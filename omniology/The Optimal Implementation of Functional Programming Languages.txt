

The
Optimal
Implemen
tation
of
F
unctional
Programming
Languages
Andrea
Asp
erti
Stefano
Guerrini


Con
ten
ts

In
tro
duction
p
age

.0.
Ho
w
to
read
this
b
o
ok
0

Optimal
Reduction

.
Some
Sharing
mec
hanisms
0
..
W
adsw
orth's
tec
hnique
0
..
Com
binators

..
En
vironmen
t
Mac
hines

.
Sharing
graphs

..
Graph
rewriting

..
Read-bac
k
and
Seman
tics


The
full
algorithm
0
.
P
airing
fans

.
Sharing
Graphs

.
The
initial
enco
ding
of
-terms

.
Lamping's
paths
0
..
Con
texts
and
prop
er
paths

.
Correctness
of
the
algorithm

..
Prop
erties
of
sharing
graphs
0
..
Corresp
ondence
b
et
w
een
sharing
graphs
and
-terms

..
Expanded
prop
er
paths

..
Pro
of
of
Theorem
..
(correctness)

..
Pro
of
of
Lemma
..
(prop
erties
of
expanded
prop
er
paths)
	
..
Pro
of
of
the
sharing
graph
prop
erties


Optimal
Reductions
and
Linear
Logic

.
In
tuitionistic
Linear
Logic

.
The
\!"
mo
dalit
y

..
Bo
xes
	



Contents
..
A
Remark
for
Categoricians
	0
.
The
duplication
problem
	

Redex
F
amili
es
and
Optimalit
y
	
.
Zig-Zag
	
..
P
erm
utation
equiv
alence
		
..
F
amilies
of
redexes
0
.
Extraction
0
..
Extraction
and
families
0	
.
Lab
eling

..
Conuence
and
Standardization

..
Lab
eled
and
unlab
eled
-calculus

..
Lab
eling
and
families
0
.
Reduction
b
y
families

..
Complete
deriv
ations

.
Completeness
of
Lamping's
algorithm

.
Optimal
deriv
ations


P
aths
	
.
Sev
eral
denitions
of
paths
0
.
Legal
P
aths

..
Reminder
on
lab
eled
-calculus

..
Lab
els
and
paths

..
The
equiv
alence
b
et
w
een
extraction
and
lab
eling

..
W
ell
balanced
paths
and
legal
paths

..
Legal
paths
and
redex
famili
es

..
Legal
paths
and
optimal
reductions

.
Consisten
t
P
aths

..
Reminder
on
prop
er
paths

..
Consistency
	
.
Regular
P
aths
	
..
The
Dynamic
Algebra
LS
	
..
A
mo
del
	
..
Virtual
Reduction
		
.
Relating
P
aths
0
..
Discriminan
ts
0
..
Legal
paths
are
regular
and
vice-v
ersa
0
..
Consisten
t
paths
are
regular
and
vice-v
ersa

.
Virtual
in
teractions

..
Residuals
and
ancestors
of
consisten
t
paths

..
F
an
annihilations
and
cycles
0

Contents


Read-bac
k

.
Static
and
dynamic
sharing

..
Grouping
sequences
of
brac
k
ets

..
Indexed
-trees
	
..
Beta
rule
	
..
Multiplexer

.
The
propagation
rules

..
Mux
in
teractions

..
Mux
propagation
rules

..
The
absorption
rule

..
Redexes

.
Deadlo
c
k
ed
redexes
0
..
Critical
pairs

..
Mux
p
erm
utation
equiv
alence

.
Sharing
morphisms

..
Sim
ulation
lemma

.
Unshared
b
eta
reduction
	
.
P
aths

.
Algebraic
seman
tics

..
Left
in
v
erses
of
lifting
op
erators

..
The
in
v
erse
semigroup
LSeq


.
Prop
er
paths
	
..
Deadlo
c
k-freeness
and
prop
erness

.	
Soundness
and
adequateness

.0
Read-bac
k
and
optimalit
y


Other
translations
in
Sharing
Graphs

.
In
tro
duction

.
The
bus
notation

.
The
bus
notation
of
the
translation
F

.
The
corresp
ondence
of
F
and
G

.
Concluding
remarks

	
Safe
No
des
	
	.
Accum
ulation
of
con
trol
op
erators
	
	.
Eliminating
redundan
t
information
	
	.
Safe
rules
	
	.
Safe
Op
erators
		
	.
Examples
and
Benc
hmarks
0
0
Complexit
y
0
0.
The
simply
t
yp
ed
case
0
0..
T
yping
Lamping's
rules



Contents
0..
The
-expansion
metho
d

0..
Sim
ulating
generic
elemen
tary-time
b
ounded
computation
0
0.
Sup
erp
osition
and
higher-order
sharing

0..
Sup
erp
osition

0..
Higher-order
sharing

0.
Conclusions
	

F
unctional
Programming
0
.
In
teraction
Systems

..
The
In
tuitionistic
Nature
of
In
teraction
Systems

.
Sharing
Graphs
Implemen
tation

..
The
enco
ding
of
IS-expressions

..
The
translation
of
rewriting
rules


The
Bologna
Optimal
Higher-order
Mac
hine

.
Source
Language

.
Reduction

..
Graph
Enco
ding

..
Graph
Reduction

.
Garbage
Collection

..
Implemen
tation
Issues

..
Examples
and
Benc
hmarks

.
Problems

..
The
case
of
\app
end"

Biblio
gr
aphy
	


In
tro
duction
This
b
o
ok
is
ab
out
optimal
sharing
in
functional
programmi
ng
lan-
guages.
The
formal
notion
of
sharing
w
e
shall
deal
with
w
as
formalized
in
the
sev
en
ties
b
y
L

evy
in
terms
of
\famili
es"
of
redexes
with
a
same
origin|
more
tec
hnically
,
in
terms
of
sets
of
redexes
that
are
residuals
of
a
unique
(virtual)
redex.
The
goal
of
his
foundational
researc
h
w
as
to
c
haracterize
formally
what
an
optimal
ly
ecient
reduction
strategy
for
the
-calculus
w
ould
lo
ok
lik
e
(ev
en
if
the
tec
hnology
for
its
implemen
tation
w
as
at
the
time
lac
king).
L

evy's
dual
goals
w
ere
c
orr
e
ctness,
so
that
suc
h
a
reduc-
tion
strategy
do
es
not
div
erge
when
another
could
pro
duce
a
normal
form,
and
optimality,
so
that
redexes
are
not
duplicated
b
y
a
reduction,
causing
a
redundancy
in
later
calculation
[L

ev,
L

ev0].
The
relev
an
t
functional
programming
analogies
are
that
call-b
y-name
ev
aluation
is
a
correct
but
not
optimal
strategy
,
while
call-b
y-v
alue
ev
aluation
is
a
(v
ery
rough)
appro
ximation
of
an
incorrect
but
\optimal"
strategy
.
L

evy
clearly
evinced
that
no
sharing
based
implemen
tati
on
of
-calculus
could
reduce
in
a
single
step
t
w
o
redexes
b
elonging
to
distinct
families.
So,
according
to
his
denition,
a
reduction
tec
hnique
is
optimal
when
(i
)
a
whole
family
of
redexes
is
con
tracted
in
a
single
computational
step
and
(ii
)
no
unneeded
w
ork
is
ev
er
done
(i.e.,
the
reduction
do
es
nev
er
con
tract
a
redex
that
w
ould
b
e
erased
b
y
a
dieren
t
reduction
strategy).
Suc
h
optimal
and
correct
implem
en
tations
w
ere
kno
wn
for
recursion
sc
hemas
[V
ui
],
but
not
for
ones
where
higher-order
functions
could
b
e
passed
as
rst-class
v
alues.
Actually
,
all
the
naiv
e
algorithms
sug-
gested
b
y
L

evy's
theory
lo
ok
ed
quite
articial
and
required
an
unfeasible
o
v
erhead
to
decide
whether
t
w
o
redexes
b
elong
to
a
same
family
.
Recen
t
researc
h
b
y
Lamping
has
sho
wn
that
there
indeed
exist
-
calculus
ev
aluators
satisfying
L

evy's
sp
ecication
[Lam	
,
Lam	0
].
The



Intr
o
duction
fact
that
more
than
ten
y
ears
elapsed
b
et
w
een
L

evy's
denition
of
op-
timalit
y
and
Lamping's
reduction
algorithm
should
already
giv
e
a
gist
of
the
complexit
y
of
the
problem.
As
a
matter
of
fact,
ha
ving
a
unique
represen
tation
for
all
the
redexes
in
a
same
family
en
tails
the
use
of
a
very
sophistic
ate
d
sharing
tec
hnique,
where
all
the
computational
and
expressiv
e
p
o
w
er
of
higher-order
languages
really
shines.
Note
in
par-
ticular
that
t
w
o
redexes
of
a
same
family
can
nest
one
in
to
the
other
(for
instance,
giv
en
R
=
(x:M
N),
its
subterms
M
and
N
ma
y
con
tain
redexes
in
the
family
of
R).
Therefore,
all
the
traditional
implem
en
ta-
tion
tec
hniques
for
functional
languages
(mostly
based
on
sup
ercom
bina-
tors,
en
vironmen
ts
or
con
tin
uations)
fail
in
a
v
oiding
useless
rep
etitions
of
w
ork:
no
mac
hinery
in
whic
h
the
sharing
is
exploited
at
the
(rst
order)
lev
el
of
subterms
can
b
e
L

evy's
optimal.
Lamping's
breakthrough
w
as
a
tec
hnique
to
share
con
texts,
that
is,
to
share
terms
with
an
unsp
ecied
part,
sa
y
a
hole.
Eac
h
instance
of
a
con
text
ma
y
ll
its
holes
in
a
distinct
w
a
y
.
Hence,
for
an
y
shared
con-
text,
there
are
sev
eral
access
p
oin
ters
to
it
and,
for
eac
h
hole,
a
set
of
p
ossible
c
hoices
for
ho
w
to
ll
it|a
c
hoice
for
eac
h
instance
of
the
con-
text.
Lamping's
solution
mo
v
ed
from
the
idea
that
some
con
trol
op
erator
should
manage
the
matc
hing
b
et
w
een
the
instances
of
a
con
text
and
the
w
a
ys
in
whic
h
its
holes
ma
y
b
e
lled.
As
a
result,
Lamping
extended
-graphs
b
y
t
w
o
sharing
no
des
called
fans:
a
\fan-in"
no
de
collecting
the
p
oin
ters
to
a
con
text;
a
\fan-out"
no
de
collecting
the
w
a
ys
in
whic
h
a
hole
can
b
e
lled
(the
exit
p
oin
ters
from
the
con
text).
Assuming
that
eac
h
p
oin
ter
collected
b
y
a
fan-in
or
fan-out
is
asso
ciated
to
a
named
p
ort,
the
corresp
ondence
b
et
w
een
en
tering
and
exiting
p
oin
ters
is
k
ept
pro
vided
to
ha
v
e
a
w
a
y
to
pair
fan-in's
and
fan-out's:
the
instance
of
the
con
text
corresp
onding
to
the
p
oin
ter
connected
to
a
fan-in
p
ort
with
name
a
lls
its
holes
with
the
subgraphs
accessed
through
the
p
orts
with
name
a
of
the
matc
hing
fan-out's.
Let
us
try
to
explain
in
more
detail
the
last
p
oin
t
b
y
a
simplied
ex-
ample.
Let
us
tak
e
the
language
of
named
angles
L
::=i
x
j
x
h,
where
x
is
a
sym
b
ol
c
hosen
o
v
er
a
giv
en
alphab
et.
In
a
string
ai
x
b
x
hc,
the
pair
of
angles
with
the
same
lab
el
x
is
matc
hing
when
the
corresp
onding
pair
of
paren
theses
matc
hes
(b
y
the
usual
rules)
in
the
expression
a
0
(b
0
)c
0
obtained
b
y
erasing
the
angles
lab
eled
b
y
y
=
x
and
replacing
\("
for
i
x
and
\)"
for
x
h.
According
to
this
denition
of
matc
hing,
t
w
o
substrings
enclosed
b
et
w
een
matc
hing
angles
ma
y
ev
en
o
v
erlap,
as
in
i
x
i
y
x
h
y
h.
The
string
b
et
w
een
t
w
o
matc
hing
angles
is
the
idealization
of
a
shared
con-
text:
a
left
angle
i
x
denotes
the
access
p
oin
t
to
a
shared
con
text,
a
righ
t

Intr
o
duction
	
angle
x
h
denotes
an
exit
p
oin
t
from
the
con
text
(i.e.,
a
hole).
Assuming
that
fans
are
binary
op
erators,
at
the
left
angle
w
e
en
ter
the
shared
part
from
one
of
t
w
o
p
ossible
c
hoices
(top
or
do
wn
for
instance);
at
a
righ
t
angle
w
e
ha
v
e
instead
t
w
o
exit
p
orts,
one
for
eac
h
w
a
y
in
whic
h
the
con-
text
can
b
e
accessed.
The
k
ey
idea
is
that
the
c
hoice
b
et
w
een
the
t
w
o
p
ossibilities
at
a
righ
t
angle
(fan-out)
is
forced
b
y
the
matc
hing:
en
tering
b
y
the
top/do
wn
p
ort
of
a
fan-in
w
e
ha
v
e
to
exit
b
y
the
top/do
wn
p
ort
of
an
y
matc
hing
fan-out.
In
the
implemen
tation
of
-calculus,
a
naiv
e
attempt
to
k
eep
trac
k
of
the
b
order
of
the
shared
parts
based
on
the
pre-
vious
lab
eling
tec
hnique
(for
more
details
see
the
example
dev
elop
ed
in
section
.)
corresp
onds
in
L
to
ha
v
e
a
rewriting
system
whose
rules
ma
y
cop
y
and/or
mo
v
e
angles
but
not
c
hange
their
names.
Unfortunately
,
suc
h
a
solution
is
not
adequate,
as
there
are
cases
in
whic
h
t
w
o
distinct
shared
parts
ha
v
e
the
same
origin
and
then
the
same
lab
el
(a
detailed
example
will
b
e
giv
en
at
the
b
eginning
of
Chapter
).
F
or
instance,
w
e
could
get
cases
as
i
x
i
x
x
h
x
h
in
whic
h
the
correct
lab
eling
corresp
onds
to
i
x
0
i
x
00
x
0
h
x
00
h.
The
actual
ac
hiev
emen
t
of
Lamping
is
the
use
of
a
dynamic
lab
el-
ing
of
fans
con
trolled
b
y
other
no
des
called
brac
k
ets.
Going
on
with
our
simplied
example,
let
us
assume
that
the
lab
els
are
in
tegers
and
that
w
e
enclose
in
to
brac
k
ets
regions
in
whic
h
the
lab
els
of
the
angles
ha
v
e
to
b
e
incremen
ted
b
y
.
That
is,
i
n
[
i
n
]
n
h
[
n
h
]
is
equiv
alen
t
to
i
n
i
n+
n
h
n+
h.
The
use
of
suc
h
brac
k
ets
allo
ws
us
to
deal
with
the
cyclic
structures
that
ma
y
arise
along
the
reduction.
F
or
instance,
reminding
that
t
w
o
shared
parts
ma
y
b
e
ev
en
nested,
it
is
immediate
to
see
that
in
order
to
share
them
w
e
need
some
in
v
olv
ed
cyclic
structure.
In
our
simplied
example,
assuming
a
corresp
ondence
b
et
w
een
our
strings
and
paths
of
the
shared
graph,
cycles
w
ould
corresp
ond
to
strings
con
taining
m
ultiple
o
ccurrences
of
the
angles
asso
ciated
to
a
same
no
de.
Ho
w
ev
er,
exploiting
the
fact
that
the
t
w
o
o
ccurrences
of
suc
h
a
no
de
ha
v
e
t
w
o
distinct
access
paths,
w
e
ma
y
main
tain
the
correct
matc
hing
using
the
brac
k
ets
to
ensure
that
t
w
o
angles
(fans)
matc
h
only
when
the
lab
els
computed
taking
in
to
accoun
t
the
brac
k
ets
coincide.
By
the
w
a
y
,
this
is
only
a
starting
p
oin
t.
In
fact,
see
Chapter
,
also
the
brac
k
ets
m
ust
b
e
lab
eled
b
y
an
index
and
ha
v
e
a
problem
of
matc
hing.
A
surprising
and
remark
able
asp
ect
of
Lamping's
algorithm
(and
its
seman
tics)
is
its
tigh
t
relation
to
Girard's
Linear
Logic
and
in
particular
with
that
deep
analysis
of
the
mathematical
foundations
of
op
erational
seman
tics
that
go
es
under
the
name
of
\Geometry
of
In
teraction"
(GOI).
In
particular,
our
previous
example
can
b
e
directly
reform
ulated
in
the

0
Intr
o
duction
language
of
GOI.
As
a
matter
of
fact,
GOI
is
essen
tially
based
on
an
algebraic
in
terpretation
of
graph
paths:
a
w
eigh
t
is
asso
ciated
to
eac
h
path
forcing
to
0
the
v
alue
of
the
wrong
ones.
Namely
,
in
the
dynamic
algebra
of
GOI
there
are
t
w
o
sym
b
ols
r;
s
and
their
duals

r;

s
corresp
ond-
ing
to
our
angled
paren
theses|the
pair
r
and
s
corresp
onds
to
the
pair
top
and
do
wn.
The
axioms
are:

rr
=

=

ss
and

rs
=
0
=

sr.
In
practice,
a
wrong
brac
k
eting
yields
0,
while
a
correct
and
fully
balanced
brac
k
eting
yields
;
the
other
cases
corresp
ond
to
correct
expressions
with
some
un
balanced
paren
theses.
According
to
this
w
e
ha
v
e

r

ssr
=

and

r

srs
=
0.
The
reindexing
w
e
denoted
b
y
brac
k
ets
corresp
ond
in
GOI
to
an
op
eration
\!"
for
whic
h
x!(P
)
=
!(P
)x
and
!(PQ)
=
!(P
)!(Q),
where
x
is
either
r
or
s.
Hence,
!(

r)

s!(r)s
=
,
since
!()
=
.
In
general,
the
study
of
optimal
reduction
has
pro
vided
imp
ortan
t
in-
sigh
ts
and
connections
b
et
w
een
linear
logic,
con
trol
structures,
con
text
seman
tics,
geometry
of
in
teraction,
in
tensional
seman
tics.
Other
rela-
tions,
in
particular
with
game
seman
tics
and
the
area
of
full
abstraction
lo
ok
at
hand,
but
ha
v
e
not
b
een
really
exploited,
y
et.
This
is
actually
the
most
in
triguing
nature
of
optimalit
y:
a
w
onderfull,
tough
mathe-
matical
theory
applied
to
a
v
ery
practical
problem:
sharing.
And
this
is
also
the
leading
theme
of
the
b
o
ok,
whic
h
in
tends
to
co
v
er
optimal
im-
plemen
tations
issues
from
the
most
theoretical
to
the
most
pragmatical
ones.
.0.
How
to
r
e
ad
this
b
o
ok
The
structure
of
the
b
o
ok
is
quite
complex.
Since,
probably
,
it
is
not
a
go
o
d
ide
a
to
r
e
ad
it
se
quential
ly
(unless
y
ou
really
wish
to
b
ecome
an
exp
ert
in
this
eld)
w
e
feel
comp
elled
to
add
some
\reading
instructions"
(w
e
usually
detest
them).
First
of
all
let
us
briey
explain
the
con
ten
t
of
eac
h
c
hapter.
Chapter
:
Optimal
Reduction
This
c
hapter
pro
vides
a
hop
efully
friendly
approac
h
to
the
(pragmatical)
problem
of
optinal
shar-
ing.
Sev
eral
sharing
mec
hanisms
are
discussed
(W
adsw
orth's
graph
reduction,
com
binators
and
en
vironmen
t
mac
hines),
and
Lamping's
\abstract"
reduction
algorithm
is
in
tro
duced.
Chapter
:
The
F
ull
Algorithm
Here
w
e
in
tro
duce
all
the
tec
hnol-
ogy
of
sharing
graphs,
and
its
con
text-seman
tics.
Y
ou
can
skip
section
.
(correctness)
at
rst
reading.
Chapter
:
Optimal
Reduction
and
Linear
Logic
A
naiv
e
in
tro-

Intr
o
duction

duction
to
the
relation
b
et
w
een
Optimalit
y
and
Linear
Logic.
Y
ou
can
denetely
skip
it
if
y
ou
are
not
in
terested
in
this
topic.
Ho
w
ev
er,
in
its
simplicit
y
,
it
ma
y
oer
y
ou
an
alternativ
e
in-
tuition
on
Optimal
Reduction
(or,
con
v
ersely
,
a
simple
in
tro-
duction
to
Linear
Logic,
in
case
y
ou
are
not
acquain
ted
with
it).
Chapter
:
Redex
F
amilies
and
Optimalit
y
The
formal
denition
of
optimalit
y
,
at
last!
Wh
y
did
w
e
p
ostp
one
it
up
to
Chap-
ter
?
W
ell,
the
b
o
ok
is
mainly
addressed
to
Computer
Sci-
en
tists,
whic
h
are
supp
osed
to
ha
v
e
some
clear
in
tuition
of
the
problem
of
sharing.
Y
ou
do
not
really
need
the
formal
denition
of
family
in
order
to
appreciate
the
b
eaut
y
and
the
expressiv
e-
ness
of
sharing
graphs.
But,
and
here
things
start
getting
really
in
triguing,
this
reduction
tec
hnique
relies
on
an
ev
en
more
b
e-
atifull
and
comp
elling
mathematical
theory!
Chapter
:
P
aths
The
w
a
y
w
e
giv
e
seman
tics
to
sharing
graphs
is
b
y
reading
paths
inside
them.
But
this
kind
of
path
seman
tics
has
b
een
in
tro
duced
for
the
rst
time
in
a
totally
dieren
t
setting:
the
geometry
of
in
teraction
of
Linear
Logic.
An
y
relation?
Read
this
c
hapter
if
y
ou
w
an
t
to
learn
the
answ
er.
Chapter
:
Read-bac
k
.
In
this
c
hapter
w
e
will
pursue
a
more
syn-
tactical
study
of
the
prop
erties
of
sharing
graphs
and
w
e
will
presen
t
a
w
a
y
to
group
con
trol
no
des
allo
wing
to
solv
e
and
sim-
plify
the
problem
of
read-bac
k.
Chapter
:
Other
translation
s
in
sharing
graphs
Sharing
graphs
are
the
real
thing.
But
y
ou
ma
y
enco
de
-terms
in
to
sharing
graphs
in
a
n
um
b
er
of
dieren
t
w
a
ys.
Here
w
e
just
men
tion
a
few
of
them,
relating
them
b
y
the
so
called
\bus
notation".
Chapter
	:
Safe
Rules
The
most
anno
ying
problem
of
optimal
re-
duction
is
the
accum
ulation
of
spurious
b
o
ok-k
eeping
informa-
tion.
In
this
c
hapter
w
e
discuss
this
problem
and
giv
e
a
partial,
but
practical
solution.
Chapter
0:
Complexit
y
Ha
v
e
a
glance
at
this
c
hapter
as
so
on
as
y
ou
can.
It's
not
the
complexit
y
result
that
matters,
at
rst
reading
(optimal
-reduction
is
not
elemen
tary
recursiv
e),
but
the
examples
of
sharing
graphs,
and
their
reduction.
Chapter
:
F
unctional
Programming
So
far,
w
e
ha
v
e
b
een
in
the
comfortable
setting
of
-terms.
No
w,
w
e
start
adding
a
few
\-rules".
Chapter
:
The
Bologna
Optimal
Higher-order
Mac
hine
Y
es,
it


Intr
o
duction
w
orks!
A
real,
optimal
implemen
tation
of
a
core
functional
lan-
guage,
freely
a
v
ailable
b
y
ftp.
& Linear Logic
Chapter 3: Opt. 
Section 2.5:
Correctness
Chapter 4:
Families
Sections 2.1-2.4:
Full algorithm
Chapter 8:
Complexity
Introduction
Chapter 1:
Chapter 5:
Paths
Chapter 7:
Safe rules
Other Translations
Chapter 6:
Read-back
Chapter 9:
Extensions
Chapter 10:
BOHM
Chapter 11:
Fig.
..
Dep
endency
graph
of
the
b
o
ok.
No
w,
there
are
sev
eral
dieren
t
\access
paths"
to
all
the
material
co
v-
ered
b
y
this
b
o
ok,
dep
ending
on
y
our
in
terests
and
cultural
formation.
W
e
just
men
tion
a
few
p
ossibilities.
First
reading
If
y
ou
are
just
in
terested
to
understand
what
all
this
story
of
optimalit
y
is
ab
out,
and
to
ha
v
e
a
closer
lo
ok
at
sharing
graphs,
w
e
suggest
to
start
with
the
in
tro
duction
to
Optimal
Reduction
in
Chapter

(this
c
hapter
is
ob
viously
c
ompulsory
in
ev
ery
\access
paths"),
jumping
then
to
Chapter
,
where
a
lot
of
in
teresting
examples
of
sharing
graphs
are
discussed
(that
should
b
e
enough
to
get
a
gist
of
the
actual
p
o
w
er
of
this
formalism
).
If
y
ou
get
in
trigued
b
y
the
problem
of
the
correct

Intr
o
duction

matc
hing
of
fan,
y
ou
can
then
ha
v
e
a
lo
ok
at
the
rst
sections
of
Chapter
,
up
to
section
.
or
.
(section
.
is
rather
tec
hnical
and
it
can
b
e
skipp
ed
at
rst
reading!).
On
the
other
side,
if
y
ou
are
in
terested
in
the
formal
denition
of
optimal
sharing,
please
glance
at
Chapter
.
Implemen
tati
on
If
y
ou
are
in
terested
in
implemen
tativ
e
issues,
and
y
ou
wish
to
understand
what
are
the
op
en
problems
in
this
area,
y
ou
m
ust
ev
en
tually
read
sections
.{.
(again,
y
ou
can
skip
section
.).
Then,
jump
to
Chapter
,
and
read
sequen
tially
the
remaining
part
of
the
b
o
ok.
-calculus
So,
y
ou
are
an
imp
eniten
t
theorician,
y
ou
don't
kno
w
an
y-
thing
ab
out
sharing
(ma
yb
e
y
ou
do
not
ev
en
care),
but
p
eople
told
y
ou
it
could
b
e
w
orth
to
ha
v
e
a
lo
ok
at
this
b
o
ok.
Go
o
d.
Y
ou
had
probably
b
etter
start
with
Chapter

(the
formal
de-
nition
of
optimalit
y),
and

(paths),
coming
bac
k
to
Chapter

for
all
the
references
to
sharing
graphs
and
optimal
reduction.
When
y
ou
feel
ready
,
y
ou
ma
y
start
tac
kle
section
.
(correct-
ness)
and
Chapter

(read-bac
k).
Linear
Logic
Y
ou
are
in
terested
in
linear
logic,
and
y
ou
wish
to
under-
stand
what
is
the
relation
with
optimalit
y
.
F
or
an
\elemen
tary"
in
tro
duction,
start
reading
Chapter

(this
requires
Chapter

as
w
ell).
Ho
w
ev
er,
the
real
sta
is
con
tained
in
Chapter

(paths),
and
Chapter

(read-bac
k).
A
discussion
of
the
p
oten
tial
rele-
v
ance
of
additiv
e
t
yp
es
in
the
setting
of
optimalit
y
is
also
con-
tained
in
section
.
(problems).


Optimal
Reduction
In
the
-calculus,
whenev
er
w
e
execute
a
-reduction
(x:M
N)
!
M[N=x]
w
e
replace
eac
h
o
ccurrence
of
the
b
ound
v
ariable
x
in
M
b
y
a
cop
y
of
the
argumen
t
N.
This
op
eration
could
ob
viously
duplicate
w
ork,
since
an
y
reduction
required
to
simplify
the
argumen
t
will
b
e
rep
eated
on
eac
h
cop
y
.
A
t
rst
glance,
it
could
seem
that
c
ho
osing
a
innermost
reduction
strategy
(i.e.,
reducing
argumen
ts
rst)
w
e
w
ould
easily
solv
e
this
prob-
lem,
simply
b
ecause
w
e
w
ould
a
v
oid
cop
ying
redexes.
Unfortunately
,
this
is
not
true.
First
of
all,
w
e
should
also
a
v
oid
to
reduce
useless
redexes
(i.e.,
b
y
the
standardization
theorem,
redexes
not
reduced
in
the
leftmost-outermost
reduction),
but
they
cannot
b
e
found
eectiv
ely
in
the
lam
b
da-calculus.
Moreo
v
er,
and
this
is
the
crucial
p
oin
t,
ev
en
a
reduction
strategy
that
alw
a
ys
reduces
ne
e
de
d
in
ternal
redexes
is
not
guaran
teed
to
reac
h
the
normal
form
(if
it
exists)
in
a
minima
l
n
um
b
er
of
steps.
F
or
example,
in
the
case
of
the
I-calculus,
where
all
redexes
are
needed
for
computing
the
normal
form,
innermost
reductions
could
not
b
e
optimal.
T
ak
e
for
instance
the
term
M
=
(x:(x
I)
y:(
(y
z))),
where
I
=
w:w
and

=
x:(x
x).
The
normal
form
of
M
is
(z
z).
Some
reduction
strategies
for
M
are
sho
wn
in
Figure
..
In
particular,
the
in
ternal
strategies
(on
the
righ
t
in
the
gure)
are
not
the
shortest
ones.
The
reason
is
that
they
duplicate
a
sub
expression
(y
z)
whic
h
is
not
y
et
a
redex,
but
that
will
b
ecome
a
redex
later
on,
when
y
will
b
e
instan
ti-
ated
to
the
iden
tit
y
(b
y
the
outermost
redex).
Note
that
the
redex
(I
z)
is
in
tuitiv
ely
sharable,
and
it
is
actually
shared
b
y
the
reduction
on
the
left
in
Figure
..
A
deep
er
analysis
of
the
previous
example
allo
ws
us
to
in
tro
duce
the
core
idea
of
optimal
reductions:
ev
en
if
the
subterm
(y
z)
of
M
is
not
a
redex,
reducing
M
the
term
I
will
substitute
y
creating
a
redex
(I
z).
In
a
certain
sense,
the
sub
expression
(y
z)
is
a
\virtual
redex".
More


Optimal
R
e
duction

∆
(    (I z) )
(    y.(    (y z)) I )
λ
∆
λ
λ
(    x.(x I)      y.( (y z) (y z) )  )
(    y.( (y z) (y z) )  I )
λ
(    z)
∆
M
((I z) (I z))
(z (I z))
((I z) z)
(z  z)
Fig.
..
M
=
(x:(x
I)
y:(
(y
z)))
accurately
,
w
e
could
uniquely
describ
e
the
virtual
redex
corresp
onding
to
(y
z)
as
a
path
of
the
abstract
syn
tax
tree
of
M
leading
from
the
application
in
(y
z)
to
the

of
the
iden
tit
y
,
as
sho
wn
in
Figure
..
T
o
nd
the
path
of
the
virtual
redex
(y
z)
let
us
pro
ceed
as
follo
ws.
Lea
ving
the
@
no
de
of
(y
z)
through
its
left
edge
a,
w
e
w
ould
immedi-
ately
nd
a
redex
if
at
the
other
end
of
a
there
w
ould
b
e
a

no
de.
In
this
case,
there
is
a
v
ariable
y.
W
e
ha
v
e
not
y
et
a
redex
but
it
could
b
ecome
a
redex
if
y
get
substituted
b
y
a
-abstraction,
that
is
if
the
binder
of
y
is
the
left
part
of
a
(virtual!)
redex
ha
ving
as
righ
t
part
a
-abstraction.
So,
let
us
push
in
a
stac
k
the
initial
question
ab
out
y,
and
pro
ceed
asking
if
y
is
the
left
part
of
a
virtual
redex.
T
o
this
purp
ose,
let
us
mo
v
e
bac
k
from
w
to
the
ab
o
v
e
application
follo
wing
the
edge
b,
and
then
let
us
go
do
wn
through
the
edge
c.
The
edge
c
is
a
redex
and
the
v
ariable
b
ound
b
y
x
o
ccurs
as
left
argumen
t
of
an
@
no
de.
The
path
bcd
is
then
a
virtual
redex:
it
corresp
onds
to
the
term
(x
w:w),
in
whic
h
after
the
con
traction
of
c
the
abstraction
y:(
(y
z))
will
tak
e
the
place
of
the
v
ariable
x.
P
opping
from
the
stac
k
our
initial
question
ab
out
y,
w
e
see
th
us
that
the
path
abcde
giv
es
a
connection
b
et
w
een
the
@
no
de
of
(y
z)
and
the
ro
ot
of
a
subterm
that
will
replace
y
after
some
reductions.
Therefore,
since
the
edge
e
reac
hes
a
-abstraction,
the
path
abcde
corresp
onds
to
the
virtual
redex
(y
z).
Moreo
v
er,
note
that,
if
w
e
imagine
that
b
ound
v
ariables
are
explicitly
connected
to
their


Optimal
R
e
duction
w
e
@
λ
x
λ
@
@
@
∆
z
y
w
λ
@
λ
λ
∆
@
y
z
z
@
@
∆
λ
w
e
@
b
abcde
dcb
c
a
d
a
x
y
y
w
w
w
Fig.
..
Virtual
redexes
and
paths.
binders
(an
idea
that
go
es
bac
k
to
Bourbaki),
this
\path"
is
an
actual
path
in
the
graph
represen
tation
of
M.
A
complete
denition
of
the
\paths"
corresp
onding
to
virtual
redexes
will
b
e
giv
en
in
Chapter
.
Here,
let
us
note
that,
b
y
means
of
a
simple
lab
eling
tec
hnique,
w
e
ha
v
e
b
een
able
to
lab
el
eac
h
edge
created
along
the
reduction
b
y
a
corresp
onding
path
in
the
initial
term,
and
that,
in
tuitiv
ely
,
the
edge
w
as
exactly
created
b
y
\con
traction"
of
this
path.
F
or
instance,
the
edge
dcb
in
Figure
.
is
the
result
of
the
con
traction
of
the
corresp
onding
path
(note
the
order
of
the
lab
els!),
while
the
redex
edge
abcde
is
the
con
traction
of
the
path
of
the
virtual
redex
(y
z).
T
o
implemen
t
optimal
reductions
w
e
m
ust
a
v
oid
the
duplication
of
explicit
and
virtual
redexes.
Pursuing
the
analogy
with
paths,
w
e
ha
v
e
to
nd
some
reduction
tec
hnique
that
compute
the
normal
form
of
a

Optimal
R
e
duction

term
without
duplicating
(or
computing
t
wice)
any
p
ath
c
orr
esp
onding
to
a
virtual
r
e
dex.
The
constrain
t
to
nev
er
duplicate
a
path
reects
in
an
ordering
con-
strain
t
b
et
w
een
redexes.
F
or
instance,
in
the
previous
example
it
en
tails
to
p
ostp
one
the
innermost
redex
(
(y
z))
after
the
reduction
of
the
(vir-
tual)
redex
(whose
path
is)
con
tained
in
abcde.
Namely
,
it
means
to
start
with
the
outermost
redex
of
M,
to
reduce
the
redex
(I
z)
created
b
y
it
and,
only
at
this
p
oin
t,
to
con
tract
the
redex
in
v
olving
.
Suc
h
a
reduction
strategy
corresp
onds
to
the
one
on
the
left-hand
side
in
Fig-
ure
.,
whic
h
in
this
case
is
also
the
optimal
one.
But
what
it
w
ould
ha
v
e
happ
ened
if
the
outer-most
redex
had
duplicated
its
argumen
t
at
is
turn?
The
ordering
b
et
w
een
redexes
suggested
b
y
the
non-duplication
constrain
t
of
virtual
redex
paths
w
ould
ha
v
e
b
een
unsatisable.
L

evy
ga
v
e
a
clear
example
of
ho
w
the
eect
of
duplication
of
needed
redexes
can
com
bine
in
a
v
ery
subtle
and
nast
y
w
a
y
.
Let
us
dene
the
follo
wing
-terms:

n
=
x:(x
x
:
:
:
x
|
{z
}
n
times
)
F
n
=
x:(x
I
x
x
:
:
:
x
|
{z
}
n
times
)
G
n
=
y:(
n
(y
z))
G
0
n
=
y:((y
z)
(y
z)
:
:
:
(y
z)
|
{z
}
n
times
)
The
reduction
of
the
term
P
=
(F
m
G
n
)
is
depicted
in
Figure
..
The
sequence
on
the
left-hand
side,
whose
length
is
n
+

is
a
t
ypical
inner-most
reduction.
The
one
on
the
righ
t-hand
side
follo
ws
instead
an
outer-most
strategy
and
requires
m
+

-reductions.
The
shortest
reduction
strategy
dep
ends
th
us
from
the
v
alue
of
m
and
n.
It
is
remark
able
that,
in
this
case,
every
r
e
duction
str
ate
gy
duplic
ates
work!
Indeed,
the
strategy
on
the
righ
t-hand
side
shares
the
reduction
of
G
n
to
G
0
n
,
but
not
the
reduction
of
(I
z)
to
z.
The
con
v
erse
happ
ens
for
the
reduction
strategy
on
the
left-hand
side.
Exercise
.0.
T
ry
to
guess
the
paths
of
the
virtual
redexes
of
P
;
=
(F

G

).
Sho
w
that
an
y
con
traction
of
a
redex
of
P
;
causes
the
dupli-
cation
of
a
virtual
redex
observing
that
it
causes
the
duplication
of
a
corresp
onding
path.


Optimal
R
e
duction
 Q =  (z z . . . zG’ G’
G’ )
n
n
n
 . . . 
)
n
G’
. . . 
n
G’
n
G’
( I z )
( I z ) ( I z ) . . .
=  (
Q 3
)
P3 =  (∆  n z G G  . . . G
n
n
n
 . . . G
P2 =  (∆  n( I  z )  Gn Gn
n )
P =  (  G I G
1
n
n Gn
G
 . . . 
n )
 . . . 
z
G
G
n
z z . . . Gn
)
n
P4 =  (
2
Q
G’
=  (
n
G’
G’
 I 
n
n
. . . G’n )
)
Q
G’n
m
=  ( F  
1
*
*
P
Fig.
..
P
=
(F
m
G
n
)
Besides,
supp
osing
to
ha
v
e
an
optimal
implem
en
tation
where
no
du-
plication
is
ev
er
done,
what
could
w
e
sa
y
ab
out
the
reduction
of
P
?
In
suc
h
an
optimal
mac
hine,
all
the
reductions
of
P
should
b
e
equiv
alen
t.
In
fact,
suc
h
an
implemen
tatio
n
w
ould
corresp
ond
to
reduce
at
eac
h
step
all
the
copies
of
a
giv
en
redex.
The
term
P
has
only
four
distinguished
redexes.
Therefore,
the
reductions
of
suc
h
an
optimal
mac
hine
w
ould
corresp
ond
to
the
diagram
of
Figure
..
P
 Q
P
Q
P
P
Q
1
2
3
1
Q2
3
Fig.
..
P
=
(F
m
G
n
)
L

evy's
example
pro
v
es
not
only
that
the
problem
of
optimal
reduc-

Optimal
R
e
duction
	
tion
cannot
b
e
simply
solv
ed
b
y
the
c
hoice
of
a
suitable
reduction
strat-
egy
,
but
also
that,
if
an
implemen
tation
without
duplication
exist,
its
exp
ected
p
erformance
w
ould
b
e
arbitrarily
b
etter
than
an
y
reduction
tec
hnique
without
optimal
sharing.
Another
in
teresting
example
is
diusely
discussed
b
y
Lamping
[Lam	
].
Let
R
=
g:(g(g
I)),
and
tak
e
S
=
(R
h:(R
(h
I)))
(it
is
easy
to
see
that
S
reduces
to
the
iden
tit
y).
Again,
w
e
are
in
the
same
situation.
If
the
outermost
redex
is
reduced
rst,
w
e
ev
en
tually
create
t
w
o
copies
of
the
innermost
one.
Con
v
ersely
,
if
w
e
start
executing
the
innermost
redex,
w
e
duplicate
the
\virtual
redex"
(h
I)
(that
requires
the
ring
of
the
outermost
redex,
in
order
to
b
ecome
an
actual
redex).
In
particular,
four
copies
of
the
application
(h
I)
will
need
to
b
e
simplied,
if
the
in-
ner
redex
is
reduced
rst,
compared
to
only
t
w
o
copies
if
the
outermost
redex
is
reduced
rst
(one
for
eac
h
distinct
v
alue
of
the
argumen
t
h).
All
these
examples
migh
t
lo
ok
quite
articial,
and
one
could
easily
w
onder
what
is
the
actual
and
practical
relev
ance
of
optimal
implemen-
tation
tec
hniques.
F
rom
this
resp
ect,
it
is
probably
imp
ortan
t
to
stress
some
other
essen
tial
prop
erties
of
optimalit
y
.
The
only
reason
b
ecause
in
the
-calculus
dieren
t
reduction
strategies
ha
v
e
dieren
t
lengths
is
the
duplication
of
redexes
(as
long
as
w
e
tak
e
care
to
reduce
\needed"
redexes
only).
Supp
osing
to
ha
v
e
an
implemen-
tation
tec
hnique
that
a
v
oids
these
duplications,
all
reduction
strategies
w
ould
b
e
absolutely
equiv
alen
t.
More
precisely
,
the
rewriting
system
w
ould
satisfy
a
one-step
diamond
prop
ert
y
.
Since
ev
en
in
the
case
of
optimalit
y
the
leftmost-outermost
reduction
do
es
only
reduce
needed
redexes,
it
simply
jumps
o
v
er
the
(undecidable!)
problem
of
establish-
ing
the
shortest
reduction
strategy
.
In
particular,
an
optimal
reduction
tec
hnique
is
able
to
com
bine
all
the
b
enets
of
lazy
and
strict
strategies.
Moreo
v
er,
and
this
is
a
crucial
p
oin
t,
an
optimal
implemen
tatio
n
im-
plicitly
solv
es
the
w
ell
kno
wn
problem
of
\computing
inside
a
"
(al-
most
all
implemen
tatio
ns
of
functional
languages
circum
v
en
t
this
prob-
lem
adopting
a
w
eak
notion
of
v
alue
that
prev
en
ts
an
y
sharing
inside
a
).
The
relev
ance
of
this
p
oin
t
should
b
e
correctly
understo
o
d.
Consider
for
instance
the
-term
(n

I
a),
where
n
and

are
the
Ch
urc
h
in
tegers
of
n
and
,
and
a
is
some
constan
t.
Note
that
(
I)
!
I.
So,
adopting
an
innermost
reduction
strategy
,
w
e
get
the
normal
form
a
in
a
n
um
b
er
of
-reduction
steps
linear
in
n.
Ho
w
ev
er,
ev
en
in
t
ypical
strict
functional
languages
(lik
e
SML
or
CAML),
the
computation
of
(n

I
a)
is
exp
o-
nen
tial
in
n.
The
reason
is
that
the
reduction
of
(
I)
stops
at
the
w
eak
head
normal
form,
namely
(some
in
ternal
represen
tation
of
)
y:(I(Iy)).

0
Optimal
R
e
duction
The
t
w
o
applications
of
the
iden
tit
y
are
not
reduced,
and
they
will
b
e
ev
en
tually
duplicated
when
this
term
is
passed
as
an
argumen
t
to
the
successiv
e
.
A
t
the
end,
w
e
are
left
with

n
applications
of
the
iden
tit
y
to
b
e
reduced.
The
situation
is
ev
en
w
orse
in
lazy
languages,
suc
h
as
Sc
heme,
Hask
ell
or
Miranda.
The
usual
ob
jection
of
the
old,
w
eek-ev
aluation
sc
ho
ol
of
functional
programming
is
that:
\stopping
reduction
under
a
lam
b
da
mak
es
go
o
d
practical
sense
as
it
prev
en
ts
problems
asso
ciated
with
reduction
of
op
en
terms.
y
"
Sure,
as
w
ell
as
P
ascal
mak
es
go
o
d
practical
sense
as
it
prev
en
ts
prob-
lems
asso
ciated
with
returning
functions
as
results.
But
the
purp
ose
of
Computer
Science,
if
an
y
,
is
just
to
study
and
p
ossibly
to
solv
e
problems,
not
just
\prev
en
ting"
them,
isn't
it?
.
Some
Sharing
mec
hanisms
By
the
previous
discussion,
it
is
clear
that
no
satisfactory
notion
of
sharing
can
b
e
obtained
without
lea
ving
the
syn
tactical
univ
erse
of
-
expressions
and
the
usual
notion
of
reduction
strategy
.
In
other
w
ords,
w
e
ha
v
e
to
lo
ok
for
some
represen
tation
of
-terms
inside
dieren
t
struc-
tures
with
some
(explicit
or
implicit)
sharing
mec
hanism.
..
Wadsworth's
te
chnique
A
rst
attempt
in
this
direction
w
as
pro
vided
b
y
W
adsw
orth's
graph
reduction
tec
hnique
[W
ad
].
W
adsw
orth
suggested
to
represen
t
-
expressions
as
directed
acyclic
graphs
similar
to
abstract
syn
tax
trees
plus
p
oin
ters
for
implemen
ting
sharing.
In
W
adsw
orth's
graphs,
iden
ti-
cal
subtrees
(iden
tical
sub
expressions)
are
represen
ted
b
y
a
single
piece
of
graph.
As
a
consequence,
the
reduction
of
a
-redex
x:(M
N)
do
es
not
require
cop
ying
the
argumen
t
N:
eac
h
o
ccurrence
of
x
in
M
is
simply
link
ed
to
N.
Moreo
v
er,
an
y
simplication
in
a
shared
section
of
a
graph
corresp
onds
to
m
ultiple
simplications
in
the
corresp
onding
-term.
F
or
instance,
the
W
adsw
orth
graph
normal
(leftmost-outermost)
re-
duction
of
the
term
M
=
(
x:((x
y)
I))
is
represen
ted
in
Figure
..
y
Anon
ymous
referee.

.
Some
Sharing
me
chanisms

@
λ
@
x
λ
@
x
x
y
x
@
I
x
@
λ
@
x
x
y
@
I
@
@
y
I
@
y
Fig.
..
W
adsw
orth's
reduction
The
corresp
onding
reduction
in
the
usual
syn
tactical
framew
ork
of
-
terms
is:
M
!
(x:((x
y)
I)
x:((x
y)
I))

!
((I
y)
(I
y))

!
(y
y)
W
e
see
that
the
second
and
third
step
sim
ultaneously
con
tract
b
oth
the
copies
of
the
redexes
x:((x
y)
I)
and
(I
y)
con
tained
in
the
corresp
onding
terms.
Unfortunately
,
cop
ying
is
required
also
in
W
adsw
orth's
algorithm
as
so
on
as
the
-term
in
v
olv
ed
in
a
redex
is
represen
ted
b
y
a
shared
piece
of
graph.
Otherwise,
the
substitution
called
for
b
y
the
-reduction
w
ould
instan
tiate
other
instances
of
the
b
o
dy
of
the
function
whic
h
ha
v
e
noth-
ing
to
do
with
the
curren
t
redex.
Consider
for
instance
the
-term
N
=
(x:((x
y)
(x
z))
w:(I
w))
After
the
outermost
-reduction,
the
argumen
t
w:(I
w)
is
shared
b
y
the
t
w
o
o
ccurrences
of
x.
A
t
the
follo
wing
step,
only
the
rst
instance
of
w:(I
w)
should
b
e
in
v
olv
ed
in
the
redex
(w:(I
w)y).
W
adsw
orth's
algorithm
pro
ceed
th
us
to
the
duplication
of
the
functional
argumen
t
of
the
redex.
But
in
this
w
a
y
,
it
duplicates
the
in
ternal
redex
(I
w),
that
on
the
con
trary
should
b
e
shared
in
the
t
w
o
instances.
Despite
this
example
could
b
e
solv
ed
b
y
reducing
the
functional
argumen
t
rst,
in
the
general
case,
the
problem
cannot
b
e
xed
just
c
hanging
the
reduction
strategy
,(as
w
e
already
remark
ed
at
the
b
eginning
of
the
c
hapter.
The
reason
is
that
the
applications
inside
the
functional
argumen
t
could
b
e
\virtual
redexes"
(supp
ose
that
in
the
place
of
I
there
b
e
a
v
ariable
b
ound
externally
to
w:(I
w),
and
note
that
w
e
are
not
follo
wing
a


Optimal
R
e
duction
leftmost-outermost
strategy
an
y
more).
The
duplication
of
suc
h
\virtual
redexes"
(i.e.,
of
the
application
(y
w))
is
as
useless
and
exp
ensiv
e
as
the
duplication
of
real
redexes.
As
an
instructiv
e
example,
w
e
suggest
the
reader
to
try
W
adsw
orth
graph
reduction
tec
hnique
on
L

evy's
example
in
Figure
..
He
will
immedia
tely
realize
that
no
reduction
strategy
is
optimal,
w
orking
with
W
adsw
orth's
structures.
..
Combinators
Graph
reduction
can
b
e
easily
adapted
to
w
ork
with
c
ombinators,
instead
of
-expressions.
Com
binators
(either
of
Com
binatory
Logic
or
Sup
er-
Com
binators)
are
used
to
split
a
-reduction
step
in
to
a
sequence
of
sim-
pler
(rst
order)
reductions,
that
essen
tially
corresp
ond
to
an
explicit
mo
deling
of
the
substitution
pro
cess.
While
W
adsw
orth's
-reduction
alw
a
ys
requires
the
duplication
of
the
function
b
o
dy
,
the
corresp
onding
com
binator
reduction
is
t
ypically
able
to
a
v
oid
cop
ying
all
the
sub
ex-
pressions
that
do
not
con
tain
the
v
ariable
b
ound
b
y
the
.
Nev
ertheless,
this
is
not
enough
to
a
v
oid
duplication
of
w
ork.
Let
us
consider
a
simple
example
for
the
Com
binatory
Logic
(CL)
case.
A
t
ypical
enco
ding
of
-abstraction
in
to
CL
is
dened
b
y
the
follo
wing
rules:


x:x
=
SKK


x:M
=
KM
if
x

var
(M)


x:(M
N)
=
S(

x:M)(

x:N)
A
-term
is
then
inductiv
ely
translated
in
to
CL
as
follo
ws:
[x]
CL
=
x
[(M
N)]
CL
=
[M]
CL
[N]
CL
[x:M]
CL
=


x:[M]
CL
Let
us
tak
e
the
-term
M
=
(x:(x(x
y))
z:(A
B)).
Applying
the
previous
rules,
w
e
get
[z:(A
B)]
CL
=
S(

z:[A]
CL
)(

z:[B]
CL
).
W
e
see
that
after
the
translation,
the
in
ternal
application
(A
B)
is
split
and
the
t
w
o
terms
[A]
CL
and
[B]
CL
b
ecome
the
argumen
ts
of
the
com
binator
S.
After
a
few
reduction
steps,
w
e
ev
en
tually
come
to
the
graph
in
Figure
..
A
t
this
p
oin
t,
the
p
ortion
of
graph
enclosed
in
the
dotted
line
m
ust
b
e
duplicated
(usually
,
this
duplication
step
comes
together
with
the
reduction
of
the
leftmost-outermost
instance
of
S,
so
it
is
not
alw
a
ys

.
Some
Sharing
me
chanisms

λ*z . [A]
CL
@
y
@
@
@
S
λ*z . [B]
CL
Fig.
..
Com
binatory
Logic
reduction
explicit).
Unfortunately
,
this
duplication
amoun
ts
to
a
duplication
of
the
application
(A
B)
in
the
corresp
onding
-term.
If
this
application
w
as
a
redex
(either
actual
or
virtual),
w
e
denitely
lo
ose
the
p
ossibilit
y
of
sharing
its
reduction.
Let
us
consider
another
example.
Let
M
=
(
I)
(where
I
=
SKK
).
In
Com
binatory
Logic,
this
term
do
es
not
reduce
to
I,
but
to
the
term
S(K
I)(S(K
I)
I),
where
the
t
w
o
in
ternal
applications
of
the
iden
tit
y
are
\frozen"
as
argumen
ts
of
S.
If
this
term
is
shared
b
y
other
terms,
the
in
ternal
applications
will
b
e
ev
en
tually
duplicated:
for
this
reason,
the
reduction
of
(n

I
a)
is
exp
onen
tial
in
n,
in
Com
binatory
Logic
(while
w
e
ha
v
e
seen
that
there
exists
a
linear
normalizing
deriv
ation
for
this
term,
and
th
us,
a
p
osteriori,
a
linear
optimal
reduction).
The
previous
examples
are
a
consequence
of
the
particular
enco
ding
of
-abstraction
in
to
Com
binatory
Logic,
but
not
of
the
reduction
strategy
.
As
a
matter
of
fact,
it
is
p
ossible
to
pro
v
e
that
leftmost-outermost
graph
reduction
of
com
binators
is
optimal.
The
problem
is
that
optimalit
y
in
Com
binatory
Logic
has
v
ery
little
to
do
with
optimalit
y
in
-calculus.
Moreo
v
er,
although
one
could
consider
dieren
t
enco
dings
of
-abstraction,
the
problem
ab
o
v
e
seems
to
b
e
completely
general:
in
an
y
translation
of
a
-term
M
in
to
a
CL-term
M
0
,
there
will
b
e
applications
in
M
whic
h
are
not
translated
as
applications
in
M
0
,
but
co
ded
as
argumen
ts
of
some
S.
When
one
of
these
S
is
shared,
it
m
ust
b
e
duplicated,
that
im-
plies
a
blind
(not
optimal)
duplication
of
the
corresp
onding
-calculus
application.


Optimal
R
e
duction
The
situation
is
similar
for
Sup
erCom
binators.
Consider
for
instance
the
term
(

I
a),
and
note
that
Ch
urc
h
in
tegers
are
(a
particular
case
of
)
sup
ercom
binators.
The
reduction
of
this
term
w
ould
pro
ceed
as
in
Figure
..
@
@
@
a
I
@
@
a
@
@
@
a
@
I
@
@
@
I
a
@
I
2
2
2
2
2
Fig.
..
Sup
erCom
binator
reduction
After
t
w
o
reduction
steps,
the
subterm
(
I)
is
shared
(see
the
dotted
line
in
Figure
.).
Unfortunately
,
Sup
erCom
binator
reduction
is
not
able
to
reduce
this
subterm
to
the
iden
tit
y
(
do
es
not
ha
v
e
enough
argumen
ts:
I
is
its
only
argumen
t,
in
the
subterm).
So,
w
e
shall
ha
v
e
t
w
o
dieren
t
reductions
of
this
subterm,
leading
to
a
useless
duplication
of
w
ork.
These
duplications
can
com
bine
in
a
v
ery
nast
y
w
a
y:
it
is
easy
to
see
that
our
t
ypical
example
(n

I
a)
is
exp
onen
tial
in
n,
also
in
the
case
of
Sup
erCom
binators.

.
Some
Sharing
me
chanisms

..
Envir
onment
Machines
An
alternativ
e
w
a
y
for
reducing
-terms
that
lo
oks
particularly
promis-
ing
in
view
of
its
sharing
p
ossibilities
is
b
y
means
of
envir
onments.
Roughly
,
an
en
vironmen
t
is
a
collection
of
bindings,
that
is
a
map-
ping
from
v
ariable
names
to
v
alues
(other
terms).
Reducing
a
-redex
x:(M
N),
the
instance
of
the
function
M
is
not
explicitly
created,
it
is
rather
implicitly
represen
ted
b
y
means
of
a
closur
e
hM;
ei
b
et
w
een
the
b
o
dy
M
and
its
curren
t
en
vironmen
t
up
dated
b
y
the
new
binding
[N=x].
If
the
function
x:M
w
as
shared,
w
e
ma
y
a
v
oid
duplicating
the
function:
the
dierence
b
et
w
een
the
instances
of
M
will
b
e
expressed
b
y
their
dieren
t
closing
en
vironmen
ts.
In
particular,
the
b
o
dy
M,
and
hence
an
y
redex
con
tained
therein,
ha
v
e
the
p
oten
tial
to
b
e
shared
in
dieren
t
closures,
a
v
oiding
redundan
t
reductions.
A
n
um
b
er
of
reduction
sc
hemes
for
the
-calculus
using
en
vironmen
ts
ha
v
e
b
een
prop
osed
in
literature
(e.g.,
the
SECD
mac
hine
b
y
Landin
[Lan
],
the
Categorical
Abstract
Mac
hine
b
y
Cousineau,
Curien
and
Maun
y
[CCM
],
the
K-mac
hine
b
y
Krivine
[],
the
-calculus
of
Abadi,
Cardelli,
Curien,
and
L

evy
[A
CCL	
,
A
CCL	0
]).
A
common
framew
ork
for
studying
all
these
implemen
tatio
n
is
oered
b
y
the
calculus
of
ex-
plicit
substitution
or
-calculus.
The
main
idea
of
this
calculus
is
to
incorp
orate
the
meta-op
eration
of
substitution
as
an
explicit
comp
onen
t
of
the
calculus.
In
particular,
substitutions
(en
vironmen
ts)
b
ecome
rst
class
ob
jects
in
-calculus.
W
orking
in
this
setting,
it
is
p
ossible
to
giv
e
a
formal
pro
of
that
ev
en
the
sophisticated
notion
of
sharing
oered
b
y
closures
is
not
enough
to
ac
hiev
e
optimal
reductions.
The
follo
wing
example
is
discussed
b
y
Field
in
[Fie	0
]:
M
=
(x:((x
A)(x
B))
y:(z:((z
C)(x
D))
w:(y
E)))
(note
the
analogy
with
L

evy's
example).
Here,
A
and
B
are
-abstractions,
while
C;
D
and
E
are
arbitrary
terms.
After
a
few
reductions,
w
e
even-
tual
ly
come
to
the
follo
wing
conguration
N
=
(hP
;
[A=y]i
hP
;
[B=y]i)
where
P
is
the
shar
e
d
closure
P
=
h((z
C)(z
D));
[w:(y
E)=z]i
Let
us
resp
ectiv
ely
call
P

and
P

the
t
w
o
external
closures.
Since
all
the
terms
in
the
closures
of
N
are
in
normal
form,
w
e
m
ust
pro
ceed
b
y
applying
some
substitutions
(i.e.,
computing
some
closures).
If
w
e
start


Optimal
R
e
duction
reducing
P
,
w
e
ev
en
tually
create
t
w
o
copies
of
the
application
(A
E)
(and
t
w
o
copies
of
the
application
(B
E)).
These
duplications
are
a
v
oided
if
w
e
start
reducing
P

and
P

,
that
is
substituting
A
(resp
ectiv
ely
B)
for
y
in
w:(y
E).
In
this
w
a
y
,
w
e
get:
(((w:Q
C)
(w:Q
D))
((w:R
C)
(w:R
D)))
where
Q
and
R
are
the
shar
e
d
subterms
(A
E)
and
(B
E).
But,
in
this
case
w
e
duplicate
the
redexes
w:((:
:
:
)
C)
and
w:((:
:
:
)
D).
In
conclusion,
no
matter
what
reduction
is
done
rst,
some
duplication
of
w
ork
ev
en
tually
o
ccurs.
Again,
the
example
ab
o
v
e
ma
y
lo
ok
articial,
but
it
should
b
e
cor-
rectly
understo
o
d:
its
aim
is
to
pro
v
e
that
shared
en
vironmen
t
and
clo-
sure
are
not
sucien
t
to
implemen
t
optimal
reduction
no
matter
what
r
e
duction
str
ate
gy
is
adopte
d.
On
the
con
trary
,
once
a
reduction
strat-
egy
has
b
een
giv
en,
it
is
usually
m
uc
h
simpler
to
nd
a
coun
terexample
to
optimalit
y
.
F
or
instance,
if
w
e
forbid
reduction
inside
a
,
that
is
the
t
ypical
w
eak
notion
of
v
alue
adopted
b
y
most
implemen
tations,
our
usual
term
(n

I
a)
is
enough:
its
reduction
turns
out
to
b
e
exp
onen
tial
in
an
y
en
vironmen
t
mac
hine
(either
strict
or
lazy).
.
Sharing
graphs
The
initial
represen
tation
of
a
-term
in
the
optimal
graph
reduction
tec
hnique
is
v
ery
similar
to
its
abstract
syn
tax
tree
(just
lik
e
in
W
adsw
orth's
graph
reduction).
There
are
ho
w
ev
er
t
w
o
main
dierences:
(i)
w
e
shall
in
tro
duce
an
explicit
no
de
for
sharing;
(ii)
w
e
shall
supp
ose
that
v
ariables
are
explicitly
connected
to
their
resp
ectiv
e
binders.
F
or
instance,
the
graph
in
Figure
.
is
the
initial
represen
tation
of
the
-term
M
=
(
h:(
(h
I))),
where

=
x:(x
x)
and
I
=
x:x.
The
triangle
(w
e
shall
call
it
fan)
is
used
to
express
the
sharing
b
et
w
een
distinct
o
ccurrences
of
a
same
v
ariable.
All
v
ariables
are
connected
to
their
resp
ectiv
e
binders
(w
e
shall
alw
a
ys
represen
t

no
des
dra
wing
the
binding
connection
on
the
left
of
the
connection
to
the
b
o
dy).
Since
m
ultiple
o
ccurrences
of
a
same
v
ariable
are
shared
b
y
fans,
w
e
shall
ha
v
e
a
single
edge
lea
ving
a

to
w
ards
its
v
ariables.
So,
eac
h
no
de
in
the
graph
(@,

and
fan)
has
exactly
three
distinguished
sites
(p
orts)
where
it
will
b
e
connected
to
other
p
orts.

.
Sharing
gr
aphs

*
λ
@
*
λ
@
@
λ
@
@
λ
Fig.
..
Represen
tation
of
(
h:(
(h
I)))
..
Gr
aph
r
ewriting
W
e
shall
illustrate
the
main
ideas
of
Lamping's
optimal
graph
reduction
tec
hnique
sho
wing
ho
w
a
simplied
v
ersion
of
the
algorithm
w
ould
w
ork
on
the
-term
(
h:(
(h
I))).
As
w
e
shall
see,
a
crucial
issue
will
remain
unresolv
ed;
w
e
shall
p
ostp
one
its
solution
un
til
Chapter
.
The
term
(
h:(
(h
I)))
reduces
to
the
iden
tit
y
.
The
shortest
reduc-
tion
sequence
consists
in
ring
t
w
o
outermost
redexes
rst,
and
then
pro
ceed
b
y
an
innermost
reduction
strategy
(w
e
lea
v
e
the
easy
c
hec
k
of
this
fact
to
the
reader):
(
h:(
(h
I)))
!
(h:(
(h
I))
h:(
(h
I)))
!
((h:(
(h
I)))
I)
!
((
(I
I)))
!
((
I))
!
((I
I))
!
(
I)
!
(I
I)
!
I
In
particular,
w
e
need

-reduction
steps.
Note
moreo
v
er
that
the
inner
redex
(
(h
I))
is
duplicated
b
y
the
rst
reduction.
The
algorithm
for
optimal
graph
reduction
consists
of
a
set
of
lo
cal
graph
rewriting
rules.
A
t
a
giv
en
stage
of
the
computation,
w
e
can
usually
ha
v
e
sev
eral
reducible
congurations
in
the
graph.
In
this
case,
the
c
hoice
of
the
next
rule
to
apply
is
made
non-deterministically
.
This


Optimal
R
e
duction
do
es
not
matter
that
m
uc
h.
As
w
e
shall
see,
the
graph
rewriting
satises
a
one-step
diamond
prop
ert
y
implying,
not
only
conuence,
but
also
that
all
the
reduction
sequences
to
the
normal
form
(if
it
exists)
ha
v
e
the
same
length.
In
our
example,
w
e
shall
usually
c
ho
ose
the
next
rule
according
to
a
didactic
criterion
(and
sometimes
for
graphical
con
v
enience).
By
the
w
a
y
,
the
most
imp
ortan
t
sharing
graph
rewriting
rule
is
-
reduction:
x:(M
N)
!
M[N=x].
@
λ
M
*
N
M
*
N
Fig.
.	.
-reduction
In
sharing
graph
reduction,
substituting
a
v
ariable
x
for
a
term
N
amoun
ts
to
explicitly
connect
the
v
ariable
to
the
term
N.
A
t
the
same
time,
the
v
alue
returned
b
y
the
application
b
efore
ring
the
redex
(the
link
ab
o
v
e
the
application)
b
ecomes
the
instan
tiated
b
o
dy
of
the
function
(see
Figure
.	).
The
p
ortions
of
graph
represen
ting
M
and
N
do
not
pla
y
an
y
role
in
the
sharing
graph
-rule.
In
other
w
ords,
-reduction
is
expressed
b
y
the
completely
lo
cal
graph
rewriting
rule
of
Figure
.0.
λ
@
b
d
a
c
a
c
d
b
Fig.
.0.
-rule
The
term
(
h:(
(h
I)))
con
tains
t
w
o
-redexes.
The
corresp
onding
sharing
graph
reduction
is
giv
en
in
Figure
..

.
Sharing
gr
aphs
	
*
@
*
@
@
λ
λ
*
@
*
λ
@
λ
@
@
λ
*
λ
@
*
λ
@
@
λ
@
@
λ
(2)
(3)
(1)
Fig.
..
Initial
reductions
of
(
h:(
(h
I))).
The
graph
in
Figure
.()
corresp
onds
to
a
shared
represen
tation
of
the
-term
(h:((h
I)
(h
I))
h:((h
I)
(h
I)))
in
whic
h
the
sub
expression
(h
I)
is
shared
four
times.
Since
the
next
redex
in
v
olv
es
a
shared
-expression,
w
e
m
ust
ev
en
tually
pro
ceed
to
the
duplication
of
h:(:
:
:
).
In
ordinary
graph
reduction,
this
duplication
w
ould
b
e
p
erformed
as
a
unique
global
step
on
the
shared
piece
of
graph.
On
the
con
trary
,
in
the
optimal
graph
reduction
tec
hnique
w
e
pro
ceed
duplicating
the
external
,
and
still
sharing
its
b
o
dy
,
as
describ
ed
in
Figure
..
Note
that,
duplicating
the
binder,
w
e
ha
v
e
b
een
forced
to
in
tro
duce
another
fan
on
the
edge
leading
from
the
binder
to
the
v
ariable:
the
o
ccurrences
of
the
v
ariable
are
split
in
t
w
o,
one
for
eac
h
new
binder.
In
a
sense,
this
upside
do
wn
fan
w
orks
as
an
\unsharing"
op
erator
(fan-
out),
that
is
to
b
e
\paired"
against
the
fan(-in)
sharing
the
b
o
dy
of
the
function.
Although
there
is
no
op
erational
distinction
b
et
w
een
a
fan-in
and
a
fan-out,
their
in
tuitiv
e
seman
tics
is
quite
dieren
t;
in
particular,
k
eep
in
mind
that
a
fan-out
is
alw
a
ys
supp
osed
to
b
e
paired
with
some
fan-in
in
the
graph,
delimiting
its
scop
e
and
annihilating
its
sharing
eect.
As
w
e
shall
see,
the
w
a
y
in
whic
h
the
correct
pairing
b
et
w
een
fans
is
determined
is
a
crucial
p
oin
t
of
the
optimal
graph
reduction

0
Optimal
R
e
duction
*
*
M
λ
λ
λ
M
*
Fig.
..
The
\duplicati
on"
of
x:M
tec
hnique.
But
for
the
momen
t,
w
e
lea
v
e
this
p
oin
t
to
the
in
tuition
of
the
reader.
Again,
the
b
o
dy
of
the
function
x:M
do
es
not
pla
y
an
y
role
in
Fig-
ure
..
The
reduction
rule
can
th
us
b
e
formally
expressed
as
a
lo
cal
in
teraction
b
et
w
een
a
fan
and
a
,
as
describ
ed
in
Figure
..
*
*
λ
*
λ
λ
Fig.
..
F
an-
in
teraction
Let
us
pro
ceed
reducing
our
example.
After
the
application
of
the
fan-

in
teraction
rule,
w
e
get
the
graph
in
Figure
.().
A
new
-redex
has
b
een
created,
and
its
ring
leads
to
the
graph
in
Figure
.(),
corresp
onding
to
the
-term
((h:((h
I)
(h
I))
I)
(h:((h
I)
(h
I))
I))
In
the
graph,
there
are
no
more
-redexes
and
no
fan-
in
teractions.
Therefore,
w
e
m
ust
pro
ceed
duplicating
some
application.
If
w
e
w
ould
duplicate
the
outermost
application,
w
e
ev
en
tually
lo
ose
sharing:
it
w
ould
amoun
t
to
duplicate
the
redex
(h:((h
I)
(h
I))
I).
Therefore,
in
general,
the
graph
rewriting
rule
of
Figure
.
is
strictly
forbidden,
in
the
optimal
implemen
tatio
n
tec
hnique
(although
seman
tically
correct).
The
in
tuition
should
b
e
clear:
since
the
shared
application
could
b
e
in-

.
Sharing
gr
aphs

@
λ
*
*
@
λ
*
@
λ
*
*
@
@
λ
λ
*
*
@
@
λ
*
λ
@
(3)
(4)
(5)
Fig.
..
.
.
.
reduction
.
.
.
v
olv
ed
in
some
redex,
its
duplication
w
ould
imply
a
double
execution
of
the
redex.
*
@
*
*
@
@
Fig.
..
Non
optimal
duplication
Let
us
then
consider
the
innermost
application.
W
e
already
kno
w
that
w
e
cannot
apply
the
rule
of
Figure
..
Ho
w
ev
er,
in
this
case,
w
e
ha
v
e
another
fan
(a
fan-out)
that
could
p
ossibly
in
teract
with
the
application,
via
the
ob
vious
rule
of
Figure
..
W
e
ha
v
e
to
understand
if
suc
h
a
duplication
preserv
es
optimali
t
y
.
@
*
*
*
@
@
a
c
d
b
a
b
c
d
Fig.
..
F
an-@
in
teraction


Optimal
R
e
duction
Note
that
the
innermost
application
corresp
onds
to
six
applications
in
the
asso
ciated
-term:
t
w
o
applications
of
the
kind
(h:((h
I)
(h
I))
I),
and
four
of
the
kind
(hI).
The
rst
group
corresp
onds
to
the
path
leading
from
the
application
to
h:(:
:
:
)
passing
through
the
p
ort
mark
ed
with

of
the
fan-out;
similarly
,
the
other
group
corresp
onds
to
the
path
leading
from
the
application
to
the
binding
p
ort
of
the
,
passing
through
the
p
ort
mark
ed
with
.
There
is
no
in
tuitiv
e
w
a
y
to
handle
these
t
w
o
groups
of
reductions
together,
since
w
e
do
not
kno
w
an
ything
ab
out
the
term
that
will
b
e
substituted
for
h.
In
general,
from
the
p
oin
t
of
view
of
sharing,
it
is
alw
a
ys
correct
to
pro
ceed
to
the
duplication
of
the
application
according
to
Figure
.,
b
ecause
suc
h
a
conguration
already
implies
the
existence
of
t
w
o
unsharable
(class
of
)
redexes
for
the
application.
@
λ
*
*
@
λ
*
*
*
*
*
*
@
λ
@ @
λ
λ
λ
*
*
*
@
λ
@ @
*
(5)
(6)
(7)
a
b
Fig.
..
fan-@
in
teraction
The
reduction
of
our
example
pro
ceeds
according
to
Figure
..
W
e
re
the
fan-@
in
teraction
rule,
putting
in
evidence
a
new
fan-
rule.
In
the
nal
graph,
w
e
ha
v
e
t
w
o
groups
of
fans
meeting
eac
h
other
(see
the
dotted
o
v
als
a
and
b
in
the
picture).
This
is
another
crucial
p
oin
t
of
the
optimal
graph
reduction
tec
hnique.
As
w
e
shall
see,
these
t
w
o
cases

.
Sharing
gr
aphs

m
ust
b
e
handled
in
dieren
t
w
a
ys
(although,
up
to
no
w,
w
e
ha
v
e
no
syn
tactical
w
a
y
to
distinguish
them).
Let
us
start
with
the
in
teraction
mark
ed
with
a
in
Figure
..
W
e
are
duplicating
the
iden
tit
y
,
and
the
ob
vious
idea
w
ould
b
e
to
complete
the
duplication.
This
amoun
ts
to
annihilate
b
oth
fans
connecting
the
corresp
onding
links:

with
,
and

with
,
see
Figure
.().
*
*
a
d
c
b
*
*
a
d
b
c
a
b
c
d
*
*
*
*
c
d
a
b
(2)
(1)
Fig.
..
F
an-fan
in
teractions.
This
rule
can
b
e
only
used
when
the
fan-in
and
the
fan-out
are
paired
(since,
in
a
sense,
they
b
elong
to
a
same
\duplication
pro
cess"
that
has
b
een
no
w
accomplished).
This
is
not
the
case
in
the
conguration
mark
ed
with
b
in
Figure
.,
where
the
fan-in
and
the
fan-out
ha
v
e
nothing
to
do
with
eac
h
other
(the
fan-out
is
actually
paired
with
the
upp
ermost
fan-in).
In
this
case,
the
fans
m
ust
duplicate
eac
h
other,
according
to
the
rule
in
Figure
.().
The
problem
of
deciding
whic
h
rule
to
apply
when
t
w
o
fans
meet
(that
is
the
question
of
ho
w
their
pairing
is
established)
is
a
crucial
p
oin
t
of
the
optimal
implemen
tatio
n
tec
hnique.
But
as
previously
said,
w
e
shall
p
ostp
one
this
complex
matter
to
a
further
c
hapter;
for
the
momen
t,
w
e
will
use
in
tuition
(the
informal
argumen
ts
presen
ted
so
far)
to
decide
whether
t
w
o
fans
pair
or
not.
Applying
the
fan-fan
in
teraction
rules
of
Figure
.,
the
computation
pro
ceed
as
describ
ed
in
Figure
.	.
The
rules
seen
so
far
are
enough
to
complete
the
reduction.
In
partic-
ular,
w
e
can
start
ring
t
w
o
-redexes,
w
e
can
then
duplicate
the
only
application
left
in
the
graph
and
annihilate
a
couple
of
paired
fans.
The
nal
graph
in
Figure
.0
has
b
een
redra
wn
for
the
sak
e
of
clarit
y
in
Figure
..
No
w,
the
iden
tit
y
gets
duplicated,
its
application
is
reduced.
The
resulting
iden
tit
y
id
duplicated
again
and
b
y
a
nal
-
redex
w
e
get
the
exp
ected
normal
form.
The
normalization
of
this
term
required
only

applications
of
the
-rule,
against

-reductions
needed
b
y
the
b
est
str
ate
gy
in
the
usual
syn
tactical
univ
erse
of
-expressions
(recall
that
there
is
no
eectiv
e
w
a
y


Optimal
R
e
duction
*
*
*
*
*
*
*
*
λ
λ
@
λ
@ @
*
λ
λ
*
*
*
*
@
λ
@ @
λ
λ
@
λ
@ @
(7)
(8)
(9)
Fig.
.	.
.
.
.
reduction
.
.
.
*
*
*
*
*
λ
λ
@
@
*
*
*
*
*
λ
@
*
*
*
*
*
λ
*
@
@
*
λ
*
@
@
(11)
(10)
(12)
(13-14)
Fig.
.0.
.
.
.
reduction
.
.
.
to
c
ho
ose
the
b
est
reduction
order
in
the
-calculus).
The
situation
is

.
Sharing
gr
aphs

λ
*
@
*
@
(14)
λ
*
@
λ
λ
@
*
λ
@
λ
λ
@
(15-16)
(18-19)
(17)
(20)
Fig.
..
.
.
.
reduction.
ev
en
more
fa
v
orable
for
other
t
ypical
reduction
strategies:
innermost
and
outermost
reduction
require
resp
ectiv
ely

and

-reduction
steps.
Although
this
is
still
not
v
ery
impressiv
e,
the
actual
gain
of
the
optimal
graph
reduction
tec
hnique
can
b
ecome
exp
onen
tial
on
more
complex
examples.
Let
us
nally
recall,
for
the
sak
e
of
clarit
y
,
all
the
graph
reduction
rules
considered
so
far,
see
Figure
..
W
e
stress
again
that
the
main
prob-
lem
of
the
optimal
graph
reduction
tec
hnique
consists
in
discriminating
the
application
of
the
last
t
w
o
rules
in
Figure
..
By
the
previous
dis-
cussion,
this
amoun
ts
to
understand
ho
w
fan-in
and
fan-out
are
paired
in
the
graph.
W
e
suggest
the
reader
to
try
to
think
of
this
problem
b
y
himself,
b
efore
pro
ceeding
an
y
further
in
reading
the
b
o
ok.
Let
us
also
remark
that
all
graph
rewriting
rules
in
Figure
.
can
b
e
seen
as
lo
cal
in
teractions
b
et
w
een
pair
of
no
des
in
the
graph.
Suc
h
graph
rewriting
systems
ha
v
e
b
een
studied
b
y
Lafon
t,
under
the
name
of
In
teraction
Nets.
Note
in
particular
that
eac
h
no
de
has
a
unique,
distinguished
p
ort
where
it
can
p
ossibly
in
teract
with
other
no
des.
This
p
ort,
that
has
b
een
put
in
evidence
b
y
an
arro
w
in
Figure
.,
will
b
e
called
the
princip
al
p
ort
of
the
no
de.
All
the
other
p
orts
will
b
e
called
the
auxiliary
p
ort
of
the
no
de.
..
R
e
ad-b
ack
and
Semantics
The
initial
sharing
graph
represen
tation
G
M
of
a
-term
M
has
an
ob
vi-
ous
corresp
ondence
with
the
abstract
syn
tax
tree
of
M.
Besides,
as
so
on


Optimal
R
e
duction
@
a
λ
d
c
b
a
d
c
b
*
*
a
d
c
b
a
b
c
d
*
*
a
d
b
c
*
*
*
*
c
d
a
b
λ
*
a
b
c
d
*
*
λ
λ
a
b
c
d
*
*
@
@
a
c
d
b
@
*
a
b
c
d
Fig.
..
Sharing
graph
reduction
rules.
*
@
λ
Fig.
..
Principal
p
orts.
as
w
e
start
the
reduction
(and
w
e
in
tro
duce
fan-out),
this
prop
ert
y
is
immediately
loss,
and
quite
complex
lo
ops
arise
in
the
graph.
Moreo
v
er,
in
general
the
normal
graph
G
0
of
G
M
is
quite
dieren
t
from
the
graph
G
N
enco
ding
the
normal
form
N
of
M.
Consider
for
instance
the
-term
M
=
xy:(z:(z
(z
y))
w:(x
w))
This
term
reduces
to
the
Ch
urc
h
in
teger

=
xy:(x
(x
y)).
Nev
erthe-
less,
its
graph
reduction
(see
Figure
.)
pro
duces
the
normal
form
in
Figure
.,
that
is
not
the
initial
enco
ding
of

.
The
ob
vious
problem
is
to
understand
in
whic
h
sense
a
sharing
graph
\represen
ts"
a
-term,
or,
if
y
ou
prefer,
ho
w
can
w
e
\read-bac
k"
a
-
expression
from
a
sharing
graph
(in
some
sense,
sharing
graphs
should
b
e
considered
a
kind
of
\in
ternal
represen
tation"
of
the
asso
ciated
-

.
Sharing
gr
aphs

*
*
λ
λ
@
Fig.
..
A
shared
represen
tation
of
Ch
urc
h's

.
expression).
This
problem
is
indeed
essen
tial
in
order
to
pro
v
e
the
cor-
rectness
of
the
algorithm:
since
w
e
do
not
have
syn
tactical
correctness
(the
normal
forms
do
not
coincide),
w
e
m
ust
ev
en
tually
w
ork
up
to
some
seman
tical
notion
of
equiv
alence
b
et
w
een
sharing
graphs
y
.
The
general
idea
b
ehind
the
read-bac
k
is
to
compute
the
abstract
syn
tax
tree
of
the
corresp
onding
-term
b
y
considering
one
branc
h
at
a
time.
Although
the
graphs
w
e
considered
so
far
are
not
directed,
w
e
ha
v
e
already
remark
ed
that
it
lo
oks
natural
to
sup
erimp
ose
a
top-
do
wn
direction
(that,
informall
y
,
also
allo
w
ed
us
to
distinguish
a
fan-in
from
a
fan-out)
y
.
The
idea
is
to
read
eac
h
branc
h
of
the
syn
tax
tree
represen
ted
b
y
the
graph
b
y
follo
wing
a
path
from
the
ro
ot
no
de
up
to
a
b
ound
v
ariable,
tra
v
eling
top-do
wn
in
the
graph.
Note
that,
when
w
e
reac
h
a
fan-in,
w
e
ev
en
tually
en
ter
this
form
at
an
auxiliary
p
ort,
and
w
e
exit
from
its
principal
p
ort.
Con
v
ersely
,
when
w
e
reac
h
a
fan-out,
w
e
forcedly
en
ter
through
its
principal
p
ort,
and
w
e
m
ust
decide
from
whic
h
auxiliary
p
ort
to
exit:
from
the
one
mark
ed
with

or
from
the
one
mark
ed
with
?.
In
order
to
solv
e
this
am
biguit
y
,
recall
that
eac
h
fan-out
is
alw
a
ys
\paired"
with
some
fan-in,
and
that
the
fan-out
is
supp
osed
to
annihilate
the
sharing
eect
of
the
paired
fan-in.
It
is
p
ossible
to
pro
v
e
that,
reading
paths
in
the
w
a
y
men
tioned
ab
o
v
e,
the
fan-in
paired
with
some
fan-out
has
b
een
ev
en
tually
tra
v
ersed
in
the
path
leading
from
the
ro
ot
to
the
fan-out.
No
w,
the
decision
ab
out
whic
h
w
a
y
to
follo
w
exiting
from
a
fan-out
is
ob
viously
imp
osed
b
y
the
p
ort
w
e
used
to
en
ter
the
y
The
read-bac
k
problem
is
prett
y
seman
tical:
op
erationa
lly
,
w
e
do
not
usually
need
to
read-bac
k
the
result,
in
the
same
w
a
y
as
w
e
nev
er
read-bac
k
the
in
ternal
repre-
sen
tation
of
a
function
in
all
the
usual
implemen
tat
ion
s
of
functional
programm
ing
languages.
If
the
result
is
a
basic
v
alue,
it
will
b
e
directly
a
v
ailable
as
ro
ot
no
de
at
the
end
of
the
computation
.
y
This
prop
ert
y
could
b
e
formalized
b
y
in
tro
ducin
g
a
suitable
p
olarit
y
for
all
the
p
orts
of
the
forms
in
the
graph.


Optimal
R
e
duction
*
*
@
λ
λ
@
@
λ
λ
*
*
λ
λ
@
*
λ
λ
@
λ
@
λ
@
@
*
λ
λ
λ
@
@
@
*
*
@
λ
λ
@
λ
(3)
(4) 
(5)
(1)
(2)
Fig.
..
Sharing
reduction
of
M
=
xy:(z:(z
(z
y))
w:(x
w))
.
paired
fan-in:
if
w
e
en
tered
the
fan-in
at
,
w
e
shall
exit
the
fan-out
at
,
and
similarly
for
?.
Let
us
see
ho
w
the
read-bac
k
algorithm
w
ould
w
ork
on
the
example
in
Figure
..
Starting
form
the
ro
ot,
w
e
tra
v
erse
t
w
o

(w
e
alw
a
ys
exit
to
w
ards
the
righ
t-auxiliary
p
ort,
corresp
onding
to
the
b
o
dy).
Then
w
e
reac
h
a
fan-in,
and
an
application
no
de.
No
w
w
e
are
free
to
c
ho
ose
whic
h
branc
h
(whic
h
argumen
t
of
the
application)
reading
rst.
Let
us
supp
ose
to
exit
to
w
ards
the
functional
argumen
t
(that
is,
exiting
from

.
Sharing
gr
aphs
	
the
principal
p
ort
of
the
abstraction
no
de).
W
e
nd
a
lo
op
to
w
ards
a

no
de,
corresp
onding
to
a
b
ound
v
ariable
(moreo
v
er,
w
e
kno
w
that
the
v
ariable
w
as
b
ound
b
y
the
rst
binder
w
e
tra
v
ersed).
So,
w
e
ha
v
e
nished,
along
this
path.
The
p
ortion
of
term
read-bac
k
so
far
is
dra
wn
in
Figure
.(a).
Let
us
start
the
pro
cess
again,
but
this
time
c
ho
osing
to
exit
from
the
auxiliary
p
ort
of
the
application.
W
e
reac
h
a
fan-out.
Since
w
e
en
tered
the
paired
fan-in
at
the
p
ort
mark
ed
with
,
w
e
are
forced
to
exit
from
the
corresp
onding
p
ort
of
the
fan-out.
W
e
tra
v
erse
a
second
time
the
fan-in
(this
time
en
tering
from
the
p
ort
mark
ed
with
?),
and
w
e
nd
again
the
same
application
as
b
efore.
Ob
viously
,
c
ho
osing
to
follo
w
the
path
to
w
ards
the
function,
w
e
nd
the
same
b
ound
v
ariable
of
the
rst
time
(see
Figure
.(b)).
λx
y
λ
λx
λx
y
λ
@
x
@
x
@
x
@
x
@
y
λ
x
y
(a)
(b)
(c)
Fig.
..
Read-bac
k.
T
o
conclude,
let
us
resume
our
read-bac
k
pro
cess
starting
from
the
auxiliary
p
ort
of
the
last
application.
W
e
meet
again
the
fan-out,
but
this
time
w
e
are
forced
to
exit
from
the
p
ort
mark
ed
with
?,
since
this
w
as
the
p
ort
through
whic
h
w
e
en
tered
the
last
o
ccurrence
of
the
paired
fan-
in.
W
e
nd
a
v
ariable
b
ound
b
y
the
second
lambda
(see
Figure
.(c)).
Since
all
the
paths
ha
v
e
b
een
considered,
w
e
are
done.


The
full
algorithm
The
main
problem
of
the
Optimal
Reduction
Algorithm
via
Sharing
Graphs
is
to
establish
the
correct
pairing
b
et
w
een
fan-in's
and
fan-out's.
The
most
ob
vious
idea
w
ould
b
e
to
lab
el
fans
in
the
sharing
graph,
in
suc
h
a
w
a
y
that
t
w
o
fans
are
paired
if
and
only
if
they
ha
v
e
iden
tical
lab
els.
Unfortunately
,
this
simple
solution
is
inadequate.
A
nice
argu-
men
tation
against
lab
els
w
as
giv
en
b
y
Lamping
in
[Lam	
].
*
*
*
*
B
A
@
B
A
X
Y
Fig.
..
Am
biguous
pairing
of
fans.
As
w
e
ha
v
e
seen
in
the
in
tro
duction,
complex
lo
oping
paths
are
cre-
ated
along
the
reduction
of
a
sharing
graph.
This
lo
oping
paths
presen
t
a
problem
with
lab
eling
when
a
path
tra
v
erses
sev
eral
times
the
same
fan-in
b
efore
reac
hing
its
paired
fan-out.
F
or
instance,
in
the
graph
of
Figure
.,
supp
ose
that
the
fans
are
paired
according
to
their
lab
els.
An
y
legal
path
that
reac
hes
the
fan-out
lab
eled
B
m
ust
ev
en
tually
tra-
v
erse
the
fan-in
lab
eled
B
t
wice.
If
the
tra
v
ersal
of
the
fan-out
is
paired
0

The
ful
l
algorithm

with
the
rst
tra
v
ersal
of
the
fan-in,
the
graph
represen
ts
the
expression
((x
x)
(y
y));
on
the
con
trary
,
if
the
second
tra
v
ersal
of
the
fan-in
B
is
tak
en
in
to
accoun
t,
the
read-bac
k
of
the
graph
is
((x
y)
(x
y)).
W
e
can
then
conclude
that
lab
els
are
not
enough
to
distinguish
these
t
w
o
cases.
Exercise
.0.
Pro
v
e
that
the
graph
of
Figure
.
can
resp
ectiv
ely
o
c-
cur
with
the
t
w
o
in
terpretations
ab
o
v
e
near
the
end
of
the
reduction
of
the
follo
wing
terms:
(i)
x:y:
(
f:
(
h:
(h
p:
(h
q:
p))
l:
(((f
n:
(l
n))
x)
y)
)
g:u:v:((g
u)
(g
v))
)
(ii)
x:y:
(
f:
(
h:
(h
p:
(h
q:
q))
l:
(((f
n:
(l
n))
x)
y)
)
g:u:v:((g
u)
(g
v))
)
The
next
example
pro
vides
a
more
op
erational
grasp
of
the
problems
with
lab
eling.
In
Figure
.
is
describ
ed
the
initial
part
of
the
sharing
graph
reduction
of
(
).
In
the
initial
graph,
the
t
w
o
fans
are
not
paired,
so
they
get
dieren
t
lab
els
(A
and
B,
in
our
example).
The
lab
el
of
the
fan
mark
ed
with
A
m
ust
b
e
preserv
ed
while
it
tra
v
erses
the

in
the
second
reduction
(the
t
w
o
\residual"
fans
are
actually
paired).
The
problem,
is
the
m
utual
crossing
of
fans,
in
the
third
reduction.
If
lab
els
are
unstructured,
this
rule
m
ust
b
e
symmetric.
Since
the
fan-out
mark
ed
with
A
is
paired
with
the
top-most
fan-in
(also
mark
ed
with
A),
this
lab
el
m
ust
b
e
preserv
ed
during
the
m
utual
tra
v
ersal
of
fans.
Due
to
the
symmetry
of
the
rule,
this
implies
that
the
lab
els
of
fans
m
ust
b
e
left
unc
hanged
during
their
m
utual
tra
v
ersal;
in
particular,
w
e
create
t
w
o
residual
fan-in's
b
oth
mark
ed
with
B.
The
problem
is
that
these
t
w
o
fans
ha
v
e
nothing
to
do
with
eac
h
other.
As
a
consequence,
at
the
end
of
the
reduction
represen
ted
in
Figure
.,
w
e
(correctly)
get
a
graph
with
the
same
shap
e
of
the
initial
one,
but
where
the
t
w
o
fan-in's
lo
ok
paired.
This
w
ould
ev
en
tually
turn
in
to
an
error
in
con
tin
uing
the
reduction.
Exercise
.0.
Con
tin
ue
the
reduction
of
the
example
in
Figure
..


The
ful
l
algorithm
*
*
λ
@
@
*
*
*
*
*
@
λ
λ
@
*
*
*
*
*
@
λ
λ
*
@ @
*
λ
@
*
λ
@
@
*
λ
@
*
λ
@
@
*
@
*
*
@
λ
λ
(3)
(2)
(1)
(5) 
(4)
(6)
A
A
A
B
B
B
A
A
B
B
A
A
A
A
A
A
B
B
B
B
Fig.
..
Lab
eling
fans
with
names.
.
P
airing
fans
Since
lab
els
are
not
enough
to
solv
e
the
problem
of
pairing
fans,
w
e
should
consider
more
structured
decorations
of
the
no
des
in
the
graph.
Lo
oking
bac
k
at
the
m
utual
crossing
rule
for
fans,
one
can
easily
realize
that,
seman
tically
,
this
rule
is
not
as
symmetric
as
it
lo
oks
lik
e:
the
idea
is
that,
when
t
w
o
fans
meet
in
suc
h
a
conguration,
they
are
not
m
utually
duplicating,
there
is
instead
only
one
\activ
e"
fan
whic
h
is
duplicating
(and
passing
through)
the
other.
Starting
from
this
simple

.
Pairing
fans

consideration,
w
e
can
imagine
that
w
e
need
some
order
relation
among
lab
els.
Let
us
just
tak
e
in
tegers.
In
other
w
ords,
let
us
add
a
lo
cal
lev
el
struc-
ture
to
the
bidimensional
graphs
presen
ted
in
the
in
tro
duction.
Eac
h
op
erator
will
b
e
decorated
with
an
in
teger
tag
whic
h
sp
ecies
the
lev
el
at
whic
h
the
op
erator
liv
es:
t
w
o
fans
matc
h,
or
are
paired,
if
they
meet
at
the
same
lev
el;
they
mismatc
h
otherwise.
In
tuitiv
ely
,
one
ma
y
think
of
the
lev
el
of
a
no
de
in
the
graph
as
ex-
pressing
the
n
um
b
er
of
dieren
t
w
a
ys
the
fan
can
b
e
shared
inside
the
term.
Consider
for
instance
the
term
(P
(Q
R)).
The
subterm
(Q
R)
can
b
ecome
shared
inside
P
;
since
w
e
m
ust
a
v
oid
an
y
conict
b
et
w
een
the
p
ossible
duplication
of
(Q
R)
and
the
fans
in
ternal
to
this
term,
(Q
R)
m
ust
b
e
put
at
a
dieren
t
(let
us
sa
y
,
higher)
lev
el
than
P
.
Similarl
y
,
R
is
not
only
p
oten
tially
shared
b
y
P
as
a
subterm
of
(Q
R),
but
it
can
b
e
also
shared
inside
Q.
So,
it
m
ust
liv
e
at
an
ev
en
higher
lev
el
than
Q.
More
generally
,
ev
ery
time
w
e
pass
the
argumen
t
of
an
application,
w
e
should
incremen
t
the
lev
el
of
the
term.
F
or
instance,
the
graph
in
Figure
.
is
the
already
met
term
(
)
with
the
righ
t
no
de
indexing.
*
λ
@
*
λ
@
@
0
1
1
0
1
0
0
Fig.
..
Syn
tax
tree
of
(
)|Adding
lev
els.
Clearly
,
this
is
not
enough
to
solv
e
our
problems:
in
the
same
w
a
y
as
for
lab
els,
after
one
iteration
of
the
reduction
pro
cess
in
Figure
.,
the
whole
term
w
ould
b
e
at
lev
el
,
while
one
w
ould
exp
ect
to
get
the
same
conguration
of
Figure
..
W
e
need
therefore
a
further
op
erator
for
decreasing
the
lev
el
of
no
des.
This
op
erator
is
usually
called
\croissan
t",
due
to
its
customary
represen
tation,
see
Figure
..
i
Fig.
..
The
\croissan
t"
op
erator.


The
ful
l
algorithm
The
idea
is
that
a
croissan
t
tra
v
els
along
the
other
no
des
of
the
graph
in
the
direction
of
the
arro
w
decremen
ting
the
lev
el
of
the
op
erators
that
it
crosses
(see
the
left-hand
side
rule
of
Figure
.).
When
t
w
o
croissan
ts
meet
face
to
face
at
the
same
lev
el,
they
are
annihilated,
as
in
the
case
of
fans
(see
the
righ
t-hand
side
rule
of
Figure
.).
i
i
a
b
a
b
a
f
.   .   .
b
c
j-1
i
i
f
.   .   .
j
i
b
c
a
i  <  j
Fig.
..
Rewriting
rules
for
\croissan
t".
The
problem
is
where
to
put
suc
h
op
erators
in
the
initial
graph.
By
the
discussion
ab
o
v
e,
this
question
can
b
e
rephrased
in
the
follo
wing
w
a
y:
when
do
es
a
p
oten
tially
sharable
ob
ject
lo
ose
a
lev
el
of
sharing?
Stated
in
this
w
a
y
,
the
answ
er
is
easy:
when
the
ob
ject
is
accessed
b
y
an
o
ccurrence
of
a
v
ariable
(o
ccurrences
of
v
ariables
are
linear
en
tities).
As
a
consequence,
w
e
should
add
a
croissan
t
ev
ery
time
w
e
ha
v
e
an
o
ccurrence
of
a
v
ariable
in
the
term.
In
the
case
of
(
),
w
e
w
ould
get
the
graph
of
Figure
..
*
*
0
@
0
λ
@
0
0
λ
@
1
1
1
0
1
1
2
Fig.
..
Syn
tax
tree
of
(
)|Adding
croissan
ts.
This
w
orks
ne
for
the
leftmost
cop
y
of

whic
h
is
created
along
the
reduction,
since
it
is
no
w
shifted
at
lev
el
0,
as
w
e
exp
ected.
Ho
w
ev
er,
w
e
ha
v
e
no
w
problems
with
the
other
cop
y
.
The
source
of
the
problem
should
b
e
clear,
b
y
no
w:
since
this
cop
y
is
going
to
b
e
accessed
inside
the
argumen
t
of
an
application
(see
the
dotted
region
in
Figure
.),
it
should
b
e
incremen
ted
b
y
one
lev
el
b
efore
doing
an
y
use
of
it.
T
o
this

.
Pairing
fans

aim,
w
e
are
forced
to
in
tro
duce
y
et
another
op
erator
called
\brac
k
et"
(see
Figure
.).
i
Fig.
..
The
\brac
k
et"
op
erator.
A
brac
k
et
w
orks
m
uc
h
lik
e
a
croissan
t,
but
it
incremen
ts
lev
els,
instead
of
decremen
ting
them.
The
corresp
onding
rewriting
rules
are
giv
en
in
Figure
..
a
b
i
b
a
i
a
f
.   .   .
b
c
i
i
j+1
.   .   .
j
b
c
i
f
a
i  <  j 
Fig.
..
Rewriting
rules
for
\brac
k
et".
In
the
initial
graph,
a
brac
k
et
m
ust
b
e
put
in
corresp
ondence
with
ev
ery
free
v
ariable
inside
an
argumen
t
of
an
application.
*
*
0
1
0
@
0
λ
@0
λ
@
1
1
0
1
1
2
0
1
Fig.
.	.
The
initial
translation
of
(
).
Putting
all
together,
w
e
nally
get
the
correct
translation
of
(
)
dra
wn
in
Figure
.	.
The
formal
statemen
t
of
the
inductiv
e
rules
for
the
translation
of
-terms
in
to
sharing
graphs
can
b
e
found
in
section
..


The
ful
l
algorithm
..0.
Some
additional
r
emarks
on
br
ackets
and
lab
els
The
ab
o
v
e
in
tro
duction
to
sharing
graphs
and
our
solution
to
the
prob-
lem
of
pairing
is
sensibly
dieren
t
from
Lamping's
original
presen
tation.
Lamping's
idea
w
as
to
in
tro
duce
a
notion
of
enclosure
to
delimit
the
in-
teraction
of
fans,
in
suc
h
a
w
a
y
that
fans
from
dieren
t
enclosures
nev
er
pair.
Croissan
ts
and
brac
k
ets
are
used
to
delimit
these
enclosures:
in
particular,
in
the
initial
graph,
they
just
surround
eac
h
fan
in
the
graph.
Unfortunately
,
this
simple
idea
is
not
fully
adequate:
as
Lamping
ob-
serv
e
(see
[Lam	
],
p.	)
\when
initially
enco
ding
a
-expression
with
a
graph,
a
few
extra
brac
k
ets
ma
y
b
e
necessary
:
:
:
This
kind
of
brac
k-
eting
:
:
:
is
only
needed
to
delimit
the
scop
e
of
a
lam
b
da
that
con
tains
free
v
ariables".
Actually
,
this
is
also
the
reason
wh
y
Lamping
did
nev
er
pro
vide
a
clear
inductiv
e
denition
of
his
translation
of
-expressions
in
to
sharing
graphs.
A
more
formal
explanation
of
these
extra-brac
k
ets
w
as
giv
en
in
[GAL	b
].
The
nice
idea
w
as
that
application
and
ab-
straction
no
des
should
b
e
assimilated
to
fans
(note
indeed
their
similar
op
erational
b
eha
vior),
requiring
th
us
a
suitable
enclosure
themselv
es.
The
translation
presen
ted
here
w
as
prop
osed
for
the
rst
time
in
[Asp	].
The
main
adv
an
tage
of
this
translation,
as
w
e
shall
see,
is
that
of
b
eing
particularly
close
to
Linear
Logic
and
Geometry
of
In
teraction.
Actually
,
the
general
in
tuition
is
not
that
far
from
Lamping:
w
e
still
use
croissan
ts
and
brac
k
ets
to
dene
enclosures.
Ho
w
ev
er,
w
e
are
not
enclosing
fans,
but
\sharable
data"
(b
o
xes,
in
the
terminology
of
Linear
Logic).
W
e
shall
come
bac
k
to
the
other
translations
in
Chapter

.
Sharing
Graphs
As
w
e
ha
v
e
seen
in
the
previous
section,
our
original
denition
of
sharing
graph
m
ust
b
e
extended
with
t
w
o
new
op
erators
required
for
op
erating
on
the
lev
el
structure
of
the
graph:
the
cr
oissant,
whic
h
op
ens
or
closes
a
lev
el,
and
the
squar
e
br
acket
(or
simply
br
acket),
whic
h
temp
orar-
ily
closes
a
lev
el
or
restores
a
temp
orarily
closed
one.
Summarizing,
sharing
graphs
are
undirected
graphs
built
from
the
indexed
no
des
in
Figure
.0.
Eac
h
no
de
of
the
graph
has
a
main
or
princip
al
p
ort
where
it
can
p
ossibly
in
teract
with
other
no
des
(this
p
ort
has
b
een
put
in
evidence
b
y
an
arro
w
in
Figure
.0).
All
the
other
p
orts
of
the
no
de
are
its
auxiliary
p
orts.
Tw
o
op
erators
(no
des
of
the
graph)
are
said
to
inter
act
when
their

.
Sharing
Gr
aphs

i
i
i
*
i
λ
@ i
application
abstraction
fan 
croissant 
bracket 
Fig.
.0.
Sharing
graph
op
erators.
principal
p
orts
are
connected
and
their
lev
els
are
equal.
The
whole
set
of
the
in
teraction
rules
in
tro
duced
so
far
is
describ
ed
in
Figure
..
@
a
λ
d
c
b
a
d
c
b
i
i
a
b
i
b
a
i
i
i
a
b
a
b
*
*
a
d
c
b
a
b
c
d
i
i
Fig.
..
In
teraction
rules.
The
rst
of
these
rules
is
the
usual
-reduction.
The
second
one
(b
ottom-left
in
gure)
is
the
matc
hing
of
fans.
The
latter
t
w
o
state
resp
ectiv
ely
that
op
ening
and
then
immedia
tely
closing
a
lev
el,
or
tem-
p
orarily
closing
and
then
immedia
tely
reop
ening
it
has
no
eect
at
all.
An
op
erator
at
a
giv
en
lev
el
can
also
act
up
on
an
y
other
op
erator
f
at
a
higher
lev
el
(reac
hed
at
its
principal
p
ort),
according
to
the
rules
in
Figure
.
(where
f
denotes
a
generic
op
erator).
*
a
b
c
c
d
a
b
*
*
d
f
.   .   .
.   .   .
.   .   .
.   .   .
f
f
i
i
i
j
j
j
f
.   .   .
j
i
b
c
a
a
f
.   .   .
b
c
j-1
i
i
f
.   .   .
j
b
c
a
i
a
f
.   .   .
b
c
i
i
j+1
Fig.
..
Action
rules.
In
these
rules,
the
op
erators
are
simply
propagated
through
eac
h
other


The
ful
l
algorithm
in
suc
h
a
w
a
y
that
their
eect
on
the
lev
el
structure
is
left
unc
hanged.
The
terminology
is
due
to
the
follo
wing
fact:
the
activ
e
op
erator
can
ha
v
e
an
eect
on
the
lev
el
at
whic
h
the
passiv
e
one
is
found,
so
the
index
of
the
latter
can
b
e
c
hanged,
while
the
index
of
the
former
remains
the
same.
Although
w
e
made
a
\seman
tical"
distinction
b
et
w
een
action
and
in-
teraction,
all
of
the
graph
rewriting
rules
are
lo
cal
in
teractions
in
La-
fon
t's
terminology
.
W
e
shall
often
use
the
term
in
teraction
in
this
more
generic
sense.
.
The
initial
enco
ding
of
-terms
A
-term
N
with
n
free
v
ariables
will
b
e
represen
ted
b
y
a
graph
with
n
+

en
tries
(free
edges):
n
for
the
free
v
ariables
(the
inputs),
and
one
for
the
\ro
ot"
of
the
term
(the
output).
The
translation
is
inductiv
ely
dened
b
y
the
rules
in
Figure
..
[x]n
n
= 
[M]n
λ
. . .
= 
λ
[   x.M]n
n
[MN]n = 
[M]n
[N]n+1
*
n
n
n
. . .
. . .
@ n
Fig.
..
Initial
translation.
The
translation
function
is
indexed
b
y
an
in
teger
whic
h
can
b
e
though
t
of
as
b
eing
the
lev
el
at
whic
h
w
e
w
an
t
the
ro
ot
to
b
e.
The
translation
starts
at
lev
el
0,
i.e.
[M]
=
[M]
0
.
In
the
gure
for
the
application
(M
N),
all
the
v
ariables
common
to
M
and
N
are
supp
osed
to
b
e
shared
b
y
means
of
fans.
As
a
consequence,
w
e
alw
a
ys
ha
v
e
just
one
en
try
for
eac
h
distinct
v
ariable
in
the
graph.

.
The
initial
enc
o
ding
of
-terms
	
If
a
lam
b
da
abstraction
binds
a
v
ariable
that
do
es
not
o
ccur
(i.e.,
it
is
free)
in
its
b
o
dy
,
the
edge
of
the
lam
b
da
no
de
leading
to
the
v
ariable
w
ould
b
e
dangling.
T
o
a
v
oid
this
dangling
reference,
w
e
in
tro
duce
a
new
op
erator,
usually
called
garb
age.
As
far
as
w
e
are
not
concerned
with
garbage
collection
issues,
this
op
erator
has
no
op
erational
eect
in
the
reduction
system.
[M]n
= 
λ
[   x.M]n
n
λ
. . .
Fig.
..
The
translation
of
x:M
when
x

FV
(M).
Example
..
Figure
.
sho
ws
the
initial
enco
ding
of
the
-term
(
I).
*
λ
@
@
λ
@
λ
0
0
0
0
0
0
1
1
0
1
0
2
1
1
Fig.
..
Initial
translation
of
(
I).
Exercise
..
T
ranslate
the
terms
of
Exercise
.0.
applying
the
rules
in
Figure
..
Use
the
sharing
graph
reduction
rules
so
far
dened
to
reduce
the
sharing
graphs
obtained
b
y
the
translation.
Remark
the

0
The
ful
l
algorithm
indexes
of
the
fans
in
the
congurations
analogue
to
the
one
of
Figure
.
that
w
ould
b
e
reac
h
near
the
end
of
the
reduction.
.
Lamping's
paths
The
correctness
of
sharing
implemen
tatio
n
is
pro
v
ed
b
y
dening
a
matc
h-
ing
b
et
w
een
sharing
graphs
and
terms.
W
e
ha
v
e
already
remark
ed
that
there
is
a
close
corresp
ondence
b
et
w
een
the
syn
tax
tree
of
a
-term
M
and
its
sharing
graph
represen
tation
[M],
and
that
this
corresp
ondence
is
far
from
eviden
t
as
so
on
as
[M]
is
ev
aluated
(see
Figure
.,
for
instance).
The
crucial
p
oin
t
is
the
presence
of
subpieces
of
the
graph
whic
h
con
tain
fan-out's.
M
N
*
F
or
instance,
the
ab
o
v
e
subgraph
ma
y
represen
t
either
M
or
N.
This
uncertain
t
y
ma
y
b
e
resolv
ed
b
y
observing
that
a
fan-out
describ
es
\un-
sharing"
and
that
an
expression/subgraph
whic
h
con
tains
unsharing
m
ust
ha
v
e
b
een
shared
somewhere
\in
the
history
of
the
path"
reac
hing
the
no
de.
Namely
,
if
w
e
tak
e
a
p
ath
from
the
ro
ot
of
the
graph
to
a
fan-
out
no
de,
w
e
exp
ect
to
nd
some
fan-in
p
erforming
the
sharing
paired
with
the
fan-out.
Once
this
pairing
has
b
een
established,
the
branc
h
for
exiting
the
fan-out
m
ust
b
e
the
same
of
the
one
that
has
b
een
tra
v
ersed
at
the
paired
fan-in.
This
means
that
w
e
m
ust
record
whic
h
branc
hes
of
fan-in's
ha
v
e
b
een
crossed
along
the
path.
The
structure
where
this
information
is
stored
is
called
c
ontext.
The
branc
hing
information
is
still
insucien
t
for
reco
v
ering
the
prop
er
pairing
of
fans.
In
fact,
paths
ma
y
tra
v
erse
sev
eral
fan-in's
(ev
en
the
same!)
b
efore
nding
a
fan-out
(see
Figure
.).
In
order
to
o
v
ercome
this
problem,
the
mec
hanism
of
con
texts
m
ust
not
only
store
the
branc
h-
ing
information
of
fan-in's,
but
also
organize
this
information
in
order
to
determine
the
pairing
b
et
w
een
fans.
The
lev
el
structure
of
no
des
suggests
that
con
texts
to
o
should
ha
v
e
a
similar
structure.
In
this
w
a
y
,
tra
v
ersing
a
-branc
h
of
an
n-indexed
fan-in
means
recording
this
information
in
the
n-th
lev
el
of
the
con
text.
The
tra
v
ersal
of
an
n-indexed
fan-out
is
th
us
constrained
b
y
what
is
stored
in
the
n-lev
el
of
the
con
text.
More
precisely
,
let
a
con
text
b
e
a
list
hh


hC;
a
n-
i;



;
a

i;
a
0
i
whose
elemen
ts
a
i
ma
y
b
e
lists
at
their

.
L
amping's
p
aths

turn.
The
tail
of
A
at
width
n
is
a
con
text
C,
i.e.,
the
con
text
C
is
the
information
stored
in
A
starting
from
lev
el
n.
Since
a
no
de
with
index
n
op
erates
on
suc
h
a
con
text
C,
w
e
shall
use
A
n
[

]
to
denote
the
con
text
whose
rst
n
elemen
ts
are
the
rst
n
elemen
ts
of
A,
while
its
tail
at
lev
el
n
is
unsp
ecied,
that
is,
A
n
[

]
=
hh


h

;
a
n-
i;



;
a

i;
a
0
i:
Inserting
a
con
text
in
to
[

]
w
e
get
then
A
n
[C]
=
hh


hC;
a
n-
i;



;
a

i;
a
0
i:
W
e
stress
that
C
can
b
e
an
y
con
text.
So,
in
general
A
n
[C]
=
A
if
and
only
if
C
is
the
sub
con
text
of
A
at
width
n.
Using
the
latter
notations,
the
con
text
transformation
p
erformed
b
y
a
fan-in
ma
y
b
e
summarized
as
follo
ws:
*
n
A  [<b, a>]
n
A  [<b, a>]
n
n
n
n
*
A  [<b,    a>]
.
A  [<b,    a>]
*.
F
an-out's
transform
con
texts
in
a
dual
w
a
y
with
resp
ect
to
fan-in's
(turn
upside-do
wn
the
ab
o
v
e
picture).
Namely
,
when
a
fan-out
is
met,
w
e
c
ho
ose
the
-branc
h
or
the
-branc
h
for
prosecuting
the
path,
according
to
what
is
stored
at
lev
el
n
in
the
con
text.
Of
course,
after
tra
v
ersing
the
fan-out
the
topmost
information
at
lev
el
n
in
the
con
text
is
p
opp
ed
(since
it
has
b
een
consumed).
What
ab
out
when
a
croissan
t
or
a
brac
k
et
is
met?
W
ell,
recall
from
section
.
that
these
no
des
w
ere
in
tro
duced
with
the
purp
ose
of
\man-
aging
the
lev
el
of
sharing".
In
particular,
croissan
ts
allo
w
to
decremen
t
the
lev
el
of
sharing
of
a
graph.
That
is,
an
n-indexed
croissan
t
in
fron
t
of
a
graph
at
lev
el
k,
k
>
n,
means
that
the
graph
m
ust
b
e
read
at
lev
el
k
-
.
F
rom
the
p
oin
t
of
view
of
con
texts
this
op
eration
of
\decreasing
the
lev
el
of
sharing"
is
reected
b
y
the
op
eration
whic
h
\remo
v
es
one
lev
el"
from
the
con
text,
the
n-th
lev
el
in
the
ab
o
v
e
case.
There
is
a
problem:
lev
els
of
con
texts
store
the
branc
h
marks
of
the
tra
v
ersed
fan-
in's.
If
w
e
remo
v
e
this
information,
there
is
no
w
a
y
for
restoring
it
when,
later
on
the
path,
a
paired
croissan
t
is
found
(and
w
e
ha
v
e
to
\increase
the
lev
el
of
sharing").
In
other
w
ords
w
e
m
ust
understand
whether
the
remo
v
ed
information
at
lev
el
n
ma
y
b
e
meaningful
in
the
follo
wing
of


The
ful
l
algorithm
the
path
or
not.
T
o
this
aim
remark
that
n-indexed
croissan
ts
instan-
tiate
v
ariable
o
ccurrences
with
the
asso
ciated
expressions,
whic
h
m
ust
b
e
at
a
lev
el
greater
than
n.
W
e
exp
ect
that
no
branc
h
information
is
recorded
at
the
n-th
lev
el
when
the
croissan
t
is
met,
for
ev
ery
no
de
of
the
asso
ciated
expression
sta
ys
at
a
greater
lev
el.
Namely
,
the
n-th
lev
el
of
the
con
text
m
ust
b
e
empt
y
(notation:
)
when
a
croissan
t
is
met.
The
follo
wing
picture
describ
es
this
requiremen
t:
n
A [a]
n
n
A [<a,    >]
Note
that
crossing
a
croissan
t
top-do
wn
all
the
con
texts
at
lev
els
greater
or
equals
than
n
increase
their
lev
el
b
y
one.
While
on
the
con-
trary
,
going
b
ottom-up
the
head
of
the
con
text
at
lev
el
n
is
remo
v
ed
and
all
the
follo
wing
con
texts
shift
to
the
righ
t
decreasing
their
lev
el
b
y
.
Finally
,
let
us
come
to
brac
k
ets.
W
e
said
that
the
tra
v
ersal
of
brac
k
ets
p
erforms
a
\dual"
action
with
resp
ect
to
croissan
ts.
This
is
not
com-
pletely
true.
Actually
,
the
aim
of
brac
k
ets
is
to
dene
the
part
of
the
graph
whic
h
m
ust
b
e
shared.
Of
course
the
sharing
lev
el
increases
when
y
ou
en
ter
this
part.
But,
unlik
e
the
case
of
croissan
ts,
w
e
cannot
hop
e
to
en
ter
an
n-indexed
brac
k
et
with
an
\empt
y"
lev
el
n
of
the
con
text.
In-
deed,
when
y
ou
exit
a
\shared
part"
at
lev
el
n,
w
e
migh
t
ha
v
e
recorded
branc
hing
informations
required
in
the
follo
wing,
accessing
again
the
shared
part.
This
means
that
the
information
at
lev
el
n
m
ust
b
e
sa
v
ed
when
the
shared
part
is
left
and
resumed
when
the
shared
part
is
en-
tered
again.
In
terms
of
con
texts
w
e
need
an
op
eration
that
sa
v
e
the
information
at
a
giv
en
lev
el.
W
e
shall
use
the
same
op
erator
for
building
lev
els,
as
dra
wn
in
the
follo
wing
picture:
n
A [<<b,a>,c>]
n
A [<b, <a, c>>]
n
Remark
that,
as
w
e
ha
v
e
already
seen
for
the
croissan
t,
also
the
brac
k
et
c
hanges
the
lev
el
of
the
con
texts
ab
o
v
e
n.
W
e
also
in
vite
the
reader
to
c
hec
k
that
the
opp
osite
rewriting
b
eha
vior
of
brac
k
et
and
crois-
san
t
is
sound
with
resp
ect
to
their
corresp
onding
op
erations
on
con
texts.
The
op
erational
b
eha
vior
of
brac
k
et
and
croissan
t
is
rev
ersible.
In
particular,
tra
v
ersing
a
brac
k
et
top-do
wn
(according
to
the
previous

.
L
amping's
p
aths

picture)
w
e
tak
e
the
con
text
a
at
lev
el
n
+

and
w
e
sa
v
e
it
in
to
the
con
text
at
lev
el
n
creating
a
pair
ha;
ci,
so
that
no
information
w
ould
b
e
lost.
Vice
v
ersa,
tra
v
ersing
a
matc
hing
brac
k
et
the
pair
ha;
ci
is
split
and
the
con
texts
a
and
c
b
ecome
a
v
ailable
again.
The
last
p
oin
t
is
one
of
the
most
imp
ortan
t.
It
means
that
in
order
to
access
the
information
w
e
sa
v
ed
crossing
a
brac
k
et
top-do
wn
(suc
h
a
direction
corresp
ond
to
the
fan-in
direction
in
the
case
of
fans)
w
e
need
to
tra
v
erse
b
ottom-up
(alw
a
ys
with
resp
ect
to
the
previous
picture)
a
brac
k
et
paired
with
the
previous
one.
As
a
consequence,
no
fan,
brac
k
et
or
croissan
t
paired
with
a
no
de
that
op
erated
on
a
or
c
can
b
e
met
in
b
et
w
een.
It
remains
to
deal
with
abstraction
and
application
no
des.
Do
es
these
no
des
mo
dify
con
texts?
Lamping,
when
he
pro
v
ed
the
correctness
of
his
implemen
tation
[Lam	
],
did
not
dene
con
text
transformations
for
@
and
-no
des.
Indeed,
in
order
to
read-bac
k
the
-term
asso
ciated
to
a
sharing
graph
(whic
h
w
as
Lamping's
purp
ose)
it
is
enough
to
recognize
those
paths
of
the
sharing
graph
whic
h
are
in
one-to-one
corresp
ondence
with
the
paths
in
the
syn
tax
tree
of
the
term.
T
o
this
aim,
when
an
@-no
de
is
met
y
ou
m
ust
prosecute
b
oth
from
the
function
p
ort
and
from
the
argumen
t
p
ort
(y
ou
ha
v
e
to
read-bac
k
b
oth
the
argumen
ts
of
the
application);
when
a

is
met
y
ou
m
ust
prosecute
from
the
b
o
dy
p
ort
(y
ou
m
ust
read-bac
k
the
b
o
dy).
In
other
w
ords,
the
no
de
itself
sp
ecies
ho
w
to
lengthen
the
path
and
there
is
no
necessit
y
for
con
text
information.
As
far
as
this
c
hapter
is
concerned,
Lamping's
paths
w
ork
v
ery
w
ell
(w
e
w
an
t
to
dene
the
-term
asso
ciated
to
a
sharing
graph,
to
o).
Ho
w
ev
er,
w
e
w
arn
the
reader
that
the
notion
of
prop
er
path
w
e
are
using
here
do
es
not
t
with
the
notion
of
path
w
e
will
use
in
Chapter
.
There,
w
e
shall
come
bac
k
in
more
detail
on
this
issue.
..
Contexts
and
pr
op
er
p
aths
Let
us
formalize
the
foregoing
discussion.
F
oremost
w
e
shall
dene
con-
texts.
Denition
..
(con
text)
A
level
is
an
elemen
t
of
the
set
inductiv
ely
generated
b
y
the
follo
wing
grammar:
(i)

is
a
lev
el
(the
empty
lev
el);
(ii)
if
a
is
a
lev
el
then
so
are


a,


a;
(iii)
if
a
and
b
are
lev
els,
then
also
ha;
bi
is
a
lev
el.


The
ful
l
algorithm
A
c
ontext
is
an
innite
list
of
lev
els
con
taining
only
a
nite
n
um
b
er
of
non-empt
y
lev
els.
Namely:
(i)
the
empty
con
text
?
is
the
innite
list
of
empt
y
lev
els,
i.e.,
?
=
h?;
i;
(ii)
if
C
is
a
con
text
and
a
0
is
a
lev
el,
then
hC;
a
0
i
is
a
con
text.
According
to
the
previous
denition,
a
con
text
has
the
follo
wing
shap
e:
A
=
h


hB;
a
n-
i



;
a
0
i
where
a
0
;
:
:
:
;
a
n-
are
lev
els,
and
B
is
a
con
text.
W
e
will
sa
y
that
A(i)
=
a
i
is
the
i-th
lev
el
of
the
con
text
A,
and
that
B
is
the
sub
con
text
of
A
at
width
n.
W
e
will
also
sa
y
that
A
n
[

]
=
hh


h

;
a
n-
i;



;
a

i;
a
0
i
are
the
lev
els
of
A
lo
w
er
than
n,
and
w
e
will
denote
b
y
A
n
[C]
the
con
text
obtained
replacing
C
for
the
sub
con
text
of
A
at
width
n
(in
our
case
replacing
C
for
B).
W
e
stress
that
in
spite
of
their
formalization
as
innite
lists,
con
texts
are
indeed
nite
ob
jects.
In
fact,
for
an
y
con
text
A
there
is
an
index
n
suc
h
that
the
sub
con
text
at
width
n
is
empt
y
(i.e.,
A
=
A
n
[?]).
The
width
of
a
con
text
is
the
least
n
for
whic
h
A
=
A
n
[?].
Denition
..
(prop
er
paths)
A
pr
op
er
p
ath
in
a
sharing
graph
G
is
a
path
suc
h
that:
(i)
ev
ery
edge
of
the
path
is
lab
eled
with
a
con
text;
(ii)
consecutiv
e
pairs
of
edges
satisfy
one
of
the
follo
wing
constrain
ts:
*
n
A  [<b, a>]
n
n
A [<b, o  a>]
.
*
n
A  [<b, a>]
n
n
A [<b,    a>]
*.
A [a]
n
n
n
A [<a,    >]
n
A [<<b,a>,c>]
n
A [<b, <a, c>>]
n
@n
A
A
@n
A
A
λn
A
A
(iii)
the
path
do
es
not
con
tain
b
ounce,
i.e.,
none
of
the
previous
con-
gurations
can
b
e
tra
v
ersed
b
ottom-up
immediately
after
it
has
b
een
tra
v
ersed
top-do
wn,
and
vice
v
ersa.

.
L
amping's
p
aths

Giv
en
a
prop
er
path,
the
mapping
b
et
w
een
edges
and
con
texts
that
the
path
induces
is
said
a
pr
op
er
c
ontext
lab
eling
(prop
er
lab
eling
for
short).
Prop
er
paths
are
equated
up
to
con
texts.
That
is,
t
w
o
prop
er
paths
ha
ving
pairwise
equal
edges
are
considered
equal,
ev
en
when
their
con
texts
dier.
Remark
..
Prop
er
paths
nev
er
tra
v
erse
a
-no
de
from
the
binding
p
ort
to
the
con
text
p
ort
(or
vic
e
versa
).
W
e
will
also
see
that
prop
er
paths
are
suitable
represen
tations
of
paths
of
the
syn
tax
tree
of
the
-
term
denoted
b
y
the
sharing
graph.
As
a
consequence
the
length
of
prop
er
paths
is
alw
a
ys
nite.
This
is
the
most
manifest
feature
whic
h
distinguishes
Lamping's
paths
from
the
paths
w
e
will
study
in
Chapter
.
Remark
..
(forw
ard
paths)
Prop
er
paths
are
not
orien
ted.
Nev-
ertheless,
in
the
follo
wing
w
e
shall
mainly
consider
forw
ard
orien
ted
prop
er
paths,
that
is,
orien
ted
according
to
the
natural
top-do
wn
orien-
tation
of
-term
syn
tax
trees.
Th
us,
a
forwar
d
pr
op
er
p
ath
is
a
prop
er
path
whose

and
@
no
des
are
alw
a
ys
tra
v
ersed
top-do
wn,
according
to
the
dra
wing
of
Denition
...
F
urthermore,
for
the
rest
of
this
c
hap-
ter,
and
when
not
otherwise
sp
ecied,
paths
will
b
e
forw
ard
orien
ted,
that
is,
a
part
for
con
texts,
they
will
v
erify
all
the
comp
osition
rules
of
forw
ard
prop
er
paths.
More
precisely
,
a
forwar
d
p
ath
is
a
sequence
of
edges
in
whic
h:
(i
)
there
are
no
b
ounces;
(ii
)
@-no
des
are
tra
v
ersed
en
tering
from
the
con
text
p
ort
and
lea
ving
through
the
argumen
t
or
to
the
function
p
ort;
(iii
)
-no
des
are
tra
v
ersed
en
tering
from
the
con
text
p
ort
and
lea
ving
from
the
b
o
dy
p
ort.
F
or
instance,
the
arro
ws
in
the
path
of
Figure
.
corresp
ond
to
its
forw
ard
orien
tation.
It
is
indeed
easy
to
c
hec
k
that
the
sequence
of
edges
corresp
onding
to
a
prop
er
path
is
either
forw
ard
orien
ted
or
the
rev
erse
of
a
forw
ard
path,
sa
y
a
bac
kw
ard
path.
F
urthermore,
an
y
path
starting
at
the
ro
ot
is
forw
ard
orien
ted.
Exercise
..
Pro
v
e
that
an
y
prop
er
path
has
an
innite
n
um
b
er
of
prop
er
lab
elings.
Exercise
..
Let
'
b
e
a
nite
path.
Pro
v
e
that
the
predicate
\
has
a
prop
er
lab
eling"
is
decidable.


The
ful
l
algorithm
*
0
0
*
(a)
(b)
x
y
@
*
*
0
0
0
1
1
1
0
A
B
D
C
E
G
F
H
I
L
M
x
y
@
*
*
0
0
0
1
1
1
0
*
N
O
P
*
Fig.
..
A
prop
er
path.
Example
..
Figure
.(a)
illustrates
a
(simplied)
sharing
graph
segmen
t
whic
h
can
o
ccur
near
the
end
of
the
ev
aluation
of
x:
y:
(z:
(M
N)
P
)
where
M
=
u:
(u
(v:
(u
w:
v)))
N
=
i:
(((z
j:
(i
j))
x)
y)
P
=
f:
r:
s:
((f
r)
(f
s))
In
Figure
.(b)
w
e
ha
v
e
dra
wn
a
prop
er
path
(the
dashed
line).
The

.
L
amping's
p
aths

lab
els
of
the
edges
are
in
order
(b
eing
X
an
arbitrary
con
text):
A
=
X
H
=
hX;


i
B
=
hX;
i
I
=
hX;




i
C
=
hX;


i
L
=
hX;




i
D
=
hX;


i
M
=
hhX;
i;




i
E
=
hhX;
i;


i
N
=
hhX;


i;




i
F
=
hhX;


i;


i
O
=
hhX;


i;


i
G
=
hhX;


i;
i
P
=
hhX;


i;
i
W
e
added
the
arro
ws
along
the
path
only
for
ease
of
reading,
since
prop
er
paths
are
not
orien
ted.
Observ
e
that
the
prop
er
path
of
the
example
starts
at
the
ro
ot
of
the
sharing
graph
and
terminates
at
the
v
ariable
x,
b
y
tra
v
ersing
t
wice
an
application
no
de
from
the
con
text
to
the
principal
p
ort.
As
a
consequence,
in
the
term
represen
ted
b
y
the
graph
in
Figure
.(a),
the
v
ariable
x
will
b
e
inside
the
rst
argumen
t
of
t
w
o
nested
applications.
Exercise
..
T
ak
e
the
graph
of
Figure
..
(i)
Find
a
prop
er
path
starting
at
the
ro
ot
and
terminating
at
y.
(ii)
Is
there
a
prop
er
path
starting
at
x
and
terminating
at
y?
(iii)
Find
all
the
prop
er
paths
starting
at
the
ro
ot
and
terminating
at
a
v
ariable.
(iv)
Sho
w
that
an
y
of
the
previous
paths
crosses
t
wice
the
@-no
de.
Example
..	
Ev
ery
path
(the
dashed
lines)
in
the
conguration
b
e-
lo
w
is
not
prop
er.
*
0
*
0
0
*
0
*
0
1
1
0
0
1
2
Notice
that
there
are
connections
b
et
w
een
principal
p
orts
of
no
des
whic
h
giv
e
rise
to
improp
er
paths.
Remark
also
that
no
rewriting
rule
has
b
een
dened
for
these
connections.


The
ful
l
algorithm
.
Correctness
of
the
algorithm
It
is
folklore
that
the
standard
syn
tax
tree
represen
tation
of
terms
ma
y
b
e
uniquely
describ
ed
b
y
the
set
of
paths
whic
h
start
at
the
ro
ot
and
terminate
at
the
no
des
of
the
tree.
These
paths
are
called
ac
c
ess
p
aths.
There
is
a
subtlet
y
for
access
paths
in
-calculus
due
to
the
presence
of
binders
and
b
ound
v
ariables.
F
or
example,
the
t
w
o
terms
K
=
x:
y:
x
and
O
=
x:
y:
y
ha
v
e
the
follo
wing
syn
tax
trees:
λx
x
λy
λx
λy
y
Notice
that
the
t
w
o
syn
tax
trees
ha
v
e
the
same
\structure"
but
dier
for
the
no
de
binding
the
leaf.
Therefore,
in
the
-calculus,
t
w
o
access
paths
are
e
qual
when
they
tra
v
erse
no
des
in
the
same
order
and
the
lea
v
es
are
b
ound
b
y
corresp
onding
binders.
W
e
will
not
b
e
fussy
on
this
issue,
since
w
e
are
sure
the
reader
has
k
ept
the
idea.
Remark
..
T
o
simplify
the
presen
tation,
in
the
follo
wing
w
e
will
restrict
without
loss
of
generalit
y
to
closed
-terms
(i.e.,
to
terms
in
whic
h
all
the
v
ariables
are
b
ound).
Hence,
an
y
access
path
ending
at
a
v
ariable
o
ccurrence
crosses
a
-o
ccurrence
binding
that
v
ariable.
As
a
consequence
all
the
sharing
graphs
w
e
will
consider
ha
v
e
just
one
en
tries,
the
r
o
ot
of
the
sharing
graph,
whic
h
w
e
ma
y
assume
to
b
e
a
no
de
with
index
0
(note
that
the
use
of
the
index
0
corresp
onds
to
the
fact
that
[M]
=
[M]
0
).
Prop
er
paths
pla
y
in
sharing
graphs
the
same
role
that
access
paths
pla
y
in
the
syn
tax
tree
represen
tation.
In
fact,
w
e
are
going
to
establish
a
one-to-one
relation
b
et
w
een
prop
er
paths
starting
at
the
ro
ot
of
a
sharing
graph
and
access
paths
of
the
asso
ciated
term.
There
are
t
w
o
main
problems
in
giving
suc
h
a
corresp
ondence:
(i)
Paths
cr
e
ate
d
by
-r
e
duction.
Ev
ery
-rule
creates
new
access
paths:
the
paths
terminating
at
the
v
ariables
b
ound
b
y
the
ab-
straction
are
lengthened
with
the
paths
starting
at
the
argumen
t

.
Corr
e
ctness
of
the
algorithm
	
of
the
application
in
the
redex.
A
similar
lengthening
happ
ens
to
prop
er
paths
when
a
-in
teraction
o
ccurs.
Ho
w
ev
er,
it
is
far
to
b
e
ob
vious
whether
the
t
w
o
lengthenings
preserv
e
the
corresp
on-
dence
b
et
w
een
access
paths
and
prop
er
paths.
(ii)
Determining
the
binder
of
a
variable
o
c
curr
enc
e.
As
w
e
said
in
the
ab
o
v
e
discussion,
in
order
to
uniquely
dene
an
access
path
terminating
at
a
b
ound
v
ariable,
one
has
to
determine
the
binder.
This
case
is
particularly
hard
in
sharing
graphs
b
ecause
there
ma
y
b
e
sev
eral
o
ccurrences
along
a
prop
er
path
of
the
same
-no
de.
F
or
example,
the
(simplied)
graph
segmen
ts
in
Fig-
ure
.
resp
ectiv
ely
o
ccur
near
the
end
of
the
ev
aluation
of
(x:
(x
y:
(x
(K
y)))

)
and
(x:
(x
y:
(x
(O
y)))

),
where
K
=
x:
y:
x,
O
=
x:
y:
y,
and

=
x:
y:
(xy).
The
dot-
ted
paths
are
prop
er
paths
terminating
at
a
v
ariable
no
de
and
tra
v
ersing
t
wice
the
same
.
In
Figure
.(a)
the
binder
of
the
v
ariable
is
the
top
,
that
is,
the
rst
one
tra
v
ersed
b
y
the
path
(the
graph
represen
ts
K);
in
Figure
.(b)
the
binder
of
the
v
ari-
able
is
the
b
ottom
,
that
is,
the
second
one
tra
v
ersed
b
y
the
path
(the
graph
represen
ts
O).
0
*
0
*
0
λ
0
1
*
0
λ
0
1
*
0
*
*
1
0
0
(a)
(b)
Fig.
..
Prop
er
paths
tra
v
ersing
t
wice
the
same
binder
Exercise
..
Pro
v
e
that
(a
part
for
a
spurious
brac
k
et
at
the
garbage
no
de)
the
graphs
of
Figure
.
normalize
to
[K]
and
[O].

0
The
ful
l
algorithm
..
Pr
op
erties
of
sharing
gr
aphs
The
correctness
of
the
algorithm
relies
on
a
few
essen
tial
prop
erties
of
prop
er
paths
and
their
con
text
seman
tics.
Let
us
start
discussing
them
(their
pro
of
is
p
ostp
oned
to
section
..).
Remark
..
In
this
and
in
the
next
sections
w
e
shall
refer
to
t
w
o
distinct
represen
tations
of
-terms:
sharing
graphs
and
syn
tax
trees.
T
o
a
v
oid
am
biguit
y
w
e
shall
use
-no
de
and
@-no
de
to
refer
to
no
des
of
the
sharing
graphs,
-o
c
curr
enc
e
and
@-o
c
curr
enc
e
to
refer
to
no
des
of
the
syn
tax
trees.
F
urthermore,
w
e
shall
use
pr
op
er
no
de
to
denote
the
ro
ot,
or
a

or
@
no
de,
while
w
e
shall
use
c
ontr
ol
no
de
to
denote
a
brac
k
et,
croissan
t
or
fan.
The
con
ten
t
of
the
rst
prop
ert
y
,
the
so-called
indep
endence
prop
ert
y
,
is
rather
tec
hnical.
Besides,
as
w
e
shall
see
farther,
indep
endence
is
the
prop
ert
y
ensuring
the
p
ossibilit
y
to
lengthen
prop
er
paths
during
-
reduction.
Prop
osition
..
(indep
enden
ce)
Given
a
pr
op
er
p
ath
'
c
onne
ct-
ing
two
pr
op
er
no
des
whose
indexes
ar
e
r
esp
e
ctively
m
and
n,
let
A
and
B
b
e
the
initial
and
nal
c
ontexts
of
'.
(i)
F
or
any
c
ontext
X,
the
pr
op
er
p
ath
'
has
a
pr
op
er
c
ontext
lab
eling
assigning
A
m
[X]
to
its
initial
e
dge.
(ii)
A
c
c
or
ding
to
the
typ
e
of
the
p
ort
r
e
ache
d
by
',
let
us
take
b
n
=
n
+

when
'
ends
at
the
binding
p
ort
of
a
-no
de,
and
b
n
=
n
otherwise
(i.e.,
'
ends
at
a
c
ontext
p
ort).
Ther
e
is
an
index
b
m

m,
such
that:
(a)
if
B
=
B
b
n
[C],
then
A
=
A
b
m
[C];
(b)
C
c
an
b
e
r
eplac
e
d
by
any
c
ontext
Y
,
i.e.,
for
any
c
ontext
Y
,
ther
e
is
a
pr
op
er
lab
eling
of
'
assigning
A
b
m
[Y
]
and
B
b
n
[Y
]
to
the
initial
and
nal
e
dges
of
';
(c)
mor
e
over,
when
'
starts
at
the
ar
gument
p
ort
of
an
@-
no
de,
we
have
inde
e
d
b
m
>
m.
In
other
w
ords,
b
y
the
rst
item
of
indep
endence,
a
forw
ard
path
'
starting
at
an
m-indexed
prop
er
no
de
is
prop
er
(or
not)
indep
enden
tly
from
the
initial
con
text
at
width
m.
In
particular,
a
path
starting
at
the
ro
ot
is
prop
er
if
and
only
if
it
has
a
prop
er
lab
eling
for
an
y
initial
con
text.
This
is
particularly
relev
an
t
for
the
read-bac
k
algorithm.
In
fact,
w
e
will
see
that
the
read-bac
k
of
a
sharing
graph
(i.e.,
the
-term

.
Corr
e
ctness
of
the
algorithm

matc
hing
it)
can
b
e
dened
in
terms
of
the
prop
er
paths
starting
at
the
ro
ot
of
the
graph.
By
indep
endence,
lo
oking
for
these
prop
er
paths
w
e
can
start
with
an
y
initial
con
text
and
w
e
do
not
need
bac
ktrac
king.
The
second
part
of
indep
endence
giv
es
instead
some
details
on
the
shap
e
of
con
texts
along
a
prop
er
path.
As
a
matter
of
fact,
niteness
of
prop
er
paths
implies
the
existence
of
some
part
of
the
initial
con
text
of
'
that
w
e
should
nd
unmo
died
in
the
nal
con
text.
Namely
,
for
an
y
index
b
n
big
enough,
w
e
exp
ect
to
ha
v
e
an
index
b
m
for
whic
h
the
initial
con
text
of
'
is
A
=
A
b
m
[C]
and
the
nal
one
is
B
=
B
b
n
[C].
Indep
endence
claries
ho
w
big
w
e
ha
v
e
to
c
ho
ose
b
n.
In
particular,
whenev
er
'
ends
at
a
con
text
p
ort,
no
con
trol
no
de
in
'
has
eect
on
the
v
alue
of
the
nal
con
text
at
width
n.
While,
in
the
case
that
'
ends
at
a
binding
p
ort
(i.e.,
it
reac
hes
a
v
ariable),
some
con
trol
no
des
in
'
migh
t
ha
v
e
written
on
lev
el
n
of
the
nal
con
text.
Indeed,
in
the
latter
case,
lev
el
n
con
tains
the
information
relativ
e
to
the
con
trol
no
des
b
elonging
to
a
so-called
lo
op
of
the
-no
de

reac
hed
b
y
'
(see
Denition
..).
Finally
,
let
us
note
that
what
w
e
nd
ab
o
v
e
b
n
in
the
nal
con
text
B
w
as
at
width
b
m

m
in
the
initial
con
text
A.
In
some
sense,
the
in-
dexes
of
the
prop
er
no
des
in
a
forw
ard
path
are
non-decreasingly
ordered
(compare
with
the
indexes
assigned
b
y
the
translation
of
Figure
.).
In
fact,
let
us
assume
that
'
end
at
a
con
text
edge,
although
the
nal
index
m
migh
t
ev
en
b
e
lo
w
er
than
n,
the
relev
an
t
information
con
tained
in
the
initial
con
text
(i.e.,
b
elo
w
lev
el
m)
that
has
not
b
een
used
along
the
path
is
recorded
in
the
lev
els
b
elo
w
n
of
the
nal
con
text.
Moreo
v
er,
let
us
tak
e
an
y
prop
er
no
de
tra
v
ersed
b
y
the
prop
er
path
',
sa
y
an
appli-
cation
@.
This
no
de
splits
'
in
t
w
o
prop
er
subpaths
'

@'

,
to
whic
h
w
e
can
separately
apply
indep
endence.
Then,
let
r
b
e
the
index
of
@
and
D
=
D
r
[E]
b
e
the
con
text
assigned
to
the
edges
of
@.
F
or
the
path
'

,
w
e
get
B
=
B
b
n
[C]
and
D
=
D
b
r
[C]
for
some
b
r

r,
and
th
us
E
=
E
k
[C]
for
some
k

0.
A
t
the
same
time,
b
y
indep
endence
of


,
w
e
get
A
=
A
e
m
[E],
for
some
e
m

m.
Summing
up,
A
=
A
e
m
[E
k
[C]]
=
A
b
m
[C],
with
b
m
=
e
m
+
k

e
m.
In
other
w
ords,
in
terpreting
b
m
and
e
m
as
the
in-
dexes
of
the
corresp
onding
no
des
rep
orted
to
the
initial
no
de
of
'
(note
that
e
m
and
b
m
are
denitely
functions
of
r
and
n,
resp
ectiv
ely),
w
e
see
that
suc
h
rep
orted
indexes
are
non-decreasingly
ordered
along
a
prop
er
path.
As
a
matter
of
fact,
the
previous
consideration
immediately
forbids
congurations
lik
e
the
ones
in
Figure
..
In
all
these
cases
the
paths
crossing
the
con
trol
no
des
are
prop
er;
nev
ertheless,
the
indexes
asso
ci-


The
ful
l
algorithm
ated
to
them
are
incompatible
with
indep
endence
(in
particular,
the
last
remark
on
paths
starting
with
an
argumen
t
edge
forbids
the
righ
tmost
case).
λ 1
@2
λ 1
λ 2
@1
λ 1
Fig.
..
Prop
er
congurations
incompatibl
e
with
indep
endence
The
next
t
w
o
exercises
formalize
some
of
the
previous
considerations.
Exercise
..
Let
'
b
e
a
forw
ard
prop
er
path.
Using
indep
endence
prop
ert
y
,
pro
v
e
that
there
is
a
prop
er
lab
eling
suc
h
that
the
width
of
the
con
text
at
the
con
text
p
ort
of
an
y
n-indexed
prop
er
no
de
is
lo
w
er
than
n.
Exercise
..
Let
'
b
e
a
forw
ard
prop
er
path
ending
at
an
n-indexed
prop
er
no
de.
Let
A
and
B
b
e
resp
ectiv
ely
the
con
texts
of
the
rst
and
last
edge
of
'.
Pro
v
e
that:
(i)
T
o
an
y
mark
er
of
a
fan
auxiliary
p
ort
con
tained
in
B,
sa
y
a

sym
b
ol,
w
e
can
asso
ciate
a
(unique)
fan-in
crossed
b
y
'
that
wrote
this

in
B,
or
conclude
that
suc
h
a

w
as
already
presen
t
in
A
(w
e
lea
v
e
to
the
reader
the
exact
formalization
of
the
concepts
\write
in
the
con
text"
and
\w
as
already
presen
t
in
the
con
text").
(ii)
Pro
v
e
that
an
y

in
B
has
not
b
een
written
b
y
a
fan-in
crossed
b
y
'
if
and
only
it
can
b
e
replaced
b
y
an
y
other
(p
ossibly
empt
y)
sequence
of

and

sym
b
ols
(i.e.,
for
an
y
con
text
B
0
obtained
from
B
b
y
the
previous
replacing,
there
is
a
prop
er
con
text
lab
eling
assigning
B
0
to
the
last
edge
of
').
(iii)
Using
indep
endence,
pro
v
e
that
no
fan-in
crossed
b
y
'
can
write
a

in
the
sub
con
text
of
B
at
width
b
n
(i.e.,
an
y

con
tained
in
a
con
text
X
suc
h
that
B
b
n
[X]
w
as
already
presen
t
in
the
initial
con
text
A),
where
b
n
is
dened
as
for
indep
endence.
(iv)
Extend
the
previous
results
to
brac
k
ets
and
croissan
ts.
Another
relev
an
t
consequence
of
indep
endence
is
that,
in
certain
cases,
w
e
can
safely
comp
ose
t
w
o
prop
er
paths
'

and
'

resp
ectiv
ely
ending

.
Corr
e
ctness
of
the
algorithm

and
starting
at
suitable
n-indexed
no
des,
ev
en
when
the
nal
con
text
of
'

and
the
initial
con
text
of
'

dier
for
the
sub
con
text
at
width
n.
In
particular,
suc
h
a
king
of
comp
osition
o
ccurs
when
a
-reduction
is
p
erformed.
In
this
case
an
y
path
'

starting
at
the
@-no
de
in
the
redex
is
app
ended
to
one
or
more
corresp
onding
paths
'

ending
at
the
binding
p
ort
of
the
-no
de
in
the
redex.
What
w
e
ha
v
e
to
pro
v
e
is
that
this
comp
osition
is
sound;
namely
,
that
the
meaningful
part
of
the
nal
con
text
of
'

matc
hes
with
the
meaningful
part
of
the
initial
con
text
of
'

(i.e.,
the
lev
els
b
elo
w
n
coincide),
if
and
only
if
the
paths
p

and
p

,
resp
ectiv
ely
corresp
onding
to
'

and
'

in
the
matc
hing
syn
tax
tree,
are
connected
to
the
same
redex
(i.e.,
the
corresp
onding
reduction
of
the
syn
tax
tress
creates
an
access
path
p


p

in
the
result).
This
is
the
purp
ose
of
the
follo
wing
nesting
and
transparency
prop
erties.
Prop
osition
..
(nesting)
Every
pr
op
er
p
ath
starting
at
the
r
o
ot
no
de
never
r
e
aches
twic
e
the
c
ontext
p
ort
of
a
n-indexe
d
pr
op
er
no
de
with
two
c
ontexts
whose
rst
n
levels
ar
e
e
qual.
The
rst
p
oin
t
to
remark
is
that
the
nesting
prop
ert
y
giv
es
a
w
a
y
for
separating
t
w
o
o
ccurrences
of
the
same
-no
de
in
a
prop
er
path.
Let
us
consider
for
instance
the
t
w
o
graphs
in
Figure
..
In
b
oth
cases
(a)
and
(b)
the
t
w
o
o
ccurrences
of

are
accessed
with
t
w
o
dieren
t
con
texts
hX;


i
and
hX;


i.
Secondly
,
the
nesting
prop
ert
y
is
necessary
if
w
e
w
an
t
to
ac
hiev
e
that
the
length
of
an
y
prop
er
path
starting
at
the
ro
ot
is
nite,
that
at
its
turn
is
a
necessary
condition
implied
b
y
the
fact
that
w
e
w
an
t
to
nd
a
direct
corresp
ondence
b
et
w
een
prop
er
paths
and
access
paths.
Let
us
no
w
come
to
the
crucial
notion
of
binding
lo
op.
Denition
..
(lo
op)
A
lo
op
is
a
prop
er
path
that
starts
at
the
b
o
dy
of
a
-no
de
and
terminates
at
the
binding
p
ort
of
the
same
-no
de.
A
lo
op
'
of
an
n-indexed
-no
de
is
a
binding
lo
op
if
the
initial
con
text
A
and
the
nal
con
text
B
of
'
are
equal
up
to
the
sub
con
text
at
width
n.
Namely
,
'
is
a
binding
lo
op
when
A
n
[

]
=
B
n
[

].
As
a
consequence
of
the
prop
ert
y
of
nesting,
a
lo
op
has
at
most
one
sux
whic
h
is
a
binding
lo
op.
The
underlying
idea
is
that
the
o
c-
currence
of
the
-no
de
binding
a
v
ariable
is
uniquely
determined
b
y
a
binding
lo
op.
Because
of
the
indep
endence
prop
ert
y
,
this
ts
w
ell
with
the
p
ossible
lengthening
of
the
lo
op
when
the
binder
will
b
e
reduced
(see
Exercise
..	).
Note
moreo
v
er
that
not
ev
ery
lo
op
is
a
binding
lo
op.


The
ful
l
algorithm
Let
us
consider
again
the
example
in
Figure
.(a).
As
w
e
already
remark
ed,
the
rst
o
ccurrence
of

is
tra
v
ersed
with
con
text
hX;


i,
while
the
second
o
ccurrence
is
tra
v
ersed
with
con
text
hX;


i.
No
w,
when
w
e
come
bac
k
to
the
-no
de,
the
con
text
is
hhX;
i;


i,
that
coincides
with
the
con
text
corresp
onding
to
the
rst
tra
v
ersal
of
,
up
to
the
sub
con
text
at
width
.
So,
this
is
the
real
binder.
Con
v
ersely
,
in
case
(b),
the
nal
con
text
of
the
lo
op
is
hhX;
i;


i,
that
coincides
with
the
con
text
corresp
onding
to
the
se
c
ond
tra
v
ersal
of
,
up
to
the
sub
con
text
at
width
.
Let
us
consider
another
example.
The
sharing
graph
in
Figure
.	
is
a
represen
tation
of
x:y:
(x
y).
A
similar
conguration
ma
y
app
ear
during
the
reduction
of
(x:
(x
x)
x:y:
(x
y))
(pro
v
e
it
as
an
exercise).
λy
λx
@
x
y
0
λ1
0
0
0
*
0
0
0
1
2
1
0
*
0
@
0
1
*
0
0
0
0
1
Fig.
.	.
Binding
Lo
ops.
Again,
w
e
ha
v
e
a
double
tra
v
ersal
of
the
-no
de
b
efore
reac
hing
the
application:
the
rst
time.
en
tering
the
-no
de
with
con
text
hX;


i;
the
second
one
en
tering
it
with
con
text
hX;


h;
ii.
Then,
when
w
e
ev
en
tually
reac
h
the
application,
w
e
ha
v
e
t
w
o
p
ossibilities.
If
w
e
follo
w
the
functional
p
ort
of
the
application,
w
e
come
bac
k
to
the
-no
de
with

.
Corr
e
ctness
of
the
algorithm

con
text
hhX;
h;
ii
i.
Th
us,
in
this
case,
the
v
ariable
is
b
ound
b
y
the
-o
ccurrence
corresp
onding
to
the
rst
tra
v
ersal
of
-no
de.
On
the
other
side,
if
w
e
follo
w
the
argumen
t
p
ort
of
the
application,
w
e
come
bac
k
to
the
-no
de
with
con
text
hX
0
;
h;
a
0
ii;


h;
ii,
where
X
=
hX
0
;
a
0
i.
In
this
case,
the
v
ariable
is
th
us
b
ound
b
y
the
-o
ccurrence
corresp
onding
to
the
second
tra
v
ersal
of
the
-no
de.
As
already
remark
ed,
-reduction
corresp
onds
to
comp
osition
of
prop
er
paths;
moreo
v
er,
binding
lo
ops
are
the
k
eystones
of
suc
h
a
comp
osition.
The
follo
wing
exercise
giv
es
a
rst
idea
of
that
role
of
binding
lo
ops.
Exercise
..	
Let
'

v
c

w
a

 
and
'

v
c

u

v
b



w
v
b
e
t
w
o
prop
er
paths
starting
at
the
ro
ot
and
suc
h
that:
(i
)
u
is
a
-redex;
(ii
)
w
a
is
the
argumen
t
edge
of
the
@-no
de
of
u;
(iii
)

is
a
binding
lo
op.
Let
v
b
e
the
edge
obtained
merging
the
con
text
edge
v
c
and
the
b
o
dy
edge
v
b
(i.e.,
v
is
the
con
traction
of
the
path
v
c

u

v
b
);
and
let
w
b
e
the
edge
obtained
merging
the
binding
edge
w
v
and
the
argumen
t
edge
w
a
(i.e.,
w
is
the
con
traction
of
the
path
w
v

u

w
a
).
Pro
v
e
that
the
path
'

v



w

 
is
prop
er.
So
far,
w
e
ha
v
e
no
w
a
y
to
ensure
that
an
y
prop
er
path
ending
at
a
v
ariable
corresp
onds
to
a
prop
erly
b
ound
v
ariable.
The
next
prop
ert
y
of
transparency
guaran
tees
that
to
reac
h
a
v
ariable
w
e
also
ha
v
e
to
cross
its
binder.
Prop
osition
..0
(transparency)
Every
pr
op
er
p
ath
starting
at
the
r
o
ot
and
terminating
at
a
binding
p
ort
has
a
sux
which
is
a
binding
lo
op.
Let
us
no
w
consider
a
more
in
v
olv
ed
example.
The
sharing
graph
in
Figure
.0
is
a
represen
tation
of
the
-term:
y:(
(w:((w:(y
w))
y)
w)
((w:(y
w))
y)):
A
similar
conguration
ma
y
app
ear
during
the
reduction
of
the
-term:
(x:y:
(x
(x
y))
z:((w:
(z
w))
z)):
W
e
ha
v
e
three
p
ossible
tra
v
ersals
of
the
-no
de
in
v
olv
ed
in
the
-
redex
and
sev
eral
o
ccurrences
of
v
ariables
b
ound
b
y
corresp
onding
-
o
ccurrences.
(F
or
the
sak
e
of
simplicit
y
and
referring
to
the
syn
tax-tree
on
the
righ
t
of
Figure
.0,
let
us
en
umerate
these
o
ccurrences
according


The
ful
l
algorithm
λy
λw
@
w
λw
@
y
@
w
y
λw
@
@
y
@
w
y
@1
0
1
0
*
0
*
0
@1
λ1
0
λ0
0
0
1
0
1
2
1
*
1
0
*
2
1
0
1
0
1
0
0
0
1
@0
0
*
0
*
2
1
Fig.
.0.
An
in
v
olv
ed
example.
to
a
depth-rst-left-rst
tra
v
ersal
of
the
syn
tax
tree.)
Let
hhX;
a

i;
a
0
i
b
e
the
initial
con
text.
The
rst
o
ccurrence
of
w
is
reac
hed
with
con
text
hhhX;
a

i;
a
0
i;


i;
the
second
with
con
text
hhhX;
a

i;
a
0
i;


h;


ii
and
the
third
with
con
text
hhhX;
a

i;
a
0
i;


h;


ii:

.
Corr
e
ctness
of
the
algorithm

The
three
(linear)
o
ccurrences
of
w
are
resp
ectiv
ely
reac
hed
with
con-
texts:
hhhX;
a

i;
h;
a
0
ii;


i
hhhX;
a

i;
h;
a
0
ii;


h;


ii
hhhX;
a

i;
h;
a
0
ii;


h;


ii
On
the
other
side,
w
e
ha
v
e
a
single
o
ccurrence
of
y,
reac
hed
with
the
initial
con
text
hhX;
a

i;
a
0
i
(therefore,
every
lo
op
will
b
e
a
binding
lo
op).
In
this
case,
w
e
ha
v
e
four
lo
ops,
corresp
onding
to
the
four
o
ccurrences
of
y.
They
are
resp
ectiv
ely
reac
hed
with
con
texts:
hhX;
a

i;
a
0
i;
hh;


i;


ii
hhX;
a

i;
hh;


h;
a
0
ii;


ii
hhX;
a

i;
hh;


i;


h;
a
0
iii
hX;
hh;


h;
a

ii;


h;
a
0
iii
Supp
ose
no
w
to
re
the
redex
in
the
sharing
graph
in
Figure
.0,
that
corresp
onds
to
three
redexes
in
the
asso
ciated
-term.
One
ma
y
w
onder
what
happ
ens
of
the
(distinguished!)
argumen
ts
of
these
redexes.
First
of
all,
what
are
these
argumen
ts?
They
are
dened
b
y
the
paths
whic
h
can
b
e
lab
eled
with
an
initial
con
text
corresp
onding
to
the
tra
v
ersal
of
the
resp
ectiv
e
application.
Moreo
v
er,
these
con
texts
are
just
the
three
con
texts
corresp
onding
to
the
three
o
ccurrences
of
w
dened
ab
o
v
e,
and
whic
h,
b
y
indep
endence,
can
b
e
simplied
in
to:
hX
0
;


i
hX
00
;


h;


ii
hX
000
;


h;


ii
where
X
0
;
X
00
and
X
000
are
arbitrary
.
But,
b
y
denition,
no
binding
lo
op
for
w
can
mo
dify
lev
el
0
of
that
con
texts.
So,
eac
h
\lo
op"
will
b
e
connected
to
the
righ
t
argumen
t.
On
the
other
hand,
supp
ose
to
add
an
application
with
argumen
t
N
(that
will
b
e
at
lev
el
)
on
top
of
our
graph.
In
this
case,
the
same
argumen
t
N
is
the
same
for
all
binding
lo
ops
for
y
(here
w
e
ha
v
e
a
single
o
ccurrence
of
y
with
m
ultiple
o
ccurrences
of
y).
Ho
w
do
w
e
distinguish
among
the
dieren
t
instances
of
N
after
the
reduction?
The
k
ey
p
oin
t
is
that
t
w
o
binding
lo
ops
for
the
same
tra
v
ersal
of
an
n-
indexed
-no
de
are
distinguished
b
y
their
sub
con
texts
at
width
n.
The
see
this,
let
us
compare
t
w
o
binding
lo
ops


and


for
the
same
-no
de


The
ful
l
algorithm
starting
from
their
binding
p
ort.
Since
the
the
t
w
o
paths
are
distinct,
they
m
ust
ev
en
tually
dier
after
a
common
p
ostx
.
Moreo
v
er,
it
is
indeed
imm
ediate
to
see
that
this
m
ust
happ
en
at
a
fan-in
that


and


crosses
through
distinct
auxiliary
p
orts,
sa
y

and
,
resp
ectiv
ely
.
According
to
what
stated
in
Exercise
..,
the
fan-in
preceding

writes
a

in
the
nal
con
text
B

of


,
and
analogously
,
it
writes
a

in
the
corresp
onding
p
osition
of
the
nal
con
text
B

of


.
W
e
can
then
conclude
that
B

dier
from
B

,
at
least
for
the
presence
of
a

in
the
place
of
a
.
By
the
w
a
y
,
when
suc
h
a
dierence
is
in
a
lev
el
b
elo
w
n,
the
t
w
o
binding
lo
ops
corresp
onded
to
t
w
o
distinct
tra
v
ersal
of
the
-no
de,
that
is
not
the
case
in
whic
h
w
e
are
in
terested
no
w;
otherwise,
the
t
w
o
dierences
are
in
the
sub
con
texts
at
width
n.
Moreo
v
er,
b
y
the
indep
endence
prop
ert
y
,
the
previous
dierence
m
ust
necessarily
b
e
con
tained
in
the
lev
el
n
of
B

and
B

,
(i.e.,
if
B
n

[

]
=
B
n

[

]
and
B
i
=
B
n
i
[hC
i
;
b
i
i]
with
i
=
;
,
then
b

=
b

).
F
or
instance,
the
four
binding
lo
ops
of
y
in
the
previous
example
dier
at
least
for
their
lev
el
0.
T
o
conclude
this
analysis,
w
e
in
vite
the
reader
to
giv
e
a
formal
pro
of
a
formal
pro
of
of
the
previous
fact
on
binding
lo
ops
exploiting
the
results
in
Exercise
...
Exercise
..
V
erify
that
the
sharing
graphs
in
Figure
.
and
Fig-
ure
.	
ha
v
e
the
prop
erties
of
indep
endence,
nesting,
and
transparency
.
Exercise
..
The
sharing
graph
in
Figure
.
is
part
of
the
sharing
graph
in
Figure
..
Pro
v
e
that
the
prop
erties
of
indep
endence,
nesting,
and
transparency
hold
for
these
sharing
graphs.
..
Corr
esp
ondenc
e
b
etwe
en
sharing
gr
aphs
and
-terms
Denition
..
An
access
path
p
c
orr
esp
onds
to
a
prop
er
path
'
('
is
supp
osed
to
start
at
the
ro
ot)
if
p
tra
v
erses
prop
er
no
des
in
the
same
order
as
'
and
from
the
same
p
orts.
Moreo
v
er,
if
'
terminates
at
a
binding
p
ort,
the
nal
v
ariable
of
p
is
the
v
ariable
b
ound
b
y
the
unique
abstraction
along
p
corresp
onding
to
the
-no
de
of
the
binding
lo
op.
A
sharing
graph
G
matches
with
a
syn
tax
tree
N
if
there
exists
a
bijectiv
e
function
f
from
prop
er
paths
of
G
from
the
ro
ot
and
to
prop
er
no
des
and
access
paths
in
N
suc
h
that:
(i)
for
ev
ery
',
f(')
corresp
onds
to
';
(ii)
if
'

 
and
'
terminate
at
prop
er
no
des,
then
there
exists
a
path
q
suc
h
that
f('

 )
=
f(')

q.

.
Corr
e
ctness
of
the
algorithm
	
*
@ 1
*
*
0
0
0
1
1
0
*
0
0
λ
0
λ
0
0
Fig.
..
Sharing
graph
for
Exercise
..
and
Exercise
...
Exercise
..
Pro
v
e
that
the
sharing
graph
of
Figure
.
matc
hes
with
the
-term
y:
x:
((x
x)
(y
y)).
Since
the
function
f
b
et
w
een
the
prop
er
paths
of
G
and
the
access
paths
of
the
syn
tax
tree
N
is
a
bijection,
its
in
v
erse
function
f
-
maps
an
y
access
path
of
N
to
a
prop
er
path
starting
at
the
ro
ot
and
ending
at
a
prop
er
no
de
of
G.
Indeed,
suc
h
a
function
f
-
is
a
function
mapping
an
y
path
of
N
in
to
a
prop
er
path
of
G.
In
fact,
let
p
b
e
the
access
path
of
an
edge
e
p
of
N;
taking
g(e
p
)
=
f
-
(),
where
'
and

are
the
unique
prop
er
paths
suc
h
that
p
=
f(')
and
p

e
p
=
f('

);
w
e
can
dene
g(e




e
k
)
=
g(e

)



g(e
k
).
It
is
not
dicult
to
c
hec
k
that
the
restriction
of
g
to
the
access
paths
of
N
coincide
with
f
-
.
W
e
remark
that,
for
an
y
edge
e,
the
prop
er
path
g(e)
con
tains
only
brac
k
ets
and
fans
and
connects
t
w
o
prop
er
no
des.
In
particular,
for
an
y
-redex
u
of
G
there
is
a
set
U
=
fu

;
:
:
:
;
u
k
g
of
corresp
onding
-redexes
of
N
suc
h
that
g(u
i
)
=
u,
for
i
=
;
:
:
:
;
k.
W
e
will
see
that
the
reduction

0
The
ful
l
algorithm
of
u
corresp
onds
to
the
sim
ultaneous
reduction
of
all
the
redexes
in
U
.
But
to
pro
v
e
this,
w
e
need
to
pro
v
e
that
all
the
rules
of
the
algorithm
are
sound
with
resp
ect
to
the
corresp
ondence
b
et
w
een
sharing
graphs
and
syn
tax
trees
established
b
y
Denition
...
Theorem
..
(correctness)
F
or
any
sharing
gr
aph
r
e
duction
[M]

G,
ther
e
exists
a
c
orr
esp
onding
-term
r
e
duction
M

N
such
that
G
matches
N.
The
tough
part
of
Theorem
..
is
the
pro
of
that
-rule
preserv
es
the
righ
t
corresp
ondence
.
In
more
details,
let
[M]

G
0
u
!
G,
where
u
is
a
-redex.
Assuming
that
correctness
holds
for
G
0
,
w
e
ha
v
e
a
-term
N
0
that
matc
hes
with
G
0
.
W
e
need
to
nd
a
-term
N
that
matc
hes
with
G
and
to
pro
v
e
that
N
0

N.
Let
us
analyze
in
more
details
wh
y
suc
h
a
case
is
not
direct.
@n
λx
n
ζ
φ
λn
u
ψ
ϕ
@
x
p
r
up
sharing graph G’
syntax tree N’
n
z
q
Fig.
..
P
aths
in
v
olv
ed
in
a
-reduction.
The
problem
is
illustrated
b
y
Figure
.
(in
the
follo
wing
example
the
names
of
the
paths
will
corresp
ond
to
the
ones
used
in
suc
h
a
gure).
T
o
start,
let
us
assume
that
'
b
e
the
unique
prop
er
path
ending
at
the
@-no
de
of
the
redex
u.
That
is,
the
edge
u
p
is
the
unique
-redex
corresp
onding
to
u.
As
w
e
already
said,
in
this
case
w
e
shall
pro
v
e
that
N
0
u
p
!
N.
Here,
let
us
see
ho
w
the
paths
of
G
0
and
N
0
are
c
hanged
b
y
the
reduction
of
u
and
u
p
.
W
e
can
distinguish
t
w
o
cases:
(i
)
the
path
ends
at
a
prop
er
no
de
in
the
b
o
dy
of
the
redex;
(ii
)
the
path
ends
at
a
prop
er
no
de
in
the
argumen
t
of
the
redex.
In
fact,
the
reduction
lea
v
es
unc
hanged
all
the
paths
with
a
dieren
t
shap
e.

.
Corr
e
ctness
of
the
algorithm

In
the
rst
case,
the
prop
er
path
crosses
the
edge
u
and
the
corre-
sp
onding
access
path
crosses
the
edge
u
p
.
The
reduction
erases
the
edge
u
of
the
prop
er
path
'

u


and
the
edge
u
p
of
the
corresp
onding
access
path
p

u
p

z,
giving
'


and
p

z.
Th
us,
w
e
see
that
prop
erness
of
'


follo
ws
from
prop
erness
of
'

u


and
that
the
corresp
ondence
b
et
w
een
the
paths
is
preserv
ed,
i.e.,
'


and
p

z
corresp
ond.
(Note
the
small
abuse
of
notation
in
the
last
writing.
In
fact,
after
the
reduction,
the
last
edge
of
'
and
the
rst
of

are
merged,
and
similarly
for
the
last
edge
of
p
and
z.)
In
the
second
case,
the
dicult
one,
the
prop
er
path
crosses
the
@-
no
de
of
the
redex
from
the
con
text
p
ort
to
the
argumen
t
p
ort,
and
similarly
for
the
corresp
onding
access
path
and
@-o
ccurrence.
W
e
ha
v
e
then
a
prop
er
path
'

 
and
a
corresp
onding
access
path
p

r.
Here,
rather
than
erasing
edges,
the
-reduction
of
u
inserts
a
path
in
the
place
of
the
@-no
de
and
a
path
in
the
place
of
the
@-o
ccurrence.
In
fact,
for
an
y
binding
lo
op
,
and
an
y
corresp
onding
path
q
(connecting
the
matc
hing
-o
ccurrence
to
an
o
ccurrence
of
its
b
ound
v
ariable),
w
e
get
a
new
prop
er
path
'



 ,
and
a
new
access
path
p

q

r.
The
situation
is
th
us
no
more
direct
as
in
the
rst
case.
But,
b
y
denition
of
binding
lo
op
and
indep
endence,
the
insertion
of
the
lo
op

has
no
impact
on
prop
erness
(see
Exercise
..	).
Unfortunately
,
the
reasoning
is
no
more
so
straigh
t
when
the
restric-
tion
on
u
is
remo
v
ed.
In
the
general
case,
the
paths
',
,
 
and

ma
y
cross
at
their
turn
the
@-no
de
of
the
redex,
either
to
w
ards
the
b
o
dy
of
the
redex
than
to
w
ards
the
argumen
t.
In
particular,
the
second
case
of
the
simplied
example
b
ecomes
ev
en
more
in
v
olv
ed,
for
the
lo
op

is
no
more
a
prop
er
path
of
G
but
a
path
that
migh
t
ha
v
e
b
een
expanded
at
its
turn.
T
o
tak
e
in
to
accoun
t
this
sort
of
recursiv
e
expansion,
w
e
need
to
extend
the
denition
of
prop
er
path.
..
Exp
ande
d
pr
op
er
p
aths
An
exp
ande
d
forwar
d
p
ath
is
a
sequence
of
edges
concatenated
according
to
the
construction
rules
of
forw
ard
paths
plus
the
follo
wing
comp
osition
rule:
the
sequence
'

u

 
is
an
expanded
forw
ard
path
when
u
is
a
-redex,
'
ends
at
the
binding
p
ort
of
the
-no
de
of
u,
and
 
starts
at
the
argumen
t
p
ort
of
the
@-no
de
of
u.
Let
us
note
that
in
the
previous
comp
osition
rule,
the
o
ccurrence
u
of
the
-redex
u
is
crossed
follo
w-
ing
the
bac
kw
ard
orien
tation.
(The
underlining
has
b
een
in
tro
duced
to
emphasize
this
p
oin
t.)
Let
us
also
note
that
suc
h
underlined
-redex


The
ful
l
algorithm
are
the
only
edges
that
an
expanded
prop
er
path
crosses
according
to
bac
kw
ard
orien
tation.
The
idea
is
that
exp
ande
d
forwar
d
p
ath
are
just
the
paths
that
can
b
e
con
tracted
in
to
forw
ard
paths
b
y
the
ring
of
some
redex.
W
e
shall
pro
v
e
that,
pro
vided
indep
endence,
nesting,
and
transparency
for
for-
w
ard
prop
er
paths,
they
hold
for
expanded
paths
as
w
ell.
This
is
essen-
tially
enough
to
pro
v
e
Theorem
...
Denition
..
The
set
of
the
(forw
ard)
exp
ande
d
pr
op
er
p
aths
(start-
ing
at
the
ro
ot)
is
the
smallest
set
of
expanded
forw
ard
paths
suc
h
that:
(i)
An
y
prop
er
path
starting
at
the
ro
ot
is
an
expanded
prop
er
path.
(ii)
'

u



u

 
is
an
expanded
prop
er
path
when:
(a)
u
is
a
-redex;
(b)
'

 
is
an
expanded
prop
er
path
and
 
starts
at
the
argumen
t
p
ort
of
the
@-no
de
of
u;
(c)

is
a
binding
lo
op
and
'

u


is
an
expanded
prop
er
path.
The
notion
of
prop
er
lab
eling
giv
en
for
prop
er
paths
applies
to
ex-
panded
paths
to
o,
assuming
that,
in
addition
to
the
constrain
ts
of
Def-
inition
..,
an
y
con
text
edge
of
a
-no
de
follo
wing
a
binding
edge
is
lab
eled
b
y
the
same
con
text
of
the
binding
edge.
Also
the
denition
of
binding
lo
op
can
then
b
e
extended
to
expanded
paths.
Namely
,
an
exp
ande
d
binding
lo
op
is
an
expanded
path
connecting
the
b
o
dy
p
ort
to
the
binding
p
ort
of
the
same
-no
de
with
a
prop
er
lab
eling
suc
h
that
the
initial
and
nal
con
texts
are
equal
up
to
the
sub
con
text
at
width
n,
where
n
is
the
index
of
the
lo
op
-no
de.
W
e
stress
that
an
expanded
prop
er
path
ma
y
con
tain
t
w
o
o
ccurrences
of
the
same
edge
u
with
the
same
con
text.
In
fact,
for
an
y
lo
op
,
the
con
texts
A
and
B
of
the
t
w
o
o
ccurrences
of
u
in
the
expanded
path
'

u



u

 
ma
y
b
e
equal.
Moreo
v
er,
ev
en
when
A
=
B,
the
con
texts
A
and
B
are
denitely
equal
up
to
the
sub
con
text
at
width
n,
where
n
is
the
index
of
the
-no
de
of
u.
Nev
ertheless,
this
do
es
not
con
tradict
the
nesting
prop
ert
y
,
as
nesting
prop
ert
y
compares
the
con
texts
of
forw
ard
orien
ted
edges
only
.
The
analogous
of
the
prop
erties
of
indep
endence,
nesting,
and
trans-
parency
hold
for
expanded
prop
er
paths
assuming
that
suc
h
prop
erties
hold
for
prop
er
paths,
as
claimed
b
y
the
next
lemma.
Lemma
..
The
pr
op
erties
of
forwar
d
pr
op
er
p
aths
given
in
Pr
op
o-

.
Corr
e
ctness
of
the
algorithm

sition
..,
Pr
op
osition
..
and
Pr
op
osition
..0
imply
the
fol
lowing
pr
op
erties
of
exp
ande
d
pr
op
er
p
aths:
(indep
endenc
e)
Given
a
pr
op
er
c
ontext
lab
eling
of
an
exp
ande
d
pr
op
er
p
ath
'
ending
at
an
n-indexe
d
pr
op
er
no
de,
let
B
b
e
the
nal
c
ontext
of
'
and
A
b
e
the
c
ontext
of
an
e
dge
v
in
'
fol
lowing
an
m-indexe
d
pr
op
er
no
de.
(i)
F
or
any
c
ontext
X,
the
pr
op
er
p
ath
'
has
a
pr
op
er
c
ontext
lab
eling
assigning
A
m
[X]
to
the
e
dge
v.
(ii)
A
c
c
or
ding
to
the
typ
e
of
the
p
ort
r
e
ache
d
by
',
let
us
take
b
n
=
n
+

when
the
last
e
dge
of
'
is
a
r
everse
d
-r
e
dex
or
'
ends
at
a
binding
p
ort,
and
b
n
=
n
otherwise
(i.e.,
'
ends
at
a
c
ontext
p
ort).
Ther
e
is
an
index
b
m

m,
such
that:
(a)
if
A
=
A
b
m
[C],
then
B
=
B
b
n
[C];
(b)
C
c
an
b
e
r
eplac
e
d
by
any
c
ontext
Y
,
i.e.,
for
any
c
ontext
Y
,
ther
e
is
a
pr
op
er
lab
eling
of
'
assigning
A
b
m
[Y
]
to
v
and
B
b
n
[Y
]
to
the
nal
e
dge
of
 ;
(c)
mor
e
over,
when
v
is
a
r
everse
r
e
dex
or
the
ar-
gument
e
dge
of
an
@-no
de
an
ar
gument
p
ort,
we
have
inde
e
d
b
m
>
m.
(nesting)
A
n
exp
ande
d
pr
op
er
p
ath
never
r
e
aches
twic
e
the
c
ontext
p
ort
of
an
n-indexe
d
pr
op
er
no
de
with
two
c
ontexts
whose
rst
n
levels
ar
e
e
qual.
(tr
ansp
ar
ency)
Every
exp
ande
d
pr
op
er
p
ath
terminating
at
a
binding
p
ort
has
a
sux
which
is
an
exp
ande
d
binding
lo
op.
The
only
dierence
with
resp
ect
to
to
forw
ard
prop
er
paths
is
the
statemen
t
of
indep
endence.
In
fact,
for
expanded
prop
er
paths
alw
a
ys
start
at
the
ro
ot,
w
e
had
to
rearrange
the
form
ulation
of
indep
endence.
Indeed,
in
the
case
of
non-expanded
prop
er
paths
the
form
ulations
of
indep
endence
in
Lemma
..
and
Prop
osition
..
are
indeed
equiv-
alen
t:
it
suces
to
note
that
an
y
subpath
of
a
(non-expanded)
prop
er
path
is
prop
er,
and
to
note
that
indep
endence
is
trivially
comp
ositional
for
(non-expanded)
prop
er
paths.
Let
us
also
remark
that
also
the
form
ulation
of
indep
endence
in
Lemma
..
implies
the
existence
of
a
prop
er
lab
eling
for
an
y
con
text
assigned
to
the
initial
edge
of
an
expanded
prop
er
path
(remind
that
an
expanded
prop
er
path
alw
a
ys
starts
at
the
ro
ot).
The
pro
of
of
Lemma
..,
will
b
e
giv
en
in
section
...
Besides,


The
ful
l
algorithm
Lemma
..
allo
ws
to
nally
pro
v
e
that
sharing
graph
reduction
is
correct.
Exercise
..
Pro
v
e
that
an
y
prex
of
an
expanded
prop
er
path
is
an
expanded
prop
er
path.
Exercise
..	
Let

b
e
an
expanded
prop
er
path
suc
h
that

=
'

u



u

 ,
for
some
expanded
binding
lo
op

and
some
-redex
u.
(i)
Pro
v
e
that
'

u

 
and
'


are
expanded
prop
er
paths.
(ii)
Let
v
and

0
b
e
another
-redex
and
another
expanded
binding
lo
op
suc
h
that

=
'
0

v


0

v

 
0
.
Assume
that
Lemma
..
holds
for
the
expanded
prop
er
paths
'

u

 ,
'

,
'
0

v

 
0
,
and
'
0


0
.
Pro
v
e
that

\

0
=
;
implies
either



0
or

0

.
Exercise
..0
An
alternativ
e
denition
of
expanded
binding
lo
op
migh
t
b
e
giv
en
b
y
a
constructiv
e
tec
hnique
similar
to
the
one
used
to
dene
expanded
prop
er
paths.
Namely
,
w
e
migh
t
sa
y
that
an
expanded
path

starting
at
the
b
o
dy
p
ort
of
a
-no
de
is
an
expanded
binding
lo
op
when:
(i)

is
a
binding
lo
op,
or
(ii)

=
'

u



u

 ,
where
(a)
u
is
a
-redex;
(b)
'

 
is
an
expanded
binding
lo
op
and
 
starts
at
the
argumen
t
p
ort
of
the
@-no
de
of
u;
(c)

is
an
expanded
binding
lo
op
and
'

u


is
an
expanded
prop
er
path.
Pro
v
e
that
the
latter
denition
of
expanded
binding
lo
op
is
equiv
alen
t
to
the
original
one.
F
urthermore,
pro
v
e
that
expanded
binding
lo
ops
migh
t
b
e
used
to
reform
ulate
the
denition
of
expanded
prop
er
paths,
replacing
\
is
an
expanded
binding
lo
op"
for
\
is
a
binding
lo
op".
..
Pr
o
of
of
The
or
em
..
(c
orr
e
ctness)
Before
to
en
ter
in
to
the
details
of
the
pro
of,
let
us
in
tro
duce
some
ter-
minology
.
First
of
all,
the
denition
of
expanded
path
can
b
e
reform
ulated
for
ac-
cess
paths
to
o,
simply
replacing
\access"
for
an
y
o
ccurrence
of
\prop
er"
Denition
...
W
e
get
in
this
w
a
y
that:
(i)
An
y
access
path
is
also
an
exp
ande
d
ac
c
ess
p
ath.

.
Corr
e
ctness
of
the
algorithm

(ii)
An
y
sequence
p

u

q

u

r
is
an
expanded
access
path
when:
(i
)
u
is
a
-redex;
(ii
)
p

u

q
and
p

r
are
expanded
access
paths;
(iii
)
q
is
an
expanded
access
lo
op
(i.e.,
it
starts
at
the
b
o
dy
p
ort
of
a
-no
de
and
ends
at
a
v
ariable
o
ccurrence
b
ound
b
y
the
previous
-no
de).
Secondly
,
giv
en
a
syn
tax
tree
-reduction
N
0
!
N
let
us
dene
a
residual
relation
b
et
w
een
edges
and
paths.
Namely
,
an
edge
u
of
N
is
a
r
esidual
of
an
edge
e
0
of
N
0
when
u
is
a
cop
y
of
the
edge
u
0
.
It
is
readily
seen
that
the
only
edges
of
N
without
a
cop
y
in
N
0
are:
(i
)
the
con
text-
b
o
dy
edge
connecting
the
con
text
no
de
of
the
redex
(the
one
ab
o
v
e
the
@-o
ccurrence)
to
the
b
o
dy
no
de
(the
one
b
elo
w
the
-o
ccurrence);
(ii
)
the
binding-argumen
t
edges
connecting
an
o
ccurrence
of
the
v
ariable
of
the
redex
to
the
argumen
t
no
de
(the
one
at
the
argumen
t
p
ort
of
the
@-o
ccurrence)
.
Besides,
an
y
new
con
text-b
o
dy
edge
can
b
e
seen
as
the
merging
of
a
con
text
edge
and
of
a
b
o
dy
edge,
while
an
y
binding-
argumen
t
edge
can
b
e
seen
as
the
merging
of
a
binding
edge
(one
of
the
edges
connected
to
the
binding
p
ort
of
the
redex)
and
of
an
argumen
t
edge.
According
to
this
remark,
let
u
cb
b
e
a
con
text-b
o
dy
edge
origi-
nated
reducing
a
-redex
edge
u
whose
corresp
onding
con
text
and
b
o
dy
edges
are
resp
ectiv
ely
u
c
and
u
b
.
The
relation
!
can
b
e
extended
taking
u
c

u

u
b
!
u
cb
.
Similarl
y
,
let
u
va
b
e
a
new
binding-argumen
t
edge.
Also
in
this
case,
w
e
can
extend
the
relation
!
taking
u
v

u

u
a
!
u
va
,
where
u
v
is
the
binding
edge
and
u
a
is
the
argumen
t
edge.
In
b
oth
the
previous
cases,
w
e
ha
v
e
asso
ciated
a
path
to
an
edge
of
the
result
of
the
reduction;
in
particular,
let
us
note
that
the
ancestor
of
a
binding-argumen
t
edge
is
an
expanded
path.
With
this
extension
the
in
v
erse
of
the
relation
!
b
ecomes
a
function
 [
from
the
edges
of
N
to
paths
of
N
0
.
F
urther-
more,
when
N
0

N,
the
previous
relations
induce
a
relation

!
and
a
corresp
onding
map

 [
that
are
just
the
transitiv
e
closure
of
!
and
 [,
resp
ectiv
ely;
these
maps
extend
in
the
natural
w
a
y
to
expanded
access
paths
as
w
ell.
The
relev
an
t
p
oin
t
of
the
last
extension
to
expanded
paths
is
that
there
is
a
straigh
t
corresp
ondence
b
et
w
een
the
access
paths
of
the
result
of
a
reduction
and
the
expanded
access
paths
of
the
initial
syn
tax
tree,
as
pro
v
ed
b
y
the
result
in
the
next
exercise.
Exercise
..
Let

:
N
0

N
b
e
a
reduction
relativ
e
to
a
set
of
redexes
of
N
0
(i.e.,
for
an
y
redex
u
reduced
b
y
,
w
e
ha
v
e
that
u

 [
u
0
,
for
some
redex
u
0
of
N
0
).
Pro
v
e
that
for
an
y
access
path
p
of
N
there
is
a
unique
expanded
access
path
p
0
of
N
0
suc
h
that
p

 [
p
0
.


The
ful
l
algorithm
The
previous
denitions
of
residual
relation
(!)
and
ancestor
map
( [)
apply
immedia
tely
also
to
sharing
graphs.
F
urthermore,
since
in
this
case
a
-reduction
creates
just
one
new
con
text-b
o
dy
edge
and
one
new
binding-argumen
t
edge,
w
e
see
that
the
restriction
of
!
to
the
maxi-
mal
paths
con
taining
con
trol
no
des
only
giv
es
a
function,
or
equiv
alen
tly
,
the
corresp
onding
restriction
of
 [
is
injectiv
e.
Let
us
no
w
go
on
with
the
pro
of,
pro
ceeding
b
y
induction
on
the
length
of
the
deriv
ation
[M]

G.
...
Base
c
ase
The
matc
hing
is
immedia
te:
ev
ery
path
obtained
starting
at
the
ro
ot
and
tra
v
ersing
G
=
[M]
follo
wing
the
natural
orien
tation
of
G
(i.e.,
going
top-do
wn
with
resp
ect
to
the
translation
giv
en
in
Figure
.)
is
prop
er.
F
urthermore,
an
y
of
suc
h
paths
is
isomorphic
to
an
access
path
of
the
syn
tax
tree
of
M.
...
Induction
c
ase
Let
[M]

G
0
u
!
G.
If
u
is
a
rule
in
v
olving
at
least
a
con
trol
no
de,
then
u
do
es
not
aect
the
expression
represen
ted
b
y
the
graph.
Indeed,
the
set
of
expanded
prop
er
paths
connecting
prop
er
no
des
do
es
not
c
hanges
(the
reader
is
in
vited
to
c
hec
k
this
statemen
t).
Therefore,
correctness
follo
ws
b
y
induction
h
yp
othesis.
Th
us,
the
crucial
case
is
-reduction.
Let
us
assume
that
u
is
a
-redex.
If
N
0
is
the
term
represen
ted
b
y
G
0
and
f
0
is
the
one-to-one
corresp
ondence
b
et
w
een
them,
w
e
ha
v
e
to
nd
a
term
N,
with
N
0

N,
suc
h
that
G
and
N
matc
h
through
a
one-
to-one
corresp
ondence
f.
By
induction
h
yp
othesis
w
e
assume
to
kno
w
the
functions
g
0
and
f
0
,
and
the
-term
N
0
corresp
onding
to
G
0
.
W
e
need
to
nd
g,
f
and
N.
(i)
T
o
dene
N,
let
U
=
fu

;



;
u
h
g
b
e
the
-redexes
of
N
0
corre-
sp
onding
to
u.
The
-term
N
is
the
result
of
an
y
dev
elopmen
t
of
U
(for
a
denition
of
dev
elopmen
t
see
section
..).
(ii)
T
o
dene
g
w
e
can
pro
ceed
as
follo
ws:
for
an
y
edge
e
of
N,
let
us
tak
e
the
path
p
of
N
0
suc
h
that
e

 [
p;
then,
let
us
tak
e
the
image
g
0
(p)
of
suc
h
a
path
in
G
0
;
w
e
can
easily
see
that
there
is
a
unique
path
'
of
G
suc
h
that
'
0
!
';
w
e
dene
g(e)
=
'.
It
is
readily
seen
that
this
pro
cedure
asso
ciates
to
eac
h
access
path
p
of
N
an
expanded
prop
er
path
'
0
starting
at
the
ro
ot
of
G
0
and
then
a
path
'
starting
at
the
ro
ot
of
G.
F
urthermore,
let
us
note
that
'
is
obtained
from
'
0
merging
in
to
a
unique
edge
sequences
u
0

u

u
0
0
whose

.
Corr
e
ctness
of
the
algorithm

con
texts
are
alw
a
ys
equal.
W
e
can
th
us
conclude,
b
y
the
prop
er
lab
eling
prop
ert
y
of
expanded
prop
er
paths
(Lemma
..),
that
'
is
a
prop
er
path.
W
e
no
w
ha
v
e
to
pro
v
e
that
an
y
prop
er
path
of
G
is
image
of
an
access
path
of
N.
The
rst
p
oin
t
is
to
sho
w
that
an
y
prop
er
path
'
of
G
is
image
of
exactly
one
expanded
prop
er
path
of
G
0
.
T
o
pro
v
e
this
w
e
can
pro
ceed
b
y
induction
on
the
n
um
b
er
of
binding-argumen
t
edges
con
tained
in
an
y
prop
er
path
'
of
G.
The
base
case
is
direct.
In
fact,
when
'
do
es
not
con
tain
binding-argumen
t
edges,
it
is
readily
seen
that
there
is
a
prop
er
(non-expanded)
path
'
0
of
G
suc
h
that
'
 [
'
0
.
Hence,
let
us
assume
that
'
=
 

e
va

,
where
e
va
is
the
binding-argumen
t
edge
in
tro
duced
b
y
the
reduction
of
u,
and
e
va
 [
e
v

u

e
a
.
Let
 
0

e
v
b
e
the
expanded
path
of
G
0
suc
h
that
 
0
 [
 .
By
the
induction
h
yp
othesis
(the
n
um
b
er
of
binding-argumen
t
edges
of
 
is
less
the
n
um
b
er
of
binding-argumen
t
edges
of
'),
 
0

e
v
is
an
expanded
prop
er
path
from
the
ro
ot
to
the
binding
p
ort
of
u.
Hence,
b
y
the
nesting
prop
ert
y
,
there
is
a
sux

0
of
 
0
(i.e.,
 
0
=

0


0
)
suc
h
that

0

e
v
is
an
expanded
binding
lo
op
connecting
the
b
o
dy
p
ort
of
u
to
its
binding
p
ort.
F
urthermore,
let
us
also
assume
that
the
o
ccurrence
of
e
va
under
analysis
is
the
last
one
con
tained
in
'.
Under
this
additional
assumption,
the
forw
ard
path

0
suc
h
that

 [

0
is
prop
er
(note
that

is
not
expanded)
and,
b
y
the
indep
endence
prop
ert
y
,
w
e
also
see
that

0

e
c

e
a


0
is
an
expanded
prop
er
path.
W
e
conclude
then
that
'
0
=

0

e
c


0

e
a


0
is
an
expanded
prop
er
path
(see
Exercise
..0).
The
next
p
oin
t
is
to
sho
w
that
an
y
expanded
prop
er
path
of
G
0
deter-
mines
a
unique
access
path
of
N.
T
o
do
this,
let
us
note
that,
since
'
is
a
(non-expanded)
prop
er
path,
the
expanded
binding
lo
ops
used
in
the
construction
of
'
0
are
relativ
e
to
the
-no
de
of
u.
As
a
consequence,
the
residual
p
of
the
expanded
access
path
p
0
of
N
0
suc
h
that
g(p
0
)
=
'
0
is
an
access
path
of
N.
(The
detailed
pro
of
of
the
last
assertion
is
left
to
the
reader.
T
o
this
purp
ose
w
e
also
suggest
to
see
Exercise
..).
Hence,
b
y
construction,
w
e
ha
v
e
that
f(')
=
p.
Exercise
..
(i)
Dene
a
pro
cedure
whic
h
tak
es
a
set
of
access
paths
and
giv
es
the
syn
tax
tree
of
a
-expression.
(ii)
Dene
a
pro
cedure
(the
read-bac
k)
whic
h
tak
es
a
sharing
graph
G
and
giv
es
the
syn
tax
tree
of
the
term
asso
ciated
to
G.
(Hint:
Dene
a
pro
cedure
whic
h
giv
es
the
set
S
of
prop
er
paths
of
G
whic
h
start
at
the
ro
ot
and
terminate
at
prop
er
no
des.
Then,


The
ful
l
algorithm
dene
a
pro
cedure
whic
h
tak
es
S
and
giv
es
the
corresp
onding
set
of
access
paths.
Finally
,
use
the
pro
cedure
in
the
previous
item.)
Remark
..
Theorem
..
migh
t
b
e
stated
in
a
stronger
form,
in
order
to
ensure
that
when
[M]

G
and
G
is
in
normal
form
(there
is
no
in
teraction),
the
syn
tax
tree
matc
hing
with
G
is
in
normal
form
to
o.
T
o
this
aim
one
has
to
pro
v
e
that
the
follo
wing
t
w
o
graph
segmen
ts
nev
er
app
ear:
(i)
An
m-indexed
con
trol
no
de
in
fron
t
of
the
principal
p
ort
of
an
n-indexed
prop
er
no
de
and
m

n.
F
or
instance:
@
λ 1
1
2
(ii)
Tw
o
prop
er
no
des
of
dieren
t
index
whic
h
in
teract,
as
in:
@1
λ 2
Remark
that
the
t
w
o
paths
connecting
the
no
des
@
and

in
the
ab
o
v
e
pictures
are
b
oth
prop
er.
Exercise
..
Referring
to
the
previous
remark:
(i)
Pro
v
e
that
graph
segmen
ts
as
in
the
rst
item
nev
er
app
ear.
(Hint:
Use
the
prop
ert
y
of
indep
endence.)
(ii)
(Dicult
)
Pro
v
e
that
graph
segmen
ts
as
in
the
second
item
nev
er
app
ear.
(Hint:
Dene
a
function
`
whic
h
tak
es
a
prop
er
path
tra
v
ersing
con
trol
no
des
only
and
giv
es
the
\lev
el
c
hange"
p
er-
formed
b
y
the
path.
That
is,
the
tra
v
ersal
of
a
croissan
t
from
the
auxiliary
p
ort
to
the
principal
p
ort
increases
the
lev
el
b
y
;
the
tra
v
ersal
of
a
brac
k
et
from
the
auxiliary
p
ort
to
the
principal
p
ort
decreases
the
lev
el
b
y
,
etc.
Hence,
pro
v
e
that
if
'
connects

.
Corr
e
ctness
of
the
algorithm
	
the
function
p
ort
of
an
n-indexed
@-no
de
and
the
con
text
of
an
m-indexed
-no
de,
then
n
+
`(')
=
m.)
..
Pr
o
of
of
L
emma
..
(pr
op
erties
of
exp
ande
d
pr
op
er
p
aths)
All
the
pro
ofs
but
the
one
of
nesting
are
b
y
induction
on
the
denition
of
expanded
prop
er
path.
The
base
case
holds
b
y
h
yp
othesis.
So,
let
'
=


u



u

 
b
e
a
decomp
osition
of
the
expanded
prop
er
path
'.
That
is,
u
is
a
-redex,


u


and


 
are
expanded
prop
er
paths,
and

is
a
binding
lo
op.
The
prop
erties
are
pro
v
ed
in
order.
...
Indep
endenc
e
First
of
all
let
us
see
ho
w
to
build
a
prop
er
con
text
lab
eling
of
'
for
an
y
initial
con
text.
By
induction
h
yp
othesis
indep
endence
holds
for
b
oth


u


and


 ;
in
particular,
this
also
means
that
they
ha
v
e
a
prop
er
lab
eling
for
an
y
initial
con
text.
Let
us
c
ho
ose
the
same
initial
con
text
for
the
t
w
o
paths.
It
is
immediate
that
in
b
oth
the
paths
the
con
texts
of
the
edges
in

coincide.
By
denition
of
binding
lo
op,
if
D
is
the
nal
con
text
of

and
r
is
the
index
of
the
no
des
in
the
redex
u,
the
nal
con
text
of

in
the
previous
path
is
equal
to
D
r
[E],
for
some
con
text
E.
By
induction
h
yp
othesis,
there
is
a
prop
er
con
text
lab
eling
for


 
in
whic
h
the
con
text
at
width
r
in
D
is
replaced
b
y
an
arbitrary
con
text;
in
particular,
it
means
that
there
is
lab
eling
yielding
G
=
D
r
[E]
to
the
initial
edge
of
 .
W
e
can
then
use
this
lab
eling
to
app
end
 
to


u


through
u.
The
previous
construction
pro
v
es
at
the
same
time
the
existence
of
a
prop
er
assignmen
t
for
an
y
X
replacing
the
con
text
at
width
b
m
of
v,
when
v
is
in


u


or
in
 
(apply
induction
h
yp
othesis
to
the
subpath
in
whic
h
v
is
and
tak
e
the
corresp
onding
initial
con
text
for
).
F
or
the
case
in
whic
h
v
=
u
instead,
it
suces
to
note
that
the
con
text
of
u
is
alw
a
ys
the
same
of
the
rst
edge
of
 ,
whic
h
starts
at
the
argumen
t
edge
of
the
@
no
de
in
the
redex
(i.e.,
r
=
n
and
b
n
=
r
+
).
In
the
case
in
whic
h
v
is
in
 ,
the
rest
of
the
pro
of
follo
ws
immedia
tely
b
y
induction
h
yp
othesis.
Th
us,
let
us
assume
that
v
is
in


u

.
Let
E
=
hF
;
ai.
By
the
initial
construction
and
b
y
induction
h
yp
othe-
sis,
w
e
ha
v
e
that
A
=
A
e
m
[F],
for
some
e
m

m;
and
at
the
same
time,
taking
B
=
B
b
n
[C],
there
is
k

0
for
whic
h
F
=
F
k
[C]
(i.e.,
since
the
st
edge
of
 
is
an
argumen
t
edge,
G
=
D
r
[hF
k
[C];
ai]
=
G
b
r
[C],
for
some

0
The
ful
l
algorithm
b
r
=
r
+
k
>
r).
Summi
ng
up,
the
last
con
text
of
'
is
B
b
n
[C]
while
the
con
text
of
v
is
A
=
A
e
m
[F]
=
A
e
m
[F
k
[C]]
=
A
b
m
[C],
with
b
m
=
e
m
+
k

m.
The
other
prop
erties
follo
ws
then
b
y
insp
ection
of
the
latter
construc-
tion.
In
particular,
replacing
Y
for
C,
w
e
ha
v
e
D
r
[hF
k
[Y
];
ai]
at
the
b
eginning
of
 ;
but,
b
y
induction
h
yp
othesis,
F
=
F
k
[C]
can
b
e
sim
ulta-
neously
replaced
b
y
an
y
con
text
in
b
oth
G
=
D
r
[hF
;
ai]
and
A
=
A
e
m
[F];
th
us,
putting
F
k
[Y
]
for
F,
w
e
conclude.
...
Nesting
The
pro
of
is
b
y
con
tradiction.
Without
loss
of
generalit
y
,
w
e
can
tak
e
'
=


u



u,
where
u
is
the
con
text
edge
u
of
some
prop
er
no
de
and

is
not
empt
y
(i.e.,
the
t
w
o
o
ccurrences
of
u
are
distinct);
w
e
can
assume
that
the
con
text
assigned
to
the
t
w
o
o
ccurrences
of
u
is
the
same
and,
moreo
v
er,
that
'
is
the
shortest
path
with
this
prop
ert
y
.
Let

0
and

00
b
e
resp
ectiv
ely
the
p
ostxes
of

and

comp
osed
of
con
trol
no
des
only
.
Since
'
is
the
shortest
path
for
whic
h
nesting
do
es
not
hold,
w
e
see
that

0
and

00
m
ust
dier;
moreo
v
er,
the
only
p
ossibilit
y
is
that
after
a
common
p
ostx
these
paths
con
tain
a
fan-in
that

0
crosses
en
tering
through
the
-p
ort
and

00
passing
through
the
-p
ort.
Summarizing,
w
e
ha
v
e
t
w
o
prop
er
paths

0

u
=

0



u
and

00

u
=

00



u
suc
h
that:
(i)
the
prop
er
paths

0



u
and

00



u
cross
con
trol
no
des
only
and
end
at
the
con
text
p
ort
of
an
n-indexed
prop
er
no
de;
(ii)

0
and

00
start
at
the
p
orts
of
some
prop
er
no
des
(note
that
they
migh
t
also
b
e
the
same
p
ort
of
the
same
prop
er
no
de);
(iii)

0
and

00
end
at
distinct
auxiliary
p
orts
of
the
same
fan-in,
sa
y
that
they
reac
h
the

and
the
-p
ort,
resp
ectiv
ely
.
Let
A

;
B

and
A

;
B

b
e
the
initial
and
nal
con
texts
of
the
prop
er
paths

0

u

u
and

00

u,
resp
ectiv
ely
.
By
con
tradiction
of
nesting,
there
is
some
con
text
assignmen
t
suc
h
that
B
n

[

]
=
B
n

[

].
A
t
the
same
time,
the
shap
e
of

0
and

00
implies
that
B

=
B

for
an
y
con
text
assignmen
t.
But,
see
Exercise
..,
this
con
tradict
indep
endence
(note
that
to
pro
v
e
indep
endence
w
e
did
not
use
nesting).
...
T
r
ansp
ar
ency
By
induction
h
yp
othesis,
there
is
an
expanded
binding
lo
op

suc
h
that


 
=


w

.
W
e
can
then
see
that
this
induces
a
decomp
osition
of
'
suc
h
that
'
=

0

w


0
,
where

b
elong
to

0
or
to

0
according
to
the
p
osition
of
w
with
resp
ect
to
.

.
Corr
e
ctness
of
the
algorithm

..
Pr
o
of
of
the
sharing
gr
aph
pr
op
erties
By
induction
on
the
length
of
the
deriv
ation
ending
with
the
sharing
graph
G.
...
Induction
c
ase:
[M]

G
0
u
!
G
Let
u
b
e
a
rule
in
v
olving
a
con
trol
no
de.
W
e
in
vite
the
reader
to
c
hec
k
case-b
y-case
that
these
rules
do
not
in
v
alidate
the
prop
erties.
When
u
is
a
-reduction,
w
e
ha
v
e
already
seen
in
the
pro
of
of
The-
orem
..
that
eac
h
prop
er
path
'
of
G
starting
at
the
ro
ot
is
the
residual
of
an
expanded
prop
er
path
'
0
of
G
0
.
F
urthermore,
since
'
is
obtained
from
'
0
replacing
an
y
triple
u
0

u

u
00
with
a
single
edge.
It
is
readily
seen
that
'
has
the
indep
endence,
nesting
and
transparency
prop
erties
if
and
only
if
'
0
has
suc
h
prop
erties.
W
e
conclude
th
us
b
y
induction
h
yp
othesis.
...
Base
c
ase:
G
=
[M]
The
con
trol
no
des
of
G
are
all
in
the
paths
connecting
the
binding
p
orts
of
-no
des
to
the
nearest
prop
er
no
de.
Because
of
this
it
is
immediate
to
see
that
all
the
prop
er
path
'
ending
at
the
con
text
p
ort
of
a
prop
er
no
de
con
tains
prop
er
no
des
only
.
Hence,
all
the
con
texts
of
'
are
equal.
F
urthermore,
b
y
analysis
of
the
translation
of
Figure
.,
w
e
see
that
the
lev
els
of
an
y
no
de
of
'
is
greater
or
equal
than
the
lev
el
m
of
the
initial
no
de,
and
that
when
'
starts
from
an
argumen
t
p
ort
they
are
indeed
greater
than
m.
These
observ
ations
suce
to
pro
v
e
indep
endence.
Nesting
prop
ert
y
is
v
oid.
In
fact,
in
G
w
e
cannot
ha
v
e
a
prop
er
path
reac
hing
t
wice
the
con
text
p
ort
of
the
same
prop
er
no
de.
The
pro
of
of
transparency
is
b
y
induction
on
the
denition
of
the
translation
[

].
W
e
lea
v
e
it
to
the
reader,
see
Exercise
...
Exercise
..
Let

b
e
the
bac
kw
ard
path
connecting
a
binding
p
ort
to
a
croissan
t
of
[M]
(note
that

crosses
con
trol
no
des
only).
The
oset
p
of

(b
eing

the
forw
ard
path
obtained
rev
ersing
)
is
the
n
um
b
er
of
square
brac
k
ets
con
tained
in
.
Let

=
 


b
e
a
lo
op
of
[M].
Pro
v
e
that

is
a
binding
lo
op
and
that
if
A
and
B
are
resp
ectiv
ely
the
initial
and
nal
con
texts
of
,
then
B
=

A
n
[hC;
h


hc
p

;
c
p-

a
p-
i;



;
c
0

a
0
ii]
when
p
>
0
A
n
[hC;
i]
when
p
=
0
where:
(i
)
a
i
=
A(n
+
i)
and
(ii
)
c
i
is
a
(p
ossibly
empt
y)
string
of

and
?,
for
i
=
0;
:
:
:
;
p
-
;
(iii
)
A
=
A
n+p
[C].


Optimal
Reductions
and
Linear
Logic
There
exists
a
deep
relation
b
et
w
een
Lamping's
optimal
graph
reduction
tec
hnique
and
Girard's
Linear
Logic.
Although
this
relation
b
ecomes
re-
ally
in
triguing
only
considering
the
notion
of
path,
and
the
so-called
ge-
ometry
of
in
teraction
for
Linear
Logic,
w
e
an
ticipate
in
this
c
hapter
the
main
ideas
b
ehind
this
corresp
ondence,
for
w
e
b
eliev
e
it
could
pro
vide
some
more
op
erational
in
tuition
on
Lamping's
Algorithm.
Besides,
the
existence
of
a
connection
b
et
w
een
Lamping's
tec
hnique
and
Linear
Logic
is
not
as
surprising
as
it
migh
t
app
ear
at
a
rst
glance.
In
fact,
Lamping's
algorithm
pro
vides
a
sophisticated
w
a
y
for
handling
sharing
in
lam
b
da
terms.
This
requires
a
deep
in
v
estigation
of
the
op
eration
of
duplication
(or
con
traction,
in
logical
terms),
and
a
clean
approac
h
to
the
notion
of
sharable
en
tit
y
,
whic
h
are
also
the
main
topics
of
Linear
Logic:
du-
plication
(con
traction)
is
generally
a
v
oided
unless
on
sp
ecial
\sharable"
ob
jects
equipp
ed
b
y
a
suitable
mo
dalit
y
\!"
(read
\of
course").
Suc
h
a
mo
dalit
y
pro
vides
a
subtle
to
ol
for
in
v
estigating
the
sharable
nature
of
ob
jects:
!!(A)
is
b
y
no
means
isomorphic
to
!(A).
Th
us,
w
e
immedia
tely
ha
v
e
a
stratied
univ
erse
that
is
the
logical
coun
terpart
of
Lamping's
lev-
els.
In
particular,
the
croissan
t
and
the
brac
k
et
of
Lamping
are
naturally
and
resp
ectiv
ely
asso
ciated
with
the
t
w
o
op
erations

:
!(A)
!
A
and

:
!(A)
!
!!(A)
of
the
comonad
\!"
of
Linear
Logic.
According
to
suc
h
a
corresp
ondence
,
the
optimal
rewriting
rules
can
then
b
e
understo
o
d
as
a
\lo
cal
implem
en
tation"
of
naturalit
y
la
ws,
that
is
as
the
broadcasting
of
some
information
from
the
output
to
the
inputs
of
a
term,
follo
wing
its
connected
structure.
In
order
to
get
optimal
reductions,
w
e
just
ha
v
e
to
pursue
this
propagation
of
natural
transformations
as
far
as
it
is
re-
quired
to
put
in
evidence
new
redexes.
This
can
b
e
simply
ac
hiev
ed
b
y
k
eeping
a
subset
of
the
full
broadcasting
system.
The
other
rules
still
pla
y
a
cen
tral
role
in
the
read-bac
k
phase.


.
Intuitionistic
Line
ar
L
o
gic

.
In
tuiti
oni
st
ic
Linear
Logic
In
this
section
w
e
shall
rapidly
surv
ey
the
main
notions
of
In
tuitionistic
(Implicativ
e)
Linear
Logic.
F
or
the
momen
t,
w
e
shall
merely
in
tro
duce
the
\truly"
linear
part
of
the
logic,
p
ostp
oning
the
discussion
of
the
\of
course"
mo
dalit
y
to
section
..
In
tuitionistic
Linear
Logic
is
the
logical
system
dened
b
y
the
follo
w-
ing
rules:
(Exchange
)
 ;
x
:
A;
y
:
B;

`
M
:
C
 ;
y
:
B;
x
:
A;

`
M
:
C
(Axiom
)
x
:
A
`
x
:
A
(Cut
)
 `
M
:
A
;
x
:
A
`
N
:
B
 ;

`
N[
M
=
x
]
:
B
((;
l)
 `
M
:
A
x
:
B;

`
N
:
C
 ;
y
:
A
(
B;

`
N[
(y
M)
=
x
]
:
C
((;
r)
 ;
x
:
A
`
M
:
B
 `
x:M
:
A
(
B
It
is
readily
seen
that
this
fragmen
t
of
Linear
Logic
corresp
onds
with
linear
-calculus
y
,
via
the
Curry-Ho
w
ard
analogy
(see
also
Exercise
..).
Linear
Logic
pro
ofs
can
b
e
nicely
represen
ted
b
y
means
of
Pr
o
of
Nets
[Gir
,
Dan	0
].
Pro
of
Nets
pro
vide
a
graphical
represen
tation
that
elim-
inates
most
of
the
syn
tactical
bureaucracy
due
to
the
arbitrary
sequen-
tialization
of
inference
rules
in
a
linear
or
tree-lik
e
represen
tation
of
pro
ofs.
In
a
sense,
they
are
an
\abstract
syn
tax"
for
pro
ofs,
compared
with
the
\concrete
syn
tax"
of
usual
represen
tations.
Ax
-
+
Cut
Fig.
..
Pro
of
Net
links.
Pro
of
Net
links
are
depicted
in
Figure
..
A
pro
of
of
a
sequen
t
A

;
:
:
:
;
A
n
`
B
is
represen
ted
as
a
net
with
n
+

distinguished
no
des,
called
\conclusions":
n
negativ
e
conclusions
for
the
h
yp
othesis
A

;
:
:
:
;
A
n
,
and
one
p
ositiv
e
conclusion
for
B.
Denition
..
(pro
of
net)
Pro
of
Nets
are
inductiv
ely
dened
as
follo
ws:
y
A
-term
is
linear
when
it
con
tains
exactly
one
o
ccurrence
of
eac
h
v
ariable
o
ccur-
ring
free
in
it,
and
an
y
of
its
subterms
is
linear.
In
linear
-calculus
all
the
terms
are
linear.


Optimal
R
e
ductions
and
Line
ar
L
o
gic

Ev
ery
axiom
link
is
a
pro
of
net.
Both
the
no
des
are
c
onclusions
of
the
pro
of
net.
A
B
N
...
A
B
+
+
-
+
Fig.
..
P
ositiv
e
linear
implication
.

Let
N
b
e
a
pro
of
net.
If
A
is
a
negativ
e
conclusion
and
B
is
the
p
ositiv
e
conclusions
of
N,
then
the
net
in
Figure
.
is
a
pro
of
net.
All
conclusions
of
N
but
A
and
B
are
negativ
e
conclusions
of
the
new
pro
of
net.
A
(
B
is
the
new
p
ositiv
e
conclusion.
...
...
A
B
N’
N"
A
B
+
-
-
-
Fig.
..
Negativ
e
linear
implicatio
n.

Let
N
0
and
N
00
b
e
pro
of
nets.
If
A
is
the
p
ositiv
e
conclusion
of
N
and
B
is
a
negativ
e
conclusion
of
N
00
,
then
the
net
in
Figure
.
is
a
pro
of
net.
All
conclusions
of
N
0
and
N
00
but
A
and
B
are
conclusions
of
the
new
pro
of
net.
A
(
B
is
a
new
negativ
e
conclusion.
The
unique
p
ositiv
e
conclusion
is
the
p
ositiv
e
conclusion
of
N
00
.

Let
N
0
and
N
00
b
e
pro
of
nets.
If
A
is
the
p
ositiv
e
conclusion
of
N
0
and
A
is
a
negativ
e
conclusion
of
N
0
,
then
the
net
in
Figure
.
is
a
pro
of
net.
All
conclusions
of
N
0
and
N
00
but
A
and
B
are
conclusions
of
the
new
pro
of
net.
The
unique
p
ositiv
e
conclusion
is
the
p
ositiv
e
conclusion
of
N
00
.
The
cut-elimination
rules
are
giv
en
in
Figure
..

.
Intuitionistic
Line
ar
L
o
gic

...
...
N’
N"
A+
-
A
Cut
Fig.
..
Cut.
+
Cut
-
Cut
a
b
c
d
a
b
c
d
Ax
Cut
Cut
Cut
a
b
a
b
Ax
a
b
a
b
Fig.
..
Pro
of
Net
cut-elimination.
By
the
Curry-Ho
w
ard
corresp
ondence,
w
e
can
use
Pro
of
Nets
to
repre-
sen
t
linear
-terms.
In
particular,
a
linear
-term
M
with
free
v
ariables
x

;
:
:
:
;
x
n
is
translated
in
a
pro
of
net
M

with
n
+

conclusions:
the
n
negativ
e
conclusions
corresp
ond
to
the
free
v
ariables
of
M;
the
unique
p
ositiv
e
conclusion
is
the
\ro
ot"
of
the
term.
Example
..
The
-term
x:
y:
((z:
z
x)
y)
is
represen
ted
b
y
the
pro
of
net
of
Figure
.
The
reader
should
not
b
e
scared
b
y
the
net
of
Figure
..
Rearrang-
ing
the
graph
according
to
a
dieren
t
top
ological
setting,
it
is
easy
to
recognize
the
usual
abstract
syn
tax
tree
(see
Figure
.).
A
simple
pro
cedure
for
transforming
an
abstract
syn
tax
tree
of
a
-
term
in
to
a
pro
of
net
is
the
follo
wing:


Optimal
R
e
ductions
and
Line
ar
L
o
gic
-
Ax
Ax
-
Ax
Ax
+
Cut
+
+
Fig.
..
The
pro
of
net
of
x:
y:
((z:
z
x)
y).
+
+
-
-
Ax
Ax
+
Ax
Cut
Ax
Fig.
..
Rearranging
the
pro
of
net
of
x:
y:
((z:
z
x)
y).
(i)
Change
eac
h
application
no
de
in
a
(
-
no
de,
and
eac
h

no
de
in
a
(
+
no
de;
(ii)
F
or
ev
ery
v
ariable
x
add
an
axiom
link
leading
to
a
new
no
de
x
?
.
(iii)
If
a
v
ariable
x
is
b
ound,
add
a
link
from
x
?
to
the
no
de
corre-
sp
onding
to
its
-binder.

.
The
\!"
mo
dality

(iv)
Giv
en
an
application
(M
N),
add
an
axiom
link
b
efore
the
appli-
cation
and
a
cut
link
b
et
w
een
M
and
the
application.
(v)
Remo
v
e
all
cut-axiom
pairs
in
tro
duced
b
y
this
pro
cedure
(t
ypi-
cally
,
in
applicativ
e
c
hains
of
the
kind
(M
N

:
:
:
N
k
)).
Cut
and
axioms
links
are
a
sort
of
iden
tit
y
connections
whose
purp
ose
is
to
preserv
e
the
orien
tation
of
the
net|in
all
the
previous
dra
wings
of
pro
of
nets
but
Figure
.
the
edges
should
b
e
in
tended
orien
ted
top-
do
wn.
Hence,
it
is
readily
seen
that
cut
and
axioms
links
are
not
really
necessary:
they
can
b
e
safely
replaced
b
y
wires
once
w
e
assume
that
the
edges
are
not
orien
ted.
Ev
en
in
this
linear
setting,
w
e
already
ha
v
e
some
imp
ortan
t
relations
b
et
w
een
pro
of
nets
and
sharing
graphs.
Namely:
(i)
The
explicit
connection
b
et
w
een
b
ound
v
ariables
and
their
re-
sp
ectiv
e
binders;
(ii)
The
cut-elimination
rule
for
(,
that
is
exactly
equiv
alen
t
to
the
-reduction
rule
of
sharing
graphs.
.
The
\!"
mo
dalit
y
In
order
to
exit
from
the
linear
framew
ork,
and
to
reco
v
er
the
full
p
o
w
er
of
in
tuitionistic
logical
systems,
Linear
Logic
is
equipp
ed
b
y
a
suitable
mo
dalit
y
\!"
(read
of
c
ourse).
The
mo
dalit
y
applies
to
form
ulae,
ex-
pressing
their
non
linear
nature.
So,
a
form
ula
of
the
kind
!(A)
can
b
e
freely
duplicated
and
erased.
F
rom
the
logical
p
oin
t
of
view,
this
means
that
w
e
allo
w
con
traction
and
w
eak
ening
on
these
form
ulae:
(Contr
action
)
x
:
!(A);
y
:
!(A);
 `
M
:
B
z
:
!(A);
 `
M[
z
=
x
;
z
=
y
]
:
B
(We
akening
)
 `
M
:
B
x
:
!(A);
 `
M
:
B
The
mo
dalit
y
\!"
can
b
e
in
tro
duced
on
the
left-hand
side
of
a
sequen
t
b
y
the
follo
wing
dereliction
rule:
()
x
:
A;
 `
M
:
B
x
:
!(A);
 `
M
:
B
F
or
in
tro
ducing
\!"
on
the
righ
t,
w
e
m
ust
ensure
that
all
the
h
yp
othe-
ses
on
the
left-hand
side
of
the
sequen
t
ha
v
e
b
een
previously
derelicted


Optimal
R
e
ductions
and
Line
ar
L
o
gic
(if
 =
A

;
:
:
:
;
A
n
,
w
e
shall
write
! for
!(A

);
:
:
:
;
!(A
n
)):
(!;
r)
! `
M
:
B
! `
M
:
!B
In
tuitionistic
Logic
is
fully
reco
v
ered
via
the
isomorphism
A
!
B
=
!(A)
(
B.
Exercise
..
The
follo
wing
inference
rules
plus
Exc
hange,
Axiom
and
Cut
dene
the
implicativ
e
fragmen
t
of
in
tuitionistic
logic
(IL):
(!;
l)
 `
M
:
A
x
:
B;

`
N
:
C
 ;
y
:
A
!
B;

`
N[
(y
M)
=
x
]
:
C
(!;
r)
 ;
x
:
A
`
M
:
B
 `
x:M
:
A
!
B
(Contr
action
)
x
:
A;
y
:
A;
 `
M
:
B
z
:
A;
 `
M[
z
=
x
;
z
=
y
]
:
B
(We
akening
)
 `
M
:
B
x
:
A;
 `
M
:
B
(i)
Exploiting
the
translation
A
!
B
=
!(A)
(
B,
pro
v
e
that
for
an
y
IL
pro
of
there
is
a
corresp
onding
Linear
Logic
pro
of
ending
with
the
corresp
onding
sequen
t.
(ii)
Find
another
translation
of
IL
in
to
Linear
Logic.
(Hint:
What
w
ould
happ
en
if
ev
ery
form
ula
w
ould
b
e
prexed
b
y
an
\!"
mo
dal-
it
y?)
In
order
to
ha
v
e
a
b
etter
corresp
ondence
b
et
w
een
sharing
graphs
and
linear
logic,
it
is
con
v
enien
t
to
split
(!;
r)
in
t
w
o
more
elemen
tary
steps:
(!)
 `
M
:
B
! `
M
:
!(B)
()
x
:
!(!(A));
 `
M
:
B
x
:
!(A);
 `
M
:
B
The
t
w
o
form
ulations
of
the
\!"
mo
dalit
y
w
e
ha
v
e
giv
en
are
equiv
alen
t.
In
fact,
it
is
immediate
that
(!)
and
()
imply
(!;
r),
and
that
(!;
r)
imply
(!)
(note
that
to
pro
v
e
the
latter
implication
w
e
also
use
()).
Hence,
the
only
think
w
e
ha
v
e
left
to
pro
v
e
is
that
(!;
r)
implies
().
F
or
this
purp
ose,
let
us
note
that
!(A)
`
!(!(A))
is
pro
v
able
in
the
rst
form
ulation;
then,
b
y
a
cut
(whic
h
can
b
e
ev
en
tually
eliminated),
w
e
ha
v
e:
!(A)
`
!(!(A))
!(!(A));
 `
B
!(A);
 `
B

.
The
\!"
mo
dality
	
..
Boxes
The
pro
of
net
notation
for
con
traction,
w
eak
ening,
()
and
()
is
straigh
t-
forw
ard:
w
e
just
in
tro
duce
four
new
links
of
arit
y
three,
one,
t
w
o,
and
t
w
o,
resp
ectiv
ely
(see
Figure
.).
As
w
e
shall
see,
these
links
ha
v
e
some
clear
op
erational
analogies
with
the
corresp
onding
sharing
graphs
op
erators.
*
Fig.
..
Sharing
graph
no
des
for
con
traction,
w
eak
ening,
()
and
().
Less
ob
vious
is
the
pro
of
net
notation
for
(!);
Girard's
solution
w
as
that
of
using
b
oxes.
A
b
o
x
denotes
a
datum
whic
h
has
a
non-linear
use.
In
particular,
data
inside
b
o
xes
ma
y
b
e
duplicated
and
erased.
The
role
of
the
b
o
x
is
merely
to
stress
the
c
haracter
of
glob
al
entity
of
the
data
it
con
tains.
No
direct
in
teraction
b
et
w
een
the
external
and
the
in
ternal
w
orld
of
a
b
o
x
is
allo
w
ed.
W
e
can
duplicate
a
b
o
x,
erase
it,
op
en
it,
build
a
new
b
o
x
around
another
one,
or
merge
t
w
o
b
o
xes
together.
All
these
op
erations
are
describ
ed
b
y
the
rewriting
rules
of
Figure
.	.
A
more
suggestiv
e
solution
for
represen
ting
b
o
xes
is
that
of
using
dieren
t
lev
els,
in
a
three
dimensional
space.
In
this
case,
\building
a
b
o
x"
around
a
pro
of
net
N
(i.e.,
applying
the
(!)
rule),
means
to
shift
N
at
a
higher
lev
el
(in
practice,
w
e
can
use
in
tegers
to
denote
the
lev
el
of
links,
as
in
sharing
graphs)
In
Figure
.0
y
ou
will
nd
the
cut
elimination
rules
for
b
o
xes,
rephrased
in
the
\three
dimensional"
approac
h.
W
e
also
remo
v
ed
the
(inessen
tial)
cut-link,
and
adopted
the
con
v
en
tion
of
writing
the
unique
p
ositiv
e
con-
clusion
of
the
b
o
x
at
its
top.
Note
that
the
last
rule
of
Figure
.	
can
no
w
b
e
omitted
(t
w
o
regions
at
the
same
lev
el
can
b
e
seen
as
a
unique
region).
The
relation
with
sharing
graphs
should
b
e
no
w
clear:
in
b
oth
cases,
the
eect
of
croissan
ts
and
brac
k
ets
is
just
that
of
shifting
links
at
a
lo
w
er
or
higher
lev
el.
The
only
dierence
is
that
this
op
eration
is
considered
as
a
unique
global
mo
v
e
(i.e.
o
v
er
a
b
o
x)
in
the
cut-elimination
pro-
cess,
while
it
has
b
een
decomp
osed
in
more
atomic
steps
in
the
optimal
implemen
tation
(w
e
shall
come
bac
k
to
this
p
oin
t
in
the
next
section).
The
analogy
b
et
w
een
pro
of
nets
of
Linear
Logic
and
sharing
graphs
is
particularly
striking
when
considering
the
pro
of-net
enco
ding
of
-

	0
Optimal
R
e
ductions
and
Line
ar
L
o
gic
Cut
+
-
-
...
Cut
+
-
-
...
...
*
*
Cut
+
-
...
-
+
-
...
-
Cut
Cut
+
-
...
-
Cut
*
+
-
...
-
Cut
+
-
...
-
Cut
+
-
...
-
+
-
...
-
+
-
...
-
Cut
Cut
+
-
...
-
+
-
...
-
Fig.
.	.
Rewriting
of
b
o
xes.
terms
as
pro
vided
b
y
the
Curry-Ho
w
ard
corresp
ondence.
In
the
\three
dimensional"
approac
h,
this
is
giv
en
b
y
the
rules
in
Figure
..
This
is
exactly
the
same
as
the
enco
ding
of
-terms
in
sharing
graphs
giv
en
in
Figure
..
..
A
R
emark
for
Cate
goricians
The
previous
exp
osition
of
In
tuitionistic
Linear
Logic
is
particularly
close
to
its
categorical
in
terpretation
[BBdPH	].
The
general
ideas
are
the
follo
wing:

.
The
\!"
mo
dality
	
*
-
-
...
+
-
-
-
-
*
*
...
-
-
...
+
-
-
...
+
-
-
...
+
-
-
...
+
-
-
...
+
...
+
...
+
Fig.
.0.
Three
dimensional
in
terpretation
of
b
o
xes.

!
is
a
comonad,
and
it
is
th
us
equipp
ed
with
t
w
o
natural
transforma-
tions

:
!
!
I
(where
I
is
the
iden
tit
y)
and

:
!
!
!!.
Explicitly
,
the
naturalit
y
of

and

is
expressed
b
y
the
follo
wing
equations:
giv
en
an
arro
w
f
:
!(A)
!
!(B)
(i.e.,
a
\pro
of
"
f
inside
a
b
o
x),
w
e
ha
v
e:

A

!(f)
!
f


B

A

!(f)
!
!(!(f))


B

Eac
h
ob
ject
!(A)
is
a
comonoid,
and
it
is
th
us
equipp
ed
with
t
w
o
mor-
phisms
E
A
:
!(A)
!
e,
(where
e
is
the
unit
of
the
monoidal
category)

	
Optimal
R
e
ductions
and
Line
ar
L
o
gic
-
-
-
*
-
[N]
[M]
[(M N)]      =
...
+
...
+
-
+
-
-
-
...
+
[   x.M]       =
λ
[x]        =
Fig.
..
T
ranslation
of
-terms
in
to
\three
dimensional
"
sharing
graphs.
and

A
:
!(A)
!
!(A)

!(A).
Again,
these
morphisms
are
natural:
E
A

!(f)
!
id
e


B

A

!(f)
!
!(f)

!(f)


B

!
b
eha
v
es
as
a
monoidal
m
ulti-functor,
that
is,
w
e
ha
v
e
a
natural
transformation
m
A;B
:
!A

!B
!
!(A

B)
suc
h
that,
giv
en
f
:
A
!
C;
g
:
B
!
D,
then
m
C;D

!f

!g
=
!(f

g)

m
A;B


and

are
monoidal
natural
transformations.
According
to
the
previous
ideas,
the
rule
(!;
r)
has
then
the
follo
wing
in
terpretation:
giv
en
an
arro
w
g
:
!A

!B
!
C,
w
e
get
the
new
arro
w
!(g)

m
!A;!B


A


B
:
!A

!B
!
!C.
The
in
teresting
fact
is
that
the
morphism
m
is
implicit
in
the
pro
of
net
represen
tation,
that
is
essen
tially
justied
b
y
the
follo
wing
equations:

A
B

m
=

A


B
(.)

.
The
duplic
ation
pr
oblem
	

A
B

m
=
!(m)

m


A


B
(.)
E
A
B

m
=
E
A

E
B
(.)

A
B

m
=
m

m




A


B
(.)
where

:
(!A

!A)

(!B

!B)

=
(!A

!B)

(!A

!B)
in
()
is
the
unique
structural
isomorphism.
Equations
()
and
()
follo
ws
from
the
h
yp
otheses
that

and

are
monoidal
natural
transformations,
and
equations
()
and
()
from
the
go
o
d
in
terpla
y
b
et
w
een
the
comonad
(!;
;
)
and
the
comonoids
(!A;
E;
).
The
rewriting
rules
of
Figure
.0
are
just
the
naturalit
y
la
ws
of
;
;

and
E
up
to
the
implicit
morphism
m.
F
or
instance,
giv
en
g
:
!A

!B
!
C
and
the
\b
o
x"
!(g)

m
!A;!B
:
!A

!B
!
!C,
w
e
ha
v
e:

C

!(g)

m
!A;!B
=
!(!(g))


!(!A
!B)

m
!A;!B
=
!(!(g))

!(m)

m


!A


!B
=
!(!(g)

m)

m


!A


!B
Y
ou
will
also
note
that
the
reduction
system
do
es
not
ha
v
e
an
y
coun-
terpart
for
the
three
comonad
equations
of
\!",
namely:

!A


A
=
Id
!A
!(
A
)


A
=
Id
!A
!(
A
)


A
=

!(A)


A
These
rules
are
not
essen
tial
to
pursue
-reduction,
since
w
e
ma
y
alw
a
ys
propagate
the
natural
transformations
in
order
to
put
in
evidence
new
redexes.
Ho
w
ev
er,
these
natural
transformations
will
ev
en
tually
accum
ulate
o
v
er
free
v
ariables.
This
is
actually
a
ma
jor
problem
of
optimal
reduction
to
o:
the
so-
called
dynamical
accum
ulation
of
square
brac
k
ets
and
croissan
ts.
W
e
shall
come
bac
k
in
more
details
to
this
problem
in
Chapter
	.
.
The
duplicati
on
problem
In
the
rules
of
Figure
.0,
the
b
o
x
!(

)
is
considered
as
a
single,
global
en
tit
y
.
In
particular,
the
reduction
of
Figure
.
amoun
ts
to
ph
ysically
duplicate
the
whole
b
o
x.
If
w
e
had
a
-redex
inside
the
b
o
x,
this
w
ould
b
e
ev
en
tually
duplicated,
lo
osing
the
p
ossibilit
y
to
share
its
reduction.
As
w
e
kno
w,
in
order
to
get
optimal
reduction,
w
e
are
forced
to
pro-
ceed
to
this
duplication
in
a
sort
of
\lazy"
w
a
y
.
In
other
w
ords,
the
duplication
op
erator

at
the
output
of
the
b
o
x
m
ust
b
e
propagated

	
Optimal
R
e
ductions
and
Line
ar
L
o
gic
*
-
-
...
+
-
-
-
-
*
*
...
+
...
+
Fig.
..
Duplication
.
to
w
ards
the
inputs
tra
v
elling
inside
the
b
o
x.
Since
the
graph
inside
the
b
o
x
is
a
connected
structure,
the
ob
vious
idea
for
p
erforming
this
prop-
agation
is
that
of
doing
a
\full
broadcasting"
of

along
all
links
in
the
b
o
x;
if
t
w
o
copies
of

meet
eac
h
other
they
annihilates,
otherwise
the
broadcasting
stops
when
the
op
erator
reac
hes
a
link
at
its
o
wn
lev
el.
In
this
w
a
y
,
part
of
the
b
o
x
ma
y
b
e
shared
b
y
dieren
t
terms,
and
w
e
are
forced
to
implemen
t
al
l
the
reduction
rules
of
Figure
.0,
follo
wing
the
same
lo
cal
strategy
as
for
.
a
j
. . .
i
a
. . .
i
i
j-1
*
*
*
a
i
j
. . .
a
a
j
j
i
i
. . .
a
j
. . .
i
a
. . .
i
i
j+1
i < j 
Fig.
..
Broadcasting
rules.
Ev
ery
op
erator
will
act
o
v
er
the
link
l
it
tra
v
erses
according
to
its
seman
tics:
the
duplicator
(fan)
will
duplicate
l,
the
croissan
t
will
decre-
men
t
the
lev
el
of
l,
the
square
brac
k
et
will
incremen
t
it
(and
the
garbage
will
collect
l).
In
tuitiv
ely
,
since
all
op
erators
tra
v
el
in
the
same
direc-
tion
and
according
to
a
same
strategy
,
there
is
no
p
ossible
confusion
in
this
pro
cess.
So,
the
rules
in
Figure
.
are
all
seman
tically
correct,
no
matter
at
whic
h
p
ort
of
a
the
op
erator
of
lo
w
er
index
is
in
teracting

.
The
duplic
ation
pr
oblem
	
to.
A
pro
of
of
the
soundness
of
these
rules
will
b
e
giv
en
in
Chapter
.
Besides,
w
e
already
kno
w
that
in
order
to
ac
hiev
e
optimal
reduction,
it
is
enough
to
limit
the
p
ossibilit
y
of
reduction
to
the
case
of
in
terac-
tion
at
the
princip
al
p
orts
of
the
no
des.
Nev
ertheless,
the
fact
that
all
broadcasting
rules
are
correct,
has
another
imp
ortan
t
consequence:
in
order
to
\read
bac
k"
a
term
obtained
b
y
an
optimal
sharing
reduction,
w
e
could
just
apply
all
the
remaining
broadcasting
rules,
as
w
e
will
see
in
detail
in
Chpater
.


Redex
F
amilies
and
Optimalit
y
In
	,
L

evy
in
tro
duced
the
notion
of
r
e
dex
family
in
the
-calculus
with
the
aim
to
formally
capture
an
intuitive
idea
of
optimal
sharing
b
et
w
een
\copies"
of
a
same
redex.
In
order
to
comfort
his
notion
of
family
,
L

evy
prop
osed
sev
eral
alternativ
e
denitions
inspired
b
y
dieren
t
p
ersp
ectiv
es
and
pro
v
ed
their
equiv
alence.
The
most
abstract
approac
h
to
the
notion
of
family
(see
[L

ev
,
L

ev0])
is
the
so
called
zig-zag
relation.
In
this
case,
duplication
of
redexes
is
formalized
as
residuals
mo
dulo
p
erm
utations.
In
particular,
a
redex
u
with
history

(notation
u)
is
a
c
opy
of
a
redex
v
with
history

i
v

u
(i.e.,
there
exists

suc
h
that

=

up
to
a
notion
of
p
erm
utation
of
redexes,
and
u
is
a
residual
of
v
after
).
The
family
relation
'
is
then
the
symmetric
and
transitiv
e
closure
of
the
cop
y
re-
lation.
No
w,
let
us
dra
w
reduction
arro
ws
do
wn
w
ards.
Pictorially
,
the
family
reduction
giv
es
rise
to
an
alternate
sequence
of
descending
and
ascending
reduction
arro
ws.
This
is
the
reason
wh
y
it
is
also
kno
wn
as
\zig-zag"
relation.
Another
approac
h
is
that
of
considering
the
c
ausal
history
of
redexes.
In
tuitiv
ely
,
t
w
o
redexes
can
b
e
\shared"
if
and
only
if
they
ha
v
e
b
een
\created
in
the
same
w
a
y"
(or,
b
etter,
their
c
auses
are
the
same).
This
is
formalized
b
y
dening
an
extr
action
r
elation
o
v
er
redexes
(with
his-
tory)
u,
whic
h
thro
ws
a
w
a
y
all
the
redexes
in

that
ha
v
e
not
b
een
relev
an
t
for
the
creation
of
u.
The
canonical
form
w
e
obtain
at
the
end
of
this
pro
cess
essen
tially
expresses
the
causal
dep
endencies
of
u
along
the
deriv
ation
(w
e
ma
y
deal
with
causal
chains
instead
of
p
artial
or
ders
since
only
standar
d
derivations
are
considered).
The
most
\op
erational"
approac
h
to
the
family
relation
is
based
on
a
suitable
lab
eled
v
arian
t
of
the
-calculus
[L

ev
].
The
idea
of
lab
els
is
essen
tially
that
of
marking
the
\p
oin
ts
of
con
tact"
created
b
y
reductions.
	

.
Zig-Zag
	
In
particular,
lab
els
gro
w
along
the
reduction,
k
eeping
a
trace
of
its
history
.
Tw
o
redexes
are
in
a
same
family
if
and
only
if
their
lab
els
are
iden
tical.
The
equiv
alence
b
et
w
een
zig-zag
and
extraction
is
not
particularly
problematic
(see
[L

ev0]).
On
the
con
trary
,
the
pro
of
of
the
equiv
alence
b
et
w
een
extraction
(or
zig-zag)
and
lab
eling
is
m
uc
h
more
dicult
(see
for
instance
the
long
pro
of
that
L

evy
ga
v
e
in
its
thesis
[L

ev
]).
F
or
this
reason,
w
e
shall
p
ostp
one
its
pro
of
in
Chapter
,
after
the
in
tro
duction
of
the
so-called
le
gal
p
aths.
In
fact,
giv
en
a
term
T
,
legal
paths
will
giv
e
us
a
complete
c
haracterization
in
terms
of
paths
(virtual
redexes)
in
T
of
the
redexes
generated
along
the
reduction
of
T
.
In
tuitiv
ely
,
a
legal
path
for
a
redex
R
will
b
e
a
suitable
comp
osition
of
subpaths
connecting
those
redexes
required
for
the
creation
of
R.
An
y
legal
path
'
will
corresp
ond
to
a
reduction

comp
osed
of
redexes
in
'
only;
moreo
v
er,
the
redex
with
history
R
will
b
e
in
normal
form
with
resp
ect
to
the
extraction
relation.
The
main
issue
of
section
.
of
Chapter
,
will
b
e
to
pro
v
e
that
the
lab
els
generated
along
the
reduction
of
T
\are"
indeed
legal
paths
in
T
,
and
vice
v
ersa.
.
Zig-Zag
Let

=
x:
(x
x),
F
=
x:
(x
y),
I
=
x:
x.
Consider
the
p
ossible
reduc-
tions
of
M
=
(
(F
I)),
represen
ted
in
Figure
..
In
tuitiv
ely
,
there
are
just
three
kinds
of
redexes
in
this
example:
R,
S
and
T
.
In
the
case
of
R
and
S,
the
common
nature
of
these
redexes
is
clear,
for
all
R
i
and
S
i
are
residuals
of
R
and
S.
The
case
of
T
is
more
complex.
In
fact,
T
,
T

and
T

are
not
residuals
of
an
y
redex
in
M:
they
are
just
created
b
y
the
imm
ediately
previous
reduction.
The
t
w
o
redexes
T

and
T

clearly
lo
ok
sharable
(and
they
are
indeed
\shared"
as
the
unique
redex
T
in
the
innermost
reduction
on
the
left).
Ho
w
ev
er,
the
only
w
a
y
to
establish
some
formal
relation
b
et
w
een
these
redexes
is
b
y
closing
residuals
do
wn
w
ards.
In
fact,
T

and
T
ha
v
e
a
common
residual
T

inside
the
term
((I
y)
(I
y));
similarly
,
T

and
T
ha
v
e
a
common
residual
T

in
the
same
term.
By
transitiv
e
closure,
w
e
can
th
us
conclude
the
\common
nature"
of
T

and
T

:
in
a
sense,
T

is
\the
same"
redex
as
T

,
whic
h
is
the
same
as
T
,
whic
h
in
turn
is
the
same
as
T

whic
h
is
the
same
as
T

.
So,
the
idea
of
\closing
residuals
do
wn
w
ards"
seems
the
righ
t
extension
allo
wing
to
connect
redexes
with
a
common
origin,
but
without
an
y
common
ancestor.
The
formalization
of
the
previous
in
tuition
requires
ho
w
ev
er
some

	
R
e
dex
F
amilies
and
Optimality
S 1
S 2
T 2
R 1
T 1
S 3
S 4
S 5
T 3
T 4
S 6
T 5
T 6
R 2
∆(F I)
(
)
((F I) (F I))
((I y) (F I))
((F I) (I y))
((I y) (I y))
((F I) y)
(y (I y))
((I y) y)
∆
T
R
S
(y (F I))
(y y)
(
)
∆(I y)
y)
(
Fig.
..

=
x:
(x
x);
F
=
x:
(x
y);
I
=
x:
x
care.
In
particular,
let
us
start
noticing
that
T

and
T

should
not
b
e
connected
if
the
initial
expression
w
ould
b
e
((F
I)
(F
I)),
instead
of
M.
The
in
tuitiv
e
reason
is
that,
while
w
e
w
an
t
to
preserv
e
the
shar-
ing
\inheren
t"
in
the
initial
-term,
w
e
are
not
in
terested
in
recognizing
common
sub
expressions
generated
along
the
reduction|the
equiv
alence
of
suc
h
new
sub
expressions
should
b
e
considered
as
a
mere
syn
tactical
coincidence.
F
or
instance,
although
that
reducing
an
y
of
the
t
w
o
redexes
in
(I
(I
x))
w
e
get
the
\same"
term,
the
term
(I
x)
obtained
reducing
the
outermost
redex
and
the
term
(I
x)
obtained
reducing
the
innermost
redex
should
b
e
considered
distinct.
The
reasons
should
b
e
computa-
tionally
clear:
to
lo
ok
for
common
sharable
sub
expressions
w
ould
b
e
to
o
exp
ensiv
e
in
an
y
practical
implemen
tation.
F
urthermore,
ev
en
though
w
e
could
imagine
an
optimization
step
based
on
a
prepro
cessing
rec-

.
Zig-Zag
		
ognizing
common
sub
expressions
in
the
initial
term,
to
run
suc
h
an
optimizing
algorithm
at
run-time
w
ould
b
e
infeasible.
A
main
consequence
of
the
latter
assumption
is
that
the
relation
w
e
are
lo
oking
for
will
not
really
b
e
a
relation
o
v
er
redexes,
it
will
b
e
rather
relativized
with
resp
ect
to
the
reduction
of
some
initial
expression.
In
other
w
ords,
w
e
shall
ha
v
e
to
consider
pairs
comp
osed
of
a
redex
R
to-
gether
with
the
reduction

that
generated
it.
Namely
,
giv
en
a
deriv
ation
T


T
0
R
!
,
w
e
shall
sa
y
that

is
the
history
of
the
redex
R
in
T
0
.
As
a
consequence,
an
y
redex
with
history
R
determines
a
unique
initial
term
T
with
resp
ect
to
whic
h
w
e
are
considering
sharable
redexes,
and
t
w
o
redexes
with
history
will
b
e
comparable
only
when
they
start
at
the
same
initial
term.
Let
us
come
bac
k
to
the
see
ho
w
the
previous
considerations
apply
to
our
previous
examples.
Since
w
e
relativized
redexes
with
resp
ect
to
an
initial
expression
and
w
e
equipp
ed
them
with
an
history
,
redexes
are
no
more
iden
tied
only
b
y
their
syn
tactical
p
osition
in
the
term.
F
or
instance,
the
term
M
=
(I
(I
x))
has
t
w
o
redexes
R
and
S.
By
ring
an
y
of
them
w
e
obtain
the
term
(I
x),
in
whic
h
w
e
ha
v
e
a
unique
redex
T
.
Since
T
is
a
residual
of
b
oth
R
and
S
w
e
could
b
e
tempted
to
conclude
that
R
and
S
are
connected
b
y
our
\sharing"
relation.
On
the
con
trary
,
for
w
e
do
not
w
an
t
to
relate
distinct
redexes
in
the
initial
term,
the
equiv
alence
of
the
result
reducing
R
or
S
is
merely
inciden
tal.
In
fact,
in
tro
ducing
histories,
the
t
w
o
reductions
resp
ectiv
ely
giv
e
RT
and
ST
.
Th
us,
the
t
w
o
redexes
RT
and
ST
could
b
e
related
via
our
sharing
relation,
only
if
their
histories
R
and
S
could
b
e
related
via
suc
h
a
relation.
That
is,
only
if
M
w
ould
b
e
some
partial
result
of
the
computation
of
another
term
N,
and
w
e
could
nd
t
w
o
reductions

and

of
N
suc
h
that
R
and
S
migh
t
b
e
equated
applying
zig-zag
or
the
extraction
relation.
This
is
indeed
the
case
for
the
term
((I
y)
(I
y))
generated
along
the
reduction
in
Figure
..
The
t
w
o
redexes
T

and
T

do
not
ha
v
e
an
y
common
ancestor.
Nev
ertheless,
zig-zag
will
relate
them
(see
Example
..	)
and
the
extraction
relation
will
asso
ciate
to
an
y
T

and
an
y
T

the
same
redex
with
history
ST
(see
Example
..
and
Exercise
..).
..
Permutation
e
quivalenc
e
Before
to
giv
e
the
denition
of
families,
w
e
presen
t
some
standard
results
of
-calculus.
F
or
an
unabridged
presen
tation
of
-calculus
and
for
the
pro
of
of
the
previous
results,
w
e
refer
the
reader
to
Hindley
and
Seldin's
b
o
ok
[HS
],
ev
en
if
the
most
complete
source
for
the
syn
tax
prop
erties

00
R
e
dex
F
amilies
and
Optimality
of
-calculus
is
denitely
Barendregt's
b
o
ok
[Bar
].
Nev
ertheless,
es-
p
ecially
for
readers
without
a
go
o
d
familia
rit
y
of
-calculus,
w
e
suggest
to
start
with
Hindley
and
Seldin.
W
e
also
remark
that
the
pro
ofs
of
the
follo
wing
results
are
actually
subsumed
b
y
the
results
on
the
lab
eled
calculus
that
w
e
will
giv
e
in
section
..
The
rst
notions
w
e
need
are
the
ones
of
r
esidual
of
a
redex
(note
that
in
the
pro
of
of
correctness
w
e
ha
v
e
already
met
this
concept
using
graphs)
and
of
p
ermutation
of
a
reduction.
T
o
in
tro
duce
them,
let
us
recollect
what
w
e
did
learn
b
y
analyzing
the
example
of
(I
(I
y)).
The
relev
an
t
p
oin
t
w
as
that
the
syn
tactical
equiv
alence
of
the
redexes
RT
(T
with
history
R)
and
ST
(T
with
history
S)
is
inciden
tal,
for
the
redex
T
in
(I
y)
is
resp
ectiv
ely
a
residual
of
S
w.r.t.
R
and
a
residual
of
R
w.r.t.
S.
Abstracting
from
the
con
tingen
t
syn
tax
of
-calculus
that
equates
the
result
of
the
t
w
o
reductions
ab
o
v
e,
there
is
clearly
no
reason
to
equate
RT
and
ST
.
The
previous
p
oin
t
is
settled
in
tro
ducing
a
p
erm
utation
op
eration
on
redexes
suc
h
that
t
w
o
reductions
T


T
0
and
T


T
0
are
p
erm
utation
equiv
alen
t
only
when

is
a
suitable
p
erm
utation
of
the
redexes
in
.
By
the
w
a
y
,
in
this
framew
ork
the
w
ord
p
erm
utation
m
ust
b
e
in
terpreted
in
a
wide
sense,
for
the
con
traction
of
a
redex
migh
t
cause
the
duplication
of
another
redex
follo
wing
it;
th
us,
p
erm
uting
a
reduction,
its
length
migh
t
shrink
or
expand.
In
the
previous
example,
since
R
and
S
are
distinct
redexes
of
the
initial
term,
the
corresp
onding
reductions
cannot
b
e
equated
b
y
p
erm
utation.
F
urthermore,
in
suc
h
a
formal
setting
w
e
should
not
use
the
name
T
to
denote
the
redex
of
(I
y);
taking
in
to
accoun
t
that
reducing
R
the
redex
T
is
what
remains
of
the
redex
S,
while
reducing
S
the
redex
T
is
what
remains
of
R,
w
e
should
rather
use
the
names
S=R
(the
residual
of
S
after
R)
and
S=R.
It
is
then
in
tuitiv
e
that
in
order
to
get
t
w
o
equiv
alen
t
reductions,
the
reductions
R
and
S
should
b
e
completed
reducing
S=R
and
R=S,
resp
ectiv
ely
.
Namely
,
while
RS=R
and
SR=S
will
not
b
e
equated
as
redexes
with
history
,
the
t
w
o
reductions
RS=R
and
SR=S
are
ob
viously
equiv
alen
t
b
y
p
erm
utation.
T
o
denote
the
residual
of
a
redex,
let
us
assume
that
w
e
can
mark
some
redexes
of
a
-term
underlining
them
and
asso
ciating
a
name
to
eac
h
underlining.
F
or
instance,
let
us
consider
again
the
term
of
Figure
.
(
(F
I)
S
)
R

.
Zig-Zag
0
w
e
ha
v
e
underlined
the
redexes
R
and
S
of
(
(F
I))
using
the
names
R
and
S
(sa
y
that
the
redexes
are
underlined
b
y
R
and
S,
resp
ectiv
ely).
Let
us
assume
that
-reduction
preserv
es
marking
and
naming.
It
is
in
tuitiv
e
that,
after
a
reduction,
what
is
left
of
a
redex
mark
ed
b
y
a
name
R,
sa
y
its
residual,
is
formed
of
all
the
redexes
of
the
result
with
the
same
marking
R.
Example
..
F
or
instance,
(
(F
I)
S
)
R
R
!
((F
I)
S
(F
I)
S
)
S

!
((I
y)
(F
I)
S
)
S

!
((I
y)
(I
y))
is
a
mark
ed
reduction
tak
en
from
the
example
in
Figure
..
The
previous
example
also
sho
ws
that
when
a
mark
ed
redex
is
red
there
is
no
trace
of
its
underlining
in
the
result,
whic
h
corresp
onds
to
the
fact
that
after
its
con
traction
a
redex
has
no
residual.
Denition
..
(residual)
Let

:
M

N.
Let
us
assume
that
R
is
the
only
redex
of
M
mark
ed
b
y
an
underlining
with
name
R.
The
set
R=
of
the
redexes
of
N
mark
ed
b
y
an
underlining
with
name
R
is
the
r
esidual
of
R
under
.
The
redex
R
is
the
anc
estor
of
an
y
redex
R
0

R=,
while
an
y
of
these
R
0
is
a
r
esidual
r
e
dex
of
R.
The
previous
denition
giv
es
an
example
of
ho
w
to
use
marking.
In
general,
giv
en
a
reduction

:
M

N,
w
e
asso
ciate
to

a
corresp
onding
mark
ed
reduction
assuming
that
eac
h
redex
of
M
is
underlined
using
its
name.
As
a
consequence,
t
w
o
redexes
R
and
S
of
M
will
b
e
alw
a
ys
underlined
using
distinct
names.
Let
us
ho
w
ev
er
remark
that
this
is
not
true
an
ymore
for
the
result
of
a
reduction
(see
the
example
ab
o
v
e).
Let
F
b
e
a
set
of
redexes
of
a
-term
M.
A
reduction

:
M

N
is
r
elative
to
F
when
no
redex
underlined
b
y
a
name
R

F
is
reduced
along
the
mark
ed
reduction
corresp
onding
to
.
F
or
instance,
the
reduction
in
Example
..
is
relativ
e
to
fR;
Sg.
A
reduction

:
M

N
is
a
(complete)
development
of
a
set
of
redexes
F
of
M
when

is
relativ
e
to
F
and,
after
the
mark
ed
reduction
corresp
onding
to
,
N
do
es
not
con
tain
an
y
redex
underlined
b
y
a
name
R

F
.
Theorem
..
(nite
dev
elopmen
t
s)
L
et
F
b
e
a
set
of
r
e
dexes
of
a
-term.
(i)
Ther
e
is
no
innite
r
e
duction
r
elative
to
F
.

0
R
e
dex
F
amilies
and
Optimality
(ii)
A
l
l
developments
end
at
the
same
term.
(iii)
F
or
any
r
e
dex
R
of
M
and
any
p
air
of
developments

and

r
elative
to
F
,
we
have
that
R=
=
R=.
A
rst
consequence
of
the
previous
lemma
is
that
there
is
no
am
biguit
y
in
writing
F
:
M
!
N,
for
w
e
ma
y
assume
that
this
is
a
notation
for
all
the
dev
elopmen
ts
of
F
.
Besides,
w
e
get
in
this
w
a
y
a
parallel
reduction
of
-terms
in
whic
h
a
whole
set
of
redexes
is
sim
ultaneously
reduced
at
eac
h
step.
Th
us,
the
comp
osition
F

F




F
k
denotes
a
sequence
of
parallel
reduction
steps
F
i
:
M
i-
!
M
i
.
In
particular,
as
there
is
no
restriction
on
the
shap
e
of
the
previous
sets,
F
i
migh
t
ev
en
b
e
empt
y;
in
whic
h
case
M
i-i
=
M
i
.
In
spite
of
this,
w
e
stress
that
;
=

(b
eing

the
empt
y
reduction),
then
in
the
equiv
alence
b
y
p
erm
utation
that
w
e
will
later
dene,
w
e
will
ha
v
e
to
explicitly
state
that
the
empt
y
reduction
and
the
reduction
relativ
e
to
an
empt
y
set
of
redexes
are
equiv
alen
t.
The
notion
of
residual
can
b
e
directly
extended
to
parallel
reductions,
i.e.,
R=F
is
the
residual
of
the
redex
R
under
(an
y
dev
elopmen
t
of
)
F
(let
us
note
that
b
y
Theorem
..
suc
h
a
denition
is
not
am
biguous).
F
urthermore,
residuals
can
b
e
also
extended
to
set
of
redexes,
taking
R
0

G
=F
i
R
0

R=F
for
some
R

G
.
Of
particular
relev
ance
is
the
reduction
F
t
G
=
F
(G
=F
),
that
is,
giv
en
t
w
o
sets
of
redexes
F
and
G
of
a
-term,
the
reduction
obtained
reducing
rst
the
set
F
and
then
the
residual
of
G
.
In
terms
of
dev
elopmen
ts,
it
is
not
dicult
to
realize
that,
app
ending
a
dev
elopmen
t

of
G
=F
to
a
dev
elopmen
t

of
F
,
w
e
get
a
dev
elopmen
t

of
F
[
G
.
Nev
ertheless,
F
[
G
and
F
t
G
dier,
for
they
denote
dieren
t
sets
of
reduction
sequences.
Hence,
assuming
parallel
reduction
as
atomic,
w
e
are
not
allo
w
ed
to
equate
them.
What
w
e
exp
ect
to
equate
are
instead
reductions
in
whic
h
redexes
are
p
erm
uted
preserving
their
grouping,
i.e.,
lik
e
in
the
t
w
o
reductions
F
t
G
and
G
t
F
.
Lemma
..
(parallel
mo
v
es)
L
et
F
and
G
b
e
set
of
r
e
dexes
of
a
-term
M.
We
have
that:
(i)
F
t
G
and
G
t
F
ends
at
the
same
expr
ession;
(ii)
H=(F
t
G
)
=
H=(G
t
F
).
The
main
consequence
of
the
previous
lemma
is
that
the
equiv
alence
F
t
G

G
t
F
is
sound.
W
e
can
th
us
use
it
as
the
core
of
the
equiv
alence
of
reduction
b
y
p
erm
utation,
the
other
equations
b
eing
the
ones
induced
b
y
the
fact
that
w
e
w
an
t
to
get
a
congruence
with
resp
ect
to
comp
osition
of
reductions.

.
Zig-Zag
0
Denition
..
(p
erm
utation
equiv
alence)
The
p
ermutation
e
quiv-
alenc
e
of
reductions

is
the
smallest
congruence
with
resp
ect
to
comp
o-
sition
of
reductions
satisfying
the
parallel
mo
v
es
lemma
and
elimination
of
empt
y
steps.
Namely
,

is
the
smallest
equiv
alence
suc
h
that:
(i)
F
t
G

G
t
F
,
when
F
and
G
are
set
of
redexes
of
the
same
-term;
(ii)
;
=
;
(iii)



0
,
when



0
.
The
notion
of
residual
extends
to
reductions
to
o.
In
fact,
w
e
ha
v
e
the
follo
wing
denition
b
y
induction
on
the
length
of
the
reduction:
=
=

(F
)=
=
(=)(F
=(=))
The
previous
denition
allo
ws
to
conclude
this
part
with
the
so-called
diamond
prop
ert
y
.
Theorem
..
(diamond
prop
ert
y)
F
or
any
p
air
of
r
e
ductions

and

starting
fr
om
the
same
term,
we
have
that

(=)
=

(=).
That
can
b
e
graphically
depicted
b
y
the
follo
wing
diamond:
M
M










M




?
?
?
?
?
?
?
N

=


?
?
?
?
?
?
?
=








Let
us
remark
that
the
previous
comm
uting
diagram
is
indeed
the
base
of
the
equiv
alence
b
y
p
erm
utation.
In
fact,
t
w
o
reductions

and

are
p
erm
utation
equiv
alen
t
if
and
only
comp
osing
instances
of
the
previous
diagram
w
e
can
get
a
comm
uting
diagram
in
whic
h
the
comp
osition
of
the
external
reductions
yields

and
.
The
diamond
prop
ert
y
is
a
strong
v
ersion
of
the
so-called
Ch
urc
h-
Rosser
(or
conuence)
prop
ert
y
.
In
fact,
it
pro
v
es
the
conuence
of
the
calculus,
sho
wing
at
the
same
time
ho
w
to
complete
an
y
pair
of
reductions

and

in
order
to
get
the
same
result.
Hence,
an
easy
corollary
of
the
previous
result
is
the
uniqueness
of
the
normal
form
(if
an
y).

0
R
e
dex
F
amilies
and
Optimality
..
F
amilies
of
r
e
dexes
Denition
..
(cop
y)
A
redex
S
with
history

is
a
c
opy
of
a
redex
R
with
history
,
written
R

S,
if
and
only
if
there
is
a
deriv
ation

suc
h
that

is
p
erm
utation
equiv
alen
t
to

(

)
and
S
is
a
residual
of
R
with
resp
ect
to

(S

R=).
Denition
..
(family)
The
symmetric
and
transitiv
e
closure
of
the
cop
y
relation
is
called
the
family
relation,
and
will
b
e
denoted
with
'.
Explicitly
,
t
w
o
redexes
R
and
S
with
resp
ectiv
e
histories

and

are
in
the
same
family
(R
'
S)
if
and
only
if
there
is
a
nite
sequence

0
T
0
;


T

;
:
:
:
;

k
T
k
,
with

0
T
0
=
R
and

k
T
k

S,
suc
h
that
either

i-
T
i-


i
T
i
or

i
T
i


i-
T
i
-
,
for
i
=
;
:
:
:
;
k.
That,
pictorially
,
giv
es
rise
to
a
sort
of
\zig-zag"
(see
Figure
.).
τ
M
ρ
σ
N
P
S
R
COPY 
R 2
j
Μ
R
ρ
σ
R
R
R
R
P
N
N 2
Ν
j
1
3
k
1
N
N 3
N k
S
FAMILY
Fig.
..
Cop
y
and
family
relations.
Example
..	
Let
us
come
bac
k
to
the
example
of
Figure
..
W
e
ha
v
e:
RS

T


RS

S

T


ST

RS

S

T


RS

T

F
rom
whic
h
w
e
conclude
that
RS

T

'
RS

T

.
Let
us
no
w
pro
v
e
a
few
in
teresting
prop
erties
of
the
cop
y
and
family
relations.
Lemma
..0
L
et



0
and



0
.
Then:
(i)
R

S
i

0
R


0
S
(ii)
R
'
S
i

0
R
'

0
S

.
Zig-Zag
0
Pr
o
of
Ob
vious,
since

is
a
congruence
for
comp
osition.
Although
the
previous
lemma
lo
oks
straigh
tforw
ard,
its
relev
ance
is
not
negligible.
Indeed,
it
sa
ys
that
in
order
to
c
hec
k
that
t
w
o
redexes
are
in
the
same
family
,
w
e
can
consider
an
y
other
history
of
the
redexes,
pro
vided
that
they
are
p
erm
utation
equiv
alen
t
to
the
giv
en
ones.
In
particular,
it
allo
ws
to
restrict
our
analysis
to
standar
d
deriv
ations.
In
fact,
let
us
remind
that
a
deriv
ation
R

R




is
standard
when
R
i
is
not
residual
of
an
y
redex
at
the
left
of
R
j
,
for
an
y
i
and
an
y
j
<
i.
In
the
case
of
parallel
reductions,
the
deriv
ation
F

F




is
standard
when
the
previous
pro
viso
holds
assuming
that
R
i
and
R
j
are
the
leftmost-
outermost
redexes
of
the
resp
ectiv
e
sets
F
i
and
F
j
.
A
relev
an
t
result
of
-calculus|the
so-called
standar
dization
the
or
em
|ensures
that,
for
an
y
reduction,
there
exists
an
equiv
alen
t
one
whic
h
is
standard.
The
p
erm
utation
equiv
alence
allo
ws
to
extend
the
usual
preorder
giv
en
b
y
the
prex
relation
b
et
w
een
reduction
sequences.
Namely
,
let
us
dene

v
,
when



for
some
reduction
.
Lemma
..
R

S
i

v

and
S

R=(=).
Pr
o
of
())
By
denition,
if
R

S
there
exists

suc
h
that



and
S

R=.
Th
us,

v
,
b
y
denition
of
v.
Moreo
v
er,


=,
that
implies
R=
=
R=(=)
and
S

R=(=).
(()
Just
tak
e

=
(=).
An
in
teresting
consequence
of
the
previous
lemma
is
that
the
cop
y
relation
is
decidable.
Lemma
..
(in
terp
olat
io
n)
F
or
any

v

v

and
R

T
,
ther
e
exists
a
r
e
dex
S
such
that
R

S

T
.
Pr
o
of
By
assumption,
there
exist
reductions

0
,

0
and

0
suc
h
that

0

,

0

,

0


and
T

R=
0
.
Th
us

0


0

0
,
and
b
y
left-cancellation

0


0

0
.
Since
R
has
a
residual
T
after

0


0

0
,
then
it
m
ust
also
ha
v
e
a
residual
S
after

0
.
Lemma
..
(uniqueness)
If
R


S
and
R


S,
then
R

=
R

.
Pr
o
of
By
the
fact
that
eac
h
redex
is
residual
of
at
most
one
ancestor.

0
R
e
dex
F
amilies
and
Optimality
Exercise
..
(i)
Pro
v
e
that

is
a
preorder.
(ii)
Pro
v
e
that
R
'
S
if
and
only
if
S

R=.
(Hint
:
F
or
the
if
part,
apply
an
induction
on
the
denition
of
',
using
in
terp
olation
and
uniqueness.)
.
Extraction
In
tuitiv
ely
,
t
w
o
redexes
R
and
S
are
in
a
same
family
if
and
only
if
they
ha
v
e
b
een
created
\in
a
same
w
a
y"
along

and
.
Nev
ertheless,
this
in
tuition
is
not
easy
to
formalize,
since
\creation"
is
a
v
ery
complex
op
eration
in
the
-calculus.
A
w
a
y
to
get
rid
of
this
complexit
y
is
to
mo
dify
the
calculus
asso
ciating
a
lab
el
to
eac
h
(sub)term.
In
this
lab
eled
v
ersion
of
the
calculus,
lab
els
w
ould
b
e
a
trace
of
the
history
of
eac
h
subterm,
and
in
particular
of
the
w
a
y
in
whic
h
eac
h
redex
has
b
een
created.
This
tec
hnique,
that
generalizes
an
idea
of
V
uillemin
for
recursiv
e
program
sc
hemes,
leads
to
the
lab
ele
d
-c
alculus
that
will
b
e
presen
ted
in
section
..
Here,
w
e
giv
e
an
alternativ
e
approac
h
to
zig-zag
that
do
es
not
in
v
olv
e
an
y
mo
dication
of
the
calculus.
Let
us
assume
to
ha
v
e
a
simplication
pro
cess
(extraction)
that
for
an
y
redex
R
thro
ws
a
w
a
y
all
the
redexes
in
its
history

that
are
not
relev
an
t
to
the
\creation"
of
R.
A
t
the
end
of
this
pro
cess,
w
e
w
ould
essen
tially
obtain
the
\causal
history"
of
R
(with
resp
ect
to
).
The
causal
histories
of
redexes
could
then
b
e
used
to
decide
when
t
w
o
redexes
are
in
the
same
family
.
Namely
,
w
e
could
sa
y
that
R
and
S
are
in
the
same
family
when
the
extraction
pro
cess
con
tract
them
to
the
same
redex
T
.
Ho
w
ev
er,
in
order
to
ac
hiev
e
suc
h
a
strong
result,
w
e
imm
ediately
see
that
w
e
ha
v
e
to
x
some
tec
hnical
details.
In
particular,
when
sev
eral
redexes
participate
to
the
creation
of
R
and
S,
the
corresp
onding
casual
histories
migh
t
dier
for
the
order
in
whic
h
suc
h
redexes
are
applied.
Unfortunately
,
this
w
ould
imm
ediately
lead
bac
k
to
p
erm
utation
equiv
alence
and
zig-
zag.
Th
us,
as
w
e
w
an
t
a
unique
\linear"
represen
tation
of
equiv
alen
t
causal
histories
(namely
,
a
unique
deriv
ation),
w
e
are
forced
to
organize
redexes
in
some
xed
order.
But
in
view
of
Lemma
..0,
this
do
es
not
seem
a
big
problem,
for
restricting
to
standar
d
deriv
ations
fulll
the
uniqueness
requiremen
t
and
do
es
not
force
an
y
limitation.
In
order
to
formally
dene
the
extraction
relation,
w
e
need
a
few
preliminary
denitions.
In
the
next
subsection
w
e
will
then
sho
w
that
extraction
giv
es
indeed
a
decision
pro
cedure
for
the
family
relation.
In

.
Extr
action
0
fact,
although
the
results
of
section
..
hold
for
redexes
whose
history
is
in
standard
form,
this
do
es
not
impact
decidabilit
y
of
zig-zag,
for
there
is
a
recursiv
e
algorithm
transforming
a
giv
en
reduction

in
to
a
(unique)
standard
reduction

s
suc
h
that



s
.
W
e
sa
y
that
t
w
o
deriv
ations

:
M

N
and

:
M

P
are
disjoint
if
they
con
tract
redexes
in
to
disjoin
t
sub
expressions
of
M.
This
means
that

:
M
=
C[Q

;
Q

]

C[Q
0

;
Q

]
=
N,
and

:
M
=
C[Q

;
Q

]

C[Q

;
Q
0

]
=
P
,
for
some
con
text
C[

;

]
with
t
w
o
disjoin
t
holes.
W
e
also
remind
that,
in
a
redex
R
=
(x:M
N),
the
subterm
x:M
is
the
function
p
art
of
R,
while
M
is
its
ar
gument
p
art.
Finally
,
let
us
recall
that
=
(the
residual
of
a
deriv
ation

with
resp
ect
to
a
deriv
ation
)
is
dened
inductiv
ely
b
y:
=
=


when

=

(
0
=)
(R=(=
0
))
when

=

0
R:
where

is
the
empt
y
reduction.
The
next
denition
giv
es
the
only
issue
that
p
ose
some
tec
hnical
dif-
culties
in
the
denition
of
extraction.
The
idea
is
that,
giv
en
a
redex
R
=
(x:
M
N)
and
a
reduction
R
i
suc
h
that

i
w
orks
inside
the
i-th
instance
N
i
of
the
argumen
t
part
N
of
R.
An
y
redex
created
b
y
R
i
could
ha
v
e
b
een
created
b
y
the
direct
execution
in
N
of
the
reduction

isomorphic
to

i
.
In
order
to
formalize
this
p
oin
t,
let
us
in
tro
duce
the
notation
M
x
[

;

;
:
:
:
;

]
to
represen
t
the
con
text
obtained
b
y
replacing
a
hole
for
all
the
o
ccurrences
of
a
giv
en
v
ariable
x
o
ccurring
free
in
the
term
M.
Denition
..
(paralleli
zatio
n)
Let
R
=
(x:M
N).
Let
R
b
e
a
deriv
ation
suc
h
that

is
in
ternal
to
the
i-th
instance
of
N
in
the
con
tractum
M[N=x]
of
R
(see
the
gure
in
item

of
Denition
..).
The
reduction
j
jR
(
p
ar
al
lelize
d
b
y
R),
is
inductiv
ely
dened
as
follo
ws:

j
j
R
=

(S)
j
j
R
=
(S
0
=R)
((=F
)j
j(R=S
0
))
where
S

S
0
=R;
F
=
S
0
=(RS)
In
tuitiv
ely
,
for

corresp
onds
to
a
reduction
applied
to
the
instance
of
N
inserted
in
the
i-th
hole
of
M
x
[

;
:
:
:
;

],
the
reduction

w
orks
on
a
subterm
isomorphic
to
N.
Hence,
there
exists
a
reduction

0
:
C[(x:
M
N)]

C[(x:
M
N
0
)]
in
ternal
to
N
and
isomorphic
to
,
suc
h
that

:
C[M
x
[N;
:
:
:
;
N;
:
:
:
;
N]]

C[M
x
[N;
:
:
:
;
N
0
;
:
:
:
;
N]]:

0
R
e
dex
F
amilies
and
Optimality
The
order
of
R
and

could
then
b
e
comm
uted
obtaining

0
t
R.
Nev-
ertheless,
it
is
immediate
that
after

0
t
R
all
the
instances
of
N
in
C[M
x
[N;
:
:
:
;
N;
:
:
:
;
N]]
are
con
tracted
to
M
0
.
The
reduction

0
t
R
is
indeed
the
parallelization
of

b
y
R,
that
is,

0
=R
=

0
t
R
(see
again
item

of
Denition
..).
In
order
to
clarify
ho
w
Denition
..
ts
suc
h
an
informal
idea
of
parallelization,
let
us
remark
that,
b
y
induction
on
S:
(i
)
S
0
is
in
ternal
to
N;
(ii
)
F
is
disjoin
t
from
;
(iii
)
R=S
0
is
a
singleton
fR
0
g;
(iv
)
=F
is
in
ternal
to
the
i-th
instance
of
the
argumen
t
of
R
0
in
its
con
tractum.
By
whic
h
w
e
conclude
the
soundness
of
Denition
..
and
that,
as
w
e
an
ticipated,
(S)j
jR
=
(S
0

0
)=R,
for
a
suitable
reduction

0
in
ternal
to
N.
Denition
..
(extraction)
The
con
traction
b
y
extraction
B
is
the
union
of
the
follo
wing
four
relations:
(i)
RS
B

S
0
,
if
S

S
0
=R;
(ii)

(R
t
)
B

,
if
jj


and
R,

are
disjoin
t
reductions;
R /σ
/ R
σ
C[M’,N]
C[M’,N’]
C[M,N]
C[M,N’]
ρ
σ
R
(iii)
(R
t
)
B

,
if
jj


and

is
in
ternal
to
the
function
part
of
R;
R /σ
/ R
σ
ρ
σ
R
C[M[N/x]]
C[M’[N/x]]
λ
λ
C[(   x.M N)]
C[(   x.M’ N)]
(iv)
R
B
i


0
,
if
jj

,

is
in
ternal
to
the
i-th
instance
of
the
argumen
t
of
R
in
its
con
tractum,
and

0
=R
=
j
jR.

.
Extr
action
0	
R /σ
’
σ
’ / R =     || R
σ
σ
ρ
R
C[M[N/x]]
λ
C[(   x.M N’)]
’
σ
x
C[M   [N, . . . ,N’, . . . ,N]]
C[(   x.M N)]
λ
C[M[N’/x]]
The
extr
action
relation
D
is
the
transitiv
e
and
reexiv
e
closure
of
B.
Example
..
Let
us
consider
again
the
example
in
Figure
..
By
parallelization,
w
e
ha
v
e
RS

T

B
ST
and
RS

T

B
ST
.
By
the
second
rule
of
the
extraction
relation,
w
e
ha
v
e
RS

S

T

B
RS

T

and
RS

S

T

B
RS

T

.
Summari
zing,
RS

S

T

D
ST
E
RS

S

T

:
Whic
h
is
the
same
result
that
w
e
could
ha
v
e
get
applying
zig-zag
(see
Example
..	).
Theorem
..
([L

ev0
])
D
is
c
onuent
and
str
ongly
normalizing.
Pr
o
of
See
[L

ev0]
or
solv
e
Exercise
...
Exercise
..
Let

i
R
i
,

i
S
i
,
and

i
T
i
b
e
the
redexes
with
history
relativ
e
to
the
example
in
Figure
..
Applying
D
to
eac
h
of
them,
v
er-
ify
that
extraction
is
conuen
t
and
strongly
normalizing.
F
urthermore,
c
hec
k
that:
(i
)
R
is
the
unique
normal
form
of
an
y

i
R
i
;
(ii
)
S
is
the
unique
normal
form
of
an
y

i
S
i
;
(iii
)
ST
is
the
unique
normal
form
of
an
y

i
T
i
.
Exercise
..
Pro
v
e
the
follo
wing
fact:
Let
R
and
S
b
e
t
w
o
distinct
redexes
in
a
term
M.
If
T
;
T

;
T

are
suc
h
that
T

T

=(R=S),
T

T

=(S=R),
then
there
exists
some
redex
T
0
suc
h
that
T

T
0
=(R
t
S)
and
T

T
0
=(S
t
R).
Use
the
previous
result
to
pro
v
e
Theorem
...
..
Extr
action
and
families
In
this
section,
w
e
shall
consider
standard
deriv
ations
only
.

0
R
e
dex
F
amilies
and
Optimality
Prop
osition
..
If
ther
e
exists
a
r
e
duction
T
such
that
R
D
T
E
S,
then
R
'
S.
Pr
o
of
It
is
enough
to
observ
e
that,
if
R
D
T
,
then
R
'
T
.
In
the
rst
three
cases
in
the
denition
of
B,
w
e
ob
viously
ha
v
e
T

R.
In
the
last
case
(see
Figure
.)
w
e
ha
v
e

=

0
R
0

00
and

=

0

0
,
for
some
R
0
.
Let

=

0
=(R
0

00
).
Then

00



0
=R
0
.
Moreo
v
er,
R
has
a
unique
residual
T
0
after
,
and
this
m
ust
also
b
e
a
residual
of
T
after
R
0
=
0
.
(Note
that
T
is
in
ternal
to
N
0
in
C[(:
x
N
0
)],
and
that
R
is
the
image
of
T
in
C[M
x
[N;
:
:
:
;
N
0
;
:
:
:
;
N]].)
Th
us,
R


0
(R
0
t

0
)T
0

T
,
that
implies
R
'
T
.
C[M   [N, . . . ,N’, . . . ,N]]
x
"
ρ
’
τ
’
ρ
x
C[M   [N’, . . . ,N’, . . . ,N’]]
R’
C[M[N/x]]
ν
C[(   x.M N)]
λ
λ
=
C[(   x.M N)]
C[M[N’/x]]
’
R’/τ
τ
τ
’ / R’ =     || R’
Fig.
..
Also
the
con
v
erse
of
the
previous
prop
osition
is
true.
But
to
pro
v
e
it
w
e
need
some
preliminary
lemmas.
Lemma
..
If
R

S,
then
S
D
R.
Pr
o
of
If
R

S,
then
S

R=
and
S
D
R
b
y
B

.
Lemma
..	
L
et
R

S.
Ther
e
is
a
r
e
duction
T
such
that
R
D
T
E
S.
Pr
o
of
First
of
all,
let
us
note
that

v
,
for
b
y
h
yp
othesis
R

S.
The
pro
of
con
tin
ues
then
b
y
induction
on
jj.
The
base
case
is
imm
ediate.
In
fact,
when
jj
=
0,
also
jj
=
0,
for

v
.
The
result
follo
ws
then
b
y
Lemma
...
So,
let
us
pro
ceed
with
the
induction
case.
W
e
can
distinguish
t
w
o
sub
cases,
according
to
the
length
of
.
The

.
Extr
action

easy
one
is
jj
=
0,
for
the
result
follo
ws
again
b
y
Lemma
...
Th
us,
let

=
S
0

0
and

=
R
0

0
.
If
S
0
=
R
0
,
then

0
R


0
S
and,
b
y
the
induction
h
yp
othesis,
there
exists

0
T
suc
h
that

0
R
D

0
T
E

0
S.
Then,
for

=
R
0

0
,
R
D
T
E
S.
Summarizing,
w
e
ha
v
e
left
to
pro
v
e
the
case

=
S
0

0
,

=
R
0

0
,
and
R
0
=
S
0
.
The
redex
R
0
cannot
b
e
external
or
to
the
left
of
S
0
,
for
otherwise
R
0
=
0
=
;,
con
tradicting
the
h
yp
othesis

v
.
Since

is
standard
(recall
the
assumption
at
the
b
eginning
of
this
section),
it
can
b
e
decomp
osed
as

=

f
t

a
t

d
suc
h
that

f
;

a
and

d
are
resp
ectiv
ely
in
ternal
to
the
function
part
of
S
0
,
in
ternal
to
the
argumen
t
part
of
S
0
,
and
disjoin
t
from
S
0
(to
its
righ
t).
Moreo
v
er,
S
0
has
a
unique
residual
S
00
after

(remind
that
S
0
is
leftmost
w.r.t.
Rq
0
).
W
e
pro
ceed
then
b
y
case
analysis,
according
to
the
m
utual
p
ositions
of
R
and
S
00
in
the
nal
term
of
.
(i)
R
is
external
or
to
the
left
of
S
00
:
There
is
a
redex
T
external
or
to
the
left
of
S
0
suc
h
that
R

T
=
(easy
induction
on
jj).
Th
us,
R
D
T
.
That,
b
y
Prop
osition
..,
implies
T
'
R.
Moreo
v
er,
T
'
S,
for
R

S.
Hence,
S

T
=
(see
Exercise
..)
and
S
D
T
(b
y
denition
of
B

).
(ii)
R
is
in
ternal
to
the
function
part
of
S
00
:
Let

=
(
a
t

d
)=
f
.
If
S
f
is
the
unique
residual
of
S
0
after

f
,
then
S
f
=
=
fS
00
g.
Moreo
v
er,

is
disjoin
t
from
the
function
part
of
S
f
.
Th
us,
there
exists
a
redex
R
f
in
the
function
part
of
S
f
suc
h
that
R
f
=
=
fRg,
that
implies
b
oth
R
D

f
R
f
and
R


f
R
f
.
By
transitivit
y
,
since
R

S,
w
e
also
ha
v
e

f
R
f

S.
By
Lemma
..,
S

R
f
=(=
f
).
Then,
let

0
f
=

f
=S
0
and
R
0
f
=
R
f
=S
f
(i.e.,
(
f
R
f
)=S
0
=

0
f
R
0
f
).
W
e
ha
v
e
that

0
f
R
0
f


0
S
and
S
0

0
f
R
0
f
D

f
R
f
(see
Figure
.).
Since

f
is
in
the
function
part
of
S
0
and

f
R f
f
R’
σ ’
f
S
S’
ν
R
S
ρ f
’f
ρ
S"
Fig.
..


R
e
dex
F
amilies
and
Optimality
is
standard,
S
0

0
f
and
then

0
f
are
standard
to
o.
W
e
can
no
w
apply
the
induction
h
yp
othesis
to

0
f
R
0
f


0
S,
concluding
that
there
is

0
T
0
suc
h
that

0
f
R
0
f
D

0
T
0
E

0
S.
Therefore,
S
0

0
f
R
0
f
D
S
0

0
T
0
E
S
(let
us
note
that
also

0
is
in
the
function
part
of
S
0
,
and
then
that
S
0

0
to
o
is
standard).
But
w
e
ha
v
e
already
seen
that
S
0

0
f
R
0
f
D

f
R
f
.
So,
b
y
the
Ch
urc
h-Rosser
prop
ert
y
of
D,
there
exists
a
deriv
ation
T
suc
h
that
S
0

0
T
0
D
T
E

f
R
f
.
Th
us,
S
D
T
E
R.
(iii)
R
is
disjoin
t
from
S
00
or
to
its
righ
t:
There
is
again
some
R
d
disjoin
t
from
the
residual
S
d
of
S
0
after

d
,
suc
h
that
R
D

d
R
d
and
R


d
R
d
.
Then
w
e
pro
ceed
as
in
the
previous
case.
(iv)
R
is
in
the
argumen
t
part
of
S
00
:
There
is
a
redex
R
a
in
the
argumen
t
part
of
the
residual
S
a
of
S
0
after

a
,
suc
h
that
R
D

a
R
a
and
R


a
R
a
.
Unfortunately
,
the
previous
reasoning
do
es
not
go
through
so
simply
in
this
case,
since

00
a
=

a
=S
0
migh
t
not
b
e
standard.
In
fact,
let
us
note
that

00
a
is
the
union
of
disjoin
t
reductions,
eac
h
of
them
in
ternal
to
a
dieren
t
instance
of
the
argumen
t
of
S
a
in
its
con
tractum.
An
yho
w,
it
is
still
true
that

a
R
a

S,
for
R

S.
Th
us,
S

R
a
=(=
a
)
and
there
is
a
redex
R
00
a

R
a
=S
a
suc
h
that

00
a
R
00
a


0
S.
Moreo
v
er,
R
00
a
is
in
ternal
to
some
instance,
sa
y
the
i-th
one,
of
the
argumen
t
part
of
S
a
in
its
con
tractum.
Let
us
tak
e
the
comp
onen
t

0
a
of

00
a
in
ternal
to
suc
h
an
instance.
There
is
a
redex
R
0
a
suc
h
that

0
a
R
0
a

R,
with

0
a
R
0
a
standard.
Moreo
v
er,
S
0

0
a
R
0
a
D

a
R
a
,
for

a
R
a
=S
0
=
(
0
a
R
0
a
)j
jS
0
b
y
B

;
and

0
a
R
0
a


0
S,
for

00
a
R
00
a


0
S.
W
e
can
no
w
pro
ceed
as
in
case
.
By
induction
h
yp
othesis,
there
is

0
T
0
suc
h
that

0
a
R
0
a
D

0
T
0
E

0
S.
Therefore,
S
0

0
a
R
0
a
D
S
0

0
T
0
E
S.
But
since
S
0

0
a
R
0
a
D

a
R
a
,
b
y
the
Ch
urc
h-Rosser
prop
ert
y
of
D,
there
exists
T
suc
h
that
S
0

0
T
0
D
T
E

a
R
a
.
Th
us,
S
D
T
E
R.
Let
us
remark
the
structure
of
the
previous
pro
of.
It
follo
ws
exactly
the
denition
of
D.
In
fact,
eac
h
sub
case
in
Denition
..
yields
a
corresp
onding
sub
case
in
the
non-trivial
part
of
the
pro
of.
It
is
indeed
true
that
this
is
the
actual
reason
of
the
four
cases
in
the
denition
of
extraction.
Prop
osition
..0
If
R
'
S,
then
R
D
T
E
S
for
some
T
.

.
L
ab
eling

Pr
o
of
By
denition
of
family
,
R
'
S
if
and
only
if
there
exists
a
c
hain
of

i
R
i
suc
h
that

0
R
0
=
R,

n
R
n
=
S,
and
for
all


i

n
either

i-
R
i-


i
R
i
or

i
R
i


i-
R
i-
(remind
that
w
e
can
assume
without
loss
of
generalit
y
that
all
the

i
are
standard).
By
Lemma
..	,
there
exists

i
T
i
suc
h
that

i-
R
i-
D

i
T
i
E

i
R
i
,
for
ev
ery
i.
By
the
conuence
of
D,
w
e
conclude
then
that
there
exists
T
suc
h
that
R
D
T
E
S.
Theorem
..
(decidabil
i
t
y
of
extraction)
L
et

and

b
e
two
standard
r
e
ductions.
Then
R
'
S
if
and
only
if
R
D
T
E
S
for
some
T
.
Pr
o
of
By
Prop
osition
..
and
Prop
osition
..0.
The
previous
result
not
only
establishes
a
full
corresp
ondence
b
et
w
een
zig-zag
and
extraction,
but
also
giv
es
an
ee
ctive
pro
cedure
for
deciding
the
family
relation.
In
fact,
giv
en
t
w
o
redexes
R
and
S,
there
is
an
eectiv
e
w
a
y
for
deriving
the
standard
reductions

s
and

s
resp
ectiv
ely
equiv
alen
t
to

and

b
y
p
erm
utation.
Then,
as
extraction
is
eectiv
e
and
terminating,
w
e
can
compute
the
D
canonical
forms

0
s
R
0
and

0
s
S
0
of

s
R
and

S
S.
If
and
only
if

0
s
R
0
=

0
s
S
0
the
redexes
R
and
S
are
in
the
same
family
.
The
previous
considerations
can
b
e
summarized
as
follo
ws.
Denition
..
(canonical
deriv
ation)
Ev
ery
standard
deriv
ation
u
in
normal
form
with
resp
ect
to
D
will
b
e
called
c
anonic
al.
Corollary
..
(canonical
represen
tati
v
e)
The
canonical
repre-
sen
tativ
e
of
a
family
c
an
b
e
ee
ctively
derive
d
fr
om
e
ach
memb
er
R
of
the
family:
it
is
the
unique
c
anonic
al
derivation

c
R
c
such
that

s
R
D

c
R
c
,
wher
e

s
is
the
standar
d
derivation
e
quivalent
to
.
Each
family
of
r
e
dexes
has
a
unique
c
anonic
al
r
epr
esentative.
.
Lab
eling
The
lab
ele
d
-c
alculus
is
an
extension
of
-calculus
prop
osed
b
y
L

evy
in
[L

ev].
Let
L
=
fa;
b;



g
b
e
a
den
umerable
set
of
atomic
lab
els.
The
set
L
of
lab
els,
ranged
o
v
er
b
y
;
;



,
is
dened
as
the
set
of
w
ords
o
v
er
the
alphab
et
L,
with
an
arbitrary
lev
el
of
nested
underlinings
and
o
v
erlin-
ings.


R
e
dex
F
amilies
and
Optimality
F
ormally
,
L
is
the
smallest
set
con
taining
L
and
closed
with
resp
ect
to
the
follo
wing
formation
rules:
(i)
if


L
and


L,
then


L;
(ii)
if


L,
then


L;
(iii)
if


L,
then


L.
The
op
eration
of
concatenation

is
supp
osed
to
b
e
asso
ciativ
e.
The
set

L
V
of
lab
eled
-terms
o
v
er
a
set
V
of
v
ariables
and
a
set
L
of
lab
els
is
dened
as
the
smallest
set
con
taining:
(i)
x

,
for
an
y
x

V
and


L;
(ii)
(M
N)

,
for
all
M;
N


L
V
and


L;
(iii)
(x:M)

,
for
an
y
M


L
V
and


L.
As
usual,
w
e
shall
iden
tify
terms
up
to
-con
v
ersion.
The
concatenation


M
of
a
lab
el

with
a
lab
eled
term
M
is
dened
as
follo
ws:
(i)


x

=
x

(ii)


(M
N)

=
(M
N)

(iii)


(x:M)

=
(x:M)

The
substitution
M[N=x]
of
a
free
v
ariable
x
for
a
lab
eled
-term
N
in
a
lab
eled
-term
M,
is
inductiv
ely
dened
b
y:
(i)
x

[N=x]
=


N
(ii)
y

[N=x]
=
y

,
when
y
=
x
(iii)
(M

M

)

[N=x]
=
(M

[N=x]
M

[N=x])

(iv)
(x:
M)

[N=x]
=
(x:
M)

(v)
(y:
M)

[N=x]
=
(y:
M[N=x])

In
item

ab
o
v
e,
N
is
free
for
y
in
M,
that
is,
no
free
v
ariable
of
N
is
captured
b
y
the
binder
of
y.
This
is
not
a
limitati
on,
due
to
our
assumption
on
-con
v
ersion,
w
e
can
alw
a
ys
suitably
rename
the
v
ariable
y
in
y:
M.
In
the
lab
eled
system,
-reduction
is
dened
b
y
the
follo
wing
rule:
((x:M)

N)

!




M[

N=x]
The
de
gr
e
e
of
a
redex
R
=
((x:M)

N)

is
the
lab
el

of
its
function
part
(notation:
degree
(R):
=
).
The
formal
presen
tation
of
the
lab
eled
-calculus
giv
en
ab
o
v
e
should
not
scare
the
reader.
The
main
idea
is
indeed
v
ery
simple,
once
shifting
from
the
concrete
syn
tax
of
terms
to
their
graphical
represen
tation
as

.
L
ab
eling

syn
tax
trees.
In
this
con
text,
to
add
a
lab
el
to
eac
h
subterm
corresp
onds
to
mark
eac
h
edge
in
the
tree
b
y
a
lab
el.
The
degree
of
a
redex
R
=
((x:M)

N)

is
the
lab
el
of
the
edge
b
et
w
een
the
corresp
onding
@-
no
de
of
(x:M
N
and
the
-no
de
of
x:M.
Firing
the
redex,
the
degree
of
R
is
captured
b
et
w
een
the
lab
els
of
the
other
edges
inciden
t
to
the
the
no
des
in
R.
Namely
,
b
et
w
een
the
lab
el
of
the
application
of
R
and
the
lab
el
of
the
b
o
dy
of
the
abstraction
in
R,
and
b
et
w
een
the
lab
el
of
an
y
o
ccurrence
of
the
v
ariable
in
R
and
the
lab
el
of
the
argumen
t
part
of
R.
In
the
con
tractum,
the
pairs
of
edges
corresp
onding
to
the
previous
pairs
of
lab
els
are
replaced
b
y
new
connections.
Apart
from
lining,
the
lab
els
of
these
new
edges
are
obtained
comp
osing
the
lab
els
of
the
corresp
onding
edges
in
the
natural
w
a
y
(see
Figure
.).
λx
δ αε
1
M
N
N
x
x
. . .
. . .
@
M
N
β
δ
δ 1
k
βαγ
γ
α
ε
δ αε
k
Fig.
..
Lab
eled
-reduction
Ov
erlining
and
underlining
resp
ectiv
ely
represen
t
the
t
w
o
w
a
ys
in
whic
h
new
connections
are
created
ring
R:
up
w
ards
(from
the
con-
text
to
the
b
o
dy
M
of
x:M),
and
do
wn
w
ards
(from
the
o
ccurrences
of
the
v
ariable
x
in
M
to
the
instances
of
the
argumen
t
N).
Example
..
W
e
already
observ
ed
that,
con
tracting
(I
(I
x)),
after
one
step
w
e
get
the
same
term
(I
x)
whic
hev
er
redex
w
e
reduced.
Besides,
w
e
p
oin
ted
out
that
this
equiv
alence
of
the
result
should
ha
v
e
b
een
considered
merely
inciden
tal|for
our
purp
oses,
a
sort
of
lac
k
in
the
syn
tax
of
-calculus.
This
situation
is
correctly
handled
b
y
the
lab
eled
system,
where
lab
els
allo
w
to
distinguish
b
et
w
een
the
w
a
y
in
whic
h
the
t
w
o
terms
(I
x)
are
obtained
(see
Figure
.).
Besides,
let
us
also
note
that,
after
one
more
step,
the
reduction
ends
with
the
same
term
also
in
the
lab
eled
system
(Figure
.).
In
fact,
lab
eling
preserv
es
conuence
of
the
calculus,
as
w
e
will
sho
w
in
the
next
section.


R
e
dex
F
amilies
and
Optimality
λx
x
λx
x
@
@
x
a
c
d
e
f
g
b
λx
x
@
x
a
defeg
b
c
λx
x
@
x
abcbd
f
g
e
xabcbdefeg
Fig.
..
(I
(I
x))
Example
..
In
the
-calculus,
reducing
(
)
w
e
get
a
reduction
sequence
comp
osed
of
an
innite
n
um
b
er
of
copies
of
(
).
As
for
the
previous
example,
in
the
lab
eled
calculus
this
is
not
true
an
ymore.
In
fact,
the
reduction
of
(
)
giv
es
rise
to
an
innite
sequence
of
distin-
guished
lab
eled
terms
(see
Figure
.).
λx
λx
@
a
b
d
e
c
@
x
x
@
x
x
f
g
h
i
λx
λx
λx
λx
@
@
x
x
@
x
x
g
h
i
abc
ebf
g
h
i
dbf
@
@
x
x
@
x
x
g
h
i
abcdbfg
idbfebf
hdbfebf
g
h
i
Fig.
..
(x:(x
x)
x:(x
x))
..
Conuenc
e
and
Standar
dizati
on
In
this
section
w
e
shall
pro
v
e
the
Ch
urc
h-Rosser
and
standardization
prop
erties
for
the
lab
eled
-calculus.

.
L
ab
eling

F
or
the
sak
e
of
the
pro
of
of
suc
h
prop
erties,
w
e
will
consider
a
suitable
extension
of
-reduction.
Namely
,
w
e
will
assume
that
the
degrees
of
the
redex
con
tracted
reducing
terms
v
erify
a
giv
en
predicate
P
on
L.
According
to
this,
the
reduction
((x:M)

N)

!




M[

N=x]
will
b
e
considered
legal
only
when
P
()
is
true.
By
the
w
a
y
,
the
in
tro
duction
of
this
predicate
do
es
not
cause
an
y
loss
of
expressiv
eness,
as
usual
-reduction
corresp
onds
to
the
case
in
whic
h
P
is
alw
a
ys
true.
F
urthermore,
the
use
of
P
allo
ws
to
reco
v
er
in
a
v
ery
simple
w
a
y
man
y
other
kinds
of
lab
elings
considered
in
the
literature,
without
a
sensible
complication
of
the
theory
of
the
calculus.
The
sc
hema
of
the
pro
ofs
of
conuence
and
standardization
is
the
follo
wing:
(i)
W
e
shall
start
pro
ving
that
lab
eled
-calculus
is
lo
cally
conuen
t,
for
an
y
c
hoice
of
the
predicate
P
.
(ii)
W
e
shall
directly
pro
v
e
standardization
for
strongly
normalizable
terms.
(iii)
Since
it
is
w
ell
kno
wn
that
lo
cal
conuence
implies
conuence
for
strongly
normalizable
terms,
the
goal
will
b
e
to
exploit
the
previous
results
in
conjunction
with
some
suitable
predicate
P
ensuring
strong
normalization.
T
o
this
purp
ose,
w
e
shall
giv
e
some
sucien
t
conditions
for
P
that
imply
strong
normalization
of
ev
ery
term
(taking
in
to
accoun
t
reductions
that
are
legal
with
resp
ect
to
P
only).
(iv)
Finally
,
w
e
shall
observ
e
that,
for
an
y
pair
of
reductions

:
M

N
and

0
:
M

N
0
,
w
e
can
construct
a
predicate
P
satisfying
the
ab
o
v
e
men
tioned
sucien
t
conditions,
for
whic
h
the
reductions

and

0
are
legal.
The
pro
of
of
lo
cal
conuence
is
preceded
b
y
some
lemma
useful
to
pro
v
e
that
substitution
b
eha
v
es
w
ell
with
resp
ect
to
lab
els.
Namely
,
that
the
usual
prop
ert
y
of
-calculus
M[N=x]

M
0
[N
0
=x],
when
M

M
0
and
N

N
0
,
holds
in
the
lab
eled
case
to
o.
Lemma
..
(i)


(M[N=x])
=
(

M)[N=x]
(ii)
M[N=x][N
0
=y]
=
M[N
0
=x][N[N
0
=y]=x],
when
x
=
y
and
x
do
es
not
o
c
cur
fr
e
e
in
N
0
.
Pr
o
of
An
easy
induction
on
the
structure
of
M.


R
e
dex
F
amilies
and
Optimality
Lemma
..
If
M

M
0
,
then
M[N=x]

M
0
[N=x].
Pr
o
of
Let
us
pro
v
e
rst
the
case
M
!
M
0
b
y
structural
induction
on
M:
(i)
M
=
x

.
This
case
is
v
acuous.
(ii)
M
=
(x:M

)

.
Since
the
redex
m
ust
b
e
in
ternal
to
M

,
M
0
=
(x:M
0

)

,
with
M

!
M
0

.
By
induction
h
yp
othesis,
M

[N=x]
!
M
0

[N=x],
and
th
us
M[N=x]
!
M
0
[N=x].
(iii)
M
=
(M

M

)

,
and
the
redex
is
in
ternal
to
M

or
M

.
This
case
is
similar
to
the
previous
one.
(iv)
M
=
((y:M

)

M

)

,
M
0
=


M

[

M

=y]
and
P
()
is
true.
By
-con
v
ersion
w
e
ma
y
supp
ose
x
=
y
and
y
not
free
in
N.
Then,
w
e
ha
v
e
M[N=x]
=
((y:M

[N=x])

M

[N=x])

,
and
M
0
[N=x]
=
(

M

[

M

=y])[N=x]
=


M

[

M

=y][N=x]
b
y
Lemma
...
=


M

[N=x][(

M

)[N=x]=y]
b
y
Lemma
...
=


M

[N=x][

M

[N=x]=y]
b
y
Lemma
...
Since
P
()
is
true,
M[N=x]
!
M
0
[N=x].
By
iteration,
w
e
get
the
case
M

M
0
.
Lemma
..
If
M

M
0
,
then


M



M
0
.
Pr
o
of
T
rivial.
Lemma
..
If
N

N
0
,
then
M[N=x]

M[N
0
=x].
Pr
o
of
By
structural
induction
on
M:
(i)
M
=
x

.
Then,
M[N=x]
=


N,
M[N
0
=x]
=


N
0
,
and


N



N
0
,
b
y
Lemma
...
(ii)
M
=
y

,
where
y
=
x.
Ob
vious.
(iii)
M
=
(x:M

)

.
Then
(up
to
-con
v
ersion),
M[N=x]
=
(x:M

[N=x])

,
and
M[N
0
=x]
=
(x:M

[N
0
=x])

.
By
induction
h
yp
othesis,
M

[N=x]

M

[N
0
=x],
and
th
us
M[N=x]

M[N
0
=x].
(iv)
M
=
(M

M

)

.
Analogous
to
the
previous
case.
Corollary
..
If
M

M
0
and
N

N
0
then,
M[N=x]

M
0
[N
0
=x].

.
L
ab
eling
	
Pr
o
of
By
Lemma
..
and
Lemma
...
Prop
osition
..
(lo
cal
conuence)
F
or
any
p
air
of
r
e
dexes
M
R
!
M
0
and
M
S
!
M
00
,
ther
e
exist
N
and
two
r
e
ductions

and

such
that
M
0


N
and
M
00

!
N.
Pr
o
of
By
structural
induction
on
M:
(i)
M
=
x

.
This
case
is
v
acuous.
(ii)
M
=
(x:M

)

.
Since
R
and
S
m
ust
b
e
in
ternal
to
M

,
M
0
=
(x:M
0

)

,
M
00
=
(x:M
00

)

,
M

!
M
0

,
and
M

!
M
00

.
By
induction
h
yp
othesis,
there
exists
N

suc
h
that
M
0


N

and
M
00


N

.
T
aking
N
=
(x:N

)

w
e
ha
v
e
done.
(iii)
M
=
(M

M

)

,
and
b
oth
redexes
R
and
S
are
either
in
ternal
to
M

or
in
ternal
to
M

.
This
case
is
similar
to
the
previous
one.
(iv)
M
=
(M

M

)

,
R
is
in
ternal
to
M

and
S
is
in
ternal
to
M

(or
vice
v
ersa).
In
this
case,
w
e
close
the
diamond
in
one
step,
ring
the
unique
residuals
of
R
and
S
in
M
00
and
M
0
,
resp
ectiv
ely
..
(v)
M
=
((y:M

)

M

)

R
!
M
0
=


M

[

M

=y].
W
e
distin-
guish
t
w
o
sub
cases:
(a)
S
is
in
ternal
to
M

.
Let
M
0

b
e
the
reduct
of
M

b
y
S.
Then,
M
00
=
((y:M
0

)

M

)

!
N
=


M
0

[

M

=y].
Since
M

!
M
0

,
b
y
Lemma
..
and
Lemma
..,
M
0
=


M

[

M

=y]
!
N
=


M
0

[

M

=y].
(b)
S
is
in
ternal
to
M

.
Let
M
0

b
e
the
reduct
of
M

b
y
S.
Then,
M
00
=
((y:M

)

M
0

)

!
N
=


M

[

M
0

=y].
Since
M

!
M
0

,
b
y
Lemma
..
and
Lemma
..,
M
0
=


M

[

M

=y]

N
=


M

[

M
0

=y].
(vi)
As
in
the
previous
case,
in
v
erting
R
and
S.
It
is
imm
ediate
to
c
hec
k
that,
extending
the
denitions
of
residual
and
dev
elopmen
t
to
the
lab
eled
case
(see
Denition
..
and
Theorem
..),
w
e
ha
v
e
indeed
that

=
S=R
and

=
S=R.
Remark
..	
Let
us
note
again
that
the

and

are
legal
for
an
y
predicate
P
suc
h
that
b
oth
P
(R)
and
P
(S)
are
true.
Indeed,
since

=
S=R
and

=
S=R,
the
degree
of
all
the
redexes
red
in

()
is
equal
to
degree
S
(degree
R).
This
migh
t
not
b
e
surprising,
since
lab
els
aim
at
mark
redexes
with
the
same
origin,
closing
the
diamond
of
lo
cal
conuence
w
e
should
use
instances
of
the
redex
on
the
opp
osite
side
of
the
diamond.

0
R
e
dex
F
amilies
and
Optimality
This
is
indeed
the
idea
that
w
e
will
pursue
nding
a
suitable
predicate
P
for
an
y
pair
of
reductions
starting
from
the
same
term
(see
the
pro
of
of
Theorem
..).
It
is
a
w
ell
kno
wn
result
of
rewriting
systems
that
lo
cal
conuence
implies
conuence
for
strongly
normalizable
terms
(in
literature
this
prop
ert
y
is
kno
wn
as
Newman
Lemma).
The
pro
of
is
a
simple
induction
on
the
length
of
the
longest
normalizing
deriv
ation
for
the
term.
So,
w
e
ha
v
e
the
follo
wing
corollary
.
Prop
osition
..0
(conuence)
L
et
M
b
e
a
str
ongly
normalizable
term.
If

:
M

M
0
and

:
M

M
00
,
then
ther
e
exist
N
such
that

0
:
M
0

N
and

0
:
M
00

N,
wher
e

0
=
=
and

0
=
=.
Pr
o
of
By
Newman's
Lemma
and
Lemma
..
w
e
ha
v
e
conuence,
that
is,
the
existence
of
N,

0
:
M
0

N
and

0
:
M
00

N.
An
yho
w,
since
w
e
w
an
t
to
pro
v
e
that

0
=
=
and

0
=
=,
let
us
giv
e
the
pro
of
in
full
details.
Let
us
dene
a
measure
depth
(

)
on
terms,
suc
h
that
depth
(T
)
is
the
length
of
the
longest
reduction
of
T
.
The
pro
of
is
b
y
induction
on
depth
(M).
(i)
depth
(M)
=
0.
M
is
in
normal
form.
Hence,

=

=

and

0
=

0
=

(ii)
The
cases

=

or

=

are
trivial,
since
w
e
immediately
see
that

0
=

and

0
=
.
Hence,
let
us
assume

=
M
0
R
!
P
0

0

M
0
and

=
M
0
S
!
P
00

0

M
00
.
By
Lemma
..,
there
exists
Q
suc
h
that
S=R
:
T
0

Q
and
R=S
:
T
00

Q.
By
denition,
depth
(T
0
);
depth
(T
00
)
<
depth
(M).
Hence,
b
y
induction
h
yp
othe-
sis,
there
are
Q
0
and
Q
00
suc
h
that

0
=(S=R)
:
Q

Q
0
,

0
=(R=S)
:
Q

M
0
,
(S=R)=
0
:
M
0

Q
0
and
(R=S)=
0
:
M
00

Q
00
.
Fi-
nally
,
since
depth
(Q)

depth
(T
0
)
and
depth
(Q)

depth
(T
00
),
b
y
induction
h
yp
othesis
w
e
ha
v
e
that
(
0
=(R=S))=(
0
=(S=R))
:
Q
0

N
and
(
0
=(S=R))=(
0
=(R=S))
:
Q
00

N,
for
some
N.
It
is
no
w
an
easy
exercise
to
v
erify
that
R
0
((S=R)=
0
)((
0
=(R=S))=(
0
=(S=R)))
=
=
and
that
S
0
((R=S)=
0
)((
0
=(S=R))=(
0
=(R=S)))
=
=.
Exercise
..
V
erify
the
last
t
w
o
equiv
alences
in
the
pro
of
of
The-
orem
..0.
Moreo
v
er,
w
e
in
vite
the
reader
to
dra
w
the
reduction
dia-
gram
corresp
onding
to
the
previous
pro
of.

.
L
ab
eling

Exercise
..
W
e
in
vite
the
reader
to
reect
on
wh
y
the
strong
nor-
malization
h
yp
othesis
is
mandatory
in
Newman
Lemma.
Then,
w
e
in
vite
him
to
pro
v
e
that
the
follo
wing
rewriting
system
a
!
b
b
!
a
a
!
c
b
!
d
(o
v
er
the
set
of
sym
b
olsa
fa;
b;
c;
dg)
is
not
conuen
t,
although
it
is
lo
cally
conuen
t.
Let
us
no
w
pro
v
e
standardization
for
strongly
normalizable
terms.
The
denition
of
standard
and
normal
(leftmost-outermost)
deriv
ations
are
as
usual:

A
reduction
M
0
R

!
M

R

!



R
k
!
M
k
R
k+
!



is
standar
d
when
for
an
y
i;
j
suc
h
that


i

j,
the
redex
R
j
is
not
residual
of
a
redex
in
M
i-
to
the
left
of
R
i
.

A
reduction
M
0
R

!
M

R

!



R
k
!
M
k
R
k+
!



is
normal
(or
leftmost-
outermost)
when
for
an
y
i


the
redex
R
i
is
the
leftmost
redex
in
M
i
.
In
the
follo
wing,
w
e
shall
resp
ectiv
ely
use
M
st

N
and
M
no
rm

N
to
denote
standard
and
normal
reductions.
It
is
immediate
that
an
y
normal
reduction
is
also
standard
and
that
normal
reduction
is
uniquely
determined.
Namely
,
if

:
M
no
rm

N
and

0
:
M
no
rm

N
0
,
then

is
a
prex
of

0
,
or
vice
v
ersa.
Denition
..
The
function
Abs
is
dened
as
follo
ws:
(i)
Abs((x:M)

)
=
(x:M)

(ii)
Abs(M
N)

)
=
Abs(

P
[

N=x])
if
Abs(M)
=
(x:P
)

So,
Abs(M)
is
the
rst
abstraction
obtained
b
y
normal
reduction
of
M.
Ob
viously
,
Abs
is
not
alw
a
ys
dened.
Example
..
V
ariables
are
trivial
examples
of
terms
for
whic
h
Abs
is
undened.
Nev
ertheless,
for
some
terms
the
reason
for
whic
h
Abs
is
undened
are
more
deep.
F
or
instance,
let
us
tak
e
again
(
).
Since,
(
)
!
(
)
is
the
only
con
traction
of
(
),
w
e
can
nev
er
obtain
an
abstraction
along
its
reduction.
Lemma
..
Every
standar
d
r
e
duction
M
st

(x:N)

c
an
b
e
de
c
om-
p
ose
d
in
the
fol
lowing
way:
M
no
rm

Abs(M)

(x:N)



R
e
dex
F
amilies
and
Optimality
Pr
o
of
T
rivial.
Prop
osition
..
L
et
M
b
e
str
ongly
normalizable.
F
or
any

:
M

N,
ther
e
exists
a
c
orr
esp
onding
standar
d
r
e
duction

:
M
st

N,
such
that


.
Pr
o
of
Let
us
call
depth
(M)
the
length
of
the
longest
normalizing
deriv
a-
tion
for
M.
The
pro
of
is
b
y
double
induction
o
v
er
depth
(M)
and
the
structure
of
M.
If
depth
(M)
=
0
the
result
is
trivial.
If
depth
(M)
>
0,
w
e
pro
ceed
instead
b
y
structural
induction
on
M:
(i)
M
=
x

.
This
case
is
v
acuous.
(ii)
M
=
(x:M

)

.
Then,
N
=
(x:N

)

,
and
M


N

.
F
urther-
more,
M

is
a
subterm
of
M
and
depth
(M

)
=
depth
(M).
So,
b
y
induction
h
yp
othesis,
M

st

N

,
and
M
st

N.
(iii)
M
=
(M

M

)

.
Let
us
distinguish
t
w
o
sub
cases:
(a)
N
=
(N

N

)

,
and
the
reduction
M

N
is
comp
osed
of
t
w
o
separate
reductions
in
ternal
to
M

and
M

.
Then,
b
y
induction
h
yp
othesis,
M

st

N

,
M

st

N

,
and
M
=
(M

M

)

st

(N

M

)

st

(N

N

)

=
N.
(b)
The
reduction
M

N
can
b
e
decomp
osed
in
the
fol-
lo
wing
w
a
y:
M
=
(M

M

)


((x:N

)

M

)

!


N

[

N

=x]

N,
where
M


N

and
M


(x:N

)

.
By
induction
h
yp
othesis,
M

st

(x:N

)

,
and
b
y
Lemma
..,
M

no
rm

(x:M

)
st

(x:N

)

,
where
Abs(M

)
=
(x:M

)

.
So,
M


N

.
More-
o
v
er,
M


N

,
and
b
y
Lemma
..
and
Lemma
..,


M

[

M

=x]



N

[

N

=x].
Summing
up,
M
=
(M

M

)

no
rm

((x:M

)

M

)

!


M

[

M

=x]



N

[

N

=x]

N
Let
us
no
w
note
that
depth
(

M

[
M

=x])
<
depth
(M).
So,
b
y
induction
h
yp
othesis
there
exists
M

[
M

=x]
st

N.
So,
w
e
nally
ha
v
e
the
standard
reduction:
M
=
(M

M

)

no
rm

((x:M

)

M

)

!


M

[

M

=x]
st

N:

.
L
ab
eling

W
e
lea
v
e
as
an
exercise
to
the
reader
to
v
erify
that
the
reduction

built
in
the
pro
of
and

are
equiv
alen
t
b
y
p
erm
utation.
Remark
..
Prop
osition
..0
and
Prop
osition
..
hold
for
ev-
ery
c
hoice
of
the
predicate
P
.
In
particular,
assuming
the
usual
notion
of
-reduction,
they
hold
for
an
y
subset
of
-terms
that
is
strongly
normalizable|for
instance,
strong
normalization
migh
t
b
e
obtained
re-
stricting
our
atten
tion
to
terms
t
ypable
according
to
a
suitable
t
yping
discipline.
An
yho
w,
w
e
w
an
t
to
pro
v
e
conuence
and
standardization
for
any
-term.
So,
the
strategy
m
ust
b
e
to
restrict
-reduction,
eliminat-
ing
those
reductions
that
cause
non-termination.
A
t
the
same
time,
w
e
w
an
t
that
the
reductions
in
v
olv
ed
in
the
theorem
remain
legal.
Hence,
next
step
is
to
nd
some
sucien
t
conditions
on
P
suc
h
that
all
terms
of
lab
eled
-calculus
b
ecome
strongly
normalizable.
Let
us
start
in
tro
ducing
some
notation
and
denitions.
Notation
..
W
e
shall
use
`(M)
to
denote
the
external
lab
el
of
a
lab
eled
-term.
In
particular,
`(x

)
=
`((M
N)

)
=
`((x:M)

)
=
.
Denition
..	
The
heigh
t
h()
of
a
lab
el

is
the
maxima
l
nesting
depth
of
o
v
erlinings
and
underlinings
in
it.
F
ormally:
(i)
h(a)
=
0,
when
a
is
an
atomic
lab
el;
(ii)
h()
=
max
fh();
h()g;
(iii)
h()
=
h()
=

+
h().
Denition
..0
W
e
sa
y
that
the
predicate
P
has
an
upp
er
b
ound,
if
the
set
fh()
j
P
()g
has
an
upp
er
b
ound.
Lemma
..
If
M

M
0
,
then
h(`(M))

h(`(M
0
)).
Pr
o
of
Ob
vious.
Lemma
..
L
et
T
=
(:
:
:
((M
N

)


N

)


:
:
:
N
n
)

n
.
If
T

(x:N)

,
then
h(`(M))

h().
Pr
o
of
By
induction
on
n.
When
n
=
0,
the
result
follo
ws
b
y
the
previous
lemma.
When
n
>
0,
w
e
m
ust
ha
v
e:

(:
:
:
((M
N

)


N

)


:
:
:
N
n-
)

n-

(y:P
)


N
n

N
0
n


R
e
dex
F
amilies
and
Optimality

((y:P
)

N
0
n
)



n


P
[

N
0
n
]

(x:N)

So,
b
y
induction
h
yp
othesis,
h()
<
h()

h(`(
n


P
[

N
0
n
]))

h():
Lemma
..
A
ny
standar
d
r
e
duction
M[N=x]
st

(y:P
)

c
an
b
e
de-
c
omp
ose
d
in
one
of
the
fol
lowing
two
ways:
(i)
M

(y:M
0
)

and
M
0
[N=x]

P
.
(ii)
M

M
0
=
(:
:
:
((x
M

)


M

)


:
:
:
M
n
)

n
and
M
0
[N=x]

(y:P
)

.
Pr
o
of
By
induction
on
the
length
l
of
M[N=x]
st

(y:P
)

.
(i)
l
=
0.
Then
M[N=x]
=
(y:P
)

.
This
means
that
either
M
=
(y:M
0
)

,
and
M
0
[N=x]
=
P
,
or
M
=
x

and
x

[N=x]
=
(y:P
)

.
(ii)
l
>
0.
W
e
shall
distinguish
sev
eral
sub
cases,
according
to
the
structure
of
the
term
M.
(a)
If
M
=
(y:M
0
)

,
then
M[N=x]
=
(y:M
0
[N=x])

.
So,

=

and
M
0
[N=x]

P
.
(b)
If
M
=
(:
:
:
((y
M

)


M

)


:
:
:
M
n
)

n
,
then
x
=
y,
since
otherwise
M[N=x]
could
not
reduce
to
a
lam
b
da
ab-
straction.
So,
M
=
M
0
and
M
0
[N=x]

(y:P
)

.
(c)
If
M
=
(:
:
:
((((y:A)

B)

M

)


M

)


:
:
:
M
n
)

n
,
then
the
redex
((y:A)

B)

m
ust
b
e
con
tracted
along
the
stan-
dard
reduction
M[N=x]
st

(y:P
)

,
otherwise
w
e
could
not
get
an
abstraction
as
the
result
of
this
reduction.
More-
o
v
er,
since
((y:A)

B)

is
the
leftmost
redex
in
M,
it
is
the
rst
redex
con
tracted
in
M[N=x]
st

(y:P
)

.
Hence,
let
Q
=
(:
:
:
(((

A[

B=y])
M

)


M

)


:
:
:
M
n
)

n
.
W
e
ha
v
e
Q[N=x]
st

(y:P
)

.
But
the
length
of
this
deriv
a-
tion
is
l
-
,
so
w
e
can
apply
the
induction
h
yp
othesis.
Since
M
!
Q,
w
e
conclude.
Lemma
..
If
P
has
an
upp
er
b
ound,
and
the
terms
M;
N
ar
e
str
ongly
normalizing,
then
also
M[N=x]
is
str
ongly
normalizing.

.
L
ab
eling

Pr
o
of
(W
e
shall
abbreviate
strongly
normalizable
in
s.n.)
Let
m
b
e
the
upp
er
b
ound
for
the
predicate
P
;
depth
(M)
b
e
the
length
of
the
longest
normalizing
deriv
ation
of
M;
j
jMj
j
b
e
the
structural
size
of
M
(dened
in
the
ob
vious
w
a
y).
The
pro
of
is
b
y
induction
on
the
triple
m
-
h(`(N));
depth
(M);
j
jMj
j
.
(b
ase
c
ase
)
By
h
yp
othesis,
M
=
y

.
Then,
w
e
ha
v
e
t
w
o
p
ossibilities:
(i
)
y
=
x,
in
whic
h
case
M[N=x]
=
y

is
trivially
s.n.;
(ii
)
x
=
y,
in
whic
h
case,
M[N=x]
=


N
is
s.n.,
for
N
is
s.n.
(inductive
c
ase
)
Let
us
classify
sub
cases
according
to
the
size
of
M:
(i)
M
=
y

.
Similar
to
the
base
case.
In
fact,
pro
ving
it
w
e
did
nev
er
use
the
h
yp
othesis
m
-
h(`(N))
=
0.
(ii)
M
=
(y:M

)

.
Then
M[N=x]
=
(y:M

[N=x])

.
Ob
viously
,
M

is
s.n.,
depth
(M

)

depth
(M)
and
j
jM

j
j
<
j
jMj
j.
So,
b
y
induction
h
yp
othesis,
M

[N=x]
is
s.n.
Th
us,
M[N=x]
is
s.n.
(iii)
M
=
(M

M

)

.
Then
M[N=x]
=
(M

[N=x]
M

[N=x])

.
Since
depth
(M

)

depth
(M)
and
j
jM

j
j
<
j
jMj
j,
M

[N=x]
is
s.n.
b
y
induction
h
yp
othesis.
Similarly
for
M

[N=x].
No
w,
t
w
o
sub
cases
are
p
ossible:
(a)
M

[N=x]
nev
er
reduces
to
a
lam
b
da
abstraction.
In
this
case
the
reduction
of
M[N=x]
is
the
comp
osition
of
t
w
o
indep
enden
t
reductions:
a
reduction
of
M

[N=x]
and
a
reduction
of
M

[N=x].
So,
M[N=x]
is
s.n.
since
M

[N=x]
and
M

[N=x]
are.
(b)
M

[N=x]

(y:P
)

.
The
case
in
whic
h
P
()
is
false
is
similar
to
the
previous
one.
Then,
let
us
assume
that
P
()
is
true.
In
this
case,
M[N=x]
=
(M

[N=x]
M

[N=x])


((y:P
)

M

[N=x])

;
furthermore,


P
[

M

[N=x]=y]
is
s.n.
Since
M

[N=x]
is
s.n.,
w
e
can
apply
the
standard-
ization
prop
ert
y
of
Prop
osition
..,
getting
a
standard
deriv
ation
M

[N=x]
st

(y:P
)

.
Then,
b
y
Lemma
..,
w
e
ha
v
e
the
follo
wing
cases:
.
M


(y:M

)

and
M

[N=x]

P
.
Since
the
term
M
=
(M

M

)

is
s.n.,
also
M
0
=


M

[

M

=y]
is
s.n.
Moreo
v
er,
as
M
0
[N=x]
=


M

[N=x][

M

[N=x]=y],
b
y
Lemma
..
and
Lemma
..,
w
e
ha
v
e
M
0
[N=x]


P
[
M

[N=x]=y].
Since
M

M
0
,
h(`(M))

h(`(M
0
)),
and
depth
(M
0
)
<
depth
(M
0
),
w
e
can
apply
induction
h
yp
othesis.
That
is,
M
0
[N=x]
is
s.n.,
as
w
ell
as


P
[

M

[N=x]=y].


R
e
dex
F
amilies
and
Optimality
.
M


M
0

=
(:
:
:
((x

A

)


A

)


:
:
:
A
n
)

n
for
some
M
0

suc
h
that
M
0

[N=x]

(y:P
)

.
Since
M

[N=x]
is
s.n.,
also
P
is
s.n.
Moreo
v
er:
M
0

[N=x]
=
(:
:
:
((N)
A

[N=x])


:
:
:
A
n
[N=x])

n
:
By
Lemma
..,
h(`(

N))

h().
So,
w
e
ha
v
e:
h(`(N))

h(`(N))

h()
<
h()

h(`(M

[N=x]))
Then,
b
y
induction
h
yp
othesis,
P
[
M

[N=x]=y]
is
s.n.
Prop
osition
..
If
P
has
an
upp
er
b
ound,
then
every
term
M
is
str
ongly
normalizable.
Pr
o
of
By
structural
induction
on
M.
(i)
M
=
x

.
T
rivial.
(ii)
M
=
(y:M

)

.
M

is
strongly
normalizing
b
y
induction
h
y-
p
othesis,
and
so
is
M.
(iii)
M
=
(M

M

)

.
By
induction
h
yp
othesis,
M

and
M

are
strongly
normalizing.
If
M

do
es
nev
er
reduce
to
a
lam
b
da
abstraction
the
result
is
ob
vious.
Otherwise,
supp
ose
M


(x:M

)

;
w
e
m
ust
pro
v
e
that


M

[

M

=x]
is
strongly
normalizing.
Since
M

and
M

are
strongly
normalizing,
so
are


M

and


M

.
Th
us,
b
y
Lemma
..
w
e
conclude.
Theorem
..
(Ch
urc
h-Rosser
)
If

:
M

N
and

:
M

P
,
then
ther
e
exists
a
term
Q
such
that
N

Q
and
P

Q.
Pr
o
of
Let

:
M
=
M
0
R

!
M

R

!
:
:
:
R
n
!
M
n
=
N
and

:
M
=
M
0
S

!
P

S

!
:
:
:
S
m
!
P
m
=
P
.
Let
P

and
P

b
e
the
predicates
dened
in
the
follo
wing
w
a
y:
(i)
P

()
if
and
only
if
	i;


i

n;

=
degree
(R
i
);
(ii)
P

()
if
and
only
if
	j;


j

m;

=
degree
(S
j
).
Let
P
=
P

S
P

.
Ob
viously
,
P
has
an
upp
er
b
ound,
and
since
the
t
w
o
reductions

and

are
legal
for
P
,
M
is
strongly
normalizable
(with
resp
ect
to
P).
Then,
b
y
Prop
osition
..0,
w
e
conclude.

.
L
ab
eling

Theorem
..
(standardizati
on
)
If
M

N,
then
M
st

N.
Pr
o
of
Similar
to
the
previous
one,
using
Prop
osition
..
in
the
place
of
Prop
osition
..0.
Exercise
..
(Dicult)
Pro
v
e
that
if

:
M

N
and

:
M

P
,
then
there
exists
a
term
Q
suc
h
that
=
:
N

Q
and
=
:
P

Q.
Exercise
..	
(Dicult)
Pro
v
e
that
if

:
M

N,
then
there
ex-
ists
a
standard
reduction

s
:
N
st

Q
suc
h
that



s
.
Remark
..0
In
the
pro
v
e
of
Ch
urc
h-Rosser
prop
ert
y
(Theorem
..)
w
e
ha
v
e
not
explicitly
seen
as
closing
reduction
are
done.
An
yho
w,
the
previous
exercise
sho
ws
that,
similarly
to
what
done
pro
ving
lo
cal
con-
uence,
the
diamond
is
closed
b
y
the
image
of
the
reduction
on
the
opp
osite
side.
F
urthermore,
let
us
note
that
this
prop
ert
y
is
in
some
sense
enco
ded
in
to
the
pro
of
of
Theorem
..:
the
predicate
P
that
w
e
c
ho
ose
is
exactly
the
one
that
enables
families
that
w
ere
presen
t
in
the
initial
reductions

and
.
..
L
ab
ele
d
and
unlab
ele
d
-c
alculus
W
e
shall
no
w
pro
v
e
one
of
the
most
in
teresting
results
of
the
lab
eled
-calculus.
As
w
e
already
noted
studying
families,
in
the
unlab
eled
case
there
are
pairs
of
reductions
starting
and
ending
with
the
same
pair
of
terms
that
cannot
b
e
considered
equiv
alen
t
(remind
the
example
(I
(I
x))).
W
e
already
p
oin
ted
out
with
an
example
that
this
is
not
the
case
in
the
lab
eled
calculus.
In
this
section
w
e
will
pro
v
e
that
this
is
a
general
prop
ert
y
of
lab
eled
-calculus.
In
fact,
w
e
will
see
that
giv
en
t
w
o
terms
M
and
N
suc
h
that
M

N,
then
there
is
a
unique
standard
reduction
M
st

N.
Denition
..
Giv
en
a
lab
eled
term
M,
w
e
call

-
(M)
the
corre-
sp
onding
unlab
eled
term
obtained
b
y
erasing
all
lab
els.
F
ormally:
(i)

-
(x

)
=
x
(ii)

-
((x:M)

)
=
x:
-
(M)
(iii)

-
((M
N)

)
=
(
-
(M)

-
(N))
W
e
shall
no
w
in
tro
duce
a
new
measure
for
lab
els
that
will
b
ecome
useful
in
pro
ving
the
next
prop
osition.


R
e
dex
F
amilies
and
Optimality
Denition
..
The
size
j
jj
j
of
a
lab
el

is
the
sum
of
the
total
n
um
b
er
of
letters,
o
v
erlinings
and
underlinings
in
.
F
ormally:
(i)
j
jaj
j
=

if
a
is
an
atomic
lab
el;
(ii)
j
jj
j
=
j
jj
j
+
j
jj
j;
(iii)
j
jj
j
=
j
jj
j
=
j
jj
j
+
.
Lemma
..
If
M

M
0
,
then
j
j`(M)j
j

j
j`(M
0
)j
j.
Pr
o
of
Immedia
te.
Prop
osition
..
F
or
every
p
air
of
lab
ele
d
terms
U;
V
such
that
U

V
,
ther
e
exists
exactly
one
standar
d
r
e
duction
U
st

V
.
Pr
o
of
If
U

V
,
b
y
the
standardization
theorem
there
exists
at
least
one
standard
reduction

:
U

V
.
W
e
m
ust
pro
v
e
that
this
is
unique.
The
pro
of
is
b
y
induction
on
the
length
l
of

and
the
structure
of
U.
(b
ase
c
ase
)
U
=
V
=
x

.
Then
the
only
standard
reduction
is
the
empt
y
one.
(inductive
c
ase
)
(i)
U
=
x

.
This
case
has
b
een
already
considered.
(ii)
U
=
(x:U

)

.
Then
V
=
(x:V

)

and
U

st

V

with
a
standard
reduction

0
of
length
l.
By
induction
h
yp
othesis

0
is
unique,
and
so
is
.
(iii)
U
=
(U

U

)

.

m
ust
b
e
either
of
the
kind
U
=
(U

U

)

st

(V

U

)
st

(V

V

)

=
V
or
U
=
(U

U

)

no
rm

((x:U

)

U

)
!


U

[

U

=x]
st

V
where
(x:U

)

=
Abs(U

).
W
e
pro
v
e
rst
that,
in
the
lab
eled
system,
al
l
standard
reductions
b
et
w
een
U
and
V
are
of
a
same
kind.
Indeed,
supp
ose
w
e
migh
t
ha
v
e
t
w
o
standard
reductions

and

of
dieren
t
kinds.
If

w
ould
b
e
of
the
rst
kind
ab
o
v
e,
w
e
w
ould
also
ha
v
e
`(V
)
=

=
`(U).
On
the
other
side,
if

w
ould
b
e
of
the
second
kind,
b
y
Lemma
..,
w
e
w
ould
ha
v
e
j
j`(U)j
j
=
j
jj
j
<
j
j`(

U

[

U

=x])j
j

j
j`(V
)j
j
and
th
us
`(U)
=
`(V
).

.
L
ab
eling
	
Coming
bac
k
to
the
pro
of
of
the
prop
osition,
w
e
can
th
us
distin-
guish
t
w
o
sub
cases,
according
to
the
kind
of
the
standard
reduc-
tion
.
(a)
if

is
of
the
rst
kind,
the
result
follo
ws
b
y
induction,
since
the
standard
reductions
U

st

V

and
U

st

V

are
unique.
(b)
If

is
of
the
second
kind,
ev
ery
other
standard
reduc-
tion
m
ust
b
e
of
the
same
kind.
Since
the
initial
part
of
the
deriv
ation
is
normal,
this
m
ust
b
e
common
to
ev
ery
suc
h
reduction.
Since,
b
y
induction
on
the
length
of
the
deriv
ation,
there
exists
a
unique
standard
reduction
from


U

[

U

=x]
to
V
,

is
unique
to
o.
Note
that
the
previous
prop
osition
do
es
not
hold
in
the
(unlab
eled)
-calculus
(tak
e
for
instance
U
=
(I(I
x))
and
V
=
(I
x)).
W
e
also
in
vite
the
reader
to
not
confuse
the
previous
prop
ert
y
with
the
one
that
Theo-
rem
..
induces
on
the
unlab
eled
-calculus.
In
fact,
in
the
unlab
eled
calculus
w
e
can
still
sa
y
that
giv
en
a
reduction

:
M

N,
there
is
a
unique
standard
reduction

s
:
M
st

N
equiv
alen
t
to
it
(see
also
Ex-
ercise
..	).
Nev
ertheless,
t
w
o
non-equiv
alen
t
reductions
connecting
the
same
pair
of
terms
lead
to
t
w
o
distinct
standard
reduction.
This
is
no
more
true
in
the
lab
eled
calculus
where
t
w
o
reductions
are
equiv
a-
len
t
if
and
only
if
connect
the
same
pair
of
terms
(see
next
theorem).
In
a
sense,
the
lab
eled
-calculus
do
es
not
make
syntactic
al
mistakes
iden
tifying
terms
coming
from
\dieren
t"
deriv
ations.
This
in
tuition
is
formalized
b
y
the
follo
wing
theorem.
Theorem
..
L
et
U
b
e
a
lab
ele
d
-term
with
M
=

-
(U).
L
et

:
M

N
and

:
M

P
.
Consider
the
lab
ele
d
r
e
ductions


:
U

V
and


:
U

W
r
esp
e
ctively
isomorphic
to

and
.
Then:
(i)



if
and
only
if
V
=
W
(ii)

v

if
and
only
if
V

W
.
Pr
o
of
(i)
Let

0

and

0

b
e
the
standard
reductions
corresp
onding
to


and


,
resp
ectiv
ely
.
Then,



if
and
only
if





if
and
only
if

0

=

0

.
But
for
the
previous
prop
osition,

0

=

0

if
and
only
if
V
=
W
.

0
R
e
dex
F
amilies
and
Optimality
(ii)
By
denition,

v

if
and
only
if
there
exists

suc
h
that


.
Let


:
V

T
b
e
the
lab
eled
reduction
isomorphic
to
.
By
the
previous
item,



if
and
only
if
T
=
W
.
So,

v

if
and
only
if
V

W
.
..
L
ab
eling
and
families
Prop
osition
..
If
M

N
in
the
lab
ele
d
lamb
da
c
alculus,
and
S
is
a
r
e
dex
in
M,
then
al
l
r
esiduals
of
S
in
N
have
the
same
de
gr
e
e
of
S.
Pr
o
of
Let
us
start
with
the
case
M
R
!
N.
Let
R
=
((x:A)

B)

and
S
=
((y:C)

D)

.
The
pro
of
is
b
y
cases,
according
to
the
m
utual
p
ositions
of
R
and
S
in
M.
(i)
R
and
S
are
disjoin
t.
T
rivial.
(ii)
If
S
con
tains
R
in
C
(resp
ectiv
ely
D),
then
the
(unique)
residual
of
S
in
N
is
of
the
form
((y:C
0
)

D)

(resp
ectiv
ely
((y:C)

D
0
)

,
whic
h
has
the
same
degree
of
S.
(iii)
If
R
con
tains
S
in
A,
then
S
has
a
unique
residual
in
N
of
the
form
((y:C[

B=x])

D[

B=x])

0
,
where
only
the
external
lab
el

can
b
e
mo
died
in
to

0
(this
happ
ens
when
A
=
((y:C)

D)

).
(iv)
If
R
con
tains
S
in
B,
then
all
residuals
of
the
redex
S
in
N
are
of
the
form
((y:C)

D)

0
,
where
only
the
external
lab
el

can
b
e
mo
died
in
to

0
(this
happ
ens
when
B
=
((y:C)

D)

).
Exercise
..
Reform
ulate
the
pro
of
of
the
previous
prop
osition
in
terms
of
lab
eled
syn
tax
trees.
Note
in
particular
that
the
four
cases
in
the
pro
of
corresp
ond
in
order
to:
(i
)
the
edge
of
the
redexes
app
ear
in
disjoin
t
subtrees;
(ii
)
the
edge
of
R
is
in
the
subtree
of
the
application
corresp
onding
to
S;
(iii
)
the
edge
of
S
is
in
the
b
o
dy
of
the
abstraction
of
R;
(iv
)
the
edge
of
S
is
in
the
subtree
of
the
argumen
t
of
R.
In
particular,
note
that
the
last
one
is
the
only
case
in
whic
h
the
edge
of
R
is
duplicated.
Prop
osition
..
If
M
R
!
N
and
S
is
a
r
e
dex
in
N
cr
e
ate
d
by
R
then
j
jdegree
(R)j
j
<
j
jdegree
(S)j
j.
Pr
o
of
Let
R
=
((x:A)

B)

.
Three
cases
are
p
ossible:

.
L
ab
eling

Upwar
d
cr
e
ation.
In
M
there
is
a
subterm
of
the
form
(((x:A)

B)

D)

where
A
=
(y:C)

.
Then,
S
=
((

A[

B=x])
D)

=
((y:C[

B=x])

D)

and
j
jj
j
<
j
j
j
j.
Downwar
d
cr
e
ation.
In
A
there
is
a
subterm
of
the
form
((x)

D)

and
B
=
(y:C)

.
Then,
S
=
((x)

D)

[

(y:C)

=x]
=
((y:C)

D)

,
and
j
jj
j
<
j
jj
j.
Identity.
This
is
a
com
bination
of
the
t
w
o
previous
cases.
Namely
,
w
e
ha
v
e
a
subterm
in
M
of
the
form
(((x:A)

B)

D)

where
A
=
x

and
B
=
(y:C)

.
Then,
S
=
((

A[

B=x])
D)

=
((y:C)



D)

and
j
jj
j
<
j
j
j
j.
Denition
..	
(INIT
)
W
e
shall
sa
y
that
the
predicate
INIT(M)
is
v
eried
b
y
a
lab
eled
term
M
if
and
only
if
the
lab
els
of
all
subterms
of
M
are
atomic
and
pairwise
distinct.
Prop
osition
..0
L
et
M
b
e
a
term
such
that
INIT(M)
holds.
F
or
any
r
e
duction
M

N,
a
r
e
dex
S
in
N
is
a
r
esidual
of
a
r
e
dex
R
in
M
if
and
only
if
they
have
the
same
de
gr
e
e.
Pr
o
of
The
only
if
direction
is
Prop
osition
...
F
or
the
if
direction,
w
e
pro
ceed
b
y
induction
on
the
length
l
of
the
reduction
M

N.
If
l
=
0,
the
result
follo
ws
b
y
the
conditions
imp
osed
b
y
INIT
(M).
If
l
>
0,
let
M

N
0
P
!
N.
By
h
yp
othesis,
there
exists
a
redex
R
in
M
with
the
same
degree
of
S.
Since,
b
y
INIT
(M),
all
redexes
in
M
ha
v
e
atomic
degree,
the
degree
of
S
m
ust
b
e
atomic
to
o.
This
means
that
S
cannot
b
e
created
b
y
the
ring
of
P
,
since
otherwise
j
jdegree
(S)
>
j
j.
So,
S
m
ust
b
e
the
residual
of
a
redex
S
0
in
M
0
with
the
same
degree
of
R.
By
induction
h
yp
othesis
S
0
is
a
residual
of
R,
and
so
is
S.
Theorem
..
L
et
R
and
S
b
e
two
r
e
dexes
with
histories

:
M

N
and

:
M

P
.
L
et
us
take
the
c
orr
esp
onding
isomorphic
r
e
ductions


:
U

V
and


:
U

W
in
the
lab
ele
d
system
(the
initial
lab
eling
of
U
c
an
b
e
arbitr
ary).
If
R
'
S,
then
R
and
S
have
the
same
de
gr
e
e
(in
V
and
W
,
r
esp
e
ctively).
Pr
o
of
This
is
an
easy
corollary
of
Theorem
..
and
Prop
osition
...


R
e
dex
F
amilies
and
Optimality
Let
us
remark
again
that
the
previous
theorem
holds
for
an
y
lab
eling
of
the
initial
term
M.
According
to
the
in
tended
in
terpretation
of
lab
eling
as
the
name
asso
ciated
to
all
the
edges
with
a
same
origin,
the
previous
theorem
states
that
this
in
terpretation
is
sound.
In
fact,
all
redexes
in
the
same
family
with
resp
ect
to
a
giv
en
initial
term
are
mark
ed
b
y
the
same
lab
el.
F
urthermore,
the
indep
endence
from
initial
lab
eling
state
that
to
equate
ob
jects
in
the
initial
term
do
es
not
create
troubles.
F
or
instance,
the
term
migh
t
b
e
the
result
of
a
previous
computation
and
according
to
this
lab
els
migh
t
denote
sharabilit
y
of
some
ob
jects.
More
tec
hnically
,
this
comp
ositionalit
y
o
d
the
prop
ert
y
is
w
a
y
it
can
b
e
pro
v
ed
inductiv
ely
on
the
length
of
the
deriv
ation.
In
Chapter

w
e
shall
pro
v
e
the
con
v
erse
of
Theorem
..,
but
under
the
(essen
tial)
assumption
that
INIT(U)
holds.
In
fact,
according
to
the
idea
that
all
redexes
in
the
initial
term
are
in
dieren
t
families
and
then
unsharable,
all
the
edges
of
the
initial
term
m
ust
b
e
mark
ed
with
dieren
t
(atomic)
lab
els|it
other
w
ords,
the
initial
term
is
not
the
result
of
some
previous
computation
or
equiv
alen
tly
,
w
e
do
not
its
history
.
Under
this
assumption,
w
e
will
b
e
able
to
pro
v
e
that
t
w
o
redexes
are
in
the
same
family
only
if
they
ha
v
e
the
same
degree.
Let
us
note
that
Prop
osition
..0
is
not
enough
to
get
this
equiv
alence
b
et
w
een
the
equiv
alence
families
and
degree.
In
fact,
Prop
osition
..0
pro
v
es
the
result
in
the
case
of
atomic
lab
els,
but
do
es
not
allo
w
to
immedia
tely
extend
it
to
the
case
of
comp
osite
degrees.
Let
us
compare
this
with
the
situation
in
extraction
relation.
Also
in
that
case
it
is
immediate
to
pro
v
e
that
when
a
redex
R
has
an
ancestor
S
in
the
initial
term,
then
S
is
the
canonical
represen
tativ
e
of
R
plus
its
history
(see
Lemma
..).
The
dicult
part
in
pro
ving
uniqueness
of
a
canonical
represen
tativ
e
is
when
the
redex
is
created
along
the
reduction
(see
the
rest
of
section
.).
In
the
lab
eled
case,
the
dicult
part
will
b
e
to
sho
w
the
uniqueness
of
this
canonical
represen
tativ
e
in
terms
of
lab
els,
i.e.,
that
t
w
o
canonical
represen
tativ
es
for
extraction
cannot
ha
v
e
the
same
degree.
.
Reduction
b
y
families
In
this
section
w
e
aim
at
nding
the
syn
tactic
coun
terpart
of
an
ev
aluator
nev
er
duplicating
redexes,
according
to
notion
of
duplication
induced
b
y
family
relation
(i.e.,
the
zig-zag
relation
dened
in
Section
.).
T
o
this
aim
w
e
in
tro
duce
a
strategy
of
deriv
ation
b
y
famili
es,
a
parallel
reduction
in
whic
h
at
eac
h
step
sev
eral
redexes
in
the
same
family
can
b
e
reduced
in
parallel.
The
idea
is
that
reducing
at
once
all
the
redexes

.
R
e
duction
by
families

in
a
giv
en
families,
in
the
future,
w
e
cannot
ev
aluate
an
y
redex
in
this
family
.
In
fact,
once
a
family
has
b
een
completely
erased
from
a
term,
it
is
imp
ossible
it
can
reapp
ear
along
the
reduction
(let
us
note
that
this
follo
ws
from
the
in
terp
olation
prop
ert
y
of
Lemma
..).
In
order
to
formalize
these
deriv
ations,
w
e
foremost
generalize
the
nite
dev
elopmen
t
theorem.
Denition
..
Let
[R]
=
fS
j
S
'
Rg
b
e
the
family
class
of
R.
Let

=
F




F
n
.
Then,
F
AM
()
=
f[F




F
i
R]
j
R

F
i+
;
i
=
0;
;
:
:
:
;
n
-
g
is
the
set
of
family
classes
con
tained
in
.
Denition
..
(dev
elopmen
t
of
family
classes)
Let
X
b
e
a
set
of
family
classes.
A
deriv
ation

is
r
elative
to
X
if
F
AM
()

X.
A
deriv
ation

is
a
development
of
X
if
there
is
no
redex
R
suc
h
that
[R]

X
.
Theorem
..
(generalized
nite
dev
elopmen
ts
)
L
et
X
b
e
a
(-
nite)
set
of
family
classes.
Then:
(i)
Ther
e
is
no
innite
derivation
r
elative
to
X
.
(ii)
If

and

ar
e
two
developments
of
X
then,


.
Pr
o
of
(i)
Let
X
b
e
a
nite
set
of
family
classes
with
resp
ect
to
the
ini-
tial
term
M.
Let
us
assume
that
INIT(M)
is
true.
Let
 =
fdegree
(R)
j
[R]

X
g
and
P
=
f
j
h()

max
fh()
j


 g
g.
By
Theorem
..,
an
y
family
class
has
a
unique
degree.
Hence,
 is
nite
and
P
has
an
upp
er
b
ound.
By
Prop
osition
..,
an
y
lab
eled
deriv
ation
legal
for
P
is
nite.
Since
an
y
deriv
ation
relativ
e
to
X
is
legal
for
P
,
w
e
conclude.
(ii)
Let
us
observ
e
that,
if

and

are
relativ
e
to
X
,
then

t

is
also
relativ
e
to
X
.
No
w,
b
y
denition,
if

and

are
t
w
o
dev
elopmen
ts
of
X
,
then



t

and



t
.
Th
us,



b
y
transitivit
y
.
Let
us
no
w
pro
v
e
our
claim
that,
after
the
dev
elopmen
t
of
a
set
of
families
X
,
no
redex
in
a
family
con
tained
in
X
can
b
e
created
an
ymore
along
the
reduction.
The
main
lemma
is
preceded
b
y
a
more
tec
hnical
prop
ert
y
useful
for
its
pro
of.


R
e
dex
F
amilies
and
Optimality
Lemma
..
L
et
R
b
e
the
c
anonic
al
derivation
of
S.
Then

v

if
and
only
if
R

S.
Pr
o
of
The
if
direction
follo
ws
b
y
denition
of
cop
y
relation.
Let
us
fo
cus
on
the
only-if
direction.
Let

b
e
the
standard
deriv
ation
of
.
Then
S
B
R
and

v
,
since


.
F
urthermore,
it
suces
to
pro
v
e
R

S.
W
e
pro
ceed
b
y
induction
on
jj.
If

=
0,
then
S
B
R
implies

=
0
and
R
=
S.
Th
us,
R

S.
Let

=
T

0
.
Since
b
oth

and

are
standard,
there
are
t
w
o
cases:
(i)

=
T

0
and

0
R
is
the
canonical
deriv
ation
of

0
S.
Then

v

implies

0
v

0
b
y
left
cancellation.
Therefore,
R

S
b
ecause,
b
y
induction,

0
R


0
S.
(ii)
T

0
R
0
B
R,
where

0
R
0
is
the
canonical
deriv
ation
of

0
S.
Then

0
v
=T
,
b
y
denition
of
B.
This
fact
and

v

imply
=T
v
=T
=

0
.
Therefore,

0
v
=T
v

0
and,
b
y
induction,

0
R
0


0
S.
By
the
in
terp
olation
prop
ert
y
(Lemma
..),
there
is
S
0
suc
h
that

0
R
0

(=T
)S
0


0
S.
Then,
T
(=
T
)S
0

(T

0
)S
=
S.
Moreo
v
er,
(T
=)S
0

S,
for
T
(=T)

(T
=
).
Finally
,
S

R=(T
=),
since
R
is
canonical
and
(T
=)S
0
'
R.
Th
us,
R

S.
Lemma
..
L
et

b
e
a
development
of
X
.
(i)
L
et
S
b
e
the
c
anonic
al
derivation
of
R.
Then
S

R.
(ii)
F
or
every
S
such
that

v
,
[S]

F
AM
().
Pr
o
of
(i)
By
h
yp
othesis,

is
relativ
e
to
X
.
Then

v
,
since

can
b
e
alw
a
ys
extended
to
a
dev
elopmen
t

of
X
and


,
b
y
Theorem
...
Th
us
S

R,
b
y
Lemma
...
(ii)
By
con
tradiction.
Let
S

F
AM(),

=


F


and
R

F
suc
h
that


R
'
S.
Let

0
R
0
b
e
the
canonical
deriv
ation
of


R
and
S.
By
denition,

0
is
relativ
e
to
F
AM
().
Therefore,

0
v

and,
b
y
transitivit
y
,

0
v
.
Therefore,

0
R
0

S,
b
y
Lemma
...
By
the
in
terp
olation
prop
ert
y
(Lemma
..),
there
exists
T
suc
h
that

0
R
0

T

S.
But
this
con
tradicts
this
con
tradicts
the
h
yp
othesis
that

is
a
dev
elopmen
t
of
X
,
since
under
this
h
yp
othesis

should
also
b
e
a
dev
elopmen
t
of
F
AM
().

.
R
e
duction
by
families

..
Complete
derivations
W
e
can
nally
dene
the
reductions
b
y
famili
es
w
e
are
in
terested
in.
Denition
..
(complete
deriv
ation)
A
deriv
ation
F




F
n
is
c
om-
plete
if
and
only
if
F
i
=
;
and
F
i
is
a
maxim
al
set
of
redexes
suc
h
that
R;
S

F
i
:
F




F
i-
R
'
F




F
i-
S
for
i
=
;
;
:
:
:
;
n.
The
follo
wing
lemma
sho
ws
that
complete
deriv
ations
are
particular
dev
elopmen
ts.
Lemma
..
Every
c
omplete
derivation

is
a
development
of
F
AM().
Pr
o
of
By
induction
on
jj.
The
base
case
is
ob
vious.
Let

=
F
,
where
F
is
a
maxima
l
set
of
redexes
in
the
same
family
.
Then,
b
y
inductiv
e
h
y-
p
othesis,

is
a
dev
elopmen
t
of
F
AM
().
Therefore,
b
y
Lemma
..(),
there
is
no

0
S,

v

0
,
suc
h
that
[
0
S]

F
AM
().
By
con
tradiction,
let
us
assume
that
there
exists
R
suc
h
that
R
'
S.
Namely
,
let
us
assume
that

is
not
a
dev
elopmen
t
of
F
AM
().
Let
S
0
b
e
the
canonical
deriv
ation
of
S.
Then

v

v

=
F
.
Moreo
v
er,
b
y
Lemma
..(),
S
0

R
and,
b
y
the
in
terp
olation
lemma
(Lemma
..),
there
exists
T
suc
h
that
T

R.
This
means
that
T
'
S
with
R

T
=F
,
in
v
al-
idating
the
h
yp
othesis
that
F
is
a
maxim
al
set
of
redexes
in
the
same
family
.
Complete
deriv
ations
con
tract
maximal
set
of
copies
of
a
single
redex.
When
complete
deriv
ations
are
considered,
this
means
that
deciding
if
t
w
o
redexes
are
in
the
same
family
,
ma
y
b
e
safely
reduced
to
c
hec
k
the
cop
y-relation.
Lemma
..
A
derivation

=
F




F
n
is
c
omplete
if
and
only
if,
for
i
=
;
:
:
:
;
n,
F
i
is
a
maxima
l
set
of
copies.
Namely,
for
any
i,
ther
e
exist

i
S
i
and

i
such
that

i

i


i
and
F
i
=
S=
i
.
Pr
o
of
(only-if
dir
e
ction
)
Let

b
e
a
complete
reduction
and
R
b
e
a
redex
with
history
.
Let
F
b
e
the
set
of
redexes
T
suc
h
that
R
'
T
.
Let
F
0
b
e
a
set
of
redexes
con
taining
R
and
suc
h
that
there
exist
S
and

with



and
F
0
=
S=.
W
e
shall
pro
v
e
that
F
=
F
0
.


R
e
dex
F
amilies
and
Optimality
Surely
,
F
0

F
,
b
y
denition
of
'.
By
the
completeness
of

and
Lemma
..,

is
a
dev
elopmen
t
of
F
AM
().
Let

0
R
0
b
e
the
canonical
deriv
ation
of
R.
Then

0
R
0

R,
b
y
Lemma
..().
Therefore,
for
ev
ery
S

F
,

0
R
0

S;
whic
h
means
F

F
0
,
for
F
0
is
maxima
l.
(if
dir
e
ction
)
By
con
tradiction.
Let
us
assume
that

is
complete
and
that
there
exists
i
suc
h
that
F
i
is
not
a
maxim
al
set
of
copies.
Let
R

F
i
.
Therefore,
there
is
S

F
i
suc
h
that,
for
some
T
,
T

F




F
i-
R
and
T

F




F
i-
S.
Then,
F




F
i-
R
'
F




F
i-
S,
whic
h
in
v
alidates
the
h
yp
othesis
that
F
i
is
a
maxima
l
set
of
redexes
in
the
same
family
.
Exercise
..	
Pro
v
e
that
for
an
y
reduction

:
M

N
there
exists
a
complete
reduction

c
equiv
alen
t
to

(i.e.,

c

).
Prop
osition
..0
L
et

b
e
a
c
omplete
derivation.
Then
jj
=
](F
AM()),
wher
e
](F
AM())
is
the
c
ar
dinality
of
F
AM().
Pr
o
of
Easy
consequence
of
Lemma
..
and
of
the
requiremen
t
that
the
steps
of
complete
deriv
ations
are
non-empt
y
.
Reasoning
in
graphs,
it
will
b
e
useful
to
ha
v
e
names
for
eac
h
link
participating
in
a
-reduction.
Denition
..
In
-reduction,
the
links
that
are
consumed
b
y
and
are
created
reducing
a
redex
will
b
e
referred
to
as
indicated
in
Figure
..
λx
M
N
N
N
x
x
redex
body
variable
variable
M
substitution
substitution
result
@
context
argument
Fig.
..
Links
in
v
olv
ed
in
-reduction.

.
Completeness
of
L
amping's
algorithm

Lemma
..
L
et
F




F
n
b
e
a
c
omplete
derivation.
Then:
(i)
Each
new
link
cr
e
ate
d
by
a
(p
ar
al
lel)
r
e
duction
is
marke
d
with
a
lab
el
that
did
not
pr
eviously
app
e
ar
in
the
expr
ession.
(ii)
The
lab
els
on
r
esult
links
cr
e
ate
d
by
F
i
ar
e
dier
ent
fr
om
the
lab
els
on
substitution
links.
The
lab
els
on
two
r
esult
links
cr
e
ate
d
by
F
i
ar
e
identic
al
if
and
only
if
the
lab
els
on
the
ante
c
e
dent
c
ontext,
r
e
dex
and
b
o
dy
links
ar
e
r
esp
e
ctively
e
qual.
The
lab
els
on
two
substitution
links
cr
e
ate
d
by
F
i
ar
e
identic
al
if
and
only
if
the
lab
els
on
the
ante
c
e
dent
variable,
r
e
dex
and
ar
gument
links
ar
e
r
esp
e
ctively
e
qual.
Pr
o
of
Easy
,
b
y
denition
of
lab
eling
and
complete
deriv
ation.
.
Completeness
of
Lamping's
algorithm
L

evy's
w
ork
concluded
in
	0
lea
ving
op
en
the
issue
of
designing
a
-
ev
aluator
implemen
ting
complete
reductions.
This
issue
slept
ten
y
ears
b
efore
Lamping
a
w
ak
ened
it
presen
ting
its
ev
aluator
in
		.
Ha
ving
the
formalization
of
L

evy
optimalit
y
at
hand
w
e
can
no
w
pro
v
e
that
the
algorithm
presen
ted
in
Chapter
|a
simplied
v
ersion
of
Lamp-
ing's
one|ts
L

evy's
completeness
requiremen
t.
Most
of
the
denitions
and
results
in
this
section
are
due
to
Lamping
[Lam	
].
In
order
to
pro
v
e
that
Lamping's
algorithm
is
complete,
it
suces
to
sho
w
that
all
the
redexes
in
a
maxim
al
set
ha
v
e
a
unique
represen
tation
in
the
sharing
graphs.
Let
us
b
e
more
precise
on
this
p
oin
t.
Let
G
b
e
a
sharing
graph
obtained
along
the
reduction
of
[M].
Let
T
b
e
the
-term
that
matc
hes
with
G
(see
Denition
..).
Correctness
implies
that

:
M

T
(see
Theorem
..).
F
urthermore,
let

c
b
e
a
complete
reduction
equiv
alen
t
to

(see
Exercise
..	),
w
e
ha
v
e
to
pro
v
e
that
in
G
all
the
redexes
in
a
same
family
ha
v
e
a
unique
represen
tation,
in
this
w
a
y
con
tracting
suc
h
a
shared
redex
w
e
w
ould
con
tract
a
maxim
al
set
of
redexes.
In
terms
of
lab
els,
to
pro
v
e
completeness
means
to
sho
w
that
an
y
-redex
edge
in
G
represen
ts
only
and
al
l
-redexes
of
T
with
the
same
lab
el.
The
pro
of
will
b
e
pursued
exploiting
the
latter
corresp
ondence
of
la-
b
els.
Nev
ertheless,
it
is
not
trivial,
for
the
corresp
ondence
b
et
w
een
edges
and
connections
in
the
sharing
graph
is
not
a
function
from
lab
els
to
iden
tit
y
connections
(i.e.,
sequences
of
edges
crossing
fans
or
brac
k
ets
only).
Namely
,
uniqueness
of
represen
tation
migh
t
not
hold
for
edges
with
the
same
lab
el
that
are
not
-redexes.


R
e
dex
F
amilies
and
Optimality
*
*
*
u
u’
v
w
@
c
@
d
c
d
a
b
b
@
@
@
a
(1)
(2)
Fig.
.	.
Duplicati
on
of
edges
F
or
instance,
let
us
consider
the
example
in
Figure
.	.
The
edge
mark
ed
u
in
the
sharing
graph
in
Figure
.	()
represen
ts
a
set
of
edges
in
the
syn
tax
tree
asso
ciated
to
the
graph,
all
with
the
same
lab
el.
Ho
w
ev
er,
as
so
on
as
the
fan-@
in
teraction
is
con
tracted
(see
Figure
.	()),
the
edge
u
is
split
in
to
the
t
w
o
(distinct)
paths
u
0

v
and
u
0

w.
The
represen
tations
of
these
paths
in
the
syn
tax
tree
are
the
same
of
u,
since
a
fan-@
in
teraction
do
es
not
c
hange
the
syn
tax
tree
matc
hing
the
sharing
graph.
Therefore,
u
0

v
and
u
0

w
represen
t
edges
mark
ed
b
y
the
same
lab
el,
ev
en
if
they
are
dieren
t.
Nev
ertheless,
-in
teractions
in
v
olving
the
topmost
application
are
not
copies,
so
they
w
ould
not
get
the
same
lab
el.
But
this
is
denitely
the
case,
as
suc
h
reduction
will
ev
en
tually
apply
t
w
o
in
trinsically
dieren
t
functions:
the
one
resulting
from
the
con
traction
of
the
b
ottom-left
application,
and
the
other
one
obtained
b
y
ev
aluating
the
b
ottom-righ
t
application.
Let
us
see
this
p
oin
t
in
full
details.
Let
@

and
@

b
e
resp
ectiv
ely
the
topmost
and
b
ottommost
redexes
in
Figure
.	().
Let

b
e
the
lab
el
of
the
edges
corresp
onding
to
u
in
Figure
.	().
According
to
our
previous
reasonings,
b
oth
u
0

v
and
u
0

w
corresp
onds
to
edges
with
lab
el
.
F
urthermore,
propagating
the
fan
in
Figure
.	()
through
@

,
w
e
ev
en
tually
get
t
w
o
instances
of
the
edge
u,
sa
y
u

and
u

,
connecting
pair
of
@-no
des
that
are
instances
of
@

and
@

(i.e.,
for
i
=
;
,
the
edge
u
i
connects
a
no
de
@

i
to
a
no
de
@

i
,
where
@

i
and
@

i
are
instances
of
@

and
@

,
resp
ectiv
ely).
Again,
w
e
kno
w
that
u

and
u

represen
t
edges
with
lab
el
.
No
w,
the
edges
u

and
u

ma
y
b
ecome
part
of
a
redex
in
the
sharing
graph
only
after
ring
redexes
in
v
olving
the
corresp
onding
b
ottom
no
des.
Moreo
v
er,
b
y
induction
h
yp
othesis,
w
e
ma
y
assume
that
suc
h
t
w
o
redexes
yield

.
Completeness
of
L
amping's
algorithm
	
distinct
lab
els


and


.
Summari
zing,
an
y
redex
in
v
olving
@


will
yield
a
lab
el




,
while
an
y
redex
in
v
olving
@


will
yield
a
lab
el




,
that
are
denitely
distinct.
In
a
sense
the
ev
aluator
go
es
ahead
duplicating
edges
yielding
the
same
lab
el
that
will
participate
to
the
creation
of
dieren
t
(families
of
)
-redexes.
Unfortunately
,
the
reasoning
applied
in
the
example
do
es
not
w
ork
for
-rule.
In
this
case,
new
redexes
can
b
e
created,
all
in
v
olving
the
-redex
red
b
y
the
rule.
Because
of
this,
the
induction
h
yp
othesis
m
ust
b
e
stronger
than
the
one
used
ab
o
v
e.
More
precisely
,
w
e
need
to
c
haracterize
those
segmen
ts
in
the
syn
tax
tree
that
ha
v
e
a
unique
represen
tation
in
the
corresp
onding
sharing
graph.
Denition
..
(prerequisi
te
c
hain)
Let
n
b
e
a
no
de
in
the
syn
tax
tree
of
a
-term.
The
pr
er
e
quisite
chain
'
of
n
is
(if
an
y)
the
unique
sequence
of
edges
(a
path
assuming
that
v
ariables
are
bac
k-connected
to
their
binders)
according
to
the
follo
wing
inductiv
e
denition
b
y
cases
on
the
t
yp
e
of
n:
(i)
n
is
a
-no
de
:
Let
v
b
e
the
con
text
edge
of
n.
If
v
is
a
-redex,
then
'
=
v,
otherwise
'
=
v

 ,
where
 
is
the
prerequisite
c
hain
of
the
no
de
ab
o
v
e
n.
(ii)
n
is
an
@-no
de
:
Let
v
b
e
the
function
edge
of
n.
If
v
is
a
-redex,
then
'
=
v,
otherwise
'
=
v

 ,
where
 
is
the
prerequisite
c
hain
of
the
no
de
connected
to
the
function
p
ort
of
n.
(iii)
n
is
a
variable
:
Then
'
is
the
prerequisite
c
hain
of
the
-no
de
binding
n.
F
or
instance,
let
us
consider
the
syn
tax
tree
in
Figure
.0.
The
v
er-
tex
x
has
no
prerequisite
c
hain;
the
prerequisite
c
hain
of
the
no
de
y
is
the
edge
ab
o
v
e
it;
the
prerequisite
c
hain
of
the
no
de
v
is
the
edge
ab
o
v
e
it
follo
w
ed
b
y
the
-redex.
Finally
,
let
us
compute
the
prereq-
uisite
c
hain
of
the
righ
tmost
application
(the
c
hain
dra
wn
b
y
a
dashed
line
in
Figure
.0):
the
prerequisite
c
hain
of
the
topmost
application
is
its
function
edge
follo
w
ed
b
y
the
-redex
(the
short
dotted
line);
the
prerequisite
c
hain
of
the
no
de
u
is
its
con
text
edge
follo
w
ed
b
y
the
prerequisite
c
hain
of
the
topmost
application
(the
curv
ed
dotted
line);
therefore,
the
prerequisite
c
hain
of
the
righ
tmost
application
is
its
func-
tion
edge
follo
w
ed
b
y
the
prerequisite
c
hain
of
the
v
ariable
u,
whic
h
is
the
same
of
the
prerequisite
c
hain
of
u.

0
R
e
dex
F
amilies
and
Optimality
λu
v
λ
λx
@
@
@
x
λy
u
x
y
Fig.
.0.
Prerequisite
c
hains.
Exercise
..
Notice
that
the
denition
of
prerequisite
c
hain
con-
forms
to
the
idea
that
v
ariables
are
bac
k-connected
to
their
binders
(as
already
done
for
sharing
graphs).
Then,
according
to
this
remark,
pro
v
e
that
an
y
prerequisite
c
hain
is
indeed
a
path.
Moreo
v
er,
pro
v
e
that:
(i)
An
y
tail
of
a
prerequisite
c
hain
is
a
prerequisite
c
hain.
(ii)
An
y
prerequisite
c
hain
ends
with
a
-redex
(whic
h
is
indeed
the
only
redex
edge
crossed
b
y
the
c
hain).
(iii)
The
length
of
an
y
prerequisite
c
hain
is
nite.
(iv)
If
v
is
the
redex
at
the
end
of
the
prerequisite
c
hain
'
of
a
no
de
n,
then:
(a)
the
redex
v
is
to
the
left
of
n;
(b)
when
'
=
v,
an
y
reduction
leading
to
the
creation
of
a
redex
in
v
olving
n
con
tracts
(an
instance
of
)
the
redex
v.
The
previous
exercise
giv
es
an
idea
of
the
information
enco
ded
in
to
prerequisite
c
hains.
In
the
pro
of
of
next
theorem,
prerequisite
c
hains
will
b
e
used
to
link
sharing
of
Lamping's
algorithm
to
sharing
of
L

evy's
lab
eling.
T
o
this
purp
ose,
w
e
need
some
terminology:

A
pr
er
e
quisite
chain
r
epr
esentation
is
a
sequence
of
edges
in
the
shar-
ing
graph
corresp
onding
to
the
edges
of
a
prerequisite
c
hain.

An
edge
of
the
syn
tax
tree
is
called
auxiliary
if
do
es
not
start
at
the
function
p
ort
of
an
application
or
do
es
not
terminate
at
the
con
text
p
ort
of
an
abstraction.
Auxiliary
edges
are
nev
er
tra
v
ersed
b
y
prerequisite
c
hains.
Nev
erthe-

.
Completeness
of
L
amping's
algorithm

less,
they
are
crucial
when
prerequisite
c
hains
are
created,
as
sho
wn
b
y
the
follo
wing
example.
λy
λx
uv
uw
λy
z
λ
@
@
@
@
@
x
@
v
w
ξ
ζ
λz
u
@
@
w
ξ
*
@
v
ζ *
Fig.
..
Creation
of
prerequisite
c
hains.
Example
..
Let
us
consider
the
prerequisite
c
hains

=

0

u
and

=

0

u
in
Figure
..
After
the
reduction
of
u,
t
w
o
new
prerequisite
c
hains
are
created.
F
urthermore,
these
new
c
hains


and


resp
ectiv
ely
in
v
olv
e
the
auxiliary
edges
u
w
and
u
v
(see
again
Figure
.).
In
fact,
with
resp
ect
to
the
initial
term,
they
corresp
ond
to
the
lengthening
of

and

b
y
the
segmen
ts
u
w

w
and
u
v

v
(i.e.,
w
e
could
sa
y
that


=

0

u

u
w

w,
and
that


=

0

u

u
v

v).
W
e
are
no
w
ready
to
state
and
pro
v
e
optimalit
y
of
Lamping's
algo-
rithm.
Let
us
remark
again
that
what
w
e
actually
need
is
the
prop
ert
y
in
the
rst
item
of
Lemma
...
Nev
ertheless,
w
e
ha
v
e
to
sim
ultaneously
pro
v
e
that
also
the
second
item
is
in
v
arian
t
(i.e.,
w
e
ha
v
e
to
concern
ab
out
the
represen
tation
of
auxiliary
edges),
otherwise
w
e
w
ould
not
b
e
able
to
ensure
in
v
ariance
of
the
rst
item
under
-reduction.
Before
to
state
the
lemma,
let
us
remark
that
the
notion
of
isomor-
phism
b
et
w
een
prerequisite
c
hains
is
the
usual
one.
Namely
,
t
w
o
pre-
requisite
c
hains
are
isomorphic
when
they
there
is
a
bijection
b
et
w
een
their
edges
and
no
des
suc
h
that
lab
els
of
the
edges
are
preserv
ed.
Lemma
..
L
et
us
assume
that
the
-term
N
matches
with
a
sharing
gr
aph
G
such
that
[M]

G,
for
some
term
M
such
that
INIT(M)
is
true.
(i)
Two
pr
er
e
quisite
chains
in
N
have
the
same
r
epr
esentation
in
G
if
and
only
they
ar
e
isomorphic.


R
e
dex
F
amilies
and
Optimality
(ii)
If
two
auxiliary
e
dges
n
e
n
0
and
m
e
0
m
0
have
matching
lab
els
but
dier
ent
r
epr
esentations,
then
at
le
ast
one
of
the
pr
er
e
quisite
chains
of
n
and
n
0
is
not
isomorphic
to
the
c
orr
esp
onding
pr
e-
r
e
quisite
chain
of
m
and
m
0
.
Pr
o
of
By
induction
on
the
length
of
the
deriv
ation.
In
the
base
case
(i.e.,
[M]
=
G),
the
corresp
ondence
b
et
w
een
prerequisite
c
hains
and
rep-
resen
tations
is
injectiv
e
(an
y
c
hain
has
a
unique
represen
tation).
Hence,
the
theorem
trivially
holds,
for
INIT(M)
is
true,
b
y
h
yp
othesis.
Th
us,
let
N
0
and
N
b
e
the
terms
that
resp
ectiv
ely
matc
h
the
sharing
graphs
G
0
and
G
suc
h
that
[M]

G
0
u
!
G.
W
e
pro
ceed
b
y
cases
on
the
rule
u.

If
u
in
v
olv
es
con
trol
no
des
only
or
is
a
p
erm
utation
b
et
w
een
a
brac
k
et
and
a
prop
er
no
de,
(i.e.,
fan-fan,
fan-brac
k
et,
brac
k
et-
brac
k
et,
brac
k
et-@,
or
brac
k
et-),
then
N
=
N
0
.
Also,
the
rule
only
causes
a
lo
cal
c
hange
in
the
prerequisite
c
hain
represen
ta-
tions
crossing
u
(a
p
erm
utation
of
the
no
des
in
v
olv
ed
in
the
rule,
or
an
erasing
in
the
case
of
annihilation).
Then,
b
y
inductiv
e
h
yp
othesis
w
e
conclude.

Let
u
b
e
a
fan
propagation.
The
t
w
o
cases
(fan-@
and
fan-)
are
similar.
So,
let
us
giv
e
the
case
in
whic
h
u
is
a
fan-@
in
teraction
only
.
Let
@
b
e
the
@-no
de
in
u.
In
this
case,
although
w
e
still
ha
v
e
N
=
N
0
,
the
prerequisite
c
hain
represen
tations
tra
v
ersing
@
are
c
hanged
(see
the
example
in
Figure
.	),
according
to
the
fact
that
the
fan
has
propagated
through
@
duplicating
it.
Let
@

b
e
the
cop
y
of
@
corresp
onding
to
the

p
ort
of
the
fan,
and
@

the
other
cop
y
of
@.
The
rule
has
split
the
set
of
prerequisite
c
hain
represen
tations
crossing
@
in
t
w
o
sets
(let
us
note
that
an
y
prereq-
uisite
c
hain
represen
tation
in
N
0
crossing
@
also
crosses
the
fan
in
u):
the
represen
tations
in
N
0
tra
v
ersing
the

p
ort
of
the
fan
are
transformed
in
represen
tations
crossing
@

;
the
represen
tations
in
N
0
tra
v
ersing
the

p
ort
of
the
fan
in
represen
tations
crossing
@

.
In
other
w
ords,
the
rule
has
just
caused
some
lo
cal
p
erm
uta-
tions
in
prerequisite
c
hain
represen
tations,
plus
the
replacemen
t
of
an
y
o
ccurrence
of
@
with
a
corresp
onding
instance
@

or
@

,
according
to
the
w
a
y
in
whic
h
the
represen
tation
tra
v
ersed
the
fan.
Th
us,
b
y
induction
h
yp
othesis
w
e
conclude.

Let
u
b
e
a
-in
teraction.
(Let
us
remark
that
-reduction
is
the
unique
rule
that
creates
and
destro
ys
prerequisite
c
hains;
see
Example
...)
By
induction
h
yp
othesis,
the
edge
u
represen
ts

.
Completeness
of
L
amping's
algorithm

only
and
all
the
redexes
with
a
giv
en
lab
el.
Hence,
U
:
N
0

N,
where
U
is
a
maxima
l
set
of
redexes
in
a
giv
en
family
.
Let
us
pro
v
e
in
order
the
t
w
o
prop
erties:
(i)
T
ak
e
t
w
o
isomorphic
prerequisite
c
hains

and
.
The
only
relev
an
t
case
is
when
at
least
one
of
them
con
tains
an
edge
created
b
y
the
reduction
of
u,
otherwise,
the
prop
ert
y
follo
ws
immediately
b
y
induction
h
yp
othesis.
Hence,
let

=

0

v


00
,
where
v
is
the
rst
edge
in

that
has
b
een
created
b
y
u.
Corresp
ondingly
,
w
e
ha
v
e

=

0

w


00
,
where

0
(
00
)
has
the
same
length
of

0
(
00
),
and
the
edges
v
and
w
yield
the
same
lab
el.
By
Lemma
..,
also
w
has
b
een
create
b
y
the
reduction
of
u.
Moreo
v
er,
b
oth
u
and
w
m
ust
b
e
of
the
same
t
yp
e,
that
is,
either
they
are
b
oth
result
links
or
they
are
substitution
links.
The
crucial
observ
ation
is
that

and

ma
y
b
e
seen
as
comp
ositions
of
suitable
prerequisite
c
hains.
More
precisely
,
w
e
ha
v
e
that:
(a)
The
edges
v
and
w
ma
y
b
e
seen
as
con
tractions
of
t
w
o
c
hains
e
0
v

u
v

e
00
v
and
e
0
w

u
w

e
00
w
with
matc
hing
lab
els
and
suc
h
that
u
v
;
u
w

U
.
In
particular,
an
y
represen
tation
of
v
in
G
is
obtained
b
y
erasing
an
@-
pair
from
some
represen
tation
of
e
0
v

u
v

e
00
v
,
and
analogously
for
w
and
e
0
w

u
w

e
00
w
.
(b)
The
edges
e
0
v
and
e
0
w
cannot
b
e
auxiliary
.
Let
us
pro
v
e
it
for
e
0
v
.
Since

is
a
prerequisite
c
hain,
v
cannot
b
e
an
auxiliary
edge.
Hence,
v
is
either
the
function
edge
of
an
application
or
the
con
text
edge
of
an
abstraction.
In
b
oth
cases,
w
e
easily
see
that
e
0
v
is
of
the
same
t
yp
e
of
v,
th
us,
it
cannot
b
e
aux-
iliary
.
Instead,
let
us
note
that
e
00
v
and
e
00
w
can
b
e
auxiliary
edges.
(c)
Both

0
and

0
do
not
con
tain
edges
created
b
y
the
reduction
of
an
y
redex
in
U
.
Moreo
v
er,
they
are
isomorphic,
and

0

e
0
v

u
v
and

0

e
0
w

u
w
are
prerequisite
c
hains
in
N
0
.
Hence,
b
y
induction
h
yp
othesis,
the
represen
tations
of

0

e
0
v

u
v
and

0

e
0
w

u
w
coincide
in
G
0
.
(d)
Both

00
and

00
are
prerequisite
c
hains
in
the
term
N
(see
Exercise
..).
Hence,
b
y
induction
h
yp
oth-


R
e
dex
F
amilies
and
Optimality
esis
on
the
n
um
b
er
of
new
edges,
the
represen
tations
of

00
and

00
in
G
coincide.
(e)
Let
us
consider
the
longest
subpaths
of

00
and

00
comp
osed
of
edges
that
ha
v
e
not
b
een
created
b
y
the
reduction
of
U
(the
rst
segmen
ts
of

00
and

00
obtained
applying
inductiv
e
h
yp
othesis).
It
is
im-
mediate
to
note
that
suc
h
paths
either
are
prerequi-
site
c
hains
in
N
0
(when
they
coincide
with

00
and

00
)
or
can
b
e
completed
in
to
prerequisite
c
hains
in
N
0
.
Namely
,
let

00
0
and

00
0
b
e
the
prerequisite
c
hains
in
N
0
of
the
no
des
at
the
end
of
e
00
v
and
e
00
w
,
resp
ectiv
ely
.
Suc
h
c
hains
are
isomorphic.
Th
us,
the
represen
tation
in
G
0
of

00
0
and

00
0
coincide.
The
previous
considerations
allo
ws
us
to
conclude
that
the
represen
tation
of

and

in
G
coincide.
In
fact,
the
third
and
fourth
items
ensure
that
the
subpaths
corresp
onding
to

0
and

0
and
the
subpaths
corresp
onding
to

00
and

00
coincide
in
an
y
represen
tation
of

and
.
Th
us,
the
t
w
o
represen
tations
migh
t
dier
for
the
represen
tations
of
u
and
v
only
.
According
to
the
rst
item
in
the
previous
en
umeration,
the
subpaths
corresp
onding
to
v
and
w
in
an
y
represen
ta-
tion
in
G
of

and

corresp
ond
to
suitable
con
tractions
of
subpaths
represen
ting
e
0
v

u
v

e
00
v
and
e
0
w

u
w

e
00
w
.
F
urther-
more,
the
third
item
allo
ws
to
conclude
that
the
subpaths
corresp
onding
to
e
0
v
u
v
and
e
0
w
u
w
coincide.
W
e
left
to
see
what
happ
ens
to
e
00
v
and
e
00
w
.
(a)
If
e
00
v
and
e
00
w
are
not
auxiliary
edges,
then
the
paths
e
00
v


00
0
and
e
00
w


00
0
are
prerequisite
c
hains.
Since
b
y
induction
h
yp
othesis
they
coincide,
w
e
conclude
that
also
the
subpaths
corresp
onding
to
v
and
w
in
the
represen
tations
of

and

coincide.
(b)
Let
n
e
00
v
n
0
and
m
e
00
w
m
0
b
e
auxiliary
edges.
W
e
ha
v
e
already
pro
v
ed
that
the
represen
tations
of
the
pre-
requisite
c
hains
of
n
and
m
(i.e.,
u
v
and
u
w
)
and
of
the
prerequisite
c
hains
of
n
0
and
m
0
(i.e.,

00
0
and

00
0
)
coincide.
Hence,
b
y
the
part
on
auxiliary
edges
of
induction
h
yp
othesis,
w
e
conclude
that
also
the
represen
tation
of
e
00
v
and
e
00
w
coincide.

.
Completeness
of
L
amping's
algorithm

The
pro
of
of
the
in
v
erse
implication
is
similar,
just
start
assuming
that

and

ha
v
e
the
same
represen
tation.
(ii)
Let
n
e
n
0
and
m
e
0
m
0
b
e
t
w
o
auxiliary
edges
as
in
the
h
y-
p
othesis.
F
urthermore,
let
us
assume
that
they
ha
v
e
not
b
een
created
b
y
the
reduction
of
U
and,
without
loss
of
generalit
y
,
that
the
prerequisite
c
hains

0
and

0
of
n
and
m
ha
v
e
dieren
t
represen
tations
in
G
0
.
The
reduction
of
U
c
hanges
the
prerequisite
c
hains
of
n
and
m
only
if
they
end
with
a
redex
in
U
.
An
yho
w,
let

and

b
e
the
new
prerequisite
c
hains
in
N
of
n
and
m,
resp
ectiv
ely
.
If

0
=
,
then
the
prop
ert
y
trivially
follo
ws
b
y

=

0
:
in
the
case

=

0
,
this
inequalit
y
holds
b
y
h
yp
othesis;
in
the
case
that

0
ends
b
y
a
redex
in
u,
the
prerequisite
c
hain

con
tains
at
least
an
edge
with
a
lab
el
that
where
not
presen
t
in
N
0
(see
Lemma
..).
Finally
,
let
us
assume
that
b
oth

0
and

0
end
with
a
redex
in
U.
Let

0
=

00

e
0

u
0
and

0
=

00

e
00

u
00
.
Since

0
and

0
are
not
isomorphic
b
y
h
yp
othesis,
either

0
is
isomorphic
to

0
but
e
0
and
e
00
are
not,
or

0
and

0
are
not
isomorphic.
In
b
oth
cases,
b
y
Lemma
..,
w
e
see
that

and

m
ust
ev
en
tually
dier
after
t
w
o
isomorphic
prexes.
When
one
of
n
e
n
0
and
m
e
0
m
0
has
b
een
created
b
y
the
re-
duction,
sa
y
n
e
n
0
,
w
e
see
that
they
ma
y
ha
v
e
matc
hing
la-
b
els
only
if
they
ha
v
e
are
b
oth
new
(b
y
Lemma
..).
In
this
case
let
us
note
that
suc
h
new
auxiliary
edges
are
the
result
of
the
con
traction
of
t
w
o
sequences
a
0

u




u
k

a
k
and
b
0
v




v
h
b
h
of
auxiliary
edges
a
0
;
:
:
:
;
a
k
;
b
0
;
:
:
:
;
b
h
and
redexes
u

;
:
:
:
;
u
k
;
v

;
:
:
:
;
v
h
in
U
.
Some
though
ts
allo
w
to
conclude
that:
h
=
k;
the
lab
els
of
these
edges
m
ust
matc
h;
the
represen
tations
of
n
e
n
0
and
m
e
0
m
0
ma
y
dier
only
b
ecause
the
represen
tations
of
a
0
and
b
0
or
the
represen
tations
of
a
k
and
b
k
dier.
Let
us
tak
e
the
case
in
whic
h
a
0
and
b
0
dier.
By
induction
h
yp
othesis,
the
prerequisite
c
hains
of
n
and
m
in
N
0
dier.
W
e
can
then
conclude
applying
the
same
tec
hnique
used
for
the
case
in
whic
h
n
e
n
0
and
m
e
0
m
0
w
ere
not
new.
The
completeness
of
Lamping's
ev
aluator
is
an
immediate
consequence
of
the
ab
o
v
e
lemma.


R
e
dex
F
amilies
and
Optimality
Theorem
..
F
or
any
-term
M,
we
have
that
[M]

G
by
L
amp-
ing's
algorithm
if
and
only
if
M

N
for
some
c
omplete
(family)
r
e
duc-
tion
and
N
matches
with
G.
Pr
o
of
Redexes
are
particular
cases
of
prerequisite
c
hains.
Hence,
b
e-
cause
of
Lemma
..,
all
the
redexes
of
a
term
N
0
in
a
same
family
ha
v
e
a
unique
represen
tation
in
the
sharing
graph
G
0
that
N
0
matc
hes.
The
pro
of
is
then
b
y
induction
on
the
length
of
the
deriv
ation.
(only-if
dir
e
ction
):
Since
the
other
rules
do
not
c
hange
the
matc
hing
term,
w
e
only
consider
the
case
u
:
G
0
!
G
for
some
-redex
u.
Since,
u
represen
t
all
the
redexes
in
the
same
family
in
the
term
N
0
matc
hing
with
G
0
,
it
corresp
onds
to
the
complete
family
con
traction
U
:
N
0
!
N.
(if
dir
e
ction
):
Let
us
tak
e
a
maxim
al
set
U
of
redexes
with
the
same
la-
b
el
in
N
0
.
All
these
redexes
ha
v
e
the
same
represen
tation
in
the
matc
hing
sharing
graph
G
0
.
Suc
h
a
represen
tation
'
migh
t
not
b
e
an
edge,
for
it
migh
t
con
tain
sev
eral
con
trol
no
des.
Nev
erthe-
less,
there
is
a
reduction
sequence
comp
osed
of
con
trol
no
de
rules
only
con
tracting
the
path
'
to
a
-redex.
Namely
,
G
0

G
00
for
some
G
00
that
matc
hes
N
0
in
whic
h
the
represen
tation
of
U
is
an
edge
u.
Th
us,
G
0

G
00
u
!
G
ensures
that
G
matc
hes
with
the
term
N
suc
h
that
U
:
N
0
!
N.
.
Optimal
deriv
ations
An
optimal
ev
aluator
m
ust
meet
t
w
o
goals:
a
v
oiding
to
duplicate
redexes
and
a
v
oiding
to
p
erform
useless
w
ork.
The
rst
goal
is
satised
b
y
the
completeness
requiremen
t;
the
second
one
is
fullled
b
y
call-b
y-need
deriv
ations.
The
formalization
of
call-b
y-need
requires
some
terminology
.
Let

=
F




F
n
,
the
set
of
redexes
in
the
initial
term
one
of
whose
residuals
is
con
tracted
along

is
dened
in
the
follo
wing
w
a
y:
R()
=
fR
j
	i:
(R=F




F
i-
)
\
F
i
=
?g:
Moreo
v
er,
as
usual,
w
e
shall
sa
y
that
a
deriv
ation

is
terminating
if
its
nal
expression
is
in
normal
form.
Denition
..
(call-b
y-need)
A
redex
R
in
M
is
ne
e
de
d
if
and
only

.
Optimal
derivations

if,
for
ev
ery
terminating
deriv
ation

starting
at
M,
R

R().
A
deriv
ation

=
F




F
n
is
c
al
l-by-ne
e
d
if
and
only
if
there
is
at
least
one
needed
redex
in
ev
ery
F
i
.
Prop
osition
..
Every
-term
has
at
le
ast
a
ne
e
de
d
r
e
dex.
Pr
o
of
Let
R
b
e
the
leftmost-outermost
redex
in
M
and

:
M

N
b
e
a
deriv
ation
suc
h
that
R

R().
Then
there
exists
a
redex
S
in
N
suc
h
that
R=
=
fSg,
whic
h
means
that
R
is
needed.
Theorem
..
L
et
M
have
a
normal
form.
A
ny
c
al
l-by-ne
e
d
deriva-
tion
starting
at
M
is
eventual
ly
terminating.
Pr
o
of
By
the
standardization
theorem,
the
leftmost-outermost
deriv
a-
tion
of
M
ev
en
tually
reac
hes
the
normal
form.
Let
d(M)
b
e
the
length
of
the
leftmost-outermost
deriv
ation
starting
at
M.
Let

=
M
F

!
M




M
n-
F
n
!
M
n



b
e
a
call-b
y-need
deriv
ation.
W
e
pro
v
e
that
d(M)
>
d(M

)
>



>
d(M
n
)
>



:
Let

=
R




R
k
b
e
the
leftmost-outermost
deriv
ation
reducing
M
to
its
normal
form.
Then
=F

=
C




C
k
,
where
C
i
=
?
or
C
i
=
fS
i
g,
since
residuals
of
leftmost-outermost
redexes,
if
an
y
,
remain
leftmost-
outermost.
No
w,
as

is
a
call-b
y-need
deriv
ation,
there
is
a
needed
redex
T
in
F

.
Hence,
T

R(),
that
is,
R
j

T
=R




R
j-
for
some
j.
Therefore,
C
j
=
?
and
d(M)
>
d(M

).
Iterating
the
argumen
t,
w
e
get
that
d(M
i-
)
>
d(M
i
),
for
an
y
i
>
.
W
e
can
nally
dene
a
cost
measure
for
deriv
ations.
An
ev
aluator
k
eeping
shared
copies
of
a
redex
p
erforms
a
reduction
of
all
the
copies
in
one
step.
Let
us
giv
e
unitary
cost
to
the
reduction
of
a
set
of
copies.
According
to
this,
the
cost
of
a
reduction
F
con
taining
n
dieren
t
sets
of
copies
is
n.
The
cost
of
a
deriv
ation
,
sa
y
cost
(),
is
the
sum
of
the
costs
of
eac
h
reduction
in
.
By
Lemma
..,
if

is
a
complete
deriv
ation,
cost()
=
jj.
F
urthermore,
b
y
Prop
osition
..0,
jj
=
](F
AM
())
for
complete
deriv
ations
.
Th
us,
since
for
ev
ery
deriv
ation

cost
()

](F
AM())
w
e
conclude
that
complete
deriv
ations
ha
v
e
minimal
cost
with
resp
ect


R
e
dex
F
amilies
and
Optimality
to
the
cost
of
reducing
copies.
Nev
ertheless,
in
order
to
b
e
optimal
w
e
m
ust
a
v
oid
useless
computations
to
o.
Theorem
..
(optimali
t
y)
A
ny
c
omplete
and
c
al
l-by-ne
e
d
deriva-
tion
c
omputes
the
normal
form
in
optimal
c
ost.
Pr
o
of
Let

b
e
a
complete
call-b
y-need
deriv
ation
and

b
e
a
terminating
deriv
ation
starting
at
the
same
expression
as
.
Firstly
w
e
pro
v
e
b
y
induction
on
jj
that
F
AM
()

F
AM().
The
base
case
is
ob
vious.
So,
let

=

0
F
.
Then
F
AM
()
=
F
AM
(
0
)
[
f[
0
S]g,
for
an
y
S

F
and,
b
y
induction
h
yp
othesis,
F
AM
(
0
)

F
AM
().
By
h
yp
othesis,
there
exists
a
needed
redex
R
in
F
.
Then
R

R(=
0
),
whic
h
means
that
[
0
R]

F
AM
()
and
F
AM()

F
AM
().
Then,
the
cost
of
ev
ery
terminating
reduction

is
greater
than
the
cost
of
a
complete
and
call-b
y-need
deriv
ation
,
since
cost()

](F
AM
())

](F
AM())
=
cost()
where
the
last
equalit
y
follo
ws
b
y
Lemma
..
and
Prop
osition
..0.
The
follo
wing
corollary
is
an
easy
consequence
of
optimalit
y
theorem
and
completeness
of
Lamping's
algorithm.
Corollary
..
L
amping's
evaluator
e
quipp
e
d
with
a
c
al
l-by-ne
e
d
r
e-
duction
str
ate
gy
(the
leftmost-outermost,
for
instanc
e)
is
optimal.
Nev
ertheless,
let
us
conclude
observing
that
a
call-b
y-need
strategy
reduces
the
p
ossible
parallelism
of
the
ev
aluator.
A
parallel
implemen-
tation
should
instead
adopt
a
strategy
dieren
t
than
call-b
y-need
in
order
to
ac
hiev
e
high
parallelism,
at
the
cost
of
p
erforming
some
useless
w
ork.


P
aths
In
the
previous
c
hapters,
w
e
already
remark
ed
that
the
main
diculties
in
implemen
ting
L

evy's
optimalit
y
theory
is
that
it
do
es
not
suce
to
a
v
oid
the
duplication
of
reducible
subterms;
indeed,
w
e
m
ust
also
a
v
oid
the
duplication
of
an
y
\virtual
redex"|an
y
application
whic
h
is
not
y
et
a
redex,
for
its
functional
part
is
not
y
et
an
abstraction,
but
that
migh
t
b
ecome
a
redex
later
on
during
the
reduction
due
to
the
instan
tiation
of
some
of
its
free
v
ariables.
A
t
ypical
example
of
virtual
redex
is
an
application
(y
z)
in
whic
h
the
v
ariable
y
ma
y
b
e
instan
tiated
b
y
an
abstraction
after
the
execution
of
a
redex.
W
e
met
a
virtual
redex
lik
e
this
in
the
in
tro
duction,
analyzing
the
example
M
=
(x:
(x
I)
y:
(
(y
z))),
where
I
=
y:
y
and

=
x:
(x
x)
(see
Chpater
).
In
particular,
w
e
observ
ed
that
the
in
ternal
strategies
are
not
the
shortest
ones
in
reducing
M,
for
the
subterm
(y
z)
will
b
ecome
a
redex
(I
z)
after
the
reduction
of
the
outermost
redex
of
M
and
of
the
new
redex
created
b
y
it.
Hence,
adopting
an
in
ternal
strategy
,
the
redex
(
(y
z))
w
ould
b
e
reduced
rst,
creating
t
w
o
instances
of
the
application
(y
z);
the
successiv
e
instan
tiation
of
y
with
I,
w
ould
then
create
t
w
o
copies
of
the
redex
(I
z),
causing
a
useless
duplication
of
w
ork.
A
t
the
same
time
(see
Figure
.),
the
analysis
of
the
example
p
oin
ted
out
that
w
e
could
in
terpret
the
virtual
redex
corresp
onding
to
(y
z)
as
a
\path"
(in
the
abstract
syn
tax
tree
of
M)
connecting
the
function
p
ort
of
the
application
(y
z)
to
the
ro
ot
of
the
term
I
that
will
replace
y
(this
path
has
b
een
redra
wn
in
Figure
.).
In
tuitiv
ely
,
suc
h
a
\path"
describ
es
the
\con
trol
o
w"
b
et
w
een
the
application
and
the
-no
de
that
giv
es
rise
to
the
virtual
redex|note
that
the
ro
ot
of
I
is
the
con
text
p
ort
of
a
-no
de.
F
urthemore,
the
path
asso
ciated
to
the
virtual
redex
of
(y
z)
is
the
only
path
that
con
tracts
b
y
-reduction
in
to
the
edge
of
the
actual
redex
(I
z)
(see
again
Figure
.
of
Chapter
).
	

0
Paths
λ
@
@
λ
@
λ
@
x
x
y
y
y
y
z
∆
Fig.
..
Virtual
redexes
and
paths
Pursuing
the
analogy
with
paths,
the
statemen
t
that
an
optimal
im-
plemen
tation
has
to
a
v
oid
the
duplication
of
virtual
redexes
can
th
us
b
e
rephrased
b
y
sa
ying
that
an
optimal
implemen
tation
has
to
compute
the
normal
form
of
a
term
without
duplicating
(or
computing
t
wice)
any
p
ath
c
orr
esp
onding
to
a
virtual
r
e
dex.
In
this
c
hapter
of
the
b
o
ok,
w
e
shall
in
v
estigate
the
formal
denition
of
these
kind
of
paths,
giv
e
a
formal
analysis
of
their
relations
with
optimalit
y
,
and
presen
t
some
distinct
c
haracterizations
of
them.
But
b
efore
to
go
on,
let
us
remind
that,
ev
en
if
according
to
Figure
.
the
\path"
of
the
virtual
redex
(y
z)
is
not
an
actual
path
in
the
usual
sense,
it
turns
out
to
b
e
an
actual
path
as
so
on
as
w
e
assume
that
b
ound
v
ariables
are
explicitly
connected
to
their
binders|as
in
the
sharing
graph
notation
w
e
are
using.
.
Sev
eral
deniti
on
s
of
paths
As
a
matter
of
fact,
the
study
of
paths
denable
on
the
syn
tax
tree
represen
tation
of
-terms
arosed
in
the
literature
from
three
dieren
t
p
ersp
ectiv
es,
resp
ectiv
ely
related
to
three
ma
jor
foundational
in
v
estiga-
tions
of
-reduction:
)
L

evy's
analysis
of
famili
es
of
redexes
(and
the
asso
ciated
concept
of
lab
eled
reduction);
)
Lamping's
graph-reduction
algorithm;
)
Girard's
geometry
of
in
teraction.
All
the
previous
studies
happ
ened
to
mak
e
crucial
(ev
en
if
not
alw
a
ys
explicit)
use
of
a
notion
of
path,
resp
ectiv
ely
called
le
gal,
c
onsistent
and
r
e
gular.

.
Sever
al
denitions
of
p
aths

W
e
are
already
familiar
with
the
notion
of
L

evy's
redex
family
.
L

evy's
idea
w
as
to
use
lab
els
to
capture
the
notion
of
t
w
o
redexes
b
eing
cre-
ated
in
the
\same"
w
a
y
during
a
reduction.
T
o
this
purp
ose,
he
lab
eled
terms
and
made
b
eta
reductions
act
on
suc
h
lab
els.
He
ga
v
e
then
a
calculus
in
whic
h
t
w
o
redexes
are
in
the
same
family
if
and
only
if
their
lab
els
coincide.
The
in
tuition
that
led
L

evy
to
this
result
w
as
that
lab
els
should
b
e
a
trace
of
the
history
of
creation
of
the
redex.
In
[AL	b
],
Asp
erti
and
Lanev
e
made
suc
h
an
in
tuition
more
formal,
pro
ving
that
the
notion
of
\history"
enco
ded
b
y
lab
els
has
a
direct
image
as
a
\path"
in
the
graph
of
the
initial
term.
In
a
certain
sense,
they
sho
w
ed
that
the
history
of
a
redex
can
b
e
seen
as
a
sort
of
o
w
of
con
trol
b
et
w
een
a
suitable
application
and
a
suitable
-no
de
of
the
term|that
is,
a
virtual
redex|and
that
suc
h
o
w
can
b
e
describ
ed
as
a
suitable
path,
sa
y
a
le
gal
p
ath,
connecting
an
application
and
an
abstraction
no
de.
The
relev
an
t
p
oin
t
of
legal
paths
is
that
their
denition
is
indep
enden
t
from
-term
reduction.
In
fact,
redexes
are
the
base
case
of
legal
paths;
the
inductiv
e
construction
consists
then
in
lengthening
previously
built
paths
accord-
ing
to
a
simple
and
eectiv
e
condition
asking
for
the
minima
l
symmetry
necessary
to
ensure
that
an
y
legal
path
migh
t
unfold
in
to
a
redex.
As-
p
erti
and
Lanev
e
sho
w
ed
then
the
relations
b
et
w
een
the
statical
notion
of
legal
path
and
-reduction
pro
ving
that:
)
lab
els
of
redexes
in
an
y
reduct
N
of
M
denote
paths
in
M;
)
all
the
latter
paths
are
legal;
)
an
y
legal
path
in
M
denotes
a
lab
el
of
a
redex
to
app
ear
somewhere
in
the
set
of
reducts
of
M.
Mean
while,
p
eople
w
ere
seeking
for
a
shared
reduction
faithfully
im-
plemen
ting
the
notion
of
famili
es,
i.e.,
a
reduction
where
famili
es
could
b
e
said
to
b
e
reduced
in
one
step.
The
result
w
as
the
optimal
algorithm
that
w
e
ha
v
e
widely
presen
ted
in
Chapter
.
Also
this
algorithm
rests
on
a
notion
of
path.
In
fact,
pro
ving
its
correctness
w
e
ha
v
e
already
met
the
so-called
pr
op
er
p
aths,
b
y
whic
h
w
e
ga
v
e
the
corresp
ondence
b
et
w
een
sharing
graphs
and
-terms.
In
this
c
hapter,
w
e
will
presen
t
and
use
in-
stead
another
notable
notion
of
paths
related
to
the
optimal
algorithm,
the
so-called
c
onsistent
p
aths
in
tro
duced
b
y
Gon
thier,
Abadi
and
L

evy
in
[GAL	a
].
In
some
sense,
prop
er
paths
are
a
restriction
of
consisten
t
paths
to
the
paths
of
a
sharing
graph
with
a
direct
corresp
ondence
in
the
syn
tax
tree
of
the
matc
hing
-term.
Finally
,
Girard
un
v
eiled
in
[Gir	a
,
Gir
]
a
more
mathematical
in-
terpretation
of
the
cut-elimination
pro
cedure
of
linear
logic.
Again,
this
alternativ
e
computation
could
b
e
dened
as
the
computation
of
a
par-
ticular
set
of
paths
dened
on
the
nets
represen
ting
linear
logic
pro
ofs.


Paths
Namely
,
as
the
computation
and
comp
osition
of
a
set
of
r
e
gular
p
aths
dened
through
an
algebraic
and
computational
device,
the
so-called
dynamic
algebr
a
(see
the
w
ork
of
Danos
and
Regnier
[Dan	0
,
Reg	
,
DR	a
],
and
in
particular
[DR	
],
where
suc
h
an
approac
h
is
extended
to
pure
lambda-calculus).
The
surprising
fact
is
that,
although
the
previous
three
notions
ab
o
v
e
seems
to
b
ear
no
clear
relation
with
eac
h
other,
they
are
indeed
e
quiva-
lent.
.
Legal
P
aths
The
notion
of
le
gal
p
ath
arises
from
the
attempt
to
pro
vide
a
formal
c
haracterization
of
the
in
tuitiv
e
notion
of
\virtual
redex"|as
w
e
ha
v
e
already
seen,
a
conguration
inside
a
term
whic
h
is
not
y
et
a
redex,
but
that
migh
t
b
ecome
a
redex
along
the
reduction
of
the
term
(more
precisely
,
there
is
at
least
a
reduction
of
the
term
that
transforms
suc
h
an
application
in
to
a
redex).
Let
us
consider
for
instance
the
(lab
eled)
-term
(
),
represen
ted
in
Figure
..
a
@
b
f
x
y
c
g
@
@
d
e
h
k
x
x
y
y
Fig.
..
(
)
Let
us
tak
e
the
application
no
de
lab
eled
b
y
c
(note
that
the
lab
el
of
the
edge
ab
o
v
e
a
no
de
is
the
lab
el
of
the
corresp
onding
subterm
in
the
lab
eled
calculus).
Our
question
is:
\is
it
p
ossible
that
this
application
no
de
migh
t
b
e
ev
er
in
v
olv
ed
in
a
-reduction?".
In
order
to
answ
er
to
suc
h
a
question,
w
e
m
ust
lo
ok
for
a
-no
de
to
matc
h
against
the
applica-
tion.
W
e
start
our
searc
h
to
w
ards
the
left
son
of
the
@-no
de.
(According
to
Lafon
t's
terminology
[Laf	0
,
AL	a
],
this
is
the
princip
al
p
ort
of
the
application,
that
is,
the
only
p
ort
where
w
e
ma
y
ha
v
e
in
teraction
with
a
dual
op
erator;
see
the
denition
of
-rule.)
Th
us,
w
e
pass
the
edge
lab
eled
b
y
d
and
w
e
nd
a
v
ariable.
If
the
v
ariable
had
b
een
free,
w
e

.
L
e
gal
Paths

w
ould
ha
v
e
nished:
no
redex
in
v
olving
our
application
could
p
ossibly
exist;
but
this
is
not
the
case.
Besides,
since
the
v
ariable
is
b
ound,
the
\con
trol"
can
b
e
passed
bac
k
to
its
binder,
that
is
the
-abstraction
la-
b
eled
b
y
b
in
the
picture.
In
fact,
a
-reduction
in
v
olving
suc
h
a
binder
w
ould
replace
the
v
ariable
with
the
argumen
t
of
the
initial
application.
So,
to
con
tin
ue
our
searc
h
w
e
ha
v
e
to
en
ter
inside
suc
h
an
ev
en
tual
ar-
gumen
t.
Namely
,
w
e
ha
v
e
to
p
ose
a
symmetrical
question
ab
out
the
-no
de
w
e
ha
v
e
reac
hed:
\is
it
p
ossible
that
it
w
ould
b
e
ev
er
in
v
olv
ed
in
a
-reduction?".
Since
the
latter
question
concerns
a
-no
de,
w
e
m
ust
no
w
tra
v
el
to
w
ards
the
ro
ot
(note
that
this
is
still
the
principal
p
ort
of
the
-no
de,
according
to
Lafon
t).
W
e
nd
an
application.
Moreo
v
er,
for
w
e
en
ter
the
application
at
its
principal
p
ort,
w
e
ha
v
e
got
a
redex.
The
second
question
is
then
p
ositiv
ely
solv
ed;
so,
w
e
can
resume
our
initial
question,
con
tin
uing
our
searc
h
lo
oking
in
to
the
argumen
t
of
the
application
(that
is,
the
argumen
t
that
w
ould
replace
the
o
ccurrence
of
y
after
ring
the
redex
b).
Mo
ving
from
the
argumen
t
p
ort
of
the
appli-
cation
w
e
cross
the
edge
f
and
w
e
ev
en
tually
reac
h
the
principal
p
ort
of
a

no
de,
that
is,
w
e
nally
nd
a
(virtual)
redex
for
the
@-no
de
from
whic
h
w
e
started
our
searc
h.
As
a
result
of
the
previous
pro
cess,
in
addition
to
a
p
ositiv
e
answ
er
to
our
starting
question,
w
e
ha
v
e
also
collected
an
ordered
sequence
of
edges
dbf.
Moreo
v
er,
assuming
that
b
ound
v
ariables
are
explicitly
connected
to
(p
ositiv
e,
auxiliary
p
orts
of
)
their
resp
ectiv
e
binders|an
idea
going
bac
k
to
Bourbaki
that
w
e
ha
v
e
already
used
for
sharing
graphs;
suc
h
a
sequence
is
indeed
connected,
that
is,
it
is
a
\path"
in
the
usual
sense.
Because
of
this,
in
the
follo
wing,
ev
en
if
w
e
shall
not
explicitly
dra
w
suc
h
connections
in
the
pictures,
w
e
will
alw
a
ys
assume
that,
as
for
sharing
graphs,
also
in
the
syn
tax
trees
of
-terms
v
ariables
are
bac
k-connected
to
their
binders.
Summarizing
,
w
e
ma
y
sa
y
that
the
path
dbf
represen
ts
the
\virtual
redex"
(y
y).
In
fact,
b
y
ring
the
redex
b,
the
path
dbf
\con
tracts"
in
to
a
single
edge
corresp
onding
to
the
\actual"
redex
asso
ciated
to
the
path
dbf.
Let
us
no
w
consider
another
example
using
the
same
-term.
Starting
at
the
@-no
de
whose
top
edge
is
lab
eled
b
y
g,
w
e
tra
v
el
along
the
edge
h
(that
is,
bac
k
to
the
binder
of
y)
and
then
up
along
f.
As
in
the
former
example,
w
e
nd
an
@-no
de,
but
in
this
case
en
tering
it
at
argumen
t
p
ort
(its
negativ
e
auxiliary
p
ort,
not
its
principal
p
ort!).
So,
w
e
do
not
nd
a
redex,
and
to
con
tin
ue
w
e
m
ust
op
en
a
new
session,
lo
oking
for
a
(virtual)
redex
in
v
olving
the
@-no
de
whose
con
text
edge
is
lab
eled
b
y


Paths
a.
As
the
function
edge
b
of
the
@-no
de
is
a
redex,
this
new
session
immediately
ends
with
success,
and
to
con
tin
ue
w
e
ha
v
e
to
resume
the
initial
searc
h.
But,
since
at
the
end
of
the
inner
session
the
\con
trol"
w
as
coming
from
the
argumen
t
of
the
@-no
de
lab
eled
b
y
a,
w
e
m
ust
pass
con
trol
to
some
of
the
v
ariables
b
ound
b
y
the
-no
de
in
the
redex
b,
that
is
d
or
e
(note
the
non-determinism
of
the
searc
h
algorithm
at
this
p
oin
t).
Supp
ose
to
follo
w
the
rst
p
ossibilit
y
.
W
e
nd
the
same
redex
dbf
of
the
previous
computation
(ev
en
if
tra
v
eling
in
the
opp
osite
direction).
So,
w
e
ma
y
resume
the
initial
session
pro
ceeding
through
the
edge
e,
then,
mo
ving
from
the
binder
of
x,
up
along
the
redex
b,
and
nally
do
wn
along
f.
W
e
get
in
this
w
a
y
the
path
hfbdebf,
b
eginning
at
the
principal
p
ort
of
the
@-no
de
(y
y)
and
ending
at
the
principal
p
ort
of
the
-no
de
y.
Also
in
this
case,
the
path
w
e
get
corresp
onds
to
a
virtual
redex,
the
one
that
is
image
of
the
unique
redex
that
w
ould
b
e
created
after
t
w
o
reductions
of
(
)
(see
also
Example
..).
F
urthermore,
b
y
ring
rst
the
redex
b
and
then
the
(newly
created)
redex
dbf,
the
path
hfbdebf
con
tracts
in
to
a
single
redex-edge.
The
previous
t
w
o
examples
giv
e
an
informal
description
of
the
searc
h
algorithm
b
y
whic
h
to
nd
virtual
redexes,
or
more
precisely
,
b
y
whic
h
to
build
path
descriptions
of
virtual
redexes.
Unfortunately
,
the
previ-
ous
examples
are
greatly
simpler
than
the
general
case,
so
the
searc
h
algorithm
is
indeed
more
con
triv
ed
than
one
could
exp
ect
analyzing
the
case
met
so
far.
Besides,
the
second
path
that
w
e
ha
v
e
built
presen
ts
already
the
critical
issue
of
the
general
case,
for
at
a
certain
p
oin
t
w
e
add
to
c
hoice
b
et
w
een
t
w
o
o
ccurrences
of
the
same
v
ariable.
In
the
ex-
ample,
w
e
said
that
suc
h
a
c
hoice
in
tro
duces
in
the
algorithm
a
certain
degree
of
non-determinism,
for
in
this
case
b
oth
w
ere
v
alid
c
hoice;
on
the
con
trary
,
in
certain
situations,
it
is
not
true
that
coming
do
wn
through
a

the
algorithm
can
pro
ceed
non-deterministically
,
for
in
suc
h
cases
the
c
hoice
of
the
o
ccurrence
of
the
b
ound
v
ariable
m
ust
indeed
accord
with
the
part
of
the
path
already
built
to
reac
h
the
-no
de.
A
go
o
d
explanation
of
the
problem
can
b
e
found
b
y
insp
ection
of
the
follo
wing
example.
Example
..
Consider
the
-term
(x:
((x
M)
(x
N))
y:
y),
repre-
sen
ted
in
Figure
..
Let
us
supp
ose
w
e
are
lo
oking
for
a
-no
de
to
matc
h
against
the
application
lab
eled
c.
Mo
ving
from
this
application,
w
e
go
do
wn
through
d,
do
wn
again
through
f,
bac
k
to
b,
and
then
do
wn
through
l.
W
e
nd
in
this
w
a
y
a
-no
de
matc
hing
the
application
la-
b
eled
d.
Since
w
e
en
tered
this
application
from
the
top,
w
e
con
tin
ue

.
L
e
gal
Paths

a
@
b
l
x
y
c
m
@
y
d
e
@
f
x
g
M
@
h
x
k
N
Fig.
..
(x:
((x
M)
(x
N))
y:
y)
our
searc
h
inside
the
b
o
dy
of
the
.
So,
w
e
go
do
wn
through
m,
bac
k
through
l,
and
do
wn
through
b.
W
e
reac
h
in
this
w
a
y
the
principal
p
ort
of
the
-no
de
x,
and
to
con
tin
ue
w
e
ha
v
e
to
c
ho
ose
an
o
ccurrence
of
its
v
ariable
x.
In
the
previous
examples,
suc
h
a
c
hoice
w
as
free,
in
this
case
instead,
only
the
c
hoice
of
the
o
ccurrence
lab
eled
f
is
correct.
The
in
tuition
should
b
e
clear:
since
w
e
en
tered
the
argumen
t
of
the
appli-
cation
coming
from
this
o
ccurrence
of
the
v
ariable,
w
e
are
conceptually
w
orking
inside
the
instance
of
the
argumen
t
replacing
suc
h
a
particular
o
ccurrence
x
(in
some
reduction
of
the
initial
term);
th
us,
w
e
cannot
jump
to
a
dieren
t
instance,
it
w
ould
b
e
as
jumping
from
a
p
oin
t
of
a
subterm
to
a
corresp
onding
p
oin
t
of
a
distinct
instance
of
the
same
subterm.
Because
of
this,
let
us
assume
w
e
correctly
c
ho
ose
f:
w
e
nd
(again,
but
tra
v
eling
in
the
opp
osite
direction)
the
application
matc
hing
the

lab
eled
l.
Since
w
e
en
ter
this

through
the
b
ound
v
ariable,
w
e
m
ust
exit
the
application
through
the
argumen
t
p
ort
lab
eled
g,
pursuing
the
searc
h
inside
M.
If
M
starts
with
a
,
w
e
ha
v
e
found
the
virtual
re-
dex
w
e
w
ere
lo
oking
for;
otherwise,
there
is
no
virtual
redex
b
et
w
een
the
application
lab
eled
c
and
M.
On
the
con
trary
,
b
ecause
of
the
previous
argumen
ts
ab
out
the
c
hoice
of
the
o
ccurrence
of
x
to
pass
through
after
the
path
dfblmlb,
no
virtual
redex
can
exist
b
et
w
een
the
application
lab
eled
c
and
N,
indep
enden
tly
from
the
shap
e
of
N.
The
previous
example
p
oin
ts
out
that
the
in
v
olv
ed
case
arises
in
pres-
ence
of
a
lo
op
inside
the
argumen
t
P
of
an
application.
In
suc
h
a
sit-
uation
w
e
are
in
fact
forced
to
follo
w
the
same
path
w
e
used
to
en
ter
the
argumen
t
P
(ev
en
if
crossing
it
in
the
opp
osite
direction),
up
to
the
o
ccurrence
of
the
v
ariable
indicating
the
particular
instance
of
P
w
e
w
ere


Paths
considering.
The
precise
formalizatio
n
of
the
previous
in
tuition
requires
a
complex
inductiv
e
denition
that
will
b
e
discussed
in
section
..
Our
aim,
for
the
momen
t,
w
as
just
to
pro
vide
the
main
in
tuitions
b
ehind
the
path-description
of
\virtual"
redexes
in
a
-term
T
.
According
to
suc
h
an
in
tuition,
ev
ery
\virtual"
redex
of
T
denes
a
suitable
\legal"
path
in
the
syn
tax
tree
of
T
connecting
the
function
part
of
an
application
to
the
top
of
a
-no
de.
The
natural
question
at
this
p
oin
t
is
if
also
the
con
v
erse
hold,
that
is,
do
dieren
t
\virtual"
redexes
dene
dieren
t
paths?
Due
to
a
duplication
issue,
the
answ
er
to
this
question
is
instead
no.
F
or
instance,
let
us
consider
a
term
T
=
(x:
M
N)
with
a
redex
r
inside
N.
The
redex
r
ma
y
ha
v
e
sev
eral
residuals
in
M[N=x];
ev
en
though
all
these
dieren
t
residuals
corresp
ond
to
the
same
path
in
T
.
This
fact,
that
at
a
rst
glance
migh
t
seem
negativ
e,
suggests
instead
that
w
e
can
reasonably
hop
e
to
ha
v
e
an
injection
from
\virtual"
redexes
to
paths,
up
to
some
notion
of
\sharing"
that
w
e
should
hop
e
to
b
e
the
optimal
one
of
L

evy
.
By
the
w
a
y
,
this
is
indeed
the
case,
for
there
is
a
bije
ctive
c
orr
esp
ondenc
e
b
et
w
een
L

evy's
families
of
redexes
and
the
class
of
legal
paths
that
w
e
ha
v
e
informall
y
in
tro
duced
b
y
the
previous
examples.
In
other
w
ords:
two
r
e
dexes
ar
e
in
a
same
L

evy's
family,
if
and
only
if
their
asso
ciate
d
p
aths
in
the
initial
term
of
the
derivation
c
oincide.
The
relev
an
t
p
oin
t
with
this
corresp
ondence
is
that
the
formal
denition
of
legal
path
(see
section
.)
get
rid
of
the
lab
els
assigned
to
the
edges
of
the
(lab
eled)
-term.
Th
us,
the
notion
of
le
gal
p
ath
pro
vides
a
complete
c
haracterization
of
virtual
redexes
indep
enden
t
from
lab
els.
..
R
eminder
on
lab
ele
d
-c
alculus
F
or
ease
of
reference,
w
e
recall
the
main
denitions
of
the
lab
eled
-
calculus.
Let
L
=
fa;
b;
:
:
:
g
b
e
a
den
umerable
set
of
atomic
lab
els.
The
set
L
of
lab
els,
ranged
o
v
er
b
y
`;
`
0
;
:
:
:
;
`
0
;
`

;
:
:
:
,
is
dened
b
y
the
follo
wing
rules:
a
j
`

`

j
`
j
`
The
op
eration
of
concatenation
of
lab
els
`

`

is
assumed
to
b
e
asso
cia-
tiv
e.
The
set
L
p
of
pr
op
er
lab
els
con
tains
exactly
all
those
lab
els
`

L
suc
h
that
`
is
atomic
or
`
=
`
0
or
`
=
`
0
.

.
L
e
gal
Paths

The
set
L
p
will
b
e
ranged
o
v
er
b
y
;
;
:
:
:
.
Giv
en
a
lab
el
`,
at(`)
is
the
set
of
all
its
atomic
(sub)lab
els.
The
set

L
V
of
lab
eled
-terms
o
v
er
a
set
V
of
v
ariables
and
a
set
L
of
lab
els
is
dened
as
the
smallest
set
con
taining:
(i)
x
`
,
for
an
y
x

V
and
`

L;
(ii)
(M
N)
`
,
for
an
y
M;
N


L
V
and
`

L;
(iii)
(x:
M)
`
,
for
an
y
M


L
V
and
`

L.
Lab
eled
-reduction
is
the
follo
wing
rule
(remind
that
`
0

(T
)
`

=
(T
)
`
0
`

,
where
T
is
either
a
v
ariable,
a
comp
osition
of
lab
eled
terms,
or
an
abstraction
of
a
lab
eled
term):
((x:M)
`
0
N)
`

!
`


`
0

M[`
0

N=x]
The
lab
el
`
0
is
the
de
gr
e
e
of
the
redex
((x:M)
`
0
N)
`

.
Let
M
b
e
a
lab
eled
-term.
The
predicate
INIT(M)
is
true
if
and
only
if
the
lab
els
of
all
subterms
of
M
are
atomic
and
pairwise
distinct.
Giv
en
a
lab
eled
term
M,
w
e
shall
denote
b
y
M
I
a
lab
eled
-term
equal
to
M
up
to
lab
eling,
suc
h
that
INIT(N
I
)
is
true.
If
M


N
and
u
is
a
redex
of
M,
w
e
shall
denote
b
y
degree

M
(u)
the
degree
of
u
after
the
lab
eled
reduction
of
M
I
isomorphic
to
;
at
the
same,
w
e
will
con
tin
ue
to
use

to
denote
suc
h
an
isomorphic
reduction,
i.e.,
M
I


N
?
,
where
N
?
is
equal
to
N
up
to
sharing.
In
other
w
ords,
t
w
o
lab
eled
reductions
are
equated
when
they
corresp
ond
to
the
same
unlab
eled
one.
The
map
(

)
I
is
a
sort
of
standar
d
initial
lab
eling
function
asso
ciating
a
lab
eled
term
M
I
to
eac
h
(lab
eled)
term
M,
with
the
pro
viso
that
INIT(M
I
)
holds
for
an
y
M.
According
to
this,
degree

M
(u)
is
the
degree
of
the
redex
u
with
resp
ect
to
the
reduction

and
to
the
standard
initial
lab
eling
of
M
The
set
L
0
(M)
is
the
set
of
all
the
lab
els
con
tained
in
the
lab
eled
term
M
I
;
the
set
L(M)
is
the
set
of
all
the
lab
els
obtainable
reducing
M
I
,
that
is,
L(M)
=
S
fL
0
(N)
j
M
I

Ng.
Let
us
remark
that
b
oth
the
denition
of
degree
and
L
are
indep
en-
den
t
from
the
actual
initial
lab
eling
of
the
term
M.
In
fact,
in
b
oth
of
them
w
e
use
its
standard
initial
lab
eling.
This,
in
conjunction
with
the
assumption
that
w
e
equates
reductions
up
to
the
lab
els
of
the
terms
in
v
olv
ed,
will
allo
w
us
to
freely
mix
lab
eled
and
unlab
eled
reductions.
In
fact,
when
not
otherwise
sp
ecied,
the
lab
eled
reductions
w
e
are
in-
terested
in
is
the
one
in
whic
h
the
lab
els
of
the
initial
term
are
assigned
according
to
the
standard
initial
lab
eling.


Paths
..
L
ab
els
and
p
aths
Lab
els
pro
vide
a
v
ery
simple
approac
h
to
the
notion
of
computation
as
a
tra
v
el
along
a
path.
In
particular,
ev
ery
lab
el
trivially
denes
a
path
in
the
initial
term.
The
in
teresting
problem
will
b
e
to
pro
vide
an
indep
enden
t
c
haracterization
of
these
paths
(see
Section
.).
Before
to
see
the
corresp
ondence
b
et
w
een
lab
els
and
paths,
let
us
remind
that
in
the
graph
represen
tation
of
-terms
that
w
e
assumed
to
use,
b
ound
v
ariables
are
explicitly
connected
to
the
resp
ectiv
e
binders|
this
assumption
is
ob
viously
crucial
in
order
to
obtain
connected
paths.
F
urthermore,
let
us
also
note
that,
giv
en
a
lab
eled
term
M,
ev
ery
edge
of
-term
M
I
is
lab
eled
with
a
distinct
atomic
sym
b
ol;
as
a
consequence,
when
it
will
not
cause
confusion,
eac
h
edge
of
M
will
b
e
denoted
b
y
the
the
lab
el
marking
it
in
M
I
.
Denition
..
If
`
is
the
lab
el
of
an
edge
generated
along
some
re-
duction
of
the
lab
eled
-term
M
I
(i.e.,
`

L(M)),
the
p
ath
of
`
in
the
-term
M
is
inductiv
ely
dened
as
follo
ws:
path
(a)
=
a
path
(`

`

)
=
path
(`

)

path
(`

)
path
(`)
=
path
(`)
path
(`)
=
(path
(`))
r
where
path
(`

)

path
(`

)
denotes
the
concatenation
of
the
corresp
onding
t
w
o
paths
(in
the
follo
wing
w
e
will
usually
omit
\"
concatenating
paths),
while
(path
(`))
r
is
the
path
obtained
rev
ersing
path
(`).
By
induction
on
the
length
of
the
deriv
ation
generating
the
lab
el
`,
it
is
readily
seen
that
the
denition
of
path
is
sound,
i.e.,
that
path
(`)
is
a
path
of
M
(it
is
indeed
an
immediate
consequence
of
Lemma
..).
F
urthermore,
path
(`)
connects
no
des/p
orts
of
the
same
t
yp
e
of
the
ones
connected
b
y
the
edge
lab
eled
b
y
`.
F
act
..
If
`
is
the
lab
el
of
an
e
dge
u
gener
ate
d
along
some
r
e
duction
of
M
I
,
then
u
and
path
(`)
c
onne
cts
c
orr
esp
onding
p
orts
of
no
des
of
c
or-
r
esp
onding
typ
e.
F
or
instanc
e,
if
u
is
a
r
e
dex,
then
path
(`)
c
onne
cts
the
function
(left)
p
ort
of
an
applic
ation
of
M
to
the
c
ontext
(top)
p
ort
of
an
abstr
action
of
M.
The
in
tuitiv
e
idea
b
ehind
the
denition
of
the
paths
asso
ciated
to
la-

.
L
e
gal
Paths
	
b
els
is
that
a
redex
with
degree
`
is
ev
en
tually
obtained
b
y
\con
traction"
of
path(`).
λx
λx
@
a
b
d
e
c
@
x
x
@
x
x
f
g
h
i
λx
λx
λx
λx
@
@
x
x
@
x
x
g
h
i
abc
ebf
g
h
i
dbf
@
@
x
x
@
x
x
g
h
i
abcdbfg
idbfebf
hdbfebf
g
h
i
Fig.
..
(x:
(x
x)
x:
(x
x))
Example
..
Consider
again
the
term
(
)
giv
en
at
the
b
eginning
of
the
c
hapter.
After
t
w
o
reductions,
w
e
obtain
a
redex
with
degree
`
=
hdb
febf
(see
Figure
.).
Th
us,
path
(`)
=
hfbdebf,
that
is
the
path
w
e
obtained
in
the
in
tro
duction
to
the
c
hapter
for
the
application
lab
eled
with
g.
The
in
teresting
p
oin
t
is
that
dieren
t
degrees
dene
dieren
t
paths
in
the
initial
term.
The
pro
of
of
suc
h
a
claim
requires
a
b
etter
comprehen-
sion
of
the
structure
of
lab
els.
Hence,
as
a
preliminary
remark,
let
us
note
that
an
y
lab
el
`
can
b
e
written
as
the
concatenation
of
a
(unique)
sequence
of
prop
er
lab
els






n
.
Then,
let
us
analyze
in
more
detail
the
shap
e
of
suc
h
a
sequence
of
prop
er
lab
els.
Lemma
..
L
et






n

L(M);
wher
e

i

L
p
(i.e.,

i
is
either
atomic
or
an
over/underline
d
lab
el),
for
i
=
;
:
:
:
;
n.
Then:
(i)
The
length
n
of






n
is
o
dd.
(ii)
F
or
every
i
o
dd,

i
is
atomic.
(iii)
F
or
every
i
even
(i.e.,
i
=
j),
either

i
=
`
or

i
=
`,
for
some
`

L(M)
such
that
path
(`)
starts
at
the
function
(left)
p
ort
of
an
applic
ation
and
ends
at
the
c
ontext
of
an
abstr
action
of
M.
F
urthermor
e:
(a)
when

j
=
`,
then:
.

j-
is
the
c
ontext
(top)
e
dge
of
the
@-no
de
fr
om
which
path
(`)
starts;
.

j+
is
the
c
ontext
(top)
e
dge
of
the
-no
de
to
which
path
(`)
ends;

0
Paths
(b)
when

j
=
`,
then:
.

j-
is
a
binding
e
dge
of
the
-no
de
to
which
path
(`)
ends;
.

j+
is
the
ar
gument
(right)
e
dge
of
the
@-no
de
fr
om
which
path
(`)
starts.
Pr
o
of
By
an
easy
induction
on
the
length
of
the
deriv
ation.
Remark
..
An
imm
ediate
corollary
of
the
previous
prop
osition
is
that
the
degree
`
of
a
redex
ma
y
app
ear
inside
another
lab
el
only
o
v
er/underlined
and
surrounded
b
y
atomic
lab
els.
Vice
v
ersa,
an
y
o
v
er/underlined
lab
el
is
the
degree
of
some
redex.
Another
consequence
of
the
ab
o
v
e
prop
osition
is
that
b
oth
o
v
er
and
underlines
can
b
e
erased
from
L

evy's
lab
els
without
an
y
loss
of
informa-
tion,
as
the
lining
of
suc
h
a
at
lab
el
can
b
e
reco
v
ered
using
the
result
of
the
previous
lemma.
Corollary
..
Overlining
and
underlining
c
ould
b
e
safely
omitte
d
in
the
denition
of
lab
ele
d
-c
alculus,
i.e.,
its
-rule
c
ould
b
e
r
eplac
e
d
by
a
rule
e
quivalent
in
al
l
r
esp
e
cts
to
the
old
one
but
for
the
fact
that
the
lines
ab
ove
or
b
elow
lab
els
ar
e
omitte
d.
Pr
o
of
Remo
v
e
all
the
o
v
er/underlines
con
tained
in
a
lab
el
`.
This
can
b
e
formalized
b
y
a
function
at
equal
to
path
whose
denition
is
similar
to
the
one
of
path
except
for
at(`)
=
at(`).
The
initial
structure
of
`
can
b
e
inductiv
ely
retriev
ed
applying
Lemma
..
and
w
orking
inside-out.
Namely
,
starting
from
the
atomic
lab
els
of
at(`)
relativ
e
to
redexes,
w
e
o
v
er/underline
eac
h
of
them
them
according
to
the
lab
els
surrounding
it
(note
that
this
step
is
uniquely
determined
b
y
the
initial
lab
eling
of
the
term).
Iterating
the
pro
cess
with
the
structured
lab
els
yielded
so
far,
w
e
ev
en
tually
get
a
lab
el
`
0
suc
h
that
at(`
0
)
=
at(`).
Since
the
pro
cedure
applied
to
build
`
0
is
deterministic,
w
e
conclude
that
`
0
is
the
unique
lab
el
ha
ving
this
prop
ert
y
that
accords
to
the
prop
erties
of
Lemma
...
That
is,
`
0
=
`.
The
deep
reason
b
ehind
the
previous
result
is
the
tigh
t
corresp
ondence
b
et
w
een
paths
and
lab
els
that
w
e
are
pursuing.
With
this
resp
ect
the
rst
prop
ert
y
w
e
can
sho
w
is
that
t
w
o
distinct
lab
els
arising
during
the
reduction
of
a
term
M
I
alw
a
ys
corresp
ond
to
distinct
paths.
The
relev
an
t
p
oin
t
is
that
in
this
claim
w
e
do
not
mak
e
an
y
assumption
on

.
L
e
gal
Paths

the
terms
in
whic
h
the
t
w
o
lab
els
app
ear,
so
they
migh
t
also
mark
edges
of
t
w
o
distinct
terms.
Prop
osition
..
The
function
path
is
inje
ctive
over
L(M).
Pr
o
of
Let
`

and
`

b
e
t
w
o
distinct
lab
els
in
L(M).
The
pro
of
that
path
(`

)
=
path
(`

)
is
b
y
induction
on
the
structure
of
`

.
The
case
`

atomic
is
imm
ediate.
Th
us,
let
`

=






n
.
If
`

=
`

`
(or
vice
v
ersa),
the
thesis
follo
ws
trivially
,
since
the
t
w
o
paths
ha
v
e
dieren
t
lengths.
An
yho
w,
let
us
note
that
the
previous
situation
is
not
the
case
when
either
`

or
`

is
the
degree
of
some
redex
(b
y
the
remark
on
Lemma
..).
Hence,
let
us
assume
that
`

=






m
and
that
k
is
the
rst
index
suc
h
that

k
=

k
.
According
to
Lemma
..,
w
e
can
distinguish
t
w
o
cases:
(k
is
o
dd
)
In
this
case,
b
oth

k
and

k
are
atomic,
that
is,

k
and

k
are
distinct
edges
of
M.
Th
us,
the
t
w
o
paths
div
erge
here.
(k
is
even
)
In
this
case,
either

k
=
`
0

or

k
=
`
0

,
for
some
degree
`
0

;
and
analogously
for

k
and
some
degree
`
0

.
F
urthermore,
either
b
oth

k
and

k
are
o
v
erlined
or
b
oth
of
them
are
underlined
(i.e.,
it
is
not
the
case
that

k
=
`
0

and

k
=
`
0

,
or
vice
v
ersa),
for
b
y
h
yp
othesis

k-
=

k-
.
Since
`
0

;
`
0


L(t)
and
`
0

=
`
0

,
b
y
inductiv
e
h
yp
othesis
w
e
get
that
path
(`
0

)
=
path
(`
0

).
As
w
e
already
remark
ed,
in
suc
h
a
case
neither
`
0

can
b
e
a
prex
of
`
0

,
nor
`
0

can
b
e
a
prex
of
`
0

.
So,
since
b
oth
path
(`
0

)
and
path
(`
0

)
start
at
the
function
p
ort
of
the
same
application
and
end
at
the
con
text
p
ort
of
the
same
abstraction,
there
are
t
w
o
paths


and


starting
and
ending
with
distinct
edges
suc
h
that
path
(`
0
i
)
=

i
 ,
for
t
w
o
non
empt
y
paths

and
 
and
i
=
;
.
W
e
conclude
then
that
path
(`

)
and
path(`

)
div
erge
after
a
common
prex
 
r
or
,
where

=
path
(





k-
).
In
fact,
when

k
and

k
are
underlined,
w
e
get
path
(`

)
=
 
r

r


r


and
path
(`

)
=
 
r

r


r


,
for
some
paths


and


;
while
when

k
and

k
are
o
v
erlined,
w
e
get
path(`

)
=


 

and
path
(`

)
=


 

.
Exercise
..	
Giv
e
an
algorithm
dening
a
function
pathtolab
from
paths
of
M
to
L

evy's
lab
els
suc
h
that
pathtolab
(path
(`))
=
`,
for
an
y
`

L(M).


Paths
..
The
e
quivalenc
e
b
etwe
en
extr
action
and
lab
eling
In
Chapter

w
e
ha
v
e
sho
wn
that
all
the
redexes
of
a
family
b
ear
the
same
degree
(see
Theorem
..).
T
o
complete
the
pro
of
of
the
equiv
alence
b
et
w
een
extraction
and
lab
eling,
w
e
need
to
pro
v
e
that
t
w
o
redexes
ha
v
e
the
same
degree
only
if
they
are
in
the
same
family
.
(Let
us
remind
again
that
a
k
ey
assumption
in
this
is
that
INIT
holds
for
the
initial
term;
but,
as
all
the
lab
els
w
e
will
compute
are
relativ
e
to
the
reduction
of
a
term
M
I
,
this
is
denitely
the
case.)
The
corresp
ondence
b
et
w
een
lab
els
and
paths
is
expressed
b
y
the
fol-
lo
wing
theorem,
of
whic
h
w
e
ha
v
e
to
pro
v
e
the
\if
"
part
only
,
for
the
\only
if
"
directions
is
an
immedia
te
consequence
of
Theorem
...
Theorem
..0
L
et
M


N

and
M


N

.
Then
u
'
v
if
and
only
if
degree

M
(u)
=
degree

M
(v).
The
corresp
ondence
b
et
w
een
paths
and
lab
els
w
e
presen
ted
in
the
rst
part
of
this
c
hapter
giv
es
a
w
a
y
to
complete
the
pro
of
of
this
equiv
alence.
In
order
to
giv
e
the
full
details
of
suc
h
a
pro
of,
w
e
need
the
follo
wing
t
w
o
preliminary
lemmas.
Lemma
..
(First
Redex
Lemma)
L
et
v
b
e
a
r
e
dex
with
his-
tory

such
that
v
is
c
anonic
al.
L
et
u
b
e
the
leftmost-outermost
r
e
dex
of
M
for
which
degree

M
(u)

at(degree

M
(v)).
Then
u
is
the
rst
r
e
dex
r
e
d
by
.
Lemma
..
(Con
tracted
Lab
el
Lemma)
L
et
M
w
!
N


N

u
!
and
M
w
!
N


N

v
!
b
e
two
derivations
such
that
b
oth
wu
and
wu
ar
e
c
anonic
al.
Then
degree
w
M
(u)
=
degree
w
M
(v)
)
degree

N
(u)
=
degree

N
(v):
W
e
p
ostp
one
the
pro
of
of
suc
h
lemmas
to
the
end
of
the
section,
after
the
pro
of
of
the
main
theorem.
The
in
tuitiv
e
idea
b
ehind
suc
h
pro
ofs
is
v
ery
simple.
In
the
case
of
the
rst
redex
lemma,
w
e
observ
e
that
ev
ery
redex
tra
v
ersed
b
y
the
path
asso
ciated
to
the
degree
of
a
redex
v
is
needed
for
its
creation.
As
a
consequence,
the
leftmost-outermost
of
suc
h
redexes
should
denitely
b
e
the
rst
one
red
along
the
deriv
ation

suc
h
that
v
is
canonical.
In
the
case
of
the
second
lemma,
w
e
already
kno
w
that
if
degree

N
(u)
=
degree

N
(v)
they
dene
dieren
t
paths
in
N.
No
w,
in
an
y
lab
eled
reduction
starting
with
M
I
,
the
only
p
ossibilit
y
that
these
paths
get
a
same
lab
eling
is
that
they
are
isomorphic
paths

.
L
e
gal
Paths

inside
dieren
t
instances
of
the
argumen
t
of
the
redex
w.
But
this
case
is
excluded
b
y
canonicit
y
,
for
in
suc
h
a
case
w
e
could
apply
the
last
rule
of
the
extraction
relation
(see
Denition
..).
...
Pr
o
of
of
The
or
em
..0
The
\only
if
"
direction
of
the
theorem
has
b
een
already
pro
v
ed
b
y
The-
orem
...
Th
us,
w
e
left
to
sho
w
that:
degree

M
(u)
=
degree

M
(v)
)
u
'
v
As
a
consequence
of
the
fact
that
u
'
v
)
degree

M
(u)
=
degree

M
(v)
has
b
een
already
pro
v
ed,
w
e
can
restrict
to
the
case
in
whic
h
u
and
v
are
canonical.
F
urthermore,
b
ecause
of
the
uniqueness
of
the
canonical
form,
this
also
means
that
the
former
implication
is
equiv
alen
t
to:
u
=
v
)
degree

M
(u)
=
degree

M
(v)
where
u
and
v
are
canonical.
The
pro
of
pro
ceed
b
y
induction
on
the
length
of
:
(b
ase
c
ase
:

=
)
In
this
case
u
is
a
redex
of
the
initial
term
M;
its
lab
el
is
th
us
atomic.
As
a
consequence,
the
prop
ert
y
immedi-
ately
holds
when
degree

M
(v)
is
not
atomic.
F
urthermore,
let
us
assume
that
degree

M
(v)
is
atomic.
Since
v
is
canonical,

=

(w
e
in
vite
the
reader
to
c
hec
k
that,
if
this
w
as
not
the
case,
then
w
e
could
apply
at
least
one
of
the
rules
of
the
extraction
relation).
Then,
b
y
the
denition
of
degree
,
w
e
conclude
noting
that
degree

M
(u)
=
degree

M
(v)
if
and
only
if
u
=
v.
(induction
c
ase
:

=
w
0
)
Let

=
w
0

0
(let
us
assume
without
loss
of
generalit
y
that

is
not
longer
than
).
By
h
yp
othesis,

and

are
standard;
then,
b
y
Lemma
..,
degree

M
(w)
and
degree

M
(w
0
)
are
the
lab
els
of
the
leftmost-outermost
redexes
in
at(degree

M
(u))
and
at(degree

M
(v)),
resp
ectiv
ely
.
As
an
imme-
diate
consequence,
degree

M
(u)
=
degree

M
(v),
when
w
=
w
0
.
Hence,
let
us
assume
w
=
w
0
and
M
w
!
N.
In
suc
h
a
case
u
=
v
only
if

0
u
=

0
v.
Then,
b
y
the
inductiv
e
h
yp
othe-
sis,
w
e
get
degree

N
(u)
=
degree

N
(v),
and
b
y
Lemma
..,
w
e
conclude
that
degree
w
M
(u)
=
degree
w
M
(v).
The
original
pro
of
giv
en
b
y
L

evy
in
his
thesis
([L

ev,
pp.
{])
w
as
m
uc
h
con
triv
ed
than
the
one
presen
ted
here.
L

evy's
pro
of
based
on
a
complex
notion
of
lab
eled
sub
con
texts,
and
it
tak
es
o
v
er
than
fort
y


Paths
pages.
It
is
in
teresting
to
note
that
his
induction
on
the
length
of
the
deriv
ation
w
ork
ed
in
the
opp
osite
direction,
i.e.,
considering
the
tail
redex
of
the
canonical
deriv
ations.
The
main
reason
b
ehind
the
sim-
plication
of
the
pro
of
presen
ted
here
(that
w
as
published
for
the
rst
time
in
[AL	b
])
is
that
it
tak
es
adv
an
tage
of
the
structural
prop
erties
of
lab
els
that
L

evy
did
not
notice
at
that
time|in
particular,
it
rests
on
the
corresp
ondence
b
et
w
een
lab
els
and
paths.
...
Pr
o
of
of
the
First
R
e
dex
L
emma
(L
emma
..)
By
induction
on
the
length
of
the
deriv
ation
.
The
base
case
(
=
)
is
v
acuous.
Hence,
let

=
u
0
and
M
I
u
!
N.
W
e
pro
ceed
then
b
y
induction
on

0
:
(
0
=
)
Since
uv
is
canonical,
v
is
not
a
redex
of
M,
it
has
instead
b
een
created
b
y
executing
u.
In
more
details,
let
v
b
e
((y:
S)
`
T
)
`
0
in
N.
If
the
redex
u
is
((x:
P
)
a
Q)
b
in
M
I
(note
that,
since
w
e
are
considering
M
I
,
the
lab
els
in
u
are
atomic),
then
((x:
P
)
a
Q)
b
u
!
b

a

P
[a

Q=x].
Accordingly
,
w
e
ha
v
e
t
w
o
p
ossibilities:
(i
)
the
term
M
I
con
tains
(((x:
P
)
a
Q)
b
T
)
`
0
and
P
=
(y:
S
0
)
c
,
with
S
=
S
0
[a

Q=x];
(ii
)
Q
=
(y:
S)
c

and
the
term
P
con-
tains
((x)
c

T
0
)
`
0
,
where
x
is
b
ound
b
y
the
abstraction
of
u
and
T
=
T
0
[a

Q=x].
It
is
immediate
to
see
that,
corresp
ondingly
,
w
e
ha
v
e
either
`
=
ba
c
and
`
=
c

a
c

,
that
is,
a
is
the
unique
degree
of
a
redex
con
tained
in
at(`).
Hence,
as
`
=
degree

M
(v)
and
a
=
degree

M
(u),
w
e
conclude.
(
0
=
w
00
)
Let
degree

M
(u)
=
a.
F
or
an
y
degree
`
of
a
redex
of
N,
only
t
w
o
cases
ma
y
hold:
(i
)
`
is
atomic
and
`

L
0
(M);
(ii
)
there
are
t
w
o
atomic
lab
els
b;
c

L
0
(M)
suc
h
that
`
=
bc,
with


fa:ag.
F
urthermore,
in
the
rst
case,
the
redex
is
the
residual
of
a
redex
of
M;
in
the
second,
the
redex
has
b
een
created
b
y
the
execution
of
u,
and
none
of
the
atomic
lab
els
b
and
c
can
b
e
the
degree
of
a
redex
of
M.
As
an
immedia
te
consequence,
w
e
get
then
that
at(degree

M
(v))
=
at(degree

0
N
(v))
[
a
(w
e
in
vite
the
reader
to
pro
v
e
it
using
the
results
of
Exercise
..).
Hence,
for
an
y
redex
u
0
=
u
suc
h
that
degree

M
(u
0
)

at(degree

M
(v))
and
an
y
redex
w
0

u
0
=u,
then
degree

N
(w
0
)

at(degree

0
N
(v)).
By
the
induction
h
yp
othesis
(note
that

0
v
=
w
00
v
is
canonical),
w
is
the
leftmost-outermost
redex
of
N
for
whic
h
degree

N
(w)

at(degree

0
N
(v)).
So,
w
is
leftmost-outermost
with
resp
ect
to
w
0
.
By
this
and
the
h
yp
othesis
that

is
canonical,
it
follo
ws
that

.
L
e
gal
Paths

uw(w
0
=w)
=
uw(u
0
=uw)
is
a
standard
reduction
of
M.
Then,
u
is
leftmost-outermost
with
resp
ect
to
u
0
.
Exercise
..
An
atomic
lab
el
substitution
is
a
function
s
from
atomic
lab
els
to
L.
The
previous
function
extends
to
generic
lab
els
in
the
natu-
ral
w
a
y
,
i.e.,
to
apply
the
atomic
lab
el
substitution
s
to
a
lab
el
`
means
to
build
the
lab
el
`[s]
obtained
replacing
eac
h
atomic
lab
el
a
of
`
b
y
the
lab
el
s(a).
The
relab
eling
b
y
s
of
a
lab
eled
term
M
is
the
term
M[s]
obtained
from
M
b
y
applying
s
to
eac
h
lab
el
`

L
0
(M).
The
usual
comp
osition
rule
of
functions
induces
in
a
natural
w
a
y
a
notion
of
com-
p
osition
of
atomic
lab
el
substitutions,
i.e.,
ss
0
is
the
substitution
suc
h
that
`[ss
0
]
=
(`[s
0
])[s],
and
analogously
for
relab
eling
of
terms.
Pro
v
e
that:
(i)
An
y
reduction
M
I


N
induces
an
atomic
lab
el
substitution
s

suc
h
that
N
=
N
I
[s

],
and
that
at(s

(a))

L
0
(M
I
),
for
an
y
a

L
0
(N
I
).
(ii)
M[s]


N[s]
for
an
y
atomic
lab
el
substitution
s
and
an
y
M


N.
(iii)
F
or
an
y

=
,
then
s

=
s

s

.
Exercise
..
The
atomic
lab
el
substitution
dened
in
the
previous
exercise
can
b
e
extended
to
paths.
Namely
,
if
M
I


N,
the
e
dge
sub-
stitution
induced
b
y
the
atomic
lab
el
substitution
s

is
a
transformation
[s

]
of
the
paths
of
N
suc
h
that
path
(degree

M
(u))
=
path(degree

N
(u))[s

].
Giv
e
a
formal
denition
of
suc
h
a
transformation
of
paths
and
pro
v
e
that
[s

]
is
a
path
of
M,
for
an
y
path

of
N,
and
that
edge
substitution
ac-
cords
to
the
comp
osition
la
w
[s

]
=
[s

s

]
=
([s

])[s

].(W
arning:
[s

]
is
not
just
the
concatenation
of
the
transformations
of
the
edges
of
N.
In
fact,
assuming
to
orien
t
paths,
an
edge
of
N
ma
y
app
ear
in

according
its
p
ositiv
e
or
to
its
negativ
e
orien
tation.)
...
Pr
o
of
of
the
Contr
acte
d
L
ab
el
L
emma
(L
emma
..)
Let
us
remind
the
h
yp
otheses:
M
w
!
N;
the
t
w
o
redexes
wu
and
wv
are
in
canonical
form;
degree
w
M
(u)
=
degree
w
M
(v).
W
e
w
an
t
to
pro
v
e
that
suc
h
h
yp
otheses
imply
degree

N
(u)
=
degree

N
(v).
Let

=
path
(degree

N
(u))
and
 
=
path
(degree

N
(v)).
By
the
deni-
tion
of
edge
substitution
giv
en
in
Exercise
..,
w
e
ha
v
e
that
path
(degree
w
M
(u))
=
u[s
w
s

]
=
(u[s

])[s
w
]
=
[s
w
],
and
analogously
path
(degree
w
M
(v))
=
 [s
w
].
By
h
yp
othesis,
w
e
ha
v
e
th
us

=
[s
w
]
=
 [s
w
].
W
e
w
an
t
to
pro
v
e
that

=
 .


Paths
Let
a
=
degree

M
(w).
W
e
start
noticing
that

cannot
b
e
in
ternal
to
the
argumen
t
of
w,
for
b
y
the
First
Redex
Lemma
w
e
m
ust
ha
v
e
a

at(degree

M
(u))
(see
also
Exercise
..).
T
o
complete
the
pro
of
w
e
sho
w
that
the
follo
wing
claim
is
true:
Let

and
 
b
e
t
w
o
paths
of
N
suc
h
that
[s
w
]
=

=
 [s
w
].
If

and
 
are
not
in
ternal
to
distinct
instances
of
the
argumen
t
of
u,
then

=
 .
The
pro
of
of
the
claim
is
b
y
induction
on
the
o
ccurrences
of
u
in
.
In
the
base
case,

do
es
not
con
tain
u.
Then,
it
is
readily
seen
that
w
e
migh
t
ha
v
e

=
 
only
if

and
 
w
ould
b
e
in
ternal
to
distinct
instances
of
the
argumen
t
of
u.
But
b
y
h
yp
othesis
this
is
not
the
case.
In
the
induction
case,
w
e
see
that
c
hosen
an
arbitrary
o
ccurrence
of
w,
there
are
t
w
o
edges
(atomic
lab
els)
c
and
d
suc
h
that

=



cwd



.
F
urthermore,
w
e
ma
y
assume
without
loss
of
generalit
y
that
there
is
an
atomic
lab
el
(edge)
b
of
N
I
suc
h
that
s
w
(b)
=
cd,
with


fa;
ag.
In
fact,
if
s
w
(b)
=
dc
w
e
could
just
tak
e
the
rev
erse
of

(and
then
of

and
 ).
W
e
distinguish
t
w
o
cases:
(s
w
(b)
=
cad)
In
this
case,
c
is
the
con
text
edge
of
u
and
d
is
the
b
o
dy
edge.
Th
us,
neither


nor


are
in
ternal
to
the
argumen
t
of
u:
the
rst
ends
at
the
no
de
ab
o
v
e
u,
the
second
start
in
the
b
o
dy
of
the
abstraction
of
u.
So,
b
y
the
induction
h
yp
othesis,
there
is
a
unique
path


and
a
unique
path


of
N
suc
h
that

i
[s
w
]
=

i
,
with
i
=
;
.
A
t
the
same
time,
the
lab
el
(edge)
b
is
the
unique
one
of
N
I
for
whic
h
s
w
(b)
=
ca
d.
W
e
conclude
then
that

=


b

=
 .
(s
w
(b)
=
cad)
Here,
c
is
an
edge
connected
to
the
binding
p
ort
of
the
abstraction
of
u;
while
d
is
the
function
edge
of
u,
that
is,
the
ro
ot
edge
of
the
argumen
t
of
u.
While
it
is
still
true
that
the
lab
el
(edge)
b
is
the
unique
lab
el
of
N
I
for
whic
h
s
w
(b)
=
cad
(note
that
in
N,
the
lab
els
of
the
ro
ots
of
the
instances
of
the
argumen
t
of
u
are
all
distinct)
and
that


is
not
in
ternal
to
the
argumen
t
of
u
(it
ends
in
the
b
o
dy
of
u),
the
path


migh
t
b
e
in
ternal
to
the
argumen
t
of
u.
An
yw
a
y
,
there
exists
a
unique
path


of
N
suc
h
that
(

b)[s
w
]
=



cad.
So,
let

0

and

00

b
e
t
w
o
paths
suc
h
that

=
(

b
0

)[s
w
]
=
(

b
00

)[s
w
].
As
the
edge
b
corresp
onds
to
a
giv
en
instance
of
the
argumen
t
of
u,
in
the
case
that


is
in
ternal
to
it,
the
paths

0

and

00

are
in
ternal
to
the
same
instance
of
the
argumen
t
of
u.
W
e
can
then
apply
the
induction
h
yp
othesis
concluding
that

0
=

00
.

.
L
e
gal
Paths

Exercise
..
Let
v
b
e
the
canonical
form
of
a
redex
with
resp
ect
to
the
initial
term
M.
Pro
v
e
that
if
path
(degree

M
(v))
is
in
ternal
to
the
argumen
t
of
a
redex
u
of
M,
then
the
reduction
v
is
in
ternal
to
the
argumen
t
of
u.
Exercise
..
Let
M


N

u
!
and
M


N

v
!.
If
`
=
degree

M
(v),
pro
v
e
that
path
(`)

degree

M
(u)
or
path
(`)
r

degree

M
(u)
if
and
only
if

=

0
v
0

0
,
for
some

0
v
0
suc
h
that

0
v
0
'
v.
..
Wel
l
b
alanc
e
d
p
aths
and
le
gal
p
aths
The
previous
sections
ha
v
e
giv
en
a
go
o
d
accoun
t
of
the
corresp
ondence
b
et
w
een
paths
and
lab
els.
In
particular,
the
pro
of
of
the
corresp
ondence
b
et
w
een
extraction
relation
and
lab
eling
has
sho
wn
suc
h
a
corresp
on-
dence
at
w
ork.
Nev
ertheless,
the
only
metho
d
so
far
a
v
ailable
to
recog-
nize
paths
corresp
onding
to
virtual
redexes
is
via
the
lab
eled
calculus.
That
is,
w
e
can
sa
y
that
a
path
'
is
a
virtual
redex
if
and
only
if
there
is
a
lab
el
`
generated
along
the
reduction
of
M
suc
h
that
path
(`)
=
'.
The
relev
ance
of
the
set
path
(L(M))
of
suc
h
paths
is
that
it
giv
es
in-
deed
another
c
haracterization
of
L

evy's
famili
es.
In
fact,
b
ecause
of
the
corresp
ondence
b
et
w
een
families
and
degrees,
eac
h
family
corresp
ond
to
a
unique
virtual
redex
(path)
in
M,
vice
v
ersa,
eac
h
virtual
redex
of
M
iden
tify
a
unique
family
of
redexes.
Hence,
once
recognized
the
isomorphism
b
et
w
een
virtual
redexes
and
families,
the
natural
question
is
of
nding
a
denition
of
path
(L(M))
indep
enden
t
from
the
notion
of
lab
eled
reduction
and
from
the
notion
of
extraction
relation.
In
this
w
a
y
w
e
w
ould
also
get
a
new
c
haracterization
of
famili
es
indep
enden
t
from
the
dynamics
of
the
calculus,
or
more
precisely
,
w
e
w
ould
get
a
c
har-
acterization
of
the
notions
of
history
and
dep
endency
b
et
w
een
redexes
based
on
an
implicit
enco
ding
of
the
-calculus
reduction.
In
this
section
w
e
will
sho
w
that
suc
h
an
implicit
enco
ding
of
the
dynamics
is
indeed
p
ossible
and
that
it
leads
to
the
so-called
le
gal
p
aths.
Legal
paths
are
dened
in
terms
of
another
set
of
paths,
the
so-called
wel
l
b
alanc
e
d
p
aths,
that
at
their
turn
are
the
language
generated
b
y
a
suitable
set
of
con
text
free
comp
osition
rules.
Ha
ving
in
mind
the
examples
giv
en
to
in
tro
duce
the
corresp
ondence
b
et
w
een
paths
and
vir-
tual
redexes,
the
in
tuition
should
b
e
clear:
constructing
the
path
of
a
virtual
redex
w
e
w
ork
b
y
\sessions",
or
equiv
alen
tly
,
b
y
nesting
calls
of
a
recursiv
e
algorithm;
it
is
th
us
reasonable
that
the
formalizatio
n


Paths
of
suc
h
a
naiv
e
pro
cedure
should
lead
to
an
inductiv
e
denition
of
the
corresp
onding
paths.
In
more
details,
a
session
starts
at
the
function
p
ort
of
an
application
mo
ving
along
the
corresp
onding
edge.
The
purp
ose
is
to
end
at
the
con
text
edge
of
an
abstraction.
So,
the
base
case
is
when
the
initial
edge
is
just
a
redex.
In
the
other
cases,
the
searc
hing
con
tin
ues
with
a
new
session
p
erforming
a
recursiv
e
call
of
the
algorithm.
Then,
in
the
case
that
the
recursiv
e
subsession
w
ould
end
successfully
,
the
initial
session
is
resumed
and
the
searc
hing
con
tin
ues
from
the
ending
p
oin
t
of
the
result
returned
b
y
the
subsession.
Unfortunately
,
the
con
text
free
approac
h
corresp
onding
to
the
previ-
ous
algorithm
giv
es
raise
to
a
set
of
paths
wider
than
the
ones
corre-
sp
onding
to
virtual
redexes
(b
y
con
text
free
w
e
mean
that,
applying
the
inductiv
e
step
of
the
construction,
w
e
do
not
lo
ok
inside
the
shap
e
of
the
paths,
but
w
e
just
c
hec
k
if
they
start
and
end
at
the
righ
t
p
orts).
The
problem
has
b
een
already
sho
wn
b
y
one
of
the
in
tro
ductory
examples:
sometimes,
mo
ving
from
the
binding
p
ort
of
an
abstraction
no
de,
the
searc
h
ma
y
con
tin
ue
only
through
some
of
the
binding
edges
connected
to
the
abstraction;
in
suc
h
cases,
the
c
hoice
of
whic
h
binding
edge
w
e
are
allo
w
ed
to
cross
dep
ends
on
the
shap
e
of
the
path
built
so
far.
Ev
en
if
our
concern
is
on
paths
connecting
the
function
p
ort
of
an
application
to
the
con
text
p
ort
of
an
abstraction,
for
tec
hnical
reasons
w
e
do
not
p
ose
suc
h
a
restriction
in
dening
w
ell
balanced
paths.
In
particular,
w
ell
balanced
paths
still
start
at
the
function
p
ort
of
an
application,
but
w
e
distinguish
them
in
three
t
yp
es,
according
to
the
p
ort
at
whic
h
they
end
(i.e.,
a
w
ell
balanced
path
can
end
at
the
con
text
p
ort
of
an
applications,
at
the
con
text
p
ort
of
an
abstraction,
or
at
the
binding
p
ort
of
an
abstraction).
F
or
the
sak
e
of
a
uniform
presen
tation,
w
e
also
assume
that
\the
path
'
ends
at
the
con
text
p
ort
of
a
v
ariable
no
de
represen
ting
an
o
ccurrence
of
x"
b
e
indeed
a
synon
ym
of
\the
path
'
ends
at
the
binding
p
ort
the
application
represen
ting

x".
In
other
w
ords,
in
this
section
w
e
will
freely
sw
ap
b
et
w
een
the
represen
tation
of
a
syn
tax
tree
in
whic
h
eac
h
o
ccurrence
of
a
v
ariable
is
represen
ted
b
y
a
no
de,
and
the
represen
tation
in
whic
h
suc
h
no
des
are
omitted
and
the
corresp
onding
edges
connected
to
the
abstractions
binding
them.
Finally
,
w
e
will
also
sa
y
that
an
abstraction
is
a
no
de
of
t
yp
e
,
an
application
is
a
no
de
of
t
yp
e
@,
and
a
v
ariable
is
a
no
de
of
t
yp
e
v.
According
to
the
previous
notation,
a
w
ell
balanced
path
of
t
yp
e
@-?,
with
?

f@;
;
vg,
connects
the
function
p
ort
of
a
no
de
of
t
yp
e
@
to
the
con
text
p
ort
of
a
no
de
of
t
yp
e
?.
Namely
,
a
w
ell
balanced
path
is:

.
L
e
gal
Paths
	

an
@-@-p
ath,
when
it
ends
at
the
con
text
p
ort
of
an
application;

an
@--p
ath,
when
it
ends
at
the
con
text
p
ort
of
an
abstraction;

an
@-v-p
ath,
when
it
ends
at
the
con
text
p
ort
of
a
v
ariable
(i.e.,
at
the
binding
p
ort
of
an
application).
Denition
..
(wbp)
The
set
of
the
wbp
's
(w
ell
balanced
paths)
of
a
term
M
is
inductiv
ely
dened
b
y
the
follo
wing
rules
(see
also
Fig-
ure
.):
Base
c
ase
:
The
function
edge
of
an
y
application
of
M
is
a
wbp.
@-c
omp
osition
:
Let
 
b
e
a
wbp
of
t
yp
e
@-@,
and
'
b
e
a
wbp
of
t
yp
e
@-
starting
at
the
nal
application
of
 ,
then
 

'

u
is
a
wbp,
where
u
is
the
b
o
dy
edge
of
the
nal
abstraction
of
'.
-c
omp
osition
:
If
 
is
a
wbp
of
t
yp
e
@-v,
and
'
is
a
wbp
of
t
yp
e
@-
ending
at
the
abstraction
binding
the
v
ariable
at
the
end
of
 ,
then
 

(')
r

u
is
a
wbp,
where
u
is
the
argumen
t
edge
of
the
initial
application
of
'.
@
u
@
λ
@
u
ϕ
ψ
λ
@
@
ψ
ϕ
u
Fig.
..
W
ell
balanced
paths
(wbp
).
In
the
previous
denition,
ev
ery
wbp
of
t
yp
e
@-
corresp
onds
to
a
session
of
the
searc
hing
algorithm.
Comp
osition,
that
is,
the
execution
of
a
subsession,
explains
th
us
ho
w
to
resume
the
main
session
according
to
the
w
a
y
in
whic
h
the
subsession
w
as
en
tered.
In
particular,
let
us
remark
that
comp
osing
paths
w
e
alw
a
ys
add
@-
wbp's.
Another
w
a
y
to
understand
the
denition
of
wbp's
is
comparing
it
with
the
decomp
osition
of
degrees
in
prop
er
lab
els
stated
b
y
Lemma
...
In
fact,
an
y
subpath
of
t
yp
e
@-
corresp
onds
to
an
underlined
or
o
v
erlined
lab
el.
Hence,
according
to
Lemma
..,
it
m
ust
b
e
surrounded
b
y
suitable
atomic
edges
(see
Figure
.).

0
Paths
Exercise
..
V
erify
that
the
in
terpretation
of
the
wbp's
of
t
yp
e
@-

as
paths
corresp
onding
to
degrees
of
redexes
is
compatible
with
the
constrain
ts
in
Lemma
...
Example
..	
Let
us
consider
again
the
-term
(
)
with
the
la-
b
eling
of
Figure
.
(left).
The
edge
b
is
a
wbp
of
t
yp
e
@-.
The
edge
d
is
a
wbp
of
t
yp
e
@-v.
By
-comp
osition,
d(b)
r
f
=
dbf
is
a
wbp
of
t
yp
e
@-.
It
corresp
onds
indeed
to
the
redex
created
after
one
step
along
the
unique
deriv
ation
for
(
).
Let
us
go
on
computing
paths.
The
edge
h
is
a
wbp
of
t
yp
e
@-v
and
w
e
ha
v
e
already
built
the
wbp
dbf
leading
from
an
application
to
the
binder
of
the
ending
v
ariable
of
h.
So,
w
e
can
apply
again
-comp
osition,
obtaining
the
wbp
h(dbf)
r
e
=
hfbde
of
t
yp
e
@-v.
By
a
further
application
of
-comp
osition,
w
e
nally
get
the
wbp
hfbde(b)
r
f
=
hfbdebf
of
t
yp
e
@-,
that
is
the
path
asso
ciated
to
the
unique
redex
created
after
t
w
o
-reductions.
Up
to
no
w,
the
corresp
ondence
b
et
w
een
virtual
redexes
and
wbp's
is
complete:
an
y
wbp
w
e
ha
v
e
found
so
far
is
a
virtual
redex;
vice
v
ersa,
the
virtual
redexes
corresp
onding
to
the
rst
yielded
b
y
rst
t
w
o
steps
of
the
reduction
of
(
)
are
wbp's.
Unfortunately
,
suc
h
a
corresp
on-
dence
is
lost
at
the
next
step.
First
of
all,
let
us
note
that
the
result
of
the
previous
computation
are
t
w
o
@--paths
leading
to
the
same
ap-
plication
mark
ed
with
f;
namely
,
'
=
dbf
and
 
=
hfbdebf.
By
-
comp
osition,
h( )
r
k
is
then
an
@-v-path
whose
nal
v
ariable
is
b
ound
b
y
the

mark
ed
b
y
f.
According
to
the
paths
built
so
far,
the
con-
struction
can
then
pro
ceed
in
t
w
o
w
a
ys:
(i
)
follo
wing
';
(ii
)
rep
eating
 
an
arbitrary
n
um
b
er
of
times.
In
the
rst
case,
w
e
w
ould
end
up
with
h( )
r
k(')
r
ebf,
that
corresp
onds
to
the
redex
created
after
three
-reductions.
It
the
second
case,
w
e
w
ould
rather
construct
paths
with
the
shap
e
h( )
r
k( )
r
k



( )
r
k(')
r
ebf
and
none
of
them
corresp
onds
to
a
redex.
Example
..0
A
simpler
example
of
the
same
phenomenon
is
pro-
vided
b
y
the
term
of
Example
..
(redra
wn
on
the
righ
t
hand
side
of
Figure
.).
There
are
t
w
o
wbp's,
'
=
fbl
and
 
=
hbl,
leading
to
the
same
.
The
t
w
o
paths
d'm(')
r
g
and
d'm( )
r
k
are
b
oth
w
ell
balanced,
but
only
the
rst
one
is
\legal".
As
w
e
already
remark
ed,
the
only
non-determinism
in
the
algorithm

.
L
e
gal
Paths

a
@
b
f
x
y
c
g
@
@
d
e
h
k
x
x
y
y
a
@
b
l
x
y
c
m
@
y
d
e
@
f
x
g
M
@
h
x
k
N
Fig.
..
Left:
(
).
Righ
t:
(x:
((x
M)
(x
N))
y:
y).
searc
hing
virtual
redexes
(in
the
denition
of
wbp)
is
at
the
lev
el
of
b
ound
v
ariables.
F
urthermore,
the
latter
examples
clearly
p
oin
ts
out
that
not
alw
a
ys
suc
h
nondeterminism
is
unconstrained.
In
fact,
accord-
ing
to
the
-comp
osition
rule,
an
y
binding
edge
v
o
ccurring
in
a
wbp
is
ev
en
tually
follo
w
ed
b
y
a
(rev
ersed)
wbp
'
of
t
yp
e
@-,
and
b
y
an
access
to
the
argumen
t
N
of
the
initial
application
of
'.
The
shap
e
of
'
migh
t
b
e
v
ery
complex;
in
particular,
it
migh
t
describ
e
a
cycle
in
ter-
nal
to
N
(Figure
.).
Let
us
assume
that
this
is
the
case.
In
tuitiv
ely
,
the
path
'
should
tra
v
el
inside
the
instance
of
N
replacing
the
v
ariable
o
ccurrence
corresp
onding
to
v.
So,
after
the
cycle
in
ternal
to
N,
a
legal
path
\cannot
jump"
inside
another
instance
of
N,
it
is
rather
forced
to
follo
w
bac
k
the
same
path
tra
v
ersed
to
access
N
b
efore
the
cycle
(see
Example
..0).
@
Fig.
..
Naiv
e
denition
of
cycle
The
main
problem
in
formalizing
the
previous
in
tuition
is
to
capture
the
\righ
t"
notion
of
cycle.
The
rst
idea
w
ould
b
e
to
dene
cycles
according
to
Figure
.,
that
is,
without
an
y
other
tra
v
ersal
of
their
initial
application
no
de.
Unfortunately
,
this
naiv
e
approac
h
fails,
for
the
path
migh
t
tra
v
erse
sev
eral
times
the
function
p
ort
of
the
initial
@
no
de
(i.e.,
according
to
Figure
.)
b
efore
lo
oping
bac
k
to
its
argumen
t


Paths
p
ort|furthermore,
the
crossings
in
Figure
.
migh
t
neither
corresp
ond
to
an
inner
o
ccurrence
of
a
cycle
of
the
same
t
yp
e.
@
Fig.
..
In
other
w
ords:
(i)
Cycles
ma
y
con
tain
o
ccurrences
of
other
cycles,
ev
en
of
cycles
lo
oping
to
the
same
p
ort;
(ii)
It
is
generally
incorrect
to
nd
the
cycles
in
a
path
pairing
a
p
oin
t
in
whic
h
the
path
exits
from
the
argumen
t
of
an
application
to
the
last
p
oin
t
in
whic
h
the
path
en
tered
in
to
it
(i.e.,
according
to
a
last-in-rst-out
strategy).
According
to
the
latter
remarks,
the
base
case
of
the
inductiv
e
def-
inition
of
cycles
is
immediate:
w
e
can
start
from
the
paths
physic
al
ly
in
ternal
to
the
argumen
t
of
an
application.
Denition
..
(elemen
tary
cycle)
Let
'
b
e
a
wbp.
A
subpath
 
of
'
is
an
elementary
@-cycle
of
 
(o
v
er
an
@-no
de
@)
when:
(i)
 
starts
and
ends
with
the
argumen
t
edge
of
the
@-no
de
@;
(ii)
 
is
in
ternal
to
the
argumen
t
N
of
the
application
corresp
onding
to
the
@-no
de
@
(i.e.,
 
do
es
not
tra
v
erse
an
y
v
ariable
that
o
ccurs
free
in
N).
The
denition
of
the
inductiv
e
step
requires
instead
more
regards..
The
problem
is
that
tra
v
eling
along
the
cycle
w
e
could
exit
from
some
free
v
ariable
of
N
(free
in
N,
but
ev
en
tually
b
ound
in
the
initial
term),
mak
e
a
cycle
somewhere
else,
and
come
bac
k
again
inside
N.
According
to
this,
w
e
need
to
in
tro
duce
a
notion
of
v-cycle
(i.e.,
a
cycle
lo
oping
o
v
er
a
v
ariable)
describing
suc
h
a
situation.
F
urthermore,
for
the
sak
e
of
clarit
y
,
w
e
will
write
'
?
 
to
denote
that
the
paths
'
and
 
resp
ectiv
ely
ends
and
start
at
a
no
de
of
t
yp
e
?.
Denition
..
(cycle)
Let

b
e
a
wbp.
The
set
of
the
@-cycles
of

(o
v
er
an
@-no
de
@)
and
of
the
v-cycles
of

(o
v
er
the
o
ccurrence
v
of
a
v
ariable)
is
inductiv
ely
dened
as
follo
ws:

.
L
e
gal
Paths

Elementary
:
Ev
ery
elemen
tary
@-cycle
of

(o
v
er
an
@-no
de
@)
is
an
@-cycle.
v-cycle
:
Ev
ery
cyclic
subpath
of

of
the
form
v

(')
r
@
 
@
'

v,
where
'
is
a
wbp,
 
is
an
@-cycle
and
v
is
a
binding
edge,
is
a
v-cycle
(o
v
er
v).
@-cycle
:
Ev
ery
subpath
 
of

that
starts
and
ends
with
the
argumen
t
edge
of
a
giv
en
@-no
de
@,
and
that
is
comp
osed
of
subpaths
in
ternal
to
the
argumen
t
N
of
@
and
v-cycles
o
v
er
free
v
ariables
of
N
is
an
@-cycle
(o
v
er
the
@-no
de
@).
In
the
denition
of
@-cycles,
w
e
ha
v
e
ev
en
tually
inserted
a
consistency
condition
requiring
that
a
path
lo
oping
to
the
argumen
t
of
an
application
m
ust
b
e
accessed
and
exited
though
the
same
wbp.
The
next
step
is
to
extend
suc
h
a
constrain
t
to
all
the
cycles
o
ccurring
in
a
wbp.
Namely
,
that
an
y
@-cycle
is
surrounded
b
y
a
consisten
t
pair
of
wbp's.
Ho
w
ev
er,
b
efore
to
do
this,
let
us
v
erify
that
the
decomp
osition
of
a
wbp
in
to
smaller
wbp's
is
unique.
Prop
osition
..
L
et
'
b
e
a
wbp.
(i)
F
or
every
-no
de
in
'
ther
e
exists
a
unique
wbp


(of
typ
e
@-)
such
that
'
c
an
b
e
de
c
omp
ose
d
as


@





or



(

)
r
@


.
F
urthermor
e,
the
given
-no
de
is
p
air
e
d
with
the
initial
@-no
de
of
'
if
and
only
if
it
is
the
last
no
de
of
'.
(ii)
F
or
every
@-no
de
in
'
but
the
initial
one,
ther
e
exists
a
unique
wbp


(of
typ
e
@-)
such
that
'
c
an
b
e
de
c
omp
ose
d
as


@





or


(

)
r
@


.
Pr
o
of
By
easy
induction
on
the
denition
of
wbp.
Remark
..
In
b
oth
the
cases
of
the
previous
prop
osition,
the
shap
e
of
the
decomp
osition
is
xed
b
y
the
w
a
y
in
whic
h
'
crosses
the
corre-
sp
onding
no
de,
e.g.,
w
e
can
ha
v
e


@





only
if
'
crosses
the
-no
de
en
tering
through
its
con
text
(i.e.,
its
principal)
p
ort,
and
crosses
the
@-
no
de
exiting
through
its
argumen
t
p
ort.
F
urthermore,
when
'
is
of
t
yp
e
@-,
the
initial
application
is
alw
a
ys
paired
with
the
nal
abstraction
of
the
no
de.
Exercise
..
Let
 

and
 

b
e
t
w
o
wbp's
con
tained
in
the
wbp
'.
Pro
v
e
that
 

and
 

o
v
erlap
only
if
one
is
a
subpath
of
the
other,
i.e.,
either
 

and
 

are
disjoin
t
in
',
or
 

is
a
subpath
of
 

(assuming
w.l.o.g.
that
 

is
not
shorter
than
 

).


Paths
A
consequence
of
the
previous
prop
osition
is
that
an
y
@-cycle
is
sur-
rounded
b
y
t
w
o
wbp's
of
t
yp
e
@-.
Corollary
..
L
et
 
b
e
an
@-cycle
of
'
over
an
@-no
de
@.
The
wbp
'
c
an
b
e
uniquely
de
c
omp
ose
d
as



(

)
r
@
 
@





wher
e


and


ar
e
wbp's
of
typ
e
@-.
Pr
o
of
Let
us
apply
Prop
osition
..
to
the
o
ccurrence
of
@
at
the
b
eginning
of
 
and
to
the
o
ccurrence
at
the
end
of
 .
According
to
Remark
..,
the
unique
decomp
osition
w
e
can
get
is
the
one
ab
o
v
e.
In
fact,
the
o
ccurrence
of
 
in
'
is
preceded
and
follo
w
ed
b
y
the
argumen
t
edge
of
@.
In
the
situation
of
Corollary
..,
the
wbp


and
the
wbp


are
resp
ectiv
ely
the
c
al
l
and
r
eturn
paths
of
the
@-cycle
 .
The
last
lab
el
of


and
the
rst
lab
el
of


are
instead
the
discriminants
of
the
call
and
return
paths,
resp
ectiv
ely
(note
that
discriminan
ts
are
binding
edges
connected
to
nal
-no
de
of
the
call
and
return
paths).
W
e
are
no
w
ready
to
state
the
le
gality
condition
for
wbp's.
Denition
..
(legal
path)
A
wbp
is
a
le
gal
p
ath
if
and
only
if
the
call
and
return
paths
of
any
@-cycle
are
one
the
rev
erse
of
the
other
and
their
discriminan
ts
are
equal.
In
particular,
w
e
will
sa
y
that
an
@-cycle
is
le
gal,
when
its
call
and
return
parts
accord
with
the
legalit
y
constrain
t
in
the
previous
denition.
Let
us
also
note
that
an
@-cycle
is
legal
only
when
it
can
b
e
used
to
build
a
v-cycle.
Hence,
in
a
legal
path
an
y
@-cycle
is
con
tained
inside
some
v-cycle.
Example
..
Let
us
consider
again
the
wbp's
dfblmlbfg
and
dfblmlbhk
of
Example
..0.
Both
con
tain
an
(elemen
tary)
@-cycle
lml
o
v
er
the
@-no
de
lab
eled
with
a.
In
b
oth
cases
the
call
and
return
path
of
lml
is
b.
Nev
ertheless,
only
the
rst
path
is
legal,
for
in
the
second
case
the
discriminan
ts
dier
(they
are
f
and
h).
T
o
conclude
our
analysis
of
the
denition
of
legal
paths,
let
us
pro
vide
a
detailed
coun
ter-example
to
the
naiv
e
denition
of
cycle
(i.e.,
to
the
fact
that
all
the
@-cycles
are
elemen
tary).

.
L
e
gal
Paths

λx
λy
@
@
y
y
M
@
x
@
λz
z
z
@
λy
@
@
y
y
M
λx
λy
@
@
y
y
M
@
x
*
@+
Fig.
.	.
(
N)
!
!
(y:(y
(y
M))
N),
with
N
=
x:(y:(y
(y
M))
x)).
Example
..	
Let
us
tak
e
(see
Figure
.	)
the
terms
P
=
(
N)
and
Q
=
(y:(y
(y
M))
N),
where
N
=
x:(y:(y
(y
M))
x)).
It
is
readily
seen
that
P
!
(N
N)
!
Q.
The
applications
resp
ectiv
ely
mark
ed
with
+
and

in
Figure
.	
are
b
oth
residual
of
a
same
application
in
P
.
Moreo
v
er,
the
dotted
path
in
Figure
.	
is
ob
viously
a
legal
path
of
t
yp
e
@-@.
This
path
en
ters
the
argumen
t
of
@

and
imm
ediately
exit
from
the
argumen
t
of
@
+
.
Since
these
t
w
o
applications
are
residual
of
a
same
application
in
P
,
the
ancestor
of
the
ab
o
v
e
p
ortion
of
path
w
ould
b
e
a
cycle
in
the
naiv
e
sense,
that
is
instead
ob
viously
wrong.
Explicitly
,
the
ancestor
in
P
of
the
dotted
path
in
Q
is
describ
ed
in
Figure
.0:
w
e
ha
v
e
a
\naiv
e"
cycle
inside
the
argumen
t
of
@

,
but
this
is
not
an
@-cycle
in
the
sense
of
Denition
..
(pro
v
e
it
as
an
exercise).
..
L
e
gal
p
aths
and
r
e
dex
families
W
e
shall
no
w
pro
v
e
than
there
is
a
bijectiv
e
corresp
ondence
b
et
w
een
legal
paths
and
paths
yielded
b
y
degrees.
More
formally
,
w
e
shall
pro
v
e
that
path
(L(T
))
is
the
set
of
the
legal
paths
of
T
.
Some
preliminary
denitions
and
results
are
required.
Denition
..0
Let
'
b
e
a
wbp
in
a
term
T
.
The
lab
el
of
'
is
dened
inductiv
ely
as
follo
ws:
(b
ase
c
ase
)
When
'
=
u,
the
lab
el
of
'
is
equal
to
the
lab
el
of
u
in
T
I
.
(@-c
omp
osition
)
When
'
=
'

@
'


u,
the
lab
el
of
'
is
`

`

a,
where


Paths
λx
λy
@
@
y
y
M
@
x
@
λz
z
z
@
Fig.
.0.
An
example
of
\naiv
e"
lo
op
that
is
not
a
cycle.
`

is
the
lab
el
of
'

,
`

is
the
lab
el
of
'

,
and
a
is
the
lab
el
in
T
I
of
u.
(-c
omp
osition
)
When
'
=
'


'

@
u,
the
lab
el
of
'
is
`

(`

)
r
a,
where
`

is
the
lab
el
of
'

,
`

is
the
lab
el
of
'

,
and
a
is
the
lab
el
in
T
I
of
u.
According
to
the
ab
o
v
e
denition,
it
is
immediate
to
v
erify
that
'
=
path
(`),
when
`
is
the
lab
el
of
a
wbp
'.
Let
T
u
!
T
0
.
Ev
ery
(arbitrary)
path
in
T
0
has
an
anc
estor
in
T
.
Its
denition
is
prett
y
in
tuitiv
e,
so
w
e
shall
not
b
e
p
edan
tic.
In
particular,
w
e
shall
just
dene
the
notion
of
ancestor
for
single
edges
in
T
0
.
This
extends
to
paths
b
y
comp
osition,
in
the
ob
vious
w
a
y
.
Let
T
=
C[(x:
M
N)]
and
T
0
=
C[M[
N
=
x
]],
where
C[

]
is
some
con-
text.
Let
us
note
rst
that
some
edges
in
T
0
are
\residuals"
of
edges
in
T
.
This
is
the
case
for
ev
ery
edge
v
0
b
elonging
to
the
con
text,
or
in
ternal
to
M
or
to
some
instance
of
N.
If
v
0
is
a
residual
of
v
in
the
previous
sense,
then
v
is
the
ancestor
of
v
0
.
The
problem
is
when
v
0
is
a
new
connection
created
b
y
ring
the
redex
u.
Let
@
and

b
e
the
t
w
o
no
des
connected
b
y
u
in
T
.
Three
cases
are
p
ossible
(see
also
Figure
.):

v
0
is
a
connection
b
et
w
een
the
con
text
C[

]
and
the
b
o
dy
M.
The
ancestor
of
v
0
is
a

u

b,
where
a
is
the
connection
from
the
con
text
to
@
(i.e.,
the
con
text
edge
of
@),
and
b
is
the
connection
from

to
M
(i.e.,
the
b
o
dy
edge
of
).

v
0
is
a
connection
b
et
w
een
M
and
the
i-th
instance
of
N.
The
ancestor
of
v
0
is
b

(u)
r

c,
where
b
is
the
edge
leading
from
M
to
the
i-th
instance
of
the
v
ariable
b
ound
b
y

(i.e.,
an
edge
corresp
onding
to
an

.
L
e
gal
Paths

o
ccurrence
of
the
v
ariable
x),
and
c
is
the
edge
leading
from
@
to
N
(i.e.,
the
argumen
t
edge
of
@).

v
0
is
a
connection
b
et
w
een
the
con
text
and
N.
This
is
only
p
ossible
when
M
=
x,
and
it
is
an
ob
vious
com
bination
of
the
previous
cases.
In
particular,
the
ancestor
of
v
0
is
a

u

b

(u)
r

c,
with
a,
b
and
c
as
ab
o
v
e.
W
e
lea
v
e
to
the
reader
the
care
to
generalize
the
denition
of
ancestor
from
edges
to
arbitrary
paths|the
only
thing
to
pro
v
e
is
that
comp
osing
the
ancestors
of
the
edges
in
a
path
the
result
is
a
connected
sequence.
The
denition
of
ancestor
is
then
extended
to
deriv
ations
in
the
usual
w
a
y
(transitiv
e
and
reexiv
e
closure
of
the
base
case).
Moreo
v
er,
the
ancestor
relation
preserv
es
path
balancing.
Prop
osition
..
Every
anc
estor
of
a
wbp
is
a
wbp.
Pr
o
of
By
induction
on
the
length
of
the
deriv
ation
leading
to
the
term
in
whic
h
the
wbp
o
ccurs.
Lemma
..
L
et
T
u
!
T
0
.
If
'
is
the
anc
estor
of
a
le
gal
p
ath
'
0
in
T
0
,
then:
(i)
Every
@-cycle
in
'
r
elative
to
an
applic
ation
@
not
r
e
d
by
u
is
anc
estor
of
an
@-cycle
in
'
0
over
any
r
esidual
of
@.
(ii)
Every
v-cycle
in
'
r
elative
to
an
instanc
e
x
of
a
variable
not
b
ound
by
the

in
u
is
anc
estor
of
a
v-cycle
in
'
0
over
any
r
esidual
of
x.
Pr
o
of
By
induction
on
the
denition
of
cycle.
Let
 
b
e
the
cycle
under
analysis.
W
e
ha
v
e
the
follo
wing
cases:
(elementary
)
T
rivial,
for
the
execution
of
u
do
es
not
c
hange
the
fact
that
 
is
in
ternal
to
the
argumen
t
of
its
initial
@-no
de.
(v-cycle
)
Let
 
=
v

('

)
r
@

@
'


v.
Since
v
is
not
b
ound
b
y
the
-no
de
in
u,
the
@-cycle

cannot
b
e
relativ
e
to
the
applica-
tion
red
b
y
u
(indeed,
u
is
the
unique
wbp
in
T
relativ
e
to
this
application).
So,
applying
the
induction
h
yp
othesis,
w
e
see
that
there
exists
a
cycle

0
inside
'
0
whose
ancestor
is
.
By
h
yp
othesis,
'
0
is
legal.
Hence,
b
y
Corollary
..,
it
con-
tains
a
unique
subpath
suc
h
that
v
0

('
0

)
r
@

0
@
'
0


v
0
.
Let
e
v

(
e
'

)
r
@

@
e
'


e
v
b
e
the
ancestor
of
the
previous
subpath


Paths
in
T
(i.e.,
e
'

is
the
ancestor
of
'

).
By
Prop
osition
..,
e
'

is
a
wbp.
Then,
b
y
Corollary
..,
'

=
e
'

and
v
=
e
v
.
(@-cycle
)
Let
@

b
e
the
@-no
de
o
v
er
whic
h
 
lo
ops.
By
denition,
 
comp
oses
of
an
alternated
sequence
of
paths
suc
h
that
 
=



v


 


v








k

v
k

 
k

v
k


k+
where,
an
y

i
is
in
ternal
to
the
argumen
t
M
of
@

,
while
an
y
v
i

 
i

v
i
is
a
v-cycle
o
v
er
a
v
ariable
of
M.
Firstly
,
let
us
assume
that
none
of
the
edges
v
i
is
connected
to
the
-no
de
in
the
redex
u.
In
this
case,
w
e
ha
v
e
that:
 
0
=

0


v
0


 
0


v
0



0





0
k

v
0
k

 
0
k

v
0
k


0
k+
where,
for
an
y

0
i
,
the
path

i
is
its
ancestor,
and
for
an
y
v
0
i

 
0
i

v
0
i
,
the
v-cycle
v
i

 
i

v
i
is
its
ancestor.
W
e
claim
that
all
the

0
i
are
in
ternal
to
the
argumen
t
M
0
of
the
@-no
de
@
0

o
v
er
whic
h
 
0
lo
ops.
The
only
relev
an
t
case
is
when
some

i
con
tains
a
no
de
in
u.
When
this
happ
ens,
it
is
immediate
to
c
hec
k
that

i
crosses
the
redex
u,
that
is,
u
is
in
ternal
to
M.
The
claim
is
then
an
imm
ediate
consequence
of
the
previous
remark.
Th
us,
to
conclude
the
pro
of
for
the
case
no
lo
op
o
v
er
the
v
ariable
of
u,
let
us
note
that
an
y
v
0
i

 
0
i

v
0
i
is
a
v-cycle
o
v
er
a
v
ariable
of
M
0
,
b
y
induction
h
yp
othesis.
That
is,
 
0
is
an
@-cycle.
No
w,
let
us
assume
that
v
i
is
a
binding
edge
connected
to
the
-no
de
in
u.
The
redex
u
is
the
rst
and
last
edge
of
 
i
.
More-
o
v
er,
u
is
external
to
M,
otherwise
w
e
could
tak
e
a
longer
path

i
con
tained
in
M.
By
the
denition
of
v-cycle
and
b
y
Corol-
lary
..,
w
e
see
that
 
i
=
v
i

u
@
@
u
v
i
,
for
some
@-cycle

(again,
remind
that
u
is
an
@-
wbp).
The
@-cycle

can
b
e
decomp
osed
at
its
turn
in
paths
in
ternal
to
the
argumen
t
N
of
u
and
v-cycles
o
v
er
v
ariables
of
N.
Moreo
v
er,
let
us
note
that:
(i
)
none
of
suc
h
v-lo
ops
can
b
e
o
v
er
the
v
ariable
b
ound
b
y
the
-no
de
of
u;
(ii
)
since
M
is
in
ternal
to
the
b
o
dy
of
u
(b
y
the
syn
tax
of
-terms),
@
has
a
unique
residual
@

;
(iii
)
the
residual
in
 
0
i
of
the
paths
in
ternal
to
N
are
paths
in
ternal
to
the
instance
of
N
replacing
the
o
ccurrence
of
the
v
ariable
corresp
onding
to
v
i
.
As
a
consequence,
w
e
see
that
the
residual
of
 
i
is
a
path
comp
osed
of
subpaths
in
ternal
to
the
argumen
t
M
0
of
@

,
and
of
residuals
of
v-cycles
o
v
er
v
ariables
of
N
that,

.
L
e
gal
Paths
	
b
y
induction
h
yp
othesis
and
b
y
(iii
),
are
v-cycles
o
v
er
v
ariables
in
M
0
.
This
suces
to
conclude.
Lemma
..
L
et
T
u
!
T
0
.
If
'
is
the
anc
estor
of
a
legal
p
ath
'
0
in
T
0
,
then
every
@-cycle
 
in
'
r
elative
to
an
applic
ation
not
r
e
d
by
u
is
le
gal.
Pr
o
of
By
Lemma
..,
 
is
ancestor
of
an
@-cycle
 
0
in
'
0
.
Since
'
0
is
legal,
'
0
con
tains
a
v-cycle
v
0

('
0

)
r
@
 
0
@
'
0


v
0
.
So,
the
structure
of
'
around
the
@-cycle
 
has
the
shap
e
v

('

)
r
@
 
@
'


v,
where
'

is
the
ancestor
of
'
0

,
and
v
0
is
the
ancestor
of
v.
Lemma
..
L
et
T
u
!
T
0
.
If
'
is
the
anc
estor
of
a
legal
p
ath
'
0
in
T
0
,
then
every
@-cycle
 
in
'
r
elative
to
the
applic
ation
r
e
d
by
u
is
le
gal.
Pr
o
of
The
call
and
return
paths
of
 
are
equal
to
u,
that
is,
they
are
trivially
equal.
Th
us,
let
v


u
@
 
@
u

v

.
W
e
m
ust
pro
v
e
that
the
discriminan
ts
v

and
v

are
equal.
By
denition,
 
comp
oses
of
subpaths
in
ternal
to
the
argumen
t
N
of
the
redex
u
and
v-cycles
o
v
er
free
v
ariables
of
N.
By
Lemma
..,
eac
h
of
suc
h
v-cycles
is
the
ancestor
of
a
v-cycle
in
'
0
.
F
urthermore,
suc
h
cycles
in
'
0
are
relativ
e
to
free
v
ariables
of
some
instance
N
i
of
N
in
T
(see
the
pro
of
of
Lemma
..).
Let
us
note
that:
(i
)
all
the
instances
of
N
are
disjoin
t
in
T
0
;
(ii
)
the
con
text
edge
of
eac
h
N
i
corresp
onds
to
a
unique
discriminan
t
of
the
v
ariable
of
u.
Hence,
b
y
induction
on
the
n
um
b
er
of
v-cycles
in
 ,
w
e
conclude
that
all
the
residuals
of
the
paths
in
ternal
to
N
in
 
are
in
the
same
instance
N
i
,
and
that
all
the
residuals
of
the
v-cycles
in
 
are
o
v
er
free
v
ariables
in
that
instance
N
i
.
As
a
consequence,
the
path
v


u
@
 
@
u

v

is
the
ancestor
of
a
path

starting
and
ending
at
the
con
text
edge
of
N
i
.
Th
us,
w
e
conclude
that
v

=
v

.
The
previous
lemmas
ensure
that
legal
paths
cannot
b
e
created
along
reduction.
Prop
osition
..
L
et
T
u
!
T
0
.
The
anc
estor
of
a
le
gal
p
ath
'
0
in
T
0
is
a
le
gal
p
ath
'
in
T
.
Pr
o
of
By
Prop
osition
..
w
e
kno
w
that
'
is
a
wbp.
By
the
previous
lemmas
w
e
see
that
it
is
indeed
legal.

0
Paths
A
relev
an
t
p
oin
t
for
the
corresp
ondence
b
et
w
een
legal
paths
and
de-
grees
is
that
a
legal
path
and
an
y
of
its
ancestors
yield
the
same
lab
el.
Prop
osition
..
L
ab
eling
of
le
gal
p
aths
is
unchange
d
in
anc
estors.
Pr
o
of
By
induction
on
the
denition
of
ancestor
and
b
y
analysis
of
the
shap
e
of
the
edges
created
at
an
y
reduction
giv
en
in
page
.
W
e
are
no
w
ready
to
pro
v
e
that
the
set
of
the
legal
paths
in
a
term
T
con
tains
the
set
path
(L(T
))
of
the
paths
yielded
b
y
the
degrees
ob-
tainable
reducing
T
.
That
is
the
equiv
alence
b
et
w
een
degrees
and
legal
paths
in
the
direction
from
degrees
to
legal
paths.
Theorem
..
(from
degrees
to
legal
paths)
Every
p
ath
yielde
d
by
the
de
gr
e
e
of
a
r
e
dex
is
a
le
gal
p
ath.
Pr
o
of
An
y
redex
u
in
a
term
T
0
is
a
legal
path.
By
Prop
osition
..
and
Prop
osition
..,
if
T


T
0
,
then
the
ancestor
of
u
in
T
is
a
legal
path
'
whose
lab
el
`
is
equal
to
degree

T
(u).
Finally
,
as
'
=
path
(`),
w
e
conclude.
The
strategy
to
sho
w
the
con
v
erse
of
Theorem
..
bases
on
sho
wing
that
an
y
legal
path
can
b
e
uniquely
\con
tracted"
in
to
a
legal
path
b
y
ring
the
leftmost-outermost
redex.
By
the
previous
results,
w
e
kno
w
that
suc
h
a
con
traction
preserv
es
legalit
y;
furthermore,
since
it
also
de-
creases
the
length
of
the
path,
w
e
can
conclude
that
iterating
the
pro
cess
w
e
ev
en
tually
get
a
legal
path
corresp
onding
to
the
base
case
in
the
def-
inition
of
wbp;
that
is
a
redex,
when
the
path
is
of
t
yp
e
@-.
Some
preliminary
results
are
required.
Lemma
..
L
et
T
u
!
T
0
,
with
u
=
(x:
M
N).
L
et
'
b
e
a
le
gal
p
ath
internal
to
N.
Each
instanc
e
N
i
of
N
in
T
0
c
ontains
a
le
gal
p
ath
'
i
whose
anc
estor
is
'.
Pr
o
of
By
insp
ection
of
the
-rule.
Lemma
..	
L
et
T
u
!
T
0
,
with
u
=
(x:
M
N).
L
et
'
b
e
any
le
gal
p
ath
in
T
such
that
u
is
the
leftmost-outermost
r
e
dex
that
'
tr
averses
in
T
.
Then,
when
'
do
es
not
start
or
end
at
any
p
ort
of
a
no
de
in
u,
ther
e
is
a
unique
wbp
'
0
in
T
0
whose
anc
estor
is
'.

.
L
e
gal
Paths

Pr
o
of
By
induction
on
the
structure
of
'.
The
base
case
holds
trivially
.
In
fact,
since
'
m
ust
con
tain
the
redex
u,
the
only
p
ossibilit
y
when
j'j
=

is
'
=
u.
That
is,
'
violates
the
\when"
clause
of
the
thesis.
Let
us
no
w
pro
ceed
with
the
induction
case
(j'j
>
).
The
only
problem
is
to
pro
v
e
that
suitably
c
ho
osing
the
residuals
of
the
edges
in
'
w
e
get
a
connected
sequence
in
T
0
,
that
is,
a
path
'
0
.
Let
'
=
'

@
'


v,
i.e.,
'
is
the
result
of
an
@-comp
osition.
W
e
dis-
tinguish
three
cases
according
to
the
p
osition
of
the
@-no
de
@
b
et
w
een
'

and
'

with
resp
ect
to
N:
(i)
@
is
external
to
N:
The
path
'

cannot
end
at
the
-no
de
of
u,
for
otherwise
w
e
w
ould
ha
v
e
'

=
u.
F
urthermore,
if
the
\when"
clause"
of
the
thesis
holds,
then
'

do
es
not
start
at
the
@-no
de
of
u.
According
to
this,
w
e
see
that
the
paths
'

and
'

determine
a
unique
pair
of
wbp's
'
0

and
'
0

suc
h
that
'
i
is
ancestor
of
'
0
i
,
for
i
=
;
.
In
fact,
for
b
oth
'

and
'

w
e
can
distinguish
t
w
o
sub
cases:
(i
)
'
i
con
tains
u;
(ii
)
'
i
do
es
not
con
tain
u,
i.e.,
it
is
external
to
N.
In
case
(i
),
our
preliminary
considerations
ensure
that
w
e
can
apply
the
induction
h
yp
othesis.
In
case
(ii
),
b
y
the
denition
of
-rule,
'
i
is
ancestor
of
a
unique
path
'
0
i
in
T
0
;
furthermore,
since
'
0
i
and
'
i
are
isomorphic,
'
0
i
is
a
wbp.
T
o
conclude,
let
us
note
that
@
and
v
ha
v
e
unique
residuals
in
T
0
:
the
no
de
@
0
at
the
end
(b
eginning)
of
'
0

('
0

),
and
the
edge
v
0
,
resp
ectiv
ely
.
Hence,
'
0
=
'
0

@
'
0


v
0
is
a
wbp.
(ii)
@
is
internal
to
N:
As
in
the
previous
case,
w
e
can
exclude
that
'

ends
at
the
-no
de
of
u,
and
assume
that
'

do
es
not
start
at
the
@-no
de
of
u.
As
in
the
previous
case
w
e
ha
v
e
to
distinguish
whether
'
i
tra
v
erses
u
or
not.
The
only
dierence
is
that
here,
in
sub
case
(ii
),
the
path
'
i
is
completely
in
ternal
to
N.
Let
us
ho
w
ev
er
note
that
case
(ii
)
cannot
sim
ultaneously
hold
for
b
oth
'

and
'

.
Hence,
the
induction
h
yp
othesis
applies
to
at
least
one
of
the
paths.
F
or
instance,
let
us
assume
that
'

is
in
ternal
to
N.
The
path
'
0

ends
at
a
residual
@
0
of
@
in
T
0
in
ternal
to
a
giv
en
instance
N
0
of
N.
By
Lemma
..,
in
an
y
instance
N
i
of
N
in
T
0
,
there
is
a
wbp
'
i

suc
h
that
'

is
ancestor
of
'
i

.
Nev
ertheless,
the
only
'
i

that
yields
a
connected
sequence
is
the
instance
'
0

in
ternal
to
N
0
.
By
construction,
w
e
ha
v
e
then
that
'
0
=
'
0

@
'
0


v
0
is
a
wbp.
The
case
'

in
ternal
to
N
is
similar.
Then,
w
e
ha
v
e
left
to
pro
v
e
the
case
in
whic
h
the
induction
h
yp
othesis
applies
to
b
oth
'

and


Paths
'

.
Namely
,
w
e
ha
v
e
to
pro
v
e
that,
when
b
oth
'

and
'

con
tain
u,
the
sequence
'
0

@
'
0

@
u
0
obtained
comp
osing
the
(unique)
paths
asso
ciated
to
'

and
'

is
indeed
a
path.
This
fact
is
not
trivially
immedia
te,
for
'
0

migh
t
end
at
a
residual
@

of
@
in
an
instance
N

of
N,
and
'
0

migh
t
start
at
the
residual
@
+
of
@
in
an
instance
N
+
of
N.
Nev
ertheless,
tak
e
the
last
instance
of
u
in
'

and
the
rst
instance
in
'

,
w
e
ha
v
e
'

=
 


u



and
'

=



u

 

.
F
urthermore,
since
b
oth


and


m
ust
b
e
in
ternal
to
N,


starts
at
the
argumen
t
p
ort
of
the
@-no
de
of
u,
while


ends
at
this
p
ort.
As
a
consequence,

=





is
an
elemen
tary
case
of
@-cycle.
The
call
and
return
paths
of

are
u
and,
b
y
h
yp
othesis,
their
discriminan
ts
coincide
and
are
are
equal
to
an
o
ccurrence
of
x.
Hence,
since
an
y
o
ccurrence
of
x
determines
a
unique
instance
of
N
in
T
0
,
w
e
conclude
that
N

=
N
+
,
that
is,
@

=
@
+
.
(iii)
@
is
the
@-no
de
of
u:
Thas
is,
'

=
u.
First
of
all,
let
us
note
that
the
last
edge
of
'

is
denitely
the
con
text
edge
w
of
the
redex
u.
Then,
let
us
pro
ceed
b
y
induction
on
the
shap
e
of
'

:
('

=
w)
The
only
case
in
whic
h
the
\when"
clause
of
the
thesis
is
violated
is
when
v
is
connected
to
the
binding
p
ort
of
the
-no
de
in
u
(that
is
M
=
x).
Hence,
let
us
assume
that
this
is
not
the
case.
There
is
a
unique
edge
v
0
of
T
0
whose
ancestor
is
'
=
wuv.
Since
suc
h
edge
starts
at
the
unique
residual
in
T
0
of
the
@-no
de
at
the
b
eginning
of
',
w
e
conclude
that
v
0
is
a
wbp.
('

=
 

@
 


w)
The
path
 

ends
at
a
-no
de
immedia
tely
ab
o
v
e
the
@-no
de
of
u.
Then
the
@-no
de
b
et
w
een
 

and
 

cannot
b
e
the
application
of
u.
Using
the
same
tec
hnique
of
the
case
\@
external
to
N",
w
e
can
then
con-
clude
that
 

@
 

is
ancestor
of
a
unique
path
 
0

@
 
0

comp
osed
of
t
w
o
wbp's
 
0

and
 
0

.
Hence,
if
v
0
is
the
residual
of
wuv,
w
e
see
that
'
0

@
'
0


v
0
is
the
unique
wbp
in
T
0
whose
ancestor
is
'.
('

=
 


( 

)
r
@
w)
As
in
the
previous
case
w
e
can
exclude
that
 

and
 

ends
at
the
-no
de
of
u.
Then,
using
the
same
reasoning,
w
e
conclude.
The
case
of
-comp
osition
(i.e.,
'
=
'


('

)
r
@
v)
is
totally
similar
to
the
case
of
@-comp
osition.
W
e
lea
v
e
it
to
the
reader
as
an
easy
exercise.

.
L
e
gal
Paths

Lemma
..0
L
et
',
T
,
u
=
(x:
M
N),
T
0
,
and
'
0
b
e
as
in
the
pr
evious
lemma.
F
or
any
cycle
 
0
c
ontaine
d
in
'
ther
e
is
a
cycle
 
in
'
such
that
 
is
the
anc
estor
of
 
0
.
Pr
o
of
Similar
to
the
pro
of
of
Lemma
...
The
dicult
p
oin
t
is
in
the
case
of
@-cycle,
where
the
construction
used
in
Lemma
..
m
ust
b
e
rev
erted.
Let
us
pro
ceed
b
y
induction
on
'
0
.
(elementary
)
T
rivial.
(v-cycle
)
Let
 
0
=
v
0

('
0

)
r
@

0
@
'
0


v
0
.
The
@-cycle

0
is
not
relativ
e
to
the
application
red
b
y
u.
Applying
the
induction
h
yp
othesis,
the
ancestor
of

0
in
'
is
an
@-cycle
.
By
h
y-
p
othesis,
'
is
legal.
Hence,
b
y
Corollary
..,
it
con
tains
a
subpath
 
=
v

('

)
r
@

@
'


v,
where
'

is
a
legal
path.
By
Lemma
..	
and
Corollary
..,
'

is
the
unique
ances-
tor
of
'
0

.
Th
us,
 
is
the
ancestor
of
 
0
.
(@-cycle
)
Let
@
0
b
e
the
@-no
de
o
v
er
whic
h
 
0
lo
ops.
By
denition,
 
comp
oses
of
an
alternated
sequence
of
paths
suc
h
that
 
0
=

0


v
0


 
0


v
0



0





0
k

v
0
k

 
0
k

v
0
k


0
k+
where,
an
y

0
i
is
in
ternal
to
the
argumen
t
P
0
of
@
0

,
while
an
y
v
0
i

 
0
i

v
0
i
is
a
v-cycle
o
v
er
a
v
ariable
of
P
0
.
Corresp
ondingly
,
in
'
there
is
a
path
 
=



v


 


v








k

v
k

 
k

v
k


k+
where,
an
y

i
is
the
ancestor
of
the
corresp
onding

0
i
,
and
an
y
v
i

 
i

v
i
is
the
ancestor
of
the
corresp
onding
v-cycle
v
0
i

 
0
i

v
0
i
.
In
particular,
b
y
Lemma
..	
an
y
v
i

 
i

v
i
is
a
v-cycle.
The
easy
case
is
when
none
of
the

i
crosses
u.
If
this
is
the
case,
it
is
indeed
immediate
to
see
that
all
the

i
are
in
ternal
to
the
argumen
t
P
of
the
@-no
de
@
at
the
b
eginning
of
 ,
and
that
all
the
v-cycles
are
o
v
er
v
ariables
free
in
P
.
Th
us,
let
us
analyze
the
other
situation.
The
edge
u
ma
y
o
ccur
in
some

i
only
when
the
v
ariable
x
of
u
o
ccurs
in
M.
According
to
this
w
e
ha
v
e
to
distinguish
t
w
o
sub
cases:
(i
)
u
o
ccurs
in
P
;
(ii
)
the
no
de
@
and
then
P
are
in
M.
In
case
(i
),
it
is
immedia
te
that
an
y

i
is
in
ternal
to
P
and,
as
a
consequence,
that 
is
an
@-cycle.
In
case
(ii
)
instead,
let
us
tak
e
the
rst
i
suc
h
that

i
con
tains
u.
The
only
p
ossibilit
y
is
that

i
=

i

w

u
@
v

i
,
where
w
is
an
o
ccurrence
of
x
and


Paths
v
is
the
con
text
edge
of
N.
According
to
this,
after

i
,
the
path
 
exits
from
P
and
en
ters
in
to
N,
but,
since
the
last
no
de
of
 
is
in
P
,
 
m
ust
ev
en
tually
reen
ter
in
to
N.
Let
us
see
ho
w
this
can
happ
en;
in
particular,
the
follo
wing
steps
will
sho
w
ho
w
to
build
an
@-cycle
starting
from
the
giv
en
o
ccurrence
of
u.
In
fact:
(a
)
no
v
ariable
free
in
N
is
b
ound
b
y
a
-no
de
in
P
;
(b
)
since

i
is
ancestor
of
a
path

0
i
con
tained
in
P
,

i
cannot
exit
N
through
an
y
v
ariable
free
in
N;
(c
)
when

i
is
completely
in
ternal
to
N,

0
i
is
in
ternal
to
the
instance
N
w
of
N
corresp
onding
to
the
discriminan
t
w;
(d
)
when

i
is
completely
in
ternal
to
N,
the
successiv
e
v-cycle
v
i

 
i

v
i
is
ancestor
of
a
v-cycle
o
v
er
a
v
ariable
o
ccur-
ring
free
in
N
w
,
then

0
i+
starts
at
a
-no
de
in
ternal
to
N
w
;
(e
)
as
for

i
,
neither

i+
can
exit
from
N
through
a
v
ariable
o
ccurring
free
in
N;
(f
)
iterating
the
previous
reasonings
w
e
nally
reac
h
some

j
that
exits
from
N
through
the
redex
u,
that
is,

j
=

j

v

u
@
e
w


j
;
(g
)
the
result
is
a
subpath

i




j
=

i

w

u
@
v



v

u
@
e
w


j
;
(h
)
since

is
the
ancestor
of
a
path

0
comp
osed
of
parts
in
ter-
nal
to
the
instance
N
w
of
N
and
v-cycles
o
v
er
v
ariables
o
ccurring
free
in
N
w
,
and

i




j
is
the
ancestor
of
the
path

0
i




0
j
con
taining

0
,
the
path
v

u
@
e
w
is
the
ancestor
of
the
ro
ot
edge
of
N
w
,
that
is,
w
=
e
w;
(i
)

is
an
@-cycle
o
v
er
the
application
in
u;
(j
)

i




j
comp
oses
of
t
w
o
parts

i
and

j
in
ternal
to
M
and
a
v-cycle
w

u
@
v



v

u
@
w
o
v
er
an
o
ccurrence
of
the
v
ariable
of
u.
The
previous
pro
cedure
can
b
e
iterated
for
the
next

k
that,
after
starting
in
M,
go
es
in
N
through
u;
and
so
on
for
all
the
o
ccurrences
of
u
con
tained
in
some

i
.
In
this
w
a
y
,
w
e
ev
en
tually
get
a
sequence
of
paths
in
ternal
to
M
alternated
with
v-cycles
either
o
v
er
x
or
o
v
er
v
ariables
o
ccurring
free
in
x:
M.
That
is,
 
is
an
@-cycle.

.
L
e
gal
Paths

Prop
osition
..
L
et
'
b
e
any
le
gal
p
ath
of
typ
e
@-
in
T
but
a
r
e
dex.
If
u
=
(x:
M
N)
is
the
leftmost-outermost
r
e
dex
tr
averse
d
by
'
in
T
,
let
T
u
!
T
0
.
Ther
e
is
a
unique
le
gal
p
ath
'
0
in
T
0
whose
anc
estor
is
'.
Pr
o
of
By
h
yp
othesis,
'
=
u.
So,
'
do
es
not
start
or
ends
at
the
p
ort
of
a
no
de
in
u.
Th
us,
the
h
yp
otheses
of
Lemma
..	
hold
and
'
is
ancestor
of
a
unique
wbp
'
0
in
T
0
.
By
Lemma
..0,
the
ancestor
 
of
an
y
@-cycle
 
0
in
'
0
is
an
@-cycle.
Th
us,
b
y
h
yp
othesis,
in
'
there
is
a
v-cycle

=
v

('

)
r
@
 
@
'


v.
Corresp
ondingly
(note
that

cannot
lo
op
o
v
er
an
o
ccurrence
of
the
v
ariable
of
u),
 
0
con
tains
a
subpath

0
=
v
0

('
0

)
r
@
 
0
@
'
00


v
00
,
where
'

is
an
ancestor
of
'
0

and
'
00

.
Using
the
same
tec
hnique
rep
eatedly
used
in
the
previous
lemma
s,
w
e
can
then
pro
v
e
that
'
0

=
'
00

and
v
0
=
v
00
.
(W
e
lea
v
e
the
details
of
the
latter
pro
of
to
the
reader
as
an
exercise.)
Theorem
..
(from
legal
paths
to
degrees)
F
or
any
le
gal
p
ath
'
of
typ
e
@-
in
a
term
T
,
ther
e
exists
a
de
gr
e
e
`
of
a
r
e
dex
originate
d
along
some
r
e
duction
of
T
such
that
path(`)
=
'.
Pr
o
of
By
Prop
osition
..,
when
a
legal
path
'
is
longer
than
a
simple
redex,
w
e
can
\con
tract"
it
in
to
another
legal
legal
path
'
0
b
y
ring
the
leftmost-outermost
redex
that
'
tra
v
erses.
Since
'
0
is
strictly
shorter
than
',
iterating
the
pro
cess
w
e
ev
en
tually
get
a
reduction

suc
h
that
the
con
tractum
of
'
is
a
single
redex
v.
F
urthermore,
since
lab
els
are
preserv
ed
b
y
con
traction,
the
path
yielded
b
y
the
degree
of
v
is
exactly
',
that
is,
path(degree

T
(v))
=
'.
Prop
osition
..
(canonical
deriv
ation
of
a
legal
path)
L
et
'
b
e
any
le
gal
p
ath
of
typ
e
@-
but
a
r
e
dex.
Assuming
that
the
c
anonic
al
derivation
of
a
r
e
dex
is
the
empty
one,
the
canonical
deriv
ation
of
'
is
obtaine
d
by
ring
the
leftmost-outermost
r
e
dex
in
',
and
iter
ating
this
pr
o
c
ess
over
its
unique
r
esidual.
Pr
o
of
By
induction
on
the
length
'.
The
base
case
is
ob
vious.
Then,
let
us
tak
e
a
legal
path
',
with
'
>
.
By
Lemma
..,
the
leftmost-
outermost
redex
tra
v
ersed
b
y
'
is
the
rst-one
red
b
y
the
canonical
deriv
ation
yielding
the
lab
el
of
'.
Let
it
b
e
u.
By
Prop
osition
..
the
residual
of
'
w.r.t.
u
is
unique
and
it
is
legal.
Let
it
b
e
'
0
(notice
that
its
length
is
shorter
than
').
By
induction,
'
0
has
a
canonical


Paths
deriv
ation
tting
with
the
statemen
t.
Let
it
b
e
.
The
deriv
ation
u
is
canonical,
b
y
the
denition
of
the
extraction
relation,
and
the
fact
that
u
is
needed.
Since
the
deriv
ation
u
preserv
es
the
lab
el
of
(all
the
residuals
of
)
',
the
prop
osition
is
pro
v
ed.
T
o
conclude,
let
us
remind
that
the
canonical
deriv
ation
yielding
a
re-
dex
lab
eled
as
'
is
unique,
for
the
bijectiv
e
corresp
ondence
b
et
w
een
canonical
deriv
ations
and
degrees.
The
previous
prop
osition
essen
tially
states
the
in
tuitiv
e
fact
that
al
l
and
only
the
(\virtual")
redexes
along
a
legal
path
are
needed
for
its
con
traction
to
a
single
redex.
Moreo
v
er,
the
uniqueness
of
the
residual
of
a
legal
path
with
resp
ect
to
its
leftmost-outermost
redex
also
pro
vides
a
unique,
standard
(and
th
us
canonical)
w
a
y
to
p
erform
this
con
traction.
..
L
e
gal
p
aths
and
optimal
r
e
ductions
Due
to
Theorem
..,
an
optimal
implemen
tatio
n
of
the
-calculus
m
ust
alw
a
ys
k
eep
a
unique
represen
tation
of
ev
ery
legal
path.
In
par-
ticular,
legal
paths
m
ust
b
e
physic
al
ly
shared
during
the
computation.
The
optimal
ev
aluation
can
th
us
pro
ceed
b
y
con
tracting
a
legal
path,
only
when
there
is
some
mec
hanism
ensuring
that
ev
ery
con
tractum
of
an
y
legal
subpath
has
a
unique
represen
tation.
More
precisely
,
supp
ose
to
ha
v
e
an
explicit
op
erator
of
duplication
(a
fan,
in
Lamping's
terminology).
Consider
a
legal
path
'.
An
essen
tial
condition
to
get
optimalit
y
is
that
a
fan
external
to
'
can
nev
er
en
ter
the
path.
On
the
other
side,
a
fan
already
in
ternal
to
'
can
b
e
freely
mo
v
ed
along
'
(pro
vided
it
do
es
not
en
ter
subpaths
of
t
yp
e
@-).
That
is,
w
e
ma
y
pursue
the
duplication
inside
a
path
@-,
for
the
p
ortion
of
paths
w
e
are
duplicating
ev
en
tually
b
elong
to
dieren
t
legal
paths.
As
a
matter
of
fact,
a
pr
er
e
quisite
chain
for
an
@-no
de
is
alw
a
ys
a
prex
of
a
legal
path,
up
to
the
rst
atomic
edge
represen
ting
a
redex.
The
in
teresting
fact
is
that
this
prex
is
alw
a
ys
unique
for
ev
ery
legal
path
starting
from
a
same
no
de.
In
a
sense,
prerequisite
c
hains
are
the
deterministic
part
of
legal
paths.
Similarly
,
a
prerequisite
c
hain
of
a
-no
de
is
the
unique
common
sux
of
ev
ery
legal
path
starting
from
the
last
edge
represen
ting
a
redex.
.
Consisten
t
P
aths
Consisten
t
paths
w
ere
in
tro
duced
in
[GAL	a
]
as
a
natural
extension
of
Lamping's
prop
er
paths.

.
Consistent
Paths

Prop
er
paths
ha
v
e
b
een
used
in
pro
ving
correctness
of
Lamping's
algo-
rithm.
In
fact,
in
order
to
establish
a
correct
matc
hing
relation
b
et
w
een
fans,
w
e
in
tro
duced
a
new
data
structure,
the
so-called
c
ontexts.
Con-
texts
store
the
branc
hing
information
corresp
onding
to
tra
v
erse
fan-in's
and
organize
it
in
to
lev
els,
reecting
in
this
the
stratied
organization
of
terms.
In
particular,
tra
v
ersing
a
fan-in
with
index
n,
a
mark
er
is
recorded
(pushed)
in
the
n-th
lev
el
of
the
con
text.
Mark
ers
pushed
in
to
a
con
text
while
tra
v
ersing
fan-in's
are
then
used
to
decide
ho
w
to
cross
fan-out's.
Namely
,
tra
v
ersing
a
fan-out
with
index
n,
the
mark
er
of
the
p
ort
to
pass
through
m
ust
matc
h
the
t
yp
e
of
the
top
mark
er
in
the
n-th
lev
el
of
the
con
text;
at
the
same
time,
this
tra
v
ersing
causes
the
consumption
of
that
mark
er,
whic
h
is
th
us
p
opp
ed
from
the
con-
text.
Croissan
ts
and
brac
k
ets
con
trol
instead
the
structure
of
con
texts,
for
they
mo
dify
con
texts
according
to
the
reorganization
of
lev
els
they
induce
on
terms:
a
croissan
t
with
index
n
adds
a
new
lev
el
at
heigh
t
n
and
increases
b
y

the
heigh
t
of
all
the
lev
els
ab
o
v
e
n;
a
brac
k
et
with
index
n
\compresses"
and
stores
the
information
of
lev
el
n
+

in
to
lev
el
n,
decreasing
b
y

the
heigh
t
of
all
the
lev
els
ab
o
v
e
n.
..
R
eminder
on
pr
op
er
p
aths
Before
to
go
on,
let
us
recall
the
denition
of
prop
er
path
(see
Sec-
tion
.).
A
level
is
an
elemen
t
of
the
set
inductiv
ely
generated
b
y
the
follo
wing
grammar:
(i)

is
a
lev
el
(the
empty
lev
el);
(ii)
if
a
is
a
lev
el,
then
so
are


a,


a;
(iii)
if
a
and
b
are
lev
els,
then
also
ha;
bi
is
a
lev
el.
A
c
ontext
is
an
innite
list
of
lev
els
con
taining
only
a
nite
n
um
b
er
of
non-empt
y
lev
els.
Namely:
(i)
the
empty
con
text
?
is
the
innite
list
of
empt
y
lev
els,
i.e.,
?
=
h?;
i;
(ii)
if
C
is
a
con
text
and
a
0
is
a
lev
el,
then
hC;
a
0
i
is
a
con
text.
An
y
con
text
A
has
the
follo
wing
shap
e:
A
=
h


hB;
a
n-
i



;
a
0
i
where
a
0
;
:
:
:
;
a
n-
are
lev
els,
and
B
is
a
con
text.
W
e
will
sa
y
that
A(i)
=
a
i
is
the
i-th
lev
el
of
the
con
text
A,
and
that
B
is
the
sub
con
text


Paths
of
A
at
width
n.
W
e
will
also
sa
y
that
A
n
[

]
=
hh


h

;
a
n-
i;



;
a

i;
a
0
i
are
the
lev
els
of
A
lo
w
er
than
n,
and
w
e
will
denote
b
y
A
n
[C]
the
con
text
obtained
replacing
C
for
the
sub
con
text
of
A
at
width
n
(in
our
case
replacing
C
for
B).
Let
us
also
remind
that,
in
spite
of
their
formalization
as
innite
lists,
con
texts
are
indeed
nite
ob
jects,
for
in
an
y
con
text
only
a
nite
n
um
b
er
of
lev
els
ma
y
b
e
non-empt
y
.
A
pr
op
er
p
ath
in
a
sharing
graph
G
is
a
path
suc
h
that:
(i)
Ev
ery
edge
of
the
path
is
lab
eled
with
a
con
text.
(ii)
Consecutiv
e
pairs
of
edges
satisfy
one
of
the
follo
wing
constrain
ts:
*
n
A  [<b, a>]
n
n
A [<b, o  a>]
.
*
n
A  [<b, a>]
n
n
A [<b,    a>]
*.
A [a]
n
n
n
A [<a,    >]
n
A [<<b,a>,c>]
n
A [<b, <a, c>>]
n
@n
A
A
@n
A
A
λn
A
A
Prop
er
paths
are
iden
tied
up
to
con
texts.
That
is,
t
w
o
prop
er
paths
ha
ving
pairwise
equal
edges
are
considered
equal,
ev
en
if
their
con
texts
dier.
The
problem
of
prop
er
paths
is
that
they
do
not
exploit
the
sym-
metry
b
et
w
een
-rule
and
fan-annihilation.
More
precisely
,
w
e
already
observ
ed
that
in
optimal
reduction
there
is
an
op
erational
analogy
b
e-
t
w
een
these
t
w
o
kind
of
rules.
Suc
h
a
corresp
ondence
is
at
the
base
of
the
denition
of
le
gal
p
ath.
In
fact,
hidden
b
ehind
the
construction
of
legal
paths
there
is
the
idea
that
an
@-no
de
is
a
fan
with
the
princi-
pal
p
ort
orien
ted
to
w
ards
the
function
edge
and
that
a
-no
de
is
a
fan
with
the
principal
p
ort
orien
ted
to
w
ards
the
con
text
edge.
According
to
this
in
terpretation,
it
is
immediate
to
see
that
-rule
b
ecomes
indeed
a
particular
case
of
fan-annihilation.
Nev
ertheless,
prop
er
paths
ha
v
e
the
follo
wing
restrictions:

A
path
cannot
tra
v
erse
a

from
the
binding
p
ort
to
the
con
text
p
ort
(or
vice
v
ersa).

.
Consistent
Paths
	

A
path
ma
y
tra
v
erse
an
application
from
an
auxiliary
p
ort
to
the
other
auxiliary
p
ort
(i.e.,
from
the
con
text
to
the
argumen
t
or
vice
v
ersa).
On
the
other
side,
a
path
cannot
tra
v
erse
an
application
from
its
principal
p
ort
(the
function
edge)
to
the
auxiliary
p
ort
corresp
onding
to
the
argumen
t.
Remo
ving
suc
h
dierences
b
et
w
een
fans
and
prop
er
no
des
w
e
get
the
notion
of
consisten
t
path.
..
Consistency
F
or
the
sak
e
of
clarit
y
,
with
resp
ect
to
the
presen
tation
giv
en
in
[GAL	a
],
w
e
shall
use
dieren
t
mark
ers
for
prop
er
no
des
and
fans.
W
e
will
th
us
ha
v
e
the
usual
sym
b
ols

and
?
for
auxiliary
p
orts
of
fans,
and
the
new
sym
b
ols
#
and
$
for
auxiliary
p
orts
of
prop
er
no
des.
According
to
this,
the
gramma
r
for
lev
els
b
ecomes:
a
::=

j


a
j
?

a
j
#

a
j
$

a
j
ha;
bi
In
the
follo
wing,
w
e
will
assume
that
con
texts
are
dened
in
the
usual
w
a
y
with
the
previous
extension
on
the
grammar
of
lev
els.
Denition
..
(consisten
t
paths)
A
c
onsistent
p
ath
in
a
sharing
graph
is
an
undirected
path
that
can
b
e
consisten
tly
lab
eled
b
y
con
texts
according
to
the
rules
in
Figure
..
As
for
prop
er
paths,
consisten
t
lab
eling
of
a
path
is
just
a
sort
of
cor-
rectness
criteria.
So,
paths
are
equated
mo
dulo
con
texts.
Nev
ertheless,
let
us
remark
that
the
idea
b
ehind
consisten
t
paths
is
to
nd
a
suitable
denotational
in
terpretation
of
paths,
that
is,
some
prop
ert
y
in
v
arian
t
under
reduction.
F
rom
this
p
oin
t
of
view,
the
denotation
asso
ciated
to
a
path
is
the
con
text
transformation
mapping
the
input
con
text
of
the
path
to
the
output
one.
Prop
er
paths
yielded
this
prop
ert
y
with
resp
ect
to
rules
in
v
olving
con
trol
no
des,
hence
correctness
of
Lamping's
algo-
rithm
has
b
een
pro
v
ed
with
resp
ect
to
the
-term
matc
hing
the
graph
(w
e
will
come
bac
k
to
this
tec
hnique
in
Chapter
).
Nev
ertheless,
-rule
causes
a
global
rearrangemen
t
of
prop
er
paths.
Th
us,
an
y
denotational
prop
ert
y
of
them
is
immediately
lost
in
presence
of
-reduction.
In
the
case
of
consisten
t
paths
w
e
rather
ha
v
e
that
an
y
reduction
rule|
included|only
causes
a
lo
cal
rearrangemen
t
of
the
corresp
onding
paths
(this
should
not
b
e
surprising,
for
prop
er
no
des
b
ecome
sp
ecial
cases
of
fans).
Hence,
assuming
that
the
initial
and
nal
no
des
of
a
consisten
t

	0
Paths
@n
n
A  [<b, a>]
n
.
A [<b, $  a>]
@n
n
.
A [<b, #  a>]
n
A  [<b, a>]
A [a]
n
n
n
A [<a,    >]
n
A [<<b,a>,c>]
n
A [<b, <a, c>>]
n
n
A  [<b, a>]
n
.
A [<b, #  a>]
λn
n
A  [<b, a>]
λn
n
.
A [<b, $  a>]
*
n
A  [<b, a>]
n
n
A [<b,    a>]
*.
*
n
A  [<b, a>]
n
A [<b, o  a>]
.
n
Fig.
..
Gon
thier's
con
text
transformations
path
do
not
disapp
ear
along
the
reduction,
the
input-output
transfor-
mation
asso
ciated
to
suc
h
a
path
can
b
e
seen
as
its
denotation.
Prop
osition
..
The
c
ontext
tr
ansformation
b
etwe
en
the
initial
and
nal
p
oint
of
a
c
onsistent
p
ath
is
invariant
during
optimal
r
e
duction
of
the
gr
aph
(pr
ovide
that
the
initial
and
nal
no
des
of
the
p
ath
have
not
b
e
en
er
ase
d
along
the
r
e
duction).
Pr
o
of
By
insp
ection
of
the
graph
rewriting
rules.
The
next
example
sho
ws
in
details
the
shap
e
of
consisten
t
paths
in
sharing
graphs.
Example
..
The
dotted
path
in
Figure
.
is
a
consisten
t
path.
A
p
ossible
c
hoice
of
con
texts
lab
eling
the
path
is
the
follo
wing
one
(starting

.
Consistent
Paths
	
from
the
ro
ot
of
the
term):
hX;
$

i
hX;
$

$

i
hX;
$

i
hX;
i
hX;
$

i
hhX;
$

i;
i
hhX;
$

i;


i
hhX;
$

i;
#



i
hhX;
$

i;


i
hhX;
i;


i
hhhX;
i;
i;


i
hhhX;
i;
#

i;


i
hhhX;
i;
#

i;
#



i
hhhX;
i;
#

i;


i
hhhX;
i;
#

i;
i
hhX;
i;
#

i
hhX;
i;
i
where
X
is
an
arbitrary
con
text.
*
λ
@
@
λ
@
λ
0
0
0
0
0
0
1
1
0
1
0
2
1
1
Fig.
..
Consisten
t
paths.

	
Paths
Exercise
..
V
erify
Prop
osition
..
reducing
the
sharing
graph
in
Example
..
(Figure
.).
Let
us
note
that,
constructing
the
path
in
Figure
.,
w
e
could
not
start
with
an
arbitrary
con
text.
W
e
should
rather
use
something
lik
e
hh

;
$

biai.
This
w
as
not
the
case
for
prop
er
paths,
where
starting
at
the
ro
ot
of
a
sharing
graph
w
e
could
use
an
y
con
text.
Th
us,
the
transformation
issued
b
y
consisten
t
paths
is
a
relation
or,
more
precisely
,
a
partial
function.
W
e
should
no
w
observ
e
that,
building
a
giv
en
path,
the
shap
e
that
w
e
m
ust
assign
at
the
ro
ot
edge
is
a
sort
of
\observ
ation"
of
the
prop
er
no
des
crossed
b
y
the
path
(con
trol
no
des
do
not
inuence
this
initial
v
alue).
Because
of
this,
there
is
indeed
go
o
d
evidence
that
w
e
could
retriev
e
a
denotation
of
the
term
represen
ted
b
y
a
sharing
graph
from
the
set
of
its
consisten
t
paths|in
particular,
that
w
e
could
build
its
B
ohm's
tree.
An
yho
w,
at
presen
t,
no
formal
pro
of
of
this
fact
exists
in
literature;
although
Gon
thier,
Abadi
and
L

evy
claimed
it
in
[GAL	a
].
In
fact,
the
sk
etc
h
of
pro
of
of
correctness
in
[GAL	a
]
rested
on
that
corresp
ondence
b
et
w
een
consisten
t
paths
and
B
ohm
trees.
Nev
ertheless,
a
detailed
pro
of
attempt
based
on
that
approac
h
is
actually
m
uc
h
more
complicated
than
the
one
follo
w
ed
in
the
b
o
ok,
for
using
consisten
t
paths
no
simple
read-bac
k
pro
cedure
can
b
e
pro
vided.
Let
us
nally
remark
that
the
relation
b
et
w
een
Lamping's
and
Gon
thier's
con
text
seman
tics
do
es
rely
on
the
so-called
tr
ansp
ar
ency
prop
ert
y
(see
Prop
osition
..0).
Namely
,
if
w
e
describ
e
a
lo
op
inside
the
function
part
of
an
application,
and
this
function
is
in
v
olv
ed
in
a
-redex,
the
con
text
transformation
dened
b
y
suc
h
a
lo
op
is
inessen
tial
to
the
read-
bac
k
of
the
argumen
t
part
of
this
application.
So,
instead
of
crossing
the
lo
op,
w
e
can
just
pass
from
the
con
text
p
orts
of
the
application
to
its
argumen
t
p
ort,
as
Lamping
actually
do
es.
.
Regular
P
aths
Once
ha
ving
understo
o
d
the
notion
of
consisten
t
path,
the
reader
should
not
ha
v
e
m
uc
h
problems
to
shift
to
r
e
gular
p
aths.
The
general
idea
is
the
follo
wing:
instead
of
considering
the
no
des
of
the
sharing
graph
as
con
text
transformers,
let
us
directly
lab
el
eac
h
(orien
ted)
edge
of
the
graph
with
a
\w
eigh
t"
in
a
suitable
algebra
(the
dynamic
algebr
a)
that
essen
tially
em
b
o
dies
the
con
text
transformation
giv
en
b
y
its
tra
v
ersal.
The
w
eigh
t
of
a
path
is
then
dened
as
the
(an
timorphical)
comp
osition
of
the
w
eigh
ts
of
its
edges.
Equations
of
the
dynamic
algebra
will
reect

.
R
e
gular
Paths
	
the
consistency
conditions
of
the
previous
section.
In
particular,
since
inconsistency
will
corresp
ond
to
ha
v
e
a
w
eigh
t
equal
to
0,
a
path
will
b
e
consisten
t,
or
r
e
gular,
when
its
w
eigh
t
will
dier
from
0.
This
in
tro
duction
to
regular
paths
is
completely
ap
o
cryphal.
As
a
matter
of
fact,
regular
paths
ha
v
e
b
een
in
tro
duced
b
y
Danos
and
Reg-
nier
some
time
b
efore
consisten
t
paths,
and
with
totally
dieren
t
aims
(actually
,
they
are
the
rst
notion
of
a
path
ev
er
in
tro
duced
in
the
lit-
erature,
apart
from
the
v
ery
restricted
case
of
Lamping's
paths).
More
precisely
,
regular
paths
w
ere
devised
in
the
con
text
of
Girard's
Geometry
of
In
teraction
y
with
the
aim
of
pro
viding
a
mathematical
ac-
coun
t
of
-reduction
(and
more
generally
,
of
cut
elimination)
that
could
describ
e
its
apparen
tly
global
and
sequen
tial
nature
as
a
sequence
of
lo
cal
and
parallel
elemen
tary
mo
v
es.
T
o
this
aim,
Danos
and
Regnier
rein
ter-
preted
Girard's
Exe
cution
F
ormula
EX
as
the
computation
of
suitable
paths,
called
r
e
gular,
in
the
graphical
represen
tation
of
-terms
(that,
as
w
e
ha
v
e
seen,
is
inherited
from
pro
of
nets
of
Linear
Logic).
EX
is
a
scalar
v
alue
attac
hed
to
the
graph
and
b
elonging
to
the
dynamic
algebra
L

,
an
in
v
erse
semigroup
(see
[CP
])
of
partial
one-to-one
transformations
of
an
y
coun
table
set
(sa
y
N).
The
computation
of
EX
(virtual
reduction)
can
b
e
describ
ed
b
y
a
single
completely
lo
c
al
and
asynchr
onous
rule:
the
comp
osition
of
t
w
o
edges.
..
The
Dynamic
A
lgebr
a
LS
W
e
giv
e
a
presen
tation
of
the
dynamic
algebra
LS
as
an
equational
theory
.
W
e
dene
at
the
same
time
the
language
and
the
(equational)
axioms
of
LS
.
Items
are:

a
comp
osition
function
whic
h
is
asso
ciativ
e;

a
neutral
constan
t

and
an
absorbing
constan
t
0
for
comp
osition;

an
in
v
olution
op
eration
u

satisfying
(PQ)

=
Q

P

0

=
0


=

for
an
y
P
and
Q
in
LS
;

t
w
o
multiplic
ative
c
o
ecients
p
and
q
satisfying
the
annihilation
ax-
ioms
:
p

p
=
q

q
=;

p

q
=
q

p
=
0
y
\In
teractio
n"
means
dealing
with
lo
cal
computation
s
of
a
logical
nature;
\geometry
of
"
means
b
y
geometric
(or
algebraic)
to
ols.

	
Paths

four
exp
onential
c
onstants
r,
s,
t,
d
satisfying
the
annihilation
axioms:
r

r
=
s

s
=
d

d
=
t

t
=

s

r
=
0

a
morphism
!
for
comp
osition,
0,

and
;

the
exp
onen
tial
constan
ts
and
the
morphism
!
are
related
b
y
the
fol-
lo
wing
c
ommutation
axioms
!(P
)r
=
r!(P
)
!(P
)s
=
s!(P
)
!(P
)t
=
t!

(P
)
!(P
)d
=
dP
:
where
P
is
an
y
elemen
t
of
LS
.
Let
us
no
w
consider
an
orien
ted
graph
lab
eled
b
y
elemen
ts
of
the
dynamic
algebra.
The
weight
of
an
edge
is
just
the
lab
el
of
the
edge.
The
w
eigh
t
w(')
of
a
path
'
is
inductiv
ely
giv
en
b
y
the
follo
wing
rules:
(i)
If
'
is
a
n
ull
path
(a
path
starting
and
ending
in
the
same
no
de,
crossing
no
edge),
then
its
w
eigh
t
is
.
(ii)
If
'
is
u'
0
(resp.
u
r
'
0
),
then
w(')
=
w('
0
)w(u)
(resp.
w('
0
)w(u)

),
where
u
is
an
orien
ted
edge.
Note
that
w
eigh
ts
are
comp
osed
an
timorphically
with
resp
ect
to
path
comp
osition
and
that
w
e
ha
v
e
w('
r
)
=
w(')

.
Denition
..
A
path
'
is
r
e
gular
if
and
only
if
LS
`
w(')
=
0.
Read
sequences
of
!
as
a
denotation
for
lev
els,
there
is
an
ob
vious
analogy
b
et
w
een
the
op
erational
b
eha
vior
of
d
and
t
as
expressed
b
y
the
comm
utatio
n
rules,
and
the
rewriting
rules
for
croissan
t
and
brac
k
et
in
Lamping's
algorithm.
Similarly
for
annihilation
and
-rule,
in
whic
h
r
and
s
should
b
e
in
terpreted
as
the
t
w
o
branc
hes
of
fans,
and
p
and
q
as
the
t
w
o
branc
hes
of
application
and
-no
des.
Starting
from
this
analogy
,
the
lab
eling
of
graphs
for
-terms
depicted
in
Figure
.
should
come
as
no
surprise
(the
in
teresting
fact
is
that
this
enco
ding
w
as
kno
wn
b
efor
e
Lamping's
algorithm).
A
t
rst
sigh
t
the
denition
of
regularit
y
migh
t
lo
ok
prett
y
ineec-
tiv
e,
for
it
is
usually
hard
to
sho
w
that
something
is
not
pro
v
able
in
an
axiomatic
theory
.
Nev
ertheless,
the
follo
wing
theorem
due
to
Regnier
sho
ws
that
in
LS
it
is
rather
easy
to
compute
whether
a
w
eigh
t
of
a
path
is
(pro
v
ably)
n
ull
or
not.
Theorem
..
(AB

)
L
et
M
b
e
a
term
and
'
b
e
a
p
ath
in
G
(M).
The
weight
w(')
r
ewrites
by
the
left
to
right
oriente
d
e
quations
of
LS
either
into
0,
or
into
an
element
AB

of
LS
,
wher
e
A
and
B
ar
e
p
ositiv
e,
i.e.,

.
R
e
gular
Paths
	
[MN]n = 
[M]n
[N]n+1
! (d)
n
! (d)
n
= 
λ
[   x.M]n
[M]n
n! (q)
  
  
  
  
  
  
  
      

      

      

      

  
  
    
    

    

. . .
. . .
n! (p)
n! (q)
1
n
n
! (t)
! (t)
[x]n = 
. . .
n! (p)
Fig.
..
-term
lab
eling
in
the
dynamic
algebra
LS
.
an
element
of
LS
p
ossibly
e
qual
to

and
c
ontaining
neither
the
c
onstant
0,
nor
the
symb
ol
.
Pr
o
of
See
[Reg	
].
Let
us
no
w
supp
ose
that
AB

=
0,
for
some
p
ositiv
e
A
and
B.
By
induction
on
the
n
um
b
er
of
constan
ts
in
A,
w
e
see
that
A

A
=
.
Simi-
larly
,
w
e
also
ha
v
e
B

B
=
.
Th
us,
w
e
w
ould
get
LS
`
0
=
.
But
this
is
con
tradicted
b
y
the
fact
that
LS
has
at
least
a
non
trivial
mo
del
(see
section
..).
Th
us
rewriting
a
w
eigh
t
in
to
AB

form
sho
ws
indeed
that
it
is
not
pro
v
ably
n
ull
in
LS
.
The
foregoing
argumen
t
has
an
in
teresting
corollary
concerning
mo
d-
els
of
LS
.
Corollary
..
L
et
M
b
e
a
non
trivial
mo
del
of
LS
and
M
b
e
a
term.
Then,
for
every
p
ath
'
in
G
(M)
we
have
LS
`
w(')
=
0
i
M
j
=
w(')
=
0:
Remark
..
The
previous
corollary
is
not
the
case
in
general:
usually
a
mo
del
satises
more
equations
than
the
theory
.
F
or
instance,
one
ma
y
nd
some
non
trivial
mo
del
of
LS
in
whic
h
t

d
=
0,
that
is
not
pro
v
able
in
LS
(i.e.,
there
are
some
other
mo
dels
in
whic
h
t

d
=
0).
In
fact,
AB


	
Paths
theorem
and
its
corollary
are
only
v
alid
for
w
eigh
ts
of
paths.
Ho
w
ev
er,
it
is
a
strong
result,
since
it
states
that
an
y
non
trivial
mo
del
of
LS
is
as
go
o
d
as
the
theory
for
deciding
regularit
y
.
Example
..
Let
us
consider
the
regular
path
dra
wn
b
y
a
dotted
line
in
Figure
.
(let
us
notice
to
o
that
this
is
the
consisten
t
one
already
considered
in
Figure
.).
The
w
eigh
t
of
this
path
is
w
=
p



d

r

p

p!(p)!(d)(!(q))

p

prdqq

q

q
Let
us
simplify
it
(w
e
already
erased
all
the
o
ccurrences
of
):
w
=
p

d

r

p

p!(p)!(d)(!(q))

p

prdqq

q

q
=
p

d

r

p

p!(p)!(d)(!(q))

p

prdqq

=
p

d

r

p

p!(p)!(d)(!(q))

rdqq

=
p

d

r

p

p!(p)!(d)!(q

)rdqq

=
p

d

r

p

p!(p)!(d)r!(q

)dqq

=
p

d

r

p

p!(p)!(d)rdq

qq

=
p

d

r

p

p!(p)!(d)rdq

=
p

d

r

p

p!(p)r!(d)dq

=
p

d

r

p

p!(p)rddq

=
p

d

r

p

pr!(p)ddq

=
p

d

r

p

prdpdq

=
p

d

r

rdpdq

=
p

d

dpdq

=
p

pdq

=
dq

The
theorem
AB

has
a
natural
coun
terpart
in
sharing
graphs.
Theorem
..
L
et
G
b
e
a
sharing
gr
aph
and

b
e
a
c
onsistent
p
ath
in
G.
If
we
r
e
duc
e
all
r
e
dexes
internal
to

(i.e.,
we
normalize
it),
the
r
esidual

0
of

is
the
c
omp
osition
of
two
p
aths




,
wher
e


tr
averses
no
des
fr
om
princip
al
to
auxiliary
p
orts,
and


tr
averses
no
des
fr
om
auxiliary
to
princip
al
p
orts.
Pr
o
of
[Sk
etc
h]
Supp
ose
otherwise.
Then
w
e
should
ha
v
e
inside

0
a
pair
of
no
des
connected
to
their
principal
p
orts.
This
is
either
a
redex,

.
R
e
gular
Paths
	
q
p
1
!(q)
!(d)
!(p)
q
q
q
p
!(q)
!(p)
1
!(d)
s
d
r
1
!!(d)
!(t)
t
t
p
p
Fig.
..
A
regular
path.
con
tradicting
the
h
yp
othesis
that

w
as
in
normal
form,
or
a
deadlo
c
k,
con
tradicting
the
h
yp
othesis
that

(and
th
us

0
)
w
as
consisten
t.
F
or
instance,
let

b
e
the
path
in
Figure
..
If
y
ou
reduce
all
redexes
in
ternal
to

and
consider
the
residual

0
of

in
the
nal
graph,

0
tra
v
erses
in
order
a

of
index
0
from
the
principal
to
the
b
o
dy
p
ort,
and
a
croissan
t
of
index
0
from
the
auxiliary
to
the
principal
p
ort.
Note
the
corresp
ondence
with
the
reduced
w
eigh
t
of
.
..
A
mo
del
A
simple
mo
del
of
the
dynamic
algebra
is
giv
en
b
y
the
the
in
v
erse
semi-
group
L

of
p
artial
one-to-one
transformations
of
N
(see
[CP]).
Let
0
and

b
e
resp
ectiv
ely
the
no
where
dened
transformation
and
the
iden
tit
y
of
N.
F
or
an
y
elemen
t
x
in
L

,
let
x

b
e
its
in
v
erse
trans-
formation.
W
e
ha
v
e:
(xy)z
=
x(yz)
(.0)
(x

)

=
x
(.)

	
Paths
(xy)

=
y

x

(.)
xx

x
=
x
(.)
Let
hxi
=
xx

(resp.
hx

i
=
x

x),
that
is

restricted
to
the
co
domain
(resp.
the
domain)
of
x.
Ob
viously
,
hxi
=
xx

and
hx

i
=
x

x
are
idemp
oten
ts,
since
hxihxi
=
xx

xx

=
xx

=
hxi,
and
symmetrically
for
hx

i.
The
v
ery
basic
prop
ert
y
of
in
v
erse
semigroups
is
that
idemp
oten
ts
comm
ute.
Namely:
hxihyi
=
hyihxi
(.)
Axioms
(0)-()
pro
vide
a
p
ossible
axiomatization
of
in
v
erse
semi-
groups
(see
[P
et
]).
Let
us
no
w
consider
some
in
teresting
consequences
of
these
axioms.
Prop
osition
..
L
et
a
b
e
an
idemp
otent.
Then,
a
=
a

.
Pr
o
of
Let
a
=
aa,
a

=
a

a

.
W
e
pro
ving
that
a
=
aa

.
a
=
aa

a
=
aaa

a

a
=
ahaiha

i
=
aha

ihai
=
aa

aaa

=
aaa

=
aa

Then,
a

=
(aa

)

=
(a

)

a

=
aa

,
and
b
y
transitivit
y
a
=
a

.
Corollary
..
If
a
and
b
ar
e
idemp
otents,
then
ab
=
ba.
Pr
o
of
Ob
vious,
since
b
y
the
previous
prop
osition
a
=
hai.
W
e
already
ha
v
e
the
basic
ingredien
ts
for
in
terpreting
the
monomia
ls
of
the
dynamic
algebra
LS
.
In
particular,
w
e
can
tak
e:
[
[]
]
L

=

[
[0]
]
L

=
0
[
[(a)

]
]
L

=
([
[a]
]
L

)

[
[ab]
]
L

=
[
[a]
]
L

[
[b]
]
L


.
R
e
gular
Paths
		
Our
next
step
is
to
giv
e
an
in
terpretation
to
p;
q;
r;
s;
d;
t
and
the
\of
course"
sym
b
ol.
The
constan
ts
p
and
q
are
not
a
problem:
just
tak
e
an
y
t
w
o
total
transformations
with
disjoin
t
co
domains.
F
or
instance:
[
[p]
]
L

(n)
=
n
[
[q]
]
L

(n)
=
n
+

No
w,
let
(m:n)
!
dm;
ne
b
e
a
one-to-one
mapping
of
N

on
to
N.
W
e
shall
denote
b
y
dn

;
:
:
:
;
n
k
e
the
in
teger
dn

;
dn

;
:
:
:
dn
k-
;
n
k
e;
:
:
:
ee.
W
e
can
dene
the
functional
!
L

:
N
N
!
N
N
,
assuming
that:
!
L

(f)dm;
ne
=
dm;
f(n)e
for
an
y
transformation
f.
Th
us,
for
an
y
monom
ial
a
of
LS
,
w
e
can
tak
e:
[
[!(a)]
]
L

=
!
L

([
[a]
]
L

)
Finally
,
let
k
b
e
an
arbitrary
in
teger
and
;

and

three
total
trans-
formations
suc
h
that

and

ha
v
e
disjoin
t
co
domains.
W
e
dene:
[
[d]
]
L

(n)
=
dk;
ne
[
[t]
]
L

dl;
dm;
nee
=
d(dl;
me);
ne
[
[r]
]
L

dm;
ne
=
d(m);
ne
[
[s]
]
L

dm;
ne
=
d(m);
ne
W
e
lea
v
e
as
an
exercise
the
easy
v
erication
that
the
previous
in
ter-
pretation
satises
the
axioms
of
LS
.
W
e
only
remark
that
the
denition
of
[
[

]
]
L

has
b
een
sub
ject
to
a
lot
of
arbitrary
c
hoices,
starting
from
the
bijectiv
e
function
(m:n)
!
dm;
ne.
As
a
consequence,
it
is
p
ossible
to
build
without
m
uc
h
eort
some
other
in
terpretation
satisfying
addi-
tional
equations.
F
or
instance,
[
[(t

d)]
]
L

=
[
[0]
]
L

if
and
only
if
k
is
not
in
the
range
of
.
..
Virtual
R
e
duction
Let
us
start
adding
some
more
structure
to
our
algebra.
In
the
mo
del
of
partial
transformations
L

,
it
is
natural
to
in
tro
duce
a
sort
of
c
om-
plementation
of
a
transformation
f,
that
is
an
op
eration
dened
b
y
f
=

-
hfi
=

-
ff

.
The
main
equations
concerning
this
op
eration
w
ould
b
e
the
follo
wing:

=
0
(.)

00
Paths
0
=

(.)
xy
=
xyx
(.)
Finally
,
let
us
remind
that

is
a
neutral
elemen
t
and
that
0
is
absorb-
ing.
Namely
,
that
w
e
ha
v
e:
x
=
x
=
x
(.)
0x
=
0
=
x0
(.	)
These
axioms,
in
conjunction
with
axioms
()-()
of
the
previous
sec-
tion,
pro
vide
an
axiomatization
of
the
notion
of
b
ar-inverse
monoid
in-
tro
duced
b
y
Danos
and
Regnier
in
[DR	
].
Let
us
see
some
in
teresting
consequences
of
them.
Prop
osition
..	
)
x
x
=
0;
)
x
x
=
x
;
)
x

=
x
)
x

x
=
0;
)
x
y
=
y
x;
)
x
hyi
=
hyix;
)
xy
xy
=
x;
)
xx

=
x;
	)
x
x
=
x;
0)
xx

=
x.
Pr
o
of
)
xx
=
x
x
=
x
=
x0
=
0;
)
x
x
=
xxx
=
0
x
=
x
=
x;
)
b
y
)
and
Prop
osition
..;
)
x

x
=
x

x

=
(xx)

=
0

=
0;
)
b
y
)
and
Corollary
..;
)
b
y
)
and
Corollary
..;
)
xy
xy
=
xy
xy
=
xy
x
xy
=
xy
x
=
x
xy
=
xxy
x
=
0y
x
=
x
=
x;
)
xx

=
xx

x
=
0x
=
x;
	)
let
us
pro
v
e
that
(xx)

=
x

.
W
e
ha
v
e
(xx)

=
x

x

=
x

x
=
x,
b
y
the
previous
prop
ert
y;
0)
xx

=
xx


=
xx

xx

=
x,
b
y
).

.
R
e
gular
Paths
0
Prop
osition
..0
The
fol
lowing
c
onditions
ar
e
e
quivalent:
)
hxihyi
=
0
)
x

y
=
0
)
y
x
=
x
)
x
y
=
y
Pr
o
of
)
)
)
Supp
ose
xx

yy

=
0.
Then:
x

y
=
x

xx

yy

y
=
0
)
)
)
Supp
ose
x

y
=
0.
Then:
x

y
=
x

yx

=
0
x

=
x

and
th
us
x
=
(x

y
)

=
(y)

x
=
yx
)
)
)
Supp
ose
yx
=
x
and
let
us
pro
v
e
that
y

x
=
y

.
Using
the
fact
that
y

y
=
0,
w
e
ha
v
e:
y

x
=
y

xy

=
y

y
xy

=
0y

=
y

Then:
y
=
(y

x)

=
(x)

y
=
xy
)
)
)
Recall
that
x

x
=
0.
Then:
xx

yy

=
xx

xyy

=
0
Using
the
previous
algebraic
material,
w
e
can
no
w
dene
an
in
terest-
ing
notion
of
virtual
r
e
duction
on
our
graphs
lab
eled
b
y
w
eigh
ts
of
the
dynamic
algebra.
Let
us
assume
to
ha
v
e
the
follo
wing
conguration,
where
w
e
ha
v
e
t
w
o
edges
a
x
!
b
and
b
y
!
c:
b
a
c
y
x
Remark
..
According
to
the
in
terpretation
in
LS
,

means
to
re-
v
erse
the
orien
tation
of
a
path.
Th
us,
in
the
sequel,
w
e
shall
implicitl
y
iden
tify
the
edges
a
x
!
b
and
b
x

!
a.

0
Paths
The
w
eigh
t
of
the
comp
osed
path
is
yx.
So,
w
e
could
consisten
tly
add
a
new
edge
b
et
w
een
a
and
c
with
w
eigh
t
yx.
W
e
w
ould
also
b
e
tempted
to
remo
v
e
the
t
w
o
original
edges,
since
w
e
already
computed
their
comp
osition.
Ho
w
ev
er,
this
could
b
e
wrong,
since
there
could
exist
other
incoming
edges
in
b,
and
other
p
ossible
paths
whic
h
ha
v
e
not
b
een
considered
y
et.
On
the
other
side,
w
e
cannot
just
lea
v
e
the
original
edges
as
they
are,
since
they
could
comp
ose
together
o
v
er
and
o
v
er
again,
prev
en
ting
an
y
sensible
notion
of
r
e
duction
of
the
graph.
In
tuitiv
ely
,
w
e
w
ould
just
recall
that
the
t
w
o
edges
lab
eled
b
y
x
and
y
ha
v
e
b
een
already
comp
osed.
An
elegan
t
w
a
y
to
do
that,
is
remo
v
e
from
y
of
the
part
of
its
w
eigh
t
red
in
the
comp
osition
with
x
(and
symmetrically
for
x).
F
ormally
,
this
is
ac
hiev
ed
restricting
y
b
y
the
complemen
tary
of
the
left
unit
of
y,
that
is
y
(and
symmetrically
for
x).
So,
the
virtual
r
e
duction
of
the
ab
o
v
e
conguration
leads
to:
b
a
c
yx
yx
y*x
If
w
e
try
to
comp
ose
again
the
residual
of
the
original
edges,
w
e
w
ould
no
w
get
a
new
edge
with
w
eigh
t
0.
Indeed:
yx
y

x
=
yy

xx
=
0
Ob
viously
,
there
is
no
in
terest
in
adding
0
w
eigh
ted
edges
to
the
graph,
so
w
e
can
just
prev
en
t
the
previous
recomp
osition
b
y
requiring
that
the
op
er
ation
of
virtual
r
e
duction
c
an
b
e
only
applie
d
to
p
air
of
e
dges
whose
c
omp
ose
d
weight
is
dier
ent
fr
om
0.
Actually
,
the
previous
op
eration
of
reduction
can
b
e
seen
as
the
com-
p
osition
of
t
w
o
more
elemen
tary
steps
splitting
and
mer
ging.

Splitting
an
edge
a
x
!
b
b
y
a
w
eigh
t
w
amoun
ts
to
replace
the
edge
with
t
w
o
edges
a
wx
!
b
and
a
w
x
!
b.

The
op
eration
of
mer
ging
t
w
o
distinct
edges
a
x
!
b
and
b
y
!
c
is
only
dened
if
hxi
=
hy

i;
in
this
case,
it
amoun
ts
to
erasing
the
t
w
o
original
edges
and
replacing
them
with
a
new
edge
a
xy
!
c.
Denition
..
(virtual
reduction)
The
r
e
duction
of
t
w
o
distinct
edges
a
x
!
b
and
b
y
!
c
is
only
dened
if
xy
=
0.
In
this
case,
it
consists
in:

.
R
e
gular
Paths
0
(i)
Splitting
a
x
!
b
b
y
hy

i,
that
is,
replacing
it
b
y
a
hy

ix
!
b
and
a
hy

ix
!
b.
(ii)
Splitting
c
y

!
b
b
y
hxi,
that
is,
replacing
it
b
y
c
hxiy

!
b
and
c
hxiy

!
b.
(iii)
Merging
the
edges
a
hy

ix
!
b
and
b
yhxi
!
c,
that
is,
replacing
them
with
a
new
edge
a
w
!
c,
where
w
=
yhxihy

ix
=
yhy

ihxix
=
yx.
As
w
e
ha
v
e
seen,
during
the
virtual
reduction
of
t
w
o
edges
a
x
!
b
and
b
y
!
c
their
w
eigh
ts
are
mo
died
in
order
to
prev
en
t
their
recomp
osition.
Ho
w
ev
er,
what
ab
out
other
p
ossible
edges
colliding
in
b?
(e.g.,
as
in
the
situation
of
Figure
.)
Can
w
e
ensure
that
w
e
do
not
unadvisedly
mo
dify
the
w
eigh
t
of
other
paths
b
y
our
notion
of
reduction?
y
x
yx
yx
y*x
b
b
a
c
a
c
z
z
d
d
Fig.
..
Colliding
edges.
The
answ
er,
in
general,
is
no!
Supp
ose
for
instance
that
in
the
struc-
ture
of
Figure
.
z
=
x:
ob
viously
,
after
reducing
a
x
!
b
and
b
y
!
c
w
e
lo
ose
the
path
from
d
to
c
whic
h
has
no
w
w
eigh
t
0.
Ho
w
ev
er,
the
idea
is
that
suc
h
a
conguration
is
p
atholo
gic
al.
In
a
sense,
if
the
t
w
o
w
eigh
ts
x
and
z
are
not
disjoin
t,
they
are
conicting
on
the
use
of
y,
and
this
kind
of
conict
should
b
e
clearly
prev
en
ted
in
a
\sound"
structure.
Then,
what
w
e
ma
y
exp
ect,
is
that
the
virtual
reduction
of
a
\sound"
structure
should
preserv
e
its
soundness.
The
required
notion
of
soundness
is
the
follo
wing:
Denition
..
Let
a
x
!
d,
b
y
!
d
and
c
x
!
d
three
distinct
coinci-

0
Paths
den
t
edges.
W
e
sa
y
that
they
are
wel
l
split
if
and
only
if:
hxihyihzi
=
0
A
graph
is
w
ell
split
when
the
w
ell
split
condition
is
satised
b
y
all
its
edges.
Prop
osition
..
Wel
l
splitness
is
pr
eserve
d
by
splitting,
mer
ging
and
(henc
e)
by
virtual
r
e
duction.
Pr
o
of
Exercise.
W
e
also
lea
v
e
as
an
exercise
to
the
reader
the
pro
of
that
an
y
graph
obtained
b
y
lam
b
da
terms
using
the
enco
ding
of
Figure
.
is
w
ell
split.
The
most
imp
ortan
t
prop
ert
y
of
virtual
reduction
is
that,
on
a
w
ell
split
graph,
it
preserv
es
the
w
eigh
ts
of
paths.
Consider
again
the
case
of
Figure
.,
and
the
path
leading
from
d
to
c
In
the
initial
conguration,
this
path
has
a
w
eigh
t
yz,
while
after
the
reduction,
its
w
eigh
t
is
yx
z.
W
e
ha
v
e
to
pro
v
e
that
they
are
equal.
Our
h
yp
othesis
is
that
the
graph
is
w
ell
split,
so
w
e
ha
v
e:
hxihy

ihzi
=
0
Let
us
recall
that
haihbi
=
0
if
and
only
if
a
b
=
b,
and
note
that
hy

ihzi
=
hhy

ihzii
since
it
is
an
idemp
oten
t.
So,
w
e
ha
v
e:
hxihy

ihzi
=
0
if
and
only
if
xhy

ihzi
=
hy

ixhzi
=
hy

ihzi
and
nally
yxz
=
yhy

ixhziz
=
yhy

ihziz
=
yz
The
pro
of
is
similar
if
w
e
consider
the
path
from
d
to
a
(the
path
from
a
to
c
is
ob
viously
preserv
ed
b
y
reduction).
The
reader
in
terested
in
learning
more
on
virtual
reduction
and
its
prop
erties
(most
remark
ably
,
c
onuenc
e)
is
referred
to
[DR	
].
.
Relating
P
aths
In
this
section
w
e
will
ev
en
tually
sho
w
that
all
the
previous
notions
of
paths
coincide.
F
or
the
sak
e
of
clarit
y
,
let
us
remind
and
x
some
notation.

.
R
elating
Paths
0
W
e
shall
start
adding
some
notation
to
the
lab
eled
graphs,
let
us
call
them
dynamic
gr
aphs,
already
met
in
studying
regular
paths.
As
already
notices,
although
suc
h
graphs
are
unorien
ted,
their
edges
ha
v
e
a
natural
orien
tation
corresp
onding
to
the
arro
ws
in
the
gures
b
elo
w
(see
also
Figure
.).
Eac
h
no
de
m
has
a
depth
(an
index
in
sharing
graphs
terminology)
whic
h
is
a
p
ositiv
e
in
teger
marking
m.
Similarly
,
an
edge
is
at
depth
i
if
its
nal
no
de
(w.r.t.
the
natural
orien
tation)
is
at
depth
i
and
the
depth
of
a
path
is
the
smallest
depth
of
the
no
des
it
tra
v
erses.
Among
the
edges
inciden
t
to
a
no
de
w
e
alw
a
ys
distinguish
a
set
of
pr
emises,
that
is,
a
set
of
en
tering
edges
xed
b
y
the
t
yp
e
of
the
no
de.
Eac
h
edge
of
a
dynamic
graph
is
the
premise
of
at
most
one
no
de
(i.e.,
the
natural
orien
tation
is
not
con
tradictory)
and
it
is
lab
eled
b
y
a
weight
that
is
an
elemen
t
of
the
dynamic
algebra
LS
.
The
w
eigh
t
of
an
edge
cor-
resp
onds
to
its
natural
orien
tation;
th
us,
an
imp
ortan
t
prop
ert
y
that
will
b
e
used
in
asso
ciating
w
eigh
ts
to
paths,
is
that
rev
ersing
the
direction
of
an
edge
corresp
ond
to
the
star
op
eration
on
w
eigh
ts.
(Let
us
remark
that
this
in
terpretation
is
sound
b
ecause
of
the
previous
assumption
on
premises.)
In
addition
to
the
usual
no
des
w
e
ha
v
e
t
w
o
c
ommunic
ation
no
des
(needed
in
order
to
b
e
consisten
t
with
the
requiremen
ts
ab
o
v
e):
c
ontext
(c)
and
variable
(v).
Hence,
summing
up,
the
no
des
of
a
dynamic
graph
can
b
e
of
three
dieren
t
kinds:
(i)
Communic
ation
no
des:
c
ontext
(c)
and
variable
(v),
with
no
premises.
(ii)
L
o
gic
al
no
des:
lamb
da
and
applic
ation
no
des
with
t
w
o
asso
ciated
premises.
(iii)
Contr
ol
no
des:
cr
oissant
and
br
acket,
with
one
premise;
fan
with
t
w
o
premises;
we
akening
with
no
premise.
F
or
eac
h
in
teger
n
and
eac
h
term
M
w
e
dene
b
y
induction
on
M
a
graph
G
n
(M)
together
with
its
ro
ot
no
de
(represen
ted
on
the
gure
as
the
topmost
no
de).
The
translation
is
dened
so
that
eac
h
free
v
ariable
of
M
is
asso
ciated
with
a
unique
con
trol
no
de
in
G
(M)
(at
the
b
ottom
of
the
graph)
with
no
exiting
edge;
these
con
trol
no
des
are
the
fr
e
e
no
des
of
G
(M).
The
translation
of
a
lam
b
da-term
M
is
dened
to
b
e
G
(M)
=
G
0
(M).

0
Paths
V
ariable
x.
G
n
(x)
=
!
n
(d)
n
n
v
Application
(MN).
G
n
(MN)
=
!
n
(t)
!
n
(q)
!
n
(p)
!
n
(t)
!
n
(r)
!
n
(s)

n
n
n
n
n
@
G
n
(M)
G
n+
(N)
c
The
fan
at
the
b
ottom
of
the
graph
merges
t
w
o
free
no
des
cor-
resp
onding
to
the
same
v
ariable;
at
the
same
time,
eac
h
pair
of
corresp
onding
v
ariables
o
ccurring
free
in
M
and
N
is
link
ed
b
y
means
of
a
fan.
The
premises
of
the
application
are
resp
ectiv
ely
called
the
con-
text
and
the
argumen
t
edges
of
the
application;
the
argumen
t
no
de
of
the
application
is
the
initial
no
de
of
the
argumen
t
edge.
The
exiting
edge
is
called
the
function
edge
and
its
nal
no
de
is
the
function
no
de
of
the
application.
Abstraction
x:M.
There
are
t
w
o
cases
whether
the
v
ariable
do
es
or
do
es
not
app
ear
in
M.
In
the
former
one
w
e
link
the
corre-
sp
onding
no
de
to
the
lam
b
da
no
de;
in
the
latter
one
w
e
link
a

.
R
elating
Paths
0
w
eak
ening
no
de
to
the
lam
b
da
no
de:
G
n
(xM)
=

!
n
(q)
!
n
(p)
n
n

!
n
(q)
!
n
(p)
G
n
(M)
G
n
(M)
The
premises
of
the
lam
b
da
are
resp
ectiv
ely
called
the
v
ariable
and
the
b
o
dy
edges;
the
initial
no
de
of
the
b
o
dy
edge
is
the
b
o
dy
no
de
of
the
abstraction.
If
n
is
a
con
text,
v
ariable
or
lam
b
da
no
de
at
depth
n
in
G
n
(M),
then
the
set
of
no
des
b
elo
w
n
at
depth
greater
than
n
m
ust
b
e
of
the
form
G
n
(N),
for
some
subterm
N
of
M.
The
no
de
n
is
the
ro
ot
of
N
in
M;
furthermore,
if
N
diers
from
M,
the
edge
on
top
of
n
is
the
ro
ot
edge
of
N
in
M
or
also
the
ro
ot
of
n.
A
path
is
a
sequence
of
consecutiv
e
no
des,
or
equiv
alen
tly
,
a
sequence
of
orien
ted
edges
and
rev
ersed
orien
ted
edges
w.r.t.
the
natural
orien
ta-
tion.
W
e
shall
use
b
oth
con
v
en
tions
and
ev
en
mix
them
without
men
tion.
The
rev
erse
of
a
path
'
is
denoted
'
r
.
A
path
is
str
aight
if
it
con
tains
no
subpath
of
the
form
''
r
nor
uv
r
where
u
and
v
are
the
t
w
o
premises
of
some
binary
no
de.
F
rom
no
w
on
w
e
assume
that
all
the
paths
are
straigh
t.
Note
also
that
all
w
ell
balanced
paths
are
straigh
t
b
y
denition.
The
w
eigh
t
of
a
path
is
a
dynamic
graph
is
the
an
timorphical
comp
o-
sition
of
the
w
eigh
ts
of
its
edges.
Namely
,
the
w
eigh
t
of
a
path
w()
is
giv
en
b
y
the
follo
wing
rule
for
(an
timorphical)
comp
osition:
(i)
If
'
=
u
(i.e.,
an
edge
crossed
according
to
its
natural
orien
ta-
tion),
then
w()
=
w(u)
is
equal
to
the
w
eigh
t
of
u.
(ii)
If
'
=
  
0
,
then
w()
=
w( 
0
)w( ).
(iii)
If
'
=
 
r
,
then
w()
=
w( )

.
W
e
will
sa
y
that
a
path
is
of
t
yp
e
t

-t

if
it
starts
from
a
no
de
of
t
yp
e
t

and
ends
in
a
no
de
of
t
yp
e
t

.
In
particular
an
edge
of
t
yp
e
@-
will
b
e
called
a
redex
edge.
There
is
a
one
to
one
corresp
ondence
b
et
w
een
redexes
in
M
and
redex
edges
in
G
(M).
W
e
sa
y
that
a
path
'
crosses
a
redex
if
it
con
tains
the
corresp
onding
redex
edge.
Beta
reduction
induces
a
notion
of
r
esidual
e
dge,
dened
in
the
stan-
dard
w
a
y
(w
e
already
met
it
sev
eral
times).
This
notion
can
b
e
easily
extended
to
paths
in
an
edge-wise
manner.
Moreo
v
er,
let
us
remark
again
that
paths
ma
y
ha
v
e
no
more
than
one
residual.

0
Paths
..
Discriminants
T
o
eac
h
v
ariable
no
de
(o
ccurrence
of
v
ariable)
v
w
e
asso
ciate
a
discrim-
inant

v
.
Namely
,
the
maxim
al
path
starting
at
v
and
mo
ving
do
wn-
w
ards.
Let
us
note
that
an
y
discriminan
t
is
uniquely
determined
b
y
v
and
that
it
con
tains
con
trol
no
des
only
.
The
last
no
de
of

v
is
the
discriminant
no
de
of

v
.
The
discriminan
t
no
de
of
a
discriminan
t

v
is
ob
viously
connected
to
a
-no
de

binding
v.
Th
us,
w
e
will
also
sa
y
that

v
is
b
ound
b
y
this
.
Let

b
e
a
discriminan
t.
The
depth
of
its
v
ariable
no
de
is
the
maxim
al
one
in
,
while
the
depth
of
its
discriminan
t
no
de
m
is
the
minim
al
one;
in
particular,
when

is
b
ound
b
y
some
,
the
depth
of
m
is
equal
to
the
depth
of
.
The
dierence
b
et
w
een
these
maxim
al
and
minim
al
depths
is
the
lift
of
.
Let

b
e
a
discriminan
t
of
lift
c
in
G
(M)
suc
h
that
k
is
the
depth
of
its
discriminan
t
no
de.
The
w
eigh
t
of

is
equal
to
!
k
(G)
for
some
G
of
the
form:
G
=
!

t!(!

t!(:
:
:
!
k
t!(!
c+
d)))
where
all
the
!
i
are
pro
ducts
of
r's
and
s's
only
.
More
in
general,
an
y
elemen
t
of
LS
as
the
G
ab
o
v
e
will
b
e
called
a
w-discriminant
of
lift
c.
An
y
w-discriminan
t
G
of
lift
c
satises
the
follo
wing
gener
alize
d
swap
e
quation:
!(P
)G
=
G!
c
(P
)
for
an
y
monomi
al
P
in
LS
.
Let

and

0
b
e
t
w
o
discriminan
ts
b
ound
b
y
the
same
lam
b
da
no
de
.
If
!
k
(G)
and
!
k
(G
0
)
are
the
w
eigh
ts
of

and

0
,
then
the
t
w
o
w-
discriminan
ts
G
and
G
0
satises
the
follo
wing
gener
alize
d
zap
e
quation:
G

G
0
=


0
where


0
is
the
Kro
enec
k
er
function
(i.e.,


0
=

when

=

0
,
and


0
=
0
otherwise).
..
L
e
gal
p
aths
ar
e
r
e
gular
and
vic
e-versa
W
e
shall
pro
v
e
in
this
section
the
coincidence
of
legal
paths
and
(w
ell-
balanced)
regular
paths.
F
or
the
regularit
y
of
legal
paths
w
e
need
a
couple
of
lemmas.
The
rst
one
is
a
restatemen
t
of
Prop
osition
..
and
w
e
recall
it
here
only
for
the
sak
e
of
clarit
y
.

.
R
elating
Paths
0	
Lemma
..
L
et
M
b
e
a
term,
'
a
le
gal
p
ath
in
G
(M),

the
leftmost
outermost
r
e
dex
cr
osse
d
by
'
and
M
0
the
term
obtaine
d
by
ring
.
Then
'
has
a
unique
r
esidual
'
0
in
M
0
and
'
0
is
in
turn
le
gal.
The
second
one
is
called
lifting
lemma.
Lemma
..
(Liftin
g
Lemma)
L
et
'
b
e
a
str
aight
p
ath
in
G
(M),
P
b
e
its
weight,
and

b
e
the
leftmost-outermost
r
e
dex
cr
osse
d
by
'.
Supp
ose
'
has
a
r
esidual
'
0
by
the
r
e
duction
of

and
let
P
0
b
e
the
weight
of
'
0
.
Then:
P
=
AP
0
B

for
some
p
ositive
A
and
B
in
LS
.
Pr
o
of
[Sk
etc
h
of
the
pro
of.]
Let
@
and

b
e
the
application
and
the
lam
b
da
no
des
dening
the
redex
,
and
u
b
e
the
function
edge
of
@.
W
e
use
some
k
ey
prop
erties
of
'
w.r.t.
its
leftmost
outermost
redex.
Namely
,
under
the
h
yp
otheses
of
the
lemma,
w
e
use
the
fact
that
the
path
'
ma
y
b
e
decomp
osed
as
'
=
('
0

0
v
u
v
0

)
 
0
v
0
u
v


0

'




'
n

n
v
u
v
0

 
n
(v
0
u
v


n

'
n+
)
where:
(i
)
v
and
v
0
are
resp
ectiv
ely
the
v
ariable
edge
of

and
the
argumen
t
edge
of
@;
(ii
)
an
y

i
is
the
discriminan
t
of
an
o
ccurrence
of
the
v
ariable
b
ound
b
y
;
(iii
)
an
y
'
i
is
a
subpath
of
'
lying
completely
outside
the
argumen
t
of
@;
(iv
)
an
y
 
i
is
a
subpath
of
'
lying
completely
inside
the
argumen
t
of
@;
(v
)
the
paren
thesized
subpaths
ma
y
p
ossibly
b
e
empt
y
.
F
rom
the
decomp
osition
ab
o
v
e,
a
straigh
tforw
ard
computation
of
the
w
eigh
t
giv
es
the
result.
Remark
..
The
theorem
AB

is
an
ob
vious
consequence
of
this
lemma.
One
has
just
to
pro
v
e
that
if
'
has
no
residual
then
its
w
eigh
t
is
n
ull.
Theorem
..
Every
le
gal
p
ath
'
is
r
e
gular.
Pr
o
of
W
e
pro
v
e
b
y
induction
on
the
length
of
'
that
its
w
eigh
t
is
in
the
AB

form.
If
'
is
the
function
edge
of
an
application
no
de,
then
its
w
eigh
t
is
;
so,
it
is
in
AB

form.
Otherwise
b
y
denition
of
wbp,
'
m
ust
cross
some
redex.
Let

b
e
the
leftmost
outermost
redex
of
'.
If
'
0
is
the
residual
of
'
b
y
the
con
traction
of

(b
y
lemma
..,
'
0
exists

0
Paths
and
is
unique),
then
b
y
induction
h
yp
othesis,
the
w
eigh
t
of
'
0
is
AB

for
some
p
ositiv
e
elemen
ts
A
and
B
of
LS
.
But
b
y
lifting
lemma,
there
are
some
p
ositiv
e
C
and
D
suc
h
that
w(')
=
Cw('
0
)D

=
CAB

D

.
Unfortunately
,
the
con
v
erse
of
the
previous
theorem
is
not
as
easy
.
Again,
w
e
need
a
few
preliminary
results.
Prop
osition
..
(Rendez-v
ous
prop
ert
y)
L
et
P
b
e
the
weight
of
a
wbp
'
linking
two
no
des
m
and
n
and
let
m
and
n
b
e
the
r
esp
e
ctive
depth
of
m
and
n.
Then
for
any
element
X
of
LS
we
have:
!
n
(X)P
=
P
!
m
(X)
Pr
o
of
When
P
=
0
the
prop
osition
is
ob
vious.
So,
let
us
assume
that
P
is
not
n
ull.
The
pro
of
is
b
y
induction
on
the
structure
of
'.
'
is
an
e
dge
:
'
is
the
function
edge
of
some
application
no
de;
so,
P
=

and
n
=
m.
'
=
'

u'

u
0
r
:
By
h
yp
othesis,
b
oth
'

and
'

are
wbp's.
Let
P

and
P

b
e
their
resp
ectiv
e
w
eigh
ts.
Let
us
note
that
the
ending
no
de
of
'

and
the
initial
no
de
of
'

are
at
the
same
depth,
sa
y
k;
moreo
v
er,
the
nal
no
de
of
'

has
the
same
depth
n
of
the
no
de
n,
for
u
and
u
0
are
resp
ectiv
ely
con
text
and
b
o
dy
edges.
Then,
P
=
!
n
(q

)P

!
k
(q)P

=
P

P

,
b
y
induction
h
yp
othesis
and
the
annihilation
equations
of
q.
No
w,
using
the
induction
h
yp
othesis
on
'

and
'

,
w
e
conclude
b
y:
!
n
(X)P
=
!
n
(X)P

P

=
P

!
k
(X)P

=
P

P

!
m
(X)
=
P
!
m
(X):
'
=
'

u('

)
r
u
0
r
:
The
computation
is
essen
tially
similar
to
the
one
in
the
previous
case.
The
only
dierence
is
that
w
e
ha
v
e
to
use
the
sw
apping
equation
of
the
discriminan
t
crossed
b
y
'.
Lemma
..
(@-cycle
prop
ert
y)
L
et
@
b
e
an
applic
ation
no
de
in
G
(M)
at
depth
k,
u
b
e
its
applic
ation
e
dge
and
u
r
 u
b
e
an
@-cycle
starting
at
@.
Ther
e
ar
e
two
monomials
U
and

such
that:
w( )
=
!
k+
(U)
wher
e

is
a
k-swapping
idemp
otent,
i.e.,

satises
the
two
e
quations:

=

!
k
(X)
=
!
k
(X)

.
R
elating
Paths

for
any
monomial
X.
Pr
o
of
If
the
w
eigh
t
of
 
is
n
ull,
then
the
prop
osition
is
true
for
U
=

=
0.
So,
let
us
supp
ose
that
w( )
=
0.
Let
N
b
e
the
argumen
t
of
the
application
@.
By
denition
of
@-cycle,
 
has
the
follo
wing
form:
 
0
v



v



'
r
@

u
r



u

@

'

v
r


r

v

 

:
:
:
 
n
where,
for
eac
h
i,
 
i
is
in
ternal
to
N,

i
is
a
discriminan
t
for
some
free
v
ariable
v
i
of
N,

i
is
its
binder
(external
to
N),
'
i
is
a
virtual
redex
b
et
w
een
@
i
e

i
,
u
i
is
the
argumen
t
edge
of
@
i
,
and
u
r
i

i
u
i
is
an
@-
cycle.
W
e
pro
v
e
b
y
induction
on
n,
and
then
on
 ,
that
an
y
path
of
this
form
has
the
@-cycle
prop
ert
y
(note
that
suc
h
a
path
migh
t
not
b
e
a
cycle).
Let
n
=
0.
In
this
case,
 
=
 
0
is
en
tirely
con
tained
in
N.
Then,
its
w
eigh
t
has
the
form
w( )
=
!
k+
(X),
for
some
X,
and
the
prop
osition
is
satised
b
y
taking

=
.
If
n
>
0,
let
l

b
e
the
depth
of


.
The
w
eigh
t
of


is
of
the
form
!
l

(G

)
for
some
w-discriminan
t
G

of
lift
c

.
F
urthermore,
let
k

b
e
the
depth
of
@

.
Since
u
r



u

is
a
@-cycle,
b
y
induction
h
yp
othesis
(on
the
length
of
the
cycle


)
its
w
eigh
t
is
of
the
form
w(

)
=
!
k

+
(V

)

for
some
monomia
l
V

and
some
k

-sw
apping
idemp
oten
t


.
Moreo
v
er,
the
sux
 

:
:
:
 
n
,
although
it
is
not
a
@-cycle,
still
has
the
righ
t
shap
e.
Th
us,
b
y
induction
h
yp
othesis
(on
the
n
um
b
er
of
comp
onen
ts
n
in
the
decomp
osition
at
the
b
eginning
of
the
pro
of
)
its
w
eigh
t
m
ust
b
e
w( 

:
:
:
 
n
)
=
!
k+
(V
)
for
some
monomi
al
V
and
some
k-sw
apping
idemp
oten
t
.
Summing
up,
if
w( 

)
=
U

,
the
w
eigh
t
of
 
is:
w( )
=
!
k+
(V
)!
l

(G


)!
l

(p

)U

!
k

(p)!
k

+
(V

)

!
k

(p

)U


!
l

(p)!
l

(G

)!
k+
(W
0
)
Since
'

is
a
wbp
linking
t
w
o
no
des
whose
resp
ectiv
e
depths
are
k

and
l

,
b
y
the
rendez-v
ous
prop
ert
y
,
w
e
ha
v
e:
!
l

(X)U

=
U

!
k

(X)
for
an
y
monomi
al
X.
In
particular:
!
l

(p

)U

!
k

(p)
=
!
l

(p

)!
l

(p)U

=
U



Paths
The
w
eigh
t
of
 
can
then
b
e
simplied
to:
w( )
=
!
k+
(V
)!
l

(G


)U

!
k

+
(V

)

U


!
l

(G

)!
k+
(W
0
)
Let
X
=
!
l

(G


)U

!
k

+
(V

)

U


!
l

(G

).
W
e
ha
v
e
that:
X
=
!
l

(G


)U

!
k

+
(V

)

U


!
l

(G

)
=
U

!
k

(G


)!
k

+
(V

)

U


!
l

(G

)
rendez-v
ous
for
U

=
U

!
k

(G


!(V

))

U


!
l

(G

)
=
U

!
k

(!
c

(V

)G


)

U


!
l

(G

)
sw
ap-equation
for
G


=
U

!
k

+c

(V

)!
k

(G


)

U


!
l

(G

)
=
U

!
k

+c

(V

)

!
k

(G


)U


!
l

(G

)
sw
ap-equation
for


=
U

!
k

+c

(V

)

U


!
l

(G


)!
l

(G

)
rendez-v
ous
for
U

=
U

!
k

+c

(V

)

U


=
!
l

+c

(V

)U



U


Th
us,
w
e
get:
w( )
=
!
k+
(V
)!
l

+c

(V

)U



U


!
k+
(W
0
)
Since
l

is
the
depth
of


,
it
is
also
the
depth
of
the
discriminan
t
no
de
of


.
Th
us
l


k.
That
is,
there
exists
a
d


0
suc
h
that
k
=
l

+
d

.
No
w,
let
Y
b
e
an
y
monomia
l.
U



U


!
k
(Y
)
=
U



U


!
l

+d

(Y
)
=
U



!
k

+d

(Y
)U


rendez-v
ous
prop
ert
y
for
U


=
U

!
k

+d

(Y
)

U


sw
apping
prop
ert
y
for


=
!
l

+d

(Y
)U



U


rendez-v
ous
prop
ert
y
for
U

=
!
k
(Y
)U



U


So,
U



U


is
k-sw
apping.
Using
the
p
erm
utation
prop
ert
y
for
idem-
p
oten
ts,
it
is
also
easy
to
pro
v
e
that
U



U


is
idemp
oten
t.
Let

0

=
U



U


.
W
e
see
that

0

is
k-sw
apping
idemp
oten
t:
w( )
=
!
k+
(V
)!
l

+c

(V

)!
k+
(W
0
)
0

But
c

is
the
lift
of
the
discriminan
t


whic
h
starts
at
a
depth
strictly
greater
than
k
and
ends
at
depth
l

.
So,
there
exists
d
0


0
suc
h
that
l

+
c

=
k
+

+
d
0

.
Th
us,
w
e
nally
get:
w( )
=
!
k+
(V
)!
l

+c

(V

)!
k+
(W
0
)
0

=
!
k+
(V
)!
k++d
0

(V

)!
k+
(W
0
)
0

=
!
k+
(V
)!
k+
(!
d
0

(V

)W
0
)
0

=
!
k+
(V
)!
k+
(!
d
0

(V

)W
0
)
0

sw
apping
prop
ert
y
for

=
!
k+
(V
!
d
0

(V

)W
0
)
0


.
R
elating
Paths

Since

and

0

are
b
oth
k-sw
apping
idemp
oten
ts,
their
pro
duct
also
is.
Theorem
..
Every
r
e
gular
wbp
is
le
gal.
Pr
o
of
Let
'
b
e
a
regular
wbp.
W
e
m
ust
pro
v
e
that
ev
ery
@-cycle
in
'
satises
the
legalit
y
condition.
In
other
w
ords,
let
us
consider
an
y
subpath
of
'
of
the
kind

=
v



u

'
r

@u
r
 u@'



u
r


r

v

where
u
r
 u
is
a
@-cycle:
w
e
m
ust
pro
v
e
that
the
call
and
return
paths
are
equal,
that
is
 

=
v



u

'
r

@
?
=
v



u

'
r

@
=
 

Let
k
and
k
i
b
e
the
resp
ectiv
e
depths
of
@
and

i
,
for
i
=
;
.
The
w
eigh
ts
of
'
i
and

i
are
resp
ectiv
ely
of
the
form
U
i
and
!
k
i
(G
i
)
where
G
i
is
a
w-discriminan
t
of
lift
c
i
.
Then,
the
w
eigh
t
of

is
w()
=
!
k

(G


)!
k

(p

)U

!
k
(p)w( )!
k
(p

)U


!
k

(p)!
k

(G

)
By
the
rendez-v
ous
prop
ert
y
of
'

and
'

,
this
w
eigh
t
can
b
e
reduced
to:
w()
=
!
k

(G


)U

w( )U


!
k

(G

)
The
@-cycle
prop
ert
y
tells
us
that
w( )
=
!
k+
(U)
for
some
monomi
al
U
and
k-sw
apping
idemp
oten
t
.
Therefore:
w()
=
!
k

(G


)U

!
k+
(U)U


!
k

(G

)
=
!
k

(G


)!
k

+
(U)U

U


!
k

(G

)
rendez-v
ous
for
U

=
!
k

(G


!(U))U

U


!
k

(G

)
=
!
k

(!
c

(U)G


)U

U


!
k

(G

)
sw
ap
equation
for
G


=
!
k

+c

(U)!
k

(G


)U

U


!
k

(G

)
Let
W
i
=
!
k
(p

)U

i
!
k
i
(p)!
k
i
(G
i
)
=
U

i
!
k
i
(G
i
)
b
e
the
w
eigh
t
of
 
i
.
Then,
the
w
eigh
t
of

can
b
e
equiv
alen
tly
expressed
as
w()
=
!
k

+c

(U)W


W

Ev
en
if
so
not
already
kno
w
whether
 

and
 

are
equal
or
not,
they
are
t
w
o
straigh
t
paths
ending
at
the
same
application
no
de.
So,
either
 
i
=

i
n
i

where
n

and
n

are
distinct
premises
of
a
binary
no
de,
or
w.l.o.g.
 

is
a
sux
of
 

.


Paths
In
the
rst
case,
let
x
i
b
e
the
w
eigh
t
of
n
i
,
V
i
and
V
b
e
the
resp
ectiv
e
w
eigh
ts
of

i
and
,
so
that
W
i
=
Vx
i
V
i
,
and
w()
=
!
k

+c

(U)V


x


V

Vx

V

Since
n

and
n

are
distinct
premises
of
a
binary
no
de,
w
e
ha
v
e
x


x

=
0.
Moreo
v
er,
V

V
is
an
idemp
oten
t.
So,
it
is
in
terpreted
as
a
partial
iden
tit
y
in
the
mo
del
of
partial
one-to-one
transformations
of
N.
By
the
seman
tical
AB

theorem
w
e
conclude
that
x


V

Vx

=
0
and
therefore
w()
=
0,
con
tradicting
the
h
yp
othesis
of
regularit
y
.
Hence,
w
e
ha
v
e
that
 

is
a
sux
of
 

.
This
en
tails
that
'

is
a
prex
of
'

.
But
since
they
are
are
b
oth
wbp's
of
t
yp
e
@-,
they
are
forcedly
equal.
Th
us,
 
i
=
v
i

i


'
r

@.
Joined
to
the
fact
that
 

is
a
sux
of
 

,
w
e
conclude
that
 

=
 

.
..
Consistent
p
aths
ar
e
r
e
gular
and
vic
e-versa
Let
us
rephrase
the
notion
of
consisten
t
path
in
G
(M).
According
to
the
denition
of
con
texts
giv
en
in
section
.,
an
(innite)
con
text
can
b
e
also
seen
as
a
function
from
natural
n
um
b
ers
to
lev
els,
where
a
lev
el
is
an
y
w
ord
of
the
language
generated
b
y
the
follo
wing
gramma
r:
a
::=

j


a
j
?

a
j
#

a
j
$

a
j
ha;
bi
Let
C

b
e
the
class
of
innite
con
texts.
W
e
w
an
t
to
in
terpret
the
ele-
men
ts
of
the
algebra
LS
as
partial
transformations
on
con
texts.
Namely
,
w
e
w
an
t
to
sho
w
that
there
exists
a
set
H
of
partial
injectiv
e
endomor-
phisms
of
C

that
is
a
non
trivial
mo
del
of
LS
.
The
in
terpretation
of
pro
duct
and

of
LS
in
H
will
b
e
the
natural
ones.
Namely
,
the
pro
duct
of
LS
will
b
e
function
comp
osition;
while
for
the

op
eration,
let
us
note
that,
since
all
the
functions
in
H
are
injectiv
e,
they
are
left-in
v
ertible,
i.e.,
for
an
y
h

H
there
is
h

suc
h
that
h

h
is
the
iden
tit
y
on
the
domain
of
h.
Therefore,
w
e
left
to
nd
ho
w
to
in
terpret
the
constan
ts
of
LS
.
As
usual,
let
us
denote
b
y
A
n
[C]
a
con
text
of
the
form
h:
:
:
hC;
a
n
i;
:
:
:
a

i.
The
b
asic
tr
ansformations
of
lev
el
n
are
injectiv
e
partial
transforma-
tions
on
con
texts
dened
(for
eac
h
n)
in
the
follo
wing
w
a
y:
d
n
(A
n
[hC;
ai])
=
A
n
[hhC;
ai;
i]
t
n
(A
n
[hhC;
ai;
bi])
=
A
n
[hC;
ha;
bii]
r
n
(A
n
[hC;
ai])
=
A
n
[hC;
?

ai]
s
n
(A
n
[hC;
ai])
=
A
n
[hC;


ai]

.
R
elating
Paths

p
n
(A
n
[hC;
ai])
=
A
n
[hC;
#

ai]
q
n
(A
n
[hC;
ai])
=
A
n
[hC;
$

ai]
The
family
of
p
artial
inje
ctive
c
ontext
tr
ansformations
H
is
then
the
smallest
set
of
partial
injectiv
e
functions
con
taining
the
previous
basic
transformations
and
closed
under
comp
osition
and
.
Remark
..
According
to
the
previous
denition,
H
m
ust
con
tain
the
no
where
dened
transformation
0
and
the
iden
tit
y
transformation
.
In
fact,
all
the
basic
transformations
are
total
and
for
an
y
pairs
of
basic
transformations
h

and
h

of
the
same
lev
el
n
the
co
domains
of
h

and
h

are
disjoin
t.
Hence,
h


h

=

and
h


h

=
0.
W
e
can
no
w
directly
asso
ciate
an
elemen
t
of
H
to
paths
of
dynamic
graphs.
T
o
eac
h
orien
ted
edge
u
(w.r.t.
the
natural
orien
tation)
of
a
graph
G
(M)
w
e
asso
ciate
a
basic
con
text
transformation
h
u
in
the
follo
wing
w
a
y:

If
u
is
not
the
premise
of
a
no
de,
then
h
u
is
the
iden
tit
y
.

If
u
is
the
premise
of
a
no
de
n
of
depth
n,
then
h
u
is
d
n
;
t
n
;
r
n
;
s
n
;
p
n
or
q
n
when,
resp
ectiv
ely
,
n
is
a
croissan
t,
n
is
a
square
brac
k
et,
n
is
a
fan
and
u
is
its
left
premise,
n
is
a
fan
and
u
is
its
righ
t
premise,
n
is
an
application
or
a
lam
b
da
no
de
and
u
is
its
argumen
t
or
v
ariable
edge,
n
is
an
application
or
a
lam
b
da
no
de
and
u
is
its
con
text
or
b
o
dy
edge.
W
e
dene
then
h
u
r
=
h

u
and
h
 
=
h
u
n
:
:
:
h
u

,
for
an
y
path
 
=
u

:
:
:
u
n
in
G
(M),
where
eac
h
u
i
can
b
e
either
a
direct
or
rev
erse
ori-
en
ted
edge.
Denition
..	
(Consisten
t
P
aths)
A
consisten
t
path
is
a
path
 
suc
h
that
h
 
is
dened
on
some
con
text,
i.e.,
h
 
=
0.
Prop
osition
..0
The
family
H
is
a
non
trivial
mo
del
of
LS
.
Pr
o
of
Let
us
dene
the
(straigh
tforw
ard)
in
terpretation
of
the
monomi-
als
of
LS
.
The
constan
ts
0,
,
d,
t,
r,
s,
p
and
q
of
LS
are
in
terpreted
resp
ectiv
ely
b
y
0,
,
d
0
,
t
0
,
r
0
,
s
0
,
p
0
and
q
0
;
the
in
v
olution

is
the
in
v
ersion
of
partial
transformation;
the
morphism
!
(in
LS
)
is
the
mor-
phism
of
H
dened
b
y:
!(h)hC;
ai
=
hh(C);
ai


Paths
for
an
y
h

H.
In
particular,
let
us
note
that,
if
b
n
is
a
basic
trans-
formation
of
lev
el
n,
the
previous
denition
implies
that
!(b
n
)
=
b
n+
and,
b
y
iteration,
that:
b
n
=
!
n
(b
0
):
In
the
follo
wing,
when
not
am
biguous,
w
e
shall
drop
the
sup
erscript
0
from
the
in
terpretations
of
the
constan
ts.
The
facts
that
!
of
H
is
a
morphism
and
that
the
in
v
ersion
is
an
an
ti-
morphism
for
comp
osition
are
imm
ediate.
In
particular,
let
us
note
that
if
h
is
a
transformation
with
full
domain,
then
!(h)
has
a
full
domain
as
w
ell.
Hence,
to
complete
the
pro
of
w
e
left
to
c
hec
k
the
axioms
for
the
constan
ts.
Let
C
=
hC
0
;
ai
b
e
an
y
con
text.
Then,
p

p(C)
=
p

hC
0
;
]

ai
=
hC
0
;
ai
=
C.
F
urthermore,
p

q(C)
=
p

hC
0
;
\

ai.
But
hC
0
;
\

ai
is
not
in
the
co
domain
of
p
and
th
us
it
is
not
in
the
domain
of
p

.
Therefore,
p

q
is
no
where
dened,
i.e.,
p

q
=
0.
Let
C
=
hhC

;
bi;
ai
b
e
an
y
con
text.
F
or
an
y
h

H,
w
e
ha
v
e
that
 !(h)t

(C)
=
!(h)hC

;
ha;
bii
=
hh(C

);
ha;
bii
and
that
 t!

(h)

(C)
=
thhh(C

);
bi;
ai
=
hh(C

);
ha;
bii.
So,
!(h)t
=
t!

(h).
The
computations
for
the
other
axioms
are
similar
and
w
e
left
them
as
an
exercise.
Theorem
..
A
p
ath
'
in
G
(M)
is
c
onsistent
i
it
is
r
e
gular.
Pr
o
of
The
in
terpretation
of
w( )
in
H
is
clearly
h
 
.
By
denition,
 
is
consisten
t
if
and
only
if
h
 
=
0.
Then
the
only
if
part
of
the
theorem
follo
ws
from
the
fact
that
H
is
a
mo
del
of
LS
.
The
if
part
is
a
consequence
of
Corollary
..,
that
is,
a
consequence
of
the
the
seman
tical
AB

theorem.
Remark
..
The
mo
del
H
is
not
initial
in
the
category
of
dynamic
algebras.
F
or
instance
d

t
is
not
pro
v
ably
equal
to
0
in
LS
.
But
it
is
equal
to
0
in
H,
since
the
transformation
d

t
is
no
where
dened.
.
Virtual
in
teractions
In
Section
.
w
e
pro
v
ed
that
L

evy's
families
of
redexes
for
a
-term
M
can
b
e
describ
ed
as
suitable
p
aths
(virtual
redexes)
in
(the
syn
tax
tree
of
)
M.
As
a
consequence,
since
Lamping's
graph
reduction
tec
hnique

.
Virtual
inter
actions

is
optimal,
w
e
ha
v
e
a
bijectiv
e
corresp
ondence
b
et
w
een
Lamping's
-
in
teractions
and
virtual
redexes.
A
similar
result
can
b
e
obtained
for
the
other
crucial
annihilation
op
eration
of
sharing
graphs:
the
in
terac-
tion
b
et
w
een
fans
of
a
same
lev
el
(and,
more
generally
,
for
all
kinds
of
annihilations
rules).
In
particular,
w
e
shall
pro
v
e
that
fan-annihilations
are
in
one-to-one
corresp
ondence
with
paths
starting
and
terminating
at
the
same
fan
in
M
and
tra
v
ersing,
in
order,
a
virtual
redex
 ,
an
@-cycle
and
 
r
(i.e.,
the
path
 
but
in
the
rev
erse
direction).
Let
us
consider
for
instance
the
\abstract"
reduction
of
the
term
(
)
depicted
in
Figure
..
In
this
reduction,
w
e
ha
v
e
applied
t
w
o
fan-
annihilation
rules.
F
ollo
wing
the
analogy
with
-reduction
and
virtual
redexes,
our
problem
is
to
describ
e
these
in
teractions
as
suitable
paths
in
the
initial
term
of
the
reduction.
The
general
idea
is
v
ery
simple:
consider
the
annihilation
rule
and,
going
bac
kw
ard
along
the
reduction,
follo
w
the
paths
tra
v
ersed
b
y
the
t
w
o
in
teracting
fans.
Applying
this
in
tuition
to
our
example,
w
e
disco
v
er
that
the
t
w
o
annihilation
rules
in
Figure
.()
corresp
ond
to
the
paths
in
the
initial
term
illustrated
in
Figure
..
These
paths
ha
v
e
a
v
ery
precise
and
similar
structure:
they
b
oth
start
and
terminate
at
the
same
fan,
and
can
b
e
uniquely
decomp
osed
as
a
virtual
redex
 ,
follo
w
ed
b
y
an
@-cycle
(see
Denition
..
in
Section
.)
and
b
y
 -rev
erted.
This
decomp
osition
is
general,
as
w
e
shall
see.
In
this
w
a
y
,
w
e
can
recast
(and
explain)
all
dynamical
asp
ects
of
Lamping's
algorithm
in
terms
of
statics.
..
R
esiduals
and
anc
estors
of
c
onsistent
p
aths
The
rst
step
is
to
formalize
the
notion
of
residual
(and
ancestor)
of
a
consisten
t
path
in
a
sharing
graph.
Let
[M]
!

G
u
!
G
0
and

b
e
a
path
in
G
whic
h
starts
and
terminates
at
t
w
o
principal
p
orts
y
.
The
notion
of
residual
path
is
not
dened
when
u
is
an
annihilation
rule
and
u
in
v
olv
es
the
endp
oin
ts
of
.
By
denition
of
sharing
rules,
u
is
\lo
cal",
namely
it
in
v
olv
es
exactly
t
w
o
no
des
n
and
n
0
in
G
and
the
edges
starting
at
these
no
des.
Therefore,
let
G
at
b
e
the
subgraph
of
G
where
n,
n
0
and
the
edges
starting
at
n
and
n
0
are
missing.
Then
G
at
is
also
a
subgraph
of
G
0
.
If

is
in
ternal
to
G
at
of
G
then
the
r
esidual
of

is
the
corresp
onding
path
in
G
at
y
This
constrain
t
guaran
tees
the
uniqueness
of
the
ancestor.
Indeed,
assume

start-
ing
at
the
auxiliary
p
ort
of
a
no
de
m,
m
is
in
v
olv
ed
in
u
and
u
is
not
the
rst
edge
of
.
Then
the
residuals
of

and
u
should
b
e
the
same.


Paths
*
*
λ
@
@
λ
@
λ
@
*
*
λ
@
λ
@
@
*
*
@
*
λ
@
λ
*
*
*
*
λ
*
@
*
*
*
λ
@
*
*
*
λ
*
@
@
@
*
*
@
λ
*
*
@
*
*
*
*
*
*
(1)
(2)
λ
@
@
λ
λ
(3)
(4)
(5) 
(6)
(7)
(8)
(9)
λ
*
@ @
Fig.
..
Abstract
reduction
of
(
)

.
Virtual
inter
actions
	
*
*
λ
@
@
λ
@
λ
@
*
*
λ
@
@
λ
@
λ
@
Fig.
..
Virtual
fan-annihilati
ons
in
(
)
of
G
0
.
Otherwise

=


e

m

up

e
0




e
k
m
k
up
k
e
0
k

k+
suc
h
that

i
are
in
ternal
to
the
subgraph
G
at
of
G,


e

or
e
0
k

k+
ma
y
b
e
missing
and
fm
i
;
p
i
g
=
fn;
n
0
g.
There
are
t
w
o
cases:
(u
is
a
c
ommutation
rule
)
Let
us
dene
the
cases
when


e

or


e

m

u
are
missing:
the
other
cases
ma
y
b
e
dened
in
a
similar
w
a
y
.
In
this
case
the
residual
of

is
m
0

c
0


0




c
k
p
0
k
v
k
m
0
k
c
0
k

0
k+
,
where

0
i
are
the
residuals
of

i
,
c
i
p
0
i
v
i
m
0
i
c
0
i
are
the
unique
paths
tra
v
ers-
ing
the
part
of
G
0
whic
h
is
not
in
G
at
suc
h
that
they
connect
the
p
orts
whic
h
corresp
ond
to
the
initial
p
ort
of
e
i
and
the
nal
p
ort
of
e
0
i
.
The
no
de
m
0

is
consecutiv
e
to
the
initial
no
de
of

0

through
the
p
ort
corresp
onding
to
the
nal
p
ort
of
e
0

.
(u
is
an
annihilation
rule
)
Remark
that


e

and
e
0
k

k+
cannot
b
e
missing
in
this
case.
The
residual
of

is

0

c




c
k

0
k+
,
where

0
i
are
the
residuals
of

i
and
c
i
are
the
edges
connecting
the
p
orts
whic
h
corresp
ond
to
the
initial
p
ort
of
e
i
and
the
nal
p
ort
of
e
0
i
.
There
is
an
ob
vious
consequence
of
the
ab
o
v
e
denition:
Prop
osition
..
The
r
esidual
of
a
p
ath
(if
any)
is
unique.
The
uniqueness
of
residuals
allo
ws
to
dene
the
\in
v
erse"
notion,
called
ancestor.

0
Paths
Denition
..
Let

b
e
the
residual
of
.
Then

is
called
the
an-
c
estor
of
.
Ob
viously
,
since
Lamping's
graph
rewriting
rules
preserv
e
the
con-
sistency
of
paths,
the
residual
of
a
consisten
t
path
is
still
consisten
t.
Similarly
for
the
ancestor.
..
F
an
annihilations
and
cycles
Lemma
..
L
et
'
b
e
a
p
ath
starting
and
terminating
at
the
princip
al
p
orts
of
two
abstr
actions

and

0
.
L
et

and

0
b
e
two
discriminants
of

and

0
,
r
esp
e
ctively,
such
that
'
and
'(
0
)
r
ar
e
b
oth
le
gal.
The
p
ath
'(
0
)
r
is
il
le
gal
if
and
only
if:
(i)

=

0
,

=
u,

0
=
v
0
and
u
=
v;
(ii)
'
=
 @@ 
r
,
wher
e
 
is
a
virtual
r
e
dex
and

is
an
@-cycle.
Pr
o
of
The
if
direction
is
immediate
b
y
denition
of
legalit
y
.
The
only-if
direction
is
pro
v
ed
b
y
con
tradiction.
Let
'(
0
)
r
b
e
illegal
and
'(
0
)
r
=
u @@ 
r

r
v(
0
)
r
,
with
u
=
v,
 
b
e
a
virtual
redex
and

b
e
a
@-cycle.
Since
'(
0
)
r
is
illegal,
there
exists
a
subpath
#
=


@
0

0
@
0
(
0
)
r


(
0
)
r
of
'(
0
)
r
suc
h
that

=

0
or

=

0
.
No
w,
remark
that
#
m
ust
b
e
a
subpath
of
'
or
of
'(
0
)
r
,
whic
h
implies
that
one
b
et
w
een
'
and
'(
0
)
r
is
illegal.
But
this
is
imp
ossible,
since
they
are
b
oth
legal,
b
y
h
yp
othesis.
Theorem
..
L
et
[M]
!

G
and
u
b
e
an
e
dge
in
G
c
onne
cting
the
princip
al
p
orts
of
two
fans.
The
inter
action
u
annihilates
the
two
fans
if
and
only
if
the
anc
estor
of
u
is
a
p
ath
 @@ 
r

r
,
wher
e

is
a
discriminant,
 
is
a
virtual
r
e
dex
and

is
a
@-cycle.
Pr
o
of
(if
dir
e
ction
)
Let

=
 @@ 
r

r
b
e
the
ancestor
of
u
suc
h
that

is
a
discriminan
t,
 
is
a
virtual
redex
and

is
a
@-cycle.
Then
every
p
ath
tra
v
ersing
the
-p
ort
of
an
ending
fan
of

and
the
-p
ort
of
the
other
is
illegal
(hence
inconsisten
t,
b
y
Theorem
..
and
Theorem
..).
Therefore
the
in
teraction
u
cannot
comm
ute
the
t
w
o
fans,
otherwise
the
ancestor
of
a
consisten
t
path
could
b
e
inconsisten
t,
in
v
alidating
the
con
text
seman
tics.

.
Virtual
inter
actions

(only-if
dir
e
ction
)
Assume
that
u
annihilates
the
t
w
o
fans.
This
means
that
every
p
ath
tra
v
ersing
the
-p
ort
of
a
fan
and
the
-p
ort
of
the
other
is
inconsisten
t,
since
sharing
rules
preserv
e
consistency
(b
y
the
con
text
seman
tics).
No
w,
tak
e
the
ancestor

of
u
in
[M].
Notice
that

=
'
0
(
0
)
r
.
Moreo
v
er,

is
consisten
t
b
ecause
u
is
consisten
t.
Let
e
b
e
the
edge
of
the
-p
ort
of
one
of
the
ending
fans
of

and
e
0
b
e
the
edge
of
the
-p
ort
of
the
other.
It
is
not
dicult
to
sho
w
that
e
and
e
0
are
consisten
t.
Ho
w
ev
er,
ee
0
is
inconsisten
t,
since
its
residual
in
G
will
tra
v
erse
the
-edge
of
a
fan
of
u
and
the
-edge
of
the
other.
Then,
b
y
Lemma
..
(only-if
direction),

=

0
and
'
=
 @@ 
r
,
where
 
is
a
virtual
redex
and

is
a
@-cycle.
Corollary
..
If
two
fans
match
(ar
e
p
air
e
d),
they
ar
e
r
esidual
of
a
same
fan
in
the
initial
gr
aph.
All
previous
results
could
b
e
easily
generalized
to
the
other
con
trol
op
erators
(do
it
as
an
exercise).
Let
us
remind
that
the
con
v
erse
of
Corollary
..
is
not
true
in
gen-
eral.
In
fact,
there
are
cases
in
whic
h
t
w
o
residuals
of
a
same
con
trol
no
de
meet
with
dieren
t
indexes,
and
consequen
tly
,
they
do
not
anni-
hilate.
This
is
indeed
the
reason
b
ecause
of
whic
h
a
static
lab
eling
of
fans
w
as
insucien
t
and
w
e
had
to
in
tro
duce
indexes
and
brac
k
ets
(see
the
example
in
Figure
.
at
the
b
eginning
of
Chapter
).
Nev
erthe-
less,
the
previous
corollary
sho
ws
that
all
the
con
trol
no
des
in
an
initial
graph
are
indeed
distinct
ob
jects,
for
t
w
o
con
trol
op
erators
with
distinct
ancestors
in
the
initial
graph
will
nev
er
matc
h.
F
or
instance,
w
e
could
explicitly
distinguish
all
the
con
trol
no
des
in
the
initial
graph
decorating
them
with
a
distinct
name.
Preserving
the
usual
op
erational
b
eha
vior
of
con
trol
no
des,
w
e
could
also
assume
that
names
are
in
v
arian
t
along
reduction
(i.e.,
a
con
trol
no
de
b
ear
a
giv
en
name
i
it
is
the
residual
of
a
no
de
with
suc
h
a
name).
In
the
case
of
facing
con
trol
op
erators
w
e
could
then
c
hec
k
if
they
ha
v
e
the
same
index|pro
ceeding
th
us
with
an
annihilation|only
when
they
ha
v
e
the
same
name;
in
the
other
cases,
w
e
could
instead
directly
pro
ceed
with
a
sw
ap,
for
b
y
Corollary
..
the
no
des
ha
v
e
denitely
dieren
t
indexes.
Suc
h
a
prop
ert
y
will
b
e
exploited
b
y
the
in
tro
duction
of
safe
op
er
ators
(Chapter
	)
to
pro
v
e
soundness
of
some
additional
simplication
rules
of
con
trol
no
des.
In
particular,
w
e
will
dene
safe
an
op
erator
whose
residuals
ma
y
erase
only
b
y
anni-


Paths
hilation
rules
in
v
olving
t
w
o
of
them.
Therefore,
according
to
suc
h
a
denition,
Corollary
..
states
that
all
the
con
trol
no
des
in
the
initial
graph
are
safe.
The
theoretical
in
terest
of
Theorem
..
is
that
it
allo
ws
to
translate
a
dynamical
concept
(an
in
teraction)
in
to
a
static
one
(a
path).
This
cor-
resp
ondence
b
et
w
een
paths
and
annihilations
explains
in
a
v
ery
simple
and
in
tuitiv
e
w
a
y
why
fan
annihilates
(due
to
the
legal,
lo
oping
nature
of
the
path),
which
fans
will
annihilate
(residuals
of
a
same
initial
fan
along
the
path),
and
also,
b
y
a
simple
insp
ection
of
the
path,
wher
e
and
when
the
actual
annihilation
will
tak
e
place.


Read-bac
k
In
this
c
hapter
w
e
will
pursue
a
more
syn
tactical
study
of
the
prop
erties
of
sharing
graphs
and
w
e
will
presen
t
a
w
a
y
to
group
con
trol
no
des
allo
wing
to
solv
e
and
simplify
the
problem
of
read-bac
k.
The
set
of
rules
for
con
trol
no
des
that
w
e
already
met
will
b
e
extended
b
y
other
rules
preserving
the
corresp
ondence
b
et
w
een
sharing
graphs
and
-terms.
The
extended
set
of
pr
op
agation
rules
obtained
in
this
w
a
y
will
not
b
e
an
ymore
optimal,
but
will
allo
w
a
clean
study
of
Lamping's
tec
hnique
in
terms
of
usual
rewriting
system
prop
erties.
Moreo
v
er,
giv
en
the
previous
extended
set
of
propagation
rules,
sa
y
,
w
e
will
see
that
Lamping's
optimal
algorithm
corresp
onds
exactly
to
the
subset
of
rules
induced
b
y
a
lazy
application
(w.r.t.
duplication
of
-redex
edges)
of
the
rules
in
.
The
analysis
mo
v
es
from
the
idea
that
the
propagation
rules
for
con-
trol
no
des
are
a
distributed
and
step-b
y-step
implemen
tati
on
of
-rule.
According
to
this,
a
natural
requiremen
t
migh
t
th
us
b
e
that,
for
an
y
-rule
M
!
N,
there
exist
a
corresp
onding
sharing
graph
reduction
[M]

[N]
rewriting
the
translation
of
M
in
to
the
translation
of
N.
W
e
stress
that
this
is
m
uc
h
stronger
than
what
w
e
ha
v
e
got
pro
ving
sound-
ness
of
Lamping's
algorithm.
There
w
e
just
sho
w
ed
that
for
an
y
sharing
reduction
[M]

G
the
graph
G
is
some
compact
represen
tation
of
a
reduct
N
of
M
(i.e.,
M

N
in
-calculus).
The
previous
requiremen
t
asks
instead
to
reac
h
the
translation
of
N
at
the
end
of
some
reduction
of
G
(i.e.,
G

[N]).
The
existence
of
suc
h
a
reduction
w
ould
giv
e
b
y
denition
an
in
ternal
implemen
tation
of
the
read-bac
k
algorithm.
A
t
the
same
time
it
m
ust
b
e
clear
that
there
is
no
c
hance
to
get
this
without
extending
the
rewriting
rules.
Namely
,
the
rules
implemen
ting
read-bac
k
will
not
necessarily
b
e
optimal
preserving.



R
e
ad-b
ack
A
relev
an
t
case
in
whic
h
the
read-bac
k
prop
ert
y
holds
without
an
y
addition
to
the
usual
optimal
rules
is
the
term
(
)
(see
Figure
.
in
Chapter
).
As
w
e
already
kno
w,
this
-term
alw
a
ys
rewrites
to
itself.
Moreo
v
er,
b
eing
G
=
[(
)],
it
is
not
dicult
to
see
that
after
the
con-
traction
of
the
unique
-redex
in
G
w
e
get
a
shared
represen
tation
G
0
of
(
)
that
can
at
its
turn
b
e
reduced
to
G
b
y
a
sequence
of
brac
k
et
and
fan
rules
(i.e.,
G
!

G
0

G).
In
this
case,
things
w
ork
w
ell
since,
unfolding
the
shared
instances
of
,
w
e
do
not
ha
v
e
to
duplicate
an
y
virtual
redex.
As
a
matter
of
fact,
the
optimal
rules
will
not
al-
lo
w
to
ac
hiev
e
the
previous
prop
ert
y
in
the
general
case.
F
or
instance,
let
us
tak
e
the
redex
R
=
(x:
M
N)
suc
h
that
N
con
tains
at
least
a
redex,
and
x
o
ccurs
sev
eral
times
in
N.
By
denition
of
optimalit
y
,
if
(x:
M
N)
R
!
T
,
no
optimal
sharing
graph
implemen
tation
can
admit
a
reduction
[(x:
M
N)]

[T
].
Later,
w
e
will
indeed
see
that,
without
an
y
extension
to
the
basic
set
of
rules
giv
en
in
Chapter
,
the
previous
problem
is
unsolv
able
indep
en-
den
tly
of
sharing.
Namely
,
in
absence
of
sharable
redexes,
the
reduction
ma
y
end
with
an
unshared
represen
tation
of
a
-term
T
that
dier
from
[T
]
b
ecause
of
some
spurious
con
trol
no
des
accum
ulated
along
the
re-
duction
(for
the
full
details
and
some
examples
see
Chapter
	).
Summarizing
,
let
us
pro
ceed
forgetting
optimalit
y
for
a
while.
W
e
aim
at
nding
all
the
propagation
()
rules
for
con
trol
no
des
that
are
sound
w.r.t.
the
in
terpretation
of
sharing
graphs
as
-terms.
Giv
en
suc
h
a
set
of
rules
w
e
will
study
its
main
prop
erties
(conuence
and
strong
normalization).
Finally
,
w
e
will
notice
that
Lamping's
algorithm
is
just
a
particular
lazy
reduction
strategy
for
-rules.
As
a
main
result
w
e
will
get
that,
giv
en
a
-term
M,
for
an
y
sharing
reduction
[M]

G,
the
extended
set

of
con
trol
no
de
rules
allo
ws
to
reduce
G
to
the
sharing
graph
[N],
where
N
is
the
-term
matc
hing
with
G.
In
particular,
assuming
that
[M]

G
is
an
optimal
reduction,
the
unrestricted
application
of
the
rules

giv
es
an
algorithm
for
the
read-bac
k
of
the
-term
corresp
onding
to
G.
Let
us
also
remark
that,
since
the
pro
of
of
correctness
of
the
read-bac
k
of
G
will
rest
on
the
fact
that
G

[N]
for
some
-term
N
suc
h
that
M

N,
this
will
giv
e
another
correctness
pro
of
of
Lamping's
algorithm.
The
previous
approac
h
generalizes
to
more
general
graph
rewriting
systems
in
whic
h
there
is
a
rule
similar
to

of
-calculus,
sa
y
-lik
e.
Using
the
natural
generalization
of
the
rules

to
suc
h
systems,
the
global
-lik
e
rule
can
b
e
implemen
ted
via
a
lo
cal
and
distributed
graph

.
Static
and
dynamic
sharing

rewriting
system
for
whic
h,
when
it
mak
es
sense,
optimal
reduction
can
b
e
dened
as
a
particular
reduction
strategy
for

+
.
F
or
a
treatmen
t
of
this
general
result
w
e
refer
the
in
terested
reader
to
[Gue	
].
.
Static
and
dynamic
sharing
T
o
presen
t
the
results
describ
ed
in
the
in
tro
duction
to
the
c
hapter
w
e
will
resort
to
a
small
c
hange
in
the
presen
tation
of
sharing
graphs.
The
follo
wing
discussion
will
p
oin
t
out
that
in
sharing
graphs
there
are
co-
heren
t
sequences
of
con
trol
no
des
whic
h
ma
y
b
e
usefully
group
ed
in
to
comp
ound
op
erators.
Similar
argumen
ts
will
b
e
at
the
base
of
the
safe
op
erators
that
w
e
will
study
in
Chapter
	.
..
Gr
ouping
se
quenc
es
of
br
ackets
It
is
immedia
te
to
see
that
the
follo
wing
conguration:
n+1
n
can
b
e
in
terpreted
as
a
comp
ound
op
erator
with
a
n
ull
eect
on
the
no
des
it
acts
on.
A
similar
argumen
t
applies
to
sequences
of
brac
k
ets
with
the
more
general
shap
e
in
Figure
.,
where
q

-.
n
n+q
n+q+1
q+1
Fig.
..
A
brac
k
et-croissan
t
sequence
In
this
case,
the
result
is
a
comp
ound
no
de
whose
task
is
to
lift
b
y
the
oset
q
the
no
des
it
acts
on.
In
fact,
let
suc
h
a
brac
k
et-croissan
t
sequence
meet
a
generic
no
de
whose
index
i
is
greater
than
n.
There
is
a
rewriting
sequence
b
y
whic
h
all
the
brac
k
ets
cross
the
no
de
(see
Figure
.):
eac
h
of
the
q
+

square
brac
k
ets
increasing
b
y

the
index
of
the
no
de;
the
croissan
t
decreasing
b
y

suc
h
an
index.
By
the
w
a
y
,
ev
en
more
complicated
congurations
can
b
e
treated
as
a
unique
comp
ound
no
de.
Besides,
their
grouping
turns
to
b
e
useful
only
if
suc
h
sequences
corresp
ond
to
patterns
arising
in
sharing
graphs


R
e
ad-b
ack
f
n+q+1
n+q
n
f
.  .  .
i
n
n
n+q+1
n+q
.  .  .
n+q
n  <  i 
i+q
n+q+1
Fig.
..
A
sequence
of
brac
k
ets
crossing
a
generic
no
de.
represen
ting
-terms.
Let
us
illustrate
b
y
an
example
the
only
relev
an
t
case:
the
trees
of
brac
k
ets
and
fans
corresp
onding
to
the
o
ccurrences
of
a
v
ariable
in
a
term.
λ
@
x
*
0
λ
0
1
0
0
@ 0
.[  ]0
=
Fig.
..

=
x:xx.
In
Figure
.
w
e
ha
v
e
dra
wn
the
syn
tax
tree
of

=
x:
(xx)
(on
the
left)
and
the
corresp
onding
sharing
graph
(on
the
righ
t).
The
v
ariable
x
o
ccurs
t
wice
in
the
b
o
dy
of
.
Therefore,
bac
k-connecting
the
o
ccur-
rences
of
this
v
ariable
to
the
corresp
onding
binder
w
e
w
ould
get
t
w
o
binding
edges
incoming
to
the
no
de
of
x.
In
order,
to
k
eep
the
fact
that
an
y
abstraction
has
a
unique
binding
p
ort,
let
us
add
in
the
syn
tax
tree
of

a
no
de
x
con
tracting
the
t
w
o
o
ccurrences
of
the
v
ariable
x
in
to
a
unique
wire.
In
terms
of
sharing
graphs,
the
latter
no
de
for
a
v
ariable
corresp
onds
to
a
fan
with
t
w
o
sequences
of
brac
k
ets
at
its
input
p
orts.
Also
suc
h
fan-
brac
k
ets
tree
ma
y
b
e
group
ed
in
a
comp
ound
no
de.
In
fact,
let
the
fan
in
teract
with
a
no
de.
After
the
duplication
of
the
no
de,
eac
h
brac
k
et-
croissan
t
sequence
connected
to
an
input
of
the
fan
ma
y
cross
the
new
instance
of
the
no
de,
lifting
it
b
y
the
corresp
onding
sequence
oset.

.
Static
and
dynamic
sharing

More
generally
,
for
an
y
v
ariable
w
e
ha
v
e
a
fan-brac
k
et
tree
as
the
one
in
Figure
.,
an
y
branc
h
of
whic
h,
a
discriminant
of
the
v
ariable
x,
is
a
connection
from
an
o
ccurrence
of
x
to
its
binder.
*
*
ρ = σ
1
1
pρ1
*
i+q +1
1
i+p+p -1
1
i+p
Σ
α<ρ
p
i
i+p-1
i+p
p1
i
i
q =
α
p
p
1σ
i+q +1
k
i+p
i+p+p -1
2
Fig.
..
F
an-brac
k
et
tree.
A
part
for
fans,
crossing
a
discriminan
t
w
e
meet
a
sequence
of
brac
k-
ets
whose
oset
is
equal
to
the
dierence
b
et
w
een
the
index
at
whic
h
the
corresp
onding
o
ccurrence
of
x
is
translated
(i.e.,
the
index
of
the
croissan
t)
and
the
index
of
the

no
de
binding
x
decreased
b
y
.
F
or
instance,
in
Figure
.
w
e
ha
v
e
explicitly
depicted
the
v
ariable
x
in
.
*
[x]1
[  x]
λ
0
0
0
1
0
-1
0
[x]0
Fig.
..
The
fan-brac
k
et
tree
represen
ting
x
in
.
The
tree
in
Figure
.
globally
b
eha
v
es
as
a
k-ary
duplicator
follo
w
ed
b
y
k
reindexing
op
erators
lifting
the
i-th
instance
of
the
duplicated
no
de
b
y
the
oset
q
i
.
T
o
mak
e
suc
h
a
b
eha
vior
more
explicit,
let
us
consider
the
p
erm
utation
rule
in
Figure
..
This
rule
is
not
justied
b
y
the


R
e
ad-b
ack
con
text
seman
tics.
In
spite
of
this,
the
p
erm
utation
is
sound
if
applied
to
the
initial
conguration
(or
to
so-called
safe
op
erators,
see
Chapter
	).
*
*
n
n
n
n
n+1
Fig.
..
Brac
k
et-m
ux
p
erm
utation|soun
d
at
initializ
atio
n.
Exercise
..
Pro
v
e
that
the
rule
in
Figure
.
is
not
justied
b
y
the
con
text
seman
tics
but
it
is
sound
for
a
sharing
graph
whic
h
is
the
translation
of
a
-term:
the
p
erm
utation
preserv
es
the
three
prop
erties
used
pro
ving
correctness
of
Lamping's
algorithm.
Iterating
the
transformation
in
Figure
.
an
y
fan-brac
k
et
tree
of
a
v
ariable
can
b
e
con
v
erted
in
to
a
tree
in
whic
h
the
brac
k
ets
are
pushed
to
w
ards
the
lea
v
es
and
all
the
fans
ha
v
e
the
same
index.
The
comp
ound
no
de
corresp
onding
to
suc
h
a
kind
of
tree
is
the
v
no
de
dra
wn
in
Fig-
ure
.,
that
is,
a
no
de
with
a
unique
output
wire
to
b
e
connected
to
the
binder
of
the
v
ariable
and
an
input
wire
with
an
asso
ciated
oset
for
eac
h
o
ccurrence
of
the
v
ariable.
*
*
i+q1
i+q +1
k
i+qk
i+q +1
1
*
i
i
i
i
i
=
v
q
q
1
k
i
Fig.
..
v
no
de
The
output
edge
lea
v
es
a
v
no
de
from
its
princip
al
p
ort,
the
input
edges
en
ter
in
to
a
v
no
de
through
its
auxiliary
p
orts.
The
auxiliary
p
orts
of
a
v
no
de
are
not
named,
the
only
lab
el
they
ha
v
e
is
an
oset
greater
or
equal
than
-.
Th
us,
t
w
o
p
orts
of
a
v
no
de
with
the
same
oset
are
indistinguishable.

.
Static
and
dynamic
sharing
	
..
Indexe
d
-tr
e
es
Using
v
no
des,
w
e
asso
ciate
to
eac
h
-term
a
structure
tigh
tly
related
to
the
term
abstract
syn
tax
tree.
Let
us
call
suc
h
a
structure
an
indexe
d
-tr
e
e,
or
a
-tree
for
short.
There
is
a
certain
abuse
of
notation
in
dening
the
previous
structure
a
tree,
as
it
con
tains
the
lo
ops
created
b
y
the
bac
k-connections
from
the
v
ariable
o
ccurrences
to
their
binders.
An
yho
w,
just
remo
ving
them,
w
e
get
a
tree.
(F
or
an
exp
osition
in
whic
h
there
is
a
more
explicit
distinction
b
et
w
een
the
tree
of
the
-term
and
its
binding
relation
see
[Gue	,
Gue	].)
Giv
en
a
-term,
w
e
could
get
a
-tree
applying
rst
the
translation
in
section
.
and
then
the
p
erm
utation
and
grouping
pro
cedures
pre-
viously
describ
ed.
Ho
w
ev
er,
the
indexes
of
a
-tree
can
b
e
directly
de-
termined
decorating
the
edges
of
the
tree
b
y
an
indexed
term,
in
accord
with
the
rules
in
Figure
..
n
x
n+q +1
x
1
n+q +1
x
k
sn
t n+1
nt
n
x
λx.t n
v
1
k
q
q
n
n
@
λn
(st) n
Fig.
..
Indexing
rules.
The
rules
in
Figure
.
force
the
uniqueness
of
the
decoration
of
a
-term
syn
tax
tree
(see
Figure
.	
for
the
decoration
of
(
)).
In
partic-
ular,
the
index
n
of
an
o
ccurrence
of
a
v
ariable
is
greater
or
equal
than
the
index
l
of
the

no
de
binding
it.
Hence,
the
oset
of
the
corresp
ond-
ing
edge
en
tering
in
to
a
v
no
de
is
q
=
n
-
l
-


-.
W
e
also
stress
that
the
previous
decoration
is
not
part
of
the
graph:
it
is
just
useful
to
determine
the
osets
of
the
wires
en
tering
in
to
a
v
no
de.
The
usual
-calculus
-rule
naturally
induces
a
corresp
onding
-tree
reduction.
Denition
..
Let
T
b
e
the
-tree
of
the
-term
t.
If
T
0
is
the
-tree
of
t
0
and
t
!
t
0
,
then
T
!


T
0
.
..
Beta
rule
The
-rule
is
implemen
ted
in
the
usual
w
a
y
(see
Figure
.0):
the
@-
redex
disapp
ears
substituted
b
y
direct
connections
from
the
con
text
edge
of
the
@
no
de
to
the
b
o
dy
edge
of
the

no
de,
and
from
the
binding
edge

0
R
e
ad-b
ack
x1
x1
x2
x0
x1
@
λ
0
-1
-1
0
1
v
@
@
v
λ
δ
δ
x
(xx)
(xx)
0
1
0
0
1
0
0
1
(δδ)0
0
1
Fig.
.	.
Decoration
of
(
).
of
the

no
de
to
the
argumen
t
edge
of
the
@
no
de.
The
main
dierence
is
that
a
-reduction
c
hanges
the
status
of
the
v
no
de
connected
to
the
binding
p
ort
of
the
redex.
In
fact,
suc
h
a
no
de
is
no
more
an
op
erator
con
tracting
the
o
ccurrences
of
a
v
ariable;
it
b
ecomes
instead
a
sharing
no
de
(the
triangle
in
Figure
.0)
con
tracting
a
set
of
access
p
oin
ters
to
a
same
shared
part
of
the
graph.
i
a 1
1
q
k
a
k
q
i
λ
q
q 1
k
v
body
context
argument
body
argument
context
@ i
i
Fig.
.0.
-rule
Hence,
-rule
b
ecomes
a
sort
of
task
activ
ator
transforming
a
static
ob
ject|a
v
no
de|in
to
a
dynamic
op
erator
whose
task
is
to
duplicate
the
argumen
t
of
the
redex.
In
more
details:
v
no
des
are
in
tro
duced
b
y
the
initial
translation
of
the
term;
their
principal
p
orts
p
oin
t
to
the
binding
p
ort
of
their
corresp
onding

no
de.
On
the
con
v
erse:
dynam-
ical
op
erators
are
in
tro
duced
b
y
-rules;
they
in
teract
with
the
no
des
they
p
oin
t
to
duplicating
them;
during
their
propagation
they
originate
unsharing
op
erators,
that
is,
fan-out's.

.
Static
and
dynamic
sharing

..
Multiplexer
The
triangle
in
tro
duced
b
y
the
-rule
is
a
sort
of
multiplexer
,
or
mux
for
short.
A
m
ux
no
de
is
similar
to
a
v
no
de|it
has
a
princip
al
p
ort
for
the
outgoing
edge
and
a
set
of
auxiliary
p
orts
for
the
incoming
edges|
but,
diering
from
v
no
de,
the
auxiliary
p
orts
of
a
m
ux
are
named
and
distinguishable,
see
Figure
..
Namely
,
the
k
auxiliary
p
orts
of
a
m
ux
are
lab
eled
b
y
names
a
i
;
:
:
:
;
a
k
c
hosen
among
a
den
umerable
set
of
names
A
with
the
pro
viso
that
a
i
=
a
j
implies
i
=
j.
a 1
1
q
a k q k
m
Fig.
..
Multiplexer
(m
ux)
no
de
As
for
fans,
w
e
ha
v
e
p
ositiv
e
and
negativ
e
m
uxes.
The
in
terpretation
is
the
same,
a
p
ositiv
e
m
ux
actually
denotes
a
m
ultiplexing
op
erator,
a
negativ
e
m
ux
is
rather
a
sort
of
dem
ultiplexing
op
erator.
The
index
m
of
a
m
ux
is
its
thr
eshold.
The
reasons
of
suc
h
a
name
will
b
ecome
clear
after
the
analysis
of
the
m
ux
rewriting
rules.
In
fact,
w
e
shall
see
that
a
m
ux
duplicates
an
i-indexed
no
de
only
if
i
is
ab
o
v
e
its
threshold
(i.e.,
m
<
i).
Remark
..
W
e
restrict
our
analysis
to
I-calculus.
This
implies
that
an
y
v
no
de,
and
th
us
an
y
m
ux
to
o,
has
at
least
an
auxiliary
p
ort.
In
the
follo
wing
w
e
will
need
to
distinguish
among
unary
and
k-ary
m
uxes.
In
particular,
w
e
will
refer
to
the
rst
ones
as
p
ositiv
e/negativ
e
lifts.
Although
a
lift
is
not
a
duplicator
but
just
an
op
erator
for
index
b
o
okk
eeping,
it
cannot
b
e
simply
remo
v
ed
from
sharing
graphs.
In
fact,
after
a
-redex
in
v
olving
a
linear
v
ariable,
the
corresp
onding
lift
has
the
task
to
increase
b
y
its
oset
all
the
indexes
in
the
argumen
t
of
the
redex.
The
in
terpretation
of
a
m
ux
in
terms
of
fans
and
brac
k
ets
is
exactly
the
same
of
a
v
no
de.
Namely
,
a
tree
of
fans
follo
w
ed
b
y
suitable
sequences
of
brac
k
ets.
This
suggests
a
natural
w
a
y
to
c
ho
ose
the
names
for
its
auxiliary
p
orts.
If
A
is
the
set
of
the
strings
o
v
er
f;
g,
let
us
tak
e
for
a
i
the
string
corresp
onding
to
the
discriminan
t
path
connecting
the
ro
ot
of
the
tree
to
its
i-th
leaf.
Suc
h
a
solution
implies
that
in
the
unary
case
w
e
ha
v
e
only
one
p
ossible
c
hoice:
a
=

(the
empt
y
string).
Ho
w
ev
er,
for
the
successiv
e
pro
ofs,
w
e
prefer
to
assume
a
more
general
assignmen
t
for


R
e
ad-b
ack
the
names
a
i
that
do
not
force
an
empt
y
v
alue
in
the
unary
case.
As
a
matter
of
fact,
from
the
implemen
tation
p
oin
t
of
view,
w
e
could
simply
get
rid
of
m
ux
auxiliary
p
ort
names,
assuming
that
their
auxiliary
p
orts
are
n
um
b
ered
according
to
some
ordering.
.
The
propagation
rules
Hitherto,
the
aim
w
as
at
dev
eloping
implemen
tations
tec
hniques
for
op-
timal
reductions.
Suc
h
a
requiremen
t
w
as
fullled
enforcing
a
lazy
b
e-
ha
vior
of
con
trol
no
des.
Dropping
suc
h
a
constrain
t,
w
e
can
see
that
b
ey
ond
the
optimal
rules,
there
are
other
rewriting
rules
(again,
see
also
Chapter
	)
that
can
b
e
added
to
the
system
with
no
impact
on
soundness,
although
some
of
them
causing
the
loss
of
optimalit
y
.
Th
us,
let
us
c
hange
the
fo
cus.
W
e
go
on
without
pa
ying
atten
tion
to
optimalit
y
,
but
rather
concen
trating
on
the
dynamical
in
terpretation
of
m
uxes
as
duplicators.
In
this
w
a
y
,
w
e
ac
hiev
e
a
set
of
rewriting
rules
for
m
uxes,
sa
y
-rules
,
comp
osed
of
all
the
lo
cal
graph
rewritings
sound
w.r.t.
the
in
tended
in
terpretation
of
sharing
graphs
in
-calculus.
Giv
en
suc
h
an
extended
set
of
rewriting
rules,
the
natural
question
is:
what
can
w
e
sa
y
ab
out
the
conuence
and
normalization
of
them?
The
answ
er
is:
restricting
our
atten
tion
to
the
sharing
graphs
obtainable
starting
from
a
-tree
(further
w
e
implicitly
assume
this
as
denition
of
sharing
graph),
-rules
are
conuen
t
and
strong
normalizing.
F
urther-
more,
the
(unique)

normal-form
of
a
sharing
graph
G
is
the
-tree
corresp
onding
to
G,
that
is,
its
read-bac
k.
..
Mux
inter
actions
The
rst
-rules
w
e
consider
deal
with
the
case
of
a
facing
pair
of
m
uxes.
Suc
h
rules
are
the
direct
reform
ulation
of
the
usual
ones
for
fans
and
brac
k
ets,
see
Figure
..
a1
ak qk
q1
a1
ak qk
q1
m
m
a1
ak qk
q1
b1 p1
hp
bh
m
n
n+q1
n+qi
n+qk
m
m
m
m < n
Fig.
..
Mux
in
teractions:
annihilati
on
(left)
and
sw
ap
(righ
t).
T
o
apply
the
annihilation
rule
the
pair
has
to
b
e
comp
osed
of
c
om-

.
The
pr
op
agation
rules

plementary
muxes
.
It
do
es
not
suce
to
ask
that
the
thresholds
of
the
m
uxes
coincide,
their
set
of
p
orts
m
ust
ha
v
e
matc
hing
name-oset
pairs
(i.e.,
for
an
y
p
ort
of
the
m
ux
lab
eled
with
the
name-oset
pair
(a
i
;
q
i
),
there
has
to
b
e
a
corresp
onding
p
ort
of
the
negativ
e
m
ux
lab
eled
b
y
(a
i
;
q
i
),
and
vice
v
ersa).
After
the
annihilation,
the
pair
of
m
uxes
is
replaced
b
y
a
set
of
direct
connections
b
et
w
een
the
edges
formerly
con-
nected
to
matc
hing
p
orts.
Let
us
note
that
the
rule
is
not
am
biguous
b
ecause
of
the
uniqueness
of
auxiliary
p
ort
names.
A
m
ux
pair
with
the
same
threshold
but
with
a
mismatc
h
b
et
w
een
the
auxiliary
p
orts
is
a
deadlo
c
k,
that
is,
a
conguration
irremediably
stuc
k,
for
it
cannot
b
e
remo
v
ed
b
y
applying
an
y
of
the
rewriting
rules.
Suc
h
kind
of
situations
w
ere
already
presen
t
in
the
form
ulation
using
brac
k
ets
and
fans:
*
n
n
*
n
n
n
n
In
particular,
the
deadlo
c
k
caused
b
y
a
mismatc
h
b
et
w
een
cardinali-
ties
corresp
onds
to
a
deadlo
c
k
ed
conguration
comp
osed
of
a
fan
with
index
n
facing
with
a
croissan
t/brac
k
et
ha
ving
the
same
index
n.
The
deadlo
c
k
caused
b
y
a
mismatc
h
b
et
w
een
the
lab
els
of
the
auxiliary
p
orts
corresp
onds
instead
to
a
brac
k
et
and
a
croissan
t
meeting
with
the
same
index.
..
Mux
pr
op
agatio
n
rules
As
a
consequence
of
the
in
terpretation
of
a
m
ux
as
an
unrestricted
du-
plicator,
there
is
a
rule
for
an
y
case
in
whic
h
the
principal
p
ort
of
a
m
ux
is
connected
to
a
logical
no
de
(;
@;
v
no
des).
In
the
case
in
whic
h
the
logical
no
de
is
a

or
an
@,
the
analysis
is
im-
mediate:
suc
h
no
des
cannot
b
e
the
b
order
of
the
duplicating
subgraph,
it
is
then
sound
to
allo
w
m
uxes
to
duplicate
them
in
an
y
case.
The
cor-
resp
onding
set
of
m
ux
propagation
rules
is
dra
wn
in
Figure
..
The
side
condition
m
<
i
restricts
the
applicabilit
y
of
the
rules
to
the
case
in
whic
h
the
index
of
the
-@
no
de
is
ab
o
v
e
the
threshold
of
the
m
ux.
Most
of
the
cases
excluded
b
y
the
side
condition
will
b
e
easily
pro
v
ed
unreac
hable
(see
Exercise
..).
Ho
w
ev
er,
suc
h
simple
reasonings
will
not
suce
to
pro
v
e
that
a
m
ux
with
threshold
m
=
i
cannot
reac
h
the
argumen
t
p
ort
of
an
@
no
de
with
index
i.
Let
us
note
that
a
situation


R
e
ad-b
ack
a1
ak qk
q1
@
m
i
a1
ak qk
q1
a1
ak qk
q1
i+q1
i+qk
@
@
m
m
a1
ak qk
q1
m
λ i
i+q1
i+qk
a1
ak qk
q1
a1
ak qk
q1
λ
λ
m
m
a1
ak qk
q1
@
m
i
a1
ak qk
q1
i+q1
a1
ak qk
q1
i+qk
@
m
m
@
a1
ak qk
q1
λi
m
i+q1
a1
ak qk
q1
a1
ak qk
q1
i+qk
λ
λ
m
m
a1
ak qk
q1
@
m
i
a1
ak qk
q1
a1
ak qk
q1
i+qk
i+q1@
@
m
m
a1
ak qk
q1
λi
m
i+q1
i+qk
a1
ak qk
q1
a1
ak qk
q1
λ
λ
m
m
m < i
m < i
m < i
m < i
m < i
m < i
Fig.
..
Propagation
rules
lik
e
this
w
ould
lead
to
a
deadlo
c
k
ed
conguration
after
the
execution
of
a
-rule
in
v
olving
the
@
no
de
p
oin
ted
b
y
the
m
ux.
T
o
exclude
the
pres-
ence
of
suc
h
deadlo
c
ks,
w
e
will
need
to
dev
elop
the
algebraic
seman
tics
of
section
.
The
analysis
of
the
in
teractions
b
et
w
een
a
m
ux
and
a
v
no
de
deserv
es
instead
more
atten
tion.
When
the
side
condition
m
<
i
holds,
w
e
can
pro
ceed
as
for
the
other
logical
no
des,
obtaining
the
propagation
rules
dra
wn
in
Figure
..
The
problem
with
the
left-hand
sides
of
the
rules
in
Figure
.
is
that
it
is
no
more
true
that
the
side
condition
m
<
i
alw
a
ys
hold
in
sharing
graphs.
In
fact,
at
the
end
of
its
propagation,
a
m
ux
migh
t
reac
h
the
v
no
de
of
a
v
ariable
whose
binder
is
external
to
the
duplicating
subgraph,
that
in
terms
of
indexes,
means
with
m

i.
This
has
no
coun
terpart
for
@
and
-no
des
and
deserv
es
indeed
a
rule
ad-ho
c.
In
fact,
since
this
case
corresp
onds
to
a
m
ux
reac
hing
the
b
order
of
the
subterm
it
had
to
duplicate,
the
op
erator
should
stop
duplicating
there.
In
some
sense,
the
m
ux
should
b
e
erased,
for
it
has
completed
its
task.
T
o
b
etter
understand
what
to
do
in
these
cases,
and
to
see
the
-rules
at
w
ork,
let
us
pro
ceed
with
an
example.

.
The
pr
op
agation
rules

p1
ph
a1
ak qk
q1
v i
m
m < i
i+qk
ph
p1
a1
ak qk
q1
p1
ph
i+q1
a1
ak qk
q1
v
m
v
m
p1
a1
ak qk
q1
ph
pj
v i
m
i+qk
ph
p1
a1
ak qk
q1
a1
ak qk
q1
p1
ph
pj
pj
i+q1
a1
ak qk
q1
v
m
m
v
m
m < i
Fig.
..
Mux-v
propagation
rules.
..
The
absorption
rule
Let
us
tak
e
the
term
z:
(w:
(w
w)
x:
y:
(y
(x
z))).
Its
-tree
and
the
initial
steps
of
its
reduction
are
dra
wn
in
Figure
..
A
t
the
end
of
this
reduction
the
m
ux
named

in
Figure
.
is
at
the
auxiliary
p
ort
of
a
v
no
de.
W
e
red
just
one
-rule,
all
the
m
uxes
are
copies
of
the
one
in
tro
duced
b
y
this
rule,
their
task
is
th
us
the
duplication
of
the
term
T
=
x:
y:
(y
(x
z)).
The
v
no
de
p
oin
ted
b
y

corresp
onds
to
the
v
ariable
y,
whic
h
is
b
ound
in
T
.
Then,
not
only
the
o
ccurrence
of
y
has
to
b
e
duplicated,
but
its
binder
to
o.
(Note
that
this
duplication
could
b
e
equiv
alen
tly
p
erformed
b
y
an
y
of
the
m
uxes

.
In
the
optimal
algorithm,
b
y
the
top
one.)
Since
y
is
b
ound
in
T
and
the
m
ux
w
as
created
outside
it,
that
is,
at
a
lev
el
lo
w
er
than
T
,
the
threshold
of

is
smaller
then
the
index
of
the
v
no
de;
the
side
condition
of
the
v
-propagation
rule
holds;
the
corresp
onding
reduction
is
the
one
in
Figure
..
After
the
annihilation
of
the
t
w
o
pairs
of
m
uxes
;


created
b
y
the
latter
reduction,
w
e
get
the
sharing
graph
on
the
left
in
Figure
.,
in
whic
h
only
the
m
ux

is
left.
Also

p
oin
ts
to
a
v
no
de,
but
in
this
case
the
no
de
represen
ts
a
v
ariable
(z)
whose
binder
is
external
to
T
.
In
other
w
ords,

has
reac
hed
the
b
order
of
its
scop
e
and
completing
its
task;
in
terms
of
indexes
the
threshold
of
the
m
ux
is
greater
or
equal
than
the
index
of
the
v
no
de.
Therefore,

can
b
e
incorp
orated
in
to
the
v
no
de
of
z,
and
the
edges
en
tering
in
to

can
b
e
directly
connected
to
the
v
no
de
of
z,
adding
to
their
osets
the
oset
of
the
p
ort
previously


R
e
ad-b
ack
@
λ
@
v
-1
0
0
0
@
v 1
λ 1
λ 1
@
v
v 0
1
2
λ0
0
0
2
-1
0
1
λ0
@
-1
0
0
@
v 1
λ
λ 1
@
v
v 0
1
2
0
2
1
-1
0
1
λ0
@
λ
λ
0
1
0
λ 1
v
v
v
v
-1
0
0
0
0
1
1
2
0
1
@
@
0
2
-1
0
0
0
-1
0
α
α
α
γ
λ0
@
λ
λ
0
1
0
λ 1
@
0
1
@
@
@
v
v
v
v
-1
0
-1
0
-1
0
0
0
0
1
2
1
1
-1
0
0
2
0
-1
0
0
0
Fig.
..
Reducing
z:(w:
(ww)
x:
y:
(y
(x
z)))

.
The
pr
op
agation
rules

λ0
@
λ
λ
0
1
0
λ 1
@
0
1
@
@
@
v
v
v
v
-1
0
-1
0
-1
-1
0
0
0
0
0
1
2
1
1
-1
0
0
2
0
0
0
α
α
α
α
γ
λ0
@
λ
λ
0
1
0
-1
0
0
λ 1
λ1
@
0
1
@
@
@
v
v
v
-1
0
-1
-1
0
0
0
0
1
2
1
0
2
0
0
0
v
v
0
1
-1
-1
0
0
0
0
Fig.
..
An
example
of
bac
kw
ard
v
-m
ux
propagation
p
oin
ted
b
y
.
The
result
of
suc
h
a
reduction
is
the
sharing
graph
on
the
righ
t
in
Figure
..
Summarizing
,
when
a
m
ux
with
threshold
m
reac
hes
an
auxiliary
p
ort
of
an
n-indexed
v
no
de,
w
e
can
ha
v
e:

m
<
n,
that
is,
the
o
ccurrence
of
the
v
ariable
and
its
binder
are
b
oth
in
the
scop
e
of
the
m
ux.
The
m
ux
can
propagate
duplicating
the
v
no
de
as
describ
ed
b
y
the
b
ottom
picture
in
Figure
..

n

m
<
n
+
p
+
,
where
p
is
the
oset
of
the
p
ort
to
whic
h
the
m
ux
is
connected.
In
this
case,
the

no
de
binding
the
v
ariable
is
not
in
the
scop
e
of
the
m
ux.
The
m
ux
can
complete
its
task
just
duplicating
the
o
ccurrence
of
the
v
ariable
it
p
oin
ts
to.
The
corresp
onding
rule
is
dra
wn
in
Figure
..
In
the
reduction
the
m
ux
disapp
ear
absorb
e
d
b
y
the
v
no
de;
its
auxiliary
p
orts
replace
the
p
ort
of
the
v
no
de
to
whic
h
the
m
ux
w
as
connected,
and
their
osets
are
increased
b
y
p.


R
e
ad-b
ack
λ0
@
λ
λ 1
0
0
λ
λ1
0
@
0
1
@
@
@
v
v
-1
0
0
1
2
1
0
0
v
v
0
1
v 0
1
2
λ0
@
λ
λ 1
0
0
λ
λ1
0
@
0
1
@
@
@
v
v
-1
-1
0
0
0
1
2
1
0
0
0
v
v
0
1
v 0
2
γ
Fig.
..
An
example
of
m
ux
absorption
rule
Remark
..
In
the
case
of
the
m
ux
absorption,
the
side
condition
n

m
<
n
+
p
+

implies
p

0.
Then,
the
osets
of
the
new
p
orts
of
the
v
no
de
are
denitely
greater
or
equal
than
-.
..
R
e
dexes
The
set
of
the
-rules
comp
oses
of
the
m
ux
in
teraction
rules
in
Fig-
ure
.,
of
the
m
ux
propagation
rules
in
Figure
.
and
Figure
.,
and
of
the
absorption
rule
in
Figure
..
In

the
only
no
de
whose
in
teraction
p
ort
is
alw
a
ys
xed
remains
the
m
ux:
a
m
ux
in
teract
with
another
link
only
through
its
principal
p
ort.
Moreo
v
er,
eac
h
m
ux
whose
principal
p
ort
is
not
connected
to
an
auxiliary
p
ort
of
another
m
ux
is
a
redex,
pro
vided
that
the
prop
er
side
condition
holds.
p1
a1
ak qk
q1
ph
p1
ph
p+q
j
k
p+q
j
1
n+p +1 > m > n
v n
m
pj
j
v n
Fig.
..
Mux-v
absorption
(b
ottom).

.
The
pr
op
agation
rules
	
Denition
..
(-redex)
A
-r
e
dex
is
a
pair
of
no
des
(

;


)
in
whic
h:
(i)


is
a
m
ux
connected
to
an
y
p
ort
of


but
an
auxiliary
one
when


is
a
m
ux
to
o;
(ii)
if
m
is
the
threshold
of


and
n
the
threshold/index
of


,
then
the
follo
wing
side
c
ondition
holds:
(a)
if


is
a
m
ux
and
m
=
n,
then
the
sets
of
pairs
lab
eling
the
auxiliary
p
orts
of


and


coincide;
(b)
if


is
a
v
no
de
and


p
oin
ts
to
an
auxiliary
p
ort
of


with
oset
q,
then
m
<
n
+
q
+
;
(c)
otherwise,
m
<
n.
Muxes
and
v
no
des
ha
v
e
analog
in
terpretations
in
terms
of
brac
k
ets
and
fans.
In
spite
of
this,
w
e
ha
v
e
more
reduction
rules
for
v
no
des
than
for
m
uxes.
In
particular,
there
are
rules
for
the
cases
in
whic
h
a
m
ux
reac
hes
the
auxiliary
p
ort
of
a
v
no
de.
The
corresp
onding
rules
for
m
uxes
w
ould
not
b
e
sound.
F
or
instance,
the
absorption
rule
w
ould
fail.
In
fact,
let

b
e
obtained
b
y
merging
a
m
ux

with
another
m
ux

follo
wing
it,
and
let
us
assume
that

reac
h
a
negativ
e
m
ux


that
should
annihilate
with
.
T
o
con
tin
ue
the
reduction,
w
e
should
b
e
able
to
split
bac
k

in
to

and
.
But
this
w
ould
imply
to
ha
v
e
a
w
a
y
to
record
in
to

the
threshold
and
the
names
of
the
p
orts
of
,
that
is,
to
ha
v
e
a
structure
with
the
same
complexit
y
of
the
m
uxes
k
ept
disjoin
t.
The
k
ey
p
oin
t
for
the
v
absorption
rule
is
that
a
v
no
de
has
not
a
complemen
tary
no
de.
The
rule
corresp
onding
to
the
propagation
of
a
m
ux
through
the
auxiliary
p
ort
of
a
v
no
de
is
instead
denitely
unsound.
Suc
h
a
rule,
w
ould
b
e
sound
only
in
the
situation
co
v
ered
b
y
the
m
ux
p
erm
utation
equiv
alence
that
w
e
will
later
in
tro
duce
studying
the
reduction
prop
erties
of
the

rules.
Exercise
..
Dene
a
propagation
rule
as
the
b
ottom
one
in
Fig-
ure
.,
putting
a
m
ux
in
the
place
of
the
v
no
de.
Wh
y
the
rule
cannot
b
e
sound?
(Hint:
It
w
ould
b
e
sound
to
rev
erse
the
direction
of
the
annihilation
rule?)
Exercise
..
A
pair
of
no
des
(

;


)
is
said
a
p
atholo
gic
al
redex
when


(let
m
b
e
its
threshold)
is
a
m
ux
connected
to
an
y
p
ort
of
the
logical
no
de


(let
i
b
e
its
index)
and
m

i,
but
m
=
i
when


is
an
@
no
de
and


is
connected
to
its
argumen
t
p
ort.
Pro
v
e
that
no
reduct
of
a
-tree
con
tains
a
pathological
redex.
(Hint:
Assume
that

0
R
e
ad-b
ack
eac
h
edge
of
a
sharing
graph
has
an
index
and
consisten
tly
extend
the
propagation
rules
to
edge
indexed
redexes.
Namely
,
when
a
m
ux
crosses
an
edge,
the
indexes
of
the
new
instances
of
the
edge
are
lifted
b
y
the
corresp
onding
oset
of
the
m
ux.
Assign
to
eac
h
edge
of
a
-tree
the
index
of
the
-term
assigned
to
it
b
y
the
decoration
rules
of
Figure
..
Pro
v
e
that
the
threshold
of
a
m
ux
is
alw
a
ys
smaller
than
the
index
of
its
principal
p
ort
edge.)
.
Deadlo
c
k
ed
redexes
The
purp
ose
of
the

rules
is
to
get
a
-tree
as
normal
form
of
the
m
ux
propagation.
Hence,
an
y
situation
in
whic
h
a
m
ux
is
stuc
k
b
ecause
it
is
not
part
of
a
redex,
and
there
is
no
c
hance
that
it
could
b
e
in
the
future,
has
to
b
e
considered
an
error.
Denition
..
(deadlo
c
k)
A
deadlo
c
k
ed
-redex,
or
a
de
ad
lo
ck
for
short,
is
a
pair
of
no
des
(

;


)
as
the
one
in
the
rst
item
of
Deni-
tion
..
that
violates
the
side
condition
giv
en
in
the
second
item
of
that
denition.
A
part
for
the
pathological
redexes
describ
ed
in
Exercise
..,
there
are
t
w
o
cases
of
deadlo
c
k:

A
m
ux
pair
stuc
k
b
ecause
the
m
uxes
ha
v
e
the
same
threshold,
but
their
auxiliary
p
orts
do
not
matc
h.

The
m
ux


is
connected
to
the
argumen
t
p
ort
of
the
@
no
de


and
the
threshold
of


is
equal
to
the
index
of


.
Denition
..
(deadlo
c
k
freeness)
The
sharing
graph
G
is
said
de
ad
lo
ck-fr
e
e
when,
for
an
y
-reduction

:
G

G

,
the
reduct
G

do
es
not
con
tain
an
y
deadlo
c
k
ed
-redex.
The
result
of
Exercise
..
allo
ws
to
infer
that
no
reduct
of
a
-tree
can
con
tain
a
m
ux
p
oin
ting
to
its
ro
ot.
Therefore,
an
y

normal-form
of
a
deadlo
c
k-free
sharing
graph
do
es
not
con
tain
m
uxes
at
all.
The
previous
denition
do
es
not
giv
e
an
y
insigh
t
on
ho
w
to
c
harac-
terize
deadlo
c
k-free
sharing
graphs:
according
to
it
there
is
no
w
a
y
than
reducing
them.
Moreo
v
er,
to
pro
v
e
deadlo
c
k-freeness
w
e
should
try
all
the
p
ossible
reduction
orders,
though
it
is
not
dicult
to
nd
a
standar
d
reduction
strategy
reducing
-trees
to
-trees,
sim
ulating
step-b
y-step
the
usual
-calculus
reduction
(see
Exercise
..).

.
De
ad
lo
cke
d
r
e
dexes

Exercise
..
(standard
strategy)
Let
us
call
a
sharing
graph
re-
duction
standard
when
an
y
of
its
-con
traction
is
follo
w
ed
b
y
a
max-
imal
sequence
of
-rules.
In
particular,
let
us
write
G
!
s
G

when
G
!

G



G

and
G

is
in

normal-form
.
Let
T

T

b
e
a
-term
reduction.
Pro
v
e
that
[T
]

s
[T

],
where
[T
]
and
[T

]
are
the
-trees
corresp
onding
to
T
and
T

,
resp
ectiv
ely
.
The
algebraic
seman
tics
of
section
.
will
giv
e
us
a
c
haracterization
of
deadlo
c
k-freeness
for
the
relev
an
t
case
in
whic
h
the

in
teractions
are
normalizing.
Besides,
some
useful
prop
erties
of
sharing
graphs
can
b
e
pro
v
ed
taking
deadlo
c
k-freeness
as
the
only
assumption.
..
Critic
al
p
airs
As
a
consequence
of
the
loss
of
the
uniqueness
of
the
in
teracting
p
ort
of
a
no
de,
the
system
is
no
more
an
in
teraction
net.
Then,
lo
cal
conuence
is
no
more
for
free,
but
m
ust
b
e
pro
v
ed
b
y
case
analysis
of
the
critical
pairs
b
et
w
een
-redexes.
Some
critical
pairs
can
b
e
remo
v
ed
assuming
that
the
sharing
graph
is
deadlo
c
k-free.
F
or
instance,
the
critical
pair
depicted
in
Figure
.	
(w
e
dra
w
this
and
the
follo
wing
picture
using
unary
m
uxes,
for
the
gen-
eralization
is
trivial)
ma
y
arise
in
a
deadlo
c
k-free
sharing
graph
only
if
a

=
a

and
q

=
q

.
In
whic
h
case,
after
the
annihilation
of
the
m
ux
pairs
w
e
close
the
picture
getting
a
comm
uting
diamond.
a1 q1
a2 q2
m
m
@
i
a2 q2
a1 q1
a1 q1
@
i+q
m
m
m
1
a2 q2
a2 q2
a1 q1
@
i+q
m
m
m
2
Fig.
.	.
Critical
pairs
for
the
-rules:
m
=
m

=
m

.
The
situation
is
dieren
t
when
the
threshold
of
the
m
uxes
dier,
as
in
Figure
.0.
In
this
case
w
e
ha
v
e
no
help
from
deadlo
c
k-freeness.
Lo
cal
conuence
is
lost
ev
en
for
deadlo
c
k-free
sharing
graph
(if
w
e
do
not
assume
an
y
other
prop
ert
y
of
the
graph).


R
e
ad-b
ack
a1 q1
a2 q2
m1
m2
@
i
a2 q2
a1 q1
a2 q2
a1
i+q +q
1
2
m +q
2
1
m1
m1
a1 q1
a2 q2
a2 q2
a1 q1
i+q +q
1
2
m1
m2
m1
m +q
2
1
m +q
2
1
@
q1
@
*
*
Fig.
.0.
Critical
pairs
for
the
-rules:
m

<
m

.
..
Mux
p
ermutation
e
quivalenc
e
According
to
the
path
seman
tics,
the
t
w
o
sharing
graphs
originated
b
y
the
critical
pair
in
Figure
.0
can
ho
w
ev
er
b
e
equated
mo
dulo
some
p
er-
m
utation
of
m
uxes.
Namely
,
w
e
dene
G


G

,
when
the
sharing
graph
G

is
obtainable
from
G

b
y
rep
eated
application
of
the
p
erm
utation
in
Figure
..
ak qk
a1 q1
a1 q1
a1 q1
ak qk
ak qk
bh ph
b1 p1
bj pj
x h
k
x h
1
x j
k
x 1
j
x 1
k
x 1
1
m
m
m
n
n+q1
n+qi
n+qk
b1 p1
b1 p1
bh ph
a1 q1
ak qk
ai qi
bh ph
bh ph b1 p1
x h
k
x h
1
x j
k
x 1
j
x 1
k
x 1
1
m
n > m
Fig.
..
Mux
p
erm
utation
equiv
alence.
The
p
erm
utation
equiv
alence

is
not
part
of
the
-rules.
It
has
b
een
in
tro
duced
just
to
pro
v
e
the
relev
an
t
prop
erties
of
sharing
graph
re-
duction.
In
particular,
to
sho
w
that
they
are
lo
cally
conuen
t
mo
dulo

(that
means
at
the
same
time
soundness
of
p
erm
utation
equiv
alence
w.r.t.
-reduction).
Lemma
..
(lo
cal
conuence)
F
or
any
p
air
of
e
quivalent
de
ad
lo
ck-
fr
e
e
sharing
gr
aphs
G
0

H
0
,
we
have
that:
G
0
{
{
{
{

}{
{
{
{
/o
H
0
C
C
C
C

!
C
C
C
C
G



!
H



}
G

/o
H


.
Sharing
morphisms

Pr
o
of
Let
(

;


)
b
et
the
redex
of
G
0
and
(

;


)
b
e
the
redex
of
H
0
.
By
denition
of
,
there
exists
a
k

0
and
t
w
o
sets
of
trees
of
m
uxes
T
0

;
:
:
:
;
T
0
k

G
0
and
T
00

;
:
:
:
;
T
00
k

H
0
s.t.:
(i
)
T
0
i
\
T
0
j
=
;
implies
T
0
i
=
T
0
j
and
T
00
i
=
T
00
j
;
(ii
)
T
0
i

T
00
i
,
for
i
=
;
:
:
:
;
k;
(iii
)
G
0
n
(
S
k
i=
T
0
i
)
=
H
0
n
(
S
k
i=
T
00
i
).
No
more
than
t
w
o
of
suc
h
trees
can
b
e
in
v
olv
ed
in
the
reduction
of
(

;


)
and
(

;


).
So,
let
us
assume
w.l.o.g.
k
=
.
The
pro
v
e
pro
ceed
b
y
case
analysis.
The
relev
an
t
cases
are:
(a
)
there
is
an
edge
connecting
the
ro
ots
of
T
0

and
T
0

,
and
the
redexes
(

;


)
and
(

;


)
are
the
m
ux
pairs
comp
osed
of
the
ro
ots
of
T
0

and
T
0

,
and
of
T
00

and
T
00

,
resp
ectiv
ely;
(b
)
the
m
uxes


and


are
the
ro
ots
of
T
0

and
T
0

,
resp
ectiv
ely
,
and


=


.
In
b
oth
these
cases
w
e
see
that
the
trees
of
m
uxes
can
b
e
considered
as
a
sort
of
big
no
de
and
that
considerations
analog
to
the
one
pursued
for
the
m
uxes
in
Figure
.0
and
Figure
.
apply
to
these
big
no
des
to
o.
Exercise
..
Complete
the
pro
of
of
Lemma
...
The
previous
result
sho
ws
that
w
e
nev
er
need
to
p
erform
an
y
p
erm
u-
tation
in
order
to
allo
w
-reduction
to
pro
ceed.
F
urthermore,
as
an
y

normal-form
of
a
deadlo
c
k-free
sharing
graph
is
m
ux
free
(it
is
th
us
the
only
elemen
t
of
its
equiv
alence
class
mo
dulo
),
a
deadlo
c
k-free
sharing
graph
has
at
most
a

normal-form
.
Using
the
algebraic
seman
tics,
w
e
will
also
pro
v
e
that
the
-rules
are
strongly
normalizing
o
v
er
sharing
graphs,
and
then
the
existence
and
uniqueness
of
their

normal-form
.
Remark
..
There
is
no
simple
w
a
y
to
ha
v
e
something
similar
to
Lemma
..
in
the
case
of

+
.
The
problem
are
the
critical
pairs
b
et
w
een
a
m
ux-v
redex
and
a
-redex.
F
or
instance,
let
us
consider
the
case
of
a
critical
pair
b
et
w
een
an
absorption
rule
and
a
-redex.
If
w
e
w
ould
execute
the
-rule
rst
w
e
w
ould
in
tro
duce
a
m
ux
in
fron
t
of
the
one
that
could
b
e
absorb
ed,
and
there
is
no
direct
w
a
y
to
merge
suc
h
t
w
o
m
uxes.
If
w
e
w
ould
execute
the
absorption
rule
rst,
after
the
-rule
w
e
w
ould
ev
en
tually
get
a
sharing
graph
with
a
unique
m
ux
that
is
the
merging
of
the
t
w
o
m
uxes
obtained
in
the
other
case.
.
Sharing
morphisms
Giv
en
t
w
o
sharing
structures
G

and
G

,
w
e
can
assume
that
they
are
represen
tations
of
the
same
ob
ject
when
G

is
obtainable
b
y
un
winding
some
sharing
con
tained
in
G

,
or
vice
v
ersa.
A
formal
w
a
y
to
express


R
e
ad-b
ack
suc
h
a
notion
is
via
a
partial
order
relation
G


G

capturing
the
in
tuitiv
e
statemen
t:
\G

is
a
less-shared-instance
of
G

".
According
to
its
in
tuitiv
e
denition,
G


G

implies
the
existence
of
a
corresp
ondence
b
y
whic
h
an
y
no
de/edge
of
G

can
b
e
in
terpreted
as
the
image
of
(at
least)
a
no
de/edge
of
G

.
Namely
,
a
function
mapping
the
ro
ot
of
G

in
to
the
ro
ot
of
G

,
a

no
de
of
G

in
to
a

no
de
of
G

,
and
so
on
for
no
des;
plus
a
function
mapping
an
y
edge
of
G

connecting
the
p
ort
x
of
the
no
de

to
the
p
ort
y
of
the
no
de

in
to
an
edge
of
G

connecting
the
p
ort
x
of
M()
to
the
p
ort
y
of
M(),
with
the
additional
requiremen
t
that,
when

is
a
m
ux
and
x
one
of
its
auxiliary
p
ort,
the
name
and
oset
pairs
of
the
p
ort
x
of

and
of
the
p
ort
x
of
M()
coincide.
Denition
..
(sharing
morphism)
A
mapping
M
b
et
w
een
the
edges
and
the
no
des
of
t
w
o
graphs
G

and
G

is
a
sharing
morphism,
de-
noted
M
:
G


G

,
if
it
is
a
surjectiv
e
homom
orphism
b
et
w
een
G

and
G

preserving
the
t
yp
e
of
the
no
des,
their
index/threshold,
the
name
of
eac
h
p
ort,
and
the
osets
of
the
auxiliary
p
orts
of
m
uxes
and
v
-no
des.
By
the
previous
denition,
only
m
uxes
and
v
no
des
ma
y
c
hange
their
cardinalit
y
under
the
application
of
M
(remind
that
t
w
o
auxiliary
p
orts
of
a
v
no
de
with
the
same
oset
are
indistinguishable).
The

and
@
no
des
ha
v
e
in
fact
a
xed
distinct
set
of
p
orts.
An
yho
w,
since
M
is
surjectiv
e,
for
an
y
auxiliary
p
ort
of
a
m
ux

of
G

,
there
is
at
least
an


M
-
()
with
a
p
ort
yielding
the
same
name/oset.
Consequen
tly
,
if
G

con
tains
a
deadlo
c
k,
also
G

do
es.
The
con
v
erse
is
instead
not
true.
In
fact,
assume
that
G

con
tains
a
k-ary
m
ux
annihilating
pair.
F
or
an
y
function
f
=
f;
:
:
:
;
kg
!
f;
:
:
:
;
kg,
there
is
a
corresp
onding
w
a
y
to
build
a
sharing
morphism
M
b
et
w
een
the
t
w
o
pairs,
but
among
these,
w
e
do
not
get
an
immedia
te
deadlo
c
k
only
c
ho
osing
f
equal
to
the
iden
tit
y
.
As
a
consequence
of
the
previous
example,
w
e
can
infer
that
sharing
morphisms
are
not
y
et
enough
to
dene
the
partial
order
.
Or
more
precisely
that,
in
order
to
get
a
unique
completely
unshared
represen
ta-
tion
(i.e.,
con
taining
unary
m
uxes
only)
of
a
sharing
graph
G,
w
e
m
ust
restrict
the
class
of
the
sharing
graphs,
at
least
to
deadlo
c
k-free
ones.
An
example
of
sharing
morphism
has
b
een
dra
wn
in
Figure
..
Both
the
graphs
represen
t

=
x:
y:
(x
(x
y)).
If
U
is
the
graph
on
the
left
and
G
the
one
on
the
righ
t,
it
is
in
tuitiv
e
that
U
m
ust
b
e
a
less-shared
represen
tation
of
G,
since
b
oth
the
graphs
represen
t
the
same
-term

.
Sharing
morphisms

v
λ
λ
@
@
v
0
0
a
b
a
b
0
0
-1
-1
0
0
1
1
0
0
α
α
β
β
@
λ
λ
v
v
0
0
a
b
a
b
0
0
0
0
-1
-1
1
α
β
1
0
1
Fig.
..
Sharing
morphism.
and
G
is
more
compact
than
U;
moreo
v
er,
U
is
not
shared
at
all,
for
all
the
m
uxes
in
it
are
unary
.
As
a
matter
of
fact,
U

G
via
the
sharing
morphism
mapping
the
m
uxes
with
name
/
in
U
to
the
m
ux
with
name
/
in
G
and
the
t
w
o
applications
in
U
to
the
unique
application
in
G
(the
other
corresp
ondences
follo
w
b
y
denition
of
graph
morphism).
Ev
en
if
the
m
uxes
in
U
are
unary
(also
called
lifts
later)
and
do
not
in
tro
duce
an
y
sharing,
there
is
a
tigh
t
relation
b
et
w
een
the
unary
m
uxes
in
U
and
the
binary
m
uxes
in
G,
for
the
unary
m
uxes
mark
the
b
ound-
aries
of
sharable
parts
of
U.
In
some
sense,
the
compact
represen
tation
G
corresp
onds
to
the
sup
erp
osition
of
the
sharable
parts
denoted
in
U
b
y
the
m
uxes
surrounding
the
@-no
des.
This
consideration
is
crucial
for
the
follo
wing
analysis.
Hidden
b
ehind
the
sim
ulation
prop
erties
that
w
e
will
pro
v
e
in
the
next
sections
(Lemma
..
and
Lemma
..)
there
is
the
idea
that
an
y
reduction
of
G
corresp
onds
to
mo
v
e
or
create
shar-
ing
b
oundaries
in
some
pr
op
er
unshared
represen
tation
U
of
G;
where
prop
er
means
that
U
has
some
p
eculiar
prop
erties
with
resp
ect
to
an
arbitrary
unfolding
of
G.
In
other
w
ords,
since
not
all
the
U
0

G
are
correct,
sa
y
prop
er,
the
sim
ulation
prop
erties
are
ensured
only
when
w
e
restrict
to
prop
er
sharing
morphisms.
F
or
instance,
the
graph
U
0
in
Figure
.,
and
man
y
others
could
b
e


R
e
ad-b
ack
v
λ
λ
@
v
0
0
a
0
0
-1
1
0
0
α
1
@
b
a -1
0
1
α
β
@
b
a
b
-1
0
0
1
α
β
β
0
Fig.
..
An
unsharing
of
G
that
is
not
prop
er.
giv
en,
is
obtained
b
y
unfolding
G;
there
is
in
fact
a
sharing
morphism
U
0

G.
In
spite
of
this,
U
0
cannot
b
e
tak
en
as
a
prop
er
unsharing
of
G,
for
it
cannot
b
e
a
represen
tation
of

(ev
en
if
w
e
do
not
kno
w
y
et
ho
w
to
asso
ciate
a
-term
to
a
sharing
graph,
at
least
formally;
w
e
can
sa
y
that
the
in
terpretation
of
G
m
ust
b
e

for
G


).
Moreo
v
er,
w
e
could
easily
see
that
U
0
is
not
deadlo
c
k-free.
In
some
sense,
the
b
oundaries
of
the
sharable
parts
in
U
0
are
inconsisten
t.
The
k
ey
p
oin
t
of
the
algebraic
seman
tics
(section
.)
will
b
e
to
giv
e
the
to
ols
for
deciding
prop
erness,
that
is,
to
ensure
that
in
an
unshared
graph
the
b
oundaries
of
sharable
parts
are
consisten
t.
Exercise
..
V
erify
that
b
oth
the
graphs
in
Figure
.
normalize
to
the
-tree
of

(see
Figure
.),
and
that
the
graph
in
Figure
.
is
not
deadlo
c
k-free.

.
Sharing
morphisms

v
λ
λ
v
0
0
0
0
0
-1
1
1
@
@ 2
Fig.
..

=
x:
y:
(x
(x
y))
..
Simulation
lemma
The
study
of
deadlo
c
k-freeness
rests
on
the
analysis
of
the
case
in
whic
h
all
the
m
uxes
are
unary
.
The
results
obtained
for
this
case
will
then
b
e
generalized
exploiting
the
previously
remark
ed
fact
that
sharing
mor-
phisms
preserv
e
deadlo
c
k-freeness
(i.e.,
G
do
es
not
con
tain
deadlo
c
k
ed
redexes
when
M
:
U

G
and
U
do
es
not
con
tain
deadlo
c
k
ed
redexes).
First
some
terminology:
a
p
ositiv
e
(negativ
e)
lift
is
a
unary
(negativ
e)
m
ux;
a
sharing
graph
U
is
said
unshar
e
d
if
all
its
m
uxes
are
lifts;
suc
h
a
U
is
said
an
unshar
e
d
instanc
e
of
G,
if
M
:
U

G.
The
relev
an
t
p
oin
t
is
that
an
y
reduction
of
G
corresp
onds
to
a
reduc-
tion
of
a
deadlo
c
k-free
U,
whenev
er
U

G.
Lemma
..
(sim
ul
ati
on:
)
L
et
U
b
e
a
de
ad
lo
ck-fr
e
e
unshar
e
d
gr
aph
and
let
M
:
U

G.
F
or
any
r
:
G
!

G

ther
e
exist
a
c
orr
e-
sp
onding
non-empty
r
e
duction

:
U
!

U

and
a
sharing
morphism
M

:
U


G

.
Summarizing
in
a
diagr
am:
U

+



M
G

r

U


M

G

Pr
o
of
W
e
will
sho
w
ho
w
to
build
the
reduction
;
then,
giv
en
,
the
denition
of
the
sharing
morphism
M

is
trivial
and
it
is
left
as
an
exercise.
Let
r
=
(

;


),
and
let
(
0

;

0

)
and
(
00

;

00

)
b
e
t
w
o
redexes
s.t.
M(
0
i
)
=
M(
00
i
)
=

i
,
for
i
=
;
.
If

0

=

00

implies

0

=

00

,


R
e
ad-b
ack
then
M
-
(r)
do
es
not
con
tain
critical
pairs
and
the
reduction

is
an
y
of
the
p
ossible
ordered
sequences
of
the
redexes
M
-
(r).
Otherwise,


is
a
v
no
de
and


p
oin
ts
to
one
of
its
auxiliary
p
orts;

0

=

00

=

is
a
v
no
de;
and

0

;

00

p
oin
t
to
t
w
o
distinct
auxiliary
p
orts
of

with
the
same
oset
(remind
that
v
no
des
are
the
only
ones
that
can
ha
v
e
t
w
o
indistinguishable
p
orts).
F
urthermore,
since
U
is
deadlo
c
k-free
and

0

and

00

ha
v
e
the
same
threshold,
the
auxiliary
p
orts
of

0

and

00

ha
v
e
the
same
name-oset
pair
(a;
q).
If
r
is
an
absorption,
w
e
conclude
just
absorbing
in
an
y
order
all
the
m
uxes
in
M
-
().
So,
let
us
assume
that
r
is
a
propagation
rule.
F
or
an
y

s.t.
M()
=


,
let
R

=
f(;
)
j
M()
=


g
(b
y
the
w
a
y
,
M
-
(r)
=
S

R

).
Let
us
use
R

also
to
denote
the
transformation
that
sim
ultaneously
propagates
all
the
lifts

in
the
set
of
redexes
R

through
the
v
no
de
.
Namely
,
the
reduction
R

:
(i
)
increases
b
y
q
the
index
of
;
(ii
)
remo
v
es
eac
h
lift

directly
connecting
its
auxiliary
p
ort
to
the
corresp
onding
auxiliary
p
ort
of
;
(iii
)
inserts
a
cop
y

0
of

b
et
w
een
an
y
auxiliary
p
ort
of

that
did
not
in
teract
with
a
m
ux
.
F
or
an
y
of
suc
h
transformation
R

there
is
a
corresp
onding
-reduction


with
the
same
result.
The
transformations
R

do
not
form
critical
pairs.
Hence,
w
e
can
tak
e

:
U


U

s.t.
U

is
obtained
applying
in
an
y
order
the
transformations
R

,
that
is,
concatenating
in
an
y
order
the
reductions


.
In
the
previous
lemma,
the
reduction
of
U
sim
ulating
the
reduction
of
G
is
not
empt
y
.
Therefore,
whenev
er
the

rules
strongly
normalize
U,
they
strongly
normalize
G
to
o.
Prop
osition
..
L
et
G
b
e
a
sharing
gr
aph
with
a
de
ad
lo
ck-fr
e
e
un-
shar
e
d
instanc
e
U,
i.e.,
M
:
U

G
for
some
sharing
morphism
M.
The
sharing
gr
aph
G
is
de
ad
lo
ck-fr
e
e
and,
when
U
has
no
innite

r
e
duction:
(i)
the

rules
str
ongly
normalize
G;
(ii)
the

normal-form
of
G
is
unique
and
mux
fr
e
e.
Pr
o
of
The
rst
item
is
a
direct
consequence
of
Lemma
...
The
second
follo
ws
from
the
fact
that
the
unique

normal-form
of
U
do
es
not
con
tain
m
uxes
(b
y
the
denition
of
deadlo
c
k-freeness
and
Lemma
..)
and
Lemma
...
Exercise
..
V
erify
the
results
pro
v
ed
in
this
section
on
the
sharing
graphs
in
Figure
..
In
particular,
v
erify
the
sim
ulation
prop
ert
y
of
-rules.

.
Unshar
e
d
b
eta
r
e
duction
	
.
Unshared
b
eta
reduction
Though
w
e
ha
v
e
to
w
ait
section
.
to
get
a
go
o
d
denition
of
prop
er-
ness
(i.e.,
indep
enden
t
from
the
reduction),
Prop
osition
..
states
the
minima
l
requiremen
ts
that
an
y
prop
er
unsharing
of
G
is
lik
ely
to
ha
v
e.
Then,
in
order
to
an
ticipate
the
relev
an
t
results
on
-rules,
let
us
dene
prop
er
sharing
graphs
via
the
syn
tactic
prop
erties
w
e
w
ould
lik
e
they
hold.
Later,
in
section
..,
w
e
will
ev
en
tually
see
that
this
syn
tactical
denition
is
equiv
alen
t
to
the
seman
tical
one.
Denition
..
A
sharing
graph
G
is
pr
op
er
if
it
is
deadlo
c
k-free
and
its
-normal
form
R(U)
is
a
-tree.
Both
the
sharing
graphs
in
Figure
.
are
prop
er.
Exercise
..
Let
J

K
b
e
the
partial
map
that
asso
ciates
a
-tree
T
to
an
unshared
graph
U
b
y:
(i)
replacing
the
lifts
of
U
b
y
direct
connections
b
et
w
een
their
p
orts;
(ii)
reindexing
T
according
to
the
rules
in
Figure
..
(This
map
is
partial
since
T
could
not
b
e
the
abstract
syn
tax
tree
of
a
-term.
In
fact,
after
remo
ving
the
v
-
binding
connections,
w
e
ha
v
e
to
c
hec
k
whether
T
is
a
tree,
and
whether
the
binding
connections
are
correct.)
Pro
v
e
that
if
U
is
prop
er,
then
JUK
=
R(U).
(Hint:
By
induction
on
a
normalizing

reduction
of
U.)
The
previous
exercise
p
oin
ts
out
that
a
prop
er
unshared
graph
U
is
a
-tree
apart
for
some
lifts
and
for
the
indexes
of
its
no
des.
The
lifts
of
an
unshared
instance
G
ha
v
e
in
fact
no
sharing
eect,
they
rather
delimit
subgraphs
that
are
shared
in
G.
More
precisely
,
giv
en
an
unshared
graph
U
represen
ting
the
-tree
T
=
JUK,
the
lifts
of
U
restrict
the
p
ossible
shared
represen
tations
of
T
xing
the
p
oin
ts
in
whic
h
sharing
ma
y
tak
e
place
(see
again
the
examples
in
Figure
.
and
Figure
.).
According
to
the
previous
syn
tactical
denition,
prop
erness
is
triv-
ially
preserv
ed
b
y
-rules;
and
ob
viously
,
this
will
b
e
the
case
also
for
the
seman
tical
denition
of
prop
erness
that
w
e
will
giv
e
in
section
..
Nev
ertheless,
in
the
seman
tical
approac
h,
this
in
v
ariance
will
not
b
e
trivial
an
ymore;
on
the
con
trary
,
it
will
b
e
the
k
ey
p
oin
t
to
b
e
pro
v
ed.
The
next
issue
is
to
pro
v
e
that
the
-rule
preserv
es
prop
erness.
Unfor-
tunately
,
the
pro
of
of
this
fact
is
not
straigh
tforw
ard
and
the
syn
tactical
denition
do
es
not
help
at
all.
Indeed,
this
is
the
reason
b
ecause
of
whic
h
w
e
will
need
a
denition
of
prop
erness
that
do
es
not
men
tion
-reduction.

0
R
e
ad-b
ack
In
addition,
-rule
in
tro
duces
another
obstacle
to
our
plan
to
study
the
unshared
case
rst.
The
p
oin
t
is
that
unshared
graphs
are
closed
under
-reduction
only
in
the
case
of
linear
-terms.
Namely
,
only
if
eac
h
v
ariable
o
ccurs
exactly
once
in
the
b
o
dy
of
its
abstraction
(remind
w
e
are
in
I-calculus).
Therefore,
to
get
a
sim
ulation
prop
ert
y
similar
to
the
one
of
Lemma
..
w
e
ha
v
e
to
dene
an
unshared
v
ersion
of
-rule,
sa
y

u
-rule,
that
do
es
not
in
tro
duce
k-ary
m
uxes,
see
Figure
.
(note
that,
since
there
is
no
pro
viso
on
the
names
in
tro
duced
b
y
a

u
-rule,
distinct
lifts
migh
t
ha
v
e
the
same
name).
i
q k
q 1
λ
@ i
i
v
S
T
k
a
k
q
a 1
1
q
i
i
T
T
S
βu
Fig.
..
Unshared
-rule.
The

u
-rule
splits
the
reindexing
and
duplication
task
of
m
uxes:
the
duplication
in
em
b
o
died
in
to
the
rule;
the
reindexing
is
instead
de-
manded
to
the
propagation
of
lifts
(see
Prop
osition
..).
This
can
b
e
seen
in
more
detail
lo
oking
at
the
linear
case.
In
that
case
w
e
w
ould
not
need
an
y
particular
implemen
tati
on
of
sharing.
Nev
ertheless,
the
-rule
of
Figure
.0
w
ould
in
tro
duce
a
lift
to
tak
e
in
to
accoun
t
that
w
e
ha
v
e
to
c
hange
the
indexes
in
the
tree
of
the
argumen
t
of
the
-redex.
The
follo
wing
propagations
of
lifts
do
not
cause
an
y
duplication,
they
simply
set
the
righ
t
v
alues
of
that
indexes.
Prop
osition
..
L
et
T
b
e
a
pr
op
er
unshar
e
d
gr
aph.
If
T
!

u
T
0
and
T
0
is
pr
op
er,
then
R(T
)
!


R(T
0
).
Pr
o
of
Using
the
notation
and
the
result
of
Exercise
..,
w
e
see
that
JT
K
!


JT
0
K
(b
y
insp
ection
of
the

u
-rule)
and
then
that
R(T
)
!


R(T
0
).
The
usefulness
of

u
-rule
is
connected
to
the
pro
of
of
soundness
of
shared
-rule.
The
k
ey
relation
b
et
w
een
the
t
w
o
rules
is
established
b
y

.
Paths

the
p
ossibilit
y
to
sim
ulate
a
-reduction
b
y
a
sequence
of

u
-reductions
in
the
unshared
graph.
Lemma
..
(sim
ul
ati
on:
)
L
et
T
b
e
a
pr
op
er
unshar
e
d
gr
aph
and
let
M
:
T

G.
F
or
any
r
:
G
!

G

ther
e
exist
a
c
orr
esp
onding
non-
empty
r
e
duction

:
T
!

u
T

,
and
a
sharing
morphism
M

:
T


G

.
Summarizing
in
a
diagr
am:
T

u
+



M
G

r

T


M

G

Pr
o
of
In
the
usual
w
a
y
w
e
can
dene
a
man
y-to-one
relation
s.t.
e

!
e
0
when
e
is
an
edge
of
T
,
e
0
is
an
edge
of
T
0
,
T


u
T
0
,
and
e
0
is
a
residual
of
e;
and
analogously
for

s
.
Suc
h
a
relation
immediately
extend
to
redexes
and,
b
eing
R
=
fr
0
j
M(r
0
)
=
rg
the
redexes
of
T
whose
image
in
G
is
the
redex
r;
the
reduction

is
an
y
complete
dev
elopmen
t
of
the
set
of
redexes
R.
(That
is,
T

do
es
not
con
tain
an
y
redex
r

s.t.
r
0

!
r

for
some
r
0

R.
It
is
also
easy
to
see
that
this
denition
is
sound
since

u
has
a
nite
dev
elopmen
t
prop
ert
y
similar
to
the
one
of


.)
F
or
an
y
edge
e
0
t
of
T

w
e
ha
v
e
a
unique
edge
e
t
of
T
s.t.
e
t

!
e
0
t
.
F
urthermore,
there
is
a
unique
edge
e
0
g
of
G

s.t.
M(e
u
)
!
e
0
g
.
Let
us
tak
e
M

(e
0
u
)
=
e
0
g
.
It
is
not
dicult
to
c
hec
k
that
M

is
a
sharing
morphism.
W
e
left
to
pro
v
e
that

u
preserv
es
prop
erness,
but
for
this
w
e
need
the
algebraic
material
that
w
e
are
going
to
in
tro
duce.
.
P
aths
In
Chapter

w
e
ha
v
e
seen
sev
eral
notions
of
paths.
The
purp
ose
of
all
of
them
w
as
to
c
haracterize
the
(virtual)
redexes
of
a
sharing
graph.
Here,
as
already
done
for
Lamping's
prop
er
paths,
w
e
restrict
to
the
paths
allo
wing
to
reco
v
er
the
read-bac
k
of
a
sharing
graph
G,
that
is,
to
the
paths
connecting
the
ro
ot
of
G
to
its
v
no
des,
follo
wing
the
usual
syn
tax
tree
orien
tation.
Let
(U)
b
e
the
set
of
the
orien
ted
paths
starting
from
the
ro
ot
of
U
and
crossing
the
no
des
according
to
the
arro
ws
in
Figure
.
(the
last
t
w
o
no
des
are
a
p
ositiv
e
and
a
negativ
e
lift,
resp
ectiv
ely).
Let
us
assume


R
e
ad-b
ack
λn
v
1
k
q
q
n
q
a
i
q
a
i
n
@
Fig.
..
P
aths.
that
JUK
is
a
-tree.
The
unshared
graph
U
is
completely
c
haracterized
b
y
(U).
In
fact,
an
y
no
de
u
of
U
has
an
ac
c
ess
p
ath
eu

(U),
where
e
is
the
edge
connected
to
the
top
p
ort
of
u
(according
to
the
orien
tation
in
Figure
.).
Suc
h
an
access
path
is
unique
for
all
the
no
des
but
the
v
ones,
whic
h
ha
v
e
a
path
for
eac
h
o
ccurrence
of
the
corresp
onding
v
ariable|that
is,
for
eac
h
input
edge.
F
urthermore,
for
an
y
o
ccurrence
of
a
v
ariable,
there
is
a
cycle
 e,
where

is
the
binder
of
the
v
ariable,
e
is
a
binding
edge
(the
edge
en
tering
in
to
the
binding
p
ort
of
),
and
an
y
path
 
0
e
is
a
maxim
al
path
of
(U)
(note
that
in
Figure
.
there
is
no
arro
w
from
the
binding
edge
of
a

no
de
to
an
y
other
edge).
Notation
..
As
already
done
in
the
last
paragraph,
ev
en
if
a
path
is
a
sequence
of
edges,
w
e
will
sometimes
do
explicit
some
of
the
no
des
crossed
b
y
it.
In
particular,
w
e
will
use:
u
to
mean
that
u
is
the
last
no
de
of
;

=
 e
to
mean
that
e
is
the
last
edge
of
;

=
 eu
to
explicit
b
oth
the
last
edge
and
no
de
of
;
and
so
on.
The
meaning
will
alw
a
ys
b
e
clear
since
w
e
will
use
the
(indexed)
letter
e
for
edges,
and
the
(indexed)
letters
u,
v
,
@
and

for
the
no
des;
in
particular,
,
@
and
v
will
alw
a
ys
denote
a
no
de
of
the
corresp
onding
t
yp
e.
Assuming
that
in
Figure
.
the
last
t
w
o
no
des
are
resp
ectiv
ely
a
p
ositiv
e
and
negativ
e
m
ux,
the
previous
denition
of
path
extends
to
shared
graphs
to
o.
Also
in
this
case
(G)
is
a
tree,
but,
since
a
sharing
graph
ma
y
con
tain
cycles,
(G)
can
b
e
innite
(for
instance,
the
sharing
graph
on
the
righ
t-hand
side
of
Figure
.
has
an
innite
unfolding).
Besides,
there
is
no
more
a
natural
isomorphism
b
et
w
een
the
graph
and
the
set
of
its
paths.
Sharing
morphisms
also
relate
paths.
In
fact,
giv
en
a
sharing
mor-
phism
M
:
U

G,
there
is
a
corresp
onding
path
morphism
M
:
(U)

(G).
This
suggests
that
in
order
to
nd
the
prop
er
unsharings
of
G,
w
e
need
to
x
a
subset
(G)
of
the
paths
(G)|the
pr
op
er
p
aths
of
G|in
v
arian
t
under
sharing
morphisms.
Namely
,
(G
0
)
and
(G)
are

.
A
lgebr
aic
semantics

isomorphic
(written
(G
0
)
'
(G)),
whenev
er
M
:
G
0

G.
In
particu-
lar,
as
it
is
lik
ely
that
an
y
path
of
a
prop
er
unshared
graph
b
e
prop
er,
the
natural
prop
ert
y
of
(G)
should
b
e
that
(U)
'
(G)
for
an
y
prop
er
unshared
instance
of
G.
This
corresp
onds
indeed
to
require
the
unique-
ness
of
the
prop
er
unshared
instance
of
G,
b
ecause
an
y
unshared
graph
is
isomorphic
to
the
set
of
its
paths.
The
denition
of
prop
er
paths
(section
.)
will
b
e
giv
en
follo
wing
the
tec
hniques
used
to
dene
Lamping's
prop
er
paths
in
section
..
An
yho
w,
the
w
a
y
in
whic
h
the
dynamic
algebra
is
used
here
is
sligh
tly
dieren
t.
In
particular,
w
e
ha
v
e
to
reform
ulate
some
of
the
algebraic
material.
.
Algebraic
seman
tics
Let
us
assume
to
ha
v
e
an
unshared
graph
U.
F
or
an
y
edge
of
U,
w
e
w
an
t
to
nd
a
renaming
function
b
y
whic
h
to
compute
the
actual
lev
els
of
the
no
des
of
U.
The
idea
is
that
eac
h
no
de
corresp
ond
to
a
relation
relate
b
et
w
een
the
renaming
functions
yielded
b
y
the
edges
inciden
t
to
it.
In
particular,
the
in
tended
in
terpretation
of
a
lift
should
then
b
e
an
op
erator
increasing
b
y
its
oset
the
indexes
ab
o
v
e
its
threshold.
Denition
..
(liftin
g
op
erator)
A
lifting
op
er
ator,
where
m;
q;
a

Z
,
and
m

0,
q

-,
is
an
indexed
transformation
L[m;
q;
a]
of
a
do-
main
D
.
The
follo
wing
axiom
hold
for
an
y
m,
and
an
y
q
i
;
a
i
;
d
i
,
with
i
=
;
:
(LO)
L[m;
q

;
a

](d

)
=
L[m;
q

;
a

](d

)
implies
q

=
q

^
a

=
a

^
d

=
d

furthermore,
for
an
y
m

<
m

,
(LO)
L[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

;
q

;
a

]
L[m

+
q

;
q

;
a

]
(LO)
L[m

;
q

;
a

](d

)
=
L[m

;
q

;
a

](d

)
i
	
d
:
L[m

+
q

;
q

;
a

](d)
=
d

^
L[m

;
q

;
a

](d)
=
d

The
index
m
is
the
(lifting)
thr
eshold
of
L[m;
q;
a],
the
index
q
is
its
(lifting)
oset,
and
the
index
a
is
its
p
ort
name.
Lifting
op
erators
are
the
in
tended
in
terpretation
of
lifts.
The
idea
is
that
an
y
edge
of
an
unshared
graph
U
is
in
the
scop
e
of
a
set
of
lifts:
the
ones
that
should
cross
the
edge
normalizing
U.
Assuming
that
lifting


R
e
ad-b
ack
op
erators
giv
e
a
comp
ositional
seman
tics
for
lifts,
w
e
exp
ect
that
the
reindexing
op
erator
asso
ciated
to
an
edge
b
e
a
pro
duct
of
them,
sa
y
a
lifting
se
quenc
e,
in
whic
h
there
is
a
factor
for
an
y
lift
con
taining
the
edge
in
its
scop
e.
Before
to
go
on,
let
us
note
that
lifts,
and
then
lifting
op
erators,
are
indeed
something
more
than
renaming
functions.
The
rst
reason
is
that
w
e
ha
v
e
to
k
eep
trac
k
of
their
matc
hing.
The
second
problem
is
that,
assuming
to
mo
v
e
along
a
path,
at
a
negativ
e
lift
w
e
ha
v
e
to
restore
the
names
that
where
in
act
at
the
matc
hing
p
ositiv
e
lift;
more
formally
,
a
lifting
op
erator
m
ust
b
e
at
least
left
in
v
ertible.
T
o
clarify
the
latter
p
oin
t
let
us
try
to
in
terpret
a
lifting
op
erators
as
in
teger
functionals.
Namely
,
let
us
assume
D
=
Z
Z
and
JL[m;
q;
a]
K
=

m;q
where

m;q
(f)(i)
=

f(i)
when
i

m
f(i
+
q)
otherwise
The
in
teger
lifting
functionals
ha
v
e
a
comm
utativ
e
prop
ert
y
analog
to
the
one
of
lifting
op
erators
in
axioms
(LO)
and
(LO).
Exercise
..
Pro
v
e
that,
for
an
y
q

;
q


-,

m

;q


m

;q

=

m

;q


m

+q

;q

and
that

m

;q

(f)
=

m

;q

(g)
i
	(h)(
m

;q

(h)
=
g
^

m

+q

;q

(h)
=
f)
when
m

<
m

.
One
of
the
reasons
b
ecause
of
whic
h
suc
h
an
in
terpretation
is
inad-
equate
is
that
axiom
(LO)
fails,
that
is,
w
e
do
not
ha
v
e
a
correct
al-
gebraic
enco
ding
of
the
annihilation
rule,
for
the
functional

m;q
is
not
injectiv
e.
Suc
h
a
naiv
e
in
terpretation,
ev
en
if
not
completely
satisfac-
tory
,
is
ho
w
ev
er
helpful
for
the
in
tuitiv
e
understanding
of
the
b
eha
vior
of
lifts.
F
or
instance,
a
lifting
in
teger
functional
compress
the
names
b
et
w
een
m
and
m
+
q
(let
us
assume
q

0)
in
to
the
range
m
and
m
+

and,
since
w
e
are
in
Z
Z
,
the
v
alues
in
ternal
to
the
range
are
lost.
The
latter
reasoning
on
the
range
in
whic
h
a
lifting
op
erator
acts
extends
to
lifting
sequences
to
o.
Unfortunately
,
the
corresp
onding
for-
malization
requires
a
rather
tec
hnical
condition,
w
e
hop
e
that
some
ex-
planation
on
its
meaning
will
b
e
giv
en
b
y
Exercise
...

.
A
lgebr
aic
semantics

Denition
..
A
lifting
se
quenc
e
from
n
0
to
n

,
with
n
0

n

,
is
a
pro
duct
of
lifting
op
erators
H
=
Y
0<ik
L[m
i
;
q
i
;
a
i
]
in
whic
h,
for
i
=
;
;
:
:
:
;
k,
n
0

m
i
<
n

+
X
0<j<i
q
j
:
The
set
LSeq
[n
0
;
n

]
is
the
family
of
the
lifting
sequences
from
n
0
to
n

.
In
particular,
assuming
n

=
!
w
e
get
the
family
LSeq
[n
0
;
!]
of
the
lifting
sequences
H
for
whic
h
m
i

n
0
.
Then,
LSeq
=
LSeq
[0;
!]
is
the
family
of
all
the
lifting
sequence.
By
insp
ection
of
the
denition,
w
e
also
see
that
LSeq
[n
0
;
n

]

LSeq
[m
0
;
m

],
when
m
0

n
0

n


m

.
Therefore,
if
w
e
w
an
t
to
c
haracterize
the
range
of
indexes
on
whic
h
a
lift-
ing
op
erator
F
w
orks
w
e
ha
v
e
to
c
ho
ose
n
0
and
n

s.t.
F

LSeq
[m
0
;
m

]
implies
m
0

n
0
and
m


n

.
Exercise
..
Let
F

LSeq
[n
0
;
n

].
If
Q
is
the
sum
of
the
osets
of
the
lifting
op
erators
in
F
,
pro
v
e
that
JF
K(f)(i)
=

<
:
f(i)
when
i

n
0
f
0
(i)
when
n
0
<
i
<
n

f(i
+
Q)
when
i

n

for
some
f
0

Z
Z
.
..
L
eft
inverses
of
lifting
op
er
ators
Lifting
sequences
are
injectiv
e
transformations
of
D
:
they
are
the
comp
o-
sition
of
injectiv
e
op
erators
(remind
axiom
(LO)).
Hence,
eac
h
lifting
sequence
F
has
a
non
unique
left
in
v
erse
F

that
ma
y
assume
an
y
v
alue
outside
of
the
co
domain
of
F
.
An
yho
w,
if
w
e
consider
partial
functions
to
o,
the
natural
c
hoice
for
F

is
the
less
dened
partial
transformation
s.t.
F
F

F
=
F
,
i.e.,
s.t.
dom(F

)
=
co
dom(F
)
and
F

(F
(d))
=
d,
for
an
y
d

dom(F
).
In
particular,
dened
L[m;
q;
a](d)
=


d
when
d
=
L[m;
q;
a](

d
)
?
when
d

co
dom
(L[m;
q;
a])


R
e
ad-b
ack
where
L[m;
q;
a](d)
=?
is
just
a
denotation
for
d

dom(L[m;
q;
a]),
w
e
ha
v
e
L[m;
q;
a]

=
L
[m;
q;
a]
e
L[m;
q;
a]
=
(
e
L
[m;
q;
a]

)

(
e
L
[m

;
q

;
a

]



e
L
[m
k
;
q
k
;
a
k
])

=
e
L
[m
k
;
q
k
;
a
k
]




e
L[m

;
q

;
a

]

where
e
L[m
i
;
q
i
;
a
i
]
stands
for
either
L[m
i
;
q
i
;
a
i
]
or
L
[m
i
;
q
i
;
a
i
]
Lifting
op
erators
and
their
left
in
v
erses
form
a
monoid
of
injectiv
e
partial
transformations
of
D
closed
under
left
in
v
ersion.
F
urthermore,
the
axioms
of
the
lifting
op
erators
can
b
e
reform
ulated
using
the
left
in
v
erse
op
eration.
Exercise
..
Pro
v
e
that
the
axioms
of
Denition
..
are
equiv
alen
t
to
the
axioms:
L[m;
q;
a]
L[m;
q;
a]
=

L[m;
q

;
a

]
L[m;
q

;
a

]
=
0
for
an
y
m;
q,
and
q

=
q

or
a

=
a

;
L[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

;
q

;
a

]
L[m

+
q

;
q

;
a

]
L
[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

;
q

;
a

]
L
[m

+
q

;
q

;
a

]
for
an
y
q

;
q

,
a

;
a

,
when
m

<
m

.
By
the
w
a
y
,
also
the
dual
prop
erties
of
the
last
p
erm
utation
rules
hold:
L
[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

+
q

;
q

;
a

]
L
[m

;
q

;
a

]
L
[m

;
q

;
a

]
L
[m

;
q

;
a

]
=
L[m

+
q

;
q

;
a

]
L
[m

;
q

;
a

]
where
m

<
m

.
..
The
inverse
semigr
oup
LSeq

Let
us
remind
the
denition
and
the
main
prop
ert
y
of
in
v
erse
semi-
groups
(see
section
..).
An
inverse
semigr
oup
M
with
a
n
ull
elemen
t
0
s.t.
0F
=
0
=
F
0,
for
an
y
F
,
is
a
monoid
closed
under
an
in
v
olution
op
eration
()

s.t.,
for
an
y
F
;
F

;
F


M,
F

=
F
(F

F

)

=
F


F


hF
iF
=
F
hF

ihF

i
=
hF

ihF

i

.
A
lgebr
aic
semantics

where
hF
i

F
F

.
F
rom
these
axioms
w
e
can
pro
v
e
that
F
is
an
idemp
oten
t
i
F
=
hF
i
and
that
for
an
y
idemp
oten
t
F
w
e
ha
v
e
F
=
F

.
That
in
particular
implies


=

and
0

=
0.
Denition
..
(LSeq

)
The
in
v
erse
semigroup
LSeq

is
the
small-
est
in
v
erse
semigroup
generated
b
y
the
family
of
the
indexed
sym
b
ols
L[m;
q;
a]
and
of
their
left
in
v
erse
sym
b
ols
L[m;
q;
a]
(b
eing
m

0
and
q

-)
according
to
the
axioms
(LS0)
L[m;
q;
a]

=
L
[m;
q;
a]
(LS)
L
[m;
q;
a]
L[m;
q;
a]
=

(LS)
L
[m;
q

;
a

]
L[m;
q

;
a

]
=
0
if
q

=
q

or
a

=
a

(LS)
L[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

;
q

;
a

]
L[m

+
q

;
q

;
a

]
(LS)
L[m

;
q

;
a

]
L[m

;
q

;
a

]
=
L[m

;
q

;
a

]
L
[m

+
q

;
q

;
a

]
when
m

<
m

.
The
monoid
LSeq
is
instead
the
smallest
monoid
LSeq

LSeq

con-
taining
the
indexed
sym
b
ols
L[m;
q;
a]
(for
an
y
m

0
and
q

-)
and
closed
b
y
comp
osition.
By
the
w
a
y
,
the
in
tended
in
terpretation
of
LSeq

is
the
monoid
gener-
ated
b
y
the
lifting
op
erators
and
b
y
their
left
in
v
erse
partial
functions.
In
fact,
it
is
readily
seen
that:
(i)
The
constan
t
0
is
the
no
where
dened
partial
transformation
of
D
.
(ii)
An
y
idemp
oten
t
hF
i
of
LSeq

is
the
iden
tit
y
map
restricted
to
the
co
domain
of
F
,
i.e.,
dom
(hF
i)
=
co
dom(F
).
(iii)
F
or
an
y
H

LSeq
w
e
ha
v
e
that
H

H
=
hH

i
=
,
since
co
dom(H

)
=
dom
(H)
=
D
.
Also
in
this
case
w
e
ha
v
e
an
AB

theorem.
Lemma
..
F
or
any
F

LSeq

,
F
=
0,
ther
e
exist
H
+
;
H
-

LSeq
s.t.
F
=
H
+
H

-
.
Pr
o
of
By
induction
on
jF
j.
The
case
jF
j
=
0
and
the
case
F
=
L[m;
q;
a]
F

(just
apply
the
induction
h
yp
othesis)
are
direct.
So,
let
us
tak
e
F
=
L[m;
q;
a]
F

.
By
induction
h
yp
othesis,
w
e
get
F
=
L[m;
q;
a]
H
+
H

-
,
with
H
+
;
H
-

LSeq
.
Let
H
+
=
L[m

;
q

;
a

]



L[m
k
;
q
k
;
a
k
]


R
e
ad-b
ack
b
e
in
canonical
form,
and
let
h
b
e
the
rst
index
for
whic
h
m
+
Q
i

m
h
(where
Q
i
=
P
i<h
q
i
),
or
let
h
=
k
+

when
suc
h
an
index
do
es
not
ex-
ist.
Let
H
=
H
0
H

with
H
0
=
L[m

;
q

;
a

]



L[m
h-
;
q
k-
;
a
k-
].
If
m
h
=
m
+
Q
i
,
w
e
ha
v
e
either
q
h
=
q
and
a
h
=
a,
or
not.
In
the
rst
case
L[m;
q;
a]H
+

LSeq
,
in
the
second
L[m;
q;
a]H
+
=
0
and
then
H
=
0.
When
m
h
>
m
+
Q
i
instead,
w
e
see
that
H
=
H
0
H
+q

L[m
+
Q
i
;
q;
a]
H

-
,
where
H
+q

is
the
lifting
sequence
obtained
increasing
b
y
q
all
the
thresh-
olds
in
H

.
The
elemen
ts
of
LSeq

can
then
b
e
written
in
c
anonic
al
form.
In
more
detail,
Axiom
(LS)
allo
ws
to
state
that
an
y
lifting
sequence
can
b
e
written
in
a
canonical
w
a
y
b
y
arranging
it
in
a
pro
duct
of
lifting
op
erators
whose
thresholds
are
non-decreasingly
ordered.
Therefore,
F

H
+
H

-
is
in
canonical
form
only
whenev
er
b
oth
H
+
and
H
-
are
canonical.
Lemma
..
L
et
H
+
;
H
-

LSeq
.
We
have
that
H
+
H

-
=

i
H
+

H
-

.
Pr
o
of
Let
us
assume
H
+
=
L[m;
q;
a]
H
0
.
F
or
an
y
pair
q
0
;
a
0
s.t.
q
=
q
0
or
a
=
a
0
.
W
e
w
ould
get

=
L
[m;
q
0
;
a
0
]
H
+
H

-
L[m;
q
0
;
a
0
]
=
0.
Hence,
H
+

,
etc.
Remark
..	
In
the
latter
lemma
w
e
implicitly
assumed

=
0.
More
precisely
w
e
should
ha
v
e
said
that
the
only
mo
del
in
whic
h
Lemma
..
do
es
not
hold
is
the
trivial
one.
The
same
reasoning
apply
to
the
unique-
ness
of
the
canonical
form
pro
v
ed
b
y
the
next
prop
osition.
Lemma
..0
F
or
any
p
air
H

;
H


LSeq
,
hH

i
=
hH

i
i
H

=
H

.
Pr
o
of
Let
H
+
H

-
b
e
a
canonical
form
of
H


H

.
W
e
ha
v
e

=
H


hH

iH

=
H


hH

iH

=
H


H

(H


H

)

=
H
+
H

-
H
-
H

+
=
H
+
H

+
.
F
rom
whic
h,
w
e
see
(b
y
Lemma
..)
that
H
+
=
.
In
a
similar
w
a
y
w
e
see
that
H
-
=

and
then
that
H


H

=
.
Hence,
H

=
hH

i
H

=
hH

i
H

=
H

.
Prop
osition
..
Two
elements
of
LSeq

ar
e
e
qual
i
their
c
anonic
al
forms
c
oincide.

.
Pr
op
er
p
aths
	
Pr
o
of
Let
H
+
H

-
and
b
H
+
b
H

-
b
e
t
w
o
canonical
forms
of
F

LSeq

.
W
e
ha
v
e
hH
+
i
=
hF
i
=
h
b
H
+
i.
Then,
b
y
Lemma
..0
H
+
=
b
H
+
.
F
rom
whic
h,
H
-
=
b
H
-
to
o.
Hence,
w
e
ma
y
restrict
to
sho
w
the
uniqueness
of
the
canonical
form
of
a
lifting
sequence.
The
case
of

is
pro
v
ed
b
y
F
act
...
So,
let
us
assume
that
L[m

;
q

;
a

]
H

=
L[m

;
q

;
a

]
H

are
b
oth
in
canonical
form
and,
w.l.o.g.,
that
m


m

.
If
m

<
m

,
then
H

=
L[m

+
q

;
q

;
a

]
H
+q


L[m

;
q

;
a

],
that
leads
to
the
con
tradiction
H

L[m

;
q
0

;
a
0

]
=
0
when
q
0

=
q

or
a
0

=
a

.
Hence,
the
only
p
ossibilit
y
is
m

=
m

,
and
then
q

=
q

and
a

=
a

to
o.
Summarizing,
from
the
initial
canonical
forms
w
e
ha
v
e
got
t
w
o
shorter
equiv
alen
t
ones
H

=
H

.
So,
b
y
induction
h
yp
othesis,
w
e
see
that
H

and
H

coincide,
etc.
.
Prop
er
paths
Let
us
no
w
pro
ceed
with
the
original
goal
to
asso
ciate
to
eac
h
edge
the
reindexing
op
erator
corresp
onding
to
the
m
uxes
that
ha
v
e
to
cross
it.
In
this
w
a
y
,
w
e
will
giv
e
t
w
o
new
equiv
alen
t
denitions
of
prop
er
sharing
graphs
based
on
the
algebraic
seman
tics.
Ev
en
tually
,
b
y
Prop
o-
sition
..,
w
e
will
also
sho
w
that
seman
tical
prop
erness
coincides
with
the
syn
tactical
denition
of
prop
er
sharing
graphs
that
w
e
ga
v
e
in
Denition
...
A
lifting
se
quenc
e
assignment
is
a
map
asso
ciating
to
eac
h
edge
of
an
unshared
graph
a
w
eigh
t
F

LSeq
according
to
the
constrain
ts
in
Figure
..
In
particular,
since
the
rst
no
de
of
U
m
ust
alw
a
ys
ha
v
e
an
index
0,
the
constrain
t
on
F
implies
that
the
lifting
sequence
assigned
to
the
ro
ot
is
alw
a
ys
.
F
F
S

F
S
k
F
F

=
L
[m;
q;
a]F

λn
n
@
v
1
k
q
q
n
m
q
a
F
F
F
S
F
F
F

=
L[m;
q;
a]F

Fig.
..
In
all
the
rst
three
cases,
F

LSeq
[0;
n].
In
the
@-no
de
case,
S

LSeq[n;
n
+
].
In
the
v
-no
de
case
S
i

LSeq[n;
n
+
q
i
+
],
for
i
=
;
:
:
:
;
k.
There
are
unshared
graphs
for
whic
h
there
is
no
lifting
sequence
as-
signmen
t
(e.g.,
the
unshared
graph
in
Figure
.).

0
R
e
ad-b
ack
Exercise
..
Pro
v
e
that
an
unshared
graph
con
taining
a
deadlo
c
k
do
es
not
admit
an
y
lifting
sequence
assignmen
t.
Exercise
..
V
erify
that
the
sharing
graphs
in
Figure
.
are
prop
er
(according
to
the
previous
seman
tical
denition).
According
to
the
result
of
the
exercise,
lifting
sequence
assignmen
ts
are
lik
ely
to
b
e
the
algebraic
c
haracterization
of
deadlo
c
k-freeness.
An
yho
w,
b
efore
to
pro
v
e
that|b
y
sho
wing
that
the
existence
of
an
assignmen
t
is
in
v
arian
t
under
unshared
reduction|let
us
analyze
in
more
details
ho
w
to
constructiv
ely
c
hec
k
whether
an
unshared
graph
U
admits
a
lifting
assignmen
t
or
not.
The
constrain
ts
in
Figure
.
can
b
e
orien
ted
according
to
the
orien-
tation
of
the
paths
in
the
tree
(U)
(this
means
that
the
last
constrain
t
in
Figure
.
has
to
b
e
read
top-do
wn
in
the
case
of
a
p
ositiv
e
lift
and
b
ottom-up
in
the
case
of
a
negativ
e
one).
W
e
get
in
this
w
a
y
a
functional
dep
endency
b
et
w
een
the
w
eigh
ts
of
the
edges
corresp
onding
to
the
de-
scendan
t
relation
of
(U).
The
only
cause
of
indeterminacy
remaining
the
parameters
S
in
the
equations
asso
ciated
to
the
@-no
des.
A
state

of
U
is
a
map
asso
ciating
a
lifting
sequence
S
u

LSeq
[n;
n
+
]
to
eac
h
@-no
de
u
of
U,
where
n
is
the
index
of
u.
A
state

is
c
omp
atible
if
there
is
a
lifting
sequence
assignmen
t
s.t.
the
constrain
ts
of
eac
h
@-no
de
u
are
satised
replacing
S
u
for
S
.
The
w
eigh
t
of
an
y
edge
of
U
is
completely
determined
once
xed
a
compatible
state
.
Moreo
v
er,
a
simple
visit
(in
an
y
order)
of
the
tree
(U)
from
its
ro
ot
to
its
v
-no
des
giv
es
a
constructiv
e
pro
cedure
to
decide
if
a
state
is
compatible.
Let
us
b
e
more
precise.
W
e
start
assigning
at
the
ro
ot
the
lifting
sequence
,
and
w
e
pro
ceed
according
to
the
equations
in
Figure
..
This
rst
part
of
the
pro
cedure
ma
y
fail
only
reac
hing
the
principal
p
ort
of
a
negativ
e
lift
with
a
w
eigh
t
H
s.t.
L[m;
q;
a]H

LSeq
,
where
m
is
the
threshold
of
the
lift,
q
its
oset,
and
a
its
p
ort
name.
In
other
w
ords,
b
e-
cause
of
the
prop
erties
of
lifting
sequences,
the
w
eigh
t
asso
ciated
to
the
principal
p
ort
edge
of
a
negativ
e
lift
m
ust
b
e
L[m;
q;
a]H.
Let
us
remark
that
the
latter
requiremen
t
is
the
algebraic
enco
ding
of
the
prop
ert
y
that
for
eac
h
negativ
e
con
trol
no
de
there
m
ust
b
e
a
matc
hing
p
ositiv
e
no
de.
Assuming
that
w
e
do
not
fail
b
ecause
of
a
negativ
e
lift,
w
e
left
to
c
hec
k
the
constrain
ts
on
the
v
-no
des.
A
t
rst
glance,
it
migh
t
seem
that
this
constrain
ts
are
a
source
of
indeterminacy:
for
an
y
edge
en
tering
in
to
a
v
-no
de,
w
e
ha
v
e
a
lifting
sequence
H
that
w
e
w
an
t
to
split
in
the

.
Pr
op
er
p
aths

pro
duct
of
t
w
o
sequences
S

LSeq
[n;
n
+
q
+
]
and
F

LSeq
[0;
n],
where
q
is
the
index
of
the
edge
and
n
the
index
of
the
no
de.
The
next
lemma
ensures
instead
that
the
previous
decomp
osition,
if
an
y
,
is
indeed
unique.
Lemma
..
L
et
n
b
e
an
index
s.t.
n
0

n

n

.
Given
H

LSeq
[n
0
;
n

],
ther
e
is
a
unique
se
ctioning
of
H
(w.r.t.
to
the
index
n)
in
two
lifting
se
quenc
es
H
<n

LSeq
[n
0
;
n]
and
H
n

LSeq
[n;
n

]
s.t.
H
=
H
n
H
<n
.
Pr
o
of
Let
H
=
L[m

;
q

;
a

]



L[m
k
;
q
k
;
a
k
]

LSeq
[n

;
n

]
b
e
in
canonical
form.
Let
h
b
e
the
rst
index
for
whic
h
n
+
Q
i

m
i
(where
Q
i
=
P
i<h
q
i
),
if
an
y
,
otherwise
let
h
=
k
+
.
Let
us
tak
e
H
<n
=
L[m

;
q

;
a

]



L[m
h-
;
q
k-
;
a
k-
]
and
H
n
=
L[m
h
-
Q
h
;
q
h
;
a
h
]



L[m
k
-
Q
h
;
q
k
;
a
k
]:
By
denition,
H
<n

LSeq
[0;
n]
and
H
n

LSeq
[n;
!].
The
denition
of
H
<n
and
H
n
also
pro
v
es
their
uniqueness.
Inciden
tally
,
let
us
note
that
the
previous
lemma
also
implies
that
a
decomp
osition
H
=
S
F
,
with
S

LSeq
[n;
n
+
q
+
]
and
F

LSeq
[0;
n],
is
p
ossible
if
and
only
if
H

LSeq
[0;
n
+
q
+
].
After
the
assignmen
t
phase,
w
e
can
th
us
determine
the
v
alue
of
F
for
an
y
edge
en
tering
in
to
a
v
-no
de.
Only
when
eac
h
of
the
previous
v
alues
is
equal
to
the
lifting
sequence
asso
ciated
to
the
-no
de
binding
the
corresp
onding
v
ariable,
w
e
can
nally
sa
y
that
the
lifting
sequence
assignmen
t
is
correct.
(W
e
in
vite
the
reader
to
compare
this
requiremen
t,
with
the
transparency
prop
ert
y
used
pro
ving
correctness
of
Lamping's
algorithm
in
section
...)
Denition
..
A
sharing
graph
G
is
pr
op
er
if
there
exists
an
un-
shared
graph
U
and
a
sharing
morphism
M
s.t.
M
:
U

G
and
U
admits
a
lifting
sequence
assignmen
t
for
eac
h
in
ternal
state
.
An
y
prop
er
unshared
graph
U
s.t.
there
exists
M
:
U

G
is
said
a
c
omplete
unsharing
of
G.
In
particular,
an
unshared
graph
that
admits
an
assignmen
t
for
an
y
state
is
prop
er
and
is
the
complete
unsharing
of
itself.


R
e
ad-b
ack
Exercise
..
Pro
v
e
that
an
y
-tree
is
a
prop
er
sharing
graph.
Assignmen
ts
and
prop
er
sharing
graphs
ma
y
b
e
studied
also
in
terms
of
paths.
F
rom
that
p
oin
t
of
view,
the
constrain
ts
in
Figure
.
b
ecome
the
rules
to
asso
ciate
a
transfer
function
F

[]

LSeq

,
dep
enden
t
on
the
state
,
to
eac
h
path
.
Denoted
b
y
(U)
the
biggest
subset
of
(U)
s.t.
F

[]

LSeq
for
an
y
state
,
an
equiv
alen
t
denition
of
prop
er
unshared
graph
is:
(i)
(U)
=
(U).
(ii)
for
an
y
v
e

(U),
if

=
 v
,
there
exists
S
[]

LSeq
[n;
n+
q
+
],
s.t.
F

[]
=
S
[]F

[],
where
n
is
the
lev
el
of

and
q
the
oset
of
the
p
ort
of
the
v
no
de
reac
hed
b
y
.
The
adv
an
tage
of
the
latter
approac
h
is
that
the
denition
of
prop
er-
ness
can
b
e
reform
ulated
for
all
the
sharing
graphs
(not
only
the
un-
shared
ones),
extending
the
notation
in
the
natural
w
a
y
.
Denition
..
The
sharing
graph
G
is
pr
op
er
if:
(i)
(G)
spans
G.
(ii)
An
y
maxim
al
path

0

(G)
is
nite
and
ends
at
the
binding
p
ort
of
a
-no
de,
that
is,

0
=
e.
(iii)
F
or
an
y
maximal
path
e

(G),
there
in
an
o
ccurrence
of

in

s.t

=
 
and,
for
an
y
state
,
there
exists
S
[]

LSeq
[n;
n
+
q
+
],
s.t.
F

[]
=
S
[]F

[],
where
n
is
the
lev
el
of

and
q
the
oset
of
the
p
ort
reac
hed
b
y
.
Let
us
note
that
the
second
pro
viso
of
this
denition
do
es
not
implies
F
 
[]

LSeq
[n;
n
+
q
+
].
In
fact,
w
e
migh
t
ha
v
e
F
 
[]
=
S
HH

,
for
some
H

LSeq
s.t.
F

[]
=
HH
0
.
T
o
see
that
Denition
..
and
Denition
..
are
equiv
alen
t
let
us
start
noticing
that
the
pr
op
er
p
aths
(G)
of
a
prop
er
sharing
graph
G
are
the
prop
er
paths
of
its
complete
unsharing.
Lemma
..
If
U
is
a
c
omplete
unsharing
of
G,
then
(U)
'
(G).
Pr
o
of
Let
M
:
U

G.
Since
F

=
F
M()
,
w
e
ha
v
e
M()

(G),
for
an
y


(U).
Vice
v
ersa,
to
an
y
 

(G)
w
e
pro
v
e
that
there
is
a
path


(U),
with
M()
=
 ,
b
y
induction
on
the
length
of
 .
The
only
relev
an
t
case
is
when
 
=
 
0
eu
and
the
last
no
de
of
 
0
is
a
negativ
e
m
ux.
By
the
induction
h
yp
othesis,
there
is

0

(U)
s.t.
M(
0
)
=
 
0
.
Since
U
is
a
prop
er
unshared
graph
(according
to
Denition
..)
and
u

.
Pr
op
er
p
aths

is
a
negativ
e
m
ux
(hence,

0
ends
at
the
principal
p
ort
of
a
negativ
e
lift)
there
is
a
unique
path

=

0
e
0
u
0

(G),
F

=
L[m;
q;
a]F

0

LSeq
(where
m;
q;
a
are
the
parameters
of
the
lift),
and
M()

(G).
W
e
sho
w
that
M()
=
 .
In
fact,
since
L[m;
q;
a]F

=
F

0
=
F
 
0
,
the
edge
e
m
ust
b
e
connected
to
the
p
ort
with
name
a
of
the
negativ
e
m
ux
at
the
end
of
 
0
.
Th
us,
M(e
0
)
=
e
and
M()
=
 .
The
main
consequence
of
the
previous
lemma
is
that
an
y
prop
er
shar-
ing
graph
according
to
Denition
..
is
prop
er
also
according
to
Def-
inition
...
F
or
the
con
v
erse,
let
us
note
that
the
requiremen
ts
in
Denition
..
allo
w
to
asso
ciate
a
prop
er
unshared
graph
to
(G),
and
then
to
G.
In
fact,
in
terpreting
a
path


(G)
ending
at
a
no
de
u
as
a
no
de
of
the
same
t
yp
e
of
u
,
it
is
natural
to
see
(G)
as
an
unfolding
tree
of
G.
The
last
pro
viso
of
Denition
..
suggests
then
ho
w
to
close
the
tree
in
order
to
get
a
prop
er
unshared
graph
U.
Let
us
b
e
more
precise.
An
y
path
eu

(G)
s.t.
e
is
not
a
binding
connection
and
u
is
not
a
v
-no
de
is
an
in
ternal
no
de
of
U
with
the
same
t
yp
e
and
index
of
u
(a
lift
with
the
same
threshold
of
u
and
the
appropriate
threshold,
p
ort
name,
and
oset
in
the
case
in
whic
h
u
is
a
m
ux).
It
is
easy
to
c
hec
k
that
an
y
lift
dened
in
this
w
a
y
has
only
one
descendan
t
(see
the
pro
of
of
Lemma
..),
an
y
@
no
de
has
a
left
and
a
righ
t
descendan
t,
and
an
y
-no
de
has
one
descendan
t.
W
e
left
to
nd
the
corresp
ondence
b
et
w
een
v
ariables
and
binders.
F
or
eac
h
-no
de
,
there
is
a
v
-no
de
u
with
an
input
edge
for
an
y
e
that

splits
in
to
 e,
in
accord
with
the
last
pro
viso
in
Denition
...
The
unshared
graph
obtained
in
this
w
a
y
is
prop
er,
according
to
Denition
..,
and
is
a
complete
unsharing
of
G.
The
previous
pro
cedure
to
get
a
complete
unsharing
of
G
from
its
prop
er
paths
migh
t
seem
non-deterministic,
for
w
e
could
ha
v
e
more
than
one
o
ccurrence
of
the
same
no
de

splitting
e.
The
next
lemma
pro
v
es
that
this
is
not
the
case
(w
e
in
vite
the
reader
to
compare
this
lemma
with
the
nesting
prop
ert
y
used
pro
ving
correctness
of
Lamping's
algorithm
in
section
..).
Lemma
..
L
et
G
b
e
a
pr
op
er
sharing
gr
aph
and
let
uev;
 uev

(G)
(i.e.,
two
pr
op
er
p
aths
ending
with
the
same
e
dge).
L
et
F
uev
and
F
 uev
b
e
the
c
orr
esp
onding
tr
ansfer
functions
(the
internal
state
of
G
is
not
r
elevant
and
might
even
b
e
dier
ent
for
the
two
c
ases).
If
F
vuev
=
F
 uev
,
then

=
 .


R
e
ad-b
ack
Pr
o
of
The
pro
of
is
b
y
induction
on
the
length
of
;
 
and
b
y
case
analysis
of
the
t
yp
e
of
u.
The
base
case
is
trivial:
e
is
the
edge
at
the
ro
ot
of
G
and
there
is
nothing
to
pro
v
e.
Therefore,
let

=

0
u
0
e
0
u
and
 
=

00
u
00
e
00
u.
The
statemen
t
follo
ws
b
y
induction
h
yp
othesis
once
sho
w
ed
that
e
0
=
e
00
and
F

=
F
 
.
The
only
relev
an
t
cases
are:
u
is
a
p
ositive
mux.
The
edge
e
is
the
principal
edge
of
the
m
ux
u,
while
e
0
and
e
00
are
connected
to
t
w
o
auxiliary
p
orts,
sa
y
that
(a
0
;
q
0
)
and
(a
00
;
q
00
)
are
the
corresp
onding
name-oset
pairs.
Let
m
b
e
the
threshold
of
u.
By
h
yp
othesis,
F
uev
=
L[m;
q
0
;
a
0
]
F

=
H
=
L[m;
q
00
;
a
00
]
F
 
=
F
 uev
;
that,
since
H
=
0,
is
p
ossible
only
if
a
0
=
a
00
and
q
0
=
q
00
,
that
is,
e
0
=
e
00
.
Then
b
y
simplication
of
the
lifting
op
erator,
w
e
also
get
F
 
=
F

.
u
is
a
ne
gative
mux.
The
edge
e
is
in
this
case
connected
to
an
auxiliary
p
ort
of
u,
sa
y
that
(a;
q)
is
the
corresp
onding
name-oset
pair;
the
edges
e
0
and
e
00
are
instead
the
principal
edge
of
u,
that
is,
e
0
=
e
00
.
By
h
yp
othesis,
F
uev
=
L
[m;
q;
a]
F

=
H
=
L
[m;
q;
a]
F
 
=
F
 uev
;
that,
since
H
=
0,
is
p
ossible
only
if
F

=
L[m;
q;
a]
H
=
F
 
.
e
is
the
right
e
dge
of
the
@
no
de
u.
Also
in
this
case
w
e
immedia
tely
ha
v
e
e
0
=
e
00
(it
is
the
con
text
edge
of
u).
By
h
yp
othesis
of
prop
erness,
F

0
;
F

00

LSeq
[0;
n]
where
n
is
the
lev
el
of
u,
and
S
0
F

=
S
00
F
 
for
some
S
0
;
S
00

LSeq
[n;
n
+
].
But,
b
y
Lemma
..,
this
is
p
ossible
if
only
if
F

=
F
 
and
S
0
=
S
00
.
The
other
cases
are
trivial.
By
insp
ection
of
the
previous
pro
of,
w
e
see
that
not
only

and
 
coincide,
but
also
the
in
ternal
states
for
whic
h
F
vuev
and
F
 uev
w
ere
computed
are
equal,
at
least
for
the
part
relativ
e
to

and
 .
Actually
,
for
the
pro
of
of
the
next
theorem
it
w
ould
ha
v
e
b
een
enough
to
pro
v
e
Lemma
..
for
a
particular
in
ternal
state,
sa
y
;
that
on
the
other
hand,
is
the
relev
an
t
one
for
the
determination
of
the
unshared
instance
corresp
onding
to
a
sharing
graph
(see
Exercise
..).
The
other
states
are
rather
relev
an
t
for
the
pro
of
of
in
v
ariance
of
prop
erness
under
-
reduction.
Theorem
..	
L
et
G
b
e
a
pr
op
er
sharing
gr
aph.
Its
c
omplete
unshar-
ing
is
unique.
Pr
o
of
The
only
thing
that
m
ust
b
e
pro
v
ed
is
that
there
is
a
unique
w
a
y
to
split
an
y
prop
er
path

from
the
ro
ot
to
a
v
ariable
in
to
the

.
Pr
op
er
p
aths

concatenation
of
an
access
path

from
the
ro
ot
to
the
no
de

binding
the
v
ariable
and
a
lo
op
 
from
the
b
o
dy
to
the
binding
p
ort
of
.
Let


(G)
b
e
a
maxim
al
path.
If

(let
n
b
e
its
index)
is
the
no
de
to
whic
h
the
v
-no
de
is
bac
k-connected,
let
us
assume
that
for
b
oth

=
 
and

=

0
 
0
the
third
pro
viso
of
Denition
..
holds.
Fixed
an
in
ternal
state
(sa
y
),
if
q
is
the
oset
of
the
v
ariable
reac
hed
b
y
,
w
e
ha
v
e
that
S
F

=
F

=
S
0
F

0
,
for
some
S
;
S
0

LSeq
[n;
n
+
q
+
],
with
F

;
F

0

LSeq
[0;
n].
But,
b
y
Lemma
..,
this
is
p
ossible
only
if
F

=
F

0
.
Therefore,
b
y
Lemma
..,
w
e
conclude

=

0
and
 
=
 
0
.
W
e
in
vite
the
reader
to
compare
the
previous
pro
of
with
the
analog
one
in
Lamping's
case.
Exercise
..0
Giv
e
an
algorithm
that
v
erify
if
a
sharing
graph
is
prop
er
and
compute
its
complete
unsharing.
..
De
ad
lo
ck-fr
e
eness
and
pr
op
erness
In
the
follo
wing
prop
erness
refers
to
the
seman
tical
prop
ert
y
of
sharing
graphs
giv
en
b
y
the
t
w
o
equiv
alen
t
c
haracterizations
in
Denition
..
and
Denition
...
Prop
erness
is
mainly
an
algebraic
c
haracterization
of
deadlo
c
k-freeness.
But,
while
the
denition
of
deadlo
c
k-freeness
do
es
not
giv
e
an
y
hin
t
on
ho
w
to
v
erify
it,
the
equiv
alence
with
prop
erness
that
w
e
are
going
to
pro
v
e
will
sho
w
that
deadlo
c
k-freeness
is
decidable,
for
w
e
already
ga
v
e
an
algorithm
to
v
erify
prop
erness.
The
easy
thing
to
pro
v
e
is
that
prop
erness
is
w
ell-dened
w.r.t.
-
reduction.
Let
us
start
with
the
case
of
unshared
graphs.
Lemma
..
Pr
op
erness
of
unshar
e
d
gr
aphs
is
invariant
under
-
r
e
duction.
Pr
o
of
By
insp
ection
of
-rules.
Let
us
giv
e
some
relev
an
t
cases
only
.
Let
U
b
e
an
unshared
prop
er
graph
suc
h
that
r
:
U
!

U
0
,
where
r
is
a
-rule
in
v
olving
an
n-indexed
@-no
de
v
@
,
sa
y
a
negativ
e
lift
v
M
connected
to
the
argumen
t
p
ort
of
v
@
.
W
e
start
pro
ving
that
if
U
is
prop
er,
then
U
0
is
prop
er
to
o.
If

is
an
y
in
ternal
state
of
U,
let
S
b
e
the
lifting
sequence
it
asso
ciates
to
v
@
and
L[m;
q;
a]
b
e
the
lifting
op
erator
of
v
M
.
Let
F
and
H
b
e


R
e
ad-b
ack
the
lifting
sequences
that
the
assignmen
t
for

asso
ciates
to
the
edges
inciden
t
to
v
@
and
v
M
in
U,
according
to
the
lab
eling
rep
orted
on
the
left-hand
side
of
the
follo
wing
picture.
m
@
n
q
S F
H
F
F
a
@
m
m
q
q
S’ H’ = H
F
F
a
a H’
n+q
H’
By
the
side
condition
of
the
rule,
w
e
kno
w
that
m
<
i;
while,
b
y
the
denition
of
lifting
assignmen
t,
w
e
see
that
S
F
=
L[m;
q;
a]
H,
with
F

LSeq
[0;
n]
and
S

LSeq
[n;
n
+
].
According
to
the
latter
considerations,
w
e
also
ha
v
e
that
L[m;
q;
a]
S
=
S
0
L
[m;
q;
a],
where
S
0
=
S
+q
is
the
lifting
sequence
obtained
from
S
increasing
b
y
q
all
the
thresholds
in
S
.
Moreo
v
er,
it
is
immedia
te
to
see
that
S
0

LSeq
[n
+
q;
n
+
q
+
].
Let
us
note
that
H
=
L[m;
q;
a]
S
F
=
S
0
L[m;
q;
a]
F
;
that,
b
y
the
AB

prop
ert
y
of
lifting
sequences,
is
p
ossible
only
if
F
=
L[m;
q;
a]
H
0
,
for
some
H
0

LSeq
[0;
n
+
q]
(w
e
lea
v
e
to
the
reader
the
easy
v
erication
of
the
fact
that
H
0

LSeq
[0;
n
+
q]).
Summarizing,
the
lifting
sequences
H
=
S
0
H
0
,
H
0
and
F
0
can
b
e
as-
signed
to
the
edges
inciden
t
to
the
residuals
of
v
@
and
v
M
in
U
0
according
to
the
lab
eling
rep
orted
in
the
righ
t-hand
side
of
the
picture
ab
o
v
e.
This
assignmen
t
satises
the
constrain
ts
of
the
no
des
inserted
in
U
0
b
y
the
reduction
of
the
redex
r
and
has
not
inuence
on
the
lifting
sequences
that
the
assignmen
t
for

asso
ciated
in
U
to
the
other
edges.
W
e
get
in
this
w
a
y
a
lifting
assignmen
t
of
U
0
for
the
in
ternal
state

0
of
U
0
obtained
from

b
y
replacing
S
0
for
S
.
It
is
indeed
imm
ediate
to
c
hec
k
that
also
the
con
v
erse
is
trivially
true.
Namely
,
if
the
assignmen
t
of
U
0
for
the
state

0
asso
ciates
to
the
edges
inserted
b
y
the
reduction
of
r
the
lifting
sequences
in
the
righ
t-hand
side
of
the
ab
o
v
e
picture,
then
the
lifting
sequences
in
the
left-hand
side
giv
e
an
assignmen
t
of
U
for
the
in
ternal
state
.
T
o
conclude
the
in
v
ariance
of
prop
erness
under
the
previous
rule,
w
e
left
to
note
that
an
y
S
0

LSeq
[n
+
q;
n
+
q
+
]
can
b
e
obtained
increasing
b
y
q
the
thresholds
of
the
lifting
op
erator
in
some
S

LSeq
[n;
n
+
],
and
vice
v
ersa.

.
Pr
op
er
p
aths

Let
us
no
w
consider
the
case
in
whic
h
U
!

U
0
b
y
an
absorption
rule.
The
situation
is
as
dra
wn
in
the
follo
wing
picture:
v n
F
v
m
q
a
p
n
F
G
H
H
p+q
in
whic
h
n

m
<
n
+
p
+
.
Let
F
,
G
and
H
b
e
the
lifting
sequences
that
an
assignmen
t
of
U
asso-
ciates
to
the
edges
in
the
left-hand-side
of
the
ab
o
v
e
picture.
By
deni-
tion
of
lifting
assignmen
t,
w
e
ha
v
e
that
G
=
S
F
=
L[m;
q;
a]
H,
where
F

LSeq
[0;
n]
and
S

LSeq
[n;
n
+
p
+
].
In
particular,
since
n

m,
an
easy
calculation
allo
w
to
conclude
that
necessarily
S
=
L[m;
q;
a]
S
0
,
with
S
0

LSeq
[n;
n
+
p
+
q
+
],
and
then
that
H
=
S
0
F
.
Therefore,
the
lifting
sequences
asso
ciated
to
the
righ
t-hand-side
in
the
ab
o
v
e
picture
giv
e
a
lifting
assignmen
t
of
U
0
(the
lifting
sequences
of
the
other
edges
are
unc
hanged,
in
ternal
state
of
@-no
des
included).
Hence,
for
an
y
as-
signmen
t
of
U
for
an
in
ternal
state

w
e
get
an
assignmen
t
of
U
0
for
the
same
in
ternal
state.
The
con
v
erse
is
also
imm
ediate.
In
this
case,
the
assignmen
t
for
U
0
giv
es
F
and
H;
th
us,
to
obtain
an
assignmen
t
for
U,
it
suces
to
tak
e
G
=
L[m;
q;
a]
H.
The
other
cases
are
similar,
therefore,
as
a
nal
example
w
e
let
us
an-
alyze
the
sw
ap
rule
of
lifts
only
.
The
situation
is
as
in
the
follo
wing
picture:
F1
F2
a1
1
m +q
2
1q
a1
F1
F2
m2
1q
2q
a2
m1
m1
a2
2q
H’
H
in
whic
h
m

<
m

.
The
left-hand-side
giv
es
H
=
L[m

;
q

;
a

]
F

;
the
righ
t-hand-side
giv
es
instead
L[m

+
q

;
q

;
a

]
H
0
=
F

;
b
y
a
simple
replacemen
t
of
F

w
e
get
then
H
=
L[m

;
q

;
a

]
L[m

+
q

;
q

;
a

]
H
0
.


R
e
ad-b
ack
Therefore,,
giv
en
a
lifting
assignmen
t
of
U
0
,
and
in
particular
H
0
,
the
previous
equation
ensures
the
existence
of
an
H
satisfying
the
con-
strain
ts
of
the
lifts
in
U
(in
particular,
note
that
H
=
L[m

;
q

;
a

]
F

,
for
L[m

;
q

;
a

]
L[m

+
q

;
q

;
a

]
=
L[m

;
q

;
a

]
L[m

;
q

;
a

]).
Vice
v
ersa,
the
AB

prop
ert
y
ensures
that,
giv
en
a
lifting
assignmen
t
of
U
0
,
and
in
particular
giv
en
H,
there
exists
H
0
for
whic
h
the
constrain
ts
of
the
lifts
in
U
0
are
satised.
The
pro
of
of
the
other
cases
is
similar
and
is
th
us
omitted.
An
imm
ediate
consequence
of
the
previous
lemma
is
that
-reduction
of
unshared
graphs
nev
er
get
stuc
k.
Lemma
..
A
ny
pr
op
er
unshar
e
d
gr
aph
is
de
ad
lo
ck-fr
e
e.
Pr
o
of
Let
U
b
e
a
prop
er
unshared
graph.
The
constrain
ts
imp
osed
b
y
the
existence
of
a
lifting
assignmen
t
for
an
y
in
ternal
state
of
U
(actu-
ally
,
the
state

w
ould
suce)
are
incompatible
with
the
presence
of
deadlo
c
k
ed
redexes
in
U.
Hence,
U
do
es
not
con
tain
an
y
deadlo
c
k.
By
Lemma
..,
if
U


U
0
,
also
U
0
is
prop
er
and,
b
ecause
of
the
previ-
ous
remark,
do
es
not
con
tain
deadlo
c
ks.
The
sim
ulation
prop
ert
y
for

(Lemma
..)
allo
ws
to
extend
the
previous
results
to
sharing
graphs
to
o
and
to
conclude
that
prop
erness
implies
deadlo
c
k-freeness.
Prop
osition
..
Pr
op
erness
of
sharing
gr
aphs
is
invariant
under
-r
e
duction
and
any
pr
op
er
sharing
gr
aph
is
de
ad
lo
ck-fr
e
e.
Pr
o
of
Let
G
b
e
a
prop
er
sharing
graph.
W
e
already
remark
ed
(see
the
end
of
section
.)
that,
when
G
con
tains
a
deadlo
c
k,
eac
h
G
0
s.t.
G
0

G
con
tains
at
least
a
deadlo
c
k
ed
redex.
Therefore,
since
the
prop
er
unshared
graph
U
s.t.
U

G
is
deadlo
c
k-free
(b
y
Lemma
..),
w
e
conclude
that
G
0
do
es
not
con
tain
deadlo
c
ks
to
o.
By
the
sim
ulation
lemma
for

(Lemma
..),
whenev
er
G


G
0
there
is
a
corresp
onding
reduction
U


U
0
suc
h
that
U
0

G
0
.
By
the
in
v
ariance
of
prop
erness
for
unshared
graphs,
U
0
is
prop
er
and
th
us,
so
is
G
0
;
moreo
v
er,
the
fact
that
U
0
is
deadlo
c
k-free
implies
that
G
0
cannot
con
tain
deadlo
c
ks.
T
o
conclude
the
analysis
of
-rules,
w
e
left
to
pro
v
e
that
they
are
strongly
normalizing
on
prop
er
sharing
graphs.

.
Pr
op
er
p
aths
	
Prop
osition
..
The
-rules
ar
e
str
ongly
normalizing
over
pr
op
er
sharing
gr
aphs.
Pr
o
of
Because
of
Prop
osition
..,
it
suces
to
pro
v
e
the
result
for
the
unshared
case.
Let
U
b
e
a
prop
er
unshared
graph.
The
pro
of
rests
on
the
idea
that
eac
h
lifting
sequence
of
an
assignmen
t
corresp
onds
to
a
pro
duct
of
op
erators
that
m
ust
cross
and
reindex
the
corresp
onding
edge
along
the
reduction.
According
to
this,
w
e
exp
ect
that
eac
h
-rule
decrease
the
length
of
at
least
one
of
that
lifting
sequences
or,
in
the
case
of
absorption
and
anni-
hilation,
something
taking
in
to
accoun
t
the
n
um
b
er
of
lifts
in
the
graph.
The
previous
considerations
formalize
in
the
follo
wing
t
w
o
measures,
de-
ned
for
the
assignmen
t
of
U
corresp
onding
to
the
in
ternal
state
:
(a)
k

is
the
sum
of
the
lengths
of
the
lifting
sequences
assigned
to
con
text
edges
of
no
des

or
@,
or
to
principal
edges
of
v
-no
des;
(b)
k

is
the
sum
of
the
lengths
of
the
lifting
sequences
assigned
to
the
principal
edges
of
the
lifts
in
the
graph.
By
insp
ection
of
the
rules,
w
e
see
that,
with
the
exception
of
absorption,
eac
h
-rule
in
v
olving
a
prop
er
no
de
decreases
k

,
though
it
generally
in-
creases
k

.
The
other
-rules
decrease
instead
k

lea
ving
k

unc
hanged.
F
or
instance,
let
us
tak
e
the
t
w
o
examples
describ
ed
in
the
pro
ving
Lemma
...
In
the
rule
for
the
@-no
de,
the
lifting
sequence
its
con
text
edge
in
U
is
F
,
while
in
U
0
is
H
0
.
All
the
other
lifting
sequences
of
con
text
edges
are
un-
c
hanged,
and
moreo
v
er,
since
F
=
L[m;
q;
a]
H
0
,
jF
j
>
jH
0
j.
Therefore,
the
rule
decrease
k

.
A
t
the
same
time,
since
the
lift
has
t
w
o
residuals,
the
addend
jF
j
in
k

(remind
that
S
=
)
is
replaced
b
y
jF
j,
causing
an
increase
of
k

.
In
the
absorption
rule,
k

is
ob
viously
unc
hanged,
while
k

decreases
for
the
reduction
erases
one
lift,
causing
the
corresp
onding
erasing
of
the
addend
jG
j
from
k

(note
also
that
jG
j
>
0).
Finally
,
also
the
sw
ap
rule
of
lifts
do
es
not
c
hange
k

,
while
t
w
o
addend
jHj
in
k

are
replaced
b
y
jF

j
and
jF

j
with
H
=
L[m
i
;
q
i
;
a
i
]
F
i
,
for
i
=
;
.
Summarizing,
eac
h

rule
decreases
the
com
bined
measure
(k

;
k

)
(w.r.t.
lexicographic
ordering).
Therefore,
since
(k

;
k

)

(0;
0),
there
is
no
in-
nite
-reduction
of
an
y
prop
er
unshared
graph.
The
previous
prop
ositions
and
lemmas
sum
up
in
the
follo
wing
theo-
rem,
that
states
indeed
the
equiv
alence
b
et
w
een
the
seman
tical
(Deni-

0
R
e
ad-b
ack
tion
..
and
Denition
..)
and
syn
tactical
(Denition
..)
c
har-
acterizations
of
prop
erness.
Prop
osition
..
A
ny
pr
op
er
sharing
gr
aph
G
has
a
unique

normal-
form
R(G)
=
JUK,
wher
e
U
is
the
c
omplete
unsharing
of
G.
Pr
o
of
Since
an
y
prop
er
sharing
graph
G
has
an
unshared
instance
U

G
that
is
deadlo
c
k-free,
b
y
Prop
osition
..
w
e
conclude
that
the
normal
form
R(G)
of
G
there
exists
and
is
unique;
moreo
v
er,
R(G)
do
es
not
con
tain
lifts
or
m
uxes.
This
last
fact,
in
addition
with
the
sim
ulation
prop
ert
y
for

(Lemma
..,
also
implies
that
R(G)
=
R(U).
By
denition
of
J

K
(see
Exercise
..),
w
e
see
that
the
-tree
JUK
is
in
v
arian
t
under
-reduction
(i.e.,
JU
0
K
=
JUK,
for
an
y
pair
of
un-
shared
graph
suc
h
that
U


U
0
).
In
particular,
since
R(G)
is
a
-tree,
JR(G)K
=
R(G).
By
the
fact
that
U


R(G),
w
e
ev
en
tually
get
R(G)
=
JUK.
T
o
conclude,
let
us
note
that
the
in
v
ariance
of
JUK
giv
es
indeed
a
direct
pro
of
of
the
uniqueness
of
the

normal
form.
Exercise
..
Let
J

K

b
e
the
map
that
asso
ciates
a
-tree
JUK
to
an
y
prop
er
unshared
graph
U
in
the
follo
wing
w
a
y:
(i)
Replace
all
the
lifts
in
U
b
y
direct
connections
b
et
w
een
their
p
orts.
(ii)
F
or
an
y
edge
e
connected
to
the
con
text
p
ort
of
a

or
@
no
de
or
to
an
y
p
ort
of
a
v
-no
de,
denote
b
y
F
e
the
transfer
function
for
the
in
ternal
state

of
the
(unique)
prop
er
path
ending
with
e,
and
b
y
j
jH
e
j
j
the
sum
of
all
the
osets
in
H
e
.
Reindex
no
des
and
v
-no
de
osets
according
to
the
follo
wing
rules:
(a)
The
new
index
of
an
y
n-indexed
@
or
-no
de
is
equal
to
n
+
j
jH
e
j
j,
where
e
is
the
con
text
edge
of
the
no
de.
The
new
index
of
an
y
v
-no
de
is
equal
n
+
j
jH
e
j
j,
where
e
is
the
principal
edge
of
the
no
de.
(b)
The
new
oset
of
an
edge
e
en
tering
in
to
an
n-indexed
v
-no
de
is
q
+
j
jS
e
j
j,
where
q
is
the
old
oset
of
e
and
S
e

LSeq
[n;
n
+
q
+
]
is
the
unique
lifting
sequence
suc
h
that
F
e
=
S
e
F
,
for
some
F

LSeq
[0;
n].
Pro
v
e
that:
(i)
JUK

is
a
-tree;
(ii)
JUK

is
in
v
arian
t
under
-reduction;
(iii)
JUK

=
JUK
=
R(U).

.	
Soundness
and
ade
quateness

.	
Soundness
and
adequateness
The
next
step
is
to
pro
v
e
that
prop
erness
is
sound
w.r.t.
to
-rule
to
o.
The
k
ey
p
oin
t
is
to
pro
v
e
soundness
of

u
.
Lemma
.	.
L
et
U
b
e
a
pr
op
er
unshar
e
d
gr
aph.
A
ny
unshar
e
d
gr
aph
U
0
s.t.
U
!

u
U
0
is
pr
op
er.
Pr
o
of
Let
us
just
consider
the
case
in
whic
h
the
v
ariable
in
v
olv
ed
in
the
rule
has
only
one
o
ccurrence.
The
generalization
to
the
k-ary
case
is
imm
ediate,
for
it
suces
to
rep
eat
the
argumen
t
for
an
y
of
the
o
ccur-
rences
of
the
v
ariable.
An
y
path

0
starting
at
the
ro
ot
of
U
0
has
an
ancestor
in
U
(starting
at
the
ro
ot
of
U).
W
e
can
distinguish
the
follo
wing
cases,
according
to
the
p
osition
of
the
redex
u:
(i)

did
not
tr
averse
any
no
de
of
u.
In
this
case

and

0
are
isomorphic
and
the
prop
erness
of

0
follo
ws
immediately
from
the
prop
erness
of
.
(ii)

tr
averse
d
the
e
dge
u.
The
only
dierence
b
et
w
een

and

0
is
that
the
sequence
of
three
edges
tra
v
ersing
the
@-
pair
of
u
that
w
as
in

(i.e.,
the
con
text
edge
of
u,
the
edge
u
itself
and
the
b
o
dy
edge
of
u)
has
b
een
merged
in
to
a
unique
edge
in

0
.
It
is
ho
w
ev
er
immedia
te
to
note
that
this
substitution
has
no
impact
on
the
prop
erness
of

0
,
for
the
transfer
function
of
the
remo
v
ed
@-
pair
w
as
the
iden
tit
y
.
(iii)

tr
averse
d
the
@-no
de
to
enter
the
ar
gument
p
art
of
u.
Let
v
e
b
e
the
path
of
U
starting
at
the
ro
ot
and
ending
at
the
binding
p
ort
of
the
-no
de

in
u.
The
syn
tax
ensures
that

crosses
the
-no
de
,
that
is,

=
 v
.
Moreo
v
er,
b
y
the
prop
erness
of
U,
for
an
y
state
,
there
exists
S
[]

LSeq
[n;
n
+
q
+
]
s.t.
F

[]
=
S
[]F

[],
where
n
is
the
lev
el
of

and
q
the
oset
of
the
p
ort
reac
hed
b
y
.
Let

=
@
b
e
the
crossing
of
the
@-no
de
@
under
analysis.
The
path

0
is
obtained
b
y
replacing
the
path
 
0
e
M
v
M
for
the
no
de
@,
where
 
0
is
 
without
its
rst
edge
(the
b
o
dy
edge
of
u),
v
M
is
a
lift
with
threshold
n
and
oset
q,
and
the
edge
e
M
is
connected
to
the
auxiliary
p
ort
of
v
M
(let
a
b
e
the
name
of
this
p
ort).
Accord-
ing
to
this,

0
splits
in
the
follo
wing
w
a
y

0
=

0

e

 
0
e
M
v
M

0
,
where

0
is
isomorphic
to

without
its
last
edge
(the
con
text
edge
of
u),

0
is
isomorphic
to

without
its
rst
edge
(the
argumen
t


R
e
ad-b
ack
edge
of
u),
and
e
is
the
edge
inserted
b
y
the
reduction
to
replace
the
@-
pair
of
u.
Let
us
no
w
compute
the
transfer
functions
of
the
previous
paths.
The
path

0
=

0

e


 
0
is
the
image
in
U
0
of
the
path

=
 
of
U.
Then,
b
y
the
previous
item
in
the
pro
of,
w
e
also
kno
w
that
its
transfer
function
is
F

0
[]
=
F

[]
=
S
[]F

[],
for
some
S
[]

LSeq
[n;
n
+
q
+
].
The
transfer
function
of

0
fol-
lo
w
ed
b
y
the
lift
inserted
b
y
the
reduction
is
then
F

0
e
M
[]
=
L[n;
q;
a]S
[]F

[],
and
an
easy
calculation
allo
ws
to
v
erify
that
L[n;
q;
a]S
[]

LSeq
[n;
n
+
].
Therefore,
assuming
that

as-
so
ciate
the
in
ternal
state
L[n;
q;
a]S
[]
to
the
@-no
de
@
in
the
redex
u,
w
e
see
that
F

[]
=
F

0
[]
(let
us
remark
that
here,
and
in
all
the
previous
equations,
w
e
ha
v
e
implicitly
assumed
that
the
in
ternal
state

of
U
0
is
the
natural
one
obtained
from
the
state

of
U
erasing
the
v
alue
for
@).
Since
apart
for
the
v
alue
assigned
to
@
the
state

is
arbitrary
,
w
e
conclude
the
prop
erness
of
U
0
.
The
extension
of
the
previous
result
to
sharing
graphs
is
immediate
b
ecause
of
the
sim
ulation
prop
ert
y
for
.
As
a
matter
of
fact,
since
w
e
already
sho
wn
that
prop
erness
is
sound
for
-rules
to
o,
w
e
can
directly
state
the
result
for
the
whole
system.
Prop
osition
.	.
L
et
G
b
e
a
pr
op
er
sharing
gr
aph.
If
G

G
0
,
then
G
0
is
pr
op
er.
Pr
o
of
It
is
an
imm
ediate
consequence
of
the
sim
ulation
prop
erties
(Lemma
..
and
Lemma
..)
and
of
the
in
v
ariance
of
prop
erness
for
unshared
graphs
under

u
-reduction
(Lemma
.	.)
and
-rules
(Lemma
..).
W
e
can
ev
en
tually
pro
v
e
that
sharing
reduction
is
sound
w.r.t.
stan-
dard
-calculus
-reduction
and
that,
in
the
extended
(and
th
us
non-
optimal)
system,
an
y
-calculus
reduction
can
b
e
implemen
ted
on
shar-
ing
graphs.
Theorem
.	.
L
et
T
b
e
a
-tr
e
e.
(i)
F
or
any
sharing
r
e
duction
T

G,
ther
e
exists
a
standar
d
-
c
alculus
r
e
duction
s.t.
T


R(G).
(ii)
F
or
any
-c
alculus
r
e
duction
T


T
0
,
ther
e
exists
a
sharing
r
e
duction
s.t.
T

T
0

.0
R
e
ad-b
ack
and
optimality

Pr
o
of
First
of
all
let
us
note
that
T
,
and
then
G,
is
prop
er
(see
Exer-
cise
..)
and
that
R(T
)
=
T
.
The
rst
item
follo
ws
b
y
the
follo
wing
observ
ations:
(i)
F
or
an
y
prop
er
sharing
graph
G
0
,
if
G
0
!

G,
then
R(G)
=
R(G)
0
.
By
the
uniqueness
of
the
-normal
form.
(ii)
F
or
an
y
prop
er
sharing
graph
G
0
,
if
G
0
!

G,
then
R(G)
!

R(G)
0
.
In
fact,
b
y
Prop
osition
..,
G
0
and
G
ha
v
e
t
w
o
unique

normal
forms,
that
are
indeed
the

normal
forms
of
the
re-
sp
ectiv
e
complete
unsharings
U
and
U
0
(i.e.,
R(G)
=
R(U)
and
R(G
0
)
=
R(U
0
),
with
U

G
and
U
0

G);
moreo
v
er,
b
y
Exer-
cise
..
and
sim
ulation
prop
ert
y
of
,
R(G)


R(G
0
).
Then
an
easy
induction
on
the
length
of
the
reduction
of
T
allo
ws
to
conclude
that
T


R(G).
The
second
item
is
instead
an
immediate
consequence
of
Exercise
...
.0
Read-bac
k
and
optimalit
y
The
relev
an
t
p
oin
t
of
the
results
pro
v
ed
in
the
previous
sections
is
the
uniqueness
of
the
-normal
form
of
an
y
prop
er
sharing
graph
G
and
the
fact
that
it
coincides
with
the
-term
matc
hing
suc
h
a
graph.
Then,
since
ev
ery
sharing
graph
obtained
along
the
reduction
of
a
-tree
is
prop
er,
the
-rules
giv
e
an
implemen
tation
of
the
read-bac
k
algorithm.
This
unrestricted
application
of
the
-rules
causes
ho
w
ev
er
the
loss
of
all
the
sharing
accum
ulated
in
G|as
a
matter
of
fact,
it
could
not
b
e
otherwise,
for
w
e
w
an
t
to
get
a
-tree
as
the
result
of
read-bac
k.
In
spite
of
this,
optimalit
y
can
b
e
reco
v
ered
assuming
to
follo
w
a
lazy
reduction
strategy
in
the
application
of
-rules.
The
idea
is
to
execute
a
m
ux
propagation
only
when
it
migh
t
hide
a
-redex.
Namely
,
giv
en
a
sharing
graph
G
suc
h
that
R(G)
=
T
,
a
propagation
rule
should
b
e
applied
on
G
only
if
the
corresp
onding
m
uxes
migh
t
hide
a
-rule
presen
t
in
T
.
F
or
instance,
the
t
w
o
binary
m
uxes
in
Figure
.
hide
in
G
at
least
a
pair
of
redexes
con
tained
in
the
corresp
onding
-term
T
.
In
more
detail,
if
the
t
w
o
m
uxes
are
complemen
tary
,
after
an
annihilation
w
e
immediately
get
a
pair
of
-redexes;
while,
if
the
t
w
o
m
uxes
are
not
complemen
tary
(w
e
assume
an
yho
w
that
they
are
not
deadlo
c
k
ed),
af-
ter
a
sw
ap
and
t
w
o
propagations
w
e
get
four
-redexes.
Since
all
the


R
e
ad-b
ack
@
@
λ
λ
Fig.
..
Hidden
-rules.
previous
rules
do
es
not
c
hange
the
read-bac
k,
that
redexes
w
ere
already
explicit
in
T
.
According
to
this
lazy
approac
h,
it
is
an
easy
observ
ation
to
notice
that
the
rules
in
Figure
.	
are
the
minima
l
subset
ensuring
that
situations
as
the
one
previously
describ
ed
nev
er
get
stuc
k,
inadv
erten
tly
ending
the
computation
when
it
should
rather
pro
ceed|note
that
the
optimal
rules
con
tain
the
propagation
through
the
principal
no
de
of
a
v
-no
de
in
order
to
ensure
to
completely
explicit
-redexes.
a1
ak qk
q1
m
λ i
i+q1
i+qk
a1
ak qk
q1
a1
ak qk
q1
λ
λ
m
m
a1
ak qk
q1
@
m
i
a1
ak qk
q1
i+q1
a1
ak qk
q1
i+qk
@
m
m
@
m < i
p1
ph
a1
ak qk
q1
v i
m
m < i
i+qk
ph
p1
a1
ak qk
q1
p1
ph
i+q1
a1
ak qk
q1
v
m
v
m
a1
ak qk
q1
b1 p1
hp
bh
m
n
n+q1
n+qi
n+qk
m
m
m
m < n
a1
ak qk
q1
a1
ak qk
q1
m
m
m < i
Fig.
.	.
Optimal
-rules.
It
should
not
b
e
surprising
that
the
previous
system
corresp
onds
ex-

.0
R
e
ad-b
ack
and
optimality

actly
to
the
rules
that
w
e
ga
v
e
in
Chapter

reform
ulated
according
to
the
notation
based
on
m
uxes.
Moreo
v
er,
it
is
also
immediate
to
note
that
the
addition
of
absorption
to
the
previous
set
do
es
not
cause
the
loss
of
optimalit
y
.
Indeed,
this
is
a
rst
example
of
a
more
general
tec
hnique
called
safe
op
er
ators
that
w
e
will
study
in
Chapter
	.
As
the
standard
Lamping's
algorithm,
the
optimal
-rules
in
Fig-
ure
.	
are
an
in
teraction
net.
Therefore,
they
are
trivially
lo
cally
conuen
t.
The
addition
of
absorption
impro
v
es
eciency
,
but
from
the
theoretical
p
oin
t
of
view
has
the
side-eect
of
the
loss
of
conuence:
it
is
an
easy
exercise
to
build
an
example
in
whic
h
the
optimal
rules
plus
absorption
are
not
conuen
t,
starting
from
a
critical
pair
b
et
w
een
an
absorption
and
a
-rule.
The
whole
system
of
the
-rules
plus

is
instead
conuen
t.
In
fact,
giv
en
t
w
o
reductions
M

G
0
and
M

G
00
w
e
can
alw
a
ys
ap-
ply
the
read-bac
k
algorithm
to
obtain
R(G
0
)
and
and
R(G
00
).
Then,
b
y
the
conuence
of
-calculus,
w
e
kno
w
that
there
exists
a
-tree
N
suc
h
that
M


R(G
0
)


N
and
M


R(G
00
)


N.
By
Theorem
.	.,
w
e
nally
see
that
the
previous
comm
uting
diamond
giv
es
indeed
a
comm
uting
diamond
of
sharing
reductions
comp
osed
of
M

G
0


R(G
0
)

s
N
and
M

G
00


R(G
00
)

s
N.
T
o
conclude
the
c
hapter,
let
us
recollect
in
a
theorem
the
read-bac
k
prop
erties
of
-rules.
Theorem
.0.
(read-bac
k)
L
et
T

G
b
e
any
sharing
gr
aph
r
e
duc-
tion,
e.g.,
an
optimal
one
obtaine
d
by
applying
rules
c
ontaine
d
in
the
set
in
Figur
e
.	
only.
(i)
The
-rules
ar
e
str
ongly
normalizing
and
c
onuent
on
G.
(ii)
The
unique
normal-form
of
G,
say
the
read-bac
k
of
G,
is
a
-tr
e
e
R(G)
such
that
T


R(G).
Pr
o
of
Then
rst
item
is
an
immediate
consequence
of
Prop
osition
..
and
Prop
osition
.	..
The
second
item
is
just
a
restatemen
t
of
Theo-
rem
.	..


Other
translations
in
Sharing
Graphs
The
enco
ding
of
-terms
in
to
sharing
graphs
whic
h
ha
v
e
b
een
presen
ted
in
this
b
o
ok
is
not
the
original
one
prop
osed
b
y
Lamping.
There
are
sev
eral
imp
ortan
t
reasons
for
departing
from
Lamping's
approac
h.
First
of
all,
his
algorithm
con
tained
a
lot
of
\optimization"
rules
whic
h
hide
the
core
of
the
issue,
prev
en
ting
an
y
sensible
theoretical
foundation
of
this
implemen
tation
tec
hnique
y
.
Secondly
,
our
presen
tation
is
aimed
to
stress
the
relation
b
et
w
een
optimal
reduction
and
Linear
Logic
that
is
one
of
the
most
in
triguing
and
suggestiv
e
asp
ects
of
this
implemen
tatio
n
of
the
-calculus.
Actually
,
since
Lamping's
seminal
w
ork
[Lam	0
]
on
optimal
graph
reduction
tec
hniques
for
-calculus,
sev
eral
dieren
t
translations
based
on
the
same
set
of
con
trol
op
erators
(sharing
graphs)
ha
v
e
b
een
pro-
p
osed
in
literature.
Lamping's
approac
h
w
as
revisited
for
the
rst
time
in
[GAL	a
],
where
a
restricted
set
of
con
trol
op
erators
and
reduction
rules
w
as
pro
v
ed
sucien
t
for
the
implem
en
tation.
In
the
same
pap
er,
an
in
teresting
and
quite
o
dd
notation
w
as
in
tro
duced
(the
so
called
\bus
notation"),
with
the
aim
to
further
minimi
ze
the
n
um
b
er
of
reduction
rules.
In
[GAL	b
]
the
same
authors
p
oin
ted
out
a
strong
analogy
b
e-
t
w
een
optimal
reductions
and
Linear
Logic
[Gir
],
already
hin
ted
to
in
their
previous
pap
er.
By
their
enco
ding
of
Linear
Logic
in
sharing
graphs,
and
some
enco
ding
of
-calculus
in
Linear
Logic,
a
third
(sligh
tly
dieren
t)
translation
w
as
implicitly
obtained.
This
enco
ding
has
b
een
used
(and
explicited)
in
[AL	a
],
in
the
m
uc
h
more
general
case
of
In-
teraction
Systems.
In
the
same
pap
er,
the
authors
p
oin
ted
out
that
Lamping's
con
trol
no
des
could
b
e
considered
as
a
v
ery
abstract
set
of
op
erators
for
implemen
ting
(optimal)
sharing
in
virtually
ev
ery
class
of
y
W
e
shall
discuss
these
rules,
whic
h
are
essential
in
view
of
an
actual
implemen
ta-
tion,
in
Chapter
	,
where
w
e
shall
in
tro
duce
the
crucial
notion
of
safe
op
erator.


.
Intr
o
duction

higher
order
rewriting
systems.
This
suggested
the
name
of
\sharing
graphs",
that
has
b
een
adopted
henceforth.
The
translation
used
in
this
b
o
ok
w
as
rst
dened
in
[GAL	b
];
the
main
p
oin
t
of
this
translation
w
as
its
close
relation
with
dynamic
alge-
bras
and
the
Geometry
of
In
teraction
for
Linear
Logic,
whic
h
has
b
een
fully
exploited
in
the
previous
c
hapter.
The
aim
of
this
c
hapter
is
to
clarify
the
relations
b
et
w
een
all
this
dieren
t
translations
of
-calculus
in
to
sharing
graphs.
W
e
shall
do
this,
b
y
passing
through
the
\bus
notation",
that
will
also
giv
e
us
the
opp
ortunit
y
to
shed
some
more
ligh
t
on
v
ery
in
teresting
prop
erties
of
this
(somewhat
neglected)
notation.
.
In
tro
ducti
on
The
somewhat
puzzling
n
um
b
er
of
dieren
t
translations
of
-calculus
in
sharing
graphs
is
actually
due
to
a
double
lev
el
of
indeterminacy
.
As
w
e
p
oin
ted
out
sev
eral
times
when
discussing
the
relation
with
Linear
Logic,
the
real
problem
of
this
implemen
tation
tec
hnique
is
the
optimal
sharing
of
the
b
o
x
of
Linear
Logic
[GAL	b
].
So,
w
e
ha
v
e
a
double
problem,
here:

ho
w
to
represen
t
a
b
o
x
in
sharing
graphs;

where
to
put
b
o
xes,
in
the
enco
ding
of
a
-term.
Let
us
briey
discuss
the
last
p
oin
t,
rst.
Ob
viously
,
this
problem
has
v
ery
little
to
do
with
optimal
reduction:
the
real
question,
here,
is
ho
w
do
w
e
enco
de
a
-term
in
Linear
Logic.
The
solution
adopted
so
far
in
this
b
o
ok
is
based
on
the
w
ell
kno
wn
decomp
osition
of
the
in
tuitionistic
implication
A
!
B
as
!(A)
(
B,
imp
osing
moreo
v
er
the
t
yp
e-isomorphism
D

=
!(D)
(
D.
Ho
w
ev
er,
this
is
not
the
only
solu-
tion:
for
instance,
another
approac
h
is
based
on
the
t
yp
e
isomorphism
D

=
!(D
(
D).In
this
case,
a
-term
M
with
free
v
ariable
in
x

;
:
:
:
;
x
n
is
translated
in
to
a
pro
of
of
x

:
D;
:
:
:
x
n
:
D
`
M
:
D
A
v
ariable,
is
just
an
axiom
x
:
D
`
x
:
D


Other
tr
anslations
in
Sharing
Gr
aphs
F
or
-abstraction,
w
e
rst
mak
e
a
linear
abstraction,
and
then
w
e
build
a
b
o
x
around
the
so
obtained
function:
x

:
D;
:
:
:
;
x
n-
:
D;
x
n
:
D
`
M
:
D
x

:
D

=
!(D
(
D);
:
:
:
;
x
n-
:
D

=
!(D
(
D)
`
x
n
:M
:
D
(
D
x

:
D

=
!(D
(
D);
:
:
:
;
x
n-
:
D

=
!(D
(
D)
`
x
n
:M
:
D

=
!(D
(
D)
F
or
application,
w
e
apply
the
left
in
tro
duction
rule
for
linear
implication,
and
then
w
e
mak
e
a
dereliction
on
the
new
assumption:
x

:
D;
:
:
:
;
x
n
:
D
`
N
:
D
y

:
D;
y

:
D;
:
:
:
;
y
m
:
D
`
M
:
D
z
:
D
(
D;
x

:
D;
:
:
:
;
x
n
:
D;
y

:
D;
:
:
:
y
m
:
D
`
M[
(z
N)
=
y

]
:
D
z
:
D

=
!(D
(
D);
x

:
D;
:
:
:
;
x
n
:
D;
y

:
D;
:
:
:
y
m
:
D
`
M[
(z
N)
=
y

]
:
D
According
to
our
represen
tation
of
pro
of
nets
in
to
sharing
graphs,
this
w
ould
giv
e
rise
to
the
enco
ding
in
Figure
.
(where,
as
usual,
[M]
=
[M]
0
).
[x]n = 
= 
λ
[   x.M]n
n
n
[M]n+1
λ
. . .
n+1
[MN]n = 
n
[M]n
[N]n
. . .
. . .
*
n
@ n
Fig.
..
Another
enco
ding
of
-terms
in
sharing
graphs
Man
y
other
enco
dings
of
-terms
in
to
linear
logic
can
b
e
dened,
and
eac
h
of
them
w
ould
pro
vide
a
dieren
t
initial
represen
tation
in
to
sharing
graphs.
The
in
teresting
fact
is
that
all
these
represen
tations
w
ould
giv
e
rise
to
(dieren
t)
optimal
reductions
of
the
-term,
do
to
the
optimal
implemen
tation
of
the
underlying
Linear
Logic.

.
Intr
o
duction
	
The
more
in
teresting
asp
ect
of
the
enco
ding
is
ho
w
ev
er
the
represen
ta-
tion
of
the
b
o
x
in
sharing
graph.
The
solution
considered
so
far
consists
in
raising
of
one
lev
el
the
in
ternal
structure
M
of
the
b
o
x
w.r.t.
the
surrounding
w
orld
(see
Figure
.(a)).
A
p
ossible
alternativ
e
is
to
use
a
more
explicit
notation,
enclosing
M
in
to
a
set
of
con
trol
no
des
(brac
k
ets
of
lev
el
0)
delimiting
the
exten
t
of
the
b
o
x
(see
Figure
.(b)).
[M]n+1
. . .
. . .
[M]
0
0
0
(a)
(b)
Fig.
..
Bo
x
represen
tations
in
sharing
graphs
In
tuitiv
ely
,
this
approac
h
is
somewhat
dual
to
the
former:
it
is
not
the
b
o
x
to
b
e
raised
of
one
lev
el,
but
the
surrounding
w
orld,
b
y
the
implicit
eect
of
the
brac
k
ets
of
lev
el
0
whic
h
ha
v
e
b
een
added
to
the
graph.
Note
in
particular
that
w
e
do
not
need
indexes
an
y
more
during
the
translation,
since
b
oth
the
con
text
and
the
in
ternal
region
of
the
b
o
x
are
(apparen
tly)
at
a
same
lev
el,
sa
y
0.
The
con
trol
op
erators
require
no
w
some
care.
F
or
instance,
the
crois-
san
t,
whic
h
corresp
onds
to
a
dereliction,
is
supp
osed
to
op
en
the
b
o
x,
so
w
e
should
add
a
brac
k
et
of
index
0
to
annihilate
the
analogous
op
erator
on
the
input
of
the
b
o
x;
moreo
v
er,
since
it
m
ust
propagate
inside
the
b
o
x
(whic
h
is
at
lev
el
0,
no
w),
w
e
shall
translate
the
croissan
t
at
lev
el
.
Similarly
,
a
fan
op
en
the
b
o
x
but
imm
ediately
closes
it
again,
and
a
brac
k
et
op
en
the
b
o
x
and
create
t
w
o
new
b
o
xes
around
the
term.
So,
according
to
our
in
tuition,
the
three
con
trol
op
erators
should
b
e
no
w
represen
ted
as
describ
ed
in
Figure
..
1
0
0
0
0
1
*
1
0
0
0
Fig.
..
The
con
trol
op
erators,
revisited

0
Other
tr
anslations
in
Sharing
Gr
aphs
Putting
together
these
ideas,
and
eliminating
all
pairs
of
in
teracting
squares
of
lev
el
0,
w
e
get
the
translation
of
Figure
.
(for
closed
terms).
= 
[x]
1
= 
λ
[   x.M]
= 
[MN]
@ 0
λ0
[M]
. . .
0
. . .
. . .
[M]
[N]
*
0
1
1
1
Fig.
..
Still
another
enco
ding
of
the
-calculus
In
the
follo
wing,
w
e
shall
denote
b
y
F
(M)
the
graph
generated
b
y
the
translation
of
the
term
M
according
to
Figure
.,
and
use
G
(M)
for
denoting
our
usual
enco
ding.
It
is
w
orth
noticing
that
the
op
erational
b
eha
vior
is
sensibly
dieren
t
in
the
t
w
o
cases.
In
particular,
in
G
(M),
the
(external)
con
trol
op
era-
tors
whic
h
are
propagating
inside
the
b
o
x
are
at
a
lo
w
er
lev
el
than
the
op
erators
inside
the
b
o
x.
The
con
trary
happ
ens
in
[GAL	b
]
where
the
square
brac
k
et
of
index
0
on
the
principal
p
ort
of
the
b
o
x
has
the
eect
to
raise
the
lev
el
of
incoming
con
trol
op
erators,
a
v
oiding
their
conict
with
inner
op
erators
prop
er
to
the
b
o
x.
Due
to
this
consideration,
it
can
app
ear
a
bit
surprising
that
exactly
the
same
set
of
r
ewriting
rules
w
orks
in
b
oth
cases.
Moreo
v
er,
apart
the
ab
o
v
e
informal
discussion
on
the
idea
underlying
the
t
w
o
b
o
x
represen
tations
(i.e.,
their
dieren
t
w
a
ys
to
a
v
oid
conicts),
there
is
a
priori
no
m
uc
h
evidence
of
a
formal
corresp
ondence
b
et
w
een
them.
This
is
exactly
the
issue
that
w
e
shall
address
in
the
follo
wing
sections.
T
o
this
purp
ose,
it
is
con
v
enien
t
to
use
an
in
teresting
notation,
in
tro
duced
for
the
rst
time
in
[GAL	a
]:
the
bus
notation.

.
The
bus
notation

Exercise
..
Giv
e
the
translation
based
on
the
isomorphism
D

=
!(D
(
D)
using
the
b
o
x
represen
tation
of
G
(M).
.
The
bus
notation
An
alternativ
e
and
v
ery
suggestiv
e
graph
notation
for
sharing
graphs
is
obtained
b
y
in
terpreting
wires
in
the
systems
G
(M)
and
F
(M)
as
buses,
namely
set
of
wires.
In
this
view,
an
i-indexed
no
de
is
considered
as
an
op
erator
acting
on
the
wire
at
depth
i
(see
Figure
.,
where
i
-
means
a
bus
of
width
i).
i
i
j
i
becomes
becomes
*
*
i
i
j
becomes
i
j
Fig.
..
The
con
trol
op
erators,
revisited
The
rules
go
v
erning
the
in
teraction
of
con
trol
no
des
in
the
bus
nota-
tion
are
depicted
in
Figure
..
Remark
that
no
in
teraction
b
et
w
een
croissan
ts
or
brac
k
ets
on
dieren
t
wires
is
dened,
just
b
ecause
it
is
implicit
in
the
notation.
On
the
other
side,
in
teractions
with
fans
are
no
more
lo
cal,
but
concern
the
whole
bus.
.
The
bus
notation
of
the
translation
F
T
rying
an
enco
ding
ad
liter
am
through
buses
of
the
translation
F
,
w
e
ma
y
immediately
realize
that
w
e
cannot
x
a
priori
the
dimension
of
the
bus
(w
e
shall
come
bac
k
so
on
to
this
p
oin
t).
F
or
the
momen
t,
after
ha
ving
xed
some
wire
\0",
w
e
shall
supp
ose
to
ha
v
e
an
innite
n
um
b
ers
of
wires
at
its
left.
The
resulting
translation
is
dened
b
y
the
function
B
F
in
Figure
.
(note
that
B
F
(M)
is
exactly
the
bus-coun
terpart
of
F
(M)).
Remark
that
B
F
(M)
uses
a
nite
numb
er
of
wires.
This
n
um
b
er


Other
tr
anslations
in
Sharing
Gr
aphs
*
*
*
*
*
*
*
*
*
*
*
*
Fig.
..
The
in
teractions
of
con
trol
no
des
in
bus
notation
dep
ends
on
the
syn
tactical
structure
of
the
term;
precisely
w
e
exactly
need
an
extra-wire
at
the
left
ev
ery
time
w
e
ha
v
e
a
(nested)
application.
Alternativ
ely
w
e
ma
y
add
an
index
to
the
translation
F
,
mimi
c
king
the

.
The
bus
notation
of
the
tr
anslation
F

B[M]
F
F
B[M]
F
B[N]
= 
F
*
. . .
. . .
@
B[x]
λ
= 
λ0
. . .
B[   x.M]
F
F
= 
B[MN]
Fig.
..
The
enco
ding
F
in
the
bus
notation.
denition
of
G
.
This
index
expresses
no
w
the
n
um
b
er
of
extra-wires
required
to
the
left
of
the
term
(see
Figure
.	).
It
is
p
ossible
to
a
v
oid
the
innite
(or,
in
an
y
case,
gro
wing)
n
um
b
er
of
wires
needed
during
the
translation
b
y
in
tro
ducing
suitable
op
erators
(square
brac
k
ets)
on
the
leftmost
wire.
The
resulting
translation
B
F
GAL
is
describ
ed
in
Figure
..
Remark
that,
in
B
F
GAL
,
the
bus
has
alw
a
ys
dimension
t
w
o
at
the
ro
ot
of
a
(sub-)term,
and
three
at
its
free
v
ariables.
The
purp
ose
of
the
t
w
o
brac
k
ets
added
on
the
leftmost
wire
is
exactly
that
of
\absorbing"
and
\recreating"
the
extra-wire
required
b
y
the
b
o
x.
This
enco
ding
w
as
used
for
the
rst
time
in
[GAL	a
]
(in
conjunction
with
a
translation
of
-
terms
in
to
Linear
logic
based
on
the
t
yp
e
isomorphism
D

=
!(D
(
D)).
The
relation
b
et
w
een
B
F
and
B
F
GAL
is
established
b
y
Theorem
..
b
elo
w.
F
ew
preliminary
prop
erties
ab
out
B
F
GAL
are
required.
Prop
osition
..
Counting
the
index
of
op
er
ators
fr
om
right
to
left,


Other
tr
anslations
in
Sharing
Gr
aphs
F
GAL = 
B[x]
λ
F
B[   x.M]GAL = 
F
GAL
B[M]
@
λ
. . .
*
. . .
. . .
F
GAL = 
B[MN]
F
F
GAL
GAL
B[M]
B[N]
Fig.
..
The
translation
function
B
F
GAL
the
no
des
lo
c
ate
d
on
the
leftmost
wir
e
never
mo
dify
the
index
of
other
no
des.
This
is
an
imm
ediate
consequence
of
the
shap
e
of
the
rules
in
Fig-
ure
..
Prop
osition
..
In
gr
aphs
r
esulting
by
the
r
e
duction
of
-terms
tr
ans-
late
d
ac
c
or
ding
to
B
F
GAL
,
the
only
op
er
ators
which
c
an
p
ossibly
app
e
ar
on
the
leftmost
wir
e
ar
e
br
ackets.
Mor
e
over
such
no
des
wil
l
always
r
emain
on
the
leftmost
wir
e.
Also
this
prop
ert
y
is
immediate
b
ecause
it
is
true
initially
,
and
it
is
ob
viously
preserv
ed
b
y
the
reduction
rules
in
Figure
..
Let
us
call
a
de
ad
lo
ck
a
pair
of
no
des,
one
in
fron
t
of
the
other,
that
do
not
in
teract
(i.e.,
no
rule
of
Figure
.
can
b
e
applied).
Remark
that
Prop
osition
..
guaran
tees
the
absence
of
deadlo
c
ks
on
the
leftmost
wires
of
graphs
obtained
b
y
the
reduction
of
B
F
GAL
(M).
Indeed,
the
only

.
The
c
orr
esp
ondenc
e
of
F
and
G

no
des
on
the
leftmost
wire
are
brac
k
ets
and
t
w
o
brac
k
ets,
one
in
fron
t
of
the
other,
can
b
e
simplied
b
y
the
second
rule
of
Figure
..
Lemma
..
Ther
e
exists
a
c
orr
esp
ondenc
e
b
etwe
en
the
evaluations
of
B
F
(M)
and
of
B
F
GAL
(M).
Such
c
orr
esp
ondenc
e
just
for
gets
the
no
des
on
the
leftmost
wir
es
of
B
F
GAL
and
the
r
e
ductions
c
onc
erning
them.
Indeed
there
exists
an
ob
vious
em
b
edding
from
B
F
(M)
to
B
F
GAL
(M),
whic
h
is
the
iden
tit
y
for
ev
ery
wire
except
the
leftmost
one.
This
em
b
ed-
ding
is
preserv
ed
b
y
rewritings.
In
particular
a
rewriting
not
in
v
olving
the
leftmost
wire
ma
y
b
e
p
erformed
b
oth
in
B
F
and
B
F
GAL
.
A
rewriting,
let
us
sa
y
r,
in
v
olving
the
leftmost
wire
concerns
only
B
F
GAL
.
But
r
do
es
not
mo
dify
the
em
b
edding
for
the
follo
wing
reasons:
(i)
r
do
es
not
c
hange
the
lev
el
of
no
des
lo
cated
on
wires
dieren
t
from
the
leftmost
(b
y
Prop
osition
..);
(ii)
r
nev
er
duplicates
no
des
on
wires
dieren
t
from
the
leftmost
(since,
b
y
Prop
osition
..,
a
fan
cannot
app
ear
on
the
leftmost
wire).
Recall
no
w
that,
in
sharing
graphs,
brac
k
ets
and
croissan
ts
are
used
only
with
the
purp
ose
to
guaran
tee
the
correct
matc
hing
of
fans
and
ab-
stractions/applications.
Lemma
..
implies
that
suc
h
matc
hings
are
p
erformed
in
the
same
w
a
y
b
oth
in
B
F
and
B
F
GAL
,
therefore
the
in
ter-
actions
of
fans
and
applications/abstractions
is
completely
insensible
to
the
remo
v
al
of
leftmost
brac
k
ets.
The
previous
remark
can
b
e
formalized
b
y
pro
ving
that
the
seman
tics
of
B
F
GAL
is
not
aected
b
y
the
remo
v
al
of
brac
k
ets
on
the
leftmost
wire,
i.e.,
that
consisten
t
paths
are
insensible
to
this
op
eration.
W
e
lea
v
e
the
pro
of
of
this
fact
as
an
easy
exercise
for
the
reader.
In
conjunction
with
Lemma
..,
w
e
immediately
get
the
follo
wing
result:
Theorem
..
The
r
emoval
of
no
des
on
the
leftmost
wir
es
of
B
F
GAL
has
no
sensible
ee
ct
on
the
evaluation
of
sharing
gr
aphs
and
on
their
semantics.
.
The
corresp
ondence
of
F
and
G
The
corresp
ondence
b
et
w
een
F
and
G
will
b
e
pro
v
ed
b
y
reasoning
again
on
the
bus-notation.
The
main
idea
underlying
the
pro
of
is:
inste
ad
of


Other
tr
anslations
in
Sharing
Gr
aphs
c
ounting
levels
fr
om
right
to
left,
let
us
c
ount
them
fr
om
left
to
right.
The
application
of
this
criterion
to
the
function
B
F
giv
es
B
F
;r
,
whic
h
is
describ
ed
in
Figure
.	
(w
e
assume
B
F
;r
(M)
=
B
F
;r
0
(M)).
j
F,r
B[M]
= 
*
. . .
. . .
@
B[x]j
F,r
j
λ
= 
λ
. . .
B[   x.M]j
F,r
j
j
j
= 
B[MN]
F,r
j
j
j
j
j
j
B[M]
B[N]
F,r
F,r
j
j+1
j
Fig.
.	.
The
translation
B
F
;r
On
the
other
hand,
the
bus
in
terpretation
B
G
of
G
(coun
ting
lev-
els
from
left
to
righ
t),
is
illustrated
in
Figure
.0
(as
usual
B
G
(M)
=
B
G
0
(M)).
No
w,
B
F
;r
only
diers
from
B
G
for
the
presence
of
some
extra-brac
k
ets
at
the
ro
ot
of
the
argumen
t
of
an
application
and
on
b
ound
v
ariables.
The
relation
b
et
w
een
B
F
;r
and
B
G
ma
y
b
e
xed
in
the
same
w
a
y
used
in
the
previous
section.
Lemma
..
Ther
e
exists
a
c
orr
esp
ondenc
e
b
etwe
en
the
evaluations
of
B
G
(M)
and
of
B
F
;r
(M).
Such
c
orr
esp
ondenc
e
just
for
gets
the
br
ackets
on
the
rightmost
wir
es
of
B
F
;r
and
the
r
e
ductions
c
onc
erning
them.
Establishing
the
ab
o
v
e
corresp
ondence
is
a
bit
less
ob
vious
than
for
Lemma
..,
b
ecause
of
the
presence
of
applications
and
abstractions

.
The
c
orr
esp
ondenc
e
of
F
and
G

= 
B[x]j
j
G
λ
= 
B[   x.M]j
G
j
B[MN]
G
*
. . .
. . .
= 
j
j
j
j
B[M]
B[N]
j
j+1
j
@
j
G
G
λ
j
. . .
j
j
j
B[M]
G
Fig.
.0.
The
bus
in
terpretation
of
the
translation
G
on
righ
tmost
wires.
In
particular,
what
could
in
v
alidate
the
lemma
is
the
ev
en
tual
presence
of
a
deadlo
c
k
b
et
w
een
a
brac
k
et
and
an
abstraction
(or
application)
no
de
on
the
righ
tmost
wire.
Note
ho
w
ev
er
that
there
exists
a
bijectiv
e
corresp
ondence
b
et
w
een
abstraction/application
no
des
and
brac
k
ets
on
righ
tmost
wires.
When
an
abstraction
no
de,
let
us
sa
y
m,
is
red
with
an
application,
call
it
n,
the
brac
k
et
corresp
onding
to
m
ev
en
tually
annihilates
against
the
brac
k
et
corresp
onding
to
n
(i.e.,
they
in
teract
through
the
second
rule
of
Figure
.).
Therefore
the
bijectiv
e
corresp
ondence
is
preserv
ed
b
y
reduction.
So,
w
e
can
conclude
the
follo
wing
prop
osition:
Prop
osition
..
If
a
gr
aph
is
obtaine
d
by
the
r
e
duction
of
B
F
;r
(M)
for
some
-term
M,
we
c
an
never
have
a
de
ad
lo
ck
b
etwe
en
abstr
actions
(applic
ations)
and
br
ackets.
Again,
it
is
easy
to
pro
v
e
that
consisten
t
paths
are
insensible
to
the


Other
tr
anslations
in
Sharing
Gr
aphs
remo
v
al
of
brac
k
ets
on
the
righ
tmost
wires.
This
fact
and
Lemma
..
imply:
Theorem
..
The
r
emoval
of
the
squar
e
br
ackets
on
the
rightmost
wir
es
of
B
F
;r
has
no
sensible
ee
ct
on
the
evaluation
of
sharing
gr
aphs
and
on
their
semantics.
.
Concluding
remarks
A
lot
of
dieren
t
enco
dings
of
-terms
in
to
sharing
graphs
are
p
ossible,
and
ha
v
e
b
een
actually
prop
osed
in
the
literature.
These
enco
dings
essen
tially
dier
from
eac
h
other
for
t
w
o
resp
ects:
the
w
a
y
-terms
are
em
b
edded
in
to
Linear
Logic,
and
the
w
a
y
used
for
coun
ting
lev
els
in
the
bus-represen
tation
of
the
graph
(ma
yb
e
adding
or
deleting
\absorption"
no
des
on
righ
tmost
and
leftmost
wires).
The
follo
wing
sc
hema
classies
the
main
translations
prop
osed
in
the
literature,
according
to
the
ab
o
v
e
criteria:
isomorphism
righ
t-to-left
bus
left-to-righ
t
D

=
(!D)
(
D
[AL	a]
[AL	a]
[Asp	
]
D

=
!(D
(
D)
[GAL	b
]
[GAL	a]
Fig.
..
Classication
of
translations

	
Safe
No
des
In
this
c
hapter,
w
e
shall
discuss
the
complex
problem
of
accum
ulation
of
con
trol
op
erators
(square
brac
k
ets
and
croissan
ts).
The
solution
w
e
shall
prop
ose
(based
on
the
so
called
safe
no
des)
is
not
y
et
quite
satis-
factory
from
the
theoretical
p
oin
t
of
view,
although
it
w
orks
prett
y
w
ell
in
practice.
In
particular,
our
\tagging"
metho
d
for
recognizing
safe
no
des
can
b
e
surely
impro
v
ed.
As
a
matter
of
fact,
the
accum
ulation
of
con
trol
op
erators
(and,
more
generally
,
the
denitiv
e
understanding
of
the
\oracle"
in
Lamping's
algorithm)
is
still
the
main
op
en
problem
of
this
tec
hnique.
	.
Accum
ulation
of
con
trol
op
erators
Let
us
consider
the
term
-term
(
I)
represen
ted
in
Figure
	.
(note
that
(
I)
!
I).
Its
reduction
starts
with
the
complete
duplication
of
the
iden
tit
y
(see
Figure
	.)
and
ends
up
with
the
graph
in
Figure
	.(a),
while
one
w
ould
ob
viously
exp
ect
to
arriv
e
to
the
conguration
in
Figure
	.(b).
Actually
,
these
t
w
o
graphs
are
equiv
alen
t
w.r.t.
the
standard
seman
tics
for
sharing
graphs
pro
vided
b
y
means
of
con
texts
[Lam	0
,
GAL	a
,
ADLR	
]
(in
tuitiv
ely
,
the
rst
one
con
tains
op
erators
that
op
en
and
then
temp
orarily
close
lev
els
that
are
nev
er
to
b
e
op
ened
again).
This
accum
ulation
of
\redundan
t"
con
trol
op
erators
(suc
h
as
in
the
rst
graph
ab
o
v
e)
is
the
main
source
of
ineciency
in
the
optimal
graph
reduction
tec
hnique.
F
or
instance,
iterating
once
more
the
application
of

to
the
\iden
tit
y"
of
Figure
	.(a),
the
computation
ends
up
with
the
\iden
tit
y"
of
Figure
	.,
and
so
on,
essen
tially
doubling
the
n
um
b
er
of
con
trol
op
erators
at
eac
h
new
application
of
.
In
particular,
in
the
graph
rewriting
system
considered
so
far,
the
	

	0
Safe
No
des
*
λ
@
@
λ
@
λ
0
0
0
0
0
0
1
1
0
1
0
2
1
1
Fig.
	..
-term
(
I)
0
1
0
1
λ0
2
0
λ1
1
@1
1
0
2
λ0
λ
0
0
λ1
1
λ
@
@
0
0
1
1
0
2
Fig.
	..
The
reduction
of
(
I)
0
1
0
2
λ0
1
λ
0
0
(a)
(b)
Fig.
	..
Tw
o
represen
tations
of
the
iden
tit
y

	.
A
c
cumulation
of
c
ontr
ol
op
er
ators
	
1
0
2
1
0
2
1
0
1
0
2
λ0
1
0
Fig.
	..
Another
represen
tation
of
the
iden
tit
y
in
sharing
graphs
reduction
of
the
-term
n:(n

I)
is
exp
onential
in
n
(note
that
inner-
most
reduction
is
linear!)
and
this
exp
onen
tial
b
eha
vior
is
merely
due
to
a
problem
of
accum
ulation
of
\redundan
t"
con
trol
op
erators
(see
the
b
enc
hmarks
at
the
end
of
this
c
hapter).
A
similar
problem
is
caused
b
y
fans
and
garbage.
Consider
for
in-
stance
the
reduction
of
the
term
I
0
=
x:(z:w:w
x
x),
represen
ted
in
Figure
	.
(note
again,
that
I
0
!
I).
*
1
0
1
0
0
@
@
0
0
λ0
λ
λ
0
0
0
*
1
0
1
0
λ
0
0
0
@0
λ0
*
1
0
1
0
0
0
λ0
Fig.
	..
The
reduction
of
x:(z:w:w
x
x)
Ev
en
if
w
e
remo
v
e
all
redundan
t
brac
k
ets
and
croissan
ts,
w
e
still
re-
main
with
the
conguration
in
Figure
	.,
that
con
tains
a
redundan
t
garbage-fan
pair.

	
Safe
No
des
0
*
0
λ0
Fig.
	..
Y
et
another
graph
for
the
iden
tit
y
Again,
these
spurious
no
des
can
easily
accum
ulate,
giving
rise
to
an
exp
onen
tial
explosion
of
the
reduction
time.
F
or
instance,
in
Figure
	.
w
e
giv
e
some
b
enc
hmarks
in
bohm
(our
protot
yping
implem
en
tation
of
Sharing
Graphs)
relativ
e
to
the
-term
f
=
n:(n

I
0
),
where
I
0
=
x:(z:w:w
x
x).
Note
the
exp
onen
tial
explosion
of
the
reduction
time
when
the
garbage
collector
is
\o
".
The
rst
and
ob
vious
consequence
of
this
fact
is
that
garbage
collection
is
essential
in
Lamping's
algorithm,
not
only
from
the
p
oin
t
of
view
of
memory
o
ccupation,
but
also
(and
esp
ecially)
for
eciency
reasons.
In
particular,
garbage
collection
should
b
e
p
erformed
as
so
on
as
p
ossible.
The
problem
is
that
the
ob
vious
garbage
collection
rules
(that
is,
the
rules
collecting
no
des
b
y
in
teraction
of
a
garbage
no
de
with
another
form
at
its
princip
al
p
ort)
are
not
enough
to
solv
e
the
previous
case.
W
e
shall
discuss
more
ab
out
garbage
collection
later
in
this
c
hapter
and
in
the
nal
Chapter.
	.
Eliminatin
g
redundan
t
information
W
e
are
th
us
in
terested
in
eliminating
as
m
uc
h
redundan
t
information
as
p
ossible.
Let
us
consider
for
instance
the
conguration
in
Figure
	..
W
e
immediately
realize
t
w
o
imp
ortan
t
prop
erties
of
suc
h
a
congura-
tion:
(i)
The
pair
of
con
trol
op
erators
can
b
e
alw
a
ys
propagated
together
through
other
op
erators
in
the
graph
(that
is,
they
can
b
e
re-
garded
as
a
unique
comp
ound
op
erator).
(ii)
The
total
eect
of
this
\comp
ound"
op
erator
on
the
no
des
they
act
up
on
is
n
ull
(in
the
sense
that
they
do
not
mo
dify
their
lev
el).

	.
Eliminating
r
e
dundant
information
	
Input
G.C.
on
G.C.
o
(f
one)
0.00
s.
0.00
s.
0
in
teractions

in
teractions

fan
in
t.

fan
in
t.
	
family
red.
	
family
red.
(f
three)
0.00
s.
0.00
s.
0
in
teractions

in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(f
v
e)
0.00
s.
0.00
s.
	
in
teractions

in
teractions

fan
in
t.
0
fan
in
t.

family
red.

family
red.
(f
sev
en)
0.00
s.
0.00
s.

in
teractions

in
teract.

fan
in
t.

fan
in
t.

family
red.

family
red.
(f
nine)
0.00
s.
0.0
s.

in
teractions

in
teractions

fan
in
t.
0
fan
in
t.

family
red.

family
red.
(f
elev
en)
0.00
s.
0.0
s.

in
teractions
0	
in
teractions
0
fan
in
t.
	
fan
in
t.
	
family
red.
	
family
red.
(f
thirteen)
0.00
s.
0.
s.

in
teractions
0
in
teractions

fan
in
t.
0
fan
in
t.

family
red.

family
red.
(f
fteen)
0.00
s.
0.
s.

in
teractions

in
teractions

fan
in
t.

fan
in
t

family
red.

family
red.
Fig.
	..
Garbage
collection:
b
enc
hmarks
for
f
=
n:(n

I
0
)
n+1
n
Fig.
	..
Croissan
t-brac
k
et
comp
ound
conguration

	
Safe
No
des
Recall
no
w
that
the
only
problem
of
the
optimal
reduction
tec
hnique
is
to
guaran
tee
the
correct
matc
hing
b
et
w
een
fan-in
and
fan-out.
Since
t
w
o
fans
matc
h
if
and
only
if
they
meet
at
the
same
lev
el,
and
the
\comp
ound"
conguration
ab
o
v
e
has
no
total
eect
on
lev
els,
the
natural
idea
w
ould
b
e
to
simply
remo
v
e
them
from
the
graph,
according
to
the
rewriting
rule
in
Figure
	.	.
n+1
n
Fig.
	.	.
Simplica
tion
of
a
croissan
t-brac
k
et
comp
ound
conguration
Unfortunately
,
the
rule
in
Figure
	.	
is
not
correct
in
general.
The
reason
is
v
ery
simple:
w
e
forgot
to
tak
e
in
to
accoun
t
the
p
ossible
anni-
hilation
of
the
innermost
op
erator,
as
describ
ed
b
y
the
critical
pair
in
Figure
	.0.
n+1
n
n
n
n+1
Fig.
	.0.
Critical
pair
Ob
viously
,
only
the
rst
reduction
is
correct,
while
the
second
one
could
easily
lead
to
wrong
and
irreducible
congurations.
Let
us
sho
w
that
this
can
actually
b
e
a
problem
in
practice.
Consider
the
term
x:I(I(x
P
))
I
where
I
is
the
iden
tit
y
and
P
is
an
arbitrary
term.
In
Figure
	.(a)
w
e
see
the
initial
translation
of
this
term.
By
applying
the
rule
in
Figure
	.	
to
this
graph
(see
the
dotted
region),
w
e
obtain
the
graph
in
Figure
	.(b).
As
w
e
shall
see,
this
simplication
is
harmless,
here.
Let
us
no
w
pro
ceed
in
the
reduction.
After
ring
three
-redexes
w
e
get
the
graph
in
Figure
	.(a).
No
w,
the
brac
k
et
tra
v
erses
the

(b)
and
the
lo
w
er
croissan
t
(c).
Fi-
nally
,
b
y
ring
the
last
-redex
w
e
get
our
critical
pair.
In
this
case,

	.
Eliminating
r
e
dundant
information
	
λ1
1
λ
@0
0
@
@
@
P
λ
λ1
1
0
0
1
0
2
2
0
1
λ1
1
λ
@0
0
@
@
@
P
λ
λ1
1
0
0
2
0
1
0
(b)
(a)
Fig.
	..
Reduction
of
x:I(I(x
P
))
I.
.
.
λ1
1
@
P
2
0
0
1
@
P
2
0
1
λ
0
0
1
2
@
P
2
0
1
λ
0
2
0
2
0
1
0
0
2
P
(a)
(b)
(c)
(d)
Fig.
	..
.
.
.
ending
with
a
critical
pair
applying
the
rule
of
Figure
	.	
in
the
dotted
region,
w
e
w
ould
get
a
deadlo
c
k
b
et
w
een
a
brac
k
et
and
a
croissan
t
at
the
same
lev
el.
Remark
	..
A
dieren
t
w
a
y
to
understand
the
v
ery
problematic
na-
ture
of
the
rule
in
Figure
	.	
is
b
y
noticing
that
its
natural
coun
terpart
in
dynamic
algebra
(namely
,
the
rule
t!(d)
=
)
is
inc
onsistent.
Indeed,
supp
ose
that
t!(d)
=
.
Since
t

t
=
,
w
e
ha
v
e
!(d)
=
t

,
and
!(t)
=
t

t!(t)
=
!(d)t!(t)
=
t!(!(d))!(t)

	
Safe
No
des
=
t!(t

)!(t)
=
t
Then,
let
us
tak
e
u
=
!(r

)t!(!(s)).
W
e
ha
v
e
that
u
=
t!(!(r

s))
=
0.
Moreo
v
er:
u
=
!(r

)!(t)!(!(s))
=
!(r

)(!(!(t))!(!(s))
=
!(r

)!(!(ts))
=
!(!(ts))!(r

)
whic
h
implies

=
!(!(ts))

!(!(ts))!(r

)!(r)
=
0
A
v
ery
similar
problem
is
p
osed
b
y
fan
and
garbage
no
des.
In
par-
ticular,
w
e
w
ould
b
e
tempted
to
add
the
rewriting
rule
in
Figure
	..
One
of
the
t
w
o
branc
hes
of
the
fan-in
has
b
ecome
garbage,
and
only
the
other
one
lo
oks
relev
an
t.
*
n
a
b
a
b
Fig.
	..
Simplica
tion
of
a
fan-garbage
comp
ound
conguration
Ho
w
ev
er,
in
this
case,
the
v
ery
\dangerous"
nature
of
this
rule
should
b
e
clear.
Again,
the
problem
is
that
the
fan-in
could
matc
h
with
some
other
fan-out
in
the
graph,
for
instance
as
in
the
example
sk
etc
hed
in
Figure
	..
In
terms
of
paths,
applying
the
ab
o
v
e
men
tioned
rule
to
the
fan-
garbage
at
the
top
in
Figure
	.
w
ould
cause
the
loss
of
the
needed
information
ab
out
the
correct
\con
tin
uation"
of
the
term
at
the
matc
h-
ing
fan
at
the
b
ottom.
In
the
rewriting
system,
this
corresp
onds
to
the
critical
pair
in
Fig-
ure
	..

	.
Safe
rules
	
*
*
Fig.
	..
Matc
hing
fans
in
v
olving
a
fan-garbage
comp
ound
pair
*
*
*
n
n
n
yes
no
Fig.
	..
Critical
pair
	.
Safe
rules
In
this
section
w
e
shall
giv
e
a
theoretical
c
haracterization
of
the
cases
in
whic
h
the
simplication
rules
previously
depicted
can
b
e
safely
applied.
In
the
next
section
w
e
will
ev
en
tually
see
ho
w
to
nd
a
w
eak
er
notion
of
safeness
applicable
in
practice.
W
e
sa
y
that
t
w
o
no
des
n

and
n

in
a
sharing
graph
G
match
along
a
(consisten
t)
path
,
if
there
exists
a
graph
G
0
suc
h
that
G

G
0
and
the
residual

0
of

in
G
0
is
an
annihilation
conguration
for
(the
residuals
of
)
n

and
n

.
Denition
	..
(safe)
A
sharing
op
erator
n
(fan,
croissan
t
or
brac
k
et)
in
a
sharing
graph
G
is
safe
if,
considering
an
y
consisten
t
path
of
G,
it
can
only
matc
h
with
itself.

	
Safe
No
des
Prop
osition
	..
The
rules
in
Figur
e
	.
ar
e
c
orr
e
ct
pr
ovide
d
the
lower
op
er
ator
is
safe.
Mor
e
over,
given
the
c
ongur
ations
in
the
rhs
of
rules
,,,,
when
the
lower
op
er
ator
is
safe,
the
upp
er
one
is
safe
to
o.
*
n
*
*
*
*
n
n
n
n
n
n
n
n+1
*
n
n
n
n
n+1
(3)
(2)
(5)
(6)
(1)
(4)
Fig.
	..
Safe
rules
Pr
o
of
As
w
e
already
noticed,
the
t
w
o
op
erators
in
the
righ
t
hand
side
of
these
rules
can
b
e
alw
a
ys
\propagated
together";
more
precisely
,
no
other
op
erator
orien
ted
in
the
same
direction
can
ev
er
app
ear
inside
the
path
connecting
them.
Let
us
note
no
w
that
the
only
w
a
y
to
annihilate
the
upp
er
op
erator
is
b
y
previously
annihilating
the
lo
w
er
one
(just
c
hec
k
the
lev
els).
Since
the
lo
w
er
op
erator
is
safe,
it
can
only
matc
h
with
itself.
As
a
consequence,
also
the
upp
er
op
erator
can
only
matc
h
with
itself;
th
us,
it
is
safe
to
o.
Vice-v
ersa,
if
the
lo
w
er
op
erator
is
annihilated,
it
can
b
e
ev
en
tually
follo
w
ed
b
y
an
annihilation
of
the
upp
er
one.
Finally
,
the
congurations
in
the
rhs
and
lhs
of
eac
h
rule
c
hange
the
lev
els
of
the
op
erators
they
are
propagated
through
in
an
iden
tical
w
a
y
.
So
they
cannot
alter
the
matc
hing
of
other
op
erators
in
the
graph,
and
hence
neither
the
structure
nor
the
consistency
of
paths.
The
in
teresting
problem,
that
will
b
e
addressed
to
in
the
next
section,
is
to
nd
a
simple
and
ecien
tly
computable
sucient
c
ondition
for
safeness
of
con
trol
op
erator.
Remark
	..
There
is
no
natural
w
a
y
of
orien
ting
rules

and
,
ab
o
v
e.
This
suggests
that
the
conguration
in
the
rhs
of
these
rules
should
b
e
more
correctly
reduced,
resp
ectiv
ely
,
to
a
unique
new
brac
k
et

	.
Safe
Op
er
ators
		
with
\w
eigh
t"

(and
index
n),
and
a
unique
new
fan
with
three
auxiliary
do
ors
(and
index
n).
Actually
,
al
l
con
trol
op
erators
can
b
e
uniformly
(and
protably)
describ
ed
as
a
unique
\p
olymorphic"
no
de
(sa
y
m
ulti-
plexer,
see
Chapter
).
Remark
	..
The
reader
with
a
categorical
bac
kground
should
ha
v
e
no
problem
in
recognizing
in
rules
-
ab
o
v
e
the
three
equations
for
the
comonad
\!".
Indeed,
w
e
already
established
a
relation
b
et
w
een
croissan
ts
and
brac
k
ets
and
the
t
w
o
natural
transformations

A
:
!(A)
!
A
and

A
:
!(A)
!
!!(A)
of
the
comonad
\!".
In
fact,
the
equations
c
haracterizing
the
comonad
are
precisely
the
follo
wing:
!(
A
)


!(A)
=
id
!(A)

!(A)


!(A)
=
id
!(A)
!(
!(A)
)


!(A)
=

!!(A)


!(A)
Similarly
,
equations
-
describ
e
the
comonad
structure
of
eac
h
exp
o-
nen
tial
t
yp
e
!(A).
The
in
teresting
fact
is
that
this
analogy
with
category
theory
w
as
actually
the
starting
p
oin
t
for
the
study
and
the
dev
elopmen
t
of
safe
op
erators
and
their
rewriting
rules
[Asp	
].
	.
Safe
Op
erators
W
e
shall
no
w
address
the
problem
of
recognizing
safe
op
erators.
In
particular,
w
e
shall
giv
e
an
easy
mec
hanism
for
marking
no
des
with
a
suitable
safeness
tag
(a
b
o
olean
indicating
if
it
is
safe
or
unsafe).
The
tag
is
just
a
sucien
t
condition
for
safeness,
i.e.,
a
no
de
with
a
tag
safe
is
ev
en
tually
safe,
but
a
safe
no
de
could
b
e
tagged
unsafe
(see
the
example
at
the
end
of
this
section).
The
problem
of
giving
a
precise,
op
erational
c
haracterization
of
safe
no
des
is
still
op
en.
In
spite
of
this
fact,
our
tagging
mec
hanism
lo
oks
as
a
quite
go
o
d
appro
ximation
of
safeness,
and
w
orks
prett
y
w
ell
on
practical
examples.
The
algorithm
for
tagging
no
des
is
the
follo
wing:
(i)
All
sharing
op
erators
are
initially
tagged
safe.
(ii)
Both
residuals
of
an
op
erator
in
teracting
with
a

no
de
are
tagged
unsafe.
(iii)
All
other
in
teraction
rules
preserv
e
the
tag
of
the
(ancestors
of
)
the
in
teracting
op
erators.
(iv)
Giv
en
the
congurations
in
the
lhs's
of
the
rules
in
Figure
	.,
if
the
lo
w
er
op
erator
is
tagged
safe,
the
upp
er
op
erator
can
b
e

00
Safe
No
des
tagged
safe
as
w
ell
(it
is
in
teresting
to
observ
e
that
suc
h
congu-
rations
can
b
e
dynamically
created
along
the
reduction).
Denition
	..
(t-safe)
An
op
erator
is
t-safe
if
it
is
tagged
safe.
The
rest
of
this
section
is
dev
ote
to
the
pro
of
of
the
follo
wing
theorem.
Theorem
	..
If
a
sharing
op
er
ator
is
t-safe,
then
it
is
safe.
The
pro
of
is
b
y
induction
on
the
length
of
the
reduction.
The
fact
that
all
op
erators
in
the
initial
graph
are
safe
is
an
immediate
consequence
of
Corollary
...
Moreo
v
er,
let
us
assume
that
at
a
giv
en
stage
of
the
computation
an
y
t-safe
op
erator
is
safe.
Item

of
the
ab
o
v
e
tagging
algorithm
is
an
ob
vious
consequence
of
Prop
osition
	...
Hence,
w
e
left
pro
v
e
that
the
tagging
algorithm
is
sound
with
resp
ect
to
the
application
of
an
y
graph
rewriting
rule.
First
of
all,
w
e
see
that
no
rule
can
c
hange
the
safeness
of
an
op
erator
not
in
v
olv
ed
in
the
rule,
since
consisten
t
paths
are
preserv
ed
along
the
reduction.
Then,
let
us
start
with
the
situations
in
whic
h
the
pro
of
is
trivial.
When
the
in
teraction
rule
in
v
olv
es
a
-no
de,
w
e
ha
v
e
nothing
to
pro
v
e.
A
t
the
same
time,
let
us
note
that
b
y
our
tagging
algorithm,
eac
h
t-safe
op
erator
is
ev
en
tually
\in"
(e.g.,
a
fan-in).
In
particular,
since
a
sharing
op
erator
in
teracting
with
an
application
is
\out"
(e.g.,
a
fan-out),
it
is
ev
en
tually
t-unsafe.
Th
us,
also
in
the
case
of
a
rule
in
v
olving
an
@-no
de
w
e
ha
v
e
nothing
to
pro
v
e.
When
a
safe
op
erator
in
teract
with
a
croissan
t
or
a
brac
k
et,
it
ob
vi-
ously
remains
safe,
b
y
the
uniqueness
of
the
residual.
The
only
non
trivial
case
is
th
us
the
case
of
a
safe
op
erator
in
teracting
with
a
fan.
That
is,
in
order
to
complete
the
pro
of
w
e
m
ust
sho
w
that:
Prop
osition
	..
Given
the
r
e
duction
in
Figur
e
	.,
if
the
sharing
op
er
ator
f
is
t-safe
b
efor
e
the
r
e
duction
(and
thus
safe,
by
induction
hyp
othesis),
then
b
oth
r
esiduals
of
f
ar
e
safe
after
the
r
e
duction.
Since
b
efore
the
reduction
in
Figure
	.
the
no
de
f
w
as
safe,
safeness
ma
y
b
e
lost
only
in
the
case
that,
carrying
on
reducing,
the
residuals
of
f
will
m
utually
annihilate.
Namely
,
the
t
w
o
residuals
of
f
are
unsafe
only
if
there
is
a
consisten
t
path
connecting
them
that
con
tracts
to
an
annihilation
redex.
In
order
to
pro
v
e
correctness
of
tagging,
w
e
ha
v
e
th
us
to
pro
v
e
that
situations
as
the
one
depicted
in
Figure
	.
cannot
arise.

	.
Safe
Op
er
ators
0
.   .   .
.   .   .
.   .   .
*
*
f
f
.   .   .
i
f
j
j
*
j
i
i
Fig.
	..
In
teraction
b
et
w
een
a
fan
and
a
safe
no
de
.   .   .
i
f
*
j
.   .   .
.   .   .
.   .   .
*
*
f
f
j
j
i
i
before
after
α
γ
γ
Fig.
	..
The
(inconsisten
t)
conguration
that
could
cause
loss
of
safeness.
First
of
all,
let
us
note
that
w
e
can
restrict
to
the
case
of
a
no
de
that
has
nev
er
b
een
t-unsafe.
The
idea
is
that
an
y
t-unsafe
no
de
has
to
touc
h
some
t-safe
op
erator
in
order
to
reset
its
unsafe
tag.
Hence,
w
e
exp
ect
that
either
a
no
de
has
alw
a
ys
b
een
t-safe
(i.e.,
without
an
y
t-unsafe
ancestor),
or
its
principal
p
ort
p
oin
ts
(or
b
etter,
has
p
oin
ted)
to
some
t-safe
op
erator.
Let
us
sa
y
that
a
path
f
0
:
:
:
f
k
is
a
comp
ound
t-safe
c
hain
when:
(i
)
an
y
no
de
in
the
path
is
t-safe;
(ii
)
for
i
=
0;
:
:
:
;
k
-
,
the
principal
p
ort
of
f
i
is
connected
to
an
auxiliary
p
ort
of
f
i+i
;
(iii
)
f
k
is
the
only
no
de
in
the
c
hain
that
has
alw
a
ys
b
een
t-safe.
W
e
see
that
the
notion
of
comp
ound
c
hain
of
t-safe
no
des
is
a
sort
of
particular
case
of
the
lhs's
of
the
rules
in
Figure
	.:
it
is
a
sequence
of
them
in
whic
h
the
fron
t
no
de
has
alw
a
ys
b
een
t-safe.
F
rom
the
reduction
p
oin
t
of
view,
w
e
already
remark
ed
that
suc
h
congurations
can
b
e
seen
as
comp
ound
no
des.
In
fact,
an
y
propagation
in
v
olving
the
rst
op
erator
f
k
in
the
c
hain
f
0
:
:
:
f
k
can
b
e
follo
w
ed
b
y
the
corresp
onding
propagations
of
all
the
op
erators
in
the
rest
of
the
c
hain.
This
also
explains
wh
y
w
e
could
not
b
e
able
to
construct
a
t-safe
c
hain
mo
ving
from
an
y
t-safe
op
erator
f
i
:
the
initial
part
f
i+
:
:
:
f
k
of
the
c
hain
migh
t
ha
v
e
in
teracted
with
some
no
de,
while
the
tail
f
0
:
:
:
ff
i
of
the
c
hain
is
still
w
aiting
to
do
so.
Nev
ertheless,
let
us
note
that,
when

0
Safe
No
des
the
in
teraction
w
as
with
a
,
all
the
c
hain
is
going
to
b
ecome
unsafe,
otherwise,
when
the
in
teraction
w
as
with
another
con
trol
no
de,
there
is
a
reduction
sequence
in
v
olving
con
trol
op
erators
only
that
will
recreate
(a
residual
of
)
the
original
t-safe
c
hain.
(W
e
in
vite
the
reader
to
formally
pro
v
e
the
previous
claim
doing
the
next
exercise.)
Exercise
	..
Pro
v
e
that,
for
an
y
t-safe
no
de
in
a
sharing
graph
G,
one
of
the
follo
wing
t
w
o
cases
holds:
(i)
There
is
a
reduction
G

G
0
in
v
olving
con
trol
no
des
only
suc
h
that
an
y
residual
of
f
is
con
tained
in
a
c
hain
f
0
:
:
:
f
k
of
t-safe
no
des
in
whic
h
f
k
has
alw
a
ys
b
een
t-safe.
(ii)
There
is
a
reduction
G

G
0
in
v
olving
con
trol
no
des
only
suc
h
that
an
y
residual
of
f
is
t-unsafe.
As
a
matter
of
fact,
in
the
rest
of
the
pro
of
of
Prop
osition
	..,
w
e
shall
this
a
prop
ert
y
to
restrict
our
atten
tion
to
the
case
of
a
no
de
that
has
alw
a
ys
b
een
t-safe.
So,
let's
go
bac
k
to
the
conguration
of
Figure
	..
Let

0
and

0
b
e
resp
ectiv
ely
the
ancestors
of

and
,
in
the
initial
graph.
Since
f
is
t-safe,
it
did
not
tra
v
erse
neither

nor
application
no
des
in

0
.
So,
all
unmatche
d

and
@
no
des
m
ust
b
e
orien
ted
with
their
principal
p
ort
to
w
ards
the
fan
and

0
m
ust
ha
v
e
the
structure
of
Figure
	.	.
@
@
@
λ
λ
λ
@
@
.   .   .
f
λ
λ
λ
γ ’
j
*
@
. . .
. . .
α’
c
Fig.
	.	.
Orien
tation
of
unmatche
d

and
@
no
des
in

0
.
In
particular,
for
ob
vious
p
olarit
y
reasons,

0
con
tains
at
least
an
unmatc
hed
-no
de.
In
the
follo
wing,
w
e
shall
consider
the
one
closest
to
f,
lab
eled
with
c
in
the
previous
picture.
No
w,
let
us
assume
that
that
the
residuals
of
f
matc
h
along
.
Then
f

	.
Safe
Op
er
ators
0
matc
hes
with
itself
along

0

0
(
0
)
r
.
But,
b
y
the
results
on
virtual
in
ter-
actions
(section
.),
w
e
kno
w
that
an
op
erator
in
the
initial
graph
can
only
matc
h
with
itself
along
a
path
comp
osed
b
y
a
calling
path,
follo
w
ed
b
y
an
@-cycle
and
a
return
path
(equal
to
the
rev
erted
calling
path).
Therefore,
w
e
ha
v
e
done
if
w
e
pro
v
e
that
a
path
with
this
structure
is
inconsisten
t
with
the
structure
of

0

0
(
0
)
r
.
The
idea
is
simple:
w
e
ha
v
e
to
pro
v
e
that
the

mark
ed
with
c
m
ust
ev
en
tually
b
elong
to
some
calling
path.
Indeed,
since
c
is
unmatc
hed
in

0
it
m
ust
ev
en
tually
b
e
matc
hed
b
y
an
application
in

0
.
So,
the
fan
b
elong
to
the
calling
path,
and
since
eac
h
calling
path
m
ust
b
e
ev
en
tually
asso
ciated
to
an
e
qual
return
path,
w
e
cannot
return
to
the
fan
from
a
dieren
t
auxiliary
p
orts.
Prop
osition
	..
L
et
'
b
e
an
@-cycle,
and

b
e
an
initial
se
gment
of
'
terminating
at
the
b
ound
p
ort
of
a
-no
de
l
which
is
unmatche
d
in

(we
c
onsider

as
a
dir
e
cte
d
p
ath).
If
it
exists
an
initial
c
ontext
for

that
do
es
not
c
ontain
any
#
symb
ol,
then
either
l
is
the
initial
no
de
of
a
c
al
ling
p
ath
or
l
was
pr
eviously
tr
averse
d
by

p
assing
fr
om
its
princip
al
to
its
b
o
dy
p
ort
(the
exiting
p
ort
is
for
c
e
d
ly
the
b
o
dy
p
ort,
due
to
the
assumptions
on
the
c
ontext).
Pr
o
of
By
induction
on
the
denition
of
@-cycle.
If
the
@-cycle
is
elemen-
tary
,
the
statemen
t
is
ob
vious
(due
to
the
assumptions
on
the
con
text,
the
only
w
a
y
w
e
ha
v
e
to
reac
h
a
v
ariable
is
b
y
tra
v
ersing
its
binder).
Let
us
come
to
the
inductiv
e
case.
Supp
ose
that
w
e
reac
h
a
free
v
ari-
able
inside
the
argumen
t
N
of
the
application
connected
to
some
-no
de
l.
If
l
is
unmatc
hed,
w
e
ha
v
e
done,
since
w
e
m
ust
ha
v
e
here
a
calling
path
b
y
denition
of
@-cycle.
Otherwise,
l
is
matc
hed,
so
w
e
jump
o
v
er
the
calling
path,
and
en
ter
another
@-cycle.
W
e
can
no
w
apply
the
in-
duction
h
yp
othesis
for
this
@-cycle
(indeed
no
#
sym
b
ol
can
ha
v
e
b
een
added
to
the
con
text,
so
far).
So
there
exists
a
no
de
l
0
with
the
desired
prop
erties
w.r.t.
the
in
ternal
@-cycle.
There
are
t
w
o
p
ossibilities:
either
l
0
is
unmatc
hed
in

(and
then
w
e
ha
v
e
done)
or
it
is
matc
hed.
In
the
latter
case,
it
is
ev
en
tually
matc
hed
inside
the
argumen
t
of
the
external
application.
This
means
that
w
e
ev
en
tually
complete
the
in
ternal
cycle,
come
bac
k
inside
N,
exit
from
the
argumen
t
of
the
matc
hing
application
and
start
tra
v
eling
do
wn
again.
If
w
e
reac
h
another
free
v
ariable
of
N,
w
e
rep
eat
the
reasoning
(again,
no
#
sym
b
ol
has
b
een
added).
Other-
wise,
w
e
reac
h
a
v
ariable
b
ound
inside
N,
but
then
w
e
forcedly
tra
v
ersed

0
Safe
No
des
its
binder
l
from
the
principal
to
the
b
o
dy
p
ort,
since
this
is
the
only
w
a
y
the
path
could
en
ter
inside
the
b
o
dy
of
l.
Corollary
	..
L
et
'
b
e
an
@-cycle,
and

b
e
an
initial
se
gment
of
'
terminating
at
the
b
ound
p
ort
of
a
-no
de
l
which
is
unmatche
d
in
.
If

do
es
not
tr
averse
unmatche
d
-no
des
then
l
is
the
initial
no
de
of
a
c
al
ling
p
ath.
Pr
o
of
If

do
es
not
tra
v
erse
unmatc
hed
-no
des
w
e
do
not
need
an
y
#
sym
b
ol
in
the
initial
con
text.
Then
apply
the
previous
prop
osition.
F
or
an
alternativ
e
and
more
formal
pro
of
of
the
correctness
of
our
tagging
tec
hnique
(using
prop
er
paths
a
la
Lamping),
the
reader
ma
y
consult
[A
C	
].
	.
Examples
and
Benc
hmarks
The
aim
of
this
section
is
to
sho
w
the
practical
relev
ance
of
the
safe
rules
b
y
comparing,
on
a
few
simple
examples
the
relativ
e
p
erformances
of
the
rewriting
system
with
and
without
them.
As
y
ou
will
see,
the
in
tro
duction
of
the
safe
rules
is
actually
something
more
than
a
mere
\optimization":
in
some
cases
it
mak
es
the
reduction
time
linear
in-
stead
of
exp
onen
tial.
With
these
additional
rules
(and
only
with
them),
Lamping's
tec
hnique
b
ecomes
really
comp
etitiv
e
with
resp
ect
to
more
traditional
implem
en
tation
tec
hniques.
The
b
enc
hmarks
refers
to
the
Bologna
Optimal
Higher-order
Ma-
c
hine
(bohm),
our
protot
yp
e
implemen
tation
of
(a
v
arian
t
of
)
Lamp-
ing's
graph
reduction
tec
hnique.
Although
bohm's
source
language
con-
stitutes
the
full
core
of
a
t
ypical
dynamically-t
yp
ed
lazy
functional
lan-
guage,
including
a
few
data
t
yp
es,
conditional
expressions,
recursiv
e
v
alues
and
lazy
pattern
matc
hing,
w
e
will
mainly
presen
t
examples
from
pure
-calculus,
here,
since
these
terms
are
particularly
w
ell
suited
to
in
v
estigate
the
problem
of
accum
ulation
of
con
trol
op
erators.
Moreo
v
er,
in
order
to
giv
e
a
gist
of
optimalit
y
and
its
actual
p
o
w
er,
w
e
shall
also
compare
bohm's
p
erformance
with
t
w
o
fully
dev
elop
ed
and
largely
dif-
fused
implemen
tations:
Caml
Ligh
t
0.
and
Y
ale
Hask
ell
Y.b-v
(see
Chapter

for
other
\real
w
ord"
b
enc
hmarks).
Our
rst
example
is
a
\primitiv
e
recursiv
e"
v
ersion
of
the
factorial
function
(on
Ch
urc
h
in
tegers).
def
Succ
=
\n.\x.\y.(x
(n
x
y));;

	.
Examples
and
Benchmarks
0
def
Mult
=
\n.\m.\x.(n
(m
x));;
def
Pair
=
\x.\y.\z.(z
x
y);;
def
Fst
=
\x.\y.x;;
def
Snd
=
\x.\y.y;;
def
Nextfact
=
\p.let
n
=
(p
Fst)
in
let
n
=
(Succ
(p
Snd))
in
(Pair
(Mult
n
n)
n);;
def
Fact
=
\n.(n
Nextfact
(Pair
one
zero)
Fst);;
Since
the
ev
aluation
in
bohm
stops
at
w
eak
head
normal
forms,
w
e
ha
v
e
to
supply
enough
argumen
ts
(iden
tities,
for
instance)
to
get
an
in-
teresting
computation.
The
result
of
the
test
is
in
Figure
	.0.
The
rst
column
of
the
table
is
the
input
term.
The
t
w
o
follo
wing
columns
resp
ec-
tiv
ely
refer
to
the
optimal
implem
en
tation
without
the
safe
rules
(bohm
0.0),
and
with
them
(bohm
.).
The
last
columns
refer
to
Caml
Ligh
t
and
Hask
ell,
resp
ectiv
ely
.
Eac
h
en
try
in
the
table
con
tains
the
user
time
required
for
reducing
the
input
b
y
eac
h
system
(on
a
Sun
Sparcstation
).
In
the
case
of
optimal
systems,
w
e
also
giv
e
the
n
um
b
er
of
fan
in
ter-
actions
(a
measure
of
the
complexit
y
of
the
abstract
algorithm),
as
w
ell
as
the
total
n
um
b
er
of
in
teractions
(i.e.,
of
elemen
tary
op
erations)
exe-
cuted
during
the
computation,
and
the
length
of
the
family
reduction.
The
latter
datum
is
the
n
um
b
er
of
redex-families
(i.e.,
optimal
ly
shar
e
d
-reductions)
required
for
normalizing
the
term.
This
is
the
same
as
the
total
n
um
b
er
of
in
teractions
b
et
w
een
application
and
lam
b
da
no
des
in
the
graph.
These
data
are
sligh
tly
dieren
t
in
the
t
w
o
v
ersions
of
bohm,
due
to
a
dieren
t
managemen
t
of
globally
dened
terms
(see
Chapter
).
The
impro
v
emen
t
pro
vided
b
y
the
safe
rules
is
amazing.
The
old
v
ersion
explo
des
for
input
sev
en,
Caml
Ligh
t
for
input
ten,
while
with
the
new
v
ersion
w
e
compute
the
factorial
of
t
w
en
t
y
in
0.
seconds.
Unfortunately
,
things
are
not
alw
a
ys
that
go
o
d
for
bohm.
Our
next
example
is
a
computation
of
the
Fib
onacci
sequence,
dened
as
follo
ws:
def
Add
=
\m.\n.\x.\y.(m
x
(n
x
y));;
def
Nextfibo
=
\p.let
n
=
(p
Fst)
in
let
n
=
(p
Snd)
in
(Pair
(Add
n
n)
n);;
def
Fibo
=
\n.(n
Nextfibo
(Pair
zero
one)
Fst);;
The
result
of
the
test
is
in
Figure
	..
Again,
there
is
a
substan
tial

0
Safe
No
des
Input
bohm
0.0
bohm
.
Caml
Ligh
t
Hask
ell
(fact
one
I
I)
0.00
s.
0.00
s.
0.00
s.
0.00
s.

in
teractions

in
teractions

fan
in
t.

fan
in
t.
0
family
red.
0
family
red.
(fact
three
I
I)
0.0
s.
0.00
s.
0.00
s.
0.0
s.

in
teractions

in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(fact
v
e
I
I)
0.
s.
0.00
s.
0.0
s.
0.0
s.

in
teractions
	
in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(fact
sev
en
I
I)
explo
des
0.0
s.
0.
s.
0.
s.
	
in
teractions
0
fan
in
t.

family
red.
(fact
nine
I
I)
0.0
s.
0.0
s.
explo
des
0
in
teractions
		
fan
in
t.

family
red.
(fact
ten
I
I)
0.0
s.
explo
des
0
in
teractions

fan
in
t.

family
red.
(fact
t
w
en
t
y
I
I)
0.
s.
0
in
teractions
	
fan
in
t.

family
red.
Fig.
	.0.
F
actorial
impro
v
emen
t
with
resp
ect
to
the
old
v
ersion,
but
in
this
case
Caml
Ligh
t
is
still
more
ecien
t.
Note
that
the
total
n
um
b
er
of
family
reductions
gro
ws
quadratically
in
the
case
of
the
factorial
function
while
it
gro
ws
as
Fib
onacci
for
the
Fib
onacci
function.
In
the
rst
case,
the
optimal
compiler
is
able
to
prot
of
the
big
amoun
t
of
sharing,
obtaining
v
ery
go
o
d
p
erformance
on
big
input
v
alues,
while
in
the
second
case
the
computation
is
already
in
trinsically
exp
onen
tial,
and
Caml
Ligh
t
tak
es
adv
an
tage
of
its
sim-
pler
abstract
reduction
mo
del,
a
v
oiding
b
o
ok-k
eeping
op
erations
that
in

	.
Examples
and
Benchmarks
0
Input
bohm
0.0
bohm
.
Caml
Ligh
t
Hask
ell
(b
o
one
I
I)
0.0
s.
0.00
s.
0.00
s.
0.00
s.

in
teractions

in
teractions

fan
in
t.

fan
in
t.
0
family
red.

family
red.
(b
o
four
I
I)
0.0
s.
0.00
s.
0.00
s.
0.0
s.

in
teractions

in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(b
o
sev
en
I
I)
0.	
s.
0.00s.
0.0
s.
0.0
s.
	
in
teractions
0
in
teractions
an
in
t.
0
fan
in
t.
	
family
red.
0
family
red.
(b
o
ten
I
I)
0.
s.
0.0
s.
0.0
s.
0.0
s.

in
teractions
	
in
teractions
0
fan
in
t.

fan
in
t.

family
red.

family
red.
(b
o
thirteen
I
I)
.0
s.
0.
s.
0.0
s.
0.
s.
0
in
teractions

in
teractions
0
fan
in
t.
	
fan
in
t.
	0
family
red.
	
family
red.
(b
o
sixteen
I
I)
explo
des
0.
s.
0.
s.
0.
s.

in
teractions

fan
in
t.

family
red.
(b
o
nineteen
I
I)
.
s.
0.
s.
.	
s.
	
in
teractions

fan
in
t.

family
red.
Fig.
	..
Fib
onacci
this
case
are
useless.
Note
in
particular
that
the
execution
time
in
the
Caml
Ligh
t
system
is
line
ar
in
the
n
um
b
er
of
family
reductions
(i.e.,
optimal
in
the
strongest
sense)
in
the
case
of
Fib
onacci,
so
this
term
is
surely
one
of
the
b
est
examples
we
c
ould
cho
ose
for
Caml
Light.
Ha
ving
considered
an
example
particularly
fa
v
orable
to
Caml
Ligh
t
and
other
standard
implemen
tation
mo
dels,
let
us
no
w
see
a
couple
of
examples
particularly
suited
to
Lamping's
tec
hnique.
Let
us
rst
consider
the
term
g
=
n:(n

I
I),
where

is
the
Ch
urc
h
n
umeral
represen
ting
the
n
um
b
er
,
and
I
is
the
iden
tit
y
.
In
this
case
(see

0
Safe
No
des
Figure
	.)
the
(new
v
ersion
of
the)
optimal
in
terpreter
w
orks
linearly
w.r.t.
its
input,
while
Caml
Ligh
t
and
Hask
ell
are
exp
onen
tial
(just
lik
e
the
old
implemen
tatio
n).
Input
bohm
0.0
bohm
.
Caml
Ligh
t
Hask
ell
(g
one)
0.00
s.
0.00
s.
0.00
s.
0.00
s.

in
teractions
0
in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(g
four)
0.00
s.
0.00
s.
0.00
s.
0.0
s.
0
in
teractions
	
in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(g
sev
en)
0.0
s.
0.00
s.
0.00
s.
0.0	
s.
0
in
teractions

in
teractions
0
fan
in
t.

fan
in
t.

family
red.

family
red.
(g
ten)
0.
0.00
s.
0.0
s.
0.0
s.

in
teractions
	
in
teractions
0
fan
in
t.
	
fan
in
t.

family
red.

family
red.
(g
thirteen)
explo
des
0.00
s.
0.0
s.
.
s.
0
in
teractions

fan
in
t.
	
family
red.
(g
sixteen)
0.00
s.
.0
s.
explo
des

in
teractions

fan
in
t.

family
red.
(g
nineteen)
0.00
s.
.
s.

in
teractions

fan
in
t.

family
red.
Fig.
	..
g
=

n.(n

I
I)
Things
are
ev
en
more
impressiv
e
if
w
e
consider
the
-term
f
=
n:(n


II).
Notice
that,
in
this
case,
the
n
um
b
er
of
fan
in
teractions
is
exp
onen
tial
in
the
n
um
b
er
of
family
reductions:
this
is
therefore
a
case
in
whic
h
the
abstract
algorithm
is
exp
onen
tial
in
L

evy's
complexit
y
measure.

	.
Examples
and
Benchmarks
0	
Input
bohm
0.0
bohm
.
Caml
Ligh
t
Hask
ell
(f
one)
0.00
s.
0.00
s.
0.00
s.
0.00
s.

in
teractions
0
in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(f
t
w
o)
0.00
s.
0.00
s.
0.00
s.
0.0
s.

in
teractions
	
in
teractions

fan
in
t.

fan
in
t.

family
red.

family
red.
(f
three)
0.0
s.
0.00
s.
0.00
s.
0.
s.
00
in
teractions
0
in
teractions
00
fan
in
t.

fan
in
t.

family
red.

family
red.
(f
four)
explo
des
0.00
s.
.0
s.
.0
s.

in
teractions
0
fan
in
t.

family
red.
(f
v
e)
explo
des
0.00
s.
explo
des
explo
des

in
teractions
	
fan
in
t.

family
red.
(f
six)
0.00
s.
0
in
teractions
0
fan
in
t.

family
red.
(f
ten)
.
s.
0
in
teractions

fan
in
t.

family
red.
Fig.
	..
f
=

n.(n

I
I)

0
Complexit
y
The
rst
results
ab
out
the
inheren
t
complexit
y
of
optimal
reduction
of
-
expressions
are
v
ery
recen
t,
and
this
topic
is
still
full
of
man
y
in
teresting
op
en
problems.
W
e
curren
tly
kno
w
that
the
cost
of
parallel
-reduction
is
not
b
ounded
b
y
an
y
Kalmar-elemen
tary
recursiv
e
function
[AM	
].
This
means
that
the
parallel
-step
is
not
ev
en
remotely
a
unit-cost
op
eration:
the
time
complexit
y
of
implemen
ting
a
sequence
of
n
par-
allel
-steps
is
not
b
ounded
as
O(
n
),
O(

n
),
O(


n
),
or
in
general,
O(K
`
(n))
where
K
`
(n)
is
a
xed
stac
k
of
`
's
with
an
n
on
top.
A
k
ey
insigh
t,
essen
tial
to
the
establishmen
t
of
this
nonelemen
tary
lo
w
er
b
ound,
is
that
an
y
simply-t
yp
ed
-term
can
b
e
reduced
to
normal
form
in
a
n
um
b
er
of
parallel
-steps
that
is
only
linear
in
the
length
of
the
explicitly-t
yp
ed
term.
The
result
then
follo
ws
from
Statman's
theorem
that
deciding
equiv
alence
of
t
yp
ed
-terms
is
not
elemen
tary
recursiv
e.
This
theorem
giv
es
a
lo
w
er
b
ound
on
the
w
ork
that
m
ust
b
e
done
b
y
any
tec
hnology
that
implemen
ts
L

evy's
notion
of
optimal
reduction.
So,
w
e
cannot
exp
ect
a
miracle
from
Lamping's
algorithm.
Y
et
this
sharing
tec
hnology
remains
a
leading
candidate
for
correct
ev
al-
uation
without
duplication
of
w
ork.
In
this
case,
the
close
complexit
y
analysis
of
sharing
graph
implemen
tation
just
impro
v
e
our
appreciation
of
its
v
ery
parsimonious
w
a
y
of
handling
sharing,
ev
en
if
parallel
-steps
are
ne
c
essarily
resource-in
tensiv
e.
0.
The
simply
t
yp
ed
case
A
k
ey
insigh
t,
essen
tial
to
the
establishmen
t
of
our
nonelemen
tary
lo
w
er
b
ound,
is
that
an
y
simply-t
yp
ed
-term
can
b
e
reduced
to
normal
form
in
a
n
um
b
er
of
parallel
-steps
that
is
only
linear
in
the
length
of
the
explicitly-t
yp
ed
term.
The
pro
of
of
this
claim
dep
ends
on
the
judicious
0

0.
The
simply
typ
e
d
c
ase

use
of
-exp
ansion
to
con
trol
the
n
um
b
er
of
parallel
-steps.
Not
only
do
es
-expansion
act
as
an
ac
c
ounting
me
chanism
that
allo
ws
us
to
see
order
in
the
graph
reduction,
it
moreo
v
er
serv
es
as
a
sort
of
optimizer
that
exc
hanges
the
w
ork
of
parallel
-reduction
for
the
w
ork
of
sharing.
Remark
ably
,
w
e
shall
pro
v
e
the
previous
result,
that
do
es
not
concern
any
sp
ecic
implemen
tatio
n,
b
y
making
a
v
ery
simple
use
of
Lamping's
tec
hnology
.
In
particular,
since
w
e
already
kno
w
that
this
graph
reduc-
tion
metho
d
is
algorithmicall
y
correct,
it
lets
us
w
ork
out
calculations
that
w
ould
b
e
virtually
imp
ossible,
and
certainly
inscrutable,
in
the
la-
b
elled
-calculus.
In
our
opinion,
this
mere
pro
of
is
already
enough
to
oer
a
go
o
d
justication
and
a
solid
theoretical
status
to
sharing
graphs.
0..
T
yping
L
amping's
rules
As
w
e
already
observ
ed
sev
eral
times,
Lamping's
graph
rewriting
rules
can
b
e
naturally
classied
in
t
w
o
main
groups:
(i)
the
rules
in
v
olving
application,
abstraction
and
sharing
no
des
(fan),
that
are
resp
onsible
for
-reduction
and
duplication
(this
is
what
w
e
call
the
abstr
act
algorithm);
(ii)
some
rules
in
v
olving
con
trol
no
des
(square
brac
k
ets
and
crois-
san
ts),
whic
h
are
merely
required
for
the
correct
application
of
the
rst
set
of
rules.
More
precisely
,
the
rst
set
of
rules
requires
an
\oracle"
to
discriminate
the
correct
in
teraction
rule
b
et
w
een
a
pair
of
fan-no
des;
the
second
set
of
rules
can
b
e
seen
as
an
eectiv
e
implemen
tation
of
this
oracle.
This
distinction
lo
oks
particularly
app
ealing
since
al
l
dieren
t
translations
prop
osed
in
the
literature
after
Lamping
[GAL	a
,
GAL	b
,
Asp	,
Asp	]
(see
Chapter
)
dier
from
eac
h
other
just
in
the
w
a
y
the
oracle
is
implem
en
ted
(in
the
sense
that
all
of
them
p
erform
exactly
the
same
set
of
abstract
reductions).
W
e
are
not
concerned
with
the
oracle,
here,
since
it
do
es
not
pla
y
an
y
role
in
our
pro
of
(y
ou
ma
y
just
supp
ose
the
existence
of
an
oracle,
and
not
ev
en
an
ee
ctive
one).
No
w,
in
the
simply
t
yp
ed
case,
Lamping's
abstract
rules
assume
the
shap
e
in
Figure
0..
The
general
idea
is
that
eac
h
edge
y
of
the
graph
is
lab
elled
with
a
suitable
t
yp
e
(in
the
pictures,
w
e
shall
usually
use
the
notation


in-
y
Instead
of
t
yping
edges,
w
e
could
equiv
alen
tly
t
yp
e
eac
h
p
ort
of
a
no
de
(adding,
moreo
v
er,
a
suitable
p
olarit
y).
Our
approac
h
has
b
een
essen
tially
adopted
for
t
yp
ographi
cal
reasons.


Complexity
λ
*
α      β
α      β
α      β
*
*
λ
λ
α      β
α      β
β
α
α
α
α
β
β
β
*
*
*
*
*
*
δ
δ
δ
δ
δ
δ
δ
δ
δ
δ
δ
δ
δ
*
*
δ
δ
α      β @
*
α      β
α      β
*
*
α      β
α      β
@
@
a
c
d
b
α
α
α
β
β
β
α
β
α      β
@
λ
β
α
β
α
α
β
δ
δ
δ
δ
δ
Fig.
0..
Lamping's
simply
t
yp
ed
rules.
stead
of

!
,
since
it
is
more
compact).
Let
us
remark
that
t
yp
es
do
not
pla
y
an
y
role
in
the
reduction
of
the
term;
they
are
just
an
ob
vious
in
v
arian
t
of
the
computation.
A
graph
is
w
ell
t
yp
ed
if
and
only
if
for
eac
h
no
de
n
in
the
graph,
the
t
yp
es
of
the
edges
connected
to
n
satisfy
the
constrain
ts
imp
osed
in
Figure
0..
@
*
λ
βα
βα
β
α
β
α
δ
δ
δ
Fig.
0..
W
ell
t
yp
ed
sharing
no
des.
Denition
0..
(t
yp
e
of
a
no
de)
The
typ
e
of
a
no
de
is
the
t
yp
e
of
the
edge
connected
to
its
principal
p
ort.

0.
The
simply
typ
e
d
c
ase

No
w,
w
e
can
already
state
the
main,
straigh
tforw
ard
but
crucial
prop-
ert
y
of
the
simply
t
yp
ed
case:
Prop
osition
0..
The
typ
e
of
fan-no
des
may
only
de
cr
e
ase
along
the
r
e
duction.
Pr
o
of
Just
lo
ok
at
the
t
yp
ed
in
teraction
rules
of
Figure
0..
In
other
w
ords,
the
o
w
of
fan
no
des
is
alw
a
ys
from
regions
of
higher
t
yp
e
to
regions
of
equal
or
lo
w
er
t
yp
e.
0..
The
-exp
ansion
metho
d
Giv
en
a
simply
t
yp
ed
-term
E,
w
e
sho
w
ho
w
to
construct
a
v
arian
t
E
0
that
is
-equiv
alen
t
to
E,
deriv
ed
b
y
in
tro
ducing
-exp
ansions
of
b
ound
v
ariables
in
E.
The
size
of
E
0
,
and
the
size
of
the
initial
sharing
graph
that
represen
ts
E
0
,
are
larger
than
E
b
y
only
a
small
constan
t
factor.
Moreo
v
er,
the
n
um
b
er
of
parallel
-steps
needed
to
normalize
E
0
is
linearly
b
ounded
b
y
its
size.
As
a
consequence,
w
e
demonstrate
that
the
normal
form
of
an
y
simply
t
yp
ed
-term
can
b
e
deriv
ed
in
a
linear
n
um
b
er
of
parallel
-steps.
In
order
to
mak
e
these
calculations
more
precise,
w
e
need
to
dene
what
w
e
mean
b
y
the
size
of
t
yp
es,
-terms,
and
graphs:
Denition
0..
(size)
W
e
dene
the
size
of
a
simple
typ
e
b
y
struc-
tural
induction:
j
joj
j
=

j
j
!
j
j
=

+
j
jj
j
+
j
jj
j:
Similarly
,
w
e
inductiv
ely
dene
the
size
of
a
simply-typ
e
d
term
as:
jxj
=
j
jj
j
if
x
has
t
yp
e

jx
:
:Ej
=

+
jEj
j(EF)j
=

+
jEj
+
jFj:
The
n
um
b
er
jEj
simply
coun
ts

for
eac
h

and
apply
in
E,
plus
j
jj
j
for
eac
h
v
ariable
of
t
yp
e
.
Finally
,
w
e
refer
to
the
size
[
[G]
]
of
a
sharing
gr
aph
G
as
the
n
um
b
er
of
its
no
des.
The
only
un
usual
feature
of
this
denition
is
that
the
size
of
a
v
ariable
is
giv
en
b
y
the
size
of
its
t
yp
e.
Had
w
e
instead
used
the
more
usual


Complexity
denitions
jxj
=

and
jx
:
:Ej
=

+
j
jj
j
+
jEj,
the
size
of
terms
w
ould
b
e
p
olynomial
ly
smaller,
but
only
b
y
a
quadratic
factor.
The
b
ound
w
e
pro
v
e
on
the
n
um
b
er
of
parallel
reductions
dep
ends
essen
tially
on
con
trolling
the
duplication
of

and
apply
no
des
b
y
sharing
no
des.
When
a
sharing
no
de
has
t
yp
e

!

and
faces
the
principal
p
ort
of
either
a
-no
de
or
an
apply
no
de,
duplication
creates
t
w
o
sharing
no
des,
of
t
yp
es

and

resp
ectiv
ely
.
If
the
v
alue
b
eing
shared
b
y
a
no
de
is
the
base
t
yp
e
o,
then
that
sharing
no
de
cannot
in
teract
with
a

or
apply
no
de,
since
the
principal
p
orts
of
those
no
des
cannot
sit
on
wires
that
are
at
base
t
yp
e|they
are
functions.
As
a
consequence,
eac
h
sharing
no
de
has
a
c
ap
acity
for
self-repro
duction
that
is
b
ounded
b
y
the
size
of
the
t
yp
e
of
the
v
alue
b
eing
shared.
The
idea
of
in
tro
ducing
-exp
ansion
is
to
force
a
no
de
sharing
a
v
alue
x
of
t
yp
e

to
the
base
t
yp
e
o,
b
y
making
that
no
de
duplicate
comp
onen
ts
of
the
graph
co
ding
the
-expansion
of
x.
This
tec
hnique
leads
to
an
ecien
t
ac
c
ounting
me
chanism
whic
h
b
ounds
the
duplication
of

and
apply
no
des
in
a
graph
reduction,
and
hence
b
ounds
the
n
um
b
er
of
par-
allel
-steps.
In
addition,
it
serv
es
as
a
lo
v
ely
optimization
metho
d,
where
parallel
-reduction
is
sim
ulated
b
y
the
in
teraction
b
et
w
een
shar-
ing
no
des
only.
Denition
0..
(-expansion)
Let
x
b
e
a
v
ariable
of
t
yp
e
.
The
-exp
ansion


(x)
of
x
is
the
t
yp
ed
-term
inductiv
ely
dened
on

as
follo
ws:

o
(x)
=
x



!!
k
!o
(x)
=
y

:


:
:
:
:
y
k
:

k
:x
(


(y

))
:
:
:
(

k
(y
k
))
In
the
graph
represen
tation,
eac
h
-expanded
v
ariable
is
co
ded
b
y
a
subgraph
with
t
w
o
distinguished
wires
that
w
e
resp
ectiv
ely
call
the
p
ositive
entry
and
the
ne
gative
entry
of
the
v
ariable
(see
Figure
0.).
When
the
v
ariable
is
of
base
t
yp
e
o,
this
subgraph
is
just
a
wire.
The
graph
represen
ting
an
-expanded
term
has
the
follo
wing
nice
prop
erties:
Lemma
0..
If
G
is
the
initial
sharing
gr
aph
r
epr
esenting


(x),
then
[
[G]
]

j
jj
j.
Pr
o
of
By
induction
on
.
Notice
that
if




!


!




k
!
o,
then
[
[G]
]
=
k
+
P
ik
[
[G

i
]
],
where
G

i
represen
ts


i
(y
i
).

0.
The
simply
typ
e
d
c
ase

α n
(y  )
n
η
α n
α 1
α 1
α n
σ
o
o
λ
+
yn
λ
@
@
y1
(y  )
η
1
-
-
-
+
+
σ
oo
(    )
oo
(    )
@
oo
(    )
oo
oo
oo
oo
λ
λ
λ
@
@
+
-
oo
(    )
o
o
o
o
(a)
(b)
Fig.
0..
(a)
-expansion;
(b)

(o!o)!o!o
(x).
Lemma
0..
L
et
x
b
e
a
variable
of
typ
e
,
and
let
G
b
e
the
gr
aph
r
epr
esenting


(x).
Then
in
an
optimal
r
e
duction,
any
sharing
of
G
at
the
p
ositive
or
ne
gative
entry
r
esults
in
a
r
esidual
gr
aph
(x)
wher
e
al
l
c
opies
of
the
sharing
no
de
ar
e
at
b
ase
typ
e,
and
[
[(x)]
]

j
jj
j.
y
Pr
o
of
The
pro
of
is
a
simple
induction
on
.
If

=
o,
the
conclusion
is
immediate
and
trivial|no
reductions
are
p
ossible,
b
ecause
G
is
just
a
single
wire.
Supp
ose

=


!
:
:
:
!

n
!
o.
Then
the
graph
G
co
ding


(x)
has
the
structure
depicted
in
Figure
0.(a),
with
n
-no
des
and
n
apply
no
des.
If
a
sharing
no
de
is
placed
at
the
p
ositive
en
try
,
that
no
de
will
duplicate
the
n
-no
des;
copies
of
the
sharing
no
de
will
mo
v
e
to
the
auxiliary
(non-in
teraction)
p
ort
of
the
top
apply
no
de,
whic
h
has
base
t
yp
e
o,
and
to
the
ne
gative
en
tries
of
the
subgraphs
G
i
represen
ting


i
(y
i
).
Dually
,
if
a
sharing
no
de
is
placed
at
the
ne
gative
en
try
,
that
no
de
will
duplicate
the
n
apply
no
des;
copies
of
the
sharing
no
de
will
mo
v
e
to
the
auxiliary
p
ort
of
the
top
-no
de,
whic
h
has
base
t
yp
e
o,
y
W
e
c
hose
the
notation
(x)
to
remind
the
reader
that
the
graph
is
dened
b
y
propagatin
g
the
sharing
no
des
(hence
the
)
to
base
t
yp
e.


Complexity
and
to
the
p
ositive
en
tries
of
the
subgraphs
G
i
represen
ting


i
(y
i
).
The
lemma
follo
ws
b
y
induction
on
the

i
.
(y  )
n
η
α n
α n
*
*
-
α 1
*
-
@
(y  )
η
1
-
+
σ
α 1
α 1
α n
o
α n
o
α n
α n
α 1
α n
*
*
α n
*
(y  )
n
η
-
+
α n
σ
λ
+
yn
λ
y1
σ
o
λ
+
yn
λ
y1
@
+
o
o
σ
o
o
λ
+
yn
λ
y1
@
@ α
α
1
1
@
@
-
+
(y  )
η
1
σ
σ
(1)
(2)
Fig.
0..
F
an
propagation
inside
(x).
Example
0..
The
graph
in
Figure
0.
sho
ws
the
duplication
of
(
(o!o)!o!o
(x))
b
y
a
single
sharing
no
de.
The
previous
lemma
ma
y
b
e
easily
generalized
to
an
arbitrary
tree
net-
w
ork
of
sharing
no
des,
or
equiv
alen
tly
,
the
t-fold
multiplexers
of
Guerrini
[Gue	
].
In
this
case,
the
duplicated
\sk
eleton"
of
the
sharing
graph
rep-
resen
ting


(x)
is
replicated
for
eac
h
instance
of
its
use
b
y
the
t
lea
v
es
of
the
m
ultiplexor.
Corollary
0..
L
et

t
(x)
b
e
the
r
esidual
gr
aph
that
r
esults
fr
om
the
sharing
of
the
gr
aph
r
epr
esenting


(x)
by
a
binary
tr
e
e
of
t
sharing
no
des.
Then
[
[
t
(x)]
]

(
+
t)j
jj
j.
In
the
initial
sharing
graph
co
ding
a
-term
x
:
:E,
m
ultiple
ref-
erences
to
the
b
ound
v
ariable
are
represen
ted
b
y
exactly
suc
h
a
tree

0.
The
simply
typ
e
d
c
ase

*
oo
oo
oo
No
No
oo
oo
@ oo
*
*
*
No
λ
λ
o
o
@
λ
λ
o
o
o
o
λ
@
o
@
o
o
o
o
o
o
o
Fig.
0..
Duplicati
on
of

(o!o)!o!o
(x).
net
w
ork
of
sharing
no
des.
This
tree
is
connected
to
the
(auxiliary)
pa-
rameter
p
ort
of
the
-no
de
that
represen
ts
the
binding.
Because
this
parameter
p
ort
is
not
a
primary
p
ort,
no
in
teraction
is
p
ossible
b
et
w
een
the
sharing
no
des
and
the
-no
de;
the
sharing
no
des
are
\stuc
k"
un
til
the
-no
de
is
annihilated
in
a
parallel
-reduction.
W
e
seek
to
con
trol
the
p
ossible
no
de
replication
that
could
result
from
suc
h
a
reduction,
b
y
forcing
the
-term
x
:
:E
to
b
e
applied
to


(x
0
).
W
e
ma
y
then
conclude
that
the
duplication
caused
b
y
a
sharing
no
de
is
prop
ortional
to
a
xed
function
of
the
size
of
the
initial
term,
and
is
not
aected
b
y
the
size
of
in
termediate
terms
in
the
reduction
sequence.
In
other
w
ords,
the
duplication
is
amenable
to
con
trol
via
static
analysis
of
the
initial
term.
These
in
tuitions
are
claried
in
the
follo
wing
denition.
Denition
0..	
(optimal
ro
ot)
Let
M
b
e
a
simply-t
yp
ed
-term.
The
optimal
r
o
ot
or(M)
of
M
is
deriv
ed
b
y
replacing
ev
ery
subterm
of
the
form
x
:
:E
with
x
0
:
:(x
:
:E


(x
0
)),
where

=
o
and
x
o
ccurs
more
than
once
in
E.
W
e
refer
to
the
new
-redexes
in
tro
duced
b
y
this
transformation
as
pr
eliminary
r
e
dexes.
It
should
b
e
clear
that
the
transformation
is
applied
at
most
once
to
an
y
subterm
x
:
:E.
Since
or(M)
is
obtained
b
y
M
b
y
means
of

and


Complexity
-expansions,
w
e
also
kno
w
that
M
=

or(M).
The
transformation
can
b
e
understo
o
d
as
duplicating,
once
and
for
all,
the
\sk
eleton"
of
this
term
that
describ
es
all
of
its
p
ossible
uses.
The
relev
an
t
information
ab
out
these
uses
is
pro
vided
unam
biguously
b
y
the
t
yp
e
.
Denition
0..0
W
e
dene
(M)
to
b
e
the
sharing
graph
obtained
from
or
(M)
b
y
reducing
all
of
the
preliminary
redexes,
and
propagating
all
sharing
no
des
to
the
base
t
yp
e.
W
e
emphasize
the
follo
wing
crucial
prop
ert
y
of
(M):
Lemma
0..
A
l
l
sharing
no
des
in
(M)
have
atomic
typ
es.
Pr
o
of
After
the
-reduction
of
all
preliminary
redexes,
all
sharing
no
des
are
p
ositioned
to
in
teract
at
the
p
ositiv
e
en
try
of
the
subgraphs
repre-
sen
ting
-expanded
v
ariables.
F
ollo
wing
these
essen
tially
structural
re-
ductions,
the
sharing
no
des
duplicate
these
subgraphs.
Lemma
0..
ensures
that
all
suc
h
sharing
no
des
can
propagate
to
base
t
yp
e.
Denition
0..
(trivial)
A
b
ound
v
ariable
is
trivial
in
a
t
yp
ed
-
term
if
it
is
at
base
t
yp
e,
or
o
ccurs
at
most
once.
A
t
yp
ed
-term
is
trivial
if
all
of
its
b
ound
v
ariables
are
trivial.
Lemma
0..
L
et
F

x
:
:E
b
e
a
nontrivial
term
wher
e
E
is
trivial.
Then
[
[(F)]
]

jFj.
Pr
o
of
Let
G
b
e
the
sharing
graph
co
ding
or(F)

x
0
:
:F(

(x
0
)),
and
let
G
0
b
e
deriv
ed
b
y
graph
reduction
of
the
outermost
-redex,
represen
ting
the
term
x
0
:
:E[

(x
0
)=x].
Assume
x
o
ccurs
t
times
in
E,
where
G
E
is
the
sharing
graph
represen
ting
E,
so
that
the
sharing
of


(x
0
)
is
represen
ted
in
G
0
b
y
a
tree
of
sharing
no
des
with
t
lea
v
es.
Since
[
[G
E
]
]
coun
ts
only
the
n
um
b
er
of
o
ccurrences
of

and
apply
in
E,
it
should
b
e
clear
that
[
[G
E
]
]

jEj
-
tj
jj
j.
T
o
construct
(F)
from
G
0
,
w
e
need
only
propagate
the
sharing
no
des
in
to
the
graph
represen
tation
of


(x
0
),
generating

t-
(x
0
)
with
size
at
most
(
+
t)j
jj
j,
b
y
Corollary
0...
Then
the
size
of
(F)
is
[
[(F)]
]


+
(jEj
-
tj
jj
j)
+
(
+
t)j
jj
j
=

+
jEj
+
j
jj
j
=
jFj
+
j
jj
j:
Ho
w
ev
er,
j
jj
j

jFj,
since
j
jj
j
just
coun
ts
the
con
tribution
of
one
o
ccur-
rence
of
x
in
F;
w
e
then
conclude
[
[(F)]
]

jFj.

0.
The
simply
typ
e
d
c
ase
	
Theorem
0..
L
et
F
b
e
a
simply-typ
e
d
-term.
Then
[
[(F)]
]

jFj.
Pr
o
of
The
pro
of
is
just
a
generalization
of
the
previous
lemma.
W
e
construct
(F)
b
y
insertion
of
the
same
preliminary
redexes,
reduction,
and
propagation
of
sharing
no
des
through
the
graphs
represen
ting


(x)
o
v
er
v
ariables
x
of
t
yp
e
.
Assume
without
loss
of
generalit
y
that
the
name
of
eac
h
b
ound
v
ariable
is
unique;
then
b
y
Corollary
0..,
[
[(F)]
]

0
@
jFj
-
X
x
:

x
non
trivial
(x)j
jj
j

A
+
0
@
X
x
:

x
non
trivial
(
+
(x))j
jj
j

A

jFj
+
0
@
X
x
:

x
non
trivial
j
jj
j

A
;
where
(x)
is
the
n
um
b
er
of
o
ccurrences
of
x
in
F.
When
(x)

,
only
(x)
-

sharing
no
des
are
needed
in
the
initial
graph
represen
tation.
Again,
it
is
clear
that
P
x
j
jj
j

jFj,
so
that
[
[(F)]
]

jFj.
The
reader
ma
y
b
e
b
othered
b
y
this
\linear"
b
ound,
whic
h
dep
ends
on
the
denition
of
the
size
function
jFj,
where
the
o
ccurrence
of
an
x
of
t
yp
e

con
tributes
j
jj
j
to
the
sum.
Supp
ose
w
e
had
instead
c
hosen
the
denition
of
size
as
(x)
=

(x
:
:E)
=

+
j
jj
j
+
(E)
(EF)
=

+
(E)
+
(F);
so
that
(E)
is
the
length
of
the
explicitly-t
yp
ed
term.
Since
it
is
not
hard
to
sho
w
that
jMj

(M)

,
w
e
w
ould
deriv
e
instead
[
[(F)]
]

(F)

as
the
statemen
t
of
the
previous
theorem.
The
signicance
of
either
inequalit
y
is
that
[
[(F)]
]
is
only
p
olynomial
in
jFj,
whic
h
is
a
go
o
d
enough
b
ound
to
deriv
e
our
more
imp
ortan
t
results.
As
an
ob
vious
consequence
of
Lemma
0..,
w
e
ha
v
e
the
follo
wing
imp
ortan
t
observ
ation.
Theorem
0..
The
total
numb
er
of
-r
e
ductions
(and
thus
of
fam-
ilies)
in
the
gr
aph
normalization
of
(M)
c
annot
exc
e
e
d
its
initial
size.
Pr
o
of
Since
all
sharing
no
des
ha
v
e
atomic
t
yp
es
in
(M),
they
can-
not
in
teract
with
abstractions
or
applications.
As
a
consequence,
no
new
application
or
-no
de
can
b
e
created
during
the
reduction.
Since

0
Complexity
-reduction
can
only
mak
e
the
graph
smal
ler
via
annihilation
of
comple-
men
tary

and
apply
no
des,
the
total
n
um
b
er
of
-reductions
is
b
ounded
b
y
the
initial
size
of
the
graph
(M).
If
(M)
is
considered
as
the
represen
tation
of
a
logical
pro
of
via
the
Curry-Ho
w
ard
analogy
,
with
the
ca
v
eat
that
some
sense
is
made
of
fan-
out,
it
giv
es
a
v
ery
in
teresting
\normal"
form,
where
all
logical
rules
are
\b
elo
w"
the
structural
ones.
This
pro
vides
for
some
computational
am
usemen
t:
one
can
imm
ediately
and
easily
remo
v
e
all
the
logical
cuts.
The
rest
of
the
computation
is
merely
structural|the
annihilation
or
duplication
of
sharing
no
des.
A
fundamen
tal
consequence
of
the
b
ound
on
the
n
um
b
er
of
redex
families
in
or
(M)
is
its
str
ong
normalization,
as
w
ell
as
the
strong
nor-
malization
of
M).
This
observ
ation
is
a
trivial
conseqeunce
of
Theo-
rem
0...
Theorem
0..
L
et

b
e
any
nite
(p
ossibly
p
ar
al
lel)
r
e
duction
of
a
term
M.
Then
any
r
e
duction

0
relativ
e
y
to

is
terminating.
Since
all
redexes
created
along
any
reduction
of
or
(M)
ev
en
tually
b
elong
to
some
of
its
famili
es,
an
y
reduction
strategy
is
terminating.
Theorem
0..
The
simply
typ
e
d
-c
alculus
is
str
ongly
normalizing.
Ev
en
more,
the
b
ound
on
the
reduction
is,
if
one
coun
ts
parallel
-
reduction
of
families,
merely
linear
in
the
length
of
the
initial
term.
0..
Simulating
generic
elementary-time
b
ounde
d
c
omputation
No
w
that
w
e
kno
w
that
the
normal
form
of
a
simply-t
yp
ed
-term
can
b
e
computed
in
a
linear
n
um
b
er
of
parallel
-steps,
the
next
goal
is
to
construct
a
generic
r
e
duction
from
the
largest
time
hierarc
h
y
w
e
can
manage
via
a
lo
gsp
ac
e
r
e
duction.
z
F
or
example,
if
w
e
can
sim
ulate
deter-
ministic
computations
in
dtime[
n
]
(deterministic
exp
onen
tial
time)
in
y

0
is
relativ
e
to

if
all
redexes
in

0
are
in
the
same
family
of
some
redex
in
,
see
Chapter
.
z
This
r
e
duction
is
just
a
compiler
that
tak
es
an
arbitrary
T
uring
Mac
hine
M
running
in
some
time
b
ound
t(n)
on
an
input
x
of
size
n,
and
pro
duces
a
t
yp
ed
-term
e
:
Bo
ol
suc
h
that
e
reduces
to
the
term
co
ding
true
i
M
accepts
x
in
f(n)
steps.
The
\logspace"
means
that
the
compiler
has
only
O(log
n)
bits
of
in
ternal
memory
to
carry
out
the
compilation,
ensuring
that
the
output
has
length
p
olynomial
in
n.

0.
The
simply
typ
e
d
c
ase

the
simply-t
yp
ed
-calculus,
where
the
initial
-term
corresp
onding
to
a
computation
has
length
b
ounded
b
y
a
xed
p
olynomial
in
n,
w
e
ma
y
then
conclude
that
the
parallel
-reduction
c
annot
b
e
unit
cost.
The
reason
is
simple:
w
ere
a
parallel
-step
implem
en
ted
in
unit
cost,
w
e
w
ould
ha
v
e
sho
wn
that
ptime
equals
dtime[
n
],
since
an
exp
onen
tial-
time
computation
on
an
input
of
size
n
can
b
e
compiled
in
to
a
short
(with
length
p
olynomial
in
n)
t
yp
ed
-term,
and
that
term
normalizes
in
a
p
olynomial
n
um
b
er
of
parallel
-steps
to
a
Bo
olean
v
alue
indicating
acceptance
or
rejection
of
the
input.
W
e
w
ould
then
ha
v
e
sim
ulated
an
exp
onen
tial-time
computation
in
p
olynomial
time,
and
this
conclusion
con
tradicts
the
time
hier
ar
chy
the
or
em
(see,
e.g.,
[HU	
]),
whic
h
asserts
that
p
olynomial
time
is
prop
erly
con
tained
in
exp
onen
tial
time.
x
In
fact,
for
an
y
in
teger
`

0,
w
e
can
construct
generic
reductions
of
this
kind
for
dtime[K
`
(n)].
The
consequence
is
that
the
cost
of
a
sequence
of
n
parallel
-steps
is
not
b
ounded
b
y
an
y
of
the
Kalmar-
elementary
r
e
cursive
functions
K
`
(n).
Observ
e
that
w
ere
the
cost
con-
tained
in
O(K
`
(n)),
then
b
y
sim
ulating
arbitrary
computations
in
dtime[K
`+
(n)],
and
requiring
only
O(n)
parallel
-steps
(via
the
-expansion
metho
d)
at
cost
O(K
`
(n)),
w
e
w
ould
ha
v
e
sho
wn
that
dtime[K
`
(n)]
equals
dtime[K
`+
(n)],
whic
h
is
again
con
tradicted
b
y
the
time
hierarc
h
y
the-
orem.
W
e
shall
not
en
ter
in
the
complex
and
tric
ky
details
of
enco
ding
T
ur-
ing
Mac
hines
in
the
simply
t
yp
ed

calculus,
but
w
e
shall
con
ten
t
our-
selv
es
with
pro
viding
the
main
ideas.
The
in
terested
reader
ma
y
consult
[Mai	
,
AM	].
Rather
than
co
de
directly
in
the
simply-t
yp
ed
-calculus
it
is
con-
v
enien
t
to
use
an
equiv
alen
tly
p
o
w
erful
logical
in
termediate
language:
higher-order
logic
o
v
er
a
nite
base
t
yp
e.
Denition
0..
Let
D

=
ftrue
;
false
g,
and
dene
D
t+
=
p
o
w
erset
(D
t
).
Let
x
t
;
y
t
;
z
t
b
e
v
ariables
allo
w
ed
to
range
o
v
er
the
elemen
ts
of
D
t
.
The
prime
formulas
of
the
logic
are
x
0
,
true

y

,
false

y

,
and
x
t

y
t+
.
A
form
ula
of
the
logic
is
an
y

built
up
out
of
prime
form
ulas,
the
usual
logical
connectiv
es
_,
^,
!,
:,
and
the
quan
tiers

and
	.
Mey
er
[Mey
]
pro
v
ed
that
the
problem
of
deciding
if
a
generic
form
ula

of
this
logic
is
true
under
the
usual
in
terpretation
requires
nonelemen-
tary
time.
x
Readers
familiar
with
the
diagonalization
tec
hnique
from
the
pro
of
of
undecid-
abilit
y
of
the
Halting
Problem
should
recognize
that
in
exp
onen
ti
al
time,
one
can
diagonalize
o
v
er
ev
ery
p
olynomia
l
time
computation
.


Complexity
The
relation
of
this
analysis
to
t
yp
ed
-calculus
w
as
originally
p
oin
ted
out
b
y
Statman
[Sta	
]
and
then
revisited
and
simplied
b
y
Mairson
[Mai	
].
As
a
matter
of
fact,
the
truth
of
form
ulas
in
this
logic
can
b
e
decided
b
y
compiling
them
in
to
short
t
yp
ed
-terms,
and
using
the
p
o
w
er
of
primitiv
e
recursion
to
realize
quan
tier
elimination
and
to
de-
cide
the
truth
of
prime
form
ulas.
In
particular,
primitiv
e
recursion
is
easily
implemen
ted
using
list
iter
ation,
a
straigh
tforw
ard
programming
tec
hnique
of
functional
programming.
The
main
result
is
the
follo
wing
[Mai	
,
AM	
]:
Theorem
0..	
A
formula

in
higher-or
der
lo
gic
over
the
nite
b
ase
typ
e
D

=
ftrue
;
false
g
is
true
if
and
only
if
its
typ
e
d
-c
alculus
interpr
etation
^

:
Bo
ol
is
-e
quivalent
to
true

x
:
:y
:
:x
:
Bo
ol.
Mor
e
over,
if

only
quanties
over
universes
D
i
for
i

k,
then
^

has
order
y
at
most
k,
and
if
we
also
write
jj
to
denote
the
length
of
lo
gic
formula
,
then
j
^
j
=
O(jj(k)!).
The
next
step
is
to
use
the
previous
logic
to
express
T
uring
Mac
hine
instan
taneous
descriptions
(IDs)
of
sucien
t
size,
and
to
compute
the
transitiv
e
closure
of
the
transition
relation
b
et
w
een
suc
h
IDs.
The
logical
co
ding
problems
that
ha
v
e
to
b
e
solv
ed
are
really
tric
ky
,
in
this
case
(see
[Mai	
,
AM	]).
Again
w
e
just
recall
the
main
results.
Theorem
0..0
L
et
M
b
e
a
xe
d
T
uring
Machine
that
ac
c
epts
or
r
eje
cts
an
input
x
in
K
`
(jxj)
steps.
Then
ther
e
exists
a
formula

x
in
higher-or
der
lo
gic
such
that
M
ac
c
epts
x
if
and
only
if

x
is
true.
Mor
e
over,

x
only
quanties
over
universes
D
i
for
i

(log

jxj)
+
`
+
,
and
j
x
j
=
O(jxj
log

jxj).
Corollary
0..
L
et
M
b
e
a
xe
d
T
uring
Machine
that
ac
c
epts
or
r
eje
cts
an
input
x
in
K
`
(jxj)
steps.
Then
ther
e
exists
a
typ
e
d
-term
^

x
:
Bo
ol
such
that
M
ac
c
epts
x
if
and
only
if
^

x
r
e
duc
es
to
true

x
:
:y
:
:x
:
Bo
ol
.
Mor
e
over,
the
b
ound
variables
in
^

x
have
or
der
O(log

jxj),
and
j
^

x
j
=
O(jxj
log
(c)
jxj)
for
any
xe
d
inte
ger
c
>
0.
y
The
or
der
of
a
t
yp
e
is
a
measure
of
its
higher-orde
r
functionalit
y:
order
(o)
=
0
order
(
!
)
=
max
f
+
order
();
order
()g:

0.
Sup
erp
osition
and
higher-or
der
sharing

Theorem
0..
Ther
e
exists
a
set
of
-terms
E
n
:
Bo
ol
which
nor-
malize
in
no
mor
e
than
n
p
ar
al
lel
-steps,
wher
e
the
time
ne
e
de
d
to
im-
plement
the
p
ar
al
lel
-steps,
on
an
y
rst-class
machine
mo
del
[vEB	0
]
(and
in
p
articular
for
L
amping's
algorithm),
gr
ows
as

(K
`
(n))
for
any
xe
d
inte
ger
`

0.
Corollary
0..
(Readbac
k
Lemma)
Ther
e
exists
a
set
of
shar-
ing
gr
aphs
G
n
wher
e
[
[G
n
]
]
is
b
ounde
d
by
a
smal
l
xe
d
p
olynomial
in
n,
G
n
c
ontains
no
-r
e
dexes,
the
-term
c
o
de
d
by
G
n
has
c
onstant
size,
and
the
c
omputational
work
r
e
quir
e
d
to
r
e
ad
b
ack
the
r
epr
esente
d
term
gr
ows
as

(K
`
(n))
for
any
xe
d
inte
ger
`

0.
W
e
remark
also
that
the
basic
theorem
giv
es
b
ounds
on
the
complex-
it
y
of
cut
elimination
in
m
ultiplicativ
e-exp
onen
tial
linear
logic
(MELL),
and
in
particular,
an
understanding
of
the
\linear
logic
without
b
o
xes"
formalism
in
[GAL	b
].
In
pro
of
nets
for
linear
logic
(see,
for
example,
[Laf	
]),
the
times
and
p
ar
connectiv
es
of
linear
logic
pla
y
essen
tially
the
same
role
as
apply
and

no
des
in
-calculus;
the
programming
syn-
c
hronization
implemen
ted
b
y
the
closur
e
has
its
coun
terpart
in
pro
of
net
b
oxes.
Just
as
Lamping's
tec
hnology
can
b
e
used
to
optimally
duplicate
closures,
it
can
b
e
used
to
optimally
share
b
o
xes.
Because
the
simply-
t
yp
ed
-calculus
is
happily
em
b
edded
in
m
ultipli
cativ
e-exp
onen
tial
logic,
w
e
get
similar
complexit
y
results:
small
pro
of
nets
with
p
olynomially-
b
ounded
n
um
b
er
of
cuts,
but
a
nonelemen
tary
n
um
b
er
of
\structural"
steps
to
resolv
e
pro
of
information
co
ded
b
y
sharing
no
des.
0.
Sup
erp
ositi
on
and
higher-order
sharing
The
analysis
of
the
previous
section
mak
es
it
v
ery
clear
that
the
paral-
lel
-step
is
not
ev
en
r
emotely
a
unit-cost
op
eration.
The
w
orkhorse
of
an
y
optimal
reduction
engine
is
not
the
parallel
-step,
but
the
b
o
ok-
k
eeping
o
v
erhead
of
sharing
redexes.
The
b
o
okk
eeping
m
ust
remem
b
er
which
redexes
are
b
eing
so
parsimoniously
shared,
and
wher
e
parallel
-reduction
tak
es
place.
W
e
used
Lamping's
tec
hnology
as
a
calculating
device
to
pro
v
e
a
theo-
rem
ab
out
all
p
ossible
implem
en
tations
of
optimal
ev
aluation.
Ho
w
ev
er,
it
is
w
orth
asking
the
follo
wing
question:
what
are
Lamping's
graphs
doing
to
so
clev
erly
enco
de
so
m
uc
h
sharing?
In
this
section,
w
e
discuss
t
w
o
essen
tial
phenomena
of
these
data
struc-
tures:
that
of
sup
erp
osition,
and
that
of
higher-or
der
sharing
(these
t
w
o


Complexity
notions
are
essen
tially
due
to
Mairson).
Sup
erp
osition
is
a
co
ding
tric
k
where
graphs
for
dieren
t
v
alues
{
for
example
true
and
false,
or
dier-
en
t
Ch
urc
h
n
umerals
{
are
represen
ted
b
y
a
single
graph.
Higher-order
sharing
is
a
device
where
sharing
no
des
can
b
e
used
to
co
de
other
shar-
ing
structures,
allo
wing
a
com
binatorial
explosion
in
the
size
of
graphs.
Both
of
these
tec
hniques
are
used
to
realize
the
generic
sim
ulations
of
the
previous
section.
0..
Sup
erp
osition
Here
is
a
really
simple
example
of
sup
erimp
osed
graphs:
the
co
ding
of
true
and
false:
λ
λ
true
λ
λ
false
*
*
*
λ
λ
true-or-false
Fig.
0..
Sup
erp
ositio
n
of
true
and
false
.
Notice
ho
w
the
?-sides
of
the
sharing
no
des
co
de
true
,
and
the
-sides
of
the
sharing
no
des
co
de
false.
The
t
w
o
terms
share
the
-no
des
that
serv
e
as
the
in
terface
to
the
external
con
text.
A
curious
consequence
of
this
sup
erp
osition
is
that,
for
example,
w
e
can
negate
b
oth
Bo
olean
v
alues
at
the
cost
usually
ascrib
ed
to
negating
only
one
of
them:
the
negation
function
merely
switc
hes
the
top
ological
p
osition
of
t
w
o
of
the
sharing
no
des.
Suc
h
congurations
are
easily
generated
b
y
the
-tec
hnique.
Consider
for
instance
the
co
ding
of
c
:
Bo
ol
!
o
!
o:n
:
o:c
true
(c
false
n)
:
(Bo
ol
!
o
!
o)
!
o
!
o
and
its
-expanded
equiv
alen
t,
depicted
in
Figure
0..
In
the
unexpanded
term,
there
is
a
sharing
of
c,
but
not
a
sharing
of
the
four
applications.
In
the
-expanded
term,
the
co
ding
of
(c
true
)

0.
Sup
erp
osition
and
higher-or
der
sharing

*
*
*
λ
λ
*
*
*
*
@
@
@ @
@
@
λ
λ
λ
λ
n
c
Fig.
0..
-expansion
of
the
list
of
Bo
oleans.
and
(c
false)
is
shared
b
y
a
single
application,
and
the
argumen
t
is
ex-
actly
our
sup
erimp
osed
true
and
false.
In
addition,
there
is
a
sharing
of
((c
true
)
(c
false
n))
and
((c
false)
n).
Notice
that
the
companion
ar-
gumen
t
to
the
sup
erimp
osed
v
alues
is
just
t
w
o
-expansions:
the
?-side,
co
ding
((c
true)
(c
false
n)),
leads
bac
k
in
to
the
net
w
ork
of
applications
(but
on
the
-side),
while
the
-side
leads
out
to
the
parameter
n.
This
example
explains
wh
y
Sa
tisfiability
can
b
e
co
ded
in
a
trivial
n
um
b
er
of
parallel
-steps.
Generalizing
the
ab
o
v
e
graph
constructions,
w
e
ma
y
essen
tially
sup
erimp
oses
every
ro
w
of
an
n-v
ariable
truth
table
in
to
a
single,
shared
structure,
so
that
applying
a
Bo
olean
function
to
all

n
ro
ws
can
b
e
done
\sim
ultaneously
."
Another
b
eautiful
example
comes
from
Ch
urc
h
n
umerals.
In
Figure
0.
are
t
w
o
sharing
graphs,
represen
ting
the
Ch
urc
h
n
umerals
for

and
,
in
whic
h
ev
ery
application
of
the
\successor"
constructor
x
is
shared.
Notice
that
these
examples
giv
e
us
a
fairly
univ
ersal
picture
of
Ch
urc
h
n
umerals,
where
the
x
and
y
serv
e
as
a
uniform
in
terface,
the
appli-
cations
are
maximal
ly
shared,
and
t
w
o
n
umerals
are
distinguished
only
b
y
their
net
w
ork
of
sharing
no
des.


Complexity
3
2
λx
λy
*
*
@
λx
λy
*
*
*
*
@
Fig.
0..
-expansion
of
the
c
h
urc
h
n
umerals

and
.
λy
λx
*
*
*
*
*
*
*
*
*
*
@
Fig.
0.	.
Sup
erimp
osed

and
.
No
w
w
e
can
co
de
a
sup
erimp
osed
represen
tation
of
man
y
Ch
urc
h
n
u-
merals,
b
y
inserting
more
sharing
no
des
to
serv
e
as
m
ultiplexors
and
dem
ultiplexors
leading
to
the
correct
sharing
net
w
ork
(Figure
0.0).
This
st
yle
of
computation
lo
oks
lik
e
a
-calculus
optimal
ev
aluation
implemen
tation
of
SIMD
(single
instruction,
m
ultiple
data)
parallelism.
Imagine
a
list
c:n:c
x

(c
x




(c
x
`
n)



))
where
the
x
i
are
Ch
urc
h

0.
Sup
erp
osition
and
higher-or
der
sharing

λy
λx
1
n
@
n
n
2
k
k
k
k
k
. . .
Fig.
0.0.
Sup
erimp
osi
ng
Ch
urc
h
n
umerals.
n
umerals,
whic
h
gets
-expanded
so
that
the
applications
(c
x
i
)
are
all
shared,
via
sup
erimp
osed
represen
tations
of
the
n
umerals.
W
e
can
then,
for
example,
apply
an
y
in
teger
function
to
eac
h
of
the
n
umerals
\sim
ul-
taneously
,"
that
is,
coun
ting
parallel
-steps,
but
not
coun
ting
sharing
in
teractions.
The
sharing
net
w
ork
for
eac
h
n
umeral
is
lik
e
a
separate
pro
cessor,
serving
as
m
ultiple
data;
the
-
and
apply-no
des
serv
e
as
in
terface
to
the
external
con
text;
the
m
ultiplexors
and
dem
ultiplexors
replicate
and
pump
the
single-instruction
stream
(the
co
de
for,
sa
y
,
fac-
torial)
to
eac
h
of
the
pro
cessors.
The
real
w
ork
of
the
computation
b
ecomes
c
ommunic
ation,
p
erforming
the
-expansion
on
the
lists,
and
comm
unicating
the
function
to
to
dieren
t
pro
cessors.
But
the
actual
computation
asso
ciated
with
the
function
o
ccurs
via
in
teraction
of
shar-
ing
no
des
only
,
our
\parallel
computation."
0..
Higher-or
der
sharing
Sup
erp
osition
is
only
one
comp
onen
t
of
the
graph
reduction
tec
hnology
that
supp
orts
nonelemen
tary
computation
in
a
trivial
n
um
b
er
of
parallel
-steps.
The
other
essen
tial
phenomenon
is
higher-or
der
sharing,
used
to
construct
enormous
net
w
orks
of
sharing
no
des.


Complexity
0...
A
simple,
exp
onential
c
onstruction
Let
us
start
with
a
simple
example,
used
to
sim
ulate
an
exp
onen
tial
n
um
b
er
of
function
applications.
As
w
e
already
remark
ed,
the
c
h
urc
h
n
umeral
t
w
o
can
b
e
describ
ed
b
y
the
graph
in
Figure
0..
*
@
λ
λ
*
Fig.
0..
A
represen
tation
of
Ch
urc
h's
in
teger

Let
us
no
w
consider
the
application
of
two
0
to
itself.
Recall
that
the
application
(n
m)
of
t
w
o
c
h
urc
h
in
tegers
n
and
m
giv
es
the
c
h
urc
h
in
teger
m
n
,
so
the
exp
ected
result
is
(a
represen
tation
of
)
the
c
h
urc
h
in
teger
four.
The
reduction
is
sho
wn
in
Figure
0..
The
t
w
o
rst
reduction
steps
are
-redex.
After
these
reductions
w
e
are
left
with
the
term
in
Figure
0..(),
where
the
subterm
y:(x(x
y))
is
shared
b
y
means
of
the
t
w
o
copies
of
the
fan
mark
ed
"a".
No
w,
this
subterm
is
fully
duplicated.
This
pro
cess
requires:

steps
for
duplicating
the

and
the
application;

steps
for
duplicating
the
fans;

steps
for
eacing
all
residuals
of
fans
mark
ed
with
"a".
After
these

steps
w
e
are
left
with
the
graph
in
Figure
0..(),
where
a
new
-redex
has
b
een
put
in
evidence.
Firing
this
redex,
w
e
obtain
the
nal
conguration
in
Figure
0..().
Summing
up,
w
e
executed

-reductions,
and

fan-
in
teractions.
Note
moreo
v
er
that
the
nal
conguration
has
the
same
shap
e
of
the
initial
one.
Let
us
no
w
generalize
the
previous
example.
As
should
b
e
clear,
the
c
h
urc
h
in
teger

n
can
b
e
represen
ted
b
y
the
graph
in
Figure
0.,
where
w
e
ha
v
e
exactly
a
sequence
of
fan-in
of
length
n
and
a
corresp
onding
sequence
of
fan-out
of
the
same
length.
Let
us
no
w
apply
this
term
to
itself.
By
ring
the
t
w
o
outermost
-redexes
w
e
get
the
term
in
Figure
0..
As
in
the
case
of
t
w
o,
the
p
ortion
of
graph
inside
the
t
w
o
fans
mark
ed
with
"a"
is
no
w
fully
duplicated.
This
duplication
requires:

steps
for

0.
Sup
erp
osition
and
higher-or
der
sharing
	
@
two’
two’
*
@
λ
two’
*
*
*
*
@
λ
λ
*
a
a
(3)
(2)
(1)
λ
*
*
@
λ
@
λ
*
*
λ
*
*
λ
@
*
*
(5)
(4)
Fig.
0..
the
reduction
of
(t
w
o'
t
w
o')
duplicating
the

and
the
application;
n
steps
for
duplicating
fans;
n+
steps
for
eacing
fans.
This
giv
es
a
total
of

+
n
op
erations.
After
these
reductions,
w
e
get
the
conguration
in
Figure
0..
A
new
-redex
has
b
een
created.
By
ring
this
redex
w
e
obtain
the
graph
in
Figure
0..
No
w,
this
graph
has
the
same
shap
e
of
the
graph
in
Figure
0.,
and
w
e
can
iterate
our
reasoning.
In
particular,
the
duplication
of
the
innermost
part
of
the
graph
will
no
w
require

+
*(n)
op
erations.
Then,
w
e
shall
ha
v
e
a
new
-redex,
and
b
y
its
ring,
w
e
shall
get
a
graph
of
the
same
shap
e
of
Figure
0.
but
where
the
innermost
sequences
of
fans
ha
v
e
length
n
(this
length

0
Complexity
λ
*
*
*
λ
@
*
*
*
n
n
Fig.
0..
a
represen
tation
of

n
*
*
*
n
*
*
*
n
*
*
*
*
*
*
λ
@
λ
a
n
n
a
n
Fig.
0..
the
reduction
of
(
n

n
)

0.
Sup
erp
osition
and
higher-or
der
sharing

*
*
*
*
*
n
*
*
*
λ
@
n
*
*
*
n
*
*
*
n
λ
@
n
*
*
λ
Fig.
0..
the
reduction
of
(
n

n
)
is
doubled
at
ev
ery
iteration
of
the
pro
cess),
while
the
length
of
the
outermost
sequences
is
decremen
ted
b
y
one.
Summing
up,
the
total
n
um
b
er
of
fan-in
teractions
is
giv
en
b
y
((
+
n)
+
(
+


(n))
+
(
+


(n))
+
:
:
:
+
(
+


(
n-
n)))
=
n
+
n

n-
X
i=0

i
=
n
+
n

(
n
-
)
=
n

(


n
+
)


Complexity
*
*
*
*
*
*
*
λ
λ
@
2n
*
*
*
2n
n-1
n-1
Fig.
0..
the
reduction
of
(
n

n
)
In
con
trast,
w
e
ha
v
e
executed
just
n
-reductions
in
the
main
lo
op,
plus
t
w
o
at
the
v
ery
b
eginning,
for
a
total
of
n
+

family
reductions.
The
previous
construction
is
essen
tially
obtained
in
the
reduction
of
g
=
n:(n

two
0
I
q)
where

=
x:(xx),
two
0
=
x:y:(z:(z(z
y))
w:(x
w)),
I
is
the
iden-
tit
y
and
q
is
some
constan
t.
If
n
is
a
c
h
urc
h
in
teger,
(g
n)
ob
viously
reduces
to
q.
As
a
function
of
n,
the
term
(n

two
0
)
corresp
onds
to
the
c
h
urc
h
in
teger
a
n
,
in
the
succession
a
0
=
;
a
i+
=
a
a
i
i
.
It
is
easy
to
pro
v
e
that
the
n
um
b
er
f(n)
of
family
reductions
gro
ws
as
f(n)
=
	
+


n
+
n-
X
i=0
b
i
where
b
i
=
log(a
i
)
y
.
Finally
,
let
us
consider
the
n
um
b
er
of
fan-in
teractions.
F
or
eac
h
ap-
plication
of
(
a
i
),
w
e
ha
v
e

+

+


b
i
in
teractions
for
duplicating
y
b
n
can
b
e
equiv
alen
tly
dened
as
b
0
=
;
b
i+
=
b
i


b
i
.

0.
Sup
erp
osition
and
higher-or
der
sharing

a
i
,
plus
b
i
+


b
i+
op
erations
in
the
reduction
of
(a
i
a
i
)
(recall
that
b
i+
=
b
i


b
i
).
Moreo
v
er,
w
e
ha
v
e
one
single
op
eration
in
ternal
to
two
0
,


(n
-
)
op
erations
for
creating
all
copies
of
,
and
b
n
nal
op
erations
of
fan-eacemen
t
when
w
e
apply
the
external
parameters.
Summing
up,
the
n
um
b
er
c(n)
of
fan-in
teractions
(for
n
>
0)
is
giv
en
b
y
the
form
ula:
c(n)
=
0

n
-

+


n-
X
i=0
b
i
+


n
X
i=
b
i
+
b
n
=
0

n
+


n-
X
i=
b
i
+


b
n
>


b
n
Note
no
w
that

P
n-
i=0
b
i
=
b
n
.
So,

f(n)
=

	+n+
P
n-
i=0
b
i
=

	+n

b
n
F
or
n

,
it
is
easy
to
sho
w
that

	+n
<



b
n
.
Hence:

f(n)
<



b

n
<



c(n)

:
and
nally
(for
an
y
n

)
c(n)
>




f(n)

W
e
can
also
easily
pro
v
e
that,
for
an
y
n,
c(n)


f(n)
.
On
one
side
w
e
ha
v
e

f(n)
>

	

b
n
.
On
the
other
side,
P
n-
i=0
b
i

b
n
and
ob
viously
n

b
n
,
so
c(n)
<


b
n
<

	

b
n
<

f(n)
The
previous
form
ulas
ha
v
e
b
een
also
exp
erimen
tally
conrmed
b
y
our
protot
yp
e
implemen
tatio
n
of
(a
v
arian
t
of
)
Lamping's
algorithm:
the
Bologna
Optimal
Higher-Order
Mac
hine
(see
Chapter
).
The
results
of
the
computation
of
the
function
g
are
sho
wn
in
Figure
0..
The
four
columns
in
the
table
are,
resp
ectiv
ely
,
the
user
time
required
b
y
the
computation
(on
a
Sparc-station
),
the
total
n
um
b
er
of
in
ter-
actions
(comprising
the
\oracle"),
the
length
of
the
family
reduction
(app-lam
b
da
in
teractions),
and
the
total
n
um
b
er
of
fan-in
teractions.
It
is
also
v
ery
easy
to
nd
examples
of
exp
onen
tial
explosion
with
resp
ect
to
a
line
ar
gro
w
of
the
n
um
b
er
of
family
reductions.
A
simple
example
is
pro
vided
b
y
the
-term
h
=
n:(n
two
0
two
0
I
q).
In
this
case
the
n
um
b
er
of
family
reductions
f(n)
gro
ws
linearly
in
its
input
n


Complexity
Input
user
tot.
in
ter.
fam.
fan-in
ter.
(g
zero)
0.00
s.

	

(g
one)
0.00
s.



(g
t
w
o)
0.00
s.
00


(g
three)
.	0
s.
	
	
	
Fig.
0..
The
function
g
(in
particular,
f(n)
=
	
+


n),
while
the
n
um
b
er
of
fan-in
teractions
c(n)
is
giv
en
b
y
the
form
ula
c(n)
=


n
-

+



n
In
particular,
for
an
y
n,

f(n)-


c(n)


f(n)
In
the
table
of
Figure
0.,
y
ou
will
nd
the
exp
erimen
tal
results
in
BOHM.
In
this
case
(the
term
is
t
ypable),
w
e
also
mak
e
a
comparison
with
t
w
o
standard
(resp
ectiv
ely
,
strict
and
lazy)
implemen
tations
suc
h
as
Caml-Ligh
t
and
Y
ale
Hask
ell.
CamlLigh
t
[LM	
]
is
a
b
yteco
ded,
p
ortable
implemen
tatio
n
of
a
di-
alect
of
the
ML
language
(ab
out
00K
for
the
run
time
system,
and
another
00K
of
b
yteco
de
for
the
compiler,
v
ersions
for
the
Macin
tosh
and
IBM
PC
are
also
a
v
ailable)
dev
elop
ed
at
the
INRIA-Ro
cquencourt
(F
rance).
In
spite
of
its
limited
dimensions,
the
p
erformance
of
Cam-
lLigh
t
is
quite
go
o
d
for
a
b
yteco
ded
implem
en
tation:
ab
out
v
e
times
slo
w
er
than
SML-NJ.
W
e
used
CamlLigh
t
v.
0..
Y
ale
Hask
ell
[The	
]
is
a
complete
implemen
tatio
n
of
the
Hask
ell
lan-
guage
dev
elop
ed
at
Y
ale
Univ
ersit
y
.
The
Hask
ell
compiler
is
written
in
a
small
Lisp
dialect
similar
to
Sc
heme
whic
h
runs
on
top
of
Commo
n
Lisp.
Hask
ell
programs
are
translated
in
to
Lisp,
and
then
compiled
b
y
the
underlying
Lisp
Compiler.
W
e
used
Y
ale
Hask
ell
Y.b-v
built
on
CMU
Common
Lisp
f.
The
results
of
the
test
should
giv
e
a
gist
of
the
p
o
w
er
of
the
optimal
graph
reduction
tec
hnique.
0...
A
n
elementary
c
onstruction
The
k
ey
idea
in
the
previous
construction,
and
in
more
sophisticated
examples
of
higher-order
sharing,
is
the
pairing
of
sharing
no
des
with

0.
Sup
erp
osition
and
higher-or
der
sharing

Input
BOHM
Caml-Ligh
t
Hask
ell
user
tot.
in
ter.
fam.
fan-in
ter.
user
user
(h
one)
0.00
s.



0.00
s.
0.00
s.
(h
t
w
o)
0.00
s.
	


0.00
s.
0.0
s.
(h
three)
0.00
s.
0


0.00
s.
0.
s.
(h
four)
0.00
s.


0
.0
s.
.0
s.
(h
v
e)
0.00
s.
0


??
??
(h
six)
0.0
s.



(h
sev
en)
0.0
s.

0
	
(h
eigh
t)
0.
s.
	


(h
nine)
.0
s.



(h
ten)
.0
s.

	

Fig.
0..
The
function
h
wires
from

to
?-sides,
so
that
w
e
can
en
ter
the
same
graph
in
t
w
o
dieren
t
\mo
des."
(see
Figure
0.	).
*
*
*
*
*
*
*
@
f
x
*
k
*
*
*
*
*
*
*
*
Fig.
0.	.
Exp
onen
tial
path
and
exp
onen
tial
function
application
In
this
case,
a
naiv
e
v
ersion
of
con
text
information
can
b
e
constructed
as
mere
stac
ks
of
?
and
.
When
a
stac
k
en
ters
a
sharing
no
de
at
its
in
teraction
p
ort,
the
top
tok
en
on
the
stac
k
is
p
opp
ed,
and
used
to


Complexity
determine
whether
the
path
to
follo
w
is
along
the

or
?-auxiliary
p
orts
of
the
no
de
(and
con
v
ersely
,
when
en
tering
a
sharing
no
de).
Ho
w
ev
er,
this
construction
merely
shares
an
application
no
de;
to
get
a
truly
p
o
w
erful
net
w
ork
of
no
des,
w
e
need
to
b
e
able
to
share
sharing
no
des
as
w
ell.
F
or
example,
consider
the
net
w
ork
of
Figure
0.0.
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
Fig.
0.0.
A
simple
sharing
net
w
ork.
By
linking
t
w
o
symmetric
copies
of
this
construction
via
the
mark
ed
wire,
w
e
get
a
\stac
k"
of
sharing
no
des
implem
en
ting
the
standard
ex-
p
onen
tial
construction.
Iterating
the
idea
of
the
ab
o
v
e
gure,
w
e
can
deriv
e
a
doubly-exp
onen
tial
stac
k,
as
in
Figure
0..
*
0
*
0
1 *
*
1
1
0
*
*
*
0
*
0
*
0
*
0
1 *
*
0
*
*
0
1
1
0
*
*
*
*
*
*
*
*
*
1
0
1
1
1
0
0
Fig.
0..
A
doubly-exp
onen
ti
al
stac
k
of
sharing
no
des.
No
w
w
e
go
one
step
further,
considering
the
neste
d
construction
of
Figure
0.,
whic
h
hin
ts
at
ho
w
a
net
w
ork
of
n
sharing
no
des
can
expand
to
a
net
w
ork
of
size
K
`
(n):
After
these
illustrativ
e
examples,
w
e
can
describ
e
the
basic
idea
of
the
elementary
c
onstruction
(in
the
sense
of
Kalmar).
W
e
dene
a
sequence

0.
Sup
erp
osition
and
higher-or
der
sharing

*
*
*
*
*
1
1
2
1
1
*
2
*
1
1
0
*
*
*
1
1
0
*
*
*
2
*
0
*
0
1 *
0
0
*
*
*
1
Fig.
0..
A
\nested"
construction.
of
networks
N
j
,
where
N
j
con
tains
sharing
no
des
at
levels
(not
to
b
e
confused
with
indic
es)
0

`

i.
Lik
e
a
sharing
no
de,
ev
ery
net
w
ork
will
ha
v
e
one
principal
p
ort,
t
w
o
auxiliary
p
orts
(iden
tied
as
the

and
?-p
orts),
and
a
distinguished
sharing
no
de
that
w
e
will
call
the
c
or
e
no
de.
Giv
en
a
sharing
net
w
ork
N,
w
e
will
write
N
to
mean
N
with
blac
k
and
white
exc
hanged
on
the
auxiliary
p
orts
of
the
core
no
de
of
N.
The
net
w
ork
N
0
is
a
single
sharing
no
de
at
lev
el
0,
whic
h
is
b
y
pro
cess
of
elimination
the
core
no
de.
T
o
construct
N
j+
,
w
e
com
bine
N
j
,
N
j
,
and
a
new
core
no
de
at
lev
el
j
+
,
attac
hing
the
principal
p
orts
of
the
core
no
de
and
N
j
,
the
principal
p
ort
of
N
j
to
the
-auxiliary
p
ort
of
the
core
no
de,
and
the
?-auxiliary
no
de
of
N
j
to
the
-auxiliary
no
de
of
N
j
(see
Figure
0.).
The
principal
p
ort
of
N
j+
is
the
blac
k
external
p
ort
of
N
j
;
auxiliary
p
orts
are
the
?-auxiliary
p
ort
of
the
core
no
de,
and
the
-auxiliary
p
ort
of
N
j
.
Note
that
the

and
?-p
orts
of
N
j+
and
N
j+
are
essen
tially
\inherited"
b
y
the
core
no
de.
It
should
b
e
clear
that
N
j
has

j
-

sharing
no
des.
W
e
dene
a
naiv
e
oracle
for
in
teractions
b
et
w
een
sharing
no
des:
no
des
at
iden
tical
lev
el
annihilate,
otherwise
they
duplicate.
Lemma
0..
The
network
N
j
(r
esp
e
ctively,
N
j
)
normalizes
to
a
c
om-
plete
binary
tr
e
e
with
K
j
()
le
aves.
The
le
aves
ar
e
c
onne
cte
d
to
sharing


Complexity
Nj
Nj
*
*
j+1
*
*
Nj+1
Nj
Nj
*
*
j+1
Nj+1
*
*
Fig.
0..
The
generic
construction
of
an
elemen
tary
net
w
ork.
no
des
at
level
j
-

on
their
black
(r
esp
e
ctively,
white)
auxiliary
p
orts;
the
r
emaining
auxiliary
p
ort
is
c
onne
cte
d
to
the
primary
p
ort
of
the
no
de
at
the
adjac
ent
le
af,
as
in
Figur
e
0..
Pr
o
of
By
induction.
The
lemma
is
trivially
true
for
j
=
0.
F
or
j
=
i
+
,
use
the
induction
h
yp
othesis
to
normalize
N
i
and
N
i
,
pro
ducing
the
net
w
ork
in
Figure
0.0.
The
t
w
o
binary
trees
no
w
annihilate
eac
h
other,
and
the
t
w
o
stac
ks
of
K
i
()
sharing
no
des
then
create
a
complete
binary
tree
with
K
i+
copies
of
the
core
no
de,
with
a
complete
binary
tree
link
ed
to
these
copies
at
the
lea
v
es.
This
kind
of
sharing
net
w
ork
results
from
the
parallel
-reduction
of
the
-expanded
term

j







of
j
s,
where

is
the
Ch
urc
h
n
umeral
for
.
This
term
has
length
O(
j
)
b
ecause
of
explicit
t
yp
e
information
that
doubles
for
eac
h
additional
;

j
normalizes
in
O(j)
parallel
-steps
to
the
Ch
urc
h
n
umeral
for
K
j
().
The
exp
onen
tial
length
is
sucien
t
to
co
de
a
cop
y
of
N
j
and
N
j
;
after
normalization,
these
net
w
orks
expand
to
construct
K
j
()
function
applications.
The
same
computational
phe-
nomenon
is
eviden
t
in
the
co
ding
of
the
iterated
p
o
w
erset,
though
not
as
straigh
tforw
ard
to
describ
e.

0.
Conclusions
	
0.
Conclusions
W
e
ha
v
e
seen
that
the
cost
of
implemen
ting
a
sequence
of
n
parallel
-reduction
steps
in
the
reduction
of
a
-term
cannot
b
e
b
ounded
in
general
b
y
an
y
Kalmar-elemen
tary
function
K
`
(n).
Giv
en
that
the
par-
allel
-step
is
one
of
the
k
ey
ideas
in
optimal
reduction,
it
mak
es
sense
to
consider
whether
the
idea
of
optimal
ev
aluation
has
an
y
implem
en
tativ
e
relev
ance,
and
in
particular
if
the
complex
graph
reduction
tec
hnology
that
is
the
main
sub
ject
of
this
b
o
ok
is
of
an
y
go
o
d,
in
practice.
The
answ
er
is
y
es,
of
course.
The
previous
result
merely
giv
es
a
lo
w
er
b
ound
in
a
particularly
\bad"
case:
the
sim
ulation
of
a
generic
compu-
tation,
whic
h
is
\incompressible"
b
y
the
time
hierarc
h
y
theorem.
But
the
real
question
are:
(i)
With
resp
ect
to
more
traditional
implem
en
tations,
do
es
Lamp-
ing's
graph
reduction
algorithm
in
tro
duce
an
y
ma
jor
o
v
erhead,
in
general?
(ii)
Ho
w
m
uc
h
can
w
e
gain
in
\go
o
d"
cases?
As
for
the
second
question,
w
e
ha
v
e
a
lot
of
examples
where
optimal
graph
reduction
can
drastically
reduce
the
actual
cost
of
the
computation
(from
exp
onen
tial
to
linear,
sa
y
,
but
ma
yb
e
more:
w
e
do
not
kno
w
y
et).
The
rst
question
lo
oks
more
delicate.
Clearly
(and
the
pro
of
of
our
complexit
y
results
should
b
e
enough
to
con
vince
the
reader)
optimal
graph
reduction
is
really
parsimonious
in
its
duplication
strategy
.
This
insigh
t
and
in
tuition
can
b
e
formalized
more
precisely
b
y
the
fact
that
the
n
um
b
er
of
in
teractions
of

no
des,
apply
no
des,
and
sharing
no
des
in
optimal
graph
reduction
is
b
ounded
b
y
a
p
olynomial
in
the
n
um
b
er
of
unique
Levy's
lab
els
generated
in
a
reduction
[LM	
].
If
w
e
b
eliev
e
that
a
lab
el
iden
ties
a
set
of
similar
sub
expressions,
this
result
means
that
the
graph
reduction
algorithm
is
really
maxim
izing
sharing
up
to
a
p
olynomial
factor.
It
remains,
ho
w
ev
er,
to
giv
e
a
denitiv
e
solution
to
the
problem
of
accum
ulation
of
c
ontr
ol
op
er
ators
discussed
in
the
previous
c
hapter,
and
the
equally
anno
ying
problem
of
garbage
collection.


F
unctional
Programming
So
far,
w
e
ha
v
e
b
een
merely
dealing
with
-calculus.
F
acing
the
problem
of
using
Lamping's
tec
hnique
for
an
actual
implem
en
tation
of
a
F
unc-
tional
Programming
Language,
w
e
m
ust
ob
viously
extend
this
tec
hnique
to
co
v
er
a
ric
h
set
of
primitiv
e
data
t
yp
es,
as
w
ell
as
other
computational
constructs,
suc
h
as
conditionals,
recursion
and
so
on.
Luc
kily
,
there
is
a
simple
and
uniform
w
a
y
for
taking
in
to
accoun
t
all
these
asp
ects
of
a
real
programmi
ng
language,
starting
from
the
relation
b
et
w
een
optimal
reduction
and
Linear
Logic.
The
main
idea
b
ehind
Linear
Logic
is
to
mak
e
a
clean
distinction
b
et
w
een
the
lo
gic
al
part
of
the
calculus
(dealing
with
the
logical
con-
nectiv
es)
and
the
structur
al
part
(dealing
with
the
managemen
t
of
h
y-
p
otheses,
whic
h
can
b
e
considered
as
ph
ysical
resources).
These
t
w
o
dieren
t
asp
ects
of
logical
calculi
ha
v
e
their
ob
vious
corresp
onden
t
(via
the
Curry-Ho
w
ard
analogy)
inside
-calculus:
on
one
side,
w
e
ha
v
e
the
line
ar
part
(the
linear
-calculus),
dening
the
syn
tactical
op
erators
(the
arit
y
,
the
\binding
p
o
w
er",
etc.)
and
their
in
teraction
(-reduction);
on
the
other
side,
w
e
ha
v
e
the
structur
al
part,
taking
care
of
the
manage-
men
t
(sharing)
of
resources
(i.e.,
of
sub
expressions).
Summari
zing
in
a
form
ula:
-calculus
=
linear
-calculus
+
sharing.
By
the
previous
c
hapters,
it
is
clear
that
Lamping's
sharing
op
erators
(fan,
croissan
t
and
square
brac
k
et)
pro
vide
a
v
ery
abstract
framew
ork
for
an
(optimal)
implem
en
tation
of
the
structural
part,
whic
h
is
then
in
terfaced
to
the
linear
(or
logical)
part
of
the
calculus.
Therefore,
it
should
b
e
clear
that
Lamping's
tec
hnique
smo
othly
gener
alizes
to
a
larger
class
of
calculi,
just
replacing
linear
-calculus
with
an
y
arbitrary
linear
calculus
that
preserv
es
a
smo
oth
in
terface
b
et
w
een
the
linear
and
the
0

F
unctional
Pr
o
gr
amming

structural
subparts
of
the
system.
By
the
w
a
y
,
the
critical
p
oin
t
of
this
generalization
is
the
in
terface
b
et
w
een
the
t
w
o
parts
of
the
system.
Let
us
b
e
more
precise
on
this
last
p
oin
t.
The
natural
correp
ondence
b
et
w
een
structural
op
erators
of
sharing
graphs
and
structural
rules
of
Linear
Logic
strongly
suggests
that
the
system
extending
or
replacing
-calculus
m
ust
b
e
in
terpretable
in
some
extension
of
the
in
tuitionistic
part
of
Linear
Logic.
In
other
w
ords,
the
c
hosed
linear
calculus
m
ust
preserv
e
the
str
ong
lo
gic
al
foundation
of
the
system.
Luc
kily
,
in
literature
there
is
a
natural|and
up
to
our
kno
wledge
unique|candidate
for
the
linear
calculus
replacing
-calculus:
Lafon
t's
In
teraction
Nets
[Laf	0
].
Therefore,
dropping
the
linearit
y
constrain
t
in
In
teraction
Nets,
w
e
ev
en
tually
obtain
our
candidate
calculus,
in
tro-
duced
in
[AL	b
]
under
the
name
of
Inter
action
Systems.
In
the
spirit
of
the
equation
ab
o
v
e,
w
e
can
then
summarize
the
result
b
y
the
form
ula:
In
teraction
Systems
=
In
teraction
Nets
+
sharing.
The
main
(logical)
prop
erties
of
In
teraction
Systems
(b
orro
w
ed
from
In
teraction
Nets)
are
the
follo
wing:

the
syn
tactical
op
erators
are
classied
in
t
w
o
dual
groups:
c
onstruc-
tors
and
destructors;

eac
h
op
erator
has
a
distinguished
p
ort,
called
its
main
or
princip
al
p
ort,
where
it
can
in
teract
with
a
dual
op
erator;

eac
h
reduction
is
an
in
teraction
b
et
w
een
a
c
onstructor-destructor
p
air
(thas
is,
a
logical
cut).
F
rom
the
p
oin
t
of
view
of
optimal
reduction,
the
relev
ance
of
ha
ving
a
distinguished
principal
p
ort
for
eac
h
op
erator
should
b
e
clear.
The
deep
reason
b
ecause
of
whic
h
Lamping's
tec
hnique
is
optimal
in
the
case
of
-calculus
is
that
duplication
of
applications
and
-no
des
is
only
allo
w
ed
at
their
principal
p
ort.
Therefore,
this
prop
ert
y
m
ust
b
e
preserv
ed
when
extending
the
system
b
y
adding
new
op
erators
to
the
signature|this
is
what
w
e
mean
t
sa
ying
that
the
extension
m
ust
preserv
e
a
clean
in
terface
b
et
w
een
the
logical
and
the
structural
part.
The
logical
nature
of
In
teraction
Systems
(IS's)
b
ecomes
particularly
clear
comparing
them
with
other
Higher-order
rewriting
systems,
suc
h
as
Klop's
Com
binatory
Reduction
Systems
(CRS's)
[Klo0
].
As
a
mat-
ter
of
fact,
In
teraction
Systems
are
just
the
sub
class
of
Com
binatory
Reduction
Systems
where
the
Curry-Ho
w
ard
analogy
stil
l
makes
sense.
This
means
that
w
e
can
asso
ciate
to
ev
ery
IS
a
suitable
logical
(in
tu-
itionistic)
system:
constructors
and
destructors
resp
ectiv
ely
corresp
ond


F
unctional
Pr
o
gr
amming
to
righ
t
and
left
in
tro
duction
rules,
in
teraction
is
cut,
and
computation
is
cut-elimination.
As
a
consequence,
In
teraction
Systems
ha
v
e
a
nice
lo
c
al
ly
se
quential
natur
e:
in
particular,
the
leftmost
outermost
reduction
strategy
reduces
needed
redexes
only
.
.
In
teraction
Systems
An
In
teraction
System
is
dened
b
y
a
signatur
e

and
a
set
of
r
ewriting
rules
R.
The
signature

consists
of
a
den
umerable
set
of
variables
and
a
set
of
forms.
V
ariables
will
b
e
ranged
o
v
er
b
y
x;
y;
z;



,
p
ossibly
indexed.
V
ectors
of
v
ariables
will
b
e
denoted
b
y
~
x
i
where
i
is
the
length
of
the
v
ector
(often
omitted).
F
orms
are
partitioned
in
to
t
w
o
disjoin
t
sets

+
and

-
,
represen
ting
c
onstructors
(ranged
o
v
er
b
y
c)
and
destructors
(ranged
o
v
er
b
y
d).
Eac
h
form
of
the
syn
tax
can
b
e
a
binder.
In
the
arit
y
of
the
form
w
e
m
ust
sp
ecify
not
only
the
n
um
b
er
of
argumen
ts,
but
also,
for
eac
h
argumen
t,
the
n
um
b
er
of
b
ound
v
ariables.
Th
us,
the
arity
of
a
form
f,
is
a
nite
(p
ossibly
empt
y)
sequence
of
naturals.
Moreo
v
er,
w
e
ha
v
e
the
constrain
t
that
the
arit
y
of
ev
ery
destructor
d


-
has
a
leading
0
(i.e.,
it
cannot
bind
o
v
er
its
rst
argumen
t).
The
reason
for
this
restriction
is
that,
in
Lafon
t's
notation
[Laf	0
],
at
the
rst
argumen
t
w
e
nd
the
princip
al
p
ort
of
the
destructor,
that
is
the
(unique)
p
ort
where
w
e
will
ha
v
e
in
teraction
(lo
cal
sequen
tialit
y).
Expressions,
ranged
o
v
er
b
y
t;
t

;



,
are
inductiv
ely
generated
as
follo
ws:
(i)
ev
ery
v
ariable
is
an
expression;
(ii)
if
f
is
a
form
of
arit
y
k




k
n
and
t

;



;
t
n
are
expressions
then
f
(
~
x

k

:
t

;



;
~
x
n
k
n
:
t
n
)
is
an
expression.
F
ree
and
b
ound
o
ccurrences
of
v
ariables
are
dened
in
the
ob
vious
w
a
y
.
As
usual,
w
e
will
iden
tify
terms
up
to
renaming
of
b
ound
v
ariables
(-con
v
ersion).
Rewriting
rules
are
describ
ed
b
y
using
sc
hemas
or
metaexpressinos.
A
metaexpr
ession
is
an
expression
with
metavariables,
ranged
o
v
er
b
y
X;
Y
;



,
p
ossibly
indexed
(see
[Acz]
for
more
details).
Metaexpres-
sions
will
b
e
denoted
b
y
H;
H




.
A
r
ewriting
rule
is
a
pair
of
metaexpressions,
written
H

!
H

,
where

.
Inter
action
Systems

H

(the
left
hand
side
of
the
rule
or
lhs
for
short)
has
the
follo
wing
format:
d(c(
~
x

k

:
X

;



;
~
x
m
k
m
:
X
m
);



;
~
x
n
k
n
:
X
n
)
where
i
=
j
implies
X
i
=
X
j
(i.e.,
left
line
arity).
The
arit
y
of
d
is
0k
m+



k
n
and
that
of
c
is
k




k
m
.
The
right
hand
side
H

(rhs,
for
short)
is
ev
ery
close
d
metaexpression,
whose
meta
v
ariables
are
already
in
the
lhs
of
the
rule,
built
up
according
to
the
follo
wing
syn
tax:
H
::=
x
j
f
(
~
x

a

:
H

;



;
~
x
j
a
j
:
H
j
)
j
X
i
[
H

=
x
i

;



;
H
k
i
=
x
i
k
i
]
where
the
expression
X[
H

=
x

;



;
H
n
=
x
n
]
denotes
a
meta-op
eration
of
substitution
(as
the
one
of
-calculus)
dened
in
the
ob
vious
w
a
y
.
Finally
,
the
set
of
rewriting
rules
m
ust
b
e
non-ambiguous,
i.e.,
there
exists
at
most
one
rewriting
rule
for
eac
h
pair
d-c.
In
teraction
Systems
are
a
subsystem
of
Klop's
(Orthogonal)
Com
bina-
tory
Reduction
Systems
[Klo0
,
Acz
].
W
e
just
added
a
bipartition
of
op
erators
in
to
constructors
and
destructors,
and
imp
osed
a
suitable
constrain
t
on
the
shap
e
of
the
lhs
of
eac
h
rule.
As
a
sub
class
of
non
am
biguous,
left-linear
CRS's,
In
teraction
Systems
inherit
all
go
o
d
prop-
erties
of
the
former
ones
(Ch
urc
h
Rosser,
nite
dev
elopmen
t,
.
.
.
).
Example
..
(-calculus)
The
application
@
is
a
destructor
of
ar-
it
y
00,
and

is
a
constructor
of
arit
y
.
The
only
rewriting
rule
is
-reduction:
@((x:
X);
Y
)
!
X[
Y
=
x
]:
Example
..
(Bo
oleans)
Bo
oleans
are
dened
b
y
t
w
o
construc-
tors
T
and
F
of
arit
y
"
(t
w
o
constan
ts).
Then
y
ou
ma
y
add
y
our
fa
v
orite
destructors.
F
or
instance
the
logical
conjunction
is
a
destructor
and
of
arit
y
00,
with
the
follo
wing
rewriting
rules:
and
(T;
X)
!
X
and
(F;
X)
!
F
Another
t
ypical
destructor
is
the
if-then-else
op
erator
ite,
of
arit
y
000:
ite
(T;
X;
Y
)
!
X
ite
(F;
X;
Y
)
!
Y
Example
..
(Lists)
Lists
are
dened
b
y
t
w
o
constructors
nil
and


F
unctional
Pr
o
gr
amming
cons
of
arit
y
"
and
00,
resp
ectiv
ely
.
The
t
ypical
destructors
hd,
tl
and
isnil
(all
of
arit
y
0)
ma
y
b
e
dened
b
y
the
follo
wing
rules:
hd
(cons(X;
Y
))
!
X
tl
(cons(X;
Y
))
!
Y
isnil
(nil
)
!
T
isnil
((cons
(X;
Y
))
!
F
Example
..
(Primiti
v
e
Recursion)
The
sc
hemas
for
Primitive
R
e
cursion
do
es
p
erfectly
t
inside
In
teraction
Systems.
In
this
case,
w
e
ha
v
e
only
t
w
o
constructors
0
and
succ
.
An
y
new
function
d
dened
b
y
primitiv
e
recursion
corresp
onds
to
a
new
destructor
d
with
in
teraction
rules
of
the
follo
wing
kind:
d(0;
X)
!
h(X)
d(succ
(X);
Y
)
!
f
(X;
Y
;
g
(X;
Y
))
F
or
instance,
w
e
ma
y
dene
sum
and
pro
duct
b
y
the
follo
wing
IS-rules:
add
(0;
X)
!
X
add
(succ
(X);
Y
)
!
succ
(add
(X;
Y
))
mult
(0;
X)
!
0
mult
(succ
(X);
Y
)
!
add
(Y
;
mult
(X;
Y
))
Example
..
(In
tegers)
F
or
practical
purp
oses,
w
e
cannot
ob
vi-
ously
use
the
unary
represen
tation
of
in
tegers
giv
en
b
y
0
and
succ
.
The
ob
vious
solution
is
to
consider
eac
h
in
teger
n
as
a
distinguished
construc-
tor
n.
Then,
w
e
ma
y
dene
arithmetical
op
erations
in
constan
t
time.
The
only
problem
is
the
strictly
sequen
tial
nature
of
IS's,
that
imp
oses
in
teraction
on
a
distinguished
p
ort
of
the
form.
F
or
instance,
w
e
ma
y
dene
add(m;
X)
!
add
m
(X)
add
m
(n)
!
k
where
k
=
n+m.
Note
that
w
e
ha
v
e
an
innite
n
um
b
er
of
forms,
and
also
an
innite
n
um
b
er
of
rewriting
rules.
Example
..
(General
Recursion)
The
denition
of
the
recur-
sion
op
erator
x:M
!
M[
x:M
=
x
]
is
less
straigh
tforw
ard
than
the
previous
examples,
for
in
this
case
w
e
do
not
ha
v
e
a
pair
of
in
teracting
forms.
The
ob
vious
idea
is
to
in
tro
duce
a
suitable
\dumm
y
"
op
erator
in
teracting
with
.
Then,
according
if
w
e

.
Inter
action
Systems

c
ho
ose
to
in
tro
duce
a
constructor
or
a
destructor,
w
e
ev
en
tually
get
the
t
w
o
follo
wing
enco
dings:
d

((x:
X))
!
X[
d

((x:
X))
=
x
]
(c

;
x:
X)
!
X[
(c

;
x:
X)
=
x
]
Consequen
tly
,
in
the
rst
case

is
a
constructor,
while
in
the
second
it
is
a
destructor.
In
other
w
ords,
and
more
precisely
,

is
a
sort
a
constructor-destruc
tor
pair,
p
ermanen
tly
in
teracting
with
itself.
..
The
Intuitionistic
Natur
e
of
Inter
action
Systems
In
this
section
w
e
shall
recall
the
logical,
in
tuitionistic
nature
of
In
ter-
action
Systems,
and
their
relations
with
Lafon
t's
In
teraction
Nets.
The
aim
is
to
in
tro
duce
and
clarify
some
essen
tial
notions
of
IS-forms
(p
o-
larities,
principal
and
auxiliary
p
orts,
b
ound
p
orts,
inputs
and
outputs,
etc.).
...
Statics
An
In
tuitionistic
System,
in
a
se
quent
c
alculus
presen
tation
(
a
la
Gen
tzen)
(see
[Gir	b
]),
consists
of
expressions,
named
se
quents,
whose
shap
e
is
A

;



A
n
`
B
where
A
i
and
B
are
form
ulas.
Inference
rules
are
par-
titioned
in
to
three
groups
(in
order
to
emphasize
the
relationships
with
IS's,
w
e
write
rules
b
y
assigning
terms
to
pro
ofs):
Structural
Rules
(Exchange
)
 ;
x
:
A;
y
:
B;

`
t
:
C
 ;
y
:
B;
x
:
A;

`
t
:
C
(Contr
:
)
 ;
x
:
A;
y
:
A
`
t
:
C
 ;
z
:
A;

`
t[
z
=
x
;
z
=
y
]
:
C
(We
ak
:
)
 `
t
:
C
 ;
z
:
A
`
t
:
C
Iden
tit
y
Group
(Identity
)
x
:
A
`
x
:
A
(Cut
)
 `
t
:
A
;
x
:
A
`
t
0
:
B
 ;

`
t
0
[
t
=
x
]
:
B
Logical
Rules
These
are
the
\p
eculiar"
op
erations
of
the
systems,
for
they
allo
w
to
in
tro
duce
new
form
ulae
(i.e.,
new
t
yp
es)
in
the
pro
of.
The
unique
new


F
unctional
Pr
o
gr
amming
form
ula
P
in
tro
duced
b
y
eac
h
logical
rule
is
called
the
princip
al
form
ula
of
the
inference.
The
inference
rule
is
called
right,
when
the
principal
form
ula
is
in
the
rhs
of
the
nal
sequen
t,
and
left
otherwise.
Righ
t
and
left
in
tro
duction
rules
resp
ectiv
ely
corresp
ond
with
c
onstructors
and
destructors
in
IS's.
The
shap
e
of
these
rules
is:
 
;
~
x

:
~
A

`
t

:
B




 n
;
~
x
n
:
~
A
n
`
t
n
:
B
n
 
;



;
 n
`
c(
~
x

:
t

;



;
~
x
n
:
t
n
)
:
P
for
righ
t
in
tro
duction
rules
(constructors),
and
 
;
~
x

:
~
A

`
t

:
B




 m
;
~
x
m
:
~
A
m
`
t
m
:
B
m
;
z
:
C
`
t
:
D
 
;



;
 m
;

;
y
:
P
`
t[
d(y;
~
x

:
t

;
;
~
x
m
:
t
m
)
=
z
]
:
D
for
left
in
tro
duction
rules
(destructors).
The
con
texts
 i
are
pairwise
dieren
t.
A
canonical
example
is
logical
implication,
that
giv
es
the
expressions
of
t
yp
ed
-calculus:
(!
l
)

`
t
:
A
z
:
B;
 `
t
0
:
C
;
y
:
A
!
B;
 `
t
0
[
@(y;t)
=
z
]
:
C
(!
r
)
;
x
:
A
`
t
:
B

`
(x:
t)
:
A
!
B
An
immedia
te
consequence
of
the
ab
o
v
e
construction
is
that
ev
ery
pro
of
of
an
In
tuitionistic
System
ma
y
b
e
describ
ed
b
y
an
IS-expression.
In
particular,
follo
wing
Lafon
t,
w
e
ma
y
pro
vide
a
graphical
represen
ta-
tion
of
IS-forms.
This
will
explain
some
imp
ortan
t
relations
b
et
w
een
the
arit
y
of
the
forms
and
the
w
a
y
in
whic
h
they
link
upp
er
sequen
ts
in
a
pro
of.
In
the
notation
of
In
teraction
Nets,
a
pro
of
of
a
sequen
t
A

;
:
:
:
;
A
n
`
B
is
represen
ted
as
a
graph
with
n
+

conclusions,
n
with
a
negativ
e
t
yp
e
(the
inputs)
and
one
with
a
p
ositiv
e
t
yp
e
(the
output).
In
particular,
an
axiom
is
just
a
line
with
one
input
and
one
output.
Ev
ery
logical
rule
is
represen
ted
b
y
in
tro
ducing
a
new
op
erator
in
the
net
(a
new
lab
eled
no
de
in
the
graph).
The
op
erator
has
a
princip
al
(or
main)
p
ort,
individuated
b
y
an
arro
w,
that
is
asso
ciated
with
the
princip
al
formula
of
the
logical
inference.
F
or
instance,
the
t
w
o
logical
rules
for
implications
are
illustrated
in
Figure
..
The
principal
p
ort
of
eac
h
op
erator
ma
y
b
e
either
an
input
or
an
output.
In
the
rst
case
it
corresp
onds
to
a
new
logical
assumption
in
the
left
hand
side
of
the
sequen
t
(as
for
@),
and
the
op
erator
is
a
destructor;
in
the
second
case
it
corresp
onds
to
the
righ
t
hand
side
of

.
Inter
action
Systems

P
0
P
00
@
?
A
!
B
-
A
+

-
B
-
 -
C
+
P

?
A
!
B
+
A
-

-
B
+
Fig.
..
The
graphical
represen
tation
of
@
and
.
the
sequen
t
(as
for
),
and
the
op
erator
is
a
c
onstructor.
The
other
p
orts
of
the
agen
ts
are
asso
ciated
with
the
auxiliary
form
ulae
of
the
inference
rule,
that
is
the
distinguished
o
ccurrences
of
form
ulae
in
the
upp
er
sequen
ts
of
the
rule.
In
the
t
w
o
rules
ab
o
v
e,
the
auxiliary
form
ulae
are
A
and
B.
The
auxiliary
p
orts
of
an
agen
t
ma
y
b
e
either
inputs
or
outputs,
inde-
p
enden
tly
from
the
fact
that
it
is
a
constructor
or
a
destructor.
Actually
,
in
the
general
theory
of
In
teraction
Nets,
whic
h
is
inspired
b
y
classic
al
(linear)
logic,
there
is
a
complete
symmetry
b
et
w
een
constructors
and
destructors,
and
no
restriction
at
all
is
imp
osed
on
the
t
yp
e
of
the
auxil-
iary
p
orts
(in
other
w
ords,
there
is
a
complete
symmetry
b
et
w
een
inputs
and
outputs).
On
the
con
trary
,
the
fact
of
limiting
ourselv
es
to
the
in-
tuitionistic
case
imp
oses
some
ob
vious
\functional"
constrain
ts.
Note
rst
that
auxiliary
form
ulae
ma
y
come
from
dieren
t
upp
er
se-
quen
ts
or
from
a
single
one.
F
or
instance,
the
auxiliary
p
orts
of
@
are
in
dieren
t
upp
er
sequen
ts,
while
those
of

are
in
a
same
one.
Lafon
t
expresses
this
fact
b
y
dening
p
artitions
of
auxiliary
p
orts.
So,
in
the
case
of
@,
A
and
B
are
in
dieren
t
partitions,
while
in
the
case
of

they
are
in
the
same
partition.
Note
that
the
concept
of
partition
is
ob
viously
related
to
that
of
binding.
In
particular,
a
partition
is
a
singleton
if
and
only
if
the
arit
y
of
the
form
for
that
p
ort
is
0.
Moreo
v
er,
the
p
olarit
y
of
an
auxiliary
p
ort
is
the
opp
osite
of
the
p
olarit
y
of
the
conclusion
it
has
to
b
e
matc
hed
against.
Then,
the
in
tuitionistic
framew
ork
imp
oses
the
follo
wing
constrain
ts:

In
ev
ery
partition
there
is
at
most
one
negativ
e
p
ort.
If
a
negativ
e
p
ort
exists,
w
e
shall
call
it
an
input
partition;
otherwise
it
is
an
output.
The
p
ositiv
e
p
orts
of
an
input
partition
are
called
b
ound
p
orts
of
the
form
(they
are
the
p
orts
connected
to
b
ound
v
ariables).


F
unctional
Pr
o
gr
amming

Ev
ery
agen
t
has
exactly
\one
output"
(functionalit
y).
In
particular,
if
the
agen
t
is
a
constructor,
the
principal
p
ort
is
already
an
output,
and
all
the
partitions
m
ust
b
e
inputs.
Con
v
ersely
,
in
the
case
of
de-
structors,
w
e
ha
v
e
exactly
one
output
partition
among
the
auxiliary
p
orts,
and
this
partition
has
to
b
e
a
singleton.
If
k

:
:
:
k
n
is
the
arit
y
of
a
form,
ev
ery
k
i
denotes
the
n
um
b
er
of
p
ositiv
e
p
orts
in
the
i-th
input
partition.
In
the
case
of
a
destructor,
one
input
partition
m
ust
b
e
a
singleton
(since
it
corresp
onds
to
the
principal
p
ort),
so
its
arit
y
is
0.
By
con
v
en
tion,
in
the
concrete
syn
tax
of
IS's,
w
e
ha
v
e
supp
osed
that
this
is
alw
a
ys
the
rst
partition
of
the
destructor
(this
assumption
is
absolutely
irrelev
an
t).
Summing
up,
a
form
with
arit
y
k

:
:
:
k
n
is
asso
ciated
with
an
op
erator
with

+
P
n
i=
(k
i
+
)
p
orts.
...
Dynamics
Dynamics,
in
logical
systems,
is
giv
en
b
y
the
cut
eliminatio
n
pro
cess;
the
idea
is
that
ev
ery
pro
of
ending
in
to
a
cut
can
b
e
simplied
in
to
an-
other
one
b
y
means
of
some
mec
hanism
that
is
c
haracteristic
of
that
cut
(pro
viding,
in
this
w
a
y
,
a
rewriting
system
o
v
er
pro
ofs).
In
particular,
there
exist
essen
tially
t
w
o
kinds
of
cuts.
The
most
in
teresting
case
is
the
lo
gic
al
cut,
i.e.,
a
cut
b
et
w
een
t
w
o
dual
(left-righ
t)
in
tro
duction
rules
for
the
same
principal
form
ula.
The
w
a
y
suc
h
a
cut
should
b
e
eliminated
is
ob
viously
p
eculiar
to
the
system,
and
to
the
in
tended
seman
tics
of
the
form
ula.
In
all
the
other
cases
(structural
cuts),
In
tuitionistic
Systems
\eliminate"
the
cut
b
y
lifting
it
in
the
premise(s)
of
one
of
the
rules
preceding
the
cut
(that
b
ecomes
the
last
rule
of
the
new
pro
of
).
As
in
the
case
of
-calculus,
these
kind
of
cuts
are
essen
tially
\unobserv
able"
in
IS's
(they
are
dealt
with
in
the
metalev
el
denition
of
substitution).
So,
let
us
concen
trate
on
logical
cuts
only
.
A
t
ypical
case
of
logical
cut
is
that
for
implication
in
In
tuitionistic
Logic.
 ;
x
:
A
`
t
:
B
 `
(x:
t)
:
A
!
B

`
t
0
:
A
y
:
B;

`
t
00
:
C
;
z
:
A
!
B;

`
t
00
[
@(z;t
0
)
=
y
]
:
C
 ;
;

`
t
00
[
@(z;t
0
)
=
y
][
(x:
t)
=
z
]
:
C
The
elimination
of
the
ab
o
v
e
cut
consists
in
in
tro
ducing
t
w
o
cuts
of

.
Inter
action
Systems
	
lesser
grade
(see
[Gir	b
]).
The
rewritten
pro
of
is:

`
t
0
:
A
 ;
x
:
A
`
t
:
B
y
:
B;

`
t
00
:
C
 ;
x
:
A;

`
t
00
[
t
=
y
]
:
C
 ;
;

`
t
00
[
t
=
y
][
t
0
=
x
]
:
C
Since
b
y
assumption
t
00
[
@(z;t
0
)
=
y
][
(x:
t)
=
z
]
=
t
00
[
t
=
y
][
t
0
=
x
]
this
meta-op
eration
on
pro
ofs
ob
viously
induces
the
b
eta-reduction
rule
in
the
underlying
IS.
Graphically
,
the
ab
o
v
e
cut
elimination
rule
can
b
e
represen
ted
as
fol-
lo
ws:
P
0
P
00
@
?
(A
!
B)
-
A
+

-
B
-

-
C
+
P

?
(A
!
B)
+
A
-
 -
B
+
reduces
to:
P
0
P
00
A
+

-
B
-

-
C
+
P
A
-
 -
B
+
In
general,
let
L
and
R
b
e
the
left
and
righ
t
sequen
t
in
the
cut-rule,
resp
ectiv
ely
.
During
the
pro
cess
of
cut-elimination,
the
pro
ofs
ending
in
to
the
premises
of
L
and
R
m
ust
b
e
considered
as
\blac
k
b
o
xes"
(only
their
\in
terfaces",
that
is
their
nal
sequen
ts
are
kno
wn).
During
cut-
elimination,
one
can
build
new
pro
ofs
out
of
these
blac
k
b
o
xes.
The
unique
constrain
t
is
the
pr
ohibition
of
having
new
hyp
otheses
in
the
nal
sequen
t
of
rewritten
pro
of.
This
has
t
w
o
implications:
(i)
the
v
ariables
b
ound
b
y
L
or
R
(i.e.,
the
auxiliary
form
ulae
of
the

0
F
unctional
Pr
o
gr
amming
rules)
m
ust
b
e
suitably
lled
in
(t
ypically
with
cuts
or
in
tro
ducing
new
rules
binding
them);
(ii)
if
a
new
axiom
is
in
tro
duced
b
y
the
rewriting,
then
the
h
yp
othesis
in
the
lhs
m
ust
b
e
consumed
(with
a
cut
or
b
y
binding
it
via
a
logical
rule)
inside
the
rewritten
pro
of.
According
to
statics,
a
cut
in
an
in
tuitionistic
pro
of
system
corre-
sp
onds
to
a
term
of
the
kind
d(c(
~
x

:
X

;



;
~
x
m
:
X
m
);



;
~
x
n
:
X
n
)
that
is
just
an
IS's
redex.
The
X
i
represen
t
the
pro
ofs
ending
in
to
the
upp
er
sequen
ts
of
L
and
R
(the
\blac
k
b
o
xes"
ab
o
v
e),
and
the
ab
o
v
e
conditions
on
the
rewritten
pro
of
are
ob
viously
reected
in
IS's
b
y
left
linearit
y
and
the
assumption
that
righ
t
hand
sides
of
rules
m
ust
b
e
closed
expressions.
Example
..
(Naturals)
If
w
e
do
not
lik
e
to
in
tro
duce
all
naturals
as
explicit
constructors,
w
e
could
just
w
ork
with
t
w
o
constructors
0
and
succ
,
resp
ectiv
ely
asso
ciated
with
the
follo
wing
righ
t
in
tro
duction
rules:
(nat;
right
0
)
`
0
:
nat
(nat;
right
S
)
;
`
n
:
nat

`
succ
(n)
:
nat
A
t
ypical
destructor
is
add.
(nat;
left
add
)

`
p
:
nat
 ;
y
:
nat
`
t
:
A
;
 ;
x
:
nat
`
t[
add
(x;p)
=
y
]
:
A
where
A
can
b
e
an
y
t
yp
e.
The
follo
wing
is
an
example
of
cut:
`
0
:
nat

`
p
:
nat
y
:
nat;

`
t
:
A
;
x
:
nat;

`
t[
add
(x;p)
=
y
]
:
A
;

`
t[
add
(x;p)
=
y
][
0
=
x
]
:
A
that
is
simplied
in
to:

`
p
:
nat
y
:
nat;

`
t
:
A
;

`
t[
p
=
y
]
:
A
The
ab
o
v
e
eliminatio
n
induces
the
IS-rule
add
(0;
X)
!
X,
corresp
ond-
ing
to
the
equation
t[
add
(x;p)
=
y
][
0
=
x
]
=
t[
p
=
y
].
Graphically:

.
Inter
action
Systems

P
0
P
00
add
?
nat
-
nat
+

-
nat
-

-
A
+
0
?
nat
+
reduces
to:
P
0
P
00
nat
+

-
nat
-

-
A
+
Example
..
(Lists)
Lists
are
dened
b
y
means
of
t
w
o
construc-
tors
cons
and
nil
of
arit
y
00
and
",
resp
ectiv
ely
.
The
t
ypical
destructors
are
hd
and
tl
of
arit
y
0.
In
the
case
of
lists
of
in
tegers,
w
e
ma
y
write
the
follo
wing
in
tro
duction
rules
for
the
t
yp
e
natlist:
(natlist
;
right
nil
)
`
nil
:
natlist
(natlist
;
right
c
ons
)

`
n
:
nat
 `
l
:
natlist
;
 `
cons
(n;
l)
:
natlist
(natlist
;
left
hd
)
 ;
y
:
nat
`
t
:
A
 ;
x
:
natlist
`
t[
hd
(x)
=
y
]
:
A
(natlist
;
left
tl
)
 ;
y
:
natlist
`
t
:
A
 ;
x
:
natlist
`
t[
tl
(x)
=
y
]
:
A
A
t
ypical
cut
is:

`
n
:
nat
 `
l
:
natlist
;
 `
cons
(n;
l)
:
natlist
;
y
:
nat
`
t
:
A
;
x
:
natlist
`
t[
hd(x)
=
y
]
:
A
;
 ;

`
t[
hd
(x)
=
y
][
cons
(n;l)
=
x
]
In
this
case,
the
cut
w
ould
b
e
eliminated
in
the
follo
wing
w
a
y

`
n
:
nat
;
y
:
nat
`
t
:
A
;

`
t[
n
=
y
]
:
A


F
unctional
Pr
o
gr
amming
corresp
onding
to
the
reduction
rule
hd(cons
(X;
Y
))
!
X.
Graphically:
P
P
0
cons
?
natlist
+
nat
+

-
 -
natlist
+
P
00
hd
?
natlist
+

+
nat
-
A
+
reduces
to:
P
nat
+

-
P
00

+
nat
-
A
+
Note
here,
b
y
the
w
a
y
,
the
phenomenon
of
garbage
creation
(P').
All
the
rewriting
rules
considered
so
far
are
line
ar
in
their
meta-
v
ariables.
An
in
teresting
example
of
non
linear
rule
is
pro
vided
b
y
the
recursion
op
erator
,
dened
b
y:
x:M
!
M[
x:M
=
x
]
As
w
e
discussed
in
Example
..,
this
is
a
degenerate
case
of
IS-rule,
and
th
us
a
degenerate
case
of
\cut".
The
idea
is
that,
giv
en
a
pro
of
of
the
kind
 ;
x
:
A
`
M
:
A
 `
x:M
:
A
it
can
b
e
rewritten
as
 ;
x
:
A
`
M
:
A
 `
x:M
:
A
 ;
x
:
A
`
M
:
A
 ;
 `
M[
x:M
=
x
]
:
A
 `
M[
x:M
=
x
]
:
A
Note
the
double
use
of
the
meta
v
ariable
M
in
the
rule,
whic
h
is
reected
b
y
the
double
use
of
the
subpro
of
of
 ;
x
:
A
`
M
:
A
in
the
latter
pro
of.
Graphically
w
e
ha
v
e
something
of
the
follo
wing
kind:

.
Sharing
Gr
aphs
Implementation

?

M
 A
-
A
+
)
M
A
-
A
+
 ?

M
A
-
A
+
 Note
that
the
p
ortion
of
graph
corresp
onding
to
M
has
b
een
duplicated.
Moreo
v
er,
all
the
free
v
ariables
in
M
(those
mark
ed
with
 in
the
picture
ab
o
v
e)
m
ust
b
e
suitably
shared.
This
means
that
the
subterm
M
has
to
b
e
considered
as
a
global
en
tit
y
(a
b
ox,
in
Linear
Logic
terminology),
and
w
e
lo
ose
the
p
ossibilit
y
to
express
the
rewriting
rule
as
a
lo
cal
op
eration
in
teracting
with
the
rest
of
the
w
orld
only
through
an
in
terface.
Ho
w
ev
er
the
lo
calit
y
of
rewriting
rules
can
still
b
e
reco
v
ered
b
y
im-
plementing
IS's
in
sharing
graphs:
w
e
ha
v
e
just
to
use
Lamping's
fan
op
erators,
replacing
the
graph
in
the
righ
t
hand
side
b
y
a
structure
of
the
follo
wing
kind:

?
a

?
a
?

M
A
-
A
+
 The
main
problem,
that
w
e
shall
address
in
the
follo
wing
sections,
is
to
put
croissan
ts
and
brac
k
ets
in
suc
h
a
w
a
y
as
to
guaran
tee
the
correct
matc
hing
b
et
w
een
the
fan-in
and
the
fan-out,
and
to
a
v
oid
conicts
with
the
in
ternal
op
erator
of
the
b
o
x.
.
Sharing
Graphs
Implemen
tati
on
In
this
section
w
e
shall
describ
e
the
optimal
implem
en
tation
of
In
terac-
tion
Systems
in
Sharing
Graphs.
W
e
shall
not
giv
e
neither
the
correct-
ness
nor
the
optimalit
y
pro
of,
whic
h
are
quite
tec
hnical
and
not
v
ery
informativ
e.
Actually
,
b
oth
these
asp
ects
essen
tially
follo
ws
b
y
the
cor-
rectness
and
optimalit
y
of
the
Sharing
Graphs
implemen
tation
of
(the


F
unctional
Pr
o
gr
amming
b
o
x
of
)
Linear
Logic.
Let
us
also
remark
that
the
optimalit
y
pro
of
re-
quires
the
preliminary
generalization
of
the
notion
(and
the
theory)
of
family
reduction
to
IS's.
The
simplest
w
a
y
to
extend
this
notion
is
b
y
dening
a
suitable
lab
eled
v
ersion
of
the
reduction
system.
Again,
the
in
tuition
is
simple,
but
the
details
are
quite
in
v
olv
ed
(see
[AL	b
])
and
w
e
shall
skip
them
y
.
The
optimal
implemen
tation
is
describ
ed
as
a
graph
rewriting
sys-
tem,
where
the
no
des
of
the
graph
are
either
con
trol
op
erators
(squares,
croissan
ts
and
fans)
or
syn
tactical
forms
of
the
IS.
W
e
shall
start
with
discussing
the
general
enco
ding
of
IS-expressions;
subsection
..
will
deal
with
the
translation
of
IS-rewriting
rules.
..
The
enc
o
ding
of
IS-expr
essions
The
general
idea
of
the
enco
ding
in
to
Sharing
Graphs
is
v
ery
simple:
eac
h
meta
v
ariable
(that
can
p
ossibly
ha
v
e
a
not
linear
use)
is
put
inside
a
b
o
x
(represen
ted
in
the
usual
w
a
y).
F
or
the
sak
e
of
simplicit
y
,
w
e
shall
merely
consider
the
paradigmatic
case
when
constructors
and
destruc-
tors
ha
v
e
resp
ectiv
ely
arit
y

and
0.
The
other
cases
are
easily
deriv
ed.
The
enco
ding
is
dened
b
y
the
translation
of
Figure
.
(as
usual
w
e
ha
v
e
[M]
=
[M]
0
).
In
this
gure,
the
dangling
edges
in
the
b
ottom
represen
t
generic
free
v
ariables
whic
h
are
not
b
ound
b
y
the
forms
c
and
d.
As
usual,
if
some
b
ound
v
ariable
do
es
not
o
ccur
in
the
b
o
dy
the
corresp
onding
p
ort
of
the
binder
is
connected
to
a
garbage
no
de.
Note
that
when
w
e
put
an
argumen
t
of
a
constructor
or
a
destructor
inside
a
b
o
x
the
con
trol
op
erators
to
b
e
added
at
the
lev
el
of
the
b
ound
v
ariable
are
dieren
t
form
the
con
trol
op
erators
to
b
e
added
to
free
v
ari-
ables.
The
reader
should
in
tuititiv
ely
imagine
to
ha
v
e
a
pseudo-binder
(a
-abstraction)
b
et
w
een
the
form
and
the
b
o
dy
of
the
argumen
t;
in
par-
ticular,
rst,
w
e
p
erfom
the
abstraction,
then,
w
e
build
the
b
o
x.
Since
the
pseudo-binder
is
a
ghost,
it
magically
disapp
ears,
and
w
e
obtain
the
translation
of
Figure
..
The
reason
for
pro
ceeding
in
this
w
a
y
will
y
The
general
idea
is
the
follo
wing.
When
a
redex
is
red,
a
lab
el

is
captured
b
et
w
een
the
destructor
and
the
constructor
;
this
is
the
lab
el
asso
ciated
with
the
redex.
Then,
the
rhs
of
the
rewriting
rule
m
ust
b
e
suitably
\mark
ed"
with
,
in
order
to
k
eep
a
trace
of
the
history
of
the
creation.
Moreo
v
er,
since
in
the
rhs
w
e
ma
y
in
tro
duce
new
forms,
w
e
m
ust
guaran
tee
a
prop
ert
y
similar
to
the
initial
lab
eling,
where
all
lab
els
are
dieren
t.
This
means
that
all
links
in
the
rhs
m
ust
b
e
mark
ed
with
a
dieren
t
function
of

(w
e
can
use
sequences
of
in
tegers,
for
this
purp
ose).

.
Sharing
Gr
aphs
Implementation

[x]n
n
= 
= 
n
[c(<x>.M)]
n
n
n
*
n
[N]n+1
[M]n
[d(M,<x>.N)]n
= 
c
[M]n+1
. . .
n
n
d
. . .
. . .
. . .
Fig.
..
The
enco
ding
of
IS-expressions
b
ecome
clear
when
w
e
will
describ
e
the
translation
of
the
IS-rewriting
rules.
A
t
that
stage,
the
ghost-binder
will
b
ecome
apparen
t
and
will
pla
y
an
essen
tial
role
during
partial
ev
aluation.
..
The
tr
anslation
of
r
ewriting
rules
Rewriting
rules
ma
y
b
e
classied
in
three
groups:
con
trol
rules,
in
ter-
facing
rules
and
prop
er
rules.
W
e
shall
discuss
eac
h
group
separately
.
...
Contr
ol
R
ules
These
are
the
w
ell
kno
wn

rules
for
annihilation
and
m
utual
crossing
of
con
trol
op
erators.
These
rules
pro
vide
the
general
framew
ork
for
the
optimal
implemen
tation
of
the
structural
part
of
an
y
IS's.
...
Interfacing
R
ules
These
are
the
rules
whic
h
describ
e
the
in
teraction
b
et
w
een
con
trol
op-
erators
and
forms
of
the
syn
tax
(that
is,
they
describ
e
the
in
terface
b
et
w
een
the
structural
and
the
logical
part
of
IS's).
These
rules
ha
v
e
a


F
unctional
Pr
o
gr
amming
p
olimorphic
nature.
W
e
dene
them
b
y
means
of
sc
hemas,
where
f
can
b
e
an
arbitrary
form
of
the
syn
tax.
The
rules
are
dra
wn
in
Figure
..
a
f
.   .   .
b
c
i
i
j+1
.   .   .
j
b
c
i
f
a
i  <  j 
a
f
.   .   .
b
c
j-1
i
i
f
.   .   .
j
i
b
c
a
i  <  j
i  <  j 
.   .   .
j
f
a
b
c
d
*
i
f
j
f
j
a
b
.   .   .
c
d
*
*
i
i
Fig.
..
The
in
terfacing
rules
b
et
w
een
con
trol
op
erators
and
forms.
As
y
ou
see,
in
terfacing
the
structural
and
the
logical
part
of
IS
at
the
implemen
tati
on
lev
el
is
very
simple.
This
is
a
main
consequence
of
the
logical
nature
of
IS's,
and
one
of
the
main
motiv
ations
for
their
denition.
...
Pr
op
er
R
ules
These
rules
describ
e
the
in
teractions
b
et
w
een
destructors
and
construc-
tors
of
the
IS's.
These
are
the
only
rules
whic
h
are
dep
enden
t
from
the
particular
In
teraction
System
under
in
v
estigation,
and
the
only
ones
whic
h
deserv
e
some
care,
in
the
translation.
W
e
shall
dene
the
imple-
men
tation
of
the
rewriting
rules
in
four
steps:
-expansion,
linearization,
translation
and
partial
ev
aluation.
The
idea
b
ehind
-expansion
and
linearization
is
that
of
expliciting
the
\in
terface"
b
et
w
een
the
new
forms
whic
h
ha
v
e
b
een
p
ossibly
in
tro-
duced
in
the
rhs
of
the
rule,
and
the
meta
v
ariables
in
its
lhs.
Then,
w
e
ma
y
essen
tially
translate
the
rhs
as
a
normal
term,
just
regarding
eac
h
meta
v
ariable
as
a
\blac
k
b
o
x".
Finally
,
w
e
m
ust
partially
ev
aluate
the
graph
obtained
in
this
w
a
y
,
since
during
-expansion
and
linearization
w
e
ha
v
e
in
tro
duced
some
\pseudo-op
erators"
whic
h
should
disapp
ear.
The
linearization
step
is
particularly
imp
ortan
t
(-expansion
is
just
aimed
to
linearization).
It
purp
ose
is
to
obtain
an
equiv
alen
t
form
of
the

.
Sharing
Gr
aphs
Implementation

rewriting
rule
where
eac
h
meta
v
ariable
is
used
linearly
in
the
rhs
(recall
the
problem
of

in
Example
..).
(-expansion)
The
rst
step
is
to
-expand
all
substitutions
in
the
rhs.
The
aim
of
this
step
is
to
pro
vide
a
clean
vision
of
all
the
meta
v
ariables
in
the
rhs.
F
or
this
purp
ose
w
e
shall
use
t
w
o
classes
of
pseudo-forms:
abstraction
Abs
n
and
application
App
n
,
for
n

0.
Pseudo-forms
are
similar
to
all
other
forms
of
the
syn
tax.
Abs
n
is
a
constructor
of
arit
y
n
whilst
App
n
is
a
destructor
of
arit
y
0
n+
.
As
the
reader
could
probably
imagine,
they
generalize
-calculus
abstraction
and
application.
Their
in
teraction
is
expressed
b
y
the
rule:
App
n
(Abs
n
(hx

;



;
x
n
i:
X);
Y

;



;
Y
n
)
!
X[
Y

=
x

;



;
Y
n
=
x
n
]
The
step
of
-expansion
consists
in
rewriting
the
rhs
of
the
IS-rule
b
y
-
expanding
substitutions
in
to
in
teractions
of
the
pseudo-op
erators
Abs
n
and
App
n
.
In
particular,
after
the
-expansion,
all
meta
v
ariables
are
closed
b
y
pseudo
binders,
i.e.
they
b
ecome
expressions
of
the
follo
wing
kind:
Abs
n
(
~
x:
M).
Example
..
Consider
the
rewriting
rule
for
:
x:M
!
M[
y:M[
y
=
x
]
=
x
]
The
-expansion
of
the
rhs
giv
es
the
follo
wing
term:
App
(Abs(x:
M);
(y:
App
(Abs
(x:
M);
y))))
(linearization
)
The
next
step
consists
in
line
arizing
the
rhs
w.r.t.
the
o
ccurrences
of
expressions
Abs
n
(
~
x:
X).
This
is
obtained
b
y
taking,
for
ev
ery
meta
v
ariable
X
i
o
ccurring
in
the
left
hand
side
of
the
IS-rewriting
rule
(let
them
b
e
k),
a
fresh
pseudo-variable
w
i
and
replacing
ev
ery
o
ccurrence
of
Abs
n
(
~
x
i
:
X
i
)
with
w
i
.
In
this
w
a
y
w
e
yield
a
metaexpres-
sion
T
.
Next
T
is
closed
w.r.t.
the
meta
v
ariables
w
i
's,
and
the
(closed)
meta
v
ariables
Abs
n
(
~
x
i
:
X
i
)
are
passed
as
argumen
ts
to
this
term.
In
other
w
ords,
b
y
linearization,
w
e
get
a
metaexpression
of
the
follo
wing
kind,
where
eac
h
meta
v
ariable
o
ccur
exactly
once
(and
no
substitution
is
applied
to
them):
App
k
(Abs
k
(hw

;



;
w
k
i:
T
);
Abs
n

(
~
x

:
X

);



;
Abs
n
k
(
~
x
k
:
X
k
))
(n
i
is
the
arit
y
of
the
meta
v
ariable
X
i
.)
Example
..
After
the
linearization
step,
the
rhs
of
the
recursion


F
unctional
Pr
o
gr
amming
rule
b
ecomes:
App
(Abs
(w:
App
(w;
y:
App
(w;
y)));
Abs
(x:
M))
Let
us
remark
that
ev
ery
meta
v
ariable
in
the
lhs
of
the
IS-rewriting
rule
o
ccurs
exactly
once
in
the
linearized
metaexpression
yielded
b
y
the
ab
o
v
e
pro
cedure,
ev
en
if
it
do
es
not
o
ccur
in
the
rhs
of
the
IS-rewriting
rule.
F
or
instance,
in
the
case
of
conditionals,
the
linearization
of
the
rhs
of
\(T;
X;
Y
)
!
X
giv
es
App

(Abs

(hw

;
w

i:
w

);
Abs
0
(X);
Abs
0
(Y
)):
The
actual
erasing
will
b
e
p
erformed
in
the
follo
wing
steps
(see
transla-
tion
and
partial
ev
aluation).
(translation)
This
step
pro
vides
the
graphical
represen
tation
of
the
rhs
of
the
rule.
It
is
essen
tial
that,
during
the
translation,
w
e
ma
y
consider
eac
h
sub
expression
Abs
n
(
~
x:
X)
as
a
\blac
k-b
o
x".
According
to
the
linearization
step,
the
expression
that
results
will
ha
v
e
the
shap
e
App
k
(M;
Abs
n

(
~
x

:
X
i

);



;
Abs
n
k
(
~
x
k
:
X
i
k
))
The
translation
of
this
expression
is
dra
wn
in
Figure
.,
where,
for
simplicit
y
,
w
e
ha
v
e
assumed
n
i
=
,
for
ev
ery
i.
Note
that
meta
v
ariables
are
not
put
inside
b
o
xes:
they
alr
e
ady
ar
e
b
o
xes,
due
to
the
translation
of
expressions
in
Figure
..
In
particular,
no
op
eration
around
the
(unaccessible!)
free
v
ariables
of
the
instance
of
the
meta
v
ariable
m
ust
b
e
p
erformed.
App k
[M]n
. . .
. . .
n
. . .
. . .
n+1
n+1
[X]
[X]
n+1
n+1
Abs
Abs
Fig.
..
The
translation
step
No
w
w
e
can
pro
vide
some
more
in
tuition
ab
out
our
translation
in
Figure
.,
and
the
role
of
the
\ghost-binders".
In
particular,
ghost-
binders
b
ecome
apparen
t
in
the
translation
in
Figure
.:
they
are

.
Sharing
Gr
aphs
Implementation
	
the
Abs
pseudo-forms.
The
reason
for
in
tro
ducing
ghost-binder
when
translating
rules,
instead
of
when
translating
terms,
is
that
w
e
ma
y
no
w
partially
ev
aluate
the
rhs,
eliminating
all
pseudo-forms
whic
h
ha
v
e
b
een
just
in
tro
duced
for
con
v
enience.
This
is
the
purp
ose
of
the
next,
nal
phase.
Ob
viously
,
all
the
other
pseudo-applications
and
pseudo-
abstractions
are
translated
as
usual
applications
and
-no
des.
Example
..
According
to
the
previous
rules,
the
righ
t
hand
side
of
the
recursion
rule
has
the
shap
e
of
Figure
.
(w
e
implicitly
p
erformed
some
safe
optimizations,
see
Chapter
	)
. . .
n+1
n+1
[M]
Abs
Abs
n
n
App
*
i
n
n
App
n
µ
n+1
App
n+1
Fig.
..
The
rhs
for
the
recursion
rule.
A
nal
observ
ation
b
efore
discussing
partial
ev
aluation.
As
already
said,
some
meta
v
ariables
in
the
lhs
of
the
IS-rewriting
rule
could
not
o
ccur
in
the
rhs
(e.g.,
the
case
of
conditionals).
According
to
the
trans-
lation
of
Abs,
the
corresp
onding
pseudo-v
ariable
in
tro
duced
in
the
lin-
earization
step
is
implemen
ted
b
y
a
garbage
no
de
(since
it
do
es
not
o
ccur
in
the
b
o
dy
of
the
leftmost
outermost
Abs).
This
implies
that,
during
the
next
phase,
the
corresp
onding
expression
will
b
e
ev
en
tually
erased.
(partial
ev
aluation)
The
nal
step
is
to
partially
ev
aluate
the
term
w
e
ha
v
e
obtained
after
the
translation
w.r.t.
all
pseudo
op
erators.
The
reduction
rule
for
pseudo
application
and
abstraction
is

0
F
unctional
Pr
o
gr
amming
Abs
n
-
App
n


n
0
b
ound
p
orts
0

n+
)
0

n
0

n+
Note
that
n
can
b
e
0.
In
this
case,
the
rewriting
rule
simply
consists
in
connecting
the
t
w
o
edges
coming
in
to
the
auxiliary
p
orts
of
Abs
0
and
App
0
.
It
is
easy
to
pro
v
e
that
the
partial
ev
aluation
of
the
expressions
yielded
b
y
the
previous
translation
steps
strongly
normalizes
to
a
graph
without
pseudo-forms
(essen
tially
,
it
is
a
direct
consequence
of
the
fact
that
all
pseudo-op
erators
ha
v
e
b
een
created
b
y
-expansions).
Example
..
By
applying
the
previous
tec
hnique
to
our
w
orking
example
of
the
recursion
op
erator,
w
e
nally
obtain
the
optimal
reduc-
tion
rule
of
Figure
.,
in
Sharing
Graphs.
*
n
. . .
n
n
n
*
n
n
µ
µ
a
a
b
c
b
c
Fig.
..
The
optimal
implemen
tation
of
recursion
in
Sharing
Graphs.
Remark
..
The
previous
translation
can
b
e
impro
v
ed
b
y
consider-
ing
sp
ecial
cases
of
the
particular
IS's
under
in
v
estigation.
In
particular,
some
op
erators
of
the
syn
tax
could
mak
e
only
a
linear
use
of
some
of
their
argumen
ts.
F
or
instance,
this
is
the
case
of
the
-calculus,
where
the
b
o
dy
of
the
abstraction
is
treated
linearly
in
-reduction.
These
lin-
ear
argumen
ts
ma
y
deserv
e
a
simpler
translation,
since
there
is
no
need

.
Sharing
Gr
aphs
Implementation

to
put
them
inside
a
\b
o
x".
Ho
w
ev
er,
in
order
to
conclude
that
some
op
erator
f
b
eha
v
es
linearly
o
v
er
one
of
its
argumen
ts
w
e
m
ust
examine
al
l
the
in
teraction
rules
in
v
olving
f.
Th
us,
the
c
hoice
of
the
rewriting
system
and
its
forms
ma
y
ha
v
e
a
big
impact
on
the
practical
eciency
of
the
implemen
tatio
n.


The
Bologna
Optimal
Higher-order
Mac
hine
This
c
hapter
describ
es
the
main
arc
hitecture
of
the
Bologna
Optimal
Higher-order
Mac
hine
(bohm).
bohm
is
a
protot
yp
e
implemen
tatio
n
of
an
extension
of
Lamping's
optimal
graph
reduction
tec
hnique.
Its
source
language
is
a
sugared
-
calculus
enric
hed
with
b
o
oleans,
in
tegers,
lists
and
basic
op
erations
on
these
data
t
yp
es.
The
op
erational
seman
tics
of
bohm
will
b
e
giv
en
in
the
form
of
an
In
teraction
System.
In
particular,
this
means
that:
(i)
All
syn
tactical
op
erators
will
b
e
represen
ted
as
no
des
in
a
graph.
(ii)
No
des
will
b
e
divided
in
to
c
onstructors
and
destructors.
(iii)
Reduction
will
b
e
expressed
as
a
lo
cal
in
teraction
(graph
rewrit-
ing)
b
et
w
een
constructor-destruc
tor
pairs.
The
reader
should
not
b
e
particularly
surprised
of
this,
for
w
e
already
describ
ed
in
detail
the
tigh
t
relation
b
et
w
een
In
teraction
Systems
and
optimal
implemen
tations
(see
Chapter
).
F
rom
the
reduction
p
oin
t
of
view,
bohm
is
a
lazy
system.
Namely
,
giv
en
an
input
term,
it
reduces
the
corresp
onding
graph
un
til
the
top-
most
no
de
(i.e.,
the
one
connected
to
the
\ro
ot")
b
ecomes
a
constructor.
bohm
is
just
a
high
lev
el
in
terpreter
written
in
C.
Its
purp
ose
w
as
not
to
b
e
a
real
implemen
tatio
n,
but
to
pro
vide
some
empirical
evidence
ab
out
the
feasibilit
y
of
Lamping's
tec
hnique.
Because
of
this,
particular
care
has
b
een
dev
oted
in
supp
orting
the
user
with
a
large
set
of
data
on
the
resources
used
b
y
computations
(user
and
system
time,
n
um
b
er
of
in
teractions,
storage
allo
cation,
garbage
collection,
and
so
on).
The
source
co
de
is
a
v
ailable
b
y
anon
ymous
ftp
at
ftp.cs.unibo.it,
in
the
directory
/pub/asperti,
under
the
name
BOHM.tar.Z
(compressed
tar
format).


.
Sour
c
e
L
anguage

.
Source
Language
As
describ
ed
in
Chapter
,
Lamping's
optimal
implemen
tation
tec
h-
nique
can
b
e
generalized
to
In
teraction
Systems.
This
means
that:
(i)
It
is
p
ossible
to
translate
an
arbitrary
IS-expression
in
to
a
suit-
able
graph
represen
tation
using
Lamping's
con
trol
op
erators
for
represen
ting
structural
information
(sharing),
and
new
graphical
forms
for
the
logical
part
of
the
system
(in
particular,
w
e
shall
ha
v
e
a
new
graphical
form
for
eac
h
op
erator
in
the
signature).
(ii)
An
y
IS-rewriting
rule
has
an
asso
ciated
graph
rewriting
rule,
cor-
resp
onding
to
the
lo
cal
in
teraction
of
t
w
o
forms
at
their
principal
p
orts.
(iii)
The
graph
rewriting
rules
are
correct
and
optimal
w.r.t.
the
giv
en
In
teraction
System.
The
main
issue
of
this
extension
is
that
In
teraction
Systems
are
p
o
w-
erful
enough
to
encompass
all
t
ypical
constructs
of
a
\core"
functional
language.
The
source
language
of
bohm
is
a
sugared
-calculus
enric
hed
with
some
primitiv
e
data
t
yp
es
(b
o
oleans,
in
tegers,
lists)
equipp
ed
b
y
the
usual
op
erations,
and
t
w
o
more
con
trol
o
w
constructs:
an
explicit
x-
p
oin
t
op
erator
(rec)
and
a
conditional
if-then-else
statemen
t.
The
syn
tax
of
the
language
accepted
b
y
bohm
is
giv
en
in
Figure
..
.
Reduction
The
op
erational
seman
tics
of
the
language
is
giv
en
in
the
form
of
an
In
teraction
System.
Therefore,
all
the
rewriting
rules
will
th
us
b
e
written
as
destructor-constructor
in
teractions.
In
some
cases,
this
will
ho
w
ev
er
require
the
in
tro
duction
of
a
few
auxiliary
destructors.
The
full
list
of
constructors,
destructors,
and
their
resp
ectiv
e
arities,
is
giv
en
b
elo
w:
constructors

:
;
true
:
";
false
:
";
m
:
",
for
eac
h
in
teger
m;
nil
:
";
cons
:
00.
destructors
@
:
00;
+
:
00;
+
m
:
0;
-
:
00;
-
m
:
0;

:
00;

m
:
0;
div
:
00;
div
m
:
0;
mo
d
:
00;
mo
d
m
:
0;
and
:
00;
o
r
:
00;
not
:
0;
==
:
00;
==
m
:
0;
>
:
00;
>
m
:
0;
<
:
00;
<
m
:
0;
>=
:
00;
>=
m
:
0;
<=
:
00;
<=
m
:
0;
<>
:
00;
<>
m
:
0;
head
:
0;
tail
:
0;
if
then
else
:
000.


The
Bolo
gna
Optimal
Higher-or
der
Machine
hexpri
::=
true
j
false
j
hn
um
consti
j
hiden
tieri
j
(happlisti)
j
\
hiden
tieri
.
hexpri
j
let
hiden
tieri
=
hexpri
in
hexpri
j
rec
hiden
tieri
=
hexpri
j
if
hexpri
then
hexpri
else
hexpri
j
hexpri
and
hexpri
j
hexpri
or
hexpri
j
not
hexpri
j
hexprihrelopihexpri
j
hexprihmathopihexpri
j
hlisti
j
cons
(hexpri,
hexpri)
j
head
(hexpri)
j
tail
(hexpri)
j
isnil
(hexpri)
hlisti
::=
nil
j
[hexprlisti]
hexprlisti
::=
hexpri
j
hexpri,
hexprlisti
happlisti
::=
hexpri
j
happlistihexpri
hrelopi
::=
<
j
==
j
>
j
<=
j
>=
j
<>
hmathopi
::=
+
j
-
j
*
j
div
j
mod
Fig.
..
bohm's
syn
tax
As
already
remark
ed,
rec
is
the
unique
exception
to
the
previous
clas-
sication.
Indeed,
rec
is
b
y
itself
a
constructor-destructor
pair.
Here
are
the
prop
er
in
teractions
of
the
rewriting
system:

Beta-r
e
duction
(x:
M
N)
!
M[N=x]

R
e
cursive
Denition
rec
x
=
M
!
M[(rec
x
=
M)=x]

.
R
e
duction


A
rithmetic
al
Op
er
ators
m
+
M
!
+
m
(M)
+
m
(n)
!
p
where
p
is
the
sum
of
m
and
n
m
-M
!
-
m
(M)
-
m
(n)
!
p
where
p
is
the
dierence
of
m
and
n
m

M
!

m
(M)

m
(n)
!
p
where
p
is
the
pro
duct
of
m
and
n
m
div
M
!
div
m
(M)
div
m
(n)
!
p
where
p
is
the
quotien
t
of
the
division
of
m
b
y
n
m
mo
d
M
!
mo
d
m
(M)
mo
d
m
(n)
!
p
where
p
is
the
rest
of
the
division
of
m
b
y
n

Bo
ole
an
Op
er
ators
true
and
M
!
M
false
and
M
!
false
true
o
r
M
!
true
false
o
r
M
!
M
not
false
!
true
not
true
!
false

R
elational
Op
er
ators
m
==
M
!
==
m
(M)
==
m
(m)
!
true
]isf==
m
(n)
!
false
if
n
=
m
m
<
M
!
<
m
(M)
<
m
(n)
!
true
if
m
is
less
than
n
<
m
(n)
!
false
if
m
is
not
less
than
n
m
>
M
!
>
m
(M)
>
m
(n)
!
true
if
m
is
greater
than
n
>
m
(n)
!
false
if
m
is
not
greater
n
m
<=
M
!
<=
m
(M)
<=
m
(n)
!
true
if
m
is
not
greater
than
n
<=
m
(n)
!
false
if
m
is
greater
than
n
m
>=
M
!
>=
m
(M)
>=
m
(n)
!
true
if
m
is
not
less
than
n
>=
m
(n)
!
false
if
m
is
less
than
n
m
<>
M
!
<>
m
(M)
<>
m
(m)
!
false
<>
m
(n)
!
true
if
n
=
m


The
Bolo
gna
Optimal
Higher-or
der
Machine

Op
er
ator
for
list
manipulation
head
(cons
(M;
N))
!
M
tail(cons(M;
N))
!
N
tail(nil)
!
nil
isnil(cons
(M;
N))
!
false
isnil(nil)
!
true

The
c
ontr
ol
ow
op
er
ator
if-then-else
if
true
then
M
else
N
!
M
if
false
then
M
else
N
!
N
..
Gr
aph
Enc
o
ding
bohm's
con
trol
op
erators
for
sharing
are
a
compromise
b
et
w
een
Lamp-
ing's
original
ones
(square
brac
k
et,
croissan
t
and
fan)
and
Guerrini's
multiplexers.
In
particular,
it
uses
t
w
o
con
trol
op
erators:
the
triangle
and
the
fan,
that
should
b
e
resp
ectiv
ely
understo
o
d
as
a
m
ux
with
one
or
t
w
o
auxiliary
p
orts
(see
Figure
.).
n
i
*
n
i
j
Fig.
..
bohm's
triangle
and
fan
Similarly
to
a
mux,
eac
h
auxiliary
p
ort
has
an
asso
ciated
w
eigh
t.
So,
a
croissan
t
is
just
a
triangle
with
w
eigh
t
-,
a
square
brac
k
et
is
a
triangle
with
w
eigh
t

and
Lamping's
fan
is
bohm's
fan
with
w
eigh
t
0
on
b
oth
auxiliary
p
orts.
The
adv
an
tage
of
triangles
and
generalized
fans,
is
that
they
allo
w
to
compress
a
long
sequence
of
con
trol
op
erators
in
to
a
single
no
de.
In
particular,
when
the
lower
op
er
ator
is
safe,
w
e
can
apply
the
\merging"
rules
in
Figure
..
Practically
,
on
t
ypical
examples,
the
in
tro
duction
of
these
m
ux-lik
e
op-
erators
ma
y
easily
sp
eed
up
the
reduction
time
of
an
order
of
magnitude,
with
resp
ect
to
Lamping's
algorithm.
On
the
other
side,
w
e
made
sev
eral
attempts
to
implemen
t
Guerrini's
m
ultiplexers,
but
none
of
them
pro-
vided
the
exp
ected
results.
The
reason
is
that
handling
op
erators
with
a
dynamic
n
um
b
er
of
auxiliary
p
orts
in
tro
duces
a
computational
o
v
erhead

.
R
e
duction

n
i
m
j
n
*
m
k
*
m
j
i
i+k
j
i
*
n
m
j
k
*
m
i+k
i+j
m
i+j
*
m
*
m
n
k
i
j
j
i+k
Fig.
..
Merging
rules
|
Pro
viso:
m

n

m
+
i,
and
lo
w
er
op
erator
safe.
that
v
ery
often
is
not
comp
ensated
b
y
the
dimin
ution
of
the
n
um
b
er
of
in
teractions.
Since
moreo
v
er
the
co
de
gets
m
uc
h
more
con
triv
ed,
w
e
prefered
to
w
ork
with
xed-arit
y
op
erators.
Ha
ving
explained
the
kind
of
con
trol
op
erators
used
in
bohm,
w
e
ma
y
no
w
giv
e
the
initial
translation
of
input
terms
in
to
their
graphical
represen
tation.
As
usual,
an
y
term
N
with
n
free
v
ariables
will
b
e
represen
ted
b
y
a
graph
with
n
+

en
tries
(free
edges):
n
for
the
free
v
ariables
(the
inputs),
and
one
for
the
\ro
ot"
of
the
term
(the
output).
The
translation
starts
at
lev
el
0
(see
Figure
.).
F
or
the
sak
e
of
clarit
y
and
for
implemen
tation
reasons,
w
e
add
an
explicit
r
o
ot
no
de
at
the
top
of
the
term.
Moreo
v
er,
w
e
are
implicitly
assuming
that
all
input
terms
are
closed.
= 
[M]
[M]0
Root
0
Fig.
..
Starting
translation
rule.
Remark
..
Actually
,
there
is
a
global
construct
def
for
building


The
Bolo
gna
Optimal
Higher-or
der
Machine
up
a
global
en
vironmen
t
in
whic
h
names
are
asso
ciated
to
expressions
(see
section
...).
According
to
this,
\closed"
means
that
an
y
free
v
ariable
in
an
ev
aluating
term
m
ust
corresp
ond
to
the
name
of
some
previous
dened
expression.
The
general
translation
rules
are
describ
ed
in
Figure
.
(only
some
t
ypical
examples
are
depicted).
They
are
a
mere
sp
ecialization
of
the
general
translation
metho
d
for
In
teraction
Systems
to
our
particular
source
language
(and
to
our
c
hoice
of
con
trol
op
erators).
Ho
w
ev
er,
the
translation
has
b
een
optimized
in
sev
eral
places
to
tak
e
adv
an
tage
of
the
line
ar
b
eha
vior
of
most
part
of
in
teraction
rules.
The
only
term
that
deserv
es
a
sp
ecial
commen
t
is
the
x-p
oin
t
op
era-
tor
rec
x
=
M.
According
to
the
usual
translation
of
In
teraction
System,
it
should
corresp
ond
to
the
graph
in
Figure
.(a).
Ho
w
ev
er,
w
e
can
just
get
rid
of
the
explicit

no
de,
adopting
the
simpler
translation
in
Figure
.(b).
The
latter
enco
ding
has
b
een
suggested
b
y
Juliusz
Chrob
o
czek;
in
this
w
a
y
,
reduction
is
t
wice
faster
on
highly
recursiv
e
terms.
W
e
lea
v
e
as
an
exercise
to
the
reader
to
mak
e
sense
of
this
translation.
Let
us
just
remark
that
it
also
mo
dies
the
notion
of
family
of
redexes
(and
th
us
of
optimali
t
y).
Let
us
consider
for
instance
the
follo
wing
denition
of
the
factorial
function:
rec
fact
=
\n.if
n
==
0
then

else
(fact
(n-));;
With
the
rst
enco
ding,
the
computation
of
(fact
n)
requires
n
-
reductions.
With
Chrob
o
czek's
enco
ding,
just
one
()
-reduction
is
p
erformed.
The
reason
is
that
with
the
former
enco
ding
eac
h
recursiv
e
application
of
fact
to
its
argumen
t
is
considered
as
a
reducible
expression
that
is
cr
e
ate
d
b
y
ring
the
x-p
oin
t
rule
(so,
they
cannot
b
e
shared).
In
the
second
case,
the
x-p
oin
t
op
erator
is
\transparen
t";
there
is
no
explicit
rule
for
,
so
no
new
redex
can
b
e
created
b
y
its
\application".
...
Implementation
Issues
The
graph
created
b
y
the
previous
rules
is
not
orien
ted
(y
ou
should
not
confuse
the
arro
w
denoting
the
principal
p
ort
of
a
form
with
an
orien
ted
edge).
F
or
this
reason,
and
in
order
to
facilitate
graph
rewriting,
all
edges
will
b
e
represen
ted
b
y
a
double
connection
b
et
w
een
no
des.
In
particular,
for
eac
h
p
ort
of
a
syn
tactical
form
F
w
e
m
ust
kno
w
the
other

.
R
e
duction
	
[M]n
λ
. . .
= 
λ
[   x.M]n
n
[x]n = 
n
-1
= 
n
[false]
F
Intm
= 
n
[m]
= 
n
[nil]
NIL
[MN]n = 
[M]n
[N]n+1
@ n
0
0
*
n
. . .
. . .
n
n
1
1
[true]n
0
0
*
n
CONS
n
0
0
*
n
0
0
*
n
n = 
. . .
. . .
n
[N]
[M]n
[B]n
0
0
*
n
. . .
n
 ITE
[M]n
. . .
n
CAR
[car(M)]n = 
n
n
n
n
= 
T
. . .
. . .
n = 
[M]n
n
[N]
n
ADD
[M+N]
. . .
. . .
n = 
n
[N]
[M]n
[cons(M,N)]
[if B then M else N]
Fig.
..
Initial
translation.

0
The
Bolo
gna
Optimal
Higher-or
der
Machine
µ
[M]n+1
n
1
= 
n
[rec x = M]
[M]n+1
n
1
n
[rec x = M] = 
. . .
n
. . .
*
n
1
(a)
(b)
-1
Fig.
..
Recursion.
form
F
0
whic
h
is
connected
to
it
at
that
p
ort,
and
also
to
whic
h
p
ort
of
F
0
it
is
connected
to.
Ob
viously
,
eac
h
form
has
also
a
name
(F
AN,
APP
,
ADD,
.
.
.
),
and
an
index.
The
t
ypical
represen
tation
of
a
ternary
form
ma
y
b
e
th
us
describ
ed
b
y
the
follo
wing
struct
in
C.
typedef
struct
form
{
int
name,
/*
name
of
the
form
*/
/*
(FAN,
APP,
ADD,
*/
/*
SUB,
EQ,
...)
*/
index;
/*
index
of
the
form
*/
int
nport[];
/*
numbers
of
the
ports
of
adjacent
*/
/*
forms
where
the
three
ports
*/
/*
of
this
form
are
connected
to
*/
struct
form
*nform[];
/*
pointers
to
the
forms
*/
/*
where
the
three
ports
*/
/*
of
this
form
are
connected
to
*/
}
FORM;
Giv
en
a
p
oin
ter
f
to
a
form,
the
eld
f->nform[i]
will
denote
the
next
form
g
connected
with
f
at
p
ort
i.
Similarly
,
f->nport[i]
sa
ys
to

.
R
e
duction

whic
h
p
ort
of
g
the
form
f
is
connected.
In
particular,
w
e
alw
a
ys
ha
v
e
that
(f->nform[i])->nfo
rm[f-
>npor
t[i]]
==
f.
Remark
..
By
con
v
en
tion,
the
principal
p
ort
of
a
form
has
alw
a
ys
n
um
b
er
0.
Ob
viously
,
dieren
t
sets
of
no
des
require
their
o
wn
sp
ecic
informa-
tions.
F
or
instance,
some
arithmetical
no
des
need
a
n
umerical
v
alue;
con
trol
no
des
need
a
\safeness"
tag
and
\w
eigh
ts"
for
the
auxiliary
p
orts;
and
so
on.
Actually
,
the
large
dimension
of
F
ORMS
is
the
main
imple-
men
tation
problem
of
bohm.
A
t
the
same
time,
let
us
note
that
all
unary
constructors
(in
tegers,
true,
false,
and
nil)
do
not
require
an
ex-
plicit
form.
In
particular,
their
v
alue
can
b
e
directly
stored
in
the
form
to
whic
h
they
are
connected,
instead
of
a
p
oin
ter
to
them.
Ev
en
if
the
double
connection
b
et
w
een
F
ORMS
in
tro
duces
some
re-
dundancy
,
it
allo
ws
to
na
vigate
the
graph
in
a
v
ery
easy
w
a
y
.
Indeed,
w
e
should
a
v
oid
a
systematic
use
of
bi-links,
restricting
them
to
partic-
ular
edges
of
the
graphs
(t
ypically
,
those
represen
ting
cut
or
axioms).
Although
this
solution
could
reasonably
sa
v
e
some
space
and
could
also
impro
v
e
p
erformances,
it
lo
oks
more
in
v
olv
ed
to
implemen
t;
th
us,
w
e
nally
rejected
it
in
designing
the
protot
yp
e.
As
a
simple
example,
let
us
see
the
function
that
connects
together
t
w
o
forms
at
t
w
o
sp
ecied
p
orts
(this
is
the
most
frequen
tly
used
function
of
bohm;
eac
h
atomic
in
teraction
calls
connect
-
times,
in
a
v
erage.
/*
the
following
function
connects
together
the
port
*/
/*
portf
of
form
to
the
port
portf
of
form
*/
connect(form,portf
,fo
rm,p
ortf
)
FORM
*form;
int
portf;
FORM
*form;
int
portf;
{
form->nport[por
tf]
=
portf;
form->nform[por
tf]
=
form;
form->nport[por
tf]
=
portf;
form->nform[por
tf]
=
form;
}


The
Bolo
gna
Optimal
Higher-or
der
Machine
...
Glob
al
Denitions
The
syn
tactical
construct:
def
hiden
tieri
=
hexpri
allo
ws
the
user
to
declare
an
expression
as
a
global
denition,
binding
it
with
an
iden
tier
name.
F
rom
the
p
oin
t
of
view
of
reduction,
there
are
t
w
o
p
ossible
w
a
ys
for
handling
global
denitions:
sharing
and
c
opying.
The
rst
v
ersion
of
bohm,
w
as
based
on
a
sharing
approac
h.
In
par-
ticular,
ev
ery
time
w
e
had
a
new
declaration
of
a
term,
the
graph
corre-
sp
onding
to
the
term
w
as
built
up
and
closed
with
a
ROOT
form
p
oin
ted
to
b
y
the
iden
tier
in
the
sym
b
ol
table.
Then,
using
a
previously
de-
ned
global
expression,
w
e
simply
attac
hed
a
F
AN
at
the
top
of
the
corresp
onding
graph,
implicitl
y
creating
a
new
instance
of
the
expres-
sion.
In
this
w
a
y
,
the
global
denition
w
as
shared
b
y
all
its
instances.
Note
that
this
also
implied
a
minor
c
hange
in
the
translation
of
terms.
In
fact,
since
a
global
expression
is
a
sharable
data,
its
graph
m
ust
b
e
created
starting
at
lev
el
,
and
not
0
as
for
usual
expressions.
The
previous
handling
of
global
denitions
w
as
ho
w
ev
er
resp
onsible
for
an
o
dd
op
erational
b
eha
vior:
the
second
time
w
e
ev
aluated
an
expression
con
taining
global
iden
tiers,
the
reduction
time
could
b
e
m
uc
h
smaller
than
the
rst
time.
The
reason
is
that
the
second
call
to
ok
adv
an
tage
of
all
partial
ev
aluations
that
the
rst
call
p
erformed
on
global
expressions.
T
o
share
global
expressions
allo
w
ed
th
us
to
prot
of
the
shared
partial
ev
aluation
of
global
terms,
exploiting
sharing
in
great
extend
in
accord
to
the
philosoph
y
of
optimal
reduction.
Ho
w
ev
er,
in
man
y
cases,
it
also
in
tro
duced
a
substan
tial
trade
o
from
the
p
oin
t
of
view
of
memory
al-
lo
cation.
In
fact,
the
partially
ev
aluated
global
expression
migh
t
usually
need
much
mor
e
sp
ac
e
than
the
original
term.
F
or
this
reason,
the
new
v
ersions
of
bohm
adopt
instead
a
cop
y
tec
hnique:
ev
ery
time
w
e
use
a
global
name,
a
new
lo
cal
instance
of
the
corresp
onding
graph
is
created.
..
Gr
aph
R
e
duction
Once
the
graph
represen
ting
an
expression
has
b
een
built,
the
reduction
pro
ceeds
according
to
the
graph
rewriting
rules
in
the
next
pictures.
The
rules
in
Figure
.
and
Figure
.
are
the
instan
tiation
of
the
general
paradigm
for
In
teraction
Systems
to
our
case.
Their
reading
is
completely
straigh
tforw
ard.

.
R
e
duction

m
INTl
ADD1
n
m
a
INTl+n
m
a
ADD
m
INTn
m
a
b
ADD1
n
m
a
b
m
F
m
F
m
AND
a
b
a
T
m
AND
m
a
b
a
b
m
m
T
OR
b
m
T
a
a
a
b
m
m
F
OR
a
b
m
NOT
m
F
a
m
T
a
m
F
a
m
T
m
m
T
a
m
F
a
NOT
INT
m
m
b
m
n
b
a
a
EQ
EQ1
a
a
m
INT
m
n
l
EQ1
a
m
INT
m
n
n
EQ1
n
Fig.
..
bohm's
in
teraction
rules:
logical
rules
I


The
Bolo
gna
Optimal
Higher-or
der
Machine
TESTNIL m
m
CONS
m
F
a
b
c
a
NIL
TESTNIL m
m
m
T
a
a
NIL
NIL
m
m
CDR
m
a
a
CONS
m
m
CDR
a
b
c
a
c
a
b
CAR
CONS
m
m
a
b
c
T
F
m
m
a
b
c
a
c
ITE
m
m
a
b
c
a
b
ITE
Fig.
..
bohm's
in
teraction
rules:
logical
rules
I
I
The
rules
in
Figure
.	
co
v
er
instead
the
in
teractions
b
et
w
een
con
trol
op
erators
(triangle
and
fans)
and
prop
er
no
des;
they
are
the
ob
vious
generalization
of
the
usual
ones.
W
e
omit
to
dra
w
the
usual
annihilation
rules.
*
n
i
j
f
n
i
n
i
f
m
f
m
n
i
m+i
*
n
i
j
f
f
*
n
i
j
m+i
m+j
n < m
...
...
...
...
...
...
Fig.
.	.
bohm's
in
teraction
rules:
triangle
and
fan

.
R
e
duction

...
Implementation
Issues
bohm
is
lazy.
It
do
es
not
p
erform
the
full
reduction
of
a
term,
it
rather
stops
when
the
topmost
op
erator
in
the
graph
b
ecomes
a
constructor.
This
halting
situation
is
easily
recognized,
since
it
means
that
the
ro
ot
of
the
term
b
ecomes
dir
e
ctly
connected
to
some
op
erator
f
at
its
princip
al
p
ort
(i.e.,
b
y
con
v
en
tion,
the
p
ort
with
n
um
b
er
0).
In
this
case,
the
name
of
f
is
the
result
of
the
computation.
Reduction
pro
ceeds
according
to
the
follo
wing
idea.
W
e
start
lo
oking
for
the
leftmost
outermost
redex.
In
particular,
starting
from
the
ro
ot
of
the
term,
w
e
tra
v
erse
an
y
op
erator
that
w
e
reac
h
at
an
auxiliary
p
ort
always
exiting
fr
om
its
princip
al
p
ort,
un
til
w
e
ev
en
tually
reac
h
an
op
erator
f
at
its
principal
p
ort.
No
w
t
w
o
cases
are
p
ossible:
either
the
previous
op
erator
w
as
the
ro
ot
no
de
(and
this
is
the
halting
case),
or
w
e
ha
v
e
found
a
redex
(for
the
last
t
w
o
op
erators
are
connected
at
their
principal
p
orts).
In
this
case,
the
redex
is
red
b
y
applying
the
asso
ciated
graph
reduction
rule,
and
w
e
start
the
pro
cess
again.
In
order
to
a
v
oid
to
rescan
the
term
from
the
ro
ot
ev
ery
time,
it
is
con
v
enien
t
to
push
all
op
erators
leading
to
the
rst
redex
on
a
stac
k
(similar
to
the
stac
k
of
the
G-mac
hine).
After
ring
a
redex
it
is
enough
to
p
op
the
last
elemen
t
from
this
stac
k,
and
start
searc
hing
for
the
next
redex
from
this
no
de.
The
follo
wing
piece
of
co
de
is
the
main
lo
op
of
the
reduction
mac
hine:
reduce_term(root
)
FORM
*root;
{
FORM
*f,
*f,
*erase;
int
type_error;
type_error
=
FALSE;
f
=
lo_redex(root);
f
=
f->nform[0];
while
((f
!=
root)
&&
(!type_error))
{
if
(f->index
<=
f->index)
reduce_redex(f
,f);
else
reduce_redex(f
,f);


The
Bolo
gna
Optimal
Higher-or
der
Machine
f
=
lo_redex(pop());
f
=
f->nform[0];
}
if(!type_error)
rdbk(root);
}
where
lo_redex
is
dened
as
follo
ws:
FORM
*lo_redex(f)
FORM
*f;
{
FORM
*temp;
temp
=
f;
while
(temp->nport[0]
!=
0)
{
push(temp);
temp
=
temp->nform[0];
}
return
temp;
}
reduce_redex(f,f)
is
just
a
big
switc
h
based
on
the
name
of
f
and
f
(and
their
index).
F
or
example,
here
is
the
piece
of
co
de
in
the
case
the
t
w
o
forms
ha
v
e
the
same
index
and
the
rst
form
f
is
AND
:
case
AND:
switch(f->name)
{
case
F:
connect(f->nfor
m[],
f->nport[],
f,
0);
myfree(f);
break;
case
T:
connect(f->nfor
m[],
f->nport[],
f->nform[],
f->nport[]);

.
Garb
age
Col
le
ction

myfree(f);
myfree(f);
break;
default:
printf("--->
type
error\n");
type_error
=
TRUE;
break;
}
.
Garbage
Collection
In
pure
-calculus,
the
creation
of
garbage
is
related
to
the
presence
of
abstraction
no
des
whose
b
ound
v
ariable
do
es
not
app
ear
in
the
b
o
dy
.
As
w
e
ha
v
e
already
seen,
suc
h
situations
ma
y
b
e
represen
ted
b
y
in
tro
ducing
a
suitable
garb
age
no
de
connected
to
the
b
ound
p
ort
of
the
-no
de.
F
or
instance,
consider
the
term
(x:N)M,
where
x
do
es
not
app
ear
in
N
(see
Figure
.0).
After
the
-reduction,
the
term
M
app
ears
disconnected
from
the
main
graph,
b
ecoming
garbage.
M
@ n
n
λ
N
M
N
Fig.
.0.
Creation
of
garbage
Unfortunately
,
things
are
usually
more
complex.
In
fact,
M
migh
t
share
some
subterms
with
the
main
graph.
Therefore,
these
subterms
cannot
b
e
regarded
as
garbage.
Moreo
v
er,
the
whole
term
M
w
ould
remain
connected
to
the
main
graph
through
that
shared
subterms.
As
far
as
w
e
consider
pure
lam
b
da
calculus,
garbage
collection
is
not
really
imp
elling;
on
the
con
trary
,
it
b
ecomes
of
dramatical
imp
ortance
in
the
enric
hed
language
of
bohm.
As
a
matter
of
fact,
a
lot
of
bohm's
rewriting
rules
create
garbage.
A
t
ypical
case
is
the
conditional
expres-
sion
if
B
then
M
else
N.
If
B
is
true
(false),
the
subterm
N
(resp
ectiv
ely


The
Bolo
gna
Optimal
Higher-or
der
Machine
M)
is
garbage.
Analogously
,
the
ev
aluation
of
the
b
o
olean
expression
false
and
B
immediately
reduces
to
false,
and
B
b
ecomes
garbage.
Other
imp
ortan
t
cases
concern
lists;
for
instance,
after
an
application
of
the
op
erator
CAR
,
whic
h
selects
the
rst
elemen
t
of
a
list,
the
tail
of
the
list
can
b
e
discarded.
In
the
con
text
of
optimal
reduction,
it
lo
oks
dicult
to
implem
en
t
an
ecien
t
garbage
collection
pro
cedure
using
traditional
mark
and
swe
ep
algorithms.
Indeed:
(i)
Marking
the
activ
e
elemen
ts
w
ould
require
a
complex
visit
of
the
graph,
based
on
the
so
called
con
text
seman
tics,
and
the
complexit
y
of
suc
h
a
visit
could
b
e
exp
onen
tial
in
the
size
of
the
graph.
(ii)
W
e
could
limit
collection
of
garbage
to
ph
ysically
disconnected
subgraph.
Ho
w
ev
er,
particularly
with
bohm's
lazy
strategy
,
garbage
collection
w
ould
b
e
dela
y
ed
v
ery
farther
in
the
reduction
of
the
term,
causing
a
p
ossible
explosion
of
garbage.
The
second
p
oin
t
ab
o
v
e
should
probably
deserv
e
some
more
w
ords.
Consider
for
instance
the
case
of
a
shared
list
(a
fan
o
v
er
a
cons).
Sup-
p
ose
moreo
v
er
that
one
branc
h
of
the
fan
has
b
ecome
garbage
(i.e.,
w
e
ha
v
e
a
garbage
op
erator
at
one
auxiliary
p
ort
of
the
fan).
This
situation
o
ccurs
v
ery
often
with
bohm's
rules.
Ob
viously
,
w
e
w
ould
lik
e
to
elim-
inate
the
fan
and
the
garbage
op
erator,
attac
hing
the
list
to
the
only
activ
e
branc
h
of
the
fan.
Ho
w
ev
er,
adopting
the
p
olicy
in
the
second
p
oin
t
ab
o
v
e,
w
e
could
not
collect
an
y
garbage
un
til
w
e
nished
dupli-
cating
the
whole
list.
On
the
con
trary
,
in
optimal
reduction,
garbage
should
alw
a
ys
b
e
collected
as
so
on
as
p
ossible.
As
p
oin
ted
out
b
y
Lamping,
an
ecien
t
w
a
y
to
in
tegrate
a
garbage
collector
in
the
optimal
graph
reduction
tec
hnique
is
based
on
lo
cal
in
ter-
actions
of
erase
op
erators
(
).
The
basic
idea
is
that
the
erase
op
erators
are
propagated
along
the
graph,
collecting
ev
ery
no
de
encoun
tered
along
their
w
alk.
In
bohm,
all
erase
op
erators
are
main
tained
in
an
appropriate
data
structure
(a
list).
When
garbage
collection
is
activ
ated
eac
h
of
them
in
teracts
with
the
forms
it
can
erase,
adding
new
erase
op
erators
to
the
list.
The
pro
cess
ends
when
no
in
teraction
for
an
y
eraser
in
the
list
is
p
ossible.
The
k
ey
p
oin
t
is
that
there
are
situations
in
whic
h
no
erasing
in
ter-
action
is
allo
w
ed;
t
ypically
,
when
an
erase
op
erator
reac
hes
the
binding

.
Garb
age
Col
le
ction
	
p
ort
of
an
abstraction,
or
an
auxiliary
p
ort
of
an
unsafe
fan.
This
latter
case
is
particularly
imp
ortan
t;
therefore
let
us
analyze
it
in
full
details.
*
n
a
b
a
b
Fig.
..
Naiv
e
garbage
collection
of
a
fan
When
a
garbage
op
erator
reac
hes
a
fan
at
an
auxiliary
p
ort,
one
w
ould
b
e
tempted
to
apply
the
rule
in
Figure
..
Indeed,
one
of
the
t
w
o
branc
hes
of
the
information
shared
b
y
the
fan
has
b
ecome
garbage,
and
the
ob
vious
solution
w
ould
seem
to
simply
drop
this
branc
h.
Ho
w
ev
er,
this
rule
is
not
correct
in
general,
due
the
problem
describ
ed
in
Fig-
ure
..
That
is,
if
w
e
allo
w
a
fan-in(-out)
to
in
teract
with
an
erase
op
erator
according
to
the
rule
in
Figure
.,
w
e
could
preclude
to
some
\paired"
fan-out(-in)
the
p
ossibilit
y
to
annihilate
with
the
erased
fan.
*
*
*
n
n
n
yes
no
Fig.
..
Critical
pair
created
b
y
the
rule
in
Figure
.
Luc
kily
,
as
w
e
already
kno
w,
the
rule
is
p
erfectly
correct
for
safe
fan
(for
the
trivial
reason
that
no
\paired"
fan-out
could
p
ossibly
exist,
in
this
case).
Another
in
teresting
p
oin
t
is
the
c
hoice
of
an
appropriate
strategy
for
activ
ating
the
garbage
collection
pro
cedure.
Our
empirical
studies
seem
to
suggest
that
the
b
est
strategy
is
to
call
the
garbage
collector
ev
ery
time
some
reduction
rule
generates
new
garbage,
i.e.,
as
so
on
as
the

0
The
Bolo
gna
Optimal
Higher-or
der
Machine
garbage
is
created.
Op
erating
in
this
w
a
y
,
w
e
obtain
t
w
o
imp
ortan
t
adv
an
tages:

the
size
of
the
graph
is
alw
a
ys
k
ept
to
a
minim
um
along
the
reduction;

collecting
garbage
as
so
on
as
p
ossible
prev
en
ts
that
it
b
ecomes
in-
v
olv
ed
in
useless
in
teractions,
resulting
in
a
sensible
impro
v
emen
t
in
p
erformance.
Figure
.
con
tains
the
whole
set
of
garbage
rules
for
pure
lam
b
da
calculus.
These
rules
generalize
in
the
ob
vious
w
a
y
to
the
other
forms
of
the
syn
tax.
In
particular,
a
garbage
op
erator
can
eace
an
y
syn
tactical
form,
no
matter
at
whic
h
p
ort
it
reac
hes
the
form,
unless
it
is
a
b
ound
p
ort.
In
this
case
it
stops
there.
After
collecting
the
form,
w
e
broadcast
the
garbage
op
erator
to
all
other
p
orts
of
it,
starting
the
pro
cess
again.
Remark
..
The
erase
no
de
has
no
index.
Moreo
v
er,
its
in
terac-
tions
are
indep
enden
t
from
the
index
of
the
adjacen
t
no
de.
W
e
stress
that
the
last
t
w
o
rules
for
fans
ma
y
b
e
only
applied
in
the
case
in
whic
h
the
fan
is
safe,
otherwise
no
in
teraction
is
allo
w
ed,
and
the
erase
op
erator
is
stopp
ed.
Moreo
v
er,
let
us
note,
that
these
rules
ma
y
create
triangles
with
w
eigh
t
0.
No
w,
since
a
triangle
of
suc
h
a
kind
neither
mo
dify
the
indexes
of
the
no
des
it
crosses,
nor
has
an
y
sharing
eect,
it
can
b
e
alw
a
ys
erased
from
the
graph
without
an
y
consequence
on
the
result
of
the
reduction.
Ho
w
ev
er,
y
ou
m
ust
tak
e
in
to
accoun
t
the
p
ossibilit
y
that
the
original
fan
(and
th
us
the
triangle)
w
as
in
the
\leftmost-outermost-redex"
stack.
If
this
is
the
case,
to
erase
the
triangle
from
the
graph
w
e
should
consisten
tly
remo
v
e
it
from
the
stac
k
to
o,
that
is
ho
w
ev
er
a
complex
op
eration.
The
simplest
solution
is
to
lo
ok
for
triangles
with
w
eigh
t
zero
when
w
e
p
op
elemen
ts
from
the
stac
k,
erasing
them
at
that
momen
t.
As
an
example
of
the
subtlet
y
of
this
problem,
w
e
o
v
erlo
ok
ed
it
in
our
rst
implemen
tatio
n
and,
b
eliev
e
it,
the
bug
w
as
r
e
al
ly
dicult
to
nd.
Although
the
previous
garbage
collection
pro
cedure
w
orks
prett
y
w
ell
in
practice,
it
gets
in
troubles
with
particularly
lo
oping
situations.
F
or
instance,
the
whole
graph
in
Figure
.
is
garbage,
but
no
garbage
collection
rule
ma
y
b
e
applied
to
erase
it.
F
or
this
reason,
bohm
p
erio
dically
lo
oks
for
completely
disconnected
subgraphs
(t
ypically
,
this
op
eration
is
p
erformed
immediately
b
efore
the
reduction
of
a
new
input
term).
T
o
conclude
this
in
tro
duction
to
garbage
collection,
w
e
w
an
t
to
stress

.
Garb
age
Col
le
ction

@ n
b
b
a
a
b
@ n
a
b
a
b
a
@ n
a
b
b
a
n
λ
a
b
n
λ
a
b
a
b
                    



n
i
a
a
                        



n
i
a
a
*
n
i
j
a
b
a
b
                    


safe
*
n
i
j
b
a
n
a
b
j
                    



*
n
i
j
b
n
a
b
a
i
safe
Fig.
..
Garbage
collection
rules
that
the
theoretical
and
practical
asp
ects
of
garbage
collection
in
opti-


The
Bolo
gna
Optimal
Higher-or
der
Machine
*
@
*
1
0
-1
-1
-1
-1
0
Fig.
..
Garbage
that
cannot
b
e
easily
collected
mal
reduction
are
still
among
the
most
relev
an
t
op
en
problems
of
this
discipline,
and
surely
deserv
es
further
in
v
estigation.
..
Implementation
Issues
T
o
impro
v
e
the
eciency
of
the
garbage
collection
pro
cedure,
three
new
no
des
ha
v
e
b
een
in
tro
duced.
They
do
not
represen
t
neither
new
syn-
tactical
elemen
ts,
nor
new
con
trol
op
erators;
these
new
forms
are
just
a
sort
of
abbreviation
for
particular
congurations
of
other
forms.
In
particular
(see
also
Figure
.):

UNS
F
AN
represen
ts
a
conguration
where
an
erase
op
erator
is
\blo
c
k
ed"
on
the
\rst"
auxiliary
p
ort
of
an
unsafe
fan.

UNS
F
AN
is
similar
to
the
previous
one,
but
relativ
e
to
the
\second"
auxiliary
p
ort.

-unb
represen
ts
an
abstraction
no
de
connected
at
its
b
ound
p
ort
with
an
erase
op
erator.
n
λ
n
-unb
λ
*
n
i
j
j
n
unsafe
fan_1
*
n
i
j
unsafe
fan_2
i
n
=
=
=
Fig.
..
Some
new
forms
incorp
orating
the
erase
op
erator
The
in
tro
duction
of
these
new
forms
has
t
w
o
imp
ortan
t
adv
an
tages:
(i)
All
erase
no
des
whic
h
cannot
b
e
propagated
an
y
further
are
merged
in
to
their
adjacen
t
no
des.
Therefore,
it
is
easy
to
recognize
when
garbage
collection
is
p
ossible:
an
erase
op
erator
is
ph
ysically
presen
t
in
the
graph
if
and
only
if
it
is
\activ
e".

.
Garb
age
Col
le
ction

(ii)
The
forms
UNS
F
AN
and
UNS
F
AN
prev
en
t
man
y
useless
du-
plications
and
garbage
collection
calls
during
reduction.
In
accord
with
the
idea
that
bohm
is
a
sort
of
testb
ed.
The
user
can
select
among
three
garbage
collection
strategies
and
compare
the
corresp
onding
p
erformances.
The
p
ossibilities
are:
)
Maxim
um
garbage
collection.
The
garbage
collector
is
activ
ated
as
so
on
as
new
garbage
is
created.
)
Garbage
collection
dep
ending
on
memory
o
ccupation.
In
this
case,
garbage
collection
is
attempted
as
so
on
as
the
total
n
um
b
er
of
allo-
cated
no
des
reac
hes
a
certain
b
ound
c
hosen
b
y
the
user.
)
No
garbage
collection.
The
user
can
select
one
of
the
previous
c
hoice
at
start
time,
calling
the
program
with
the
option
-s,
or
at
a
man
y
momen
t
during
the
session,
in
v
oking
a
suitable
men
u
via
the
directiv
e
#option.
..
Examples
and
Benchmarks
In
this
section,
w
e
giv
e
a
few
t
ypical
b
enc
hmarks
ab
out
garbage
collec-
tion.
W
e
start
with
some
examples
in
pure
-calculus.
In
particular,
w
e
consider
t
w
o
\primitiv
e
recursiv
e"
v
ersions
of
the
factorial
and
b
onacci
functions
on
Ch
urc
h
in
tegers.
Since
the
computation
stops
at
w
eak
head
normal
form,
w
e
shall
supply
some
extra-parameters
(iden
tities),
in
order
to
get
an
in
teresting
computation.
Here
is
the
source
co
de
(these
denitions
can
b
e
also
found
in
the
le
examples/purelamb
da
in
bohm's
main
directory):
def
I
=
\x.x;;
def
zero
=
\x.\y.y;;
def
one
=
\x.\y.(x
y);;
def
two
=
\x.\y.(x
(x
y));;
...
def
Pair
=
\x.\y.\z.(z
x
y);;
def
Fst
=
\x.\y.x;;
def
Snd
=
\x.\y.y;;
def
Succ
=
\n.\x.\y.(x
(n
x
y));;
def
Add
=
\n.\m.\x.\y.(n
x
(m
x
y));;
def
Mult
=
\n.\m.\x.(n
(m
x));;


The
Bolo
gna
Optimal
Higher-or
der
Machine
def
Next
=
\p.let
n
=
(p
Fst)
in
let
n
=
(Succ
(p
Snd))
in
(Pair
(Mult
n
n)
n);;
def
Nextfibo
=
\p.let
n
=
(p
Fst)
in
let
n
=
(p
Snd)
in
(Pair
(Add
n
n)
n);
def
Factprim
=
\n.(n
Next
(Pair
one
zero)
Fst);;
def
Fiboprim
=
\n.(n
Nextfibo
(Pair
zero
one)
Fst);;
The
previous
co
de
cause
the
initial
allo
cation
of
00
no
des
whic
h
ob
viously
cannot
b
e
erased
b
y
an
y
computation.
In
Figure
.
w
e
sho
w
the
maxim
um
n
um
b
er
of
no
des
allo
cated
during
the
reduction
of
suitable
applications
of
Factprim
and
Fiboprim,
with
and
without
garbage
collection.
G.C.
o
G.C.
on
(Factpri
m
one
I
I)


(Factpri
m
two
I
I)

	
(Factpri
m
three
I
I)
0

(Factpri
m
five
I
I)


(Factpri
m
ten
I
I)

	
(Factpri
m
(add
ten
five)
I
I)
00	

(Factpri
m
(add
ten
ten)
I
I)


(Fibopri
m
one
I
I)
0
0	
(Fibopri
m
two
I
I)


(Fibopri
m
three
I
I)
	

(Fibopri
m
five
I
I)


(Fibopri
m
ten
I
I)
	

(Fibopri
m
(add
ten
five)
I
I)
	

(Fibopri
m
(add
ten
ten)
I
I)
00
	
Fig.
..
Maxim
um
allo
cation
space
(n
um
b
er
of
no
des).
The
table
in
Figure
.
sho
ws
instead,
for
the
same
terms,
the

.
Garb
age
Col
le
ction

dimension
of
the
graph
at
the
end
of
the
reduction,
and
the
total
n
um
b
er
of
garbage
in
teractions
p
erformed
b
y
the
garbage
collector.
G.C
o
G.C.
on
Garbage
Op.
(Factprim
one
I
I)


0
(Factprim
two
I
I)

0	

(Factprim
three
I
I)
		
0

(Factprim
five
I
I)

0
00
(Factprim
ten
I
I)

0

(Factprim
(add
ten
five)
I
I)
	
0	

(Factprim
(add
ten
ten)
I
I)



(Fiboprim
one
I
I)



(Fiboprim
two
I
I)

0

(Fiboprim
three
I
I)

0

(Fiboprim
five
I
I)
0
0

(Fiboprim
ten
I
I)

0

(Fiboprim
(add
ten
five)
I
I)
	
0	

(Fiboprim
(add
ten
ten)
I
I)
	
0

Fig.
..
Final
allo
cation
space.
The
p
erformance
of
the
garbage
collection
pro
cedure
is,
in
some
cases,
surprisingly
go
o
d.
Consider
for
example
the
case
of
the
-term
(Factprim
(add
ten
ten)
I
I);
if
the
garbage
collector
is
activ
e,
the
remaining
no
des
after
the
reduction
are
only
,
against
a
nal
allo
cation
of
o
v
er
0000
no
des
when
no
garbage
collection
is
p
erformed.
Moreo
v
er,
and
this
is
particularly
in
teresting,
this
result
is
obtained
b
y
executing
only

garbage
collecting
op
erations!
The
reason
is
that
garbage
c
an
b
e
duplic
ate
d
along
the
r
e
duction.
Let
us
no
w
consider
an
example
in
v
olving
some
syn
tactical
constructs
of
the
extended
source
language.
In
particular,
let
us
tak
e
a
quic
ksort
algorithm
for
lists
of
in
tegers.
Next
there
is
the
corresp
onding
bohm
co
de.
The
function
genlist
tak
es
an
in
teger
n
and
returns
the
list
of
the
rst
n
in
tegers
in
in
v
erse
order,
and
will
b
e
used
to
generate
the
inputs
to
the
function
quicksort.
{length
of
a
list}
def
length
=
rec
l
=
\x.if
isnil(x)
then
0


The
Bolo
gna
Optimal
Higher-or
der
Machine
else

+
(l
tail(x));;
{(listIt
f
l
e)
iterates
f
on
the
elements
of
list
l}
def
listIt
=
rec
lIt
=
\f.\l.\e.if
isnil(l)
then
e
else
(f
head(l)
(lIt
f
tail(l)
e));;
{split
a
list
in
two
sublists
according
the
property
t}
def
partition
=
\t.\l.let
switch
=
\e.\l.if
(t
e)
then
[head(l),cons(e,h
ead(t
ail(
l)))
]
else
[cons(e,head(l)),
head(
tail
(l))
]
in
(listIt
switch
l
[nil,nil]);;
{appends
two
lists}
def
append
=
rec
a
=
\l.\l.if
isnil(l)
then
l
else
cons(head(l),(a
tail(l)
l));;
{generates
the
list
of
the
first
n
integers}
def
genlist
=
rec
gen
=
\n.if
n
==
0
then
nil
else
cons(n,(gen
n-));;
{returns
the
sorted
list}
def
quicksort
=
rec
qs
=
\l.if
isnil(l)
then
nil
else
if
(length
l)
==

then
l
else
let
l
=
head((partition
\x.head(l)
<=
x
tail(l)))
in
let
l
=
head(tail((part
ition
\y.head(l)
<
y
tail(l))))
in
(append
(qs
l)
cons(head(l),(qs
l)));;
The
function
quicksort
has
b
een
tested
on
lists
of
sev
eral
length.
The
results
are
summarized
in
the
tables
in
Figure
.
and
Figure
.	.
In
particular,
in
Figure
.
w
e
compare
the
maxim
um
dimension
of
the
graph
and
the
n
um
b
er
of
garbage
collecting
in
teractions
p
erformed
along
the
reduction.

.
Pr
oblems

G.C.
o
G.C.
on
Garbage
Op.
(quicksor
t
(genlist
))
0	

	
(quicksor
t
(genlist
0))
	

	
(quicksor
t
(genlist
))
0


(quicksor
t
(genlist
0))
	


(quicksor
t
(genlist
))


0	
(quicksor
t
(genlist
0))
	
	
00	
Fig.
..
Maxim
um
allo
cation
space
In
Figure
.	
w
e
compare
instead
the
total
n
um
b
er
of
in
teractions
with
and
without
garbage
collection.
As
remark
ed
ab
o
v
e,
collecting
garbage
as
so
on
as
p
ossible
ma
y
a
v
oid
a
lot
of
useless
op
erations.
G.C.
o
G.C.
on
(quicksor
t
(genlist
))

	
(quicksor
t
(genlist
0))

0
(quicksor
t
(genlist
))
00	

(quicksor
t
(genlist
0))


(quicksor
t
(genlist
))

0
(quicksor
t
(genlist
0))

	
Fig.
.	.
T
otal
n
um
b
er
of
in
teractions
.
Problems
bohm
w
orks
p
erfectly
w
ell
for
pure
-calculus:
m
uc
h
b
etter,
in
a
v
erage,
than
all
\traditional"
implemen
tations.
F
or
instance,
in
man
y
t
ypical
situations
w
e
ha
v
e
a
p
olynomial
cost
of
reduction
against
an
exp
onen
tial
one.
Unfortunately
,
this
is
not
true
for
\real
w
orld"
functional
programs.
In
this
case,
bohm's
p
erformance
is
ab
out
one
order
of
magnitude
w
orse
than
t
ypical
call-b
y-v
alue
implemen
tations
(suc
h
as
SML
or
Caml-li
gh
t)
and
ev
en
sligh
tly
(but
not
dramatically)
w
orse
than
lazy
implem
en
ta-
tions
suc
h
as
Hask
ell.
The
main
reason
of
this
fact
should
b
e
clear:
w
e
hardly
use
truly


The
Bolo
gna
Optimal
Higher-or
der
Machine
higher-order
functionals
in
functional
programming.
Higher-order
t
yp
es
are
just
used
to
ensure
a
certain
degree
of
parametricit
y
and
p
olymor-
phism
in
the
programs,
but
w
e
nev
er
really
consider
functions
as
data,
that
is,
as
the
real
ob
ject
of
the
computation|this
mak
es
a
crucial
dif-
ference
with
pure
-calculus,
where
all
data
are
ev
en
tually
represen
ted
as
functions.
As
a
consequence,
w
e
cannot
tak
e
a
real
adv
an
tage
from
the
higher-order
notion
of
sharing
discussed
in
this
b
o
ok.
Ho
w
m
uc
h
this
programming
st
yle
dep
ends
from
the
traditional,
\com-
mercial"
implemen
tations,
is
hard
to
sa
y
.
W
e
shall
not
try
to
answ
er
this
question,
here.
The
aim
of
this
section
is
just
to
p
oin
t
out
a
few
p
ossible
dev
elopmen
ts
of
bohm
that
could
mak
e
it
really
comp
etitiv
e
with
all
existen
t
reduction
mac
hines.
Do
not
forget
that
bohm
is
just
a
quite
primitiv
e
protot
yp
e!
..
The
c
ase
of
\app
end"
Most
of
the
curren
t
implem
en
tation
problems
can
b
e
easily
understo
o
d
b
y
discussing
the
case
of
the
append
function.
This
is
the
co
de:
def
append
=
rec
append
=
\l.\l.
if
isnil(l)
then
l
else
cons(hd(l),
append(tl(l)
l));;
Its
naiv
e
translation
in
to
a
graph
is
giv
en
in
Figure
.0.
The
problem
with
this
graph
should
b
e
eviden
t:
append
is
ob
viously
line
ar
in
b
oth
its
argumen
ts
(the
t
w
o
lists
to
b
e
app
ended).
Ho
w
ev
er,
this
linearit
y
is
hidden
b
y
the
syn
tax,
generating
a
graph
with
a
lot
of
useless
fans.
This
is
a
great
source
of
ineciency
.
F
or
instance,
in
Figure
.
is
describ
ed
a
t
ypical
piece
of
computation
concerning
the
in
teraction
b
et
w
een
isnil
and
cons
,
mediated
b
y
a
fan.
The
curren
t
solution
is
to
merge
together
(during
graph
generation)
isnil
and
the
fan,
obtaining
a
new
no
de
isnil
whose
b
eha
vior
is
describ
ed
in
Figure
..
Similarly
,
all
binary
forms
are
curren
tly
merged
with
fans
(w
e
lea
v
e
as
an
easy
exercise
for
the
reader
to
dene
all
new
forms
and
their
in
teraction
rules).
The
real
graph
generated
b
y
bohm
is
th
us
represen
ted
in
Figure
..
Although
this
naiv
e
optimization
do
es
not
w
ork
to
o
bad
in
practice,
the
real
issue
of
the
\hidden"
linearit
y
of
append
is
not
solv
ed
at
all.
Unfortunately
,
this
is
the
cause
of
a
quite
subtler
problem,
whic
h
is
also
related
to
bohm's
reduction
strategy
.
As
a
matter
of
fact,
graphs
lik
e

.
Pr
oblems
	
*
*
ISNIL
tl
hd
*
*
ITE
λ
λ
CONS
@
@
Fig.
.0.
Naiv
e
translation
of
append
the
one
in
Figure
.
easily
create
situations
of
the
kind
describ
ed
in
Figure
.
(the
rst
graph),
where
a
safe
fan
is
captured
inside
a
couple
of
other
matc
hing
fans
(those
inside
the
dotted
lines).
The
garbage
no
de
is
blo
c
k
ed
on
the
(ob
viously
unsafe)
\top-most"
fan
(actually
,
they
w
ould
b
e
merged
in
an
Uns
f
an).
No
w,
if
the
con
trol
is
coming
from
a
(i.e.,
this
is
the
main
path
on
the
stac
k),
the
computation
will
pro
ceed
as
describ
ed
in
Figure
..
In
particular
that
the
safe
fan
on
the
path
leading
to
c
w
ould
b
e
simplied
b
y
its
\in
teraction"
with
the
garbage
no
de.

	0
The
Bolo
gna
Optimal
Higher-or
der
Machine
*
*
CONS
ISNIL
CONS
ISNIL
*
CONS
F
*
*
CONS
CONS
F
(1)
(2)
(3)
(4)
Fig.
..
T
ypical
isnil
-cons
in
teraction
mediated
b
y
a
fan
ISNIL1
NIL
NIL
T
ISNIL1
CONS
F
CONS
Fig.
..
Reduction
rules
for
isnil
Instead,
if
the
con
trol
is
coming
from
b
w
e
ha
v
e
no
practical
w
a
y
to
get
rid
of
the
safe
fan,
causing
a
lot
of
useless
duplications.
As
a
matter
of
fact,
to
solv
e
the
previous
problem,
w
e
should
alw
a
ys
(or
at
least
frequen
tly)
attempt
a
propagation
of
uns
fan
no
des,
that
is
completely
infeasible,
in
practice.
Due
to
this
reason,
w
e
should
try
to
get
all
the
p
ossible
adv
an
tage
from
the
\hidden"
linearit
y
of
programs,
a
v
oiding
to
in
tro
duce
fans
where
they
are
not
really
needed.

.
Pr
oblems
	
*
DEC
*
ITE
λ
λ
CONS
@
@
ISNIL1
Fig.
..
In
ternal
bohm's
represen
tation
of
append
Let
us
see
ho
w
w
e
could
pro
ceed
in
the
practical
case
of
append
(ho
w-
ev
er,
this
is
not
implemen
ted
in
the
curren
t
v
ersion
of
bohm).
First
of
all,
w
e
should
a
v
oid
sharing
b
et
w
een
the
then
and
the
else
branc
h
of
the
conditional
statemen
ts.
This
is
not
to
o
dicult;
it
is
enough
to
write
the
program
in
the
follo
wing
w
a
y:
def
append
=
rec
append
=
\l.
if
isnil(l)
then
\l.l
else
\l.cons(hd(l),
append(tl(l)
l));;
Suc
h
a
program
w
ould
generate
a
graph
of
the
kind
describ
ed
in
Fig-
ure
..

	
The
Bolo
gna
Optimal
Higher-or
der
Machine
*
*
*
*
*
a
safe
b
safe
c
d
*
*
*
safe
a
b
c
d
*
*
*
safe
b
safe
c
d
a
*
*
b
safe
c
d
a
Fig.
..
A
safe
fan
captured
b
et
w
een
a
pair
of
matc
hing
fans
*
ITE
λ
λ
CONS
@
@
DEC
λ
ISNIL1
Fig.
..
append
without
sharing
b
et
w
een
the
conditional
branc
hes
This
tec
hnique
can
b
e
generalized:
close
the
subterms
with
resp
ect
to
eac
h
(shared)
v
ariable
y,
and
apply
the
result
of
the
conditional
state-
men
t
to
y
(in
the
case
of
append,
there
is
also
an
implicit
-reduction).

.
Pr
oblems
	
In
order
to
eliminate
the
remaining
sharing
in
the
graph
of
Fig-
ure
.,
w
e
m
ust
then
c
hange
the
if
then
else
statemen
t
in
to
a
case
statemen
t.
The
case
no
de
will
pass
its
test-argumen
t
to
the
appropriate
con
tin
uation(s)
(so,
it
also
w
orks
as
a
binder
for
these
con
tin
uations).
F
or
instance,
t
ypical
in
teraction
rules
for
a
simple
case
op
erator
o
v
er
lists
are
describ
ed
in
Figure
..
c-
b
c
NIL
a
CASE
c-
a
b
c
c-
a
CASE
b
c
CONS
e
d
CONS
d
e
c-
b
a
c
Fig.
..
Reduction
rules
for
case
Using
suc
h
a
case
no
de,
append
w
ould
b
e
represen
ted
b
y
the
graph
in
Figure
.
As
w
e
exp
ected,
w
e
ha
v
e
no
sharing
at
all
in
this
graph!
Ho
w
ev
er,
there
is
still
a
nal
problem
to
b
e
addressed.
If
a
function
is
linear
in
some
of
its
argumen
ts,
w
e
should
not
put
these
argumen
ts
inside
a
b
o
x
(i.e.,
the
argumen
ts
should
b
e
translated
at
the
same
lev
el
of
the
term).
Note
that
this
is
essential
if
w
e
w
an
t
to
prot
of
the
linearit
y
of
the
term;
otherwise,
w
e
should
in
an
y
case
propagate
a
croissan
t
through
the
argumen
t,
that
is
practically
as
exp
ensiv
e
as
propagating
a
fan.
So,
w
e
m
ust
ev
en
tually
address
the
complex
problem
of
t
yping
in
Linear
Logic.
In
particular,
for
p
eople
acquain
ted
with
Linear
Logic,
it
should
b
e
clear
that
all
the
previous
discussion
is
strictly
related
to
the
so
called
additive
t
yp
es
of
this
Logic.
W
e
strongly
b
eliev
e
that
the
future
of
optimalit
y
as
a
really
feasible
arc
hitecture
for
functional
programming
largely
dep
ends
on
additiv
e
t
yp
es
and
on
the
related
linearit
y
issues|on
the
other
side,
the
the
or
etic
al
in
terest
of
this
topic
is
out
of
question.
Another
in
teresting
p
oin
t
to
b
e
in
v
estigated
is
the
p
ossibilit
y
to
rein-
tro
duce,
at
some
exten
t,
an
explicit
(i.e.,
glob
al)
notion
of
b
o
x
in
the
graphs.
Suc
h
a
b
o
x
should
b
e
ob
viously
understo
o
d
as
a
place
where
w
e
force
se
quentialization
(lo
osing
sharing).
This
approac
h
seem
to
op
en
the
w
a
y
to
an
in
tegration
b
et
w
een
Lamping's
algorithm
and
more
tra-
ditional
implemen
tation
tec
hniques,
suc
h
as
en
vironmen
t
mac
hines
and,

	
The
Bolo
gna
Optimal
Higher-or
der
Machine
*
λ
λ
CASE
λ
CONS
@
@
DEC
Fig.
..
append
using
case
esp
ecially
,
sup
ercom
binators.
In
particular,
explicit
b
o
xes
should
allo
w
a
certain
degree
of
compilation:
the
idea
is
to
compile
a
b
o
x
in
to
the
sequence
of
instructions
needed
to
create
an
instance
of
itself
(as
it
is
done
for
sup
ercom
binators).

Bibliograph
y
[A
CCL	0]
Mart

n
Abadi,
Luca
Cardelli,
Pierre
Louis
Curien,
and
Jean-Jacques
L

evy
.
Explicit
substitutions
.
In
Confer
enc
e
R
e
c
or
d
of
the
Sevente
ent
h
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	0),
pages
{,
San
F
rancisco,
California,
Jan
uary
		0.
[A
CCL	]
Mart

n
Abadi,
Luca
Cardelli,
Pierre-Louis
Curien,
and
Jean-Jacques
L

evy
.
Explicit
substitutions
.
Journal
of
F
unctional
Pr
o
gr
amming,
():{,
Octob
er
		.
[Acz]
P
eter
Aczel.
A
general
Ch
urc
h-Rosser
theorem.
Unpublished
man
uscript,
	.
[AP]
Luigia
Aiello
and
Gianfranco
Prini.
An
ecien
t
in
terpreter
for
the
lam
b
da
calculus.
Journal
of
Computer
and
System
Scienc
es,
:{,
	.
[AKP]
Arvind,
Vino
d
Kathail,
and
Kesha
w
Pingali.
Sharing
of
computation
in
functional
language
implemen
tations
.
T
ec
hnical
rep
ort,
MIT,
Lab
oratory
for
Computer
Science,
Cam
bridge,
Massac
h
usetts,
July
	.
[Asp	]
Andrea
Asp
erti.
A
categorical
understanding
of
en
vironmen
t
mac
hines.
Journal
of
F
unctional
Pr
o
gr
amming,
(),
		.
[Asp	]
Andrea
Asp
erti.
Linear
logic,
comonads,
and
optimal
reductions.
F
undamenta
Informatic
ae,
(),
		.
Sp
ecial
Issue
dev
oted
to
Categories
in
Computer
Science
(in
vited
pap
er).
[Asp	]
Andrea
Asp
erti.


!
=
:
Optimizing
optimal
-calculus
implemen
tations
.
In
Jieh
Hsiang,
editor,
R
ewriting
T
e
chniques
and
Applic
ation
s,
th
Internationa
l
Confer
enc
e,
R
T
A-	,
v
olume
	
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
0{,
Kaiserslautern,
German
y
,
		.
Springer-V
erlag.
[Asp	]
Andrea
Asp
erti.
On
the
complexit
y
of
b
eta-reduction.
In
Pr
o
c.
of
the
Twentythir
d
A
nnual
A
CM
SIGA
CT-SIGPLAN
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	),
St.
P
etersburg
Beac
h,
Florida,
		.
[A
C	]
A.
Asp
erti,
J.Chrob
o
czek.
Safe
Op
erators:
brac
k
ets
closed
forev
er.
Applicable
Algebra
in
Engineering,
Comm
unication
and
Computing,
Springer
V
erlag.
T
o
app
ear.
[ADLR	]
Andrea
Asp
erti,
Vincen
t
Danos,
Cosimo
Lanev
e,
and
Lauren
t
Regnier.
P
aths
in
the
-calculus.
In
Pr
o
c
e
e
dings,
Ninth
A
nnual
IEEE
	

	
Biblio
gr
aphy
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
P
aris,
F
rance,
		.
[A
GN	]
A.
Asp
erti,
C.
Gio
v
annetti,
and
A.
Naletto.
The
Bologna
Optimal
Higher-order
Mac
hine.
Journal
of
F
unctional
Pr
o
gr
amming,
		.
T
o
app
ear.
[AL	a]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
Optimal
Reductions
in
In
teraction
Systems.
In
M.-C.
Gaudel
and
J.-P
.
Jounnaud,
editors,
Pr
o
c.
of
T
apSoft
'	,
v
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
{00.
Springer-V
erlag,
Orsa
y
,
F
rance,
		.
[AL	b]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
P
aths,
computations
and
lab
els
in
the
-calculus.
In
C.
Kirc
hner,
editor,
R
ewriting
T
e
chniques
and
Applic
ation
s,
Pr
o
c.
of
the
th
Internation
al
Confer
enc
e,
R
T
A'	,
v
olume
	0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
{,
Mon
treal,
Canada,
		.
Springer-V
erlag.
[AL	a]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
The
family
relation
in
in
teraction
systems.
In
Pr
o
c.
of
the
International
Symp
osium
on
The
or
etic
al
Asp
e
cts
of
Computer
Scienc
e
(T
A
CS'	),
v
olume
	
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
{.
Springer-V
erlag,
Sendai,
Japan,
		.
[AL	b]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
In
teraction
Systems
I:
the
theory
of
optimal
reductions.
Mathematic
al
Structur
es
in
Computer
Scienc
e,
:{0,
		.
[AL	a]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
Comparing
-calculus
translations
in
sharing
graphs.
In
M.
Dezani-Ciancagli
ni
and
Gordon
Plotkin,
editors,
Pr
o
c.
of
the
Se
c
ond
Internation
al
Confer
enc
e
on
T
yp
e
d
L
amb
da
Calculi
and
Applic
atio
ns
,
TLCA'	,
v
olume
	0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
{.
Springer-V
erlag,
Edin
burgh,
Scotland,
		.
[AL	b]
Andrea
Asp
erti
and
Cosimo
Lanev
e.
P
aths,
Computations
and
Lab
els
in
the
-calculus.
The
or
etic
al
Computer
Scienc
e,
(),
Ma
y
		.
Sp
ecial
Issue
dev
oted
to
R
T
A
'	.
Extended
v
ersion
of
[AL	b].
[AL	]
Andrea
Asp
erti
and
Giusepp
e
Longo.
Cate
gories,
T
yp
es,
and
Structur
es.
A
n
intr
o
duction
to
Cate
gory
The
ory
for
the
Working
Computer
Scientist.
F
oundation
of
Computing
Series.
M.I.T.
Press,
		.
[AM	]
A.
Asp
erti,
H.
Mairson.
P
arallel
b
eta
reduction
is
not
elemen
tary
recursiv
e.
Draft.
T
o
app
ear.
[AJ	]
L.
Augustsson
and
T.
Johnsson.
The
Chalmers
Lazy-ML
compiler.
The
Computer
Journal,
():{,
April
		.
Sp
ecial
issue
on
Lazy
F
unctional
Programming.
[Bar]
Henk
P
.
Barendregt.
The
L
amb
da
Calculus,
its
Syntax
and
Semantics,
v
olume
0
of
Studies
in
lo
gic
and
the
foundations
of
mathematics.
North-Holland,
	.
[BKKS]
H.P
.
Barendregt,
Kenna
w
a
y
,
Klop,
and
Sleep.
Needed
reduction
and
spine
strategies
for
the
lam
b
da
calculus.
Information
and
Computation,
:	{,
	.
[BBdPH	]
N.
Ben
ton,
G.
Bierman,
V.
de
P
aiv
a,
and
M.
Hyland.
T
erm
assignemen
t
for
in
tuitionisti
c
linear
logic.
In
ternal
rep
ort,
Univ
ersit
y
of
Cam
bridge,
		.
[BL	]
G

erard
Berry
and
Jean-Jacques
L

evy
.
Minimal
and
optimal
computations
of
recursiv
e
programs.
Journal
of
the
A
CM,
():{,
Jan
uary
		.

Biblio
gr
aphy
	
[BD]
Corrado
B
ohm
and
Mariangiol
a
Dezani.
A
CUCH-mac
hine:
the
automatic
treatmen
t
of
b
ound
v
ariables.
Internationa
l
Journal
of
Computer
and
Information
Scienc
es,
():{	,
June
	.
[BD]
Corrado
B
ohm
and
Mariangiol
a
Dezani.
Notes
on
\A
CUCH-mac
hine:
the
automatic
treatmen
t
of
b
ound
v
ariables".
International
Journal
of
Computer
and
Information
Scienc
es,
():{0,
June
	.
[vEB	0]
P
.
v
an
Emde
Boas.
Machine
mo
dels
and
simulation.
Handb
o
ok
of
Theoretical
Computer
Science,
v
olume
A,
pp.
{.
North
Holland,
		0.
[BG]
Corrado
B
ohm
and
W
olf
Gross.
In
tro
duction
to
the
CUCH.
In
E.
R.
Caianiello,
editor,
A
utomata
The
ory,
pages
{.
Academic
Press,
	.
[Bou]
N.
Bourbaki.
Th

eorie
des
ensembles.
Hermann
&
C.
Editeurs,
	.
[Bur	]
A.
Burroni.
Higher
dimensional
w
ord
problems.
In
Cate
gory
The
ory
and
Computer
Scienc
e,
v
olume
0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
	{0.
Springer-V
erlag,
		.
[Car]
Luca
Cardelli.
Compiling
a
functional
language.
In
Pr
o
c
e
e
dings
of
the
A
CM
Symp
osyum
on
LISP
and
F
unctional
Pr
o
gr
amming,
pages
0{,
Austin,
August
	.
[Carar]
Luca
Cardelli.
The
functional
abstract
mac
hine.
Polymorphism,
(),
y
ear?
[Ch
u]
A.
Ch
urc
h.
The
Calculi
of
Lam
b
da-con
v
ersion.
Princeton
Univ
ersit
y
Press,
	.
[CP]
A.H.
Cliord
and
G.B.
Preston.
The
algebraic
theory
of
semi-groups.
A.M.S.,
:??,
	.
[CCM]
G.
Cousineau,
P
.
L.
Curien,
and
M.
Maun
y
.
The
categorical
abstract
mac
hine.
In
J.R.
Jounaund,
editor,
F
unctional
L
anguages
and
Computer
A
r
chite
ctur
es,
v
olume
0
of
LNCS,
pages
0{.
Springer-V
erlag,
	.
[Cur	]
Pierre-Louis
Curien.
Cate
goric
al
Combinators,
Se
quential
A
lgorithms
and
F
unctional
Pr
o
gr
amming.
Progress
in
theoretical
computer
science.
Birkhauser,
Boston,
nd
edition,
		.
[CF]
Hask
ell
B.
Curry
and
Rob
ert
F
eys.
Combinatory
L
o
gic,
vol.
.
Studies
in
Logic
and
The
F
oundations
of
Mathematics.
North-Holland,
Amsterdam,
	.
Third
prin
ting
	.
[Dan	0]
Vincen
t
Danos.
Une
Applic
ation
de
la
L
o
gique
Lin

eair
e

a
l'

Etude
des
Pr
o
c
essus
de
Normalisation
(princip
alemen
t
du
-c
alcul).
Th

ese
de
do
ctorat,
Univ
ersit

e
P
aris
VI
I,
		0.
[DR	]
Vincen
t
Danos
and
Lauren
t
Regnier.
Lo
cal
and
async
hronous
b
eta-reduction.
In
Pr
o
c.

th
A
nnual
Symp
osium
on
L
o
gic
in
Computer
Scienc
e
(LICS'	),
pages
	{0,
Mon
treal,
		.
[DR	a]
Vincen
t
Danos
and
Lauren
t
Regnier.
Pro
of-nets
and
the
Hilb
ert
space.
In
J.-Y.
Girard,
Y.
Lafon
t,
and
L.
Regnier,
editors,
A
dvanc
es
in
Line
ar
L
o
gic,
pages
0{.
Cam
bridge
Univ
ersit
y
Press,
		.
Pro
ceedings
of
the
W
orkshop
on
Linear
Logic,
Ithaca,
New
Y
ork,
June
		.
[DR	b]
Vincen
t
Danos
and
Lauren
t
Regnier.
Rev
ersible
and
irrev
ersible
computations:
Goi
and
-mac
hines.
Draft,
		.
[Fie	0]
John
Field.
On
laziness
and
optimalit
y
in
lam
b
da
in
terpreters:
to
ols
for
sp
ecication
and
analysis.
In
Pr
o
c.
Sevente
en
th
Symp
osium
on
Principles
of
Pr
o
gr
ammining
L
anguages
(POPL'	0),
pages
{,
		0.

	
Biblio
gr
aphy
[GAL	a]
Georges
Gon
thier,
Mart

n
Abadi,
and
Jean-Jacques
L

evy
.
The
geometry
of
optimal
lam
b
da
reduction.
In
Confer
enc
e
r
e
c
or
d
of
the
Ninete
enth
A
nnual
A
CM
SIGPLAN-SIG
A
CT
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	),
pages
{,
Alb
equerque,
New
Mexico,
Jan
uary
		.
[GAL	b]
Georges
Gon
thier,
Mart

n
Abadi,
and
Jean-Jacques
L

evy
.
Linear
logic
without
b
o
xes.
In
Pr
o
c
e
e
dings,
Seventh
A
nnual
IEEE
Symp
osium
on
L
o
gic
in
Computer
Scienc
e
(LICS'	),
pages
{,
San
ta
Cruz,
CA,
June
		.
IEEE.
[Gir]
Jean-Yv
es
Girard.
Linear
logic.
The
or
etic
al
Computer
Scienc
e,
0():{0,
	.
[Gir]
Jean-Yv
es
Girard.
Geometry
of
In
teraction
:
Deadlo
c
k-free
algorithms.
In
Pr
o
c.
of
the
Internationa
l
Confer
enc
e
on
Computer
L
o
gic
(COLOG
).
COLOG
,
Springer
V
erlag,
	.
[Gir	a]
Jean-Yv
es
Girard.
Geometry
of
In
teraction
:
In
terpretation
of
system
F.
In
R.
F
erro,
C.
Bonotto,
S.
V
alen
tini,
and
A.
Zanardo,
editors,
L
o
gic
Col
lo
qium
`,
pages
{0.
Elsevier
(North-Holland),
		.
[Gir	b]
Jean-Yv
es
Girard.
Pr
o
ofs
and
typ
es,
v
olume

of
Cambridge
tr
acts
in
the
or
etic
al
c
omputer
scienc
e.
Cam
bridge
Univ
ersit
y
Press,
		.
T
ranslated
and
with
app
endices
b
y
P
aul
T
a
ylor,
Yv
es
Lafon
t.
[Gir	a]
Jean-Yv
es
Girard.
Geometry
of
In
teraction
I
I
I:
The
general
case.
In
J.-Y.
Girard,
Y.
Lafon
t,
and
L.
Regnier,
editors,
A
dvanc
es
in
Line
ar
L
o
gic,
pages
	{	.
Cam
bridge
Univ
ersit
y
Press,
		.
Pro
ceedings
of
the
W
orkshop
on
Linear
Logic,
Ithaca,
New
Y
ork,
June
		.
[Gir	b]
Jean-Yv
es
Girard.
Linear
logic:
Its
syn
tax
and
seman
tics.
In
J.-Y.
Girard,
Y.
Lafon
t,
and
L.
Regnier,
editors,
A
dvanc
es
in
Line
ar
L
o
gic,
pages
{.
Cam
bridge
Univ
ersit
y
Press,
		.
Pro
ceedings
of
the
W
orkshop
on
Linear
Logic,
Ithaca,
New
Y
ork,
June
		.
[GL]
Jean-Yv
es
Girard
and
Yv
es
Lafon
t.
Linear
logic
and
lazy
computation.
In
T
APSOFT
'
vol.
,
v
olume
0
of
LNCS,
pages
{,
	.
[GMM	]
S.
Guerrini,
S.
Martini,
and
A.
Masini.
Coherence
for
sharing
pro
of
nets.
In
Harald
Ganzinger,
editor,
Pr
o
c
e
e
dings
of
the
th
Internation
al
Confer
enc
e
on
R
ewriting
T
e
chniques
and
Applic
ations
(R
T
A-	),
v
olume
0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
{	,
New
Brunswic
k,
NJ,
USA,
		.
Springer-V
erlag.
[Gue	]
Stefano
Guerrini.
Sharing-morphis
ms
and
(optimal)
-graph
reductions.
In
??,
editor,
The
Tbilisi
Symp
osyum
on
L
anguage,
L
o
gic
and
Computation,
??,
page
??,
Tbilisi,
Georgia,
Octob
er
		.
CSLI
Publication
s.
[Gue	]
Stefano
Guerrini.
The
or
etic
al
and
Pr
actic
al
Issues
of
Optimal
Implementations
of
F
unctional
L
anguages.
PhD
Thesis,
Dipartimen
to
di
Informatica,
Univ
ersit
a
di
Pisa,
Pisa,
		.
TD-/	.
[Gue	]
Stefano
Guerrini.
A
general
theory
of
sharing
graphs.
IR
CS
Rep
ort
	{0,
Institute
for
Reasearc
h
in
Cognitiv
e
Science,
Univ
ersit
y
of
P
ennsylv
ania,
Philadelph
ia
,
Marc
h
		.
Submitted
for
publicati
on:
in
vited
submission
to
a
sp
ecial
issue
of
Theoretical
Computer
Science.
[HS]
J.
Roger
Hindley
and
Jonathan
P
aul
Seldin.
Intr
o
duction
to
Combinators
and
-c
alculus,
v
olume

of
L
ondon
Mathematic
al
So
ciety,
Student
T
exts.
Cam
bridge
Univ
ersit
y
Press,
Cam
bridge,
	.
[HU	]
J.
E.
Hop
croft
and
J.
D.
Ullman.
In
tro
duction
to
Automata

Biblio
gr
aphy
		
Theory
,
Languages,
and
Computation.
Addison
W
esley
,
		.
[Kat	0]
Vino
d
Kathail.
Optimal
Interpr
eters
for
lamb
da-c
alculu
s
b
ase
d
functional
languages.
PhD
Thesis,
MIT,
		0.
[Klo0]
J.
W.
Klop.
Combinatory
R
e
duction
Systems.
PhD
Thesis,
Matematisc
h
Cen
trum,
Amsterdam,
	0.
Mathematical
Cen
tre
T
racts
.
[Laf]
Yv
es
Lafon
t.
The
linear
abstract
mac
hine.
The
or
etic
al
Computer
Scienc
e,
	:{0,
	.
Sp
ecial
issue:
In
t.
Join
t
Conf.
on
Theory
and
Practice
of
Soft
w
are
Dev
elopmen
t,
Pisa,
Marc
h
	.
[Laf	0]
Yv
es
Lafon
t.
In
teraction
nets.
In
Pr
o
c.
of
Sevente
en
th
A
nnual
A
CM
Symp
osyum
on
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	0),
pages
	{0,
San
F
rancisco,
California,
Jan
uary
		0.
[Laf	]
Yv
es
Lafon
t.
P
enrose
diagrams
and
-dimensional
rewritings.
In
LMS
Symp
osium
on
Applic
ation
s
of
Cate
gories
in
Computer
Scienc
e.
Cam
bridge
Univ
ersit
y
Press,
		.
[Laf	]
Yv
es
Lafon
t.
F
rom
pro
of
nets
to
in
teraction
nets.
In
J.-Y.
Girard,
Y.
Lafon
t,
and
L.
Regnier,
editors,
A
dvanc
es
in
Line
ar
L
o
gic,
pages
{.
Cam
bridge
Univ
ersit
y
Press,
		.
Pro
ceedings
of
the
W
orkshop
on
Linear
Logic,
Ithaca,
New
Y
ork,
June
		.
[Lam	]
John
Lamping.
An
algorithm
for
optimal
lam
b
da
calculus
ev
aluation.
T
ec
hnical
Rep
ort
Series
SSL-	-,
Xero
x
P
AR
C,
P
alo
Alto,
Ma
y
		.
[Lam	0]
John
Lamping.
An
algorithm
for
optimal
lam
b
da
calculus
reduction.
In
Pr
o
c.
of
Sevente
enth
A
nnual
A
CM
Symp
osyum
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
{0,
San
F
rancisco,
California,
Jan
uary
		0.
[Lan]
P
.
J.
Landin.
The
mec
hanical
ev
aluation
of
expressions.
Computer
Journal,
:0{0,
	.
[Lan	]
Cosimo
Lanev
e.
Optimality
and
Concurr
ency
in
Inter
action
Systems.
PhD
Thesis,
TD-/	,
Dipartimen
to
di
Informatica,
Univ
ersit
a
di
Pisa,
Pisa,
Marc
h
		.
[LM	]
Julia
L.
La
w
all
and
Harry
G.
Mairson.
Optimality
and
ineciency
:
what
isn
't
a
c
ost
mo
del
of
the
lamb
da
c
alculus?
		
A
CM
In
ternational
Conference
on
F
unctional
Programming,
pp.
	{0.
[LM	]
Julia
L.
La
w
all
and
Harry
G.
Mairson.
On
the
glob
al
dynamics
of
optimal
gr
aph
r
e
duction.
		
A
CM
In
ternational
Conference
on
F
unctional
Programming,
to
app
ear.
[LM	]
X.
Lero
y
and
M.
Maun
y
.
The
Caml
Ligh
t
system,
release
0..
do
cumen
tation
and
user's
man
ual.
T
ec
hnical
rep
ort,
INRIA,
Septem
b
er
		.
[L

ev]
Jean-Jacques
L

evy
.
An
algebraic
in
terpretation
of
the
K-calculus
and
an
application
of
lab
elled
-calculus.
The
or
etic
al
Computer
Scienc
e,
():	{,
	.
[L

ev]
Jean-Jacques
L

evy
.
R

eductions
Corr
e
ctes
et
Optimales
dans
le
lamb
da-c
alcul.
PhD
Thesis,
Univ
ersit

e
P
aris
VI
I,
	.
[L

ev0]
Jean-Jacques
L

evy
.
Optimal
reductions
in
the
lam
b
da-calcul
us.
In
Seldin
and
Hindley
[SH0],
pages
	{	.
[Mac	]
Ian
Mac
kie.
The
Geometry
of
In
teraction
Mac
hine.
In
Confer
enc
e
R
e
c
or
d
of
POPL
'	:
nd
A
CM
SIGPLAN-SIGA
CT
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
	{0,
San
F
rancisco,
California,
Jan
uary
		.

00
Biblio
gr
aphy
[Mai	]
Harry
G.
Mairson.
A
simple
pr
o
of
of
a
the
or
em
of
Statman.
Theoretical
Computer
Science
0
(		),
pp.
{	.
[Mey]
Alb
ert
R.
Mey
er.
The
inher
ent
c
omputational
c
omplexity
of
the
ories
of
or
der
e
d
sets.
Pro
ceedings
of
the
In
ternational
Congress
of
Mathematicians,
	,
pp.
{.
[P
ar	]
Mic
hel
P
arigot.
-calculus:
An
algorithmic
in
terpretation
of
classical
natural
deduction.
In
Andrei
V
oronk
o
v,
editor,
L
o
gic
Pr
o
gr
amming
and
A
utomate
d
R
e
asoning,
Internationa
l
Confer
enc
e
LP
AR'	,
v
olume

of
L
e
ctur
e
Notes
in
Computer
Scienc,
St.
P
etersburg,
Russia,
		.
Springer-V
erlag.
[P
et]
Mario
P
etric
h.
Inverse
Semigr
oups.
Pure
and
applied
mathematics.
John
Wiley
&
Sons,
New
Y
ork,
	.
[PJ]
Simon
L.
P
eyton
Jones.
The
Implementation
of
F
unctional
Pr
o
gr
amming
L
anguages.
Pren
tice
Hall
In
ternational,
Englew
o
o
d
Clis,
New
Jersey
,
	.
[Reg	]
Lauren
t
Regnier.
L
amb
da-Calcul
et
R
ese
aux.
Phd
Thesis,
Univ
ersit

e
P
aris
,
Jan
uary
		.
[Sc
h]
Helm
ut
Sc
h
wic
h
ten
b
erg.
Complexity
of
normalization
in
the
pur
e
typ
e
d
lamb
da
c
alculus.
The
L.E.J.
Br
ouwer
Centenary
Symp
osium
(ed.
A.
S.
T
ro
elstra
and
D.
V
an
Dalen).
North-Holland,
Amsterdam.
	.
[SH0]
Jonathan
P
.
Seldin
and
J.
Roger
Hindley
,
editors.
T
o
H.B.
Curry,
Essays
on
Combinatory
L
o
gic,
L
amb
da
Calculus
and
F
ormalism.
Academic
Press,
	0.
[Sta	]
Ric
hard
Statman.
The
typ
e
d
-c
alculus
is
not
elementary
r
e
cursive.
Theoretical
Computer
Science
	,
		,
pp.
{.
[The	]
The
Y
ale
Hask
ell
Group.
The
y
ale
hask
ell
users
man
ual.
T
ec
hnical
rep
ort,
Y
ale
Univ
ersit
y
,
Octob
er
		.
[VDS	]
J.B.
Joinet
V.
Danos
and
H.
Shellinx
.
lkt
and
lkq.
Submitted
for
publication
,
		.
[V
ui]
J.
V
uillemin.
Correct
and
optimal
implemen
tation
of
recursion
in
a
simple
programming
language.
Journal
of
Computer
and
System
Scienc
es,
	(),
	.
[W
ad]
C.
P
.
W
adsw
orth.
Semantics
and
pr
agmatics
of
the
lamb
da-c
alculu
s.
Phd
Thesis,
Oxford,
	.
Chapter
.


