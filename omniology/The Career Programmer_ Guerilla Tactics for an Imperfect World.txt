
THE CAREER
PROGRAMMER
GUERILLA TACTICS FOR AN IMPERFECT WORLD,
SECOND EDITION
Christopher Duncan

The Career Programmer: Guerilla Tactics for an Imperfect World,
Second Edition
Copyright © 2006 by Christopher Duncan
All rights reserved. No part of this work may be reproduced or transmitted in any form or by any
means, electronic or mechanical, including photocopying, recording, or by any information
storage or retrieval system, without the prior written permission of the copyright owner and the
publisher.
ISBN-13 (pbk): 978-1-59059-624-1
ISBN-10 (pbk): 1-59059-624-2
Library of Congress Cataloging-in-Publication data is available upon request.
Printed and bound in the United States of America 9 8 7 6 5 4 3 2 1
Trademarked names may appear in this book. Rather than use a trademark symbol with every
occurrence of a trademarked name, we use the names only in an editorial fashion and to the
benefit of the trademark owner, with no intention of infringement of the trademark.
Lead Editor: Dominic Shakeshaft
Editorial Board: Steve Anglin, Dan Appleman, Ewan Buckingham, Gary Cornell, Jason Gilmore,
Jonathan Hassell, Chris Mills, Dominic Shakeshaft, Jim Sumser
Project Manager: Richard Dal Porto
Copy Edit Manager: Nicole LeClerc
Copy Editor: Marilyn Smith
Assistant Production Director: Kari Brooks-Copony
Production Editor: Katie Stence
Compositor: Dina Quan
Proofreader: Lori Bring
Indexer: Toma Mulligan
Cover Designer: Kurt Krames
Manufacturing Director: Tom Debolski
Distributed to the book trade worldwide by Springer-Verlag New York, Inc., 233 Spring Street,
6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax 201-348-4505, e-mail 
orders-ny@springer-sbm.com, or visit http://www.springeronline.com.
For information on translations, please contact Apress directly at 2560 Ninth Street, Suite 219,
Berkeley, CA 94710. Phone 510-549-5930, fax 510-549-5939, e-mail info@apress.com, or visit
http://www.apress.com.
The information in this book is distributed on an “as is” basis, without warranty. Although every
precaution has been taken in the preparation of this work, neither the author(s) nor Apress shall
have any liability to any person or entity with respect to any loss or damage caused or alleged to
be caused directly or indirectly by the information contained in this work. 

This book is dedicated to the memory of James Michael Graves,
my best friend and the brother I never had. I miss you, man.

Contents at a Glance
FOREWORD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
ABOUT THE AUTHOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
ACKNOWLEDGMENTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix
INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxi
PART I
SOFTWARE DEVELOPMENT IN AN IMPERFECT WORLD 
CHAPTER 1
WELCOME TO THE CORPORATE WORLD . . . . . . . . . . 3
CHAPTER 2
BUSINESS IS WAR. MEET THE ENEMY. . . . . . . . . . . . . . 21
CHAPTER 3
GOOD CODING SKILLS ARE NOT ENOUGH . . . . . . . . 45
PART II
GUERILLA TACTICS FOR FRONT-LINE PROGRAMMERS 
CHAPTER 4
PREVENTING ARBITRARY DEADLINES . . . . . . . . . . . . 59
CHAPTER 5
GETTING YOUR REQUIREMENTS ETCHED IN STONE . . 75
CHAPTER 6
EFFECTIVE DESIGN UNDER FIRE . . . . . . . . . . . . . . . . 95
CHAPTER 7
PRACTICAL ESTIMATING TECHNIQUES . . . . . . . . . . 111
CHAPTER 8
FIGHTING FOR QUALITY ASSURANCE . . . . . . . . . . . 127
CHAPTER 9
KEEPING THE PROJECT UNDER CONTROL . . . . . . . . 141
CHAPTER 10 MANAGING YOUR MANAGEMENT . . . . . . . . . . . . . 159
CHAPTER 11 CORPORATE SELF-DEFENSE . . . . . . . . . . . . . . . . . 175
iv

PART III
BUILDING A BETTER CAREER 
CHAPTER 12 CONTROLLING YOUR DESTINY . . . . . . . . . . . . . . . 189
CHAPTER 13 GET A JOB (SHA NA NA NA. . .) . . . . . . . . . . . . . . . 201
CHAPTER 14 CAREER 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
CHAPTER 15 FLYING SOLO . . . . . . . . . . . . . . . . . . . . . . . . . . 231
CHAPTER 16 JOB SECURITY . . . . . . . . . . . . . . . . . . . . . . . . . . 245
INDEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
v

Contents
FOREWORD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
ABOUT THE AUTHOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
ACKNOWLEDGMENTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix
INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxi
PART I
SOFTWARE DEVELOPMENT IN AN IMPERFECT WORLD 
CHAPTER 1
WELCOME TO THE CORPORATE WORLD . . . . . . . . . . 3
So You Thought You’d Just Be Coding All Day, Eh? . . . . . . . . 3
What’s a Nice Programmer Like Me. . . . . . . . . . . . . . . . . 5
Why People Run Businesses and Pay Programmers . . . . . . . 6
The Corporate World Is Not Logical . . . . . . . . . . . . . . . 8
You Can’t Win If You Don’t Play . . . . . . . . . . . . . . . . . 11
The Food Chain . . . . . . . . . . . . . . . . . . . . . . . . . . 13
The Various Species of Programmers . . . . . . . . . . . . . . 16
CHAPTER 2
BUSINESS IS WAR. MEET THE ENEMY. . . . . . . . . . . . . . 21
Unrealistic Deadlines . . . . . . . . . . . . . . . . . . . . . . . . 21
Vague Definition of Requirements . . . . . . . . . . . . . . . . 28
Inadequate Time for Analysis and Design . . . . . . . . . . . . 31
Sometimes the Enemy Is Within . . . . . . . . . . . . . . . . . 34
No Time or Resources for Testing . . . . . . . . . . . . . . . . 36
Poor Company Management . . . . . . . . . . . . . . . . . . . 38
Internal Politics . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
The Unexpected . . . . . . . . . . . . . . . . . . . . . . . . . . 42
vi

CHAPTER 3
GOOD CODING SKILLS ARE NOT ENOUGH . . . . . . . . 45
What’s in It for Me? . . . . . . . . . . . . . . . . . . . . . . . . 45
Who Needs These Skills? . . . . . . . . . . . . . . . . . . . . . 49
Taking Control of Your Time . . . . . . . . . . . . . . . . . . . . 51
Enhancing Design . . . . . . . . . . . . . . . . . . . . . . . . . . 53
Improving Interaction . . . . . . . . . . . . . . . . . . . . . . . 53
Getting What You Want . . . . . . . . . . . . . . . . . . . . . . 54
PART II
GUERILLA TACTICS FOR FRONT-LINE PROGRAMMERS 
CHAPTER 4
PREVENTING ARBITRARY DEADLINES . . . . . . . . . . . . 59
Defining the Process . . . . . . . . . . . . . . . . . . . . . . . . 60
Commissioning a New Software Project . . . . . . . . . . . . 63
Identifying the Requirements . . . . . . . . . . . . . . . . . . . 64
Building Your Testing Environment . . . . . . . . . . . . . . . . 65
Entering the Design Phase . . . . . . . . . . . . . . . . . . . . . 66
Estimating the Effort . . . . . . . . . . . . . . . . . . . . . . . . 68
Coding Bliss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Testing the Candidates . . . . . . . . . . . . . . . . . . . . . . . 71
Addressing the Installation Issues . . . . . . . . . . . . . . . . . 71
Managing the Beta Phase . . . . . . . . . . . . . . . . . . . . . 72
vii

CHAPTER 5
GETTING YOUR REQUIREMENTS ETCHED IN STONE . . 75
You Don’t Have to Like It. It Just Has to Be Clear.
. . . . . . . 76
Where Does the Power Lie? . . . . . . . . . . . . . . . . . . . 77
Politics Are an Inescapable Reality . . . . . . . . . . . . . . . . 79
Identifying the Other Influential People . . . . . . . . . . . . . 81
Selling the Process . . . . . . . . . . . . . . . . . . . . . . . . . 82
The Definition Questions . . . . . . . . . . . . . . . . . . . . . 83
Preparations for Effective Information Gathering . . . . . . . . 84
Defining the Requirements . . . . . . . . . . . . . . . . . . . . 86
When the Party’s Over . . . . . . . . . . . . . . . . . . . . . . 88
Coping with a Hostile Environment . . . . . . . . . . . . . . . 89
Politics Are Never Far Away . . . . . . . . . . . . . . . . . . . . 93
CHAPTER 6
EFFECTIVE DESIGN UNDER FIRE . . . . . . . . . . . . . . . . 95
Design? What Design? . . . . . . . . . . . . . . . . . . . . . . . 96
Estimating the Design Effort . . . . . . . . . . . . . . . . . . . . 97
Rolling Your Own Design Methodology . . . . . . . . . . . . 100
Hitting the High Points . . . . . . . . . . . . . . . . . . . . . . 105
Effective Prototyping . . . . . . . . . . . . . . . . . . . . . . . 106
When You Can’t Get Even This Much Time . . . . . . . . . . 108
Onward to Implementation . . . . . . . . . . . . . . . . . . . 110
CHAPTER 7
PRACTICAL ESTIMATING TECHNIQUES . . . . . . . . . . 111
Understanding the Process . . . . . . . . . . . . . . . . . . . 112
Avoiding Common Mistakes . . . . . . . . . . . . . . . . . . . 113
The Myth of the Eight-Hour Day . . . . . . . . . . . . . . . . 114
Crunching the Numbers . . . . . . . . . . . . . . . . . . . . . 116
Converting Hours to Delivery Dates . . . . . . . . . . . . . . 118
Don’t Forget the Final Details . . . . . . . . . . . . . . . . . . 121
Wrapping Up the Project . . . . . . . . . . . . . . . . . . . . 123
What If Things Didn’t Go by the Book? . . . . . . . . . . . . 124
viii
Contents

CHAPTER 8
FIGHTING FOR QUALITY ASSURANCE . . . . . . . . . . . 127
How Do We Get Away with Buggy Releases? . . . . . . . . . 128
Justifying a Quality Assurance Effort . . . . . . . . . . . . . . . 129
What’s a Tester? . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Building Your Team . . . . . . . . . . . . . . . . . . . . . . . . 133
Training Your Testers . . . . . . . . . . . . . . . . . . . . . . . 134
Make the Testers Feel Like a Part of the Team . . . . . . . . . 136
Establishing the QA Process . . . . . . . . . . . . . . . . . . . 138
CHAPTER 9
KEEPING THE PROJECT UNDER CONTROL . . . . . . . . 141
Keeping Track of Your Time . . . . . . . . . . . . . . . . . . . . 141
Managing Your Team . . . . . . . . . . . . . . . . . . . . . . . 143
Improving Your Coding Discipline . . . . . . . . . . . . . . . . 144
Thinking Ahead to Debugging . . . . . . . . . . . . . . . . . . 147
Incorporating Version Control . . . . . . . . . . . . . . . . . . 148
Improving Productivity . . . . . . . . . . . . . . . . . . . . . . 149
Knowing When to Walk Away . . . . . . . . . . . . . . . . . . 151
Optimizing Your Meetings . . . . . . . . . . . . . . . . . . . . 152
Wrapping It Up . . . . . . . . . . . . . . . . . . . . . . . . . . 156
CHAPTER 10 MANAGING YOUR MANAGEMENT . . . . . . . . . . . . . 159
Improving Communications . . . . . . . . . . . . . . . . . . . 160
Instituting Change . . . . . . . . . . . . . . . . . . . . . . . . . 163
Bolstering Your Position . . . . . . . . . . . . . . . . . . . . . 165
Frontal Assaults (For Those Who Respond to Reason) . . . . 167
Stealth Tactics (When Reason Is Not Enough) . . . . . . . . . 169
Credibility, the Key to Success . . . . . . . . . . . . . . . . . . 171
CHAPTER 11 CORPORATE SELF-DEFENSE . . . . . . . . . . . . . . . . . 175
What Do You Have to Lose? . . . . . . . . . . . . . . . . . . 176
Picking Your Battles . . . . . . . . . . . . . . . . . . . . . . . . 177
Avoid Being a Target . . . . . . . . . . . . . . . . . . . . . . . 180
Assessing the Lay of the Land . . . . . . . . . . . . . . . . . . 181
Escape and Evade . . . . . . . . . . . . . . . . . . . . . . . . . 182
If You Must Attack . . . . . . . . . . . . . . . . . . . . . . . . 183
Improving Your Skills . . . . . . . . . . . . . . . . . . . . . . . 185
Contents
ix

PART III
BUILDING A BETTER CAREER 
CHAPTER 12 CONTROLLING YOUR DESTINY . . . . . . . . . . . . . . . 189
Considering Your Options . . . . . . . . . . . . . . . . . . . . 190
The Company Man . . . . . . . . . . . . . . . . . . . . . . . . 192
The Mercenary . . . . . . . . . . . . . . . . . . . . . . . . . . 194
The Entrepreneur . . . . . . . . . . . . . . . . . . . . . . . . . 197
Off to the Races . . . . . . . . . . . . . . . . . . . . . . . . . 199
CHAPTER 13 GET A JOB (SHA NA NA NA. . .) . . . . . . . . . . . . . . . 201
The Usual Suspects . . . . . . . . . . . . . . . . . . . . . . . . 202
Fame for Fun and Profit . . . . . . . . . . . . . . . . . . . . . 206
Getting the Word Out . . . . . . . . . . . . . . . . . . . . . . 207
Digging Deeper . . . . . . . . . . . . . . . . . . . . . . . . . . 208
Shuffling Paper . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
Face Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
CHAPTER 14 CAREER 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Captain, She Canna Take Much More o' This! . . . . . . . . . 219
Life Beyond Coding . . . . . . . . . . . . . . . . . . . . . . . . 220
Where’s a Compass When You Need One? . . . . . . . . . . 223
Abandon Ship! . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Where Do We Go from Here? . . . . . . . . . . . . . . . . . 226
Turning Passion into Paychecks . . . . . . . . . . . . . . . . . 227
CHAPTER 15 FLYING SOLO . . . . . . . . . . . . . . . . . . . . . . . . . . 231
Many Hats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Getting the Picture . . . . . . . . . . . . . . . . . . . . . . . . 238
Know Your Weaknesses . . . . . . . . . . . . . . . . . . . . . 239
Creating Your Deliverables . . . . . . . . . . . . . . . . . . . . 240
Distribution Decisions . . . . . . . . . . . . . . . . . . . . . . 241
Getting the Word Out . . . . . . . . . . . . . . . . . . . . . . 242
Continuing Education . . . . . . . . . . . . . . . . . . . . . . . 243
x
Contents

CHAPTER 16 JOB SECURITY . . . . . . . . . . . . . . . . . . . . . . . . . . 245
Long-Term Thinking . . . . . . . . . . . . . . . . . . . . . . . . 247
Taking Care of Your Peers . . . . . . . . . . . . . . . . . . . . 248
Improving Communication . . . . . . . . . . . . . . . . . . . . 249
Overcoming Fear of Change . . . . . . . . . . . . . . . . . . . 250
Turning Drudgery into Games . . . . . . . . . . . . . . . . . . 251
Promoting Your Agenda . . . . . . . . . . . . . . . . . . . . . 252
Becoming a General . . . . . . . . . . . . . . . . . . . . . . . 253
Inspiring Innovation . . . . . . . . . . . . . . . . . . . . . . . . 254
Generating Enthusiasm . . . . . . . . . . . . . . . . . . . . . . 255
Promoting Unity . . . . . . . . . . . . . . . . . . . . . . . . . 257
The Indispensable Programmer . . . . . . . . . . . . . . . . . 258
INDEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Contents
xi


When Chris Duncan first asked me to do the foreword to his book, I didn’t
think it would be that tough to do. How hard could writing a foreword be?
Compared to some of the projects I worked on in the past such as
BoundsChecker, writing a book, or my current job of debugging others’
impossible bugs, writing a foreword should be a piece of cake. However,
within reading a couple of pages of The Career Programmer, I became
extremely nervous because Chris is a far better writer than I can ever hope
to be. The last thing I want to do is detract from great writing, and more
importantly, an extremely important message for the software business.
You’ve probably looked at the back cover or flipped through the pages and
noticed that this book is not what you would expect to find in the computer
books section of the typical bookstore. There are a billion books on how to use
the hot technology du jour and maybe a few on project management, but this
is the first book to directly address the developer and what it takes to get your
real job done. Isn’t it amazing that the software engineering field has been
around this long and this is the first book written for the real engineer? We’d
love to say that we spend our days coding, but we really don’t. Instead, we
spend much of it doing all the other stuff associated with getting our software
released, like sitting in meetings and wondering what planet the marketing
people came from. What you hold in your hands is the stuff you really should
have learned in school.
Unfortunately, those schools you attended are a major reason we’ve got
many of the problems we have in the software business today. I’m willing to
bet most of you have some sort of computer science degree from a four-year
university. Having been in the business a little too long, having a computer
science degree myself, and hiring many of you with computer science degrees,
I can’t think of any worse preparation for a job. Few of your courses did much
of anything to prepare you to develop software. Don’t get me started on the
fact that fewer than 1% of schools offer you a class in debugging! With more
than 50% of your average project time spent debugging, you were completely
cheated by the school and should ask for your money back. Although it’s hard
xiii
Foreword

to duplicate a real-world environment in school, the schools also failed you in
discussing how to prepare and plan for a project. Yes, most of you took some
form of software engineering class, but that class was the ivory tower version.
For those of you who were smart enough to get into this field without the
time-wasting pit stop in a computer science program, you’re slightly better off.
However, with many of you coming into software from professions or fields
with more common sense, you have to wonder what perverse universe soft-
ware development comes from. A mechanical engineer would never be told
that he needs to change a load-bearing bracket on the fly without being given
the time to do the calculations to see if the change would still support the
engine’s weight. A software engineer, on the other hand, is told on a Wednesday
to change a major part of the internal product architecture and have it done
by Friday. Too many people, including software engineers, think of software
products as simply a collection of text files you can play with like Play-Doh.
Fortunately, The Career Programmer is the School of Hard Knocks in the
realities of corporate development. The lessons Chris imparts in this book took
years to learn and will truly save your skin on your current and future projects.
Pay special attention to Chapter 5 (“Getting Your Requirements Etched in
Stone”), Chapter 6 (“Effective Design Under Fire”), and Chapter 7 (“Practical
Estimating Techniques”). These are the areas in which you as even the lowliest
developer on the team can make an impact. There are years of extremely
hard-earned experience in those chapters, and the good news is that Chris
will save you years of pain learning those lessons.
One thing I do want to address a little bit in this foreword is attitude. As
you read this book, you’re going to get quite excited about the real-world tech-
niques that Chris lays out. However, some of you are going to get depressed
because you feel that you don’t have near enough clout to get these techniques
implemented. I can’t begin to tell you how many times I have heard this lament.
No matter what happens, you are the one in control of your own destiny—not
your boss, not the boss’s potted plants, and not your coworkers. (The latter two
might be one in the same). It’s absolutely up to you to make the difference in
your job. Start by worrying about getting your own small piece of the pie done
and lead the way. Leading by example is the best way to show that the tech-
niques in this book work and make your job fun and interesting. If your com-
pany is not interested in doing software the right way, even after you show how
it’s done, it’s time for you to find another job. Yes, plenty of companies out
there are doing it right, and they are looking for you.
xiv
Foreword

My big hope for this business is that you all get to feel what it’s like to hit a
home run and ship on time with high quality. I’ve been fortunate enough to do
it more than most developers, and it’s a truly wonderful feeling. The neat thing
is that, once you ship on time, you can get away with anything at work. You
could burn down the office with a wild party, and, if you shipped on time, the
senior management would just say, “Oh, those crazy engineers!” Armed with
Chris’s book, you’ll have a huge head start on the real techniques to hitting
your own home runs. 
John Robbins
Cofounder Wintellect (www.Wintellect.com)
Author of Debugging Applications
Foreword
xv


The founder of Practical Strategy Consulting,
author and speaker Christopher Duncan spe-
cializes in strategies based on human nature,
one of the few constants in the business world.
He has been a frequent guest on radio shows
across the country, his books and columns have
been read by hundreds of thousands world-
wide, and he is widely acclaimed for his prac-
tical approach to overcoming the common
obstacles of office politics and self-interest.
This keen insight does not come by acci-
dent. Christopher has an unusually diverse
background, which includes a career in sales
consulting, life as a professional musician, and fighting deadlines as a cubicle-
dwelling software developer. He has also performed mind-numbing factory
work, labored on construction sites, and built components for guided missiles.
He understands the problems and goals of the business world, from the lowest
paid workers to the executive elite, because he has been there himself and
lived to tell the tale.
Christopher speaks and conducts seminars nationwide on IT, career, and
business strategies. In addition to his realistic approach to everyday problems,
he believes in having a little fun in the process. Whether he’s talking about the
job-related anxieties of the night watchman’s attack Chihuahua or explaining
the relationship between bunny slippers and corporate productivity, he contin-
ually reinforces the message that we’re all at our very best when we enjoy what
we do. He can be reached at www.PracticalStrategyConsulting.com.
xvii
About the Author


Many moons ago, Tom Archer, a friend and author who at the time was also
running the popular developer Web site CodeGuru, approached me about
writing a column for the site. He already had a number of columns by some
of the top names in Windows programming who were writing about specific
technologies. My task was to instead pen a series of articles about the insani-
ties of Corporate America, the corporate world, and the things we program-
mers grapple with on a daily basis just to get a release out the door. In short,
he said, he wanted to add some attitude to the site. It’s not often that someone
offers to pay you to be a wise guy and a troublemaker. Who could refuse? 
In writing that column, “Programming in the Real World,” I received a
stream of emails from programmers the world over who told me they felt as
though I was looking over their cubicle walls. It seems I’m not the only one
who has needed to deal with arbitrary deadlines, inept management, corporate
politics, and all the other ridiculous situations I’ve found myself in as a profes-
sional developer. This book was directly inspired by all of you who encouraged
me to expand upon the things I’ve learned about navigating the corporate
world of software development. I’m grateful for the conversations and for the
stories you’ve told. I hope this helps you avoid some of the disasters I’ve seen
in my own travels.
If it weren’t for Tom and his faith in my writing, however, I never would
have taken a swing at either the column or The Career Programmer. The
bookstore shelves are full of programming books, but they’re all about specific
technologies and writing code. I’ve learned from experience that coding is
only a very small part of what we have to do to successfully make a living in
this business. Still, I never would have taken a shot at writing something as off
the wall as this without his encouragement and support. Thanks, man. The
next pizza is on me. Yeah, yeah, I know, extra pepperoni. (It’s good to have old
friends who share your taste in pizza.)
When I mentioned that I was thinking about writing a book, Tom also put
me together with Robert Scoble of Thunder Lizard Productions (you just
gotta love a name like that), who in turn introduced me to Dan Appleman
xix
Acknowledgments

here at Apress. Robert, if you hadn’t done that, heaven only knows how long
I would have flailed around trying to figure out how to publish a book. Your
kindness made a real difference, and I truly appreciate it.
The truth of the matter is that I was going to chicken out and just ask Dan
if he had a language book of some sort that I could write. However, when I
was referring to “Programming in the Real World,” I described it to him as
“guerilla tactics for an imperfect world.” He responded that it sounded like a
great title for a book and told me if I had something along those lines in mind,
he’d rather hear about that first. If you’ve read many books on programming,
you know that there’s a pretty consistent format for tech publications. Most
publishers do their best to stick with the status quo and color within the lines.
I sincerely believe that the programmers of the world would benefit tremen-
dously if there were more people like Dan who were willing to take a chance
on something a little different. And believe me, folks, this book is so far from
the mainstream it can’t even swim. I figured about the time he reviewed the
chapter introducing the night watchman’s attack Chihuahua I’d get a very
polite rejection letter, but not this guy. He has been incredibly supportive
throughout the process, and is just a great person in general.
One of the people writing columns for CodeGuru at that time was debug-
ging guru John Robbins, best known for his “Bugslayer” column and recent
book Debugging Applications. We had exchanged a couple of emails in the
course of things, and I liked his sense of humor. He’s also an extremely capable
techie. When I started work on this book, I asked him if he’d be willing to
write the foreword. Given the workload this guy maintains (don’t even ask
about the frequent-flyer miles), I didn’t expect that he’d have time to fool
with it, but I figured it couldn’t hurt to ask. I’m glad I did, as it has given me
a chance to get to know him a little better. He’s even more fun on the phone,
but I’m certainly not going to tease him too much about it. He was a Green
Beret before he started squashing bugs for a living. If that’s not the perfect
training for life as a professional programmer, I’ve never seen it. I personally
believe that, if we all had that kind of background, management wouldn’t try
to pull even half of the stunts that I’ve seen. In any event, thanks for taking
the time for this, John. Forget the pizza. Green Berets get beer.
My sincere thanks to you all. May your ankles never know the wrath of
small, hairless canines.
xx
Acknowledgments

I’ve paid the bills for close to two decades as a working class programmer,
with the last ten years of the journey being spent as a mercenary. For the
uninitiated, that’s a contract programmer, and it means that I’ve seen a lot of
shops. Over the years, I’ve learned some tricks to help take control of my pro-
gramming life again, including how to further my career in general. (I do like
to eat well.) For a long time now, I’ve been working exactly the kinds of jobs
that I like, doing the techie stuff that I enjoy, concentrating on the coding,
and actually delivering on schedule, not to mention getting paid well in the
process.
However, anyone who has been in the business for more than a few years
knows that the recent changes we’ve witnessed in our industry have little to do
with coding. I sat down to write the first sentence of this book’s first edition in
September of 2001. In the days and years that followed, I’ve watched in dis-
may as the IT community has been turned upside down and shaken like a
chew toy for a small, hairless canine. It’s not an experience I can recommend,
but, of course, chew toys around the world could have told me that long ago.
It seems that the biggest issues we face today are all career related. For
many, what we have to cope with on the job is a secondary consideration to
getting a job in the first place. As more and more software development proj-
ects began to revolve around the Internet, bean counters realized that they
didn’t have to hire programmers who live in the same city, and thus the new
trend of global outsourcing gained a firm foothold in our reality. Salaries and
rates for local programmers began to plummet as they were compared not to
competitive local rates, but to a global market where the cost of living and
strength of the hiring company’s currency vary wildly. Because of this, there
are now programmers working on high-profile software projects in other coun-
tries who make less than the local fry cook gets for flipping burgers. Really—
I’ve seen the numbers. What makes this a complicated scenario is that in some
countries, that’s extremely good money. Welcome to the new global age of
programming.
xxi
Introduction

Bean counters aren’t the only ones who have rocked our world with a large
and heavy rock. The dot-com gold rush also came to an end, as overvalued
stock prices and Internet companies with no business plan other than raising
venture capital and going public all came crashing down. The stock market
took a beating, and economies the world over felt the effect. This affected
the working-class programmer in a couple of ways, neither of them pleasant.
Suffering massive loss of capital from the bubble that used to be the tech stock
market, companies the world over began tightening their budgets in many
directions. The reining in of software projects not only decreased the number
of new jobs out there, but many companies proceeded to eliminate large
quantities of programmers whose projects no longer existed. During the hey-
day of the dot-com era, we would have just shrugged our shoulders and started
our own Internet software company. However, venture capitalists now con-
sider investing in Internet startup companies to be only slightly less risky than
putting their money down on the blackjack tables in Vegas. The end result?
Fewer jobs and less support to go it alone.
Societies are usually slow to catch up to prevailing conditions and trends,
and the same is true with career paths. If conditions in the job market weren’t
bad enough from jobs going to other countries or just disappearing altogether,
yet another factor made it increasingly difficult to pay the bills writing cool
software. Hundreds of thousands, perhaps even millions of people worldwide
continued to gear up for programming careers, flooding the job market with
more and more competition. Although this fascination with software careers
eventually began to wane in response to lessened opportunity, it nonetheless
made a bad situation worse. All markets revolve around the concept of supply
and demand. We simply had too much supply and far too little demand. The
inevitable result of all these factors also contributed to lower wages, since the
tide shifted from a seller’s market for programming talent to a buyer’s market.
If you don’t find all of this a bit depressing, then you’re a more resilient
creature than most of us. The career path of the average programmer has
taken more serious body blows than you’ll ever see in a heavyweight boxing
championship, and I’ve known a lot of people whose lives were seriously
affected by the change in fortunes. Once upon a time, being a professional
software developer meant that you not only got paid to play, you got paid really
well. In the new millennium, it’s not even a certainty that you’ll get paid at all.
All of these things were fresh in mind when I was asked to write the second
edition of The Career Programmer. I spent most of the first edition showing
people how to cope with the typical insanities of the average software develop-
ment environment so that they could get good code out the door in spite of
dubious management decisions and internal politics. From this perspective,
the level of ridiculous behavior that we encounter on our quest to kick out the
next Killer App hasn’t changed much, and my tactics and suggestions remain
the same.
However, as I considered the situation, I realized that the biggest problem
we now face is not the mismanagement of the average software project. Today,
it’s all about careers: how to get one, how to keep it going, how to get paid
xxii
Introduction

reasonably well for your efforts, and how to avoid losing sleep each night
worrying about when they’ll outsource your project and fire you. Consequently,
I decided that it was time to really put the career into The Career Programmer.
There are almost no changes at all to the original chapters. Instead, I’ve added
a third part to address what I believe to be the most important issue of our
day: Building a Better Career.
This new part focuses on what I feel are the most critical concerns for
those of us who depend on our love of coding to pay for our homes, meals,
and, of course, the latest compiler upgrades. First, we’ll take a look at life as
the unemployed programmer sees it. When you’re out of work but the bills
keep coming in, nothing takes a higher priority than landing your next job.
However, just as I continually point out when it comes to the development
process, the average techie also suffers from tunnel vision when looking for a
new gig. Because we love working on computers, we tend to think that techni-
cal skills are all that matter. Having been on both sides of the hiring equation
myself, as well as hearing countless stories from friends who also do the hiring,
I could tell you stories that you would swear I was making up, from laughable
résumés to unbelievable job interview performances and more. So, after cov-
ering career options in the first chapter, the second chapter of the new section
will take a close look at all the dos and don’ts, some obvious and some not so
obvious, when it comes to rising above the herd and getting hired.
As I worked on these issues, I also realized that there was another perspec-
tive that many of you now share. If you’ve been doing this for a number of
years, you may very well experience a couple of significant events. First, as
unthinkable as this may seem, you might just be getting burnt out on coding,
perhaps with a feeling of “it’s all been done before,” or just that glazed over
feeling you get when you have to write the same database-driven app for the
hundredth time. However, even if after all the years, you still love coding,
there’s another wall you’re about to hit whether you like it or not: age discrimi-
nation. Nobody really wants to talk about it, but it’s there. It also works in both
directions. The old guys take advantage of the young guys, paying them as lit-
tle as possible until they wise up, and keeping all of the power to themselves.
Once you start becoming an old guy yourself, though, you soon realize that
companies want to hire young programmers, not older ones, for a variety of
reasons. Consequently, the next chapter looks into some of your options that
allow you to stay in tech but shift into positions where you’re not at a hiring
disadvantage. Not written for just the old guys, this chapter covers practical
considerations for anyone who realizes that slinging code might not be the
most secure method of paying the bills.
Of course, for many of you, the solution to your problems may well be to
start up your own software company and go it alone. Although it’s true that
after the dot-com crash, there’s not much enthusiasm among venture capital-
ists for investing in tech startups, that’s not really the path most of us take. To a
great many programmers, the Holy Grail of career options involves starting a
small development shop, perhaps even run out of a back bedroom, giving you
the freedom to truly create that Killer App. And if that’s all there were to it,
Introduction
xxiii

life would be a blast and large corporate IT departments would be ghost
towns. What most developers don’t realize until it’s too late, however, is that if
technical skills are only a portion of what’s required to manage a career work-
ing for someone else, they’re only the tiniest fraction of what it takes to run
your own business. Business, as they say, is business. If you don’t tend to the
basics, there’s nothing in the bank account when it’s time to write a check.
However, running your own software company can certainly be done and you
can make a nice living in the process, provided you pay attention to the things
that are important. With that in mind, we’ll spend a chapter looking at the
realities and requirements for hanging out a shingle and flying solo.
With the exception of running your own company, however, it doesn’t
matter what kind of a job you land. Life just isn’t as certain in our industry as
it once was, and job security is little more than a myth from another era,
foisted upon the naïve by recruiters, human resources professionals, and hir-
ing managers. Repeat after me—no job is 100% secure. Whether you work for
a large company or a small mom-and-pop shop, you could find yourself out on
the streets tomorrow for a host of reasons that most programmers never see
coming. If you want security, you have to create it yourself. 
The bad news for software developers is that some of the most fundamen-
tal aspects of creating your own security revolve around people skills, political
acumen, and all those other “soft skills” that most techies look down on. Like
it or not, however, when you’re on the job, you’re surrounded by people, and
human nature is one of the few constants in our experience. Because of this,
we’ll spend some time in the last chapter looking at the many different ways
that you can make yourself an indispensable part of the company and let the
other guy be the one who gets fired. And you’ll be surprised how little coding
knowledge has to do with becoming indispensable.
When you’ve finished with the last page, it’s my sincere hope that you’ll
be much better armed when coping with the volatile and difficult industry in
which we live. I’d like nothing more than for you to be able to spend your days
thinking exclusively about that cool bit of code that you’re currently crafting.
The best way I can think of to accomplish this is to help you build a better
career. No one does their best work when they’re worried about paying the
bills. And in our business, doing your best work is the fun part. 
I hope these observations, tips, and techniques will help you take your
professional career to new heights, and as always, I’d love to hear from
you. Drop by anytime and leave me a note at my consulting Web site,
www.PracticalStrategyConsulting.com. Helping companies and careers is no
longer just a passion for me—it’s what I do for a living. I hope this new edition
of The Career Programmer helps you achieve new heights in the career that is
your passion. 
xxiv
Introduction

From the First Edition
If you picked up this particular book, it’s likely that you either make a living
as a programmer or plan to do so in the future. Of course, you could just be
shopping for something that’s precisely the right thickness to prop up your
rickety coffee table, but we’ll play the odds for the moment and assume that
you spend more time in front of a debugger than you do a television.
The first questions we typically have when looking for technical books
relate to platform and language. What kind of computer? What flavor of oper-
ating system? Which particular set of languages and technologies must we
know to benefit from this book? For The Career Programmer, it just doesn’t
matter. Whether we make our living under the flag of Mac or Microsoft, main-
frame or mini, our ultimate goals and desires are the same: all we really want
to do is make good money, spend our days writing the next Killer App, and get
our pizza delivered in thirty minutes or less.
However, for those who possess the ability to turn screens full of cryptic
statements into state-of-the-art software systems, there’s only one slight com-
plication. In order to get paid for doing what we love, we find ourselves work-
ing deep in the heart of the corporate world. Nothing we were taught in
school prepared us for the illogical, inconsistent, and sometimes downright
silly business practices that are the norm in software development shops both
large and small.
For instance, deadlines are declared in an almost arbitrary fashion, with no
real consideration of what’s involved. We’re expected to produce specific func-
tionality from vague and ever-changing requirements. We’re given little to no
time for proper analysis and design, and, when we ask management about
hiring professional testers and setting up a QA process—well, I’ve seen deer
in my headlights look less stunned. Internal politics are rampant, threatening
everything from our current project to our staplers, which for some bizarre
reason seem to be a precious commodity in the cubicle world. In short, from
a software developer’s point of view, the environment makes no sense.
Unfortunately, no matter how unrealistic the deadline, we’re expected to work
day and night to make it happen, only to have the product shipped with less
than fifteen minutes of testing. Care to guess who’s going to get yelled at the
first time it blows up in the field? I can assure you, the deer have leapt safely
out of the glare of the headlights and there’s nobody here but us programmers.
Anyone who hasn’t worked in our field will by now have labeled me quite
the cynic, but I suspect you were shaking your head while reading the last
paragraph and remembering the insanities of your own company’s releases. As
passionately as we want to do good work, it seems that we’re checked at every
turn by corporate bureaucracy and management that can barely spell the word
computer, let alone manage a software development process. Of course, we
learn all of this the hard way. All of the books on the bookstore shelves teach
us how to program, not how to fend off the lunacy of the business world so
that we can actually program and deliver excellence.
Introduction
xxv

Much of what I know as a programmer I’ve learned from other guys who
were nice enough to share their experience, and so this is my way of giving a
little back. No matter where you fit into your project, you can learn some
tricks from this book to help simplify your life and get you back to concentrat-
ing on the code. That’s the best thing I can think of to give to a programmer.
Assumptions About the Reader
I assume that you already know how to program and that you either currently
make your living programming in the business world or soon will be. The plat-
form or language you work with doesn’t matter. This is a book about overcom-
ing the obstacles we encounter as programmers in the real world, and these
obstacles are the same, regardless of what type of software you write. It proba-
bly goes without saying, but I also assume that you rail against any and all limi-
tations that you encounter on the job and that you find anything that interferes
with your ability to deliver high-quality software extremely frustrating. That’s
where I hope to help.
Who Should Read This
The issues addressed here affect developers at all levels. If you work as a
project manager or team lead, you’re already a veteran of many battles with
management and are always looking for new ways to talk sense into these guys.
If you’re a front-line programmer, you’re the one who ultimately has to pay the
price for bad decisions further up the food chain, whether it’s from the Suits in
the front office or your own project manager. The tactics and techniques work
at both levels. If you’re not happy with the way things are run, and want to
change your job so that you can focus more on software development and less
on damage control from dubious decisions, this book is for you.
A Note to Women Who Code
Not everyone who stays up for three straight nights chasing a bug is male.
Many women also make a living as professional developers. When the fingers
hit the keyboard, it doesn’t matter if the nails are polished or not. The com-
piler doesn’t care and neither do I; good code is good code and none of the
topics I cover are gender-specific. However, the English language simply does
not have an easy way to address both genders in a conversational manner.
While I applaud the sincere intentions of those who insert a “his/her” or
xxvi
Introduction

“he/she” into everything they write out of consideration for equality, in prac-
tice, it can make the text a bit tedious to read.
I’m no Nobel laureate. I’m just a programmer, and I write like I talk.
Although the issues we’ll cover are serious ones, my priority is to keep this a
light, conversational, and easy read. I’m more interested in helping people
overcome the many obstacles to good software that the corporate world con-
tinually throws our way than I am in being considered a scholarly author.
Therefore, to keep it simple, I made a conscious decision to speak to a single
gender for the sheer literary convenience of doing so. Because the program-
ming community is overwhelmingly populated by the male of the species,
you’ll see references to “he” and “him,” rather than an attempt to speak to
both genders in every sentence. If this is perceived as a lack of political cor-
rectness, I hope that the easier flow of words and the matters upon which they
touch will compensate. This is a book for programmers. The specifications of
your particular body are irrelevant.
What’s Not Addressed
This is not a language or technology book. No matter what programming
technique you want to master, plenty of books are available to teach you. This
book is about overcoming the obstacles you face on the job that ultimately
result in release disasters, stressed-out development experiences, software
death marches, and bad software that could have been good. It’s not a treatise
from the ivory tower of academia. It’s a field manual for the software devel-
oper grunts who relentlessly toil away in the thick of it, day after day.
What This Book Brings to the Party
If you worked in a perfect world, you’d have plenty of time for gathering
requirements, for analysis and design, and for implementation and testing.
You’d also be in charge of what went into the product, the overall design, and
which technologies were used, and you’d release it when you were darned
well ready. Management would not interfere, and you wouldn’t have to con-
tend with any office politics. Everyone would listen and do things exactly
as you suggested. Small, furry creatures from Alpha Centauri would be, well,
you know.
If you live in such a world, go ahead and use this book for that wobbly
coffee table. Oh, yeah, and save me a seat. I’d love to have a job there.
For the rest of us, this book is a collection of very simple and practical
observations and techniques for putting us in as much control of the develop-
ment process as the real world is going to allow. A number of hurdles must be
Introduction
xxvii

cleared when shipping a good product, and some of these can be handled by
modifying the approach we take to design, estimating, and other matters of
process.
Other issues result from bureaucracy and politics. No design methodology
in the world is going to help you there. The higher-ups tend to ignore the
opinions of programmers partly because we’ve never learned to speak their
language or communicate in a way that is meaningful to them. Consequently,
our thoughts and suggestions—the very things that could save our projects
from disaster—are ignored even though we’re the specialists. Before we can
show them how we’d like to do things, we must first acquire the skills neces-
sary to make them hear us. In short, we need to learn how to manage our
management so that we can get back to doing the job that we love.
You don’t need an MBA to figure this stuff out. You just need to pay atten-
tion to how things work and modify your approach to one that is realistic and
effective in your environment. The bottom line is simple: whether we agree
or disagree, more often than not, we’re simply told to get the job done in the
time we’re given, or else. Consequently, the approaches that work when we
have the luxury of time fail utterly when we have the ability to implement only
a quarter of the process. In such moments, we need simple and practical
approaches that get the product delivered.
In the chapters that follow, I’ll be addressing these issues with the assump-
tion that you don’t have time for the perfect solution. That’s why I refer to
them as guerilla tactics. They’re direct and effective, and they’re not always
pretty. These tricks are all taken from real jobs with real pressures. When you
have to deliver, or else, neatness just doesn’t count. Getting the job done is all
that matters.
A Quick Peek at the Chapters
Here’s a look at the rest of the book. Part 1 explains the problems prevalent in
our jobs, and Part 2 speaks to the issues and their solutions. Part 3 addresses
the new challenges facing those of us who make a living in the programming
arena.
Software Development in an Imperfect World
Part 1 consists of three chapters that introduce the realities of programming in
the corporate world:
xxviii
Introduction

Welcome to the Corporate World: After landing their first job, many
programmers are shocked by the reality of life in the corporate world. Your
initial dream of sitting undisturbed each day, kicking out clever little apps,
is continually disturbed by unrealistic deadlines, unreasonable decisions,
bureaucracy, politics, and crisis after crisis. Any of these could reduce your
current software project to a pile of smoking rubble reminiscent of the
latest Godzilla movie. They don’t teach this sort of thing in school, and
even seasoned developers have difficulty knowing how to cope with
elements that seem beyond their control.
Business Is War. Meet the Enemy: To successfully deliver the next killer
app, you must fight many battles, the easiest of which is with your
debugger. Whether you’re a systems architect, project manager, team lead,
or full-time coder, your ability to do your job and enjoy your pizza without
indigestion is going to be continually assaulted by a host of business-
induced problems. The first step in building up your defenses is simply
knowing your enemy. Consequently, this chapter will highlight the
problems that most software development teams commonly encounter.
Good Coding Skills Are Not Enough: In gazing at the enemy, it’s tempting
for many programmers to simply shrug off management problems as not
being a part of a programmer’s job description. However, this will be of
little consolation to you when you’re plucking the arrows out of your
posterior. Software development is a team endeavor. If you don’t work at
your level to help combat the problems that threaten your project, you’ll
all go down together. If you don’t do anything but code, here’s why you still
need additional skills to survive.
Guerilla Tactics for Front-Line Programmers
Part 2 includes eight chapters dedicated to helping you survive the real world
described in the first three chapters. Here’s a rundown:
Preventing Arbitrary Deadlines: It’s three o’clock in the morning, your
system just crashed again, your debugger shrugs its shoulders and asks for
a coffee break, your eyes are so bloodshot that they look like a road map
of midtown Manhattan, and the product must ship tomorrow if you wish
to continue your employment. How did you get into this mess? At this
point, there’s not much you can do about it beyond persistence, excessive
caffeine consumption, and simply hoping for a lucky break. The time to
prevent this disaster was much earlier in the game. Where’s a good time
machine when you need one?
Introduction
xxix

Getting Your Requirements Etched in Stone: “Scope creep” is not the title
of a bad science-fiction movie involving mutant gunsights from outer
space; rather, it’s one of the foremost reasons that software projects are not
delivered on time and within budget. If your features seem to continually
evolve as the project progresses, or you find yourself trying to provide well-
defined functionality from vague specifications, here’s how to nail your
requirements down firmly, right at the beginning. If they wiggle, use
another nail.
Effective Design Under Fire: The only problem with many design
methodologies is that it takes a significant time investment to work through
the entire process. Unfortunately, out here on the front lines, we typically
have a hard time convincing management that we need a little time away
from the compiler for sleep, let alone for months and months of abstract
drawings that they don’t understand. Consequently, at such times, we must
break the rules and roll our own design approach, using the best of all that
we’ve encountered in the time we’re given to work with. It ain’t pretty, but
it works.
Practical Estimating Techniques: Arguably the hardest thing to do in our
business (beyond finding pizza toppings that everyone agrees on) is
producing an accurate time estimate for any nontrivial amount of code.
Furthermore, many unrealistic deadlines arise due to overlooking tasks
other than coding that also eat up chunks of time. In the end, if the
estimates aren’t real, it’s the programmers who pay the price at deadline
time. Here’s a simple approach to help ensure that your next timeline is
an achievable one.
Fighting for Quality Assurance: No programmer worth his weight in
cappuccino ever wants to ship a buggy product. It’s bad for the ego, bad
for the résumé, and bad on the nerves when your telephone rings in the
middle of the night. Amazingly, however, the overwhelming majority of
businesses who develop software do not hire quality-assurance professionals
or otherwise institute any sort of rigorous software-testing procedures.
This calls for a combination of fighting for change and exercising self-
defense wherever possible.
Keeping the Project Under Control: Keeping a software development team
running like a well-oiled machine takes work from people at every level.
Code standards, version control, technical documentation, organization,
discipline, and good communications are but a few of the skills required
to keep a project on track. It matters little that you’ve prevailed in your
political battles if your project simply implodes due to poor structural
integrity. From programmer to project manager, here’s how to keep things
running smoothly.
xxx
Introduction

Managing Your Management: If management is to have realistic
expectations and a firm foundation upon which they can plan their
business strategies, a little retraining is in order. If it were true that those
higher up the corporate food chain were immune to the concerns of rank-
and-file programmers, the battle would be lost before it began. However,
what we’re dealing with here is not an abstract concept but is instead real,
flesh-and-blood people. Consequently, they can be convinced, directed,
inspired, and motivated to do the right things. You simply need to speak a
language that they understand. And, of course, let them think that it was
their idea all along. 
Corporate Self-Defense: In companies large and small, internal politics can
be the most frustrating and disruptive force that you encounter. People
with agendas that are quite different from your own can disrupt, take over,
or even completely destroy your project. Many programmers have neither
the skill nor the desire to engage in political games; however, just as in the
martial arts, many methods of self-defense are available that require little
more than attention and redirection—and knowing when to duck. The
alternative is to become a professional target.
Building a Better Career
Part 3 contains five chapters about finding and keeping a job:
Controlling Your Destiny: No matter how permanent you’ve been told
your position is, software developers have about as much job security as a
drummer in Spinal Tap. Whether you move to different projects at the
same job, change companies as a contractor, or hang out a shingle and go
into business yourself, there are no guarantees. If you want to keep paying
the rent by making the compiler dance, it’s up to you to look after your
career. No one else will. This means keeping yourself marketable, knowing
how to negotiate, and always staying prepared by looking to the future.
Get a Job (Sha na na na. . .): It’s a new world out there for those of us who
love to make the compiler dance. Between events of the past few years and
growing trends that aren’t going away, getting a job isn’t as easy as it used
to be, no matter how good you are with a keyboard and a mouse. Whether
you’re looking for a position as a salaried employee or you prefer the
hourly rate of the contract programmer, good coding skills just aren’t
enough. If you’re looking to land a new job in today’s market, you’re going
to have to become an expert at making yourself stand out in the herd.
Introduction
xxxi

Career 2.0: Most of us program for a living because we enjoy it. However,
it’s also been a career path that has paid well. Although there may still
be fun in the development aspect of the business, in many cases, the
monetary compensation has significantly diminished, in addition to the
problem of coding jobs being harder to land than they once were. If you
enjoy your current standard of living and are open to new career options,
the best choice may well be to step away from the keyboard and transition
into a new career in a different area of the business. 
Flying Solo: For many developers, owning their own software company is
a dream come true. However, if all you want to do is code, it’s the wrong
choice. To be successful as an entrepreneur in the software industry, you
need many of the same skills that every other business requires, and none
of them are technical. The most important thing to realize when going it
alone is that the first priority of running a business is to make a profit.
Without that, you’re soon out of business and looking for a job again.
Fortunately, these are all skills that any intelligent programmer can master
with the proper effort.
Job Security: Whether you’re looking for a new job or you already have
one, the idea of your company promising you a secure job is a concept long
dead in our industry. Furthermore, it’s simply not enough to make yourself
indispensable from a technical point of view, as there are too many others
in the world who can do the job just as well as you can. If you truly want
to secure your position in your company and sleep well at night with the
thought of having a job there as long as you like, you’ll need to master
some fundamental people skills that few of your competitors ever address.
It’s not as fun as coding, but it gives you a great deal more power to keep
your job and make a difference on your projects.
xxxii
Introduction

SOFTWARE
DEVELOPMENT IN AN
IMPERFECT WORLD
I
P
A
R
T


You’re typing so fast that the keys of your keyboard would threaten to go on
strike if only enough of them were visible to form a good union. Aside from
the racket of the keys under your fingertips and the continual stream of
enhancement requests from management, your office is a fortress of solitude
where none dare disturb your rapid-fire coding sessions. Your days are a
delight and a blur as you experiment to your heart’s content with state-of-the-
art technology, rarely taking a break from your creations for even a fresh cup
of coffee. Suddenly, you feel an uncomfortable sensation on your forehead and
realize, as you peel your head from the keyboard that has been serving as your
pillow that you’ve been dreaming again. It’s two o’clock in the morning, you
haven’t slept three hours in as many days, the deadline for your release is mere
hours away, and your software is about as stable as the maintenance program-
mer who had to deal with the previous release. A marketing rep drops by after
his latest three-martini lunch with your clients and adds yet another do-or-die
feature to the stack on your desk. At least he got some extra use out of his
cocktail napkins. Now, recovered from your pleasant dream, you shake your
head and gaze bleary-eyed over the sea of cubicles to survey your home away
from home, deep in the heart of the corporate world. Welcome to reality. We
hope you enjoy your stay.
So You Thought You’d Just Be
Coding All Day, Eh?
It matters little if you spent years in college training for a career in software
development or simply stayed up night after night with a PC, a compiler, and a
language tutorial until you could write a complete piece of software that out-
put more than just “Hello, World.” You studied, you coded, and you made the
grade. You’re a programmer now. Very few people in life are fortunate enough
3
Welcome to the
Corporate World
1
C
H
A
P
T
E
R

to pursue their passion for a living. Right up there with professional athletes
and rock stars, you’ve devoted your life to a hobby that became a source of
income, and a pretty decent source at that.
For most of us, the early days of programming were heady days indeed.
Regardless of the hardware, operating system, or language, all software devel-
opers share a common joy: that thrill of transforming lines of incomprehensible
text into high-powered databases, sizzling graphics, and earthshaking audio. In
our world, we get a special kind of delight in the instant gratification of turning
our thoughts into code that then magically instructs a machine to do exactly as
we please with just the quick rumblings of a compiler pass. Unlike architects
who dream but must wait years to see the resulting building, programming
is the closest thing to magic to be found in a day and age when Merlin the
Wizard would probably be sent home for violating the company dress code.
In fact, a life of getting paid to play was the siren song to which we all suc-
cumbed, lured by the promise of a life of creativity and intellectual challenge
into a world where excellence was the common goal and faster ponies always
won the race. Although I’m sure many people went to school and learned to
become programmers because they reasoned that it was a good way to make a
living, I have personally never met them. I understand that they’re prone to
jumping out the nearest window after about the third release. The pressures
of our industry are extreme. Without a love of the art to carry you through, it
can be a harrying experience for even the stoutest heart. Fortunately, the only
windows that actually open in most development shops are located on the
first floor, for probably just this reason. No, rather than a cold and calculated
career path based on salaries, promotions, and longevity, we got into this busi-
ness for a very understandable motive. People do all sorts of unreasonable
things in the midst of a love affair, and we simply love coding.
If the early days of learning to program were intoxicating, they were bal-
anced by the experience of finding the first job. The software business is no
different from any other when it comes to hiring. It’s a classic catch-22: you
can’t get a job without experience, and you can’t get experience without a job.
Nonetheless, we scratched, clawed, and wrote résumés that would be the
envy of any best-selling novelist, and we managed to obtain that Holy Grail
of techies everywhere: a full-time job writing software. However, no college
course could ever adequately prepare a new programmer for what comes next.
Just as a teenager with a new electric guitar has visions of becoming an
overnight success, selling millions of records and playing to packed houses full
of screaming fans, most beginning developers anticipate arriving at their new
job Monday morning and being given an office, a computer, and a list of pro-
grams to write. What could be better? Well, perhaps a cup of Jamaican coffee,
but any form of caffeine will do in a pinch. However, as every veteran of our
business knows by now, if you’re spending even 75% of your day actually cod-
ing, you’re way ahead of the game. Much of the day is consumed in meetings
of one form or another. When that fails to be a sufficient deterrent to produc-
tivity, the corporate world has plenty of other weapons in its arsenal: bureau-
cracy, politics, marketing, clueless management, general confusion, and a host
4
Part I Software Development in an Imperfect World

of other little distractions. One notable engineer has actually left the field to
make his fortune drawing cartoons that illustrate some extremely fanciful and
imaginative scenarios in the business world. No one who has ever lived in the
cubicle maze of the software development industry believes it to be fiction.
So, just as quickly as our new hire was sucked into the endless hours of
typing and compiling for the sheer pleasure of it, he now more closely resem-
bles the shell-shocked inhabitants of a recently invaded city. Gone are the
distraction-free days of coding, the dreams of state-of-the-art software, and
even a decent night’s sleep for that matter, although few programmers get
much of that sort of thing even on a good day. Instead, it’s a life that more
closely resembles a small domestic rodent running in circles on a treadmill
inside his cage. The end result of all the bureaucracy, mission statements, and
crisis-driven management is a development cycle awash in vague definition of
requirements, last-minute feature requests, buggy releases, and mandatory
overtime—unpaid, of course.
Okay, a quick show of hands here. How many in the audience have already
branded me a jaded cynic who has a dismal and unrealistic view of the soft-
ware development industry? Do I see a few hands in the back? Good. It’s
always nice to know where the new hires are sitting. The seasoned developers
are either grinding their teeth or nodding with a grim acceptance of the nature
of the beast. Perhaps both. The reality of the matter, whether we like it or not,
is that, to pay the bills doing what we love, we must step into the business
world, for that’s where the money is. No money, no new toys. For that matter,
no house to put them in. Landlords are funny that way.
Actually, it tends to take a few years for all of this to sink in. In the begin-
ning, it’s just so cool to have a job where we effectively get paid to play with
our favorite toys that we tend to overlook a lot of this stuff. It’s also not until
you change jobs a few times that you begin to realize that it wasn’t just one
screwy company that was like this, it’s an entire industry. It’s long about then
that frustration really starts to develop, and such feelings always manage to
find an outlet in one form or another. That can be a dangerous time to be in a
design meeting with a lot of whiteboard erasers lying about. Those suckers can
really sting when you put a little velocity behind them.
What’s a Nice Programmer Like Me. . .
Of course, the only reason that frustration arises in the first place is due to the
nature of the typical techie. We truly care about the quality and content of our
work. We are artists, idealists, and inspired creators. We are also quite logical.
None of this really meshes very well with the typical corporate environment in
which more time is spent on political maneuvering and career enhancement
than in actually producing something valuable. Nonetheless, such is our real-
ity. So how did we get here, unwilling partners in an unlikely marriage
Chapter 1 Welcome to the Corporate World
5

between artist and businessman? How is it that our environment not only tol-
erates both types but seems to require them?
Well, it’s easy enough to understand how we got here. We like to program,
and we like to get paid, if for no other reason than to afford the next complier
upgrade. Given our preferences, we would live in a world where technical
excellence was the only thing that mattered. We certainly have little patience
for stuffed suits or anyone else with limited technical understanding. If we
get paid for writing software, though, there must be a reason. Furthermore,
although it may boggle the imagination, the Suits find us just as incomprehen-
sible as we find them. From their perspective, we are a class of creature that
doesn’t seem to understand the way that the world really works. Besides, we
talk funny. And yet, they pay us reasonably well to come in to work each week,
no matter how peculiar our mannerisms. Why?
Why People Run Businesses and
Pay Programmers
To grasp how the corporate world came to be populated by such different
classes of creatures, we must first understand why people run businesses in
the first place. If we take it as a given that the prevailing population of the
typical software development shop didn’t come about by a freak accident
between Noah’s ark and an oversized pocket calculator, then there must be
an overriding purpose at play. Actually, it’s not that difficult to understand:
it’s all about the money, the fundamental reason that people start businesses
in the first place.
No matter what other motivations people may have in terms of their prod-
ucts or services and the impact they might make on our society, unless it’s a
nonprofit organization, you can bet that the very first consideration will be
making money. What they actually sell is a secondary matter. In fact, many
businesses start out in the planning stages with a financial model and explore
a number of products until they find one that matches their market and fiscal
expectations.
This is where the typical programmer gets into strange and treacherous
waters. In the business world, software is simply a product. It is not high art.
It is not a religion. It is just something to give to customers so that they’ll part
with their money. Keep chanting that until you can at least wipe that incredu-
lous look from your face. You’re starting to make the new hires nervous.
Yes, folks, hard as it may be to believe, what we create is simply an inven-
tory item—an excuse to generate an invoice. But what’s that you say? Who
wrote the invoicing program? Well, that brings up the other type of software
that they pay us to create. We either produce a product to sell or we give them
tools to help them sell their products. Either way, the same inescapable logic
applies: our software is simply a means to an end, and that end is to bring in
6
Part I Software Development in an Imperfect World

money. Now I’ve hung out with enough musicians in my life to know what the
next batch of responses will be, for musicians and programmers are kindred
spirits. All of these responses center on how business is destroying art, how
commercialism rips the very soul out of software development, how money is
evil and is the cause of all the grief that assaults us in our day-to-day life on
the job.
Okay, everyone, take a deep breath, and let’s take a good look at this. You
do like to get paid every week or two, don’t you? If not, I have a few projects
I’d like to discuss with you. No scope creep. Honest. In fact, all of the profes-
sional programmers I know get paid, and furthermore depend on that money
a great deal. If you’re a musician and don’t make much on your gigs, then you
get a day job. So what do you do if you’re a programmer and don’t get paid on
your day job? Take up playing music at night? Sure hope you like macaroni
and cheese. The simple fact of the matter is that our lives revolve around
money just as much as a businessman’s does. Businesses hire us to develop
software that’s either sold to make money or supports the effort of making
money. Profit is not a bad thing. Without it, your company—and your job—
ceases to exist.
So, this is why businesspeople hire computer programmers. It’s all about
money. Another important point to keep in mind is that, regardless of the
chaos that they seem to inject into the software development process, the
businesspeople are in charge here, not the programmers. Why is that? The
Golden Rule, of course, and I don’t mean the one about doing unto others; I
mean the one that states “The people with the gold get to make the rules.” It
was a businessperson who conceived of the company; put together a plan to
market a product; and got the financing to rent the building, bring in the com-
ponents to build your spacious cubicle, and provide you with a paycheck. Why
shouldn’t they be in charge? Programmers are usually busy finding neat new
toys to spend money on. We’re not real big on bringing more of it back into
the corporate bank accounts. If it were up to us to run the companies, we’d die
out—abruptly.
So, we easily recognize that two completely different perspectives are at
play in a software development shop: programmers work from a technical and
artistic point of view, and those with a business perspective sustain and drive
the company. Consequently, the two camps speak completely different lan-
guages, which brings up a very important point for those of us who would like
to regain control of the software development process. If you wish to succeed
in your technical endeavors, you must be able to interact with businesspeople
and address their perspective in a language that is meaningful to them. Why
can’t they just learn our language instead? They don’t have to. They have the
money, remember?
Actually, we have much more in common with our brethren in the three-
piece suits than we’d like to admit. Both of us are driven by some of the same
fundamental goals and desires. It may not sound pretty, but a core motivation
for us both is the simple phrase, “What’s in it for me?” For businesspeople,
making money is, in fact, the gig that they signed up for. Those of us who
Chapter 1 Welcome to the Corporate World
7

watch the compiler spin for a living also need money, but that’s not our pas-
sion. Instead, although we may acknowledge the need for financial compensa-
tion, our hearts belong to technology. Much of what we want lies in the realm
of technical and artistic gratification.
This is the point where we should all take a step back and give a little nod
of respect to the Suits. We may not approve of weasel-like marketing tactics or
corporate doublespeak, but, without a doubt, they are people who know how
to get what they want, and far more than we do. To be able to enjoy more of
our day and get what we truly want out of our career, we need to develop the
same degree of skill in achieving our own objectives. Very simply put, if you
ignore the business realities, you just won’t be able to do what you really want
to do. A large part of accomplishing this has to do with two fundamental tasks.
One is recognizing the realities of the business world for what they are rather
than wishing it were otherwise. Having accomplished this, the next logical step
is to improve both our communication and navigation skills, so that we can not
only speak to the Suits in their own language, but manage the conversation
skillfully enough to get what we want out of it.
The Corporate World Is Not Logical
The corporate world is an exercise in the unreasonable, inept, and frequently
just plain unfair. I suppose that the same could be said of life in general from
time to time, but the business world just seems to excel at it. As a case in
point, consider the following.
Early in my career, I worked for a company writing software that was used
at remote sites. People in the field needed the ability to update their systems
with information in the primary company database as it changed. I was tasked
with writing the communications module. This was long before the general
public was aware of the Internet’s existence. Consequently, you might assume
that I would set myself to the task of writing a serial communications subsys-
tem using a dial-up modem. I know that’s certainly what I had in mind.
However, my manager instead informed me that I needed to design and
implement a data transfer module that would allow our program to write the
information to a floppy disk and then read it back at the remote site when
the reps set up their system. After the reps carried the floppies though the
scanners at airport security, of course. Floppies love that sort of thing. If the
people in the field needed subsequent updates, we would simply send an
overnight letter with new floppies. This happened many times a day.
Sure, these were the pre-Internet days when the term high bandwidth
usually referred to someone in marketing who had consumed one cup of cof-
fee too many, but I can assure you that the modems of the day were more than
equal to the task. In fact, I made those same assurances to my manager, with
some degree of enthusiasm. Well, the enthusiasm, to put it politely, was also
mixed with a fairly incredulous posture, as he was a programmer himself and
8
Part I Software Development in an Imperfect World

someone who knew better. I simply couldn’t believe that he’d make such a
preposterous decree. (It wasn’t a suggestion.) Nonetheless, he was a patient
guy, and, because he had hired me as the token extrovert for this outfit, he just
let me get it all out of my system before offering what he saw as a perfectly
understandable explanation. Mind you, he was much more experienced in
these matters than I.
This being a somewhat small outfit with employees numbering fewer than
fifty, the president of the company was a fairly active participant in all aspects
of the operation. Worse still, he had been tested with genius-level IQ, had
many impressive degrees, and consequently approached things with a friendly
but inflexible nature. And he was, after all, in charge. When my manager had
attempted to explain how the dial-up communications system he envisioned
would work (I told you he knew better), the president had immediately
insisted on the aforementioned floppy disk system instead. (We’re talking mul-
tiple floppies here by the way, folks.) No matter what argument my boss used,
the president had a comeback. When the vulnerability of floppy disks was
pointed out, he proposed taking two copies of the disk on the plane instead of
one. Many other such topics were covered, of course, but my favorite was the
obvious: why not just use modems and be done with it? The president of the
company was adamant and explained the reason for his intransigence patiently,
as if to a very young child. It was a matter of dependability: what if the modem
breaks? And, with that, the conversation he had with the head of our team was
declared over and the matter closed. He was, after all, in charge.
In addition to being a rather high-strung young man by nature, I was also
new to the software development industry and the corporate world in general.
Naturally, I was full of idealism and ideas on how to pursue excellence wher-
ever possible, and I was typically quite vocal about it. I remember this little
episode, though, because it was my first encounter with the realities of the
business world with which I’ve become so familiar. I realized in that moment
that logic had absolutely no bearing on the matter, that my manager felt
exactly the same way about it as I did, and that in the end, there just wasn’t a
darned thing that either of us could do about it. There was one and only one
path available: shut up and code. So I did. To detail the adventures encoun-
tered by the field reps due to the expected instances of bad things happening
to good floppies would be an exercise in the obvious. Although ten years later,
I now view this as a fairly tame example of corporate ineptitude, it was a real
eye-opener at the time. It was at that moment that I realized I wasn’t in
Kansas anymore.
The first mistake that most new programmers make is assuming that the
logical, practical, and most sensible arguments always prevail. I’m certainly not
the first to observe this, but there seems to be an almost mathematical formula
that dictates a diminishing capacity for common sense as one moves up the
corporate ladder. This gets even more exciting when you couple it with tech-
nology, for the Suits often consider themselves an authority on software mat-
ters after having read an article on the latest technology trend in an outdated
business magazine while visiting the restroom. Having added “chief architect
Chapter 1 Welcome to the Corporate World
9

and software engineer” to their list of perceived skills, they are then known to
join in the next available software meeting and insist on design and implemen-
tation details with all the authority that they possess. Many sets of lungs have
been exhausted as programmers frantically try to explain why writing a wire-
less transmission system to control a toy dune buggy isn’t necessarily the most
efficient way to deliver interoffice mail. Their arguments are based on the
invalid pretext that the businessperson in question would know a network pro-
tocol if it bit him on the fanny. They will lose. For what it’s worth, however,
they will end up having a lot of fun testing the system by having dune buggy
races at two o’clock in the morning. Our business is ever an exercise in
tradeoffs.
Another area where the nonsensical ways of the business world cause us
grief in a very personal way is the matter of deadlines. In a world controlled
by programmers, or perhaps Vulcans, a new software project would start out
in a controlled and organized manner: gathering requirements, estimating the
effort, performing adequate design, and ultimately following a well-thought-out
and achievable schedule of implementation. In the real world, this almost
never happens.
The ultimate delivery date—that magical moment on the calendar that sig-
nals the end of four straight weeks without sleep—is typically arrived at in an
almost unbelievably arbitrary fashion. Sometimes it’s due to a management
staff that has convinced themselves that they know enough about software
development to say how long an effort should take. Other times the marketing
department publicizes a release date scheduled without the slightest consider-
ation for the time it takes to write the system. Rather, they do this as a pre-
emptive strike against the competition, to keep the customer from buying
Brand X because your new version is coming out “real soon now.” Dates are
sometimes even given to development teams because that’s just the date that
management wants the results, with no more logic or reasoning behind it
than that.
One might be inclined to simply explain to the decision makers, either
patiently or angrily (I’ve done both), that they can make all the decrees that
they like, but the software will be done when it’s done. Why, yes, I have
changed jobs a few times, now that you mention it. Above and beyond the
political peril caused by telling the person who controls your department’s
budget that you’ve seen burritos with less potential for hot air than they pos-
sess, there’s a very simple reality to consider: regardless of whether the dead-
lines are realistic, if you don’t meet them, either you’ll be replaced by
someone who will or your project will be killed. Sometimes both.
Often, even with unrealistic dates, it’s possible to prevail and deliver the
goods on time. In order to do this, it’s important to possess the ability to man-
age each stage of the development process effectively in the time that you do
have. Many of the books and courses on requirements gathering, analysis,
design, project management, quality control, and the software development
process in general are written for a perfect world in which there’s plenty of
10
Part I Software Development in an Imperfect World

time, and management is never resistant to the development team’s way of
doing things. In the real world, however, we’re rarely given the time that these
approaches require. The end result is either a chaotic sequence of events or
no sequence at all, with the developers shooting from the hip and making it up
as they go along. Either way, you have about as much chance for success as
you do landing the space shuttle in the driveway next to your kid’s new tur-
bocharged skateboard.
The business world simply doesn’t operate in a logical or rational fashion.
If you don’t recognize this and learn practical methods of coping with it, you’ll
encounter failure after failure, no matter how good your technical skills. Left
to their own devices, the Suits will not only shoot themselves in the foot,
they’ll miss on the first attempt and get yours as well. What does this really
mean to you, the working-class programmer, on a day-to-day basis? After all,
you didn’t sign up to be a project manager; you just wanted to write cool pro-
grams. Well, above and beyond the obvious shoe repair bills, you’re going to
find yourself continually angry and frustrated as you spend your days designing
and implementing programs that were doomed before you even fired up your
editor.
If you can’t win critical battles in all phases of the development process,
poor decisions will continually transform your potentially excellent software
into a series of well-publicized disasters. If management doesn’t trip you up
by mandating some form of arbitrary and inappropriate technical approach,
you’ll find yourself having to perform hack after hack of your own accord just
to meet the ridiculous deadlines. Long before the obligatory release crunch,
you’ll be throwing monitors out of fifth-floor windows to try to vent the stress.
All you wanted to do when you got into this business was code. Now, in addi-
tion to the meetings, company procedures, paperwork, dress codes, and other
trappings of bureaucracy, the very thing that allowed you to put up with it all
in the first place, the joy of writing good-quality software, is being interfered
with on a daily basis. This is when it gets personal.
You Can’t Win If You Don’t Play
You most likely didn’t start out wanting to be an entrepreneur, project man-
ager, CEO, or anything else with a spiffy title. You prefer the artistry of com-
manding little silicone chips to do your bidding. In fact, if you’re like most of
the programmers that I’ve known over the years, you have an active animosity
for any of these positions. The best place for most developers is in a room with
a door that has a large enough gap at the bottom to slide raw meat in once a
day. If we wanted to be the dashing owner of a Fortune 500 company, we’d
have bought pin-striped suits instead of the latest version of that hot rod pro-
grammer’s editor.
Chapter 1 Welcome to the Corporate World
11

Nonetheless, it’s time to wake up and smell the espresso. The single
most prevalent reason that programmers don’t prevail in internal company
maneuvering is the fatal misconception that it’s not a part of their job. Most
programmers excel in the technical areas but rarely know how to navigate the
business environment in which they exist. This isn’t for a lack of ability, how-
ever; they simply never chose to develop these skills and, as a result, become
corporate roadkill, along with their favorite development projects. Mind you,
they would be quick to make fun of any developer who didn’t have solid cod-
ing abilities, as these are obviously required to do the job and deliver the soft-
ware. And, yet, they don’t realize that the very same set of rules applies to
understanding and effectively dealing with the corporate world. Without
the capacity to cope with all that the business world throws at you, it is an
inescapable fact that you will not deliver high-quality software on time and
within budget. By the way, you might be wondering why you care about the
budget. What do you figure your chances are of getting another project to
work on if the one you just finished was a financial disaster? It goes without
saying what fate befalls the employment status of programmers who have no
project.
Remember, too, that if your project dies, no one will ever see how cool
your code was. That’s the artist’s reason for caring about the ins and outs of the
corporate world, distasteful though it may be. Pouring heart and soul into a
project for months only to have management pull the plug on it can be a real
stress inducer. It’s better to learn how to avoid such things. It’s either that or
listening to an angry night watchman explain to you why the near miss of a
monitor from a fifth-story window is going to cause many more sessions of
expensive therapy for his already jumpy attack Chihuahua. And you thought
you had problems.
Many an otherwise brilliant developer shrugs these things off as nothing
more than politics, as if it’s something that pops up only occasionally and is of
little importance. In reality, the numbers are actually much more distressing
in this area. Whenever three or more people occupy the same room, you have
politics. It’s human nature. If you choose to ignore this, you will eventually lose
a battle that you care about. Actually, you’ll probably lose them all. The night
watchman’s dog will doubtless get some smug satisfaction from this. The very
first step towards a better workday is simply recognizing the fact that you must
learn to control the scenarios you encounter on the job, or they will control
you. From that point on, it’s just a matter of getting good at it.
Of course, one of the first steps in learning how to deal with your environ-
ment is simply recognizing its key components. If you’ve had your head buried
in a compiler (or the sand), you might not have taken the time to catalog the
various aspects of your domain. Let’s start by taking a look at one of the most
fundamental and critical structures you’ll encounter. We’re not talking about
data structures here, but rather the food chain.
12
Part I Software Development in an Imperfect World

The Food Chain
As we all know, animals in the wild have their survival threatened on a regular
basis according to their position in the food chain. The rules are actually quite
easy to understand: either get dinner or be dinner. For most of us, the former
is much more appealing, particularly when microwaves are involved. However,
for the hungry lion that doesn’t have a choice between chasing down a zebra
on the open Serengeti or just ordering a pizza, the food chain is a critical con-
sideration. Of course, you might hear similar sentiments from the zebra.
You should know that the corporate world has a very similar structure. Just
as a salmon isn’t going to be much of a threat to a grizzly bear’s survival, so too
does the president or CEO of your company sleep soundly at night, immune
to the attitudes and desires of the rank-and-file programmer. In the business
world, there’s an oft-used plumbing metaphor about—well, let’s say stuff—
rolling downhill that is actually quite accurate. If the head of the company
decides that Software Project X is no longer desirable, due either to fiscal
considerations or that three-martini lunch he just had with the manager of
Software Project Y, then Project X is history. Just like that. Game over, and if
you have another quarter, you’d better save it to call a recruiter. 
The CEO is the most dangerous beast in the corporate animal kingdom.
Not only does he have the power to lay waste to entire departments (it’s very
rarely a she, for a completely different set of inane reasons), he is also almost
always out of touch with the day-to-day realities of your business. The head of
your company gets his view from 30,000 feet, not from down on the ground
where real people deal with real problems on a daily basis. The fact that he
has to depend almost entirely on summaries, reports, upper or maybe middle
managers, and the obligatory pie charts guarantees that, from his lofty view, all
the details that are critical from your front-line position are lost. However, if
he gets good advice from informed and properly motivated managers beneath
him, he can still make solid, practical, and informed decisions. So, let’s take a
look at the next rung in the ladder: upper management.
These short-haired creatures are easily identified by their customary pin-
striped suit and the exclusivity of their dwellings, typically posh offices located
very high up in the building. This location helps them avoid chance encoun-
ters with the packs of programmers known to roam the lower-level halls in
search of a Suit who has been separated from the herd. Upper management
is actually the same breed as that of the president/CEO; the latter has simply
established himself as the dominant male. These managers, in turn, establish
their own territories, such as accounting, marketing, manufacturing, and, of
course, software development. Although it may seem that the only one of
these we care about is the one in charge of the programming department,
that’s a bit misleading. These critters are known for their aggressive behavior
and are always positioning themselves to take over the turf of any other
Chapter 1 Welcome to the Corporate World
13

managers who are unwary or who let their guard down. This is how bean
counters can end up in charge of an incredibly complex and critical software
development project.
Although highly competitive, they are also greatly influenced by each
other, reading similar trade publications and frequenting the same watering
holes. This also poses a threat to those lower on the food chain, for advice
from one manager is taken more seriously than are recommendations from
someone at a lower level who actually produces something. Consequently, we
find many disastrous decisions that have their genesis in one of these guys tak-
ing bad advice from a peer who, while clueless about software development,
was considered a good source of information because he was, after all, a man-
ager. If you knew how often this happened, it would only interfere with your
ability to sleep nights.
Our next species doesn’t worry much about sleeping nights because they’re
usually spending them at the local watering holes (the very same watering
holes, by some strange coincidence, as the ones frequented by upper manage-
ment). This, combined with the fact that they are directly responsible for
bringing money into the company (remember the reason people form compa-
nies?), accounts for the high position that those in marketing occupy in the
food chain. Their credo—nothing happens until a sale is made—is oft ignored
by the rest of the kingdoms in the corporate world.
Because I’m a practical person who likes to eat on a regular basis, it’s worth
noting at this point that I’ll be the very first one to buy the drinks when in the
company of my publisher’s marketing folks. Programmers do love to tease
those in marketing, probably because this group is so often responsible for
unreasonable deadlines. It also happens to be the group, though, that fills the
payroll bank accounts. That’s typically overlooked. In fact, of the groups we’ve
reviewed in the food chain thus far, those in marketing are the first to actually
produce tangible results. This brings up an interesting survival skill that we’ll
be touching on later. Although they exist higher up on the food chain and are
without a doubt born predators, those in marketing are not always the natural
enemy of programmers. It just seems that way. It’s not often documented in
the wild, but these two species have been known to form powerful unions,
elevating the power and status of both within the corporate structure. Just
don’t ask who usually ends up paying for the drinks. They’re in marketing for
a reason.
As is so often the case in nature, the greatest threat to survival often comes
from those just above you in the natural order of things. Middle management
is that class of creatures who are in direct, day-to-day contact with the people
who develop software. This group is the most feared by those who actually
produce tangible results on a daily basis. Well, feared by everyone but market-
ing; those guys are fearless by nature. Middle management has a fairly well-
ordered social structure. Most of their behavior is dictated, in fact, by the
established norm of the pack in which they live. Middle management is the
weather vane of the corporate environment, as they’re always the first to sniff
out new trends. This doesn’t guarantee an accurate weather forecast, mind
14
Part I Software Development in an Imperfect World

you; it simply means that they’re highly driven by which way the wind is blow-
ing. In these parts, it blows a lot. Above and beyond the fact that they have,
by position, the ability to control and therefore wreak havoc on the software
development community, the additional danger comes from proximity. Being
close to developers each day—even sharing the same dwellings in many com-
panies—this group eventually hears enough buzzwords to believe that they
actually understand technology. Worse still, they come to the inescapable
conclusion that they’re more qualified to make decisions in this area than pro-
grammers are because they understand technology and are, after all, man-
agers. Of all the dangers in the wild, these harmless-looking creatures, attired
as they are in their natural “business casual” camouflage, pose the greatest
threat to the unwary developer.
At the lowest level of the food chain, at least as far as the programming
world is concerned, the software development group is a species that com-
prises several subgroups. The highest ranking of these is project management.
Note that I didn’t say “the most dominant.” Software developers are always
vying for control of some corner of the pack, and the power doesn’t always
match the position. A veteran coder who is the only one on this planet or any
other who understands the cryptic and arcane workings of a critical piece of
software is often given deference by the project manager, being appeased with
trinkets such as high-resolution monitors, extra computers, and even (in rare
cases) an office with a door on it. Nonetheless, when you look at the org chart,
the project manager is perched at the top of this group. The greatest threat
that a project manager generally poses to the surrounding programmers is not
one of direct aggression, but rather that of the entire project being decimated
by the project manager’s inability to defend the pack from outside predators.
Next in rank (at least as far as structure is concerned), team leads are typi-
cally little more than programmers with a full coding load who somehow got
suckered into doing some of the project manager’s job in addition to their
own. This makes the team lead a more dangerous individual than the project
manager because, due to the stress induced by the dual workload, the former
is much more likely to hand you your head for a stupid interruption. Pro-
grammers in general don’t care much for distractions, but this subgroup is
distinguished by a marked lack of patience and general harried look that
sets them apart from those who only code all day. It is a subtle distinction,
but one that the expert can learn to recognize.
Tucked away in corners of the building where the sun shines the least
(particularly on higher floors where windows overlooking the night watchman
are discouraged), programmers are at the very bottom of the food chain.
Depending in part on project managers for protection and survival, they exist
primarily as nature’s way of balancing out marketing. Neither would exist
without the other, although you won’t hear much of that sort of talk at the
local watering holes. Important by implication is the position occupied at the
bottom of the heap. Remembering the adage that things tend to roll downhill,
programmers are, in fact, at the bottom of the hill. Regardless of the reason,
be it a project manager who has no idea how to estimate and create milestones,
Chapter 1 Welcome to the Corporate World
15

a middle manager who decides to try the latest management fad, the market-
ing rep who has just made yet another unsubstantiated promise to customers,
or the sweeping decisions of those in upper management—it all falls squarely
on the shoulders of the rank-and-file programmer. In short, no matter who
screws up in the food chain, you can rest assured that you can kiss your week-
end plans good-bye. All the more reason for you to periodically stick your head
above the cubical walls and see what’s going on in the rest of the world.
Over the years, I’ve found myself occupying a cubicle in huge international
companies as well as small mom-and-pop shops. If you work in the latter, you
may think that the preceding descriptions of the corporate world don’t apply
to your situation. In fact, these categories exist in every company large and
small. It’s more obvious in the large firm, but, no matter where you work,
there is without question a food chain. Learn to recognize it. Remember, it’s
either get dinner or be dinner.
The Various Species of Programmers
Having seen a glimpse of the wider world of which you are a part, it’s also use-
ful to have an understanding of the different styles of the critters in your own
pack. Although they are much less likely to be a threat than those above you in
the food chain, making the wrong move with some of these guys will result in
you limping back to your cube. Others will make you want to gnaw your arm
off just to escape. So, in the spirit of obtaining a better grasp of the program-
mer’s world, let’s take a look at some of the more common varieties of coders
that you’ll meet in your travels.
One of the all-time classics, the crusty and cranky coder is a timeless sym-
bol found in trade magazine advertisements everywhere. Far from fiction,
these are very real people. With a diminished patience for others sculpted
from many years of corporate ineptitude, these folks tend to be irritable frus-
trated, and they just basically want to be left alone—or else. They may or may
not appear to have any teeth, but it’s wise not to antagonize them. This is par-
ticularly good advice for the young. They may seem powerless to affect your
life, but tick them off, and you’re liable to find out exactly how they’ve man-
aged to survive in the business world for so long. Not everyone displays their
weapons. Although there are times when you must press an issue regardless
of who you disagree with, choose your battles wisely and avoid confrontations
with these guys whenever possible. The best way to get along with them is to
simply leave them alone and to make sure that any of your code that they’re
dependent on is stable and on time. It also never hurts to pay attention to what
they’re doing and how they’re going about it. You might learn something, no
matter how long you’ve been at it.
The technology evangelist can be a real pain in design meetings. His par-
ticular preferences for a brand or product will be promoted without regard to
16
Part I Software Development in an Imperfect World

any pragmatic reason. If he thinks that Brand X is the hottest new technology
going, he will most assuredly try to incorporate Brand X into every coding
assignment he has a crack at. Attempting to get into philosophical arguments
is pointless. So is arguing for your own technology on the same emotional
basis, if you happen to be a technology evangelist yourself. The best way to
counter any ill-advised recommendations from this sort is to be well prepared
with accurate, detailed information about the strengths of your approach and
the weaknesses of his. You must also make sure that your appeals are to the
rest of the group or to those above him on the food chain. Any presentation
you make to him will fall on deaf ears. And no, whiteboard erasers don’t help.
I’ve tried.
For some—shucks, for most of us—it’s easy to adopt the perspective that
technology is life. Twenty-four hours a day (because I’m sure they dream
about it, too), seven days a week, the only thing that matters to such people
is the latest development in computer programming. Social events, family,
friends, politics, the weather, you name it, are all completely irrelevant topics
and not worthy of discussion. You may find this frustrating if you’re trying to
make casual conversation at the office. However, bear in mind that it’s not
for you to determine the life that others should live. It’s been said that no
one on their deathbed ever wished they had spent more time at the office.
Nonetheless, it’s their choice. With these folks, talk tech or just leave them
alone. When you’re at the office, however, these are frequently great guys to
hang with. You’re there to work as a techie, and these guys are some of the
best. You’ll not only learn many things that you wouldn’t have taken the time
to research for yourself, you’ll also find a highly enthusiastic ally in your devel-
opment efforts. Such developers are the epitome of the passionate programmer.
On the complete opposite end of the spectrum, the company man is a
strange genetic hybrid between a Suit and a programmer. Technology will
not be nearly as important to him as toeing the company line, no matter how
insane that may be. Curiously, these are often excellent programmers who
fall into this category for the purest of reasons: they want the company to suc-
ceed and are under the impression that goose-stepping along with the others
is the clear path to this goal. They succumb to the corporate rhetoric that the
employees should sacrifice their own lives for the better of the common good.
It’s useful to note that they’re typically young as well. A few years in the corpo-
rate world is generally all the treatment that this particular malady requires. 
However, this represents another nuisance and even potential danger in
the wild. To the company man, good employees work eighty hours a week,
every week, because they’re dedicated and hard workers. Anyone who doesn’t
put in this ridiculous level of effort is considered to be a slacker, a malcontent,
or some other form of deadwood that should be fired or at the very least rele-
gated to the most tedious and dreary task that can be found. Watch these guys
closely and never let your guard down around them, for they will stab you in
the back without even a moment’s hesitation. Yes, I know that sounds a bit
dramatic, but I’ve seen it too many times. In reality, they’ve been played for
Chapter 1 Welcome to the Corporate World
17

suckers by middle and upper management, but they’re not yet sharp enough
to realize it. Don’t bother trying to convince them; it will only make you an
enemy. Just give them a wide berth and always sleep with one eye open.
Even though the company man thinks that most of us aren’t really dedi-
cated workers, most of us are actually quite conscientious. There are, however,
those in companies here and there who truly are slugs. I’ve seen hourly work-
ers bill excessive overtime, and yet actively dodge assignments and spend their
days brazenly reading the newspaper or playing video games at their desk
when there was no shortage of coding to be done. Really. My personal inclina-
tion with such people involves an open fifth-floor window but, out of consider-
ation for the health and well being of small, hairless canines everywhere, I’ve
learned to just let it go and let them reap their own rewards without my help.
In addition to the fact that I have no shortage of flaws myself, trying to get
rid of one of these slugs is usually more stress inducing than it’s worth. Just
concentrate on your own work. Eventually, the wheel will come around for
these guys.
The burnout is closely related to the slug, but is a little easier to under-
stand and tolerate. Spend enough time working bad jobs in this business and it
could be you. The best thing to do is just be nice to them, and try your hardest
to make sure you don’t have to depend on them.
Possessing no social skills that I’ve ever been able to discern, the arrogant
bit head is almost always an absolute killer programmer, the best of the best.
The problem with this guy is not just his cocky, condescending, and demean-
ing attitude, but the fact that 9.990872 times out of 10 he can back it up. He’s
just that good. It’s a pity that he holds others in such low regard because,
although not everyone achieves god-like status as a software developer, the
world is full of really, really good ones. It’s worth noting that not all bit heads
are terminally arrogant (hence the prefix). Most of us who have any skills at all
are a bit on the cocky side. The really good bit heads are almost impossible to
convince that they’re wrong because they usually aren’t. However, once you
prove your point with no margin for error, they will quickly and graciously
come over to your camp and help you fight the next battle. It’s only the arro-
gant bit heads who cross the line and whose abusive and offensive behavior
makes them a personality type that you need to watch out for. Don’t bother
arguing with these guys unless you really know your stuff. Even then, be pre-
pared for a fight that includes innuendo that you have less mental-processing
facilities than a refried bean factory. If you win the day, they’ll usually be
sullen about it, but, in general, these aren’t particularly political creatures and
so the threat is minimal. Fighting with them over technical issues can actually
help make you a better programmer, if you can avoid killing them before the
discussion is done. You just have to learn to detach the emotions and let their
poor attitude roll right off you.
One of the more frustrating types to deal with when you’re under pressure
to meet a deadline is the terminally educated. These folks will spend hours
and hours of time that you just don’t have to spare pontificating on the “proper
process” to follow. Strong on academia, weak on hitting deadlines—that’s the
18
Part I Software Development in an Imperfect World

hallmark of these guys. Don’t get me wrong: I think a little education is a fine
thing every now and then. However, out here on the streets, no one has time
nor really cares about obtuse studies, ivory tower design philosophies, or any-
thing else that can’t bring a tangible result to the party really soon. In a perfect
world, I’d love to have the benefit of all that they’ve studied. Unfortunately, in
the incredibly unproductive corporate environment, these guys just chew up
bandwidth and create clutter that gets in the way of getting the product out
the door in the three-and-a-half days that middle management gave us to do it
in. Do your best to avoid meetings with this sort. If you do have to work with
them, try to get support from those further up the food chain who realize that
there’s actual work to be done.
Ever a mix of styles and personalities, the wild man probably just exists for
our own personal entertainment. Typically as enthusiastic about coding as he is
about rock climbing, loud music, mosh pits, or anything else extreme, he does
tend to break up the monotony of the corporate world. He may be a distrac-
tion in meetings, but he is usually amiable to saving the stories until later if
approached in a friendly manner. His animated mannerisms are a great thing
to have around when the going gets tough and morale begins to falter. This
kind of programmer can usually be counted on when there’s a crunch, but
don’t expect him to live at the office otherwise, as he has a life to live. He’ll be
the very first target of the company man and often doesn’t even realize his
peril. Keep an eye out and watch his back for him. He might even teach you
how to surf, if you’re not afraid of getting your pocket protector wet.
While I personally have only seen pocket protectors in bad black-and-
white science fiction movies, there was a time on Earth when computer pro-
grammers were geeks. Even if they weren’t serious dweebs, they were, at the
very least, clean-cut, properly attired, and professional in demeanor. Old-
school programmers still exist in the world today, although they’re typically
older than the rank and file. They never caught on to the Wild West attitude
that has been so pervasive in our industry since the dawn of the personal com-
puter. You won’t catch them hang gliding, nor are you likely to have animated
and passionate technical discussions about the latest trends in software devel-
opment with them. However, it would be a serious mistake to write them off
as an irrelevant group with nothing to offer. It is the very fact that they don’t
have the typical shoot-from-the-hip mentality that brings such value to a team.
They are organized and well prepared, and tend to think things through thor-
oughly before implementing a plan of action. Yes, I know that’s kind of an
alien concept these days, but heaven only knows how many bugs we could
avoid if there were a little more of that mentality. Personally, I’m a Wild West
kind of guy who has had to learn discipline for matters of pure survival, and I
hope to never lose my passion for coding. However, somewhere between the
Wild West and the old-school programmer lies a land where software is stable
and pocket protectors are still badges of honor.
Given the explosion of opportunities in the computer business these days,
it’s not hard to snag a couple of side projects in addition to your day gig.
There’s certainly nothing wrong with that, as it’s just an aspect of reaching
Chapter 1 Welcome to the Corporate World
19

for the brass ring. The entrepreneur, however, always seems to be doing this
stuff on company time. Mind you, most companies aren’t really that anal about
whether or not you take a couple of minutes for a personal call, send an email
to a friend, or hit the Web to look something up. People need breaks to be
productive. However, if you’re sitting there on the clock coding an order-entry
system for a client that you have on the side, you have some serious ethical
problems. I tend to deal with these guys the same as I do the slugs.
We’re all a pretty opinionated lot, and that’s not necessarily a bad thing.
The authority, however, knows all things on all subjects, regardless of actual
experience. If he doesn’t know the answer, he will simply ramble on trying to
look knowledgeable. It’s even worse when those up the food chain assume that
he’s a credible source of information, as that tends to lead to some fairly inter-
esting technical directions and hinders those who really are informed in their
efforts to steer a sensible course. Probably the most frustrating thing is this
person’s inability to utter the simple phrase, “I don’t know” (which is some-
thing I consider to be the very cornerstone of wisdom). Nonetheless, if they
have good communication skills or any degree of charisma, they can be quite
difficult to deal with. Again, the best way to counter such a problem is to gain
enough allies to give the dissenting opinion a fighting chance. Those who are
impressed by the authority rarely look too deeply into the detail of things, so
your political skills will almost always come into play in countering such a
programmer.
So, having explored a wide variety of programmers, each with their own set
of nuances and shortcomings, what shall we do? Throw them all out and keep
only the good ones? Hope you don’t mind coding the entire system yourself.
The well-adjusted programmer is an urban myth. I have heard tales of a crea-
ture that balances work and play equally, and that has unsurpassed technical
skills but the social graces of a saint. If you find one, stick him in the
Smithsonian Institute and give me a call. Maybe then I’ll believe. From my
experience, we’re all a pretty strange lot. As with anything else in life, the key
to success is not insisting on a perfect world, but rather in having a firm grasp
of reality and operating accordingly. You’ll doubtless find programmers who
display many of these attributes, just as you’ll find some classic examples. In
the end, it’s not about trying to change someone else. It’s only important to
learn how to effectively interact with those with whom you spend your days.
Remember that you have a few quirks of your own, and not all buildings lock
the windows on the fifth floor.
Having taken the nickel tour of the corporate world, we now have a foun-
dation on which to build as we look to the issues that hinder our efforts to kick
out the code. It’s been said that to know where you’re going you must first
know where you’ve been. I’ll extend that a bit further to include where you
are at the moment, which is a strange place, indeed.
20
Part I Software Development in an Imperfect World

We know the symptoms of the problem all too well: endless hours of overtime,
continual meetings with stressed-out management, and just crisis after crisis
as software continually blows up in the field. These are but a few examples of
what happens when the software development process goes awry. Any devel-
oper who has ever taken home a paycheck knows this cycle well. No matter
how much we enjoy coding, this isn’t the way we’d like to do it. It’s just no fun
being under this kind of pressure only to work in an environment that almost
guarantees buggy releases. Because we’ll never win the fight for the software
development process if we’re swinging at shadows, the next logical step is to
grab the binoculars and get a good look at the enemy. If only they were really
that far away.
Unrealistic Deadlines
Ask any veteran programmer to name the biggest enemy on the job, and
chances are good that you’ll hear about unrealistic deadlines. Exactly what is
an unrealistic deadline? Simply put, it’s a no-win scenario in which the game is
lost before it’s even begun because the software cannot possibly be developed,
tested, and delivered in the allotted time. It would be much less of a problem
if this resulted in software that simply wasn’t shipped. Unfortunately, it always
gets delivered. It’s often unstable and almost never thoroughly tested, but it
ships. As you might imagine, this creates more than one problem.
The first and most obvious bit of fallout from the decision to ship software
regardless of its state is that of a customer paying for a buggy product. This
makes for unhappy customers, which, in turn, makes for unhappy people at
your company, all of whom are further up the food chain than you are. It’s not
difficult to figure out who will bear the brunt of the accumulated frustrations
and anxieties that result.
21
Business Is War.
Meet the Enemy.
2
C
H
A
P
T
E
R

The other more subtle and damaging problem that comes from shipping
a product that wasn’t ready has to do with expectations. It works like this.
Management comes to you with a silly date. You argue that there is no way the
software can be delivered in that amount of time. Your opinion is ignored, and
the mandate is given that the software will be done by the aforementioned
date, or else. You’re expected to “do whatever it takes” to make it happen, or
suffer dire consequences up to and including spontaneous loss of income. For
those of you new to the business, “do whatever it takes” means that now would
be a great time to rent out your house because you’re not going to be seeing
much of it until after the deadline. You will code, eat, and do everything but
bathe in your cube for as many consecutive hours as you can manage to stay
conscious. You will then sleep the absolute bare minimum required to prevent
hallucinations and repeat the cycle, day after day. Of course, in this state of
mind and alertness, you’ll no doubt write your finest and most stable code
ever.
The problem is that the software will indeed ship. Toward the end of the
cycle, corners will get cut, bugs will be declared features, and printed copies
of enhancement requests will mysteriously disappear, only to be seen many
weeks later in the dumpster appearing rather well gnawed. (The watchman’s
dog, of course, will deny any involvement.) Any remaining issues will be
deemed acceptable shortcomings that can be remedied by a patch that the
customers can download from the Internet.
Why is this a problem? Even though you were correct in the beginning
about not having enough time to deliver the software, you assumed everyone
understood that you meant solid, full-featured, quality software. That’s not
what they heard, of course, so, from their perspective, you were dead wrong.
It did in fact ship. This means that the next time management comes to you
with a ridiculous deadline, you’ll have even less credibility, if that’s possible.
You said it couldn’t be done the last time but, by golly, it shipped anyway.
Consequently, there shouldn’t be any problem with the next unrealistic dead-
line, right? That’s why they call it a no-win scenario. If you hadn’t met the
deadline, there would be the devil to pay. So, you do your best to hack together
something that they can call a release, and they see it as proof that they were
right all along. It validates their practice of choosing arbitrary dates.
So far, I’ve been referring to unrealistic deadlines as a rather vague con-
cept. We know that they happen. However, to put an end to them, we have to
know why they happen. One of the first causes is something that I refer to as
“inverted project management.” By this, I mean the time-honored approach of
picking a release date out of the clear blue sky and then giving the project to
the programmers. Even if management were inclined to take a reasonable and
logical approach to arriving at the delivery date (and they’re typically not), they
simply lack the technical skills needed to know how long the development
process takes. That’s why they hired programmers to begin with. They couldn’t
do it themselves. Fortunately, for all concerned, they typically spare us the
pain and suffering of trying to justify in technical terms exactly why they chose
December 7 as the release date. They don’t have to. Remember the food chain?
22
Part I Software Development in an Imperfect World

Regardless of how and why they select the dates, however, it simply doesn’t
matter when it comes down to the coding. The dates are never even close to
reality, and the ensuing chaos is a constant. Any time that your company
selects a delivery date before the technical aspects of the project have been
evaluated in full detail, you will either miss your deadline or suffer a poor-
quality release. Any time, every time.
The next common practice that’s sure to wreak havoc on the unsuspecting
deadline is scope creep. If you’re not familiar with the term, it means the
addition of features after the product has been defined and the deadlines
determined. Even if you’ve done everything right, evaluated the project in
fine-grained detail, and come up with extremely practical and realistic dates,
this will still nail you. The reason that scope creep is a problem is that,
although the feature list changes midstream, the deadline doesn’t.
The habit of adding features as you go tends to be an incremental process.
Most people wouldn’t dream of walking into the programming department
and proposing a new feature equal in complexity to landing a man on the moon.
Apart from the volley of whiteboard erasers that would inevitably result, it’s
too obvious that it wouldn’t be possible in the time available. However, just
one tiny little enhancement doesn’t seem like a big deal, and developers are
made to feel petty and uncooperative if they make a fuss about it. I mean,
we’re just talking about adding a new button to the program; how big of a deal
can it possibly be? Leaving aside for the moment the mountains of code under
the hood that could result from our hypothetical little button, the problem is
really in the frequency of occurrence. 
One small change in a program is probably not going to blow the deadline.
Over the lifetime of your project, though, there won’t be just one of these inci-
dents. There will be a continual stream of them that bears a close resemblance
to a conga line in an all-night coffee house. Each enhancement is presented as
no big deal because it’s such a small matter. But, over time, these add up to
the point that the Great Wall of China will look like a white picket fence in
comparison.
It’s tempting to blame this one on marketing, but, in truth, these requests
come from anyone in the building who’s even remotely familiar with the proj-
ect you’re working on. Even the night watchman will get into the act, reason-
ing that a motion detector and early warning system couldn’t possibly take that
long to add to your system. Simple math will illustrate the result when your
feature list changes and your deadline doesn’t. Something, somewhere has to
give, and it’s usually the developer’s sanity.
Another reason that a project is destined to miss the delivery date from the
very beginning falls squarely on the shoulders of the programmers themselves.
If the developers have poor estimating skills, the timeline won’t be accurate,
even if management is willing to let the programmers set the dates. When a
programmer errs on an estimate, it is almost always on the side of optimism.
If, at the lowest level, the person writing the code can’t accurately estimate
how long the development effort will take, there’s no way to come up with an
achievable deadline.
Chapter 2 Business is War. Meet the Enemy.
23

This often comes about due to our desire to spend time coding rather than
shuffling paper on what seems like dull, boring, and bureaucratic tasks. It’s
true that writing an estimate for the system you’re going to develop is about as
exciting as a judo tournament between two blades of grass. It doesn’t matter. If
excitement is what you’re after, just wait until the last few weeks of the project.
You may decide that boredom is a highly underrated attribute. Tedious though
it may be, if we want to grapple with management for control over the delivery
dates, we better be ready and able to back it up once given the opportunity. I’ll
take a few boring days up front any time if it means that the rest of the project
will go smoothly and I’ll have the opportunity to sleep on a regular basis.
Another area where we actually have some responsibility for bad dates is
that of complicity. Programmers who are afraid to speak up are doomed to
suffer from the poor choices of others. If there’s no way to hit the deadline but
everyone on the team remains silent, there’s absolutely no chance of making it
more realistic. It’s true that management may still not change the deadlines no
matter how vocal you are, but you can’t succeed if you don’t try. What typically
happens is that a completely mindless date is given to the developers, but no
one confronts management about it, either out of fear of reprisal or simply a
general distaste for doing anything other than coding. The date gets set in
stone, the project moves on, and in the background you hear the constant
grumbling of programmers grousing about how stupid the timeline is. Sorry,
boys, but you should have spoken up when you had the chance. If you didn’t
at least give it the old college try when the dates were getting set, you forever
lose your right to complain about them.
Of course, trying to convince management that you know best about the
timeline is often about as easy as getting a coffee table to do the bunny hop.
The simple reality of it is that, right or wrong, management does not take pro-
grammers’ opinions seriously, for a number of reasons. First and foremost is
the lack of a common language. Anyone who writes software for a living has
a technical frame of reference and is consequently prone to geek speak.
Businesspeople have a completely different frame of reference, centered on
revenue, profits, expenses, market share, sales volume, and anything else that
might contribute to the purchase of an exotic new sports car when they retire.
Attempting to justify your reasoning with technical arguments will be met with
the same results as trying to teach calculus to your cat. Even if it weren’t for
the natural indifference of felines everywhere, all those noises coming out of
your mouth are simply unintelligible to the cat and are subsequently ignored.
Of course, it has been noted that many managers lack the basic intelligence
inherent in even the densest of house pets. This doesn’t improve your odds for
effective communications. However, no matter how correct the developers
might be in technical terms, they are simply ignored by a management staff
that doesn’t speak the same language.
It certainly isn’t fair, but the self-perpetuating cycle of missed delivery
dates also contributes to management’s resistance to the suggestions of their
programmers. Once a team has a history of slipped dates on previous projects
24
Part I Software Development in an Imperfect World

(and we all know how easily that happens), they have extremely little credibil-
ity with the higher-ups when discussing future deadlines. Management rea-
sons that, because we couldn’t hit dates in the past, then we clearly don’t know
what we’re talking about. The fact that these missed deadlines are the direct
result of poor management and the practice of ignoring the technical staff is
always overlooked or denied. It’s a tricky business saying “I told you so” to
people who directly or indirectly have control over your paycheck. Their posi-
tion on the food chain also allows management to simply stonewall program-
mers, denying any responsibility in the poorly considered schedule and placing
all the blame on the development team. They outrank us, and therefore tend
to get away with it. It ain’t fair, but it’s the way it is.
Businesspeople also tend to dismiss the opinions of technical workers due
to the backgrounds involved. Programmers rarely have MBAs. Management
figures that, when it comes to business decisions, they’re the ones who are
trained to make such calls because that’s their area of expertise. This is diffi-
cult to deal with because they consider everything to be a business decision.
Consequently, software developers are treated like small children who just
aren’t grown up enough yet to realize that they don’t know anything.
The “human wave” approach also causes its fair share of missed dates.
Assuming that the company is large enough to have a good pool of coders to
assign to a given project, many managers will often base their dates on the
assumption that they can solve a problem by simply throwing more bodies at
it. They don’t really understand the nature of the dependencies that we deal
with when coding on a large, multiple-programmer project. Nor are they
aware of the fact that it’s often quicker and easier to have one person write a
section of code than to try and share it among three. Instead, management
typically sees the problem no differently than a factory production issue: if you
have one person painting little wooden ducks all day, he can produce a reason-
ably predictable amount of decoys by quitting time. Therefore, if you have a
hundred people painting little wooden ducks, by quitting time, you’ll have
enough decoys to distract the entire migrating population of North America.
If only it were so simple in programming. The fact that it’s not matters little to
the manager who ignores his techies. On the positive side, at least we don’t
have to make our software quack.
Abusive management is another project killer. When I was a younger man,
I did a wide variety of things for a living, including working in factories and
shipyards. I even flipped burgers. Most of these were little more than minimum-
wage jobs. In my later days as a programmer, I noticed an interesting trend.
Factory workers are very often managed by intimidation and abuse. They are
made to feel inferior, yelled at, belittled, and driven like cattle. For the most
part, you don’t see this sort of behavior in professional circles. It struck me
as an interesting curiosity that the more money I made, the less I was micro-
managed and abused. And let me tell you, folks, if you think you catch some
disrespect as a programmer, you need to do a tour of duty as a blue-collar
worker. 
Chapter 2 Business is War. Meet the Enemy.
25

However, although this statement is true in general, it is not true without
exception. People are people no matter where you find them in life, and man-
agers are no exception. In our business, it’s not hard to find examples of those
who abuse their power and the people they control. Such miscreants will use
threats, intimidation, and everything short of physical violence to cow the
development team into doing their bidding. This is often an issue of unpaid
overtime and a mandate of doing it. . . or else, although it may manifest itself
in any area where programmers are forced to do that which they would other-
wise avoid. Of course, we all know what the “or else” part means. Not only are
such managers just not nice people, they’re also not very smart. They assume
that if they just demand loudly enough, the deadlines will be met. That doesn’t
change the facts and realities of a poorly considered date, however, so the
inevitable result is a slipped schedule and an unhappy group of developers.
This type of manager never realizes that happy workers are always more pro-
ductive than unhappy ones.
Of course, regardless of whether the date comes from highly accurate
technical estimates or from a manager wanting to deliver on the birthday of
his pet cocker spaniel, there is often little or no margin for error in the time-
line for the unexpected. If our industry has any absolutes, the one thing that
you can always count on is the fact that at least one thing will unexpectedly go
wrong within the lifetime of a project. There is no way to predict it and no
possibility of a contingency plan. You just have to wing it when it happens, put
out the fire, and move on. However, no matter how adept a team is at manag-
ing the occasional crisis, if the schedule doesn’t have any room for such events,
the date will be missed.
The practice of casual estimates also creates problems for a project. One
practice that both management and developers alike are guilty of is shooting
from the hip. When considering either a full-blown project or a specific set of
functionality, the estimating process is started and ended with the phrase, “No
problem, that should take only a couple of weeks.” I’ve also heard developers
offer the equivalent: “Well, we’ve never worked with the XYZ technology
before, but it looks pretty straightforward.” The unpleasant truth of the matter
is that casual estimating is often the result of laziness. Crunching numbers isn’t
nearly as much fun as coding the motion detector and early warning system
that the night watchman wanted. So, the tendency is to say whatever is needed
to make that pesky person asking for estimates go away. When the deadline
crunch comes—and it will—the night watchman will no doubt be hoping that
you got the early warning system coded at the beginning of the project. His
trusty attack Chihuahua has already been updating his resume, keeping one
eye on that fifth-floor window just to be on the safe side.
Many times, a marketing or management type will ask for “just a rough
ballpark figure” at the beginning of a new project. Many an unwary developer
has fallen into this trap. Even though the requesting party assures them that
it’s just a number to help them get a feel for the duration, the next thing you
know, marketing has made announcements in every major trade publication
on the planet trumpeting the new version of your product due to greet the
26
Part I Software Development in an Imperfect World

masses on the date derived from your extremely rough and unresearched esti-
mate. Once the date has been announced to the entire free world, manage-
ment naturally considers it the gospel, and the developers are left to figure out
how to make it happen. The local pizza delivery companies, who monitor the
programming trade press with great enthusiasm, couldn’t be more pleased.
A common mistake that in retrospect seems obvious to the point of sim-
plicity is failing to factor in time for installation, integration, and other periph-
eral issues that must occur in the fielding of any software system. Programmers
tend to think strictly in terms of coding, whereas management. . . well, we’re
not sure that they think at all when it comes to scheduling. It matters little,
though, for in the end, it must all be accomplished, and it all takes time.
In a similar fashion, there is almost never any time allocated for technical
documentation; that is, the design-oriented documentation used by program-
mers for development and maintenance. Once a project is complete, most
programmers don’t want to deal with any of that boring documentation stuff.
They just want to move on to coding the next gizmo. Actually, they usually
want to get in at least one decent night’s sleep, but that’s another matter.
Failure to update technical documentation may not hurt you on 1.0, but it’ll
impact 2.0 tremendously. Heaven forbid you should lose a critical developer
at any point in the process before that section has been etched in paper. Of
course, the maintenance programmers will also be extremely inconvenienced
if they have to go on a bug hunt without a road map. I’ve heard some interest-
ing stories regarding inconvenienced maintenance programmers, but it’s worth
mentioning that not all of them stockpile automatic weapons.
Merely having the initial design documentation—assuming you were given
any time for that to begin with—doesn’t get you off the hook. Something will
change during the implementation to render it all out-of-date. An inaccurate
road map is sometimes worse than no map at all.
Customer-driven deadlines are another source of difficulty for those of us
trying to kick out a solid system on time. Following is a summary of a conver-
sation that I’ve heard so many times in my career that it’s not even funny
anymore. “Well, I know you guys said it would take six months to build this
system, but our most important customer says that if they can’t have it by next
month, then we’ll lose their business. So we told them no problem. It’s no
problem, right?” Note that these comments are typically delivered as the man-
ager or marketing rep is walking steadily towards the door. Your protests are
usually silenced by the noise of the door closing.
This theme has many variations, of course, and it’s not always customer-
driven. It may be someone further up the food chain who declares an arbitrary
date after he has asked you how long it will take to deliver. It makes about the
same amount of sense regardless of the origination. It effectively boils down to
your superiors telling you that they’ve decided to completely ignore everything
you’ve told them regarding the timetable. They will then naturally expect you
to embrace the schedule and be positive, enthusiastic, and motivated about
hitting the deadline. Any other response results in your being declared “not a
team player.” At such times, I’ve reasoned that being a team player might not
be such a bad thing after all if it gave me easy access to baseball bats.
Chapter 2 Business is War. Meet the Enemy.
27

Vague Definition of Requirements
The next culprit in our lineup of seedy characters tends to appear early in the
development process. While known by some less flattering names, we’ll simply
refer to it as the “vague definition of requirements” out of politeness. In the
beginning, someone decides they want the software developers to create a
program. That’s all well and good, and, of course, programmers are typically
quite enthusiastic about such things. However, asking them to write a system
that allows the company to “take orders from customers via the Internet” is
just a little on the fuzzy side for most of us. Unfortunately, the requirements
are frequently not much more specific than that. Oh, you may get a little bit of
detail, but it all too often ends up sounding like, “You know, get the customer
information and the products they want to buy, and then charge their credit
card.” The interesting part of this is that, for many developers, that seems to
define the requirements well enough to get started. They reason that quantity,
product, price, billing, and shipping information should be obvious, and really
now, how hard could charging a credit card via the Internet be?
As the seasoned programmer knows all too well, even the simplest of soft-
ware has a host of details, with the answer to one question significantly alter-
ing all the questions that follow. Nonetheless, either through an optimism
that knows no bounds or at the urging of management, many a project goes
straight to coding with little more than these vague specifications. What fol-
lows is an extreme exercise in scope creep. Actually, it can’t be referred to as
creep with any fairness, because the scope was never really defined to begin
with. Instead, what you’ll find is a never-ending stream of modifications to
what the program should do, how the user interface should look, what the
inputs and outputs need to be, and so on. In addition to the mess this makes
of your schedule, it also makes a mess of your code. If you don’t know what
the program will do in the beginning, you will forever be wedging in bits of
code here and there in a completely undesigned manner. How could it be
otherwise? The bit of code you’re wedging in at the moment wasn’t a require-
ment when you wrote the existing parts of the system. For that matter, it prob-
ably wasn’t a requirement ten minutes ago.
The scheduling implications are obvious. It’s almost completely unheard
of in our business for management to ask us for a system without attaching a
timetable of some sort. That means that this project has a deadline. As is the
nature of deadlines everywhere, the requirements will change on you in an
almost hourly fashion, but the deadline will not budge an inch. Deadlines are
rather stubborn creatures and don’t care much for being moved around once
they’re comfortable. Consequently, if you don’t have your requirements
etched in stone from the very beginning, you can give up any hopes you had
of actually finishing the project on time.
Above and beyond our desire to just jump right into the coding, we end up
with fuzzy specifications for a number of other reasons. One of these is again a
28
Part I Software Development in an Imperfect World

matter of communications: domain experts are rarely technical, and program-
mers aren’t always social. Someone has to do the translation, and there are
very few in the company who speak both languages. In a well-organized shop,
those who cook up the requirements aren’t allowed to just grab a developer in
the hallway and start requesting new features. Instead, they typically interface
with the project manager through a series of meetings. The project manager
then passes the requirements down to the developers. Sometimes select pro-
grammers are included in the requirements meetings, at least in the later
stages, in an effort to get things spelled out in more detail. Ultimately, how-
ever, there must be at least one person who has both the ability and the
responsibility to take what the domain experts are saying and translate it to
geek speak. The fact that such a liaison is all too typically absent in develop-
ment departments makes it extremely difficult to get the specifics required
for a spec that won’t move.
Impatience is another common reason that requirements gathering is
given little serious attention. Management wants the program tomorrow if at
all possible, and today by lunch would be even better. Explaining to them that
there needs to be weeks of conversations before the software can enter even
the design stage is met with little enthusiasm. In defense of management,
though, the programmers aren’t any better. Sitting around all day listening to
a bunch of users talk about what they want is boring at best, and frustrating
more often than not when the discussions venture into the unrealistic. Once
again, we’d rather be coding. 
The end result is that no one, neither management nor development,
wants to take the time required to really nail down the requirements in black
and white. Because no one pushes for it, it just doesn’t happen. Everyone is a
loser as a result. Management won’t get what they want, when they want it.
And you know what’s going to happen to the programmers about halfway into
the project. Keep that sleeping bag by your desk. You’re not going home any
time soon.
All too frequently, even in shops with management willing to let the devel-
opers go through a fairly intensive design phase, a formal requirements phase
is not taken seriously and is moreover deemed a waste of time. Those request-
ing the project will tend to speak in high-level terms, and any efforts by the
programmers to get all the wagons in a circle and hash out the details meet
with little success. As astounding as it may be to the professional software
developer who has read all of the top design methodology books, most non-
techies don’t even know what a requirements phase is. The fact that it should
be approached in a manner no less structured and detailed than the software
design itself is equally alien to your user community. This makes it difficult to
get people to commit time and effort to meetings, write formal documents,
or do anything more labor-intensive than standing around the watercooler
dreaming up an ever-growing wish list of cool features.
Chapter 2 Business is War. Meet the Enemy.
29

Another reason that we meet with resistance when asking for formal and
detailed requirements documents has nothing to do with impatience and
everything to do with politics. The fact that they couldn’t coax “Hello, World”
out of a compiler does not make your user community stupid. They are far
from it. In most cases, when it comes to internal company politics and maneu-
vering, they leave programmers in the dust, pocket protectors spinning idly in
the wind. They’re aware of the fact that anything committed to paper today
could be trotted out to their disadvantage tomorrow. (The spoken word is
much more difficult to prove.) 
A great many people in your company have an agenda all their own. Those
who are savvy and determined about it take their business just as seriously as
we take our debugging. Should things go wrong, a paper trail can be used to
establish blame, and it can also give fair warning to an opponent with a differ-
ent plan for your project. Either way, it’s a political liability. Those who maneu-
ver have nothing to gain by committing to paper, which gives them no reason
to take on a potential liability. Although it may sound silly or paranoid to you
that they wish to avoid putting things in writing, it’s the reality far more often
than you may realize. Because of this, we can add yet another obstacle to our
need for a detailed and well-documented requirements phase.
Turf wars also contribute to problems of this sort. In all but the tiniest of
companies, multiple departments are typically involved in the software you
develop, particularly if it’s for internal use rather than the commercial market.
Each of these departments will, without a doubt, have its own agenda regard-
ing what the priorities should be for your project. The development team is
typically at the center of this struggle, as each party tries to convince either the
programmers or the upper management in control of the project to see things
its way. The ensuing conflict and politics do little to contribute to a well-
ordered and balanced requirements document. 
Yet another entertaining aspect to the search for the elusive specification
has more to do with being trendy than with practicality. Some of those
involved in shaping your software may specify that particular technologies be
used and promote this technology as a part of the requirements, regardless of
its suitability for the task at hand. Never mind that choosing technologies has
no place in the requirements phase in the first place. It’s similar to inverted
project management in which a participant decides that some specific network
protocol or client/server architecture should be used because it’s the buzzword
of the day, and then tries to force the rest of the project into whatever bound-
aries that this decision creates. If no one stands up and firmly explains that
requirements gathering is about what, not how, you may be stuck with this
millstone around your neck from the very beginning.
30
Part I Software Development in an Imperfect World

Inadequate Time for Analysis
and Design
If it’s hard to believe that companies would shortchange the requirements-
gathering process, it simply boggles the mind that they’re just as quick to dis-
miss the formal design phase. How anyone could be expected to deliver a
solid, stable, expandable, and maintainable system without the benefit of an
extremely well-thought-out design simply escapes me. Actually, I suppose
that’s not entirely true. Although we truly do require a sincere design effort to
have any hopes of delivering a good system, I understand why we’re expected
to skip it all too well.
Probably one of the most common perceptions that prevent us from having
the time we need for design is management’s view that, if we’re not coding,
we’re not really getting anything done. Consequently, time spent on analysis
and design is considered a waste of good programming hours. I don’t really
understand how it is that they equate typing with work and yet relegate think-
ing to the equivalent of standing around the kitchen drinking coffee. As an
aside, I might mention that I’ve solved a great many technical problems in my
career doing just that: standing in the kitchen drinking coffee and thinking my
way out of the sand trap. Nonetheless, a manager’s typical mindset would lead
to the quick conclusion that I must have way too much time on my hands and
therefore need another project or two. As a result, I’ve developed hearing and
instincts that leave gazelle in the dust. I can smell middle management three
corridors away and be safely down the road before they hit the kitchen.
One of my programmer friends, not known for his diplomacy, handles
things a bit differently. As a contractor at one of the large international corpo-
rations, he hit a technical problem that required some thought before any fur-
ther coding took place. As is his style, he started wandering the halls. Having
known him for many years, I recognize the distant look in his eyes and tend to
just leave him alone when he wanders by in such a state. I know that he’s four-
teen levels deep in his brain working through the intricacies of the bit of code
that he’ll soon sit down and bang out with a ferocity reminiscent of a WWII
machine gun nest. It’s unwise to bug a guy in such a state. He also happens
to have long blond hair down to his waist and probably doesn’t look like the
poster boy for the corporate world. So, he strolled slowly down the hallway,
casually looking at the artwork because his eyes had to have something to keep
them entertained while the mental process got all the attention. Suddenly, into
the aisle pops a rather self-important middle manager who clearly assumes
that some homeless derelict has stumbled in from the street and is trying to
decide exactly which piece of art to steal. Clearly someone who was used to
being obeyed, he confronted the distracted programmer. In a tone of voice
that more clearly indicated the fact that my friend should clear out before he
called the police, he huffs, “Can I help you?” The epitome of the classic, blunt
programmer, my friend simply looked him in the eye, replied “No,” stepped
around him, and kept walking as the manager fumed from behind.
Chapter 2 Business is War. Meet the Enemy.
31

Above and beyond the fact that the techie in question more closely resem-
bles an invading Norseman than he does a high-level software professional,
the message was reinforced quite clearly once more: if you’re not coding,
you’re not working. Thinking doesn’t count. It certainly doesn’t seem to be a
requirement in management, based on what I’ve seen at some of these compa-
nies. Because it seems that the bigger the company, the more one encounters
this mindset. It could even be argued that, in these circles, the absence of
thinking is a precursor to financial success. As an aside, I’m thinking that
another of my programmer friends who advocates a career change to herding
sheep in New Zealand may be right on the money. At the very least, if you
have a bad day at the office, the source of your irritation translates nicely into
dinner and a warm pair of socks.
Why is it that thinking isn’t considered a productive use of a developer’s
time? Maybe it’s a trust issue. If you’re banging on a keyboard and source code
appears on the screen in front of you, it’s obvious that you’re engaged in a use-
ful activity. However, because thinking isn’t visible (and I’m sure the planet is
the better for it), there’s just no telling what you might be up to. You might
be thinking about your girlfriend, if you still have one after the overtime from
that last release fiasco, or you could be fantasizing about the latest cool video
game. I suppose it’s easier for management to picture us geeks doing some-
thing like that than having a girlfriend, anyway. The fact that you could be
working through the various relationships necessary for the database system
you’re currently involved in never seems to occur to them. Regardless of the
reason, it’s a real problem. Show me a programmer who codes before he
spends serious time thinking, and I’ll show you a guy who’s going to be work-
ing 22-hour days come release time.
Perhaps another reason that design is deemed wasted time is that manage-
ment doesn’t have an understanding of the relationship between poor design
and the countless hours it costs in debugging, maintenance, and support. A
computer program is not a physical structure with components that can be
touched and examined with a magnifying glass, and so perhaps it’s hard for
some to draw the clear lines of cause and effect. When the Titanic struck
an iceberg, it was obvious to those on deck who felt the ship tear against the
ice that the resulting gash in the side meant a night treading water and hoping
that the sharks had been fed recently. We have no such irrefutable proof avail-
able to demonstrate that giving us eight hours to design a software system
that took a year to code is the reason that it’s suffering the same fate in the
marketplace as the aforementioned unsinkable vessel. Consequently, it is very
difficult to hold management accountable for the disaster.
Not realizing that the correct and productive development of software is
four parts thinking and one part typing, management is quick to dismiss our
requests for a design phase with a response that seems an exercise in the obvi-
ous to them. “We don’t have time for all this design phase stuff. We need this
program now.” In other words, instead of having fun and drawing all those pic-
tures on the wall, it’s time to get to work. So start typing.
32
Part I Software Development in an Imperfect World

Again touching on what is becoming a common theme, there’s a failure to
communicate. Programmers lack the ability to translate analysis and design
deliverables into something meaningful to management. It would be nice if we
could just ask management to trust us, but in reality, that’s not terribly practi-
cal. Ultimately, because no one can (or will) take the time to relate the results
of an abbreviated design phase to corporate red ink rising from maintenance
and support expenses, our request for adequate up-front design is simply
denied. Although the company will end up paying the price in dollars and
cents, the programmers will pay with fatigue and probably the occasional
sleep-deprivation-induced hallucination. I’m sure that’s why we throw moni-
tors out of windows. That’s my story, and I’m sticking to it. I’ve seen what that
Chihuahua can do when he’s agitated.
As is becoming apparent, though, it’s never all management’s fault.
Coupled with our desire to dive into the code, programmers often fear that a
lengthy analysis and design phase will give management a chance to change
their collective mind and drop the project. If something is quickly coded and
shown, the project is harder to drop because “it’s almost done.” If you’ve ever
worked in a shop where middle and upper management were rather capri-
cious in their approach to software projects, starting one only to cancel it and
start another just a few weeks into the process, this won’t seem like such a far-
fetched defense tactic. Although it’s true that this is often effective in saving a
project from the scrap heap, it’s rarely worth the cost. I think I’d rather just let
them cancel my project every four weeks. At least that way, I won’t have to
face the deadline insanities that are sure to arise in a shoot-from-the-hip proj-
ect. The reason many programmers don’t feel the same way is that we tend to
get emotionally attached to our work, like artists. That’s an easy trap to fall
into, and a costly one.
We also fall short in another area. Once we’ve asked for time for a full
design phase, management naturally wants to know how long such an effort
will take. When we reply with vague answers that amount to the fact that we
really don’t know, it’s not surprising that our request is denied. No manager in
his right mind is going to sign a blank check. Would you?
As in many other aspects of life, often what we find is not a complete lack
of time for design but rather simply an extremely inadequate amount. In the
case of many formal analysis and design approaches, the time required to do
the full-blown approach and all the charts, documents, and procedures is sim-
ply not realistic in terms of the time we’re given. The choices are to either can-
cel the project or use an abbreviated analysis and design phase. If the team
doesn’t have experience using a condensed but effective design approach, the
results are typically somewhat chaotic and of little value.
Of course, another contributing factor to our inability to get what we want
when it comes to time allocation is the fact that management doesn’t take pro-
grammers seriously when making business plans. Programmers (forgetting
where their paychecks come from) also don’t take management seriously and
make little effort to speak management’s language. We can’t really afford that
Chapter 2 Business is War. Meet the Enemy.
33

kind of attitude because our position on the food chain makes it obvious who
will win and who will lose in these contests. However, programmers are tech-
nically oriented people, and rare is the developer who has (or is willing to
develop) the skills needed to make management sit up and listen.
Sometimes the Enemy Is Within
Poor project management is also a high-ranking officer in the enemy lines.
Wouldn’t you think that the project managers would be on our side? In fair-
ness, while we all spent a considerable amount of time and effort to become
competent programmers, those who find themselves in project manager posi-
tions, officially or unofficially, have often been drafted. Whether they migrate
down from middle management or are the result of programmers who were
too slow to keep from getting recruited, these are often people who end up in
charge of a software development effort and yet have no real training in the
process. The end result is often a project that’s destined to implode due to
poor internal support as much as for any other reason.
One of the first mistakes that those new to project management make is
in creating timelines with the assumption that an eight-hour day means eight
hours of coding. This even happens to those of us who got sucked into the
position out of the ranks of programmers. Once you find yourself staring at
graphs, timelines, and other such seemingly bureaucratic stuff, it’s easy to
glaze over a bit and start thinking in nice, tidy boxes such as eight-hour coding
days and forty-hour workweeks. It happens. The reality, of course, is that we
never get eight hours of coding in unless we’re working thirteen or fourteen
hours a day. The result is more missed deadlines, this time not because of
the hours it took to do the job, but due to incorrect calendar projections.
Also included in this type of misfortune are not taking holidays, vacations,
and sick time into account when laying out the milestones. The productivity of
technical leads who take on a full coding load as well as project management
duties is also suspect. Being the lead on even a small team results in far more
interruptions to your day than you would have thought when you optimistically
put yourself down for a full share of the coding workload. The only way such
people get in eight hours of coding is if they do it when the rest of the team is
at home asleep.
Of course, the absolute worst mistake to make with a timeline is to simply
not have one. If you don’t have a plan for where you’re going, how you’re
going to get there, and what your progress is along the way, be prepared for
some surprises.
Even worse than not having a timeline, however, is the habit of developing
software by sequentially putting out fires, which is more aptly known as crisis
management. The frantic and harried project manager, moving from one mini
disaster to the next, follows an endless pattern of pulling the programmers
from one task to the next, without completing any of them. The conversation
34
Part I Software Development in an Imperfect World

typically amounts to “Stop everything and do this!” only to be followed a day
later by “Now stop everything and do this!” Naturally, nothing ever gets com-
pleted with this approach, with the possible exception of the programmer’s
résumé.
If the project manager lacks the necessary skills and ends up performing
poor task partitioning or dependency ordering, the schedule will suffer as well.
Another such issue is that of leaving integration testing between modules to
the last minute. Sparks inevitably fly at such points, and a little extra time is
required to smooth out the rough edges so that all the various subsystems play
nice with each other.
Because so few shops actually have a testing team staffed by experienced
professionals, keeping up with bugs, enhancement requests, and so on typi-
cally falls to the project manager. It’s unreasonable to expect him to perform
the same functions that a quality assurance manager would, but some projects
are unwittingly sabotaged by failing to implement any form of organization in
this area, such as a simple bug-tracking database.
A lack of general management skills can also hurt a team, such as the com-
mon scenario of frequent, long, and rambling meetings. Burdening program-
mers with unnecessary bureaucratic procedures just for the sake of the
paperwork is another mistake common to those with a background in middle
management rather than development. The project manager who operates in
a vacuum, not taking the feedback from developers seriously, can also create
deadline difficulties by making promises to management without consulting
the programmers first. However, one of the worst things that a project man-
ager can do to a project is contributing to programmer burnout due to con-
stant overtime. I actually worked at a shop once where the person in charge
told me, with a straight face, that he didn’t have any crunch time at the end of
a project because they encouraged their coders to “do all the overtime up
front.” I think I managed to make it out of the room before the laughter came
out. The line he was trying to sell me would no doubt result in my working
overtime in the beginning of the project and once again at the inevitable
crunch time. (They weren’t immune to scope creep.) So, in other words, they
were trying to sucker their programmers into constant, nonstop overtime. I
didn’t stay there too long.
Although a bad project manager can certainly throw things off track from
the very beginning, it’s possible for a seasoned professional to derail a perfectly
good project even at the last minute. I once found myself as the de facto proj-
ect manager on an effort that ran about a year and a half. I had a very small
team, all of whom were top-notch, seasoned programmers. Early on, we
adopted a few systems to keep us organized, including a bug-tracking database,
and for the first fourteen months or so, we had an uncanny track record of
meeting our milestones. No one on the team required any babysitting, and we
all just followed the procedures we had put into place and got the job done.
Toward the end of the project, one of the other project managers who was
an employee of the company (I was a contractor) decided to assume control of
our project. I didn’t bother to fight it as we were nearly finished, and frankly,
Chapter 2 Business is War. Meet the Enemy.
35

I didn’t mind someone else shuffling the paper for the last mile. This was a sig-
nificant tactical error. Our code, which wasn’t complete enough to be called
beta, was given to our most hostile customer because they were screaming for
it. The project team that ours had replaced failed to deliver to them even a
year past the deadline, hence their demise.
What followed was a series of crisis-management decisions as our coding
schedule was disrupted and reduced to fixing bugs or implementing features
that the customer made noise about. Further, the project manager expressly
refused to use our bug-tracking database, for reasons that escape me to this
day. Instead, each bug was distributed by writing up a document in a word
processor, complete with a screenshot. This was then printed out, additional
notes were written on the printout in red ink, and this was then photocopied.
The subsequent black-and-white copies were then distributed in piles on all
of our desks. I’ll leave the rest of the story to your imagination. This was at a
period of time when the Internet was just entering the public consciousness,
so in the end, of course, another team convinced management that our project
should be scrapped and they should rewrite it from scratch for Web browsers.
Given the disaster that had befallen our efforts, this was probably one of those
rare moments when the irrational logic of the corporate world actually did
some good by putting a wounded project out of its misery.
No Time or Resources for Testing
Without a doubt, my personal favorite target, though, is the lack of a profes-
sional quality assurance team in a shop. One would think that, with the incred-
ible complexities inherent in even a moderate software system, companies
would be extremely motivated to do a thorough and professional job of testing
prior to fielding the system. But then, logic does not always drive the manage-
ment decisions in our business. One of the most overwhelmingly consistent
mistakes I’ve seen in shop after shop is the omission of time and resources for
testing.
With the “logic” that I’ve just come to accept as normal in the business
world, most companies consider hiring professional testers to be an unneces-
sary expense. How they justify the money spent on extended software mainte-
nance and all those tech support calls is a mystery to me, but then I never was
all that good at accounting. In general, management perceives programmers
as a highly skilled set of workers, possessing the talents necessary to deal with
any complex technical task. However, they don’t view testing as a terribly diffi-
cult or technical undertaking, and therefore reason that, if we were smart
enough to write the program, then we should have no difficulty in testing it.
I will heartily agree that coding can be a complex task. However, most
managers grossly underestimate the difficulty of comprehensive quality assur-
ance. I’ll take coding over testing any day of the week. The idea of forming an
organized plan to exercise every aspect of a nontrivial software system makes
36
Part I Software Development in an Imperfect World

me twitch. I wouldn’t hire a plumber to tune up my car, and I’d certainly
want a trained professional if the electricity in my house needed attention.
Nonetheless, when it comes to the incredibly daunting task of regression test-
ing, the business world sees no need for specialized talents. Why? Actually
there’s a herd of reasons, but they never seem to hold still long enough for a
good group photo.
One of the best reasons is the perception that the programmers can test it.
I’m afraid the businesspeople just don’t understand the division of labor here.
I’m adept at creating bugs. If I could catch them just as easily, well, I wouldn’t
be adept at creating bugs now, would I? Of course, management often takes
the stance that anyone in the office who has a few spare minutes and can type
at least seventeen words per minute can test it. How hard can it be? Failing
that, of course, we’ll just beta test it and let our customers find the bugs for us.
Never mind what that makes the product look like to the outside world. Even
though it’s branded “beta” in big, bold letters, if the product flames out in the
field, it’s going to get a bad rap. But, then, why bother testing it at all? If the
customers find bugs in the release product, we can always just put a patch up
on the Web site, right? These are only a few of the justifications for not hiring
professionals to do a job that requires a high degree of skill and training. You’ll
notice that all of these solutions are approaches that don’t require spending
additional funds. I’m sure that’s just a coincidence.
Still, these aren’t the only obstacles to getting our software thoroughly
tested before it hits the streets. Management, not being technical, truly has no
concept of how tremendously difficult it is to exhaustively test all code paths.
Often, they don’t even know that there’s a completely different discipline of
technical workers who specialize in testing software. For those who do know,
they often find that software QA is such a small field due to lack of demand
that finding truly qualified testers is extremely difficult. I once was given the
go-ahead by a company I worked for to hire a tester after much lobbying and
fighting on the part of my team. Because we could hire only one, we looked
for a senior-level person, and we had a reasonable budget to do so. This was in
one of the major American cities with a good base of technical workers. In the
course of a year, we went through three people. None of them even knew
how to write a test plan. Writing up a bug with detailed steps to reproduce
was pushing the envelope. This is an unfortunate side effect of supply and
demand: with few jobs offered by companies, naturally very few people seri-
ously enter the field.
Thus, much of the testing process is left to the project managers and
teams. Even if you can find someone who understands how to set up an organ-
ized bug-tracking system (yeah, I thought it was obvious too, but apparently
not), there are still many obstacles to creating some homegrown testing proce-
dures. Typically, management doesn’t want to spend the money for additional
computers and the various operating systems and platforms that are needed to
realistically test the software in all scenarios. Again, it’s perceived as a business
expenditure that doesn’t bring any benefit in terms of dollars and cents gained.
Chapter 2 Business is War. Meet the Enemy.
37

There’s also the mantra of management when it comes to programming: they
don’t want to pay testers out of the development budget because, if it’s not
coding, it’s not software development.
Oddly enough, another reason that we don’t have better testing systems in
place is that some programmers actually don’t want people finding bugs in
their code. It’s probably just an ego thing, or the fear that if people find bugs
in your code, then maybe management will think you should be fired. I had a
friend who worked for another of these large, international companies in an
environment where they actually did pay for a QA team. Unfortunately, the
system they set in place for motivation was a bit counterproductive. The
testers got points for each bug they found, and, for each bug that was found in
their code, the developers lost points. As you might have guessed, these points
translated to bonus dollars. Of course, there was a highly adversarial relation-
ship between the testers and the programmers. I can’t fathom why a company
would want to foster that sort of confrontational environment. Personally,
when someone finds a particularly glaring bug in my code, my first reaction is
gratitude. It’s going to show up sooner or later, and I’d much rather someone
find it now so I can fix it. Found a bug? Thanks! Better here than in the field!
The biggest reason of all, though, that we don’t have a professional QA
department in every shop is that programmers simply don’t fight for it. We
fight for design considerations, technologies, tools, and even for nice, big mon-
itors (not the cheesy little ones that tend to be flung out the fifth-floor win-
dows during crunch time). What we don’t fight for is testers, and we pay for it
on every release. The business bottom line pays for it as well, although that’s
something that our MBA friends fail to recognize.
Poor Company Management
In fact, although it’s not really a technical matter at all, poor business manage-
ment in general can have far-reaching effects on a software development
project. Even though the Suits provide the paychecks and run the company,
bad decisions at this level can sabotage a project before it even gets started.
Constantly canceling projects and starting new ones can make a mess of
the occasional effort that actually does make it through to completion. More
often than not, those programs that do see the light of day end up being some
strange, mutated beast that’s a hybrid of the fourteen failed projects that came
before. It doesn’t take much imagination to know what sort of a fiasco this can
be. Perhaps companies that manage themselves in this manner think that
they’re showing nimble reflexes and an ability to quickly adapt to each new set
of circumstances. I’m sure that sounded good on paper when they were study-
ing for their MBA. However, out here on the streets, it’s nothing more elegant
than a well-ordered series of train wrecks. 
I’ve known of major corporations that reorganize their departments a
couple of times a year almost as if by decree. The result is invariably a host of
38
Part I Software Development in an Imperfect World

partially completed projects being canceled due to the restructuring. This, in
turn, brings about the obligatory political activities as people vie for control
of these orphaned efforts. Unfortunately, rather than just letting them die an
ignoble death, the politically savvy often manage to resurrect a project and
morph it into their own plan. This is more disastrous than the worst scope
creep, as the existing code base is augmented with a new set of directives that
may have little to do with the existing design and architecture. If you remem-
ber the old adage that a camel is nothing more than a racehorse designed by a
committee, you have the idea. For a developer who happens to be on one of
these teams, it’s an endless exercise in confusion and frustration of the highest
degree. People always think I’m kidding about monitors and fifth-floor
windows.
Following the buzzword of the week can also lead to frequent require-
ments changes. This has little to do with design or architectural issues, and
programming isn’t the only community with buzzwords. For the management-
oriented worker, there is a never-ending stream of management trends pro-
moted in the marketplace. Each of these is touted as the salvation of
businesses everywhere and is eagerly embraced by companies that give more
heed to talking the talk than walking the walk. If you’re involved in meetings
with these guys, you may have a hard time keeping a straight face. So many of
the phrases you hear spouted with much seriousness sound so phony and shal-
low that even a first-grader would catch it. Others are pompous, overworded
descriptions of an obvious fact. I encountered one example of this kind of
thinking working for yet another large corporation.
I was to develop some communications code on the PC side of the house
that would talk to minicomputers in a different department. The job was fairly
small in scope, and all that I really needed to do was sit down with the com-
munications guy who had coded the interface to which I’d be talking. This
wasn’t rocket science. So, a meeting with the other programmer was arranged.
However, because it involved programmers from two different and warring
departments, it just wasn’t that simple.
My manager, sharp and politically savvy, knew what was about to happen
and volunteered to come along and watch my back. I’ve learned to trust this
guy in such matters and so readily agreed. Attending the meeting were my
manager’s boss (who was middle management of the most stereotypical kind),
his counterpart in the other team, the upper-level managers responsible for
both of these middle managers, and the vice president in charge of the upper
managers. Five—count ’em, five—levels of managers, including a vice presi-
dent, all gathered together in a meeting at which I simply needed to ask
another programmer for a couple of header files and the description of the
interface API.
I had pretty much reached the end of my patience on this particular gig
anyway and consequently wasn’t feeling very diplomatic because my ten-
minute meeting now went on for an hour, as these managers all went through
their dances and posturing while the two programmers just sat there listening.
Finally, seeing a break in the action, I asked the room full of Suits what on
Chapter 2 Business is War. Meet the Enemy.
39

earth they were doing here as I still hadn’t had the chance to have the conver-
sation I called the original meeting for. It was curtly explained to me (as if to
a small child) that, although I certainly couldn’t be expected to understand
management matters, it was important for all concerned to “sign off on the
process.” That was one of their catch phrases. I don’t remember if anyone
other than my programming counterpart on the other team saw me roll my
eyes. As I had finished the project for which I’d taken the original contract,
I decided then and there that it was time for a new gig.
Bureaucracy and maintaining the status quo create a corporate culture in
which the resistance to change takes on an almost fanatical pitch. Whether it’s
a set of procedures that were handed down on stone tablets from the company
founder or it’s a management style similar to the story I just told, keeping in
step with the way things are done is mandatory for anyone wishing to climb
the corporate ladder. You must look like everyone else, adopt the same man-
nerisms and procedures, and in general be seen as someone who follows the
established practices, regardless of how unproductive or even disastrous they
may be. In such an environment, excellence and innovation are not just dis-
couraged, they’re actively punished. We’ve all had to suffer through the prolif-
eration of the phrase “thinking outside of the box,” but the simple truth is that
the minute you do you may as well paint a series of red concentric circles on
your posterior, for you’ve become target practice. Anything that doesn’t follow
the norm is suspect and makes you subject to reprimand or worse. Should you
actually follow the intent of the catch phrase and get way outside the box,
things are not going to go well with your career.
I once worked on a small team that had the task of kicking out a database
system for internal company use. Like any such venture, coming up with the
perfect user interface to make it easy to grasp and manage a complex collec-
tion of data was a challenge. I worked for one of those guys who actually
believed in pursuing excellence and didn’t even own a box. In other words, he
already had a reputation as a troublemaker, at least as the corporate world saw
it. Being a video game enthusiast, he observed that in today’s Hollywood-
production-quality games, the user had to deal with a ton of information, all
in a real-time environment. That meant you either got the information you
needed quickly or you were soon to be little more than a wisp of computer-
generated smoke wafting to the heavens as your enemy stomped on to the next
conquest. From that perspective, it made perfectly logical sense for him to
show us one of his favorite games to point out the user interface techniques
they used to accomplish this. So, here we are, three developers gathered in a
cubicle around a monitor deep in the heart of the corporate world playing with
a very conspicuous game. Naturally, my manager’s boss chose that moment to
happen by the cube. Needless to say, he wasn’t impressed with our manager’s
initiative or original thinking.
Of course, while not a direct result of this incident (it was just one of a long
string in this person’s career), it probably isn’t too surprising that he’s no longer
with that company. Ultimately, in the corporate world, those who promote
change are labeled troublemakers and demoted to positions where they can’t
40
Part I Software Development in an Imperfect World

cause any more trouble. Although this guy was nimble enough to avoid demo-
tions, neither did he advance, and he was frequently the target for harassment
by middle management. It’s only natural that he would eventually seek
greener pastures, and so a company loses yet another individual who could
have made them more profitable. Worse still, when he left, the company prob-
ably felt that they were better off. It’s a strange world.
Internal Politics
If poor company management and business practices are the officers in the
front lines of the enemy, then internal company politics is the common soldier.
Decisions are almost never made because it’s the best thing from a business
point of view. They’re made because they further the interests and career of
the decision maker. These two concepts—doing what’s best for the business or
what’s best for the career—are often completely at odds with each other.
As anyone who has ever witnessed a real shooting war will readily attest,
such conflicts are a monument to pointless waste and destruction. There’s lit-
tle difference in the business world. Although we rarely break out the auto-
matic weapons to solve our conflicts (well, if we forget about maintenance
programmers for the moment, anyway), there is still no end to the amount of
time and resources wasted in the petty struggles of departmental turf wars.
In the end, it’s all about individual grabs for power. Somewhere in the process,
though, it seems to be forgotten that we were hired to develop software.
Consider a common example. Your team and another have both developed
projects for internal use. A new company-wide software initiative is underway
to consolidate all the functionality of the many disparate systems into one
cohesive system. This, of course, will establish the team who develops it as
dominant and relegate the other to a status of irrelevance, reducing it to per-
form the unpleasant tasks that no other programmer wants to do. The pro-
grammers may even be absorbed by the winning team to serve a similar
function. If you work in either of these two teams, the outcome of who gets
the project and who doesn’t is an extremely significant factor in how pleasant
your job will be in the months or years to come.
Every kind of business and even personal political tactics you can imagine
get employed as the two teams compete. None of this has much to do with
writing code at the moment, but it will most certainly affect the code you write
in the future. If you don’t believe it, just sit on your hands and wait for the out-
come. If you don’t fight, you will, without a doubt, lose and most likely find
yourself relegated to life as a maintenance programmer in the deepest, darkest
bowels of some system that no one wants to touch. Suddenly, politics have
everything to do with the code you write. The fact that these obscure mainte-
nance jobs are sometimes on systems that manage inventory control for auto-
matic weapons may explain a thing or two, but you’re still not going to have
any fun with your coding.
Chapter 2 Business is War. Meet the Enemy.
41

Of course, similar struggles can arise within your own team, as each mem-
ber jockeys for a position that allows him to work on the sexy new technology,
gain control over design, get concessions over which languages to use, and so
on. The results are almost always the same. Those who are adept at political
maneuvering typically get the juicy assignments while the technical prodigy
who stood by silently gets the leftovers, regardless of who has the most appro-
priate technical skills and experience.
Maneuvering for promotions is another aspect of the same sort of thing.
Middle managers with no technical knowledge often want to advance their
careers by having control over your department. It expands their kingdom, and
in such matters, those vying for power consider any addition to the territory a
good thing. Sometimes project managers want to be middle managers and act
more like Suits than programmers. Worse still, they forget their most sacred
mandate: to protect their programmers from external politics and distractions
so that they can code. Even at a lower level, team leads or programmers occa-
sionally think they should be in charge of the current project instead of the
project manager. This creates even more games and posturing. How do we
ever get any code written in the middle of all of this? Well, sometimes we
don’t, which is why we should care.
Religious wars over technology and platforms are another common skir-
mish. Your team does PC development. Another works on mainframes. Each
wants the company to use their team as the primary platform for software
development. Just as in the example of the struggle for the internal software
system project, these platform wars have similar fallout. Additionally, though,
people in these conflicts are often true believers, those who sincerely advocate
that their platform is superior to all the rest. If the general confusion of turf
wars isn’t bad enough, you can count on a lot of hurt feelings in this sort of
struggle, as such people are very emotionally attached to their positions. It
may well have been in the midst of just such a scuffle that the first whiteboard
eraser was thrown.
Even when we retreat to our secret hiding place of closed-door design
meetings, we’re still not immune to the effects of maneuvering. Think design
meetings aren’t political? Many is the poorly considered software feature that
was an absolute disaster and yet made it to market only because a better tech-
nical solution had a weaker presentation in the meeting. Anytime you have a
room full of people, you have politics. The people who choose to ignore this
fact are always the first victims.
The Unexpected
Of course, no discussion of the enemy would be complete without mention of
The Unexpected. It is one of the few constants in the universe. You can’t con-
trol it, you can’t foresee it, and none of your contingency plans cover it. It just
42
Part I Software Development in an Imperfect World

happens and is as inescapable as the sun rising each morning, or the program-
mer who is still frantically coding away trying to hit an unrealistic deadline
when it does. Although you can’t adequately position yourself to be immune
to it, you can strengthen your ability to cope with it. As simplistic as it sounds,
this is often little more than making sure you always have margins in your
plans to account for the time it will take when an unannounced little disaster
drops by for dinner. Simple though it may be, it’s amazing how often compa-
nies neglect to do just that.
It is both a truism and an exercise in the obvious to state that you can’t
really solve your problems until you know exactly what they are. The ground
we’ve covered is by no means comprehensive, but it does bring to light the
many factors that conspire against us in our efforts to be productive software
developers. Ultimately, the very first survival skill that front-line programmers
must possess is the ability to look at their own environments and recognize the
dangers and obstacles to developing and delivering quality software. It is only
with this heightened perception that we can hope to effectively combat the
countless enemies of the professional developer.
Chapter 2 Business is War. Meet the Enemy.
43

But I just wanna be a programmer! Why do I need all of these non-coding
skills? Can’t I just sit in my cubicle and concentrate on programming?
Sure you can. In fact, the overwhelming majority of programmers world-
wide do just that. Of course, the overwhelming majority of programmers
worldwide also have an extremely common set of complaints about their jobs.
The simple reality of the matter is that your job is probably not anywhere near
as good as it could be, and neither is your software. We’ve already identified
a large number of culprits that appear to be responsible for the problems we
encounter, but, when it all comes down to the bottom line, it’s your fault.
Ouch. Can I say that? Well, perhaps, if only because I’m safe for the moment
from the sting of a whiteboard eraser.
How can all of the shortcomings in your software development shop—so
many of which are typically caused by managerial decisions that exhibit about
as much common sense as a lima bean—be your fault? Simple. If you sit on
your hands and do nothing, then you’re part of the problem when you could
be part of the solution. Wait, that sounded a bit like one of those trendy catch
phrases. Maybe I’ve been hanging out in the corporate world too long.
If I’m suggesting that you take a more active role in dealing with the issues
you face as developers, I suppose it’s not that different from asking you to
storm a machine gun nest. Of course, all those years of dealing with mainte-
nance programmers has undoubtedly prepared you better for such a task. Still,
to be practical about it, anyone taking risks should have a reason for doing so.
In other words, what’s in it for you?
What’s in It for Me?
Probably one of the biggest hassles in any full-time programmer’s career is sac-
rificing your life to countless hours of unproductive—and very often unpaid—
overtime. It’s bad enough that you’re given a situation where you can’t get the
45
Good Coding Skills Are
Not Enough
3
C
H
A
P
T
E
R

job done working forty hours a week. The way most businesses are run, the
end result may well be yet another release disaster, even if you put in eighty
hours a week. That’s not exactly a rewarding experience, particularly if you
have to give up your life for it. When we fire up the editor, what we’re reach-
ing for is the next killer app. We are artists as much as anything else. To put
blood, sweat, and tears into a project (okay, maybe not the former if you don’t
have to interact with the maintenance programmer) only to have management
ship it in a half-baked state can be downright infuriating, and that’s with a full
night of sleep. I have no desire to work day and night as it is. Doing so on a
project destined for failure adds insult to injury.
Along those lines, one of the things that are in it for you as an artist is the
ability to ship a better-quality product. Whether your name is in the About box
or not, your signature is on every piece of software you ship. We all tend to
take a great deal of pride in our accomplishments, so who wants to be associ-
ated with anything other than a spectacular success? Do I work for money or
for ego? Both. (In that order, for the record, but definitely both.) If you want
to be involved in projects that make you proud, you have to do your part to
help them survive in the wild.
Actually, I’ve always had a pretty bad attitude towards companies that take
advantage of programmers and expect them to dedicate their every waking
minute to the job. Maybe it’s because I’ve been a musician all my life and
have seen how nightclubs and other aspects of the music industry tend to pay
almost nothing. They get away with this because they know we love music so
much that we’d probably play for free and are usually happy to take whatever
we can get. A low-paying gig on the weekend is more fun than no gig. Because
of this, bar gigs pay today almost exactly what they paid twenty years ago—
really. It’s an unfair and predatory practice, but is so common that it’s become
the accepted norm. If you push for more equitable pay, you’re simply told that
they’re not doing anything different than every other venue in town. That’s
typically true, but it doesn’t make it right.
Many software development companies employ this exact approach in
dealing with programmers, and for the same reasons. We got into this business
because we were passionate about programming. We tend to do it at home in
the evenings and on weekends just for fun. With the same predatory attitude,
these sweatshops take advantage of our love for development and make con-
tinual overtime an accepted norm.
I have a friend who is a programmer working in such an environment. In
fairness, I must say that he was told up front in the interview that, due to the
stock options giving the employees a sense of ownership in the company, they
hired only those people who were willing to dedicate above-average hours to
the job. Nonetheless, he has been killing himself the past few weeks working
late hours. I made some of the usual jokes with him regarding end-of-the-
project crunch time and asked when the release date was. His answer floored
me, even though it’s nothing new. He said there was no deadline; it was simply
a corporate culture. If you weren’t putting in all the extra hours, you just
weren’t working hard enough.
46
Part I Software Development in an Imperfect World

When there’s an honest-to-goodness crisis, you can count on me each time,
every time. I’ll be the guy with the sleeping bag next to my desk. Obviously,
my friend sees it as worthwhile, and he’s a pretty sharp guy for whom I have a
lot of respect. However, this sort of open-ended abuse of programmers consti-
tutes a gig that I wouldn’t touch with a ten-foot pole.
Consequently, for years now, I have employed a somewhat unorthodox tac-
tic for avoiding sweatshops. I live in a major city, and there always seems to be
plenty of work out there for my particular skill set. Consequently, when I go
out for interviews, I do so with the desire of landing a job that I really want.
By the time I actually get down to the normal face-to-face interaction with the
company, we’ve already done a lot of the dance and it’s a foregone conclusion
that I’m potentially a good fit. They wouldn’t bother to interview me other-
wise. So, we go through all the normal motions where we each do our best to
convince the other that we’re something that life is just not complete without.
When it’s just about all said and done and things look good, I ask about the
kind of hours that they’re working on average and if overtime is a frequent
flyer in their world. I’ve found that a good many managers don’t want to be
honest with you about this because they figure it would be harder to get peo-
ple to sign on. They’re certainly correct. So, just to make sure that I’m not
being suckered into a sweatshop environment, after they’ve assured me that
they don’t work much overtime, I happily agree with the philosophy, telling
them that I have enough going on in my life that I like to get my job done in
forty hours a week. I then tell them that as a seasoned developer it’s my per-
sonal conviction that, if you’re unwilling to pull the occasional all-nighter at
crunch time, you should get out of the business. However, I feel that any com-
pany that has a crisis every week and that requires constant overtime is a
company with extremely stupid management, and I have no desire to work
for such morons.
The truth is that, if the conversation has indicated to me that I’m not the
only programmer in the room who curses like a sailor, I use much stronger
language than “extremely stupid” because I really want to make a point.
Having done so, one of two things usually results. Either they were telling me
the truth in the first place about little overtime, in which case we’ve agreed on
yet another topic, or they’re lying to me. If the latter, I have just terminally
insulted them, and there is no way in heaven or earth that they will hire me.
Which is exactly my intent. When times are tough, you take whatever gig you
have to in order to survive. However, under normal circumstances, there’s
plenty of work in our business, and life is too short to work for abusive
companies.
Does all of that sound patently unprofessional to you? Perhaps it is.
Nonetheless, ask me how many sweatshops I’ve worked in. Now, I spend my
nights and weekends living my life while others toil away hour after hour,
pushing themselves closer and closer to burnout. I’m a decent programmer,
but many folks in this business are much, much better than I. And yet, I get
paid as well as the next guy, and I work forty-hour weeks. Why? Because I
realize that, to have a gratifying career, good coding skills aren’t enough.
Chapter 3 Good Coding Skills Are Not Enough
47

The ability to consistently meet your deadlines is indeed another benefit
that we can gain by looking beyond our technical abilities. Above and beyond
the obvious fact that if you’re hitting your goals in a well-organized fashion,
you’re not killing yourself with pointless overtime, being successful and pro-
ductive tends to lower your stress level and makes you less likely to be
harassed by management. We get up each morning and spend a very signifi-
cant portion of our days working for a living. If that experience is unpleasant,
then simple math tells us that a very significant portion of our lives is unpleas-
ant. Who wants to live like that?
Of course, if you regain control of your programming life, you can spend
more time coding and less time putting out fires. I realize that, technically
speaking, coding is coding, but that doesn’t mean that I enjoy it all equally.
My personal preference is to sit undisturbed writing new code on a project
that sparks my interest and enthusiasm. I can assure you, I’ve spent many,
many hours coding in scenarios that were nowhere near my preference. So
have you. I could have gone to school and learned to do a great many things
for a living. 
I became a programmer because it was a way to pay the rent that was actu-
ally fun. If I’m not having fun, I feel cheated. Consequently, I care a great
deal about any aspect of my job that could interfere with the enjoyment of my
work, for when I’m enjoying what I’m doing, I’m giving it heart, body, and
soul. That’s good for me, that’s good for the project, and that’s good for the
company. I believe strongly in win-win scenarios.
Naturally, one of the things we want to do is work on the cool projects
instead of the stuff nobody wants to touch. Who cares if you’re using the pro-
gramming language and environment of your choice if the task you’ve been
given is dull, tedious, and probably destined to never see a real, live user any-
way? The cool projects, as you have no doubt observed, tend to go to the peo-
ple who make an effective effort to get them. That sexy new project has to go
to someone. Why not you?
I once worked a contract with a friend doing development on a data-entry
product that had an extremely complex list of input validations that were dif-
ferent for each state in the country and for each new customer’s needs. The
approach that they were taking when we got there was to create a new
dynamic link library for each customer/state modification. This struck us as a
little cumbersome. We then found that their method of doing this was copying
the entire source codebase for one library, pasting it to a new directory, going
into the code, and manually changing anything that needed alteration. Above
and beyond the volumes of duplicate code, they even approached the position-
ing of images by changing magic numbers in the call to display the image,
compiling, viewing the image, taking a guess at how much it needed to move,
and repeating the process. 
My friend, being a serious veteran programmer, observed the obvious:
what this really called for was a custom screen editor and code generator, cou-
pled with common code libraries. Of course, we could have solved this prob-
lem in other ways that didn’t require a code generator, but in talking to the
48
Part I Software Development in an Imperfect World

other developers, we encountered massive resistance to the idea. They felt
that if there wasn’t a lot of code floating around, their job security might be
threatened. We both take a dim view of such poor ethics but were realistic
enough to know that we were swimming upstream in trying to fight it.
We approached the project manager, who was himself a programmer and
a good guy. He was newly arrived to this project and not responsible for the
mess of his predecessor. He enthusiastically embraced our idea and told us to
get to it. In the end, while the rest of the team slogged away copying and past-
ing code (my friend also observed that .cpp clearly stood for copy-and-paste
programming), we were off creating a cool new app using the latest version
of the operating system, all the new UI gadgets, and anything else that we
wanted to play with that we felt would make a better tool. 
When it was complete, work that took several programmers three months
to accomplish was done in a week or two by a single developer. After we had
moved on to new contracts, we heard that the project manager was promoted.
When a new manager came in, the developers got together, scrapped the sys-
tem we built, and returned to the old ways of copy-and-paste programming.
Who cares? We didn’t. I’ve long since spent that money. It’s my responsibility
to conduct myself in an ethical fashion and do quality work; what the company
does with it is its own affair. The point is that, although everyone else was
working on dull, boring, and tedious tasks, my friend and I were having a blast
kicking out a cool app and earning the high regard of the project manager.
Why? Because we both pursued talents beyond the technical.
The last reason I list in terms of what’s in it for you is no doubt one of the
most important. The ability to make better money has a lot to do with non-
coding skills. You do work for money, don’t you? I suppose I could have pur-
sued different avenues of programming that might make me a buck or two
more, but I like what I do. That’s a big deal, and without it, I think I’d just go
back to playing guitar in smoky bars. Life is too short to spend it doing some-
thing you hate, no matter how much it pays. Nonetheless, I’ve been broke
many times in my life (many of which had a curious relationship to the amount
of time I spent playing in smoky bars), and I don’t care for the experience.
Money ain’t a bad thing, and, if you want me to write code for you, money is
required. How much? Every last penny that I can negotiate, of course. 
The goal is not just to do what we love for a living, but to get paid
extremely well in the process. To accomplish both, you’re going to need more
than just your technical prowess. If you can code in technical utopia and also
have enough money to keep yourself stocked up on the latest bleeding-edge
gadgets, isn’t that worth a little extra effort?
Who Needs These Skills?
How do these various skills fit into the structure of the development team?
You may be thinking that much of what we’ve discussed thus far is of limited
Chapter 3 Good Coding Skills Are Not Enough
49

use to a production coder and applies more to those who pursue a management
career path. Actually, it’s never really that simple. I’ve never met a program-
mer whose job could be neatly packaged into one tidy little category. In the
real world, throughout the course of the project, we end up wearing different
hats at different times, even if the job description when we signed on was sup-
posed to be nothing but a coder.
Whether your part of the project is large or small, the same requirements
apply if you’re to successfully deliver your software. Chances are good that you
have some additional responsibilities beyond making sure that your code com-
piles without warnings and doesn’t cause smoke to pour out the back of the
box. (It’s true, though, that I once came back to my desk in the middle of a
debugging session to find a fire extinguisher in front of my keyboard. I can
assure you that there were no hardware problems—honest.) If that’s the case,
you’re going to need skills beyond the technical. However, even if you’re fortu-
nate enough to do absolutely nothing but code week after week, you still have
other responsibilities. At a minimum, for your project manager to be success-
ful in shielding you from the insanities of the corporate world, he’s going to
need your support.
You’re also going to be involved in meetings. If you never go to meetings,
drop me an email and let me know who the human resources person is at
your company. In any event, you’re going to find that you spend much of your
workweek doing things that don’t require compiling, debugging, or uttering
the occasional programmer’s expletive.
The size of your team may shift the types of skills you need, but whether
it’s large or small, you’ve got to be able to cope with the business world in one
manner or another. Small teams with a lot of individual autonomy require indi-
viduals with good organizational and navigational skills. If you’re working in an
environment where you’re given a task and are then left alone to make it hap-
pen, you actually end up doing a lot of project management whether you real-
ize it or not. (You can think of it as just being organized and focused in your
work if the “project manager” part makes you twitch.) Whatever you call it,
however, you have many of the same duties. You still need to be able to define
your requirements clearly, perform adequate design, and arrive at an achiev-
able timeline with milestones arranged along the way, just to name a few. Your
compiler won’t help you with any of this.
When working on larger projects with multiple teams, you’ll often
encounter as much corporate fumbling from within your team as you do from
without. You will likely have a dedicated project manager and perhaps a struc-
ture of technical leads as well, along with a hefty complement of program-
mers. Political considerations will be much more a factor in this environment,
as will issues such as how well meetings are run, the competency of your proj-
ect manager in partitioning tasks, how much interference you get from middle
and upper management, and many of the other things we’ve touched on thus
far. Remember, you’re at the bottom of the software development food chain.
Very little happens higher up that doesn’t have an effect on you, one way or
another.
50
Part I Software Development in an Imperfect World

You may also find yourself working in the capacity of technical lead from
time to time. Although that’s a testament to the confidence that others have in
your technical and organizational skills, this can be a thankless job with great
potential for burnout. 
A technical lead is often nothing more than a project manager with limited
scope who carries a full coding load. In other words, not only do you get to do
all the work you normally do as a developer, much of it technical and therefore
enjoyable, you also get to handle the managerial tasks that are relevant to your
team. If it sounds like you just inherited a considerable amount of overtime,
you’re probably not far from the truth. The trick to working this position with
any degree of success, which includes avoiding burnout, is to realize that you
can’t be a manager at any level, not even the team lead, and get a full day’s
worth of coding in. Depending on how large your team is and how much
organizational work you’ll have to perform, you should take your normal
level of coding assignments and knock off a quarter, or perhaps even half.
Unfortunately, technical leads are not always given the power to make such
decisions, which is why it’s often a real burnout inducer.
Of course, if you have a one-programmer project (and that happens a lot
in the business world), you’re the project manager, team lead, and coder all
rolled into one. If you thought that technical leads had a workload, you’ll just
love this one. Of course, there are some significant benefits to being a one-
programmer team. With no other team members to distract you or call you
into endless meetings, you might actually get some coding done. However,
never forget that there are always going to be managers above you. What
they’re called is irrelevant. Any way you shake it, they’re managers and that
involves all the normal issues of politics, bureaucracy, their effectiveness in
dealing with their own management, and all the rest. Additionally, just because
you’re the only programmer doesn’t mean that it’s wise to short-circuit the
requirements gathering, design, or estimation phases. The rules don’t change
based on the size of the project, although experience tells us that, if you’re a
one-programmer team, the chances are good you work in one of those places
where they expect to see code flying off your fingertips nonstop. Trying to get
a process in place is even harder when you’re the only one there.
Taking Control of Your Time
To be successful—and, even more important, to be recognized as such by
those you work for—you have to get the job done. This sounds too obvious to
mention, but sometimes it’s easy to overlook the obvious. It’s important to
keep in mind that businesspeople pay you because they want you to produce
something. If you really want to be good at your job, there’s more to delivering
the goods than coding. You have to keep in mind the end goal of the system
you’re developing and what it’s supposed to accomplish, and do everything
within your power and the scope of your position to see it through to completion.
Chapter 3 Good Coding Skills Are Not Enough
51

You may or may not be recognized for your extra efforts. You may not even
want to be recognized, for a variety of reasons. Nonetheless, your ultimate
reward will be in delivering quality software, on time and within budget, with-
out overtime, without stress, and without any other nonsense you can avoid.
Make this happen, and you put yourself in a better position for the next proj-
ect that comes up. Everyone loves a winner.
At every level of development, one of the constants is the need for effective
time management if you wish to meet your deadlines. Approaching software
development in a scattered and disorganized manner is going to significantly
diminish your results and increase the amount of time it takes you to get them.
Along with that comes a higher level of stress as you’ve never really quite got a
handle on what’s going on. This tends to leave you feeling rather breathless
and with the nagging suspicion that you’re always running behind. It’s proba-
bly a correct assessment.
I once knew a project manager who actually oversaw several development
efforts. This person always seemed to have several balls in the air at any time.
His office looked like a whirlwind of file folders, stacks of paper, and various
boxes of uninstalled software, and there were probably a couple of chew toys
from his dog in there somewhere as well. He constantly had a harried look
about him as if he were somewhere on the border between not being able to
cope with it all and the sheer terror that someone else was going to come yell
at him. All of his projects were behind, and he spent half his time dealing with
customers who were upset about it. This, of course, didn’t help free up any
time for him to solve the problems.
In short, this was one of the most disorganized managers I’ve seen. Little
wonder that his projects were a mess. In fact, what thread of cohesion that
actually did run through his various teams was the result of the personal initia-
tive of his developers, who wisely saw that they would get no support from
their manager and consequently took matters into their own hands whenever
possible. The interesting thing about this guy is that, not only was he over-
booked as it was, he never hesitated to take on a new project whenever he
could get his hands on one. Could he have handled this kind of workload effi-
ciently? Probably not in forty-hour weeks, but it didn’t have to be the disaster
that it was. It all comes down to organization. He didn’t know how to keep his
own ducks in a row, had no skills at planning or running a meeting, and inter-
acted with his developers only in a crisis-driven mode, dashing out in a panic
to tell them of the latest fire that they had to work late to put out. 
With better time-management skills, he could have taken control of the
various projects, avoided being yanked from one crisis to the next, and perhaps
even have delegated a little. Such things would have settled down his projects
tremendously. What’s that you say? It’s not your problem because you don’t
want to be a project manager? You’re just a programmer? Well, who do you
think he had working for him? If your manager is a mess, and many of them
are, you’re going to need all the skills you can get purely for self-defense.
52
Part I Software Development in an Imperfect World

Enhancing Design
System design is another area in which it’s handy to have some facility in
something other than compilers. It is certainly not a given that a good coder is
naturally a good software designer as well. Although obviously related, they
are two completely separate disciplines. However, you don’t have to know how
to code to work in an architectural capacity, and you don’t have to have design
skills to write source code. 
However, you do need to have a grip on the design side of things before
you start writing that source code. If you just shoot from the hip and don’t
think your way through things on a small scale the same as you would for
larger tasks, you’re likely to encounter difficulties either halfway through what
you’re coding or the first time someone else has to interface to your code. We
typically think of design in terms of mapping out the entire software system,
but, when you get down to it, you should always think before you code. Even
if management is inclined to believe that you’re daydreaming rather than
working.
One of the many reasons you need some facility with design is that, to
meet your deadlines, you’ll need to have some skills in estimating as well. It’s
true that an estimate is of little importance if you’re given the date before
you’re given the assignment, but sometimes you’ll have a manager who asks
you how long a task will take and actually pays attention to what you say. If you
can’t cook up a good estimate, you’re not only setting yourself up for failure,
but you’re also doing it to your manager as well. I’ve found that, in general, it’s
a bad thing to make the person who is responsible for your paychecks look
stupid to his own boss. People are funny that way.
Improving Interaction
One of the significant benefits to possessing more than merely technical skills
comes when you learn to improve your interaction with others. Sometimes it’s
courtesy, sometimes it’s being able to deliver the goods, and sometimes it’s
just plain old politics, but it’s always a beneficial thing that comes back to you.
When you come in to the office each morning, you don’t deal with a highly
specialized class of sentient office furniture. You deal with people. Okay, I did
once know someone who spent an inordinate amount of time talking to his
furniture but I gave him the benefit of the doubt and chalked it off to sleep
deprivation. If you keep in mind that you’re dealing with real, live, flesh-and-
blood people instead of nameless, faceless coworkers, you’re going to have a
much better time of it in the business world. The better your people skills, the
better your chances of getting what you want, whether it’s a new computer, a
new project, or more money. If you can also learn to be bilingual and speak
the language of businesspeople, there’s no end to the enhancements your pro-
gramming career can experience.
Chapter 3 Good Coding Skills Are Not Enough
53

For those of us who take our programming seriously, sometimes just the
ability to bring better software to life is reward enough. Interpersonal skills
help tremendously in this area as well. If you have great new ideas on how
your software should be designed or how a particular chunk should be coded,
you still have to be able to sell it to others if you want to make it a reality.
Proposing new ideas successfully requires more than flowcharts and white-
boards. Decisions are often made not because the facts overwhelmingly
pointed to a particular solution but rather due to the charisma of the individ-
ual making the presentation, whether it was a formal meeting or just a persua-
sive conversation in the hallway. Don’t feel as if you’re really overflowing with
charisma? You’d be surprised how much of that can be an acquired skill. We
weren’t all born movie stars. Many times, attention to the details of how things
work in the business world and learning a few navigational tricks are all the
tools you need to gain the respect and admiration of your peers and manage-
ment. Many programmers feel that they’ll never have much luck in the per-
suasion department because they weren’t born natural orators. However, if
you learn to speak the language of your audience, understand the things that
motivate them, and position yourself appropriately, you’ll be surprised how
often you win. I’ll be going into these things in more detail later, but I’ll touch
once more on a recurring theme here: you can’t win if you don’t try.
Probably the bane of programmers and cubicle dwellers everywhere is the
dreaded meeting. Some weeks, it feels as if all you’ve done is travel from one
meeting to the next. Sometimes it’s true. Ironically enough, many of those
meetings will be rants from higher-ups who wonder why the heck we’re so far
behind on our schedule. You’re probably not in charge of most of the meetings
you attend and therefore have to suffer through someone else’s poor skills at
organizing and running such gatherings. There’s only so much you can do in
that scenario, but you can help expedite the process at least a little. Further, if
you decide to get serious about your skills in meetings, others will notice, and
a small groundswell may result. A meeting run by an inept manager can be put
back on track, shortened, and made more productive when just a few of the
attendees understand some of the basics and are assertive enough to help the
process along. If you’re actually responsible for reducing the number or dura-
tion of meetings at your company, you’ll probably become a folk hero among
your peers. (Who knows? They may even name a conference room in your
honor.)
Getting What You Want
Something that’s not really as obvious as it seems is knowing what you want
out of life. The truth is that a very large number of people in this world just
don’t know exactly what they want. Just as it’s impossible to meet all the expec-
tations when developing a piece of software with poor or fuzzy requirements,
54
Part I Software Development in an Imperfect World

so too is it true in life. That includes your career. If you don’t know very
specifically what you want, you’ll have difficulty achieving it and probably
wouldn’t recognize it if you did.
My observations have led me to believe that a large majority of program-
mers got into this business much as I did. I started programming for fun, got
hooked, and decided that it would be a cool way to make a living. I then went
out and got a job. What exactly was I looking for in a programming career? In
retrospect, I had absolutely no idea. I just wanted to get paid to write code.
Having put a number of miles behind me by now, I have a much better
idea of what I want for two reasons. First, I’ve had enough experience to see
what’s out there, what I like, and what I passionately wish to avoid. Second,
and I think even more important, is the fact that at one point I sat up and real-
ized I was working with fuzzy requirements and decided to do something
about it. I actually spent time and gave serious, detailed thought to just exactly
what I wanted in my programming career. I then set out to accomplish it.
Naturally, it’s much easier to get what you want when you know what it is,
and I’ve had a very enjoyable career thus far. I’ve spent time doing the types of
things I wanted to do and have been paid well for it. This is not because I’m
any kind of superstar, one-in-a-million programmer. It’s simply because I
detailed my goals and desires, and then set out to accomplish them in exactly
the same way that I would approach turning a requirements document into a
good design and ultimately an implemented product. That involves little more
than taking one step at a time, always with an eye to the future. Of course,
from time to time, I revisit my desires and tweak the spec where necessary,
as what I want tends to change. I also spend a fair amount of time reviewing
where I am, where I’ve been, and how things are going so far in my efforts to
meet these goals. That helps me to make the necessary course corrections.
Many of us tend to spend our lives on automatic pilot to one degree or
another. I’m sure if you took a little time to yourself and gave it some thought,
you could come up with a pretty decent list of things you’d like to change
about your current job and perhaps your career or life in general. That’s a step
I’d encourage you to take. Be specific. Be very specific. What you’re defining
is the perfect world. Don’t leave anything out, even if you think it unlikely to
accomplish. Once you’ve done this, you’ll have a decent requirements docu-
ment from which to work.
The next step is to come up with a decent design doc. Take a look at where
you are in your career and start brainstorming, just as you would in a design
meeting, about how you might get there. Unlike as in software design, in this
exercise, it’s acceptable to leave some questions unanswered. You may not see
the solution at the moment, but new input or opportunities could come out of
the clear blue sky at any point in the future to help you chart a course for that
particular goal. Keep it on the requirements list. For all the other items, you’ll
end up with at least a beginning strategy and plan of action. Although this
doesn’t agree with all of the true software design methodologies, in the real
world, design tends to get tweaked as we go, benefiting from what we learn
Chapter 3 Good Coding Skills Are Not Enough
55

and steering around problems as we encounter them. So, too, will your design
doc that you create for your programming career be modified as time goes on.
I’ve heard it said that no battle plan survives contact with the enemy. Allow for
that flexibility.
Once you have a good design (which in any business is simply a detailed
road map for how to get where you wish to be), it’s time to give some attention
to implementation. You now know, in great detail, exactly what the perfect
programmer’s life is, at least for you. You have a strategy in place to make this
a reality. The next logical step is to start taking the necessary steps to realize
your desires.
When you have both your requirements and design docs sitting in front of
you, you’ll quickly realize that to meet your goals, you’re going to need a few
more tricks up your sleeve than just knowing how to avoid compiler and run-
time errors. That’s where we’re headed next. You already know how to code.
You’re good at it, or you wouldn’t have a job. Now it’s time to hone your skills
in all of those other areas so you can effectively combat the insanities of the
corporate world and achieve your objectives. With any luck at all, the result
will be more coding, more fun, and fewer encounters with nervous little dogs.
The last time I saw him, the watchman’s partner was sporting a camouflage
collar and jacket and was having a whispered conversation with the mainte-
nance programmer about inventory control.
56
Part I Software Development in an Imperfect World

GUERILLA TACTICS
FOR FRONT-LINE
PROGRAMMERS
II
P
A
R
T

For a host of reasons, software projects either fail to be delivered on time or
are released in an embarrassingly buggy and unstable state (and there’s actu-
ally an even more common scenario that combines these two). The most
frequent reason for these disasters is probably the arbitrary deadline.
Developing software is a highly complex pursuit with many interacting
considerations. One small change in a seemingly isolated area can have conse-
quences that ripple through the rest of the project like a stadium full of beer-
consuming sports fans doing the wave. It’s difficult to stop once it gets going,
and it won’t take much for things to get just a little out of hand. 
We already encounter enough surprises throughout the course of a project
to make any specified delivery date an exercise in fortune-telling to one degree
or another. However, meeting deadlines and delivering solid software is
indeed achievable, but only if all of the complexities and interdependencies of
the development process are considered when determining the delivery date.
Unfortunately, this is almost never the case in the business world. Instead,
programmers are handed drop-dead dates by which a system must be deliv-
ered. Of course, these dates all but ignore the intricacies involved in bringing a
new piece of software to life. The dates chosen by management are, in a word,
arbitrary. This is certainly not the only way to sabotage a project, but it is with-
out a doubt one of the best. Unless the final delivery date and a well-considered
set of interim milestones are selected with the same attention to detail as that
required by the coding itself, there’s little chance of your project surviving as
an unqualified success.
To remedy this situation, we must first acknowledge something that,
although seemingly obvious, is categorically ignored by the software industry as
a whole: reliable and achievable delivery dates can come only from developers
who have made a detailed and realistic assessment of the effort. No matter
where you sit in the food chain and no matter what your personal agenda,
this statement is the unblinking reality in the world of professional software
development. The facts do not change based on whether you like them.
59
Preventing Arbitrary
Deadlines
4
C
H
A
P
T
E
R

Were it otherwise, I can assure you that my first step would be to address the
escalating difficulty of getting a decent and affordable pizza these days.
Only a disciplined approach to the software development process can put
an end to arbitrary deadlines and the excitement that they invariably cause. In
this chapter, I’m going to define that process. Many of the major steps encom-
pass sufficient detail to merit subsequent chapters of their own. Consequently,
what we’ll focus on at this stage of the game is the overall approach that will
lead us to consistently accurate delivery dates with a more reasonable work-
week. What you do with all those overtime hours you don’t have to work is up
to you. Personally, I’d recommend a little extra sleep. You’re starting to look a
bit like the maintenance programmer.
Defining the Process
As any veteran of the business world already knows, it’s one thing for us to
declare a process, but it’s another matter entirely to persuade management to
follow it, particularly because these guys somehow have the impression that
they’re in charge. The tactics and techniques we’ll need to employ to win man-
agement over to our way of thinking constitute a large topic in and of itself.
Before we can sell anything to management, though, we must first understand
the details of the process that we’re promoting. Consequently, I’ll leave for a
later chapter the methods we’ll employ in convincing management to follow
our lead. I’ll leave graphic visualizations of the ensuing conga line to braver
souls.
A software development project has a number of facets, requiring efforts
from people of many disciplines to bring it to the intended audience. However,
we’re going to narrow our focus to just those issues that have a direct effect on
programmers. Consequently, whereas you might have guessed that we won’t
be including marketing strategies, we also won’t be touching on user docu-
mentation. The technical writer’s part in the project tends to run a somewhat
parallel path to that of the programmer. Other than the meetings that we must
attend from time to time to explain the software, it has little effect on our code
or our hours. What we will give our attention to is the dance between manage-
ment and programmer and the steps that each must take to ensure a success-
ful project. Because debugging is a part of the programmer’s typical day, we’ll
be looking at the testing process as well. After all, it’s much easier to have a
debugging session when someone has scared up a bug to chase.
First, let’s take a quick look at the overall sequence of events required to
bring a new software system to life, from the initial phase when management
decides they want a new program to the very end when the software is deliv-
ered to the target audience. To keep it simple, for those tasks that fall on the
software development side of the fence, I’ll just refer to programmers as the
group responsible for the task. In reality, some of these duties may be per-
formed by project managers, and others by team leads. Of course, in many
60
Part II Guerilla Tactics for Front-line Programmers

shops, the project manager, team lead, and production programmer all occupy
the same spacious cubicle and type with the same set of fingers. 
So then, what are the steps that we must take to generate reasonable dead-
lines and high-quality software? A well-behaved software project should follow
a certain sequence of events, but our project is not a straight-A student, mind
you. It has to exist within the confines of the corporate world, amid all the dis-
tractions and inefficiencies that line its corridors. Consequently, it will no
doubt cut a class here and there, but, when you have time for nothing more
than the essentials, the following steps are a summary of what you really need
to make it to release day in one piece.
1. Management states high-level requirements.
2. Programmers formalize the requirements in detail.
3. Management approves detailed requirements.
4. Programmers identify testing resources.
5. Management approves testing resources.
6. Programmers estimate duration of design phase.
7. Testers estimate duration of test plan creation.
8. Management approves design and test plan efforts.
9. Programmers perform design phase.
10. Testers begin development of test plan.
11. Programmers estimate duration of estimation phase.
12. Management approves estimation phase.
13. Programmers perform task partitioning.
14. Programmers perform detailed estimate in hours.
15. Management may allocate additional programming resources.
16. Programmers define timeline with incremental milestones.
17. Management approves the timeline.
18. Programmers begin implementation.
19. Testing begins when software deliverables are available.
20. Programmers complete implementation.
21. Testers perform full regression testing.
22. Programmers define integration procedures.
23. Programmers implement installation program.
Chapter 4 Preventing Arbitrary Deadlines
61

24. Testers perform full regression testing including installation and
integration.
25. Testers approve beta release.
26. Beta testing begins.
27. Testers perform free play testing in parallel with beta.
28. Beta testing complete.
29. Testers perform full regression testing including installation and
integration.
30. Testers approve product release.
31. Management or marketing begin distribution.
32. Programmers collapse in corner and sleep for three days.
As you can see, our list has quite a few steps. Chances are good that some
of these steps are absent in your environment. Shucks, for that matter, some of
the players (notably testers) may also be absent from your environment. Don’t
worry; one of the most important aspects of a successful development process
is realism. It doesn’t matter how great a plan looks on paper if there’s not a
snowball’s chance that it’ll fly in your actual corporate environment. That’s
where many strategies fall short. It may sound great at a technical conference
to mandate that you generate a pile of design documents large enough to
ensure a visit from your local “Save the Rain Forests” committee, but the
minute you try to implement such a procedure, you may find that manage-
ment is less than supportive of the time required. Consequently, flexibility is
key in all of our subsequent endeavors.
Additionally, although it would certainly be nice to simply post the list on
the company bulletin board and declare that all steps will be followed, you’ll
more typically find that an all-or-nothing approach to restructuring your devel-
opment process translates very quickly to nothing. In other words, it’s going to
take time to change the way things are done in your company, and for a variety
of reasons. Not only do you simply have to fight the status quo that prefers to
do things the way they’ve always been done, you must also establish credibility
before you can gain control. That’s perfectly natural. Everything looks good on
paper. It’s your job to convince management—not only through persuasion
but, more importantly, through results—that life just goes better when the
programmers are in charge of the programming. Therefore, you must be pre-
pared from the very beginning to fight a longer battle with incremental suc-
cesses, eventually leading to a completely restructured software development
process. This may very well span multiple projects, with management giving in
more and more to your approach with each improvement that they see. It’s a
longer road, to be sure, but you weren’t planning on giving up programming
anytime soon, were you? Let’s take a look, then, at the steps we need to take
on the road to the mythical stress-free release.
62
Part II Guerilla Tactics for Front-line Programmers

Commissioning a New Software
Project
In the beginning, management decides that the company’s life is just not com-
plete without the addition of a new software system. At this stage of the game,
it’s unrealistic to expect a highly polished, detailed set of requirements. For
all their faults and foibles, pointy hair notwithstanding, it is indeed the job of
upper management to think in terms of the big picture. In fact, when you
have upper or even middle management trying to direct the minute details of
your daily job, it’s called micromanagement. That’s the sort of thing that sends
maintenance programmers scurrying to review the inventory control program.
To upper management falls the task of charting a general course for the com-
pany to follow. They are aided by input from both marketing and middle man-
agement, of course, and together they will arrive at a set of loosely defined
requirements that justify the time and expense of a software development
effort. This is a good thing. Most of the beneficial software we have in this
world started out life in the conceptual stage as ideas of a general nature.
Of course, not all programs have their genesis in the hallowed halls of
upper management. They may be proposed by marketing or even deemed
desirable by those in middle management. In fact, while we’ll touch on this
in more detail when we start looking beyond projects and more closely at the
individual programmer’s long-term career, many a software project is con-
ceived and proposed by the actual worker bees of the software environment,
the front-line programmers. Left to their own devices, programmers would
probably just sit around and write new software anyway, so it’s not much of a
stretch of the imagination that they would come up with proposals for projects
to benefit the company as a whole.
Regardless of the origination, however, the requirements are expected to
be loose and general at this stage of the game. The emphasis should be on
identifying the problem to be solved or the benefits that the new software
bring to the party. An idea must survive this phase of the process on business
merits alone. The proposed new system must either generate revenue directly
or enhance a business process that translates to increased profits, either
through reduced expenses or the ability to more efficiently generate revenue.
If the program won’t do at least one of these two things, then no matter how
cool the technology or how trendy the approach, the idea should make its way
into the nearest recycle bin with all due haste. Our purpose in being here is
to benefit the company, no matter what we would prefer to be doing with
our time.
Such decisions are the responsibility of management. Should they choose
to field a new piece of software that doesn’t meet one of these baseline
requirements, it won’t affect your life in terms of the development effort. A
stream of such decisions that generate expenses without enhancing profitabil-
ity will, however, eventually kill your company. Even though it’s not your job to
run the firm, always maintain an awareness of the business decisions made in
Chapter 4 Preventing Arbitrary Deadlines
63

your company. It’s much better to update that résumé before your company
files for bankruptcy or is acquired by another firm that knows more about
manufacturing dog food than it does software. Certain members of the secu-
rity staff may greet the latter scenario with enthusiasm, but it’ll do little for
the care and feeding of the local programmers.
Once the decisions makers have decided that there is sufficient justifica-
tion to kick off a new development project, it’s the programmers’ turn to take
the field. This is a crucial area that is all too often skipped, particularly in
smaller shops. It is a great temptation to take the general requirements
announced by management and begin working on the design or code. In fact,
this is what will most likely happen by default. But, to start developing some
discipline in your company, this is where you must take your first step and
make your presence known.
Identifying the Requirements
Once given the general directives regarding the new system, the programmers
should then begin asking questions. The types of questions are bounded by
the fact that the requirements phase, high level or detailed, can be summed
up by a single notion. At every step of the way and every level of detail, you
must ask for specifics on exactly what the program must do. This requires the
persistence to ask again when the answer is vague or ill defined. Sometimes
you’ll find that the people you’re asking don’t really have a clear picture them-
selves. They may not even realize this until you start asking very precise ques-
tions. Nonetheless, you must dig in at this point and resist moving forward
until you have a very explicit definition, in writing, of what your software is
expected to do. 
The importance of this phase of the process cannot be overstated. Your
ultimate success is judged by your ability to deliver the software requested of
you by the agreed-upon date. If you don’t have an extremely clear definition
of what the software must do, there’s no way for anyone to know if you suc-
ceeded in your task, even if you do make the deadline. Furthermore—and
even more dangerous to those of us who will roam the halls at three o’clock in
the morning—should the project fall behind schedule, if the software require-
ments are not chiseled in stone tablets and hung from the highest ceiling
beyond the reach of meddling hands, your task list will grow while your date
remains unchanged. This is how the death march begins, and it is to be
avoided at all costs.
Not only is it the programmers’ responsibility to lead management by the
hand in generating a set of detailed requirements, it also falls on our shoulders
to set some boundaries. Once you’ve managed to define the requirements (a
step that I’ll detail in a subsequent chapter), you must then identify the ulti-
mate authority over the project and get that person to sign off on the require-
ments document. This signed document gives you a task to perform that,
64
Part II Guerilla Tactics for Front-line Programmers

albeit large, is explicitly defined. It is to this signed requirements document
that you will link the project’s delivery date, which you will determine after the
estimates are done. That delivery date is the when part of the equation, the
requirements document defines exactly what is to be done, and the design
document (which we’ll also look at in a future chapter) states how it is to be
done. That’s the contract.
Having made the requirements document a publicized matter at the
beginning of the project, you have some ammunition further down the road
when someone comes along and wants you to add additional features. You are
then able to state in an unemotional and businesslike manner that the current
deadline is tied to the approved project requirements, but you’ll be delighted
to add any new features that they desire. However, because we’ve changed
the requirements from which the date was originally derived, the date must
naturally be reevaluated as well. Either the requesting party backs off, or you
update your stone tablets and delivery date and life continues in an orderly
fashion. Reasonably speaking, if you have sufficiently detailed requirements
and you’ve done a good job of designing and estimating your effort (including
time for the unexpected), there’s no reason why you shouldn’t meet your dead-
lines every time. Of course, the more deadlines you meet, the more credibility
you have with management, which means that they’re more likely to allow you
to do things your way in the future. It’s a process that tends to snowball as you
continue to succeed.
Building Your Testing Environment
Now that management has signed off on the detailed requirements document,
your project is an official reality. If you work in a company that already has a
well-defined and well-staffed quality assurance team, you’re way ahead of the
game. For most of us, though, the company has been unwilling to put money
into building such a capability. What this means is that, in the end, your soft-
ware will hit the streets with very little testing and most of that being fairly
haphazard. Thinking ahead at this stage of the game can help save you from
such a fate. Just as there’s no way for you to provide an accurate estimate with-
out detailed requirements, so too are your testers at an extreme disadvantage
without a detailed plan. Furthermore, if you don’t have trained professionals,
it’s not fair to expect them to know what to do in the first place. This is another
area where you can step in and act proactively.
Chances are good that when management decided to authorize the proj-
ect, they envisioned the coding and debugging and maybe even a little beta
program. That’s about as far they can see, and it’s certainly as far as the testing
considerations typically get. Just as it was the responsibility of the programming
department to take the initiative and create a detailed requirements document,
so too is it our task to create a quality assurance process where none previously
existed.
Chapter 4 Preventing Arbitrary Deadlines
65

Again, you start by identifying the person with the authority to allocate
such resources and asking questions, with an ultimate goal of identifying which
individuals will be available for testing, what their availability will be on an
ongoing basis, and what their level of computer experience is. You might find
the last statement a bit curious, but I can assure you that from time to time
you will encounter people chosen to test software who think that a mouse is a
rodent requiring an underfed feline and that a keyboard is something you see
on the stage of the better-equipped rock bands. Even with such limitations,
you’re often consigned to either take what you can get or take nothing at all.
It’s best to know what you have to work with up front so that you can factor
into your own schedule the additional hand-holding that they’ll need. A tester
you trained yourself is far superior to no tester at all.
Questions about testing at this early stage will frequently surprise manage-
ment, just as detailed requirements did, and so it is critical that you nail down
your testing resources up front. Parallel to your development efforts, testers
will need to devise a test plan so that it’s ready to go when the software is avail-
able to test. No resources means no test plan, and that means no testing of any
dependable nature.
In addition to identifying the individuals who will be available for testing,
this is also the time to get hardware commitments. Depending on the specifics
of the system you’ll be putting together, you may need an isolated network, a
certain class or combination of computers, particular types and versions of
operating systems, external computer hardware or hardware simulators, and
many other such items. Failure to acquire these resources will mean that the
first testing in these environments will be by your customers, which is guaran-
teed to generate stress and increase consumption of antacids. It’s also much
harder to debug something from a customer’s description than it is in the rela-
tive safety and comfort of your own lab.
It’s a good idea (if it’s at all possible) to get these resources committed to
you in writing. The future is always uncertain, and there may come a time
when you need to defend your claim to the people or hardware involved, as
other departments will almost certainly be vying for control of them as well.
Although having it in black-and-white doesn’t mean you won’t end up arm
wrestling for it anyway, such a signed agreement gives you more ammunition
when you get down to the nitty-gritty. And you can never have too much
ammunition out here on the front lines.
Entering the Design Phase
Now that you have identified your testing resources, the next major task for
the programmers is the design phase. This obviously takes some time, but
without having done sufficient work in this area, there is no way to accurately
estimate how much time it will take to deliver the system.
66
Part II Guerilla Tactics for Front-line Programmers

It’s unrealistic to expect management to casually sit back at this point and
wait for you to finish the design at your leisure. They have a business to run,
and other departments are affected by your release schedule. Additionally,
programmers cost money, and every week you spend on design adds to the
overall expense of the project. It’s certainly a justified expense, but no man-
ager in his right mind is going to sign a blank check. Neither would you, in
their position. Consequently, you not only need to perform the design phase,
but you must first give management an estimate of how long it will take. Such
an estimate allows them to coordinate the other departments and the flow of
the development effort in general. It also keeps them in control of the expen-
ditures, and managers like that sort of thing.
It’s worth noting at this point that the word estimate gets used a lot in our
business. The truth is, if you look up the word in a dictionary, you’ll find that
it’s tantamount to an educated guess. If you take your car to the shop and ask
for an estimate of the repair costs, the final bill may indeed be more. No one
likes these kinds of surprises, but the mechanic will be quick to point out that
what you were given was an estimate, not a guarantee. This is all true enough,
but in our business, it’s also completely irrelevant. At every level of the food
chain, an estimate—no matter how rough—is understood to be a commitment
rather than an approximation. I have tried over the years to educate manage-
ment about the difference between an estimate and a hard-and-fast guarantee;
I would have spent my time more productively had I taken up knitting classes.
At least I’d have something warm to wear in the winter. No matter how loudly
you say it, the bottom line is that, in our business, an estimate is considered a
commitment. That’s just the way it is. Consequently, I’ve become more creative
in my estimating process to give me the room I need to cope with this fact.
At the same time that the programmers are estimating the design phase of
the project, the testers (assuming such creatures actually exist in the wild) are
creating similar numbers for the time required to write the test plan. If you
don’t have professional testers available, and most of us don’t, then the people
who will ultimately perform the testing must come up with the estimates for
developing a test plan. In the common scenario (wherein you don’t have
trained testing professionals), this means that the testers are going to need a
fair amount of help from the programmers. This does increase your workload,
but anything that you can do to improve the testing process ultimately yields
tremendous benefits to you personally, so it’s well worth the time and effort it
takes to support the testers. Consequently, you’ll need to determine how much
time and effort on your part that they’ll need and add it, as a separate line
item, to your estimate for the design phase. No, it doesn’t really fit there logi-
cally, but it is during this same time that you’ll be helping the testers, so this is
the estimate you bundle it in with.
Having delivered time estimates for the design and test plan phases, you
once again appear at the doorstep of your favorite manager’s office, pen and
document in hand. In addition to getting the required approval, we’re also
doing a little conditioning here. After a while, management will become accus-
tomed to your asking for specific documents and signed approvals. As it
Chapter 4 Preventing Arbitrary Deadlines
67

becomes the norm, you’ll have to fight a bit less for it each time. That’s one of
the benefits to an incremental approach. I’d toss in a metaphor about old dogs
and new tricks, but I’m not sure how much legal representation the canine
portion of the security force has. I understand that night watchmen have a
pretty good union, and it’s never a good idea to tempt fate.
Now that management has actually agreed to allocate time for the design
phase, a major victory in and of itself, you’re back in familiar territory. Although
we’ll be covering the details of a compressed design phase in subsequent
pages (because you won’t ever get as much time as you want), programmers
are generally comfortable with this part of the process because it concerns
actual programming issues. However, at the same time that you’re performing
your design, you will most likely be helping your untrained testers develop
their test plan. The reality of this is that you may well have to all but write the
test plan yourself until they get the hang of it. As a result, your design phase
will be interrupted a bit more than usual. It’s also worth nothing that preparing
the test plan continues beyond your design phase. That’s because, although the
requirements doc drives much of the test plan, the specific test cases them-
selves will have to be written in terms of the user interface you provide.
Naturally, the details of the user interface won’t be available until you com-
plete the design phase, which means that you must also factor in time for
helping the testers as you move into subsequent stages of the process.
Estimating the Effort
Having completed the design of your new system, you’re now in a position to
give a legitimate, well-considered, and accurate estimate of how long it will
be before management can wrap their fingers around the mouse and take the
new software for a spin. You may notice that I intentionally avoided referring
to how long the implementation phase will take. That’s because there are more
steps to delivering the software than simply calling its code complete. There
will be installation programs, integration issues, and rounds of regression test-
ing and beta testing, all of which must be performed before the software can
be shipped. You need to factor these into your estimates as well.
Just as we’ve done in prior steps, the next duty for the programmers is to
deliver to management an estimate of how long the estimation phase will
take. Yes, even the estimation needs an estimate. It’s going to take some time
to do it right, and this is actually the point we’ve been building up to all along.
I’ll bet you thought that the coding was the part we’ve been building up to.
Actually, the point of this entire process, at least from a programmer’s perspec-
tive, is to do the organizational work up front and arrange life so that, when we
actually do get to sit down and fire up the editor, we can have as much fun and
as little stress as possible. To do that, however, we have to take the estimating
phase very seriously. If we do this job properly, from this point on, we’ll be
dealing with realistic deadlines and maybe even normal business hours.
68
Part II Guerilla Tactics for Front-line Programmers

I’m not terribly excited about staring at a spreadsheet all day, but, just as
women have told me that the pain of childbirth fades quickly from memory,
so too is this task quickly forgotten and even appreciated once we fall into a
smooth coding groove.
Once management has signed off on the time that it will take us to per-
form the estimate, we must first take a look at task partitioning before we can
start crunching numbers. In all but the most trivial systems, there’s going to be
more than one programmer involved. As it will ultimately fall to the individual
developers to do the lowest-level estimates, it’s only common sense to give
them the piece of the puzzle that they will end up implementing. Although
management may allocate additional programming resources to you after
reviewing the estimate, you typically start with at least a core team of senior-
level developers. It’s a good idea to remind them when doing their estimates
that the actual coders who perform a given task may well have less experience,
so it’s a good idea to temper the numbers with the realization that you won’t
be able to count on a senior programmer’s productivity in all areas. We’ll get
into more detail later when we come to the chapter on estimating, but for now,
it’s sufficient to know that all estimates are done in terms of the actual hours it
takes to perform a task, not in calendar days. Calendar days, and their deriva-
tive dates, are calculated based on these hours.
Once the programmers have turned in the estimate, written in detail for
the programmers but summarized appropriately for management’s consump-
tion, the brass may determine that additional resources will be required to
move the project along at a rate consistent with their desires. This may also
happen after you’ve delivered the timeline. If it does, you will, of course, have
to rework the timeline, but management will be happy to give you time to do
this, as an earlier release date is what they were after when they gave you the
additional resources.
In any event, once you have the hours and know what resources you have
to work with, you’re in a position to extrapolate actual milestones and delivery
dates. You need to consider a number of other factors when creating this time-
line, including vacation and holiday schedules, the number of coding hours
per day, and other such practical considerations. Nonetheless, giving attention
to these details, you again show up on the doorstep of your manager. He’s
probably already reaching for his pen.
This is the big moment and one you most certainly want documented in
indelible ink. This is where you hand your manager a timeline complete with
delivery dates and he approves it. Get it in writing. Get it in blood if you can,
providing that doesn’t violate any state or federal statutes. Attach a copy of the
signed requirements document so that the two are inextricably linked. Once
he has put his name on the dotted line, make a copy of the signed documents
and take them home. Think I’m kidding? Not even a little. I’m also not wanting
to appear cynical or paranoid, but the corporate world is a strange and some-
times bizarre world in which rules and codes of good conduct just don’t always
apply. Some people change their minds, others pop up from different depart-
ments with their own agenda, and not everyone operates in an honorable or
Chapter 4 Preventing Arbitrary Deadlines
69

aboveboard fashion. People frequently try to weasel out of commitments or
even deny altogether that they ever made them. Signed documents are a little
harder to deny. However, things sometimes mysteriously disappear in the
cubicle world, and believe it or not, there are times when the watchman’s dog
is truly innocent. You’ve busted your tail to get a signed copy of the require-
ments and the timeline for the project. Protect your investment.
You have now made a commitment to deliver a very specific piece of soft-
ware on a very specific date. After all that I’ve been through in this business,
this is one situation that I’m actually quite comfortable with. If you blow the
deadline after these steps, it’s because you didn’t do a good enough job some-
where up to this point. However, you’ve been given a fighting chance, and
that’s all that most developers have ever really needed. The date bearing the
manager’s signature—and yours as well—is one that was carefully considered
and based on reality as you know it in your company. I would venture to say
that, if all programmers were given this opportunity, the state of the software
industry would change dramatically for the better.
Coding Bliss
In the time that all of this has taken, you’ll probably want to order the upgrade
to your programmer’s editor that was released while you were nose deep in all
of these non-coding tasks. Then it’s time to fire up the espresso machine, put
on the headphones, and enjoy some time in coding bliss. However, you won’t
work without interruption. In the corporate world, there’s always a meeting or
two that you get dragged into (kicking and screaming, no doubt). There’s also
the likely reality that your testers are not professionals and will consequently
require a fair amount of support from you just to give you the support that you
need in the form of thorough testing and well-documented bugs. Even so,
you’re now doing what you signed up for. You’re coding. Enjoy the moment.
Without a concerted effort on your part, you wouldn’t have spent all the
time leading up to this point doing non-coding tasks. This process will not be
in place by default; rather, it is something you have to work for. No matter how
much time you spent on it, however, you’ll more than make up for the hours
you spent away from the compiler between here and the release date. Your
software will ship on time, you’ll sleep on at least a semi-regular basis, and you
will be able to hold your head high and be proud of the quality when your
product reaches the users. Who knows, the maintenance programmer may
even take you out to lunch. Time will undoubtedly heal any rifts between you
and our trusty attack Chihuahua as well, but don’t count on that happening
anytime soon. He’s still in therapy from those monitor incidents.
70
Part II Guerilla Tactics for Front-line Programmers

Testing the Candidates
You still have a few steps to take before you’re home free, though. Testing
will proceed as soon as you have software deliverables available. There will be
bugs, and this means the standard test-debug cycle with which we’re all famil-
iar. This will actually be a more pleasant experience than usual, however. If
you’ve trained your testers properly, and you no doubt have, then they will be
giving you bug reports with detailed steps to reproduce the bug. That, my
friends, is programmer’s heaven. As we all know, reproducing the bug is the
hard part. It’s all just coding from there.
Although the testing is an incremental and ongoing process that follows
the software along as it progresses, the programmers will ultimately reach the
point of being code complete. At this point, the testers will run a full regres-
sion test, which is effectively a process whereby they run every test case in the
entire test plan. Should any deficiencies be encountered in this process, the
bugs will be fixed and the appropriate tests performed for the specific prob-
lems identified. When the last of the individual bugs have been fixed and the
relevant tests are run, the testers will once more run the full regression test,
top to bottom. The goal is to make it through the entire regression test from
beginning to end without finding any deficiencies. Once this is accomplished,
the software is ready to move to the next level. Resist the temptation to just
run the tests that verify your bug fixes. You know full well how one part of the
codebase can influence another. Running the entire regression test from top to
bottom is the only way to know for sure that the system is solid and that the
bug fixes didn’t create other problems.
Addressing the Installation Issues
Now that the product has been certified as solid and without known issues by
the testers, it’s time to turn your attention to the installation and integration
issues that will need to be addressed prior to actually shipping the software.
Although at a minimum there’s typically an installation program to write that
was no doubt included in the original programming estimates, additional steps
often need to be performed to field the system.
The installation program, and any other programs and scripts that the
installation procedure requires, must be tested like any other program. This
means wiping out the computer and starting with a fresh operating system or
environment from scratch, installing the program, looking for any defects in
the installation procedure, and documenting the deficiencies in the exact same
manner as was done for the software system itself. This can get a bit tedious,
Chapter 4 Preventing Arbitrary Deadlines
71

as for each pass, the operating environment must be certified to be completely
fresh and representative of what the end user will have when installing your
product. Nonetheless, the installation process is considered complete only
when the program can be installed in a stable and dependable manner on a
fresh system and the integration scripts are certified bug-free. Of course, the
same must be done for any uninstall programs. (This is why you can’t just run
uninstall each time instead of refreshing the operating environment. You can’t
trust the uninstall program to provide the baseline for testing, because it, too,
is a program under test and therefore suspect.)
When both the installation and uninstall procedures have been certified
by the testers, the full regression test must be run once more on a freshly
installed system. Any defects found at this stage of the game will set you back
a couple of steps. You must fix the bug, run the individual tests, and then per-
form the entire regression test before moving on to the installation test. Once
that passes, you again perform the regression test on the newly installed sys-
tem. Seem like a lot of extra work? Perhaps, but this is the only way that you
can be absolutely certain that the user experience will be a solid one from the
first moments of installation all the way through each feature of the software.
Any shortcut in the process only leaves you vulnerable to bugs in the field.
Nobody wants that. Especially after the maintenance programmer was nice
enough to buy you that cheeseburger.
Managing the Beta Phase
Once the testers sign off on the system, again in writing, your system is now
ready to move to beta testing. If you have any control over the matter at all,
you should choose beta participants with great care. Remember that when
customers see your product for the first time, it makes a lasting impression.
It doesn’t matter that they know it’s a beta release. It doesn’t matter that
seasoned developers everywhere know that beta is probably an acronym for
Bugs Expected To Appear. The customer will run the program, somehow man-
age to trigger a code path that no one caught in testing, and crash the system.
This experience leaves a sinking feeling in the customer’s stomach that
your system just isn’t stable or trustworthy, and that feeling never completely
goes away. “Well, of course it’s not stable,” you might reply. “It’s in beta testing.”
That doesn’t matter. Although nothing may even be said, that impression will
live on in his mind, and it will be reflected when he speaks of your product.
Furthermore, if the customer doing the testing is one who has experienced
any degree of dissatisfaction with your company in the past, it could trigger an
entire series of events that in the animal kingdom would look very much like a
small, hairless canine gnawing on someone’s ankle.
In other words, although you want to get your software field-tested in the
very harshest of real-world environments, you should not ignore certain politi-
cal and image considerations. When at all possible, choose customers who love
72
Part II Guerilla Tactics for Front-line Programmers

you and who can be counted on to actually test the system rather than bet the
farm on it. If your beta testers put your system into play in the real world
where they have real live dollars and cents at risk, you can count on some very
unpleasant experiences. Chant it to them over and over so that they can reflex-
ively recite it to you on demand: Don’t get attached to any data created in a
beta system. It will go away. In a perfect world, you won’t have to make such
tradeoffs, but, if push comes to shove, you should choose a less-demanding
beta participant over one who could shake down the software better but would
cause bad publicity or much gnashing of teeth. It’s not fair to subject your soft-
ware to the criticisms of the real world just yet. You haven’t released it.
When the system has made it through the full cycle of beta testing and no
more bugs can be shaken out of it, it leaves the hands of the customers who
were kind enough to test it for you, and the focus moves back to the testing
department. Again, if you have any control over the matter, all traces of the
beta product should be obliterated from existence on the customers’ comput-
ers, leaving not so much as a smoking floppy disk on which it once resided.
Take a magnet to the floppies. Break the CDs in half. Walk through the cus-
tomer sites and reformat their hard drives. Burn the documentation. Erase
the name of the product off any stray whiteboard where it may have been
written. You want every last vestige of the test system to be nothing more
than a fleeting memory. Hopefully a pleasant one.
Why get so nuts over wiping out traces of the beta? If you don’t, then
somewhere, somehow, sometime, when the customer’s business is at its most
critical moment, your system will crash in full, living color. Perhaps even a very
striking shade of the color blue, depending on the operating system for which
you develop. Some time later, probably around three o’clock in the morning, it
will be discovered that the crash was caused by some incompatible or buggy
piece of the beta that was left lying around and somehow got mixed in with
the production system. Worse still, it’ll be the maintenance programmer who
finds it.
Now that your program once again exists nowhere in the world other than
in your own software development lab, to the testers falls the task of running
the full installation and regression test one last time. By now, it’s probably
going to be a seamless experience. However, if it’s not, now is the time to find
out. When the software leaves the testers’ hands at this point, it will do so once
more in writing, for this is your certified release, ready for deployment. It’s
time to open the champagne, or at least fire up the cappuccino machine, and
celebrate. You’ve just done something that few developers ever get to partici-
pate in. You’ve released a solid, full-featured software system, on time and
under budget. Now go home and get some sleep. All that racket from the
celebration is keeping the night watchman awake.
Chapter 4 Preventing Arbitrary Deadlines
73

The Curse of the Casual Requirement is a classic thriller guaranteed to scare
the pants off programmers everywhere. It’s a bit of a sleeper, though, as the
scary stuff doesn’t happen in the beginning. Unlike most mysteries with
the good guys winning in the end and the blame falling on the butler, in our
little story, the good guys lose and they never really could afford a butler to
begin with.
The software development process begins with an idea for a program. This
idea is typically about as fuzzy as those socks that get lost behind the washing
machine. When the programmers first get wind of management’s desire for
new software, only two paths can be taken. The first is the default direction, in
which the programmers do nothing and begin designing or coding based on
whatever nebulous requirements they were given. The second direction is
more arduous: the programmers must fight, scratch, and claw for every single
detail that they can get and make sure it’s documented in explicit and unwa-
vering language for posterity. In other words, this entails getting the specifics
and generating a paper trail to be used at the end of the project, or at any
other point in which the developers need to defend themselves.
If you already follow an organized, structured, and effective requirements-
gathering process, you don’t need guerilla tactics. Instead, you should probably
spend more time hanging out in the coffee shops that programmers frequent,
as you’re sure to get the local hero treatment. For the rest of us, trying to get
management to cough up the details and commit to them in any form more
tangible than the spoken word is harder than trying to herd a corral full of
greased pigs into a room for a bath. And, no, I’m not going to draw any further
parallels. My own management may be reading this, and I’ve grown rather
fond of my paychecks arriving on a regular basis.
Make no mistake: if you leave room for people to wiggle on the interpreta-
tion of a requirement at some future point in time, they will. At the very last
minute. Furthermore, an imprecisely worded requirement is an open invita-
tion for scope creep. Even if you do everything right from this point onwards,
75
Getting Your Requirements
Etched in Stone
5
C
H
A
P
T
E
R

either of these can throw you into a frenzy of overtime when you’re one week
away from the deadline. The requirements will suddenly change, and of
course your deadline won’t.
You might be tempted to argue that you were hired to write software, not
manage the company, and so therefore it’s not your job to make the require-
ments specific. The requirements should be that way when they come to you,
and whoever wants the program has the responsibility of making this so. In
terms of the world I’d like to live in, you certainly won’t get any arguments
from me. However, it’s also a well-documented fact that the world I’d like to
live in entails much more money, offices with real walls, and the complete
absence of middle management by federal decree, just to list the ones that can
be printed. In the world that we step into each day to do our jobs, things work
a little differently. Because we’re at the bottom of the food chain, we rarely
have the luxury of demanding much of anything. And, because the require-
ments for the software we write comes from those who outrank us, we typi-
cally receive them in a wide variety of forms, with none of them organized
and very few of them detailed. Consequently, it is in fact our job to make sure
that the requirements are explicit and well documented before we begin our
design. It simply won’t happen otherwise, and we are the ones who will ulti-
mately pay the price at the end of the show. Where’s a good butler when you
need one?
You Don’t Have to Like It.
It Just Has to Be Clear.
Even though we tend to get a little possessive about our programs once we
start working on them, when it comes to requirements, it doesn’t matter if
we like them or not. The only thing that matters is that they are precise and
unwavering. Whether you’re a mercenary or a full-time employee, you’re a
hired gun in management’s eyes: they brought you on board to write the soft-
ware that they needed or wanted, and your job exists for no other reason.
I worked for one company that tasked my group with writing a database
system to manage customer information. As this was a national firm, part of
our requirement was to keep the data up to date in thirty cities. The decision
was made at a higher level that this should be done with a replicated database,
with each city having a copy of the data. When any one city would update
information, databases in all other cities were to be instantaneously updated
via the corporate WAN. We implemented this system and delivered it, on
time and under budget. It was at this approximate point in time that Internet
became a household word, which, of course, meant that it was one of those
trendy things that middle management felt we should be using. Therefore,
mere weeks after we finished installing the system that they asked for in
thirty cities, the word came down to us that all the data should reside on one
76
Part II Guerilla Tactics for Front-line Programmers

computer at a single location and access should be provided to the thirty cities
via a Web browser interface. Consequently, the system that was now installed
and serving its purpose was to be thrown away and completely rewritten from
the ground up to provide the exact same functionality. I don’t count beans for
a living (unless you want to include coffee in that equation), so I have no idea
how much money they threw out the window on this project. But it makes me
feel a little better about all those flying monitors.
Note a couple of important points from this example. First of all, it’s obvi-
ously incredibly wasteful to implement a system, field it, train the users in its
operation, and then immediately scrap it just to do the exact same thing on a
different platform (and for no other reason than to be trendy). However,
that’s not my problem. I’m hired to write software, not manage companies.
Furthermore, if they want to pay me twice to write the same system, my bank
makes little distinction when it comes to the deposits. In other words, because
it’s not my company, choosing which programs to implement or what their
requirements should be is not for me to say. If I feel strongly about the matter,
I need to quit and start a company of my own. Otherwise, it’s my duty to
implement the decisions of the people who hired me.
That being said, the second thing to note here is that the amount of money
this company wasted was probably enough to keep me on a beach with a full
margarita glass for a good year or two. The reason this money was pointlessly
spent was due to a fundamental mistake in the requirements process. In the
very beginning, before a programmer had even heard of the project, manage-
ment was specifying how it should be done, when the requirements phase is
about what, not how. They threw suitcases of money out the window simply to
change how something was done when the business needs had already been
met. Unfortunately, the evening that the money went flying out the window
the night watchman and his partner were on vacation, which is truly a shame.
It might have paid for all that therapy.
If you want to spend your time coding a system that inspires you person-
ally, you may have to hang out a shingle and go into business for yourself. I’ve
been asked to write a lot of things that I didn’t find particularly riveting. I can
live with that. All I ask is that, if you’re going to bore me to tears, please go
about it in a very precise manner. If you’d like for me to write your system
twice, that’s just fine with me as long as the second iteration is just as explicit
as the first. I will give these folks credit for one thing: they had no idea what
they were doing, but they could explain that to you in great detail.
Where Does the Power Lie?
Regardless of how much sense it makes to implement a particular software
system, when it gets to our desks the question is not “why should we write it?”
but rather “what exactly should we write?” If we can get satisfactory answers to
the latter, preferably in writing, then we’ve got a fighting chance at meeting
Chapter 5 Getting Your Requirements Etched in Stone
77

the deadlines that will eventually await us. The first step to take in getting
these requirements nailed down may seem like an exercise in the obvious,
unless you’ve been wandering the halls of the corporate world for a while.
As programmers, we are not in a position to declare that a piece of software
is complete. Rather, someone above us in the food chain must sign off on the
system and call it done. Who is the person who has that authority? Is it one
person, or is it some formal or informal consortium that must be satisfied
before we can put the code, and ourselves, to bed? In short, who makes the
decisions?
Until we have identified this person or group, we don’t know who to turn
to both at the end of the project when we’re done and in the very beginning
when we want to get the requirements etched in stone. It’s a common mistake
to assume that, if our boss comes to us and tells us to write a program, then he
must be the decision maker. I can assure you, particularly if he’s middle man-
agement, that he has about as much authority over the definition of the project
as you do. If you put your fate in his hands when it comes to the requirements
phase, you may as well stock up on espresso. You’re going to need it. The way
it typically works in any company large enough to have a layer of middle man-
agement is that people positioned above your boss are the ones who truly need
to be satisfied with the programs you write. Chances are good that the man-
ager you directly report to is not a programmer. Consequently, he has neither
the training nor the motivation to press his managers for more detail on a proj-
ect. In fact, he’s likely to avoid just that sort of thing, as people who make too
much noise in the business world are often put on the slow track when it
comes to promotions.
If you work in a smaller company, you may not have much middle manage-
ment to deal with. This doesn’t mean, however, that the person who asks you
to write the program is the only one who needs to be satisfied when the coding
is done. People from other departments may be involved. If you work in a ver-
tical market, there may well be important customers who have a say as well.
Basically, anyone who wants to put their finger in the pie and has enough
political clout to gain entry to the game must be taken into consideration.
No matter what your company’s structure, when the word comes down to
your team that there’s a program to write, the very first and most crucial step
to take is to quickly and accurately identify the people who have the final
decision-making authority over your system. Once again, you may be tempted
to shrug this duty off to your project manager and turn back to your compiler.
However, you must bear in mind that you’re on a team. In our business, the
fate suffered by one is shared by all. If your project manager is stressed out
and living in overtime city, it’s a pretty safe bet that you will be, too. One of
the nice things about working on a team, though, is that you have more people
to apply to a task. This will come in handy, because identifying the major play-
ers can require a bit of detective work and you won’t have much time to figure
it out.
Know up front that there are times in our business when you must make a
choice between taking action that involves some political risk or suffering the
78
Part II Guerilla Tactics for Front-line Programmers

consequences that are sure to befall your project if you don’t. If there were a
simple prescribed set of rules that every company recognized that would allow
you to operate within your normal chain of command and accomplish all that
you need to deliver your software, you wouldn’t face this dilemma. These rules
don’t exist. If you’re a good boy, you’ll trust those above you in the food chain
and simply do what you’re told by your immediate superior. You probably
won’t get yelled at much, I’ll grant you. However, if one path offers a little
political risk, the other guarantees the evils that we suffer on every release.
I decided long ago that I’ve had enough of pointlessly chaotic releases.
Politics Are an Inescapable Reality
In fact, I also made a decision about politics in general many years ago. I used
to have a philosophy that many programmers share: I just wasn’t going to get
involved in any of that political nonsense. I was a programmer, I was there to
code, and if everyone else wanted to stand around the watercooler and play
little power games, then fine. I had serious work to do. I eventually ended up
in a small company on a project that required only a couple of programmers.
My project manager, who was the head of development, was actually a solid
database programmer. So solid, in fact, that he kept his head buried in a data-
base and actively avoided any project management duties.
The programmer initially assigned to this project was a sharp guy, but he
was one guy too few for the deadline that was dictated. The manager was
pressed to beef up the team a little, and I wanted on the project. It was tech-
nology I wanted to play with, and I liked the guy that was already on it.
However, a new guy who didn’t have even the most fundamental grasp of the
programming language itself, let alone the technologies, was available. Not to
be uncharitable, but let’s just say that no amount of experience was ever going
to make this guy a good programmer. Some folks have it, and some don’t.
Nonetheless, having to deal with the issue at all was a distraction that kept the
manager from enjoying his database programming, so the new guy was quickly
assigned to the team so that the manager could return to his fun.
Naturally, the project’s progress deteriorated rapidly as the original coder
had to not only do his own job but babysit the new guy and clean up after him
as well. Several weeks went by, and the manager was pressed to get the project
back on track. Obviously, the solution was more bodies. This time, due in no
small part to the lobbying effort of the lead programmer, I was assigned. We
decided that the first thing that needed to be done was to lighten our load by
one body so that we could get some work done. I was a very vocal person, and
the lead programmer was much more politically savvy. So, I confronted the
manager without so much as the slightest regard for diplomacy and had the
guy reassigned to the equivalent of scraping gum off the bottom of chairs. In
retrospect, I may have made some comments about how stupid it was to have
assigned this clown in the first place. I was also rather forceful and demanding,
Chapter 5 Getting Your Requirements Etched in Stone
79

because we were already working overtime and this guy was making matters
worse rather than better. As I said, I wasn’t interested in politics, and I saw it
as a simple, cut-and-dried technical matter. This wasn’t a particularly bright
thing for me to do, but I didn’t realize it at the time.
In the end, we delivered the project two weeks late after many all-nighters.
That’s not on time and under budget. However, in our business, being two
weeks late is also a little better than the average. Nonetheless, when it was all
completed, I suddenly found myself in the manager’s office. By the time I got
back to my cube from the conversation, my network login and my job were
both history. The stated reason was because the program was late, but curi-
ously only one of the two programmers was fired. The truth of the matter was
much more simple: I ticked off the wrong guy, and I paid for it.
Incredulous, particularly after I had just killed myself with overtime in the
name of being a dedicated employee, I went to one of the company owners.
He was a good guy, and he just told it like it was. He agreed that the situation
was bogus but pointed out that my manager was the head of development
and, unless there was an extremely compelling reason to override him, he had
to back him up. He then told me something that lives with me to this day.
He said that I knew as well as he that, while technically I was being treated
unfairly, politics were just as real and valid a consideration in business as any
other aspect. He was half right. What he said about politics was true, but I
didn’t know that at the time. I decided then and there that although in the
future I may lose political battles from time to time, I would never, ever again
lose because I didn’t play.
The lead programmer, who had much more common sense than I, contin-
ued to rise in the company. He’s still a friend to this day, and he continues to
do well in the programming business due to the unbeatable combination of
good technical abilities and good political skills. And, although I certainly
haven’t won every battle I’ve fought, I have never again ignored political
realities.
The example I’ve just given has nothing to do with defining the require-
ments for a software project. However, it has everything to do with how you
get them. As we were considering, chances are good that the people who must
be satisfied before you can stop coding and get some sleep are further up the
food chain than your immediate manager. This poses a dilemma. If you go
over your manager’s head, you risk ticking off the person who can eliminate
your source of income. On the other hand, if you don’t, you’re not going to
have any time to spend your money anyway, as you’ll always be at the office
coding away to ever-changing requirements. I’ll discuss some ways to commu-
nicate directly with the decisions makers in a moment. For now, it’s sufficient
to say that your first step is to identify the people who truly have sign-off
power on the software. Between you, your fellow programmers, and a bit of
asking around, you’ll find it’s usually not that hard to figure out once you
decide to look.
80
Part II Guerilla Tactics for Front-line Programmers

Identifying the Other Influential
People
Having made note of where the power lies, the next thing to jot down is less of
a political issue and more of a practical one. Any system is going to have some
domain experts—that is, those people who have the business experience rele-
vant to the system being developed. For instance, one of the projects I’ve
worked on involved software for air traffic control. A couple of the guys at the
office used to work as controllers, and they were considered domain experts
because they had worked the position and knew what a controller needed out
of software. 
It’s important to know which domain experts will be involved in defining
the requirements of your system because these people bring a very practical
perspective to the software you will develop. In the end, people will use your
program to accomplish a set of goals. The more input you can get from domain
experts, the better your software will be. It’s also worth mentioning that these
people typically have some degree of political clout, or management wouldn’t
have let them participate in defining the software to begin with.
If it’s possible for the type of work you’re doing, it’s also a good idea to list
some actual users, the real people who will be using the system. They often
have a perspective that’s very different from anyone else, and they can also
help you clarify the requirements. It’s better to hear their voice now than to
wait until the software is fielded, they don’t like it, and you find yourself
redesigning the thing in the beta testing phase of the project. It happens.
I realize that I often paint a picture of the corporate world as a place in
which common sense is never a priority and people are always scheming,
unreasonable, or just plain hard to work with. Although this is the case often
enough to make it foolish to ignore, a great many programmers live in an envi-
ronment that’s more accurately a combination of this sort of nonsense and
groups of smart, practical, and dedicated people. If I emphasize the bizarre
aspect of the business world, it’s only to make you realize that there’s a little
bit of that in every company. Actually, there’s a lot of that in some companies.
Therefore, it’s counterproductive for you to ignore it. 
We’re going to assume for the moment that much of the chaos in the
development cycle is due not to people who are unwilling to make the neces-
sary changes, but rather to the fact that those in the upper ranks of manage-
ment simply don’t understand that their approach is causing disaster after
disaster. This is very often the case. Because business people want to succeed,
we have a fighting chance if we approach things in a sensible manner.
Chapter 5 Getting Your Requirements Etched in Stone
81

Selling the Process
So far, we’ve identified the decision makers, the domain experts, and the people
who will actually use the software. The next thing we need to do is insert a
pause in the process. Frequently, we’re given fairly high-level requirements
and expected to start coding. The fact that the project starts into the design or
implementation work at this point is due to no one making the suggestion that
there’s a better way. That’s what we’re going to do now.
Development efforts come in all sizes, from one programmer to large
groups with multiple teams, and so there’s no one right person to whom you
should make this suggestion. If you’re a coder on a team, enlist the support of
your fellow programmers and your team lead, and go to the project manager.
In smaller groups, there may be no officially titled project manager, in which
case, your group simply talks to the next level up on the food chain. In any
event, you’ll have more success if you can first convince your peers and enlist
their support in your efforts. If there’s one among you who would make a
better spokesman, get him up to speed on what you’re trying to accomplish,
and then by all means, utilize his abilities to further the interests of the team.
After arranging for a little time with the appropriate manager to talk about
the requirements, first briefly go over what you have at this point. Because you
wouldn’t need to go to this trouble to begin with if you had detailed specs, you
should have little difficulty in pointing out the ambiguities in the requirements
you’ve been given. You probably don’t need to do anything more than touch
on a few high-level requirements and start asking the manager, quite inno-
cently, exactly what they mean. It will quickly become evident that you have
insufficient details. You’re not looking for anything more than his acknowledg-
ment at the moment. Once the manager has agreed that yes, things probably
should be spelled out a little more clearly, you have an in.
People are always much more prone to lending an ear to someone who
both has a problem as well as a proposed solution than to a person who just
wants to complain about the problem. Now that the manager has agreed with
you that it would be difficult to code from the existing requirements, you sim-
ply mention that you have an idea that might help in this regard. If you could
get together with a few of the people involved and ask for a little clarification,
you could answer your questions and get right to work on the programming.
Chances are good that this won’t seem terribly unreasonable, and you’ll be
given the opportunity to proceed. 
How much of the process you lay out to the manager is going to fall to
your instincts and common sense, based on the level of support and coopera-
tion you’re getting. To a manager who is truly supportive of anything that will
improve the software development procedures, the process we’re about to
walk through will seem logical and productive. On the other hand, if you’re
having to fight every inch of the way to make changes, you need to employ
what’s known as incremental selling. In this case, rather than overwhelming a
82
Part II Guerilla Tactics for Front-line Programmers

less-than-enthusiastic person with all the details of a decent requirements-
gathering phase, you instead speak more generally about “just a meeting or
two” with the relevant people to clear up matters. That’s easier for them to
commit to than some big, fancy, and time-consuming process. It gets your foot
in the door, and once you’re there, it’s fairly easy to keep having “just one more
meeting” until you get the details you need. A little underhanded? Maybe.
But, hey, they’ve been doing that sort of thing to us on software requirements
for years. For now, let’s proceed with the assumption that you have at least a
little support and can put it all on the table.
The Definition Questions
At this point, I’m going to define a set of questions to which I’ll occasionally
refer for the purpose of defining a requirement in greater detail. These are the
requirement definition questions, or simply the definition questions for short:
 What is the desired action?
 What initiates the action?
 What data does it operate on?
 Where does this data come from?
 What action is performed on the data?
 What supplemental data does it need to perform the action?
 Where does the supplemental data come from?
 What are the visual requirements?
 What are the audio requirements?
 What other systems or subsystems are affected by this operation?
 What are the effects of the other subsystems on this operation?
Most of these are obvious in their intent, but a couple of them require
clarification. The questions regarding the visual and audio requirements can
easily drift into issues of user interface design. That is not the intent. We still
want to focus on what, not how. At times, however, part of the requirement
will be visual or audible by nature. For instance, air traffic controllers need to
know if data being displayed on the screen is out-of-date and consequently
invalid, regardless of the reason. For example, the figures displayed on the
screen for the current runway visibility may indicate a clear day with no visual
obstacles. However, if the equipment that gathers this data has malfunctioned,
the controller may not be aware of the fact that a fog bank has rolled in and
Chapter 5 Getting Your Requirements Etched in Stone
83

the pilot couldn’t see a Chihuahua if it scampered across the runway right in
front of him. Not all controllers have windows. Consequently, it may be fairly
stated in the requirements that the controller needs to be given a visual warn-
ing indication that the current data is bogus. There may also be a requirement
that some sort of audible event take place to get their attention. Both of these
accurately state what the software needs to do without getting into how this
is accomplished. It’s crucial to keep this in mind at all times. When in doubt,
simply ask yourself if the topic being discussed is about what or how. That will
keep you on track. 
Following is an overview of the process we’re going to be using.
1. Identify the decision makers and key participants.
2. Create data-entry forms and a database to gather individual
requirements.
3. Have a series of meetings to clarify issues on individual requirements.
4. Collect and organize the individual requirements and formalize them in
a document.
5. Have the decision makers sign off on the final requirements document.
Seems pretty straightforward, doesn’t it? Actually, it is. Requirements
gathering, stripped of all the pomp and ceremony of the big-ticket design
methodologies, is nothing more complicated than holding meetings with the
appropriate people and asking precise questions about the needs of the system.
Preparations for Effective Information
Gathering
Although we have our key players identified and we have a set of concise defi-
nition questions, we still need to do a couple of other helpful things in prepa-
ration for the requirements meetings. First, set up a database that has, at
minimum, a record for a single requirement and fields for the data gathered
from the definition questions. If there are a lot of major categories or subsys-
tems, it would be a good idea to include fields for those as well. Whoever is
most comfortable with databases in your group can easily go to town from
there, but these are the basics. Create data-entry forms that will make it easy
for nontechnical users to enter this information in plain text and normal lan-
guage. Make this database, or at least the data-entry mechanism, available to
all attendees via your company network.
84
Part II Guerilla Tactics for Front-line Programmers

Using this data-entry form as a guideline, create a document template as
well, using whatever word processor is prevalent in your company. It’s helpful
to have two versions of this: one that the user can type directly into and
another that is designed to be printed out and written on. A constant in any
enterprise is the fact that the easier you make it for someone to give you what
you want, the better your chances of getting it.
Set up a couple of projects in your version control system to house two
types of documents. One project will hold the documents that describe a
single requirement, and the other will be the repository for the actual formal
requirements documents that will be the output of the entire process. Yes, yes,
I know, it would make much more sense for everyone to just enter the individ-
ual requirements into the database. For a variety of reasons that rarely make
sense, this just won’t happen with some folks. Having both the documents and
printed forms gives you a fallback strategy for those who can’t or won’t use the
database. You need the information more than you need to stand on principles
of how they should get it to you. Frankly, if they won’t use the database, the
document templates, or the printed forms, but they will answer the definition
questions on a cassette tape, take that instead. What you need are results, so
take the input any way you can get it.
Now that your infrastructure is in place, if you don’t already have a docu-
ment that details everything you currently know about your requirements,
now is the time to gather one together. Once you have this, it’s time to arrange
the first meeting. As a general practice for all meetings, it’s not only common
courtesy but much more productive if you distribute the documents with
which you wish your attendees to be familiar a day or two prior to the meeting.
In other words, give them enough time to read and digest the document
before the meeting. A lot of people won’t read it anyway, but it’ll be easier for
you to diplomatically ask them to hold questions that were covered in the doc-
ument if everyone had time to read it beforehand. You’ll find that the other
attendees will be supportive of this, by the way, because no one likes going to
meetings, and anything to speed them up will make you popular among your
attendees.
Another general practice for productive meetings is to always have some-
one who will be responsible for taking the notes during the meeting and gen-
erating a summary document afterwards. Designating such a person makes it
easier for everyone else to give their attention to the matters at hand, and also
helps to avoid conflicting perceptions of what took place.
At a minimum, in this first meeting, you need to have the decisions makers
present. If at all possible, you also want to include the domain experts and any-
one else who is a power to contend with as far as the requirements go. If you
need to work a little harder to arrange a time that everyone can live with, it’s
more than worth it if you can get all the major players in one room. Everyone
should have had a chance to read over the general requirements of the project
as you currently understand them.
Chapter 5 Getting Your Requirements Etched in Stone
85

Defining the Requirements
The first thing you want to accomplish in the initial meeting is a bit of parti-
tioning. For any nontrivial system, you can usually divide the requirements
into some major categories or subsystems. The next step is to build a focus
group for each of these subsystems. You may find that some people will need
(or want) to be involved in more than one group. Although it defeats the pur-
pose to have all participants work in all groups, this is at times a legitimate
need and should be allowed. You may find that there also may be a political
need, which is just as important. Identify a leader, preferably by group con-
sensus, for each group. This person will serve as the moderator for the focus
group meetings to keep them organized. Of course, you’ll need someone to
take the minutes for each group as well. That’s not a terribly gratifying job, so
it’s best to get a volunteer if you can.
You now want to give these focus groups a task to accomplish and turn
them loose. From the issues in their subsystem, they are to put together two
lists: the first is a feature list of all items that they agree by majority vote are
desirable, and the second list contains those features that were mentioned but
didn’t claim a majority. The focus groups should proceed by first going off
individually and making their wish list of features. Detail is encouraged, but
it’s not required at this point. They simply need to be able to identify the fea-
tures in such a manner that everyone in the meeting understands what they
mean. After a reasonable amount of time, typically a day or two, the focus
groups reconvene and the weeding-out process begins as people lobby, bribe,
and argue their way through the wish list. It’s a good idea to remove all the
whiteboard erasers from these conference rooms.
As each focus group finishes the two lists, they should distribute them to
all members of the complete group. When all focus groups are done, it’s time
to reconvene the complete group. At this point, the leader of each focus group
walks through the list and lets the group vote on it at large. The same rules
apply: majority rules. However, at this point, any decision maker can override
the group decision and accept or reject a feature. That’s one of the reasons
that the decision makers must be present at these meetings. They’re going to
do this anyway, and you don’t want it happening after you’ve already coded
the darned thing. After the list of agreed-upon features for each focus group
has been covered, the list of features that got only a minority vote is reviewed.
If a majority of the overall group decide that it’s a keeper, it moves to the
feature list.
If your project is large, you may want to stagger your effort by a series of
meetings, one for each subsystem. All-day meetings are tedious and a waste of
time by the second hour. If you truly care about keeping everyone’s attention,
no meeting should ever go past the one-hour mark.
The output of this meeting or series of meetings is the definitive list of fea-
tures for the system, albeit loosely defined. The next step is to drop back down
to the focus group level. These groups reconvene in their individual meetings
86
Part II Guerilla Tactics for Front-line Programmers

armed with their list of features and the definition questions. The output of
this process is a record in the database for each requirement, with answers to
all the definition questions. How it gets into the database is a matter of what
works best for the people you’re dealing with. For some companies, it’s viable
to have a workstation in the conference room so someone can enter the data as
the questions are answered. In other environments, printing out the forms and
filling them in by hand may be the approach most likely to succeed. Even if
they do it on a cassette tape and someone transcribes it into the database, it
doesn’t matter. Just get the questions answered.
When the focus groups have finished, the information in the database is
then used to generate a draft of the full requirements document. Depending
on how formally your company likes to do things, this can be as simple as a
database report or as tedious as taking the information and creating a separate
document in a word processor. The important thing is to do it in a fashion that
contains all the details and is in a format that works for the decision makers.
It’s a draft of the document you’ll eventually want them to sign. If they’re for-
mal and officious people, you must create a document in the same spirit or it
won’t be taken seriously. It may sound dumb, but that’s human nature in the
corporate world, and in the end, it’s critical that this document—and you and
your ideas—be taken seriously.
After the draft requirements document has been distributed, it’s time for
another meeting or series of meetings, depending again on the size and the
number of subsystems. This time, you want some of your top programmers
involved as well. There’s an advantage to having all of your programmers in on
the meeting if you can manage it, but at a minimum, you need the key players
for the subsystem that they’ll be working on. If the decision makers want to
skip out on the next meeting or two, that’s fine, but the focus group members
have to stay because they’re the ones the programmers will question. The
same procedure is repeated, and each requirement is visited. This time, in
addition to input from anyone in the room who feels the requirement in ques-
tion isn’t as clear as it should be, the programmers have a chance to review
each feature and verify that they have the information they need to design and
code from.
Here’s your chance, folks, so don’t be shy. If it’s not clear to you now, it
won’t be when you fire up your editor, either. This is one of those rare times
in life when it’s okay to put words into other peoples’ mouths. You may hear
vague descriptions of functionality that you must help translate into strict and
specific statements. An approach that I find helpful is to take the fuzzy state-
ment you heard and repeat it back to them in precise terms, asking for their
agreement, such as, “I see. So what you’re saying is that we need to <replace
vague ramblings you just heard with a precise description of functionality>.
Did I get that right?” Remember, many of the participants aren’t techies, so
you may need to lend your skills in that area. Diplomacy is very important
when doing this because you want to build allies, not adversaries. Believe me,
I learned about diplomacy the hard way.
Chapter 5 Getting Your Requirements Etched in Stone
87

Although the programmers don’t have veto power regarding which feature
stays and which feature goes, they do have the power to flag a requirement as
incomplete, meaning that it needs further clarification before it can go into the
requirements document. Of course, the more specific they can be about what
additional info they need, the better the focus group will be able to comply.
Additionally, programmers can flag a requirement as impossible to implement
in its current state. For instance, if a feature requires Internet access but the
program will be run on some machines that lack that connectivity, it’s a no-go.
This does not mean that the feature is dropped from the requirements docu-
ment, but rather that it is placed on a list for the decision makers to ultimately
review. They are the only ones who can make the call to either drop the fea-
ture or to ensure that it’s possible to implement (such as, in our example, by
including Internet access as a part of the product requirements).
Additionally, the programmers can flag a requirement that turns out to be
a design issue rather than an actual requirement. If people have properly
answered the definition questions, you shouldn’t see much of this. If it does
happen, though, it needs to be noted so the programmers can address it with
the appropriate people when it’s time for design.
When the Party’s Over
When all of the requirements have been worked through and there are no
more issues to resolve, the draft requirements document is updated once
more and distributed. One last meeting is convened with the decision makers
and the full group. The goal of this meeting is to get all concerned to figura-
tively “sign off” on the requirements, but, literally, there should be signature
lines for all of the decision makers and the leader of each focus group. The
leader of the programmers will also sign. The signatures of the decision makers
are mandatory because that’s the point of the entire process—getting the people
in power to make a firm and public commitment to a very specific set of fea-
tures. Getting the focus groups to sign off on the document is simply good pol-
itics, indicating that everyone involved has agreed that these are, in fact, the
gospel requirements. You never know when this sort of thing is going to come
in handy.
Check the document into version control, label it as the final requirements
document, and distribute a copy of the signed document to all participants.
It’s a good idea to have everyone sign two or more copies at the last meeting if
any of the decision makers want to keep an original. You certainly want one
with ink on it for yourself. Store it where it’s safe from the gnawing teeth of
any stray canines.
Once it’s approved, the requirements phase is officially over. For any
future feature requests, there’s a simple response. You can have anything
you want, as long as it’s in 2.0. But what if a decision maker requires a new
88
Part II Guerilla Tactics for Front-line Programmers

feature? If so, and this may happen, then it must meet the same stringent
guidelines outlined by the definition questions, and the subsequent design
and estimation phases must be revisited. The bottom line is that the dates
must be adjusted accordingly. However, having bought into a process of spe-
cific dates tied to specific deliverables, you’ll find that this will be much easier
to accomplish.
While the meetings are in progress, encourage the use of email for question-
and-answer sessions among members of the requirements team. People have
different schedules, and email is the most considerate way to ask questions
without interrupting what they’re doing. Of course, email is also the easiest
way to get ignored. If you find that some people are prone to doing this,
encourage the others to simply camp outside their office door if they have
to. Consideration works both ways. Also, remind the team that, as far as the
official proceedings go, hall meetings don’t count. If it’s not in writing, it
doesn’t exist.
Coping with a Hostile Environment
So far, we’ve been working on the assumption that you’ll get the participation
and support that you need from the decision makers to follow this process.
Due to politics, resistance to change, or any of the other reasons that people
do stupid things in the business world, it may not work out this way. In fact,
you may encounter active and extreme resistance to any or all of this. In my
opinion, a process is completely useless if it doesn’t fly in the real world, no
matter how impressive it looks on paper. 
If the decisions makers, who are ultimately the only ones who count, won’t
allow or follow through with this process, then a couple of things are clear.
First, you’re in a pretty bad environment, and frankly you might want to dust
off that résumé. Any management that is resistant to a procedure that will help
them get the software they want on time and in good working condition is just
going to be trouble at every turn. The second thing that’s clear at this point is
that, if this is your reality, any help you can get is going to be better than what
you have. So, let’s take a look at some shortcuts. They won’t yield perfect
results, but any degree of detail and accountability is better than vague feature
requests from people who position themselves as untouchables.
No matter what, you must still identify the decision maker. In this particu-
lar case, you want a single person, the ultimate authority who can veto every-
one else. This shouldn’t be hard. He’ll be the one telling you that he’s not
going to support or allow the requirements meetings. This is the guy who you
ultimately need to coerce into making a commitment. It’s crucial to know who
this person is and to verify that he indeed has the power to sign off on the soft-
ware system. It’s also still important to round up, or at least to identify, as
many of the relevant domain experts as you can.
Chapter 5 Getting Your Requirements Etched in Stone
89

Forget about the formal document templates for the individual require-
ments, but keep the database. Just realize that you’ll have to do all of the data
entry yourself. It’s tedious, but worth it in the end.
In this abbreviated process, you’re going to follow some of the same steps,
and it still starts with your creating a document that summarizes the require-
ments given you by management. You still need clarification. Because the
decision maker doesn’t want to support a legitimate process, you need to tar-
get this person with your questions. We’re now on touchy political ground, so
be very wary. Use the person on your team who has the best people skills and
doesn’t mind storming that machine gun nest. If you don’t have anyone on
the team willing to do this, you’re toast. Normal, logical approaches have
failed, and you must now decide whether it’s worth taking some risks to try to
improve your lot in life. No one can make that decision but you. Your only
choices are to update your résumé or get out the sleeping bag.
You want to ask the questions in person. The tactic here is a tricky one, but
the idea is to make it clear to the manager that you can’t write the software
until you get answers to your questions. If you’re not allowed to have the
meetings you need with the parties concerned, you can’t get your questions
answered. However, because this is the person who is requesting the software,
he can obviously answer them because he ultimately is the one who must be
happy with the system. Your only hope of success is to be pleasant, positive,
nonconfrontational, and impeccably logical. If you approach it with a seem-
ingly naïve innocence, it’s harder to get nailed. Gee, you need to write soft-
ware but you just don’t know what you’re supposed to write, so naturally it’s
okay to ask these questions, right?
The implied statement here is that if the manager wants the software but
doesn’t want to allow you to go through the common sense steps of defining
it, you’re going to be a pain in his behind until you either get your questions
answered or he gets irritated and delegates the matter. The danger in irritating
a superior is obvious, which is why you want your least irritating person to per-
form this mission. The interruptions will be irritant enough. You don’t want
one of your guys coming back with the pink-slip equivalent of a Purple Heart.
With any luck at all, you’ll at least get some definition out of this guy. You
probably won’t have much time each occasion you corner him, so have your
questions prioritized, well thought out, and ready to go. If this is as good as it
gets in your world, then, in addition to getting the information, you’ve also
been conspicuous enough in your approach that he’ll remember having com-
mitted to the details you asked for, if only because he found it annoying.
Another thing that can be helpful in this scenario is to use one of the small
pocket cassette recorders rather than trying to take notes. Just be sure it’s
obvious to him that you have it, or it looks like you’re trying to pull something
over on him. There are also legal implications involved in recording people
without their knowledge or permission, and you just don’t want to go there.
Simply explain the fact that you appreciate how little time they have so you
don’t want to waste it trying to take notes, and then put it in your shirt pocket
so it’s not waving in anybody’s face. This makes it a little less threatening.
90
Part II Guerilla Tactics for Front-line Programmers

The wise bunny rabbit does not threaten the Bengal tiger. Also be prepared to
be told to turn it off. Some people are uncomfortable with being recorded for
a number of reasons. If the person expresses such sentiments, comply quickly
and with a good attitude. Have a small notepad handy as a backup.
If the person gets irritated enough to delegate, that’s an opening. Pounce
on it. If he was previously resistant to the meetings you proposed, probably
because he didn’t want to fool with it himself, you can now suggest once more
“just a quick meeting or two” with the people he’s trying to delegate to, which
is tantamount to agreeing with him. However, you might casually suggest at
this point that it might help speed things up a bit and be less of a hassle for
the people he delegated to if you bring in “just a couple of other people” who
might be able to answer some of the questions. These couple of people are the
domain experts you’ve already identified. No need in announcing how many
or who unless you’re pressed for it. Even then, there’s no need to admit to the
full complement. Mention the person or two least likely to cause resistance.
The rest just get invited to the meeting. It’s always easier to ask for forgiveness
than to ask for permission.
Be prepared when you hit the meeting, but don’t distribute the documents
prior to the meeting as you normally would. Remember, if you’re here, you’re
in a hostile situation and need to think a little differently. Any little bit of fair
warning you give offers the opportunity for someone to screw it up for you. So,
show up to the meeting with copies of the high-level document you prepared
and hand it out. What you do at this point depends largely upon the feel of the
group. You may find that, even though the decision maker is an inflexible pain
in the posterior, the people to whom the work was delegated are actually rea-
sonable and supportive.
You’ll have to play this one by instinct. If you get a good attitude from all
concerned, you might try suggesting that you break it into subsystems and
letting each of them gather a little information, perhaps getting together with
some users or other people that they feel would help with their area. Further,
you offer an approach that will help them—that is, the two-list system we’ve
already covered—and you slide each of them a list of the definition questions
that you were holding on to just in case. In other words, if you end up with a
good group, you just slide right into the procedure, quietly and with little fan-
fare. Don’t push them to do any data entry or any other tedious task. Your
main priority is to collect information, and your secondary priority is to estab-
lish allies whom you can count on when it comes time to get the requirements
document recognized by the decision maker. Your team can handle any of the
grunt work needed. You just don’t want this alliance to unravel, so do whatever
you can to keep things rolling smoothly.
If you get to the delegated meeting and you don’t have a supportive group,
then you simply fall back on the same tactics you used with the decision
maker: innocence, logic, charm if you’ve got it, and an overriding goal of get-
ting as many questions answered as you can. Towards the end of each meeting,
for as long as you can get away with it, casually ask one or two of the key players
if they’d mind getting together with you briefly a little later in the week to
Chapter 5 Getting Your Requirements Etched in Stone
91

“just answer a couple of questions.” Target people that you need the informa-
tion from the most. If you can pull it off, you can use this approach to hold a
series of mini-meetings with a couple of people at a time. In a similar fashion,
you can drop by a person’s office (email is useless in this context) and ask if
they could spare a minute or two for a couple of questions. In other words,
your mission is to gather information, even if it breaks down to house-to-house
fighting. All of this is a real nuisance, but still not nearly as much of a pain as
trying to cope with deadlines and pressures when you’ve only been given the
vaguest of requirements that you know will continue to change on you.
What if you simply don’t have physical access to the decision maker? This
is a hard situation. At that point, shoot for people directly under them in the
food chain and work the same tactics. The bottom line is that, if you don’t get
some cooperation or access at a reasonably high level relative to the people
who make the decisions on your software, you’re pretty much done for.
However, I’ve worked for large, international corporations, and, although the
general directive to go forth and create software may come from the CEO, in
reality, the people who will approve your software as being finished are typi-
cally not too far from you in the general scheme of things.
In a similar fashion, regardless of which of the preceding tactics you’re
forced to employ, your ultimate goal is still to get an official approval of your
detailed requirements from the decision maker. It’s best to get one in writing.
However, if you’re in a hostile or unsupportive environment, that just ain’t
gonna happen. In such a case, you take the finalized requirements document—
the best that you could put together under the circumstances—and make it
available on the network after having labeled it in version control to prevent
someone from tinkering with it later. You then send an email that this docu-
ment exists and how to find it to anyone with any clout in the decision-making
process; in other words, to all perceived decision makers, as well as all domain
experts. In your email, you state—diplomatically, of course—that to the best of
your understanding, here are the only things you’re aware of that you need to
implement in the software and that, unless you hear otherwise, it’s all you’re
going to implement. The language should be nonconfrontational and more
along the lines of telling them that you’d be grateful for any clarification or
input that they might have. If you get any takers, try to walk them through the
definition questions on any features that they may want to sneak in. After a
round of that, update the document and repeat the email. When you send an
email and you don’t get any response back for a day or two, then that’s as good
as it’s going to get. However, when the release crunch comes and people start
trying to wedge in new requirements or wiggle on existing ones, you’ve got a
paper trail (print out and save at home all of the email responses you get) to
help fight off the last-minute changes. It’s not as good as a signature from the
decision maker, but it’s a little more ammunition than you would have other-
wise had.
92
Part II Guerilla Tactics for Front-line Programmers

Politics Are Never Far Away
Even though we’ve run the gamut here from a constructive and cooperative
environment to one that is hostile and unreasonable, some of the basic con-
cepts remain unaltered. To define a given requirement, you need to ask spe-
cific questions. To tie requirements to a date, you need to formalize the final
requirements and have the decision maker acknowledge them. 
As important as all of the issues we’ve covered here may be, perhaps the
most critical consideration is realizing that, if you get anything less than full
support when trying to nail down your requirements, you’re dealing with polit-
ical issues. This is a double-edged sword. Although politics are unsavory to
most of us and certainly dangerous if ignored or handled poorly, programmers
can also employ them to get what we want. This is most prevalent in the
requirements-gathering phase, as you have people with their own personal
agendas jockeying for what they want. That’s politics, pure and simple.
However, you’re going to find that, although we talk about practical, nuts-and-
bolts programming issues regarding condensed design approaches, low-level
estimating techniques, and so on, political considerations will never be far
behind. If you make your living in the business world, it’s an inescapable real-
ity. In the end, the programmer who successfully delivers his software is most
often the person who has good technical skills, good organizational skills, and
good political skills, and is willing to use each when called upon.
Chapter 5 Getting Your Requirements Etched in Stone
93

If the realities of the requirements-gathering phase are a combination of poli-
tics and trying to pin down slippery product definitions, the design phase in
most programming departments is typically an exercise in making the best out
of the time you’re given. In many shops, management doesn’t even understand
the concept of a design phase and are consequently not too generous in their
time allotments. The end result is an implementation phase that often starts
with little more than a meeting or two gathered around a whiteboard before
the programmers scurry off to their corners to begin coding against an already
impossible deadline.
With that in mind, let’s take a look at some of the essential realities. First
of all, when it comes to design, you’re not going to have time to do it The
Right Way. I’m sure you’ve read about it though, and probably even have a
few excellent books on the software design process lining your bookshelves.
Personally, I’ve learned a great deal over the years from such approaches, and
they have doubtless made me a better programmer. I’ve just rarely been in a
shop in which management gave the developers even a fraction of the time
necessary to fully implement these methodologies. That’s a shame, too.
I actually worked in one shop where they followed the rule that software
development is 80% design and 20% coding. We literally designed the entire
system on paper, down to the function level, complete with all parameter
passing, and debugged it in peer meetings before we ever got near a compiler.
Seemed like it took forever at the time, but in retrospect, the design and cod-
ing phase together took about half the time it would have taken with the typi-
cal shoot-from-the-hip-and-debug-all-night approach.
When (and only when) the overall design finally survived a gathering
without red ink, we started coding. The design was so detailed we could have
almost hired typists to do that part of the work. When the last compile was
complete, we plugged four independently developed modules together for the
first time, and it just worked. No sparks flew, there were no major or minor
rewrites, and we found an extremely small number of bugs. We’re talking
around two or three bugs per module, and this was a nontrivial codebase.
95
Effective Design
Under Fire
6
C
H
A
P
T
E
R

Everything that they tell you in these methodology books about the benefits of
following an analysis and design approach thoroughly, in great detail and by
the book, is true. I’ve seen it work.
Sadly, however, that was a unique experience in my career. I’ve been at this
for a little more than twelve years. Never before or since have I been given
anywhere near that kind of time in the design phase of the project, if in fact I
was given any time for design at all. 
Remember, in management’s eyes, if you’re not coding, you’re not work-
ing. The way they handle the development teams in most of the shops I’ve
seen is chaotic and extremely shortsighted, and they pay for it with every
release. You’d think that they would eventually figure it out, but they never
quite seem to catch on. Nonetheless, it is what it is. No matter how much
better life would be if they’d let us do it The Right Way, you’re just not going
to have the time you need to design in complete and thorough detail before
you’re expected to start coding. As such, we must either adapt or be dashed
on the rocks of corporate reality.
Design? What Design?
I’m not going to teach you how to design software, nor am I going to introduce
another design methodology to the world. I’m sure you’re already familiar with
many approaches, and there is a wealth of excellent books available at your
nearest bookstore. Instead, what we’re going to focus on is how to cope with
design in the compressed timeframe that we’re typically forced to live with.
You should know right up front that the things I’m about to suggest will doubt-
less destroy my reputation as a serious systems architect and software engineer
in the eyes of credible and respectable professionals everywhere. However,
I’ve got deadlines to meet, and I’ve always been more interested in that than
looking respectable, anyway. It’s probably just as well. The black leather jacket
tends to give me away every time. Don’t ask about the earring.
So, brace yourself. We’re going to do everything backwards here. We’ll
be basing the way we approach our design on the available time, instead of
declaring the amount of time we need based on the design philosophy. That’s
because, as in every other aspect of our jobs, we simply don’t have the author-
ity to say how long we’re going to take on a task. Rather, management tells us
how long we have and will hear no arguments to the contrary. Consequently,
the design document that we’ll come up with is not a 400-pound college
research paper. It’s a computer-generated cocktail napkin to help you get
the job done.
You need to keep a couple of other things in mind as we go along. First,
design specs are not the same as technical documentation. When the imple-
mentation is done, it will not match the original design. It never does. Along
the way, things will change here and there as you encounter unexpected and
undocumented problems and are forced to come up with solutions on the fly.
96
Part II Guerilla Tactics for Front-line Programmers

You won’t have time to go back and redo all of the design documents that
these changes affect to keep them up-to-date with the implementation. You’ll
simply make some notes that are relevant to the remaining work and keep
moving. The sole purpose of these design documents is to aid you in your
quest to write the code. They are not sacred scrolls. Scribble on them, put
your coffee cup on them (provided you can still read the text around the cof-
fee ring), and don’t sweat it if a printout or two gets torn. They’re cheat sheets,
nothing more. Additionally, you’re going to find that you’ll need more than a
typist to code from them. A programmer’s interpretation will be required,
although that won’t be much of a problem, because it will typically be the
programmer who drew the given diagram in the first place.
Estimating the Design Effort
Before any design effort can begin, we have to get the time to do it.
Consequently, the first task of the project manager (or whoever happens to be
in charge) is to secure this time. As in all other phases of the project, manage-
ment will want an estimate of how long the design phase will take. Being a
reasonable kind of guy, your project manager will be happy to comply. At this
point, he asks management to give him a few days to put an estimate together.
How many days is “a few”? That’s going to depend on the climate of your
company, your project manager’s experience in dealing with the management,
and his bargaining skills. In general, asking for a month to estimate how long
the design phase itself will take will never fly. Asking for half an hour is too
little. Somewhere between two days and a week is probably in the ballpark,
depending on the size of your project. In the end, of course, you’ll take what
you can get.
You might think that the purpose of the days you’ve just bought for esti-
mating the design phase is for figuring out how long the process will actually
take, right? Well, no, but thanks for playing and we do have some lovely
parting gifts for you. The goal of this estimation process is not to determine
how long the design will take, but rather to put together the compressed
design approach itself and then do the highest level of design. Did I mention
that we might be bending a couple of rules ever so slightly here and there? To
however many days or weeks you’ll ultimately be given to do what will have to
pass for system design, you just snuck in a few more. Hey, they don’t play fair,
so we don’t play fair.
We’ll touch on the actual estimate that gets forked over to management in
a moment. For now, let’s take a look at what we’re really going to do with the
day or two we’ve just been given. Before we can do a design at any level of
detail, we need to get organized. In addition to the fact that we’ll generate
some degree of design documentation that will need a common set of symbols,
definitions, and so forth, we’ll also need a common language and point of ref-
erence to use when discussing the design issues. Which design methodology
Chapter 6 Effective Design Under Fire
97

should we then use: Brand X or Brand Y? Actually, we’re going to roll our own.
If having an official name for the design approach makes you more comfort-
able, you can think of this as Incremental Design, for reasons that will soon
become apparent. Or you can just call it Brand Z.
What we’re going to do is build a composite methodology that leverages
the existing knowledge of your team. To do so, quietly gather your developers
together in a small little conference room on the bad side of town where man-
agement can’t find you, and make a list of all the design methodologies that
you know of. It doesn’t matter how old the approach is, whether or not it’s
object-oriented, or even if anyone has ever heard of it before. We’re looking
for building blocks at this point, and we want to pour them all onto the table
before we start building anything.
From the list of methodologies you’ve now assembled, make a list of all
the diagram types in each, along with the purpose that they serve. Duplication
is okay and is in fact expected. Most design systems overlap in a number of
areas, varying not so much in content, but rather in the style in which things
are approached. Nongraphical representation is okay as well. We’re building a
list of ways to present design information, and the printed word is perfectly
valid, if sometimes verbose. If you see holes when your list is complete, declare
a new diagram type and define its purpose. Don’t worry about the representa-
tion for that particular diagram type just yet, because you’ll address it later.
Keep in mind that you’re short on time here, so don’t go crazy and get into
tons of detail. Keep it simple and concise, and remember that your ultimate
purpose is to build a customized design methodology for this specific project
that you can actually take into battle with you. Leave all the theoretical stuff
for those ivory tower guys in the white lab coats. It weighs too much in your
backpack and will only make you tired.
Next, break the software system down into its major modules. Although
this partitioning often falls along some fairly obvious boundaries, the size of
the modules may be in question. If so, think in terms of the size of a team and
how large a chunk they could handle. Before you can perform this partition-
ing, however, you’re first going to have some discussions of the overall system
itself, what you’re trying to accomplish with it, your vision of the overall archi-
tecture, where the major interaction points are, what the high-level flow of
data is, and other such familiar topics that are necessary to make an initial pass
at system architecture and high-level design. Once you have this level defined,
break these major modules down into successively smaller submodules until
you have a module size that one programmer is capable of handling.
By the way, remember that estimate that we were supposed to be working
on? Here’s how it works. When all the justifications are made and your team
has explained the various benefits of any given design approach to manage-
ment along with how long a proper effort will take, you’ll find that they really
just don’t give a rat’s patootie. They didn’t understand a single word you just
said, and they already knew how much time they were willing to lose on all
98
Part II Guerilla Tactics for Front-line Programmers

this design nonsense long before you started talking. Yes, in their mind design
is frequently considered lost time. You’re not coding. Bear in mind that you’re
getting any time at all only because you made a fuss about it.
So, once again, based on his previous experience with management, the
project manager determines the amount of time, in calendar days, that he
thinks management will realistically agree to in terms of the design process.
This is typically a matter of weeks, not months. It’s important to be realistic
about this number, regardless of your personal feelings on how much time
you’d like to have. Once this number has been determined, he then multiplies
it by 1.5 and gives this new estimate to the team. The individual teams will use
it as a boundary and work under the assumption that this is the amount of
time they have to do the complete design once the design phase starts. This
helps them to determine how much detail they can afford to pursue.
This will also be the estimate that the project manager presents to manage-
ment as a starting point, once you’ve chewed up all the days you were given to
do the estimate, of course. Because it’s half and again more than he expects
they’ll accept, they will most likely balk at the figure, and so he bargains for
what he can get. As a general rule, if they say yes to your first offer, you could
have gotten more. If they say no to your first estimate and proceed to haggle
you down from there, you can rest assured that you squeezed every last day
out of them that you were ever going to get.
You already know that you won’t be given the time that you really need to
do a complete and detailed low-level design. However, if you can get a good
high- to medium-level design laid out in the design phase, then, as you’re
doing the low-level estimating that will be required later on to determine the
implementation timeline, you’ll actually be doing the low-level design. It just
won’t be obvious to management. Keeping this in mind will help you maintain
your focus at this stage of the game. You don’t need to go into minute detail in
the design phase. You need to go only deep enough to provide the framework
that you’ll use later when you actually are ready to go into fine-grained detail.
As you can see, what we’re doing is taking the true, overall design phase
and surreptitiously spreading it out over a couple of estimation phases as well.
In such a manner, you can come close to doubling the amount of time that you
have to design your software. Furthermore, you’ll probably impress them on at
least one level, because management respects people who can give estimates,
manage time, or perform any other function that somehow works out to num-
bers. While you’re in the process of getting what you need to get the job done,
you’re also gaining credibility because you’re speaking the language that they
understand. In the end, everybody wins. Now that we have the estimate safely
scribbled away on the back of an old gum wrapper somewhere, let’s get back
to using up those days we were given to conjure up the aforementioned esti-
mate by doing some more design work.
Chapter 6 Effective Design Under Fire
99

Rolling Your Own Design Methodology
You have both your modules and teams defined, so now you need to assign the
major modules to the individual teams that will ultimately be working with
them. Their first task will be gathering the information you need as you build
your customized design approach for this project. When doing this, don’t
worry about the next project or trying to come up with an approach that will
be perfect for all needs and all times. While you obviously won’t forget what
you learn on this project and will tend to keep things that have worked for you,
it’s important to note that this customized design methodology is disposable.
You’ll use it for developing this project, and then you’ll simply throw it away
once the postmortem has been done and you glean all the information you can
from it to roll into technical documentation. Remembering this will help you
keep it simple, concise, and to the point. If you weren’t short on time, you
wouldn’t need to take this approach in the first place. However, because these
are the waters you find yourself in, you have to maximize the effectiveness of
every minute you have, which means cutting out the fluff whenever and wher-
ever possible. Marketing has an acronym about simplicity: KISS. Buy them a
drink sometime and ask them what it stands for.
Previously, we built a list of all the different diagram types we could come
up with from our pooled knowledge of various methodologies. Each team is
now going to determine which diagram types it needs in order to design the
module for which it is responsible. Just as the overall group had high-level dis-
cussions on overall system architecture, now the individual teams have similar
conversations regarding the architecture of their major module.
As you start to make this list of diagram types, you need to keep a couple
of important questions in the forefront of your mind, remembering that we’re
doing only high- to medium-level design and that time is short. How deep
do you really need to go to have a workable framework for future low-level
design, and how much time do you have? These two questions should continu-
ally bound your efforts. As you consider this level of design, approach it with
the perspective that the interfaces are more important than the internals. The
latter will be fleshed out in more detail later. The interfaces should conse-
quently be given more attention.
Additionally, what level of experience does each of your developers possess?
The level of design detail can vary on each programmer-sized submodule,
based on the experience of the developer who will be working that piece of
the puzzle. This is acceptable because, in the end, each programmer will be
coding largely from the design specs he created. Because each will know what
he’s capable of in terms of filling in the blanks on the fly, the diagrams and
design documents that he will use can reflect that. Thus, you can save time
when working with seasoned developers, rather than going down to the lowest
level of detail for every module whether it’s needed or not. That’s one of the
benefits of using disposable cocktail napkins for design.
100
Part II Guerilla Tactics for Front-line Programmers

Each programmer now proceeds to create his own list of diagram types
that he’ll need to develop the portion of the code for which he’s responsible.
From the overall diagram types list, he’ll make a list of only the diagram types
he needs to communicate the program design both to himself and other mem-
bers of the team. The goal is to take a minimalist approach that efficiently
covers the bases, as it leverages the experience of the individual and leaves
part of the communication of the design to a verbal process that can often be
much quicker than a large stack of detailed drawings. While it’s true that a pic-
ture can be worth a thousand words, sometimes a few well-chosen words can
save you the arduous task of generating a thousand pictures.
To derive this individual list, the programmer will have to think through
the major aspects of the portion of the system he is to design. Although I’ve
been loosely equating a design methodology to a set of documents, we all
know that it’s really not that simple. A design methodology is not just a way
of documenting things; it’s also a way of analyzing and organizing a software
system for subsequent coding, be it an overall project or the one small part
that’s managed by the given programmer. Once again, what we’re doing is
leveraging the strengths of the individual. Each programmer will naturally
gravitate towards the methodologies with which he’s familiar. As a result, when
he sits down to look at his part of the system, he will instinctively apply these
approaches as he breaks down his work into progressively smaller pieces and
defines the interfaces, states, interactions, data, and procedures that are
required for implementation. Thinking through these issues and conceptualiz-
ing the work enough to determine the types of diagrams that are necessary
represents the next initial stages of high-level design, even if you’re not writing
anything down just yet.
Now that you have a list of the diagram types that you’ll need to code your
portion of the system in the time given to you by the project manager, make a
second list of diagram types that you would use if you had only half the time.
It can be a subset of your first list or a completely different list, if you find that
you really need different types of diagrams for such an abbreviated approach.
Having covered the procedure that we’ll follow, let’s look in a little more
detail at the process of rolling your own design methodology. Those of you
who have watched the occasional Bruce Lee movie may have heard mention
of Jeet Kune Do, the system of martial arts that he developed. One of the fun-
damental principles, which can be applied to many aspects of life, has to do
with stripping away formalities that appear to exist for the sake of formality
alone and instead gleaning from any martial arts system you encounter those
basic techniques that work for you personally. Although this brief statement
is obviously inadequate to describe an entire system of martial arts, it’s suffi-
cient for our purposes as it relates to software design, as that’s just what we’re
doing here.
In every major design methodology that you encounter, you’re going to
find many useful techniques and ways to represent information. It’s not
unusual, however, to find that even going by the book, you don’t need all of
Chapter 6 Effective Design Under Fire
101

the tools that they provide for you to properly describe your system. This isn’t
a matter of taking shortcuts in the given approach. Rather, it points out that a
methodology, to be complete, must be able to cover all the bases for all sys-
tems. From this basic set of tools, you follow the prescribed procedures and
use those elements that are relevant to the system under development.
What we’re doing here is loosening the rules somewhat. We’re expanding
our toolset to include every design technique known by the group as a whole,
and we’re removing the constraint that a strict and particular set of steps and
procedures must be followed. Instead, we’ll utilize the strengths that each sys-
tem brings to the problem at hand and simply leave the remainder unused.
This applies not only to documents and diagrams, but also to methods of
thinking, analyzing, organizing, and every other aspect of the design process
that’s covered in those books you bought. Although following the entire
process as outlined has definite benefits when you have the luxury of that
kind of time, a great many aspects of each system are strong enough to
stand on their own. We’ll take advantage of that.
Just as we’ll avoid going through procedures for the sake of formality
alone, we also want to avoid a scattered approach if a more contained one is
available. If you can use the graphical representations from a single design
methodology with which everyone on the team is familiar, you’re off to a good
start. You have a single point of reference, a good source of documentation on
the symbols themselves, and a group of practices and diagramming techniques
that were meant to work together. Even if not every person on your team has
experience in the given design approach, take a look at the numbers. Is the
group small enough that it would be easier to bring them up to speed than it
would be to roll your own? What is their general level of experience and men-
tal agility? Is it such that they would quickly grasp things? If they have a back-
ground in any methodology at all, they should be a quick study.
What you’re taking advantage of in this case is existing common knowl-
edge. If you decide to use a single approach in your efforts, make sure that
your motivation for doing so is the prevailing knowledge base of your develop-
ers. Do not—I repeat do not—force a particular approach down everyone
else’s throat because you have an emotional attachment to what you consider
to be The Right Way. That’s counterproductive and will also make you the tar-
get of many whiteboard erasers. The one and only justification for using a sin-
gle methodology in our situation is to save the time it takes to roll our own. If
overwhelming numbers don’t make this a no-brainer, there is no benefit, and
we go back to picking and choosing the best of all worlds.
Assuming that you don’t have a team trained in a single method of design,
we’ll continue with our considerations of creating a customized subset of many
approaches for our own use. In the beginning, as you’re considering the types
and definitions of your diagrams and documents, there are no rules, only the
goal of coming up with your set of tools for this project. This means that you
are encouraged to make up the rules as you go along, creating or borrowing
them from the methodologies you’ve seen in the past as is appropriate, and
always working to boil things down to their essence. The end result we’re
102
Part II Guerilla Tactics for Front-line Programmers

striving for is the simplest, shortest, quickest, and most efficient method that
we can come up with to describe this software project. In the end, no one,
particularly management, will care what brand of box you drew on your design
charts. They’ll only remember if you made the deadline and that the software
works. In short, results count. Purism for its own sake is to be avoided like an
attack Chihuahua who has had one cup of espresso too many.
You’ll be defining only the diagram types that you need and for which
you have time. Are you approaching things in an object-oriented fashion?
Then you’ll probably want some manner of describing your class hierarchy.
However, you may or may not need the equivalent of a state transition dia-
gram. Flowcharts? They take a great deal of work to do in low-level detail,
but would they be useful in showing the overall process for a given module?
Don’t forget the user interface. Now that we’ve passed beyond the
requirements-gathering stage, we’re no longer asking what. We’ve moved on
to how. Consequently, there are times when you may want a quick and easy
way of communicating UI design without having to kick out a prototype. I’ve
seen some standard business drawing packages that made it pretty easy to
drag-and-drop a quick screen representation together. If such tools aren’t
available to you, it’s actually easy to convey a lot of UI information using noth-
ing but rectangles of various sorts. Do you need to go to this trouble? That’s
going to depend on the target audience for the software (particularly the deci-
sion maker over the entire project) and the amount of time you have. If you’ve
seen examples in your company of people constantly redoing the user inter-
face to a program, it might be a good idea to at least hit the high points and
put them in front of the decision makers for approval. That’s no guarantee
against their waffling on it later, but you can at least get a few rounds of that
nonsense out of the way on paper, where it’s quick and easy. To do this, you’ll
need a diagram type or two to easily represent such things.
If you have concepts that you need to represent that are not covered by a
given methodology, take a diagram from another methodology or simply make
one up yourself. It’s worth mentioning that making up a diagram type of your
own should truly be used as a last resort. If you create it, then you have to
make the legend, explain to others how it works, and give them the informa-
tion that they need to be able to use it or interpret it themselves. That’s not
really a problem, but, if you use a stock one out of an established methodology,
all you have to do is hand them the book. That saves time, and saving time
while doing effective design is what we’re concerned with here.
Wherever possible, try to map your design diagrams and verbiage to the
programming languages and technologies that you’ll be using for implementa-
tion. One of the advantages of this crude, homegrown approach to design is
that you’re not creating a generic, reusable methodology. You’re defining the
tools that you need for a single, specific piece of software. Whereas a standard
design methodology must remain absolutely generic in terms of platforms and
programming languages to be of benefit to the development community at
large, you have no such constraints. Consequently, you’re able to speak a more
specific language that relates directly to the environment in which you’ll be
Chapter 6 Effective Design Under Fire
103

coding, as well as a language that addresses the particular business issues for
which the software is being created. That does wonders for improving commu-
nications both among your team and when you want to convey something to
management or your user base.
Now that each programmer has created two lists of diagram types for his
own piece of the puzzle, the overall team reconvenes and compiles two global
lists of diagram types: one for the allotted time and one for half the time.
Because the entire team is assembled, it’s a good idea to discuss interactions
and interfaces between modules to determine if additional diagram types are
needed. The two global lists are then updated accordingly.
You now know exactly what types of diagrams or other documents you
need as a group to perform the high- to mid-level design of your system. It’s
now time to clarify and formalize each diagram type. For each one on your
list, a decision is made on a common representation that everyone will use. In
other words, you determine exactly what boxes, arrows, circles, and the like
will be used on a diagram of a given type, and what each of these symbols will
represent. Then a legend is created for each diagram type, and these legends
are summarized in a document and made available on the network.
I’ve certainly done this sort of thing by hand with pencil and paper, but
there’s no reason to suffer through that these days. You should also decide as
a group which pieces of software you will use to generate the documents and
diagrams. If possible in the time you have available, create document tem-
plates for these diagram types, if your software supports such things. If not,
you can accomplish the same thing in a less elegant fashion by creating blank
documents the same as you would a template and storing them, as read-only,
in a common directory on your network. To create a new document, you sim-
ply make a writable copy of your virtual template and go from there. It’s a bit
clunky but nonetheless effective and worthwhile in terms of the entire team
exhibiting some consistency in the look and feel of the design documents.
You now have a design approach that’s customized for your particular proj-
ect and that uses a minimalist set of diagrams and documents. It leverages
both the overall group knowledge of various design methodologies to broaden
your design options, as well as benefiting from the individual programmer’s
experience level to reduce the amount of documentation you have to deal
with. Additionally, you’ve talked through the high-level design of the entire
system as well as the internal architecture of the individual modules. Each
programmer has also given thought to his individual part of the project and
has performed a similar level of conceptualization and high-level design on his
area of responsibility. In other words, you have just performed the highest
level of design for your system, and the clock hasn’t even started ticking yet.
Having used up all the days you were given for estimating the design effort,
the project manager now presents the 1.5 estimate to management and bar-
gains for what he can get. We want to squeeze every hour out of this that we
can, but make sure that you deliver the estimate by the time you said you
104
Part II Guerilla Tactics for Front-line Programmers

would. It doesn’t matter what the deadline is for; it’s critical to your credibility
that you meet each one. Having done so, a duration for the design effort is
now set, and the official design phase commences.
Hitting the High Points
As discussed earlier, the goal of the design phase is not function-level detail
but rather to think through the system as a whole, consider the interactions
and interfaces, and prepare a design of sufficient detail to use at a later stage
in performing the function-level design. The fact that the function-level design
happens during the time you’re given to estimate the implementation effort is
immaterial. It’s simply the third step in an incremental approach to design.
When you’re done with the official design phase, however, you should know
how the major components of the system work together. At a programmer
level, you should have a grasp of what objects or their procedural counterparts
you’ll need, along with a good idea of what the internals of these will consist of
in terms of data and routines. You’ll also have thought through which of these
will be used internally and which will be exposed externally. The overriding
question that should drive this process is very simple: when you’re done, will
you have the information you will later need, whether explicitly detailed or
implicit in form, to figure out what needs to be done in terms of coding?
This is usually a fairly easy distinction for experienced developers to make.
To take a very simple example for illustration, consider a requirement to print
an invoice. You know that you’re going to need data pertaining to customer
account information, inventory, pricing, and the relevant tax information.
You may need the ability to both retrieve this data and update it. Given this
data, you’ll perform some fairly straightforward calculations. Eventually, of
course, you’ll also need to format your results and send them to a printer. How
much detail do you really need at this stage to prepare for such a task? Let’s
take a slightly closer look.
Assuming that you will ultimately need to provide a method that someone
else can call to print the invoice, you must first know at least in a general sense
where you’re going to get your data. You will also be taking data as parameters
to let you know which particular invoice to print. This may be as simple as an
invoice number. Because the mathematical calculations in this example are
trivial, the only other piece this leaves is the printing routines. You’ll doubtless
need to select a printer, and then you’ll make formatting calls and output your
results.
At this level, you simply define the type of data that you’ll need to work
with, such as customer information, inventory line item data, and so forth. You
don’t have time to spell out all the fields and data types in painstaking detail,
so a certain amount of trust is required in this approach. By stating that you’ll
Chapter 6 Effective Design Under Fire
105

need customer information, you’re saying to whoever is handling that part of
the project that you need an interface to obtain this data. The minute details
such as what type of variables you’ll be using will be handled in real-time dis-
cussions when you get down to actually doing the coding. The same applies to
the printing routines. You define the basics of the services you’ll need, which
serves notice to others that these interfaces will be required.
With this in mind, how many pounds of design documentation do we need
to convey this in a manner sufficient for the programmer at hand to later think
through the details of the functions? Not even a fraction of an ounce. By draw-
ing whatever lines and boxes you’ve agreed upon to represent the input needs,
data gathering, calculations, subsequent data updates, and printing options,
you’re going to have a pretty good idea of what your coding tasks will be. It
doesn’t take much to represent that if you don’t get caught up in drawing a
bunch of stuff just because you feel like you’re supposed to.
Later, when you start doing your low-level implementation estimates,
you’ll take a look at what you’ve done here. At that stage, you’ll start thinking
through in a bit more detail the steps required to, for instance, retrieve the
customer billing information. This framework will provide adequate bound-
aries and mid-level conceptual design to enable you to do this. As such, the
design work you perform at this stage doesn’t have to be pretty, fancy, or offi-
cial looking. It just needs to be effective. Nothing else matters.
Effective Prototyping
Many times, it’s useful to do a little prototyping in the design stage, particu-
larly if management wants to be involved in the overall look and feel of things
(or simply has to meddle to feel like they’re managing). Of course, this has
tradeoffs. Prototyping can do wonders for settling down the user interface
before true coding begins, and therefore can save many hours of rewriting
UI code again and again. However, no matter what tools you use, prototyping
takes time. If you spend a significant portion of your design phase prototyping
the system, you may well end up with a lot of great-looking screens and
absolutely no idea of how you’re going to handle the internals of the system.
In general, prototyping should be avoided unless you truly need to convey
UI design concepts to someone outside the programmer group, such as man-
agement or your users. If you’re in a situation wherein either your higher-ups
request it or you know from personal experience that without this sort of
direct user and management interaction, you’re doomed to an endless series of
rewrites, it’s best to present it as another stage of the process. In other words,
when the project manager is bargaining for time to do the design phase, he
will also bargain for a prototyping phase as a separate entity.
The first rule of presenting this is to avoid the temptation of bargaining for
both design and prototyping time together. Instead, the wily project manager
will simply ask for time to estimate the design effort as we’ve already covered.
106
Part II Guerilla Tactics for Front-line Programmers

Several days later, when the bargaining is complete for the design phase and
you’re a day or two into it, the project manager returns to management in a
casual manner. With the duration of the design phase already defined and
indeed underway, you simply approach management as if this thought has just
occurred to you. Observing the degree to which they like to be involved in all
things related to UI, you ask if they’d like to see and approve some simple pro-
totypes and screenshots before the actual development begins. This, of course,
also makes you look much more responsive to the needs and desires of man-
agement and your user community, which is always a good thing. It also com-
municates in subtle language that you recognize their authority and are happy
to cater to them. A lot of sales are made in the business world by going for
the ego.
Once you have their interest and enthusiasm, you briefly get a feel for the
level of detail that they’d like in the prototyping. Do try to remind them that
a prototype is not the foundation of the ultimate system but rather an empty
house with screens on the outside, and try to keep them from going nuts with
details. A prototype is little more than a moving sequence of screenshots.
Further, make sure you emphasize that absolutely no prototyping code will be
used for the production system, as that tends to cause a lot of rewriting, creates
bugs, and makes missing the deadline that much more likely. This should scare
them off. If it doesn’t, make sure that the prototyping tool that you use is not
in the same programming language or in any way compatible with the devel-
opment environment already accepted for building the system.
Once you’ve got some boundaries set on the prototyping, you’ll also have
made it plain in your conversation by implication that this isn’t something you
can kick out in ten minutes. You then mention that you obviously can’t begin
the prototyping before the design phase is complete because you’ll have to
take the design information into account in your prototyping. Following that,
you make the observation that, of course, you’ll need to put together a “quick
estimate” on how long it will take to kick out the prototype.
Right about now, you’ll see the light bulb go off over their head as they
realize that the prototype isn’t free. At this point, you do what your marketing
brethren would call “assuming the sale.” This means that you tell management
that it’ll take roughly the same amount of time to put this estimate together
as the design estimate did, so you’ll have the numbers back to them in that
amount of time. If you’re lucky, they’re still staring at the headlights just a bit
and will agree. If not, it’s back to bargaining for the amount of time you’ll get
to do the estimate for the prototyping phase.
Of course, you’ll follow the exact same process with the prototyping esti-
mate as you did with the design phase estimating. Take the days you’ve just
materialized, gather your team, and work through all those high- to mid-level
design issues that you would have liked to have addressed but just didn’t have
the time previously. You should, however, give some thought to the level of
effort required by the prototyping. That will tell you how hard you should fight
when you go back to bargain for the prototyping phase. Otherwise, the tactic is
the same. Propose 1.5 times the duration that they gave you for the design
Chapter 6 Effective Design Under Fire
107

phase and bargain from there. If you honestly think, because of the degree of
prototyping they want done, that you can get more time, remember to ask for
50% more than you expect them to accept and go from there.
When the design phase is done and you’re moving into the prototyping
stage (assuming that you’re using one), build only those prototypes or screen
mockups that are absolutely necessary to convey a concept or get approval. If
this sounds familiar, yes, it’s the exact same attitude with which you approached
the design phase. Prototyping can be an excellent communications tool pro-
vided you don’t let yourself get bogged down in unnecessary detail. Use rapid
development tools and as much smoke and mirrors as possible to provide the
maximum visual feedback with a minimum of code. Remember, there are no
user serviceable parts inside. In fact, if you don’t have to show any actual pro-
cessing, consider using a desktop publishing package, slideshow presentation
software, or any other such tool that makes it easy to put together sequential
screenshots without coding. Keep your focus on the goal of the exercise, which
is communicating with your management and users, and leave the coding to
the implementation phase of the project.
Another benefit of having no code in your prototype is that you can’t use
it in production. You want to avoid code in your prototype at all costs. If you
do have to code but you know from the beginning that it’s a throwaway effort,
then you won’t waste a lot of time on the details. You’ll simply hack something
together that gets the point across using whatever cheap tricks you can come
up with. You’d never do that in production code, of course, but for prototypes,
you don’t care about how solid or maintainable the codebase is. You only care
that it works and meets its purpose. Remember, the prototype is a tool for
clarification and is ultimately for the recycle bin. Fortunately, the maintenance
programmer will never see it.
When You Can’t Get Even This
MuchTime
By now, anyone who has the luxury of doing things The Right Way is doubtless
shaking his head and clucking his tongue over my proposing such an unsophis-
ticated approach to software design. Don’t get me wrong; I’m with you all the
way. This is not my preferred method of operation either. Rather, it’s simply
how I deal with life when I’m painted into a corner by unreasonable manage-
ment. Nonetheless, don’t bother trying to explain this to anyone who lives in
the ivory towers. It’s a foregone conclusion that they won’t be inviting me to
any of their parties. However, while they’re turning up their noses at this
down-and-dirty approach to developing software, I’m busy meeting my dead-
lines, which is what I get paid to do.
Of course, the ironic part is that, although the ivory tower types would
quickly dismiss such a slash-and-burn approach to design, many of you are
108
Part II Guerilla Tactics for Front-line Programmers

doubtless shaking your heads and wondering what planet I live on that makes
me think you’d get anywhere near this much time from your management. As
hard as it may be for some to comprehend, there are shops out there where
even spending a week on design is considered a ridiculous request. 
I was once on a project with three senior-level developers. We created a
system that took the full extent of our talents and a year and a half to imple-
ment. We were given two weeks to design it, and only then after some serious
bargaining. Furthermore, the only reason we got anywhere near that amount
of time was due to the fact that the head of the company was also a program-
mer. Heaven only knows how long we’d have been given if we’d had to bargain
with a Suit.
For any of you who may be new to the programming business, I’ll state it
plainly: two weeks to design a system that required a year and a half to imple-
ment is insanity of the highest order. It’s an exercise in the absurd, and any
highly paid design consultant would probably walk out of the meeting and not
take the client if those were the terms of engagement. Nonetheless, that was
the time we were given and that’s what we therefore had to work with. I don’t
define reality. I just have to cope with it.
So, what if you can’t get enough time to do even this much? Give up? Not
me. I may go down, but I’ll go down fighting. Ultimately, some of the basic
principles remain. The amount of time that you have for design is more a
factor of your negotiating skills than anything else. What you must do after
you know how much time you’re given is make the most efficient use of
what you have.
The things we’ve covered here can indeed be scaled down even further. If
you’re in an extreme situation that may involve only a day or two of design, the
first thing you do is ditch the printed documentation. You don’t have time for
it. In a similar fashion, whether you were creating documents or not, you don’t
have the luxury of a lot of the concepts, such as completely detailing your class
hierarchy. In times like these, ask yourself one simple question: what would
you draw on a whiteboard?
When I say to ditch the printed documentation, I don’t mean that you
should leave no written trace of the design. Rather, I simply mean that you
don’t want to try to draw detailed diagrams or create densely worded docu-
ments. Although you may indeed jot some of this down for posterity in your
favorite drawing tool, they will be sketches. Think framework, not blueprint.
Simpler does not mean less structured; it merely means that you eliminate a
few levels of detail in an organized and consistent fashion. In terms of the dia-
grams and such that you come up with, you can also forget all but the most
basic of symbolism. That might not be quite the limitation that you would
expect. It’s amazing what you can get across with two rectangles and a few
arrows. If you can make it work while standing in front of a whiteboard, you
can make it work on paper. Just remember that it’s easy to get carried away
with details when you’re in front of a computer. You’d never draw all that stuff
on a whiteboard, particularly in a meeting with a lot of erasers handy.
Chapter 6 Effective Design Under Fire
109

If you indeed find yourself in such dire straits, I would recommend review-
ing the approach we’ve covered here, and then mentally making a checklist of
what levels of detail you can eliminate from the process, given the amount of
time you have to work with. Just as we cover only the high- to mid-level design
here because it provides sufficient conceptual boundaries from which to do
more-detailed work, so, too, is this true in progressively higher levels. If you
think of a hierarchy drawing that is fifty boxes at its widest and ten boxes at its
deepest, you’ll quickly see how you can eliminate a few of the middle layers
and still have an organized chart. In fact, I’ve made similar suggestions over
the years regarding middle management, not that it ever did much more than
get me banned from the meetings where the really good donuts were served.
Onward to Implementation
No matter how little time you’re given for design, if you keep the end goal
of delivering software firmly fixed in your consciousness, throw out the rule
book, and trust both to your common sense and to the experience of your
team, you can put together something that will be the foundation you need for
meeting your deadlines. As much as it is a tool for developing software, the
design phase is also the springboard for a good estimating effort. In the end,
no matter how long the project takes, if you do what you said you would in the
time allotted, you’re going to look good. To meet that objective, you need to
know how to put together estimates that you can meet in a consistent fashion.
Our next step, then, will be to move beyond the collective bargaining tac-
tics we’ve had to use thus far and start digging into the details of truly estimat-
ing the implementation phase. Of course, we’ll be sneaking a little design in
while we’re at it, but you didn’t hear that from me.
110
Part II Guerilla Tactics for Front-line Programmers

The dreaded estimate is at the very heart of the software development cycle
and the individual programmer’s efforts to meet deadlines. No one likes doing
estimates, and most developers have a hard time projecting an accurate esti-
mate for even the smallest program. If so many software professionals all have
difficulty with this aspect of the development process, clearly the problem is
not a lack of aptitude on the part of the programmer. In the minds of many,
estimating a software development effort is simply one of the hardest aspects
of our jobs.
Much of this problem exists not because we are unable to determine how
long it will take to code a particular task, but rather because we have insuffi-
cient information with which to work. Even a fortune-teller is going to need a
good cup of tea before she can read the tea leaves. For many things in life, you
simply must have a foundation upon which to build if you wish to have any
hopes of achieving success. So, too, is it in our profession. To offer truly accu-
rate estimates upon which we can base a realistic delivery schedule, we must
perform some preliminary steps. Fortunately, we’ve actually been working our
way through these crucial prerequisites as we’ve put forth the effort to nail
down requirements and knock together a good design framework.
You simply cannot know how long an effort will take if you don’t know
exactly what that effort is. We now have those requirements spelled out. In a
similar fashion, you won’t be able to determine how long it will take to code a
given task if you don’t know how you’re going to do it. We’ve addressed the
larger part of that question as well. Because we intentionally avoided low-level
detail in the design phase, we’ll be working through the rest of how we’re
going to do things as we estimate. In the end, however, we’ll have answered
the two fundamental questions without which we would never be able to ren-
der an accurate estimate for our project: what are we going to do and how are
we going to do it? For those of you who played the murder-mystery board
game Clue as children, these questions may trigger visions of butlers, libraries,
and pipe wrenches in the back of your mind. Believe me, I’ve fantasized about
111
Practical Estimating
Techniques
7
C
H
A
P
T
E
R

a few of those things myself over the duration of my career, but management
and cubicles typically replaced the butlers and libraries. For what it’s worth,
however, I never could seem to find a good pipe wrench when I needed one.
Understanding the Process
Armed as we are now with the answers to the fundamental questions of the
estimation process (if not a good pipe wrench), we’re in a position to kick out
some numbers that actually have meaning in our less than perfect world. Let’s
quickly review all of the steps in the estimating process that are required in
addition to the information we need about what we’re creating and how we’re
going about it. The following list summarizes the steps required for a depend-
able delivery schedule.
1. Estimate everything!
2. Estimate the duration of the design phase.
3. Estimate the duration of the implementation phase.
4. Estimate the effort for the install program and integration issues.
5. Estimate the duration of the release candidate testing/debugging cycles.
6. Estimate the duration of the beta testing phase.
7. Estimate the duration of the post-implementation technical
documentation.
8. Estimate the duration of the postmortem phase.
9. Finally, estimate how long will it take to do the estimating steps.
The first step is perhaps the most important and the most frequently over-
looked. If you don’t estimate every step of the process, from the time manage-
ment dreams up a new project to the time you hand them the keys and walk
away, you have a window of vulnerability. This single window can be enough to
blow your deadline. The last step is a summary of some of the individual steps
we’ve taken thus far as we’ve offered estimates to management of how long it
will take us to give them a particular estimate. It’s easy in the rush of the
development process to dismiss small issues as unimportant and not worth
the time to consider. However, everything takes time, and time is always
cumulative. The little steps you don’t account for can add up to a very big
cup of coffee as you work around the clock to meet a deadline.
You may notice that there isn’t a step to estimate the requirements-gathering
phase. In an ordered and organized shop with a company that is willing to let
you go through an orderly and detailed approach to the requirements phase,
you would want to start by estimating the duration that this phase would take.
112
Part II Guerilla Tactics for Front-line Programmers

However, that’s also only necessary if the clock begins ticking before you begin
defining the requirements. In a shop with management that actually possesses
the common sense to listen to the programmers, that’s probably not going to
be the case. The clock really shouldn’t start ticking until you know what it is
that you’re creating. In an imperfect world, though, the clock usually starts
running the moment management decides they want a new piece of software.
As you’ll recall from our focus on requirements gathering, because this isn’t a
shop where common sense prevails, that phase is the result of bargaining and
political maneuvering as much as anything else. We’re not given the luxury of
a requirements-gathering phase as an official cycle. Consequently, there’s
nothing to estimate.
We’ve also given them an estimate of how long the design phase will take
and have now performed that task, bringing us to the point at which we esti-
mate the implementation effort. This is the next area that we focus on, but you
may have noticed that there are quite a few steps after it. These are also areas
where confusion can get a foothold in the development cycle. If indeed an
estimate for the implementation phase is even formally constructed, it’s often
the last thing considered before the coding begins. The coding, however, is
not the last thing that happens before you polish the bumpers and hand them
the keys to their shiny new high-performance software vehicle. Once again,
failure to estimate and account for these efforts will leave windows of vulnera-
bility through which confusion and missed deadlines can enter. We’ll be
touching on these in a bit more detail following our discussion of the imple-
mentation phase.
Avoiding Common Mistakes
Before we get into the steps we’ll take to deliver our implementation estimate,
let’s first take a quick look at the way it’s normally estimated in the always-
under-the-gun world of the professional developer. I like to think of this as
the Guess Times Two method. When asked how long a particular program or
piece of code will take to deliver, we’re typically not given any time to consider
the details. If management is not standing there waiting impatiently, they will
at least expect us to get back to them before the day is out. What tends to hap-
pen, therefore, is that the programmers take a wild guess at how long it will
take, scientific or otherwise. Then, just to be on the safe side and make sure
that we have a little cushion in case things go wrong, we multiply that number
by two and give it to the project manager. He’s no fool, of course, and knows
that programmers are typically a bit optimistic with their estimates. To avoid
giving management a date that runs the risk of failure, he then multiplies the
numbers he was given by two and turns the estimate in.
One would think that with all that padding, it would be a pretty safe esti-
mate, but in truth, these almost always fall short of the mark. That’s because
without truly thinking through the details of what needs to be done, you’ll
Chapter 7 Practical Estimating Techniques
113

always overlook a great many issues, many of which can be extremely time-
consuming. It’s worth mentioning as well that, in such an environment, the
programmers have also not nailed down the requirements or had the opportu-
nity to do any sort of significant design phase. This weakens their chances of a
good guess even further.
However, at times, the estimates are so overly generous that when multi-
plied by two a couple of times they end up representing far more time than is
actually needed, and the project finishes way ahead of schedule. Great, right?
Nope. Now you have no credibility. Ultimately, for you to gain more control
over the development process from management, you must be able to deliver
accurate estimates and timelines. Then, and only then, will they be able to
believe what you tell them and have sufficient confidence in your opinions and
abilities to trust your recommendations on the best approach to developing
software.
The Myth of the Eight-Hour Day
Another common mistake made when estimating software development centers
on the myth of the eight-hour day. If you’ve compiled your estimate figures in
terms of hours, which in and of itself is rare enough, many project managers
will then convert these numbers to calendar days by simply dividing by eight.
Although that’s a nice convenient number to work with, it’s simply not realistic
when you’re trying to put together a timeline for software deliverables.
Whether you’re designing or coding, you never get eight hours of it done in an
eight-hour day. A significant portion of any normal business day is consumed
by many non-coding activities: scheduled meetings, hall meetings, administra-
tive work, unexpected tasks, and a host of other distractions. Consequently,
any timeline based on the assumption that programmers will be coding every
single minute that they spend at the office is doomed to failure before it even
begins.
To convert hours to days, you need to determine the percentage of your
day that you actually spend coding and apply that to your calculations. A real-
istic modifier is to assume 62.5% productivity, or five hours of coding in an
eight-hour day. Management may balk at this, call you into a meeting, and ask
just what the heck you’re doing with the rest of your time. It’s unwise to retort
that you spend it in just such pointless meetings. Nonetheless, this can some-
times be a bit intimidating. However, if you think that, at the very best, you’ll
get in more than six hours of coding in an eight-hour day, you’re dreaming.
The six-hour coding day is optimistic in many environments, particularly larger
corporations in which bureaucracy is rampant. Consequently, you should start
with six as your absolute best-case scenario and adjust it downwards to reflect
your corporate reality.
Whether you come up with six, five and a half, or five hours of coding per
day, when you try to communicate this to management and factor it into your
114
Part II Guerilla Tactics for Front-line Programmers

timeline, some fur will fly. Regardless of how unpleasant the conversations
may be, it is absolutely critical that you hold your ground and establish this fig-
ure as a constant to be used in all estimates and projections. Let’s look at how
much of a difference this can make in your ability to hit the deadline. For the
sake of example, let’s assume that you work in a fairly busy and bureaucratic
environment and consequently get only five hours of coding in during your
eight-hour day. Management, however, insists that your timeline be based
on eight-hour days. You have five programmers on your team, and with the
calculation of eight-hour coding days per programmer, your project will
take six months to complete. To keep it simple, we’ll call six months exactly
24 weeks and we won’t account for vacations, holidays, and so forth.
Here’s how the numbers come out. You have five programmers working
eight-hour days. Your original estimate was 4,800 hours for the project. Divide
that by eight-hour days and you have 600 programmer days. Divide that by the
five programmers that you have on the project, and you have 120 calendar
days. Using five-day workweeks, that tells us that the project will take exactly
24 weeks to complete, hence the six-month deadline that will loom over our
head.
Now let’s take a look at reality. In our hypothetical environment, program-
mers are actually coding five hours a day. Divide 4,800 hours for the project
by five-hour days and you find that it takes 960 programmer days. Now divide
this by the five programmers you have on your team, and it translates to 192
calendar days. Using the same five-day workweek, our project will actually
take 38.4 weeks to complete. Using simple four-week months for illustration,
this means that, instead of the 6 months that management insisted upon, this
project will actually take 9.6 months to complete. What we have now is a proj-
ect that is due in 6 months that will be 3.5 months late. Somewhere down the
line, someone will figure out that you’re running really, really behind. At that
point, the overtime death march begins. So, you’ll probably spend the last
3 months of the project killing yourself, but it won’t be enough to offset a dif-
ference of 3.5 months. You’ll still miss the deadline. The only thing worse than
being screamed at by management for being late on a project is to have to
listen to this nonsense when you haven’t had a decent night’s sleep in months.
It’s somewhere around this time that the night watchman starts getting a little
nervous and spends a lot more time away from his post under your fifth-floor
window. Don’t worry about his Chihuahua, though. He’s switched his therapy
sessions to evening hours to avoid just this scenario.
Think five-hour days is extreme? Do the numbers with a six-hour day.
You’ll still be late. Really late. However, no matter how many deadlines you
blow, management will typically dig their toes into the sand and cling to the
myth of the eight-hour coding day. If you want your projects to succeed, be
prepared to fight over this. And don’t lose.
I glossed over one point when looking at the number of hours that actually
get spent coding during the day. I made mention of the estimate being made
in hours. This is actually another common and serious mistake that’s made in
estimating the development effort. When asked for an estimate for any chunk
Chapter 7 Practical Estimating Techniques
115

of code, the instinctive response is to offer the estimate in calendar days. This
is probably due to the fact that most shops don’t spend a lot of time estimat-
ing, and it’s quick and easy to throw out a time in days, such as the following
familiar conversation. “Hey, Joe, how long will it take you to code that user
interface?” “Oh, I can have it done in about four days.”
Okay, what’s wrong with this picture? First of all, you have by now devel-
oped a keen eye for such things and doubtless noticed the word about in Joe’s
response. That’s scary enough. Additionally, it appears that Joe gave an imme-
diate response to the question. How on Earth could he know with any degree
of accuracy that he’d be done in four days without so much as four minutes’
worth of research? Finally, how many hours are in a workday? In Joe’s case, I
can assure you that it will be around twenty.
In the estimation process, calendar days are calculated. They are not raw
data. Hours are raw data. If you figure on a six-hour day, then a project that
will truly take 24 calendar weeks to complete means you’re managing a 720-
hour estimate. That seems pretty unwieldy. It’s much easier to get your arms
around calendar days, and weeks are even easier to conceptualize. How then
do we perform an estimate in hours when it feels like the equivalent of build-
ing a sand castle one grain of sand at a time? The short answer is that we break
down tasks until we can estimate a very small task in a very small number of
hours. When we’ve gone through all of the tasks, we simply add up the hours.
Let’s have a look now at the overall process for estimating the coding phase of
the project.
Crunching the Numbers
Working on the assumption that you’ve been able to follow the process thus
far of getting firm requirements and completing a design phase of at least
adequate duration, you now have what you need to build a realistic estimate.
In the end, you may adjust your estimate somewhat to account for any discom-
fort with the degree of design you were allowed. If you feel the process was
extremely shortchanged and there will be much on-the-fly design happening,
the adjustment will factor this in. We’ll discuss this at the end of the estimate.
You will have by now taken care of the partitioning of your system, as it was
a part of the design phase. From this, individual programmers are assigned
their areas of responsibility in the system. The overall estimate for the project
will be built in a bottom-up fashion, starting with the detailed view of the indi-
vidual developers and eventually summarizing the numbers in a manner suit-
able for management’s consumption.
Each programmer will now begin work on his personal estimate. This
begins by breaking his work down into progressively smaller chunks. Doing
this in a hierarchical fashion, you will eventually reach a level of detail where
they’re small enough to be identifiable programming tasks.
116
Part II Guerilla Tactics for Front-line Programmers

As you recall, we intentionally kept our design phase at a high- to mid-level
view of the system, with the understanding that we would delve down into
lower-level details when the estimating was done. We now can perform this
low-level design. Our design phase may well have stopped at the level where
we said, “Okay, when the user pushes this button, we print the invoice.” If you
happen to be the programmer tasked with making this printed invoice a real-
ity, you haven’t had a chance to think through all the details involved until
now. However, you can’t really determine how many hours a task will take
until you know exactly what it is that you’re doing.
In dividing the overall assignment into progressively lower levels of detail,
you proceed by continually asking yourself exactly how you will accomplish a
particular task. This is the time to think like a programmer. In other words,
you need to be thinking specifically about how you will write the code. If you’re
unfamiliar with a technology that’s needed for the work you’re doing, take as
much time as is realistic to research it and get a feel for what you’re up against.
If you’ll be depending on routines from other developers on your team
(as is often the case), batch up your questions and then get together with the
appropriate programmers. You’ll want to get an idea from them of the amount
of effort that will be required on your part to use their routines. For instance,
if you need to get the customer information in the process of printing the
invoice, it’s likely that another programmer will have written the routines
you’ll call to access the database. Your question to him will center on how
many hoops you’ll have to jump through to accomplish this. Will you be able
to call one routine to get the data? If not, how much effort and how many calls
will be necessary to accomplish this? What parameters are you going to need?
The answers to these questions will give you a pretty good feel for how long it
will take you to write the code.
Because we don’t have the time to do a complete, highly detailed and 
low-level design in our less than perfect environment, these questions will by
necessity be a bit loose, and once again the interpretation skills of the individ-
ual programmer will be an important part of the process. Unless you’ve been
given an extremely generous amount of time to do the implementation esti-
mate, the programmers you meet with will not have the fully detailed inter-
faces prepared and documented for you. They should, however, be able to give
you a pretty good idea of how they’ll approach things and what’s involved for
you. That will have to be good enough.
As you’re working through the estimates of your assignments, you’ll also
be making use of the document types that you put together in the design
phase. As you determine what’s needed to implement a given module, you’ll
use these to sketch it out. In such a manner, you’ll be generating the low-level
design documents you need at the same time as you analyze your tasks for the
purpose of estimating.
How low do you go when breaking things down into more detail? No indi-
vidual coding task should ever be larger than four hours, and that extreme is to
be avoided. If you’re averaging around two hours per coding task, you’re prob-
ably low enough to have some confidence in how long it will really take to
Chapter 7 Practical Estimating Techniques
117

write the code. At this level, you’re forced to think through the details at a
function level. The larger the chunk, the greater the margin for error when
estimating. Even if the number is less than four hours, if you don’t feel confi-
dent, keep breaking it down until it feels realistic. Durations of quarter and
half hours are perfectly acceptable. What you’ll end up with is a list of individ-
ual coding tasks and their associated durations.
Now fire up your favorite spreadsheet program. List each coding task and
the number of hours required. Be sure as you’re estimating the individual cod-
ing portions that you include time for unit testing and a little debugging. Also
keep these numbers as real as you can get them. In other words, these num-
bers won’t have any padding. Be conservative, but keep the numbers legit.
Now we want to summarize these numbers. Add up the estimates for all
of your coding tasks. If this total is more than forty hours, start breaking your
work down into progressively smaller modules with a subtotal for each until
none exceed forty hours. Naturally, you’ll want to align these divisions to the
actual module divisions in your overall assignment. You now have your coding
assignments detailed and individually estimated, as well as having a list of
subtotals that summarize these detailed estimates.
It’s a forgone conclusion that, as you code your work and hand it over to
whoever is doing the testing, there will be bugs. This means that you’ll have to
take the time to diagnose the problem and fix it so that your testers can verify
the fix and move on. You must leave room for these QA failures in your esti-
mates or you’ll just start getting behind when they happen. To account for this,
for each subtotal that you’ve created, you’ll add a line reading “QA Failures”
and set the value to a calculation of 10% of the subtotal. As you go along, you’ll
also hit snags and bumps in the road that you could never have anticipated. If
you ignore this reality, you’ll only get behind when it happens. Consequently,
for each subtotal you’ll also add a line reading “The Unexpected” and also set
this value to 10% of your subtotal.
For each subtotal, you now add a “Complete Subtotal” line. This value will
be the sum of the subtotal and the two lines you added for QA failures and the
unexpected. It’s now time to add the bottom line, which summarizes these
completed subtotals into one final number, which is the total amount of hours
that it will take you to deliver your coding assignment.
Converting Hours to Delivery Dates
You’ll actually have two deliverables to pass along. The first will be this sum-
marized set of raw hours. However, a timeline and delivery schedule are more
than just numbers. Dependencies must be taken into account as well. For
instance, if you’re the one doing the invoice printing, you’re going to need the
data-access routines before you can finish. If the other programmer has other
tasks to complete before he can get to the ones you need, you may experience
a delay.
118
Part II Guerilla Tactics for Front-line Programmers

Additionally, it’s not enough to simply calculate how long a project will take
based on hours, convert those to days, and subsequently a calendar delivery
date before you begin coding. You need to be able to track your progress as it
goes along so that you’ll know if a problem arises. Naturally, it’s our desire to
orchestrate our work such that no overtime is required and the project is
delivered on schedule. However, even with factoring in the unexpected, we
may still fall behind at points. If we realize this quickly, we can apply a brief
moment of extra effort to get back on schedule, and then continue on with a
normal and reasonable workweek. Failure to do this will result in an end-of-
project crunch and all the stress, overtime, and nervous little dogs that accom-
pany it.
The way we handle this is to set incremental milestones along the way for
each programmer. Along with the estimate figures turned in, each program-
mer will also define the preferred order of his tasks. I say preferred, as this
may change due to dependencies. In a separate document, the programmer
will list the order in which he wishes the tasks to proceed. He will additionally
make note of tasks that are dependent upon other circumstances, as well as
note tasks that can occur at any point in the process, regardless of the pre-
ferred order. This information, along with the hourly estimates, is passed along
to your team lead or project manager. If team leads are in your structure, they
will, of course, summarize the estimates from all of their developers and
report this to the project manager.
At this point, a lot of work falls on the shoulders of the project manager, or
whoever happens to be walking point for your project. Even if you’re the sole
programmer on a project, you should take the time to follow the next steps.
Although you may not have any dependencies, the rest of the process applies,
regardless of the size of the team.
Your first task as project manager is to convert the estimates you’ve been
given from hours to calendar days, based on the five- to six-hour coding days
that you’ve determined are the reality for your environment. Using these days,
you’ll eventually be building your timeline based on five-day weeks. You must
also factor in company holidays, vacations, and any other known days that pro-
grammers will not be in the office, such as time off site for developer training
seminars, participation in user training sessions, work as a maintenance pro-
grammer on previous versions of products on which they’ve coded, and so on.
Now that you know how many days that the chunks of work will take, it’s
time to arrange the individual programmers’ tasks according to any existing
dependencies. If you don’t have a project management software package avail-
able to you, see if you can get management to approve one. It’s a relatively
small expense because you don’t need a license for each developer. The proj-
ect manager is the only one who will be using it. The programmers certainly
won’t be interested in it and will avoid it like the plague if at all possible.
However, when you’re trying to order a set of tasks that take dependencies
into account, project management software pays for itself the first day in
terms of the time you save.
Chapter 7 Practical Estimating Techniques
119

Naturally, you can order dependencies by hand if you must, although
that sort of thing tends to make for cranky project managers, to be sure.
Nonetheless, regardless of the tools you have at your disposal, you must now
order the efforts of each developer so that, if at all possible, no one is sitting
idle waiting for someone else. If you do find such a stopping point, ask the
developer who would be idled if there are any tasks that he can break down
further, so that when he’s waiting for someone else before he can continue
with his current task, he can perhaps switch over and work on the internals of
another task that have no dependencies. If this is possible, these switchover
tasks are then broken out and subtotaled separately.
Having ordered the efforts of the individual developers, the project man-
ager then defines a series of milestones for each programmer. A milestone is a
date by which a specific task is due. Having these milestones is how you keep
track of your efforts and know if you’re falling behind. Just as you kept your
granularity small on the hourly estimates, keep the milestones small as well.
In addition to minimizing the vulnerability of any one portion of your schedule,
it has an additional benefit: having many small milestones allows you to rack
up multiple successes. At any point in the process that management cares to
check in, you’re able to report that not only is everything right on schedule,
you’ve already hit 42 of your projected milestones. Remember, every single
success enhances your credibility with those further up the food chain. If you
want to change the way they do things, you have to be able to prove that your
ideas actually work. Having multiple milestones in a project gives you just this
opportunity. As such, your milestones should not be longer than two weeks at
a time. Smaller is better.
Based on the module dependencies, you now lay out these incremental
milestones that will, when combined, represent the overall timeline for your
project. Project management software will allow you to plug in holidays and
weekends, and automatically derive the dates for you based on the number of
hours in your day. In our case, that will be between five and six. It’s not until
this point that you can truly fine-tune the dependencies. Although you were
able to take an initial swing at it prior to this point, you’re now dealing with
actual calendar dates and can see exactly when one programmer is to finish his
deliverable and when the next programmer needs it. As such, there may be a
bit of tweaking and reordering at this stage of the game. After any ordering
issues have been ironed out, you’ll be able to determine your actual specific
milestones with their associated dates for each of your developers.
You now know how many hours small, granular coding tasks will take.
Based on a realistic coding day and the consideration of holidays and other
time off, you also know how many calendar days each task will take. You’ve
ordered the efforts of your developers such that there is no idle time due to
dependencies, and you’ve given them their list of milestones. They now know
what tasks they are to perform and the order in which they should proceed.
They also know what their deliverables are and when they are due. You now
have everything you need to keep a very close eye on the project. Based on
the programmer milestones, you now summarize these into slightly higher
120
Part II Guerilla Tactics for Front-line Programmers

milestones appropriate for management. For larger projects, milestones in
months are fine for middle and upper management. However, list each indi-
vidual programmer milestone that will occur as a line item under each major
milestone. This gives you plenty of ammunition when they question your
progress, as you’re able to not only tell them that a major deliverable is on
track, but exactly which lower-level milestones you’re currently implementing.
Being able to report in this degree of detail is the sort of thing that increases
management’s confidence in you. A good field commander must know the
status and position of his troops at all times. A good high-level commander
must be able to depend on his field commanders for this.
Don’t Forget the Final Details
We have now estimated and organized our implementation effort, but we’re
not quite ready to turn in the paperwork. Before you can give management a
date when they can consider the software ready to ship, you need to take into
account several other steps that happen after the implementation is complete.
First, using the techniques we just outlined, identify the programmers who
will participate in writing the installation programs and scripts or who deal
with any other related installation or integration efforts. They’ll usually be
junior programmers, not because of the skills involved, but rather because all
of the senior programmers will have mysteriously vacated the premises when
it comes time to make these assignments. Add these estimates to your timeline
as a separate milestone, breaking them down into smaller milestones if
needed.
The next step is a bit less specific: you must estimate the duration of the
testing and debugging cycles of the release candidate. This will have to be
done based on a combination of experience with past releases and the amount
of time that you think management will stand for before they insist that you
release the product. In truth, testing is almost always curtailed long before it
should be, and this explains the poor state of most commercial software cur-
rently on the market. Nonetheless, we’re trying to deal with reality here, so
the numbers that you come up with on this are again a cross between practical
experience and collective bargaining. This phase will also be listed in the time-
line as separate milestones.
If you can swing it, your project should have a well-defined beta testing
phase as we’ve previously discussed. The time considerations for this are much
as they are for the release candidate testing phase. Take what you can get and
put another milestone in the project timeline. 
At this point, you have the timeline complete in terms of when the product
can be shipped, and you want to label the product release date in big bold
letters on the timeline. However, it does not fully represent when the develop-
ment team will be available for the next assignment. If you don’t include this
in your timeline, you risk getting sucked into the next adventure before you’ve
Chapter 7 Practical Estimating Techniques
121

brought this one to complete closure, which will surely bite you in the mainte-
nance phase. Actually, it will bite you somewhere else but I’m trying to be
polite.
After everyone has had a good night’s sleep or two, you want to convene
the entire development group including testers, technical writers, program-
mers, installers, trainers, and anyone else who had a hand in making the prod-
uct a reality. First and foremost, never underestimate the value of morale. If
you’re in charge, you’re looking at a room full of people who just put in a sig-
nificant effort, kicked fanny, and took names. This is the time to let them know
how much you appreciate all that they’ve done and to tell them in no uncer-
tain terms just how great you think they are to have done so.
Little plastic plaques and awards are considered a shallow and insulting
joke by most corporate workers, but, oddly enough, middle and upper man-
agement never seem to pick up on this. Maybe they just live in their own little
world and don’t bother to pay attention to what matters to the troops who do
the real work. If at all possible, the best way to reward people for excellent
work is with money, or anything else that has real and tangible value such as
extra vacation time (that you actually let them use), holiday packages in resort
hotels, or any other real, live perk that they can enjoy. Unfortunately, in many
companies, the project manager just doesn’t have that authority or influence
over management.
This doesn’t mean that there’s nothing you can do to maintain the morale
that has already given you one success. Although money is the reason we go to
work each day, it’s an extremely understated and overlooked fact in the busi-
ness world that people will practically kill themselves putting out excellent
work for nothing more than recognition and sincere public appreciation from
the people they work for.
I know that this is what the little plastic plaques are supposed to be about,
but for some reason, it just doesn’t sell to the rank-and-file production work-
ers. Maybe it’s all the corporate speak and buzzwords that make it seem phony,
but there never seems to be any true sincerity behind it. Rather, it comes
across as an empty ritual. Praise and recognition work to motivate and gratify
people only when it feels personal.
Consequently, if you’re a project manager and you can’t get any real bene-
fits or rewards for your people, at a minimum, you can tell them face to face,
in front of their peers, about the things you saw them do that really made a
difference. Trivial as it may seem, you can also get the point across by taking
some money out of your own pocket to do things as simple as taking them all
out to lunch. If you explain to them that you’re not able to get them the tangi-
ble perks you think they deserve but show them that nonetheless you want to
do something for them on your own, you’ll find that an extremely loyal group
of people are backing you on your next project. If you can do this throughout
the course of the project—occasionally ordering the pizza when they’re work-
ing late, inviting them over to your house for a weekend cookout and all-day
122
Part II Guerilla Tactics for Front-line Programmers

boogie to help keep spirits up, or any other little things to show them that you
truly appreciate what they do for you—you’ll find that there’s absolutely noth-
ing they can’t find a way to accomplish. Esprit de corps is an extremely power-
ful thing.
Wrapping Up the Project
This may seem a bit of a digression while we’re discussing estimates, but the
next milestone we want in our timeline is that of the project’s postmortem
phase. While the term technically translates as after death, it’s generally used
to describe the assessment phase after a project is complete. In our case, it
will be the evaluation of what we went through to succeed. This is where your
people have a meeting or two and discuss the things that went wrong and how
they can be avoided the next time, along with the inspirations that team mem-
bers have come up with for additional ways to improve the process. This is a
crucial phase, not only for the purpose of the aforementioned morale, but
also in terms of fine-tuning your overall development process. After several
projects and their subsequent evaluation phases, you’ll start getting a really
streamlined approach to delivering software in your company’s environment.
Of course, the time for the postmortem phase will be another time element
for which you’ll have to negotiate.
The next thing you want to do is put together accurate technical documen-
tation that reflects the reality of your codebase. Your design documents, com-
plete with coffee rings, red ink, and torn pages, will be of some use to you
here as a starting point. However, each programmer must take the time to go
through his code, and from these two items, create a new set of documents
that tells it like it is. Before you slough your way through this, bear in mind
that this is the documentation that the maintenance programmer will be trust-
ing when he’s trying to fix your bugs at two o’clock in the morning. Unless
you’ve found a way to take the inventory control program offline, I’d suggest
you do a good job on this. Besides, you never know. You might be the mainte-
nance programmer.
The amount of time you get for post-implementation technical documen-
tation is again a matter of bargaining. Take the amount of time that you think
will fly with management, multiply it by 1.5 for bargaining purposes, and list it
on the timeline as yet another milestone.
Many of the steps after the actual implementation are ones for which there
is no procedure for determining the time. Instead, being aspects that must be
negotiated, they might change. Keep this in mind as you turn in your now
complete timeline to management and be prepared to tweak the appropriate
areas if needed. However, hold firm on your implementation estimates
because they’re crucial to your ability to deliver on time. Pick your battles if
Chapter 7 Practical Estimating Techniques
123

you must. It’s much more important to have them sign off on the implementa-
tion estimates than it is to gain an extra week for technical documentation.
It’s nice to get both, but have your priorities in order if you have to fight for
one and give a little on the other.
What If Things Didn’t Go by
the Book?
The possibility exists that you weren’t given the time to do the requirements or
design phases. How does that affect the implementation estimates? Naturally,
if your requirements are fuzzy, you’re going to get into trouble when they
change the rules on you in the middle of the game. There’s just not much that
you can do about that. As for design, if you can at least get a little time to do
the implementation estimate, you can compensate somewhat. We’ve used
this phase as a covert way of finishing the design by performing the low-level
design as we’re in the estimation phase. In a similar fashion, if you’re in an
extreme bind, you can take your best shot at high- and mid-level design at this
point as well. 
In an extremely abbreviated fashion, you simply gather together at the
beginning of the estimating phase and hit the whiteboard, sketching out the
major high- and mid-level modules. In extremely poor environments, you may
have only a matter of hours to do this, but even this amount of effort gives you
a chance to think your way through the system. You then partition the modules
out and assign them to the programmers, who perform the implementation
estimates and lower-level design just described as much as is possible in the
time allowed.
If you find yourself in such a situation, I hope you’ve got some seasoned
developers on your team, because much depends on the individual abilities of
the programmers. No matter what your situation, however, it is better to take
a shot at high-level design and low-level estimating than to do nothing. It may
not put you in a position to succeed, but it may at least temper the scale of the
disaster on the horizon. In other words, do the best you can with what you
have to work with, but have a plan and follow it. A little organization goes a
long way.
Once again, there’s also the very real possibility that you may turn in your
timeline only to have management balk and say that the release date is unac-
ceptable. If your management is completely unreasonable, no books or proce-
dures on the market can help you. Given their position on the food chain, if
they insist on your doing something stupid, you must either perform the stu-
pid task or update your résumé. That is the reality with which we all must live.
However, you can do some things to increase your bargaining power for the
next project.
124
Part II Guerilla Tactics for Front-line Programmers

For example, document the exchanges that you had with management, the
dates that you had them, your recommended dates, and the dates they forced
upon you instead, along with any other such scenarios where you tried to
provide a realistic process and were overridden. Keep these documents at
home, not the office. Don’t even think about making the statement that infor-
mation on your work computer should be private. You don’t own the computer.
The company does. If you want something kept private, keep it at home.
When the project crashes and burns at the end, as you know it will, the
records you’ve kept regarding the progress, the problems you encountered,
and the decisions made by management are supportive evidence that you can
use to bolster your position on the next project. When you once again fight to
put an ordered procedure in place for the development process, you’ll be
reminded that your last project was late, or perhaps even a disaster. Assuming
you’re prepared to fight until you get control of the process, you now have the
highly detailed evidence you need to give them both barrels. Diplomatically, of
course. It will be particularly useful if you can show that all of your tasks did,
in fact, take the amount of time that you estimated. This leads to the obvious
conclusion that, if your original timeline were honored, you would have deliv-
ered on time.
If the delivery date was unacceptable to management, the options were
either to reduce functionality or give you additional resources, not ignore the
realities of how long the work was going to take. No one likes to have this sort
of thing thrown in their faces, to be sure. Nonetheless, unless you’re content
to work on disaster after disaster, you’re going to have to stand up and fight
for a realistic development process if you’re going to institute any degree of
change.
In the end, it’s all about power. Your power to create change for the better
will be based on your ability to document your successes and identify the
processes that ensured your failures. The more times that you can prove that
your methods work and lead to the successful deployment of software proj-
ects, the more power you’ll gain for the future. One of the most critical ele-
ments of this is your ability to accurately project the duration of your efforts.
Learn to estimate software development accurately, and you’ll gain the credi-
bility that you need over time to let control of the process come back to the
programmers, where it belongs.
A large part of your project being considered a success is not only your
ability to hit the deadlines, but also having a solid and dependable system
when it hits the streets. No one cares if you delivered on time if your system is
as stable as a house of cards. Consequently, one of the key elements for deliv-
ering high-quality software is the quality assurance process, which is curiously
absent in all but a few development shops. That’s where we’re headed next.
Chapter 7 Practical Estimating Techniques
125

Right up there with the fate of all those single socks whose mate goes missing,
one of the great mysteries of the universe is how an industry that produces
something as complex as computer software can exist with the almost com-
plete absence of highly trained, skilled, professional testers. Actually, I have
some theories concerning the secret life of socks without partners that typi-
cally involve late nights at a noisy singles bar drinking fabric-softener shooters
and dancing to old fifties rock tunes. Isn’t that where the sock hop really got
its name? You may think that that’s a bit fanciful, but it can’t hope to compare
with the notion of programmers spending months or even years writing hun-
dreds of thousands of lines of code only to have management ship the product
with less time spent on testing than it takes for a stray sock to get a date on
Saturday night. It’s so bizarre it just can’t be real. However, for those of us who
have spent many a late night in frantic debugging sessions trying to do damage
control on such hastily shipped programs, it’s a reality that is far too convincing.
How is it that the concept of quality control can be so completely alien to
the very industry that needs it the most? Can you imagine the fiscal and navi-
gational chaos that would ensue if automobiles were sold with the same casual
attitude that accompanies a software release? Even a casual inspection by the
manufacturer would reveal whether wheels were completely bolted on or if
the throttle had a tendency to stick somewhere between the posted speed
limit and Mach 1. Attorneys would have a field day if automotive manufactur-
ers delivered cars with brakes that worked, well, most of the time. Yet, in the
software industry, these examples pale in comparison to the state in which
programs are commonly delivered to paying customers.
127
Fighting for Quality
Assurance
8
C
H
A
P
T
E
R

How Do We Get Away with
Buggy Releases?
One of the reasons that our profession is so incredibly sloppy in its standards is
a very simple one. Why do companies ship buggy software? Because they can.
This is due to a couple of fundamental differences between the manufacture
of software and the manufacture of hard goods that you can touch and feel.
First of all, if a manufacturer delivered 10,000 cars that each had a dozen fun-
damental flaws, the cost of returning them to the factory, taking them apart,
scrapping the defective parts, putting them back together again, and deliver-
ing them once more to the dealerships would be astronomical. Just one such
fiasco could very easily put a company out of business. Even if the company
survived the financial losses, consumer confidence would plummet. Who in
their right mind would want to buy a car that might crash into a telephone
pole due to faulty steering and undependable brakes? An automotive manu-
facturer that actually released finished products that are comparable in quality
to the typical software release would be out of business within a week.
Software, however, is quite a bit different in this regard. There’s very little
cost involved in putting out a patch for a bug discovered in a released product,
particularly because the maintenance programmer who worked around the
clock for three days straight to fix it is on salary. No wonder maintenance pro-
grammers are a little cranky. Because of this, we don’t have the same financial
accountability faced by those who work in factories. The primary cost of soft-
ware is labor. If you don’t pay for overtime, then (from a business perspective)
there’s no real incentive to avoid it. Consequently, it’s easier to just ship the
product early to beat your competitors to market and worry about the bugs
later. This is done so often that it’s probably taught in colleges to the people
getting their MBAs. From a very simple profit-and-loss perspective, there are
no advantages to spending months on testing, not to mention the additional
payroll incurred by having to staff quality assurance professionals. The ease
with which users can now download patches from an Internet Web site just
makes matters worse. It seems to validate management’s decision to skip the
rigorous testing that’s so crucial to other industries.
Another reason we get away with this has to do with conditioning the con-
sumer. We, as an industry, have been shipping poor-quality software for so
many years now that the general public has become convinced that all soft-
ware will just naturally have bugs. They view it as an inescapable reality that
cannot be changed. If you told them that it was possible to deliver software
that was 100% stable and bulletproof—an application that never, ever crashed
or misbehaved—they’d probably eye you cautiously and ask just how much
fabric softener you’d been drinking.
Those who manage software companies believe that they have absolutely
no incentive to convince their customers otherwise. Indeed, it seems like they
have it made. Why in the world would they want to change the status quo
when they have their customers so snowed that they would never dream of
128
Part II Guerilla Tactics for Front-line Programmers

holding a software company’s feet to the fire as they would an automobile
manufacturer’s? You can talk to management about excellence, quality, art,
moral obligations, and other idealistic things until you’re blue in the face. But,
if you’re not speaking in terms of profit and loss, you’ve lost your audience in
the first sentence. This is the business world. It exists to make money.
When you factor in the general public’s insatiable desire for new software,
it’s easy to see that, between their hunger for the latest gadget and their condi-
tioned acceptance of buggy products, businesses are effectively shielded from
the consequences of poor quality control. In short, our management short-
changes the testing process because it seems profitable to do so.
Because of this, testing is not taken seriously as a discipline in our industry.
What little spot-checking that does occur on our systems before we ship them
is usually done by whatever general office personnel happen to be available
at the moment, and that’s only if no other department is screaming for the
resources. Consequently, in a classic example of supply and demand, you’ll
find yourself hard-pressed to hire a top-notch quality assurance team. Although
some have chosen software testing as their trade and have the skills and train-
ing to back it up, there just aren’t very many of them around when you com-
pare their numbers to the hordes of programmers kicking out code every day.
That doesn’t help matters. I have personally spent months and months trying
to hire a single senior-level tester without success, and this is in a city with a
huge pool of software professionals available. That makes you look pretty stu-
pid after you’ve just fought tooth and nail with management to get approval
for the position. However, the difference in quality that even one good tester
can make negates that in very short order.
Justifying a Quality Assurance Effort
It would seem thus far that, no matter how much sense it might make in terms
of quality software, from a business perspective I haven’t made much of a case
for hiring testers. However, like many things, it seems this way if you look at
only a small part of the overall picture. It is undoubtedly true that on the front
end, the expense of software QA is a net loss when you can get your customers
to download bug fixes at no cost to your company. However, that doesn’t take
into account the bane of software profits everywhere: technical support.
With absolutely no disrespect intended towards tech support professionals
(some of these guys make maintenance programmers look positively tame in
comparison), support is universally considered an expense by management.
As such, it is kept to the absolute bare minimum staff that can be maintained
without having your customers show up on your doorstep with pitchforks and
torches. That might explain why some of these folks are a bit on the excitable
side.
However, what’s often overlooked is that the amount of money that must
be spent on technical support to keep your office lobby from looking like a
Chapter 8 Fighting for Quality Assurance
129

village mob scene from an old Frankenstein movie is in direct proportion to
the quality of the release. The buggier the release, the more effort you have to
expend to convince your paying customers that giving you their money really
wasn’t a bad idea, no matter how it may seem. If you shortchange your support
effort, the usually forgiving public will eventually write your company off as an
establishment that markets absolute garbage. Let me tell you, folks, given the
slack that the paying public gives the software industry, if they get to that
point, you can kiss your revenues good-bye. Sales will plummet, and the only
thing left of your profits will be that shiny red sports car that the CEO some-
how managed to buy when no one was looking. Put out enough bad releases
and eventually your reputation and your income suffers. That’s a net loss that
could be prevented by taking quality assurance as seriously as you do any other
aspect of the development process.
Another expense caused by bad releases is the end result of programmers
working night and day trying to patch up buggy versions. Even if they’re being
paid salary and given no financial perks whatsoever for the additional hours,
the time they spend fixing problems that never should have gone out the door
in the first place is time that they can’t spend on your next product. While your
competitors pour all their resources into getting their next version to market
before you do, your programmers are busy putting out fire with gasoline. Of
course, you can solve that problem by simply hiring more programmers so
that some do maintenance and others work on new development. Now you’re
spending money and chewing into profits. Either way it’s gonna cost you. The
latter is just more obvious. Eventually, your best and brightest developers will
tire of the treadmill and opt to leave for greener pastures. Losing talent is
more expensive than either of the two previous scenarios. All of it is more
expensive than hiring professional testers.
Although management is ultimately responsible for the decisions that are
made, programmers are not blameless in this area. The plain and simple truth
of it is that programmers do not fight hard enough to change these things.
They’d rather be coding. And they will be, just as soon as those bug reports
start coming in from the field. As in every other area of the development
process that we’ve touched on thus far, it may be an uphill battle, but with
persistent effort, management can be persuaded to try a quality assurance
process. It will be harder for you to track absolute results in this area when
you want to demonstrate to those up the food chain that the QA process has
more than paid for itself. Still, everyone loves a winner. When your releases
start going out the door on time, bug reports slow to a trickle, and the overall
feedback from your customers is positive, management will eventually notice.
Marketing will notice as well, for your sales will doubtless increase with the
quality of your product.
If you can convince management of these things, at least enough to get
their attention, the next thing you’ll typically have to do in your fight for test-
ing resources is to explain exactly what a QA person actually does. You’ll find
that, although they think they know what a tester’s job description is, it will be
a far cry from reality.
130
Part II Guerilla Tactics for Front-line Programmers

What’s a Tester?
The first and most fundamental aspect of a quality assurance professional is a
person who, strangely enough, spends his entire workday involved in nothing
but duties related to software testing. This will certainly seem unusual to man-
agement, who typically considers the receptionist a tester after pulling her off
of the telephone for two hours. A full-time tester is just that—a full-time
trained professional. Hijacking anyone who can at least click a mouse is not
going to yield the highest quality results.
A professional tester is also a person who studies the art and science of
software QA with the same degree of devotion and interest that a programmer
applies to learning the latest coding technology. Testers are constantly thinking
of new ways to improve the process and keep up with the latest approaches
and methodologies, just as we do in our world.
What output does a tester produce? The cornerstone of any testing process
is the test plan, a detailed approach to putting your software through the
wringer in a very thorough and methodical manner. Test plans are an organ-
ized and structured collection of test cases. An individual test case is the pro-
cedure for verifying one small and specific piece of functionality.
For instance, if you’ve written a word processor, one test case would
involve invoking the file-save mechanism and making sure that the work is, in
fact, saved to disk. However, it’s not as simple as scribbling on a piece of paper
a reminder to save the file. Most GUI applications feature multiple ways to
accomplish the same task. You might save the file by invoking a selection from
the main menu, or you might also select a button on a toolbar. Additionally,
there will probably be a keyboard shortcut, as well as multiple places where
you might be able to choose the function from a context-sensitive menu. The
test case for saving a file would offer step-by-step instructions for each of these
discrete operations. Furthermore, you can’t really say that you’ve successfully
saved a file until you’ve read it back in and confirmed that the contents don’t
now look like hieroglyphics from some ancient language. Consequently, each
test case will also have explicit instructions for verifying that the desired result
did in fact take place. The combination of performing the detailed actions and
validating the results constitutes the complete execution of one test case.
As you can no doubt imagine, writing such detailed test cases for the entire
software system is a full-time job in and of itself. Of course, that’s rather the
point. There’s no way that the developers or any part-time resource is going to
be able to build a test plan of this quality and comprehensiveness. Typically,
the tester will create these documents in the company’s standard word proces-
sor, and they should be stored in version control in a separate project dedi-
cated to QA. Along with the detailed steps to perform, these documents (when
done well) also have a checkbox next to each case so that whoever is running
the test can keep track of his progress. A signature line with a date is also com-
mon so that the QA manager, or project manager if the former doesn’t exist,
can keep track of what tests were performed and by whom. A database can
Chapter 8 Fighting for Quality Assurance
131

also be used to track the information, but it’s frequently handier to have paper
and pen nearby when executing the test cases because running a database app
might interfere with the test. Never underestimate the value of low tech.
Automated testing tools are also available for most major platforms. These
are powerful programs that offer the ability to record the user’s actions for
subsequent playback, thus speeding up and automating specific tasks. It is
common for such programs to save these operations in the form of a script,
typically using its own proprietary language or API. This will then allow the
tester to edit the scripts and customize the operations further. Along with
automated program execution, these systems have various methods of captur-
ing screenshots for comparison to a previously saved reference, comparing file
contents and other such things. This allows them to generate reports at the
end of a test run so that you can fire off an overnight regression test and check
the results in the morning. As with so many other computer-automated tasks,
you can perform a tremendously complex series of tests overnight or in the
space of an hour or two that would normally have taken manual testers a week
to run. As you’ve no doubt already guessed, a professional quality assurance
person is someone who learns to manipulate such automation systems with the
same degree of skill and productivity that a programmer demonstrates with a
compiler.
Earlier, I mentioned both art and science in relation to testing. Just as pro-
gramming is neither art nor science alone, but rather a creative but still scien-
tific combination of the two, so too is testing. We’ve just touched on some of
the more technical aspects. To these, the veteran tester adds the concept of
free-play testing. Actually, that’s probably the only kind that most apps have
seen. In free play, the tester simply uses the software, noting any deficiencies
encountered while doing so. It’s not as simple as it may seem, however,
because when a bug is found, the tester must write up a bug report. A crucial
requirement of any bug report is a list of detailed steps to reproduce the prob-
lem. This is easy when using a test case because it’s already documented.
However, in the case of free-play testing, many times, a tester must spend
hours trying to find a consistent method of reproducing an obscure and inter-
mittent bug. The tester must then be able to communicate what he did with
the same step-by-step precision required in writing a test case so that the pro-
grammer can first reproduce and then fix the deficiency. This is an acquired
skill.
Beyond simply using the application in a manner that’s likely to be similar
to that of end users in the real world, the seasoned tester also adds another
approach to the free-play phase in which he actively and cleverly tries to break
the application and intentionally cause problems. This is often a rather intu-
itive approach that combines years of testing experience with an intimate
knowledge of the application under test. You just wouldn’t believe some of the
stuff these guys pull. When they come to you with some rather fanciful scenar-
ios, you must chant to yourself, “better here than in the field.”
I once had a tester perform a particularly nonsensical sequence of key-
strokes that culminated in the application crashing in a very vivid and
132
Part II Guerilla Tactics for Front-line Programmers

memorable fashion. After offering the obligatory profanity, I told her that her
example was ridiculous and that I strongly suspected that she came up with
this sequence by randomly banging on the keyboard. Who, I asked, would ever
perform such a highly speculative sequence of events? Her response came
swiftly and with conviction: the user might.
She then admitted, with pride, that she had in fact been randomly banging
on the keyboard and then subsequently figured out exactly how to reproduce
it. Without question, she was a testing goddess. The bottom line is that no
application should ever crash, no matter what the user does. If it’s a bogus
action and will cause harm, the programmer should simply not allow it. That’s
how you write a solid app. It takes seasoned, veteran testers like this to help
you make your system bulletproof. You won’t get there without help. Of
course, this may also explain those mornings where I could swear that I saw
tiny canine footprints on my keyboard. In their quest for quality software,
testers can make some strange alliances.
After getting a quick look at the life and times of a professional software
tester, you can see why you need people who dedicate their professional
career to garnering these skills. Any programmer knows all too well how
complex even the simplest of applications can be. The thought of trying to
methodically test every possible code path just makes me twitch. Truly achiev-
ing this goal may be possible only on paper, but the closer you can get to it, the
more confidence you can have in your program. It is the tester’s goal in life to
do just that, and it requires every bit as much skill, experience, and training as
does coding.
Building Your Team
Now that you know what professional testers do, all you have to do is get man-
agement to hire some, right? Good luck. To those in positions of power, testers
are perceived as nothing more than minimum-wage workers who sit in front of
a computer and use the program. Like so many other things in the corporate
world, if you insist on trying to change that all at once, you’re doomed to fail-
ure. Instead, the road to success is an incremental one.
In the beginning, management will probably not commit the money to
hiring trained professionals, even if you’ve managed to at least partially con-
vince them of how important it is to the overall development effort. You’ll
have better luck building a quality assurance team by sneaking it in the back
door. Just make sure they don’t leave the door ajar when they come in. The
watchman’s partner has been known to tiptoe into the company cafeteria for a
late-night snack or two given the chance. Your design documents are typically
the preferred dessert.
How do we surreptitiously build a team of testers when management
won’t authorize the expenditures? We train our own. In the beginning, use any
warm body you can get. As you gain momentum, you’ll eventually have the
Chapter 8 Fighting for Quality Assurance
133

credibility to start hiring professionals, but you must first show some results to
justify your request for funding. It’s fairly common for management to dig up
a person here and there to help with the testing, particularly in the end stages
of the project. What we’ll do is start asking for those people early on in the
process. Although the testers should really start writing test cases based on the
requirements and design docs as soon as they’re available, that’s going to be a
hard sell on your first attempt. Wait until you’ve got some form of user inter-
face up and running on your program. As soon as you do, start lobbying for
resources. Take anyone even moderately trainable that you can get, for how-
ever many hours that they’ll agree to commit. Beggars can’t be choosers.
Once you have some fingers on the keyboard, it’s going to be up to you
to train them. As if you didn’t have enough to do already, right? Of course, to
train a tester you must understand the process yourself, but we’ve covered
much of the basics already. Just as it’s not been my intention to teach experi-
enced programmers how to write code in this little treatise, neither will I make
any attempt to represent myself as a testing guru. If you’re not familiar with
the fundamentals, some decent books are available. There isn’t the volume of
reading material available that there is on programming, but with dedicated
effort, you can find some worthwhile references.
However, getting started with a skeleton testing effort is often just an exer-
cise in the obvious. Well, perhaps it’s obvious, but the second part of that is
actually doing it. Therefore, we start by putting together some simple test
cases that cover basic and obvious functionality. Continuing with our word
processor example, you might write quick test cases for opening a file, saving
it, and printing it. After walking through these with your borrowed resources,
you suggest that they continue with the effort by simply working through the
main menu one item at a time. In other words, for most programs, the main
menu is the entry point for the most fundamental operations in the system.
Starting with the first menu entry, have them write a test case for each option
that a user can access by this menu. If they’re given enough time to do more,
move on to the toolbars and buttons. Next, give them a list of the keyboard
shortcuts and context menus. While they’re doing this, your team is continuing
with the coding. Of course, as they’re performing the actions themselves in
order to write up the test cases, they’ll encounter the occasional bug. As this
happens, they’ll document the incident in the prescribed manner and continue
on with writing the test cases.
Training Your Testers
I mentioned an incremental approach because it may be too much to expect
in the beginning that you’ll get test cases for all scenarios. That’s why you start
with the main menu. If you can get even that much done, it’s a huge step in
the right direction, and those test cases don’t go away. At any point in the
future, you can always build on them when you get the opportunity to add
134
Part II Guerilla Tactics for Front-line Programmers

more. If you feel that you’ll start getting some resistance after the first level of
test cases, have the testers switch over to running them, or perhaps move on to
free play. Management views the work of testers in much the same way as that
of programmers. If they’re not actively testing the application, they’re not
really testing.
It’s important that you not only start training your testers but also maintain
the support and enthusiasm of management. Without this, you have nothing.
Make sure as you’re training the testers that you also keep notes of exactly how
you’re training them. Keep your training documents as organized as you would
your design docs so that you can use them for the next person that manage-
ment throws your way. Okay, perhaps you won’t write your training documents
on cocktail napkins, but I’m sure you get the idea. You’re building a process
here, so document it well.
One of the most fundamental things you’ll need to teach your testers is
how to write up a bug report. It will help tremendously if you can provide
them with a database form or a printed document that will step them through
all of the required fields, providing a list of acceptable choices wherever possi-
ble. The easier that you can make it for them, the better chance you have of
their actually doing it. Most of the fields, such as the criticality of the error
(incorrect functionality, cosmetic, full-blown system crash, and so on), version
of the code, and so forth will be easy for them to understand and work with.
The most difficult but important part of the bug report is the steps to repro-
duce the bug. As any developer knows, the bug report is next to useless with-
out this. This procedure requires attention to detail, and you’ll have to teach
them how to think in steps. Part of this success will come when they under-
stand that they can’t assume any knowledge on the part of the person reading
the report. This means that they must spell out in mind-numbing detail exactly
what you must do to create the bug, such as the following series of steps.
1. Start the application.
2. From the main menu, select File.
3. From the File menu, select Open.
4. From the File Open dialog, select the file BugReport1.txt.
5. Press the Page Down key exactly three times.
6. Press the Enter key to start a new paragraph.
7. Type the phrase “This is never gonna work.”
8. From the main menu, select File.
9. From the File menu, select Save.
10. Observe that the application has crashed, displaying a diagnostic
dialog box.
Chapter 8 Fighting for Quality Assurance
135

Our example has several points to note. First, we started the application. It
seems obvious and pointless because you can’t perform the subsequent actions
if the app isn’t running. Ah, but what if the bug happens only when you start
the application fresh? Furthermore, if you don’t start fresh, who knows how
the previously performed actions may affect the state, perhaps masking the
bug altogether? Also, in our example, the bug really occurs as soon as you
attempt to save a modified document. However, the more specific the bug
report, the better chance you have that people can reproduce it. By explicitly
specifying that the user should press the Page Down key three times, start a
new paragraph, and enter a specific bit of text, you know that you can repro-
duce the bug each and every time. This is not important to only the developer
because, when the bug is fixed, a tester will have to run these steps to verify
the fix and close the incident. Particularly because you’re training your own
QA team, you can never assume the level of technical expertise that the tester
who closes the incident will have. The other thing to note is that there is a spe-
cific file, BugReport1.txt, that is used to reproduce the problem. Attaching or
otherwise making available specific data files is always a very useful step in
reproducing bugs, as often the data in the file gives clues to the problem.
Even if the list of steps seems obvious to you, I can assure you that this
level of detail will not be obvious to the newly trained testers. Instead, left to
their own devices, your bug report will look like the following.
1. Program crashed while saving a file.
That’s all you’ll get, and it’s not their fault. Testing is a specific discipline in
the software development business. It’s unreasonable for you to expect that
anyone without experience or training will possess these skills. That’s why you
have to help them. It’s also worth remembering, once again, that you’re deal-
ing with people. Testing is repetitive, tedious work that’s about as exciting as
doing your tax returns. It’s also going to be new ground for your testers.
People are always less comfortable in situations in which they know they don’t
possess the appropriate skills. Your encouragement, enthusiasm for their
efforts, and sincere appreciation will go a long way.
Make the Testers Feel Like a Part 
of the Team
Above and beyond the fact that it’s just a good way to treat folks, you also need
allies to support your efforts to build a testing team. If you greet each new bug
that the testers find with unreserved enthusiasm and make it a point to tell the
world what a huge difference in the project their great work is making, you’ll
find a significant change in their attitudes. Where they once may have been
dragged grudgingly into doing your testing, they now feel like a valued and
136
Part II Guerilla Tactics for Front-line Programmers

important part of the software development team. Indeed they are. Make sure
that whenever the rest of the team gets together for lunch, your testers are
invited as well. When you call an all-hands meeting, their presence should be
requested, even if management won’t always give them the time to attend.
Any emails sent to the team at large should include the testers. In short, even
if your testers can spend only four hours a week on your project, treat them
with as much value and respect as your full-time members.
If you do this, you’ll find that they will begin to take ownership of the test-
ing process. They will become emotionally involved in the project, and its suc-
cess will be as important to them as it is for you. Now, in addition to your own
lobbying efforts, you’ll find that your testers will themselves start lobbying for
more time on the project. Some will even put in a little overtime if they can’t
get the time free during the normal course of the workweek. If you make
them a part of your team in every regard, you’ll find that more and more
they’ll push to get testing time until, in some cases, they get a permanent reas-
signment. At this point, you truly do have the beginnings of a dedicated testing
department. It all starts from small, incremental steps and making your part-
time testers feel as important as the rest of the team. Never have a reindeer
game without them.
Above all, no matter who you have to strong-arm, when you gather your
team for a celebration or company-wide recognition after your successful
release, make sure that all of your testers are sitting with you, equal in stature
and praise to every other member of the team. If one of them can’t make it,
reschedule. “All for one and one for all” is not just a corny line out of a book.
Esprit de corps is more powerful than any management course you could ever
attend. When you make each person on your team feel like the full weight of
the group is behind him, he will move heaven and earth to help your project
succeed.
The more that management sees this, and the more your software quality
improves (as it certainly will), the more time they’re going to allow these peo-
ple to spend on the project. Between your lobbying and that of your testers,
you will continually chip away at the stone until you can get them assigned
permanently to your team. Also make sure that you keep careful notes of the
ever-increasing quality of your software with each passing release. Any infor-
mation you can gather—the decreasing number of tech support calls and user
complaints, the fact that any bugs encountered are of a less severe nature, and
so on—is ammunition that you can use as you continue your efforts to build a
quality assurance process that becomes the de facto standard in your company.
Ultimately, if you’re successful, you should have a testing group that mir-
rors your programmer group. In other words, you want one tester for each
developer. If you have team leads, you’ll want an equal number of test leads. If
your project is large enough to be broken into subgroups based on functional-
ity, you’ll want to mirror that in your testing group as well.
This may seem like the southern colloquialism of the fox guarding the hen-
house, but you’ll want all of your testing resources to be under your project
manager. Just as it’s important for them to feel like a part of the team, you also
Chapter 8 Fighting for Quality Assurance
137

want to avoid the “us versus them” mentality that can sometimes arise
between stand-alone QA groups and the programmers whose work they test.
If your testing group gets large enough to warrant it, however, you’ll want to
appoint a testing manager to oversee the group. This manager will report
directly to the project manager, although the project manager may interact
directly with testers in the same way that he interacts with programmers.
Once things get rolling, it’s a good idea to give the testers a little room to
grow. You now have a testing department in large part due to the enthusiasm
and efforts of your previously part-time resources. They were fired up enough
about the project to help you make your dream of a full-time testing staff
become a reality. Allow them the elbow room to take that enthusiasm and pur-
sue the skills, procedures, techniques, and structures of the testing profession.
They worked their way from the ground up, just as many of us have done as
programmers. If they start having ideas of their own about how to improve
the testing process, let them roll with it. It’s their career now, and this is really
what you wanted all along. Everybody wins, especially your customers and
your company.
Establishing the QA Process
Whether you’ve managed to build a full-time testing staff or you’re still work-
ing with a few people who can give you only a couple of hours a week, you’ll
want to incorporate a few things into your overall testing procedures. First, go
out and buy a big stone tablet, suitable for hanging over the main door of the
programming department. Then, chisel on it in big bold letters a statement
that no releases, whether beta, public, or patch, shall leave the room without
going through a regression test of whatever test cases you’ve been able to put
together. You’d be surprised how much this alone will improve the quality of
your releases. Of course, a large stone block above the main doorway may
have additional uses if your management walks in and declares that the prod-
uct will in fact be shipped without testing.
As in so many other cases, the easier you can make a process to be fol-
lowed, the better your chances of success. You now have well-organized test
cases and a staff of at least part-time people who know how to run them and
document any deficiencies. Demonstrating to management that you’re well
prepared to run this test before you ship and that it’s a simple and straightfor-
ward process makes it easier for them to say yes. Furthermore, should you
catch any blatant and potentially embarrassing bugs in this prerelease regres-
sion test, fix the bug and advertise loudly that this would have been a customer
disaster had it not been for the testing process. This gives you more credibility
for your testing procedures and more horsepower the next time you need to
ask for something, such as more time for your testing resources.
In addition to the full regression tests in which you run every single test
case that you have, some additional tests should be on your list as well (if you
138
Part II Guerilla Tactics for Front-line Programmers

can get the time to do them). If your system can be set to operate on auto-
matic pilot, tests that run overnight or over the weekend are great for smoking
out cumulative errors. If your app always requires user interaction, pester
management until they approve the purchase of a testing automation program.
Even if you buy nothing more than a single license of the cheapest product
going, your ability to run overnight tests will pay for the software the first week.
Not content to just run the program until it drops, a good testing effort will
also try to push it until it squeaks. Whether it’s a database app, a word proces-
sor, or a Web browser-based system, all programs consume system resources
such as memory, processor cycles, and disk space. How snippy does your app
get when these things are in short supply? Do your really know how your pro-
gram will react if your computer runs completely out of disk space? What hap-
pens when it can’t allocate memory? What if other programs are chewing up
the processor and it can’t get much done? These scenarios and many like them
should be a part of your stress testing. Buy or write simple applications that
consume these resources, and see how your application reacts. You’ll be sur-
prised at the bugs this sort of thing will flush out, sometimes in rather unex-
pected places.
Hardware failures, particularly when your system interacts with external
dedicated hardware, are another avenue to test. This may not always be practi-
cal or relevant to your system. It’s hard to suddenly invoke a video card failure.
However, if your program depends on anything physical in the outside world,
make sure you test the behavior if that outside resource suddenly vanishes or
misbehaves. In the real world, hardware fails from time to time. That’s not the
fault of your software, but that also won’t be remembered if your program
crashes and corrupts data as a result.
Speaking of hardware, having an appropriately stocked testing lab is
another luxury that you should work for. Having computers running all the
various versions of the target operating systems is incredibly valuable. If there
are any networking aspects to your project, you need a nontrivial network on
which to test it. You’ll also find that some printers react better to your output
than others, and, of course, the list goes on.
When you’re scrounging for hardware resources, you’re in a tough neigh-
borhood. In the corporate world, that’s one of the first things that everyone
fights for. The best way to get your foot in the door without too much competi-
tion is to first determine the most obsolete hardware that your system can tol-
erate. Armed with this list, begin your scavenging by trying to get possession of
old hardware that meets these requirements. Often, the old stuff works just
fine for testing, but of course nobody wants old stuff on their desk, and so you
stand a good chance of getting it for your testing lab. As your lab grows, it’ll
eventually reach a point where it’s recognizable as a dedicated testing resource
of a reasonably serious nature. As you start documenting more and more bugs
that never made it to the field because the hardware in your lab caught it first,
you’ll begin to gain some power to requisition additional hardware that you
couldn’t scrounge. The more you can prove that your testing efforts are bring-
ing real value to the party, the more resources you’ll be able to commandeer.
Chapter 8 Fighting for Quality Assurance
139

You should also have, in addition to your regression test, a baseline critical
path test, a series of test cases that exercise the most fundamental and critical
aspects of your system. These are the things that absolutely must not fail.
Make this test as short as it can possibly be and still maintain its effectiveness.
This is your backup plan for any occasion when management declares a
release over the loud protests of you and your testers. Under no circumstances
should your system leave the building without this test, even if you have to
sneak in at midnight to run it. It will save you from many embarrassing
encounters.
It’s not going to be easy putting together a professional testing department
if you don’t already have one. You’re going to have to use every political trick
in the book to get your hands on the resources, both people and hardware,
that you’ll need for your product to be adequately tested. You’ll probably want
to pull your hair out in the beginning stages as you try to take people who are
not software professionals and teach them the basics of QA. However, if you’ll
stick to your guns and make it a priority to build this team, the rewards will far
outweigh the aggravation. It doesn’t matter if you’re a project manager or just
a front-line coder. You have to put the full weight of your personal involve-
ment behind the overall effort to make a dedicated, full-time testing team a
reality. It will forever change the quality of the software you deliver. It might
even allow you to get a good night’s sleep from time to time. Such things will
make you the envy of your peers when you gather at your favorite program-
mers’ cappuccino bar. Just make sure that you invite the testers, too.
140
Part II Guerilla Tactics for Front-line Programmers

So far, we’ve concentrated on the different tasks that must be addressed in
preparation for the actual coding. Some of these have been a matter of setting
up procedures, and others constitute a large body of work to be performed in
and of itself. Although it’s imperative to establish a solid organizational struc-
ture for your approach to software development, keeping a close eye on the
day-to-day details of the process is equally important. Even if you’ve done
everything right, it’s still possible to miss the deadline if you lose control of
the project in midstream.
Most people consider the oversight of daily operations of the development
process to be the domain of the project manager. In reality, many details are
inherent to the creation of any significant piece of software, and every mem-
ber of the team should attend to them. Just as a fireplace is built by stacking
one brick upon the next, so too are programs created by the individual efforts
of each member of the team. If everyone works with a common mindset and
thinks not just of their particular tasks but of the group effort as a whole, much
of the process becomes self-maintaining. 
With any luck at all, this won’t be the last development effort you work on.
All of the steps we’ve taken thus far to keep the deadlines achievable and in
sight require skills that will improve with each subsequent project. Because so
much of the focus of our efforts is based on time, it’s only natural that we’d
want to know how our projections match up to reality. To know for certain,
we’re going to have to do some bookkeeping.
Keeping Track of Your Time
If you don’t have dedicated software to manage this sort of thing, a simple
database will do the job nicely. At the beginning of the project, whenever
tasks are delegated to team members, they’re added to a list in this database.
Additionally, you add a field for the individual performing the work and
141
Keeping the Project
Under Control
9
C
H
A
P
T
E
R

populate that list with the names of all team members. To this list of fields,
you add three more: one for the date, one for the start time, and one for the
stop time. Also add a comment field, but don’t make it required. You can add
more information, of course, but keep it simple. What you’re building is a
data-entry system for your team members. Remember, the more of a pain it
is to use, the better chance that it won’t be, no matter how much you beat
your chest.
During the course of each day, your team members will work on one or
more tasks. With just a little bit of discipline, it’s easy to fire up the data-entry
form, pick your name, pick the task, and enter the date and start time. Later,
when you switch tasks, you edit that record with the stop time and add a new
record with the start time of your new task. Yeah, yeah, I know; it seems like a
hassle. And it is, in the beginning. However, you quickly get used to it, and in
reality it takes less than thirty seconds to make an entry. If it takes any longer
than that, you might want to brush up on your typing skills.
But where’s the payoff for the individual programmer? Isn’t this just a tool
for the project manager? True, it does serve him as well, but each time you
have a new task assignment, it gets put into the database, right? This includes
each and every line item that you estimated in your detailed implementation
figures, which means that you now have small tasks to perform, a record of
how long you thought it would take, and ultimately from this database, you’ll
have the numbers of how long it really did take. When you complete each
task, if you finished significantly sooner or later than you anticipated, make
sure you enter some explanation for it in the comment field.
For the one to five minutes that fooling with this database will consume in
your day, you get a wealth of useful information that will make you much more
effective in estimating your next effort. We do so many tasks in a week and
touch upon so many technical issues that it’s literally impossible for us to truly
remember what took how long and why. Without this key information, we
have no chance of improving our estimating skills. Without adequate estima-
tion skills, there’s no way we can propose a realistic deadline, and we are for-
ever doomed to occupy our cubicles late at night every week as we try to hit a
deadline that we underestimated. However, if you maintain the simple disci-
pline that it takes to make these entries, you’ll have extremely precise informa-
tion with which you can raise your estimating skills to new heights. We already
know how to code. That’s the easy stuff. Estimating is hard, and this is how you
get better.
Not only does this information improve your ability to project effort, it
keeps a running status of all aspects of your project. When you know to the
minute exactly how long any single part of your project took, you’re going to
be speaking with tremendous authority the next time you talk to management
about schedules. Furthermore, you’ll have database reports and spreadsheets
to document your trail and back you up. Management responds to that sort
of thing. When you’re offering reports and spreadsheet printouts, you’re
speaking the language that they understand, and it boosts your credibility
significantly.
142
Part II Guerilla Tactics for Front-line Programmers

One last note on this topic: enter your times right then and there, as you
start or stop them. The temptation is great to figure you’ll just summarize it all
at the end of the day, or at the end of the week. You won’t get precision that
way, and precision is the entire point of this exercise. If you take shortcuts
here, you’re cheating only yourself.
Managing Your Team
If you find yourself in the position of project manager or team lead, you’ll be
responsible for the efforts of others as well. This adds to your workload on a
daily basis, of course. For the most part, though, it’s been my experience that,
if you treat programmers like grownups and just let them do their job, you’ll
get the most from them. As a class of creature, we don’t respond well to
micromanagement. If you do find that there’s someone on your team who isn’t
pulling his share of the load, either through lack of ability or laziness, that
should probably invoke the question of whether or not that person should be
there in the first place.
In general, though, I find that the position of team lead or project manager
is more concerned with supporting the programmers than trying to manage or
motivate them. They’re already motivated, and for the most part, the only
management they need is the sort of organizational stuff that we’ve been talk-
ing about all along. When it gets down to getting the work done, the first and
most fundamental job of a manager or team lead is to provide air cover. Your
highest priority is to shield your programmers from the nonsense and bureau-
cracy of middle and upper management, keeping them off your programmers
so that they can get some work done. This means that you take the heat from
management, you deal with the insipid requests from marketing, you shuffle
all the paper that needs to be shuffled, and you keep your programmers out of
meetings that don’t truly require their presence.
Additionally, depending on the level of effort your team is putting in, it’s
up to you to keep spirits high. Morale is more important than most businesses
ever realize. If keeping morale up means bringing in the occasional pizza, then
do it. If you can come up with any perks that are actually meaningful to your
team, then hand them out. Every opportunity you have to reinforce the fact
that you feel your team is the absolute best of the best, jump on it. When at
all possible, pass the credit for successes along to your team and take the flak
for the problems yourself. When your people see that you’re covering them
even when you get grief for their mistakes, you’ll find an ever-growing loyalty
among your team. This is where treating programmers like adults and letting
them do their job starts to pay off. Eventually, you’ll find that loyalty and esprit
de corps have risen to a point where people do whatever it takes to put out a
fire without ever being told. They simply do it because they’re good, and they
believe in the team. This may all sound a little corny to you, but it’s worth reit-
erating that at the end of the day, you’re dealing with real, live human beings,
Chapter 9 Keeping the Project Under Control
143

and people have feelings. It doesn’t matter if you have a hundred people in
your department or you’re just the technical lead on a two-person team. Take
care of your people, and they’ll take care of you and your project.
Improving Your Coding Discipline
Another aspect of keeping the project on track has to do with maintaining an
organized approach to your coding efforts. Standards and procedures are
nothing new to programmers in the corporate world. Whether or not they’re
actually adhered to is another matter entirely, of course. Probably the single
most recognizable standard to those of us who spend our days in front of a
compiler is the coding standard. Because programming is as much of an art as
it is a science, we take it a bit personally when constraints are placed on how
we write our code. However, when you get right down to it, there’s only one
proper way to write your code: the way that everyone else in your shop does.
You can do a great many things to enhance the readability of your code,
but the most important consideration overall is consistency. Any programmer
should be able to bring up any file in the system and be in familiar territory. If
it’s a struggle to wade through different and ever-changing methods of inden-
tation, commenting, variable naming conventions, and so forth, you’re going to
find your maintenance programmer shopping the Internet for good deals on
bulk ammunition. Comprehension will suffer, and it just generally takes longer
to do whatever you had in mind. Naturally, any programmer worth his pocket
protector should be able to read the code and figure it out. However, dead-
lines are all about time, and anything that slows you down adds up and con-
tributes to the potential for missed deadlines, even if it’s a seemingly small
thing. It’s all incremental.
A number of good books about coding style and practices are available,
and it’s not my intent to duplicate that information here. Additionally, some of
these issues will be, to a certain degree, language-dependent. If you’re a Basic
programmer, you couldn’t possibly care less where a C++ programmer puts
his braces. I’ve actually heard the occasional Basic programmer make some
rather specific suggestions about where they should put the braces, but I sup-
pose that’s another story. In any event, just as it is between these two, so is it
for all of the languages. Each has specific nuances that won’t be relevant to
others. Nonetheless, a number of common threads run through the program-
ming experience regardless of your choice of weapons.
Beyond the simple formatting issues regarding how the code should look,
another of your primary considerations when cranking up the editor should
be the debugging experience. I’ve known many programmers over the years
who simply wrote code, and then eventually spent some time debugging it.
I’ve watched as they struggled with their debuggers, not always having the
information that they needed in the context of the problem they were
144
Part II Guerilla Tactics for Front-line Programmers

tracking. Often, too, debugging is an intrusive experience and interferes with
the normal execution of the program you’re testing. This can mask the prob-
lem entirely or demonstrate different symptoms than those that are seen when
the program is run normally. This can often be fairly misleading and can waste
many hours while barking up the wrong tree. You can do a number of things
when you code that will make life much easier for you when problems arise.
And they always do. The most important step is to simply think about how you
will debug an application from the moment you start coding it. It would prob-
ably be a good idea to avoid barking as well. That sort of thing could be taken
the wrong way by Security.
Although this book is aimed at programmers of all disciplines, the majority
of my personal experience has been in writing C and C++ code for Microsoft
platforms, starting with early incarnations of DOS and working through all of
the versions of Windows from 3.1 on. I’ve encountered a few things along the
way that seem useful no matter what flavor of program you’re building. The
first was a concept that was given to me as a mandate from one of my man-
agers. The sentence started, “You’re not going to like this, but . . ..” He was
right. He was talking about a variable naming convention known as Hungarian
notation, which is familiar to most Windows programmers.
The idea is a simple one: you use a well-defined prefix on all variables that
instantly identifies exactly what type of variable it is. To the uninitiated, it
seems to add a lot of visual garbage to the code, and I fought it tooth and nail
in the beginning. Well, it isn’t fair to say that I fought it because not using it
wasn’t an option, but I grumbled long and loud about what a pain it was. It
didn’t take long, however, for me to get used to it. Once I did, I was amazed
at how it improved my debugging experiences. When you hit a breakpoint
and immediately recognize exactly what the variables are as well as their scope
(another facet of Hungarian notation), it’s much more of a timesaver than
you might initially expect. Although this naming convention is popular for
Windows developers, it doesn’t really matter what convention you use. The
important thing is that you use one that makes sense for the language and
development environment in which you work and that the entire team applies
it consistently. It will take a little getting used to, but if you’re so set in your
ways that you can’t adapt to a change here and there, then you’re probably not
going to survive for long in this business anyway. The increased productivity
will be worth it in the long run, and productivity is a major issue for those of
us on a deadline.
Along these lines, anything else you can put in your code with debugging
in mind will save you countless hours in the debugging sessions that are sure
to come. One of the first things I tend to do on a new assignment is put
together some diagnostic routines before I write the first line of system code.
It’s important to minimize the overhead that these diagnostics require because
the idea is to use them liberally in your code on a daily basis. 
As an example, it’s a familiar struggle for the C++ developer to deal with
good pointers gone bad. Among my tricks are macros that not only test for
Chapter 9 Keeping the Project Under Control
145

null pointers, but also confirm that they point to valid memory blocks and are
indeed a pointer to the type of class that I think they are. What do they do if
these conditions are not met? Bark loudly. Never mind how nervous that
makes the night watchman.
My environment offers the use of assertions, and I suspect that the major-
ity of programming languages have similar features. An assertion is effectively
a Boolean test that does nothing when true and offers a diagnostic message
when false. This message displays the filename of the source code and the
exact line number where the mishap occurred. In other words, it says in big,
bold language that something is screwed up and it tells you exactly where. As
you might imagine, this is extremely helpful information. I suspect that most
programmers are familiar with this sort of technique. Consequently, if I get a
bogus pointer, I make sure that the world knows about it immediately, at least
in a debug build, via a popup message box. Unfortunately, the stock assertion
routines offered are only useful in a debug build, which brings us to another
point.
When you’re peppering your code with diagnostics, you need to think in
terms of both the debug and release environments. Not all languages or com-
pilers make a physical distinction between the two types of builds, but the log-
ical problem is always present. You may write code that’s designed to offer a
lot of troubleshooting information when you’re debugging, but remove it or
comment it out before shipping the final product. Then, at two o’clock in the
morning, your product crashes in the field and you sit on the phone, bleary
eyed, trying to determine exactly what went wrong. Of course, because the
diagnostics were present only when you were coding and debugging, your pro-
gram in the field is conspicuously silent about whatever made it unhappy. This
makes for a much more difficult debugging experience, made all the worse by
the frantic pressures that always accompany problems that occur in a produc-
tion system. This is when you need the full complement of debugging and
diagnostic tools, and it’s typically when you have the least.
While I’m drawing on my personal experience as a Windows/C++ devel-
oper, these ideas are not tied to this platform in even the slightest manner. I
take a little teasing from my fellow developers about having exceptionally
whiney code, and I’m guilty as charged. In my bag of tricks, I make sure that I
have routines that will give me information both in the field and in the debug-
ger. When the program goes south, the assertions that I previously mentioned
are nonexistent in release builds. Consequently, I roll my own routines that
give me popup messages in a debug environment and the exact same informa-
tion written to disk in both debug and release environments. This means that
when I’m rousted from bed in the middle of the night, I immediately ask the
person on the other end of the line to bring up the error log and read me the
contents. This doesn’t fix the problem, but it sure speeds up the process. I
then stumble into the office and fire up the debugger, knowing exactly where
the crash occurred. If you have more than twenty minutes of programming
146
Part II Guerilla Tactics for Front-line Programmers

experience behind you, you know how valuable this is. However, it didn’t hap-
pen by default. It happened because I thought of debugging before I started
building the system and put together some tools to help me when I got there.
Thinking Ahead to Debugging
Although it’s a good idea to build a library of such diagnostic routines, some-
times it’s helpful to write another app or two to help with the debugging as
well. Does your system require nonstop execution of routines? If so, you may
want to consider a trace utility that allows you to put diagnostic lines in your
program but have them displayed via interprocess communication in your
trace utility. This means a real-time display of what’s going on in your code
without disturbing the execution of the program. For all of you Windows pro-
grammers out there, yes, I know that there’s some trace features built into the
compiler, but sometimes you need more information than that. And it cer-
tainly doesn’t save this information to disk. In other words, no matter what
your development environment offers, it may not be enough. But there’s no
reason to accept that as a limitation.
Other examples of diagnostic utilities include tools to view data file con-
tents and snooping utilities to show what’s happening on serial ports, network
connections, or even interprocess or thread communications. In general,
the idea is simple: think ahead to what you’ll be encountering as your system
progresses and build a suite of tools and routines to help you deal with the
inevitable debugging adventures. You’re a programmer. If you need a tool
that’s too specific to be available on the open market, there’s no reason that
you can’t cook it up yourself. That’s one of the advantages of our trade. A
carpenter doesn’t have the manufacturing capabilities needed to create a spe-
cialized type of hammer that he may need (although I’ve certainly seen the
creative use of other tools to compensate for this). However, as professional
developers, we can create our own hammer anytime we like. It’s not as much
fun as beating on the monitor with a blunt instrument, of course, but then we
don’t want to spoil its appearance before it goes out that fifth-floor window.
Many aspects of how you write your code can contribute to the ease of
debugging, and some are less obvious than others. For instance, in my little
world, I can legally write a method in a single line, curly braces and all. This is
a style that many C++ developers utilize, particularly for such routines that set
or get the value of a variable. It looks very neat and clean. Unfortunately, when
stepping through in my particular debugger, I cannot inspect the value of the
variable. If, however, I reformat the code into three lines with the curly braces
each occupying a line of their own, the debugger behaves differently, and I
can in fact inspect the variable. Leaving aside any comments I might have
about this little feature of my debugger, the point is that, in this case, even
Chapter 9 Keeping the Project Under Control
147

the visual aspects of how the code is formatted have a very real implication on
debugging. As such, I now have removed the practice of single-line routines
from my coding, even if it ain’t pretty.
This is as close as we’ve come to talking about writing code thus far, as
we’ve been focusing primarily on procedural issues in the preceding chapters.
However, a procedure lurks here just beneath the surface. In the beginning of
the project, you should include time to look into and write whatever diagnostic
routines and tools that you’ll need. Furthermore, all of the coding standards
and related issues should be defined up front and then adhered to by all.
Although it’s not uncommon for coding standards to be considered in a shop,
you might not have had a group discussion about the preferred use and fre-
quency of diagnostic routines, or which routines and what functionality would
even be useful. Take the time to do this, and make debugging a priority when
you’re writing your code. You’ll end up with more lines of code than you
otherwise would have had, but the payoff at debugging time will far outweigh
the time it takes to add the diagnostics up front. The sanity you save will be
your own.
Incorporating Version Control
Another procedure that should be standard in every shop is the use of a ver-
sion control system for source code. It’s one of those things that seems as obvi-
ous as mentioning that you have to have a development environment before
you can start coding, but I’ve actually known good developers who were either
completely unfamiliar with the concept or, for whatever reason, didn’t have a
system available to them. If you’re new to version control systems, the short
explanation is that it’s a system that lets you store multiple versions of the
same source code file in a central repository. This means that you can fetch a
particular revision of this file at any later time. These systems are typically aug-
mented with a number of features, and the ability to slap a label on a particu-
lar revision is a fundamental feature.
One obvious use of labels is stamping the codebase for your current
release product. In this way, when version 2.13 has a problem in the field but
you’re already coding version 3.0, you can fetch the entire 2.13 codebase and
debug it. However, labels are cheap. Any time you make a change to your
codebase that you might want to come back to, slap a label on it. For instance,
if you’re about to rewrite a portion of your code to use a different architecture,
you’ll want to first label the existing one that actually works. So, if the new
architecture doesn’t work out, you can drop back to where you were and either
try something new or keep what works.
Most professional shops already have a version control system in place
because the benefits are too extreme to ignore. However, if management has
not authorized the money for you to have such a tool, grab your pitchforks,
light the torches, and gather every developer in the entire company at the
148
Part II Guerilla Tactics for Front-line Programmers

offending manager’s doorway. Get the maintenance programmers to guard the
exits, and don’t let him out until he signs the check. No tool short of the devel-
opment environment itself is more crucial to an ongoing software development
effort. And do be careful with those torches.
Improving Productivity
While we’re on the topic of productivity, it’s important to keep human nature
in mind no matter what procedures you’re putting into place. The unshakable
reality is that, if it’s not easy, it simply won’t happen, even if you pull rank
(assuming that you have any). The more of a pain or distraction a particular
procedure is, the better the chance that team members will just conveniently
forget that they were supposed to do it. Without a doubt, some rules that
should be followed generate additional work we’d rather not deal with.
Discipline certainly has a place in the professional software development
environment. Nonetheless, if you can find ways of automating or simplifying
a cumbersome task, you’ve got a much better chance of success.
For instance, if you want information entered in a database and the form
requires twenty fields to be entered, how many of these can you default to the
most commonly used values? If your team uses status reports, are they easy
to fill out? Are they paper or electronic? If the latter, do you have document
templates set up to minimize the amount of typing required? If you train your-
self to think along these lines, you’ll be much more effective in getting what
you need from the rest of your team without the fear of torches at your own
doorstep. It’s a good idea to periodically get together with everyone and find
out what works and what doesn’t. Never be afraid to tailor your approach as
you go along. Remember, results are what matter.
Another thing you can do to improve your productivity has to do with
your personal coding environment. Whether you’re using a development envi-
ronment that’s built in with the language or you have a dedicated program-
mer’s editor in which you do your coding, chances are good that you’ve only
scratched the surface of the power available. When we’re pressed for time, it’s
common to do something manually because it would take longer to set up an
automated process than it would to just do it. However, you should always
question whether you’ll ever need to perform this particular task again. If the
answer is yes, especially if it will be a frequent occurrence, it’s worth taking a
break and finding out what your environment can do to streamline the task.
This isn’t a new idea to those who already use a full-featured editor.
However, the editors that are shipped with many database or language envi-
ronments are often much less powerful or flexible than a program whose sole
purpose is editing source code. I realize that sometimes the reasons for not
having a hot rod editor are financial, but often it’s simply because program-
mers don’t push for this critical tool. We also tend to get comfortable with the
editing environment that we’ve learned and don’t want to have to learn a
Chapter 9 Keeping the Project Under Control
149

whole new set of keystrokes. I’ve moved through a few different editors over
the years, but for the last decade, I’ve been able to use one of the standard key
mappings from a popular editor of days gone by that most everyone still sup-
ports. Even so, there were a couple of times that I had to learn a completely
new way of typing to get more power. It was a distraction to be sure, but in the
end, it was most certainly worth it.
I’ve often told the story of a particular project manager I worked for who
was adept at dealing with the political insanities of the company that employed
us. I was using a rather clunky set of tools and had lobbied along with my fel-
low developers for a more popular and significantly more powerful develop-
ment environment. After a difficult political struggle, I got the word from him
one morning that we were authorized to use the desired tools. (We already
had the software but had been forbidden to use it in the name of departmental
standards.)
We were at the very beginning of the application, and I didn’t want to give
my boss’s manager any chance to change his mind, so I kicked out around
10,000 lines of code over the course of the week. This was what I needed to do
to get the system visibly up and running, and doing so made it harder for man-
agement to pull the plug and send us back to the chisels and stone tablets that
we were using previously.
I later heard some interesting comments about my efforts that were made
from those on a team who were politically opposed to the tool transition (and
our very existence, for that matter, due to turf wars). The first was that there
was no way that I could have written that amount of code on my own, implying
that I must have had other developers helping me. The second comment was
that I was no hotshot programmer; my tools just did all the work for me.
Frankly, I have no idea if 10,000 lines of code in a week is a lot or not. I
have no metrics for comparison. Apparently, however, it was a lot by these pro-
grammers’ standards. There was no way I could have written all that on my
own? They were, of course, correct. I didn’t have help from other program-
mers, though. My tools generated a lot of this code for me. That, of course,
validated their second thought. I’m certainly no hotshot programmer; I’m just
smart enough to use power tools. I found it entertaining that their comments
validated the very effort they were opposing just weeks prior, and they didn’t
even realize it.
Whether it’s standardized comments for file and function headers, tem-
plates of code for classes or routines, on-the-fly macros, powerful multifile
search-and-replace mechanisms, or any of a host of other features, there is
almost no end to the work that you can automate with a good editor. Those
who work in a UNIX environment are familiar with a particular editor that is
almost always available no matter which flavor of the operating system you’re
running. It generates extreme feelings among programmers: they either love
it or hate it. Probably because I didn’t grow up on UNIX boxes, I fall into the
latter category. However, I would rather use that editor any day of the week
150
Part II Guerilla Tactics for Front-line Programmers

than work with one from a standard development environment. I may have
some personal issues with the user interface, but it is without question
extremely powerful, and power is the point.
No matter which dedicated editor you choose, what used to take five min-
utes of typing will now be done in two keystrokes. You don’t think this adds up
over the life of your project? Remember, if you’re struggling with unreason-
able deadlines, then every single minute of productivity that you lose will add
up. In the end, it can cost you the delivery date. If you don’t have a hot rod
editor, get one. Which brand to use is a religious issue among programmers,
but I’ll tell you right now that it doesn’t really matter. They’re all competitive,
and any of them will shave literally weeks off of your project. There is a learn-
ing curve, but the payoff is huge. Of course, if you’re in a shop that won’t allow
you to get one, then the only other option you have is to squeeze every last
ounce of performance out of what you have. I strongly suspect that most pro-
grammers don’t use even half of the power that they have available. No matter
how you get there, if you wish to be productive and enjoy your coding experi-
ence more, it is imperative that you soup up your editing environment. Just
don’t forget the seat belts.
Knowing When to Walk Away
We’re conditioned both by our passion for our work and the pressures of our
career to work hard and work often. Burning the midnight oil is a common
experience for the professional developer, and one of the reflexive solutions
to any problem is to simply work more hours. Although at times this is just
what has to be done, at other times it’s the absolute worst mistake that you can
make. Programming requires sharp focus, perception, attention to detail, and
hopefully eyes that are in the open, not half-closed, state. A friend of mine
used to routinely say that he didn’t work until two o’clock in the morning
because you didn’t want the code that he wrote at two in the morning. There’s
tremendous truth to that. Sometimes the very best thing you can do to meet
your deadline is to learn when to walk away. This seems counterintuitive—
walking away when there’s work to be done—but it’s a trick that can actually
enhance productivity.
This isn’t an abstract philosophy. It’s simple math. You’ve been struggling
with a problem and working enough hours to get a little crispy. It’s the end of
the business day on Wednesday, and your deadline is Friday morning. Things
aren’t going well. You’re worried that you won’t resolve the issues before the
deadline, and so you pull an all-nighter to make it happen. Your dedication to
your job is not in question; your common sense, however, could use some
work. You do indeed go without sleep Wednesday night and continue working
on through Thursday. The code you wrote in the all-night affair isn’t working,
Chapter 9 Keeping the Project Under Control
151

and each attempt to remedy the situation just results in one more layer of
hacks and confusion. It’s now Thursday evening and you’re panicked. You find
a conference room and sleep for two hours, and then head back to your cube
determined to go all night and have the code ready for Friday morning. You’re
bleary eyed and unfocused, your memory is impaired, and you’re having diffi-
culty even concentrating or thinking clearly. You have absolutely no chance of
delivering a solid codebase Friday morning, and yet you’ve worked your tail
off and gave it everything you had. It’s true, you worked hard. You just weren’t
very smart.
Let’s rewind to Wednesday and try this again. This time, realizing that
you’re already pretty cooked and that your efforts to solve the problem are not
gaining you much ground, you decide to do something highly unconventional.
You inform all concerned that you’re going home to get a good night’s sleep
and warn them that you’re close personal friends with the maintenance pro-
grammer should anyone think of disturbing you. You take the phone off the
hook and sleep soundly. Early Thursday morning, you’re once again looking at
your code, only this time your head is clear and your focus sharp. You’ve also
had a little time away from the problem. Now, with a fresh perspective and a
more balanced state, you clearly see the flaws in your approach and make a
surgical strike or perhaps even throw it all away and start from scratch with a
better plan. Either way, by noon, your coding is complete and you’re deep into
unit testing, only to find that there just aren’t that many problems. You check
in your code, go home at the end of the business day Thursday, and on Friday
morning, deliver your work on time and in a stable state. You worked much
fewer hours and delivered much better quality, all because you knew when to
walk away.
Does this example seem a bit contrived? I can assure you both from per-
sonal experience and that of my friends that this is a very real story, in both
scenarios. It’s all too easy to get caught up in frantic desperation, thinking that
you’ll make “just one more pass” at the problem until it’s 4:30 in the morning
and you’re crispier than the day-old french fries on your desk. To realize when
you’ve hit a point of diminishing returns and call it a day takes both discipline
and the courage to explain to management that you are in fact doing the most
productive thing that you can to hit the deadline. More is not always more.
Sometimes, as musicians are known to say, less is more. It doesn’t seem to
make a lot of sense when you say it, but then what in this business does make
sense?
Optimizing Your Meetings
Another thing that’s a continual drain on the productivity of any software
development effort is the dreaded meeting. Depending on the size of com-
pany and its level of bureaucracy, you can end up spending half your life in
meetings, most of which don’t accomplish anything more than setting the
152
Part II Guerilla Tactics for Front-line Programmers

date for the next meeting and determining who’s going to buy the donuts.
Even so, many aspects of our work require a gathering of two or more people.
Communication is very important in our business. However, just because you
have a meeting doesn’t necessarily mean that you’re communicating effec-
tively. If it’s a given, then, that meetings are a requirement in the course of
writing a program, why not take the same approach to them as you would soft-
ware development? You optimize your code. Why not optimize your meetings?
Much of the pain and suffering that we encounter regarding meetings is
due not so much to the fact that we must attend them as to how poorly they
are typically run. Gatherings are held with poorly defined or unrealistic objec-
tives, people are often unprepared, and many just seem to ramble on without
end. It’s little wonder then that most programmers would rather admit to an
attack Chihuahua that they abuse monitors than they would attend a meeting.
Like most things, though, the problem can in fact be remedied if we first
break things down into building blocks that are small enough to address effec-
tively. With that in mind, what are the bricks of which a well-ordered meeting
is constructed? The following list describes the key components:
 A leader
 Someone to take notes
 Participants
 A list of specific issues
 Optional supporting documentation
 One or more specific goals to achieve
Let’s talk about the components first. The person who leads a meeting is
typically, but not always, the person who calls it. For instance, if someone in
upper management wants a status report on your project with feedback from
the developers involved, he may call the meeting but delegate leadership to
the project manager. 
The role of the leader is to keep the meeting on track and avoid the long,
rambling, and useless gatherings that we’ve all attended. The leader opens
each topic for discussion and grants each person the permission to speak. This
is not so much an opportunity for a power trip as it is a job working as a traffic
cop. If each person waits until being recognized by the leader before speaking,
much of the confusion that results when people try to talk over each other is
eliminated. Even if you have a small and informal gathering, observing this
will get you out of the meeting much quicker because less time will be wasted.
The leader also has the authority to table an issue and move on to the next
topic, particularly when it’s apparent that you’re beating a dead horse. When
it’s obvious that there’s no further benefit to be gained by additional discussion
on a given topic—whether there’s insufficient information, all the bases have
been covered, or a couple of people will simply never agree—it’s time to pull
Chapter 9 Keeping the Project Under Control
153

the plug and move on. By controlling the flow of the meeting, keeping people
from rambling and straying off topic, and pruning any unproductive tangents
as quickly as they sprout, the leader of a meeting is capable of keeping it lean,
to the point, and effective.
The person who takes notes has the responsibility of documenting all that
takes place in the meeting. When you have a room full of people trying to
scribble on paper, understand the points of others, and in general keep their
minds on the topics at hand, keeping notes is sporadic and inconsistent among
the participants. By dedicating one person to the process whose job it is to
note all details in the proceeding, everyone else is freed up to concentrate
more on the matter at hand. When the meeting is concluded, this person then
summarizes the outcome of the meeting and either emails or distributes a doc-
ument to all concerned. This gives the added benefit of everyone having a
consistent view of what really took place.
The participants of the meeting are those who have been invited to attend
because they have either something to offer or something to gain. If a person
doesn’t fall into at least one of these two categories, they shouldn’t be there.
Often, the person who stirs up the most trouble or rambles on and chews up
the most time is the one who didn’t need to be there in the first place. Because
they have nothing to offer or gain, they can only entertain themselves by dis-
tracting others. It is the responsibility of the leader, either directly or through
delegation, to choose participants wisely.
The leader also brings to the meeting a list of specific issues that this group
will discuss. The smaller and more concise this list of issues, the better chance
you have of getting something accomplished. This list may have been gener-
ated by one or more people other than the leader, but in the meeting, it is the
leader who walks through these topics and opens them for discussion.
Prior to the meeting, optional supporting documentation may also be dis-
tributed. It’s important to make sure that you pass this out to the participants
enough days before the meeting so they can actually read and absorb the
information, taking into account how busy their days usually are. If you hand
out information that no one has seen before at the beginning of your meeting,
one of two things will happen. Either they’ll ignore what you’re saying because
they’re busy reading the documents, or they won’t read them at all. Either
way, they’re missing information, and that won’t help the cause.
Listed last is something that should probably be considered first. What are
the specific goals that you hope to achieve by holding this meeting? I’m speak-
ing here of short-term goals—in other words, something that can be seen as
the direct output of the meeting. If you don’t have an objective clearly in
mind, don’t call the meeting. You may indeed have a larger goal, such as deliv-
ering a complex piece of software. However, you’re not going to address some-
thing at that level in a single meeting. If, on the other hand, you wanted to
make a decision regarding the specific user interface to be utilized on a specific
piece of functionality, that’s small and well defined enough to be attainable. In
short, know why you’re meeting in the first place, but, most importantly, know
what you need to accomplish.
154
Part II Guerilla Tactics for Front-line Programmers

Often, you’ll hear of people heading off to attend or hold meetings. When
you ask what the meeting is for, they’ll reply that they’re gathering to discuss a
particular topic. That’s not a sufficient definition for a meeting. I could call a
meeting to discuss the phases of the moon. However, when it was all said and
done, I might know a little more about why Chihuahuas howl in the wee small
hours of the night, but I wouldn’t have accomplished a darned thing. If I
instead held a meeting to discuss the fact that the maintenance programmer
grew long hair and fangs during the full moon, and opened the floor to possi-
ble safety precautions that could be taken to avoid any unfortunate incidents,
there would be a constructive point to the meeting.
This leads us naturally to the output of a meeting. Now that we have an
idea of what we’ll find in the conference room, what do we hope to achieve
once we get there? A meeting can generate one or more of the following
deliverables:
 A report of the conclusions
 Action items
 Future meetings
The first result of a meeting can be the documentation of the proceedings
by the person who took the notes. I used the words can be instead of is
because it’s not necessary to distribute this unless there’s a point. That’s the
thing to keep drilling into everyone’s head when it comes to meetings: what’s
the point? If an action does not serve the desired goals, ditch it.
Action items are effectively a list of actions that need to be taken as a result
of the meeting. This usually takes the form of individuals being assigned tasks
to perform. Along those lines, let me offer a word of warning to those of you
who are new to the corporate world: don’t miss meetings. Who do you suppose
gets tasked with the stuff nobody wants to do? In any event, action items are a
logical and expected output. Even if the purpose of the meeting is to decide
between Plan A and Plan B, in the end, someone’s probably going to get
assigned the job of carrying out said plan.
The third bit of output from a meeting can be future meetings. This isn’t
as bureaucratic as it seems. To understand why, let’s touch on another critical
topic of effective meetings: the duration. I’d love to have the following sign
hung in brilliant neon above the doors of every conference room in the world:
No meeting should ever, under any circumstances, last more than two hours.
It’s the leader’s job to make sure that this is so. Furthermore, two hours is an
undesirable extreme. One hour is better. Much, much better. People start
fidgeting after an hour and you lose their attention. This is why the output of
meetings can be more meetings. It’s actually more efficient to table a topic for
a future gathering that would be dedicated exclusively to it than to try and
address it in one marathon session.
If you’re looking for decisions on three separate topics, you may come to a
quick consensus on the first. The second, however, may bog down. Frequently,
Chapter 9 Keeping the Project Under Control
155

this is a sign that more research needs to be done before a decision can be
made. Rather than chew up everyone’s time trying to hash this out, the leader
simply tables this topic and declares that a future meeting will be held to
resolve the issue after sufficient research has been done. The group is then
free to pursue the third topic, which they quickly do. You’re in and out in an
hour, and you’ve accomplished two of the three goals. Subsequent research is
performed, and in a follow-up meeting, the elusive second topic is nailed
down in fifteen minutes now that people have had a chance to better prepare.
The first meeting could have gone on for six hours while everyone offered
their opinions, prejudices, and arguments on the second topic. In the end, you
still would have had to hold the second meeting because there was simply
insufficient preparation to resolve the issue. Instead, it wrapped up within the
one-hour limit, and the subsequent work involved in the follow-up meeting
took only another quarter of an hour. Those are much better numbers. It’s all
about making the most efficient use of the most critical resource in the pro-
gramming industry: your time. Focus is also much better when you have
shorter meetings that are aimed at very specific issues. Often, two concise
meetings are much more efficient than one long, rambling meeting in which
you try to solve all the problems of the world at once.
Complete books have been written solely on the topic of holding effective
meetings, but these key points can make a world of difference in the duration
and productivity of your gatherings. Of course, we didn’t discuss who has to
buy the donuts. Traditionally, it’s the person who calls the meeting. That’s the
other way that we discourage frequent and pointless meetings.
Wrapping It Up
When all the coding and debugging is done, when the last QA person has
signed off on the last bug, and when development has truly come to closure
such that even the night watchman’s dog can sleep without one eye open, it’s
time to hand management the keys and call it a wrap. That’s not, however, the
end of the story for this release. Now is the time to run the reports from the
time database and compare them to the original estimates. It’s also the time to
gather the troops for the best pizza in town and a frank and friendly discussion
of what went right, what went wrong, what came up that was unexpected, and
how you can improve the process in general for the next project.
If it has been a tough project and everyone is a little cooked, you might
want to give it a week and let everyone decompress. The goal is a positive and
constructive interchange aimed at reaffirming what was good and improving
what was lacking. It’s not an opportunity for finger-pointing, recriminations, or
any negative attitudes. That’s why you should defer it if your people need a
break. Tired people are pessimistic people. Nonetheless, when your troops are
rested, go over every single step of the process, from the initial requirements
down to the last bit of testing and installing. You’ll want to keep records of all
156
Part II Guerilla Tactics for Front-line Programmers

this so that you can see your progress and improve from project to project.
Depending on the political climate of your company, you’ll either put it in ver-
sion control or keep it at home. In any event, you learn from history, so keep
your records and make the improvements to your process that are needed.
This is also the time that you take for technical documentation, that less-
than-glamorous task of looking at the code and documenting what it is as
opposed to what you thought it would be in the beginning. Remember, this
documentation is not for anyone’s consumption but your own. There’s no need
to generate a 5,000-page document, but you should detail the codebase suffi-
ciently or it’ll just be trouble when there’s maintenance to perform. Of all the
tasks in the development cycle, this is typically the least favorite. Just remem-
ber, you’re doing this for the poor sucker that has to fix a bug at two o’clock in
the morning, and you might even end up being that poor sucker. Document
defensively.
No two software development shops are the same. Some are huge organi-
zations that are much more susceptible to bureaucracy and corporate politics;
others are small and understaffed, and more likely to take shortcuts than waste
time in pointless meetings. You will also find yourself in different positions as
your career progresses. Much of this advice applies to every level. Even the
parts that don’t seem relevant to you today because you’re only coding may
suddenly become important when you find yourself unexpectedly drafted into
a team lead or project management position. Hey, you don’t think these guys
volunteered for those positions, do you? A project manager is often nothing
more than a programmer who didn’t know when to duck. In any event, keep-
ing a firm grasp on your project as it progresses is as much an attribute of
preparation as it is of managing details along the way. When both are done
properly, you’ll find that the road is much smoother and that the stress level is
greatly diminished. That certainly makes it easier to digest your pizza.
Chapter 9 Keeping the Project Under Control
157

I’ve often speculated about the origins of those who find a career in the mid-
dle and upper strata of software development management. In fact, I suppose
if I had any business sense, I could have made a fortune long ago by selling my
ideas to Hollywood scriptwriters who specialize in science fiction, for in all of
my ruminations there is a single, overriding question: what planet are these
guys from?
Without a doubt, there is traditionally a huge conceptual gulf between
the rank-and-file programmers and those who manage them. The Suits never
really seem to grasp the fundamental issues that drive the software develop-
ment process. Instead, they proceed as if they believe that a computer key-
board is the modern equivalent of a magic wand, a device capable of all forms
of sorcery if the wizard chooses to wave it. For what it’s worth, I’ve waved
more than a few keyboards at management over the years. For some reason,
security seems to take a dim view of this. Perhaps it’s the way that I wave it.
Managers fare little better in their attempts to understand programmers.
We speak a strange, technical language that seems to have no relationship to
profits, expenses, or long-term business strategies. They’re never quite sure
exactly what it is that we’re talking about and are often frustrated by our
lack of enthusiasm for the truly important things in life as they see it. And
then there are the short tempers and those darned flying monitors. It’s little
wonder that management treats us as wild animals that lack the ability to
communicate.
Truly, a more dissimilar coupling of people I’ve never seen. It’s like two
wet cats thrown into a burlap bag, and the fur will continue to fly until we fig-
ure out a way to deal with them. The first step in this process is to understand
and accept that those who roam the halls in the guise of management have a
completely different perspective than do the techies. This makes perfect sense
because they’re trained in business, not software development. Just as you
wouldn’t expect a plumber to have a master’s degree in philosophy, it’s imprac-
tical to expect a businessman with an MBA to be extremely technical. Although
I’ve known some pretty philosophical plumbers in my day, when there’s water
159
Managing Your Management
10
C
H
A
P
T
E
R

pouring all over my kitchen floor, I’m much more concerned about his skills
with a pipe wrench. In a similar fashion, if it weren’t for the financial and busi-
ness skills of management, we’d all be writing extremely cool programs at
night while flipping burgers during the day. It’s their business skills that bring
in the money, some of which goes towards payroll. And that’s a trend that we’d
all like to see continue.
Still, realizing this does little to help us in our predicaments. Left to their
own devices, management consistently makes a shambles out of almost every
software development project that they touch. To have any hopes of delivering
quality software on a reasonable schedule, we must wrest control of the devel-
opment process from their hands. That’s a tall order when you consider our
position in the food chain. We work for management and not the other way
around, and so we lack the authority necessary to dictate the changes that a
controlled approach to development requires. This means that, for program-
mers to take the wheel, management must voluntarily give it up. Although his-
tory shows that those in power are typically reluctant to relinquish it, there are
ways of accomplishing our aims nonetheless.
Improving Communications
Working on a time-honored principle of human nature, to get what we want,
we simply need to show management what’s in it for them. Although it’s typi-
cally a source of frustration, in this case, it’s to our advantage that decisions in
the corporate world are not made based on merit but rather on what advances
the career of the decision maker. We can use this to our advantage. If the indi-
viduals in management can be shown that their current model of development
is costing them money and prominence in the marketplace and that our
approach will both boost profits and further the corporate goal of market dom-
inance, they will be much more motivated to listen. That’s because the man-
ager who makes the company more successful has a better shot at improving
his personal career path.
In short, to gain control of the development process, we must first moti-
vate and educate those who have the authority to make changes. The time to
do this, however, is before the project begins. Once the status quo kicks in,
it’s hard to alter, which means that we’ll be facing yet another project with ill-
defined requirements and arbitrary deadlines. Although not impossible, it’s
very hard to correct this problem in midstream because the time has passed
for much of the groundwork that is needed for an orderly approach to the
project.
Certain fundamental issues must be addressed for us to establish and
maintain control over the development process. First, requirements gathering,
design, and estimating must be accomplished in a compressed time frame and
still remain effective. In the beginning, we won’t be given the amount of time
160
Part II Guerilla Tactics for Front-line Programmers

we’d like, but we must still prove that our approach works. If we don’t, we
won’t be given the flexibility to do things our way in the future.
Additionally, throughout the project, developers must be responsive to the
actual needs of the company. It’s not enough to simply immerse ourselves in
technical bliss. We must make it a priority to address the business issues that
our software was commissioned to improve. That’s more a matter of a perspec-
tive than it is a list of specific actions to take, but it’s worth mentioning. As
programmers, we tend to get caught up in the technical side of things and
completely lose sight of (or just plain don’t care about) the underlying business
issues. And yet, for the company to prosper, the business issues are truly all
that matter. It’s hard to accept that the solar system does not revolve around
our code, but if we’re to be successful, we must not lose sight of the fact that
the business issues are, in fact, the ultimate priority.
Lastly, to get our points across to management and garner the respect that
we’ll need in order to induce change, we must speak their language, learn to
make presentations to which they can relate, and in general bolster our credi-
bility. If we can accomplish this, we’ll be dealing with management on their
own terms. We’re never going to turn them into techies or make the program-
ming issues that are so dear to our hearts their highest priority. Instead, if we
really wish to institute change, then we must fight from the inside. This means
slipping behind enemy lines and blending in with the scenery. It’s not always
fun, it’s not always safe, and it’s almost never easy. However, if programmers
in every company in the business world can change the way that software is
developed, we will not only improve the quality of our own professional lives
but also the overall quality of software in general. To me, that makes it all
worthwhile.
The programming community is an international one, and I’ve had the
good fortune to work with people from all over the world. Born and raised in
America, I speak English. Of course, one of my friends from England once
corrected me, saying that I don’t speak English, I speak American. Be that as
it may, having never had a need to speak any other languages, it’s the only one
I know. Those who travel here from other countries speak many languages,
English among them. Were they to speak to me in French, German, Italian,
Spanish, or any other language, they’d simply get blank looks from me because
I wouldn’t understand what they were saying. However, because they were
intelligent and motivated enough to learn my language as well as their own,
they are able to converse with all of the English-speaking people in my com-
pany. That means that they are able to achieve their own objectives in the
business world, much of which involves getting a job kicking out cool code.
It’s absolutely no different in the business world. Programmers employ a
form of geek speak, and business people speak their own peculiar language.
Attempting to communicate with a manager using a programmer’s language
and point of view is futile. You’ll get the same blank looks that my more edu-
cated friends get from me and for the very same reason. If you don’t speak a
common language, you won’t have effective communications. 
Chapter 10 Managing Your Management
161

One of the first steps in learning the lingo is to change your perspective.
Believe it or not, the world does not revolve around programmers, and other
priorities and points of view exist in the business world. We need to become
comfortable with this reality. Consequently, it helps if you can start thinking
like a business person. It’s not beyond your capabilities. It’s just something that
most programmers don’t want to do. This doesn’t mean that you now have to
start spouting empty buzzwords or adopt a more bureaucratic approach to
your work. It simply means taking a look at how they think and understanding
what motivates them. Although this varies a bit from person to person, some
things are true in general of our pinstriped friends.
In the business world, you’ll find that management is a culture that values
statistics and reports from business newspapers, industry analysts, and so on.
This means that you can benefit in your communications by gathering similar
statistics of your own when there’s a point you wish to make. Of course, the
nice thing about statistics is that you can find numbers to support virtually any
theory or position. Even so, you’ll find that management respects statistics
nonetheless. When starting with an agenda that you wish to promote, hit the
bookstores, trade magazines, and newspapers to find corroborating numbers
that support your view. Rightly or wrongly, printed publications are given
more respect and credibility than an Internet Web site, so research accord-
ingly. Armed with this information, prepare a presentation in a format that
they take seriously and give it to them in their language and from their per-
spective. You’ll be surprised at the difference in their reactions. Where you
may previously have encountered a rather dismissive attitude from manage-
ment, you’ll now find that they’re actually listening to you. That doesn’t guar-
antee that they’ll agree, but there’s no way that a proposal can succeed if they
aren’t interested or paying attention. It’s the first step in achieving your goals.
Another method of conveying what you wish them to hear is to adopt their
manner of speaking. As distasteful as I personally find the shallow nature of
corporate speak, if you learn the catch phrases, buzzwords, and metaphors
that management uses and communicate in a similar manner when speaking
with them, you will again have their attention. Think of it as learning a foreign
language that you’ll need when traveling to a strange and distant land, for the
domain of management is about as alien to programmers as the landscape of
the moon. Learning their language is actually rather easy, by the way. If you
were smart enough to grasp a programming language, comprehending the ver-
biage of the Suits is a piece of cake. It simply takes attention and effort. Just
make sure you revert to normal speech when around your fellow program-
mers, or you’ll never hear the end of it.
Another method of speaking their language is what I previously referred to
as changing your perspective. You have to talk about the things that are impor-
tant to them, not to you. Well, actually you have to talk about what’s important
to you, but put it in terms of what’s important to them. As an example of this,
let’s look at dissipating the idea that managing software development by shoot-
ing from the hip is really quicker than the ordered and structured approach
that we’re promoting here. Truly, management considers our procedures to be
162
Part II Guerilla Tactics for Front-line Programmers

nothing more than lost time. This is why they shoot from the hip to begin with,
because they think it’s the quickest and most cost-effective way to get software
out the door. As long as they go on believing this, they’ll have no reason to
change.
Instituting Change
Programmers could probably write an entire operating system in the time
that’s lost on a typical project because of rewrites due to scope creep and slid-
ing requirements. The amount of time lost from integration issues and archi-
tectural rewrites stemming from an incomplete design phase is typically more
than all of our procedures would take combined. However, designing and cod-
ing from the hip can be done. Companies do it every day. Software projects
are always late and buggy, too. Coincidence? Not likely. Even so, because of
the perception that coding is the only work that moves the software project
forward, all else is considered a waste of time that delays the ultimate release
of the program. The fact that we know otherwise has no impact because they
don’t understand the technical side of things.
Now let’s look at how we would change the way they think using their
point of view. They believe that shooting from the hip delivers software
quickly and is more cost-effective. First of all, we need a common definition
of what delivered software really is. Management would probably agree that a
software project is not really complete as long as you’re still spending money
on it. When a hurried program makes its way out the door, there is inevitably a
cycle of bugs being found in the field, with the programmers fixing them and
patches being made available to the users. This takes both time and money,
as programmers don’t work for free. Additionally, technical support costs
increase dramatically due to the higher call volume that these bugs cause. As
changes are made, documentation may also be updated to reflect the new
state of the software. Tech writers don’t work for free, either. This particular
bit of money spent on support and documentation would not have been spent
if the project was stable before it shipped. Therefore, in dollars and cents, not
following our proposed procedures directly drives up the cost of the final
delivered product. Due to unstructured rewrites and the massive debugging
adventures involved, it also takes longer to write something poorly and fix a
gazillion problems than it does to spend a little time in preparation up front
and do it right the first time. That’s more money out the window.
If you make an emotional argument based on the amount of sleep you’re
losing or the number of times you’ve had to rewrite the code, it will fall on
deaf ears. However, if you do a little research, find some reference materials
that support your arguments, and then show them how delivery time is actually
longer and, in particular, how costs are dramatically increased with the current
way of doing things, they’ll listen to what you have to say. That’s because you’ve
presented it in a language that they understand, used meaningful reference
Chapter 10 Managing Your Management
163

materials, crunched some numbers, and showed them a bottom-line impact
on the profitability of the company. Furthermore, if you’re clever, you’ve also
alluded to the fact that, when the manager you’re dealing with institutes these
changes and saves the company a ton of money, he’ll also be an obvious choice
for promotion. You have spoken his language and addressed what’s in it for
him personally. You have a very real chance of prevailing. If you approach all
of your proposals to management in a similar fashion, you have the opportu-
nity to truly change the way in which your shop develops software. Who
knows, your fellow programmers may even pitch in and buy you a gold-plated
pocket protector.
We’ve been focusing thus far on middle and upper management. However,
for many programmers, the person they need to convince is either another
programmer on their team (such as a technical lead) or a project manager.
These types of people have a different set of motivations than do the upper
levels of management. Both programmers and project managers will relate
more easily to the ability to get the next cool project that they want, or the
opportunity to move to a position they desire. This could be a chance to use
a new technology they want to work with or moving up to a position of team
lead, system architect, or project manager. It’s also convenient that you won’t
have to learn a new language to speak to this group, as they’re techies. Project
managers might be the exception to this, however, if you work in a large
enough company in which project managers take on the guise of half pro-
grammer, half Suit.
Now that we’re all speaking the same language, what else do we need to
sell management on if we’re to improve the state of software development in
our individual companies? First, they must understand the dependencies of
the development process. This is a pretty straightforward procedure that
requires little explanation to most programmers:
 Design must not proceed without final and detailed requirements.
 Implementation must not proceed without complete design.
 Final QA must not proceed without implementation.
 Deployment must not proceed without final QA.
It is imperative that one phase be completed before beginning the next.
They must be made to understand that real progress is being made even if
they don’t see programmers coding. If, during the design phase, functionality
is added or changed, you must revert back to the requirements phase and
make the appropriate modifications before continuing. The same goes for
every step in the process. It’s important for management to realize that, if you
spend the proper time in requirements and design, the coding and delivery of
milestones proceed much more quickly and with fewer roadblocks. Again, you
can convey tangible, business-oriented results to make this point, because time
is money.
164
Part II Guerilla Tactics for Front-line Programmers

Management must also be shown just exactly how important accurate and
detailed estimating is if the deadlines are to be successfully met and therefore
reliable. A good estimate takes time, and therefore time for estimating itself
must be factored into the schedule. Detailed estimates also produce mile-
stones of small granularity. This is better for project management as well as
upper management because it allows both to keep a close eye on the progress
of the project and keep it on track. For all the time that detailed estimating
takes, doing it right yields estimates that are dependable. This reliability
greatly reduces the risk of a project running late. Risk management is also an
important concept to those in the upper reaches of the food chain. Dependable
timelines are also better for marketing because they’ll help avoid the embar-
rassment and additional expenses that result from advertising a product, miss-
ing the delivery schedule, advertising the next release date, missing it again,
and so on.
Many people don’t want to do a thorough job of estimating because they
don’t really want to hear that the project will take a long time. They must
understand that, if the amount of time is unacceptable, it is far better to know
it up front and cancel the project than it is to find out the hard way after com-
mitting the company’s money, manpower, and position in the marketplace.
An easy way to make this something that the individual manager cares about
is to point out the obvious. If the project turns out to be a disaster, who do
they think is going to get the blame? The person who has the authority to say
no to a detailed estimation process is the very same person who will be burned
at the stake when the project fails. If you can make them understand this,
they’ll have a new personal motivation for hearing what you say. The ultimate
reality is unchangeable. It takes as long as it takes. No amount of denial will
change that.
Bolstering Your Position
If you’re proposing a new or different way of doing things in your department,
you’re going to need some justification. People are quick to point out that
they’ve always done things a certain way and the world hasn’t come to an end.
Therefore, if you want them to take the risk of changing the status quo (and
that’s perceived as a huge risk in the corporate world), you’d better be able to
justify your proposal. This shouldn’t be much of a problem because you doubt-
less have plenty of ammunition. All of the previous projects that were late or
became some form of a disaster can be used to provide examples of the conse-
quences of an improper approach. This is part of your proof and their motiva-
tion. At the risk of pointing out the obvious, if you can’t find examples of these
disasters, then it seems to me that your company’s doing just fine and you
don’t need to change the way you’re doing things. Any details that you can
point to from failed projects (such as figures, statistics, demoted managers, sig-
nificant layoffs, plummeting stock prices, bad press, poor sales, a parking lot
Chapter 10 Managing Your Management
165

littered with shattered monitors, and so on) will provide a motivation that they
can readily appreciate. Fear can be a great motivator. Of course, if you can
map it to dollars and cents, that’s going to help a great deal with middle and
upper management. Additionally, if you can map it to promotions, more
power, and an upward career path, that helps with everyone from the project
manager on up. This sort of preparation will prove quite valuable to you in
demonstrating why things should change.
Eventually, with persistence, you will get the opportunity to put all of
this into practice. Once you do, it’s critical to make sure that your project is
considered a success. Regardless of where you get your foot in the door, you
absolutely, positively must be perceived as a success if you wish to continue
doing things your way. Note that I didn’t say that your project should succeed
but rather that it should be perceived as a success. It doesn’t matter if you’re
right if no one else recognizes this fact.
To make sure that the world acknowledges your achievements, you must
keep track of all the low-level timeline details we’ve discussed previously and
be ready to kick out a report on a moment’s notice that will show all of your
successes thus far. That’s why we keep the granularity small. The more
milestones you have, the better chance you have of hitting most of them.
Furthermore, reporting that you hit nineteen of twenty milestones is much
better than showing that you hit one of one. The latter could be a fluke,
while the former establishes a clear pattern of success.
Additionally, it’s important that you subtly ensure that the whole world
knows you’re on track, on time, and under budget. I say subtly because if
you’re constantly in everyone’s face about it, you’ll eventually irritate people to
the point that they’ll want to see you fail just to take you down a notch or two.
They may even actively work against you because of this. One way of going
about this is to gather as many cheerleaders as you can get. It always looks
better when other people tout your achievements rather than doing it yourself
and appearing egocentric. You’ll find support in a lot of places if you look hard
enough, such as other programming groups who’d like to have the same free-
dom, managers who are impressed with your success and look good because
of it, and political hangers-on who just want to be associated with a winner
because they’re social climbers. Who cares what their motivations are? It all
adds up to a good support base, and it’s all good advertising. You’ll need it
from time to time, no matter how well things are going.
Of course, to be considered a success, you have to get the chance to prove
that you’re right. Look for every opportunity that you can find in the begin-
ning to work on small, isolated startup projects. Management will be much
more likely to take a chance on a small risk rather than a large one. If you need
to gain more credibility and you have no track record, propose that you be
allowed to prove your concepts on one of these small projects because it’s
obviously a low risk to management. Be sure to point out that, even though a
success on this pilot program may not change the world, the implications for
the rest of the company could be quite large. As always, be sure to also men-
tion that the manager who first fields the concepts that ultimately lead to
166
Part II Guerilla Tactics for Front-line Programmers

overall benefits for the company will surely be given a boost on the career
path. What if no small projects are handy? Create one. Programmers are
always good at coming up with an idea for a useful program.
You need to consider one additional thing when trying to convince man-
agement that the current approach to developing software needs improve-
ment. What do you do if none of this sways them and they insist on continuing
with chaotic development approaches that consistently create disasters and
stress? Update your résumé. Life is too short to work for clowns.
Frontal Assaults (For Those Who
Respond to Reason)
The business world is no different than any other aspect of humanity. Just as
some people are obstinate by nature, there are those who are open to direct
persuasion and for whom convincing arguments are sufficient motivation for
change. We’ve talked about the retraining that management requires and a
little bit about how we should proceed. Now let’s take a look at some of the
direct approaches to achieving this goal.
In general, businesspeople can relate to airtight, well-prepared presenta-
tions. Conveniently, so can project managers and programmers. The most
important aspect of making a direct proposal for change is to use the right
presentation for the given audience. Find out by observation and investigation
exactly what language they speak and what forms of presentations they take
seriously. For high-level Suits, this may mean formal meetings and polished
reports with a lot of pie charts, graphics, and summarized corroborating statis-
tics. For project managers or middle management who take more of a hands-
on approach, a more technical perspective backed up by detailed reference
materials, real-world examples, and unambiguous information will be more
appropriate.
If you have occasion to attend meetings that the people you wish to pres-
ent to either hold or attend themselves, you have the perfect opportunity to
gauge this. Pay attention to what they respond to, what they seem to immedi-
ately dismiss, and—most importantly—how they present things themselves.
What do they use for supporting materials? Videos, slideshows, printed docu-
ments? If they use printed materials, how fancy is the formatting? Do they
lean towards dense, information-intensive pages or very sparse presentations
that are heavy on graphics and light on verbiage? In short, do your homework
and find out as much as possible what pushes your manager’s buttons. It’s
important to have solid facts, but, as anyone who watches television can tell
you, advertising is typically more about presentation that content. Television
advertising is extremely expensive. If they spend that much money and yet
concentrate on how they’re saying things more than what they’re saying,
there’s a reason. It works.
Chapter 10 Managing Your Management
167

I once worked for a consulting company that dealt with many banks. I’d
been asked to put together an assessment of a particular client’s codebase in
preparation for a project we were proposing. Being a programmer, the result
that I handed in was one very dense page of highly detailed points. The man-
ager who requested it looked it over, approved of the contents, and then told
me to get together with another manager who would show me how to turn one
page into twenty. The result was a very highly polished, bound presentation
sporting a fancy cover, with rich graphics taking up most of each page and
perhaps a line or two of explanatory text at the bottom, all laid out in a neat,
sequential manner. I remember at the time scoffing at such fluff. However, in
this case, my management was much smarter than I was. They knew the lan-
guage that the bankers responded to and they spoke it well. We got the project.
When it comes to making proposals, where is just as important as what. If
you don’t hold an official meeting in a conference room and conduct it just as
they do their meetings, many managers won’t take you seriously. If you want to
be successful with these guys, all you really need to do is observe and mimic
their behavior. Informal gatherings in cubicles or hallways may suffice for pro-
grammers or project managers. Just make sure that your arguments are still
well thought out and bulletproof. The single most important aspect of making
a successful proposal in the corporate world is simply to adapt to your target’s
environment and mannerisms.
Once you have their attention and they’re taking what you say seriously,
you must still make a winning presentation if you want them to accept your
plan. A few ground rules need to be observed here. From the very first
moment that you approach them about your ideas, always be sure to focus
on what’s in it for them. Otherwise, why should they care?
Often, what you propose may be a change to the way that they personally
have decided to do things. It’s absolutely critical to keep their ego in mind
with every word that you speak. People frequently make emotional decisions.
Stepping on someone’s ego is the quickest way in the world to trigger this, and
I can assure you that you won’t like the decision. Consequently, take great care
to avoid criticizing their plan. Point out the portions of their approach that you
intend to keep and be sure to highlight the things that you think are great
about them. When suggesting something that would replace or contradict
their current way of doing things, approach it by pointing out that their cur-
rent plan has many good things going for it and that what you’re suggesting is
just something to make a good plan even better. Never, ever offer a perspec-
tive that they can take as personal criticism. You’ll be dead the minute you do.
Overall, your proposal must not only be presented well, it must also offer
them lower risk and higher benefits. Specifically, it must do so from their per-
spective, not yours. By speaking their language, using common phrases,
acronyms, points of reference, and tailoring your way of presenting your argu-
ment to the style to which they are accustomed, you have a very good shot at
walking away a winner on every point. If you can manage to phrase things in
such a manner that they also walk out feeling like a winner on every point,
you can be assured of continued support and enthusiasm on their part as you
168
Part II Guerilla Tactics for Front-line Programmers

proceed. Everyone loves a win-win scenario. What you propose may not, in
fact, be such a situation, but that doesn’t matter. All that matters is that they
perceive it as such.
Stealth Tactics (When Reason Is
Not Enough)
Life would be much more simple and people much easier to deal with if
everyone made their decisions based on logic. Unfortunately, we’re dealing
with human beings, and they just don’t work that way. Very often in your
career, you’re going to find yourself in a situation in which logic, common
sense, and clearly presented arguments will still lose, time after time. All the
pie charts in the world aren’t going to help on such occasions. However, the
people who give up are the people who never win. If we can’t make it in
through the front door, we’ll simply sneak in through a window. Just keep an
eye out for tiny dogs wearing combat fatigues. Those little teeth can really
get your attention.
I’ve heard it said that there is often more power in being a king maker than
in being a king. If your position is such that you just don’t have the power to
institute change, then what you need to do is alter the perspective and actions
of someone who does. There are two types of people in this regard. First are
those who actually do have the power to make changes. In this case, your
efforts can get them to make the changes for you. The second type of person is
someone who is effectively almost as powerless as you are, but who has access
to those with more clout. If you can get this person on board, you can still pro-
mote change. It’s a little like playing pool. Sometimes one ball hits another,
which then hits another, and so on before you achieve the desired effect. Who
cares, as long as the right ball goes into the right hole?
One method of influencing another person in your company is to become
an ally. I’m not suggesting a campaign of brown-nosing, as I have difficulty
dealing with the types of people who suck up to others. Rather, as mercenary
as it may sound, what I propose is that you learn to manipulate others to do
your bidding. In a perfect world, we wouldn’t have to do such things, but the
corporate world is a far cry from perfect. Business is war, and I like to win.
By becoming a trusted lieutenant and confidant of the person who can
help you make changes, you’ll be in a position to continually whisper things in
his ear that others would not have the opportunity to suggest. To gain this kind
of access, however, you have to become a valued commodity. The first thing
you need to do is get a clear picture of their personal agenda in the company.
Everyone has an agenda, including you. You simply need to find out what this
person wants to achieve. That’s typically not too difficult because people often
advertise such things openly.
Chapter 10 Managing Your Management
169

With a knowledge of what they want to accomplish, you then look for ways
to offer support. Becoming a source of hard-to-get information is one tactic.
You may also offer strategies and solutions for their problems, but if you do,
it’s important to position yourself in a supporting role and allow them to take
credit for anything you might do on their behalf. Look ahead and meet their
needs even before they realize they had them. Demonstrate loyalty, and let
them see that you’re watching their back. In such ways are allies made.
As they continually see you supporting their position and backing them up
in any way that you can, they’ll come to count you as one of their own, regard-
less of the departments in which each of you works. One note on this approach
is to make sure that you offer all of this help with an attitude of strength and
self-respect. Regardless of the fact that I personally don’t care for groveling,
subservient creatures, it’s strategically important to avoid being perceived as
someone who’s just sucking up. If that’s what they think, they won’t have any
respect for you, and you will consequently have no power to influence their
decisions or actions. Instead, you must be seen as a person who is strong,
sharp, and capable and who is offering your help only because the two of you
share a common vision. They must feel fortunate to have such a capable ally.
It’s okay to position yourself behind them; their ego may require it anyway.
Just make sure that you have their respect.
Mentoring is another way of doing this, particularly if the person you’re
dealing with is new to his position or just young in general. If such is the case,
you will have experience in areas where they’re weak. Often, they will have
already paid the price a couple of times for their weaknesses. If you casually
and quietly show them the ropes, you can gain both their respect and support.
This is often very easy to do. When you see them about to do something that
you know will result in their getting nailed, let them know what’s lurking just
around the corner and how to avoid it. They may be skeptical the first time
you do this, so make sure you’re right, particularly about the repercussions
that they’re about to experience. When things go just exactly as you said they
would, you’ll immediately have their undivided attention.
Once you’re in this position, look out for them as you would your own fam-
ily and share with them every trick you know. Don’t worry about reaching a
point where you have no more to show them. By the time you’ve reached that
plateau, you will have gained an ally and a friend. As always, remember the
chain of command and watch their ego. Equally important, never allow others
to see you helping or take credit in any way. The idea is to strengthen their
image, not your own.
The next method of gaining access is something you can learn from mar-
keting. Many transactions in the business world happen not at formal meetings
with three-piece suits lined up all in a row, but rather over cocktails. Socializing
can be an extremely powerful tactic when done properly. Whether it’s playing
golf, dodging handballs, going out for drinks, or any other form of contact with
them outside the workplace that forms a bond, it establishes you as someone
in the inner circle. As such, you have access, which is what we’re after here.
170
Part II Guerilla Tactics for Front-line Programmers

When socializing, it’s important that you never talk business unless they
bring it up. If you do, you’ll find out quickly that you’re no longer invited to
any of the really good reindeer games. Rather, be a good listener. As you hang
out with them, they’ll start grumbling about the office problems all on their
own. Take mental notes of the difficulties they’re having. In addition to being a
social friend, you’re also arming yourself with the information that you need to
make yourself more valuable. If you know what problems they’re encounter-
ing, then you know where you can try to make a difference and bring them aid
and support.
Another means to an end is that of gaining consensus and support from
others who can influence management for you. This is very dangerous stuff
and is only for the most extreme of situations because getting people to gang
up on management can easily be construed as mutiny. Most commanders take
a dim view of such things. You’ll typically either win big or lose big. Make sure
that you can afford it before you attempt this approach. No matter what you
do, care should be taken to avoid being seen as insubordinate. That’s just the
polite term they use in the business world for mutiny, but that single word is
also all that needs to show up on an employee review to end said employment.
Whether you instigate a little friendly persuasion or an all-out revolution
will depend on the gravity of the situation, how much support you can truly
count on, and in general which way the wind blows in the company. If things
are going so badly that you need to instigate a mass uprising, you should prob-
ably have your résumé updated anyway because there are only three possible
outcomes. The first potential outcome is that you’ll succeed, in which case,
you just forget about the resume. The other two possibilities, however, are that
either it doesn’t make a difference (in which case, you should put that résumé
to good use and move on to new opportunities) or it will be seen as a mass
revolt. In that case, life will get bad in a real hurry. However, if things are so
bad that you’re thinking about looking for another job anyway, you have much
less to lose by taking one last shot. Just remember that a good reference is
among the things you risk.
Credibility, the Key to Success
Credibility is not something you come into the business world with. No matter
how many college degrees you have and regardless of how impressive your
résumé, the only way you’re ever going to get a solid standing and the respect
that you deserve in your company is by demonstrating time and again that you
can deliver on your promises. To middle and upper management, everything
else is just talk. This may seem like a no-win scenario when we’ve observed
that many companies choose deadlines that guarantee that their developers
will fail. On a large scale, this is true. However, credibility is something that
tends to be cumulative. Consequently, many small successes are often more
effective than one large one. You often have to artificially create your own
Chapter 10 Managing Your Management
171

scenarios for success to rack up the points. However, the first rule of maintain-
ing your credibility is to deliver the goods. If you’re successful, they’ll take you
more seriously with each new venture.
There are, however, more aspects to building credibility than simply doing
what you said you would do. Keep personal notes of all your successes, the
times that your recommendations were right, and all of the benefits that either
the company or the management you deal with received. Keep these notes at
home. I’ve mentioned this before, and I do so again here only because you are
never guaranteed privacy in the business world. Consequently, it’s the safest
way to keep confidential information to yourself. Also keep notes of every 
software-related disaster that you’ve observed, on any team, with as much
detail as possible on why it happened and what would have prevented it. Make
meticulous notes regarding who the responsible parties were as well. This is to
make sure that you never mention them directly. It’s not only good manners,
it avoids creating adversaries unnecessarily. Style counts.
There will be times when these notes will come in handy when you need
to reaffirm or defend your credibility. If you need to defend your position in a
particular power struggle, it’s hard to work from memory. At such times, what
you really need is precise and specific information that you can convey without
fear of contradiction. Get into a habit of jotting things down in a notebook
when you get home from work. If you’re more ambitious, punch it into a data-
base on your home computer so that you can do specific searches later. Either
way, make your notes at home, not at the office. If you’re seen doing it at
work, you simply make yourself vulnerable to attack by others. Doing it at
home at the end of the day, while the events are still fresh in your mind, is
both perfectly safe and more accurate.
Another aspect of credibility is simple physical perception. From a political
point of view, it’s best to look, act, and dress like the herd. Honestly, I’ve never
been very good at this, and I’m more likely to show up in blue jeans and a
black leather jacket than I am slacks and a golf shirt. Frankly, I would have
done better in many circumstances had I conformed more. However, that
said, it’s okay to establish your own individuality (within acceptable company
boundaries) provided that you’re recognized as someone who always comes
through. In fact, at times you can play it to your advantage. Some people love
me, some don’t, but few ever forget me. This comes in handy sometimes.
Of course, coming back to a recurring theme, you must never forget that
you’re dealing with people. In the business world, a huge number of decisions
are made not on the black-and-white issues of profit and loss but rather due to
emotions, personal inclinations, and bonds with other people. Kindness, con-
sideration, and just being a nice guy in general are always in your favor. It may
be necessary to defend yourself from time to time, but never show your teeth
if you can avoid it. People remember that sort of thing. In fact, avoid antago-
nizing people whenever possible. You’ll do enough of it as it is, and there’s no
advantage in creating animosity if you don’t have to.
172
Part II Guerilla Tactics for Front-line Programmers

Additionally, never underestimate the power of charisma. You don’t have
to be a movie star; they just have to like you and trust you. People will do
all sorts of unreasonable things if they like you. You can even get them to do
reasonable things. Of course, always watch their egos. People will also do
unreasonable things if you hurt their feelings.
Part of credibility is being a trustworthy person. Therefore, make sure that,
if people follow your recommendations based on personal affinity or trust, you
never let them down. Furthermore, if things go south because of your ideas,
step up to the plate and take the consequences yourself. Doing so will con-
tribute to their perception of your integrity, as well it should. From a tactical
point of view, though, the blame would have landed on you anyway. You may
as well get some mileage out of it.
In general, reliable delivery dates can come from only the developers.
Management, however, has somehow gotten the impression that they’re in
charge. This means that, if we’re to have any chance whatsoever of changing
things for the better, we have to retrain our managers. To do this, developers
must gain not just their trust, but also the opportunities to prove that we have
a better way. Accomplishing this requires effective communications, credibil-
ity, and more than a little behind-the-scenes maneuvering. It’s not what you
signed on for when you took your job as a programmer, but the choices are
clear: learn to manage your management or continue to cope with the disas-
ters that their inept techniques cause. Although it’s not the sort of thing that
most of us care to spend our time doing, in the end, the improvements we
make in our development process, not to mention our ability to get a decent
night’s sleep, make it all worthwhile.
Chapter 10 Managing Your Management
173

It’s a common dream to live in a world in which everyone is always treated
fairly, with respect and equality. If you ever find such a place, be sure to save
me a seat. I’ll bring the donuts. Although it’s a tall order for humanity in gen-
eral, in the corporate world, it’s not even on the horizon. No matter how good
the intentions or benevolent the company, when you have a building full of
people vying for money and control, somebody’s gonna get hurt. If you’re not
careful, it’ll be you. It has been said that in the animal kingdom, it’s either get
dinner or be dinner. Thankfully, we don’t have to go to such extremes in the
business world. Nonetheless, if you don’t know how to exercise a little self-
defense, you’re going to have a very unpleasant stay. But at least it will be
short.
Exactly what kind of defenses are we talking about here? Barbed wire and
machine gun nests? Although I’ve had days when that was indeed tempting,
there’s no need to break out the weaponry or start renting a bunch of over-
dubbed martial arts movies. The self-defense we need in this case has little to
do with bodily harm. Besides, we have attack Chihuahuas for that job. The
threat in the business world is not that you’ll find yourself dodging bullets
(at least if you give the maintenance programmer a wide berth). More likely,
you’ll be dodging bad assignments. Those who have chosen a career in build-
ings crammed with cubicles soon find that it’s a dog-eat-dog world in which
nothing is sacred, although I’d recommend against using that phrase around
the security shack. Turn your back for just a moment, and they’ll steal your
project, your programmers, and even your stapler. Make no mistake: the very
first targets are the ones who look like easy prey.
Does all of this sound overly dramatic to you? If so, you either lead a
charmed life or you simply haven’t spent enough time in the business world
yet. The software development business, whether you’re working on a commer-
cial product or internal software, is a collection of highly competitive people,
each with his own agenda. Some pursue this agenda in an aggressive and cut-
throat manner, and others take a more civilized approach. Many struggle in
the area between, grasping and fumbling, sometimes winning and sometimes
175
Corporate Self-Defense
11
C
H
A
P
T
E
R

losing, but usually making a mess of things in the process. It’s true that many
go about their business in a reasonable and considerate manner, but it only
takes one or two of the other sort to put a premature end to an otherwise
good day.
What Do You Have to Lose?
But exactly what sort of dangers does a professional programmer have to
guard against? Let’s talk about some of the bad things that happen to good
programmers. Just to have an extreme to start with, consider the loss of your
job. Projects come and go, and the size of a company’s development depart-
ment is often in a state of flux. When times are good, human resources is hir-
ing anyone who can breathe and type three words a minute. Six months later,
however, a couple of major projects get canceled, and suddenly it’s a game of
musical chairs as people scramble to avoid being laid off. Who do you think
ends up keeping their job: the most talented and qualified? Sometimes. But
not always. Invariably, when times get tough, the people who thrive and sur-
vive are the ones who can maneuver, even if they’re drooling idiots when they
sit down in front of a compiler. Perhaps you’ve known such people.
This can get a bit ugly, fostering situations in which one person goes out of
his way to make others look bad to management so that they’re the ones who
get cut from the herd. Many times such unscrupulous people succeed, and
good programmers unjustly lose their jobs. Why? Because they didn’t know
how to defend themselves or—worse still—somehow felt that they didn’t have
to participate in a struggle that was beneath them. Occasionally, this will be a
blatant event, but it happens much more often than you think and in subtle
but effective ways. The end result is always the same: those who do not defend
themselves are the first to go.
At other times, your employment status may not be in jeopardy. However,
you could lose many other things. We get up each morning and rush to work
because we’re excited about what we do for a living. Most programmers are
always looking for new technologies to play with and typically have a pet proj-
ect or two going on for entertainment purposes if nothing else. The types of
assignments we get are a very fundamental part of our job satisfaction. If
there’s some hot, sexy new technology that you’re just dying to get your hands
on but someone else is better at playing the game, you may well find yourself
relegated to doing postmortem technical documentation while the more politi-
cally adept programmer props his feet up and has one coding adventure after
another. It may not be fair if you’re senior or more qualified, but it’s the way it
is. Again, if you don’t learn a little hand-to-hand combat, you’ll start losing bat-
tles that you care about.
Ever notice how some programmers seem to have all the luck? They’re the
ones with the 75-inch monitors, a connection to the Internet via direct satellite
hookup, a couple of super computers tucked under their desk, and all of this
176
Part II Guerilla Tactics for Front-line Programmers

in an actual office with a door. How is it that these guys end up with all the
cool toys? Are they really that good? Well, they’re certainly good at saying the
right things to the right people. That’s why they get the best toys. And wait a
minute, isn’t that my stapler on his desk?
I could go on for days, but by now you probably have a pretty good picture
of what I’m talking about and can see it in terms of the company where you
work. In the corporate world, there are takers and the taken. Now, just for the
record, I’m not advocating that we should all become grasping, coldhearted,
back-stabbing meanies. I personally believe in treating people with kindness
and respect, the same as I’d want for myself, and I believe that to a degree,
this will bring its own rewards. In the context of the workaday world, people
like doing things for nice folks. Given the choice, that’s how I prefer to spend
my days. Unfortunately, not everyone shares the same attitude about this sort
of thing, and I occasionally find myself in a situation in which I either must
take action or be the victim of someone else’s questionable morals. The world
can be a dark and scary place. I shoot back.
I once worked on a team where one of the analysts was fairly outspoken
and worked very hard to try to bring a quality product to the users. He truly
cared about their needs and lobbied hard for anything that promoted better
quality or functionality. In contrast, some of the programmers who felt that the
user requests would be too much trouble would literally lie to them about why
something just couldn’t be done. As you can imagine, the sparks flew on more
than one occasion.
Then one day the middle manager to whom our project manager reported
was transferred. The new guy who took his place was the immediate target of
pressures and arm-twisting from the programmers who felt that the analyst
was, well, inconvenient. As it happens, the analyst was also a friend of the proj-
ect manager. Unfortunately, the other programmers had a number of friends
and allies in middle and upper management and they turned the heat up on
my project manager’s boss to have the analyst fired. Having about as much
backbone as a lot of the middle managers I’ve known, this guy caved. I actually
heard him tell my project manager to make a decision about the analyst. The
middle manager acknowledged the fact that, because my boss was the project
manager, it was of course his decision one way or the other. However, he fol-
lowed up by saying that if my boss didn’t make the right decision he’d make it
for him. And so, my project manager had the unenviable task of firing some-
one who was both a friend and had done nothing wrong beyond being politi-
cally inconvenient. And so, he was fired. Why? Pure politics. The corporate
world is full of such tales. You don’t want to be one of them.
Picking Your Battles
The art of self-defense is a complex one with many facets. One thing that
might be learned from my previous example is that there are many battles
Chapter 11 Corporate Self-Defense
177

that can be fought every single day. However, fighting them all isn’t always a
good idea. There are no actions without consequences. Part of staying alive
in the sometimes dangerous political environment of the business world is
knowing when to fight, when to run, and when to just keep your mouth shut.
The enemy rarely shoots just for the fun of it. That wastes ammunition. They
shoot when they have a target, and the more noise you make, the better target
you are.
Programmers are fiery and temperamental artists. When you’re talking
about software and how to write it, it’s something we take personally. Conse-
quently, it’s easy to get all worked up about something and find yourself in the
middle of a big blowout because you feel strongly about an issue. Whether it’s
a matter of design, how something should be coded, or even which brand of
soft drinks should be stocked in the kitchen, you may be tempted to argue and
fight passionately with everything you have. In fact, the issues are truly that
important at times. However, they aren’t always critical. Any time you fight for
something, you stand to win or lose. If you lose, it could really cost you. The
first question you should ask yourself is a simple one: is it worth it? If it’s not,
let it go. Save your bullets not for the skirmish, but for the invasion.
It isn’t always obvious what you stand to lose in any given confrontation.
Those who practice judo make very effective use of a simple characteristic of
human nature. When you push against someone, they instinctively push back.
Say the judo instructor wants to throw you in a southerly direction. He will
first push you north. You will, of course, resist and push in the opposite direc-
tion with all your might, at which point, the instructor smiles and simply helps
you throw yourself south. Hope you learned how to tumble. Those carpeted
hallways are never as soft as they look.
In a similar fashion, when you take a stand on an issue and push hard for
things to be done your way, others will instinctively push against you as hard as
they can. Under normal circumstances, these very same people might not have
been inclined to work against you at all. However, this is the way people react
when they’re threatened. In the end, you may lose much more than you
thought possible simply because of a strong backlash. In effect, you created
that backlash yourself.
Another problem with fighting every fight that comes your way is reputa-
tion. Eventually, people tire of one who is always confrontational and will
look for ways to neutralize or eliminate him. In the case of the analyst, this is
exactly what happened. If he had fought fewer battles, he wouldn’t have gar-
nered such intense animosity that an entire department conspired to get rid of
him. This doesn’t mean that he was wrong when he stood up for an issue, but
in the end, it just didn’t matter. Not only does it bite to lose your job, once
you’re fired, you can’t accomplish anything else that you were trying to achieve
there. Management takes a dim view of ex-employees showing up for design
meetings. Security isn’t real big on the matter, either. It interferes with the
donut breaks.
Consequently, before you stand up in your next meeting and arm yourself
with a few whiteboard erasers, stop and consider the importance of the issue
178
Part II Guerilla Tactics for Front-line Programmers

at hand in the grand scheme of things. Start by looking at the basics. Does a
change in the project affect the amount of hours you have to work, the amount
of money you make, the quality of your day-to-day life on the job, or your
overall value on the job market? This is our livelihood, and these are the real
issues. If you’re about to push for something that will undoubtedly make a big
stink, you need to ask these questions. If none of them come up in the affir-
mative, then sit down and be quiet. And put those erasers back where you
found them.
Sometimes, however, the issues are truly important. If so, how major is the
matter at hand? Is it something worth changing jobs over? If so, make sure
that you’re prepared to do so before engaging in the fight. This means that you
need to have already quietly updated your résumé. You should also have taken
a good look at the job market and your personal finances. How long will it take
you to find another job? Do you have offers already? If not, how long can you
go without income before you have to start ordering your pizzas without extra
pepperoni? These are the practical considerations that you need to have in
mind when you’re ready to go to the mat over something.
If you’re not willing to quit your job over the matter, how good are your
chances of winning the fight? If it gets tough and you lose, is it something that
could cost you your job? If so, you need to weigh the risks against the benefits.
Again, is it worth it? However, even if your chances for success are good, how
many people will you alienate in the process? There’s almost always some
hard feelings after a major battle. If you make people angry in the process of
getting your way, are they significant enough to cause you trouble later on?
Remember, just because you win a decision in a meeting doesn’t mean that
your adversaries disappear. They still work at the same company, and people
hold grudges. Depending on how ugly the confrontation got, you may have
created some enemies that will be working against you for some time to come,
just out of spite. No, that’s not very professional, but people are people. To
expect them to be otherwise makes about as much sense as starving a lion for
a week and then sticking your head into his mouth.
Be aware of the fact that with every battle you fight, you may create your
own adversaries. Some will be powerful and some will not. Even if you alien-
ate only the peasants, though, be sparing in your battles. If you slam-dunk
enough people, it’s eventually going to make you look bad, and that will catch
up to you. Image notwithstanding, though, even those with little power in the
company can still nail you. It’s like that town square full of angry villagers with
the pitchforks and torches. Individually they may not be very powerful, but as
a group, it’s a scary thing to see.
If your chances of winning are low and it’s also not worth quitting your job
over, there’s only one path to take: get over it. If you feel particularly strong
about the matter, perhaps it would be a good time to take some of your vaca-
tion days and come back when you have a better attitude. Conceding a point
doesn’t count if you sulk about it. That just irritates people. Remember the
pitchforks.
Chapter 11 Corporate Self-Defense
179

In general, the best approach is to not only choose carefully the issues
that you think are worth fighting for, but also to be prudent in your approach.
Although there are times for overwhelming firepower, in general, you’ll ruffle
fewer feathers if you use no more force than is absolutely necessary to get your
point across convincingly. In short, be a gentleman about it. When you do win,
do so graciously and don’t rub it in. People aren’t always happy when things
don’t go their way, but they can shake it off pretty quickly if the winner is nice
about it. Again, style counts. The people you argue with today may be your
allies tomorrow.
Avoid Being a Target
What we’ve discussed thus far is in fact a way to avoid having your peers use
you for target practice. Choosing to not fight every battle that comes along is
simply one way of maintaining a low profile. The obvious advantage, of course,
is that the less of a profile you present, the less they have to shoot at. There
are other things that you can do as well to keep those red concentric circles
off of your posterior.
One very good rule to live by is to never put anything in writing that you
wouldn’t want broadcast worldwide on the evening news. Email is particularly
dangerous. It’s true that, if I snail mail a letter to someone, they can give it to a
friend or read it aloud at the next bridge party, but that takes effort. Further-
more, there’s only one letter, so, unless they feel like making photocopies, they
lose the original if they give it to someone. Not so with email. With the simple
click of a mouse, what you thought you told someone in confidence is sud-
denly broadcast to everyone on the company mailing list. Of course, it’s rarely
done to that extreme, but you’d probably be surprised and more than a little
uncomfortable if you knew how often your email was silently forwarded to
someone else. The truth of the matter is that you simply don’t know where it’s
going to end up. Few things are as embarrassing as the public surfacing of an
email in which you’re insulting someone in your very own words.
As a techie, however, you already know that this is just the simple and
straightforward part of it. Email is nothing more than fancy text files that get
passed around from computer to computer until they land at their intended
destination. Anyone with an administrative password and an agenda of their
own can read every email in the entire company. I’ve actually had people tell
me on sensitive matters to email them at their home address rather than the
office because they’ve witnessed this sort of thing. Absolutely nothing you
send in an email is private. If you need it to be so, take a walk and have a con-
versation. Otherwise, you’re just making yourself vulnerable.
Furthermore, if you think that you might change your mind about an issue
at some point in the future, don’t put it in writing at all. Whether it’s a word
processor document, a scribbled note, an email message, or any other such
thing, once you put it in writing, it’s in a physical form that you cannot
180
Part II Guerilla Tactics for Front-line Programmers

completely control. This may sound a little cloak-and-dagger to you, but I’m
sure that there have been times when you needed to discuss sensitive topics at
work and the breaking of that confidence would have had unpleasant conse-
quences. It’s simply a matter of avoiding potential trouble. The fewer holes
you have in your defenses, the fewer attacks that will get through.
You may be reading all of this and thinking to yourself that you simply
don’t have any political skills to begin with. This may be true. Not everyone
possesses the instincts necessary to play the game effectively, and there are no
guarantees even to those who do. However, you do have a good set of eyes and
some perceptive abilities. If you don’t have political skills, do your best to keep
a low profile around the potential troublemakers who do. They’re easy to spot.
You could probably make a list of all the ones in your company right now.
Furthermore, align yourself with as many people as you can who have more
maneuvering abilities than you do, assuming that they have some common
sense as well. The combination of not sticking your head up for someone to
shoot at and running with a pack that’s capable of defending themselves will
reduce your vulnerabilities tremendously.
As I discovered many years ago, choosing to not participate doesn’t get you
out of the game. It only makes you a target that doesn’t shoot back. Whether
you have no talent for politics or you simply don’t think that you should have
to deal with these things, if you don’t find ways of keeping yourself safe that
work for you and practice them continually, you’re going to find yourself con-
tinually under fire. I freely acknowledge that if you get hired as a programmer,
you shouldn’t have to do anything but focus on programming. However, the
reality is that you’re in the game whether you like it or not. How you fare is up
to you. Personally, I hate losing.
Assessing the Lay of the Land
One of the simplest and most effective techniques that you can employ to
keep your tookus out of a sling is to just pay attention. Be aware of the political
landscape at every level you can, from your small corner of the world to as far
up the food chain as you can see. Ask yourself the following questions:
 Who has the power?
 Who are the followers? 
 Who is loyal? 
 Who is opportunistic? 
 Who has integrity? 
 Who is out for themselves regardless of the cost to others?
 Who is fighting the good fight? 
Chapter 11 Corporate Self-Defense
181

 Who is causing problems? 
 Who’s winning? 
 Who’s losing?
 What’s changing?
The answers to these simple queries will tell you much about where you
should be and whom you should avoid. One of the best self-defense tech-
niques I’ve ever heard of was a man who said that he could smell trouble three
weeks away and be out of town before it got here. If you can identify who the
aggressive and manipulative players are, then you’ll see trouble before it gets
to you.
Equally important, just like meerkats on the prairie, you should poke your
head up every now and then so that you always know which way the wind is
blowing. Management comes and goes, and projects come and go. The way
things are done today may not be the way they’ll be done tomorrow. Maybe
that’s a good thing, and maybe it’s not. In any event, if you pay attention to the
overall trends of how your company is run, you’ll be in a position to either cap-
italize on change when it happens or have the foresight to put your résumé on
the streets long before anyone else figures out that their job is a disaster waiting
to happen. This doesn’t require political savvy. You just have to pay attention.
Escape and Evade
Periodically, you’ll find yourself cornered by someone pressing you to endorse
their position or to take some action on their behalf. This can be a real prob-
lem if it’s someone who’s higher up the food chain than you are, particularly
if what they’re selling is something you wish to avoid. On the one hand, you
could be pressured into committing to a task or an opinion that will cause you
problems. Refusing, however, could create an adversary who may try to find
ways to take it out on you later. The best thing you can do in these situations is
find a way to be someplace else.
You can actually accomplish this in a number of ways that require very lit-
tle assertiveness on your part. Essentially, you simply look for the first oppor-
tunity to politely excuse yourself. Apologize for having to cut them short and
then explain (as you start walking away) that you have to go to the restroom
and it simply won’t wait. This isn’t a terribly elegant solution, but it’s an effec-
tive one. Social etiquette demands that they not impede your journey. Then
make sure you go directly to the facilities. If they follow you, find a stall and
close the door. Eventually they’ll get tired of waiting and go away.
Of course, you can substitute other scenarios. You can claim that you have
to get to a meeting right away, that you are expecting a phone call, have to
return one, are late for a lunch appointment, and so on. However, whatever
182
Part II Guerilla Tactics for Front-line Programmers

excuse you offer, make sure it’s something that can’t wait. And make certain
they never see that it’s otherwise. No one likes having the wool pulled over
their eyes.
If You Must Attack
It’s often said that the best defense is a good offense, but I disagree. Although
a good offense can certainly be an effective tactic, I believe that the best
defense is simply being somewhere else when the bullets fly. If you’re not
there, you don’t get hurt. That being said, there are certainly times, whether
it’s a routine design meeting or a struggle to keep your project from being can-
celed, when you must go on the offensive to protect your position. If you’re
going to take a swing at someone else’s position, there are a number of things
you can do to increase your chances for success while minimizing your risks.
First and foremost, know your strengths and your weaknesses. If an issue
must be pushed, but you’re not assertive by nature, arrange for a coworker
who is more persuasive than you to do the fighting, with you working in a sup-
portive role. This doesn’t mean that you just put the work off on them. You
can plan, prepare, detail the arguments, write the documents, prepare the
slideshows, brainstorm with your partner, and so forth. You just let them do
the talking because they’re better at it. A good partnership with each person
utilizing the best of what they bring to the party makes for a formidable pres-
entation. Conversely, if you talk a good line but are a little weak on preparation
and detail, find an ally who can help you in this area. In general, be frank and
honest with yourself about where your talents and deficiencies lie. If you can
do that, you’ll know how to shore up your defenses and you’ll be way ahead of
the game.
Knowing what to expect out of people is also important. If your expecta-
tions are unrealistic, you’ll get acquainted with reality at the most inconvenient
moment. One good example of this has to do with the herd instinct. Never
assume that someone will come to your rescue in a meeting. They never do.
Be prepared to stand on your own.
In a similar fashion, never assume that silence or the nodding of heads at a
meeting means that everyone agrees with you. Often, they will say yes, only to
strike behind your back the next day. Don’t let this take you by surprise. To a
certain degree, you’ll have to learn to trust your gut instincts. Any time that
something seems too easy to be true, it is. If you expected significant resist-
ance to an idea but encounter only nodding heads and tacit agreement, you
can bet that something’s up. Work on that assumption, and you’ll be much less
likely to get blindsided.
Also never assume that the people who said they would support you in a
meeting actually will. Be prepared and have a plan ready should they all just
remain silent and stare at their shoes when it’s time to back you up. It’s amaz-
ing how fascinating shoes can be. If you find yourself on the losing end of a
Chapter 11 Corporate Self-Defense
183

heated debate, and you know that several other people in the room share the
same convictions as you, don’t be surprised to find them avoiding eye contact
with you. They may have been behind you one hundred percent before the
meeting, and they may indeed grumble with you about the outcome after-
wards, but, if you expect them to stick out their own necks in the meeting
when you’re taking heavy fire, you’re in for an unpleasant surprise. When you
get right down to it, people are typically much more concerned about saving
their own skin. However, if you’re prepared for this going in, you’ll have
thought of some alternate strategies to fall back on if things don’t go your
way. That’s what’s important.
No matter how technically correct you are, if you don’t evaluate the politi-
cal dynamics of what you’re about to propose, you could stir up a hornet’s nest
that you never saw. For example, you may point out a flaw in the way orders
are processed in a meeting that has your boss and his superior in attendance.
Although you did so to propose a solution, your boss’s manager interprets it as
a major mistake on the part of your project manager and proceeds to slice and
dice him in front of the entire meeting. Little wonder, then, that the next day
you find that, instead of working on that cool little database project you had in
mind, you find yourself relegated to scraping gum off the bottoms of chairs.
And you thought your boss had no sense of humor.
Remember, there are no actions without consequences. Whatever ideas
you propose, whatever issues or problems you raise, make sure that you have
first evaluated every possible political ramification that you can. Who is in
attendance? Do they have an agenda with which this would conflict? Are any
egos at stake? Will there be competition for who gets control of the idea?
Does this make anyone look bad? These are just a few of the questions that
you should train yourself to ask instinctively before you set upon a course of
action. It may seem a bit paralyzing to you at first, but you’ll be surprised at
how quickly this becomes instinctive. It’s worth noting that, in the wild, the
critters with the best instincts are typically the ones who survive, even if it’s
just playing possum.
It’s also worth evaluating the consequences of both winning and losing.
Although it’s easy to work your way through the various disaster scenarios that
accompany losing, it’s just as important to think through the chain of events
that winning will set into motion. In addition to concern for the egos of others,
keep the domino effect in mind. For instance, you may have proposed that
reporting would be much easier if someone would write a print library to han-
dle all of the commonly used formatting issues. This would allow the person
writing the report to simply make a few function calls and be done. Because
you’re the one tasked with writing the reports, this will no doubt seem like a
very good idea. Everyone else in the room argues against it. However, after a
persuasive presentation and to your utter delight, your project manager agrees
with you. In fact, because you have such a good grasp of the matter, he assigns
the task of writing the print library to you. Of course, your deadlines for the
reports don’t change. But you won, right? It’s impossible to foresee every pos-
sible outcome. However, it’s even less possible if you don’t try.
184
Part II Guerilla Tactics for Front-line Programmers

Regardless of what you’re proposing, always do your research on the
opposing points of view. Find your opponents’ strengths and weaknesses, who
will support them and who won’t, how much weight that support has, and so
on. If you’ve thought things through thoroughly, you’re in an excellent position
to rebut any arguments that they are likely to make in the meeting. However,
this doesn’t just apply to the strengths and weaknesses of their argument. Do
your best to discern the temperament of the opposition as well. What are their
hot buttons? Are they emotional? As such, if you can get them to react emo-
tionally, will it throw them off balance or make their position look weaker?
Are they stronger in abstract concepts? Then hit hard on the details. Are they
better at details than grasping the conceptual? Then emphasize the big pic-
ture. Everyone has weaknesses. Learning where they are tells you exactly
where to hit.
Another thing to keep in mind is your own credibility with those who mat-
ter. It doesn’t make a bit of difference that your idea is completely bulletproof.
If your credibility is not sufficient in the eyes of those who make the decisions,
you’re going to be dismissed with little attention given to your issues. That can
also put you in an embarrassing or precarious situation. Don’t start something
that you’ll later regret. If you don’t have the horsepower, don’t have the meet-
ing. Instead, take some time and build an alliance with those who do. When
you finally do make your presentation, allow the focus to drift away from you
and onto the people who can get the job done. It may not be as good for the
ego, but it’ll be much more effective in terms of achieving your aims.
Just as you looked for weaknesses in your opposition, give the same attention
to your own. Be prepared with defenses to any perceived weaknesses. Think of
how you would attack the argument if you were on the other side, and then
close that window. If there truly is a real vulnerability in your position, you can
choose to abandon the proposal or try to make it fly regardless. If you do plan
to go ahead, make sure you have an answer of some sort prepared, and then
quickly try to change the subject after you use it. Sometimes you’ll get away
with it.
Never underestimate the value of overwhelming firepower. If you can win
by just minor rebuttals or dazzling a little, that’s all good and fine. However, if
it’s a battle you simply cannot afford to lose, it’s best to just come out with both
guns blazing. If you’re well prepared to shoot down every single opposing view
in your opening volley, the room will simply rustle nervously and take a step or
two back, and you’ll save a lot of time from arguments that just won’t happen.
Improving Your Skills
You’d be quick to buy a book on the latest coding technique. However, very
few people spend anywhere near the same amount of time or effort sharpening
their self-defense skills. A wealth of literature is available in every bookstore
covering negotiation, proposals, politics, and the many paths to achieving
Chapter 11 Corporate Self-Defense
185

success in business. Don’t dismiss the book just because the guy’s wearing a
three-piece suit or isn’t speaking specifically about programming. You’re a pro-
grammer, true, but you’re a programmer who lives in the corporate world. It
only makes sense, then, to read books that relate to the business environment.
In fact, some of them may be less obvious than others. Many people the world
over understand the adage that business is war. Consequently, you’ll find that
they study some of the classic books on warfare and military strategy and apply
those concepts to the daily struggles faced by people in the business world.
All of this nontechnical stuff may seem like a waste of time when you’d
rather be coding, but if you pay attention to these details, you’ll find that your
days are disrupted much less by the maneuverings of others. When your
defenses are strong and none dare attack you, that’s when you can sit back
undisturbed and enjoy moments of pure coding bliss.
186
Part II Guerilla Tactics for Front-line Programmers

BUILDING A BETTER
CAREER
III
P
A
R
T

One of the great things about being a techie is the wide variety of options
available when it comes to making a living. Consequently, the considerations
of choosing the best career path for your personal preferences and learning to
control that journey are just as important as knowing when the compiler is
making fun of you. 
Unlike those who pursue more traditional vocations, programmers are
probably as likely to be self-taught as they are to have college degrees.
Programming is one of the rare careers in which ability is often more impor-
tant than pedigree. (Don’t mention that to our faithful watchdog, however.
He’s rather proud of his.) Nonetheless, although attorneys and accountants
would have a hard time finding a job without the appropriate certificates, many
of us started our professional lives as little more than enthusiastic hobbyists.
Only later did the notion strike us that we could actually get paid for this stuff,
and college may or may not have followed that realization. Consequently, the
time eventually comes when developers, whether degreed or bootstrapped, set
off in search of gainful employment using the skills that have become their
passion.
For many, that exciting first job search was a rather unstructured affair,
with little thought given to anything beyond getting a paycheck for writing
code. It often involved simply grabbing the newspaper and applying for every
opportunity for which your skills were even a remote match. When asked what
we were looking for by our friends, the answer was simple: a job. Nothing
more, nothing less.
However, as most of us now know only too well, working as a professional
software developer involves a tremendous number of variables. A program-
ming job can range from Utopia to Hades, and sometimes both in the same
day. Even though a lot of folks out there went to school, had a long-term
career plan, and were in general quite organized and forward-thinking, many
of us didn’t have the slightest idea what we were getting ourselves into. For
that matter, the guys with the career plan probably didn’t either, but at least
they had some goals.
189
Controlling Your Destiny
12
C
H
A
P
T
E
R

As with most anything in life, it’s hard to achieve your dreams if you don’t
know what they are. Quick, grab a piece of paper and write down all the
details of the perfect job. As you look over your shoulder, you probably won’t
be too surprised to find that some of the newer guys have written down only a
couple of things before stopping. The ones back in the corner frantically wear-
ing out their pencils are the seasoned old dogs who have been in the business
long enough to have a better idea of what they want. For the most part, they
learned the hard way. Take a peek at their lists, and you’ll likely find that the
majority of lines involve things they’d like to avoid in the perfect job. A few
years in the corporate world does that to you.
Although most of you may well have a job at present, we’ve all been doing
this long enough to know that the tides of technology turn quickly. The job
that’s here today may be gone tomorrow. Even more likely, the job that’s fun
today may well turn into something about as exciting as working in a dog bis-
cuit factory. Although that may be enticing to some of the staff here, in gen-
eral, it’s sufficient to say that in our line of work, looking for a job is often just
a part of the job. However, as those of you who have been around for a while
know all too well, the employment landscape has changed quite a bit since the
exciting times of the early PCs or the heady days of the dot-com boom. To
ensure continued success in the programming field, you’re going to have to
come to terms with the latest wrinkles in our imperfect world.
Considering Your Options
If you make your living as a programmer, or have intentions of entering the
field, you have some decisions to make about which direction to take your
career. Three primary choices present themselves. The most obvious of these
is to continue on your current path of coding for a living, and dealing with the
process of getting a new job when the need arises.
As we all know, getting hired is not as easy as it used to be, which will
make many of you rethink your overall career path. Without a doubt, it’s fun to
develop software. However, it’s even more fun to get paid on a regular basis.
Because of this, a second option to consider for those of you who can’t bear to
leave the software industry is to change the flight path of your career. Although
coding is what lured many of us into the corporate world, a host of other posi-
tions are available in the software development industry. For some, the best
way to stay gainfully employed is to shift into a different job description,
whether that’s a move into management or a lateral shift into other related
technical areas.
The third option, unthinkable as it may be to some, is to simply get the
heck out of tech. The global nature of the industry, and the effect it has on our
employment, isn’t likely to change anytime soon. If you’ve become accustomed
190
Part III Building a Better Career

to a comfortable standard of living and wish to continue receiving that kind of
income, your best bet may simply be to abandon a sinking ship and move into
a different career where the supply for talent doesn’t exceed the demand. 
If you hold in low regard the rats who scurry down the deck and dive to
safety, those rats would be quick to remind you that dead rats tell no tales. Of
course, the small, hairless canines who are often uncharitably compared to the
rodent family might tend to bristle just a bit at that comparison, so perhaps
we should just leave well enough alone. Nonetheless, regardless of your view
regarding rodents and structurally unsound vessels, the simple reality remains.
You may have difficulty maintaining your preferred lifestyle in the software
industry, so you’ll need to decide whether coding or income is more important
to you.
There is no right or wrong answer to this consideration. For many people,
programming is a passion no less intense or artistic in nature than that of a
musician, painter, dancer, or any other creative creature. History is replete
with examples of those willing to suffer for their art. If you consider software
to be more art than science, and you’re more concerned with what you do for
a living than how much money you make, stay in the business. You may find
yourself unemployed from time to time, and your income may drop to lower
levels than you’ve experienced in the past, but if your heart says code, then fol-
low your heart. I personally spent many years as a professional musician in my
younger days, which involved sleeping on floors and eating a lot of boxed mac-
aroni and cheese. Even so, I enjoyed the life because performing was my pas-
sion. I made my exit as a career musician when the tides of music changed
and I found I wasn’t having as much fun doing it as I once did. So, if coding is
more important than income, go for it. Just be practical enough to know what
the realities of the industry are, and position yourself accordingly.
For those of you who see now as a good time to make your escape from
tech, I recommend wherever possible finding a new passion in life before
making the change. I’ve had a number of careers in my life, and it’s been my
extreme good fortune to pay the bills pursuing things I truly enjoyed. As a
musician who had to work more than a few day gigs (the industry term for
non-musical employment, such as waiting tables, to pay the bills), I can tell
you with confidence that life sucks when you hate your job. Tech careers are
unstable at present, but if you have the ability to continue on as a programmer
until you discover and pursue a new passion, by all means, take your time and
make the right decision. One of the truly cool things about being a career pro-
grammer is that we get paid to play. If you’re getting out of the business, find
another way to play that pays well. 
No matter which choice you make, however, unless you decide to open
your own business, which is yet another option, you’re faced with three basic
choices: get another job as a programmer, pursue a different type of tech job
such as management, or get out of the business entirely. We’ll explore each of
these career paths in depth in the upcoming chapters. Before we do, let’s take
a quick peek at some of the more common choices.
Chapter 12 Controlling Your Destiny
191

The Company Man
Working as an employee is probably the most familiar approach to the major-
ity of us, and choosing this road has a number of positive aspects. Salaried
employees get paychecks that come on a regular basis and are for a predictable
amount. Having spent many years doing more entrepreneurial things, I can’t
tell you how exciting it can be to know every month just exactly how much
money you’re going to make. It does wonders for the budgetary planning and
keeps the antacid bills low as well.
In addition to the stability of income, being a company man has additional
financial advantages. First among these are the tax benefits. For openers, an
employer will withhold your taxes for you so that you don’t have to worry
about how you’re going to come up with the money at the end of the year. You
may think that this is no big deal because we’re all obviously smart enough to
save some money for taxes each month instead of spending it, but having all
that extra cash available can be a mighty temptation. If you’ve ever had any
extended adventures with the Internal Revenue Service, you’ll be more moti-
vated than most to avoid any such encounters in the future. Even though
we’re certainly capable of managing our own tax money, having it out of sight
and out of mind is a definite benefit.
That’s not the only tax benefit, however. Without getting into all the fine
details of the federal tax code, when you work as an employee, there are addi-
tional taxes that you don’t have to pay because your company does it for you,
typically in the area of additional social security and unemployment taxes. This
isn’t out of the kindness of their heart, of course. It’s federal law. Still, the per-
son who benefits is you, for at the end of the year, it’s money you didn’t have to
pay out of your own pocket.
Additional financial benefits are available to employees in the form of paid
or copaid medical insurance, sick days, vacation days, stock options, and a
good many other options that businesses offer to entice the better-quality pro-
grammers to set up camp at their place. Regular jobs have a number of non-
cash benefits as well, and these can range from company cars and continuing
education programs to seemingly little things like reserved parking and an
office with a door.
Beyond compensation, life as a full-time employee has a number of intan-
gible benefits. The first and most often cited is job security. Of course, anyone
who has been working for more than a couple of months can tell you that, to a
large degree, job security in the technology business is an illusion. Full-time
employees are not immune to layoffs when times are hard or projects get can-
celed. However, in a company that hires contractors and permanent employ-
ees alike, the contractors are typically the first to go. Many companies will also
go to a fair degree of trouble to take care of their employees and make job cuts
the very last option. So, even though nothing in this business is guaranteed,
employees do have a more secure position than others in the industry.
192
Part III Building a Better Career

Another thing that many people prefer about working for the same com-
pany for many years is, well, working for the same company for many years.
Not everyone is comfortable with interviewing or looking for a job. People
who work as contractors accept frequent job changes as a part of their lifestyle.
However, that’s not for everyone, and if you’re someone who enjoys keeping
a little consistency in your life, there are definite advantages to life as an
employee.
For the ambitious, there’s also the opportunity to advance your career and
move up through the ranks. Although most programmers prefer to write code
and just be left alone, some enjoy working in management. Staying at the
same company for any significant amount of time also gives you the chance to
consider altogether different avenues. Some who code actually enjoy testing,
and some find that they prefer firing up a word processor and writing technical
manuals. You didn’t hear this from me, but some even gravitate toward market-
ing. All in all, life as a company man offers many options and advantages.
It’s not a complete bed of roses, however. For some, exposure to company
politics—a requirement for climbing up the food chain—is an extremely
unpleasant prospect. If you have a long-term job with a company, then you
have a career path to protect. That can take a bit of maintenance from time to
time, depending on the level of corporate insanity prevalent in your place of
business.
Money is another area in which the employee typically doesn’t come out
ahead. Those who work as hourly contractors make a significantly greater
wage, assuming they work all through the year. Although contractors don’t get
all of the benefits and perks of an employee, the full-time employee is the
lowest on the overall pay scale in terms of annual bank deposits.
However, probably the biggest disadvantage to being a salaried employee
is the fact that, by definition, you’re not paid by the hour. The predictability of
paychecks is certainly a consideration, but employees are all too often exposed
to significant amounts of unpaid overtime. This is true of salaried employees
everywhere, but overtime is legendary in the deadline-driven world of the
professional programmer. Furthermore, because they don’t have to pay you
anything extra for your time, many companies are all too eager to abuse this
aspect of the arrangement. A sweatshop by any other name is still an unpleas-
ant experience.
Like any other aspect of the business world then, working as a salaried
employee has both positive and negative aspects. Just as it’s true in program-
ming, choosing a career path is an exercise in tradeoffs, and no one size fits all.
So, to have as many options to choose from as we can, let’s look at our next
contestant, the hired gun.
Chapter 12 Controlling Your Destiny
193

The Mercenary
Another thing that sets the software development business apart from other
professional pursuits is the hiring of temporary workers. Although program-
ming is certainly not the only aspect of the business world that hires in this
manner, you’re less likely to find hired guns in a biscuit factory. One of the
first things that sets contract programmers apart from employees is the fact
that they are paid by the hour, typically at a rate much higher than what the
employees make. In a sane and controlled development environment (I’ve
read about them in the trade magazines, so I’m sure they must exist some-
where), contractors work forty hours a week like everyone else and are paid
accordingly. However, when the overtime hits the fan, contractors are paid for
every hour that they work. If it’s crunch time and everyone on the team is put-
ting in eighty hours a week, the contractor has the additional motivation of
knowing that it will be a good month financially.
Of course, working hourly cuts both ways. Contractors are not paid for
time off due to illness, nor do they get holiday or vacation pay. If you have to
take your dog to the vet, it’ll cost you much more than the price of those little
doggie antibiotics. You’ll lose a day’s pay as well, and that adds up in a hurry.
Fortunately for all concerned, the night watchman is on salary. Actually, so is
his trusty attack Chihuahua. You didn’t think he got those camouflage collars
for free now, did you? 
There’s also another thing to consider when thinking about living out of a
briefcase. In some companies, contractors are decidedly treated like second-
class citizens. They’re herded two and three at a time into cubicles scarcely
big enough for one and given the old hardware that no one else wanted. Don’t
even ask about the chances of getting a stapler. I once worked for a large
financially oriented corporation as a mercenary. One day, I went to the supply
person to request a stapler. I was informed that staplers were capital expendi-
tures and consequently something to which contractors were not entitled. To
this day, I’m still not entirely sure what that means, other than the fact that I
had to become adept at slipping in and out of cubicles to surreptitiously fasten
a couple of sheets of paper together before meetings.
In addition to the overall company culture and how they treat contractors,
be prepared for a fair degree of resentment by the regulars. Anyone who has
been around for a while has a good idea of the hourly rates that contractors
make. Some employees are highly offended by the fact that they dedicate their
lives to the company and yet some outsider comes in, writes the same code,
and gets paid quite a bit more. Having worked as both an employee and a con-
tractor, I can see both sides of that sentiment. Although it’s true that, at the
end of the day, both may produce the same work and one is paid more, at
the end of the year, one may have a job and the other may not. Reward often
comes to those willing to accept the risks. I must also say that I’ve never had
much patience for that kind of attitude because each person is free to make
his own career decisions. The disgruntled employee could probably be
194
Part III Building a Better Career

working next week as a contractor for the same money as the person he’s
offended by, but some people would rather whine than take action. If it
weren’t the contractors, they’d just find something else to be unhappy about.
Having said this, I must say in fairness that the overwhelming majority of
contracts I’ve worked were in environments where I was just another guy on
the team. We all went to lunch together, we all worked the overtime together,
and we all participated equally in the design meetings. The only distinction
between the employees and me was on payday, a matter I tend to keep to
myself no matter how I’m working. Well, the other distinction is that they’re
still working there, and I’m not. Sometimes that’s a good thing; sometimes it’s
a bad thing. Overall, I’ve had both good and bad experiences as a contractor in
about the same proportion as my experiences as an employee. A gig is a gig.
Of course, for some contractors, the fact that they don’t have a career path
to maintain at a given company is an advantage in and of itself. When all the
petty power struggles kick in, the contractors just go out to lunch. There’s no
need to grapple over promotions or keep up with the latest company gossip.
They’re only there to get the job done, and that can be liberating. This is not
to say that the life of a mercenary is one completely devoid of politics and cor-
porate maneuvering. Far from it. It’s just that all the nonsense one deals with
as a contractor (and there’s plenty to go around) has to do with the actual proj-
ect itself, not the bobbing and weaving that some indulge in to get that juicy
promotion.
Although it’s my firm conviction that anyone who’s unwilling to pull the
occasional all-nighter at deadline time should get out of the business fast, I
also enjoy one of the other benefits of being a merc: if companies have to pay
you for every hour that you work, they tend to think twice about demanding a
lot of overtime. I’m still passionate about programming, but I also have other
things going on in my life. I have no desire to participate in a software death
march on a regular basis. There are too many other things in life to do. No one
lies on their deathbed and wishes that they’d spent more time at the office. I
don’t know who originally said that, but I sure do try to live by it. In fairness,
I’ll freely admit that I’ve sometimes made it a point to get my job done and be
out of the office in eight hours so that I could then go home and code all night
on some other pet project. That doesn’t matter. The point is that I need time
for the other activities in my life. Consequently, minimizing overtime, even
though I could get paid for it, is a benefit to me.
Another nice thing about living the life of a gypsy programmer is the chance
to work in a lot of different shops with a lot of different technologies. On top
of that, you continually meet new programmers. Most of the cool stuff I’ve
learned over the years has been due to hanging out with some really gifted
developers. Of course, that’s also where I learned how to dodge whiteboard
erasers. There are tradeoffs for everything.
Contractors, of course, don’t have even the illusion of job security. If you
read the contracts you sign (and I hope you do), you’ll notice that the rules are
fairly simple: you must give two weeks’ notice, and the client can fire you with
no notice whatsoever. I haven’t encountered such an extreme in my mercenary
Chapter 12 Controlling Your Destiny
195

life, but it’s part of the game, and you have to be prepared for it. This means
that you also have to be comfortable with looking for a job and doing the inter-
view dance. Some handle this better than others.
A final wrinkle in the life of itinerant programmers centers on exactly how
they get paid. There are a couple of different approaches. By far, the most
common involves working as an hourly employee of a recruiting company.
Although you report to work at the office of the company’s client, you’re an
employee of the recruiting company itself, and your taxes are withheld just as
they would be if you were with a permanent employer. This keeps your life
nice and simple, and again helps avoid those unsightly tax bills at the end of
the year.
However, as a contractor, many companies will also let you work as an
independent company. It may require that you incorporate, but in general, the
idea is that you then get your entire hourly rate paid directly to you. Your tax
deductions and every other aspect of running your company are your own
affair. Some people have enough tax deductions and expenses overall, along
with the requisite business skills, to make this a preferable situation. I’ve also
seen people get in deep with the tax man at year’s end because they lacked the
financial discipline needed to save money for taxes and make the quarterly
payments. That’s someplace you just don’t want to be.
Regardless of which way you get paid, working for a recruiting company
has another reality. The hourly rate that the client gets billed is not the hourly
rate that you get paid. The recruiting company gets a cut. It’s easy to spot the
rookie contractors. These are the guys who find out for the first time just what
margin their recruiting firm is making and go ballistic. You’ll hear them go on
to no end with tremendous righteous indignation about how they’re doing all
the work while the recruiter gets paid for every hour doing nothing more than
sitting back and drinking coffee. I very often want to make a fairly pointed
reply to such tirades, but discretion typically gets the better of me. Here’s how
it really works.
First and foremost, yes, your recruiter gets a piece of the action. If you’re
not happy with the hourly rate that you bargained for when you took the job,
then you shouldn’t have taken it to begin with. No one forced you, and the
offer of money was yours to negotiate, accept, or refuse. Personally, I bargain
hard. However, when I take a job, it’s because I’m happy with what I’m getting
paid. I don’t accept it otherwise. If I find out later that someone else makes
more than me, or that the recruiter got a particularly big chunk of the money,
who cares? I was happy with what I had before I got that information. I’m still
happy.
The second point has to do with what recruiting companies do to “earn”
their share, seeing how we do all the coding. I could go out and shake the
trees myself when I’m looking for work, but I’ve run businesses before in my
life and I know just exactly how much work marketing can be. No thanks. I
live in a major city with a lot of recruiters. I just pick up the phone and let
them beat their brains out trying to find a good fit for me. Above and beyond
the amount of effort involved in doing that, recruiting companies provide me
196
Part III Building a Better Career

with a couple of very tangible financial benefits. First, the amount of money
the company pays in taxes for me, as does any company in an employer-
employee relationship, is significant. If I went into business for myself, that
would be money out of my pocket. In simple terms, that works out to a non-
trivial number of dollars per hour, and it comes out of their cut, not mine.
Additionally, they handle billing and collections. As I mentioned, I’ve run
businesses before and consequently know the joys of trying to hammer money
out of a deadbeat customer who’s 120 days late on an invoice. It’s a real stress-
inducer, particularly when you’re counting on that money to pay your own
pressing bills. The recruiting company protects me from that. I get paid every
couple of weeks no matter what happens between the recruiter and the client.
In fact, I was once on contract working for a fairly big company and through
my relationship with some of the recruiting staff learned that the client was
over six months late on paying a little over $500,000. And yet, I got paid every
payday, direct deposit, with no fuss and no worries.
In my opinion, these companies provide a very real service to me, and I
strongly believe that they earn and deserve the profits that they make on my
hourly rate. On a more practical note, what if they didn’t make a profit? Who
would be there for me the next time I needed a job? The recruiters would be
long out of business by then.
If you work as a contractor, make sure that you have a realistic and practi-
cal attitude about how the money gets split and who does what. Not only does
it make you look like a stark raving amateur to go on a rant about what your
recruiters makes off you, it also doesn’t endear them to you in the slightest.
I treat my recruiters with gratitude and respect, and some have even become
friends over the years. Consequently, they always return my calls, and when
we go out to a business lunch, they buy. They also know by now that I eat the
most expensive steak in the house (you get a reputation for this sort of thing,
you know) and are happy to specify that the chef cook it just the way I like.
Treat the people who take care of you as you would your friends, and they’ll
always be happy to hear from you.
The Entrepreneur
Although a lot of us enjoy getting up each day and going to work in an office
where someone else is minding the farm while we code, for some, the thrill of
the chase is irresistible. Sometimes it starts as a software idea that turns into
a marketable product. Other times it’s just the adventure of being your own
boss. No matter how it happens, some choose to break out of the mold and
start their own company.
Running your own business can certainly be exciting. So can plugging a
pair of needle-nosed pliers into a live electrical outlet. This is not the path for
the faint of heart. There’s much more to running a software company than
coding. Depending on whether you get the capital to do a big-time startup or
Chapter 12 Controlling Your Destiny
197

kick it off from your kitchen table, you’ll find yourself performing a wide vari-
ety of nontechnical duties, from accounting and management to marketing
and even a little janitorial duty. I’ll leave the interviews for hiring your own
attack Chihuahua to the imagination.
One of the lures of starting a company that makes all the work seem
worthwhile is the chance to make it big. Some of the major software corpora-
tions in our country seem powerful enough to be a government unto them-
selves, not to mention the gobs and gobs of money they make. That sure can
seem appealing. For the few and the motivated, these dreams truly are attain-
able. It’s also great fun for the ego to tell your friends at the local programmers’
bar that you’re the president of XYZ Software and Assorted Clever Gadgets,
Incorporated. If you can’t have a little fun with your job, then what’s the point?
Building a company is also a creative endeavor that isn’t dissimilar to writ-
ing a song or painting a masterpiece. You’re building something new, some-
thing from your own imagination, something that never existed before you
brought your vision to reality. There’s a lot of gratification in that alone.
Of course, what most budding young entrepreneurs dream of is a company
that runs itself while the boss plays golf. In reality, the boss’s workweek starts
at forty hours. You’re the first to arrive and by far the last to leave. One of the
requirements for a sane life and a healthy company is the discipline to know
when to not work. If you can’t develop the strength of will to call it quits for
the day and leave it at the office, you’ll burn out in a heartbeat. You also may
find that whatever family and friends you had when you started thin out con-
siderably once you spend day and night working. Balance is an important art
for the new entrepreneur to learn.
Of course, with all the freedom and potential comes a fair amount of
expense and risk as well. If you don’t have any experience or training in some
of the basic aspects of business, the very best thing you can do for yourself is
to find a partner you can trust who is a professional Suit. Know your strengths
and weaknesses, and don’t let your shortcomings become your company’s
as well.
Even if you do it all correctly, the business world is an uncertain one, and
there’s no guarantee of a weekly paycheck. Make sure you can survive for a
year without income from the company. One of the reasons that there’s such a
high mortality rate for new businesses is that many people overlook this and
expect to have the money rolling in from day one. Sometimes it happens that
way. Often it doesn’t. As an entrepreneur, a conservative financial outlook is
your best friend. Live to fight another day.
Running a business also involves a host of legal issues. Talk to some people
you respect and trust, get some recommendations, and hire a good lawyer and
accountant. Unless you have an accounting or law degree (and a whole lot of
time on your hands), hire professionals to handle these critical tasks for you.
That’s a hard choice to make for a small startup company, particularly if kitchen
tables are involved, but in the long run, it’ll cost you much less this way.
198
Part III Building a Better Career

If you do decide that you’ve come up with the superior mousetrap and
want to show it to the world, I say go for it. Give it heart, body, and soul. Then
go home at five o’clock and spend time with your family. Remember, nobody
ever wishes they spent more time at the office.
Having reviewed all of the obvious choices for making a living as a profes-
sional developer, the next thing to look at is actually landing the job. Assuming
that you’ll be working either as a contractor or an employee, you need to keep
a number of considerations in mind when it’s time to seek those greener
pastures.
Off to the Races
It’s hard to construct a building without a good blueprint, and landing the
perfect programming gig is no different. You won’t get the job of your dreams
unless you know what it is. No one path is better than the others, and each
approach has its pluses and minuses. It all comes down to personal preference.
So, without further ado, let’s take a more detailed look at some of our
options in the wonderful world of software development.
Chapter 12 Controlling Your Destiny
199

The past decade or so has been a great time to be a techie. It seemed that no
matter what language you preferred or which operating system you called
home, people were kicking down your door and begging you to come to work
for them. Stock options, pool tables in trendy offices, and high salaries all
beckoned. Without a doubt, it was an excellent time to be coding for a living.
However, nothing in life ever stays the same, and the business arena is no
exception. A host of transformational events have arisen in the past few years,
and they have left very few technical careers untouched. The collapse of the
dot-com era boom is one of the more obvious calamities that we’ve endured of
late. Between that and the ensuing economic slump, businesses have reined in
their spending on software development, and a large amount of new jobs went
the way of the dinosaur as Internet-based companies folded left and right.
In the midst of all of this, corporate bean counters realized that the Internet
made it easy to hire cheap technical labor in areas of the globe where their
currency carried much more weight. An onslaught of global outsourcing initia-
tives followed, with huge numbers of software jobs being shipped off to other
countries for bargain-basement prices. In addition to the obvious loss of local
jobs, this contributed to a trend of reduced salaries. 
These changes have had an enormous impact on what were once very
easy career choices. The decision to pursue a career as a professional software
developer is no longer the no-brainer that it once was. Consequently, many are
now opting for different fields. Those of us who remain are facing a decidedly
different job market. And, like it or not, sooner or later you’re going to have to
change horses. No job lasts forever, and if you’ve been in your current position
for a number of years, you’re going to find a completely different landscape
when you look for your next one.
If you’re among those who are out of work, your highest priority is landing
a new job. However, even if you’re currently employed, you can no longer
afford to sit in your cubicle and trust that you’ll always have a position with
your current employer. Our industry is in a major state of transition, and if
201
Get a Job (Sha na na na. . .)
13
C
H
A
P
T
E
R

you don’t start thinking ahead, your ability to pay the bills could be rudely
disrupted by a spontaneous loss of income. As in all matters, luck favors the
prepared.
Many of the things we’ll cover here will be common knowledge to you.
However, the person with the competitive edge is the one who looks for every
single angle from which they can work a problem. Consequently, we’ll cover it
all, from the mind-numbingly obvious to the not-so-well-known tricks that can
make a real difference in your job search.
If you’ve decided to stick it out as a professional programmer, you’re in
good company. A lot of us couldn’t leave this lifestyle if we tried. I think they
have treatment centers for that. As you’re no doubt aware, there are basically
two different types of programming jobs available if you want to work for
other people. The first is the traditional position as a salaried employee of a
company. Alternatively, you can work as a contract programmer, a job where
you’re essentially a temporary part of the team, paid by the hour, and then dis-
missed when your services are no longer required. When it’s time to get your
next job, there are some subtleties to these two paths, so let’s explore each in a
little more detail.
The Usual Suspects
Now that we’ve taken a look at the most common options for finding employ-
ment, it’s time to start thinking about where to look. Like so many other things
in our industry, locating potential employment is no longer as simple as it
once was.
Once upon a time, if you were looking for a job, you’d grab your local
newspaper and leaf through to the Help Wanted section. However, people
often have a tendency to throw out the old in order to embrace the new. With
the dominance of the Internet in our current culture, many people assume
that print publications are now irrelevant. This is simply not the case, but that’s
good news for those of you looking for work. It means less competition for
you. Although it’s true that companies now use a variety of methods to look
for new people, your local newspaper is still a player in that game.
If you’re looking for a contract position, you’ll see some ads that are obvi-
ously posted by recruiting companies. You may also see multiple ads from the
same firm. What I typically did when scanning the newspaper was to enter
each job I wanted to pursue into a simple database that required a unique
phone number. That way, if it wasn’t obvious that two ads were from the same
company, I’d realize it when I made the entry. It kept me from looking like a
poorly organized candidate, which is how I’d appear if I called the same com-
pany several times in ten minutes. 
When considering newspapers, don’t make the assumption that
everything appearing in the paper will also be on the company’s Web site.
202
Part III Building a Better Career

That’s frequently not the case for a number of reasons. The bottom line is that
in a competitive job market, you need every edge you can get. Therefore, buy
the newspaper, get ink on your fingers, and look in the classified section under
Help Wanted. While you’re at it, be sure to quickly browse each and every cat-
egory. Sometimes there are multiple categories that might be appropriate for
advertising a programming job. In addition to that, people will occasionally
list their job in unlikely places, either due to cluelessness or simply because
they’re looking at things in a different way. You don’t care why. You’re just
looking for opportunities. Therefore, make a thorough perusal of the physical
local newspaper one of your first stops.
Having washed the ink from your fingers, your next stop is the newspaper’s
Web site. I didn’t say ignore the Web, only that you shouldn’t count on it being
a duplicate of the print publication. This works in both directions. The possi-
bility also exists that there are items on the Web that don’t appear in the physi-
cal edition. Remember that newspaper Web sites are often run as a separate
business unit. If you treat them as closely related but separate sources with a
high percentage of duplicates, you’ll have the proper perspective. Yes, you’ll
waste a bit of time being this thorough, but extra effort is what differentiates
the winners from the losers in life.
Of course, having mentioned the Internet (or more, specifically, the Web),
we’re now off to consider the wide array of job sites available to the inquisitive
and hungry programmer. As soon as I declare that there are a finite number of
categories to these sites, some bright boy will immediately come up with yet
another angle. Nonetheless, there are two basic types of sites that are very
popular.
The most common are the employment sites. These folks do a good job of
allowing you to post your résumé and look for jobs, while employers post jobs
and search through résumés. It’s a classic example of something that computers
do well, and it’s a worthwhile exercise to use your favorite search engine and
locate each and every one of these sites that don’t charge you money. The nor-
mal arrangement is that the employer pays to list their job, and the programmer
posts résumés for free. There are a lot of sites like this out there, so keep your
wallet in your pocket. If a site wants to charge you to post your résumé, move
on to the next one.
Overall, establishing a comprehensive presence on these sites is a task
worth adding to your search. However, don’t let it become the centerpiece of
your efforts. In the movie and theater community, this is what’s known as a
cattle call. You’re competing with a cast of thousands, and it’s easy to get lost in
the shuffle. Without a doubt, it’s possible to get a job through this mechanism,
but you need to realize that there are high odds working against you. Let this
motivate you to list your résumé in every legit-looking site you can find, and
then move on to your next task. Your overall strategy should be to cast as wide
a net as possible. Who cares how many of your efforts yield no results? You
only need one success to become employed.
Chapter 13 Get a Job (Sha na na na. . .)
203

There’s a second kind of job site that is project-related. Essentially, compa-
nies post a desire to have someone write a chunk of code for them. It could be
small routine or a complete system. Interested programmers then bid on the
opportunity. I can’t imagine a worse possible environment in which to present
myself.
Like so many other things that computers do well, this seems like a great
approach. Similar to a job site, it’s simply a way of putting people together.
However, the process breaks down in a number of places. First, the Web is
global. That means you may well be bidding against people in different coun-
tries and economic climates, who can make a good profit at a much lower rate
than you can live with. And trust me, no matter who you are or where you live,
there’s always someone who will offer to do it cheaper, even when it makes no
financial sense to do so.
However, just like a live auction, people often get caught up in the excite-
ment of the bidding process and keep competing long past the point of prof-
itability. The end result is that you may win a gig by continually underbidding
others, and end up working for 17 cents an hour by the time the project is
done. Sorry, but that’s just not an enticing scenario for me.
Additionally, these sites violate my first rule of software development.
Never, ever, do a job for a fixed bid. You’ll always encounter the unexpected,
things will invariably take longer than you thought they would, and your cus-
tomer’s requirements will frequently be fuzzy and ever changing, leading to an
endless cycle of scope creep.
Just to add one more reason to avoid these situations, bear in mind that
the world is a very big place and international law gives you even less protec-
tion than your local laws offer. You’re dealing with people who are frequently
on the other side of the world and are many times little more than an email
address or Web site to you. Your exposure and vulnerability in terms of not
getting paid are astronomical. Want a job? Get a job. Leave the Internet
bidding wars to others.
One additional way to use the Web to your advantage is to do some clev-
erly crafted searches in your favorite engine. Specify the names of your city
and suburbs and other relevant keywords that would appear in a Help Wanted
ad for programmers. You might also experiment with industry-specific key-
words if you have a background in vertical industry software. Occasionally,
companies will list a job opportunity on their Web site. Naturally, the newspa-
pers, job sites, and other employment-oriented resources will have no aware-
ness of these little gems. Your chances of stumbling onto a job in this manner
are very slim. However, if you have some time on your hands, add it to your
overall efforts. People do list jobs in this manner, so the needles do exist. It’s
just a very large haystack.
Another unconventional method of looking for work is canvassing compa-
nies. Using your local phone book, the display advertisements of companies
in your newspaper, and industry trade publications, build a list of businesses
who could use your services. Software development companies are the more
obvious targets. However, consider this: do you know any companies that don’t
204
Part III Building a Better Career

use computers? Not all of them will need programmers for internal software
development, but a great many do. Armed with a list of company names,
addresses, and phone numbers, you’re able to embark on a campaign of 
cold-calling. You can call the company’s main number and ask for the person
in charge of the IT department, or you can simply show up at the front desk
with a copy of your résumé. I’ve seen both approaches. The latter takes more
time and effort on your part, but adds a personal touch. They can see that
you’re a real, live programmer looking for a job, not one of a dozen recruiting
companies that have called them today. That sometimes makes a difference.
If you have a background or interests in particular industries, target those
companies. You might even sit down with the business section of your phone
book and go through it front to back, making note of categories that have
potential, and returning to glean the information and incorporate the compa-
nies into your search. There are endless possibilities on how to organize such
a search, and if you live in a major metropolitan area, you’ve got a lot of poten-
tial companies. The most important rule I taught people when I ran a sales
consulting firm was that they absolutely must “run the numbers.” You’re going
to sell a certain percent, or fraction of a percent, of the contacts you make.
Therefore, simple math tells you that the more contacts you make, the greater
your chance for success.
Yes, this approach is a lot of work, and it’s also a bit unconventional. In
addition to expanding the possibilities of getting an interview, you should also
think about what this says to potential employers. Countless people send in
volumes of résumés in response to traditional ads. These same people then
often sit back and do nothing other than complain when they see no results.
You, on the other hand, got off your posterior, showed some creativity and
initiative, engaged in some hard work, and demonstrated that you are clearly
not the average candidate. You’re a self-starting, results-oriented, make-it-
happen person. Even if a company isn’t hiring at present, a lot of them are
going to keep your résumé just because your initiative and strength of charac-
ter impressed them. Who do you think they’ll call first if they suddenly lose a
programmer?
Now, back to some of the more traditional job search methods. If you’re a
contract programmer, recruiting companies should be your first stop. This is
what they do for a living. However, do you have a list of every recruiting com-
pany that operates in your city? Don’t assume that they’re all advertising in
this Sunday’s paper. Although that’s a good place to start, continue your
research from there. Hit the phone book and find out what category these
companies are listed under. Add the rest of those categories to your database.
Search the Web for these companies, and see if you can find any search engine
or other directories that list them. These sources will lead to more companies
to add to your list. For each company that you find, see if they also have
branches in other cities. Why? So that you can search that city for recruiters,
and see if they have branches you overlooked in your own city. Also, check the
paper every single day. Some small recruiting companies are harder to find,
but are still worth working for. In short, make it a research project to build and
Chapter 13 Get a Job (Sha na na na. . .)
205

continually update a database of recruiting companies. Like all other aspects
of our field, this landscape is always changing, with new players coming into
the field and others going out of business. They’re valuable resources, and the
more you have on your side, the greater your odds of success.
But what if you’re not looking for a contract job? Contact these companies
anyway, and ask if they do permanent placement. Many do. Furthermore, fol-
low the exact same exercise I just outlined with standard employment agencies.
They’re still an established industry, and many companies will use them when
looking for programmers. Don’t limit your options by looking only for techni-
cally oriented employment firms. Unless they specify that they hire people
only for a specific and nontechnical industry, it takes only a moment to contact
them. Remember, run the numbers.
Fame for Fun and Profit
Another thing to keep in mind is that people often seek out programmers by
reputation. In my case, I now run a consulting company and teach manage-
ment techniques, strategy, tactics, and other such things related to improving
companies and careers. People who have either read my books or heard about
me through other related venues often contact me, and it’s a great source of
new clients, since they already have a good idea of who I am and how I can
help them.
You don’t have to write books to benefit from this approach. Can you write
articles? Do you make interesting and useful contributions to code-sharing
sites? If so, then you can build a reputation that will bring people to you. In
fact, you’ll find that if you have something of value to offer—be it advice,
opinion, libraries, code snippets, or any other useful tidbit relevant to your
skills—you can use the same promotional techniques used by professional
public relations firms to spread your name, such as print and radio interviews,
articles, blogging, podcasting, press releases, and all the other normal
approaches to publicity. Find a way to make yourself a celebrity, and you’ll
draw attention.
Once again, run the numbers. The more people who know about you, the
better chance that you’ll encounter someone who’s willing to pay you for what
you do. Don’t forget that this isn’t limited to coding skills. If you have a back-
ground in any particular industry, then you may well have something to say
that would be of interest to that industry. Become a voice, be a personality,
become known in your circle. When someone in that business needs another
programmer, they may very well contact you to see if you’re interested in the
job. I mean, after all, you’re a well-known figure—wouldn’t it be a real feather
in their cap if you worked for them?
It probably goes without saying, but keep this in mind: if you’re drawing
employment offers through your reputation, take that reputation seriously.
People don’t always agree with the way I see things, and I’m not the right guy
206
Part III Building a Better Career

to help every single business with a problem. However, taking care of my
clients, doing a good job for them, looking out for their best interests, and, in
general, always thinking of them first is my most important daily activity. Your
ethics, dependability, promptness, competency, and even seemingly small
things like how much fun you are to correspond and work with are all your
most valuable assets. Take them seriously, treat people well, and you never
know who might refer you for a job.
While we’re on the subject of referrals, it’s worth noting that this is yet
another area that most people don’t actively work when looking for a job. In
fact, probably the single most valuable thing you could receive in your job
search is a heartfelt recommendation from someone who your potential
employer trusts. Hiring programmers is a crapshoot. Everyone looks good
on paper, and it’s almost impossible to tech interview someone in any kind
of comprehensive manner. Referrals are worth their weight in gold.
Unfortunately for most people, they just sit on the couch and wait for
referrals to magically happen. Yes, random events do happen, but why put
your ship at the mercy of the winds? Given the choice, I’ll take a romantic-
looking, tall-masted sailing ship every time, just for the sheer adventure of
hanging from the rigging with a pistol in my belt and a sword in my teeth. In
fact, you may have even heard rumors (which I shall neither confirm nor deny)
that I first met a certain small but fierce Chihuahua when he was captain of
the gunnery crew aboard a pirate ship out of Port Royal. Never trifle with a
swordsman who’s faster than you and can run between your legs. However,
even were I to captain such a ship, you can be sure that I’d also have some
hefty, high horsepower engines tucked away down below, just in case the wind
failed. I don’t like leaving things to chance, and neither should you. You want
referrals? Get out there and make them happen.
In fact, the hardest aspect of networking for most programmers is not the
availability of contacts, but the stereotypical introverted nature of the stan-
dard-issue, pocket-protector-wearing geek. What’s that you say, you don’t fit
that image? Good. Very few do these days. However, even if you spend your
off-hours hang gliding or playing full-contact sports, that doesn’t guarantee
that you’re comfortable meeting new people or promoting yourself. Like any
other skill, however, this can be acquired with effort on your part.
Getting the Word Out
First of all, become a joiner. Find every organization that is even remotely
relevant to your technical skills or to the industries you’ve worked in, and join
them. Be active on their Web forums, and attend the local meetings. Offer to
write for their newsletter. In short, go out of your way to be helpful to the
members, and start building a reputation. As your circle grows, you don’t have
to be a late-night infomercial guru to use this to your advantage. In fact, a
crass approach will actually work against you. Instead, simply mention to all
Chapter 13 Get a Job (Sha na na na. . .)
207

those you come in contact that, by the way, you’re currently looking for work,
and should they hear anything, you’d be most grateful if they’d pass your
name along.
Do you have a personal business card? If not, print up a few. They don’t
have to be elaborate. They can simply be Your Name, Programmer. It’s an
easy way to give someone your name, phone number, Web site URL, and
email address. For obvious reasons, you don’t want to hand out your current
employer’s business card when looking for a new job, but surprisingly few
people think to have personal cards made up if they’re not running a business.
There’s a reason business cards exist. They’re a convenient method of
exchanging contact information. Use them.
In addition to joining organizations, start building your skills at networking
through your friends and acquaintances. If you’re a programmer, you probably
know other programmers as well. Talk with them, and work to expand your
network of friends. Here’s a tip that works wonders when you’re looking to
expand your social circle: think of other people first. This is not some idealistic
truism, but rather an established principle. If you meet people and get to
know them, you’ll soon know much about their goals, dreams, and desires,
along with the problems they may have achieving them. Look for ways that
you can help them, and when you see an opportunity to do so, offer it, asking
and expecting nothing in return beyond the good feeling of doing something
nice for others. Make every effort you expend on behalf of others sincere and
high quality. 
So what’s in it for you? Nothing immediate. However, by doing this, you’ll
build a reputation as a really great person to know, and people will speak
highly of you. This will bring you in contact with more people, expanding
your circle, and you’ll be introduced as someone special. When people hear
of a great new job opportunity, who do you figure they’ll think of first? As
programmers, we’re used to thinking in terms of concrete cause and effect.
However, when you’re looking for work, life isn’t always that cut-and-dried.
Learn to network and gain a good reputation as a nice, competent, and helpful
person, and you’ll be amazed at what opportunities come your way.
Digging Deeper
With perseverance and consistent effort, you’ll start getting interviews. Even
though that’s a significant success in a competitive climate, there’s still a lot of
other people who want the job. You’re going to have to demonstrate in clear
terms that you’re the best pick for the team. The interview process is where
you get the chance to sell yourself. Fortunately for you, the majority of people
simply show up at the appointed time and place, and answer questions. This
means you have yet another opportunity to rise above the rest by doing your
homework prior to the initial conversations.
208
Part III Building a Better Career

When it’s a seller’s market for your skills, you have the luxury of letting
your talents and experience do the talking for you. When it’s a buyer’s market,
that simply makes you look arrogant at worst and uninterested at best. You
need to show the people you’re corresponding with that you’re the perfect fit
for their company and their project. But how can you possibly do this when
you know next to nothing about them? That’s a good point, and one you can
easily address.
Most companies have a Web site, and in addition to a little Internet
searching and perhaps some local research through friends, recruiters, and
anyone else familiar with them, you can find out a great deal about a com-
pany’s culture. Here are just a few questions to give you an idea of what you’re
looking for:
 How do they dress, and what sort of image do they present as a business? 
 Is it a conservative or casual environment?
 Is there a language of their industry that you might familiarize
yourself with?
 What are their business priorities?
 What are the biggest problems facing their IT department?
 What can you learn about the individuals on the team and the
project itself?
 What can you learn about the decision makers?
There are, of course, many more such questions that you can, and should,
ask yourself well in advance of the actual interviews and phone calls. It’s not
really hard to come up with the list if you just sit down and think of what you
would need to know in order to fit in perfectly in their situation. 
None of this is a recommendation that you should pretend to be some-
thing that you’re not. People can spot a phony a mile off, and to most people,
it’s offensive. However, by doing a little investigative work up front, you can
present yourself in a language that they can relate to. If you’ve done your
homework and are reasonably well educated about who they are and what
they’re doing, it’s going to be obvious to the people conducting the interview,
and if nothing else, they will always be impressed that you had the initiative
to be so well prepared.
Shuffling Paper
I intentionally mentioned research prior to any discussion of résumés because
research can aid you in this area as well. The majority of your competitors are
going to do the same thing. They’ll update their résumé, print out a few
Chapter 13 Get a Job (Sha na na na. . .)
209

copies, and mail them off to prospective employers. Every prospect gets
exactly the same thing. Most of your competitors’ résumés will look very
similar to each other as well.
You, however, have already done your homework on the company that
you’re applying to, which puts you in an excellent position to knock their socks
off before they even pick up the phone. Since you know a little about their
company, their project, their culture, and their team, you can really stand out
by customizing your résumé for each company. Instead of the interminably
boring list of technologies and job experience summaries, you can speak
directly to them and their needs. This is not to say that you don’t give them the
technical and historical information they need. Rather, it’s how you offer it.
You can tell them, “I worked at the ABC company where I used the XYZ
technology on their Gizmo project.” Yawn. They’ve read twenty of these
already from your competitors, and believe me, it’s not even registering. Even
our trusty canine friend is snoring in the corner, dreaming of pint-sized
Harleys and heaven only knows what else.
Instead, imagine their surprise when they see you speaking directly to
their needs. “After reading about [Company Name]’s stated goal to dominate
the [their specialty] industry through a unique and innovate approach to the
XYZ technology in the Wall Street Journal recently, I realized I would be able
to contribute a great deal to the process from my experience in this area on
the ABC company’s Gizmo project.”
As you can see, by filling in the blanks, you can really draw a straight line
between your previous work history and the things that benefit them. Your
personal style will dictate how you incorporate this information, of course, but
people will immediately notice things like their company’s name, references to
news articles or Internet mentions, their project name, and so on. And that’s
exactly what you want to do: grab their attention. Once you have it, you pro-
ceed to answer the single most important question they have: if they hire you,
what’s in it for them?
But given the number of résumés you’re planning on sending out, isn’t all
this research and customization an awful lot of work? You bet it is. That’s why
your competition isn’t doing it, and it’s precisely why it gives you the edge.
In the past couple of years, I’ve known absolutely brilliant and seasoned pro-
grammers who were out of work for months, even over a year. If a little up-
front effort reduces your job search time down to weeks because you present
yourself as such a compelling choice, isn’t it worth the effort?
Above and beyond research, there are some other fundamental aspects to
consider in preparing your résumé. First, as always, you need to think of the
other guy. Most of the people going through stacks of résumés are programmers
themselves. What would you rather be doing: coding something interesting or
going through a stack of résumés that all look the same? Yep, that’s how they
feel, too. If you want to get on their good side, do everything you can to make
things easy for them.
210
Part III Building a Better Career

After the first few résumés, they all start looking the same, usually because
they all look the same. Consequently, the hiring managers begin glossing over
the endless acronym soup and repetitive paragraphs of job descriptions. ABC
technology. Check. XYZ technology. Yeah, yeah. Next. . .
Surprisingly, however, even though much of the résumé content tends to
run together, one thing that catches people’s eye every time is poor content,
grammar, formatting, or any other thing that highlights the fact that the person
submitting it was either too stupid or too lazy to do a proper job. If someone is
sloppy in his résumé, it’s a pretty good bet that he’s sloppy in his work as well.
Congratulations. You’ve just made the résumé reader’s life easier, although not
with the results that you wanted. Your résumé goes straight into the trash can.
Here are a few classic mistakes that you should never make in your résumé.
I’ve seen these too many times in my own hiring adventures. First, if you have
misspelled words or typos, it indicates that you’re not smart enough to operate
the spell check button in your word processor. When I see this, I’m afraid to
think what would happen if I turned you loose with a compiler. Spell-check
your document one last time before you hit print. Make it a habit.
Poor grasp of the spoken language is another biggie. In America, the com-
mon language is English, so I’ll use that as my example, but this applies no
matter what country you’re in. Since the IT industry is very international by
nature, it’s common for me to meet, work with, and see résumés from people
who were raised in every part of the world. Personally, I think that’s a pretty
cool side benefit of the business, but I digress. When you’re working on a soft-
ware project, communication is an extremely important consideration. 
I don’t care if you speak fourteen languages and have a dozen degrees in
rocket science. If you can’t effectively communicate with the team, you’re a
liability, not an asset. So what message does it send to me as a hiring manager
when I read your résumé that, while spell-checked, nonetheless presents
clumsy and unnatural sentences and paragraphs? You’re going to appear either
as someone incapable of speaking the language or as a rather uneducated per-
son who simply lied about all those rocket science degrees. Either way, into
the trash you go.
Now it may well be that English is not your primary language and that you
actually communicate verbally much better than you do on paper. Leaving
aside for the moment that written skills are also valuable, there’s something
that you can do about this. Have someone who was raised speaking the lan-
guage (not someone who is merely fluent) proofread your résumé. In fact,
even if language is not an issue for you, you should have a friend read your
résumé nonetheless. I always get caught with words that are correctly spelled,
but not the word I wanted. For instance, a typo can easily make “read” come
out “red.” No spell checker is going to catch that for you, but a friend will. It
also helps with things like accidentally leaving in “the the,” which happened
when you were editing. Lastly, a second set of eyes can look over what you’re
saying and point out anything that might be clumsy or completely boneheaded.
It happens.
Chapter 13 Get a Job (Sha na na na. . .)
211

You should also make sure you have your facts straight. If you start talking
about the work you did on Microsoft’s latest distribution of Linux, you’re
gonna get laughed out of every programmers’ bar in town. Your résumé will
also go in the trash, or worse yet, be posted on the refrigerator to serve as
company entertainment. Be intelligent and accurate. That’s not an unreason-
able set of expectations for programmers.
In general, you’re offering a professional document. It should have all the
trappings of professional work. Along those lines, remember the words of your
first-grade teacher. Neatness counts. If you don’t have good composition skills,
get a friend to help you with the formatting of your résumé, but make sure it
looks good. If you have a seventeen-color résumé that looks like a bad Mardi
Gras hangover, it’s going straight into the, well, you know.
During the interview that would result in one of my first programming
jobs, the manager told me that he had a number of other people who were
more qualified, but that because of my formatting and overall presentation,
my résumé stood out nonetheless and he felt compelled to at least interview
me. In person, I was able to impress him with my potential and how good a fit
I would be, and I got the job. However, it was the presentation of my résumé
that got his attention.
What’s that you say? You’re an absolute guru at the compiler, have an
incredible work history, and just don’t need to depend on this kind of stuff? I’d
like to remind you that this is exactly the kind of people I beat out for the job
in question. And I had exactly one year of professional coding experience at
that point in my career. Neatness counts. So do style points. 
Speaking of style, I would rank it as yet another crucial consideration. I
should preface my next set of comments by telling you that I never have really
fit into the corporate mold. What works for me might be a disaster for you.
That said, I make it a point to put a very large personal stamp on my résumé.
It reads like the books and articles I write. I’m a wise guy who’s irreverent and
not afraid to poke fun at the things that we all know need poking fun at in this
business. I’ve had recruiters turn white as a sheet after reading my résumé and
inform me, hands still twitching, that they would have to completely rewrite it.
I simply smile and tell them that if they do, the deal’s off. All of the wise guy
stuff in my résumé is my idiot filter. Anyone who’s going to freak out because I
made a joke in a job description is going to have an absolute panic attack when
he meets me personally, so why do I want to interview with him? Life’s too
short to work for clowns.
As an example, following is an actual excerpt from my résumé regarding
experience working on a nationwide air traffic control system. I suppose people
expect me to be somber and serious about something as important as landing
airplanes, but that’s not the guy they’d get if they hired me. So, here’s a bit of
what they get to help them determine whether or not I’m the right one for
their team, with some of the technical stuff snipped out:
212
Part III Building a Better Career

This system supports controllers in their management of large, heavy
flying objects containing people who typically prefer uneventful
landings, so the system must run 24/7 with zero failures. . . . 
Design phase of the system utilized UML and only a small number 
of cocktail napkins, all of which were object oriented.
I can assure you, many managers will read this and immediately toss it into
the trash, which is precisely my intent. Interviews are a two-way street. I’m
actively weeding out the stuffed shirts that I know I wouldn’t enjoy working
for. The résumé continues in this tone throughout. If that’s not enough to send
any reasonable recruiter running for a therapist, there’s always the cartoon at
the bottom of my résumé containing an interview between two cavemen and
the observation that all the applicant’s references are baboons. Yes, I really did
put a cartoon at the bottom of my résumé. Above and beyond the sheer fun of
watching recruiters twitch, there’s another practical aspect to this. Not only
have I weeded out the faint of heart, I can assure you that, by the time a hiring
manager has gone through a hundred résumés, he’ll remember mine. He may
love it or he may hate it, but he’ll never forget it.
Am I suggesting that you take ridiculous chances and drop any vestige of
professionalism in your résumé? Absolutely not. What I’ve shared about my
own is merely a way of making a point. Your résumé should be a reflection of
who you are, and it should stand out in a stack of others as memorable. Find a
way to get your personality into what you write. If you can think of something
else that they’ll find memorable, like my example of a cartoon, do it. However,
heed these words of caution. I take chances because I know from experience
that I can pull it off. Even so, my approach falls flat on its face with many
people. I’m sure there have been jobs I would have enjoyed that I never got a
shot at because of my flippant approach. If you’re going to take some chances,
be aware that there will be some cost involved, and use your common sense
accordingly.
Another important thing to emphasize here is personality. What’s your
personal style? Do you even know? What makes you cool? Why do other pro-
grammers want to hang out with you? What aspects of your personality do
people talk about and admire when you’re not around? No matter what you
may think, you have an effect on people. Find out who you are and what
makes you someone worth knowing, and then find a way to make that stand
out in your résumé.
I recently watched a movie, Legally Blonde, which is a comedy about a
stereotypical California girl who’s a blonde, rich, beautiful, trendy, fashion-
conscious sorority girl and appears to be quite the shallow bimbo. Quite the
contrary—she’s actually highly intelligent and has a 4.0 average, which is part
of the fun. As the plot evolves, she applies to Harvard Law School. Although
it’s obviously a comedy and an unrealistic situation, her application video alone
Chapter 13 Get a Job (Sha na na na. . .)
213

is worth the price of admission just to watch how she spins her background as
some kind of fashion retail merchandising major into justification for getting
into Harvard. An exercise in pure, delightful chutzpah. Later in the show, and
more relevant to this portion of our considerations, she gives someone from a
law firm her résumé. In disbelief, he looks at her and says, “It’s . . . pink.”
“Yes,” she says brightly, “and it’s scented. I think it gives it a little something
extra, don’t you?” Not to spoil the movie for you, but she not only got into
Harvard, she got the job from her proffered pink résumé. 
Does this mean you should scent your résumés and use pink paper?
Maybe, maybe not. It wouldn’t work for me, but then, a cartoon probably
wouldn’t have worked for her. In all seriousness, though, you need to find a
way to make a statement with your résumé—something that will make them
say, “Hey, here’s somebody worth talking to. This person is unique.”
Be advised that this advice is in distinct conflict with what professional
placement agencies and résumé-writing specialists will tell you. Their advice is
typically to find out what the common, professional format that everyone else
uses is and follow those guidelines. You’ll never look stupid taking that advice.
But then, you may never get noticed, either. There’s a fine line between per-
sonality and unprofessional. You’ll have to be the judge of what you can suc-
cessfully pull off. Nonetheless, remember that those who get the greatest
rewards are those willing to accept a degree of risk. If you want to stand out
in a tough market, you’ll have to take some chances.
Above and beyond things like cartoons and the color of your paper, your
writing style also sends a message. My résumé had in bold letters, “No college!
Completely self-educated in programming, living on popcorn and existing with
no sleep.” I don’t have a college education, so I figured I’d sell it as a feature
rather than claim it as a bug. And of course, I also made references to doing
design using object-oriented cocktail napkins. Basically, my résumé reads like
my books: irreverent and colorful wherever possible. Once again, you first
have to know who you are and what makes you cool. Having discovered that,
convey it both in visual presentation and in the language that you use. After
all, they’re going to figure it out anyway on the interview. You don’t want to be
accused of false advertising, do you?
Skill summaries are also important, especially for recruiting companies,
as they use this information in their database so that they can do keyword
searches for the needs of their clients. However, this information tends to
clutter up the presentation of the résumé and takes away from anything I do
to get their attention. Consequently, I provide the skill summary as a separate
page with a table listing the technology in one column and the number of
years I’ve worked with it in the other. That also makes it easy for the data-
entry people.
Of course, references are also something that tend to get included with
résumés. I always simply state that references are available upon request, as I
don’t want to give out these people’s information unless there’s a legitimate
reason to do so. However, there’s something else to consider about references.
214
Part III Building a Better Career

First, make sure you have both personal and professional references lined up.
My next comment may surprise you, but remember, for every rule, there was
an incident. If you give someone a reference, make absolutely sure that it’s
someone who will say good things about you. Why would anyone list as a refer-
ence someone who would not speak well of them? I have no idea, but I’ve
seen it many times. Lastly, and this is sometimes easy to overlook, verify that
you have their correct and up-to-date contact information before you give it
out. In today’s highly mobile society, this stuff changes frequently, especially
email addresses and cell phone numbers. You can imagine what someone will
think if he tries to contact your reference and the email bounces.
Remember, your résumé is your first and most important sales tool. It
doesn’t matter if it’s traditional. It doesn’t matter if it’s pink. It doesn’t even
matter if it’s scented, although the hiring manager might find tiny teeth marks
on it if it smells like a doggie biscuit. The only thing that matters is that it’s
effective in getting you an interview. All other considerations are secondary.
Face Time
Having done everything right that your competitors missed out on at this
point, you now find yourself in the actual interview, exactly where you wanted
to be. Or not. I’ve known a lot of really bright programmers who couldn’t
interview their way out of a wet paper bag. That’s more than unfortunate—
that’s downright disastrous when it comes to landing a job. What good are all
those great skills if you can’t sell them? And make no mistake, even if the
approach is a subtle one, interviews are all about sales. You’re working to per-
suade them to hire you, and if they know you’re the guy they want, they’ll be
working just as hard to convince you to join the team. You can make all the
jokes you like about the marketing folks, but if you can’t sell yourself, you’re
going to lose the job to less qualified candidates every time. Although you
should never pretend to be something that you’re not, here are a few tips on
improving your image when you finally get to the face-to-face interview.
How you dress for the interview is not as obvious as it once was. Show up
in a suit and tie for an interview for a financial institution and they’re going to
be impressed. However, it might just send the wrong signal to the Web devel-
opment team at DeathMetalRockers.com. Worse still, even if it’s a casual dress
shop, some people still expect you to show up in a suit as a gesture of respect.
Do your research and know what’s going to be the most appropriate. Any time
I showed up at what I knew was a casual shop, I also mentioned (casually, of
course) that I’d learned in advance that this was how everyone dressed or I
would have worn a suit as a gesture of respect. That shows them the difference
between someone who did their homework and a slacker who shows up
dressed in jeans and a T-shirt even when interviewing at IBM (a company
once notorious for its blue business suits).
Chapter 13 Get a Job (Sha na na na. . .)
215

Self-confidence is another key factor. If you don’t have it, brother, you’d
better learn to fake it. This is one area where it’s okay to pretend to be some-
thing you’re not, for if you don’t, you’ll never get anywhere in life. When
I’m interviewing someone, it doesn’t matter if his résumé and a dozen
unimpeachable sources say that he could have designed the space shuttle
better than what we’ve got. If he’s sitting there with his head hung low, mum-
bling, and gazing at his shoes, the only thing that goes through my mind is
“Loser!” Regardless of how incredible your credentials, people just can’t shake
those visceral reactions. That impression will nag at them, they won’t hire you,
and they may not even be able to say why other than the fact that you just
somehow didn’t seem right for the job.
Sit up straight. Try to relax and act like you’ve done this before. And for
heaven’s sake, try to smile and be a pleasant person to be around! They’re
hiring more than thousands of lines of code. They’re hiring a new team mem-
ber, a comrade with whom they’ll survive stressful times, someone they’ll
doubtless be pulling all-nighters with. If you’re not someone people want to
be around, then all things being even moderately close to equal, they’re going
to hire the guy who is.
Spend some time in front of the mirror. Practice talking out loud. Watch
yourself and see the image you present. Listen to the sound of your voice, your
tone; hear how happy, sad, angry, or apathetic you sound. Then do something
about it and keep practicing until you’ve knocked the most obvious sharp cor-
ners off your persona. This may be uncomfortable, even bordering on excruci-
ating for some. However, it ain’t nearly as bad as being hungry because you’ve
been out of work for a year.
Another important thing for potential employers to see is honesty. Have
some integrity. I’ve threatened to take sticks into interviews so that I could just
slap the next person who tries to fake his way through a question. If you don’t
know the answer, say “I don’t know.” In fact, I intentionally put people in that
position just to see if they will. If you won’t be honest with me about whether
or not you know the answer to a technical question, how can I trust you about
anything? Many people try to fake it because they don’t want to look like an
idiot if they don’t know the answer. Trust me. If you don’t know the answer
and try to scam your way through it, you look like an idiot. Be honest. People
admire that.
Along those lines, don’t be afraid to disagree on any issues where you feel
you have a better approach. People don’t want to hire a yes man. They want
someone who can help them accomplish their objectives. If you don’t have a
few ideas of your own, then what are you bringing to the party? The key to
this is in the presentation. There is a distinct difference between expressing a
different view and being confrontational. Even when I’m with people I know,
I frequently make it a point to smile and use polite language, such as,
“Respectfully, I disagree with that last part. Let me explain why. . .” I want
them to know that I don’t think that they, or their idea, is of no value just
because I see it differently. Since programmers are known for occasionally
216
Part III Building a Better Career

offering blunt, straightforward comments without regard for the feelings of
others, this usually gets people’s attention. Additionally, I always make sure
that I’m smiling and have a happy or positive attitude as I explain my points. 
You can contribute a great deal with opposing ideas, and many shops look
for that. However, if you can’t present your ideas without offending everyone
else, your team won’t get much done because people will always be too busy
with their emotions. At the same time, make sure that you demonstrate that
you can approach any issue with flexibility and an open mind. Nobody wants
to play with a guy who always digs in his heels and insists on having things his
way. So, be honest and disagree if that’s the way you see it, but be considerate
and respectful of others. When you leave the room, people will comment on
what a class act you are.
Another thing you want to sell in the interview is something that many
developers lose track of. Make sure these people know that you are a results-
oriented person. Programmers get caught up in how great they are with the
XYZ technology. Nobody cares. What they really care about is whether or not
you can deliver high-quality code and meet their deadlines while using the
XYZ technology. They’re not hiring you to write code. They’re hiring you to
produce results for the company. However, this is something that many pro-
grammers don’t really understand, which once again gives you the edge.
When being interviewed, I always let people know that in terms of
strengths and weaknesses, my talents and experience were geared toward
delivering the goods in the corporate world, where deadlines are typically
ridiculous and getting it done on time is more important than spending count-
less hours optimizing the performance of a couple of loops to the nth degree.
I would openly admit that if they needed someone to write the smallest, tight-
est, most efficient code, I probably wasn’t the best guy for the gig. On the
other hand, since my priorities were deadlines and writing maintainable code,
if theirs was a less-than-perfect environment where unreasonable demands
were the order of the day, I had a proven track record of being just what they
needed.
In other words, I sold my skills, in an honest manner, in a way that pre-
sented them as results-oriented and benefits-based. If my specialty had been
writing super-efficient code, I would have sold that in exactly the same way.
Do your research. Know the results they need. Then sell them on how you’re
exactly the results-driven person they’ve been dreaming of.
In a similar vein, I promote myself as a self-starter, someone who looks for
the problems and takes the initiative to solve them without needing to be led
by the hand. If I don’t know how to do it, I know where to find the informa-
tion and I can teach myself. In fact, I’ve been hired a number of times over
the years by people who have told me afterwards that I didn’t have the skill set
or experience that they were looking for. Yet, they hired me anyway, because
they could tell that I was a guy who could get the job done for them. And that’s
what people are looking for.
Chapter 13 Get a Job (Sha na na na. . .)
217

Throughout all of these interview considerations, I’ve emphasized being
friendly, cooperative, and personable. An interview is a sales job, and I have no
problem with the concept of selling something, especially myself. However,
just as politicians, lawyers, and other such professions are the eternal butt of
the joke at countless parties, so too are salespeople. They are seen as sleazy,
smarmy, insincere, dishonest, and just not the kind of guys you’d want to buy a
used car from. And yet, when you’re on an interview, a salesman you must be
if you want to land the job. As in many other social aspects of life, the key lies
in sincerity. Show them how great you’ll be to work with; show them the bene-
fits and results that you bring to the party; and show them that you’re an
honest, dependable, and trustworthy person.
If you follow all of this advice, you may be surprised at how often you beat
out many other people for the job, even though they have more experience or
better qualifications. It’s assumed that you can code, but then, so can everyone
else. Take all the extra steps that your competitors ignore, and you’ll rise to the
top of the stack every time.
218
Part III Building a Better Career

A lot of us got into programming because we love to create software and make
computers do cool things. The fact that we make our living in the software
development industry is another matter entirely. Even though coding is fun,
working in a corporate environment can suck all the life out of the experience,
which is why many programmers spend their spare time at home working on
software that’s more fun to develop. When you add the distractions and obsta-
cles we encounter in the business world to the current less-than-ideal status
of the IT industry as a career path, you might be thinking that it’s time for a
change. And depending upon the kinds of things you enjoy in addition to
coding, you may well be right.
Captain, She Canna Take Much
More o' This!
If you got into this business because the money was good and the work was
fun, you might feel like you’re coping with things these days that you didn’t
exactly sign up for. It may even seem that someone changed the rules of the
game when you weren’t looking. In fact, that’s exactly what happened.
When I got into the programming business in the 80s, there were a lot of
jobs available and more coming every day, and they paid quite well. This con-
tinued through the 90s as well, so opportunity was everywhere. Best of all, it
seemed like there was a great deal of potential to do something new that hadn’t
already been done to death. No social or economic trend is ever simple, so it’s
safe to say that many things contributed to the IT slowdown that we grapple
with today. However, a significant part of the problem is that over the past
couple of decades, more and more people have joined the industry and written
a staggering amount of software. Even a healthy job market would be flooded
219
Career 2.0
14
C
H
A
P
T
E
R

with competition, and worse, when it comes to writing the next Killer App,
many of us face a severe case of blank page syndrome, feeling that it has all
been done before. 
As long as we can keep our jobs and maintain our standard of living, there
are a lot of creative compromises we’re more easily able to live with. However,
when job security is nonexistent and the prospects of finding that next job are
not so rosy for the average programmer, many start rethinking their career
paths. It can be difficult to throw a long marriage with computers and technol-
ogy out the window (and the security folks aren’t all that crazy about you even
opening your window, given their proximity to whatever happens to come
flying out). Even if coding is a more difficult way to make a living than it used
to be, being a part of the software development process is still, to many, com-
pelling. One possible solution to this dilemma is to transition into a new area
of the IT industry.
Life Beyond Coding
Depending on your background, and of course the kinds of things you enjoy
doing, a number of options are open to you beyond sitting in front of a com-
piler. For those of you with some leadership skills and the ability to cope with
the political realities of the cubicle jungle, you might consider stepping away
from the keyboard and moving into project management. If your love for soft-
ware has not diminished, this gives you a new opportunity to make a differ-
ence in the overall success of a company’s projects.
You’ll need a number of skills that aren’t always required as a coder.
First and foremost, if people skills are important for programmers, they’re
absolutely paramount in a project manager. When you manage, in any capacity
and regardless of industry, it’s fair to say that the job is all about people. You
have to be able to listen, understand, and motivate. Communication skills are
also critical, not only between you and your development team, but also
between you and your own manager.
In addition to all of the obvious development process abilities, outlined
in countless high-quality books, you’re going to need a great deal of political
savvy. If you don’t like politics, then stay out of management, for it is an
inescapable reality of that career path. However, this also gives you the chance
to do something for your developers that no one ever did for you. A good
manager is a shield for his people. He takes all the corporate and political
skirmishes on himself, protecting his people from distractions so that they can
do the job they were hired to do. If you’re not wild about company politics but
you believe in the cause of software development and are sympathetic to the
plight of the common developer, you can make a real difference.
Although there are fewer management jobs than those involving coding,
you’ll find that the competition is also greatly reduced. One very obvious
220
Part III Building a Better Career

reason for this is that most techies would rather work with technology than
manage others. If you’re in a position where it’s getting harder and harder to
find the kind of programming job you want, project management may not only
be a rewarding direction for you to pursue, but it can also be a career path
that’s relatively more stable and secure.
One other thing makes management a beneficial choice for many:
although no one likes to talk about it, age discrimination is rampant in the soft-
ware business. There are a couple of obvious reasons for this. First, from a
bean counter’s point of view, why would they want to pay the old guy the high
salary that he has worked his way up to through years of experience when they
can hire some young guy right out of college who will enthusiastically take on
the same job for a fraction of the money? This approach also takes advantage
of the young guy who’s talented and excited about the career, but lacks the
street experience that would let him know what he’s really worth and when
he’s being taken for a ride.
The other motivation for discriminating based on age is more subtle.
Having lived only in America, I can’t say what it’s like in other countries, but
in our culture, we do not honor our old people. In fact, even the word “old”
carries with it negative and insulting connotations in our society. There are a
couple of magic numbers that Americans respond to as well. At 40, you’re not
only old, you’re “over the hill.” At 50, you are a “senior citizen,” officially “old
and in the way.” These factors contribute to a competitive attitude among
many younger people, fueling the desire to get rid of the old guys in order to
make room for themselves. Between these two considerations, the simple fact
of the matter is that the older you get in the programming business, the more
difficult it’s going to be for you to land a job. These are not moral judgments,
but rather a pragmatic look at the way things are today. Ignore it at your peril.
Fortunately for the old guys, management is one of the few areas where a
few gray hairs don’t make you look like someone who should be cut out of the
herd. In fact, management is frequently populated not by the young, but by
the old. I don’t know if this really has as much to do with garnering more skill
and experience over the years as it does with becoming better at politics. In
any event, for those of you who are no longer in your 20s, this can be a much
safer career path than coding.
Ironically, however, age discrimination exists here as well. We have a
wealth of brilliant young people with great leadership skills who would be
excellent managers, but they encounter the same prejudice in reverse. Instead
of being judged on their talents, they’re dismissed as being too young and
inexperienced, as if the two were synonymous. Once again, it may not be right,
but it’s a reality in our industry. Consequently, I would highly recommend that
younger developers start looking for ways to incorporate management and
leadership tasks into their careers as early as possible. Additionally, it’s even
more critical for you to accept the fact that politics are a powerful force and
become good at handling them. Even if none of this is appealing to you today,
you may find down the line that you’d like to move up in the food chain. Or,
Chapter 14 Career 2.0
221

who knows, you might even get old one day. In either case, it’s a good idea to
already have yourself prepared, so that when you want to make the move to
management, you’re not facing unnecessary obstacles.
Keep in mind that software project management is not the only lateral
move that a programmer can make. Throughout the average company, dozens
of groups and departments intersect with the IT department. Each of these
intersections is a gateway through which your career can make a transition.
If you have good management skills and are adept in the ways of company
politics, you’re not limited to project management. If you can establish a con-
nection between the work of your department and that of another workgroup,
you have a way to justify moving into management in a completely different
department. This takes some creativity and personal salesmanship, but to a
certain degree, a good leader is a good leader. Many management sorts recog-
nize the fact that you can teach workgroup-related skills to a person with char-
acter and charisma, but it doesn’t work in the opposite direction. Therefore,
if you can demonstrate that you’re someone who’s qualified and destined to
lead, you can pursue opportunities anywhere, provided you can make that link
between what you’ve done in the past and what you’d like to do in the future.
Another direction open to programmers is working in or with the sales and
marketing department. Even if these are the very people who have caused you
headaches with previous deadlines or feature changes, recognize that if you’ve
got what it takes, there’s a career there for you to pursue. If you have the per-
sonality for it, you could move into actual sales and marketing work, bringing
you complete freedom from the volatility of the IT job market. Why? If you
can sell, you can sell anything. It doesn’t matter what the product is. Every
company will be delighted to have you if you can move the merchandise.
Your opportunities with marketing don’t stop there, though. In the soft-
ware business, it’s extremely common for the sales force to have dedicated
techies who help them make sales by explaining to customers all the technical
stuff that salespeople never want to know about. A variation on this theme is
the person who is the liaison between the marketing and development depart-
ments. This position is a great opportunity for someone who can speak both
marketing and tech, as we all know how difficult it can be to deal with sales-
people who can’t communicate their needs or desires in a language that we
understand and can implement.
These options lead to similar possibilities in organizations that have train-
ing departments. If you can learn the skills you need to teach others, then who
better to have on that staff than someone who truly understands how the soft-
ware, or any software for that matter, works? It’s also not a very long jump
from training to installation. Many large corporate IT departments develop
internal software that needs to be installed throughout the company. Again, if
you have a more intimate technical understanding of things, you’re a valuable
asset.
222
Part III Building a Better Career

Of course, installations often involve hardware considerations, giving you
yet another direction to consider. With the rise of the Internet and of large
internal company networks, becoming a networking guru is also an excellent
opportunity. 
One thing that all of these options have in common is that while not
outsourcing-proof, they’re positions that are much more likely to be retained
internally, as it makes more sense to have these resources locally. This leads
to greater job security, which is one of your goals.
You can also stay closer to the actual development of software by shifting
to technical writing or, for those rare shops who actually have a testing depart-
ment, quality assurance work. In fact, the semi-entrepreneurial among you
might even be able to create a testing department where none previously
existed, with you at its head.
Where’s a Compass When You
Need One?
Of course, if you just can’t bear to step away from the compiler but you’d like
to find ways to improve your chances in future job searches, then the changes
to consider are technological ones, rather than a lateral or upward shift in your
job description.
As a case in point, when I was coding for a living, I was a Microsoft
Windows/C++ guy. This path served me well for many years. However, with
the rise in popularity of the Internet, the software community soon became
obsessed with all things Web-related. These days, there’s an ever-growing
movement towards these priorities. To many, it doesn’t matter what the
requirements of the software are or who the customers may be, it absolutely
must run in a Web browser. There are, of course, benefits and negatives to a
browser-based approach that will vary wildly from project to project, but in the
hearts and minds of techies, that just doesn’t matter. The Web is relatively new
and sexy, and everyone wants to play with it. Management, which often can’t
even spell the word browser, will often jump on the bandwagon and declare
that all applications must henceforth run on the Web just because they know
it’s trendy.
So where does that leave a C++ guy? Learning Web-related technologies,
of course, which is rather my point. Just as many COBOL guys learned C and
C++ when they saw the writing on the wall, so, too, does the move towards the
Web show the way for desktop developers. Of course, these are just specific
examples. The real point is that if you want to keep coding for a living, you
may need to reevaluate the platform you work with. The questions you’ll want
to ask yourself are related to the movement of jobs. What operating systems
Chapter 14 Career 2.0
223

and programming languages are the most popular today and have the most
promise for staying power? What specific technologies within these groups
are solid, marketable skills? In short, where is the work going to be?
I made a decision early on in my career. I realized that UNIX and
Microsoft technologies both provided a good career path, and decided to pick
a direction and dig in. Why was Apple not a contender in this decision-making
process, especially when Macs are such great machines? Easy. Any time I
opened the paper, there were no listings for Apple programmers and hun-
dreds for UNIX and Microsoft guys. I have no religious preference for any
technical camp. All I cared about was having fun programming in an environ-
ment that provided good potential for a career. If you want to retool your
skills, these are the considerations you need to think about as well.
There are a couple of different angles on this as well. First, instead of
picking a development platform, you might consider things like becoming a
systems programmer rather than an applications developer. As an example,
depending on the external hardware you’re writing device drivers for, it might
make more sense to keep the jobs local if shipping and maintaining the equip-
ment in another country would pose a business problem.
Choice of industry can also lead you into safer waters. The last job I had
prior to making my escape from tech into full-time writing, speaking, and
training was in the air traffic control industry. In fact, I spent the tumultuous
years after 2000 in an isolated little island that depended not on the general
software market or industry, but instead serviced the FAA. Since the company
I worked for depended upon government contracts, we weren’t tossed about
by many of the sea changes in the IT industry. There are many industries out
there in the same situation. These include not just government contract work
operations, but isolated vertical market businesses whose customer base does
not make them as likely a candidate for corporate takeovers, global outsourcing,
and all the other little adventures we’ve lived through lately. It’s yet another
train of thought to pursue in your quest for a more stable programming career.
One last thought. Sometimes backwards is forwards. And no, I haven’t
been drinking—honest. Just the other day, I was reading an article talking
about the impending crisis looming over some sectors of IT as the old guys
with specific knowledge prepare to retire en masse. Among the examples
given were those who worked on the big iron mainframes. This is not a sexy
career path for programmers, and most guys who actually go to college for IT
aren’t dreaming of a job writing COBOL or mainframe assembler. However, if
you’re faced with working or not working, this is also an opportunity. There are
tons of data on mainframes throughout the world, and they were very expen-
sive. Corporations aren’t going to just put them in the trash and go buy a couple
of PCs to store their data. That means they’re going to need people to main-
tain and expand these systems, and given the current brain drain from the
baby boomer generation retiring, this could translate to higher rates through
increased demand.
The mainframe scenario is but one example. This sort of thing happens
all the time. Companies invest heavily in a technology that does the job.
224
Part III Building a Better Career

Consequently, they’re not cost-justified in moving to another platform even
when it becomes outdated, much as the techies would prefer otherwise. If you
get creative in your thinking, you’ll see a wide range of skills out there that
companies still need, but that younger people are not being trained in. That
means both money and something that’s in short supply in the current job
market—security.
Abandon Ship!
If you’ve spent any time grappling with the IT job market and felt like you
were beating your head against a wall, you may have been perceiving things
correctly. It’s all too common for people to get set in their ways and overlook
the fact that we often have a tremendous amount of flexibility in how we live
our lives if we but have the courage to try. However, a great many people go
through their entire life with the assumption that a person is allowed one, and
only one, career. The rules are simple. You choose a way of making a living
(or have one thrust upon you), perhaps go to school, and then spend the rest
of your days climbing the corporate ladder within that context. This is a very
traditional way of thinking. While not without value, it is certainly not the only
choice.
I have been extremely fortunate in my years, as I’ve had the opportunity to
make a living doing something that I truly loved, something that I would often
do on my own time for free. Many of you feel this way about programming.
Any day that you drive to work excited about the tasks that lay ahead of you,
take a moment to look around you on the road. You’ll see a lot of unhappy
people who are dreading their workday, as they may for the rest of their lives.
This alone should tell us how lucky we are to turn our passion into our living.
And if that was all that I’d experienced, I would still count myself as lucky.
However, I’ve done this not once, but four times now. I’ve paid the bills as
a full-time musician, which is quite literally getting paid to play. I spent many
years in the sales business as head of a consulting firm, teaching the employees
of my clients how to do better. I found that I truly loved teaching and helping
people improve the quality of their lives, and it was great fun. Then I got the
programming bug and spent over a decade playing with computers for a living.
Somewhere in the middle of all that, I started writing and speaking, which is
now my livelihood. They are in many ways the best of both worlds to me. I get
the creative rush from writing that I do from programming or playing music.
Doing keynote speaking, workshops, and seminars lets me indulge my desire
to play to a live audience while at the same time giving me the gratification of
once again helping people improve their lives.
I’m now well into my fourth successful career, with each of the previous
ones being pursuits that I enjoyed every bit as much as you enjoy coding. And
I’m only 47. Imagine what I can accomplish in my next 50 years. Best of all,
I’m nothing special. I didn’t go to college, I didn’t grow up rich or privileged,
Chapter 14 Career 2.0
225

and in the most fundamental ways, I’m just not that different from anyone
else. The only real advantage I possess is a complete disregard for the assump-
tions of others. People will always be quick to tell you what’s unrealistic, what’s
impossible, and why you can never achieve your dreams. Your greatest limita-
tion, however, is often little more than your own thinking. Once you believe
you can make a change, you’d be surprised how easily it comes.
If you’ve been in the IT industry awhile and it’s no longer working for you,
you need to stop and ask yourself if it’s time to move on. For some people,
careers don’t last a lifetime. If you dove into programming with great enthusi-
asm and really lived it up for a long time, maybe you’ve done all that there is
to be done in this direction. Do you have other dreams and desires? Are there
any other things in life that you really have a great time doing? If the software
business is no longer the fun time it used to be, perhaps it’s time to get out of
tech altogether and follow a new passion. Sometimes the greatest inspirations
come in the form of a brick wall. When you can no longer move forward, it
forces you to think of where you want to go next.
Where Do We Go from Here?
The first step in considering new careers is to spend a little time thinking
about the things you enjoy doing. To my way of thinking, the best career is one
that pays you extremely well to do something you would have done for free. So
there’s your first exercise. If you were independently wealthy and never had to
work another day in your life, what would you do with your time? For a lot of
people, paradise would be days on the beach doing nothing but soaking up the
sun. I rather doubt that this works for most programmers, because we’re cre-
ative creatures by nature. A week or two of leisure might be okay, but after
that, you probably want to get out and do something. What would it be?
Make a list of all the things you’d spend time doing in this perfect world.
Next, engage in a little free-floating research. Poke around on the Internet,
visit a library or two, leaf through the business section of the phone book con-
sidering the categories. What pursuits do you encounter that interest you?
You’ll find that as you let your spirit wander, one thing leads to another, and
you’re considering things that you wouldn’t have thought of before. As you
find new things that are intriguing and exciting to you, add them to your list.
The last batch of things to add to the list are the things that you know how
to do. When you’re done, you’ll find that you know how to do a lot of things.
Don’t get bogged down in rationalizing whether or not you could pay the
bills with this knowledge. That comes later. Right now, you’re just fishing for
possibilities.
Got a list now? I’ll bet it’s a long one. Spend some time over the next few
weeks considering all the entries. You’ll find that after the initial excitement,
some are still interesting but others are absolutely compelling. Take your time,
and prioritize the list, and you’ll soon have a wealth of options to consider.
226
Part III Building a Better Career

Turning Passion into Paychecks
Knowing what you enjoy is a good exercise, and as you may find, the answers
aren’t as obvious as people would think. However, this knowledge alone is not
enough. The next question is a very important one. How will you get paid
doing what you love? 
Actually, although this question is indeed important, in many ways, it’s also
pretty easy. For each passion on your list, consider the various industries that
have arisen around it. It’s very unlikely that there are things that you enjoy that
no one else on the planet cares about. Consequently, it will show up in the
business world. Therefore, beneath each passion, you’ll list all the different
career opportunities, whether they are working for someone or going into
business for yourself. This answers the question of how you’ll get paid. A rele-
vant consideration, however, is just exactly how well each of these fields pays.
You also need to spend a little time considering how much money you care
about making. These two considerations, combined with how appealing each
career path seems, will allow you to prioritize the career options available for
this passion.
One of the things I love about the software industry is that you don’t have
to spend 10 years in college to get into the game. I made a good living and
had a great time with no college at all. However, whether it’s college, board
certification, or any number of other considerations, each career will have its
requirements. For programmers, the only real requirements are the ability to
write bug-free code and meet deadlines (I figure one out of two must be okay
since they let me stick around). A career as a lawyer carries more stringent
educational requirements, along with the necessity for certification. For each
career opportunity, do your homework and list the requirements that you’ll
need in order to get into the game. I’d like to emphasize the word requirement
here. There are those in the software industry who feel strongly that all devel-
opers should have a college education. If you listen to them, you’d be tempted
to state that you can’t become a programmer unless you first go to school. As
we all know, this is not a requirement, but rather a preference by some in the
community. Preferences can’t keep you out of the game. Requirements can, so
make sure you understand the difference as you continue to refine your list.
Experience is another factor in getting started. Even if there are prefer-
ences for certain types of education or training, people often value street
experience more than academic pedigrees since you have hands-on knowledge
of how things work in the real world. You’ll need to list what kind of a back-
ground is required, what’s preferred, and what you already have behind you
that can contribute to your chances of getting into that industry.
You should now have quite a list—one that is prioritized and shows your
favorite pastimes, the career opportunities available, how much they pay, and
what you need to do in order to get started. The next thing to consider is the
transitional phase of moving from software to your new career. You’ve built
your income up to a certain level as a programmer through your experience.
Chapter 14 Career 2.0
227

You need to be prepared for the reality that, in a new industry, you’re starting
at the bottom of the food chain again. Particularly if you have some years and
life experience behind you, you don’t have to spend as long moving up this
time around, but you’ll definitely be on the low end of the pay scale, at least
in the beginning. You need to be financially prepared to handle that.
One option is a savings account built up during the programming years
that can carry you into your new career. You can also look at it from a different
angle. Is it possible for you to work two jobs, continuing your full-time pro-
gramming job and working part-time in your new career? This gives you a way
to gain experience, increase your pay scale, and perhaps even stick that extra
money you make in a bank account as an added measure of safety. For those
of you who share a home with your partner, you have another option. If you
both work, is it possible that your partner’s income can provide the cushion
you need to get into the new career and cover you while you bring your pay
up to what you need? And, of course, you can always consider taking a look at
your expenses with an eye to reducing what you can live without during the
interim. Most of all, you simply need to be practical and prepared, so that you
can make a safe and smooth transition to your new career.
Assuming you’ve spent the time and met the minimum requirements to
get into your chosen new field, you’ll need to consider just how you can get
that all-important first job. The dilemma that we’ve all faced at one time or
another is that people want you to have experience before they’ll hire you,
but you can’t get experience unless you get hired. Or can you?
Especially with the ability to put up a Web site and do business from your
home, in many careers, you can get into the game by doing a little side work
for others. In fact, it’s sometimes worthwhile to do a small job for a couple of
people for free so that you’ll have both experience and references. As part
of your agreement, you won’t charge them, but they won’t divulge that you
worked for free, which would damage your credibility. No need for them to lie.
They need only say that they don’t discuss their financial arrangements with
others. Worried about how to get even those first few chances? Check with
your friends. Chances are good that you can either do it for them or for people
they know. This experience not only helps you get your first job, it may even
let you start out at a higher than entry-level salary because, after all, you’re not
entry level—you have experience.
Networking and referrals will also serve you well. It’s certainly possible to
go through the traditional job search routine of reading help wanted ads, but
an introduction from a friend is always a valuable thing. Go back and reread
the chapter on getting a new programming job, only this time, think of it in
terms of your new career. You’ll find that many of the same principles apply.
Only the names are changed.
Bear in mind that even if the transition is a bit difficult, you’re going to be
alive for a long time. Transition phases by their very definition don’t last for-
ever. However, if you do nothing, this time years from now, you may find your-
self in a very difficult position—one that could last indefinitely. So do your
homework, be prepared, and then go for it. There’s no limit to how many
228
Part III Building a Better Career

careers you can have in your life, so if you’re getting bored of IT, find some-
thing new and exciting. If you’re smart enough to program computers, you’re
certainly smart enough to manage a career change.
Whether you’re looking for another programming job, making a lateral
move to another job description in the IT world, or setting off on a new adven-
ture, you’ll always meet with success if you keep your plans practical and treat
people well. If you’re someone who’s a joy to work with and you understand
the realities of any situation you may find yourself in, there’s very little that you
can’t accomplish.
Chapter 14 Career 2.0
229

Whether it’s because of the conditions of the current job market or simply the
desire to go out and do their own thing, many programmers will at one point
or another consider hanging out a shingle and starting their own software
company. This can be a great way to make a living, as it not only allows you to
continue doing what you love, but also provides the freedom that comes with
being your own boss. If you’re going to make this jump, though, you need to
step back and consider the big picture, for it’s a much different life than work-
ing as someone else’s employee. 
Many people believe that running a successful software company is all
about the code. In fact, nothing could be further from the truth. If all you
want to with your day is sit back and program, your best bet is either working
for someone else or just pursuing it as a hobby. If you go into business for
yourself, you’re going to have to manage a much wider array of details. You
can still code, even to the point of being the only programmer. You just have to
make sure that everything else gets taken care of, or you’ll be out of business
in a heartbeat.
One of the great things about developing software is that you can really
do it just about anywhere. All you need is a computer with a compiler, and a
steady stream of junk food. Given the power of today’s laptops, with enough
batteries, you could seclude yourself on a tropical island and not be seen again
until version 1.0. As tempting as that may be, most individual programmers
who decide to fly solo start out by working from home. It’s sensible, as it avoids
unnecessary overhead. It’s also nice to be able to work in your robe and bunny
slippers, just moments away from the kitchen.
Some folks are worried that if they work from home, they won’t get any-
thing done, but in the case of programmers, the real danger is that they won’t
get any sleep. But then, we never sleep anyway, so I don’t concern myself
much with these things. If you have a family, however, you’ll need to approach
a home-based business with the same discipline that you had working for
someone else, or you’ll stumble into the kitchen one day to find that they’ve
231
Flying Solo
15
C
H
A
P
T
E
R

taped your picture onto the side of a milk carton. Keep your priorities straight.
You’re in this for the long haul, and without the support of your family, it just
ain’t worth it.
Another benefit of being self-employed is the potential for unlimited
financial gain. When you work for someone else, there’s always going to be a
practical limit to how much money you can make. When you’re in business for
yourself, there is no limit. Remember, Microsoft started out as a handful of
scruffy looking broke hippie types in the beginning. They don’t look so broke
anymore.
The other side of the coin is that you have no guarantees. You can make a
gazillion dollars, or you can make not a single penny. Consequently, you need
to make sure that you’re practical in your approach to a new venture. Hungry
programmers make poor entrepreneurs. 
It’s a given that you enjoy programming, or you wouldn’t have gotten your-
self into this business in the first place. Running a business is a completely dif-
ferent way of life. You may find that it’s every bit as intoxicating as coding was
when you first started. Bear in mind, though, that like anything else, you have
to enjoy the game or you’re just not going to be very good at it. 
Give all aspects of the entrepreneurial lifestyle your full consideration
before moving forward. It’s one thing having a job you don’t like. You’ll be
unhappy, but you’ll still get paid. If you’re unhappy as a business owner, you
may very well be unhappy and unpaid. As you might imagine, that’s not a par-
ticularly good combination. However, for the creative and adventurous among
us, there’s just no rush like that of succeeding with your very own venture, so
let’s dive into the details and explore the various areas that you’ll need to con-
sider as you put your company together. 
Many Hats
As a programmer, you may have had to manage a few things beyond coding,
but they were generally technical in nature and therefore familiar territory to
you. In your own business, you’ll also have many responsibilities, but they
might not be the sort of things you’ve done before. Although some of these will
be pretty obvious, it’s worth touching on them all just to be on the safe side.
Legalities
No matter what kind of software or services you’re selling, you’re doing busi-
ness with other people. They might be individuals or companies, and some-
times your customers will fall into both categories. From licensing agreements
to contracts and beyond, there are going to be times when you have to deal
with the legal side of doing business. Occasionally, common-sense practices
are enough to keep you out of trouble. Nonetheless, you need to be both
232
Part III Building a Better Career

mentally and financially prepared to bring in the services of a lawyer from
time to time. This is especially true given the continually evolving status of
intellectual property rights, software piracy, and other legal ramifications of
life in a digital world.
In a perfect world, you’d call your lawyer for each and every little legal
detail. For a startup company with little or no venture capital, that’s not always
realistic, given the fact that the legal profession is well known for being a bit
expensive. Therefore, you’ll have to make judgment calls in terms of when to
bring in the professionals and when you can do it yourself. As an example of
the latter, a number of books provide you with all the information and forms
you need to create your own corporation, and you’ll find similar resources for
standard contract templates and other such documents. Ultimately, you’ll
have to decide how comfortable you are doing these things yourself. When
in doubt, hire a professional, especially when you need to cover your legal
posterior.
When starting your company, you’ll need to make a number of important
decisions up front, such as whether or not to incorporate and what interaction
and filing you’ll need to do with local, state, and federal government agencies.
You’re not writing software; you’re starting a company, and the same rules
apply to your business as to any other. It would be a good idea to read a few
books on the basics of starting your own company. There are a lot of them out
there, and many offer both general advice and specific recommendations
depending on the laws of your particular state.
Starting a new business is not rocket science, but it involves many impor-
tant legal details, both in the beginning and in the day-to-day operations.
Educate yourself on what needs to be done, and also realize that dealing with
legalities will consume a certain percentage of your time each month. 
Accounting
Along those same lines, you’ll need to open a bank account, set up your books,
and make a number of financial and budgeting decisions. There are a number
of excellent small business accounting software packages out there that are
very reasonably priced. The best thing to do is to find an accountant that
you’re comfortable working with, preferably through the recommendation of
someone you trust, and have an initial consultation with him regarding what
the best accounting method and setup is for your business. After that, you’ll be
able to do a lot of the bookwork yourself, and can call in your accountant for
specific needs, such as taxes. 
I can’t overemphasize the importance of finding a good accountant, mean-
ing one who is competent, has enough time to properly take care of your
needs, and is honest and trustworthy. Don’t assume that just because someone
is in business or has a nice-looking office that any of these apply. You don’t
want to find out the hard way that your accountant left you hanging out to dry.
This is personal experience talking here. Don’t ask about the battle scars.
Chapter 15 Flying Solo
233

My current accountant is someone I found through a close friend who man-
ages a small office. I asked who her accountant was, if she was happy with him,
and if she’d recommend him for me. All the responses to my questions were
positive, and I couldn’t be happier. He has saved me money and also kept me
on the straight and narrow, and every time I write him a check, I whistle a little
tune. Talk to your friends who are involved in small businesses and find some-
one like this, and you’ll sleep much better at night.
Taxes
No matter what country you live in, you’re going to have to pay taxes. Your
accountant is your best friend when it comes to dealing with the government,
and the government is the last entity that you want to antagonize. The first
rule of running a business, especially for small, self-employed types, is simple
and imperative. Every dollar you make is only fifty cents. The other half goes
to taxes. If you think along those lines, you’ll find that it’s a modest overestimate
of taxes, but it’ll keep your head in the right place.
When you work as an employee, at least in America, your company takes
the taxes out of your pay before you get your check. I’ve seen a lot of people
go into business for themselves and spend the money that they bring in from
their customers as though it were a paycheck. Eventually, it comes time to file
and pay taxes, and they have no money in the bank. It’s not a good place to
be, and a little financial discipline will go a long way.
One last note on accountants and taxes. In the end, you’re the one who has
to make the decisions, but I strongly advise you to be conservative in the tax
deductions and accounting games in which you partake. Accounting is not a
black-and-white process. There are a lot of different ways to do things, and
many accountants will advise you to pursue some rather creative deductions
and procedures. Although not illegal, anything that’s in the gray area can put
you at odds with your government should there be a dispute. At best, you get
audited and spend a lot of stressful time defending the accounting choices you
made. At worst, your deductions can be disallowed, you can be assessed inter-
est and penalties, and in extreme cases, even have criminal charges brought
against you. I may not get every single tax break I could pursue, but I’d rather
play it straight. In the long run, it’s much less wear and tear on the nerves.
Administration
Running a business means shuffling paper. There are government reports to
file, invoices and statements for your customers, bills to pay, records to keep,
and a host of other things just waiting to fill up your file cabinet. Most of this is
more tedious than difficult, but in terms of how you manage your time, these
are once again details that will chew up a certain amount of hours each week.
Unless you hire someone else to do these tasks for you, you’ll need to budget
your time accordingly.
234
Part III Building a Better Career

Management
In the corporate world, we often grumble about the managers who are making
demands, setting deadlines, asking for progress reports, and in general bothering
us with all the day-to-day details of running a business that they’re personally
responsible for. Although they’re pesky creatures when you work for someone
else, once you go it alone, you’ll realize that suddenly you’re the manager.
Even if you have no employees, you’re the one who’s in charge of every single
aspect of your business. From high-level decisions such as equipment pur-
chases and company strategy to the finer details of what your priorities are for
this week, you’re the man. When you see how many hours it takes out of your
week, you might find a new appreciation for your previous boss.
Marketing
Speaking of the people we love to hate, one of the most fundamental mistakes
people make when starting a new business is to minimize the importance of
the marketing folks. Back when I ran a sales consulting company, one of my
clients was a family-owned newspaper startup. They had capital, and they had
great offices. Various family members had been in the business before, so they
understood layout, printing, and all the other aspects of putting out a first-class
publication. I asked them what their plan was for selling advertising and sub-
scriptions. They told me that they figured Uncle Joe could handle that. When
I asked what kind of sales and marketing background he had, I was shocked to
find that he had none whatsoever.
Stop and think about this for a moment. A company’s primary reason for
existing is to make money. That means generating revenue. People in sales and
marketing are professionals at bringing in this money. I consider this to be the
single most important job in the business, for if no money is coming in, you’re
out of business. Are you good at sales? Do you have any experience at it? Does
your Uncle Joe? Unless the answer to these questions is a resounding yes, you
need a plan, and you need help. Joke about the marketing guys all you like,
and I’ll be right there with you. However, before you even think about starting
your own company, you need to first consider exactly how you’re going to
sell your products or services. You can make mistakes in many areas of your
business and still survive. Screw this one up, and you’re toast.
Customer Service
If your business is to thrive, you’ll need to have customers. We can all agree
that this is a good thing. However, no matter how good your product is, you’re
going to spend time occasionally helping your customers with problems they
encounter. A shipment could get lost or damaged. Their check could bounce.
They might have problems with your online ordering system. The list is
endless.
Chapter 15 Flying Solo
235

The mark of a truly stable company is the quality of its customer service.
Yes, you can take the money and run. You can also put together a voice-
response system so that when people call you, they have to navigate fifteen
menus before they’re put on terminal hold. No matter what clever little tricks
businesses pull to avoid dealing with the people who give them money, in the
long run, it’s never profitable. Customers who aren’t treated well defect to the
competition, and they never tell you that they did or why. Consequently, good
customer service is absolutely critical. You need to treat customers like gold
because, in a very literal sense, they are. Dare I mention that this will take a
few hours out of your week?
Tech Support
In reading the previous comments on customer service, you were probably
thinking I meant tech support for your software. Nope. That’s a whole differ-
ent area, and yet another significant demand on your time. How you structure
the support you offer, whether or not you charge for it, and who performs it
are all important questions you’ll need to answer before opening your doors.
As you doubtlessly know, tech support is a never-ending issue for software
companies. If not managed properly, it can not only chew up a lot of your
time, but also cost you dangerous amounts of money in additional resources.
There’s no one right way to handle support, but you’ll need a plan, and it will
consume a portion of your week.
Web Site Maintenance
No matter what your product or service, you simply can’t have a credible busi-
ness presence today without a Web site. You’ll also want to have an online 
e-commerce system for some of your offerings. For a programmer, this is no
big deal. I mean, programming is what you do, right? Well, all of these details
we’re covering take time, and nothing chews up the hours like working on
software.
If you’re going to do the site yourself, budget a serious chunk of time up
front, and add in reasonable time each month for maintenance. Alternatively,
you’re going to have to pay someone to do it for you. Don’t let your program-
mer’s ego get in the way. Given the demands placed on your time, sometimes
this is the most cost-effective solution. Either way, you’ll need a Web site, so
you’ll need a plan. And time.
Capital Expenditures
In addition to all the elbow grease you put into your startup, you’ll occasionally
have to pour in some money, too. Whether it’s a new high-volume laser printer
236
Part III Building a Better Career

or just a desk and filing cabinet, there’s a certain amount of physical infrastruc-
ture that any business needs. The good news about this is that it doesn’t take
up that much of your time. Just have your checkbook handy.
Tech Writing
Since you’re in the software business, you’re going to need online help, printed
manuals, or both. Technical writing is a highly specialized skill, and it’s also
boring beyond belief to the average techie. If you’re not going to hire a profes-
sional tech writer, you need to keep a couple of things in mind when writing
your product documentation. First, your customer is probably not a techie
of your caliber, so you’re going to have to write something that mere mortals
can understand. The more difficult it is to use, the more tech support calls
you’ll get. 
In addition to clear and easy-to-understand language, how your documen-
tation is formatted and presented has a huge impact on its usefulness. One of
the best guidelines to follow if you’re rolling your own is to study the best
examples of documentation you can find and learn from their style. Remember,
you can’t take your product to market until the documentation is done, so
allocate time or money accordingly.
Testing
This shouldn’t take much explanation. If you don’t adequately test your soft-
ware in many, many different environments prior to selling it to someone, the
word on the street will be that your product is pathetic. A bad reputation will
destroy your business in a surprisingly short amount of time. This is your liveli-
hood on the line, so you need to take testing more seriously than ever before.
That means a lot of time to do it yourself (bad idea) or money to get someone
else to do it for you. You might be able to trade products and services in
exchange for testing, as is common with beta programs. However, don’t short-
cut this critical phase of development, or it’ll cost you dearly in the long run. 
Oh,Yeah, and Programming
You should now have at least three and a half free hours left in each week.
Congratulations, you can now sit down and code. Of course, I’m exaggerating
a bit here, but not nearly as much as you might think. Whenever possible, it’s a
good idea to finish your product completely before starting the business, for
reasons that should now be apparent. Once you start raking in the dough, you
can hire programmers to help you with version 2.0. However, in the begin-
ning, even if it’s just bug fixes and minor feature tweaks, you’re not going to
have nearly as much time to code as you’d like, so make sure you have a plan
for how you’re going to get it done.
Chapter 15 Flying Solo
237

Getting the Picture
Another thing that’s commonly overlooked when going solo is the overall
vision of your enterprise. I know this sounds really silly, but you need to have a
clear and concise idea of exactly what your product or service is before you can
open your doors. As talented programmers, it’s easy to think that we can do all
things for all people, and perhaps we can. However, that’s a marketing night-
mare waiting to happen.
Not only do you need to know the specifics of your offerings, you need to
have a solid grasp on what kind of pricing will be effective. There are a num-
ber of questions to answer before you can even get this far, though.
 Who, specifically, are your customers?
 How do you reach them?
 What will it cost you to reach them?
 How many competitors do you have in this marketplace?
 What do they charge?
 What makes you better?
Another factor in your pricing is your cost of making the sale. There are
physical, per-unit costs such as your distribution media and packaging that are
easy to calculate. For software, labor costs are the biggest expense, so if you
pay people to code, document, or do any other development tasks, you have
to factor that in at a higher level, along with fixed office overhead and all the
other general costs of doing business. These details raise the question, how
many units do you have to sell to break even on your expenditures and make
a profit? All of these considerations will affect your pricing.
In considering the specifics of your offerings, your costs and pricing, and
how you’re going to reach and sell your customers, you’re beginning to see the
reason that a lot of companies seek investors. You might have to spend a fair
amount of money up front before you can even start making sales, and once
the sales start rolling in, it may be quite some time before you’re turning a
profit.
There are a variety of capitalization options, running the gamut from hitting
your Uncle Joe up for a loan to dealing with professional venture capitalists.
Bank loans and other forms of money are much more straightforward than the
latter option. In fact, one of the reasons for the dot-com bust was that every-
one was starting an Internet-based company by putting together a business
plan and seeking venture capital. They rarely had any real idea of how the
company would ultimately turn a profit. All their efforts went into putting
together a business plan that would sell investors on the company. Optimism
drove stock prices high, but eventually the chickens came home to roost.
238
Part III Building a Better Career

These companies had no real plan for operating as a profitable business, and
the rest is regrettable history. As a side note, venture capital firms typically
require controlling interest in your company, so as soon as you bring one on
under these conditions, you no longer control your own company. Not my idea
of a good time.
Partners are another source of investment capital, and you can probably
guess the long-term problems that come from bad relationships with partners.
Running up credit card bills is also tempting, although given the interest rates
they charge, it’s an extremely expensive way of raising money.
Perhaps the best method is to do everything possible to get your product
ready to sell in ways that don’t cost you money, and then concentrate on gen-
erating revenue rather than acquiring investment capital. Never lose sight of
the fact that your company is in business to generate profitable revenue.
Know Your Weaknesses
When starting a company, a competent person can do a surprisingly large
amount of things on his own. However, nobody’s a rock star at everything. It’s
important to have the ability to draw the line and recognize when you’re just
not good at a given task. That allows you to pursue other options and get
someone on the job who can do it well.
You can actually have a lot of tasks done for you using an on-demand
approach. For instance, if you need to generate product sales literature but
you lack graphical skills, you can hire a graphic artist to do piece work for you.
That way, you pay just for the bit of art you need, rather than hiring a full-time
artist. In a similar fashion, much of your administrative work can be handled in
this manner. College campuses are great resources for this. You give a student
an opportunity to put some professional experience on his résumé, and you
can frequently strike a bargain at a price you can afford.
Sales is another area where you can get results without hiring salaried
employees. Salespeople are used to working on commission, meaning they get
a percentage of each sale made. On a straight commission deal, you pay them
only when you make money. Of course, the more stable and profitable a deal
you can offer salespeople, the better chance you’ll have of bringing on people
that will be dependable. As in all other aspects of business, when you treat
people well, they’ll stick around for more.
In other areas, the need for outside expertise is more obvious, such as hir-
ing accountants and lawyers. As a small startup, the temptation, and indeed
often the need, is to do it all yourself. Sometimes you just have to do what you
have to do, but whenever possible, bring in a pro when you lack the skills to do
it well yourself. It’s an expense, but the payoff of a professional image, good
products, great service, and salespeople who can move the merchandise make
it well worth the money.
Chapter 15 Flying Solo
239

Creating Your Deliverables
You may be selling a physical product, or you might be offering a service of
some kind. Either way, there are usually physical items that require distribu-
tion. The most obvious example of this is the CD or DVD on which your soft-
ware ships. Among the many things you’ll need to research are the best deals
on manufacturing and packaging.
The lowest price isn’t always in your best interest. For example, among the
products I sell on my company site are audio CD courses that teach people
various skills. Because I own a professional recording studio, I’m able to create
a wide variety of content without having to jump through a lot of hoops. This
gives me the freedom to experiment with different concepts and product
ideas. So far, so good.
When you sell a physical product, your merchandise cost obviously has a
direct effect on your profit margin. With that in mind, you’d think that I would
want to get the rock bottom price on having my CDs replicated and packaged.
If I’ve got a best-seller on my hands, this is absolutely true. However, to get
the best price, you have to purchase a large quantity up front.
Currently, the minimum order in most replication houses is a thousand
CDs. Depending on how elaborate you want to get with your packaging
and CD face printing, the prices will naturally fluctuate. However, the going
rate for a nice, professional-looking CD and case is around $1,500 for a thou-
sand units. That means each one costs $1.50, which makes for a decent profit
margin. However, the problem with this is that for every single CD, I have
to shell out $1,500. For a six-CD set, that means I’m out $9,000 before I’ve
brought in a single dollar. And I don’t even know how well any particular
course will sell. Furthermore, to keep the math simple, let’s say I sell the six-
CD set for $90. That means I have to sell a hundred units just to break even.
With close to ten grand out of pocket and no proven track record on how well
a title will sell, it’s easy to see the amount of financial risk involved in this
approach. And that’s not even a good price or a high volume. If I really wanted
a good price, I’d have to talk tens or hundreds of thousands of units in one
purchase.
Fortunately for the startup software company, there are other options. In
my case, rather than investing in inventory, I instead invested in equipment.
This allows me to produce professional-quality CDs and cases one at a time.
My per-unit cost is considerably higher than $1.50. However, I now have the
freedom to experiment wildly with my offerings and see what works well. If a
product is a flop, I don’t have thousands of dollars lost in inventory that didn’t
move. On the other hand, once a course demonstrates itself as a consistent
seller, I have a track record of sales that allows me to do reasonably accurate
future sales projections. I then have the confidence and justification to put in
a volume order with my replication house to get a better profit margin.
240
Part III Building a Better Career

In addition to buying the duplication and printing equipment to manufac-
ture your own CDs and DVDs, you can also have replication companies
manufacture small quantities for you. You’ll pay for setup charges up front,
and your per-unit costs will be higher, of course, but once again, you’re able to
avoid large amounts of your money tied up in inventory.
Of course, these days, technology allows us many options for creating elec-
tronic media. The latter example of setup cost plus higher per-unit cost for
lower quantity might be more relevant to printing hard-copy manuals or creat-
ing any other physical deliverables you’ll be distributing. The bottom line is to
weigh good prices against how much money you’ll have tied up in inventory.
In the beginning, it’s best to be conservative with your cash flow. When you’ve
got a ton of orders coming in and you’re concerned with your profit margins,
well, those are nice problems to solve.
Distribution Decisions
It doesn’t matter how great your manufacturing options are if you can’t get
your product into the hands of the customer. Another area that programmers
often don’t consider is the distribution chain. 
Thanks to the Internet, it’s now very realistic to have people come to your
Web site, buy your product through your online store, and make a trip once a
day to your local shipping folks to send off the orders. That’s a very viable and
conservative way to get started. Depending on the kind of products and serv-
ices you’re offering, however, there are other means of distribution that you
might want to consider, particularly if yours is a retail-oriented package.
Like books, music CDs, or any other physical products, a lot of software
packages and games are purchased in stores. Getting your product on the
shelves is not as easy as you might think, but it’s another marketing option. In
the most typical case, you sell your product to distributors at a reduced, below
wholesale price. They then sell the product to the stores they service at whole-
sale. The store then sells it at retail, which is usually the suggested retail price
less a discount. As you can see, chunks are taken out of the price in several
stages of the game. However, if your product becomes popular and people begin
to buy in volume, there’s a lot of money to be made, even at this reduced price.
There are a few things that most people don’t know about this arrange-
ment, however, and you’ll need to plan accordingly. First, distributors don’t
pay you up front. You invoice them, and it’s common for them to take 90 days
or more to pay. Additionally, there’s the concept of the return. In other words,
a sale is not necessarily a sale. Distributors allow stores to return unsold stock
for credit. They then return that stock to you for credit. In other words, if a
distributor buys a thousand units from you, it may pay you for all of them in
90 days, but at 120 days, the distributor may have returned 50% of them and
Chapter 15 Flying Solo
241

will be expecting a credit on its account for that amount. Although that may
not excite you, it’s important to remember that this model does work very
effectively for many people, which is why it’s been in place for so long. The
point here is to know what to expect in terms of the money you have out in
inventory and what you can realistically expect in your accounts receivable.
Getting the Word Out
This brings us back around to that all-important aspect of making the sale. In
addition to active salespeople calling on customers and selling your product,
which is a more likely scenario in the case of expensive, enterprise-level sys-
tems, you can find other more passive methods of generating revenue.
Whether you employ salespeople, work with distributors, or just sell it off
your Web site, no one is going to buy your product unless they know about it.
There are countless ways to spread the word about what you offer. Some cost
money, some cost time, and most of them are very difficult to track in a spe-
cific, cause-and-effect manner. Welcome to the wonderful world of promotion
and public relations.
Before you even begin considering your methods of marketing and public-
ity, you should first have a very clear picture in your mind of the benefits you
offer. What makes your product the most worthy purchase for your customer’s
money? There are a number of angles here. You might do the job better than
anyone else. For a 1.0 product, unless there’s no established competition
(unlikely), that’s probably not the most realistic approach. You could sell your
product cheaper than anyone else, but that brings image concerns into play.
People believe at a gut level that they get what they pay for. If your product is
ridiculously cheaper than the competition, they won’t believe it’s a profes-
sional, high-quality package.
You might have a particular niche that the competition’s broader package
doesn’t address as completely as yours does. Another effective angle is offering
the best bang for the buck. You’re significantly less expensive but not cheap
enough to make you look like an amateur. You don’t offer 100% of the features
the competition does, but you cover 90% of the most popular features. Most peo-
ple don’t use the full power of their software, and so don’t want to pay top dollar
for a lot of features they won’t use. This is where you get your foot in the door.
No matter which approach you use, you need to know what your benefits
are so that you can promote your selling points. Your next step is determining
whether you should pay for advertising, put your efforts into free publicity and
promotion, or a mixture of both. For advertising, you’ll have to determine who
your market is and what media they subscribe to so that you’ll know where to
advertise. You must then do a cost/benefits analysis on the ad. How many units
do you have to sell to pay for the ad and get into profitable territory? Is that
realistic? What’s the difference in results between expensive and cheap ads?
242
Part III Building a Better Career

There’s a lot of work to be done in this area, and there’s no silver bullet.
Research and experimentation are your most effective methods of improving
your response rate.
Publicity is a different creature. You can write articles in trade publica-
tions, solicit product reviews, do print and radio interviews, and do a host of
other things to spread the word about you and your product. Professional PR
firms work hard to make you newsworthy. No one wants to book you on a talk
show to give an infomercial on your product. They want to hear you talk about
interesting things that will hold the audience’s attention. However, even
though you’re not hawking your product at the top of your lungs, by continu-
ally engaging in an active publicity campaign and looking for ways to make
what you do entertaining, interesting, and newsworthy, interest in your prod-
uct will grow. The results you’re shooting for are a little more indirect, but
profitable nonetheless, such as “Hey, there’s the XYZ product. I’ve heard of
that. Maybe I should give it a try.”
No matter what anyone tells you, there is no sure thing in marketing. It’s a
constant process of trial and error, so you should be prepared to dedicate a sig-
nificant portion of your time, effort, and money to this on an ongoing basis. The
results, however, are quite enjoyable, as your banker will most certainly tell you.
Continuing Education
It’s obviously not possible for me to comprehensively cover in one chapter
every aspect and detail about running your own software company. And in
fact, much of what has been covered here isn’t even specific to software, but
instead applies for any business startup. Nonetheless, my intention has been
to make you aware of the wide variety of skills and resources that you’ll need
should you choose to hang out a shingle and go it on your own. 
The amount of work involved in running your own business may even
seem overwhelming, and there are days when it certainly feels that way.
However, that’s no different than how you felt when you were working for
someone else. It’s all a matter of knowing what strengths you need and then
acquiring them. In fact, there’s a parallel between running a business and
being a programmer that might not be obvious. We never give it a second
thought when we spend all night experimenting with a new technology, and
we buy books all the time for the same reason. We subscribe to magazines,
become members of organizations, frequent Web sites on a regular basis, and
in general work our tails off on a regular basis to be informed, skilled techies.
If you want to be successful with your own business, you have to take the
art of the entrepreneur just as seriously. You can find many books, magazines,
Web sites, and all other forms of information on becoming a better business-
man. If you dedicate yourself to improving your business skills with the same
degree of enthusiasm you apply to coding, you’ll have a serious advantage in
the business world, and ultimately, you’ll meet with great success.
Chapter 15 Flying Solo
243

The previous chapters have covered a lot of different ways that you can further
your career. If you’re currently out of work or are so terminally bored with your
present job that you’ve just got to seek greener pastures, you now have a lot
more options than you may have previously realized. However, if you work for
other people, sooner or later, you’ll be right back in the same situation that
faces us all. No matter how good your gig may be at the moment, it’s a differ-
ent playing field than it once was. The concept of job security is now an illu-
sion, as is any notion of corporate loyalty to employees.
The world of technology changes at a rapid pace, and the market we com-
pete in is decidedly global. In this fast-paced and ever-changing environment,
you can be a dedicated and dependable employee and still be out on the street
tomorrow if the tides of business and profit dictate. If you were hoping to go
to work for a stable company where you could spend the rest of your days
free from the worry of ever having to look for new employment again, you’re
dreaming. Your company will not protect you, or your job.
If that sounds like a cynical or bitter perspective, then you’ve missed the
point. The business world is not about emotion or idealism. It’s about com-
merce and making money. Furthermore, there’s nothing wrong with that. It is,
however, important for you to realize that if you program for a living, you earn
your paycheck from within this environment. Those who ignore reality are
soon trampled by it.
So, if you can no longer place your trust in working 50 years for a company
and retiring with a gold watch, does this mean that you will forever be a help-
less victim of the world of commerce? Not in the slightest. It’s true that com-
panies give their loyalty to the bottom line rather than their people, but that
doesn’t mean there’s no such thing as a secure job. It only indicates that secu-
rity must come from someplace other than your employer, and that obtaining
it is an active, not passive, exercise. 
In fact, the good news is that you—yes, you—are in complete control of
your career. You just have to know the ropes and be willing to do the work.
245
Job Security
16
C
H
A
P
T
E
R

The key to understanding your power in the greater scheme of things lies not
in technology, but in the oldest constant in the business world: human nature.
The company you work for is not some abstract entity represented by org
charts on a piece of paper. It’s a collection of people who are each interested
first and foremost in his own career and standard of living, from the chairman
of the board right on down to the fierce, furless canine.
Corporate presidents, upper management, mid-level managers, and all
their kindred spirits are to some degree looking for more money and power.
All the various people who influence and interfere with your software project
are also striving for power, control, and through their efforts, a better career
path for them as individuals. Companies don’t eliminate entire IT departments
and outsource them to the South Pole because of some abstract principle.
They do it because the people making those decisions stand to profit person-
ally as an end result of their decisions. It may well be that in order for them to
profit, others must profit as well, but make no mistake, this is their primary
motivation. If they didn’t think that there was something in it for them to do
so, they’d quit and go to work for a company where there was.
Therein lies the key to your success and security as a programmer. Sitting
back and trusting the company to look after you doesn’t work. There are some
who would tell you that becoming completely focused on the good of the com-
pany is therefore the path to a stable career, but we all know of people who
have gone this route and still found themselves out on the streets, or at the
very least, taken advantage of by others. The answer to this dilemma, and the
true secret to job security, is actually a combination of a couple of factors.
First, you have to keep the health, well being, and profitability of the company
in mind, for a very practical reason. If your competitors put your company out
of business, you lose your paycheck. The second part of the equation is human
nature. You have to look after the health of your company in a way that bene-
fits the people around and above you, particularly the ones who have influence
over whether you, or perhaps your entire project or department, stay or go.
When you put these two pieces together in a practical and realistic man-
ner, you’ll be that programmer we’ve all seen who always seems to land on his
feet no matter what happens around him. He gets the hot new computer, the
best cubicle, the juicy parts of the coolest new projects, and even gets left
alone more than most people so that he can sit back and code. When word
comes down from on high that budgets are being cut and a few people are
going to have to go, his name isn’t even on the list. He appears to lead a
charmed life and seems all but invincible, impervious to the corporate chaos
around him. Isn’t this really the kind of job that you want for yourself? You
can have it. You just have to work for it.
If what I’m describing sounds like politics, you’re right on the money. In
short, job security is 100% about politics. Does that make you twitch? Too bad.
There was a great line in the recent batch of Lord of the Rings movies that is
very pertinent here: “those without swords can still die upon them.” You can
either become a little more politically savvy in your day-to-day work and reap
246
Part III Building a Better Career

the rewards of an enjoyable and secure programming gig, or you can spend a
lot of time looking for jobs and complaining about how unfair life is. Either
way, the reality doesn’t change. 
However, don’t despair. To protect your job and your position on the proj-
ect, you don’t have to become some brownnosing yes-man, and neither do you
have to embrace the dark side and screw everyone else to get what you want.
In fact, both of those paths lead to disaster. Instead, you simply have to use a
little common sense, keep your eyes open, and believe it or not, just be a nice
guy. Everyone knows the old saying, “Nice guys finish last.” That’s not true.
Stupid nice guys finish last. Be smart and be nice, and you’ll have the edge.
In all that I’ve said so far, it’s been assumed that you’re technically compe-
tent at your job. If you’re not, make sure you do what it takes to get that way.
If you’re constantly creating problems for your project, it’s fair for them to say
that you need to be replaced. However, we’ll take it for granted that this is not
the case. So, let’s take a look at just a few basic techniques that you can employ
to ensure that you remain a valued employee and member of your team, no
matter what kind of hard times hit your company. Each idea will no doubt
bring to mind many similar approaches that you can employ, as is my intention.
Long-Term Thinking
Since the idea is to improve your job security, that means you’re going to be
around for a long time. Whether it’s a quick hack in your code to meet a
ridiculous deadline or a higher-level decision to put out the fire at your feet
even though everyone knows it’s a bad idea in the long run, sooner or later,
you’re going to be faced with the consequences of your action. People are
going to be angry, there will often be a search for a scapegoat, and in general,
you’re going to go through a bad experience. You have a few opportunities for
job security here.
First, if you know the quick fix is a bad long-term idea, you have to come
up with a better solution. This means a long-term plan in which you can incor-
porate a compatible short-term solution. Bear in mind that some vague and
generic long-term plan is going to put you right up there with the people who
write mission statements. You need to have a very clear and detailed picture of
the long-term results. Only then can you propose short- and long-term actions
that are practical and realistic.
Coming up with a way to avoid future disaster is not enough. You need
to show the people who have the power to do something about it why they
should care. This means knowing a little about what their personal desires and
ambitions are, and drawing a straight line between your idea and their per-
sonal benefit—whether it’s looking good to their boss, more power and control
for them, enhanced status, better opportunity for career advancement, or any
of the other things people go to work for each morning.
Chapter 16 Job Security
247

We’ve all sat through meetings and endured the one lone voice of discon-
tent who continually proclaims that the direction we’re going is a bad idea or
is just plain wrong. They’re quick to cite the problems and consequences, but
when asked for a better way, they either shrug their shoulders or propose
their own short-term solution with its own set of disastrous long-term conse-
quences.
No one wants to listen to people complain. When you see a problem, be
prepared to offer a better way. However—and this is the part many people
miss—you have to show your solution as something that benefits the people
who can make or influence the decision. I emphasize this because although
there are certainly a few altruistic souls out there who do the right thing just
because it’s the right thing to do, the vast majority of those who can make a
difference are motivated by self-interest. You will rarely go wrong by taking
this into consideration in your proposals.
Nobody likes having to resort to ugly short-term fixes, and most people
know it’ll be trouble down the line. They just stick their heads in the sand and
hope they won’t personally suffer any of the consequences. If you’re the per-
son who proposes a better long-term plan and shows how to get there while
putting out the fire at your feet, people are going to love you. Especially if
they benefit by following your advice.
When powerful people love you, it increases your job security.
Taking Care of Your Peers
A lot of people assume that unless you’ve been hired as a manager of some
sort, you have no power or responsibility regarding other people. This is
only true on paper, and as we all know, the paper world rarely survives an
encounter with the real world. In every crowd, you’ll see people who seem to
stand out, to whom the rest of the group looks for advice, support, or even
protection. Sometimes these people have an official leadership role with the
accompanying authority, but even when they don’t, their influence makes
them a force to contend with.
The larger percentage of programmers are rank-and-file workers, either
members of a team or individuals working on solo projects. It’s easy to allow
yourself to fall into the role of a follower rather than one who leads, but if you
want a more stable career, lead you must. You encounter situations every week
where you know that something should really be done, but no one is stepping
up to the plate. Once again, if you’re the one who can propose both a solution
and a plan of action, you’re going to improve your career.
248
Part III Building a Better Career

Many times, the problems we encounter are things that affect our entire
group. A good example of this is the manager who drops new features into our
lap but doesn’t change the deadline. We all know what this means. A lot of
long nights at the office, time away from our families, and if we’re on salary,
all for no extra money. Everyone’s upset about it, everyone complains to each
other, but in the end, no one’s willing to do anything about it.
This is where you come in. Since you’re a part of the team, you’re affected
by this just like everyone else. However, if you start thinking of your peers as
brothers in arms rather than just people who share cubicle space with you,
you have the opportunity to stand out. Programmers are not known for being
extroverts. When you see injustice—and there’s plenty of it in this business—
find a better way. Put together a plan of action, and take a shot at selling it to
the people who can make a decision. As we’ve already covered, if you map it
to the decision maker’s personal benefit, you have a true chance for success.
More importantly, don’t fly into action just when you’re personally affected
by the problem. Even when it doesn’t matter to you, keep an eye out for the
people you work with, and for that matter, keep an eye out for your boss as
well. When any of these people are in a jam, make an effort to help them. You
won’t always win, but you should always try. As time goes on, you’ll gain a rep-
utation as someone who looks out for the good of the group, and you’ll gain
the loyalty, gratitude, and respect of your peers and your manager alike.
When you have the loyalty and respect of a group of people, it increases your job
security.
Improving Communication
You’re now thinking like a leader, whether you lead from the front as an actual
manager or lead from the middle as one of the guys. This is a key decision to
make on your part. Leaders have control of their destiny. Followers don’t.
Another way that you can make a difference for your team and improve
your career stability at the same time is by helping to solve one of the greatest
problems in software development: communication. Not the kind that modems
engage in, of course, but rather that ever-elusive transmission of thoughts,
ideas, and concerns between two or more human beings. 
How much time have you wasted in your development career because
information that was crucial to your efforts was inaccurate, late, difficult to
comprehend, or simply altogether absent? This is often the root cause of wild
goose chases that lead development projects down the wrong path for a pro-
longed period of time, only to have much of the effort scrapped. These prob-
lems come from many different directions, and with some effort, you can
make a difference.
Chapter 16 Job Security
249

Adopt the role of translator and information expediter. Start within your
own group. Many programmers possess absolutely brilliant minds and can
do wonderful things with just a few lines of code. They may nonetheless fall
terribly short in their communication skills. Oftentimes, when you’re working
with people like this, you find a way of establishing a rapport so that even if
they can’t clearly say what they mean, you can read between the lines and get
the point just the same. There are also times when they simply don’t offer
information at all, and you go on a fishing expedition to extract from them
what you need.
By learning to understand others, read between the lines, and enhance
your listening and interpretation skills, you’re in a position to share these ben-
efits with others. If you take an active role in clarifying internal communica-
tions, helping to translate or request information, you’ll serve a valuable role,
and your group’s development efforts will be greatly enhanced. This benefits
your peers as well as your manager, who looks good to his boss as a result.
Additionally, you can provide an even more important service by learning
to speak the language of groups outside the development area. For example,
those who work in marketing don’t speak techie. It’s unclear if they even
understand how to work a light switch, but that’s another matter. Neither do
techies understand the sales group. If you can learn to think from the perspec-
tive of others and act as an unofficial liaison between the techies and mere
mortals, you make a huge impact and also increase your visibility in a positive
way. Everyone’s job is easier, and they get better results because you’ve
enhanced the communication process.
When you’re recognized as someone who improves communication, it increases your
job security.
Overcoming Fear of Change
Change is a constant in the business world, but even more so in the highly
charged world of software development. Not only are the technologies chang-
ing under our feet every time we turn our backs, but also the entire industry is
continually working to redefine itself. Fear of change is one of the constants of
human nature, and the way people react to this internal concern creates a lot
of problems that never needed to happen. Once again, by exercising personal
initiative, you can make a difference.
Programmers are more conditioned to change than the average corporate
workers, because we deal in technologies that are moving targets. We’re
always learning new programming languages or the API of the week. In fact,
not only do we embrace this, we think it’s fun. However, we rarely fare as
well when other aspects of our jobs change.
250
Part III Building a Better Career

One of the more common things we encounter is projects shooting off in
unpredicted directions with no warning, Whether it’s due to capricious man-
agement decisions or just a response to unforeseen situations, when this hap-
pens, many programmers become upset and have a hard time not clinging to
“the way things were,” even when resistance is futile. 
Many times, however, we’re affected by change from a corporate level.
Departments get reorganized; people gain or lose control over projects; bene-
fits, bonuses, and other perks are altered; and other such things happen that
tend to affect us personally. Once again, if the company has decreed a new
way of doing things, people will resist, some digging in with all four paws. 
To a very large degree, coping with change is a matter of attitude. There
are things that you can influence and things that you can’t. When you have the
ability to make a difference on an issue, a finite number of choices and actions
are available to you. You pick your battles, you win or lose, and you move on.
And in the latter case, you simply have to move on.
However, most people don’t see things that way. They’ll go through a lot of
internal distress over things that they can do nothing about, and their reactions
will hamper their productivity as well as that of their group. By becoming a
voice for reason, the source of a pragmatic, practical perspective, you can help
a great many people get over the hump and become comfortable with the new
reality. You’ll find as you do this that people are very often quite grateful, as no
one has ever tried to help them before. Often, people are simply told that they
need to sit down, shut up, and get over it. When you help other people work
through their problems, you build alliances.
Your efforts to help people through transitions also benefit the company.
By smoothing over difficulties that people have with new events, procedures,
and directions, you bring things back to a productive state much more quickly.
That’s good for your group and good for the company, and you make your boss
look good as well.
When you reduce resistance to change, it increases your job security.
Turning Drudgery into Games
When you work in an environment that’s heavy on bureaucracy or covered
with chaos, or you’re just in the middle of a software death march, it can sap
the life right out of you. Not surprisingly, people rarely do their best work in
this state. Furthermore, when the overall energy level of your group lags, it
takes down even the most energetic of the bunch. This is bad for the individ-
uals, bad for the group, and bad for the company. Rare is the person who can
do anything about this, which means it’s yet another opportunity for you to
establish yourself as an indispensable employee in your company.
Chapter 16 Job Security
251

To a certain degree, life on the planet Earth is an exercise in competition.
I was going to say something about a dog-eat-dog world, but the growl I heard
underneath my chair gave me second thoughts. Still, plants, animals, and
people all compete for the resources that we need to survive, including food,
water, and access to a fast Internet connection. As a result, competitiveness is
in our blood, whether we realize it or not. This can be an excellent tool to use
when your group is starting to resemble the extras in an old zombie movie.
It’s not hard to pick a fight, and in a similar manner, it’s not hard to create a
contest. Companies are rife with power struggles, and your software project is
often rocked by various groups trying to exert influence over it. Other times,
there’s competition between yours and another internal project. In the retail
software, there’s also the reality of competitors who would just love to put your
company out of business. All of these things give you the ability to create a
common enemy, which is one of the oldest tricks in the book when it comes to
rallying a group of people. Creating a sense of competition with the need to
outproduce, outperform, and generally outdo your enemy is a surefire way to
get your people back into a lively and productive state.
When you just don’t feel like dealing with common enemies, you can also
get the competitive spirit going within your own project. Programmers have
egos, and in moderation, this can be a productive thing. By throwing down
the gauntlet and declaring that your group will complete your tasks well in
advance of everyone else, you can once again fire people up. You can spice it
up a bit by betting a few pizzas. Of course, the goal of competition is to raise
spirits and improve productivity, not create animosity, so it’s important to
approach things with the proper attitude.
When people get excited about winning, they not only become more ener-
getic, they also have fun. Suddenly, the gloomy and grim environment that you
were working in seems somehow bearable again. Also, importantly, productiv-
ity will once again be on the rise, perhaps even helping you all to get out of a
bad situation as quickly as possible.
When you improve productivity, it increases your job security.
Promoting Your Agenda
Everyone has an agenda, whether they realize it or not. Programmers are just
not very effective at selling theirs. In fact, the folks in the marketing depart-
ment are invariably the butt of our jokes as we make fun of their shallow atti-
tudes and corny sounding language. And yet, there’s a fundamental difference
between our group and those guys. They’re good at getting people to say yes.
We’re not.
252
Part III Building a Better Career

We usually have impeccable logic and can explain in very clear and precise
terms why we’re right and the other party is wrong. Consequently, we’re con-
tinually surprised when people don’t agree to do what we’d like them to do.
That’s because blunt conversations and bare information are generally quite
ineffective as means of persuasion. Of course, that last word, persuasion, is
the key. You can’t explain people into taking action; you have to persuade
them to act. 
Actually, the basic skills required to present a plan and get people to agree
to it are not that difficult to master. When I ran a sales consulting firm, we
taught minimum-wage workers these skills on a regular basis, transforming
their lives by increasing their income in ways they never believed possible.
The problem with most programmers is that they just don’t want to deal with
it. Once again, this is an opportunity, for if you’re the person who can achieve
the goals of your group, you become very valuable.
There are countless books in the stores about sales techniques. Even
though you’re not going door to door selling encyclopedias, you are nonethe-
less engaged in sales every time you want to persuade someone to go along
with your way of thinking. You wouldn’t give the purchase of a technical book
a second thought. Spend some money on sales books while you’re there. They
will have a lot of motivational, cheerleading language that may be difficult for
you to stomach at first, but if you find books on basic techniques, it’s worth
wading through an alien form of speech to acquire the skills.
Although you’ll do well to educate yourself more fully, I can give you the
basics quite simply. Establish a friendly conversation, and present your plan
in a way that benefits the other party. Then ask them to say yes. Be prepared
for the ways that they’ll object, and have responses ready to go. After you’ve
answered an objection, once again ask them to say yes. There are a lot of
techniques and subtleties that go into an effective presentation, whether it’s
a PowerPoint presentation in a conference room or just a hall meeting.
Nonetheless, if you master the basics, putting emphasis on why it’s in some-
one’s personal best interest to agree with you, you’ll get results for your group.
When you gain a resulting reputation as someone who can get the job done,
you’ll also grow in power and status.
When you can effectively promote your agenda, or that of your group, it improves job
security.
Becoming a General
What’s the difference between an architect and an engineer? Engineers build
weapons systems. Architects build targets. As funny as I personally find that,
Chapter 16 Job Security
253

I must say that most of the software engineers I’ve met in the business world
resemble targets when it comes to the inner workings of a typical corporation.
Many programmers are not only talented with a compiler, they’re also quite
idealistic. This is an attribute common among the artistic, and I think it’s quite
a noble personality trait. Up to a point.
What most techies either don’t understand or try hard not to believe is
that to a very large degree, business is war. If that sounds overly dramatic to
you, it helps to realize that essentially, war is a competition for territory and
resources. Sound more familiar now? And if you get paid to program, you’re
right in the middle of it. No one really cares about this sort of thing until it
affects them personally, and in the software biz, this happens all the time.
People are constantly vying for control of our projects. That’s why our dead-
lines are always so ridiculous—because we’re not in control. In fact, that’s why
a lot of things in our professional lives are so ridiculous.
Nonetheless, most programmers stick their heads in the sand and proclaim
in a self-righteous manner that they won’t stoop to playing these games because
they were hired to code. Wrong. You were hired to produce results, and every
time you allow some boneheaded manipulative person to come along and dis-
rupt your project, you’re not doing what you were hired to do.
Of course, you’ll find that no one wants to hear this, and that’s where you
come in. If you step back and take a look at what goes on in your department
and in your company, you’ll realize that there is a never-ending stream of
people taking action, launching initiatives, and grasping for control. What’s
required to counter this and keep your software project on track? Good strate-
gic and tactical skills. Once again, it’s not difficult to educate yourself in this
area. You simply have to take that first step and decide to do so. Then, as each
new gambit comes your way, you’re in a position to make recommendations to
both your peers and your managers (who are often not very skilled in strategy
either) that will benefit you all.
You’ll find as you improve that most of the people who try to influence
your project aren’t really that good at playing the game. The only reason
they’ve won in the past is that no one stood up to counter them. Once you
become known as an internal strategist who can help protect the interests of
the group, you’ll become the go-to guy anytime there’s trouble. That makes
you a very in-demand person.
When people depend on your strategic skills, it increases your job security.
Inspiring Innovation
As software developers, innovation is something we strive for on a regular
basis. Even so, we often find ourselves emulating the way that others before us
254
Part III Building a Better Career

have done things, either because it’s the best way we’ve seen so far or because
we simply don’t have the time to do anything better. Of course, a development
group rises and falls with the quality of its work, but quality is also a concept
that’s somewhat open to interpretation. Just because something’s new and
innovative does not mean that it’s necessarily good. Although many geometric
shapes have been tried, nothing rolls quite so well as a wheel. The trick in this
business is to come up with new ways of doing things that are also useful.
Surprisingly, one of the obstacles in the typical development shop is the
status quo. Perhaps you’re familiar with the experience of proposing an idea
that you know to be superior, only to have it turned down in favor of the old
way because, “that’s the way we’ve always done it.” As always, the way to
overcome this is by thinking like the other person. What’s in it for them to give
your new idea a try? When you can present it in terms of their benefit, you’ll
often find instant support.
With enough success, you can eventually foster an attitude in your team
to look down on the old ways as an incentive to reach for new heights. If the
wheel is the best solution, don’t throw it out just because it’s tried and true.
It’s always a bad idea to be clever just for the sake of being clever, and that
happens far too often in our industry. However, if you’re designing a tank, you
might find that a group who prides itself in not clinging to the past will be the
one who comes up with the idea of treads.
For an individual to strive for the new and exciting is admirable, and it
does benefit the group. However, if you really want to make a difference, you
need to find ways to inspire your people as a whole to reach for bold new
ideas. When you help your people gain a sense of pride in their inspired and
innovative abilities, it becomes a self-fulfilling prophecy, leading you on to one
success after another. Since you’re producing ideas that actually have value
rather than simply embracing cleverness for its own sake, you’ll soon find that
the company values your team a great deal. As the catalyst for inspiration, you,
in turn, will be even more valued.
When you inspire others to reach for innovation and excellence, it increases your job
security.
Generating Enthusiasm
We rarely have a hard time getting excited about programming, for coding is
a passion more than a job assignment. However, it’s not the coding that tends
to bring us down, but rather the endless cycle of corporate insanity that we’re
confronted with on a daily basis. No matter how much fun writing code may
be, in many cases, we don’t get nearly as much time doing that as we’d like.
Instead, our time is often taken up in unproductive meetings and other such
Chapter 16 Job Security
255

bastions of bureaucracy. Additionally, the artificial limitations we’re often
given on our projects coupled with a never-ending stream of mindless tasks
and the ever-present impossible deadlines all conspire to dampen the spirit
of even the most enthusiastic of developers.
This is a much more dangerous situation than many in management real-
ize. Productivity, innovation, and quality are all tied very closely to the overall
morale of the group. No matter how brilliant they may be, programmers are
still human and have emotions like everyone else. When people become
depressed or lose hope, projects quickly enter into an endless downward
spiral that ultimately leads to one disaster after another.
You may not have the power to change the various things in your environ-
ment that sap the collective will of your group. You can, however, do some-
thing about the effect it has on people. One of the most fundamental truths at
your disposal is the fact the enthusiasm is contagious. The reason the people
on all those late-night infomercials are jumping up and down and screaming
their 800 number at you is because it works. Maybe not on people like you or
me, but it works.
There are a couple of things you can learn and apply from this. First, if
you’re obnoxious or insult people’s intelligence, they’re not going to take you
seriously. The late-night commercials are not aimed at the intellectually gifted,
so this is not a concern for them. In a group of techies, it’s something you want
to avoid at all costs. Secondly, at every level of society, enthusiasm is conta-
gious. Therefore, when things are bad, if you continually find ways to look at
things in a positive light, keep your spirits up, and help others to do the same,
eventually it’s going to catch on. Actually, it’ll catch on quicker than you think.
If you approach this with some dignity instead of trying to be a shallow, mind-
less cheerleader, you’ll find that you have great power to influence the feelings
of others.
Another thing that will bolster your efforts is the fact that the spiral works
in both directions. As their spirits lift, productivity will increase, leading peo-
ple to achieve success in their efforts, whether it’s meeting a deadline or find-
ing a particularly nasty bug. People enjoy succeeding, so it will lift their spirits.
That, in turn, encourages more good things, and soon you’ve redirected the
emotional momentum of your group into a positive direction. This change of
attitude will not go unnoticed by management, nor will the fact that every time
things get bad, you’re the guy who pulls people together again. Once again,
you will have made a difference and been noticed by people who are in a posi-
tion to protect your career.
If you can motivate people, it increases your job security.
256
Part III Building a Better Career

Promoting Unity
The typical corporate environment is so incredibly fragmented it’s amazing that
people even speak the same language. This can’t be good for productivity, and,
in fact, it never is. The solution to this problem is a little equation that would
surely make my old high school math teacher twitch. Any time you’re dealing
with the human race, one plus one is greater than two. United groups of people
can accomplish great things. All they need is something to bring them together.
As you might have guessed by now, that’s where you come in.
It’s not uncommon for programmers to be highly individualistic, and that’s
not always a bad thing. In the rough-and-tumble world of software develop-
ment, we need people who can get out there and make things happen without
a lot of hand-holding required. However, as the world discovered in the days
of Genghis Khan, a single united group can overcome even the strongest of
individuals. That’s usually the first thing that comes to mind when you see a
group of unruly barbarians riding over the horizon. Well, that and the fact that
now would be a great time to close the gates.
In many ways, building unity and a sense of camaraderie within your group
is one of the most powerful tools you have in enhancing the security of your
own career. There are countless ways to create stronger bonds between your
coworkers, from socializing outside the workplace to demonstrating the bene-
fits of a united front in the face of a common enemy. 
Your local bookstores have shelves full of books that will teach you leader-
ship and team-building skills. As with the many other things we’ve looked at,
you don’t have to be in a management position to employ these techniques. All
it takes is a desire to change things for the better and a willingness to pursue a
little self-education and put in the work involved to make a difference.
No matter how great the power of a united people may be, it can’t be
tapped until someone finds a way to wake everyone up and bring them
together. The person who can accomplish this has not only greatly increased
the capabilities of the group, but also now wields tremendous influence.
Genghis Khan certainly couldn’t have single-handedly defeated the opposing
armies he encountered. However, when you’re at the local tavern, the last guy
you’re going to pick a fight with is the one who’s backed up by ten thousand
heavily armed horsemen.
When you can turn individuals into a united and powerful group, it increases your job
security.
Chapter 16 Job Security
257

The Indispensable Programmer
It’s often said in companies that no one is indispensable, and from a certain
point of view, this is true. No matter how good you are at your job, you can
never let yourself become arrogant and self-important, because there’s always
someone else out there who can take your place. There’s also the truck factor
to consider. Any project manager worth his pocket protector tries to spread
knowledge around and document things to keep the project from grinding to a
complete halt should one of the team members get hit by a truck. This means
that it’s harder to become indispensable based on your technical accomplish-
ments alone. And if you think the truck example is a bit far-fetched, you’ve
never seen a Chihuahua behind the wheel.
The truck factor, coupled with an increasing trend in companies to show
less and less loyalty to their employees, should serve as a cautionary tale. You
can and will be replaced any time that it’s convenient or profitable for the
company to do so. The key to protecting your job and furthering your career
should therefore be obvious. You want to make sure that it’s never in the best
interests of the company or anyone above you to end your employment there.
We’ve just covered a number of ways that you can work to make yourself a
valuable member of the team, an asset to your boss, and someone who pro-
motes productivity and other profitable behavior. The more you benefit your
company, and specifically the people in your company who have the ability to
protect your career, the more secure your career will be. 
Of course, I’ve only scratched the surface of the strategic possibilities avail-
able to you. Not only could I write an entire book about this, I already have:
Unite the Tribes: Ending Turf Wars for Career and Business Success (Apress,
2003). It has absolutely nothing to do with programming or technical matters
and could not be called a software development book by any stretch of the
imagination. It’s not intended to be. It’s a book of practical strategies for those
who wish to improve their careers using the kinds of tactics we’ve been look-
ing at in this chapter. In fact, I created every job security suggestion you’ve
just read by following the instructions in Tribes. I took just a few of the hun-
dred individual tactics that it details and applied them in the context of your
personal career. If you want to dig deeper into strategies and tactics that will
strengthen your career through practical and benevolent actions, it’s a good
place to start. However, no matter what resources you use, I encourage you to
take the strategic and nontechnical side of your job seriously and continually
improve your capabilities in this area. It will transform your career in ways that
many only dream of.
Job security isn’t something that’s handed to you on a silver platter by an
HR department or a recruiting agency. It’s something that you have to create
on your own through the right kinds of efforts, day after day. In our industry,
those efforts have surprisingly little to do with technical prowess. Although
there’s much to learn, none of it is beyond your capabilities if you apply your-
self with the same enthusiasm that you have for your coding.
258
Part III Building a Better Career

I’m also continually adding new articles and other resources for you on my
Web site at www.PracticalStrategyConsulting.com, and of course, I’m always
happy to hear from you. No matter what twists and turns our industry takes, I
hope you’ll use these ideas to achieve ever greater success in your career. It’s
still a great way to make a living.
Chapter 16 Job Security
259

A
arbitrary deadlines
delivery dates, reliable, 59
interim milestones, determining, 59
preventing, 59
attack Chihuahua
career aspirations of, 246
chats with maintenance programmer, 56
confessing monitor abuse to, 153
corporate guardian, role as, 175
dental charms of, 72
document-shredding capabilities of, 22, 88
expensive therapy sessions and, 12, 70, 115
favorite desserts of, 133
fear of high windows, 26
gourmet benefits of, 64
legal beagles and, 68
letting sleeping dogs lie, 70
nighttime keyboarding of, 133
swashbuckling adventures of, 207
avoiding sweatshops, 47–48
B
building personal-interaction skills, 53–54
businesspeople
communicating with, 7–8, 53, 159
motivations of, 6
perspectives on programmers, 6
C
career paths
age discrimination and, 221–22
alternatives to programming, 220
brainstorming new careers, 226
choosing between coding and income, 191
contract programming, 194–97
downturn in IT industry, 219
employment options, 190–91
getting paid for what you love, 191, 227–29
job preferences vs. requirements, 227
job security and, 223, 225
management skills, value of, 222
network management positions, 223
project management positions, 220–21
rethinking “lifetime” careers, 225–26
retooling to marketable skills, 223–25
running your own business, 197–99
sales and marketing positions, 222
training positions, 222
working as an employee, 192–93
Chihuahua, attack. See attack Chihuahua
coding and debugging for productivity, 144–47
communicating with businesspeople, 7–8, 53,
159
corporate self-defense
assessing the political landscape, 181–82
email, dangers of, 180
going on the offensive, 183–85
improving your political skills, 185–86
keeping a low profile, 180–81
picking the right battles, 177–79
survival threats, 176–77
taking evasive action, 182–83
weighing political risks against benefits,
179–80
D
design phase
basic services, defining, 105–6
design detail, determining the level of, 100
design documents, role of, 97
design methodology, customizing a, 97,
100–105
261
Index

design specs vs. technical documentation,
96
designing “The Right Way”, 95–96
diagram types, creating, 100–101
estimating time requirements of, 97–99
extremely limited timeframes and, 108–10
lack of, in programming departments,
95–96
major modules, defining, 98
prototyping, 106–8
user interface and, 103
developing time-management skills, 51–52
E
estimating delivery schedules
accurate estimates and management
credibility, 113–14, 121
arranging tasks by dependencies, 119
beta testing phase, estimating, 121
building the overall timeline, 120
coding phase, estimating, 116–18
difficulties of, 111–12
estimating in hours vs. calendar days, 116,
119
installation and integration efforts,
estimating, 121
myth of the eight-hour day, 114–16
setting incremental milestones, 119–20
testing and debugging phases, estimating,
121
timeline rejection by management, 124–25
what to estimate, 112–13
F
flying monitors
blunt instruments and, 147
fifth-floor launching point, 11, 12, 39
forced and sudden trajectory of, 33, 77
raging at management, 159
G
geek speak vs. biz speak, 24, 29
getting paid for what you love, 191, 227–29
getting the cool projects, 48–49
I
International Federation of Canine Night
Watchmen. See under night watchman
J
job market
building a reputation, 206–7
canvassing and cold-calling companies,
204–5
Internet employment sites, 203–4
interview tips and pointers, 208–9, 215–18
networking, 207–8
newspaper Help Wanted ads, 202–3
newspaper Web sites, 203
personal business cards, 208
recent changes in, 201
recruiting companies, finding and using,
205–6
referrals, value of, 207
researching prospective employers, 209
résumés, preparing and customizing,
209–15
job security
becoming indispensable, 258
being smart and nice, 247
building strategic skills, 253–54
exercising helpful leadership, 248–49
generating team enthusiasm, 255–56
illusory nature of, 245
improving communication, 249–50
inspiring innovation, 254–55
promoting group unity, 257
promoting your agenda, 252–53
proposing beneficial long-term solutions,
247–48
raising spirits and productivity, 251–52
reducing resistance to change, 250–51
true secret of, 246
M
maintenance programmer, stressed-out
avoidance of, during full moon, 155
crankiness of, 128
inventory control program, joys of, 56, 63
late-night bug fixes and, 123
lunch dates with, 70, 72
mental stability of, 3
monitoring online ammo purchases by, 27,
41, 144
total sleep deprivation and, 60
managing management
addressing business issues, 161
building personal credibility, 171–73
communications skills, improving, 161
communications, frustrations over, 159–60
development process, gaining control of,
160
fostering wise development practices,
163–65
influencing decision makers, 169–71
justifying your proposals, 165–67
262
Index

making winning proposals, 167–69
speaking the language of business, 161–63
managing software projects
coding and debugging for productivity,
144–47
debugging and diagnostic utilities, 145–48
“hot rod” code editors, using, 149–51
motivating team spirit, 143
optimizing meetings, 152–56
project management software, using, 141
shielding the team from management, 143
streamlining paperwork, 149
time-estimation skills, improving, 142
tracking project status, benefits of, 142
version control systems, benefits of, 148–49
“walking away” to increase productivity,
151–52
wrapping up a project skillfully, 156–57
monitors, flying. See flying monitors
mythical stress-free release
programmer’s nirvana, achieving, 62
N
night watchman
benefits of salaried employment, 194
caffeine-free lifestyle of, 73
fifth-floor window views of, 15
guard-shack jitters, 115
ill-timed vacation of, 77
ironclad union benefits of, 68
motion-detector requests, 23, 26
O
overtime city, living in, 35, 45, 78
P
product specifications
clarifying with management, 82–83
company politics, dealing with, 79–80, 93
defining with precision, 76–77
domain experts, identifying, 81
draft requirements document, 87–88
feature list, defining, 86–87
final requirements document, getting sign-
off, 88
focus groups, convening, 86
identifying, 75–76
knowledgeable users, identifying, 81
management resistance, handling, 89–92
new feature requests, 89
requirement definition questions, 83
requirements gathering with users, 84–85
sign-off authorities, identifying, 78–79
specifying “what” not “how”, 77, 84
programmers
achieving career goals, 54–56
authority types, 20
avoiding killed projects, 12
avoiding sweatshops, 47–48
bit heads, 18
building personal-interaction skills, 53–54
burnouts, 18
CEOs and, 13
communicating with businesspeople, 7–8,
53, 159
company-man programmers, 17
coping with corporate management, 11, 81
corporate world as illogical, 8–9, 77
cranky coders, 16
deadlines, realities of, 10
developing non-technical skills, 50
developing time-management skills, 51–52
enhancing design skills, 53
entrepreneurial programmers, 20
getting the cool projects, 48–49
marketing managers and, 14
middle managers and, 14
morale, praise, and recognition, 122–23
navigating a corporate environment, 12
old-school programmers, 19
one-programmer teams, 51
project managers and, 15, 50
respecting businesspeople, 8
senior-level managers and, 13
slug programmers, 18
team leads and, 15, 51
techies, 17
technology evangelists, 16
terminally educated programmers, 18
wild-man programmers, 19
programming
commercialism and, 7
corporate realities and, 5
designing “The Right Way”, 95–96
earning money from, 49
frustrations of, 4
joys of, 4, 48
shoot-from-the-hip-and-debug-all-night
approach, 95
taking personal pride in, 46
project scope creep, 23, 28, 75
Q
quality assurance process
automated testing tools, 132, 139
baseline critical path test, 140
bug reports, writing, 132, 135–36
consumers and buggy software, 128–29
documenting, 135
free-play testing, 132–33
hardware failures, testing for, 139
regression tests, running, 138
Index
263

selling management on, 130, 133
software industry and, 127–30
software testers, professional, 128–31, 133
software testers, training and valuing,
133–37
stress testing, 139
technical support as alternative to, 129
test plans and test cases, defined, 131
testing lab, building a, 139
R
résumés, preparing and customizing, 209–15
S
software-development problems
abusive management, 25, 46
buggy products, 21
failing to confront management, 24
geek speak vs. biz speak, 24, 29
inadequate analysis and design time, 31–34
inadequate testing and quality assurance,
36–38
internal company politics, 41–42, 246
“inverted project management”, 22, 30
lack of developer credibility, 24
management impatience and, 29
paper-trail avoidance, 30
poor company management, 38–41
poor project management, 34–36
poor project-estimation skills, 23, 26
scope creep, 23, 28, 75
technical documentation, 27
turf wars, 30
unexpected project crises, 26, 42
unrealistic deadlines, customer-driven, 27
unrealistic deadlines, management-driven,
21
vaguely defined projects, 28
working constant overtime, 35, 45
software-development process
arbitrary deadlines, preventing, 59–60
beta participants, choosing, 72
beta testing, 72–73
coding, 70
defining, 60–62
delivery dates, reliable, 59
design phase, estimating, 67
design phase, planning, 66–68
flexibility and, 62
installation and integration, 71–72
interim milestones, determining, 59
outlined, 61–62
postmortem phase, 123
program testers, experience of, 66
realism and, 62
regression testing, 68, 71–72
software projects, commissioning, 63–64
software projects, identifying requirements
of, 64–65, 75–76
software testing, 71
technical documentation, writing, 123–24,
157
test plan, estimating, 67
test plan, writing, 68
test-debug cycle, 71
testing environment, building a, 65–66
testing environment, hardware
requirements of, 66
timeline and delivery dates, estimating,
68–70
uninstall program, testing, 72
starting a software business
administrative tasks, 234
building a Web site, 236
capital expenditures, 236
coding, 237
customer service, 235–36
distributing your product, 241–42
financial risks and benefits of, 232
finding a good accountant, 233–34
having a solid business plan, 238–39
improving your business skills, 243
investment capital, sources of, 238–39
legal aspects of, 232–33
managing your business, 235
manufacturing and packaging, 240–41
marketing, advertising, and publicity,
242–43
paying taxes, 234
product documentation, 237
product pricing, 238
sales, 235
software testing, 237
technical support, 236
using outside expertise, 239
working from home, 231
W
whiteboard erasers
avoiding when thrown, 102
as indispensable meeting props, 5
removing from conference rooms, 86
264
Index

