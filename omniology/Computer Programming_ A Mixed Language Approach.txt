COMPUTER 
PROGRAMMING: 
ACADEMIC PRESS, N e w York a n d 
London 
Λ Λ/Ι/xed Language 
Approach 
by 
Marvin L. Stein and 
William D. Munro 
Division of Mathematics, 
Numerical Analysis Center 
University of Minnesota, Minneapolis, 
Minnesota 

COPYRIGHT © 1964, BY ACADEMIC PRESS INC. 
ALL RIGHTS RESERVED. 
NO PART OP THIS BOOK MAY BE REPRODUCED IN ANY FORM, 
BY PHOTOSTAT, MICROFILM, OR ANY OTHER MEANS, WITHOUT 
WRITTEN PERMISSION FROM THE PUBLISHERS. 
ACADEMIC PRESS INC. 
I l l Fifth Avenue, New York, New York 10003 
United Kingdom Edition published by 
ACADEMIC PRESS INC. (LONDON) LTD. 
Berkeley Square House, London W.l 
LIBRARY OF CONGRESS CATALOG CARD NUMBER: 64-20324 
First Printing, 1964 
Second Printing, 1965 
Third Printing, 1966 
PRINTED IN THE UNITED STATES OF AMERICA. 

For Ruth and Anne 

Preface 
The purpose of this book is to help in providing the training of two 
classes of computer users. For the professional programmer-to-be, it aims 
to furnish a solid foundation for the more complex and subtle programs 
with which he will ultimately deal. For the nonprofessional, who neverthe-
less is required to make consistent use of the computer, it represents an 
attempt to give him an adequate training with which the additional 
practice of use will suffice. For this reason we treat three kinds of pro-
gramming languages, the absolute machine language required by the com-
puter "hardware," the symbolic machine language, and the problem-
oriented language provided by the "software" of symbolic assembly 
programs and compilers. For the occasional user of a computer with perhaps 
a differential equation to solve, a minimum of one of the problem-oriented 
languages and the help of a professional will be adequate. It is our belief, 
however, that a consistent user of a computer must delve deeper. An in-
telligent and efficient use of the convenience furnished by the software 
languages can only be attained with a thorough understanding of how the 
computer itself functions and of machine language. A thorough mastery of 
the subject of programming includes the versatility to make effective use 
of the hardware and software aspects of the total system provided. In 
particular, this can be achieved through the utilization of the mixed 
languages which are neither the absolute machine languages nor the more 
facile problem-oriented languages alone, but a composite of both. In this 
book we attempt the task of drawing together this material into a unified 
whole to illustrate the basic way in which the computer operates and how 
this is related to a convenient mixed language in current use. 
In the earlier days of digital computers the transition from the original 
problem to an acceptable version for the computer was usually accomplished 
vii 

viii 
PREFACE 
by a staff of trained personnel who could do the necessary programming 
and coding. The increased speeds and capacities of modern computers and 
the increased demand for their use, however, have made it impossible to 
maintain a sufficiently large body of professional programmers to meet 
all needs. For this reason, an ever growing numbefr of persons who are not 
primarily interested in digital computers as such have, nevertheless, found 
it necessary to learn enough to do the major part of the programming for 
their own problems. This raises the two questions which this book attempts 
to answer. How are these people to be trained to use a computer with a 
minimum of help, and how are additional professional programmers to be 
educated at the same time? 
The fact that the ordering of the topics follows a historical pattern is 
incidental. We believe that this is both the logical order and the order which 
is pedagogically most sound. It is easy for a person well grounded in 
absolute machine language who has written at least a few programs in this 
form to make the transition to the more convenient symbolic languages 
of the assemblers, and from these to the problem-oriented language. 
Furthermore, he will better understand what is involved in the translation 
from the symbolic language to the objective program, and can make a 
more intelligent and efficient use of the software. It is our experience that 
the inversion of this order makes it much more difficult to attain the same 
level of programming proficiency. Some people, however, will disagree 
with this point of view and will prefer to start with a symbolic language. 
This objective can still be achieved by reordering the chapters of the book. 
For those who wish to start with a compiler, Chapters 7 and 9 give a 
reasonably complete and self-contained version of Fortran, after which 
the other chapters can be considered in any desired order. We recommend, 
however, that early attention be given to Chapter 2, at least to the extent 
that the student becomes sufficiently familiar with machine organization to 
understand why we can identify symbolic addresses and variable names. 
For those who wish to start with a symbolic form of machine language, 
Chapter 8 can be treated earlier. Whatever the order of its use, the book 
tries to give a complete fundamental description of each of the three 
languages, alone and intermixed, and presents numerous examples for 
illustration. We have also provided a variety of exercises for each of the 
topics covered, together with answers to selected ones of these where a 
single answer is meaningful. 
We have chosen Fortran as the compiler language of this book because 
it is a widely used language available in some form at most installations, and 
serves, with the Fortran Symbolic Assembly Program, to give a good 
illustration of mixed language programming. 

PREFACE 
ix 
In the basic description of the organization of a computer and the use of 
machine language, we have attempted to present the topics with as great 
a generality as possible. For purposes of explicit illustration, however, it is 
necessary to introduce a specific machine, real or hypothetical. We feel 
that the use of a real machine which is widely employed has advantages 
over the use of a hypothetical one, provided that the salient generalities 
are not obscured by the painful detail of a manufacturer's manual. At the 
same time, the direct introduction of some of the typical hardware and 
software idiosyncrasies associated with any real computing system will 
guard against a complete idealization and give the student a feel for the 
actualities he will encounter in practice. We have chosen for illustration 
the Control Data Corporation Model 1604 (which we will hereafter refer 
to as the CDC 1604). In terms of instruction repertoire this is representa-
tive of most large scale modern computers. It is also completely compatible 
with a subset of the instruction repertoires of the Control Data 3400* and 
3600* systems, and all discussions in the book are directly applicable to 
these. Furthermore, the format of its instruction words is such as to teach 
something of a feel for both single address and double address computers. 
It is true that once machine language is learned for a particular machine, 
the transition to another machine is relatively simple. This is so to the ex-
tent that many of our students have done the laboratory problems on 
other kinds of computers available to them, even though the text illustrates 
programming concepts with the C D C 1604. Except for Chapter 3 in which 
the specific programs all relate to it, those sections which deal specifically 
with the CDC 1604 are so labeled. 
Although the practice of external scaling is much less prevalent in current 
usage than it was formerly, we have treated the topic in considerable detail. 
This was done with a twofold purpose in mind. First, to understand floating 
point operation, which is merely scaling handled by the computer, a 
programmer needs to know what scaling is all about. Moreover, in some 
oroblems he will have to use it. Second, we felt that the literature lacked a 
detailed exposition of the topic which could be used as a reference. This 
aspect is of more interest if we note that an increase in the use of external 
scaling is likely to result from the development of the modern hybrid 
digital and analog systems. 
The material in the complete book is suitable for a course of three quarters 
or two semesters, although in a course of such length we usually include 
some additional material on topics such as circuit logic and Algol. For a 
one-quarter or one-semester course, the book can be used in various ways. 
It can be used for training in Fortran alone. Alternatively, as we use it, 
* Registered. 

χ 
PREFACE 
it is suitable for a brief introduction to machine language, floating point 
operation, and elementary Fortran. The material is designed for the junior, 
senior, and early graduate level. No specific background of mathematical 
knowledge is required, although the maturity acquired by, say, a first 
course in differential equations is valuable. Students in almost all fields 
including physical sciences, behavioral sciences, biological sciences, educa-
tion, and agriculture have successfully mastered the material. 
The book should be used, if possible, in conjunction with a laboratory 
program which permits the students at the earliest possible moment to 
write and run programs on a computer. In starting with machine language 
we have found that students can write successful programs of the sort sug-
gested in the exercises within a week of starting Chapter 3. The writing of 
programs of increasing complexity and diversity should run concurrently 
with the material covered in class during the entire course. We have found 
it useful for students to write simple assembly programs before using the 
more sophisticated ones. 
The joint experience of the authors in the use and teaching of a variety 
of computers and a variety of topics in the computing field totals more than 
twenty-five years. This book reflects our judgment of the topics and 
presentation which will best guide the novice along the road to becoming a 
well-rounded programmer. We find it impossible to mention all of the 
associates or authors who have contributed invaluably to our present 
way of thinking, nevertheless, we thank them all. We also thank James 
Carlson, Richard Hotchkiss, and Lawrence Liddiard for invaluable criti-
cisms and contributions, and Mrs. Janet Schuffenhauer for care and pa-
tience in typing the manuscript. We also express our appreciation to 
Control Data Corporation for their permission to use the CDC 1604 as the 
illustrative model of a computer. Finally, we would like to express our 
appreciation to Academic Press for their competence and skill in producing 
the book. 
Minneapolis, 
Minnesota 
MARVIN L . 
STEIN 
WILLIAM D. 
M U N R O 

Introduction 
0-0. General Description of a Modem Digital Computer 
We will use the terminology modem digital computer to describe a high-
speed, internally programmed, general-purpose, automatic, digital com-
puting machine. In what follows we will deal with three basic questions 
regarding the modern digital computer: What is it? What does it do? How 
do we get it to do whatever it is that it does do? As a specific model for 
illustration we shall use the CDC 1604; however, the general ideas carry-
over to other modern computing systems since they are all similar in their 
main operating features, although they differ somewhat in the design of 
these features. 
To say that a computer is digital is to say that it operates on numbers 
represented by sequences of digits. This is in contrast to the class of com-
puting machines called analog computers that operate on continuous input 
data represented in terms of some physical quantity (such as voltage or an-
gular displacement of a wheel) which varies in proportion to the actual data 
which it represents. The digital computer, on the other hand, deals with 
discrete sets of digits in much the same way as a human being in carrying 
out the operations of addition, subtraction, multiplication, and division It 
can also distinguish between a sequence of digits representing a number 
greater than or equal to zero and one representing a number less than zero; 
however, this is about as far as its ability in arithmetic will ordinarily 
extend. Very few modern digital calculators come from the assembly line 
with the builtin ability to evaluate such functions as the logarithm to the 
base e or the Bessel function of order zero. Any one of these machines can 
be used to turn out a table of logarithms or Bessel functions, but it must be 
1 

2 
INTRODUCTION 
made to carry out such complex operations by a proper sequence of the 
elementary operations which are built into it. 
The fact that the digital computer performs only very simple operations 
upon digits is compensated for by the extremely high speeds at which it 
performs them. It carries out literally thousands of operations each second. 
Speed alone, however, is not enough. The ingenuity and skill displayed by 
the human operator in expressing his problems in terms of mathematical 
models that lend themselves to solution by means of sequences of the simple 
operations available, and in actually creating the correct sequences of such 
operations, is also of prime importance. 
The modern high-speed digital calculator is automatic only in the sense 
that, after being presented with its input, it can operate upon that input to 
produce the desired output without further intervention by any human 
operator. It operates in this manner by means of its program. By the pro-
gram of a machine we mean its way of selecting the sequence in which the 
operations will actually be carried out in order to solve a specific problem. 
A special-purpose 
computer will have a fixed program built in to solve its 
specific problem. Such a computer is a useful and economical device if we 
wish only to solve the same problem for different input values a large 
number of times. The modern digital calculator, however, is a general-
purpose type of machine. It aims at versatility. With it the user can attempt 
any particular problem he has in mind; and once his programs are prepared, 
he can switch from one program to another in a few seconds. 
If its repertoire of operations is suitably versatile, a machine may be 
judged to be general-purpose by the degree of ease with which its program 
can be changed. There are a variety of ways in which a change of program 
can be facilitated. A common technique is to provide easily accessible 
external switches or an external plugboard. This technique can be made 
more effective by making the plugboards removable, thus enabling one to 
set up any number of programs in advance. Another common method for 
changing the program is to feed into the machine a sequence of punched 
cards or, what is logically the same, a punched paper tape. The holes in the 
tape are used to change internal switch settings. Even greater flexibility in 
the changing of programs can be provided by a combination of removable 
plugboards and punched paper tape. Automatic computing machines 
which employ any of the above or similar means for changing their programs 
are referred to as externally programmed machines. The programs of these 
machines are external in the sense that the machines must accept them as 
given by their operators and can do little, if anything at all, to change or 
modify them by means of their own operations. In the modern digital 
calculator, however, this is not the case. The program of a modern digital 

0-1. 
FUNCTIONAL DESCRIPTION 
3 
calculator is stored within the calculator in the same form as its data. As 
a consequence, the modern digital calculator can operate upon its program 
just as it can operate upon its data and can change and modify the program 
during the course of the operation. For this reason the modern digital 
calculating machine is referred to as an internally programmed 
machine. 
Internal programming and high speed of operation are what make a 
general-purpose, automatic, digital calculator truly versatile. It is clear 
that these two features must go hand-in-hand. In order for a machine that 
can perform thousands of operations each second to be economically in 
balance, it must receive its instruction as to which of its operations it is to 
perform next just as quickly as it can perform that operation. The machine 
cannot afford to wait for a relatively slow moving tape; no plugboard would 
contain enough hubs to set up the thousands of operations necessary to 
keep it going even a few seconds unless a small set of operations is used 
repetitively. Similarly, unless a small set of operations is used repetitively, 
the machine's internal storage capacity would have to be unaffordably 
large before a sequence of internally stored operations could be set up 
which was long enough to keep the machine going for a length of time 
sufficient for the operator even to remove his finger from the start button. 
The solution is for the machine to have the ability to manufacture its 
instructions internally on the basis of a set of initial instructions to be 
loaded in with the data. Thus, to solve a problem we do not write a complete 
sequence which includes one operation for each computation that is to be 
made. Rather, we prepare a relatively small set of instructions (small in 
relation to the eventual number of operations that are to be executed) 
which will cause the computing machine to create internally, as it needs 
it, the program that is necessary to the solution of the given problem. It is 
obvious that a departure from older methods of problem preparation is 
called for if such a machine is to be put into effective use. 
0-1. Functional Description of a Modern Digital Computer 
In solving a given problem a modern digital computer performs the 
functions of input of information, storage of information, control, 
arithmetic, 
logic, and, finally, output of information. These are all indicated in the 
figure below, the traditional block diagram of a calculator. The parallel 
with a human being who is doing hand computation on a desk calculator 
is straightforward. The human being is replaced by the control; his desk 
calculator is replaced by the arithmetic-logic unit; and his pencil and paper, 
books of tables, and human memory are replaced by the input-output and 
storage units. 

4 
INTRODUCTION 
Arithmetic 
Logic 
Input 
Storage 
Arithmetic 
Logic 
Input 
Storage 
Arithmetic 
Logic 
Storage 
Arithmetic 
Logic 
Output 
Storage 
Arithmetic 
Logic 
Output 
Storage 
Arithmetic 
Logic 
Arithmetic 
Logic 
Control 
Control 
Solid lines represent data channels 
Dotted lines represent control channels 
0-1.0. Input-Output 
It sometimes seems as if every conceivable variety of input-output 
device has been tried on some digital computing machine. The majority of 
modern digital calculators, however, make use of devices for input and 
output which can inscribe information onto or read punched paper tape, 
punched cards, magnetic tape or some combination of these. In input the 
inscription of information will ordinarily be done away from the computer 
on an off-line keypunch or specially adapted typewriter. The medium into 
which the information is inscribed then serves as a buffer or time adapter 
between the speed of the human operator and the speed of the on-line 
reader which will take the information and enter that information in the 
computer storage. Output is ordinarily the reverse of this process, with the 
computer itself inscribing information into the output medium and the 
medium (punched cards, punched paper tape, or magnetic tape) being 
taken to some off-line reader such as a tabulator or specially adapted type-
writer for preparation of the final reports. Direct input and output by 
means of on-line keyboard and typewriter are usually provided, but for the 
most part this method is used only sparingly for such purposes as checking 
out programs and monitoring the progress of a particular calculation. 
When the first scientific calculators were built, it was believed that the 
typical scientific problem would be one with little input or output and with 
a large amount of internal calculation. Accordingly, the first modern digital 
calculators for scientific purposes had little in the way of input and out-
put and were extremely fast arithmetically. When the businessman began 
to demand his own version of the modern digital calculator, it was believed 
that the typical business problem involved almost all input and output 
and only a modest amount of calculation. Accordingly, the first business 
calculators were built with great attention to input-output systems and 
with little arithmetical ability. Then it turned out that there were problems 

0-1. FUNCTIONAL 
DESCRIPTION 
5 
in each field which required large amounts of both input and output and 
calculation. The solution, of course, was to put a powerful input-output 
system on a scientific calculator, and this is the line along which a great deal 
of engineering effort in the computing business has been expended re-
cently. This has resulted in more effective handlers for the input-output 
media as well as in some compensation for their slowness relative to the 
internal computer operations by providing for the simultaneous sharing of 
the storage unit by all of these. The most modern versions of scientific 
calculators can thus be distinguished from their predecessors by the atten-
tion which has been expended on the input-output systems. In spite of all 
of this, however, input and output operations are still very slow in compari-
son with the other operations of the computer. They must be planned with 
great care, and the volume of input-output information should be mini-
mized whenever possible. 
0-1.1. Storage 
The function of the storage unit of the calculator is to hold the initial 
data, instructions, intermediate data, and final data before output. In order 
for the over-all economy of operation to be effective, the storage unit must 
be able to deliver or receive an item of information consisting of an ordered 
sequence of digits of some fixed length in a time comparable to the time in 
which the arithmetic unit operates. The storage unit of the computer is 
composed of a large number of registers which are devices for holding an 
ordered array of digits of a given length. Each of these registers in many 
computers presently being built is composed of an array of tiny magnetic 
cores and is uniquely identified by an integer known as its address. 
A storage register may store either an instruction or a data item, or both, 
at different times during the course of a given calculation. One of the prime 
features of a modern digital calculator is the fact that upon obtaining the 
sequence of digits stored in a given register we cannot, in general, tell 
whether the sequence represents an instruction or an operand. When inter-
preting a sequence of digits in a register as an instruction, we divide the 
original digits into subsets. One subset of digits will represent a numerical 
code for the particular operation to be performed, and the remaining ones 
will generally represent addresses at which the operands are to be found or 
to which results are to be delivered. In certain classes of instructions an 
actual operand may appear. 
0-1.2. Control 
It is the function of the control unit to obtain the instructions from the 
storage unit in the correct sequence and to cause each instruction as ob-

6 
INTRODUCTION 
tained to be properly executed. In executing an instruction, the control 
decodes the particular subset of digits representing the operation to be per-
formed and sets up the proper function in the arithmetic-logic unit. The 
control also decodes the remaining subsets of digits in order to arrange for 
transmission of operands from the addressed registers to the arithmetic-
logic unit or vice versa. 
The particular instruction which the control is to execute is specified by 
presenting it with the address of the register in which the instruction is 
stored. The control will then consider any sequence of digits which it finds 
in the register with the given address to be an instruction. In many calcula-
tors the control will choose its next instruction from a register with address 
one greater than that of the register from which it obtained its current 
instruction, provided only that the current instruction does not specify 
some other register from which the control must choose. Thus, after the 
control has executed its first instruction from some register, usually chosen 
arbitrarily by the operator, the sequence of addresses of registers from which 
it is to choose succeeding instructions is defined by the internally stored 
instructions themselves. 
0-1.3. Arithmetic-Logic Unit 
The arithmetic-logic unit will have a few registers for storing sequences 
of digits, the exact number and type of these registers depending on the 
particular machine. The arithmetic-logic unit will also be able to carry 
out a variety of operations on the digits stored in its registers. The control 
unit causes sequences of digits to be transferred from selected storage 
registers to the registers of the arithmetic-logic unit. It then selects a subset 
of the total operations the arithmetic-logic unit can perform on digits 
stored in its registers and causes the selected operations to be sequentially 
executed. The resulting digits may be interpreted as representing a sum, 
difference, product, or quotient in accordance with the particular subset of 
operations and execution sequence chosen by the control. The end result of 
the digit manipulations of the arithmetic-logic unit may also have a non-
arithmetic or "logical" interpretation. 
0-2. Coding, Programming 
The final step in preparing a calculation consists of making ready the 
sequences of digits which represent the coded instructions and assigning 
each coded instruction to its proper register in the storage system. This 
task is usually called coding. The job of the coder is not an easy one. The 
form of the coded instruction will generally depend very much on the ad-

0-2. 
CODING, PROGRAMMING 
7 
dress of the particular register in which it is to be located, but the coder 
finds it difficult to decide in which register to locate a particular instruction 
until he has completed the entire code. The coder has to learn to handle 
this difficulty and many others; he must have a thorough understanding of 
the particular machine for which he is preparing the code; and he must, of 
course, be thoroughly familiar with its repertoire of instructions. 
Although the repertoire of instructions will differ from machine to 
machine, there are certain basic kinds of instructions which all general-
purpose machines will have. Among these basic instructions there will be 
some for facilitating the internal transfer of information, others for per-
forming ordinary arithmetic, and still others for assisting the control to 
choose the sequence in which it is to execute instructions. Instructions 
enabling one to operate on the individual digits of the sequences, which 
are otherwise always handled as units of information, will be available. 
There will also be instructions for the control of the input and output 
equipment, as well as for a variety of additional operations to facilitate 
coding and checkout procedures. 
The most complex problems which the modern digital calculator can 
attack must eventually be expressed in terms of a repertoire of instructions 
such as has just been outlined above. We have already pointed out that the 
actual number of instructions will generally be few relative to the amount 
of calculation which is carried out. These few instructions must create 
from themselves all of the many instructions which a complex calculation 
will eventually require. This means that the calculation must be expressed 
in the most elementary form in terms of the operations just described. Sets 
of instructions must be used over and over again and often for entirely 
different data. Instructions which are used over again can be made to 
apply to different data by changing their address parts. 
A lot of spadework, generally referred to as programming, 
must be carried 
out before the problem arrives at the stage at which a detailed code in 
machine language can be written down. A very precise mathematical 
formulation must be available. The methods of solution must be chosen. 
In choosing these methods, we should always bear in mind the tremendous 
speeds of calculation, the relative difficulties of eventual coding and check-
out for the particular machine, the limited storage capacity, the limited 
speed of input and output, and the effect which the truncation and round-
off errors may have on the validity of the solution. The methods we choose 
can involve only the finite operations of arithmetic—derivatives are to be 
replaced by difference quotients and integrals by finite sums and compli-
cated functions by polynomial or rational function approximations. While 
any reliable pencil and paper method can be duplicated on a machine, this 
will not always prove to be the best machine technique. For example, the 

8 
INTRODUCTION 
human being, who is slow at calculation and faster at looking things up, 
would prefer to use tables; while the machine, which is tremendously fast 
at arithmetic and rather slow at looking things up, is more efficient in 
recomputing a particular functional value than in looking it up in a table. 
Pencil and paper techniques tend toward a relatively small number of 
powerful computations using more complex methods, while machine 
techniques show a preference for repeating a simple method a large number 
of times. 
In the earlier days of high-speed digital calculators the transition from 
the program to be carried out to the code or sequence of digits required for 
the machine itself was accomplished by hand. Thus, the sequence of steps 
which ultimately provided the solution to a problem might consist of a 
numerical analysis of the problem in order to reduce it to a finite combina-
tion of elementary operations, the rewriting of this as a suitable program 
for the computer, and, finally, the assembly of this program into the strict 
digital code or machine language required by the computer. To facilitate 
this final translation, the program was written in a form very close to the 
absolute machine language itself, and the programmer would usually 
prepare his own coded version and frequently carry out the laborious 
process of checking and correcting the code on the computer. To do this 
effectively he needed an intimate knowledge of the way his computer 
functioned and he needed to think of a mathematical problem from the 
point of view of the computer in a very different form from the usual 
mathematical notations. Because of this intimate knowledge, however, an 
experienced programmer could write highly efficient and time-saving pro-
grams. It is with this basic approach to programming that our earlier 
chapters are concerned. 
As the art of computing developed, it was found that more and more of 
the task could be carried out by the computer itself. With the aid of a 
properly written and already stored assembly program, the, computer 
could give invaluable aid in the final reduction of the program to its .coded 
digital sequence form. This technique permitted the writing of programs in 
a form more convenient to the human being, including the use of alpha-
betical mnemonics in place of digits. As these programming aids became 
more sophisticated, they permitted more and more convenience to the 
programmer. He could write his program in a "problem-oriented" language, 
that is, he could make use of symbols more closely related to the mathe-
matical problem to be solved than the "machine-oriented" symbols re-
quired earlier. In the later chapters we consider both the programs which 
permit this more convenient language and the use of one of the languages 
itself. 

0-2. 
CODING, PROGRAMMING 
9 
With the aid of the kind of translating programs just mentioned, it is 
quite possible for a person to write a program for a computer in a form 
reasonably close to mathematical notation and have it run on a computer 
which he knows nothing about and which he never sees. For the occasional 
user this is the simplest solution. The consistent user, however, will take 
advantage of all the assistance the computer can give him, but he will be 
thoroughly familiar with the computer he uses and the basic machine 
language which is the only kind directly accepted by it. It is for this kind 
of well-rounded programmer that we have ordered the topics in the fol-
lowing chapters. 

CHAPTER 1 
Number Systems 
1 -0. Introduction and General Theory 
As implied by the name, the modern high speed digital computer does 
its arithmetic operations on digits. For reasons of design, however, most 
modern machines do not use the familiar decimal digits for their internal 
arithmetic. The most frequently used system is the binary and, in coding, 
the related octal system. For this reason the coder must become familiar 
with these systems and others which are occasionally used. In this chapter 
we will develop the theory of number systems to any valid base, thus 
laying the groundwork for the specific systems which will be employed 
later. 
In its simplest form a number system is a scheme for representing 
positive integers, and the system which human beings have used most is 
based on the integer ten, presumably because people have ten 
fingers 
(digits). By means of the number ten and the positional system of repre-
sentation, we have a convenient and easily handled way of describing 
integers. For example, in the integer 13402, each digit has a position 
signifying a power of ten, and in writing 1, 3, 4, 0, 2 in order we really 
mean 
1(10
4) + 3(10
3) + 4(10
2) + 0(H)
1) + 2(10°) 
In general, any decimal whole number with digits in order, 
dndn-idn-2 
· · · cWi^o 
is an abbreviation for 
4 ( 1 0 " ) + d^xUo*-
1) + . . . + diCIO
1) + do (10°) 
10 

1-0. 
INTRODUCTION AND GENERAL THEORY 
11 
Looking at it this way, we see that our ordinary decimal representation 
of an integer is a shorthand way of writing a polynomial 
in powers of ten. 
Ten is called the base or radix of the decimal number system. We note that 
the digits or coefficients in the terms are restricted to 0 < d» < 9 and that 
we cannot omit terms with zero coefficients as we might do with poly-
nomials written out (1342 is not the same as 13402). 
As we shall see, any integer r > 1, together with an appropriate set of 
digits, could be used in place of ten, and positive integers expressed as 
polynomials in r. Such a representation gives us a base r number 
system. 
Here and later we shall use the basic division algorithm. 
Theorem 1 -0. For any two integers a > 0 and b > 0 there exist 
unique 
integers q (called the quotient) and f (called the remainder) for 
which 
q>Q,Q<f<b 
and a = b*q + f. 
Proof. Since 0 < 1 < 2 < 3 < · · ·, also 0 < b < 2b < 36 < 
· · · . 
Either a is one of the numbers in the last sequence or is between two. 
That is, a = qb and a — qb = f = 0, or qb < a < (q + 1) b and 0 < a — qb = 
f < b. If there were more than one pair, q and 6, we would have 
a = qib + fi = q2b + f2. But 0 < fi = a — qtb < 6, and 0 < f 2 = 
a — q2b < by so that qxb < a < (qx + 1)6 and q2b < a < (q2 + 
1)6. 
Since a cannot lie in two distinct intervals, 
= q2) from which fι = 
f2, 
and q and f are unique. QED 
We can now establish our basic representation. 
Theorem 1 - 1 . Given an integer r > 1, every positive whole number Ν can be 
represented as a 
polynomial 
Ν = dmr
m 
+ dm-ir™-
1 
+ · · · dir
1 + d0r° 
where the digits satisfy 0 < dj < r — 1, j = 0, 1, · · ·, m; and this repre-
sentation is 
unique. 
Proof. As in Theorem 1-0, divide Ν by r and obtain a quotient Ni < Ν 
(since r > 2) and a remainder d 0, 0 < d0 < r, which gives 
Ν = rNx + do 
Repeat this by dividing Ni by r, and continue, to obtain 
Ν = rNi + dç 
Nx = rN2 + di 
N2 = rNz + d2 
= ri\T i +1 + dj 

12 
1. NUMBER SYSTEMS 
with Ν > Νχ > N2 · · · > Νj > · · · and 0 < dy < r. Since the Ns form 
a strictly decreasing sequence of nonnegative integers, there must be one 
equal to zero, say iV m+i, and we terminate with 
Nm-i 
= rNm 
+ 
dm-i 
Nm 
= r-0 + 
dm 
Successive substitutions give us 
Ν = do + rNi 
= do + r(dx 
+ rN2) 
= d0 + rdx + r
2( d 2 + 
rNz) 
= · · · = d 0 + rdi + r
2d2 + rHz + · · · + r
m~
l dm-\ + r
m dm 
To prove uniqueness we assume a representation 
Ν = cmr
m 
+ · · · + c 0r° 
(if the number of terms differed we could fill in with zeros). If any digit 
differs from the initial representation, there must be a first, say cy — dj 9* 0. 
But 
Ν - 
Ν = (cm 
- dm)r
m 
+ 
· · · + 
(c 0 - 
do) 
= 
(cm 
- 
dm)r
m 
+ 
· · · + 
(c y - 
dj)r* 
= 
0 
Hence, 
cy - 
dy = (dy +i - 
Cy+i)r + 
· · · + 
(dm 
- 
c m) r
m~
y 
= r[(dj+i 
- 
cy+i) + · · · + (dm - 
cm)r
m-i-
l~] 
is exactly divisible by r. Since — (r — 1) < cy — dy < r — 1, cy — dy = 0, 
and we contradict the assumption that there is a different digit. Q E D 
Therefore, by Theorem 1-1, we can defioe a base r number system and 
give the unique polynomial representation of any integer Ν by the same 
positional system we use in decimal as 
Ν = dmr
m 
+ dm-\r
m~
l 
+ · · · + dir
1 + d0r° = dmdm-i 
· · · did 0 
where the digits satisfy 0 < dy < r — 1. The most important bases we will 
use are r = 2, r = 8, and r = 10. The ordinary decimal system is r = 10 
and requires no further discussion. 
Counting, for any base r, is the same as in decimal with the largest digit, 
r — 1, playing the same role as nine in decimal; that is, to go from Ν to 
Ν + 1, we increase the first digit from the right which is less than r — 1 
by one and replace all (r — l)'s to its right by zeros. Using this scheme 

1-1. 
CONVERSION OF INTEGERS 
13 
we see that the first seventeen nonnegative integers represented in binary, 
octal, and decimal are those shown in the accompanying tabulation. 
Binary 
Octal 
Decimal 
0 
0 
0 
1 
1 
1 
10 
2 
2 
11 
3 
3 
100 
4 
4 
101 
5 
5 
110 
6 
f 
111 
7 
7 
1000 
10 
8 
1001 
11 
9 
1010 
12 
10 
1011 
13 
11 
1100 
14 
12 
1101 
15 
13 
1110 
16 
14 
1111 
17 
15 
10000 
20 
16 
1-1. Conversion of Integers from One Base to Another 
In this section we consider the problem of converting the representations 
of integers from one base to another. We assume that we are given the 
digits of the representation of the number in the base r and that we wish 
to convert them to the digits for the base r* system. The fundamental 
idea behind this conversion is the one expressed in the proof of Theorem 
1-1, the digits being generated as the remainders in the division process. 
Example 1 -0. Convert the decimal number 402 to binary and octal. 
We form (in decimal) 
402 — 2(201) + 0 
and 
402 = 8(50) + 2 
201 = 2(100) + 1 
50 = 8(6) 
+ 2 
100 = 2(50) 
+ 0 
6 = 8(0) 
+ 6 
50 = 2(25) 
+ 0 
25 = 2(12) 
+ 1 
12 — 2(6) 
+ 0 
6 = 2(3) 
+ 0 
3 = 2(1) 
+ 1 
1 = 2(0) 
+ 1 

14 
1. NUMBER SYSTEMS 
Since the digits are obtained in reverse order, we read up and have 
(402) 10 = (110010010) 2 = (622) 8 
Here and elsewhere in this book decimal subscripts indicate the base of 
the representation. 
A frequent question asked by the beginner is, "How do you read numbers 
in other bases?" For example, if four hundred and two is (622) 8, how is the 
last version to be read? Habit is likely to produce "six hundred and twenty-
two" which is not a correct name although probably understandable. A 
simple solution to the problem is simply to read the digits in order (as in a 
telephone number) ; say "octal, six, two, two." 
If r < 10 and we wish to convert from decimal to base r we may use the 
usual symbols for the base r digits. For r > 10, however, we will have to 
introduce new symbols of our own. In base twelve, for example, we cannot 
represent the digit ten by its familiar form, 10, since this is the symbol for 
twelve. A system with base sixteen (hexagesimal) is sometimes used in 
connection with computers. Here we might arbitrarily introduce symbols 
for digits as 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, u, v, w, x, y, ζ (where the letters repre-
sent ten through fifteen in order). Conversion is the same. 
Example 1 - 1 . Convert the decimal number 3122 to base sixteen. We form 
in decimal 
3122 = 16(195) + 2 
195 = 16(12) 
+ 3 
12 = 16(0) 
+ 12 
Replacing 12i 0 by the agreed symbol, w, we write 
(3122) io = 
(1*32)10 
All of the above examples were from decimal to a different base. Pre-
cisely the same scheme works for conversion from any base to any other. 
However, this mil require that the arithmetic 
be done in the original 
base, 
a topic which will be treated in the next section. Since it takes time to 
become facile with such arithmetic, an alternative scheme in which all 
arithmetic is done in decimal can be used. We simply go back to the mean-
ing of the positional representation. Several examples will serve, with all 
notations in decimal except as noted. 
Example 1-2. Convert (1101101) 2 to decimal. Write 
(1101101) 2 = 1(2·) + 1(2
5) + 0(2
4) + 1(2
8) + 1(2
2) + 0(2) + 1 
- 
1(64) + 1(32) + 1(8) + 1(4) + 1 = 109 

1-2. 
ARITHMETIC, BASE Γ 
15 
Example 1-3. Convert (2307) 8 to decimal. Write 
(2307) 8 = 2(8
3) + 3(8
2) + 0(8) + 7 = 2(512) + ' 3 ( 6 4 ) + 7 = 1223 
Example 1 -4. Convert (y29) ιβ to decimal. Write 
(2/29) ie = 14(16
2) + 2(16) + 9 = 14(256) + 2(16) + 9 = 3625 
Note that the greater the base the greater the economy of notation; that 
is, in general, fewer digits are needed to represent an integer of given size. 
1 -2. Arithmetic, Base r 
In a base r number system in accordance with Theorem 1-1, we can get a 
unique representation of any whole number Ν as 
Ν = dmr
m 
+ · · · + d 0 = dm · · · d0 
In addition to being a convenient way of expressing integers, this system 
permits us to do arithmetic in a simple fashion, because we can do it 
digit by digit. Basically all of the algorithms of decimal arithmetic are just 
applications of similar operations done on polynomials, with the con-
venience of the positional system. Thus to add two numbers, base r, we 
group like terms and obtain for 
M = 
CmCm-l 
· · · CiCo = CmT
m + · · · + Co 
and 
Ν = dmdm-i 
· · · dido = dmr
m + · · · + d0 
the sum 
Μ + Ν = (cm + dm)r
m 
+ - - - + (co + do) 
If all (ck + dk) are digits, we are through. Suppose, however, that some 
such sum exceeds r — 1. Then if ck + dk > r, we have r < ck + dk < 
r + r — 2. Therefore, ck + dk = r + Sk where 0 < sk < r — 2. We can 
then write for the two terms 
(ck + dk)r
k 
+ 
(Ck+i 
+ 
dk+i)r*+i 
= 8kr» + (1 + 
ck+i 
+ 
d ^ i ) ^ 
The 1 grouped with the r
k+1 
term is called the carry and sk is called the 
sum digit. We note that even if a carry is included from the next lower 
order that l + c
k + dk<r 
+ r— 1 and 0 < sk < r — 1 so that only a 
one carry can occur. If ck + dk = r — 1, a carry from the next lower order 
will generate a carry, and sk = 0. 
Subtraction is similar. If some (ck — d k ) < 0 we can write 
• · · + 
(Ck+i 
- 
dk+i 
- 
l ) r *
+ 1 + (r + ck — dk)r
k 
+ · · · 
and the — 1 appearing in the k + 1 position is called the borrow. As with 
carries, only a unit borrow can occur. 

16 
1. NUMBER SYSTEMS 
Multiplication (and its inverse, division) can be done, as in decimal, 
using the rules for multiplying and dividing polynomials with 
shifting 
taking care of the powers of r involved. The use of the usual digit-by-digit 
decimal techniques in any base will become clear when we consider the 
particular applications to base r = 2 and r = 8 in the next two sections. 
To summarize, we note that all the digit-by-digit algorithms for arith-
metic have the same form in any base r as they have in decimal. Thus, in 
order to perform arithmetic in a given base r, we need only keep in mind 
the addition, subtraction, and multiplication tables for all possible com-
binations of base r digits. 
1 -3. Binary Arithmetic 
For digit-by-digit addition in binary we need consider only two binary 
digits (usually called bits), and there are four possibilities: 
0 
0 
1 
1 
+ 0 
+ 1 
+ 0 
+ 1 
0 
1 
1 
10 
In the last case, 1 + 1 = 10 (one plus one equals two), we have a carry of 
one. In the others, the carry is zero. We can arrange this in a convenient 
addition table for binary : 
+ 
0 
1 
Carry 
Sum 
Carry 
Sum 
0 
0 
0 
0 
1 
1 
0 
1 
1 
0 
Example 1 -5. In this example, the carry digits are placed above the 
digits they are added into, and enclosed in boxes. Note that in the 5th 
place from the right, we have a total of 3 = 11 (binary) including the 
carry digit. 
087 
decimal 
= 
1010111 
binary 
+026 
decimal 
= 
+0011010 
binary 
113 
decimal 
= 
1110001 
binary 

1-3. 
BINARY ARITHMETIC 
17 
Subtraction, base 2, is the inverse of addition, and we subtract digit by-
digit with a borrow of one from the left when a one is subtracted from a 
zero. The table for the borrow and difference digits is: 
-
0 
1 
Borrow 
Difference 
Borrow 
Difference 
- 0 
0 
0 
0 
1 
- 1 
1 
1 
0 
0 
Example 1 -0. 
IH 
CCD 
25 
decimal 
= 
11001 
binary 
—7 
decimal 
= 
—111 
binary 
18 
decimal 
= 
10010 
binary 
Here the "borrows" are shown above the digits affected. 
In multiplication, base 2, we use the same algorithm as in decimal, 
based on the product of the two polynomials, multiplying one digit at a 
time and adding the partial products correctly shifted over. The multi-
plication of two binary digits also presents four possibilities : 
0 
0 
1 
1 
x o 
X I 
x o 
X I 
0 
0 
0 
1 
The simplicity of this multiplication table is another reason for the 
preference for binary in digital computers. 
Example 1 -7. 
11 
decimal 
= 
1011 
binary 
X 6 
decimal 
= 
XI10 
binary 
0000 
1011 
1011 
66 
decimal 
= 
1000010 
binary 

18 
1. NUMBER SYSTEMS 
For division we arrange our work in the same format as in decimal, as 
illustrated in the following example. 
Example 1-8. 
Decimal 
Binary 
11 
1011 
13JÏ50 
1101)10010110 
13 
1101 
20 
10111 
13 
1101 
7 
(remainder) 
10100 
1101 
111 
(remainder) 
Note that division is also simple in binary, since the only quotient digits 
are zeros and ones. To see if one number will "go into another" we simply 
compare their magnitudes. 
For any other base r we need keep in mind tables for addition, subtrac-
tion, and multiplication. The smaller the value of r, the simpler these 
will be, and for this reason the binary system gives the simplest computa-
tions of all. This explains why almost all modern machines use an internal 
binary arithmetic. The lack of economy of notation makes the use of 
binary cumbersome for hand calculation. 
1 -4. Octal Arithmetic 
In the octal number system r = 8 and, in accordance with Theorem 1-1, 
we can uniquely represent any whole number as a sequence of the digits 
dj, where the dj are either 0, 1, 2, 3, 4, 5, 6, or 7. Thus, in octal, the number 
thirteen would be represented by 15 since 
13 = 1-8
1 + 5-8° 
From the remarks of the previous section we see that we need only keep 
in mind the addition, subtraction, and multiplication tables for octal 
digits in order to carry out arithmetic with numbers in this representation. 
These tables are given below. 

1-4. 
OCTAL ARITHMETIC 
OCTAL ADDITION TABLE 
19 
+ 
0 
1
2
3
4
5
6
7 
Carry 
Sum 
C s 
c s 
c s 
C s 
C s 
C s 
C s 
+ o 
0 
0 
0 
1 
0 
2 
0 
3 
0 
4 
0 
5 
0 
6 
0 
7 
+ 1 
0 
1 
0 
2 
0 
3 
0 
4 
0 
5 
0 
6 
0 
7 
1 
0 
+ 2 
0 
2 
0 
3 
0 
4 
0 
5 
0 
6 
0 
7 
1 
0 
1 
1 
+ 3 
0 
3 
0 
4 
0 
5 
0 
6 
0 
7 
1 
0 
1 
1 
1 
2 
+ 4 
0 
4 
0 
5 
0 
6 
0 
7 
1 
0 
1 
1 
1 
2 
1 
3 
+ 5 
0 
5 
0 
6 
0 
7 
1 0 
1 
1 
1 
2 
1 
3 
1 
4 
+ 6 
0 
6 
0 
7 
1 
0 
1 
1 
1 
2 
1 
3 
1 
4 
1 
5 
+ 7 
0 
7 
1 
0 
1 
1 
1 
2 
1 
3 
1 
4 
1 
5 
1 
6 
OCTAL SUBTRACTION TABLE 
Subtrac-
tion 
0 
1
2
3
4
5
6
7 
Borrow 
Diff. 
Β D 
Β D 
Β D 
Β D 
Β D 
Β D 
Β D 
- 0 
0 
0 
0 
1 
0 
2 
0 
3 
0 
4 
0 
5 
0 
6 
0 
7 
- 1 
1 
7 
0 
0 
0 
1 
0 
2 
0 
3 
0 
4 
0 
5 
0 
6 
- 2 
1 
6 
1 
7 
0 
0 
0 
1 
0 
2 
0 
3 
0 
4 
0 
5 
- 3 
1 
5 
1 
6 
1 
7 
0 
0 
0 
1 
0 
2 
0 
3 
0 
4 
- 4 
1 
4 
1 
5 
1 
6 
1 
7 
0 
0 
0 
1 
0 
2 
0 
3 
- 5 
1 
3 
1 
4 
1 
5 
1 
6 
1 
7 
0 
0 
0 
1 
0 
2 
- 6 
1 
2 
1 
3 
1 
4 
1 
5 
1 
6 
1 
7 
0 
0 
0 
1 
- 7 
1 
1 
1 
2 
1 
3 
1 
4 
1 
5 
1 
6 
1 
7 
0 
0 
OCTAL MULTIPLICATION TABLE 
X
0
1
2
3
4
5
6
7 
0
0
0
0
0
0
0
0
0 
1
0
1
2
3
4
5
6
7 
2 
0 
2 
4 
6 
10 
12 
14 
16 
3 
0 
3 
6 
11 
14 
17 
22 
25 
4 
0 
4 
10 
14 
20 
24 
30 
34 
5 
0 
5 
12 
17 
24 
31 
36 
43 
6 
0 
6 
14 
22 
30 
36 
44 
52 
7 
0 
7 
16 25 
34 
43 
52 
61 

20 
1. NUMBER SYSTEMS 
We will now make use of these tables to carry out the examples of the 
previous section in octal. 
Example 1-9. 
Uli 
087 
decimal 
+026 
decimal 
Example 1-10. 
Example 1-11. 
Example 1-12. 
Decimal 
11 
13) 
150 
- 1 3 
20 
-13 
111 
127 
octal 
+032 
octal 
113 
decimal 
= 
161 
octal 
11 
decimal 
X 6 
decimal 
13 
octal 
X6 
octal 
66 
decimal 
= 
102 
octal 
25 
decimal 
— 7 
decimal 
LLI 
31 
octal 
— 7 
octal 
18 
decimal 
= 
22 
octal 
Octal 
13 
15) 
226 
- 1 5 
56 
-47 
7 
remainder 
7 
remainder 
We are now in a position to consider the alternate method for conversion 
from bases, other than ten, into decimal. We use the same division process 
as before, and now do the arithmetic in the appropriate base, that is, the 
base of the system in which the number is originally represented. 

1-4. 
OCTAL ARITHMETIC 
21 
Example 1-13. Suppose we wish to express the binary number 110010011 
in decimal. We successively divide by ten in binary (1010) to get (in 
binary) 
110010011 = (1010) 
(101000) + 
11 
101000 = (1010) 
(100) 
+ 
0 
100 = (1010) 
(0) 
+ 100 
This is obtained by the following arithmetic : 
101000 
1010)110010011 
1010 
1010 
1010 
0011 = 
do 
Therefore, d0 = 3 in decimal. We divide again, 
100 
1010)101000 
1010 
000 = 
di 
Thus, d\ = 0. The third division is trivial: 
0 
lOlOjIOO 
0 
100 = 
d2 
Hence, 110010011 2 = 403 i 0. 
Similarly, we can now go directly from one base to another without 
intermediately using decimal. As an example, we consider a conversion 
from base seven to base three. 
Example 1-14. Convert (1406) 7 to base three. We form (all base seven) 
1406 = 3(346) + 2 
346 = 3(114) + 1 
114 = 3(26) 
+ 0 
26 = 3(6) 
+ 2 
6 = 3(2) 
+ 0 
2 = 3(0) 
+ 2 

22 
1. NUMBER SYSTEMS 
This is based on the following divisions: 
346 
114 
3)1406 
3}ö46 
12 
3 
20 
4 
15 
3 
26 
16 
24 
15 
2 = do 
1 = 
d1 
26 
3 ) i l 4 
6 
24 
24 
0 = 
d2 
6 
26 
24 
2 = d 3 
2 
0 
3)6 
3 j 2 
6 
0 
0 = di 
and 
2 = 
db 
Therefore, 1406 7 = 202012 3. 
1-5. Fractions 
Although many digital computers use a mode of arithmetic in which all 
sequences of digits are interpreted as integers, others are so designed that 
all such sequences are interpreted as fractions. Regardless of whether we 
are computing with a machine of integral or fractional type, mixed num-
bers will generally enter into our problems. Thus, we will need to be 
familiar with the representations of both fractions and integers. Ac-
cordingly, we will devote this section to the study of representations of 
fractions in general number systems. The extension of the digital repre-

1-5. 
FRACTIONS 
23 
sentation to fractions, or rational numbers, is given by the following 
theorem. 
Theorem 1 -2. Let a and b be any two positive whole numbers and r an integer, 
r > 2. Then there exist digits djy 0 < dj < r such that a/b can be represented 
as a series 
Since 
— < - 
and 
! _ > Q 
r
kb 
r
k 
r
k 
1
 
k 
b 
Finally, by Theorem 1-1, Q = dnr
n 
+ · · · + d0. 
Q E D 
Proof. Form the following infinite sequence of divisions: 
From Theorem 1-0, 0 < Äy < b. Hence 
By successive substitutions we have 
Hence, the partial sum 
from the series 

24 
1. NUMBER SYSTEMS 
We extend the positional notation and introduce a period to separate 
negative and nonnegative powers of r and write 
7 = dnr
n 
+ · · · + d0 + cLir"
1 + d_ 2r"
2 + · · · = dn · · · do-d^d^ 
· · · 
ο 
The period is called the base point or radix pom£. For r = 10 it is the decimal 
point, and for r = 2 and r = 8 it is the binary point and octaZ point, re-
spectively. 
We note that Q = dndn-i 
· · · cMo is a whole number, called the integral 
part of a/b. The sequence to the right of the radix point is called the frac-
tional part of a/b. For this sequence, we have 
.cLid_2 · · · = d-ir-
1 + d_ 2r-
2 + - - - < (r - 
l ) / -
1 + (r - 
l)r~
2 + · · · 
= (r - 
1 ) ^ ( 1 + r"
1 + r-
2 + . · . ) = 
1 
If we eliminate writing the integer one as a sequence of digits all of which 
are (r — 1), the fractional part is always less than one. 
It can be proved that the representation of Theorem 1-2 [with the above 
agreement about unending sequences of (r — l ) ' s ] is unique. It can also 
be proved that every irrational number has such a representation. Thus, in 
binary τ = 11.001001000011 · · · . Practically speaking, however, whether 
the number is rational or irrational, we almost always deal with a truncated 
version of the number, which is itself rational. Before dealing with this 
truncation procedure, we give some examples of the use of Theorem 1-2. 
Example 1-15. Convert the fraction 14/3 to binary. We form (in decimal) 
14 = 3(4) + 2 
2(2) = 3(1) + 1 
2(1) = 3(0) 
+ 2 
2(2) = 3(1) + 1 
with obvious repetition. Setting the integral part 4 = 100 2 we have 14/3 = 
100.101010... 2. 
Example 1-16. Convert the fraction 29/7 to octal. We form (in decimal) 
29 = 7(4) + 1 
8(1) = 7(1) + 1 
8(1) = 7(1) + 1 
and as above, 29/7 = 4 . 1 1 1 . . . 8. 

1-5. 
FRACTIONS 
25 
If ρ is the highest power of r for which Ν has a nonzero digit, then 
Ν = 2 da* 
T—Ρ 
where ρ may be negative or nonnegative. If ρ < 0, Ν < 1 and if ρ > 0, 
Ν > 1. If we use a truncation procedure which merely discards digits, then 
we approximate Ν by 
P-(*-I) 
i— Ρ 
The digits retained are called significant digits, and if there are s of them, 
we say that Ν is represented by s significant digits. Although Ν is generally 
different from N, we use Ν for Ν for all practical purposes; and we will 
usually make no attempt to introduce a separate notation. 
The number of significant digits retained determines the accuracy of the 
rounded-off number. If simple truncation of the sequence is used, we get an 
accuracy which depends on the base and the number of digits used. A basic 
result is given in the following theorem. 
Theorem 1 -3. / / s significant digits are retained in a number N, the refotive 
error does not exceed 
r~
i8~
l\ 
Proof. Since 
Ν = dpr* + · · · + d p _ e +i r P -
e + 1 + dp.8r^-
8 
+ · · · 
and 
Ν = dpr*> + · · · + 
dp-8+lr^-
e+l 
the error 
Ν — Ν = dps*-' 
+ dp-^r**-*-
1 + 
··· 
Hence, 
Ν — Ν < (r - 
l)r*-
e + (r - 
l ) ^ * "
1 + · · · 
= (r - 
l)rr-"(l + r-
1 + r~
2 + · · ·) 
Since dp > 1, Ν > r», and 1/N < τ-*, so that 
Ν - 
Ν 
— — — 
< 
R-P rp-«+i = r-(s-i) 
Q E D 
This means that the error is no more than one in the final digit retained, 
and does not apply to the truncation procedure usually called rounding 
off. Rounding off retains dp_,+i, if the error is known to be less than fr*-**
1 

26 
1. NUMBER SYSTEMS 
and rounds it to dp_,+i + 1 if the error is known to be larger than this. This 
procedure gives a relative error between — ^r~
(*
_ 1) and |r~
(*
_ 1 ). If r = 2 
and nothing is known about the error, it presumably lies with equal proba-
bility in either the range 0 to 2*-* or 2
p-» to 2
p~
e + 1. This accounts for the 
custom sometimes used of rounding the final binary digit to one so that 
round-off errors will be approximately half in each direction. 
It is obvious that we may increase accuracy by increasing the number of 
significant digits or by increasing r, and that, for a given accuracy, more 
digits are required with small r than with large r. For example, since 
logio2 is about .3, or close to one third, it requires roughly three times as 
many binary digits as decimal digits for comparable accuracy. 
Although we have made a slight distinction in truncation procedures, we 
shall actually use the terms truncated and rounded-off more or less inter-
changeably. If a precise procedure is intended, context will make it clear. 
1 -6. Conversion of Mixed Numbers 
In Section 1-1 we considered the conversion of integers from one base to 
another. We now treat the same problem for the case of mixed numbers. 
The basic scheme is contained in the proof of Theorem 1-2. The 
first 
quotient, Q, is the integral part of the number and is converted as in Section 
1-1. The rest of the quotients give, in order, the digits to the right of the 
base point. If the conversion is for a fraction, two procedures are available. 
These are illustrated in the following examples. 
Example 1-17. Convert the decimal fraction 14/3 to binary and octal. 
We form in decimal 
14 = 3(4) + 2 
and 
14 = 3(4) + 2 
2(2) = 
4 = 3(1) + 1 
8(2) = 16 = 3(5) + 1 
2(1) = 
2 = 3(0) + 2 
8(1) = 
8 = 3(2) + 2 
2(2) = 
4 = 3(1) + 1 
8(2) = 16 = 3(5) + 1 
In each case the sequence repeats. The integral part is 4 which we 
convert to IOO2 and 4 8, adjoining the digits to the right as given by the 
remaining quotients. We have 
14/3x0 = 100.10101...2 = 4 . 5 2 5 2 . . . 8 
The other alternative is to convert numerator and denominator to the new 
base, and use arithmetic as follows. 

1-6. 
CONVERSION OF MIXED NUMBERS 
27 
Example 1-18. We write 
(y) 1 0
 = (irl
= (y) 8 
Since multiplication by r, base r, is just "bringing down the next zero," 
we use long division. For base 2, 
100.10101... 
11) 
1110.00000 
- 1 1 
100 
- 1 1 
100 
- 1 1 
1 . . 
and for base 8, 
4.5252.. 
3) 
16.0000 
- 1 4 
20 
- 1 7 
10 
- 6 
2 0 . . . 
The most common problem is that of converting a mixed number, that is, 
given dn · · · do*d_i · · · cL*, base r, to find the equivalent sequence of 
digits for base r*. The problem is still one of converting a fraction, but if 
arithmetic is done in base r, a very simple device is available. We see that 
j 
j 
j 
, 
dn 
· · · dod-i 
· · · 
d_* 
an · · · α 0·α-ι · · · «-* = 
We employ the division algorithm of Theorem 1-2. We see at once that 
the initial quotient is the integral part (converted as usual) given by 
dn · · · d 0, and the first remainder is given by d_i · · · dL*. Since each sue-

28 
1. NUMBER SYSTEMS 
ceeding division is by r*, it can be accomplished by shifting the base point, 
provided arithmetic is done base r. We achieve this result by leaving the 
base point in and multiplying the fractional 
part by r*. The integral part 
of the product gives the quotient or digit. This process is then repeated, 
as in the following example. 
Example 1-19. Convert the decimal number 23.247 to binary and octal. 
Since 23 is the integral part we convert it to 101112 and 27 %. The digits to 
the right of the point are then given by 
r = 8 
r = 2 
r 
.247 
2 
.976 
2 
.247 
8 
0.494 
<Li = 0 
1.952 
d-i = 1 
1.976 
.494 
2 
.952 
2 
.976 
8 
0.988 
d-2 = 0 
1.904 
<L, = 1 
7.808 
.988 
2 
.904 
2 
.808 
8 
= 7 
1.976 
d_3 = 1 
1.808 
d_* = 1 
6.464 
d_ 3 = 6 
Hence, 23.247i 0 = 10111.001111.. . 2 = 27.176... 8. 
Example 1-20. Convert 1101.101 binary to decimal. The integral part 
is IIOI2 = 13io. The fractional part is converted by multiplying by ten 
in binary: 
.101 
.010 
.1 
1010 
1010 
1010 
1010 
0100 
101.0 
cL 3 = 5 
101 
010 
110.010 
cLi = 6 
10.100 
d_2 = 2 
so that 1101.101 2 = 13.625io. 
In general, this procedure yields an infinite sequence of digits, although 
the last example was one in which both representations 
terminated. 
Practically, of course, the process is always terminated with a rounded-

1-7. 
BINARY-OCTAL CONVERSION 
29 
off version of the same order of accuracy as the original number (pre-
sumably also rounded-off). 
1 -7. Binary to Octal and Octal to Binary Conversion 
Since eight is a power of two, the conversions from binary to octal and 
octal to binary are very simple. Let 
Ν = du+2 du+i 
du 
· · · cWido = d3*+22
3*+
2 + · · · + dx2 + do 
be the binary representation of an integer, N. If the total number of 
digits, 3fc + 3, is not originally divisible by three, fill in with zeros. Con-
sider this as written out in reverse order and grouped as follows: 
Ν = (do + di2 + d 22
2) + (d 32
3 + d 42
4 + rf62
5) + · · · 
+ (dzk2*
k + <Vi2
3*
+1 + <W22
3*+
2) 
= (do + di2 + d 22
2) + (dt + dA2 + d 62
2)2
3 + 
. . . 
2 + c? 3 Ä + 22
2)2
3 fc 
Each group of three is followed by a power of two which is also a power 
of eight. Let Cy = day + d 3y +i2 + d 3y + 22
2,j = 0, 1, · · ·, k. Since each dj < 1, 
each Cj < 7 and is a legitimate octal digit. Hence, we have 
Ν = Co + 
C i 8 + c 28
2 + · · · + ckS
k = CkCk-i 
· · · 
CiCo 
as the unique octal representation of N. In this manner we derive the 
following simple conversion rule: To convert an integer from binary to octal, 
first group the binary digits into sets of three, beginning 
at the right. 
Then 
write down the octal digit corresponding to the set of three binary digits accord-
ing to the accompanying 
table. Thus, if Ν = Oil, 100, 101, 111, 000, 001, 
Binary 
Octal 
000 
0 
001 
1 
010 
2 
011 
3 
100 
4 
101 
5 
110 
6 
111 
7 
100, 111, 010, 001, 101 in binary, then Ν = 34570147215 in octal. 

30 
1. NUMBER SYSTEMS 
It is clear from what we have just said that to make the reverse transfor-
mation from octal to binary, we simply replace each octal digit with its value 
as a three binary digit integer according to the table above. Thus, if we are 
given Ν = 62407531 in octal, we know at once that Ν = 110 
010 
100 
000 
111 
101 
Oil 
001 in binary. We leave it to the reader to apply 
the general rules for converting representations of fractions to the special 
cases at hand and convince himself that the rule given in the integer 
case still holds, with the change that binary digits are now to be grouped 
to the right of the point. 
Thus 
001, 
010, 
110 
011, 
1002 = 126.34 8 
and vice versa. 
Although the simplicity of binary arithmetic makes it desirable in 
machines, the large number of digits necessary to represent numbers in 
this system makes it cumbersome for human beings. Accordingly, we will 
ordinarily avail ourselves of the more economical and powerful octal 
notation as a "shorthand" for the binary. This does not affect the results 
of arithmetic which are independent of the number representation being 
used. Using octal for binary in this manner entails no particular difficulty 
for the programmer, since the conversions, as we have just seen, are 
almost immediate. 
Conversions between binary representations of numbers and representa-
tions in any other base which is a power of two are also immediate. Thus, in 
dealing with a binary computing machine in which all of the important 
numbers are given by an amount of digits which is a multiple of 4, the 
coder may find the number system based on 2
4 to be a convenient short-
hand for binary. With the notation of Section 1-1, we would have the 
following table : 
Binary 
Hexagesimal 
Binary 
Hexagesimal 
0000 
0 
1000 
8 
0001 
1 
1001 
9 
0010 
2 
1010 
u (ten) 
0011 
3 
1011 
ν (eleven) 
0100 
4 
1100 
w (twelve) 
0101 
5 
1101 
χ (thirteen) 
0110 
6 
1110 
y (fourteen) 
0111 
7 
1111 
ζ (fifteen) 

1-8. 
COMPLEMENT ARITHMETIC 
31 
1 -8. Complement Arithmetic 
So far we have discussed only positive integers. We must also investigate 
ways of handling negative integers. We may, of course, associate a plus ( + ) 
or minus ( — ) sign with the integer, and use the ordinary laws of algebra. 
This presents little difficulty to the human being, but it does represent 
some additional circuitry for the computer. For example, if the sum of 
two integers is wanted, the computer must inspect the sign of each number, 
decide whether to add or subtract the absolute values, and then determine 
the sign of the answer. The procedures for dealing with negative integers 
as well as the corresponding hardware can be simplified by the use of 
what we call complement 
arithmetic. 
If we permit the introduction of 
complement numbers in the arithmetic registers of the computer, we can 
eliminate the necessity of building either addition or subtraction 
(but 
not both) of absolute values into the computer. If the subtraction opera-
tion is eliminated, it can be carried out by addition of a complement 
number. On the other hand, if the addition operation is eUminated, its 
effect can be achieved by subtraction of a complement number. With 
complement numbers in both storage registers and arithmetic registers, 
an even greater simplification can be obtained, although multiplication 
and division operations become somewhat more complex. 
Before defining the complement of an integer, we introduce a simple idea 
based on the division algorithm of Theorem 1-0. Suppose m > 0 is a 
fixed integer. Then any integer Ν > 0 defines a unique remainder from 
Ν = qm + f 
with 0 < f < m — 1. Now if we permit negative quotients, 
this same 
scheme can be extended to integers Ν < 0, with the remainder in the same 
range. This subdivides all integers into classes corresponding to the m 
possible values of the remainder. If two integers are from the same class, 
they have the same remainder on division by m, say 
Ν = qtm + f 
and 
M = qtfn + f 
so that Ν = M = (qi — q2)m is exactly divisible by m. If this is true, we 
say that Ν is congruent or equivalent to Μ, modulo m, and write 
Ν = M (mod m). 
Now suppose that we have a computer using numbers of a fixed size, 
that is, using η digits to the base r. The numbers representable are 0, 1, 

32 
1. NUMBER SYSTEMS 
2, · · ·, r
n — 1, and these correspond exactly to the set of possible remainders 
modulus m = r
n. If we started counting on the machine, as soon as we 
got to r
n — 1 and added one, the machine would show zero since high 
order carries are lost. This is what occurs when an automobile odometer 
goes from 99999 to 00000. In other words, numbers differing by multiples 
of r
n are equivalent as far as the computer is concerned. Hence, if Ν can 
be represented on the computer, any other integer M, such that M 
= 
Ν (mod m = r
n), will also have its representation given by N. 
Another modulus which often proves to be convenient is that for 
m = r
n — 1. For this modulus counting on the machine is arranged so 
that carries from the highest order are not discarded, but are added, 
end-around, into the lowest order position. This will make numbers differ-
ing by multiples of (r
n — 1) equivalent as far as the computer is con-
cerned. Hence, if Ν can be represented on the computer, any other integer 
M such that Μ = Ν (mod m = r
n — 1) will also have its representation 
given by N. 
For defining the complement we assume integers of a fixed number 
of digits, say n. An integer, N, is thus allowable if and only if | Ν \ < r
n. 
Then, if 0 < Ν < r
n, we define its r's complement to be r
n — Ν and its 
(r — l)'s complement to be (r
n — 1) — N. Since Ν is allowable, both of its 
complements are nonnegative. 
In using complement arithmetic, we replace every negative number, 
— I Ν I, by the complement of | Ν |, and leave positive numbers un-
changed. We note that 
- I Ν I s r
n - I N\ (mod r
n) 
and 
- I Ν I = 
(r» - 
1) - I Ν I (mod r
n - 
1). 
This gives rise to a consistent arithmetic based on nonnegative integers. 
Proof of consistency can be based on congruences. We shall show con-
sistency in a few cases and give illustrations. 
Suppose now that we further restrict the size of the numbers to be 
represented on the machine to the range | Ν | < r
n~
l. 
Then any positive 
number would have a high order digit of zero, but the complement of such 
a number (representing its negative) would begin with r — 1. So, de-
spite the fact that introduction of complements for negative integers 
means that we will deal exclusively with nonnegative integers, we 
can always recognize a complement representation by noting that its 
leading digit is r — 1, the largest in the given number system. Except 
for binary, the restriction of the high order place to zero or (r — 1) is 
overly restrictive but simpler. 

1-8. 
COMPLEMENT ARITHMETIC 
33 
To change the representation of an integer to the representation of its 
negative, we complement it. The complement of the complement is the 
original number. 
We will now proceed to develop some properties of these complements. 
In particular, we will show that by introduction of the r's complements 
we can perform the process of addition of two integers Ni and N2 of any 
sign without subtracting. Since all carry into the (n + l)st order position 
corresponds to a multiple of r
n, we ignore it; that is, if 
M 
= cr
n 
+ dn-ir"-
1 
+ 
· · · + 
do 
the machine equivalent is 
Ν 
= dn-ir
n~
l 
+ 
· · · + 
do = 
· · · do 
There are four cases to consider. 
In case 1, both iVi and N2 are positive, and the sum Ni + N2 is correctly 
given in the usual way, provided Ni + N2 < r
n. 
In case 2, one of JVi or N2 is negative, the other positive, and the sum 
is negative. Without loss of generality, we may take Ni 
> 0, N2 
< 0. 
Then N2 will be written r
n + N2 in complement form. Then the sum 
Ni + (r
n + N2) 
will represent the correct negative sum written in r's 
complement form. 
In case 3, Ni > 0 and N2 < 0, but the sum is positive. In this case JVi + 
(r
n + N2) 
> r
n, and is therefore not an allowable integer, being too large. 
But if r
n is subtracted from the number, we will have the correct sum in 
the ordinary base representation. We note that r
n is represented by a 1 
followed by η zeros in base r notation. Hence, this subtraction simply 
consists of dropping off the initial 1 in the (n + l)st digit: i.e., of dis-
carding the carry from the nth digit position. 
In case 4, iVi and iV2 are both negative, and we write them both in com-
plement form. Then the addition in complement form will be (r
n + Ni) 
+ 
(r
n + JV2) = 2r
n + Ni + N2. But we know the sum is negative, and so 
should be written as r
n + iVi + N2, in complement form. Hence, we must 
again subtract r
n from the result by dropping off the carry from the nth 
digit position. 
We have shown that if the two numbers iVi and N2, as well as the sum 
Ni + N2, are of the allowable size, we get the correct representation of 
the sum by replacing negative integers by complements and throwing 
away the carry from the nth digit position when it appears. If | Ni + N2 \ < 
r
n _ 1, the leading digit of the result will determine its sign with the digit 
r — 1 indicating a negative answer and the digit zero a positive answer. 
Some examples may clarify the process. 

34 
1. NUMBER SYSTEMS 
We first note that if (base r) 
M = d n_id n_2 - 
"do 
then the r's complement of M is r" — M or 
10 
0 
· · · 0 
— dn-\dn-i 
" ' d o 
To form the complement we leave all zeros on the right, subtract the first 
nonzero digit from r(10), requiring a borrow so that all remaining digits 
are subtracted from r — 1. Thus, for a three-place decimal machine the 
ten's complement of 030 is 970, and for a four-place binary machine, the 
two's complement of 0011 is 1101. 
Example 1-21. 
Signed 
numbers 
+ 5 
+ 6 
+ 1 1 
r's Complements 
Decimal 
Binary (n = 6) 
Octal {n = 3) 
Decimal (n = 3) 
000101 
000110 
001011 
+ 
005 
006 
013 
+ 
005 
006 
011 
+ 
- 5 
+ 6 
Throw 
away [ 1 ] 
111011 
000110 
Throw 
away 
[ 1 ] 
773 
006 
Throw 
away 
[ l j 
995 
006 
+ 1 
Throw 
away [ 1 ] 
000001 
Throw 
away 
[ 1 ] 
001 
Throw 
away 
[ l j 
001 
+ 5 
- 6 
000101 
111010 
005 
772 
005 
994 
- 1 
111111 
-000001 
777 
- 0 0 1 
999 
—001 
- 5 
- 6 
Throw 
away [ 1 ] 
111011 
111010 
Throw 
away 
[ 1 ] 
773 
772 
Throw 
away 
[ 1 ] 
995 
994 
- 1 1 
Throw 
away [ 1 ] 
110101 
-001011 
Throw 
away 
[ 1 ] 
765 
- 0 1 3 
Throw 
away 
[ 1 ] 
989 
- 0 1 1 

1-8. 
COMPLEMENT ARITHMETIC 
35 
The use of the modulus r
n — 1 and (r — l ) ' s complements results in 
simplification in the formation of complements. Since 
r
n — 1 = (r — 1), 
(r — 1), · · · , (r — 1) 
The (r — l ) ' s complement is formed by subtracting each digit of M from 
(r — 1). With this method of complementing, zero will have two machine 
representations, one the usual sequence of all zero digits (called positive 
zero), and the other a sequence of all (r — 1) digits (called negative zero). 
We can no longer ignore carry into the (n + l ) s t position, but we can 
treat it correctly by the following device: 
If 
M = cr
n + d n_ i r
n _1 · · · + dQ 
add zero as — c + c to give 
M = c(r
n - 1) + dn-ir""
1 + · · · + (dQ + c) Ξ d^r"-
1 
Η 
+ (dQ + c) 
( m o d r
n — 1) 
That is, we get a correct result modulus r
n — 1 if all carry from the nth 
position is added into the zero order position. This is referred to as the 
end-around 
carry and works as though the positions were arranged in a 
circle with the nth order next to the zero order. To illustrate this idea 
and to show that negative zero is equivalent to positive zero, we consider 
the following example. 
Example 1-22. 
Signed 
numbers 
(r — l ) ' s Complements 
Decimal 
Binary (n = 6) 
Octal (n = 3) 
Decimal (n = 3) 
+ 5 
000101 
005 
005 
+ 0 
000000 
000 
000 
+ 5 
000101 
005 
005 
+ 5 
000101 
005 
005 
- 0 
111111 
777 
999 
End 
End 
End 
+ 5 
around [ 1 ] 000100 
around [ 1 ] 004 
around [ 1 ] 004 
1 
1 
1 
000101 
005 
005 

36 
1. NUMBER SYSTEMS 
As with the r's complements, we can form each combination of signed 
numbers without subtracting. We illustrate the technique by doing again 
the problems of Example 1-21 using (r — l)'s complements. 
Example 1-23. 
Signed 
numbers 
(r — l)'s Complements 
Decimal 
Binary (n = 6) 
(Octal η = 3) 
Decimal (n = 3) 
+ 5 
000101 
005 
005 
+ 6 
000110 
006 
006 
+ 11 
001011 
013 
011 
+ 
+ 
+ 
- 5 
111010 
772 
994 
+ 6 
000110 
006 
006 
End 
End 
End 
+ 1 
around [ 1 ] 
000000 
around [ 1 ] 
000 
around [ 1 ] 
000 
1 
1 
1 
000001 
001 
001 
+ 
+ 
+ 
+ 5 
000101 
005 
005 
- 6 
111001 
771 
993 
- 1 
111110 
776 
998 
-000001 
- 0 0 1 
- 0 0 1 
- 5 
111010 
772 
994 
- 6 
111001 
771 
993 
End 
End 
End 
- 1 1 
around [ 1 ] 
110011 
around [ 1 ] 
763 
around [ 1 ] 
987 
1 
1 
1 
110100 
764 
988 
-001011 
- 0 1 3 
- 0 1 1 
The illustrations have made use of the basic operation of addition, and 
some computers are designed with this operation. Others are designed to 

EXERCISES 
37 
use only subtraction, with addition done by subtraction of complements. 
If we use (r — l ) ' s complements, use of subtraction will, of course, require 
end-around borrow. For an additive machine, Ν — Ν is given by Ν + 
(—Ν) 
and is formed on the machine as Ν + (r
n — 1) — Ν = r
n — 1, so that 
the negative form of zero is generated. With a subtractive machine Ν — Ν 
is formed as Ν - Ν or as -Ν 
+ N = -Ν 
- 
(-N) 
= [ ( r
n - 1) - JV] -
[ ( r
n — 1) — iV], and in either case, gives the positive form of zero. 
We note that in binary the (r — l ) ' s complement, called the one's 
complement, is formed by subtracting each digit from one. If a zero is 
subtracted from a one, a one results, whereas a one subtracted from a one 
yields zero. This gives a particularly simple rule for forming one's comple-
ments in binary: to complement a number we replace each one by a zero and 
each zero by a one. 
Example 1 -24. 
For an eight-place binary machine the one's complement of 
Section 1-0 
1. 
Extend the basic division algorithm of Theorem 1-0 to include the 
case a < 0, b > 0, and 0 < r < b. 
2. 
Use only the basic meaning of the positional system to write each 
of the following integers in decimal. The base is indicated by a 
subscript. 
3. 
(a) Suppose a positional system is introduced in which each position 
can have r,- > 2 digits 0, 1, 2, . . . , (r, — 1), positioned as follows: 
• · ·, r2y ri, r 0. If Äo = fo, Ri = r 0ri, and in general Rs = r 07 V · τ,· = 
r,ßy_i, show that every positive integer can be expressed in the form 
Ν = do + diRo + diRi + · · · + dnRn-i 
= eWn-i · · · do where the 
dj are legitimate digits, 0 < dj < rj. Hint: use the division process 
of Theorem 1-1 replacing r by r3- in order. 
(b) Show that if 77 = r, all j , this reduces to base r. 
4. 
Show that the rule for counting applies to the system of Problem 3. 
Use it to write the first 20 integers in the system indicated. 
00001101 
is 
11110010 = 11111111 - 
00001101 
Exercises 
(a) IOIOIII2 
(c) 5132 7 
(b) 37214 8 
(d) 102011 3 
1760 
8 
12 
(yards, feet, inches) 

38 
1. NUMBER SYSTEMS 
5. 
(a) If the scheme of Problem 3 is used with 
To = 
Γ2 = 
* * ' = 
T2k = * * * = 5 
and 
T\ = r 3 = 
· · · = r2k+i 
= 
· · · 
= 2 
we have the biquinary 
system (used in the abacus and some modern 
digital computers). Use the rule of counting to write the first 16 
integers in biquinary. 
(b) Write the general form of Ν = dndn-i 
· · · do of Problem 3 for 
the biquinary system and show that each successive pair of biquinary 
digits provides the corresponding decimal digit. 
6. 
Write the first 16 integers for each base 3 < r < 9. 
7. 
Prove that every even integer ends in zero when written in binary. 
Generalize your result. 
Section 1-1 
8· 
Convert each of the following decimal numbers to the base indicated, 
introducing your own notation for digits when necessary. 
(a) 144 to binary 
(b) 2345 to octal 
(c) 335 to duodecimal 
(d) 2345 to biquinary (Problem 5; 
(base 12) 
use two methods) 
9. 
Convert each of the numbers from the given base to decimal 
(a) ΙΟΙΟΠΟΙ2 
(b) 2374 8 
(c) 246i2 
(d) 1062 7 
Section 1-2 
10. 
Use the rules for multiplying polynomials to show how the ordinary 
long multiplication algorithm of decimal is achieved. 
11. 
Generalize the result of Problem 10 to base r > 2. 
12. 
Determine the maximum carry in one product for digit by digit 
multiplication, base r. 
13. 
Devise an addition algorithm for biquinary (Problem 5). 

EXERCISES 
39 
Section 1-3 
14. 
Perform the indicated operations in binary. 
(a) 
11011011 
(b) 
11011011 
+1010110 
-1010110 
(c) 11011011 
(d) 11011011 -v- 1101 
X110101 
(quotient and remainder) 
15. 
Convert each of the following decimal problems to binary, do the 
arithmetic in binary, and check by converting the answer back to 
decimal. 
(a) 23 + 12 = 35 
(b) 27 - 
13 = 14 
(c) 21 X 10 = 210 
(d) 37 -τ- 5 = quotient 7 
remainder 2 
16. 
Construct your own add, subtract, and multiply tables for bases 
r = 3 and 5. 
17. 
Use the results of Problem 16 to repeat Problem 15 for bases r = 3 
and 5. 
Section 1-4 
18. 
Do the indicated operations in octal. 
(a) 
2345 
(b) 
7251 
+7251 
- 2 3 4 5 
(c) 
7251 
(d) 1234 ^ 13 
X2345 
(quotient and remainder) 
19. 
Convert each of the decimal problems to octal and do the arithmetic 
in octal. Check by converting your answer to decimal, 
(a) 
347 
(b) 
216 
+296 
X47 
643 
10 152 
(c) 
475 
(d) 87 + 5 = quotient 17 
—238 
remainder 2 
237 

40 
1. NUMBER SYSTEMS 
20. 
Use the division scheme of Theorem 1-1 and make the following 
conversions, doing all arithmetic in the given base. 
(a) 101011102 to decimal 
(b) 101011102 to octal 
(c) 2347 8 to decimal 
(d) 13246 to decimal 
(e) 13246 to trinary (base 3) 
Section 1-5 
2 1 . 
Show that every rational number expanded base r as in Theorem 
1-2 provides a repeating or periodic expansion. 
22. 
Show the converse of Problem 21, that every periodic expansion is 
rational. 
23. 
For each of the following periodic representations, find in the base 
given and in decimal the rational number represented. 
(a) 1001.101010... 2 
(b) 13.242424... 8 
(c) 110.0010101... 2 
(d) 
12.012012012...a 
24. 
Show that every sequence of legitimate digits d_i, cL2, d_ 3, · · · , 
base r, converges to a number no greater than one. Hence, show 
from Problem 22 that a nonperiodic sequence represents an irrational 
number. 
25. 
(a) Determine the number of significant digits base r* required 
to give a round-off error no greater than the original if s digits are 
retained base r. 
(b) Apply this to find the relation between the number of sig-
nificant binary and decimal digits. 
Section 1-6 
26. 
Find the expansion for each of the following decimal numbers in 
the base given, using decimal arithmetic and the algorithm of 
Theorem 1-2. 
(a) 25/3 to binary 
(b) 25/3 to octal 
(c) 355/113 to binary (this is an approximation to π, accurate 
to .0001%) 
27. 
Repeat Problem 26, doing it by division in the given base. 
28. 
Make the following conversions (from decimal) to the given base. 
Retain the same order of accuracy. 
(a) 23.24 
to binary 
(b) 317.912 
to octal 
(c) (17.3) X 2
2 9 
to binary 
(d) (17.3) X 2
2 9 
to octal 

EXERCISES 
41 
29. 
Make the following conversions to decimal using only basic definition 
of the positional system and doing arithmetic in decimal. 
(a) 11011.101* 
(b) 2731.25 8 
30. 
Repeat Problem 29, doing all arithmetic in the given base. 
31. 
Compute 1/3 in binary and compare it to the binary representations 
of the decimal approximations .3, .33, and .333. Relate the results to 
Problem 25. 
Section 1-7 
32. 
Make the following conversions from binary to octal by inspection. 
(a) 1011101111010110 
(b) 
111101110100011010001 
33. 
Make the following conversions from octal to binary by inspection. 
(a) 23145 
(b) 1237654 
34. 
Show that the scheme for octal to binary and binary to octal also 
holds for digits to the right of the base point. 
35. 
Use the results of Problem 34 to convert the following binary numbers 
to octal. 
(a) 1011.011101111 
(b) 1011001.0101111 
36. 
Convert the following octal numbers to binary. 
(a) 342.756 
(b) 213.3214 
Section 1-8 
37. 
Show that addition, modulo m, is consistent, that is, if 
Ni = N2 
(mod m) 
and 
Μχ = M2 
(mod m) 
then 
(Ni + Mi) 
= (N2 + M2) 
(mod m) 
38. 
Repeat Problem 37 for multiplication. 
39. 
Assume a 3-place decimal machine and use 10's complements to 
obtain the results. 
(a) 8 - 5 = 3 
(b) 5 - 8 = 
- 3 
(c) 8 X ( - 5 ) = - 4 0 
(d) ( - 8 ) X ( - 5 ) = 40 
40. 
Repeat Problem 39 for a 3-place octal machine with 8's complements. 

42 
1. NUMBER SYSTEMS 
4 1 . 
Repeat Problem 39 for a 7-place binary machine using 2's comple-
ments. 
42. 
Repeat Problem 39 for a 3-place decimal machine using 9's comple-
ments. 
43. 
Repeat Problem 39 for a 3-place octal machine using 7's comple-
ments. 
44. 
Repeat Problem 39 for a 7-place binary machine using l's comple-
ments. 
45. 
On a three-place decimal machine, we wish to compute —15/3 = — 5. 
Explain why we cannot use 9's complements as 984/003. 
46· 
Show that the binary to octal conversion is applicable to comple-
menting if we use Ts and 7's complements. 

CHAPTER 2 
Machine Organization 
2-0. Introduction 
In the last chapter we saw that numbers can be represented by sequences 
of digits, and that, for computational purposes, we truncate these se-
quences to a finite number of places. Digital computing machines perform 
their functions by operating upon such finite, linearly ordered arrays of 
digits. In internally programmed computers, these arrays serve a twofold 
purpose. They may represent the numerical operands and parameters in-
volved in a problem, and they may also function as instructions to the 
computer itself. Regardless of the specific use which is intended, in what 
follows such arrays will be called words. Words are stored within the 
machine in physical devices called registers. The specific array of digits 
stored in a register will be referred to as the content of that register. In ac-
cordance with the computer functions with which it is associated, each 
register can be assigned to one or more of four groups: 
1. Storage registers 
2. Arithmetic registers 
3. Control registers 
4. Input-Output registers 
In this chapter we will describe the way in which computing machines 
are organized to perform their functions. We will base this description on 
a study of the properties of the four groups of registers, the relationships 
which exist between them, and the various interpretations which are as-
signed to the content of the registers. While individual computers will vary 
considerably in the particular methods by which they achieve results, 
certain basic requirements are always the same. It is in terms of these 
requirements that we will discuss machine organization. 
43 

44 
2. MACHINE ORGANIZATION 
For specific illustrations, we use here, as we do throughout the book, 
the properties of the CDC 1604. It is pedagogically convenient to start 
with a particular machine, and once we have mastered it, the others will 
be much easier. 
2-1. Storage Registers 
The number of digits which constitute the content of a register defines 
the length of that register. Registers will have lengths appropriate to the 
functions which they perform. In the majority of computing machines, 
the storage registers are of fixed length. Regardless of the length of the 
register, the content of a register must always be complete. That is, there 
can be no empty digital locations. 
All of the storage registers (or "memory") of any computing machine, 
will have the following three basic properties: 
1. The reading property 
2. The writing property 
3. The address property 
These properties, whatever the physical method of achieving them, are 
the following: 
1. Reading 
is the operation of consulting a register and obtaining a 
copy of its content. The reading property enables this copy to be made as 
often as necessary without alteration of content. 
2. Writing is the operation of replacing the content of a register with a 
new content. The writing property enables destruction of the original 
content in such a way that it does not interfere with the new content 
during a writing operation. 
3. The address is the means by which a particular register is identified 
and selected from the totality of storage registers for the operation of 
reading or of writing. It is a nonnegative integer, which serves the same 
purpose as a street address or room number. Each storage register is as-
signed an address which distinguishes it from all other registers, and which 
may be used by the programmer to specify this register directly to the 
control for reading or writing. Many registers which are not in the memory 
have the reading and writing properties, but do not have the address 
property, and, hence, are only indirectly available to the coder. In the 
final analysis, it is the property of addressability which distinguishes the 
group of storage registers. 
In enumerating the reading, writing, and address properties of storage 
registers, we have stated essentially all of their basic characteristics. While 

2-1. 
STORAGE REGISTERS 
45 
some storage registers may have special properties, these will rarely be 
built into all storage registers because of the prohibitive cost. Therefore, 
the fundamental facts which a coder need know about a computer's storage 
system is the fixed number of registers it contains; the fixed length of each 
register (ignoring the variable length case) ; and the fact that each register 
holds information (called its content) that can be copied (read), or changed 
(written), by specification of its address to the control. Of course, the coder 
need also know the correspondence between registers and addresses. 
While we may write a correct code with no more knowledge of storage 
than that just mentioned, we can often prepare a more effective and 
efficient code if we are familiar with the physical makeup and the related 
properties of the system of storage registers, in particular, how the reading 
and writing operations are carried out. The examination of the method 
by which reading or writing is carried out in storage registers necessitates 
the introduction of a set of registers associated with the memory, but 
which are not themselves storage registers. We have seen that the address 
is the means by which we specify the particular register for a reading or 
writing operation, and, accordingly, a register is provided to store this 
address. Such a register is often called a storage address register. A place to 
hold the digits which are to be written into, or to be read from, a storage 
register must also be provided, unless each register can be connected to 
all others. This would be a situation similar to a telephone system with a 
direct wire connecting every pair of phones. A more economical approach 
is to supply a separate register, equal in length to each storage register, 
which can be connected to any of them. Such a register is called an exchange 
register because it provides a means for exchanging data between registers 
which have no direct connections to each other. 
A reading or a writing operation can be described in the following 
manner: 
1. The address of the register in which the operation is to occur is 
placed in a storage address register. 
2. The register whose address now appears in the storage address 
register is connected to the exchange register. 
3. If the operation is reading, the initial content of the exchange register 
is replaced by a copy of the content of the storage register connected to it. 
4. If the operation is writing, the initial content of the storage register 
connected to the exchange register is replaced by a copy of the content of 
the exchange register. 
Frequently, the manner in which step three is physically implemented will 
result in the destruction of the original content of the storage register as 
it is being copied into the exchange register. This would be contrary to the 

46 
2. MACHINE ORGANIZATION 
definition of the reading property of storage registers. To guard against 
this contradiction and restore the initial content of the register, we can 
always follow step three by step four. In particular, knowledge relating 
to the timing of steps one through four can be very useful to a coder inter-
ested in program efficiency. For example, the length of time which elapses 
between the specification of a given address and the completion of the 
read or write operation may itself be a periodic function of time, and this 
function may be different for each address. A storage system with this 
property is called a variable access system. An example is given by a system 
in which each register consists of a number of magnitized spots on the 
surface of a revolving cylindrical drum, and reading and writing is accom-
plished by means of a fixed head. The time of access in this case varies 
with the central angle subtended by the head and the addressed area. Ob-
viously, the coder may achieve a decrease in running time if he takes the 
care to place his data so that each register to be consulted is available with 
a minimum delay at the time of consultation. This approach is called 
minimum 
access coding. It is clear that minimum access coding is not 
relevant for a storage system in which each register is available for reading 
or writing with a constant delay after specification of the address, and in 
which this constant delay is independent of the address. Such a storage 
system is called a random access system. 
Another example where the physical makeup of the storage system 
affects the coder's approach to the use of storage, arises when one group 
of storage registers has an access time considerably greater than that of 
another group. This situation often occurs in the form of a random, very 
high speed access, storage system containing relatively few registers, 
backed up by a considerably slower system, such as a magnetic drum, 
containing a relatively large number of registers. 
2-1.0. Storage Registers in the CDC 1604 
In the CDC 1604, all storage registers are 48 bits in length. There are 
usually 32,768 such registers. These 32,768 storage registers are identified 
by the address integers zero through thirty-two thousand, seven hundred 
and sixty-seven. This is the totality of nonnegative integers which can be 
represented by 15 bits. Thus, in the CDC 1604, all addresses are 15-bit 
integers, and every 15-bit integer can be correctly interpreted as the 
address of a unique storage register. Such a one-to-one correspondence 
does not hold in all computers. In some there will be digital combinations 
of proper length which are not addresses, and whose use as addresses may 
lead to faults. 

2-1. 
s t o r a g e 
r e g i s t e r s 
47 
It is convenient to employ the straightforward mode of translation 
between the binary and octal number systems to represent the 15-bit 
address as a five octal digit integer. Thus, we will treat addresses hence-
forth as if they were actually five octal digit integers, and arithmetic with 
addresses will be carried out in octal. This, however, is merely a notational 
convenience, allowed us by the fact that the translation of the address to 
octal and back to binary is easy. Internally, the addresses remain 15-bit 
integers, in spite of the fact that we represent them externally by the octal 
integers 00000 through 77777. 
In the CDC 1604 the storage registers are made up physically of mag-
netic cores, a single bit being stored in one core. The cores are arranged in 
square arrays, or matrices, each having 128 rows and 128 columns. Each 
such array, consisting of 16,384 cores, is called a memory plane. A group of 
48 memory planes is called a memory plane assembly. A register consists 
of 48 cores in correspondingly located positions, that is, in the same row 
and column, in 48 different memory planes. Thus, a memory plane as-
sembly contains 16,384 registers. The total system of 32,768 registers is 
made up of two memory plane assemblies. In the range 00000 through 
77777, the 16,384 even octal integers refer to registers in one assembly, 
while the 16,384 odd octal integers refer to the other. Hence, of the fifteen 
bits that make up an address, one, the lowest order, selects the even or 
odd memory plane assembly. The remaining fourteen bits define the row 
and column intersection of each memory plane, at which the individual 
cores making up the register are to be found. Since there are 128 rows and 
128 columns, fourteen digits, taken in two groups of seven, are just suffi-
cient for this. 
The CDC 1604 has one storage address register for each memory as-
sembly. The storage address register, S
1, is associated with the even address 
memory assembly, and the storage address register, S
2, is associated with 
the odd one. Each of these registers is fourteen bits in length, and, although 
they themselves have no addresses, they are each of the appropriate length 
to store that portion of an address needed after its parity has been 
determined. 
The CDC 1604 exchange register, or X, is 48 bits in length and receives 
the word to be read from the register whose address is in S
l or S
2. In order 
to expedite the restoration process needed after a read operation, two Ζ 
registers are also present. A Ζ register holds the 48-bit word to be written 
into the register whose address is held in S
1 or S
2. The two Ζ registers, Z
1 
and Z
2, are, respectively, associated with the even and odd memory plane 
assemblies. Initially, the word to be read into memory is placed in X and 
then transmitted to the appropriate Ζ register. These registers and their 

48 
2. m a c h i n e 
o r g a n i z a t i o n 
organization are schematically illustrated in the figure below, where the 
solid arrows represent paths for the parallel transmission of 48 bits. 
S
l 
S
2 
16,384 
Storage registers 
(even addresses) 
Z
l 
16,384 
Storage registers 
(odd addresses) 
z * 
X 
Thus, to write in a register, the high order fourteen bits of its address 
are first placed in the appropriate S register, the new word to be inserted 
is placed in X, and the write operation is initiated. The storage register is 
then cleared, the word in X is transmitted to the appropriate Ζ register, 
and is sent from there to the storage register whose address is being held 
in S. The control accepts whichever word appears in X and whatever 
address is held in S at the time the write operation is initiated, and it is 
not concerned with the manner in which the content of these registers was 
established. 
To read the content of a register, the high order fourteen bits of its 
address are placed in the appropriate S register, the X register is cleared, 
and the read operation is initiated. A copy of the content of the register 
whose address was in S at the time the read operation was initiated will 
then appear in X. Whatever address happens to be in S when the read 
operation is initiated is accepted by control unconditionally. The agency 
which performs the operation is not concerned with the nature of any 
earlier operation which may have set the content of AS. We see from the 
figure that, as a copy of the memory register content is made in X, it is 
also made in the appropriate Ζ register. This permits the word copied 
from the storage register to be recopied into that register from Z, so that 
the reading operation does not change the content of the register read from. 

2-2. 
ARITHMETIC 
49 
We see that the reading operation includes also the operation of writing 
(to restore the register read to its original content). These two operations 
taken together are called a storage cycle. Each memory plane system has 
a storage cycle time of 6.4 microseconds (Msec). The read access time of 
this cycle is 2.2 ßsec, after which the information read can be operated 
upon without further delay. However, subsequent access to the same 
memory plane system is not permitted until the full cycle has been com-
pleted. Since each memory plane assembly has been furnished with its 
own S and Ζ registers, they can operate independently, and their storage 
cycles made to overlap in time. Thus, the cycle of one memory plane 
system will begin when the cycle of the other is half completed. By ar-
ranging a program so that even and odd addresses are referred to alter-
nately, we can cut the time delay before the memory plane assembly is 
available for a subsequent reference to 3.2 Msec. However, successive 
references to registers having both even, or both odd, addresses require a 
wait of the maximum cycle time of 6.4 μββο before the second reference 
can be initiated Since it is not always convenient to arrange to refer to 
alternate memory units, the effective cycle time will lie somewhere be-
tween 3.2 and 6.4 μsec. 
2-2. Arithmetic 
In the earlier discussion of storage registers, emphasis was necessarily 
placed on the address word, as it is the primary thing which distinguishes 
a storage register from a control or arithmetic or input-output register. All 
classes of registers, however, have content associated with them. Thus, 
addressable registers always have two sequences of digits associated with 
them. One of these sequences represents the address of the register and the 
other its content. It is of prime importance to avoid confusion between 
these sequences, and so we introduce a notation to distinguish the two. 
Let a represent the address of any addressable register. Then the symbol 
(a), that is a in parentheses, will represent the content of the register with 
address a. We note that the symbol (a) will usually represent a longer 
sequence than does a. The parenthesis notation will also be used and will 
prove convenient in referring to the content of registers which do not have 
addresses. For such registers the name, or some other symbol representing 
the register, if placed in parentheses, will refer to its content. For example, 
the fourteen bits in register S will be referred to by the notation ( £ ) . 
When we are first introduced to the concept of a register, we are likely 
to think of it as a device capable of containing a number to be used as an 
arithmetic operand. In the case of the storage register, however, the con-
tent can be given a variety of interpretations. The two primary interpréta-

50 
2. 
MACHINE ORGANIZATION 
tions are first that the content represents an operand for the operations of 
the computer, and second, that the content represents a coded instruction 
to the control section of the computer. Study of the first interpretation 
will lead naturally to an examination of the arithmetic section of the com-
puter and its registers, while study of the second interpretation will lead 
to an examination of the control section and its registers. We turn to the 
first interpretation now, deferring the investigation of the second to later 
sections of this chapter. 
2-2.0. The Content of α Storage Register as an Arithmetic Operand 
The word in a storage register, when interpreted as an arithmetic operand, 
is usually considered to be either a fraction or an integer, in which case 
the base point is thought of &s fixed; or it is thought of as a combination of 
the two. In the latter case, part of the digits of the word in storage are 
taken to represent a fraction. The remaining digits represent an integer 
which relocates the base point by specifying the power of the base by which 
the fraction is to be multiplied. This last interpretation is ordinarily re-
ferred to as a floating point representation of an arithmetic operand. In 
addition to the interpretation of a sequence of digits as an integer or frac-
tion, there is also the question of whether it is to be thought of as giving 
an absolute value and sign or a complement form. 
When used as an operand for nonarithmetic processes, the storage word 
can have a great variety of interpretations. For instance, an individual bit 
in a word may signify the presence or absence of a certain chromosome, 
or perhaps the presence or absence of a hole in a specific row and column 
of a card. Such interpretations as these are better left for the later discus-
sion of nonarithmetic operations and specific examples of their use in 
Chapter 5. 
If the content of a storage register is to be interpreted as an arithmetic 
operand, it represents a number; and the numbers which can be represented 
will always be restricted to some finite range. The restrictions are dictated 
by the format chosen, by the use of absolute value and sign or complements, 
and, of primary importance, by the fact that only a finite number of digital 
positions are available. It is this last restriction which we must always ob-
serve with meticulous care. Regardless of the format chosen, every number 
entering into, or arising from, a computation, must be representable in 
terms of no more than the number of digit locations allotted to it. If more 
than this number of digits is required, overflow occurs and we have incorrect 
results. The precise mathematical restrictions imposed by the length of a 
register will depend in turn on the format. We shall consider here only the 
basic restrictions imposed. In Chapter 4 we shall treat in detail the way 
in which a coder observes these restrictions. 

2-2. 
ARITHMETIC 
51 
Suppose we have a register of length a + 1 digital positions, base r. The 
restrictions imposed on a number N, considered as a fixed point operand, 
are then the following. 
1. The operand is interpreted as an absolute value integer with sepa-
rately stored sign: Ν must satisfy 
\N\ 
< r «
+ 1 - 1. 
2. The operand is interpreted as an absolute value fraction with sepa-
rately stored sign and base point considered to be to the left of the digits: 
Ν must satisfy 
r-(a+i) < I iV I < 1 — r
_ ( a + 1
) 
or be zero. 
3. The operand is interpreted as a complement integer, with the high 
order digit allocated as the sign digit : Ν must satisfy 
I Ν I < r« - 1. 
4. The operand is interpreted as a complement fraction, with the high 
order digit allocated as the sign digit, and base point immediately to the 
right of the sign digit : Ν must satisfy 
r~
a < I Ν I < 1 - 
r~
a 
or be zero. 
In the case of floating point interpretations, each operand is considered 
to be the product of a fraction with its first significant digit right of the 
base point, and an integral power of r, that is Nr
s. 
This number is stored 
as an ordered pair, consisting of the fraction Ν and the exponent S, that 
is, (N, S). The pair may be stored in a single register (packed) or in more 
than one register (unpacked). 
In either case, if C digits are allocated to 
storage of the coefficient Ν and Ε digits are allocated to storage of the 
exponent S, we have the following restrictions. 
1. The operand is interpreted as a floating point absolute value fraction 
with separately stored sign and S an absolute value integer with separate 
sign: Ν and S must satisfy 
r~
c < I Ν I < 1 - 
r~
c 
or be zero and 
I S I < r
E - 1. 
2. The operand is interpreted as a floating point complement fraction 
with sign digit just left of base point and S as a fixed point complement 
integer: Ν and S must satisfy 
r- ( c - i ) < 
I N \ 
< 
χ _ 
r- ( C - l ) 
or be zero, and 
I s J < 
rE-i _ ι 

52 
2. MACHINE ORGANIZATION 
The particular form of these restrictions will be clarified in our discus-
sion of CDC 1604 operands, since all three interpretations are possible on 
this computer. 
2-2.1. Arithmetic Operands in the CDC 1604 
In our discussion of CDC 1604 operations, we will take the integer 
interpretation of an operand as the primary one. In this case, the content 
of a storage register is always assumed 
to represent a binary integer less 
than 2
4 7 in absolute value. In conformance with this integer interpretation, 
the individual bits in a register will be ordered, with subscripts starting 
with zero for the lowest order bit and advancing by one for each higher 
order bit until the highest order bit with subscript 47 is reached. Thus, 
written from highest order to lowest order in conventional form, the 
digits in a storage register will appear as 
We see that each subscript represents the power of the base two with 
which the particular digit is associated. This subscript notation, as used 
in Chapter 1, will prove to be convenient even when interpretations other 
than as an integer are to be assigned to the word in a register, and it will 
be used in the remainder of the book. When they are indicated by a particu-
lar situation, symbols other than 6» will be employed for individual digits 
in a register. 
In the discussion of CDC 1604 address words, which were also considered 
to be binary integers, the convenience of octal notation was pointed out. 
The same simplification can be used for the content of a storage register, 
since this content can readily be translated into a sixteen octal digit integer. 
Thus 
&47&46&4B&44&43&42
 β * * 66&4&3&2&1&0 
becomes 
Φίδ 
Ψΐ4 
' * * Φΐ Φθ 
Henceforth, we will ordinarily employ the octal notation to represent the 
word in a register. As with the subscript notation, this octal notation will 
also be used when other than arithmetic interpretations are to be assigned 
to the content of a register. It must be emphasized again that we use the 
octal notation only externally as a convenience to ourselves. Internally, the 
content will always be a 48-bit sequence. 
If the integer Ν is nonnegative, the digits in the storage register will 
represent its absolute value in the conventional manner, that is, 
If = I Ν I = δ 47·2
4 7 + ΐ>4β·2
46 + · · · + 6 0·2° 

2-2. 
ARITHMETIC 
53 
with 647 always zero. However, if the integer Ν is negative, the digits in 
the register will represent 2
4 8 — 1 — | Ν | which is clearly nonnegative, 
since | Ν \ < 2
4 7. Thus, in this case, 
2
4 8 - 1 - I Ν I = Ö47-2
47 + 6 4 β·2
4 6 + · · · + 6 0·2° 
with 647 always one, so that the integer Ν is represented in one
1 s complement 
form; and the sequence of digits is said to give the one's complement 
of 
I Ν I . Since | Ν \ < 2
4 7, we can always tell from observing 647 whether a 
word represents | Ν | or 2
4 8 — 1 — | Ν | . If 647 = 0, the sequence repre-
sents Ν = I Ν I and if 647 = 1, the sequence will represent the one's com-
plement of I Ν I = — N. In the latter case, we know from the discussion 
of Chapter 1 that 
\N\ 
= £)5<2' 
where 
bi 
= 1 - 
bi 
A special note should be made of the form of the integer zero. In a one's 
complement system for representing negative integers, zero has two forms, 
either a sequence of 48 zeros which is called a true, or positive, zero, or a 
sequence of 48 ones which is called a negative zero. We have shown that if 
the basic arithmetic operation of a machine is addition, the latter form of 
zero will always arise; but if the basic arithmetic is subtraction, only true 
zeros will arise. Unfortunately, the arithmetic operations of the CDC 1604 
are carried out in such a way as to make it possible to introduce both 
negative and positive zeros. Although true zeros will ordinarily predomi-
nate, to protect his code against machine idiosyncrasies, the coder must be 
aware of ways in which negative zeros can arise. 
Since we will usually deal with the content of a register in octal form, we 
will rephrase some of the preceding results for octal notation. The octal 
digits will be assigned subscripts in accordance with the integer interpreta-
tion of an operand and in accordance with the power of eight with which 
a particular digit is associated. Thus, the digits in a 48-bit register appear 
as ΨΙΒΦΗ· · ·ΦιΦο, where φ. is any octal digit. If Φ15 is equal to 0, 1, 2, or 3, 
the integer represented is nonnegative and has absolute value equal to 
Σ"ο 
Φ<8*. If Φ16 is equal to 4, 5, 6, or 7, the integer represented is negative 
and has absolute value equal to Σΐ-ο 
Φ.8* where φ ϊ = 7 — φ,: The initial 
integral content of any register can be replaced by a word representing 
its negative (regardless of sign of the original) simply by replacing each 
octal digit by its difference from seven, that is, by forming its seven's 
complement. 

54 
2. MACHINE ORGANIZATION 
The largest possible integer which we can store in a storage register is 
2
4 7 — 1. This will appear in the register as 
Oil 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 
Externally it will be represented in the octal form 3777 7777 7777 7777. 
The smallest integer which we can store in a storage register is — (2
4 7 — 1). 
This we accomplish by actually storing the nonnegative integer 2
4 8 — 1 — 
(2
4 7 — 1) = 2
4 8 — 2
4 7 = 2
4 7, which will appear in the storage register as 
100 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 
and be represented externally, in octal, as 4000 0000 0000 0000. Since 
each of these integers is the negative of the other, one can be obtained from 
the other by one's complementation of the binary form or seven's comple-
mentation of the octal form. It is easily verifiable that this is the case. 
We determine the fractional interpretation of the content of a CDC 1604 
storage register by a modification of the integral interpretation. In the 
fractional case, the binary point is imagined to lie between bi7 and b^. Thus, 
we can obtain the fractional interpretation by merely applying the factor 
2~
4 7 to the content taken as an integer. The sequence 3777 7777 7777 7777 
which represents the largest admissible integer 2
4 7 — 1 will then represent 
the largest admissible fraction, 1 — 2~
4 7, under the fractional interpreta-
tion, and the sequence 4000 0000 0000 0000, which represents 1 - 2
4 7 in 
the integral interpretation, becomes 2
- 4 7 — 1. 
The smallest positive number representable as an integer is one. As an 
integer, one is contiguous to zero. In the fractional interpretation, however, 
the smallest positive number is 2~
4 7. Hence, admissible fractional values 
consist of the interval 2
- 4 7 < | Ν \ < 1 — 2
- 4 7 and the number zero. 
In the integral interpretation of the content of a CDC 1604 register we 
assume the binary point to be fixed at the right of the register, and all of 
the bits in the register are used to represent the magnitude of the integer 
or its complement. In the fractional interpretation, we multiply the integer 
by 2
- 4 7 so that the binary point is imagined to be fixed between 647 and 
b46. In the floating point interpretation of the content of a register the posi-
tion of the binary point is thought of as varying from word to word, and a 
subset of the bits in the register is utilized to specify the position. The re-
maining bits specify the digits of the number. Accordingly, a register is 
assumed to contain a number of the form 
N-2
S, 
I < I Ν I < 1 
(unless 
Ν = 0) 
The eleven bits 646ί>45· · ·&3β give the exponent 
S. The remaining bits 647 
and 635· · -b0 give the coefficient, N, of the floating point word, with the 
point imagined to lie just to the left of 635. We call Ν the normalized co-

2-2. 
ARITHMETIC 
55 
efficient to indicate that the bit 635 of Ν will always be significant. This 
follows from the condition \ < | Ν \ < 1. Since Ν is represented in one's 
complement form on 37 bits, &47 determines the sign of Ν in the usual way. 
Thus, the content of a register when interpreted as a floating point operand 
has the following format: 
&47 
&46 
&36 
^35 
&0 
Sign 
of Ν 
Exponent S 
Normalized part of Ν 
Since 635 is always the first significant bit of iV, it must be different from 
the sign bit, so that 647 ^ 
£»35. 
The exponent S is an integer represented by eleven bits in one's comple-
ment form, and if the leading bit of S is to determine its sign in the usual 
way, we must have | S \ < 2
1 0 = 1024. In practice, it proves convenient 
to replace S by a related number called the biased form of S. We shall 
consider this and other aspects of floating point format, including conver-
sions between fixed and floating point representation in Chapter 4. Here 
We note that the allocation of 37 bits for Ν in normalized, fractional form 
will require for Ν ^ 0 that 
ΛΜ < 1 - 2 -
3 6 
This condition, together with the restriction on S, will confine 
floating 
point numbers to the value of zero, or to the range 
2-1024 < 
I tf.2S I < 
21023 _ 
2987 
2-2.2. The Arithmetic Registers 
A discussion of the content of a storage register as an operand for the 
arithmetic processes of the computer leads naturally to an investigation of 
these processes. The arithmetic section of a computer must be provided 
with a means for the storage of the operands, such as addend and augend; 
the intermediate results, such as the partial remainders and products; 
and, finally, the results of the operation. It must also be capable of oper-
ating on these stored quantities. Since it is too expensive to provide each 
memory register with the special operational properties which arithmetic 
requires, a separate set of arithmetic registers is required. Typical attributes 
of the arithmetic registers are the ability to shift digits within the register, 
to complement digits, and to test sign. Most important of all is the ability 
to accumulate, that is, to form the sum (or difference) of the operand 

56 
2. MACHINE ORGANIZATION 
already in the register and a second operand transmitted to the register. 
For this reason, in many computers the basic register of the arithmetic 
section will be an accumulator whose primary purpose is the formation of 
sums and differences. In some computers, a simplification of design is 
achieved by having the accumulator perform only one operation; either 
addition or subtraction, and using complements to obtain the other. Such 
machines are called additive or subtractive, depending on the base operation 
chosen. 
To augment the accumulator and permit it to perform compound addi-
tions and subtractions such as are required for multiplication and division, 
there will usually be some auxiliary arithmetic registers. These will usually 
be multipurpose registers, even though they are assigned names which 
are associated with one particular function, such as quotient register. 
Since we wish to retain the freedom of choosing operands from, and 
preserving results in, arbitrary storage registers, we must provide for the 
transfer of data from any storage register into the arithmetic registers and 
for the reverse transfer from arithmetic registers to any storage register. 
Thus, the digits manipulated within and between arithmetic registers in 
order to create results, will either have been copied into these registers 
from addressed storage registers or will have been left there from the pre-
vious operation. Usually this transmission of information between arith-
metic registers and storage registers will be handled by the same exchange 
register used for the storage to storage transmission. The exchange register 
may also function as an auxiliary arithmetic register. The actual switching 
networks which permit the accumulator to carry out its specific functions 
are a proper topic for a book on computer design. However, it is important 
to a programmer that he be familiar with the way in which each operation 
is carried out, and, in particular, with the sequencing. We illustrate this 
point by an example. 
Example 2-0. In the UNIVAC 1103 an appropriate instruction will 
cause the computer to form the sum of two numbers obtained from storage. 
Since the accumulator is addressable in this machine, one of the two num-
bers may be the one currently stored in the accumulator. The steps are: 
(1) The first number goes to the exchange register. 
(2) The accumulator is cleared. 
(3) The content of the exchange register (first number) is added to the 
cleared accumulator. 
(4) The second number goes to the exchange register. 
(5) The number in the exchange register (second number) is added to 
the content of the accumulator. 

2-2. 
ARITHMETIC 
57 
We see that if the content of the accumulator is specified as the first num-
ber, a correct sum of the content of the accumulator and the second num-
ber is formed. On the other hand, if the content of the accumulator is 
specified as the second number, the clearing operation in (2) will destroy 
this number and the result will be to form twice the first number. 
The important thing for the programmer to know is the overall method 
which his computer uses to carry out operations. He must become familiar 
with its idiosyncrasies and plan his program accordingly. Our investigation 
of such idiosyncrasies will be limited in objective, confining itself mainly 
to a brief description of the organization and physical properties of the 
CDC 1604 arithmetic in the next section. Further discussion of arithmetic 
processes will be postponed to the sections of this book dealing with the 
various CDC 1604 computer instructions. 
2-2.3. Arithmetic Registers in the C D C 1604 
We now turn to the CDC 1604 arithmetic registers and their properties. 
The two principal registers of the arithmetic section are the 
accumulator 
or A, and a register called Q. The exchange register or X, which was intro-
duced in Section 2-1.0, also serves as an auxiliary arithmetic register. 
Registers A, Q, and X are each 48 bits long. A simplified version of their 
relations is given in the diagram below. One of the transmissions from X 
X 
A 
Q 
to A is more than a mere copying operation, since, as the designation of 
accumulator implies, the difference of the operands in A and X before the 
transmission is placed in A, In view of the relationship of X to the storage 
system, we see that transmissions via X from any storage register to A 
and Q and vice versa are possible. However, A and Q, having no addresses, 
cannot be directly specified to the control for reading or writing operations 
as storage registers can. Reading and writing in A and Q are accomplished 
by the provision of special instructions. These instructions will be dis-
cussed in later chapters. 
The accumulator is utilized in almost all of the arithmetic instructions 
of the computer. It stores the sum or difference in addition and subtrac-
tion, the quotient after division, and in conjunction with Q, the product 

58 
2. MACHINE ORGANIZATION 
after multiplication. Before division, it stores, in conjunction with Q, the 
dividend. Before addition and subtraction, it stores the augend and minu-
end, respectively. Register Q, besides holding product and dividend in 
conjunction with the accumulator, holds the multiplier during multiplica-
cation and the remainder after division. 
Both A and Q are also shifting registers. This means that both the ac-
cumulator and Q can shift their content to the right or to the left. These 
two registers can perform their shifts individually or in conjunction, as 
one double length register. This will be clarified in Chapter 4 when the 
shifting instructions are introduced and discussed in detail. 
The remaining arithmetic register is X. As an arithmetic register, X 
stores the divisor, multiplicand, addend, and subtrahend in the respective 
operations of division, multiplication, addition, and subtraction. 
2-3. Control Registers 
The interpretation of the content of a storage register as an integer or 
fraction, as a floating point number, or as a coded parameter, was con-
sidered in the earlier sections of this chapter. We discussed then the fact 
that the digits of such operands are copied from storage registers into 
arithmetic registers, where certain manipulations or algorithms are carried 
out on these digits in order to transform them into the result of an opera-
tion. We must still examine the agency which selects operands and trans-
ports them between storage and arithmetic registers, and which carries 
out the desired algorithm. This agency, the control unit, will be the topic 
of the present sections. 
Since we are concerned with internally programmed computers which 
are guided by internally stored words, the examination of the control will 
stem from the interpretation of the content of a register as a computer 
instruction. Our picture will again be one of copying digits from the storage 
registers into appropriate registers provided in the control unit. The control 
registers will have special properties which are utilized to operate on a 
sequence of instruction digits in order to initiate events which produce the 
end result of the instruction. Consequently, our first investigation will be 
of the structure of a sequence of digits which can be interpreted by the 
control as an instruction, a sequence which we will call an instruction 
word. 
-3.0. Instruction Words 
If a sequence of digits is to be interpreted as an instruction, it must con-
tain, minimally, a means of specifying the particular operation to be per-
formed; and, if operands are involved, they must also be specified. Thus, 

2-3. 
CONTROL REGISTERS 
59 
typically, an instruction word will specify an operation or operations to 
be performed and one or more addresses of storage registers. The address 
parts are used to define the locations in storage of operands for the specified 
operation and/or the storage location at which the result is to be deposited. 
In later sections we will see the need for a variety of operations beyond the 
simple ones of arithmetic, and we note that the address parts of instruction 
words for certain operations do not actually specify computer addresses. 
They might, for example, specify a shift count, or they may not be used at 
all. Whatever the interpretation, however, we will often refer to these 
portions of the instruction word as "addresses." If it is fixed, the number 
of address parts adjoined to the operation part of an instruction word pro-
vides a convenient way to classify the control of a computing machine, 
and we often hear of one, or single, address computers, two, or double, 
address computers, and so on. 
Since all pertinent information must be contained in the sequence of 
digits considered as an instruction word, some of the digits will be allocated 
to specify the operation. The particular combination of digits which desig-
nates a specific operation is referred to as an operation code. The remaining 
digits in the sequence are allocated to the one or more addresses which 
may be used. We consider some examples of possible word structures which 
might correspond to different machines. 
Let us say, for example, that the operation to be specified is "add." We 
may assign various interpretations to the instruction word containing this 
operation, depending primarily on the number of addresses to be given. 
Assume that only one address is to be employed. The instruction word 
then has the form 
add 
a 
where a represents the address of any storage register. The control might 
be constructed to interpret such an instruction to mean "form the sum of 
whatever number is presently stored in the register with address a, and 
whatever number is currently in the accumulator, leaving the result in 
the accumulator." If two addresses were employed, the instruction word 
would have the form 
add 
α 
β 
where a and β represent addresses of any storage registers. The control 
might be constructed to interpret this instruction as "form and store in 
the accumulator the sum of whatever number is presently stored at the 
register with address a and whatever number is presently stored at the 
register with address ß." An alternate interpretation might be "form and 
store at the register with address β the sum of whatever number is près-

60 
2. MACHINE ORGANIZATION 
ently in the accumulator and whatever number is presently stored at the 
register with address a." An instruction with three address parts would 
have the form 
add 
α 
β 
5 
and would also have a variety of possible interpretations associated with 
it, any of which the control could be designed to follow. A possible one is 
"form in the accumulator the sum of whatever number is presently stored 
in the register with address a and whatever number is presently stored in 
the register with address β and transmit the result to the register with 
address δ." 
Addition instructions with four or more address parts can also be 
constructed. 
The way in which the various parts of an instruction word are allocated 
digitally will depend on the machine. We give a few examples of possible 
combinations. 
Example 2-1. A single address computer has an instruction word con-
sisting of eight octal digits, the first three of which specify the operation 
and the last five of which specify the address; that is, we have, as an in-
struction of the type considered above, 
ΦΊΦ*ΦΙ 
ΦΑΦΖΦΫΦΙΦΟ 
add 
a 
In a specific case this might then become 140 
01012, which will then be 
interpreted by the control as "add the content of storage register with 
address 01012 to the current content of the accumulator." This is an 
actual instruction word for the CDC 1604, in which 140 is an operation 
code for add. 
Example 2-2. A double address machine has an instruction word con-
sisting of twelve octal digits. The first two digits specify the operation, the 
next five digits a first address, and the final five digits a second address; 
that is, we have as an instruction of the type considered above, 
011010 
ΨθΦβΦτΦβΦδ 
0403020100 
add 
α 
β 
In a specific case this might become 35 01012 01013, which is then 
interpreted by control as "add the content of the storage register with 
address 01012 to the current content of the accumulator and store the 
sum at address 01013." This is an actual instruction word for the UNI VAC 
1103, 1103A, or 1105, in which 35 is an operation code for add. 

2-3. 
CONTROL REGISTERS 
61 
and a possible interpretation for control is 
add the content of storage 
location 00011011 to the content of storage location 01101001 and place 
the sum in storage location 00110111, after which take the next instruction 
from storage location 11010101. " This is an actual instruction word for 
the computer SWAC, built by the National Bureau of Standards. In this 
machine the operation code for add is 0101. 
We see that each computer will have a "language" consisting of digital 
combinations or words which are intelligible to its control. It is the task 
of the beginning coder to master the particular machine language of the 
computer he uses. 
The fact that the sequence of digits in a storage register may represent 
either an instruction or an operand is of cardinal importance. It means 
that instructions can be employed as operands by other instructions. The 
purpose of this treatment will usually be to create new instructions from 
old ones. In this way the computer has the ability to modify or alter the 
program that was originally stored. This facility will be amplified at length 
in the later chapters of the book. 
In the more sophisticated computing machines a means is often provided 
for modification of an instruction within the control section itself, rather 
than within the arithmetic unit. This is accomplished by provision, within 
the control section, of registers with properties similar to those of the 
arithmetic section. The modification is carried out in these registers, which 
need not have the capacity of arithmetic registers, since the arithmetic 
on instructions is ordinarily only that of moderately small integers such 
as addresses. 
The control of instruction modification within the control unit itself is 
managed by a subset of digits in the instruction word, adjoined to the 
operation code and the address subsets. It may be referred to as the desig-
nator. In certain instructions the designator causes a modification of the 
operation code function. From this point of view, it may be thought of as 
extending the set of operation codes. In other instructions the purpose of 
the designator is to cause a modification of the address part. In these in-
structions it may be thought of as an extension of the address. 
00011011 
01101001 
00110111 
11010101 
0101 
In a specific case this might bec ome 
Example 2-3. A 36-bit computer has an instruction word in which the 
first 32 bits are allocated in sets &i eight as eight-bit addresses. The final 
four bits specify the operation. Thus, we have as a possible instruction, 

62
2. MACHINE ORGANIZATION
2-3.1. The CDC 1604 Instruction Word
The CDC 1604 instruction word is made up of 24 bits. When a 24-bit
word is to be considered as an instruction, the bits are divided into three
subgroups and assigned the following meanings:
b23 -
bI8 = operation code = F
bI7
-
bI6 = designator
= b or j
bI4
-
bo = (base) address = m, Y, k, or z
Since a storage register holds a 48-bit word, it can hold two computer
instructions. Two instructions stored in a single storage register are called
a program step. The high order" 24 bits in a storage register define one in-
struction of a program step, called the upper instruction, and th~ remaining
24 bits define the lower instruction. Thus, a computer instruction word,
which consists of one six-bit (2 octal digit) group representing an operation
code, one three-bit (one octal digit) group representing a designator, and
one 15-bit (5 octal digit) group representing a base address, is half of a
storage word. Because of this form of its instruction word, the CDC 1604
can be called a single address computer. However, when the entire program
step is taken into consideration, it is often convenient to think of the CDC
1604 as equivalent to a two-address computer. '-fhe octal structure of an
instruction is thus given by
Operation code
Designator
Address
while a program step has the octal form
Operation
code
Designator
Address
Operation
code
Designator
Address
cPI6cP14
cPI3
cP12cPUcPIOcP9cP8
cP7cP8
cP6
cP4cP3cP2cPlcPO
'fhe operation code symbol F, representing a two-octal digit integer, can
be assigned 64 different values. Of these 64 possible values, 62 are actually
utilized, with operation codes 00 and 77 remaining undefined. Thus, from

2-3. 
CONTROL REGISTERS 
63 
the point of view of operation code, there are 62 different instruction 
classes. Should F be assigned the values 00 or 77 by the coder, the control 
will reject the instruction, causing the computer to stop. 
The designator symbols b or j , either of which represent a single octal 
digit, may be utilized to designate up to eight different things. The class 
of objects, from among which the value assigned to b or j designates a 
specific object, may not always contain eight objects and may not always 
be the same class. The precise nature of this class will depend upon the 
specific value of the operation code, and will be defined carefully when the 
various available operations are discussed individually. However, for most 
operations, the designator values 0, 1, · · ·, 6 are used to designate one of 
seven 15-bit auxiliary control registers, called index registers. In accordance 
with the particular designator value with which it is associated, an index 
register will be referred to as index register 0, 1, 2, 3, 4, 5, or 6. In this 
context the designator is referred to as the index designator and assigned 
the symbol b. Used in this way, it becomes the address of the index register. 
The associated index register will be referred to by the symbol B
b, 6 = 0, 
1, · · · , 6. Index registers B
1 to ΰ
6 actually exist physically. However, 
index register B° is only imagined to exist and to contain only the value 
zero. Because B° is hypothetical, a value of b = 0 will require special con-
sideration in some instructions. 
For certain operations it is convenient to think of the designator as 
specifying an extension or variation of the operation specified by F, since 
its function will be to modify the operation. In these cases, the symbol j 
will be utilized for the designator; and, if we wish, we may think of Fj 
taken together as defining an extended operation code. 
The five octal digit base address can be assigned any of 32,768 values 
00000 to 77777, and thus can refer to any one of the storage registers. 
Although this fifteen-bit subgroup of an instruction word has been called 
a base address, there will be occasions (depending upon the value of the 
operation code F) in which it will not be an address but will function as a 
shift count, an operand, or a code word to external equipment. Although 
the general designation "address'' will be used in all situations, in order to 
distinguish between them, the different symbols m, y, k, ζ are used to stand 
for the value of the address in the following way: 
Base address 
symbol 
Address type 
ζ 
m 
y 
k 
Machine address 
15-Bit operand 
Shift count 
Code word to external device 

64 
2. MACHINE ORGANIZATION 
The base address specified in an instruction is not always the address 
utilized by the control in the execution of the instruction. In many cases, 
a different address related to the base address is utilized. This address will 
be called the effective or execution address and will be symbolized by the 
capital of the letter used for its base address. It turns out in all cases that 
ζ = Ζ. However, for addresses of type m, y, and k} in the majority of cases 
where it is appropriate to utilize b as the designator symbol, we define the 
associated effective address to be 
M = m + 
(B
b) 
Y = y+(B
b) 
(b = 0, 1, . . . , 6 ) 
Κ = k + 
(B
b) 
We recall that the symbol (B
b) stands for the content of index register B
b 
and that we assume (B°) = 0 at all times. It follows that whenever b = 0, 
the base address and the effective address are the same. We illustrate by 
an example. 
Example 2-4. Assume that 
= 00002 and (B
2) 
= 00010, in octal, 
and consider the three instructions (a) 14 
0 
10000, (b) 14 
1 
10000, 
and (c) 14 
2 
10000. Each of these is an instruction to add the content 
of the effective address to the content of the accumulator. With address 
modification, we will have, for the three cases, when control executes the 
instruction: 
(a) b = 0, 
so M = m = 10000 and (10000) is added to 
(A) 
(b) b = 1, 
so M = m + (Β
1) 
= 10002 and (10002) is added to 
(A) 
(c) b = 2, 
so M = m + (Β
2) 
= 10010 and (10010) is added to 
(A) 
In order to keep the accumulator available for functions associated with 
the operation F, the control is provided with an auxiliary control accumu-
lator U
2 which carries out the arithmetic of base address modification as 
defined above. The accumulator, U
2, is a fifteen-bit, subtractive accumu-
lator, which performs arithmetic modulo 2
1 5 — 1. This means that U
2 adds 
by subtraction of one's complements and propagates end-around borrows. 
This introduces certain minor idiosyncrasies which we will elaborate on in 
Chapter 4. It also permits the address modification to include decreases in 
m, as illustrated in the following example. 
Example 2-5. Assume (B
1) 
= 77775 and consider the instruction 14 
1 
10000. When control executes the instruction, the effective address is 
10000 + 77775 = 07776 (mod 2
1 5 — 1), because of the one's complement 

2-3. 
CONTROL REGISTERS 
65 
arithmetic; that is, the base address has been decreased by two and (07776) 
is added to 
(A). 
The control is also provided with a fifteen-bit register R which plays a 
role relative to U
2 and the index registers similar to that which X plays 
relative to A and the storage registers. The content of any index register 
can be transmitted to R and vice versa. The register R has provision for 
counting, complementing, and subtracting its content from U
2. In the 
counting process, R functions as an additive register, doing arithmetic 
modulo 2
1 5, that is, in terms of two's complements. This permits R to count 
from address 77777 to address 77777 + 1 s 00000 (mod 2
1 δ), so that 
address zero is not skipped as it would be in one's complement arithmetic. 
The relationships between the registers B
b, R and U
2 are illustrated in the 
figure below. From the figure it is not difficult to imagine how it is possible 
B
l 
B
4 
5
δ 
R 
U
2 
m, y, k 
for the control to form the effective address in U
2. The registers R and U* 
are utilized by the control for address modification and for other functions 
which call for small integer arithmetic. Such functions include computa-
tions on the exponent parts Ε of floating point operands and direct opera-
tions to change the content of index registers. 
For all instructions in which it is appropriate to label the designator 
with the symbol 6, the value 6 = 7 will also cause the base address to be 

66 
2. MACHINE ORGANIZATION 
replaced. However, in this case the effective address is not determined as 
some simple function of the base address. Instead, the base address is 
used to make a reference to a storage register. The low order eighteen bits 
&ΐ7· · ·&ο, in the register referred to by the base address are then taken as 
the designator and base address for the current instruction. If the new 
designator obtained in this manner is s e v e D , the process is repeated with 
the new base address. If the new designator is b = 0, · · ·, 6, the effective 
address is determined from the new base address as previously described. 
This process, in which an address specifies a register which contains as 
part of its content the actual address we want, is called indirect 
addressing. 
We illustrate by the example given below. 
Example 2-6. Assume 
(10000) 
= 
22 
2 
22222 
11 
1 
11111 
and 
(B
1) 
= 00005. The instruction 14 
7 
10000 will then be treated as 
follows. Since the low order eighteen bits of (10000) are given, in octal, by 
1 11111, the instruction will be executed as though it were 14 
1 
11111. 
With address modification, this gives M = 11111 + (Β
1) 
= 11116. Thus, 
when control executes the instruction, (11116) is added to 
(A). 
2-3.2. Obtaining the Next Instruction 
Since instructions and operands occupy the same set of storage registers, 
they are indistinguishable. It is possible for control to interpret an operand 
as if it were an instruction and try to execute it. Should the particular 
operand be capable of interpretation as an instruction, errors may arise. 
Because of this the coder must be sure to store only instructions in that 
sequence of registers to which the control will refer for its program. To do 
this the coder must be aware of the manner in which the control obtains 
and executes instructions. In the remainder of this section, we will deal 
with the manner in which the control is designed to determine the sequence 
of registers which it will refer to in a search for its program and the way in 
which it is made to obtain a particular instruction from a given storage 
register. The question of how the control actually causes an instruction to 
be executed once it is located and obtained will be dealt with in a following 
section. 
Since instructions are stored in ordinary storage registers, the control 
obtains an instruction in the same way that it reads any word from a 
storage register, once the address of the register has been specified. This 
reading process has already been described. It remains for us to consider 
the manner in which the control determines the address of the register to 
be consulted. Since a storage address register (the S register in the CDC 
1604) is already provided for holding the address of the storage register in 

2-3. 
CONTROL REGISTERS 
67 
which a reading or writing operation is to be carried out, and since obtaining 
the next instruction is a reading operation, one seeming possibility would 
be to keep in the storage address register the address of the register which 
contains the next instructiop. This is not feasible, however, because the 
storage address register must be available to the control to store the 
addresses which are involved in the reading and writing operations of the 
current instruction. Therefore, a different control register, which we will 
call the program address register or P , is provided. The main function of Ρ 
is to hold the address of that register which contains the next instruction 
to be executed. Like a storage address register, a program address register 
is, in general, nonaddressable with just sufficient length to store an address 
word. In a so-called implicit computer, the control implicitly understands 
(unless informed otherwise) that the address at which it will find the next 
instruction is some simple function of the address at which it found the 
current instruction. In such machines, register Ρ will have the ability to 
evaluate this function. Almost invariably this means that Ρ will be a 
counting register, that is, it will increase its content by one on receipt of 
an appropriate control signal. If this is the case, the normal mode of opera-
tion of the computer will be to accept its instructions as the content of 
sequentially addressed registers. This kind of operation is too rigid to cover 
every kind of situation, however, and such computers will also have in-
structions which can themselves alter the content of P . This will cause 
control to accept its next instruction from the location specified by the 
address inserted into P . Instructions which cause modification of the 
content of register Ρ are called jump 
instructions. 
In contrast to implicit computers there are explicit machines in which 
the control must be told at the conclusion of the execution of the current 
instruction the address of the next instruction to be executed. This can be 
accomplished by adjoining to each instruction an additional address part 
to specify the location of the next instruction. Thus, the instruction "add 
a" becomes "add α, 0" and its interpretation could be the same as given 
above with the addition of "and obtain the next instruction from the 
register whose address is ß.
t} In this way every instruction becomes a jump 
instruction. The explicit control shows to advantage when storage devices 
are of variable access type. Since the address of the location of the next 
instruction is arbitrary and not necessarily one greater than the address of 
the previous one, the coder can try to choose a location which is the most 
accessible one. He can thus minimize the time the control must wait and 
do nothing before it can obtain its next instruction. 
In summary, whether the control is implicit or explicit, once it has been 
started on its initial instruction, it performs, repetitively, the cycle of (1) 

68 
2. MACHINE ORGANIZATION 
execute the current instruction, and (2) obtain the next instruction, until 
it receives a command to halt. At the conclusion of part (1) of the cycle, 
the only information that the control needs for part (2) is the address at 
which the next instruction is stored. A special control register is provided 
for storing this information and is usually given a name such as "sequence 
control register" or "program address register." In an implicit control, 
this register will usually be provided with counting facilities, since for the 
most part, the address of the next instruction is determined by advancing 
its content by one. In machines in which the location of the initial instruc-
tion is arbitrary, the program address register can be set by hand from the 
operator's console. 
In implementing phase (2) of its cycle, the control first consults Ρ and 
causes the content of the register whose address is in Ρ to function as an 
instruction word. This will usually be accomplished by transmitting this 
word to a special control register designed to store an instruction during 
its execution. This register, which we may call the program control register, 
will be discussed in Section 2-3.4. We see, however, that because of the 
special function of P, a sequence of digits contained in a storage location 
will be interpreted as an instruction if, and only if, the address of that 
location has been sent to register P. If the sequence constitutes a legitimate 
instruction word, the instruction will be carried out. If the sequence is not 
a proper combination, the computer will fault and come to a halt. 
2-3.3. The Next Instruction in the C D C 1604 
The CDC 1604 control is implicit. A special fifteen-bit register called the 
Program 
Address 
Register, or P, is used to contain the address of the 
storage location which holds the next instruction to be carried out. This 
register is also a counter; that is, if its content is not altered by the instruc-
tion being executed, it will, for each program step, advance its content by 
one. In the CDC 1604, Ρ counts modulo 2
1 5, or in a two's complement mode. 
This means that (P) passes from address 77777 to 00000 on receipt of a 
count signal. 
Assume that the CDC 1604 control has arrived at the point in its cycle 
at which it has completed the current program step and must obtain the 
next instruction pair from a storage register. The normal procedure is for 
the control to advance the content of Ρ by one. However, without any 
consideration as to the manner in which the content of Ρ was determined, 
the control will then accept whatever integer it finds in Ρ as the address of 
the register containing the next instruction pair. To be definite, we will 
assume that the current program step was taken from the register with 

2-3. 
CONTROL REGISTERS 
69 
address 00123, and, hence, that (P) 
= 00123. In order to obtain its next 
instruction, the control initiates the following sequence of events: 
1. Advance the content of Ρ by one. Therefore, ( P ) = 00124. 
2. (P)—>S, that is, the content of Ρ is copied into the appropriate S 
register ( S
1 in this particular case). 
3. A reading operation is initiated. Therefore, (X) 
= (00124) = the 
next program step. 
4. The content of X is transferred to a control register whose function 
is to store the current program step during its execution. 
The current instruction pair cannot be retained in X during its execution, 
as that execution may itself require the control to make further use of X. 
Accordingly, the register referred to in step four, which is reserved for 
storage of the current program step during its execution, is necessary. This 
register is called the Program 
Control Register and is referred to by the 
symbol U. 
Once the next instruction pair has been transferred to U, it becomes the 
current program step. A more detailed discussion of how the control 
carries out the current program step will be given in the succeeding section. 
Regardless of its execution details, however, an instruction of the current 
pair will either leave the content of Ρ unchanged and permit the next 
program step to be determined in the manner described above, or it will 
alter the content of Ρ and cause the next program step to be taken from 
the register whose address it has inserted in P. In the latter event, the 
instruction is called a jump instruction. 
If the current instruction is not a 
jump instruction in the example above, the content of Ρ will remain at 
00124. This address will then be used as the address of the register con-
taining the current instruction pair until the control again arrives at that 
point in its cycle at which it must obtain the subsequent instruction pair. 
The control will continue to take its next program step from the register 
whose address is one greater than that of the register from which it ob-
tained its current program step, unless an instruction is a jump instruction. 
In this case, control will take the next program step from the register with 
address specified by the jump instruction. The jump address will be deter-
mined by the address part of the jump instruction. The execution of a 
jump depends on the operation code, and its purpose will be clarified in 
the detailed discussions of jump instructions in later chapters. 
The content of Ρ can be set by hand at the console. After this first 
manual setting, the control will consult a sequence of registers in the 
manner defined above without the necessity of further intervention from the 
operator. We illustrate by an example. 

70 
2. MACHINE ORGANIZATION 
Example 2-7. We assume (P) = a initially, and the computer is started. 
Program steps will then be chosen from a sequence of registers with the 
following addresses: 
a 
a + 1 
a + k 
(contains a jump instruction to address β) 
ß 
ß + 1 
etc. 
Thus, the sequence of registers from which instructions will be taken is 
defined by the implicit nature of the control, the initial content of P , 
possibly the content of the registers which are actually consulted by the 
control, and, as we will see below, the data. These last three items are the 
particular responsibility of the coder. 
Our discussion so far has concentrated on describing the means by which 
the sequence of addresses of registers containing instructions is determined 
and how the instruction is extracted from storage once the address is 
specified. The fact that in the CDC 1604 a register contains two instruc-
tions (in contrast to a number of machines in which a register contains a 
single instruction) presents a complication of which the coder must be 
aware. The question of the order of execution of the instructions of the 
pair arises, as does the possibility of the omission of one of them. In the 
CDC 1604, the control normally executes the upper instruction of a program 
step and then the lower one, and then passes to the upper instruction of the 
next program step. The execution of the lower instruction will be omitted 
if the upper instruction initiates a jump. There are certain other instructions 
which will cause the lower instruction to be skipped and the next program 
step to be taken in sequence, if certain internal conditions are met. If an 
instruction with a skip feature appears as the lower instruction, it will be 
executed repeatedly until the skip condition is met. Then the next program 
step in sequence will be initiated. If the condition is not met, the computer 
will continue to cycle until manually stopped. This presents some inter-
esting programming possibilities. Finally, we note that a deviation from 
the normal procedure of executing the upper instruction first can be ac-

2-3. 
CONTROL REGISTERS 
71 
complished by a jump instruction called a return jump. This particular 
kind of jump instruction causes the upper instruction of the program step 
which it initiates to be skipped and modified. It will be described in greater 
detail in Chapter 6. 
2-3.4. Executing the Current Instruction 
The function of the control is repetitively to execute the current instruc-
tion and obtain the next instruction until a current instruction causes it to 
stop. In the previous sections we outlined the means by which the control 
is made to decide on the sequence of addresses of those storage registers 
from which it will obtain instructions, and we saw that it transfers these 
words to a special control register where they are held during execution. 
It is only after a digital sequence is placed in this register that control will 
interpret it as the current instruction. In this section we will outline the 
means by which an instruction is actually executed. 
As soon as an instruction or instruction pair has been copied into the 
program control register, it becomes the current instruction or instruction 
pair; and the control is ready to enter into that phase of its cycle in which 
it executes the current instruction. The first step involves the translation 
of the operation code part of the instruction word. For this purpose the 
control is provided with a many-to-one 
translator. This is a device which 
accepts as inputs the digits representing an operation code and produces a 
single output uniquely determined by each possible set of input digits. 
Thus, each translator output is uniquely associated with an operation code. 
If there are any unused operation codes, they are normally lumped together 
and assigned a translator output which initiates a "fault and halt" opera-
tion, corresponding to any illegitimate combination. The single output 
from the translator is employed by the control to select all functions which 
must be performed in carrying out a particular instruction. 
The execution of a particular instruction can generally be described in 
terms of the execution of a sequence of elementary machine operations. 
The concept of what constitutes an elementary machine operation will 
vary from computer to computer, depending on the complexity of the 
individual instruction, so that what might be considered an elementary 
operation in one machine may turn out to be a regular operation in another. 
Typical of elementary operations are the following: 
Clear the accumulator. 
Add the content of the exchange register to the content of t h e 
accumulator. 

72 
2. MACHINE ORGANIZATION 
Shift the digits of the accumulator left (right) one position. 
Form the one's complement of the digits in the exchange register. 
Initiate reading (writing). 
These, of course, are only a representative few of the operations actually 
required, and we assume that the control is provided with a large class of 
elementary operations, each of which can be activated by directing a 
control signal to the proper location, that is, by the equivalent of pushing 
the proper button. Any single computer instruction will require the execu-
tion of a different subclass of the totality of elementary operations. Al-
though each operation code will require the execution of a distinct subclass 
of elementary functions, there will usually be an overlap among the differ-
ent subclasses required for the various operation codes. It is the function 
of the translator to define the subclass for each instruction. The translator 
output is split to select from the class of all elementary operations which 
the control can carry out, that subclass appropriate to the particular 
operation code. 
If the instruction word involves a subset of digits defining a designator, 
a similar translator arrangement will provide a unique output correspond-
ing to each designator value. This output will be utilized by the control 
to select all of the elementary operations which must be carried out in 
conformance with a particular designator value. 
Obviously, selection of a set of elementary operations by the translator 
output should not cause them all to be initiated immediately and simul-
taneously. They must be carried out in the proper order. This ordering 
usually is arranged by providing one or more timing devices or clocks 
which issue a sequence of timing signals. An elementary operation can 
then be initiated only if selected by both a translator signal and a timing 
signal. In this way, the elementary operations selected by the translator 
will be performed in the order imposed by the clock, and the selection and 
sequencing necessary for the execution of a current instruction is carried 
out by combining the translator output with clock signals into a suitable 
network. This is an extremely simplified version of what takes place. The 
resultant network may be complicated by feedbacks from the elementary 
computer operations themselves. Such feedbacks may be required to sus-
pend and resume the issuance of clock signals in order to give certain opera-
tions, which take longer than the normal interval between signals, the time 
to complete themselves. 
The control which sequences the execution of elementary operations by 
means of equally spaced clock signals is usually referred to as 
synchronous 
control, and most computing machines have this type of control*. However, 

2-3. 
CONTROL REGISTERS 
73 
in some computing machines the control is asynchronous, 
that is, it does 
not depend on a set of equally timed signals to sequence the execution of 
elementary operations. In such a control each succeeding elementary opera-
tion is initiated by the preceding one as its final function. This eliminates 
loss of time due to an elementary operation's having completed itself 
before the issuance of the next clock signal. The execution times of instruc-
tions have greater variability in asynchronous machines, and conceivably, 
a shrewd coder can minimize these times to some extent. However, this is 
a subject for the advanced coder, and we will not pursue the matter further. 
In general, we will not need to know the detailed manner in which an 
instruction is executed in terms of elementary functions selected, sequencing 
by clock signal, feedbacks, and analysis of the elementary operations, 
which are frequently complex in themselves. Rather, we should be familiar 
with the general flow of events in the execution of an instruction, so that 
we may predict the changes in register content which the instruction will 
cause and the order in which these changes will occur. We must also be 
aware of possible idiosyncrasies associated with the way in which some 
instructions are performed and which may sometimes produce unexpected 
results. Such peculiarities are certainly of interest to the programmer. 
2-3.5. The Current Instruction in the C D C 1604 
We have already pointed out that the program control register, or U, 
is used in the CDC 1604 to hold the instruction which is currently being 
carried out. The register is forty-eight bits in length, and it will initially 
contain the instruction pair as copied from storage. The upper instruction 
of a program step is normally executed first and then the lower. The in-
struction bits must be in the high order half of U during the instruction's 
execution. Accordingly, the lower instruction is moved to the upper half 
of U and held there during its execution. For this reason we sometimes find 
it convenient to let U refer to the upper half of the program control register 
and introduce the symbol L to refer to the lower. The process of initiating 
the lower instruction is called taking a half exit. A half exit is normally 
taken after an upper instruction is executed unless the particular instruc-
tion specifies a jump or a full exit. The jump exit initiates a new sequence 
of program steps whose addresses begin with the effective address of the 
jump instruction. A full exit will advance the program address by one and 
cause the next program step to be taken in sequence. Certain instructions 
specify either a half exit or a full exit depending on a machine condition. 
When such instructions appear in the lower half of a program step, they 
are executed repeatedly until the condition for a full exit is met. 

74 
2. MACHINE ORGANIZATION 
The elements of control utilized in the execution of an instruction are 
shown in the following diagram. 
U
2 
U 
Operation 
code 
translator 
Designator 
translator 
Operation 
Designator 
Base 
Operation 
Designator 
Base 
code 
address 
code 
address 
Move to upper half before execution 
To select appropriate subsequences of elementary operations 
corresponding to operation code and designator code. 
The half of a program step which is being executed is held in the upper 
half of the program control register. The base address part of this instruc-
tion is copied into the fifteen-bit accumulator U
2 where, as we saw in 
Section 2-3.1, it is converted into the effective address. In the figure both 
the operation code and designator bits are shown entering the translators. 
These are many-to-one translators which, respectively, replace each con-
figuration of six and three bits by a single output, uniquely corresponding 
to the input configuration. The split outputs of the two translators serve 
to initiate a unique sequence of elementary operations carried out in order 
and timed by the computer clock signals. At the end of this sequence, the 
execution of the instruction is complete, and the control goes on to repeat 
a similar cycle for the next instruction. We make no attempt here to de-
scribe the switching networks and related equipment which actually pro-
duce the execution of each elementary operation. Rather, we illustrate by 
some simplified examples the steps used to complete an instruction. Since 
we have already discussed the way in which a word is read out of one 
register and written into another, we omit the details of these operations. 
Example 2-8. The CDC 1604 is a subtractive machine, that is, it sub-
tracts directly and adds by subtracting a complement. The add instruction 

2-3. 
CONTROL REGISTERS 
75 
provides for addition of the content of a storage register (whose address is 
specified by the instruction) to the content of the accumulator, A. Suppose 
that the address specified in the add instruction is ra, then the sequence of 
steps initiated is: 
1. m goes to U
2. 
2. Content of the designated index register goes to R. 
3. (R) 
is complemented. 
4. (Ä) is subtracted from (C/
2) to provide M in U
2. 
5. (f/
2) goes to S. 
6. Initiate read. 
7. (M) goes to X. 
8. (X) 
is complemented. 
9. (X) 
is subtracted from 
(A). 
If we use primes to denote complements, we see that the first four steps 
give the effective address M = m — (B
h) ' = m + (B
h). 
The remaining 
steps serve to complete the operation by forming (A) 
— (M)
r 
= (A) 
+ 
(M) as the final content of A. 
Example 2-9. The A left shift instruction provides for a shift of all bits 
in A to the left by an amount which is specified by the address portion k 
and the designator of the instruction word. As high order digits are shifted 
out, they go into the 1W order positions. The steps are : 
1. k goes to U
2. 
2. Content of the designated index register goes to R. 
3. (R) is complemented. 
4. (Ä) is subtracted from (U
2) to provide Κ in U
2. 
5. (U
2) 
goes to R. 
6. (R) is tested. 
(a) If (R) 
— 0, control accepts the next instruction. 
(b) If (R) 
j£ 0, (R) is decreased by one and (A) is shifted left by 
one. 
7. Step 6 is repeated until (R) 
= 0 . 
Steps 1 through 5 set the effective shift count Κ = k — (B
h)' 
= k + 
(B
b) 
into the counting register R. For each left shift of one place in (A), 
the 
count is decreased by one until it is zero. Thus, at the end of the complete 
operation, (A) has been shifted left Κ places. 
Some instructions, such as division, will require the execution of many 
more elementary operations than those listed for addition. We also note 
that the repetition of part of the steps in shifting will require more opera-
tions than are apparent in the written list, and the number will vary for 

76 
2. MACHINE ORGANIZATION 
different values of K. These differences will be reflected in the total execu-
tion times. For example, the average time to add is 7.2 Msec, to divide is 
65.2 Msec, and to shift is variable, (2.8 + AK) 
Msec. For the most part, 
however, the programmer will not need a detailed knowledge of the in-
dividual steps taken to complete an instruction. Instead, he will have to 
be aware of the final effect on all pertinent registers. A general feeling for 
the flow of events in each instruction may make it possible to anticipate 
idiosyncrasies and to write a more efficient code. 
2-4. Input-Output 
The problem of input is that of transforming an ordered array of char-
acters external to the computer into an ordered array of characters stored 
internally. Although the characters employed may actually be digits of 
some number system, letters, and "special" symbols, we can usually think 
of them as a sequence of binary digits. We change the characters into a 
binary array by the introduction of a binary code. By a binary code we 
mean a one-to-one correspondence between the admissible characters 
and a subset of the integers which can be represented by a fixed number of 
bits. The reason for the choice of binary as fundamental is sometimes sur-
prising to the uninitiated, but a little consideration will clarify the simplicity 
of design involved. We need only devise a physical "either-or" situation, 
such as a switch on or off, to simulate a binary zero or one. Most input and 
output systems reflect the simplicity of this concept. 
The input data is most commonly transcribed into punched paper tape, 
magnetic tape, or punched cards. The transcription medium is then taken 
to a reader j or sensing device, which operates in conjunction with the 
computer, and which scans the medium and transmits the information 
into the computer. In the case of data transcribed into punched cards, 
we can think of a punch or hole at a row and column intersection as stand-
ing for a one and the lack of a hole as standing for a zero. Since each char-
acter is transcribed into a single twelve row column of the card, our corre-
spondence or code in this case is between the set of admissible characters 
and a subset of the twelve-bit integers. Similar remarks apply to punched 
paper tape and also to magnetic tape, in which digits zero and one can be 
inscribed by utilization of two different intensities of magnetization. In 
the case of data to be read from external copy by an optical scanning de-
vice, we can still think of the external information as corresponding to a 
binary array, since the scanner will generate and transmit to the computer 
the binary coded form of each character that it sees. In most machines it 
is possible to transmit data directly without the use of an intermediate 

2-4. 
INPUT-OUTPUT 
77 
transcription medium and reader. This is done by means of an on-line 
(or directly connected) keyboard or by means of console buttons which 
give direct access to certain computer registers. Depression of a key or 
button will generate and transmit to the computer the binary code corre-
sponding to the character with which the key or button is labeled. 
The problem of output is the reverse of that of input. An ordered array 
of binary information is stored internally and must be transformed into 
an ordered array of characters external to the computer. Frequently 
these characters are first transcribed as binary codes into an output medium 
(such as magnetic tape) by means of a peripheral recording device which 
operates in conjunction with the computer. The output medium is then 
taken to an off-line device where it can be recorded visually at any time 
without further use of the computer. These visual recording devices have 
the facility to generate the appropriate character from its binary code; 
and while there will usually be one or more which operate directly on-line 
as well, their use will be restricted because of the encroachment on com-
puter time. 
In this section we give a brief account of the mechanics of the move-
ment of binary data from outside of the computer into the storage registers 
and vice versa. We will ignore the fact that only rarely will we want in-
ternally an exact copy of the array that we have externally, or externally 
an exact copy of the internal array. In general, a transformation of some 
sort is carried out during the transmission of data. However, we assume 
that on input this transformation is carried out on a copy of the external 
array as it is stored internally; and on output we will assume that this 
transformation is carried out at the time the internal array in the storage 
registers is sent to output. This reduces the problem of transformation of 
the data array between the internal and external form to one of ordinary 
coding. The details of this coding will be discussed in the succeeding chap-
ters, while here we concentrate on the mechanics of transmitting the data. 
At one end of the data transmission we will have the computer's storage 
system and at the other a variety of peripheral devices: readers, scanners, 
punches, printers, cameras, etc., each capable of handling the binary array 
of data it is to receive or transmit. A communication channel between 
storage and the peripheral input-output devices must be provided. This 
channel may be shared by all of the devices, or there may be a number of 
different channels among which the input-output devices are distributed. 
It is not unusual to have several channels capable of simultaneous opera-
tion, and each connected to a subset of the devices in such a way that at 
any time only one can utilize the channel for either input or output. Such 
a channel obviously provides a path for the transmission of data from 
storage to peripheral equipment and back. It must also provide a path 

78 
2. MACHINE ORGANIZATION 
for the transmission of control information, 
and the channels must thus be 
accessible to the control. Over a channel the control will select an item of 
peripheral equipment and initiate one of its modes of operation and will 
receive information back as to the current status of the channel and any 
equipment attached to the channel. A channel must, of course, have 
access to the read and write mechanism of the computer, since data trans-
missions will require reading and writing operations in storage registers. 
In some computers this access will hold up other computer operations 
during input and output transmissions. Because of the relative slowness 
of the peripheral equipment, this is costly in computer time. Hence, other 
computers are designed so that the transmission operations can be carried 
out in parallel with other computer operations. A channel which can operate 
simultaneously with computer operations can generally operate simul-
taneously with other input-output channels, thus providing additional 
savings in time. 
2-4.0. Input-Output in the CDC 1604 
The amount of peripheral input-output equipment used by a CDC 1604 
varies in different installations. A typical set includes a typewriter; a paper 
tape punch and reader; a card punch and reader; magnetic tape handlers; 
and a high-speed printer. Each of these is directly connected to the com-
puter by means of its input-output channels. 
The CDC 1604 has seven communication channels between its storage 
section and its external input-output equipment. These channels are used 
for the transmission of blocks of data from the computer storage to the 
external device and vice versa. By a block of data we mean one or more 
48-bit words stored in consecutively addressed storage registers. Once the 
main control has initiated the transfer of a block of data on any of the 
channels numbered 1 through 6, the block transfer is completed in a man-
ner which is independent of the main control, that is, which permits it to 
go on with the execution of instructions having nothing to do with the 
block transfer. This kind of transfer is called a buffered transfer. In buffered 
transfers the odd channels, 1, 3, and 5 are used for input, and the even 
numbered channels, 2, 4, and 6 are used for output. Channel number 7 can 
be used for both input and output in nonbuffered block transfers which 
are carried out under the direct control of two special instructions provided 
expressly for this purpose. Once either of these instructions has been 
initiated, the control cannot proceed with the execution of any other in-
struction until the transfer of data has been completed. The nonbuffered 
transmission, carried out at CDC 1604 computer speed, makes direct use 
of the control to achieve this rate, and requires a receiving or transmitting 
device (possibly another CDC 1604) which can sustain the rate. The 

2-4. 
INPUT-OUTPUT 
79 
buffered transfers are carried out at the various speeds of the external 
devices. 
The figure below provides us with a schematic diagram of the CDC 1604 
input-output system. As illustrated in the figure, the channels communicate 
Output data to external equipment 
Output register 2 
Output register 4 
Output register 6 
Output register 7 
Storage registers 
X Register 
Control data common 
to all channels 
t 
ι 
t 
External function 
code Ζ 
Input data from external equipment data registers 
with the storage registers via the exchange register X. Output data goes 
from storage, via X, to the appropriate output register for the channel. 
Input data goes to storage, via X, the data coming from registers which 
are within the input device. The channel paths shown can carry 48 bits of 
data and also carry control signals between the computer and the various 
external components. This ensures that the transmission from input regis-
ters to input channels, and from output registers to output channels, are 
properly completed. These signals indicate readiness to transmit or receive 
and also acknowledge receipt of information. 
The buffered transmission is set up and initiated by means of a special 
external function instruction. We will consider the form and use of this 
instruction in Chapter 7. 

80 
2. 
MACHINE 
ORGANIZATION 
Another element for input and output is the operator's console. On the 
CDC 1604 this provides direct manual input to all index registers and to 
A, Q, P , and U, where the computer is stopped. At such a time, output is 
also provided in terms of a visual display of the content of these registers 
in octal. Of course, the necessary switches to facilitate the operator's 
control of the computer are also to be found on the console. 
Exercises 
Section 2-1 
1. 
Since any register in a computer has content and "stores" it, what 
particular characteristics are associated with those we call storage 
registers which distinguish them from other kinds of registers? 
2. 
Consider the numbers stored at specific locations in a table of values 
of e
x. What would correspond to the "address" at which a number is 
located? What features, if any, are lacking in the table to make the 
number locations equivalent to storage registers in a computer? 
3. 
Suppose a computer is stopped. The content in each of its storage 
registers momentarily defines a mathematical function whose values 
are given by the content of the registers. What corresponds to the in-
dependent variable? Hence, to what general mathematical notation 
does (a) for content of address a correspond? 
Section 2-1.0 
4. 
What is the length of a word in a CDC 1604 storage register? What is 
its octal length? 
5. 
What is the length of an address in the CDC 1604? What is its octal 
length? 
6. 
In the CDC 1604 suppose (00100) 
= 0123 4567 6543 2101 and 
(00200) = 1111 1111 1111 1111, all numbers in octal. What would 
(00100) + (00200) be? Would (00100 + 00200) have any meaning, 
and if so, how would it be related to your first result? 
Section 2-2.0 
7. 
If the sequence of digits contained in a computer register is considered 
to be an arithmetic operand, what are the usual interpretations given 
to it? Think of as many nonarithmetic interpretations of words as you 
can. 

EXERCISES 
81 
8. 
In a decimal computer using nine's complement arithmetic, storage 
registers have a twenty-digit length. Find the mathematical restric-
tions which must be imposed on arithmetic operands considered as 
integers and considered as fractions. 
Section 2-2.1 
9. 
If an integral operand η is in a storage register in the C D C 1604 why 
should it satisfy the condition that | η \ < 2
4 7? 
10. Since a C D C 1604 storage register has forty-eight bits, it can actually 
contain the integer 2
4 8 — 1. Why would you interpret this as overflow? 
11. In some operations in the C D C 1604, arithmetic operands are con-
tained in a ninety-six bit register. Find the mathematical restrictions 
on these operands if they are to be interpreted as integers, and as 
fractions. 
12. How would you properly extend a complement number from a forty-
eight bit register to a ninety-six bit register? 
Section 2-3.0 
13. What are the minimum number of parts that must go into an instruc-
tion word? If an instruction word contains one or more addresses, why 
is an address normally shorter than a word in storage? 
14. Suppose you have a computer whose word length is twelve bits. Treat 
it in order as a single address, double address, and triple address 
machine, and devise your own allocation for operation code and ad-
dresses. Consider the restrictions imposed by word length, address 
length, and length of operand code. 
15. In most computer instructions, the number of digits for the operation 
code is less than the number assigned to addresses. Why? 
16. Suppose you have a single address computer. What is the minimum 
number of instructions you would need to add two numbers? What 
are the actual steps required? 
Section 2-3.1 
17. How long is a C D C 1604 instruction word, and what are its component 
parts? 

82 
2. MACHINE ORGANIZATION 
18. The octal form of a CDC 1604 instruction word is 12 
0 
00100. 
Decide what each octal digit represents and write the instruction word 
as it would be stored in a register. 
19. Since each complete program step for the CDC 1604 contains two 
addresses, why is it referred to as a single address machine? Are there 
any essential differences between the two addresses in a program step 
and a two-address instruction word? 
Section 2-3.2 
20. Suppose an address appears in a program address register. Decide 
what functions control must provide to initiate the execution of the 
next instruction. 
21. In what way does control "decide" what its next operation will be? 
22. What sequence of numbers determines the order of instructions in an 
implicit computer? an explicit computer? 
Section 2-3.3 
23. In what way does control in the CDC 1604 obtain its current 
instruction? 
24. How does the control distinguish a sequence of digits which is an in-
struction and one which is an operand? Could control "execute" an 
operand? 
25. Suppose you are carrying out an arithmetical computation with a 
desk calculator. Decide which components of your work correspond 
to those of a computer. What is storage, arithmetic section, and con-
trol? What constitutes a program? 

Elementary Coding 
3-0. Some Introductory Instructions 
In this chapter we introduce a number of instructions. We then investi-
gate the problem of arranging these instructions into meaningful patterns, 
that is, in such a way that the computer will, in executing the sequence of 
instructions, be made to perform a given calculation. This is called coding. 
At this point the reader should refer to Appendix A and familiarize 
himself with the operation of the following instructions: 
Instruction 
Operation code 
Load A 
12 
Store A 
20 
Add 
14 
Subtract 
15 
A jump 
22 
Selective jump 
75 
Selective stop 
76 
In the following example these instructions will be utilized with the 
designator b or j set equal to zero. For load A, store A, add, and subtract, 
this means that the base address and the effective address will always be 
the same. With j = 0, the selective jump becomes an unconditional 
jump, 
the selective stop becomes an unconditional 
stop, and the A jump becomes 
a zero jump. In later examples we will make use of these instructions in 
situations in which the designator will be permitted to take nonzero 
values. 
83 
CHAPTER 3 

84 
3. ELEMENTARY CODING 
Example 3-0. Consider the result of carrying out the particular add 
instruction, 14 0 00002, where it is assumed that 
( A ) / = 7777 7012 3456 7000 
and 
(00002)/ = 7777 7700 0010 0002 
The computer will perform the equivalent of the following computation: 
(A)j = 7777 7012 3456 7000 
(00002)/ 
= 7777 7700 0010 0002 
7777 6712 3466 7002 
End around carry 
+ 1 
(Α)ρ 
= (A)/ + (00002)/ = 7777 6712 3466 7003 
Here and elsewhere in the book the subscripts / and F refer to the 
initial and final content of the register referenced, with respect to the 
execution of the particular instruction involved. 
Example 3-1. If the instruction in the preceding example had been the 
subtract, 15 0 00002, the equivalent of the following computation would 
have been performed: 
(A)/ = 7777 7012 3456 7000 
(00002)/ = 7777 7700 0010 0002 
7777 7112 3446 6776 
End around borrow 
— 1 
(A)F = (A)/ - 
(00002)/ = 7777 7112 3446 6775 
Particular notice should be given to the fact that in simulating the 
CDC 1604, carries and borrows from the highest order position in the 
accumulator are not ignored, but are instead applied to the lowest order 
digit of the accumulator. This is necessitated by the one's (or seven's) 
complement form of negative integers. 
The coder must always keep in mind the fact that execution of the add 
or subtract or load A instructions will change the initial content of the 
accumulator and that the store A instruction will destroy the initial 

3-0. 
SOME INTRODUCTORY 
INSTRUCTIONS 
85 
content of the register whose address is equal to m. Consequently, when 
the content of any of these registers is of future interest, we must take 
pains to preserve it elsewhere before the execution of the operation. 
It is of extreme importance for the coder to remember that the integer 
which finally appears in A after a 14 or 15 operation will not be equal to 
the sum or difference of the original integers in A and m, unless this sum 
or difference is less than 2
4 7 in absolute value. The kind of error in which a 
result is too large for a given location is usually referred to as overflow. 
The treatment of this difficulty will be considered in Chapter 4. 
If the control is ever to break away from the sequential scanning of 
registers in its search for instructions, a way of changing the content of the 
program address register during the execution of the current instruction 
is necessary. The jump instructions provide the means for attaining this 
end. The simplest jump instruction is an unconditional 
jump, 
75 0 m, 
which sets the content of the address register to m, thus causing the next 
instruction to be taken from address m. For example, the instruction 
75 0 01234 will cause the next program step to be taken from memory 
register 01234, regardless of the address of the register which stores the 
unconditional jump itself. 
In our previous instructions, the address parts represented data addresses, 
that is, the location in storage of operands or of results. In the jump 
instructions we have our first example of a jump 
address, that is, an ad-
dress specifying to the control the location of an instruction. 
The A jump is an example of a conditional jump instruction. The address 
m in this instruction is the jump address. The A jump with j = 0 may be 
thought of as asking the question, "Is (A) equal to zero?" If the answer 
to this question is yes, the next instruction pair is to be taken from ad-
dress m. If the answer is no, the next instruction is to be taken in the 
normal sequential and implicit way. 
Example 3-2. Consider that the particular A jump instruction 22 0 00200 
is stored at the lower location 00100, and let 
(A) 
= 0000 0000 0000 0000 
or 
(A) 
= 7777 7777 7777 7777 (negative zero). 
In this case, the next instruction will be taken from register 00200. On the 
other hand, if (A) had been equal to anything 
else, the next instruction 
would have been taken in sequence from register 00101. 
The A jump restores all changes that it makes in testing. Hence, no 
change will have been made in A or in any storage register at the conclusion 

86 
3. ELEMENTARY CODING 
of the instruction. Each of the jumps considered so far is a normal jump; 
that is, if the jump is taken, the next instruction executed is the upper 
one at the jump address. Without a stop instruction, the computer would 
be forced to continue in its implicit mode of selecting instructions after all 
the useful calculations had been completed. It would continue indefinitely 
unless stopped by a computer fault. This could conceivably damage the 
results of the calculation. Accordingly, a number of stops are provided in 
the CDC 1604. 
3-1. A Code for α Vector Sum 
We now turn to our first example of coding. The problem we will under-
take is that of writing a code which will form the sum Ζ = V + W of two 
n-dimensional vectors, V and W, without destroying either V or W in 
storage. 
Example 3-3. The problem of adding two η-vectors may be restated in 
the following way. Two tables of integers, each containing η entries are 
given. Let these table entries be symbolized by Vi and Wi, i = 1, 2, · · ·, n. 
Then we must form the sum, Z< = V< + ΤΓ»·, i = 1, 2, · · ·, n, of corre-
sponding table entries, without destroying any of the original entries in 
storage. For simplicity, we will assume that | Vt-1 < 2
4 7, | Wi | < 2
4 7, and 
\Zi\< 
2
4 7 for all i. 
To start, we will assign the following definite storage locations to the 
data and to the results: 
Vi = (00100 
+ ί - 1 ) 
Wi = (00200 + t - 
1) 
Zi = (00300 + * - 
1), 
1 < i < η 
Since addresses are to be expressed in octal, the integers i and η will also be 
represented in that system. It is clear that in order to avoid the overlap of 
data and results in storage registers, the restriction η < 100 (sixty-four) 
must be imposed. 
The initial component, Z\ of the resultant vector, can be formed by the 
execution in sequence of the following triplet of instructions 
12 
0 
00100, 
14 
0 
00200, 
20 
0 
00300 
The triplet of instructions 
12 
0 
00101, 
14 
0 
00201, 
20 
0 
00301 

3-1. A CODE FOR A VECTOR SUM 
87 
will then correctly form Z 2. The storage location of instructions as well as 
data must, of course, be precisely specified. We will assume that the data 
has already been placed in the assigned registers. Then the following 
two codes will correctly form the specified vector sum for η = 2 and 
η = 5, respectively: 
01000 
12 0 00100 
14 0 00200 
V, -> A, 
(A) = 7i + Wi 
01001 
20 0 00300 
12 0 00101 
Zi -* 00300, 
V2-+A 
01002 
14 0 00201 
20 0 00301 
(A) = 7 2 + W2, Z2 
301 
01003 
76 0 01003 
STOP 
01000 
12 0 00100 
14 0 00200 
7i -> A, 
(A) = Vi + Wi 
01001 
20 0 00300 
12 0 00101 
Zi -> 00300, 
7 2 
A 
01002 
14 0 00201 
20 0 00301 
(A) = 7 2 + W2} 
Z2 -> 00301 
01003 
12 0 00102 
14 0 00202 
7 8 
A, 
(A) = 7 3 + W3 
01004 
20 0 00302 
12 0 00103 
Zi-> 00302, 
VA->A 
01005 
14 0 00203 
20 0 00303 
(A) = 7 4 + WA, Z4 -» 00303 
01006 
12 0 00104 
14 0 00204 
7 6 -> A, 
(A) = 7 6 + T76 
01007 
20 0 00304 
76 0 01007 
Z 6-> 00304, 
STOP 
Only the information between the double lines is entered into the storage 
registers of the computer. The information to the left and right of the 
double lines is for the aid of the coder, reminding him of exactly where 
an instruction is to be located and of the effect of that instruction. 
The codes or programs given above, although correct, have certain 
undesirable features. They vary in length and are different for each different 
value of n. The varying storage requirements of the programs arise from 
the fact that separate instructions have been placed in storage to handle 
each individual item of data. For a typical problem, such a coding tech-
nique would require an extremely large number of instructions—probably 
more than could be placed in storage at one time. Since the speed of the 
computer enables it to execute thousands of instructions per second, the 
technique of storing separate instructions to handle each item of data will 
lead to an uneconomical mode of operation in which the computer will 
spend the majority of its time either stopped or loading in new sets of 
instructions. 
The coding technique which should ordinarily be employed consists of 
creating the instructions for handling each item of data as it is needed from 
a small set of prototype instructions. This technique requires that we 
place the data in storage systematically and with careful foresight. Sys-
tematic storage of data allows repetitive use of a small body of instructions 
to create from a set of prototype instructions, as needed, the individual 
instructions for operating on given data items. Random placement of data 
invalidates this technique and will force the introduction of more instruc-

88 
3. ELEMENTARY CODING 
tions for operating on prototypes than would be required if individual 
instructions for each item were used. For Example 3-3 the data have al-
ready been correctly arranged, and the program will be rewritten below in 
order to illustrate the proper technique. 
3-1.0. Symbolic Addresses 
Before rewriting the vector addition code, it will be convenient to intro-
duce some notation. When we begin to prepare a program, we rarely 
have a complete knowledge of all of the addresses involved. We may not 
know where certain instructions, parameters, and data will finally be 
located. Unfortunately, we must constantly refer to these quantities by 
address within the code. Accordingly, we will introduce certain symbols 
which represent addresses. These are referred to as symbolic 
addresses, 
and, when necessary, are used in place of the actual machine or absolute 
addresses of a quantity. Of course, all of the symbolic addresses must 
eventually be reduced to machine addresses. Fortunately, this last reduc-
tion is quite straightforward, though often tedious. 
We will at first employ two kinds of symbolic addresses. One type is 
called a relative address and is symbolized by the notation α». Here α is 
just a convenient tag for which any other symbol could have been used, 
and additional symbols may be required. The address α» is defined to be 
equal to the address a0 + i. Thus, once an absolute address value is as-
signed to «o, all ai are immediately determined relative to a 0. In using the 
relative address notation, it is advisable to express the subscript i in 
octal. A number of minor but troublesome errors will be avoided thereby. 
The second type of symbolic address is not quite as elegant as the 
first, but is, nevertheless, quite useful. It is known as the location-of 
address 
notation and symbolized by l(z). 
This symbol is interpreted to be the 
location of the quantity in its parentheses—in this particular example z. 
We are at liberty, of course, to introduce any other symbols for addresses 
which may seem convenient. We ordinarily choose such symbols for 
mnemonic purposes. However, it is well to keep in mind that symbolic 
addresses must eventually be converted to absolute machine addresses. 
In what follows we will see that this conversion can be accomplished by 
the machine itself if a suitable program of instructions is provided. In 
order to avail ourselves of the machine conversion, we will have to sacrifice 
some freedom of choice of symbols in order to remain within some format 
dictated by the conversion program. We will examine this subject in 
greater detail in later chapters. Here we will utilize the two kinds of address 
symbols defined above and perform the conversion to absolute addresses 
ourselves. 

3-1. 
A CODE FOR A VECTOR SUM 
89 
Example 3-4. As an example of the use of the symbolic addresses, we 
rewrite the first code of Example 3-3 using both kinds. We have for η = 2, 
with instructions started at a 0, 
ao 
12 0 t{Vi) 
14 0 t{Wx) 
Vi — A, 
(A) = Vi + Wi 
ai 
20 0 l(Zx) 
12 0 1{V2) 
Zi->/(Zi), 
V2 -> A 
a 2 
14 0 /(TP,) 
20 0 /(Z2) 
(.I) = 7 2 + TT2, Z2 -> /(ZJ 
a 3 
76 0 ao 
STOP 
If we assign a 0 = 01000, t(Vt) 
= 00100, t(Wx) 
= 00200 and l(Zx) 
= 
00300, all other absolute addresses are determined, and the absolute 
program is the same as before. 
In addition to simplifying the bookkeeping required in the first stages 
of a program, the use of symbolic addresses often helps us to visualize the 
purpose of each instruction. For instance, we see that the triplet of in-
structions, 
12 
0 
l{Vi), 
14 
0 
t(Wi), 
20 
0 
/(Z<), 
indicates very clearly the steps we need to take to form each component. 
3-1.1. The Iterative Loop 
Now let us turn to a second technique for writing the code for vector 
addition. Nöte that the instruction triplet for forming the ith component 
Z t i s 
12 
0 
00100 + i - 
1, 
14 
0 
00200 + ί - 
1, 
20 
0 
00300 + i - 
1, 
while the triplet for forming the (ί' + l ) s t components Zi+i is 
12 
0 
00100 + f, 
14 
0 
00200 + t, 
20 
0 
00300 + i. 
Obviously, the instructions for forming Zi+i 
can be obtained from the 
instructions for forming Z t by addition of the parameter 00 
0 
00001. 
Thus, if the instructions for forming Zi are written explicitly, all of the 
other triplets can be obtained from them by successive addition of this 
parameter. When it is necessary to advance the address part of both 
the upper and the lower instructions of a program step, we utilize the 
parameter 
00 
0 
00001 
00 
0 
00001, 

90 
3. 
ELEMENTARY CODING 
which we will refer to as the U-L advancer. Similarly, we introduce param-
eters 
00 
0 
00001 
00 
0 
00000 
and 
00 
0 
00000 
00 
0 
00001 
for advancing, respectively, only the upper address or the lower address. 
We will refer to these parameters as the U advancer and L advancer. 
Example 3-5. We write the vector sum code, creating the necessary 
instructions, as needed, from those for forming Z\. The reader is warned 
in advance that the code has a serious defect. 
OCA 
12 0 00100 
14 0 00200 
20 0 00300 
12 0 a„ 
14 0 /(tf-Ladv.) 
20 0 
a 0 
12 0 ai 
14 0 
*(£/adv.) 
20 0 αϊ 
75 0 
a 0 
Vt -> A, 
(A) = Vi + Wi, 
i = 1 
initially. 
Vi + ΪΓ.-+300 + i - 1, i = l initially. 
Set up (ao) for modifications. 
Increase i by one in instruction and 
reset. 
Increase i m(ai). 
Reset (ai) and repeat for next value of i. 
We note that the first three instructions form Zi starting with i = 1. 
The next six instructions change the initial three so that they will form 
Z»+i when executed. The final instruction provides for the control to go 
back to the program step at ao in order to form 
Zi+i. 
An iterative loop of addresses consists of a sequence of addresses which the 
control consults repetitively in the execution of a code. The addresses 
ao, ai, OÎ2, «3, au, in the code above form such a loop. The instructions 
making up the content of the registers whose addresses form the loop may 
remain constant, but ordinarily certain ones will change each time the 
control traverses the loop of addresses. Unfortunately, in Example 3-5, 
the control has no means of breaking out of, or exiting, from the loop. 
Consequently, it will cycle through the loop indefinitely, performing the 
desired vector addition, and a large number of extraneous calculations, 
unless halted by a computer fault. A loop without an exit, such as formed 
by ao — «4, is called a closed or infinite 
loop. 
When the data are properly arranged in storage, an effective and eco-
nomical code can be written by employing the loop concept. In general, 
some of the instructions stored within the registers addressed in the loop 
will be prototype instructions for operating on the initial data items. 
Others will be housekeeping 
instructions 
which operate on the prototypes 
and their successors to create new instructions for handling succeeding 
sets of data items. As Example 3-5 illustrates, however, the housekeeping 

3-1. 
A CODE FOR A VECTOR SUM 
91 
instructions must do more than this—they must also provide the loop with 
an exit. 
A simple and straightforward means of exiting from a loop is the com-
bination of a counting operation and a conditional jump. For example, a 
parameter equal to n, the number of times the loop is to be traversed, can 
be stored. Then each time the loop is actually traversed, this parameter 
can be reduced by one and compared to zero by means of the 4-jump. If 
the parameter has become zero, the instructions of the loop have been 
executed a sufficient number of times and the control exits from it by a 
jump; if not, the jump will be such as to cause the control to complete the 
loop one more time. We will redo the vector addition code to illustrate this 
exit technique. 
Example 3-6. We write the loop of Example 3-5 with an exit. 
a 0 
12 0 00100 
14 0 00200 
> Form Zi beginning with i = 1. 
Ot\ 
20 0 00300 
12 0 
t(n) 
a 2 
15 0 
\ 
Reduce count by one; if count zero, exit from loop. 
22 0 
« 7 
« 3 
20 0 l{n) 
12 0 ao 
1 Store reduced count. Modify first program step to 
«4 
14 0 t(U-L adv.) I 
handle next component. 
20 0 ao 
« 5 
12 0 ai 
14 0 1{U adv.) 
1 Modify second program step to handle next com-
« 6 
20 0 αϊ 
! 
ponent. Jump back to ao. 
75 0 ao 
« 7 
76 0 a 7 
STOP 
Here we have written the lower instruction under the upper. This format 
is a more convenient means of displaying groups of related instructions. 
It also provides more space for editorial comment. 
3-1.2. Prestoration, Entry Points 
If the data and parameters are stored, absolute addresses assigned, and 
the initial instruction taken from the absolute address assigned to a 0, the 
program of Example 3-6 will cause the computer to form the sum of two 
η-dimensional vectors and stop. However, this code is not acceptable. It 
preserves the data but does not preserve itself. Although the original 
data remains intact, repeating the program will not cause the vector addi-
tion to be repeated correctly because the instructions stored in registers 
a0 and αχ, and the parameter n, are changed each time the loop is traversed. 
This defect can be remedied either by restoring these quantities to their 
initial values before stopping or by prestoring them to their initial values 

92 
3. ELEMENTARY CODING 
before entering the loop. With the addition of prestoration or restoration, 
the program will perform the vector sum correctly every time the control 
is set to begin executing instructions from register a0. Without prestoration 
or restoration, the program must be reloaded before it will repeat itself. 
If a program causes the computer to carry out on the same data exactly 
the same calculation every time it is executed, its initial address will be 
called a proper entry point for the program. It is of the utmost importance 
to prepare codes with proper entry points. Such codes will prove to be 
much simpler to check out and to run. 
Of the two methods—restoration and prestoration—for providing proper 
entry points, the authors prefer the latter. One obvious reason for this 
preference is that a program which requires restoration will have to be 
completed before initial values are restored. On the other hand, a prestored 
initial setting will always be correct, even though the program has been 
interrupted. 
To provide an example of prestoration, the vector addition will be 
redone. In writing the code, we will assume that the U-L advancer, C/-ad-
vancer, and L-advancer are stored, that the integer η is stored in register 
77777, and that parameters 
P 0 = 12 
0 
00100 
14 
0 
00200 
and 
Pi = 20 
0 
00300 
12 
0 
/(index) 
are also available in storage. 
Example 3-7. We write the vector sum loop with a proper entry point. 
12 0 /(Po) 
20 0 as 
Prestore instructions to value i = 1. 
ai 
12 0 /(Pi) 
20 0 
a 2 
12 0 77777 
20 0 /(index) 
Set index to η — t + 1, i = 1. 
a 8 
12 0 00100 
14 0 00200 
Vi - A, 
(A) = Vi + Wi = Zi. 
0 4 
20 0 00300 
12 0 £(index) 
Zi -* 00300 + i - 1, index 
A. 
a 5 
15 0 l(L adv.) 
22 0 ai2 
Decrease index by one. Index = zero? 
If yes, jump to stop. 
a e 
20 0 /(index) 
12 0 a 3 
a 7 
14 0 /(C/-Ladv.) 
20 0 a 8 
* + 1 —• ι in instructions and in index; 
jump to form next component. 
aio 
12 0 
0 4 
14 0 t(U adv.) 
an 
20 0 
CH 
75 0 a 3 
ai2 
76 0 ai 2 
STOP 
ai2 
76 0 ai 2 
STOP 
an 
12 0 00100 
14 0 00200 
Po 
an 
20 0 00300 
12 0 /(index) 
Pi 
a» 
00 0 00001 
00 0 00001 
U-L adv 
aie 
00 0 00001 
00 0 00000 
C/adv 
an 
a2o 
00 0 00000 
00 0 00001 
L adv 
Index 

3-2. 
CODE ASSEMBLY 
93 
3-2. Code Assembly 
The vector addition code instructions in the form given above could not 
be transmitted directly from the storage registers of the computer to the 
Program Control Register for execution. Before this is possible, all of the 
symbolic addresses in relative and location-of form must be reduced to 
absolute machine addresses. This can be done in two stages: first the 
location-of symbols are changed to relative symbols; then a 0 is defined as 
an absolute machine address and all relative addresses are reduced to 
absolute form by the formula <*t = «ο + i. In Example 3-7, 
= 
«13 
((Pi) 
= 
«14 
t (index) = 
«20 
l(L 
adv) = 
«17 
l(U-L 
adv) = 
«15 
^(C/adv) 
= 
«16 
The absolute machine codes corresponding to both a0 
= 
00500 and 
«o = 01000 are given below. The procedure of changing from symbolic to 
machine addresses is usually called assembly. As we will see later, assembly 
is an operation which can be carried out by the computer itself when ap-
propriate format and symbolic address forms are employed in writing the 
code. 
Example 3-8. We assemble the program of Example 3-7 with absolute 
addresses assigned as shown: 
« 0 = 00500 
= 01000 
00500 
12 0 00513 
20 0 00503 
01000 
12 0 01013 
20 0 01003 
00501 
12 0 00514 
20 0 00504 
01001 
12 0 01014 
20 0 01004 
00502 
12 0 77777 
20 0 00520 
01002 
12 0 77777 
20 0 01020 
00503 
12 0 00100 
14 0 00200 
01003 
12 0 00100 
14 0 00200 
00504 
20 0 00300 
12 0 00520 
01004 
20 0 00300 
12 0 01020 
00505 
15 0 00517 
22 0 00512 
01005 
15 0 01017 
22 0 01012 
00506 
20 0 00520 
12 0 00503 
01006 
20 0 01020 
12 0 01003 
00507 
14 0 00515 
20 0 00503 
01007 
14 0 01015 
20 0 01003 
00510 
12 0 00504 
14 0 00516 
01010 
12 0 01004 
14 0 01016 
00511 
20 0 00504 
75 0 00503 
01011 
20 0 01004 
75 0 01003 
00512 
76 0 00512 
01012 
76 0 01012 
00513 
12 0 00100 
14 0 00200 
01013 
12 0 00100 
14 0 00200 
00514 
20 0 00300 
12 0 00520 
01014 
20 0 00300 
12 0 01020 
00515 
00 0 00001 
00 0 00001 
01015 
00 0 00001 
00 0 00001 
00516 
00 0 00001 
00 0 00000 
01016 
00 0 00001 
00 0 00000 
00517 
00 0 00000 
00 0 00001 
01017 
00 0 00000 
00 0 00001 
00520 
01020 

94 
3. ELEMENTARY CODING 
We notice immediately that the vector addition code with entry point 
at 00500 is different from the one with entry point 01000. This illustrates 
a cardinal point—a code is a function 
of its operating locations and 
assumes, 
in general, different forms in different operating locations. Thus an item of 
coding, operating in certain fixed registers, cannot be arbitrarily copied 
into other registers and then be expected to function correctly. In general, 
modifications of the code will be necessary. We will discuss computer 
programs designed to assist the coder to carry out such modifications in 
later chapters. 
3-3. Code Editing 
The final version of the vector addition program turns out to be a fairly 
large array of octal digits. Checking out the program, or simply reviewing 
it, at some later date may prove troublesome without the addition of 
editorial comments designed to emphasize its most important features and 
point out the places at which difficulties may arise. 
Since the loop is the basic element of most codes, editorial notation 
should make all loops easy to pick out of the array of digits. A common 
practice is to enclose the addresses of the loop and their initial content in 
parentheses such as 
If there are a large number of loops or loops within loops, double and 
triple parentheses or numbered parentheses such as 
j 
or 
or 

3-3. 
CODE EDITING 
95 
may be helpful. Every loop, of course, must have an exit. It will furnish 
both a check on the coding and an aid in reconstructing the function of the 
loop to provide a suitable exit indication in the margin opposite the exit 
instruction. Certain ones of the instructions within the registers of the 
loop will require prestoration. These are the most important instructions 
in the loop, and editorial comment should bring them to attention. 
One way to focus attention on such instructions is to underline all addresses 
of loop registers which contain them. The changing portions of the instruc-
tion should be distinguished from the constant portions. This can be done 
by enclosing the varying part in parentheses. In addition to the prestora-
tion references, there will usually be modification references to the pre-
stored instructions. These references should be editorially emphasized 
by some device such as underlining the address of the register containing 
the prestored instruction whenever this address appears within modifica-
tion and prestoration instructions. Finally, it will be helpful to emphasize 
all conditional jumps by underlining, and to point out entry points by 
marginal notations. 
As an example, the type of editorial comment just suggested will be 
added to the absolute machine code for vector addition. The comments 
to the right in Example 3-9 are intended to explain the editorial notation. 
It must be emphasized that the editorial notations are merely for the 
coder's convenience and are completely external. Only the actual instruc-
tions are to be placed in the storage registers of the computer. 
Example 3-9. We give an edited version of the code in Example 3-8. 
ENTRY POINT 01000 
12 0 01013 
20 0 01003 
Prestoration reference 
01001 
12 0 01014 
20 0 01004 
Prestoration reference 
01002 
12 0 77777 
20 0 01020 
|01003 
12 0 [00100] 
14 0 [00200] 
Prestored instruction, 
initiate loop 
01004 
20 0 [00300] 
12 0 01020 
Prestored instruction 
LOOP EXIT 
01005 
15 0 01017 
22 0 01012 
Conditional jump 
01006 
20 0 01020 
12 0 01003 
Modification reference 
01007 
14 0 01015 
20 0 01003 
Modification reference 
01010 
12 0 01004 
14 0 01016 
Modification reference 
01011 
20 0 01004 
75 0 01003 1 
Modification reference 
01003 1 
close loop 
01012 
76 0 01012 
— 
01013 
12 0 00100 
14 0 00200 
01014 
20 0 00300 
12 0 01020 
01015 
00 0 00001 
00 0 00001 
01016 
00 0 00001 
00 0 00000 
01017 
00 0 00000 
00 0 00001 
01020 

96 
3. ELEMENTARY CODING 
3-4. Flow Charts 
The coder should not blindly set out to write a program without working 
out a precise plan of attack beforehand. This, of course, may be set down in 
any manner as long as it is comprehensible and legible. A very useful device 
for laying out the computational plan is the flow chart, which presents a 
schematic representation of the computing operations and decisions and 
of their sequencing. The flow chart has been referred to as the "road m a p " 
of a computation. 
Flow charts can be constructed with widely varying degrees of complexity 
and elaboration of detail. In general, it is better for the initial flow chart 
from which the coder works to be relatively simple and straightforward. 
Much valuable time can be wasted in constructing an overly detailed flow 
chart for a code, only to find that changes must be made and the chart 
completely redone. However, a detailed flow chart for a program which 
has already been completed and machine checked is a great aid in re-
activating the program, if it has been dormant for a time, or if it is used by 
someone other than the original coder. 
We will confine ourselves here to the construction of the most elementary 
kinds of flow charts. The following symbols will be used: 
(1) Operation Box. The operation box is a rectangular figure. It can be 
of any convenient size. Inside the box the coder will write a description of 
some particular operation or operations which the program is to carry 
out at a given point of the computation. For example, 
1 
k
2 
Form yi ^ - (y^ 
+ y^) 
- 
- (yi+1 
+ 
y^t) 
is an operation box which might appear in a flow chart outlining the 
integration of a second order differential equation. 
(2) Decision Box. The decision box is an oval shaped figure of any con-
venient size. It is used to indicate points in the program at which a choice 
between two alternative routes of computational flow is to be made. The 
decision is usually phrased in terms of a question which is to be answered 
in a yes or no manner. The coder will indicate the question by writing in 
the box. Two arrows, one labeled "yes" and the other "no," will emerge 
from the decision box to indicate the path to be followed in each case. 
For example, the decision box 

3-4. 
FLOW CHARTS 
97 
ç i > n? y 
YET 
N O 
might be placed at a point in the program at which it is necessary to decide 
whether or not a certain operation has been completed for all admissible 
values of an index. 
(3) Connectors. A connector is a circular figure of any convenient size. 
It is used for the purpose of attaching a label to a point in the diagram so 
that it can be referred to in a simple way. The device of considering all 
connectors with the same label to define the same point in the flow chart 
enables the coder to simplify the "topology" of a flow chart and, par-
ticularly, to avoid the necessity of drawing tortuous arrows through a 
confusing maze of boxes and connections. The following are some typical 
examples of connectors, 
(4) Subroutines. 
The coder often will wish to indicate that a subroutine 
is to be executed without giving the specific subroutine flow details which 
may, perhaps, be set down elsewhere in a dictionary of library subroutines. 
In this case, a diamond shaped figure with the name of the subroutine 
written inside will be utilized. For example, the symbol 
indicates that a square root subroutine is to occur at this point in the code. 
The basic concepts relating to subroutines and their use will be found in a 
later chapter. The symbolism is included here for the sake of completeness. 
When the code is completed, the coder should go back to the flow chart 
and fill in above each box the address of the register containing the first 
instruction of the group of instructions which carry out the function defined 
in that box. This increases the effectiveness of the chart as a code checking 
aid and as a record of the program. 

98 
3. ELEMENTARY CODING 
Example 3-10. We give a flow chart for the vector addition program as an 
example. 
( é > 
(Β) 
i + 1 —* i in 
index and instructions 
« 0 
« 2 
Prestore 
instructions to 
i = 1 
Set index to 
n — i' + 1, i = 1 
Prestore 
instructions to 
i = 1 
Set index to 
n — i' + 1, i = 1 
H 
«3 
« 4 
) 
Form 
Decrease 
/ 
Zi = Vi + Wi 
index 
• 0 
«5 
Index = 0? 
STOP 
® 
3-5. Timing the Code 
It is often useful to get a rough estimate of the amount of time a coded 
problem will take before it is actually run in the computing machine. For 
this purpose, average times for the execution of the CDC 1604 instructions 
are given in the appendix. 
In timing a loop, some estimate must be made of the number of times 
the loop will be traversed. This number is then multiplied by the operation 
time needed to go through the loop once. In the case of a loop within a 
loop, the time must be estimated beginning with the "inside" loop first. 
Example 3-11. We wish to estimate the computing time for the vector 
sum code of Example 3-8 for a0 = 01000. Within the registers of the loop, 
which consists of the addresses 01003 to 01011 inclusive, we have four 
load-Α, three add, one subtract, four store-Α, one A jump, and one selec-
tive jump instructions for a total average computing time of 101 /xsec. 
Thus, the total average time for the loop is 101 η /isec. To this we must 
add the time for prestoration, program steps 01000 to 01002, which is 
43 ßsec. Hence, the total average running time for the code is (43 + 101η) X 
10~
6 sec. For the largest admissible η = 64, the total average running time 
is .0065 sec. 
3-6. Indexing 
In the examples of coding given above, we modified instructions by 
means of a set of constant parameters, namely, the U, L, and C/-L advancers. 
Each of these parameters can be used to increase or decrease the address 
parts of a program step by one. Of course, any other incrementation or 

3-6. 
INDEXING 
99 
decrementation constants appropriate to a particular situation can be 
introduced and utilized in a similar way. In this technique of address 
modification, we see that, although the modified remains constant, the 
digits in storage representing the instruction change after each modification. 
As we have seen, this requires us either to prestore or restore the modified 
instruction. Another drawback of this kind of instruction modification 
technique is that it requires the use of the accumulator for housekeeping 
arithmetic. This imposes an added burden on the busy accumulator and 
frequently interferes with the essential problem arithmetic. The additional 
housekeeping instructions required make the code cumbersome 
and 
lengthy. Accordingly, we seek a method of address modification which 
will minimize prestoration or restoration of program steps and extend the 
capability of our computing equipment by not .disturbing the flow of the 
problem arithmetic being handled in the accumulator. This leads us to the 
introduction of index 
registers and computer instructions for working 
with such registers. These will be discussed in the remainder of this chapter 
and appropriate techniques for illustrating their use will be demonstrated. 
We recall from Chapter 2 that the CDC 1604 computer has six actual 
index registers, called B
b, b = 1, 2, · · ·, 6, and one imaginary index register 
B°, which is understood to be such that (B°) = 0 at all times. We recall 
also that in instructions where it is appropriate to utilize the symbol b 
for the designator the effective address is given by 
effective address = base address + (B
b) ; 
and that the computation of the effective address is carried out away 
from the accumulator by means of the registers R and U
2. Thus, assuming 
the availability of instructions which will enable us to assign initial values 
to and modify the content of index registers without using the accumulator, 
we can carry out address modification without disturbing the flow of the 
problem arithmetic and without altering the coded instruction in the 
storage register. To do this, we hold the instruction in storage constant 
and modify the modifiers, that is, the content of the index registers. Since 
index register modification and computation of the effective address is 
carried out in R and U
2, the accumulator is free to carry out the essential 
arithmetic of a problem. This reverses the earlier procedure of modifying 
the instruction in storage and holding the modifier constant. 
Example 3-12. (B
l) 
= 00001, (B
2) 
= 77775. What occurs if we execute 
the pair of instructions 
12 
1 
01000, 
14 
2 
01000? 
Because of address modification the computer will form in A the sum 
(01001) + (00776). This occurs because the effective addresses are, for U, 
01000 + 1 = 01001 

100 
3. ELEMENTARY CODING 
and for L, 
01000 + 77775 = 01000 - 
(00002) = 00776. 
Note that without indexing, 
we would have 
12 
0 
01000, 
14 
0 
01000 
giving us 2(01000) in A. 
Because the effective address is computed in the control registers from a 
copy of the instruction taken from storage, the stored copy is unchanged. 
Hence, prestoration or restoration is unnecessary although we will see 
that a form of restoration is inherent in some instructions governing the 
use of index registers. Prestoration with index registers is ordinarily simpler 
to carry out than prestoration of instructions, since, frequently, 
the 
content of a single index register can be used to modify more than one 
instruction, as well as to count loop traversais. We have assumed that the 
instructions which increment or decrement the content of index registers 
do not make use of the accumulator. By also using index registers to carry 
out any counting necessary to perform the exits from loops, we can relieve 
the accumulator of its last housekeeping function, leaving it completely 
free to carry out the problem arithmetic unhindered. 
3-0.0. Index Instructions 
Before turning to examples of the use of index registers, that is, indexing, 
we must first introduce the index instructions whose existence we assumed 
above. The reader should at this point consult the appendix and study the 
following instructions. 
Instruction 
Operation code 
Instruction 
Operation code 
Enter index 
50 
Index skip 
54 
Increase index 
51 
Index jump 
55 
Load index U 
52 
Store index U 
56 
Load index L 
53 
Store index L 
57 
Since the technique of address modification now requires the prestoration 
of the content of an index register, we must have instructions available 
for this purpose. The two load index instructions carry out this prestoration 
using the content of the storage registers referenced by their address parts. 
The enter index instruction carries out this prestoration directly from the 
value y, stored within the instruction itself. Since (B°) is always zero by 
definition, it is unnecessary to prestore (B°). Therefore the load and enter 
index instructions with b = 0 are treated by the control as "do-nothing" 
instructions. 
The 
do-nothing 
or pass instruction 
normally 
used 
is 
50 
0 
00000. 

3-6. 
INDEXING 
101 
Example 3-13. We wish to perform the pair of instructions 
12 
0 
ßi 
20 
0 
di, 
i = 0, 1, · · · , 77 (octal) 
to transmit a block of information. We propose to do this by indexing 
and decreasing the content of an index register one step at a time. To 
load the index we use 
50 
1 
00077 
and the pair, 12 
1 
ß0 
20 
1 
δ 0 as the equivalent of the above. 
At the outset this will be the equivalent of 12 
0 
βπ 
20 
0 
δ1Ί, 
and if we successively decrease (B
1) by one it will become, in turn, equiva-
lent to 
12 
0 
ßn 
20 
0 
δ 7 β 
12 
0 
076 
20 
0 
δη 
Note that the original pair of instructions is not modified, but remains 
12 
1 
β0 
20 
1 
δ0. Note also that the final 15 bits in the 50 
1 
00077 
instruction are not used as an address, but as an operand. 
The prestoration of the content of an index register will cause its initial 
content to be destroyed. If we wish to preserve the initial content of the 
index register, we must transfer it to another index register or to a storage 
register. Since the preservation of this initial content is usually forced upon 
us by the fact that the number of index registers is limited and, hence, 
that we will often need to use all index registers for several different pur-
poses, we will ordinarily save the initial content in a storage register. 
This facility is provided by the store index instructions. Since (B°) = 0, 
b = 0 in these instructions will cause the storage of the value zero. The 
store index instructions do not alter the operation code and designator 
parts of instructions into whose address parts they copy the index value. 
This permits us also to store the content of an index register for use as a 
new base address in an instruction. 
An index register to index register transmission can be carried out by 
means of an appropriate combination of the store index and load index or 
enter index instructions. 
Since we now propose to modify addresses by changing the value which 
we add to the base address rather than by changing the base address itself, 
we must, of course, have instructions to alter the index register content. 
The index skip, index jump, and increase index instructions serve this 
purpose. Because we usually take pains to store the data in sequentially 
addressed registers, the most frequently desired modification of an index 
will be a unit incrementation or decrementation. The index skip provides 
for the first alternative and the index jump for the second. 
Example 3-14. We conclude the problem of Example 3-13. The block 
of data stored at β0) ßi, ···, 
ßn is to be transmitted into locations δ0, 

102 
3. ELEMENTARY CODING 
δι, "', 
δηΊ. We form a loop and an exit by means of an index jump. We 
start at ao. 
50 
1 00077 
50 2 00077 
Set (ß
1) = 77, set (Β
2) = 77 
12 1 
20 
1 δο 
(ß%) -> δ», i = 77 initially 
« 2 
51 
1 77776 
55 2 αϊ 
Decrease (ß
1) by one. (&) = 0? STOP. If 
reloop. 
« 3 
76 0 
« 3 
STOP 
In order to illustrate several index instructions we have used some 
unnecessary steps. For example, the decreasing of (B
1) by the 51 
1 
77776 
instruction is unnecessary. The computer performs this automatically in 
the 55 index jump. Furthermore, we could use the same index register 
to count and to decrease address. That is, we could use 
ao 
ai 
a 2 
50 
1 00077 
50 0 00000 
12 1 
ft 
20 
1 
do 
55 2 ai 
76 0 
a 2 
(B
1) = 77. 
PASS 
(ßi) -* «< 
Through? STOP. If not, reloop 
At times we may wish to select a subset from a sequence of data items 
in some regular manner, for example, every nth item, or we may merely 
wish to skip over a certain amount of data before starting or resuming a 
sequential data scan. In such cases, we will want to alter our address, and 
hence, our index, by a value different from one. We can do this by means 
of the increase index instruction. Although the instruction is named 
increase index, it can also be used to decrease the index. Since the index 
modification is carried out in one's complement arithmetic modulo 2
1 5 — 1, 
if the index is 77772 and we wish to decrement it by 2, we set y = com-
plement [00002] = 77775 in the increase index instruction. The effect 
is as follows: 
77772 
+77775 
End around carry 
77767 
+ 1 
77770 
The skip and jump features of the index jump and skip operations give us 
a means for utilizing the index value as both a modifier and an exit count. 
We note that they also provide a certain type of restoration in that the 
index register referenced will always have its content set to zero when the 
skip is taken or jump is not. The fact that by definition (B°) is always zero 
introduces certain idiosyncrasies into the use of the index jump, index 
skip, and increase index to modify the content of (B°). The precise results 
of choosing 6 = 0 are given in Appendix A. 

3-6. 
INDEXING 
103 
We must remember that we cannot "index" the indexing instructions. 
That is, the content of the index register B
h, referred to by the designator 
b of an indexing instruction, is never used to modify the base address of 
that instruction. Thus, for indexing instructions, the base address and 
effective address are always equal. Finally, indirect addressing, that is, 
the case 6 = 7, applies to indexing instructions in the same way as it 
does to other classes of instructions. 
3-0.1. Examples of Indexing 
For the first examples of the indexing technique of looping and address 
modification we will redo the vector sum problem of Section 3-1. All of the 
previous assumptions will be retained. We will assume the parameter η 
specifying the number of components in the vector table to be in the lower 
address part of register 77777. 
Example 3-15. The code for a vector sum, with indexing, follows: 
EXIT |"ϊ 
50 0 00000 
Do nothing. 
53 
1 77777 
Set (B
l) = n. 
55 
1 
« 2 
If (Β
1) 
0, decrement, jump to as. 
76 0 
« 1 
STOP 
12 1 00100 
Vi —» A, 
i = η, η — 1, ·*·,1. 
14 1 00200 
(il) = Vi + Wi = Zi, 
i = η,η 
-
20 1 00300 
Store Zi, 
i — η, η — 1, · · · , 1. 
75 0 
Oil 
Close loop. 1 
In Example 3-15, the upper instruction of the program step located at 
«o is a do-nothing designed to locate the index jump instruction at αχ in the 
upper part of its program step. We do this because the loop is closed with 
an unconditional jump at a 3 which gives control to the upper instruction 
at the jump address. Placing the index jump in the lower part of its pro-
gram step would require the execution of a do-nothing η times within 
the loop. 
Only the content of index register B
1 needs to be prestored before the 
loop is entered. This single prestoration replaces the prestoration of the 
count and the address parts of three instructions required by the previous 
technique of looping and address modification. Since the index is auto-
matically decremented by unity, we do not need to store various advancer 
parameters as in the previous codes. The effect of this is to give an average 
running time of (19.2 + 26η) Msec, about one fourth the time for the 
preceding code. 
The index jump operates so that the vector components are handled in 
the order η, η — 1, · · ·, 1. This makes no difference in the final result. 

104 
3. ELEMENTARY CODING 
If we wish to handle the components in the order 1, 2, · · ·, n, we can, of 
course, reverse the order in which components are stored, or, as we shall 
see below, use the index skip. 
In Example 3-15, the index jump is placed at the beginning of the loop. 
It may also be placed at the end of the loop. However, in this case, we must 
decrease the initial value of the index by one to account for the fact that 
one traversal of the loop will have occurred before the index test. 
Example 3-16. The following code is an example of the vector addition 
program with the index jump at the end of the loop. We assume n ^ O . 
« 0 
53 1 77777 
Set (B
l) = n. 
55 
1 
(Β
1) = η - 1. 
αϊ 
12 1 00100 
Vi - 
Α. 
14 1 00200 
(A) = Vi + Wi = Zi, 
i = η, η - 1, 
1 
« 2 
20 1 00300 
Store Zi. 
55 
1 
If (B
1) 
0, decrement, jump to αι. 
at 
76 0 ctz 
STOP 
In the code of Example 3-16, we have used the index jump in step a 0 to 
decrement the index value by one. This is in line with the policy of trans-
ferring as much of the housekeeping arithmetic as possible out of the 
accumulator. For more complicated operations on index values we may 
still have to use the conventional arithmetic registers. 
Example 3-17. To conclude the vector addition problem, we will code 
it using the index skip instruction to provide a means of counting and to 
exit from the loop. 
53 1 77777 
(£') = n. 
56 1 
Set η into index skip instruction 
ai 
50 2 00000 
(B
2) - 0. 
50 0 00000 
PASS. 
a 2 
12 2 00100 
Vi -> A. 
14 2 00200 
Vi + Wi = Zi -> A. 
a 8 
20 2 00000 
Store Zi. 
50 0 00000 
PASS. 
*4 
54 2 00000 
If t < n, % + 1 replaces i; 
if i 
75 0 a 2 
Reloop if necessary. 
«· 
76 0 
Stop when through. 
— -

3-6. 
INDEXING 
105 
When we use the index skip, we must set the parameter η into the y 
part of the index skip instruction itself rather than into an index register. 
In Example 3-17, we accomplish this in the first program step at a 0, where 
index register B
l has been used as a transit register. When we used the 
index jump, we decremented the value η to zero in an index register. 
The index skip reverses this process and increments the initial value in an 
index register to n. Because of this, the sequence of modified addresses 
will also be reversed. Accordingly, the components Z . will be computed in 
the normal order i = 1, 2, · · · , n. This requires that the initial count 
in the referenced index register be set to zero before the loop is entered. 
We take care of this in the upper instruction of program step αι. The use 
of index register B
2 to hold the count is arbitrary. Index register B
1 is 
free at this point and should be used for the sake of efficiency. 
In the Example 3-17, the index skip is at the end of the loop. It could 
have been placed at the beginning of the loop. In this case, however, it will 
be necessary to decrease the base addresses by one, since the modifier is 
incremented before executing the loop. We illustrate this in Example 3-18. 
Example 3-18. 
53 
1 
77777 
= η. 
56 
1 a 2 
Set η into index skip instruction. 
ai 
50 
1 
00000 
m 
= ο. 
50 
0 
00000 
PASS. 
a 2 
54 
1 
00000 
If i < n , i + 1 replaces i, i = n , close loop. 
75 
0 
Compute Z<. 
az 
76 
0 
a 0 
STOP if through. 
00 
0 
00000 
a 4 
12 
1 
00077 
14 
1 
00177 
Vi + Wi = Zi - A. 
a 5 
20 
1 
00277 
Store Zi. 
75 
0 
a 2 
Reloop to test. 
On occasion we will find that it is not possible to carry out all of our 
housekeeping arithmetic in the index registers and that the accumulator 
must be used for this purpose. The results of such computations will often 
have to be placed in the address parts of instructions or in index registers, 
while the C D C 1604 does not provide for direct transmission from the 
accumulator to an index register, it does provide for direct transmission 
from the low order 15 bits of the accumulator to the upper or lower address 
part of a storage word. This transmission is carried out without disturbing 

106 
3. ELEMENTARY CODING 
any of the other bits in the storage word. The instructions which effect the 
transmission are: 
Instruction 
Operation code 
Substitute address upper 
60 
Substitute address lower 
61 
The substitute address instruction combined with the load index instruc-
tion can be used to carry out a transfer of information from the accumulator 
to an index register. 
Example 3-19. We wish to transfer the 15 low order bits of (A) into index 
register B
1. We can use a temporary storage address, a, and either of the 
program steps 
60 
0 
α 
52 
1 
α 
or 
61 
0 
α 
53 
1 
α 
The only difference is the portion of register α which temporarily holds the 
15 bits. 
Example 3-20. We wish to prestore (or restore) initial values of U and 
L in a program step which is to be modified in a program. The instructions 
are at a 0 and the initial values are U = 00100 and L = 00200. We can 
use the following: 
10 
0 
00100 
61 
0 
ao 
set initial L 
10 
0 
00200 
60 
0 
ao 
set initial U 
3-6.2. Editing with Index Instructions 
The previous remarks on editing are still applicable. However, the new 
technique of address modification will make the necessity for pointing out 
parts of instructions which change, and indicating prestoration and modifi-
cation references relatively infrequent. On the other hand, the index skip 
will frequently require a prestoration. This is because the y part, repre-
senting a count, will often not be known in advance, but will be determined 
from input parameters or computed parameters. This prestoration can be 
pointed out in the usual way by underscoring the prestoration reference, 
56 
1 
a3, underscoring the address, and indicating by parenthesis that 
the y part must be prestored. For example, we can write 56 
1 
oj 
and 
os H 54 
2 
[00000]. 
The use of the index jump will usually require the prestoration of the 
content of the index register referenced by the jump. We can edit this by 

3-7. 
NONUNIT INCREMENTATION; INNER LOOPS 
107 
underscoring the designator parts of both the index jump and the instruc-
tion to carry out the prestoration. For example, we can write 
53 
1 
77777 
55 
1 
ax 
It may also be helpful to indicate that the prestoration operation and 
index jump are associated with a particular loop. In this case, double or 
triple underscoring in correspondence to double or triple loop parentheses 
may prove to be of value. The artistically inclined coder may use colors. 
3-7. Nonunit Incrementation; Inner Loops 
In the previous sections we have introduced two basic concepts used in 
programming. The first of these is the modification of addresses in order 
to use a small set of prototype instructions to perform a large number of 
essentially similar operations. The second basic concept is the iterative 
loop, which provides the means of reusing the prototype instructions in 
suitably modified form. For simplicity we have considered only programs 
which contain a single loop, and examples in which unit incrementation or 
decrementation of addresses is required. With more complex problems 
to be solved, however, it is apparent that many loops will be required, 
and these may well involve loops contained within other loops. While it is 
probably true that unit address modification is the kind most frequently 
required, there are a number of situations in which incrementation by 
amounts different from one may be needed. In the following examples, we 
will illustrate both an inner loop and nonunit incrementation. 
Example 3-21. Suppose we are writing a program dealing with η Χ η 
square matrices, and at some point we wish to form the transpose of a 
matrix; that is, for the 
matrix = 
we wish to form the 
transpose = 
«11, 
«12, 
« l n 
«21, 
«22, 
· , 
«2n 
«nl, 
«n2, 
*, 
OLnn 
«11, 
«21, 
#, 
« n l 
«12, 
«22, 
*, 
«n2 
«ln, 
«2n, 
* * ·, 
OLnn 

108 
3. ELEMENTARY CODING 
We see that the transpose is formed by interchange of rows and columns. 
The method we use will depend on the particular manner we choose to 
store the matrix. We assume here that storage is by rows in consecutively 
addressed registers, with 
«11, 
«12, "',Οίΐη 
in 
βο, 
βι,···,βη-χ 
«21, 
«22, · ' · , « 2 η 
Hl 
ßn, 
ßn+1, ' ' *, 
ftn-l 
«nl, 
«n2, ·
β
,, « η η 
in 
ß(n-l)-n, " ' , ßn-n-1 
Our object now is to convert each column to a row with the same kind of 
storage in registers addressed by δ; that is, we wish to put 
« i i , 
«2i, * · · , « n i 
in 
δο, 
δι, · · ·, δ η-ι 
«12, 
«22, * · · , « η 2 
in 
δ η, 
δ η+1, ' * ', Ô2n-1 
«1η, 
«2η, · ' · , « η η 
ΠΙ 
δ( η_ΐ). η, 
·
β· , δ η. η - 1 
Stated in terms of indices, we see that the element α»·,·, which is originally 
stored at 
ß(»-l)-n+(j-l) 
will go to 
δ ( ; - ΐ ) + ο - ΐ ) · η 
where it will be equivalent to a'a of the transpose, where a'a = 
aH. 
For each column j , of the matrix, we pick out the elements in registers 
ßo+O-l), 
ßn+U-D> 
' ") 
ßn(n-l)+(j-l) 
and place them, respectively, in consecutive registers 
δθ+0-1).η, 
δΐ +(,_ΐ)η, 
' * · , δ η- 1 + ( , - l ) n 
For example, for the first column,; = 1, and 
( f t ) , 
(ßn), 
· · ' , 
(jS(n-l).n) 
gO to 
δ0, 
δι, · · · , « „ _ ! 
For each column, therefore, we form an inner loop which extracts every 
nth item, starting from the first in the column, from the β group and 
transfers each in turn to consecutive locations in the δ group. We then 
form an outer loop which will take care of each column in order. The flow 
chart follows, with some prestoration items included. 

3-7. 
NONUNIT INCREMENTATION; INNER LOOPS 
109 
Set column counter 
to η and set column 
valued = 1, initially 
Set row counter 
to η and row value 
i = 1, initially 
Store (0 ( t-_i). n+ (y_i)) 
at Ô(t_i)+ (y_i).n 
i = n? 
j = n? 
No 
No 
Reloop 
(inner) 
Increase i by one 
Reloop 
(outer) 
Increase j by one 
EXIT 

110 
3. ELEMENTARY CODING 
We see that two loops are formed. The inner loop is one which will 
select every n t h item from the β range and store the results consecutively 
in the δ range, beginning with the proper β and δ values specified by the 
outer loop. The outer loop accounts for one column at a time and we 
arrange instructions so that each time we enter the inner loop, column 
by column, the row counters are properly reset and initial values are preset. 
The selection of every nth item entails incrementation of β addresses by n. 
Example 3-22. We write a code corresponding to the flow chart of 
Example 3-21. 
Of0 
50 
1 00 
Preset address for an in matrix. 
50 
2 δο 
Preset address for an in transpose. 
« 1 
50 3 
η 
Set column [ j ] counter. 
f. 
50 0 00000 
Do nothing. 
55 
3 ocz 
Count columns. If not through, reloop. 
76 0 α 0 
If through, EXIT. 
« 3 
56 
1 
« 6 
Set /S(/_i)+(t_i)n. Start i = j = 1. 
57 
2 
«β 
Set |8o_i)„+(t_i). Start i = j = 1. 
CtA 
50 4 0 
Set increment η index to zero. 
50 5 0 
Set increment 1 index to zero. 
a6 
50 6 η 
Set row [ i ] counter. 
|ö7 
55 
6 
« 6 
η becomes η — 1. 
|ö7 12 4 Ü8CM>+(. - 1 ) η ] 
(/3o-i)+<i-i>.n) - » A. Start i = j = 1. 
20 
5 
[ δ ( ; - ΐ ) . η + « - ΐ ) ] 
(A) —• 5 (y_i).„ + t_i. Start i = j = 1. 
51 
4 
η 
Increase £
4 by n.l 
j n c r e a s
e ^ D χ 
Increase B
B by l.J 
51 
5 
1 
J 
Increase £
4 by n.l 
j n c r e a s
e ^ D χ 
Increase B
B by l.J 
<XlO 
55 
6 
αβ 
J 
Count rows. If through, go to next column. If not, reloop. 
an 
51 
51 
1 
2 
1 
η 
J 
Increase B
1 by l\ 
T 
., 
i 
τ 
r» u 
f Increase; by 1. 
Increase Β
1 by nj 
75 0 
« 2 
J 
Reloop if necessary. 
We have been profligate with our use of index registers in order to empha-
size the problem of incrementing by n. It is easily seen that, since all 
incrementation in the δ region of addresses is by one, we could avoid the 
use of B
2 and the lower program step at a i 0. Many other improvements in 
efficiency are possible and we suggest that each reader attempt to provide 
his own. 
Exercises 
All specific computer instructions and contents refer to the CDC 1604. 
Section 3-0 
1. 
(Ai) = 1234 5676 5432 1234; (00100)i = 1111 1111 1111 1111, 
and (00200) T = 1020 3040 5060 7060. The computer accepts the 

EXERCISES 
111 
01000 
01001 
12 
0 
00200 
14 
0 
00100 
20 
0 
00200 
if the computer starts at 01000? From where will the computer 
accept its next instruction? 
With the same initial content as given in Problem 1, what are 
(A)F} 
(00100) F, and (00200) F immediately after the following four in-
structions: 
01000 
01001 
12 
0 
00200 
15 
0 
00200 
20 
0 
00100 
22 
0 
02000 
if the computer starts at 01000? From where will the computer 
accept its next instruction? 
Repeat Problem 3 if the four instructions are 
12 
0 
00200 
15 
0 
00100 
01000 
01001 
20 
0 
00100 
22 
0 
02000 
5 . 
What is the net effect of the execution of the four instructions 
12 
0 
00100 
15 
0 
00100 
15 
0 
00100 
20 
0 
00100 
in order? 
6. 
Suppose we wish to form and store (00100) + (00200). What are the 
drawbacks in achieving the result by the use of the instructions 
12 
0 
00100 
14 
0 
00200 
20 
0 
00100? 
following two instructions, stored at 01000, 
12 
0 
00200 
14 
0 
00100 
Give, immediately after 
completion, 
(A)F, 
(00100) F, 
(00200) F. 
From where will the computer accept its next instruction? 
2. 
With the same initial content as given in Problem 1, what are 
(A)F, 
(00100) F, and (00200) F immediately after the following three in-
structions: 
3 . 
4. 

112 
3. ELEMENTARY CODING 
7. 
Write a sequential set of upper and lower instructions, stored con-
secutively starting at 01000, which will: 
(a) form (00100) + 
(00200) in A and take the next instruction 
from 01001. 
(b) form (00100) + 
(00200) in A and take the next instruction 
from 02000. 
(c) form (00100) + 
(00200) in A and take the next instruction 
from 02000 only if (00100) + (00200) = 0. 
8. 
Write a sequence of instructions which will cause the computer to 
test the equality of (00100) and (00200) and take its next instruc-
tion from 02000 if they are equal, but from 03000 if they are unequal. 
9. 
(00100) = 3777 7777 7777 7777 and (00200) = 0000 0000 0000 0002. 
What error is produced with the sequence of instructions 
12 
0 
00100 
14 
0 
00200 
20 
0 
00300? 
10. 
Write a sequence of instructions which will form (00100) — (00200) 
and store it at 00300, and which will also restore the original content 
of il. 
Section 3-1 
11 
12. 
13. 
Use no jump instructions and write the codes for the vector sum of 
Section 3-1 for values of η = 3, 4, 7 and 10. 
A set of integers a», | a* | < 2
4 7, is stored consecutively at locations 
00100 + i - 
1, with i = 1, 2, · · ·, n. We assume 
< 2« 
Write a sequence of instructions which will form 
η 
a,i in 
A 
t=l 
for values of η = 2, 3, 4, 5, and 10. Use no jump instructions and 
start instructions at 01000. 
The number one is stored at location 03333. Write a set of instructions 
starting at 01000 which will form the consecutive integers i = 1, 
2, · · ·, η and store them consecutively at locations 00100 + i — 1, 

EXERCISES 
113 
1 < i < n, for values of n = 2, 3, 4, 5, and 10. Use no jump instruc-
tions. What are the limitations on n for the way in which the programs 
are written? 
14. 
Repeat Problem 13 for the even integers 2, 4, · · ·, 2n. 
15. 
Repeat Problem 13 for the odd integers 1, 3, 5, · · ·, 2n — 1. 
Section 3-1.0 
16. 
By means of editorial comment in the column to the right, explain 
the meaning of the following, if the computer starts at aQ: 
Address 
U 
L 
(a) 
12 0 ßo 
14 0 AD 
ai 
20 0 ßo 
76 0 ai 
(b) 
ao 
12 0 ßo 
15 0 βι 
ai 
22 0 a 2 
76 0 
Oil 
a 2 
20 0 ft 
76 0 a 2 
(c) 
ao 
12 0 AD 
14 0 a 2 
ai 
20 0 a 2 
12 0 00 
a 2 
14 0 ßl 
20 0 ßl 
as 
76 0 a 3 
In each case determine what actually occurs. 
17. 
Write the final set of instructions obtained for each part of Problem 
16 if the following assignments of symbolic and absolute addresses 
are made: 
(a) / ( l ) = a2, βο = α*, and a0 = 00100. 
(b) ßo = 00100, ao = 01000, and ß0 = ah a0 = 01000. 
(c) / ( l ) = α 4, βο = α 6, and a0 = 01011. 
18. 
Do Problem 12 using symbolic addresses with instructions starting 
at ao and storage starting at βο. 
19. 
Do Problem 12 using symbolic addresses with instructions starting 
at a 0 and with location of addresses for the at-. 
20. 
In Problems 18 and 19, what additional assignments to the symbolic 
addresses are required to put the programs in the original absolute 
form? 

114 
3. ELEMENTARY CODING 
Section 3-1.1 
2 1 . 
A set of three program steps is stored consecutively at α3·, 
ccj+2. Write a set of instructions to precede these so that when the 
control reaches α,·, the current values of (ay), ( a J + i) 
and 
(α,·+2) 
will be such that U is increased by one in ( a 3) , L is decreased by one 
in (α,·+ι), and U and L are both increased by one in (α 3·+ 2). 
22. 
Redo Problem 12 using an iterative loop with no exit. 
23. 
Redo Problem 13 using an iterative loop with no exit. 
24. 
Redo Problem 23 for even and then for odd integers. 
25. 
Redo Problems 22, 23, and 24, using an iterative loop with an exit 
based on an A jump. 
Section 3-1.2 
26. 
Redo Problems 22, 23, 24, and 25, to provide proper entry points. 
Section 3-2 
27. 
Write an assembled form for the programs of Problem 26 with at 
least three different assignments of absolute addresses. Compare 
the results. 
Section 3-3 
28. 
Edit each of the programs of Problem 27. 
Section 3-4 
29. 
Make a flow chart for each of the programs in Problem 27. 
30. 
Make a flow chart for a program which will test each of η integers 
stored in consecutively addressed registers for a zero value and 
count the total numbers of zeros. 
3 1 . 
Convert the flow chart of Problem 30 into a program with symbolic 
addresses. 
32. 
Assemble the program of Problem 31. Edit the assembled version 
of the program. 
33. 
Make a detailed flow chart of the final program in Problem 32. 
Compare this with the first draft. 

EXERCISES 
115 
Section 3-6 
34. 
The control enters the following program at 01000. What occurs? 
01000 
50 
1 00144 
50 2 00002 
01001 
12 1 00100 
14 2 00200 
01002 
20 
1 00101 
51 
1 00001 
01003 
51 2 77776 
12 1 00100 
01004 
14 2 00200 
20 
1 00100 
01005 
76 0 01005 
35. 
In Problem 34 mark all designators which cause direct address 
modification and all those which cause the content of a register to 
change. 
36. 
In Problem 34 in which registers will the initial contents be altered? 
37. 
In Problem 34 in which values of U and L does the address part 
serve as an address and in which as an operand? 
38. 
The control enters the following code at a0. What occurs? 
« 0 
OC2 
52 
1 «! 
52 2 
a i 
12 1 ß0 
14 2 βι 
76 0 
« 2 
39. 
Repeat Problems 35, 36, and 37 for the code in Problem 38. 
40. 
The control enters the following code at a0. What occurs? 
oto 
<Xi 
a 2 
<*3 
OCA 
50 
1 01000 
56 
1 
cx2 
12 0 
ft 
51 
1 00001 
20 0 
β0 
52 2 02000 
57 2 
a 2 
14 0 ßQ 
% 
56 
1 α4 
76 0 
α / * 
4 1 . 
Repeat Problems 35, 36, and 37 for the code in Problem 40. 
Section 3-6.1 
42. 
Redo Problem 25, using an index jump and ignoring the fact that 
the integers in the second two problems will be stored in reverse 
order. Make a preliminary flow chart. 
43. 
Redo Problem 34, using an index jump and ensuring that the integer 
storage is properly sequential. Make a preliminary flow chart. 
44. 
Redo Problem 34 using an index skip. Make a preliminary flow chart. 

116 
3. ELEMENTARY CODING 
45. 
Write a code for a vector sum using an Α-jump (b = 0) to close the 
loop and which achieves all internal address modification in instruc-
tions by use of the substitute address instructions (56 and 57). Use 
any other instructions discussed in Chapter 3, but no others. 
Section 3-6.2 
46. 
For Problems 42, 43, and 44 prepare a properly edited final version 
of the code. 
47. 
Make flow charts for the edited codes of Problem 46. 
Section 3-7 
48. 
Indicate adjacent to each box of the flow chart of Example 3-21 the 
appropriate address from the code of Example 3-22. 
49. 
Make a flow chart and write the code to form the transpose by taking 
each row of the original matrix in turn, and distributing the ele-
ments to the appropriate columns of the transpose. 
50. 
Make a flow chart and write the code to form the trace of the matrix 
of Examples 3-21 and 3-22, that is,
 
α
**'· Assume | Σ?-ι
 
α« I < 
2
4 7. 

CHAPTER 4 
Fixed and Floating Point 
Arithmetic; Scaling 
4-0. Introduction 
For ordinary hand calculation, we use the visual aid of the base point 
and a few simple rules to keep an account of the relative order of all signifi-
cant digits. This technique, however, is not suitable for the automatic 
digital computer, and it is the purpose of this chapter to consider the 
methods which are used. Two general schemes are available. The first of 
these is the fixed point method in which the programmer is responsible for 
the operations of scaling which properly place the base point. The other is 
the floating point method in which the computer itself handles the location 
of the base point, provided that numbers are represented in a suitable 
format. The arithmetic operations of most machines are designed to do 
fixed point arithmetic, although some are designed to do only 
floating 
point, and many are capable of both. If floating point operation is not 
directly provided, it can be achieved by suitable coding techniques. Al-
though the use of external scaling is now much less prevalent than in the 
early days of programming, a well-rounded programmer should be thor-
oughly versed in both schemes. In this chapter we shall consider both 
the fixed and floating point methods of computing and some of the 
arithmetic operations related to them. 
4-1. Integral Fixed Point Arithmetic 
Fixed point operations in a digital computer treat all sequences of digits 
representing arithmetic operands as though an imaginary base point were 
in a fixed position. In an integral machine, this point is imagined to be 
117 

118 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
Instruction 
Code 
Instruction 
Code 
A right shift 
01 
Q left shift 
06 
Q right shift 
02 
AQ left shift 
07 
AQ right shift 
03 
Multiply integer 
24 
-A" left shift 
05 
Divide integer 
25 
4-1.0. Shifting Operations 
Shifting operations are designed to move the digits in a register either 
to the right or to the left of their initial position. Used correctly, these 
operations provide the equivalent of a method of moving the relative posi-
tion of the fixed base point. In the CDC 1604, each of the three right shift 
instructions and each of the three left shift instructions differ only in the 
registers in which they are carried out, but there are basic differences 
between the right shift and the left shift other than the direction. These 
differences are concerned with the treatment of digits shifted in or out of 
the right- and left-hand ends. Right shift instructions are end off and 
sign extending, that is, the low order bits shifted to the right of the zero 
order position are lost, and the vacated bit positions on the left are filled 
with bits equal to the original sign bit. Left shift instructions are end 
around, or circular, that is, bits shifted left from the high order position 
are carried end around into the low order positions. Each of these is useful 
under certain programming conditions, and the distinction will become 
clear with examples. 
4-1.1. Right Shift Instructions in the CDC 1604 
The instructions 01 
b 
k, 02 
b 
k, and 03 
b 
k provide end off 
right shifts in A, Q, and AQ, respectively, by an amount Κ determined 
as the sum of k and the content of the index register designated by b. For 
simplicity, we consider here only the case in which 6 = 0 and the number 
of right shifts is k = K. As the digits are shifted to the right, the highest 
order digit (normally a sign bit) is extended to fill in the high order places. 
at the right-hand end of the sequence of digits in each register, so that each 
number is treated as an integer. We expect that almost all machines will 
have operations for addition, subtraction, multiplication, and division of 
fixed point operands. A bit of reflection will convince us of the desirability 
of shifting operations for moving digits in registers relative to the fixed 
point. We now introduce some of the specific arithmetic operations in the 
CDC 1604 which use this principle. 

4-1. INTEGRAL FIXED POINT ARITHMETIC 
119 
Note that the address portions of the instruction words are used to desig-
nate the basic shift counts and not addresses. 
As an example, we consider a right shift in A with Κ = 3, instruction 
01 
0 
00003. If at the initiation of the operation ( A)i = α^α^α^' 
· ·α2αιαο, 
immediately after we would have (A)F 
— 047047047(147046· · * (I4Ö3. The low 
order digits a 2, a i , and a 0 are lost. 
In the long right shift, the combined A and Q registers are treated as a 
single double length 96-bit register AQ, that is, with the high order 48 
bits in A and the low order 48 bits in Q. The high order bit of A is extended 
by the amount of the shift, the low order bits of A move into the high order 
position of Q and the low order bits of Q are end off. For example, if 
( A Q ) ι = 
a 47ß46 · · · a2aia0, 
q^a · · · q2qiqo 
at initiation of an instruction of the form 03 0 
00003, immediately 
after execution, 
( A Q) F = a^a^a^a^a^ 
· · · a^a^aïaçq^q^ 
· · · qsq^qz 
with q2) qh and qo lost. 
A few numerical examples will help to clarify the situation. 
Example 4-0. The content immediately before and after a right shift in 
A with Κ = 6 is indicated in octal. The instruction is 01 0 
00006. 
Case 1. 
(Α) τ = 2 4 3 1 2 3 4 5 5 4 3 2 1 7 
1 6 4 [->OFF 
\ 
\ 
(A) F = 
0 0 2 4 3 1 2 3 4 5 5 4 3 2 1 7 
Case 2. 
(A)T 
= 5 4 3 2 1 2 3 4 5 6 1 7 6 5 
1T~3~1->0FF 
\ 
\ 
(A) F = 
7 7 5 4 3 2 1 2 3 4 5 6 1 7 6 5 
Since a right shift of 6 in binary is a right shift of 2 in octal, each octal 
digit is shifted 2 places right. In Case 1, a high order octal digit of 2 = 
(010)2 has a zero sign bit and this zero is extended. In Case 2, a high octal 
digit 5 = (101)2 has a high order sign bit of 1 and this is extended as two 
7's. The low order 64 and 43 are lost. 
Example 4-1. The content immediately before and after a long right 
shift in AQ with Κ 
= 5 is indicated in binary. The instruction is 
03 
0 
00005. Dots indicate that all binary digits are alike. 
(A, Q)T = 011110---011111, 100010-»000001 11011 h-»OFF 
00000011110·--0, 11111 100010··-00J00 

120 
4. FIXED AND FLOATING POINT ARITHMETIC) SCALING 
The five low order digits of A, 11111, become the high order digits of Q, 
the zero sign bit is extended in A , and the five low order bits of Q, 11011, 
are lost. If numbers in A , Q, and A Q are interpreted as fixed point numbers, 
the arithmetic effect of a right shift of Κ is the equivalent of multiplication 
by 2~
K and truncation of the result. In Examples 4-0 and 4-1 we see that 
the numbers have been multiplied, respectively, by 2
- 6 and 2
- 6 and 
truncated. 
The largest practical right shifts in A and Q are forty-seven. Such 
shifts will fill the registers with original sign bits, additional right shifts 
producing no further change. Similarly, a long right shift in A Q of ninety-
five will extend the sign bit of A to the entire combined register, with addi-
tional shifts producing no further change. Shifts greater than these amounts 
will be executed. However, for a shift count of Κ greater than one hundred 
and twenty-seven, a fault indicator is set, which may either be ignored or 
accepted by means of appropriate program action. This will be considered 
in a later chapter. 
4-1.2. Left Shift Instructions in the CDC 1604 
As we have already indicated, the C D C 1604 left shift instructions are 
end around or circular. As each digit is shifted left out of the high order 
position, it moves into the low or zero order position. All initial bits in a 
register are retained. The instructions 05 
b fc, 06 
b 
k, and 07 
b 
k 
provide for each bit to be shifted left by an amount Κ which is the sum of 
k and the content of the index register designated by b. We shall again 
consider in this section only the case b = 0, k = K. As an example, we 
consider a left shift in A, with Κ = 3, instruction 05 
0 
00003. If (Α) ι = 
a^a^aif 
··α 2αια 0, then (A)F 
= 
044043042· ··α^οα^α^α^. A similar result 
holds for left shift in Q. As with the long right shift, the long left shift 
instruction 07 b k treats AQ as a combined double length register of 96 
bits. That is, high order bits of Q move into the low order positions of A, 
and high order bits of A are carried end around into the low order positions 
of Q. 
To give numerical illustrations, we replace the right shift instructions 
in Examples 4-0 and 4-1 with left shift instructions. 
Example 4-2. The content immediately before and after a left shift in 
A with Κ = 6 is given in octal. The instruction is 05 
0 
00006. 
r->End around 
Case 1. 
(A) j 
2~4~1 
3 1 2 3 4 5 5 4 3 2 1 7 6 4 
(A)F 
3 1 2 3 4 5 5 4 3 2 1 7 6 4 2 4 

4 - 1 . 
INTEGRAL FIXED POINT ARITHMETIC 
121 
Case 2. 
(Α)τ 
= 
»End around 
5jT) 
3 2 1 2 3 4 5 6 1 7 6 5 4 3 
(A)F 
= 
3 2 1 2 3 4 5 6 1 7 6 5 4 3 5 4 
Note that the left shift of 6 in binary is a left shift of 2 in octal. Positive 
and negative numbers are handled the same way, since no sign bit is ex-
tended. In Case 2 the original sign bit, one, has been replaced by zero. 
Example 4-3. The content of AQ immediately before and after a long 
left shift in AQ with Κ 
= 
5 is given in binary. The instruction is 
07 
0 
00005. Dots indicate that all bits are alike. 
—» End around 
X 
(A, Q ) r = 1011111 00000 0 . . . 0 00000, 10001 00000 0 . . . 0 
11011 
(A, Q)F 
= 00000 0 . . . 0 00000 10001, 00000 0 . . . 0 
110111011111 
Because of its circular nature, a left shift of forty-eight in A or Q and 
ninety-six in AQ will restore all digits to their initial positions. Shifts 
greater than these in number will be carried out but can produce no new 
configurations. Shifts of more than one hundred and twenty-seven set a 
fault indicator. Another effect of the circular nature of the left shift is 
that every end around left shift is equivalent to an end around right shift. In 
A and Q a left shift Κ is equivalent to a right shift (48 — K) and in AQ 
a right shift of (96 — K). 
Thus, a circular right shift instruction is 
superfluous. 
Example 4-4. A left shift in A of Κ = 39i 0 produces a right shift of 9ι0' 
The instruction is 05 
0 
00047 and gives shifts octally of 13i0 left and 3 
right. Content is given in octal. 
»End around 
or 
(Α) ι = l O O O O O O O O O O 
ΟΊΠΠ 2 3 4 
(A) ρ = 2~3~1 l O O O O O O O O O O O 
ÖT1 
< 
End around < 
(A)r 
= 
(A), 
= 
0 _ 0 0 0 0 0 0 0 0 0 0 0 _ 1 
12 3 4 1 
2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 1 

122 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
The reader should note that the base shift count Κ is specified in octal. 
Experience indicates that a beginner coder will often err by giving the 
base value of the shift in decimal. While advanced assembly systems will 
frequently permit this, care should be taken at this early stage of coding 
development to utilize octal notation in all parts of program words. 
As with end off right shifts, the left shift instructions can be interpreted 
under certain circumstances as producing multiplication by powers of two. 
The rule is: After a left shift of λ, the final content of the registers can be con-
sidered to represent the initial 
content multiplied 
by 2
X if and only if the 
initial content had at least λ + 1 leading bits which were either all zeros or 
ones. A right circular shift of ρ is equivalent to multiplication 
by 2~
p if and 
only if the initial content had at least ρ low order bits all equal to each other 
and equal to the initial high order (sign) 
bit. 
Example 4-5. The content before and after a left shift in Q with Κ = 6 
is given in octal. The instruction is 06 
0 
00006. 
Case 1. 
(Q)i 
= 0 0 2 1 1 1 1 1 
0 0 0 0 1 0 0 0 
(Q)F 
= 2 1 1 1 1 1 0 0 
0 0 1 0 0 0 0 0 
Here there are seven sign bits and the content is multiplied by 2
6 = 8
2. 
The sign bit in 2 = (010) 2 is still correct. 
Case 2. 
(Q)r 
= 0 0 5 1 1 1 1 1 
0 0 0 0 1 0 0 0 
(Q)F 
= 5 1 1 1 1 1 0 0 
0 0 1 0 0 0 0 0 
Here only six sign bits are available, and the shift has turned a positive 
number into a negative number whose sign bit is given by the 5 = (101) 2. 
4-1.3. The Multiply Integer and Divide Integer Instructions in the CDC 1604 
The multiply integer and divide integer operations treat sequences of 
digits as though the binary point were at the right-hand end of the se-
quence. The first operation forms a product of two integers and the second 
forms the quotient and remainder after division of one integer by another. 
The multiply integer instruction, 24 
b 
m, is straightforward. It forms 
the 96-bit product of the 48-bit content of the register with address M 
(determined as the sum of m and the content of the index register desig-
nated by b) and the 48-bit content of A. This product is formed in QA 
considered as a single 96-bit register with the high order bits in Q, and the 
low order bits in A. With the digits of the product in this position, the 
binary point, imagined to be at the right of (A), is aligned for addition in 
A of an integer from storage. We consider here only the case b = 0, m = M. 

4-1. 
INTEGRAL FIXED POINT ARITHMETIC 
123 
To form a product of two numbers, we must first load one of the two 
factors into A and then multiply. We accomplish this by a single program 
step as shown in Example 4-6. 
Example 4-6. We wish to form the product of the integers contained in 
registers 00100 and 00101. We assume the content in octal is 
(00100) = 3000 0000 0000 0002 and 
(00100) = 0000 0000 0000 0003. 
We form the product by means of this program step: 12 
0 
00100 
24 
0 
00101. After completion of the instruction pair, the product is in 
QA: 
Q 
A 
(QA) 
= 0000 0000 0000 0001 
1000 0000 0000 0006 
s
 
ν — ' 
** 
' 
sign digits 
significant digits 
It is important to note that the combination of A and Q as a single 96-bit 
register is here reversed from the shift instructions, that is, it is Q A and 
not 
AQ. 
The divide integer instruction 25 b m, divides the 96-bit content of QA, 
considered as the dividend, by the 48-bit content of register M 
(deter-
mined as the sum of m and the content of the index register specified by b). 
We note that the digital positions of the dividend and divisor give proper 
alignment of the binary point for integral division by successive subtrac-
tions. The quotient is formed in the A register and the remainder is left 
in the Q register. The remainder and the initial dividend will have the 
same algebraic sign. We consider again in the initial examples only 6 = 0, 
m = 
M. 
Given the integer dividend χ and the integer divisor y we wish to deter-
mine integers q and r, with | r \ < \ y | such that χ = yq + r. This is given 
by the divide integer instruction as 
(QA)r 
= 
(M)(A)F 
+ 
(Q)F 
where 
χ = 
(QA)T, 
y = 
(M), 
q = 
(A)F, 
and 
r = 
(Q)F 
Example 4-7. We wish to do the inverse of Example 4-6. Immediately 
after the execution of the upper and lower instructions of that example, 
(QA) 
= 0000 0000 0000 0001, 
1000 0000 0000 0006 
The instruction 25 0 00101 will then produce 
(A)F 
= 3000 0000 0000 0002, 
the quotient 
and 
(Q)F 
= 0000 0000 0000 0000, 
the remainder 
(zero because the division is exact). 

124 
4. FIXED AND FLOATING POINT ARITHMETIC j SCALING 
Example 4-8. We wish to divide the number 17i0 by 5 to produce a 
quotient of 3 and a remainder of 2. The numbers 17io and 5 are in registers 
00100 and 00101 ; that is, in octal, 
(00100) = 0000 0000 0000 0021 
(00101) = 0000 0000 0000 0005 
We must first load the dividend into QA. We achieve this by the instruc-
tions 04 
0 
00000 
12 
0 
00100. The upper instruction fills Q with 
sign bits and the lower instruction loads the significant digits in A . At this 
point 
(QA) 
= 0000 0000 0000 0000, 
0000 0000 0000 0021 
If this is now followed by the instruction 25 
0 
00101, the result is 
( A ) F = 0000 0000 0000 0003 
(Q)F 
= 0000 0000 0000 0002 
In Example 4-8 we were able to enter the dividend in QA simply by 
filling Q with sign bits for the known positive number. This is necessary 
to provide a properly extended complement arithmetic version of the divi-
dend in QA. The proper steps for entering the dividend in general, when 
we do not know the sign in advance, will be considered in the sections on 
scaling. The reader may find it instructive to achieve the loading result in 
Example 4-8 with the aid of shift instructions. 
4-2. Scaling for Integral Fixed Point Operation 
In a machine using integral fixed point operations, all arithmetic opera-
tions are carried out on integers with the base point considered to be at 
the right-hand end of each sequence of digits. It is not to be expected, 
however, that numbers arising in a typical computation will all be integers, 
or that all integers arising in computation will be small enough to be con-
tained in a register. We treat such problems by introducing suitable scale 
factors, and the technique for using them properly is called scaling. Except 
for variations in the base used and in the number of digits in a register, the 
scaling problem is the same for all fixed point integral computers. In this 
section we will study this problem for the general case, with specific applica-
tions to the CDC 1604. 
4-2.0. Scale Factors 
Let Ν represent a typical number which we wish to introduce into the 
storage register of a machine which uses base r with a + 1 digits in each 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
125 
register. We assume that the computer uses complements, that the high 
order digit is always a sign digit, and that a positions are available for 
significant digits. In general, Ν will have both a fractional and an integral 
part. Consequently, we will not be able to place its digits directly into a 
storage register. Instead of N, we will store its machine representation. 
This 
is denned to be the integral part of ΛΓ-r·, where s is a suitable integer, 
negative or nonnegative. Suppose that Ν has the digital representation, 
base r, 
Ν 
= 
dmdm-i 
· · 'do'd-id^d-z* 
· · 
To obtain the machine representation, we round Ν to a suitable number 
of significant digits and move the base point to the right-hand end of the 
digits retained. For base r, shifting of the base point is multiplication by a 
power of r, and round-off is the retention of the integral part of the result. 
Thus, the machine representation of Ν is 
η = integral part of 
N*r* = integral part of 
(dmdm-i' 
· ·<ί_,·<£-(β+ΐ)· · · ) 
= 
dmdm-v 
· 'd-8 
= 
Nr
8 
We will use Nr*, without the "dot" symbol for multiplication to mean the 
machine representation of Ν scaled r*. Since η is an integer, there will be 
no difficulty in storing its digits properly in a register of an integral ma-
chine, provided that η is of suitable magnitude. This will be the case if s 
has been selected correctly. The number r* is called the scale factor and s 
the scale factor exponent. 
The problem we will consider below is that of 
correctly selecting s for machine representations of numbers to be entered 
into storage registers as input data, or which arise internally in arithmetic 
operations. 
The inverse problem of obtaining an unsealed version of a machine 
representation also rises. Since 
η = integral part of N*r* 
we have 
Ν = η · Γ ~ * ( = Ν to within round-off error) 
If we assume that η is stored in register a, then 
(a) 
= 
dmdm-v 
· 
-d-a 
and the base point is imagined to be just to the right of <L.e. The factor r~* 
then tells us how far to shift the point in order to get N. The number of 
positions shifted will be equal to | s | . The direction of shift is left if s is 
positive and right if s is negative. If the shift of the point opens up digital 
positions which are not occupied by dm through cL,, these positions are to 
be filled by digits which make no contribution to the absolute value of N. 

126 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
The resultant number Ν may be equal to Ν but, in general, will only be 
an approximation to it. Unfortunately, Ν is the only reconstruction of Ν 
that can be obtained from the machine number and the coder must learn 
to make it the best available reconstruction by optimal choice of s. Since 
for practical purposes we use Ν for N, we will use the symbol Ν in situa-
tions where, strictly, Ν should be employed. This laxity should do no 
harm, however, if we bear in mind that almost all numbers used in com-
putation are subject to errors of round-off. 
If the integer η = Nr
8 is to be stored correctly in complement form in 
an a + 1 digit register, then it must contain no more than a digits; that 
is, it must satisfy the condition 
Since the digital representation of | Ν | starts with a first nonzero digit 
corresponding to some power of r, 
(4-0) 
there is always a unique integer ρ for which 
(4-1) 
and 
Hence, condition (4-0) will be fulfilled if 
(4-2) 
Inequality (4-2) makes it easy to deal with the two basic questions of 
scaling: 
(1) Given p, that is, given a bound for | Ν | , what are the allowable 
scale factor exponents, s, such that η = Nr* can be stored in complement 
form in an a + 1 digit register? 
(2) Given s, that is, given a scale factor, what numbers Ν have a ma-
chine representation η = Nr
8 which can be stored in complement form in 
an a + 1 digit register? 
In the CDC 1604, the normal storage register has r = 2 and a + 1 = 
48. If the combined A and Q registers are considered as a single 96-bit 
register, r = 2 and a + 1 = 96. Thus, for scale factors 2*, the equivalents 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
127 
of (4-0), (4-1), and (4-2) are 
(4-3) 
\n\ 
< \N-2<\ 
< 2
4 7 
or 
I η J < I Ν·2° I < 2
9 δ 
for 
AQ 
or 
QA 
(4-4) 
2*-
1 < I N\ 
< 2* 
and 
(4-5) 
ρ + s < 47 
or 
ρ + s < 95 
for 
AQ 
or 
QA 
Using the inequalities (4-5) in conjunction with a table of powers of two 
(Appendix B), we can readily answer the two basic questions. 
Example 4-9. Find suitable scale factors for the decimal numbers Ν = 
3.1416, -.0003, and 27,000. From the table of powers of two we have 
2 < I 3.1416 I < 2
2 
2-12 < ι - . 0 0 0 3 I < 2 -
1 1 
and 
2
1 4 < I 27,000 I < 2
1 5 
Hence, for the three cases, we have, respectively, ρ = 2, —11, and 15. In-
equalities (4-5) give us, in order 
si < 47 - 2 = 45 
S2 < 47 - 
( - 1 1 ) = 58 
and 
or 
and 
s 3 < 47 - 
15 = 32 
si < 95 - 2 = 93 
s2 < 95 - 
( - 1 1 ) = 106 
s 3 < 95 - 15 = 80 
for 
AQ 
or 
QA 
Theoretically, we have an infinite range of choices for s to satisfy (4-2) 
or (4-5) for a given value of p. Consider, however, that each decrease of 
one in the value of s moves the base point one place left before rounding. 
Thus, the rounded-off 
machine 
representation 
loses the significant 
digit 
moved to the right of the base point. For example, in a five-place decimal 
machine with scale factor 10*, for the number 1.342, we could have values 

128 
4. FIXED AND FLOATING POINT ARITHMETIC J SCALING 
of s < 3, so that for s = 3, η = 01342, but for 
= 2; 
η = 00134 
= l; 
η = 00013 
= 0; 
η = 00001 
< 0 ; 
η = 00000 
Hence, in the inequality s < a — p, the equality sign provides for 
retention 
of the maximum 
number of significant 
digits and each decrease of one in s 
causes a loss of one significant digit. Since ρ + s is the number of signifi-
cant digits retained, it is important for maximum 
significance to choose the 
optimal or largest possible value of s in the acceptable range. We will generally 
take s as the largest integer for which s < a — p, although this will not 
always be the case. As we shall see later, arithmetic operations may dictate 
that some significant digits be dropped. In other cases, where the resulting 
loss of accuracy may be permissible, we may choose less than optimal 
scaling for convenience. 
The same rule for optimal scaling is applicable to the second of our basic 
questions. 
Example 4-10. Given a fixed scale factor exponent of 44i 0 on the C D C 
1604, what numbers Ν can be stored without overflow? From (4-5) we 
have 
ρ < 47 _ 44 = 3 
or 
ρ < 95 - 44 = 51 
for 
AQ 
or 
QA 
Hence, any Ν for which, in the two cases, \ N \ < 2
3 or | Ν | < 2
6 1 are 
acceptable. However, for numbers less than 2
2 or 2
5 0 we would lose signifi-
cance at the given scaling, and for | Ν \ < 2
- 4 4 no significant digits at all 
would appear in the machine representation. 
Since many modern machines use internal binary arithmetic and the 
coder uses the more convenient octal format, two questions frequently 
arise. The first of these is how to obtain the octal form of a properly scaled 
decimal number, and the second is how to reduce a scaled octal representa-
tion to its unsealed decimal equivalent. We give examples of each. 
Example 4-11. (a) The decimal number Ν = 586.25 is to be optimally 
scaled and put in a 48-bit register. What is the octal form of the machine 
representation? Since 2
9 < 586.25 < 2
1 0, s < 47 - 10 = 37 and, optimally, 
s = 37. Therefore, we scale in the following way: 
(586.25) ·2
3 7 = (586.25)·2·2
3 6 = (1172.5) · 2
8 β = (1172.5) ·8
1 2 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
129 
The last form permits us to multiply by 8
1 2 in octal by shifting. Thus, con-
verting to octal, we get 1172.5i0 = 2224.4 8; and with a twelve-place shift, 
η = [(586.25)2
3 7] 1 0 = 2224 4000 0000 0000 8 
(b) The decimal number Ν = —.046875 is to be optimally scaled and 
put in a 48-bit register. What is the octal form of the machine representa-
tion? Since, 2"
6 < | -.046875 | < 2~
4, s < 47 - ( - 4 ) = 51 and, optimally, 
s = 51 which gives a scale factor 2
5 1 = 8
1 7. 
Converting to octal, we get | —.046875 |i 0 = .046875i0 = .03 8. Hence, 
[(.046875)2
δ 1] 1 0 = 3000 0000 0000 0000 8 
but we want the negative number, so we complement to get 
η = 4777 7777 7777 7777 8 
(c) The number Ν = 2
5 5 + 2
9 + 3 is to be stored in a 48-bit register, 
optimally scaled. What is the octal form of the machine representation? 
Since 2
W < 2
5 5 + 2
9 + 3 < 2
5 6, s < 47 - 56 = - 9 , and optimally, s = - 9 . 
The octal form of Ν is 2,000,000,000,000,001,0038. The scaled machine 
representation is the integral part of ΛΓ·2
- 9 = ΛΓ·8~
3 which in octal is 
η = 2000000000000001. We see that in order to store a number of this 
size, we have had to discard three octal or nine binary digits of the integral 
part. 
Example 4-12. (a) The content of a 48-bit register is 3524 0000 0000 0000 
scaled at 2
4 0. What is the unsealed decimal version of the content? Since 
η = 
N2
40 
Ν = n - 2 -
4 0 = η-2-
ι-2-*' 
= (3524000000000000) ^ - ^ δ "
1 3 
= 165.2 8 = 117.25io 
(b) The content of a 48-bit register is 5324 7777 7777 7777, scaled at 
239 what is its unsealed decimal version? Here the leading octal digit 
5 = (101) 2 gives a sign bit of one, indicating a negative number, and we 
have I η I = 24530000000000008. This gives 
I Ν I = I η I 2~
3 9 = I η I 8~
13 = 245.3 8 
and 
Ν = - 2 4 5 . 3 8 = -165.375io 
The coder must understand that neither the base point nor the scale factor 
will appear anywhere inside of the computer. The coder must record the 
scale factor externally whenever a number is placed in storage by input or 
generated internally by arithmetic operations. It is his responsibility to be 

130 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
370.3465 
and gives the scaled and rounded machine version of the result. Because of 
the necessity of lining up the decimal point, we could not retain four 
significant digits in M. 
By making t = s, we line up the base point and form 
n ± m 
= Nr
8 ± Mr
8 = (N + 
M)r
8 
so that the sum or difference has the same scaling as the original operands. 
It is important to remember, however, that results of all arithmetic opera-
tions must be properly scaled for the registers in which they are contained, 
just as the original operands had to be properly scaled to fit the registers 
in which they were stored. Otherwise overflow may occur, that is, the result 
of the operation may be too large for the register in which it is to be formed 
aware of the scale factors associated with all machine numbers and with 
the final results so that they may be properly interpreted. 
4-2.1. Scaling Integral Addition and Subtraction 
The scaling problems which arise in forming the sum or difference of 
two machine numbers η = Nr
8 and m = Mr
1 will now be considered. Be-
cause the two machine numbers are integers, it is, of course, no problem 
to form the sum or difference. However, since we wish to obtain the cor-
rectly scaled machine version of Ν ± M it is essential that Ν and M have 
the same scale factor, that is, s = t. This is equivalent to lining up the 
base point in M and Ν so that corresponding digits are added. If t > s 
and t is optimal, then m = Mr
1 must be scaled down to m = Mr
8 
and 
rounded off, a case in which optimal scaling may not be used. 
Example 4-13. In a five place decimal machine, we wish to add the op-
timally scaled numbers Ν = 345.212 and M = 25.1345. We can retain 
four significant digits so that, optimally, 
η = N(IO)
1 
= 03452 
and 
m = M(l0y 
= 02513. 
If these were added directly, an incorrect sum would be formed. Since t = 
2 > 1 = s, we must scale M and its machine representation down to 
m = M(IO)
1 = 00251 and add η + m = 03452 + 00251 = 03703. This 
effectively lines up the decimal point in the original calculation, 
345.212 
25.1345 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
131 
00001101 
but if only four bits are sent to storage, we get the incorrect sum 1101 
which is equivalent to —0010. That is, overflow has given us + 7 + 6 = —2. 
Example 4-15. In a 48-bit complement machine, sums are formed in a 
48-bit accumulator. We wish to add the positive numbers (in octal) 
3500 0000 0000 0000 and 3620 0000 0000 0000, each of which is in 
storage. However, the sum produced in A is 7320 0000 0000 0000, which 
is a negative number. 
In machines where overflow will occur in a storage register but not in 
the accumulator, adjustment of the scale factor to forestall overflow can 
usually be accomplished by shifting operations on the result after addition 
or subtraction takes place, and this may be preferable to reduce round-off 
error. Where overflow occurs in the arithmetic register itself, however, 
such adjustments must be made on all operands prior to completion of the 
operation. 
The condition on the sum or difference for no overflow in a register of 
length a + 1 is the same as that given by inequality (4-2), that is, if 
rp-i < \ M ± N \ < r*> 
then a correct scale factor for the sum is given by s < a — p, with s = 
a — ρ optimal. Since in many instances the exact value of ρ is not known, 
we must estimate ρ in terms of upper bounds on results. We first estimate 
an upper bound 
I Ν ± M I < r*' 
and then use p' in place of p. If the estimate is correct, p' > p, then no 
overflow occurs; and if p
r = p, we may use optimal scaling. If p' < ρ is 
used, overflow occurs. 
or stored. Two problems can arise. If the sum or difference is formed in an 
arithmetic register of extra length, the arithmetic register may accom-
modate it but an ordinary storage register may not. If the arithmetic 
register is of the same size as a storage register, overflow may occur in 
this register. 
Example 4-14. In a four place binary; one's complement, machine sums 
are formed in an eight place accumulator. We wish to add 0111 and 0110. 
In the accumulator we get, correctly, 
00000111 
00000110 

132 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
In all cases, we may handle the problem of adjusting to a correct scale 
factor in the sum or difference by the use of a properly selected right shift 
of ρ to multiply by r~
p. With M and Ν scaled at r* and an estimate p' of 
p, we have after multiplication by r
_ p, 
I (N db M) . r ' - r - ' | 
<rP'+*-f> 
and the required condition is then p' + s — ρ < α. This last inequality is 
just (4-2) with ρ replaced by the estimate p
f and s replaced by the adjusted 
scale factor exponent s — p. It answers the question, What scale factor 
exponents, s — ρ, are permissible for a sum or difference of the estimated 
magnitude? The inequality may be written as 
(4-6) 
P>p' 
+ 
s - a 
with all quantities on the right known. This tells us that to avoid overflow, 
we must right shift by at least p' + s — a places, and round off. The ma-
chine representation of the sum or difference will be correct with a scaling 
of s — p. The optimal value of the right shift count is ρ = ρ
1 + s — α, 
and larger values will cause overshifting and loss of significance. This will 
be the case also if too large a value of p' is used, and it is thus important 
to obtain the best possible estimate of p. 
We now present some examples illustrating scaling of addition and sub-
traction on the CDC 1604. For the CDC 1604, we use r = 2 and a = 47. 
Example 4-16. (a) The numbers Ν scaled at 2
1 8, and M scaled at 2
1 7, 
are stored in two 48-bit registers. We wish to form their sum which is 
known to be such that | Ν + M \ < 2
3 0. We must first line up the binary 
points, so we scale Ν down to 2
1 7 to match M. This is accomplished by 
loading Ν into A and right shifting by one. Since | Ν + M | < 2
8 0, the 
scaled sum | (Ν + Μ) · 2
1 71 < 2
4 7 and we can add directly with no further 
shifting. Alternatively, we can make direct use of inequality (4-6). Suppose 
(01000) = N2
1* and (01001) = M2
1 7. The instructions to line up the 
binary point and form the sum are 
12 
0 
01000 
01 
0 
00001 
14 
0 
01001 
— 
(b) The numbers Ν and M are both scaled at 2
2 3 and stored in 48-bit 
registers. We wish to form their difference, but no direct upper bound is 
known. Since the numbers have the same scale factor, they can be sub-
tracted directly. Furthermore, | Ν \ < 2
4 7~
2 3 = 2
2 4 and | M \ < 2
4 7"
2 3 = 
2
2 4, or the numbers are not correctly stored at the given scaling. The best 
estimate we can make of the difference is then | Ν — M \ < 2
2 4 + 2
2 4 = 2
2 5, 
giving p' = 25. Hence, to be sure that we avoid overflow, we have, by in-
iV2
17 - > A 
(M + N)2
17
 
—» A 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
133 
equality (4-6), a right shift ρ > 25 + 23 — 47 = 1 and we choose the 
value ρ = 1 to avoid overshifting. Because this condition holds for the 
accumulator, the shifts must be made prior to subtraction, and the resulting 
difference is scaled at 2
2 2. If (01000) = JV2
28 and (01001) = M2
2 3, we can 
achieve this result by 
12 
0 
01000 
16 
0 
01001 
21 
0 
01001 
01 
0 
00001 
02 
0 
00001 
15 
0 
01001 
N2
22-+A 
M2
22^>Q 
M2
2 2-> (01001) 
and 
(N - 
M)2
22->A 
4-2.2. Scaling Multiplication 
Suppose we wish to form the product of two integers which are machine 
representations η = Nr
9 and m = MrK Here it is not necessary to align 
the base point, and we get 
nm = 
(NM)r
8+
l 
so that the preliminary scale factor for the product has exponent (s + 
t). 
In almost all machines, the product is formed in a double length register. 
Since η and m are proper machine representations, \n \ < r
a, \ m \ < r*, 
and I nm \ < r
2a so that no product overflow can occur in the double length 
register. If the product is to be transferred to a normal length register, 
however, we will, in general, have to scale down by the equivalent of a 
rounded-off right shift p, that is, to multiply by r~
p and round to an integer. 
Multiplication of the original machine representation of the product by 
r~
p, followed by rounding, yields the new machine representation 
integral part of [ w m « r
p] = 
NMr
8+t-
p 
The condition that this new machine version fit in a register of normal 
length is 
I NMr
8+t-
p 
I < r
a 
If an upper bound for the product is known, that is, we know ρ such that 
I NM I < r*> 
we can write 
I NMr
8+t~
p 
I < r
p + e + < _
p 
and the no overflow condition is satisfied if 
This can be rewritten as 
(4-7) 
p + s + t — 
p<a 
P>p+s+t—a 

134 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
where everything on the right is known. This is equivalent to deriving 
inequality (4-2) with s + t — ρ in place of s. Hence, the question that in-
equality (4-7) answers is: What scale factor exponents s + t — ρ are per-
missible for a product of the given magnitude to be stored in a register of 
length a + 1? The choice of the equality, p=p+s+t— 
a, produces 
optimal scaling of the product, while larger values of ρ result in overshifting 
and loss of low order significant digits. The choice oîp<p 
+ s + t — a 
results in undershifting, 
which leads to loss of high order significant digits 
and incorrect answers. We have tacitly assumed that ρ > 0 and would 
correspond to an actual right shift or none. It is apparent that a negative 
ρ should simply be interpreted as producing a left shift requirement. This 
situation seldom arises, and we will not pursue it here. 
If ρ is not known exactly, as is often true, we must estimate an upper 
bound 
\NM I < r*' 
and use p' as an estimate for ρ in inequality (4-7), giving ρ > p' + s + 
t — a. If p' < p, overflow probably occurs. If p' > p, there is no overflow, 
but loss of significance occurs for p' > p. For this reason we should strive 
to find the sharpest estimate possible. 
The method used to scale down the product by r~
p depends on the ma-
chine. It is equivalent to an end-off right shift of ρ to maximize the number 
of digits retained and place them in the proper location just left of the 
base point. In machines where only the low order digits of the double 
length arithmetic register can be sent to storage, we form the product, 
right shift by ρ and transmit to storage. In machines in which both the 
high order digits and the low order digits may be directly stored we may 
use alternate methods. 
In the CDC 1604, the double length register in which products are formed 
is QA. If we were to treat this as a single register in which only (A) 
could 
be stored, we could scale down by 2~
p, but we must remember that the 
end-off right shift is in AQ. With a long left shift of 48 in AQ, we inter-
change (A) and (Q) and place the product in AQ. We can now follow by a 
long right shift of ρ in AQ. Since Q can be stored directly, however, a 
simpler technique is available. If we consider the 96-bit number in QA, the 
48 bits of Q alone are the same as those we get by multiplying by 2
- 4 8 and 
rounding off. That is, omission of (A) 
is equivalent to an end-off right 
shift of 48. If we shift left by an amount λ in QA and then store (Q), it is 
the equivalent of an end-off right shift of ρ = 48 — λ, so we use λ = 48 — p. 
We can look at this in another way. A long right circular shift of ρ in A Q 
will place the desired product digits in A. This must be achieved by a long 
left circular shift of 96 — ρ in AQ. With the selected digits now in A, we 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
135 
can place them in Q by an additional long left circular shift of 48 positions. 
Since a left shift of 96 is redundant, the combination of these two shifts 
can actually be effected by a single left shift of λ = 48 — p. 
We must remember that in circular shifting, no digits are lost, and the 
digits discarded from the product will be left in either A or Q. Furthermore, 
we cannot discard more than 48 bits at one time. 
Example 4-17. We illustrate by some examples of scaling multiplication 
on the C D C 1604. 
(a) We wish to form, scale and store the product of 
η = # 2
2 4 
and 
m = M 2
3 5 
No further information is available about the size of 
NM. 
In this case our best estimate of ρ comes from inequality (4-5). Assuming 
correct storage of properly scaled Ν and M, we must have \ N \ < 2
2 3 and 
I M \ < 2
1 2, so that | NM \ < 2
3 5. In equality (4-7) we have p' = 35, 
s = 24, t = 35, a = 47 to give ρ > 35 + 24 + 35 - 47 = 47. That is, the 
machine forms NM2
b9, 
and because of our estimate of | NM | we must 
scale down to at least 2
1 2. For optimum scaling for our estimated bound, 
ρ = 47 and we left shift 48 — 47 = 1 and store Q, as follows: 
12 0 
l{n) 
07 0 00001 
24 0 
t(m) 
21 0 
l(NM2
12) 
Put η in A and form nm in QA 
Scale down and store NM2
12 
(b) We wish to form (NM 
+ L) where it is known that Ν and M are 
between .04 and .05 and L is between .07 and .08. All are stored properly 
and scaled as ΛΓ2", M2
61 
and L2
6 0. We know that | NM \ < .0025 < 2 "
8 
and, hence, for the product, ρ > 51 + 51 — 8 — 47 = 47. Optimal scaling 
of NM requires the choice of ρ = 47, but this would give ΝΜ2
6δ, 
and the 
scale factor of NM must match that of L. Since | NM + L \ < .0825 < 2~
3, 
no overflow occurs in addition, if we scale the sum at 2
5 0. Hence, we align 
NM and L by selecting ρ = 52 to form (ΝΜ)2
δ0. 
This requires shifting 
by more than 48 and we cannot use the technique of part (a). Instead we 
form the product in QA, shift left in AQ by 48 to put the product in AQ. 
We follow this by a long right (end off) shift in AQ of 4. Omission of (Q) 
supplies the additional right shift of 48, which leaves the properly scaled 
product in A where we can complete the operation by adding L. 
4-2.3. Scaling Division 
Suppose we have η = Nr
8 and m = Mr
1 and we wish to divide M by 
Ν. Direct division with machine representations gives integers of q, the 
quotient, and p, the remainder, which satisfy 
m = nq + ρ 

136 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
The unsealed quotient and remainder satisfy 
M = NQ + Ρ 
and the scaled version of this with machine representations is 
Mr
1 = (Nr*) (Qr
x) 
+ 
(Pry) 
or 
Mr
0 
= NQr*
+x~
l 
+ 
Pr*-
1 
To obtain M = NQ + Ρ correctly, the scale factor for each term must 
be the same, that is 
s + χ — t = y — t = 0 
or 
χ = t — s 
and 
y = t 
This means that an unmodified division of m by η will always result in a 
quotient scaled at r
l~* and a remainder scaled the same as the dividend, 
at rK In general, the scale factor r'~* will not be desirable. A simple ex-
ample shows why. Suppose in a ten place decimal machine, we wish to 
divide 4 by 3, each optimally scaled at 10
8. We form (4) (10
8)/(3) (10
8) = 
1.3333 . . . . However, at a scaling 10
8~
8 = 10°, the quotient given by the 
machine is 1, and only one digit has been retained. We should have ar-
ranged for the optimal scale factor of 10
8 for the quotient also. We can 
handle this by essentially reversing the procedure for multiplication. Since 
division is the inverse of multiplication, the dividend must ordinarily first 
be placed in the same double length arithmetic register in which products 
are formed. This permits us to scale up the dividend by a left shift, prior 
to division. We enter the dividend Mr* and left shift by λ to produce 
A f r
i +\ Division by Nr* then gives 
M
rt + \ 
= 
( # r. ) (Qr«) + 
(prv) 
with 
χ = t + λ — s 
and 
y = t + λ 
The rule for finding λ is based on the usual requirement that Qr* must fit 
into a standard register, that is, so that | Qr* \ < r*+
p < r
a
) where ρ is 
such that 
r*"
1 < I Μ/Ν I < r* 
We can apply inequality (4-2) to determine the range of scale factor expo-
nents which will permit storage of a quotient Q of the given magnitude. 

4-2. 
SCALING FOR INTEGRAL 
FIXED POINT 
OPERATION 
137 
This inequality gives 
ρ + χ < a 
or 
P+t 
+ λ 
s < a 
with 
(4-8) 
λ < a + s 
ρ - t 
Optimal scaling is given by the maximum value of the left shift count 
λ = a + s — ρ — ty which retains all possible quotient digits. Again, if ρ 
is not known, it must be estimated from | Μ/Ν 
\ < r
pf to give 
If p' < p, division overflow may take place. If p' > p, a correct result will 
be obtained, but again significance is lost for ρ' > ρ because of under-
shifting. The method of achieving the left shift λ is dependent on the ma-
chine, but it must always be the equivalent of multiplication by 
r\ 
In the CDC 1604, the divide integer operation requires prior placement 
of the dividend in the QA register, in proper complement form. If the 
dividend is formed by multiplication, it will generally be in the correct 
form. If it is to be extended to 96 bits from a 48-bit register, it must have 
the 47 possibly significant bits surrounded by sign bits. That is, if the 
dividend in a 48-bit register is 647&46· · *&o, it must appear in QA as 
with at least one sign bit in the high order position of Q. 
If the sign bit is known, we can achieve the extension by loading the 
dividend in A, loading all sign bits in Q, and circularly left shifting by λ. 
If the sign bit is not known, we can load the dividend in A and follow this 
operation by a right shift of 48 in AQ. This end-off shift replaces the original 
content of Q by the 48 bit dividend and fills A with sign bits. We now have 
in the register QA the original dividend multiplied by 2
4 8. We actually 
wish to multiply by 2
λ, where λ is determined from inequality (4-8), so 
we must compensate. If λ < 48, we need a right shift ρ for which λ = 48 — p, 
or ρ = 48 — λ. We must not use the end-off right shift in AQ however, 
since this would cause a loss of significant digits in Q, so we use a circular 
left shift of 96 — ρ = 48 + λ. If λ > 48, we simply make the initial right 
shift 48 — λ, after obtaining the correct sign bits in Q. 
Example 4-18. The number 4 scaled at 2
4 4 is to be divided by the num-
ber 3 scaled at 2
4 5. The quotient i < 2 and can be scaled at 2
4 6; that is, 
λ < a + s — p
f — t 
96 bits 
647 ·· · btfh 
sign bite 
>47&46' * * W>47' * *î>47 
;s 
sign bits 

138 
4. FIXED AND FLOATING POINT ARITHMETIC) SCALING 
2000 0000 
0000 0000 
unknown 
and follow by a right shift of 48 in A Q to give 
A 
Q 
0 
- 0 
2000 0000 
0000 0000 
We follow this with a left shift of 95, which is a circular right shift of one, 
to obtain in AQ 
A 
π 
π 
U 
Q 
1 0 — 
0 
10-
or 
'inQAy 
0 
0 
0 
We see that (QA) 
= (4) (2
4 4) (2
4 7) = (4) (2
9 1). A code for these operations 
is given by 
12 0 /((4)(2«)) 
03 0 00060 
II (QA) = (4)(2
9 2). 
07 0 00137 
25 0 /((3)(2
4 6)) || Divide (4)2« by (3)2« to get (J)2
4 e. 
Example 4-19. Af, scaled at 2
4 3, and N, scaled at 2
4 0, are both stored, 
optimally scaled, and we wish to form M/N. 
We have from inequality 
(4-5), because of optimum 
scaling, 
2* < I M I < 2
4 
2
1 < I Ν I < 2
2 
so that 
I l/N I < 2 -
1 
and 
I Μ/Ν 
I < (2
4)2-
1 = 2
8 
a = 47, s = 45, t = 44, and ρ = 1, and from inequality (4-8) we need a 
left shift 
λ < 47 + 45 - 
1 - 44 = 47 
To form (4) ( 2
4 4 + λ) / ( 3 ) (2
4 5) = (i)2
x~
1, with an optimal scale factor expo-
nent of λ - 
1 = 46, we use λ = 47. We put (4) (2
4 4) = (2) (2
4 5) in A to 
give 
A 
Q 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
139 
With p' = 3 we have from inequality (4-8), 
λ = 47 + 45 - 3 - 43 = 46 
Note the importance of a lower bound for the divisor, ΛΓ, since a knowledge 
of an upper bound only would be useless. 
4-2.4. Integral Operation Combinations 
When we code a complete problem for the computer, we will generally 
have to combine all of the scaling procedures discussed in the previous 
sections. In addition, we may need to use some analysis to estimate ap-
propriate bounds on quantities which will arise in the computations. 
Whether we choose to use optimal scaling at each step will depend on the 
kind of accuracy we need. We have seen that less than optimal scaling 
may be necessary for addition and subtraction to line up the base point. 
In other instances we may choose to use less than optimal scaling as a 
matter of convenience. 
Consider, for example, two problems. Suppose we wish to tabulate on 
the CDC 1604 the function f(x) 
= x
2 for values of χ in increments of 0.01 
for all χ in the range 100 < χ < 125. Because of the range of values on χ 
we have, for all χ, 2
6 < χ < 2
7 and can optimally scale χ at 2
4 0. Similarly, 
we have 10,000 < x
2 < 15,625, and all functional values satisfy 2
1 3 < 
\f(x) 
I < 2
1 4 so we can scale f(x) 
at 2
3 3. On the other hand, suppose the 
range of values for tabulations had been 0.01 < χ < 10. For 
optimal 
scaling, this would require that we scale 0.01 at 2
5 3, but since 2~
6 < 0.02, 
0.03 < 2"
5, we must scale 0.02 and 0.03 at 2
5 2. Similarly, 2~
5 < 0.04, 0.05, 
0.06 < 2~
4, so we must scale at 2
5 1, and so on up to values of χ for which 
8 < χ < 10, giving 2
3 < χ < 2
4 and an optimal scale factor for χ of 2
4 3. 
An even more detailed breakdown into groups would be required for x
2. 
It is evident that such scaling would greatly increase the difficulties of 
both the preliminary analysis and the coding of the program. It is also 
evident that in writing such a program, we would increase the amount of 
computer time involved, and this may be expensive. On the other hand, 
since all χ and x
2 satisfy χ < 2
4 and x
2 < 2
7, we could correctly (but not 
optimally) scale them at 2
4 3 and 2
4 0. In χ this would produce a loss, from 
the largest optimal scale factor of 2
5 3, of ten bits or about three decimal 
digits, leaving about twelve significant decimal digits. In many cases we 
may tolerate such a loss of accuracy and will choose to do so to gain greater 
simplicity in scaling and programming. 
We will illustrate these ideas further by coding some simple problems 
involving the scaling of combinations of arithmetic operations. 

140 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
Example 4-20. We wish to compute a table of values for the function 
4.6a:
2 - 0.9a; + 4.9 
f ( x ) 
= 
5 I T ^ 
for values of χ in 0 < χ < 1 in increments of Ax = 0.01. The first step is 
to obtain upper bounds on all quantities which will arise in the computa-
tion. Since 0 < χ < 1, a scale factor of 2
4 6 or less will scale any power of 
χ without overflow. For simplicity, we choose to scale χ and x
2 at 2
4 6. The 
inequalities 
2
2 < 4.9 < 2
3 
2 -
1 < I - 0 . 9 I < 2° 
2
2 < 4.6 < 2
3 
tell us that we can scale these constants in the numerator at any factors 
no greater than 2
4 4, 2
4 7, and 2
4 4, respectively. Since | χ | and all powers of 
I χ I are no greater than one, we can use the same scale factors for these 
individual terms. For addition, however, we must have a common scale 
factor, so we might choose 2
U, but we note that the complete numerator 
has a maximum value of 8.6 for χ = 1 and must be scaled at 2^ or less to 
avoid overflow. Accordingly, we choose to use this scale factor for the 
entire range of x} and we scale the terms in the numerator: 
(4.6x
2)2
43 
( - 0 . 9 x ) 2
4 3 
and 
(4.9) 2
4 3 
Since the constants 4.6 and 0.9 enter as factors, we can scale them (4.6) 2
4 4 
and (0.9) 2
4 7 and round off the products to 2
4 3. 
In the denominator 0.1 < 0.1 + x
2 < 1.1 < 2 for all admissible x, so 
that we can scale 0.1, x
2
y and 0.1 + x
2 at 2
4 6. Finally, we consider 
f(x). 
Since | 4.6a:
2 - 0.9a: + 4.9 | < 8.6, and | 0.1 + χ
2 \ > 0.1, we have | f(x) 
\ < 
8.6/0.1 = 86 < 2
7 and can scale f(x) 
at 2
4 0. A sharper bound might be 
made by analyzing absolute maxima for f(x), 
but we content ourselves 
with the simpler bound. 
The actual scaling operations in the program will depend on the method 
we use to compute. For example, if we use finite difference techniques to 
tabulate values of the numerator and denominator, the scaling steps would 
be different than if we compute them directly. For illustration here we 
will assume that we compute x, 0.9a:, a:
2, 0.1 + x
2, 4.6a:
2, 4.6a:
2 — 0.9a: + 4.9, 
and /(x) in that order. 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
141 
We first assign storage locations for intermediate results and program 
parameters as follows: 
00 
(*)*· 
ßl 
(0.9χ)2* 
β* 
(χ«)2<« 
ßz 
(0.1 + *
2)2*
6 
β* 
(4.6ζ
2)2« 
δο 
(4.9)2*3 
(0.9)2« 
(0.1)2« 
δι 
(4.6)2« 
(0.01)2« 
«· 
zero 
We make no attempt to write the most efficient program, but rather 
consider the most straightforward, to illustrate the handling of scale 
factors. We start instructions relative to a 0 and begin by storing suitable 
initial values of addresses and parameters. 
U 
«0 
Oil 
50 
10 
12 
1 00144 
0 ωο 
0 δδ 
50 
61 
20 
00000 
« 1 4 
00 
Set counter index to lOOio. PASS. 
Set storage ω» for f(x) to initial value ωο. 
Set χ = 0 initially. 
We are now prepared to enter the main computational loop starting with 
χ = 0. 
U 
12 
107 
0o 
00060 
20 0 A 
24 0 
01 0 
«1 
00002 
12 0 βο 
(0.9x)2
M -> QA. 
(0.9z)2
M -> AQ, 
(A) = (0.ftc)2«. Scale down to 
(0.9*)2«->ii. 
(O.9s)2«->0i, 
(x)2"^>A. 
The first pair of instructions forms (0.9a:)2
9S in QA. We need to scale 
the product down to 2
4 8, requiring a right shift of 50. Since the long right 
shift is in AQ, we put (0.9s) 2
9 8 into AQ with a long left shift of 48. This 
leaves (AQ) 
= (0.9x)2
n 
or (A) 
= (0.9z)2
t t, and an end-off right shift 
of two in A alone gives us (A) 
= (0.9x)2
4 3, which we store. With 
(x)2
46 
in il, we compute x
2 and scale it. 
α, 
Κ 24 0 /3o 
07 0 000021| (s*)2
M -> QA, 
(Q) = (x*)2** 
The upper instruction in a e forms (x*)2
n 
in QA, with (Q) = (x
2)2
u. 
Since 
we wish (s
2)2
4 e, we left shift two in QA to form (Q) = (x
2)2*\ 
We wish 

142 
4. 
FIXED AND FLOATING POINT ARITHMETIC; 
SCALING 
to store this last result and also to form (0.1 + x
2)2
4 6. For the addition, 
we need (x
2)2
4 6 in A. 
« 7 
« 1 0 
21 0 0 2 
07 0 00060 
14 0 δ2 
20 0 & 
χ 2 · 2
4 β —• 02 and A 
(0.1 + χ
2)2
4β 
0 3 and A 
We next form (4.6a:
2) 2
4 3. 
« 1 1 
« 1 2 
12 0 δ3 
07 0 00061 
24 0 fr 
15 0 0i 
(4.6x
2)2
90 
QA 
(4.βχ»)2« 
A, 
(4.6z
2 - 0.9x)2« -* Λ 
The product (4.6α:
2)2
90 is formed in QA. We need (4.6a;
2)2
43 in A. A left 
shift of 48 would put (4.6o:
2)2
90 in AQ, with (A) 
= (4.6x
2)2
4 2. Thus, one 
additional left shift, or a total of 49, puts (4.6x
2)2
43 in A, and we can 
correctly subtract (0.9x)2
4 3. One more addition step gives us (4.6a:
2 — 
0.9a: + 4.9)2
43 in A. Before division by (0.1 + x
2), the dividend must be 
in QA, and to scale/(x) at 2
4 0 we need 
integral part -[ 
(4.6a:
2 - 0.9x + 4.9)2' 
(0.1 + r>)2
46 
'h 
/ ( x ) 2
4 0 
Therefore, we must arrange to put (4.6a:
2 — 0.9a: + 4.9)2
8 6 in QA. To begin 
with, we have (4.6a:
2 — 0.9a: + 4.9)2
43 in A. An end-off long right shift of 
48 fills A with sign bits and discards the unrelated digits of Q. This puts 
the numerator scaled at 2
4 3 in Q and extends it into AQ with the same 
scaling, or into QA with a scaling of 2
9 1. However, we wish our dividend in 
QA to be scaled at 2
8 6, so we need a further right shift of five. We combine 
the two into a single shift of 53 to give (QA) 
= (4.6a:
2 - 0.9a: + 4.9)2
8 6 
and the sign bit properly extended in QA. The divide integer operation is 
now used to form f(x), 
and we are ready to go on to compute the next 
values of χ and 
f(x). 
« 1 3 
« 1 4 
« 1 6 
« 1 6 
14 0 δ0 
03 0 00065 
25 0 
03 
20 0 
ω. 
12 0 0o 
14 0 δ4 
20 0 0o 
72 0 
« M 
(4.6x
2 - 0.9* + 4.9)2*
β 
/(x)2
40 -+ A and ω. 
χ·2«-+Α, 
(χ + 0.01)2
4β 
Next χ —• 0ο, ω,· —» ω»·+ι 
QA 
The last set of instructions computes the next value of χ for which 
f(x) 
is to be tabulated, stores it in β0, and advances the storage location for 
the next f(x). 
We are now ready to reloop if necessary. 
EXIT «π 
II 55 
1 « 3 
76 0 00000 || All values? If not, reloop, otherwise stop. 

4-2. 
SCALING FOR INTEGRAL FIXED POINT OPERATION 
143 
We used a minimum of indexing in order to emphasize scaling. We suggest 
that the reader simplify the code to cut down on prestoration operations 
by using indexing. 
In the preceding example, the scaling was straightforward and rather 
simple, since appropriate bounds on all quantities were obvious. In other 
cases a more sophisticated, and possibly more roundabout, analysis may 
be required. We present another example to illustrate a possible approach 
which might be used. 
Example 4-21. We wish to tabulate on the CDC 1604 values of a func-
tion, y(x), which satisfies the differential equation dy/dx 
= y + χ and the 
initial condition y(0) 
= 1. The interval of tabulation is 0 < χ < 1. For 
this simple linear equation we can find the explicit solution y = 2e
x — χ — 1, 
and one possibility is to use direct computation of the function, with 
scaling bounds easily found, as in Example 4-20, and dependent on the 
way we choose to compute e
x. For illustrative purposes, however, we will 
assume (as is frequently the case) that no explicit solution is known and 
that we must have recourse to some numerical method of approximating 
the solution. We choose a method which uses the finite difference quotient 
Ay/Ax 
as an approximation to the derivative dy/dx. 
We subdivide the 
interval 0 < χ < 1, into Ν equal subintervals of length Ax = h = 
1/N 
by means of the set of points 0 = xQ < X\ < x2 < · · · < xN 
= 1, with 
xn = nh. At the point xn+iy 
we compute the approximate value of the solu-
tion function yn+i 
from the approximation to the differential equation, 
= y η 
+ 
Xn 
AXn+1 
with Ayn+i 
= 2/n+i — 2/n. We replace the initial condition by y0 = 1. Since 
Axn+i = Ax = A, we can write this approximating difference equation 
àyn+i 
. 
. 
—— 
= y η + nh 
η 
in the form yn+i 
= yn + hyn 
+ nh
2. Starting with η = 0, we can then 
compute yh y2, yz, · · ·, y η in turn. 
We start our scaling procedure by noting that all χ in the interval satisfy 
I χ I < 2, and hence, we can correctly, if not optimally, scale χ and Ax = h 
at 2
4 6. We must now determine bounds on yn. In this example, the scaling 
could be made simple because of our ability to obtain an explicit solution 
of the difference equation. In general, with such problems this will not be 
possible, and a different approach will be required. Here, for example, we 

144 
4. FIXED AND FLOATING POINT ARITHMETIC ) SCALING 
proceed as follows. Since yn+i 
= (1 + h)yn 
+ nh? and nh < 1, all n, 2/n+i < 
(1 + h)yn 
+ h] and if yn < En, then 
2/n+l < (1 +h)En+h 
= En+! 
Because y0 = 1, we can take E0 = 1 and obtain, in order, 
2/1 < (1 + h) + h = 
Ex 
2/2 < (1 + A)
2 + (1 + h)h + h = 
E2 
2/3 < (1 + A)
8 + (1 + h)*h + (1 + h)h + h = 
Ez 
2/n < (1 + h)
n 
+ (1 + Α)
η _ 1Λ + ··· + (1 + h)h + h = 
En 
= (1 + h)» + A[l + (1 + h) + . . . + (1 + 
A ) -
1 ] 
Summation of the geometric sum gives yn < 2(1 + h)
n 
— 1 and we see 
that this is maximal for η = Ν so that 
2/0 = 1 < 2/n < 2(1 + h)
llh 
- 1 < 2e - 1 < 2
8 
Hence, we can correctly scale 2/n at 2
4 4. If we now choose to compute yn+i 
from 2/n+i = 2/n + h(yn 
+ xn), we must scale xn and A(2/N + xn) also at 2 " 
for addition. For simplicity we could then scale xn, yn and Ax = h at 2**, 
with z n2
4 4 = (x n_i + A)2
44 and 2/ n +i2
4 4 = [2/n + h(yn 
+ Xn)¥" 
and the 
only rounding procedure would be to reduce h2
u(yn 
+ xn)2" 
to h(yn 
+ 
x„)2
4 4. We leave it to the reader in the exercises to write the programming 
steps required. 
4-3. Fixed Point Integral Arithmetic in Control and Index Registers 
In the previous sections, we have discussed techniques for carrying out 
arithmetic operations in the fixed point integral mode. These techniques 
relate to the basic problem arithmetic as done in the primary computing 
registers, and are generally concerned with providing the true location of 
the binary point, while properly preserving the algebraic sign. House-
keeping arithmetic can also be done in these primary registers, and the 
previous results applied. In many computers, however, there are auxiliary 
registers whose function is to provide the control and housekeeping arith-
metic. The use of these registers may require a different attack. 
The problems which are handled in the auxiliary control registers are 
those related to address modification, counting of loop traversais, and so 
on. The addresses and indices which arise can be treated as nonnegative 
integers. Hence, we have only a trivial problem of scaling and do not 
require allocation of a digital position for sign determination. It might 

4-3. 
CONTROL AND INDEX REGISTERS 
145 
appear, then, that we would have no need for complement arithmetic, but 
there are two reasons why we do. In the first place, we are always dealing 
with a finite number of digital positions, and this imposes a requirement 
that arithmetic be done relative to a modulus compatible with the number 
of positions available. In the second place, we will need to be able to in-
crease and decrease addresses, and we will need to count down as well as 
count up. Since most machines have only one basic operation, we will use 
complement arithmetic to achieve both addition and subtraction. The 
problem for the coder is that he must be aware that the different require-
ments and interpretations of housekeeping arithmetic are distinct from 
those of problem arithmetic, and this may demand precaution in certain 
programming situations. 
Consider, for example, the control register which is designed to hold 
the address of the location from which the control accepts its current in-
struction. In computers whose normal mode of operation is the acceptance 
of instructions from sequentially addressed registers, the program address 
register will also be a counter. The operation required is to increase its 
content by one for each instruction executed; and if this process continues, 
the register will finally contain its maximum representation, with a con-
tent which is the largest possible address for a storage register. At this 
point, an increase of one should take the content back to zero, since count-
ing must be closed for the finite range of addresses. This means that the 
counting must be equivalent to that of r's complements (modulus = 
r
n). 
If (r — l ) ' s complements were used, the address zero would always be 
skipped. The reason for this is that the positive and negative zeros of 
(r — l ) ' s complement arithmetic can no longer be interpreted as the same 
entity. They represent, respectively, the two distinct registers with the 
zero and maximum addresses. We illustrate with an example. 
Example 4-22. In the C D C 1604, the program address counter Ρ uses 
two's complement (mod 2
U) counting. To see the reason for this, we assume 
( P ) = 77777 and consider the effect of adding one in one's complement 
and in two's complement operation. 
(a) If one's complement (mod 2
1 5 — 1) counting is used, we have 
( P ) r = 
77777 
+ 1 
00000 
End around 1 
1 
( P ) F = 
00001 
and address 00000 is skipped. 

146 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
Register 
Modulus 
Complement 
Arithmetic 
Ρ 
216 
Two's 
Additive 
R 
Two's 
Subtractive 
U* 
2i» - 1 
One's 
Subtractive 
The basic arithmetic of Ρ is that of counting (or successive addition of 
one) to provide sequential operation. The R register has provisions for 
counting and complementing. The U
2 register is an auxiliary subtractive 
accumulator used primarily for address modification (see Chapter 2). We 
illustrate some of the possible idiosyncracies with examples. 
Example 4-23. An index skip instruction 54 
1 
00000 is executed as a 
lower program step with (B
1) 
= 77777. Since y τ* ( 5
1) , (JB
1) is increased 
by one in R and a half exit is made back to the same instruction. Since R 
is a two's complement register, (JB
1) + 1 = 00000 and the next execution 
will provide a full exit. 
Example 4-24. A load A instruction 12 
1 
00001 is executed with 
(B
1) 
= 77777. The effective address is obtained by sending 00001 to U
2 
and 77777 to R. These are then added in I/
2, which is a one's complement 
accumulator. The result is (B
1) 
+ 1 = 00001, as the effective address. 
(b) If two's complement (mod 2
1 6) counting is used, we have, correctly, 
( P ) r 
= 
77777 
+ 1 
Discarded 
1 
00000 
(P)F 
= 00000 
We see that "negative zero" or 77777 cannot be interpreted as "positive 
zero" or 00000. 
We make no attempt to give any general rules, since individual com-
puters will vary in their treatment of address modification and counting 
procedures. In most cases, the design will be such that normally expected 
results will be obtained in all ordinary situations; however, the coder 
should be aware that special situations do arise, and he should be thoroughly 
acquainted with the functioning of control section arithmetic in the particu-
lar computer he is using. 
In the CDC 1604, there are three fifteen-bit auxiliary arithmetic registers. 
These, with their characteristics, are given below. 

4-4. 
SCALING FOR FRACTIONAL FIXED POINT OPERATION 
147 
We see that in the two examples, with (B
1) 
= 77777 in each case, the 
value of (B
1) 
+ 1 is zero or one, depending on which auxiliary register is 
used to do the arithmetic. This can result in skipping an address in a given 
range; or it can result in repeating an instruction with the same address on 
successive traversais of a loop. 
4-4. Scaling for Fractional Fixed Point Operation 
We have considered the problem of scaling for computers in which 
arithmetic operations treat sequences of digits as integers, with an imagi-
nary base point at the right hand end of the sequence. Other machines 
treat such sequences as fractions between zero and one. The most common 
arrangement is to perform operations as though the base point were im-
mediately to the right of the sign digit, that is, at the left-hand end of any 
sequence of possibly significant digits. If we think in terms of long hand 
computation, there seems to be no real distinction between the two meth-
ods. For example, in a two-digit decimal machine, there is no apparent 
difference between adding ( + 1 ) to ( + 1 ) , as 01 + 0 1 = 02 on an integral 
machine and in doing 0.1 + 0 . 1 = 0.2 on a fractional machine. If we con-
sider multiplication, however, we see that in a two-digit decimal machine 
with a double length register we would have (01) (01) = 0001 on an inte-
gral machine, but (0.1) (0.1) = 0.010 on a fractional machine. In other 
words, in an integral register we would have the sequence of digits 0001, 
and in a fractional register we would have 0010. The digits are the same, 
but they must be positioned differently; and this, of course, affects the 
scaling. 
We consider a fractional complement machine, base r, with a + 1 digits 
to a register, so that numbers are treated as dfd-id-2* 
· «cLa with d 0 the 
sign digit. We can think of such fractional complements as being obtained 
from integral ones by multiplication by r~
a. Positive and negative zero are 
0.00· · ·0 and (r — 1) · (r — 1) · · · (r — 1), and the largest positive number 
which can be represented is 0.(r — 1) (r — 1) · · · (r — 1) = 1 — r~
e. This 
means that the fractional machine representation is zero or satisfies the 
basic inequality 
r~
a < I η I < 1 - 
r~
a 
that is, we must represent the actual number Ν by the rounded-off 
a-place 
number in 
0 < I η I < 1 
The problem of finding a satisfactory representation for Ν is made 
easier if we relate it to the corresponding problem for the integral machine. 

148 
4. FIXED AND FLOATING POINT ARITHMETIC ) SCALING 
It follows from inequality (4-0) that for integral representation of Ν in 
a + 1 digits, we must obtain an integer n' for which n' = integral part of 
N*r* and 
I η' I < r
a - 1 < r
a 
To convert this for fractional operation, we move the binary point to the 
left end of the a low order digits to obtain a machine representation η = 
n'*r~
a which gives, correctly, 
I η ' τ -
β I = I η | < 1 - r~
a < 1 
For the integral machine we retain only the integral part of the scaled 
number. Hence, assuming correct integral scaling, we find the properly 
truncated fractional representation by using the integral representation 
multiplied by r~
a. 
Example 4-25. Consider the number two-thirds, in binary equal to 
0.101010 . . . . We see that on a 3-bit, 5-bit and 7-bit integral machine we 
would have optimally scaled integral machine representations: 
integral part of 
[ f · 2
2] = integral part of 
[010.1010 
] = 010 
integral part of 
[ f · 2
4] = integral part of 
[01010.1010 ....] = 01010 
integral part of 
[ f · 2
β] = integral part of 
[0101010.1010..] = 0101010 
The conversion to fractional requires that we multiply by 2~
2, 2
- 4, 2~
6 to 
obtain 0.10, 0.1010, 0.101010, respectively. 
We must determine the value of the scale factor r* for the fractional 
machine representation η of a number Ν so that 
Ν = η·τ~
α 
(to within round off) 
and we can write, as usual, 
η = Nr
8 
We have 
η = n'«r~
a = Nr*'~
a = Nr
9 
and therefore 
s = s' — a 
In other words, if the scale factor exponent for integral operations is 
properly s', we may always use an exponent for equivalent fractional 
operation which is s = s' — α. Employing this idea, we recall that the 
bound 
2*-
1 < I Ν I < 2* 

4-4. 
SCALING FOR FRACTIONAL FIXED POINT OPERATION 
149 
is independent of whether we use integral or fractional scaling, and we see 
that the inequality (4-2) with ρ + s' = α, becomes 
(4-9) 
ρ + s < 0 
which is just the statement that 
I Nr
8 I = j Nr
9'~
a 
| < 1 - r~° < 1 
For most scaling problems, we can now push the integral interpretations 
to the background and proceed straightforwardly with inequality (4-9) 
as a guide. Thus, given ρ we find an appropriate s < — ρ and take | η | = 
I Nr* I as the first a digits to the right of the base point in | iV-r* | . The 
machine representation of η = Nr
8 
is then the properly complemented 
version of this with a sign digit to the left of the base point. As before, 
optimal scaling will be given by choice of the maximum s in the permissible 
range, that is s = —p. For each decrease of s by one, we will lose one 
significant digit. The inequality (4-9) can also be used to determine, for 
given s, the magnitude of numbers which can be scaled at r
8 in a fractional 
complement machine. 
Although use of inequality (4-9) is straightforward, we must avoid 
detours introduced by the idiosyncracies of computer operation. For ex-
ample, if a number is contained in an ordinary register and transmitted to 
a double length register, the effect on scaling in the integral and fractional 
cases is not the same. Consider the sequence 0101 transferred from a four-
bit to an eight-bit register, where it is extended. The eight-bit representa-
tion is 00000101. In an integral machine, both the four and eight-bit num-
bers are interpreted as 101. However, in a fractional machine, t h e y are 
interpreted as 0.101 and 0.0000101, respectively. That is, the extended 
number in the fractional machine has been multiplied by 2~
4, and, in 
general, an extension from an (a + 
1)-digit 
register to a double 
length 
2(a + 1)-digit register is equivalent to multiplication 
by r~
( a + 1 ). In the reverse 
direction, deletion of the (a + 1) high order digits of the double length 
register multiplies by r
a + 1. 
We will illustrate fractional scaling by redoing some of the previous 
examples. We consider fractional operation on the CDC 1604 with r = 2, 
a = 47. 
Example 4-26. Find suitable scale factors for the decimal 
numbers 
Ν = 3.1416, -0.0003, and 27000. We see that 
2 < I 
3.1416 I < 2
2 
2-12 < I -0.0003 I < 2 -
1 1 
2 " < I 
27000 I < 2
1 δ 

150 
4. FIXED AND FLOATING POINT ARITHMETIC J SCALING 
We can proceed directly, using inequality (4-9), with pi = 2, p
2 = —4, 
and pz = 15, to get 
si < 
- 2 
s 2 < 11 
and 
S3 < 
- 1 5 
with optimal scaling given by the equality sign. Alternately, we note that 
the integral scale factors from Example 4-9 are $i = 45, s 2' = 58, and 
Sz = 32. Subtraction of 47 from each of these gives the same results as 
above. 
Example 4-27. (a) The decimal number Ν = 586.25 is to be optimally 
scaled (fractional) and put in a 48-bit register. What is the octal form of 
the machine representation? 
Since 2
9 < 586.25 < 2
1 0, s + 10 < 0 and s = - 1 0 gives optimal scaling. 
Hence, we have 
(586.25)ιο·2-
10 = (293.125)ιο·2-
9 = (445.1) 8·8-
8 = .4451 8 < 1 
Now, however, we have to affix the sign digit zero before the point. The 
48 binary digits for 0.4451s are 0.1001001010010. . .0; regrouping in threes, 
we get 0.10 010 010 100 100 0. . .0. Since the binary point is imaginary 
in the computer, the actual octal content of the register will be 
2224 4000 0000 0000 
the same as the integral representation in Example 4-11. However, the 
same sequence of 48 bits will need to be interpreted in one case as 
(586.25)2
37 = 01001001010010. . .0, and in the other as (586.25) 2~
1 0 = 
0.1001001010010. . .0. Although the internally stored digits of a number 
in the machine are the same for fractional and integral, the externally 
recorded scale factors and, hence, the scaling operations in computation, 
will be different. 
(b) The decimal number Ν 
= 
—0.046875 is to be optimally scaled 
(fractional) and stored in a 48-bit register. Give the octal content. Since 
2"
5 < j -0.046875 | < 2~
4, s - 4 < 0 and s = 4, optimally. Thus, 
(0.046875)ιο·2
4 = (0.093750) ι 0·2
3 = (0.06) 8·8 = (0.6) β 
The 48-bit representation is 0.11000. . .0, but the number is negative 
and we complement to get 1.00111. . .1. Conversion to octal 
gives 
4777 7777 7777 7777 [compare Example 4-11 ( b ) ] . 
Example 4-28. A 48-bit register contains the octal sequence 
3524 0000 0000 0000 

4-4. 
SCALING FOR FRACTIONAL FIXED POINT OPERATION 
151 
scaled as a fraction at 2
- 7. What is the decimal equivalent of the unsealed 
number? 
Since η 
= 
3524 0000 0000 0000 is interpreted 
as η 
= 
0.11 101 010 10...0 2 = # 2 -
7 , w e h a v e # = n 2
7 = 01 110 101 .010...0 2 = 
(165.2) 8 = 117.25io [compare Example 4-12(a)]. 
4-4.0. Scaling Fractional Addition and Subtraction 
Scaling operations for addition and subtraction are the same for frac-
tional as for integral operation. In each case, there are two requirements. 
One is that both operands must have the same scale factor in order to line 
up the base point. The other is that the sum or difference must not exceed 
the capacity of the arithmetic register in which it is formed. This means 
that to add or subtract operands M and ΛΓ, we must have M2
8 and 
N2
8 
and, if | M ± Ν \ < 2
P, s + ρ < 0. If we do not know ρ we must estimate 
it by I M =fc Ν \ < 2*'. 
Example 4-29. The numbers iV2~
29 and M2~*° are stored as fractions in 
the CDC 1604 and we wish to form their sum, which is known to be such 
that I Μ + Ν I < 2
8 0. With ρ = 30, the sum can be scaled at {M + 
N)2
8 
with s < —30, and we choose the optimum (M + iV)2~
3 0. We must first 
line up the binary point by scaling N2~*°. Suppose (01000) = N2~
29 
and 
(01001) = M 2 -
3 0. The instructions can be 
12 0 01000 
14 0 01001 
01 0 00001 
N2-*
9 -> A, right shift to put ΛΓ2~
30 in A 
(M + N)2r
i0 —• A 
Note that the instructions [compare Example 4-16(a)] are exactly the 
same as for integral operation. The only difference here is in our 
interpreta-
tion of the numbers. No separate code is needed for fractional addition 
and subtraction. 
4-4.1. Scaling Fractional Multiplication 
As we have just seen, the same addition and subtraction instructions 
can be used for both integral and fractional machine numbers, provided 
we interpret our operands properly. However, if we try to form the double 
length product of two fractional operands by use of the integer multiply 
instruction, the product digits will not be correctly positioned relative to 
the base point in the double length register. We have shown an example 
of this above for the case of a two-by-two decimal machine. Accordingly, 
in machines which operate on numbers represented in both the integral 
and fractional modes, there will be a distinct multiply operation for each 
mode. The multiply fractional instruction for the CDC 1604 has the form 

152 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
26 
b 
m. The result of the instruction is the formation of the 96-bit 
product of the operands initially in A and in Μ, where M = m + 
(B
h). 
We consider in this section only b = 0, M = m. The product is formed in 
the combined A and Q registers with the high order bits in A, that is, 
(A)(M) 
—> AQ. All numbers are treated as fractions with the binary 
point immediately right of the sign bit. Note the reversal of the register 
as compared to the multiply integer operation in which the product is 
formed in QA. With this reversal, the product is properly aligned for the 
addition or subtraction of a fractional operand from storage. 
As with integral multiplication, we need not make the scale factor expo-
nents equal. Furthermore, if | M2
t \ < 1 and | N2* \ < 1, then | MN2*+
l \ < 
1 and no overflow will occur, and no truncation of the product is required. 
We must remember, however, that additional digits retained in the double 
length register must be rounded off for storage of the product in an or-
dinary register. For fractional scaling, this will probably require scaling 
up the product, or the equivalent of a left shift, to avoid loss of significance. 
This is in contrast to the probable right shift after integral multiplication, 
and is one of the primary distinctions between scaling for fractional and 
integral operation. To use inequality (4-9), we must either know or esti-
mate a bound on the product as 
rp-i < I MN I < r
p 
or 
I Μ Ν I < r*> 
We form MNr*
+t 
in a double length arithmetic register. We apply inequality 
(4-9) with s replaced by s + t to obtain s + t < —p or s + t < —p'. 
In 
many cases, however, s + t will be less than the optimal scale factor expo-
nent for the products, and immediate truncation of the low order a + 1 
digits would produce loss of significance. Before storage, we pick up λ 
significant low order digits by a left shift λ with 
λ + s + t < 
- ρ 
and 
λ < 
-(p+8+t) 
The optimal scaling will occur if we use the maximum λ in the acceptable 
range, that is, if we shift the highest order significant digit immediately 
to the right of the base point before truncating. If ρ is not known exactly, 
we have 
λ < - ( ρ ' + 
β + 0 
Overestimation of p' may result in undershifting and loss of significance. 
Underestimating of p' causes overflow. 

4-4. 
SCALING FOR FRACTIONAL FIXED POINT OPERATION 
153 
The actual operations to multiply by r
x and truncate the result will, of 
course, vary from machine to machine. We consider some examples on 
the CDC 1604. 
Example 4-30. (a) We wish to form, scale and store the product of 
N2~
2Z and M2~
12. No further information is available about the size of 
NM. 
If Ν and M are properly scaled, we know that 
and 
I N\ 
< 2
2 3 
Ι Μ I < 2
1 2 
so that I NM I < 2
3 5. The actual product formed in AQ is (NM)2~*. 
With 
p' = 35 we have λ < 0 and, hence, to the best of our knowledge, no further 
scaling is required. However, for storage we must truncate the product to 
48 bits. This we do by storing (A) only. Instructions to accomplish this are 
12 0 t(N2r™) 
26 0 
/(M2~
1 2) 
20 0 /(AfiV2~
35) 
(MN)2-™ -+ AQ 
Store a 48-bit version of ΜΛΓ2"
35. 
(b) Given that 2 < M < 3 and 9 < Ν < 10 are optimally scaled and 
stored, we wish to form their optimally scaled product and store it. Optimal 
scaling gives Af2~
2 and N2~
A. We know, however, that MN 
< 30 < 2
5. 
With p' = 5, we find λ < 1, hence, we can scale MN optimally at 
(MN)2~
b. 
We form MN2~* in AQ and shift left one to scale (MN)2~
b. 
Instructions 
to accomplish this are 
12 0 
ί(Ν2~*) 
07 0 
00001 
26 0 
/(Af2-») 
20 0 
t(MN2~
5) 
{MN)2r* -
A, then storage 
4-4.2. Scaling Fractional Division 
It might at first appear that, as with addition and subtraction, separate 
operations are not required for fractional and integral division. Consider, 
however, the problem of dividing the sequence 04 by the sequence 03 on a 
two-decimal digit machine. The integral divide operation yields the correct 
quotient 01, with all three numbers scaled 10°. On a fractional machine, 
the first two sequences will be interpreted as 0.4 and 0.3, scaled at 10
_ 1. 
Accordingly, with no shifting before division, the quotient should be scaled 
at 10°, but the sequence given by integral division must now be interpreted 
as 0.1, which is incorrect. We cannot use the integral division on fractional 
operands unless scaling adjustments are made. Thus, to employ 
straight-
forward scaling procedures, we will need separate division instructions for 

154 
4. FIXED AND FLOATING POINT ARITHMETIC) SCALING 
integers and fractions. In fractional division, the important thing to keep 
in mind is that the scaling should be such as to generate as many significant 
quotient digits as possible, and yet avoid overflow. As usual, we need at 
least an estimate of the size of the quotient. Suppose we wish to divide 
Mr* by Nr
8. In most computers we will be required to put Mr* in a double 
length dividend register in a properly extended version, and then divide. 
Straightforward division will produce a quotient represented by the ma-
chine number, {M/N)r
1-
8 
and if | Μ/Ν 
\ < r
p, then inequality (4-9), with 
s replaced by t — s, yields the requirement that 
ρ + t - s < 0 
If this requirement is not met, we will have quotient overflow at the given 
scaling. On the other hand, if ρ + t — s is too small, we will not generate 
all possible significant digits at this scaling. If the overflow condition exists, 
we must decrease the scale factor of the dividend by a right shift; but if 
too few significant digits will be generated, we must increase the dividend 
scale factor by a left shift. We assume that by a right shift of ρ places, we 
apply a factor r~
p to the dividend before division. The machine quotient 
is then Qr
1'^
8 
and inequality (4-9) yields the requirement for p, 
ρ + t - ρ - s < 0 
Solving for p, we get 
ρ > ρ + t — s 
where everything on the right is known. If we must estimate ρ by p', we 
get 
P> 
p' + t - s 
If ρ is positive, as will ordinarily be the case, a right shift of ρ places before 
division suppresses the generation of ρ quotient overflow digits. If ρ is 
negative, a left shift of | ρ | places before division will pick up | ρ | addi-
tional significant quotient digits. In either case, for optimal scaling within 
the limits of knowledge given by ρ or p', we choose ρ as small as is 
permissible. 
A remainder will be left behind in the double length dividend register at 
the conclusion of the division operation. This double length machine num-
ber will have the same scale factor as the dividend had just prior to the 
initiation of the divide operation. If the remainder is removed to a single 
length register, its base point is effectively moved a + 1 places to the right, 
and so the scale factor exponent must be increased by a + 1. The divide 
fractional instruction on the CDC 1604 has the form 27 
b 
m. The 
dividend must be loaded into AQ in a properly extended form, and the 

4-4. 
SCALING FOR FRACTIONAL FIXED POINT OPERATION 
155 
result is (AQ) / (M)—>Ay where M = m + (B
b). 
The remainder is left in 
Q. All operands are treated as fractions, with the binary point just to the 
right of the sign bit. Again we note the reversal of A and Q as compared 
to the integral operation. This reversal gives proper alignment of the base 
points for addition and subtraction in A. 
Example 4-31. The number (4) (2~
3) is to be divided by (3) (2~
2) in the 
CDC 1604. The quotient i < 2, and can be scaled at 2"
1; that is, t = - 3 , 
s = —2, and ρ = 1, so 
and no right shift prior to division is required for optimal scaling. However, 
we must load (4) (2~
8) into AQ and extend it properly. Since, in general, 
the current content of Q is not known, a simple device for achieving the 
extension is to load (4) (2~
3) into A and long right shift by 48, which puts 
(4) ( 2
- 3) in Q and fills A with sign bits. A circular left shift of 48 will then 
position the properly extended number in AQ. Instructions which accom-
plish the extension and division are: 
We can now store the quotient. 
4-4.3. Scaling Combinations of Fractional Operations 
Whether use of the fixed point fractional mode is dictated by the particu-
lar computer used, or is a matter of choice, the scaling of a complete problem 
will require, as in integral operation, a preliminary investigation of bounds. 
It is only after such an investigation that differences in fractional and 
integral scaling will occur. A problem scaled for one mode of operation is 
easily converted for the other mode by simply multiplying each quantity 
by an appropriate power of r to shift the base point. As an illustration, we 
will repeat Example 4-20, scaling for fractional operation on the CDC 1604. 
Example 4-32. We wish to tabulate 
Ρ > 1 + ( - 3 ) - 
( - 2 ) = 0 
12 0 A(4)2"
3) 
07 
0 00060 
03 
0 00060 
(4)(2-
3)->QA 
27 0 4(3)2-*) H (t)(2-i)^A 
fix) 
= 
4.6s
2 - 0.9s + 4.9 
0.1 + x
2 
for 
0 < χ < 1 
in increments of Ax = 0.01 using fractional operation. Since 0 < χ < 1 
and 0 < x
2 < 1, we can correctly scale all χ and x
2 at 2r
l. (For all χ except 

156 
4. 
FIXED AND FLOATING POINT ARITHMETIC; SCALING 
x = 1 we could use 2°, but we choose 2
- 1 for convenience.) Inequalities 
2
2 < 4.9 < 2
3 
2 -
1 < 0.9 < 2° 
2
2 < 4.6 < 2
3 
will permit us to scale factors 2
- 3, 2°, 2
- 3 or less, and, because of the range 
on x, we can use the same scale factors for individual terms in the nu-
merator. To add, we must have a common scale factor for the entire nu-
merator. Since the maximum value of the numerator is 8.6, and 2
3 < 8.6 < 
2
4, it may be scaled at 2~
4, and for simplicity, we use this scaling for all 
of its terms: (4.6x
2)2~
4, ( - 0 . 9 x ) 2 -
4, and (4.9)2~
4; and we scale the con-
stants (4.6) 2~
3 and (0.9)2°. 
For the denominator 0.1 < 0.1 + x
2 < 1.1 < 2
1, and we can scale x} 1, 
x
2, and 0.1 + x
2 at 2r\ As in Example 4-20, we find that | f(x) 
| < 86 < 2
7, 
and we can scale at 2
- 7. We note that we can obtain all scale factors by 
multiplying those in Example 4-20 by 2~
4 7. 
For comparison, we will recode the problem for fractional operation, 
paralleling the steps in Example 4-20 as closely as possible. Storage loca-
tions are assigned as 
ßo 
Χ 2 -
1 
ßl 
( 0 . 9 χ ) 2 -
4 
ft 
( 0 . 1 + 
χ
2
) 2 -
ßi 
( 4 . 6 χ
2) 2 -
4 
δο (4.9)2-* 
δι 
( 0 . 9 ) 2 ° 
δ2 
(0.1)2-» 
δζ 
(4.6) 
2 -
3 
( 0 . 0 1 )2~» 
δ6 
zero 
We start instructions at a0. 
50 
1 
00144 
50 
0 
00000 
10 
0 
ω0 
61 
0 
a7 
12 
0 
δ6 
20 
0 ßo 
12 
0 
ft 
26 
0 
δι 
01 
0 
00003 
20 
0 
ßi 
Set counter index to 100i0. PASS. 
Set storage ω» for f(x) to initial value ωο. 
Set x2r
l = 0 initially. 
(χ2"
1)[(0.9)2°] 
= 
(0.9x)2~
1 -> AQ, 
(A) 
= 
(0.9x)2~
l rounded off. 
Scale down to (0.9x)2~
4, round off (0.9x)2"
4 -* ft. 
Note that, since the fractional product is formed in AQ, we do not need to 
interchange A and Q as in the integral program, and can end-off right 

4-5. 
SCALING FOR ABSOLUTE VALUE MACHINES 
157 
shift directly. We next compute x
2, 0.1 + x
2, and then the remaining terms 
in the numerator. 
« 6 
12 0 
00 
26 0 ßo 
«β 
07 0 00001 
20 0 
ß2 
« 7 
14 0 
« 2 
20 0 ßz 
αιο 
12 0 δζ 
26 0 
ß2 
an 
15 0 ßl 
14 0 
δο 
ßt. 
x2~
l^>A, 
x*2-*^>AQ. 
322-1 
AQ, and the rounded-off (A) = 2x
22~
1 
(x* + 0.1)2"
1 -> A and ßz. 
C(4.6)2-
3][a;
22-
1] = (4.6x
2)2"
4 -+ AQ. (A) = rounded-
off version. 
(4.6s
2 - 0.9x)2-< 
A, 
(4.6x
2 - 0.9* + 4.9)2~
4 -* A 
We now have the numerator in A. To f o r m / ( ζ ) , we need 
(4.6ar> - 0.9z + 4.9)2-« 
f(x)2~
7 
= 
(0.1 + 
x
2)2~
l 
so we must put a proper version of the numerator, namely, (4.6a;
2 — 0.9a; + 
4.9) 2
- 8 in AQ. At the conclusion of program step at an, we have (4.6a;
2 — 
0.9a; + 4.9) 2
- 4 in A, and Q contains the 48 low order digits of the product 
(4.6a;
2) 2
- 4 formed by the instruction at ai0. 
Hence, we actually have 
(4.6a;
2 — 0.9a; + 4.9) 2
- 4 in AQ with an unrounded first term and rounded 
last two terms. Since this is a somewhat unusual situation, we will include 
an unnecessary step to show the scaling procedures used when (A) 
and 
(Q) are unrelated. We must scale down to 2
- 8 and surround the significant 
digits by sign bits. A right shift of 48 will fill A with sign bits, discard un-
wanted digits from Q, and put the numerator scaled at 2
- 52 in AQ. A left 
shift of 48 now yields a properly extended 96-bit version scaled at 2
- 4 in 
AQ, and a further right shift of 4 will scale down to 2~
8. We combine the 
last two shifts into one left shift of 48 — 4 = 44. 
« 1 3 
απ 
OC15 
EXIT «ιβ 
03 0 00060 
07 0 00054 
27 0 ßz 
12 0 ßo 
20 0 ßo 
55 1 
« 3 
20 0 [«*] 
14 0 /Su 
72 0 
« i 3 
76 0 00000 
(4.6s
2 - 0.9* + 4.9)2~
5β -> AQ, 
(4.6x
2 - 0.9s + 4.9)2-
8 -> AQ 
f(x)2~
7 -+ A and ω< 
X2"
1 -> A, 
(x + 0.01)2"
1 
A 
Next x —> 0o, 
ω< —> ω»·+ι 
AU values? If not, reloop; otherwise STOP. 
4-5. Scaling for Absolute Value Machines 
In preceding sections we have considered scaling for integral and frac-
tional fixed point operations for machines which were assumed to use the 
complement method of handling signed numbers. Many machines, how-
ever, are designed to do arithmetic so that all numbers are stored as ab-
solute values with a related algebraic sign. Arithmetic is performed on 
absolute values and algebraic signs are assigned by the usual rules. For 
such machines a slight alteration in scaling procedures is necessary. 

158 
4. FIXED AND FLOATING POINT ARITHMETIC) SCALING 
If the algebraic sign is stored separately in an a + 1 digit, base r machine, 
then all a + 1 digits may be significant 
In other words, all digital positions 
may be used with no necessity of saving one position for a sign digit. This 
affects the rules of scaling because in all the scaling inequalities we can 
replace α by α + 1. For example, in a 48-bit complement machine, the 
requirement on an integral machine representation η is that | η \ < 2
4 7, 
but for an absolute value machine, it is | η \ < 2
4 8. In general, our basic 
inequality ρ + s < a, becomes ρ + s < a + 1, and, after this change, we 
may proceed as before. We see that for the absolute value machines, we 
may correctly increase each scale factor exponent by one. 
In the absolute value machines, fractional machine numbers may be 
truncated to a + 1 places, since no digit position need be saved for the 
sign. These representations may be obtained from the corresponding inte-
gral ones by multiplication by the factor r~
( a + 1 ). We note that this places 
the imagined position of the base point immediately to the left of each 
digit sequence. It follows from a discussion parallel to the earlier one for 
the complement case that, if the scale factor exponent for integral opera-
tions is properly s', we may always use an exponent for fractional opera-
tions which is s = s' — (α + 1). Since s' has been increased by one for the 
absolute value case, s will be the same for both absolute value and com-
plement cases. The only difference is that we truncated at a + 1 digits 
instead of a. With this in mind, we can utilize the rule 
Ρ + s < 0 
and proceed as before. 
In extending absolute value numbers to larger registers, we need, of 
course, only fill in the new digital positions with zeros. Similarly, in right 
shifting an absolute value number, it will no longer be necessary to fill in 
the Vacated positions at the left with "sign" digits, rather these positions 
are to be filled with zeros. We may modify our earlier statement concerning 
shifting to the following one: 
After a left shift of k, the final content of the registers can be considered 
to represent the initial content multiplied by r
k if, and only if, the initial 
content had at least k leading zeros. A right shift of k is equivalent to mul-
tiplication by r~
k if, and only if, at least the final k of the low order are all 
zero. 
We note that for shifts which can be correctly interpreted as multipli-
cation by r
k or r~*, it makes no difference whether we interpret the actual 
shift as circular or end off, with all vacated positions on the right or left 
always filled with zeros. Many absolute value machines will therefore 
have no circular shift operations, confining themselves to end-off shifts 
as described above. 

4-6. 
FLOATING POINT ARITHMETIC 
159 
4-6. Floating Point Arithmetic 
In any method of carrying out arithmetic operations digitally, two basic 
problems arise. One is the representation of numbers as finite digital 
sequences of proper size, which will involve rounding procedures. The 
other is the proper designation of the position of each digit within its 
sequence, which will involve keeping account of the location of the base 
point as a reference. In general, we handle these problems by whatever 
techniques are appropriate to the kind of calculating we do. For instance, 
in longhand calculation, we write the digits in columns and line up the 
base point for addition. For fixed point computer operation we achieve 
the same result by using common scale factors, and, in general, we find 
that an easy way of handling the problem is to reduce numbers to a specific 
kind of sequence (integral or fractional) and to keep track of the base 
point by means of externally recorded scale factor exponents. The same 
approach is used in so-called floating point arithmetic operations, except 
that we store the scale factor exponent internally and make the adjust-
ment of these exponents an automatic part of each arithmetic operation. 
This materially reduces the amount of bookkeeping required on the part 
of the programmer and yields simpler and more compact programs, since 
the shifting and related instructions are eliminated. 
Let Ν be a rounded version of any number represented digitally, base r, 
with a properly located base point. Then we can always represent the 
number Ν as Ν = η τ * where η is a suitable sequence of digits in which 
the base point is placed at our convenience, and s is the exponent to put 
it back where it belongs. In the discussion of fixed point operation, we have 
treated η as an integer or a fraction of a certain kind. In floating point 
operation, on the other hand, it turns out to be convenient to treat η as 
though the base point were immediately 
to the left of the first significant 
digit. 
The number η is frequently referred to as the coefficient and the number 
s as the exponent. Since it is necessary to deal with signed numbers, both 
Ν and η are signed numbers, and s, being a negative or nonnegative integer, 
is also a signed number. Thus, we can think of each number as being deter-
mined by an ordered set of four quantities, 
Ν = (sign, coefficient; 
sign, exponent) 
In some computers the sign and coefficient are lumped together and treated 
by means of complements. In others, the absolute value of the coefficient 
is used, and the sign is treated separately. In fixed point operation, the 
computer arithmetic deals with the coefficient and its sign, while the coder 
records the exponent and its sign externally, adjusting as necessary by 

160 
4. 
FIXED AND FLOATING POINT ARITHMETIC J SCALING 
(1) Fixed point integral: Any of 
0325120 
scaled at 10
8 
0032512 
scaled at 10
2 
0003251 
scaled at 10
1 
0000325 
scaled at 10°, etc. 
(2) Fixed point fractional: Any of 
0.325120 
scaled at 10~
3 
0.032512 
scaled at 10~
4 
0.003251 
scaled at 10~
5 
0.000325 
scaled at 10~
6, etc. 
(3) Floating point: Only 0.325120, true exponent 3. 
Note that because of the chosen form of the coefficient only one possible 
scale factor or true exponent can be used. The normalization of the co-
efficient provides that, interpreted as a fixed point fraction, it is always 
scaled optimally. That is, it has a scale factor exponent equal to the nega-
tive of the true exponent (see Example 4-33). 
In fixed point operation we need store in the computer only the coeffi-
cient consisting of sign and significant digits, recording the scale factor 
externally. For floating point we must also store the signed exponent. The 
most common storage scheme employs the packed format in which the 
means of shifting instructions. In floating point the computer arithmetic 
automatically handles all four quantities. 
We will assume that the computer arithmetic is designed to deal with 
the coefficient and exponent as if they were both complement numbers, 
that is, as if each were lumped together with its own sign. Absolute value 
and sign format or combinations of this and complement formats are, of 
course, possible and are sometimes used; but complement format is the 
only one we consider here. 
Let Ν be any number, different from zero; then its floating point machine 
equivalent is defined as n*r*, where Ν = n«r«, s is an integer, and η is a 
machine number satisfying 1/r < \ n\ < 1. Because of this restriction, the 
coefficient η appears as a sequence of digits beginning with a sign digit 
followed immediately by the first significant digit, with the base point 
always interpreted as lying to the left of the first significant digit. Only one 
sign digit can occur. With its digits arranged so that the first significant 
digit is immediately to the right of the base point, the coefficient is said to 
be normalized. 
In this case, the integer s is called the true exponent. 
We 
illustrate with some comparisons between fixed point and floating point 
machine representations. 
Example 4-33. The number +325.12 is to be represented on a seven-
place decimal machine in fixed point integral and fractional, and in floating 
point form. 

4-6. 
FLOATING POINT ARITHMETIC 
161 
signed coefficient is stored in part of a register and the signed exponent in 
the rest of the same register. 
Both coefficient and exponent will be limited by the number of digits 
allocated to their storage. In general, we will need fewer digits for the 
exponent (which determines shifts in base point) than for the coefficient 
(which determines significant digits). The number of digits and position 
assigned to each part of a floating point machine operand will be precisely 
defined for specific machine operations or extant programs. Variations 
from these precise formats will require that we write our own routines, in 
which case we can make the allocations as we choose. 
We will consider some simple computational illustrations to point out 
what must be done by the computer in applying arithmetic operations to 
floating point machine numbers. Since we will deal with the coefficient 
and exponent separately, we will treat them as though they were in the 
unpacked format, in which each is stored in a separate register. 
Example 4-34. In a 7-place decimal machine, we wish to add the num-
bers +105.12 and —60.322. We consider fixed and floating point. For 
integral fixed point arithmetic, we can scale 105.12 at 10
8, to give a machine 
representation of 0105120. We could scale -60.322 optimally at 10
4. To 
align the decimal points for addition, however, we must use a common 
scale factor; and the programmer must arrange to scale the second operand 
at 10
8 also, giving a machine representation (using 9's complement) of 
9939677. The machine then adds 
0105120 
9939677 
I 1 10044797 
>1 
0044798 
The programmer's notes indicate that this result is scaled at 10
8 and so 
the unsealed version is 44.798, positive because of the leading sign digit. 
Alternately, for fractional operation, the common scale factor is 10~
8 with 
operands interpreted to be 0.105120 and 9.939677 and the final result the 
same. In each case we note that the first significant digit is a 1 or a 3, and 
that the alignment of these is taken care of by the coder. 
For floating point we would have 
105.12 
= 
0.105120 X 10
8 
-60.322 = -0.603220 Χ 10
2 

162 
4. FIXED AND FLOATING POINT ARITHMETIC J SCALING 
0.044798 
(exponent 3) 
Since it is not normalized, this is not a proper floating point number, and 
the machine must now left shift the result enough to move the leading 
digit, 4, immediately to the right of the decimal point. It must also count 
the number of such shifts required and adjust the exponent correspondingly. 
That is, it normalizes (and if necessary, may round) the coefficient to 
0.447980. This requires a left shift of 1, so it computes the exponent as 
3 — 1 = 2 and registers the floating point sum as 0.447980 (exponent 2). 
This is the correct floating point representation of +44.798. 
Example 4-35. In a 7-place decimal machine we wish to multiply and 
store the product of 312.11 and 0.00123. Products are formed in a 14-digit 
register and transferred to a standard length register. 
For fixed point integral operation we can use, with optimal scaling: 
(312.11) (10
3) = 0312110 
(0.00123) (10
8) = 0123000 
The product is 00038389530000, scaled at 10", which is too large for a 7-
place register. We must therefore scale down by an end-off 5-place right 
shift to give 0383895, scaled at 10
6, as the machine version of the product 
0.3838953. 
For floating point we have 
312.11 = 0.312110· 10
8 
0.00123 = 0.123000· ΙΟ"
2 
and we store 0312110 (exponent 3) and 0123000 (exponent - 2 ) . To form 
the product the machine must multiply, as fractions, 0.312110 and 0.123000 
to obtain the double length product 0.0383895300000. It must now add 
Hence, we store the sequence 0105120 and the exponent 3 and the comple-
mented sequence 9396779 and the exponent 2. For the addition operation 
the machine must first compare the two exponents and determine that, 
since 2 < 3, a right shift of 3 — 2 = 1 of the second number is required 
before addition. To compensate for this shift the machine adjusts the expo-
nent to 3 and saves this value as the temporary common exponent and 
adds as 
0.105120 
(exponent 3) 
9.939677 
(exponent 3) 
ΓΤΊθ.044797 
I 
I 
- > i 

4-6. 
FLOATING POINT ARITHMETIC 
163 
the exponents 3 and —2 to obtain an intermediate exponent value of 
3 + 
(—2) 
= 
1. However, it must also normalize the coefficient to 
0.383895300000 and round off. This requires a left shift of 1, and the final 
exponent is 3 + (—2) — 1 = 0 . The result is stored as the rounded off 
product 0383895 (exponent 0). 
As we see, the basic distinction in the fixed point and floating point 
methods is the way in which machine representations are interpreted and 
the distribution of calculation between the machine and the coder. 
In machine computation, the problem of the number zero can be trouble-
some. We must deal in computers with various kinds of zero, for instance, 
the mathematical zero, and the rounded off zero. The latter is simply a 
number which appears as zero within the number of digits used. If comple-
ments are used, we may also have to recognize the positive and negative 
versions of these zeros. 
The problem of zero is particularly accentuated in floating point com-
putation by the fact that we cannot normalize zero, and we have excluded 
zero from our definition of a floating point machine number. Theoretically, 
of course, the mathematical zero can be written as 0 = Ο τ ' and we can 
choose any value of t. We will ordinarily take t = 0, since this gives a 
floating point zero identical with a true fixed point zero. At the same time, 
we must make sure that what is meant to be a mathematical zero will 
always behave as such. This means that other values of t may be introduced, 
but regardless of the exponent used, and, for complement systems, regard-
less of whether the + 0 or —0 appears, the arithmetic result should be 
correct. For the programmer this means that he must be completely 
familiar with the particular treatment accorded this problem in the com-
puting system he is using. 
We give an example to indicate the way in which rounded-off zeros may 
arise in floating point computation. 
Example 4-36. Consider a seven place decimal machine, using 
floating 
point. We wish to add the two numbers 3456.78 and 0.0001. For 
floating 
point we write 3456.78 = (0.345678) · 10
4 and 0.0001 = (0.1000000) -lO"
8 
giving coefficients and true exponents 
For addition, however, the computer must compare exponents and line 
up the digits. This will require an end-off right shift of 7 on the second co-
efficient in order to match exponents. It is easily seen that this gives 
(0.345678) 
(0.100000) 
(exponent 
4) 
(exponent —3) 
0.345678 
0.000000 
01 
(exponent 4) 
(exponent 4) 

164 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
and that the rounded off version of the second number acts as a zero for 
addition. If we multiply, the computer must form (0.0345678) with expo-
nent one, normalize, adjust exponent, and round to give 
(0.345678) 
(exponent 0). In other words, the operand is zero for addition and different 
from zero for multiplication. On the other hand, a true zero must behave 
as a zero in both cases. There is no particular problem with apparent zeros 
of the type mentioned above, since such numbers will have uniquely deter-
mined exponents, and, in a sense, only behave as zero under certain round 
off conditions (they may, for example, produce division overflow just as 
true zero does). 
Example 4-36 serves to illustrate some of the peculiar things which occur 
as a result of the automatic adjustment of scale factors. Such adjustments 
can lead to the introduction of floating point machine numbers which mask 
a complete loss of significance. While similar situations can arise in fixed 
point operations, the coder is more able to anticipate them and take cor-
rective measures, if he has carried out the proper scaling analysis. Hence, 
while it is true that the use of floating point operation will simplify the 
bookkeeping required in scaling, this work can by no means be eliminated. 
We must also remember that the fixed format of the floating operand and 
a limited range of exponents can be represented. As a consequence, opera-
tions on floating point quantities which differ too much in magnitude may 
produce exponents exceeding the allocated capacity. For this reason, a 
preliminary scaling analysis will be essentially the same for fixed point or 
floating point operation. In either case, the experienced programmer will 
make an analysis of the quantities involved and attempt to write his pro-
gram so that it can be carried out properly in terms of the limitations of 
his method. 
In the remainder of this chapter, we give specific consideration to the 
floating point operation in the CDC 1604, and consider typical problems 
which will be the same, with minor variations, in all floating point operation. 
4-6.0. Floating Point Format on the CDC 1604 
The CDC 1604 has instructions for direct floating point addition, sub-
traction, multiplication, and division of machine operands which adhere 
to the format described below. The floating point format is packed, both 
exponent and coefficient being contained in a single 48-bit register. As in 
fixed point, arithmetic is binary, and the floating point form of a number 
is obtained from Ν = η·2', where t is the true exponent. However, in the 
computer a biased exponent is used. The allocation of digits in a 48-bit 
register is as follows: the high order bit is the sign bit for Ν and also for 
the coefficient η as well; the next eleven bits in order represent the biased 

4-6. 
FLOATING POINT ARITHMETIC 
165 
exponent; and the final low order thirty-six bits represent the significant 
digits of the coefficient or significant digits of N. That is, 
647 
&4β&46· · ·&3β 
ί>3δ···δο 
Sign bit 
Biased exponent 
Significant bits of the coefficient 
The coefficient, n, is a 37-bit fraction whose 36 low order bits are inter-
preted as a sequence of bits in which the base point is immediately left 
of the first digit, 635, so that the normalized coefficient η satisfies § < | η \ < 
1. One's complement arithmetic is used and the sign bit is always different 
from the first significant digit of n. That is, the sign bit, together with the 
low order 36 bits, is either 0.1. . .6 0 for a positive number or its complement 
1.0. . .W for a negative number. 
The value of the true exponent is uniquely determined by the normalized 
form of n. Thus, the decimal numbers .5, 5, and 15 have binary representa-
tions .1, 101, and 1111. These are then represented as 
.1 = (0.1)2° 
101 = (0.101)2
3 
1111 = (0.1111)2
4 
with unique true exponents 0, 3, and 4. 
The exponent t is an integer represented by 11 bits in one's complement 
form. Thus, if the leading bit of t is to determine its sign in the usual way, 
we can only admit values of t such that \t \ < 2
1 0 = 1024. Ordinarily for 
one's complement arithmetic, we would utilize the eleven bits to represent 
\t I, if t > 0, and to represent 2
1 1 — 1 — 11 | , if t < 0. However, we see 
that 2
1 1 — 1 — 111 > 111 for all admissible t. Accordingly, the eleven expo-
nent bits, if packed into the floating point word, would give the total 
register content, considered as an integer, a greater weight for negative 
exponents than for nonnegative ones, but a negative exponent indicates a 
smaller number than does a positive one. Thus, we will not be able to 
apply the ordinary fixed point comparison instructions to floating point 
numbers, unless some modification is introduced. This is accomplished in 
the following way: we bias the absolute value of t by 2
1 0, that is, we replace 
111 by 2
1 0 + J11 . Then, if t is negative, we replace the biased value by its 
one's complement. Thus, we have as our exponent values: 
2 n - 1 - 2
1 0 - 
\ t I = 2
1 0 - 
1 - 
\ t I , 
- 1 0 2 3 < t < 
- 0 
2
1 0 + \t I , 
0 < t < 1023 

166 
4. FIXED AND FLOATING POINT ARITHMETIC) SCALING 
In summary: all exponents are biased to give a biased exponent s = t + b; 
the bias is b = 2Q008 for all positive exponents (including + 0 ) ; and the 
bias is 6 = 1777 8 for all negative exponents (including —0) ; that is, in 
octal this orders our exponent representations in the following manner: 
True exponent, 
Biased exponent, 
True exponent, 
Biased exponent, 
t 
t + b = s 
t 
t + b = s 
1777 
3777 
- 0 
1777 
1776 
3776 
- 1 
1776 
- 2 
1775 
2 
2002 
... 
... 
1 
2001 
- 1776 
0001 
+ 0 
2000 
- 1777 
0000 
Notice that two distinct biased exponents correspond to the two forms 
of zero. Both are acceptable and in floating point operations the machine 
will treat each in the same way as it treats the plus zero. Thus, no funda-
mental difficulty arises because of the difference in 2000 8 and 17778. We 
will, in practice, normally omit 1777 8 and use only 2000 8. 
In the CDC 1604, all forms of floating point zero are acceptable, that is, 
positive or negative, and with any proper exponent. The usual practice is 
to use the standard fixed point zero (zero coefficient and zero biased expo-
nent) . In the case of an augend with zero coefficient and a smaller exponent 
than that of the addend, the net result is a rounded-off version of the 
addend to match exponents. This feature is sometimes useful in rounding 
coefficients without unpacking. This may, however, result in completely 
discarding a number if the difference in exponents is as large as 36. 
Although the biased exponent is actually only an eleven-bit word, we 
have represented it, for convenience, as four octal digits, or twelve bits. 
This is permissible when we restrict ourselves to the representation of 
the absolute values of floating point numbers. Then 647 will always be zero, 
and if we include 647 with the exponent bits, we get the 12-bit representa-
tions given in the table above. Thus, to get the 48-bit (16 octal digit) 
representation of the absolute value | η | ·2' of a floating point operand, 
we first write down the four octal digits of the sign and biased exponent, 
and then the 12 octal digits giving the absolute value of n. For example, 
to represent + . 0 4 8 in floating point, we write .04 8 = .0001002 = 
. I 2 X 2
- 3. 
Therefore, 11 j = 3 so that 
2
1 0 + j 11 = 2003 8 
and 
2
1 1 - 1 - 
(2
1 0 + 
= 1774 8 

4-6. 
FLOATING POINT ARITHMETIC 
167 
We take 1774 8 to represent the sign and exponent. The absolute value of 
the normalized coefficient η is given in octal by .400000000000. Putting 
these two 
sequences together, 
we get 
the 
floating 
point 
operand 
1774 4000 0000 0000. 
We note that the floating point representations of nonnegative numbers, 
when considered as integers, are ordered in the same way as the actual 
numbers because of the biasing of the exponent. Hence, their magnitudes 
can be compared in the ordinary fixed point manner. However, such a 
comparison of two different representations of zero will result in the deter-
mination that their magnitudes are not equal. 
We define the floating point representation of a negative number to be 
the one's complement of the representation of its absolute value. Accord-
ingly, the representation of — .04 8 is given by 6003 3777 7777 7777. 
We note that these complements will be correctly ordered 
algebraically 
since the absolute values were properly ordered. Hence, ordinary algebraic 
comparison instructions valid for fixed point operands can correctly be 
used in conjunction with the representations of floating point numbers of 
any sign. We also see that the negative of a representation can be obtained 
from the same instructions as for fixed point. 
Basic problems which arise are the proper floating point representation 
of numbers for machine storage and conversion from one form to another. 
We consider several examples to illustrate the ideas. 
Example 4-37. We wish to find the octal form of the floating point repre-
sentation of the decimal numbers 1234.5, 0.015625, and -3.625. We first 
convert to octal and binary to obtain 
1234.5io = 2322.4g = 100110100104 2 
0.015625io = 
0.01s = 0.000001 2 
-3.625io = 
- 3 . 5 8 = 
-II.IOI2 
which gives in octal true exponents of 13, —5 and 2. The biased exponents 
are in octal 13 + 2000 = 2013, - 5 + 1777 = 1772 and 2 + 2000 = 2002. 
In binary notation the two positive numbers and the absolute value of 
the negative number are then, in packed floating point format, 
Sign 
Exponent 
Coefficient 
0 
10 000 001 011 
1001101001010....0 
0 
01 111 111 010 
10 
0 
0 
10 000 000 010 
111010 
0 

168 
4. FIXED AND FLOATING POINT ARITHMETIC J SCALING 
With the usual grouping, the octal form is 
2013 4645 0000 0000 
1772 4000 0000 0000 
2002 7200 0000 0000 
Since the last is the absolute value of a negative number, we complement 
the entire format and use 
5775 0577 7777 7777 
We note that the absolute value of the number always has its first four 
octal digits the same as the biased exponent, the zero sign bit forms the 
twelfth digit of the group. The entire format, including the exponent, is 
complemented for negative numbers. 
Example 4-38. The floating point numbers 2003 4000 0000 0000 8 and 
6002 2777 7777 7777 8 are in CDC 1604 format. Find their decimal 
equivalents. 
In the first representation the leading digit is 2, with a sign bit 0 for a 
positive number. Since the biased exponent is 2003, the true exponent is 
2003 — 2000 = 3. We remark that all nonnegative true exponents will 
have a biased form beginning with 2 or 3, while negative ones will have a 
biased form starting with 0 or 1. The coefficient in octal is 400.. .0 = 
1000...0 2 and is interpreted as 0.1 2. Hence, the number is (0.1 2)·2
3 = 
1002 = 4io. 
The second representation, beginning with 6, has a sign bit of one and 
is negative. We complement to form 1775 5000 0000 0000 8. The biased 
exponent is 1775 8 giving a true exponent of —2. The normalized coefficient 
is 5 0 . . .0 8 = 1010.. .0 2, interpreted as 0.101 2. Hence, the absolute value 
of the number is (0.1012) ·2~
2 = 0.00101 2. Its decimal equivalent is then 
0.15625; and since we complemented, the number represented is —0.15625. 
Example 4-39. The number η = 1234 5676 5432 1234 is the fixed point 
integral representation of a number scaled at 2
8 9, and we wish to convert it 
to CDC floating point format. The leading digit 1 indicates the number is 
positive. Since it is scaled at 2
3 9, the number represented in 
Ν = n . 2 -
8 9 
= 123.45676543212348 
= 1010011.100101...0111 2 
= 
(0.1010011100101...0111 2)·2
7 
= (0.516273726150516 8)·2
7 

4-6. 
FLOATING POINT ARITHMETIC 
169 
Hence, the true exponent is 7 and the biased exponent is 2007 8. We must 
round off the coefficient to 12 octal digits. Thus, the assembled 
floating 
point number is 2007 5162 7372 6150 8. Properly, the last digit should be 
rounded to one, but we have used the simpler device of suppressing all 
unused digits. 
Example 4-40. The floating point word 6004 3377 7777 7777 is to be 
converted for fixed point integral use. Since the number is negative, we 
complement to get 1773 4400 0000 0000. This has a true exponent 1773 8 -
1777 8 = 
—4. The coefficient, in binary, is 0.100100.. .0 2, so the actual 
numberis (-0.100100.. .0 2) -2~
4 = -0.000010010.. .0 2 = - 0 . 0 2 2 0 . . .0 8 = 
N. Since 2~
5 < | Ν \ < 2~
4, we can scale it at any s < 51. If we scale op-
timally, we have | Ν | 2
6 1 = | Ν | 8
1 7 = 2200 0000 0000 0000 8, and finally 
for the negative number we complement to get 5577 7777 7777 7777 8. 
We note that we have introduced false precision by use of the optimal 
factor, since the original floating point contained only 36 significant bits, 
while the fixed point version contains 47 possibly significant bits. The 
additional eleven bits, however, are not significant—we could have used 
any value 40 < s < 51 and still have retained as much precision as we 
started with. 
4-6.1. Floating Point Instructions for the CDC 1604 
The direct application of fixed point arithmetic instructions to 
floating 
point machine operands will produce incorrect results. Accordingly, for 
correct operation on floating point machine numbers, either we will need 
a separate program, made up of existing instructions, or we will need to 
build distinct floating point operations into the computer. We consider 
here a typical set of instructions for builtin floating point operations, those 
of the CDC 1604. 
In all four of the CDC floating point arithmetic instructions it is as-
sumed that numbers are in the standard floating point format considered 
in the last section: sign bit, eleven bits of biased exponent, and thirty-six 
bits of coefficient. The instructions and their forms are 
floating add, 
30 
b 
m 
floating subtract, 
31 
b 
m 
floating multiply, 
32 
6 
m 
and 
floating divide, 
33 
b 
m 
In the floating add instruction, 30 
b 
m, the sum of (Af), where M 
= 
m + (B
b), 
and (A)i 
is formed in A, with the numbers treated as floating 
point words. The sum is normalized and rounded in A. The residual of the 

170 
4. FIXED AND FLOATING POINT ARITHMETIC ) SCALING 
rounding operation remains in Q. Symbolically, (A) 
+ (M) —» A. 
The 
floating 
subtract instruction, 31 
b 
m, is the same except that (M) 
is 
subtracted, that is, (A) 
— (M) —* A, with the rounding residual left in 
Q. In each case, the exponents are compared and any necessary shifting 
for alignment is made prior to addition. The common exponent is adjusted 
in the normalization and placed in proper location in A. In case of expo-
nent overflow, a fault indicator is set. This could occur, for example, if 
0.1 2 (biased exponent 3777 8) were added to itself. The result would be 
01.0 2 (biased exponent 3777 8), and normalizing would require a 
right 
shift and an increase in the biased exponent to 4000 8, which exceeds the 
11 bits allocated for an exponent. 
The floating multiply instruction, 32 
b 
m, forms the product of 
(A)i 
and (M), with M = m + (B
b). Each operand is treated as a floating point 
word, and the normalized, rounded product remains in A. Symbolically, 
(A)(M) 
—» A. The rounding residual is contained in Q. The operation 
must, of course, add exponents and adjust, if necessary, as well as form 
the product of the coefficients. A fault indicator is set if exponent overflow 
occurs. 
In the floating point divide instruction, 33 
b ra, the dividend must 
be loaded into A prior to division (note that, in contrast to fixed point 
operations, only A need be used and Q is ignored). The divisor is contained 
in M = m + (Β
6), and the rounded, normalized quotient is left in A. That 
is, (A)i/(M) 
= {Α)ρy 
with all operands treated as floating point words. 
No remainder is preserved. However, the rounding residual is left in Q. 
The operation subtracts exponents and adjusts the difference if this is 
required for normalization. A fault indicator is set if the divisor is zero, 
or if exponent overflow occurs. 
Although the use of these instructions is straightforward, the programmer 
should, to the best of his ability, analyze the computations to prevent 
floating point range faults, or exponent overflow. On the CDC 1604, with 
37 bits in the coefficient, one of which is a sign bit, the maximum coefficient 
in absolute value is 1 — 2~
3 6 and the minimum is § (except for zero). 
Similarly, the maximum absolute value of a true exponent is 2
1 0 — 1. 
Hence, numbers, not equal to zero, of the form \ N \ = | η | ·2' must lie 
in the range 
(2-
1)·2-«
1 0-
1> < \ N\ 
< (1 - 
2-
3 6)-2<
2 l 0-
1> 
or 
2-1024 < 
J ff 
I < 
( ! 
_ 
2-36) . 21028 
This is not a very severe limitation, but its observance will permit us to 
avoid faults which require recoding. We note that such faults do not stop 
operation of the machine unless the option is selected by separate instruc-

4-6. 
FLOATING POINT ARITHMETIC 
171 
tions. If the option is not selected, computation may continue with in-
correct operands. 
We illustrate the use of floating point instructions with some simple 
examples. 
Example 4-41. The numbers a = 114.5 and b = 24.25 are to be stored, 
added, subtracted, multiplied, and divided in floating point. We start by 
putting them in proper floating point format. Since 114.5 = 162.4 8 = 
ΙΠΟΟΙΟ.Ι2 = 
(0.11100101 2)-2
7, we have a coefficient 0.111001010.. .0 2 
and biased exponent 2007 8. For 
24.25 = 30.2 8 = IIOOO.OI2 = (0.1100001 2)·2* 
we have a coefficient 0.11000010.. ,0 2 and a biased exponent 2005* The 
packed formats for a and b are 
a = 0 10000000111 111001010...0 = 2007 7120 0000 0000 
b = 0 10000000101 11000010....0 = 2005 6040 0000 0000 
(1) For addition we can use the program step 
12 
0 
t(a) 
30 
0 
1(b) 
a^>A,a 
+ 
b-*A 
Since 2007 8 > 2005 8, b is shifted right 2 places after comparing exponents, 
and the exponent 2007 8 is preserved. The coefficients are then added, 
giving 
.1110010100...0 
.0011000010...0 
1.0001010110...0 
Normalization requires a right shift of one and, hence, a compensatory 
increase of one in the exponent of the sum to 2010 8. Finally, the new co-
efficient is 0.10001010110.. .0 2 and the packed sum is 
a + b = 2010 4254 0000 0000 = 
(A) 
(2) For subtraction we can use the program step 
12 
0 
1(a) 
31 
0 
1(b) 
a 
A, 
a - 
b
A 
The exponents are treated as in addition, with a temporary common value 
of 2007 8. Subtraction of coefficients gives 
.1110010100...0 
- . 0 0 1 1 0 0 0 0 1 0 . . . 0 
.1011010010...0 

172 
4. 
FIXED AND FLOATING POINT ARITHMETIC) SCALING 
This result is already normalized, so the final exponent is 2007s, and the 
packed difference is a - b = 2007 5510 0000 0000 = 
(A). 
(3) For multiplication we can use the program step 
12 
0 
1(a) 
32 
0 
((b) 
a -> A, 
ab -> A 
The true exponents must be added to give a proper result, and the biased 
form of the sum of the exponents is 20148. The product formed is 
0.10101101100010102. This is already normalized and, because of the final 
zeros, needs no rounding. The packed product is then 
ab = 2014 5330 5000 0000 = 
(A) 
(4) For division a/b, we use the program step 
12 
0 
1(a) 
33 
0 
1(b) 
a-+A, 
a/b -> A 
The true exponents are subtracted to give a biased exponent of 2002 8. The 
quotient is, in binary, 
1.001011100010111110000001010100011101... 
This must be normalized and rounded to 36 bits, giving 
0.100101110001011111000000101010001111 
The normalization requires a right shift of one, and a compensatory in-
crease in the exponent to 2003 8. The packed result in octal is then 
a/b = 2003 4561 3700 5217 = 
(A) 
In the rounding procedure, the digit immediately following the last to 
be retained is inspected. If this is a one, we round up one in the last digit 
retained, that is, we add one to the last digit retained. Since this may cause 
a carry through the entire sequence, the rounding precedes the normaliza-
tion in the computer. 
To illustrate direct use of the floating point commands, we will consider 
the problem treated in fixed point integral and fractional. 
Example 4-42. We wish to tabulate the function 
4.6x
2 - 0,9s + 4.9 
/(*) = 
0.1 + x
2 
in increments of AX = 0.01 in the range 0 < Χ < 1 in floating point on the 
CDC 1604. Using the inequalities of Example 4-20, we see that all quan-
tities which arise are safely in the floating point range. We can therefore 

EXERCISES 
173 
proceed directly. As before, we start by assigning storage locations to all 
quantities: 
00 
X 
A 
0.9z 
A 
χ
2 
A 
(0.1 + χ*) 
«0 
4.9 
[2003 4714 6314 6315] 
«! 
0.9 
[2000 7146 3146 3146] 
0.1 
[1774 6314 6314 6315] 
δζ 
4.6 
[2003 4463 1463 1463] 
«4 
Αχ = 0.01 
[1771 5075 3412 1727] 
«5 
zero 
[0000 0000 0000 0000] 
all floating point 
Since the computational pattern is essentially that of the fixed point 
examples, we present the program without further elaboration. 
ENTER 
a0 
50 
1 00144 
50 0 00000 
Set counter index to lOOio. PASS. 
10 0 o>o 
61 0 
« 1 1 
Set the storage address ω< for f(x) to 
initial value ωο. 
« 2 
12 0 *s 
20 0 ßo 
Set χ = 0 initially. 
12 0 ßo 
32 0 δι 
z-*A, 
0.9x -• A 
Cti 
20 0 ßl 
12 0 ßo 
0.9x ->βι, 
x^A 
« 6 
32 0 ßo 
20 0 
ß2 
x
1 —> A} 
x* -* & 
Οβ 
30 0 
20 0 ßz 
0.1 + x
1 -> A, 
0.1 + x* -» ßz 
α 7 
12 0 β* 
32 0 δζ 
x*-+A, 
4.63* —> A 
αιο 
31 0 ßl 
30 0 δο 
4.6x
2 - 0.9* -> A, 
4.6x* - 
0.9* + 
4.9-* Λ 
au 
33 0 ßz 
20 0 M 
/(*)-* 
A, 
/(*)->«< 
au 
12 0 ßo 
30 0 
x-+A, 
χ + Δχ = χ + 0.01 -> A 
an 
20 0 ßo 
a , _ J 
72 0 an 
Next x —> /3o, ω»· —* co<+i 
EXIT 
au 
55 1 
ßo 
a , _ J 
76 0 00000 
All values? If not, reloop. Otherwise 
STOP. 
Exercises 
Section 4-0 
1. 
Review for yourself each step which you take to do arithmetic on 
decimal numbers with a decimal point included. That is, step by step, 
recall from grade school the rules you have used to place the decimal 
point in addition and subtraction, multiplication and division. (These 
are so automatic now that you have forgotten why you do them. Re-
construct this and it will make scaling easy later on.) 
2. 
Redo Problem 1 in binary, octal and base 16. 

174 
4. FIXED AND FLOATING POINT ARITHMETIC ) SCALING 
Section 4-1.0 
3. 
Write down several numbers in different bases. Rewrite them with 
the digits shifted several places right 
and then left. Decide what 
arithmetic operation has taken place. 
Section 4-1.1 
4. 
(Α)ι 
= 
1234 5676 5432 1234. F i n d (A) 
in octal after each of 
the 
following instructions: 
(a) 0 1 
0 
00005 
(b) 0 1 
0 
00034 
(c) 0 1 
0 
00060 
(d) 01 
0 
00065 
5. 
(AQ)i 
= 
1234 5676 5432 1234 5676 5432 1234 5676. F i n d 
(AQ), 
(QA), 
(A), 
(Q) 
in octal after each of the following: 
(a) 03 
0 
00005 
(b) 03 
0 
00060 
(c) 03 
0 
00100 
(d) 03 
0 
00140 
(e) 
03 
0 
00141 
Section 4-1.2 
6. 
(Q)i 
= 
1234 5676 5432 1234. F i n d 
(Q) 
in octal after each of 
the 
following instructions: 
(a) 06 
0 
00005 
(b) 06 
0 
00034 
(c) 06 
0 
00060 
(d) 06 
0 
00065 
7. 
(AQ)i 
= 
1234 5676 5432 1234 5676 5432 1234 5676. F i n d 
(QA), 
(A), 
(Q) in octal after each of the following: 
(a) 07 
0 
00005 
(b) 07 
0 
00060 
(c) 07 
0 
00100 
(d) 07 
0 
00140 
(e) 07 
0 
00141 
Section 4-1.3 
8. 
If (01000) = 0000 0000 1000 0000 
(01001) = 0000 0000 0002 0000, 
find (QA), 
(AQ), 
(A) 
and (Q) in octal after each of the following: 
(a) 
12 
0 
01000 
24 
0 
01001 
(b) 12 
0 
01001 
24 
0 
01000 

EXERCISES 
175 
9. 
If (01000) = 7777 7777 6777 7777 
(01001) = 0000 0000 0002 0000, 
find (QA), 
(AQ), 
(A) 
and (Q) in octal after each of the following: 
(a) 12 
0 
01000 
24 
0 
01001 
(b) 12 
0 
01001 
24 
0 
01000 
10. If (01000) - 
7777 7777 6777 7777 
(01001) = 7777 7777 7775 7777, 
find (QA), 
(AQ), 
(A) 
and (Q) 
in octal after: 
12 
0 
01000 
24 
0 
01001 
11. If (01000) and (01001) are the same as in problem ( 8 ) , give 
(AQ), 
(QA), 
(A), 
(Q) in octal after each of the following: 
(a) 
12 
0 
01000 
03 
0 
00060 
25 
0 
01001 
P A S S 
(b) 12 
0 
01000 
16 
0 
01000 
25 
0 
01000 
P A S S 
12. Repeat Problem 10 with (01000) and (01001) as in Problem 9. 
13. Repeat Problem 11 with (01000) and (01001) as in Problem 10. 
Section 4-2.0 
14. A 7-place decimal machine 
uses 9's complements. 
F o r each of 
the 
following decimal numbers find a range of permissible scale factor 
exponents and obtain the machine version of each number if optimal 
scaling is used. 
(a) 3.123456 
(b) 
31234.56 
(c) 0.003123456 
(d) 
0.0000003123456 
15. A 48-bit binary machine uses l's complements. F o r each of the follow-
ing decimal numbers, determine a suitable range of scale factor expo-
nents a n d obtain the machine version in octal if optimal scaling is used: 
(a) 3.25 
(c) 
0.000125 
(e) 
- 3 2 5 . 5 
(b) 
325.5 
(d) 
- 3 . 2 5 
(f) 
- 0 . 0 0 0 1 2 5 

176 
4. FIXED AND FLOATING POINT ARITHMETIC J SCALING 
16. A 7-place 9's complement decimal machine contains the following 
decimal contents, scaled as indicated. Find the decimal version of 
the actual numbers. 
(a) 0123456 
(scaled at 10
3) 
(b) 0123456 
(scaled at 10
8) 
(c) 0123456 
(scaled at ΙΟ"
4) 
(d) 9876543 
(scaled at 10
3) 
(e) 9876543 
(scaled at 10
8) 
(f) 9876543 
(scaled at 10"
4) 
17. A 48-bit binary machine using l's complements contains the following 
octal contents, scaled as indicated. Find the decimal version of the 
actual numbers. 
(a) 2443 0000 0000 0000 
(scaled at 2
3 9) 
(b) 2443 0000 0000 0000 
(scaled at 2
4 0) 
(c) 5447 7777 7777 7777 
(scaled at 2
3 9) 
(d) 5447 7777 7777 7777 
(scaled at 2
4 0) 
Section 4-2.1 
18. On a 7-place decimal complement machine we wish to add 1234.56 
and 65.4321. Find the optimal scaled version of each number and 
determine what steps are required to perform the addition. 
19. On a 48-bit binary, Ts complement, machine we wish to add 1234.5 
and 24.25. Find the optimal scale factor for each number, the octal 
version of the optimally scaled numbers, and the octal version of the 
numbers which are added. Determine the final sum in octal and the 
related scale factor. 
20. Repeat Problems 18 and 19 with one number negative and one posi-
tive, and both negative. 
21. On a 48-bit, l's complement computer, M and Ν are correctly stored, 
scaled at 2
4 3. No further information is available. What scaling steps 
are required to avoid overflow in a 48-bit register if the numbers are 
added? 
22. We wish to form Σΐ-ι°^* where it is known that all x% satisfy 3 < 
Xi < 6. What scaling steps are required on a 48-bit complement 
computer? 
Section 4-2.2 
23. The numbers Ν and M are optimally scaled at 2
4 3 and 2
6 1 on the 
CDC 1604. What scaling steps are required to form the product? 
Write a set of instructions to form and store the product. 
24. The numbers Ν, M and L are known to satisfy 3 < iV < 5, 8 < Af < 
10, and 1 < L < 2. We wish to form MN + L, properly scaled on 

EXERCISES 
177 
the CDC 1604. Find the scaling steps and write a set of instructions 
which will form and store the product. 
25. Suppose that 1 < Xi < 2 and 2 < y { < 3. We wish to form >2)°™Xiyi 
on the CDC 1604. Determine the scaling and write a set of instructions 
which will form and store the product sum. 
Section 4-2.3 
26. The numbers Ν and M are optimally scaled for the CDC 1604 at 2
4 3 
and 2
5 1. Determine the scaling steps required to form the quotient 
N/M. 
Write instructions to form and store the quotient. 
27. If Ν, M, and L satisfy 3 < Ν < 5, 8 < M < 10, and 1 < L < 2, find 
optimal scale factors for each, and determine the scaling steps, and 
write instructions to form MN/L 
on the C D C 1604. 
Section 4-2.4 
28. We wish to tabulate the function/(x) = 3.2x
2 + 5.4 on the CDC 1604 
at intervals of Δα: = 0.01 in the range 0 < χ < 1. Consider first optimal 
scaling throughout and determine the steps. Next consider the most 
convenient scaling and write a program to carry out the tabulation. 
3 2χ
2 -f- 5.4 
29. Repeat Problem 28 for the function/(z) = - — -
1— — — ' • 
. 
0.5x
2 + 3.7z + 1.9 
30. Repeat Problem 28 for the range 50 < χ < 100. 
31. Repeat Problem 29 for the range 50 < χ < 100. 
32. Values of yfx 
are to be computed on the CDC 1604 using the iterative 
scheme in which the (n + l ) s t approximation, 
Xn+i, 
is obtained from 
the nth, xn, by the iteration 
Xn+i = ?[xn + x/xn~] 
(Newton's method) 
What are the scaling procedures for each of the following ranges: 
(a) .5 < χ < 1, 
xo = 1 
(b) 10 < χ < 100, 
x0 = 50 
If we write a loop to perform the iterations, what kinds of exits from 
the loop can be provided? 
33. An approximate solution for the differential equation dy/dx 
= Sy + 
2x
2 with 2/(0) = 1 is to be found by the method of Example 4-21 for 
the interval 0 < χ < 1, with Ax = h = 0.0001. Do the proper scaling 
and write a CDC 1604 program to carry out the tabulation. 

178 
4. FIXED AND FLOATING POINT ARITHMETIC; SCALING 
Section 4-4 
34. Repeat Problem 15 for fractional operation. 
35. A 48-bit machine with fractional operations contains the following 
octal numbers, scaled as indicated. If each binary number is inter-
preted as having the binary point after the first bit, find the unsealed 
version of each number in decimal. 
Section 4-4.0 
36. Repeat Problems 19-22 for fractional operation. 
(a) 3.1416 
(b) 1,234,567.89 
(c) 0.0123 
(d) 0.00000123 
42. An unpacked floating point representation with coefficient η satisfying 
\ < η < 1 is to be used on a 36-bit, one's complement machine. Find 
(a) 2443 0000 
(b) 2443 0000 
(c) 5447 7777 
(d) 5447 7777 
0000 0000 
0000 0000 
7777 7777 
7777 7777 
(scaled at 2~
8) 
(scaled at 2~
7) 
(scaled at 2
- 8) 
(scaled at 2~
7) 
Section 4-4.1 
37. Repeat Problems 23-25 for fractional operation. 
Section 4-4.2 
38. Repeat Problems 26 and 27 for fractional operation. 
Section 4-4.3 
39. Repeat Problems 28-33 for fractional operation. 
Section 4-5 
40. Repeat Problems 15 and 19-33 for a 48-bit machine which uses absolute 
values and a separately stored algebraic sign. 
Section 4-6 
41. An unpacked floating point representation with coefficient η satisfying 
.1 < η < 1 is to be used on a 9's complement decimal ten-digit ma-
chine. Find the coefficient and true exponent for each of the following 
numbers: 

EXERCISES 
179 
the coefficient and true exponent for each of the following decimal 
numbers and find the octal form for the stored coefficient. 
(a) 32.5 
(b) 1127 
(c) 0.05 
(d) 0.000625 
Section 4-6.0 
(Each of the following is for standard floating point format for 
the CDC 1604.) 
43. Put each of the following decimal numbers in proper floating point 
format in octal. 
(a) 32.5 
(b) 
- 1 1 2 7 
(c) 0.05 
(d) 
-0.000625 
44. Each of the following is the octal version of a standard floating point 
number. Find the decimal equivalent of the number. 
(a) 2003 5510 0000 0000 
(b) 1771 5510 0000 0000 
(c) 5772 2267 7777 7777 
(d) 6003 2267 7777 7777 
45. Each of the following numbers is the octal content of a register, inter-
preted as a fixed point integer with scale factor as shown. Convert 
each to proper floating point format. 
(a) 2440 0000 0000 0000 
(scaled at 2
4 2) 
(b) 2440 0000 0000 0000 
(scaled at 2
4 3) 
(c) 5337 7777 7777 7777 
(scaled at 2
4 5) 
(d) 5337 7777 7777 7777 
(scaled at 2
4 4) 
46. Each of the following numbers is the octal content of a register inter-
preted as a fixed point fraction with scale factor as shown. Convert 
each to proper floating point. 
(a) 2440 0000 0000 0000 
(scaled at 2~
5) 
(b) 2440 0000 0000 0000 
(scaled at 2~
7) 
(c) 5337 7777 7777 7777 
(scaled at 2"
2) 
(d) 5337 7777 7777 7777 
(scaled at 2~
1 0) 
47. Convert each of the numbers in Problem 44 to fixed point integers 
and find the scale factors. 
48. Convert each of the numbers in Problem 44 to fixed point fractions 
and find the scale factors. 
Section 4-6.2 
49. Redo Problems 28-33 for floating point operation. 

CHAPTER 5 
Nonarithmetic Operations 
5-0. Introduction 
The instructions which we have mentioned in the preceding chapters 
have been primarily of the arithmetic and shifting variety. This is not sur-
prising, since our initial ideas about the kinds of things which a digital 
computer might be expected to do naturally focus on the elementary opera-
tions of arithmetic, and on scaling the results of such operations. Never-
theless, we have seen that internal storage of both data and instructions 
necessitates the introduction of a number of operations which a computer 
must be capable of but which are primarily of a nonarithmetic nature. 
Purely transmissive instructions are necessary and yet do not perform any 
direct arithmetic operations. We have seen that we need a stop instruction 
and that we need jump instructions as well. Jump and stop instructions 
are nonarithmetic in the sense that if they deal with data at all, the arith-
metic they perform is only incidental. Their primary function is to. be sure 
that the basic operations are performed in correct order and on correct 
operands. Other classes of instructions may operate directly on data, but 
the operations they perform are not those we would usually call arithmetic. 
For example, in an operand a bit value of one in a particular location might 
correspond to a yes answer to a specific question, while a bit value of zero 
would mean an answer of no. In such a situation we will need to be able to 
deal with individual subsets of digits in a register. The ability to deal singly 
with the digits in a register is called the resolution of a register and is pro-
vided by means of logical operations in contrast to arithmetic operations. 
Finally, we may wish to check large volumes of internally stored data, 
without altering it, seeking words whose digits conform to some predeter-
mined pattern or satisfy some other predetermined condition. This may 
be achieved by combinations of the instructions already mentioned or by 
180 

5-1. 
STOP INSTRUCTIONS 
181 
the introduction of specific instructions for this purpose, called search 
instructions. 
We shall make no attempt here to give an exhaustive discussion of the 
nonarithmetic instructions used on computers. Rather, we will consider 
the major kinds of such instructions which will be common to most com-
puters, with examples to show how they may be used. We start by ex-
amining certain aspects of nonarithmetic operations in general, and we 
then discuss specifically some of those available on the CDC 1604. 
5-1. Stop Instructions 
We can always stop a computer by the equivalent of pressing a button 
on the console. This has frequently been called "hitting the panic button." 
Its disadvantage as a general method for stopping computation is that it 
leaves the operator completely unaware of where the computer is in its 
program, and hence, with no assurance that it is at a suitable stopping 
point. We thus see that a basic necessity for any internally programmed 
computer is an unconditional 
stop instruction to provide a means of halting 
the computer at a predetermined place, usually at a program's end. If we 
do not have such an instruction, the computer must be stopped at random 
or it will continue to operate unless the attempted execution of a super-
fluous instruction word causes a fault condition which stops the computer. 
In any case, even one excess operation can completely spoil the results of 
a program. 
In addition to an unconditional stop, however, we will find that it is 
sometimes desirable to be able to stop at a specific program point if a 
certain condition exists and to go on with the program if it does not. Stop 
instructions which provide this facility are called conditional stops. These 
will be of two general types: 
(1) The condition to be checked is an external one which can be initiated 
at the computer console by the operator, 
(2) The condition to be checked is an internal one which arises as a 
result of program execution. 
An example of the first of these is given by a manually 
selective stop, in 
which the stop occurs only if an appropriate switch is set to the ON posi-
tion at the control board. If the switch is set to the OFF position, the com-
puter continues to operate. Such a stop might be useful, for example, in 
preliminary checkouts of codes. We will often choose to write a lengthy 
program in small sections and check each section in turn. Ending each 
small section with a selective stop will permit us to run one section, stop, 
if desired, look at the results and then continue. We will also make loop 

182 
5. NONARITHMETIC OPERATIONS 
checking easier if we provide optional stops which can be taken after each 
traversal. In the final production run, we will want to go through the 
entire program without making these stops. To do this we set all stop 
switches to the OFF position. Manually selective stop instructions pro-
vide the coder with a valuable tool for the control of program operation 
both during the checkout period and subsequently. 
General situations, common to all programs, in which we may want to 
stop on an internal condition arise from fault conditions. A stop may be 
taken if any one of a number of improper conditions occur, that is, on such 
events as division overflow, exponent overflow, digital combinations which 
are not interprétable as instruction words, and so on. In many machines 
these stops will be provided automatically by the computer control and 
will not require use of an instruction word. In some cases they may be 
selective, that is, a fault condition is indicated, but the stop occurs only 
if the operator has selected it in advance by setting an appropriate control, 
or if an appropriate conditional stop instruction has been placed in the 
program. 
Other cases in which we may want a conditional stop based on an in-
ternal condition will usually be associated with a particular program. For 
example, we might wish to write a program in such a way that the com-
puter will stop if a computed quantity which should be positive becomes 
negative, or if a computed quantity exceeds a certain magnitude or be-
comes sufficiently small. Such stops will have to be tailored to the particular 
program and we will provide them by means of instructions incorporated 
into it. The nature of the instructions used will depend on the computer. 
In some cases we may have to manufacture our own conditional stop by 
means of a combination of a conditional jump and an unconditional stop, 
that is, the computer will jump to the stop order only if the basic jump 
condition occurs. 
We will consider a specific case and some examples in the next section. 
5-1.0. Stop Instructions in the CDC 1604 
The stop instructions in the CDC 1604 also operate as unconditional 
jump instructions. They have the form 76 
j ra, and in all cases the 
jump is taken to address ra, that is, the control will accept its next instruc-
tion from address ra. It will do this immediately in case the stop is not 
taken. If the stop is selected, the control goes to ra only if the computer is 
started again. When the computer is stopped, of course, the operator can 
manually reset the content of Ρ to any address he wishes. 
The CDC 1604 stop instruction actually consists of eight subinstruc-
tions which are selected by the value of the designator j . In execution, no 
reference is made to an index register. Thus, there is no address modifica-

5-1. 
STOP INSTRUCTIONS 
183 
tion and the jump address is always M = m. The value of j determines 
whether an unconditional stop or a manually selective stop is taken and 
makes a reference to the appropriate stop key in the console. The subin-
structions are 
76 
0 
m 
Stop unconditionally (normal jump) 
76 
1 
m 
Stop if key 1 is up (normal jump) 
76 
2 
m 
Stop if key 2 is up (normal jump) 
76 
3 
m 
Stop if key 3 is up (normal jump) 
76 
4 
m 
Stop unconditionally (return jump) 
76 
5 
m 
Stop if key 1 is up (return jump) 
76 
6 
m 
Stop if key 2 is up (return jump) 
76 
7 
m 
Stop if key 3 is up (return jump) 
Of these, 76 
j 
m is an unconditional 
stop if j = 0 or 4. It is a selective 
(and conditional) stop if j = 1, 2, 3, 5, 6 or 7. For j = 0, 1, 2, 3 the jump 
is normal, that is, the next instruction will be the upper instruction at m. 
For j = 4, 5, 6, 7 the jump is a return jump, that is, the next instruction 
will be the lower instruction at m and provision is also made to return to 
the original sequence of instructions. We defer a detailed discussion of this 
feature until Chapter 6 and consider some examples in which the normal 
jump aspect is used. The operator is free to change the position of the stop 
key at any time during the course of the program. 
Example 5-0. We are writing a program whose entry point is at storage 
address 01000 and in which the final operation is in the upper instruction 
stored at address 01103. We wish to use an unconditional stop and to be 
able to rerun the program with a minimum of effort. Since the program 
begins at address 01000, we provide a jump to this location, and hence 
we use the lower instruction 76 
0 
01000 at 01103. We may then rerun 
the program by simply restarting the computer. 
Example 5-1. We wish to end a program at address a and have no in-
tention of rerunning it. We then may use as the upper instruction of the 
program step at address a, 76 
0 
a. This prevents accidental restarting 
of the program. 
Example 5-2. We write a program in three sections. In checking it out 
we wish to be able to stop at the end of any single section and sample the 
contents of various registers. For the final run, we wish to proceed with no 
stops except the last. The program begins at address 01000. The first sec-
tion ends with the lower instruction in address 01103, the next section ends 
with address 02103 and the last section with address 03103. Since we wish 
to go through all sections with no intermediate stops on the final run, we 

184 
5. NONARITHMETIC OPERATIONS 
use selective stops at the end of the first two sections, and an unconditional 
stop at the end. The instruction pattern is: 
ENTRY POINT 
01000 
01103 
76 
1 
01104 
Stop if key 1 is up, 
otherwise proceed 
01104 
02103 
76 
2 
02104 
Next instruction. 
Stop if key 2 is up, 
otherwise proceed 
02104 
03103 
Next instruction 
76 
0 
01000 
STOP 
The use of a value of j = 1 in one case and j = 2 in the next permits us to 
take either conditional stop or both at liberty. The final instruction serves 
the same purpose as in Example 5-0. For the final run we will set all selec-
tive stop keys to OFF. 
Example 5-3. We wish to do the three sections of Example 5-2 in the 
order 1-3-2. Storage is the same, and we use the following instruction 
pattern: 
ENTRY POINT 
01000 
01103 
Stop if key 1 is up, 
76 
1 02104 
jump to 02104 
01104 
02103 
76 
0 
01000 
Stop, set up for restart 
02104 
03103 
Stop if key 2 is up, 
76 
2 
01104 
jump to 01104 

5-2. JUMP INSTRUCTIONS 
185 
In Example 5-2 we used the jump feature to proceed sequentially. In Ex-
ample 5-3 we have used it to jump from one section to a nonsequential 
one. In all cases, we note that the jump occurs regardless of whether or 
not we select the stop. 
Example 5-4. During checkout of a program we wish to stop and sample 
the content of various registers after each traversal of a loop; but during 
normal runs we wish to traverse the loop as often as necessary without 
stopping. We assume that the entry point of the loop is at address a and 
that the loop is controlled by means of an index skip instruction in the 
upper part of register β. We then write 
ß 
ß + l 
ß + 2 
54 b y 
76 
76 
1 ß + 2 
— 
Continue 
AH traversais? If not, go back to α, but stop first if 
key 1 is up. If yes, continue, but stop first if key 
ι :„ 
1 is up. 
In situations such as in Example 5-4, we often have more than one loop. 
We can proceed in a similar manner for each loop and try to use different 
j values. This is particularly important for the case of a loop within a loop, 
since we will probably wish to check the inner loop before the outer one. 
On the CDC 1604 conditional stops which depend on an internal condi-
tion, but which do not arise as the result of fault conditions, will need to 
be programmed with the aid of jump instructions. We will consider these 
in Section 5-2.1. Stops which occur as a result of internal fault conditions 
are optional; that is, when a fault condition occurs, a visual indication is 
made on the console but the computer does not stop unless the programmer 
has so elected by insertion of the proper instructions in his program. The 
key instruction in this procedure is the external function, 74 j 
z. This 
instruction will be considered in greater detail in Chapter 7. We note, 
however, that fault indication on the console is by means of a red light 
occurring at one of the 16 stages of the octal representation of (A). 
For 
arithmetic faults there are, with AuAw 
·Άοΐ 
(1) floating point range fault, 
A0 
(2) overflow fault, 
Αι 
(3) shift fault, 
A2 
(4) divide fault, 
Az 
Other fault indications concern storage and external equipment and will 
not be discussed here. 
5-2. Jump Instructions 
We have already considered in some of our earliest programming ex-
amples the necessity of providing jump instructions in implicit computers 
which will take the control out of its normal sequential mode of operation. 
An obvious situation is in the writing of the loops, where we have to go back 

186 
5. NONARITHMETIC OPERATIONS 
to an earlier address in the sequence of program addresses. In explicit 
computers each instruction includes a jump, that is, each instruction con-
tains the location of the instruction which is to follow. In all cases, however, 
different kinds of jump instructions will be needed, and these, like the stop 
instructions, may be characterized as conditional and 
unconditional. 
Those jump instructions in which the jump is always made independently 
of any current conditions existing in the computer are called 
unconditional 
jumps. 
An example is given by the jump feature of the stop instructions 
in the CDC 1604 discussed in the last section. Here the jump is always 
taken, whether the stop is chosen or not. In a conditional jump 
instruction, 
the jump is taken only if a specified condition, either internal or external, 
is satisfied. Again, as with stops, conditional jumps will be selective if the 
condition to be fulfilled is under the control of the operator at the console, 
and the uses of such selective jumps are much the same as those of selective 
stops. They make for greater versatility in putting a program together, 
permitting the inclusion of a number of optional features. If we consider a 
few typical situations in which jump instructions are needed, we will see 
the reason for the different kinds and the most common kinds that are 
provided. 
Consider, for example, the use of a subroutine. Such a routine is a pro-
gram related to, but not part of, the main program, which will need to be 
repeatedly referred to from different points in the main program, for ex-
ample, a routine which computes vector sums. If subroutines are to be 
used, we must obviously have some method to jump from any point of 
the main program to the entry of the subroutine, and the subroutine must 
provide a final jump back to the continuation of the main program. Since 
we must continue at an appropriate place, the initial jump to the subroutine 
must provide a means of returning to this place and is called a return 
jump. 
We note that the return jump and the jump which actually effects the 
later return will normally be unconditional, although certain problems may 
require that either one or both of the jumps be made only if a specified 
condition holds. The use of subroutines and related return jumps will be 
discussed in detail in Chapter 6. 
External conditional jumps are almost invariably based on the setting 
of switches by the computer operator at his console. If there are η such 
two-way switches, 2
n different external jump conditions can be selected 
and treated by appropriate combinations of selective conditional jump 
instructions. 
For examples of the use of conditional jumps we think immediately of 
some of our earlier programs containing loops in which a jump back to the 
loop entry point was required a specified number of times. A jump of this 
kind is called an index jump and is made conditionally on the basis of the 
current value of an integer called the index. Whether the counting pro-

5-2. JUMP INSTRUCTIONS 
187 
cedures in index jumps are provided automatically or must be programmed 
will depend on the machine. The final effect is the same in either case. 
In some loops we know in advance the precise number of times we need 
to traverse the loop and can use an index jump. Consider, however, an 
iterative loop such as the one associated with Newton's method of finding 
square roots (see Chapter 4, Problem 32). Here the work done in the loop 
consists of computing a new approximation to the square root based on 
the previously computed one. In general, we will either not know or will 
not wish to compute in advance the exact number of iterations required 
to obtain a certain accuracy. Some other cutoff criterion must be used. A 
simple one would be to exit from the loop when two successive iterates 
differ by less than a specified magnitude, | x n +i — xn \ < Ε. This means 
in this case that the condition for a jump to re-enter the loop is based on a 
comparison of two numbers. If Ν > Μ, we take the jump. If Ν < Μ, we 
do not. In computers in which both Ν and M can be specified in a single 
instruction we may use these conditions directly. The various combinations 
which occur are: 
(a) Is Ν = M or is N 9
e ΜΊ 
(equality jump) 
(b) Is Ν < M or is Ν > ΜΊ 
(threshold jump) 
(c) Is Ν > M or is Ν < ΜΊ 
(threshold jump) 
Thus, in the example, we could use Ν = | xn+i — xn | and Μ = Ε with 
condition (b) above. However, if the value of only one number, N, can be 
specified in a single instruction, the second number, M, must be implicit 
and the obvious choice for M is zero. This would give as the equivalent of 
the three conditions: 
(d) Is Ν = 0 or is N 9
e 0? 
(zero jump) 
(e) Is Ν < 0 or is Ν > 0? 
(sign jump) 
(f) If Ν > 0 or is Ν < 0? 
(sign jump) 
In such a computer we would replace the condition | χη+ι 
— xn \ < Ε by 
the equivalent condition | χη+ι 
— xn | — Ε 
< 0 and, with Ν 
= 
I Xn+i — xn I — Εy use condition (e). 
In the preceding example we have seen that there is a certain redundancy 
in the conditions, in terms of the fact that we could achieve condition (b) 
by a combination of subtraction and condition (e). The redundancy is 
even greater than this. We see that conditions (a), (b), and (c) are im-
mediately obtained by subtraction and use of (d), (e), and (f ), respectively. 
In turn, (d) can be replaced by a combination of (e) and (f ), since Ν = 0 
if and only if Ν < 0 and Ν > 0, that is, if both Ν > 0 and Ν < 0. Finally, 
since Ν > 0 is the same as — Ν < 0, we can replace (f) by (e) and thus 
all six conditions by (e). 
Many computers will have conditional jump instructions with redundant 

188 
5. NONARITHMETIC OPERATIONS 
conditions in order to speed operation and simplify the task of coding. 
Redundancy is sometimes compounded for the sake of convenience by 
having more than one form of a jump instruction, using the same condition 
with each form, explicitly available as a separate instruction. For example, 
both an instruction which initiates a jump on the condition Ν < 0 and 
causes control to proceed in sequence otherwise and an instruction which 
initiates a jump on the condition Ν > 0 may be present, even though the 
effect of the latter can be attained by following the first form of the in-
struction with an unconditional jump. 
The form and definition of jump instructions will vary with the number 
of addresses available for the instruction word. In single address machines 
the address part almost always specifies the jump location. There are jump 
instructions in which the jump address is implicitly defined by the opera-
tion code. However, the operation code is much more likely to be used to 
specify the jump condition and the register in which it is to be tested. 
Machines may also vary in the particular registers in which conditions for 
jumps are tested, and we may in some cases have to use auxiliary transmis-
sive instructions in conjunction with jump instructions. In other cases we 
may have different operation codes for testing the same jump condition 
in different arithmetic or control registers. 
Two address machines provide a means of specifying two jump locations 
in a single instruction. Thus we can attain both direct forms of a jump in 
one instruction, for example, if Ν < 0, the jump is to one address, and if 
Ν > 0, the jump is to the other. On the other hand, rather than use the 
second address to specify a jump location, we might use it to give the 
storage location of data to be tested for the jump condition. The instruction 
may possibly test this last data against data already in a control or arith-
metic register implicitly selected by the operation code. Three addresses 
present even more possibilities and we leave it to the reader to amuse him-
self by defining plausible jump instructions utilizing two and three or 
more address parts. 
We note that the basic investigation of whether a number is positive, 
negative or zero will require a longer time for the computer to answer for 
zero, than it will for plus or minus. In the latter case only a sign bit or 
sign symbol will need to be consulted. In the case of zero the computer 
must test each digit or the equivalent. In jumps based on algebraic sign 
only, we must pay attention to what happens to a zero value. In a one's 
complement machine, for example, if only the sign bit is tested, the positive 
form of zero will be lumped with the positive numbers, and negative zero 
will be lumped with negative numbers. Minor variations will thus occur in 
the handling of zero in different machines, and we must be certain that we 
apply the jump instructions properly, particularly if we change sign in 
order to utilize the existing form of a sign jump directly. 

Ö-2. JUMP INSTRUCTIONS 
189 
Suppose, for instance, that we consider a jump which is to be taken if a 
number is negative and not taken if it is positive, and that only the sign 
bit is tested. In a machine which generates only positive zero we would 
have 
Ν < 0, 
jump 
Ν > 0, 
do not jump 
but with a machine which generates only negative zero we would have 
Ν < 0, 
jump 
Ν > 0, 
do not jump 
That is, in the first case, the jump is taken only if the number is strictly 
less than zero, whereas in the second case it will be taken if the number is 
either negative or zero. We must therefore be familiar with the particular 
characteristics of the computer we use. In computers which generate both 
forms of zero we will have to be particularly careful to avoid ambiguities 
in our jump conditions. 
In a well-designed computer, jump instructions will rarely, if at all, 
alter the content of storage or arithmetic registers unless they are return 
jumps. Sign jumps, zero jumps, equality jumps, and threshold jumps 
should not alter the content of any storage or arithmetic register unless 
the return jump feature is included. In this event a part of the content of 
a storage register will be set to the current value of the content of the 
program register. However, all data tested against the jump condition 
should remain unchanged or be restored. Unconditional jumps without 
the return features will leave the content of all storage and arithmetic 
registers invariant. An index jump will, of course, change the index. If the 
index is held in an index register and modified in control registers, no varia-
tion in storage or arithmetic register content should be expected. However, 
this is obviously not the case if the index is held in a storage register and 
increased or decreased in the accumulator. 
In the next section we consider some specific jump instructions and 
their uses. 
5-2.0. Jump Instructions in the CDC 1604 
In the CDC 1604 the jump instructions are: 
Instruction 
Operation code 
A jump 
22 
Q jump 
23 
Selective jump 
75 
Index jump 
55 
Each of the first three instruction names actually represents a group of 
eight instructions whose individual members are differentiated by the 

190 
5. NONARITHMETIC OPERATIONS 
assignment of different values to the designator j . In each group the in-
structions associated with the designator values j = 0, 1, 2, 3 are normal 
jumps and those associated with the designator values j = 4, 5, 6, 7 are 
return jumps. In all normal jumps the jump is made to the upper 
instruction 
at the specified location. In return jumps the jump is made to the lower 
instruction of the specified location. Prior to the jump, however, the ad-
dress of the upper instruction at this location is replaced by the jump in-
struction address plus one. This information permits the programming of 
a later return to the original sequence of instructions. This feature is most 
useful working with subroutines. For this reason we will postpone further 
discussion of return jumps to Chapter 6, confining our discussion in this 
chapter to normal jumps. The index jump is a normal jump for all values 
of the designator. 
The jumps employing the designator form j make no reference to index 
registers and so involve no address modification. Although the index jump 
uses the designator form b to refer to index registers, the reference is for 
the purpose of operating on the content of the register and not for address 
modification. Therefore, in all jump instructions, the effective jump ad-
dress and the base jump address are the same, that is, m = M. Another 
common characteristic of the jump instruction is that in every case when 
the jump is not taken the control proceeds sequentially to the next instruc-
tion. Any jump instruction may be used in either the upper or lower portion 
of a program step. 
The A jump and Q jump are conditional jumps which test internal 
conditions. Their characteristics for different j values are as follows: 
zero jump in A 
>r 
(A) 
= + 0 \ 
. 
. 
>r 
(A) 
= - 0 / 
« 8 * ™* 
zero jump in Q 
ar 
(Q) = + 0 \ 
. 
. 
. 
n 
a T 
(Q) = - o / 
sigixjumpmQ 
We see that the only differences in these jumps is the location of the 
register which holds the data. For j = 0 or 1 the number —0 is treated 
the same as + 0 . For j = 2 the leading one bit in —0 is sensed and the jump 
does not occur. For y = 3 the zero bit in + 0 is sensed and the jump does 
jump, 
22 
j 
j = 0: 
jump 
j = 1: 
jump 
j = 2: 
jump 
j = 3: 
jump 
m 
if 
(A) = 0 
if 
(A) 
0 
if 
(A) > 0 
if 
(A) < 0 
Q jump, 
23 
j 
j = 0: 
jump 
j = 1: 
jump 
j = 2: 
jump 
j = 3: 
jump 
m 
if 
(Q) = 0 
if 
(Q) 
0 
if 
(Q) > 0 
if 
(Q) < 0 

5-2. 
JUMP INSTRUCTIONS 
191 
not occur. For the normally generated + 0 , j = 2 gives a jump if (A) 
or 
(Q) > 0. The normal form of these jumps does not change the content of 
A, Q, or any index or storage register. 
The Selective Jump, 75 j 
m, takes the following forms for normal 
jumps: 
j = 0: 
jump unconditionally 
7 = 1: 
jump if jump key 1 is up 
j = 2: 
jump if jump key 2 is up 
7 = 3 : 
jump if jump key 3 is up 
Of these, the first is unconditional, while the next three are selective and 
operate in a manner similar to that of the stop instruction. In the index 
jump an index register is referred to. 
The Index Jump, 55 
b 
m is a conditional jump in which the data to 
be tested is in the index register designated by the b value. If (B
b) 
j± 0, 
then (B
b) 
— 1 is formed in B
b and the jump is taken. At the point where 
(B
b) 
has been reduced to + 0 , the jump does not occur, and —0 is not 
generated. The jump to m, when taken, is a normal jump. Since (B°) = 0, 
the jump is not taken for b = 0 and the instruction becomes a pass or do-
nothing instruction. The index jump carries out two operations, a jump 
and a countdown, and the jump will be taken only the number of times 
specified by the original content of B
b. The maximum value of the index is 
32,767. 
We consider several examples to show different ways of achieving the 
same results and to illustrate typical uses of the jump instructions. We 
note that some of the illustrations will represent inefficient applications of 
the jump instructions, but they will serve to illustrate similar usage on 
machines which have a different complement of jump instructions. 
Example 5-5. We have the number one and the number one hundred 
stored, and we wish to generate and store the first one hundred positive 
integers starting at ßo. We enter the code at a 0. 
ENTRY 
« 0 
50 
1 00000 
50 0 00000 
Set index register 1 to zero. 
PASS. 
αϊ 
12 0 /(99) 
20 0 /(counter) 
Set counter to 99. 
« 2 
10 0 00001 
20 0 ßo 
Set (ßo) = 1. 
« 3 
12 1 ßo 
11 0 00001 
(ßi) + 1-+A, 
i = 0 initially. 
« 4 
20 
1 ßl 
51 
1 00001 
(ßi) + 
1 -> ßi+1, 
i 
= 
0 
initially, increase i. 
<*5 
12 0 /(counter) 
11 0 77776 
(Counter) — 1 —• A, count 
down. 
EXIT 
« 6 
20 0 /(counter) 
22 0 
Of 10 
Preserve count. Count zero? 
If yes, STOP. 
« 7 
« 1 0 
75 
76 
0 
0 
az 
aio 
50 0 00000 
If not, reloop. PASS. 
STOP. 

192 
5. NONARITHMETIC OPERATIONS 
Here we have created our own index jump by use of a conditional zero 
jump and an unconditional jump. We do our own countdown in a storage 
register reserved for this purpose. With the use of this form of the zero 
jump we must jump to the stop instruction. Hence, when the zero jump is 
not taken, we need an unconditional jump to reloop. Since the jump is 
normal, we put the stop at the upper instruction of αι0, rather than the 
lower instruction of αη. At αβ, the current content of the counter is still in 
A, so we can use an A jump. 
Example 5-6. We repeat Example 5-5, using a different form of zero jump. 
ENTRY 
« 0 
50 
1 00000 
50 0 00000 
Set index register 1 to zero. 
PASS. 
cti 
12 0 /(99) 
20 0 /(counter) 
Set counter to 99. 
a2 
10 0 00001 
20 0 
ßo 
Set (ßo) = 1. 
az 
12 1 ßo 
11 0 00001 
(ßi) + 1 -> A, 
i = 0 initially. 
« 4 
20 
1 ßi 
51 
1 00001 
(ßi) + 1 -» ßi+l, 
i = 0 ini-
tially, increase i. 
« 5 
12 0 /(counter) 
11 0 77776 
(counter) 
— 1 —> A, count 
down. 
« 6 
20 0 /(counter) 
22 
1 
« 3 
Preserve count. Count zero? 
No, reloop. Yes, STOP. 
CC7 
76 0 
« 0 
STOP. 
Here the count is made down as before, but this time the jump is to re-
enter the loop if the count is not zero. Hence, we can eliminate the uncon-
ditional jump. 
Example 5-7. We repeat Examples 5-5 and 5-6 using the index jump. 
ENTRY 
« 0 
50 
1 00000 
50 2 00142 
Set index register 1 to zero. Set index 
register 2 to 98. 
« 1 
10 0 00001 
20 0 ßo 
Set (ßo) = 1. 
« 2 
12 1 ßo 
11 0 00001 
(A)-.il, 
(ßt) + 
l-+A. 
« 8 
20 1 ßi 
51 
1 00001 
(ßi) + 1 —> ßi+h 
increase i. 
a 4 
55 2 
« 2 
76 0 «ο 
Count zero? No, reloop. Yes, STOP. 
Here the countdown is done automatically by the builtin feature of the 
index jump. This eliminates many of the initial prestoration instructions 
and all other countdown instructions. 
Each of these usages of jump instructions achieves the same end, that 
is, that the loop be traversed a specific number of times. However, the 
efficiency with which this result is achieved varies. In the general case, of 
course, the manner of obtaining an index jump will depend on the com-
mands available. We note that there are still other ways of obtaining it 
on the CDC 1604. For example, we might have used a 22 
2 
m instruc-
tion and an initial value in our counter of two less than the total number 
of traversais we wanted. 
Example 5-8. A continuous function satisfies f(x) 
> 0 for χ = 0 and 
f(x) 
< 0 for χ =?= 1, so that a root of f(x) 
= 0 lies between 0 and 1. We 

5-2. 
JUMP INSTRUCTIONS 
193 
wish to obtain an approximate value of this root by tabulating f(x) 
in 
small increments AX and recording the first value of χ for which f(x) 
is 
negative. The program for computing/(x) has prestoration instructions 
from a 0 to ay_i and the basic loop from <*j to a*. 
ENTRY a 0 
EXIT 
ctk 
a * + i 
ajfc+2 
ajfc+3 
ajfc+4 
12 0 
/[/(*»)] 
75 0 α,· 
12 0 
t(xn) 
76 0 
a 0 
22 
3 
a j t + 3 
50 0 
00000 
20 0 
/(approx. root) 
f(x) - A, /(*) < 0? 
No, reloop. 
Yes, store current x». 
STOP. 
To achieve our result this way, we used a combination of a conditional 
and an unconditional jump to exit from the loop whenf(x) 
< 0. We note 
that the case f(xn) 
= 0, which gives a true value of the root, would be 
ignored by this code because f(xn) 
= 0 is not negative, since a positive 
zero would normally be computed. To include zero we can use the instruc-
tion 22 j 
m with j = 0 or 1. 
Example 5-9. We are using loop procedure to code an iterative procedure 
to compute successive approximations xn, each being computed from the 
preceding. We wish to terminate the iterations if | xn+i 
— xn \ < E. The 
loop entry is at ay and x n+i is computed at a*. 
12 0 
l(xn+i) 
15 0 
*(Xn) 
Form X n + i 
— xn in A. 
Otk+2 
22 
2 
ajfc+4 
20 
0 
l(Xn+\ 
— Xn) 
Test if Xn+l 
— 
Xn 
> 0. If S O , Xn+l 
~ 
Xn = 1 Xn+l 
— 
Xn\mA. 
OCk+3 
13 
0 
t(xn+l 
- 
Xn) 
PASS 
If not, form — ( x n + i 
— xn) 
= 
1 Xn+i 
— 
Xn 
1 in 
A. 
Otk+4 
15 0 
1(E) 
22 
3 
Form I χη+ι — xn \ — Ε and test 
1 Xn+l 
- r Xn 
| < 
E. 
<Xk+6 
75 0 
a , 
PASS 
If not, re-enter loop. 
a * + 6 
12 0 
t(xn+l) 
20 
0 /(final re suit) 
If so, store current value. 
« * + 7 
Continue program 
Here we have used two jump instructions, one for the purpose of con-
structing I xn+i 
— xn I and the other for testing the condition for re-entering 
the loop or not. The condition | xn+i — xn \ < Ε was translated into 
I Xn+i 
— xn I — Ε < 0 to use the available jump. 
Use of the Q jump is essentially the same as that of the A jump, and 
which is chosen will, in general, be a matter of programming convenience. 
In some circumstances, a joint use is indicated. 

194 
5. NONARITHMETIC OPERATIONS 
Example 5-10. We have two numbers a and b. At program step ay we 
wish to test whether they are of like sign or of opposite sign. If they are 
of like sign, we wish to go to the program step at am, and if they are of 
unlike sign, we wish to go to the step at α Λ. 
a, 
« J + 2 
« ; + 3 
12 0 1(a) 
16 0 1(b) 
22 2 aj+3 
23 3 
am 
75 0 an 
PASS 
23 2 am 
75 0 a„ 
a->A, 
b-+Q. 
a > 0? If not, a < 0, so test b. If b < 0, go to am. 
a < 0 but b > 0 go to a„. 
a > 0. If b > 0, go to am. If 6 < 0, go to an. 
Here the sequencing is as follows: a and 6 are placed in A and Q, respec-
tively. The instruction at ay+i is such that if a > 0, control goes to ay +3 to 
test 6. If 6 > 0, and the numbers are of like sign, the jump is taken to a m, 
but if b < 0, the jump is skipped and the lower instruction sends control 
to am. On the other hand, if a < 0 at 
the jump is not taken and the 
lower instruction tests b. If b < 0, it has the same sign as a and control 
goes to am on the Q jump; but if b > 0, the jump to an is made at ay+2. The 
use of both A and Q jumps is for illustration. We could, of course, form ab 
and test the sign of the product. 
We have considered various uses of conditional jumps, based on internal 
conditions. These illustrate the general kind of coding problem which such 
jumps help to solve and the fact that there will usually be a number of 
different ways of achieving the same solution. To conclude the section on 
jump instructions we will consider some examples of the use of conditional 
jumps based on external conditions. 
Example 5-11. We have a program consisting of three sections: (1) from 
a 0 to ay, (2) from ay+i to ak, and (3) from ak+i to a n. We have written it 
so that we may decide at the console whether to use the normal order 1, 
2 and, omitting 3, stop or the optional order 1, 3 and stop, omitting 2. 
We choose the optional order by setting jump key 1 up. 
If jump key 1 set go to section 3, otherwise 2. 
« J + 1 
STOP 
STOP 

5-2. 
JUMP INSTRUCTIONS 
195 
We see that if jump key 1 is not up, the jump is ignored and control proceeds 
sequentially through sections 1 and 2 and stops at a. If the key is up, the 
program jumps at ctj to 
ctk+i. 
Example 5-12. We wish to repeat the Example 5-11 but, for checkout, 
provide for optional stops at the ends of sections 1, 2, and 3 by use of 
stop keys 1, 2, and 3, respectively. 
OCk-l 
Otn-
76 
1 a, 
75 1 ctk+i 
Pass 
76 2 «o 
76 3 ao 
This code will form a closed loop if no stop switch is up. We assume that 
exits have been coded for either jump option. 
Example 5-13. In the loop beginning at a 0 in Example 5-12 we wish to 
compute using the normal sequence until a quantity x» becomes negative. 
The occurrence of a negative value is a signal to switch to the optional 
sequence. That is, to stop the computer and set jump switch 1 to the up 
position. We begin testing the sign of Xi at 
aj+i. 
a
i + i 
« J + 3 
12 0 l(xi) 
22 3 α,·+3 
75 0 α,+4 
76 0 ao 
xn < 0? ALARM! 
> 0, proceed. 
STOP: re-enter for new order. 
This is an example of a conditional stop, as discussed in Section 5-1, ob-
tained by use of a conditional jump and an unconditional stop. The stop 
condition is internal and arises during computation as opposed to the 
selective stops, which are externally set by the operator at any time. 
Example 5-14. On reading address a0) a program must determine which 
of eight possible options has been selected and jump to an appropriate 

196 
5. NON ARITHMETIC OPERATIONS 
program entry point for that option. The operator selects a specific option 
by setting jump keys according to the accompanying tabulation. 
Option 
Key 1 
Key 2 
Key 3 
Entry point 
0 
Down 
Down 
Down 
β 
1 
Down 
Down 
Up 
7 
2 
Down 
Up 
Down 
δ 
3 
Down 
Up 
Up 
μ 
4 
Up 
Down 
Down 
ρ 
5 
Up 
Down 
Up 
σ 
6 
Up 
Up 
Down 
θ 
7 
Up 
Up 
Up 
φ 
Two programs corresponding to the entry points defined in the table are 
given below. 
« 0 
75 1 ai 
75 0 
a2 
If key 1 up, go to α ι . If key 1 down; go to a2. 
oci 
75 2 
OC3 
75 0 
a4 
Key 1 up; if key 2 up go to a 3 . Key 1 up and 2 down, 
go to « 4 . 
OC2 
75 2 
« 6 
75 0 
a 6 
Key 1 down. If key 2 up go to a 6 . Key 1 down and key 
2 down; go to αβ. 
ocz 
75 3 φ 
75 0 θ 
Key 1 up and key 2 up; if key 3 up go to φ. Key 1 up 
and key 2 up and key 3 down; go to 0. 
Ol4 
75 3 σ 
75 0 ρ 
Key 1 up and key 2 down; if key 3 up go to σ. Key 1 
up and key 2 down and key 3 down; go to p. 
OLh 
75 3 μ 
75 0 δ 
Key 1 down and key 2 up; if key 3 up, go to μ. Key 1 
down and key 2 up and key 3 down; go to δ. 
« 6 
75 3 y 
75 0 β 
Key 1 down and key 2 down; if key 3 up, go to y. 
Key 1 down, key 2 down and key 3 down; go to β. 
75 1 
« 3 
75 2 
OL2 
If key 1 up, go to a s . Key 1 down, if key 2 up go to a 2 . 
OL\ 
75 3 7 
75 0 β 
Key 1 down, key 2 down; if key 3 up go to y. Key 1 
down, key 2 down, key 3 down; go to β. 
OC2 
75 3 μ 
75 0 δ 
Key 1 down, key 2 up; if key 3 up go to μ. Key 1 
down, key 2 up, key 3 down; go to δ. 
ocz 
75 2 
« β 
75 3 
σ 
Key 1 up; if key 2 up, go to a 5 . Key 1 up, key 2 down, 
if key 3 up, go to σ. 
OC4 
75 0 Ρ 
50 0 00000 
Key 1 up, key 2 down, key 3 down; go to p. PASS. 
OCb 
75 3 Φ 
75 0 Ö 
Key 1 up and key 2 up; if key 3 up, go to φ. Key 1 up, 
key 2 up, key 3 down, go to 0. 
5-3. Resolution of Register Content 
We have already noted that programming situations arise which will 
require that we be able to handle subsets of individual digits in a register. 

5-3. 
RESOLUTION OF REGISTER 
CONTENT 
197 
An instruction such as the sign jump specifically tests the single sign bit. 
In other cases, however, we must be provided with a means of dealing 
with arbitrary combinations of digits, for example, in a packed 
floating 
point format, we must be able to extract and treat separately those digits 
which form the exponent and those which form the coefficient. Many other 
situations occur in which we need to resolve the content of a register into 
component parts, and often the individual digits will not even represent 
numbers. Consider, for example, a machine with storage registers capable 
of holding six bits. We assign to the bits in order from the highest the mean-
ings: sex, college degree, experience, age range 20-29, age range 30-39, 
age range 40 or over. In each case, respectively, a one will mean: male, 
yes, 4 or more years, yes, yes, yes, whereas a zero means female, no, less 
than 4 years, no, no, no. Thus, a 28 year old male college graduate with 
two years of experience would have an identification 110100. Such an 
identification tag would permit a computer, with the ability to resolve 
the content of a storage register, to sample a large file of applicants and 
select those with acceptable job qualifications. For the most part, such 
functions are handled by means of instructions that are based on logical 
operations. The reason for this terminology stems from the fact that these 
computer operations correspond to operations in a mathematical descrip-
tion of logic called Boolean 
algebra. 
The basic logical operations involved in computer instructions apply to 
binary operands and are bit-by-bit. They are, for each bit, 
Logical product 
0 <S 5> 0 = 0 
0 <S S> 1 = 1 ® 0 = 0 
1 C 5 1 = 1 
Logical sum 
o e 5 0 = 0 
o e B> 1 = 1 ® 0 = 1 
1 € & 1 = 
1 
Although, for one digit, logical multiplication is the same as ordinary 
binary multiplication and logical addition is almost like ordinary addition, 
we have used the ® and ® notation to emphasize a distinction which 
will be much more apparent when we apply these operations to sequences 
of digits. We mention that the ® operation is equivalent to the logical 
"and" while the ® operation is equivalent to the logical "or." We will not 
emphasize this feature here, but the interested reader might consider its 
applications to solving logical puzzles on a computer. 
As used in computers, logical operations are applied to sequences of 
digits, so we extend the definitions to two sequences (of the same length) 
of binary digits. The more commonly used operation is the logical product. 

198 
5. NONARITHMETIC OPERATIONS 
F or two binary representations χ and y we use the notation L[x, y~], called 
the logical product of χ and y , and define it to be the bit-by-bit 
product of 
χ and y ; that is, if χ = xnxn-i* 
· 'Xo and y = ynyn-i' 
· *2/o, where xt- and ?/» 
are bits, then L[>, y~] = (x n ® 2/n) (xn-i 
® 2/n-i) · · · (zo ® 2/o). The bit-by-
bit operation is illustrated in the following example. 
Example 5-15. If χ = 1010110 and y = 0110111 we have 
χ = 1010110 
y = 0110111 
L[x, y ] = 0010110 
Note that there is no carry or addition as there would be in an ordinary 
multiplication. We have simply formed in any order, so long as we omit 
no pair, 
(1 ® 0) 
(0 ® 1) 
(1 ® 1) 
(0 ® 0) 
(1 ® 1) 
(1 ® 1) 
(0 ® 1) 
to give 
0 
0 
1
0 
1
1
0 
In the same manner, we can form the bit-by-bit logical sum of two 
binary words of equal length using the ® operation. The use of logical 
addition is likely to be required in more advanced and subtle programming 
problems. An example will be given below. We note that in the logical 
product of two words, χ and y , the presence of a zero in y produces a zero 
in the corresponding position of the result regardless of the bit value in 
the corresponding position in x. On the other hand, the presence of a one 
in y will produce or copy the same digit as in x. That is, if we think of y as 
an operator on x, a zero will suppress the corresponding digit, while a one 
will reproduce it. It is this feature which permits us to extract an arbitrary 
combination of digits from x. The idea has symmetry, and if we wish, we 
may consider χ as an operator on y in precisely the same way. 
Example 5-16. In a seven-bit machine, we wish alternately to extract 
the low order three and the high order four digits, filling the remainder of 
the register with zeros. For the low order three, we use a value of y = 
0000111 to give, for χ = 1010110, L[x, ?/] = 0000110, and to extract the 
high order four we use y = 1111000 to give, for the same x, L[x, ?/] = 
1010000. 
In Example 5-16 the values of y used to extract digits from selected 
positions are referred to as masks, that is, they mask out the unwanted 
portion of the sequence. It is easy to see how, by the use of such masks, 

5-3. 
RESOLUTION OF REGISTER 
CONTENT 
199 
we can resolve a register into component parts: exponent and coefficient, 
operation code and address, and so on. 
Usually in a computer the basic operation of forming a logical product 
or sum will be utilized in a number of related operations giving specialized 
combinations of logical and transmissive, complementing, and arithmetic 
instructions. These will facilitate coding the resolution of register content 
and will vary from computer to computer. The basic concept in such opera-
tions, however, is always the logical product and/or sum. 
The circular shifting operations, which we have conceived as auxiliary 
arithmetic operations, also play an important role in relation to logical 
operations. For example, a circular shift will prove to be a convenient 
means of positioning a mask relative to a piece of data it is to be applied 
to, or vice versa, in positioning data relative to a given mask. 
Example 5-17. We have a six-bit machine in which we have stored a per-
sonnel file in accordance with the discussion given in the first paragraph 
of this section.. We wish to count the number of males available for assign-
ments. We can proceed as follow. We extract the bit defining sex with the 
mask y = 100000 and copy this information into another location. (An 
instruction combining a logical product and a transmit would prove con-
venient for this purpose.) We then circularly shift each extracted word 
left one position to put the bit defining sex into the units place. Now if we 
add the entire extracted file, we will get an integer equal to the number of 
males in the file. 
Example 5-18. A computer maintenance engineer wishes to write a 
program to determine whether or not a certain group of storage registers 
is functioning properly. He proceeds on the premise that all other parts 
of the system are in good working order. He writes a code to perform the 
following operations: 
(a) Generate a random number in one specific register, say μ, and then 
copy the content of μ into all registers of the group being tested. 
(b) Replace the initial content of each register a of the test group by 
the logical sum of Ζ/[(μ)', ( α ) ] and £ [ ( μ ) , ( α ) Ί when primes denote 
one's complements. As a result of these operations, in each register to be 
tested, positions corresponding to positions in μ containing zeros are un-
changed and positions corresponding to positions in μ containing ones are 
complemented. Thus, if the pattern generated in μ was properly copied 
and stored in all registers, these registers will now all have been set to 
zero. Consequently, a bit equal to one in any position will indicate a failure 
in that position and in that register. For example, let 
(μ) = 
. . . 0 1 0 1 . . . 

200 
5. NONARITHMETIC OPERATIONS 
and assume that this has been incorrectly copied into register a as 
(a) = . . . 0 1 1 0 . . . 
We have 
(μ)' = . . . 1 0 1 0 . . . 
(a) = . . . 0 1 1 0 . . . 
LZW, 
(«)] = 
.0010. 
and 
( M) = 
. . . 0 1 0 1 . 
(α)' = 
. . . 1 0 0 1 . 
ΙΊ(μ), 
( « ) ' ] = 
. . . 0 0 0 1 . . . 
Forming the logical sum of Ι/[(μ)', 
( α ) ] and 1>[(μ), 
( a ) ' ] 
gives 
.. .0011...-. We see that zeros occur in the positions which have been 
copied and stored correctly while ones occur in those in which errors were 
made. 
If the engineer wishes to know which register failed, he must have his 
code search through the entire group of registers to determine which have 
nonzero content. Obviously, this is a situation in which special care must 
be observed in the testing of negative zeros. If the engineer wishes to detect 
a failure in a particular bit position in at least one register, he can have his 
program form the logical sum of the final content of all of the registers in 
the test group. The location of bits equal to one in the resultant logical 
sum word will define the failing digit positions. This determination may be 
made by use of logical instructions or perhaps by a loop containing a left 
circular shift of one position and a sign jump. 
Since the coder is more likely to use the shorter octal notation, we con-
clude this section with tables for logical products and logical sums of octal 
digits. For example, L[2, 3 ] = 2 since L[010, 011] = 010. 
LOGICAL PRODUCTS OP OCTAL DIGITS 
0 
1 
2 
3 
4 
5 
6 
7 
0 
0 
0 
0 
0 
0 
0 
0 
0 
1 
0 
1 
0 
1 
0 
1 
0 
1 
2 
0 
0 
2 
2 
0 
0 
2 
2 
3 
0 
1 
2 
3 
0 
1 
2 
3 
4 
0 
0 
0 
0 
4 
4 
4 
4 
5 
0 
1 
0 
1 
4 
5 
4 
5 
6 
0 
0 
2 
2 
4 
4 
6 
6 
7 
0 
1 
2 
3 
4 
5 
6 
7 

5-3. 
RESOLUTION OF REGISTER CONTENT 
LOGICAL SUMS OF OCTAL DIGITS 
201 
0 
1 
2 
3 
4 
5 
6 
7 
0 
0 
1 
2 
3 
4 
5 
6 
7 
1 
1 
1 
3 
3 
5« 
5 
7 
7 
2 
2 
3 
2 
3 
6 
7 
6 
7 
3 
3 
3 
3 
3 
7 
7 
7 
7 
4 
4 
5 
6 
7 
4 
5 
6 
7 
5 
5 
5 
7 
7 
5 
5 
7 
7 
6 
6 
7 
6 
7 
6 
7 
6 
7 
7 
7 
7 
7 
7 
7 
7 
7 
7 
5-3.0. Logical Instructions in the CDC 1604 
In the CDC 1604 there are several instructions which facilitate the 
problem of dealing with individual bits in a register. We consider first 
those which make direct use of the logical product as defined in the pre-
ceding section. In each case the effective address M = m + 
(B
b). 
Load logical, 
Add logical, 
Subtract logical, 
Store logical, 
44 
b 
m, 
L[(Q), ( M ) ] —> A 
45 
b 
m, 
L[(Q), ( M ) ] + (A)i 
—> A 
46 
b 
m, 
(A)r 
- 
L[(Q), ( M ) ] - > A 
47 
& m, 
L[(Q), (A)-]-* 
M 
Of these, two employ straightforward logical product operations and two 
supply the additional arithmetic operations of addition and subtraction 
as well. We note that these are the ordinary add and subtract operations 
and are not logical addition. A few examples will illustrate the results of 
these instructions. 
Example 5-19. 
and 
(Q) = 2135 4216 3651 6721 
(01000) = 5321 7654 0213 4215 
Immediately after a 44 
0 
01000 instruction we have (Q), (01000) un-
changed, and (A) 
= 0121 4214 0211 4201. (See the octal logical product 
table in the preceding section.) 
Example 5-20. 
and 
(Q) = 2135 4216 3251 6721 
(A) 
= 5321 7654 0213 4215 

202 
5. NON ARITHMETIC OPERATIONS 
Immediately after a 47 
0 
01000 instruction we have (Q), (A) unchanged 
and (01000) = 0121 4214 0211 4201. Compare this with Example 5-19 
and note that the only difference in the load logical and store logical in-
structions is in the registers involved. 
Example 5-21. 
(A) 
= 1234 5676 5432 1234 
(Q) = 3421 2345 6765 4321 
and 
(01000) = 7654 3212 3456 7654 
After a 45 
0 
01000 instruction we have 
i [ ( Q ) , (01000)] = 3400 3200 2444 4200 
(A)r 
= 1234 5676 5432 1234 
(A)F 
= sum = 4635 1077 0076 5434 
Note that the sum is the ordinary arithmetic sum with carries. 
Example 5-22. With the same initial (A), 
(Q), (01000) as in Example 
5-21, we have as the result of a 46 
0 
01000 operation 
(Α)ι 
= 1234 5676 5432 1234 
- L [ ( Q ) , (01000)] = L[(Q), (01000)]' = 4377 4577 5333 3577 
(A) 
= difference 
= 5634 2476 2765 5033 
Example 5-23. Register 01000 contains a number n. We wish to use the 
low order octal digit of n as a nonnegative integer in later arithmetic opera-
tions. A masking operation is required since the digit consists of the three 
lowest order bits. Hence, we form a mask with ones in the three lowest 
order binary positions and zeros in the remaining forty-five to suppress 
the other digits. In octal, the mask is 0000 0000 0000 0007. We may use 
the instructions 
04 
0 00007 
44 
0 
01000 
M a s k - » Q , 
extract selected digit in A 
Example 5-24. We wish to compute with the highest order octal digit 
of (01000) as a positive integer. We can extract this high order digit with 
the mask 7000 0000 0000 0000, but this would give us the digit multiplied 
by 2
4 5. Hence, we first shift it to the lowest order octal position and use 
the same mask as in Example 5-23. 
16 
0 
01000 
06 
0 
00003 
(01000) 
-> Q, shift 
desired 
octal 
digit to lowest order position 
44 
0 
I (mask) 
Extract digit in A 

5-3. 
RESOLUTION OF REGISTER 
CONTENT 
203 
Example 5-25. We wish to test the parity of a number η > 0. If η is odd, 
we jump to ay; if η is even, we jump to a*. Since a binary number is odd if 
it ends with a one and even if it ends with a zero, we can use a mask = 1 
to extract the low order digit and test. 
16 
0 
44 
0 
l(n) 
Mask -> Q; b0 -> A 
22 
0 
ak 
75 
0 
ay 
Even? go to a*; odd? go to ay 
We could of course load the number in A, shift the digit to sign bit location 
in Q and test the sign in Q. 
In each of the preceding examples we could also have extracted the 
desired digits by means of the store logical instruction, 47 
b 
m. A 
choice between the load logical and store logical instructions will depend 
on programming convenience. For example, if we had wished to preserve 
the extracted information in storage, we would have used the load logical 
instruction. 
We consider now some examples in which we make use of the add logical, 
45, and subtract logical, 46, instructions. 
Example 5-26. A floating point word, n, is stored in standard format. 
We wish to enter the 37 bits of the coefficient in a register as a fixed point 
complement integer, disregarding the scale factor. Since η is interpreted 
as (sign bit, exponent, coefficient bits), we must replace exponent bits by 
sign bits. We may do this in the following way. We use two masks, mi = 
4000 0000 0000 0000 which in binary is one followed by 47 zeros, to extract 
the sign bit, and m 2 = 0000 7777 7777 7777, which is ones in the 36 low 
order positions, to extract the coefficient. 
16 
0 
/(mi) 
44 
0 
l{n) 
Sign bit —> 
zeros to other positions 
01 
0 
00013 
16 
0 
/(m 2) 
Extended sign bit to ΑΑΊ through A 3 6, 
second mask to Q 
45 
0 
l(n) 
Combine extended sign bit and signifi-
cant bits in A 
Example 5-27. We wish to compare the exponents of two positive floating 
point words n\ and n 2. If that of U\ is greater than or equal to that of n 2, 
we jump to ay. If not, we jump to a*. Since the exponents are both non-
negative because of the bias, and the binary point is aligned, we can simply 
subtract them in their normal location surrounded by zeros. We use the 
mask m = 3777 0000 0000 0000 to extract the eleven exponent bits. 
16 
0 
l(m) 
44 
0 
t{ni) 
Mask to Q; first exponent to A 
46 
0 
/(n 2) 
22 
2 
ay 
Difference in exponents to A; 
test; 
if ei > 62, go to ay 
75 
0 
ak 
βι < 62Î go to a* 

204 
5. NONARITHMETIC OPERATIONS 
Four other instructions in the CDC 1604 permit specialized treatment of 
individual digits. The effect of each of these could be obtained by use of 
combinations of other available instructions, but their presence will ease 
the burden of programming. These instructions are, with M = ra + 
(B
b), 
(M) 
= 
ra47ra46-· 
'Mo, (A) 
= a^a^'-a^ 
(Q) 
= q^q^* 
"q0: 
Selective Set, 
40 
b 
ra 
Sets each α» to one for those values of the index i for which ra» = 1 
and leaves α» unaltered for those i for which rat- = 0. (This is the 
operation of logical addition.) 
Selective Clear, 
41 
b 
m 
Clears (replaces by zero) each at- for each value of the index i for 
which mi = 1 and leaves at- unaltered for those i for which rat- = 1. 
Selective Complement, 
42 
6 
m 
Complements each a, for those values of the index i for which rat- = 1, 
and leaves α» unaltered for those i for which rat- = 0. 
Selective substitute, 
43 
6 
m 
Replaces each at- by m» for those values of the index i for which qi = 1 
and leaves a% unaltered for those i for which qi = 0. 
Example 5-28. 
(A)r 
= 1234 5676 5432 1234, 
(Q) = 0000 0000 7777 7777, 
and (ra) = 7777 7777 0000 0000. We give (A)F 
for each of the above 
instructions. 
(a) After 40 
0 
ra 
(A) 
= 7777 7777 5432 1234 
since the first 24 bits were set to one and the others left unaltered. 
(b) After 41 
0 
ra 
(A) 
= 0000 0000 5432 1234 
since the first 24 bits were cleared and the others left unaltered. 
(c) After 42 
0 
ra 
(A)F 
= 6543 2101 5432 1234 
since the first 24 bits were complemented and the others left 
unaltered. 
(d) After 43 
0 
ra 
(A)f 
= 1234 5676 0000 0000 
since the first 24 zeros in (Q) left the corresponding digits in A un-
altered while the low order 24 ones in (Q) replaced the corresponding 
digits of A by those in ra = M. 

5-3. 
RESOLUTION OF REGISTER 
CONTENT 
205 
We note that the result of Example 5-24(a), for example, could have 
been achieved, but less efficiently, by placing the mask 0000 0000 7777 7777 
in Q, its complement 7777 7777 0000 0000 in A, and using the add logical 
instruction 45 
0 
m. 
Example 5-29. A floating point number, n, in standard format is nonneg-
ative. We wish to load it into A with all exponent bits replaced by sign bits. 
Since the sign bit is zero, we can do it with a selective clear, and a mask = 
3777 0000 0000 0000, as follows: 
II 12 
0 
t(n) 
41 
0 
/ (mask) || 
Example 5-30. We wish to complement the sign bit and low order bits of 
a floating point number, n, leaving the exponent unchanged. We use the 
mask = 4000 7777 7777 7777 and the selective complement as follows: 
II 12 
0 
t(n) 
42 
0 
/ (mask) || 
Example 5-31. We wish to form the output image of the ten row, forty-
eight column punched card shown below. By the term output image we 
mean a one-to-one correspondence between 480 internally stored bits and 
Col 
Col 
Col 
1
2
·
.
. 
48 
Row 0 
Row 1 
Row 2 
Row 9 
the 480 row and column intersections of the card, such that the bit value 
one will indicate that a hole is to be punched in the corresponding row and 
column intersection and the bit value zero that it is to remain unpunched. 
We will use ten registers, ß i f i = 0, 1, . . . , 9, to store the bits of the image. 
The bits in register 0» will correspond to the 48 column positions in the ith 
row of the card, i = 0, 1, · · ·, 9. A bit bj of register ß { (where we use our 
standard mode of designating bits) will define the punched or unpunched 
state of the 48-jth column in the ith row of the card. Our output data will 
consist of the values of forty-eight decimal digits which are consecutively 

206 
5. NONARITHMETIC OPERATIONS 
stored at scaling 2° in the registers ω*, k = 0, 1, . . . , 47. Let d
w be the 
value of the digit stored in register ω*. Then the problem is to place a one 
in the bit position corresponding to row i = d
(k) 
and column k + 1 for all 
forty-eight values of Ä; and zeros in all other bit positions; that is, in registers 
P., i = d
( J k) = (ω*), we set b5 = 1, j = 47 - k, for k = 0, 1, . . . , 47; and 
we set all other bits in registers ßif i = 0, 1, . . . , 9, to zero. 
We will write the code relative to address α 0· 
ENTER 
« 0 
50 
1 00011 
Set (BO = 9. 
10 0 00000 
Set (-4) = 0. 
EXIT 
« 1 
20 
1 ßo 
Set (ft) = 0, fort = 9,8, - . · , 0 . 
55 
1 «ι 
j 
« 2 
50 2 00057 
Prestore (B
2) = k = 47i0. 
04 0 00001 
Set mask in Q for j = 0. 
e n t e r ) 1= 
12 2 ωο 
(ω0 + k) —• A . 
20 0 
« 1 1 
(il) —• temporary storage. 
« 4 
53 
1 
« 1 1 
Set (Β
1) = i = d<*> = (ω*). 
12 1 
0 0 
(ft) -> A. 
« 6 
43 0 
« 1 0 
Set A, = I, j = 47io — k. 
20 1 ßo 
W)->ft. 
EXIT 
« 6 
06 0 00001 
Change mask in Q f or j + 1 —• i. 
55 2 
« 3 
A; = 0? If £ 
0, k - 1 -> k and close loop. 
STOP 
a7 
76 0 
« 7 
& = 0! HALT! 
« 1 0 
77 7 77777 
Parameter = all ones. 
77 7 77777 
« 1 1 
Temporary storage. 
5-4. Search Instructions 
A basic problem which often arises in programming is that of selecting 
a quantity with a given property from a set of stored data. For example, 
suppose that we have tabulated values of a function f(x) 
for a range of 
values of χ and that we have a particular value /(x 0) which we expect to 
be a maximum. We wish to answer the question of whether/(^ 0) > 
f(x%), 
or posing the question in another way, we wish to ask whether the stored 
data contains a n / ( x t) such that/(χ») > /(zo). We should be able to write 
such search programs without the use of specific search instructions in 
much the same way that we can devise one kind of jump in terms of 
another. For example, in the problem above, we could form/(a:o) — f(xi) 
for each pertinent i and use a sign jump to test. On the other hand, we 

5-4. 
SEARCH INSTRUCTIONS 
207 
will usually gain programming efficiency if we do use search instructions 
where they are available. 
Search instructions are likely to be based, as are some jumps, on the 
question of which of the following conditions is satisfied by a number N: 
Ν > M 
Ν = M 
Ν < M 
The basic difference is that a single instruction will initiate the test of 
Ν against not only a single number, M, but the entire set of numbers Af ». 
In effect, the search instructions will set up, initiate and execute the loop 
needed to search the data Af »· and test each item against N, 
5-4.0. Search Instructions in the CDC 1604 
In the CDC 1604 there are four search instructions. They are the 
following: 
Instruction 
Operation code 
Equality search 
64 
Threshold search 
65 
Masked equality search 
66 
Masked threshold search 
67 
These instructions function differently when used as upper instructions 
and when used as lower instructions. We give a brief description of the 
properties of each as an upper instruction. 
The equality search instruction, 64 
b 
m, searches a list of operands 
to find one equal to (A). The items examined are in sequentially addressed 
registers beginning with m and ending with m + (B
b) 
— 1, with the actual 
search starting at this last address. As the search is made, (B
b) is succes-
sively reduced by one and the search continues until either an items equals 
(A), in which case a full exit is made, or (B
b) is reduced to zero, in which 
case a half-exit is made. If an item equal to (A) is found, its location is the 
sum of m and the final content of B
b. In the test, —0 and + 0 are sensed as 
equal. If (B
b) 
= 0, no search is made. If b = 0 , only the word at m is 
examined. If b = 7, indirect addressing is used. 
The threshold search instruction, 65 
b 
m, is identical with the equality 
search except that it seeks for an item greater than (A) in the list which 
it consults. If an item is found to be greater than (A), the threshold search 

208 
5. NONARITHMETIC OPERATIONS 
terminates with a full exit. If no such item is found, the search terminates 
with a half exit when (B
b) is zero. If an item greater than (A) is found, 
its location is at the sum of m and the final content of B
b. The case (B
b) 
= 
0, b = 0 and b = 7 are as in the equality search. 
The masked equality search instruction, 66 
b 
m, functions identically 
with the equality search but includes the possible use of a mask. The test 
is for the equality of (A) and 
( M ) ] where M is the current loca-
tion being searched. 
The masked threshold search instruction, 67 
b ra, is identical with 
the threshold search except that the test is for an item at M for which 
L[(Q), 
(M)~] is greater than (A). 
Again M is the address of the current 
register being searched. 
In all four instructions, if any of the four search instructions occurs as 
a lower program step, the next instruction is executed regardless of the 
outcome of the search. We note that for these instructions the case b = 0 
is not equivalent to an assumed (B°) = 0. We illustrate some simple uses 
of search instructions. 
Example 5-32. In a set of one hundred tabulated values of a function 
we have reason to believe that /(x 0) is algebraically a maximum, that is, 
that/(a: 0) > f{xi) for all i. If this is actually the case, we wish to jump to 
program step ay. However, if there is a n / ( x t) > f(xo), we wish to jump to 
program step α*. We assume storage of f{xx) 
in sequentially addressed 
registers starting at β0. 
50 
1 00144 
12 0 /[/(*o)] 
65 1 ßo 
75 0 
a, 
75 0 ak 
Set index register B
l to lOOio. f(xo) 
Search for f(xx) > f(xo). 
We see that if no f{x%) 
> f(xo) is found, a half-exit is taken to an instruc-
tion to jump to ay. If this is not the case, a full exit is taken to an instruc-
tion to jump to ak. 
Example 5-33. We have a positive floating point number, n, and a set 
of 1000 positive floating point numbers stored sequentially starting at ß0. 
We wish to find if there is one of these which has the same exponent as n. 
To isolate the exponent we use the mask m = 3777 0000 0000 0000. 
50 1 01750 
44 0 t(n) 
66 
1 ßo 
75 0 
Ottn 
16 0 
t(m) 
PASS 
75 0 «,· 
Set index register B
l to lOOOio. Mask —> Q. 
Exponent of η —• A. 
Search for equal exponent. Jump to no equal exponent 
entry point. 
Jump to equal exponent entry point. 

5-4. 
SEARCÖ INSTRUCTIONS 
209 
By using a pass after extracting the exponent of η into A, we can place 
the 66 
1 
ßo as an upper instruction. This permits us the option of two 
different operations on the basis of the result of the search. 
5-4.1. Skip Instructions in the C D C 1604 
In the preceding section our concern was with the primary character-
istic of the search instructions, their ability to test a large set of data for 
the answer to a specific question. At the same time, we see that the ques-
tions involved are the same as those which are asked in the jump instruc-
tions. The names equality search and threshold search reflect the fact that 
the basic conditions are the same. There is, however, one further aspect 
in which these instructions are similar to jump instructions, and that is 
they provide for conditional branching in the execution of a code. The 
four search instructions are also similar in this regard to the index skip 
(54 
b 
m) 
and the storage skip (36 
b 
m) 
instructions, which the 
reader should review from the appendix. In each of the six instructions, 
the branching is provided by the feature that if a certain condition is 
satisfied, the lower instruction is skipped and a full exit is made to the 
upper instruction at the next program step. For this reason these instruc-
tions are referred to as skip instructions. The skip feature is available only 
if the instructions are used as upper program steps. In the event that they 
occur as lower program steps they half-exit upon themselves until the 
condition is satisfied and will, if it is not, form closed loops. For example, 
if the storage skip instruction is used as a lower program step and the 
tested number is positive, the instruction will half-exit on itself until the 
computer is manually stopped. 
While the skip instructions are not jump instructions as such, since they 
do not permit specification of a jump address, they function in much the 
same manner. That is, they give us the means of selecting either one of 
two alternatives in program sequencing depending on an internal condition 
in the machine. The jump addresses are implicit rather than explicit. 
Normally, the choice is between the lower instruction of the current 
program step and the upper instruction of the subsequent one. Used in 
conjunction with the explicit jump instructions, however, the skip instruc-
tions provide us with conditional two-way jumps. The most general two-
way jump is illustrated in the following example. 
Example 5-34. We wish to test a condition available in a skip instruction. 
If the condition is satisfied we wish to proceed to the program step at 
address a, and if it is not satisfied, we wish to go to the program step at δ. 
This is a two-way branch shown by the following diagram. 

210 
5. NONARITHMETIC OPERATIONS 
Condition 
λ 
satisfied? 
/ 
No 
go to δ 
Υββ 
go to α 
The coding is simple if we use a skip instruction as an upper program step: 
Skip instruction 
75 
0 
δ \ 
75 
0 
a 
We can also use skip instructions in conjunction with return jumps or 
normal conditional jumps. We show some possible uses in the following 
examples. 
Example 5-35. We wish to form and store, consecutively, the η positive 
integers beginning with one. We can use the index skip and an entry point 
at «ο* 
oco 
50 
1 00000 
12 0 Ai) 
Set counter to zero. 1 —> 4 . 
Oil 
20 5 ßo 
50 0 00000 
1 -> ßo. PASS. 
[«Γ 
12 1 ßo 
14 0 ßo 
i-+A, 
i + 
l->A. 
ot% 
20 
1 ßl 
50 0 00000 
t + 1 -* ßi. PASS. 
a* 
54 
1 η - 1 
75 0 
« 2 I 
All? If not, re-enter loop. 
as 
76 0 
« 6 
If yes, STOP. 
Here we have used the index skip to terminate loop traversais after a 
given number of repetitions. In this respect the instruction can be used 
much as the index jump is used. For further illustrations see Chapter 3. 
Example 5-36. We wish to test the sign of the operand stored at the 
register with address δ. If the sign is negative we proceed to the program 
step at ω, but if the sign is positive we proceed to the step at μ. We can use 
the storage skip instruction and test, starting at ay. 
ay 
36 
75 
75 0 μ 
Negative? Go to μ. 
Positive? Go to ω. 
This test could also be made by means of an A or Q jump, but use of the 
index skip avoids use of either A or Q and requires no preliminary 
transmission. 
As we have mentioned, some instructions are likely to be redundant, 
but highly useful, on any computer. Each of the skip instructions can be 

EXERCISES 
211 
achieved by combinations of the other available instructions on the CDC 
1604 (try them!). However, they provide convenient and more efficient 
ways of obtaining some results, and the alert coder will always take ad-
vantage of such opportunities. 
Exercises 
Section 5-1.0 
1. 
A program is written in four sections: 1, 2, 3, 4. Introduce stop in-
structions which will permit optional stops between sections which are 
to run in the order 1-2-3-4. 
2. 
Repeat Problem 1 if the order is 1-3-2-4. 
3. 
Is it possible by means of stop instructions only to devise a way of 
running three sections of a program in the order 1-2-3 or the order 
1-3-2 optionally with optional stops between? 
Section 5-2.0 
4. 
(A) 
= 2345 6765 4321 2345. Find the location from which the com-
puter will accept its next instruction after each of the following com-
mands as the upper instruction at 01000. 
(a) 22 
0 
02000 
(b) 22 
1 
02000 
(c) 22 
2 
02000 
(d) 22 
3 
02000 
5. 
(Q) = 5676 5432 1234 5676. Find the location from which the com-
puter will accept its next instruction after each of the following com-
mands as the upper instruction in 01000. 
(a) 23 
0 
02000 
(b) 23 
1 
02000 
(c) 23 
2 
02000 
(d) 23 
3 
02000 
6. 
Assume (B
1) 
= 125s. A sequence of instructions is stored at a 0 (upper) 
through ak, with (α*) = 5 5 
1 
a0; 76 
0 
a 0. What takes place if 
control starts at a 0? Assume no jumps are stored in a 0 through α*_ι. 
7. 
Do the problem in Example 5-5 using a 22 
2 
m instruction to obtain 
the index jump. 
8. 
Assume storage of all parameters required and write a program which 
will form and store the first 1000 even integers. Construct the index 
jump by use of the 22 j 
m instruction with j = 0, j = 1, j = 2, 
a n d j = 3. 
9. 
Repeat Problem 8 using the 23 j 
m instruction. 

212 
5. NONARITHMETIC OPERATIONS 
10. Repeat Problem 8 using the 55 b m instruction. 
11. At ay it is to be determined whether or not a loop which begins at a 0 
has been traversed exactly 100i0 times. If so, a stop is to take place. A 
coder proposes the following: 
(ay) = 12 0 
(counter) 
15 0 
t{\) 
(ay +i) = 22 2 a 0 
76 0 
a 0 
and initially sets (counter) = 0000 0000 0000 0144 octal. Detect the 
error and find two ways of correcting it. 
12. We wish to transfer η items from sequentially addressed storage loca-
tions beginning at ßo to η sequentially addressed locations starting at 
a 0. The following code with entry point at a 0 is proposed: 
50 1 00000 
50 2 00000 
50 3 η 
12 1 
20 2 oco 
51 
1 00001 
51 2 00001 
55 3 on 
76 0 oco 
Detect and correct all errors. 
13. Assume/(x) in Example 5-8 i s / ( x ) = 1 — χ — χ
2 and write a loop 
to achieve the desired result of the example. Use floating point instruc-
tions with Ax = 0.001 io. 
14. In Example 5-8, what would occur if we attempted to obtain the exact 
χ value of the root by use of the following code? 
α*+ι 
12 
0 
4UM1 
22 
0 
α*+3 
α*+2 
75 0 α,· 
50 0 00000 
12 0 /(*„) 
20 0 /(root) 
QfJfe+4 
176 
0 
OCo 
15. Assume that the multiply integer operation is valid only if the two 
factors M and Ν in a product MN are both non-negative. Write a 
program which will properly reduce M and Ν to this form, compute 
the product | Μ \ \ Ν \ , and put this result in proper complement form. 
16. Assume four segments of a program: 1, 2, 3, and 4 and any convenient 
storage designation. Introduce selective jumps which will make it 
possible for the operator at the console to choose to run the program 
in any of the orders 1-2-3-4; 1-3-2-4; 1-4-2-3; or 1-4-3-2. 
17. Repeat Problem 16 with optional stops between sections. 
18. Write a sequence of instructions which will provide an emergency 
stop and an option to jump to an error analysis routine in the event 
that a computed quantity exceeds a given value M. 

EXERCISES 
213 
19. It α, ö, and c can have values 0 or 1, show that the logical product 
operation is such that 
Section 5-3 
20. Repeat Problem 19 for logical addition, ©. 
21. For both operations show that 
22. For each of the following combinations, find L[x} y~]. 
1010111 
0101010 
1101011101 
1010000110 
23. If χ = 1010111100000101, find a mask which will 
(a) extract the 5 lowest order digits, 
(b) extract the 11 highest order digits, 
(c) extract the alternate digits beginning with highest order. 
Section 5-3.0 
24. Assume (Q) = 1123 2333 4456 6666 and 
(Ό1000Ϊ = 7765 5555 4432 2222 
Determine (A) immediately after the execution of the instruction 
44 
0 
01000. 
25. Assume (Q) = 1123 3333 4456 6666, (01000) =7765 5555 4432 2222 
and (A) 
= 7700 7070 0077 7700. Determine content as indicated 
after execution of each of the following: 
(a) 44 
0 
01000; 
content of A 
(b) 45 
0 
01000; 
content of A 
(c) 46 
0 
01000; 
content of A 
(d) 47 
0 
01000: 
content of A, Q, and 01000 
26. Write a program which will compute the sum of the highest order 
octal digit and the lowest order digit of a number n. 
27. Write a program which will extract the biased exponent from a floating 
point number and replace it with the true exponent with properly 
extended sign in A, 

214 
5. NONARITHMETIC OPERATIONS 
28. Write a program which will test the parity of a stored number, n, for 
either sign and jump to ay if η is even, and to <xk if η is odd. 
29. Write a program which will add the coefficients of two floating point 
numbers having common exponents and store the result as 
floating 
point. Assume no overflow occurs in the 37 available bits. Do not use 
floating point instructions! 
30. Use the selective substitute instruction to write a program which will 
interchange the exponents of floating point numbers n\ and rti. 
31. Repeat Problem 30 using instructions with operation codes 44, 45, 46, 
or 47, but not 43. 
32. Write a program to replace the coefficient of a floating point number 
(including sign bit) by its complement while leaving the exponent 
unchanged. 
Do it with and without 
the selective 
complement 
instruction. 
33. Write a program which will round off the last thirteen bits of a stored 
number without using any shift operations. That is, replace these 
digits by zeros or ones. Devise at least two methods. 
Section 5-4.0 
34. Assume that 150i0 items are stored in consecutively addressed registers 
beginning at β0. We wish to find if any one of these items is equal to n. 
If there is one such we wish to put it in Q and jump to ay. Write in-
structions which will do this. 
35. Repeat Problem 34, except that we wish to put the exact count of the 
number of items equal to η in Q. 
36. Use the masked equality search to determine if there is at least one 
negative number in a set of 1500i0 items stored in consecutively ad-
dressed registers beginning at β0. If there is, send control to ay. If there 
is not, send control to a*. 
37. A floating point number η is stored. We wish to find if a set of 200i 0 
floating 
point numbers has at least one whose coefficient is larger 
algebraically than that of n. Write appropriate instructions, with 
two alternatives based on the outcome. 
38. For a set of 150i0 stored values of a function, / ( x i ) , we wish to deter-
mine if \f(xo) I < \f(xi) 
I all i. If it is we send control to ay, if not 
we record the location of the first one for which | f(xi) 
\ > | f(x) 
| and 
go to α*. Write instructions to do this. 

CHAPTER 6 
Subroutines 
6-0. Introduction 
We often find it necessary to repeat the same set of instructions at differ-
ent points in a computer program. For example, if we are dealing with 
complex quantities, we will find that most computers do not have direct 
commands which will form sums, products, and so on. Each time we wish 
to form a proSuct, it will be necessary to carry out a certain fixed sequence 
of additions, multiplications, and groupings which will produce the desired 
result. All such products will be formed in an identical manner, and it will 
be only the operands which differ. One possibility for handling this problem 
is to incorporate the necessary instructions into the main program, simply 
repeating them wherever necessary. In this manner, if a set of η commands 
is required to form and store a product of two complex numbers, we 
might arrive at a program storage pattern such as that shown on page 216. 
This is probably the technique which is most conservative of machine 
time, but it is wasteful of storage capacity, since it requires us to duplicate 
what is essentially the same code in various storage locations. It is also 
wasteful of effort, since the codes are a function of storage location and we 
cannot exactly duplicate them in each part of the program. We will have 
to modify each set of η instructions to make it suitable for its final location. 
A better scheme is to write a single code which will form the complex 
product of any two designated complex numbers, and store it separately 
from the main program. Then, each time we are required to form such a 
product, we will jump to this code, and, on its completion, return to the 
main program. Such a code is called a subroutine, 
or subprogram. 
It is an 
auxiliary routine used in conjunction with, but not as part of, the main 
routine or main 
program. 
215 

216 
6. SUBROUTINES 
α 0 
« 1 
> Complex product code 
«n+2 
Complex product code 
Complex product code 
etc. 
Subroutines will, in general, be of two kinds. There will be those of a 
very specialized nature which the coder will write for himself for a particular 
program, for example, a floating point add routine for a nonstandard 
operand format. There will also be those which are so generally required 

6-1. 
SUBROUTINE LINKAGE AND RETURN JUMPS 
217 
that they will be coded and stored permanently, to be available for anyone 
who uses the equipment. This last category might include routines for 
computing logarithms, exponential functions, and so on. 
If we are writing our own subroutines, we can, of course, tailor them to 
suit our particular problem; that is, we can place them in any convenient 
fixed locations, dictated by the requirements of the main program. On the 
other hand, a subroutine for general use will have to be more versatile. We 
would obviously have severe and undesirable restrictions on the writing 
of a main program if we were required to write it around a number of al-
ready fixed subroutine locations. For this reason such general subroutines 
will have to be written so that they can operate in any specified location. 
We will consider some of the problems in both cases below. 
6-1. Subroutine Linkage and Return Jumps 
The first problem which arises in the use of subroutines is the alternation 
of control between the main routine and the subroutine. For example, if 
we go back to the complex product illustration of the preceding section, 
we will want to replace the inserted commands by a complex product sub-
routine. We will code this and store it at locations ßo, ..., 
ßp (the number 
of commands for the subroutine may be different than the number of in-
serted instructions). If we then use arrows to indicate transfer of control, 
we might have the same result given schematically by 
Complex product code 
etc. 

218 
6. SUBROUTINES 
Each time we use the subroutine we must arrange for a jump to the 
entry point of the subroutine; but each time we complete the subroutine we 
must have a jump back to the next main program step, that is, the one to 
be executed immediately 
after the first jump 
instruction. 
In the example 
above, the initial jump is always to ßo, but the second jump is to az, 
ak+i, 
or oLj+i depending on where we are in the main program. The process by 
which we transfer control to and from a subroutine is called linking. 
The 
combination of operations which provides for entry into the subroutine 
and return to the next main program step is called a return 
jump. 
Individual computers will vary in the particular methods by which a 
return jump is achieved, and, as with other kinds of jumps, there will 
usually be various instruction combinations which will produce the de-
sired result. We see, however, that linking will require the following. The 
subroutine must have an entry point and must itself terminate with a 
jump instruction. Transfer of control to the subroutine will consist of a 
jump to the entry point, but we must provide that the jump address of the 
terminating instruction of the subroutine, prior to its execution, be replaced by 
the address of the next main program 
step. 
Suppose, for example, that the last instruction in the complex product 
subroutine above ends with an unconditional jump at ßp. For the linkings 
indicated we then need, for each case, 
az —> jump address portion of register ßp, 
jump to ßo 
ak+i —> jump address portion of register ßp, 
jump to ßo 
aj+i —» jump address portion of register ßp, 
jump to ß0 
The return point need not be consecutively addressed from the jump as 
shown. We may send a nonconsecutive address directly to the subroutine, 
or the subroutine itself may compute the return address as some definite 
function of the consecutive address we do send. 
On most computers the desired result can be obtained by a preliminary 
"transmit address to ßp" instruction, followed by a jump to ß0. As an illus-
tration of how a return jump may be obtained in this manner, we give the 
following example. 
Example 6-0. On the CDC 1604 we wish to make a return jump from a 
point ocj in a main program to an entry at ßo in a subroutine. The subroutine 
terminates with an unconditional 75 
0 
m jump at the upper instruction 
at ßp. One method of achieving the result is to store a parameter, P, whose 
low order 15 bits form the address, ay+i. We could then use 
and 
12 0 
a, 
aj 
75 0 ßo 
60 0 ß p 
aj+i —•* upper address part of ft 
00 0 
α,·+ι (j Jump to subroutine 

6-1. 
SUBROUTINE LINKAGE AND RETURN JUMPS 
219 
The return is to the upper instruction at ay+i, since the upper instruction 
at ßp now is 75 
0 
The disadvantages of using the method given in Example 6-0 are obvious. 
For each return jump we need a stored parameter (as well as instructions 
transmitting this parameter), giving the location of the next main program 
step. For this reason, most modern computers will have at least one in-
struction which will transmit the return address and jump to the sub-
routine as one unified operation. Such instructions will be labeled as return 
jumps, and it is the duty of the coder to become familiar with the way in 
which the return jumps on his computer work. The ability of a return jump 
instruction to provide the return address automatically is usually based 
on a transmission of content from the program register Ρ to storage. In 
implicit machines (P) will be an address one greater than that of the 
register which contains the return jump. 
We note the particular importance of proper entry points in the writing 
of subroutines. The subroutine must produce the same program steps each 
time it is used. 
When we write subroutines, we are at liberty to design them with as 
much flexibility and versatility as we choose. One of the most important 
questions to be considered is the manner in which the data to be operated 
on are delivered to the subroutine and the way in which the results are 
obtained from the subroutine. Two general cases arise. In one the sub-
routine will operate on a relatively small amount of data. For example, a 
routine to compute the exponential function would require that the main 
program specify only one operand, say x, and in turn, the single value of 
e
x would be the output of the subroutine. In such a situation, it is probably 
simplest to provide some fixed locations in which to put the data, and to 
design the subroutine to accept the data from them and deliver the results 
to some implicitly understood place. For the exponential function, we 
might place χ in the accumulator and expect to find the value of e
x there 
on completion of the operations. This would require a minimal number of 
transmissive instructions in the main program. In the other case, the sub-
routine will serve the purpose of carrying out a set of operations on a rela-
tively large amount of data. An example is a routine which will form the 
product of two square matrices of order n. Here the main program must 
specify 2n
2 items of data and accept n
2 items in return. We can again write 
the subroutine to work only in a fixed data region, but this will require 
that each time it is used we must insert a number of block transfer instruc-
tions in the main program both before and after linking the subroutine. 
In cases of this kind it is better to put more of the burden on the sub-
routine and make it flexible enough to operate on the data and deposit 
results in whatever regions are specified by the main program. This specifi-
cation is ordinarily made by transmission of initial addresses of these 

220 
6. 
SUBROUTINES 
regions. These address transmissions may be made either directly to the 
appropriate subroutine locations or to fixed locations such as index and 
arithmetic registers. In the latter case the subroutine itself will provide 
the necessary address prestorations. Library subroutines will usually 
operate in this last manner. On those computers which have the indirect 
addressing feature it may be used to eliminate explicit prestoration in-
structions. The idea of transmitting data addresses instead of data may in 
some cases increase operating time because of the additional housekeeping 
instructions required in the subroutine. It will, however, present certain 
advantages. It will make it possible to reduce the number of prelinkage 
and postlinkage instructions in the main program and will reduce the 
time in the main program required to transmit large blocks of information. 
By minimizing the number of steps required for linking in the main program 
and by shifting them into the subroutine, we permit these steps to be 
checked out once and for all. If they are left in the main program, they 
will require checking for each different entry to the subroutine. It is for 
this reason that a subroutine will frequently be used even though the 
number of instructions which would have to be repeated in a main program 
is small. 
ό-l.O. Implicit Return Jumps 
In some machines the repertoire of instructions will include a return 
jump instruction in which both the jump address and the location at which 
the return address is to be stored are implicitly understood. Thus, if the 
instruction works so that the return address is transmitted from the 
program register to its storage location, the address parts of the instruc-
tion need not be specified. Accordingly, these address digits are arbitrary; 
and they can be used to code a parameter to be used by the subroutine 
whose entry point is at the implicitly understood jump address. This sub-
routine can easily compute the address of this parameter from the return 
address and then acquire it for use in directing the remainder of the sub-
routine operation. In effect, the parameter can be considered to represent 
a coded instruction which the subroutine is to execute. The parameter 
can have any interpretation which the coder wishes to assign provided that 
the subroutine starting at the entry point has been designed with this 
interpretation in mind. 
A common application of an implicit return jump instruction arises in 
connection with the simulation of one computer, either existing or imagi-
nary, by another. In this application the arbitrary address digits of the 
return jump are used to code the instructions of the computer being simu-
lated. If the available digits prove to be insufficient in number, they can 

6-1. 
SUBROUTINE LINKAGE AND RETURN JUMPS 
221 
be used to give the location of a longer parameter word. In this case, in-
direct addressing may prove to be convenient. In any event, the subroutine 
entered must obtain and interpret the parameter and execute the instruc-
tion it represents in the way defined for the machine under simulation. 
Such a subroutine is frequently referred to as an interpretive 
subroutine. 
We give an example below. 
Example 6-1. In a machine whose instruction word is twelve octal digits 
in length, the first two digits define the operation code and the remaining 
ten define two addresses of five octal digits each. In this machine the opera-
tion code 14 always causes the content of the program register to be stored 
at address zero and control to jump to register one. Since this computer 
has no floating point arithmetic operations as part of its normal repertoire, 
we desire to add such operations by means of an interpretative subroutine. 
We add eight three-address instructions which are coded by the ten arbi-
trary address digits of the implicit return jump (operation code 14) as 
follows: 
φ 
xxx yyy zzz 
Here φ represents any of eight operation codes and xxx, yyy, and zzz 
represent any of 512i 0 consecutively addressed storage locations in the 
machine. Thus, the parameter 
3 142 206 014 
might be defined to mean "add the floating point number stored at 70512 + 
142 to the floating number stored at 70512 + 206 and store the 
floating 
point result at address 70512 + 014." We assume that this interpretation 
has been assigned and that the floating point data has been properly 
stored. The instruction 
14 3 142 206 014 
stored at register δ, will cause the value δ + 1 to be transmitted to register 
zero from the program register and will then initiate a jump to the inter-
pretive subroutine with entry point at register one. The interpretive 
routine can use the value δ + 1 in register zero to set up a later return to 
the main sequence. It can also use this information to pick up the remaining 
ten octal digits of the return jump instruction from register δ. The inter-
pretive subroutine will then separate these digits into the appropriate 
operation code and address subsets. It will analyze these subsets to select 
from a group of eight auxiliary subroutines the one corresponding to opera-
tion code three; to obtain the data for the subroutine from storage registers 
70654 and 70720; and to arrange to store the result in register 70526. Con-

222 
6. 
SUBROUTINES 
trol will return to the main program once the interpretive floating point 
instruction has been completed. 
An interpretive system similar to that in Example 6-1 could have been 
designed on the basis of an explicit return jump instruction followed im-
mediately in the next storage location by the parameter representing the 
instruction to be interpreted. The use of an implicit return jump enables 
us to combine the jump to the interpretive system and the interpretive 
parameter in the form of a single instruction. In this form, the new floating 
point instructions are like machine language instructions. This simplifies 
the housekeeping connected with using them in codes. More important, 
however, the implicit return jump enables the control to differentiate 
between built-in machine language instructions and those to be inter-
preted. Thus, instructions to be executed by the interpretive system can 
be interspersed freely with machine language instructions and the entire 
mixture can be handled by the machine control in the normal way. To 
retain the single register feature without the implicit return jump would 
require that the mixture be treated as instructions to be interpreted and 
turned over to the interpretive routine for execution, including the ma-
chine language instructions as well. In the CDC 1604, we can achieve the 
effect of an implicit return jump by thinking of an interpretive instruction 
word as a two-address instruction. Then a program step becomes an inter-
pretive instruction, with the upper instruction of the step a return jump 
to the interpretive subroutine and the lower instruction a parameter to 
be interpreted, or vice versa. 
Many machines have an interrupt feature which functions as an implicit 
return jump. With the interrupt feature, the implicit return jump is not 
actually stored as an instruction. Instead its operation code is generated 
by the control after completion of the current operation and on receipt of 
an "interrupt" signal. This signal may come from one of the external 
peripheral devices or perhaps internally from some other part of the 
machine such as the arithmetic unit on a fault condition. Generating the 
implicit return jump causes control to transfer to an interrupt subroutine 
whose entry point is the fixed and implicitly understood jump location. 
This subroutine then determines the causes of the interrupt signal, takes 
appropriate action, and returns control to the main program so that the 
interrupted computations may continue. 
6-1.1. Return Jumps and Subroutine Linkage in the CDC 1604 
At this point the reader should review the following jump instructions 
on the CDC 1604, with particular attention to values of b = 4, 5, 6, and 7: 

6-1. 
SUBROUTINE LINKAGE AND RETURN JUMPS 
223 
Instruction 
Operation code 
A jump 
22 
Q jump 
23 
Selective jump 
75 
Selective stop 
76 
We recall that for values of b = 0, 1, 2, and 3 the jump operation of these 
instructions is a normal jump, either conditional or unconditional. That is, 
the jump, if made, is always to the upper instruction at the jump address. 
For values of b = 4, 5, 6, and 7, the conditions of the jumps are the same 
as before, but the jump is a return jump which operates in the following 
manner. The return jump is always made to the lower instruction word at 
the jump address. Prior to this, however, the address portion of the upper 
instruction at the jump address is replaced by the address of the next 
main program step. This address is obtained from the program address 
register P . We see that this provides the correct linkage if the subroutine 
terminates with a jump at the upper program step of the same register in 
which its entry point is the lower program step. 
Example 6-2. A subroutine is stored with its entry point at the lower 
instruction of the program step at ßo. The upper instruction at ßo is an 
unconditional jump, that is, 
U 
L 
(ßo) = 75 
0 
(arbitrary), 
(initial instruction) 
At the point ay in the main program we wish to jump to the subroutine 
and on its completion return to ay+χ. We use 
(ay) = 
75 
4 
ßo 
or 
(ay) = 75 
4 
ßo 
In either case the computer will replace the address portion of U in ß0 to 
make it (ßo) = 75 
0 
ay+i, (initial instruction). If the subroutine termi-
nates at the upper instruction in ß0, the return will be made to the upper 
instruction at ay+i. We see that return jump instructions can be used in 
either the upper or lower program positions. If they occur as upper in-
structions, the lower instructions will not be carried out. 
For ordinary linkage with a specific subroutine we will use the uncondi-
tional return jump 75 
4 
m. The use of a value of b = 5, 6, or 7, however, 

224 
6. 
SUBROUTINES 
will provide us with optional return jumps, the choice being made at the 
console. In addition, we may stop unconditionally or optionally before a 
return jump, by using the stop instruction, 76 
b 
m, with values of 
b = 4, 5, 6, and 7. With either the 75 or 76 return jump operation the jump 
is unconditional as far as any internal condition is concerned. Any choice 
is made by the operator at the console. In certain programming situations, 
however, we will want to use return jumps based on internal conditions 
for linking. These jumps can be achieved by use of conditional normal 
jumps and unconditional return jumps. They are obtained more efficiently, 
however, if conditional return jumps are provided, as in the 22 
6 
m 
and 23 
b ra, A and Q jumps, with b = 4, 5, 6, or 7. We illustrate by an 
example. 
Example 6-3. At a number of points in a program we generate a variable 
χ in A, and we wish to replace χ by f(x). 
If ζ > 0, f(x) 
= χ and if χ < 0, 
f(x) 
is defined by a subroutine which sets f(x) 
in A. If the entry point of 
this subroutine is at ß0j we can use 
12 
0 
/(*) 
22 
7 
ft 
Another important use of a conditional return jump is in connection 
with an error analysis subroutine. Such an instruction enables us to detect 
an error and jump to the appropriate subroutine. In this case the return 
address is more likely to be used to locate the point in the program where 
the error occurs than to provide a return. 
In an earlier section we pointed out that two kinds of data transmission 
to and from a subroutine arise. These are the case in which, for relatively 
small amounts of information, we will transmit the data itself and the 
case in which, for larger blocks of words, we will usually transmit appro-
priate initial storage addresses. We illustrate with two simple examples. 
In the first of these the subroutine requires only two numbers as input and 
produces a single number as output. In the second example, we must 
transfer to and from the subroutine an nth order matrix, involving n
2 
words each way. 
Example 6-4. We wish to write a subroutine which will form the nth 
(n an integer) power of a floating point operand x. Since only two items 
need be specified and only one result obtained, we choose to write the 
subroutine to work on data in a fixed location. We will place χ in A and 
η in Q and obtain x
n in A. We must leave the content of any index registers 
used unaltered. Since η < 0 requires formation of a reciprocal, we will 
introduce a nested subroutine which will do this when necessary. We 
assume η ^ 0 and leave it to the reader to supply the two instructions 
required to make x° = 1 for η = 0. 

6-1. 
SUBROUTINE LINKAGE AND RETURN JUMPS 
225 
ENTRY 
ωο 
75 0 
Return exit to main program. 
23 7 
ωβ 
Jump to reciprocal subroutine if 
ωι 
56 1 
ωΐ2 
Save 
20 0 
ωΐ6 
Save χ or 1/x. 
ωι 
21 0 
ωι« 
Save η or I η |. 
53 1 
ωΐ4 
I η 1 - * BK 
ωι 
51 1 77776 
I η 1 - 1 -+ BK 
50 0 00000 
PASS. 
ω 4 
55 1 
ω 5 
If exponent < | η |, reloop. 
75 0 
ω υ 
If exponent = | η |, EXIT. 
ωι 
32 0 
ωι* 
x
i —• A, i = 2 initially. 
75 0 
ω* 
j 
Reloop if necessary. 
ωβ 
75 0 
[ ω ι ] 
Return to subroutine main loop. 
21 0 
ωΐ4 
Save η < 0. 
ω 7 
17 0 
ωΐ4 
| n | - > Q . 
21 0 
ωΐ4 
Save I η |. 
ωι 0 
20 0 
ω » 
Save x. 
12 0 
ωΐ3 
1 ->A. 
ωιι 
33 0 
ωι 5 
1/x -+ A. 
75 0 
ωβ 
Exit from subsubroutine. 
ωιι 
50 1 Ε(*
1)] 
Restore (B
1). 
75 0 
ωο 
Exit from subroutine. 
ωιι 
20 0 
14000 
Floating point. 
00 0 00000 
One. 
ωΐ4 
η 
Temporary storage for η and/or 
ωΐδ 
χ 
Temporary storage for χ and/or 
Reciprocal 
Subroutine 
We have written the instructions for taking the reciprocal as an inner 
subroutine only for illustration. Since the return to ωι is fixed, we could 
have written a more efficient program without the return jump at the 
lower instruction in ω0. If we now assume that at ay of the main program 
we require x
n, we can link with the instructions: 
a y + i 
04 0 η 
12 0 
75 4 
ω 0 
η -
χ - • A and link. 
We can now continue coding with (A) 
= x
n. We must be certain that χ 
and η are within the implicit limitations for no overflow in the subroutine. 
Example 6-5. We wish to write, as a subroutine, a code for the matrix 
transpose described in Example 3-22. Here a matrix must be specified to 
the subroutine, and the subroutine will provide the transpose of the matrix. 
We choose to write the code in such a way that it will operatp on a matrix 

226 
6. 
SUBROUTINES 
in an arbitrary location and store the transpose in an arbitrary location. 
These locations are to be specified by the main program. The subroutine 
is to be used for a range of values of n. If we look at the three instructions 
at a 0 and ah of the original program, we see that they serve to define the 
storage for the given matrix, the storage for the transpose, and the order 
of the matrix. Hence, these can be used in the main program as prelinkage 
instructions. With index registers 1, 2, and 3 filled from the main program, 
the original program can be used as a subroutine if it is modified to insert 
the given value of η in (α 5), (a 7), and (an). We must also provide the jump 
for a return. We rewrite the code as a subroutine starting at ω0. 
EXIT 
coo 
75 0 
OJ+2] 
ENTER 
56 3 ω6 
coi 
56 3 ω7 
56 3 
çon 
1 l^2~ 55 3 
C03 
75 0 
ωο 
56 1 
C06 
57 2 ωβ 
03* 
50 4 00000 
50 5 00000 
ω5 
50 6 Μ 
55 6 
I "β 12 4 
LßU-l )+(»-! )«] 
20 5 
[δ(/_1)η+(ί-1)] 
ω7 
51 4 Μ 
51 5 
1 
ωιο 
55 6 ωβ 
51 1 , 
J 
con 
51 2 Μ 
75 0 
J Ι 
75 0 
C02 
j 
Return exit. 
Insert η for row counter. 
Insert η for increment. 
Insert η for increment. 
Count columns. 
If through, return exit. 
Set ß ( / _ i ) + ( t - i ) n. Start i = j — 1. 
Set/3(/_i)n+(»_i). Start i = j = 1. 
Set increment η index to zero. 
Set increment 1 index to zero. 
Set row (i) counter. 
η becomes η — 1. 
(/3(/_i)+(._i)„) —> A. Start i = j = 1. 
(A) —> δ ( , · _ ΐ ) η + ( . - ΐ ) . Start i = j = 1. 
Increase (2?
4) by
 n \ j n
c
r
e
a
g
e ^ 
j 
Increase (B
6) by l j 
Count rows. 
Increase (B
l) by 1. Increase i by 1. 
Increase (B
2) by n. Increase i by 1. 
Reloop if necessary. 
Suppose now that at ay in the main program we wish to transpose the 
matrix starting at β0 and store the transpose starting at δ0. The only in-
structions required are: 
a , 
50 1 ßo 
50 2 
δ 0 
50 3 η 
75 4 ω0 
Specify matrix locations. 
Specify η and link to subroutine. 
We can then continue coding at ay+2 with the transpose stored starting at 
δ0. For simplicity we have assumed that there is no reason for saving the 

6-2. 
SUBROUTINE ASSEMBLY 
227 
content of the index registers. If this is required, we would insert instruc-
tions in the main program, before and after linking, to save and restore 
(Β
1), 
(Β
2), and (B
3). We would also provide instructions in the subroutine 
to save and restore ( 5
4) , (B
b) 
and (J5
6). 
6-2. Subroutine Assembly 
In the last section we discussed subroutines as if each subroutine were 
to be used with a single program. However, as pointed out in Section 6-0, 
there are a wide variety of computational operations such as the evaluation 
of logarithms, square roots, and so on, which will be carried out in many 
different programs. Recoding such a subroutine for each problem in which 
it is used is a needless duplication of effort. Accordingly, we will ordinarily 
code this type of subroutine once and for all and place it on file in the 
library of the computing installation, where it will be available for general 
use. In using such library subroutines, we must, of course, be familiar with 
the way in which they function (fixed point, floating point, etc.) and ar-
range to keep within the limits of their specifications and ranges. We must 
also remember that the actual code for the subroutine is a function of its 
operating locations in storage. To be useful, a library subroutine must be 
designed to fit into any program, provided only that sufficient storage 
space is available to contain the instructions, parameters, and intermediate 
results of the subroutine. This available space should not be limited to any 
particular region of storage. It would be excessively restrictive for a file 
copy of a subroutine to be in a form suitable for operation in only one 
fixed region of storage. The library subroutine must be stored in such a 
way that a copy of it can be assembled in a correct form for operation in 
any storage region the coder wishes to specify. This assembly operation 
can be carried out easily by the computer itself, if proper conventions of 
address notation and format are employed in the file copy of the subroutine. 
The computer will carry out the assembly operation under control of 
an assembly program. Most computing laboratories will keep one or more 
assembly programs in the service library. The particular assembly programs 
may, of course, vary from one installation to another. We shall consider 
here some of the basic requirements of such programs and the way in which 
a typical one might operate. For illustration, we introduce a hypothetical 
program which we call SURAP (Subroutine Assembly Program). 
Input to an assembly program must include a designation of the particu-
lar subroutine to be assembled and must also include a specification of the 
locations in storage where the subroutine is to operate and where it is to 
be stored when not in use. We assume for SURAP that the given subroutine 
is specified by a single parameter giving its name. The locations for use 

228 
6. 
SUBROUTINES 
are given by the first address of the operating region and the first address 
of the storage region when not in operation. These two addresses may be 
the same, but if they are not, then the main program must provide for 
transferring the subroutine to the operating locations before its execution. 
SURAP will select the named^ubroutine from its permanent storage 
location in the library (probably on magnetic tape) and will provide a 
copy of it in assembled form. This copy may be placed directly in operating 
storage or may be produced externally in a reloadable form, or both. In a 
similar way, SURAP can be made to accept an external input of a sub-
routine written in proper form and deliver a suitably modified version of 
it to storage or to an external device, or both. This latter feature will permit 
the coder to use SURAP to assemble the special subroutines he has written 
for a particular program as well as those he picks from the permanent 
library. 
All subroutines to be assembled must be written in a proper form dictated 
by the particular assembly program to be used. This will permit the as-
sembly program to distinguish between those parts of the subroutine which 
will remain fixed and those which will be modified. That is, it must be 
able to distinguish between quantities which are independent of storage 
and operation locations (constant operands, fixed addresses) and those 
which are a direct function of these locations. 
For SURAP assembly, we assume that all subroutines are coded in 
absolute machine form as though they were to operate in one set of con-
secutively addressed registers with a given initial address δ. The address δ 
can be any convenient integer. However, handling subroutines is easier if 
δ is actually an address in the range of admissible machine addresses. This 
permits the unmodified form of a subroutine to be a straight machine code 
which can operate correctly when stored with initial word at δ and which 
can be loaded into storage with an elementary input program. Thus, the 
coder can check out a subroutine in its unmodified version. For purposes 
of discussion we will fix δ as 01000. 
SURAP assembly format also places restrictions on the order in which 
instructions, parameters, and intermediate results can be stored within 
the set of consecutively addressed registers. All of the instructions in the 
subroutine come first, beginning at address δ. The last instruction in the 
subroutine must be followed immediately in storage, first by the param-
eters and constants and then by the intermediate results. All parameters 
which are functions of δ must precede the remaining parameters and con-
stants. A subroutine satisfying these conditions is said to be 
assembly 
modifiable for SURAP. 
An assembly modifiable subroutine may reference fixed registers outside 
of its operating address range as long as these addresses are given in ab-

6-2. SUBROUTINE ASSEMBLY 
229 
solute form. S u c h absolute address references should be minimized. T o 
avoid unnecessary restrictions in a choice of operating regions, 
fixed 
absolute addresses referenced b y a subroutine should be as close to each 
other as possible, since none of the fixed addresses can overlap the final 
operating region. 
Suppose that a subroutine consists of a total of Τ words, including 
parameters, constants, and intermediate results for which storage locations 
must be reserved. Let W be the number of instruction words plus the n u m -
ber of subroutine parameters whose form depends o n the initial operating 
address. W h e n the subroutine is assembled, only address parts, a, of in-
structions a n d parameters that occur i n the first W words of the sub-
routine and which satisfy 01000 < a < 01000 + 
Τ - 
1 will be modified. 
S u c h addresses are relative addresses base 01000. 
T h e modification of a 
relative address is accomplished b y adding the parameter β — 01000 to it, 
where β is the first address of the operating region selected b y the coder. 
T h a t is, the assembly program will shift the relative address origin from 
location 01000 to location ß. I n this way, a = 01000 becomes a = β, and 
a = 01000 + 
Τ — 1 becomes a = β + 
Τ — 1 , while all intermediate 
addresses are translated in a similar manner. T h e integers Τ a n d W are 
constants which are independent of the subroutine's operating region. 
Hence, they m a y be stored permanently in the library along with the file 
copy of the subroutine. If we write our o w n subroutines for assembly b y 
S U R A P , however, we will have to provide values of Τ and W with the 
input. 
I n certain instructions, such as shift instructions, address portions of 
instruction words do not actually function as addresses. Hence, a n in-
discriminate application of the modification criterion m a y lead to incorrect 
results. S U R A P must therefore be written in such a w a y that it will check 
operation codes during the modification of a subroutine and make allowances 
for the idiosyncrasies of various instructions. I n introducing modifiable 
parameters, we must be aware of the treatment S U R A P 
gives these 
idiosyncrasies. 
I n addition to the fixed order dictated b y S U R A P , it often proves useful 
to introduce other format conventions. F o r example, if the exit and entry 
points of all subroutines are fixed relative to δ, reference to subroutines in 
the main program is made simpler. F o r one thing, the reference is always 
the same even though the body of the subroutine m a y change. T h i s can 
be advantageous for programs in which the analytical description of a 
certain quantity will be different from case to case. Various forms of the 
subroutine evaluating this quantity can be coded and placed in storage 
as needed. However, all m a i n program references to the quantity remain 
the same. It is only necessary to retain the same initial point in the oper-

230 
6. SUBROUTINES 
ating region and provide an operating region large enough to contain any 
subroutine which may be coded. 
When working at any particular installation, we must become familiar 
with the details of the assembly programs used and with the dictionary 
describing all assembly modifiable subroutines which the laboratory keeps 
on file. If we also code our own subroutines in assembly modifiable form 
for later modification by the assembly program, we can postpone many 
difficult decisions on storage assignment until the program is completed. 
This will save much time and effort. 
6-2.0. An Assembly Modifiable Square Root Subroutine 
In order to illustrate the form for an assembly modifiable subroutine 
and the way in which it will be modified, we will present an example of a 
CDC 1604 subroutine designed for assembly by SURAP. The subroutine 
will compute the square root of a fixed point integral operand placed in A, 
and replace the original operand by its square root on completion. 
We shall employ Newton's method for the computation of the square 
root. Briefly, this method consists of starting with an initial approximation 
Xo for λ/Ν. 
If we then define the sequence {#»·} by the iteration Xi+i 
= 
%(xi + 
Ν/χ*), 
we have Xi —> \/N. 
For practical application we would 
like to terminate the iterative procedure at the point where | Xi — λ/Ν 
\ 
is less than some preassigned amount. Since the true error is not available, 
we will replace this criterion by the condition that the iteration will be 
terminated when | xi+i 
— Xi | is sufficiently small. Furthermore, we will 
have available only the rounded-off versions of Xi+\ and Xi, say χi+i and 
It can be shown that, with all the numbers represented by a 
finite 
number of bits, and with 0 < Ν < 1 and x 0 < 1, then for 
IN 
1 
x<+i -
 
xi = g J. ~~ 2
 X i - 
' 
the current value of Xi+i is a correct approximation to y/N 
to within the 
number of digits retained (see e.g. A. S. Householder, "Principles of Nu-
merical Analysis," pp. 10-14, McGraw-Hill, New York, 1953). This is an 
interesting example of the way in which a strictly mathematical condition 
can, and must, be translated into a corresponding computational condition. 
We shall use this condition to terminate the iteration, with all quantities 
properly scaled to reduce them to proper integer form. 
We will show the successive steps of writing the subroutine, first with 
symbolic addresses, then in a form suitable for submitting to SURAP, 
and finally in the form in which it might be assembled by SURAP. We do 
this by a sequence of examples. 

6-2. 
SUBROUTINE ASSEMBLY 
231 
Example 6-6. We write a subroutine which will replace in A a non-
negative, scaled number N2* by its scaled square root 
v/ ] y
r2
( e + 4 7 ) /
2 
We use Newton's method for computation and we wish to provide an alarm 
exit in the event that Ν < 0. For convenience in handling the scaling, we 
introduce Ν so that the subroutine will result in 
(Α) ι = N2< = iV2
47 
(A)F 
= VÎV2
47 = 
VN2<<+w* 
We consider first a flow chart for the subroutine computation (see next 
page). 
We start instructions at ßo and use the following: 
EXIT 
ENTRY 
ßo 
75 4 /(alarm 
50 0 00000 
ßl 
75 0 
[00000] 
20 0 00103 
ß2 
22 3 
ßo 
12 0 φο2
4 7) 
ßz 
20 0 00105 
50 0 00000 
ßi 
12 0 00103 
03 0 00060 
& 
07 0 00136 
25 0 00105 
ß* 
20 0 00104 
12 0 00105 
ßl 
01 0 00001 
20 0 00106 
ßio 
14 0 00104 
20 0 00105 
ßn 
12 0 00104 
15 0 00106 
ßl2 
22 3 
ßi 
12 0 00105 
ßn 
75 0 
ßl 
50 0 00000 
ßli 
37 7 77777 
77 7 77777 
J 
Alarm exit. 
PASS. 
Normal exit. 
Save N2*
7 in 00103. 
N2
A1 < 0, alarm exit. 
Set z 02
47 in 00105. 
Set z 02
47 in 00105. 
PASS. 
JV2
47 -> A. 
N2«-+AQ; 
N2!*-+QA. 
ft2P = 
W^-^QA. 
W/Xi)2«-+A. 
Save \{N/xx)2« 
in 00104. 
xx2«-+A. 
x%2« = èz.2
47 - > 4 . 
Save \x%2* in 00106. 
\{xi + N/Xi)2« - 
A. 
Xi+i -» 00105. 
W/Xi)2«-+A. 
i(N/xi 
- z.)2
47 = Δ*.·2
47 -> A 
Axt' < 0? Reloop. 
If not Xi+i = N2« -» A. 
EXIT. 
PASS. 
z 0 = (1 - 2~
4 7)2
47 = 2
47 - 1. 
We assume a format convention which places entry and exit to the sub-
routine at ßi, and the alarm exit at /30. Thus, at this stage of the coding, 
the main program reference will be, after N2
9 is in A, 75 
4 
ßi. We must, 
of course, assume that /(alarm entry) contains an instruction which begins 

232 
6. 
SUBROUTINES 

6-2. 
SUBROUTINE ASSEMBLY 
233 
a subroutine which will properly treat the Ν < 0 case and return to the 
normal exit at βχ. Since no index registers are used, we need make no pro-
vision for restoring their contents. 
Of the addresses involved in the subroutine, all symbolic addresses are 
relative to ßo except /(alarm entry) and /(ζ 02
4 7). The first of these is, of 
course, dependent on storage of the subroutines for the Ν < 0 case, and 
we assume, for definiteness, that /(alarm entry) = 70000. Finally, rr 02
47 is 
a constant used in the subroutine and we store it, following the instructions, 
at ft4 = /(z 02
4 7). 
As the code is now written, all of the addresses ßi will be dependent on the 
operating region and must be modified accordingly. All other addresses 
will be constant and are unchanged in different locations. For a proper 
SURAP assembly version, we now set ßo = 01000 and obtain the following 
form. 
Example 6-7. The assembly modifiable square root subroutine is: 
01000 
75 4 
70000 
Alarm exit. 
50 0 00000 
PASS. 
01001 
75 0 
[00000] 
Normal exit. 
20 0 00103 
Save N2« in 00103. 
01002 
22 
3 01000 
N2*
7 < 0, alarm exit. 
12 0 01014 
Set so2
47 in 00105. 
01003 
20 0 00105 
Set z 02
47 in 00105. 
50 0 00000 
PASS. 
01004 
12 0 00103 
N2« -+ A. 
03 0 00060 
N2"-+AQ; 
(QA) = N2P. 
01005 
07 
0 00136 
7V2
93 = i#2°< -> QA. 
25 0 00105 
i(#*i)2«->ii. 
01006 
20 0 00104 
Save h(Nxi)2" in 00104. 
12 0 00105 
Xi2
47 —» A. 
01007 
01 
0 00001 
χ#« = (s./2)2
47 -> A. 
20 0 00106 
Save èx.2
47 in 00106. 
01010 
14 0 00104 
s. + 12
47 = i(x< + Ît/xiflP 
-» A. 
20 0 00105 
xi+i -» 00105. 
01011 
12 0 00104 
$(N/xi)2«-> 
A. 
15 0 00106 
ï(fî/xi 
- 
Xi)2« 
= Δχ.·2
47 
A. 
01012 
22 3 01004 
I 
Axi < 0? Reloop. 
12 0 00105 
_ J 
If not, x<+i2
47 = N2*
1 —> A. 
01013 
75 0 01001 
EXIT. 
50 0 00000 
PASS. 
01014 
37 
7 77777 
xo = (1 - 2"
4 7)2
47 = 2
47 - 1. 
77 
7 77777 
For this subroutine, Τ is thirteen and W is twelve. Hence, all addresses, 
a, of the first twelve words, for which 01000 < a < 01014 will be judged 

234 
6. SUBROUTINES 
to be relative by the assembly program and modified by the addition of 
β — 01 COO, where β is the initial address of the chosen operating region. 
These addresses are underlined in Example 6-7. We must, of course, choose 
β > 00107 to avoid overlap with fixed addresses in the subroutine. We must 
also have β + 00014 < 70000 to prevent overlap with the assumed sub-
routine used in case of an alarm exit. For this example, we can then use 
any β in the range 00107 < β < 67763. 
Suppose now that we finally decide on β = 00700 as the initial operating 
address for the subroutine. The assembly program will add the constant 
00700 — 01000 = —00100 to each relative address and produce the result 
shown in the following example. 
Example 6-8. For an initial operating address of 00700, the assembled 
version of the square root subroutine produced by SURAP would be the 
following: 
00700 
75 4 70000 
50 0 00000 
00701 
75 0 [00000] 
20 0 00103 
00702 
22 3 00700 
12 0 00714 
00703 
20 0 00105 
50 0 00000 
00704 
12 0 00103 
03 0 00060 
00705 
07 0 00136 
25 0 00105 
00706 
20 0 00104 
12 0 00105 
00707 
01 0 00001 
20 0 00106 
00710 
14 0 00104 
20 0 00105 
00711 
12 0 00104 
15 0 00106 
00712 
22 3 00704 
12 0 00105 
00713 
75 0 00701 
50 0 00000 
00714 
37 7 77777 
77 7 77777 
Suppose the assembled form of the subroutine is stored and we find 
that at address ay we wish to take the square root of (ω) = iV2
1 7. We use 
12 
0 
co, 75 
4 
00700, and can continue coding at ay+i with the knowl-
edge that (A) 
= Λ / ^ 2
3 2. For proper scaling we must, of course, have s 

EXERCISES 
235 
odd to apply the subroutine to N2*, since 
λ/ ] γ
: 2
( 4 7 + β ) /
2 
must have an integral exponent. 
Exercises 
Section 6-1.1 
1. 
What happens after each of the following instructions: 
(a) 22 
5 
00100 
(b) 75 
4 
00100 
(c) 76 
5 
00100 
(Stop key 1 not up) 
(d) 76 
5 
00100 
(Stop key 1 up) 
2. 
Devise problems in which two-way, three-way, and four-way condi-
tional linkage is needed. How can these be done with conditional 
normal and unconditional return jumps? 
3. 
Redo Problem 2 with conditional return jumps only. Is the timing 
more efficient? 
4. 
Write a program to form the product of two complex numbers, stored 
at a0 and βο, and at ai and βχ. Write it as a sequence of instructions in 
a main program. 
5. 
Write the program of Problem 4 as a subroutine. Be sure to restore the 
content of any index registers used. 
6. 
Determine the implicit limitations on χ and η in Example 6-4. 
7. 
Rewrite the code of Example 6-5 to utilize indirect addressing. Transmit 
data addresses to storage from the main routine and eliminate explicit 
prestorations in the subroutine. 
Section 6-2 
8. 
Write the subroutines of Problem 5 in SURAP form. 
9. 
Determine the values of Τ and W to be applied to SURAP for assembly 
of the program of Problem 8. 
10. Write an assembly program which will assemble the program written 
for Problem 8. 
11. Simulate the computer and assemble the program in Problem 8. Re-
place address 01000 by 56000, and use the assembly routine of Prob-
lem 10. 

236 
6. 
SUBROUTINES 
12. Devise a scheme for writing a very long main program in pieces like 
subroutines, for the assembly of the final version with SURAP. 
Section 6-2.0 
13. Rewrite the assembly modifiable square root subroutine for fractional 
scaling. 
14. Rewrite the assembly modifiable square root subroutine for 
floating 
point operation. 
15. Write assembled versions of the routines of Problems 13 and 14 as 
they might be produced by SURAP. Assemble each in two different 
locations and compare the results. 
16. Use the square root routine of Example 6-7 as a basis, and write an 
assembly modifiable subroutine to find roots of a quadratic equation 
with real coefficients. 
17. Assemble the program of Problem 16 in two different locations and 
compare the results. 

CHAPTER 7 
Input-Output 
7-0. Introduction 
In Chapter 2 we gave a brief account of the way in which data are 
transferred into and out of a computer. In this chapter we shall consider 
in more detail the mechanics of input and output, with some specific 
examples. We shall make no attempt to give an exhaustive account of the 
large variety of ways in which an operator can "cornmunicate" with a 
computer. Rather we give an account of some of the simplest and most 
direct methods, concluding with a way in which a coder may use a language 
other than machine language to store into or remove pertinent data from 
a machine. 
In our earlier discussion we pointed out that most input and output 
devices represent a method of transforming an ordered array of bits, in-
ternal or external to the computer, into an ordered array external or 
internal to it. The most common external media used to transmit or ac-
cept such binary arrays are punched paper tape, punched cards, and 
magnetic tape. The first two can be used away from the computer to 
transcribe information in a form which the computer can accept. Once 
prepared, at a speed appropriate to the human operator, they can be 
entered into the proper device on the computer and the transcribed data 
are then taken by the computer at a speed suitable to it. Direct transcrip-
tion into magnetic tape from a keyboard is rare. Frequently, a card to 
magnetic tape or paper tape to magnetic tape device operating away from 
the computer will be available. It is also common in large scale installa-
tions for card-to-tape and tape-to-tape operations to be carried out under 
control of a smaller subsidiary or special purpose computer. Once prepared, 
the magnetic tape can usually be read into the computer at a rate faster 
237 

238 
7. 
INPUT-OUTPUT 
than either cards or tape. On output, information is transcribed by the 
computer to be taken to an off-line device and put into proper visual form. 
Because the computer can ordinarily transcribe information into magnetic 
tape at a rate greater than into cards or paper tape, the initial output 
may be to magnetic tape for off-line retranscription into the other media. 
Because of its higher speed of operation, magnetic tape may serve a dual 
input-output function. In addition to use in a manner similar to that of 
paper tape and cards, it may also be utilized as auxiliary storage capacity 
for the computer. That is, in an extensive program it may hold large blocks 
of data which can be transmitted under control of the program into and 
out of storage registers. In this sense, it forms a standby storage section 
whose content cannot be operated on directly, but can be rapidly trans-
mitted to operating locations. In this capacity magnetic tape will be 
useful in storing permanent library subroutines, assembly programs, 
input-output programs, and so on, with the data transmission under the 
control of the computer itself. 
Transcription media serve as buffers or time adapters between the rela-
tively slow human operator and the faster computer. These mechanisms 
will be used for the normal transfer of fairly large amounts of data. If 
sufficiently high-speed printing equipment is available, however, it may 
be used as a direct final output mechanism, making it unnecessary to pro-
duce an intermediate punched tape or card for an off-line device. In addi-
tion, there will be more direct methods of input and output which are 
suitable for exchange of small amounts of information. These will be the 
input-output devices available at the console or external control panel of 
the machine. 
At the console of the computer will be a display of the content of key 
registers, usually arithmetic registers, control registers, and index registers. 
The display will be in the form of digits (octal, binary, or decimal), giving 
register content at the time when the computer is stopped. In some ma-
chines the digits may be in continuous evidence during computer operation, 
but they are then almost useless to the operator because of the rapidity 
with which they change. Visual rendition of the content of a register forms 
an elementary and sometimes useful method of output. It gives the operator 
an immediate means of finding such things as the location of a fault condi-
tion, the current value of an operand, or the last instruction executed. 
Those registers whose content is shown on the console will also be associ-
ated with a direct input device which will permit the operator to set manu-
ally any desired value into the registers when the computer is stopped. By 
this means he will be able to initiate a program sequence at any desired 
point, set in one or more parameter values, and so on. He will also be able 
to set in an appropriate instruction, an operand, and hence, transmit a 

7-0. 
INTRODUCTION 
239 
word to any desired storage location. Because of the low speed involved, 
however, only a very limited use of such input is in order, for example, 
when initiating computer operation from scratch with no useful informa-
tion stored in the machine. 
Besides the visual and manual input and output at the console, there 
may be the equivalent of an on-line input-output typewriter. This type-
writer may effect direct entry to the storage and control registers for such 
purposes as initiating standard library routines. It may also serve to type 
out pertinent information in an alarm exit resulting from a fault condition, 
small amounts of check point data, and the like. Although the typewriter 
can generally be used to provide as much information as desired, such a 
usage will be kept to a minimum because of the relative slowness of the 
device and the consequent encroachment on computer time. The primary 
function of an on-line typewriter will not be for transfer of large sets of 
data but for monitoring and checking program and system operation. 
Because of the time limitations inherent in the direct input and output 
equipment, the normal mode of communication will be through the tran-
scription devices. That is, larger blocks of information will be recorded at 
human operator rate and then transferred to the machine at something 
more akin to its rate. The techniques of transcription will almost always 
reflect the simplicity of binary digits: the presence or absence of a punched 
hole in a paper tape or card or the presence of one of two intensities of 
magnetization in a spot on a magnetic tape. Since the strict binary sym-
bolism may not be the most convenient for practical use, some method of 
transformation to other symbols may be used. We shall see in a later sec-
tion that even alphabetic symbols and words may be acceptable to a 
computer provided that a suitable program is already available in storage 
to translate them. This translation will normally be done with the aid of 
binary codes. That is, corresponding to whatever symbol is on the key 
struck by the human operator, there will be formed an equivalent combina-
tion of bits called its code. For example, in a decimal machine we could 
introduce a code based on four-digit combinations such as: 
Digit 
Code 
Digit 
Code 
0 
0000 
5 
0101 
1 
0001 
6 
0110 
2 
0010 
7 
0111 
3 
0011 
8 
1000 
4 
0100 
9 
1001 

240 
7. 
INPUT-OUTPUT 
Other four-bit combinations than these could be used for letters or what-
ever other useful symbols might be desired. 
One of the most easily understood means of transcribing such a code is 
punched paper tape. This tape can be put into a punch which will produce 
a proper combination of holes to correspond to each binary code, or it can 
be put into a reader which will sense the presence or absence of these holes 
and decode the combination. As an example, we consider a seven-level 
tape. Slightly off-center will be a row of tiny perforations which serve as 
sprockets to transport the tape through a punch or reader. On one side of 
this row will be four, and on the other side three, levels in which any com-
bination of seven bits can be punched. A single set of punches is called a 
frame. For example, we might have the tape of the following figure: 
ο 
Frame 1 
Frame 2 
Frame 3 
Ο 
Ο 
O O 
Ο 
O O 
ο Ο 
Ο 
ο 
O O 
ο Ο 
Ο 
ο 
The three frames shown would correspond to binary combinations of 
0101101, 0011011, and 1011101. The properly coded combination will be 
punched when a key with a given symbol is struck. Conversely, a reading 
device might translate such a code into a printed version of the symbol. 
We illustrate by some examples. 
Example 7-0. Suppose we have a computer capable of storing thirty-six 
bits to a register. A simple code would be straightforward binary with a 
seventh level control. A typical tape to transcribe data for transmission to 
or from a register might then be as follows, with bits numbered as usual: 

7-0. 
INTBODUCTION 
241 

242 
7. 
INPUT-OUTPUT 
Thus the number 010111 101101 100001 011110 101010 001111 would 
appear as: 
7 
6 
5 
4 
3 
2 
1 
Control 
Control 
This tape could then be prepared outside the computer and used to load 
thirty-six bit words into computer storage or could be punched by the 
computer to indicate such words in storage. 
Since the handling of long sequences of bits is cumbersome, the usual 
practice will be to use octal or decimal equivalents. In this form Example 
7-0 represents one of the simplest codes, a straightforward binary-to-octal 
conversion. We illustrate the code in the following example. 
Example 7-1. The tape of Example 7-0 is to be coded as pairs of octal 
digits, with the seventh level as a control. Thus, each set of six bits in a 
frame will represent a pair of octal digits, and a typical word would con-
sist of: seventh level punch; six pairs of octal digits. Preparation of the 
tape of Example 7-0 would then require the operator to punch a seventh 
level key and twelve keys of octal digits marked 27 55 41 36 52 17 to 
produce the six successive frames. Similarly, a computer-produced tape 
read by a proper device would print these digits. 
Just as the octally coded punch of Example 7-1 may provide a simple 
way to permit a coder to strike a key marked " 6 " and have the combina-
tion 110 punched in a tape, other codes and appropriate mechanisms can 
be used. Some examples of such codes are given in Appendix C in which 
the codes correspond to proper octal pairs. We illustrate the use of these 
codes by some further examples. 

7-0. 
INTRODUCTION 
243 
Example 7-2. A tape-controlled typewriter is an electrical typewriter 
capable of producing a tape which can in turn be used to reproduce a 
sequence of typewriter functions. Each typewriter function corresponds to 
a two-octal digit code consisting of the corresponding six bits punched on 
the tape. Suppose we use the first typewriter code in Appendix C and 
produce, with the punch on, the typing: Computer. To type this we need 
the typewriter functions and characters: shift up, C, shift down, o, m, p, 
u, t, e, r, period and stop. We turn the punch on and strike keys for these 
functions in turn, with one key depression per frame. The codes are: 
47, 16, 57, 03, 07, 15, 34, 01, 20, 12, 46, 42, and 43. Hence, the tape pro-
duced would be: 
7 6 
5 
4 
3 
2 
1 
47 
0 
ο Ο 
ο 
ο 
16 
ο 
ο Ο 
ο 
57 
Ο 
ο 
ο ο 
ο 
ο 
03 
ο 
ο 
ο 
07 
ο ο 
ο 
ο 
15 
ο 
ο ο 
ο 
34 
ο 
ο 
ο ο 
01 
ο 
ο 
20 
ο 
ο 
12 
ο 
ο 
ο 
46 
ο 
ο ο 
ο 
42 
ο 
ο 
ο 
43 
ο 
ο 
ο 
ο 
Put through the "read" cycle of the typewriter, this tape would then re-

244 
7. 
INPUT-OUTPUT 
produce the word: Computer., and stop. Thus, we could prepare such a 
tape to be read into a computer by a proper prestored program, or the 
computer could produce such a tape based on internal storage and we 
could obtain a printed version on an off-line typewriter. 
A punched card may be thought of as a section of paper tape, with each 
column representing a frame and each row a level. Thus, logically, a deck 
of cards may be conceived of as a paper tape which has been cut into sec-
tions and stacked. Of course, the associated transcription and read devices 
and the modes of operation are quite different. The analogy between paper 
and magnetic tape is even more straightforward with hole and blank 
being replaced by different intensities of magnetization. 
Codes of the sort described are the means of permitting a computer 
operator to use a keyboard with familiar and convenient symbols to tran-
scribe information for the computer and, in turn, receive data in transcribed 
form which can be converted to a printed version. The actual acceptance 
of such transcribed information in code will require that the computer 
have a machine language load routine already stored; that is, it must have 
a program which enables it to use its peripheral sensing devices and accept 
the code and then translate it into proper form for the storage registers. 
Similarly, for the computer to prepare a correct recording of internal 
information for external reproduction, it must be provided with a machine 
language unload routine. These load and unload routines will utilize special 
instructions designed to control input and output equipment. Such in-
structions are usually labeled as external, that is, external function, ex-
ternal read, external write, or the like. In following sections we will give 
some explicit examples of instructions of this kind and their use in load 
and unload programs. 
Punched cards and magnetic tape will use codes similar to those of the 
paper tape but suitable to the particular device. For the coder the important 
thing to know for standard input and output techniques is the availability 
of appropriate load and unload routines and their requirements. In cases 
where he must code his own input and output programs, he must be more 
intimately acquainted with the instructions involved. 
For the experienced programmer, the choice of a particular input-output 
equipment and format will depend on personal preference, speed of opera-
tion, and the magnitude of the problem. For the beginner, it is more likely 
to be a matter of simplicity of preparation, and it is with the beginner in 
mind that we consider the explicit examples of the following sections. 
7-1. Examples of Input-Output Coding for the CDC 1604 
Exchange of data with external equipment in the CDC 1604 is of two 
kinds. The first of these, which we consider only briefly, is referred to as 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
245 
transfer. Transfer of data is via a special communication channel number 
seven and is controlled by the input transfer, 62 
b ra, and output 
transfer, 63 
b ra, instructions. The explicit function of these instructions 
is given in Appendix A. The use of the transfer instructions with channel 
seven is restricted to situations in which the external equipment is able 
to accept and transmit information at the full speed of the computer, for 
example, to another CDC 1604, or another smaller satellite computer. 
When a transfer is in progress, all other operations stop except the proc-
essing of input-output requests. Physically, channel seven consists of one 
input path and one output path on which data are transmitted in or out 
in blocks of forty-eight bit words at a rate of 4.8 Msec per word. The transfer 
operations may be considered as rather specialized and will not be discussed 
further here. 
The normal exchange of data is with relatively slow peripheral equip-
ment and is geared to the particular rate of the device in use. The exchange 
is carried out via six channels, of which those numbered one, three, and 
five are input channels, and those numbered two, four, and six are output 
channels. More than one external device may be connected to a channel, 
but only one can use the channel at a time. 
The mode of input and output on channels one through six differs from 
the transfer mode on channel seven in that it is buffered. That is, once 
initiated, the data exchange proceeds under an independent control asyn-
chronously with main computer operation. In effect, computer operation 
and input-output operation take place simultaneously, with independent 
access to read and write mechanisms. In actual fact they are made to inter-
lace in time in such a way that while one is waiting for the normal read-
write cycle to be completed, the other is carrying out its own cycle. The 
buffered mode of input and output provides for reading data into or out 
of a region of consecutively addressed registers. This set of registers is 
called a buffer region, and the entire operation of transferring data to or 
from such a region in this mode is called a buffer. The buffering operation 
permits the coder to arrange his program so that the computer need not 
hold up operation while waiting for the completion of a function of an 
external device. 
The transmission of data through the six buffering channels is under 
control of a special external function instruction. Before describing the 
use of this instruction in a program, however, we comment on the direct 
input and output at the console. Console output is in the form of a visual 
display in octal of the content of the six index registers, the arithmetic 
registers A and Q, the control register P, and the upper half of U when 
the computer is stopped. A blue light in the background indicates that the 
instruction shown in U is a lower instruction. The content of each of these 
registers can be changed manually by means of groups of three buttons to 

246 
7. INPUT-OUTPUT 
each octal digit which set the binary content of the register. Typical uses 
of this manual-visual feature are in checking a programmed stop and 
initiating a program sequence by insertion of the beginning address directly 
into P . Experience will teach the coder the diversity of uses of the facilities 
available at the console. 
Aside from the direct access at the console, the exchange of data is 
under control of the external function, 74 j 
z, instruction. To have a 
particular piece of equipment transmit or receive information, we must 
take three steps. We must select the particular device to be used, we must 
sense its readiness to be used, and, finally, if all is ready, we must activate 
it. Each of these three operations is provided by the designator value in 
the external function instruction in the following way: 
Select: 
74 
0 ζ 
Sense: 
74 
7 ζ 
Activate: 
74 j 
z, 
with 
j = 1, 2, 3, 4, 5, or 6 
By means of this instruction we can select a desired mode of operation 
U = 0)> check the status of a channel or device (j = 7), and initiate a 
block transfer of data (j = 1, . . . , 6). In this context, the address part ζ 
of the external function instruction becomes a coded word. When the 
instruction is taken from storage by control, the address part is transferred 
to a special register whose output is monitored by all of the external 
devices. The appropriate device will then respond to the fifteen bit code 
word. The high order three bits of ζ specify the channel, the next three the 
equipment, and the remaining nine the condition to be initiated or checked. 
This coding applies to the values,/ = 0 and 7, for sense or select. The struc-
ture of the code word is indicated in the following 
figure: 
Channel 
Device 
Condition or mode 
bi4 biz bn bn bio &9 b* 67 be 65 64 bz 62 &i bo 
External function code word 
We note that the condition or mode bits may themselves make a channel 
and device reference. These are shown in Appendix A. For the other j -
values, ζ is treated as an address to locate the buffer region in storage. 
Because of the greater complexity of the treatment of ζ in the sense and 
select functions, we will first consider the way in which any device is 
activated after it has once been selected and its readiness for use sensed. 
Each of the six input and output channels corresponds to a value of j 
from one through six, the numbering of the channels and the j-values 
being 
the same. Associated with each channel and j-value is the register with 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
247 
address equal to j . That is, for each value of j from one through six, the 
corresponding storage register with address 0000,/ will contain the initial 
address of the buffer region together with its terminal address plus one. 
The terminal address plus one must be placed in the lower address portion 
of the associated register prior to the initiation of the buffer. The initial 
address is automatically placed at the upper address portion of the register 
as equal to the value of ζ in the external function instruction. Thus, aside 
from the proper sense and select instructions, an activate form of the 
external function instruction will need to be preceded by the necessary 
transmission instructions to specify the terminal address of the buffer. 
Example 7-3. A block of data from registers 06000 through 06024 is to 
be punched on tape. The punch (connected to channel 2) has been selected 
and is ready to operate. The address 06025 has been placed in the lower 
address portion of register 00002. To initiate the buffer we use the instruc-
tion 74 
2 
06000. The value j = 2 activates channel 2 and, hence, be-
cause of prior selection, the punch. The address 06000 is placed at the 
upper portion of register 00002 so that (00002) 
= 
06000 
06025, 
and the required block of data is punched. The remaining digits in 00002 
are unused. The address 06000 is advanced by one for each word put out, 
and the final (00002) = 
06025 
06025. 
Transmission of data on channels one through six is in either one of 
two sub-modes, assembly or character. In the assembly mode the data are 
buffered, forty-eight bits per word, in sets of six-bit groups called char-
acters. On input, each forty-eight bit word is accepted directly by the X 
register and assembled with the high order bits first. Similarly, on output, 
the word is assembled in output register O
1 and transmitted in pieces to 
the peripheral device. 
Example 7-4. The octal word 1234 5676 5432 1234 is in register 01000. 
We have selected the punch in the assembly mode, the punch is ready, 
and 01001 is stored at the lower address portion of register 00002. The 
instruction 74 
2 
01000 will then cause the punch to form the octal code 
of Example 7-1 on a tape (with seventh level control omitted) as shown in 
the figure on page 248. 
The character mode causes the buffering of only the seven lowest order bits 
to or from each addressed register. This mode is useful with the codes 
mentioned in the last section, since the seven bits correspond, for example, 
to the seven levels of a paper tape. 
Example 7-5. A paper tape with the coded word: Computer, has been 
prepared as in Example 7-2. It consists of thirteen pairs of octal digits 
which we wish to store in addresses 01000 through 01014, respectively. 

248 
7. 
INPUT-OUTPUT 
7 6 5 4 
3 2 1 
12 
Ο ο 
Ο 
34 
O O 
ο Ο 
56 
ο 
ο ο Ο Ο 
76 
ο ο ο Ο ο ο 
54 
ο 
ο ο Ο 
32 
ο ο ö 
Ο 
12 
ο 
ο 
Ο 
34 
ο ο Ο Ο 
We have selected the paper tape reader (on channel 1) in the character 
mode, the tape is in the reader, and address 01015 is in the lower address 
portion of register 00001. We can then use the instruction 74 
1 
01000, 
and the codes will be stored as indicated. At this stage we can select the 
paper tape punch in character mode, store 01015 at the lower address 
portion of 00002 and use the instruction 74 
2 
01000 to have the com-
puter punch a duplicate tape of the one we made on the off-line typewriter. 
Thus, alphabetic information (sometimes called alphamerical by computer 
enthusiasts who do not mind inventing words) can be accepted and sent 
out by the computer. 
The selection of assembly mode or character mode, as well as selection 
of external equipment, is made prior to the activation of a buffer and is 
accomplished by the use of the external function instruction with a value 
of j = 0. The use of j = 0 in the external function instruction provides a 
straightforward selection of equipment and mode. It is almost always 
used in conjunction with one or more instructions which employ j = 7 to 
sense the readiness of equipment to be used. The value j = 7 may also be 
used to sense certain conditions other than the readiness of equipment, 
for example, the presence of an overflow condition. Since the sense in-
struction asks a question, it forms a branch point in a code. Thus, if the 
question is "Is channel two ready to operate?", the instruction must pro-
vide two alternatives, depending on the answer to the question. For this 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
249 
reason, with the value j = 7, the external function instruction is a skip 
instruction. The control will either exit or half exit depending on the con-
dition's being satisfied or not. Because of this feature, the instruction can 
be used as a lower instruction to provide a waiting condition or an alter-
native mode of operation if used as an upper instruction. The specific 
external function codes are given in Appendix A. 
Example 7-6. At address a we wish to start an output buffer on channel 
2 when it is ready. If the channel is not yet available, we wish to wait 
until it is and then proceed. We use the instructions 
— 
- 
74 
7 
00021 
74 
2 
a 
— 
-
Since it is used here as a lower instruction, the skip feature in the 74 
7 
ζ 
combination will cause the instruction to half exit on itself until the condi-
tion is satisfied. Thus, the computer will wait until channel 2 is inactive 
(code 00021) and then proceed with the buffer from the instruction 
74 
2 
a. 
Example 7-7. We wish to test if channel 2 is inactive. If it is, we wish to 
start a buffer operation at address β. If it is not, we wish to start a program 
sequence beginning at a. We can use 
74 
7 
00021 
75 
0 
a 
74 
2 
β 
— 
-
If channel 2 is active, a half exit is taken to the jump to a at the lower 
instruction. If it is inactive, a full exit is taken to the buffering instruction. 
A complete input or output operation, even for simple exchanges of 
data, will usually involve a combination of the external function sub-
instructions to select the equipment to be used, test its readiness, and 
activate the buffer. The codes will reflect the channels to which the various 
peripheral devices are connected, and the coder must be familiar with the 
correspondence. The channel connections for a particular piece of equip-
ment may vary from installation to installation, and thus so will the codes. 
The on-line typewriter and paper tape equipment are on channels one and 
two, while, typically, magnetic tape equipment is on channels three and 
four, and punched card devices on channels five and six. A high-speed 
printer may be connected to channel seven, or may be on one of the other 
channels. 
The coder must decide the question of how much of the burden to put 
on the machine and how much on himself. For example, he can write his 
program in such a way that the computer will stop and wait for him to put 
a new roll of tape in the punch in the event that it is out. He can also omit 

250 
7. INPUT-OUTPUT 
such instructions if he prefers always to check the quantity of tape before-
hand to see that it is adequate. 
In order to illustrate some of the typical ways of using the external 
function instruction, we give several examples. 
Example 7-8. We wish to load sixty-four words of forty-eight bit length 
which are punched on octal coded tape, and then stop the computer. The 
first of these words is to be loaded at address 00500, the rest to follow at 
consecutive addresses. We assume that the tape is in the paper tape reader 
and the reader is on. Since we are directly loading forty-eight bit words, 
we choose the assembly mode and start instructions at ao: 
74 7 00011 
75 0 
Wait for channel 1. 
Oil 
10 0 00600 
20 0 00001 
Terminal address + 1 -> 00001 
OC2 
74 7 11210 
76 0 a 2 
Assembly mode? No. STOP. 
a3 
74 0 
11200 
74 
1 00500 
Yes. Select reader and activate. 
« 4 
50 0 00000 
74 7 00011 
Buffer finished? No. WAIT. 
« 5 
76 0 
OCb 
— -
Yes. STOP. 
The instructions at a 0 and a 4 show two ways in which the 74 
7 
ζ in-
struction can be used to wait for a channel to be clear. At a 0 the instruc-
tion will continue to half exit to the unconditional jump back to itself 
until the channel is ready. At this point it will take a full exit. The com-
bination at a 4 provides for the instruction to half exit on itself until the 
channel is cleared. When the channel is ready, the full exit from a 0 pro-
vides the step which will put the terminal address plus one in register 
00001. The next instruction tests to see if the tape reader is correctly in 
the assembly mode and provides a stop for the operator to switch if it is 
not. We may, if we wish, provide an exit at this point to a typewriter 
typeout program which will prepare an appropriate message with the 
option to return to a 2 and restart. Example 7-9 will illustrate such a type-
out. If it is already in the assembly mode, the program continues at a 3 to 
select the paper tape reader and initiate the buffer. The initial address is 
provided by the value ζ = 00500 in the lower instruction at a 3. The second 
waiting step at a 4 is utilized to determine when the buffer is complete. At 
this time a full exit is taken to the stop at a 5. 
Example 7-9. Whenever a certain program generates a quantity which 
should not be negative, an alarm exit is provided to a subroutine that 
causes the on-line typewriter to type out: ALARM, after which the com-
puter stops with a provision to return to the main program if it is restarted. 
In order to type the word we must use the CDC 1604 typewriter code. A 
reference to Appendix C tells us that the codes for: shift up, A, shift down, 
1, a, r, m, and period are, respectively, 47, 30, 57, 11, 30, 12, 07, and 42. 
These eight codes are stored in order at β 4 through ßn and we use the 
character mode. We can then start the subroutine at ßo. 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
251 
0 0 
76 0 
[00000] 
74 7 00021 
Exit with stop. Wait for channel 2. 
ßl 
10 0 A4 
20 0 00002 
Terminal address + 1 to 00002. 
ß2 
74 0 21110 
74 2 
ßi 
Select TW character mode. TYPE. 
ßz 
75 0 
ßo 
— -
EXIT. 
ßi 
00 0 00000 
00 0 00047 
Code for shift up, etc. 
The use of the 76 
0 
00000 as an exit provides the stop and return jump 
option. The lower instruction at ß0 waits for channel two to be ready, 
while the program step at ß2 selects the typewriter in character mode and 
initiates the buffer. 
In Example 7-9 the character mode seemed natural, since we were deal-
ing with six-bit characters representing codes. In many situations this 
treatment will be preferred. Since the assembly mode buffers forty-eight 
bit words in groups of six bits, however, an alternative scheme can be used 
with more economy of storage. 
Example 7-10. We repeat Example 7-9 using the typewriter in the 
assembly mode: 
ßo 
76 0 
[00000] 
74 7 00021 
Exit with stop. Wait for channel 2. 
ßl 
10 0 & 
61 0 00002 
Terminal address + 1 to 00002. 
ß2 
74 0 21100 
74 2 
ßi 
TW in assembly mode. TYPE. 
ßz 
75 0 
ßo 
— -
EXIT. 
ßi 
47 3 05711 
30 
1 20742 
Codes for: ALARM. 
Since the forty-eight bit word at 0 4 is buffered six bits at a time with high 
order bits first, the code pairs 47, 30, 57, 11, 30, 12, 07, and 42 will serve 
the same function as in Example 7-9. 
In Examples 7-9 and 7-10 we have ignored a characteristic of the on-line 
typewriter, which is typical of the idiosyncrasies that we must accom-
modate ourselves to in dealing with computer peripheral equipment. If 
the carriage is already up and an instruction to shift up is received, the 
typewriter will cease operation until released by striking of the space bar. 
For this reason, before a shift up or down instruction is sent to the type-
writer, the current status of the carriage should be sensed. We will illustrate 
this procedure in the next example. 
In the preceding examples we have considered data to be transmitted 
directly with no transformation. Either the words were straightforward 
forty-eight bit combinations which could go immediately into storage, or 
they were codes which were directly applicable to the on-line typewriter. 
The question naturally arises as to how we translate a binary code from 
an external device into a proper value for a storage register. Conversely, 
how do we transform a binary sequence in a register into acceptable codes 
for external use? The particular method will depend both on the data to 
be processed and the equipment to be used. For most input-output the 

252 
7. 
INPUT-OUTPUT 
ao 
50 
1 00020 
74 
7 00021 
Set counter. Wait for channel 2. 
« 1 
74 
7 
11140 
75 0 ais 
TW in lower case? No. Set it. 
« 2 
10 0 012 
74 
7 00021 
Set terminal address. Wait for channel 2. 
« 3 
61 
0 00002 
74 0 
21110 
TA to 00002. Select TW character mode. 
ΠΓ 74 2 011 
16 0 
/(word) 
Carriage return. Word to Q. 
« 5 
55 
1 
« 6 
76 0 
as 
All 16 digits? Yes. STOP. 
αβ 
06 
0 
00003 
44 
0 
« 1 6 
No. Digit to low order Q and to A. 
« 7 
11 0 00 
60 
0 
« 1 2 
Address of code to A and prestore it. 
« 1 0 
11 0 
00001 
61 
0 
00002 
Terminal address for buffer. 
« 1 1 
74 0 
21110 
74 
7 00021 
TW character mode. Wait for channel 2. 
« 1 2 
74 
2 M 
75 0 - 
J 
Type digit. Reloop. 
an 
10 0 011 
74 
7 00021 
Set terminal address. Wait for channel 2. 
« 1 4 
61 
0 
00002 
74 0 
21110 
TA to 00002. TW character mode. 
a i 5 
74 
2 010 
75 0 
Oil 
Shift down and continue. 
« 1 6 
00 
0 00000 
00 
0 
00007 
MASK. 
coder will probably select from basic library routines available for each of 
the different cases. He can choose these more effectively if he understands 
their basic structure. Moreover, he may want to write input-output in-
structions in his own programs for monitoring purposes and the like. For 
this reason he will need to be concerned with the problems raised above. 
In this connection, a very useful device for translating a digit into a code 
for the digit is based on storing the codes in a region with an origin which 
contains the code for a zero. The remaining digital codes (any base) are 
then stored in order in consecutively addressed registers of the region. 
Suppose we have the code for the digit zero stored at ß0. Contained in 
register ßk will then be the proper code for the digit k. Hence, if we compute 
the value of k and add it to the base address ßo, we get the address of the 
code for k. In the other direction, given a digital code, an equality search 
of the code region will pick out the digit whose code it is by the relative 
position of the register at which equality was noted. 
Example 7-11. We wish to use the on-line typewriter to type the content 
of a register in octal. We assume that stored consecutively in ß0 through βΊ 
are the CDC 1604 typewriter codes for the octal digits, with the code for 
shift down in ßw and for carriage return in ßn. Because of the simplicity of 
the relation between the binary content of the register and the required 
octal form, we can compute each octal digit by simply extracting the cor-
responding three bits. We start instructions at a0 by setting a counter for 
sixteen octal digits in B\ Since we must have the typewriter in lower case 
for the digits, we test this condition and jump to an 
to shift down if 
necessary: 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
253 
Since the on-line typewriter is used for input and output, it is connected 
to both channels one and two. Because of this, an instruction to select the 
typewriter for input on channel one will be ignored if an output buffer is 
going to it on channel two. This difficulty can be avoided if we sense readi-
ness of both channels prior to selecting the typewriter for input. 
In Example 7-11 we saw how the value of a digit can be converted into 
the storage location of a code for the digit and, hence, be reproduced on 
the on-line typewriter. The same technique can be used to punch a code 
into a paper tape or card. The reverse problem of accepting a code from 
an external device and converting it into a digit for storage arises on input. 
The method for treating this case is similar to that used for output, that 
is, we base it on the ordered storage of digital codes so that the code for 
the digit k is at ßk. We illustrate the method in the following example. 
Example 7-12. We have prepared a tape on an off-line typewriter which 
uses the CDC 1604 code of Appendix C. The tape consists of the code for 
an octal digit representing a number to be stored at /(word). We assume 
that the paper tape reader is on and in the character mode. We start with 
instructions beginning at «o to accept the code for the digit and store it at 
/(code). 
a 0 
« 1 
« 2 
10 0 /(code) + 1 
61 0 00001 
74 1 /(code) 
74 7 00011 
74 0 
11200 
12 0 
/(code) 
Set up terminal address. WAIT. 
TA to 00001. Select Tape Reader. 
Read in code. Code to A. 
We now have the code for the digit in storage and in A, and we wish to 
convert it to the value of the digit. We assume storage of the codes for the 
eight octal digits in order starting at ß0. The conversion is handled simply 
with an equality search. 
az 
OA 
Oi 
oca 
50 1 00010 
50 0 00000 
64 1 ßo 
75 0 
/(alarm) 
10 0 00000 
11 1 00000 
20 0 /(word) 
76 0 
a6 
Set search count in B
l. PASS. 
Is character a digit? No. EXIT. 
Yes. (B
l) = digit goes to A. 
Store digit. STOP. 
We see that the equality search compares the code in A with the stored 
codes for the digits. If an equality is found, the address is β0 + (Β
1) 
= 
ßk = ßo + k. Thus, (Β
1) 
= k} and the exit is taken to a 6 where the digit 
value k is put in A. If the code is not that of an octal digit, a half exit is 
taken to an alarm routine which presumably handles this situation. By 
extending the table of codes to include eight and nine and changing the 
search count to ten, we could use this program to read in and store an 
integer punched in decimal digits. 

254 
7. INPUT-OUTPUT 
In the preceding examples we have ignored many of the housekeeping 
details which would be required in a useful input or output program in 
order to illustrate certain basic points. In the following sections we will 
consider in detail a complete input and output program. 
7-1.0. A Flexowriter Tape Input Program for the CDC 1604 
In this section we will describe a paper tape input routine called Flex-
Load. The routine is designed primarily with the idea of simplicity of tape 
preparation for beginning coders, including the ability to overlook certain 
kinds of ignorable errors which are frequently made by the novice. We 
first consider the format of the tape to be loaded and then consider different 
sections of the program to show how a routine can be written to achieve 
the desired results. 
The Flex-Load routine is written to accept tape prepared on a Flexo-
writer coded according to the first code in Appendix C. This code differs 
in some respects from the Flexowriter code of the CDC 1604 and from the 
code for the on-line typewriter. For most programs we can switch from one 
set of codes to another by replacing the program parameter which defines 
the origin of the storage region. Information on the tape consists of blocks 
of sixteen-octal-digit words to be loaded in consecutively addressed registers 
beginning with an initial address called the insert address. For each block 
we must specify the insert address as well as the words to be loaded. In 
order to make the typed copy of the tape easy to read, we choose the car-
riage return as a format device to separate words. To distinguish the insert 
address word from the words to be stored, we precede it by the letter i. 
Finally, to define the end of a tape, we use the letter e. Thus, for one block 
of information to be loaded, the typed version of the input tape will 
appear as follows: 
i X X X X X 
X X 
X 
X X X X X 
X X X 
x x x x x 
X X 
X 
X X X X X 
X X X 
x x x x x 
X X 
X 
X X X X X 
X X X 
x x x x x 
e 
where each X represents an octal digit. Each word, including insert address, 
stored words, and end-of-tape symbol is preceded and followed by a car-
riage return. For more than one block per tape a new insert address is 
required for each block, with no e except at the end of the final block. 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
255 
Before considering the routine itself, we note certain conditions that we 
will have to account for in writing it. Since each typewriter function pro-
duces its own code on the tape and this will be sensed by the tape reader, 
we must decide how codes other than those for i, e, carriage return, and 
octal digits are to be treated. In order to allow for latitude in spacing and 
to permit short comments, we choose to write the code in such a way that 
it will ignore all characters except the pertinent ones. Thus, we will permit 
a data word on the tape to appear on typed copy as 
X X 
X 
X X X X X 
X X X 
x x x x x 
or 
X X 
X 
X X X X X 
X X 
X 
X X X X X 
Add a t o b 
or, perhaps, 
x x x x 
x x x x 
x x x x 
x x x x 
The codes for alternate spacings and comments will be ignored. We must 
be careful in using such comments to avoid the use of the special symbols 
which are accepted by the routine. In writing the program to pass over the 
auxiliary characters, we also automatically provide for certain typing 
errors to be overlooked. Thus, if the coder in preparing a tape mistakenly 
strikes the lower case "el" key instead of the one, he can correct without 
having to delete the "el" by striking the one key. 
We must also plan to check for errors, such as an incomplete insert 
address, which could produce incorrect results. To achieve this we write 
the program to check that the insert address, following the tag i, consists 
of exactly five octal digits and that each word to be stored consists of ex-
actly sixteen octal digits. To indicate this kind of error, we will have the 
alarm exits go to routines which cause the on-line typewriter to print: 
illegal ia format 
or 
illegal word format 
a, η 
for an incorrect nth word after the last insert address a. Finally, we must 
remember that the load routine itself must have operating storage in the 
computer along with any other general routines to be used with it. We must 
therefore provide the code with a protection for itself, that is, we must 
write it in such a way that it will not accept storage of a word at an address 
which would destroy either it or the other routines to be preserved. Sup-
pose, for example, that storage of all routines to be used occupies registers 
up to, but not including, N. Then we write the program to reject storage 

256 
7. 
INPUT-OUTPUT 
of any word for which the insert address is less than Ν or for which a 
current address exceeds 77777. To indicate this kind of error the program 
will cause the on-line typewriter to print 
illegal 
ia 
or 
illegal 
ia + k 
We see that in addition to the basic instructions required for accepting 
coded information and translating it into proper form for the machine, 
we must keep in mind the usual housekeeping details, which will them-
selves constitute a major part of the program. For additional versatility 
we write the code as a subroutine beginning at β0. This will then permit 
its use to load a tape under program control. To activate the routine from 
the console we provide an auxiliary entry point at a with 
a 
75 4 
ßQ 
a + 1 
76 0 a + 1 
Return jump to load tape. 
STOP. 
We consider the program in small sections, giving a detailed discussion of 
the function of each. Hence, we can omit most of the usual editing notation. 
We make use of index registers to store key information. To hold the 
count of octal digits in an insert address or word being assembled for 
storage, we use B
1. T O hold the assembled insert address, we use B
b, while 
B
3 is used to hold an index for equality searches to check for accepted and 
ignored characters. We use B
4 to form the successive addresses of the storage 
region. To distinguish between kinds of words we will store a code in JB
6. 
The code is: 
0 
Test for insert address by looking for the pair (carriage return, i). 
1 
Test for digits of insert address after the pair (carriage return, i). 
2 
Test for sixteen octal digits after complete insert address. 
Since we use the code for a carriage return as a sensing device between 
words, we transform its code into a more convenient form. This form is 
called a carriage return flag, CRF, and is defined to have the following 
significance: 
C R F < 0 
Last six-bit character was code for carriage return, 
C R F > 0 
Last six-bit character was not this code. 
We read each six-bit character into a temporary storage for the code 
called £(word), and we assemble the actual bits of a forty-eight bit word 
into a register which we designate as £(pack). We assign storage for codes 
as follows: 

7-1. INPUT-OUTPUT CODING FOR THE CDC 1604 
257 
Flex Code 1 for: 
$o 
0000 0000 0000 0037 
Zero 
$1 
0000 0000 0000 0052 
One 
$2 
0000 0000 0000 0074 
Two 
$8 
0000 0000 0000 0070 
Three 
$4 
0000 0000 0000 0064 
Four 
$6 
0000 0000 0000 0062 
Five 
$β 
0000 0000 0000 0066 
Six 
$7 
0000 0000 0000 0072 
Seven 
$10 
0000 0000 0000 0020 
e 
$n 
0000 0000 0000 0014 
i 
«12 
0000 0000 0000 0045 
Carriage return 
δ ι , 
0000 0000 0000 0047 
Shift up 
δα 
0000 0000 0000 0057 
Shift down 
$ΐδ 
0000 0000 0000 0077 
Code delete 
$ιβ 
0000 0000 0000 0004 
Space 
$17 
0000 0000 0000 0000 
Tape feed 
Also correct for the on-line typewriter 
Each of these is a single code for the typewriter function or character in-
dicated and can be used for input testing. The codes in διι through δη can 
also be used for typewriter output in the alarm exits. For these exits how-
ever, we also need the on-line typewriter codes for the digits, which differ 
from the above, so we assign storage for these. 
On-line TW code for: 
$20 
0000 0000 0000 0056 
Zero 
$ a 
0000 0000 0000 0074 
One 
$22 
0000 0000 0000 0070 
Two 
$2» 
0000 0000 0000 0064 
Three 
$24 
0000 0000 0000 0062 
Four 
$26 
0000 0000 0000 0066 
Five 
$26 
0000 0000 0000 0072 
Six 
$27 
0000 0000 0000 0060 
Seven 
For the words to be typed in the alarm exits we can conserve storage by 
packing the codes in a single register and using the assembly mode for 
output. Additional code storage for this purpose will be: 
On-line TW code for: 
$30 
4514 1111 2013 3011 
CR, i, 1,1, e, g, a, 1. 
δη 
[0000 0000 0000 0000] 
(Reserved for buffers). 
$32 
2603 1207 3001 0404 
f, o, r, m, a, t, space, space. 
$33 
0414 3004 0000 0000 
Space, i, a, space. 
$34 
0431 0312 2204 0000 
Space, w, o, r, d, space. 
$35 
4514 3004 4604 3604 
CR, i, a, space, + , space, k, space 

258 
7. 
I N P U T - O U T P U T 
In order to explain the purpose of each instruction more clearly, we will 
use the format for the program which places each lower instruction below 
the upper. We begin instructions at ß0) provide the return exit, preserve 
the current content of the index registers used, and set appropriate registers 
to zero. 
0 o 
75 
0 
00000 
Return exit. 
56 
1 
034 
ßl 
57 
3^ 034 
56 
4 
035 
Save (B
b), b = 1, 3, 4, 5 
ß2 
57 
5 
035 
56 
6 
036 
0 3 
50 
6 
00000 
Set (B
6) = 0. 
50 
1 
00000 
Set (B*) = 0. 
ßi 
10 
0 
00000 
Set (A) = 0. 
20 
0 
/(pack) 
Set (/(pack)) = 0. 
0 5 
20 
0 
/(word) + 1 
Set (/(word) + 1) = 0. 
20 
0 
/(CRF) 
Set (/(CRF)) = 0. 
These are all instructions which prepare the way for the actual input. 
We next consider a simple loop which is designed to read in a character 
and process it while the next character is being read in, thus, by buffering, 
making it unnecessary for the computer to wait while a second character 
comes in. 
0 6 
10 
0 
/(word) + 1 
Prepare terminal address for buffer. 
50 
0 
00000 
PASS. 
0 7 
20 
0 
00001 
Terminal address + 1 -> 00001. 
74 
7 
00011 
Wait for channel 1. 
010 
74 
0 
11200 
Select paper tape reader. 
74 
1 
/(word) 
Read in one character. 
011 
50 
3 
00005 
Set B
3 to check for ignored characters. 
74 
7 
00011 
Wait for channel 1. 
0.2 
12 
0 
/(word) 
Save character in A. 
74 
1 
/(word) 
Buffer in next character. 
0.3 
G4 
3 
δι 3 
Ignore character? 
75 
0 
015 
No: Check character. 
0.4 
75 
0 
011 
Yes. Read in new character. 
00 
0 
00000 
j 
We see that the instructions at βί2 serve to save the current character 
while starting the process of reading in the next one. We next check the 
saved code to see if it is one of those to be ignored. If it is, we read in a 
new character by re-entry in the loop. If it is not to be ignored, we check 
its nature; in particular we determine if it is a carriage return by going to 
a sequence of instructions starting at βίο. 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
259 
015 
64 0 δι 2 
Is code a carriage return? 
75 0 
βζι 
No. Check what it is. 
016 
36 0 /(CRF) 
Yes. Does it follow a carriage return? 
75 0 
020 
No. Continue. 
ßu 
75 0 
011 
Yes. Ignore it and read in a new character. 
00 0 00000 
If the character was a carriage return, not followed by a carriage return, 
we proceed to ß2o to process it. If it was not a carriage return, we go to β3ι 
where we will check to see if it is an octal digit. For a carriage return we 
must distinguish where it occurs and set the proper code into Β
6 
and 
/ ( C R F ) . We do this, check for a complete insert address, check for an 
illegal insert address, and check for the end of a complete word in the set 
of instructions at β2ο through β 3 0. 
020 
10 0 
77755 
Set CRF to negative. 
20 0 /(CRF) 
021 
10 6 00000 
Code in B
6 —> A. Has part of IA been found? 
22 0 
011 
No. Read in new character. 
022 
10 6 77775 
Is code in B* for IA all in? 
22 0 
050 
Yes. Check for the end of a 16-octal digit word. 
023 
10 1 77772 
No. Check number of digits in I A. 
22 1 057 
Does IA have five octal digits? No. ALARM EXIT. 
024 
12 0 /(pack) 
Yes. Put IA in A. 
60 0 
055 
Prestore IA in program. 
025 
53 5 /(pack) 
Pres tore IA in program. 
11 0 75777 
Decrease (A) by 2000. 
02Γ, 
22 3 
063 
Is IA < 2000? Yes. ALARM EXIT. 
50 
1 00000 
No. Reset (B
l) = 0. 
027 
10 0 00000 
Clears. 
20 0 /(pack) 
Clear /(pack). 
030 
50 6 00002 
Put code for complete IA in B
6. 
75 0 
011 
Read next character. 
For characters which are not to be ignored between carriage returns, 
we must take appropriate action to implement the role of each. In particu-
lar, for an end-of-tape e, we must complete the steps for an exit, while for 
an insert address symbol i we must take a different kind of action. We do 
this in instructions stored at βζι through 0 4 i. The jumps to 0 4 2 in the se-
quence send control to a set of instructions which determine whether a char-
acter which is not an e, an i, or a carriage return is a proper octal digit. 
We see that use of the equality search instruction, 64 
b 
m, permits us 
to check the current code read by the tape reader against the stored codes 
of all the pertinent characters. If the character does not follow a carriage 
return, we jump immediately to a set of instructions at β 42 through β^} 
which will analyze its nature. If the character is an e after a carriage re-
turn, we take the necessary steps to exit. If it is an i after a carriage return, 

260 
7. 
INPUT-OUTPUT 
031 
36 0 /(CRF) 
Does character follow a carriage return? 
75 0 
042 
No. Check the kind of character. 
032 
17 0 /(CRF) 
Yes. Set CRF for next round by: 
21 0 /(CRF) 
Sign change. 
033 
64 0 
διο 
Is character an e for end of tape? 
75 0 
037 
No. Check for i. 
034 
50 1 [00000] 
Yes. Start to exit. Restore (B
l). 
50 3 [00000] 
Restore (£
3). 
035 
50 4 
[00000] 
Restore (£
4). 
50 5 [00000] 
Restore (£
6). 
036 
50 6 [00000] 
Restore (ß
6). 
75 0 
00 
Exit on end of tape. 
037 
64 0 
«11 
Is character an i? 
75 0 
042 
No. Check for octal digit. 
040 
50 6 00001 
Yes. Set B* for code for i found. 
50 4 00000 
Clear £
4. 
041 
75 0 
011 
Read next character. 
00 0 00000 
we initiate steps to handle the insert address. If the character follows a 
carriage return, but is not an i or an e, we again send control to the set of 
instructions beginning at ß42. This latter set of instructions constitutes a 
routine to determine whether the character is an octal digit, and if it is, 
to translate the code into proper binary form and put it in /(pack). 
042 
04 6 00000 
(B*) —* Q. Is insert address complete? 
23 0 
011 
No. Read new character. 
043 
50 3 00010 
Yes. Set (£
3) to check for octal digit. 
50 0 00000 
PASS. 
044 
64 3 
Is character an octal digit? 
75 0 
011 
No. Ignore it and read next character. 
045 
12 0 /(pack) 
Yes. (B*) = digit. Set pack to accept it. 
05 0 00003 
Shift pack to proper digital location. 
046 
11 3 00000 
Put digit in pack. 
20 0 /(pack) 
Store pack. 
047 
51 
1 00001 
Count the digit in B
l. 
75 0 
011 
Read the next character. 
At JÔ44 we have used the same device to translate the code for the digit to 
the actual three bits of the octal digit that we used in Example 7-12; that 
is, if the equality search finds the current code equal to one of the eight 
octal digit codes, then a full exit is made with (B
z) equal to the number of 
searched registers, or the actual value of the octal digit. The remaining 
steps provide for placement of the digit in the pack and reading of a new 
character. 
The next seven program steps through β Μ provide a check for exactly 
sixteen octal digits, a check of the current storage address, and for actual 
storage of an assembled word. 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 1604 
261 
060 
10 1 00000 
Is number of octal digits zero? 
22 0 
011 
Yes. Read next character. 
051 
50 1 77757 
No. Set (B
l) = -16i 0. Exactly sixteen? 
22 1 
067 
No. ALARM EXIT. 
052 
57 5 /(word) + 1 
Yes. Obtain address for storage. 
12 0 /(word) + 1 
Set up to check. 
053 
11 4 00000 
15 0 *(77777) 
Does storage address exceed 77777? 
054 
22 2 
073 
Yes. ALARM EXIT. 
12 0 /(pack) 
No. Start to store the word. 
055 
20 4 00000 
Store word. 
51 4 00001 
Increase storage address by one. 
056 
50 1 00000 
Clear B
1 for next count. 
75 0 
027 
Start cycle for new word. 
We now consider the sections of the routine necessary to type the proper 
information and exit for any one of the possible errors to be detected. In 
each case we use the on-line typewriter, and since digits are involved for 
some of the alarms, we want the typewriter carriage down. Hence, we will 
write a little subroutine starting at ßm which will check the carriage and, 
if necessary, shift down. We start each error routine with a link to this 
subroutine. Each of the error routines is a simple output of the appropriate 
words. The codes for these words are in packed form at δ3ο through $35 so 
that we can use the assembly mode for output. The choice of assembly 
mode is made in the subroutine for lower case. The first error statement 
occupies addresses £57 through β& and is for an incorrect number of digits 
in an insert address. The second error statement occupies addresses ßu 
through foe and is for an insert address less than 02000. 
057 
75 4 
0101 
Link to subroutine for TW lower case. 
00 0 00000 
060 
12 0 
$33 
Set up output statement. 
20 0 
$31 
061 
10 0 
$32 
61 0 00002 
Set terminal address for buffer. 
062 
74 2 
$30 
Type ALARM: illegal ia format. 
76 
1 
034 
EXIT. 
063 
75 4 
0101 
Link to subroutine for TW lower case. 
00 0 00000 
064 
12 0 
$33 
Set up output statement. 
20 0 
$31 
065 
10 0 
$32 
61 0 00002 
Set terminal address for buffer. 
066 
74 2 
$80 
Type ALARM: illegal ia. 
76 1 
034 
EXIT. 
The next error statement corresponds to an illegal word (number of octal 
digits not equal to sixteen). Since this also requires typing the location of 

262 
7. INPUT-OUTPUT 
the error, we type the statement and then send control to a routine at 
ßm 
which will provide the necessary address. This routine occupies registers 
067 through 072 and is followed by a similar routine for an insert address 
greater than 77777. 
067 
75 4 
0101 
Link to subroutine for TW lower case. 
00 0 00000 
070 
12 0 
$34 
20 0 
$31 
Set up output statement. 
071 
10 0 
$33 
61 0 00002 
Set terminal address for buffer. 
072 
74 2 
$30 
Type ALARM: illegal word. 
75 0 
0103 
Jump to type location. 
073 
75 4 
0101 
Link to subroutine for TW lower case. 
00 0 00000 
074 
10 0 
$32 
61 0 00002 
Set terminal address for buffer. 
075 
74 2 
$30 
Type ALARM 
75 0 
0103 
Jump to type location. 
We consider next the little subroutine which puts the typewriter in 
lower case. The entry point is at ßm, but we precede this with three program 
steps starting at 0 7 6 which shift the carriage down only when necessary. 
We also use this subroutine to select the typewriter assembly mode so 
that the packed words for the various alarm exits can be typed. 
076 
10 0 
$15 
Set terminal address for buffer. 
61 0 00002 
077 
74 2 
$14 
Shift carriage down. 
74 7 00021 
Wait for channel 2. 
0100 
74 7 11140 
Carriage down? 
75 0 
076 
No. Go back and set it. Yes, EXIT. 
0101 
75 0 
[00000] 
Subroutine exit. 
74 7 00021 
Wait for channel 2. 
0102 
74 0 21100 
Select TW in assembly mode. 
75 0 
0100 
Go back to check position of carriage 
The remaining instructions are the instructions necessary to type the 
locations of errors for the alarm exits. 
We have considered a simple input routine for transferring and trans-
lating external information, including instructions for the computer and 
data to be operated on, into the basic binary form it must have for actual 
storage in the computer. We have also considered the use of the on-line 
typewriter for the primary purpose for which it is intended, that is, the 
output of small pieces of information for checking errors or other key 
items. We have attempted to show by the structure of the routine that an 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
263 
0103 
50 6 00005 
Set B* for count. 
50 
1 00001 
Set B
1 for count. 
0104 
04 5 00000 
Five digit address to Q. 
07 0 00041 
Address to high order Q. 
0105 
10 0 /(word) + 1 
Set up terminal address. 
74 7 00021 
Wait for channel 2. 
0106 
61 0 00002 
Terminal address for buffer. 
10 0 00004 
Code for space to A. 
0107 
50 0 00000 
PASS. 
74 7 00021 
Wait for channel 2. 
0110 
20 0 /(word) 
74 2 /(word) 
Type character in A. 
0111 
55 6 
0112 
Five digits? 
75 0 
0115 
No. Next digit to A. Yes. Check for exit. 
0112 
10 0 00000 
Clear A. 
07 0 00003 
Next digit to A. 
0113 
61 0 
057 
} 
53 5 
057 
(Code for digit to A. 
0114 
12 5 
^ 2 0 
J 
75 0 
0107 
Jump to type digit. 
0115 
55 
1 
0116 
Both numbers? 
76 
1 
034 
Yes. EXIT. 
0116 
50 6 00005 
No. Reset £
6. 
04 4 00001 
Reset Q. 
0117 
07 0 00041 
Digit to high order Q. 
10 0 00004 
Space code to A. 
0120 
75 0 
0107 
Type space, five digits, and EXIT. 
00 0 00000 
important factor to keep in mind is the human being who prepares the 
input data and the input medium. Thus, we use octal digits which can be 
directly struck on a typewriter in place of the more cumbersome (for the 
human) binary notation. We write the routine with the recognition that 
the human coder can and will make certain kinds of errors. If they are not 
serious, they should be ignored, otherwise the coder should be given as-
sistance in locating them. When we progress beyond the short routines 
with which we start to gain skill, we find that a severely simplified input 
routine of the kind discussed in this section is not really adequate. While it 
might be useful for a long computer-produced tape, programs of greater 
magnitude are difficult to handle in terms of a coder's doing all the work 
to assemble the program and put it on the kind of tape described in this 
section. For this reason .he will usually be given assistance in terms of 
more sophisticated input-output programs, and in the later sections of 
this chapter we consider the introduction to such aids in the form of ex-
panded input-output languages. The coder must always keep in mind, 
however, that the aids themselves operate as basic machine language 
programs and have been written by people who have devoted much time 

264 
7. INPUT-OUTPUT 
to the task, and he will never be able to use them efficiently and well 
unless he understands their basic structure, a simple example of which 
we have given here. 
7-1.1. A Flexowriter Tape Output Program for the CDC 1604 
In this section we consider one of the most generally useful machine 
language outputs—a straightforward binary reproduction of the content 
of various registers, put for convenience into the more readable octal ver-
sion for the coder. 
While in most instances the octal content of a register will not be de-
sirable for results, it will be most useful in the early stages of checking out 
programs. This will include the obviously necessary copy of the current 
status of instruction words, and it may also include a simple octal version 
of certain key operands. In final production runs, we will want decimal 
output of data with properly located decimal point and other indications 
of what the significance of each number is. For a coder working on the 
checkout stages of a problem, however, there is rarely anything more 
useful than the display of the content of the registers used. In a later sec-
tion of this chapter, we consider an introduction to the more sophisticated 
forms of output. In this section, we consider what amounts to a simple 
inverse of the input routine of the last section. We show a program which 
will reproduce on tape in the same flex code of the input routine the con-
tent in sixteen-octal-digit groups of any block of specified registers. Since 
the tape is to be used to produce a printed version on off-line typewriters, 
we use the first code of Appendix C instead of the on-line typewriter code. 
In many ways the writing of an output routine is simpler than the 
writing of one for input. For one thing there is less opportunity for human 
error. We do not need to determine the correctness of the content of a 
given register but only to reproduce it. For this reason we will not have 
the alarm exits of the input program of the last section. We still have the 
problem of translation, that is, we must convert the bits in a register into 
a code which will reproduce them in acceptable form on an off-line device. 
For this translation, we will again use the technique of Sections 7-1 and 
7-1.0, of storing the codes for the consecutive digits at consecutively num-
bered registers. We will also store whatever typewriter function codes we 
need to produce a properly spaced and aligned version of register content. 
Since we use the input and output programs in conjunction with each 
other, we can use the same code storage for digits for both routines. Hence, 
we assume, as before, that the flex codes for the digits are stored conse-
cutively at registers with addresses δ0 through δ7, so that (ôk) 
= code for 
digit k. As. with the input routine, we write the code as a subroutine for 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
265 
output under control and provide a separate entry followed by a stop in-
struction for use as a straightforward terminating routine which can also 
be conveniently initiated at the console. This permits us to punch out 
pertinent parameters periodically during a program as well as terminate 
a code with an unconditional jump to the output routine. 
For the flex punch routine we will need to specify not only the initial 
address of the output region, for which we use B\ but we will also need to 
specify the terminal address. For this purpose we use B
2. Since certain 
programming situations may require that the output tape be reloadable, 
we will write the code so that the user can make the tape a legitimate tape 
for loading via the load routine of Section 7-1.0. To make the formats 
conform, we use only the initial address of the region to be punched, and 
we precede it by a carriage return and an i. For a completely reloadable 
tape we then need add only the end-of-tape e symbol. Since a single use of 
the output routine may not always make up a complete tape, we write 
the routine in such a way that the option to add the e is up to the user. 
For this we will use a code in B
z. The convention is (B
z) 
i£ 0 and will 
produce a final e. For any value of (B
z) 
= 0, we will omit the final e. 
Since we intend to use this program together with the flex load routine, 
we will start instructions at a different origin ω0 to avoid error. We start 
by writing the usual instructions for return exit and preservation of the 
current content of index registers. At this point in the program, we also 
reserve locations for the initial address, terminal address, and the code for 
a final e. 
ωο 
75 0 00000 
Return exit. 
75 0 ω4 
ENTRY. 
ωι 
00 0 00000 
00 0 00000 
Initial address of region. 
ώ>2 
00 0 00000 
00 0 00000 
Terminal address of region. 
C03 
00 0 00000 
00 0 00000 
Code for end-of-tape e. 
ω4 
56 
1 
ω52 
57 2 
ω52 
ω5 
56 
57 
3 
4 
ω53 
ω 53 
>Save current content of index registers. 
ωβ 
56 5 ω Μ 
57 6 
ω 5 4 
We next take care of some additional initial housekeeping details. This 
includes computing the total number of registers to be punched, presetting 
index registers, selecting the paper tape punch in character mode, producing 
a tape leader, storing the insert address, and punching a leading carriage 

266 
7. 
INPUT-OUTPUT 
return. We do this with instructions in ω7 through ω2ο· We again use /(word) 
for storage in turn of each word to be punched. 
ω 7 
12 0 
ω·2 
15 0 
ω ι 
ΙΑ - 
ΤΑ-+Α. 
ω ι ο 
22 2 
ω ι ι 
Is ΤΑ > ΙΑ? 
10 0 00000 
No. Clears. 
ω ι ι 
14 0 
ω ι 
Yes. ΤΑ to Α. 
60 0 
ω 4ι 
Prestore TA. 
ωΐ2 
50 
1 00005 
Set B
1 to count,IA digits. 
74 7 00021 
Wait for channel 2. 
ωΐ3 
74 0 21210 
Select paper tape punch, character mode. 
10 0 £(word) + 1 
ωΐ4 
20 0 00002 
Terminal address to buffer. 
50 6 00062 
Set frames for tape lead from counter. 
ω ΐ δ 
10 0 00000 
Set (A) to code for tape feed. 
75 4 
ωβ6 
Link to subroutine to punch (A). 
ω ι β 
55 6 
ω ι 5 
Count 51 frames of leader. 
16 0 
ω ι 
IA to Q. 
ω π 
10 0 00045 
Code for carriage return to A. 
75 4 
C066 
Jump to punch carriage return. 
In these instructions we have made use of a subroutine which is written 
to punch the code currently in A, and which has its entry at ω6β. We 
complete the introductory phase of the routine with a program step to 
put the code for i (insert address) into A and set up Q for the basic loop. 
10 0 00014 
06 0 00041 
Code for i to A. 
IA to high order of Q. 
We follow this with five program steps in co2i through 
which produce 
the insert address preceded by i: 
ω 2ι 
75 4 
ω β β 
Punch i or digit. 
00 0 00000 
0022 
55 
1 
C023 
All five digits of I A? 
75 0 
ω 2 β 
Yes. Go on. 
ω 2 3 
10 0 00000 
No. Clear A. 
07 0 00003 
Shift address digit to A. 
ω24 
61 0 
C063 
Addresses to punch routine. 
53 3 
C063 
ω 2 5 
12 3 δο 
Code for digit to A. 
75 0 
ω 2ι 
Re-enter loop to punch digit. 
The exit from this preliminary loop occurs at the point where the insert 
address, with its identifying tag of i, has been punched. We follow with 
instructions to punch sixteen-octal-digit words from 'successive registers. 

7-1. 
INPUT-OUTPUT CODING FOR THE CDC 
1604 
267 
In order to make a reloadable tape we insert a carriage return before and 
after each group of sixteen digits. To make the printed version of the out-
put tape easy to read, we provide spaces which will identify the parts of 
an instruction word by printing the sixteen digits in two groups of two, 
one, and five; that is, the form of the printed word will be 
X X 
X 
X X X X X 
X X X 
x x x x x 
We will again make use of the subroutine with entry at ω6β for punching 
the code in the accumulator, and we will write a loop to provide the proper 
spacing. The routine for proper spacing begins with a set of instructions 
starting at ω66. 
The basic loop which puts each word to be punched in Q and punches it 
one digit at a time starts at ω2β. We must provide not only the count of 
sixteen digits for each word but also the count of the number of words. 
We do this by checking the terminal address at B
2. 
C026 
53 2 
ω ι 
ΙΑ to £
2. 
50 6 00000 
Clear 5
e. 
C027 
16 2 00000 
Word to Q. 
10 0 00045 
Code for carriage return to A. 
ω 3 ο 
50 5 00001 
Set BK 
50 4 00001 
Set B*. 
C031 
75 4 
ωββ 
Punch carriage return. 
00 0 00000 
ü>32 
75 0 
ω 35 
Jump to punch digits with proper spacing. 
00 0 00000 
ω33 
75 4 
ωββ 
Punch code in A. 
00 0 00000 
C034 
55 4 
ω 35 
Count for 2-1-5 spacing. 
75 0 
ω4ο 
Punch six groups properly spaced. 
ω 35 
10 0 00000 
Clear A. 
07 0 00003 
Shift next digit to A. 
C036 
61 0 
ω 63 
53 3 
ω 63 
Data to spacing routine. 
ü>37 
12 3 δο 
Code for digit to A. 
75 0 
ω 3 3 
Punch code for digit. 
ω4ο 
54 6 00005 
Count six groups of digits. 
75 0 
ω 5β 
Jump to spacing routine. 
ω 4ι 
54 2 [00000] 
All words? 
75 0 
ω ? 7 
J 
No. Next word. 
When a full exit is made from the upper instruction at ω4ι, we are prepared 
to terminate the output. We check to see if a final e is required, punch the 
carriage return and e, if necessary, and finally, provide a trailer for the 
tape, whether or not the e was punched. We then restore the index registers 
and exit. 

268 
7. 
INPUT-OUTPUT 
0)42 
10 0 00045 
Code for carriage return to A. 
75 4 
ωββ 
Punch carriage return. 
ω43 
12 0 ω8 
Check code for final e. 
22 0 
ω4β 
Final e? No. Continue exit. 
W44 
10 0 00020 
Yes. Code for e to A. 
75 4 
ωββ 
Punch e. 
<04ö 
10 0 00045 
Code for carriage return to A. 
75 4 
ωββ 
Punch carriage return. 
ω 46 
10 0 00043 
Code for typewriter stop to A. 
75 4 
ωββ 
Punch stop code. 
ω 47 
50 6 00000 
Clear £«. 
10 0 00000 
Clear A. 
ωδο 
75 4 
ωββ 
Punch tape trailer. 
00 0 00000 
C051 
54 6 00226 
Count frames of trailer. 151? 
75 0 
ωδο 
No. Punch more trailer. 
ω 52 
50 1 [00000] 
50 2 [00000] 
ω δ3 
50 3 [00000] 
50 4 
[00000] 
Yes. Restore index registers. 
ω 54 
50 5 [00000] 
50 6 [00000] 
ω 55 
75 0 
ωο 
E X I T . 
00 0 00000 
The next eight instructions provide for the two, one, and five spacing 
of the digits. 
ω5β 
10 5 77776 
(Β*) = 1? 
22 0 
ωβ4 
Yes. Jump to punch space. 
ω 57 
10 5 77775 
No. (£
5) = 2? 
22 0 
ω6δ 
Yes. Jump to reset index. 
ω βο 
50 5 00001 
Reset indices and punch 2 spaces. 
50 4 00001 
ωβι 
10 0 00004 
Code for space to A. 
75 4 
ωββ 
Punch space. 
ω62 
10 0 00004 
Code for space to A. 
75 4 
ωββ 
Punch space. 
ω 63 
75 0 
ω 35 
Go back to punch digits. 
00 0 00000 
ω 64 
51 5 00001 
Change spacing index. 
75 0 
ωβ2 
Go to punch one space. 
ωβδ 
50 4 00004 
Change spacing index. 
75 0 
ω Μ 
Go back for other index and space 
We end the program with the little subroutine designed to punch the code 
previously placed in the accumulator. The terminal address plus one, that 
is /(word) + 1 has already been placed in the lower address portion of 
register 00002. Entry is at ω6β. 

7-2. 
AN INPUT-OUTPTJT LANGUAGE 
269 
ωββ 
75 0 00000 
Return exit. 
74 7 00021 
Wait for channel 2. 
ωβ7 
20 0 /(word) 
Code in A to buffer register. 
74 2 /(word) 
Punch code. 
ω7ο 
75 0 
ωββ 
EXIT. 
00 0 00000 
For the results of calculations we will probably want the output in an 
appropriate decimal form, with properly located decimal point, sign and 
so on. Coding of this kind will, of course, involve the necessary instructions 
to make sign tests, compute the values of decimal digits, and fix the order 
of the digits to the right and left of the decimal point. Once these calcula-
tions are made, however, the conversion of the information to a proper 
code for punching is as straightforward as in the simple octal case. We can 
use exactly the same devices for conversion, provided only that we store 
suitable codes for all the symbols required, such as the extra decimal digits, 
decimal point, and sign. 
In a similar manner we could form a coded output for other external 
media such as punched cards. For example, we need to add only the ap-
propriate output instructions to the techniques of the card image example 
in Chapter 5 for a punched card decimal output. 
7-2. An Input-Output Language 
In the earlier sections of this chapter, we reviewed the basic problem of 
input-output and discussed the mechanics of solution of this problem on 
the CDC 1604 by means of the external function group of instructions. 
We showed how these instructions are used in the paper tape load and 
paper tape punch routines of Sections 7-1.0 and 7-1.1. While these paper-
tape oriented input and output routines are useful, they will hardly suffice 
for the variety of problems which coders will have to undertake because 
they are too restrictive. Although they provide for relatively arbitrary 
choice of data addresses for either input or output, they demand a fixed 
data format, including the requirement that all data must be in octal. 
Furthermore, paper tape may not always prove the most convenient me-
dium for recording input or output data. For a typical gamut of problems, 
the coder will need input-output programs for both decimal and octal in-
formation, as well as for information consisting of alphabetic and other 
special characters. He may have the input information on cards, paper 
tape, or magnetic tape, and he may wish to have the output information 
on cards, paper tape, magnetic tape, or in printed form. He may deal with 
dozens of different formats within each of these media. The novice, as well 
as the expert coder, will find it a difficult and time consuming task to pre-
pare such a variety of input-output routines for use with his programs. 

270 
7. 
INPUT-OUTPUT 
Accordingly, in almost every computing laboratory a number of standard 
input-output programs will be prepared and kept on file in a readily ac-
cessible library. All coders should use these standard library programs 
whenever it is feasible. 
The availability of a library of input-output programs does not com-
pletely solve the coder's problem. He must learn the characteristics of 
each program in the library, and know those parameters which must be 
furnished to each in order to define the nature of the data and the manner 
in which it is to be processed. When he wishes to prepare codes in a different 
laboratory, he must master these details for the programs in the library 
of that particular laboratory. In order to lessen these difficulties, a language 
for the description of input or output data and the manner in which it is 
to be processed has been developed. This language is part of a more ex-
tensive language called FORTRAN. It is sufficiently independent of any 
particular machine so that it has been employed in a large number of differ-
ent computing laboratories. The coder can shift from machine to machine 
within or among such laboratories, and employ this basic language with 
only a minimum amount of time spent assimilating local idiom and ac-
cents. Although the basic language may be the same, the particular trans-
lators employed for different machines or installations may differ consider-
ably. In general, this will not concern the programmer provided that all 
translators are of comparable efficiency. The translator is a program which 
deciphers the coder's statements in the input-output language in order to 
determine which program, and the proper form of that program, will be 
required to process the data in the manner described by the coder. In part, 
the translator must function as an input program in order to read in the 
coder's statements. This facet of the translator is elementary, however, 
since a fixed format must be rigidly adhered to in forming input-output 
statements. 
It is the purpose of the remaining portion of this section to describe 
the elementary aspects of this input-output language and give illustrations 
of its use. Although the translator program analyzes the statements made 
in the input-output language in order to provide appropriate machine 
language instructions for carrying out the required operations, we will, 
for the most part, proceed with our description as if the statements were 
executed directly by computer control. This causes no difficulty if the 
reader keeps firmly in mind the fact that the statements result in the 
machine language program for the input-output operations described. 
7-2.0. Information Units; Fields 
A unit of input or output information 
mill consist of a linearly 
ordered 
array or string of characters chosen from some admissible 
set of characters. 

7-2. 
AN INPUT-OUTPUT 
LANGUAGE 
271 
For the admissible set with which we are presently concerned, see Appendix 
F. The number of characters in an information unit will vary from one 
medium to another and may also vary from unit to unit within a given 
medium. If information comes from eighty column cards or is to be punched 
in such cards, the unit will naturally consist of eighty characters. On the 
other hand, for output to a printer, a unit will consist of the number of 
characters that the device can print per line, which for our present pur-
poses, we will take to be 120. For input or output on magnetic or paper 
tape, information units can be "blocks" of varying length; and we will 
assume that this is true for purposes of our present discussion. In all cases, 
the length of any particular unit of information is a specific number of 
characters; and we must be well aware of this number in order for the 
format statements to be correct. 
Within a unit the string of characters will be broken into one or more 
consecutive substrings, each consisting of one or more characters. Each 
substring of characters defines a field of information. The following ex-
ample will illustrate this. 
Example 7-13. A unit of information consists of twenty consecutive 
characters (possibly including blanks or spaces), which we indicate below 
ordered from left to right and divided into three fields of five, nine, and 
six characters, respectively. 
C1C2C3C4C5 I CtC^sCçCioCnCuCizCu I C15C16C17C18C19C20 
Field one 
Field two 
Field three 
The subdivision of a unit of information into fields is associated with the 
distribution of the data in storage registers. Usually one field of information 
will be stored in one register. 
The number of characters in a field is called the width of the field. The 
characters in any field may represent information of a variety of types. 
The input-output language provides for the descriptions of field information 
of the following kinds: 
1. Decimal integer 
2. Fixed point decimal number 
3. Floating point decimal number 
4. Octal integer 
5. A sequence of alphabetic and special characters and digits which 
may include blanks (Hollerith) 
6. Blank 
We define the properties of each of these kinds of information below. 

272 
7. 
INPUT-OUTPUT 
A decimal integer is a sequence of decimal digits preceded by a plus or a 
minus sign; however, the plus may be omitted. A decimal point is not 
permitted to appear in the sequence of characters defining an integer. 
Thus, the following are examples of permissible integers: 
+ 1243 
1243 
- 
3102689 
The following are not permissible integers, however, according to the 
definition given above, since one contains a decimal point and one a char-
acter which is not a decimal digit: 
1243. 
124A 
The only restriction which the input-output language places on an integer 
is on its magnitude. Since the restriction depends on register size, it will 
vary from machine to machine and is one of the local variants in the 
language which must be learned on transferring from one machine to 
another. In the CDC 1604, integers must all be less than 2
4 7 in absolute 
value. In addition to accepting decimal integers, the input program pro-
vides other conveniences for its user. Thus, unlike the more rigid input 
routine of Section 7-1.0, we need not fill in leading zeros, nor do we need 
to supply the complement form of negative numbers. 
A fixed point decimal number is a sequence of characters composed of 
decimal digits and exactly one decimal point. The sequence is preceded 
by the appropriate sign character, but this may be omitted for nonnegative 
numbers. Thus, the following are examples of permissible fixed point 
decimal numbers: 
+ 123.101 
123.101 
- 
123.101 
101. 
.011 
The following are not acceptable as fixed point decimal numbers: 
123.101. 
125 
12.N41 
Again the register size imposes a restriction, depending on the machine, 
on the maximum number of significant digits. If too many digits are 
specified on input, all but those which can be contained in a register will 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
273 
be lost. If too many digits are specified on output, those beyond the register 
capacity will be nonsensical. In the CDC 1604, the number of decimal 
digits permitted is between one and eleven. The precise limitations im-
posed are based on the fact that fixed point decimal numbers are con-
verted internally to the floating point format of the particular machine. 
For this reason they are sometimes (incorrectly) called 
floating 
point 
numbers in external representation. 
A floating point decimal number is a fixed point decimal number, as 
defined above, which has been multiplied by an integral power of ten. In 
addition to the fixed point decimal part, only the exponent and its sign 
will be shown, the base ten being suppressed. To indicate that what follows 
is the exponent, the symbol Ε is used. Accordingly, a power of ten takes 
the form 
Ε ± cfedido 
where di represents a digit of the exponent. Leading zero digits, d2, d\ can 
be suppressed. The following are examples of admissible floating point 
decimal numbers. In some installations, either the Ε or the decimal point 
may be omitted. 
+ 123.101# + 05 
- 
123.101Ä - 
10 
101.#2 
.OWE - 
13 
- 
12.18E210 
201. # 0 
328. + 5 
Various restrictions are imposed on the magnitude of the exponent and 
the number of digits in the fixed point part because of the varying internal 
representations of floating point numbers from machine to machine. For 
the CDC 1604, the exponent may take values from —308 to +308, while 
the restrictions on the fixed point part are the same as above. The usual 
form of output will be ± 
E} so that the field width should have 
w > d by 6. 
An octal integer is a sequence of octal digits preceded by a sign char-
acter. The plus sign may be omitted. No octal point is permitted. If the 
computer is a binary-complement machine, the input routine will extend 
the sign digit of the octal integer to full register capacity whenever neces-
sary. Again, register capacity will impose locally varying restrictions. For 
the CDC 1604, an octal integer should have no more than sixteen digits. 
A Hollerith sequence is composed of a sequence of alphabetic characters, 
special characters, digits, and blanks. It is named after Dr. Herman 

274 
& 
INPUT-OUTPUT 
Hollerith, who devised the system for encoding such information into 
punched cards. The blanks provide for no punches in cards, space codes on 
paper tape, space codes on magnetic tape, and spaces in printed output. 
Hollerith sequences are used mainly for headings or other pertinent com-
ments on output media. They can be specified for input, but only for the 
purpose of altering format statements. We will clarify this usage below. 
A sequence of blanks represents a portion of a card with no punching, a 
section of a paper tape or magnetic tape with only space codes, or a se-
quence of spaces in a line of type. Therefore, blanks present no information, 
beyond indicating that the portion of the input-output unit represented 
by the blanks is to be skipped or ignored. We note, however, that blanks 
appearing in a field containing other types of information will not be 
skipped or ignored, but will be treated as zeros. This is true of decimal 
integer, fixed point decimal, and floating point decimal fields; but blanks 
in octal integer fields will be ignored. Blanks in Hollerith fields are treated 
as such. 
We distinguish types of fields in accordance with the kinds of informa-
tion contained, and denote each by a capital letter as an identifier and an 
integer w which specifies its width as shown in the accompanying tabulation. 
Field type 
Symbols 
Decimal integer 
Iw 
Fixed point decimal number 
Fw.d 
Floating point decimal number 
Ew.d 
Octal integer 
ßw 
Hollerith 
wH 
Blank 
wX 
The identifier and the field width must have the order shown in the table. 
Thus, the symbols 75, 05, 5H, and 5X, respectively, mean integer, octal, 
Hollerith, and blank fields of width 5. 
We use the symbol 0 to denote the alphabetic "oh," as opposed to zero, 
which looks the same in type but is not interchangeable. This conforms 
with a standard notation and we use it whenever necessary to avoid con-
fusion. For fields which contain decimal points, a specification of the num-
ber of decimal places to the right of the point must be made. This takes 
the form 
d, where d is a positive integer indicating the number of 
places. Thus, Fw.d, and Ew.d, respectively, describe fixed point decimal 
and floating point decimal fields of width w having d places to the right 
of the point. 

7-2. 
AN INPUT-OUTPUT 
LANGUAGE 
275 
In cases where a number η of consecutive fields of exactly the same 
description appear in a unit, we need not write down the symbols describing 
the fields η times. We merely write the description once and multiply it 
by n. Thus, nlw stands for η consecutive integer fields of width w. We are 
not permitted to designate consecutive Hollerith or blank fields in this 
manner, but we can achieve the same result with a lumped Hollerith blank 
field by replacing w by the product of η and w. 
Example 7-14. We give a number of specific field notations and their 
meanings. 
73 
describes a three-character, integer field. 
6/5 
describes six consecutive 
five-character, 
integer fields. 
F8.5 
describes an eight-character, fixed point decimal field with five 
places to the right of the decimal point. 
32?8.2 
describes three consecutive eight-character, floating point fields 
with two places to the right of the decimal point. 
4016 
describes four consecutive sixteen-character, octal integer fields. 
33X 
describes a field of thirty-three consecutive character positions 
to be ignored on input or blank on output. 
2Iff 
describes a field of twenty-one Hollerith characters. 
7-2.1. Format Statements 
The Format statement is one of the fundamental modes of address of 
the input-output language. It is used to describe the makeup of units of 
information. To specify the format of a unit of information, we write down 
the descriptions of all fields contained in the unit using the notation given 
in Section 7-2.0. The field descriptions are separated by commas and 
ordered in the normal sequence in which the fields will be scanned. This 
sequence is usually clear in any particular case and may generally be char-
acterized by the term "left to rights To complete the statement of format, 
we enclose the sequence of field descriptions in parentheses and preface 
the parenthesis by the word F0RMAT. Accordingly, a Format statement 
appears as 
s F0RMAT (Ci, C i , · · · , CM) 
where C» (i — 1, 2, · · ·, k) are the field descriptions. Since a variety of 
format statements may be needed in a program, we identify a particular 
one by assigning to it a unique statement number s. The statement num-
ber is an integer on the range 1-99999 which precedes the word F0RMAT 
in the statement. 
Example 7-15. In an eighty-column card, the first five columns are not 
used for purposes of input or output. The following fifteen columns are 

276 
7. INPUT-OUTPUT 
divided into five integer fields of width three, and the next 
fifty-four 
columns are used for six fixed point decimal fields in which there will be 
three digits to the right of the point. The remainder of the card is not 
utilized. The Format statement takes the following form: 
s F0RMAT (5X, 5/3, 6F9.3) 
A Format statement by itself initiates no input or output. It is made 
merely for reference. To initiate input or output, the language has a variety 
of statements, each of which specifies a particular peripheral device to be 
utilized and gives an ordered list of addresses from which output will be 
taken or to which input will be delivered. The Format statement serves as 
a reference for these input-output statements, and we define and examine 
them in greater detail below; however, of more immediate concern is the 
way in which the list of addresses provided by an input or output state-
ment interacts with the format statement which it refers to. 
A Format statement presents an ordered list of fields and a description 
of the information contained in each field. The ordered list of fields pro-
vided by the Format statement then is matched to the ordered list of 
addresses provided by the input or output statement. The address thus 
associated with each field will specify the location to which input from that 
field is to be delivered, or the location from which output for the field is 
to be taken. Of course, the digits taken from the input medium and de-
livered to the addressed register, or taken from the addressed register and 
delivered to the output medium, must represent information of the type 
described by the corresponding field description. If this is not the case, an 
error will ensue. In matching the list of fields to the list of addresses, care 
must be taken in dealing with X-fields and i/-fields. An X-field can con-
tain no input information. Neither can it receive output information. It 
merely provides a means of ignoring part of a unit of input information 
or of not inscribing any data in part of an output unit. Thus, X-fields are 
ignored in the matching of addresses and fields in the two lists. 
To understand why //-fields receive special treatment in the matching 
process, we must amplify somewhat on their properties. In fact, the in-
formation in an //-field is normally specified within the Format 
statement 
itself. For example, assume that the iZ-field is to contain characters repre-
senting the table heading A R C T A N G E N T THETA. This gives a sixteen-
character Hollerith field including the space between words. Its description 
in the Format statement takes the following form: 
1 6 H A R C T A N G E N T AT H E T A 
Here the characters 16H identify a Hollerith field of width sixteen and the 
field information itself follows immediately. The symbol 
Λ which would 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
277 
not normally be present, has been included to call attention to the fact 
that the space is counted in the sixteen characters. We see that i7-field 
information is actually a part of the Format statement, and on input it 
will be stored as part of the Format statement. For output, these char-
acters can then only be taken directly from storage within the Format 
statement and not from any storage register whose address is listed by 
the output statement. If a Hollerith field is referred to in a Format state-
ment for an input operation, Hollerith data on the input medium will 
replace the Hollerith data in the Format statement and not in any listed 
register. Thus, iï-fields must be ignored as far as the matching of addresses 
and fields in the two lists is concerned. We remark in passing that if we 
wish to get Hollerith characters into addressed registers, we can determine 
their codes in octal (see Appendix C) and employ octal field notation. A 
more convenient means of introducing Hollerith data into 
addressed 
registers will be provided in Chapter 8. 
Example 7-16. Assume that an input statement specifies a list of eleven 
addresses and refers to the format statement s of Example 7-15. In match-
ing the list of eleven addresses to the fields listed in Format statement s, 
we ignore the initial no information or blank field of width five. The follow-
ing five fields of three-character integers are then stored in order in the 
first five locations listed by the input statement. The remaining six fields 
of nine characters are stored in order as floating point numbers in the re-
maining six listed locations. We point out again, that on input, information 
in F-fields, which are fixed point decimal numbers externally, become 
floating point numbers internally. 
We note that in Example 7-15 the Format statement makes no reference 
to the field formed by the final six unused columns of the card. This was 
not necessary since the left parenthesis signified the beginning of an in-
formation unit and the right the close. Thus, when the right parenthesis 
is encountered, the remainder of the card is ignored. The next unit, con-
sisting of the next card in the deck, will be read provided that there are 
still unmatched addresses on the list furnished by the input statement. 
This is not the case in Example 7-14, and so the input operation terminates. 
Example 7-17. Assume that a list of twenty-two addresses was specified 
in the input statement of Example 7-14. In this case, the input will proceed 
as before, except that after the first eleven fields of information defined 
by the Format statement have been matched to addresses, the input 
routine will determine that, although the unit of information has been 
exhausted, there are still eleven unfilled locations in the list of addresses. 
The next unit must then be read and matched to the unfilled input loca-
tions. This is done according to the format initiated by the opening paren-

278 
7. 
INPUT-OUTPUT 
thesis immediately preceding the closing parenthesis which signals the 
end of the previous unit. Although there is only one opening parenthesis 
in the Format statement under consideration, we have presented the rule 
in this general way so that it will also apply in the more complex cases to 
be introduced below. 
Example 7-18. Assume that an output statement for card punching 
specifies a list of addresses totaling some multiple η of eleven and refers 
to Format statement s of Example 7-15. The output routine will then punch 
η cards. The first five columns of each card will be blank as well as the last 
six. The first five three-column fields of each card will contain decimal 
integers and the following six nine-column fields will contain fixed point 
decimal numbers with three places to the right of the decimal point. These 
values will be taken from the storage registers in the order in which their 
addresses appear on the output list. The first five registers listed should 
contain integers of correct magnitude and the next six, floating point 
numbers of correct magnitude, and so on, alternately, until the list is 
exhausted. 
We note that on output in the form of F-fields, the content of the ad-
dressed register is treated as a floating point number even though the in-
field holds a fixed point number. We have already seen that F-fields go 
into floating point form on input. 
At this point we may make some general observations. 
1. An input statement will cause the input routine to continue calling 
in new units from the peripheral device until the list of addresses specified 
by the input statement has been exhausted. Similarly, an output state-
ment will cause the output routine to continue sending out new units to 
the peripheral device until the list of addresses furnished by the output 
statement has been exhausted. 
2. The input or output routine will determine that all relevant fields 
in a unit have been matched with addresses when it encounters a closing 
parenthesis in the Format statement. It then stops if the address list is 
exhausted. If the address list is not exhausted, it goes to the next unit and 
continues matching fields and addresses in accordance with that part of 
the Format statement which begins with the opening parenthesis immedi-
ately preceding the right parenthesis which signalled the end of the previ-
ous unit. 
To this point we have introduced only a single opening and a single 
closing parenthesis. In what follows, we introduce extensions of the use of 
parentheses in order to be able to describe a number of different input-
output units in a single format statement. For this reason, we have stated 
observation (2) in a more general way than yet necessary. Before extending 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
279 
the use of parentheses, however, we will define another means of incorpo-
rating the description of more than one unit in a single statement, namely 
the slash, /, symbol. 
We have seen that an input or output statement referring to a Format 
statement of the form 
s F0RMAT (Ci, C 2, · · · , Ck) 
causes the list of fields to be repeatedly matched against the list of addresses 
it supplies until the list of addresses is exhausted. As many units as necessary 
will be activated until this condition is met. All of these units will have 
the same structure since statement s defines the format of exactly one 
unit of information. To assist in defining the format of more than one 
unit of information with a single Format statement, we use the slash 
symbol. When this symbol appears in a Format statement, it is interpreted 
to mean that the current unit is terminated. If the list of addresses supplied 
by the input-output statement has not been exhausted, the next unit is 
then processed according to that part of the format statement to the 
right of the slash. 
Example 7-19. We have the following Format statement: 
s F0RMAT (3Z, 75, 3X, 77, /, 18X, 37Ί0.4) 
We wish to determine the effect of an input statement specifying cards and 
listing 100 addresses. We can regard the initial opening parenthesis as a 
signal to the input routine to read in the first unit of information or, in 
this case, the first card. The format of this card is given by the field de-
scriptions up to the slash. Accordingly, a five-character decimal integer is 
taken from columns four to eight and stored at the first listed address, and 
a seven-character decimal integer is taken from columns twelve to eighteen 
and stored at the second address of the list. The slash indicates the end 
of the unit represented by the first card. Since the list of addresses has not 
yet been used up, the next unit, that is, card, will be read in and processed 
according to the field description following the slash. This results in the 
three 
fixed-point 
four-decimal place numbers in columns 19-28, 29-38, 
and 39-48 being stored as floating point numbers at the next three addresses 
on the list. The closing parenthesis indicates the end of the unit. Since the 
address list is not yet exhausted, the input routine returns to the opening 
parenthesis immediately. preceding the closing right parenthesis and con-
tinues. The next two cards will be read and five numbers stored at the 
next five addresses of the input list, and so on until the address list is used 
up. This will result in forty cards being read. Of course, at least forty cards 
punched in the proper format should have been placed in the hopper of 
the card reader. 

280 
7. 
INPUT-OUTPUT 
We note in Example 7-19 that the input process will continue until the 
address list is exhausted. The Format statement will be used repeatedly 
until this condition is achieved. The repeated use of the Format statement 
generates a list of fields long enough to satisfy the list of addresses given 
by the input statement. A corresponding remark holds for output as we 
see in the following example. 
Example 7-20. We wish to determine the effect of an output statement 
listing 100 addresses, specifying a line printer and referring to format s of 
Example 7-19. The resultant output will consist of 40 printed lines. The 
odd numbered lines 1, 3, 5, · · · , 39 will contain a 
five-character 
and a 
seven-character integer. The even lines 2,4, · · ·, 40 will contain three ten-
character, four decimal place numbers. No integer will appear directly 
above or below a number containing a decimal point. This follows from a 
discussion similar to that of Example 7-19. 
We note that in the last two examples the X fields were ignored in the 
process of matching the field list to the address list. 
In Examples 7-19 and 7-20 we illustrated the use of the slash symbol to 
incorporate the description of more than a unit of information into a single 
Format statement. In the examples, the slash appeared in the statement 
with one information unit to its left and the description of the following 
unit to its right; that is, the slash appeared somewhere in the middle of 
the format statement. We now consider the effect of a slash appearing at 
one end or the other of the statement, that is, with all field descriptions 
either preceding it or following it. In the latter case we have a statement 
of the following form : 
s F0RMAT (/,···) 
We have not shown any more of the statement detail since it is not relevant 
to the point we wish to make. To determine the effect of this Format 
statement, we must keep in mind that both the initial opening parenthesis 
and the slash call for the next unit, with the slash's having the additional 
property of terminating the previous unit. Thus, in this case, the opening 
parenthesis calls for a unit of information and the slash terminates this 
unit and calls for its successor. Since there are no fields described between 
the parenthesis and slash, the information unit called for by the opening 
parenthesis cannot be processed before termination by the slash, so it is 
ignored. If the Format statement is referred to by an input statement 
calling for card input, the first card in the deck will be read and disregarded. 
If the input statement calls for magnetic tape or paper tape, the first 
record, or block on tape, will be read, but then not used. If an output 
statement to cards refers to this format, the first card in the deck will be 

7-2. 
AN INPUT-OUTPUT 
LANGUAGE 
281 
blank, that is, unpunched. If the output is to a line printer, there will be 
a blank line. The effect is like that of a carriage return on a typewriter. If 
the output is to tape, a record or block composed of blank codes will occur 
on the tape. 
We may also place more than one slash in succession in a Format state-
ment. We may do this either by writing the exact number η of slashes we 
wish, or (in some installations) by writing one slash preceded by the 
number n. If this letter were done in the last Format statement, it would 
appear as follows: 
s F0RMAT (η/, · · · ) 
The result would then be η blank lines, cards, or tape records on output, 
and the passing over of η cards or tape records on input. This is confirmed 
by an analysis similar to the one made above for a single slash. We note 
that the η blank, or unprocessed, units result from the combination of the 
initial opening parenthesis and the first η — 1 slashes. The unit called for 
by the nth slash is processed in the manner imposed by the field descrip-
tions appearing immediately to the right of the slash. Similar reasoning 
leads us to conclude that η slashes appearing with field descriptions be-
tween them and the parentheses on either side, will lead to η — 1 blank or 
unprocessed units of information. There is one less unit in this case because 
there is no opening parenthesis immediately preceding the first slash. The 
unit activated by the nth slash will be processed according to the part of 
the Format statement to the right of this slash. Conceivably, this could 
result in this unit's also being ignored. 
We complete the discussion of the slash symbol with the case of the 
following Format statement: 
s F0RMAT ( - - · , η / ) 
We see that this is essentially the same as the case of η slashes in the middle 
of a format statement and will result in η — 1 blank or unprocessed units 
due to the first η — 1 slashes. Because there is no information in the part 
of the Format statement between the right of the nth slash and the closing 
parenthesis, however, the additional unit activated by this slash will also 
be blank or unprocessed, for a total of n. 
We have seen that our notation permits us to avoid repetition; for ex-
ample, nlw stands for η consecutive integer fields of width w, and, in some 
laboratories, n / stands for η consecutive slashes. Frequently we encounter 
the situation in which a sequence of the members of a Format statement 
will be repeated successively if written out at length. For example, we 
might have the requirement for 
. - ·, 75, 2X, 76, / , 75, 2X, 76, / , 75, 2X, 76, / , · · . 

282 
7. 
INPUT-OUTPUT 
appear within a Format statement. We avoid unnecessary repetition in 
this case by the same device as before. We merely write 
. . . , 3 [ / 5 , 2X, 76, / ] , · . . 
In general, we have the form 
. . · , n [ 
] , . . . 
where the content of the square brackets consists of the repeated part of 
the format. This notation is equivalent to writing the content of the 
brackets within the Format statement η consecutive times at the point 
the brackets appear in the statement. We have introduced brackets for 
this purpose in order to distinguish them from the parentheses we have 
previously employed, which play a vital and not yet completely explored 
role in determining the sequence in which the fields in a Format statement 
are matched to the address list and which also influence the activation of 
information units. The square brackets have no such functions, serving 
only to specify that part of the Format statement to which the repetition 
index η applies. Unfortunately in practice, we do not have a distinct code 
for a square bracket symbol available for input to the computer. Accord-
ingly, all brackets and parentheses on actual input to the translator will 
appear to be the same. The translator will have no difficulty telling the 
two kinds of parentheses apart, and neither should we once we have at-
tained some proficiency in the use of the input-output language. At this 
early state, however, we will continue to make the distinction. 
Example 7-21. An input card is divided into a 
five-digit-integer 
field, 
a 
five-column 
blank field and fields of ten columns each. The data for the 
seven ten-column fields consists of numbers with four decimal places to 
the right of the point. For purposes of processing external to the computer, 
five data cards for each case have a blank card with a distinctive corner 
cut preceding them. All cards are placed in the card reader. We give a 
Format statement for reference when reading the data for any single case. 
15 F0RMAT (/, 4[75, 5X, 7F10.4/], 75, 5X, 7F10.4) 
We can also use Format statement 15 as a reference to list the input data 
for each case. On output to printer this format provides for a blank line 
preceding the data. This spacing will improve the appearance of the listing. 
Spacing between the listing of input data and the listing of results can be 
provided by the format statement used as a reference in listing results. 
The following, if used, yields two blank lines: 
20 F0RMAT (//, ·..) 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
283 
Example 7-22. For each of a number of cases, we want output of the 
following format: 
15 CHARACTERS H O L L E R I T H 
4 Floating Point Numbers 
The fifteen Hollerith characters identify the particular case and are read 
in with the input data for each case. The data is the same as that of Ex-
ample 7-21, except that the first card contains the identifying Hollerith 
information in columns 1 to 15, instead of being blank. Our Format state-
ments for output reference can take the form: 
100 F0RMAT 
(15#Λ ΛΛΛΛΛΛΛΛΛΛΛΛΛΛ) 
200 F0RMAT (//, 4#17.10) 
Format statement 100 contains 15 arbitrary characters, which are to be 
filled by an input statement for cards referring to it and providing no address 
list. This will read in the first card of the input deck. The remaining 5 
cards may be read in with reference to the following format statement: 
300 F0RMAT (4[75, 5X, 7F10.4, / ] , 75, 5X, 
7F10A) 
Output to printer can be handled by two statements, the first referring to 
Format statement 100 with no address fist and the second to Format state-
ment 200 with an appropriate address list. 
We have seen how the parentheses are used in a Format statement for 
reference in determining the order in which field descriptions will be 
matched with the address list and also for reference in determining when 
to activate the next unit of information. To this point we have introduced 
only a single opening parenthesis and a single closing parenthesis. We may 
introduce other parentheses. For example, we may have a Format state-
ment with the following structure, where we have numbered the parentheses 
for reference. 
1 
2 
34 
s F0RMAT (...(...)) 
We will have no difficulty in determining the effect of this or any other 
particular structure if we keep the following basic rules in mind. 
(a) The initial opening parenthesis always calls for activation of the 
next available unit of information. 
(b) The interior opening parentheses are to be ignored when encountered 
on scanning the Format statement from left to right. 

284 
7. 
INPUT-OUTPUT 
(c) A closing parenthesis calls for the scanning procedure to back up to 
the nearest preceding opening parenthesis and then resume from left to 
right, provided the address list is not used up. When encountered in this 
manner, an interior opening parenthesis has the same effect as an initial 
one. [See (a).] 
On applying (a), (b), and (c) to the last Format statement, we see that 
it will be scanned from parenthesis 1 to parenthesis 3, and then from 
parenthesis 2 to parenthesis 3, repeatedly until the address list is exhausted. 
A unit of information will be activated at parenthesis 1. The first time 
parenthesis 2 is reached, it will be ignored, but on each subsequent en-
counter, a new unit of information will be activated. Parenthesis 4 is never 
used and could be omitted; however, it seems tidier to have as many 
closing parentheses as opening parentheses in each Format statement. 
Example 7-23. In a deck of data cards, the first has a ten-character 
integer in columns 1-10 to identify the particular experiment to which the 
data corresponds. The following data cards are all filled with five char-
acter integers. We may read cards with reference to the following Format 
statement. 
138 F0RMAT (710, /, (1675)) 
When the address list has been used up, the scanning of the Format 
statement will stop, no matter how many or few times it has been perused, 
or when the process happens to be within the statement. The input or 
output operation, activated by the statement furnishing the list, is then 
finished. 
The controlling factor in this regard is the address list and not 
the Format statement. Accordingly, a Format statement may have elements 
which, for a particular address list, are never used. This feature may enable 
us to utilize a single Format statement with a number of different input-
output statements. 
7-2.2. Address Mnemonics 
The input or output statement supplies a fist of addresses of registers 
in which data will be stored or from which data is to be taken. When we 
are preparing such statements, we do not always know what the total 
storage requirements of the program will be; and, hence, we cannot assign 
addresses to all quantities until we have completed the program. We must 
assign addresses, however, in order to complete the program. As we saw 
in Chapter 3, we get out of this seeming dilemma by the use of symbolic 
addresses which are converted to absolute form, or assembled, on comple-
tion of the program when all requirements are defined. We saw in Chapter 

7-2. 
AN INPUT-OUTPUT 
LANGUAGE 
285 
6, that for subroutines, if the address symbolism is properly chosen and 
if program format is properly chosen, the assembly process can be carried 
out in the computer by means of an assembly program. In Chapter 8, we 
extend this idea to include complete programs. Here, we apply this same 
concept for the list of addresses supplied by an input or output statement. 
These addresses must be given in symbolic form. When the entire program 
has been written, they will be converted to absolute form by an assembly 
program. We will assume that the translator program can perform the 
assembly function, and confine ourselves here to defining the permissible 
forms for symbolic addresses. 
Symbolic addresses for the input-output language are defined to con-
sist of any combination of at least one and not more than seven decimal 
digits and alphabetic characters. In all cases, the first character must be 
alphabetic. Several other restrictions on the selection of address symbols 
are imposed by the interpretation which is to be placed on the stored data. 
We note that externally we are permitted a variety of different kinds of 
information in fields. Internally, however, in the storage register, the 
information will either be a fixed point integer or a floating point number 
in whatever base the computer uses. We recall that i/-fields and X-fields 
are not to be associated with symbolic addresses. If the stored numbers 
are integers (/-fields, 0-fields), the following restrictions apply to symbolic 
addresses. 
1. The first character must be one of the letters I, J, K, L, M, or N. 
2. If the address is represented by one of the single characters I, J, K, 
L, M, or N, the integer must be less than 16,384 in magnitude. 
3. If more than four characters are used, the last one cannot be F. 
If the stored numbers are floating point (F-fields, ^-fields), the following 
restrictions apply to symbolic addresses. 
1. The first character must not be I, J, K, L, M, or N. 
2. If four or more characters are used, the initial one must not be X. 
All of these may be considered as format restrictions to comply with the 
way in which the assembly or translator program is written. Since some of 
these restrictions are based on index register availability and capacity, 
they are, in part, local, and should be reviewed on transfer from one ma-
chine or installation to another. The restrictions serve to emphasize a 
defect in the input-output language as stated here, namely, that there is 
no flexibility in the internal handling and scaling of fixed point numbers. 
These must be reduced to integers externally by incorporation of the scale 
factor before input and returned to mixed form by removal of the scale 
factor after output. 

286 
7. INPUT-OUTPUT 
Example 7-24. The following are examples of admissible symbolic ad-
dresses for registers containing integers: 
IA33 
M O N E Y 
JAMES4 
The following are not admissible : 
AI33 
(Begins with wrong letter) 
42XY 
(Begins with a digit) 
I J K N N F 
(Ends with F) 
JAMES4TH 
(Too many characters) 
Example 7-25. The following are examples of admissible symbolic ad-
dresses for registers containing floating point numbers: 
TALLY 
S P E E D 
A33 
B1J4 
The following are not admissible: 
I N D E X 
(Begins with wrong letter) 
VELOCITY 
(Too many characters) 
33A 
(Begins with a digit) 
XCOORD 
(Begins with X) 
7-2.3. Address Arrays 
In Chapter 3 we introduced the idea of a relative address. Such addresses 
were represented by symbols such as α», ω,·. Each of these subscripted 
address symbols represents one of a sequence of consecutive addresses 
with the subscript defining the position of any address relative to the origin 
by the formula 
ai = αο + i 
or 
ω» = ωο + i 
The input-output language also permits the use of a subscripted symbolic 
address to represent one of a consecutive sequence or block or region of 
addresses. The input equipment does not conveniently permit subscripts 
or superscripts, however, so that notationally we write the subscript as an 
argument, placing it in parentheses following the symbolic address name. 
Thus, we can write ALPHA (/) or 0MEGA(7) for any of the addresses 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
287 
symbolized previously by a, and ω». For specific addresses in a region we 
write down the specific value of the argument, for example, ALPHA(5), 
0MEGA(16). We note a few general rules: 
1. We may use any admissible symbolic address name for the array of 
addresses of a region as long as it does not end in F and as long as it cor-
responds to the type of information to be contained in the registers of the 
region. Thus, it must conform to the restrictions stated above for this type 
of information. The subscripts and their surrounding parentheses are not 
counted as a part of the permissible number of characters in the name. 
2. The subscripts or arguments can be specific positive integers or can 
be symbolic names of registers containing information of integral type, 
namely, the current value of the subscript. We point out that addresses in 
machine language instructions have been used in this dual way, with some 
giving quite specific parameter values and others giving actual machine 
addresses. In some cases the subscripts may serve merely as dummy 
indices. The particular interpretation will be made clear by the content. 
3. Subscripts must have values at least equal to one; however, some 
translators treat an unsubscripted address name as equivalent to one with 
subscript zero and assign a location accordingly. We assume that this is 
the case here. 
On many occasions our mathematical notation for objects which are to 
be stored in the registers of a region of consecutive addresses calls for more 
than one subscript. For example, we may be dealing with a matrix 
A, 
whose elements we denote by A a. In such cases, it is convenient to extend 
the symbolic address notation so that it is easier to name the address at 
which a particular subscripted quantity will be stored. We do this to the 
extent of permitting as many as three subscripts. The subscripts are sepa-
rated by commas in the conventional way in which commas are used to 
separate arguments of functions of many variables. The rules stated above 
continue to apply. Thus, we may employ A (I, J) as a symbolic address in 
the storage region of the matrix A, and for the address of the element in 
the 4th row and 5th column we may write A (4, 5). For a three dimensional 
array of integers, we may assign a notation such as J I M (I, J, K ) , with a 
specific element JIM 3 ti, 2 having address J I M (3, 1, 2). Although we have 
been using names I, J, Κ for subscript addresses, we may use any admis-
sible fixed point integral names. Address names I, J, K, L, M, and N, will 
restrict the values which subscripts stored in these locations may take on 
to a range of 1 to 16383. 
We emphasize that these two and three dimensional arrays go into a 
single region of consecutive addresses. Storage of two dimensional arrays 
of quantities in registers addressed by a single region of addresses is by 

288 
7. 
INPUT-OUTPUT 
columns. Since conventionally, in a two dimensional array, the first sub-
script represents the row and the second the column, this means that we 
hold the second subscript fixed and let the first go through all of its values, 
and then advance the second subscript by one and let the first go through 
all of its values again, and so on, until the second has gone through all of 
its values. Accordingly, in the 3 X 3 symbolic address array A (I, J ) , the 
initial address of the region is assigned to A ( l , 1) and the final to A(3, 3). 
In between we have in order A(2, 1), A(3, 1), A ( l , 2), A(2, 2), A(3, 2), 
A ( l , 3), A(2, 3). As assumed in rule 3 above the symbol A will be assigned 
a location immediately preceding A ( l , 1). We determine the storage order 
of three dimensional address arrays by the same general process, allowing 
the first subscript to vary most rapidly, then the second, and the final one 
least rapidly. 
The assembly or translator program knows a priori that it need assign 
at most one storage location for each different nonsubscripted symbolic 
address; however, the assembly program must be told the number of 
storage locations to reserve for an array of symbolic addresses. It is given 
this information by means of a dimension 
statement. A possible dimension 
statement for all of the arrays introduced above is the following. 
DIMENSI0N ALPHA (20), 0MEGA(32), A (3, 3), J I M (4, 2, 2) 
The integers appearing in place of a subscript argument give the maximum 
value that that particular subscript argument may take. Thus, we have 
stated that the ALPHA and 0MEGA regions require at most 20 and 32 
storage locations respectively, while A requires at most 3 X 3 = 9 
con-
secutive locations, and J I M requires at most 4 X 2 X 2 = 16 consecutive 
storage locations excluding the locations assigned to the unsubscripted 
region name itself. No harm beyond a waste of storage capacity occurs if 
the number of elements in any of these arrays turns out to be less than the 
maximum stated in the dimension statement. If we introduce more ele-
ments than we have told the assembly program we would, an error will 
result. 
Like the Format statement, the Dimension statement is a passive ele-
ment of the input-output language, serving merely as reference material 
for the assembly program. We may use a single Dimension statement for 
all of our symbolic address arrays, or we may use more than one such state-
ment. The only condition is that the Dimension statement defining the 
extent of an array be made prior to the appearance of that array in the 
address list of an input or output statement. We have no such condition 
on the placement of Format statements. We note, however, that Format 
statements are numbered and referred to by number, while Dimension 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
289 
statements are not. We remark that we must specify numerically the maxi-
mum value of the subscript and cannot give instead the symbol for an 
address of a register whose content is this maximum value. Thus, in the 
Dimension statement we must have ALPHA (20) 
and cannot 
have 
ALPHA (MAX), where M A X is an address containing a value defining 
the maximum subscript. ALPHA (20) and ALPHA (MAX) would both 
be permissible, however, if they appeared in an address list furnished by 
an input or output statement. 
7-2.4. Input and Output Statements 
The specific statements we have defined above are for reference only. 
Of themselves, they do not cause any input or output to take place. This 
is reserved for the input and output statements. Such statements initiate 
input or output from a specified peripheral device, for data conforming to 
a specified format which is to be loaded into or taken from storage registers 
whose addresses are listed in the statement. In this section we define input 
and output statements for a computing system whose peripheral devices 
include a card reader and punch, magnetic tape handlers, and a line printer. 
The permissible input and output statements will vary from system to 
system depending on the complement of peripheral equipment present. 
The statements and their definitions are listed below. 
R E A D n, LIST 
This statement causes data to be read from 80 column cards, punched 
and arranged according to Format statement n, into the registers whose 
addresses are in the list. 
P U N C H n, LIST 
This statement causes data from registers, whose addresses are in the 
list, to be punched into 80 column cards in accordance with Format state-
ment n. 
R E A D I N P U T T A P E 
n, LIST 
This statement causes data to be read from a magnetic tape, prepared in 
accordance with Format statement η and mounted on tape unit t, into 
registers whose addresses are in the list. 
W R I T E OUTPUT T A P E t, n, LIST 
This statement causes data to be written, in accordance with Format 
statement n, on a magnetic tape mounted on tape unit t, from registers 
whose addresses are in the list. 

290 
7. 
INPUT-OUTPUT 
P R I N T ft, LIST 
This statement causes data from registers with addresses in the list to 
be printed by the line printer in accordance with Format statement ft. 
We also have statements to assist with the mechanics of dealing with 
magnetic tape, of which we give three examples. 
E N D F I L E t 
This statement causes an end of file mark to be written on the magnetic 
tape mounted on tape unit t. This indicates the end of the run for this 
tape unit. 
R E W I N D t 
This statement causes the magnetic tape mounted on tape unit t to be 
rewound to its initial point. 
BACKSPACE t 
This statement causes the magnetic tape mounted on tape unit t to be 
moved back one record, a unit of information. 
In many of the later versions of Fortran, the list of input and output 
statements has been altered to include only four (aside from the previous 
ones which are mostly retained). These are: 
R E A D (e, ft), LIST 
W R I T E (e, n), LIST 
R E A D (e), LIST 
W R I T E (e), LIST 
The function of these last four statements is the same as that of the listing 
above, except that all input statements are R E A D with the specific input 
equipment designated by the code e. In this way, R E A D (e, n) with the 
code e for the card reader is equivalent 
to READ, ft. Similarly, 
W R I T E (e, η), with the value of e equal to the code for the card punch 
is equivalent to P U N C H ft, while W R I T E (e, n) with a code e for the 
printer is the same as P R I N T ft. In the following examples we will use the 
statements given first, since they are more self-explanatory and the codes 
for equipment may vary. In all cases, we must remember that local usage 
and local compilers will have individual characteristics which differ and 
which should always be checked by the individual programmer. 
(See 
Appendix F for other variations.) 
If the list in any of the above input and output statements is empty, 
that is, if no list is stated, only Hollerith information will be read in or out. 

7-2. AN INPUT-OUTPUT 
LANGUAGE 
291 
In this case only the part of the Format statement up to the first field 
which is not an i7-field or X-field will be used. We recall that Hollerith 
information is stored in the Format statement itself and not in any register 
addressed by the list. 
The addresses in the list of an input or output statement must conform 
to the rules for symbolic addresses, and formation of a list is straightforward 
within these rules if no subscripted address symbols are used. Address 
arrays in lists may present difficulties, and we elaborate on some of these. 
We have two cases: (1) the name of the array is given without subscripts; 
(2) the name of the array is given with subscripts. 
If the name of the address array is given in the list without subscripts, 
then the name stands for all addresses in the array, in sequence, with sub-
script values running from the value of one to the highest value specified 
in the applicable 
Dimension 
statement. 
Frequently, the Dimension state-
ment will reserve storage for the maximum number to be expected in any 
case, but in the particular case at hand the actual order of the array is 
only n, where η is less than the maximum. Here we assume η is a parameter 
of the problem stored at symbolic address N. We recall that Ν cannot 
appear in the Dimension statement which must use the actual numerical 
value of the largest subscript value. If we state merely the name of the 
address array, too many addresses will be placed on the list. To avoid this, 
we introduce the subscripts and give their specific range. Thus, we might 
have the following statement: 
P R I N T 100, A, B, (VECT0R(I), I = 1, N) 
We assume that the value at address Ν has already been read in, and that 
Format statement 100 is appropriate. If the parameter η is not in storage 
we must give its value explicitly as in the following example: 
P R I N T 100, A, B, (VECT0R(I), I = 1, 20) 
We may place more than one array depending on the dummy subscript I 
in parentheses. For example we might have a combination such as the 
following: 
P R I N T 100, A, B, (VECT0R(I), HECT0R(I), 1 = 1, 20) 
The part of the list determined by the subscript must be enclosed in 
parentheses. Parentheses play a major role in defining the order of a sub-
scripted array within a list, and we must pay particular attention to the 
way in which they are used when we have more than one subscript. For 
two subscripts, the corresponding part of the list may assume a form such as 
((A(I, J ) , I = 1, 50), J = 1,50) 

292 
7. INPUT-OUTPUT 
and for three, a form such as the following: 
(((A(I, J, Κ ) , I = 1, 10), J = 1, 10), Κ = 1, 5) 
The rule for determining the order in which subscripts vary the fastest is 
"from the inside out." This corresponds to the order in which subscripts 
are varied when multidimensional arrays are transformed to linear arrays. 
Thus, the list given above for the two-dimensional array specifies input 
or output by columns. If we want the matrix A (I, J) to be read in or out 
by rows, we should put it in the list as 
((A(I, J ) , J = 1, 50), I = 1, 50) 
In either event the elements will be stored by columns as indicated 
previously. 
Example 7-26. We have a two-by-two matrix in storage with the element 
a,-y at address A (I, J ) . We assume that statement 10 is an appropriate 
F0RMAT statement. Then the statement 
P R I N T 10, ((A(I, J ) , I = 1, 2), J = 1, 2) 
would result in the printing, in order, of 
an, 021, ai2, a22 
That is, the first column followed by the second. The statement 
P R I N T 10, ((A(I, J ) , J = 1, 2), I = 1, 2) 
would print by rows in the form 
an, ai2, 021, 022 
Example 7-27. We have a three-dimensional array with the element 
a\j to be stored at address A (I, J, K ) . Each subscript takes values 1 and 
2. We again assume an appropriate F0RMAT statement number 10. The 
statement 
R E A D 10, (((A(I, J, K ) , J = 1, 2), Κ = 1, 2), I = 1, 2) 
would then read in eight elements which are interpreted to be, in order 
1
1
2
2
1
1
2
2 
an, 
ai2, 
an, 
a 12, 
Q>2i* 
#22, 
021, 
a^ 
On the other hand, the statement 
P R I N T 10, (((A(I, J, Κ ) , I = 1, 2), J = 1, 2), Κ = 1, 2) 
would print these elements in the order 
1
1
1
1
2
2
2
2 
a
i l i
 
a
2V
 
a
!2)
 
a
22*
 
α
11» 
#21. 
#12, 
#22 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
293 
This last sequence happens to correspond to the order in which the elements 
are stored, which is different from the order in which they were read in. 
Finally we may use fixed values of the subscript. Thus, the symbolic 
addresses VECTOR(5), A(2, 1), A(4, 3, 2) may appear in a list and be 
treated as single symbolic addresses. If the content of N N is established, 
we may write VECTOR (NN) in the list, and this is treated as a single 
address with the subscript assigned the value equal to the content of 
register N N . We may establish the content of N N in the same statement 
in which N N is used as an address as follows: 
R E A D 100, NN, VECTOR (NN) 
Thus, we see that the content of any symbolic address which precedes the 
current one in the list is available. 
7-2.5. Examples 
We close the discussion of the input-output language with two examples 
to illustrate how the various statements of the language are used in 
combination. 
Example 7-28. We wish to write a program for the solution of the system 
of η linear equations in η unknowns 
Σ,ΑνΧι 
= Bi 
(f = 1,2, 
. . . , n ) 
For each set of coefficients An, the program is to produce the solution for 
an arbitrary number of sets of right-hand terms. The number of different 
sets of coefficients, as well as the number of different right-hand sides for 
each such set, is to be specified as part of the input data. The input data 
are punched on cards in the following manner. 
1. The first three columns of the first card contain an integer k which 
specifies the number of different sets of coefficients An to be furnished. 
The remainder of the card is not used. 
2. The first ten columns of the second card contain Hollerith information 
to identify the coefficients An for the current case, and the first three 
columns of the next card give the current value of n. 
3. The fourth card and the following (n
2/4) — 1 or (n
2 — l ) / 4 cards, 
as the case may be, contain the coefficients An, punched four to a card in 
eighteen column 2?-fields with 9 digits to the right of the point. The leading 
eight columns of each card are used for a sequence number which is not 
part of the input data. 

294 
7. 
INPUT-OUTPUT 
4. The first three columns of the next card contain an integer m defining 
the number of decks of right-hand terms which follow. The remainder of 
the card is not used. 
5. There are m right-hand term decks which follow. Each deck of right-
hand terms starts with a card with an initial ten-column Hollerith field 
which identifies the current right-hand terms Bi} the remainder of this 
card being unused. The rest of the deck consists of the number of cards 
required for the JSt to be.punched in the same way as the An defined in (3). 
6. Cards such as those described in (2)-(5) are repeated for each of the 
k cases. 
The output is to take the following form: 
1. Two blank lines before the output in the first case and between the 
output data for all k — 1 succeeding cases. 
2. For each of the k cases, the first line consists of the identification of 
the coefficients A a and is followed by two blank lines. 
3. For all right-hand sides within each case, one line is printed for identi-
fication. 
This is followed by two blank lines and then by the column of 
answers. The answer column has a ten column margin and is to be com-
posed of F-fields, twelve characters wide, containing 9 digits to the right 
of the point. There are two blank lines between the last answer line and 
the identification for the next set of right-hand lines. 
We assume that for all k cases we have η < 100. 
We list first the necessary Dimension and Format statements. 
DIMENSI0N 4(100, 100), £(100), X(100) 
100 F0RMAT (73) 
200 F0RMAT (10# Λ Λ ΛΛΛΛΛΛΛΛ) 
300 F0RMAT (73, / , (8X, 4#18.9)) 
400 F0RMAT (8X, 4£18.9) 
500 F0RMAT (/) 
600 F0RMAT (10X, F12.9) 
The Dimension statement will cause the translator or assembly program 
to reserve storage space for the matrix A, one right-hand vector B, and 
the answer vector X. The number of registers reserved provides sufficient 
storage for the case of a matrix A of maximum order η = 100. Not all of 
these registers will necessarily be utilized in all cases. 

7-2. 
AN INPUT-OUTPUT LANGUAGE 
295 
Format statement 100 provides a reference for reading the cards con-
taining the values k and ra. Format statement 200 provides storage for 
the varying identifications as they are read in from cards. It also serves 
as a reference for the printing of these identifying headings. Format state-
ment 300 provides a reference for the input from cards of the integer η 
defining the current order of A as well as the matrix A itself. Format 
statement 400 provides a reference for the input from cards of the vector 
B. Statement 500 is to be used to provide spacing on output, and state-
ment 600 for reference when the column of answers is printed. 
The first input statement is 
R E A D 100, Κ 
which reads from the first card the three-digit integral value of k for this 
run and places it in a register to which the symbolic address Κ has been 
assigned. This statement is only executed once at the beginning of the 
input for the problem. 
The next input statements are the following: 
5 R E A D 200 
R E A D 300, N, ((A(I, J ) , I = 1, N ) , J = 1, N) 
Statement 5 reads the information identifying the coefficient matrix A 
into Format statement 200. It has been numbered for convenience of 
reference. The following statement causes the matrix A to be read into 
storage from cards. The value of η will have already been read from the 
preceding card into the register with symbolic address N. 
We must now provide for the initial two blank-line heading and the 
printing of the identification for the current matrix A. We use the following 
output statements. 
P R I N T 500 
P R I N T 200 
We now read in the integer ra defining the number of right-hand vectors 
Β to go with the current A. The statement 
R E A D 100, M 
reads the value ra into symbolic address M. 
All statements from 5 to the one just given are to be executed once for 
each matrix A, that is, a total of k times. Before each repetition, however, 
the statements which we give below are to be executed a total of ra times. 
We assume that appropriate loops, counting on the values k and ra which 
have been read in, have been set up. We show only input and output 
statements here. 

296 
7. 
INPUT-OUTPUT 
We now read in the identification and the values of the next vector Β 
with the following statements: 
10 R E A D 200 
R E A D 400, (B(I), I = 1, N) 
We assume that at this point we have a program which solves 
AX 
= Β 
and places the result at symbolic address region X, without changing the 
coefficients of the matrix A. We are now ready for output which we accom-
plish by the following statements: 
P R I N T 500 
P R I N T 200 
P R I N T 500 
P R I N T 600 ( X ( I ) , I = 1, N) 
If the number of right-hand sides m is not exhausted, we go back to 
statement 10 and repeat. If it is exhausted, we test k. If the number of 
matrices A is exhausted, we stop; if not, we go back to statement 5 and 
repeat. 
Example 7-29. We wish to solve a first-order differential equation 
for ni different sets of initial conditions (xo, yo). The input information is 
punched in a deck of nx + 1 cards. The first card contains the integer n\ 
in columns 1-5. The remaining n\ cards each contain an initial point 
(zo, yo), the value of the integration'step k, and an integer n 2 which specifies 
the total number of integration steps. We punch x0, y0, and k in columns 
1-10, columns 21-30 and columns 31-40, respectively. The three numbers 
xo, yo, and k are punched into F-fields with 6 digits to the right of the 
point. The integer n 2 is punched in columns 41-45. The output is to the 
line printer and is to be listed for each case under the headings X, Y, 
D Y / D X . There are to be three initial blank lines as well as three blank 
lines following the output data for each different case. There is to be one 
blank line between the heading information and the first line of output 
data. All output numbers are to be in 2£-fields of width 20 with nine places 
to the right of the point. 
We place the following Format statements for reference at the beginning 
of the program: 

7-2. AN INPUT-OUTPUT LANGUAGE 
297 
100 F 0 R M A T (15) 
200 F 0 R M A T (3F10.6, 15) 
300 F 0 R M A T ( / / / , 39X, 1HX, 19X, 1HY, 17X, 5 H D Y / D X , / ) 
400 F 0 R M A T (30X, 3E20.9) 
Format statement 100 will be referred to on reading the card containing 
ni. Statement 200 serves as a reference in reading in an initial condition, 
and statement 300 serves for spacing and printing output headings. 
Format statement 400 is used for the output of data to the line printer. 
The input and output statements follow. The first one 
R E A D 100, N l 
reads the integer rii from the first card of the input deck into the register 
with symbolic address N l . The value ηχ can now be used to control a loop 
which determines the number of different cases for the current computer 
run. This Read statement need only be executed once. 
The input statement 
5 R E A D 200, Χ, Y, H, N2 
causes the initial information to be read in from the next card in the 
hopper. The statement is numbered for later reference. We note that the 
symbolic address X is permissible for a register containing floating point 
data since the name has only one character. 
We now space down three lines, provide the required headings on the 
fourth line, space after the headings, and print the initial conditions as 
the first line of output with the following statements. 
P R I N T 300 
P R I N T 400, X, Y, D Y D X 
We assume that the derivative has been computed and assigned a storage 
location with symbolic address D Y D X . 
We now can advance the integration to the next point and succeeding 
points. As each new set of values of x, y, and dy/dx is computed, we print 
them by repeating the following statement. 
P R I N T 400, X, Y, D Y D X 
At the end of the integration the program will check to see if n\ cases 
have been computed. If not, the program will return to input statement 5. 
Otherwise it will halt. 

298 
7. 
INPUT-OUTPUT 
Exercises 
Section 7-1 
1. 
Write a sequence of instructions which will read in sixty-four words of 
forty-eight bit length punched in the octal code of Examples 7-0 and 
7-1, and store them in a set of consecutively addressed registers. 
2. Write a sequence of instructions, using the character mode, to make 
the on-line typewriter print: CDC 1604. Assume storage of any neces-
sary parameters. 
3. 
Redo Problem 2 to punch the codes on paper tape for later printing 
on an off-line typewriter, coded according to the first flex code in 
Appendix C. 
4. 
Redo Problem 2 using the typewriter in the assembly mode. 
5. 
Write a sequence of instructions which will punch the content of a 
register in the octal code of Problem 1. 
6. 
Write a sequence of instructions which will punch the sixteen octal 
digits of the content of a register in flex code. 
7. 
Write a sequence of instructions which will cause the on-line type-
writer to print the content of a register in decimal. Assume that the 
content represents an unsealed integer. Be sure to provide for a proper 
version of a negative number. 
8. 
Repeat Problem 7 and include instructions which will provide for 
suppression of leading zeros. 
Section 7-1.0 
9. 
Give a completely edited version of the tape input program. 
10. Modify the tape input program so that it will accept decimal integers 
in flex code and store them in a block of sequentially addressed registers. 
Section 7-1.1 
11. Give a completely edited version of the tape output program. 
12. Modify the tape output program so that it will punch in flex code the 
decimal digits of the content of a block of sequentially addressed 
registers. Provide the sign and absolute value for negative numbers. 

EXERCISES 
299 
13. Repeat Problem 12 with the integers considered as scaled with a 
known (common) scale factor. Provide the properly placed decimal 
point. 
Section 7-2.0 
14. Which of the following are admissible decimal integers? 
(a) +123456 
(b) 123456 
(c) ±123456 
(d) -123456 
(e) 3 X 10
5 
(f) 
30,000 
(g) $297 
15. A binary, one's complement, machine has twelve bits to a register. 
For conversion and storage in such a machine, which of the following 
is an acceptable decimal integer? 
(a) 
1234 
(b) 
- 3 1 4 1 
(c) - 2 1 2 
(d) 
+2048 
16. Which of the following are admissible fixed point decimal numbers? 
(a) 1234.5 
(b) 123456. 
(c) 123456 
(d) -0.012 
(e) $2.98 
(f) 
3.1416(P7) 
17. Recalling that the fixed point decimal number is converted to a floating 
point word in the computer, find, for the C D C 1604, the proper internal 
version of each of the following: 
(a) 32.5 
(b) 
- 1 1 2 7 . 
(c) 0.05 
(d) 
-0.000625 
18. Which of the following are admissible floating point decimal numbers? 
(a) 123456502 
(b) 123.45653 
(c) 314159. X 10-
5 
(d) - 2 7 1 8 2 8 5 - 
5 
(e) + 1 2 . 3 4 5 5 - 
10 
(f) 
- 1 2 . 3 4 5 5 + 10 
19. For the CDC 1604, find the internal version of each of the following 
point decimal numbers. 
(a) 0.032554 
(b) 
- 1 1 2 7 . 5 0 
(c) 5005 - 5 
(d) - 6 . 2 5 5 - 
6 
20. What kinds of fields are described by each of the following? 
(a) 6X 
(d) 511.1 
(b) 7710 
(e) 
7H 
(c) 259.4 
(f) 
016 

300 
7. INPUT-OUTPUT 
21. What is wrong with each of the following field descriptions? 
(a) X15 
(b) 7110.2 
(c) 3F8.12 
(d) 2029. 
Section 7-2.1 
22. What does each of the following F 0 R M A T statements describe? 
Relate each to as many different input-output media as you can. 
(a) 10 F 0 R M A T (5X, 2F8.2, E10.4) 
(b) 13 F 0 R M A T (02, IX, 0 5 , 2X, 02, IX, 05) 
(c) 200 F 0 R M A T ( 9 H P R 0 B L E M 3 A, 12, 4F10.5) 
23. Write a format statement to describe the information on an eighty 
column card in which columns 1-5 contain a decimal integer, columns 
6-35 contain three fields of equal size each with a fixed point decimal 
number with four digits to the right of the point, columns 36-45 are 
blank, columns 46-61 contain the statement W I N D T U N N E L DATA, 
and the remaining columns are not used. 
24. What are the effects of the following F 0 R M A T statements? Relate 
each one to as many different input-output media as you can. 
(a) F 0 R M A T (2X, 16, 3F4.2, /, 10E7.1, 6HFINISH) 
(b) F 0 R M A T (3/, 4020, /, 5E10.2) 
(c) F 0 R M A T (4F12.6, 2111, 10/) 
25. For the following F 0 R M A T statements determine the kinds of fields 
involved and the sequence in which they will be matched with the list 
of an input-output statement. 
100 F 0 R M A T (15, 4(317.5), 04) 
200 F 0 R M A T (/, 3X, 10(E10.3), /, 17.4/) 
10 F 0 R M A T (15, /, (3F7.5), 04) 
20 F 0 R M A T (3X, /, (217, 4E9.2)) 
Section 7-2.2 
26. Which of the following are permissible symbolic addresses for integers? 
(a) J A C K P 0 T 
(b) CASH 
(c) LUNA4 
(d) K 0 0 R D I N A T E 
(e) 4LUNA 
(f) 
LINE10 
(g) J U M P 3 F T 

EXERCISES 
301 
27. Which of the following are permissible addresses for floating point 
numbers? 
Section 7-2.3 
28. A fifteen by fifteen matrix with elements m»y is to be stored. We desig-
nate the symbolic address by M A T R I X (I, J ) . What kind of numbers 
must the elements be? Give the specific address for each of the elements 
m23 and 
m^. 
29. A vector with one hundred components st- represents a set of data in a 
statistical problem and is stored in registers with symbolic address 
STAT (I). What kinds of numbers comprise its components? Where 
are the components s3, $20 and s 8i stored? 
30. Write a D I M E N S I 0 N statement to describe the matrix in Problem 
28 and the vector in Problem 29. 
31. Determine the kind of information stored in addresses 
BYPASS (I, J, K ) , LUNA2(I), F L Y ( M , N) 
if the following D I M E N S I 0 N statement has been made. 
D I M E N S I 0 N BYPASS (10, 10, 15), LUNA2(30), FLY(20, 20) 
32. A set of 1000 fixed point decimal numbers is to be stored in consecutive 
locations. Devise permissible symbolic addresses for the array and 
provide an appropriate D I M E N S I 0 N statement. 
33. Determine the significance of the following statements and the kind 
of data involved. 
D I M E N S I 0 N MARV(10), BILL (20, 20), J U P I T E R (4, 5, 6) 
Section 7-2.4 
34. Determine the effect in a single program of the following combinations. 
In all cases determine the kinds of data produced. How many absolute 
addresses are involved? 
(a) CASH 
(d) A I R C 0 R 2 
(g) CHECKS 
(b) 
X C 0 0 R D 
(e) 
NAVY2 
(c) 
Y C 0 0 R D 
(f) 
C H E K 0 U T 
(a) 
D I M E N S I 0 N MARS (20) 
R E A D 100 (MARS(I), 1 = 1, 15) 
100 F 0 R M A T (15) 

302 
7. 
INPUT-OUTPUT 
(b) 
W R I T E 0UTPUT T A P E 3, 99, (GAMMA(Ν) , # = 1,6) 
99 F0RMAT (6E15.7) 
3 5 . Determine what output will result if each of the following combina-
tions is used in a program. 
(a) 
D I M E N S I O N A (150, 150), Ν (10) 
P U N C H 100, N, ( ( A i l , J ) , I = 1, 100), J = 1, 100) 
100 F0RMAT (/, 1018, / , (8F10.5)) 
(b) 
D I M E N S I O N ALPHA(5, 4, 3) 
P R I N T 13, C0SMIC, M E R C U R Y , (((ALPHA(I, J, K ) , 
I = 1, 3), Κ = 1, 2), J = 1, 4) 
13 F0RMAT (2X, F9.4, /, 16, /, (3(E12.6, 4X), / ) ) 

CHAPTER 8 
Assembly of Complete 
Programs 
8-0. Introduction 
In Chapter 6 we considered the possibility of having the computer as-
sist in the assembly of a program. We introduced a simple program, 
SURAP, which is useful in assembling and assigning to storage programs 
composed of items of coding, such as subroutines, which conform to a 
fairly restricted, assembly-modifiable format. A program such as SURAP 
makes a valuable contribution by permitting us to postpone storage de-
cisions which depend on the final form of a code and also by permitting us 
to keep items of coding on hand in a library to allow their inclusion in 
many different programs. SURAP, however, provides the coder with just 
two address classes, the relative addresses (with only one origin) and all 
other addresses; and only relative addresses can be assigned by the as-
sembly program. While many short programs and subroutines will naturally 
fall into such a classification, longer programs will not. A long program can 
perhaps be handled by an assembler such as SURAP if it is segmented 
into a number of shorter program items. This causes difficulty, however, 
since the format requirements dictate that no one segment of the program 
contain addresses which refer to any other segment and which thus depend 
on the eventual location of that segment. That is, every address in each 
segment must be an absolute address or a relative address in that segment 
alone. In addition, the absolute addresses of one segment may overlap 
those of another segment, causing further difficulty. 
We see that the SURAP assembly program provides no straightforward 
means of communication between the items of coding to be assembled into 
a program. Thus, it will often prove to be unsatisfactory, since many 
programs naturally consist of a number of parts among which free com-
303 

304 
8. ASSEMBLY OF COMPLETE PROGRAMS 
munication is essential. For this reason there will usually be available for 
the coder a more sophisticated assembly routine which will put together 
and assign to appropriate storage, programs composed of codes both 
written for the occasion and taken from the library. The assembler permits 
them to refer to each other freely. 
The actual writing of an advanced assembly program is the job of an 
experienced coder. Assemblers are frequently the combined work of many 
people and are continually undergoing change and improvement. For this 
reason, we shall make no attempt to describe the detailed coding of as-
sembly routines or to give examples of such codes. We shall confine our-
selves to what these programs do and to their use, although we point out 
some of the considerations which their authors must keep in mind. 
The most straightforward kind of assembly program after one such as 
SURAP is the regional assembly program. This kind of program assumes 
that a certain number of consecutively addressed registers have been set 
aside and designated as storage regions. This is precisely the same concept 
as the relative address introduced in Chapter 3. That is, each relative 
address origin such as a0 specifies a storage region consisting of all registers 
with consecutive addresses α», i = 0, · · ·, n. Thus, the specification to an 
assembly program of the designated origin of a particular region will make 
the assignment of all other addresses in the region automatic. The number 
of regions and the number of registers in each region will vary from program 
to program and the assembler must be able to accommodate this. The 
SURAP program, for example, is designed to handle only one region, and 
we see that the regional program is a simple generalization of the SURAP 
idea. 
Many assembly programs which go beyond the regional in their ca-
pabilities often prepare an intermediate version, in regional form, of the 
programs they are putting together. This intermediate version can be 
easily relocated in storage or kept as a library program for combination 
with other programs also assembled in this way. Thus, a regional assembly 
program may function as an integral part of a much more sophisticated 
and versatile system. For this reason we will discuss regional assembly at 
some length in the following section. We will then indicate possible exten-
sions of this idea and close the chapter with a discussion of an assembly 
program which permits the use of the input-output language of Chapter 7 
and the symbolic addresses introduced there. 
8-1. Regional Assembly Techniques 
We have pointed out that the skeletal structure of a regional assembly 
program is based on the division of the available storage registers into 

8-1. 
REGIONAL ASSEMBLY TECHNIQUES 
305 
storage regions, each of which consists of consecutively addressed registers 
starting with an initial one whose address is called the origin. The number 
of regions, the number of registers in a region, and the actual addresses of 
these registers need not be determined by the coder in advance. For the 
moment we can think of regions as being given by the relative address 
notation of the preceding chapters. That is, each region has a tag such as 
α, β, or 7 which is nonnumerical. A specific address of the α-region then 
becomes α» or the ith address of the region, with a 0 representing the origin. 
Once an assembler has been provided with the origin values of all designated 
regions in a particular program, it can easily assign the proper value to 
all relative addresses in the program. It merely replaces each relative 
address with the machine address obtained by adding its subscript to the 
proper origin value. Once the coder has completed the code in regional 
form, he can readily determine the number of regions used and the number 
of registers in each region, and so select appropriate origins. 
The SURAP type of assembly program employs a format which gives 
the region tag in numerical form. Thus, it can be used in conjunction with 
an input routine as simple as the paper tape program discussed in Section 
7-1.0. A regional assembly program, however, must be provided with an 
input program which can bring in the nonnumerical region designations. 
This input routine will, in addition, generally load program parameters 
and problem data. Such information can ordinarily be given in absolute 
machine form, in decimal, or in both, and with a variety of formats, de-
pending on the particular assembly program. Because of the diversity of 
information which the assembler must accept, it will also require the coder 
to give it certain specific instructions which are for its own use and not a 
part of the program under assembly. The coder will thus be provided with 
a set of pseudo-instructions 
which will consist of alphabetical and numerical 
combinations to be interpreted by the assembly program as instructions 
to itself. For example, the coder must inform the regional assembly pro-
gram as to the absolute address assigned to the origin of each region. He 
will ordinarily do this by prefacing the input to the assembly program 
with the appropriate pseudo-instructions. Thus, the input to the regional 
assembly program will consist of instructions in which both absolute and 
relative addresses are employed, program parameters, data in either ab-
solute machine notation or in decimal, and instructions to the assembly 
program itself. All of this information must be presented in some predeter-
mined form. The regional assembly program will then convert this input 
into an absolute machine program in operating storage. The assembly 
program may also perform other services for the coder, such as providing 
him with a listing of the absolute program, or a version of it on magnetic 
tape, or punched cards suitable for reloading. It may also perform such 

306 
8. ASSEMBLY OF COMPLETE PROGRAMS 
services as checking for illegal operation codes and addresses and other 
obvious coding errors, and deviations from the format required by the 
assembly routine. 
From our earlier examples of coding we have seen that the storage 
registers used in a program can be grouped so that they depend on the 
particular nature of the words contained in each group. One group will con-
tain the instructions in the program, and this set may well be subdivided 
into smaller segments which depend on the various functions that the in-
structions perform. In addition, there will be other register sets containing 
such items as program parameters, temporary data, library subroutines, 
alarm routines, and operands. Each such group, assigned to some common 
purpose, will correspond to a specific storage region. That is, in writing a 
program, we will naturally classify words as to function, and the assembler 
can then accept this in terms of a regional classification. Only to a limited 
extent does the assembler need to be told the function of the region (for 
example, to distinguish the treatment of a region of program parameters 
given in decimal from that of a region of parameters given in octal). 
Example 8-0. We note that the code of Example 4-42 has been written 
in regional format with the α-region assigned to the instructions, the jo-
region to the storage of temporary data, the δ-region to the storage of 
program constants, and the ω-region to the storage of the results. From 
the program in the form given in Example 4-42, it is a simple matter to 
note that the α-region contains thirteen registers, the ß-region four registers, 
and the δ-region six registers. Thus, if the coder decides to start the program 
at address 10000 and to store data immediately following the program, he 
can assign origins as in the accompanying tabulation. 
Region 
Origin 
a 
10000 
δ 
10015 
β 
10023 
ω 
10027 
Once we give the regional assembly program this table of origins and 
the code, it is able to assemble an absolute machine language program in 
one sweep over the input data. That is to say, it can convert any given 
regional instruction to absolute machine form and provide for storing the 
instruction in the correct location using only the table of origins. None of 
the items preceding or following a particular instruction will be needed. 

8-1. 
REGIONAL ASSEMBLY TECHNIQUES 
307 
For example, given 
a 6 II 
30 
0 
δ2 
20 
0 
ßz I 
from the code, the assembly program can immediately convert this to 
30 
0 
10017 
20 
0 
10026 and provide for its storage in register 
10006 without making reference to any other part of the regional code. 
For this reason it is often called a one-pass assembly program. 
In the example just presented, the subscripts denoting the position within 
the region were given in the octal number system. This is not essential, 
and the assembly program could have permitted decimal notation for the 
subscripts. We must, however, conform to the notations and formats 
which are permitted by the particular assembly program we use. Thus, 
the actual symbols which we use as tags for various regions will be dictated 
by this program. In turn, the format requirements will be determined to 
some extent by the available symbols on the equipment used to prepare 
input media. Hence, we are more likely to use the tag ALPHA than the 
symbol a and ALPHA3 in place of az. The use of names rather than single 
symbols for regions can, however, be helpful to the coder in remembering 
the function of a given region, and the wise programmer will exploit this 
feature by a judicious choice of regional tags. As a further aid, the assembly 
program and its related input routines may be written to accept mnemonic 
alphabetic codes for the operations. Thus, programs written for an as-
sembler will probably have a very different appearance from the earlier 
absolute codes we considered; however, the ultimate program executed by 
the computer will be in the strict digital forms of these codes. Finally, we 
must remember that the program is designed to work within its own 
structure and can be helpful to us only to the extent that we know and 
conform to the restrictions this structure imposes. 
The availability of a regional assembly program need not eliminate the 
subroutine type of assembly program. The two programs can complement 
each other. When we wish to include a subroutine in a code being prepared 
in regional form, we can simply designate a separate storage region for 
the subroutine and insert the proper regional form of a return jump. For 
example, assume that the 7-region has been assigned to a subroutine and 
that the entry point is known to be at the first word. The regional form of 
a jump entering this subroutine might then be 75 
4 
7 0 . After laying 
out storage, the coder will supply the origin value of γ 0 to the regional as-
sembly program which will then convert all main program references to 
the subroutine to proper absolute form. He will also specify 7 0 to the sub-
routine assembly program as the address in which the first instruction of 
the subroutine will operate. The subroutine assembly program will then 
provide a copy of the subroutine in a form suitable for use with the re-

308 
8. ASSEMBLY OF COMPLETE PROGRAMS 
gionally written main program. The finally assembled machine version of 
the program will then consist of the joint output of the two assembly 
programs. If, as is likely, the subroutine assembly program operates as a 
part of, and under control of, the regional assembly program, the coder 
will supply an appropriate pseudo-instruction identifying the subroutine 
and defining the value of 7 0 . 
A little reflection will tell us that complete regional addressing is not 
sufficient. For one thing, although we have had assignment of addresses, 
as such, primarily in mind, we must remember that the address portion of 
an instruction word is not always used as an address. It may be used 
instead to specify a number such as a shift count, or, in some machines, a 
direct arithmetic operand. In such situations the regional concept will not 
be pertinent to the assignment of address portions of instruction words. 
Thus, unless the coder is to do a great deal of preparatory work or give an 
unduly large number of pseudo-instructions to the assembly program itself, 
an assembly routine should be capable of recognizing and handling classes 
of addresses other than regional. Even in a simple assembler such as 
SURAP we are allowed two classes of addresses, a single regional class and 
all absolute addresses. For shift instructions and other instructions where 
addresses are used as operands, special provision can be made in regional 
assembly programs to permit various types of numerical designation, in-
cluding use of decimal and negative numbers. For instance an instruction 
of the form "left shift in A ( —10) " might be interpreted as a circular right 
shift of ten. This can be handled without sacrificing the feature of a single-
pass over the data which the regional program permits. 
8-2. Variations on the Assembly Theme 
In preceding sections we have seen that the concept of regional coding 
can form the basis for the structure of an assembly program. The idea is 
similar to that of the relative address symbolism used in Chapter 3. The 
fundamental assumption is that any program will contain a certain number 
of blocks of words to be stored in consecutively addressed registers or 
regions. Thus, a program can be divided functionally into regions each of 
which serves a specific program purpose. The use of regional address 
symbols permits words in any region to refer to words in any other region. 
One of the main advantages of the scheme lies in the fact that once an 
absolute address is assigned to the origin of a region, all other addresses in 
that region are also determined. This permits the assembly routine to 
assemble the program in a single pass over the data submitted to it by the 
coder. 

8-2. 
VARIATIONS ON THE ASSEMBLY THEME 
309 
If we give up the single-pass feature of the assembly program and, at the 
cost of machine time, permit it two or more passes over the data, we can 
shift even more of the coder's burden to the machine. For instance, in 
Example 8-0, the origins of regions were assigned by the coder; however, 
a preliminary pass over the data would permit the assembly program itself 
to determine the number of regions and the number of words in each region, 
and, hence, to assign the regional origins. Then all that the coder may have 
left to do is to assign the initial address for the entire program. In many 
cases, this too will be left to the assembly program. 
In the regional code of Example 8-0, each word of the program was 
tagged in the margin with its regional address. Thus each tagged word 
could be assembled and placed in storage without reference to any other 
word in the code; and so the order of the scanning of the data is not ma-
terial. We ordinarily, however, present the information for a region in the 
correct order for storage in that region; and if we do, we may dispense with 
most of the marginal tags, tagging only the word at the origin of the region. 
If, in addition, we are willing to give up the one-pass feature of the assembly 
program, we can effect an even greater convenience. We need tag only the 
origin word and those other words which will be referred to directly by 
instructions in the program or which, for one reason or another, we find 
it convenient to label. Then, on a preliminary pass over the data, the 
assembly program can count to the position of any tagged word relative 
to the origin, making up in the process a table of tags and corresponding 
addresses. With a subsequent pass over the data, any tag appearing in an 
address position of a word can be replaced by the corresponding address 
from the table. In such a process we need not restrict ourselves to regional 
address notation in defining tags. 
Example 8-1. In the course of writing a code we find it necessary to 
store a variable V which is to be referred to by address in subsequent 
instructions. We might write 
20 0 L0CV 
In later instructions using the value V, we use L0CV for the address part. 
When we can conveniently decide on a register for holding V, we merely 
tag it as L0CV. This gives us direct use of "location-of" address notation. 
Example 8-2. At a point in a program which we are writing we must 
introduce a sign jump; however, the exact location of the instruction to 
jump to is still indeterminate. We might use 
23 
2 P0S 
This is an instruction to j u m p to the address P0S if (A) 
> 0. We now 

310 
8. ASSEMBLY OF COMPLETE PROGRAMS 
continue writing the code; and on determining the point to which the jump 
should be made, we tag it with the name P0S. 
The technique of tagging only addresses to which reference will be 
made permits the insertion of new words freely at any point of a program. 
This makes it easy to incorporate corrections. This simplicity is not avail-
able in a regional program, since the insertion of a new word will change 
the relative addresses of all words in the region which follow the inserted 
word. Thus, all references to the words which follow must be modified. 
The assembly program, in addition to permitting the use of tags as 
addresses, may also permit some simple functions of tags. The most straight-
forward function is the tag plus or minus a constant. For example, 
L0CV + 7, 
or perhaps, the sums and differences of tags may also be allowed, such as 
L0CV - L0CW + 1. 
The introduction of addresses which are functions of tags makes it more 
difficult to make changes freely, since the insertion of a word may change 
the values of these functions adversely. Such functions, however, can 
easily be evaluated on a subsequent pass over the data, from the table of 
tags and corresponding addresses obtained in the first pass. 
We often find occasion to refer to an address relative to the location in 
storage of the current instruction we are writing. For example, we are 
writing a conditional jump instruction and wish either to continue in se-
quence or to jump over the next five words. We may write 
23 
2 
L + 6 
where L stands for the eventual location of the jump instruction. Thus, 
L + 6 stands for an address six greater than that of the instruction in 
which the symbol L + 6 appears. We need not tag the jump instruction 
with the symbol L. The assembly program will always have the value of 
L and so can easily evaluate an expression such as L + p, where ρ is an 
integer specifying the number of registers forward or backward from the 
instruction at L. Such address symbols can be used in a one-pass assembly 
program but are not particularly pertinent in a regional program. We see 
that their use increases the difficulty of inserting new words freely in a 
program. 
The assembly program, no matter what kind of address symbolism it 
permits, should provide the coder with a means of making a unified whole 
out of pieces of coding which have been independently coded. The items 
may be taken from some form of program library or may be coded espe-
cially for the current program. In Section 8-3.4, we will illustrate the use 

8-2. 
VARIATIONS ON THE ASSEMBLY THEME 
311 
of an assembly program to combine separately written pieces. Here we 
will confine ourselves to pointing out that the assembly program will gen-
erally be provided with a number of pseudo-instructions, 
some of which 
will be for the purpose of easing the burden of putting together various 
program items into a single program. The pseudo-instructions associated 
with a particular assembly program are similar to the interpretive instruc-
tions discussed in Chapter 6. That is, the acceptable symbols for these in-
structions will be interpreted by the assembly program as instructions to 
itself. Typically, pseudo-instructions may be used to (1) declare that tags 
and addresses which have the same symbols are different, (2) declare that 
tags and addresses with different symbols are the same, (3) modify all 
tags and addresses in a specified program segment, or (4) assign values to 
parameter symbols which may appear in addresses in conjunction with 
tags. Pseudo-instructions may be used to call out library subroutines and 
to specify linkages between various segments of a program in connection 
with input and output. 
A good assembly program, if properly used, will materially decrease the 
labor of coding and error checking. It will also provide considerably greater 
flexibility in the way in which we can write and put together our programs. 
At the same time, we must remember that this increased flexibility in no 
way decreases the attention which we must give to the details of format 
imposed by the particular assembler. In fact, even greater care may be 
required, since such simple marks as periods and commas can have a very 
specialized significance, and hence, a clerical error or blunder in this respect 
can have just as adverse an effect as in an absolute machine language 
program. 
8-2.0. An Example 
In order to illustrate some of the ideas just discussed we give an example 
of the straightforward use of an assembly program and the way in which it 
converts a routine into absolute machine language. We make use of CODAP 
(Control Data Assembly Program). In this section we consider only the 
relatively simple ramifications of this routine. A description of CODAP 
sufficient for this purpose is given in Appendix D. We suggest that the 
reader consult it before proceeding with the example. A complete descrip-
tion is available in the manufacturer's literature. 
The structure of a program to be written for assembly by CODAP is 
closely patterned after our earlier machine language programs; that is, 
each program step will consist of an identifier for its storage location 
(LOCN term) and two instructions, each with the following structure: 
(1) an operation (OPN) code term which may be a three or six letter 
mnemonic or an octal operation code; (2) a designator (or b) term which 

312 
8. ASSEMBLY OF COMPLETE PROGRAMS 
may contain a single octal digit, a single letter, or be blank; (3) an address 
(or m) term which may be a number, a parameter, a symbolic address, or 
a symbolic address plus or minus a constant. Constant values in an ra 
term may be decimal integers not exceeding 32,767 in magnitude, or octal 
integers (identified by a Β following the digits) not above 77777 in magni-
tude. In pseudo-instructions (see Appendix F) the ra term is a parameter. 
The LOCN term is used as either a regional or specialized address 
identifier and consists of alphabetical and numerical characters to a maxi-
mum of eight. A particular identifier can be referred to in ra terms as neces-
sary, but it can be used only once as a location term. 
In addition to the instruction components, CODAP permits the inclusion 
of editorial remarks. We illustrate the use of CODAP and the assembled 
form of the resulting absolute program in two examples. In the first we 
consider a short program which is to be assembled as a part of a larger 
program. It is designed to accept a decimal integer typed at the on-line 
typewriter and enter it into A in binary form. No check is made for over-
flow, and the program ignores all characters except carriage return, minus, 
period, and decimal digits. 
Example 8-3. As a part of a larger program, we wish to write a short 
routine to accept a decimal integer typed on the on-line typewriter and 
put it into A in proper binary form. Since we wish to use the routine more 
than once, we write it as a little subroutine within the main program. We 
find that the instructions fall naturally into five sets according to the 
following functions: (1) exit-entry together with saving index registers 
and setting up the terminal buffer; (2) selection and preparation of key-
board entry; (3) checking of the entering codes for decimal digits and 
algebraic sign and proper entering of the number into A) (4) handling the 
case of a negative number; and (5) checking for ignored codes and con-
version of decimal digits to binary form. We present the program as written 
using mnemonic three-letter designations for operation codes as well as 
pseudoinstructions. 
LOCN term 
OPN term b term 
m term 
Remarks 
ENTRDINT 
SLJ 
SIU 
1 
77777B 
EDIB12IM 
EXIT 
STORE INDEX 
REGISTERS 
SIL 
ENA 
2 
EDIB12IM 
EDIBUFFR + 1 
SET UP TERMINAL 
ADDRESS 
STA 
EXF 
1 
11100B 

8-2. 
VARIATIONS ON ,ΤΗΕ ASSEMBLY THEME 
313 
LOCN term 
OPN term b term 
m term 
Remarks 
ENTDINT1 
EXF 
EXF 
1 
1 
EDIBUFFR + 1 
EDIBUFFR 
KEYBOARD ENTRY 
ENA 
STA 
0 
EDIDINT 
CLEAR DECIMAL 
INTEGER CELL 
ENI 
ENI 
2 
1 
1000B 
10 
SET SIGN SWITCH PLUS 
ENTDINT2 
EXF 
SLJ 
7 
11101B 
ENTDINT1 
SET SEARCH INDEX 
FOR DECIMAL DIGITS 
WAIT ON CHANNEL 1 
EXF 
S U 
7 
IIB 
. - 1 
EXIT ON NO CR 
START OVER 
LDA 
EXF 
1 
EDIBUFFR 
EDIBUFFR 
EQS 
SLJ 
EDIPERCD 
ENTDINT3 
IS FLEXCODE A PERIOD 
NO 
LDA 
LIU 
1 
EDIDINT 
EDIB12IM 
YES, DECIMAL 
INTEGER TO A 
RESTORE INDEX 
REGISTERS 
U P 
SCM 
2 
• + 1 
EDINEGZR 
COMPLEMENT A, IF 
NEGATIVE 
LIL 
S U 
2 
EDIB12IM 
ENTRDINT 
ENTDINT3 
EQS 
S U 
EDIMINCD 
ENTDINT4 
IS FLEXCODE A MINUS 
NO 
ENI 
S U 
2 
0 
ENTDINT5 
YES, SET SIGN SWITCH 
TO MINUS 
ENTDINT4 
EQS 
S U 
1 
EDIDIGCD 
ENTDINT2 
IS FLEXCODE A 
DECIMAL DIGIT 
NO, READ ANOTHER 
CODE 
ENA 
MUI 
10 
EDIDINT 
INA 
STA 
1 
0 
EDIDINT 
MULTIPLY DIGIT BY 
10 ADD DIGIT 

314 
8. ASSEMBLY OF COMPLETE PROGRAMS 
LOCN term 
OPN term b term 
m term 
Remarks 
ENTDINT5 
ENI 
SLJ 
1 
10 
ENTDINT2 
EDIBUFFR 
BSS 
1 
EDIDINT 
BSS 
1 
EDIB12IM 
BSS 
1 
EDINEGZR 
OCT 
7777777777777777 
EDIPERCD 
OCT 
42 
PERIOD CODE 
EDIMINCD 
OCT 
52 
MINUS SIGN CODE 
EDIDIGCD 
OCT 
56 
DIGITAL CODES 
OCT 
74 
OCT 
70 
OCT 
64 
OCT 
62 
OCT 
66 
OCT 
72 
OCT 
60 
OCT 
33 
OCT 
37 
The mnemonic devices used in Example 8-3 are more or less self-
explanatory. For example, the base address E N T R D I N T refers to "enter, 
decimal integer.'' The final Β after a sequence of digits defines it as octal. 
All code symbols are standard three-letter codes as given in Appendix A 
except for the pseudocodes BSS and OCT (see Appendix F ) . The code 
BSS is a pseudocode to reserve a block of storage, while the OCT code 
indicates simply that what follows is an octal value. The asterisk is a 
symbol for the location of the current instruction. Thus we have used, as 
intelligible to the assembly program: 
(1) Regional addresses, for example E N T D I N T , E N T D I N T 2 
(2) Location of addresses, for example EDIB12IM 
(3) Address references relative to the current instruction, for example 
* + 1 
(4) Addresses to be filled by computer, for example 77777B 
(5) Constant address values in decimal, for example 10 (ten) 

8-2. 
VARIATIONS ON THE ASSEMBLY THEME 
315 
The way in which the various kinds of addresses are treated by CODAP 
becomes apparent in the next example. 
Example 8-4. The assembled version of the subroutine of Example 8-3 
was obtained as a part of a larger program in which CODAP assigned the 
address 47540 to the entry point E N T R D I N T . The assembled version is 
on the right, with the original version on the left. 
INPUT TO CODAP 
ASSEMBLED PROGRAM 
ENTRDINT 
SLJ 
SIU 
1 
77777B 
EDIB12IM 
47540 
75 0 77777 
56 1 47565 
SIL 
ENA 
2 
EDIB12IM 
EDIBUFFR + 1 
47541 
57 2 47565 
10 0 47564 
STA 
EXF 
1 
11100B 
47542 
20 0 00001 
74 0 11100 
ENTDINT1 
EXF 
EXF 
1 
1 
EDIBUFFR + 1 
EDIBUFFR 
47543 
74 1 47564 
74 1 47563 
ENA 
STA 
0 
EDIDINT 
47544 
10 0 00000 
20 0 47564 
ENI 
ENI 
2 
1 
1000B 
10 
47545 
50 2 01000 
50 1 00012 
ENTDINT2 
EXF 
SLJ 
7 
11101B 
ENTDINT1 
47546 
74 7 11101 
75 0 47543 
EXF 
SLJ 
7 
IIB 
. - 1 
47547 
74 7 00011 
75 0 47546 
LDA 
EXF 
1 
EDIBUFFR 
EDIBUFFR 
47550 
12 0 47563 
74 1 47563 
EQS 
SLJ 
EDIPERCD 
ENTDINT3 
47551 
64 0 47567 
75 0 47555 
LDA 
LIU 
1 
EDIDINT 
EDIB12IM 
47552 
12 0 47564 
52 1 47565 
U P 
SCM 
2 
• + 1 
EDINEGZR 
47553 
55 2 47554 
42 0 47566 
LIL 
SLJ 
2 
EDIB12IM 
ENTRDINT 
47554 
53 2 47565 
75 0 47540 
ENTDINT3 
EQS 
SLJ 
EDIMINCD 
ENTDINT4 
47555 
64 0 47570 
75 0 47557 
ENI 
SLJ 
2 
0 
ENTDINT5 
47556 
50 2 00000 
75 0 47562 

316 
8. ASSEMBLY OF COMPLETE PROGRAMS 
INPUT TO CODAP 
ASSEMBLED PROGRAM 
ENTDINT4 
EQS 
SLJ 
1 
EDIDIGCD 
ENTDINT2 
47557 
64 1 47571 
75 0 47546 
ENA 
MUI 
10 
EDIDINT 
47560 
10 0 00012 
24 0 47564 
INA 
STA 
1 
0 
EDIDINT 
47561 
11 1 00000 
20 0 47564 
ENTDINT5 
ENI 
S U 
1 
10 
ENTDINT2 
47562 
50 1 00012 
75 0 47546 
EDIBUFFR 
BSS 
1 
47563 
EDIDINT 
BSS 
1 
47564 
EDIB12IM 
BSS 
1 
47565 
EDINEGZR 
OCT 
7777777777777777 
47566 
77 7 77777 
77 7 77777 
EDIPERCD 
OCT 
42 
47567 
00 0 00000 
00 0 00042 
EDIMINCD 
OCT 
52 
47570 
00 0 00000 
00 0 00052 
EDIDIGCD 
OCT 
56 
47571 
00 0 00000 
00 0 00056 
OCT 
74 
47572 
00 0 00000 
00 0 00074 
OCT 
70 
47573 
00 0 00000 
00 0 00070 
OCT 
64 
47574 
00 0 00000 
00 0 00064 
OCT 
62 
47575 
00 0 00000 
00 0 00062 
OCT 
66 
47576 
00 0 00000 
00 0 00066 
OCT 
72 
47577 
00 0 00000 
00 0 00072 
OCT 
60 
47600 
00 0 00000 
00 0 00060 
OCT 
33 
47601 
00 0 00000 
00 0 00033 
OCT 
37 
47602 
00 0 00000 
00 0 00037 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
317 
We see that the treatment accorded the various types of addresses is as 
follows: 
(1) In regional addresses, for example, the origins of the regions identified 
as E N T R D I N T and E N D I N T 2 have been established as 47540 and 
47546, respectively. Hence, the instruction SLJ E N D I N T 2 (at E N D I N T 4 ) 
becomes 75 
0 
47546. 
(2) The location-of address within the instruction SIU 1 EDIB12IM 
becomes 47565. 
(3) The current instruction reference in the instruction U P 2 * + 1 
becomes 47554, since the instruction itself is assigned storage at 47553. 
(4) The address to be filled by the computer at E N T R D I N T remains 
as designated, 77777 in octal, until the program is run. 
(5) The decimal value ten has been assembled correctly at 47560 as 
00012. 
We note that such instructions as the enter U instruction at 47541 have 
been properly treated since the original instruction, ENA E D I B U F F R + 1 
has become 10 
0 
47564 with E D I B U F F R itself assigned the value 
47563. We note also that blanks are automatically filled in as pass instruc-
tions, that the necessary zeros to fill the register are supplied and that no 
information is put in the registers reserved for temporary storage. 
In Examples 8-3 and 8-4 we have seen how an assembly program can 
be utilized to transform the kind of program which it is convenient for the 
human coder to write into the absolute, digital, machine language for the 
computer control. In subsequent sections, we shall consider even more 
sophisticated coding and programming aids. We should take very careful 
notice, however, of the assembled version of the program of Examples 8-3 
and 8-4. It points out the fact that the ultimate form for the machine is 
the same as that which we used in our first examples in Chapter 3. Thus, 
unless the programmer keeps in mind basic functioning of the computer 
and has some idea how the assembly language is transformed into machine 
language, he will often make inefficient use of the facilities provided by 
the assembly programs. 
8-3. Fortran Symbolic Assembly Program 
In Chapter 7 we introduced an input-output language which permits 
us to load information into or unload information from storage registers 
whose addresses are given symbolically. In the examples of Section 7-2, 
we assumed that we could operate on this data by means of programmed 
instructions. We have, however, no way of knowing the absolute addresses 
associated with the symbolic addresses by the translator, or of establishing 
a correspondence between the absolute addresses of intermediate and final 
results and the symbolic address forms needed for output specifications. 

318 
8. ASSEMBLY OF COMPLETE PROGRAMS 
Thus, our assumption implies that the translator program could be ex-
tended to handle machine language instructions with address parts specified 
in the same way as the symbolic addresses of input-output lists. In this 
section we will describe such an extended program, called the Fortran 
Symbolic Assembly Program, and we will give examples of its use. 
To simplify the discussion, we will utilize eighty-column punched cards 
as the only input medium for program instructions, program parameters, 
and data. The input and output of data have been discussed in Chapter 7 
and we will not expand on that discussion or review it here. The statements 
by which we accomplished the input and output will continue to be avail-
able. We will extend this class of statements below; but first, we will define 
the admissible card format and symbolism for presenting machine language 
instructions to the assembly program. 
On a single card we will punch the two instructions which make up a 
program step and an optional tag which may be used to identify the register 
in which the program step is to be stored. Columns 1-5 of the card are 
reserved for the tag, and columns 7-72 for the program step. Spaces in 
columns 7-72 of a card containing a program step will be ignored. Column 
6 is always left blank on such a card. Columns 73-80 are not used by the 
assembly program. Hence, the programmer's disposition of these columns 
is arbitrary. 
The tag is a symbolic address giving the location of a program step. 
Since it differs from the symbolic addresses of Chapter 7, we need to define 
the admissible notations for tags. We must, of course, also define the way 
in which tags, besides being marginal notes identifying program step 
locations, can be used inside of a program. 
A tag consists of at least one and not more than five characters. The 
leading, nonblank, character of the tag must be a decimal digit. The re-
maining characters may be decimal digits and letters of the alphabet with 
only relatively minor restrictions. Thus, the following are admissible tags: 
12345 
1ABC 
6 
3AB39 
The following are not admissible as tags: 
12.381 
A24 
95WXYZ 
Restrictions are placed on tag symbols to keep the assembly program from 
confusing them with other types of symbolic information, namely Hollerith 
information and octal data. Since the symbol Β at the end of a digital 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
319 
sequence has a special use for the latter, we should not introduce tags 
which consist of digital sequences and an ending B. For example, a tag 
such as 7743B should not be used. Another type of tag which should be 
avoided is one which has H as the first alphabetic character following the 
lead digit, such as 3HABZ. This tag may be confused with a three-char-
acter Hollerith field description. 
Since the order in which the cards containing program steps are pre-
sented to the assembly program will serve to assign locations to program 
steps sequentially from some origin point in storage, not all cards will 
have to be tagged. Thus, we normally tag only those program steps which 
will be referred to within the program. Since these program steps may be 
referred to by the address parts of the instructions in the program, tags 
must be available for use as symbolic addresses within instructions. A 
tag may be used as an address in any instruction which requires the address 
of an operand or a jump location. Tags may also be used as addresses in 
instructions in which address parts themselves are treated as operands, 
shift counts, or code words. In such cases the absolute five octal digit 
address which ultimately corresponds to the tag will actually be treated 
as the operand, shift count, or code word. Since we will not, however, in 
general, know the explicit correspondence between tags and absolute 
addresses set up by the assembly program, we must utilize the utmost 
care if we make such use of a tag. Programming situations in which we do 
so are almost invariably confined to address arithmetic where the tag-
operand is to be interpreted as an address. 
In columns 7-72 of a card containing a program step, we punch the two 
instructions in the normal order of operation code, designator, address for 
the lower instruction. We introduce spacing to suit our convenience. We 
will define the permissible forms for the three parts of an instruction. 
The operation code must be given in mnemonic alphabetical form as listed 
in Appendix A. To this list we add the mnemonic codes Z R 0 and SEV for 
00 and 77, respectively, not, however, as new instructions. Thus, the opera-
tion code for a load Q instruction cannot be given as 16; it must take the 
form LDQ. Similarly, the store A operation code is to be given as STA, 
not 20, and so forth. 
The designator must be given numerically. 
The designator values 0-7 have 
the usual significance. If the designator is omitted, it is understood to be 
zero. 
The use of the alphabetic mnemonic forms for the operation codes and 
a digital value for the designator makes it easier for the assembly program 
to distinguish between them. To assist in the recognition of addresses, we 
must enclose all address parts of instructions 
in parentheses. 
The address 
portions, as we know, may have a variety of functions, such as operand 
addresses, jump addresses, shift counts, operands, and external function 

320 
8. ASSEMBLY OF COMPLETE PROGRAMS 
codes. Address parts may take a number of forms. We have already become 
familiar with the use of the tag form of an address, and we will now intro-
duce some other forms. 
In instructions such as enter A and enter Q, the address parts are used 
as operands. As such, they represent octal constants which are to be 
utilized as program parameters. We generalize this idea to permit the 
introduction of different kinds of program parameters as address parts of 
instructions. Thus, addresses may be signed octal integers, signed decimal 
integers, fixed and floating point decimal numbers. Such addresses are not 
restricted to the instructions whose address parts are actually operands; 
but, with reasonable prudence, they may be used with all instructions. 
To exercise reasonable prudence, however, we must know that for instruc-
tions in which the address parts are actually operands or shift counts, the 
constant will be stored in the address part itself. We must also know that 
for instructions in which address parts normally are addresses, a constant 
in the address portion of the instruction will be stored in a separate register 
by the assembly routine. The constant is then replaced in the instruction 
by the address of this register. We must observe the usual precautions 
against overflow. Thus, for a shift instruction the address will be a positive 
integer less than 2
1 δ, but for a load A or load Q instruction, we can admit 
as an address any of the constant types, provided that they are capable of 
storage in a single register. For octal integers this means no more than six-
teen digits and for decimal no more than twelve. The exponent of a decimal 
floating 
point number must be less than or equal to 99 in magnitude. 
With reasonable precaution we will avoid the use of floating point constants 
as address parts of instructions for fixed point arithmetic, and vice versa. 
In Appendix Ε we give a detailed listing of instructions and the types of 
address constants they admit. We give some specific examples below. 
Example 8-5. The following are examples of symbolic instructions whose 
address parts illustrate some of the types of permissible addresses. 
1TAG 
ARS(15B) 
E N Q ( - 7 7 B ) 
2TAG 
E N Q 4 ( - 1 0 ) 
LLS2(48) 
3TAG 
LDL(777B) 
S C M ( - O B ) 
4TAG 
SUB ( — 15) 
MUI(IO) 
5TAG 
LDA ( - 1 . 5 ) 
FMU(1.65E + 1) 
The instructions have been arranged into the form of a program and the 
program steps tagged for convenient reference. The code as an entity is 
meaningless. 
Since the instructions at 1TAG normally contain operands, the symbolic 
addresses 15B and — 77B will be stored as five-octal-digit integers within 
the address parts of the instructions themselves. Thus, in the storage 
register which the assembly program assigns to 1TAG, we may expect to 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
321 
find, after assembly, the absolute program step 
01 
0 
00015 
04 
0 
77700 
The program step at 2TAG will be treated in a similar manner except that 
the addresses will be translated from decimal to binary. The assembly 
program will set the absolute content of the register associated with 
2TAG to 
04 
4 
77765 
07 
2 
00060 
The address parts of the instructions at program steps 3TAG, 4TAG, and 
5TAG cannot be converted and stored within the instructions themselves 
as in the previous program steps. They must be converted and stored in 
separate registers. Assume that these constants are stored by the assembly 
routine in consecutively addressed registers beginning with register 01000. 
Then we will get 
(01000) = 0000 0000 0000 0777 
(01001) = 7777 7777 7777 7777 
(01002) = 7777 7777 7777 7760 
(01003) = 0000 0000 0000 0012 
(01004) = 5776 1777 7777 7777 
(01005) = 2005 4100 0000 0000 
while the absolute form of the instructions in the registers associated with 
the symbols 3TAG, 4TAG, 5TAG will be, respectively, 
44 
0 
01000 
42 
0 
01001 
15 
0 
01002 
24 
0 
01003 
12 
0 
01004 
32 
0 
01005 
We note that both fixed and floating point decimal constants go into 
floating 
point form unless they are integers without decimal point. This 
corresponds to the way in which F-fields and 2?-fields are handled. 
We may also use the kinds of symbolic addresses introduced in connec-
tion with the input-output language of Chapter 7. The restrictions imposed 
there will continue to hold. In addition, we exclude the previously admis-
sible symbols I, J, K, L, Μ, Ν from representing addresses of operands in 
storage. We do this because these symbols used in this context will be 
translated into addresses for index registers. Thus, they may appear in 
input and output statements, but they may not appear in instructions as 
addresses of operands. When these symbols are introduced into programs 
as addresses by means of the various statements of the 
input-output 
language, the registers associated with them will, in fact, be index registers. 
The register content is then accessible to symbolic machine instructions 
only by means of the index designator part or by use of instructions which 
deal directly with the content of index registers. Although the symbol L 

322 
8. ASSEMBLY OF COMPLETE PROGRAMS 
may not be used as the address of an operand, it can be used as a symbol 
for the address of the instruction in which it appears. Thus, E N A ( L ) , if 
ultimately stored at address 10000 would become 10 
0 
10000. 
In many cases, the address part of an instruction is immaterial and we 
fill it arbitrarily. To avoid having to set aside a register for a symbolic 
address we will never use, or for a constant that will not be called for, we 
indicate such addresses by the asterisk symbol *. Thus, (*) represents an 
arbitrary address part. This will be assembled as zero in the address part 
of the instruction. For this reason we may also use it to do such things as 
complete a pass instruction in the form ENI(*) or complete the content 
of a register with ZR0(*). These will be assembled as 50 
0 
00000 and 
00 
0 
00000, respectively. 
Example 8-6. We write a code for the vector addition problem of Ex-
amples 3-15, 3-16, 3-17, and 3-18 in the assembly language of this section. 
We assume that symbolic address arrays V, W, and Ζ for the vectors F, 
W, and Ζ have been defined by means of appropriate input-output state-
ments, that the vectors V and W are already in storage, and that the 
value η of the number of components is stored at symbolic address NN. 
1L00P 
1SKIP 
LDA(NN) 
ENI 1(1) 
LDA 1(V) 
STA 1(Z) 
ISK 1(*) 
SLS(*) 
SAU(ISKIP) 
ENI (0) 
ADD 1(W) 
ENI (0) 
SLJ(1L00P) 
ZRß (*) 
Set (A) = n. Prestore index skip. 
Set (B
1) = 1. Pass. 
Vt 
A. (A) = Vi + Wi = 
Zi. 
Store Zi. Pass. 
If i < η, i + 1 —• t and close loop, 
t = n. STOP. 
In the code of Example 8-6 we allowed our index values to run from 1 
through η in order to generate in sequence the addresses of the arrays V, 
W, and Z. Since apparently each address of the array was generated by 
adding the current value of the index to the initial array address, we may 
well ask why the index was not made to take values zero through η — 1. 
The answer brings out an important fact about the manner in which 
symbolic address arrays, defined by means of the input-output language, 
are associated with absolute addresses. Each symbolic address array is 
replaced by a sequence of consecutive addresses which is one longer than 
the number of symbolic addresses. The array name itself, as distinguished 
from the subscripted array names, is then considered also to represent a 
symbolic address; and the origin of the block assigned to the array is made 
to correspond to the symbolic address given by the array name. Thus, for 
the array of symbolic addresses V: 
V ( l ) , 
V(2), . . . , V ( n ) 
a block of η + 1 consecutive absolute addresses is assigned. The origin of 
these will correspond to the symbolic address V, the remaining η will cor-

8-3. FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
323 
respond in order to the symbols V ( I ) , I = 1, 2, · · · , n. We note the dual 
usage of V as a symbolic address and as the name of an array. Because of 
this fact, we will usually find it convenient when dealing with arrays in 
the Fortran symbolic assembly language to utilize the index skip instruc-
tion with a starting index value of one rather than zero. It is easy to see 
that the assembly program is designed to handle arrays as regions, so that 
by making V the origin V(I) becomes V + I. 
Example 8-7. For a second example of coding in the symbolic assembly 
language, we rewrite the program of Example 4-42. We make no essential 
change in the original code, merely adding to it the statements to print 
the resultant values of f(x) in a single column. The output data is stored 
in an array W, which we set up by means of a Dimension statement. Since 
the output program treats the first address of the array as corresponding 
to the array name, we must take care to place the first output item in 
the second register of the storage block corresponding to this array. We 
handle this in the preliminary part of the code before entering the loop. 
500 
D I M E N S I O N W(101) 
F0RMAT(5OX, F20.10) 
3ALF 
HALF 
ENI 1(100) 
ENA(W) 
Set counter index to lOOio. 
Address W to accumulator. 
INA(l) 
SAL(llALF) 
Set the storage address for 
f(x) to initial value. 
ENA(O) 
STA(TEMPl) 
Set χ = 0 initially. 
LDA(TEMPl) 
FMD(0.9) 
0.9* -> A. 
STA(TEMP2) 
LDA (TEMPI) 
0.9a; -> TEMP2. 
x-^A. 
FMU (TEMPI) 
STA(TEMP3) 
x
2-^A. 
X 2 
TEMP3. 
FAD(O.l) 
STA(TEMP4) 
0.1 + 
x
2-+A. 
0.1 + χ
2 -> TEMP4. 
LDA(TEMP3) 
FMU(4.6) 
x
2->A. 
4.6a;
2 -> A. 
FSB(TEMP2) 
FAD(4.9) 
4.6a;
2 - 0.9a; -> A. 
4.6a;
2 - 0.9a; + 4.9 -> A. 
FDV(TEMP4) 
STA(*) 
/ ( * ) - • A. 
Store/(x). 
LDA (TEMPI) 
FAD(O.Ol) 
X-+A. 
χ + Ax = χ + .01 -> A. 
STA(TEMPl) 
RAO (11 ALF) 
χ + Ax —* x. 
' 
Set up storage for f(x + Δα;). 
UP K3ALF) 
ENI(*) 
All values? If not, reloop. 
Otherwise, pass to output. 
PRINT 500, W 
Print/(a;) table. 
SLS(*) 
ZR0(*) 
STOP. 

324 
8. ASSEMBLY OF COMPLETE PROGRAMS 
8-3.0. Pseudoinstructions 
In Section 8-3 we defined the admissible form of symbolic machine 
language instructions. In assembling these, the assembly routine replaces 
mnemonic operation code symbols by the octal operation codes, and 
symbolic addresses of various types by appropriate five octal digit com-
binations. It then stores each program step in a location determined by 
its tag, or by its position in sequence relative to the last tagged program 
step. Thus, in this case, each card will generate a single program step re-
quiring a single register for storage. Constants appearing as addresses of 
some instructions will require one additional register for their storage. 
While statements such as the Format statement of Chapter 7 are in-
tended for reference only, and so may be thought of as instructions to the 
assembly program itself, others, such as the Read statement, do initiate 
program action. We may think of the action of the assembly routine in 
connection with such statements as being that of selecting from the library 
an appropriate input or output routine, supplying it with the correct 
parameters, and making provision to initiate and terminate the selected 
routine at the right place in the assembled code. Thus, in contrast to the 
symbolic machine instruction, a single statement may result in an assembled 
program of a number of machine language instructions. We see that the 
statement is in effect a compact and easy way of introducing a relatively 
large number of instructions into the assembled program. 
We now extend the class of statements to include 
pseudoinstructions 
and define three new ones. The form that each takes is the operation code, 
CJ3N, H0L, or LJ3C, as the case may be, followed by a parenthesis con-
taining a list of equals relationships. Each element of the list is separated 
from the others by commas. The C0N, H0L, and L0C pseudoinstructions 
are used to provide information to the assembly routine and to control its 
actions. The term pseudoinstructions is not very apt, but it serves to dis-
tinguish an instruction to the assembly program from a direct instruction 
to the computer. We will describe each pseudoinstruction in turn. 
We have seen how we may introduce constants by means of the address 
parts of symbolic instructions. If we wish to use these constants in later 
instructions, we must arrange to place them in registers whose symbolic 
addresses are known. Thus, for example, we may write 
ENA(144B) 
STA(IND) 
The index 144 8 would then be available in a register with symbolic address 
I N D . Another way to assign a symbolic address to a constant is by means 
of the C 0 N statement. This statement permits us to give to the assembly 
program a list of values and the symbolic addresses of the registers in 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
325 
which they are to be stored. Thereafter, the constants will be available in 
storage and may be used by specifying the associated symbolic address in 
any appropriate instructions. 
Example 8-8. We present a C0N statement which provides for the 
storage at named registers of a list which exhibits the various types of 
constants: 
C0N(LI = - 7 7 7 B , K 2 = 12,K0N = 12B,XY1 = - .35, Ζ = 
1.0E-10) 
We note again that constants which are given externally as octal inte-
gers are to be followed by the letter B. Otherwise the integer is interpreted 
to be decimal. Integers are recognized by the fact that they contain no 
decimal point 
Their internal representation will have to fit in a single 
register, and so the integers listed must be capable of being stored in this 
form. The constant to be stored at register XY1 is given externally in the 
C0N statement as a fixed point decimal number, while that to be stored 
at register Ζ is given externally as a floating point decimal number. How-
ever, both will be stored internally as floating point binary numbers, and 
so the constants listed must be capable of storage in this form. In the 
present case, this imposes the restrictions that the fixed point constant 
contain no more than twelve decimal digits and the exponent must be 
less than or equal to ninety-nine in magnitude. 
Once a constant has been defined by the C0N operation, it can be re-
ferred to by symbolic address in subsequent instructions. 
Example 8-9. Following the C0N operation of Example 8-8, we wish to 
load the value 1.02? — 10 into the accumulator. We may use LDA(Z). 
In Chapter 7, we noted that, on input, Hollerith information is stored 
within a Format statement. Thus, it is not directly accessible to machine 
language instructions. To store Hollerith information into registers with 
known symbolic addresses, we can replace each character by its octal 
code and then handle the data by means of octal field designations. To 
avoid this cumbersome process we introduce the H0L statement which 
provides us with a simpler means of carrying it out. The H0L operation 
permits us to present to the assembly program a list of one-word units of 
Hollerith information with their corresponding symbolic addresses. Once 
the Hollerith word has been introduced in this way, it can be referred to 
by its symbolic address in any subsequent instruction. 
Example 8-10. We present a H0L statement which provides for the 
storage at named registers of a list of Hollerith words: 
H0L(H1 = H E A D 1 Α Λ Λ, H2 = B A D AE R R A, H 3 = (6E20.9) ) 

326 
8. ASSEMBLY OF COMPLETE 
PROGRAMS 
When the assembly routine processes the H0L 
pseudoinstruction, it 
will replace each character on the right side of an equals relation with its 
two octal digit code and pack the codes into the register associated with 
the symbolic address on the left of the equals sign. If, as we assume here, 
a register holds sixteen octal digits, we must have exactly eight Hollerith 
characters including 
spaces in the word immediately to the right of an 
equals sign. To emphasize that we must count spaces, they have been 
indicated by the symbol Λ in Example 8-10. However, aside from the eight 
characters immediately following the equality sign, spaces in the 
H0L 
statement can be introduced at our convenience. 
While the assembly program permits us to use only symbolic addresses, 
we may find it necessary from time to time to employ absolute addresses. 
Such a programming situation can arise, for example, when we wish to 
make use of library programs which have fixed absolute entry points. This 
may be the case when both the program we have written and the assembly 
program operate under control of an executive or monitor routine which 
is normally in storage in fixed locations. To avail ourselves of the services 
of the executive routine we may then have to make use of a series of fixed, 
absolute entry points. The L0C pseudoinstruction enables us to list a 
series of absolute machine addresses and the corresponding symbolic 
addresses which we wish to assign. Once the L0C instruction has been 
presented to the assembly program, we may refer to any absolute address 
in its list by the symbolic address assigned. 
Example 8-11. We present a L0C statement which provides for assign-
ment of given symbolic addresses to a list of absolute addresses: 
L0C ( E R P = 24, Ζ = 0, ZM1 = 77776, ZP1 = 1 ) 
Since the integers on the right of the equals signs must all be in octal, it 
is not necessary to include the final B . 
Since each constant in the list of a C0N pseudoinstruction and each 
Hollerith word in the list of a H0L pseudoinstruction must go into a 
single register, each symbolic address in the address lists of these instruc-
tions must be a single address, that is, none can be array names as defined 
in Chapter 7. Similarly, only simple symbolic addresses may be used in 
the list of a L0C statement. However, the list of a C0N pseudoinstruction 
is stored sequentially and so we can provide our own arrays. Thus, 
C0N(A=O,A1=1.1,A2 = 1.2,A3 = 1.3) 
would 
give 
the 
equivalent 
of 
storing the numbers 1.1, 1.2, and 1.3 in the registers A ( I ) , I = 1, 2, and 
3. With this usage we can deal with the array A by indexing as before. 
Thus, LDA1(A) is load A with A I if { B
1 ) 
= I , 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
327 
The pseudoinstructions we have just introduced, the statements of 
Chapter 7, and the statements still to be introduced below are punched 
into Columns 7-72 of the card, just as are the symbolic machine language 
instructions. However, unlike machine language instructions, pseudo-
instructions and statements may require more than one card before they 
are completed. In this case, a statement may be continued onto the next 
card by punching one of the digits 1-9 in Column 6 of each continuation 
card, and then continuing with the statement in Columns 7-72. Up to 
nine continuation cards may be used. The spacing of the statement, as 
with machine language instructions, is arbitrary within Columns 7-72, 
provided we remember that spaces are to be counted in Hollerith fields 
and represent zeros in certain constants. Columns 73-80 of a card are not 
read by the assembly program and we may use them in any way that we 
wish. 
We recall that we may have to refer to certain statements such as 
Format statements within a program. Because of this we are permitted to 
assign five digit integers, called statement numbers, to any statement. When 
a statement number is to be assigned, it will be punched in Columns 1-5. 
Since statements may be referred to by machine language instructions as 
well as by other statements, we must be able to use them as symbolic 
addresses. Such usage is permitted, but is appropriate only in such in-
structions as jump, stop, or substitute address. 
8-3.1. Editorial Comment 
In Chapter 3 we pointed out the value of editorial notation and com-
ment. With the symbolic assembly program we may insert comments in 
two ways. A "C" in Column 1 of a card means that the entire card is not 
to be read as part of the program, and so may be used for a comment. 
Alternatively, on instruction cards, we may terminate the second instruc-
tion with a period and follow the period with comments. 
Example 8-12. We illustrate each type of comment. 
1 
80 
c 
MAIN LOOP BEGINS H E R E 
7 
72 
80 
LDA(X) A D D ( Y ) . I N C R E M E N T X 

328 
8. ASSEMBLY OF COMPLETE PROGRAMS 
As the program is assembled it is possible to get an on-line listing of the 
cards just as they have been punched. Columns 73-80 are not reproduced 
on this listing. 
8-3.2. Complete Programs 
We have reviewed the various statements which can be accepted by the 
assembly programs, and the format of symbolic machine instructions. We 
have given examples illustrating parts of programs written in this assembly 
language. Now we consider a complete program for assembly. We already* 
have all of the components which go into the structure of such a program, 
except for a means of telling where the program to be assembled begins, 
and where it ends. For this purpose we introduce two more statements, 
the Program Name statement and the End statement. 
Each program for assembly must be initiated by a Program Name 
statement and terminate with an End statement. These statements are 
to be punched somewhere in Columns 7-72 of the card. The End state-
ment consists of the single word E N D . The Program Name statement con-
sists of the word PR0GRAM followed by the program's name. The pro-
gram's name is formed by a combination of at least one, and not more than 
eight letters and digits of which the first must be a letter. If the name con-
sists of a single letter, the letter cannot be I, J, K, L, M, or N. 
Between the initiating Program Name statement and the terminating 
End statement, the program may be arranged in any correctly sequential 
way with one exception—all of the C0N, H0L, and L0C statements must 
follow immediately after the program name statement. These statements 
and one other to be introduced are distinguished from the remaining 
statements by this restriction. This distinction is emphasized by the use 
of the term pseudoinstruction. 
Example 8-13. We illustrate the structure of a complete program for 
assembly. 
PROGRAM E X A M P L E 
PSEUDOINSTRUCTIONS 
S T A T E M E N T S A N D SYMBOLIC 
INSTRUCTIONS 
AS NECESSARY 
E N D 
Example 8-14. In Example 7-29 we showed the input-output statements 
of a program for integrating a differential equation and printing the results 
with a specified format for each of a given number of sets of initial condi-

8-3. 
FORTRAN SYMBOLIC-ASSEMBLY PROGRAM 
329 
tions punched on cards. The actual number of cases is furnished as part 
of the input data. We now complete the example by providing the coding 
for the integration of the differential equation 
f x
=
f
(
X'
y
) -
We handle the evaluation of the derivative by means of a subroutine, ex-
hibiting the code for the particular case 
f(x, y) = 2 (ζ - 
xy) 
Although the input for each case specifies the size of the integration step 
and the number of steps, we will nevertheless agree to terminate the inte-
gration, provide a suitable output indication, and proceed to the next 
case whenever the independent variable χ turns negative. For this purpose 
we assume the existence of a subroutine with absolute entry point at 00100 
which will output any Hollerith word placed in the accumulator. This 
gives us an opportunity to utilize the H0L 
and L0C 
pseudoinstructions 
in our program. 
Given a solution point (x, y(x)), 
we proceed to the point (x+h, y(x+h) 
) 
by means of the following integration formulas, which we introduce with-
out further justification: 
where 
y(x+h) 
= y(x)+hftx+h/2, 
y(x+h/2)-] 
y(x+h/2) 
= y(x) 
+ 
(Λ/2)/[*, 
5 6 7 
P R O G R A M 
E X A M P L E 
C 0 N ( T W 0 = 2.0, H A L F = 
0.5) 
H 0 L ( H 0 L W D 
= 
ARGAANEG) 
L 0 C ( 0 P S R T 
= 
100) 
100 
F 0 R M A T (15) 
200 
F O R M A T 
(3F10.6,I5) 
300 
F 0 R M A T 
( / / / , 3 9 X , 1 H X , 1 9 X , 1 H Y , 1 7 X , 5 H D Y / D X , / ) 
400 
F 0 R M A T (30X,3E20.9) 
R E A D 100,N1 
L D A (NI) 
SAU(IP) 
ENI6(1) 
ENI(0). N 0 W S E T U P T 0 H A N D L E N l 
CASES. 
C 
R E A D I N I T I A L C 0 N D I T I 0 N S . P R I N T H E A D I N G S . 
5 
R E A D 200, Χ, Y, H, N 2 
P R I N T 300 
L D A ( N 2 ) 
SAU(3P) 
ENI5(1) 
L D A ( H ) . N 0 W S E T U P F 0 R N 2 STEPS. 
F M U ( H A L F ) 
STA(H2). S T 0 R E H / 2 . 

330 
8. ASSEMBLY OF COMPLETE PROGRAMS 
1 
2 
5 6 7 
C 
F0RM INITIAL DY/DX. PRINT INITIAL CONDITIONS. 
LDA(Y) 
LDQ(X) 
SLJ4(10P) 
ENI(O). JUMP TO DERIVATIVE 
SUBROUTINE. 
STA(DYDX) 
ENI(O) 
PRINT 400, X, Y, DYDX 
C 
CHECK SIGN 0 F X 
2P 
LDA(X) 
AJP2QP0S). JUMP T 0 CONTINUE 
THIS CASE. 
LDA(HjZ)LWD) 
SLJ4(0PSRT). JUMP TO SPECIAL 
0UTPUT. 
SLJ(IP) 
ENI(O). JUMP TO NEXT CASE. 
C 
COMPUTE Y(X + H/2) 
IPOS 
FAD(H2) 
STA(X) 
LDA(DYDX) 
FMU(H2) 
FAD ( Y) 
LDQ(X) 
C 
COMPUTE Y(X + H) 
SLJ4(10P). 
ENI(O). JUMP TO DERIVATIVE 
SUBROUTINE. 
FMU(H) 
FAD(Y) 
STA(Y) 
LDA(X) 
FAD(H2) 
STA(X) 
C 
COMPUTE DYDX 
FOR OUTPUT. PRINT OUTPUT LINE. 
LDQ(X) 
LDA(Y) 
SLJ4Q0P) 
ENI(O). JUMP TO DERIVATIVE 
SUBROUTINE. 
STA (DYDX) 
ENI(O). STORE DYDX. 
PRINT 400, X, Y, DYDX 
C 
CHECK FOR END OF CURRENT CASE. 
3P 
ISK5M 
SLJ(2P) 
C 
CHECK FOR END OF ALL CASES. 
IP 
ISK6(.) 
SLJ(5). IF MORE CASES, GO TO 
STATEMENT 5. 
SLJ(25) 
ENI(O). JUMP TO END. 
C 
DERIVATIVE SUBROUTINE BEGINS HERE. 
10P 
SLJ(.) 
STA(Tl) 
STQ(T2) 
LAC(T2) 
FMU(Tl) 
FAD(T2) 
FMU(TWO) 
SLJ(IOP). JUMP TO EXIT. 
25 
END 
END 
The reader will note the apparently superfluous End statement in the 
code of Example 8-14. This form is required in order to handle programs 
made up of a combination of segments. In such combination programs, 
each segment will have the structure illustrated in Example 8-13. Thus, 
there will be an End statement for each segment. The final End statement 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
331 
is then required to define the end of the combination of program items. 
When a program has only one segment, as in Example 8-14, this additional 
End statement will still be required to define the completion of the entire 
program. 
8-3.3. Subroutines 
We can, if we wish, include subroutines in our programs. That is, we 
can use sequences which are to be entered by means of a return jump and 
which provide for a return to the appropriate point in the main sequence. 
We manage this in the usual way by placing the exit instruction as a jump 
in the upper part of a program step and the entry instruction as the lower 
part of the same step. We need then only tag this entry point and make a 
return jump to the tag from the main sequence whenever we wish to use 
the subroutine. The derivative subroutine of Example 8-14 was handled 
in this manner. We may often find it convenient to include such subroutines 
in our programs. When we do so, however, we must code the subroutine 
within the frame of reference of the main program. That is, we must take 
care that any duplication of symbolic addresses and tags is for the purpose 
of exchanging information between the two routines, so that the subroutine 
will not interfere with the main program and vice versa. We must also be 
aware of the address tag assigned to the entry point of the subroutine. 
In general, it will not prove easy to exchange such subroutines between 
different main programs, and they will not be kept in a library for this 
purpose. 
In Chapter 6 we saw how to write subroutines in a form which permitted 
their inclusion in any program by means of a subroutine assembly program 
which we called SURAP. We then saw that we could make up a library 
of useful subroutines to be kept on hand in storage for assembly for in-
sertion in a program by SURAP whenever desired. We implement this 
same idea with our symbolic assembly program through the introduction 
of a special statement to call up a library subroutine. The statement has 
the following form. 
Symbolic address = function name (symbolic address) 
We may insert any two symbolic addresses into this statement. The 
address in parentheses specifies the location of the argument in storage. 
The address to the left of the equals sign signifies the location of the de-
pendent variable or result. The function name defines the operation to be 
performed on the argument. A list of available library functions and their 
names and definitions is given in Appendix F. This statement, as are the 
previously defined statements, is punched into Columns 7-72 of the card. 

332 
8. ASSEMBLY OF COMPLETE PROGRAMS 
Example 8-15. We wish to take the square root of a floating point number 
located at address ARG and place the floating point result at address 
RESULT. We use the following statement. 
RESULT = SQRTF(ARG) 
The appropriate function name is determined from Appendix F, where 
we also determined that, for the function name SQRTF, the argument 
must be a number in floating point mode, and the result to be obtained is 
a number of the same kind. 
In executing the statement of Example 8-15, the assembly program may 
operate in the following way. It determines whether or not the function 
SQRTF has appeared in a previous statement. If not, the program finds 
the subroutine in the library, assigns it storage locations, and assembles it 
with a subassembly program of the SURAP type. It then places instruc-
tions in the main program to transmit the argument to the subroutine 
from the absolute location assigned to ARG, to make a return jump to the 
subroutine, and then to pick up the result from the subroutine and enter 
it in the register assigned to RESULT. 
We now turn to another method for handling subroutines. We will see 
that by virtue of this technique any main program or programs can be 
made into subroutines of some designated main program. The procedure 
permits subroutines to be coded with complete independence, without 
worry about the use of overlapping symbolic names and tags. 
If a program is to be used as a subroutine for another program, we 
need only name it as a subroutine. We do this by simply replacing the card 
containing the program name statement with one containing a Subroutine 
Name statement. Thus, in Example 8-13, the first card would be replaced 
by a card making the following statement. 
SUBROUTINE E X A M P L E 
We could then utilize the program as a subroutine, but we are not per-
mitted to utilize the special statement used for library subroutines. 
We must appraise the assembly program of the existence of a subroutine 
defined by a name statement, so that proper provision may be made for 
it when assembling the main program. We do this by means of a new LIB 
pseudoinstruction, which should be placed with all other pseudoinstruc-
tions immediately following the Program Name statement of the main 
program. The LIB pseudoinstruction like those previously introduced 
presents a list of relations with the equality sign. The left-hand member of 
each relation is the name of a subroutine as stated in the Subroutine Name 
statement or as found in the library. The right-hand member gives the 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
333 
address at which the corresponding subroutine will be entered from the 
symbolic instructions of the main program. 
Example 8-16. We give an example of a LIB pseudoinstruction. 
LIB ( I N P U T = I N , I N V E R S E = I N V ) 
After this LIB pseudoinstruction, we may call for the subroutine I N P U T 
or the subroutine INVERSE by a return jump to the addresses I N and 
INV, respectively. 
Subroutines are to be put into the card deck immediately following the 
main program, or must be in the library. The End statement of the final 
subroutine must be followed by a second End statement for the combina-
tion of main program and subroutines, as noted before. 
Example 8-17. We show the structure of a program comprising a main 
program and the two subroutines of Example 8-16. 
P R O G R A M E X A M P L E 
LIB ( I N P U T = I N , I N V E R S E = I V ) 
O T H E R PSEUDOINSTRUCTIONS, I F A N Y 
I 
I 
S T A T E M E N T S + SYMBOLIC INSTRUCTIONS OF M A I N 
P R O G R A M 
E N D 
S U B R O U T I N E I N P U T 
PSEUDOINSTRUCTIONS OF SUBROUTINE 
X 
X 
S T A T E M E N T S A N D I N S T R U C T I O N S OF S U B R O U T I N E 
E N D 
SUBROUTINE I N V E R S E 
PSEUDOINSTRUCTIONS OF SUBROUTINE 
X 
X 
S T A T E M E N T S A N D INSTRUCTIONS OF SUBROUTINE 
E N D 
E N D 

334 
8. ASSEMBLY OF COMPLETE PROGRAMS 
The main program enters a subroutine by means of a return jump. If 
there is to be any other communication between the subroutine and main 
program by way of exchange of arguments and results, it is carried out 
by advance agreement as to where arguments will be placed and results 
returned (accumulator, Q register, or the like). 
Example 8-18. We accomplish the derivative evaluation of the differ-
ential equation program of Example 8-14 by means of a subroutine of the 
type just introduced. Since the communication of data between the main 
program and subroutine in Example 8-14 was carried out by means of 
understood locations rather than by means of common symbolic addresses, 
no changes need be made in this part of the program. However, the return 
jumps to the subroutine will have to be altered. The derivative subroutine 
now takes the following form: 
SUBROUTINE D E R I V 
C 0 N ( T W 0 = 2 . O ) 
S T A ( T l ) 
STQ(T2) 
LAC(T2) 
F M U ( T l ) 
FAD(T2) 
F M U ( T W O ) 
E N D 
We note that the subroutine as well as the main routine must have a C 0 N 
statement since the pseudoinstructions of one are not available to the 
other. 
The main program can now enter the derivative subroutine with the 
instruction SLJ4(DRV), if it includes the pseudoinstruction 
LIB (DERIV = DRV) 
We note finally that the End statement number 25 cannot remain in 
the given position but must be moved to the new end point of the main 
program, and an additional End statement must follow that of the 
subroutine. 
Another means of exchanging information between subroutines and 
main programs is afforded by the Common 
statement, which we now 
describe. The use of the Common statement presupposes that a region of 
addresses has been set aside as a storage pool. The statement itself pro-
vides a list of symbolic addresses which are to be assigned to this storage 
pool, and takes the following form. 
C 0 M M 0 N A,B,C, · · · , D 
Here each of the letters A,B,C, · · *,D stands for any admissible symbolic 
address. If an array of addresses is to be assigned to the common storage 
pool, only the array name need be given in the list and the subscripts 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
335 
deleted. Thus, if we have stated 
D I M E N S I 0 N A(100) 
C 0 M M 0 N A 
all of the symbolic addresses A (I), 7 = 1, 2, · · ·, 100, as well as an address 
for the name A itself will be assigned to the common pool. The common 
pool starts from some fixed origin, and absolute addresses are assigned to 
the symbols in the list in a cumulative manner from this origin, in the 
order in which the symbols appear in the list. A list furnished by a second 
Common statement in the same main program or subroutine is to be re-
garded as a continuation of the list furnished by the first Common state-
ment. That is, storage will be assigned in sequence to the symbols of the 
second list from the point at which the first list terminated. Thus, in gen-
eral, we need only one Common statement in a single main program or 
subroutine. The Common statement can be placed anywhere, but any 
applicable dimension statements must precede it. 
If the main program and a subroutine are to exchange information by 
means of the common storage region, each must assign the symbolic address 
at which the information is stored to the common pool. The symbolic 
addresses used for the same item of information may be different. This is 
immaterial as long as symbolic addresses representing the same quantity 
are assigned to the corresponding position in common storage. 
Example 8-19. In a program for integrating a differential equation the 
derivative 
Tx
 = 
/(*'
 
V) 
is evaluated by means of a subroutine. In the subroutine the quantities x, 
y, dy/dx are stored at symbolic addresses T l , T2, T3, respectively. The 
main program puts χ and y in addresses X and Y, respectively, and expects 
to pick up dy/dx at address D Y D X . To handle the exchange of information 
we use the following two Common statements. 
C 0 M M 0 N X, Y, D Y D X 
C 0 M M 0 N T l , T2, T3 
The first is placed in the main program and the second in the subroutine. 
The effect is that symbolic addresses X, Y, D Y D X and T l , T2, T3, re-
spectively, are assigned to the same registers in the common storage pool. 
If we are to exchange information in this way between three or more 
program units, we must be careful when not all units are interested in the 
same information set. In such a case we can assign dummy addresses to 
the common pool in order to ensure that corresponding data addresses will 
be in corresponding positions in the Common statements. In effect, we 

336 
8. ASSEMBLY OF COMPLETE PROGRAMS 
then exchange the same data between all program units, but they need 
not all use the entire set of data. We will give an example of this in the 
next section. 
Many programs can be divided into segments such that each segment 
uses information which is not needed by any other segment. For programs 
of this type, we can economize on storage by not saving separate locations 
for such temporary information throughout the entire program. We ac-
complish this by assigning to the common storage pool the temporary 
data which can be used freely by any program segment. If no exchange of 
data between segments is involved, we need not worry about the position 
of the symbolic addresses in the common statement. We see that the rela-
tionship between the main program subroutine outlined above gives us 
the structure we need to implement segmentation. 
Example 8-20. A program has three segments. The symbolic addresses 
for temporary quantities used in each segment are given in the table below: 
Segment 
Addresses 
1. 
IA, IB, IC 
2. 
TEMPI, TEMP2, TEMP3 
3. 
A, B, C, D, Ε 
We consider Segment 1 the main routine and the remaining two as sub-
routines. The program has the following structure. We show only the first, 
last, and Common statements for each program unit. 
PR0GRAM 0ΝΕ 
C0MM0N IA,IB,IC 
END 
SUBR0UTINE TW0 
C0MM0N TEMPI,TEMP2,TEMP3 
END 
SUBR0UTINE THREE 
C0MM0N A,B,C,D,E 
END 
END 
8-3.4. An Example of Fortran Symbolic Coding 
We close the section on the Fortran Symbolic assembly program with 
an example of coding which illustrates the way in which the statements of 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
337 
this assembly language provide a structure that permits us to put together 
a program made up of many more or less independent items of coding and 
we consider the program for an interpretive system for complex number 
arithmetic. It 
consists of an interpretive 
control subroutine, 
called 
I N T E R P , and a set of related subroutines for carrying out various opera-
tions on complex numbers which the interpretive system is written to 
perform. The I N T E R P routine itself is presented as a subroutine since it, 
as well as its subroutines, will be subservient to a separate program from 
which the interpretive instructions are taken. The reader can review some 
of the elementary concepts of interpretive programming in Section 6-1.0 
and Example 6-1. 
The interpretive system to be coded is designed to simulate a complex-
arithmetic, single-address computer. The routines deal with complex 
numbers in either rectangular form x+iy 
or polar form Re**. The complex 
numbers are kept in the CDC 1604 memory with the real part a: in a register 
and the imaginary part y in the succeeding register for rectangular co-
ordinates. Alternately, the magnitude R is stored in a register with the 
angle θ in the succeeding one. 
A complex, or interpretive, accumulator is set up inside storage, as 
are several other miscellaneous registers. The symbolic addresses for these 
registers and their functions are listed in the accompanying tabulation. 
Symbolic address 
Function 
PAR 
Stores the real part of the complex accumulator 
PAI 
Stores the imaginary part of the complex accumulator 
MR 
Stores the real part of an operand currently addressed by an inter-
pretive-instruction 
MI 
Stores the imaginary part of an operand currently addressed by an 
interpretive-instruction 
OPBM 
Stores the current interpretive-instruction 
These registers are assigned to the common storage regions so that all of 
the subroutines of the system can have access to their content. 
The format of an interpretive-instruction is the same as that of the 
C D C 1604 op 
b 
m, and such an instruction may be placed in either the 
lower or upper position of a program step. As usual, the basic operand 
address m can be indexed to form the execution address M, where M 
= 
m + (B
b), 
and the designator values b = 0, 1, · · ·, 6 refer to the corre-
sponding index registers. The designator value b = 7, however, when 
used in an interpretive-instruction, does not refer to indirect addressing; 
instead, it defines the execution address M to be the complex-accumulator, 

338 
8. ASSEMBLY OF COMPLETE PROGRAMS 
no matter what the value of the base address m. The address M is identified 
with the real part, or the magnitude, of the complex number, and the 
address M + 1 with the imaginary part, or the argument. The I N T E R P 
routine always places the content of M in M R and that of M + 1 in M I . 
We give a list of all of the codes for interpretive operations which 
I N T E R P accepts and a description of the function performed for each 
such code. In the definitions of the interpretive-instructions, we will use 
M for the address of the complex operand, even though it is actually in 
both M and M + 1. Similarly, A will stand for the complex-accumulator. 
Since the interpretive-instructions will be part of a main program to be 
assembled by the Fortran Symbolic Assembly Program, the programmer 
must use only mnemonic codes in accordance with the rules of this Assembly 
Program. Thus, the mnemonic codes for the interpretive-operations must 
conform to those for machine language operations. In this way the assembly 
program will recognize the mnemonic operation codes and generate the 
corresponding machine codes. The choice of interpretive operation codes, 
which are also mnemonic codes for ordinary non-interpretive use, will 
permit the interpretive instructions to be handled within the framework 
of Fortran Symbolic Assembly. 
Mnemonic code 
Generated code 
Function 
ADD 
14 
(M) + (A) —* A, polar operands 
SUB 
15 
(A) — (M) —• A, polar operands 
MUI 
24 
(M) (A) —• A, polar operands 
DVI 
25 
(A)/(M) —> A, polar operands 
FAD 
30 
(M) + (A) —• A, rectangular operands 
FSB 
31 
(A) — (M) —> A, rectangular operands 
FMU 
32 
(A) (M) —» A, rectangular operands 
FDV 
33 
(A)/(M) —> A, rectangular operands 
INT 
62 
Transform (M) to polar form and store in A 
0 U T 
63 
Transform (M) to rectangular form and store in A 
Z R 0 
00 
Set (A) to zero 
LDA 
12 
(M) -* A 
STA 
20 
(A) — M 
ENQ 
04 
exp (M) —> A, polar operands 
ENA 
10 
exp (M) —• A, rectangular operands 
LIU 
52 
Log (M) —* A, polar operands 
LIL 
53 
Log (M) —» A, rectangular operands 
MEQ 
66 
1 (M) 1 —• A, polar operands 
MUF 
26 
1 (M) 1 —* A, rectangular operands 
SIU 
56 
(M)
1 /2 —• A, polar operands 
SIL 
57 
(M)
1 /2 —> A, rectangular operands 
SLJ 
75 
Terminate string of interpretive instructions with 
a direct jump to execution address. 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
339 
The subroutine I N T E R P is entered by a return jump to the symbolic 
address I N T E R P from the upper instruction of a program step in the 
main program. The lower instruction of this program step and all suc-
ceeding instructions are considered to be interpretive until the operation 
SLJ causes the interpretive program to be terminated by a direct jump to 
the execution address M. 
The codes for the I N T E R P subroutine, the subroutines POLRADD 
and POLRSUB (corresponding, respectively, to the operations A D D and 
SUB) and for four special purpose subroutines of the system, are given 
below. The codes for the remaining subroutines are given in Appendix G. 
Before presenting the codes and examining in detail the means by which 
the principal program and its related subroutines implement the inter-
pretive system we have just outlined, we discuss the way in which these 
routines are related to each other, how they communicate with each other, 
and how the assembly routine is made aware of the different subprograms 
and their relationships. First we take an inventory. The interpretive system 
recognizes twenty-two different operations. The coding for the SLJ, or 
terminating operation, is carried out in the I N T E R P subroutine itself. 
The remaining twenty-one operations are handled by means of twenty-one 
different subroutines, each of which is a primary subroutine of the I N T E R P 
subroutine. For convenience we introduce four secondary subroutines 
which are subservient to some of the twenty-one primary ones, so that 
we have a total of twenty-six including I N T E R P itself. The different 
kinds of references among these twenty-six routines are as follows : 
(a) I N T E R P refers to all twenty-one primary subroutines. 
(b) All primary subroutines refer to I N T E R P . 
(c) Some primary subroutines refer to secondary subroutines. 
(d) Some primary subroutines refer to other primary subroutines. 
(e) Some secondary subroutines refer to other secondary routines. 
By a reference we mean the use of the name of the subroutine as the sym-
bolic jump address in a jump instruction. 
In order for a main routine or a subroutine to be able to make a reference 
to another subroutine, it must include in a LIB pseudoinstruction both 
the name of the subroutine to be referred to, as given in that subroutine's 
name statement, and the symbolic address to be used in the instruction 
which makes the reference. In assembling a subroutine, the assembly 
program will preface it with an entry line just preceding the first line of 
the subroutine written by the coder. This program step, inserted during 
assembly, becomes the entry and exit point of the subroutine. In the con-
ventional way, it contains an unconditional jump instruction whose 
address part is to be filled from outside by a return jump, and a pass to the 

340 
8. ASSEMBLY OF COMPLETE PROGRAMS 
first instruction supplied by the coder. This entry to the subroutine is 
assigned a symbolic address equal to the name given in its name statement. 
During assembly a table of addresses corresponding to the names is formed. 
The LIB pseudoinstruction enables the assembly program to identify 
certain names in the program and to replace them at some convenient time 
with the addresses listed in the table. If no subroutine for a name given 
in a LIB pseudoinstruction is present in the code, the assembler will search 
the library tape for a subroutine with this name. If none is found, it will 
report an error to the coder. 
In order to implement references of type (a) mentioned above, the LIB 
pseudoinstruction at the beginning of the I N T E R P program lists all 
twenty-one primary subroutines. These primary subroutines, in turn, each 
contain a similar reference to I N T E R P 
= IN. This enables them to 
handle the connection of type (b). Since I N T E R P enters each of the 
primary subroutines by means of a return jump, each primary subroutine 
can transfer control back to I N T E R P via the preliminary program step 
inserted by the assembly routine. This program step is automatically set 
to transfer control back to that point in the I N T E R P routine at which 
the return jump originated. If such a return is employed, no mention of 
the name I N T E R P in a primary subroutine LIB pseudoinstruction is 
necessary. Under this technique, however, each subroutine will return to a 
different 
point in the I N T E R P routine. In the present case we wish to 
return from any primary subroutine to the same point in I N T E R P , namely 
the preliminary program step supplied to I N T E R P by the assembler. We 
see that the LIB pseudoinstruction in each primary subroutine permits a 
return to this point by use of the unconditional jump instruction SLJ (IN). 
Appropriate LIB pseudoinstructions in the subroutines make references 
of types (c), (d), and (e). If the subroutine referred to returns to the 
subroutine which made the reference by means of the return jump auto-
matically set up in its preliminary program step, it need not mention the 
higher level routine in a LIB pseudoinstruction. We find examples of all 
types of the references (a)-(e) in the subroutines given in the text. Pri-
mary subroutine POLRADD is mentioned in the LIB pseudoinstruction 
of the I N T E R P routine and, in turn, uses I N T E R P in its own LIB pseudo-
instruction. This routine permits POLRADD to return to the preliminary 
step of the I N T E R P routine with the unconditional jump SLJ (IN). The 
POLRADD subroutine also mentions two secondary subroutines with a 
return jump. Since each secondary subroutine accomplishes its return to 
POLRADD by means of the jump address which the return jump from 
POLRADD set up in its initial line, neither need mention POLRADD in 
a LIB pseudoinstruction. In fact, P O L R E C T (polar to rectangular) con-
tains no LIB instruction at all. R E C T P O L (rectangular to polar) makes 
use of two other secondary subroutines, SQRT and FATANF, and so it 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
341 
must mention them in a LIB instruction. Because these last two sub-
routines make no reference outside of themselves, they need, and contain, 
no LIB instructions. For an example of a reference from a primary sub-
routine to another primary subroutine, we note the routine POLRSUB, 
which used POLRADD. POLRSUB must refer to POLRADD in a LIB 
instruction, but the reverse is not necessary. 
From the remainder of the code in Appendix G, we see that the secondary 
routine R E C T P O L is also used by the primary routines POLARLOG and 
RECPOL, and the way in which this is arranged. We also note the following 
types of references and the means of handling them by LIB pseudo-
instructions. 
Primary R E C D I V uses primary R E C T M U L 
Primary POLREC uses secondary P O L R E C T 
Secondary SQRT is also used by primaries RECSQRT and R E C T M A G 
Secondary F A T A N F is also used by primary RECTLOG 
The I N T E R P program itself is a subroutine of the program from which 
it draws the interpretive instructions which it interprets and executes. 
This program must refer to I N T E R P in a LIB pseudoinstruction and 
enter it with a return jump. Similarly, any subroutine associated with 
the main program may refer to the I N T E R P routine provided it lists it 
in a LIB instruction. In Chapter 9 we will give an example of such a 
program. 
Finally, we note that some of our subroutines make use of standard 
programs from the library tape. For example, P O L R E C T uses library 
routines for the evaluation of both sine and cosine. In the manner in which 
these library routines are used, that is, in the form 
Symbolic address = Function name (Symbolic address) 
no LIB references are needed. If library routines are introduced by the 
appearance of their names as symbolic address parts of instructions, a 
listing of their names in a LIB reference will be necessary. 
We now examine the ways in which the many subroutines involved in 
the interpretive system exchange or share information. This process is 
carried out either through the use of the common storage region or by 
placing information in agreed-upon locations such as the Accumulator, 
Q-register, and Index registers which are accessible to all subroutines. 
I N T E R P 
and all of its primary subroutines share the 
following 
information : 
The content of the complex-accumulator in registers PAR, PAI 
The complex operand in registers M R and M I 
The interpretive-instruction in register 0 Ρ Β Μ . 

342 
8. ASSEMBLY OF COMPLETE PROGRAMS 
This is accomplished by placing the same common statement, namely 
C0MM0N PAR, PAI, MR, MI, 0ΡΒΜ 
in each of these routines. It is permissible to use other names for the 
registers containing this information in any of the subroutines, for example, 
the names CAMAG, CAARG for the complex-accumulator and MAG, 
ARG for the operand. If this is desirable in order to have more convenient 
mnemonic devices, the common statement will take the form 
C0MM0N CAMAG, CAARG, MAG, ARG, 0ΡΒΜ 
for the routines using polar operands. It is not the actual names used but 
the order in which these names are assigned to the region of common 
storage which is important. Thus, the I N T E R P routine places the real 
part (magnitude) of the content of the complex-accumulator in the first 
position in common storage, the imaginary part (argument) in the fourth 
position, and finally, the interpretive-instruction in the fifth position of 
common storage. It also assigns names as indicated in its common state-
ment to these five registers. In the other subroutines, any other admissible 
names may be assigned to these positions by means of a common state-
ment. The coder, however, must remember that no matter what name he 
assigns to the third register, for example, the register will still contain the 
real part, or the magnitude, of the interpretive operand, and he must write 
his code accordingly. For convenience, the common storage registers have 
been given the same symbolic addresses in all subroutines. 
The secondary subroutines of the interpretive system are written to 
find the data on which they operate in A and Q, and they return their 
results to these registers. Thus, the coder must take measures to place the 
correct values in A and Q before entering these routines after which he 
can obtain the result in these registers upon return. As an example, we 
note the secondary subroutine RECTPOL, which converts a complex 
number from rectangular to polar form. R E C T P O L expects to find the 
real part of the number to be converted in A and the imaginary part in Q. 
It deposits the magnitude of the converted number into A and the argument 
into Q. 
We see now that a senior programmer can assign each subroutine of the 
interpretive system to a different assistant, needing only a brief conference 
with each as to the function of the subroutine to be coded, the functioning 
of any related subroutine, the order in which information is to be found in 
common storage, and the fixed registers to be used for the exchange of 
data. The coder of primary subroutines must also know that the exit is 
to be accomplished by an unconditional jump. After the coding of the 
routines, another briefing to settle on the names of routines and the form 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
343 
of the lists in the LIB pseudoinstruction is needed. For example, the coder 
of the P O L R A D D routine must be told the names which the other coders 
have assigned to the routines he himself named IN, RP, and PR. In the 
present example, these names are respectively, I N T E R P , RECTPOL, and 
POLRECT. With appropriate LIB instructions inserted, the subroutines 
can then be combined in any convenient order and assembled. 
We now present the codes mentioned above, beginning with the main 
driving program, I N T E R P . Because of the various aspects of programming 
illustrated, we discuss the I N T E R P code in considerably more detail than 
we -have done with others, and for reference purposes we number the lines 
starting with the first machine instruction. 
S U B R 0 U T I N E 
I N T E R P 
L 0 C ( S T 0 P = 30) 
L I B ( P O L R E X P 
= P O L R E X P , RECTLOG 
= 
RECTLOG, 
POLRLOG = POLRLOG, R E C T E X P 
= 
R E C T E X P , 
COMLOAD 
= 
COMLOAD, 
POLRADD 
= 
POLRADD, POLRSUB = POLRSUB, P O L R M U L = 
POLRMUL, 
POLRDIV 
= 
POLRDIV, 
R E C T M A G 
= 
RECTMAG, R E C T A D D = R E C T A D D , 
RECTSUB 
= 
RECTSUB, 
R E C T M U L 
= 
R E C T M U L , 
R E C T D I V = RECTDIV, RECSQRT = RECSQRT, 
POLSQRT = POLSQRT, R E C P O L = RECPOL, POLREC = 
POLREC, POLRMAG = POLRMAG, 
ZRO = ZRO, CONSTOR = STA) 
CON (KO = 12700000B, K l 
= 06000000B, K3 = 700000B, 
K7 = 77777Β, 
Κ8 = 77777777Β) 
COMMON PAR, ΡΑΙ, MR, MI, OPBM 
STA(TA) 
ENA(O) 
ENA(L) 
SAU i l ) 
LDQ(*) 
I N A ( - I B ) 
ENAC3A) 
LDQ(K8) 
STQ(TQ) 
STA ( T E M P ) 
I N A ( - 3 B ) 
SAL (2) 
LLS(24) 
SAL ( T E M P ) 
SAUi*) 
STQ(MASK) 
3A 
LDQ(MASK) 
QLS(24) 
QJP2(3) 
R A O ( T E M P ) 
3 
ALS (24) 
LDL7 ( T E M P ) 
STQ(MASK) 
STA(OPBM) 
SLJ(4) 
STA(OPBM) 

344 
8. ASSEMBLY OF COMPLETE PROGRAMS 
4 
LDA(OPBM) 
SUB (KO) 
SUB ( K l ) 
LDA(OPBM) 
I N A ( - 2 0 B ) 
I N A ( - 5 5 B ) 
LDQ(K3) 
EQS(K3) 
LDA(PAR) 
LDA(PAI) 
5 
LDA7 (OPBM) 
RAO(OPBM) 
6 
STA(MI) 
ARS(18) 
SCL(K7) 
AJP(3A) 
AJP(3A) 
ARS (18) 
AJP4(STA) 
AJPO(IOO) 
LDL (OPBM) 
SLJ(5) 
STA (MR) 
SLJ (6) 
STA (MR) 
LDA7(OPBM) 
LDA(OPBM) 
AJP4(ZRO). 
C 
T H I S W I L L GIVE CONTROL TO T H E P R O P E R SUBROUTINE 
INA( - 4 B ) 
A J P 4 ( P O L R E X P ) 
• OP = 4 
INA( - 4 B ) 
A J P 4 ( R E C T E X P ) 
• OP = 10 
INA( - 2 B ) 
AJP4(COMLOAD) • OP = 12 
INA( - 2 B ) 
AJP4(POLRADD) 
• OP = 14 
INA( - I B ) 
AJP4(POLRSUB) 
• OP = 15 
INA( - 7 B ) 
AJP4(POLRMUL) 
• OP = 24 
INA( - I B ) 
AJP4(POLRDIV) 
• OP = 25 
INA( - I B ) 
AJP4 (RECTMAG) • OP = 26 
INA( - 2 B ) 
AJP4 (RECTADD) • OP = 30 
INA( - I B ) 
AJP4(RECTSUB) 
• OP = 31 
INA( - I B ) 
A J P 4 ( R E C T M U L ) • OP = 32 
INA( - I B ) 
AJP4(RECTDIV) 
• OP = 33 
INA( - 1 7 B ) 
AJP4(POLRLOG) 
• OP = 52 
INA( - I B ) 
AJP4(RECTLOG) 
• OP = 53 
INA( - 3 B ) 
AJP4(POLSQRT) 
• OP = 56 
INA( - I B ) 
AJP4(RECSQRT) 
• OP = 57 
INA( - 3 B ) 
AJP4(RECPOL) 
• OP = 62 
INA( - I B ) 
AJP4(POLREC) 
• OP = 63 
INA( - 3 B ) 
AJP4(POLRMAG) • OP = 66 
P R I N T 1000 
1000 
F 0 R M A T ( 2 2 H AO P - C 0 D E AN 0 T AI N AT A B L E A) 
SLS1 (ST0P) 
Z R 0 ( * ) 
100 
L D A ( 0 P B M ) 
SAU(lOl) 
LDA(TA) 
LDQ(TQ) 
101 
SLJ(*) 
E N D 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
345 
We note first of all the structure of the subroutine. It begins with a 
Name statement and concludes with an End statement. Immediately 
following the Name statement, we have all of the Fortran symbolic pseudo-
instructions, LIB to list all primary subroutines, C0N to introduce some 
useful constant parameters, and L0C to provide an absolute address for 
an error exit. The LIB and C0N pseudoinstructions are too long for one 
card, and they are extended onto continuation cards. The pseudoinstruc-
tions are followed by a Common statement, and the remaining lines of the 
subroutine follow this statement. We recall that when the code is assembled, 
the assembly routine will inset a word at line zero and store this line in a 
register whose symbolic name is the one given in the subroutine Name 
statement, in this case I N T E R P . The upper instruction at address 
I N T E R P will be an unconditional jump with the lower one a pass to line 
one. Thus, on a return jump to I N T E R P , the return address is placed in 
the upper address part of register I N T E R P and execution of the subroutine 
begins with line one. 
Line 1. 
Save (A) and (Q). 
Line 2. 
Set (A) to zero and ( T E M P ) to zero. 
Line 3. 
Set (A) to the value of the absolute address assigned to the 
word at line 3 and subtract 3 from this address. This leaves 
(A) 
equal to the absolute address corresponding to the 
symbolic address I N T E R P . 
Line 4. 
Set the upper address of the program step tagged 1 to the 
value of the absolute address corresponding to I N T E R P , 
and set the lower address of the program step tagged 2 to 
the same value. 
Line 5. 
This line is tagged 1 for reference. Its function is to place the 
word at address I N T E R P into Q and shift it so that the 
upper address of the word, which is the return address to the 
main program, is positioned in the low order part of A. 
Line 6. 
Subtract one from (A) 
and store the low order 15 bits of 
(A) in T E M P . The effect of this is to set ( T E M P ) equal to 
the address of the current interpretive-instruction. 
Line 7. 
This Une is tagged 2 for reference. Its function is to put 
whatever value the assembly program assigns to the tag 
3 A into A and store it as the upper address of the word 
I N T E R P at line zero, so that when a primary subroutine 
returns control to I N T E R P , the interpretive routine will 
not, in turn, surrender control to the main program at the 
line following the current interpretive-instruction. Instead, 

346 
8. ASSEMBLY OF COMPLETE PROGRAMS 
I N T E R P will retain control, jump to the program step 3 A, 
and continue with interpretive-instructions. 
Line 8. 
Put the twenty-four bit mask for a lower instruction in Q 
and store it at address MASK. Note that this program step 
assumes that the return jump from the main program was 
an upper instruction. 
Line 9. 
This line is tagged 3 A to permit a reference to the entry of 
the loop beginning here. The loop is for processing the current 
interpretive-instruction. The function of the program step 
stored here is to put the current mask into Q and form the 
logical product with the interpretive-instruction. This is 
accomplished by means of indirect addressing, since T E M P 
contains the address of the interpretive-instruction. In this 
way, the current interpretive instruction is put in A. 
Line 10. 
This shifts the mask to an upper instruction mask if it was a 
lower instruction mask, or vice versa, and places the next 
version into register MASK. Note the use of circular shifting. 
Line 11. 
If (Q) is positive, that is, if the current interpretive instruc-
tion is from the upper part of a main program word, control 
is sent to the word tagged 3. If the instruction is from the 
lower half of the main program step, it is transferred from 
register A to register 0ΡΒΜ. This register is assigned to the 
common storage region. 
Line 12. 
This advances the value of the address in T E M P by 1. If the 
current interpretive instruction is from the lower half of a 
program step (as it must be if control comes to this line), 
the next interpretive instruction must come from a register 
with address one greater than that of the current one. This 
address is kept in T E M P , whose content is now adjusted. 
Line 13. 
This line is tagged 3. If control gets here, the current inter-
pretive instruction is in the upper instruction position. It is 
shifted to the lower position and transferred to register 
0ΡΒΜ. 
At this point in the subroutine, register 0ΡΒΜ contains the current inter-
pretive instruction in its low order twenty-four bits. It does not matter 
whether this instruction came from the upper or lower part of a word in 
the main program. Register T E M P has the address of the next interpretive 
instruction. We recall that the content of this register is not advanced if 
the current interpretive instruction is from the upper part of the register. 
Register MASK has the interpretive instruction mask correctly positioned 
for the next case. 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
Line 14. 
This line is tagged 4. Its function is to place the current 
pseudo-instruction into A and set the address part to zero, 
leaving only the operation code and designator in A . 
Line 15. 
If the current operation code and designator are 12 7, con-
trol goes to the word tagged 3^4 to initiate the succeeding 
interpretive-instruction. Thus, in effect, 12 7 
(arbitrary) 
is a do-nothing instruction. This is correct, since this opera-
tion with a 7 designator is to load the complex-accumulator 
from itself, regardless of the value assigned to the address 
part of the instruction. 
Line 16. 
If the current interpretive operation code and designator 
are 20 7, go to 3 A to initiate the succeeding interpretive 
instruction. This avoids storing the complex accumulator 
from itself, which is, in effect, a do-nothing instruction. 
Line 17. 
This puts the current interpretive instruction back into A 
and shifts the operation code part into the lower order six 
bit positions. 
Line 18. 
If the interpretive operation code is 20, control goes to sub-
routine STA to execute the interpretive instruction. Sub-
routine STA will transfer control back to S A to initiate the 
succeeding interpretive instruction. 
Line 19. 
If the interpretive operation code is 75, control jumps to 
tag 100 at line 51. At lines 51 and 52, an unconditional jump 
to the address given in the current interpretive instruction is 
set up and tagged 101. The program step tagged 101 at line 
53 is then executed. This terminates the I N T E R P subroutine 
in accordance with the definition of the 75 interpretive 
operation. 
Line 20. 
This extracts the designator part of the current interpretive 
instruction in the accumulator. 
Line 21. 
If the designator is equal to 7, the sequence is continued, 
otherwise a jump is made to the program step tagged 5. 
Line 22. 
The real part or magnitude of the current operand in M R 
is set equal to the real part, or the magnitude, of the content 
of the complex accumulator. 
Line 23. 
The imaginary part, or argument, of the current operand in 
M I is set equal to the imaginary part, or argument, of the 
complex accumulator. 
Line 24. 
If the designator part of the interpretive instruction is 7, 
this line, tagged 5, and the following line will be skipped. 
The function of the line is to store the real, or polar part, of 
the operand addressed by the current interpretive instruction 
in register MR. 

8. ASSEMBLY OF COMPLETE PROGRAMS 
LDA(MR) 
AJP(2) 
LDA(PAR) 
AJP1 (4) 
L D A ( M R ) 
STA (PAR) 
LDA(MI) 
STA (PAI) 
SLJ(2) 
ZRO(*) 
4 
LDQ(PAI) 
SLJ4(PR) 
STA (PAR) 
STQ(PAI) 
L D A ( M R ) 
LDQ(MI) 
SLJ4(PR) 
ZRO(*) 
STQ(MI) 
FAD (PAR) 
STA (PAR) 
LDA(PAI) 
FAD (MI) 
STA(PAI) 
LDA(PAR) 
LDQ(PAI) 
SLJ4(RP) 
ZRO(*) 
STA (PAI) 
STQ(PAR) 
348 
Line 25. 
Line 26. 
Line 27. 
Lines 28-46. 
Lines 47-19. 
The imaginary part or argument of the operand addressed 
by the current interpretive instruction is stored in register 
M L 
The imaginary part, or argument, from either the complex 
accumulator or the register addressed by the current inter-
pretive instruction is stored at M L 
If the interpretive operation is ZR0, control is transferred 
to subroutine ZR0. 
These lines check the interpretive operation code and transfer 
control to the correct subroutine as indicated in the comment 
appended to each. 
If control gets to this line, the interpretive operation code 
is undefined, and an error message, "OP-Code not in table," 
is printed and the program either stops, if the option to do 
so has been selected, or it transfers control to absolute 
address 00030. We assume that address 00030 is the entry 
point to an appropriate routine, which terminates the current 
problem with the undefined operation code and initiates the 
succeeding problem. 
We present the six associated subroutines below and leave it to the 
reader to analyze their structure and those of the remaining ones in Ap-
pendix G. 
SUBROUTINE POLRADD 
LIB ( I N T E R P = IN, R E C T P O L = RP, P O L R E C T = PR) 
COMMON PAR, PAI, MR, MI, OPBM 

8-3. 
FORTRAN SYMBOLIC ASSEMBLY PROGRAM 
349 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE POLRSUB 
LIB ( I N T E R P = IN, POLRADD = 
PAD) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MI) 
FAD (3.1415926536) 
STA(MI) 
SLJ4(PAD) 
E N D 
SUBROUTINE P O L R E C T 
R I N ACC, T H E T A IN Q. G E T X IN ACC, Y IN Q. 
STA(R) 
STQ(TH) 
Y = 
S I N F ( T H ) 
X = 
COSF(TH) 
LDA(Y) 
F M U ( R ) 
STA(Y) 
LDA(X) 
F M U ( R ) 
LDQ(Y) 
E N D 
SUBROUTINE R E C T P O L 
LIB(SQRT = SQ, F A T A N F = 
FA) 
X I N ACC, Y I N Q-REG. G E T T H E T A I N A, R I N Q-REG. 
STA(X) 
STQ(Y) 
SLJ4(SQ) 
ZRO(*) 
LDQ(X) 
STA(X) 
LDA(Y) 
SLJ4(FA) · F I N D T H E T A IN - P I TO 
+ P I 
R A N G E 
LDQ(X) 
E N D 
SUBROUTINE FATANF 
C O M P U T E W = ARG(Z) = A R C T A N ( Υ / Χ ) , Y IN ACC, X 
I N Q-REG 
- P I LESS T H A N ARG(Z) IS LESS T H A N OR EQUAL TO + P I 
CON (PI = 3.1415926536, PI2 = 
1.5707963268) 
STA(Y) 
STQ(X) 
Q J P K l ) 
AJP(4) 
AJP2(5) 
LAC(Y) 
FDV(Y) 
F M U ( P I 2 ) 
S U (4) 
ZRO(*) 
2 
C 
C 
C 
C 
5 

350 
8. ASSEMBLY OF COMPLETE PROGRAMS 
1 
F D V ( X ) 
STA(W) 
W = 
ATANF(W) 
LDA(W) 
ENI(*) 
LDQ(X) 
QJP2(4) 
LDQ(Y) 
QJP1(2) 
LDA (PI) 
SLJ (4) 
2 
QJP3(3) 
FAD (PI) 
SLJ (4) 
ZRO(*) 
3 
FSB(PI) 
SLJ (4) 
4 
E N D 
SUBROUTINE SQRT 
C 
HAVE X IN ACC A N D Y IN Q-REG - · - G E T S Q R T F ( X * X 
+ 
Y*Y) IN ACC AT E X I T 
STQ(Y) 
STA(X) 
F M U i X ) 
STA(X) 
LDA(Y) 
F M U ( Y ) 
F A D ( X ) 
STA(X) 
Y = 
SQRTF(X) 
LDA(Y) 
E N D 
E N D 
Exercises 
Section 8-2 
1. 
Write the programs of Examples 4-20, 4-32, and 4-42 for assembly by 
CODAP, using the three letter mnemonic code for instructions. 
2. 
Assemble in absolute form the symbolic codes you have written in 
Problem 1. What kinds of things must the assembly program take 
into account to do this? 
Section 8-3 
3. 
Which of the following are admissible tags for a Fortran symbolic 
program? 
(a) 1GO 
(b) I N 
(c) 2 E N T R A N C E 
(d) 2 E X I T 
(e) 1GO + 2 
(f) 256 
4. 
Suppose that 1TAG is finally set at 10000 and storage of any necessary 
constants starts at 20000. Give a final assembled version of the follow-
ing sequence of instructions, which are not intended to form a coherent 

EXERCISES 
351 
program. Use any reasonable absolute addresses for the symbolic 
addresses. 
1TAG 
SLJ(*) 
ENI2(12B) 
FAD(1.25E2) 
ENA(16) 
ENQ(3777B) 
LLS(48) 
E N I 1 ( - 1 2 ) 
LDA(1.25) 
STA(X) 
STA (LAST) 
LDL(LAST) 
SLJ(L - 
5) 
5. 
Repeat the instructions of Problem 4 for the following sequence. 
U N 
ENI1(25) 
E N A ( l ) 
1LOOP 
STA1(L25) 
A D D ( l ) 
I J P l ( l L O O P ) 
SLJ(L + 
1) 
LDA(2.5) 
FMU1(5.2) 
STA (ALPHA) 
FAD (BETA) 
SLS(IIN) 
ZRO(*) 
6. 
Write the programs of Examples 4-20, 4-32, and 4-42 in Fortran 
Symbolic form. 
7. 
Assemble in absolute form the symbolic codes you write for Problem 6. 
8. 
Write a code in Fortran Symbolic form to solve the equation x
z 
+ 
χ — 1 = 0 for the real root between zero and one. Use Newton's 
method with fixed point integral scaling. 
9. 
Assemble your code of Problem 8 in absolute form. 
10. Redo Problem 8 using floating point operation. 
11. Assemble your code of Problem 10 in absolute form. 
Section 8-3.0 
12. The CON pseudoinstruction stores the listed members at consecutive 
addresses. Use this fact to write a CON pseudoinstruction which will 
store a five dimensional vector in which the component vn = n. 
1 3. A two by two matrix is 
2.5 
1.3 
- 2 . 7 
5.4 
Use a C 0 N pseudoinstruction to store it by rows and another to 
store it by columns. 
14. Use the necessary C 0 N pseudoinstructions and write a Fortran 
Symbolic program to form and store the sum of two five component 
vectors, using your own decimal values for the components. Include a 

352 
8. ASSEMBLY OF COMPLETE PROGRAMS 
H0L pseudoinstruction to store the codes for the words VECTOR 
ADD. 
15. Write a program to form and store the square of the matrix of Problem 
13 with storage of all matrices by columns. 
Section 8-3.2 
16. Write the programs of Problems 14 and 15 as complete programs in-
cluding the necessary Name and End statements. 
17. Write a complete program in Fortran Symbolic to take the square 
root of a floating point operand. Include Name and End statements. 
18. Redo the program of Problem 17 as a subroutine. 
19. Write a complete program to find the roots of a quadratic equation 
ax
2 + bx + c = 0 where a 9
e 0, b, and c are in storage. Include the 
subroutine of Problem 18 as a subroutine of the main program. As-
sume b
2 — 4ac > 0. 
20. Redo Problem 19 to take care also of the case b
2 — 4ac < 0. Introduce 
any necessary subroutines. 
21. Redo Problems 19-20 to take care of the possibility that a = 0 but 
b 
0, introducing any necessary subroutines. 
Section 8-3.3 
22. Redo Problems 19, 20, and 21 with entry to the subroutines by means 
of return jumps. Include the necessary LIB pseudoinstructions. 
Section 8-3.4 
23. Complete Problems 19 and 20 by including the necessary input and 
output statements for one quadratic equation. 
24. Write your own version of the I N T E R P routine. 
25. Write your own complete versions of the necessary subroutines for 
the various functions related to I N T E R P . Compare your results with 
the programs given in Appendix G. 
26. Write an interpretive program in Fortran Symbolic, using no 
floating 
point instructions, which will have the capabilities of the direct 
instructions. 
27. Write an interpretive program in Fortran Symbolic which will supply 
vector addition, subtraction, inner product, magnitude, and cosine of 
the angle between two vectors. 

CHAPTER 9 
Fortran; Mixed Language 
Programs 
9-0. Introduction 
In Chapters 7 and 8 we have seen that by placing the necessary burden 
of translation on the computer we can present data in a form very different 
from the absolute digital machine language instructions and operands 
required in the arithmetic and control registers of the machine itself. 
Thus we are permitted the convenience of decimal digits, minus signs, 
decimal points, and the like, in place of the seven's complement octal 
numbers which we used in our earlier programs. Furthermore, we can 
initiate input and output by the use of such statements as Read or Print, 
followed by appropriate lists of symbols, instead of writing our own routines 
or using a jump instruction to a fixed, absolute address. We have also intro-
duced the use of instructions with operation codes in mnemonic form and 
addresses in symbolic form. One assumption has been that the routine 
residing in the computer, which we have called a translator or assembly 
program, enables us to write programs and present information in a manner 
which resembles our own language and way of thought more closely than 
the basic machine language does. We must not forget, however, that every 
sequence of instructions which the computer carries out must eventually 
be in terms of the absolute instructions which we first considered and which 
are the only ones which can be directly entered into the control registers 
of the machine. This is true of the translator and assembly program itself. 
Furthermore, such programs must have additional capabilities beyond a 
one-for-one translation from symbolic form to machine form and assembly. 
For a program of this sort to be able to accept a Read statement which 
will actually read in, translate, and store the required data, it must be 
able to compile an input program along with the program containing the 
353 

354 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
Read statement. That is, it must select a proper subroutine from the 
library and assemble it for final execution. The objective or absolute code 
which it compiles will be similar in form to those of the examples of Sec-
tion 7-1. Thus, in general, the statement is replaced by a program which 
may involve a large number of program steps. Because of its ability to 
produce programs of this sort, the resident routine is often called a compiler, 
and because of the many program steps which may be required, the ac-
ceptable statements are sometimes referred to as macroinstructions. 
Many compiling programs have been written, usually with two main 
objectives in mind. One of these objectives is simply to extend the ideas 
we have already introduced: to facilitate input and output and let the 
computer itself carry much of the burden of tedious and error-producing 
steps of assembly. That is, in the same way that the compiler permits a 
more convenient Read or Print statement in place of the necessity of 
writing an objective input or output program, it will carry this idea to the 
other aspects of programming, including the ultimate computational, 
logical, and housekeeping functions involved. In this respect compilers 
are designed to process programs written in terms of statements which 
are much closer to the way in which the human being is accustomed to 
define his problems. For this reason, the collection of statements accepted 
by various compilers are generally referred to as problem-oriented 
languages 
as opposed to the computer-oriented or absolute machine languages. 
In addition to this aspect of providing a simpler language for the human 
programmer, the other main objective of problem-oriented languages is 
universality. The necessary compiling routines are written in such a way 
as to make the statements of the basic language as independent as possible 
of the particular computer being used. Although basic design similarities 
can often be found, and repertoires of instructions will all contain, in 
some form, certain fundamental similarities, the specifics of computer 
design and organization produce obvious distinctions between computers. 
These dissimilarities will require that a programmer transferring from one 
machine to another learn a new language with syntax and grammar similar 
to, but distinct from, the old one. Thus, a major objective in the writing 
of compilers is to produce a common language which can be made intel-
ligible to a large class of both computers and programmers. 
Many such languages and their associated compilers have been de-
veloped, as, for example, Fortran, Algol, and Cobol. The names given to 
these languages usually reflect the intent of the people who introduced 
them. For instance, Fortran, which is the language of the statements we 
considered in Chapters 7 and 8 is a contraction of Formula Translation. 
In modern practice, the programs which compile the necessary objective 
programs will be part of a larger whole which will also include executive 

9-0. 
INTRODUCTION 
355 
or monitoring 
programs. These latter programs are designed to make the 
computer less dependent on direct supervision and operation by a human 
operator. Thus, a number of programs can be stacked and loaded and 
their actual execution will then proceed under control of the monitoring 
programs which will arrange for each to be compiled and executed with a 
minimum of supervision from an external source. Such generalized pro-
grams provide what is popularly called the "software" which is capable of 
extending and making more flexible the basic "hardware" or actual cir-
cuitry which utilizes the absolute machine codes of the basic repertoire of 
the computer. The use of such "software" makes the practical technique 
of writing programs very different from the earlier days of computing in 
which all programs were written in absolute codes or for assembly programs 
with ability to do little more than translate limited symbolic instructions. 
We must remember, however, that no matter how universal the problem-
oriented languages may appear to their users, the actual compiling pro-
grams which permit them will be very distinct. The machine language 
programs which accept, translate, compile, and execute Fortran state-
ments in a CDC 1604, an IBM computer or a UNI VAC computer will be 
very different from each other. Furthermore, even to the user there will 
be distinctive aspects of the language based on individual register capacity, 
total number of registers, the ability and predilections of the compiler 
programmer, and the like. Thus, such things as the number of permissible 
characters in symbolic addresses, the magnitudes of integers and 
floating 
point numbers, and other idiosyncrasies will have to be learned for each 
new computing laboratory. 
It is evident that the compilers themselves are lengthy and complicated 
combinations of basic instructions which are far beyond the complexity 
of any program explicitly considered in this book, although individual 
pieces of them will resemble programs which we have considered. We make 
no attempt to give a detailed account of the structure of compilers, but 
we shall give some examples of how they function in particular instances 
and show how one of them is used. 
For the occasional user of a computer, the problem-oriented languages 
come as close to an ideal solution as we now have. A physicist with a 
differential equation to solve can learn a minimum of such a language and 
produce, usually after some consultation with an experienced programmer, 
an adequate result. Anyone who consistently uses a computer, however, 
will have to delve more deeply. In spite of the relative ease of writing a 
program, the exclusive use of a language such as Fortran is often inade-
quate. There are many reasons for this. The total number of runs and time 
involved to execute an individual program run may require a more efficient 
program than one supplied by a compiler, which, in order to achieve its 

356 
9. FORTRAN) MIXED LANGUAGE PROGRAMS 
generality, must make compromises. Unorthodox problems may require 
program facilities which have not been supplied. In any event, a good 
programmer will be able to use all techniques of programming: the absolute 
machine codes, the problem-oriented languages, and, very frequently, a 
mixture of the two. He will take advantage of all available help by using 
the more convenient mnemonic and symbolic forms, but he will under-
stand the structure and function of the ultimate absolute codes and the 
manner in which a particular machine handles them and will write his 
program with this in mind. For convenience we provide a list of the Fortran 
statements considered in Chapters 7 and 8, as distinct from the pseudo-
instructions and symbolic machine language statements. A brief descrip-
tion of their function and that of others to be introduced can be found in 
Appendix F. 
FORMAT 
D I M E N S I O N 
R E A D 
P U N C H 
R E A D I N P U T T A P E 
W R I T E 0UTPUT T A P E 
P R I N T 
E N D F I L E 
R E W I N D 
BACKSPACE 
C0MM0N 
9-1. Fortran Programs 
We now consider programs written completely in Fortran, that is, 
programs utilizing only the statements in the list above and additional 
statements to be introduced. These programs will contain no machine 
language instructions or pseudoinstructions. In all cases, the kinds of 
data to be admitted conform to the previous descriptions of decimal 
integers, octal integers, and so on. In addition, the same rules apply for 
the assignment of symbolic addresses and address arrays. In this regard 
we recall that the relation between the address of a register and the con-
tent of a register is that of an independent and a dependent variable in a 
mathematical function. Thus, the specification of a symbolic address such 
as ALPHA also specifies the current content of the register and hence the 
value of the function, just as we let the functional notation stand also for 
its value. With symbolic addresses we will dispense with the "content of" 
notation and let the address specify the content. For this reason symbolic 

9-1. 
FORTRAN PROGRAMS 
357 
addresses are frequently called variables, and we shall see that they can 
be used as such in mathematical expressions. From this point of view, 
the variables associated with symbolic addresses will have an internal 
structure consistent with the address mnemonics; that is, variables related 
to addresses beginning with I, J, K, L, M, or Ν will be integers internally, 
while those related to addresses beginning with the other letters will be 
stored in internal floating point format. The use of a symbolic address as 
a symbol for the variable stored at the address proves convenient in per-
mitting the programmer to approach a mathematical problem from a 
mathematical point of view. For this reason we shall use the terms symbolic 
address and variable more or less interchangeably. Since we must also keep 
in mind the way the computer functions, however, we should always 
remember this dual role. 
Each Fortran program will consist of a sequence of statements, just as 
our very early programs consisted of sequences of machine instructions. 
These statements will include those already introduced, as well as others 
which we introduce in this chapter. They will be of two kinds: (1) those 
which can be executed, such as the Read and Print statements, and (2) 
those which are merely for reference by the compiler, such as the Dimen-
sion statement. We may also use remarks which are for the information 
of the programmer himself and not processed by the compiler. We can 
assign statement numbers to any statement, but in general we will assign 
them only to those statements which are specifically referred to in the 
program, such as the Format statement. Such statements as Dimension 
and Common will not require them. The structure of a complete Fortran 
program follows the pattern of the Fortran Symbolic programs of Chapter 
8. We assume as the basic input medium for statements a punched card 
and shall review the specific function of each column of an eighty column 
card. 
1. Column 1 is used to identify a comment card. The presence of a C 
in this column indicates to the compiler that the card is not to be processed. 
2. Columns 1-5 are used to specify a statement number in the range 1 
through 99999. Statement numbers may be assigned arbitrarily and do 
not need to be in numerical order. The only restriction is uniqueness, so 
that no number corresponds to more than one statement. 
3. Column 6 is used to indicate a continuation card; that is, if the length 
of a statement exceeds the allotted number of columns in a single card, it 
may be continued on the next card by an appropriate indication in column 
6. The rule is that the first card has column 6 blank or equal to zero, but 
each successive card is numbered in column 6 from 1 through 9 consecu-
tively. Thus, a total of ten cards may be used for one statement. 

358 
9. FORTRAN) MIXED LANGUAGE PROGRAMS 
4. Columns 7-72 are used for the statement itself. With the exceptions 
previously noted, blanks, or spaces, in these columns are ignored. Con-
tinuations of statements should also be punched in columns 7 through 72 
of the continuation cards. 
5. Columns 73-80 are not processed by the compiler, and may be left 
blank or utilized for serializing the cards or the like. 
Example 9-0. We start a program with its name, a comment on its 
purpose, and an input statement with its related information statements. 
These appear in columns as follows : 
1 2 3 4 5 6 7 
72 73 
80 
PROGRAM E X A M P L E 
1 
c 
T0 CLARIFY CARD F0RMS 
2 
D I M E N S I O N AIM (20) 
3 
READ 100, MAN, 
4 
1 (AIM(I), I = 1, 10) 
5 
1 0 0 
F0RMAT(I6/1OE8.2) 
6 
P R I N T 100, MAN, (AIM(I), I = 1, 10) 
We see that one C was required for the comment card and one statement 
number for the format statement which is referred to in the Read and 
Print statements. The continuation of the address list on a second card in 
the Read statement is for illustration only. We have used the unprocessed 
columns 73-80 to assign a serial number to each card. We note that the 
commas which we used previously for clarity around the slash in a Format 
statement are not required, although they may be included. 
The sequence of steps in Example 9-0 does not constitute a complete 
Fortran program. For one thing, there are no End statements. The End 
statements are used in the same way as in Fortran Symbolic, that is, each 
subprogram is followed by its own End statement and the final one is 
followed by an additional End statement for the program as a whole. The 
example serves to illustrate two points, however. 

9-1. FORTRAN PROGRAMS 
359 
1. The general pattern of sequencing in Fortran is like that of an im-
plicit computer. That is, unless altered by a control statement, the se-
quencing is from one statement which can be executed to the next in order. 
Thus in Example 9-0 the two executable statements would be carried out 
in order, Read and then Print. It is apparent that we will need the analog 
of the jump instructions, and we consider these in the following sections. 
2. The splitting of the short Read statement is unnecessary but shows 
that we can split long statements (to a maximum of 660 total characters) 
and that we can use spaces liberally. 
If we write and punch a program in Fortran without data, but with 
input and output statements, we can submit this program to the compiler, 
which will provide the necessary objective program. With the objective 
program in operating location we supply the data cards to be read. The 
objective program then carries out the necessary computations and, on 
the basis of the output statements, produces the results in a suitable form. 
If the objective program is to be executed immediately, we would of course 
submit both the program and the data at the same time. The objective 
program may not be capable of operation independently of the overall 
operating system in which the compiler is embedded. Considerable flex-
ibility is possible, however, in the manner in which the objective source 
program is provided. It may be produced in operating storage, on a card 
deck in an assembly relocatable version suitable for loading, or perhaps a 
version on magnetic tape. In any event, the input of data is carried out 
only after the machine language program has been compiled, assembled, 
and is in operating storage. 
The format conventions of a problem-oriented language are just as rigid 
as those of machine language. For this reason, any device which helps to 
eliminate errors is useful. Most programs will be handwritten by the pro-
grammer and then transcribed on cards either by the programmer himself 
or a professional keypunch operator. The transcription steps can produce 
needless error. For this reason, certain aids are available, and certain pre-
cautions should be taken. To match the card there are available forms 
which show each column and its functions, these forms will materially aid 
the one who punches the cards. Furthermore, certain symbols are easily 
confused and we should always make clear to ourselves and others which 
ones we mean, as for example, the use of 0 to distinguish the alphabetical 
character from zero. Other symbols which are easily confused in writing 
are the letter Ζ and the numeral 2, and the use of the European Ζ will 
help to avoid error. The digit one and the letter I and the digit five aatl 
the letter S should be carefully distinguished. 

360 
9. 
FORTRAN; MIXED LANGUAGE PROGRAMS 
9-1.0. Fortran Arithmetic Statements 
Just as the combination of symbols R E A D provides the compiler with 
the information necessary to institute an input program, so also appro-
priate combinations of symbols can be used to provide the information to 
institute programs which will evaluate arithmetic expressions. Because of 
notational limitations of transcription media this will vary somewhat from 
the standard mathematical notations. Furthermore, since these new 
symbols represent information to the compiler, their meaning will not 
always be the exact equivalent of the corresponding mathematical symbols. 
The reader should note the distinctions carefully and keep them firmly in 
mind when writing programs. 
The direct arithmetic operations available in F O R T R A N are addition, 
subtraction, multiplication, division, and exponentiation or raising to a 
power. The mathematical operations and the equivalent Fortran notations 
are listed in the accompanying tabulation. 
Mathematical 
Fortran 
a + 
b 
A + Β 
a — b 
A - Β 
ab 
or 
a X b 
or 
ο·6 
A*B 
α 
-τ- b 
a 
or 
- 
or 
a/b 
b 
A/B 
a
b 
A**B 
In the Fortran column we have used symbolic addresses which correspond 
in a natural way to the numbers for which we might, mathematically, use 
the symbols a and b. The expression A + Β actually is an instruction for 
the computer to add the content of the register with address A to that of 
the register with address B. We have already pointed out, however, that 
the symbolic address of a number may also constitute a mathematical 
symbol for the number, so that we can think of A + Β as also meaning 
"add the number A to the number B . " The specific arithmetic notations 
listed above must be used. We are not permitted, for example, to use AB 
or Α · Β in place of A*B, although we are permitted the flexibility of using, 
if we like, the symbolic address AB for the register which will hold the 
product even though the symbol will not produce the product. In general, 
any correct symbolic address symbols for variables may be used. For 
instance, we may write JACK + JILL. In this connection it is important 
to remember that the variables are stored in the computer in either floating 

9-1. 
FORTRAN PROGRAMS 
361 
point form or as integers, and the symbols we choose for variables must 
conform with the symbols we use for their storage addresses; that is, we 
must observe the rules given in Section 7-2.2. We must also remember 
that in writing machine language programs we do not get correct results 
if we use floating point instructions to obtain operations on fixed point 
integers. This same reasoning carries to combinations of variables repre-
sented by their symbolic addresses; that is, we should not attempt to com-
bine quantities in a manner which is inconsistent with the way in which 
they are handled internally by the computer. Thus, we may correctly 
write ALPHA + BETA, but we may not use ALPHA + IOTA. 
In addition to symbolic addresses in mathematical statements, we may 
also use numerical values. Again we must observe precautions to conform 
with the way in which symbolic addresses are treated by the compiler. 
We may write V + 2. In order to increase the content of V by two, but 
not V + 2, since the latter would be a command to combine an internal 
floating 
point number with an internal fixed point number, which the 
compiler will reject. On the other hand, we may use I L K + 2 but not 
I L K + 2. for combining internal fixed point operands. For another ex-
ample, X*2 is not correct since it makes no sense to multiply a 
floating 
point operand by a fixed point operand, but X**2 is permissible because 
it does make sense to square a floating point operand. In exponentiation, 
integers (no decimal point) may be used as exponents on all types of 
operands and are required for negative ones, but only internal 
floating 
point operands may have floating point exponents. 
The order in which operations are carried out in a single expression 
determines the final result, and we should be very careful to write the 
expression in such a way as to obtain what we intend. The order is given 
by the following rules. 
1. Expressions in parentheses are evaluated first. 
2. All operations are carried out in the prescribed order from left to right. 
3. The order for operations is : 
(a) Exponentiation first 
(b) Multiplications and divisions second 
(c) Additions and subtractions third. 
Parentheses are used in the usual manner to indicate groupings and avoid 
ambiguity. Parentheses are also used to help determine the order in which 
operations are carried out, as we shall see below. For this reason the be-
ginner will usually find it expedient to include a number of these grouping 
symbols which may not be required but which will guarantee that the 
computation is the way he wants it. 

362 
9. 
FORTRAN; MIXED LANGUAGE 
PROGRAMS 
Example 9-1. We give some Fortran arithmetic expressions and their 
mathematical equivalents. We use symbolic addresses which are the upper 
case equivalents of the mathematical notations we might use. 
Fortran 
Mathematical equivalent 
(a) (1*2*3) **2 
(3!)
2 = 36 
(b) 1*2*3**2 
1.2-3
2 = 18 
(c) (X + Y)*3./Z 
3(s + 
y)/z 
(d) X + (Y*3.)/Z 
or 
X + (3, .*Y)/Z 
*y 
χ + — 
ζ 
(e) X + Y*3./Z 
,3î/ 
χ Η 
ζ 
(f) (X + Y*3.)/Z 
x + 3 î / 
ζ 
(g) (X**(2.*(Y + Z*4.)))/(W - V) 
w — V 
(h) 
(i) 
(X**2*(Y + Z*4.))/W - V 
X**2*(Y + Z*4.)/(W - V) 
xKy 
+ 
±z) — V 
W 
x*(y + 42) 
w — V 
(i) X**2*Y + Z*4./W - V 
x
2y 
+ 4z/w — υ 
(k) X * ( - Y ) 
x(-y) 
We see that in (a), (b), (c), and (d) the parentheses alter the value be-
cause their contents are computed first. In (d) the parentheses are used 
but are not necessary, since the rule of multiplications and divisions prior 
to additions and subtractions gives the same result in (e). On the other 
hand, the rule of parentheses first gives us a completely different result in 
(f). We also note in (g) that with parentheses computed first, internal 
parentheses are in turn computed first. The outer parentheses in (h) and 
(i) can be omitted because of the priority of exponentiation, but the 
parentheses in the denominator of (i) cannot be omitted unless we wish 
the results of (h) and (j). We also note that the decimal points after co-
efficients 2, 3, and 4 are mandatory but the use of the exponent 2 without 
it in (g) through (j) is permissible. In (k) the parentheses are required to 
keep two operation symbols from being adjacent, which is not permitted. 

9-1. FORTRAN PROGRAMS 
363 
Just as with mathematical notation, there are a number of different 
ways to achieve a given result in a Fortran expression. The important 
thing to keep in mind is to avoid ambiguity, if necessary with redundant 
parentheses, and to keep the order of operations in mind. 
Example 9-2. We write a Fortran expression for the cosine of an angle 
in a triangle with sides x, y and z; that is, we form 
x
2 + y
2 — z
2 
2xy 
We can use any of the following: 
(a) 
(X**2 + Y**2 - 
Z**2)/(2.*X*Y) 
(b) 
.5*(X**2 + Y**2 - 
Z**2)/(X*Y) 
(c) 
(.5/(X*Y))*(X**2 + Y**2 - 
Z**2) 
(d) 
.5/(X*Y)*(X**2 + Y**2 - 
Z**2) 
(e) 
(X*X + (Y + Z) (Y — Z))/(2.*X*Y) 
We note that the one set of parentheses in (c) can be left out as in (d), 
since the left to right order assures that the division is performed first, and 
hence ,5/xy 
will be the first factor when the final multiplication is per-
formed; however, we cannot leave out the parentheses in any of the 
denominators. In (b), for example, if we were to use 
.5*(X**2 + Y**2 - 
Z**2)/X*Y 
we would actually obtain 
(x
2 + y
2 - 
z
2)y 
2x 
A programmer should, of course, be familiar with the way his compiler 
works. In (e), for example, the formation of the squares as products may 
be more efficient and use less machine time. It is apparent that if X**2 is 
obtained by the same general method as X**2.5 then X*X is faster, since 
this kind of exponentiation requires more complex procedures than simple 
multiplication. 
A Fortran expression does not in itself constitute a statement. In effect, 
it is a command to the compiler to provide the necessary instructions to 
compute the desired quantity, but it is not complete since it does not say 
where the quantity is to be placed. The complete statement will tell the 
compiler how to compute the quantity and will also specify the address of 
the register where it is to be stored. This is done by means of the equality 
sign in the form: 
Symbolic address = Fortran expression 

364 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
This is, then, a complete statement which specifies that the quantity 
defined by the expression on the right side is to be computed and stored at 
the address given on the left side. In this sense it does not give the exact 
equivalent of the mathematical equality, since we can write, for example, 
A = A*2. and mean that the current value of the variable A or the content 
of address A is to be doubled and the result stored at A. We can thus use 
the equality in two ways: We can use it to define a new variable from the 
computed value on the right, or we can use it to replace the current value 
of the variable on the left by the new value computed on the right. The 
left side of a Fortran equality must be a single symbolic address. It cannot 
be a number or a Fortran expression. Thus we can write Ζ = X + Y but 
not X + Υ = Ζ. 
Example 9-3. We wish to write a Fortran statement to obtain the 
partial solution xi of the pair of simultaneous equations 
by Cramer's rule. We assume storage of the coefficients and that the 
determinant is different from zero. We can use the following. 
X I = (B1*A22 - B2*A12)/(A11*A22 - 
A12*A21) 
Note the necessity for both sets of parentheses. 
If we have defined address arrays, we can use individual addresses from 
the arrays just as we can any single address names, or indirectly by re-
placing the subscripts by appropriate arithmetic expressions. Since sub-
scripts are integers the current value of the expression must also be an 
integer. The restriction to integral values does not, of course, apply to the 
elements in the arrays. 
Example 9-4. We have a three by three matrix A (I, J) in storage and 
we compute its trace. We use the following. 
anXi + auX2 = &i 
Ö21#l + 
α22#2 = &2 
T R = A ( l , 1) + A(2, 2) + A(3, 3) 
Example 9-5. The sequence of arithmetic statements 
L 
4 
M 
2 
VECTOR (L + M + 1) 
V E C T O R ( L + M + 1)*2. 

9-1. FORTRAN PROGRAMS 
365 
would have the effect of doubling the content of the register 
VECTOR (4 + 2 + 1) = VECTOR (7). 
We note that the left side of the Fortran equality is still a single address. 
The use of the value of an arithmetic expression for the index does not 
alter the rule that the left side itself not be such an expression. 
In the arithmetic expressions we cannot, of course, operate on all of the 
elements of an array unless we list them all explicitly. In the above ex-
amples we have conformed with the rule that we can only combine quan-
tities which are consistent, that is, we can add only numbers stored in 
floating point format to other numbers of the same kind, and so on. Thus, 
in Example 9-5 the symbol 1 with no decimal point is appropriate in the 
subscript which is fixed, but the 2. is indicated for the VECTOR array 
which is floating point. 
We have also used only consistent notations for the left-hand symbolic 
address and the right-hand expressions. This is what we will normally do, 
but it is not required. The effect of one mode of address or variable on the 
left and a different mode on the right is to give conversion. Therefore, if 
we write I N K = P E N + PAPER, the floating point words specified on 
the right will be added and their sum converted to fixed point for storage 
at INK. Similarly, we can use this method to convert a fixed point value to 
floating point. We should use care in making such conversions, since in 
the passage from floating point to fixed point only the integral part is 
retained, and in the inverse conversion no provision is made for direct 
retention of a possible scale factor. 
Example 9-6. We show the effect of two conversions. 
(a) The statements 
ALPHA = 2.3 
BETA = 5.1 
IOTA = ALPHA + BETA 
would result in the formation of 2.3 + 5.1 = 7.4, of which only the integral 
part 7 would be stored at IOTA. 
(b) Suppose we have 1.1 scaled at 2
4 6 stored as a fixed point integer in 
LUCK. We wish to convert it to floating point. The single statement 
BAD = LUCK 
would result in the storage at BAD of the floating point version of 
2057 4314 6314 6314 in the CDC 1604. Note that the number of signifi-
cant digits will decrease in conversion from fixed to floating point. 

366 
9. FORTRAN; MIXED LANGUAGE 
PROGRAMS 
9-1.1. Fortran Functions 
We can evaluate any function we wish by an appropriate combination 
of the arithmetic expressions and the control statements to be considered 
later. A number of functions are so generally required, however, that they 
are made directly available as permanent parts of the library. A typical 
list is given in Appendix F. The rule for the use of these as elements of 
arithmetic expressions is to list the name followed in parentheses by the 
quantity by which the function is to be evaluated. The independent 
variable may be any correct Fortran mathematical expression. The latter 
may include other function names. Most of the function programs are 
written for floating point operations, but before using any one we should 
know its form and follow the usual precaution with the arithmetic opera-
tions. The compiler will provide the appropriate return jump instructions 
from the subprogram used. Most of the function names are self-explanatory 
but should be checked. 
Example 9-7. We compute the cosine of a sum of two variables and store 
it. We can use 
C0SSUM = C0SF(X + Y) 
which will result in the computation of the cosine of the sum of the con-
tent of registers X and Y and storage at the designated address. 
We should keep in mind that both the arithmetic operations and the 
function subroutines will be limited in accuracy by the number of significant 
digits retained, and this in turn will be a function of register size. In gen-
eral, the truncation errors involved in the computation of the functions 
will be within this error, but these results may not be mathematically 
exact. 
Example 9-8. We check the trigonometrical identity 
cos
2 χ + sin
2 χ = 1 
and form the Fortran statement 
T I D E N T = C0SF(X)**2 + SINF(X)**2 
but this may well result in storage of the value .99999999999··· at 
T I D E N T . 
We note that, as Example 9-8 indicates, the rule for order of computa-
tion lumps subroutine names and their required parentheses with paren-
theses in general. That is, the argument expressions in parentheses are 
computed first. Therefore, C0SF(X)**2 will result in cos
2 x} not cos x
2. 
Since any legitimate Fortran expression may be used as the independent 
variable in a function expression, subject to the conditions of its sub-

9-1. 
FORTRAN PROGRAMS 
367 
program, we may obtain functions of functions. We illustrate this in the 
following example. 
Example 9-9. We compute and store a value for the inverse hyperbolic 
cosine of the content of X. The mathematical expression is 
ln(x + Vx
2 
- 
1). 
We can use 
C0SHINV = L0GF(X + SQRTF(X**2 - 1.)) 
We close this section with an example of a brief but complete Fortran 
program, showing the input and output statements, as well as the arith-
metic and function expressions. 
Example 9-10. We read in the three components of a vector and compute 
and print its magnitude. We use the following program, assuming that 
the three components are punched on a single card in three successive 
fields: 
P R O G R A M MAG 
D I M E N S I O N V(3) 
R E A D 10, V 
10 F0RMAT (3E20.13) 
ANS = SQRTF(V(1)**2 + V(2)**2 + V(3)**2) 
P R I N T 10, ANS 
E N D 
E N D 
We point out again that for some compilers we might follow statement 10 
more efficiently 
by 
ANS 
= 
SQRTF(V(1)*V(1) 
+ 
V(2)*V(2) 
+ 
V(3)*V(3)). 
9-1.2. Fortran Jump Statements 
We have seen how the basic arithmetic and transmissive instructions of 
the computer can be attained through Fortran by means of a notation 
which corresponds closely to ordinary mathematical notation. Thus we 
can write X = Y in place of the sequence of machine instructions required 
to transmit the content of Y to the register with symbolic address X, and 
we can use Ζ = X + Y to form the sum of two stored numbers and place 
the result in register Z. Just as arithmetic and transmissive instructions 
are not enough in machine language programming, however, they are not 
enough for programming in a problem-oriented language. We will also 
need the equivalent of the nonarithmetic instructions discussed in Chapter 
6. These will include the equivalents of unconditional, conditional, and 

368 
9. 
FORTRAN ) MIXED LANGUAGE 
PROGRAMS 
index jumps, selective stops, and so on. Such statements will permit us the 
flexibility 
of altering the implicit sequential operation of the language and 
introduce loops and conditional branch points. 
The simplest form of a jump instruction is the Go To s statement, 
where s is the number of any executable statement. This is an unconditional 
jump and transfers control to the sequence required to execute statement 
s. If statement s is not executable, the program will not compile. 
Example 9-11. We write a loop to carry out a vector addition, using a 
Go To statement. We assume that vectors V(I) and W ( I ) have been 
read in and that a proper dimension statement has been provided. We 
might use the following program. 
I = 1 
20 
Z(I) = V ( I ) + W ( I ) 
1 = 1 + 1 
G0 T0 20 
We see that the first statement sets the index I at the initial value of one. 
The first time that statement 20 is executed, it will b e Z ( l ) 
= V ( 1 ) 
+ 
W ( l ) . The succeeding statement provides for the increase in the index 
and the Go To statement provides re-entry in the loop. We have, of course, 
produced a closed loop, just as we did with machine language instructions 
in a similar situation in Example 3-5, and the program is not practical. 
We note, however, the analogy between the Fortran statements used to 
produce the loop and the right hand column of comments used in the 
earlier example. 
Closed loops are as much of a nuisance in problem-oriented language 
programs as in machine language programs. The obvious kinds given in 
the example above are easy to avoid, but the more subtle ones are likely 
to crop up unless great care is taken. To be able to write loops with proper 
exits, we will need various types of conditional jumps. One of these is an 
extension of the simple statement given above which is frequently called 
the Computed Go To. The statement takes the form 
G ß 
T0 
(βι, 8%, · · · , « * ) , η 
where the list of Si is a set of executable statement numbers and η is any 
single symbolic address or variable name for an internal fixed point integer. 
Address arrays are not permitted. The effect of the Computed Go To 
statement is the following: if the content of the given address or value of 
the variable is n, where 1 < η < k, then control is transferred to statement 

9-1. 
FORTRAN PROGRAMS 
369 
number sn) if the variable is outside this range, the execution of the program 
will terminate with an error printout. This occurs because the variable is 
a dynamic 
variable whose value is determined in the actual execution of 
the program and not at the time of compilation. 
The Computed Go To statement in its general form gives a ft-fold 
branch point with the branch defined by the current value of an index in 
the specified register. Many applications are possible, including some 
which use repeated statement numbers in the list. 
Example 9-12. We write a loop for the vector addition of Example 9-11 
with an exit. We again assume storage of V(I) and W ( I ) , but give an 
explicit dimension statement. 
D I M E N S I O N V(4), W(4), Z(4) 
I = 1 
20 
Z(I) = V(I) + W ( I ) 
1 = 1 + 1 
G0 T0 (20, 20, 20, 20, 30), I 
30 
E T C . 
The initial value 1 = 1 results in the execution of statement 20 for the 
first component. As I increases successively through the values 2, 3, and 
4, the loop is traversed again to add the other three components, but when 
the value five is reached the sequencing goes to statement 30 which pre-
sumably continues the program. 
In Example 9-12 for illustration we have used the Computed Go To 
statement as a simple index jump. We shall see shortly, however, that a 
more versatile way of repeating a loop a specified number of times is avail-
able, and the present usage of the statement will be limited. 
Example 9-13. A program generates the coefficients 
in an equation 
ax
2 + bx + c = 0, in which b cannot be zero. A sequence of program steps 
then tests the kind of equation it is and enters a code in register I T E S T 
as follows: 
If I T E S T = 1, the equation is linear (a = 0) 
If I T E S T = 2, the equation is quadratic with real roots 
If I T E S T = 3, the equation is quadratic with complex roots 
We might then use the following sequence to compute the root or roots. 

370 
9. 
FORTRAN J MIXED LANGUAGE 
PROGRAMS 
We assign a number to the Computed Go To statement for reference in 
the next example. 
100 
G0 T0 (200, 300, 400), ITEST 
200 
R = 
( - C ) / B 
G0 T0 500 
300 
R l = ( - B + SQRTF(B**2 - 
4.*A*C))/(2.*A) 
R2 = ( - B - SQRTF(B**2 - 
4.*A*C))/(2.*A) 
G0 T0 500 
400 
X I = (-B)/(2.*A) 
YI1 = SQRTF(4.*A*C - 
B**2)/(2.*A) 
X2 = X I 
YI1 = - Y I 1 
500 
E T C . 
We have introduced statements which serve in Fortran programs as 
unconditional and selective index jump statements. We shall also need 
statements for the kind of conditional control changes exemplified by sign 
jumps, zero jumps, threshold jumps, and the like. A combination of all 
of these jumps is given by the / / statement. With the form indicated 
below, this is executed in the following manner: 
Next statement executed is: 
Sl 
if 
X < 0 
Si 
if 
X = 0 
S) 
if 
X > 0 
The If statement contains two sign jumps and a zero jump, from which 
we can construct our own threshold and equality jumps. Although we 
have used X for the quantity in parentheses following the If statement, 
it can be any legitimate variable name for either internal fixed or floating 
point numbers, or may be an arithmetic expression involving several 
variables. The list outside the parentheses consists of three statement 
numbers assigned to executable statements. 

9-1. 
FORTRAN PROGRAMS 
371 
Example 9-14. We give a sequence which will set the proper code in 
I T E S T for Example 9-13. We assume that A, Β and C have been computed. 
I T E S T = 1 
I F (A) 20, 100, 20 
20 
I T E S T = 2 
D = B*B - 
4.*A*C 
I F ( D ) 30, 100, 100 
30 
I T E S T = 3 
G0 T0 100 
The first use of the If statement is as an unqualified zero jump, since the 
next statement executed will be number 100 if A = 0, and number 20 if 
A 
0. If A ?^ 0, the discriminant is computed and the next use of the If 
statement is for a sign jump. We note that the list of statement numbers 
30, 100, 100 lumps zero with the positive numbers and hence, the code 2 
is inserted if the discriminant is nonnegative, and the code 3 is only if it 
is negative. 
In the combined Examples 9-13 and 14 we have used the Computed 
Go To statement, but in Example 9-13 only for illustration. The code as 
such is unnecessary and we could dispense with it entirely. 
Example 9-15. With statements 200, 300 and 400 assumed to be those 
of Example 9-13, we could eliminate the code in ITEST and statement 
100 by using 
I F (A) 20, 200, 20 
20 
D = B*B - 
4.*A*C 
I F ( D ) 400, 300, 300 
We can replace the two statements starting at 20 by one, of the form 
IF(B*B — 4.*A*C)400, 300, 300, since arithmetic expressions are per-
mitted. If we compute D as a separate quantity, however, we can avoid 
the recomputation and use D or — D in place of the corresponding expres-
sion in statements 300 and 400. 
We can use the If statement in a variety of ways. We note, for example, 
that we can obtain the absolute value of X at Y by using I F ( X ) 1, 2, 2 if 
statement 1 is Y = —X and statement 2 is Y = X. In the next example, 
we illustrate the way in which the statement may be used to terminate an 
iteration. 

372 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
Example 9-16. The equation/(χ) = x
z + χ — 1 has a real root between 
zero and one since /(0) = — 1 and / ( l ) = 1. We wish to compute and 
print out this root, using Newton's method, with η = 1 and 
f(rn) 
_ 2rw» + 1 
r n +1 
Tn 
f'(rn) 
3r n
2 + l 
We will continue the iteration until no change occurs in the sixth significant 
digit, that is until | rn+i — rn \ < 10~
6. For simplicity, we replace this by 
the condition 
(r n +i - rny 
< 10-
1 2, 
or 
( r n +1 - r n)
2 - 10"
12 < 0 
We present a Fortran program to achieve this. No input statements are 
required. 
PROGRAM R00T 
C 
T0 USE NEWTONS METH0D 
R l = 1. 
10 
R2 = (2.*R1**3 + l.)/(3.*Rl**2 + 1.) 
TEST = (R2 - Rl)**2 - 
10.**(-12) 
I F (TEST) 30, 20, 20 
20 
R l = R2 
G0 T0 10 
30 
P R I N T 40, R2 
40 F0RMAT (E15.8) 
E N D 
E N D 
The first executable statement sets R l to the initial approximation. The 
next one computes the second approximation in R2, while the third calcu-
lates the square of the error relative to the predetermined value. The If 
statement determines whether the error is small enough. If it is not, a 
re-entry in the loop is made by statement 20, while if it is, the print-out 
is given by statement 30. In the statement following number 10 we have 
used the most obvious symbolism to compute 10
- 1 2, that is, 10.**( —12). 
This means, however, that it must be recomputed each time the loop is 
executed. The use of the constant 10.E — 12 would be much more efficient. 
We also note that the variable T E S T need not be explicitly introduced. 
We could replace it in the If statement by the expression which evaluates it. 

9-1. 
FORTRAN PROGRAMS 
373 
9-1.3. Fortran Do Loops 
We have seen that with statements which are the equivalent of condi-
tional jumps, we can produce the iterative loops which form the skeleton 
of most programs. When the data are not subscripted, or when the exit 
condition does not depend on the current value of an index, we will want 
to control loops in this manner. In dealing with subscripted arrays and 
loops to be traversed a predetermined number of times, a simpler approach 
is provided by the Do statement, which takes the form 
D 0 s i = ni, n 2, n% 
in which s is a statement number, i is a dummy index, and nh n 2, and n 3 
are positive integers. The dummy index i may be symbolized by any 
legitimate symbolic address or variable name for a fixed point integer. The 
integers nh 
n 2, and n 3 must be specified explicitly or given as variables 
which are integers. Thus they may not be arithmetic expressions. 
The first statement following a Do statement must be an executable 
statement, after which the statement functions in the following manner. 
If we have 
DJ3 s i = Wi, n 2, n 3 
S T A T E M E N T 
(Executable) 
S T A T E M E N T 
s 
S T A T E M E N T 
}K statements 
the sequence of Κ statements will be repeated for values of the index i 
starting at nh 
and then successively increased by n 3 for each subsequent 
loop to give values i = nh ni + n 3, nx + 2n 3, · · ·, ni + tn%. The number 
of loop traversais is determined by n 2 and the rule is that the largest index 
generated before exit be less than or equal to n 2; that is, n\ + tnz < n 2. An 
exit will be taken on the first value of the index to exceed n 2. The loop 
itself consists of the statements immediately following the Do statement 
and terminating 
with the statement numbered sy referred to in the Do state-
ment itself. It should be apparent that no statement within the loop should 
be used to alter directly the value of the dummy index. 
Example 9-17. We assume that an array X ( I ) is stored, and that proper 
dimension statements have been introduced for both X ( I ) and Y (I). The 
statements 
D 0 10, I = 2, 6, 2 
10 
Y(I) = X ( I ) 

374 
9. 
FORTRAN; MIXED LANGUAGE PROGRAMS 
will then result in the transfer of the elements X ( 2 ) , X ( 4 ) , and X(6) into 
the new locations Y (2), Y (4), and Y (6). The index has gone through 
successive values of 2, 4 = 2 + 2 and 6 = 4 + 2 determined by the incre-
mental value 2. The first generated index which exceeds 6, in this case 
8 = 6 + 2 , specifies the exit from the loop. 
On the other hand, the statements 
D 0 10, I = 1, 6, 2 
10 
Y(I) = X ( I ) 
would result in transfer of X ( l ) , X ( 3 ) , and X(5) since the indices are 
then 1,3 = 1 + 2 , 5 = 3 + 2 and 7 = 5 + 2 , which exceeds 6 and termi-
nates the loop. 
The most commonly used incremental value n 3 is one, and in this case, 
we do not need to give n 3 explicitly; that is, the statement D 0 si 
= nh 
n2 
is the same as the statement D 0 s i = nh n2) 1. We are not permitted to 
terminate a Do loop with a statement which can effect a transfer of control. 
For example, 
D 0 20 I = 1, 5 
10 
Y(I) = X ( I ) 
20 
I F ( X ( I ) ) 10, 30, 30 
30 
ETC. 
is not allowed. In the event that we need this kind of operation, however, 
we can achieve it by a special pass or do-nothing statement called 
Continue. 
This statement has the effect of allowing a final conditional jump to initiate 
an exit from the Do loop on satisfaction of a condition, but to continue the 
loop if the condition is not satisfied. 
Example 9-18. We wish to continue to transfer a subsequence of elements 
from an array X ( I ) into an array Y (I) as long as they are negative. For 
a first nonnegative element we wish to take alternative steps. The value 
of the variable INITIAL gives the starting index value, while the variable 
LAST gives the final one to be considered. 
D 0 20 I = INITIAL, LAST 
I F ( X ( I ) ) 10, 30, 30 
10 
Y (I) = X ( I ) 
20 
C O N T I N U E 
30 
ETC. 
This example also illustrates, the use of variable names for nx and n2. 

9-1. 
FORTRAN PROGRAMS 
375 
In any exit from a Do loop such as might occur in Example 9-18 before 
the normal exit, the index retains the final value it had at the time of the 
exit. Thus, if the element X(13) happened to be nonnegative in the ex-
ample, the value of I would have the value 13 at statement 30. By use of 
this value and the values of I N I T I A L and LAST we can determine if 
and where a negative member of the array was found. 
A problem-oriented language such as Fortran is partially designed to 
obtain universality, and this may be the case in terms of the symbols 
used by the programmer. We should not forget, however, that the actual 
compilation of the objective program is dependent on both the compiler 
itself and the computer for which it is written. Thus two identical Fortran 
programs submitted to compilers written by different programmers may 
result in vastly different degrees of efficiency. Similarly, two apparently 
identical programs may produce very different results when handled by 
the same compiler and computer. For this reason a Fortran programmer 
who is intimately acquainted with both his compiling program and his 
computer can use the language much more intelligently than one who 
knows only the basic ideas of the language itself. We illustrate this point 
with an example of two apparently similar Do loops written for a particular 
Fortran compiler. 
The dummy index in a Do statement can be any permissible fixed point 
symbolic address but in the CDC 1604 with the Fortran 60 compiler, the 
one-character symbols I, J, K, L, M, and Ν are specifically addresses of 
index registers. This means that their use will permit indexing to be done 
in index registers while the use of other symbols will result in indexing 
being done in storage registers and in the main arithmetic section. We 
illustrate this point and several others in Example 9-19, where we give 
the original Fortran statements and the absolute code which the compiler 
produces. In this case we choose to have the code given in relocatable form, 
that is, with regional addresses. We can, if we wish, also specify to the 
compiler that it is to assign absolute values to these addresses and obtain 
the program in operative storage. 
Example 9-19. We write two versions of a program for a vector sum and 
give the resulting machine language programs. The Fortran program is 
the following: 
P R O G R A M VECT0RAD 
D I M E N S I O N Ζ (100), V(100), W(100) 
C 
FIRST E X A M P L E 

376 
9. FORTRAN J MIXED LANGUAGE PROGRAMS 
C 
DATA ALREADY ST0RED 
5 D0 10 I = 1, 100 
10 
Z(I) = V(I) + W ( I ) 
C 
W E CAN N0W USE T H E SUM AS W E CH00SE 
C 
SEC0ND E X A M P L E 
15 
D0 20 I N D E X = 1, 100 
20 
Ζ ( I N D E X ) = V ( I N D E X ) + W ( I N D E X ) 
E N D 
E N D 
The statement numbers for the Do statements are unnecessary for the 
program, but used to illustrate the information given by the compiler. 
The regional absolute program actually produced by the compiler is given 
below. Since the program is entered by a calling program in the main 
compiler, it is produced as a subroutine. To assist in following the objective 
program produced by the compiler, we list the regional addresses and 
their functions (For objective program see pages 378 and 379) : 
Regional addresses 
Function 
AAA 
Program preamble 
BAA 
Program instructions 
IAA 
Current address of V(INDEX), W(INDEX), Z(INDEX) 
KAA 
Constant program parameters 
RAA 
Temporary storage, first example 
VAA 
Temporary storage, second example 
WAA 
Ζ array 
WAB 
V array 
WAC 
W array 
It is easy to visualize the necessary machine instructions corresponding 
to simple Do loops of the kind given above. The first loop, which does the 
indexing in the index registers, is essentially that of Example 3-17, except 
that floating point operation is involved. Similarly, the second and longer 
loop, with its necessary prestoration instructions, parallels the loop used 
in Example 3-7, although the more subtle method of indirect addressing 
is built into the compiler. We also see, however, that a knowledge of the 
basic structure of these absolute programs is important for an efficient use 

9-1. 
FORTRAN PROGRAMS 
377 
of Fortran, in which two apparently identical statements produce the same 
answers but very different codes. In either case, the obvious translation 
occurs; that is, the statement Ζ = V + W becomes the machine instruc-
tions 12, 30, and 20 with the necessary housekeeping to provide the loop 
for all components. The roundabout indexing in the second example, how-
ever, produces a program which takes a little more than three times as 
long to run. 
Do loops may be contained within Do loops, but certain restrictions are 
imposed. The basic rule is that an inner Do loop must be completely em-
bedded in the outer loop. That is, if we consider the extent of the outer 
loop as including all statements down through the numbered statement 
referred to by s, no inner loop may include a statement which extends 
beyond this numbered statement. More than one loop may terminate 
with the same statement. It is also apparent that in using nested Do loops, 
identical symbols for the dummy 
indices cannot be used. If an outer loop 
uses the index symbol I, no inner one can use it. In the following examples 
we present some correct and incorrect configurations. 
Example 9-20. We show diagrammatically some permissible nested Do 
loops. The symbols I, J, Κ refer to the dummy indices. The arrow to the 
left shows the position of the Do statement, while that to the right shows 
its terminal numbered statement. 
(a) 
(b) 
(c) 

PROGRAM PREAMBLE 
FIRST EXAMPLE 
SECOND EXAMPLE 
AAAOO 
750 
00000 
500 
00000 
AAA01 
571 
RAA01 
501 
00000 
J N PR0GRAM 
BAAOO 
160 
KAA01 
210 
RAA07 
BAA01 
531 
RAA07 
120 
KAAOO 
BAA02 
600 
BAA06 
150 
RAA07 
BAA03 
223 
BAA07 
500 
00000 
BAA04 
121 
WABOO 
301 
WACOO 
BAA05 
201 
WAAOO 
500 
00000 
BAA06 
541 
00000 
750 
BAA04 
BAA07 
120 
KAA01 
200 
VAA04 
BAAIO 
120 
KAAOO 
150 
JAA04 
BAA11 
223 
BAA22 
500 
00000 
BAA 12 
120 
VAA04 
110 
WACOO 
BAA13 
610 
IAAOO 
120 
VAA04 
BAA14 
110 
WABOO 
610 
IAA01 
BAA15 
120 
VAA04 
110 
WAAOO 
BAA16 
610 
IAA02 
127 
IAA01 
BAA17 
307 
IAAOO 
207 
IAA02 
BAA20 
720 
VAA04 
150 
KAAOO 
BAA21 
223 
BAA12 
220 
BAA12 I 
Exit-entry. 
Save (B
1). Clear B
1. 
FORTRAN STATEMENT 
1 
5 PRESTORE INDEX SKIP AND 
REJECT IF TERMINAL AD-
DRESS < INITIAL. 
10 V(I) — A, V(I) + W(I) — A. 
STORE Z(I). 
RE-ENTRY IF NECESSARY. 
15 INITIAL VALUE TO INDEX. 
REJECT AS ABOVE. 
20 V (INDEX) 
A. 
V (INDEX) + W (INDEX) 
A. 
STORE. 
RE-ENTRY IF NECESSARY. 
378 
9. FORTRAN ) MIXED LANGUAGE PROGRAMS 

BAA22 
561 
RAA01 
531 
BAA23 
750 
AAAOO 
000 
CONSTANTS 
KAAOO 
000 
00000 
000 
KAA01 
000 
00000 
000 
NORMAL VARIABLES 
VAA04 
000 
00000 
000 
ARRAYS 
WAAOO 
000 
00000 
000 
WABOO 
000 
00000 
000 
WACOO 
000 
00000 
000 
RAA01 
RESTORE (B
1). 
00000 
EXIT. 
00144 
ONE HUNDRED 
00001 
ONE 
00000 
INDEX 
00000 
Ζ 
00000 
V 
00000 
W 
END 
9-1. 
FORTRAN PROGRAMS 
379 

380 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
In the two loops of (a), both loops end with the same numbered statement, 
as do the I, J, Κ loops of (c). For each value of the index I in (a), the 
index J goes through all values. Thus, we see that the rule is similar to the 
"inside-out" rule of arrays in format statements. That is, the innermost 
index varies most rapidly, and so on out to the outermost, which varies 
least rapidly. 
Example 9-21. The following are not permissible combinations of Do 
loops: 
(a) 
(b) 
(c) 
In (a) the repeated dummy index is not allowed. In (b), the supposed 
inner loop on index J extends beyond the terminal statement of the outer 
loop. In (c), while the inner loop on index Κ is properly within the main 
outer loop on I, it extends beyond its own immediate outer loop on index J. 
We can enter single or nested Do loops only at their beginning. Thus, 
we cannot use a jump statement such as G 0 T 0 to enter at an interior 
statement in a Do loop. We can, however, jump to a statement in an outer 
Do loop from a point within one of its own inner loops if the statement 
follows the inner loop. 
The use of nested loops permits us to carry out repetitive operations on 
address arrays with two or three dimensions. For example, we can use 
inner loops to do matrix operations. 

9-1. 
FORTRAN PROGRAMS 
381 
Example 9-22. We wish to transpose a square matrix whose order is 
given by the variable NN. We assume proper dimension statements and 
storage of the elements and can then use the following: 
D0 10 I = 1, N N 
D0 10 J = 1, N N 
10 
Β (I, J) = A(J, I) 
Here the inner loop has the same terminal statement as the outer. The 
order in which transposed elements are formed is bn, 6 1 2, 613, · · · , bin 
and 
then 621, 622, 623, · · ·, and so on. 
Example 9-23. We wish to write a program to form the product of two 
15 X 15 matrices which will be read in by separate statements. That is, 
we wish to form the matrix 11 c<y 11 with elements cy = Σ*-ι e«&jy. We can 
use the following: 
P R O G R A M PR0DMTRX 
D I M E N S I O N A(15, 15), B(15, 15), C(15, 15) 
I 
D0 10 I = 1, 15 
J 
D0 10 J = 1, 15 
Κ 
C(I, J) 
D01OK 
Γ 
10 
0 ( 1 , J) 
E N D 
E N D 
0.0 
1, 15 
C(I, J) + A(I, K)*B(K, I) 
K-
J -
In this case it is important to know the order in which the indexing is 
carried out in nested Do loops. 
9-1.4. Subprograms in Fortran 
In writing either Fortran or mixed language programs we will want to 
make use of subprograms. We have already considered how to make use 

382 
9. 
FORTRAN; MIXED LANGUAGE PROGRAMS 
of library subroutines which are designed to evaluate single functions of 
the form y = f(x) 
or y = f(xh 
x2) in which the only statement required 
to bring the subroutine into operative storage and provide the necessary 
return jumps takes the form 
Symbolic address = Subroutine name (Fortran expression) 
The symbolic address on the right provides the current location of the 
independent variable x, the name defines the function /, and the address 
on the left specifies a location and name for the dependent variable y. If 
two independent variables are required, two addresses appear on the right. 
The available subroutines of this sort will reflect the functions most gen-
erally needed. In individual programs we will frequently need functions 
which are not in the library, but which we must compute several times. In 
this case we will write our own programs and use them as subroutines or 
we will check with the laboratory to see if they are included in a list of 
available but not frequently used ones. We have already seen how this 
can be done in Fortran Symbolic by replacing the Program Name state-
ment by a Subroutine Name statement. In this event, however, entry to 
the subroutine is obtained by a combined use of the LIB pseudoinstruction 
and a return jump in the program. In Fortran, two alternative methods of 
entry are provided. The first of these, which provides a direct extension of 
the library facilities, and is used in the same way, is given by the 
Function 
statement. This is used for subroutines designed to compute a single func-
tion of one or more variables of the form y = f(xh 
x2, · · ·, Xk) with k > 1. 
The statement is used in the same way as a Program Name in the form. 
F U N C T I O N N A M E (xh z 2, · · ·, xk) 
followed by the necessary statements of the subroutine with its own End 
statement. Since the name of the function serves the dual role of name 
and dummy symbolic address or variable, certain restrictions apply to it. 
It must conform to the general rules for symbolic addresses in terms of 
length and fixed or floating point quantities (including rules about a final 
F), and it must appear in an arithmetic statement which defines the value 
of the function. The x» may be any dummy symbols consistent with the 
usual restrictions, except that for arrays, only the name of the array may 
appear, and the proper Dimension statements must be given in the Func-
tion subprogram, corresponding to those given in the main program. Since 
the subroutine is separately compiled, the dummy symbols used in it may 
also be used independently in the main program or in other subroutines. 
Normally the final End statement together with the Function state-
ment serves to provide an exit from the subroutine and a return to the 
main program. In some cases, however, we will want a conditional exit at 

9-1. 
FORTRAN PROGRAMS 
383 
an interior point. This is given by the Return 
statement whose use we 
illustrate in the following example. 
Example 9-24. In a statistical problem we evaluate a step function 
V = f(x), 
defined to be 
0 
if 
χ < 0 
y = f(x) 
= i 
if 
χ = 0 
1 
if 
χ > 0 
and write it as a function subroutine. We use 
F U N C T I O N S T E P (X) 
I F (X) 1, 2, 3 
1 
S T E P = 0.0 
R E T U R N 
2 
S T E P = 0.5 
R E T U R N 
3 
S T E P = 1.0 
E N D 
The name of the function STEP, also serves as the dummy variable to 
define the function in statements 1, 2, or 3. The conditional exits following 
Statements 1 and 2 are given by the use of the Return statement. The 
End statement after 3 provides the final exit, if required, as well as giving 
the usual information to the compiler that this completes the subprogram. 
In some Fortran systems a Return statement is always required, in which 
case we must also introduce such a statement before the End statement, 
as in the following: 
3 
S T E P = 1.0 
R E T U R N 
E N D 
The use of a function subroutine follows that of a library function sub-
routine; that is, we write the name of the function followed in parentheses 
by the symbols of the particular quantities for which we want the function 
evaluated. This may either take the form of an arithmetic statement, or 
the function may be used in an arithmetic expression. 

384 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
Example 9-25. At one point in a program we evaluate the function of 
Example 9-24 for a variable R A N D 0 M and store the result at TEST. At 
another point we multiply the function by a parameter and add a constant. 
We use 
TEST = STEP 
(RANDOM) 
in the one case, and 
TEST = ALPHA*STEP (RANDOM) 
+ 1.2 
in the other. Note that the X in the subroutine in Example 9-24 is only a 
dummy, and that it is replaced by the specific value we need (some arith-
metic expression) when we use the subroutine, as in Example 9-25. We 
may employ both fixed and floating point names for dummies, but we 
must take the usual precautions about consistency in the mode and keep 
in mind that the order in which the dummy variables appear defines the 
way in which each final variable is treated. We may also use address 
arrays as arguments in the function statement. The rule is that only the 
array name appears and all arrays must be of the same dimension. A 
proper Dimension statement for all dummy arrays in the subprogram also 
must appear in the main program. 
Example 9-26. We write a function subroutine to compute the trace of 
a matrix whose order may vary up to a maximum of 100. We use 
F U N C T I O N T R A C E (ALPHA, N) 
D I M E N S I O N ALPHA (100, 100) 
TRACE = 0 
D 0 10 I = 1, Ν 
10 
TRACE = T R A C E + ALPHA (I, I) 
E N D 
If the main program contains a D I M E N S I O N Β (100, 100) statement, 
we could now use this for a matrix Β (I, J) of order 10 by the following 
statement : 
T R B = TRACE (B, 10) 
In addition to the independent variables involved, the list specified 
after the function name gives those quantities which we may interpret 
mathematically as parameters in the function. Thus, in Example 9-26 the 
parameter Ν as well as the matrix ALPHA is listed. If we are computing 
values of the linear function ax + b of the variable xy with a and b deter-

9-1. FORTRAN PROGRAMS 
385 
mined as parameters in a least squares problem, we might use the following 
Function statement for a subroutine: 
F U N C T I O N S T L I N E (Α, Β, X) 
The function declaration permits an easy way of writing a subroutine 
for the evaluation of a single function of one or more variables. In certain 
situations we might wish to write a subroutine to evaluate more than one 
function or a function having more than one dependent variable. We can 
do this by the use of more than one function statement, but a simpler and 
more versatile means is made available by the Subroutine 
statement. This 
takes a form similar to the Function Statement, 
SUBROUTINE N A M E (xh x2, · · ·, xk) 
but with one important variation. The name does not play the dual role 
of identifying the function and providing a symbolic dummy variable. 
Hence the restrictions on beginning letters do not apply. The functional 
values which are the output of the subroutine appear in the list of x t. Thus, 
the list contains both the dependent and independent variables, as well 
as the parameters. The subroutine must be written in such a way as to 
define the dependent variables, which along with the others in the list 
are again dummy symbols. 
Example 9-27. For two vectors whose maximum number of components 
is 50, we compute the magnitude of each and the inner product. We do 
this with a subroutine as follows: 
SUBROUTINE MAGPR0 (VM, WM, PR, V, W, N) 
D I M E N S I O N V(50), W(50) 
VMS = 0 
WMS = 0 
P R = 0 
D0 1 I = 1, Ν 
VMS = VMS + 
V(I)**2 
WMS = WMS + 
W(I)**2 
1 
P R = P R + 
V(I)*W(I) 
VM = 
SQRTF(VMS) 
W M = 
SQRTF(WMS) 
E N D 

386 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
Since V and W are arrays, the main program must include a Dimension 
statement for the vectors involved. 
In Example 9-27, VM, WM, and P R are dummy symbols for the two 
lengths and the inner product, which are dependent single variables. The 
symbols V and W represent the independent variables which are vectors 
or arrays. The symbol Ν is a parameter specifying the actual dimension of 
the vectors. The three outputs are in floating point, but this does not 
prevent our use of a Subroutine 
name beginning with M, as it would in a 
Function subroutine. 
Because of the possibly more complex output of a subroutine beginning 
with a Subroutine statement, a simple use of the name in an arithmetic 
statement no longer suffices as an entry. Instead we use a Call statement 
in the form 
CALL N A M E (xh x2, 
· ·, xk) 
with the name of the desired subroutine and the list which contains the 
symbolic address of dependent and independent variables and parameters. 
Example 9-28. In a program which includes the subroutine of Example 
9-27, we wish to compute the cosine of the angle between two three-
dimensional vectors ACC(I) and V E L ( I ) . We can achieve this by the 
following two statements: 
CALL M A G P R 0 (A, B, C, ACC, VEL, 3) 
C0SANG = 
C/(A*B) 
The Call statement will produce as output of the subroutine the inner 
product stored at C and the two magnitudes stored at A and B, after 
which the simple arithmetic statement computes the cosine. We note that 
we can use a number for the parameter Ν for which we could also use any 
integral variable defining the dimension. 
The location of either Function or Subroutine subprograms in a complete 
program corresponds to the format described in Section 8. That is, the 
program will consist of program name and the main program with its 
End statement; these are followed by each subroutine with its own End 
statement, followed finally by an extra End statement for the program 
as a whole. A conditional inner exit in a subroutine program is achieved in 
the same way as in Function programs by a return statement. In some 
Fortran systems this is required in all subroutines, in which case the format 
of the complete program is as above, but the End statement in each sub-
routine is preceded by a Return. We give an example of a short but com-
plete program showing the placement of a function subroutine. 

9-1. 
FORTRAN PROGRAMS 
387 
Example 9-29. We give a short Fortran program with a subroutine 
which computes binomial coefficients up to order η = 20 of the form 
n! 
m\(n 
— ra) ! 
P R 0 G R A M 
B I N C 0 E F F 
D I M E N S I O N I X (21) 
D 0 2 N 
= 0, 20 
D 0 1 J 
= 0, Ν 
1 
I X (J) = IBIN (J, N) 
2 
P R I N T 3, ( I X ( J ) , J = 0, N) 
3 
F 0 R M A T , 
(/(15I8)) 
E N D 
F U N C T I O N I B I N (M, N) 
C 
IBIN (Μ, Ν) 
= Ν FACTORIAL 0 V E R 
(M 
FACTORIAL 
T I M E S Ν - 
M FACTORIAL) 
5 
I B I N 
= 1 
10 
IB = 
M 
15 
IF(2*M - 
N) 25,20,20 
20 
IB = 
Ν - 
IB 
25 
N I = Ν + 1 
30 
D ß 35 I = 1, I B 
35 
I B I N 
= IBIN*(N1 - 
I ) / I 
E N D 
E N D 
In Example 9-29 we have introduced for the first time the use of a zero 
value in a dummy index for a Do loop. This usage is limited to certain 
compilers, in this case the Fortran 60 compiler for the CDC 1604. This 
point serves to illustrate further, however, that no truly universal language 
is available and the programmer must know the idiosyncrasies of his own 
compiler and computer. 

388 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
9-2. Programs in Mixed Languages 
In Chapter 7 we introduced Fortran statements which facilitate input 
and output in a convenient form, and in Chapter 8 we showed how these 
statements can be used in conjunction with a symbolic form of machine 
language. The mixing of the statements of a problem-oriented language 
and a symbolic form of machine language in one program provides the 
programmer with a highly versatile tool. This versatility is extended by 
the inclusion of the additional Fortran statements and arithmetic expres-
sions introduced in the earlier sections of this chapter. The availability of 
a compiling program which can accept both kinds of languages intermixed 
makes it possible for an experienced programmer to work with a maximum 
of convenience and still produce efficient, well knit programs. He must 
be thoroughly familiar with his computer and his compiler. In this way he 
will know whether it is more efficient to use B*B in place of B**2 or whether 
the necessary machine instructions will be better than either. Since the 
ultimate program executed by the computer is always a set of absolute 
digital sequences, the programmer must determine the extent to which 
he will use the computer itself to help in the transformation of the original 
mathematical problem into such a digital sequence. 
There are many reasons why the exclusive use of a problem oriented 
language may be inadequate, so that a programmer will choose to write 
a symbolic machine program or mix the two languages. The necessary 
compromises which a compiling program must make will not always permit 
the most efficient object program. In situations where a great deal of 
computer time is involved it may be necessary to improve on the efficiency 
of the compiled program. Another case in which intermixed machine in-
structions may be desirable is in the use of the computer for non-arithmetic 
operations. Advanced compilers will include statements which permit 
logical operations. In the simpler forms, however, the language is primarily 
arithmetic and problems which involve a considerable amount of bit 
manipulation will require the use of machine language instructions. What-
ever the reason for choosing a particular language or a mixture of two, the 
decision can be made intelligently only if the programmer is thoroughly 
familiar with all the languages. In the remainder of this chapter we con-
sider some further examples of the use of mixed languages. 
In using two kinds of language in one program we must be careful to 
observe not only the restrictions of each, but also any joint restrictions 
which apply. For example, in a straight Fortran Symbolic machine language 
program we may use symbolic addresses more or less as we choose. We do 
not need to observe the distinctions on beginning letters to differentiate 
fixed and floating point operands. If we are going to use machine instruc-

9-2. 
PROGRAMS IN MIXED LANGUAGES 
389 
tions intermixed with Fortran statements, however, we must observe the 
usual rules of Fortran itself. Entry to subprograms will vary. If we intend 
to enter one by a machine return jump instruction we will need the ap-
propriate LIB pseudoinstruction. If it is to be entered by a Fortran state-
ment we use the applicable rules. In our first example of the extended use 
of a mixed language we present an example of what, in a sense, is a mixture 
of three. It uses a simple Do loop and a sequence of machine instructions. 
These instructions, however, are instructions to the interpretive routine 
I N T E R P of Chapter 8 and show how the interpretive language of this 
program can be used. 
Example 9-30. We write a program to test the driving program I N T E R P 
and its own subservient programs. We form a number of functional values 
of two complex numbers 2 + i and 2 — i. Since we repeat the same set 
of operations for each number we repeat them for the second round by 
use of a Do-loop. The subsequent instructions are in the interpretive code 
given in Section 8-2.2. 
PROGRAM T E S T 
LIB ( I N T E R P = 
I N T E R P ) 
D I M E N S I O N A(4), Β(4), C(4), D ( 4 ) , E(4), F(4), G(4) 
A (1) 
= 2 
A (2) = 1 
A (3) = 2 
A (4) = 
- 1 
E N I 1 (1) E N I 2 ( - 1 B ) E N I 3 (3) 
D 0 1 L = 1, 2 
LDA 2 (A) 
STA 1 ( B ) 
STA 3 (B) 
F M U 1 (B) 
LDA 3 (B) 
S U 4 ( I N T E R P ) 
F M V 2 (A) 
I N T (*) 
LDA 1 (B) 
STA 1 ( C ) 
(2 + ») = A 
(2 - t) = Ä 
(Repeat loop for each 
number) 
(Bi = A
2, rectangular) 
(B 2 = A
2, polar) 
(Ci = Bi
2 = A
4, rectangular) 

390 
9. FORTRAN; MIXED LANGUAGE PROGRAMS 
M U I 3 (B) 
STA 3 (C) 
• (C 2 = B 2
2 = A
4, polar) 
SIL 1 ( Β ) 
STA 1 (D) 
• (Dx = Α = Λ / Β , rectangular) 
SIL 1 (C) 
STA 1 (E) 
• (Ei = A
2, rectangular) 
SIU 3 (B) 
STA 3 (D) 
• (D, - \ / B l = A, polar) 
SIU 3 (C) 
STA 3 (E) 
• (E 2 = "v/Cs = A
2, polar) 
LIL 1 (B) 
STA 1 (F) 
• (Fx = Ln Bi = Ln A
2, 
rectangular) 
LIL 1 (C) 
STA 1 (G) 
• (Gi = Ln Ci = Ln 
A\ 
rectangular) 
LIU 3 (B) 
STA 3 (F) 
• (F, = Ln B 2 = Ln A
2, polar) 
LIU 3 (C) 
STA 3 (G) 
• (G, = Ln C 2 = Ln A*, polar) 
SLJ 
(1) 
1 
P R I N T 2, A, B, C, D, E, F, G 
2 
FORMAT (2F15.8, 10X, 2F15.8) 
E N D 
E N D 
In Example 9-30, the Dimension statement permits us to use arrays, 
the Do-loop is an easy way to repeat the sequence of instructions for a 
second operand, and the output statements are used as they were in 
Chapter 7. The remaining instructions, although they have machine form, 
are interpretive language. In turn, however, they refer to subprograms 
written in straightforward symbolic machine language. Thus, as ultimately 
assembled and executed the final program will have been combined from 
all three languages. 
It is also convenient many times to introduce arithmetic expressions 
intermixed with the instructions of a machine program. For example, we 
might use the following program in place of the one given in Appendix G. 
Example 9-31. We write the subroutine to form the polar form of the 
exponential function, SUBROUTINE P O L R E X P in Appendix G as a 
F U N C T I O N P O L R E X P subprogram; 

9-3. 
EXECUTIVE PROGRAMS 
391 
FUNCTION P0LREXP 
LIB ( I N T E R P = IN) 
C0MM0N PAR, PAI, PR, PI, 0ΡΒΜ 
PAR = 
E X P F ( P R * C O S F ( P I ) ) 
PAI = 
P R * S I N F ( P I ) 
SLJ (IN) 
E N D 
We may also introduce the usual constants into arithmetic expressions, 
as illustrated in the SUBROUTINE RECTLOG in Appendix G, where 
we use PAR = .5*LOGF(PAR). In all cases where mixed languages are 
used, we should attempt to maintain the fine balance in which we use the 
computer itself to do as much of the work as possible as long as it is eco-
nomically expedient. In situations where efficiency requires it, we will 
want to forego the simplicity of a problem-oriented statement and replace 
it by a more severely disciplined sequence of machine instructions. Only 
practice, experience, and an open mind will produce a truly well-rounded 
programmer. 
9-3. Executive Programs 
At various stages we have seen how simple assembly programs such as 
SURAP of Chapter 6, can be extended into more complex regional as-
sembly programs, symbolic assembly programs, and compilers which will 
not only assemble a program but construct it as well. In current practice 
these compiling programs will be embedded in a larger whole which will 
also take over much of the task of the operation of the computer. Most 
laboratories will have some kind of resident executive program which will 
not only provide the compilation of programs written in various languages, 
but will also organize and supervise the execution of the programs. Thus, 
except for the unusual program which will require individual operator 
supervision, the sequence of programs to be run in a day will all be taped 
and run consecutively under control of the executive program. They will 
usually be assembled as subroutines to be entered from the main driving 
program. This program will provide current information on such a device 
as an on-line typewriter to tell which program is running, its execution 
time, and so on. The actual operation of the computer will for the most 
part consist of providing the proper loading of the monitoring program, 

392 
9. 
FORTRAN) MIXED LANGUAGE PROGRAMS 
the data to be operated on, the disposition of the output, and occasional 
checks to see that things are running smoothly. The really experienced 
programmer, however, will probably have a number of sessions in which 
he gets acquainted with his computer, perhaps by stepping instruction by 
instruction through a program. He will take apart and put together the 
executive program itself, trying always for improvement, since he realizes 
that the only things the computer can do are the things it is told to do by 
the aggregate of human programmers who have combined to produce its 
current instruction sequence. This final sequence will be only as good as 
the intelligence and experience of the programmers make it. 
Exercises 
Section 9-1.0 
1 . 
Write Fortran arithmetic expressions for each of the following combina-
tions of operations. Assume all variables are fixed point and obtain 
the combination in several different ways. 
a) 3fc
2 + 2k + 5 
(b) 
± -
2m — 3n 
m
2 n-
3(4Ä:
2 + 3ft)
5*-
1 
, 1N m
2 n( - 3 ) (4/c
2 + 3ft)
5*-
1 
(
C) 
(
d
) 
37
 
2
n 
2. 
Write Fortran arithmetic expressions for each of the following com-
binations of operations. Assume all variables except exponents are 
floating point and obtain the combinations in several different ways. 
(a) 3x
2 + 2x + 5 
(b) 
2x — Sy 
X2n-z^z2 
+
 
3y)i*-i 
z
2* ( - 3 ) ( 4 z
2 + 
Sy)^
1 
(c) 
(d) 
2v 
3w — 2v 
3w 
3. 
For each of the following Fortran arithmetic expressions, determine 
what the final mathematical combination will be. 
(a) N * ( N + L ) / 2 
(b) N*N + L/2 
(c) 3.*X**2*(4.*Y + Z ) / ( W - 
V) 
(d) 3.*X*X*(4.*Y + Z / W - 
V) 
(e) 3.*X**2*4.*Y + Z / ( W - V) 
(f) 
A / B / C / D 

EXERCISES 
4. 
In each of the following Fortran arithmetic expressions determine the 
effect of removing each set of parentheses. 
(a) ((ALPHA*(2*V + 3.) + BETA)*(X**2 + Y**2))/(A*(B + Q ) 
(b) ((N**(2*L + M) + K ) * J ) / ( I * ( K - 
3*J)*K) 
(c) 
( A / B ) / ( C / D ) 
5. 
Each of the following Fortran expressions is written by a programmer 
to obtain the given mathematical combination. Find and correct any 
errors. 
Mathematical 
Fortran 
(a)
 
( 3f
 
+ 
4
y) 
(3X**2 + 4*Y)/2.*X + Ζ 
2x + ζ 
( b)
 
2 W (* +
 
y ) _ 
z 
(2**N*(X + Y))/(X**2 - 
Z) 
x
2 
6. 
Write a complete Fortran arithmetic statement as a solution for each 
of the following problems. 
(a) Find the root of the equation ax — b = c. 
(b) Find the side α of a rectangular parallelipiped with sides a, b, 
and c if b and c and the volume ν are known. 
(c) Find both unknowns in the system of equations 
dix + biy = a 
(I2X + b2y 
= C2 
using Cramers rule if the determinant of the system is different from 
zero. 
Section 9-1.1 
7. 
Write a complete Fortran arithmetic statement as a solution for each 
of the following problems. Use any Fortran functions you need. 
(a) Find the hypotenuse of a right triangle with known sides a and 
b. 
(b) Find the third side α of a triangle if the other two sides b and 
c and their included angle are known. 
(c) Find the inverse hyperbolic sine in terms of logarithms. 
(d) Find the hyperbolic tangent in terms of exponential functions. 

394 
9. 
FORTRAN; MIXED LANGUAGE PROGRAMS 
Section 9-1.2 
8. 
Use the Computed Go To statement as an index jump and write 
Fortran statements to compute the following. 
(a) Σ "
2 
(b) 
9. 
Write Fortran statements to achieve a solution to the following 
problems. 
(a) Find y/a 
— b. If it is real, store it at R, but if it is imaginary, 
store it at RI. 
(b) Arrange the four numbers a, b, c, and d in ascending order of 
magnitude at X I , X2, X3, and X4. 
(c) Find Λ / Ö correct to ten decimal places if a > 0. Use Newton's 
method and do not use the Fortran square root function. 
(d) The equation ax
2 + bx + c = 0 is to be solved for a number of 
different values of a, b, and c to be read in on cards. The three param-
eters can have any values including zero. Write a complete Fortran 
program, including input and output statements, which will give 
either the real or complex roots for the quadratic case, the single root 
for the linear case, and will print C H E C K or E R R O R for c = 0 or 
c 9
e 0 in the event a = b = 0. 
Section 9-1.3 
10. Write a Do-loop to form the sum of the squares of the first ten integers. 
11. Write the program of Example 4-42 in Fortran using a Do-loop to 
terminate the tabulation at the appropriate point. 
12. Use any necessary Do-loops to write a Fortran program to form the 
sum of two square matrices whose order is the integer N. 
13. Write a Fortran program to evaluate 
/ exp(z
2) dx 
Jo 
by using Simpson's one-third rule and an increment of Ax = 0.001. 
14. Write a Fortran program to evaluate 
/ / exp (x
2 + y
2) dx dy 
by using Simpson's one-third rule and increments Ax = Ay = 0.001. 

EXERCISES 
395 
15. Write a Fortran program to evaluate 
ο
 Jo
 
Jo 
ι 
exp (χ
2 + y
2 + ζ
2) dx dy dz 
by using Simpson's one-third rule and increments Ax = Ay = Az = 
0.001. 
Section 9-1.4 
16. Write each of the subroutines of the I N T E R P routine of Chapter 8 
and Appendix G as Fortran Function subprograms. 
17. Write a Fortran Subroutine program which will form the sum, differ-
ence, inner product, and angle between two vectors whose dimension 
18. Write a Fortran Subroutine program which will form the products ab 
and ba of two matrices. 
19. Write the I N T E R P routine of Chapter 8 as a Fortran Subroutine 
program, using the Function programs of Problem 16. 
20. Write a Fortran program to form the function 
for a complex number ζ using the results of Problem 19. 
Section 9-2 
21. Redo the subroutines of Section 9-2 and Appendix G introducing 
Fortran statements wherever they seem reasonable. 
22. Using Example 9-19 as a rough guide, compare the programs you 
have written in Problem 21, those in Section 9-2, and Appendix G, 
and those of Problem 16 and try to determine their relative efficiency. 
23. Write the programs of Problems 26-38 of Chapter 5 as mixed language 
programs, 
introducing 
Fortran 
statements 
wherever 
they 
seem 
advisable. 
24. Write an interpretive program which will provide for double precision 
addition and subtraction, that is, each number consists of an exponent 
and eighty-five bit coefficient stored in two registers. Use both Fortran 
and Fortran Symbolic statements as needed. 
is N. 
f(z) 
= e* + \ / s i n ζ 
25. Write an interpretive program which will add, subtract, and form the 
product of two square matrices whose order is specified by an inter-
pretive instruction. 

APPENDIX A 
Instructions on the C D C 1604 
In the C D C 1604 an instruction word consists of 24 bits or eight octal 
digits. These are divided into sections, octally, as follows:// 
i 
aaaaa. 
Two octal digits ff represent the function or operation code, one octal digit 
i represents the index designator, and five octal digits aaaaa represent the 
address portion of the word. These words may appear either as upper in-
structions if they occupy the high order 24-bit locations, or as lower in-
structions if they occupy the low order 24-bit locations. Taken together, 
an upper and a lower instruction provide for a program step consisting of 
an upper program step and a lower program step. If control accepts the 
lower instruction consecutively after the upper instruction, it is said to 
make a half-exit from the upper location. If it accepts the instruction from 
the upper location of the next program step, it is said to make a full 
exit. 
The operation code ff may be any octal combination from 01 to 76. The 
codes 00 and 77 will be sensed as faults. The index designator i may be b, 
in which case an index register, real or imaginary, is referenced; or it may 
be j , in which case it determines a condition or a mode of operation. 
The address portion of the instruction word may be used in any one 
of three ways: as m = aaaaa, an address; as k = aaaaa, a shift count; as 
y = aaaaa, an operand; or as z, a code combination. Combinations used 
are: 
(1) 
/ / 
b 
m 
(operation code, index register, address) 
(2) 
// 
b 
k 
(operation code, index register, shift count) 
(3) 
/ / 
b 
y 
(operation code, index register, operand) 
(4) 
/ / 3 
m 
(operation code, condition, address) 
(5) 
/ / 3 
ζ 
(operation code, condition, code) 
397 

398 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
We describe the instructions according to the above five categories. In 
each category, we subdivide further according to the type of instruction, 
and for each type we give instructions in numerical order by operation code. 
For each instruction, the average time for completion of the operation 
is given in microseconds ^sec). 
(M)' 
denotes the one's complement of 
(M) ; 
and Mia 
denote the upper and lower address portions of (M) ; 
NI denotes the next instruction (upper or lower). 
Category 1. Instructions ff 
b 
m (operation code, index register, 
address) 
b = 0 implies (B°) 
= 0 with no address modification, effective address 
M = m. 
b = 1, 2, 3, 4, 5, or 6 modifies address to effective address M = m + 
(Β"). 
b = 7 is indirect addressing. 
Transmissive 
12 
b 
m 
LOAD A 
(LDA) 
(M) -* A 
7.2 
Msec 
A is cleared, and a storage reference is made to the execution address M 
to obtain the 48-bit operand (M), 
which is copied into A. (—0) can be 
loaded. 
13 
b 
m 
LOAD A, C O M P L E M E N T 
(LAC) 
(M)' 
-> A 
7.2 
Msec 
A is cleared, and a storage reference is made to the execution address M 
to obtain the 48-bit operand (M), which is complemented and then copied 
into A. (—0) can be loaded. 
16 
b 
m 
LOAD Q 
(LDQ) 
(M) -> Q 
7.2 
Msec 
Q is cleared, and a storage reference is made to the execution address M 
to obtain the 48-bit operand (M), 
which is copied into Q. (—0) can be 
loaded. 
17 
& m 
LOAD Q, 
C O M P L E M E N T 
(LQC) 
(M)' 
—• Q 
7.2 
Msec 
Q is cleared, and a storage reference is made to the execution address M 
to obtain the 48-bit operand (M), which is complemented and then copied 
into Q. ( —0) can be loaded. 
20 
b 
m 
STORE A 
(STA) 
(A) —» M 
7.2 
Msec 
Copies the content of A into the storage register designated by M. 
21 
b 
m 
STORE Q 
(STQ) 
(Q) -> M 
7.2 
Msec 

CATEGORY 1. INSTRUCTIONS ff 
b 
m 
399 
Copies the content of Q into the storage register designated by M. 
60 
6 
m SUBSTITUTE ADDRESS U P P E R 
(SAU) 
α Μ· · ·α 0 -> 
Mw 
7.2 μββο 
The low order fifteen bits of (A) 
are copied into the upper address 
portion of the content of M. Content of A and the remaining bits of the 
content of M are not changed. 
61 
6 
m SUBSTITUTE ADDRESS LOWER 
(SAL) 
α 1 4· · ·θο -> M * 
7.2 
Msec 
The low order fifteen bits of (A) 
are copied into the lower address 
portion of the content of M. Content of A and the remaining bits of the 
content of M are not changed. 
Arithmetic 
14 
b 
m 
A D D 
(ADD) 
(A) 
+ (M) —• A 
7.2 
Msec 
The content of M obtained from storage is added to the current content 
of A. ( - 0 ) is produced if and only if (A) 
= ( - 0 ) and (M) 
= 
( - 0 ) . 
(M) is unchanged. Overflow can be sensed. 
15 
b 
m 
SUBTRACT 
(SUB) 
(A) 
- 
(M)-> 
A 
7.2 
Msec 
The content of M obtained from storage is subtracted from the current 
content of A. (—0) is produced if and only if (A) 
= (—0) and (M) 
= 
( + 0 ) . (M) is unchanged. Overflow can be sensed. 
24 
b 
m 
M U L T I P L Y I N T E G E R 
(MUI) 
(A)(M)-+QA 
25.2 + 0.8nf Msec 
The 96-bit product of the 48-bit content of A and the 48-bit content of 
M is formed in QA, with the high order 48 bits in Q and the 48 low order 
bits in A. The multiplier must be loaded into A prior to execution. The 
factors are treated as integers with the binary point assumed to be at the 
low order end of the sequence of digits in the A register. No overflow can 
occur. 
25 
b 
m 
D I V I D E I N T E G E R 
(DVI) 
(QA)i 
= (M)(A)F 
+ 
(Q)F 
65.2 μββο 
The 96-bit dividend in QA is divided by the 48-bit divisor in M. The 
dividend must be formed in QA prior to execution of the instruction, and 
it must be a correct extension of the 48-bit dividend loaded from storage. 
t η = number of ones in multiplier. 

400 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
That is, whatever the final positioning of the dividend in QA, the original 
48 bits must be surrounded by sign bits. The quotient is formed in A and 
the remainder in Q. Dividend and remainder have the same sign. All 
operands are treated as integers with the binary point assumed to be at 
the low order end of the sequence of digits in the registers involved. Over-
flow can be sensed. 
26 
b 
m 
M U L T I P L Y FRACTIONAL 
(MUF) 
(A)(M) 
-> 
AQ 
25.2 + 0.8nf Msec 
The 96-bit product of the 48-bit content of A and the 48-bit content of 
M is formed in AQ, with the high order bits in A and the low order bits in 
Q. The multiplier must be loaded into A prior to execution. The factors 
are treated as fractions with the binary point assumed to be immediately 
to the right of the sign bit, that is, between the highest order bit and the 
next highest order bit. The extended register AQ is reversed from that of 
the QA in the Multiply Integer instruction. No overflow can occur. 
27 
b 
m D I V I D E FRACTIONAL (DVF) 
(AQ)Z 
= (M)(A)F 
+ 
(Q)F 
65.2 
jusec 
The 96-bit dividend in A Q is divided by the 48-bit divisor in M. The 
dividend must be formed in AQ prior to execution of the instruction, and 
it must be a correct extension of the 48-bit dividend loaded from storage. 
That is, whatever the final positioning of the dividend in AQ, the original 
48 bits must be surrounded by sign bits. The quotient is formed in A and 
the remainder in Q. Dividend and remainder have the same sign. All 
operands are treated as fractions with the binary point assumed to be im-
mediately to the right of the sign bit, that is, between the highest order 
bit and the next highest order bit. The extended register AQ is reversed 
from that of QA in the Divide Integer instruction. Overflow can be sensed. 
30 
b 
m 
FLOATING A D D 
(FAD) 
(A) 
+ (M) 
—> A 
18.8 Msec 
The floating point word obtained from storage in M is added to the 
floating point word in A. The sum is normalized and rounded and is re-
tained in A. The remaining bits of the rounding operation are left in Q. 
Floating point words must be in proper format. Exponent overflow or 
underflow can be sensed. 
31 
b 
m FLOATING SUBTRACT (FSB) 
(A) - 
( M ) - > A 18.8 Msec 
The floating point word obtained from storage in M is subtracted from 
the floating point word in A. The difference is normalized and rounded 
t η = number of ones in multiplier. 

CATEGORY 1. INSTRUCTIONS ff 
b 
Μ 
401 
and is retained in A. The remaining bits of the rounding operation are 
left in Q. Floating point words must be in proper format. Exponent over-
flow or underflow can be sensed. 
32 
b 
m FLOATING M U L T I P L Y 
(FMU) 
(A)(M) 
A 
36.0 
Msec 
The floating point product of the floating point word from M and the 
floating point word from A is formed in A. The product is normalized and 
rounded. The remaining bits of the rounding operation are left in Q. 
Floating point words must be in proper format. Exponent overflow or 
underflow can be sensed. 
33 
b 
m FLOATING D I V I D E 
(FDV) 
(A)x 
= (M)(A)F 
56.0 
Msec 
The floating point quotient of the floating point dividend in A and the 
floating point divisor in M is formed in A. The quotient is rounded and 
normalized. The remaining bits from the rounding operation are left in Q. 
Floating point words must be in proper format. Exponent overflow or 
underflow can be sensed. 
70 
b 
m R E P L A C E A D D (RAD) 
[ ( M ) + ( A ) ] - * M and A 13.2 
Msec 
The 48-bit operand in storage location M is added to the initial content 
of A. The sum is left in A and is also transmitted to storage location M. 
Overflow can be sensed. 
71 
b 
m R E P L A C E SUBTRACT 
(RSB) 
\_(M) - 
(A)'] —» M and A 
13.2 
Msec 
The initial content of A is subtracted from the 48-bit operand in storage 
location M. The difference is left in A and is also transmitted to storage 
location M. Overflow can be sensed. 
72 
b 
m 
R E P L A C E A D D O N E 
(RAO) 
[ ( M ) + 1] -> M and A 
13.2 μββο 
The 48-bit operand in storage location M is increased by one. The aug-
mented value is retained in A and is also transmitted to storage location M. 
Overflow can be sensed. 
73 
b 
m R E P L A C E SUBTRACT ONE (RSO) 
[ ( M ) - l ] - > M a n d A 
13.2 Msec 
The 48-bit operand in storage location M is decreased by one. The de-
creased value is retained in A and is also transmitted to storage location 
M. Overflow can be sensed. 

402 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
Indexing 
M = ra f or all values of b 
7 
52 
b 
ra 
LOAD I N D E X U P P E R 
(LIU) 
(mua) 
B
b 
7.2 
Msec 
The content of the designated index register is replaced by the 15-bit 
upper address content of ra. No address modification occurs. If b = 0 , the 
instruction becomes a pass (do nothing) instruction. Initial content of ra 
is unchanged. 
53 
b 
ra 
LOAD I N D E X LOWER 
(LIL) 
(mia) 
B
h 
7.2 
Msec 
The content of the designated index register is replaced by the 15-bit 
lower address content of ra. No address modification occurs. If b = 0, 
the instruction becomes a pass (do nothing) instruction. Initial content of 
ra is unchanged. 
55 
b 
ra 
I N D E X J U M P 
(UP) 
(B
h) 
^ 0: [(£*) - 
1] 
B
b, 
jump to ra. 
(B
b) 
= 0: NI 
4.4 Msec 
The content of B
b is referenced. If the content is not zero, it is reduced 
by one and a normal jump is executed to the upper program step at ra. 
The counting operation is done in the R register, but ( — 0) is not generated, 
since the jump is terminated at ( + 0 ) . If the content of B
b is zero the next 
instruction is executed. 
56 
b 
ra 
STORE I N D E X U P P E R 
(SIU) 
(B
b) 
-> mua 
7.2 
Msec 
The 15 bits of the upper address portion of the content of ra are replaced 
by the content of the designated index register. The remaining bits of the 
content of ra are unaltered. No address modification of ra occurs. If b = 0, 
(rriua) is cleared to zero. Initial content of B
b is unchanged. 
57 
b 
ra 
STORE I N D E X LOWER 
(SIL) 
(B
b) 
-> mia 
7.2 
Msec 
The 15 bits of the lower address portion of the content of ra are replaced 
by the content of the designated index register. The remaining bits of the 
content of ra are unaltered. No address modification of ra occurs. If & = 0 , 
(mia) is cleared to zero. Initial content of B
b is unchanged. 
Logical 
(Logical products are bit by bit products, with (0) (0) = (0) (1) 
= 
(1)(0) = 0 ; (1)(1) 
= 1 . ) 
40 
b 
m 
SELECTIVE SET 
(SST) 
Set a{ for ra. = 1 
7.2 
Msec 

CATEGORY 1. INSTRUCTIONS ff 
b 
TU 
403 
If the content of M is mtfm& · ·ηΐο and the content of A is α47α4β· · ·αο, 
each α» for which the corresponding bit w< = 1, is set to the value one. 
Each ai for which the corresponding bit ra» = 0, is unaltered. 
41 
b 
m S E L E C T I V E CLEAR 
(SCL) 
Clear a, for rat- = 1 7.2 
Msec 
If the content of M is m^m^ 
· - mo, and the content of A is c^a^* · ·αο, 
each α< for which the corresponding bit m» = 1, is cleared to the value zero. 
Each α» for which the corresponding bit m» = 0, is left unaltered. 
42 
b 
m 
SELECTIVE C O M P L E M E N T 
(SCM) 
Complement α» for m< = 1 
7.2 ßsec 
If the content of M is τη^τη^· · - mo and the content of A is α^α^· · ·α 0 
each α, for which the corresponding bit m» = 1, is complemented. Each α» 
for which the corresponding bit m» = 0, is left unaltered. 
43 
& m 
SELECTIVE SUBSTITUTE 
(SSU) 
mi replaces α» for g< = 1 
7.4 μββο 
If the content of M is m^m^ 
· - mo, the content of A is GkzGUe* · ·αο,
 
a n (i 
the content of Q is #47<74β· · ·<Ζο, each α» for which the corresponding bit 
qi = 1 is replaced by ra». Each α» for which the corresponding bit 
= 0 
is left unaltered. 
44 
6 
m 
LOAD LOGICAL 
(LDL) 
L(Q)(M)-*A 
7.4 
Msec 
The content of A is replaced by the 48-bit logical product of the content 
of Q and the content of M. 
45 
b 
m A D D LOGICAL 
(ADL) 
1(A) 
+ L(Q) (Jlf)] - » A 
7.4 
Msec 
The initial content of A is replaced by the sum of its initial content and 
the logical product of the content of Q and the content of M. 
46 
δ 
m SUBTRACT LOGICAL 
(SBL) 
1(A) 
~ L ( Q ) ( M ) ] - > A 
7.4 Msec 
The initial content of A is replaced by the difference between its initial 
content and the logical product of the content of Q and the content of M. 
47 
b 
m 
STORE LOGICAL 
(STL) 
L(Q)(A)->M 
7.2 
Msec 
The content of M is replaced by the logical product of the initial content 
of A and the initial content of Q. Neither (Q)r nor (A)i 
is changed. 
Storage Test 
36 
b 
m 
STORAGE S K I P 
(SSK) 
(M) 
< 0; Exit; 
(M) 
> 0: Half exit 
8.8 Msec 

404 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
The sign bit, mA1, of the content of M is sensed. If it is a one, a full exit 
is taken. If it is a zero, a half exit is taken. Content of operational registers 
is unmodified. If the instruction is used in a lower program step, a full 
exit is taken if (M) 
< 0; but if (M) 
> 0, the instruction will cause a half 
exit on itself and a full exit is never made. 
37 
b 
m 
STORAGE S H I F T 
(SSH) 
12.8 Msec 
(Af) < 0: Exit and shift (M) left 1 
(M) 
> 0: Half Exit and shift (M) left 1 
The sign bit, mA1) of the content of M is sensed. If it is a one, (M) 
is 
shifted left by one and a full exit is taken. If it is a zero. (M) is shifted 
left by one and a half exit is taken. Content of operational registers is un-
modified. If the instruction is used in a lower program step, it will cause a 
half exit on itself until a one is sensed. 
Storage Search 
For 6 = 0, search is at storage location m only. 
64 
b 
m 
EQUALITY SEARCH 
(EQS) 
4.0 + 3.6rf Msec 
Search (B
b) words for one equal 
(A) 
If one is found: Full Exit. 
If none is found: Half Exit. 
A set of sequential storage locations is searched starting at m + (B
b) 
— 1. 
The content of B
b is reduced one for each search until it is zero or until an 
operand equal to the current content of A is found. If the search is termi-
nated by the finding of an operand equal to ( A ) , a full exit is made. If 
none is found equal to (A)} 
a half exit is made when (B
b) 
= 0. If a full 
exit is made on an equality, the address of the location of the operand 
equal to (A) is m plus the final (B
b). 
( + 0 ) and ( — 0) are sensed as equal. 
If the instruction is used at a lower program step, it will cause the next 
instruction to be executed when the search is terminated. 
65 
b 
m 
T H R E S H O L D SEARCH 
(THS) 
4.0 + 3.6rf Msec 
Search (B
b) words for one > 
(A) 
If one is found: Full Exit. 
If none is found: Half Exit. 
A set of sequential storage locations is searched starting at m + (B
b) 
— 1. 
The content of B
b is reduced by oue for each search until it is zero, or until 
an operand greater than the current content of A is found. If the search 
t r is the number of words searched. 

CATEGORY 1. INSTRUCTIONS ff 
b 
m 
405 
is terminated by the finding of an operand greater than (A), a full exit is 
made. If none is found greater than (A), a half exit is made when (B
b) 
= 0. 
If a full exit is made, the address of the operand greater than (A) 
is m 
plus the final (B
b). 
In the comparison, ( + 0 ) is considered to be greater 
than ( —0). If the instruction is used as a lower program step, it will cause 
the next instruction to be executed when the search is terminated. 
66 
b 
m 
M A S K E D EQUALITY SEARCH 
(MEQ) 
4.0 + 3.6rf Msec 
Search (B
b) words for one for which L(Q) (M) 
= 
(A). 
If one is found: Full Exit. 
If none is found : Half Exit. 
This instruction is identical with the Equality Search except that the 
comparison of (A) is with the logical product of the content of Q and the 
content of the searched storage location. 
67 
b 
m M A S K E D T H R E S H O L D SEARCH (MTH) 
4.0 + 3.6rf Msec 
Search (B
b) words for one for which L(Q) (M) 
> 
(A). 
If one is found: Full Exit. 
If none is found: Half Exit. 
This instruction is identical with the Threshold Search except that the 
comparison with (A) is the logical product of (Q) and the content of the 
searched storage location. 
I N P U T — O U T P U T 
M = m 
62 
b 
m 
I N P U T T R A N S F E R 
(INT) 
4.0 + 4.8rf Msec 
(B
b) words to storage locations starting at m + (B
b) 
— 1. 
The number of words specified by (B
b) 
is transferred from an external 
equipment into storage. The words are stored in sequentially numbered 
addresses from M = mtoM 
= m+ 
(B
b) 
— 1, although transferred in 
reverse order. The count in B
b is reduced by one for each word transferred 
until it is zero. 
63 
b 
m 
OUTPUT T R A N S F E R 
(OUT) 
4.0 + 4.8rf Msec 
(B
b) 
words from storage locations starting at m + (B
b) 
— 1. 
The number of words specified by (B
b) 
is transferred from storage to 
an external equipment. The words are stored in sequentially numbered 
addresses from M=mtoM=m 
+ (B
b) 
— 1, although transferred in 
t r is the number of words transferred. 

406 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
reverse order. The count in B
b is reduced by one for each word transferred 
until it is zero. 
Category 2. Instructions ff 
b 
k (operation code, index register, 
shift count) 
6 = 0 implies (B°) = 0 with no shift modification, effective shift count 
Κ = k. 
b = 1, 2, 3, 4, 5, or 6 modifies effective shift count to effective value 
Κ = k + 
(B
b). 
b = 7 is indirect addressing. 
Shifting 
01 
b 
k A R I G H T S H I F T (ARS) 
Shift (A) right by Κ 2.8 + 0.4s| Msec 
The content of A is shifted right Κ places. The vacated bit locations in 
the high order positions are replaced by sign bits. The low order bits are 
discarded. A shift count of forty-seven replaces all bits in A by sign bits. 
Larger shift counts will be executed, but for Κ > 127 (decimal), a fault 
indicator is set. 
02 
b 
k 
Q R I G H T S H I F T 
(QRS) 
Shift (Q) right by Κ 
2.8 + 0.4*t Msec 
The content of Q is shifted right Κ places. The vacated bit locations in 
the high order positions are replaced by sign bits. The low order bits are 
discarded. A shift count of forty-seven replaces all bits in Q by sign bits. 
Larger shift counts will be executed, but for Κ > 127 (decimal), a fault 
indicator is set. 
03 
b 
k 
LONG R I G H T S H I F T 
(LRS) 
Shift (AQ) 
right by Κ 
2.8 + 0.4sf Msec 
The content of A Q as one 96-bit register is shifted right Κ places, with 
(A) 
as the high order 48 bits. The high-order positions are replaced by 
sign bits, starting with those vacated in (A). 
The low order bits are dis-
carded, starting with those in (Q). A shift count of ninety-five will replace 
all bits in A and Q by the original sign bit of (A). 
Larger shift counts will 
be executed, but for Κ > 127 (decimal) a fault indicator is set. 
05 
b 
k A L E F T S H I F T 
(ALS) 
Shift (A) left by if 2.8 + 0.4sf 
Msec 
t s is the shift count. 

CATEGORY 2. INSTRUCTIONS ff 
b 
k 
407 
The content of A is shifted left Κ places. The shift is circular, that is, 
as the low order bit positions are vacated, they are replaced by the high 
order bits of (A). 
A shift count of forty-eight restores all bits to their 
original locations. Larger shift counts will be executed, but for Κ > 127 
(decimal) a fault indicator is set. 
06 
b 
k Q L E F T S H I F T 
(QLS) 
Shift (Q) left by Κ 
2.8 + 0.4sf 
Msec 
The content of Q is shifted left Κ places. The shift is circular, that is, 
as the low order bit positions are vacated, they are replaced by the high 
order bits of (Q). A shift count of forty-eight restores all bits to their 
original locations. Larger shift counts will be executed, but for Κ > 127 
(decimal) a fault indicator is set. 
07 
b 
k 
LONG L E F T S H I F T 
(LLS) 
Shift (AQ) left by Κ 
2.8 + 0.4sf Msec 
The content of A Q as one 96-bit register is shifted left Κ places, with 
(A) as the high order 48 bits. The shift is circular, that is, as the low order 
bit positions of (Q) are vacated, they are replaced by the high order bits 
of (A); 
and as the low order bit positions oî (A) 
are vacated, they are 
replaced by the high order bits of (Q). Because of the circular shift, the 
shift in AQ is the same as a shift in QA. A shift count of ninety-six will 
restore all bits to their original locations. Larger shift counts will be exe-
cuted, but for Κ > 127 (decimal) a fault indicator is set. 
For 34 and 35, Κ = k. 
34 
b 
k 
SCALE A 
(SCA) 
2.8 + 0.4sf Msec 
(A) left until α4γ τ* α 46 or k' = 0; k' —» B
b 
The content of A is shifted left circularly until the most significant bit 
is immediately to the right of the sign bit. The shift count is reduced by 
one for each shift and the final shift count is entered in B
b. 
Operation 
terminates when the shift count is reduced to zero or the two high order 
bits are different. For b = 0, the scaling is executed, but the count is lost. 
If {Α)ι 
= 0, Κ goes to B
b. 
35 
b 
k 
SCALE AQ 
(SCQ) 
2.8 + 0.4sf Msec 
(AQ) left until α 47 ^ a J 6 or k' = 0; k' -> B
b 
The content of the combined AQ register is shifted left circularly until 
the most significant bit is immediately to the right of the sign bit. The 
shift count is reduced by one for each shift and the final shift count is 
f s is the shift count. 

408 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
entered in B
b . Operation terminates when the shift count is zero or the 
two high order bits in ( A ) are different. For 6 = 0 , the scaling is executed 
but the count is lost. If ( A Q ) j = 0, Κ goes to B
b . 
Category 3. Instructions ff 
b 
y (operation code, index register, 
operand) 
6 = 0 implies (B°) = 0 with no operand modification and Y = y . 
6 = 1, 2, 3, 4, 5 or 6 modifies operand to effective Y = y + 
( B
b ) . 
6 = 7 is indirect addressing (see page 409). 
Transmissive 
04 
6 
y 
E N T E R Q 
( E N Q ) 
Y 
Q, extend sign Y 
3.0 
Msec 
The fifteen bit operand Y is entered into the fifteen low order positions 
of 0, and the high order bit (sign bit) of Y is extended in the remaining 
thirty-three bit locations of Q . ( — 0) is formed in Q if 6 = 0 and y = 77777 
or if ( B
b ) 
= 77777 and y = 77777. 
10 
6 
y 
E N T E R A 
( E N A ) 
Y - > A , extend sign Y 3.0 
Msec 
The fifteen bit operand Y is entered into the fifteen low order positions 
of A , and the high order bit (sign bit) of Y is extended in the remaining 
thirty-three bit locations of A . ( — 0) is formed in A if 6 = 0 and y = 77777, 
or if ( B
b ) 
= 77777 and y = 77777. 
11 
6 
y 
INCREASE A 
( I N A ) [Direct extension Y + 
( A ) ' ] 
—» A 
3.0 
Msec 
The fifteen bit operand Y is entered into the fifteen low order positions 
of X y and the high order bit (sign bit) of Y is extended in the thirty-three 
remaining bit locations of X . The content of X is then added to the initial 
content of A . Overflow can be sensed. 
50 
6 
y E N T E R I N D E X 
( E N I ) Y = y 
B
b ; 6 = 0, pass 3.0 
Msec 
The content of B
b is replaced by the operand Y = y . No operand modifi-
cation takes place. If 6 = 0 the instruction becomes a pass or do nothing 
instruction. 
51 
6 
y 
INCREASE I N D E X 
( I N I ) 
Y = y ; 
[ 7 + ( Β
6) ] -> B
b ; b = 0, pass 
3.0 
Msec 

CATEGORY 4. INSTRUCTIONS / / 
j 
M 
409 
The content of B
b is increased by the amount of the operand Y = y. 
No operand modification takes place. If b = 0 the instruction becomes a 
pass or do nothing instruction. 
54 
b 
y 
I N D E X S K I P 
(ISK) 
7.2 Msec 
Y = y; (B
b) 
* y, [ ( S
6) + 1 ] - * B\ half exit 
(B
b) 
= y, 0 - > B
b, full exit. 
The content of B
b is compared with Y = y. If the two quantities are 
equal, B
b is cleared to zero and a full exit is taken. If they are not equal, 
(B
b) 
is increased by one in the R register and a half exit is taken. N O 
operand modification takes place. Since R is a two's complement register, 
it is possible to count through ( —0) and ( + 0 ) .lib 
= 0 and Y = y τ* 0, 
a half exit is taken. If b = 0 and Y = y = 0, a full exit is taken. If the 
instruction is used as a lower instruction, it will half exit on itself until the 
full exit condition is satisfied. If b = 0 and y 
0 at a lower instruction, 
the full exit condition is never satisfied. This instruction can be used for 
timed delays in a program. In this case, the 7.2 μββο execution time is 
5.6 Msec. 
Note: In all instructions ff 
b 
m, k, y where the index designator is 6, 
a value of b = 7 results in indirect addressing. In all cases, the final fifteen 
bits of the instruction word is treated as an address. A storage reference is 
made to the register designated by this address and the eighteen low order 
bits of its content are taken as the index designator and address portion 
of the instruction in which b = 7. That is, if (mi) = f2f2 
b2 
m^, the 
instruction/i/i 
7 
mi will be executed a s / i / i 
b2 
m^. This execution is 
made regardless of whether the fifteen low order bits of the instruction are 
treated as addresses, shift counts or operands for values of b < 7. 
Category 4. Instructions ff 
/ 
m (operation code, condition, 
address) 
22 
j 
m 
A J U M P 
(AJP) 
Jump to m = M on condition 
7.2 μββο 
A jump is made to the register addressed by m = M if the condition 
specified by the index designator is satisfied in A. No address modification 
takes place. If the condition is not satisfied, the next instruction is executed. 
Conditions are: 
j = 0, jump if (A) 
= 0 
j = 1, jump if (A) 
0 
j = 2, jump if (A) 
> + 0 
j = 3, jump if (A) 
< - 0 
All jumps for j - 
0, 1, 2 or 3 are 
normal jumps to the upper instruc-
tion in 
(m). 

410 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
j = 4, return jump if (A) = 0 
j = 5, return jump if (A) 
0 
j = 6, return jump if (A) > 
+ 0 
j = 7, return jump if (A) 
< — 0 
All jumps for j = 4, 5, 6, or 7 are 
return jumps to the lower instruction 
in (ra). At the same time the upper 
address portion of (m) is replaced 
by the address of the next program 
step after the jump instruction in 
the main program. 
If (A) 
= ( - 0 ) it will be interpreted as ( + 0 ) for j = 0, 1, 4 or 5, but it 
will be interpreted as negative for j = 2, 3, 6 or 7. That is, for 
j = 0, 4: the jump is made 
j = 1, 5: the jump is not made 
j = 2, 6: the jump is not made 
j = 3, 7: the jump is made. 
23 j 
ra 
Q J U M P 
(QJP) 
Jump to ra = M on condition 
7.2 Msec 
A jump is made to the register addressed by ra = M if the condition 
specified by the index designator is satisfied in Q. No address modification 
takes place. If the condition is not satisfied, the next instruction is executed. 
Conditions are: 
j = 0, jump if (Q) = 0 
j = 1, jump if (Q) s* 0 
j = 2, jump if (Q) > 
+ 0 
j = 3, jump if (Q) < 
- 0 
,7* = 4, return jump if (Q) 
j = 5, return jump if (Q) 
j = 6, return jump if (Q) 
0 
0 
+ 0 
All jumps for j = 0, 1, 2, or 3 are 
normal jumps (see 22 j 
ra). 
All jumps for j = 4, 5, 6 or 7 are 
return jumps (see 22 j 
ra). 
j = 7, return jump if (Q) < —0 
(Q) = (—0) is interpreted as in the 22 j ra A jump. 
75 j 
ra 
SELECTIVE J U M P 
(SLJ) 
Jump to ra = M on condition 
7.2 ßsec 
A jump is made -to the register addressed by ra = M if the condition 
specified by the index designator is satisfied in A. No address modification 
takes place. If the condition is not satisfied, the next instruction is executed. 
Conditions are: 

CATEGORY 5. INSTRUCTIONS / / 
j 
Ζ 
411 
j = 0, jump unconditionally. 
j = 1, jump if jump key 1 is set on. 
j = 2, jump if jump key 2 is set on. 
j = 3, jump if jump key 3 is set on. 
j — 4, return jump unconditionally. 
= 5, return jump if jump key 1 is set on. 
j = 6, return jump if jump key 2 is set on. 
j = 7, return jump if jump key 3 is set on. 
76 
j 
m 
SELECTIVE STOP 
(SLS) 
All jumps for j = 0, 1, 2 or 
3 are normal jumps 
(see 
22 j 
m). 
All jumps for j = 4, 5, 6, or 
7 are return jumps 
(see 
22 j 
m). 
Stop on condition, jump to m 
7.2 Msec 
Computer stops if condition is satisfied. Jump is made in all cases. Com-
puter continues from jump address if stop is not made, or if Run-Step key 
is set. Conditions are: 
j = 0, stop unconditionally. 
j = 1, stop if stop key 1 is set on. 
= 2, stop if stop key 2 is set on. 
j = 3, stop if stop key 3 is set on. 
j = 4, stop unconditionally. 
j = 5, stop if stop key 1 is set on. 
= 6, stop if stop key 2 is set on. 
j = 7, stop if stop key 3 is set on. 
For j = 0, 1, 2, or 3 an uncondi-
tional normal jump is made to m 
(see 22 
m). 
For j = 4, 5, 6, or 7 an uncondi-
tional return jump is made to m 
(see 22 
j 
m). 
Category 5. Instructions ff / 
ζ (operation code, condition, code) 
74 
j 
ζ 
E X T E R N A L F U N C T I O N 
(EXF) 
The designator j is used as follows: 
Select: 
74 
0 
ζ 
6.4 
Msec 
Sense: 
74 
7 
ζ 
Activate: 74 
j 
z} where j = 1, 
6. 
For j = 0, the instruction selects the external equipment to be used. The 
fifteen bits of ζ represent a code which determines the equipment and the 
mode of operation. F o r = 7, the instruction senses an internal (fault) or 
external equipment condition, and the fifteen bits of ζ represent a code 
which specifies the condition to be sensed. Values o f = 
1, · · ·, 6 cause 
the instruction to activate a particular peripheral device, and the value of 
ζ is an address. 
1. Activate: j = 1, 
6. 

412 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
Six buffer channels and one high speed channel are available, and the j 
value specifies the buffer channel to be activated. Three channels are for 
input and three for output. The channel numbers and equipment which 
might typically be associated with them are: 
Input 
Channel 1 
(Console and card 
equipment) 
Channel 3 
(Magnetic tape) 
Channel 5 
(Magnetic tape) 
Channel 2 
Channel 4 
Channel 6 
Channel 7 
Output 
(Console and card 
equipment) 
(Magnetic tape) 
(Magnetic tape) 
(High speed printer) 
The console contains both the on-line typewriter and paper tape punch 
and reader. Data is transmitted in either the character mode or the assembly 
mode. In the character mode a block of seven (which can be five to eight) 
bits is buffered, one block at a time. The seven bits are the seven lowest 
order bits of a forty-eight bit word with the remaining forty-one bits zeros. 
In the assembly mode a block of forty-eight bits is buffered in sets of eight 
six-bit words which are assembled in the computer as forty-eight bit words. 
Associated with each channel is the storage register address of the same 
number. The purpose of the storage register is to hold the initial address 
and the terminal address plus one of the block of words in memory which 
is being buffered. The terminal address plus one must be stored in the 
lower address portion prior to activating the channel. The initial address, 
specified by the ζ value in the external function instruction is automatically 
stored in the upper address location. Thus, if the address β = bbbbb is 
stored at the lower address portion of register OOOOy, the instruction 
74 j 
a = aaaaa will provide that (OOOOj) = 
aaaaa 
bbbbb, and 
the block of words from a through /S — 1 will be buffered. Selection of the 
peripheral equipment is made prior to the instruction by use of the 74 
0 
ζ 
instruction as is the sensing of readiness by the 74 
7 
ζ instruction. 
2. Select: j = 0. 
For the value j = 0, the external function instruction selects the ex-
ternal equipment or controls internal selections. The structure of the 
fifteen-bit, 
five-octal 
digit code word ζ = 040302010ο is: 
04 
0 = Internal 
1-7 = Channel 
0302 
00-77 = Equipment: 
Typewriter 
11 
Paper tape 
12 
Magnetic tape 
20 
Card equipment 40 
Printer 
60 
0100 
00-77 = Mode 

CATEGORY 5. INSTRUCTIONS / / 
j 
Ζ 
413 
The codes are: 
SELECT 
74 
0 
000C0 
000C1 
00100 
00101 
00200 
01000 
02000 
00070 
C0000 
04000 
04001 
Interrupt on channel C inactive 
Remove Interrupt Selection on channel C 
Interrupt on arithmetic faults 
Remove Interrupt on arithmetic faults 
Clear carriage return flip-flop 
Start real-time clock 
Stop real-time clock 
Clear arithmetic faults 
Clear all channel C selections 
C = Channel number = 1-7 
Select interrupt lockout 
Clear interrupt lockout 
I N P U T 
74 
0 
11140 
100 
200 
210 
220 
OUTPUT 74 
0 
21100 
110 
200 
210 
240 
I N P U T 
74 
0 
320ΛΠ 
0N2 
000 
001 
002 
004 
005 
006 
007 
Select typewriter for input, and interrupt 
on carriage return 
Select typewriter for input, arid no inter-
rupt on C. R. 
Select paper tape reader, and no interrupt 
on end of tape 
Set end of tape indicator 
Select paper tape reader, and interrupt on 
end of tape 
Select typewriter for output, assembly mode 
Select typewriter for output, character mode 
Select paper tape punch, assembly mode 
Select paper tape punch, character mode 
Turn paper tape punch motor OFF 
Select read tape AT, binary mode 
Select read tape iV, coded mode 
Clear interrupt on selected read tape 
Read selected tape, binary mode 
Read selected tape, coded mode 
Interrupt when selected tape ready 
Rewind selected tape 
Backspace selected tape 
Rewind selected tape with interlock 

414 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
OUTPUT 74 
0 
4 2 0 M 
Select write tape N, binary mode 
0ΛΓ2 
Select write tape N, coded mode 
000 
Clear interrupt on selected write tape 
001 
Write selected tape, binary mode 
002 
Write selected tape, coded mode 
003 
Write end of file mark on selected tape 
004 
Interrupt when selected tape ready 
005 
Rewind selected tape 
006 
Backspace selected tape 
007 
Rewind selected tape with interlock 
Ν = Tape number = 1, 2, 3, 4 
I N P U T 
74 
0 
14001 
Select primary read station 
002 
Select secondary read station 
003 
Select primary and secondary read stations 
005 
Select primary read station and interrupt 
006 
Select secondary read station and interrupt 
007 
Select primary and secondary read stations 
and interrupt 
OUTPUT 74 
0 
24001 
Select printer 
002 
Select punch 
005 
Select printer and interrupt 
006 
Select punch and interrupt 
OUTPUT 74 
0 
76000 
Select printer 
(ONLY) 
001 
Single space the printer 
002 
Double space the printer 
003 
Select format channel 7 
004 
Select format channel 8 
010 
Clear monitor channels 1-6 
01N 
Select monitor channel Ν: Ν = 1-6 
3. Sense: j = 7. 
For the value j = 7, the external function instruction senses an internal 
condition or the state of an external equipment. The structure of the 
fifteen-bit, 
five-octal-digit 
code word ζ = 040302010ο is: 
04 
03 
020100 
0 = Internal 
0-7 = Equipment 
000-777 = Condition 
1-7 = Channel 

CATEGORY 5. INSTRUCTIONS / / 
j 
Ζ 
415 
The value j = 7 causes the external function instruction to act as a skip 
instruction. If used as an upper instruction it will exit if the condition is 
satisfied, and half-exit if it is not. If used as a lower instruction, it provides 
a wait, since it will half-exit on itself until the condition is satisfied. 
The codes are: 
SENSE 
74 
7 
000C0 
Exit on channel C active 
000CI 
Exit on channel C inactive 
C = channel = 1 — 7 
001A0 
Exit on arithmetic fault A 
001A1 
Exit on NO arithmetic fault A 
A = 1: Divide 
2: Shift 
3: Overflow 
4: Exponent overflow 
5: Exponent underflow 
I N P U T 
74 
7 
11200 
201 
210 
211 
140 
141 
100 
101 
Exit on 
Exit on 
Exit on 
Exit on 
Exit on 
Exit on 
Exit on 
Exit on 
paper tape reader, end of tape 
paper tape reader, NO end of tape 
paper tape reader in assembly mode 
paper tape reader in character mode 
typewriter in lower case 
typewriter in upper case 
carriage return from typewriter 
NO carriage return from typewriter 
OUTPUT 74 
7 
21200 
201 
Exit on paper tape punch out of tape 
Exit on paper tape punch not out of tape 
I N P U T 
74 
7 
32000 
Exit on ready to read 
001 
Exit on not ready to read 
002 
Exit on read parity error 
003 
Exit on NO read parity error 
004 
Exit on read length error 
005 
Exit on NO read length error 
006 
Exit on end of file mark 
007 
Exit on NO end of file mark 

416 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
OUTPUT 74 
7 
42000 
Exit on ready to write 
001 
Exit on not ready to write 
002 
Exit on write reply parity error 
003 
Exit on NO write reply parity error 
004 
Exit on write reply length error 
005 
Exit on NO write reply length error 
006 
Exit on end of tape marker 
007 
Exit on NO end of tape marker 
I N P U T 
74 
7 
14002 
Exit on reader ready 
003 
Exit on reader not ready 
004 
Exit on 1604 selected 
005 
Exit on 1604 not selected 
OUTPUT 74 
7 
24002 
Exit on printer ready 
003 
Exit on printer not ready 
004 
Exit on punch ready 
005 
Exit on punch not ready 
010 
Exit on 1604 selected 
011 
Exit on 1604 not selected 
O U T P U T 74 
7 
26000 
Exit on printer ready 
(ONLY) 
001 
Exit on printer not ready 
Abbreviated repertoire of CDC 1604 instructions in numerical order by 
code. 
00 
ZRO 
(Not a legal code). 
01 
ARS 
(A) Right Κ places. 
02 
QRS 
(Q) Right K places. 
03 
LRS 
{AQ) Right Κ places. 
04 
ENQ 
Sign extended Y —» Q. 
05 
ALS 
(A) Left Κ places. 
06 
QLS 
(Q) Left Κ places. 
07 
LLS 
(AQ), 
(QA) Left Κ places. 
10 
ENA 
Sign extended Y —> A. 
11 
INA 
Y+ 
(A)-+A. 
12 
LOA 
(M) -* 
A. 
13 
LAC 
(M)'-+A. 
14 
ADD 
(A) 
+ (M) -» 
A. 
15 
SUB 
(A) 
- 
(M) -> A. 
16 
LDQ 
(M) -» Q. 

CATEGORY 5. INSTRUCTIONS ff 
j 
17 
LQC 
(M)'->Q. 
20 
STA 
(A) 
-*M. 
21 
STQ 
(Q) -» 
M. 
22 
AJP 
Jump to m on condition j.} 
23 
QJP 
Jump to m on condition j . \ 
24 
MUI 
(A)(M)-+QA. 
25 
DVI 
(QA) 
= (M)(A) 
+ 
(Q). 
26 
MUF 
(A)(M) 
-+AQ. 
27 
DVF 
(AQ) 
= (M)(A) 
+ 
(Q). 
30 
FAD 
(A) 
+ 
(M,-*A. 
31 
FSB 
(A) 
- 
(M) 
A. 
32 
FMU 
(A)(M)-^A. 
33 
FDV 
(A)/(M)^A. 
34 
SCA 
Normalizet 
(A). 
35 
SCQ 
Normalize! 
(AQ). 
36 
SSK 
Storage skip.f 
37 
SSH 
Storage shift, f 
40 
SST 
Selective set.f 
41 
SCL 
Selective clear.f 
42 
SCM 
Selective complement.t 
43 
SSU 
Selective substitute.! 
44 
LDL 
Ll(Q), 
(M)l-+A. 
45 
ADL 
(A) 
+ L[(Q), 
46 
SBL 
(A) 
- 
L[(Q), 
(M)l-+A. 
47 
STL 
LKQ), 
(A)l-+M. 
50 
ENI 
y —> B
b; 
6 = 0 , pass. 
51 
INI 
y + (B
b) 
B
b. 
52 
LIU 
(mua) 
-> B
b. 
53 
LIL 
(mu) 
-> B
b. 
54 
ISK 
Index skip.f 
55 
UP 
Index jump.f 
56 
SIU 
(B
b) -> 
mua. 
57 
SIL 
(B
b) -> 
mla. 
60 
SAU 
(Ala) 
—• Mua. 
61 
SAL 
(Ala) 
-> 
Mla. 
62 
INT 
Input transfer, f 
63 
OUT 
Output transfer, f 
64 
EQS 
Equality search, f 
65 
THS 
Threshold search.f 
66 
MEQ 
Masked equality search.f 
t See complete repertoire for details. 
417 

418 
APPENDIX A. INSTRUCTIONS ON THE CDC 
1604 
67 
M TE 
Masked threshold search, t 
70 
RAD 
(A) 
+ (M) —» A and M. 
71 
RSB 
(M) 
- 
(A)^A 
and M. 
72 
RAO 
(M) 
+ l—> A and M. 
73 
RSO 
(M) 
- 
1-+A 
and M. 
74 
EXF 
External function.f 
75 
SLJ 
Selective jump.f 
76 
SLS 
Selective stop.f 
77 
SEV 
(Not a legal code). 
t See complete repertoire for details. 

APPENDIX Β 
Table of Powers of Two 
2
ft 
η 2-
-η 
1 
0 1 0 
2 
1 0 5 
4 2 0 
25 
8 
3 0 
125 
16 
4 0 
062 5 
32 
5 0 031 25 
64 
6 0 
015 625 
128 
7 0 007 812 5 
256 
8 0 
003 906 25 
512 
9 0 001 953 125 
1 024 
10 0 000 976 562 5 
2 
048 11 0 000 488 281 25 
4 096 12 0 000 244 140 625 
8 192 13 0 000 122 070 312 5 
16 384 14 0 000 061 035 156 25 
32 768 15 0 000 030 517 578 125 
65 536 16 0 000 015 258 789 062 5 
131 072 17 0 000 007 629 394 531 25 
262 144 18 0 000 003 814 697 265 625 
524 288 19 0 000 001 907 34a 632 812 5 
1 048 576 20 0 000 000 953 674 316 406 25 
2 
097 152 21 0 000 000 476 837 158 203 125 
4 194 304 22 
0 000 000 238 418 579 101 562 5 
8 388 608 23 0 000 000 119 209 289 550 781 25 
16 777 216 24 0 000 000 059 604 644 775 390 625 
33 554 432 25 0 000 000 029 802 322 387 695 312 5 
67 108 864 26 0 000 000 014 901 161 193 847 656 25 
134 217 728 27 0 000 000 007 450 580 596 923 828 125 
268 435 456 28 0 000 000 003 725 290 298 461 914 062 5 
536 870 912 29 0 000 000 001 862 645 149 230 957 031 25 
1 073 741 824 30 0 000 000 000 931 322 574 615 478 515 625 
2 
147 483 648 31 0 000 000 000 465 661 287 307 739 257 812 5 
4 294 967 296 32 0 000 000 000 232 830 643 653 869 628 906 25 
8 589 934 592 33 0 000 000 000 116 415 321 826 934 814 453 125 
17 179 869 184 34 0 000 000 000 058 207 660 913 467 407 226 562 5 
34 359 738 368 35 0 000 000 000 029 103 830 456 733 703 613 281 25 
68 719 476 736 36 0 000 000 000 014 551 915 228 366 851 806 640 625 
137 438 953 472 37 0 000 000 000 007 275 957 614 183 425 903 320 312 5 
274 877 906 944 38 0 000 000 000 003 637 978 807 091 712 951 660 156 25 
549 755 813 888 39 0 000 000 000 001 818 989 403 545 856 475 830 078 125 
1 099 511 627 776 40 0 000 000 000 000 909 494 701 772 928 237 915 039 062 5 
2 
199 023 255 552 41 0 000 000 000 000 454 747 350 886 464 118 957 519 531 25 
4 398 046 511 104 42 0 000 000 000 000 227 373 675 443 232 059 478 759 765 625 
8 796 093 022 208 43 0 000 000 000 000 113 686 837 721 616 029 739 379 882 812 5 
17 592 186 044 416 44 0 000 000 000 000 056 843 418 860 808 014 869 689 941 406 25 
35 184 372 088 832 45 0 .000 000 000 000 028 421 709 430 404 007 434 844 970 703 125 
70 368 744 177 664 46 0 .000 000 000 000 014 210 854 715 202 003 717 422 485 351 562 5 
140 737 488 355 328 47 0 .000 000 000 000 007 105 427 357 601 001 858 711 242 675 781 25 
419 

APPENDIX C 
Flex Code 
UC 
LC 
A 
30 
N 
06 
Β 
23 
0 
03 
C 
16 
P 
15 
D 
22 
Q 
35 
Ε 
20 
R 
12 
F 
26 
S 
24 
G 
13 
T 
01 
H 
05 
U 
34 
I 
14 
V 
17 
J 
32 
w 
31 
Κ 
36 
X 
27 
L 
11 
Y 
25 
M 
07 
ζ 
21 
(Zero) 
(One) 
0 
37 
1 
52 
2 
74 
3 
70 
4 
64 
5 
62 
6 
66 
7 
72 
8 
60 
9 
33 
Numerals and letters are the usual for upper and lower case. 
Flex Code CDC 1604 
Digits (upper and lower case) 
Alphabet same 
as above. 
(Zero) 
(One) 
0 
56 
1 
74 
2 
70 
3 
64 
4 
62 
5 
66 
6 
72 
7 
60 
8 
33 
9 
37 
— 
56 
- 
Γ 
50 
( 
46 
) 
42 
/ 
+ 
54 
= 
44 
Back space 
61 
Carriage return 
45 
Code delete 
77 
Color shift 
02 
Shift down 
57 
Shift up 
47 
Space 
04 
Stop 
43 
Tabulate 
51 
UC 
LC 
( 
+ 
52 
44 
54 
46 
42 
50 
Typewriter functions are 
as above except add: 
Tape feed 
00 
420 

MAGNETIC TAPE BCD CODE (CDC 
1604) 
421 
On-Line Typewriter Code CDC 1604 
Digits 
UC 
LC 
Alphabet same 
as above. 
UC 
LC 
) 
(Zero) 
0 
56 
* 
(One) 
1 
74 
@ 
2 
70 
# 
3 
64 
$ 
4 
62 
% 
5 
66 
Typewriter functions: 
i 
6 
2 
Tab 
51 
& 
7 
60 
Space 
04 
8 
33 
Backspace 
61 
( 
9 
37 
Carriage return 
45 
-
52 
Lower case 
57 
Γ 
I 
44 
Upper case 
47 
+ 
54 
46 
42 
50 
40 
02 
Magnetic Tape BCD Code (CDC 1604) 
A 
61 
N 
45 
(Zero) 
0 
12 
à 
Β 
62 
O 
46 
(One) 
1 
01 
-
C 
63 
P 
47 
2 
02 
I 
D 
64 
Q 
50 
3 
03 
, 
Ε 
65 
R 
51 
4 
04 
$ 
F 
66 
S 
22 
5 
05 
* 
G 
67 
T 
23 
6 
06 
f 
H 
70 
u 
24 
7 
07 
% 
I 
71 
V 
25 
8 
10 
# 
J 
41 
w 
26 
9 
11 
@ 
Κ 
42 
X 
27 
(Minus zero) 
52 
L 
43 
Y 
30 
(Plus zero) 
72 
Record mark 
M 
44 
ζ 
31 
(Blank) 
20 
Group mark 
60 
40 
21 
73 
53 
54 
33 
34 
13 
14 
74 
32 
77 
Tape mark 
17 
(Codes are in octal) 

422 
APPENDIX C. FLEX CODE 
=8 
13 
[ 
17 
î 
55 
( 
34 
] 
32 
1 
56 
) 
74 
— • 
35 
> 
57 
00 
= 
36 
< 
72 
14 
Λ 
37 
> 
75 
< 
15 
V 
52 
? 
76 
τ 
16 
Ί 
53 
t 
77 
Punched Card Codes 
Char. Card BCD 
Char. Card BCD 
Char. Card BCD 
Char. Card BCD 
+ 
12 
60 
— 
11 
40 
20 
1 
01 
A 
12 
1 
61 
J 
11 
41 
/ 
0 
1 
21 
2 
02 
Β 
12 
2 
62 
Κ 
11 
2 
42 
S 
0 
2 
22 
3 
03 
C 
12 
8 
63 
L 
11 
3 
43 
Τ 
0 
3 
23 
4 
04 
D 
12 
4 
64 
M 
11 
4 
44 
υ 
0 
4 
24 
5 
* 
05 
Ε 
12 
6 
65 
Ν 
11 
6 
45 
ν 
0 
δ 
25 
6 
• 
06 
F 
12 
6 
66 
0 
11 
β 
46 
w 
0 β 
26 
7 
07 
G 
12 
7 
67 
Ρ 
11 
7 
47 
χ 
0 
7 
27 
8 
10 
H 
12 
8 
70 
Q 
11 
8 
50 
Υ 
0 
8 
30 
9 
11 
I 
12 
9 
71 
R 
11 
9 
51 
ζ 
0 
9 
31 
0 
• 
12 
+ 
0 
12 
0 
72 
0 
11 
0 
52 
-
8,8 
13 
12 
8,3 
73 
$ 
11 
8.3 
53 
> 
0 
8,3 
33 
-
8,4 
14 
) 
12 
8.4 
74 
* 
11 
8,4 
54 
( 
0 
8,4 
34 
1612 Printer Code 
Same as Magnetic Tape Code, except & becomes + for 60, and add: 

APPENDIX D 
C O D A P Assembly Program 
Location Term 
The LOCN, or "L" term, is used to assign an identifier to an instruction, 
constant or location. During assembly, a machine address is assigned to 
this identifier. Subsequent references in the program to the identifier refer 
to its assigned machine address. Each identifier must be unique; that is, 
it cannot appear in more than one location field. Identifiers contain a 
maximum of eight characters, the first of which cannot be a number. 
Location term characters may be letters, numbers, or special characters 
such as colon (:) or comma (,). 
Operation Code Term 
The OPN term may be a mnemonic code of three to six letters, or the 
numeric octal operation code of the desired instruction. An OPN term 
must be present in each entry. The OPN terms may be CDC 1604 machine 
instructions, alternative mnemonic codes from Appendix A or pseudo-
operation codes from the table on p. 426. 
"b" 
Term 
The " 6 " term is used to give the designator value. 
"m" 
Term 
The "ra" term or address portion of an instruction may be either a 
number, a parameter, or a symbolic term. In any case, the "m" term repre-
423 

424 
APPENDIX D. CODAP ASSEMBLY PROGRAM 
sents some numeric value (s). For machine instruction entries, the "ra" 
term can be a constant, an identifier, or an expression consisting of an 
identifier plus or minus a constant. The "m" term of a pseudoinstruction 
can consist of multiple symbols or constants. 
" m " Constants 
A constant consists of either a positive or negative decimal value not 
exceeding a magnitude of 32,767, or a positive or negative octal value not 
exceeding 77777. Decimal values may be followed by a D ; octal values 
must be followed by a B. 
Symbolic " m " Terms 
An "m" term identifier is either identical to a LOCN term appearing 
elsewhere, is a single asterisk (*), or a double asterisk (**). A single 
asterisk denotes "this location"; a double asterisk is defined as minus 
zero (—0) unless defined differently within the program by an EQU 
pseudo op. 
If a program is assembled relocatable, each input record with a symbolic 
' V 
term is flagged with a plus on the assembly listing if the symbolic 
term is relocatable. All numeric or nonrelocatable symbolic "m" terms 
are treated as "fixed" and are not flagged. External symbols in an "m" 
field cannot be modified by adding or subtracting a numerical value or a 
variable. 
"m" 
Term for Pseudo Ops 
If the OPN field contains a pseudoinstruction, the "wi" term is a param-
eter. Correct formats of "m" terms which require special treatment are 
described under the pseudoinstructions to which they relate. In formats 
where the "m" term can extend beyond column 40, the first blank en-
countered anywhere in the "m" term terminates the field, "ra" terms can-
not be split or continued onto a second card. 
Remarks 
Remarks are optional. They may accompany machine or pseudoinstruc-
tions by appearing in columns 41-72, or they may constitute the entire 
input record (columns 20-72). To obtain an entire input record devoted 

PAIRING RULES 
425 
to remarks, the R E M pseudoinstruction must appear in the OPN field. 
The remarks appear in columns 20-72. A maximum of 52 characters can 
appear in a single R E M input record. Blanks count as characters in a 
remark. 
Pairing Rules 
During coding, the programmer must realize that each instruction oc-
cupies one-half of a word, each constant occupies an entire word, each 
DEC, OCT, BCD, FLX, TEL, BSS, BES, BLOCK, and C O M M O N 
input record results in an integral number of words, and each I D E N T , 
E J E C T , R E M , EQU, ORG, ORGR, FINIS, E N D , E X T , LIB, E N T R Y , 
I/O, and SPACES input record does not result in a word. Because some 
instructions such as Load Index Lower (LIL) refer to a specific half of 
a word, and because the addition of a constant (n) to an address incre-
ments the address by η locations (not by η instructions), it is necessary 
that the programmer assure proper pairing of his instructions. He must 
know whether an instruction is to be assembled into the upper or lower 
half of a computer word. 
The rules governing spacing and automatic insertion of N O P (do-
nothing) codes are listed below: 
(a) Any instruction entry preceded by a location symbol will be auto-
matically forced into the upper half of a computer word. 
(b) Any instruction entry preceded by a " + " sign (instead of a loca-
tion symbol) will be forced into the upper half of a computer word; 
similarly, any instruction entry preceded by a " — " sign will be 
forced into the lower half. The " + " or " — " sign must be in column 
one. 
(c) Each skip instruction of the following types will be forced into the 
upper half, unless marked by a " - " sign: EQS, THS, M T H , 
MEQ, ISK, SSH, SSK, E X F 7 or SEN. 
(d) Any entry representing one or more constants (DEC, OCT, FLX, 
BCD) will cause one or more complete computer words to be 
created, and the location symbol, if present, will be assigned to the 
first assigned location. 
(e) Any lower half instruction following an unconditional upper half 
return jump instruction will not be executed. 
(f) The BSS function leaves an integral number of memory locations, 
and the location symbol is assigned to the first assigned location. 
(g) The BES function leaves an integral number of memory locations, 
and the location symbol is assigned to the last assigned location. 

426 
APPENDIX D. CODAP ASSEMBLY PROGRAM 
(h) The pseudo operations ORG, EQU, I D E N T , R E M , F I N I S , E N D , 
ORGR, E J E C T , SPACES, E X T , LIB, E N T R Y , and I / O are not 
assigned memory space; however, ORG, ORGR, E N D , SPACES, 
R E M and E J E C T force the next instruction into the upper half. 
(i) 
Space is alternately assigned to upper and lower halves (or to both 
halves, for constants), and each unused half is automatically filled 
with a N O P code, an ENI 
0 0. 
PSEUDOINSTRUCTION CODES 
Code 
Description 
BCD 
Binary coded decimal 
BES 
Reserve block, end with symbol 
BLOCK 
Identify data region 
BSS 
Reserve block, starting with symbol 
COMMON 
Identify COMMON arrays 
DEC 
Decimal constant 
EJECT 
Eject line printer page 
END 
Physical end of subprogram 
ENTRY 
Entry point symbol 
EQU 
Equivalence 
EXT 
External symbol 
FINIS 
Physical end of source program 
FLX 
Flexowriter code 
IDENT 
Identifier 
i/o 
Input/output assignments 
LIB 
Identify library routine 
OCT 
Octal value 
ORG 
Origin address 
ORGR 
Origin address relocatable 
REM 
Remarks only 
SPACES 
Space listing 
TEL 
Teletype codes 

APPENDIX Ε 
Fortran Symbolic Addresses 
The classes of addresses permissible for each instruction in the C D C 
1604 are the following. 
Address Types 
w 
Symbolic Address or Variable Name for Floating Point Decimal 
Numbers (Fortran F, Ε fields) 
u 
Symbolic Address or Variable Name for Decimal Integer (Fortran / 
fields) 
/ 
Decimal Numbers and Floating Point Decimals (Fortran F} 
Ε 
fields) 
i 
Decimal Integers (Fortran / 
fields) 
b 
Octal Integers (Fortran 0 
fields) 
ρ 
Positive Decimal or Octal Integers (Identified by B) 
η 
Statement Number (Fortran) 
t 
Fortran Symbolic Tag 
I 
Program Name 
Permissible 
Instruction 
addresses 
A. LDA, LAC, LDQ, LQC, EQS, THS, MEQ, M T H 
w, % /, i, 6, t 
ADD, SUB, MUI, DVI, MUF, D V F 
w, u, i, b, t 
FAD, FSB, FMU, FDV 
w, u, /, t 
SST, SCL, SCM, SSU, LDL, ADL, STL 
w, u, 6, t 
B. ENQ, ENA, INA, ENI, INI, ZR0, SEV 
w, u, t, 6, t 
ISK, ARS, QRS, LRS, ALS, QLS, LLS, SCA, SCQ 
ρ 
E X F 
w, u, 6, t 
427 

428 
APPENDIX Ε. FORTRAN SYMBOLIC ADDRESSES 
Instruction 
Permissible 
addresses 
C. STA, STQ, SSK, SSH, STL, INT, OUT 
RAD, RSB, RAO, RSO 
w, u, t 
Wy Uy t 
71, ty t 
D. AJP, QSP, U P , SLJ, SLS 
LIU, LIL, SIU, STL, SAU, SAL 
Wy Uy Uy t 
Constants in address parts of Class A instructions are converted and 
stored with their storage addresses compiled in the instruction itself. 
Constants in address parts of Class Β instructions are converted and com-
piled directly into the address part of the instruction. In intermixed 
Fortran 
and Fortran Symbolic the conventional Fortran restrictions on symbolic 
names and modes apply. 

APPENDIX F 
Fortran 
1. Operations, Numbers, Symbolic Names 
Operations: Parenthesized quantities are evaluated first. Within the 
parentheses and in the entire expression exponentiation (**) is performed 
first, multiplications (*) and divisions (/) second, and additions ( + ) and 
subtractions ( — ) third. Within any one of these three classes operations 
are performed from left to right if there are no parentheses. 
Fixed Point Names and Constants: Fixed point variable names and fixed 
point function names may consist of from 1 to 7 letters and numbers. The 
first character must be a letter I, J, K, L, M, or Ν and the last character 
must not be an F if four or more characters are used. Positive, negative, 
and zero integer values less than 2
4 7 — 1 in magnitude may be assumed 
unless a variable name is a single character I — Ν which further restricts 
the magnitude to less than 16384. Fixed point constants are written with-
out decimal points and commas. 
Floating Point Names and Constants: Floating point variable names and 
floating point function names may consist of from 1 to 7 letters and num-
bers. The first character must be a letter, but not I — N. The initial letter 
X should not be used in names four or more characters long. 
Zero and values in magnitude between 1 0
- 3 08 and 10+
3 08 may be assumed. 
2. Available Functions 
The argument(s) may be any arithmetic expression (s) in the same 
mode as the function being used. 
429 

430 
APPENDIX F. FORTRAN 
Trig, functions 
S I N F 
C0SF 
T A N F 
C T N F 
S E C F 
CSCF 
Inverse trig, 
functions 
ASINF 
AC0SF 
ATANF 
A C T N F 
ASECF 
ACSCF 
Hyper, functions 
SINH 
C0SH 
T A N H 
C T N H 
SECH 
CSCH 
Inverse hyper, 
functions 
ASINH 
AC0SH 
A T A N H 
A C T N H 
ASECH 
ACSCH 
These are floating point functions of floating point arguments. All func-
tions are accurate to 10 decimal places in the normal (non-reduced) range 
of the argument. 
Name 
Definition 
Mode of : 
No. of 
Args. 
Argument 
Function 
SQRTF 
V A r g 
1 
Floating 
Floating 
E X P F 
exp Arg 
1 
Floating 
Floating 
L0GF 
log. Arg 
1 
Floating 
Floating 
L0G1OF 
logio Arg 
1 
Floating 
Floating 
ABSF 
Arg 1 
1 
Floating 
Floating 
XABSF 
Arg j 
1 
Fixed 
Fixed 
I N T F 
Sign of Arg times 
1 
1 
Floating 
Floating 
X I N T F 
largest integer < 1 Arg |J 
1 
Floating 
Fixed 
S I G N F 
"Sign of Arg 2 
1 
2 
Floating 
Floating 
X S I G N F 
Times | Argi | J 
2 
Fixed 
Fixed 
M0DF 
"Argi (mod Arg 2), i.e., 1 
2 
Floating 
Floating 
XM0DF 
remainder of Argi/Arg 2J 
2 
Fixed 
Fixed 
D I M F 
"Argi - min (Argi, Arg 2)] 
2 
Floating 
Floating 
X D I M F 
2 
Fixed 
Fixed 
S T E P 
=0 if Arg < - 0 , " 
1 
Fixed or 
Floating 
1 if Arg > 
+ 0 
Floating 
FL0ATF 
floats a fixed num oer 
1 
Fixed 
Floating 
X F I X F 
Fixes a floating number 
1 
Floating 
Fixed 
MAXOF 
Max(Argi, 
> 2 
Fixed 
Floating 
MAX1F 
Arg 2, · · ·, Arg*) 
> 2 
Floating 
Floating 
XMAXOF 
> 2 
Fixed 
Fixed 
XMAX1F 
> 2 
Floating 
Fixed 
MINOF 
"Min (Argi, 
> 2 
Fixed 
Floating 
MIN1F 
Arg 2, · · ·, Argjv) 
> 2 
Floating 
Floating 
XMINOF 
> 2 
Fixed 
Fixed 
XMIN1F 
> 2 
Floating 
Fixed 

Statement 
V = e 
GO TO η 
GO TO (m, n 2, 
nk)I 
I F ( e ) w i , n 2, n 3 
DO η I = rii, n 2, ri3 
or DO η I = nh 
n 2 
C O N T I N U E 
STOP or STOP ra 
F U N C T I O N 
Γ 
(CT, CT, · · · , CT) 
S U B R O U T I N E S 
(CT, 
CT, 
CT) 
CALL S(e, e, . . . , e ) 
R E T U R N 
E N D 
D I M E N S I O N 
AQ),B(i,j),. 
C(i,j, 
k) 
3. 
FORTRAN STATEMENTS 
Next 
sequence 
of 
state-
ments through 
statement 
number n, repeated for val-
ues of / = rii, rii + n 3, rii + 
2n 3, · · ·, rii + 
knz < ri2, 
but rii + (k + l ) n 3 > n 2. 
Dummy, primarily for DO 
loops in which η cannot be a 
control statement. 
Terminates program, types 
ra. 
First statement in function 
subprogram. 
First statement in subrou-
tine subprogram. 
Activates subroutine S. 
Subprogram exit. 
Last statement 
of 
PRO-
G R A M or subprogram. 
Reserves storage for each 
array A, B,..., 
C as speci-
fied by positive integral sub-
script-values i, j , fc, and 
must appear before use of 
array. (Maximum of 3 sub-
scripts.) 
431 
Sequencing 
Next executable state-
ment. 
Statement number n. 
Statement number nj. 
e < 0, Statement no. ni 
e = 0, Statement no. n 2 
e > 0, Statement no. n 3. 
After 
Do-loop 
com-
plete 
the 
next 
exe-
cutable statement after 
no. n, unless internal 
branch. 
Terminates problem. 
Next executable state-
ment. 
Next executable state-
ment. 
First statement of 
S. 
Statement 
following 
CALL. 
Terminates PRO-
G R A M acts as a R E -
T U R N on subprogram. 
Not executable. 
3. Fortran Statements 
Description 
Arithmetic 
statement, 
V, 
assumes current value of e. 
Unconditional jump. 
Computed jump. 
Conditional jump. 

432 
APPENDIX F. FORTRAN 
COMMON 
Variables in same relative 
Not executable. 
V, V, . . ., V 
position from the end of the 
list of common statements 
of 
different 
subprograms 
and/or programs use the 
same storage 
locations. 
4. Fortran Input/Output Statements 
Statement 
Description 
Sequencing 
R E A D n, List, or 
R E A D η 
P U N C H n, List, or 
P U N C H η 
P R I N T n, List, or 
P R I N T η 
R E A D I N P U T 
T A P E t, n, List 
W R I T E OUTPUT 
T A P E t, n, List 
F O R M A T 
(ft, 
ft, 
ft) 
W R I T E T A P E 
t, 
List 
R E A D 
T A P E 
t, 
List 
Read variables in list from 
80 column punched cards 
using F O R M A T statement 
n. 
Punch variables in list on 80 
column cards using FOR-
MAT statement n. 
Print variables in list on 120 
column paper using FOR-
M A T statement n. 
Read variables in list from 
tape 
t 
using 
F O R M A T 
statement n. 
Write variables in list on 
tape 
t 
using 
F O R M A T 
statement n. 
Must have statement num-
ber used by prior state-
ments to indicate arrange-
ment of information on the 
input-output media as di-
rected by format controls 
C,. 
Write variables in list on 
tape t in binary format. 
Read variables in list from 
tape t in binary format. 
Next executable state-
ment. 
Next executable state-
ment. 
Next executable state-
ment. 
Next executable state-
ment. 
Next executable state-
ment. 
Not executable. 
Next executable state-
ment. 
Next executable state-
ment. 
Statement 
Description 
Sequencing 

4. 
FORTRAN INPUT/OUTPUT STATEMENTS 
433 
E N D F I L E t 
R E W I N D t 
BACKSPACE t 
Writes an end-of-file mark 
Next executable state-
signifying end of run on 
ment, 
tape t. 
Rewinds tape t 
to load 
Next executable state-
point, 
ment. 
Moves tape t 
back one 
Next executable state-
record, 
ment. 
In some of the later versions of Fortran the input and output state-
ments have the following form, in which e represents a code for a particular 
piece of equipment. 
R E A D (e, n), List 
W R I T E (e, n), List 
R E A D (e), List 
W R I T E (e), List 
The function of these is the same as those listed above. The words I N P U T 
and O U T P U T have been dropped from the tape statements and R E A D 
and W R I T E replace the other statements. Thus R E A D (e, n) with a 
value of e corresponding to the card reader is equivalent to R E A D η 
while W R I T E (e, n) with the proper e value for the punch would be the 
equivalent of P U N C H n. In these versions of Fortran the names of the 
functions have also been changed to conform with first character usage 
relative to floating and fixed point operands. Thus, the beginning letter 
corresponds to the form of output. The final F in the function name has 
also been dropped. The names corresponding to the functions of page 
430 in the order and with the same definition as there are: 
Trigonometric 
SIN 
C0S 
TAN 
C T N 
SEC 
CSC 
Inverse 
Trigonometric 
ASIN 
AC0S 
ATAN 
ACTN 
ASEC 
ACSC 
Hyperbolic 
S I N H 
C0SH 
T A N H 
C T N H 
SECH 
CSCH 
Inverse 
Hyperbolic 
ASINH 
AC0SH 
ATANH 
A C T N H 
ASECH 
ACSCH 
Statement 
Description 
Sequencing 

434 
APPENDIX F. FORTRAN 
Name 
Name 
Name 
Name 
Name 
SQRT 
IABS 
M0D 
FL0AT 
M A X I 
E X P 
A I N T 
IM0D 
I F I X 
AMINO 
AL0G 
I N T 
D I M 
ΑΜΑΧΟ 
AMIN1 
AL0G1O 
SIGN 
I D I M 
A M A X I 
MINO 
ABS 
ISIGN 
S T E P 
MAXO 
M I N I 
The admissible character set for Fortran is: 
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
0 1 2 3 4 5 6 7 8 9 Η 
* / ( ) = · , Λ (space) The character $ 
may be used in //-fields. 

APPENDIX G 
Miscellaneous Subroutines 
The following programs are the remaining subprograms used by the 
I N T E R P routine of Chapter 8. 
SUBROUTINE P O L R M U L 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, M I , OPBM 
LDA (PAR) 
F M U ( M R ) 
STA (PAR) 
LDA(PAI) 
F A D (MI) 
STA (PAI) 
SLJ (IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE POLRDIV 
LIB ( I N T E R P = 
IN) 
C O M M O N PAR, PAI, MR, M I , OPBM 
LDA (PAR) 
F D V ( M R ) 
STA (PAR) 
LDA (PAI) 
F S B ( M I ) 
STA(PAI) 
SLJ (IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE R E C T A D D 
LIB ( I N T E R P = 
IN) 
C O M M O N PAR, PAI, MR, M I , OPBM 
LDA (PAR) 
F A D (MR) 
STA(PAR) 
LDA (PAI) 
F A D (MI) 
STA (PAI) 
SLJ (IN) · E X I T F R O M S U B R O U T I N E 
E N D 
435 

436 
APPENDIX G. MISCELLANEOUS 
SUBROUTINES 
SUBROUTINE RECTSUB 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (PAR) 
FSB (MR) 
STA (PAR) 
LDA (PAI) 
FSB (MI) 
STA (PAI) 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE R E C T M U L 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (PAR) 
STA ( T E M P ) 
F M U ( M R ) 
STA (PAR) 
LAC (PAI) 
F M U ( M I ) 
FAD (PAR) 
STA (PAR) 
LDA (PAI) 
F M U ( M R ) 
STA (PAI) 
LDA (TEMP) 
F M U ( M I ) 
FAD (PAI) 
STA(PAI) 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE R E C T D I V 
LIB ( I N T E R P = IN, R E C T M U L = 
R M ) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MR) 
F M U ( M R ) 
STA(T) 
LDA (MI) 
F M U ( M I ) 
F A D ( T ) 
STA(T) 
LDA (MR) 
F D V ( T ) 
STA (MR) 
LAC (MI) 
F D V ( T ) 
STA (MI) 
SLJ4(RM) 
E N D 
SUBROUTINE RECPOL 
LIB ( I N T E R P = IN, R E C T P O L = 
RP) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MR) 
L D Q ( M I ) 
SLJ4(RP) 
ZRO(*) 
STA(PAI) 
STQ(PAR) 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 

APPENDIX G. MISCELLANEOUS 
SUBROUTINES 
SUBROUTINE P O L R E C 
LIB ( I N T E R P = IN, P O L R E C T = 
PR) 
C O M M O N PAR, PAI, MR, M I , OPBM 
LDA (MR) 
L D Q ( M I ) 
SLJ4(PR) 
ZRO(*) 
STA (PAR) 
STQ(PAI) 
SLJ (IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE ZRO 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, M I , OPBM 
C 
T H I S W I L L ZERO T H E PSEUDO ACCUMULATOR 
ENA(O) 
STA (PAR) 
STA (PAI) 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE COMLOAD 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MR) 
STA (PAR) 
LDA (MI) 
STA(PAI) 
SLJ (IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE COMSTOR 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (PAR) 
STA7 (OPBM) 
RAO (OPBM) 
LDA (PAI) 
STA7(OPBM) 
SLJ (IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE P O L R E X P 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, PR, PI, OPBM 
PAR = 
COSF(PI) 
LDA (PAR) 
F M U ( P R ) 
STA (PAR) 
PAR = 
E X P F ( P A R ) 
PAI = 
S I N F ( P I ) 
LDA (PAI) 
F M U ( P R ) 
STA(PAI) 
SLJ (IN) 
E N D 

438 
APPENDIX G. MISCELLANEOUS 
SUBROUTINES 
SUBROUTINE R E C T E X P 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
A = 
E X P F ( M R ) 
PAR = 
COSF(MI) 
PAI = 
S I N F ( M I ) 
LDA (PAR) 
F M U ( A ) 
STA (PAR) 
LDA(PAI) 
F M U ( A ) 
STA(PAI) 
SLJ(IN) · E X I T F R O M SUBROUTINE 
E N D 
SUBROUTINE POLRMAG 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MR) 
STA (PAR) 
ENA(O) 
STA (PAI) 
SLJ(IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE R E C T M A G 
LIB ( I N T E R P = IN, SQRT = SQ) 
COMMON PAR, PAI, MR, MI, OPBM 
LDA (MR) 
L D Q ( M I ) 
SLJ4(SQ) 
ZRO(*) 
STA (PAR) 
ENA(O) 
STA(PAI) 
SLJ(IN) · E X I T F R O M S U B R O U T I N E 
E N D 
SUBROUTINE POLRLOG 
LIB ( I N T E R P = IN, R E C T P O L = 
RP) 
COMMON PAR, PAI, MR, MI, OPBM 
CON(PI2 = 6.2831853072, MASK = 2044 4000 0000 0000B) 
LAC (MI) 
AJP3(1) 
FSB (MASK) 
FSB (MASK) 
F M U ( P I 2 ) 
STA (PAI) 
FDV(PI2) 
F A D (MASK) 
SLJ(2) 
FAD (MASK) 
F A D (MI) 
F O R M I N T E G R A L 
P A R T OF N U M B E R I N 
ACCUMULATOR 
G E T T H E T A I N R A N G E 
( - P I , PI) 
BY A D D I N G M U L T I P L E S OF 
2PI 

APPENDIX G. MISCELLANEOUS 
SUBEOUTINES 
439 
P A R 
- 
L O G F ( M R ) 
L D A ( P A R ) 
L D Q ( P A I ) 
S L J 4 ( R P ) 
Z R O ( * ) 
S T A ( P A I ) 
S T Q ( P A R ) 
S L I ( I N ) 
. E X I T F R O M 
S U B R O U T I N E 
E N D 
S U B R O U T I N E 
R E C T L O G 
L I B ( I N T E R P 
= 
I N , F A T A N F 
= 
F A ) 
C O M M O N P A R , P A I , M R , M I , O P B M 
L D A ( M R ) 
F M U ( M R ) 
S T A ( P A R ) 
L D A ( M I ) 
F M U ( M I ) 
F A D ( P A R ) 
S T A ( P A R ) 
P A R 
= 
. 5 * L O G F ( P A R ) 
L D A ( M I ) 
L D Q ( M R ) 
S L J 4 ( F A ) 
Z R O ( * ) 
S T A ( P A I ) 
S L J ( I N ) 
E N D 
S U B R O U T I N E R E C S Q R T 
L I B ( I N T E R P 
= 
I N , S Q R T = 
S Q R T ) 
C O M M O N P A R , P A I , M R , M I , O P B M 
L A C ( M R ) 
Q J P 1 ( 1 ) 
A J P 1 ( 2 ) 
S T A ( P A I ) 
2 
S T Q ( P A R ) 
L D Q ( M I ) 
A J P 3 ( 1 ) 
S T A ( P A R ) 
S L J ( I N ) 
S T A ( P A I ) 
- X 
I N T O A C C , Y I N T O 
Q 
Y 
N O T Z E R J 3 , O R X 
P O S I T I V E 
U S E N O R M A L 
E Q U A T I O N 
A T 
T H I S 
P T . X 
= 
Y 
= 
0 . . ., 
T H E N W 
= 
0 
A T T H I S P T . X I S N E G A N D Y 
I S 
Z E R O 
P A I 
= 
S Q R T F ( P A I ) 
S L J ( I N ) 
Z R O ( * ) 
S U 4 ( S Q R T ) 
Z R O ( * ) 
F A D ( M R ) 
F D V ( 2 . ) 
S T A ( P A I ) 
P A R 
= 
S Q R T F ( P A I ) 
L D A ( M I ) 
F D V ( P A R ) 
F D V ( 2 . ) 
S T A ( P A I ) 
S L J ( I N ) 
· E X I T F R O M 
S U B R O U T I N E 
E N D 

440 
APPENDIX G. MISCELLANEOUS SUBROUTINES 
S U B R O U T I N E POLSQRT 
LIB ( I N T E R P = 
IN) 
COMMON PAR, PAI, MR, MI, OPBM 
PAR = 
S Q R T F ( M R ) 
L D A ( M I ) 
FDV(2.) 
STA(PAI) 
SLJ(IN) 
E N D 

Answers to Selected 
O d d Exercises 
Chapter 1 
1. 
. . · < - 3 6 < - 2 6 < - 6 < 0. If a < 0, then a = -qb, f = 0 or 
(-q)b 
< a < -(q 
- 1)6, 0 < a + qb = f < 6; a = (-q)b 
+ f. 
3. 
Ν = g0ro + d0, 
0 < do < r0 
qo = q^ + di, 
0 < di < η 
tfn-l 
= 
£Λ 
+ 
dn, 
0 
< 
dn 
< 
ΓΗ, 
tfn 
= 
0 
ΛΓ = do + r 0(di + ngj) = do + r 0di + r 0r i ( d 2 + 
r 2? 2) , 
etc. 
5. 
(a) 
0, 1, 2, 3, 4, 10, 11, 12, 13, 14, 100, 101, 102, 103, 104, 110 
(b) 
do + di · 5 + d 25 · 2 + d 3 · 5 · 2 - 5 + - - · 
= d 0 + di5 + (d 2 + d 35) · 10 + · · ·. 
7. 
For base r, if d 0 = 0, then Ν = dnr» + · · · + dir is divisible by r. 
9. 
173; 1276; 342; 387 
13. UN 
= d nd n_i- · 'cMido, 
M = c nc n_i- · -c^iCo, 
Ν + M = (c 0 + do) 
+ 
(d + di)2 + (C2 + d 2)2 - 5 + . . . 
If c 2Ä + du > 5, carry one to next place. 
If Ctk+i + d ^ + i > 2, carry one to next place. 
15. (a) 
10111 
(b) 
11011 
+ 1100 
- 1 1 0 1 
100011 
1110 
441 

442 
ANSWERS TO SELECTED ODD EXERCISES 
11010010 
1000 
101 
111 
101 
10 
21 
17. Base 3: (a) 
212 
(b) 
1000 
(c) 
210 
(d) 
12JÏÏÔÏ 
+110 
- 1 1 1 
X101 
101 
1022 
112 
21210 
21 
12 
2 
21 
19. (a) 
533 
(b) 
330 
(c) 
733 
(d) 
5)127 
+450 
X 57 
- 356 
12 
1203 
23650 
355 
7 
5 
2 
21. Since Ä* < b, there must be a point at which for some Rn' 
-ßn+y — -ßn« 
23. (a) 
11101/11 
or 
29/3 
(b) 
1311/77 
or 
713/63 
(c) 
100101/110 
or 
37/6 
(d) 
12000/222 
or 
135/26 
25. (a) 
Integral s* for which ( r*)-<·*-» < r-<»-». 
(b) 
s* > [(s - 
1 ) / log» 2 ] + 1 
27. (a) 
1000.010101 . . . 
(b) 
10.2525... 
(c) 
11.0010010000111 . . . 
29. (a) 
27.625 
(b) 
1497.328125 
31. 1/3 = .010101010101 . . 
.33 = .010101000 . . ., 
.3 = .010011001 . . 
.333 = .010101010100 . . 
33. (a) 10 
011 001 100 101 
(b) 1 
010 011 111 110 101 100 
111 
(c) 
10101 
(d) 
101)100101 
X1010 
101 

ANSWERS TO SEL'ECTED ODD EXERCISES 
443 
35. (a) 
13.357 
(b) 
131.274 
37. (iVi + M1) - (N2 + M,) = (ΛΓι - Nt) + (My - 
Mt) 
= fciw + k2m = (ki + 
kï)m 
39. (a) 
4 1 . (a) 
00001000 
+11111011 
Q]ooooooii 
008 
(b) 
005 
(c) 
995 
(d) 
995 
+ 9 9 5 
+ 9 9 2 
X008 
X992 
(TJ003 
997 
|T]960 
1 990 
89 55 
895 5 
[2]040 
(b) 
11111000 
(c) 
+00000101 
11111101 
11111011 
X00001000 
111 11011000 
43. (a) 
010 
(b) 
767 
(c) 
772 
+772 
+ 0 0 5 
X010 
T ] 0 0 2 
774 
7 720 
1 
1-» 7 
003 
727 
(d) 
767 
772 
7611066 
U 761 
00047 
001 
050 
45. αφ = a2?)(mod m) does not imply αϊ = a 2(mod m). 6 = 4(mod 2 ) ; 
3 ^ 2(mod 2). 
Chapter 2 
1. 
Always addressable. 
5. 
15 bits; 8 octal digits. 
9. 
One sign bit required. 
13. One. Two, if storage is involved. It is a subset. 
15. Fewer needed. 
17. 24 bits. 6 bit operation code, 3 bit designator, 15 bit address 
3. Address. Function. 
7. Integer ; fraction ; floating-point operand. 
11. I η I < 2
9 δ; 2~
9 δ < | η I < 1 or zero. 

444 
ANSWERS TO SELECTED ODD EXERCISES 
19. Each instruction contains one address. Two operation codes provide a 
greater versatility of combinations. 
21. The address in the program address register. 
23. An instruction is distinguished by the fact that it appears in the 
program control register. 
25. Paper, calculator, user. Sequence of computations. 
Chapter 3 
75 
0 
02000 
22 
0 
02000 
9. 
Overflow occurs. 
11. η = 3: 
01000 
12 
0 
00100 
14 
0 
00200 
01001 
20 
0 
00300 
12 
0 
00101 
01002 
14 
0 
00201 
20 
0 
00301 
01003 
12 
0 
00102 
14 
0 
00202 
01004 
20 
0 
00302 
76 
0 
00000 
η = 2: 
01000 
12 
0 
03333 
20 
0 
00100 
01001 
14 
0 
03333 
20 
0 
00101 
01002 
76 
0 
00000 
00 
0 
00000 
η = 2: 
01000 
12 
0 
03333 
20 
0 
00100 
01001 
14 
0 
03333 
14 
0 
03333 
01002 
20 
0 
00101 
76 
0 
00000 
1. 
(A)F 
= 2345 6707 6543 2345 
(00100)*· = 1111 1111 1111 1111 
(00200) F = 1020 3040 5060 7060 
From 01001. 
3. 
(A), 
= 0000 0000 0000 0000 
(00100) F = 0000 0000 0000 0000 
(00200)ρ = 1020 3040 5060 7060 
From 02000. 
5. 
-(00100) = (00100)'goes to 00100. 
7. 
(a) 
12 
0 
00100 
14 
0 
00200 
(b) 
12 
0 
00100 
14 
0 
00200 
(c) 
12 
0 
00100 
14 
0 
00200 

ANSWERS TO SELECTED ODD EXERCISES 
445 
17. (a) 
00100 
00101 
(b) 
01000 
01001 
01002 
12 
0 
00103 
20 
0 
00103 
12 
0 
00100 
22 
0 
01002 
20 
0 
00102 
and 
(c) 
21, 
Oil 
α,-6 
Otj-3 
ay-2 
α/_ι 
12 
0 
01003 
22 
0 
01002 
20 
0 
01005 
01011 
01012 
01013 
01014 
19. η = 3: 
14 
0 
00102 
76 
0 
00101 
15 
0 
00101 
76 
0 
01001 
76 
0 
01002 
15 
0 
01004 
76 
0 
01001 
76 
0 
01002 
12 
0 
01015 
20 
0 
01013 
14 
0 
01017 
76 
0 
01014 
12 
0 
((ai) 
14 
0 
/(a») 
12 
0 
a, 
20 
0 
ay 
15 
0 
^(L-adv.) 
12 
0 
a / f 2 
20 
0 
a J +î 
14 
0 
f(a2) 
76 
0 
00000 
14 
0 
01013 
12 
0 
01016 
20 
0 
01017 
14 
0 
<(U-adv.) 
12 
0 
a i +i 
20 
0 
aj+i 
14 
0 
t(U 
- 
L-adv.) 
50 
0 
00000 
37. Operand 
in 
51 
2 
77776. 
50 
1 
00144; 
50 
2 
00002 ; 
51 
1 
00001; 
Chapter 4 
5. 
A 
(a) 
0024 7135 7530 6424 
(b) 
0000 0000 0000 0000 
(c) 
0000 0000 0000 0000 
(d) & (e) 0000 0000 0000 0000 
Q 
7135 7530 6424 7135 
1234 5676 5432 1234 
0000 0051 6273 7261 
0000 0000 0000 0000 
(a) 
1627 3726 1505 1627 
(b) 
5676 5432 1234 5676 
(c) 
0642 4713 5742 4713 
(d) 
1234 5676 5432 1234 
(e) 
2471 3575 3064 2471 
3726 1505 1627 3705 
1234 5676 5432 1234 
5753 0642 4713 5753 
5676 5432 1234 5676 
3575 3064 2471 3574 

446 
ANSWERS TO SELECTED ODD EXERCISES 
Q 
A 
(a) & (b) 
7777 7777 7777 7777 
| 
7777 5777 7777 7777 
11. 
(a) 
0020 0000 0000 0000 
1 0000 0000 0000 0000 
(b) 
Overflow. 
13. 
Λ 
Q 
(a) 
0020 0000 0000 0000 
1 7777 7777 7777 7777 
(b) 
Overflow. 
15. (a) 
s < 45; 
3200 0000 0000 0000 
(b) 
s < 38; 
2426 0000 0000 0000 
(c) 
s < 59; 
2030 4467 2274 3250 
(rounded) 
(d) 
s < 45; 
4577 7777 7777 7777 
(e) 
s < 38; 
5351 7777 7777 7777 
(f) 
s < 59; 
5747 3310 5503 4527 
(rounded) 
17. (a) 
164.375; 
(b) 
82.1875; 
(c) 
- 1 5 5 ; 
( 
19. (1234.56) (10
s) = 0123456 
(65.4321) (10·) = 0654321 
(d) 
- 7 7 . 5 
Scale 0654321 down to 10
2 by a right shift of 2. 
21. I M I , I Ν I < 2<; 
\M 
+ N\ 
< 2
5; 
(M + N)2*, 
(M)2**, and 
(N)2
a 
before adding. 
23. I NM j < 2°; 
(NM)2«; 
form (NM)2", 
(QA) left one, store ( Q ) . 
25. 
Σ
 
x<y* 
i - l 
(
1000 
\ 
Σ 
X . 2 / . J 2
3 3
. 
27. N2«; 
M2«; 
L2«. 
| MN/L 
\ < 2». Form (MN)2* 
in QA, 
right 
one for (MN)2
at; 
divide for 
(MN/L)2
a. 
29. (Not optimal.) Numerator: (3.2)2«; 
x2**; 
(x
s)2
4 5, 
(3.2a* + 5.4)2«; 
(5.4)2«. 
Denominator: 
(0.5)2«; 
x2«; 
(a?)2«; 
(3.7)2«; 
(O.öa? + 3.7x + 1.9)2«; 
(1.9)2«; 
f(x)2
a. 
31. (Not optimal.) 
(3.2)2«; 
x2
3 8; 
(χ*)^
3 3; 
(3.2*? + 5.4)2»
s; 
(5.4)2
3 2; 
(0.5)2«; 
x2'»; 
(x*)2»; 
(0.5x* + 3.7a; + 
1.9)2
3«; 
(1.9)2
3«; 
/(x)2«. 
33. (Not optimal.) Form yn+i 
= ( 1 + Zh)yn 
+ 2hxn*. (1 + 3Λ)2"; 
(2A)2
M; 
x„2«; 
yn2«; 
(1 + 3Ä)j/„2«; 
(2Λχ»
2)2«. 
35. (a) 
164.375 
(b) 
32.1875 
(c) 
- 1 5 5 
(d) 
- 7 7 . 5 

ANSWERS TO SELECTED ODD EXERCISES 
447 
37. (23) 
(24) 
NM2°; 
NM2r*2* 
= 2°, store 
(A). 
(MN 
+ L)2-» 
/1000 
(25) 
39. (28) 
(3.2)2~
2; 
x2-*; 
(x
2)2r
i; 
(3.2a;
2 + 5.4)2-*; 
(5.4)2-* 
(29) 
Numerator 
as in 
(28). 
(0.5)2°; 
* 2 -
2; 
(x
2)2~
2; 
(3.7) 2~
2; 
(0.5x
s + 3.7x + 1.9)2-
3; 
(1.9)2-
3; 
f(x)2~
4. 
(30) 
(3.2) 2~
2; 
x2-»; 
(a;
2)2-
1 4; 
(3.2a;
2 + 5.4) 2~
1 6; 
(5.4) 2-» 
(31) 
Numerator as in (30). 
(0.5)2°; 
x2-»; 
(a»)2""; 
(0.5a;
2 + 3.7a; + 1.9)2-»; 
(1.9)2-"; 
f(x)2~*. 
(32) 
(a) 
X2-
1; 
x ^ ; 
(x/xn)2-^; 
l/2[xn 
+ 
x / x ^ 
(b) 
x2-->; xn2-->; 
(*/*.) 2 ^ ; 
l/2[a;„ + 
x / x ^ 
(33) 
( 1 + 3 / 1 ) 2 - » ; 
(2A)2>
2; 
* η2 -
2; 
ι / n2 -
3; 
(1 + 3A)2/„2-
3; 
(2hxn*)2~* 
4 1 . 
Coefficient 
Exponent 
(a) 
0.314160000 
(1) 
43. (a) 
2006 4040 0000 0000 
(b) 
0.123456789 
(7) 
(b) 
2013 4316 0000 0000 
(c) 
0.123000000 
( - 1 ) 
(c) 
6004 1463 1463 1463 
(d) 
0.123000000 
( - 5 ) 
(d) 
6012 2702 4365 6050 
45. (a) 
2005 5100 0000 0000 
(b) 
2004 5100 0000 0000 
(c) 
6002 2677 7777 7777 
(d) 
6003 2677 7777 7777 
47. (a) 
2«; 
2260 0000 0000 0000 
(b) 
2"; 
2260 0000 0000 0000 
(c) 
2«; 
5113 7777 7777 7777 
(d) 
2
M; 
5117 7777 7777 7777 
Chapter 5 
1. 
761/3; 
762γ ; 
7635; 
760a. 
3. 
Not unless all stops are taken. 
5. 
(a) 
01001 
(b) 
02000 
(c) 
01001 
(d) 
02000 
7. 
Set counter to one less. 
11. Counter 143 8 for 22 
2 
aQ or 144 8 for 22 
0 
a 0. 

448 
ANSWERS TO SELECTED ODD EXERCISES 
15. For example, if | Μ Ν | < 2
4 7: 
ao 
16 
0 
/ ( M ) 
23 
3 
a 3 
OIL 
12 
0 
T(N) 
22 
3 
AT 
a 2 
24 
0 
T(M) 
75 
0 
a w 
ctz 
17 
0 
L(M) 
21 
0 
/(Temp.) 
A * 
12 
0 
T{N) 
22 
3 
ai2 
OC6 
24 
0 
/(Temp.) 
20 
0 
/(Temp.) 
AT 
13 
0 
/(Temp.) 
75 
0 
ai3 
AT 
13 
0 
T{N) 
24 
0 
/ ( M ) 
«10 
20 
0 
/(Temp.) 
13 
0 
/(Temp.) 
a n 
75 
0 
a w 
00 
0 
00000 
ai2 
13 
0 
T(N) 
24 
0 
/(Temp.) 
a w 
20 
0 
T(MN) 
76 
0 
00000 
19. 0 ® 0 = 0 = 0 ® 0 
(a®b)®0 
= 0 = 
a®(b®0)=a®0 
0 ® 1 = 0 
= 1 ® 0 
(a ® b) ® 1 = a ® b = α ® (b ® 1) 
1 ® 1 = 1 = 1 ® 1 
21. 0 ® (b ® c) = 0 = (0 ® b) + (0 ® c) 
1 ® (b ® c) = b ® c = (1 ® b) + (1 ® c) 
23. (a) 
0000 0000 0001 1111 
(b) 
1111 1111 1110 0000 
(c) 
1010 1010 1010 1010 
25. (a) 
1121 0111 4412 2222; 
(b) 
1021 7201 4512 2123 
(c) 
1220 1021 4312 2321; 
(d) 
(A)r 
= (A)F; 
(Q), = 
(Q)F; 
(01000) = 1100 2030 0056 6600. 
Chapter 6 
1. 
(a) 
If (A) 
- 0; ( P ) + 1 
U(00100) jump to L(00100) 
(b) 
(P) + 1 - * C/(00100) jump to L(00100) 
(c) 
(P) + 1 -»· t/(00100) jump to L(00100) 
(d) 
(P) + 1 
U(00100) ; stop; if restart jump to L(00100) 
For example, with /(Temp.) = διο: 
So 
75 
0 
00000 
12 
0 
ßo 
ΔΙ 
32 
0 
/Si 
20 
0 
διο 
Δ2 
12 
0 
αο 
32 
0 
«1 
Δ3 
31 
0 
δω 
20 
0 
7ο 
«4 
12 
0 
ft 
32 
0 
«ι 
«5 
20 
0 
δ χο 
12 
0 
Οίο 
δβ 
32 
0 
ft 
30 
0 
διο 
ÔT 
20 
0 
γι 
75 
0 
δο 
διο 
Temporary storage 

ANSWERS TO SELECTED ODD EXERCISES 
449 
9. τ = 9; 
W = 8 
11. 56000 
75 
0 
00000 
12 
0 
70002 
56001 
32 
0 
70003 
20 
0 
56010 
56002 
12 
0 
70000 
32 
0 
70001 
56003 
31 
0 
56010 
20 
0 
70004 
56004 
12 
0 
70002 
32 
0 
70001 
56005 
20 
0 
56010 
12 
0 
70000 
56006 
32 
0 
70003 
30 
0 
56010 
56007 
20 
0 
70005 
75 
0 
56000 
56010 
00 
0 
00000 
00 
0 
00000 
Chapter 7 
15. (a) 
Yes 
(b) 
No 
(c) 
Yes 
(d) 
No 
17. (a) 
2006 4040 0000 0000 
(b) 
5766 3461 7777 7777 
(c) 
1773 6333 3333 3333 
(d) 
6012 2702 4365 6050 
19. (a) 
2011 5050 0000 0000; 
(b), 
(c) 
as in No. 17; 
(d) 
6021 1344 4350 5161 
21. (a) 
15X 
(b) 
Should be no point. 
(c) 
More places after decimal than field width (all right in some 
cases). 
(d) 
Should be no point. 
27. (a) 
Yes; (b) 
no; (c) 
yes; (d) 
yes; (e) 
no; (f) 
yes; (g) 
no 
29. Floating point numbers; S T A T ( 3 ) ; STAT(20); STAT(81). 
31. 10 X 10 X 15 floating point array; 30 element fixed point array; 
20 X 20 floating point array. 
33. 10 element vector; 20 X 20 matrix, 4 X 5 X 6 three-dimensional array. 
35. (a) 
Blank card, one card with 10 eight-digit integers each; 1250 
cards with 8 ten-digit numbers with 5 digits after the decimal 
on each card. 
Chapter 8 
3. 
(a) 
Yes; (b) 
no; (c) 
xes; (d) 
yes; (e) 
no; (f) 
yes. 

450 
ANSWERS TO SELECTED ODD 
EXERCISES 
5. 
Let U N = 10000, L25 = 30000, ALPHA = 40000 and BETA = 40001. 
10000 
50 
1 00031 
10 
0 
00001 
10001 
20 
1 
30000 
14 
0 
20000 
10002 
55 
1 
10001 
75 
0 
10003 
10003 
12 
0 
20001 
32 
1 
20002 
10004 
20 
0 
40000 
30 
0 
40001 
10005 
76 
0 
10000 
00 
0 
00000 
20000 
0000 0000 0000 0001 
20001 
2002 5000 0000 0000 
20002 
2003 5146 3146 3146 
13. C O N ( A l l = 2.5, A12 = 1.3, A21 = - 2 . 7 , A22 = 5.4) 
C O N ( A l l = 2.5, A21 = - 2 . 7 , A12 = 1.3, A22 = 5.4) 
Chapter 9 
1. 
(a) 
Z*K*K 
+ 2*K + 5 
or 
Z*K**2 
+ 2*K + 5 
(b) 
(2*M**3 - Z*M*M 
+ 4*M - 6 ) / ( 2 * M - 
3*iV) 
(c) 
M**(2*N 
- 3)*(4*K*K 
+ Z*N)**(5*K 
- 
1 ) / ( 3 * J - 
2*iV) 
(d) 
M**(2*N)*(-Z)*(i*K*K 
+ Z*N)**(5*K 
- 1 ) / ( 3 * J ) - 
2*N 
, „ n(n + I) 
. , / 
3. 
(a) 
2
 
(b) 
n* + 
-
3s»(4y + z) 
... 
. . . . 
, 
(c) 
(d) 
3a;
2 4y + 
w — υ 
(e) 
3 * » . 4 i , + - £ - 
(f) 
w — υ 
oca 
5. 
(a) 
* missing in numerator: 3*X; 
( ) missing in denominator: 
(2.*X + Z) 
(b) 
Should be no ( ) in denominator. 
7. 
(a) 
H = SQRTF(A**2 + B**2), 
or 
H = SQRTF(A*A + B*B) 
(b) 
A = SQRTF(B*B + C*C - 
2.*B*C*C0SF(ALPHA)) 
(c) 
SHI = L0GF(X + S Q R T F ( X * X + 1.)) 
(d) 
( E X P F ( X ) - E X P F ( - X ) ) / ( E X P F ( X ) + 
E X P F ( - X ) ) 
9. 
I F 
(A - B) 10, 20, 30 
10 R I = S Q R T F ( B - 
A) 
20 R = 0 
30 R = SQRTF(A - 
B) 

Index 
A 
A jump instruction, 83, 189-191, 193, 194, 
223, 409; defined, 409 
A left shift instruction, 118, 120, 406; 
defined, 406 
A register (as shifting register), 119, 120 
A right shift instruction, 118, 119, 406; 
defined, 406 
AQ left shift instruction, 118, 121 
AQ register, 118, 119, 121, 152 
AQ right shift instruction, 118, 119. See 
also Long Right Shift instruction. 
Absolute address, 88, 93, 305 
Accumulate, 55 
Accumulator, 56, 57, 105 
Activate (in external function), 246 
Add instruction, 83; defined, 399 
Add logical instruction, 201, 203, 403; 
defined, 403 
Addition table, binary, 16; octal, 19 
Additive machine, 56 
Address, 5, 44, 45, 46, 59, 63, 88, 93, 100, 
101, 229, 284-286, 295, 303, 305, 308, 
310, 317, 322, 397; in instruction 
word, 59, 397; relative, 88, 93, 229, 
234, 303, 305, 308, 310, 317; sym-
bolic, 88, 93, 285-287, 295; location 
of, 93, 309, 317 
Address arrays, 286, 287 
Address list, 276-279, 284; 289, 290 
Address Mnemonics, 284-286 
Address modification, 100, 101, 105, 398-
411 
Address property (defined), 44-46 
Address type, 63; in Fortran symbolic, 
427, 428 
Alarm exit, 250 
Algol, 354 
Arithmetic, 3, 6, 15, 16, 18, 27, 49; base r, 
15, 27; binary, 16; octal, 18 
Arithmetic registers, 43, 55, 57; in the 
CDC 1604, 57 
Arithmetic statement (Fortran), 364, 365 
Array, 364, 365 
Assembly, 93, 228-235, 303-352; of a 
code, 93; modifiable, 228-233; sub-
routine, 227-235; complete programs, 
303-352; regional, 304-308 
Assembly mode, 247, 248, 261, 262 
Assembly modifiable, 228-233; square root 
subroutine, 230-235 
Assembly program, 227-235. See also 
CODAP, Fortran Symbolic, SURAP 
Asynchronous control, 73 
Β 
"b" term 311, 423 
Backspace statement, 290, 433 
Base, 11; r-number system, 11 

452 
INDEX 
Base address, 99, 103, 105 
Base point, 24, 50, 117, 127, 159; in 
floating point, 159 
Best estimate of upper bound, 135 
Biased exponent, 164, 165, 168 
Binary addition table, 16 
Binary arithmetic, 16 
Binary code, 76, 239, 251, 252, 262, 264; 
translator for, 251, 252, 262, 264, 270 
Binary multiplication table, 17 
Binary point, 24 
Binary subtraction table, 17 
Binary system, 10, 13 
Binomial coefficients, 387 
Biquinary system, 38 
Bit, 16 
Bit-by-bit product, 198, 402 
Bit-by-bit sum, 198 
Blank in Fortran, 274 
Block of data, 280 
Boolean algebra, 197 
Borrow, 15, 17; end around, 37, 84 
Bound, lower (in division), 139; upper, 
126, 134 
Bounds on an integer in the CDC 1604, 
52-54 
Branch point, 248 
Buffer, 245, 247, 248, 249, 250, 251, 312; 
region, 245; initial address, 247, 250; 
terminal address, 247, 250; operation, 
249 
Buffered, 245 
C 
Call statement (defined), 386, 431 
Card. See Punched card. 
Carry, 15; end around, 35, 84 
Character mode, 247, 248, 251 
Circular shift, 118, 120, 121 
Closed loop, 90, 368 
Cobol, 354 
Coefficient, 51, 159, 160, 167, 197; defined, 
159 
CODAP, 311-317, 423-426 
Coded instruction, 50 
Code (in transcription media), 244; octal 
coded tape, 250. See also name of 
code for tables. 
Code for a vector sum, 86-95 
Code editing, 94, 106, 327 
Code timing, 98 
Coding, 6 
Comment card, 327 
Common scale factor, 161 
Common statement, 334, 335, 356, 357, 
432 
Compile, 353 
Compiler, 354, 355, 367, 375, 376, 388 
Compiling program (see Compiler) 
Complement, 31-37; arithmetic, 31, 32; 
defined, 32; r's, 32, 33; (r-l)'s, 32, 33, 
35; binary, 37 
Complex number arithmetic, 337-350 
Complex product code, 216, 257 
Computed Go To statement, 368, 369, 
370, 394; as index jump, 369, 431 
Computer, 1, 2, 3; analog, 1; digital, 1; 
special purpose, 2; internally pro-
grammed, 3 
CON pseudoinstruction, 324, 326, 328 
Condition, external (for stop), 181 
Condition, internal (for stop), 181 
Conditional jump, 85, 186, 187, 189, 190, 
194; return jump, 224; Fortran, 367, 
368 
Conditional stop, 181, 184, 185 
Congruence (defined), 31, 32 
Connectors, 97 
Console, 77, 238, 246 
Content of a register, 43, 46, 49; defined, 
43; symbol, 49 
Continuation card, 357, 358 
Continue statement, 431 
Control, 3, 5, 43, 58, 144, 145, 242 
Control digit, 242 
Control registers, 43, 58, 144, 145; in 
CDC 1604, 74 
Control section, 50 
Conversion, 13, 20, 26, 29, 30, 148, 169, 
237, 365; one base to another, 13; 
into decimal, 20; mixed numbers, 26; 
binary-to-octal, 
29, 
30; 
octal-to-
binary, 29, 30; card-to-tape, 237; 
tape-to-card, 237; 
fixed-to-floating-
point, 
169, 365; 
floating-point-to-
fixed, 169, 365 
Cosine function, 366 
Cramers rule, 393 
Current instruction, 71-74, 145, 317 

INDEX 
453 
D 
Decimal equivalent of octal number, 128 
Decimal integer in Fortran, 272 
Decimal system, 12, 13 
Decrement, unit, 107; nonunit, 107 
Decision box, 96 
Designator, 61, 63, 83, 99, 311, 319, 423 
Dictionary, 230 
Difference digit, 17 
Differential equation, 143, 335 
Digit, 10, 11, 12 
Digital sequence, 388 
Dimension statement, 288, 291, 294, 335, 
356, 357, 386, 390, 431 
Discriminant, 371 
Divide fault, 185 
Divide fractional instruction, 152, 400; 
defined, 400 
Divide integer instruction, 118, 122-124, 
399; defined, 399 
Dividend, 123, 137, 154, 400 
Division overflow, 182, 185 
Divisor, 123 
Do loops, 373-381, 389, 390, 394; defined, 
373; 
statement 
number 
in, 
373; 
dummy index in, 375, 377; index 
register in, 375; inner, 377, 380; 
outer, 377, 380; nested, 377, 380 
Do statement, 431 
Do-nothing instruction, 100, 103. See also 
Pass 
Driving program, 392 
Dummy array, 384 
Dummy index (in Do loop), 375, 377 
Dummy variable, 385 
Dynamic variable, 369 
Ε 
Ε fields, 321 
Editorial comment, 94-96, 327 
Effective address, 64, 99, 103, 398 
Effective operand, 64 
Effective shift count, 64 
End statement, 328, 358, 382, 383, 431 
End-around borrow, 37, 84 
End-around carry, 35, 84 
Endfile statement, 290, 433 
End-off shift, 118, 134 
End-of-tape symbol, 254, 265 
Enter A instruction, 408; defined, 408 
Enter index instruction, 100, 408; defined, 
408 
Enter Q instruction, 408; defined, 408 
Entry point, 91, 196, 223; proper, 92, 219; 
of subroutine, 223 
Equality jump, 187 
Equality search, 253 
Equality search instruction, 207-209, 404; 
defined, 404 
Exchange register, 45, 57 
Executable statement, 368 
Execution address. See effective address. 
Executive program, 354, 355, 391, 392 
Exit, 73, 90, 95, 397; full, 73, 397; half, 
73, 397 
Exiting, 90 
Explicit computer, 67 
Exponent, 51, 54, 159, 160, 167, 197 
Exponent overflow, 170, 182, 185, 401 
Exponent underflow, 401 
Extend a number, 81 
Extended number, 81, 89, 119, 124, 149, 
155 
Extension of a number, 89,119 
External conditions for jumps, 194; for 
stops, 181 
External function instruction, 244, 246-
268, 411^16; code word in, 246, 249; 
defined, 411-416 
Extract (a digit), 198, 202, 252 
F 
F fields, 321 
Fault, 68, 185, 401 
Fault condition, 182, 185 
Field, 270-275, 280; blank (X), 271, 274, 
276, 285; decimal integer (/), 271, 
274; fixed point decimal number (F), 
271, 274, 277, 278; floating point 
decimal number (E)} 271, 274, 293; 
Hollerith (#), 274, 276, 277, 285, 293; 
symbols for, 274; statements (For-
tran), 275-284 
Finite difference quotient, 143 
Fixed point, 50, 51,117-158, 271; operand, 
51; integer, 51, 271; fraction, 51, 

454 
INDEX 
147-157; complement, 51; scaling for, 
117-158; in control registers, 144 
Fixed point decimal number in Fortran, 
272 
Flexowriter code, 257-259, 264, 420; table 
of, 420 
Floating add instruction, 169, 400; de-
fined, 400 
Floating divide instruction, 169, 401; de-
fined, 401 
Floating multiply instruction, 169, 401; 
defined, 401 
Floating point, 
50, 
51, 
159-172; as 
ordered pair, 51; packed, 51; un-
packed, 
51; arithmetic, 
159-172; 
instructions, 169, 400, 401 
Floating 
point 
decimal 
number 
(in 
CODAP), 320 
Floating point decimal number in Fortran, 
272, 361 
Floating point format in the CDC 1604, 
54, 55, 164 
Floating point number in INTERP sub-
routine, 221 
Floating point range fault, 170, 185. See 
also Exponent overflow. 
Flow chart, 96, 109; symbols for, 96; for 
matrix transpose, 109; for square root 
subroutine, 232 
Format, 254, 258, 306; statement: See 
Format statement. 
Format Statement, 275-284, 288, 294, 
297, 324, 432 
Fortran, 270, 353-387, 389, 392-394, 429-
434; arithmetic, 360-365, 392-394; 
equality, 365; functions, 366, 367, 
429-434; jumps, 367; programs, 356-
387; statements, 431; variable names, 
429 
Fortran arithmetic, 360-365; addition, 
360, 361; exponentiation, 360, 361; 
division, 360, 361; multiplication, 360, 
361; order of operations in, 361, 362; 
parentheses in, 360-363; subtraction, 
360, 361 
Fortran arithmetic expressions, 392-394 
Fortran control statements, 367, 431 
Fortran equality, 365 
Fortran functions, 366-367, 429-434 
Fortran jumps, 367 
Fortran programs, 356-387 
Fortran statements, 389, 431 
Fortran symbolic, 317-350, 358, 382, 388, 
427, 428; table of symbolic addresses 
for, 427, 428 
Four address computer, 61 
Fraction, digital representation of, 23 
Fractional fixed point operation, 147-159 
Fractional part of a number, 24, 28 
Full exit, 73, 397 
Function name, 331 
Function statement, 382, 385, 386, 431 
G 
Go To statement, 368, 431; defined, 361 
H 
H field, 274, 276, 277, 285, 293 
Half exit, 73, 397 
Hardware, 355 
Hollerith sequence, 273; character, 273, 
285, 326; field, 319 
HOL pseudoinstruction, 324, 328 
Housekeeping instructions, 90 
/ 
J field, 271, 274 
If statement, 370, 371, 372, 431; defined, 
370 
Implicit computer, 67 
Increase A instruction, 408 
Increase index instruction, 100, 408, 409; 
defined, 408, 409 
Increments, 101, 107; unit, 101, 107; 
nonunit, 107 
Index, 63, 100, 102, 104, 186, 187, 189, 
192, 368, 402; designator, 63; instruc-
tions, 100, 102, 104, 186-192, 368, 
409; jump, 104, 186-192, 368, 402, 
409 
Index jump instruction, 100, 102, 104, 
186-192, 368, 402; defined, 402 
Index register, 65, 99-106, 144, 145, 285, 
321, 375; arithmetic in, 144, 145; in 
Do loops, 375 

INDEX 
455 
Index skip instruction, 104, 105, 409; de-
fined, 409 
Index test, 104 
Indexing, 98-106, 402; instructions, 103 
Indirect addressing, 66, 376, 398, 409; 
defined, 409 
Infinite loop, 90 
Information unit, 270-275, 281, 284 
Initial address, 412. See also Buffer. 
Inner loop, 107-110, 185 
Input, 3, 43, 76, 78, 79, 237-298, 405; in 
the CDC 1604, 78, 79, 244-269; lan-
guages, 263, 269-302; card, 282; 
statements, 284, 289-293 
Input-Output. See Input or Output. 
Input transfer instruction, 405 
Insert address, 254, 260 
Inside-out order (in subscripted arrays), 
292 
Instruction, coded, 50, 397 
Instruction word, 58, 59, 62, 397; address 
part of, 59; in the CDC 1604, 62, 397 
Integer, 50, -51; complement, 50, 51 
Integral fixed point arithmetic, 117-146 
Integral part of a number, 24, 28 
Intermixed instructions, 388, 389 
Internal conditions (for jumps), 194 
INTERP routine, 337-350, 389, 395 
Interpretive instruction, 337, 338; codes 
for, 338 
Interpretive language, 389 
Interpretive subroutine, 221, 337-350, 
389, 395 
Interrupt, 222 
Irrational number, 40 
Iterative loop, 89, 90, 187. See also Loop. 
Iterative loop of addresses, 90. See also 
Loop. 
J 
Jump, 67, 69, 73, 85, 188-196. See also A 
jump, Conditional jump, 
Equality 
jump, Index jump, Q jump, Selective 
jump, Sign jump, Threshold jump, 
Unconditional jump, Zero jump. 
Jump address, 69, 85, 188, 190 
Jump instructions, 67, 69, 185-196 
Jump location, 188 
Κ 
Keyboard, on-line, 4, 76 
Keypunch, off-line, 4 
L 
L advancer, 90, 92, 98 
Language, 7, 8, 61, 227, 317, 354-356, 
367, 388, 390; machine, 7, 61, 227, 
317, 367; problem-oriented, 8, 354-
356, 367, 388, 390 
Left shift. See Shift. 
Left shift as an arithmetic operation, 122 
Left shift as a right shift, 121 
Left-to-right order, in Format statement, 
283; in Fortran arithmetic, 360-365 
Length of a register, 44 
LIB pseudoinstruction, 334, 340, 341 
Library, 227, 238, 252, 331, 382; assembly 
program, 238; subroutine, 238, 382; 
input-output program, 238, 252 
Linearly ordered array of digits, 43 
Load A instruction, 83, 398; defined, 398 
Load A complement instruction, 398 
Load Index Lower instruction, 100, 402; 
defined, 402 
Load Index Upper instruction, 100, 402; 
defined, 402 
Load logical instruction, 201, 202, 403; 
defined, 403 
Load Q instruction, 398 
Load Q complement instruction, 398 
Load routine, 244 
LOC statement, 324, 326, 328 
Location-of address, 88, 93, 309, 317 
LOCN term, 311 
Logic, 3, 6 
Logical instructions in the CDC 1604, 
201-206, 403; defined, 403 
Logical operations, 180, 201-206, 388, 402. 
See also Logical Product, Logical Sum. 
Logical product, 197, 199, 200, 203, 402; 
octal table for, 200 
Logical sum, 197-199, 200, 204; octal 
table for, 201 
Long left shift instruction, 407 
Long right shift instruction, 406 
Loop, 89, 90, 91, 103, 107-110, 142, 368, 
373-381, 389, 390, 394; exit, 90; 

456 
INDEX 
infinite (or closed), 90, 368; symbols, 
94; inner, 107-110, 185, 377, 380; 
outer, 108-110, 185, 377, 380; Do, 
373-381; nested, 377, 380 
Lower bound (for division), 139 
Lower instruction, 62, 223, 397; defined, 
62; in return jump, 223 
M 
"ra" constants, 424 
"ra" term, 312, 423, 424; symbolic, 424 
Machine codes (absolute), 356 
Machine instructions, 388 
Machine language, 227, 317, 367, 388 
Machine-oriented symbols, 8 
Machine representation, 125, 127, 133; 
of scaled number, 125 
Magnetic cores, 5 
Magnetic tape, 4, 76, 237-239, 249, 280 
Magnetic tape code (table), 421 
Magnitude of complex number, 337, 338 
Main program, 215, 218, 219; step, 218 
Main routine, 215 
Mask, 198, 199, 202, 203, 205, 252 
Masked equality search instruction, 207, 
208, 405; defined, 405 
Masked threshold search instruction, 207, 
208, 405; defined, 405 
Masking operation, 202 
Matrix, 107-110, 219, 224, 226, 364, 381, 
384; transpose, 107-110, 381; as an 
array, 364, 384; product, 381 
Memory, 44 
Microseconds, 398 
Minimum access coding, 46 
Mixed languages, 388-390 
Mnemonic, 284-286, 311, 319, 338, 342; in 
addresses, 284-286; code, 311, 319; 
device, 342 
Modulus, 31, 32 
Monitor program, 355 
Multiplication table, binary, 17; octal, 19 
Multiply fractional instruction, 151, 152, 
400; defined, 400 
Multiply integer instruction, 118,122-124, 
399; defined, 399 
Ν 
Negative zero, 35, 37, 53, 85, 147, 163, 
189, 190; defined, 35; in jumps, 85, 
189, 190; fractional form, 147; float-
ing point form, 163 
Newton's method, 230, 372 
Next instruction, 66, 68, 398; in the CDC 
1604, 68 
Nonperiodic expansion, 40 
Nonunit increments, 107 
Normal jump, 86, 182, 409-411 
Normalization, 171, 172 
Normalized, 54, 55, 160, 162, 163, 165, 
166, 167, 171, 172 
Ô 
Octal, 10, 13, 18, 19, 24, 273; system, 10, 
13; arithmetic, 18; addition table, 19; 
multiplication table, 19; subtraction 
table, 19; point, 24; in Fortran, 273 
Octal point, 24 
Octal system, 10, 13 
Off-line, device, 238, 239, 253; typewriter, 
253 
One-pass assembly program, 307, 308 
On-line, typewriter, 239, 249, 250, 253, 
255, 312, 391, 421; code, 257-259; 
table, 421 
One's complement, 37, 102; defined, 37; 
digital formation of, 37 
Operand, 43, 50, 52, 306, 397; as content 
of register, 50; in the CDC 1604, 52; 
in instruction word, 397 
Operating region, 229, 234 
Operation box, 96 
Operation code, 59, 398-411, 423; in the 
CDC 1604, 398-411; in CODAP, 423 
Optimal scaling, 128, 130, 132, 138, 150 
Ordered array of digits, 237 
Organization, machine, 43-82 
Outer loop, 108-110, 185 
Output, 3, 4, 43, 76-79, 205, 237-298, 405; 
in the CDC 1604, 78, 79, 289-293; 
languages, 263, 269-302; statements, 
280, 289-293 
Output transfer instruction, 405 
Overflow, 50, 85, 131, 133, 170, 182, 185, 
320, 401; defined, 50; fault, 185. See 
also Divide fault, Floating point 
range fault. 
Overshifting, 134 

INDEX 
457 
Ρ 
P-register, 67, 68, 146; arithmetic in, 146 
Packed floating point format, 160, 197 
Pairing rules (in CODAP), 425 
Paper tape, 237-269, 280; frames, 240; 
levels, 240; punch, 240, 247, 248, 265; 
reader, 240, 248, 250; movement, 241; 
control of typewriter, 243; input 
program for, 254-264; output pro-
gram for, 264-269; reloadable, 265 
Parameters, 43 
Parentheses, 281-284, 366; in Format 
statement, 281-284; in Fortran func-
tion, 366 
Pass instruction, 101, 103. See also Do-
nothing instruction. 
Periodic expansion, 40 
Peripheral, 77 
Polar form of complex number, 337, 338 
Positional system, 10 
Positive zero, 35, 37, 53, 147, 163, 189, 
190; defined, 35; fractional form, 147; 
floatingpoint, 
163; in jumps, 189, 190 
Prestoration, 91, 92, 95, 99, 100, 101, 220 
Print statement, 290-296, 353-357 
Printer code (table), 422 
Problem-oriented language, 354, 355, 356, 
367, 388, 390 
Production run, 264 
Program address register, 67, 68. See also 
P-register. 
Program control register, 69 
Program name, 358 
Program name statement, 328 
Program parameters, 306 
Program step, 62, 74, 397; defined, 397 
Programming, 7 
Proper entry point, 92, 219 
Prototype instructions, 87, 107 
Pseudoinstruction, 305, 308, 311, 312, 
314, 324-327, 329, 332, 333, 340, 426; 
table for CODAP, 426 
Punch statement, 432 
Punched cards, 4, 76, 237-239, 244, 422; 
code (table), 422 
Punched paper tape. See Paper tape. 
Q 
Q jump instruction, 189-191, 194, 223, 
410; defined, 410 
Q left shift instruction, 118, 407; defined, 
407 
Q-register, 57, 58 
Q right shift instruction, 118, 406; defined, 
406 
QA register, 137, 400 
Quotient, 154, 400 
R 
r's complements, 34 
(r-l)'s complements, 35, 36 
ß-register, 65, 99, 146; arithmetic in, 146 
Radix, 11 
Radix point, 24 
Random access system, 46 
Rational fraction, tabulation of, 140-144, 
155-157 
Rational number, 40 
Read, 45 
Read input tape statement, 289, 432 
Read statement, 289, 290, 292, 293, 294, 
295, 296, 324, 353, 354, 432, 433 
Read tape statement, 432 
Reader, 4, 76; off-line, 76. See also Paper 
tape. 
Reading property (defined), 44-46 
Rectangular form of complex number, 337, 
338 
Register, 5, 43; defined, 43. See also name 
of register. 
Relative address, 88, 93, 229, 234, 303, 
305; origin, 88, 303, 305, 308, 310, 317 
Relative error, 25, 26 
Remainder, 123, 154, 400 
Remarks, 424 
Replace Add instruction, 401 
Replace Add One instruction, 401 
Replace Subtract instruction, 401 
Replace Subtract One instruction, 401 
Resolution of register content, 180, 196-
206 
Restoration, 91, 92, 99, 100 
Return address, 219 
Return jump, 183, 186, 217-227, 334; in 
stop instructions, 183; in the CDC 
1604, 
222-227; implicit, 
220-224; 
explicit, 222 
Return statement, 383, 431 
Rewind statement, 290, 433 
Right shift, 118-122; end-off, 118, 119; 
circular, 121; arithmetic effect of, 122 

458 
INDEX 
Round-off, 25, 126, 127, 147; of a number, 
25; error, 25, 126 
Running time, 103 
S 
5
1 register, 47-49 
5
2 register, 47-49 
Scale A instruction, 407 
Scale AQ instruction, 407 
Scale factor, 124, 125, 127, 159 
Scale factor exponent, 125, 159; in floating 
point, 159 
Scaled decimal number, octal form, 128 
Scaling, 117-158; fixed point integral, 
124-144; addition, 130, 132, 151; 
subtraction, 130, 132, 151; multipli-
cation, 133, 151; division, 135-139, 
153; for absolute value machines, 157 
Search instructions, 206, 207, 208; in the 
CDC 1604, 207, 208 
Segments, program, 336 
Select (in External function instruction), 
246, 248, 250, 413-415 
Selective clear instruction, 204, 402; de-
fined, 402 
Selective complement instruction, 204, 
403; defined, 403 
Selective jump, 83, 186, 191, 194, 223 
Selective jump instruction, 83, 410; de-
fined, 410 
Selective set instruction, 204, 402; defined, 
402 
Selective substitute instruction, 204, 403; 
defined, 403 
Selective stop, 83, 181, 183, 223 
Selective stop instruction,. 83, 411; de-
fined, 411 
Sense (in the External function instruc-
tion), 246, 413-416 
Seven's complement, 53 
Shift, 16, 55, 118, 185, 397; fault, 185; 
count, 397. See also shift instructions 
by name. 
Shifting, 16, 118 
Sign digit, 118, 150, 160, 161; in sign 
extending shift, 118 
Sign jump, 187 
Significant digits, 117, 127, 128, 152, 160, 
161 
Sine function, 366 
Single address computer, 59, 60, 62 
Skip, condition, 70; instruction, 70, 71, 
209, 210; feature, 102; operations, 102 
Skipped. See Skip. 
Slash, in Format statement, 280-283 
Software, 355 
Square root subroutine, 230-234, 332 
Statement number, 327, 357 
Stop instructions, 181-185 
Stop statement, 431 
Storage, of information, 3; by columns, 
108, 227; by rows, 108 
Storage address register, 45 
Storage region, 304 
Storage registers, 43 
Storage registers in the CDC 1604, 46 
Storage Shift instruction, 404 
Storage Skip instruction, 403 
Storage unit, 5 
Store A instruction, 83, 398 
Store index lower instruction, 402 
Store index upper instruction, 402 
Store logical instruction, 201, 202, 403; 
defined, 403 
Store Q instruction, 398 
Subprograms, in Fortran, 381-388. See 
also Subroutine. 
Subroutine, 215-235, 331-336, 381-388; 
in Fortran symbolic, 331-336; in 
Fortran, 381-388 
Subroutine assembly, 227-235 
Subroutine linkage, 217-227 
Subroutine name, 382, 385 
Subroutine name statement, 386 
Subroutine statement, 431 
Subroutine symbol in flow chart, 97 
Subscript in arrays, 286 
Subscripted array names, 322 
Substitute address instructions, 106, 399 
Substitute address lower instruction, 399 
Substitute address upper instruction, 399 
Subtract instruction, 83, 399; defined, 399 
Subtract logical instruction, 201, 203, 403; 
defined, 403 
Subtraction table, binary, 17; octal, 19 
Subtractive machine, 56, 74; CDC 1604, 
74 

INDEX 
459 
Sum digit, 15 
SURAP, 227-230, 235, 236, 303-305, 331, 
332 
Symbolic address, 88, 89, 93, 285, 286, 
287, 295, 317-322, 335, 341, 357, 360, 
361, 388; as a variable, 357, 360, 361 
Symbolic instructions, 320, 321 
Symbolic machine program, 388 
Synchronous control, 72 
Τ 
Table of powers of two, 419 
Tag, 197, 305, 307, 309, 310, 318, 320, 321 
Tagging, 310, 320, 321 
Temporary data, 306 
Terminal address, 412. See also Buffer. 
Three address computer, 60 
Threshold jump, 187 
Threshold search instruction, 207, 208, 
209, 404; defined, 404 
Timing signals, 72 
Transcription, 238, 239, 244; media, 76, 
238 
Transfer, 245, 262; instructions, 245 
Translator, 71, 72, 270; many-to-one, 71 
Transmission, X to A, 57 
Transpose of a matrix, 107, 108 
True exponent, 160, 164; defined, 160 
True zero. See Positive zero. 
Truncate, 43 
Truncation, of a number, 24, 25, 152; 
error, 25 
Two, table of powers of, 419 
Two address computer, 59, 60 
Two way jump, 209 
Typewriter, on-line, 4, 239, 249, 250, 253, 
255, 312, 391, 421; off-line, 253 
U 
U
1 accumulator, 64, 146; arithmetic in, 
146 
U advancer, 90, 92, 98 
^-register, 69, 99 
U-L advancer, 90, 92, 98 
Unconditional jump, 83, 85, 186, 188, 191, 
224, 367, 368; return, 224 
Unconditional return jump, 224 
Unconditional stop, 83, 181, 183 
Underflow, exponent, 401. See also Float-
ing point range fault. 
Undershifting, 134, 152 
Univac 1103, 56 
Unload routine, 244, 264-267 
Unpacked floating point format, 161 
Unpacking, of a floating point word, 166 
Upper bound, 134 
Upper instruction, 62, 223, 397; defined, 
62; in normal jump, 223; in return 
jump, 223 
V 
Variable in Fortran, 357 
Variable access system, 46 
Vector addition, 98, 104, 375, 376, 378, 
379; flow chart for, 98; code for, 104; 
program for, 104, 375, 376, 378, 379 
Vector magnitude, 367, 385 
Vector product, 385 
Vector sum, code for, 86-95 
W 
Word, defined, 43 
Write, 45 
Write output statement, 289 
Write output tape statement, 432 
Write statement, 289, 290, 433 
Write tape statement, 432 
Writing property (defined), 44-46 
X 
X field, 271, 274, 276 
X-register, 47-49, 57, 58. See also Ex-
change register. 
Ζ 
Ζ register, 47-49 
Zero, as floating point operand, 163, 164, 
166. See also Negative zero and 
Positive zero. 
Zero jump, 83, 187 

