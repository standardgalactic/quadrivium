

Early praise for Seven Mobile Apps in Seven Weeks
Tony does an excellent job at explaining the Xamarin concepts to first-time users!
His fun tutorials keep the reader engaged while teaching them step-by-step to
create their first mobile app in C#.
➤Brandon Minnick
Customer-success engineer, Xamarin
The mobile software development landscape has never been wider than it is today.
Tony Hillerson’s Seven Mobile Apps in Seven Weeks is a wonderful approach to
showcasing the many options available for mobile application development. You’ll
find this book is a valuable learning asset regardless of whether you’re starting
fresh in the industry or looking to pick up experience on another mobile platform.
This book is the "Three Wolf Moon" of the mobile software development world.
➤Joshua Jamison
Software engineer, Ride
This book will teach you so much about mobile native and hybrid development
by taking you on an in-depth journey exploring many approaches to create incred-
ible apps across all the major platforms. An incredible and versatile source of
knowledge that I recommend to any developer of any level.
➤Daniel Wanja
VP of engineering, Blinker

I found this book much more engaging than I had anticipated. I am impressed by
the author’s ability to cover the material with a delicate balance between glossing
over important details and providing too much detail— overwhelming the reader.
I highly recommend this title to anyone interested in a practical head-to-head
comparison of modern mobile application-development approaches.
➤Daniel Lamb
Senior software engineer; Technical architect and author, CoStar Group

Seven Mobile Apps in Seven Weeks
Native Apps, Multiple Platforms
Tony Hillerson
The Pragmatic Bookshelf
Raleigh, North Carolina

Many of the designations used by manufacturers and sellers to distinguish their products
are claimed as trademarks. Where those designations appear in this book, and The Pragmatic
Programmers, LLC was aware of a trademark claim, the designations have been printed in
initial capital letters or in all capitals. The Pragmatic Starter Kit, The Pragmatic Programmer,
Pragmatic Programming, Pragmatic Bookshelf, PragProg and the linking g device are trade-
marks of The Pragmatic Programmers, LLC.
Every precaution was taken in the preparation of this book. However, the publisher assumes
no responsibility for errors or omissions, or for damages that may result from the use of
information (including program listings) contained herein.
Our Pragmatic books, screencasts, and audio books can help you and your team create
better software and have more fun. Visit us at https://pragprog.com.
The team that produced this book includes:
Jacquelyn Carter (editor)
Potomac Indexing, LLC (index)
Candace Cunningham, Molly McBeath (copyedit)
Gilson Graphics (layout)
Janet Furlow (producer)
For sales, volume licensing, and support, please contact support@pragprog.com.
For international rights, please contact rights@pragprog.com.
Copyright © 2016 The Pragmatic Programmers, LLC.
All rights reserved.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted,
in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise,
without the prior consent of the publisher.
Printed in the United States of America.
ISBN-13: 978-1-68050-148-3
Encoded using the finest acid-free high-entropy binary digits.
Book version: P1.0—July 2016

Contents
Acknowledgments
.
.
.
.
.
.
.
.
.
.
.
vii
The Story So Far...
.
.
.
.
.
.
.
.
.
.
.
ix
1.
Day 0: Setting Up the API .
.
.
.
.
.
.
.
.
.
1
Setting Up and Running the API
1
Reviewing and Testing the Endpoints
3
Now We’re Ready
6
Part I — Official Native Platforms
2.
Mobile Web
.
.
.
.
.
.
.
.
.
.
.
.
.
9
A World-Clock App
10
Day 1: A Time for Beginnings
11
Day 2: Making Time
21
Day 3: Time to Move
32
Wrapping Up the Web App
48
3.
iOS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
A Weather-Forecast App
52
Day 1: What’s It Like Out?
52
Day 2: What’s It Like There?
66
Day 3: Expanding Our Horizons
80
Wrapping Up iOS
99
4.
Android
.
.
.
.
.
.
.
.
.
.
.
.
.
101
A Currency-Conversion App
102
Day 1: How Far Does a Dollar Go?
103
Day 2: What Can I Get for a Buck?
117
Day 3: Time Is Money
127
Wrapping Up Android
139

5.
Universal Windows Platform
.
.
.
.
.
.
.
.
141
A Stock-Quote App
142
Day 1: The Initial Investment
143
Day 2: Trending Up
151
Day 3: A Wider Market
163
Wrapping Up Windows Phone
178
Part II — Cross-Platform Tools
6.
RubyMotion
.
.
.
.
.
.
.
.
.
.
.
.
183
A To-Do App
184
Day 1: ✓ Android
185
Day 2: ✓ iOS
206
Day 3: ✓ Cross-Platform
218
Wrapping Up RubyMotion
227
7.
Xamarin
.
.
.
.
.
.
.
.
.
.
.
.
.
229
A Calculator App
230
Day 1: Adding Up the Platforms
230
Day 2: Dividing Up the Solution
250
Day 3: Subtracting Platform-Specific Code
266
Wrapping Up Xamarin
279
8.
React Native
.
.
.
.
.
.
.
.
.
.
.
.
281
A Note-Taking App
282
Day 1: Comparing Notes
283
Day 2: Exchanging Notes
299
Day 3: Taking Note of Where We Are
311
Wrapping Up React Native
324
9.
Wrapping Up
.
.
.
.
.
.
.
.
.
.
.
.
327
Official Native Platforms
327
Cross-Platform Tools
329
What’s Next?
332
Index
.
.
.
.
.
.
.
.
.
.
.
.
.
.
333
Contents • vi

Acknowledgments
When people ask where I got the concept for this book, I joke that it sprang
fully formed into my head because I needed to answer questions about or
build apps for multiple mobile platforms so many times. It certainly feels that
way, but what most likely happened was that I had hundreds of conversations
with coworkers, friends, clients, and industry experts about building apps
for multiple platforms. Add to those conversations the great esteem I have
for the Seven in Seven series, and you can see how I came to the conclusion
to write this book.
So, then, thank you to all of my coworkers and friends with whom I’ve had
these conversations and built those apps over the years. We commiserated,
we argued, we experimented, we built stuff, and I learned a great deal from
all of you.
Thank you also to Dave and Andy, the publishers; Bruce, the Seven in Seven
series editor; and Jackie, the editor of this book, for helping me to make this
an addition to the series that I enjoy so much. I really appreciate the
opportunity.
Writing a book like this, with seven technologies, requires more eyes than
just mine on the code; it requires the help of reviewers both reviewing the
book as a whole and diving deeply into technologies as experts. Here are the
reviewers who made this book possible by finding bugs and corrections and
offering style tips and encouragement. Thanks to all of you:
Michael Hunter, Kevin Garriott, Daniel Wanja, Loren Sands-Ramshaw,
Maricris Nonato, Javier Collado, Alessandro Bahgat, Daniel Lamb, Nishant
Srivastava, Gábor László Hajba, Ramaninder Singh Jhajj, Stephen Wolff,
Stefan Turalski, Kaan Karaca, Fabrizio Cucci, Jacob Henry, Colin Gray, Seth
Howard, Eric Langland, Rob Malko, Brandon Minnick, Jack Moffitt, and
Joshua Jamison.
Finally, thanks to my wife, Lori, and our kids, Diāna, Lincoln, and Titus, for
allowing me the time to write another book.
report erratum  •  discuss

The Story So Far...
In the beginning there was a mobile platform, and it was good. It ran on the
best mobile hardware available, both phones and tablets. It had an app store,
where consumers could buy new software for their mobile devices. Developers
liked to develop for this platform because the devices had fancy UIs, powerful
SDKs were available, and people could make money from the app store to
support their development.
There was a competing platform, though, and a lot of those devices looked
pretty good, too. But it wasn’t that easy to develop on. Its marketplace wasn’t
as good and the toolset was really hard to work with. If you were a developer
on the first platform, it didn’t seem very appealing to try to learn a whole dif-
ferent platform. If you had a good thing going, there was not a lot of value in
learning all new tools instead of spending time building apps you already
knew how to build. The best bet was to stick with what was comfortable and
just ride that gravy train to an early retirement.
And then everything changed.
The Only Constant
In case you didn’t already guess, the mobile platform I was just talking about
was Windows Mobile. Back in the days before the iPhone changed the mobile
space, Windows Mobile had a pretty good thing going. It already had everything
the iPhone introduced: an app store (by a different name) and good tools (for
the time), and it ran on pretty sweet devices (by those days’ standards). It
had a big competitor, or maybe more than one—who can remember back that
far? The point is that if you were making your living by developing Windows
Mobile apps then, there’s a really good chance you no longer are. Not that it
would have helped to have been proficient at more than one platform when
iOS came out and made them all pretty much obsolete. The point is not how
many platforms you’re proficient on, but rather how proficient you are at
learning new platforms.
report erratum  •  discuss

As software developers, we’ve learned that the platforms we build software
on change pretty often. If you pick a durable language to learn really well,
chances are you can get some mileage out of it, but you’re always having to
learn new SDKs, new APIs, new libraries. And of course, even languages can
become obsolete. With apologies to anyone still using it, I no longer include
Cold Fusion on my resumé.
The Seven in Seven series has always been about expanding your horizons,
about becoming a polyglot and a connoisseur of new ideas in software. You
don’t learn new languages or frameworks just because that’s a fun pastime,
although it can be, but because learning a new language, framework, or
platform exposes you to new paradigms and idioms, different ways to solve
problems. At some point you realize that recognizing the similarities and dif-
ferences between languages or platforms makes you think about building
software at a higher level, no matter what tool you’re using at the time. At
some point in your career you are no longer an “X developer”—where X is
whatever platform you prefer—and instead you have become a “software
developer."
Who Should Read This Book?
To get the most out of this book, you need to buy in to the premise of the
Seven in Seven series. The best way I can express that is that you fully believe
that continually exploring and learning about software development is your
responsibility as a developer. What you get in return is the inspiration, guid-
ance, and interesting problems that can help you maximize your time spent
learning. That means that this book isn’t a replacement for the official docu-
mentation; it doesn’t spend a lot of time telling you how to get set up, and
the platform coverage isn’t comprehensive. Instead, this book provides you
with a very useful tool: problems to solve in order to help you learn. Each
week you’ll build a nontrivial app over three days, and you’ll also get some
ideas of how you can take the app further yourself.
This book is focused on modern mobile platforms. Those are the “official”
platforms: mobile web, iOS, Android, and Windows. Closely related are three
cross-platform tools: RubyMotion, Xamarin, and React Native. The selling
point of these tools is that, to some greater or lesser extent, building apps for
one or more of the official platforms is easier, and you can share code between
the platforms.
If you’ve never done any mobile development before, it’s best if you have
software-development experience of some kind. This book is most helpful for
answering the following questions about each platform:
The Story So Far... • x
report erratum  •  discuss

• How does it feel to develop on this platform?
• How does this platform compare to the others?
• And, for the cross-platform tools, what are their pros and cons over
developing for one or more of the official platforms?
If you’re a software developer who wants to dive into mobile development,
this book will help you make a solid comparison between the platforms. If
you’re already a mobile developer for one platform, this book will give you a
great framework for evaluating another platform. And if you’ve ever wondered
or been asked by a client or manager if a cross-platform development tool is
the right one for the job, this book will help you answer that question about
three popular choices.
Seven Mobile Apps
Over the course of this book, we’ll build seven mobile apps. The point of
building the apps is to explore the platforms. To that end each of the apps
have a number of design goals.
App-Design Goals
Not every app hits every goal, but each reaches a large enough subset to give
you a really good taste of building for the target platform. Here is a list of
design goals.
• The apps should have enough view code that you get a feel for how
interface-building works.
• All apps have some level of navigation, multiple screens, or at least mul-
tiple views.
• All apps deal with displaying collections of data. This is something that
happens all the time, so we cover it.
• The apps all make HTTP requests to a JSON API, so you should have a
great idea of how to request data from the web. In some cases we’ll also
post data.
• Most apps include some information on designing and building interfaces
for multiple screen sizes and orientations.
• Most apps give you an idea of how to store data locally.
These design goals won’t make you an expert on the platform, but they will
give you an idea of what it’s like to work with common use cases.
report erratum  •  discuss
Seven Mobile Apps • xi

How a Week Works
Each platform is designed to be explored over a week. There are chapters for
three days of guided development, and each day ends with some suggested
next steps for you to study or try on your own.
On the first day we start out by creating a project from scratch, so you get
an idea of how that works and if there’s anything interesting to consider there.
We don’t spend a lot of time on setting up the tools beforehand, though. We’ll
then start by building a simple feature, which will explore a few of the APIs.
On the second day we build on what we started and get deeper into the SDK,
or possibly just deeper into the problem space of the app. Either way, you’re
thinking more deeply about the features of the app and we’re covering a
potential way to build those features.
On the third day we wrap up anything left over and implement a feature that
covers one or more of the more interesting APIs on the platform.
What the Apps Aren’t
There are a few things that we won’t cover, and a few caveats to be aware of.
• We don’t cover much, if anything, about animation. It’s hard to describe
in prose.
• The apps aren’t meant to be visually appealing. You may even think they’re
downright ugly. That’s fine, though, because you’ll soon be proficient
enough to make them look however you want!
• Whenever it makes sense, we spend time refactoring some of the first
experimental steps we take. However, the finished products aren’t neces-
sarily examples of the best architecture. Instead, they contain enough
good architectural choices to build a believable app of moderately small
size so that you can focus on learning the platform.
• We focus very little on error-checking data from the API, validating user
input, or dealing with edge cases. We stick to the happy path in order to
learn. If you see some obvious bug waiting to happen, good! Design a way
to handle the problem and implement it!
• In some cases we use third-party libraries because they’re common,
because not using them would cause unnecessary distraction, or because
it’s worth highlighting the package-management solution for the platform.
Any third-party libraries we use aren’t necessarily being endorsed, nor
are they necessarily the only choices out there.
The Story So Far... • xii
report erratum  •  discuss

Approach these apps as a guide for exploring the platforms and tools, and
you’ll get the most out of the next seven weeks.
The Platforms
Let’s take a look at each platform now and cover a little about what require-
ments each has.
Mobile Web
We felt like we just had to cover mobile web. There’s continually debate about
whether natively compiled apps are better than browser-based apps, or vice
versa. That debate will probably never be resolved, but in the meantime there
are apps to build and features to ship, and knowing where best to leverage
the desktop browser, the mobile browser, natively compiled apps, or a combi-
nation of all three is important.
For the mobile web platform we’ll build a responsive world-clock app complete-
ly in the browser. It will make a call to a separate API to get a list of world
time zones. The only thing you’ll need to build this app is a modern browser.
We start out with web first, because even though it’s likely you’ve done HTML
and JavaScript development before, it’s possible you’ve never done responsive,
mobile-first design. It’s a good place to start and get your feet wet before we
move on to the official native platforms.
Official Native Platforms
Official native platforms is the term I’m using to describe the current most
popular mobile platforms and the official SDKs for developing apps on them.
These are Apple’s iOS, Google’s Android, and Microsoft’s Universal Windows
Platform.
iOS
iOS needs no introduction. You can find everything you need to get set up at
Apple’s developer portal.
1 Getting set up to develop is free, but you’ll need to
develop on a Mac computer of some kind. We’ll be using Xcode, Apple’s official
IDE for iOS development, so make sure you have that set up and running on
your Mac before you dive into this chapter.
For iOS we’ll build a weather app that shows current weather conditions at
the mobile device’s location. It will also allow you to search for a location
1.
http://developer.apple.com
report erratum  •  discuss
The Platforms • xiii

somewhere in the world and see the weather there. It will use our API’s
weather endpoint to provide current weather data.
Android
Android doesn’t need an introduction either. To get set up to develop Android
apps, install Android Studio.
2 You can develop Android apps on either Mac
or Windows machines.
We’ll build a currency-conversion app for Android. It will allow you to convert
a certain amount of money from one world currency to another. We’ll get that
conversion data from our API.
Universal Windows Platform
The Universal Windows Platform, or UWP, may need some introduction
because it’s a pretty recent addition. Windows Mobile had its heyday and
then was replaced by Windows Phone 7, with new tools and a modern platform.
Windows Phone 8 moved that platform forward. With the release of Windows
10, though, Microsoft’s aim is to provide one SDK for building apps on any
Windows device, be it desktop, tablet, phone, or even Xbox. That’s what the
universal part means. The app we build will run as easily on a Windows 10
desktop as on a Windows 10 phone. However, Windows 10 is a requirement:
developing for UWP requires a machine running Windows 10 and Microsoft
Visual Studio.
3
We’ll develop a stock-quote app for UWP. It will display the latest quotes for
a list of financial indexes, as well as a watch list of user-chosen stock symbols.
It will get the stock-quote data through our API.
Cross-Platform Tools
In addition to mobile web and the official platforms, a well-rounded look at
the mobile development ecosystem needs to offer a viewpoint on cross-platform
tools. These are the tools that let developers build apps on the official platforms
but with some purported advantage. The advantage seems to fall into two
categories:
• Building apps with a certain language/toolset that some subset of devel-
opers prefers
• Building apps for multiple platforms while sharing code
2.
http://developer.android.com/sdk/index.html
3.
https://www.visualstudio.com
The Story So Far... • xiv
report erratum  •  discuss

Usually a tool ends up offering both advantages. A ton of these tools are out
there. I chose the three in this book based on two criteria: popularity and
native app support. Popularity is easy enough to understand. By “native app
support” I mean that these tools produce apps that are compiled and run
natively, as opposed to running in a web view with a native wrapper. They
use native components that users recognize, instead of custom components.
I believe this approach is superior to any of the HTML/JavaScript-in-a-web-
view solutions. Also, these three tools are well suited to building general-
purpose apps, whereas other natively compiled tools are better suited to game
development.
RubyMotion
RubyMotion has been around for a while and started out popular among
Rubyists.
4 The original selling point of RubyMotion was that you could use
Ruby to write iOS apps. But since 2014 RubyMotion has offered Android
support as well, and that puts it in the category of cross-platform tools.
RubyMotion is a subscription service. A free “starter” version is available, but
we’ll be using some features that require a paid version of RubyMotion—for
example, building an Android app for a specific minimum API level while still
targeting the latest version.
To develop with RubyMotion, you need Ruby and the command-line tools
from RubyMotion’s site. (Refer to the instructions on the RubyMotion site for
more information about setup.) To be able to build the Android app, you need
to install the Android SDK. To be able to build for iOS, you need Xcode
installed, and that requires a Mac.
For RubyMotion’s app, we’ll write a to-do-list manager. You can add to-dos
to different lists, marking the to-dos done when you’ve completed the tasks.
This will use the API’s to-do endpoints.
Xamarin
Xamarin is a powerful cross-platform development product.
5 With a Xam-
arin.iOS project you can write code for iOS in C#, and with a Xamarin.Android
project you can do the same for Android. Using a Portable Class Library, or
PCL, you can write a library containing shared business logic, including net-
working code, and push as much as possible out of the platform-specific
projects and into this shared code library. You can also share that logic with
4.
http://www.rubymotion.com
5.
https://xamarin.com/platform
report erratum  •  discuss
The Platforms • xv

Xamarin platform code written for Windows Phone, although we won’t cover
that in this book.
Further, you can use Xamarin.Forms, which is a cross-platform UI library.
This plus a PCL allows you to write a completely cross-platform app in C#.
We’ll do both in the Xamarin chapter, starting out with Xamarin.iOS and
Xamarin.Android and then converting the UI to Xamarin.Forms. Of course,
to run the iOS version you need access to a Mac with Xcode, just as you’d
need a Windows machine to build for Windows Phone. On Windows you can
develop with Visual Studio, and on Mac you use Xamarin Studio, Xamarin’s
IDE. Xamarin was recently purchased by Microsoft, which made Xamarin
free to use for indie developers and small teams.
We’ll build a calculator app with Xamarin and a grid-based UI on both iOS
and Android, code the calculator engine into a PCL, and then later convert
the UI to Xamarin.Forms for a fully cross-platform app. We’ll also integrate
a currency-conversion feature using the API’s currency-conversion endpoint.
React Native
Facebook’s React Native is a very recent, very exciting cross-platform app-
development tool.
6 You write apps in a modern flavor of JavaScript and use
command-line tools to compile and run on both iOS and Android. React Native
is still evolving quickly, but it has many things going for it: Facebook uses it
for a number of its apps, and it’s open source, with a growing community
behind it. React Native is free, so there’s no subscription to manage. To get
set up, consult the React Native site. Again, you need a Mac with Xcode
installed to run the iOS version of the app, and you need the Android SDK
installed for Android.
The React Native app will be a note-taking app that uses the API’s note end-
points. We’ll allow the user to create and view notes, and then we’ll geotag
the notes with location data from the mobile device. We’ll finish up by viewing
those notes on a map.
System Requirements and Useful Tools
Before we dive in, let’s talk about some of the supporting tools a bit. As you
can see from the overview of the platforms, your operating system matters.
You’ll also want to get set up with the simulators and emulators that assist
development and testing, and then get prepared to run the API by understand-
ing how to call a locally running web server from these.
6.
https://facebook.github.io/react-native
The Story So Far... • xvi
report erratum  •  discuss

Development Operating System Requirements
I’ve repeated a few times that you need a Mac for iOS development, and that
for the Windows Phone app you need a Windows 10 machine. So does that
mean you need two computers, a Mac and a Windows machine, to get the
most out of this book? Not necessarily, although it’s an easy solution if you
have one of each available. There are other solutions, though. One is to work
only on a Mac and skip UWP for now. Or you could develop on a Windows 10
machine and skip any of the iOS parts, focusing on Android and UWP. That
means you won’t be able to build the iOS app, or the iOS apps from any of
the cross-platform tools, unless you have access to a Mac.
Another solution, which I used, is to have a Mac with a virtual machine run-
ning Windows 10. I used a MacBook Pro, my main computer, and installed
Windows 10 using Boot Camp. I then built the UWP app in Windows 10 and
everything else in Mac OS. This seems like the perfect compromise, but I will
mention a caveat. I was unable to install, let alone run, the Windows Phone
emulator on either a virtual machine solution or Boot Camp on my Mac. There
seems to have been some low-level incompatibility with the emulator’s virtu-
alization software and the Mac. Until this problem is solved, the only way to
run the UWP app from a Mac to a phone is to buy an actual Windows 10
phone. The app will run fine on the Windows 10 desktop version, just not on
the emulator. Luckily, you can buy a Windows 10 phone for a pretty low price.
If you run a Linux system you should be able to work with the Android
examples, but you may not have full capabilities there. None of the code here
has been tested on a Linux system.
Simulators, Emulators, and Mobile Devices
Developing mobile apps has an upside: you get to play with lots of toys. When
you get set up for development on all of these platforms, you’ll have access
to a few choices for where to run the apps. Xcode comes with the iOS Simu-
lator,
7 the Android SDK comes with the Android emulator,
8 and Windows
Phone has an emulator too. You can also deploy any of the apps you build
here to a physical mobile device. If you’d like, look into alternative Android
emulators, such as Genymotion.
9
7.
https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/
Introduction.html
8.
http://developer.android.com/tools/help/emulator.html
9.
https://www.genymotion.com
report erratum  •  discuss
System Requirements and Useful Tools • xvii

So, where is it best to test? For day-to-day development, choose whatever
works best for you. Work with all of the simulators and emulators, both third
party and official, so you can get an idea of what works best for different
development scenarios. The only advice I’ll give here is that you should always
test on a physical mobile device before you ship—probably on multiple devices,
in fact.
For the purposes of this book, you should get to know the simulator and the
emulators. Look up the documentation on each and learn how to:
• Simulate rotating the device.
• Interact with the menu button for the Android emulator.
• Run different device types and screen geometries for tablets and phones
of different sizes.
• Clear local data and remove apps.
• Simulate physical device location.
Remember that the simulator and emulators work well for testing websites
on mobile devices, too. Speaking of that, let’s talk quickly about how to point
to localhost.
Calling Localhost
When building the parts of the apps that require us to use the local API, we
have to point to a local web host. From the iOS Simulator, it’s no problem;
just point to localhost. For the Android emulator, you need to point to 10.0.2.2,
and for Genymotion you need to point to 10.0.3.2. You’ll see this in the code
when we get to it for each app, but it’s worth mentioning now.
If you want to test with a physical mobile device, it’s a bit harder, though.
One solution I like is tunneling software called ngrok.
10 There are other,
similar solutions. There is also the venerable Charles proxy.
11 With the tun-
neling solution, you’d point the app to a generated web host, which would
then tunnel through to your locally running API. With Charles as a proxy,
you’d instead point your code at some nonexistent host, such as foo.bar, proxy
your mobile device through your development machine’s address, and then
set up a rewrite rule to translate http://foo.bar to your locally running API. Refer
to the Charles documentation for more information if you’d like to try this.
10. https://ngrok.com
11. https://www.charlesproxy.com
The Story So Far... • xviii
report erratum  •  discuss

As you can see, there are lots of little bits to think about when developing
mobile software. These are the tips and tricks that you build up over the years
to make development smoother for you and your team.
Don’t Get Comfortable
Picking up this book and learning these platforms is a good move in your
development career. It shows that you’re not staying in your comfort zone.
You’re not going to let yourself get into a rut; you want to explore, know
enough about the other platforms to make educated comparisons, and ulti-
mately be ready when the next big change comes.
Online Resources
You can find the apps and examples shown at the Pragmatic Programmers
web page for this book.
12 As we progress through each app, it’s not always
possible to show all of the changes, so the code in the book focuses on the
important ones. The code for each project is separated roughly by day and
significant change—in other words, the whole project is provided, including
all changes for each section of each day. You can always refer to the code
download for any questions you have about implementation.
On the web page for the book you’ll also find the community forum and the
errata-submission form, where you can report problems with the text or make
suggestions for future versions.
12. http://pragprog.com/book/7apps
report erratum  •  discuss
Don’t Get Comfortable • xix

CHAPTER 1
Day 0: Setting Up the API
Unless the mobile apps you build are games, it’s highly likely that the
requirements for any nontrivial app will include loading data from the web.
To give you the best learning experience to evaluate the seven platforms, it’s
important that you get a chance to make some HTTP requests. In fact, each
of the apps we’ll build relies in some way on data loaded from the web. To
accomplish this, the code download for this book includes a fully built API
with a set of endpoints, or paths to call, such as /weather, that provide data to
each of the apps we’ll build over the next seven weeks.
The API is built using Ruby on Rails.
1 If you don’t have any experience with
Rails, don’t worry. You won’t need to write any code; you just need to have
the Rails app running when it comes time to write the code that makes the
API calls in the apps. Getting this API set up is the first task in writing the
apps, so let’s lay the groundwork for the rest of the project by taking the time
to get the API set up, running, and tested.
Setting Up and Running the API
The prerequisites for running the API are Ruby and Bundler, a Ruby library
package manager.
Installing Prerequisites
Here are the steps to be ready to run the API:
• Install Ruby. If you don’t already have Ruby installed, find instructions
on the Ruby website.
2 The code has been tested against Ruby 2.3 on OS
X El Capitán. On Windows, due to an issue with Ruby and Windows, only
1.
http://rubyonrails.org
2.
https://www.ruby-lang.org
report erratum  •  discuss

Ruby 2.0 is tested. If you’re using Windows, you may want to use
RubyInstaller and DevKit.
3 4
• Install Bundler.
5 Bundler is a RubyGem, so once you have Ruby installed,
you can execute gem install bundler from the command line.
On Mac, I also recommend using a Ruby version manager, such as rvm. The
project is set up to work with some common ones already, with a .ruby-version
and a .ruby-gemset file.
Running the Server
Next, in the code download for this book, go to the API directory in a terminal.
Execute the following commands:
• bundle install to install all of the RubyGems needed for the Rails app,
including the Rails gem itself. The code has been tested against Rails 4.2.5.
• rake db:migrate to create the local database and load the schema.
• rails server to run the server. It will be available at http://localhost:3000.
Take note that the API uses the venerable MapQuest API for the reverse
geocode endpoint.
6 The main use case is for reverse-geocoding the locations
sent from our Notes app, the React Native project. For that endpoint to work,
you’ll need a MapQuest API key. You can get one for free at the MapQuest
site. Once you have one, set the environment variable MAPQUEST_API_KEY to your
key. You can do that and start the server in one command:
$ MAPQUEST_API_KEY=<key> rails server
Or, on Windows:
$ set MAPQUEST_API_KEY=<key>
$ rails server
If you forget that, the reverse geocode endpoint will not work as expected and
instead will return an error message from the MapQuest API.
In case you’d like to dig further into the API code, there’s a set of tests, par-
ticularly integration tests, in the test directory. You can run these with rake
from the command line.
OK, now let’s look at the different endpoints in the API.
3.
http://rubyinstaller.org
4.
http://rubyinstaller.org/add-ons/devkit
5.
http://bundler.io
6.
http://developer.mapquest.com
Chapter 1. Day 0: Setting Up the API • 2
report erratum  •  discuss

Reviewing and Testing the Endpoints
The endpoints are not one-to-one with the apps we’ll build; in fact, both the
Android and Xamarin apps use the currency-conversion endpoint, and the
React Native app uses the notes endpoints and the reverse geocode endpoint.
I recommend testing the API endpoints to make sure you’re getting back what
you expect. You can use any HTTP client, such as Postman.
7 You just need
to be able to set the Content-Type and Accept HTTP headers to application/json. I’ve
provided examples in the following sections using curl.
Time Zones
The /clock/time_zones endpoint is pretty simple. It returns a list of all the time
zones that Rails knows about, decorated with a little extra display information.
If you call
$ curl -H "Content-Type:application/json" -H "Accept:application/json"\
http://localhost:3000/clock/time_zones
the API will return
[{"name":"American Samoa",
"zone_name":"Pacific/Pago_Pago",
"offset":-39600,
"formatted_offset":"-11:00"},...]
The time zone API is used for the mobile web app.
Weather
The /weather endpoint will return the current weather conditions in a given
area. The last element in the path is the area to search for, and it’s flexible
enough to accept a number of different types of data, such as a U.S. postal
code or just a city name. This endpoint uses Yahoo!’s weather API.
8 Although
these apps aren’t meant to be shipped to users, note that any app using
Yahoo!’s APIs is required to display an attribution.
9
As an example,
$ curl -H "Content-Type:application/json" -H "Accept:application/json"\
http://localhost:3000/weather/location.json?name=Arvada,CO
will return
7.
https://www.getpostman.com
8.
http://www.yahooapis.com
9.
https://developer.yahoo.com/attribution
report erratum  •  discuss
Reviewing and Testing the Endpoints • 3

{"title":"Conditions for Arvada, CO at 7:44 pm MST","temp":"30",...}
The weather API is used for the iOS app.
Currency Conversion
The /convert endpoint returns currency information. This endpoint uses cur-
rency financial data from Yahoo!’s APIs.
10 Again, although these apps aren’t
meant to be shipped to users, note that any app using Yahoo!’s APIs is
required to display an attribution.
11
To test the endpoint,
$ curl -H "Content-Type:application/json" -H "Accept:application/json"\
http://localhost:3000/convert/USD/EUR
should return
{"name":"USD/EUR","rate":"0.9164","numerical_rate":0.9164,"from":"USD","to":"EUR"}
The conversion API is used in the Android and Xamarin apps.
To-Dos
The /todos endpoint doesn’t use any external data sources. It’s a standard
Rails-flavored RESTful endpoint. It responds to the HTTP verbs—for instance,
GET for reading data, POST for creating, and PUT for updating.
As an example, creating a to-do like this
$ curl -X POST -d '{"title":"Get Milk"}' -H "Accept: application/json"\
-H "Content-Type: application/json" http://localhost:3000/todos
will return
{"id":5,"title":"Get Milk","complete":false,...}
and loading all to-dos like this
$ curl -H 'Content-Type: application/json' -H 'Accept: application/json'\
http://localhost:3000/todos
will return
[{"id":1,"title":"Get Milk","complete":false,
"url":"http://localhost:3000/todos/1.json"}]
We use the to-dos API in the RubyMotion apps.
10. http://www.yahooapis.com
11. https://developer.yahoo.com/attribution
Chapter 1. Day 0: Setting Up the API • 4
report erratum  •  discuss

Stock Quotes
The /stock_quotes endpoint returns stock quote data for a given list of comma-
separated stock symbols. This endpoint uses stock-quote data from Yahoo!’s
APIs.
12 Once again, although these apps aren’t meant to be shipped to users,
note that any app using Yahoo!’s APIs is required to display an attribution.
13
To test,
$ curl -H "Content-Type:application/json" -H "Accept:application/json"\
http://localhost:3000/stock_quotes/AAPL,GOOG,MSFT
should return
{"quotes":[{"name":"Apple Inc.","percent_change":"-2.40%","symbol":"AAPL",...]}
We use the stock-quote API for the Windows app.
Notes
The /notes endpoint is a local data API that responds to the same verbs as the
to-dos API.
To test creating a note, call this:
$ curl -X POST -d '\
{"title":"Noteworthy", "body":"Notes are important for keeping track of things"}'\
-H "Accept: application/json" -H "Content-Type: application/json"\
http://localhost:3000/notes
which should return this:
{"id":22,"title":"Noteworthy","body":"Notes are important...}
And to test loading all notes,
$ curl -H 'Content-Type: application/json' -H 'Accept: application/json'\
http://localhost:3000/notes
will return
[{"id":22,"title":"Noteworthy","body":"Notes are important...}]
We use the notes API for the React Native app.
12. http://www.yahooapis.com
13. https://developer.yahoo.com/attribution
report erratum  •  discuss
Reviewing and Testing the Endpoints • 5

Reverse Geocode
The /reverse_geocode endpoint is a very simple endpoint that returns a place
name given a latitude and longitude. The reverse geocoding is done by
MapQuest’s API. There’s more information on the MapQuest developer site.
14
To test, this endpoint
$ curl -H 'Content-Type: application/json' -H 'Accept: application/json'\
http://localhost:3000/reverse_geocode\?lat\=37.33233141\&long\=-122.0312186
should return
{"place":"Infinite Loop Cupertino CA"}%
We use the reverse-geocode API for the React Native app.
Now We’re Ready
With the API tested and performing as expected, we’re ready to get going with
the first set of apps, starting with a mobile web app.
14. http://developer.mapquest.com
Chapter 1. Day 0: Setting Up the API • 6
report erratum  •  discuss

Part I
Official Native Platforms
In the first four weeks we’ll cover the “official”
platforms, the ones created by the major platform
vendors: Apple, Google, and Microsoft. We’ll write
the apps in the official languages and use the offi-
cial tools for development.
But before we get into those, we’ll start out with a
mobile web app, which is perhaps not natively
compiled but is natively available on every mobile
platform and more. In that sense, while it’s intrinsi-
cally cross-platform, it’s also the most native plat-
form there is.

CHAPTER 2
Mobile Web
I spend most of my mobile-app programming time in native technologies, but
like many of you, my roots are in web development. I remember building my
first web page when I was in high school, circa 1993. I called it Das Hof-
brauhaus, I guess because I thought it sounded cool. It had a sweet textured
background, a picture of Bilbo Baggins from the Rankin/Bass Hobbit cartoon,
and JavaScript to randomly change the status-bar message. I can’t honestly
tell you that there were no blink tags in use.
Not only have computer technology and web browsers come a long way since
then, not to mention my taste in web design, but web developers now have
to deal with a whole new class of devices, screen sizes, and contexts in which
users find themselves. Mobile is a whole new world for web developers.
Luckily, mobile browsers have kept up with device capabilities to the point
where it’s possible to build a web app that can function almost indistinguish-
ably from a native app.
Native apps will always have a leg up over web apps in a number of areas, of
course, but it’s important to remember that even if your business requires a
native mobile app, when your users find themselves on your website using a
mobile device, they’d better have a good experience.
Which brings us to what we’ll build this week. Let’s look at our first app in
the book: a mobile web app.
report erratum  •  discuss

A World-Clock App
The app this week is a world-clock app. It will allow the user to keep a list of
locations for which they want to know the current time and see those as a
list of clocks. We’ll build it completely from web technologies, to be viewed
anywhere web technologies can be viewed. That means mobile browsers, of
course, but also desktop browsers.
This app is meant to be mobile—in other words, the design will be responsive
to screen size and sensitive to low-to-no-connectivity situations. However, we
can work out the majority of the functionality on a desktop browser, so we’ll
look at some examples of things like debugging using a desktop browser.
Day 1 will be about getting a project set up and a structure in place for the
code. We’ll also get the basic clock and time-zone-management functionality
built. We’ll be using the API’s /clock/time_zones endpoint to get a list of time zones
to choose from. On Day 2 we’ll build out the unstyled user interface for dis-
playing clocks, adding a clock by choosing from a list of time zones, and
removing clocks. Day 3 is where we’ll turn the web app into a mobile web
app. We’ll deal with caching data locally, using an application cache to store
the code locally, and get everything ready to run from a mobile device like a
native application. Finally we’ll apply a mobile-first responsive design so the
app works on an array of screen sizes. Let’s get started!
Chapter 2. Mobile Web • 10
report erratum  •  discuss

Day 1: A Time for Beginnings
Or, Creating and Organizing a Web App Project
This app, being a web app, has one major difference from the rest of the apps
we’ll build over the next few weeks: we’ll build the rest of the apps for a par-
ticular platform or framework, or both. As developers, having a framework is
a good thing. It limits our options to working within the conventions and
structure of the framework and allows us to focus. Ideally the creators and
community of users have already made a number of decisions about funda-
mental things so that we don’t have to rethink those choices every time we
start a new project.
When it comes to the web, we do have to make some fundamental decisions
every time we start a project, or at least we need to pick a framework that
makes some of the decisions for us, often then going on to add on some other
tools and libraries as needed. Native app development certainly involves
choosing and relying on third-party libraries and tools, but not to the deep
extent that web development does.
So, keep that in mind this week as we build this app—the libraries and tools
we use here aren’t the only ones that would have worked to solve these
problems, and some libraries shape the development of the app differently
than others. Think of the inclusion of the libraries not as recommendations
but as indications that the particular problem the library solves is a good one
to solve with a library. In other words, when we use a library or even make
a particular architectural decision, pay attention to the shape of the problem
and think of that as a slot into which a third-party library might fit.
With that in mind, let’s get started by setting up the project.
Setting Up the Project
To get this project set up, let’s make two decisions: what we want the directory
structure to be and how we should deal with third-party libraries. First let’s
nail down a directory structure.
Making a Project Structure
In general, a web project needs to have a place to store HTML, CSS, JavaScript,
and images. We’ll decide on a place for all of those things up front. Here’s a
directory structure that covers those basics. Create that now.
report erratum  •  discuss
Day 1: A Time for Beginnings • 11

/
└──app
├──images
├──scripts
└──styles
The app directory will contain files that go in the root of the website. This allows
us to keep the root of the project available for scripts, configuration, and anything
else that doesn’t need to be shipped with the app. HTML files will go into app.
Speaking of third-party libraries, we’ll use the Node.js package-management
system called NPM to manage our dependencies,
1 so let’s get that configured.
Creating an NPM project
To get access to NPM, you need to first install Node.js.
2 Once you have Node
installed, change directories into app and issue the command npm init ., filling
out the form with information similar to what you see here:
$ npm init .
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.
See `npm help json` for definitive documentation on these fields
and exactly what they do.
Use `npm install <pkg> --save` afterwards to install a package and
save it as a dependency in the package.json file.
Press ^C at any time to quit.
name: (webapp) clock
version: (1.0.0)
description: A mobile web world-clock app
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /Users/tony/work/writing/node-web/package.json:
{
"name": "clock",
"version": "1.0.0",
"description": "A mobile web world-clock app",
"main": "index.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
1.
https://www.npmjs.com
2.
https://nodejs.org
Chapter 2. Mobile Web • 12
report erratum  •  discuss

"author": "",
"license": "ISC"
}
Is this ok? (yes) y
$
This creates the file app/packages.json, which stores information about any
dependencies we register. Let’s see how to register dependencies with NPM.
Installing Dependencies with NPM
Underscore is a library of useful functional JavaScript utilities, and jQuery
is a very commonly used library in JavaScript projects. jQuery is great for
providing syntactically clean methods for finding, creating, deleting, and
otherwise managing HTML DOM elements. Here is a command-line session,
run from the app directory, showing the installation of these two modules.
$ npm install "jquery@2.1" underscore --save
underscore@1.8.3 node_modules/underscore
jquery@2.1.4 node_modules/jquery
Notice that the command specifies a version of 2.1 for jQuery. No version is
specified for Underscore, which will cause NPM to fetch the latest stable ver-
sion. The command-line switch --save tells NPM to write the dependency into
app/package.json.
WebApp/web_01_02_simple_clock/app/package.json
{
"name": "clock",
"version": "1.0.0",
"description": "A mobile web world clock app",
"main": "index.js",
"private": true,
"dependencies": {
"jquery": "^2.1.4",
"underscore": "^1.8.3"
},
"devDependencies": {},
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"author": "",
"license": "ISC"
}
report erratum  •  discuss
Day 1: A Time for Beginnings • 13

So there’s now a dependencies section in the NPM config file. The dependencies
are all installed in app/node_modules, which is where we can reference them. It’s
best to keep this directory out of source control. Then anyone else working
on the project can install a fresh copy of all the dependencies as defined in
package.json by issuing the command npm install.
Now with a good package manager in place, we’re ready to start writing our
own code.
Creating the Business-Logic Classes
Good software design, no matter what the language or platform, is as much
about sorting and categorizing code as anything. An HTML and JavaScript
project of any appreciable size needs good design too. That means some way
to organize code by responsibility into something like a class or module.
Merely sorting the code into separate files is only part of the solution. When
code from one module needs to reference code from another, we need a way
to cleanly and unambiguously reference the right code. JavaScript in the
browser hasn’t historically offered any solution to this problem, which leaves
developers having to roll their own.
This problem is solved differently by different frameworks. After picking an
architectural framework such as Backbone.js or Angular.js,
3 4 you can simply
fall into the patterns they put in place. For this app we won’t use a framework
like those, though; we’ll build our own solution. It’s worth taking a look at
building a solution from the ground up to see one way of solving it. After this,
you can use an architectural framework and have a good understanding of
how it works.
This app’s solution for namespacing, or sorting code into a hierarchical
structure, is pretty rudimentary, but it’s good enough for our needs. Let’s
look at how it works.
Building a Way to Namespace Classes
The app’s bootstrapping code is in a file called main.js. Here are the initial
contents, including a function called register(), which we’ll use to register code
modules into a namespace created for our app.
3.
http://backbonejs.org/
4.
https://angularjs.org/
Chapter 2. Mobile Web • 14
report erratum  •  discuss

WebApp/web_01_02_simple_clock/app/scripts/main.js
(function($) {
window.app = {};
$.app = window.app;
$.app.namespaces = { };
$.app.register = function(namespace, object) {
var leaf = _.reduce(namespace.split("."), function(context, name) {
context[name] = context[name] || {};
context = context[name];
return context;
}, $.app.namespaces);
$.extend(leaf, object);
};
})(jQuery);
The code for this whole file is wrapped in a function, into which is passed an
instance of jQuery. The conventional reference to jQuery is a $. This dollar-sign
variable can be referenced from a global context, but it’s safer to pass in a
reference like we do here, to make sure the dollar sign means what we expect.
This may seem strange if you’re not used to it, but it is a common pattern
when using jQuery.
Next, we create a JavaScript object to store information about our app. We
also attach this app variable to $ and so make it referenceable from wherever
we use jQuery. Then we create another object to store namespaced modules.
The register() function will take a dot-delimited namespace, à la Java or C#,
and a JavaScript object as a code module. The full namespace will be created
as a hierarchy of objects.
Next we’re using Underscore’s reduce() function, which iterates a list, passing
a context along with each iteration. If the namespace doesn’t exist already,
it will be created. Then, after the reduce is complete, jQuery’s extend() function
attaches the code module to the namespace hierarchy.
Finally, at the end of the file, the function wrapping the entire file is called,
passing in an instance of jQuery.
Now let’s see the registration in action by creating a module called Clock, which
will contain all of the logic for displaying the correct time for all of the clocks
in the app.
report erratum  •  discuss
Day 1: A Time for Beginnings • 15

WebApp/web_01_02_simple_clock/app/scripts/clock.js
(function($) {
var Clock = {
tick : function() {
var date = new Date();
$(".clock").text(date.getHours() +
":" + this.zeroPad(date.getMinutes()) +
":" + this.zeroPad(date.getSeconds()));
},
zeroPad : function(number) {
var s = number.toString();
var formattedNumber = (s.length > 1) ? s : "0" + s;
return formattedNumber;
}
};
$.app.register("models.Clock", Clock);
})(jQuery);
This module will start out simply, with a function called tick for displaying the
current time and a utility function to zero-pad single numbers.
The last line in the module is where we call the register, namespacing the clock
module to models.Clock. Now any other module that needs to reference this one
will need to point to $.app.namespaces.models.Clock. We’ll see this in action in just
a second. First let’s get an HTML page together for the clock to act on.
Showing the Time
Here’s a simple HTML file, with an unordered list containing an item with the
ID clock and with script tags referencing all of the JavaScript in our project so
far and a few files that we’ll look at shortly.
WebApp/web_01_02_simple_clock/app/index.html
<!DOCTYPE HTML>
<html>
<head>
</head>
<body>
<ul><li class="clock"></li></ul>
<script src="node_modules/underscore/underscore.js"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="scripts/main.js"></script>
<script src="scripts/time_zone_manager.js"></script>
<script src="scripts/clock.js"></script>
</body>
</html>
Chapter 2. Mobile Web • 16
report erratum  •  discuss

Looking back at the code for the clock’s tick function, notice that it puts the
current time into the text of $(".clock"). This is the way to get a reference to items
in the HTML’s DOM using jQuery. The . (dot) means to look for an element
with a certain class. So, in full, $(".clock").text("foo") tells jQuery to find all tags
with a class of clock and set their text to be “foo.”
Now we have the clock module and the HTML page. To get the time into the
list item, let’s use a desktop browser’s console. Getting to know the console
and the other development tools of each of the browsers is a good thing, so
do some investigation if you’ve never worked with a browser’s console before.
First, load app/index.html into your browser of choice from the filesystem—no
need for a web server at this point—and then open the browser’s developer
console. From the console, issue this command: $.app.namespaces.models.Clock.tick().
That should fire the tick function, which will write the current hour and min-
utes into the list item on the page.
Now that we have a clock module to show the time and an HTML page to put
the time on, we need one more module to manage a list of time zones the
app’s users can choose from when they’d like to add a new clock. Let’s do
that now.
Managing Time Zones
The app we’re building is a world clock, which is a list of clocks for different
locations in the world. What the app really needs to store is not clocks but
time zones. We’ll have another module, TimeZoneManager, handle storing a list
of time zones for the user to choose from.
WebApp/web_01_02_simple_clock/app/scripts/time_zone_manager.js
(function($) {
var TimeZoneManager = {
fetchTimeZones : function(completion) {
$.ajax({
url
: "http://localhost:3000/clock/time_zones",
headers : { Accept: "application/json" },
success : function(data) {
completion(data);
}
});
}
};
$.app.register("managers.TimeZoneManager", TimeZoneManager);
})(jQuery);
report erratum  •  discuss
Day 1: A Time for Beginnings • 17

For now this module’s only function is to fetch the time zones from the API.
It does that using another useful jQuery function, ajax. This function takes
an object with options and makes an HTTP call. If a success function is
included as an option, it will be called with the returned data when the HTTP
request is complete.
Next we’ll test this fetch function from the browser console. Before we do, it’s
important that we understand what we need to do on the API side to make
the call work. This requires an understanding of cross-origin resource sharing,
or CORS for short.
A Note on CORS
If you have done any work with websites where you needed access to data
from a server, it’s likely that the website was dynamic, or requested through
a server where some code was creating the HTML and delivering it to the web
browser. In that case the HTML is coming from the same origin as the server,
and the browser knows that any calls back to the server are coming from
HTML served by that server.
Our web app is not being delivered from the same server as the API. The
browser knows this, and without some extra work it will not allow us to call
the API. The reason for this is the security against cross-site scripting
attacks—browsers by default deny access to Ajax requests to a different origin
than the code was served from.
At the very least, to allow our app—served from the filesystem—to access the
Rails API, the API needs to add a header explicitly allowing access from across
different origins. Here’s a very rudimentary Rails concern that adds that
header, which is already in place in the API.
API/app/controllers/concerns/permissive_cors_behavior.rb
module PermissiveCorsBehavior
extend ActiveSupport::Concern
included do
before_filter :add_permissive_cors_headers
end
def add_permissive_cors_headers
headers['Access-Control-Allow-Origin'] = '*'
end
end
Chapter 2. Mobile Web • 18
report erratum  •  discuss

And here is the Rails controller that uses the module and serves time zones
to our app, again, already in place.
API/app/controllers/clock_controller.rb
class ClockController < ActionController::Base
# comment out the following line to exclude access to this API
# from javascript not originating on this server.
include PermissiveCorsBehavior
You could take on faith the fact that this header works, or if you’d like you
can comment out the include line at the top of the controller and try the Ajax
request from your browser’s console, like this:
$.ajax({ url: "http://localhost:3000/clock/time_zones", headers : { Accept: "application/json" }})
If the header isn’t present, you’ll see an error similar to this in your browser:
XMLHttpRequest cannot load http://localhost:3000/clock/time_zones.
No 'Access-Control-Allow-Origin' header is present on the requested resource.
Origin 'null' is therefore not allowed access.
In any case, the more you work with web apps like this, which access a remote
API, you should understand the issues that CORS addresses. Let’s move on
to making a request from the time zone manager module—make sure the API
is back to serving the Access-Control-Allow-Origin header, and let’s try out the time
zone manager’s fetch.
Loading Time Zones from the API
To try out the time zone manager’s fetch, we’ll execute the fetch from the
console. Try it like this.
> var timeZones = $.app.namespaces.managers.TimeZoneManager
[Object {fetchTimeZones: function}]
> timeZones.fetchTimeZones(console.log.bind(console))
undefined
[Object, Object, ...]
First we set a variable to reference the module at the namespace path we
created for it. Then we call the fetch function. It takes a callback, or a function
to be executed on completion. Here we simply log the results to the con-
sole—the results of the fetch are delivered directly into console.log once it’s
properly bound to the console reference. The code here just shows a list of
objects, but in your browser you should be able to inspect these time zone
objects to see the attributes served by the API. The image on page 20 shows
a representation of this session from the Chrome browser.
report erratum  •  discuss
Day 1: A Time for Beginnings • 19

These are the objects that we’ll employ to allow users to create clocks for time
zones all over the world.
Now that we have a clock module and a time zone module, let’s take a break
and reflect on what we’ve accomplished so far.
What We Learned on Day 1
What we’ve built today doesn’t have much in the way of a UI, but it’s the core
of a connected web app that will run as well on a desktop browser as on a
mobile browser.
We’ve gotten a dependency-management system in place and built a functional
namespacing system, two business-logic modules, a clock, and a time zone
manager. We’ve also seen firsthand how CORS works, how to interact with
downloaded code in a web-browser console, and, of course, how to work with
two useful and popular libraries, jQuery and Underscore.
Chapter 2. Mobile Web • 20
report erratum  •  discuss

Your Turn
Find
• NPM documentation
• Underscore documentation
• jQuery documentation
• More information about using CORS
• Details on the capabilities and differences of web browsers across devices
Do
• After reading up on jQuery documentation, practice manipulating the
DOM through a few different browsers’ consoles, adding and removing
elements, changing text, and so forth.
• The time-formatting code in the clock module assumes the user wants to
see 24-hour time. Although 24-hour time makes more sense in every way,
we should respect users’ preferences. Rewrite the formatting code to
optionally format the time to either 24-hour or 12-hour time.
Day 2: Making Time
Or, Managing the Clock List
Today we’ll pick up where we left off yesterday. Today is about getting all the
functionality of a world-clock app in place. We’ll create an unstyled, vanilla
UI that we can build on to add the mobile-specific features in Day 3.
For features, we’ll get a default clock displaying the local time zone, display
a list of time zones for users to choose from, and finish up by allowing users
to edit the clock list by removing clocks they don’t want to see. Let’s get
started.
Creating Clocks
As we’ve seen already, what drives the list of clocks is actually a list of time
zones, which the clock interprets into a list of clocks using the current date
of the browser. The time zone manager will manage a list of these time zones.
To have a clock to display initially, before the user chooses any clocks, we’ll
make sure that the first item in this list is the current time zone, based on
the time provided by the browser.
report erratum  •  discuss
Day 2: Making Time • 21

Displaying the Current Time
Let’s add a function to the time zone manager module to return the list of the
user’s saved time zones. We’ll also have an option to prepend the browser’s
current time zone.
WebApp/web_02_01_default_clock/app/scripts/time_zone_manager.js
savedZones : function(includeCurrent) {
var zones = [];
if (includeCurrent) {
var refDate = new Date();
var offsetMinutes = refDate.getTimezoneOffset();
zones.push({
name: "Current",
zone_name: "Current",
offset: -offsetMinutes * 60,
formatted_offset: this.formatOffsetMinutes(-offsetMinutes)
});
}
return zones;
},
formatOffsetMinutes : function(offsetMinutes) {
var offsetHours = offsetMinutes / 60;
offsetHours = Math.abs(offsetHours).toString() + ":00";
if (offsetMinutes < 600) offsetHours = "0" + offsetHours;
if (offsetMinutes < 0) offsetHours = "-" + offsetHours;
return offsetHours;
},
If the includeCurrent option is true, we’ll construct a current time zone object
like the ones the API returns.
With this code in place, we can test the time zone manager’s savedZones()
function in the console, like this:
> tzManager = $.app.namespaces.managers.TimeZoneManager
[Object {fetchTimeZones: function,
savedZones: function, formatOffsetMinutes: function}]
> tzManager.savedZones(true)
[Object
formatted_offset: "-06:00"
name: "Current"
offset: -21600
zone_name: "Current"
__proto__: Object]
Now that we have a list of saved time zones to work with, we can render them
on the page. First we need a way to have some code run when the page is
completely loaded. We can use jQuery’s ready for that, as we do here in main.js.
Chapter 2. Mobile Web • 22
report erratum  •  discuss

WebApp/web_02_01_default_clock/app/scripts/main.js
$(document).ready(function() {
var tzManager = namespaces.managers.TimeZoneManager,
clock = namespaces.models.Clock;
tzManager.fetchTimeZones(function(timezones) {
tzManager.createClocksIn($("#clockList"));
clock.start();
});
});
Now, when the page is loaded and ready for scripts to run, we tell the time
zone manager to create clocks in the clock list and then tell the clock module
to start updating the clocks on the screen by calling start().
Creating clocks, which is done here in the time zone manager (for now), is a
matter of getting the saved zones and iterating through them with Underscore’s
each() function.
WebApp/web_02_01_default_clock/app/scripts/time_zone_manager.js
createClocksIn : function(list) {
var zones = this.savedZones(true);
_.each(zones, function(zone) {
var item = $("<li class='clock'/>");
$(list).append(item);
});
}
For each zone, we create a new li tag with a class of clock, wrapped with jQuery,
and then append that to the HTML list element passed to the function.
Next, the clock module’s start() function is called.
WebApp/web_02_01_default_clock/app/scripts/clock.js
start: function() {
this.tick();
var tickFunction = _.bind(this.tick, this);
setInterval(tickFunction, 1000);
},
This function fires the tick() immediately, so there’s no rendering the clocks,
but also sets up a JavaScript timer to fire every second using setInterval().
Pay attention to the use of Underscore’s bind(). JavaScript has a rather unique
and surprising approach to dynamic lexical scope. If you’re new to JavaScript,
at some point you’ll find out the hard way that the this variable doesn’t refer
to what you think it does. When you’re writing a JavaScript function, it seems
reasonable to assume that this will point to something in the context where
the function is defined, but that doesn’t always hold true. The this variable
always refers to the parent context of the function at call time.
report erratum  •  discuss
Day 2: Making Time • 23

Here, the tick() function, when the timer calls it, is going to be called by a dif-
ferent context. So your intuition may tell you that inside the tick() function this
points to the Clock module, but actually it doesn’t. If we need to call another
function defined in clock module, we have to ensure that this points to the
clock module. Underscore’s bind function does this for us by either wrapping
a native browser function or providing it for incompatible browsers. It returns
a function where this is bound to the Clock module.
Now let’s take a closer look at the tick() function.
WebApp/web_02_01_default_clock/app/scripts/clock.js
tick : function() {
var date = new Date(),
tzManager = namespaces.managers.TimeZoneManager,
zones = tzManager.savedZones(true);
var updateClockAtIndex = function(index, element) {
var zone = zones[index],
formattedTime = this.convertAndFormatDate(zone.offset, date);
$(element).text(formattedTime);
};
updateClockAtIndex = _.bind(updateClockAtIndex, this);
$(".clock").each(updateClockAtIndex);
},
convertAndFormatDate : function(offset, date) {
var convertedSeconds = date.getUTCMinutes() * 60 +
date.getUTCHours() * 3600 + offset,
hour = Math.floor(convertedSeconds / 3600),
minutes = Math.abs(
Math.floor((convertedSeconds - (hour * 3600)) / 60)
);
if (hour < 0) {
hour = hour + 24;
} else if (hour >= 24) {
hour = hour - 24;
}
var formattedTime = this.zeroPad(hour) + ":" + this.zeroPad(minutes);
return formattedTime;
},
zeroPad : function(number) {
var s = number.toString();
var formattedNumber = (s.length > 1) ? s : "0" + s;
return formattedNumber;
}
First we create a function that will update the time for a single time zone,
given an index and an element from the clock list. To change the text of the
list-item element, we wrap the element with jQuery and then call the text()
function with the formatted time.
Chapter 2. Mobile Web • 24
report erratum  •  discuss

Just as with the tick() function before, we need to bind the function so this
points to the clock module.
The bound function is then executed for each item returned by $(".clock") or
each list item element where the class is clock.
Then we create a function, convertAndFormatDate(), for converting a date and offset
to a time for display. Keep in mind that time zones around the world are not
always offset from UTC by hours only, but sometimes by minutes as well. For
instance, Chennai, in India, is UTC + 5:30, and Kathmandu, in Nepal, is UTC
+ 5:45.
Now we have the code in place to map a list of saved time zone objects onto
a list of HTML list elements. Let’s build out a way for users to choose which
clocks they want to display.
Creating a Clock by Choosing a Time Zone
To allow users to add a new clock, we’ll give them a link to click. We’ll also
add a new unordered list to hold the time zones.
WebApp/web_02_02_add_clock/app/index.html
<body>
<a id="addClockLink">Add Clock</a>
<ul id="zoneList"></ul>
<ul id="clockList"></ul>
Then, to allow users to choose time zones, we’ll need to respond to user input.
This is a good opportunity to introduce a little better separation of concerns.
For instance, right now the time zone manager module deals with creating
clocks in the clock list. It would be better if we had a module to deal with the
view and user input so that the time zone manager could focus on time zones.
This new file, a view controller module, will manage the view and be initialized
from within main.js. Let’s look at the steps to initialize the view controller.
We declare some new variables, some pointing to the HTML elements in the
index page.
report erratum  •  discuss
Day 2: Making Time • 25

WebApp/web_02_02_add_clock/app/scripts/view_controller.js
var namespaces = $.app.namespaces,
clock = namespaces.models.Clock,
timeZoneManager = namespaces.managers.TimeZoneManager,
clockList = $("#clockList"),
zoneList = $("#zoneList"),
addClockLink = $("a#addClockLink");
Then, the initialize function does some important setup.
WebApp/web_02_02_add_clock/app/scripts/view_controller.js
initialize: function() {
this.openZoneListFunction = _.bind(this.addClockClicked, this);
this.closeZoneListFunction = _.bind(this.dismissZoneList, this);
addClockLink.click(this.openZoneListFunction);
zoneList.hide();
this.refreshClockList();
clock.start();
timeZoneManager.fetchTimeZones();
},
First we set some variables on the module pointing to bound versions of two
functions, addClockClicked() and dismissZoneList(). These functions will handle when
the Add Clock link is clicked and when the list of time zones is dismissed.
The addClockLink variable points to a jQuery element wrapping the anchor tag
we just added to the HTML. Here we use jQuery’s click() to set a click handler,
so addClockClicked() is called when the link is clicked.
We then hide the list of time zones with jQuery’s hide() function. Next we call
refreshClockList(), which will build a list of clocks for each saved time zone in the
time zone manager. Then we start the clock module ticking and fetch the list
of time zones from the API.
When the Add Clock link is clicked, we present a list of time zones for the
user to choose from. First we check to see if there are any children of the list.
If there aren’t, we assume they need to be created.
WebApp/web_02_02_add_clock/app/scripts/view_controller.js
addClockClicked : function() {
if (zoneList.children().length === 0) {
var zones = timeZoneManager.allZones();
clickHandler = _.bind(this.zoneClicked, this);
_.each(zones, function(zone, index) {
var item = $("<li class='zone'/>");
item.data("zoneIndex", index);
item.text(zone.name);
item.click(clickHandler);
zoneList.append(item);
Chapter 2. Mobile Web • 26
report erratum  •  discuss

});
}
this.presentZoneList();
},
To create the zone items, we create a bound function that points to zoneClicked().
Next we iterate through the list of all zones and create a list item for each
zone. The text of the item will be the name of the zone, the click handler will
be the bound function, and the item will be appended to the zone list.
The line where we call data() on the item uses a feature of jQuery that allows
us to store arbitrary data on an element. We’ll use this to store the index of
the zone in a key called zoneIndex. That way, when an item is clicked and the
click handler is fired, we’ll be able to get the index from the data of the clicked
item to know which time zone to add. Here’s the code for the click handler.
WebApp/web_02_02_add_clock/app/scripts/view_controller.js
zoneClicked : function(event) {
var item = $(event.currentTarget),
index = item.data("zoneIndex");
timeZoneManager.saveZoneAtIndex(index);
this.dismissZoneList();
this.refreshClockList();
},
First we grab the currentTarget of the incoming JavaScript click event and wrap
it using jQuery. This will be the list item. Then we grab the data from that
element, which tells us the associated zone index. We then tell the time zone
manager to save the zone at that index. Finally we dismiss the zone list and
refresh the list of clocks.
The code for saving time zones is rudimentary at this point, simply finding
the zone at the given index and adding it to the list of saved time zones.
WebApp/web_02_02_add_clock/app/scripts/time_zone_manager.js
saveZoneAtIndex : function(index) {
var zone = this.timeZones[index];
this.savedTimeZones.push(zone);
},
Later we’ll improve this code to store time zones in a more durable fashion,
but this will get us through today.
Now we have a system in place for users to add as many clocks as they’d like
to see in addition to the current time zone. Next let’s look at managing the
existing clock list.
report erratum  •  discuss
Day 2: Making Time • 27

Managing Clocks
Managing the clock list is pretty simple for this app: it’s just putting the clock
list into a mode that allows the user to remove clocks. We’ll do this by adding
an Edit button for the clock list, which, when clicked or tapped, will reveal a
Delete button on each clock.
Right now we have the HTML for each clock and time zone item hard-coded
into the JavaScript. This isn’t a great solution, especially as we start to make
the HTML more complex. So, before we add in the “edit clock list” functional-
ity, we’ll change to using a templating system instead of hard-coded HTML.
Using Templates for List Items
An HTML templating system is a library that can read in HTML with some
placeholders in it and then replace those with data, producing content with
the information we’d like the user to see. There are a few JavaScript HTML
templating libraries. We’ll use one called Mustache.
Mustache is a simple, easy-to-use JavaScript templating engine.
5 If you end
up using a lot of templates in your project, it’s best to include a build system
with a template preprocessor so that the templates aren’t being parsed from
text each time. For our app, we’ll just process each template as it’s needed.
The first step is to install Mustache. Using our old friend NPM from the app
directory, the install command is npm install mustache --save. Then we need to get
the HTML ready for a slightly more complex item view for clocks and time zones.
As in the following updated index.html, first we’ll change the time zone and clock
lists tags from ul to div. Unordered lists are fine, but a div containing divs is
slightly easier to style later. Next we make sure that mustache.js is included.
WebApp/web_02_03_better_labels_with_templates/app/index.html
<!DOCTYPE HTML>
<html>
<head></head>
<body>
<a id="addClockLink">Add Clock</a>
<div id="zoneList"></div>
<div id="clockList"></div>
<script src="node_modules/underscore/underscore.js"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/mustache/mustache.js"></script>
<script src="scripts/main.js"></script>
<script src="scripts/time_zone_manager.js"></script>
<script src="scripts/clock.js"></script>
5.
https://mustache.github.io
Chapter 2. Mobile Web • 28
report erratum  •  discuss

<script src="scripts/view_controller.js"></script>
<script id="clockTemplate" type="text/template">
<div class="clock">
<p class="clock-time">{{time}}</p>
<p class="clock-timezone">{{name}} ({{formatted_offset}})</p>
</div>
</script>
<script id="timeZoneTemplate" type="text/template">
<div class="timezone">
<p class="timezone-name">{{name}}</p>
<p class="timezone-offset"> (UTC {{formatted_offset}} hours) </p>
</div>
</script>
</body>
</html>
Finally, inside the script tags at the end, we create the templates for each clock
and time zone item. This will keep them easy to access and reference but
invisible to the user. Each item’s template is a div with some structured text
inside. Mustache’s variables are placed inside of double curly braces. These
will be replaced by the value from an object with those keys. We’ll pass the
object in to Mustache’s render(), and the output will be the rendered template.
Here is the updated code to refresh the clock list, using the clock template.
WebApp/web_02_03_better_labels_with_templates/app/scripts/view_controller.js
refreshClockList : function() {
var zones = timeZoneManager.savedZones(true),
template = $("#clockTemplate").text();
clockList.empty();
_.each(zones, function(zone, index) {
this.createClock(zone, index, template);
}, this);
clock.tick();
},
createClock : function(zone, index, template) {
var item = $(Mustache.render(template, zone));
clockList.append(item);
}
We use jQuery to wrap the script tag and then retrieve the text. This is the
template. Then in createClock() we combine the template and the time zone with
Mustache’s render() to get the element for that clock. This is a much better
solution, keeping view code out of the view controller.
report erratum  •  discuss
Day 2: Making Time • 29

Now let’s add the edit mode to the UI, allowing the user to remove clocks.
Editing the Clock List
The interaction when the user edits the clock list is as follows:
1.
The user clicks the Edit button.
2.
The button is relabeled Done.
3.
Each clock item reveals a delete link.
And the reverse should happen if the user clicks Done. Building on the tem-
plates we added, add a delete link to the clock template, as shown here.
WebApp/web_02_04_edit_delete_clock/app/index.html
<script id="clockTemplate" type="text/template">
<div class="clock">
<p class="clock-time">{{time}}</p>
<p class="clock-timezone">{{name}} ({{formatted_offset}})
<a class="delete-clock-link">[delete]</a></p>
</div>
</script>
The delete link will be bound and assigned like other click listeners in the
view controller. When the link is clicked, the view controller’s deleteClockClicked()
function will be called.
WebApp/web_02_04_edit_delete_clock/app/scripts/view_controller.js
deleteClockClicked : function(event) {
var clickedLink = $(event.currentTarget),
index = clickedLink.data("clockIndex"),
parentDiv = clickedLink.parents(".clock");
timeZoneManager.deleteZoneAtIndex(index);
parentDiv.remove();
}
This function grabs the index, stored on the clock element just like we did
with the time zone elements, and then gets a reference to the parent element
with the ID clock via jQuery. This should be the div that we need to remove
after deleting the clock. Next we delete the saved time zone at the index of
the clock, and finally we remove the div from the list of clocks, removing it
from the screen.
Now let’s look at how we put the clock list in edit mode. When the edit link
is clicked, the view controller’s presentEditMode() function is called.
Chapter 2. Mobile Web • 30
report erratum  •  discuss

WebApp/web_02_04_edit_delete_clock/app/scripts/view_controller.js
presentEditMode : function() {
$(".delete-clock-link").show();
editLink.text("Done");
editLink.off("click").
click(this.doneEditingFunction);
},
dismissEditMode : function() {
$(".delete-clock-link").hide();
editLink.text("Edit");
editLink.off("click").
click(this.editFunction);
},
This uses jQuery to find the delete links on the page, with $(".delete-clock-link").
This means “find every element on the page with the class delete-clock-link.”
Calling show() on the element list returned by that query makes the links visible.
Next we set the Edit button to say Done instead of Edit, and we remove the
previous click listener from that link using jQuery’s off() function. Finally we
add the doneEditingFunction as a click handler. This points to the dismissEditMode()
function, which does the reverse of presentEditMode().
Test these interactions in a browser. Add a few clocks, delete them, and so
on. Now we’ve got a web app that displays clocks from any of the time zones
the user wants to see. The functionality is basically in place and we have an
app to which we can start to add mobile functionality. Let’s call it a day!
What We Learned on Day 2
Today we focused mostly on getting the app working the way we want,
regardless of the kind of browser or device the app’s running in. We saw how
to respond to user actions and configure the view based on those actions. We
improved the architecture of the application by adding a view controller to
handle these interactions and configure the view. Then we improved the way
we deal with adding chunks of HTML to the lists by introducing a templating
solution.
Your Turn
Find
• Documentation on JavaScript’s lexical scope
• Mustache documentation
• Some other JavaScript templating solutions: How do they compare with
Mustache?
report erratum  •  discuss
Day 2: Making Time • 31

Do (Easier)
• Add an option for the user to show or hide the current time zone.
• If you worked on the 12-hour/24-hour option in yesterday’s code, update
the current code to do the same optional formatting. Then add some way
for the user to change this setting.
Do (Harder)
• For a harder challenge, building on the last two challenges, add a settings
screen with the two options listed above.
Day 3: Time to Move
Or, Making the Web App Mobile-Ready
Today we’ll make our web app ready for mobile. That means we’ll work out a
caching strategy for the data we get from the web, both JSON data and
application data. That way if we don’t have an Internet connection or the
connection isn’t great, we’ll still be able to use the app.
Then we’ll get the app ready to install on the user’s device. Finally we’ll apply
a grid-based, responsive style to the app so the user interface will work on
different screen sizes. Let’s start with caching data.
Caching Data for Offline Operation
To speed up perceived page load time, web browsers have had caching built
in almost since the beginning. Generally, this is something web developers
don’t have to think about, and the only control we have over this process is
via headers delivered from the server. The browser cache isn’t there for us to
use as a way to store local data.
Modern browsers have local data storage for cases where we want to apply
more logic to using locally cached data. This is useful for mobile web apps
because network connectivity and data usage are often issues on mobile
devices.
We’ll use two different kinds of local data storage in the app, web storage and
the application cache. We’ll start by saving clocks and storing time zones
loaded from the API in web storage, and then we’ll set up an application cache
for the app’s code.
Caching in Web Storage
We want to keep time zones locally in case the API is down or we have no
Internet on our mobile device. We often talk about offline use cases when
Chapter 2. Mobile Web • 32
report erratum  •  discuss

building mobile apps, but it’s really the same situation whether our server is
down or we can’t get an Internet connection to get to the server.
We have to be careful and think through how caching data locally works for
our app. Caching, specifically cache invalidation, is often given as a hard
programming problem, probably because it’s easy to implement a naive
solution.
Again, the solution for your app may be different from that for another app.
Let’s look at two implementations of local data storage for the time zone list.
Approach One: Trust the Local Cache
First, here’s a naive approach to caching the time zones. If we have cached
data, we use that; otherwise we load from the API.
WebApp/web_03_01_local_all_zone_storage_01/app/scripts/time_zone_manager.js
initialize : function() {
var localZones = localStorage.allTimeZones;
if (localZones) {
this.zonesLoaded(JSON.parse(localZones));
} else {
this.fetchTimeZones(function(zones) {
localStorage.allTimeZones = JSON.stringify(zones);
});
}
},
fetchTimeZones : function(completion) {
var successFunction = _.bind(function(data) {
this.zonesLoaded(data);
if (completion) completion(data);
}, this);
$.ajax({
url
: "http://localhost:3000/clock/time_zones",
headers : { Accept: "application/json" },
success : successFunction
});
},
In initialize(), we’ll pull time zones out of local storage. That’s all there is to it,
referencing localStorage. Note that this code somewhat naively expects the
browser to be modern and have web storage implemented. You may want to
check to see if localStorage is available first in a production-ready app.
If we find some time zones stored locally, we should parse them into JSON
and send them to the zonesLoaded() callback. Not all browsers allow web storage
to hold JavaScript objects, so to be safe store the time zones as a string.
report erratum  •  discuss
Day 3: Time to Move • 33

If there are no local zones, we bind up a completion function to pass to the
fetch function. It will be executed when the fetch is complete. Again, we store
the time zones as a string to be safe. JSON.stringify(), used in the code, is the
opposite of JSON.parse().
In fetchTimeZones(), inside the success function passed to ajax, we call the call-
back zonesLoaded(), which is the next point in the code whether we find zones
locally or load them from the API.
This approach to using the cache expects that the data stored locally is just
as good as the data from the API. That approach will work as long as data
never changes.
In our case, we depend on the server to correctly set the time zone offsets.
This doesn’t handle different time zone periods well, so it won’t keep the clocks
correct if, for instance, Daylight Saving Time comes into effect. A more robust
system would take care of that, but for now we rely on having the latest data
from the server. Let’s look at some small changes to our caching approach.
Approach Two: Trust the API
We want to change our approach to use locally cached time zones only if we
can’t get time zones from the server. Here’s the new version of the time zone
manager’s initialize().
WebApp/web_03_02_local_all_zone_storage_02/app/scripts/time_zone_manager.js
initialize : function() {
if (!navigator.onLine) {
this.loadLocalTimeZones();
} else {
var completion = _.bind(function(zones) {
this.storeTimeZonesLocally(zones);
}, this);
this.fetchTimeZones(completion);
}
},
This uses the navigator.onLine indicator to see if the browser has an Internet
connection. This indicator is available on modern browsers. If we’re not online,
we try to load time zones from the local cache; otherwise we load from the
server.
We also need to make sure we get data from the server. If we don’t for any
reason, we also try to load time zones locally, as shown here.
Chapter 2. Mobile Web • 34
report erratum  •  discuss

WebApp/web_03_02_local_all_zone_storage_02/app/scripts/time_zone_manager.js
fetchTimeZones : function(completion) {
var successFunction = _.bind(function(data) {
this.zonesLoaded(data);
if (completion) completion(data);
}, this);
var errorFunction = _.bind(function() {
this.loadLocalTimeZones();
}, this);
$.ajax({
url
: "http://localhost:3000/clock/time_zones",
headers : { Accept: "application/json" },
success : successFunction,
error
: errorFunction
});
},
loadLocalTimeZones : function() {
var localZones = localStorage.allTimeZones;
if (localZones) {
this.zonesLoaded(JSON.parse(localZones));
} else {
// Inform user that no timezone data is available
}
},
storeTimeZonesLocally : function(zones) {
localStorage.allTimeZones = JSON.stringify(zones);
},
zonesLoaded : function(zones) {
this.timeZones = zones;
},
The success function is the same as before, but now we’ve added an error
function, which will be called if $.ajax has any problem loading the data from the
API. The loadLocalTimeZones() function contains all the logic to load from local cache.
In the case that we have no data stored locally and aren’t able to get data
from the API, the best we can do is somehow inform users that they can’t
create any new clocks.
If we get new data from the API, we’ll store it into local cache in storeTimeZones-
Locally(), stringifying it first.
No matter how it happens, if we do get a list of time zones, zonesLoaded() will
store them in the timeZones module variable.
report erratum  •  discuss
Day 3: Time to Move • 35

That takes care of storing time zones in case we find our app without access
to the data from the server for whatever reason. Let’s take a look at storing the
user’s clocks locally so that they’re available when they come back to the app.
Saving Clocks Locally
Our app will store the user’s selected clocks locally. This is nice for two reasons.
First, we don’t need to make users log in to use the app and then implement
user account management on the server side, and second—no matter if they’re
online or not—users will always have access to the clocks they’ve created.
To make this change, on initialization the time zone manager needs to load
the list of saved time zones, the user’s clocks, from web storage. Saving also
needs some modifications.
WebApp/web_03_03_local_saved_zone_storage/app/scripts/time_zone_manager.js
saveZoneAtIndex : function(index) {
var zone = this.timeZones[index];
this.savedTimeZones.push(zone);
this.storeSavedTimeZonesLocally();
},
deleteZoneAtIndex : function(index) {
this.savedTimeZones.splice(index, 1);
this.storeSavedTimeZonesLocally();
},
storeSavedTimeZonesLocally : function() {
localStorage.savedTimeZones = JSON.stringify(this.savedTimeZones);
},
When we modify the saved time zone list, make sure to call storeSavedTimeZones-
Locally(), which will serialize and store the data structure into web storage.
Now we have a system in place for storing the application’s data locally. Next
we’ll cover how we go about storing the application code locally, making the
app fully offline capable.
Caching Code in the Application Cache
Modern web browsers have the ability to store a web app’s code locally, in
the application cache. The code is any HTML, JavaScript, CSS, images, or
other files that make up a web application, subject to the limits of the
browser’s application cache size. The app cache is useful for providing an
offline-capable web app or simply for a faster-loading app with more developer
control than we get from the browser’s cache.
To cache an application, we must provide a cache manifest. The browser will
use this file to determine what should be cached and then start downloading
Chapter 2. Mobile Web • 36
report erratum  •  discuss

the files from the manifest. We’re able to subscribe to progress events for this
initial caching process. If any download operations for these files fail, the
cache operation fails and the app won’t be available from cache until a cache
operation completes successfully.
Once an application is cached, by default the browser will only check to see
if the manifest has changed on the server. If it hasn’t, the app will be served
from cache. If the manifest has changed, then the new resources will be
downloaded and cached. Let’s add a cache manifest to our app now.
Creating an App Manifest
The signal to a browser that our app uses the application cache, or app cache
for short, is an attribute in the html tag in the root document.
WebApp/web_03_04_application_cache/app/index.html
<!DOCTYPE HTML>
<html manifest="/manifest.appcache">
<head></head>
The file itself is a structured text document. The file must begin with the line
CACHE MANIFEST and can contain zero or more sections from NETWORK, CACHE, and
FALLBACK. If there are no sections, the manifest should contain a list of newline-
delimited files to cache.
If there are any sections, the file list goes under the ‘CACHE‘ header. The
‘NETWORK‘ section, if necessary, contains a whitelist of network resources the
app can access, or the wildcard, ‘*‘, to allow access to anything. The ‘FALLBACK‘
section, if applicable, should list a locally cached file to serve in case the app
is offline. This can be a page with limited functionality or a page with a message
that our app doesn’t work offline. Here is the cache manifest for our app.
WebApp/web_03_04_application_cache/app/manifest.appcache
CACHE MANIFEST
NETWORK:
*
CACHE:
/node_modules/underscore/underscore-min.js
/node_modules/underscore/underscore-min.map
/node_modules/jquery/dist/jquery.min.js
/node_modules/jquery/dist/jquery.min.map
/node_modules/mustache/mustache.min.js
/scripts/main.js
/scripts/time_zone_manager.js
/scripts/clock.js
/scripts/view_controller.js
report erratum  •  discuss
Day 3: Time to Move • 37

Notice that we allow any network access in the network section, and we don’t
use the fallback section.
It may be obvious, but the files, such as JavaScript files, listed in the cache
need to be the same ones referenced from the HTML. It’s probably worth it
to look into implementing an automated system for generating the manifest
file and ensuring that the correct script files are referenced for the correct
environment—debuggable scripts for development and minified scripts for
production.
We need to implement one more requirement for the manifest file. The file
must be served with the MIME type of text/cache-manifest. Let’s look at one way
of doing that.
Serving the App Manifest
If this app were served from a production web server, the server would have
to be configured to always serve the manifest file with the correct MIME type.
If we’re just running the app from the local filesystem as we’ve been doing so
far, the app cache won’t work.
I’ve provided a solution in the source code to serve the app through a Sinatra
server.
6 Sinatra is a very lightweight Ruby web application server.
Installing Sinatra
The source code bundle has a Gem file that specifies Sinatra as a dependency.
WebApp/web_03_04_application_cache/Gemfile
source 'https://rubygems.org'
gem 'sinatra'
To install Sinatra using Bundler,
7 go to the root of the source code and execute
the command bundle install. If you’d rather not use Bundler, just install Sinatra
by executing gem install sinatra.
Sinatra will run from a file in the root of the web app directory, called app.rb.
To run Sinatra, execute ruby app.rb. The app should be available at the default
address http://localhost:4567.
The Sinatra application is pretty simple, just enough to serve the manifest
with the correct MIME type.
WebApp/web_03_04_application_cache/app.rb
require 'sinatra'
6.
http://sinatrarb.com
7.
http://bundler.io
Chapter 2. Mobile Web • 38
report erratum  •  discuss

set :public_folder, File.dirname(__FILE__) + '/app'
get "/" do
send_file "app/index.html"
end
get "/manifest.appcache" do
send_file "app/manifest.appcache", :type => "text/cache-manifest"
end
First, we tell Sinatra that static files should be served from the /app directory
by setting the :public_folder. Next, we specify that going to the root of the site
should serve up app/index.html. Finally, we tell Sinatra that a request to /mani-
fest.appcache should serve that file but with the MIME type of text/cache-manifest.
From now on, when we want to test caching or serve the app from cache, we’ll
need to go to the local Sinatra address instead of the filesystem.
Testing the Manifest Caching
Testing caching can get to be tedious. It can be frustrating to continually
reload the browser looking for edits you just made, only to realize the files
are coming from cache instead of picking up your changes. Luckily, browsers
with app caches generally provide developer tools to inspect the cache and
do useful things like turn the cache off for development.
For instance, here’s the console log from the first run of our app through
Chrome, showing the caching process as it happens, telling us it’s working.
Creating Application Cache with manifest http://localhost:4567/manifest.appcache
Application Cache Checking event
Application Cache Downloading event
Application Cache Progress event (0 of 9) /scripts/clock.js
Application Cache Progress event (1 of 9) /scripts/time_zone_manager.js
Application Cache Progress event (2 of 9) /scripts/main.js
Application Cache Progress event (3 of 9) /components/jquery/dist/jquery.min.map
Application Cache Progress event (4 of 9) /components/underscore/underscore-min.js
Application Cache Progress event (5 of 9) /components/mustache/mustache.min.js
Application Cache Progress event (6 of 9) /components/underscore/underscore-min.map
Application Cache Progress event (7 of 9) /scripts/view_controller.js
Application Cache Progress event (8 of 9) /components/jquery/dist/jquery.min.js
Application Cache Progress event (9 of 9)
Application Cache Cached event
report erratum  •  discuss
Day 3: Time to Move • 39

On subsequent loads, Chrome lets us know that nothing changed in the
manifest, and so the app is served fully from cache:
Adding master entry to Application Cache with manifest
http://localhost:4567/manifest.appcache
index.html:1 Application Cache NoUpdate event
Getting familiar with the developer tools on all of the browsers is essential
when working with cached data.
Now that we have an application cache and local data storage in place, our
app will load more quickly and survive more network problems, making it
better for mobile use cases. Next let’s look at the final pieces—serving the app
from our mobile device’s home screen and applying a responsive design.
Making the App a Mobile App
To make the web app look and work more like a native app, we need to add
an app icon and then apply a responsive design. First let’s add the icon.
Loading the App Like a Native App
You may already be familiar with the ability to save a web page to your home
screen on your mobile phone. As web app developers we have some control
to be able to make the web apps loaded in this way work more like native
apps, at least in the launch experience.
WebApp/web_03_05_favico/app/index.html
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/images/favicon.png">
<title>World Clock</title>
</head>
First, we set the viewport to the device width and set the initial scale to 1.
This will make the page load to sensible dimensions for viewing on a mobile-
size screen. Then we add a favicon (the icon that web browsers use to identify
a website) and an apple-touch-icon.
When the iPhone added the capability to add web locations to the home screen,
it looked for the apple-touch-icon to place on the home screen instead of the fav-
icon. Android, too, follows this convention. It’s also important to have a title
that is suitable for the name of the web app on the home screen.
With those things in place, saving the app to the device’s home screen will
look like the figure on page 41 on the iOS simulator running locally.
Chapter 2. Mobile Web • 40
report erratum  •  discuss

Don’t forget as you add more resources to the
web app to update the manifest file, or things
may seem like they work until the first time the
app is offline.
Now let’s look at how we can apply a responsive
design to the app, which will make the UI
behave appropriately on different screen sizes.
Making the App Responsive
A responsive web app is one that configures
itself to best match the characteristics and
capabilities of the device on which it’s running.
There are a lot of things to consider when
making a web app responsive. We’re going to
focus on only one aspect: UI configuration
based on screen size. We’ll do this using CSS
and media queries. Media queries are a system
modern browsers have for determining the
characteristics of the user’s device. Using them,
we can determine the width of the window our app is running in and configure
the UI to best work within that size. That means that even on a desktop
browser, if the width is small the UI will look the same as on a mobile phone.
We could write our own CSS to make a system for accomplishing this sizing.
But there are already libraries available that provide a grid system. A grid
system is simply a set of media queries and styles ready-made for configuring
elements of the UI based on available width. The available width can be broken
down into one or more columns in which to place elements. The columns
resize and reposition themselves based on the available width.
For our app, we’ll use a very simple grid system called Skeleton.
8 Skeleton is
great for our purposes because it doesn’t come with lots of other utilities that
we don’t need for this simple an app.
To apply a grid to our app, let’s first get Skeleton installed with NPM.
Installing Skeleton
Skeleton can be installed via NPM by executing npm install skeleton-css --save from
the app. Note that the NPM module version of Skeleton seems to be maintained
8.
http://getskeleton.com
report erratum  •  discuss
Day 3: Time to Move • 41

from a different GitHub repository than the official version, but it seems to
have tracked the official repository.
The Skeleton module doesn’t have any JavaScript files; it’s a set of CSS
resources. Let’s include them in the index file.
WebApp/web_03_06_responsive_design/app/index.html
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="//fonts.googleapis.com/css?family=Raleway:400,300,600"
rel="stylesheet" type="text/css">
<link rel="stylesheet" href="node_modules/skeleton-css/css/normalize.css">
<link rel="stylesheet" href="node_modules/skeleton-css/css/skeleton.css">
<link rel="stylesheet" href="styles/styles.css">
<link rel="icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/images/favicon.png">
<title>World Clock</title>
</head>
Skeleton uses a free web font called Raleway, provided by Google. The first
link in the code snippet makes that font available.
Next, before we reference any other style sheets, we need to include normalize.css,
which performs some resetting of CSS as a baseline before the Skeleton CSS
is applied. Then we apply the Skeleton CSS. And finally, in styles/styles.css, we
add additional styles to further configure elements based on available width.
Remember that every time you include new resources in the project, you have
to update the manifest file, or they won’t be cached or available offline. Now,
with the Skeleton style sheets included, we’re ready to start putting elements
into the grid system.
Applying Skeleton’s Grid System
Let’s think about what might make sense for our UI at different screen widths.
Right now our app consists of two links and two lists side-by-side. We can
think of these elements as fitting into two columns in a grid.
The simple solution to dealing with different-size screens is to have two
columns when there’s enough width, and if there’s not enough, to collapse
to one column, stacking the lists on top of each other.
Stacking the time zone list above the clock list at small widths makes the
most sense here, since the time zone list is hidden most of the time and is
the likely focus of the users’ attention when it’s not hidden.
Let’s take a look at the changes to accomplish this using styles Skeleton
provides.
Chapter 2. Mobile Web • 42
report erratum  •  discuss

WebApp/web_03_06_responsive_design/app/index.html
<div class="container">
<h1>World Clock</h1>
<a class="button button-secondary" id="editLink">Edit</a>
<a class="button button-secondary u-pull-right" id="addClockLink">Add Clock</a>
<div class="row">
<div id="zoneList" class="one-half column u-pull-right"></div>
<div id="clockList" class="one-half column"></div>
</div>
</div>
Skeleton applies its grid system to any divs that have the container class, so we
need to move our UI into this div. Skeleton also keeps this container at a
maximum width of 960 pixels.
Skeleton has some ready-made styles for UI elements such as buttons. We
next apply the button-secondary class to the edit link so it looks like a button
instead of a link.
We apply the button style to the add-clock button too. In addition, we apply
one of Skeleton’s “utility classes,” u-pull-right. This will keep the button right-
aligned inside the container.
To add a row to the grid, we add a div with the row class. Child divs with certain
styles will become the columns. To make the zone list one-half of a two-column
grid, we apply the styles one-half and column.
To place the zone list above the clock list when the screen is narrow, we need
to place the div in the first child position. Then, to make it stay on the right
of the screen when the screen is wide, we apply the u-pull-right style. Finally we
apply the styles one-half and column to the clock list as well.
Now we have a grid system in place that will configure the UI in a sensible
way, given the width of the screen it has to work with. Test it out by resizing
your browser window and interacting with the zone list at different widths.
So far we’ve relied fully on Skeleton to do the heavy lifting via CSS. It would
be a good exercise to dig into the Skeleton style sheets to investigate further
how these styles work. However, we’ll do a bit more work on our own style
sheet that will apply different styles to elements at various screen widths, so
the clock and time zone element text will be at reasonable relative sizes.
Applying Different Screen Styles
To style elements differently for different screen sizes, we’ll use the same CSS
functionality Skeleton uses to build its grid system. We’re also going to use
the same breakpoints that Skeleton does. The breakpoints are the screen
report erratum  •  discuss
Day 3: Time to Move • 43

widths at which the grid system changes from one device class to another.
Here is a list of the size classes and breakpoints Skeleton uses.
Mobile
399px and below
Larger than mobile
400px
Larger than phablet
550px
Larger than tablet
750px
Larger than desktop
1000px
Larger than desktop HD
1200px and above
The order illustrates an important point—Skeleton uses a mobile-first strategy.
This means that it first defines all the styles that apply to mobile-size screens.
Then it uses media queries to define styles for each of the larger size classes.
A non–mobile-first strategy would define all the desktop styles and then use
media queries to define mobile-specific styles.
The advantage of the mobile-first approach is that mobile devices, where we
most want to optimize performance, need to apply styles only once. Mobile
browsers don’t go through the process of applying styles for larger screens
first and then spend extra effort reapplying mobile styles.
We want to follow the same approach in our app. Here are all of the classes
we’ve applied to elements in the clock and time zone list items:
WebApp/web_03_06_responsive_design/app/styles/styles.css
/* Mobile first classes */
/* Clock */
.clock {
margin-top:
-0.5em;
margin-bottom:
-0.5em;
}
.clock-time {
font-size:
2.2em;
font-weight:
bold;
margin-bottom:
-0.2em;
}
.clock-timezone {
color:
#888888;
}
/* Timezones */
.timezone {
padding-left:
2em;
}
Chapter 2. Mobile Web • 44
report erratum  •  discuss

.timezone-name {
font-weight:
bold;
margin-top:
0em;
margin-bottom:
0em;
}
.timezone-offset {
color:
#888888;
}
This is a reasonable set of font sizes and treatments for the app on a mobile-
size screen. In this figure you can see the iOS Simulator running the website.
In this figure the time zone list is visible, positioned over the clock list.
report erratum  •  discuss
Day 3: Time to Move • 45

Now, to increase the font sizes and other styles appropriately for larger screens,
we add or change styles at each of the breakpoints we care about.
WebApp/web_03_06_responsive_design/app/styles/styles.css
/* Larger than mobile */
@media (min-width: 400px) {
.clock-time {
font-size: 2.2em;
}
}
/* Larger than phablet */
@media (min-width: 550px) {
.clock-time {
font-size: 2.8em;
}
.clock-timezone {
font-size: 1.2em;
}
}
Those styles will produce a more appropriate result at larger screen sizes, as
shown in the following figure, on a desktop browser.
Chapter 2. Mobile Web • 46
report erratum  •  discuss

In this figure, the time zone list is visible, pulled to the right of the clock list.
Now we have a web app that uses a responsive, mobile-first grid system to
apply styling and positioning to the page elements appropriate to the size of
the browser.
What We Learned on Day 3
Today we really dug into some of the mobile-optimized capabilities web-based
apps have. We built in web storage to cache API data locally in case we’re
offline. Then we added an application cache to speed up the app’s load time
on subsequent loads and give it the ability to operate offline.
We then used Skeleton to apply a grid-based responsive design, so the app
works well and looks right on all screen sizes. We did this using a mobile-first
strategy.
Your Turn
Find
• Skeleton documentation
• Other grid systems, such as Bootstrap.js
report erratum  •  discuss
Day 3: Time to Move • 47

Do (Easier)
• You may have noticed that the web font in the Skeleton style sheets is
not in the manifest. There is a fallback font list in place, but it’d be nice
if we could expect the same font whether online or offline. Pick and use
a web font, download it, and declare it in the manifest. Then change the
style of the app to use this font.
• Serve the web app from a server to your mobile device. Test the offline
capability.
Do (Harder)
• Add a way to reorder clocks. You can use a third-party library or build
your own system. Be sure to save the order of the clocks in local storage
as well, so the order persists across sessions.
• Research and implement a system, using something like Grunt,
9 to gen-
erate the cache manifest and assemble the resources into a form suitable
for deployment to a server.
Wrapping Up the Web App
Whether or not your business needs a native mobile application, it’s important
to your users that your website works well on mobile devices and in the con-
texts where mobile users find themselves. Two important differences between
desktop and mobile web use are network connectivity and screen size, and
we focused on solving for these cases in building the web app this week.
Strengths
One of the obvious benefits of building your website mobile-first is the ability
to reuse a lot of code and functionality. It’s compelling to be able to enhance
your website to the point that it’s as usable and good-looking as a native app.
As mobile-device capabilities grow, the browser makers and web-standards
people seem to be doing a reasonable job of adding corresponding capabilities
to mobile browsers. Depending on your users’ needs, it may be possible to
build a fully functional app using only web technologies.
Weaknesses
However, as your app’s complex functionality grows, at some point there’s no
longer a way for a web app to keep up with a native app. Performance of a
9.
http://gruntjs.com
Chapter 2. Mobile Web • 48
report erratum  •  discuss

native app will always be better, rendering times will be quicker, and system-
resource access and control will be more powerful.
Final Thoughts on Web Apps
This week we focused on two mobile use cases, offline use and configuration
for small screens. There are lots of other capabilities to explore, such as
camera access and location-based capabilities. Dig into these and challenge
yourself to see how far you can take your idea using purely web capabilities.
And don’t forget: even if your app is best built with native technologies, don’t
leave your website users neglected.
report erratum  •  discuss
Wrapping Up the Web App • 49

CHAPTER 3
iOS
I remember when I watched the announcement for the first iPhone, back in
the day. I looked down at my Razr, which to me had been the pinnacle of
technological coolness and now suddenly looked like a cheap toy, studded
with inexplicable bumps and lines. Its screen now looked like a grocery-store
credit-card machine, each huge, blocky pixel an abomination to behold. I
would never be able to enjoy a game of Snake again.
The iPhone and iOS changed the game for mobile development. When the
app store opened up for developers like us, even though things like app stores
had already existed on other platforms, in most people’s minds app develop-
ment started at year zero.
iOS is still one of the Big Two. Even if you find something you like about some
of the third-party app-development solutions elsewhere in this book, you’ll
most likely still be deploying your apps to iOS. Therefore, it’s important to
understand the platform.
Starting with the iPhone, continuing with the iPad, through the “flat” design
of iOS 7, different-size iPhones, and now a new language, iOS has had to
adapt and grow over the years. We’ll touch on all of these factors while we
build this week’s app. We’ll explore iOS development with Swift, make the
app work on multiple devices, and keep a focus on what modern mobile
developers most often need to focus on: getting data from a remote service,
making that data contextually relevant to the user, and displaying that data
on different devices with different screens.
report erratum  •  discuss

A Weather-Forecast App
This week we’ll build a weather app. It will allow users to get the current
weather conditions and forecast for their current location, determined by the
device’s location system. We’ll also let users search for weather at another
location by putting in the name of somewhere in the world.
To do this we’ll use the API’s /weather endpoint, which is able to take a string
description of a location, like a city name or a zip code, and return the current
conditions and forecast. On Day 2 we’ll build a search UI, but for Day 1 we’ll
use the iOS location manager to get the device’s current latitude and longitude
and then reverse-geocode those coordinates to an address. We’ll then use
that address to load the weather.
Along the way we’ll see how iOS UIs are built, how to work with the framework
classes in UIKit, Apple’s SDK for building mobile apps, and how to use Swift,
Apple’s new language, to write the logic. Let’s get started!
Day 1: What’s It Like Out?
Or, Loading Weather Data from the API
Today we’ll use Xcode to create a new iOS project. We’ll dive into writing the
code to access the API first, logging the result. Then we’ll build a UI to show
the current temperature and location.
Chapter 3. iOS • 52
report erratum  •  discuss

Creating a Project
To get started, open Xcode and choose to create a new project. Choose iOS >
Application > Single View Application. Name it Weather and give it an organi-
zation identifier of your big-endian DNS name, in the form of com.yourorg.
The language should be Swift, it should be a Universal project, and you can
either include or exclude unit and UI tests. We won’t do any development on
tests, but you may want to look at them. We won’t need Core Data, so you
can leave that selection unchecked.
When the project is created, you should see
the project navigator on the left side of the
app with a view of the generated files and
folders.
Open AppDelegate.swift, which is the app’s main
entry point to our code, and let’s get started
loading data from the API.
Loading Data from the API
The generated app delegate has one method,
called in Swift’s convention, application(_:didFinish-
LaunchingWithOptions:). By default it returns true.
iOS/ios_01_01_new_project/Weather/AppDelegate.swift
import UIKit
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
var window: UIWindow?
func application(
application: UIApplication,
didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?
) -> Bool {
return true
}
}
Above this return statement, add some code to call the weather API. Create
an NSURL with the path to the weather endpoint, including a hard-coded city.
iOS/ios_01_02_getting_data_in_app_delegate/Weather/AppDelegate.swift
let url = NSURL(string:
"http://localhost:3000/weather/location.json?name=Arvada,CO"
)
report erratum  •  discuss
Day 1: What’s It Like Out? • 53

Next, we need to get a reference to a shared NSURLSession, create an NSURLSession-
DataTask by calling dataTaskWithURL(), and then call resume() on that task.
iOS/ios_01_02_getting_data_in_app_delegate/Weather/AppDelegate.swift
let session = NSURLSession.sharedSession()
let task = session.dataTaskWithURL(
url!,
completionHandler: {(data, response, error) in
if (data != nil) {
let json: NSDictionary?
do { json = try
NSJSONSerialization.JSONObjectWithData(
data!,
options: NSJSONReadingOptions()
) as? NSDictionary
print("Weather JSON Data: \(json)")
➤
} catch let e {
print("Error retrieving weather data: \(e)")
}
}
})
task.resume()
The task takes the NSURL and a completion handler, which receives three
arguments as a result of making an HTTP call to the URL: the raw data, a
response object, and an error. All of these parameters are optional, which
means they may be nil. This is an important distinction in Swift, which is very
explicit about when variables can be nil and when they must have a value.
In the completion handler we first check to see if the data argument is nil,
and if not we define an optional NSDictionary to hold the results of deserializing
the JSON data. The deserialization is done with NSJSONSerialization.JSONObjectWith-
Data(_:options:). If the deserialization is successful, we log the string of JSON to
the console using print, and if not we log the error that we caught.
This code is ready to run and test, but we need to take one extra step before
we run the app. Since iOS 9.0, there’s been a requirement that by default all
HTTP network calls be secure. We need to add localhost to a whitelist so we
can call the local API.
Open the file called Info.plist from the project navigator. The contents are pre-
sented as a tree of keys and values. Add a new item to the end of the list and
type App Transport Security Settings. Add an item under that with the contents
Exception Domains, which has a child, localhost. The localhost entry should
have a Boolean child with the key of NSExceptionAllowsInsecureHTTPLoads
and a value of YES. The following figure is an example of what that looks like
in the editor.
Chapter 3. iOS • 54
report erratum  •  discuss

With localhost whitelisted, we can run the app. Make sure the API server is
running, and then press the play button at the top of the Xcode window. A
debug console should open at the bottom of Xcode and display the log message
we just added with the deserialized weather data.
2015-02-01 16:56:07.315 WeatherApp[4975:863999] Weather JSON Data: {
"current_conditions" = "Partly Cloudy";
date = "Sun, 01 Feb 2015 3:54 pm MST";
forecasts =
(
...
That’s the result of a round-trip to the server. Now that we can get the data,
let’s work on building a UI to display it.
Displaying the Weather
The weather information we want to display to the user for a given location
is the temperature, the weather location detail and timestamp information,
and a list of forecast data. Each of these is reflected in the data coming back
from the API, which we converted into native data structures in a previous
section.
Now we’ll build a very simple, utilitarian view to display this data, starting
with the temperature and location detail.
Building the View
In Xcode, open Main.storyboard and you should see a storyboard, which is Apple’s
UI design file format. The storyboard is opened in Xcode’s visual UI editor,
called Interface Builder.
The view represented in the visual editor is called a scene, and it’s managed
by a view controller. Let’s start building the view by adding some labels.
First, we need to add two labels to display the temperature and the weather
details. With the main storyboard open, look at the list of controls at the
bottom of the Utilities panel. One of these is a label, or a UI element that
simply displays text. Drag a label to the top center of the view until two blue
lines appear to indicate that the label is vertically and horizontally centered.
Have a look at the figure on page 56 to orient yourself.
report erratum  •  discuss
Day 1: What’s It Like Out? • 55

This label will show the weather location detail information. Once that’s
positioned, drag another label underneath that for the current temperature.
Just give it a little space under the first label. Now let’s tweak some things
about the labels.
Sizing the Labels
Select the bottom label, which we’ll use to display temperature, and go to the
Utilities panel. Select the fourth tab icon from the left, which is for the attribute
inspector.
This is where you can change attributes about the selected item in the view.
Here you should change the label’s label text to be 000ºF so we can get an
idea of the longest text we expect to see in here. By the way, typing E0 will
produce a degree symbol on the Mac.
Next, bump the font size up a lot,
to 128, and make sure the align-
ment is centered. In this design,
the temperature is the most
important piece of data on the
screen. It should look something
like it does in this figure.
Set the label text for the weather
location text field to Location. I like
Chapter 3. iOS • 56
report erratum  •  discuss

to use the label text to help keep track of what the labels are for, even if I
don’t expect to see that actual text in the app. Now we’ll configure Auto Layout
for these elements to control how they’re placed in the view.
Introducing Auto Layout
Auto Layout is a flexible constraint-based layout system for iOS. Auto Layout
helps you define a flexible view by defining constraints, which tell the system
how to lay out view elements in relation to other elements and to the screen
itself, as well as provide other variable device-specific information.
Starting at the top, select the location label, hold down C and drag the mouse a
few pixels above the label. The direction you drag your mouse matters, and going
up versus down will give you a menu with different options. Let go of the mouse
button, and you should see a pop-up menu like the one in this figure.
Select the first option, Vertical Spacing to Top Layout Guide. This will create
a constraint telling Auto Layout that the top of the label should be positioned
relative to the top of the screen, the top layout guide.
Xcode automatically populates the
constraint’s constant with the label’s
current distance from the top. You can
also see an item in the document outline
called Constraints, under the view. If
you twirl that menu item down, you
should see one constraint. Select that,
and you see an editor in the Utilities
panel that looks like this figure.
You can see that the distance between
the top and the label was 42 when I
did this. So this means Auto Layout will attempt to keep this label 42 points
(a pixel density–independent unit) from the top of the screen. Edit yours to
be 42 also.
Now that we’ve defined a Y position for the label, we need an X position.
C-drag again from your location to the top and let the mouse go. You’ll see
report erratum  •  discuss
Day 1: What’s It Like Out? • 57

the pop-up menu again. This time choose Center Horizontally in Container,
and Xcode will automatically create an Align Center X to: Superview constraint.
Next, we’ll deal with the temperature label. C-drag from the temperature label
to the location label and choose Vertical Spacing. This will create a Top Space
to: Location constraint with the constant set to the current distance between
the two labels. Finally, create a constraint to center the temperature label
vertically. If you select the location label and go to the size inspector in the
Utilities panel, the one that looks like a ruler, you should see the list of con-
straints for the selected UI element.
Invariably, after setting up a few constraints like we’ve just done, Xcode starts
to complain a bit with some warnings. I don’t know why this is the default
behavior, but here’s how to fix it. In the document outline, notice the yellow
arrow next to the scene. Click this arrow, and the document outline will pan
over to reveal a new view full of Auto Layout warnings and errors. In my case
it looked like this figure.
It’s saying that, based on constraints, the location label is positioned differ-
ently than expected in Interface Builder. I clicked the yellow triangle and was
presented with a list of possible solutions. This pane will give you some options
to fix any problems caused when editing Auto Layout settings. In this case,
we just need the Interface Builder view to look like the constraints, so
choosing Update Frame tells Interface Builder to move UI elements to match
the Auto Layout constraints. This doesn’t affect runtime layout at all.
OK, now we’ve got our view laid out. We can run the app
in the simulator and verify that everything we just did is
now on the screen, as in this figure.
The next step is to get some of the data into these labels.
Chapter 3. iOS • 58
report erratum  •  discuss

Wiring Up the View to the View Controller
With the interface defined enough to add data, now we need to connect the
UI to the view controller to allow the code to control the view. First let’s rename
the generated ViewController to a better name and connect the view controller
to the storyboard’s UI.
Renaming the View Controller
The generated view controller file name doesn’t really tell us what it does, so
follow these steps to rename it.
• Change the filename from ViewController.swift to WeatherViewController.swift. It’s
not a Swift requirement that the class be named the same as the file, but
this will make it clear to everyone what’s in the file. To rename the file,
select ViewController.swift in the project navigator, wait a second or two, and
then click it again. The filename should change to be editable.
• Change the class name to WeatherViewController.
• Change the storyboard’s view controller custom class to WeatherViewController.
Do this in the Identity Inspector pane, in the interface pictured in the
following figure.
With the view controller named something that makes sense, let’s connect
the controller to the UI.
Connecting the View Controller to the UI
With the storyboard open, either click the icon in Xcode’s top right that looks
like two intersecting circles, or press DE Return. A second view should open
to the right of the storyboard. This is called the companion editor, and ideally
it should open with a file related to the one you have open in the main editor
(but this may not be the case).
We want the WeatherViewController open in the companion editor. If it isn’t, use
the controls at the top of the companion editor to find that file.
report erratum  •  discuss
Day 1: What’s It Like Out? • 59

Now, as you can see in action in the preceding figure, C-drag from the location
label to the space in the WeatherViewController above viewDidLoad(). A dialog like
the one in the following figure should appear.
This is called an outlet. It’s defining an association from an element in the
view to a variable in the view controller that will be “wired up” at runtime.
Make the name locationLabel and click the Connect button. Then do the same
gesture to wire up the temperature label, calling it temperatureLabel.
Now you should have code like this in the view controller:
iOS/ios_01_03_displaying_weather/Weather/WeatherViewController.swift
@IBOutlet weak var locationLabel: UILabel!
@IBOutlet weak var temperatureLabel: UILabel!
Now with the view controller in place and wired up to the view, we can move
the API call from the delegate to the view controller and put the returned data
into the labels on the view.
Chapter 3. iOS • 60
report erratum  •  discuss

Moving the Data to the View Controller
We have two labels on the view, one for location and one for temperature.
Let’s move all the code above the return statement from the app delegate’s
application(_:didFinishLaunchingWithOptions:) to the view controller inside viewDidLoad().
Then change the code inside the completion handler’s if statement to look
like this:
iOS/ios_01_03_displaying_weather/Weather/WeatherViewController.swift
let json: NSDictionary?
do { json = try
NSJSONSerialization.JSONObjectWithData(data!,
options: NSJSONReadingOptions()) as? NSDictionary
dispatch_async(dispatch_get_main_queue(), {
let currentTemp:String = json!.objectForKey("temp") as! String
let title:String = json!.objectForKey("title") as! String
self.temperatureLabel.text = "\(currentTemp)˚ F"
self.locationLabel.text = title
})
} catch let e {
print("Error retrieving weather data: \(e)")
}
The code is very similar, but instead of logging the returned JSON string,
now we’re updating the labels on the UI with data from the deserialized
JSON object. Note the addition of the ‘dispatch_async‘ function wrapping
the UI-manipulating code. We need this because the completion handler
is being called on a thread different from the thread that’s rendering the
UI. To access the UI we need to execute the code that updates the label
on that "main thread." This dispatch function executes the block of code
on the main thread.
It’s important that long-running tasks like HTTP access happen off the main
thread, but when the task is completed any code that affects the view should
be executed back on the main thread.
Now run the app again, and you should see actual weather data in the UI.
We have only the current temperature and location showing, though, so let’s
get the forecast on the screen as well.
Displaying the Forecast
We’ll display the forecast in a collection view, which can display a list of data.
We’ll add a collection view to the UI, connect it to the view controller, and
then add a cell to display each day’s forecast.
report erratum  •  discuss
Day 1: What’s It Like Out? • 61

Adding and Laying Out a Collection View
With the main storyboard open, go to the bottom of the Utilities panel, where
we dragged the label out from. Find the collection view in the list of compo-
nents and drag it out to the view, underneath the temperature label.
First, let’s set up Auto Layout for the collection view. Here is a list of con-
straints to add:
• Equal Width to: Superview. This will keep the view as wide as its containing
view. C-drag from the collection view to the storyboard and choose Equal
Widths.
• Align Center X to: Superview. C-drag from the collection view down to the
storyboard and choose Center Horizontally in Container.
• Bottom Space to: Bottom Layout Guide. Try something new here, and go
to the document outline. C-drag from the collection view in the document
outline to its parent view. Auto Layout constraints can be added here,
too. Choose Vertical Spacing to Bottom Layout Guide. Update the value
in the inspector to be 0.
• Top Space to: 000ºF Equals: 20. C-drag to the temperature label and
choose Vertical Space. I set the constant to 20.
Now you should have constraints for the collection
view that look like those in this figure.
Next we need a reference to the collection view in
the view controller. Open the Assistant Editor to
the view controller and drag in an outlet called
forecastList. Now the view controller can reference
the collection view.
Setting Up the Collection View’s Data Source
In the view controller, we need somewhere to store
the list of forecasts. In WeatherViewController, below
the outlets, define an array to hold this list.
iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
var forecasts: [[String: AnyObject]] = []
This is the location from which the collection view will load the individual
forecast data. Next we need to have the view controller conform to a protocol,
which the collection view will use to get the data and configuration it needs.
Chapter 3. iOS • 62
report erratum  •  discuss

iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
class WeatherViewController: UIViewController,
UICollectionViewDataSource {
The protocol has two required methods: one to tell the collection view how
many total rows to expect and another to provide a view to display for each
collection item. First we can implement the easy function and tell the collection
view to expect as many items as are in the forecast list.
iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
func collectionView(collectionView: UICollectionView,
numberOfItemsInSection section: Int) -> Int {
return forecasts.count
}
Before we get to the other method, we need to create a view to use for the
individual forecasts in the list.
Creating a Forecast Cell
In the storyboard, the collection view we positioned on the screen already has
a UI that we can use for the forecast cell. Select the small box in the top-left
corner of the collection view. This is a default UICollectionViewCell that was
automatically created when we added the collection view to the view. Go to
the attributes inspector in the Utilities panel and enter forecast_cell in the
Identifier field. Refer to the following figure for guidance.
Use this identifier to connect the code to
the UI. Set up the cell view by adding
labels like those in the figure to the small
box in the collection view. You can resize
this box however you’d like to get the UI
elements in place.
report erratum  •  discuss
Day 1: What’s It Like Out? • 63

Now create a new Swift file called ForecastCell.swift. Open the companion editor
with the storyboard on one side and the cell on the other, and drag in outlets
for each label.
iOS/ios_01_04_displaying_forecasts/Weather/ForecastCell.swift
class ForecastCell: UICollectionViewCell {
@IBOutlet weak var forecastDayLabel: UILabel!
@IBOutlet weak var lowLabel: UILabel!
@IBOutlet weak var highLabel: UILabel!
@IBOutlet weak var conditionsLabel: UILabel!
}
Then, to associate the Swift class with the collection view cell in Interface
Builder, select the cell, go to the Identity Inspector in Xcode’s right-hand
utility drawer pane, and set the Custom Class field to be ForecastCell.
Now, with the cell in place, we go back to the view controller and get the
runtime sizing of the cell configured.
Configuring Data and Sizing the Cell
The other protocol method for UICollectionViewDataSource is collectionView(_:cellForItem-
AtIndexPath). This method will receive an NSIndexPath describing the position of
a cell in the list, and it should return the view for that cell, properly configured.
iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
func collectionView(collectionView: UICollectionView,
cellForItemAtIndexPath indexPath: NSIndexPath
) -> UICollectionViewCell {
let cell = collectionView
.dequeueReusableCellWithReuseIdentifier("forecast_cell",
forIndexPath: indexPath) as! ForecastCell
let forecast = forecasts[indexPath.row]
let day = forecast["day"] as! String
let high = forecast["high"] as! String
let low = forecast["low"] as! String
let conditions = forecast["text"] as! String
cell.forecastDayLabel.text = day
cell.highLabel.text = "High: \(high)ºF"
cell.lowLabel.text = "Low: \(low)ºF"
cell.conditionsLabel.text = conditions
return cell
}
First, we dequeue a cell from the cache that the collection view maintains.
This cache uses the reuse identifier we set up in Interface Builder.
iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
override func viewDidLoad() {
super.viewDidLoad()
Chapter 3. iOS • 64
report erratum  •  discuss

setCellSize(forFrameSize:view.frame.size)
// ...
func setCellSize(forFrameSize frameSize: CGSize) {
let layout = forecastList.collectionViewLayout as! UICollectionViewFlowLayout
layout.itemSize = CGSize(width: frameSize.width, height: 40)
}
override func viewWillTransitionToSize(size: CGSize,
withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) {
super.viewWillTransitionToSize(size, withTransitionCoordinator: coordinator)
setCellSize(forFrameSize:size)
}
Now the cell is configured with easy access to the labels through IBOutlets
in the associated class. The final step is to configure the view controller as
the collection view’s data source.
Wiring Up the Data Source
Back in the storyboard, select the collection view and C-drag from the collec-
tion view to the leftmost yellow icon at the top of the scene, as shown in this
figure.
When you release the mouse button, you should be presented with a pop-up
menu. Choose the dataSource option. Now in the storyboard, the collection
view has the weather view controller as its data source.
Finally, at the end of the completion handler of dataTaskWithURL(_:completionHandler:),
add code to assign the forecast array and to tell the collection view to reload
itself.
iOS/ios_01_04_displaying_forecasts/Weather/WeatherViewController.swift
self.forecasts = json!.objectForKey("forecasts")
as! [[String: AnyObject]]
self.forecastList.reloadData()
When reloadData() is called, the collection view calls to its data source and uses
the protocol’s methods to determine how many cells to create and how each
cell should look. Run the app and look at the forecasts, and then we can wrap
up our first day.
report erratum  •  discuss
Day 1: What’s It Like Out? • 65

What We Learned on Day 1
Today has been busy. We learned our way around Xcode, including Interface
Builder, and we learned how to run the project in the iPhone simulator. Then
we made an HTTP call to the weather API on the server, deserialized the JSON
data it returned, and did some light debugging by logging.
We made some more progress by building a UI for the data, including a col-
lection view list for the forecasts, using Interface Builder and Swift, plus Auto
Layout constraints. There was also judicious use of code at the right point to
get the cell sizing the way we wanted. Then we saw the fruits of our labor on
the simulator.
Your Turn
Find
• The Swift reference guide
• Xcode’s documentation
• Documentation on writing UI and unit tests
Do
• Write some UI and unit tests.
• Read up on UIAppearance and try styling some of the visual elements in
the view. Continue to do this as we build out more of the view.
Day 2: What’s It Like There?
Or, Loading the Current Weather at a Location
Currently our app is loading weather forecasts, but the location is hard-coded.
Today we’ll make the app usable by finding the device’s current location and
then later allowing the user to enter a location—in both cases reverse-
geocoding, or finding the real-world place name of that location, and using
that name to load the weather.
Creating a Better Organization
First, instead of keeping all the code in the view controller, let’s get a better
architecture in place. Then, as we add code to deal with location, we can do
it in a clean and organized way. We’ll start with a data model class that will
be responsible for loading and retaining weather data.
Chapter 3. iOS • 66
report erratum  •  discuss

Creating a Data Model
Create a new Swift file called WeatherDataModel.swift. First let’s set up the mech-
anism by which we’ll let the view controller know that the weather data has
changed. We could have the data model hold a reference to the view controller
directly, but that would be bad design. Instead, let’s use the same type of
delegate relationship we’ve seen the collection view use.
Data Model
First we’ll design a protocol to which we expect the weather data model’s
delegate to conform. It will be simple, with two methods—one that the model
calls upon successful load and one it calls in case of an error.
iOS/ios_02_01_weather_data_model/Weather/WeatherDataModel.swift
protocol WeatherDataDelegate {
func weatherDataDidChange(newData:[String : AnyObject]?)
func errorFetchingWeather(error:ErrorType)
}
Then the data model itself will have a reference to a delegate and two variable
properties, weatherData and forecasts.
iOS/ios_02_01_weather_data_model/Weather/WeatherDataModel.swift
class WeatherDataModel {
private var weatherDataDelegate:WeatherDataDelegate?
var weatherData:[String : AnyObject]? = [:] {
didSet {
weatherDataDelegate?.weatherDataDidChange(weatherData)
}
}
var forecasts:[[String:AnyObject]]? {
get {
if let forecastList = weatherData?["forecasts"] as? [[String : AnyObject]]
{
return forecastList
} else {
return nil
}
}
}
init(delegate:WeatherDataDelegate) {
weatherDataDelegate = delegate
}
Those properties are more than just variables. In the case of weather data,
we add a didSet observer. This code will be called whenever the property has
a value assigned. This means that whenever weatherData changes, we’ll inform
the delegate by calling its weatherDataDidChange(_:) method.
report erratum  •  discuss
Day 2: What’s It Like There? • 67

The forecasts property doesn’t actually store anything; instead, when it’s read
we attempt to look it up from the WeatherData property.
Now we move the API call from the view controller to the data model in a new
method. Notice that we add code to the URL to encode the incoming location
argument.
iOS/ios_02_01_weather_data_model/Weather/WeatherDataModel.swift
func fetchWeatherForLocation(named location: String) {
let encodedLocation = location
.stringByAddingPercentEncodingWithAllowedCharacters(
.URLHostAllowedCharacterSet())
let url = NSURL(string:
"http://localhost:3000/weather/location.json?name=\(encodedLocation!)"
)
let session = NSURLSession.sharedSession()
let task = session.dataTaskWithURL(
url!, completionHandler: {
[weak self]
➤
(data, response, error) in
if (data != nil) {
let json: [String:AnyObject]?
do { json = try
NSJSONSerialization.JSONObjectWithData(data!,
options: NSJSONReadingOptions()) as? [String:AnyObject]
self?.weatherFetchComplete(json!, error: nil)
} catch let e {
self?.weatherFetchComplete(nil, error: e)
}
}
})
task.resume()
}
Take note here of the code with the arrow pointing to it: [weak self], inside of
the completion handler. We need to make a call out from the completion
handler to self to send data to the delegate. Now that the data model is a
separate class that the view controller will construct, if the view controller is
destroyed, say, when the user navigates away from it, the data model will
also be destroyed.
However, if this happens during an API call, when the call returns and the
model is deallocated, we could get an error trying to call self. This [weak self]
tells iOS to only capture self as a weak reference. Then inside of the completion
block we can effectively use optional syntax on it, so that if self is no longer
valid there won’t be an error.
Chapter 3. iOS • 68
report erratum  •  discuss

Finally, the dispatch_async block that calls the delegate is in a new method,
weatherFetchComplete(_:error:).
iOS/ios_02_01_weather_data_model/Weather/WeatherDataModel.swift
func weatherFetchComplete(results: [String:AnyObject]?, error: ErrorType?) {
dispatch_async(dispatch_get_main_queue(), {
if let fetchError = error {
self.weatherDataDelegate?.errorFetchingWeather(fetchError)
} else {
if let weatherResults = results {
self.weatherData = weatherResults
}
}
})
}
Now let’s look at the changes to the view controller.
View Controller Changes
The weather view controller now needs to conform to the WeatherDataDelegate
protocol we defined, hold a reference to a WeatherDataModel, and initialize the
model through the various initialization paths.
iOS/ios_02_01_weather_data_model/Weather/WeatherViewController.swift
class WeatherViewController: UIViewController,
UICollectionViewDataSource,
WeatherDataDelegate {
var weatherDataModel:WeatherDataModel!
func initializeWeatherModel() {
weatherDataModel = WeatherDataModel(delegate: self)
}
override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {
super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
self.initializeWeatherModel()
}
required init?(coder aDecoder: NSCoder) {
super.init(coder: aDecoder)
self.initializeWeatherModel()
}
To accomplish that, we have a method called initializeWeatherModel() that is called
from either of the possible initializer methods, init(coder:) or init(nibName:bundle:).
Then, in viewDidLoad() we kick off the fetch in the data model.
iOS/ios_02_01_weather_data_model/Weather/WeatherViewController.swift
override func viewDidLoad() {
super.viewDidLoad()
report erratum  •  discuss
Day 2: What’s It Like There? • 69

setCellSize(forFrameSize:view.frame.size)
weatherDataModel.fetchWeatherForLocation(named: "Arvada, CO")
}
func weatherDataDidChange(newData: [String : AnyObject]?) {
if let weatherData = newData {
if let currentTemp:String = weatherData["temp"] as? String {
temperatureLabel.text = "\(currentTemp)˚ F"
}
if let title:String = weatherData["title"] as? String {
locationLabel.text = "\(title)"
}
forecastList.reloadData()
}
}
func errorFetchingWeather(error:ErrorType) {
print("There was an error getting the weather data: \(error)")
}
The implemented protocol methods are there for receiving the fetched
weather data or an error.
Now, while the weather data model is loading, we can show a progress indica-
tor to let the user know the app is doing some work. We’ll start by adding the
concept of different states to the view controller.
Adding a Loading State to the View
By having an enumeration of the different states the view can be in, it’s easy
to consolidate the logic for showing or hiding parts of the view. We can hide
the collection view while the progress indicator is showing, for instance. We’ll
do this by managing a viewState variable set to one of the enumeration’s values.
iOS/ios_02_02_view_state/Weather/WeatherViewController.swift
enum ViewState {
case Loading
case DisplayingWeather
}
var weatherDataModel:WeatherDataModel!
var viewState:ViewState = .Loading
Then, when loading weather, we can use the Loading enum case to configure
the view for loading.
iOS/ios_02_02_view_state/Weather/WeatherViewController.swift
func loadWeather() {
configureViewForState(.Loading)
weatherDataModel.fetchWeatherForLocation(named: "Arvada, CO")
}
Chapter 3. iOS • 70
report erratum  •  discuss

func configureViewForState(state: ViewState) {
viewState = state
if viewState == .Loading {
locationLabel.hidden
= true
temperatureLabel.hidden = true
forecastList.hidden
= true
spinner.hidden
= false
} else if viewState == .DisplayingWeather {
locationLabel.hidden
= false
temperatureLabel.hidden = false
forecastList.hidden
= false
spinner.hidden
= true
}
}
func weatherDataDidChange(newData: [String : AnyObject]?) {
if let weatherData = newData {
if let currentTemp:String = weatherData["temp"] as? String {
temperatureLabel.text = "\(currentTemp)˚ F"
}
if let title:String = weatherData["title"] as? String {
locationLabel.text = "\(title)"
}
forecastList.reloadData()
}
configureViewForState(.DisplayingWeather)
}
func errorFetchingWeather(error:ErrorType) {
print("There was an error getting the weather data: \(error)")
configureViewForState(.DisplayingWeather)
}
And when the weather data is loaded or an error is returned, we can configure
the view using the DisplayingWeather case. You may have noticed that configure-
ViewForState(_:) references a spinner. That will point to a progress indicator, so
let’s add that now.
Showing Progress
First, open the main storyboard and drag an Activity Indicator View from the
Utilities panel onto the view in the storyboard. Place it directly in the center
of the view and add Auto Layout constraints to center the spinner both verti-
cally and horizontally in the superview—the main view of the storyboard. Next
select that widget and go to the attributes inspector. Select the Animating
check box for the behavior. Now the indicator will always be spinning, and
we can hide or show it as needed.
Next, open the companion editor and drag an outlet from the activity indicator
to the view controller, below the other outlets. Name it spinner.
report erratum  •  discuss
Day 2: What’s It Like There? • 71

iOS/ios_02_02_view_state/Weather/WeatherViewController.swift
@IBOutlet weak var spinner: UIActivityIndicatorView!
Now we can show the user something to indicate that the app is working on
loading data while it’s making the HTTP call to get weather data. Let’s work
on getting the device’s location and using that to load weather conditions.
Getting the Weather Here
We’ll tap into a Cocoa library called Core Location to help us find the current
geographic location of the user’s device. Then we’ll use the library to reverse-
geocode the location data. Reverse-geocoding is the process of turning a lati-
tude and longitude into some sort of address or otherwise-named location.
Then we can pass that name to the weather API and find the weather where
the user is currently located.
Getting Our Current Location
The first step to using Core Location
is to include the framework in our
project so we’re able to reference its
API. In the project navigator, click
on the project at the top. Now go
down to the section labeled Linked
Frameworks and Libraries. Click the
+ button, and a window should pop
up, like in this figure.
Search for the CoreLocation.framework
using the text field and then select
it and choose Add. Now this
framework will be available for us
to reference.
Building a Location Manager
Let’s build a location manager that
contains all the logic needed to deal with obtaining a device’s current location.
There’s a few steps to this process, so it’s best to keep that code out of the
view controller. Create a file called LocationManager.swift. Start off by adding a
protocol that a delegate can conform to.
iOS/ios_02_03_get_current_location/Weather/LocationManager.swift
protocol LocationManagerDelegate {
func currentLocationDetermined(placename:String)
func unableToDetermineLocation()
Chapter 3. iOS • 72
report erratum  •  discuss

}
Then add a class definition. Importing CoreLocation will use the framework we
added just a bit ago and allow us to conform to the CLLocationManagerDelegate
protocol. This is important for determining location.
iOS/ios_02_03_get_current_location/Weather/LocationManager.swift
import CoreLocation
class LocationManager : NSObject, CLLocationManagerDelegate {
let locationManager = CLLocationManager()
var delegate:LocationManagerDelegate!
required init(delegate:LocationManagerDelegate) {
super.init()
self.delegate = delegate
locationManager.delegate = self
}
The initializer takes a delegate and sets this manager to be a delegate of the
CLLocationManager, which is assigned to the constant locationManager.
The next step to getting the device’s location is to ask the user for permission
to do so.
Requesting Permission to Determine Location
Because of privacy concerns and so forth, we can’t just get the device’s current
location in our code. We have to ask the user for permission. iOS will do that
by default the first time our app asks for a location from CLLocationManager, but
only if we’ve put a certain key/value pair in Info.plist. Open that file and add a
new row, with a key of NSLocationWhenInUseUsageDescription, and in the Value col-
umn add “Weather App would like to find the weather at your current loca-
tion.” Then in the determineCurrentLocation() method we can kick off the process
by checking the authorizationStatus().
iOS/ios_02_03_get_current_location/Weather/LocationManager.swift
func determineCurrentLocation() {
let status = CLLocationManager.authorizationStatus()
if status == .NotDetermined {
locationManager.requestWhenInUseAuthorization()
} else if status == .AuthorizedAlways ||
status == .AuthorizedWhenInUse {
locationManager.startUpdatingLocation()
} else {
delegate.unableToDetermineLocation()
}
}
report erratum  •  discuss
Day 2: What’s It Like There? • 73

If the status is AuthorizedAlways, we’re clear to get location updates with the app
in the foreground or the background. If it’s AuthorizedWhenInUse, the app only
has authorization to access location data while in the foreground. Any other
status means that we cannot use the location manager. In that case we just
inform the delegate of that.
When the status is NotDetermined, we need to ask for authorization. This app
will only ever need location data in the foreground, so we use requestWhenInUse-
Authorization(). When we request authorization, the app will present the message
we just added to the user.
As the location manager delegate, the location data model will receive notifi-
cation of any authorization change if the user allows the app to access location
data. These CLLocationManagerDelegate methods tell us when things have changed
with authorization.
Chapter 3. iOS • 74
report erratum  •  discuss

iOS/ios_02_03_get_current_location/Weather/LocationManager.swift
func locationManager(manager: CLLocationManager,
didChangeAuthorizationStatus status: CLAuthorizationStatus) {
determineCurrentLocation()
}
func locationManager(manager: CLLocationManager,
didFailWithError error: NSError) {
delegate.unableToDetermineLocation()
}
If the authorization changes, we call back to determineCurrentLocation, but if there’s
an error we inform the delegate.
Once the location manager has started updating the current location, location-
Manager(_:, didUpdateLocations:) will be called automatically when there are updates.
iOS/ios_02_03_get_current_location/Weather/LocationManager.swift
func locationManager(manager: CLLocationManager,
didUpdateLocations locations: [CLLocation]) {
if let latestLocation:CLLocation = locations.first as CLLocation? {
let geocoder = CLGeocoder()
geocoder.reverseGeocodeLocation(latestLocation,
completionHandler: {
[weak self] (results, error) -> Void in
if let firstResult:CLPlacemark = results!.first as CLPlacemark? {
var placeDescription = ""
if let name = firstResult.name {
placeDescription += name
}
// ...
self?.locationManager.stopUpdatingLocation()
self?.delegate.currentLocationDetermined(placeDescription)
} else {
self?.delegate.unableToDetermineLocation()
}
}
)
} else {
delegate.unableToDetermineLocation()
}
}
When we get a location, we turn around and reverse-geocode the location to
build up a place name and then tell the CLLocationManager to stop updating.
Refer to the code download for the elided code. Now let’s integrate this into
the view controller.
report erratum  •  discuss
Day 2: What’s It Like There? • 75

Using the Location Manager from the View Controller
The view controller should now conform to our location manager’s delegate
protocol.
iOS/ios_02_03_get_current_location/Weather/WeatherViewController.swift
class WeatherViewController: UIViewController,
UICollectionViewDataSource,
WeatherDataDelegate,
LocationManagerDelegate {
// ...
var locationManager:LocationManager!
func initializeProperties() {
weatherDataModel = WeatherDataModel(delegate: self)
locationManager = LocationManager(delegate: self)
}
We also create a property to hold an instance of the manager and initialize
it. To reflect the fact that we initialize the data model and the manager in this
method, change the name of initializeWeatherModel() to initializeProperties().
Then we implement the new delegate methods.
iOS/ios_02_03_get_current_location/Weather/WeatherViewController.swift
func currentLocationDetermined(placename:String) {
weatherDataModel.fetchWeatherForLocation(named: placename)
}
func unableToDetermineLocation() {
print("Unable to determine location")
configureViewForState(.DisplayingWeather)
}
If we can’t get a location, we should display some kind of message to the user,
but for now we just log it. If we do get a place name, we search for weather
at that place.
Now that we have the location of the device to automatically get the weather
at the current location, we can add some UI elements to allow the user to
search for weather at a different location.
Getting the Weather Somewhere Else
We’ll add the ability to search for weather at a location, so we need to add a
user-input field. The user can tap the location label to search, which will then
change the UI to a different state, showing an input field and some buttons
to search or cancel.
Chapter 3. iOS • 76
report erratum  •  discuss

Creating a View to Search for a City
To do this, go back to the main storyboard and drag out a text field and two
buttons. In the attributes inspector, set the placeholder text to Search for
Weather at a Location. Then set the titles of the buttons to Cancel and Search.
Next, we need to add the constraints to lay out the view correctly.
• Set the width of the text field to 360. Do this by C-dragging a constraint
from the control to the control itself.
• The text field should align its X to the superview.
• The text field should have top space to the top layout guide set to 42.
• The Cancel button should left-align to the search text field. This creates
an Align Leading to: constraint.
• The Cancel button should have top space to the search field set to 0.
• The Search button should right-align to the search field. This creates an
Align Trailing to: constraint.
• The Search button should have top space to the search field set to 0.
That should give you a view in Xcode that looks like the following figure.
Next, wire up the buttons and the text field into outlets.
iOS/ios_02_04_user_input_location/Weather/WeatherViewController.swift
@IBOutlet weak var locationSearchTextField: UITextField!
@IBOutlet weak var locationSearchButton: UIButton!
@IBOutlet weak var locationSearchCancelButton: UIButton!
We also need to add two actions for when the user taps the buttons. To do
this, C-drag from each of the buttons to the view controller as if you were
creating an outlet. Then change the Connection drop-down at the top of the
report erratum  •  discuss
Day 2: What’s It Like There? • 77

pop-up menu from Outlet to Action. This creates a method on the view con-
troller that will be called when the user taps the buttons. Create one for
Search and one for Cancel.
iOS/ios_02_04_user_input_location/Weather/WeatherViewController.swift
@IBAction func searchButtonPressed(sender: UIButton) {
searchForWeather()
}
@IBAction func searchCancelButtonPressed(sender: UIButton) {
configureViewForState(.DisplayingWeather)
}
func searchForWeather() {
locationSearchTextField.resignFirstResponder()
let locationName = locationSearchTextField.text!
configureViewForState(.Loading)
currentLocationDetermined(locationName)
}
When the Search button is pressed, we’ll kick off a search by grabbing the
text from the text field. The Cancel button’s action just puts the view back in
the DisplayingWeather state. Now let’s set it up so the user can tap the location
label to get into search mode.
Getting Into Search Mode
Search mode will be another ViewState, so add another case called SearchForWeather
and update configureViewForState(_:) to show the correct fields on the view.
iOS/ios_02_04_user_input_location/Weather/WeatherViewController.swift
enum ViewState {
case Loading
case SearchForWeather
case DisplayingWeather
}
//...
// in configureViewForState(_:)
} else if viewState == .SearchForWeather {
locationLabel.hidden
= true
temperatureLabel.hidden
= true
forecastList.hidden
= true
locationSearchTextField.hidden
= false
locationSearchButton.hidden
= false
locationSearchCancelButton.hidden
= false
spinner.hidden
= true
locationSearchTextField.becomeFirstResponder()
}
Chapter 3. iOS • 78
report erratum  •  discuss

Of course, each of the other branches of the if statement should hide the new
search controls. Let’s make it so the user can tap the location label.
The first step is to go to the storyboard, select the label, go to the attributes
inspector, and make sure that User Interaction Enabled is checked in the
View section. Without this step the gesture won’t be recognized. Next we’ll
add a UITapGestureRecognizer instance to the view controller.
iOS/ios_02_04_user_input_location/Weather/WeatherViewController.swift
func initializeProperties() {
weatherDataModel = WeatherDataModel(delegate: self)
locationManager = LocationManager(delegate: self)
locationTapGestureRecognizer = UITapGestureRecognizer()
locationTapGestureRecognizer.addTarget(self,
action:
#selector(WeatherViewController.locationTapped(_:))
)
}
Instead of a delegate relationship between the gesture recognizer and the view
controller, we add a target/action combination that specifies an object (self
here), and an action that takes a #selector, or description of a method to call.
Here’s how locationTapped() looks:
iOS/ios_02_04_user_input_location/Weather/WeatherViewController.swift
func locationTapped(recognizer: UITapGestureRecognizer) {
configureViewForState(.SearchForWeather)
}
We simply configure the view for searching. Run the app on the simulator
and try it out.
Search for your hometown, somewhere hot, somewhere cold, or the capital
of Mongolia (Ulan Bator).
What We Learned on Day 2
On Day 2 we focused on location and adding location awareness and search
to the app. First we cleaned house a bit and added a progress indicator to
show the user when the app is working on something. Adding a requirement
report erratum  •  discuss
Day 2: What’s It Like There? • 79

to get the user’s current location puts another step in the workflow to get the
weather, and the user needs to know when the app is working. Otherwise it
will seem unresponsive.
We also got to use the Core Location library and see what it’s like to work
with the location APIs in Cocoa. We saw how to deal with requesting permis-
sion to access location APIs, what location data looks like, and how to use
that data to do some further work, like turning a raw geolocation into a named
location.
Finally, we got to work with more controls to add interaction to the application.
We got some buttons on the screen, incorporated a text field for user input,
and saw how to wire these up to the view controller.
Your Turn
Find
• Documentation for NSURLSession
• Documentation on threads
• Details on GCD, or Grand Central Dispatch, which we used in the form
of dispatch_async
Do (Easier)
• Show some informative status messages during loading.
• In the case of an error, devise and implement a way to show the error
message to the user.
• When users search for a new location, they no longer see the weather at
their current location. Design and implement a way to take them back to
their current location.
Do (Harder)
• The code executed by the dataTaskWithURL(_:completionHandler:) runs on a differ-
ent thread. After reading more about threads and asynchronous execution,
figure out a way to find out what thread you’re on, and then log it during
different parts of the API calls.
• Think of some animations you could perform on view state changes, and
then implement them.
Day 3: Expanding Our Horizons
Or, Adding Flexibility to the Code and the UI
Chapter 3. iOS • 80
report erratum  •  discuss

Today we’ll make the code more flexible with two improvements. First we’ll
take the API call out of the weather data model and put it into a generic HTTP
client. This will give us a tour of some of the functional features of Swift, like
generics and passing closures to methods.
Then we’ll get deeper into Auto Layout and make the UI more flexible in order
to display on multiple screen sizes and geometries. The goal is to have as
responsive a layout as we can. First, though, we’ll start by creating an HTTP
client that knows how to parse and deserialize JSON into Swift objects.
A Better Deserialization Strategy
One of the first things we did yesterday was relieve the view controller of the
responsibility of fetching and storing weather data. We moved that code to
the weather data model, which was a good first step. But some things still
aren’t quite ideal:
• WeatherDataModel has to know how to encode a URL.
• WeatherDataModel needs to know how to get the NSURLSession we’re using.
• WeatherDataModel needs to know how to capture a deserialization error.
• Throughout the data model and WeatherViewController we have dictionaries
for the weather and forecast data. That means to get data out of the dic-
tionary we have to litter the code with the dictionary keys to get at the
data. If the data structure changes, the compiler won’t be able to help us
track down all the places that we need to change our code.
Building an HTTP Client with Generics
To fix these issues we’ll build a more generic HTTP client to relieve the data
model of the responsibility of knowing about how to do networking. We’ll also
create some data types to use for weather data and forecast data to make the
data structure more explicit.
Defining a Parsable Data Type
Let’s introduce the concept of something parsable; in other words, a protocol
that provides a method for parsing a JSON message. Create a new file called
HTTPClient.swift and add this protocol:
report erratum  •  discuss
Day 3: Expanding Our Horizons • 81

iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
protocol Parsable {
static func parse(json:JSONMessage) throws -> Parsable
}
Now, a critique of Swift: we really want to have a Parsable<T> with a parse(_:)
method that returns an optional T. That would allow us to enforce that any
implementation of parse(_:) returns the conforming type, but that’s not possible
with protocols in the current version of Swift, 2.2. In any case, we’ll be able
to enforce type with other parts of the client.
So far the JSON we’ve been deserializing has consisted of arrays containing
the type Dictionary of String to AnyObject. We can alias that type to something more
intention-revealing by using typealias.
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
typealias JSONMessage = [String:AnyObject]
Now we can refer to JSONMessage when we mean dictionaries with String keys
and AnyObject values.
Defining Supporting Types and Enumerations
Now, since we’re building an HTTP client, we need a way to specify the HTTP
verb, and we’ll probably want a request object and a response object. Here’s
an enum that has a GET method:
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
enum Method : String {
case GET
}
We could extend this later to include the other verbs, but for now all we’ll
implement is GET. For a request, we’ll take a path and a method.
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
struct ResourceRequest {
let path:String
let method:Method
}
We’ll require that results specify a type that conforms to the ‘Parsable‘ pro-
tocol, and return a ‘Result‘ ‘enum‘ case with that type, or an ‘ErrorType‘
called ‘ParseResourceError‘, defined here as having two cases:
Chapter 3. iOS • 82
report erratum  •  discuss

iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
enum ParseResult<T:Parsable> {
case Error(ErrorType)
case Result(T)
}
enum ParseResourceError: ErrorType {
case MalformedURL(message: String?)
case ParseError(message: String?)
}
Now let’s look at the HTTPClient class itself.
Defining an HTTP Client
The class has one class function, parseResource<T:Parseable>(_:completion:):
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
struct HTTPClient {
static func parseResource<T:Parsable>
(parseable:ResourceRequest, completion: (ParseResult<T>) -> ()) {
The completion argument is a function that takes a ParseResult of type T and
returns () or Void. This is how we’ll enforce that clients expect an instance of
a certain type returned, and that this type conforms to the Parsable protocol.
Next, we create an NSURL from the incoming path, get a reference to an
NSURLSession, and work with incoming GET requests.
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
let url = NSURL(string: parseable.path)
if let url = url {
let urlSession = NSURLSession.sharedSession()
if parseable.method == .GET {
The else block assumes that the if statement got a nil url, in which case some-
thing went wrong parsing the URL.
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
} else {
let error = ParseResourceError.MalformedURL(
message: "Malformed URL \(parseable.path)")
completion(.Error(error))
}
Finally, inside the if statement, we add the familiar dataTaskWithURL(_:completion-
Handler:) call.
iOS/ios_03_01_better_deserialization/Weather/HTTPClient.swift
let task = urlSession.dataTaskWithURL(url, completionHandler: {
(data, response, error) -> Void in
var parseResult:ParseResult<T>
❶
report erratum  •  discuss
Day 3: Expanding Our Horizons • 83

if let e = error {
parseResult = .Error(e)
❷
} else {
let json: [String:AnyObject]?
do { json = try
NSJSONSerialization.JSONObjectWithData(data!,
options: NSJSONReadingOptions()) as? [String:AnyObject]
let result = try T.parse(json!)
❸
parseResult = ParseResult.Result(result as! T)
❹
} catch {
let error = ParseResourceError.ParseError(
message: "Unable to parse")
parseResult = .Error(error)
}
}
dispatch_async(dispatch_get_main_queue(), {
❺
completion(parseResult)
})
})
task.resume()
❶Here we declare a parse result of the same type as was passed into the
method.
❷If the error to the completion handler is not nil, we’ll return the error
wrapped in the result enumeration’s error case.
❸Otherwise we’ll have the type parse itself from the deserialized JSON.
❹If the parse() method returns a result, we’ll assign it to the enumeration’s
Result case.
❺Finally, we’ll return the result enum case to the completion function.
In case of any errors, we’ll throw our custom ErrorType enum. Now we have the
framework in place for parseable results to be returned from the client. Let’s
make types for the data coming back from the API call.
Adding Data Types
We’ll add a data type for the weather data message as a whole and then for
individual forecasts.
Weather Data and Forecast Parsables
Add a struct called WeatherData in a file called WeatherData.swift. It will have the
following properties:
iOS/ios_03_01_better_deserialization/Weather/WeatherData.swift
struct WeatherData : Parsable {
let temp:String
Chapter 3. iOS • 84
report erratum  •  discuss

let title:String
let forecasts:[Forecast]
var tempLabel:String {
get {
return "\(temp)ºF"
}
}
The tempLabel property is a helper to return the temperature in a form ready
to display. Next implement the parse(_:) method.
iOS/ios_03_01_better_deserialization/Weather/WeatherData.swift
static func parse(json: JSONMessage) throws -> Parsable {
guard let temp = json["temp"] as? String,
let title = json["title"] as? String,
let forecastMessages = json["forecasts"] as? [JSONMessage] else {
throw ParseResourceError.ParseError(message: "Missing fields")
}
let parsedForecasts = try forecastMessages
.reduce([Forecast]()) {(acc, message) in
var newList = acc
do {
let forecast = try Forecast.parse(message)
newList.append(forecast as! Forecast)
return newList
} catch let e {
throw e
}
}
return WeatherData(temp: temp, title: title, forecasts: parsedForecasts)
}
This method just grabs the data out of the incoming JSONMessage and puts it
in place. It reduces the list of forecast data to an array of type Forecast. That’s
another type we can create now, in a file called Forecast.swift.
report erratum  •  discuss
Day 3: Expanding Our Horizons • 85

iOS/ios_03_01_better_deserialization/Weather/Forecast.swift
struct Forecast : Parsable {
let day:String
let high:String
let low:String
let conditions:String
Forecast works the same as WeatherData, with a set of properties that match the
JSON. It also has some helper methods for getting text to display temperatures.
iOS/ios_03_01_better_deserialization/Weather/Forecast.swift
var highLabel:String {
get {
return "High: \(high)ºF"
}
}
var lowLabel:String {
get {
return "Low: \(low)ºF"
}
}
Then it implements the parse(_:) method, which gets all of the properties in
place.
iOS/ios_03_01_better_deserialization/Weather/Forecast.swift
static func parse(json:JSONMessage) throws -> Parsable {
guard let day = json["day"] as? String,
let high = json["high"] as? String,
let low = json["low"] as? String,
let conditions = json["text"] as? String else {
throw ParseResourceError.ParseError(message: "Missing fields")
}
return Forecast(day: day, high: high, low: low, conditions: conditions)
}
Now let’s see how to change the weather data model and view controller to
use the new HTTP client.
Refactoring Classes to Use the New Types
First let’s look at the data model. We can change all of the untyped dictionaries
to types, making things much cleaner.
iOS/ios_03_01_better_deserialization/Weather/WeatherDataModel.swift
protocol WeatherDataDelegate : class {
func weatherDataDidChange(newData:WeatherData?)
func errorFetchingWeather(error:ErrorType)
}
// ...
var weatherData:WeatherData? {
Chapter 3. iOS • 86
report erratum  •  discuss

didSet {
weatherDataDelegate?.weatherDataDidChange(weatherData)
}
}
var forecasts:[Forecast]? {
get {
return weatherData?.forecasts
}
}
// ...
func weatherFetchComplete(results: WeatherData?, error: ErrorType?) {
if let fetchError = error {
self.weatherDataDelegate?.errorFetchingWeather(fetchError)
} else {
self.weatherData = results
}
}
The fetch method is also cleaner and uses the ParseResult<WeatherData> type
passed to the completion method to show what kind of type we’d like back from
a call.
iOS/ios_03_01_better_deserialization/Weather/WeatherDataModel.swift
func fetchWeatherForLocation(named location: String) {
let encodedLocation = location
.stringByAddingPercentEncodingWithAllowedCharacters(
.URLHostAllowedCharacterSet())
let path =
"http://localhost:3000/weather/location.json?name=\(encodedLocation!)"
let parseableResource = ResourceRequest(path: path, method: .GET)
HTTPClient.parseResource(parseableResource, completion: {
[weak self]
(parseResult:ParseResult<WeatherData>) -> () in
switch parseResult {
case .Error(let error):
self?.weatherFetchComplete(nil, error: error)
case .Result(let weatherData):
self?.weatherFetchComplete(weatherData, error: nil)
}
})
}
In case of either an error or a successfully parsed result, we pass along the
enclosed type to the delegate. Now in the view controller we can also use the
new types in weatherDataDidChange(_:).
iOS/ios_03_01_better_deserialization/Weather/WeatherViewController.swift
func weatherDataDidChange(newData: WeatherData?) {
if let weatherData = newData {
temperatureLabel.text = weatherData.tempLabel
report erratum  •  discuss
Day 3: Expanding Our Horizons • 87

locationLabel.text = weatherData.title
forecastList.reloadData()
configureViewForState(.DisplayingWeather)
}
}
And in collectionView(_:cellForItemAtIndexPath:), we can use the Forecast type.
iOS/ios_03_01_better_deserialization/Weather/WeatherViewController.swift
func collectionView(collectionView: UICollectionView,
cellForItemAtIndexPath indexPath: NSIndexPath
) -> UICollectionViewCell {
let cell = collectionView
.dequeueReusableCellWithReuseIdentifier("forecast_cell",
forIndexPath: indexPath) as! ForecastCell
let forecast = weatherDataModel.forecasts![indexPath.row]
cell.forecastDayLabel.text = forecast.day
cell.highLabel.text = forecast.highLabel
cell.lowLabel.text = forecast.lowLabel
cell.conditionsLabel.text = forecast.conditions
return cell
}
}
The code is much cleaner and clearer now. We know what types of data we’re
expecting where, so that’s a good improvement to the data part of the appli-
cation. Now let’s improve the view by making the layout more responsive.
A More Responsive Layout
So far we’ve only been running the app on an iPhone simulator, or at least I
have shown screenshots that way. All of the work so far looks fine on an
iPhone 6/6S. If you take a look at some other simulators, though, you can
see that we have work to do.
The figure on page 89 shows an iPad simulator, which looks very strange in
the forecast list, especially.
Chapter 3. iOS • 88
report erratum  •  discuss

The following figure shows an iPhone 5, which has sizing problems with the
search field.
The figure on page 90 shows an iPhone 5 in landscape orientation makes it
almost impossible to see forecasts. Generally the forecast list doesn’t look
good in any phone landscape configuration.
So, the final task for today is to get as close as we can to a responsive layout.
report erratum  •  discuss
Day 3: Expanding Our Horizons • 89

A More Flexible Search View
First let’s tackle the search view. The problem right now is that the search
text field is set to 360 points wide. This works everywhere except iPhone 5
and earlier phones.
To easily change the constraints for that device we can use a size class.
Introducing Size Classes
iOS and Apple devices have slowly developed the same problem that Android
started with. There are a lot of different screen sizes given all the different
iPhones and iPads.
To deal with this in a flexible and general way, Apple has given us size classes.
Size classes group all the devices and orientations, landscape and portrait.
Then in Interface Builder or in code, we can configure the views and behaviors
appropriately.
Size classes are grouped into combinations of width and height in three dif-
ferent classes, Compact, Any, and Regular. The Any Width/Any Height class
is the default, and the base from which all others can vary. See the table on
page 91 for all of the classes and how Apple describes them.
Without our necessarily knowing it, all the work we’ve done so far in Interface
Builder has been in the Any/Any class. The trouble we’re having with the
sizing of the search text field is on the iPhone 5 and earlier in portrait orien-
tation. We’ll fix it by modifying constraints for that Compact/Any size class.
Chapter 3. iOS • 90
report erratum  •  discuss

Regular Width
Any Width
Compact Width
5.5" iPhone in landscape
iPhones in landscape
3.5", 4", 4.7" iPhones
in landscape
Compact
Height
Base values for iPads or
5.5" iPhone landscape
Base values for all lay-
outs
3.5", 4", 4.7" iPhones
in portrait or landscape
Any
Height
iPads in portrait or land-
scape
Base values for iPads in
landscape or portrait;
iPhones in portrait
iPhones in portrait
Regular
Height
Configuring the Search View for Compact Width
Of course, we could address this problem in many ways, but today we’ll do
it this way. Open the main storyboard, and look at the bottom center of the
screen. You’ll see a label that reads, “w Any h Any.” Click that, and you’ll see
something like this:
Interface Builder allows us a minimal preview of the layout in any of the size
classes. Most of our design should be done in the Any/Any class. Now we’ll
add an exception for Compact/Any, so select Compact Width | Any Height
from the size class pop-up view.
The edits we make will be applied only for devices or orientations in this size
class. Select the text field and go to the size inspector. Find the constraint
that says Width Equals: 360, select it, and press Delete. The box will grey out
but not disappear.
report erratum  •  discuss
Day 3: Expanding Our Horizons • 91

This is one way to uninstall the constraint from this size class, or to tell
Interface Builder not to apply this constraint. If you changed back to Any/Any,
you would see that the box is no longer greyed out. However in Compact/Any,
we no longer have a width constraint. To add one, C-drag from the text field
to the superview and choose Equal Widths. Now double-click on the constraint
you just added in the size inspector to edit it, and you should see something
like this figure.
Set the multiplier to 0.8. This means that the search field should have its
width set to 80 percent of the superview on all 3.5", 4", and 4.7" iPhones in
landscape and portrait. On other devices, it will be set to 360 points, since
we uninstalled the constraint on only this size class.
Run the app in the iPhone 5 simulator, and
you should see that the layout works much
better on this size screen.
The constraints for the Cancel and Search
buttons should hold up to these changes just
fine since they were anchored to the size of
the text field.
Now let’s look at what we can do for the temperature and location labels.
Responsive Layout for Temperature and Location
The current interface is very sparse on the iPad and in landscape on all the
iPhones. To fix this problem for those classes, we’ll bring the location down
from the top of the screen, center it vertically with the temperature, change
the width to be the same as the temperature, and bump up the font size. On
all iPhones in portrait, the location will remain at the top of the screen.
Chapter 3. iOS • 92
report erratum  •  discuss

First, we need to change some of the base constraints: in other words, the
constraints we have in Any/Any. Right now we have the temperature label
positioned relative to the location label. Since the location label will move, it
makes sense to swap that relationship. Back in the Any/Any size class in
Interface Builder, take these steps:
• Add a width constraint of 330 to the temperature label.
• Add a height constraint of 150 to the temperature label.
• Change the location label’s font size to 12.
• Add “equal width to super view” to location, with a multiplier of 0.9.
• Remove the location label’s “top space to top layout” guide. You can select
it in the Utilities panel and press Delete, which will uninstall it from
Any/Any. Then select the greyed-out constraint from the list of constraints
in the Document Outline and delete it from the project entirely.
• Edit the location label’s “top space to temperature bottom” constraint to
have a constant of 8. Now the location label should always be 8 pixels
above the temperature label.
• Select the temperature label and add a “vertical space to top layout” guide,
with a constant of 24.
Now let’s set up the temperature label.
Temperature Layout for Landscape and iPad
The temperature label needs to shift to the left in the Compact/Compact and
Regular/Compact size classes. These correspond to iPhone and iPhone 6 Plus
landscape orientations. In these size classes, do the following:
• Select the Align Center X to: Superview constraint in the utility pane and
press Delete, uninstalling it for those size classes.
• Add a temperature label “leading edge to the superview’s left margin”
guide with a constant of 24.
An alternative to switching the size class in Interface Builder and adding
duplicate constraints is to add a constraint to one size class and then edit
the constraint to install it to more than one constraint. Look at the “leading
edge to super view” margin constraint in the figure on page 94.
To add the constraint to more than one size class, click the + to the left of the
Installed label. You can also add different constants for different constraints
by the + to the left of the Constant label.
report erratum  •  discuss
Day 3: Expanding Our Horizons • 93

For iPad, we use a different set of constraints. Switch to the Regular/Regular
size class in Interface Builder and take these steps:
• Uninstall the temperature “top space to top” guide.
• Add an “align center Y superview to temperature” with a constant of –75.
• Modify the “center temperature X in superview” constraint—add a constant
of –204 for just the Regular/Regular size class.
Now let’s focus on the location label.
Location Layout for Landscape and iPad
In iPhone landscape orientations and all iPad orientations, we want the
location label to transition down to the right of the temperature label. Take
these steps:
1.
Uninstall the location label’s width, “center X to super view”, and “top
space to temperature label” constraints in Compact/Compact and Regular/
Compact.
2.
Add a “leading edge to temperature label” trailing to the location label
with a constant of 12 in Compact/Compact and Regular/Compact.
3.
Add an “align vertical center to temperature label” to the location label in
Compact/Compact and Regular/Compact.
4.
Add a width constraint of 140 to the location label for Compact/Compact,
and make it 280 in Regular/Compact.
5.
Add an “equal height” constraint from the location label to the temperature
label in Regular/Compact and Compact/Compact.
6.
In the attribute inspector, set the location label’s font to align center and
word wrap, and set the number of lines to four. Then click the + button
to set the font size to 32 in Regular/Compact and 18 in Compact/Compact.
Chapter 3. iOS • 94
report erratum  •  discuss

And for the Regular/Regular size class, take these steps:
1.
Uninstall the location label’s width and center X constraints in Regular/
Regular.
2.
To the location label, add a constraint to Center Vertically with the tem-
perature label.
3.
Add an equal width and height constraint from the location label to the
temperature label.
4.
Set the location label’s font to 32 in Regular/Regular.
Go ahead and run this in the iPhone simulators and use D ← and D → to
test the different orientations. Then test it in the iPad simulator. The labels
should be moving side-by-side when the iPhone transitions to landscape, and
staying side-by-side in all orientations on the iPad.
Now let’s configure the forecast list.
Responsive Layout for Forecast Cells
The collection view is not quite right in the iPhone landscape orientations
and on the iPad. It’d be better if the forecast list were a vertical list in all the
iPhone portrait orientations and reconfigured itself to a horizontal list in
landscape and in all orientations on the iPad. Take a look at the following
figure, which shows this behavior on the iPhone 6 Plus in landscape.
Let’s go back to Interface Builder to add this behavior.
report erratum  •  discuss
Day 3: Expanding Our Horizons • 95

Configuring the Collection View for iPhone Landscape and iPad
First, edit constraints inside the cell. You can change the design-time view
of the cell in Interface Builder and make it bigger vertically to have space to
add these constraints. The correct cell size will be applied at runtime in code,
so don’t worry about changing it in Interface Builder. Do the following for
Regular/Regular, Compact/Compact, and Regular/Compact. You’ll probably
have to do a lot of frame updates since the labels will be moving around a lot.
1.
Remember when we created the forecast cell, I left it up to you to add
constraints to make it look like the figures. Go to each of these constraints,
and edit them to change the priority to 750, or “high.” The priority is how
the runtime layout system breaks a tie between different, possibly
ambiguous constraints. This was the only way I was able to make the
following steps work.
2.
Next, uninstall all the constraints you previously added to the labels in
the cell for Regular/Regular, Compact/Compact, and Regular/Compact.
3.
Add a constraint to center the Day of the Week label horizontally in the
cell, and add a “top guide to container margin” constraint with a constant
of 6.
4.
Center the Conditions label horizontally, and add a “top guide to container
margin” constraint with a constant of 40.
5.
Center the High temperature label horizontally, and add a “top guide to
container margin” constraint with a constant of 70.
6.
Center the Low temperature label horizontally, and add a “top guide to
container margin” constraint with a constant of 90.
That takes care of the items inside the forecast cell. The collection view also
looks better on iPad at a constant width of 750 rather than expanding to the
width of the screen. Uninstall the width constraint in Regular/Regular and
set the collection view width to 750 for that size class.
We need to make a few tweaks to the code to get all the cells sizing correctly.
Code Changes to Cell Sizing
In the weather view controller, we’ve had a method called setCellSize to set the
size of the cell once when the view is loaded. Now we’ll need to configure the
size each time the orientation changes, because on an iPhone 6/6S we want
the cells to be side-by-side in landscape and in a list format in portrait. To
reflect that, let’s start by changing the method name from setCellSize to config-
ureCellSize(), with no parameters.
Chapter 3. iOS • 96
report erratum  •  discuss

The method’s body changes drastically, too. To get the right configuration for
each size class, we need to look up the current size class of the runtime
environment.
iOS/ios_03_02_size_class_aware_layout/Weather/WeatherViewController.swift
func configureCellSize() {
let viewWidth = view.frame.width
let layout =
forecastList.collectionViewLayout as! UICollectionViewFlowLayout
layout.minimumInteritemSpacing = 0
let horizontalSizeClass = traitCollection.horizontalSizeClass
let verticalSizeClass = traitCollection.verticalSizeClass
if horizontalSizeClass == .Compact && verticalSizeClass == .Regular {
layout.itemSize = CGSize(
width: viewWidth,
height: compactHorizontalSizeClassCellHeight)
} else if verticalSizeClass == .Compact {
let cellSize = viewWidth / 5
layout.itemSize = CGSize(
width: cellSize,
height: cellSize)
} else if verticalSizeClass == .Regular && horizontalSizeClass == .Regular {
layout.itemSize = CGSize(
width: regularHorizontalSizeClassCellWidth,
height: regularHorizontalSizeClassCellHeight)
}
}
We still need references to the view’s width and the collection view’s layout.
We configure the minimumInteritemSpacing to 0 on the layout, though, to do away
with space between items.
Then we get references to the horizontal and vertical size classes through the
view controller’s traitCollection. These are enum cases, so we can use an if to
configure the layout’s itemSize the way we want for Compact/Regular, Compact
in the vertical, or Regular/Regular. Here are the constants used in the pre-
ceding code:
iOS/ios_03_02_size_class_aware_layout/Weather/WeatherViewController.swift
let regularHorizontalSizeClassCellWidth:CGFloat
= 150.0
let regularHorizontalSizeClassCellHeight:CGFloat
= 150.0
let compactHorizontalSizeClassCellHeight:CGFloat
= 40.0
Finally, instead of just snapping the view to the layout we want, on orientation
change we can animate the transition by calling configureCellSize() when the
device rotates.
iOS/ios_03_02_size_class_aware_layout/Weather/WeatherViewController.swift
override func viewWillTransitionToSize(size: CGSize,
report erratum  •  discuss
Day 3: Expanding Our Horizons • 97

withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) {
super.viewWillTransitionToSize(size, withTransitionCoordinator: coordinator)
coordinator.animateAlongsideTransition({(context) -> Void in
self.configureCellSize()
}, completion: nil)
}
Using the transition coordinator in viewWillTransitionToSize, we can add a block
to be animated alongside the transition. Test it out in all the simulators.
Now that we have a layout that works on different screen sizes and devices,
that wraps things up for Day 3.
What We Learned on Day 3
We dug deep into two areas of iOS development allowing us to write better code
and build better UIs. We learned how to use generics to create an API that’s
easier and cleaner to work with, but also one on which the compiler will be
able to enforce type safety. We learned how to build responsive UIs using size
classes. We got as close as possible to a responsive UI, which detects the screen
configuration and changes the view accordingly across all the devices.
Your Turn
Find
• Documentation on Swift’s generics
• Documentation on Swift’s enumerations and matching patterns with case
statements
• Documentation on Auto Layout
• Documentation on UIStackView
Do
• Implement the other HTTP verbs in the HTTP client. Try to integrate the
code in another project and use those other verbs.
• Dig into UIStackView and see how it often obviates the need for explicit Auto
Layout constraints. Try reimplementing the Auto Layout portions with
UIStackView instead.
• Change the existing view and add UI and appropriate calculations to
convert temperatures to centigrade.
Chapter 3. iOS • 98
report erratum  •  discuss

Wrapping Up iOS
We haven’t even scratched the surface of all the APIs that are available in iOS
development, but we’ve gone pretty deep into the ones we’ve worked with.
You’ve gotten pretty deep exposure to the tooling and the new language, Swift.
This is a great foundation from which to continue to learn to build iOS apps.
Strengths
The strength of the iOS platform is hard to dispute. It’s one of the dominant
platforms; there’s no way around it. It’s important to know. The more Apple
releases beautiful hardware, the more people will want apps on iOS. There’s
no sign of that slowing down anytime soon.
Some very exciting and cool things are happening on the platform as well.
Swift is probably the biggest. Swift is exciting because it’s a great language,
with important, modern capabilities. By introducing Swift, Apple’s showing
that it’s not afraid to move on from the legacy and keep providing users with
better ways to build apps.
Another great strength is iOS’s community support. Probably because the
community is so important to so many developers, it continues to learn and
grow and to leave a legacy of great documentation, tools, and advice on the
Internet. Access to this community means you have nearly unlimited help in
honing your iOS chops.
Weaknesses
iOS does have some weaknesses. It’s hard to believe, but iOS development
has been around for seven years or so now, and it’s built on even older Mac
development tools and frameworks. Legacy frameworks and “unique” tooling
design cause lots of headaches, even for seasoned developers. For instance,
Xcode’s project file format and XIB files are a real pain in team situations
using source control. For another example, on Day 3 you saw how deep into
the tooling you need to go to work with size classes. They may be a great tool
to deal with multiple screen sizes, but they’re hidden deep within the tool and
it’s not obvious to anyone glancing at the storyboard file to what extent
everything is configured for different screens. Is the answer to use code
instead? Or is the answer maybe comprehensive documentation about what’s
going on in a storyboard? You and your team will have to work together to
get around the tooling.
Another issue to deal with is the lack of solid third-party library support.
Solutions like CocoaPods represent the community’s best shot at dealing with
report erratum  •  discuss
Wrapping Up iOS • 99

the lack,
1 but they’re limited in how far they can go. This is starting to get
better with the introduction of user-built frameworks, but it’s not even close
to Android’s or even UWP’s NuGet support in Visual Studio.
Final Thoughts on iOS
As you continue your journey learning iOS, keep in mind the things we’ve
covered, especially on Day 3. Learning to build responsive interfaces will
benefit you and your teams. Xcode and Auto Layout have come a long way
and gotten more and more powerful. They’re still not quite as easy to use as
media queries, but I expect the capabilities and tooling support to continue
to get better.
Swift is a very powerful language with multiple paradigms to work with. As
you get deeper into iOS development, you can benefit from understanding
how to use Swift to do the heavy lifting. Also, because of Swift’s newness, the
community is going to be learning a lot and new patterns will emerge. Stay
on top of your learning, and try out new things.
iOS is a powerful, fun platform, with room for a little fanboy in all of us.
1.
http://cocoapods.org
Chapter 3. iOS • 100
report erratum  •  discuss

CHAPTER 4
Android
I remember when development opened up for the iOS platform. I felt like I
wasn’t quite ready to make the leap, first because I didn’t have an iPhone yet,
and second because I didn’t have any experience with Objective-C. When
Android was announced I felt a lot more comfortable jumping in because I
already had experience with Java. It turns out it was silly to wait to delve into
Objective-C, but I’m really glad I started out with Android.
Android began as bit of an “us too” platform. The iPhone looked better than
any of the Android devices for a long time, the operating system looked better
for even longer, and it was really easy to make ugly, poorly performing Android
apps.
But Google has kept at it on all fronts, and Android has stayed one of the Big
Two and even gained the lead in some areas at various times. Its interface
now looks great, it runs on some really nice devices, and it has a number of
interesting features that make your mobile device a powerful tool.
It’s fun to play the game of “who had it first” and “who does it better” with
people who prefer one platform over the other. Whichever platform you prefer
as a consumer, Android has a lot to love as a developer, and I still have a soft
spot for working with it. It’s so fun that I don’t even mind using Java!
report erratum  •  discuss

A Currency-Conversion App
The app for this week is a currency converter. It will enable the user to put
in the symbols for two different currencies and to see how much a certain
amount in one currency is worth in the other. It’ll use the /convert endpoint in
the API, which takes two currencies and returns a conversion rate.
We’ll be building the app in Android, and we’ll get to exercise a few important
parts of the Android API along the way. We’ll see how creating views and
layouts works, how to make network requests safely, and how to store data
locally in a SQLite database. We’ll also cover how to build views so they work
on small and large screens.
On the first day we’ll cover how to make web requests, talk about Android’s
activity life cycle, and see how to use services to avoid doing too much pro-
cessing on the main thread. We’ll be using the API’s ‘/convert‘ endpoint to
convert an amount from one currency to another. On Day 2 we’ll start
building the interface, talking about Android layouts, and using resource
qualifiers to build flexible interfaces, among other things. We’ll finish up the
app on Day 3 by adding a local data store using SQLite and displaying the
currency-conversion history in a list. Let’s get started!
Chapter 4. Android • 102
report erratum  •  discuss

Day 1: How Far Does a Dollar Go?
Or, A Round-Trip to the API
Today we’ll get started by laying the groundwork for the app. We’ll create a
project and then load data from the API. There’s more to this than you might
think—you’ll see a few ways not to make network calls before settling on a
good method. Let’s get started.
Getting Started
In the beginning, Android’s official IDE was an Eclipse plugin.
1 At the 2013
Google I/O developer conference, Android Studio was announced as the new
official IDE.
2 It’s built on IntelliJ, which makes it a solid tool. I’m not always
a fan of using an IDE, but there are a lot of benefits to working with a good
one. Android Studio is my favorite IDE of all of the ones covered in this book.
To be able to create our Android project, the first thing to do is get a copy of
Android Studio.
Creating a Project
Once you have Android Studio installed, let’s create a new project. Open
Android Studio and choose Start a New Android Studio Project from the quick-
start view or choose File > New > New Project.
The first dialog has you choose an application name and use your company’s
Internet domain name to create a Java package name. Enter Currency Con-
verter for the Application Name and something like yourdomain.com for the
Company Domain.
Next, you’re asked to choose from some form factors supported by Android.
Phones and tablets are all we’ll support with this application. You’re also
asked to choose a minimum SDK. This choice is how you strike a balance
between access to newer APIs and support for older devices, or perhaps just
slow-moving carriers as shown in the figure on page 104.
Choosing an older SDK doesn’t necessarily mean you can’t use newer APIs,
but you’ll have to code around the fact that some of your users will not have
access to the APIs you use. This is an important initial decision, but a good
minimum at the time of writing is API 15, or 4.0.3, Ice Cream Sandwich. You
can find more information at Google’s API dashboard.
3
1.
https://eclipse.org/
2.
https://developer.android.com/sdk/index.html
3.
https://developer.android.com/about/dashboards/index.html
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 103

Next, choose Blank Activity to start the app with a generated blank activity.
An activity is like a view controller and controls a full-screen view.
Finally, you’ll be asked to name and title the activity and choose its layout
name. Android Studio will generate an Android activity Java file and an XML
layout file. The layout defines the view, and the activity controls that view as
shown in the figure on page 105.
This wizard also generated a menu resource, but we won’t deal with that in
this app.
Now, let’s look at some of the files generated by Android Studio. First, an
important file that describes the application, both to the Android system and
the Google Play Store: the manifest.
First in the file, the package is defined in the manifest tag. The package is an
important identifier for the app. It is generally the root Java package, or the
highest level underneath which classes are defined. Next, the application
itself is described in the application tag, including information about the name,
how the system should treat it, and other application-level information.
Chapter 4. Android • 104
report erratum  •  discuss

Android/android_01_00_new_project/CurrencyConverter/app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.sevenapps.currencyconverter" >
<application
android:allowBackup="true"
android:icon="@mipmap/ic_launcher"
android:label="@string/app_name"
android:theme="@style/AppTheme" >
<activity
android:name=".ConvertActivity"
android:label="@string/app_name" >
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
</application>
</manifest>
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 105

Every activity needs to be registered in the manifest, and you can see where
we register the ConvertActivity here. If you create an activity and wonder why
you’re having problems getting it to show up, remember to add it to the
manifest. Finally, there are different kinds of intent filters. The one we see
here, with the category LAUNCHER, is telling the Android system that this
activity should be the one launched when the user launches the app.
Recently Google made some fundamental changes to the build process for
the Android platform. The company delegated build and dependency manage-
ment to a tool called Gradle that is built on the Groovy language.
4 5 Two
build.gradle files are created: one in the project root and one in the app directory.
Here’s the generated Gradle file for the application.
Android/android_01_00_new_project/CurrencyConverter/app/build.gradle
apply plugin: 'com.android.application'
android {
compileSdkVersion 23
buildToolsVersion "23.0.2"
defaultConfig {
applicationId "com.sevenapps.currencyconverter"
minSdkVersion 15
targetSdkVersion 23
versionCode 1
versionName "1.0"
}
buildTypes {
release {
minifyEnabled false
proguardFiles getDefaultProguardFile('proguard-android.txt'),
'proguard-rules.pro'
}
}
}
dependencies {
compile fileTree(dir: 'libs', include: ['*.jar'])
compile 'com.android.support:appcompat-v7:23.1.1'
}
In the defaultConfig section, the application ID, in conjunction with the package
ID, defines this application for the world. Having both a package ID and an
application ID allows you to use the same codebase to build, for instance,
free and paid versions of an app, distinct from each other in the Play Store.
4.
http://gradle.org/
5.
http://groovy-lang.org
Chapter 4. Android • 106
report erratum  •  discuss

The minimum SDK version is the lowest SDK version you’ll allow this app to
be installed on; however, the target SDK version is the SDK against which the
app will be compiled. The app will have access to this SDK version’s APIs. If
there are significant differences between this API and the minimum’s, you’ll
have to add conditions in the code to run correctly on the SDK version at
runtime.
Gradle’s dependency management makes full use of the Maven ecosystem,
6
allowing you to easily manage declaring dependencies to use in the app for
a given version, as in the dependencies section of the build.gradle file.
One of the best things about Gradle in the modern Android tool chain is that
Android Studio depends fully on executing Gradle tasks to build the app.
This means the build on your computer will be the same build executed on
a continuous integration server.
Since the project generated by Android Studio is ready to go, at least as a
simple, “hello world”–style app, let’s run it and see how it looks.
Running the App
To run the app right away, press the play button in the toolbar in Android
Studio, or press CR. This will open a dialog from which you can set up an
Android emulator, choosing the SDK level, screen dimensions, and so forth.
Create a phone-size emulator for now.
The Android emulator is historically slow to start and is a resource hog. One
alternative is to use Genymotion,
7 which is what you’ll see throughout these
examples.
In either case, when you run the application you should see the generated
“Hello World” screen. Now, let’s get into the code and get our hands dirty.
Avoiding Rookie Mistakes
Bear with me as we start by making a few mistakes. These are mistakes that
I have often made, and I see lots of beginners make them. By starting out
this way, you’ll see how to avoid them, but also learn a bit about how Android
works. Let’s make the app blow up. It’ll be fun. It’ll teach you how to avoid
doing so when it counts.
6.
http://maven.apache.org
7.
https://www.genymotion.com
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 107

Don’t Forget the Internet Permission
A few things are easy to forget when doing Android programming, and it’s
common to forget to register something in the manifest.
This first mistake is so simple, but it’s common at the beginning of a project.
If you try to access the Internet without listing the Internet permission in the
manifest, your app will get a permissions error. Make sure the manifest file
contains this permission.
Android/android_01_01_simple_request_fails/CurrencyConverter/app/src/main/AndroidManifest.xml
<uses-permission android:name="android.permission.INTERNET" />
Android has a feature and permission system in place to make sure users
know what your app does. For instance, if your app takes pictures, it needs
to register that it uses the android.hardware.camera feature. If it uses the network,
it needs to register that it requests the android.permission.INTERNET permission,
as in the preceding code. The idea is that users will decide what features
and permissions they trust you to use. If a simple tip-calculator applica-
tion, for instance, asks permission to use the Internet, that could make
he user wonder what’s going on behind the scenes. This is designed to keep
the user informed about what apps may be doing and thereby to cut down
on malware.
Other easy-to-forget things that need to go in the manifest are activities
and services. We’ll see some of these later on, but for now remember:
when things go wrong, make sure you have the right stuff registered in
the manifest.
Now, the reason we have to put the Internet permission in place is so that
we can call our currency-conversion API over the network. With the permission
in the manifest, let’s go on to the next mistake.
Don’t Do Networking on the Main Thread
If you remember from the iOS chapter, a cardinal rule of UI programming,
no matter the language or platform, is don’t block the main thread. This means
don’t do any long-running tasks or calculations, especially I/O, on the same
thread that’s rendering the view.
Chapter 4. Android • 108
report erratum  •  discuss

When we did this on iOS we saw that it stopped the view before the
activity indicator showed up. Since we’re in the mode of making mistakes,
let’s see what happens when we do networking on the main thread in
Android.
Java has a venerable API for making web requests, called java.net.HttpURLConnec-
tion. Like many venerable Java APIs, it comes with a lot of red tape. Let’s skip
right past it to something a little more palatable, OkHttp.
Getting OkHttp
The more time you spend working with Android these days, the more often
you’ll run into open source libraries created by the fine folks at Square,
8 the
e-commerce and point-of-sale company. One of these is called OkHttp.
9 In
fact, in the most recent versions of Android, java.net.HttpURLConnection is actually
implemented with OkHttp under the hood.
However, the library is masked from us, so we still have to include it in the
project for our own use. That’s OK, because it gives us an excuse to try out
Gradle’s third-party library support. Open app/build.gradle and add this line to
the dependencies:
Android/android_01_01_simple_request_fails/CurrencyConverter/app/build.gradle
dependencies {
compile fileTree(dir: 'libs', include: ['*.jar'])
compile 'com.android.support:appcompat-v7:23.1.1'
compile 'com.squareup.okhttp:okhttp:2.2.0'
➤
}
This adds a compile-time dependency to the build. The syntax of the library
string is library.package:library-name:version. Android Studio will notice that you
made a change to a Gradle file and warn you that you need to resync with
Gradle. When you sync with Gradle it will notice that you added a depen-
dency. It will then download ‘OkHttp‘ and make it available for use in the
app’s code. Easy! Dependency management that doesn’t get in the way of
writing your app!
Making a Request with OkHttp
Now let’s make a call to the API with the new library. We’ll make the call from
the first entry point into our code, the activity’s onCreate() method.
8.
http://square.github.io
9.
http://square.github.io/okhttp
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 109

Android/android_01_01_simple_request_fails/Curr … sevenapps/currencyconverter/ConvertActivity.java
private static final String LOG_TAG = "[Convert Activity]";
@Override protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_convert);
OkHttpClient client = new OkHttpClient();
// Use this for emulator
// String url = "http://10.0.2.2:3000/convert/USD/EUR.json";
// Use this for genymotion
// String url = "http://10.0.3.2:3000/convert/USD/EUR.json";
String url = "http://10.0.3.2:3000/convert/USD/EUR.json";
Request conversionRequest = new Request.Builder()
.url(url)
.build();
Response response = null;
try {
response = client.newCall(conversionRequest).execute();
String body = response.body().string();
Log.d(LOG_TAG, "Conversion response: " + body);
} catch (IOException e) {
Log.e(LOG_TAG, e.getMessage());
}
}
The onCreate() method is one of the important activity life-cycle methods called
after the activity is created. This is generally where you configure things about
the activity, including the view to display. In here we create a new OkHttpClient
instance, which we’ll use to make the HTTP request.
Next, the Request describes the HTTP request we wish to make, including the
URL to call, and we use the client to execute a call using the Request object.
Finally we use the Android logging method Log.d to create a debug log message
with the body of the response.
Everything’s in order with the code, but if you run this you’ll see how Android
treats attempts to make networking calls on the main thread. The app should
crash, and in the console you should see something like this stack trace:
java.lang.RuntimeException: Unable to start activity ComponentInfo{
com.sevenapps.currencyconverter/com.sevenapps.currencyconverter.ConvertActivity}:
android.os.NetworkOnMainThreadException
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2195)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2245)
...
at dalvik.system.NativeStart.main(Native Method)
You can see that Android is prescriptive about networking from the main
thread—it instantly complains and won’t allow it. Generally, any method on
Chapter 4. Android • 110
report erratum  •  discuss

Android views, fragments, and, like here, activities, are running on the main
thread. Luckily, this code isn’t wasted; it’s just being executed from the wrong
place. We just need to make the network call on a different thread.
Respect the Activity Life Cycle
If you have experience with Java, or even if you don’t, the first thing you may
try to fix the problem we’ve just seen is to use a Java Thread. You can make
this work on Android, and it will even solve the initial problem. However,
threads in Java have their own issues that others have already solved for us.
If you search on the web for how to do multithreading on Android, you’ll
probably find there’s something in the API for these situations—it’s called an
AsyncTask. An AsyncTask gives you access to a thread pool and useful callback
methods to make it easy to execute a batch of work on a background thread.
It looks for all the world like the right solution to our problem is to just throw
our API call in an AsyncTask and voila!—problem solved. This is not directly the
third mistake, but it illustrates the path to making the third mistake. Let’s
follow it and find out where things go wrong.
Android/android_01_02_move_to_async_task/Curren … sevenapps/currencyconverter/ConvertActivity.java
private AsyncTask<String, Void, String> loadConversionTask =
new AsyncTask<String, Void, String>() {
@Override protected String doInBackground(String... params) {
String urlString = params[0];
OkHttpClient client = new OkHttpClient();
Request conversionRequest = new Request.Builder()
.url(urlString)
.build();
Response response = null;
try {
response = client.newCall(conversionRequest).execute();
String body = response.body().string();
return body;
} catch (IOException e) {
Log.e(LOG_TAG, e.getMessage());
}
return null;
}
@Override protected void onPostExecute(String payload) {
conversionComplete(payload);
}
};
private void conversionComplete(String payload) {
Log.d(LOG_TAG, "Conversion response: " + payload);
}
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 111

First we define a variable, loadConversionTask, pointing to an AsyncTask. It defines
three generic types, which stand for the type of input arguments, the type of
progress the task reports (Void is fine if we don’t report progress), and the type
of data to deliver when the task is complete.
The doInBackground() method is called when the task is ready to do the work in
the background. Here we do everything with the API call that we were doing
before in the activity’s onCreate(), returning the string from the response body.
When doInBackground() is complete, the results will be delivered to onPostExecute()
on the UI thread. After the task is complete, we call back to the activity’s con-
versionComplete() method, still simply logging the results. Now, from onCreate()
we tell the task to execute so the work is no longer done on the UI thread.
Android/android_01_02_move_to_async_task/Curren … sevenapps/currencyconverter/ConvertActivity.java
@Override protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_convert);
String url = "http://10.0.3.2:3000/convert/USD/EUR.json";
loadConversionTask.execute(url);
}
If you run the app (make sure the Rails server is running the API first), you
should see something like this in the console:
... D/[Convert Activity]: Conversion response:
{"name":"USD to EUR","rate":"0.9342","numerical_rate":0.9342}
So all is well, right? Well, mostly. We’ve gotten the network call off of the main
thread, which is good, and it returns results to the activity, where we can
make use of them. The problem we’ve introduced here is subtle. We need to
take a few extra steps to see it.
In onCreate() and conversionComplete(), let’s log the hash code of the activity.
Android/android_01_03_illustrating_async_task_p … sevenapps/currencyconverter/ConvertActivity.java
@Override protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
Log.d(LOG_TAG, "Activity Created, hash:" + hashCode());
setContentView(R.layout.activity_convert);
String url = "http://10.0.3.2:3000/convert/USD/EUR.json";
loadConversionTask.execute(url);
}
private void conversionComplete(String payload) {
Log.d(LOG_TAG, "Conversion response: [" +
hashCode() + "], payload: " + payload);
}
Chapter 4. Android • 112
report erratum  •  discuss

This will tell us a unique-ish number for the instance of the activity each time
these methods are executed. Next, we need to make the conversion call run
long so we can perform some gymnastics. Uncomment the code in the API’s
convert controller to make the endpoint run slowly.
API/app/controllers/convert_controller.rb
def convert
# Uncomment to make this call run long
# sleep 10.seconds
@from_currency = params[:from_currency]
@to_currency = params[:to_currency]
@conversion = CurrencyConversion.for(params[:from_currency], params[:to_currency])
@amount = params[:amount]
@conversion_amount = @conversion.for_amount(@amount)
render "convert/convert"
end
Now we’ll run the app, which will kick off the async task. Immediately, we’ll
simulate rotating the device. Refer to the documentation for whichever emu-
lator or simulator you’re using for how to do this. You should see a console
message something like this:
D/[Convert Activity]: Activity Created, hash: 591339157
D/[Convert Activity]: Activity Created, hash: 374076263
D/[Convert Activity]: Conversion response: [591339157]
payload {"name":"USD to EUR","rate":"0.9498",
"numerical_rate":0.9498, "from":"USD", "to":"EUR"}
D/[Convert Activity]: Conversion response: [374076263]
payload {"name":"USD/EUR","rate":"0.9496",
"numerical_rate":0.9496, "from":"USD", "to":"EUR"}
So what happened? After the rotation occurred, a second activity was created.
Then the async task on the first activity completed, and finally the second
activity’s task completed.
This is an insight into the Android activity life cycle that is important for
Android developers to understand. Activities are fairly ephemeral. Any config-
uration changes—most commonly rotating the device, although there are
other kinds—cause the activity to be destroyed and a new one created. This
is a problem because the async task still has an implicit reference to the first
activity, which should be destroyed. This means either that the activity will
leak (or stay around when it should be reaped by the system), or that the
async task will refer to something on the activity that has now become null,
and you’ll get the dreaded NullPointerException.
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 113

This is our subtle mistake: using an async task directly from the activity to
do some long-running work, during which the activity may be destroyed.
AsyncTasks aren’t bad per se. You just need to know how and when to use them.
We can work around this issue a few different ways. One might be to use a
Loader, which we will look at in later days. Today we’ll instead move the net-
working to a Service, where we can safely do our networking off of the main
thread and away from the activity’s life cycle.
All Is Well: Using a Service for Networking
There are a few different kinds of service in the Android API, and a few different
ways to use them, but in general they’re for doing some kind of work and
providing results away from activities. They can be long running or just fire
up, do their jobs, and then complete. They’re a powerful part of the API.
In our case, we want a more single-task type of service, so this one will start
up, call the API, and then broadcast the results to anyone who’s listening,
before completing and shutting down. The type of service made for this job
is called an IntentService.
Creating the IntentService
The workhorse of an IntentService is the onHandleIntent() method, which you can
see here.
Android/android_01_04_intent_service/CurrencyCo … currencyconverter/service/ConversionService.java
@Override protected void onHandleIntent(Intent intent) {
String fromCurrency = intent.getStringExtra(FROM);
String toCurrency = intent.getStringExtra(TO);
Intents are fundamental to how Android works. They tell the system that you
want to do something, but it’s up to some other part of the system to get the
job done. In this way, Intents help Android developers build loosely coupled
components. One of the things they can do is carry around a key/value pair
of extras. In the service here, we treat the Intent as kind of a request object,
with the from and to currency for the conversion stored in extras on the Intent.
Once the service is done using the currencies to request the appropriate rate
from the API, it uses another Intent to broadcast the result.
Android/android_01_04_intent_service/CurrencyCo … currencyconverter/service/ConversionService.java
Intent conversionResultIntent = new Intent(CONVERSION_RESULT_ACTION);
conversionResultIntent.putExtra(CONVERSION_RESULT_EXTRA, body);
LocalBroadcastManager.getInstance(this).sendBroadcast(conversionResultIntent);
Chapter 4. Android • 114
report erratum  •  discuss

It sends the broadcast Intent through the LocalBroadcastManager, which is a
lightweight way to send messages within the app. Check out BroadcastManager
for more complex use cases.
If you’ll recall, the first mistake we talked about was forgetting to update the
manifest when we needed to. One time we need to is when adding a service.
Android/android_01_04_intent_service/CurrencyConverter/app/src/main/AndroidManifest.xml
<service android:name=".service.ConversionService" />
With that added, we’re ready to call the service.
Calling Out to the IntentService
Now, back in the activity you can see how to call out to the service and receive
results when it’s complete. To receive the broadcast, use a BroadcastReceiver—of
course!
Android/android_01_04_intent_service/CurrencyCo … sevenapps/currencyconverter/ConvertActivity.java
private BroadcastReceiver conversionReceiver = new BroadcastReceiver() {
@Override public void onReceive(Context context, Intent intent) {
String result =
intent.getStringExtra(ConversionService.CONVERSION_RESULT_EXTRA);
conversionComplete(result);
}
};
Its onReceive() gets an instance of Intent, from which it unwraps the result “extra”,
which it passes to the conversionComplete() method, like the async task used to.
In onCreate(), we register that receiver using an IntentFilter specifying the constant
for the action that the service used to send the results.
Android/android_01_04_intent_service/CurrencyCo … sevenapps/currencyconverter/ConvertActivity.java
@Override protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_convert);
IntentFilter intentFilter =
new IntentFilter(ConversionService.CONVERSION_RESULT_ACTION);
LocalBroadcastManager.getInstance(this).
registerReceiver(conversionReceiver, intentFilter);
convertCurrency("USD", "EUR");
}
@Override protected void onDestroy() {
LocalBroadcastManager.getInstance(this).unregisterReceiver(conversionReceiver);
super.onDestroy();
}
report erratum  •  discuss
Day 1: How Far Does a Dollar Go? • 115

This IntentFilter picks out the type of intent that specifies the action constant
we created in the conversion service. We register the receiver using the filter
with the LocalBroadcastManager, which will now filter out intents that use different
action constants than CONVERSION_RESULT_ACTION. Finally, since we registered
the receiver, we should also unregister the receiver in onDestroy(), the final
method in the activity life cycle.
The call to convertCurrency() in onCreate() kicks it all off right now, since we still
don’t have a UI. In convertCurrency(), to kick the process off, we create an Intent.
Android/android_01_04_intent_service/CurrencyCo … sevenapps/currencyconverter/ConvertActivity.java
private void convertCurrency(String from, String to) {
Intent convertIntent = new Intent(this, ConversionService.class);
convertIntent.putExtra(ConversionService.FROM, from);
convertIntent.putExtra(ConversionService.TO, to);
startService(convertIntent);
}
private void conversionComplete(String payload) {
Log.d(LOG_TAG, "Conversion response, payload: " + payload);
}
The intent specifies the service’s class as the one we want to use. Then we
put in the currencies for which we want a rate, and finally we start the service.
That was some good iteration. Let’s take a step back and look at what we’ve
covered.
What We Learned on Day 1
We didn’t accomplish a lot feature-wise, but we saw a number of ways to load
data from the web, finally settling on a good solution. When there is more
than one way to do it, it’s important to understand the implications of the
alternatives.
We learned a lot today. We learned how an Android project is structured, the
function of the manifest, and how Gradle manages building and dependency
management.
Then we learned how to make a web request with OkHttp. In fact, we looked at
a few different ways to do it, one wrong, one problematic, and one good. We
saw how AsyncTasks and Services work and where they work best. Finally, we
also saw how to build decoupled components using broadcasts to communi-
cate between them.
Chapter 4. Android • 116
report erratum  •  discuss

Your Turn
To get very far in Android you’ll need to get familiar with the documentation
and tools. Now it’s your turn.
Find
• Google’s official Android documentation site.
• The documentation for Service. Compare the use cases and API of a Service
to the specialized version we used, IntentService.
• The Stack Overflow tags for Android.
10 Look up some questions people
have about threading and networking, and how they’re answered.
• The OkHttp documentation.
Do (Easier)
• For both Genymotion and the emulator, learn how to put the device in
airplane mode, rotate the device, take a screenshot, take a picture with
the camera, simulate a phone call, and simulate GPS location data.
• Find how to install and use the Xamarin Android emulator.
• Deploy the API to some kind of server, perhaps at Heroku,
11 and deploy
the current code to an Android device.
Do (Harder)
• Find how to install Intel HAXM to make the official emulator more usable.
• Look for a Square library called Retrofit. Convert the app to use Retrofit
instead of OkHttp, with a model object for the conversion-rate JSON we get
from the server. Later versions of the sample code use Retrofit, starting
with the version in Android/android_01_05_retrofit, so you can refer to that for
a solution.
Day 2: What Can I Get for a Buck?
Or, Building a Conversion Interface
We’ve got a solid foundation in place for getting data to and from the API.
Now let’s get into building an interface for the app.
10. http://stackoverflow.com
11. http://heroku.com/
report erratum  •  discuss
Day 2: What Can I Get for a Buck? • 117

Building an Interface
To allow the user to be able to do the conversion of one currency to another,
we’ll need an interface. Android’s interface definition is done mostly in XML,
with sensible layout language and a very powerful system for dealing with
device differences. Let’s start by building a form for the user to specify two
currencies and convert an amount in one to an amount in the other.
Creating a Linear Layout
The activity_convert.xml layout is the view that ConvertActivity manages. Here’s the
first line of input fields for currencies.
Android/android_02_01_simple_phone_ui/CurrencyConverter/app/src/main/res/layout/activity_convert.xml
<TextView
android:id="@+id/currency_label"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="@string/currencies"
/>
<LinearLayout
android:id="@+id/currencies"
android:layout_width="match_parent"
android:layout_height="wrap_content">
<EditText
android:id="@+id/from_currency"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:layout_weight="1.0" />
<EditText
android:id="@+id/to_currency"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:layout_weight="1.0" />
</LinearLayout>
A TextView simply displays text, an EditText is a text field, and a LinearLayout is a
layout container that arranges views on the screen linearly. The ID in each
tag allows the view to be referenced in code, and the @+id/foo syntax creates
a new ID. We’ll see how these IDs are made referenceable in just a bit.
Linear layouts are the most basic type of layout. I generally find myself con-
verting linear layouts to the more powerful RelativeLayout, so keep that in mind
for further research. However, this view will work fine as it is here.
Notice there is another really great feature of the platform in the text attribute
of the TextView tag. Localization and internationalization are built right
Chapter 4. Android • 118
report erratum  •  discuss

in—@string/currencies references a string resource, which you can see in this
string resource file.
Android/android_02_01_simple_phone_ui/CurrencyConverter/app/src/main/res/values/strings.xml
<resources>
<string name="app_name">Currency Converter</string>
<string name="hello_world">Hello world!</string>
<string name="action_settings">Settings</string>
<string name="currencies">Currencies</string>
<string name="amounts">Amounts</string>
<string name="convert">Convert</string>
</resources>
Android resources are important to understand because they’re the method
for dealing with not only localization but also layouts for different screen sizes
and orientations and a lot of device differences and configurations.
Finally, to capture the user’s intention to perform a conversion, we have a
button in the UI.
Android/android_02_01_simple_phone_ui/CurrencyConverter/app/src/main/res/layout/activity_convert.xml
<Button
android:id="@+id/convert_button"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="@string/convert"
/>
Again, note the definition of the ID and the use of the string resource. Here’s
how that UI looks on a large Android version 5.0 phone and on a regular
version 4.2.2 phone.
report erratum  •  discuss
Day 2: What Can I Get for a Buck? • 119

Now let’s look at how to get a handle on the view in the activity.
Controlling the View from the Activity
A lot of setup happens in onCreate(). For the activity to be able to control the
view, it generally has to first grab on to a bunch of components in the view,
so we’ll do this in onCreate().
Android/android_02_02_edit_text_events/Currency … sevenapps/currencyconverter/ConvertActivity.java
@Override protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_convert);
IntentFilter intentFilter =
new IntentFilter(ConversionService.CONVERSION_RESULT_ACTION);
LocalBroadcastManager.getInstance(this).
registerReceiver(conversionReceiver, intentFilter);
fromCurrencyField = (EditText) findViewById(R.id.from_currency);
toCurrencyField = (EditText) findViewById(R.id.to_currency);
fromAmountField = (EditText) findViewById(R.id.from_amount);
toAmountField = (EditText) findViewById(R.id.to_amount);
convertButton = (Button) findViewById(R.id.convert_button);
fromAmountField.setText("1.00");
toAmountField.setText("1.00");
convertButton.setOnClickListener(new View.OnClickListener() {
@Override public void onClick(View v) {
convert();
}
});
}
The method setContentView() takes a layout ID and sets the activity’s view to be
the view described in the layout file. Notice this class, R, which is an autogen-
erated class holding named data about resources, such as layouts. Next, to
wire up variables to components from the layout, we use findViewById(), which
again uses R. The components are now accessible from the variable assign-
ments. Next we set some default values in the amount fields.
Finally, we add a click listener to the conversion button.
The Convert button click handler calls convert(), which checks currenciesChanged()
with some rudimentary caching to see if we need to pull down a rate again.
Chapter 4. Android • 120
report erratum  •  discuss

Android/android_02_02_edit_text_events/Currency … sevenapps/currencyconverter/ConvertActivity.java
private void convert() {
if (currenciesChanged()) {
getRate();
} else {
calculateToAmount();
}
}
private boolean currenciesChanged() {
if (currentRate != null) {
String from = fromCurrencyField.getText().toString().toLowerCase();
String to = toCurrencyField.getText().toString().toLowerCase();
if (from.equals(currentRate.from.toLowerCase()) &&
to.equals(currentRate.to.toLowerCase())) {
return false;
}
}
return true;
}
That caching solution isn’t great, we’ll look deeper at it shortly. If the cached
rate object turns out not to match the currency values, we load a new rate.
Android/android_02_02_edit_text_events/Currency … sevenapps/currencyconverter/ConvertActivity.java
private void getRate() {
String from = fromCurrencyField.getText().toString();
String to = toCurrencyField.getText().toString();
if (from != null && to != null && from.length() == 3 && to.length() == 3) {
getRate(from, to);
}
}
private void getRate(String from, String to) {
Intent convertIntent = new Intent(this, ConversionService.class);
convertIntent.putExtra(ConversionService.FROM, from);
convertIntent.putExtra(ConversionService.TO, to);
startService(convertIntent);
}
private void rateLoaded(ConversionRate newRate) {
currentRate = newRate;
calculateToAmount();
}
private void calculateToAmount() {
if (currentRate != null) {
Float toAmount = currentRate.convert(fromAmountField.getText().toString());
String formattedToAmount = String.format("%.2f", toAmount);
toAmountField.setText(formattedToAmount);
}
}
report erratum  •  discuss
Day 2: What Can I Get for a Buck? • 121

This method uses the currency-conversion service, as we saw yesterday;
there’s nothing different here except for organization. The calculateToAmount()
method uses the rate object to calculate a converted amount and then formats
a string to put into the UI. Pretty straightforward. Let’s add one more thing
to make the caching solution work.
Saving Instance Data
This point about caching the rate object on the activity is related to something
we saw yesterday: whenever a configuration change, such as a device rotation,
occurs, the activity is destroyed and a new one is created. That means any
data stored in instance variables won’t be present in the new activity. Android
has a process for dealing with this issue. Before an activity is destroyed,
saveInstanceState() is called with a Bundle.
Android/android_02_03_save_instance_state/Curre … sevenapps/currencyconverter/ConvertActivity.java
@Override protected void onSaveInstanceState(Bundle outState) {
super.onSaveInstanceState(outState);
outState.putSerializable(CURRENT_RATE, currentRate);
}
The system will save the Bundle object and then hand it back into the onCreate()
of the new activity. Then we need to check to see if we have some saved state
and grab what we need out of it.
Android/android_02_03_save_instance_state/Curre … sevenapps/currencyconverter/ConvertActivity.java
if (savedInstanceState != null) {
currentRate = (ConversionRate) savedInstanceState.getSerializable(CURRENT_RATE);
} else {
fromAmountField.setText("1.00");
toAmountField.setText("1.00");
}
Now we’ve got a view in place that works pretty well on phones. It doesn’t
look the best on tablet-size screens, though. It’s very easy to fix this using
Android’s resource system, so let’s do that now.
Creating a View for Tablets
Before adapting the view for a tablet-size screen, we need to convert the cur-
rent view from being controlled by an activity to being controlled by a fragment.
Fragments were introduced in API level 11 (version 3.0), when tablet support
was first added. The idea of an activity, as we’ve seen, is to control a screenful
of data. As Android grew from supporting only phone-size screens to support-
ing tablets as well, the SDK needed some more flexibility.
Chapter 4. Android • 122
report erratum  •  discuss

A fragment is intended to act as sort of a subcontroller, to control a view that
may or may not make up part of a larger view. This allows Android’s already
flexible resource system to handle phone and tablet views by composing a
screen full of fragments into an activity for the larger screens while simply
using individual fragments for smaller screens. The first step in our conversion
is to create a fragment.
Creating a Fragment
A fragment instance looks similar to an activity, except that it extends Fragment.
Android/android_02_04_fragment/CurrencyConverte … /currencyconverter/fragment/ConvertFragment.java
public class ConvertFragment extends Fragment {
It also has many of the same-named life-cycle methods as an instance of
Activity, such as onCreate(), onDestroy(), and onStart(), which you can see here—we
move them straight across from the activity.
Android/android_02_04_fragment/CurrencyConverte … /currencyconverter/fragment/ConvertFragment.java
@Override public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
IntentFilter intentFilter =
new IntentFilter(ConversionService.CONVERSION_RESULT_ACTION);
LocalBroadcastManager.getInstance(getActivity()).
registerReceiver(conversionReceiver, intentFilter);
if (savedInstanceState != null) {
currentRate = (ConversionRate) savedInstanceState.getSerializable(CURRENT_RATE);
}
}
@Override public void onDestroy() {
LocalBroadcastManager.getInstance(getActivity()).
unregisterReceiver(conversionReceiver);
super.onDestroy();
}
@Override public void onStart() {
super.onStart();
fromCurrencyField = (EditText) getView().findViewById(R.id.from_currency);
toCurrencyField = (EditText) getView().findViewById(R.id.to_currency);
fromAmountField = (EditText) getView().findViewById(R.id.from_amount);
toAmountField = (EditText) getView().findViewById(R.id.to_amount);
convertButton = (Button) getView().findViewById(R.id.convert_button);
convertButton.setOnClickListener(new View.OnClickListener() {
@Override public void onClick(View v) {
convert();
}
});
}
report erratum  •  discuss
Day 2: What Can I Get for a Buck? • 123

Actually, onStart() is a life-cycle method of an activity, but we didn’t have it
implemented. We need to implement it in the fragment, because only then
will we have a view available.
Speaking of the view, we create that in a slightly different way here, because
our fragment will be created in a slightly different way than the activity was.
We create the fragment’s view by overriding onCreateView().
Android/android_02_04_fragment/CurrencyConverte … /currencyconverter/fragment/ConvertFragment.java
@Override public View onCreateView(
LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
return inflater.inflate(R.layout.conversion_form, container, false);
}
This method uses a LayoutInflater to inflate, or create a view from, a layout defi-
nition, which we create in app/src/main/res/layout/conversion_form.xml. This file contains
all the XML that was previously in the activity’s layout. We’ll do this because
the fragment will be created when setLayout() is called in the activity’s onCreate()
once we make this change to the activity’s layout.
Here is that fragment definition in the activity’s layout.
Android/android_02_04_fragment/CurrencyConverter/app/src/main/res/layout/activity_convert.xml
<fragment
android:id="@+id/convert_form"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:name="com.sevenapps.currencyconverter.fragment.ConvertFragment" />
We can give the fragment an ID, a width, a height, and other attributes, just
like any component. The name attribute is what ties its instantiation to the
class we just created.
Run the app, and you should see exactly what you saw before, but this time
the fragment will be in control of the UI elements. Now we’re in a good place
to create a layout that will work on tablet-size screens.
Creating a Layout for Larger Screens
You might be surprised at how simple this next part is. I think it’s one of the
most well-conceived parts of the platform. Dealing with different-size screens
is just another part of the Android resource system.
We create another layout file, called activity_convert.xml, except this one is placed
inside app/src/main/res/layout-sw600dp/, whereas the one we’ve been working with
was in app/src/main/res/layout/. The sw600dp part of the directory name is called a
size qualifier, and in particular, this is a smallest-width qualifier.
Chapter 4. Android • 124
report erratum  •  discuss

When the activity’s onCreate() calls setContentView(), Android goes to find the layout
file specified. Before it looks, it takes into account some of the device’s
attributes, such as the current language preference, orientation, and screen
size. It’s possible that the developer could have created distinct layouts for
each possible state of all of those attributes.
If it doesn’t find distinct layouts for all of the current values of state, it starts
to get more general in its search, finally falling back to looking in just layout.
We’ve created a layout with a size qualifier of sw600dp, which says, “If the
current device’s smallest width (sw) is at least 600dp (dependency-independent
pixels), choose this layout.” The smallest width of a device is defined as the
shortest side of the rectangle defined by the screen. Here is that layout.
Android/android_02_05_tablet_layout_01/Currency … src/main/res/layout-sw600dp/activity_convert.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
android:gravity="center"
tools:context=".ConvertActivity">
<fragment
android:id="@+id/convert_form"
android:layout_width="@dimen/convert_form_width"
android:layout_height="match_parent"
android:name="com.sevenapps.currencyconverter.fragment.ConvertFragment" />
</LinearLayout>
Now it looks the same as the unqualified layout, except for the gravity="center",
which will center the fragment.
We can use the resource system to specify the dimensions to be used inside
layouts. Here we define a width for the form to use if any width of the screen
is at least 600dp. In other words, if the screen’s width, considering the current
orientation, is ever at least 600dp wide, this dimension will be used.
Android/android_02_05_tablet_layout_01/CurrencyConverter/app/src/main/res/values-w600dp/dimens.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
<dimen name="convert_form_width">500dp</dimen>
</resources>
report erratum  •  discuss
Day 2: What Can I Get for a Buck? • 125

If you’re trying to specify a specific layout for landscape only, it’s also possible
to use layout-land.
Running the app in a tablet emulator and a phone emulator will allow you to
see what we’ve done with just a few quick changes.
Now we have a usable UI that allows the user to convert a given amount.
What We Learned on Day 2
Today we covered a lot about Android UIs. We talked about defining layouts
and visual components and how to reference and control them from an Activity.
We also saw how to make the UI more flexible using Fragments and Android’s
resource qualifier system.
Your Turn
Now it’s your turn. Look into more documentation, and try to dig in and write
some code yourself.
Find
• Documentation for the Activity life cycle
• Documentation for the Fragment life cycle
• Android’s resource qualifiers and how they work for layouts, values, and
strings
Chapter 4. Android • 126
report erratum  •  discuss

Do (Easier)
• Try reimplementing the view we have using a RelativeLayout instead of a
LinearLayout. What parts are easy? What parts are hard?
• Show progress. When we’re loading the rate from the network, display a
progress bar so the user knows the app is busy.
Do (Harder)
• So far we only expect the user to put in an amount under the left-side
currency. Respond appropriately if the user changes the right-side
amount—fill out the left-side amount with a converted amount.
• It may be a bit much to expect users to know the currency codes they
care about. Search online for a list of currency codes. Change the view
from using EditText components to using Spinner components instead, filled
with a list of common currency codes.
Day 3: Time Is Money
Or, Keeping a History of Conversions
Today we’ll store history. When a user does a currency conversion, he’s
probably on a trip somewhere, and there’s a good chance he won’t have
Internet access all the time.
We’ll keep a local record of each conversion the user does, so in the case that
he’s offline, he can refer back to the last rate he loaded. It may not be the
most up-to-date rate, but chances are it will still be close enough to be useful.
Keeping a History of Conversions
To keep the history of conversions, we’ll write data to a local SQLite database.
To do this we’ll need to look at how to reference a database and get it set up
the first time it’s used.
Writing History Records
Working with SQLite on Android requires an understanding of the SQL lan-
guage. Developers coming from a service-side background generally want to
find some kind of Android object relational mapping library, or ORM, but given
things like the resource limitations of mobile devices, one of these libraries
never seems to gain traction for general development.
That means you usually need to fall back to the old approach of munging
strings and variables together into SQL statements. Android’s API helps with
report erratum  •  discuss
Day 3: Time Is Money • 127

the creation and version management of the database. It does this by providing
a SQLiteOpenHelper. We’ll extend that to create a DatabaseHelper for our app.
Creating a Conversion Record Contract and DatabaseHelper
When working with a local database, Android recommends creating a contract,
which is simply a set of constants you can use to refer to strings such as
column and table names.
For this app, let’s store the contract as an inner class of a class that models
the data, .model.ConversionRateHistoryRecord. Here’s an example of the contract in
use, constructing a CREATE statement for the table.
Android/android_03_01_write_conversion_history/ … converter/model/ConversionRateHistoryRecord.java
public static String createStatement() {
return "create table " + ConversionHistoryRecord.TABLE_NAME + " (" +
ConversionHistoryRecord._ID
+ " integer primary key," +
ConversionHistoryRecord.FROM_CURRENCY_COLUMN
+ " text," +
ConversionHistoryRecord.TO_CURRENCY_COLUMN
+ " text, " +
ConversionHistoryRecord.RATE_COLUMN
+ " real, " +
ConversionHistoryRecord.AMOUNT_COLUMN
+ " real, " +
ConversionHistoryRecord.TIMESTAMP_COLUMN
+
" datetime default current_timestamp)";
}
Note that _ID is inherited from the interface BaseColumns, which our contract
class implements. Next we’ll create an instance of a SQLiteOpenHelper as an
interface and utility class for the database.
Android/android_03_01_write_conversion_history/ … napps/currencyconverter/data/DatabaseHelper.java
public class DatabaseHelper extends SQLiteOpenHelper {
public static final int VERSION = 1;
public static final String DATABASE_NAME = "conversion_database.db";
public DatabaseHelper(Context context) {
super(context, DATABASE_NAME, null, VERSION);
}
@Override public void onCreate(SQLiteDatabase db) {
db.execSQL(ConversionHistoryContract.createStatement());
}
@Override public void onUpgrade(
SQLiteDatabase db, int oldVersion, int newVersion) {
// No action this version
}
The superclass’s constructor handles getting the database by name and
deciding whether to perform a create or upgrade on the database. If the
Chapter 4. Android • 128
report erratum  •  discuss

database file doesn’t exist, onCreate() will be called, where we should issue
create statements to the database.
If the version number has changed since the last time the open helper was
used, onUpgrade() will be called, in which case we should migrate data and get
the database into shape for the current version. Therefore, to trigger an
upgrade, increase the value of the version number passed to super() in the
constructor.
These methods deal with getting the database created and structurally ready
for data. Now let’s look at getting data into the database.
Inserting a Record
In a method called insertHistoryRecord() on the database helper, we’ll accept a
history record model, which is just a value object with attributes for each
column. Putting methods dealing with data directly on the database helper
probably isn’t a scalable pattern to follow, but it’s good enough for now.
Android/android_03_01_write_conversion_history/ … napps/currencyconverter/data/DatabaseHelper.java
public void insertHistoryRecord(ConversionRateHistoryRecord record) {
SQLiteDatabase database = getWritableDatabase();
ContentValues values = record.toContentValues();
database.insert(
ConversionHistoryContract.ConversionHistoryRecord.TABLE_NAME,
null,
values
);
}
Here you can see that the database’s insert() method takes an object of type
ContentValues, which we have the value object generate and populate for us.
This is essentially a key/value pair of column names to values.
We’ll insert a history record each time we do a conversion, right in the service
where the rate is loaded.
Android/android_03_01_write_conversion_history/ … currencyconverter/service/ConversionService.java
DatabaseHelper databaseHelper = new DatabaseHelper(this);
ConversionRateHistoryRecord record =
ConversionRateHistoryRecord.fromRate(rate, amount);
databaseHelper.insertHistoryRecord(record);
Easy enough. Fire up the simulator or emulator of your choice and do a few
conversions so we have some data. Then we can go look at the database.
report erratum  •  discuss
Day 3: Time Is Money • 129

Using ADB Shell to View the Data
Testing with an actual device is always ideal with mobile development.
Sometimes the emulator or simulator has a leg up, though, such as when
you want to view the database. It’s possible to get to data on a rooted device,
but it’s harder, and you may not want to deal with rooting your device.
Here are the commands to get to and view the data.
$ adb devices
List of devices attached
10.71.34.101:5555
device
$ adb -s 10.71.34.101:5555 shell
$ cd /data/data/com.sevenapps.currencyconverter/databases
$ sqlite3 conversion_database.db
The command-line utility adb is the Android Debug Bridge, which can connect
to Android systems from a computer. The sequence of commands here is:
1.
Ask for a list of attached devices.
2.
Connect a shell session to the device specifying the device’s name.
3.
Navigate to the data directory for our app.
4.
Start a SQLite session.
With SQLite connected, we can query the database using SQLite commands.
sqlite> select * from conversion_history_records;
1|USD|EUR|0.917900025844574|50.0|2015-04-04 20:26:41
Here you can see there’s one record, U.S. dollars to euros, which stores the
rate, amount, and date. After a few more conversions, run the query again.
sqlite> select * from conversion_history_records;
1|USD|EUR|0.917900025844574|50.0|2015-04-04 20:26:41
2|USD|NOK|8.02449989318848|20.0|2015-04-04 20:35:38
3|USD|RUB|56.8165016174316|50.0|2015-04-04 20:35:41
So we know that we have history records being written into the database.
Now we can create a view to see the history in the app.
Viewing Conversion History
We’ll use two new Android classes to deal with loading and displaying history
records, a Loader and Android’s new RecyclerView.
Loading History Records
We spent a good amount of time the first day talking about how it’s important
not to execute long-running tasks on the main thread. The example we saw
Chapter 4. Android • 130
report erratum  •  discuss

then was with networking. Loading from the database is another case of an
I/O operation that takes time and should be performed in the background.
To do this, we’ll use a Loader in conjunction with a LoaderManager. A Loader is
Android’s modern way to load data in an activity or fragment. The loader
knows how to load data off the main thread and how to reconnect to a running
loader and redeliver results if, for instance, the device goes through a config-
uration change.
To get history records, we’ll use an AsyncTaskLoader and then display them in a
new fragment. The fragment will implement an interface called LoaderCallbacks,
which is where the loader will deliver results.
Android/android_03_02_read_conversion_history/C … onverter/fragment/ConversionHistoryFragment.java
public class ConversionHistoryFragment extends Fragment
implements LoaderManager.LoaderCallbacks<ArrayList<ConversionRateHistoryRecord>> {
The loader itself does the work in a method called loadInBackground(). It instanti-
ates a database helper and loads all the history records. The callbacks deal
with creating, resetting, and receiving results from the loader.
Android/android_03_02_read_conversion_history/C … onverter/fragment/ConversionHistoryFragment.java
private static class HistoryRecordLoader
extends AsyncTaskLoader<ArrayList<ConversionRateHistoryRecord>> {
public HistoryRecordLoader(Context context) { super(context); }
@Override public ArrayList<ConversionRateHistoryRecord> loadInBackground() {
DatabaseHelper databaseHelper = new DatabaseHelper(getContext());
ArrayList<ConversionRateHistoryRecord> records =
databaseHelper.getAllHistoryRecords();
return records;
}
}
// Callbacks
@Override public Loader onCreateLoader(int id, Bundle args) {
if (id == HISTORY_LOADER_ID) {
return new HistoryRecordLoader(getActivity());
}
return null;
}
@Override public void onLoadFinished(
Loader<ArrayList<ConversionRateHistoryRecord>> loader,
ArrayList<ConversionRateHistoryRecord> records) {
recyclerView.setAdapter(new ConversionHistoryAdapter(records));
}
@Override public void onLoaderReset(
Loader<ArrayList<ConversionRateHistoryRecord>> loader) {
}
report erratum  •  discuss
Day 3: Time Is Money • 131

When you issue a request to create a loader, you pass an ID and an optional
bundle of arguments. This way a loader’s host activity or fragment can deal
with multiple loaders.
When the loader is finished, it will deliver its results to onLoadFinished(). Since
we have only one loader, we can expect it to be of the type we want. When we
get results now, we set them into the recycler view’s adapter. We’ll look at
that process in a second.
If a loader is reset, we can deal with what to do here. This is a fairly naive
implementation of the callbacks, but the framework is in place to deal with
things like cached results.
Now we have a system in place to safely load data from the database and
have the results delivered to the fragment. Next we’ll get those results dis-
played in the view.
Adding a Recycler View and Adapter
Google recently introduced a new component for displaying repeating data,
the RecyclerView. The older ListView is great for displaying a list of data, but for
more flexible presentations of collections of data the recycler view uses a
separate layout manager strategy.
For the list of history records we’ll display here, a ListView would be just fine,
but I thought you might like to get a look at how a RecyclerView works.
First of all, we need to tell Gradle that we want to get the library containing
the support recycler view, in case the OS we’re running on doesn’t include it
already.
Android/android_03_02_read_conversion_history/CurrencyConverter/app/build.gradle
dependencies {
compile fileTree(dir: 'libs', include: ['*.jar'])
compile 'com.android.support:appcompat-v7:23.1.1'
compile 'com.android.support:recyclerview-v7:22.0.0'
➤
compile 'com.squareup.okhttp:okhttp:2.2.0'
compile 'com.squareup.okhttp:okhttp-urlconnection:2.2.0'
compile 'com.squareup.retrofit:retrofit:1.9.0'
}
After a Gradle sync, we’ll be ready to place a recycler view in the layout for
displaying history records.
Chapter 4. Android • 132
report erratum  •  discuss

Android/android_03_02_read_conversion_history/C … /src/main/res/layout/conversion_history_list.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:orientation="vertical"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:background="@color/grey_background">
<TextView
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="@string/history"
android:textSize="@dimen/title_text_size"
/>
<android.support.v7.widget.RecyclerView
android:id="@+id/recycler_view"
android:scrollbars="vertical"
android:layout_width="match_parent"
android:layout_height="match_parent"/>
</LinearLayout>
Then, in the fragment’s onStart(), we get a reference to the recycler view from
the layout and configure it a bit. Since the items for each history record aren’t
of varying size, we tell the recycler view that it has a fixed size. This results
in a slight performance improvement. Next we tell the recycler view to use a
LinearLayoutManager, which will display the list items in a vertical list.
Android/android_03_02_read_conversion_history/C … onverter/fragment/ConversionHistoryFragment.java
@Override public void onStart() {
super.onStart();
recyclerView = (RecyclerView) getView().findViewById(R.id.recycler_view);
recyclerView.setHasFixedSize(true);
recyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
getLoaderManager().initLoader(HISTORY_LOADER_ID, null, this).forceLoad();
}
Finally, the last line tells the loader manager to start our history loader. That
will load the history and set the history ArrayList into the recycler view’s adapter.
An instance of Adapter is Android’s pattern for providing data to a few different
types of components, and the recycler view has its RecyclerView.Adapter, which
we extend here.
report erratum  •  discuss
Day 3: Time Is Money • 133

Android/android_03_02_read_conversion_history/C … onverter/fragment/ConversionHistoryFragment.java
private static class ConversionHistoryAdapter
extends RecyclerView.Adapter<ConversionHistoryAdapter.HistoryRecordViewHolder> {
private ArrayList<ConversionRateHistoryRecord> records;
public static class HistoryRecordViewHolder extends RecyclerView.ViewHolder {
private final TextView label;
private final TextView dateLabel;
public HistoryRecordViewHolder(View itemView) {
super(itemView);
label = (TextView) itemView.findViewById(R.id.history_label);
dateLabel = (TextView) itemView.findViewById(R.id.date_label);
}
}
public ConversionHistoryAdapter(ArrayList<ConversionRateHistoryRecord> records) {
this.records = records;
}
@Override public int getItemCount() {
return (records == null) ? 0 : records.size();
}
@Override
public HistoryRecordViewHolder onCreateViewHolder(ViewGroup parent, int i) {
View view = LayoutInflater.from(parent.getContext())
.inflate(R.layout.conversion_history_item, parent, false);
return new HistoryRecordViewHolder(view);
}
@Override
public void onBindViewHolder(HistoryRecordViewHolder viewHolder, int i) {
ConversionRateHistoryRecord record = records.get(i);
viewHolder.label.setText(record.toHTML());
viewHolder.dateLabel.setText(record.date.toString());
}
}
First, the adapter’s data is a list of ConversionRateHistoryRecords. The adapter uses
a view holder to cache references to the view’s components through a sort of
proxy object. That’s because findViewById() is an expensive call. By performing
that lookup only once per view, we can keep the list more performant during
scrolling.
The adapter’s getItemCount() tells the recycler view how many items it needs to
display in full. When the recycler view knows it needs to create a new view
holder, it calls onCreateViewHolder(). From that method we inflate the view and
return it wrapped in a view holder. The recycler view will cache this view
holder for later reuse—again, to increase performance.
Chapter 4. Android • 134
report erratum  •  discuss

When scrolling through the list, the recycler view will reuse the view holders
it holds in cache. When a previously instantiated view holder is ready for
reuse, onBindViewHolder() is called so we can put in the appropriate data.
With the loader and the recycler view in place, we’re ready to display the
fragment on the screen within the activity’s view.
Displaying History Records for Phone Screens
In the activity’s most general layout, which will end up on most regular-size
phones, let’s display the history list underneath the conversion form.
Android/android_03_02_read_conversion_history/C … ter/app/src/main/res/layout/activity_convert.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
tools:context=".ConvertActivity">
<fragment
android:id="@+id/convert_form"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:name="com.sevenapps.currencyconverter.fragment.ConvertFragment"/>
<fragment
android:id="@+id/history_list"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:name="com.sevenapps.currencyconverter.fragment.ConversionHistoryFragment"
/>
</LinearLayout>
This will work because in this layout the linear layout is configured using the
vertical orientation. Run the app in a phone emulator to have a look.
Remember that the history list will load only once for right now, because we’re
not reloading it when new records are inserted.
Displaying History Records for Tablet Screens
On tablet screens, or rather on screens where the smallest width is 600dp,
the linear layout’s orientation is horizontal and its gravity is set to center.
Android/android_03_02_read_conversion_history/C … src/main/res/layout-sw600dp/activity_convert.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
report erratum  •  discuss
Day 3: Time Is Money • 135

xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="horizontal"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
android:gravity="center"
tools:context=".ConvertActivity">
<fragment
android:id="@+id/convert_form"
android:layout_width="@dimen/convert_form_width"
android:layout_height="match_parent"
android:name="com.sevenapps.currencyconverter.fragment.ConvertFragment" />
<fragment
android:id="@+id/convert_history_fragment"
android:layout_width="@dimen/history_width"
android:layout_height="match_parent"
android:layout_marginLeft="@dimen/activity_horizontal_margin"
android:name="com.sevenapps.currencyconverter.fragment.ConversionHistoryFragment"
/>
</LinearLayout>
This will display the conversion form and history list side-by-side. For larger
“phablet” phones this layout works fine in both orientations, but the tablet
sizing doesn’t quite work. We can fix this by having different dimension
resources for each of the appropriate size qualifiers.
Android/android_03_02_read_conversion_history/C … verter/app/src/main/res/values-w600dp/dimens.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
<dimen name="convert_form_width">400dp</dimen>
<dimen name="history_width">247dip</dimen>
</resources>
Here, for the w600dp qualifier we have one size for each of the form and history
widths, and then for the w820dp qualifier we have a different set.
Android/android_03_02_read_conversion_history/C … verter/app/src/main/res/values-w820dp/dimens.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
<dimen name="activity_horizontal_margin">64dp</dimen>
<dimen name="convert_form_width">500dp</dimen>
<dimen name="history_width">308dip</dimen>
</resources>
Remember that the w qualifier means the current width, taking into account
orientation, whereas sw means the smallest width, or smallest side of the
screen. Now running the app in emulators or simulators of a few different
Chapter 4. Android • 136
report erratum  •  discuss

sizes will show us how the view looks on a few different devices. The figure
here shows a small phone in portrait orientation, a large phone in landscape,
and a tablet in portrait.
Great—the history is loaded and displayed, taking into account the screen
characteristics of the current device. Let’s do one last thing: make it so that
as each rate history record is created, the history list keeps up-to-date.
Automatically Reload on History Changes
To tell the history list to reload, we need a way to know when each record is
inserted. We’ve already seen a pattern like this at work when a rate is loaded.
We can just add a broadcast after the rate is inserted:
Android/android_03_03_listen_for_changes_to_his … currencyconverter/service/ConversionService.java
Intent historyUpdateIntent = new Intent(HISTORY_UPDATE_ACTION);
broadcastManager.sendBroadcast(historyUpdateIntent);
And then add a broadcast receiver to the fragment:
Android/android_03_03_listen_for_changes_to_his … onverter/fragment/ConversionHistoryFragment.java
private BroadcastReceiver historyReceiver = new BroadcastReceiver() {
@Override public void onReceive(Context context, Intent intent) {
historyUpdated();
}
};
That will tell the loader manager to reload the history loader:
Android/android_03_03_listen_for_changes_to_his … onverter/fragment/ConversionHistoryFragment.java
private void historyUpdated() {
getLoaderManager().getLoader(HISTORY_LOADER_ID).forceLoad();
}
report erratum  •  discuss
Day 3: Time Is Money • 137

Run the app, and you should see the history list keep up-to-date with each
conversion you perform.
What We Learned on Day 3
Today we took our app to the next level by providing the user with a local
history of conversions, so he can refer to previous rates while offline. Doing
this took us through working with SQLite in Android and the SQLiteOpenHelper.
Then we saw how to use a Loader and the LoaderManager to load the conversion
history data from the database. Once we got those results, we put the data
into a RecyclerView to show them to the user. Finally, we made the view even
more flexible by working out layouts for small phones, large phones, and
tablet-size devices.
Your Turn
Now it’s your turn. Here are some things you could read up on and try for
further study.
Find:
• Documentation for ADB. Read up and see what you’re able to do with it.
• The documentation for Gradle and Android. So far we’ve been doing builds
only through Android Studio. See if you can build and deploy to an emu-
lator using only Gradle from the command line.
• The documentation for Loader. Look through the API fully, and see how it
could help you do some of these next few things.
Do (Easier)
• Format the date in the history record list.
• Use a translation service, such as Google Translate,
12 to translate all of
the strings in app/src/main/res/values/strings.xml into a few different languages.
Create string files for those locales, and test them out by changing the
device’s language.
Do (Harder)
• Read up on and try out OkHttp caching and how to use it with Retrofit.
Cache the rate data and see how it works both offline and online.
12. http://translate.google.com
Chapter 4. Android • 138
report erratum  •  discuss

• Cache the currency rates in the local database. Come up with a strategy
for when to reload a rate from the network based on when it was loaded.
Using the Loader to your advantage may be a good way to do this.
• Read up on Android’s ContentProvider class. Try using one to create an
interface that other apps use to do currency conversions using our app.
• Try using a CursorLoader instead of an AsyncTaskLoader to load history records.
A CursorLoader takes advantage of the database better.
Wrapping Up Android
We’ve done some fairly advanced Android development with this app. Of
course, we’ve used only a few of the many APIs in the platform, but you should
have a firm foundation for forging on with your Android development.
Strengths
As with iOS, probably the greatest strength of the Android platform is its
popularity and the number of users you can reach with your apps. When
you’re considering building any mobile application, Android has to be a part
of the strategy.
Google also makes it really easy to get your apps to your users. When you
compare beta testing, putting your app in the Play Store, and shipping bug
fixes and revisions to the same processes for iOS, it’s almost laughable how
much less friction there is with Google’s processes.
When it comes to tools, coding, and APIs, Android really shines. Android
Studio is one of the best IDEs I’ve ever used. Gradle is an easy-to-use but
very deep and powerful build tool and dependency manager. I also think
Android’s XML layouts system and resource qualifiers are one of the best
solutions to the problem of view definition for multiple device configurations.
Java isn’t the most fun or modern language out there, but Android Studio
makes it much easier to work with. The APIs that Android makes available
are great and pretty easy to work with, too. What’s unique and interesting
about the platform is how your app can fit into the ecosystem of apps on a
user’s device. We didn’t look very far into that, but with things like content
providers or widgets, which work from the user’s Android home screen, you
can provide more to your users than just an in-app experience.
Finally, Android has a very strong community of people making great libraries,
teaching best practices, and generally making our lives as developers better.
report erratum  •  discuss
Wrapping Up Android • 139

Weaknesses
The biggest complaint Android developers have is the sheer number of strange,
quirky devices they have to support. That number multiplied by the number
of SDKs still in popular use makes for a daunting support matrix. If your app
has any features that really push the SDK, you’ll have a lot of testing and
support to do.
Android’s SDKs have had some really great growth and modernization lately.
Sometimes this is a bit depressing, though, because it’s not always possible
to use the new ways of doing things when you have to target older SDKs.
One final thing to mention is that in Android it can be difficult for beginners
to come up to speed. Android pushes some complex patterns in its APIs. You
need to study the documentation or follow the community to find out the best
practices for what you want to do. You experienced this a bit on Day 1, when
we saw how easy it is to fall into some traps when doing networking.
Final Thoughts on Android
There’s no way around it these days: your app needs to be on Android. It’s
everywhere. Luckily, with a little study and experience it’s not hard to be a
proficient Android developer.
Chapter 4. Android • 140
report erratum  •  discuss

CHAPTER 5
Universal Windows Platform
When I was growing up, my family had a Windows computer. I remember lots
of computing milestones on it. Games (Doom, the first Duke Nukem, Myst),
connecting to the Internet (Netscape Navigator over a Winsock connection to
a modem pool using my mom’s shell account at the university she worked
for), cursing IRQ settings for new hardware—things like that. I remember
how excited I was when Windows 95 came out, just because it looked so much
better than Windows 3.1. A lot of my early development experience was on a
Windows computer, too. I remember feeling smug because I ran Windows
2000 instead of the inferior home versions. I guess that I would say I learned
programming on a Windows computer.
However, all of the substantive server-side programming I did was on a POSIX-
compliant system.
1 And certainly, at the time the mobile revolution hit with
the first iPhone, I was already using a Mac. It seems to me that most mobile
development happened outside of the Windows ecosystem. It’s unlikely that
any iPhone development is happening on Windows, and a lot of Android
development is on Mac.
But when Windows Phone was first introduced in 2010, there was a lot to
like. The interface seemed futuristic compared to the other platforms and had
a lot of features that have since been adopted by the others. And now, with
the release of Windows 10 and the Universal Windows Platform (UWP), it’s
possible to build apps for Windows phones, tablets, and desktops.
2
Windows on mobile devices may or may not be able to rise from its third-place
platform status among mobile users; there seems to be interest in Microsoft’s
strategy of a more powerful laptop/tablet hybrid, and the SDKs have a lot of
1.
https://en.wikipedia.org/wiki/POSIX
2.
https://msdn.microsoft.com/library/windows/apps/dn894631.aspx
report erratum  •  discuss

power available for developers who are willing to take the plunge into Windows
Phone development. With the Universal Windows Platform, the apps those
developers can create are easily available on Windows 10 computers as well.
A Stock-Quote App
This week we’ll build a stock-quote app. It lets the user see the latest quotes
for a few famous stock markets, such as the NASDAQ Composite and the
FTSE 100. It also allows the user to define a list of stock symbols in a watch
list and see the latest quote for each of those symbols. The app uses the
/stock_quote endpoint, which will provide stock quotes in JSON given a list of
one or more stock symbols, optionally comma-separated for multiple quotes
at one time.
We’ll build the app using the Universal Windows Platform. This allows us to
build an app that will run in almost any Windows environment: Windows
phones, tablets, desktop computers, even the Xbox. Testing this app on the
Xbox is outside of our scope this week, but if you can imagine an app that
will work well on any combination of those platforms, at the end of this week
you’ll be ready to build it.
We’ll build the app in Visual Studio, using C# and XAML to define the logic
and views. We’ll test the app on both a Windows phone and a Windows
desktop computer, and ultimately define an interface that will work on either
of those devices’ screen sizes. On the first day we’ll get the project set up,
load stock-index data from the API, deserialize it, and then display the data
Chapter 5. Universal Windows Platform • 142
report erratum  •  discuss

on the screen. On the second day we’ll improve the view by displaying the
data in a styled stock-quote list for the stock indexes. Then we’ll give the user
an interface to add stock symbols to watch. For the final day we’ll finish up
the watch list by storing the symbols in local storage. Then we’ll add a stock-
quote detail screen and make it a reusable component that the user can reach
from either the index list or the watch list. We’ll also make the view adapt
itself to different screen geometries, so the user will have an appropriate view
on the desktop app compared to the phone app. Finally we’ll add a live tile
with the performance of the first three stocks in the user’s watch list, allowing
her to see data from the app on the app’s tile. Let’s get started!
Day 1: The Initial Investment
Or, Setting Up a Solution and Loading Quotes
Today we’ll start off by creating a project in Visual Studio. Then we’ll load
some data from the API. We’ll look at a few ways to deserialize the JSON data
we get back. Then we’ll put the data in the view and look at data binding, a
method of getting data changes automatically wired up to view updates. First
off, creating a new project.
Creating a Solution
Let’s get started by opening Visual Studio and creating a solution from the
menu that appears. It should use the Blank App (Universal Windows) Visual
C# template, with .NET Framework 4.6.1. Let’s call it Stocks, which isn’t
super imaginative, but hey, it’s the right size for the name of an app on a
smartphone.
Once the solution is created and files are generated, you’ll see something like
the following tree of items in the Solution Explorer, on the left side of the IDE.
/
└──Solution 'Stocks' (1 project)
├──Stocks (Universal Windows)
├──Properties
├──References
├──Assets
├──App.xaml
├──ApplicationInsights.config
└──MainPage.xaml
Package.appxmanifest
project.json
Stocks_TemporaryKey.pfx
report erratum  •  discuss
Day 1: The Initial Investment • 143

There are some items in the tree for solution and app configuration, a folder
for assets, and some generated application files, App.xaml and MainPage.xaml,
which we’ll look at shortly.
Loading and Displaying Stock Quotes
We’ll start by loading JSON data from the API and displaying it directly in the
view, just to see it make the full trip. We’ll continue to iterate on this solution
in the following days. We’ll create a simple view for now, just to display the
JSON string and see the results from the API.
Creating a Minimal XAML View
XAML, or Extensible Application Markup Language, is Microsoft’s XML-based
layout language. XAML has a very slick approach to describing the layout of
a view where each tag corresponds to a C# class, and the attributes of the
tag correspond to the properties of an instance of that class. The structure
of the XAML document describes a view tree, laying out the components
described by the structure of the tags.
MainPage.xaml is the generated file that defines the default view of our app so
far. Let’s open it up and add a title and a component to display text.
Windows/windows_01_02_load_stocks/Stocks/Stocks/MainPage.xaml
<Page
x:Class="Stocks.MainPage"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
xmlns:local="using:Stocks"
xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
mc:Ignorable="d">
<StackPanel Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
<TextBlock Name="Title" Text="Stock Indices" />
<TextBlock Name="StockList" TextWrapping="Wrap" />
</StackPanel>
</Page>
The root tag of the document is a Page, which defines a blank canvas for our
view. Add a StackPanel, which is a view container component that arranges its
children vertically by default. Then, inside of the panel, add two TextBlock
components, one named Title and the other named StockList. The title’s text
will be Stock Indices, and we’ll set the TextWrapping attribute of StockList to be
Wrap, since it will have to display a lot of text. Now let’s look at how to load
the data from the API.
Chapter 5. Universal Windows Platform • 144
report erratum  •  discuss

Loading JSON from the API
One of the interesting concepts with XAML is the idea of pairing a C# code
file with a XAML layout file, defining layout in the .xaml file and behavior in a
.xaml.cs file. This is referred to as code-behind, as in “the code-behind file.”
Understanding Code-Behind
In the Solution Explorer, twirl down the tree item for MainPage.xaml and you’ll
see another file: MainPage.xaml.cs. This defines the C# class MainPage as a partial
class, or a class that can have further structure defined in a separate file.
Behind the scenes, the compiler generates more C# based on the XAML defi-
nition and adds that definition to the class defined in the code-behind file.
Think of the XAML and code-behind class as the same thing, with any variable
defined in the class available for reference in the XAML and vice versa.
Loading Quotes
Let’s open the code-behind file and add some code to the class to automati-
cally load stock quotes for a few stock indices.
Windows/windows_01_02_load_stocks/Stocks/Stocks/MainPage.xaml.cs
namespace Stocks {
public sealed partial class MainPage : Page {
public MainPage() {
this.InitializeComponent();
LoadAndDisplayStocks();
}
async void LoadAndDisplayStocks() {
string json = await GetStockIndices();
StockList.Text = json;
}
async Task<string> GetStockIndices() {
var httpClient = new HttpClient();
httpClient.BaseAddress = new Uri("http://localhost:3000/stock_quotes/");
httpClient.DefaultRequestHeaders.Accept.Add(
new MediaTypeWithQualityHeaderValue("application/json")
);
string indexList = "^IXIC,^GSPC,^FTSE,^N225";
var response = await httpClient.GetAsync(indexList);
var responseBody = response.Content.ReadAsStringAsync().Result;
return responseBody;
}
}
}
report erratum  •  discuss
Day 1: The Initial Investment • 145

First, in the constructor for MainPage, we’ll insert a call to a method named
LoadAndDisplayStocks. That method calls another, named GetStockIndices, setting
the returned string in to the Text property of StockList.
GetStockIndices creates an HttpClient and sets its BaseAddress to be the path to the
stock-quote endpoint. It then sends a list of stock index symbols to that
endpoint and reads the results into a string, which it returns. That’s all there
is to it. Compared to other platforms, that’s remarkably little code for calling
an HTTP endpoint. Part of the reason for this is a language feature of C# often
called async/await.
Understanding Async/Await
In the code we added just now, notice that the two methods both have async
as part of the method signature. Also, GetStockIndices has a return type of
Task<string>, even though what it actually returns is a string. Furthermore, when
LoadAndDisplayStocks calls GetStockIndices, it uses the await keyword.
This is a really nice feature of C# where, given a few simple keywords, the
compiler will generate useful concurrent code that you don’t need to worry
about writing yourself. Simply saying await while calling a method defined as
async with a Task return type will cause that method to be executed in a different
execution context. In other words, that code won’t run on the main thread—the
same thread that the view is being rendered on. This means long-running
tasks defined in this way won’t block the view rendering, and the app will feel
smooth.
To test out the code we’ve written so far, find the play button at the top of
Visual Studio and choose to run either on a device or an emulator. You should
see the title we created; and after the JSON loads, the title should be displayed
in the second text area. Now we’ve gotten some data loading, but we can
improve it by deserializing the JSON. Let’s do that next.
Working with JSON
JSON is one of the most important structured data formats to know these
days, and working with JSON in .NET is pretty straightforward. We’ll look at
two different methods: parsing JSON into a JsonObject and deserializing JSON
into an object of a specific type based on a contract.
Simple Parsing
Working with .NET’s JsonObject is really pretty easy. Here’s some code to take
the string result of GetStockIndices and parse the JSON into an object.
Chapter 5. Universal Windows Platform • 146
report erratum  •  discuss

Windows/windows_01_03_deserialize_json/Stocks/Stocks/MainPage.xaml.cs
public MainPage() {
this.InitializeComponent();
LoadAndDisplayStocks();
}
async void LoadAndDisplayStocks() {
var jsonString = await GetStockIndices();
var json = JsonObject.Parse(jsonString);
var stocks = json.GetNamedArray("quotes", new JsonArray());
var stringBuilder = new StringBuilder();
foreach (IJsonValue item in stocks) {
JsonObject stock = item.GetObject();
stringBuilder.Append(stock["name"].GetString() + "\n");
}
StockList.Text = stringBuilder.ToString();
}
Here you can see how to parse a whole message
into a JsonObject and then access keys of that
object. When we call GetNamedArray we can look for
an array at the key quotes, as we do here, and then
specify a fallback default in case that key isn’t
present. Then we can iterate over the values in
that array as IJsonValue instances. Here we’re look-
ing for each of the stock quotes in the array and
putting the name into a newline-delimited list in
a StringBuilder. We then put that list of quote names
in the TextBox that previously held the JSON string.
So a JsonObject acts a bit like a dictionary or hash
with some nice features for dealing with certain
types and for defaults. What would be even nicer
is for the JSON messages to be turned into
instances of types that we define, and that’s what
working with a data contract allows us to do.
Contract-Based Deserialization
If we define a few C# classes to describe the JSON we get back from the API,
we can see that we need something like a QuoteMessage to contain the list of
stock quotes, and then something like a StockQuote class to define an individual
quote.
report erratum  •  discuss
Day 1: The Initial Investment • 147

Windows/windows_01_04_deserialize_to_model/Stocks/Stocks/Models/Models.cs
namespace Stocks.Models {
[DataContract]
public class QuoteMessage {
[DataMember(Name = "quotes")]
public List<StockQuote> Quotes { get; set; }
}
[DataContract]
public class StockQuote {
[DataMember(Name = "name")]
public string Name { get; set; }
[DataMember(Name = "symbol")]
public string Symbol { get; set; }
//...
Using the DataContract and DataMember attributes to add metadata to those
classes will allow a DataContractJsonSerializer to understand how to change JSON
into our custom typed objects, like this:
Windows/windows_01_04_deserialize_to_model/Stocks/Stocks/MainPage.xaml.cs
var response = await httpClient.GetAsync(indexList);
var messageBody = await response.Content.ReadAsStringAsync();
var serializer = new DataContractJsonSerializer(typeof(QuoteMessage));
var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(messageBody));
var quoteMessage = (QuoteMessage)serializer.ReadObject(memoryStream);
return quoteMessage;
Now we can use a native StockQuote object for any stock quote loaded from the
API. With that improvement in place, let’s do some cleanup and restructuring
of how we get the data and then use a feature called binding to have the view
automatically updated when data changes.
Working with Binding
.NET’s binding is a way to describe the relationship between view components
and a property on an object holding the view’s data. If the property changes,
the view will automatically update. Binding has a few different use cases and
is a powerful way to avoid having to do a lot of manual wiring of views to data.
The point of binding is that different objects hold the data and define the
view, because this is a good way to architect software. Right now we have the
MainPage doing the work of defining the view and loading data from the API,
so let’s split that up into two objects. Then we can use binding to wire the
view up to the model that holds the stock quotes.
Chapter 5. Universal Windows Platform • 148
report erratum  •  discuss

Better Architecture for API Interaction
First, let’s take the code that loads data from the API and put it in a class
called StockQuoteRequest. This will allow us to request stocks from anywhere
without duplicating this code.
Windows/windows_01_05_binding/Stocks/Stocks/Data/StockQuoteRequest.cs
namespace Stocks.Data {
class StockQuoteRequest {
public async Task<QuoteMessage> RequestStockQuotes(string quoteList) {
var httpClient = new HttpClient();
httpClient.BaseAddress = new Uri("http://localhost:3000/stock_quotes/");
httpClient.DefaultRequestHeaders.Accept.Add(
new MediaTypeWithQualityHeaderValue("application/json")
);
var response = await httpClient.GetAsync(quoteList);
var messageBody = await response.Content.ReadAsStringAsync();
var serializer = new DataContractJsonSerializer(typeof(QuoteMessage));
var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(messageBody));
var quoteMessage = (QuoteMessage)serializer.ReadObject(memoryStream);
return quoteMessage;
}
}
}
Notice that now RequestStockQuotes is returning a QuoteMessage, so the async method
signature lists a return type of Task<QuoteMessage>. With a request class to deal
with loading the data, let’s define a model to use a request and then store the
returned data for the view.
Binding the View to a Model
First let’s create a new class, called StockIndexDataModel, which will load the
stock indices from the API and (for now) hold a list of their names for the view
to display. Later we can improve this model to hold more complex data.
Windows/windows_01_05_binding/Stocks/Stocks/Data/StockIndexDataModel.cs
namespace Stocks.Data {
public class StockIndexDataModel : INotifyPropertyChanged {
private string quotes;
public string QuoteList {
get { return quotes; }
private set {
quotes = value;
NotifyPropertyChanged("QuoteList");
}
}
public StockIndexDataModel() {
report erratum  •  discuss
Day 1: The Initial Investment • 149

QuoteList = "";
GetQuotesForSymbols("^IXIC,^GSPC,^FTSE,^N225");
}
public async void GetQuotesForSymbols(string symbols) {
var request = new StockQuoteRequest();
var message = await request.RequestStockQuotes(symbols);
QuoteList = QuoteListToString(message.Quotes);
}
//...
public event PropertyChangedEventHandler PropertyChanged;
protected void NotifyPropertyChanged(string name) {
if (name != null && PropertyChanged != null) {
PropertyChanged(this, new PropertyChangedEventArgs(name));
}
}
}
}
The class has a C# property, QuoteList, which for now will just hold a newline-
delimited list of index names. That property is what the binding we’re about
to define in the view will watch for changes.
Windows/windows_01_05_binding/Stocks/Stocks/MainPage.xaml
<StackPanel Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
<StackPanel.DataContext>
<data:StockIndexDataModel x:Name="model" />
</StackPanel.DataContext>
<TextBlock Name="Title" Text="Stock Indices" />
<TextBlock Name="StockList" TextWrapping="Wrap" Text="{Binding QuoteList}" />
</StackPanel>
The binding is defined inside curly braces in the Text property of StockList.
Essentially we’re saying, “Watch the QuoteList property for changes and then
reflect the changes in this component.” However, we need some kind of context
for that binding to work. We provide this context by placing a StockIndexDataModel
tag inside of the StackPanel’s DataContext property.
Declaring the StockIndexDataModel tag will create an instance of the model and
name it model. Then, because we load the stock indices from the constructor,
the API call will automatically be made. Because the model is in the data
context of the stack panel, any bindings in that panel will be assumed to be
relative to the model.
There are other ways to use binding and data contexts, and we’ll look at some
more complex cases in the coming days. For now, though, we’ve got a request
object calling the API, a model storing the results, and the results displayed
in the view, so we’re doing fairly well. Let’s look at what we’ve accomplished.
Chapter 5. Universal Windows Platform • 150
report erratum  •  discuss

What We Learned on Day 1
Today we got started by creating a new project in Visual Studio and loading
JSON data from the quotes API. We also saw how async/await works to make
concurrent code really simple.
We then looked at how to work with JSON data a few different ways, including
the easiest method, with a DataContract. Finally, we used binding to display
data automatically in the view.
Your Turn
Find
• The Universal Windows Platform documentation.
• Some UWP examples on GitHub.
• The Stack Overflow tags for Universal Windows Platform.
3 You may have
to get creative, including things like “windows 10.”
Do
• While we’re making the API calls, it’d be good to show the user that the
app is loading data. Research and pick the best component to use to
indicate progress, and then implement it.
• Research the XAML tags for the components we’ve added so far. Try to
add them in code instead of XAML.
Day 2: Trending Up
Or, Building a Better View
Today we’ll work on improving the view. We’ll use the list of quotes we have
from the API and display them in a ListView. Then we’ll see how to define styles
that we can apply to each of the list items. Then we’ll add a second page to
hold the user’s stock watch list and add a pivot control to allow navigation
between each page. While we add these other views we’ll also see how to
extract a reusable view component for the list of stocks so that we can use it
on both pages. Let’s get started by introducing the ListView component.
Working with ListView
A ListView is a component that allows us to display repeating elements on a
page. The other platforms have similar components, and Windows works
pretty much the same. There’s a way to define what an individual item looks
3.
http://stackoverflow.com
report erratum  •  discuss
Day 2: Trending Up • 151

like and a way to provide data to the component. Let’s convert the model to
provide the list of quotes as a List instead of a string so we have some data to
drive a ListView. Then add a ListView to the indices page and see how it looks.
Displaying List Data in a ListView
Let’s convert the model to provide a List first. We just need to change the type
from string to List<string>.
Converting the Model’s Quote Property
We’ll continue to keep working with string data for now as we build out the list
item; soon we’ll be storing a list of StockQuotes, but for now strings are enough
to see how things work.
Windows/windows_02_01_add_list_view/Stocks/Stocks/Data/StockIndexDataModel.cs
private List<string> quotes;
public List<string> QuoteList {
get { return quotes; }
private set {
quotes = value;
NotifyPropertyChanged("QuoteList");
}
}
public StockIndexDataModel() {
QuoteList = new List<string>();
GetQuotesForSymbols("^IXIC,^GSPC,^FTSE,^N225");
}
public async void GetQuotesForSymbols(string symbols) {
var request = new StockQuoteRequest();
var message = await request.RequestStockQuotes(symbols);
QuoteList = message.Quotes.Select(quote => quote.Name).ToList();
}
When we get a List of stock quotes back from the API, we use the useful LINQ
Select method to extract the names of the quotes into a list. LINQ is a great
tool for working with collections of data in C#.
4 The Select method works like
a functional map operation, which turns one list into another by performing
a transform on each item. Next, let’s get the ListView into place in our view.
Laying Out the ListView
We want the ListView to sit underneath the title TextBlock. Currently the StackPanel
does that vertical layout for us. We want the ListView to take up all the space
underneath the title until the bottom of the page. There’s another component
4.
https://msdn.microsoft.com/en-us/library/bb397926.aspx
Chapter 5. Universal Windows Platform • 152
report erratum  •  discuss

that’s better for that, called Grid. The Grid component lays out its children in
rows and columns, each of which is optional if you have the other.
Here’s some code that places a ListView into the second row of a two-row Grid.
The Grid has only one column, so the column definition is optional. The Row-
Definition for the title has its Height set to Auto, which takes up as much vertical
space as it needs. The second RowDefinition is set to *, which means “Take up
the rest of the available space.” The Grid stays as tall as the view and goes no
further, which is exactly what we want.
Windows/windows_02_01_add_list_view/Stocks/Stocks/MainPage.xaml
<Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
<Grid.DataContext>
<data:StockIndexDataModel x:Name="model" />
</Grid.DataContext>
<Grid.RowDefinitions>
<RowDefinition Height="Auto" />
<RowDefinition Height="*" />
</Grid.RowDefinitions>
<TextBlock Name="Title" Text="Stock Indices" Grid.Row="0" />
<ScrollViewer Grid.Row="1">
<ListView ItemsSource="{Binding QuoteList}">
<ListView.ItemTemplate>
<DataTemplate>
<TextBlock Text="{Binding}" />
</DataTemplate>
</ListView.ItemTemplate>
</ListView>
</ScrollViewer>
</Grid>
Place the ListView into a ScrollViewer so the list will scroll as needed. Notice that
the children of the Grid are put into place with the Grid.Row and Grid.Column
attributes, so the ScrollViewer is in row one, the second zero-indexed row.
To get the data into the ListView we use binding, this time to the list’s ItemSource
property. Finally, to provide a template for each item in the list, we put view
components in the DataTemplate property of the list. Because each item defined
by the data template is a string, we can use an anonymous Binding, with no
property name, to bind the bit of data provided to each list item, the stock
quote name from the model.
If you run the app now, you should see a view similar to the one we had
before, except now the list can scroll.
Let’s convert the list items to show StockQuotes.
report erratum  •  discuss
Day 2: Trending Up • 153

More Complex List Items
Let’s start by fully converting the model over to storing StockQuotes.
Windows/windows_02_02_binding_object_name/Stocks/Stocks/Data/StockIndexDataModel.cs
private List<StockQuote> quotes;
public List<StockQuote> QuoteList {
get { return quotes; }
private set {
quotes = value;
NotifyPropertyChanged("QuoteList");
}
}
Now, with a list of complex objects in the list’s items instead of just strings,
we can bind to the object’s properties inside the template; for instance, the
stock quote’s Name.
Windows/windows_02_02_binding_object_name/Stocks/Stocks/MainPage.xaml
<ListView ItemsSource="{Binding QuoteList}">
<ListView.ItemTemplate>
<DataTemplate>
<TextBlock Text="{Binding Name}" />
</DataTemplate>
</ListView.ItemTemplate>
</ListView>
That’s a simple example, but the template can be as complex as we need it
to be. Here is a more comprehensive layout for a list item, which uses a Grid,
multiple TextBlocks, and a StackPanel to lay out a more useful view of information
about a stock quote.
Windows/windows_02_03_list_view_item_layout/Stocks/Stocks/MainPage.xaml
<ListView.ItemTemplate>
<DataTemplate>
<Grid Margin="0,8">
<Grid.RowDefinitions>
<RowDefinition Height="Auto" />
<RowDefinition Height="Auto" />
</Grid.RowDefinitions>
<Grid.ColumnDefinitions>
<ColumnDefinition Width="*" />
<ColumnDefinition Width="*" />
</Grid.ColumnDefinitions>
<TextBlock Text="{Binding Name}"
Grid.Row="0" Grid.Column="0" />
<TextBlock Text="{Binding LastTradePriceOnly}"
Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2"
HorizontalAlignment="Right" />
<TextBlock Text="{Binding Symbol}"
Grid.Row="1" Grid.Column="0" />
Chapter 5. Universal Windows Platform • 154
report erratum  •  discuss

<StackPanel Orientation="Horizontal"
Grid.Row="1" Grid.Column="1" HorizontalAlignment="Right">
<TextBlock Text="{Binding Change}"/>
<TextBlock Text="{Binding PercentChange}" Margin="8,0,0,0" />
</StackPanel>
</Grid>
</DataTemplate>
</ListView.ItemTemplate>
Finally we can add a style to the ListView’s ItemContainerStyle property to make
sure that the list item fills up its horizontal space.
Windows/windows_02_03_list_view_item_layout/Stocks/Stocks/MainPage.xaml
<ListView.ItemContainerStyle>
<Style TargetType="ListViewItem">
<Setter Property="HorizontalContentAlignment" Value="Stretch" />
</Style>
</ListView.ItemContainerStyle>
Run the app and see where we’ve gotten so far. It’s really starting to shape
up, but there are a few more visual things we could improve on the list items.
Styles, like the one we just defined for the ItemContainerStyle, are a very powerful
way to control the presentation of visual elements. Let’s define a few styles
and apply them to the list items.
Styling List Items
Let’s look at how we’d like the components in the list item to look. We’ll make
the Name bold and the font size on the Symbol smaller and dark grey.
Windows/windows_02_04_styling_the_list_item/Stocks/Stocks/MainPage.xaml
<TextBlock Text="{Binding Name}"
Grid.Row="0" Grid.Column="0" FontWeight="Bold" />
<TextBlock Text="{Binding LastTradePriceOnly}"
Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2"
HorizontalAlignment="Right" />
<TextBlock Text="{Binding Symbol}"
Grid.Row="1" Grid.Column="0"
FontSize="10.667" VerticalAlignment="Center"
Foreground="#FF505050" />
That looks better, or at least helps to distinguish pieces of information from
each other. However, it’d be better if we could define styles in a more reusable
way; something like a CSS style sheet. It turns out we can, by defining styles
in the Resources section of a context—for instance, the Application.
Defining Style Resources
Let’s put a set of styles inside the Application Resources property. The Resources
property of a Context is like a dictionary or a key/value pair.
report erratum  •  discuss
Day 2: Trending Up • 155

Windows/windows_02_05_style_resource/Stocks/Stocks/App.xaml
<Application.Resources>
<Style TargetType="TextBlock" x:Key="StockName">
<Setter Property="FontWeight" Value="Bold" />
</Style>
<Style TargetType="TextBlock" x:Key="StockSymbol">
<Setter Property="FontSize" Value="10" />
<Setter Property="Foreground" Value="#FF505050" />
</Style>
<SolidColorBrush Color="Red" x:Key="DownColorBrush" />
<SolidColorBrush Color="Green" x:Key="UpColorBrush" />
</Application.Resources>
Each Style tag has an x:Key property, which we can use to identify it. Also, since
we’ve defined the styles in the Application’s resources instead of a certain Page’s,
we can refer to them from anywhere. If we’d defined them in a particular page,
we’d have access to them from the context of that page only.
Let’s look at how we apply those styles.
Windows/windows_02_05_style_resource/Stocks/Stocks/MainPage.xaml
<TextBlock Text="{Binding Name}" Style="{StaticResource StockName}"
Grid.Row="0" Grid.Column="0" />
<TextBlock Text="{Binding LastTradePriceOnly}"
Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2"
HorizontalAlignment="Right" />
<TextBlock Text="{Binding Symbol}" Style="{StaticResource StockSymbol}"
Grid.Row="1" Grid.Column="0"
VerticalAlignment="Center" />
<StackPanel Orientation="Horizontal"
Grid.Row="1" Grid.Column="1" HorizontalAlignment="Right">
<TextBlock Text="{Binding Change}"
Foreground="{Binding IsDown,
Converter={StaticResource ColorConverter}}"/>
<TextBlock Text="{Binding PercentChange}" Margin="8,0,0,0"
Foreground="{Binding IsDown,
Converter={StaticResource ColorConverter}}"/>
</StackPanel>
Again, binding syntax comes into play to bind a component’s Style property
to a resource key, like the ones we just defined. Here, we’ve bound the Style
property of the name and stock symbol to the styles we just created.
Notice also that we’ve used a more complex binding syntax for the Foreground
property of the change and percent change fields. We’re using a value converter
to apply a conditional style. If the stock is up in value we’ll display the changes
in green, and if it’s down we’ll use red instead. Let’s look at how that works.
Chapter 5. Universal Windows Platform • 156
report erratum  •  discuss

Conditional Styles
The Foreground property of a TextBlock takes a Brush object, which defines things
like the color and border for a visual element. To choose whether to use a red
or green color, we can use a feature of binding where we run a bound value
through a converter before the binding framework notifies the bound compo-
nent of its new value. In this particular case, we’ve bound the color of the
text block to a Boolean property of the model, IsDown, which is converted to a
Brush. We do this by defining an IValueConverter.
Windows/windows_02_05_style_resource/Stocks/Stocks/ValueConverters/IsDownToColorConverter.cs
namespace Stocks.ValueConverters {
public class IsDownToColorConverter : IValueConverter {
public SolidColorBrush UpColorBrush { get; set; }
public SolidColorBrush DownColorBrush { get; set; }
public object Convert(object value,
Type targetType,
object parameter,
string language) {
if ((bool)value) { // is the stock down?
return DownColorBrush;
} else {
return UpColorBrush;
}
}
public object ConvertBack(object value,
Type targetType,
object parameter,
string language) {
throw new NotImplementedException();
}
}
}
report erratum  •  discuss
Day 2: Trending Up • 157

The interface for this type of object is a Convert method and a ConvertBack method.
In our case we expect that to be a Boolean that signifies whether the stock
is down or not. We return the appropriate predefined Brush. Notice that the
Brushes for up and down colors are properties, which allows us to define those
as styles. In fact, they’re defined in the application resources tag that we just
added. Next, we need to define the converter and bind to the brush styles.
Windows/windows_02_05_style_resource/Stocks/Stocks/MainPage.xaml
<Page.Resources>
<converters:IsDownToColorConverter x:Key="ColorConverter"
DownColorBrush="{StaticResource DownColorBrush}"
UpColorBrush="{StaticResource UpColorBrush}" />
</Page.Resources>
We place that value converter tag in the
Page.Resources property and then bind the
brushes in. If we run the app again, we should
see that the change fields are colored appro-
priately to the performance of the stock.
Now our app is starting to look like a real
stocks app! The indices page is in pretty good
shape now, so let’s move on to adding a watch
list for users to keep track of specific stocks
that they care about.
Adding a Watch List
For a watch list, we need another page that
displays a list of stock quotes. That page also
needs a way for users to add stock symbols
to the list. Finally, we need a way to navigate
between the index page and the watch list
page. Let’s start by creating a simple new page
and the top-level navigation, using a Pivot
control.
The Pivot Control
A Pivot control is one of the characteristic navigation controls of the Windows
Phone platform. It’s like a tabbed control. Users can swipe between the tabs,
and when the swipe reaches the end of the list of tabs it will cycle back to the
beginning. Adding a Pivot is rather simple. There are multiple PivotItem children,
each of which defines the tab’s title and contains the view for that tab.
Chapter 5. Universal Windows Platform • 158
report erratum  •  discuss

Windows/windows_02_06_pivot/Stocks/Stocks/MainPage.xaml
<Pivot>
<PivotItem Header="Stock Indexes">
<ScrollViewer>
<pages:IndicesPage />
</ScrollViewer>
</PivotItem>
<PivotItem Header="Watchlist">
<ScrollViewer>
<pages:WatchListPage />
</ScrollViewer>
</PivotItem>
</Pivot>
So now the MainPage holds nothing but the Pivot, and the view that was previ-
ously in MainPage is now in IndicesPage in the Pages subdirectory. Also, there’s
now a WatchListPage. Let’s take a look at what goes in there.
Adding the Watch List Page
First of all, we define a Grid with a row for a TextBox, which is where the user
can input a symbol to add to the list. There’s also an Add button, which sits
in a second column next to the text box. Nothing yet sits in the second row
of the Grid, but that’s where the stock-quote list will go.
Windows/windows_02_07_load_stock_by_symbol/Stocks/Stocks/Pages/WatchListPage.xaml
<Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
<Grid.ColumnDefinitions>
<ColumnDefinition Width="4*" />
<ColumnDefinition Width="*" />
</Grid.ColumnDefinitions>
<Grid.RowDefinitions>
<RowDefinition Height="Auto" />
<RowDefinition Height="*" />
</Grid.RowDefinitions>
<TextBox x:Name="AddSymbolTextBox"
PlaceholderText="Enter a symbol to watch"
Grid.Row="0" Grid.Column="0" />
<Button x:Name="AddSymbolButton" Content="Add" Click="AddSymbolButton_Click"
Grid.Row="0" Grid.Column="1" HorizontalAlignment="Stretch" />
</Grid>
Notice that the Click property of the Button points to AddSymbolButton_Click, which
is a method defined in the watch list page’s code-behind file.
report erratum  •  discuss
Day 2: Trending Up • 159

Windows/windows_02_07_load_stock_by_symbol/Stocks/Stocks/Pages/WatchListPage.xaml.cs
namespace Stocks.Pages {
public sealed partial class WatchListPage : UserControl {
public WatchListPage() {
this.InitializeComponent();
}
private void AddSymbolButton_Click(object sender, RoutedEventArgs e) {
string symbol = AddSymbolTextBox.Text;
LoadAndDisplaySymbol(symbol);
}
private async void LoadAndDisplaySymbol(string symbol) {
var newQuote = await GetQuoteForSymbol(symbol);
Debug.Write(
String.Format("Loaded quote for {0} ({1})", newQuote.Name, newQuote.Symbol)
);
}
public async Task<StockQuote> GetQuoteForSymbol(string symbols) {
var request = new StockQuoteRequest();
var message = await request.RequestStockQuotes(symbols);
var quoteList = message.Quotes;
var newQuote = quoteList[0];
return newQuote;
}
}
}
When the button is clicked (or tapped, as the case may be), this method is
called. We take the text from that TextBox and load the symbol’s quotes from
the API. For right now all we’ll do is log to the Visual Studio console that we
got some data back. This shows that we can do the round-trip, and the next
step would be to display that quote in a list, similar to what we do on the
indices page.
Before we code up that list, though, it’d be much better if we could reuse a
stock-quote list in both pages, to get a common presentation for stocks
throughout the app without code duplication. Let’s do that next.
Creating a Custom View Component
We want to display stock quotes in a list in two pages, so we’ll create a com-
ponent that will do that for us. However, the models for the different applica-
tions of the quote list are slightly different; the indices model currently loads
a predefined list of indices, while the watch list model should load stock
quotes from a saved list of watched symbols.
To account for these differences, we can extract a parent class, called Stock-
QuoteDataModel, which will hold the common code for each model. That code
Chapter 5. Universal Windows Platform • 160
report erratum  •  discuss

mostly has to do with holding a list of StockQuotes. Then a newly created
StockIndexDataModel will just load the indices on instantiation.
Then a WatchListDataModel can define a set of watched symbols from which to
load stock quotes on instantiation.
Windows/windows_02_08_componentize_stock_list/Stocks/Stocks/Data/WatchListDataModel.cs
namespace Stocks.Data {
public class WatchListDataModel : StockQuoteDataModel {
private SortedSet<string> watchedSymbols;
public SortedSet<string> WatchedSymbols {
get { return watchedSymbols; }
protected set {
watchedSymbols = value;
LoadWatchedSymbols();
}
}
public WatchListDataModel() : base() {
watchedSymbols = new SortedSet<string>();
}
public void AddWatchedSymbol(string symbol) {
var newSymbols = watchedSymbols;
newSymbols.Add(symbol);
WatchedSymbols = newSymbols;
}
private void LoadWatchedSymbols() {
string symbolList = string.Join(",", watchedSymbols.ToArray());
GetQuotesForSymbols(symbolList);
}
}
}
It can also provide an interface for adding and loading watched symbols,
which you see here as well.
Now we can take the whole ListView for stock quotes out of the IndicesPage and
put it in a new file called StockQuoteList.mxml. Then, from both the IndicesPage and
the WatchListPage, we put in the component as a new tag and provide the
appropriate model as a DataContext.
report erratum  •  discuss
Day 2: Trending Up • 161

Windows/windows_02_08_componentize_stock_list/Stocks/Stocks/Pages/WatchListPage.xaml
<components:StockQuoteList Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="2">
<components:StockQuoteList.DataContext>
<data:WatchListDataModel x:Name="model" />
</components:StockQuoteList.DataContext>
</components:StockQuoteList>
With relatively little work, and no
rework, now we have a new page that
allows users to add stocks to watch
and view them with the same style
treatment as on the index page. Run
the app and add a few symbols to
see it work.
Tomorrow we’ll continue with this
feature as we store the watch list
symbols so that they’re available
across app sessions.
What We Learned on Day 2
Today we got a list of quotes displaying, bound to a model’s list of quotes,
and then styled. We even got some conditional styling working so that it’s
easy to tell at a glance which stocks are up or down.
Then we added some navigation and a second page, a watch list for the user
to add a custom list of stocks to watch. We then displayed stock quotes on
this page by extracting a custom component to display stock quotes instead
of duplicating code.
Your Turn
Find
• Documentation about styling Universal Windows Apps
• Documentation about collection data types in C#
Do
• Find a unicode symbol that represents up or down well, and add that
symbol to the list item based on whether the stock is up or down.
Chapter 5. Universal Windows Platform • 162
report erratum  •  discuss

Day 3: A Wider Market
Or, Designing for More than One Device
Today let’s continue where we left off. We had the watch list showing symbols
that we searched for, but we’ll start off by storing that symbol list so the user’s
list is saved. Then we’ll see how to navigate between the stock lists and a
stock detail view so the user can see more about a particular stock.
Then we’ll start thinking about multiple screen sizes on devices other than
the phone, like tablets and desktops. We’ll add an adaptive view to the index
and watch list pages, so on a small screen we’ll navigate to the detail page
when a quote is clicked, but on a larger screen the detail will show up beside
the list with no navigation.
Finally, we’ll add a live tile, which surfaces information from inside the app
to the app icon. We’ll use the live tile to show the performance of the top three
quotes in the watch list.
In today’s code we’ll be improving existing features and implementing new
features that make our app work well across multiple devices, not just the
phone. One of the devices the app can run on, in fact, is the very Windows
system you’re working on. This makes it easy to test on both a computer and
a phone, to see how a feature works on two separate devices, or on a device
with a certain screen geometry.
To run the app on your local Windows machine, select x64 from the Architec-
ture drop-down and Local Machine next to the play button at the top of the
screen in Visual Studio.
Let’s get started on the third day by storing the watch list in local data.
Using Local and Roaming Data
Let’s take stock of where we are on the watch list. We have a pretty usable
form for users to specify a stock symbol (or list). When they submit the list,
we’ll load the current quotes for the list and display them in the list.
Using LocalSettings for Storage
What we need next is for the app to store the user’s list so that it’s available
from session to session. We could put a more complex system in place where
the user would need to log in to a service, and we’d store the list associated
with that account in an API. Let’s start simple, though, and just store the list
in data storage local to the current device.
report erratum  •  discuss
Day 3: A Wider Market • 163

Here’s a set of methods to add to the WatchListDataModel, which will store and
retrieve the symbol list into LocalSettings, which is a key-value data store scoped
to the app on the current device.
Windows/windows_03_01_store_watchlist/Stocks/Stocks/Data/WatchListDataModel.cs
private void LoadSavedWatchedSymbols() {
var settings = ApplicationData.Current.LocalSettings;
string symbolList = settings.Values["WatchList"] as string;
if (string.IsNullOrWhiteSpace(symbolList)) {
WatchedSymbols = new SortedSet<string>();
} else {
WatchedSymbols = new SortedSet<string>(symbolList.Split(','));
}
}
private void StoreSavedWatchedSymbols() {
var settings = ApplicationData.Current.LocalSettings;
settings.Values["WatchList"] = SymbolsAsList();
}
private string SymbolsAsList() {
return string.Join(",", watchedSymbols.ToArray());
}
In StoreSavedWatchedSymbols we put the list into a LocalSettings key called WatchList.
In LoadSavedWatchedSymbols we retrieve the list from that key and convert the
list into a SortedSet<string>, which will preserve order while avoiding duplicates.
Now the watch list should be preserved from session to session. However this
works only on the current app installation on the current device. But even
without setting up a full authenticated account in an API, we have one more
option for making saved user-specific data available across multiple devices.
Using RoamingSettings for Storage
If, instead of putting stored data in LocalSettings, we put the data in RoamingSet-
tings, then the data is considered roaming app data. When we store things in
roaming app data,
5 Microsoft will store and synchronize settings across all
of the user’s devices, provided the user is logged in to those devices with a
Microsoft account.
Here we’ve switched from LocalSettings to RoamingSettings.
Windows/windows_03_02_remote_watchlist/Stocks/Stocks/Data/WatchListDataModel.cs
private void LoadSavedWatchedSymbols() {
var settings = ApplicationData.Current.RoamingSettings;
string symbolList = settings.Values["WatchList"] as string;
if (string.IsNullOrWhiteSpace(symbolList)) {
5.
https://msdn.microsoft.com/en-us/library/windows/apps/hh465094.aspx
Chapter 5. Universal Windows Platform • 164
report erratum  •  discuss

WatchedSymbols = new SortedSet<string>();
} else {
WatchedSymbols = new SortedSet<string>(symbolList.Split(','));
}
}
private void StoreSavedWatchedSymbols() {
var settings = ApplicationData.Current.RoamingSettings;
settings.Values["WatchList"] = SymbolsAsList();
}
I have to mention here that I found this a little hard to test between my
development phone and my Windows laptop. The roaming data is synced at
some point in time, so not necessarily as soon as it’s saved. You must also be
logged in to both devices with a Microsoft account, not a local account on the
Windows machine. Finally, the app must be associated with the Windows
Store. You can do this by right-clicking the solution in the Solution Panel,
going to Store, and selecting Associate App with Store.
In any case, roaming data is only a nice feature to offer users without a lot
of programming work; it’s not a substitute for real account-based online
storage.
Now that we’ve got some local or roaming storage set up in the app, let’s
improve the view by adding a detail screen to give users a more in-depth look
at a stock quote.
Adding a Stock Quote Detail Screen
The detail screen will be a new Page. When the user navigates to the page by
clicking a stock quote from one of the stock-quote lists, the detail page will
be constructed and passed a StockQuote.
To make this work we need to do three things:
• Fire an event from the StockQuoteList component so that any page hosting
it can listen for that event
• Pass the event from the page hosting the StockQuoteList to the MainPage so
that it can handle navigation correctly
• Accept an incoming StockQuote in the detail view
We’ve already seen some event handlers, but now we’ll get a chance to create
a custom event handler. We’ll thread the event created in the StockQuoteList all
the way up to the MainPage.
report erratum  •  discuss
Day 3: A Wider Market • 165

Creating Event Handlers for a Selected StockQuote
Let’s start out by responding to when a list item is clicked in the StockQuoteList
component we created.
Handling a Selected StockQuote
First we need to configure the ListView so that its items are clickable, and we
need to set up a method to be the ItemClick handler.
Windows/windows_03_03_detail_view/Stocks/Stocks/ViewComponents/StockQuoteList.xaml
<ListView ItemsSource="{Binding QuoteList}" IsItemClickEnabled="True"
ItemClick="StockQuote_ItemClick">
Then we need to define an EventArgs class, so the component can emit a custom
event up to its parent page. This EventArgs class will have a property containing
the StockQuote that was clicked.
Windows/windows_03_03_detail_view/Stocks/Stocks/ViewComponents/StockQuoteSelectedEventArgs.cs
using Stocks.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace Stocks.ViewComponents {
public class StockQuoteSelectedEventArgs : EventArgs {
public StockQuote Quote { get; }
public StockQuoteSelectedEventArgs(StockQuote quote) {
Quote = quote;
}
}
}
Next we need to define an event handler in the component. With this in place,
the page that defines the StockQuoteList component can define an event handler
method in XAML. That method will receive an instance of StockQuoteSelectedEven-
tArgs. We’ll see that wired up in a second. Here’s the EventHandler definition:
Windows/windows_03_03_detail_view/Stocks/Stocks/ViewComponents/StockQuoteList.xaml.cs
public event EventHandler<StockQuoteSelectedEventArgs> StockQuoteSelected;
public StockQuoteList() {
this.InitializeComponent();
}
private void StockQuote_ItemClick(object sender, ItemClickEventArgs e) {
var quote = (StockQuote)e.ClickedItem;
if (StockQuoteSelected != null) {
StockQuoteSelected(this, new StockQuoteSelectedEventArgs(quote));
Chapter 5. Universal Windows Platform • 166
report erratum  •  discuss

}
}
So now, when StockQuote_ItemClick is called, we’ll get the StockQuote, and if an
event handler is available we’ll call it with a new StockQuoteSelectedEventArgs.
Creating a StockQuoteSelected Event Handler in XAML
Now, in the IndicesPage we can add an event handler for StockQuoteSelected in the
component’s XAML.
Windows/windows_03_03_detail_view/Stocks/Stocks/Pages/IndicesPage.xaml
<components:StockQuoteList
StockQuoteSelected="StockQuoteList_StockQuoteSelected">
<components:StockQuoteList.DataContext>
<data:StockIndexDataModel />
</components:StockQuoteList.DataContext>
</components:StockQuoteList>
And then, in the somewhat cumbersomely named method generated by
Visual Studio, StockQuoteList_StockQuoteSelected, we can create a new instance of
StockQuoteSelectedEventArgs.
Windows/windows_03_03_detail_view/Stocks/Stocks/Pages/IndicesPage.xaml.cs
public event EventHandler<StockQuoteSelectedEventArgs> StockQuoteSelected;
public IndicesPage() {
this.InitializeComponent();
}
private void StockQuoteList_StockQuoteSelected(object sender,
StockQuoteSelectedEventArgs e) {
if (StockQuoteSelected != null) {
StockQuoteSelected(this, new StockQuoteSelectedEventArgs(e.Quote));
}
}
We’ll use the same event args/event handler pattern to pass along the
selected quote from this page up to the MainPage, or (of course) any page that
owns the IndicesPage. You can see the code for IndicesPage here, but note that
you should make the same addition to WatchListPage.
Now let’s see what we do at the top of the food chain in MainPage.
Handling the StockQuoteSelectedEvent
Again, in MainPage we define a click handler for StockQuoteSelected in the XAML.
Notice that this event could come from the watch list or the indices page.
Windows/windows_03_03_detail_view/Stocks/Stocks/MainPage.xaml
<Pivot>
<PivotItem Header="Stock Indexes">
report erratum  •  discuss
Day 3: A Wider Market • 167

<ScrollViewer>
<pages:IndicesPage
StockQuoteSelected="IndicesPage_StockQuoteSelected" />
</ScrollViewer>
</PivotItem>
<PivotItem Header="Watchlist">
<ScrollViewer>
<pages:WatchListPage
StockQuoteSelected="WatchListPage_StockQuoteSelected" />
</ScrollViewer>
</PivotItem>
</Pivot>
In our case we want to handle both of these events the same way: by showing
the detail page. So both event handler methods call a method called Navigate-
ToStockDetail with the StockQuote.
Windows/windows_03_03_detail_view/Stocks/Stocks/MainPage.xaml.cs
private void IndicesPage_StockQuoteSelected(object sender,
StockQuoteSelectedEventArgs e) {
NavigateToStockDetail(e.Quote);
}
private void WatchListPage_StockQuoteSelected(object sender,
StockQuoteSelectedEventArgs e) {
NavigateToStockDetail(e.Quote);
}
private void NavigateToStockDetail(StockQuote quote) {
Frame.Navigate(typeof(StockQuoteDetailView),
quote,
new DrillInNavigationTransitionInfo());
}
This method makes a call to the MainPage’s Frame. The Frame is what displays
the Page’s content and is where we make requests to navigate to new pages,
as we’ve done here. We navigate by passing the Navigate method the Type of the
page we want to navigate to, any data to pass that page, and information
about how to transition during the navigation.
Displaying the Detail View
Now, inside the detail view that we’re navigating to, we need a property to
hold the StockQuote to display and an overridden event handler, OnNavigatedTo.
This method will be called when the page is constructed in the context of a
navigation.
Windows/windows_03_03_detail_view/Stocks/Stocks/Pages/StockQuoteDetailView.xaml.cs
namespace Stocks.Pages {
public sealed partial class StockQuoteDetailView : Page {
Chapter 5. Universal Windows Platform • 168
report erratum  •  discuss

public StockQuote Quote { get; set; }
public StockQuoteDetailView() {
this.InitializeComponent();
}
protected override void OnNavigatedTo(NavigationEventArgs e) {
base.OnNavigatedTo(e);
var quote = (StockQuote)e.Parameter;
Quote = quote;
}
}
}
We take the quote from the event arguments and put it into the Quote property.
Then, finally, here’s the abbreviated XAML for the detail view.
Windows/windows_03_03_detail_view/Stocks/Stocks/Pages/StockQuoteDetailView.xaml
<Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
<Grid.RowDefinitions>
<!-- ... -->
<StackPanel Orientation="Vertical"
Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="2">
<TextBlock Text="{x:Bind Quote.Name}" />
<TextBlock Text="{x:Bind Quote.Symbol, Mode=OneWay}" />
</StackPanel>
<TextBlock Text="Change"
Grid.Row="1" Grid.Column="0" />
<TextBlock Text="{x:Bind Quote.Change, Mode=OneWay}"
Grid.Row="1" Grid.Column="1" />
<!-- ... -->
It’s simply a list of all the properties of a StockQuote, bound to appropriate
components. Notice that in this case we’ve used x:Bind instead of Binding. This
is a newer binding technology that Microsoft has added. The older Binding is
a little more flexible, but x:Bind causes binding code to be generated at compile
time, so it’s much faster. It’s worth understanding all of the differences
between the two techniques if you use binding.
If you run the app and view a quote on the detail screen, you can see what
we’ve built. However, you may notice a problem, too. We’re not able to get
back to the screen we just came from. On a phone with a back button, clicking
the back button will take us all the way out of the app. But on a Windows
device with no back button, there’s no way to even try to get back. Let’s fix
that now.
Wiring Up the Back Button
Adding a back button to the view of the Windows app and handling the back-
button click on a phone can be done within the same code. We need an
report erratum  •  discuss
Day 3: A Wider Market • 169

instance of SystemNavigationManager to add an event handler for when the back
button is requested and to request that the back button be made visible.
Windows/windows_03_04_detail_back_button/Stocks/Stocks/Pages/StockQuoteDetailView.xaml.cs
protected override void OnNavigatedTo(NavigationEventArgs e) {
base.OnNavigatedTo(e);
var quote = (StockQuote)e.Parameter;
Quote = quote;
SystemNavigationManager systemNavigationManager =
SystemNavigationManager.GetForCurrentView();
systemNavigationManager.BackRequested += BackRequested;
systemNavigationManager.AppViewBackButtonVisibility =
AppViewBackButtonVisibility.Visible;
}
protected override void OnNavigatedFrom(NavigationEventArgs e) {
base.OnNavigatedFrom(e);
SystemNavigationManager systemNavigationManager =
SystemNavigationManager.GetForCurrentView();
systemNavigationManager.BackRequested -= BackRequested;
systemNavigationManager.AppViewBackButtonVisibility =
AppViewBackButtonVisibility.Collapsed;
}
private void BackRequested(object sender, BackRequestedEventArgs e) {
e.Handled = true;
OnBackRequested();
}
private void OnBackRequested() {
Frame.GoBack(new DrillInNavigationTransitionInfo());
}
We do this setup in OnNavigatedTo and the
teardown, or the reverse, in OnNavigatedFrom. If
the back button is pressed on any device, we
use the Frame to navigate back.
Run this on both a phone and your local
Windows machine, and have a look.
Now we have a view to show details about any
selected stock. But, we can improve the
experience for devices with bigger screens,
much like with HTML. Let’s do that next.
Making the View Adaptive
The design of this feature will be something like the concept of breakpoints
in HTML. When the screen is a certain width, we’ll decide that it makes sense
Chapter 5. Universal Windows Platform • 170
report erratum  •  discuss

for the user to see the detail view next to the quote list in the same screen.
But once the view gets to a certain size, we’ll say that the screen is too small
and the detail view should be reached by a navigation from one screen to
another. To test this, add this code to App.xaml.cs, in the OnLaunched method:
ApplicationView.GetForCurrentView().SetPreferredMinSize(
new Windows.Foundation.Size(320, 320)
);
This will allow you to resize the window smaller than usual in Windows, to
something more like a small phone, so you can test lots of different sizes.
Now let’s look at how to achieve this adaptive view.
Using the VisualStateManager
In the MainPage we want to work with the size of the stock-quote list. When the
screen size is small enough that we only want the stock-quote list to show,
we’ll allow it to resize to take up the full amount of horizontal space. We’ll set
this “narrow” state to be any width up to 720.
But if the screen size exceeds 720, which is the “wide” case, we’ll make the
stock-list view have a maximum width of 320 and add the detail view to the
screen to the right of the stock list. We’ll do this using a Grid component.
Windows/windows_03_05_adaptive_layout/Stocks/Stocks/MainPage.xaml
<PivotItem Header="Stock Indexes">
<Grid>
<Grid.ColumnDefinitions>
<ColumnDefinition x:Name="IndexListColumn" Width="320" />
<ColumnDefinition x:Name="IndexDetailViewColumn" Width="*" />
</Grid.ColumnDefinitions>
<ScrollViewer Grid.Column="0" Grid.Row="0"
VerticalScrollBarVisibility="Auto">
<pages:IndicesPage
StockQuoteSelected="IndicesPage_StockQuoteSelected" />
</ScrollViewer>
<ScrollViewer Grid.Column="1" Grid.Row="0"
VerticalScrollBarVisibility="Auto">
<TextBlock Text="Index Detail" />
</ScrollViewer>
</Grid>
</PivotItem>
We’ll configure the default state of the view to work in the “wide” case. Then
we’ll define a VisualStateGroup with a list of VisualStates, each with a StateTrigger.
Windows/windows_03_05_adaptive_layout/Stocks/Stocks/MainPage.xaml
<VisualStateManager.VisualStateGroups>
<VisualStateGroup>
report erratum  •  discuss
Day 3: A Wider Market • 171

<VisualState x:Name="DefaultState">
<VisualState.StateTriggers>
<AdaptiveTrigger MinWindowWidth="720" />
</VisualState.StateTriggers>
</VisualState>
<VisualState x:Name="NarrowState">
<VisualState.StateTriggers>
<AdaptiveTrigger MinWindowWidth="0" />
</VisualState.StateTriggers>
<VisualState.Setters>
<Setter Target="IndexListColumn.Width" Value="*" />
<Setter Target="WatchlistColumn.Width" Value="*" />
<Setter Target="IndexDetailViewColumn.Width" Value="0" />
<Setter Target="WatchlistDetailViewColumn.Width" Value="0" />
</VisualState.Setters>
</VisualState>
</VisualStateGroup>
</VisualStateManager.VisualStateGroups>
The two VisualStates are DefaultState and NarrowState. The StateTriggers watch the
minimum window width. If it gets below the MinWindowWidth parameter, then
any defined Setters will set their Value property on the Target property path. Keep
in mind that when the state manager moves from one VisualState to another,
all of the Setters will unset themselves.
Now we’ve wired up the adaptive rules so that the screen will behave how
we’d like it to. Next we need to get the detail screen working for both views.
To do this we’ll move the view inside of the current detail view to a DataTemplate.
Using a DataTemplate as a Resource
We need the detail view to show up in a separate page but also next to the
stock list. To do this, we need a view in a separate file that we can display in
the context of any other view. Making use of that resource will look like this
in the revised StockQuoteDetailView:
Windows/windows_03_06_adaptive_detail_view/Stocks/Stocks/Pages/StockQuoteDetailView.xaml
<Page.Resources>
<ResourceDictionary>
<ResourceDictionary.MergedDictionaries>
<templates:StockQuoteDetailTemplate />
</ResourceDictionary.MergedDictionaries>
</ResourceDictionary>
</Page.Resources>
<ContentPresenter x:Name="StockQuoteDetailPresenter"
Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"
Content="{x:Bind Quote}"
ContentTemplate="{StaticResource StockDetailDataTemplate}" />
Chapter 5. Universal Windows Platform • 172
report erratum  •  discuss

A StockQuoteDetailTemplate is declared in the Page.Resources ResourceDictionary as a
MergedDictionary. Then the view can be displayed in a ContentPresenter, complete
with binding to the Quote property. A ContentPresenter is simply a component
that can display a view.
The template is defined like this:
Windows/windows_03_06_adaptive_detail_view/Stoc … ks/Pages/Templates/StockQuoteDetailTemplate.xaml
<ResourceDictionary
x:Class="Stocks.Pages.Templates.StockQuoteDetailTemplate"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
xmlns:local="using:Stocks.Pages.Templates"
xmlns:models="using:Stocks.Models">
<DataTemplate
x:Key="StockDetailDataTemplate"
x:DataType="models:StockQuote">
<Grid>
<!-- ... -->
The root tag is a ResourceDictionary instead of a Page, and the rest of the view is
contained in a DataTemplate with a Key and a DataType of StockQuote. This configu-
ration, with the DataType and the MergedDictionaries tag in StockQuoteDetailView, is
necessary for binding to work.
Windows/windows_03_06_adaptive_detail_view/Stocks/Stocks/MainPage.xaml
<PivotItem Header="Stock Indexes">
<Grid>
<Grid.ColumnDefinitions>
<ColumnDefinition x:Name="IndexListColumn" Width="320" />
<ColumnDefinition x:Name="IndexDetailViewColumn" Width="*" />
</Grid.ColumnDefinitions>
<ScrollViewer Grid.Column="0" Grid.Row="0"
VerticalScrollBarVisibility="Auto">
<pages:IndicesPage
StockQuoteSelected="IndicesPage_StockQuoteSelected" />
</ScrollViewer>
<ScrollViewer Grid.Column="1" Grid.Row="0"
VerticalScrollBarVisibility="Auto">
<ContentPresenter x:Name="IndexDetailPresenter"
Margin="8,0,0,0"
Content="{x:Bind SelectedIndexQuote, Mode=OneWay}"
ContentTemplate="{StaticResource StockDetailDataTemplate}" />
</ScrollViewer>
</Grid>
</PivotItem>
report erratum  •  discuss
Day 3: A Wider Market • 173

When a stock quote is selected and threaded up to the MainPage by the indices
page or the watch list, the AdaptiveVisualStates state will change. Then we can
navigate to the detail view or use binding to have the ContentPresenter updated.
Windows/windows_03_06_adaptive_detail_view/Stocks/Stocks/MainPage.xaml.cs
private void IndicesPage_StockQuoteSelected(object sender,
StockQuoteSelectedEventArgs e) {
if (AdaptiveVisualStates.CurrentState == NarrowState) {
NavigateToStockDetail(e.Quote);
} else {
SelectedIndexQuote = e.Quote;
Bindings.Update();
}
}
Run the app on a phone, and you should see the former behavior, where
stock list clicks will cause the app to navigate to the detail view. If you run
the app on your Windows machine and keep the window relatively narrow,
the app will behave the same. However, if you resize the window to be wide,
you’ll see the new behavior, with the detail view next to the list.
We’ve done a good day’s work so far and added a nice feature to the app. With
only a little code we’re able to maintain an app that works on narrow or wide
screens. Let’s round out the day with one more nice feature, adding a live tile
with the performance of the top three quotes in the watch list.
Adding a Live Tile
The ability to add easy-to-glance information from our app to the user’s Start
screen is really useful. Whenever the user’s watch list loads, we’ll update the
information on the live tile, which means that the information won’t be up-
to-the-minute, but it’ll still be useful. You could go even further and have a
back-end service pushing live tile information without the user even needing
to open the app. However, the code we add here will be a good introduction
to how live tiles work.
Chapter 5. Universal Windows Platform • 174
report erratum  •  discuss

Preparing the App for a Live Tile
The first step is to add a package using NuGet.
6 NuGet is a package-manage-
ment tool in Visual Studio that allows you to define and install project library
dependencies. The package we need to install is called NotificationsExten-
sions,
7 and it’s from Microsoft. This gives us a framework for updating live
tiles with a TileNotification.
To install the package, in Visual Studio go to Tools > NuGet Package Manager
> Manage NuGet Packages for Solution, search for NotificationsExtensions.Win10,
and then click Install.
Next we need to update the display of the app’s tile. Open Package.appmanifest
and edit the short name to be the app’s name, Stocks. For fun, you can cus-
tomize anything else you’d like, including the background color. For now we’ll
get to the code where we send the TileNotification to update the tile.
Creating the TileNotification
To update the tiles for our simple use case, we need a way to run code when
the QuoteList is updated in either of our StockQuoteDataModel implementations.
Since this happens in the model itself, we don’t want to use an event listener.
We can just implement a base class method called from the property setter.
Windows/windows_03_07_live_tile/Stocks/Stocks/Data/StockQuoteDataModel.cs
private List<StockQuote> quotes;
public List<StockQuote> QuoteList {
get { return quotes; }
protected set {
quotes = value;
OnQuoteListChanged();
NotifyPropertyChanged("QuoteList");
}
}
protected virtual void OnQuoteListChanged() {
// override
}
Then in the WatchListDataModel, which is where we get the data for the tile, we’ll
override that method. We’ll use a helper class that we’ll create in a second to
produce a TileNotification, and then send that notification by way of a TileUpdater.
Windows/windows_03_07_live_tile/Stocks/Stocks/Data/WatchListDataModel.cs
protected override void OnQuoteListChanged() {
var notification = TileHelper.TileNotificationForQuotes(QuoteList);
6.
http://www.nuget.org
7.
https://github.com/WindowsNotifications/NotificationsExtensions
report erratum  •  discuss
Day 3: A Wider Market • 175

TileUpdateManager.CreateTileUpdaterForApplication().Update(notification);
}
Pretty easy. Let’s look how the notification is constructed in the TileHelper class.
Windows/windows_03_07_live_tile/Stocks/Stocks/Data/TileHelper.cs
namespace Stocks.Data {
public class TileHelper {
public static TileNotification TileNotificationForQuotes(
ICollection<StockQuote> quotes) {
var nameSubgroup = new TileSubgroup();
var upDownSubgroup = new TileSubgroup();
int count = 3;
foreach (var quote in quotes) {
nameSubgroup.Children.Add(CreateNameTextForQuote(quote));
upDownSubgroup.Children.Add(CreateArrowTextForQuote(quote));
count--;
if (count == 0) {
break;
}
}
var group = new TileGroup();
group.Children.Add(nameSubgroup);
group.Children.Add(upDownSubgroup);
var content = new TileContent() {
Visual = new TileVisual() {
TileMedium = new TileBinding() {
Content = new TileBindingContentAdaptive() {
Children = {
group
}
}
},
TileWide = new TileBinding() {
Content = new TileBindingContentAdaptive() {
Children = {
group
}
}
}
}
};
var doc = content.GetXml();
return new TileNotification(doc);
}
private static TileText CreateNameTextForQuote(StockQuote quote) {
return new TileText {
Text = quote.Symbol,
Style = TileTextStyle.Body
Chapter 5. Universal Windows Platform • 176
report erratum  •  discuss

};
}
private static TileText CreateArrowTextForQuote(StockQuote quote) {
return new TileText {
Text = quote.IsDown ? "▼" : "▲",
Style = TileTextStyle.Body,
Align = TileTextAlign.Right
};
}
}
}
This class is mainly here to contain all of the TileNotification logic and keep it
out of classes where it doesn’t belong. The static method TileNotificationForQuotes
does the coordination for building the notification from the first three quotes.
The notification contains a hierarchy of C# classes, but it could be composed
of XML also. The structure can be a little hard to follow, so a great tool to use
to help you build the correct structure is Microsoft’s Notifications Visualizer,
8
which can help you compose notifications with a live preview.
Run the app, go to the watch list, make sure there are some quotes loaded,
and then go back to the Start screen. You should see something like the tile
in the top-left corner of this figure.
Notice that to the right of our app’s tile is the Microsoft Money app’s tile,
which does the same kind of live tile, with a lot more detailed information.
What We Learned on Day 3
Today we added features focused on improving the experience on a wider
array of screens, plus outside of the app itself with the live tile. We stored the
user’s watch list stock symbols in local and then roaming storage.
8.
https://blogs.windows.com/buildingapps/2015/11/02/introducing-notifications-visualizer-for-windows-10
report erratum  •  discuss
Day 3: A Wider Market • 177

We then added a detail screen and made the layout and navigation dependent
on the screen width. We finished up by sending a TileNotification to show the
first three stocks’ latest performance to the app’s view in the Start screen.
Your Turn
Find
• The differences between x:Bind and Binding
• Information about responsive design with UWP
• Documentation on live tiles
Do (Easier)
• Style the detail screen.
• To add stocks to the watch list, users need to click the Add button. This
is a little cumbersome when the app is running on the desktop. It’d be
better if they could press the Enter key when they’re on a desktop com-
puter. Modify the code to respond to the enter event on the text box, and
add the stock to the watch list.
Do (Harder)
• You may have noticed when navigating back from the detail screen to the
previous page that the previous page reloaded as if from scratch. How
might you stop this? Research navigation between pages and come up
with a plan to fix this quirk, and then implement it.
Wrapping Up Windows Phone
We’ve come up with a fairly useful app that can run on a Windows phone,
tablet, or desktop. We’ve worked with a number of useful concepts in both
C# and XAML, including making HTTP calls, styling view components, navi-
gating between screens of data, and adapting the view based on the window’s
size. We even added a stock ticker–type view to the app’s tile on the Start
screen. You should have a good foundation to take on a more complex project
on the Universal Windows Platform.
Strengths
If you’ve never done any Windows development before, or if you’ve worked
with older technologies, chances are you’ll be pleasantly surprised at how
powerful the SDK is and how easy it is to create nice-looking apps on any
Windows device.
Chapter 5. Universal Windows Platform • 178
report erratum  •  discuss

C# has a number of really powerful features, such as async/await and LINQ,
that you may find yourself wishing you had on other platforms. XAML is also
one of the nicest layout and view frameworks to develop with.
Weaknesses
Of course, there’s one big barrier to entry when developing for Windows, at
least for mobile apps: the market share for Windows Phones is still strikingly
small. If you take the time to build your app, will anyone buy it? This weakness
could be considered an opportunity for someone with a killer app idea. There’s
probably no competition because of the small number of developers. You
could either take a chance and try to come up with a great app, or because
the Universal Windows Platform goes bigger than just mobile devices, try to
build an app that has a wider use case than the phone alone.
Another weakness for UWP development is the documentation. Lots of the
documentation out there is for Windows Phone 8 or earlier. In a number of
cases I found promising techniques that simply didn’t work because there’s
a newer way to do things. Make sure you pay attention to the date when you
find information online about developing for Windows.
Final Thoughts on Windows Phone
All in all, the Universal Windows Platform is a great development platform.
Once I was able to find the correct documentation, or the part of the SDK
that did what I wanted, it was surprisingly easy to use. One of the most
powerful features is the ability to make the app work on either phone or
desktop. There’s no easier way to build an app for both mobile and desktop
use cases sharing so much of the same codebase. And don’t forget Xbox. If
you’re at all curious about Windows development, with UWP now available
there’s never been a better time to get started.
report erratum  •  discuss
Wrapping Up Windows Phone • 179

Part II
Cross-Platform Tools
In the remaining three weeks, we’ll use three pop-
ular cross-platform tools, RubyMotion, Xamarin,
and React Native, to build apps that run on more
than one of the official native platforms.

CHAPTER 6
RubyMotion
Like a lot of developers, I got my first introduction to Ruby through Rails. I
got on board just as Rails was hitting 1.0, and I loved it. There was no other
language or platform like it (that I knew of). Building web apps with Rails was
a little spooky, in fact. It was a little too easy. It was hard to trust something
that worked with so little coding. Everything that worked well about Rails
was certainly due to the Rails team’s creativity, innovation, and dedication
to simplicity. All of that innovation and simplicity was made possible by Ruby.
The immense popularity that Ruby gained caused a new generation of devel-
opers to look at languages, frameworks, and any of the business problems
they had to solve with a fresh, skeptical eye. “Does it really have to be this
hard?” they asked. “Do we really need to write this much code? I don’t in
Ruby!” Out of that movement came a number of projects to put Ruby every-
where. In addition to the standard Ruby, which now had to be called MRI, or
Matz’s Ruby Interpreter, JRuby put Ruby on the JVM,
1 IronRuby put Ruby
on .NET,
2 and then in 2012 an ex-Apple engineer, Laurent Sansonetti, put
Ruby on iOS with RubyMotion.
3
When it was announced that RubyMotion 3.0 would include Android support,
there was already a thriving, loyal community of RubyMotion for iOS develop-
ment. Android support adds RubyMotion, at least nominally, to the list of
cross-platform solutions. This week we’ll see what it’s like to build for both
platforms using RubyMotion and to what extent cross-platform app building
is possible.
1.
http://jruby.org
2.
http://ironruby.net/
3.
http://rubymotion.com
report erratum  •  discuss

A To-Do App
This week we’ll create a to-do-list app—or rather two apps. The time-honored
to-do app is almost a “Hello World” for mobile app development. That makes
it great development fodder for learning RubyMotion. We won’t need to focus
on a lot of the complexities of building an app on Android or iOS; we’ll instead
be able to focus on what it means to build an app for those platforms using
RubyMotion.
That’s where we’ll keep the focus, too: on seeing what it means to build an
Android app, taking into account the specific needs of that platform, and then
building an iOS app and exploring how it might be possible to consolidate
some code into a cross-platform project. In short, we’ll focus on discovering
how close we can get to writing a cross-platform app using RubyMotion. This
is an ambitious goal for just a few days, but you’ll come away with a solid
understanding of how RubyMotion development on both platforms compares
to platform-native development.
We’ll begin the week by writing a complete Android to-do app. The API provides
a RESTful to-do app at /todos, and we’ll be using that to retrieve the to-do list,
update to-dos to be complete, and create new to-dos. We’ll display the to-dos
in a list with an affordance for marking them done or not and then adding a
way to create new to-dos. On Day 2 we’ll do the same thing with an iOS app
with all the same features. We’ll also explore testing with RubyMotion a bit
more. Then finally on Day 3 we’ll explore writing cross-platform code with
RubyMotion. We’ll consolidate the logic of interacting with the API into a
cross-platform module that will use adapters for each platform. The adapters
Chapter 6. RubyMotion • 184
report erratum  •  discuss

will be configured on a per-project basis, so one for Android and one for iOS.
This will get us part of the way toward a cross-platform codebase and hope-
fully give you an idea of how you might go further in your own projects. Let’s
get moving!
Day 1: ✓ Android
Or, Using RubyMotion to Write an Android App
RubyMotion began as a way to write iOS apps with Ruby. It was three years
later, with version 3.0, that Android support was added. This is an exciting
prospect for anyone wanting to write cross-platform apps with Ruby, or per-
haps just use the more friendly Ruby syntax. The question is, how far does
this capability take you? What does it feel like to write an Android app?
Today we’ll write a full Android app using RubyMotion, and you should be
able to get a good sense of what it feels like. We’ll create a project and then
configure the theme, using Android resources and Java dependencies. We’ll
build an API layer, testing it using RubyMotion’s excellent console. Then we’ll
work on the view—displaying, updating, and creating to-dos. Let’s get started
by creating an Android project.
Creating an Android Project
We create RubyMotion projects from the command line, using the motion util-
ity. Because RubyMotion support for Android came after the original iOS-only
first version, you’ll need to specify that you want an Android project as opposed
to the default iOS. Here’s the command to create an app called Todo using
the Android template.
$ motion create --template=android Todo
This will create a project with the following files:
Todo
├──Gemfile
├──Rakefile
├──app
│
└──main_activity.rb
└──spec
└──main_spec.rb
Like most Ruby projects, it contains a Gemfile for specifying RubyGem depen-
dencies and a Rakefile for project-management tasks. The application code files
all go in the app directory, and the spec directory contains spec files. Let’s take
a look at the generated application code file, app/main_activity.rb.
report erratum  •  discuss
Day 1: ✓ Android • 185

RubyMotion/rubymotion_01_01_initial_create/Todo/app/main_activity.rb
class MainActivity < Android::App::Activity
def onCreate(savedInstanceState)
super
end
end
Although this is a simple file at this point, there are a few important things
to note. This Ruby class corresponds to an Android Activity. You can see this
by the class that it extends, Android::App::Activity. In RubyMotion for Android, we
have access to Java classes in the underlying system and in third-party
libraries, but we need to refer to them by their fully qualified class name, with
the package path expressed as Ruby modules.
Next, notice that the Android Activity life-cycle method onCreate is implemented
here as a Ruby method. Capitalization matters, as RubyMotion doesn’t mag-
ically convert the more popular snake_case convention to camelCase. The
code, though, is pure Ruby, and almost everything you can do in MRI Ruby
you can do in RubyMotion code. Let’s take a look at configuring the project.
Configuring and Running the Project
Project configuration is controlled in the project Rakefile. Let’s make a few
changes.
RubyMotion/rubymotion_01_02_android_config/Todo/Rakefile
Motion::Project::App.setup do |app|
# Use `rake config' to see complete project settings.
app.api_version = "17"
app.package = "com.sevenapps"
app.name = 'Todo'
app.archs << "x86"
end
In addition to setting the app name to Todo, we explicitly set the minimum
API version to 17, which correlates to release 4.2. Next we set the package to
com.<yourdomain>. This is part of the unique identifier in the Play Store. Finally
we add x86 to the list of architectures, which will allow us to deploy the app
to Genymotion or a HAXM emulator.
4 5
Since we changed the API version, RubyMotion needs to have that API avail-
able. This terminal command will accomplish that:
$ motion android-setup --api_version=17`
4.
https://www.genymotion.com
5.
https://software.intel.com/en-us/android/articles/speeding-up-the-android-emulator-on-intel-architecture
Chapter 6. RubyMotion • 186
report erratum  •  discuss

To get an idea of all the configuration values that are possible to change, and
to see how they’re defaulted, you can use the rake config task.
$ rake config
api_version
: "17"
application_class
: nil
archs
: ["armv5te", "x86"]
assets_dirs
: ["./assets"]
build_dir
: "./build"
features
: []
files
: ["./app/main_activity.rb"]
icon
: nil
logs_components
: ["com/sevenapps:I", "AndroidRuntime:E...
main_activity
: "MainActivity"
manifest
: {"xmlns:android"=>"http://schemas.and...
motiondir
: "/Library/RubyMotion"
ndk_path
: "/Users/tony/.rubymotion-android/ndk"
name
: "Todo"
optional_features
: []
package
: "com.sevenapps"
permissions
: []
resources_dirs
: ["./resources"]
sdk_path
: "/Users/tony/.rubymotion-android/sdk"
services
: []
specs_dir
: "./spec"
sub_activities
: []
support_libraries
: []
target_api_version
: "23"
theme
: "@android:style/Theme.Material.Light"
version_code
: "1"
version_name
: "1.0"
As you can see, this will also list the values we’ve just set. Now let’s look at
the app on an emulator. Start up an emulator and issue the command for
the emulator Rake task.
$ rake emulator
This will build the app and deploy it to a running emulator, which should
also work with Genymotion, if you prefer. If you’d like to run the app on the
device instead, then use rake device. The figure on page 188 shows the basic
generated app.
Just like the configuration says, the app is using the Light theme, which is
something we’ll change in just a bit. First, now that we’ve seen the app run-
ning, let’s run the spec that RubyMotion generated as well.
report erratum  •  discuss
Day 1: ✓ Android • 187

Running Specs
Specs are tests written in RubyMotion’s test framework, called Bacon,
6 which
is similar to RSpec.
7 The generated spec is a simple one that specifies that
the title of the app should be Todo.
RubyMotion/rubymotion_01_01_initial_create/Todo/spec/main_spec.rb
describe "Main activity" do
it "has a title" do
main_activity.title.should == "Todo"
end
end
The specs can be run with either rake spec, which is shorthand for rake
spec:emulator, or rake spec:device. RubyMotion specs are a very cool part of the
framework. They make it much easier to write tests for your mobile app than
most of the available test frameworks on either Android or iOS, especially
given Ruby’s succinctness.
Specs are definitely an area to spend more time on later. Today we’ll move on
and configure the app to use a different, more modern theme.
6.
https://github.com/chneukirchen/bacon
7.
http://rspec.info
Chapter 6. RubyMotion • 188
report erratum  •  discuss

Configuring the App Theme
Instead of the Light theme, we’ll use a theme with a dark action bar from
Google’s v7 Support appcompat library.
8 This is a simple change, conceptually,
but it actually takes a few steps that will help familiarize you with RubyMotion
Android project configuration. The first thing we need to do is get the support
library JAR and make sure it’s available for compilation.
The appcompat library ships as a project, not just a JAR, because it contains
resource files as well as code. It also depends on the support library, which
ships as a JAR. Here are the configuration file changes to add these depen-
dencies to our project.
RubyMotion/rubymotion_01_03_change_theme_with_resource/Todo/Rakefile
Motion::Project::App.setup do |app|
# Use `rake config' to see complete project settings.
app.api_version = "17"
app.package = "com.sevenapps"
app.name = "Todo"
app.archs << "x86"
app.vendor_project :jar =>
'vendor/appcompat/libs/android-support-v4.jar'
app.vendor_project :jar =>
'vendor/appcompat/libs/android-support-v7-appcompat.jar',
:resources => 'vendor/appcompat/res',
:manifest => 'vendor/appcompat/AndroidManifest.xml'
app.theme = "@style/AppTheme"
end
By convention, included JARs go in the vendor directory in some kind of
meaningful structure. The vendor_project app-configuration method tells Ruby-
Motion to add the dependency. In the case of a simple JAR, the :jar key is
enough to add the library. If the library contains other resources, then the
:resources and :manifest key need to be specified as well.
With the libraries added, the final configuration line sets the app’s theme to
be @style/AppTheme. You should recognize this as an Android style resource.
Resources can be added to the build by placing them in the default resources
directory, much like in a conventional Android project. Here’s the style
resource file that creates the theme called AppTheme:
8.
https://developer.android.com/tools/support-library/features.html
report erratum  •  discuss
Day 1: ✓ Android • 189

RubyMotion/rubymotion_01_03_change_theme_with_resource/Todo/resources/values/styles.xml
<resources>
<style
name="AppTheme"
parent="Theme.AppCompat.Light.DarkActionBar">
</style>
</resources>
Finally, we change the activity to extend AppCompatActivity, which is necessary
to take advantage of the support library’s action-bar features.
RubyMotion/rubymotion_01_03_change_theme_with_resource/Todo/app/main_activity.rb
class MainActivity < Android::Support::V7::App::AppCompatActivity
def onCreate(savedInstanceState)
super
end
end
Run the app in the emulator and you’ll see the app with the new theme, as
the following figure shows.
Now let’s move on and look at one of the most interesting tools RubyMotion
comes with, the console.
Using the Console
Many times when writing mobile apps I’ve wanted a way to inspect or
manipulate the running application instead of having to go through the
Chapter 6. RubyMotion • 190
report erratum  •  discuss

compile-install cycle over and over. There are some tools that accomplish
something like this for some use cases, but one of the coolest features of
RubyMotion is its console. The console is an honest-to-goodness REPL like
MRI Ruby’s irb. It takes advantage of Ruby’s interpreter to allow you to inspect
and affect the running RubyMotion app.
The console becomes available after starting the app via rake. Have a look at
this session output, where I ran the app on a device and then changed the
title to a different one while the app was still running.
$ rake device
Compile ./app/main_activity.rb
...
Install ./build/Development-17/Todo.apk
5940 KB/s (2724383 bytes in 0.447s)
Start com.sevenapps/.MainActivity
--------- beginning of main
--------- beginning of system
>> getSupportActionBar
=> #<android.support.v7.internal.app.WindowDecorActionBar:0x10001d>
>> getSupportActionBar.getTitle
=> "Todo"
>> getSupportActionBar.setTitle "Todo App"
=> #<android.support.v7.internal.app.WindowDecorActionBar:0x100025>
>>
This works because the console starts in the context of the main activity—in
other words, self refers to an instance of MainActivity. This opens up a different
way to explore and plan solutions to certain problems, and it offers another
tool that you can use to be more effective in your day-to-day development.
We’ll use the console in the next section, where we build an API layer.
Building an API Layer
There are a number of possible ways to build out the API access portion of
an Android app. After a few false starts due to some issues translating Java
patterns and tools to Ruby, I landed on a reasonable pattern that we’ll go
through here. For each decision I made, whether related to patterns or
libraries, I’ll discuss some other potential Android solutions and why they
perhaps didn’t translate well to RubyMotion.
Let’s start by looking at the libraries for HTTP access and JSON parsing.
report erratum  •  discuss
Day 1: ✓ Android • 191

Adding Dependencies
The API layer will depend on two libraries: OkHttp for an HTTP client and
Gson for a JSON parser.
9 10 Gson will make it easier to quickly parse JSON
content into native objects. We add these to the Rakefile as with the other
dependencies.
RubyMotion/rubymotion_01_04_api_interaction/Todo/Rakefile
app.vendor_project :jar => 'vendor/okhttp-2.4.0.jar'
app.vendor_project :jar => 'vendor/okio-1.4.0.jar'
app.vendor_project :jar => 'vendor/gson-2.3.1.jar'
We also need to include the okio JAR, which OkHttp depends on. With the
dependencies in place, we can lay the groundwork for asynchronous commu-
nication with the main activity by creating a BroadcastReceiver.
Creating a BroadcastReceiver
We’ll use a BroadcastReceiver to receive the results of API operations because
this allows us to keep the API decoupled from the activity. Here is the code
for that class.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/main_activity.rb
class TodoReciever < Android::Content::BroadcastReceiver
def onReceive(context, intent)
action = intent.getAction
case action
when LOAD_TODOS_COMPLETE_ACTION
todos = intent.getSerializableExtra LoadTodosOperation::TODOS
puts "Loaded todo list: #{todos}"
when CREATE_TODO_COMPLETE_ACTION
todo = intent.getSerializableExtra CreateTodoOperation::TODO
puts "Created todo: #{todo["title"]}"
end
end
end
You’ll notice that we use the same receiver for two types of API action, loading
and creating. For now, to test that everything works, we’re just going to write
the data we pull from the intent’s “extra” to the RubyMotion console using
the Ruby command puts.
Of course it’s possible to use Android’s Log.d and so forth, but that will write
to the Android logs instead. You should use Ruby console printing for quick
testing and Android’s logging for longer-term application logging needs.
9.
https://github.com/square/okhttp
10. https://sites.google.com/site/gson
Chapter 6. RubyMotion • 192
report erratum  •  discuss

Now that we have a receiver we need to register it for the intent actions we
want it to receive. We’ll do that in the main activity’s onCreate.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/main_activity.rb
def onCreate(savedInstanceState)
super
@todoReciever = TodoReciever.new
createIntentFilter =
Android::Content::IntentFilter.new(CREATE_TODO_COMPLETE_ACTION)
loadIntentFilter =
Android::Content::IntentFilter.new(LOAD_TODOS_COMPLETE_ACTION)
Android::Support::V4::Content::LocalBroadcastManager.
getInstance(self).registerReceiver(@todoReciever, createIntentFilter)
Android::Support::V4::Content::LocalBroadcastManager.
getInstance(self).registerReceiver(@todoReciever, loadIntentFilter)
end
Next, we’ll add two helper methods on the activity, one to load to-dos and one
to create a to-do, given a title.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/main_activity.rb
def loadTodos
LoadTodosOperation.new(getApplicationContext).execute
end
def createTodo(title)
CreateTodoOperation.new(getApplicationContext, title).execute
end
These operation classes will do the actual heavy lifting. They’re not Android
or RubyMotion API classes. They’re completely my own invention to deal with
some of the intricacies of Android asynchronous code. Note that we use
getApplicationContext to pass a context to the operation instead of passing a ref-
erence to the activity itself. Let’s dig into how the operations work and the
reasons for this kind of approach.
Writing Safe Asynchronous Code
As you may remember from the third week (in the Android chapter), there
are some Android-specific pitfalls to asynchronous code that we need to avoid.
We can’t write long-running code to run on the main thread, of course, but
traditional Java solutions like threads are too heavy. For tasks like commu-
nicating with the API over the network, this leaves us with solutions like
AsyncTasks, Services, and Loaders.
Possible Solutions
A Service is a possible solution, but since we saw an example of that in the
Android chapter, I decided to try something different.
report erratum  •  discuss
Day 1: ✓ Android • 193

I tried to implement a Loader but quickly ran into issues because those classes
are heavily dependent on Java generics, which we can’t express in Ruby.
The least heavyweight option left is an AsyncTask, but as we saw, it’s important
not to keep any reference to the calling activity in the task so that we can
avoid problems during activity configuration changes such as device rotations.
This kind of problem has also been addressed in the RubyMotion communi-
ty—for instance, with libraries like motion-async.
11 Just make sure that
whatever solution you choose, it accounts for all of the Android quirks, such
as configuration changes. Instead of using a third-party library, I took the
roll-your-own approach here as an example of a possible solution.
An Operation Runnable
We’ve dealt with the problem of decoupling the asynchronous code from the
activity by using a BroadcastReceiver, so it’s possible to use an AsyncTask. However,
we wouldn’t be using many of the features, such as posting progress or Java
generics for type-checking of the inputs and outputs.
There happens to be a way to use the AsyncTask thread pool to execute a simple
Java Runnable by calling AsyncTask.execute. A Runnable is a Java interface that
specifies one method, run. To implement an interface in RubyMotion, we just
add the methods that the interface requires, since there’s no Ruby analog to
implementing a Java interface through code.
So, my simple homegrown approach is to build simple Runnable classes to
interact with the API and to run them through this AsyncTask utility method.
There’s more than one way to approach the problem, but I like this command
pattern–like approach, at least for our simple app. Let’s look at the code.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/api/operations/operation.rb
class Operation
def initialize(context)
@context = context
end
def new_intent(action)
Android::Content::Intent.new(action)
end
def broadcast_intent(intent)
broadcastManager =
Android::Support::V4::Content::LocalBroadcastManager.getInstance(@context)
broadcastManager.sendBroadcast intent
end
11. https://github.com/darinwilson/motion-async
Chapter 6. RubyMotion • 194
report erratum  •  discuss

def execute
Android::Os::AsyncTask.execute self
end
def add_serializable_extras(intent, extras)
extras.each do |key, value|
addSerializableExtra intent, key, value
end
end
end
In order to use the LocalBroadcastManager later on, we need an instance of a
context, so we make that a constructor parameter, passed to initialize.
Now this is a place to be careful in Android—holding on to contexts—which
this is why we used getApplicationContext() to pass in a context instead of having
the operation instance keep a reference to the activity (which is also a Context.)
The new_intent method is a helper method to avoid superfluous verbosity when
creating Intents. Similarly, broadcast_intent is a helper method for operation
implementations to broadcast an intent, and execute is for having an operation
execute itself.
To send object data through the Android system using Intents, the object must
implement either Parcelable or Serializable. This presents a problem for RubyMotion
because Ruby has no concept of interfaces, so they can’t be implemented by
a Ruby class that we make. My solution is to have a helper method called
add_serializable_extras to encapsulate a Java method, addSerializableExtra(), which
we’ll look at next.
There are a few places where RubyMotion Android programmers need to be
creative when working with the impedance mismatch between Java and Ruby.
One of these is when dealing with overloaded Java methods without being
able to specify types in Ruby. Luckily RubyMotion has at least one possible
solution, which is to write a companion Java file that will get mixed into the
class defined in Ruby.
Using Companion Java Files
To mix Java code into a Ruby file, create a .java with the same name and in
the same directory as the Ruby file. This is useful for adding a function that
must use a feature of Java with no analog in Ruby, like generics, or in the
case we need here, a type cast to Serializable. Without this cast, Java won’t pick
the right method to add an extra to the Intent, so we have to help it choose.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/api/operations/operation.java
public void addSerializableExtra(
report erratum  •  discuss
Day 1: ✓ Android • 195

android.content.Intent intent,
java.lang.String key,
java.io.Serializable value) {
intent.putExtra(key, (java.io.Serializable)value);
}
Notice that we don’t write a class in the Java file—just a bare method that
gets added at build time. Also, since we have no access to import statements,
we need to fully qualify each class. This technique is of limited use, but it’s
helpful when you need it.
With the Operation base class in place, including its Java companion file, we
can write an operation to load the to-dos and broadcast them to any listening
receiver.
RubyMotion/rubymotion_01_04_api_interaction/Todo/app/api/operations/load_todos_operation.rb
class LoadTodosOperation < Operation
TODOS = "todos"
def run
api = TodoApi.new
todos = api.get_all_todos
intent = new_intent MainActivity::LOAD_TODOS_COMPLETE_ACTION
add_serializable_extras intent, TODOS => todos
broadcast_intent intent
end
end
With the addSerializableExtra helper method in place, the list of to-dos will be
added to the broadcast intent as a Serializable.
The LoadTodosOperation uses a TodoApi class, calling get_all_todos. Let’s look at that
class now.
Building the API Adapter
The TodoApi class will use OkHttp to make the HTTP calls to the API. Let’s go
over the class’s utility methods.
Chapter 6. RubyMotion • 196
report erratum  •  discuss

RubyMotion/rubymotion_01_04_api_interaction/Todo/app/api/todo_api.rb
def client
Com::Squareup::Okhttp::OkHttpClient.new
end
def request_builder
builder = Com::Squareup::Okhttp::Request::Builder.new
builder.header "Content-Type", "application/json"
builder.header "Accept", "application/json"
yield builder
builder.build
end
def form_body_builder
builder = Com::Squareup::Okhttp::FormEncodingBuilder.new
yield builder
builder.build
end
def execute_request(request)
client.newCall(request).execute()
end
def parse_array_response(response)
stream = response.body.charStream
deserializeTodoArray stream
end
def parse_object_response(response)
stream = response.body.charStream
gson = Com::Google::Gson::Gson.new
gson.fromJson(stream, Java::Util::HashMap)
end
First, client() is a helper method to create a new OkHttpClient, and request_builder()
is a helper method to create and set defaults on a Request.Builder. It sets a few
defaults and then yields the builder to a block for further manipulation.
Likewise, form_body_builder() does the same with a builder for an HTTP form.
Another helper method, parse_array_response, is for parsing the results of an
HTTP call into a Ruby array. Here again, we need to use a companion Java
file to get Gson to parse array results into an array of java.util.HashMap. The
deserializeTodoArray() is defined in todo_api.java. However, when deserializing a
single object, we can work in Ruby, with parse_object_response.
And here are the methods for getting and creating to-dos, which use the
utility methods we just discussed.
report erratum  •  discuss
Day 1: ✓ Android • 197

RubyMotion/rubymotion_01_04_api_interaction/Todo/app/api/todo_api.rb
def get_all_todos
request = request_builder do |builder|
builder.url base_url
end
response = execute_request request
parse_array_response response
end
def create_todo(title)
request_body = form_body_builder do |form_builder|
form_builder.add "todo[title]", title
end
request = request_builder do |builder|
builder.url base_url
builder.post request_body
end
response = execute_request request
parse_object_response response
end
With TodoApi and the operation classes in place, we should be able to create
a to-do through the API and then load it back into the app. We don’t have
views with affordances for any of these operations, but we do have the
RubyMotion console. Have a look at the output of a session showing those
calls from the main activity.
$ rake emulator
...
Start com.sevenapps/.MainActivity
--------- beginning of main
--------- beginning of system
>> loadTodos
=> android.os.AsyncTask
I/com/sevenapps( 2161): Loaded to-do list: []
>> createTodo "Get Milk"
=> android.os.AsyncTask
I/com/sevenapps( 2161): Created to-do: Get Milk
>> loadTodos
=> android.os.AsyncTask
I/com/sevenapps( 2161): Loaded to-do list:
[{"id"=>1.0, "url"=>"http://10.0.2.2:3000/todos/1.json",
"complete"=>false, "title"=>"Get Milk"}]
Chapter 6. RubyMotion • 198
report erratum  •  discuss

How cool is that, to be able to test our code from right in the app without
even having made a view yet? Now that we’ve seen it in action, we can start
creating a view to display the to-dos we load from the API.
Displaying To-Dos
When writing apps with RubyMotion you have a choice to make when it comes
to view code. Android already has its resource system in place, including a
language for defining views using XML. In the Ruby community at large,
there’s a strong tendency to avoid writing code in anything but Ruby, and
the RubyMotion community shares this tendency.
Since Ruby is such a terse, expressive language, it makes sense to tend toward
Ruby. However, constructing views using the Android view classes, especially
given the requirement to use fully qualified names, would get verbose and
confusing rather quickly. There are third-party libraries that help make
writing view code with Ruby easier, but we’re not going to look at those today.
Keep in mind also that because of Android’s resource qualifiers you have a
lot of power built in to easily define different views for different configurations.
It’s a trade-off either way. Since our views are so simple for this app, we’ll
use standard Android XML layout.
Building Views Using Android XML
The view for the main activity will need to display a list of to-dos, so we’ll
create a simple linear layout with a list view.
RubyMotion/rubymotion_01_05_display_todos/Todo/resources/layout/main_layout.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent">
<ListView
android:id="@+id/todo_list"
android:layout_height="wrap_content"
android:layout_width="match_parent">
</ListView>
</LinearLayout>
Since a to-do item in the list needs to be marked as complete or not, a good
choice for the list items is a CheckBox, which can be toggled on or off but also
acts as a label.
report erratum  •  discuss
Day 1: ✓ Android • 199

RubyMotion/rubymotion_01_05_display_todos/Todo/resources/layout/todo_item.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:orientation="vertical"
android:layout_width="match_parent"
android:layout_height="48dip">
<CheckBox
android:id="@+id/todo_checkbox"
android:layout_width="wrap_content"
android:layout_height="wrap_content" />
</LinearLayout>
With the views in place, we’ll need an Adapter to turn the to-do data into views
displayed in the list.
Creating an Array Adapter
The best adapter to use here is an ArrayAdapter. It’s already suited to most of
what we want to do: have a ListView display the data from an array. We just
need to override the getView method to configure the correct list item view.
RubyMotion/rubymotion_01_05_display_todos/Todo/app/adapter/todo_adapter.rb
class TodoAdapter < Android::Widget::ArrayAdapter
attr_writer :todos
class TodoViewHolder
attr_accessor :checkbox
end
def getView(position, convert_view, parent_view)
if convert_view.nil?
inflater = Android::View::LayoutInflater.from getContext
convert_view = inflater.inflate R::Layout::Todo_item, parent_view, false
view_holder = TodoViewHolder.new
convert_view.setTag view_holder
view_holder.checkbox = convert_view.findViewById R::Id::Todo_checkbox
else
view_holder = convert_view.getTag
end
todo = getItem position
view_holder.checkbox.tap do |cb|
cb.setText todo["title"]
cb.setChecked todo["complete"]
end
convert_view
end
end
Chapter 6. RubyMotion • 200
report erratum  •  discuss

The TodoViewHolder class is an example of the “view holder” pattern. We create
a simple inner class that can cache references to views in the list items.
Looking up views with findViewById() is an expensive operation, so this pattern
makes our code a bit more efficient.
Again, the getView method is there to cut down on processing time. Android
recycles list items, so if no item exists to be recycled, then convert_view will be
nil—we should create a new item, create a view holder for its check box, and
place a reference in the tag field. Otherwise, if a recycled view exists we just
grab its view holder from its tag. Finally, we load the view up with data from
the to-do at the current position.
With the adapter written, now we kick everything off from onStart in the main
activity.
RubyMotion/rubymotion_01_05_display_todos/Todo/app/main_activity.rb
def onCreate(savedInstanceState)
super
setContentView R::Layout::Main_layout
createReceiver
end
def onStart
super
@listView = findViewById R::Id::Todo_list
loadTodos
end
def loadTodos
LoadTodosOperation.new(getApplicationContext).execute
end
def displayTodos(todos)
@listView.setAdapter(createAdapter(todos))
end
def createAdapter(todos)
TodoAdapter.new(self, 0, todos)
end
When the load call is complete, the receiver calls displayTodos, which will create
a new adapter for the list view with the array of to-dos. Run the code in the
emulator to see it in action. The figure on page 202 shows an example list.
Next we’ll look at the code for completing to-dos.
report erratum  •  discuss
Day 1: ✓ Android • 201

Completing To-Dos
Completing to-dos is fairly straightforward. First, we need to know which to-
do item is clicked, so in the adapter we’ll store its position in the check box
component’s tag. That way when we get a reference to the check box, we can
get its position in the to-do list from the tag.
RubyMotion/rubymotion_01_06_complete_todos/Todo/app/main_activity.rb
def createAdapter(todos)
TodoAdapter.new(self, 0, todos).tap do |adapter|
adapter.todo_checkbox_listener = self
end
end
We’ll also set the check box’s onClickListener to todo_checkbox_listener. The click lis-
tener for a check box is expected to have a method called onClick. Then, when
the adapter is created, we’ll set that listener to the main activity.
RubyMotion/rubymotion_01_06_complete_todos/Todo/app/adapter/todo_adapter.rb
view_holder.checkbox.tap do |cb|
cb.setText todo["title"]
cb.setChecked todo["complete"]
cb.setTag position
cb.setOnClickListener todo_checkbox_listener
end
Now when a box is clicked, the main activity’s onClick method will be called.
Chapter 6. RubyMotion • 202
report erratum  •  discuss

RubyMotion/rubymotion_01_06_complete_todos/Todo/app/main_activity.rb
def onClick(checkbox)
position = checkbox.getTag
todo = @listView.getAdapter.getItem(position)
todo["complete"] = checkbox.isChecked
UpdateTodoOperation.new(getApplicationContext, todo).execute
end
In this method we get the position from the check box’s tag, find that to-do,
set its complete key to the state of the check box, and update that to-do in the
API. Now let’s look at creating new to-dos.
Creating To-Dos
To create a new to-do, we’ll use a simple dialog box with a text-input control.
To open the dialog, the user will use the action-bar menu. For the Android
app we made in week three we didn’t use any of these controls, dialogs or
menus, so let’s look at how to build them, starting with the menu.
Adding a Menu Item
You have the option of building the menus with code or defining them in XML,
in which case menus are resources like strings or colors and can easily take
advantage of the resource qualifier system. Here is an XML menu definition.
RubyMotion/rubymotion_01_07_add_todo/Todo/resources/menu/menu.xml
<menu xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto">
<item android:id="@+id/action_new" android:title="@string/menu_new"
android:orderInCategory="100" app:showAsAction="ifRoom" />
</menu>
Notice that the menu item’s title is a string resource and that we set the
showAsAction attribute to ifRoom, so if there’s enough room, the user will see
“New Todo” as a button on the action bar instead of having to click the menu
button to get to it.
There are two methods to override in the main activity for creating the menu
and responding to menu-item selections. They are: onCreateOptionsMenu and
onOptionsItemSelected.
report erratum  •  discuss
Day 1: ✓ Android • 203

RubyMotion/rubymotion_01_07_add_todo/Todo/app/main_activity.rb
def onCreateOptionsMenu(menu)
getMenuInflater.inflate R::Menu::Menu, menu
end
def onOptionsItemSelected(menu_item)
if (menu_item.getItemId == R::Id::Action_new)
displayNewTodoDialog
return true;
end
super
end
When the selected item has the ID of the item we defined in the menu XML
file, we display the dialog to capture the title of the new to-do.
Displaying a Dialog
Android dialog boxes are defined using a dialog builder. We also want to dis-
play a text box in the dialog, and we need a reference to that text box so we
can retrieve the text once the dialog is dismissed. First create a new EditText,
and then define and show the dialog with the text box set to the dialog’s view.
RubyMotion/rubymotion_01_07_add_todo/Todo/app/main_activity.rb
def displayNewTodoDialog
@todoTitleEditText = Android::Widget::EditText.new(self);
Android::App::AlertDialog::Builder.new(self)
.setTitle(getResources.getText(R::String::New_todo_title))
.setMessage(getResources.getText(R::String::New_todo_message))
.setView(@todoTitleEditText)
.setPositiveButton(getResources.getText(R::String::New_todo_create),
DialogClickListener.new(self, :newTodo)
)
.setNegativeButton(getResources.getText(R::String::New_todo_cancel),
DialogClickListener.new
).show
end
def newTodo
createTodo @todoTitleEditText.getText.toString
end
def createTodo(title)
CreateTodoOperation.new(getApplicationContext, title).execute
end
Creating the to-do uses the CreateTodoOperation we defined earlier today. Run
the code, and you should see something like the figure on page 202.
And now we’re able to create new to-do items and display a list of to-
dos—complete to-dos, running on an Android device and written in Ruby.
Chapter 6. RubyMotion • 204
report erratum  •  discuss

What We Learned on Day 1
Today we accomplished a ton. This is the first time in the book that we’ve
created a full app in one day. We covered how to create and configure Android
projects. We’ve seen how we can use Java dependencies, both JARs and
Android libraries with resources.
We saw how to use Android string, style, and layout resources, which work
pretty much as expected. We loaded to-dos from the API, displayed them in
a ListView, updated them, and added them using a Menu and an AlertDialog.
Your Turn
Find
• RubyMotion Android documentation
• RubyMotion StackOverflow tags
• Android Support Library documentation
• RubyMotion third-party libraries (Try GitHub first.
12)
12. http://github.com
report erratum  •  discuss
Day 1: ✓ Android • 205

Do (Easier)
• Deploy the API to some kind of server, perhaps at Heroku,
13 and deploy
the current code to an Android device.
• Think of some other features that could be tested. Add some more specs.
• Add an activity indicator when the app takes any action on the API.
Do (Harder)
• Implement a delete feature so completed to-dos can be deleted from the API.
• Don’t forget the tablets! Use what you learned in the Android chapter to
build out a view that looks good and works well on Android tablets.
Day 2: ✓ iOS
Or, Using RubyMotion to Write an iOS App
Today we’ll continue on to iOS with RubyMotion and build a fully functional
to-do app. We’ll have the same functionality as on the Android side so you
can get a good comparison of the two platforms with RubyMotion.
The user will be able to display, update, and create to-dos all the way through
to the Rails API. We’ll do a little work on the project directory to have the two
projects as part of a bigger project, which we’ll complete on Day 3. We’ll also
build out the iOS API layer using the same signature as the Android applica-
tion in anticipation of building a shared API layer. Let’s get started with today’s
work by creating an iOS RubyMotion project.
Creating an iOS Project
We’ll create the iOS project in the same directory as the Android project so
that tomorrow we can place some common code beside the platform directories.
We want the name of both projects to be Todo, but both project directories
can’t be in the Todo directory. Here are the steps to create the iOS project:
1.
Rename the Android project directory to TodoAndroid.
2.
Create the iOS project with motion create Todo.
3.
Rename the iOS project directory to TodoiOS.
Now you should have an iOS project with the following contents:
13. http://heroku.com
Chapter 6. RubyMotion • 206
report erratum  •  discuss

TodoiOS
├──Gemfile
├──Rakefile
├──app
│
└──app_delegate.rb
├──resources...
└──spec
└──main_spec.rb
With the projects in place, let’s change directories to the iOS project’s and
run the specs.
Fixing and Running Specs
We need to get the specs passing because later on we’ll write another spec.
With the version of RubyMotion I used at the time of writing (3.13) and
Xcode 7, the generated main_spec.rb didn’t pass. I had to make the following
modifications to the generated example.
RubyMotion/rubymotion_02_02_fix_spec/TodoiOS/spec/main_spec.rb
describe "Application 'Todo'" do
before do
@app = UIApplication.sharedApplication
end
it "has a key window" do
@app.keyWindow.should.not.equal nil
end
end
Instead of making sure that there was only one window for the application,
which turned out not to be the case, the spec now makes sure that the app
has a keyWindow. Run rake spec to make sure everything works for you. Now let’s
get data loading in the app.
Designing and Building an API Layer
Let’s talk a little about the design of the API. We’ll stick to the same public
API as in the Android app as much as we can. At the risk of spoiling the
surprise, we’ll do this to extract a common API layer on Day 3.
One difference that we have to deal with right away on iOS is how to return
data from an API call. In the Android project we went out of our way to avoid
having a reference to the calling activity in the API and instead used a
broadcast. On iOS we could do the same with an NSNotification. However, because
it’s less dangerous to have a reference to the caller’s scope, we’ll handle API
call completion in a simpler, more Ruby-like manner.
report erratum  •  discuss
Day 2: ✓ iOS • 207

Handling Call Completion
When the caller, whatever it turns out to be, constructs an instance of the
API class, we’ll pass along a lambda, or a block of code that can be stored
and called later. The API class will keep this in an instance variable called
listener_lambda, and it will expect a list of to-dos and an optional error as
parameters.
RubyMotion/rubymotion_02_03_api/TodoiOS/app/api/todo_api.rb
def initialize(listener_lambda)
@listener_lambda = listener_lambda
config = NSURLSessionConfiguration.defaultSessionConfiguration
config.HTTPAdditionalHeaders = {"Accept" => "application/json",
"Content-Type" => "application/json"}
@session = NSURLSession.sessionWithConfiguration(config)
end
Next, configure an NSURLSession to speak JSON. We’ll use that session to make
the HTTP calls. Let’s look at an example call in the method to load to-dos.
RubyMotion/rubymotion_02_03_api/TodoiOS/app/api/todo_api.rb
def get_all_todos
url = NSURL.URLWithString(base_url)
request = NSURLRequest.requestWithURL(url)
task = @session.dataTaskWithRequest(request,
completionHandler:lambda { |data, response, error|
if error.nil?
jsonError = Pointer.new(:object)
responseDict = NSJSONSerialization.JSONObjectWithData(data,
options:0,
error:jsonError)
if jsonError[0].nil?
Dispatch::Queue.main.async do
@listener_lambda.call responseDict
end
else
Dispatch::Queue.main.async do
@listener_lambda.call nil, jsonError[0]
end
end
else
Dispatch::Queue.main.async do
@listener_lambda.call nil, error
end
end
})
task.resume
end
Chapter 6. RubyMotion • 208
report erratum  •  discuss

Just as we did in the iOS chapter, we use an NSURLSessionDataTask with a com-
pletion handler to make the call to get to-dos. Then we use NSJSONSerialization
to convert the returned JSON data into a native Ruby hash. The data task
performs the HTTP call on a background thread, so to perform the callback
using the listener_lambda, we use the main dispatch queue to call on the main
thread.
As you may have already noticed, Cocoa classes like NSURLSession are treated
in RubyMotion as if they were Ruby classes. You call native methods using
Ruby’s dot syntax instead of Objective-C’s [object message] syntax. Wherever
Cocoa classes can take a block as an argument, a Ruby block will work just
fine. Given this, and considering the need to use fully qualified class names
on the Android side, RubyMotion on the iOS side feels a little less forced and
more natural.
Before we can test this API, we need to configure App Transport Security to
allow us to call localhost without using HTTPS.
Configuring App Transport Security
A requirement on iOS since 9.0 is that all Internet communication be secure.
While we’re developing this app we’d like to call localhost without that
restriction, so we can configure iOS to allow this from the Rakefile.
RubyMotion/rubymotion_02_03_api/TodoiOS/Rakefile
Motion::Project::App.setup do |app|
# Use `rake config' to see complete project settings.
app.name = 'Todo'
app.info_plist['NSAppTransportSecurity'] = {
'NSExceptionDomains' => {
'localhost' => {
'NSIncludesSubdomains' => true,
'NSTemporaryExceptionAllowsInsecureHTTPLoads' => true,
}
}
}
end
Now with an API class in place and app transport security configured, let’s
test it out in the console.
Testing the API in the Console
Here is a console session demonstrating the use of the TodoApi class. Notice
the lambda passed to the constructor, which simply prints the results to the
console.
(main)> api = TodoApi.new lambda{|data, error=nil| puts data}
report erratum  •  discuss
Day 2: ✓ iOS • 209

=> #<TodoApi:0x10ad9c280 @listener_lambda=#<Proc:0x10ad86680 (lambda)>
@session=#<__NSURLSessionLocal:0x10ada2280>>
(main)> api.get_all_todos
=> #<__NSCFLocalDataTask:0x10ace1d50>
(main)> {"id"=>1, "title"=>"Get Milk", "url"=>"http://localhost:3000/todos/1.json...
{"id"=>2, "title"=>"Get More Milk", "url"=>"http://localhost:3000/todos/2.json", ...
{"id"=>3, "title"=>"Get Cereal", "url"=>"http://localhost:3000/todos/3.json", "co...
{"id"=>4, "title"=>"Learn RubyMotion", "url"=>"http://localhost:3000/todos/4.json...
Just as in the Android project, we’ll use Ruby hashes for the to-do data. Now
with an API in place, let’s work on displaying the to-dos to the user.
Displaying To-Dos
To display to-dos, first we need to create a view controller and make it the
root view controller in app_delegate.rb. We can have the view controller extend
UITableViewController to easily get a table view for displaying to-dos. Then we can
configure the cells in the table to display the to-do title and whether the to-
do is complete or not.
Adding a Table View Controller
First let’s look at a bare-bones controller to get a sense of how a class looks.
RubyMotion/rubymotion_02_04_add_table_view/TodoiOS/app/view_controller/todo_view_controller.rb
class TodoViewController < UITableViewController
def viewDidLoad
view.dataSource = view.delegate = self
end
def tableView(tableView, numberOfRowsInSection:section)
0
end
def tableView(tableView, cellForRowAtIndexPath:indexPath)
nil
end
end
Each of the methods named tableView are delegate methods for UITableViewCon-
troller. If you’ve done any iOS programming before in either Swift or Objective-
C, the tableView method signatures will look familiar to you. However, if you’re
coming from Ruby you may do a double take. The syntax here is not possible
to use in MRI Ruby. It will parse, but you won’t be able to call the methods.
RubyMotion does a little syntactical magic to make methods that accept
keyword parameters—like numberOfRowsInSection, which names a method local
variable section.
Chapter 6. RubyMotion • 210
report erratum  •  discuss

With a table view and delegate methods in place, we can add a method to
load the to-dos from the API.
RubyMotion/rubymotion_02_05_load_and_display_to … oiOS/app/view_controller/todo_view_controller.rb
def load_todos
api = TodoApi.new lambda {|data, error = nil|
if error.nil?
self.todos = data
view.reloadData
end
}
api.get_all_todos
end
When the call completes, the lambda will execute, setting the to-dos attribute
to the returned data. The call to view.reloadData will tell the table view to reload,
which will call back to tableView(tableView cellForRowAtIndexPath:indexPath) to get the
table view cell to display for each item.
RubyMotion/rubymotion_02_05_load_and_display_to … oiOS/app/view_controller/todo_view_controller.rb
CellId = "TodoCell"
def tableView(tableView, cellForRowAtIndexPath:indexPath)
cell = tableView.dequeueReusableCellWithIdentifier(CellId) || begin
cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleDefault,
reuseIdentifier:CellId)
cell.selectionStyle = UITableViewCellSelectionStyleNone
cell
end
todo = todos[indexPath.row]
title = todo["title"]
if todo["complete"]
title = "\u2714 " + title
else
title = "
" + title
end
cell.textLabel.text = title
cell.tag = todo["id"]
cell
end
First we dequeue a cell from the pool of reusable cells kept by the table and
configure it. Then we display the title and completion state of the to-do. If the
to-do is complete, we display a check mark, ✓, or unicode glyph 2714. Finally,
for later lookup, we set the cell’s tag to the to-do ID.
The check mark is a bit of a hack, but it’s a fun hack, so we’ll allow it. To
make ourselves feel a little better about it, let’s write a spec to specify that
we should display completed to-dos correctly.
report erratum  •  discuss
Day 2: ✓ iOS • 211

Adding a View Spec for To-Do Completion
We’ll add a new spec to test the view controller we just created. To remove
the need to have the API up and running, and to better test the view controller
in isolation, first we’ll stub out the method that uses the API.
RubyMotion/rubymotion_02_05_load_and_display_todos/TodoiOS/spec/todo_controller_spec.rb
describe "Todo Controller" do
before do
class TodoViewController
def load_todos
# noop, so no api call is made
end
end
end
tests TodoViewController
before do
controller.todos = todo_data.values
end
For this simple spec we won’t try to use a full-blown mocking framework.
Instead we’ll open the TodoViewController class in the first before block and add a
load_todos() that does nothing, thereby removing the dependency on the API.
In RubyMotion’s test framework, the tests macro will instantiate and prepare the
object under test. Any before block before a call to ‘tests ClassName‘ will be run
once, and any before block after a call to ‘tests ClassName‘ will be run once per test.
In the second per-test before block, we set up the provided controller’s to-dos
attribute with some fixture data, defined lower in the test.
Now let’s look at the test itself.
RubyMotion/rubymotion_02_05_load_and_display_todos/TodoiOS/spec/todo_controller_spec.rb
it "marks completed items as complete" do
views(UITableViewCell).each do |cell|
todo = todo_data[cell.tag]
displayed_title = cell.textLabel.text
if todo["complete"]
displayed_title.should.match(/\u2714/)
else
displayed_title.should.not.match(/\u2714/)
end
end
end
def todo_data
{
1 => { "id" => 1,
Chapter 6. RubyMotion • 212
report erratum  •  discuss

"title" => "Get Milk",
"complete" => false },
2 => { "id" => 2,
"title" => "Get Cereal",
"complete" => true }
}
end
The views() method will find all instances of the given class, so calling it gives
us a list of all of the table view cells. Since we set each cell’s tag to the to-do
ID, we can loop over them and look up the corresponding to-do by ID in the
fixture data map.
We complete the test by matching or not matching the title to the unicode
check mark, depending if the to-do is complete or not. At the end of the file
is some fixture data, built as a map of IDs to to-do hashes for easy reference.
Run the specs and you should see output like this:
$ rake spec
...
Application 'Todo'
- has a key window
Todo Controller
- marks completed items as complete
2 specifications (3 requirements), 0 failures, 0 errors
Now that we’ve proven that we can display completed to-dos, let’s go about
writing the code to complete them.
Completing To-Dos
To complete to-dos (or un-complete them), we need to issue a PUT request to
the API with the completed attribute set. It would be fine to simply add this
functionality to TodoApi using NSURLSession. Instead we’ll investigate RubyMotion’s
third-party gem support and install a dependency called AFMotion.
AFMotion is a RubyMotion wrapper around the popular iOS networking library
AFNetworking.
14 15 Let’s see how to declare and load that dependency now.
Adding Dependencies
In the Android project we used a few dependencies, but those were all JAR
files with no Ruby wrapping them at all. For Ruby dependencies, we declare
the dependency in the Gemfile.
14. https://github.com/clayallsopp/afmotion
15. https://github.com/AFNetworking/AFNetworking
report erratum  •  discuss
Day 2: ✓ iOS • 213

RubyMotion/rubymotion_02_06_complete_todo/TodoiOS/Gemfile
source 'https://rubygems.org'
gem 'rake'
gem "afmotion"
Then we need to install the dependency using Bundler and install the
underlying native dependencies.
$ bundle install
$ rake pod:install
AFNetworking is distributed through CocoaPods,
16 so the final rake task needs
to run to install and configure the CocoaPods portion of the project.
With AFNetworking in place, let’s look at refactoring and updating TodoApi with
an update_todo method.
Updating To-Dos
First we’ll add a utility method to construct an AFMotion::Client through the
builder method.
RubyMotion/rubymotion_02_06_complete_todo/TodoiOS/app/api/todo_api.rb
def http_client
AFMotion::Client.build(base_url) do
request_serializer :json
header "Accept", "application/json"
header "Content-Type", "application/json"
response_serializer :json
end
end
It will be configured and ready to send and receive JSON. Then we’ll rewrite
the get_all_todos method and add an update_todo method, which call the lambda
when they’re finished.
RubyMotion/rubymotion_02_06_complete_todo/TodoiOS/app/api/todo_api.rb
def get_all_todos
http_client.get("/todos") do |result|
call_complete(result)
end
end
def update_todo(todo)
http_client.put("/todos/#{todo['id']}", todo) do |result|
call_complete(result)
end
end
16. http://cocoapods.org
Chapter 6. RubyMotion • 214
report erratum  •  discuss

def call_complete(result)
if result.success?
@listener_lambda.call(result.object)
else
@listener_lambda.call(nil, result.error)
end
end
Switching to AFMotion makes TodoApi much cleaner. Now that we have
updating in place, let’s add the ability to create to-dos.
Creating To-Dos
We’ll allow users to create to-dos by tapping a + button from the navigation
bar. That will open a dialog where they can enter the title of a to-do.
Creating an Add Button
We’ll add a method called configure_buttons to deal with adding this button and
call it from viewDidLoad.
RubyMotion/rubymotion_02_07_add_todo/TodoiOS/app/view_controller/todo_view_controller.rb
def configure_buttons
add_button = UIBarButtonItem.alloc.
initWithBarButtonSystemItem(
UIBarButtonSystemItemAdd,
target: self,
action: 'present_add_todo_form')
self.navigationItem.rightBarButtonItem = add_button
end
If you’ve written any iOS code before, you’ll see this is almost a straight
translation. The one thing to note is that the action, or method called on the
target (self) when the add button is pressed, is expressed as a string. Let’s
look at the dialog code now.
Creating a Dialog
These days iOS dialogs are UIAlertController instances presented in the same way
as modal view controllers. First we construct the alert controller, and then
we build some UIAlertAction instances to represent the Add and Cancel options
presented on the dialog.
RubyMotion/rubymotion_02_07_add_todo/TodoiOS/app/view_controller/todo_view_controller.rb
def present_add_todo_form
alert = UIAlertController.alertControllerWithTitle("Add Todo",
message: "Enter title:",
preferredStyle: UIAlertControllerStyleAlert
)
cancelAction = UIAlertAction.actionWithTitle("Cancel",
report erratum  •  discuss
Day 2: ✓ iOS • 215

style:UIAlertActionStyleDefault,
handler:nil
)
addAction = UIAlertAction.actionWithTitle("Add",
style:UIAlertActionStyleDefault,
handler:lambda{|action|
title = alert.textFields[0].text
unless title.empty?
add_todo title
end
}
)
alert.addAction cancelAction
alert.addAction addAction
alert.addTextFieldWithConfigurationHandler nil
presentViewController(alert, animated: true, completion:nil)
end
Note the inline lambda to handle the action on the Add action. First we check
to make sure that the user entered something, and then we call add_todo. This
is a method we’ll add to create a to-do with the given title.
Creating the To-Do
The add_todo method will use the by-now-familiar TodoApi to create a to-do
through a new create_todo method. When the creation is complete, it will reload
all of the to-dos by calling load_todos again.
RubyMotion/rubymotion_02_07_add_todo/TodoiOS/app/view_controller/todo_view_controller.rb
def add_todo(title)
api = TodoApi.new lambda {|data, error = nil|
if error.nil?
load_todos
end
}
api.create_todo title
end
Run the code in the simulator and you should see something like the figure
on page 217.
Chapter 6. RubyMotion • 216
report erratum  •  discuss

Now we have a functional to-do app in iOS written in RubyMotion! Tomorrow
we’ll go back through and see how we can factor out some common code. For
now, though, let’s go over what we’ve covered today.
What We Learned on Day 2
We accomplished a lot today. To me it felt a little less like an uphill battle
than building an Android app. It’s easy to see how smoothly RubyMotion and
Ruby conventions fit with the iOS platform. Keep in mind how it felt to you
as you evaluate using RubyMotion for your projects.
Today we built a to-do app, displayed to-dos loaded from the API, and added
the ability to create and update them. We saw again how useful the RubyMo-
tion console is for testing live code. We also got to dig into writing executable
specs a little more, and we added a RubyGem dependency.
Your Turn
Find
• RubyMotion iOS documentation
• AFMotion documentation
• CocoaPods documentation
• RubyMotion iOS third-party libraries (Try GitHub first.
17)
17. http://github.com
report erratum  •  discuss
Day 2: ✓ iOS • 217

Do (Easier)
• Deploy the API to some kind of server, perhaps at Heroku,
18 and deploy
the current code to an iOS device.
• Think of some other features that could be tested. Add some more specs.
• Add a progress indicator when the app takes any action on the API.
Do (Harder)
• Spec and implement a delete feature so completed to-dos can be deleted
from the device all the way to the API.
• Look into a RubyMotion view library and use it to build iPhone and iPad
versions of the app.
Day 3: ✓ Cross-Platform
Or, Writing Cross-Platform Code
Today we’ll see just how close we can get to writing cross-platform apps with
RubyMotion. RubyMotion is a fairly thin layer on top of system APIs. There
are a lot of MRI Ruby APIs missing, including the networking APIs. This makes
it hard to write really comprehensive cross-platform code, because almost
immediately you must use platform APIs to do meaningful work.
That doesn’t mean that cross-platform code is impossible. We can still think
about areas where we tend to solve the same problems on both platforms,
and then build interfaces to help us generalize the way to think about solving
those problems. Then we can build adapters to handle the platform-specific
things. That’s what we’ll do today—build a shared API access layer that
handles updating to-dos on the Rails API, and then implement platform-spe-
cific HTTP adapters to do the actual network calling. We will get started by
creating a place in the project structure to keep common code.
Creating a Structure for Common Code
Add a directory called common for all shared files. This will contain a directory
called app with two application files and a directory called spec for spec files.
18. http://heroku.com
Chapter 6. RubyMotion • 218
report erratum  •  discuss

/
├──Rakefile
├──TodoAndroid
├──TodoiOS
└──common
├──app
└──spec
We’ll also have a Rakefile for top-level project tasks. First we’ll modify each of
the platform projects to include application code from the common directory,
and then we’ll look at the top-level Rakefile.
Including Common Code
To have common code included in the Android and iOS projects, we just
change the projects’ Rakefiles, modifying the files array in the setup block. Here’s
the new iOS Rakefile.
RubyMotion/rubymotion_03_01_add_common_files/TodoiOS/Rakefile
Motion::Project::App.setup do |app|
# Use `rake config' to see complete project settings.
app.name = 'Todo'
app.files << Dir.glob("../common/app/**/*.rb")
➤
app.info_plist['NSAppTransportSecurity'] = {
'NSExceptionDomains' => {
'localhost' => {
'NSIncludesSubdomains' => true,
'NSTemporaryExceptionAllowsInsecureHTTPLoads' => true,
}
}
}
end
Make sure the same line is added to the setup block in the Android Rakefile.
Notice that this includes only the files from the app directory and lower, not
the spec directory. Now we can look up to the top-level Rakefile.
Adding a Top-Level Rakefile
We’ll have a Rakefile for the top-level project. It will allow any sort of useful
tasks we need, such as running specs at the top level, which we’ll get to next.
We can also do a little Rake magic to make available each of the Rake tasks
in the platform projects to Rake at the top level, namespaced by platform.
report erratum  •  discuss
Day 3: ✓ Cross-Platform • 219

For example, building both the Android and iOS apps from the top level could
be done with the command rake android:build ios:build. It’s not as straightforward
as we’d like to include a lower-level Rakefile, so let’s see how we can do it.
RubyMotion/rubymotion_03_01_add_common_files/Rakefile
# Thanks to https://github.com/lrz/rubymotion-hybrid-sample for
# the idea of a combined rakefile
platform_dirs = {
:android
=> "TodoAndroid",
:ios
=> "TodoiOS"
}
def top_level
File.dirname __FILE__
end
def path_to(directory)
"#{top_level}/#{directory}"
end
platform_dirs.each do |platform, directory|
namespace platform do
rake_command = "/usr/bin/env rake -f Rakefile"
Dir.chdir path_to(directory)
platform_tasks = `#{rake_command} -T`.scan(/rake\s([^\s]+)\s+#\s([^\n]+)/)
platform_tasks.each do |platform_task, task_description|
desc task_description
task platform_task do
Dir.chdir path_to(directory)
sh "#{rake_command} #{platform_task}"
end
end
end
end
desc "Clean platform projects"
task :clean => ["android:clean", "ios:clean"]
First, with platform_dirs, we set up a map of symbols to directories. The symbols
will be the Rake namespaces.
Then, for each namespace and directory pair, we set up a Rake namespace
and include all the commands from that project’s Rakefile. To get the commands
contained in that Rakefile, we’ll open a shell and use Rake to list all the tasks,
and then define a task in the local context, inside of the current namespace.
To execute a task, we change directories and use another shell to run the
rake task from that directory.
We can also build top-level tasks, such as the final clean task, which in turn
executes clean on each of the platform projects.
Chapter 6. RubyMotion • 220
report erratum  •  discuss

Now with a little control at the top level, via Rake, we can turn to building a
common API layer.
Extracting a General API Class
We’re not able to write cross-platform HTTP code using RubyMotion, but we
can spec out a common API access layer that has semantics for our Rails to-
do API. That API class could depend on an HTTP client adapter with a prede-
termined interface.
Then, with that common API class in place, we can build HTTP adapters for
each platform, which will conform to the HTTP client interface we define. In
Ruby there’s no interface and no protocol classes to document this HTTP
client interface. Instead we’ll write a spec for the common API class to show
what kind of interface we expect the HTTP client to have.
Writing a Spec
A number of testing frameworks are available for Ruby. Minitest is available
directly with Ruby,
19 so we’ll use that. To add a spec task to the top-level
Rakefile, add require 'rake/testtask' to the top of the file and then configure the task
like this:
RubyMotion/rubymotion_03_02_spec_common_api/Rakefile
Rake::TestTask.new :spec do |t|
t.libs << "common/app"
t.test_files = FileList['common/spec/*_spec.rb']
end
This will include all of the spec files in common/spec and add common/app to the
load path. Now we can write a spec file, starting with this before block.
RubyMotion/rubymotion_03_02_spec_common_api/common/spec/api_spec.rb
describe TodoApi do
before do
@mock_client = MiniTest::Mock.new
@mock_client.expect :new, @mock_client, [DUMMY_URL]
TodoApi.client_class
= @mock_client
TodoApi.base_url
= DUMMY_URL
end
The MiniTest::Mock instance will stand in for an HTTP client and allow us to
specify its interface and expectations. Here we mock new to expect to be called
and return the mock instance (so the mock will act like both an instance and
a class), and be provided with a URL as its argument.
19. http://docs.seattlerb.org/minitest/
report erratum  •  discuss
Day 3: ✓ Cross-Platform • 221

To configure TodoApi to use a certain HTTP client class and use a given URL,
we’ll make it configurable through class variables. Then each project can
specify its own platform’s HTTP client. This is sort of a poor man’s “inversion
of control.”
Now let’s look at a few examples from the spec, starting with a GET request.
RubyMotion/rubymotion_03_02_spec_common_api/common/spec/api_spec.rb
it "should perform a GET /todos through a given client" do
@mock_client.expect :get, nil do |url, &block|
url == "/todos" && block.nil? == false
end
TodoApi.new(nil).get_all_todos
@mock_client.verify.must_equal true
end
This specifies that when we call get_all_todos on the new, shared TodoApi class,
its HTTP client should expect a method named get to be called, with one
argument, url, and then be provided with a block. It should return nil, the
block should not be nil, and url should be /todos.
To test updating to-dos, here is a spec for PUT calls. It uses a simple dummy
to-do hash with its ID set to 42.
RubyMotion/rubymotion_03_02_spec_common_api/common/spec/api_spec.rb
it "should perform a PUT /todos through a given client" do
todo = {
'id' => 42
}
@mock_client.expect :put, nil do |url, todo_hash, &block|
url == "/todos/42" && block.nil? == false
end
TodoApi.new(nil).update_todo(todo)
@mock_client.verify.must_equal true
end
There’s also an example for POST operations in the spec file, similar to PUT. If
you’d like to run the spec at this point to start your red-green test cycle, issue
the command rake spec to see the specs fail. Now we can build out the new,
shared TodoApi to this spec.
Writing the Shared API Class
First we’ll start with the class-level configuration. When the API class needs
an HTTP client, it will call the http_client method, which expects to construct
one from a class instance stored in @@client_class using the URL stored in
@@base_url.
Chapter 6. RubyMotion • 222
report erratum  •  discuss

RubyMotion/rubymotion_03_02_spec_common_api/common/app/api/todo_api.rb
def http_client
@@client_class.new @@base_url
end
From the specs you can see that we set those class variables through class
methods. The rest of the class comes together pretty simply.
RubyMotion/rubymotion_03_02_spec_common_api/common/app/api/todo_api.rb
def initialize(listener_lambda)
@listener_lambda = listener_lambda
end
def get_all_todos
http_client.get("/todos") do |result, error|
@listener_lambda.call result, error
end
end
def update_todo(todo)
http_client.put("/todos/#{todo['id']}", todo) do |result, error|
@listener_lambda.call result, error
end
end
def create_todo(title)
todo = {
title: title
}
http_client.post("/todos", todo) do |result, error|
@listener_lambda.call result, error
end
end
Notice that we still use the listener_lambda as a completion callback. That pattern
was in the iOS project but not the Android one, so we’ll need to account for
that as we go through and change to using the shared TodoApi. Let’s get
started on that now, first with the iOS project.
Adapting the iOS Project
To change the iOS project to use the new common API class, configure the
new TodoApi and provide an iOS implementation of an HTTP client.
Adding iOS Configuration
Now that we have an API class that’s configurable, we can take advantage of
that to provide, say, a development API URL while in development mode and
a production URL for production. RubyMotion has a concept of environments
much like Rails, which allows us to load configuration files based on the
current environment. Here’s an example in the iOS Rakefile.
report erratum  •  discuss
Day 3: ✓ Cross-Platform • 223

RubyMotion/rubymotion_03_03_common_api_ios/TodoiOS/Rakefile
app.development do
app.files << Dir.glob(File.join(app.project_dir,
'configuration/development/**/*.rb'))
end
You could extend this pattern to deal with other environments. Here is a
configuration file that sets up the TodoApi to use the iOS HTTP client adapter.
RubyMotion/rubymotion_03_03_common_api_ios/TodoiOS/configuration/development/config.rb
TodoApi.client_class = IOSHTTPAdapter
TodoApi.base_url = "http://localhost:3000"
Now let’s look at the iOS HTTP adapter.
Adding an iOS HTTP Adapter
You can see that, besides the method names, the adapter looks much like
the old iOS TodoApi and is really a thin wrapper around the AFMotion::Client.
RubyMotion/rubymotion_03_03_common_api_ios/TodoiOS/app/api/ios_http_adapter.rb
class IOSHTTPAdapter
attr_accessor :base_url
def initialize(url)
@base_url = url
end
def get(url, &block)
http_client.get(url) do |result|
block.call(result.object, result.error)
end
end
def post(url, hash, &block)
http_client.post(url, hash) do |result|
block.call(result.object, result.error)
end
end
def put(url, hash, &block)
http_client.put(url, hash) do |result|
block.call(result.object, result.error)
end
end
def http_client
AFMotion::Client.build(base_url) do
request_serializer :json
header "Accept", "application/json"
header "Content-Type", "application/json"
response_serializer :json
end
Chapter 6. RubyMotion • 224
report erratum  •  discuss

end
end
Run the project in the simulator, and it should work as before. Then we can
move on to changing the Android project over to the new system.
Adapting the Android Project
Moving the Android project is much the same as moving the iOS project—first
the configuration, and then the adapter.
Adding Android Configuration
With the same per-environment configuration in place in the Android Rakefile
as in the iOS one, we can create an Android configuration file with these
contents:
RubyMotion/rubymotion_03_04_common_api_android/TodoAndroid/configuration/development/config.rb
TodoApi.client_class = AndroidHttpAdapter
# Emulator: url = "http://10.0.2.2:3000"
# Genymotion url = "http://10.0.3.2:3000"
TodoApi.base_url = "http://10.0.2.2:3000"
Now let’s look at the Android HTTP adapter.
Adding an Android HTTP Adapter
One difference in design between iOS and Android calls to their old TodoApis
is that on Android the calls were synchronous, or happening directly in order
of execution—that is, not expecting a callback. The iOS code provides TodoApi
with a lambda to be executed after the calls are complete.
This isn’t an arbitrary choice—since we’re calling the TodoApi from an Operation
class running on a thread from the AsyncTask thread pool, the system considers
the object to be complete and eligible for garbage collection as soon as its run
method is complete if no other context is holding a reference to it. Therefore,
having a callback on the Android side won’t work.
That’s easy enough to build into the new TodoApi. We’ll add a method called
finish that will return results directly if no lambda exists.
RubyMotion/rubymotion_03_04_common_api_android/common/app/api/todo_api.rb
def finish(result, error)
if @listener_lambda.nil?
return result, error
else
@listener_lambda.call result, error
end
end
report erratum  •  discuss
Day 3: ✓ Cross-Platform • 225

All that remains is to build an Android HTTP client adapter. Again, this is a
pretty thin wrapper around OkHttp and Gson.
RubyMotion/rubymotion_03_04_common_api_android/TodoAndroid/app/api/android_http_adapter.rb
def get(url, &block)
request = request_builder do |builder|
builder.url "#{base_url}/#{url}"
end
response = execute_request request
block.call(parse_array_response(response), nil)
end
def post(url, hash, &block)
body = serializeHashToString hash
request = request_builder do |builder|
builder.url "#{base_url}/#{url}"
builder.post(json_request(body))
end
response = execute_request request
block.call(parse_object_response(response), nil)
end
def put(url, hash, &block)
body = serializeHashToString hash
request = request_builder do |builder|
builder.url "#{base_url}/#{url}"
builder.put(json_request(body))
end
block.call(execute_request(request), nil)
end
Notice that we changed the put method to send the updated to-do using JSON
instead of HTTP form attributes, and we added a method serializeHashToString in
the Java companion class to help with creating the HTTP body in this case.
Run this in the emulator to see everything working, as before, and then we
can assess what we’ve accomplished so far today.
What We Learned on Day 3
Today we saw how far we could get toward sharing code across platforms on
RubyMotion. We created a directory structure to store that code and added
a top-level Rakefile. We wrote a shared API client as a kind of interface and
then adapted the platform code to use that common API interface.
Your Turn
Find
• MiniTest documentation
Chapter 6. RubyMotion • 226
report erratum  •  discuss

• Popular RubyMotion libraries (If they have useful abstractions that work
on only one platform—probably iOS—think about how they could be
extended to provide a common API for both platforms.)
Do
• If you implemented delete on iOS and Android, make sure that it’s added
to the common library, as well.
• Think about how you might generalize part of the view layer into common
code—perhaps an abstract view interaction layer that uses platform-spe-
cific view code and interacts with the shared TodoApi. What differences in
the platforms make this hard? How can you overcome this? Develop a
plan and implement it.
Wrapping Up RubyMotion
RubyMotion is a lot of fun. It’s refreshing to be able to write mobile apps in
Ruby, and the tools that RubyMotion includes, such as its specs and console,
are more fun to use than the native alternatives on either platform.
Strengths
Of course one of the biggest strengths of RubyMotion is Ruby itself. If you’re
not familiar with the language, you’ll quickly learn to love it. If you’re already
familiar with Ruby, RubyMotion makes you feel right at home.
The console is also really useful when designing an app. To be able to affect
the app in real time makes a more interactive, exploratory style of development
possible, and allows developers to bypass the compile-deploy grind a little
more often.
One of the greatest strengths of RubyMotion is the community. There are a
lot of great third-party libraries that build on the power of Ruby to make
building (especially view-related) code much cleaner and more fun.
Weaknesses
RubyMotion is not without weaknesses. If you have Ruby experience, you
may have grown to depend on some of your favorite Ruby libraries—but you
won’t always find these in RubyMotion. Additionally, a few syntax differences
turn up to surprise you when you least expect it.
RubyMotion is not quite fully a cross-platform solution yet, either. Especially
with the new Android support, RubyMotion isn’t always able to break the
chains of the underlying platform. As you’ve experienced this week with all
report erratum  •  discuss
Wrapping Up RubyMotion • 227

the fully qualified class names and Java companion files, it can be challenging
to wend your way through making an Android app without some fits and
starts. Currently RubyMotion is definitely stronger on iOS.
Final Thoughts on RubyMotion
All things considered, RubyMotion is a fun, productive way to build mobile
applications. With some planning and experience, it’s also possible to dig in
and support development on both Android and iOS with generalized, shared
code. Also, given how recently Android support was added, I expect it to get
better with time, especially as the excellent RubyMotion community gets more
involved with RubyMotion for Android.
Chapter 6. RubyMotion • 228
report erratum  •  discuss

CHAPTER 7
Xamarin
Time and time again in my journey as a mobile developer, clients have asked
about cross-platform tools. “We want an iOS and an Android app; can we do
that with less time and money with tool x?” they ask. I have to confess to
feeling irritated by this sort of question. For many reasons, some valid, some
perhaps elitist, I have a gut feeling that mobile development should be done
with the official tools.
On the other hand, some of my reluctance to use anything but the platform-
native frameworks is due to the number of bad apps out there built with
shortcut solutions, especially those that try to use a web view as the shortcut.
Then again, developing apps can’t happen in a vacuum. If there’s no business
reason to build apps, developers will be out of a job. It’s our responsibility as
developers to guide the stakeholders in the right direction, but also to be able
to see the development process from the stakeholders’ point of view. Can we
build their apps with less time and money? Can we make quality apps, not
shortcuts? And can we keep the codebase maintainable?
Xamarin was the first tool that caused me to rethink my assumption that all
cross-platform tools were intrinsically bad. With Xamarin, you write native
apps, not web-view apps, using platform-native APIs for iOS, Android, or
Windows. You can share code between all of these. You write the apps in C#,
and they run natively on the Mono .NET runtime,
1 so you have access to the
.NET platform as well as the host platform. That’s a powerful combination.
All things being equal, I still prefer development with the official tools; I like
the official tools. But after using it, I believe that in a business setting, with
limited time and resources, Xamarin is a strong contender as a powerful tool
for efficiently building apps for multiple platforms.
1.
http://www.mono-project.com/
report erratum  •  discuss

A Calculator App
This week we’ll build a calculator app. It’s going to have a UI with a display
and a grid of buttons and will run on both iOS and Android. We’ll use shared
code for the calculator “engine” so that we have to write that only once. The
code will be well tested, both in business logic and on the UI. Finally, we’ll
add a feature allowing the user to convert a value in the calculator as if it
were a currency value, from one currency to another.
On Day 1 we’ll build out the iOS and Android UIs and see how platform-spe-
cific development works in Xamarin. Then, on Day 2, we’ll test and build a
calculator model, wire it up to the UI, and then test the UI. On Day 3 we’ll
use Xamarin.Forms to rewrite a cross-platform UI, cutting down the platform-
specific code to almost zero. We’ll finish out Day 3 by consuming data from
our currency-conversion API. Let’s get started!
Day 1: Adding Up the Platforms
Or, Building an iOS and Android View
Today we’ll dive in and build a Xamarin solution, or set of projects, which will
have both an Android and an iOS UI for a calculator. Most of the code we
Chapter 7. Xamarin • 230
report erratum  •  discuss

write will use native APIs and widgets on those platforms, just written in C#
instead of native code.
Creating and Setting Up a Solution
The first step is to use Xamarin Studio to create a new solution. We want to
build this app for both iOS and Android, so we need to choose to build a
cross-platform app. We’ll start with the native single-view app this time. On
Day 3 we’ll rebuild the UI using Xamarin.Forms, so don’t choose that option
at this time. We also want to have unit tests generated, so make sure you
check the box labeled Add an Automated UI Test Project.
The app name should be set to Calc, and the identifier should be set to your
reverse domain name. The solution will contain an iOS-native project, an
Android-native project, and a shared-code project. There are two options for
how to configure that project, and we want it to be a Portable Class Library,
or PCL. Once the solution is created, you’ll see the project layout in the
Solution pane.
The solution contains four projects: Calc.Droid for
Android-specific code, Calc.iOS for iOS-specific code,
Calc for shared code, and, finally, Calc.UITests for all the
testing needs of the solution. Let’s look at some of the
generated code in the native projects. First, we’ll look at
the main Android activity.
Xamarin/xamarin_01_02_cleanup_generated_comments/Calc/Droid/MainActivity.cs
namespace Calc.Droid {
[Activity(Label = "Calc.Droid", MainLauncher = true, Icon = "@drawable/icon")]
public class MainActivity : Activity {
int count = 1;
protected override void OnCreate(Bundle bundle) {
base.OnCreate(bundle);
SetContentView(Resource.Layout.Main);
Button button = FindViewById<Button>(Resource.Id.myButton);
button.Click += delegate {
button.Text = string.Format("{0} clicks!", count++);
};
}
}
}
If you’ve gone through the Android chapter or are familiar with Android pro-
gramming, you can pick out the Android APIs right away, just transcribed
into C#. With Xamarin, access to native APIs on the underlying platform is
report erratum  •  discuss
Day 1: Adding Up the Platforms • 231

gained through the C# versions of those APIs. So, for instance, in this example
Android’s Java android.app.Activity becomes Xamarin’s C# Android.App.Activity and
the onCreate life-cycle method is OnCreate, with a capital O.
You can see that some extra configuration can be done using C#’s attributes,
in this example the code in brackets above the MainActivity class definition.
These attributes are in many ways analogous to Java attributes.
The iOS-generated code is similarly familiar to iOS developers, just in C#
instead of Objective-C. Currently, Xamarin mirrors the Objective-C APIs, not
the Swift versions. Have a look at the generated AppDelegate, shown here.
Xamarin/xamarin_01_02_cleanup_generated_comments/Calc/iOS/AppDelegate.cs
namespace Calc.iOS {
[Register("AppDelegate")]
public class AppDelegate : UIApplicationDelegate {
public override UIWindow Window { get; set; }
public override bool FinishedLaunching(
UIApplication application, NSDictionary launchOptions) {
return true;
}
}
}
In Objective-C the application delegate conforms to the protocol UIApplicationDel-
egate; in Xamarin it extends the C# class UIApplicationDelegate and is registered
with the Register attribute.
Overridden method names try to match the somewhat exotic Objective-C style
as best as they can; for instance, in this example FinishedLaunching is analogous
to application:didFinishLaunchingWithOptions, and it will be called when the application
is launched and running, just as with any iOS app.
As we get further into the code, we’ll see what more and more of the C# syntax
means, so don’t worry if you don’t understand everything in even these simple
generated-code samples. Let’s get started building out the app now, beginning
with the iOS view.
Building an iOS Calculator View
When working with Apple’s official tooling, iOS views are generally built with
interface bundles and storyboards. These files are edited in Xcode’s visual
Interface Builder editor, and the file formats aren’t meant to be hand-edited.
Xamarin’s strategy for dealing with this fact of iOS development has been to
build visual tools that generally copy Interface Builder feature for feature and
Chapter 7. Xamarin • 232
report erratum  •  discuss

that operate on the same files that Xcode would. In fact, it’s possible to con-
tinue to use Xcode to edit all the view files, if you like. We’ll do everything
using Xamarin Studio. Let’s get started by adding a text field to act as the
calculator display.
Adding the Calculator Display
Get started by opening up Calc.iOS/Main.storyboard. You should see a simulation
of an iOS screen in the main view. This is where we can visually build the
app’s view. Make sure the Toolbox and Properties Pads are open by selecting
View > Pads > Toolbox and View > Pads > Properties.
From the Toolbox, drag a label control out onto to the screen and drop it in
the top-left side. As you get close to the left side of the screen, a guide line
should pop up around 20 pixels from the edge. It’s not important to be exact
at this point, however; we’ll adjust the label’s positioning next.
Adding Auto Layout Constraints for the Label
With the label selected, click it once more and you should
see the handles around the selection box change slightly,
replacing the circles with squares, as you can see here.
Each of these handles represents an Auto Layout constraint.
Auto Layout is Apple’s flexible layout system. Developers can add constraints
to views to tell the system how to resize and position elements on the screen
as the geometry of the view changes. Using Auto Layout can help you build
views that can work on an iPhone and an iPad, by having widgets resize
themselves or perhaps follow completely different rules based on the current
device. When a widget is in the mode where it has square handles, you can
drag the handles to create constraints relative to different parts of the UI, and
you can also edit constraints with other tools in Xamarin Studio, which we’ll
look at next.
Auto Layout is very powerful, but we can’t cover a lot of it today. You can find
a more in-depth overview in Introducing Auto Layout, on page 57. All we’ll do
right now is set up constraints to have the label position itself and resize to
keep to the full width of the screen.
Configuring Constraints and Other Properties
As a place to start, we can have Xamarin Studio add some suggested con-
straints. With the label still selected, go to the top of the screen and find the
constraint controls. Click the green + symbol, and some constraints should
be created based on where the label is positioned. To review the constraints,
report erratum  •  discuss
Day 1: Adding Up the Platforms • 233

go to the Properties Pad and select the Layout tab. You should see something
like this, even if the values are not exactly the same.
Change the values for the constraints to those listed here, adding any that
you need.
• Leading Space: 20
• Top Space: 20
• Trailing Space: 20
• Height: 60
Leading space is the space on the left side of the widget and trailing space is
on the right. Finally, to get the rest of the settings right for the label, go to
the Widget tab of the Properties Pad and change the following properties:
• Label Text: 0
• Alignment: Right
• Font: System 48 pt
• Background Color: Light Gray Color
Now, with the display configured, let’s make a quick change to be able to run
the app and see the results in the iOS simulator.
Viewing the Display
The code that Xamarin Studio generated for the iOS and Android projects
had some sample code that we don’t want to run right now. Instead of editing
the code yet, we can change the storyboard to use a generic view controller
instead of the generated one.
In the storyboard, at the bottom of the simulated iOS screen, select the left-
hand button.
Chapter 7. Xamarin • 234
report erratum  •  discuss

Then, in the Properties Pad, find the Class drop-down, which should contain
the property ViewController. This is the generated controller class that we looked
at first today.
Change this value to UIViewController, which is the
base view controller class. It isn’t a good idea to
ship like this, but this will allow us to simply run
the app and see the contents of the storyboard.
In the Solution Pad, right-click the Calc.iOS project
and select Run Item. This will compile the app
and deploy it to the iOS simulator. You should
see something that looks remarkably like what we’ve already seen in Xamarin
Studio in the storyboard.
So far, so good. Now let’s move on to creating
the calculator buttons. The buttons will be cells
in a UICollectionView, which is iOS’s widget for
a group of related views. It has a flexible layout
system that will allow us to lay the buttons out in a grid.
Adding the Calculator Buttons
Back in Xamarin Studio, go to the Toolbox Pad and drag a collection view to
the storyboard view. Set up constraints as in the list that follows. This time,
add the constraints using the constraint handles. Wherever a constraint from
the collection view is relative to the label, drag the appropriate handle to the
label.
• Top Space to Label Equals 0
• Align Leading to Label Equals 0
• Align Trailing to Label Equals 0
• Bottom Space to View Controller Top Layout Guide Equals 20
Next, edit the properties of the collection view, setting the background color
to white and its name to ButtonCollectionView. Then set the label’s name to Display-
Label. These will be the variable names we’ll use to reference these widgets in
the view controller code.
Setting the name of the collection view and label in the storyboard causes a
bit of magic to happen behind the scenes that is worth explaining here. If you
look at ViewController in the Solution Pad, you’ll see that you can twirl down the
item in the tree, revealing a file called ViewController.designer.cs. This is a generated
class that gets mixed in to ViewController and provides instance variables named
according to the name properties in the storyboard.
report erratum  •  discuss
Day 1: Adding Up the Platforms • 235

Speaking of the view controller, go and change the storyboard’s View Controller
property back to the ViewController class. We’ll be doing the rest of the work in
that class instead of in the storyboard.
Creating a Collection View Cell for Buttons
We could create a collection view cell in the storyboard, but we can also do it in
code. Here’s the class for the calculator buttons, which extends ‘UICollectionViewcell‘.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
public class ButtonCell : UICollectionViewCell {
public static NSString cellId = new NSString("ButtonCell");
UILabel label;
[Export("initWithFrame:")]
public ButtonCell(RectangleF frame) : base(frame) {
ContentView.Layer.BorderColor = UIColor.LightGray.CGColor;
ContentView.Layer.BorderWidth = 0.5f;
label = new UILabel();
label.TextColor = UIColor.Black;
label.TextAlignment = UITextAlignment.Center;
label.Frame = new CGRect(10, 10, 30, 30);
ContentView.AddSubview(label);
}
public void SetTitle(string title) {
label.Text = title;
}
}
The responsibility of this class is to configure the label and overall view of the
button, as well as to expose a method, SetTitle, to change the button’s label.
One interesting Xamarin-specific item of interest is the attribute decorating
the ButtonCell constructor.
The iOS constructor method for a collection view cell is called initWithFrame:,
but C# requires that a constructor have the same name as the class, ButtonCell
in this case. This Export attribute helps bridge that gap, telling Xamarin to
associate the two methods.
With the button cell defined, now let’s look at controlling the collection view
with ViewController.
Controlling the Calculator Buttons
In order for an iOS object to provide data for and respond to events from a
collection view, it needs to conform to the protocols UICollectionViewDataSource
and UICollectionViewDelegate. In Xamarin’s C# we express this by implementing
the interfaces IUICollectionViewDataSource and IUICollectionViewDelegate. In the Xamarin
Chapter 7. Xamarin • 236
report erratum  •  discuss

world these protocols are represented by C# interfaces, which we’ll have our
ViewController implement.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
public partial class ViewController : UIViewController,
IUICollectionViewDataSource,
IUICollectionViewDelegate {
Inside the ViewDidLoad life-cycle method, we set up the collection view, registering
the button cell class to the cellIDand setting the Delegate and DataSource properties
to the view controller instance.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
public override void ViewDidLoad() {
base.ViewDidLoad();
ButtonCollectionView.RegisterClassForCell(typeof(ButtonCell), ButtonCell.cellId);
ButtonCollectionView.Delegate = this;
ButtonCollectionView.DataSource = this;
}
public override void ViewDidAppear(bool animated) {
base.ViewDidAppear(animated);
ConfigureStyles();
ButtonCollectionView.ReloadData();
}
Then, in ViewDidAppear, we tell the collection view to reload its data. This will
cause it to call the following methods, which are defined by the data source
interface.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
public nint GetItemsCount(UICollectionView collectionView, nint section) {
return buttons.Length;
}
public UICollectionViewCell GetCell(UICollectionView collectionView,
NSIndexPath indexPath) {
var buttonCell = (ButtonCell)collectionView.DequeueReusableCell(
ButtonCell.cellId, indexPath);
var button = buttons[indexPath.Row];
buttonCell.SetTitle(button);
return buttonCell;
}
GetItemsCount tells the collection view how many items are in its data set. We
respond with the length of the buttons array, which is an array of strings,
one for each calculator button.
The ‘GetCell‘ method is called when the collection view needs to display a cell.
It’s given an ‘NSIndexPath‘ that defines the row of the item. We dequeue a cached
cell, set its label to the appropriate string from the ‘buttons‘ array, and return it.
report erratum  •  discuss
Day 1: Adding Up the Platforms • 237

Now the collection view should be all set to display the calculator buttons.
You should be able to run the simulator and see all the buttons in the
expected calculator button grid. We’re not quite done, though. If you rotate
the simulator to landscape orientation, you’ll notice that the buttons don’t
look right. Let’s fix that now.
Resizing the Buttons Dynamically
Because of our work with the Auto Layout constraints, we have the collection
view and label set to resize correctly when the iOS device changes orientation,
but it’s harder to get collection view cells resized on orientation change.
This isn’t a problem with the Xamarin framework, but it’s hard to know the
right thing to do for this more complex case based on the Xamarin documen-
tation; IUICollectionViewSource seems to be the preferred interface to implement
for the collection view’s delegate.
You’ll have less trouble if you implement the interfaces we’ve already imple-
mented, set the Delegate and DataSource properties as we have, and then export
a method as collectionView:layout:sizeForItemAtIndexPath:.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
[Export("collectionView:layout:sizeForItemAtIndexPath:")]
public CGSize GetSizeForItem(UICollectionView collectionView,
UICollectionViewLayout layout,
NSIndexPath indexPath) {
var button = buttons[indexPath.Row];
var height = collectionView.Frame.Height / 5;
if (button == "=") {
return new CGSize(collectionView.Frame.Width / 2, height);
} else {
return new CGSize(collectionView.Frame.Width / 4, height);
}
}
This method simply figures out which button the collection view wants to size
and then sizes it relative to the collection view’s width and height, based on
the requirement of a grid of four columns and five rows of buttons. It also
causes the bottom-rightmost button, the equals button, to span two columns.
This method will be called whenever data is loaded into the collection view.
All that’s left is to make sure the data gets reloaded on orientation changes,
as we do here in ViewWillTransitionToSize.
Xamarin/xamarin_01_04_ios_calculator_collection_view/Calc/iOS/ViewController.cs
public override void ViewWillTransitionToSize(CGSize toSize,
IUIViewControllerTransitionCoordinator coordinator) {
base.ViewWillTransitionToSize(toSize, coordinator);
Chapter 7. Xamarin • 238
report erratum  •  discuss

coordinator.AnimateAlongsideTransition(
(context) => {
ButtonCollectionView.ReloadData();
},
completion: null
);
}
This method sends a code block to be executed by this transition coordinator
as part of the animation that occurs on orientation changes. The code block
causes the collection view to reload its data, which will cause the buttons to
be resized based on the collection view’s geometry.
Now if you run the app in the simulator you should see that the buttons resize
appropriately in all orientations on any device.
To finish off our work on the iOS UI, let’s just set up a handler for when
buttons are pressed and have the display reflect the button’s label. It’s not
quite a calculator, but it at least shows us that the UI is wired up in prepara-
tion for when we build the actual calculator code tomorrow.
Xamarin/xamarin_01_05_ios_button_events/Calc/iOS/ViewController.cs
[Export("collectionView:didSelectItemAtIndexPath:")]
public void ItemSelected(UICollectionView collectionView,
NSIndexPath indexPath) {
collectionView.DeselectItem(indexPath, true);
var button = buttons[indexPath.Row];
DisplayLabel.Text = button;
}
Here the ItemSelected method we created is exported as the collection view’s
collectionView:didSelectItemAtIndexPath: method. We simply deselect the item to make
it a momentary click-type behavior, grab the button’s text, and display it.
report erratum  •  discuss
Day 1: Adding Up the Platforms • 239

Now let’s leave the iOS app as it is for a while and build out the same func-
tionality on Android.
Building an Android Calculator View
For iOS development, Xamarin went to great lengths to provide sufficient
tooling in Xamarin Studio for editing storyboards. For Android, Xamarin fol-
lowed a similar strategy of mirroring the official platform’s interface editor
and style. With Xamarin.Android, the application code you write is still C#
but the Android resource system is fully in place. That means layouts, string
resources, color and dimension values, and so on still work the same as
writing for Android with the official tools.
To explore this, we’ll start by changing the theme to be light with a dark action
bar, one of the themes in the Android compatibility support library. Along
the way we’ll see how resources work with Xamarin and how to install pack-
ages. We’ll start by editing the Android manifest.
Changing the Theme
Android application themes, or sets of style information, are applied to the
app in the Android manifest—a file that contains the application configuration,
among other things. Open Properties/AndroidManifest.xml, and let’s make a few
changes.
Editing the Manifest
The first change we’ll make is to specify a target SDK version. The minimum
SDK version is already set: this is the minimum version of the Android SDK
that we’ll allow the app to run on. The target version is the version of the SDK
that we’ll build for in order to take advantage of the APIs for that version.
We’ll set this version to 23.
Xamarin/xamarin_01_06_android_theme_and_packages/Calc/Droid/Properties/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest
xmlns:android="http://schemas.android.com/apk/res/android"
android:versionCode="1"
android:versionName="1.0"
package="com.sevenapps.calc">
<uses-sdk android:minSdkVersion="15" />
<application android:label="Calc" android:theme="@style/AppTheme" />
</manifest>
Also, we want to specify a theme for the app. We do this by adding an
android:theme property to the application tag. This @style/AppTheme value specifies
Chapter 7. Xamarin • 240
report erratum  •  discuss

a style resource named AppTheme. We can create that by adding the following
style resource file.
Xamarin/xamarin_01_06_android_theme_and_packages/Calc/Droid/Resources/values/styles.xml
<resources>
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar" />
</resources>
By setting the parent theme, we inherit all of the styles defined in the parent
and can further define app-specific styles. Now, if you run the Android app,
by right-clicking the project in the Solution Pad and selecting Run Item, you’ll
see that the app fails to build, with an error like this:
./Calc/Droid/Resources/values/styles.xml(0,0): Error APT0000:
Error retrieving parent for item:
No resource found that matches the given name 'Theme.AppCompat.Light.DarkActionBar'.
(APT0000) (Calc.Android)
There is no resource that matches that name because the theme exists in the
AppCompat Android support library. If we were working with Android tools
we’d edit the Gradle build file to specify a dependency on that support library.
Instead, with Xamarin we use the NuGet package manager to install a package
that Xamarin has produced, which includes the support library.
Installing a Package with NuGet
To install the package, right-click the Android project in the Solution Pad and
select Add Packages. A package manager window should open. In the search
bar, type AppCompat, and you should see a filtered search result including
the Xamarin-wrapped v7 support library, as shown in the figure on page 242.
Click to select the support library package and click Add Package to finish
the installation.
Before we can see the theme applied, we need to change the MainActivity to
extend AppCompatActivity.
Xamarin/xamarin_01_06_android_theme_and_packages/Calc/Droid/MainActivity.cs
public class MainActivity : AppCompatActivity {
This gives our activity an action bar on a wide range of Android APIs. Now if
you run the Android app you should see the light theme applied but with a
dark action bar. With that theme in place we can start to build out the rest
of the calculator view, starting with the display.
Adding the Calculator Display
Let’s edit the generated layout file that the MainActivity uses for its view. When
working with layouts in Xamarin.Android, once again we’re working with
report erratum  •  discuss
Day 1: Adding Up the Platforms • 241

standard Android resources; however, the files end with the extension .axml
instead of .xml. Xamarin Studio has a visual editor for Android resources
(similar to Android Studio), but you can also always edit the XML directly, as
I prefer.
Here’s the XML to include a text view for the calculator’s display:
Xamarin/xamarin_01_07_android_calculator_display/Calc/Droid/Resources/layout/Main.axml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent">
<TextView
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="0"
android:textAlignment="viewEnd"
android:gravity="right"
android:background="@color/grey_background"
android:textSize="@dimen/display_text_size" /></LinearLayout>
The contents are exactly the same as a standard Android project’s would be.
As you can see, the background color and text size refer to other resources.
The color is defined here:
Xamarin/xamarin_01_07_android_calculator_display/Calc/Droid/Resources/values/colors.xml
<?xml version="1.0" encoding="utf-8"?>
Chapter 7. Xamarin • 242
report erratum  •  discuss

<resources>
<color name="grey_background">#ffA0A0A0</color>
</resources>
And the dimension is defined here, in terms of sp, or scaled pixels, the correct
way to define text sizes in Android:
Xamarin/xamarin_01_07_android_calculator_display/Calc/Droid/Resources/values/dimens.xml
<resources>
<dimen name="display_text_size">48sp</dimen>
</resources>
Note that when any resources are edited or added, a file called Resource.designer.cs
changes also. This file plays a role similar to R.java in a standard Android
project—it provides unique identifiers for resources to support getting access
to the compiled resources at runtime.
Let’s make one more edit to change the title of the app inside the activity’s
attribute from Calc.Droid to Calc.
Xamarin/xamarin_01_07_android_calculator_display/Calc/Droid/MainActivity.cs
[Activity (Label = "Calc", MainLauncher = true, Icon = "@drawable/icon")]
Run the app to check our progress and you should see the calculator’s display.
Now we’re ready to add the calculator buttons.
Adding the Calculator Buttons
Instead of laying out each individual button, we’ll proceed as we did with the
iOS project and use a collection-management widget called RecyclerView to lay
the buttons out for us. To use the RecyclerView we first need to add the package
containing that support library. Open the NuGet package manager again and
search for RecyclerView. Install the package named Xamarin Support Library
v7 RecyclerView, and then we can add the recycler view to the layout.
Xamarin/xamarin_01_08_android_buttons/Calc/Droid/Resources/layout/Main.axml
<android.support.v7.widget.RecyclerView
android:id="@+id/recycler_view"
android:scrollbars="vertical"
android:layout_width="match_parent"
android:layout_height="match_parent" />
report erratum  •  discuss
Day 1: Adding Up the Platforms • 243

We give the recycler view an ID of recycler_view so we can refer to it in the
activity—there is no automagical wiring up of instance variables in Xam-
arin.Android as there is in Xamarin.iOS.
With the recycler view defined in the layout, the next step is to configure an
adapter, which will tell the recycler view how to display the buttons.
Displaying the Buttons
To configure the recycler view, we get a reference to it using the FindViewById
method and then store that in an instance variable. We do this in the activity
life-cycle method called OnStart.
Xamarin/xamarin_01_08_android_buttons/Calc/Droid/MainActivity.cs
RecyclerView recyclerView;
protected override void OnCreate(Bundle bundle) {
base.OnCreate(bundle);
SetContentView(Resource.Layout.Main);
}
protected override void OnStart() {
base.OnStart();
recyclerView = FindViewById<RecyclerView>(Resource.Id.recycler_view);
recyclerView.HasFixedSize = false;
recyclerView.SetLayoutManager(new GridLayoutManager(this, 4));
recyclerView.SetAdapter(new ButtonAdapter(buttons));
}
We also configure the recycler view here, setting HasFixedSize to false. We do this
because we want the equals button to span two columns, just as we did in
the iOS project. The HasFixedSize flag is an optimization for the recycler view,
defaulting to true, which means that all the items in the recycler view are the
same size.
To change the recycler view from its standard list-based layout to a grid, we
construct a GridLayoutManager with four columns and pass that to SetLayoutManager.
Finally we set the recycler view’s adapter to ButtonAdapter, passing in a local
array of strings containing the button labels. ButtonAdapter starts out like this:
Xamarin/xamarin_01_08_android_buttons/Calc/Droid/MainActivity.cs
public class ButtonAdapter : RecyclerView.Adapter {
public class ButtonViewHolder : RecyclerView.ViewHolder {
public TextView textView;
public ButtonViewHolder(View view) : base(view) {
textView = (TextView)view;
}
}
Chapter 7. Xamarin • 244
report erratum  •  discuss

The adapter extends RecyclerView.Adapter, which is responsible for providing the
data for the recycler view. The ButtonViewHolder inner class is part of an optimiza-
tion the recycler view uses. Using FindViewById is an expensive call, so the
optimization is to cache any view lookups done on the individual recycler view
items in a ViewHolder instance stored on the item. Our button cell only has a
TextView, so we provide a variable to reference that view on the view holder.
Next, the adapter contains the implementations of the Adapter API.
Xamarin/xamarin_01_08_android_buttons/Calc/Droid/MainActivity.cs
string[] buttons;
public ButtonAdapter(string[] buttons) {
this.buttons = buttons;
}
public override RecyclerView.ViewHolder OnCreateViewHolder(ViewGroup parent,
int viewType) {
var view = LayoutInflater.From(parent.Context).
Inflate(Resource.Layout.CalcButton, parent, false);
return new ButtonViewHolder(view);
}
public override void OnBindViewHolder(RecyclerView.ViewHolder holder,
int position) {
var button = buttons[position];
var viewHolder = holder as ButtonViewHolder;
viewHolder.textView.Text = button;
}
public override int ItemCount {
get { return this.buttons.Length; }
}
OnCreateViewHolder is called each time the recycler view wants to create an item.
This method will be called only when the recycler view doesn’t have a cached
item that it can reuse, so here we inflate a new view from the CalcButton layout
resource and return a view holder.
When the recycler view recycles a cached item, or once per item on initializa-
tion, OnBindViewHolder will be called. Here we simply set the button’s label to
the appropriate string from our buttons array.
The last method, ItemCount, is called when the recycler viewer needs to know
how many total items to manage. We’ll pass back the length of the buttons
array. Actually, this method implementation is an example of a C# property,
which can be accessed as if it were an instance variable on the object, but
with get and set code blocks to be called on either assignment or access.
Finally, the layout for the button is a simple TextView.
report erratum  •  discuss
Day 1: Adding Up the Platforms • 245

Xamarin/xamarin_01_08_android_buttons/Calc/Droid/Resources/layout/CalcButton.axml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="0" />
Everything should be in place for you to run the app and look at where we
are so far. Do so if you’d like, and then we’ll style the buttons a little more,
as well as fix the equals button column span.
Styling the Button Grid
First, to give the buttons more of a “button” look, we’ll add a background with
a border, a more sensible height, and a padding value.
Xamarin/xamarin_01_09_android_button_sizing/Calc/Droid/Resources/layout/CalcButton.axml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="@dimen/button_height"
android:background="@drawable/border_background"
android:padding="@dimen/button_padding"
android:clickable="true"
android:text="0" />
If you’d like, look at the resource definitions for those values. Notice that we
also set clickable to true so that we can receive click events later.
With the buttons styled, we just need to add a larger column span for the
equals button. The grid layout manager that the recycler view is using defines
a class called a SpanSizeLookup, which we can use to do this. We set that up in
the activity, shown here in a method created to configure the recycler view.
Chapter 7. Xamarin • 246
report erratum  •  discuss

Xamarin/xamarin_01_09_android_button_sizing/Calc/Droid/MainActivity.cs
void ConfigureRecyclerView() {
recyclerView.HasFixedSize = false;
var layoutManager = new GridLayoutManager(this, 4);
layoutManager.SetSpanSizeLookup(new ButtonSpanSizeLookup(buttons.Length - 1));
recyclerView.SetLayoutManager(layoutManager);
recyclerView.SetAdapter(new ButtonAdapter(buttons, ButtonPressed));
}
We expect to return a span size for whichever button is last in the list, and
the lookup object will simply increase the span of whichever button we tell
it. The implementation of the lookup is straightforward.
Xamarin/xamarin_01_09_android_button_sizing/Calc/Droid/MainActivity.cs
public class ButtonSpanSizeLookup : GridLayoutManager.SpanSizeLookup {
int p;
public ButtonSpanSizeLookup(int doubleSizeButtonPosition) : base() {
p = doubleSizeButtonPosition;
}
public override int GetSpanSize(int position) {
if (position == p) {
return 2;
} else {
return 1;
}
}
}
Run the app again to see our improved button grid view.
Next, wire up the button clicks to the display and see that they work.
report erratum  •  discuss
Day 1: Adding Up the Platforms • 247

Responding to Button Click Events
In the new ConfigureRecyclerView method that we just saw, we pass ButtonPressed
to the ButtonAdapter constructor. That’s a reference to a method on the activity.
Xamarin/xamarin_01_09_android_button_sizing/Calc/Droid/MainActivity.cs
void ButtonPressed(object sender, string button) {
displayTextView.Text = button;
}
// ...
public event EventHandler<string> buttonClickEvent;
public ButtonAdapter(string[] buttons, EventHandler<string> handler) {
this.buttons = buttons;
buttonClickEvent = handler;
}
C# can handle events easily and elegantly. We take a reference to the method
passed in to the adapter as an EventHandler and then store that in an instance
variable. Now when a button is pressed we can use this EventHandler to commu-
nicate back to that method.
Next, because we set clickable to true on the button, we can receive click events
from the button. Xamarin makes good use of C# event handlers to make
handling this click event elegant as well. In the view holder we expect an
Action<string> as a click handler. We then add a block of code to the Click event
on the text view using C#’s += operator.
Xamarin/xamarin_01_09_android_button_sizing/Calc/Droid/MainActivity.cs
public class ButtonViewHolder : RecyclerView.ViewHolder {
public TextView textView;
public ButtonViewHolder(View view, Action<string> clickHandler) : base(view) {
textView = (TextView)view;
textView.Click += (sender, e) => clickHandler(textView.Text);
➤
}
}
public override RecyclerView.ViewHolder OnCreateViewHolder(ViewGroup parent,
int viewType) {
var view = LayoutInflater.From(parent.Context).
Inflate(Resource.Layout.CalcButton, parent, false);
return new ButtonViewHolder(view, ItemClick);
➤
}
void ItemClick(string button) {
if (buttonClickEvent != null) {
buttonClickEvent(this, button);
➤
}
}
And then, in the constructor for the view holder, we pass in the ItemClick method
as that action. ItemClick will be called when the button is clicked and can then
Chapter 7. Xamarin • 248
report erratum  •  discuss

call back to the adapter’s event handler, which is set up to be the activity’s
ButtonClicked method.
Now we have an iOS and an Android calculator UI, all ready to be wired up
to a shared calculator model, which we’ll be building tomorrow.
What We Learned on Day 1
Today we created a new cross-platform Xamarin solution. We saw how the
platform projects are organized and how to run them.
We used the storyboard features in Xamarin Studio and saw how to use C#
to write an iOS application, making use of controls such as the UICollectionView.
We were able to get Xamarin to correctly resize the UI both with Auto Layout
and with delegate methods from the collection view.
We also wrote an Android application with C#, making use of Android
resources. We used NuGet to install packages we needed and then created a
UI using the Android layouts and APIs.
Your Turn
Find
• The documentation for Xamarin.Android
• The documentation for Xamarin.iOS
• The documentation for NuGet
• The Xamarin developer forums
• The Stack Overflow tags for Xamarin
2
Do
• Try building the calculator UI using iOS. What differences can you see in
development styles? How different does it feel?
• Also, try building the calculator UI using Android’s tools. What do you
think about the differences there?
2.
http://stackoverflow.com
report erratum  •  discuss
Day 1: Adding Up the Platforms • 249

Day 2: Dividing Up the Solution
Or, Building a Shared Business-Logic Layer
Today we’ll build the shared business logic of the calculator. Xamarin’s ability
to share a project among multiple platform-specific projects is one of its strong
suits. It allows us to write business logic once and share it to multiple projects.
Building a Shared Calculator Model
The business logic for a calculator isn’t extremely complex, but it does have
a few gotchas if we don’t code it correctly. With that in mind, we’ll build the
model testing first.
Testing the Calculator Model
First, get the tests that Xamarin Studio generated
working, or at least not failing. Then we can have a clean
slate to work from. Open the Unit Test Pad by selecting
View > Pads > Unit Tests. Click the Run All button. It
takes a little time to run these because they’re UI tests
that execute on the iOS Simulator and the Android
emulator. The tests will fail because the code has been
changed from the generated test’s expectations.
Just to get us going, replace the failing tests by deleting ClickingButtonTwiceShould-
ChangeItsLabel and adding a simple TestTrue, as shown here.
Xamarin/xamarin_02_01_fixing_uitests/Calc/UITests/Tests.cs
namespace Calc.UITests {
[TestFixture(Platform.Android)]
[TestFixture(Platform.iOS)]
public class Tests {
IApp app;
Platform platform;
public Tests(Platform platform) {
this.platform = platform;
}
[SetUp] public void BeforeEachTest() {
app = AppInitializer.StartApp(platform);
}
[Test] public void TestTrue() {
Assert.True(true);
}
}
}
Chapter 7. Xamarin • 250
report erratum  •  discuss

As you can see, there’s only one test, not one for Android and one for iOS.
Note that with the code download for the book, it may be necessary to restore
packages in the projects to get the tests to run. This is because the packages
those projects depend on are not shipped with the code download, but Xamarin
Studio may not automatically download them when you open the project. To
restore packages, open each project in the Solution Explorer, open the Pack-
ages item in the tree, right-click, and then select Restore.
With even these tests in place, you can already see how useful it is to have a
common code layer. Now that the UI tests will pass, let’s start setting up tests
for the calculator model.
Setting Up the Model Tests
First, create a test for the calculator model by right-clicking the Calc.UITests
project, choosing Add File, and naming the file CalculatorModelTests.
Next, make sure the test project has Calc, the shared project, included. Right-
click the References item in the Calc.UITests project and choose Edit Refer-
ences. Under the Projects tab, make sure the Calc project is selected so that
code we add there can be referenced from the tests.
Now add a C# file called CalculatorModel to the Calc project. Then, in CalculatorMod-
elTests, add the following instance variable for the model—the setup
method—and a test asserting that the Display property should default to 0.
Xamarin/xamarin_02_02_calculator_model_display/Calc/UITests/CalculatorModelTests.cs
namespace Calc.UITests {
report erratum  •  discuss
Day 2: Dividing Up the Solution • 251

[TestFixture]
public class CalculatorModelTests {
CalculatorModel model;
[SetUp] public void SetUp() {
model = new CalculatorModel();
}
[Test] public void TestDefaultDisplay() {
Assert.AreEqual("0", model.Display);
}
}
}
At this point the test won’t even compile, so we can go ahead and add the
Display property to the model.
Xamarin/xamarin_02_02_calculator_model_display/Calc/Calc/CalculatorModel.cs
namespace Calc {
public class CalculatorModel {
public string Display {
get { return "0"; }
}
}
}
Now you should be able to run the tests again and see the model test pass.
Once you’ve run the tests once, the Unit Test Pad will show CalculatorModelTests
as an item in the tree. If you right-click this item and select Run Test, you
can run only the model tests and avoid the lengthy UI tests for now.
Testing Model Input
Let’s add some more tests: one to show that the model can accept input of a
two-digit number, updating the display correctly, and another showing that
the model can accept decimal numbers.
Xamarin/xamarin_02_03_calculator_model_input_number/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestInputNumber() {
model.Input("4");
model.Input("2");
Assert.AreEqual("42", model.Display);
}
[Test] public void TestInputDecimal() {
model.Input("3");
model.Input(".");
model.Input("1");
model.Input("4");
Assert.AreEqual("3.14", model.Display);
Chapter 7. Xamarin • 252
report erratum  •  discuss

}
Once again, the tests won’t compile because we don’t have an Input method
in the model yet. Let’s fix that now.
First, because the model needs to hold on to a value over the duration of
multiple inputs while the user enters a number, we’ll add a little helper class
to represent an input value.
Xamarin/xamarin_02_03_calculator_model_input_number/Calc/Calc/CalculatorModel.cs
class Value {
string value;
public void append(string s) {
value += s;
}
public override string ToString() {
return value;
}
}
The Value class has an append method so that the number can be built up
character by character. Next we’ll update the model’s Display property to return
the current value, if we have one, or 0.
Xamarin/xamarin_02_03_calculator_model_input_number/Calc/Calc/CalculatorModel.cs
public class CalculatorModel {
private Value currentValue;
public string Display {
get {
if (currentValue == null) {
return "0";
} else {
return currentValue.ToString();
}
}
}
public void Input(string expression) {
if (currentValue == null) {
currentValue = new Value();
}
currentValue.append(expression);
}
}
We’ll also add the Input method, which will create a Value if we need one, and
then append the incoming input.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 253

Next, we’ll add some more meaningful tests. If we add one decimal point, then
we should no longer add decimal points to the current value, but we should
treat the value as a floating point value.
Xamarin/xamarin_02_04_calculator_model_number_exceptions/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestInputMoreDecimals() {
model.Input("3");
model.Input(".");
model.Input("1");
model.Input(".");
model.Input("4");
model.Input(".");
Assert.AreEqual("3.14", model.Display);
}
[Test] public void TestInputDecimalFirst() {
model.Input(".");
Assert.AreEqual("0.", model.Display);
model.Input("1");
model.Input(".");
Assert.AreEqual("0.1", model.Display);
}
Also, if the first input is a decimal, the display should continue to display the
leading zero. At this point we can get a failing test, since we’re not testing any
new model API methods. If you run the test, the output in the Test Results
Pad should look something like this.
Expected string length 4 but was 6. Strings differ at index 3.
Expected: "3.14"
But was:
"3.1.4."
--------------^
Let’s fix this in the model by adding to the Value class a little bit of logic and
the concept of being a float.
Xamarin/xamarin_02_04_calculator_model_number_exceptions/Calc/Calc/CalculatorModel.cs
public bool isFloat;
public void append(string s) {
var isDecimal = s.Equals(".");
if (isDecimal && isFloat) {
return;
} else {
if (isDecimal && value == null) {
value += 0;
}
value += s;
}
isFloat = isFloat || isDecimal;
}
Chapter 7. Xamarin • 254
report erratum  •  discuss

Finally, in this round of simple appending tests, let’s make sure that we display
only one zero even if the user enters multiple zeroes before the decimal point.
Xamarin/xamarin_02_05_calculator_model_zeroes/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestInputLotsOfZeroes() {
model.Input("0");
model.Input("0");
Assert.AreEqual("0", model.Display);
model.Input("1");
model.Input("0");
Assert.AreEqual("10", model.Display);
model.Input(".");
model.Input("0");
model.Input("1");
Assert.AreEqual("10.01", model.Display);
}
We can make that test pass by simply ignoring zeroes until we have a value.
Xamarin/xamarin_02_05_calculator_model_zeroes/Calc/Calc/CalculatorModel.cs
public void append(string s) {
if (s.Equals("0") && value == null) {
return;
};
There—now we have the ability to enter values into the model. Let’s move on
to adding operations, starting with the unary operations.
Adding the Calculator Operations
The operations that the calculator will perform will be triggered when the user
presses one of the operation buttons. There are both unary operations (such
as calculating a percentage of the current number or toggling a number’s
sign) and binary operations (plus, minus, and so on). Let’s start by testing
and implementing the unary operations.
Adding the Unary Operations
For unary operations, our calculator is going to support negation and a percent
operator. First, though, because it will be helpful in a test that we’ll write
soon, let’s test and implement a Clear function.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 255

Xamarin/xamarin_02_06_calculator_unary_operations/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestClear() {
model.Input("5");
model.Input("C");
Assert.AreEqual("0", model.Display);
}
If the input is C for Clear, we’ll null out the current value.
Xamarin/xamarin_02_06_calculator_unary_operations/Calc/Calc/CalculatorModel.cs
public void Input(string expression) {
if (expression.Equals("C")) {
currentValue = null;
} else {
if (currentValue == null) {
currentValue = new Value();
}
currentValue.apply(expression);
}
}
Now, for negation we’ll accept the input +/– and expect to toggle whether the
current value is negative or not.
Xamarin/xamarin_02_06_calculator_unary_operations/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestToggleNegation() {
model.Input("+/-");
Assert.AreEqual("0", model.Display);
model.Input("1");
model.Input("+/-");
Assert.AreEqual("-1", model.Display);
model.Input("+/-");
Assert.AreEqual("1", model.Display);
}
[Test] public void TestPercent() {
model.Input("%");
Assert.AreEqual("0", model.Display);
model.Input("8");
model.Input("%");
Assert.AreEqual("0.08", model.Display);
model.Input("%");
Assert.AreEqual("0.0008", model.Display);
}
[Test] public void TestPostPercentFormatting() {
model.Input("100");
model.Input("%");
Assert.AreEqual("1", model.Display);
model.Input("C");
model.Input("101");
model.Input("%");
Chapter 7. Xamarin • 256
report erratum  •  discuss

Assert.AreEqual("1.01", model.Display);
}
We’ll also accept the input % and expect the current value to be divided by
100 immediately. Here’s an implementation to deal with those requirements.
Xamarin/xamarin_02_06_calculator_unary_operations/Calc/Calc/CalculatorModel.cs
public void apply(string s) {
var isPlusMinus = s.Equals("+/-");
var isPercent = s.Equals("%");
if ((s.Equals("0") || isPlusMinus || isPercent)
&& value == null) {
return;
}
;
if (isPlusMinus) {
ToggleNegative();
} else if (isPercent) {
ConvertToPercent();
return;
} else {
append(s);
}
}
void ConvertToPercent() {
var f = float.Parse(value) / 100;
value = Convert.ToString(f);
}
void ToggleNegative() {
if (isNegative) {
value = value.TrimStart('-');
isNegative = false;
} else {
value = "-" + value;
isNegative = true;
}
}
It’s starting to get a little wonky to be storing the value as a string and contin-
uing to do conversions on it, but it’s not so unwieldy that we need to refactor
it yet, and it still has some benefits. Let’s move on to the binary operations.
Adding the Binary Operations
We’re not going to look at all of the binary operation tests here; feel free to
look at the test in the code downloads. They cover adding, subtracting, mul-
tiplying, and dividing as you’d expect a calculator to work. However, it’s
important that our model gets the order of operations correct or we’ll get some
strange results sometimes.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 257

According to conventions for the order of operations, multiplication and divi-
sion take precedence over addition and subtraction. Consider this test.
Xamarin/xamarin_02_07_calculator_binary_operations/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestOrderOfOperations() {
// 56 - (8 x 9) = -16
model.Input("56");
model.Input("-");
model.Input("8");
model.Input("×");
model.Input("9");
model.Input("=");
Assert.AreEqual("-16", model.Display);
}
The comments in the test show a simple equation, using parentheses to
emphasize that the multiplication of 8 and 9 should happen first. If we ignore
order-of-operations rules and evaluate the expression from left to right, we’ll
instead subtract 8 from 56, and we’ll multiply the result of 48 by 9, which
will give us 432 instead of the correct –16.
The way to avoid that issue is to use the “two-stack” algorithm. We’ll keep a
stack of all the values the user inputs and a separate stack of all the operators.
Xamarin/xamarin_02_07_calculator_binary_operations/Calc/Calc/CalculatorModel.cs
private Value currentValue;
private Stack<Value> valueStack;
private Stack<Operator> operatorStack;
public CalculatorModel() {
valueStack = new Stack<Value>();
operatorStack = new Stack<Operator>();
}
public string Display {
get {
if (valueStack.Count == 0) {
return "0";
} else {
return valueStack.Peek().ToString();
}
}
}
Chapter 7. Xamarin • 258
report erratum  •  discuss

Then, instead of the concept of the current value, we can just have Display look
on top of the value stack or return 0 if it’s empty.
And, similar to our concept of a Value, we’ll have an Operator.
Xamarin/xamarin_02_07_calculator_binary_operations/Calc/Calc/CalculatorModel.cs
class Operator {
public static bool StringIsOperator(string s) {
return (
s.Equals("+") || s.Equals("-") || s.Equals("÷") || s.Equals("×")
);
}
public string Type { get; private set; }
public Operator(string type) {
this.Type = type;
}
public bool HasHigherPrecidenceThan(Operator other) {
return (Type.Equals("×") || Type.Equals("÷")) &&
(other.Type.Equals("+") || other.Type.Equals("-"));
}
public float Operate(Value leftValue, Value rightValue) {
float left = leftValue.ToFloat;
float right = rightValue.ToFloat;
if (Type.Equals("+")) {
return left + right;
} else if (Type.Equals("-")) {
return left - right;
} else if (Type.Equals("×")) {
return left * right;
} else {
return left / right;
}
}
}
Operator objects will be able to compare their precedence in the order of opera-
tions, as well as operate on two values.
Now the Input method changes to push input operators onto the operator stack,
apply the input to the current value, or finish the calculation if the user has
pressed the equals button.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 259

Xamarin/xamarin_02_07_calculator_binary_operations/Calc/Calc/CalculatorModel.cs
public void Input(string s) {
if (s.Equals("C")) {
Clear();
} else if (s.Equals("=")) {
CompleteCalculation();
currentValue = null;
} else {
if (Operator.StringIsOperator(s)) {
currentValue = null;
PushOperator(new Operator(s));
} else {
ApplyToCurrentValue(s);
}
}
}
The ApplyToCurrentValue method knows whether to simply apply input to the
current value or to create a new one and add it to the value stack.
Xamarin/xamarin_02_07_calculator_binary_operations/Calc/Calc/CalculatorModel.cs
void ApplyToCurrentValue(string s) {
if (currentValue == null) {
currentValue = new Value();
valueStack.Push(currentValue);
}
currentValue.apply(s);
}
void PushOperator(Operator op) {
if (operatorStack.Count > 0) {
var lastOperator = operatorStack.Peek();
if (lastOperator.HasHigherPrecidenceThan(op)) {
PopOperatorAndCalculate();
}
}
operatorStack.Push(op);
}
Also, the PushOperator method checks if the operator has a higher precedence
than the previous operator. If it does, before it puts the operator on the stack,
it calculates the previous two values using the previous operator and puts
that value onto the value stack.
Chapter 7. Xamarin • 260
report erratum  •  discuss

Xamarin/xamarin_02_07_calculator_binary_operations/Calc/Calc/CalculatorModel.cs
void PopOperatorAndCalculate() {
if (operatorStack.Count > 0 && valueStack.Count > 1) {
var op = operatorStack.Pop();
var right = valueStack.Pop();
var left = valueStack.Pop();
var result = op.Operate(left, right);
var value = new Value();
value.apply(result.ToString());
valueStack.Push(value);
}
}
void CompleteCalculation() {
if (operatorStack.Count > 0 && valueStack.Count > 1) {
while (operatorStack.Count > 0) {
PopOperatorAndCalculate();
}
}
}
When the user presses the equals button, the model goes through and calcu-
lates the remaining values using the remaining operators, which should leave
the final calculated value on the value stack.
Now, with the calculator logic in place, let’s add the ability to emit an event
when the display changes. This will come in handy when we start to wire up
the UI to the model.
Testing Model Events
We saw an example of a C# event yesterday with the Android button’s Click
event. For our model we’ll add an event called OnDisplayChanged, which will
trigger the UI’s display to update. Here’s a test for that event.
Xamarin/xamarin_02_08_display_changed_event/Calc/UITests/CalculatorModelTests.cs
[Test] public void TestDisplayChangedEvent() {
var displayChanged = false;
model.OnDisplayChanged += delegate {
displayChanged = true;
};
model.Input("5");
Assert.IsTrue(displayChanged);
}
To implement this, we’ll add an event to the model.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 261

Xamarin/xamarin_02_08_display_changed_event/Calc/Calc/CalculatorModel.cs
public event OnDisplayChangedDelegate OnDisplayChanged;
public void Input(string s) {
if (s.Equals("C")) {
Clear();
} else if (s.Equals("=")) {
CompleteCalculation();
currentValue = null;
} else {
if (Operator.StringIsOperator(s)) {
currentValue = null;
PushOperator(new Operator(s));
} else {
ApplyToCurrentValue(s);
}
}
NotifyDisplayChanged();
➤
}
void NotifyDisplayChanged() {
if (OnDisplayChanged != null) {
OnDisplayChanged(this);
}
}
Then, when we’re done processing the input, we’ll call NotifyDisplayChanged, which
will trigger the event if any listeners exist.
Let’s get the model wired up and working inside each of the platforms’ UIs.
Wiring Up the UI
Start by adding the model to the iOS project, since it’s the simplest implementation.
iOS
In the iOS ViewController we need to add an instance variable to hold a reference
to a CalculatorModel. Once we have a model, we can add an event handler that
updates the display whenever the event is fired.
Xamarin/xamarin_02_09_wire_up_views/Calc/iOS/ViewController.cs
CalculatorModel model;
public ViewController(IntPtr handle) : base(handle) {
model = new CalculatorModel();
model.OnDisplayChanged += delegate (CalculatorModel model) {
DisplayLabel.Text = model.Display;
};
}
Chapter 7. Xamarin • 262
report erratum  •  discuss

Then, when an item is selected from the collection view, meaning a button is
pressed, we send the button’s label into the model’s Input method.
Xamarin/xamarin_02_09_wire_up_views/Calc/iOS/ViewController.cs
[Export("collectionView:didSelectItemAtIndexPath:")]
public void ItemSelected(UICollectionView collectionView, NSIndexPath indexPath) {
collectionView.DeselectItem(indexPath, true);
var button = CalculatorModel.buttons[indexPath.Row];
model.Input(button);
}
Try running the project. We have a running calculator on iOS! Now let’s get
it running on Android.
Android
We need to do a little more work to get the model wired up correctly on
Android. More specifically, although we can easily make the display event
and input work just as on iOS, we have to deal with a special case that Android
presents.
Each time an Android device is rotated and the screen changes orientation,
the Android system goes through a configuration change. Whenever a config-
uration change takes place, the current activity is destroyed and a new one
is created. That means if we keep hold of the calculator model as an instance
variable, we’ll completely lose its state each time the user rotates the device.
We could solve this problem a few different ways, but here we’ll move all of
the layout into a fragment. Using a fragment also gives our app more flexibil-
ity if we want to add more complex UI elements later.
We need to add a fragment into the layout the main activity uses for its view.
Xamarin/xamarin_02_09_wire_up_views/Calc/Droid/Resources/layout/Main.axml
<fragment
android:id="@+id/calculator_layout"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:name="com.sevenapps.calc.CalculatorFragment" />
This will instantiate an instance of CalculatorFragment, shown here.
report erratum  •  discuss
Day 2: Dividing Up the Solution • 263

Xamarin/xamarin_02_09_wire_up_views/Calc/Droid/CalculatorFragment.cs
namespace Calc.Droid {
[Register("com.sevenapps.calc.CalculatorFragment")]
public class CalculatorFragment : Fragment {
RecyclerView recyclerView;
TextView displayTextView;
CalculatorModel model;
public override void OnCreate(Bundle savedInstanceState) {
base.OnCreate(savedInstanceState);
RetainInstance = true;
➤
model = new CalculatorModel();
model.OnDisplayChanged += delegate(CalculatorModel model) {
displayTextView.Text = model.Display;
};
}
Notice that almost everything we did in the main activity moves to the new
fragment. We also have an instance variable to hold a CalculatorModel,] and an
event handler for the display-changed event.
In particular, notice where we set RetainInstance to true. This tells Android that
we want this fragment to persist through configuration changes. That way
we don’t have to worry about keeping the same model instance around; the
system will do that for us by maintaining the fragment’s state.
Now, with the fragment set up and the display wired to the model’s display
via an event, we need to wire the buttons to the model’s Input method. That’s
done in the ButtonPressed method.
Xamarin/xamarin_02_09_wire_up_views/Calc/Droid/CalculatorFragment.cs
void ButtonPressed(object sender, string button) {
model.Input(button);
}
Run the Android project, and you should see the calculator running as an
Android app.
Testing the UI
To finish out the day, let’s come full circle and add a UI test to show that the
calculator actually works from the interface.
In the Calc.UITests project, remove the TestTrue test and add the following test.
Chapter 7. Xamarin • 264
report erratum  •  discuss

Xamarin/xamarin_02_10_UI_tests/Calc/UITests/Tests.cs
[Test] public void OnePlusTwoShouldEqualThree() {
Func<AppQuery, AppQuery> oneButton = q => q.Text("1");
Func<AppQuery, AppQuery> twoButton = q => q.Text("2");
Func<AppQuery, AppQuery> plusButton = q => q.Text("+");
Func<AppQuery, AppQuery> equalsButton = q => q.Text("=");
Func<AppQuery, AppQuery> display = q => q.Id("calculator_display");
app.Tap(oneButton);
app.Tap(plusButton);
app.Tap(twoButton);
app.Tap(equalsButton);
AppResult[] results = app.Query(display);
Assert.AreEqual("3", results[0].Text ?? results[0].Label);
}
The test here sets up a number of Func objects, which are function references
that take and return an AppQuery object. Using this query object, we can
specify different UI elements. So, for instance, we can find the 1 button by
searching for an item where the Text property is 1.
With these references in place, we can Tap the input 1 + 2 =, and then assert
that the display should equal 3. That’s a really nice little test to show that
the calculator works with a UI in front of it.
We need to take just one platform-specific step to make sure that works.
When we look up the display by the calculator_display ID, on Android it finds
the display because that TextView has that ID. On iOS, we need to set the label’s
AccessibilityIdentifier to calculator_display so that the query finds the correct UI element
on both platforms.
Xamarin/xamarin_02_10_UI_tests/Calc/iOS/ViewController.cs
public override void ViewDidLoad() {
base.ViewDidLoad();
DisplayLabel.AccessibilityIdentifier = "calculator_display";
➤
That’s a nice, satisfying way to wrap up today: with a functioning calculator
on two platforms using shared model code. Try doing your taxes with it! It
works, I promise!
What We Learned on Day 2
Today we saw how to build out code shared between the platform-specific
projects in Xamarin. To do this we made good use of the Xamarin test
frameworks.
We tested and built out a calculator model and then tested the model emitting
events. Then we connected the model to the UI so that we had a working
report erratum  •  discuss
Day 2: Dividing Up the Solution • 265

calculator. Finally, we used Xamarin’s UI tests to ensure that the UI worked
the way we expected.
Your Turn
Find
• The documentation for NUnit, the C# testing framework.
• The documentation for Xamarin.UITest
Do
• Some calculators repeat the last calculation when the user presses the
equals button repeatedly. Research this feature and implement it in the
model, with tests.
• On the Android calculator, a running total is displayed below the current
number. This makes it easy to see the total calculated amount while
entering a new number. Implement a running-total property and display
this in the calculator.
• Some calculators allow the user to toggle comma separation for thousands,
hundred thousands, and so on. Implement this feature in the model, with
tests, and then add a button to the calculator toolbar to toggle this mode.
Day 3: Subtracting Platform-Specific Code
Or, Building a Cross-Platform UI with Xamarin.Forms
You may think that there’s not much more we could do now that we have an
iOS and an Android app working with as little platform-specific code as possible.
But, today we’ll create a new project using Xamarin.Forms, which allows us
to create a fully native, cross-platform app using a common codebase for the
model and the UI layer. Let’s get started by creating a Forms project.
Building a Cross-Platform UI with Forms
We’ll start out with a brand-new project and copy over the shared Calc project
for reuse instead of trying to apply the Xamarin.Forms project to the previous
solution.
Setting Up the Forms Solution
Create a new solution, this time selecting
Blank Xamarin.Forms App. Call this one
CalcForms to distinguish it.
Chapter 7. Xamarin • 266
report erratum  •  discuss

The new solution contains a shared PCL project called CalcForms, as well as
a CalcForms.iOS, CalcForms.Droid, and CalcForms.UITests, as in the previous
solution.
The platform projects, CalcForms.iOS and CalcForms.Droid, can hold platform-
specific code if necessary. You can also use them to launch the app on the
simulator or emulator. We won’t need to add any platform-specific code outside
of the CalcForms project, though. The CalcForms project is a PCL that is
compiled and shared among each platform-specific project. The UIs that we
define in CalcForms will be rendered using platform-specific widgets and
conventions on each platform’s app.
Now we need to get the code for the calculator model into the solution. I had
some odd problems trying to copy the project from the previous solution over
to the Forms solution. Instead I added a PCL project called Calc to the solution,
copied over CalculatorModel.cs, and added it to the new PCL project.
I also copied over CalculatorModelTests.cs and added that to the CalcForms.UITests
project. It’s good to have these tests available, since we will be making some
changes to the model. To make the tests run, though, don’t forget to add the
reference from the CalcForms.UITests project to the new Calc project.
In fact, to be able to use the calculator model, all of the other projects must
include Calc in their project references.
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 267

That’s everything we need as far as setup goes. Now let’s start working with
Xamarin.Forms to build out a cross-platform calculator view.
Building the Calculator Display in Forms
We’ll start as the generated code sample does, by building the UI in C# code.
Once we can see how that works, we’ll change to using Xaml, the XML layout
language used by Xamarin.Forms.
Adding a Label in Code
In the file CalcForms/CalcForms.cs, you’ll find a class called App. This is the main
entry point for the Forms app. Each Forms app has a property called MainPage,
which is the view that shows initially for the app.
This code shows how we can easily create a ContentPage, which is a
straightforward page that presents a single view. The Content of the page is a
StackLayout, which arranges its children vertically by default.
Xamarin/xamarin_03_02_simple_label/CalcForms/CalcForms/CalcForms.cs
namespace CalcForms {
public class App : Application {
public App() {
var calculatorPage = new ContentPage {
Title = "Calc",
Content = new StackLayout {
Children = {
new Label {
XAlign = TextAlignment.End,
Text = "0",
BackgroundColor = Color.Gray,
FontSize = 48.0,
}
}
}
};
MainPage = calculatorPage;
}
}
}
For now, the only child of the layout is a Label, which will be the calculator’s
display, and you can see it configured right in place. Finally, the MainPage
property is set to the new ContentPage.
Creating the UI in code like this may not be to everyone’s taste, but the C#
syntax really does make the construction and configuration of all the items
in the view tree pretty painless and relatively easy to read.
Chapter 7. Xamarin • 268
report erratum  •  discuss

Now, to get a look at our new cross-platform UI in action, run both the iOS
and Android projects. The following figure shows them running side-by-side.
That’s pretty cool, especially given that we’ve written so little code. There is
one small problem, though: notice that the label is tucked up underneath
the status bar on the iOS Simulator on the right. This is because of the way
iOS adds views to the screen, with a philosophy of keeping the content front
and center on the whole interface.
Fortunately this isn’t a hard problem to solve. In any solid cross-platform
solution, there needs to be a way to deal with platform differences, and
Xamarin.Forms presents an easy way to handle differences of this kind.
Add the following code after the ContentPage is defined.
Xamarin/xamarin_03_03_corrected_ios_padding/CalcForms/CalcForms/CalcForms.cs
Device.OnPlatform(iOS: () => {
calculatorPage.Padding = new Thickness(0, 20, 0, 0);
});
This is an example of one of a few ways we can deal with platform-specific
needs. The Device class has a number of utility features, and OnPlatform is a
method that can run different blocks of code for iOS, Android, or Windows.
Here we’re just adding a little extra padding to the content page if the platform
happens to be iOS.
Run the iOS project again, and you should
see that the display is now sitting below
the status bar, as in this figure.
Again, working with UI in code is not to everyone’s taste. Its good to know
that you can do it, and that it’s not overly verbose, but next let’s define the
UI over in Xaml, Xamarin.Forms’s layout language.
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 269

Changing to Xaml
Xaml stands for Extensible Application Markup Language. It was created by
Microsoft as a structured layout language, and is the language for Xamarin.Forms.
Xaml files define a layout using XML, similar to Android layouts. Each of the
tags refer directly to classes or properties of objects, and it makes creating
layouts straightforward and easy.
To get started moving the ContentPage for the app to Xaml, add a file to the
CalcForms project of type Xaml and call it CalculatorPage. Then add the following
code to reproduce the structure we had defined in CalcForms.cs.
Xamarin/xamarin_03_04_XAML_UI/CalcForms/CalcForms/CalculatorPage.xaml
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
x:Class="CalcForms.CalculatorPage" Title="Calc">
<ContentPage.Content>
<StackLayout>
<Label XAlign="End" Text="0"
BackgroundColor="Gray" FontSize="48" />
</StackLayout>
</ContentPage.Content>
</ContentPage>
Notice the Class property of the root tag names a class called CalculatorPage. In
fact, that file was created when we added the Xaml page. In the Solution Pane,
notice that in the Solution Explorer you can twirl down the item for Calculator-
Page.xaml to see CalculatorPage.xaml.cs.
Xamarin/xamarin_03_04_XAML_UI/CalcForms/CalcForms/CalculatorPage.xaml.cs
namespace CalcForms {
public partial class CalculatorPage : ContentPage {
public CalculatorPage() {
InitializeComponent();
}
}
}
The Xaml file will be compiled into this class, and so definitions and properties
in the Xaml will affect the instance of the class. It’s also possible to put code
into the class that will affect the view.
Now, with the Xaml layout in place we can remove the ContentPage definition
from the App code and replace it with the new CalculatorPage.
Xamarin/xamarin_03_04_XAML_UI/CalcForms/CalcForms/CalcForms.cs
public App() {
Chapter 7. Xamarin • 270
report erratum  •  discuss

var calculatorPage = new CalculatorPage();
Device.OnPlatform(iOS: () => {
calculatorPage.Padding = new Thickness(0, 20, 0, 0);
});
MainPage = calculatorPage;
}
We’ve left behind the OnPlatform code, but it’s possible to move that to the Xaml.
Delete the OnPlatform stanza and put this code into the CalculatorPage Xaml.
Xamarin/xamarin_03_05_content_page_padding_in_xaml/CalcForms/CalcForms/CalculatorPage.xaml
<ContentPage.Padding>
<OnPlatform x:TypeArguments="Thickness" iOS="0, 20, 0, 0" />
</ContentPage.Padding>
If you run the apps, everything should look as it did before. Now let’s build
the button grid in Xaml as well.
Adding Calculator Buttons
To lay the buttons out in columns and rows use Xamarin.Forms’s ‘Grid‘ contain-
er. Define how many rows and columns you want, including height and width.
Then all the children of the ‘Grid‘ need to specify their row and column positions.
Xamarin/xamarin_03_06_calculator_buttons/CalcForms/CalcForms/CalculatorPage.xaml
<Grid VerticalOptions="FillAndExpand">
<Grid.RowDefinitions>
<RowDefinition Height="*" />
<RowDefinition Height="*" />
<RowDefinition Height="*" />
<RowDefinition Height="*" />
<RowDefinition Height="*" />
</Grid.RowDefinitions>
<Grid.ColumnDefinitions>
<ColumnDefinition Width="*" />
<ColumnDefinition Width="*" />
<ColumnDefinition Width="*" />
<ColumnDefinition Width="*" />
</Grid.ColumnDefinitions>
<Button Text="C" Clicked="ButtonClicked" Grid.Row="0" Grid.Column="0" />
<Button Text="+/-" Clicked="ButtonClicked" Grid.Row="0" Grid.Column="1" />
<Button Text="%" Clicked="ButtonClicked" Grid.Row="0" Grid.Column="2" />
<Button Text="÷" Clicked="ButtonClicked" Grid.Row="0" Grid.Column="3" />
<!-- ... -->
<Button Text="=" Clicked="ButtonClicked"
Grid.Row="4" Grid.Column="2" Grid.ColumnSpan="2" />
</Grid>
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 271

The * for the height and width means
to divide the available space evenly.
Finally, for the equals button in the
last position, we specify a column
span to get it to take up two columns.
The layout is pretty straightforward,
if a little verbose. We can deal with
some of the verbosity later. For now,
though, run the apps and compare
how they look on each platform.
Everything seems to be looking good
on both platforms.
In each of the Button tags there is also a Click attribute set to ButtonClicked. This
points to a method in the CalculatorModel class.
Xamarin/xamarin_03_06_calculator_buttons/CalcForms/CalcForms/CalculatorPage.xaml.cs
public void ButtonClicked(object sender, EventArgs eventArgs) {
var button = (Button)sender;
string label = button.Text;
model.Input(label);
}
The instance variable model is new, so we’ll see where that comes from next,
as we start to wire up the calculator model.
Wiring Up the Calculator Model
So far, starting over from scratch with a Xamarin.Forms solution, we’ve pro-
duced the same UI with remarkably less code. It’s admittedly not a complex
UI, but the efficiency is definitely a lot higher.
Next we’ll add the calculator model and use binding to wire up the model’s
Display property to the calculator’s display declaratively.
Binding to the Model
Binding is a way to declare the data provider for a Xaml widget such that
when the bound property’s data changes, the widget is automatically updated.
Defining the Model and Binding
Adding the following code in the CalculatorPage’s Xaml will create a CalculatorModel,
store it in an instance variable called model, and set that model as the binding
context for the children of the StackLayout.
Chapter 7. Xamarin • 272
report erratum  •  discuss

Xamarin/xamarin_03_06_calculator_buttons/CalcForms/CalcForms/CalculatorPage.xaml
<StackLayout.BindingContext>
<calc:CalculatorModel x:Name="model" />
</StackLayout.BindingContext>
<Label XAlign="End" BackgroundColor="Gray" FontSize="48" Text="{Binding Display}" />
In other words, any properties that children of the StackLayout bind to will
default to properties on the model. In fact, the Label’s Text property is bound
to the model’s Display property in this way.
Adding Property-Changed Events
We need to make changes on the model to get binding to work. Currently,
the model’s Display property is a syntactically nice wrapper to the private stack
of Values. The problem with this approach is that C#’s binding won’t automat-
ically track changes to this stack, so bound widgets won’t know about changes.
Change that by making Display a simple getter and setter of a private instance
variable display and then sending a property-changed event whenever it changes.
Xamarin/xamarin_03_06_calculator_buttons/CalcForms/Calc/CalculatorModel.cs
private string display;
public string Display {
get {
return display;
}
private set {
display = value;
OnPropertyChanged("Display");
}
}
public void Input(string s) {
if (s.Equals("C")) {
Clear();
} else if (s.Equals("=")) {
CompleteCalculation();
currentValue = null;
} else {
if (Operator.StringIsOperator(s)) {
currentValue = null;
PushOperator(new Operator(s));
} else {
ApplyToCurrentValue(s);
}
}
var latestValue = (valueStack.Count == 0) ? "0" : valueStack.Peek().ToString();
Display = latestValue;
➤
}
Display will be set to the latest value on top of the stack whenever Input is called.
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 273

To make the model a property-changed event emitter, we need to implement
the INotifyPropertyChanged interface, which consists of a public event.
Xamarin/xamarin_03_06_calculator_buttons/CalcForms/Calc/CalculatorModel.cs
public class CalculatorModel : INotifyPropertyChanged {
public event PropertyChangedEventHandler PropertyChanged;
protected virtual void OnPropertyChanged(string propertyName) {
if (PropertyChanged != null) {
PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
}
}
Whenever a property changes, we notify the event handler with a reference
to the instance and a PropertyChangedEventArgs. The binding framework already
knows how to wire all this together so that when we press a button and Input
is called, the property-changed event will update the calculator’s Label through
the bound Text property.
The upshot of this is that we should have a working calculator at this point.
Run it and see how it works, and then we’ll do a little cleanup in the code.
Building the Grid Programmatically
One thing that’s not quite as clean as it could be is having all of the buttons
defined in the Xaml. There is a list of “official” buttons defined in the calculator
model, so let’s fill out the grid using those instead.
Take all of the Button tags out of the grid and add the following methods, calling
AddButtons from the constructor in CalculatorPage.xaml.cs.
Xamarin/xamarin_03_07_programmatic_buttons/CalcForms/CalcForms/CalculatorPage.xaml.cs
void AddButtons() {
var buttons = CalculatorModel.buttons;
var column = 0;
var row = -1;
for (int i = 0; i < buttons.Length; i++) {
column = i % 4;
if (column == 0) { row++; }
var label = buttons[i];
var button = CreateButton(label);
ButtonGrid.Children.Add(button, column, row);
if (label == "=") {
Grid.SetColumnSpan(button, 2);
}
}
}
Button CreateButton(string label) {
var button = new Button();
Chapter 7. Xamarin • 274
report erratum  •  discuss

button.Text = label;
button.Clicked += ButtonClicked;
return button;
}
Now at least there is one system of record the model will understand for the
buttons. We could do some more work to programmatically add the right
number of columns and rows and column spans, I suppose, but for now let’s
move on and add one last feature to the calculator.
Converting Currency on the Calculator
For the other apps we’ve built, the pattern has generally been to begin with
an HTTP call. We’ve taken a different route this week, but it would be a shame
to not get a sense of how working with data from the network feels on Xamarin.
We’ll start by adding a fledgling currency-conversion feature to the calculator.
Suppose the user wants to make some calculations where the values are
currencies. To help with that, we’ll give him the capability to—at any point
during a calculation—convert the current value from one currency to another.
To get started, we’ll add a button to convert from U.S. dollars to euros.
Adding Dependencies
Let’s add the packages we need. Open the Add Packages dialog for the Cal-
cForms project and search for JSON.NET as shown in the figure on page 276.
Select it, and then search for "Microsoft Http." The Microsoft.Net.Http package
should come up in the results. Select that as well, and add both packages.
Repeat that process for the iOS and Android projects. The JSON.NET package
will give us a JSON parser and the Microsoft.Net.Http package an HTTP client.
Modifying the Model
Next, since we plan on converting the current value displayed by the calcula-
tor, let’s add a method on the model to facilitate that.
Xamarin/xamarin_03_08_convert_currency/CalcForms/Calc/CalculatorModel.cs
public void ReplaceCurrentValue(string s) {
if (valueStack.Count > 0) {
valueStack.Pop();
currentValue = null;
ApplyToCurrentValue(s);
UpdateDisplay();
}
}
Now when the user converts the current value to a different currency, the
value can be immediately replaced.
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 275

Converting Currency
To convert the value from dollars to euros, we’ll use the same API we used to
build the Android app, the /convert endpoint. JSON.NET is a fully featured
JSON parser that can convert JSON messages to native objects. Let’s add a
class that can represent the result of a call to the conversion API.
Xamarin/xamarin_03_08_convert_currency/CalcForms/CalcForms/CalculatorPage.xaml.cs
class ConversionRate {
public string name { get; set; }
public string from { get; set; }
public string to
{ get; set; }
public float
rate { get; set; }
}
Next, after the rest of the calculator buttons are added to the grid, let’s add
a button after the equals button to trigger the conversion.
Xamarin/xamarin_03_08_convert_currency/CalcForms/CalcForms/CalculatorPage.xaml.cs
var convertButton = new Button();
convertButton.Text = "$ > €";
convertButton.Clicked += Convert;
ButtonGrid.Children.Add(convertButton, ++column, row);
Of course, we need to remove the column span from the equals button, too.
The conversion button’s click event handler is set to the Convert method. Here
is the code for that method.
Xamarin/xamarin_03_08_convert_currency/CalcForms/CalcForms/CalculatorPage.xaml.cs
async void Convert(object sender, EventArgs e) {
string converted = await ConvertUSDToEUR(model.Display);
Chapter 7. Xamarin • 276
report erratum  •  discuss

model.ReplaceCurrentValue(converted);
}
This is a good introduction to a very useful feature of C#, usually called
async/await. In all of the other apps, we’ve been at pains to make sure that
we do not execute long-running code on the main thread. We’ve seen the
various ways that different platforms handle concurrent code like this, but
none of them are quite as elegant as C#.
First, note that the Convert method signature is marked as async. This tells the
compiler that the method uses asynchronous code. Next, there is a call to a
method called ConvertUSDToEUR, which is prefixed by the await keyword.
This means that we want to have the ConvertUSDToEUR method executed on
another thread, and when it is complete, we want the results returned to this
thread. While the awaited method is executing, the Convert method is effectively
paused and its thread continues to execute. Once the awaited method returns,
the execution continues as normal. Simple and effective!
Now let’s take a look at the call to the API. This method is marked as async as
well, and it returns a type of Task<string>. This is a clue about how the await
keyword does its job: the Task is executed and returns when complete.
Xamarin/xamarin_03_08_convert_currency/CalcForms/CalcForms/CalculatorPage.xaml.cs
async Task<string> ConvertUSDToEUR(string amount) {
var client = new HttpClient();
string url = "http://localhost:3000/convert/";
Device.OnPlatform(
// Use this for emulator url = "http://10.0.2.2:3000";
// Use this for genymotion url = "http://10.0.3.2:3000";
Android: () => {
url = "http://10.0.2.2:3000/convert/";
}
);
client.BaseAddress = new Uri(url);
client.DefaultRequestHeaders.Accept.Add(
new MediaTypeWithQualityHeaderValue("application/json")
);
var response = await client.GetAsync("USD/EUR");
var json = response.Content.ReadAsStringAsync().Result;
var rateInfo = JsonConvert.DeserializeObject<ConversionRate>(json);
var convertedAmount = float.Parse(amount) * rateInfo.rate;
return convertedAmount.ToString();
}
Inside the method itself, we create a new HttpClient and set the Uri to the local
API, configure the headers to accept JSON, make the HTTP call, deserialize
report erratum  •  discuss
Day 3: Subtracting Platform-Specific Code • 277

and convert the JSON, and finally return the converted amount. All pretty
much what you’d expect.
Notice that we can make good use of the Device.OnPlatform method again to make
sure we use the right IP address for the Android emulator.
To test our work, make sure the Rails app is running, start up the emulator
and simulator, and test out the ability to convert a value in a calculation to
another currency. Now we have a useful, connected calculator running on
two mobile platforms, and it took a small amount of code to build it.
What We Learned on Day 3
We rebuilt the calculator UI using Xamarin.Forms, Xamarin’s cross-platform
UI library. We used both C# and Xaml to define the UI. Then we reintroduced
our calculator model and wired it to the UI using binding. We also covered
how to use property-changed events to build our own bindable property.
We saw how Xaml and the C# class backing the Xaml page can interoperate,
by adding buttons to the Grid programmatically. Then we added a currency-
conversion feature to the calculator, which allowed us to see how to consume
a JSON API. We used C#’s async/await feature to make sure that we didn’t
degrade UI performance while the network call was running.
Your Turn
Find
• The documentation for Xamarin.Forms
• The documentation for Microsoft’s HTTP client
• JSON.NET’s documentation
• The Stack Overflow tags for Xamarin.Forms
3
Do (Easier)
• Reintroduce the UI tests for the Forms versions of the app.
• Add any new tests you can think of—for instance, testing that the Clear
function works.
• If you implemented the running total in the model yesterday, display a
running total with binding.
3.
http://stackoverflow.com
Chapter 7. Xamarin • 278
report erratum  •  discuss

Do (Harder)
• The CalculatorPage shouldn’t be responsible for making the network call to
convert the currency. Research and design a class that should be
responsible for service calls, and change the code appropriately.
• So far the conversion feature is a little limited. Replace the button labeled
$ > € with a button, appropriately labeled, that presents a UI element
allowing the user to choose the “to” and “from” currencies.
• If you’re very ambitious, try building a scientific calculator UI as well,
with a way to switch between the two. Make the appropriate changes to
the UI and the model to support this feature.
Wrapping Up Xamarin
The promise of Xamarin is in its ability to share a maximal amount of code
between mobile-platform projects. This week we’ve tested that ability in a
number of ways by sharing code both with iOS and Android platform-specific
projects and with Xamarin.Forms.
Strengths
The ability to share code with Xamarin works really well. Whether you’re just
building a common business layer or using Xamarin.Forms, you can signifi-
cantly cut down on repeating yourself on different platforms.
Of course, none of that power means much if the apps we produce either look
or perform poorly. This doesn’t seem to be the case at all, although there is
an extra layer of executing code with the Mono runtime. You can build the
UI in just the way you want with Xamarin.iOS and Xamarin.Android, and
Xamarin.Forms makes reasonable choices for the platform-specific widgets
and layouts that it uses.
The Xamarin frameworks work well and give developers access to some neat
features that C# developers have been using for a while now, such as
async/await.
Weaknesses
There are some things to consider before diving in on your next project,
though. First of all, Xamarin Studio for Mac is not quite up to the standards
you may be used to for your IDEs. It’s a little underpowered compared to the
excellent Android Studio, and the support for Apple’s storyboards is not as
report erratum  •  discuss
Wrapping Up Xamarin • 279

good as Xcode’s. The Visual Studio support may be a lot more palatable for
Windows Xamarin developers.
Of course, once you choose Xamarin, you’ve decided on a certain support
path for your application. Xamarin developers need to not only be experts in
both the iOS and Android platforms but also experts in Xamarin and C#
development. That narrows down who can support the apps you build.
Finally, Xamarin seems to be very adept at staying up-to-date with Android
and iOS API changes, but to continue to support your released apps, you
need to rely on Xamarin’s ability to keep up. That may continue to be a good
bet, but it’s a bet you’ll need to make.
Final Thoughts on Xamarin
Overall, I believe Xamarin is one of the best cross-platform solutions available
(if not the best). It’s not one of the web-view crowd; Xamarin apps are real,
native applications, and you have the power to use all of the native APIs that
a platform-native app developer does. If your business needs to put apps on
both iOS and Android, and possibly Windows Phone as well, then Xamarin
is really worth considering.
Chapter 7. Xamarin • 280
report erratum  •  discuss

CHAPTER 8
React Native
When planning out this book, I knew that I wanted to cover some good cross-
platform native tools. Having worked on a number of mobile projects, I have
continually seen the tension between developers wanting to use the official
tools and clients wanting to know if they can get more than one platform “for
free.” However, for a long time it seemed like all of the cross-platform tools
were unsatisfying. Either they made sacrifices in the user experience by using
web technology as a cheap, easy way to get to “cross-platform,” or the tooling
and language were weird and nothing any developer with experience on the
official tools would want to use.
Some solutions did exist that made cross-platform development fun, powerful,
or some combination of both. I knew that I wanted to cover RubyMotion and
Xamarin as good examples, but when looking for a third tool I was coming
up short. Then, out of the blue, as I was partway into writing the second
chapter, Facebook announced React Native.
1 I knew I had my third. At the
time it worked only for iOS, but there were some vague promises of Android
support coming later. Luckily Android support was announced in September
2015, with plenty of time for me to get the chapter written. React Native
continues to evolve, but at this point it’s a very powerful contender for your
cross-platform tool of choice.
React Native uses Node.js and the Node Package Manager to provide a set of
really powerful development tools that closely manage native iOS and Android
project builds.
2 3 You can write your apps in JavaScript and use some very
nice development tools from right within the Android emulator and the iOS
Simulator. The tooling is powerful, but it doesn’t force you into a heavy IDE
1.
https://facebook.github.io/react-native
2.
https://nodejs.org
3.
https://www.npmjs.com
report erratum  •  discuss

to get to it; you can use whatever editor you like and do anything else you
need from the command line or the runtime environments themselves. This
week we’ll explore React Native by building a note-taking app.
A Note-Taking App
This app will allow users to keep a list of notes, which are made up of a title
and a body. Later on, we’ll add the ability to geotag notes and to view them
placed on a map as well as in a simple list.
On the first day we’ll get set up and generate a project with React Native.
Then we’ll create a navigation structure with platform-specific components
for iOS and Android. On the second day we’ll add a form for the user to create
notes. Then we’ll get those notes displayed in a list and then saving to the
API at the /notes endpoint.
On the third day we’ll build the ability for users to add their current location
to a note they’re creating. This will use the device’s location API and then do
a reverse geocode lookup through our API’s /reverse_geocode endpoint. Then the
app will display the location for notes that have one and provide a map view
showing notes with locations on a map. Let’s get started!
Chapter 8. React Native • 282
report erratum  •  discuss

Day 1: Comparing Notes
Or, Getting Set Up and Building Screens on Both Platforms
Today we’ll get React Native installed, generate a project, and then start cre-
ating the main screen for our app. We’ll get the app running on both iOS and
Android and start to build out the main screen with navigation that’s specific
to each platform. We’ll get our hands on both platform-specific and platform-
agnostic code. Let’s get started with setup.
Getting Set Up
The first step is to install something to manage the Node version we require
for the project, according to the instructions for getting started.
4 This is a
good idea to start the project off with a clear, actionable understanding of the
version of Node we expect to use. The software we use for this is called Node
Version Manager, or nvm.
5
That allows us to create a file called .nvmrc in the root of a new, empty project
directory with the version of the Node we want to use, like in this sample.
ReactNative/react_native_01_01_setup/Notes/.nvmrc
5.2.0
Then we’re able to use nvm to install and use that version of Node, as is anyone
else working on the project. With that file in place and the correct version of
Node installed, we’re ready to install React Native and create a project.
Creating a Project
React Native is installed as a global Node package with this command:
$ npm install -g react-native-cli
Then we’re able to execute a command with that command-line tool to initialize
a new project:
$ react-native init Notes
This will walk you through creating a new React Native project in ./Notes
Installing react-native package from npm...
Setting up new React Native app in /Notes
To run your app on iOS:
Open ./Notes/ios/Notes.xcodeproj in Xcode
Hit the Run button
To run your app on Android:
4.
https://facebook.github.io/react-native/docs/getting-started.html
5.
https://github.com/creationix/nvm
report erratum  •  discuss
Day 1: Comparing Notes • 283

Have an Android emulator running (quickest way
to get started), or a device connected
cd ./Notes
react-native run-android
You can see from the command-line output that this project is built to work
with both Android and iOS. The instructions state how to run those projects,
iOS through Xcode and Android from the command line, so you can guess
that the React Native tools are built very closely to the official toolsets.
The project structure looks like this at a high level:
Notes
├──android
├──ios
├──node_modules
├──index.android.js
├──index.ios.js
└──package.json
There is a generated Android project in the android directory and an Xcode
project in the ios directory. The package.json file is standard for any NPM-man-
aged project, as is the node_modules directory where all the necessary Node
libraries are installed.
Now let’s see how to run the generated project on each platform.
Getting Android Running
To run Android, first start an emulator or Genymotion session. Then, issue
this on the command line:
$ react-native run-android
Starting JS server...
Building and installing the app on the device
(cd android && ./gradlew installDebug)...
Starting a new Gradle Daemon for this build
(subsequent builds will be faster).
:app:preBuild UP-TO-DATE
...
Installing APK 'app-debug.apk' on 'N5(AVD) - 5.1.1'
Installed on 1 device.
BUILD SUCCESSFUL
Total time: 26.707 secs
Starting the app (adb shell am start -n com.notes/.MainActivity)...
Starting: Intent { cmp=com.notes/.MainActivity }
It’s clear here that React Native is making full use of the standard Android
project’s build with Gradle. The first step it takes is to start a server for some
Chapter 8. React Native • 284
report erratum  •  discuss

of the React Native development features, but the rest of the build is straight
Android.
For the first taste of some of the React Native development features, once the
app is running, press the menu button. Remember, if you’re on an emulator
you can use the F2 key from your keyboard. Once you do, you see a menu
with a number of useful development options, such as Reload. Reload does
just that: it reloads the application so you can see your changes without a
complete rebuild cycle. You can even turn on automatic reloading so that the
app will be reloaded every time a project file changes. This kind of attention
to the development experience is apparent right from the start when working
with React Native. Now let’s get the iOS version running too.
Getting iOS Running
You can run the iOS version by executing react-native run-ios. An alternative
approach is to open the .xcproject file from the ios directory in Xcode. Then press
the play button at the top of Xcode. If the JavaScript server is not already
running, it will be started, and then the iOS project will be built and deployed
to the simulator. Now we have the generated project running on both Android
and iOS.
The same development options are available from the iOS Simulator, either
by pressing DD or by “shaking” the simulator, done by pressing DCZ. I
suggest enabling automatic reload on both the simulator and the emulator
so you can see the changes displayed as we make them.
Now that you know how to run the project and use the runtime development
features, let’s get started with writing the app.
Building the Main Notes Screen
First we’ll build the main screen, which will list the notes the user has created,
and if none exist, display a default, no-data screen.
Adding a Main Screen
We’ll get started by creating a file to contain the code for the main screen and
then get that file to display on each platform.
report erratum  •  discuss
Day 1: Comparing Notes • 285

Defining the Main Screen
Create a new directory called screens, and add a new file there called MainScreen.js.
Then, start the file with this to require the modules we need to use:
ReactNative/react_native_01_02_cross_platform_screen/Notes/screens/MainScreen.js
import React, {
AppRegistry,
StyleSheet,
View,
Text,
Component,
} from 'react-native';
First we import a number of components from react-native. The import statement
may be unfamiliar to you based on previous JavaScript experience. React
makes good use of a lot of features of bleeding-edge ES2015 syntax (the latest
JavaScript language specification), including some that aren’t official yet. To
make sure you can understand the code you’re reading, it’s worth going
through the official list.
6
Now we’ll define a class, MainScreen, which is a Component, and add a function
called render that will define the view for this screen.
ReactNative/react_native_01_02_cross_platform_screen/Notes/screens/MainScreen.js
class MainScreen extends Component {
render() {
return (
<View style={styles.container}>
<Text style={styles.instructions}>
Create a note.
</Text>
</View>
);
}
};
module.exports = MainScreen;
Another strange bit of JavaScript—it seems like the method is returning bare
XML. This syntax is actually Facebook’s spec, JSX.
7 The purpose here is to
embed an XML view definition within the JavaScript code. This defines a top-
level view that contains a text block.
Then we can add style information, which is a JavaScript object with certain
key/value pairs.
6.
https://facebook.github.io/react-native/docs/javascript-environment.html
7.
https://facebook.github.io/jsx
Chapter 8. React Native • 286
report erratum  •  discuss

ReactNative/react_native_01_02_cross_platform_screen/Notes/screens/MainScreen.js
var styles = StyleSheet.create({
container: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
backgroundColor: '#F5F5F5',
},
instructions: {
textAlign: 'center',
color: '#A0A0A0',
},
});
The style information here tells React Native to center the children of the
parent View and then assigns some colors.
Adding MainScreen to the Index Files
The generated files in the project include two index files, one for Android and
one for iOS. These act as entry points to the application on each platform,
and they are one of the ways we can introduce platform-specific differences
in the app. We’ll see how this can work for us as we start to build out the
app, but for now let’s get started by displaying the main screen we just created
on each platform.
First up is the Android-specific index file, index.android.js.
ReactNative/react_native_01_02_cross_platform_screen/Notes/index.android.js
'use strict';
import React, {
AppRegistry,
Component,
} from 'react-native';
import MainScreen from './screens/MainScreen';
class Notes extends Component {
render() {
return (
<MainScreen />
);
}
};
AppRegistry.registerComponent('Notes', () => Notes);
This file does a few imports, including the MainScreen we just created. Then it
defines a class, Notes, with a render function. You can see a pattern here: when
we’re creating a view, we need a render function to describe the view to React
report erratum  •  discuss
Day 1: Comparing Notes • 287

Native. This view is pretty simple; it’s a tag for the MainScreen class we just
created. View hierarchies are just trees of components with render functions.
At this point, the iOS and Android index files should have exactly the same
code, so go ahead and copy the Android index over to index.ios.js. Now, if you
kept the simulator and the emulator running and with automatic reload on,
you should already see something that looks like this on both:
The view on the screen is completely defined in MainScreen.js, so here we’re
looking at cross-platform code, written in JavaScript but compiled as a set
of native apps.
Our next goal is to define the structure for navigating between screens, and
the controls to do so. Specifically, we want to add a way for users to interact
with a control in order to move to a screen to create a new note. Because
users on iOS and Android have different expectations for these standard
navigation controls, we’ll do this work in a platform-specific way. We already
have the structure in place to do that, since we have the two platform-specific
index files. We’ll start with iOS.
Chapter 8. React Native • 288
report erratum  •  discuss

Defining Navigation for iOS
To add controls to the screen, we’ll need to reference a few new modules. We
need to add Text, Navigator, and TouchableOpacity to the list at the top of the file.
ReactNative/react_native_01_03_main_ios_layout/Notes/index.ios.js
import React, {
Text,
AppRegistry,
Navigator,
StyleSheet,
TouchableOpacity,
Component,
} from 'react-native';
Now, in the render function we’ll add a Navigator tag. The Navigator is a cross-
platform control that handles navigation between screens. It has the concept
of a route, which we can see defined here in the initialRoute attribute. The Navi-
gator keeps a history stack of all the screens the user has visited. Each of
those screens is described by a simple object with a name and an index.
ReactNative/react_native_01_03_main_ios_layout/Notes/index.ios.js
render() {
return (
<Navigator
initialRoute={{name: 'Notes', index: 0}}
renderScene={(route, navigator) => <MainScreen /> }
navigationBar={
<Navigator.NavigationBar
style={styles.navBar}
routeMapper={this.navigationBarRouteMapper}
/>
}
/>
);
}
Next, the navigator has an attribute, renderScene, which is a reference to a
function that, given a route and a navigator reference, should return the view
definition for that route. Currently we just have an anonymous function that
always returns MainScreen.
Finally the Navigator has a navigationBar. This is a component that sits at the top
of the screen and can include some standard components like a title and
navigation buttons. It has an attribute called routeMapper, which is an object
to help define these components. That object is defined in the constructor in
a variable called navigationBarRouteMapper.
report erratum  •  discuss
Day 1: Comparing Notes • 289

ReactNative/react_native_01_03_main_ios_layout/Notes/index.ios.js
constructor(props) {
super(props)
this.navigationBarRouteMapper = {
LeftButton: function(route, navigator, index, navState) {
return null;
},
Title: function(route, navigator, index, navState) {
return(
<Text style={styles.navBarTitle}>
Notes
</Text>
);
},
RightButton: function(route, navigator, index, navState) {
return(
<TouchableOpacity>
<Text style={styles.navButtonText}>
New
</Text>
</TouchableOpacity>
);
},
}
}
The object needs to define properties for Title, LeftButton, and RightButton, which
are functions that receive the route, navigator, current index, and a navigation
state object. Using those parameters, the functions should provide the
appropriate views for those components. We currently have no left button, a
title of Notes in a Text component, and a right button labeled New in a Text
component. The Text is inside of a TouchableOpacity tag, which is a component
that can add touch response to any view. We’ll define an action for when the
user touches the right button later.
Finish up this step by adding this style sheet.
ReactNative/react_native_01_03_main_ios_layout/Notes/index.ios.js
var styles = StyleSheet.create({
navBar: {
backgroundColor: '#F5F5F5',
alignItems: 'center',
},
navButtonText: {
paddingTop: 14,
paddingRight: 8,
color: '#005DB3',
},
navBarTitle: {
Chapter 8. React Native • 290
report erratum  •  discuss

fontSize: 18,
fontWeight: '500',
marginTop: 10,
},
});
Now we have a navigation bar at the top of the iOS screen with a button on
the right, labeled New, which we’ll use to navigate to a New Note screen. Before
we get to that, let’s catch up the Android screen.
Defining Navigation for Android
Users on iOS are accustomed to a navigation bar with a title and right and
left buttons. But Android users are more accustomed to the standard Android
Action Bar. In the Android index file, add the following code. It should now
be almost exactly like the iOS file, except without the Navigator.NavigationBar.
ReactNative/react_native_01_04_main_android_layout/Notes/index.android.js
class Notes extends Component {
constructor(props) {
super(props)
this.menuActions = [
{ title: 'New', show: 'ifRoom' }
]
}
render() {
return (
<Navigator
initialRoute={{name: 'Notes', index: 0}}
renderScene={(route, navigator) =>
<View style={{flex:1}}>
<ToolbarAndroid
title="Notes"
actions={this.menuActions}
style={styles.toolbar}
/>
<MainScreen />
</View>
}
/>
);
}
};
report erratum  •  discuss
Day 1: Comparing Notes • 291

Instead, the renderScene function returns a View that contains a ToolbarAndroid
and the MainScreen. ToolbarAndroid is an Android-only component; its naming
convention with an Android suffix tells us this. There are a number of IOS-suf-
fixed components as well, following this platform-specific component-naming
convention. It makes sense to use these sparingly, and this is a good example
of a situation where a platform-specific component makes sense. We’re
making the structure of the app meet user expectations.
Like any Android Action Bar, this toolbar has a configurable menu. We use
the object in menuActions to define one menu item labeled New. We’ll use this
later to navigate to the new-note-creation screen.
Now with navigation in place, let’s get that New Note screen built so we can
navigate to it.
Building the New Note Screen
The new note screen should allow users to enter the text for a note title and
then the body of the note. Create a new file, which should contain a class,
NewNote, which is a React Native component.
ReactNative/react_native_01_05_new_note_screen/Notes/screens/NewNote.js
class NewNote extends Component {
render() {
return (
<View style={styles.container}>
<TextInput
placeholder="Note Title"
style={[styles.noteTextInput, styles.titleTextInput]} />
<View style={styles.divider} />
<TextInput
placeholder="Enter a note..."
multiline={true}
textAlignVertical='top'
style={[styles.noteTextInput, styles.noteBodyTextInput]} />
</View>
);
}
};
The TextInput component attributes are pretty self-explanatory and work on
both platforms. Note here that it’s possible to define a component’s style to
be a combination of a few different styles by passing an array of styles. For
the style definitions here, refer to the code download.
Now with a new note screen in place, we can navigate to it. Let’s start by
getting Android in place to do that.
Chapter 8. React Native • 292
report erratum  •  discuss

Navigation on Android
We’ll allow users to navigate to the new note screen when they choose the
New menu option. There the user should be able to save the note or cancel
to return to the main screen. To set up the navigation between screens, we
need to have some routes defined for each screen; and to define the menu
items for each screen, we need to have more than one list of menu actions.
ReactNative/react_native_01_05_new_note_screen/Notes/index.android.js
var mainRoute = {name: 'Notes'};
var newNoteRoute = {name: 'New Note'};
var mainMenuActions = [ { title: 'New', show: 'ifRoom' } ];
var newNoteMenuActions = [
{ title: 'Save', show: 'ifRoom' },
{ title: 'Cancel', show: 'ifRoom' },
];
// ...
initialRoute() {
return mainRoute;
}
The initialRoute function is a helper function to return which route we want
first. The mainRoute and newNoteRoute define the titles for each screen. Then, the
mainMenuActions and newNoteMenuActions define the menu options for them.
On the main screen there’s only one menu item, so we navigate to the new
note screen by pushing the newNoteRoute onto the navigator. If the user cancels
from the new note screen, position 1 will be sent to newNoteMenuAction, and we
pop the current navigator’s stack. In either case the navigator is referenced
through this.refs, which is a map of named children on the current component.
We can add a named component to that map by using ref='name', as you can
see in the following code. Because now the app contains two screens instead
of one, let’s break out the scene-rendering function to a new function.
ReactNative/react_native_01_05_new_note_screen/Notes/index.android.js
render() {
return (
<Navigator
ref="navigator"
initialRoute={this.initialRoute()}
renderScene={this.routeMapper} />
);
}
We’ll call this function routeMapper. Its job is to return the correct view definition
for the current route to the navigator.
report erratum  •  discuss
Day 1: Comparing Notes • 293

ReactNative/react_native_01_05_new_note_screen/Notes/index.android.js
routeMapper(route, navigator) {
switch(route.name) {
case mainRoute.name: return (
<View style={{flex:1}}>
<ToolbarAndroid
title={route.name}
actions={mainMenuActions}
style={styles.toolbar}
onActionSelected={() => {
navigator.push(newNoteRoute);
}}
/>
<MainScreen />
</View>
);
case newNoteRoute.name: return (
<View style={{flex:1}}>
<ToolbarAndroid
title={route.name}
actions={newNoteMenuActions}
style={styles.toolbar}
onActionSelected={(position) => {
switch(position) {
case 0: return null;
case 1: navigator.pop();
}
}}
/>
<NewNote />
</View>
);
}
}
In the case of the main route being the current route, we’ll define a view
containing the MainScreen and an appropriately configured Action Bar. Same
for the new note screen.
Run or reload the app on Android to see the navigation working. You can use
Cancel to get back to the main screen from the new note screen. Then, let’s
get iOS caught up.
Navigation on iOS
We have pretty much the same problems to solve for iOS, but in a slightly
different way. Instead of actions in a menu, we have the title, left button, and
right button as defined by the object handed to the Navigator.NavigationBar. To
make it easy to define these buttons, let’s create a small factory method that
Chapter 8. React Native • 294
report erratum  •  discuss

allows us to configure the title and action function to execute when the user
presses it.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
var navButtonFactory = function(config) {
return (
<TouchableOpacity
onPress={() => config.actionFunction()}>
<Text style={config.styleArray}>
{config.title}
</Text>
</TouchableOpacity>
);
};
Here you can see how to define an onPress action for the TouchableOpacity tag.
Let’s define routes for each screen, just as we did in the Android index file.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
constructor(props) {
super(props)
this.mainRoute = {name: 'Notes'};
this.newNoteRoute = {name: 'New Note'};
}
initialRoute() {
return this.mainRoute;
}
Then, inside of the render function, so that we can get the correct reference
back to the index page, we’ll define the mapping object for the navigation bar.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
render() {
var navigationBarRouteMapper = {
indexPage: this,
LeftButton: function(route, navigator, index, navState) {
return this.indexPage.leftButtonForRoute(route, navigator);
},
Title: function(route, navigator, index, navState) {
return(
<Text style={styles.navBarTitle}>
{route.name}
</Text>
);
},
RightButton: function(route, navigator, index, navState) {
return this.indexPage.rightButtonForRoute(route, navigator);
},
};
report erratum  •  discuss
Day 1: Comparing Notes • 295

The title is simply the name of the route, but the left and right buttons need
to make more complex choices about title and action. The helper methods on
the index page, leftButtonForRoute and rightButtonForRoute, make the code a little
more readable. We’ll look at those functions in a second, but first here’s the
rest of the render function:
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
return (
<Navigator
initialRoute={this.initialRoute()}
renderScene={(route, navigator) => (
<View style={styles.screen}>
{this.screenForRouteNavigator(route, navigator)}
</View>
)}
navigationBar={
<Navigator.NavigationBar
style={styles.navBar}
routeMapper={navigationBarRouteMapper}
/>
}
/>
);
}
This defines a view that gets its children from screenForRouteNavigator and the
navigation bar that uses the mapper object we just created.
The screenForRouteNavigator function uses the route argument to determine the
correct component to display.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
screenForRouteNavigator(route, navigator) {
switch(route.name) {
case this.mainRoute.name: return (
<MainScreen style={styles.screen} />
);
case this.newNoteRoute.name: return (
<NewNote style={styles.screen} />
);
}
}
The left button will be either empty on the main screen, or the Cancel button
on the new note screen. To set it up this way, we build a configuration object
with a title and an action function based on the route argument to the leftBut-
tonForRoute function.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
leftButtonForRoute(route, navigator) {
Chapter 8. React Native • 296
report erratum  •  discuss

var action = null;
var title = null;
switch(route.name) {
case this.mainRoute.name: return null;
case this.newNoteRoute.name:
action = () => navigator.pop();
title = 'Cancel';
break;
}
return navButtonFactory({
title: title,
actionFunction: action,
styleArray: [styles.navButtonText, styles.navButtonLeft]
});
}
We then use the button factory to produce that button and return it. The
right-button configuration is done in the same way.
ReactNative/react_native_01_05_new_note_screen/Notes/index.ios.js
rightButtonForRoute(route, navigator) {
var action = null;
var title = null;
switch(route.name) {
case this.mainRoute.name:
action = () => navigator.push(this.newNoteRoute);
title = 'New';
break;
case this.newNoteRoute.name:
action = () => {return null};
title = 'Save';
break;
}
return navButtonFactory({
title: title,
actionFunction: action,
styleArray: [styles.navButtonText, styles.navButtonRight]
});
}
On iOS on the main screen, the right button should be the New button, and
on the new note screen the Save button is the right button. For Android, the
Save button will be to the left of the Cancel button. Now, with the navigation
configured for each screen, running the app on both platforms should produce
a simple two-screen app with the appropriate navigation for each platform
as shown in the figure on page 298.
report erratum  •  discuss
Day 1: Comparing Notes • 297

We’ve gotten to a pretty good place for today, but before we stop, let’s clean
up the code a little bit.
Consolidating Routes and Styles
First, let’s critique the code as it stands now. We’ve done a significant amount
of coding in each of the platform’s index files to get the platform-specific
navigation in place. You can see that this approach has the advantage of
providing an interface that matches the needs of each platform.
But you probably also get the feeling that if this app grew any more complex
it would quickly become unwieldy to add new screens and navigation. Putting
this much pressure on the index files is probably an unscalable solution.
We’ll leave things as they are for now, at least for navigation, but there are a
few things we can clean up and consolidate.
Consolidate all of the style definitions in one style definition in a new file
called styles.js. Then, in each file where we need styles, we can require that file.
var styles = require('./styles');
Refer to the code download for the consolidated style definition. We can also
clean up one area of duplication; each index file has the same definition for
the routes, so let’s move this to a file called routes.js.
ReactNative/react_native_01_07_route_consolidation/Notes/routes.js
var Routes = {
mainRoute: {name: 'Notes'},
newNoteRoute: {name: 'New Note'},
initialRoute: function() {
return this.mainRoute;
}
};
Now, in either index file we can require the routes file and control the routes
in one place.
var routes = require('./routes');
Chapter 8. React Native • 298
report erratum  •  discuss

With those things consolidated a bit we can wrap up Day 1.
What We Learned on Day 1
On this first day with React Native we’ve covered a lot. We started out by
seeing how a project was generated and run on each platform, iOS and
Android. Then we started building the main screen for the app.
We decided that we’d like to have platform-specific navigation for the app, so
we built an Action Bar for Android and a navigation bar for iOS. We did this
easily by adding code to the platform-specific index files generated for us by
React Native. We finished up by consolidating some of the things we could
easily consolidate, such as styles and route definitions.
Your Turn
Find
• React Native documentation
• Flexbox documentation (React Native uses this for defining the view layout.)
• iOS Simulator documentation
• Android emulator documentation
Do
• Use the developer menu to connect to the debugger. Add some console.log
statements in the code to get familiar with debugging and logging.
• Use the developer menu to inspect elements.
• My tastes for styling trend toward the “shades of grey” motif. Try styling
the app to your taste.
Day 2: Exchanging Notes
Or, Creating Notes and Calling the API
Today we’ll write the code to accept user input and create a note from the
new note screen. Then we’ll get the notes displayed in a list on the main
screen. We’ll also get the notes saving to and loading from the API.
Creating a New Note
Let’s get started by creating a new note. First, to store note data locally we’ll
create a data model.
report erratum  •  discuss
Day 2: Exchanging Notes • 299

Creating a Note Data Model
Add this class to a new file called data/NotesDataModel.js:
ReactNative/react_native_02_01_saving_a_new_note/Notes/data/NotesDataModel.js
'use strict';
class NotesDataModel {
notes:Array<Object> = [];
createNewNote(title:String, body:String) {
this.notes.push({title: title, body: body});
}
}
module.exports = NotesDataModel;
This is a simple class at this point, with an array of note objects and a method
to add a new object to the array. Notice that we’re using the ES2015 class
syntax here. It’s possible to mix styles, as we’ve done so far to get a taste of
the possibilities, but in your project it’d be better to pick one style, based on
the standard your team chooses to follow.
Now let’s require the data model in the index files. Here is what the Android
index looks like, but the same changes should go into the iOS index as well:
ReactNative/react_native_02_01_saving_a_new_note/Notes/index.android.js
import NotesDataModel from './data/NotesDataModel';
import EventEmitter
from 'EventEmitter';
Notice that we also required an EventEmitter. This is a Node class that allows
us to have components subscribe to events and take action if they receive an
event. Let’s see how to use that class to emit events.
Using an Event Emitter
In both index files, we initialize the app class with a saveEventEmitter.
ReactNative/react_native_02_01_saving_a_new_note/Notes/index.android.js
var noteDataModel = new NotesDataModel();
var saveEventEmitter = new EventEmitter();
var savePressed = function() {
saveEventEmitter.emit('shouldSaveNewNote',
{model:noteDataModel});
};
In the savePressed function, we’ll use this EventEmitter to broadcast an event when
the Save button is pressed and to pass along a reference to the data model.
We need to do this because of the way the navigator adds the new note screen
later—it seems that we can’t reference it through this.ref because that map is
Chapter 8. React Native • 300
report erratum  •  discuss

not updated with any new refs from view components after we navigate to the
new note screen.
To get around this limitation we expect a saveEventEmitter passed into the new
note class. We register for the shouldSaveNewNote event when the component is
mounted. The function componentDidMount is a life-cycle method called by React
Native after the component is rendered.
ReactNative/react_native_02_01_saving_a_new_note/Notes/screens/NewNote.js
componentDidMount() {
this.props.saveEventEmitter.addListener('shouldSaveNewNote',
this.saveNote, this);
}
componentWillUnmount() {
this.props.saveEventEmitter.removeAllListeners('shouldSaveNewNote');
}
saveNote({model:model}) {
model.createNewNote(
this.state.noteTitle,
this.state.noteBody
);
}
In this method we register the saveNote function to be called when the event
is received. That method calls through to the model’s createNewNote method.
Also, keep in mind that whenever we register for an event we should remove
the listener when we’re done or we’ll get strange behavior with components
hanging around in memory, listening for events when they shouldn’t.
The saveEventEmitter is available through this.props in the new note screen. This
is where we can access anything passed into a component through an XML
attribute, as you can see here in the index screen. Make sure the saveEventEmitter
and noteDataModel attributes are on the NewNote tag in both index files.
ReactNative/react_native_02_01_saving_a_new_note/Notes/index.android.js
case routes.newNoteRoute.name: return (
<View style={{flex:1}}>
<ToolbarAndroid
title={route.name}
actions={newNoteMenuActions}
style={styles.androidToolbar}
onActionSelected={(position) => {
switch(position) {
case 0:
savePressed();
navigator.pop();
break;
case 1:
report erratum  •  discuss
Day 2: Exchanging Notes • 301

navigator.pop();
break;
}
}}
/>
<NewNote
saveEventEmitter={saveEventEmitter}
noteDataModel={noteDataModel} />
</View>
);
We have the user interaction with the save buttons tied to the new note screen
through an event emitter. Let’s finish saving the note into the data model.
Saving the New Note to the Data Model
In the saveNote function in the new note screen, we reference this.state.noteTitle
and this.state.noteBody. Each component has a concept of state, which is a map
for storing any component-specific data. Each time the two TextInput fields
change text, we update this state with the current value of those fields.
ReactNative/react_native_02_01_saving_a_new_note/Notes/screens/NewNote.js
render() {
return (
<View style={styles.container}>
<TextInput
ref='titleText'
placeholder="Note Title"
onChangeText={(text) =>
this.setState({noteTitle:text})}
style={[styles.noteTextInput, styles.titleTextInput]} />
<View style={styles.divider} />
<TextInput
ref='bodyText'
placeholder="Enter a note..."
multiline={true}
textAlignVertical='top'
onChangeText={(text) =>
this.setState({noteBody:text})}
style={[styles.noteTextInput, styles.noteBodyTextInput]} />
</View>
);
}
When the save button is pressed, we’ll have this latest state to use to create
a new note. Now we need to make sure that the savePressed functions in each
index file are called when Save is pressed in either the navigation bar on iOS
or the menu on Android. We modify the button factory configuration on iOS:
Chapter 8. React Native • 302
report erratum  •  discuss

ReactNative/react_native_02_01_saving_a_new_note/Notes/index.ios.js
case routes.newNoteRoute.name:
action = () => {
this.savePressed();
navigator.pop();
}
title = 'Save';
break;
Now let’s use React Native’s debugger to see the progress we’ve made so far.
Debugging to See Progress
Because we don’t have anything wired up to display notes yet, to see this
working, add a line to saveNote in the new note screen after the call to model.cre-
ateNewNote:
console.log(model.notes);
Then use the developer menu to make sure the simulator and the emulator
are debugging to Chrome. Run or reload the apps and save a few notes, and
you should see something like the figure on page 304.
Now we’re creating notes; let’s get them displaying on the main screen.
Displaying a List of Notes
The data model is providing the current list of notes, so the first step to dis-
playing the notes on the main screen is to get the data model referenced in
the MainScreen in each index file. Here is the change in iOS; make a similar
change for Android, too.
ReactNative/react_native_02_02_displaying_notes/Notes/index.ios.js
case routes.mainRoute.name: return (
<MainScreen noteDataModel={this.noteDataModel} />
);
Now we’ll need to notify the main screen whenever the note list has changed
so it can update its display. We’ll do that with the same event emitter pattern
we used for listening to the save button press.
Emitting Events from the Data Model
Instead of creating an EventEmitter, we’ll make the model itself extend EventEmitter.
ReactNative/react_native_02_02_displaying_notes/Notes/data/NotesDataModel.js
class NotesDataModel extends EventEmitter {
notes:Array<Object> = [];
newDataSourceFromRows():ListView.DataSource {
let ds = new ListView.DataSource(
report erratum  •  discuss
Day 2: Exchanging Notes • 303

{rowHasChanged: (r1, r2) => r1 !== r2}
);
return ds.cloneWithRows(this.notes);
}
createNewNote(title:String, body:String):void {
this.notes.push({title: title, body: body});
this.emit('noteRowsUpdated', {model: this});
}
}
Now when createNewNote is called, we can emit an event called noteRowsUpdated,
passing a reference to the model.
We added a method called newDataSourceFromRows, which returns ListView.DataSource.
The component we’re about to add to the main screen to display the list of
notes is called a ListView, and it needs a DataSource to display a list.
Chapter 8. React Native • 304
report erratum  •  discuss

Using a ListView.DataSource
The newDataSourceFromRows method on the model constructs a new data source
according to the specs, including a function for the list to determine if a par-
ticular row of data is actually different from another. This is used to optimize
the display of similar data.
Now, in the main screen, add a few methods to connect up with the data
model. The constructor sets up the component’s state variable, which will be
managed by React Native when we call setState in the future. We also need to
take the further step of binding other methods we’ll look at in a second. Bind
these to make sure that they have the right scope when they’re called so that
they have access to this.props. The mount and unmount methods are used in the
same way as on the new note screen: to add and remove event listeners.
ReactNative/react_native_02_02_displaying_notes/Notes/screens/MainScreen.js
constructor(props) {
super(props)
var model = this.props.noteDataModel;
this.state = {
dataSource: model.newDataSourceFromRows(),
};
this.updateDataSource = this.updateDataSource.bind(this);
this.listView = this.listView.bind(this);
}
componentDidMount() {
var model = this.props.noteDataModel;
model.addListener('noteRowsUpdated', this.updateDataSource);
}
componentWillUnmount() {
var model = this.props.noteDataModel;
model.removeAllListeners('noteRowsUpdated');
}
updateDataSource() {
var model = this.props.noteDataModel;
this.setState({
dataSource: model.newDataSourceFromRows(),
});
}
When the noteRowsUpdated event is received, the updateDataSource method is called,
which resets this.state.dataSource to a fresh ListView.DataSource from the model. Any
time the component’s state is changed, it will call its render method. Now let’s
update the render method to display a ListView.
report erratum  •  discuss
Day 2: Exchanging Notes • 305

Rendering a ListView
In the render method, decide if we have any notes to display. If we don’t, display
the old no-data screen. If we do, however, call the new listView method.
ReactNative/react_native_02_02_displaying_notes/Notes/screens/MainScreen.js
render() {
var rowCount = this.state.dataSource.getRowCount();
var content = rowCount === 0 ? this.noDataScreen() : this.listView();
return content;
}
listView() {
var model = this.props.noteDataModel;
return (
<ListView
dataSource={this.state.dataSource}
renderRow={this.renderRow}
/>
);
}
renderRow(note) {
return(<Text>{note.title}</Text>);
}
noDataScreen() {
return (
<View style={styles.noDataScreen}>
<Text style={styles.noDataMessage}>
Create a note.
</Text>
</View>
);
}
The ListView component needs a data source, which we’ve just obtained from
the data model. It also needs a function to decide how to render a note to an
individual row. For now, just to see things working, we have renderRow return
a text component with the note title. If you’d like, run this to see that we’re
actually getting notes to display in a list. Then we can create a cell to make
the note list look a little more like we’d expect it to.
Creating a ListView Cell
Create a new file, screens/cells/NoteCell.js, and add the following class:
ReactNative/react_native_02_03_style_list_item/Notes/screens/cells/NoteCell.js
class NoteCell extends Component {
render() {
var bodyCharLimit = 140;
Chapter 8. React Native • 306
report erratum  •  discuss

var bodyChars = bodyCharLimit - 3;
var body = this.props.note.body;
return(
<View>
<Text style={styles.noteCellTitle}>
{this.props.note.title}
</Text>
<Text style={styles.noteCellBody}
numberOfLines={2}>{
(body.length > bodyCharLimit) ?
(body.substring(0, bodyChars) + "...") :
body
}</Text>
<View style={styles.divider} />
</View>
);
}
}
This is a simple view component, but we also add a little logic to limit the size
of the note body in the list and add an ellipsis. Then we can add some styles
to control the look of the cell.
ReactNative/react_native_02_03_style_list_item/Notes/styles.js
divider: {
height: 1,
marginTop: 2,
marginBottom: 2,
borderColor: '#F5F5F5',
borderWidth: .5
},
noteCellTitle: {
flex: 1,
fontSize: 18,
fontWeight: '500',
margin: 4,
},
noteCellBody: {
flex: 1,
fontSize: 12,
margin: 6,
},
Now, change the main screen renderRow to use the new component instead of
a Text component.
ReactNative/react_native_02_03_style_list_item/Notes/screens/MainScreen.js
renderRow(note) {
return(<NoteCell note={note} />);
}
report erratum  •  discuss
Day 2: Exchanging Notes • 307

Now, run the app on both platforms and look at where we’ve gotten.
Apart from some small differences in how the ellipsis code is working on each
platform, the note-creation code we’ve written for the data model, new note
screen, and list view in the main screen is working great on both iOS and
Android.
Now we have the notes saving locally in memory, so let’s get them persisting
to the API.
Connecting with the API
To connect with the API, we’ll add the networking code to the notes data
model. If the app grew, this architecture could be improved, but at least this
keeps the HTTP access out of the view code. Let’s start out by adding the
note-loading call, and then we’ll add the note-creation call.
Loading Notes
First, let’s add a method to return the correct URL. As we know from the
other apps we’ve written, this varies depending on the platform the code
executes on, at least if we’re trying to call the local host.
Chapter 8. React Native • 308
report erratum  •  discuss

ReactNative/react_native_02_04_load_notes/Notes/data/NotesDataModel.js
notesEndpoint():string {
// Use this for emulator
// String url = "http://10.0.2.2:3000/notes";
// Use this for genymotion
// String url = "http://10.0.3.2:3000/notes";
if (Platform.OS === 'android') {
return "http://10.0.2.2:3000/notes";
} else {
return "http://localhost:3000/notes";
}
}
Here you can see that with React Native it’s pretty simple to check which
platform we’re on using the Platform module.
Now let’s fetch all the notes that are in the API, using the fetch method and
chaining other calls after it.
ReactNative/react_native_02_04_load_notes/Notes/data/NotesDataModel.js
fetchAllNotes():void {
fetch(this.notesEndpoint(),{
headers: {
'Accept': 'application/json',
}
})
.then((response) => response.json())
.then((responseData) => {
this.notes = responseData;
this.emit('noteRowsUpdated', {model: this});
})
.done();
}
This method chain adds the appropriate headers, calls the endpoint, and
then receives the response. It returns the parsed JSON from that response,
which is passed into the last then. This is the array of notes we want, so we
assign that to the local notes variable and emit the event. To kick off that
fetch, add a call to fetchAllNotes to the main screen’s componentDidMount.
ReactNative/react_native_02_04_load_notes/Notes/screens/MainScreen.js
componentDidMount() {
var model = this.props.noteDataModel;
model.addListener('noteRowsUpdated', this.updateDataSource);
model.fetchAllNotes();
}
Now you should be able to test that at least the code compiles, but if you run
the app now you should see only the no-data screen unless you’ve added
report erratum  •  discuss
Day 2: Exchanging Notes • 309

notes to the API through some other means. Next let’s add the code to create
notes in the API, too.
Creating Notes
Change the model’s createNewNote function to add a fetch call as seen here.
ReactNative/react_native_02_05_create_note/Notes/data/NotesDataModel.js
createNewNote(title:String, body:String):void {
fetch(this.notesEndpoint(),{
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Accept': 'application/json',
},
body: JSON.stringify({title:title, body:body}),
})
.then((response) => response.json())
.then((note) => {
this.notes.push(note);
this.emit('noteRowsUpdated', {model: this});
})
.done();
}
This fetch will make an HTTP POST, so we set up the appropriate headers and
convert the note object to a JSON string. Once the response is received, we
put the returned note into the local notes list and emit the “updated” event.
The new create call is executed from the new note screen when the user
presses Save.
ReactNative/react_native_02_05_create_note/Notes/screens/NewNote.js
saveNote({model:model}) {
model.createNewNote(
this.state.noteTitle,
this.state.noteBody
);
}
Networking calls are pretty straightforward with React Native. One of the best
parts is that all the work is automatically done off of the main thread, so there
are no view performance issues to deal with when calling out to the web.
We’ve got a pretty solid app now. We’re saving and loading notes from the API
and displaying those notes in a list on the main screen. Let’s recap what we’ve
done today.
Chapter 8. React Native • 310
report erratum  •  discuss

What We Learned on Day 2
Today we added the core functionality for the app: creating and displaying
notes in a list. First we added a data model to hold on to note data. Then we
added a screen to work as a form for the user to enter a new note.
We saw how events can work in React Native, how the ListView component
works, and then finally how to make both GET and POST HTTP calls to our API.
Your Turn
Find
• The JavaScript library that provides the fetch command
• React Native documentation for ListView
Do (Easier)
• When a note is created on the API, the returned data has a “created at”
date. Add this to the note cell.
• Add a loading indicator for when the notes are being loaded or a new note
is being created.
Do (Harder)
• Add a “pull to refresh” feature. How can you do this for both platforms?
• Add a way to delete notes. This should include a UI, new methods on the
data model, and a call to delete the data on the API. The path should be
something like http://localhost:3000/notes/<id>, and you’ll need to use the DELETE
HTTP method.
• Design and implement a way to edit existing notes. The path to make the
change on the API will be something like http://localhost:3000/notes/<id>, and
you’ll need to use the PUT HTTP method.
Day 3: Taking Note of Where We Are
Or, Geotagging Notes and Displaying Them on a Map View
Today we’ll add another set of features to our app. These features all have to
do with location. We’ll allow the user to geotag notes with the device’s current
location and then later display all the notes on a map view.
I need to mention a caveat here. The current version of React Native at the
time this was written was 0.23.0. At that time the device location and map
APIs were not fully supported on Android. That means that loading the current
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 311

location didn’t work on Android, but it failed gracefully with a warning. I
expect that as React Native continues to improve, this code will work as
written on Android.
The React Native APIs that wrap these features are written in a non-platform-
specific way, so when Android support catches up the code should work. Later
revisions to this book may contain more information. One thing you’ll notice
is that in cases like this, where the platform support is not at parity, React
Native tools do a great job of failing gracefully, at least during development.
Geotagging Notes
To geotag a note, we’ll add a few pieces of data to it. We’ll need a latitude and
a longitude for starters and then a human-readable place name. The latitude
and longitude we’ll get from the local device’s location, and the place name
we’ll get through the API using a reverse geocode lookup. Let’s start by getting
the device’s location.
Getting the Device’s Location
First we’ll change the new note screen to add a button the user can press to
geotag the note. Add the following view code between the note title and the
note body TextView components in the new note screen.
ReactNative/react_native_03_01_location_tag_ui/Notes/screens/NewNote.js
render() {
return (
<View style={styles.container}>
<TextInput
ref='titleText'
placeholder="Note Title"
onChangeText={(text) =>
this.setState({noteTitle:text})}
style={[styles.noteTextInput, styles.titleTextInput]} />
<View style={styles.divider} />
<View style={styles.locationButtonContainer}>
<TouchableOpacity
onPress={this.addLocationPressed}>
<Text style={styles.locationPreferenceLabel}>
Add current location
</Text>
</TouchableOpacity>
</View>
<View style={styles.divider} />
<TextInput
ref='bodyText'
placeholder="Enter a note..."
multiline={true}
Chapter 8. React Native • 312
report erratum  •  discuss

textAlignVertical='top'
onChangeText={(text) =>
this.setState({noteBody:text})}
style={[styles.noteTextInput, styles.noteBodyTextInput]} />
</View>
);
}
Then, once this view is pressed, we’ll call the getLocation method. This method
will ask the device for its current location. There are a few things to note here.
First we need the appropriate permissions and setup for each platform in
order for location APIs to be available.
Setting Up Projects for Location
On Android, pre-Marshmallow, permission is required in the Android project’s
manifest to access fine location. Note that at the time of writing, React Native
did not yet support Marshmallow-style permissions.
ReactNative/react_native_03_02_location_tagging/Notes/android/app/src/main/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.notes">
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
On iOS it’s necessary to add a message for the OS to display to the user when
location is requested. This is added to the Notes/ios/Notes/Info.plist file. It’s easiest
to edit the file as a text file (as opposed to a plist file in Xcode) and add the
following lines:
<key>NSLocationWhenInUseUsageDescription</key>
<string>
The Notes app would like to use your current location to add location to notes.
</string>
With this in place, let’s get the device’s current location.
Getting the Current Location
Working with the device location in React Native is like working with the nav-
igator.geolocation API in a web browser. It’s pretty straightforward.
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 313

ReactNative/react_native_03_02_location_tagging/Notes/screens/NewNote.js
addLocationPressed() {
this.getLocation();
}
getLocation() {
var self = this;
self.getLocationTimeoutAttempts = 1;
navigator.geolocation.getCurrentPosition(
(position) => {
self.locationLoaded(position);
},
(error) => {
if (error.code === error.TIMEOUT &&
self.getLocationTimeoutAttempts <
self.getLocationTimeoutMax) {
self.getLocation();
} else {
alert(error.message)
}
},
{enableHighAccuracy: true, timeout: 2000, maximumAge: 1000}
);
}
locationLoaded(position) {
console.log(position);
}
The only tricky bit in this code is an extra check to try to get the location a
maximum number of times if the request times out. I found that I needed to
add this code with the current version of React Native because the first request
always seemed to fail. Once the location is loaded, we can quickly log this to
the console to check that this code works. Test it if you’d like. Once you’re
happy, let’s move on to reverse-geocoding the location to get a human-readable
place name from the location.
Reverse-Geocoding Device Location
In the data model, once the device location is returned to locationLoaded, we
pass the latitude and longitude to reverseGeocode.
ReactNative/react_native_03_03_reverse_geocoding/Notes/data/NotesDataModel.js
locationLoaded(position):void {
this.reverseGeocode(position.coords.latitude,
position.coords.longitude);
}
reverseGeocode(latitude, longitude):void {
fetch(this.reverseGeocodeEndpoint(latitude, longitude),{
headers: {
Chapter 8. React Native • 314
report erratum  •  discuss

'Accept': 'application/json',
}
})
.then((response) => response.json())
.then((placeData) => {
let placeName = placeData.place;
this.emit('placeLoaded', {
place: placeName,
latitude: latitude,
longitude: longitude,
});
})
.done();
}
This does a request to the reverse geocode endpoint, which returns an object
with a place property. This is the name of the place the reverse-geocode API
found at that location. We emit an event, placeLoaded, with the place name and
coordinates.
So the round-trip for obtaining location starts with the addLocationPressed method
and returns to placeLoaded.
ReactNative/react_native_03_03_reverse_geocoding/Notes/screens/NewNote.js
addLocationPressed() {
this.props.noteDataModel.getLocation();
}
placeLoaded(placeData) {
this.place = placeData;
this.setState({noteLocationText: `At: ${this.place.place}`});
}
In placeLoaded, we store the place information on the new note screen for when
the user saves the note.
Saving and Displaying Note Location Data
We also modify the call to create a new note to include this new data.
ReactNative/react_native_03_04_save_location/Notes/data/NotesDataModel.js
createNewNote(title:String, body:String, place:Object):void {
let params = {title:title, body:body};
if (place != null) {
params.created_where = place.place;
params.latitude = place.latitude;
params.longitude = place.longitude;
}
And in the note cell’s render method, we conditionally display the location text
at the bottom of the cell.
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 315

ReactNative/react_native_03_04_save_location/Notes/screens/cells/NoteCell.js
render() {
var bodyCharLimit = 140;
var bodyChars = bodyCharLimit - 3;
var body = this.props.note.body;
return(
<View>
<Text style={styles.noteCellTitle}>
{this.props.note.title}
</Text>
<Text style={styles.noteCellBody}
numberOfLines={2}>{
(body.length > bodyCharLimit) ?
(body.substring(0, bodyChars) + "...") :
body
}</Text>
{this.locationText()}
<View style={styles.divider} />
</View>
);
}
locationText() {
if (this.props.note.created_where !== null) {
return (
<Text style={styles.noteCellLocation}>
At: {this.props.note.created_where}
</Text>
);
} else {
return null;
}
}
This means that the locationText method should return a Text component if it
finds location data on the note but return null otherwise. Run this code, create
a note with location data attached, and then compare that note to the others
in the list view. You should see something like this:
Now that we have location data saving with notes, and we can see location
information about notes with any such information attached, let’s add
another way to view notes with location: a map view.
Chapter 8. React Native • 316
report erratum  •  discuss

Adding a Map View
The map view will be an alternate view to the list view for notes. That means
we should configure navigation to the map view in a way that best matches
the platform, just as we did with the navigation bar versus the action bar.
So, we’ll add a tab bar to the iOS app and a view pager to the Android app.
Before we get started adding new things, we need to take all of the current
views and functionality for the note list out of MainScreen and put it in a new
file: screens/NoteList.js. Refer to the code download for how this file should look.
With that component taking the place of the current notes list, we can build
the Android structure into MainScreen. After we’re done with Android, we’ll
cover how to create the iOS-specific main screen.
Adding an Android View Pager
A view pager is a standard Android control to flip between views. It can have
a tab-like menu or not, depending on your design. The view pager component
for React Native, ViewPagerAndroid, doesn’t have an extra facility for displaying
tabs, so we’ll have to create our own to approximate Android behavior.
Adding Tab Buttons
We can add a class to the main screen to handle these tabs. A tab will be a
button with a label and then an optional “selected” view.
ReactNative/react_native_03_05_add_navigation_level_android/Notes/screens/MainScreen.js
class TabButton extends Component {
constructor(props) {
super(props)
this.titleClicked = this.titleClicked.bind(this);
this.selectedView = this.selectedView.bind(this);
}
render() {
return (
<View style={styles.androidTabButton}>
<TouchableOpacity
onPress={() => this.titleClicked() }>
<Text style={styles.androidTabButtonTitle}>
{this.props.title}
</Text>
</TouchableOpacity>
{this.selectedView()}
</View>
);
}
titleClicked() {
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 317

if (this.props.onClick) {
this.props.onClick(this.props.position);
}
}
selectedView() {
if (this.props.selected()) {
return (
<View style={styles.androidTabButtonSelected} />
);
} else {
return null;
}
}
}
The “selected” view will be displayed if the component’s selected function returns
true. When the TouchableOpacity instance on the screen is tapped, it will call the
onClick property as a function.
When the component is wired up, it’ll look like this.
ReactNative/react_native_03_05_add_navigation_level_android/Notes/screens/MainScreen.js
<View style={{flexDirection:'row'}}>
<TabButton
title="List"
position={0}
selected={() => mainScreen.state.selectedTab === 0}
onClick={this.tabButtonClicked}
/>
<TabButton
title="Map"
position={1}
selected={() => mainScreen.state.selectedTab === 1}
onClick={this.tabButtonClicked}
/>
</View>
The ViewPagerAndroid will contain two views: one for the note list and then a
second one as a placeholder for the map view we’ll add next.
Coding a View Pager
After the tab buttons in the render method, we’ll add the view pager with two
child views.
Chapter 8. React Native • 318
report erratum  •  discuss

ReactNative/react_native_03_05_add_navigation_level_android/Notes/screens/MainScreen.js
<ViewPagerAndroid
ref="viewPager"
style={styles.viewPager}
initialPage={0}
onPageSelected={this.onPageSelected} >
<View style={styles.pageStyle}>
<NoteList
noteDataModel={this.props.noteDataModel} />
</View>
<View style={styles.pageStyle}>
<Text>Second page</Text>
</View>
</ViewPagerAndroid>
The NoteList component that contains the current note list is the first view.
Because everything we’ve added to MainScreen so far is Android-specific, the
NoteList component contains everything about listing notes that’s cross-platform,
so it can be referenced from this new Android-specific MainScreen.
Next we’ll add a few methods that the view components have referenced to
keep the tabs and view pager in sync.
ReactNative/react_native_03_05_add_navigation_level_android/Notes/screens/MainScreen.js
onPageSelected(event) {
this.setState({selectedTab: event.nativeEvent.position});
}
tabButtonClicked(position) {
this.refs.viewPager.setPage(position);
this.setState({selectedTab: position});
}
We’ll have the concept of a selected tab, initially set to
0. When the view pager changes pages, onPageSelected is
called, and we update the state to set selectedTab to the
new page. This causes the tab buttons to re-render
correctly. Conversely, if a tab button is tapped, we’ll
update the view pager to the correct page.
Run the app on Android, and you should see the tabs
working as shown in the figure.
Now let’s start creating the new main screen for iOS.
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 319

Adding a Platform-Specific Main Screen
Everything we’ve just added to MainScreen.js is Android-specific, but we want a
main screen that works for iOS, just with iOS navigation components instead.
Let’s create that quickly.
React Native allows us to rename MainScreen.js to MainScreen.android.js and then
create a MainScreen.ios.js. Then, when we reference MainScreen from either of the
index files, the correct component for the current platform will be rendered.
Do that now, and then open the new MainScreen.ios.js.
Adding an iOS Tab Bar
We had to do a good bit of custom work to get this new level of navigation
into Android, but it’s a little bit easier on iOS. The iOS-specific main screen’s
render looks like this:
ReactNative/react_native_03_06_add_navigation_level_ios/Notes/screens/MainScreen.ios.js
render() {
var mainScreen = this;
return (
<TabBarIOS
barTintColor="#F5F5F5">
<TabBarIOS.Item
title="List"
selected={this.state.selectedTab === 'listTab'}
onPress={() => {
this.setState({
selectedTab: 'listTab',
});
}}>
{this.screenForTab()}
</TabBarIOS.Item>
<TabBarIOS.Item
title="Map"
selected={this.state.selectedTab === 'mapTab'}
onPress={() => {
this.setState({
selectedTab: 'mapTab',
});
}}>
{this.screenForTab()}
</TabBarIOS.Item>
</TabBarIOS>
);
}
Chapter 8. React Native • 320
report erratum  •  discuss

We have a TabBarIOS component with two TabBarIOS.Item children. Each of those
tab bar items has some attributes to figure out if it should be selected and
how to deal with being pressed. The child component of the tab bar item is
determined by screenForTab.
ReactNative/react_native_03_06_add_navigation_level_ios/Notes/screens/MainScreen.ios.js
constructor(props) {
super(props)
this.state = {
selectedTab: 'listTab',
};
}
screenForTab() {
switch(this.state.selectedTab) {
case 'listTab':
return(
<NoteList noteDataModel={this.props.noteDataModel} />
);
break;
case 'mapTab':
return(
<Text>Map Tab</Text>
);
break;
}
}
This function switches on the selectedTab state and
returns either the NoteList component or a place-
holder view. Run this in the simulator, and you
should see a view like in this figure, with tabs at
the bottom of the screen for either List or Map:
Now with this new navigation structure in place
for both platforms, let’s add the map view.
Adding a Map View
Adding a map view is pretty easy with React
Native. We don’t only just want to add the map,
though; we want to display notes on it, as long
as they have location data. Let’s prepare the data
model to return all the notes that have location
data in the format that the React Native map view
prefers.
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 321

Returning Map Annotations from the Data Model
We’ll have a method that the map view will call to get all the notes with location
whenever it renders. This method will be called mapAnnotations. That method
will work through all of the notes that have location data, returning an object
for each containing latitude, longitude, and title.
ReactNative/react_native_03_07_add_map_view/Notes/data/NotesDataModel.js
notesWithLocation():Array<Object> {
return this.notes.filter((note) => {
return note.latitude != null &&
note.longitude != null
});
}
mapAnnotations():Array<Object> {
let annotations = this.notesWithLocation().map((note) => {
let annotation = {
latitude: parseFloat(note.latitude),
longitude: parseFloat(note.longitude),
title: note.title,
};
return annotation;
});
return annotations;
}
We can use the Array.filter method to accomplish the first step of only working
with notes that have location data, and then use the Array.map method to turn
those notes into the data the map view would like.
Now we have data ready to put on the map. Let’s add the map component.
Displaying Notes on the Map View
Create a new file called screens/NotesMapView.js with the following contents:
ReactNative/react_native_03_07_add_map_view/Notes/screens/MainScreen.ios.js
<NotesMapView noteDataModel={this.props.noteDataModel} />
This connects the ‘MapView‘ component with the data model’s ‘mapAnnotations‘
method, so it renders all the location-based notes we produced in the last step.
Next we need to add the new NotesMapView component to the second view pager
position for Android and the second tab bar item for iOS.
Chapter 8. React Native • 322
report erratum  •  discuss

ReactNative/react_native_03_07_add_map_view/Notes/screens/NotesMapView.js
'use strict';
import React, {
View,
Component,
MapView,
} from 'react-native';
import styles from '../styles';
class NotesMapView extends Component {
render() {
return (
<View style={styles.container}>
<MapView
style={{flex:1}}
annotations={this.props.noteDataModel.mapAnnotations()}
/>
</View>
);
}
}
module.exports = NotesMapView;
Of course we need to pass in the reference to the data model as well. Believe
it or not, that’s all we need to do to display notes on the map.
Run the app and look at how notes look on a map view!
report erratum  •  discuss
Day 3: Taking Note of Where We Are • 323

Today we’ve really rounded out the app with a pretty cool feature: the ability
to display notes on a map, given that they have geolocation data attached.
What We Learned on Day 3
In this final day of exploring React Native, we worked with React Native’s
location API to add location data to notes. We used our reverse-geocode end-
point to add place data to notes if the user chooses. Then we modified the
list of notes to display this place data if it exists.
We then added an extra layer of navigation to each platform so we could dis-
play notes either in a list or on a map. We did this in such a way that we can
have Android-specific navigation components on Android and iOS-specific
components on iOS. Finally, we added a map view to display geocoded notes.
Your Turn
Do (Easier)
• Choose some icons for the list and the map and add them to the Android
tab buttons and the iOS tab bar.
• Add a loading indicator while the app is loading location and geocoding.
Do (Harder)
• Add a left or right callout to the map annotation. Look at the React Native
Map View documentation for more information about how this works with
an annotation. When the callout is pressed, show the full note in an
appropriate view on the screen.
• Design and implement an interface that allows the user to switch between
a note list and a note grid view on the list-view screen.
Wrapping Up React Native
Over three days we’ve been able to build a useful app on two platforms. Using
the React Native API it was easy for us to choose whether we wanted to keep
things platform-independent or add platform-specific features, such as navi-
gation that users expect on iOS and Android.
All of the code we’ve written is some form of the most modern JavaScript
available, enhanced by Facebook’s JSX spec to include XML view tags. It was
very easy to make calls to our API, and we’ve been able to access native APIs
through either cross-platform or platform-specific components.
Chapter 8. React Native • 324
report erratum  •  discuss

Strengths
React Native has a number of things going for it. The included components
that correspond to native components are surprisingly easy to implement.
You find yourself writing much less code than on the official platforms. Love
it or hate it, JavaScript is everywhere; and with the bleeding-edge JavaScript
standards available, React Native’s flavor of JavaScript is more fun to work
with than any other available.
One of the coolest features, though, is the debugging menu from the simulator
or the emulator. Automatic reload is a feature I immediately miss when going
from React Native to any other kind of mobile development.
A more advanced feature we didn’t look at is the ability to build native code
to back a React Native component that does what you need. The easy things
are easy with React Native, but the hard things are possible, too. Look for
more information on the React Native documentation site if you find yourself
needing a component that doesn’t exist yet.
Finally, the weight of Facebook behind the project is a pretty solid strength.
Since Facebook made React Native open source and subscription free, it’s
really easy to try it out. The pace of development seems pretty fast as well;
React Native for Android was released about six months after the iOS version,
and it’s catching up quickly.
Weaknesses
There are a few things to consider before jumping fully on board for your next
production app, though. Although Facebook’s done the heavy lifting for us,
we’ll have to trust that the project will remain supported, or that the commu-
nity will take up any slack. Luckily, the community seems to be growing well.
Another weakness is the documentation. Initial topics like how to get started
and work with most standard components are pretty well covered, but the
documentation gets spotty with more complex things. It’s likely to get better
with time, probably quickly. But you should keep this in mind when trying
to plan out a development project with React Native; you’ll want to plan extra
time for unknowns as you get into the complex bits.
The last weakness to note is full cross-platform support. Android is still behind
where iOS is, although it’s catching up quickly.
report erratum  •  discuss
Wrapping Up React Native • 325

Final Thoughts on React Native
React Native is a very strong contender for the go-to cross-platform app-
development platform. If you want certainty that you can get cross-platform
versions of more complex components, you may want to choose a different
tool. But if you have some flexibility and the luxury of patience, you’ll appre-
ciate that the tools are very lightweight and useful, and the amount of code
you need to write to build some really cool interfaces is surprisingly small.
React Native should be one of the first cross-platform tools you consider.
Chapter 8. React Native • 326
report erratum  •  discuss

CHAPTER 9
Wrapping Up
Seven weeks of apps. That’s a lot of apps, and a lot of weeks. Whether you
went through the weeks in order or jumped around, whether you followed
each chapter from first to last or skimmed to get what you need, you should
be proud to have gotten where you are. I hope you’ve learned something you
didn’t know before, that you’ve gotten exposure to a platform or a tool that
you hadn’t worked with previously, and that you have better context and
experience from which to choose and advise on a mobile development strategy
for multiple platforms.
Before you move on to your next app, let’s take a little time to wrap up. We’ll
do a little recapping and a little comparison across all of the tools and plat-
forms we’ve covered.
Official Native Platforms
The first few weeks we covered the “official” platforms, or the SDKs released
by the device and operating system makers themselves: Apple, Google, and
Microsoft. But we started out with the mobile web.
Web vs. Native
There’s been a long debate between proponents of the open web and developers
who believe native apps provide the best experience. Of course, given limited
resources, you’ll have to choose between alternatives. When building a mobile
experience you should be armed with enough knowledge of the trade-offs to
make an informed decision. Hopefully building the mobile web app and
comparing it to the rest of the native apps gave you that perspective.
But ideally, given the time and resources, your users should have as good of
an experience on native platforms as on the web, or more specifically they
should get what they need from both. This doesn’t mean that they need to
report erratum  •  discuss

have the same experience on web and native apps, but they should have an
appropriate experience on each platform.
From the web app chapter, you should have gotten a good idea of the tools,
technologies, and browser capabilities that bring the user an almost native
experience in a number of areas. This includes responsive design, storage of
local data, and offline support. The more familiar you are with the web’s
capabilities, the better equipped you are to make informed trade-offs or decide
to what extent it’s possible to make a mobile web page or a more app-like
experience.
The Big Two
Next up: the Big Two, iOS and Android. At the time this book is being written,
no other platforms come close in popularity. Support for one or the other,
whether as a consumer or a developer, is a galvanizing issue. When it comes
to getting an app to market, however, it’s hard to come up with a satisfying
argument that your app shouldn’t be on both.
There are lots of differences between the two development platforms. One big
difference you notice right away is how much it seems iOS development
depends on the IDE and Xcode. The SDK and the IDE feel very tightly inte-
grated, whereas for Android the official IDE is less tightly bound to the
underlying build tools and is coordinated by Gradle.
This dependence, though, is slightly less the case than it used to be: It’s
possible to use the Xcode command-line tools, such as xcodebuild, to control
iOS builds programmatically. But the integration with Xcode is really apparent
in view development. Apple definitely put a lot of thought into the UI for
developing views, but more complex areas, such as Auto Layout, require very
deep layers of menus and controls to manage. This is in stark contrast to
Android’s completely XML-based layout system. Android’s resource-manage-
ment system deals with screen sizes, orientations, and more, all while keeping
the view code in its XML dialect, not hidden in IDE menus—one area of
pretty big variance to keep in mind as you master both platforms.
Another area of variance is the amount and style of architecture each platform
offers—or demands, depending on your perspective. On Android there are a
number of classes and type hierarchies you should know about in order to
subclass them to get the behavior you want. Activities, fragments, services,
adapters—you need to understand how these work, which subclasses to use,
and how they work together to build apps. iOS, on the other hand, cares a
little less about how you architect your app. You most likely need to subclass
Chapter 9. Wrapping Up • 328
report erratum  •  discuss

UIViewController, but after that the system of having your classes conform to
protocols gives you more freedom to mix and match functionality, as well as
more flexibility in architecture. This is not to say that either is better or worse,
but it requires a shift in thinking.
There are more differences, of course, some significant, some trivial, but the
popularity of the platforms helps ensure that there’s an incentive to work
with both. But what about the Universal Windows Platform, where there’s
not as much consumer popularity to incentivize developers?
Microsoft, the Plucky Underdog?
From the perspective of someone who was introduced to computers in the
’90s, it’s somewhat ironic for Microsoft to be in the underdog position. But
with the rise of the iPhone and the advent of Android, Microsoft has had to
make some bold moves to try to recapture attention. From the consumer
perspective this hasn’t really taken off yet, but from a developer perspective
the Universal Windows Platform represents some significant improvements.
To build for the UWP, you’ll need to use a Windows computer, though. That
makes it more complicated to be a developer for iOS as well, which requires
a Mac. It’s not impossible, but it is extra friction. Developing for Android and
Windows is easier without switching development operating systems.
To the question of whether it’s worth developing for Windows phones, the
UWP adds incentive by making the same app work on tablets, desktops, and
other environments, such as the Xbox. Android apps can run on Android
phones, tablets, watches, and TVs, but they have no desktop operating sys-
tem—yet. iOS apps can run on iPhones, iPads, Apple Watches, and Apple
TVs. It’s also possible to share significant parts of an app between an iOS
app and an OS X application, but it’s extra work to configure and manage
that separate app and the shared code. However, UWP produces one app that
is ready to run on phones or desktops, with no extra work.
Cross-Platform Tools
Now let’s talk a bit about the cross-platform tools we covered in the book.
A Preference for Native
As discussed in the introduction, one of the reasons for choosing these three
tools was that they produce native apps instead of wrapped-HTML apps. The
assumption here is that native apps should be preferred. Even if there is a
savings in development time to deliver a cross-platform app using a web-view
report erratum  •  discuss
Cross-Platform Tools • 329

app, which is only the case for a relatively new developer, the difference in
quality negates the benefit.
This is a choice you can make for yourself, of course. Considering the trade-
offs, keep in mind that with so many native cross-platform tools like the ones
covered in this book, if the only benefit is a slightly quicker development time,
you can probably develop your skills to the point where this difference is
negligible.
Cross-Platform Considerations
Now, let’s consider some of the trade-offs between the tools we’ve covered so
far. The word trade-off may sound as if there are good and bad points to
consider between these tools. That may be the case, but some of the differences
may be more like matters of taste than trade-offs. For developers with many
choices when it comes to tools, a matter of taste is still an important consid-
eration. Let’s consider a few of the differences that you may care about when
choosing the tool that fits your needs and style.
Languages and Tools
There are some large differences between the tools we’ve covered; Xamarin
has quite a different toolset than RubyMotion and React Native. Xamarin goes
with the approach of offering a full IDE and visual editors. Xamarin provides
WYSIWYG editors that work for both Android’s and iOS’s UIs. Compilation is
all controlled from the IDE, which has autocompletion. Depending on how
you prefer to develop, that could be an important point. There are IDEs that
support RubyMotion, such as JetBrains’s RubyMine.
1 There’s also an open
source IDE called Nuclide, based on Atom, and it supports React Native.
2
Neither of these goes quite as far as Xamarin’s fully integrated experience,
though.
On the other hand, some developers may prefer not to have a separate IDE
and may prefer to develop in something they know and love, like Vim or
Emacs. In that case it’s a lot more likely that they can get the RubyMotion
and React Native tools working than Xamarin.
Then, of course, there is the language to consider. Xamarin is C#, RubyMotion
is Ruby, and React Native is a cutting-edge version of JavaScript. Differences
of opinion about compiled and interpreted, typed and duck-typed, and the
different styles between Ruby, JavaScript, and C# are important to consider.
1.
https://www.jetbrains.com/ruby
2.
http://nuclide.io
Chapter 9. Wrapping Up • 330
report erratum  •  discuss

Cost
It’s also important to consider cost. React Native is the only unpaid tool of
the three. Xamarin is certainly the most expensive. RubyMotion has a starter
version, but its restrictions require jumping through some hoops to maintain
an app—for instance, it supports only the latest versions of the Android and
iOS operating systems.
Compilation Style and Native API Support
Another important consideration is the way the language and tools you use
to develop translate into the running application. RubyMotion is being inter-
preted in a version of Ruby running on the various platforms. Xamarin works
by compiling C# code that runs in a .NET runtime on the different platforms.
React Native is being run on an interpreter also.
Your ability to write completely cross-platform code is the greatest on Xamarin,
and with Xamarin.Forms it’s almost 100 percent cross-platform. React Native
seems to have the next-best support. It aims to cover cross-platform use
cases as much as possible and offer platform-specific, React Native–specific
components next. This, combined with the ability to have code choose and
execute platform-specific code, is a nice compromise. RubyMotion allows you
to share whatever code you can write without referencing platform-specific
classes.
Support and Community
Whenever you choose a third party over one of the official platforms, you’re
placing the fate of your app at least a little in the hands of that party. Trust
is an important part of this relationship. Longevity is a good indication of how
much you can trust the third party. Xamarin has been around the longest,
since 2011. RubyMotion is the next oldest, and React Native is pretty new.
RubyMotion and Xamarin have full-fledged businesses built on their tools.
Facebook seems pretty invested in React Native, having released a few apps
with it, with likely more to come. However you gauge it, make sure you trust
the cross-platform tool vendor when you decide to build an app with it.
The community is also important to consider. RubyMotion has a very active
community with a number of open source tools and frameworks built by
RubyMotion developers. Xamarin has some things like component libraries
available, some from developers. React Native’s community is growing
quickly. Also consider how active the developer community is in answering
questions on forums.
report erratum  •  discuss
Cross-Platform Tools • 331

What’s Next?
Thank you for choosing this book to expand your skills in the mobile develop-
ment space. I hope this has been a valuable exercise for you over the last
seven weeks. I hope that what you’ve learned here improved your ability to
make informed decisions on how to develop mobile apps for more platforms
and more users. Take what you’ve learned here and expand on it. Keep
learning and growing as a developer, and don’t get stuck being an expert on
only one platform. You never know when the next one will come along and
change everything!
Chapter 9. Wrapping Up • 332
report erratum  •  discuss

Index
SYMBOLS
$ (dollar sign), pattern in
jQuery, 15
* (asterisk)
button layout, 272
row layout, 153
+= operator, 248
. (dot) syntax in jQuery, 17
@+id/foo syntax, 118
@@base_url, 222
{} (curly braces), Mustache,
29
A
AccessibilityIdentifier, 265
Action Bar, 291
actions
IntentFilter, 115
weather app buttons, 77, 
79
activities
Android manifest, 104
context and console, 191
controlling view from,
120–122
inflating layouts, 124
IntentService, 114–116
Java file, 104
life-cycle methods, 109, 
111, 113
logging, 112
saving instance data, 122
saving state with configu-
ration changes, 263
Activity
controlling view from,
120–122
life-cycle methods, 109, 
111, 113
RubyMotion, 186
saving instance data, 122
activity Java file, 104
Adapter
calculator app, 244–245
currency-conversion app,
133–135
RecyclerView, 133–135,
244–245
to-do app, 200–201
adapters, HTTP, 218, 221, 
224–225
AdaptiveVisualStates, 174
adb, 130
addLocationPressed, 315
addSerializableExtra(), 195–196
add_serializable_extras, 195
addition, 258
AddSymbolButton_Click, 159
AFMotion, 213
AFMotion::Client, 214, 224
AFNetworking, 213
ajax, 18
alert controllers, dialog boxes
for to-do app, 215
Android, see also calculator
app; currency-conversion
app; note-taking app; React
Native; RubyMotion; Xam-
arin
about, xiii–xiv, 101
Action Bar, 291
avoiding mistakes, 107–
116, 193
avoiding networking on
main thread, 108–116
dialog boxes, 204
emulator, xvii–xviii, 107
exercises, 116, 126, 138, 
205
interface definition, 118–
126
location permissions, 313
RubyMotion support,
183, 185
safe asynchronous code,
193–196
scaled pixels, 243
strengths and weakness-
es, 139, 328
support for, 328
view pager, 317–319
Android Debug Bridge, 130
Android emulator, xvii–xviii, 
107
Android SDK, xv–xviii
Android Studio, see also cur-
rency-conversion app
about, xiv, 103
advantages, 139
creating new projects,
103–107
manifest, 104
running apps in, 107
Angular.js, 14
annotations, map view, 322
Any size class, 90
API
building for to-do app,
190–199, 207–210, 
221–223
calling localhost, xviii

endpoints testing, 3–6
prerequisites, 1
running server, 2
setup, 1–6
testing, 2
App class, 268
app directory
dependencies, 14
RubyMotion projects,
185, 219
serving app from cache,
39
world-clock app, 12, 14
app icon, live tiles, 163, 174–
177
app transport security, 209
app.rb, Sinatra, 38
appcompat library, 189, 241
AppDelegate, 232
append, 253
Apple developer portal, xiii
apple-touch-icon, 40
application cache, world-clock
app, 32, 36–40
application delegate, 232
application tag, 240
ApplyToCurrentValue, 260
apps, see also calculator app;
currency-conversion app;
note-taking app; stock-
quote app; to-do app;
weather app; world-clock
app
about, xii
Android manifest, 104
API setup, 1–6
design goals, xi
IDs, 106
schedule, xii
seven weeks approach,
xi–xiii
AppTheme, 189
architecture, Android and iOS
comparison, 328
Array.filter, 322
Array.map, 322
ArrayAdapter, 200–201
asterisk (*)
button layout, 272
row layout, 153
async/await, 146, 179, 277
AsyncTask
currency-conversion app,
111–114
to-do app, 194–196
AsyncTaskLoader, 131
attribute inspector, 56
attribution, Yahoo! APIs, 3–5
authorization, location permis-
sions, 73
authorizationStatus(), 73
Auto Layout
calculator app, 233, 235
weather app, 57–58, 62, 
71
autocompletion, Xamarin,
330
await, 146, 179, 277
.axml extension, 241
B
Backbone.js, 14
Bacon, 188
BaseAddress, 146
before block, testing to-do app,
212
binary operations, 257–261
bind(), 23
binding
adaptive views, 173
calculator app, 272–274
data binding, 143, 148–
150, 153, 169
dynamic lexical scope, 23
lists, 305
to the model, 272–274
note-taking app, 305
stock-quote app, 143, 
148–150, 153, 156, 
169, 173
style properties, 156
x:Bind, 169
blocks
Cocoa classes, 209
testing to-do app, 212
breakpoints, 43, 46
broadcast_intent, 195–196
broadcasting
currency-conversion app,
115, 137
intents, 195–196
to-do app, 192, 195–196
BroadcastManager, 115
BroadcastReceiver, 115, 192
browser-based vs. natively
compiled apps
choosing tools, xv, 329
debate over, xiii, 327
need to support both, 9, 
48, 327
browsers
application cache, 36–40
caching, 32
checking if online, 34
consoles, 17
Brush, 158
Bundle, 122
Bundler
API setup, 1
installing, 1
installing Sinatra, 38
installing dependencies
with, 214
Button, 159
buttons
calculator app, 235–240, 
243–249, 271, 274, 
276
currency-conversion app,
119–120
layout with * (asterisk),
272
note-taking app, 290, 
294–298, 302, 317–319
resizing dynamically,
238–240
Skeleton, 43
stock-quote app, 159, 
169
tab buttons, 317–319
to-do app, 215–216
weather app, 77
world-clock app, 28, 30, 
43
C
C#, see also Xamarin
advantages, 179
async/await, 146, 179, 277
attributes, 232
binding, 150
code-behind, 145
constructors, 236
event handling, 248
interfaces, 236
LINQ, 152
notifications and hierar-
chy of classes, 177
properties, 245
stock-quote app, 142, 
144
syntax, 231
Index • 334

Xamarin.Forms, 268
XAML, 142
CACHE, 37
cache manifest, 36–42
caching
about, 32
application cache, 36–40
currency-conversion app,
120, 122, 127–138
invalidation, 32
JSON, 33
view holders, 134
web storage, 32–36
world-clock app, 32–40
calculator app, 230–278
about, 230
Android version, 231–
232, 240–249, 263
cross-platform with Xam-
arin.Forms, 266–278
currency conversion,
230, 275–278
endpoint, 4, 276
exercises, 249, 266, 278
iOS version, 232–240, 
262
layout, 233, 241, 243–
249, 263, 268–272
logic, shared, 250–265
model, wiring, 272–275
operations, adding, 255–
261
operations, binary, 257–
261
operations, unary, 255–
257
requirements, xvi
solution, 231–232, 266
styling, 233, 235, 240–
241, 246, 271, 274
testing, 231, 250–255, 
261, 264, 267, 278
user interface, building,
230–249, 266–272
user interface, testing,
264
user interface, updating
display, 261
user interface, wiring,
262–264
calculator_display ID, 265
call time, dynamic lexical
scope, 23
callback, defined, 19
cells
collection view, 236–240
creating ListView, 306
dequeuing, 211
weather app, 63, 96
centering, fragments, 125
change, as constant, ix
Charles proxy, xviii
classes
access to Java classes in
RubyMotion, 186
Android and iOS compar-
ison, 328
associating Swift classes
with collection view, 64
Cocoa classes in RubyMo-
tion, 209
hierarchy in C#, 177
namespacing, 14–16
clean, 220
click(), 26
click handler
calculator app, 239, 246–
249, 261–262, 264
currency-conversion app,
120
note-taking app, 300–
303, 318
stock-quote app, 159, 
166–170
to-do app, 202
world-clock app, 26, 31
client(), 197
CLLocationManager, 73, 75
CLLocationManagerDelegate, 73
clock app, see world-clock
app
Cocoa, 209, see also Core Lo-
cation
CocoaPods, 99, 214
code
application cache, 36–40
for this book, xix, 298
common code for cross-
platform RubyMotion
projects, 219
namespacing, 14–16
code-behind, 145
collection views
calculator app, 235–238
cells, 236–240
layout, 62, 235–238
weather app, 61–66, 88, 
95–98
color, conditional styling, 157
common code, cross-platform
RubyMotion projects, 219
common directory, 218
community support
cross-platform tools, 331
iOS, 99
Swift, 100
Compact size class, 90–92
companion editor, 59
companion files, Java, 195
completion, 83, 87
completion handlers, [weak
self], 68
Component class, 286
componentDidMount, 301, 309
components
adding, 293
displaying, 296
documentation, 325
mounting, 301, 305
selected, 318
unmounting, 305
conditional styles, 157
configuration changes
calculator app, 238–240, 
263
saving instance data, 122
to-do list, 194
weather app, 98
configureCellSize(), 96
configureViewForState(_:), 78
configure_buttons, 215
ConfigureRecyclerView, 248
console
about, 190
advantages, 227
building API for to-do
app, 190–199
printing vs. logging, 192
to-do app, 198, 209
constants, constraints, 57, 93
constraints
adding, 92
Auto Layout, 57–58, 62, 
71, 233, 235
collection views, 62
constants, 57, 93
priority, 96
progress spinner, 71
responsive layout, 90, 
93–98
size classes, 90, 93
uninstalling, 92
constructor, 305
constructors, 236
containers, Skeleton, 43
ContentPage, 268, 270
Index • 335

ContentPresenter, 173
ContentProvider, 138
ContentValues, 129
context
console and activity, 191
defining style resources,
155
passing, 193, 195
contracts
Database, 128
deserialization, 147
controllers, see alert con-
trollers; view controllers
Convert, 158
convert(), 120
/convert endpoint, 4, 102, 276
convertCurrency(), 116
convert_view, 201
ConvertBack, 158
Core Location, 72–76
CORS (cross-origin resource
sharing), 18
cost, cross-platform tools,
331
cross-origin resource sharing
(CORS), 18
cross-platform tools, see al-
so React Native; RubyMo-
tion, Xamarin
advantages, xiv
choosing, xv, 329–331
cross-site scripting attacks,
18
CSS, see also Skeleton
resetting, 42
world-clock app, 41–47
curly braces ({}), Mustache,
29
currency conversion, calcula-
tor app, 230, 275–278
currency-conversion app,
102–138
caching, 120, 122, 127–
138
endpoint, 4, 102
exercises, 116, 126, 138
IntentService, 114–116
Internet permissions, 108
layout, 104, 118–120, 
122–126, 132–137
networking, 108–116
requirements, xiv
setup, 103–107
storing history, 127–138
testing, 130
threading, 111–114
user interface, 104, 118–
126, 130–138
current width, 136
currentTarget, 27
CursorLoader, 138
custom event handlers, stock-
quote app, 165–170
custom view components, 160
D
data(), 27
data contexts, 150
data source, weather app, 65
data types, 81, 84–86
dataTaskWithURL(), 54, 65, 83
databases
contracts, 128
creating local, 2
currency-conversion app
history, 127–138
inserting records, 129
testing, 130
DataContract, 148
DataContractJsonSerializer, 148
DataMember, 148
DataSource, 237–238, 304
DataTemplate, 172
dates, converting, 25
Daylight Saving Time, 34
debugging
note-taking app, 303
React Native, 303, 325
world-clock app, 10
defaultConfig, 106
DefaultState, 172
degree symbol, 56
Delegate, 237–238
deleting
clock list, 28, 30
time zones, 30
dependency management
calculator app, 275
Gradle, 106, 109
RubyMotion, 189, 213
to-do app, 189, 192, 213
world-clock app, 12–14
Xamarin.Forms, 275
deserializeTodoArray(), 197
deserializing
stock-quote app, 143, 
147
to-do app, 197, 208, 226
weather app, 54, 81–88
design goals, xi
determineCurrentLocation(), 73, 75
DevKit, 1
dialog boxes
Android, 204
iOS, 215
to-do app, 203–204, 215
didSet, 67
dispatch_async, 61, 69
Display, 273
division, 258
doInBackground(), 112
dollar sign ($), pattern in
jQuery, 15
dot syntax, 17, 209
dynamic lexical scope, Java-
Script, 23
E
each(), 23
Eclipse, 103
EditText
currency-conversion app,
118
dialog boxes, 204
elements, outlets, 60
emulators, see also Genymo-
tion
automatic reloading in
React Native, 285, 325
choosing, xvii
HAXM, 186
RubyMotion projects,
configuring, 187
RubyMotion projects,
testing, 188
running Windows Phone
apps on virtual ma-
chine, xvii
running apps in Android
Studio, 107
using, xviii
endpoints
calculator app, 4, 276
currency-conversion app,
4, 102
note-taking app, 5, 315
RESTful, 4, 184
reverse-geocoding, 6, 315
stock-quote app, 5, 142
testing, 3–6
to-do app, 4, 184
Index • 336

weather app, 3, 52
world-clock app, 3
enum
defining for parsable data
types, 82
traitCollection, 97
weather app progress
bar, 70
environment variables,
MapQuest API key, 2
environments, RubyMotion,
223, 225
error checking, xii
ES2015, 286, 300
event handlers
C#, 248
calculator app, 239, 246–
249, 261–262, 264, 
276
currency-conversion app,
120
note-taking app, 289, 
295, 300–303, 318
property-changed events,
273
stock-quote app, 159, 
165–170
weather app buttons, 77, 
79
world-clock app, 26, 31
XAML, 167
EventArgs, 166–170
EventEmitter, 300–303
EventHandler, 248
exercises
Android, 116, 126, 138, 
205
calculator app, 249, 266, 
278
currency-conversion app,
116, 126, 138
Gradle, 138
HTTP client, 98
iOS, 66, 80, 98, 217
mobile web, 20, 31
note-taking app, 299, 
311, 324
OkHttp, 138
React Native, 299, 311, 
324
RubyMotion, 205, 217, 
226
stock-quote app, 151, 
162, 178
to-do app, 205, 217, 226
Universal Windows Plat-
form, 151, 162, 178
weather app, 66, 80, 98
world-clock app, 20, 31, 
47
Xamarin, 249, 266, 278
XAML, 151
Export, 236
extend(), 15
Extensible Application
Markup Language,
see XAML
extras, Intents, 114
F
Facebook, JSX, 286, 324
Facebook React Native,
see React Native
FALLBACK, 37
favicon, adding, 40
fetch
note-taking app, 309
weather app, 69, 87
fetching
note-taking app, 309
time zone data, 18–19, 34
weather app, 69, 87
files, see also manifest
cache manifest, 38
Java companion files,
195
naming, 59
note-taking app, 284
RubyMotion projects,
185, 189, 206, 218
stock-quote app, 143
to-do app, 185, 189, 
206, 218
world-clock app, 11
filtering
intents, 104, 115
map annotations in note-
taking app, 322
findViewById(), 120, 134
finish, 225
Flexbox, 299
floating point values, 254
forecast display in weather
app, 61–66, 88, 95–98
form_body_builder(), 197
forms
building in RubyMotion,
197
calculator app user inter-
face, building, 266–272
fragments
about, 122
creating, 123
layout for calculator app,
263
layout for currency-con-
version app, 125
view for currency-conver-
sion app, 122–126
Frame, 168, 170
frameworks, advantages, 11
G
generics
building HTTP client, 81–
88
RubyMotion, 194
Genymotion
about, xvii
configuring for RubyMo-
tion, 186
speed, 107
x86 architecture, 186
geotagging
locating device, 312–315
map view, 317–324
note-taking app, 282, 
311–324
notes, 312–316
gesture recognizer, weather
app search mode, 79
GET
parsable data types, 82
to-do app, 222
getApplicationContext(), 193, 195
getItemCount(), 134
getLocation, 313
getView, overriding, 200–201
GetCell, 237
GetItemsCount, 237
GetNamedArray, 147
Google, see also Android
API dashboard, 103
appcompat library, 189
Google Play Store, 104, 139, 
186
Google Translate, 138
Gradle
adding OkHttp, 109
adding RecyclerView, 132
advantages, 139, 328
currency-conversion app,
106, 109
exercises, 138
Groovy, 106
React Native, 284
Index • 337

Grid
calculator app layout,
271
stock-quote app, 152, 
159
grid systems
calculator app, xvi, 271, 
274
RecyclerView, 244
stock-quote app, 152, 
159
world-clock app, 41–44
GridLayoutManager, 244
Groovy, 106
Gson, 192, 197
H
HasFixedSize, 244
HAXM, 117, 186
height
dividing evenly, 272
row layout, 153
hide(), 26
history
automatic reloading cur-
rency-conversion app,
137
storing currency-conver-
sion app, 127–138
HTTP
adapters, 218, 221, 224–
225
API setup, 1–6
calls with ajax, 18
HTTP client
building, 81–88
defining, 83
exercises, 98
stock-quote app, 146
testing API endpoints, 3
to-do app, 192, 222
weather app, 81–88
http_client, 222
HttpClient, 146
I
Ice Cream Sandwich, 103
icons
favicons, 40
live tiles, 163, 174–177
IDs
Android layout tags, 118–
119
Android projects, 106
RecyclerView, 244
resources, 243
UI tests in Xamarin, 265
ifRoom, 203
IJsonValue, 147
import, 286
importing, React Native, 286
index files, React Native, 287, 
300
inflating views, 124, 245
init, NPM, 12
init(coder:), 69
init(nibName:bundle:), 69
initialRoute, 289, 293
INotifyPropertyChanged, 274
Input, 253, 259
insert(), 129
insertHistoryRecord(), 129
installing
Bundler, 1
dependencies with
Bundler, 214
dependencies with NPM,
13
Mustache, 28
Node.js, 12, 283
NuGet, 175
packages with NuGet,
241
React Native, 283
Ruby, 1
RubyGems, 2
Sinatra, 38
Skeleton, 41
instance data, saving, 122
integration testing, API, 2
IntentFilter, 104, 115
Intents, 114, 195–196
IntentService, 114–116
Interface Builder
about, 55
associating Swift classes
with collection view, 64
size classes, 90
Xamarin, 232
interface bundles, 232, 236
interfaces
C#, 236
cross-platform code in
RubyMotion, 218
definition in Android,
118–126
RubyMotion, 195
internationalization, Android
layout, 118
Internet permissions, 108
iOS, see also note-taking app;
React Native; RubyMotion;
to-do-app; weather app;
Xamarin
about, xiii, 51
app transport security,
209
Auto Layout, 57–58, 62, 
71
calling localhost, xviii
dialog boxes, 215
exercises, 66, 80, 98, 217
location permissions, 313
requirements, xiii, xvii
Simulator, xvii–xviii
strengths and weakness-
es, 99, 328
support for, 328
tab bar, 317, 320
iOS Simulator, xvii–xviii
IronRuby, 183
ItemClick, 166, 248
ItemCount, 245
ItemSource, 153
IUICollectionViewSource, 238
IValueConverter, 157
J
JAR, 189
:jar key, 189
Java
Android Studio, 101, 139
companion files, 195
generics and Loader, 194
RubyMotion, 186, 194–
195
threading, 111
JavaScript, see also Mus-
tache, React Native
caching objects, 33
dynamic lexical scope, 23
ES2015, 286, 300
JSX, 286, 324
namespacing, 14–16
JetBrains, 330
jQuery
about, 13
ajax, 18
click(), 26
data(), 27
dot (.) syntax, 17
extend(), 15
hide(), 26
installing dependencies
with NPM, 13
Index • 338

namespacing classes, 15
ready, 22
show(), 31
version, 13
JRuby, 183
JSON
about, 146
caching, 33
deserializing in stock-
quote app, 143, 147
deserializing in to-do app,
197, 208, 226
deserializing in weather
app, 54, 81–88
loading in stock-quote
app, 145
parsing with Gson, 192, 
197
parsing with JSON.NET,
276–278
parsing with JsonObject,
146
JSON.NET, 276–278
JSX, 286, 324
K
keyWindow, 207
keyword parameters, 210
L
labels
calculator app, 233, 235–
240, 268–269
sizing, 56
weather app, 55–58, 60, 
63, 92–95
lambdas, to-do app, 208, 
211, 214
latitude
endpoint, 6
geotagging notes, 312, 
314
weather app, 72
layout
Auto Layout, 57–58, 62, 
71, 233
calculator app, 233, 241, 
243–249, 263, 268–272
collection views, 62, 235–
238
currency-conversion app,
104, 118–120, 122–
126, 132–137
inflating, 124
landscape only in An-
droid, 126
layout manager strategy,
132
note-taking app, 285–
292, 298
resources, 119, 122–126
stock-quote app, 144, 
152–155
to-do app, 199
weather app, 57–58, 62, 
71, 88–98
layout-land, 126
LayoutInflater, 124
layouts, inflating, 245
leading space, 234
learning, need for continuous,
x
lexical scope, JavaScript, 23
libraries, choosing, 11
life-cycle methods
about, 109, 111
configuration changes
and, 113
RubyMotion, 186
LinearLayout, 118–120, 135–137
LinearLayoutManager, 133
LINQ, 152
Linux, xvii
listener_lambda, 208, 223
lists
converting model proper-
ties, 152, 154
converting strings to, 152
divs, 28
note-taking app, 303–308
scrolling, 153
stock-quote app, 151–
165, 175
styling, 155
to-do app, displaying,
199–201, 210–213
world-clock app, 28–30
ListView
creating cells, 306
note-taking app, 304–308
stock-quote app, 151–153
to-do app, 200–201
live tiles, 163, 174–177
loadConversionTask, 112
loadInBackground(), 131
Loader, 130, 194
LoaderCallbacks, 131
LoaderManager, 131
loading, see also reloading
currency-conversion app
history, 130
JSON in stock-quote app,
145
notes in note-taking app,
308
reloading currency-con-
version app automati-
cally, 137
state for weather app
progress bar, 70–72
stock-quote app data,
144–150
weather data by location,
72–79
localStorage, 33
LocalBroadcastManager
currency-conversion app,
115
RubyMotion, 195
to-do app, 195
localhost
app transport security,
209
calling, xviii
note-taking app, 308
whitelisting, 54
localization, Android layout,
118
LocalSettings, 164
location
device locating, 72–76, 
312–315
geotagging in note-taking
app, 282, 311–324
loading weather data by,
66, 72–79
location manager, 72, 75–
76
permissions, 73, 313
reverse-geocoding for
note-taking app, 282, 
312, 314
reverse-geocoding for
weather app, 52, 72, 
76–79
weather app styling, 92–
98
location manager, 72, 75–76
locationLoaded, 314
locationManager, 73, 75
locationText, 316
Log.d, 110
logging
Android, 110
Index • 339

vs. console printing, 192
currency-conversion app,
110, 112
loading time zones, 19
testing manifest caching,
39
weather app, 54
longitude
endpoint, 6
geotagging notes, 312, 
314
weather app, 72
M
main thread
avoiding networking on,
108–116
using dispatch_async, 61, 69
mainMenuActions, 293
mainRoute, 293
MainActivity, 241
MainPage, 268
MainPage.xaml, 144
MainPage.xaml.cs, 145
MainScreen, 303, 320
malware, 108
manifest, see also cache
manifest
about, 104
calculator app, 240
currency-conversion app,
104
editing, 240
including items, 108
IntentService, 115
Internet permissions, 108
location permissions, 313
RubyMotion, 189
themes, 240
to-do app, 189
updating, 104, 115
:manifest key, 189
map view
annotations, 322
note-taking app, 317–324
mapAnnotations, 322
MapQuest API, 2, 6
MapQuest API key, 2
Marshmallow, 313
Maven, 107
media queries, 41–47
menu items, adding in Ruby-
Motion, 203
MergedDictionary, 173
Microsoft, see also Universal
Windows Platform
Notifications Visualizer,
177
syncing roaming app da-
ta, 164
Visual Studio, xiv
MIME type, cache manifest,
38
minimum SDK, 103, 107, 240
minimumInteritemSpacing, 97
Minitest, 221
MiniTest::Mock, 221
MinWindowWidth, 172
mobile web, see also world-
clock app
about, xiii, 9, 328
exercises, 20, 31
loading like native app,
40
strengths and weakness-
es, 48, 328
mobile-first strategy, respon-
sive design, 44
model instance variable, 272
models
binding to, 149, 272–274
converting lists, 152, 154
MONO, 229
motion, 185
motion-async library, 194
mounting components, 301, 
305
multiplication, 258
Mustache, 28–30
N
namespacing, 14–16
NarrowState, 172
natively compiled vs. browser-
based apps
choosing tools, xv, 329
debate over, xiii, 327
need to support both, 9, 
48, 327
Navigate, 168
navigation, note-taking app,
288–299, 317–321
navigationBar, 289
navigationBarRouteMapper, 289
NavigationBar, 294
Navigator, 289
navigator.onLine indicator, 34
negation operator, 255
.NET
adding package, 275
binding, 148–150
parsing JSON with
JsonObject, 146
Xamarin, 229
NETWORK, 37
networking
application cache, 37
avoiding on main thread,
108–116
currency-conversion app,
108–116
with IntentService, 114–116
note-taking app, 308–310
whitelisting localhost, 54
newDataSourceFromRows, 304
new_intent, 195
ngrok, xviii
nil variables and Swift, 54
Node.js, see also NPM
installing, 12, 283
note-taking app, 283
React Native, 281
version manager, 283
node_modules directory, 284
note-taking app, 282–324
about, 282
Android navigation, 291, 
293–294
building main notes
screen, 285–292
building new note screen,
292–299
creating notes, 299–303, 
310
displaying list of notes,
303–308
endpoint, 5, 315
exchanging notes, 299–
310
exercises, 299, 311, 324
geotagging, 282, 311–324
iOS navigation, 289–291, 
294
layout, 285–292, 298
map view, 317–324
MapQuest API, 2, 6
navigation, 288–299
networking, 308–310
requirements, xvi
reverse-geocoding, 282, 
312, 314
setup, 283–285
styling, 286, 290, 292, 
298, 307
Index • 340

testing, 303
user interface, 293–303
notifications, live tiles, 174–
177
Notifications Visualizer, 177
NotificationsExtensions
package, 175
NotifyDisplayChanged, 262
NPM
creating project, 12–14
installing Mustache, 28
installing Skeleton, 41
installing dependencies,
13
React Native, 281
NSDictionary, 54
NSIndexPath, 64, 237
NSJSONSerialization, 209
NSURL, 53, 83
NSURLSession
to-do app, 208
weather app, 54, 83
NSURLSessionDataTask, 54, 209
Nuclide, 330
NuGet, 175, 241
nvm, 283
O
[object message] syntax, 209
Objective-C
[object message] syntax, 209
syntax, 232
Xamarin, 232
official native platforms, xiii,
see also Android, iOS
OkHttp
adding, 109–111
currency-conversion app,
109–111
exercises, 138
to-do app, 192, 196
OkHttpClient, 197
okio, 192
onBindViewHolder(), 135
onClick, 202, 318
onClickListener, 202
onCreate()
currency-conversion app,
109, 112, 115, 123, 
128
databases, 128
fragments, 123
OkHttp, 109
RubyMotion, 186, 193
to-do app, 186, 193
onCreateOptionsMenu, 203
onCreateViewHolder(), 134
OnCreateViewHolder, 245
onDestroy(), 116, 123
OnDisplayChanged, 261
onHandleIntent(), 114–116
onLoadFinished(), 132
OnNavigatedFrom, 170
OnNavigatedTo, 168, 170
onOptionsItemSelected, 203
onPageSelected, 319
OnPlatform, 271, 278
onPostExecute(), 112
onPress, 295
onReceive(), 115
onStart(), 123, 133
OnStart, 244
onUpgrade(), 129
operating system require-
ments, xvii
operations, calculator app,
255–261
Operator, 259
order of operations, calculator
app, 257–258, 260
orientation changes, see rota-
tion
outlets, 60, 77
P
package.json, 284
packages
Android manifest, 104
ID, 106
installing with NuGet,
241
management for world-
clock app, 12–14
restoring, 251
testing code for this book,
251
Page, 144
pager, view, 317–319
Parcelable, 195
parsable data types, 81
parse(), 34, 84
parse(_:), 82, 85–86
parse_array_response, 197
parse_object_response, 197
ParseResult, 83, 87
parsing
HTTP into Ruby array,
197
JSON with HTTP client,
81–88
JSON with JsonObject, 146
parsable data types, 81
vs. stringify, 34
percent operator, 255, 257
performance, see also speed
displaying lists in to-do
app, 201
findViewById(), 134
RecyclerView, 133
permissions
Internet, 108
location, 73, 313
Pivot control, 158
PivotItem, 158
pixels, scaled, 243
place property, 315
placeLoaded, 315
Platform, 309
platform_dirs, 220
platforms, see also Android,
iOS; mobile web; React Na-
tive; RubyMotion; Universal
Windows Platform; Xamarin
about, x, xiii–xvi
official native, xiii
Portable Class Library (PCL)
about, xv
calculator app, 231, 267
configuring, 231
POSIX, 141
POST
note-taking app, 310
to-do app, 222
Postman, 3
progress bar, weather app,
70–72
properties
binding, 150, 273
C#, 245
converting to lists, 152, 
154
property-changed events, 273
PropertyChangedEventArgs, 274
PushOperator, 260
PUT, to-do app, 213, 222
put method, to-do app, 226
Index • 341

R
R class, 120
Rails, 18, 183
rake config, 187
rake device, 187
rake emulator, 187
rake spec, 188, 207
Rakefile, 186, 219
Raleway, 42
React Native, see also note-
taking app
about, xvi, 281
debugging, 303, 325
exercises, 299, 311, 324
installing, 283
MapQuest API, 2
Nuclide, 330
platform-specific Main-
Screen, 320
Reload, 285, 325
strengths and weakness-
es, 324, 330–331
style definitions, 292
view pager, 317
wrapping features and
support, 312
ready, 22
records, inserting, 129
RecyclerView
adding, 243
calculator app, 243–249
currency-conversion app,
130, 132–137
RecyclerView.Adapter, 245
reduce(), 15
Register, 232
register(), 14
Regular size class, 90
RelativeLayout, 118
Reload (React Native), 285, 
325
reloadData(), 65
reloading
currency-conversion app
automatically, 137
note-taking app, 285, 
325
React Native, 285, 325
table view in to-do app,
211
weather app data, 65
render(), Mustache, 29
render, React Native, 286–287, 
296, 306, 315, 320
renderRow, 306
renderScene, 289, 292
Request, 110
Request.Builder, 197
requestWhenInUseAuthorization(), 74
request_builder(), 197
require, 298
resizing, buttons dynamically,
238–240
Resource.designer.cs, 243
ResourceDictionary, 173
resources
about, 328
calculator app, 240, 243
currency-conversion app,
119, 122–126
DataTemplate, 172
exercises, 126
layout, 119, 122–126
localization and interna-
tionalization, 118
Resource.designer.cs file, 243
RubyMotion, 189
stock-quote app, 172
to-do app, 189
Xamarin, 240, 243
:resources key, 189
Resources property, styling, 155
responsive design
calculator app, 233, 238–
240
stock-quote app, 163, 
170–174
weather app, 88–98
world-clock app, 41–47
RESTful endpoints, 4, 184
resume(), weather app API, 54
RetainInstance, 264
Retrofit, 117, 138
reuse identifier, 63
reverse-geocoding
endpoint, 6, 315
MapQuest API, 2
note-taking app, 282, 
312, 314
weather app, 52, 72, 76–
79
reverseGeocode, 314
roaming app data, stock-
quote app, 164
RoamingSettings, 164
rotation
activity life cycle, 113, 
194
calculator app, 238–240, 
263
currency-conversion app,
113
saving instance data, 122
to-do list, 194
weather app, 98
routeMapper, 289, 293
routes, 289, 293–299
routes.js, 298
RowDefinition, 153
Ruby
about, 183
advantages, 227
API setup, 1
installing, 1
RubyMotion requirement,
xv
version manager, 2
versions, 1
Ruby on Rails, 1
RubyGems, 2
RubyInstaller, 1
RubyMine, 330
RubyMotion
about, xv, 183
Android support, 183, 
185
Cocoa classes, 209
creating new projects,
185–191, 206
environments, 223, 225
exercises, 205, 217, 226
Java, 186, 194–195
keyword parameters, 210
requirements, xv
resources, 189
safe asynchronous code,
193–196
strengths and weakness-
es, 227, 330–331
tests macro, 212
versions, xv
Runnable, 194
rvm, 2
S
Sansonetti, Laurent, 183
--save switch, 13
saveEventEmitter, 300
saveInstanceState(), 122
savePressed, 302
scaled pixels, 243
scenes, 55
schema, loading, 2
Index • 342

screen sizes, see also media
queries; responsive design
breakpoints, 43, 46
layout for larger screens
in Android, 124–126
size qualifiers, 124
Skeleton list, 43
screenForRouteNavigator, 296
screenForTab, 321
scrolling
currency-conversion app,
135
lists, 153
stock-quote app, 153
ScrollViewer, 153
SDKs
Android SDK, xv–xviii
Android support, 140
minimum, 103, 107, 240
target, 107, 240
searching, weather app, 76–
79, 90–92
security
app transport security,
209
cross-origin resource
sharing (CORS), 18
Internet permissions, 108
location permissions, 73, 
313
whitelisting localhost, 54
Select, 152
selected, 318
selectedTab, 319, 321
#selector, 79
self
buttons in to-do app, 215
weak reference, 68
separation of concern, 25
Serializable, 195–196
serializeHashToString, 226
servers
cache manifest, 38
running, 2
Service, 114–116
setCellSize, 96
setContentView(), 120, 125
setLayout(), 124
setState, 305
SetLayoutManager, 244
Setter, 172
SetTitle, 236
show(), 31
showAsAction, 203
simulators
automatic reloading in
React Native, 285, 325
choosing, xvii
using, xviii
Sinatra, 38
size classes, 90–93, 99
size qualifiers, 124
sizing
cells for weather app, 96
labels for weather app, 56
resizing buttons dynami-
cally, 238–240
Skeleton, 41–44
smallest-width qualifier, 124, 
136
Solution Explorer, 143
solutions
calculator app, 231–232, 
266
Visual Studio, 143
Xamarin, 231–232, 266
SortedSet<string>, 164
source control
dependencies, 14
Xcode and, 99
sp, 243
spacing
leading and trailing, 234
minimum, 97
SpanSizeLookup, 246
spec directory, 185
specs
about, 188
cross-platform RubyMo-
tion projects, 221–222
RubyMotion versions,
207
testing, 221–222
view controller, 212
speed, see also performance
Android emulator, 107
application cache, 36, 40
UI tests, 252
Xamarin tests, 250, 252
spinner, 71
SQLite, 127–138
SQLiteOpenHelper, 127
Square, 109, 117, 138, see
also OkHttp
StackLayout, 268, 272
StackPanel, 144
state
currency-conversion app,
122
note-taking app, 302
stock-quote app, 171
weather app, 70–72, 78
StateTrigger, 171
static, 177
stock-quote app, 143–177
data binding, 143, 148–
150, 153
deserializing JSON, 143, 
147
detail screen, 165–170
endpoint, 5, 142
exercises, 151, 162, 178
layout, 144, 152–155
lists, 151–165, 175
live tile, 163, 174–177
loading and displaying,
144–150
parsing JSON, 146
requirements, xiv
responsive design, 170–
174
setup, 143–150
storage, 163–165
styling, 155–158
testing, 142, 165
user interface, 144–163, 
165–174
watch list, 158–165, 175
storing, see also caching
currency-conversion app,
127–138
stock-quote app, 163–165
weather app data, 62
world-clock app, 32–36
storyboards
about, 55
enabling User Interac-
tion, 79
weather app, 55–58
Xamarin, 232
string resources, layout, 118–
119
stringify(), 34
strings
caching JavaScript ob-
jects, 33
converting to lists, 152
style resources
calculator app, 240
RubyMotion, 189
Index • 343

styling, see also responsive
design
calculator app, 233, 235, 
240–241, 246, 271, 
274
conditional styles, 157
lists, 155
note-taking app, 286, 
290, 292, 298, 307
React Native style defini-
tions, 292
Resources property, 155
Skeleton, 41–44
stock-quote app, 155–158
weather app, 55–58, 64, 
92–98
world-clock app, 41–47
subtraction, 258
super(), 128
Swift, see also weather app
advantages, 99
associating classes with
collection view, 64
creating data model, 67–
70
creating projects in
Xcode, 53
exercises, 98
names, 59
nil variables, 54
parsable data types, 82
syncing, roaming app data,
164
SystemNavigationManager, 169
T
tab bar, 317, 320
TabBarIOS, 321
table view controllers, to-do
app, 210–213
tableView, 210
tabs, note-taking app, 317–
321
target SDK, 107, 240
Task<string>, 277
temperature, see weather app
templates
managing clock list, 28–
30
preprocessors, 28
RubyMotion, 185
testing
with adb, 130
API, 2
calculator app, 231, 250–
255, 261, 264, 267, 
278
currency-conversion app,
130
databases, 130
endpoints, 3–6
manifest caching, 39
note-taking app, 303
physical devices, xviii
roaming data storage,
165
with specs, 188, 207, 
212, 221–222
speed, 250, 252
stock-quote app, 142, 
165
to-do app, 188, 198, 
207, 209, 212
tests macro, 212
Text, 289
text(), 24
TextBlock, 144
TextInput, 292, 302
TextView, 118, 312
TextWrapping, 144
themes
calculator app, 240–241
to-do app, 187, 189
this variable, dynamic lexical
scope, 23
this.props, 301
this.refs, 293
threading
async/await, 146, 179, 277
avoiding networking on
main thread, 108–116
currency-conversion app,
111–114
Java, 111
weather app, 61, 69
TileHelper, 176
TileNotification, 175–177
tiles, live, 163, 174–177
TileUpdater, 175
time, see world-clock app
time zones
caching, 32–36
creating clocks, 21–27
deleting, 30
displaying current time,
22
endpoint, 3
managing, 17–20
offsets, 25
periods, 34
saved, 22, 25
styling, 42–47
templates, 29
to-do app, 184–226
about, 184
Android version, 184–205
building API, 190–199, 
207–210, 221–223
completing items, 202, 
211, 213
configuring and running,
186–190, 222–223, 225
creating items, 203–204, 
215–216
cross-platform version,
218–226
displaying lists, 199–
201, 210–213
endpoint, 4, 184
exercises, 205, 217, 226
iOS version, 184, 206–
217
layout, 199
requirements, xv
safe asynchronous code,
193–196
security, 209
setup, 185–191, 206, 
218–221
testing, 188, 198, 207, 
209, 212
themes, 187, 189
updating, 214
user interface, 199–204, 
210–217
ToolbarAndroid, 292
tools
Android support, 139
choosing, xv, 329–331
TouchableOpacity, 289–290, 295, 
318
trailing space, 234
traitCollection, 97
transition coordinator, 98, 
239
translation services, 138
tunneling software, xviii
“two stack” algorithm, order
of operations, 258
Type, 168
typealias, 82
U
u-pull-right, 43
UIAlertAction, 215
Index • 344

UIAlertController, 215
UICollectionView, 235
UICollectionViewCell, 63
UITableViewController, 210
UITapGestureRecognizer, 79
unary operations, 255–257
Underscore, 13, 15, 23
uninstalling constraints, 92
unit testing
calculator app, 231, 278
Xamarin, 231
Universal Windows Platform
about, xiii–xiv, 141
exercises, 151, 162, 178
requirements, xiv
strengths and weakness-
es, 178, 329
unmounting components, 305
updateDataSource, 305
updating
live tiles, 174–177
manifest, 104
URLs, parsing, 83
User Interaction, enabling, 79
UTC, see time zones
utility classes, Skeleton, 43
UWP, see Universal Windows
Platform
V
Value, 253
value converter, 156
vendor directory, 189
vendor_project, 189
view controllers
calculator app, 234
location manager, 76
naming, 59
testing with specs, 212
to-do app, 210–213
weather app, 55–61, 67–
70, 76, 79, 86–88
world-clock app, 25–27, 
30
view holders, 134, 201, 245
view pager, 317–319
viewDidLoad(), 69
viewState, 70–72, 78
viewWillTransitionToSize, 98
ViewController.designer.cs file, 235
ViewDidAppear, 237
ViewHolder, 245
ViewPagerAndroid, 317–319
viewport, loading web apps
like native apps, 40
views, see also collection
views
binding, 148–150
calculator app, 232–249
controlling from activi-
ties, 120–122
creating custom view
components, 160
currency-conversion app,
104, 120–126, 130–138
inflating, 124, 245
note-taking app map
view, 317–324
stock-quote app, 144–
150, 165–174
to-do app, 199, 210–213
weather app, 55–61, 77
XAML, 144
views() method, 213
Visual Studio, 142
creating project, 143
solutions, 143
stock-quote app, 143
Xamarin development, xvi
VisualStateGroup, 171
VisualStateManager, 171
VisualStates, 171
W
w qualifier, 136
watch list, stock-quote app,
158–165, 175
[weak self], 68
weather app, 52–99
about, 52
Auto Layout, 57–58, 62, 
71
data model, 67–70, 86–88
deserializing JSON, 54, 
81–88
displaying forecast, 61–
66, 88, 95–98
displaying weather data,
55–61
endpoint, 3, 52
exercises, 66, 80, 98
layout, 57–58, 62, 71, 
88–98
loading weather data, 52–
55
loading weather data by
location, 66, 72–79
organization, 66–72
progress bar, 70–72
requirements, xiii
responsive layout, 88–98
reverse-geocoding, 52, 
72, 76–79
setup, 53
storing data, 62
styling, 55–58, 64, 92–98
user interface, 55–66, 76–
79, 88–98
web development decisions,
11
web storage, 32–36, see al-
so caching; storing
whitelisting localhost, 54
width
adaptive view in stock-
quote app, 172
dividing evenly, 272
qualifiers, 136
Windows, see also stock-
quote app; Universal Win-
dows Platform
Ruby versions, 1
running on virtual ma-
chine, xvii
Universal Windows Plat-
form requirement, xvii, 
329
Windows 10, xiv, xvii, 
141
Windows Mobile, ix
Windows Phone
about, 141
emulators, xvii
Pivot control, 158
requirements, xvii
versions, xiv
Xamarin, xv
Windows Store, syncing
roaming data storage, 165
world-clock app, 10–49
about, 10
application cache, 32, 
36–40
business-logic classes,
14–20
caching data for offline
use, 32–40
creating clocks, 21–27
debugging with desktop
browser, 10
dependency manage-
ment, 12–14
displaying current time,
22
endpoint, 3
exercises, 20, 31, 47
Index • 345

loading like native app,
40
managing clock list, 28–
31
mobile version, 32, 40–47
project structure, 11
requirements, xiii
responsive design, 41–47
saving clocks locally, 36
schedule, 11
setup, 11–20
showing the time, 16
styling, 41–47
templates for list items,
28–30
time zones, managing,
17–20
user interface, 21–31, 40–
47
view controller, 25–27
web storage, 32–36
X
x86 architecture, 186
x:Bind, 169
x:Key property, 156
Xamarin, see also calculator
app
about, xv, 229
Android support, 240
autocompletion, 330
C# syntax, 231
exercises, 249, 266, 278
Objective-C syntax, 232
requirements, xvi
resources, 240, 243
solutions, 231–232, 266
strengths and weakness-
es, 279, 330–331
testing, 231, 250, 252
Xamarin Studio
calculator app, 231–240, 
250, 266
Mac support, 279
tests, 250
Xamarin.Forms
about, xvi, 331
cross-platform calculator
app, 266–278
user interface, building,
266–272
wiring model, 272–275
XAML
about, 270
calculator app, 268, 270–
272
detail view for stock-
quote app, 169
event handlers, creating,
167
exercises, 151
stock-quote app, 142, 
144
Xamarin.Forms, 268, 
270–272
Xcode, see also weather app
Auto Layout warnings, 58
companion editor, 59
creating projects, 53
disadvantages, 99
integration, 328
for iOS, xiii
iOS Simulator, xvii
React Native, xvi, 284–
285
RubyMotion, xv
storyboards, 55
Xamarin, xvi, 232
XML, see also XAML
Android advantages, 328
Android interface defini-
tion, 118–126
Android Studio layout
file, 104
menu definition, 203
to-do app, 199, 203
Y
Yahoo! APIs
currency conversion, 4
stock-quote app, 5
weather app, 3
Index • 346

Put the “Fun” in Functional
Elixir 1.2 puts the “fun” back into functional programming, on top of the robust, battle-
tested, industrial-strength environment of Erlang. Add in the unparalleled beauty and ease
of the Phoenix web framework, and enjoy the web again!
Programming Elixir 1.2
You want to explore functional programming, but are
put off by the academic feel (tell me about monads just
one more time). You know you need concurrent appli-
cations, but also know these are almost impossible to
get right. Meet Elixir, a functional, concurrent language
built on the rock-solid Erlang VM. Elixir’s pragmatic
syntax and built-in support for metaprogramming will
make you productive and keep you interested for the
long haul. This book is the introduction to Elixir for
experienced programmers.
Dave Thomas
(352 pages) ISBN: 9781680501667. $38
https://pragprog.com/book/elixir12
Programming Phoenix
Don’t accept the compromise between fast and beauti-
ful: you can have it all. Phoenix creator Chris McCord,
Elixir creator José Valim, and award-winning author
Bruce Tate walk you through building an application
that’s fast and reliable. At every step, you’ll learn from
the Phoenix creators not just what to do, but why.
Packed with insider insights, this definitive guide will
be your constant companion in your journey from
Phoenix novice to expert, as you build the next gener-
ation of web applications.
Chris McCord, Bruce Tate, and José Valim
(298 pages) ISBN: 9781680501452. $34
https://pragprog.com/book/phoenix

Secure and Better JavaScript
Secure your Node applications and make writing JavaScript easier and more productive.
Secure Your Node.js Web Application
Cyber-criminals have your web applications in their
crosshairs. They search for and exploit common secu-
rity mistakes in your web application to steal user data.
Learn how you can secure your Node.js applications,
database and web server to avoid these security holes.
Discover the primary attack vectors against web appli-
cations, and implement security best practices and
effective countermeasures. Coding securely will make
you a stronger web developer and analyst, and you’ll
protect your users.
Karl Düüna
(230 pages) ISBN: 9781680500851. $36
https://pragprog.com/book/kdnodesec
CoffeeScript
Over the last five years, CoffeeScript has taken the web
development world by storm. With the humble motto
“It’s just JavaScript,” CoffeeScript provides all the
power of the JavaScript language in a friendly and ele-
gant package. This extensively revised and updated
new edition includes an all-new project to demonstrate
CoffeeScript in action, both in the browser and on a
Node.js server. There’s no faster way to learn to write
a modern web application.
Trevor Burnham
(124 pages) ISBN: 9781941222263. $29
https://pragprog.com/book/tbcoffee2

Exercises and Teams
From exercises to make you a better programmer to techniques for creating better teams,
we’ve got you covered.
Exercises for Programmers
When you write software, you need to be at the top of
your game. Great programmers practice to keep their
skills sharp. Get sharp and stay sharp with more than
fifty practice exercises rooted in real-world scenarios.
If you’re a new programmer, these challenges will help
you learn what you need to break into the field, and if
you’re a seasoned pro, you can use these exercises to
learn that hot new language for your next gig.
Brian P. Hogan
(118 pages) ISBN: 9781680501223. $24
https://pragprog.com/book/bhwb
Creating Great Teams
People are happiest and most productive if they can
choose what they work on and who they work with.
Self-selecting teams give people that choice. Build well-
designed and efficient teams to get the most out of your
organization, with step-by-step instructions on how to
set up teams quickly and efficiently. You’ll create a
process that works for you, whether you need to form
teams from scratch, improve the design of existing
teams, or are on the verge of a big team re-shuffle.
Sandy Mamoli and David Mole
(102 pages) ISBN: 9781680501285. $17
https://pragprog.com/book/mmteams

The Pragmatic Bookshelf
The Pragmatic Bookshelf features books written by developers for developers. The titles
continue the well-known Pragmatic Programmer style and continue to garner awards and
rave reviews. As development gets more and more difficult, the Pragmatic Programmers will
be there with more titles and products to help you stay on top of your game.
Visit Us Online
This Book’s Home Page
https://pragprog.com/book/7apps
Source code from this book, errata, and other resources. Come give us feedback, too!
Register for Updates
https://pragprog.com/updates
Be notified when updates and new books become available.
Join the Community
https://pragprog.com/community
Read our weblogs, join our online discussions, participate in our mailing list, interact with
our wiki, and benefit from the experience of other Pragmatic Programmers.
New and Noteworthy
https://pragprog.com/news
Check out the latest pragmatic developments, new titles and other offerings.
Buy the Book
If you liked this eBook, perhaps you’d like to have a paper copy of the book. It’s available
for purchase at our store: https://pragprog.com/book/7apps
Contact Us
https://pragprog.com/catalog
Online Orders:
support@pragprog.com
Customer Service:
translations@pragprog.com
International Rights:
academic@pragprog.com
Academic Use:
http://write-for-us.pragprog.com
Write for Us:
+1 800-699-7764
Or Call:

