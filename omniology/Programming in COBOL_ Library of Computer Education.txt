LIBRARY OF COMPUTER EDUCATION ADVISORY BOARD 
Anthony Chandor, Chairman 
L. Barton Alexander 
P. D. Atkinson 
Professor Ν. V. Findler 
Dr. Robert S. Ledley 
A. E. McDonald 
R. R. Waller 
R. E. Woodall 

Programming in 
COBOL 
BY 
G. T. LANCASTER, B.Sc. (Economics) 
Systems Consultant, Group Computer Consultant's 
Department, 
Dunlop Ltd. 
P E R G A M O N PRESS 
OXFORD 
· 
NEW YORK 
· 
TORONTO 
SYDNEY 
· 
BRAUNSCHWEIG 

Pergamon Press Ltd., Headington Hill Hall, Oxford 
Pergamon Press Inc., Maxwell House, Fairview Park, Elmsford, 
New York 10523 
Pergamon of Canada Ltd., 207 Queen's Quay West, Toronto 1 
Pergamon Press (Aust.) Pty. Ltd., 19a Boundary Street, 
Rushcutters Bay, N.S.W. 2011, Australia 
Vieweg & Sohn GmbH, Burgplatz 1, Braunschweig 
Copyright © 1972 G. T. Lancaster 
All Rights Reserved. No part of this publication may be 
reproduced, 
stored in a retrieval system, or transmitted, 
in any form or by any 
means, electronic, mechanical, photocopying, 
recording or otherwise, 
without the prior permission 
of Pergamon Press 
Ltd. 
First edition 1972 
Library of Congress Catalog Card No. 72-151189 
Printed in Great Britain by A. Wheaton & Co., 
Exeter 
08 016384 X (flexicover) 

Introduction 
THIS book has been designed for those who, because of circumstances or 
lack of time, cannot avail themselves of manufacturers' or technical college 
courses. These will include experienced computer professionals who are 
acquainted with other programming languages but who cannot program in 
COBOL. The book will also be suitable for university or diploma students 
taking a course in computer science or allied subject or a student wishing 
to qualify for membership of the British Computer Society for whom the 
study of COBOL is a subject. The book implies a knowledge of computers— 
how they work and how they are programmed. Only where it is relevant 
to the section have I mentioned how the computer and its peripherals 
work. I have sought only to teach the reader the basic COBOL language. 
The book is not a teach-yourself book in the accepted sense, but there 
are questions to be answered after most chapters. The intelligent reader 
will be able to use the questions to make sure he understands all the princi-
ples covered. I have included only those COBOL facilities which I believe are 
relevant to a basic understanding of the language. All errors and omissions 
are the author's. 
I would hope that after reading the book the reader would be able to 
write programs in COBOL but must stress that the reader should use the 
compiler manual for the machine on which it is to be run. There are two 
full programs with suggested answers at the end of the book which the 
reader may like to try. The suggested answers also serve as illustrations of 
complete COBOL programs. 
I have used throughout the book international Computers Ltd. 1900 
series COBOL. I have done this to give the book a uniform structure, COBOL 
is, as I must emphasize, basically the same no matter which compiler is 
used, but there are a few minor differences. To attempt to cover all these 
details would be impossible, but to generalize would be unfair to the reader. 
Τ have indicated where these differences are in discussing the relevant 
sections. I have also used International Computers Ltd. 1900 series COBOL 
vii 

I N T R O D U C T I O N 
because I think it is an advanced and comprehensive version, with a wide 
range of the relevant COBOL features and a comprehensive range of associ-
ated software. I would like to thank International Computers Ltd. for their 
kindness in allowing me to use their version of the language. 
I would also like to thank Mrs. Julie Whalley and Mr. Peter Kenyon for 
checking the final script. 
viii 

Acknowledgement 
THE following acknowledgement is reprinted from the COBOL 1965 report issued by the 
United States Department of Defense. 
Any organization interested in reproducing the COBOL report and specification in 
whole or in part, using ideas taken from this report as the basis for an instruction 
manual or for any other purpose is free to do so. However, all such organizations 
are requested to reproduce this section as part of the introduction to the document. 
Those using a short passage, as in a book review, are requested to mention COBOL in 
acknowledgement of the source, but need not quote this entire section. 
COBOL is an industry language and is not the property of any company or group 
of companies or of any organization or group of organizations. 
No warranty, expressed or implied, is made by any contributor or by the COBOL 
Committee as to the accuracy and functioning of the programming system and 
language. Moreover, no responsibility is assumed by any contributor, or by the 
committee in connection therewith. 
Procedures have been established for the maintenance of COBOL. Enquiries 
concerning the procedures for proposing changes should be directed to the Executive 
Committee of the Conference on Data Systems Languages. 
The authors and copyright holders of the copyrighted material used herein 
FLOw-MATic (Trademark for Sperry Rand Corporation). Programming for the 
Univac (R) I and II, Data Automation Systems copyrighted 1958, 1959, by Sperry 
Rand Corporation; I.B.M. Commercial Translator Form No F28-8013, copy-
righted 1959 by I.B.M. ; FACT, DSI 27A5260-2760, copyrighted 1960 by Minne-
apolis-Honeywell, have specifically authorized the use of this material in whole or 
in part, in the COBOL specifications. Such authorization extends to the reproduction 
and use of COBOL specifications in programming manuals or similar publications. 
ix 

C H A P T E R I 
Why COBOL? 
ELECTRONIC digital computers are capable of performing many thousands 
of operations in a matter of seconds. The operations vary from simple 
arithmetic instructions, tests about the true/false condition of operands 
through to instructions to input or to output data. Computers can either 
compute data, that is perform many calculations or else process data, 
making tests on it, moving it from one area to another, and printing out 
the final conclusions. This wide variety of functions has led to computers 
being used for many different purposes ranging from scientific computing 
activities to commercial data processing. 
Industrial and commercial organizations process, whether they like it or 
not, large amounts of paper which are held usually in a file of one kind or 
another. These pieces of paper relate, of course, in some way to the physical 
process carried out by the organization. Warehouse staff, for example, 
have files labelled perhaps "stock files", holding information about goods 
stored within the warehouse. Within this stock file will be records, each 
record relating to a particular unit of stock. As goods are issued or received, 
so the records within the file are adjusted accordingly. The warehouse 
staff may, of course, have more than one file, depending on the complexity 
of the business or the same information held on different files in different 
offices. Whatever the case may be, the principle remains the same—infor-
mation held on records within files. Other systems within an organization 
will operate in much the same way. Purchasing systems will have files 
relating to purchases made on behalf of the company. The accountancy 
system will have files perhaps called ledgers, but still files in which the 
fiscal transactions made by the company will be recorded, adjusted, 
amended when necessary, as the situation changes. 
When these systems are computerized, the same basic operations will 
still need to be done. The systems analyst may want the operation carried 
1 

P R O G R A M M I N G IN 
C O B O L 
2 
out in a different order, using different forms, information stored in a 
new manner, but he will still be processing files. The units or records within 
the computer system will be held on file and each record will be basically 
the same as the others. These units will be inputed to the system in a 
computer readable form, punched cards, or paper tape, and the files stored 
on magnetic tape or disc as a series of magnetized particles, but the infor-
mation will still be regarded as held in files. Once the data has been fed into 
the computer, the user requires comparatively few calculations or tests 
before the results are either printed out or stored away. The industrial 
computer user requires then a programming language which facilitates 
the easy manipulation of these files and records, COBOL is a language that 
aims to provide these facilities. 
The scientific user, on the other hand, inputs only small amounts of data 
with comparatively few results produced but with a large amount of 
computing required for each item of data. His demands are for large 
"number-crunching" machines and a programming language which will 
handle formulae and various mathematical expressions. FORTRAN and 
ALGOL are two languages with these particular facilities. 
The basic computer language is a machine code language, usually 
referred to as a low-level language, which is designed by the manufacturers 
for a particular computer. It is designed in such a way as to give maximum 
efficiency to that particular computer. These languages are usually of a 
numerical nature, and every small step taken by the computer must be 
incorporated within the program. In the early days of computing, and until 
fairly recently, these were the only types of computer languages available 
to commercial users. The user had to adapt himself, no matter how incon-
venient this was, to the requirements of the machine code. These machine 
codes were difficult for human beings to master in the first place, and slow 
and cumbersome to use once they had been mastered. Programmers had 
to have special abilities, usually with a mathematical bias, and spent exces-
sive amounts of time writing programs. Worse than this, every time the 
user decided to change his machine he would have to rewrite all his 
programs written so far, as machine codes differed from computer to com-
puter. Industry, as you can realize, does not take kindly to conditions such 
as these, and takes a dim view—quite rightly—of expensive pieces of hard-
ware sitting round under-utilized waiting for programs to be written for it. 
These difficulties had been realized for many years by computer pro-
fessionals and they had been campaigning for an ideal commercial language 

W H Y 
C O B O L ? 
which would enable industry to write efficient programs as quickly as 
possible. With this in mind the United States of America Department for 
Defense in 1959 set up a working party of computer experts from 
companies who had already attempted to devise such a language. Their 
solution to the problem was the programming language COBOL (Common 
Business Oriented Language). 
The chief aim of the group was a computer language which would be 
compatible between different computers and also one that could be written 
in "man-sensible" English using everyday words, which clearly illustrated 
the function to be performed, COBOL is not patented, and all the manu-
facturers have been encouraged to write COBOL compilers for their own 
computers. The maintenance and future development of the language was 
placed under the auspices of the Conference in Data Systems Languages 
(CODASYL). 
No one is suggesting that COBOL in its early days was a complete success, 
but it was a step in the right direction. It was, unfortunately, compared 
with the machine code languages, rather inefficient and wasteful of com-
puter time and core storage. The language was revised giving rise to 
COBOL 61 and COBOL 65, both of which were improvements. Now it is 
claimed that COBOL 65 is 90 per cent efficient compared with machine code 
languages. It is now far more popular and more extensively used. The 
language is continually under revision, but the basic language will always 
remain the same. It could be argued that this is still not good enough, but 
I think it goes a long way towards meeting the requirements of computer 
users. There are still some problems with any conversion from one machine 
to another, but these are considerably less than have been the case with 
machine code languages and assembler languages. As a computer pro-
fessional I look forward to it being improved so that we get the maximum 
possible benefits from our computers. 
It is difficult to foresee what may happen in the future, but the present 
trends suggest that computer users are realizing that the major problems 
with commercial computer systems are systems problems and not pro-
gramming problems, COBOL has helped, I am sure, in this trend, and will 
continue to do so. A recent survey shows that 75 per cent of all production 
control applications are written in COBOL. I think that this trend will 
continue, and that as more organizations attempt to computerize their 
production areas, they will use COBOL more and more. It will also be used 
for accounting, payroll, invoicing, stock control, etc., routines, as these 
3 

P R O G R A M M I N G IN 
C O B O L 
4 
are mainly file-processing jobs. I would think that we shall see over the 
next five years a rapid expansion in the use of COBOL as a programming 
language by computer users. 
W H A T 
H A P P E N S 
The first task of the programmer, once he has been allocated a program 
to write, is to write the COBOL source program. This is written in "man-
sensible" English, using such expressions as ADD, MOVE which clearly 
indicate the functions that the programmer wishes to carry out. These 
statements, although they are in ordinary English prose, have still to be 
written according to certain strict rules which must always be adhered to. 
The programmer does not have the same freedom as he does in writing 
normal everyday English. These COBOL source program statements are then 
punched into punched cards or paper tape. 
The source program goes first through a compilation stage when the 
COBOL compiler supplied and written by the computer manufacturer con-
verts the source program into an object program. The compiler is a master 
program or translator. It checks the source program statements first of all 
for syntax errors, printing out error messages for statements that are 
incorrect. The compiler does not check for the programmer's logical errors. 
Once the programmer believes his program is syntactically correct, it is 
put through a consolidation stage which converts the original source 
program statements into the appropriate machine code instructions: one 
source program statement giving rise to several machine code instructions. 
Once the program is complete and logically correct, it is normally stored 
away on magnetic tape or disc. It is the object program that is stored and is 
therefore in machine code form. The interface, then, between the 
programmer and the computer is done by the compiler. The source 
program is written in the format most appropriate for human beings, 
whereas the final object program is in a format most appropriate for the 
computer. The programmer no longer has to adapt himself to the peculi-
arities of the computer. 
A D V A N T A G E S 
O F 
C O B O L 
The main advantages of COBOL are, in my opinion, as follows. 
1. Compatability between computers so that programs written for one 

W H Y 
C O B O L ? 
5 
computer can be run on another with only minor modifications, 
providing a COBOL compiler is available for that computer. 
2. COBOL programs are written in precise terms in every-day English 
and so can be easily followed by another programmer. This means 
that another programmer can be asked to finish a program with the 
minimum loss of time. 
3. Documentation, which is extremely important in large and expanding 
computer installations, is immediately improved. This means that the 
relationships between programmers and other computer personnel is 
also improved. 
4. Terminology is standardized and is more easily understood by non-
technical laymen. This improves the communication between the 
computer department and user department. 
5. Computer users have a greater freedom of choice between manu-
facturers and are able to have either different computers within the 
one organization or to replace an existing machine by a completely 
different make. The same program, with only minor modifications, 
may be used for these different computers. 
6. Programmers do not need to be extensively retrained every time the 
organization changes its computer if they have mastered COBOL and 
there is a compiler available. 
7. In the past, when organizations have changed computers, extensive 
reprogramming has been necessary, with COBOL this is no longer so. 

C H A P T E R 2 
COBOL Language and Structure 
S T R U C T U R E 
WITH every program, no matter in what language the program is being 
written, there are four distinct parts to it. First of all the program is given 
a name and identified. Secondly, the computer and computer peripheral 
devices to be used are allocated. Thirdly, the input and output data is 
specified, so that the program can recognize where the data fields are, their 
length, and any special properties they may have. The fourth function is to 
process or manipulate data according to the wishes of the programmer. 
With some program languages these four tasks may not be as distinctly 
sectionalized as they are in COBOL, but they are always specified. 
COBOL is split up into four major divisions corresponding to the four 
functions as above. They are written in the following order: 
1. Identification division. 
2. Environment division. 
3. Data division. 
4. Procedure division. 
The order cannot be changed, and whilst they are of equal importance, the 
identification and environment divisions are relatively short. 
Identification division identifies and gives a name to the source program. 
This division is totally machine-independent, but as the division does not 
produce any object code, this is not of any real importance. 
Environment division describes the configuration on which the source 
program is to be compiled and the relationship between the data files and 
the input-output peripherals. The environment division is totally machine-
dependent, as the parts of the program that refer to specific hardware 
peripherals are specified here. When, therefore, the program is rewritten 
6 

C O B O L L A N G U A G E A N D 
S T R U C T U R E 
blank or space 
V 
pound sign 
£ 
minus sign or hyphen 
— 
dollar sign 
% 
plus sign 
+ 
equal sign 
= 
check protection symbol * 
quotation mark 
left parenthesis 
( 
semi colon 
> 
right parenthesis 
) 
"greater than" 
> 
comma 
"less than" 
< 
decimal point or period 
7 
for another computer, this division at least must be partly rewritten. As, 
however, the division at the most is only three or four paragraphs in length, 
this represents only a minor problem for the programmer. 
Data division describes the files and data in the most precise detail. 
These are the files that are to be processed by the procedure division. Again, 
the data division is machine-independent, although a few minor alterations 
may be necessary if the type of computer is changed. 
Procedure division describes the procedures within the program which act 
on and deal with the files specified in the data division. This is the division 
where the action takes place. Apart from only very minor changes which 
may be necessary, this division is machine-independent and will be con-
verted from one computer to another without too much difficulty. 
Each division may be subdivided into sections or paragraphs, depending 
on the particular division. The section name may be fixed or may in some 
divisions be chosen by the programmer. Paragraphs are divided into one 
or more sentences which make up a coherent whole. Every section or 
paragraph name must be unique within that particular program and must 
never be the same as a data or condition name. Each division must be 
completed before the next one is begun. 
C O B O L 
C H A R A C T E R 
S E T 
The COBOL character set is composed of the following characters, which 
must be used for the source program. 
Numerals: 
0-9 
Alphabet: 
A - Z 
Special characters : 

P R O G R A M M I N G IN 
C O B O L 
F I X E D 
E L E M E N T S 
O F 
C O B O L 
These are elements that are fixed and which the programmer cannot 
alter in any way whatsoever no matter how much he may feel like it at 
times. 
Keywords 
These are words such as ADD, READ, DIVISION which have built-in 
meanings for the compiler. These words indicate that certain operations 
are to be done by the program. 
A full list is given in the Appendix. 
Optional Words 
These are words that may be written into the program to make it appear 
more like normal English prose. The compiler ignores them, apart from 
printing them out, when listing the program. 
A full list of examples is given in the Appendix. 
Examples 
ADVANCING 
THEN 
WHEN 
Punctuation 
Full stop. A full stop or period is used to complete a heading, paragraph, 
or sentence. It must be followed by at least one space. 
Semicolon and comma. Both a semicolon and a comma may be written 
between two basic elements and must be followed by at least one space. 
Both a semicolon and a comma are ignored by the compiler. 
Left parenthesis. The left parenthesis need not be preceded or followed 
by a space. 
Right parenthesis. The right parenthesis need not be preceded by a space 
but it must be followed by one unless the following element is one which 
need not be preceded by a space, such as a period. 
8 

C O B O L L A N G U A G E A N D 
S T R U C T U R E 
E L E M E N T S 
C H O S E N 
B Y 
T H E 
P R O G R A M M E R 
These are words, elements, which the programmer can choose for 
himself, providing they conform with certain basic rules laid down by the 
compiler. 
Data Names 
These are file names, record names which are chosen by the programmer 
to identify the data he wishes to process. These data names may be up to 
thirty characters in length chosen from the set: 
A-Z 
0-9 
and hyphen 
At least one letter must be alphabetic and the name must neither begin 
nor end with a hyphen. It must not be a RESERVED WORD (see 
the Appendix). 
It is sensible, in my opinion, when choosing data names to choose ones 
which give a clear idea of the contents of the file or record. 
Examples 
ORDER-INPUT 
WAGES-FILE 
GROSS-TOTAL 
rather than something obscure such as 
A-FILE 
Anyone else reading the program afterwards will be able to follow what the 
programmer is doing more easily. 
Non-numeric Literals 
A non-numeric literal, such as "stock account", is a string of characters 
bounded by quotation marks. The literal comprises of every character 
within the quotation marks, including spaces, and the literal may be up to 
120 characters in length. The literal may include a string of characters or 
a word, which might be a keyword or be a different basic element of COBOL. 
9 

P R O G R A M M I N G IN 
C O B O L 
Examples 
"WAGES RECORDS" 
"GENERAL PROCEDURES" 
"PRINT OUT OF STOCK RECORDS" 
"SALES DIVISION" 
Numeric Literals 
A numeric literal such as +103.65 may also be included in the program 
if it is desired to do an arithmetic sum using a constant. The numeric 
literal must have at least one numeric character and, naturally, must 
contain no alphabetic characters. It must also never be enclosed in quota-
tion marks. "+103.65" is a non-numeric literal and is not the same as 
+ 103.65. 
Any character from the following set may be used: 
0-9 
Plus symbol 
+ 
Minus symbol 
— 
Decimal point 
If the plus or minus symbols ( + or —) are used they must be the first 
character and must only appear once. Only one decimal point may appear, 
and this must not be the last character. 
Examples 
10 
+201.4 
-.0065 
Procedure Names 
These are section names and paragraph names, within the procedure 
division, that are invented by the programmer. A section is composed of a 
group of paragraphs, which makes a coherent whole. A paragraph is 
similar being a group of sentences, which in themselves are also a coherent 
whole. Procedure names must not be more than thirty characters in length 
10 

C O B O L L A N G U A G E A N D 
S T R U C T U R E 
and may be a string of numeric characters (set 0-9) or a string of alpha-
numeric characters (set 0-9, A-Z, and hyphen). 
Examples 
123 
PARA-1 
BEGIN 
SECTION-8 
MULTIPLICATION-SECTION 
These may be used in the program. These figurative constants are : 
Examples of how these constants may be used: 
1. MOVE SPACES TO data-name. 
Here spaces will be placed in the data name specified. 
2. DISPLAY QUOTES "ERROR MESSAGE" QUOTES. 
In this example the message "ERROR MESSAGE" will be printed out 
on the console with quotation marks. Without the figurative constants 
QUOTES, the quotation marks would not be printed. The rest of these 
examples, MOVE, DISPLAY, etc., will be explained more fully later. 
When a programmer defines a name it may not be unique within the 
program. When it is referred to, however, it must be qualified in such a 
way as to make it clear which is being referred to. For example, the program-
Figurative Constants 
ZERO 
ZEROS 
ZEROES 
SPACE 
SPACES 
HIGH-VALUES 
LOWER-BOUND 
LOWER-BOUNDS 
LOW-VALUE 
LOW-VALUES 
QUOTE 
QUOTES 
ALL 
UPPER-BOUND 
UPPER-BOUNDS 
HIGH-VALUE 
Qualifying Words 
11 

P R O G R A M M I N G IN 
C O B O L 
mer may have two records, Stock-in and Stock-out, both of which have a 
subfield called Code. The format for accessing either field is: 
Format 
(
0 F 1 
Stock-in 
Code 
UN J 
Stock-out 
C O B O L 
S P E C I F I C A T I O N 
S H E E T 
COBOL Specification sheets are split into four sections: 
Columns 1-6 
Sequence number 
Column 7 
Continuation indicator 
Columns 8-72 
Program text 
Columns 73-80 
Identification sequence 
As there are eighty columns to a punched card, it is obvious that one 
line of a COBOL sheet is equal to a punched card, although I would hasten 
to add that programs may also be punched on to paper tape. 
Sequence Number 
Each line of the program may be numbered, and, if so, must be numbered 
in ascending sequence. If the programmer does not sequence the program, 
the compiler will sequence each line and print out the number allocated 
against each line. If the numbers are not in ascending sequence, the 
compiler will print out an error message, but will still include the offending 
line in the program. 
I have always found, personally, that it is far better to sequence programs 
than not to do so, as program errors can then be quickly identified. I 
would also recommend that the sequencing be done in hundreds. 
12 

C O B O L L A N G U A G E A N D 
S T R U C T U R E 
13 
Example 
000100 
000200 
000300 
000400 
so that the programmer may insert extra lines and extra lines within extra 
lines should he wish to do so, without having to renumber every line 
again. 
Zeros and blanks are treated in exactly the same way. 
Continuation Indicator 
The continuation indicator, as in every-day English, is the hyphen 
symbol and is written in column 7. This is used when a word does not end 
at column 72 on the previous line but continues on to the next line. It 
should be noted that the text of the continuation commences in column 12 
and not column 8. 
The continuation indicator is frequently used with non-numeric literals 
when such literals are used as headings on print-outs. The literals in these 
instances are frequently 120 characters in length and extend to more than 
one line on the sheet. Then the quotation marks as well as commencing the 
literal are also repeated in column 12 but are not counted as a character 
within the literal. 
Program Text 
Columns 8-72 are filled with the text of the program, although not all 
columns need be filled. Once a sentence has been concluded by a period, 
the rest of the columns may be left blank. 
Division headings, section names, and paragraph names all start at 
column 8. Sentences in all divisions start at column 12 or later, except in the 
data division, where they may start at column 8. 
Identification Sequence 
Columns 73-80 may be used to identify the program. The programmer 
may use any set of identifying symbols he likes, such as his own initials 
followed by a number. The identification sequence is for security reasons, 

P R O G R A M M I N G IN 
C O B O L 
so that there is some check against wrong cards being included in a 
program. 
If, however, the first line is identified, all succeeding lines must have the 
same identification. If they do not, the compiler will print out an error 
message although the line will still be included in the program. The 
programmer may not wish to use an identification sequence, in which 
case the columns are left blank and the compiler takes no action apart from 
checking that all cards have a blank identification sequence. 
Throughout the book I shall use the following standard notation in all 
the formats illustrating the various features of COBOL. This is the standard 
I.C.L. notation as illustrated in their 1900 series manuals. These formats 
are enclosed in a box. 
Words written in capital letters are reserved words, which may be 
further subdivided into keywords and optional words. Reserved words 
must not be used by the programmer for his own use as data names, etc. 
They must only be used in the context for which they are designed. 
Examples 
Keywords in the format notation are written in capital letters and are 
underlined. They must always be written when the functions of which they 
are part are used. The compiler will print-out error messages if they are 
not used or are incorrectly spelt. Of course, there is no need to underline 
the words when writing an actual source program. 
Examples 
N O T A T I O N 
Reserved Words 
DIVISION 
NUMERIC 
A D D 
MOVE 
ARE 
LINES 
A D D 
MOVE 
DIVISION 
GIVING 
14 

E v a i»ipl<a 
c Γ 
α. 
c ο/Sou 
/τ&3>Λ>η 
5hecfc 
Cobol 
title 
sheet number 
prOÇ)!cim Sheet 
programmer 
date 
Sequence No. 
^ 
| 
| 
identification 
1 
6 7 8 
11 12 
15 
20 
25 
30 
35 
40 
45 
50 
55 
60 
65 
70 72 73 75 
80 
15 

P R O G R A M M I N G IN 
C O B O L 
16 
Optional words. In the formats, if a word is in capitals and is not under-
lined, it is an optional reserved word and is used to give "readability" to 
the program. The programmer may or may not use them, as he wishes. If 
used, they must, of course, be spelt correctly. 
Examples 
ADVANCING 
A N D 
THEN 
Brackets 
When braces { } are used to enclose two or more words, a choice must 
be made from the options inside the braces. When material is enclosed in 
square brackets [ 
] the material is an option, which may be included or 
not as the situation demands. 
Periods 
Three periods . . . means that the preceding group may be used as many 
times as is necessary. 
Clarity 
Because of the mixture of alphabetic and numeric character when writing 
a COBOL program, it is up to the programmer to specify his program as 
clearly as possible. Letter I should be clearly distinguished from the 
number 1, letter Ο from the number 0 (normally by putting a stroke 
through one of them according to local convention), and letter Ζ from 
number 2. Punch girls will invariably choose the incorrect option—rightly 
so, if it is not clear. 

C H A P T E R 3 
Identification and Environment 
Divisions 
I D E N T I F I C A T I O N 
D I V I S I O N 
THE first of the four divisions of COBOL is the identification division, which 
is also the smallest and easiest to understand. This division merely informs 
the compiler of the name of the program that is to be translated. It will 
also print out at the listing stage any additional information that the 
programmer may wish to identify his program by. This additional informa-
tion can be very useful in a large organization for documentation and 
control purposes. 
The formal structure for the identification division is as follows. 
Format 
IDENTIFICATION DIVISION. 
PROGRAM-ID. Program name. 
Other information 
The only lines that are necessary in this division are the heading "identi-
fication division", which must commence at column 8 and end with a 
period and "program-id" starting at columns 8 or 12 followed by a period, 
then the program name. 
Program Name 
The program name must be six characters in length, the first of which 
must be alphabetic. The next three may be either alphabetic or numeric. 
17 

P R O G R A M M I N G IN 
C O B O L 
With some computers, where multi-programming facilities are available, 
the last two characters are the priority number assigned to that program 
and must therefore be numeric. 
Other Information 
After the "program-id" line, it is permissible to add other information to 
make the purpose of the program clearer. The COBOL compiler ignores 
any such information, but prints it out when the program is listed at 
compilation. This additional information may be as follows. 
Format 
[AUTHOR. 
Comment-paragraph.] 
[INSTALLATION. 
Comment-paragraph.] 
[DATE-WRITTEN. 
Comment-paragraph.] 
[DATE-COMPILED. 
Comment-paragraph.] 
[SECURITY. 
Comment-paragraph.] 
[REMARKS. 
Comment-paragraph.] 
Example 
IDENTIFICATION DIVISION. 
PROGRAM-ID. WAGE01. 
AUTHOR. G. T. LANCASTER. 
DATE-WRITTEN. 010171. 
REMARKS. THIS PROGRAM IS THE FIRST IN 
THE 
WAGES SUITE. 
E N V I R O N M E N T 
D I V I S I O N 
The second division is the environment division, which has a dual 
function to perform. The first is to allocate the computers which are to be 
used to compile the source program and to run the object program. The 
18 

I D E N T I F I C A T I O N A N D E N V I R O N M E N T 
D I V I S I O N S 
second function is to identify the particular hardware peripherals on which 
the files, as specified in the data division, are to be run. 
There are two sections to the environment division, which are, in order, 
the configuration section and the input-output section. 
Configuration Section 
Format 
ENVIRONMENT DIVISION. 
CONFIGURATION SECTION. 
SOURCE-COMPUTER. Computer name. 
OBJECT-COMPUTER. Computer name. 
MEMORY SIZE integer WORDS. 
[SPECIAL-NAMES. 
Special-names entry.] 
The 
headings 
"environment 
division", 
"configuration 
section", 
"source-computer", "object-computer", "special-names", all commence 
at column 8. The "source-computer" and "object-computer" headings 
are followed by a period, then a space, then the name of the computer. 
Example 
SOURCE-COMPUTER. 
ICL-1902 
Memory size is an assessment of the amount of core store area required 
by the object program. This assessment should be reasonably accurate, 
especially when the installation is using multi-programming facilities, 
otherwise the operating program or executive program will not process the 
program if there is insufficient core store available. This will, of course, 
lead to delays in processing. 
The special-names section is used to allocate particular mnemonic 
names to certain peripherals. 
19 

P R O G R A M M I N G IN 
C O B O L 
SPECIAL-NAMES, hardware-name integer IS mnemonic-name. 
SPECIAL-NAMES. CHANNEL-n IS mnemonic-name. 
SPECIAL-NAMES, 
hardware-name 
Ã ON STATUS IS condition-name. 
1 OFF STATUS IS condition-name. 
The mnemonic name then becomes a pseudonym for that particular 
hardware device. 
Examples 
1. 
SPECIAL-NAMES. 
CARD-PUNCH 1 IS MAN-OUT. 
2. 
SPECIAL-NAMES. 
CARD-READER ON STATUS IS 
CORRECT. 
Input-Output Section 
File-control paragraph. This paragraph allocates data files, as specified 
in the data division, to a particular input or output peripheral. The compiler 
then inputs or outputs files as required. 
Format 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT 
file-name-1 
ASSIGN 
TO 
integer-1 
TAPES 
hardware-name integer-2 
RESERVE 
1 
fAREA 
ALTERNATE 
NO I 
I AREAS | 
20 
Format 
1 
2 
3 

I D E N T I F I C A T I O N A N D E N V I R O N M E N T 
D I V I S I O N S 
The file-name referred to is the name allocated by the programmer to 
an input or output file. File-names will be discussed later under the data 
division chapters. The hardware-name descriptions are CARD-READER, 
PRINTER, etc., and refer to the names of the input or output peripherals 
attached to the computer. The format for these will depend on the compiler 
for the computer being used. 
The programmer may wish to allocate extra buffer areas to the peri-
pheral, in order to increase the speed of the peripheral, in addition to the 
standard ones. He does this by using the optional clause 
RESERVE 1 ALTERNATE AREA. 
after the name of the peripheral. 
Example-! 
SELECT CARD-IN-FILE ASSIGN CARD-READER 1 
RESERVE 1 ALTERNATE AREA. 
When writing a source program for a particular computer, special 
reference to the appropriate compiler manual should be made, especially 
for the environment division, as this does vary in a few details. This is 
because the environment division is more machine-dependent than the 
other division as it defines the hardware to be used. The basic essentials are 
standard, but a few additional clauses or variations may be necessary 
depending on the demands of the compiler or program being written. 
Example-2 
ENVIRONMENT DIVISION. 
CONFIGURATION SECTION. 
SOURCE-COMPUTER. 
ICL-1904. 
OBJECT-COMPUTER. 
ICL-1904. 
MEMORY SIZE 5000 WORDS. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT ORDER-FILE ASSIGN CARD-READER 1. 
SELECT PRINT-FILE ASSIGN PRINTER 1. 
SELECT MAG-FILE-1 ASSIGN 1 TAPES. 
21 

P R O G R A M M I N G IN 
C O B O L 
Example-2 illustrates a standard unsophisticated environment division. 
In the examples illustrating the identification and environment divisions, 
I have left several lines between the various sections in order to make it 
more readable. When punching the program, of course, the cards follow 
consecutively without any blank cards in between. The reader, in writing 
his own programs, may like to do the same, because filling every line can 
make a program almost impossible to read. 
Q U E S T I O N 
1. Write the identification and environment divisions for the following 
program INVO01, which has been written by J. Smith, on 10 September 
1969. The program is to process three files, one card input called IN-FILE-
1; one magnetic tape file called MAG-TAPE-1, and one output file on 
the line printer called PRINT-FILE. The source and object programs are 
being run on an I.C.L. 1903 computer. The program will be approximately 
8000 words in length. 
If you have any COBOL specification sheets, use them for your answers, 
otherwise use scrap paper, marking it with two arrows for columns 8 
and 12. 
A N S W E R 
1. IDENTIFICATION DIVISION. 
PROGRAM-ID. 
INVO01. 
AUTHOR. J. SMITH. 
DATE-WRITTEN. 
10. 09. 69. 
ENVIRONMENT DIVISION. 
CONFIGURATION SECTION. 
SOURCE-COMPUTER. 
ICL-1903. 
OBJECT-COMPUTER. 
ICL-1903. 
MEMORY SIZE 8000 WORDS. 
INPUT-OUTPUT SECTION. 
FILE-CONTROL. 
SELECT IN-FILE-1 ASSIGN CARD-READER 1. 
SELECT MAG-TAPE-1 ASSIGN 1 TAPES. 
SELECT PRINT-FILE-1 ASSIGN PRINTER 1. 
22 

C H A P T E R 4 
Procedure Division-
Arithmetic Verbs 
ALTHOUGH the procedure division is the last of the four divisions and 
follows the data division, we shall look at it before the data division. Once 
the procedure division has been understood, it makes it far easier to under-
stand the data division. When writing an actual source program, it is far 
better to specify the data division completely first and to flowchart the 
procedures to be used properly before specifying the procedure division. 
Otherwise the programmer will find himself making many logical errors. 
For our purpose, however, it is better that we look at the procedure division 
first. Occasionally, in explaining this division, I shall have to make reference 
to one or two points about the data division, but I shall explain these as we 
go along. The main point to remember is that we are manipulating files and 
records within files that have been specified precisely in the data division. 
Some readers may prefer to look at the data division first, in which case 
they may jump to the appropriate chapters. 
Sections 
If the program is very large or alternatively core storage at a premium, 
the procedure division may be subdivided into sections. Sections are given 
a unique name and may also be addressed as a coherent whole. Sections 
include an integral number of paragraphs. 
Examples 
CALCULATING-SECTION. 
SIXTH-SECTION. 
Section names must always commence at column 8. 
P . C . — I 
23 

P R O G R A M M I N G IN 
C O B O L 
Paragraphs 
The statements of the procedure division are grouped together into 
paragraphs, which may consist of one or more statements. Paragraphs are 
given a unique name and may, as we shall see later, be addressed as a 
complete entity. 
Examples 
BEGIN. 
PARA-1. 
PARAGRAPH-END. 
Paragraphs must always commence at column 8. 
Statements 
The procedure division is where the action takes place, where the 
program follows a set of procedures, acting on the data that is fed in after 
the program. The procedures are a series of statements, either imperative 
or conditional, which inform the computer that a certain kind of action is 
necessary. All statements begin with verbs (so called because they are 
analogous to verbs in English grammar) because they lead to action of one 
kind or another. 
Statements must always commence at column 12 and end with a period. 
When writing on the COBOL program sheets, it is much clearer if each 
statement is kept to a separate line. 
Example 
A D D STOCK-IN TO TOTAL-1. 
MOVE STOCK-IN TO STOCK-OUT. 
IF TOTAL-1 EQUALS 100 GO TO PARA-6. 
A statement, however, may follow another statement providing a space 
is left after the period or by using the optional reserved word A N D to 
join two statements. Personally, as in the example below, I think that when 
more than one statement per line is written, the ensuing program is much 
harder to decipher. Should there be an error in any of the statements, 
either by faulty programming or punching, it is much more difficult to 
correct. 
24 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
Example 
A D D STOCK-IN TO TOTAL-1, MOVE STOCK-IN TO 
STOCK-OUT A N D IF TOTAL-1 EQUALS 100 GO TO 
PARA-6. 
The first group of verbs that we shall concern ourselves with are the 
arithmetic verbs. Which, as one would expect, are basically all of the same 
format. 
A D D 
The first of the arithmetic verbs we shall examine is the A D D verb, 
which may be written in many ways but is basically of the following format. 
Format 
data-name-1 
A D D 
« 
• TO data-name-2. 
literal-1 
Examples 
1. 
A D D A T O B . 
2. 
A D D WAGE-RATE TO WAGE-RATE-1. 
3. 
A D D 1 TO COUNT. 
The size and format of each of these data-names have been clearly 
defined in the data division. For example, if WAGE-RATE contains 
four numeric digits and WAGE-RATE-1 five numeric digits, we will have 
specified both data-names as such in the data division. We can assume, 
then, that this has been done for the rest of the examples in this division. 
In the first example above the contents of location A will be added to the 
contents of location B. Whatever was stored in A before the addition will 
remain the same, but the contents of location Β will be altered. Β will now 
contain the sum of A plus B. 
Before 
After 
Example-l 
A 
1041 
1041 
Β 
27 
1068 
25 

P R O G R A M M I N G IN 
C O B O L 
Before 
After 
Example-2 
Wage-rate 
Wage-rate-1 
71 
29 
71 
100 
Example-3 
Count 
50 
The A D D verb need not be restricted to the addition of just two loca-
tions. The following example is perfectly correct: 
A D D 
A, 
B, 
C, 
TO 
D. 
In this example after the addition has taken place, the locations A, B, and 
C remain the same but D now contains the sum of A, B, and C. The 
programmer should remember that where commas are used a space should 
immediately follow it before the next data-name. 
There are, of course, numerous situations where it is not desirable to 
have the contents of the last data-name mutilated. 
In the example 
A D D A TO Â 
the programmer may wish to retain the contents of both locations. In 
which case the programmer invents a third location, C and uses the follow-
ing expression. 
Giving 
Format 
ADD J 
literal-1 
data-name-1 
data-name-2 
literal-2 
J . . .
 GIVING data-name-3 
In this format no matter what was in location C previously, it is now 
destroyed and replaced by the addition of A and B. 
26 
49 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
Examples 
1. 
ADD HOURS-1 HOURS-2 GIVING HOURS-3. 
2. 
ADD TOTAL-10 TOTAL-OUT GIVING GROSS-TOTAL. 
3. 
ADD A, B, C, D GIVING E. 
Before 
After 
Example-! 
Hours-1 
100 
100 
Hours-2 
200 
200 
Hours-3 
9999 
300 
Example-2 
Total 
+ 2 0 
+ 2 0 
Total-out 
- 3 0 
- 3 0 
Gross-total 
97 
- 2 0 
Example-3 
A 
1.62 
1.62 
Β 
3.47 
3.47 
C 
1.39 
1.39 
D 
0.01 
0.01 
Ε 
202.36 
6.49 
The GIVING clause may be used, not only with the A D D verb but with 
all the other arithmetic verbs, subtract, multiply, divide, which we shall 
look at later. 
Rounded 
For the moment we shall have to digress a little into the data division. 
When two locations, as we used above, A and Β have been added together, 
we may have decided to locate them finally in C. All three locations will 
have been defined in the data division but the final result depends on how 
C has been defined. If both A and Β are locations with two decimal places 
after the decimal point and C has only one place, the result in C will be 
truncated, that is the last decimal place will be lost. 
27 

P R O G R A M M I N G IN 
C O B O L 
Example 
A contains 36.29 
Β contains 47.19 
If we use the expression 
A D D A, Β GIVING C 
the result stored in C would be 83.4. The true result should be 83.48. 
There are many times when the programmer does not want the answer 
rounded down, which is what effectively happens with truncating. He 
may want the answer 83.5 storing in C, which is the correct result, to one 
decimal place. In such a case the programmer uses the following format. 
Format 
data-name-1 
data-name-2 Ί 
A D D -
[ . . . 
GIVING 
literal-1 
literal-2 
J 
data-name-n 
[ROUNDED] 
The method used by the compiler to arrive at this result is that it 
does first the full calculation, that is obtains the answer 83.48. Then the 
compiler adds 5 to the decimal place, after the one specified in the final 
location. In this instance 0.05 is added to arrive at 83.53 and then the 
compiler drops the last digit, in this case 3, i.e. 83.5^. The result now 
stored in C is 83.5. 
It is obvious, then, that when calculations are being performed, that 
the programmer takes the greatest care in defining the final locations to 
ensure that he obtains the result he desires. We shall see with the other 
verbs that the programmer should be meticulous in defining data, espe-
cially when this data is being transferred from location to location. The 
receiving location must be correctly defined, in accordance with the wishes 
of the programmer. 
On Size Error 
There is another clause, the ON SIZE ERROR clause, which is similar 
to the ROUNDED clause. If there are more integral places in the result, 
28 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
Format 
f data-name-1 Ί 
data-name-2 
ADD \ 
I 
« 
• . . . GIVING 
[literal-1 
J 
literal-2 
data-name-n [ON SIZE ERROR any imperative statement.] 
The imperative statement is usually the GO TO (to be discussed later) 
verb with a paragraph name. Under this paragraph the programmer deals 
with the situation as he wishes. Perhaps by stopping the program or 
perhaps by moving the field to another location, that will be large enough, 
or by rejecting that input record and moving on to the next. 
Should there, therefore, be any possibility of an error occurring, as 
above, then the programmer should make allowances for it in his program 
by using the ON SIZE ERROR clause. 
The complete format for the A D D verb: 
Format 
ADD 
j
 data-name-
1 
!
 literal-1 
|
rdata-name-2 
I literal-2 
data-name-3 
GIVING 
data-name-4 
[ROUNDED] 
[ON SIZE ERROR 
any imperative statement.] 
29 
i.e. places to the left of the decimal point than in the location, assigned to 
the answer, the extra digits will be dropped, with disastrous results for the 
programmer, if the answer to a problem is 65732.26 and the result location 
has been defined as six characters in length, with two for the decimal places, 
then the answer stored will be 5732.26, a completely different result from 
the one intended. If the programmer knows that with certain locations 
this may happen, by using the ON SIZE ERROR he can forestall the 
disaster by taking the appropriate action in the paragraph branched to. 
The format for this clause is as follows. 

P R O G R A M M I N G IN 
C O B O L 
Subtract 
Format 
f data-name-Γ 
data-name-2] 
data-name-3 
SUBTRACT \ 
I . .. FROM* 
[literal-1 
literal-2 
J 
literal-3 
GIVING 
data-name-4 
[ROUNDED] 
[ON SIZE ERROR 
any imperative statement.] 
The SUBTRACT verb is similar to the A D D verb in that the last 
location name will be mutilated unless the GIVING clause is used and the 
result stored in another data-name. Both the ROUNDED and ON SIZE 
ERROR clauses may be used with the SUBTRACT verb and these work 
in exactly the same manner as when used with the A D D verb. 
Examples 
1. 
SUBTRACT A FROM B. 
2. 
SUBTRACT A, B, C, FROM D. 
3. 
SUBTRACT STOCK-IN 
FROM 
STOCK-OUT 
GIVING 
STOCK-HELD ROUNDED. 
4. 
SUBTRACT 15 FROM GROSS GIVING REMAiNDER ON 
SIZE ERROR GO TO PARA-1. 
Before 
After 
Example-l 
A 
113 
113 
Β 
203 
90 
Example-2 
A 
19 
19 
Β 
5 
5 
C 
6 
6 
D 
58 
28 
30 
Note that the R O U N D E D and ON SIZE ERROR clause have been 
shown in square brackets to denote that they are options. 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
Example-3 
STOCK-IN 
203.46 
203.46 
STOCK-OUT 
593.14 
593.14 
STOCK-HELD 
000.0 
389.7 
Example-4 
GROSS 
1000 
1000 
REMAINDER 
4726 
985 
In this last example, the ON SIZE ERROR clause would not be required, 
as there is no size error. The program would not branch to para-6. 
Multiply 
Format 
f data-name-Γ 
fdata-name-2] 
M U L T I P L Y \ 
• B Y J 
I G I V I N G data-name-3 
[literal-1 
[literal-2 
J 
[ R O U N D E D ] 
[ O N S I Z E E R R O R any imperative statement.] 
Again in format the MULTIPLY verb is the same as both the A D D and 
SUBTRACT verbs. The result, if the GIVING clause is not used, always 
goes into the second data-name, as you can see from the examples below. 
Examples 
1. 
MULTIPLY WAGE-RATE BY HOURS GIVING GROSS-
WAGE ROUNDED. 
2. 
MULTIPLY A BY B. 
3. 
MULTIPLY CODE-NO BY 6 GIVING INPUT-2. 
Before 
After 
Example A 
WAGE-RATE 
30.32 
30.32 
HOURS 
12 
12 
GROSS-WAGE 
1437.3 
363.8 
31 

P R O G R A M M I N G IN 
C O B O L 
Before 
After 
Example-2 
A 
18 
18 
Β 
2 
36 
Example-3 
CODE-NO 
4 
4 
INPUT-2 
- 1 3 
24 
D I V I D E 
Format 
fdate-name-l] 
data-name-2' 
DIVIDE \ 
JjNTO « 
•GIVING data-name-3 
[literal-1 
J 
literal-2 
[ROUNDED] 
[ON SIZE ERROR any imperative statement.] 
The format of the DIVIDE verb is DIVIDE . . . INTO . . . and not 
DIVIDE . . . BY . . . which cannot be used in any circumstances. This 
tends to be a rather common mistake made by many people at first. 
Examples 
1. 
DIVIDE 12 INTO GROSS. 
2. 
DIVIDE TOTAL-1 INTO TOTAL-2 GIVING NET-TOTAL 
ROUNDED. 
3. 
DIVIDE CODE-1 INTO 1000 GIVING CODE-2. 
Before 
After 
Example-l 
GROSS 
144 
12 
Example-2 
TOTAL-1 
101.1 
101.1 
TOTAL-2 
2436 
2436 
NET-TOTAL 
9999.9 
24.1 
32 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
Example-3 
CODE-1 
CODE-2 
10 
403 
10 
100 
Remainder 
The reader may have been wondering if there is a remainder option 
when the remainder is automatically calculated. The answer unfortunately 
is no. The programmer has to work it out for himself. This is not difficult, 
but it is a pity he has to do so. 
One method of doing this is as follows. 
DIVIDE TOTAL-1 INTO STOCK GIVING RESULT. 
MULTIPLY RESULT BY TOTAL-1 GIVING X. 
SUBTRACT X FROM STOCK GIVING REMAINDER. 
The location REMAINDER will now contain the remainder of the first 
statement. 
After statement-1 
TOTAL-1 contains 12 
STOCK 
contains 70 
RESULT 
contains 5 (if no decimal place specified) 
After statement-2 
X 
contains 60 
After statement-3 
REMAINDER contains 10 
The following are locations in program PAYR01 which have been 
defined in the data division as follows: 
Q U E S T I O N S 
Initial contents 
AMOUNT (one decimal place) 
STERLING (two decimal places) 
TOTAL (two decimal places) 
RATE-1 
RATE-2 
PRICE 
76.52 
91.37 
144.67 
199.9 
253103.21 
1000.00 
33 

P R O G R A M M I N G IN 
C O B O L 
Multiply hourly - pay 
by hours -1 
Answer in wage 
rounded to 3 
dec. places 
Para 2. 
Subtract tax-payable 
from wage 
Answer in net-wage 
Add net - wage 
to wage-to-date 
Add tax 
to tax-
-payable 
to - date 
FIG. 4 . 1 . 
34 
1. Add locations RATE-1, RATE-2, and PRICE, placing the result in 
location AMOUNT, showing the contents before and after. 
2. Deduct RATE-1 from PRICE, placing the result in AMOUNT (assume 
question 1 had been done) and show the contents before and after. 
3. Multiply PRICE and AMOUNT together and place the result in 
STERLING. If the result is too large for the location, continue the pro-
gram from paragraph "MISTAKE". Show contents before and after. 
4. Divide PRICE BY 12. 
5. Code the short piece of flowchart shown in Fig. 4.1. The paragraph 
names have been shown. 
Para 1. 
Add normal-hours to 
overtime - hours 
Answer in hours -1 

P R O C E D U R E D I V I S I O N - A R I T H M E T I C 
VERBS 
A N S W E R S 
1. A D D RATE-1, RATE-2, PRICE GIVING AMOUNT ROUNDED. 
Before 
After 
Rate-1 
76.52 
76.52 
Rate-2 
91.37 
91.37 
Price 
144.67 
144.67 
Amount 
199.9 
312.6 
2. SUBTRACT RATE-1 FROM PRICE GIVING 
AMOUNT 
ROUNDED 
Before 
After 
Rate-1 
76.52 
76.52 
Price 
144.67 
144.67 
Amount 
312.6 
68.2 
3. MULTIPLY PRICE BY A M O U N T GIVING 
STERLING 
R O U N D E D ON SIZE ERROR GO TO MISTAKE. 
Before 
After 
Price 
144.67 
144.67 
Amount 
68.2 
68.2 
Sterling 
253103.21 
9866.49 
4. DIVIDE 12 INTO PRICE. 
5. PARA-1. 
ADD NORMAL-HOURS OVERTIME-HOURS GIVING 
HOURS-1. 
MULTIPLY HOURLY-PAY BY HOURS-1 GIVING 
WAGE 
ROUNDED. 
SUBTRACT TAX-PAYABLE FROM WAGE 
GIVING 
Ν ET-WAGE. 
PARA-2. 
A D D NET-WAGE TO WAGE-TO-DATE. 
ADD TAX-PAYABLE TO TAX-TO-DATE. 
35 

C H A P T E R 5 
Procedure Division-
Move; Go to; Conditional Verbs 
As YOU know, if a computer could only add, multiply, subtract, and divide, 
it would be little more than a glorified comptometer no matter how quickly 
these could be done. The same applies, of course, to any programming 
language. It is the other verbs which make it a versatile language and COBOL 
has an array of versatile verbs. It is these that we shall now study. 
M O V E 
The first of these verbs that we shall look at is the MOVE verb, which 
transfers data from one storage location to another. 
The data stored in data-name-1 is transferred to data-name-2 but the 
data in data-name-1 remains as before the transfer. Whilst the use of the 
verb is basically extremely simple, great care must be taken to ensure that 
data-name-2 is compatible with data-name-1. We shall discuss the format 
of storage locations under the data division chapters, but essentially data-
name-2 must be large enough and of the same format as data-name-1, 
otherwise truncating will occur. 
Format 
MOVE 
É 
literal-1 
data-name-1 
I TO data-name-2 [data-name-3] . . . 
36 

P R O C E D U R E D I V I S I O N - M O V E ; G O 
T O 
Examples 
1. 
MOVE IN PUT-CODE TO OUTPUT-CODE. 
2. 
MOVE 10 TO DIVISOR. 
3. 
MOVE "WAGES RECORDS" TO PRINT-HEADING. 
Before 
After 
Example A 
INPUT-CODE 
3261 
3261 
OUTPUT-CODE 
1000 
3261 
Example-2 
DIVISOR 
0000 
0010 
If, however, in example-1 the location OUTPUT-CODE had been 
specified with only three digits, then the result in OUTPUT-CODE would 
have been 261. As with other verbs, it is the final locations which determine 
the nature of the results. Binary locations transferred to sterling locations 
will be converted automatically to sterling, and sterling locations to 
decimal. The programmer should, therefore, be extremely careful, that the 
locations have been specified exactly as he requires them. 
G O 
T O 
Statements in a COBOL source program are obeyed in sequence except 
when the programmer wishes to jump to a particular part of the program. 
The verb GO TO can be used to jump out of sequence. Frequently it is 
used in conjunction with conditional statements and the IF verb, as we 
shall see later in the chapter. The procedure name following a GO TO 
instruction must be a paragraph. 
Format 
GO TO 
paragraph-name-1. 
Examples 
1. 
GO TO FINAL-PARA. 
2. 
GO TO PARA-6. 
37 

P R O G R A M M I N G IN 
C O B O L 
Format 
" EXCEEDS 
IS GREATER THAN 
/data-name-1 \ 
IS NOT GREATER THAN 
/ data-name-2\ 
IF / literal-1 
IS LESS THAN 
IS NOT LESS THAN 
/ literal-2 
> 
\^condition-l J 
EQUALS 
IS EQUAL TO 
IS NOT EQUAL TO 
\condition-2 J 
Many of these relation tests are complementary and may be used in 
exactly the same circumstances. With some compilers the symbols < > = 
may also be used where appropriate. 
Examples 
1. 
IF RECORD-1 IS GREATER THAN RECORD-2 . . . 
2. 
IF CODE-Α IS NOT EQUAL TO 1 0 . . . 
3. 
IF TOTAL-2 IS LESS THAN 10000 . . . 
38 
C O N D I T I O N A L 
S T A T E M E N T S 
A N D 
T H E 
I F 
V E R B 
All languages have the facility to test various conditions and then to 
branch to a particular part of the program depending on the result. In 
COBOL the IF verb is used to test these conditions and the facilities in COBOL 
compare favourably with other languages. 
There are various types of conditions that can be tested by the IF verb, 
the first being the relation condition. 
Relation Condition 
Relation conditions cause two operands, data-names, literals, or con-
ditions to be compared with each other. 

P R O C E D U R E D I V I S I O N - M O V E ; G O 
T O 
Format 
/POSITIVE 
\ 
f data-name-1 
1 
1 
IF 
• IS [NOT] 
' NEGATIVE } . . . 
[condition-1 
J 
ZERO 
J 
These tests, of course, may only be applied to numeric data and therefore 
the data-names must be described as such in the data division. 
Examples 
1. 
IF NUMBER-IN IS NEGATIVE . . . 
2. 
IF SUB-TOTAL IS NOT ZERO . . . 
Class Condition 
Frequently during validation routines the programmer may wish to test 
if certain fields contain either only alphabetic characters or only numeric 
characters. This type of test in COBOL can be done by using class conditional 
statements. 
Format 
Γ NUMERIC 
1 
IF data-name-1 IS [NOT] 
... 
1
 ALPHABETIC J 
Examples 
1. 
IF NAME-1 IS NOT ALPHABETIC . . . 
2. 
IF RATE IS NUMERIC . . . 
39 
Sign Conditions 
With sign conditions we would be testing if a particular data-name was 
greater than, less than, or equal to zero. 

P R O G R A M M I N G IN 
C O B O L 
Conditional Names 
It is possible, as we shall see more fully in the data division, to give 
certain conditions names which will reduce the programming necessary 
to test if certain conditions arise. For example, we may have a sales file 
which is subdivided into three item sections—home, export, and re-export 
and the three sections coded as 1,2, and 3 respectively. During the program 
we may then wish to apply the following tests: 
IF ITEM-SECT IS EQUAL TO 1 GO TO HOME-PARA. 
IF ITEM-SECT IS EQUAL TO 2 GO TO EXPORT-PARA. 
IF ITEM-SECT IS EQUAL TO 3 GO TO RE-EXPORT-PARA. 
Instead of doing this, we could have specified condition names "home" 
"export", and "re-export" in the data division and given them their 
respective values. The programming would then have been : 
IF HOME GO TO HOME-PARA. 
IF EXPORT GO TO EXPORT-PARA. 
IF RE-EXPORT GO TO RE-EXPORT-PARA. 
In this particular instance, it would hardly have been worth the trouble. 
It would have been worth it, however, if we had wished to test a range 
of values. Supposing the above example had been as follows: 
IF ITEM-SECT (falls in range 1-9) GO TO HOME-PARA. 
IF ITEM-SECT (falls in range 10-19) GO TO EXPORT-PARA. 
IF ITEM-SECT (falls in range 20-29) GO TO RE-EXPORT-
PARA. 
To do this without using condition names a tremendous amount of tedious 
programming would have to be written, whereas with condition names this 
is fairly simple. Condition names are established as above, with "home" 
given values 1-9, "export" values 10-19, "re-export" values 20-29. The 
programming then is as it was earlier, but the action done "behind the 
scenes" is far more. 
IF HOME GO TO HOME-PARA. 
IF EXPORT GO TO EXPORT-PARA. 
IF RE-EXPORT GO TO RE-EXPORT-PARA. 
40 

P R O C E D U R E D I V I S I O N - M O V E ; G O T O 
How to specify these condition names is more fully illustrated under the 
data division chapter; here we are seeing how they are used in the pro-
cedure division. 
Until now we have been looking at the condition part of the conditional 
statements and the various forms that they can take. These have been 
simple, single conditions concerned with the relative size or content of a 
data-name, etc. It is possible in a full conditional statement to have more 
than one condition tested as we shall see below, to also tell the computer 
what steps to take both when the conditions are fulfilled and when they are 
not fulfilled. 
Full Format 
Examples 
1. 
IF WEEK-NO IS GREATER THAN 30 NEXT SENTENCE 
OTHERWISE MOVE "ILLEGAL WEEK N O " TO PRINT-1, 
MOVE WEEK-NO TO PRINT-2. 
2. 
IF CLAUSE-1 LESS THAN 10 GO TO PARA-6 ELSE GO TO 
ERROR-PARA. 
The reserved words ELSE and OTHERWISE are used in exactly the 
same way. It is also possible to have more complex nesting of conditions 
than the examples such as those above. It is possible for both statement-1 
and statement-2 to contain an IF statement, as in example 3. 
3. 
IF STOCK-1 EQUALS 1 IF STOCK-2 EQUALS 2 A D D 
STERLING-1 TO TOTAL-1 ELSE A D D STERLING-1 TO 
TOTAL-2 ELSE A D D STERLING-1 TO TOTAL-3. 
Full Conditional Statement 
IF condition THEN 
Statement-1 
º 
[OTHERWISE 
NEXT SENTENCE [ 
[ELSE 
{
statement-2 
NEXT SENTENCE 
41 

P R O G R A M M I N G IN 
C O B O L 
A N S W E R S 
1. MOVE VALUE-1 TO VALUE-OUT-1. 
MOVE VALUE-2 TO VALUE-OUT-2. 
MOVE VALUE-3 TO VALUE-OUT-3. 
GO TO PRINTING-PARA. 
2. 
FILE-PARA. 
MOVE FILE-NO TO FILE-WS. 
IF FILE-NO IS POSITIVE NEXT SENTENCE OTHERWISE 
GO TO ERROR-PARA. 
IF FILE-NO IS GREATER THAN 12 GO TO ERROR-PARA. 
MOVE FILE-WS TO PRINT-1. 
GO TO FILE-PARA. 
ERROR-PARA. 
MOVE "ILLEGAL FILE N U M B E R " TO PRINT-2. 
MOVE FILE-WS TO PRINT-3. 
GO TO FILE-PARA. 
It is possible to have a different answer from the above and the answer 
to still be correct. 
42 
In this example, if both STOCK-1 equals 1 and if STOCK-2 equals 2, 
then STERLING-1 is added to TOTAL-1. If, however, STOCK-1 equals 
1 but STOCK-2 does NOT equal 2, then STERLING-1 is added to 
TOTAL-2. If STOCK-1 does not equal 1, then STERLING-1 is added to 
TOTAL-3. 
As you can see from the above, COBOL conditional statements can be 
very flexible, and every possible situation is catered for. 
Q U E S T I O N S 
1. Write the COBOL program instructions, which will transfer data from 
locations VALUE-1, VALUE-2 and VALUE-3 to VALUE-OUT-1, 
VALUE-OUT-2 and VALUE-OUT-3 respectively. After transferring this 
data, branch the program to the printing paragraph of the program. 
2. Write the program for the flowchart Fig. 5.1. 

P R O C E D U R E D I V I S I O N - M O V E ; G O 
T O 
File- para 
Transfer file - no 
to file-WS 
.^file-no i s ^ s ^
 
N g 
\ 
not zero or ^ 
» 
^ s ^ n e g a t i v e / ^ 
I Yes 
^ / f i l e - n o i s \ .
 
N
o 
<^equal to or less^> 
^ 
^ x t h a n 1 2 y < 
Error - para 
Move 
"Illegal file number" 
to print - 2 
Move file - no 
to print -3 
Yes 
Transfer file-no 
to print - 1 
Go to file - para 
FiG. 5.1. 
43 

C H A P T E R 6 
Procedure Division—Open; 
Close; Read; Write; Accept; 
Display Verbs 
O P E N 
As I emphasized at the beginning of the book, COBOL regards the sources 
of input and output as FILES. It is in the procedure division that these 
files and records within files are manipulated. Therefore, before any action 
can be taken on a particular file, it must first be "opened" by using the 
OPEN verb. All the files being used by the programmer may be opened 
simultaneously and this is usually preferable. It may be desirable, if 
multi-programming of programs is being done by the installation, to leave 
some peripherals for other programs if, after being opened, they were not 
required by that particular program for some time. This would prevent a 
programmer monopolizing a peripheral he was not using immediately. 
Usually, however, the opening of files within a program is the first 
action taken by the programmer. 
Format 
OPEN 
INPUT 
file-name-1 
[file-name-2] 
OUTPUT 
file-name-3 
[file-name-4] 
. . . 
OPEN 
INPUT-OUTPUT 
file-name-5 
. . . 
44 

P R O C E D U R E 
D I V I S I O N 
Effect on Punched Cards, Paper Tape, Line Printer Files 
With files held on such peripherals, a message is sent requesting the 
operator to take the appropriate action with the peripheral. It is only 
after the operator has taken the correct initial action that the program 
will go ahead and process the later statements. 
Effect on Magnetic Tape Files 
When an INPUT file is held on magnetic tape, the OPEN verb causes 
the program to search the header label of the tape, checking the identifica-
tion fields to find the required file, checking the correct generation number 
of the file if specified by the programmer. If the required file is not found, 
the program is immediately suspended and the appropriate message sent 
to the operator. If correcting action is taken by the operator, the program 
will then continue. Once a unit is allocated to a file, that particular tape 
deck continues for that file until it is closed. 
When an OUTPUT file on magnetic tape is being opened, the program 
searches for a tape whose header label indicates that it may be written 
upon. If no deck is available, a message to that effect is given to the oper-
ator. If a deck is assigned to the file, the header label is written containing 
the identification field, retention period specified by the programmer, and 
the generation number. 
Effect on Disc Files 
The opening procedures performed with direct access files are much the 
same as for magnetic tape files. The INPUT-OUTPUT option may only 
be used with direct access devices and permits the opening of a direct 
access file for both input and output operations. When the file is opened, a 
check is made on the generation number if one has been specified. If one 
has not been specified, the operator may be asked to key in the appropriate 
number, otherwise the file with the specified label and the highest genera-
tion number is opened. 
The important fact to bear in mind with the OPEN verb is that given the 
appropriate option, if required, the program will perform all necessary 
functions in opening a file that the programmer may require. The pro-
grammer does not have the laborious tasks that he has with some low-level 
languages in setting up the appropriate peripherals. 
45 

P R O G R A M M I N G IN 
C O B O L 
Examples 
1. 
OPEN INPUT CARD-IN. OPEN OUTPUT CARD-OUT. 
2. 
OPEN INPUT MAG-IN-FILE OUTPUT MAG-OUT-FILE. 
3. 
OPEN INPUT-OUTPUT DISC-SALES-FILE. 
C L O S E 
The use of the CLOSE verb is closely allied to the OPEN verb and is 
just as simple to use. It also performs all the necessary functions that one 
would want in closing files on peripherals. 
Format 
CLOSE 
file-name-1 
[REEL] 
[WITH 
[file-name-2 
[REEL] 
[WITH 
NO REWIND 
LOCK 
NO REWIND 
LOCK 
In its simplest form CLOSE file-name-1 . . . the files concerned are 
closed and no reference is needed in the statement to indicate whether or 
not the files were input or output files. The statement is the last reference 
to the file within the procedure division. The file cannot then be accessed 
again until it is re-opened by an OPEN statement. With magnetic tape and 
disc files the necessary end of file labels are written. The magnetic tape reel 
is rewound to the unload position. 
The NO REWIND option is used with multi-file reels when the pro-
grammer may wish to close a file and still leave the magnetic tape reel 
positioned ready for the next file to be opened. 
With the LOCK option,* units holding the file are released, but the file 
concerned cannot be referred to again by that program. 
Examples 
1. 
CLOSE CARD-IN, MAG-IN, MAG-OUT. 
2. 
CLOSE MAG-TAPE-1 WITH NO REWIND. 
3. 
CLOSE SALES-OUT WITH LOCK. 
46 

P R O C E D U R E D I V I S I O N 
R E A D 
Once a file has been opened, the programmer may, when required, begin 
to read in the records from that particular file. 
Format 
READ 
file-name 
RECORD 
AT E N D 
imperative statement. 
The READ verb always makes the next record in a file available to the 
programmer in the record area specified. He can then process this record 
further, providing, of course, there is such a record available. If there is 
no such record, the AT E N D clause is obeyed. The AT END clause must 
always be used with the READ verb and must be followed by an imperative 
statement. This imperative statement is usually a GO TO instruction, 
followed by a paragraph, in which the programmer takes the action he 
requires after all the records have been read in. Note, too, that it is the 
file-name that must be specified not the record name within the file. 
Some input devices, i.e. magnetic tape decks, handle blocks of records, 
according to certain specifications and input a block of records to the core 
store at once, not individual records. In such cases the READ verb will 
read a block of records when necessary without any indication to the 
programmer. The programmer can, therefore, when processing a magnetic 
tape file, ignore the fact that these records will be blocked. He processes 
each individual record in turn and is not interested in whether that par-
ticular record is the first, in the middle, or the last record of that particular 
block. 
Examples 
1. 
READ STOCK-FILE RECORD AT END GO TO FINISH. 
2. 
READ WAGES TAPE RECORD AT END GO TO PARA-6. 
3. 
READ PAPER-TAPE-1 RECORD AT END GO TO FINAL-
PARA. 
W R I T E 
The WRITE verb is used to output a record from a file to any peripheral, 
and once written that particular record is lost to the programmer and 
47 

P R O G R A M M I N G IN 
C O B O L 
cannot be accessed again. Before a WRITE verb can be used, the appro-
priate file must be first opened by using the OPEN verb, as was the case 
with the READ verb. Note, however, one major difference from the READ 
verb that with the WRITE verb it is the record-name and NOT the file-
name that is referenced. The opposite is true of the READ verb. 
Format 
WRITE 
record-name 
f BEFORE] 
I 
ADVANCING 
AFTER 
{
data-name-1 Ί 
KLINES] 
integer 
J 
Print Records 
The WRITE verb when used with a line-printer is more machine-
dependent than other verbs are. This depends to some extent on the 
physical method by which the line-printer operates. For example, some 
line-printers (I.C.L. 1900 series) are controlled by a paper tape loop, which 
is the same size as the paper being printed. This loop can contain up to 
seven channels, each of which is used to control the line spacing. For 
example, the programmer in designing a print file, an invoice, perhaps, 
may specify the first hole in the paper tape in channel-1 to be positioned 1 
inch from the top of the page alongside the name of the customer. The 
second hole in channel-2 may be placed alongside the "total" column, 
about 2 inches from the bottom. The programmer can than instruct the 
line printer to skip to the top of the invoice, 1 inch from the perforation 
by reference to channel-1. He can then print the appropriate lines or spaces 
as he wishes and then by reference to channel-2 skip to the bottom half 
of the invoice, in line with the "total" column. 
Figure 6.1 illustrates the invoice structure and its appropriate paper tape 
loop. 
48 

P R O C E D U R E D I V I S I O N 
7 6 5 4 3 2 1 
Invoice 
Lines 
to be 
skipped 
Strip formed 
into loop 
Total ' 
FIG. 6.1. 
If the programmer wanted to print the first line of the invoice, he would 
write : 
WRITE CUSTOMER-NAME AFTER ADVANCING 
CHANNEL-1. 
Subsequent lines would be written : 
WRITE ITEM-P AFTER ADVANCING 3 LINES, 
and if the rest of the invoice is to be skipped down to the "total" column 
he would write: 
WRITE TOTAL AFTER ADVANCING CHANNEL-2. 
49 

P R O G R A M M I N G IN 
C O B O L 
ACCEPT 
data-name-1 
[FROM mnemonic-name] 
50 
The next invoice could then be printed by writing again: 
WRITE CUSTOMER-NAME AFTER ADVANCING 
CHANNEL-1. 
If the BEFORE option is used instead of AFTER, the printing takes 
place and then the paper spaced and not vice versa. The ADVANCING 
option is only used with line-printers. If the option 1 LINES is written, the 
printing will be single spaced, whereas 2 LINES will be double spaced and 
so on. 
With the printing of records it is advisable to move SPACES to the 
record after printing. This ensures that none of the characters from data-
record of the last WRITE instruction are reprinted where they coincide 
with blanks or zeros on the current one. 
Magnetic Tape and Disc Records 
As with the READ verb, the magnetic tape records will be automatically 
assembled into the required blocks as specified in the data division before 
being written to tape. The programmer, apart from specifying his require-
ments in the data division, can forget about the blocking requirements and 
assume he is writing separate records. 
Examples 
1. 
WRITE MAG-RECORD. 
2. 
WRITE NAME-1 AFTER ADVANCING 2 LINES. 
3. 
WRITE HEADING-l AFTER CHANNEL-1. 
4. 
WRITE NAME-2 BEFORE ADVANCING 3 LINES. 
A C C E P T 
The ACCEPT verb in a statement will allow the program to accept 
small quantities of data from the console or from any input device such as 
the card reader. 
Format 

P R O C E D U R E 
D I V I S I O N 
The data-name is the storage area where the input information is stored 
and from which the programmer may subsequently act on it as he wishes. 
If the FROM mnemonic-name option is not used, the information is 
assumed to be coming from the operator's console. If the option is used, 
the information is received from the peripheral input device specified by 
its mnemonic-name, such as card-reader or paper-tape reader. 
Examples 
1. 
ACCEPT DATE. 
2. 
ACCEPT INFO-1 FROM CARD-READER. 
In example 1 the program will send a message to the console, pause 
whilst the operator types in the necessary information. This will then be 
stored in location DATE, ready for use by the programmer. In example 2 
the location is called INFO-1 and the information from the punched card 
is stored there. Again, the program will pause whilst the operator performs 
the necessary tasks. 
As there is no automatic checking of the input information, the operator 
must type in the correct information unless the programmer includes a 
validating routine within his program. 
D I S P L A Y 
The DISPLAY verb is very similar to the ACCEPT verb except, of 
course, that, in this instance, the program will output small quantities of 
data to the console or other peripheral such as the line-printer. 
Format 
DISPLAY 
fdata-name-1 
literal-l 
|
rdata-name-2| 
I literal-2 
[UPON 
mnemonic-name.] 
The UPON mnemonic-name option is only used when the information 
is to be displayed on a peripheral, such as line printer, other than the 
console. 
51 

P R O G R A M M I N G IN C O B O L 
52 
Op'Mi files 
Read a card 
<
^
^
^
—
•
— 
Close files 
Display 
Type in 
week number" on 
the opei ntor s console 
Accept "week number" 
from the operator's 
console into w e e k -
rio location 
Middle of Program 
Write 
heading at 
top of the 
l'aile 
é—
1—é 
Move spaces 
to heading 
Write 
print - line 
Move spaces 
to pi int - line 
1 
FIG. 6.2. 

P R O C E D U R E 
D I V I S I O N 
Examples 
1. 
DISPLAY BALANCE. 
2. 
DISPLAY 365. 
3. 
DISPLAY "TOTAL SALES" UPON PRINTER. 
4. 
DISPLAY "GROSS SALES = " TOTAL UPON PRINTER. 
In example 1 the contents of storage location BALANCE and in example 
2 the literal 365 are both displayed on the console. In example 3 the words 
"TOTAL SALES" without the quotation marks will be printed on the 
line-printer. In example 4 if total-1 contains 369, 754, the printer will have 
displayed GROSS SALES = 369,754. 
Q U E S T I O N S 
1. Write the program instructions, which will open a file called 
BOOKING-FILE, to be read in on the paper tape reader and a print-out 
file, called FINAL-LIST on the line printer. 
2. Write the program instructions for the flowchart shown in Fig. 6.2, 
putting them into suitable paragraphs. 
A N S W E R S 
1. OPEN INPUT BOOKING-FILE. 
OPEN OUTPUT FINAL-LIST. 
2. PARA-1. 
OPEN INPUT CARD-FILE OUTPUT PRINT FILE. 
PARA-2. 
READ CARD-FILE RECORD AT END GO TO FINAL 
PARA. 
DISPLAY "TYPE IN WEEK NO". 
ACCEPT WEEK-NO. 
PARA-6. 
WRITE HEADING AFTER CHANNEL-1. 
MOVE SPACES TO HEADING. 
53 

P R O G R A M M I N G IN 
C O B O L 
54 
PARA-7. 
WRITE PRINT-LINE AFTER ADVANCING 2 LINES. 
MOVE SPACES TO PRINT-LINE. 
G O TO PARA-2. 
FINAL-PARA. 
CLOSE CARD-FILE PRINT-FILE. 

C H A P T E R 7 
Procedure Division-
Other Verbs 
Now we shall have a look at an assortment of verbs, which make up the 
rest of the procedure division. We shall group these verbs as far as possible 
like with like rather than deal with them alphabetically or randomly. The 
most commonly used and probably the most important of these verbs is 
the PERFORM verb, which along with the EXIT verb we shall look at 
first. 
P E R F O R M 
Frequently within programs, the programmer wishes to do certain tasks 
which are identical, at different intervals throughout the program. For 
instance, the programmer may have an error routine in which he adds a 
quantity to an error-total and prints the result in a certain sequence on the 
line-printer as Fig. 7.1 shows. 
This same situation may occur far more than twice in the program. It 
would be ludicrous then for the programmer to write out the instructions, 
adding quantity to error quantity and printing out the error, every time 
they were needed. It is obviously simpler if these instructions are grouped 
into one paragraph or section and, when necessary, the program branching 
to the paragraph and then returning to the original position. 
In COBOL the programmer can do this by using a PERFORM verb. The 
verb is very flexible and has endless possibilities. The more complicated 
versions of the format appear a little daunting, although in practice the verb 
is in most instances relatively easy to use. 
p.c.—c 
55 

P R O G R A M M I N G 
IN 
C O B O L 
56 
P a r a - 6 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Test 
v 
^ 
for error 
^ 
£
s 
A
d
d
 
quantity to 
situation s '
 
e
r
r
o
r
 
quantity 
No,, 
Printout 
error 
br 
P a r a -
7 
"*
 
1 
Statement 
I 
Statement 
F a r a -
8 
| 
Statement 
• 
Statement 
P a r a - 9 
| 
Statement 
Para-10 
s ^ t 
Test 
Ye S 
A
d
d 
q
u
a
n
t
j t y 
t
o 
< 
for error 
> 
. 
. , 
error quantity 
^
s
^
s
i
t
u
a
t
i
o
n
M
 
' 
No 
Print out 
error 
P a r a - 1 1 
FIG. 7.1. 

Format 1 
P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
PERFORM 
procedure-name-1 
[THRU 
procedure-name-2] 
This is the simplest and most commonly used format of the PERFORM 
verb and could be used as follows in the above flowchart. A special 
paragraph, para-X, could be allotted to the error routine, in which the 
quantity is added to the error quantity and the error printed out. 
The program would then be : 
PARA-6. 
PERFORM PARA-X. 
PARA-7. 
statement, 
statement. 
PARA-8. 
statement, 
statement. 
PARA-9. 
statement, 
statement. 
PARA-10. 
PERFORM PARA-X. 
PARA-11. 
statement. 
PARA-X. 
A D D QUANTITY TO ERROR-QUANTITY. 
WRITE ERROR-RECORD AFTER 1 LINES. 
In each case the program would branch to PARA-X, 
PERFORM 
PARA-X and then return control to the original statement + 1 . 
If there is more than one paragraph or section concerned, then the 
T H R U option is used. When the program branches the group of para-
graphs are PERFORMED and control at the end, as above, returns to 
the original statement + 1 . 
57 

P R O G R A M M I N G IN 
C O B O L 
In this case the first PERFORM verb will cause control to pass to para-6. 
The program will continue until the second PERFORM verb is reached, 
when control will pass to para-9. At the end of para-10 control will return 
to the statement after the second PERFORM verb in para-7. At the end of 
para-7 control will return to the statement, after the first PERFORM verb, 
at the beginning of para-5. 
Examples 
1. 
PERFORM PARA-6 T H R U PARA-8. 
2. 
PERFORM PARA-X T H R U PARA-Y. 
Nested PERFORM Statements 
It is quite permissible to have one PERFORM statement coming 
within the range of another. 
PARA-4. 
PERFORM PARA-6 T H R U PARA-7. 
PARA-5. 
statement, 
statement. 
PARA-6. 
statement, 
statement. 
PARA-7. 
PERFORM PARA-9 T H R U PARA-10 
statement. 
statement. 
PARA-8. 
statement. 
PARA-9. 
statement. 
PARA-10. 
statement. 
PARA-11. 
58 

P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
In this instance, the first PERFORM statement transfers control to 
para-6. The second PERFORM statement transfers control to para-8. 
After para-8 has been performed, control returns to the statement after 
the second PERFORM verb. The rest of para-7 is then obeyed, followed 
by para-8 in normal sequence, followed by para-9, after which control 
returns to the first PERFORM statement plus one. 
There are, of course, many variations on a theme, which may be done by 
nesting PERFORM verbs, which we cannot go into here. What is 
important is that the programmer should take great care that control 
returns to the correct statement. It is very easy, if complicated nesting is 
attempted to fail to make sure all paragraphs are executed as required and 
control will not then return to the required statement. 
The programmer may wish to PERFORM a paragraph or group of 
paragraphs several times. To do this he uses format 2. 
59 
It is also permissible to have the second PERFORM verb completely 
within the first. 
PARA-4. 
PERFORM PARA-6 T H R U PARA-9. 
PARA-5. 
statement. 
PARA-6. 
statement, 
statement. 
PARA-7. 
PERFORM PARA-8. 
statement. 
statement. 
PARA-8. 
statement, 
statement. 
PARA-9. 
statement. 
PARA-10. 
statement. 

P R O G R A M M I N G IN 
C O B O L 
Format 2 
PERFORM 
procedure-name-1 
[THRU 
procedure-name-2] 
data-name * 
-
> TIMES 
integer 
Examples 
1. 
PERFORM PARA-Α THRU PARA-B 6 TIMES. 
2. 
PERFORM PARA-6 COUNT TIMES. 
As well as specifying that a paragraph or group of paragraphs are per-
formed a certain number of times, the programmer may wish to have them 
performed until a certain condition is true. 
Format 3 
PERFORM 
procedure-name-1 
[THRU 
procedure-name-2] 
UNTIL 
condition-1. 
When the condition is true, control returns to the original statement 
plus one. 
Example 
1. 
PERFORM PARA-X UNTIL STOCK-TOTAL 
EQUALS 
STOCK-LEVEL. 
The fourth format at first appearance looks a little complicated, but on 
closer inspection is not really as bad as it looks. 
60 

Format 4 
P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
PERFORM procedure-name-1 [THRU procedure-name-2] 
VARYING data-name-1 FROM i 
data-name-2! 
fdata-name-31 
BY 
literal-2 
literal-3 
UNTIL condition-1 [AFTER data-name-4 FROM 
data-name-5l 
literal-5 
fdata-name-6] 
BY \ 
\ UNTIL condition-2 [AFTER data-name-7 
literal-6 
fdata-name-8] 
FROM \ 
{ 
BY 
Literal-8 
fdata-name-9] 
literal-9 
UNTIL condition-3. 
The above format will probably be clearer if I give examples to show 
how the format may be used in practice. 
Examples 
1. 
PERFORM PARA-7 VARYING COUNT-1 FROM 0 BY 1 
UNTIL COUNT-1 EQUALS 10. 
2. 
PERFORM PARA-X VARYING TOTAL-WS FROM 0 BY 
1 UNTIL TOTAL-WS EQUALS 10 AFTER COUNT-2 FROM 
20 BY 1 UNTIL COUNT-2 EQUALS 25. 
In example 1 PARA-7 is executed until COUNT-1 is 10, and each time 
the paragraph is done 1 is added to the count; the count being set at 
zero to begin with. In example 2, PARA-X is executed until TOTAL-WS is 
equal to 10, and each time the paragraph is done, one is added to TOTAL-
WS. This time, however, a further condition must also be true, that is 
COUNT-2 equal to 25. 
61 

P R O G R A M M I N G IN 
C O B O L 
E X I T 
Associated with the PERFORM verb is the EXIT verb, which provides 
a common ending for a series of procedures, i.e. paragraphs or sections. 
The verb must be in a paragraph of its own with no other verbs, to which 
the program jumps from the other paragraphs when necessary. 
Format 
EXIT 
Example 
1. 
PARA-X. 
EXIT. 
PARA-Y. 
This verb is used when the programmer, whilst performing a series of 
procedures, may wish to branch from the procedures after a certain 
condition has been tested and is found to be true. 
Example 
PARA-6. 
PERFORM PARA-8 T H R U PARA-9. 
PARA-7. 
statement. 
PARA-8. 
statement. 
IF . . . GO TO? 
statement. 
PARA-9. 
statement, 
statement. 
PARA-10. 
statement. 
62 

P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
If, as in the above example in PARA-8, the programmer wishes to jump 
out of the PERFORM sequence by branching to the end of PARA-9, when 
a condition is true, his program would be taken out of the control of the 
PERFORM verb. The programmer would have to have written GO TO 
PARA-10. Control would not then return to PARA-7; the original state-
ment plus 1. 
Only by using the EXIT verb and specifying an extra paragraph could 
this dilemma be overcome. 
Example 
PARA-6. 
PERFORM PARA-8 T H R U PARA-X. 
PARA-7. 
statement. 
PARA-8. 
statement. 
IF . . . GO TO PARA-X. 
statement. 
PARA-9. 
statement, 
statement. 
PARA-X. 
EXIT. 
PARA-10. 
statement. 
We will now, if the condition in PARA-8 is true, branch to PARA-X, 
but the program will still be under the control of the PERFORM verb in 
PARA-6, and return after PARA-X to the original statement plus 1. 
A L T E R 
Sometimes during a program, the programmer may wish to branch 
elsewhere, depending on a decision made earlier. This could be pro-
grammed, rather circuitously as follows, 
63 

P R O G R A M M I N G IN 
C O B O L 
Example 
PARA-6. 
IF STOCK-CODE-NO LESS THAN 100 MOVE 1 
TO POINTER ELSE MOVE 2 TO POINTER, 
statement, 
statement. 
PARA-7. 
statement. 
PARA-8. 
IF POINTER EQUALS 1 GO TO PARA-9 ELSE GO 
TO PARA-10. 
PARA-9. 
DISPLAY STOCK-CODE-NO. 
STOP. 
PARA-10. 
WRITE STOCK-IN TO MAG-FILE-1. 
Alternatively, this could be programmed by using the ALTER verb. 
Format 
ALTER procedure-name-1 TO PROCEED TO procedure-name-2 
[procedure-name-3 TO PROCEED TO procedure-name-4] . . . 
At the point where the programmer wishes to branch, he specifies a 
paragraph with just a GO TO statement in it. This paragraph is then 
referred to in the ALTER statement. Procedure-name-1 is the name of the 
paragraph, which contains the GO TO statement. The ALTER verb 
modifies the object of the GO TO statement replacing it with procedure-
name-2. When a GO TO statement is modified in this way, it will stay in 
its changed form until the next time an ALTER statement referring to it 
is obeyed. 
The above example could then be programmed as follows; 
64 

P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
Example 
PARA-6. 
IF STOCK-CODE-NO LESS THAN 100 ALTER 
PARA-8 TO PROCEED TO PARA-9 ELSE ALTER 
PARA-8 TO PROCEED TO PARA-10. 
statement, 
statement. 
PARA-7. 
statement. 
PARA-8. 
GO TO. 
PARA-9. 
DISPLAY STOCK-CODE-NO. 
STOP. 
PARA-10. 
WRITE STOCK-IN TO M AG-FILE-1. 
The GO TO in PARA-8 may contain an object before it is altered. This 
will be obeyed until the ALTER statement replaces it with another object. 
Both methods of programming may be used; the second example being 
a slightly neater and less laborious method of doing the operation than the 
The STOP verb is written either to stop the program permanently at the 
end of the run or temporarily so that the operator may intervene if the 
programmer wants him to. 
If the STOP literal format is used, the literal up to forty characters in 
length is displayed on the console to the operator and the program is 
first. 
S T O P 
Format 
' literal º 
R U N J 
65 
STOP 

P R O G R A M M I N G 
IN 
C O B O L 
suspended temporarily. Every program must be concluded with a STOP 
RUN statement which, of course, must be the last statement in the program. 
Examples 
1. 
STOP RUN. 
2. 
STOP "CODING ERROR." 
3. 
STOP 306. 
The program, if stopped temporarily, can be started again later by the 
operator. The STOP R U N option at the end of the program will check 
that all files have been closed correctly and that the program is to be sus-
pended. 
N O T E 
The NOTE verb like the STOP verb is not associated with any particular 
group of verbs. It is used when the programmer wishes to add a com-
mentary or description to his program as he is writing it. The description 
is printed out as the program is being compiled. 
Format 
NOTE description 
This description is, of course, ignored by the compiler and is only printed 
out. This enables the programmer to comment on his program to help 
him, or someone else, to understand his original intentions at a later stage. 
This verb can be a help with documentation if someone else has to look at 
the program later because the original programmer leaves that particular 
assignment. 
The programmer should avoid using reserved words (Appendix I). 
Example 
NOTE THIS SECTION IS TO VALIDATE INPUT DATA, 
66 

P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
E X A M I N E 
The EXAMINE verb is used to either count the number of times a 
particular character occurs within a data-name or to replace a certain 
character by another or to do both operations at the same time. This is 
useful in a validating section to test the occurrence of certain characters. 
Format 1 
ÎALL 
\ 
EXAMINE data-name-1 TALLYING < LEADING 
literal-l 
FIRST 
J 
REPLACING 
BY 
literal-2. 
Format 2 
(ALL 
\ 
EXAMINE data-name-2 REPLACING 
LEADING I literal-3 
FIRST 
J 
BY literal-4. 
When a data-name is being examined, the examination starts at the left-
most character and works towards the right, ignoring any sign characters 
in numeric data. When the TALLYING option is used, a special register 
TALLY is created, into which the count of the character is placed. 
In format 1 when the option ALL is used a count is kept of all the occur-
rences of a particular character. With the LEADING option occurrences 
of a particular character are counted, counting from the left and stopping 
as soon as a character other than the one specified is met. With the FIRST 
option a count is taken of all characters other than the one specified until 
the first of the specified characters is met. 
67 

P R O G R A M M I N G IN 
C O B O L 
Example 1 
If a code number contains the following digits 55513294153, then the 
statement 
" 1 
EXAMINE CODE-NUMBER TALLYING 
\ 2 below 
3 
1. 
ALL 5 
Value of TALLY = 4 
2. 
LEADING 5 
Value of TALLY - 3 
3. 
FIRST 9 
Value of TALLY = 6 
Example 2 
If we extended the instruction to read 
EXAMINE CODE-
NUMBER TALLYING 
REPLACING BY 0 
1. 
ALL 5 
Value of TALLY - 
4 
CODE-NUMBER = 00013294103 
2. 
LEADING 5 
Value of TALLY = 3 
CODE-NUMBER = 00013294153 
3. 
FIRST 9 
Value of TALLY = 6 
CODE-NUMBER - 
0000009453 
If the second option of REPLACING on its own is used, this gives the 
facility of substituting certain characters without giving a count as well. 
The method used is exactly the same as the one above. 
C A L L 
This verb is used to transfer control to a COBOL subroutine, when the 
programmer wishes to use a subroutine for a specific purpose within the 
program, to save him programming time, duplicating, etc. 
Format 
CALL subroutine-name USING, data-name-1 
[data-name-2] 
68 

P R O C E D U R E D I V I S I O N - O T H E R 
VERBS 
ENTER language-name subroutine-name USING parameter-1. 
The language-name, of course, will have to be a language acceptable 
to the particular computer and COBOL compiler for that computer. For 
instance, assembler languages are specific to particular computers and 
unlike high level languages, such as 
COBOL, 
FORTRAN are machine-
dependent. The parameter names specified may be file-names, record-
names, data-names, procedure-names, or literals. The use of them being 
determined by the requirements of the particular subroutines being used. 
Example 
ENTER FORTRAN XYZ. 
C O P Y 
The COPY statement is used to incorporate text from the COBOL library 
tape into the program, the effect being the same as if the text were actually 
written as part of the source program. 
69 
The subroutine-name must not exceed eleven characters in length. The 
data-names are the names of records specified in the data division file, 
working storage, constant, or linkage sections of the subroutine specified. 
These must be used in the order specified by the subroutine ; the instructions 
of which will lay down how these are to be used. 
Example 
CALL ABC. 
E N T E R 
The ENTER verb enables the programmer to incorporate within his 
program subroutines written in another language other than COBOL, such 
as FORTRAN. These subroutines may be those supplied by the manufacturers 
or special subroutines written in another language by the user himself. 
These subroutines are inserted during the consolidation stage. 
Format 

P R O G R A M M I N G IN 
C O B O L 
COPY library-name REPLACE Word-1 BY Word-2 
Word-3 BY Word-4. 
The COPY statement may be included in the environment division, 
after a paragraph in the data division at FD, 01, or 77 level or after a section 
or paragraph name in the procedure division. 
Examples 
1. 
PARA-12. 
COPY LIBRARY-A. 
2. 
ENVIRONMENT DIVISION. 
SPECIAL NAME. 
COPY LIBRARY-B. 
Q U E S T I O N S 
1. If the programmer wishes to branch out to a subroutine in two para-
graphs CONVERSION-1 and CONVERSION-2, write the instructions he 
would use to do this. 
2. Write the instructions if the same subroutine is to be done five times. 
3. Write the instructions for a validating routine allowing you to count 
the number of 2's that appear in an accounts number and to replace them 
by O's. 
4. Write the instructions that will jump to a PLAN subroutine called 
ABC. 
A N S W E R S 
1. PERFORM CONVERSION-1 T H R U CONVERSION-2. 
2. PERFORM CONVERSION-1 T H R U CONVERSION-2 5 TIMES. 
3. EXAMINE ACCOUNT-NUMBER TALLYING ALL 2 REPLAC-
ING BY 0. 
4. ENTER PLAN ABC. 
Format 
70 

C H A P T E R 8 
Data Division I 
G E N E R A L 
D E S C R I P T I O N 
T H E data division is the third of the four divisions and must be placed after 
the environment division and before the procedure division. We are looking 
at it after the procedure division, because I believe this is the best approach 
to the subject. Normally, however, when writing COBOL programs, the 
reader will be well advised to specify the data division completely before 
attempting to write the procedures for his program. This is more likely 
to ensure a greater degree of accuracy and a logically correct program. 
In the data division, the programmer specifies in very precise detail the 
data files and data records to be used by the program. The programmer 
does basically four things. 
(a) He divides up the internal storage space available to his particular 
program into the formats he requires. 
(b) He gives names, chosen by himself, to these areas. 
(c) He gives all the necessary information about the data files which 
are to be inputed to the computer or to be outputed from it. For 
instance, if a file is to be fed in via the punched-card reader, all 
the information about each record within the file and every field 
within each record is specified in the most precise detail. 
(d) He defines the properties of the internal storage, i.e. whether the 
data is alphabetic or numeric, decimal, or sterling. 
The data division is subdivided into four major sections. We shall look 
briefly at the distinctions between these sections now. Later in the book we 
shall examine these sections in more depth. 
File Section 
The file section specifies the contents of the data files, which are held in 
71 

P R O G R A M M I N G 
IN 
C O B O L 
one of the external devices, such as paper-tape reader, line printer, 
magnetic-tape devices. Each file description is immediately followed by 
the descriptions of the records held within that file. 
Working-storage Section 
This section describes records and single data items which are unique in 
themselves which are not fed in or out via external media. These items are 
used internally by the program and include such areas as "count" 
locations which the programmer uses to keep a count of the number of 
times an event occurs. Or, secondly, perhaps a "table" where, for example, 
bonus rates or names and addresses are stored which the programmer will 
wish to access during the course of his program. 
Constant Section 
Within this section are stored constant values given in the source 
program which do not change during the running of the program. 
Linkage Section 
The linkage section is only used in COBOL subroutines and describes the 
subroutines parameters. 
Before progressing 1 think we ought to have some clear idea of some of 
the terms used frequently within this division. 
File. A file in the data division is a continuous flow of information held 
on an external input or output device. This information is accessed under 
the control of the program, information being presented or produced as 
and when required, a record at a time. 
Record. A record is a unit of information; unit of the file available to the 
program for processing at any one time. A record can also be the equiva-
lent area of storage within the working-storage or constant sections. A file 
may have more than one record of a different type, but each type must be 
fully defined in the record description. Records are held in blocks of one 
or more records, the number of records per block depending on the type of 
external media and the wishes of the programmer. Magnetic tape files have 
more than one record per block usually, whereas punched-card files are 
always held in single records to a block. The compiler will always allocate 
72 

D A T A D I V I S I O N I 
sufficient internal storage space to hold at least one block. Each record 
before processing is fed into the same area of storage, allocated to the 
record. 
Field. A record is divided into fields which are given unique names and 
may be one of two types. Group fields which are composite fields and are 
subdivided into elementary fields. Elementary fields may be up to 120 
characters in length. By specifying the elementary fields in detail, a picture 
of the total record is built up. 
F I L E 
S E C T I O N 
The FILE SECTION of the data division is written as follows, 
commencing in column 8 and ending with a period : 
FILE SECTION. 
After the heading comes a file description for every file to be processed by 
the program. These file descriptions may be in any order. Each file des-
cription is followed, again in arbitrary order, by a record description for 
every record within that file. 
FILE SECTION, 
file description 
record description 
record description 
file description 
record description 
record description 
file description 
record description 
record description 
If within the file being processed by the program there is more than one 
kind of record, the compiler will allocate a record area which is sufficient 
to hold the largest record. Therefore a description of more than one 
record is really a method of mapping the record area in a different way. 
73 

P R O G R A M M I N G IN 
C O B O L 
F I L E 
D E S C R I P T I O N 
The file description part of the file section consists of a level description 
FD followed by a file-name, followed by a series of independent clauses, 
which describe in detail the nature of the file. 
Format 
FD 
file-name 
independent clause 
independent clause. 
The level indicator FD commences in column 8 and is followed by the 
file-name, which obeys the usual data-name limitations. The file-name is 
followed by various independent clauses depending on the type of file. 
Many of these clauses are optional and some of them have no effect on the 
program. They may be included for documentation purposes only. We 
shall look at each of these clauses in turn. 
Recording Mode 
The RECORDING MODE clause defines the organization of data on 
the external media. This clause is not usually included in most programs, as 
when absent the compiler assumes that the organization of data is standard. 
The only non-standard mode which is allowed is binary image card reading 
when the clause is written as follows: 
RECORDING MODE IS 2. 
File Contains 
The FILE CONTAINS clause may be used by the programmer to show 
the approximate number of records in a file. This clause causes no object 
program coding to be produced and is used solely for documentation 
purposes. 
74 

D A T A D I V I S I O N I 
Block Contains 
This clause specifies the physical size of a block. With character 
peripheral devices, such as the punched-card reader, paper-tape reader, 
line printer, a block always contains only one record, and so if the clause 
is used in the source program it is ignored by the compiler. With paper-tape 
input a block is as long as the longest record of the file, which with I.C.L. 
1900 software must not exceed 128 characters. On a buffered printer, 
the block size cannot exceed the size of the print-line. On other devices the 
block size is connected to the characteristics of that device, for instance 
number of columns with punched-card readers. If a record is less than a 
block in length, the rest of the block is ignored and filled with unpredictable 
characters. 
With magnetic-tape files a block may contain more than one record. In 
these cases the clause must always be used either with the RECORDS or 
CHARACTERS option. If the RECORDS option is used, the compiler 
will allocate sufficient storage area to hold the largest size of record. If 
the CHARACTERS option is used, then naturally the area allocated will 
hold the largest size of record in terms of characters. With direct access 
devices a storage area of the specified size is allocated to the file. 
Record Contains 
If this clause is used, it is for documentation purposes only, as the 
record is described fully in the record description. 
Label Records 
This particular clause states whether or not there are labels present, and 
if the answer is yes, identifies the label concerned. With character 
peripheral devices, punched-card readers, etc., there must be no labels 
written. In these cases the clause is written 
LABEL RECORDS ARE OMITTED. 
or the clause may be left out altogether. 
With magnetic-tape and direct-access devices, on the other hand, there 
must be labels present. The clause is written 
LABEL RECORDS ARE STANDARD [WITH 
GENERATION-NO] 
75 

P R O G R A M M I N G IN 
C O B O L 
76 
The labels used will be the standard I.C.L. 1900 labels. These labels have 
three fields: 
Identification 
Active-time 
Generation number 
The first two are dealt with under the VALUE OF clause, dealt with later. 
The GENERATION-NO option, as specified here, checks that the field 
known as the generation number is checked on input and written to on 
output. If the option is not used, the input file is not checked and zeros 
are recorded on output. 
The generation number is used in many commercial file processing 
routines to avoid confusion. In most updating routines more than one 
magnetic tape file has the same identification. This extra qualification to 
the name of the file gives additional security to the installation, ensuring 
that the correct magnetic tape is used. 
Value of Identification 
Here the first of the standard label fields is specified in the program. 
The programmer defines the name of the file, which is a non-numeric 
literal of not more than twelve characters in length. 
When an input file is opened for processing, a search is made for a file 
with the identification specified on it. With an output file the identification 
header is written to the tape. The name of the file, as a literal, must remain 
the same for all the program. Should there be any discrepancies when the 
computer is searching for the appropriate tape, a message will be sent to 
the operator. Rectification action may then be taken. 
Active-time 
The ACTIVE-TIME option is an adjunction to the VALUE OF clause. 
It is only used when a file is being written to, i.e. as an output file. This 
clause specifies the number of days before it can be overwritten. This is 
for security reasons, and helps to prevent a file being accidently over-
written. 
Data Records 
Here the programmer lists the names of the records which are to appear 
in the file. This clause is not used by the compiler, being for cross-reference 
purposes only. It must be present, however, with most compilers. 

D A T A D I V I S I O N I 
Sequenced On 
This clause is printed out by the compiler, but is not used by it. Its 
purpose is to list the fields of the record by which the records are sequenced. 
The file description entry is all one entity, and therefore the only period 
written should be after the last clause used to terminate the description. 
Commas and semicolons may be used to separate the different clauses. In 
my opinion it is also far better to write each clause on a separate line, 
although they may be written on the same line if the programmer wishes. 
The complete format of the file description is given as follows. This 
looks at first rather forbidding, but as so many of the clauses are redundant 
for most files, in practice the description is reasonably easy to use. 
Format 
FD 
file-name 
[RECORDING MODE IS mode] 
[FILE CONTAINS ABOUT integer-1 RECORDS] 
[RECORD CONTAINS [integer-4] TO integer-5 CHARACTERS] 
fRECORDS 
[BLOCK CONTAINS [integer-2] TO integer-3 
i 
CHARACTERS 
f RECORD IS 
STANDARD 
[WITH 
[LABEL 
GENERATION" 
NO] 
RECORDS ARE 
OMITTED 
[VALUE 
OFi 
IS literal-l [ACTIVE-TIME IS 
literal-2]] 
IDENTIFICATION 
[DATA 
[SEQUENCED ON data-name-3 [data-name-4 . . .]]. 
77 
RECORD IS 
RECORDS ARE 
data-name-1 [data-name-2 . . .]] 

P R O G R A M M I N G IN 
C O B O L 
Examples 
I have shown two examples of a file description. The first one is for a 
file to be inputed on the punched-card reader, the second to be outputed 
on to magnetic tape. 
Example-l. 
Punched-card reader. 
F D 
PURCHASES-FILE 
LABEL RECORDS ARE OMITTED 
DATA RECORDS ARE CARD-TYPE-1, CARD-TYPE-2. 
Example-2. Magnetic tape. 
FD 
MAG-OUT-FILE 
BLOCK CONTAINS 5 RECORDS 
LABEL RECORDS ARE STANDARD WITH 
GENERATION-NO 
VALUE OF ID IS "PURCHASES" 
ACTIVE TIME IS 7 
DATA RECORD IS RECORD-1. 
As you can see, there is nothing complicated with example-l. Example-2 
is more complex, but with practice not too difficult. I have only used the 
bare minimum of clauses. Others may be used if the programmer wishes 
to document his program more fully. 
R E C O R D 
D E S C R I P T I O N 
Once the file has been specified, the next task for the programmer is to 
specify each of the records within that file. There can be more than one 
record to a file and each must be defined separately. This is done by a 
series of sentences describing the characteristics of each field within the 
record. The record-name corresponds to that defined in the file description 
under the DATA RECORDS clause. 
Each field is given a data-name which must, again, abide by the data-
name rules, i.e. up to thirty characters, from the set A-Z, 0-9, and hyphen. 
The name is chosen by the programmer. Each data-name must be unique 
78 

D A T A 
D I V I S I O N 
within a record. It need not be unique within a program, but when it is 
used it must be qualified by using OF or IN. 
Filler 
There is just one standard data-name in use and this is called FILLER. 
It is used to describe a blank field which the programmer wishes to leave 
empty. The programmer does not need to give a name to each area he 
wishes to leave empty; he can use this standard data-name. Filler is 
defined more precisely by using the PICTURE clause in the same way that 
other data names are defined, but it cannot be referenced directly. 
Level Numbers 
In order to help the compiler ascertain the relationship between the 
various fields within a record, each field is given a level number. These 
level numbers may range from 01 to 49, although each record is rarely 
split into more than four or five levels. Each field within a record and each 
subfield within a field is given a level number. Less inclusive data items are 
given progressively higher, but not necessarily successive level numbers. 
Level numbers 66, 77, and 88 have a special purpose which will be 
explained later. 
The data record name, specified under the DATA RECORD clause, is 
always repeated and given level 01. The level numbers for the record speci-
fied in example-1 under the file description is illustrated below by designing 
the actual punched card. 
01 C a r d - t y p e - 1 
02 Order - no 
02 Item - detail 
02 Supp-name 
02 Filler 
03 Code 
03 Name 
03 Price 
FIG. 8.1. 
79 

P R O G R A M M I N G IN 
C O B O L 
Or the same format illustrated as follows. 
01 Card - type -1 
02 Order-no 
02 lt< 
02 Item-detail 
-detail 
02 S u p p - n a m e 
02 Filler 
03 Code 
03 
03 Name 
lame 
03 Price 
FIG. 8.2. 
Elementary fields in the above are order-no, code, name, price, and supp-
name. The programmer would specify the above card as follows, repeating 
the FILE DESCRIPTION of example-l : 
FD 
PURCHASES-FILE 
LABEL RECORDS ARE OMITTED 
DATA RECORDS ARE CARD-TYPE-1, CARD-TYPE-2. 
01 
CARD-TYPE-1. 
02 
ORDER-NO. 
02 
ITEM-NO. 
03 
CODE. 
03 
NAME 
03 
PRICE. 
02 
SUPP-NAME. 
02 
FILLER. 
01 
CARD-TYPE-2. 
record description 
record description 
The programmer should give the same level number to the same level 
of item. I have, too, as above, found it more readable to indent the level 
numbers in the record description. 
The reason for the different level numbers is so that the programmer 
could access, if he wishes, a whole group field, without necessarily referring 
to each elementary field. That is he could access all 01 CARD-TYPE-1 to 
80 

D A T A D I V I S I O N I 
another area or all 02 ITEM-NO or just 03 CODE, depending on what he 
wishes to do. He could move each of these different levels to a separate 
area of the core store, providing the receiving area has been specified 
correctly. 
Picture 
Once the data fields level numbers and names have been determined, the 
programmer begins to dot the i's and cross the f s by describing the format 
of each elementary item. He does this by using the PICTURE clause. 
Format 
PIC 
PICTURE 
IS 
character string 
The character string is a combination of allowable characters, which we 
shall look at separately. The string must not consist of more than thirty 
characters in total, except in arithmetic locations when the maximum is 
twelve decimal digits. 
Data Characters 
Character 9. The character 9 is the numeric symbol and represents a 
decimal digit from the range 0-9. Thus if we have an elementary field called 
TOTAL-IN which we wish to specify as being four numeric digits in 
length, we would do so as follows: 
03 
TOTAL-IN 
PICTURE 
9999. 
The contents of location TOTAL-IN could then range from 0000 to 9999. 
If the number 22 were moved into the location, TOTAL-IN would hold 
0022. Should a number greater than four digits in length be moved into 
the location, e.g. 53792, then the result would be truncated and the 5 
lost. The compiler would also print an error if the programmer tried to 
make the location hold non-numeric data. Great care should then be taken 
81 

P R O G R A M M I N G IN 
C O B O L 
82 
when specifying the PICTURE clause that the correct character is used 
and that the number of digits allowed is sufficient in all cases. The same 
applies to all other data characters. 
Character A. This character represents a character position with contents 
from the set A-Z and space. The location cannot hold numeric data. 
02 
NAME-1 
PICTURE 
AAAAAAA. 
The contents of NAME-1 could then be up to seven alphabetic characters 
in length and no more. If the contents were less than seven characters, the 
remainder of the character positions would hold spaces. 
Character X. Character X describes any of the COBOL character set given 
in Chapter 2. A five-character field able to hold alphabetic, numeric, or 
special characters would be described as follows: 
04 
CODE-TYPE-OUT 
PICTURE 
XXXXX. 
Character 
1. Most compilers have the facility for specifying binary 
digits, which are represented by a 1. This is frequently done with magnetic-
tape files. Thus a word-count field at the beginning of a record, four 
characters or twenty-four bits in length, would be specified as : 
02 
WORD-COUNT 
PICTURE 
1(24). 
As you can see from this last example, it would be ludicrous to write 
out twenty-four separate l's. it is much easier, if this is put behind the 
character. 
Example 
PICTURE 
1(24). 
There is no space between the 1 and leftmost bracket. This method 
obviously saves some coding and punching once the number of characters 
in a location exceeds four. 
All the above examples could have been written in the same manner 
without loss of meaning as follows: 
03 
TOTAL-IN 
PICTURE 9(4). 
02 
NAME-1 
PICTURE A(7). 
04 
CODE-TYPE-OUT 
PICTURE X(5). 

D A T A D I V I S I O N I 
With some compilers, I.C.L. 1900 series begin one of them, the PIC 
option may be used instead of PICTURE. Not all compilers have this 
option, although this saves a little coding and punching. 
Examples 
1. 
02 
INVOICE-NO 
PIC 9(6). 
2. 
04 
NAME-OUT 
PIC A(9). 
3. 
03 
CODE-1 
PICTURE 99. 
4. 
02 
ITEM-Α 
PICTURE XXXXX. 
Operational Characters 
Character 
V. V is the character used to indicate to the compiler the 
location of the assumed decimal point or binary point. No character 
position is taken up by the V. If there is no V used in a PICTURE clause, 
the item is assumed to be an integer. There may only be one assumed 
decimal point in a clause. It would also be superfluous to use the V as the 
rightmost character. 
03 
TOTAL-IN 
PICTURE 
99V99. 
The above location TOTAL-IN has only four digits, but the string 3657 is 
assumed to be 36.57. 
Character S. This character indicates the presence of an operational 
sign and is also not counted in the size of the data item. If specified it must 
be the leftmost character and must only appear once in the clause. It is 
stored, depending on the computer, in some way usually as part of the 
first character. It must only appear with numeric or binary fields. 
03 
TOTAL-IN 
PICTURE 
S9999. 
This example means that the contents may range from —9999 to +9999. 
The field is only four digits in length. 
Character P. Character Ρ indicates an assumed decimal scaling position, 
and is used to specify the number of character positions between the data 
item and its assumed decimal point. The character Ρ can only appear as a 
continuous string at the extreme left or extreme right of a PICTURE 
clause. The decimal point is assumed to be at the left of the P's if the P's 
are the leftmost PICTURE characters or to be at the right if the P's are 
the rightmost PICTURE characters. Only insertion characters, which we 
83 

P R O G R A M M I N G IN 
C O B O L 
84 
shall discuss later, may appear to the left or right of the P's. The characters 
are not counted in the size of the item. 
03 
TOTAL-IN 
PICTURE 
PPP999. 
03 
TOTAL-OUT 
PICTURE 
999PPP. 
Both TOTAL-IN and TOTAL-OUT are three digit fields. 373 in TOTAL-
IN would represent 000373 and in TOTAL-OUT 373000. 
Editing Characters 
It is frequently not sufficient to describe an item as being η characters 
in length. The programmer, especially with printed output locations, 
wishes to be a little more explicit. He may wish to put the £ sign at the 
front of sterling values or suppress leading zeros or place + or — symbols 
at the front of numeric values. He can do this in COBOL with a whole array 
of editing characters. 
Zero Suppression Character Ζ 
The most common editing function is the suppression of leading zeros by 
using the character Z. As with all the editing characters the character is 
counted in the item size. In a PICTURE clause each Ζ represents one 
left-hand character position in which zeros are filled with spaces. 
If, therefore, we wish in the example used above to suppress unwanted 
leading zeros in the first two character positions, item field TOTAL-IN 
would be specified as 
03 
TOTAL-IN 
PICTURE 
ZZ99. 
Thus if the contents were 0036, the edited result would be 36. If the contents 
were 3063, the edited result would be 3063. If the contents were 0306 the 
edited result would be 306. If, however, the contents were 0003, the edited 
result would be 03. 
Cheque Character * 
Instead of unwanted zeros being left as spaces, they may be replaced 
by the cheque protection symbol *. As with Z, the character is used in 
much the same way and is always counted in the size of the item 
03 
TOTAL-IN 
PICTURE 
**99. 

D A T A D I V I S I O N I 
If the contents were as above, 0036, this would appear in the edited result 
as **36; 3063 would appear as 3063 and 0306 as *306. 0003 would appear 
as **03. 
Insertion Characters 
The insertion characters are a series of characters which the programmer 
may use to insert within a data item, usually on print-out, to make the item 
more clearly understood. The first of these is the £ character. 
Character £ 
The £ character represents a character from the set 0-9 space and £. 
It is counted in the number of characters. If used as the leftmost character, 
the £ sign will be printed out followed by the contents of the item. 
03 
TOTAL-IN 
PICTURE 
£9999. 
If the contents of TOTAL-IN were 0036, then the edited result would have 
been £0036. 
The £ character may also be used to suppress leading zeros, by also 
writing the £ sign in each character to be suppressed. The first character to 
the left of the significant digit will be a £ sign. 
03 
TOTAL-IN 
PICTURE 
£££9. 
If the contents of TOTAL-IN were 0036, the edited result would now be 
£36. 
The $ can be used in exactly the same way as the £ character. 
Character Β 
The programmer frequently wishes to make printed output more read
-
able by adding spaces to an item field. He does this by using the Β symbol
. 
03 
TOTAL-IN 
PICTURE 
99BB99. 
Thus if TOTAL-IN contained 3683, this would be printed out as 36 83. 
This type of editing function is, of course, extremely useful with sterling 
fields, where the programmer wishes to leave a space between the pounds 
and pence, to make it more legible. The Β character is included, of course, 
in the count of the number of characters in the item. 
85 

P R O G R A M M I N G IN 
C O B O L 
Comma and Decimal Point 
Both these insertion characters are used in the same way. They represent 
a character position which contains a character from the set space * £ + 
— S and, of course, comma and decimal point respectively. They may be 
used as the last character only if immediately followed by a punctuation 
symbol, ; or . 
03 
TOTAL-IN 
PICTURE 
99,99. 
Here, if the contents of TOTAL-IN were 3683, the edited result would be 
36,83. Similarly, 
03 
TOTAL-IN 
PICTURE 
99.99. 
would result in 36.83. Unlike the assumed decimal point V, the comma and 
decimal point insertion characters are counted in the number of characters. 
Character 0 
Zeros may be inserted in an item by use of the character 0. When data 
is moved to a receiving field containing O's, the two items are aligned by the 
decimal point and then the O's are inserted. 
03 
TOTAL-IN 
PICTURE 
99990000. 
Thus if the content was 3683 the final edited result would be 36830000. 
Report Signs 
Positive Sign + 
This character + can be used to represent a character position with 
contents from the set 0-9 space +- and —. If a single plus sign is written as 
the first or last character of a PICTURE clause, a display plus sign + will 
be inserted into the edited item if the source data is positive. If the source 
data is negative, a display minus sign — will be inserted. If, however, the 
source data has no sign it is assumed to be positive. 
03 
TOTAL-IN 
PICTURE 
+9999. 
Here the contents 0036 will be printed as +0036 and if the contents 
were — 0036 the result printed would be —0036. 
If more than one + symbol is used, the leading zeros, as specified, will 
be suppressed. If the data is positive, the rightmost suppressed character 
86 

D A T A D I V I S I O N I 
will be replaced by a + symbol. If the data is negative, then this same 
character position will have a minus sign inserted. 
03 
TOTAL-IN 
PICTURE 
+ + + 9 . 
If the contents as above were 0036 then the edited result would be +36. 
If, on the other hand, the contents were —0036, the result would be 
- 3 6 . 
Minus Sign — 
The minus sign behaves in much the same way except that when the sign 
is positive a space is left; the + sign is not printed. Leading zeros may be 
suppressed in exactly the same way as the plus symbol. 
03 
TOTAL-IN 
PICTURE 
- 9 9 9 9 . 
If the source data were —0036, the edited result would be —0036, but 
if +0036 the edited result would be 0036. 
CR and DB 
Both these sets of characters are used in the same way and both may only 
appear as the last two characters of a PICTURE clause. They are, too, it 
should be noted, always counted as two characters. If the source data is 
negative, the edited result will have CR or DB depending on which is 
specified. If the data is positive, the characters will be replaced by spaces. 
03 
TOTAL-IN 
PICTURE 
9999CR. 
03 
TOTAL-IN 
PICTURE 
9999DB. 
If the source data were negative, TOTAL-IN would contain 0036CR or 
0036DB depending on which choice is used. If the data were positive, then 
the result would just be 0036 in both cases. 
O T H E R 
C L A U S E S 
Class 
A data-name may be defined without using the PICTURE clause. There 
are a series of clauses which perform the same function as PICTURE 
characters. If a field is described by both CLASS IS, and PICTURE, the 
compiler ignores the CLASS clause. This makes it then rather superfluous. 
P.C.—D 
87 

P R O G R A M M I N G IN C O B O L 
/ALPHABETIC 
\ 
N U M E R I C 
CLASS 
IS 
< 
CLASS 
IS 
< 
ALPHANUMERIC 
| 
[ A N 
J 
The CLASS IS clause may be written at any level. If it is used to describe a 
group field, it then applies to every elementary item within that group. No 
contradictory statement may be made concerning any field in that group. 
ALPHABETIC defines a data item from the set A-Z and spaces. 
N U M E R I C defines a data item containing a binary, decimal, or sterling 
numeric value. ALPHANUMERIC, or its abbreviation AN, defines a data 
item containing characters from the COBOL character set. 
Example 
02 
TOTAL-1 
CLASS 
IS 
N U M E R I C . 
02 
NAME-1 
CLASS 
IS 
ALPHANUMERIC. 
Size 
The SIZE clause is used to specify the number of characters in a data 
item. As with the CLASS IS clause it is made superfluous by a PICTURE 
clause. 
Format 
fCHARACTERS Ί 
SfZE 
IS 
integer 
[DIGITS 
J 
This clause is normally only used with elementary items and if used with 
group fields it is considered to be for documentation purposes only. 
88 
Format 

D A T A D I V I S I O N I 
Format 
LEFT 
1 
Γ PLACES"! 
POINT 
LOCATION IS < 
> integer \ 
\ 
RIGHT 
[BITS 
J 
This clause is used to define an assumed decimal or binary point in 
relation to the right-hand end of the field. It must only be used to 
describe an elementary numeric field. The compiler will ignore the 
POINT clause if a PICTURE clause has been used. 
Example 
03 
TOTAL-IN 
SIZE IS 5 
POINT LOCATION IS LEFT 
3 PLACES. 
Editing Clauses 
There are two other methods of editing data items than using the editing 
characters of a PICTURE clause. Once again, if the PICTURE clause is 
also used, these clauses are ignored. As they are also more difficult to 
specify, they are not really recommended. 
Format 
Î
ZERO SUPPRESS 
\ 
' C H E C K ] 
- 
I PROTECT 
) 
LEAVING integer PLACES 
CHEQUE) 
FLOAT 
CURRENCY SIGN J 
[BLANK WHEN ZERO] 
89 
Example 
03 
CHRISTIAN-N 
SIZE IS 8. 
03 
SURNAME-N 
SIZE IS 12 CHARACTERS. 
Point Location 

P R O G R A M M I N G IN 
C O B O L 
90 
The first of these ZERO SUPPRESS is the same as a PICTURE clause 
containing Z's. If the option LEAVING integer PLACES is not used, it 
corresponds to a PICTURE clause which has one Ζ for each character of 
the field to the left of the decimal point. If the LEAVING option is used, 
the corresponding PICTURE clause has a Ζ for each character, counting 
from the left until there are "integer" more characters before the decimal 
point. 
Example 
03 
TOTAL-IN 
SIZE 5 
ZERO SUPPRESS LEAVING 2 
PLACES. 
This is the equivalent of 
03 
TOTAL-IN 
PICTURE 
ZZZ99. 
The CHECK or CHEQUE PROTECT option gives the same informa-
tion about cheque protection as a PICTURE clause containing asterisks. 
It has exactly the same relationship as ZERO SUPPRESS has above to a 
PICTURE clause containing Z's. 
03 
TOTAL-IN 
SIZE IS 5 
CHEQUE PROTECT 
LEAVING 3. 
This is the equivalent to 
03 
TOTAL-IN 
PICTURE 
--999. 
The FLOAT SIGN, as you would expect by now, gives the same as a 
PICTURE clause with leading £'s. It works in exactly the same way as both 
ZERO SUPPRESS and CHEQUE PROTECT. 
The BLANK WHEN ZERO option is used to describe a destination 
field when the programmer wishes the field to be completely blank when 
the value is zero. 

C H A P T E R 9 
Data Division II 
W E SHALL now look at the remaining clauses of the data division, which 
help to specify the format of data precisely. As the data division is slightly 
more machine-dependent than the other divisions, the method of using 
some of these clauses does vary from computer to computer. The reader 
should consult the relevant computer manual before using them. 
Usage Clauses 
In addition to the record description clauses such as PICTURE, the 
programmer can describe to the compiler the dominant use of a field by 
using the USAGE clauses. The compiler uses this information to decide the 
way in which the information is assumed to be recorded. 
Format 
' DISPLAY 
DISPLAY-1 
D1SPLAY-2 
DISPLAY-3 
DISPLAY-4 
USAGE IS 
< 
DISPLAY-5 
>-
COMPUTATIONAL] 
-
COMP 
1 
COMPUTATIONAL-1Ί 
11 
COMP-1 
1 
91 

P R O G R A M M I N G IN 
C O B O L 
5 
4 
1 
3 
0 J 0
 1
 0
 
1
 1 ' 0 I 1 
ο ! ο j ο
 1
 ι I ο I ο 
! ! 
ι 
l
i 
0 ,
1
 0 ι o I 0 
0 
1 
I 
I 
I 
I 
I 
I 
I 
! 
I 
I 
ο , ο j ο 
ο Ι ι ,
1
 ι 
FIG. 9.1. 
Each character is represented by a six-bit formation. If the number is 
negative, the operational sign is expressed by overpunching in the leftmost 
character. Thus -1 would appear as J, -2 as K, -9 as R. If the leftmost char-
acter is not overpunched, then it is assumed to be positive. Leading zeros 
are normally represented by zeros, but if the data is input from a punched 
card, the leading zeros may be spaces. When the object program converts 
to display, the leading zeros are represented by zeros unless explicitly 
suppressed by editing. 
Example 
03 
TOTAL-IN PICTURE 9999 DISPLAY. 
This description would specify a four-digit numerical field of a standard 
format to the compiler. 
As the 1900 series compiler assumes the standard format, it is super-
fluous describing a field as just DISPLAY. It is normally therefore left 
out completely. 
03 
TOTAL-IN PICTURE 9999. 
Many computers are not divided into fixed length twenty-four bit 
words, and so the appropriate manual should be consulted before use. 
92 
These clauses may be used at any level. If the clause is to be used to 
describe a group field, then the elementary fields within that group have 
the same description. There must not be any contradictory descriptions 
applied to them. 
Display 
In the I.C.L. 1900 series, data is normally recorded in standard character 
form with four characters per word as Fig. 9.1. 

D A T A D I V I S I O N II 
With decimal currencies DISPLAY-1, DISPLAY-2, DISPLAY-4 and 
DISPLAY-5 usage clauses are no longer necessary. They were used to 
define sterling values. 
Display-3 
This usage clause is used when the programmer wishes to use an 
additional character for the operational sign instead of overpunching in 
the most significant character position. This character may be either + or 
space for a positive value, — for a negative value. 
DISPLAY-3 is equivalent to DISPLAY. 
except, of course, for the fact that an additional character must be allowed 
for. 
Computational 
A field which is being described by the usage clause COMPUTA-
TIONAL must be numeric, and the compiler will assume that it is so if the 
programmer does not specifically state the fact. In the 1900 series, when 
arithmetic is being performed on a DISPLAY item, it is automatically 
converted into binary integer form, as this is the most efficient method of 
doing arithmetic. Thus if the programmer knows that a field is to be used 
in arithmetic calculations frequently, it will be more efficient to describe 
that field as being USAGE IS COMPUTATIONAL. If it is not described 
like this, the compiler will convert any way but will take longer to do so. 
The most efficient method of all from an object coding point of view is 
to transfer fields involved in frequent arithmetic calculations into a 
working-storage 
location 
described 
as 
COMPUTATIONAL 
and 
SYNCHRONIZED RIGHT. This will save the compiler "unpacking" 
the relevant fields. 
Example 
03 
TOTAL-IN PICTURE 9(6) COMPUTATIONAL. 
If the clause is not used, the compiler automatically assumes the item is 
DISPLAY. 
93 

P R O G R A M M I N G 
IN 
C O B O L 
Computational-1 
COMPUTATIONAL-1 specifies that a number is held in binary form 
and each binary digit is represented by a 1 in the PICTURE clause describ-
ing that field. 
Both COMPUTATIONAL and COMPUTATIONAL-1 may be written 
as COMP and COMP-1 respectively. 
Usage Clauses in General 
When an item is moved from one location to another, it is changed into 
the format prescribed by the usage clause in the description of the receiving 
area. Suppose an item has been described as follows after being read in from 
the punched-card reader: 
03 
TOTAL-IN PICTURE 99999. 
This may then be transferred by a MOVE verb into a working-storage 
location described as 
03 
TOTAL-IN-WS PICTURE 99999 COMPUTATIONAL. 
In the working-storage location the item will be stored in binary integer 
form, which is efficient for arithmetic calculations. 
it may then be later transferred to a receiving area described as 
03 
TOTAL-IN-P PICTURE 99999 
Here the item will be held as a decimal number. The conversion of the 
item from numeric to binary and from binary to decimal will have been 
done by the compiler. There is no need for the programmer with COBOL to 
build into his program binary or decimal routines, as with other lan-
guages. By describing the receiving field with the relevant usage clause, 
the conversion will be automatically carried out. 
Synchronized 
Normally the COBOL compiler allocates storage without taking into 
account the natural divisions of the core store. With the I.C.L. 1900 
94 

D A T A D I V I S I O N II 
series twenty-four bit fixed-length words, the compiler might allocate 
space as follows to these five items. 
Α ι Α ι 
Β 
ι 
Β 
Β J Β 
I 
Β ι C 
C 
ι 
C 
I 
C 
I 
D 
D 
I 
Ε 
I 
Ε ι Ε 
FIG. 9.2. 
This leads, of course, to efficient use of storage space, but as the 1900 
series manipulates words the processing time can be increased when an 
item needs to be extracted. Before using item Β above it will have to be 
"unpacked" from word 1 and word 2. If the item is only used once, this is 
a relatively minor problem, but if it is used several times in a program, the 
wastage in computer time does increase quite considerably. 
Format 
'LEFT 
Ί 
RIGHT 
ί 
The SYNCHRONIZED clause specifies that the data-item so described 
is to occupy the minimum possible number of 1900 series words and that 
no other data-item is to occupy the same word. Thus if an item is to be 
accessed several times during a program it is more efficient to describe the 
input area as SYNCHRONIZED LEFT or RIGHT. Better still, the pro-
grammer should transfer the item to a working-storage area, which has 
been SYNCHRONIZED LEFT or RIGHT. This will decrease the object 
programming time quite considerably and produce a more efficient 
program. 
The SYNCHRONIZED clause can only be used with elementary items. 
If the SYNCHRONIZED LEFT option is used, the unused storage will be 
in the least significant part of the word or last word if more than one word 
is occupied. With SYNCHRONIZED RIGHT the unused storage will 
be in the most significant part of the word or last word. Normally 
SYNCHRONIZED 
SYNC 
95 

P R O G R A M M I N G IN 
C O B O L 
non-numeric data 
is SYNCHRONIZED 
LEFT 
and 
numeric data 
SYNCHRONIZED RIGHT. 
Examples 
1. 
03 
TOTAL-IN PICTURE 9(6) SYNC RIGHT. 
2. 
02 
NAME-1 PICTURE A(7) SYNCHRONIZED LEFT. 
Occurs and Subscripting 
The OCCURS clause is used when a record contains a group of con-
secutive items with the same format and so the clause eliminates the 
necessity of separate entries for repeated data. 
Format 
OCCURS 
integer 
TIMES 
The clause can never be used to describe fields with level numbers 01, 
66, 77, or 88. 
The clause is obviously extremely useful as it saves writing out identical 
descriptions for each item and also saves us the tedious task of allocating 
separate data names to each item. All that is necessary is that the pro-
grammer describes the first item in detail using the other record description 
clauses as appropriate and then to state how many there are using the 
OCCURS clause. For example, a record containing five identical fields, 
each of which contains three numeric digits, would be described as 
03 
ITEM PICTURE 999 OCCURS 5 TIMES. 
Subscripting. Subscripting provides a means of referring to data items 
in a list or table that have not been assigned individual data-names. A 
subscript is a positive integer whose value determines the element being 
referenced in a list or table. The subscript may either be an integral literal, 
i.e. (6), or a data-name which has an integral value, i.e. (RESULT). 
When we wish to reference any of the items in the example above we 
would do so by adding the appropriate subscript in parentheses after the 
element being referenced. So the third item would be referred to as 
ITEM(3) 
96 

D A T A D I V I S I O N II 
or 
ITEM(RESULT) 
where the location RESULT was a one digit field containing three. 
In the procedure division it would be feasible to use subscripts with the 
appropriate verbs as in these examples. 
Examples 
1. 
MULTIPLY ITEM(3) BY 10 GIVING TOTAL-OUT. 
2. 
MOVE NAME(RESULT) TO STATE(REGION). 
3. 
IFSTOCK-NO(IO)... 
Groups of items as well as elementary items may be defined by the 
OCCURS clause and referenced by subscripts providing each group has the 
same format. 
Item 
Item 
Item 
Item 
Name 
Code 
Name 
Code 
Name 
Code 
Name 
Code 
FIG. 9.3. 
This table of four identical items would be specified in the data division 
as 
02 
ITEM OCCURS 4 TIMES. 
03 
NAME PICTURE A(7). 
03 
CODE PICTURE 9(3). 
97 

P R O G R A M M I N G IN 
C O B O L 
Each of these items could than be referenced by the programmer as 
ITEM(l) . . . 1TEM(4) 
NAME(l) . . . NAME(4) 
CODE(l) . . . CODE(4) 
Tables, of course, are frequently formatted at more than one level, and 
consequently more than one subscript is required to reference them. Up 
to three levels are permitted, and the subscripts are written from left to 
right in descending order, i.e. major minor order. These subscripts are 
written in one set of parentheses with a comma and space between them. 
If in the data division, the following were specified: 
01 
LIST. 
02 
SECTION OCCURS 6 TIMES. 
03 
PART OCCURS 10 TIMES. 
then PART (3,4) would refer to the fourth part of the third section. 
The entire table may also be referenced providing it has been given a 
unique name. All the elements in the table may be referenced as a group by 
using this data-name. As above 
MOVE LIST TO OUTPUT-LIST. 
The OCCURS clause can be used in both the file section and the working-
storage section of the data division. It is obviously useful in building up 
tables and lists within the working-storage section. A table frequently 
needs, though, a value to be allocated to each elementary item. The 
OCCURS clause cannot, however, be used in the same sentence as a 
VALUE IS clause, which as we shall see later allocates values. This at 
first seems a handicap, but along with the REDEFINES clause we are 
able to get round this point. 
Redefines 
The REDEFINES clause allows the programmer to refer to the same 
computer storage area by a different name. 
98 

D A T A D I V I S I O N II 
Format 
level-number data-name-1 REDEFINES data-name-2. 
This clause is used to specify that the data-name being defined by the 
sentence containing the REDEFINES clause commences at the same core 
store position as data-name-2. There is little point in using REDEFINES 
with a level 01 field in the file section of the data division, as the compiler 
arranges for different types of records in the same file to share the same 
storage area. An 01 level may be REDEFINED in the other sections. The 
level numbers of both data-names must be exactly the same. Data-name-2 
must be the last data-name defined at that level. The VALUE IS clause 
cannot be used with data-name-1 but can be used with data-name-2 or its 
subfields. 
Example 
01 
RECORD-IN. 
02 
TYPE-1. 
03 
CODE-NUMERIC 
PIC 
9(3). 
03 
CODE-ALPH 
PIC 
A(2). 
02 
TYPE-2 REDEFINES TYPE-1. 
03 
CODE-NUMERIC-2 
PIC 
9(2). 
03 
CODE-ALPH-2 
PIC 
A(3). 
In this example the area where type-1 is located can also be referred to as 
type-2. Here the programmer may have two cards which are both identical 
except for the first five columns. The first type has the first three digits of 
the code number as numeric but the second type only has the first two. 
The second half of the code number being alphabetic. 
Renames 
This clause permits alternative groupings of elementary items, which 
may overlap if the programmer wishes. 
99 

P R O G R A M M I N G IN 
C O B O L 
Format 
66 data-name-1 RENAMES data-name-2 [THRU data-name-3]. 
The clause always has level number 66 and may be used in two ways. 
First without the T H R U option it is used to give another name to a group 
or elementary item. The first data-name, data-name-1 has the same 
meaning, size, etc., as the second. With the T H R U option data-name-1 will 
include all the data-names from data-name-2 to data-name-3. 
Example 
66 
AREA-4 RENAMES LOCATION-1 THRU LOCATION-2. 
W O R K I N G - S T O R A G E 
S E C T I O N 
Once files and records have been specified in the file section of the data 
division, data may be transferred from an input file straight to an output 
file by means of statements within the procedure division. However, in 
almost every program it is necessary to create areas within the core store 
in which to store immediate results, tables, etc. There are areas of storage 
needed during the program which are not part of input or output files. The 
working-storage section deals entirely in the storage requirements of these 
immediate results. It is specified as: 
WORKING-STORAGE SECTION. 
77 
elementary-item-1. 
77 
elementary-item-2. 
01 
data-name-1. 
02 
data-name-2. 
03 
data-name-3. 
03 
data-name-4. 
The WORKING-STORAGE SECTION header is written commencing at 
column 8 and ending with a period. 
Both independent items and group items may be stored in the working-
storage section. Independent items are items which have no relationships 
with other items and are not grouped into records. These are given level 
100 

D A T A D I V I S I O N II 
number 77 and they cannot have subfields. Their names must, too, be 
unique within the program. 
The types of items stored with level 77 in the working-storage area are 
"count locations" in which the programmer stores a count of the number of 
transactions or occurrences of a particular event. This may be specified as 
77 COUNT-W-S PICTURE 9999. 
Frequently, too, as mentioned when we looked at the SYNCHRO-
NIZED clause, the object program is far more efficient if the items that are 
used frequently are either synchronized left or right in the input file entry 
or are moved into a working-storage location also synchronized left or 
right. This is doubly true if the item concerned is involved frequently in 
arithmetic calculations, when it is more efficient if the item is moved into 
the working-storage section synchronized and specified in binary format. 
To do this the programmer invents a location in the working store similar 
in attributes to the file section location. For example, if on a payroll 
application a field called "Hours-in" has been specified on input as 
03 
HOURS-IN PICTURE 999. 
a similar location at level 77 may be created in the working-storage section 
as 
77 
HOURS-IN-WS PICTURE 999 SYNCHRONIZED 
RIGHT COMPUTATIONAL. 
As this field is being used frequently in arithmetical calculations, the 
first task of the programmer when he requires this field is to transfer it to 
the working-storage section by using the MOVE verb. Once the field has 
been transferred to the working-storage section, the item is in its most 
efficient format for fast object programming. Naturally, if the item is only 
referenced occasionally in the program there is little point in going to this 
trouble. It will be better to reference the file section directly. 
The working-storage section may also contain groups of items which 
have a definite relationship with each other. These are grouped together 
into records according to the rules for record descriptions. 
Example 
01 
ITEM-1-WS. 
02 
AREA-WS. 
03 
TOTAL-1-WS. 
03 
TOTAL-2-WS. 
101 

P R O G R A M M I N G IN 
C O B O L 
VALUE IS 
literal. 
Examples 
11 
ITEM-WS PICTURE 9999 VALUE IS ZERO. 
77 
CONSTANT-1 PICTURE 99 VALUE 27. 
03 
NAME-WS PICTURE A(7) VALUE IS "ROBERTS." 
As you can see from the examples, the values may be numeric, non-
numeric, or figurative constants. If the value is a non-numeric literal, then 
the accompanying PICTURE clause must also be the exact size as the 
literal value. 
If a condition name value or range of values is being set, then the second 
format may be used. 
102 
Each level Ol name must be unique as it cannot be qualified by reference 
to a file name. 
The initial value of any item in the working-storage section may be set 
by using the VALUE IS clause. If the clause is not used the initial value is 
unpredictable. It is better usually unless a definite value is required to be 
stored in the location, to give the location a value of zero initially. 
All clauses which are used in the file section record descriptions may be 
used in the working-storage section. By convention it is usual to specify 
the level 77 items first. With some compilers this is not only conventional 
but also obligatory. 
Value Is 
The VALUE IS clause can be used in several different situations. It can 
be used to give an initial value to a working-storage location or to set a 
value of a constant in the constant section or to define the values associated 
with a condition-name. 
If the value of an item is being set in the working-storage or constant 
section, then only the first format may be used. 
Format 1 

D A T A D I V I S I O N II 
Format 2 
[VALUE IS 
1 
J 
L l i t e r a l - l [THRU 
l i t e r a l - 2 ] [ l i t e r a l - 3 
[VALUES ARE J 
[THRU literal-4]] . . . 
We shall look at examples of this format in conjunction with condition-
names. 
The VALUE IS clause cannot occur in the same sentence as an OCCURS 
or REDEFINES clause. There is too little point in specifying the value of 
a file-section item as the values of fields in this section are undefined at the 
start of the object program. 
Tables 
Frequently, as you can imagine, the programmer wishes to build up 
within the working-storage section a table containing a string of values, 
bonus rates, stock buffer levels, etc., that he wishes to access during the 
run. As we saw with the OCCURS clause, the first part can be done 
quite simply. 
02 
TABLE-1 OCCURS 8 TIMES. 
03 
ITEM-NAME PIC A(7). 
03 
ITEM-CODE PIC 9(3). 
We can access the third ITEM-NAME by subscripting ITEM-NAME(3) 
or ITEM-NAME(NUMBER) where the field NUMBER holds integral 
numeric values. Unfortunately, to be of real use, the table needs to be 
able to store values, and the same sentence cannot contain both an 
OCCURS and VALUE clause. 
To get round this problem, we first of all create a table, giving each item 
a value. Then by use of the REDEFINE clause we redefine the storage area 
and use the OCCURS clause. 
103 

P R O G R A M M I N G IN 
C O B O L 
02 
TABLE-1. 
03 
SCREWS PICTURE 99 VALUE 25. 
03 
NAILS PICTURE 99 VALUE 36. 
03 
BOLTS PICTURE 99 VALUE 17. 
03 
WASHERS PICTURE 99 VALUE 27. 
03 
TACKS PICTURE 99 VALUE 19. 
03 
PINS PICTURE 99 VALUE 22. 
02 
TABLE-2 REDEFINES TABLE-1 PICTURE 99 OCCURS 
6 TIMES. 
Thus the original layout with values has been specified with the name 
TABLE-1. This area has been redefined as TABLE-2 and so reference to 
TABLE-2 is reference to the same area as TABLE-1. As we have also used 
the OCCURS clause, TABLE-2 can now be subscripted. TABLE-2(4) 
will now access the fourth item of the table WASHERS a value of 27. 
In the procedure division the table of values could be used as follows: 
SUBTRACT TABLE-2(NUMBER) FROM QUANTITY-N 
GIVING RESULT. 
IF RESULT IS NEGATIVE . . . 
C O N S T A N T 
S E C T I O N 
The constant section is used to define constants that are frequently 
used during the course of a program. It is organized in exactly the same 
manner as the working-storage section. Independent items which bear 
no relationship to other fields are given level 77. Group fields are specified 
as they would be in the working-storage section. 
CONSTANT SECTION. 
77 
elementary-item-1. 
77 
element ary-item-2. 
01 
data-name-1. 
02 
data-name-2. 
03 
data-name-3. 
03 
data-name-4. 
The heading CONSTANT SECTION commences in column 8 and ends 
with a period. Level 77 items by convention come before group items. 
104 

D A T A D I V I S I O N II 
The main use of the constant section is to store constants, which can be 
referred to by their data-name, making them more easily accessible should 
they need to be changed. If a bonus rate constant of 15 pence were 
frequently used throughout the procedure division and this had been 
written as a literal 15 in the program, it would be extremely long-winded 
to alter every line of the procedure division, where it had been used, should 
a change be necessary. By giving it a name, however, and a value in the 
constant section, the programmer can then refer to it by name in the pro-
cedure division, e.g. 
A D D BONUS-RATE TO TOTAL-WAGE. 
If it becomes necessary to alter the bonus rate to 20 pence, this is much 
easier as only the one tiny section needs to be altered. 
Examples 
02 
BONUS-RATE PICTURE 99 VALUE IS 15. 
02 
INTEREST-RATE PICTURE 99 VALUE IS 12. 
No data can ever be moved into the constant section. 
L I N K A G E 
S E C T I O N 
The linkage section may only appear in subroutines. It gives a description 
of the parameters used in the subroutine. 
The heading LINKAGE SECTION commences at column 8 and ends 
with a period. 
LINKAGE SECTION, 
data description, 
data description. 
Only COBOL subroutines may have a linkage section and the section is 
placed immediately before the procedure division. No other 
COBOL 
program may have a linkage section. 
Other compilers treat their subroutine parameters in a different way, 
and therefore reference must be made to the appropriate manual. 
105 

P R O G R A M M I N G IN 
C O B O L 
Condition-names 
We first looked at condition-names in Chapter 5 when we were examin-
ing the IF verb and conditional statements in the procedure division. In 
that chapter we saw the condition-names in practice; now we will see how 
they are originally specified in the data division. 
Format 
88 
condition-name 
VALUE-clause. 
Condition-names are always given level 88 and may be written in any 
section of the data division. They must immediately follow the data-item 
they are associated with except when other condition-names intervene. 
In Chapter 5 we used the following example to illustrate the potential 
of condition-names: 
IF HOME GO TO HOME-PARA. 
IF EXPORT GO TO EXPORT-PARA. 
IF RE-EXPORT GO TO RE-EXPORT-PARA. 
HOME, EXPORT, and RE-EXPORT are three condition-names associ-
ated with an input item called ITEM-SECT whose value ranges from 1 to 
29. If the value is 1-9 we jump to the HOME-PARA; 10-19 EXPORT-
PARA; 20-29 RE-EXPORT-PARA; and we gave them their respective 
condition-names Home, Export, and Re-export. 
These would be specified in the data division like this: 
02 
ITEM-SECT PICTURE 99. 
88 
HOME VALUE 1 THRU 9. 
88 
EXPORT VALUE 10 T H R U 19. 
88 
RE-EXPORT VALUE 20 T H R U 29. 
As we said in Chapter 5, this rather simple method can save a tremendous 
amount of tedious programming. 
Condition-names may also be associated with fields that contain an 
OCCURS clause and may thus also be subscripted. 
106 

D A T A D I V I S I O N 11 
02 
DATA-NAME PICTURE 9999 OCCURS 5 TIMES. 
88 
CONDITION-NAME VALUE 6 THRU 12. 
So in the procedure division we could program as 
IF CONDITION-NAME(4) . . . 
QUESTION 
Specify the file section and the working-storage section of the data 
division for the following: 
(a) Paper-tape input file called TAPE-FILE with a fixed length record 
called P-TAPE-IN. 
This record is subdivided as follows: 
Level 1 
Level 2 
NAME-i 
Level 3 
SURNAME 
INITIALS 
No. of characters 
12 alphabetic 
3 alphabetic 
P-TAPE-IN 
CODE-NO 
DEPT-CODE 
4 alphanumeric 
4 numeric 
QUAL-1 
DEGREE 
PROF-QUAL 
7 alphanumeric 
4 alphanumeric 
(b) Print output file called PRINT-FILE with a record called PRINT-
LINE, 120 characters in length equal to one complete line of print. This 
record PRINT-LINE consists of the equivalent of the above fields in 
P-TAPE-IN. They are given the same name with the addition of a hyphen 
P, i.e. CODE-NAME-P. There is one extra field ANNUAL-SAL, which 
is a sterling field consisting of ten characters, two characters for the pence 
field, with a space between the pounds and pence. The four leftmost 
characters are zero suppressed and preceded by a sterling character. 
The fields are evenly spaced with blank fields in between. 
(c) Working storage. In the working-storage area there are three locations 
for intermediate work—a count location, two numerical digits in length 
with an initial value of zero, and two working totals—TOTAL-WS-1 and 
107 

P R O G R A M M I N G IN 
C O B O L 
GRADE-1 
50 
GRADE-2 
75 
GRADE-3 
100 
GRADE-4 
125 
GRADE-5 
150 
GRADE-6 
175 
ANSWER 
DATA DIVISION. 
FILE SECTION. 
FD 
TAPE-FILE 
LABEL RECORDS OMITTED 
DATA RECORD IS P-TAPE-IN. 
01 
P-TAPE-IN. 
02 
NAME-1. 
03 
SURNAME 
PIC A(12). 
03 
INITIALS 
PIC A(3). 
02 
CODE-NO 
PIC X(4). 
02 
DEPT-CODE 
PIC 9(4). 
02 
QUAL-1. 
03 
DEGREE 
PIC X(7). 
03 
PROF-QUAL 
PIC X(4). 
F D 
PRINT-FILE 
LABEL RECORDS OMITTED 
DATA RECORD IS PRINT-LINE. 
108 
TOTAL-WS-2, with four digits each, which are to be used for arithmetical 
calculations and so are specified for efficient working. 
There is also a table of values stored as follows, which will be accessed 
during the program. 
Value 

D A T A D I V I S I O N 
II 
01 
PRINT-LINE. 
02 
FILLER 
PIC X(5). 
02 
NAME-1-P. 
03 
SURNAME-P 
PIC A(12). 
03 
FILLER 
PIC X(2). 
03 
INITIALS-P 
PIC A(3). 
02 
FILLER 
PIC X(10). 
02 
CODE-NO-P 
PIC X(4). 
02 
FILLER 
PIC X(10). 
02 
DEPT-CODE-P 
PIC 9(4). 
02 
FILLER 
PIC X(10). 
02 
QUAL-l-P. 
03 
DEGREE-P 
PIC X(7). 
03 
FILLER 
PIC X(5). 
03 
PROF-QUAL-P PIC X(10). 
02 
FILLER 
PIC X(10). 
02 
ANNUAL-SAL 
PIC ££££9999B99. 
02 
FILLER 
PIC X(16). 
WORKING-STORAGE SECTION. 
77 
COUNT-WS 
PIC 99 VALUE IS ZERO. 
77 
TOTAL-WS-1 
PIC 9(4) SYNC RIGHT COMP. 
77 
TOTAL-WS-2 
PIC 9(4) SYNC RIGHT COMP. 
01 
VALUE-TABLE. 
02 
GRADE-1 
PIC 999 
VALUE IS 050. 
02 
GRADE-2 
PIC 999 
VALUE IS 075. 
02 
GRADE-3 
PIC 999 
VALUE IS 100. 
02 
GRADE-4 
PIC 999 
VALUE IS 125. 
02 
GRADE-5 
PIC 999 
VALUE IS 150. 
02 
GRADE-6 
PIC 999 
VALUE IS 175. 
01 
VALUE-TABLE-1 REDEFINES VALUE-TABLE 
PIC 999 
OCCURS 6 TIMES. 
109 

C H A P T E R 10 
Testing COBOL Source 
Programs 
A F T E R the source program has been written, there comes the moment of 
truth for all good programmers—program testing. This can be a most 
humbling occasion when they suddenly realize that there are more errors 
in the program than they dreamt were possible. 
E L I M I N A T I N G 
P O S S I B L E 
E R R O R S 
Many programming errors can be eliminated at source by following 
certain basic rules. 
1. Flowcharting 
With 
COBOL, as with other languages, a good logical flowchart and 
spécification, written before the program is attempted, will eliminate 
many syntactical and logical errors. 
2. Systematic Desk Checking 
Once a program has been written, a thorough desk check will also 
eliminate many needless errors and computer test runs. Special emphasis 
with COBOL programs should be made on checking that the following are 
correct : 
(a) Periods. The programmer should ensure that all periods have been 
included at the end of statements. 
(b) Sequence numbers. These should be checked to make sure that all 
numbers used in columns 1-6 are in ascending sequence. Other-
wise cautionary errors will be printed out. 
110 

T E S T I N G C O B O L S O U R C E 
P R O G R A M S 
(c) Identification symbols. If the programmer has used any identifying 
symbols in columns 73-80, all lines should be checked to make 
sure that they are identical. 
(d) Major section headings. All major section headings such as "data 
division" should be checked. If a particular section name is 
missing or is spelt incorrectly, then the compiler will list many 
of the subsequent lines as errors. The effect caused by the omission 
of such lines is far above their relative importance. 
Simple, petty errors in COBOL can cause a surprisingly high number of 
error statements. Therefore systematic checking beforehand is of the 
utmost importance and should not be neglected. 
P R O G R A M 
T E S T I N G 
S T A G E S 
Syntax 
The first stage is the testing of the program's syntax by the compiler. 
Here the compiler checks that all data-names and procedure-names have 
been specified properly, that all verbs have been used correctly, and that the 
program, on the face of it, is correct. 
Logic 
The next stage is for the programmer to test the logic of his program by 
testing each branch of the program with specimen test data. The test data 
should be so designed that any validity routines on input are thoroughly 
tested, that all input formats are acceptable, that possible movements 
about core are executed correctly, and that all print-outs appear as they 
should. 
The programmer should also ensure that all files created on magnetic 
tape or disc are done correctly. He should check that updating routines are 
accomplished properly and that file security is adequate. 
C O B O L 
F A C I L I T I E S 
D U R I N G 
C O M P I L A T I O N 
In order to assist the programmer in testing his program properly, the 
compiler gives him certain facilities. These facilities depend on the opera-
P . C . - E 
1 1 1 

P R O G R A M M I N G IN 
C O B O L 
112 
ting instructions or steering lines given by the programmer. Reference to 
the appropriate manufacturer's manual should be made for the specific 
format. 
Analysis Stage 
The first print-out that the programmer receives, apart from the steering 
line statements, is a card image list of his program. This will be printed 
exactly as it has been punched. At the bottom of the list will be printed a 
list of errors. Cautionary errors such as sequence number errors will be 
interspersed with the card lists. The error list will give the sequence number 
of the program statement plus an error reference number and some guid-
ance as to the type of mistake. By reference to the appropriate manual, the 
error reference number will give some help as to the type of mistake made. 
Each error should then be examined one by one to discover the cause of 
the error. Some will be straightforward and obvious, such as incorrectly 
spelt reserved words; others will be more complicated. Common sense 
thoroughness and "intuition" based on experience are the best tools for 
a programmer at this stage. 
There is with COBOL a ricocheting effect with some error statements, 
which can be disconcerting at first. The statement with the error reference 
may be correct in itself; the error message being caused by an earlier 
mistake. For example, it is possible for a program to have twenty or so 
"errors" listed when in actual fact there have only been three or four 
genuine mistakes. These three or four, however, may have a cumulative 
effect on the rest of the program. 
Generation Stage 
Once the programmer believes that his program is syntactically correct, 
he passes it through a consolidation stage, when the object program is 
generated. This consolidated program in machine code form is then used 
to test the programmer's test data. The programmer may at this point add a 
MAP instruction to his steering lines or operating instructions. This facility 
will give him a data map, giving a detailed layout of each file and data-name 
used in the data division, with the relative word address where the data-
name starts. Following the data map will be a program map giving the 
details of his procedure division in core store. This gives the appropriate 

T E S T I N G C O B O L S O U R C E 
P R O G R A M S 
113 
word address in core store, where each statement in the program begins. 
With the data map and the program map, the programmer has a concise 
guide to his program as it appears in the core store. 
Should his program fail or "go illegal", the programmer can ask for a 
further print-out, that of the core store, as it is when the program fails. 
This print-out will give the contents of each word of core store. In addition 
the console will indicate at which point the program failed. Thus by marry-
ing all these aids together, he can discover what went amiss. 
The core store print-out will also give the machine code instruction. 
This may also assist the programmer, if he is familiar with the machine 
code, to discover his error. 
The print-outs described above do vary from computer to computer. I 
have only described them in general terms. All the compilers have these 
aids, and the appropriate manual should be referred to to find out the 
specific layout of these print-outs. 
O T H E R 
F A C I L I T I E S 
There are, of course, other methods by which the programmer can find 
out what is happening to his program during the testing stage. These 
methods include the use of the procedure division verbs DISPLAY and 
WRITE. 
By using both these verbs the contents of certain locations may be 
printed on the console or the line printer at intervals during the program. 
Thus when the programmer is using an important loop he can ensure 
everything is going smoothly by printing out the contents of locations 
during the loop. Also by using parameter cards devised by himself, the 
programmer can arrange for different combinations to be printed out under 
different circumstances. This type of program testing is best left to the 
programmer's ingenuity depending on the complexity of the program. 
It is useful if these special tests are included in one paragraph so that 
they may be removed from the program once it is fully tested. 
Program errors can, of course, be maddening in any language. With 
COBOL certain types of errors cannot occur because of the high level nature 
of the language. Logical errors can, however, be more difficult to find, and 
so good systematic documentation and desk checking is essential. If these 
golden rules are observed and the facilities for program testing used to the 
full, COBOL programs should not present too much difficulty. On the whole 

P R O G R A M M I N G IN 
C O B O L 
114 
I believe the time between commencing and finishing programs can be 
reduced considerably with COBOL. 
COBOL is a programmer's language which leaves room for ingenuity 
and clever programming but which does not take an excessive length of 
time to write. Not perfect yet but much better than most. 

C H A P T E R 
I I 
Program Questions 
T H E R E are now two program specifications with possible solutions which 
may be attempted. 
These are only short programs, but they are designed to simulate 
industrial problems which occur in industry. They include most of the 
facilities of COBOL which a programmer usually needs to use in writing 
data-processing programs. 
Write the COBOL program which will do the following (Fig. 11.1). 
1. 
Read in stock issues notes, punched on to punched cards. 
2. 
Validate the class of card, rejecting if incorrect and displaying the 
number of the card on the console. 
3. 
Calculate the value of each stock issues card (quantity X price). 
4. 
Print out the "small issues" cards, i.e.: 
Price less than £1 in value. 
Quantity less than 10. 
Item code 1050-1100. 
5. 
Write to magnetic tape all other validated cards. 
6. 
Add all validated cards to the control totals. 
P R O G R A M 
Q U E S T I O N 
1 
Input Description 
Class of card 
Card number 
Date 
Digits 
1 
3 
6 
Numeric 
Numeric 
Numeric 
115 

P R O G R A M M I N G 
IN 
C O B O L 
• " " " " × 
/
\ 
ã 
Print 
I 
A 
J 
Ë
 
, . ^ ν ^
 
s
 
control 
Close 
\ 
J 
<
A
t
e
n
d
?
^ 
• 
totals 
h"" 
files 
-—L 
1 
^ ^ Ï ^ o 
Open files 
y^^^. 
^
n , 
/ ^ s . 
No 
Display 
Class of 
\ . 
,, 
, 
. 
,,, 
< 
j 
ç 
> 
card rejected 
I 
, 
1 
\ . 
card - 1? 
,
J 
I 
^ s . 
and card number 
^
^
l
5
 
P i i c e ^ ^ 
Yes 
\ 
( 
C 
) 
Move zeros to 
I 
No 
line count 
I 
. 
I 
Yes 
<
 
q
U
a
n
t
'
t y
 
> 
m 
( 
D 
] 
less than 
" 
V 
y 
j No 
Write heading 
| 
Multiply price 
I 
by quantity 
'
1
 
giving value 
Move spaces 
to heading 
I 
Add quantity to 
I 
control total 
Ö 
r
3 ^ 
I 
Add value to 
J 
control total 
Read a card 
I 
/ w r i t e \ 
1 
/ 
to 
j 
I 
mag J 
Vtape/ 
Ã~ 
Fio. 11.1(a). 
FIG. 11.1(b). 
116 

P R O G R A M 
Q U E S T I O N S 
Multiply price 
by quantity 
giving value 
Add quantity to 
control total 
Add value to 
control tcta! 
Print 
record 
FIG. 
11.1(C) 
117 

P R O G R A M M I N G IN C O B O L 
Digits 
Departmental code 
3 
Item code 
4 
Quantity 
5 
Price 
5 
Description 
15 
Magnetic Tape File Description 
Word-count 
Date 
Departmental code 
Item code 
Quantity 
Price 
Value 
Description 
Digits 
24 
Binary digits 
6 
Numeric 
3 
Numeric 
4 
Numeric 
5 
Numeric 
7 
Numeric 
10 
Numeric 
15 
Alphabetic 
Output Description 
The "small issues" cards are tabulated under a heading "small issues" 
and neatly laid out. 
Departmental code 
Item code 
Quantity 
Price 
Value 
Description 
Digits 
3 
4 
5 
7 
10 
15 
Numeric 
Numeric 
Numeric 
Sterling 
Sterling 
Alphabetic 
At the bottom of the list one extra line is printed giving the description 
"control totals" followed by the total quantity and total value. 
118 
Input Description (contd.) 
Numeric 
Numeric 
Numeric 
Sterling 
Alphabetic 

P R O G R A M 
Q U E S T I O N 
1 — A N S W E R 
Cobol 
title 
sheet number 
' 
program Sheet 
programmer 
date 
S e q u e n c e N o . 
. 
i d e n t i f i c a t i o n 
1 
6 7 8 
1 1 1 2 
1 5 
2 0 
2 5 
3 0 
3 5 
4 0 
4 5 
5 0 
5 5 
6 0 
6 5 
7 0 
7 2 7 3 7 5 
8 0 
, , JoO 
×Ã^ΙÅÃÉΝ Ô - é × - . É i JCJ ÁΙ-Ð×ÉΟÉΝΙ 
l à i X ï v l x S i X Ï O i l J . i Ι Ι Ι I Ι Ι t Ι I Ι Ι Ι Ι I Ι Ι Ι Ι I Ι Ι Ι Ι I I Ι Ι Ι I Ι Ι Ι Ι I Ι Ι Ι Ι I Ι ò,L, 
, , ι ι 
! 1 
J l O l O 
, , I P,ft,OicUiAin,-iJii. ι 
ι S ixlc é ICi Ο, I é .1 
ι ι ι ι I ι ι ι t I ι r ι ι I ι ι • ι I ι t ι ι I ι ι ι ι I ι ι t é I ι ι ι ι I é C L , 
I , é é ι 
! 1 © ï 
, , I 
A.UiT.Hlo./ti . . i d . ιÕº . iLifllNiCifli&i-rlf.A. ι ι I . ι ι ι I ι ι ι ι I é . ι ι I ι ι ι ι I ι ι ι ι I ι ι ι é I ι ι ι ι I é C L , 
, , é é 
I 
, , , I , , , , I , , , , I , , , , I , , , , I . 
. , . I . , . . I . 
. 
. . I . . . . ! . . . . I . . . . I . . . . I . I é I é é I é _ 
. 
i b - ß è , è 
£éÏ é Ã4.Ë>É CI ÇΙÔº ."ïJxïViX.SiJoiisJi . I 
I I Ι 
I 
I 
I I Ι 
Ι 
Ι 
Ι I 
Ι 
Ι 1 I I Ι 
Ι 
Ι 
Ι I Ι 
Ι 
Ι 
Ι I Ι 
Ι 
Ι 
Ι I Ι 
Ι 
Ι · I Ι 
Ι 
Ι 
Ι I Ι 2.L. I , é , é 
S O 
Ï 
C , o , 
Xi C P U ^ U . T - ^ O I J 
iSifiCiT-lxTOirJi . é I ι ι ι ι I º ι é é I ι é é ι I , ι ι ι I é ι é ι I ι é é ι I é é é é I ι é ι é I ι 
Q.Li 
é é é é 
b ο ο 
, , I 
SiO.U.elciÊi-,CIOUIP l U . T . J £é . ι 
IXTCIL.-I I.Qiol/ r . ! 
ι ι I I t ι ι I ι é ι ι I ι ι é é I é ι é ι I é ι ι é I Ι ι 
I ι I t 
C L , 
, , , , 
, 
. V l O i Ö 
, , é O . & . r r e l d T - , - , C I O U I P I U I T I Ê I A . . , I X C I L . - I I . Q I O I I I . ι , , I , ! , . I ι , , , I , , , ι I , , é , I é , ι , I , , ι , I , Q.Li 
I I . . . 
, 
, €,oo 
, , 
! 
éçå-éÑßéΟÉΛ, í, .s.xlae-. ,3,οÉο,ο, nJ,ole,i,s,., I , , , , I , , , , I , , , 
, I , , , , I , , , , I , ι ι , I , ! , ι I é C L , 
I , , . , 
, 
ι i 
ι , 
i ^ i O i O 
X N i p ' u Ô!— IO|UIT-ÏP,U,T, 
ISIÊ-I C i T i x l o i l J i . é é I é ι , ι I , ι t é I ι ι é ι I t é é ι I ι é é ι I é ι é é I é é é é I ι ι é é I é 
C L , 
I , é , , 
é 
é 1 ι O i O © 
Ρº÷ Je - , C O , J f i C O , Li . I é é é é ! é é é 
, I , ι é ι ! , t ι é I é ι ι ι ! é é ι , I é é ι é I é é é é I é ι é é I ι ι é ι I é 
C C 
I , , , , 
I 
\ i l ο ο 
, , I 
S . E . U E I C . T . iC.Jeifc.-.É.xlLje. 
. A,sls,X,C,r>l, Ic.ft.fc.i.-lie.Ê'.Ai.fc.dfi 
i d . - 
, , 
é ι 
é ι é , I é ι , é 
, é ι , 
ι CL, I , , , , 
! 
I :ΛιÏ Ï 
s.e.L. elc-r. ,/*\,AIC-,Ô-,Á,ΡÉÅ,-,Ρ,×Ι JE, ,A,s,slx,c,rJ, .il ,ô, A Ρ, <rl s,. , . , I , . , , I , , , , I . , , , I , , , ι I , CL, 
, 1 1 . 
t 1 Ï ο 
I , i S ^ I L E I C T . 
, Ñ Ι âÉ÷,Ν,Ô.-, J r i L,b, I A I S , S , X , C , J 
, Ñ , fc,X, J Ô, ÅÃ,Λ. ,/L. 
ι . . I > . . . I . . . ι I é ι ι é I . . ι t I . CL, I , , , , 
, 
, ! 
, I , , , , 
ι , l,L, C O 
, Á, ô Á 
l i X i vlxSiXi Ïé (4 . é 
, 
é é I é é é é I , é é 
, I ι ι é é I é é é é I é , é é I , t , ι I , é é é I I 
I ! é I I é é é I é 
Q.Li I I I , , 
i l 5*, Ï Ï 
fix, J å 
, S . E I C J T I X . O . I J , . 
I é 
I é ι é t I ι é é , I ι é é > I I' é ι é I é é ι · I é é ι é 
, é é > I é é ι ι I é ι ι é I I 
CL, I , , , , 
1 . L e o 
! 
C,A,/e,iÉ-.Ρ,× Ll À ι é ι é I é 1 M 
1 , ι ι 
. ι é é 
é 1 M I ι ι ι 1 I ι é é ι I 1 1 1 1 
1 1 M 
M ι é 1 1 
CL, 
I , , , , 
é I 
Ï Ï 
L.A.Ô.JL, 
>it,e,c!o,(6,î).5- U.ß.e, ,ο ÉΛ,×,Ô,Ô, d, , , , ! , , , , I , , , , I , , , , I , , , , I , , , , 
, , , , 1 , CL, ! , , , , 
, 11 8, Ïé ο 
ï i A . - r . J 
i t C C i Û £IJ> é 
. X i i l 
IXI S I S ,ul Å , Ë , . , , 1 -, , , , Ii 
é 
, 
, I , é , é I é 
, , 
, I é - é é I é é , é I . é é é I 
é 
Q, L, I , , , , 
ι , I ι Ρ ι õ ι Ο 
I 
X . S . S - U I E I - S , . é , I I I Ι ' 
é Ι Ι Ι I Ì 
Ι Ι 
Ι , 
Ι Ι 
Ι é Ì 
I Ι Ι Ι Ι 
Ι Ι é Ι I Ι Ι Ι Ι 
Ι Ι Ι Ι ! Ι Ι Ι Ι I Ι 9 , L 
I é é é é 
, 
,Á,ο,ÏéÏ 
, , I 
0,3á. L.'ci-.o.P.-k , • , I , , . , |p.x.c, Á 
I 1 I ι . I · Ι
. 1 I I I I 1 I · I I I I . I I ! I I · I é I I Q.L ! , , , , 
611 

120 
Cobol 
title 
sheet number 1 
program Sheet 
programmer 
date 
S e q u e n c e N o . ^ 
^ 
i d e n t i f i c a t i o n 
1 
0 7 8 
1 1 12 
15 
20 
25 
30 
35 
40 
4 5 
50 
55 
60 
65 
70 72 73 75 
80 
! | â , 1 I O O 
. , é 
0 ( 5 , ! !c.!Al*i>!-U ΟΙ I I I : : . I I P I X . C . 
| 0 . É ( , 3 Ë . . . I É Ι , é I . é é , I é , , , I é . , , I , , , , I , , , , I , 
C . L i ! , 
Ι Ι Ι 
I 
Ï . 2 . , UiAi-Ã,å,-!÷é Ì, é , ! , , , é É Ρ , × , Ï .oJdfeiV.i I é é i é I . ! é é I é é é é I é é é é I , , , , I , , , , I , 
Q . L I 
, 
, 
, Ι 
' 
Ô i â l O l O 
! 
, , I ο,α, 
. hb,er,P,-n-c,o,V£, I , , , , IPX.C .oJc.ä.},., 
, , , , I , , , , I , , , é I , é , , I , , , , I , , , , I , C L 
, , "é é 
é i3lU-,OiO 
! 
I I I 
Ï Ï é é 
T, Ein. J é- é é é I é î t é I , . é . I , , . é I é , é é I , , , é I é , , , I , , , , I , , é é I é é é , I é 
2.L. 
I • . , , 
! l?lff|0'0 
é ; i ; , , !o,i, , 
, L-r.E-^Jc.O.rh.Ι, 
P , X , C , 
, Á ß , À ÷ Ë , . , I é , 
, , I , 
, é , 
, 
, 
, 
, 
, 
, 
, 
, I , , , , I , , , , 
, C L , I , , , , 
é iôi(ai©,Q 
, , é 
, é é i , é 
I S , / * \ , A , J L , - I X , S , S L , £ I é é lv,fl,L.UiE,l 
Ι ×. 
S. 
. 1 Éο „S",0 . .ÔºΝ,Å,ÉÉΙ 
Ι I I f . Ï, 
ÏΙ · Ι 
é , é é 
, 
, , , L 
C L , I , , , , 
, avoo 
, , ί , , , ο,3, , , Idu.A.^.-rJxT-ny. é lp,x,c, .oJc,«},., I é , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , C Li I , , , , 
, , Û £ O Ô 
ι 
, , , ßο,3, , , |p,fi,x,c,el , , 
, 
, |P,XC, , q | 
, - L , , . ,.... ! \ , · , . . ·, I , , , , I , , , , I , , , , I , , , , I , CL, ! , é , é 
é é ß ^ , Ï . ο 
i 
• : , ο , 3 , , , Le.s.cftl 
, , é , lp,x,c, ,AICÎ,S-,),.1 . , , . I , , , , I , , , , I , , , , I , , , , I , , , , É , CL, I , , , , 
! 
Î ^ O . O . Q 
ο ^ é . ih,x,i-,i_:de, 
,
,
,
,
,
,
, 
|p,xrc, 
I , 
, 
, 
, 
, 
, 
, 
, 
, 
, 
, 
, I , 
, , , L 
, 
, 
, 
, 
, 
, 
, I , G.L, I , . ·. 
! 
, , I , , , , 
3 I iOiO 
^ » • c i - i - r A i e . e . - l ^ x i L . e - i I é . . . I . - , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , 
C L , ! , , , , 
Ä.L.O.C!*:, 
ICI OI H Ô, A,X,NI,SI ,Ι,Ο. , £ \å, Co, *,î> s, 
, 
, 
, I , , , , I , , , , I , 
, 
, 
, I , , , , | , , , , | , , , , | , CL, I , , , , 
ί 
L, Á , ä, E!L , , fit :clo. 
s, 
Á,*,å, 
,5 IT, A ,tsi,i, Á! ß . i , , , I . , . , I , , . , I , , , , I , , , , I , , , , I ., , , , I , 
CL, 
! . , . , . 
: 
1 U ©.O 
ß 
N/.A.u.ule, .ο.ñ. É ÷ . : * , .÷.si , ".x.s.sL.e.s. ,ñº÷ß-,å. V I , , , , I , 
, 
, 
, I , 
, 
, 
, I , , 
, 
, I . , 
, 
, I , 
, 
, 
, I , 
é 
CL, I , , , , 
... .VSo ο 
, 
t ί 
A.C.TXJ í,Å, ,-ô,÷Éç å, ,xsl , 1 . , , I é , , , I , , , , I , , , , I , , , , I , , , , | , , , , | , , , , | , , , , | , C L , I , , , , 
3> Á -ô Á: . e . E . c . o k . i , 
,x,sl .-r.A.p.el-.ite-.colÄ.Ä.. , , I , , , , I , , , , I , , , , I , , , , I , , , , º , , , , I , C L ! , , , , 
, 
"2. "i ο ο 
I 
Ïé I , 
-r,A;p,e!-,R,E,c,o e  , . , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , ! , , , , ! , CL, ! , , . , 
! 
o.a. 
, 
,
,
,
,
,
,
,
,
, 
P,xc, . i l c a . t , ) , . I , , , , 
, , , , · , , , , 
, , , , 
, , , , 
, , , , I , CL, ! , , , , 
Λ Λ , ο , ο 
ι 
. I 
ο ι 5, 
, ^Á,ô,å,-'-Ã, 
,
,
,
!
,
,
,
, 
P . X . C , ,Qk,^Λ , . , 
, 
, 
, 
, I , 
, 
. 
, 
, 
, 
, 
, 
, 
, 
, 
, 
, 
, 
, , I , , , , 
, C L I , , , , 
I 
i L l C O l O 
' é ©,a: 
, li.e.PTi-lc.o.^.e.-l-r 
, 
, 
, ÉΡ,×,Ο, ,OJC'3,},., I , , 
, 
, I , 
, 
, 
, 
, 
, , , ! , , 
; 
, 
, 
, 
, 
, 
, 
, 
, 
, I , CL 
! , , , , 
, ,L, é ,ο,ο 
! 
Ï,Ñ, , É÷ô,å,/^,-Éôé ., é , I : , , , I é , , , 
, , , , I , , , , I , , , , 1 , , , , I é , , , I , , , , 
, , , , I , CL, 
, , , , 
L i 
Λ Λ 
ι 
. . . L, 
! 
- ~ I 
I— 
ft
 
J
, 
Á / . I\ 
! 
é 
é 
é 
é 
é 

Cobol 
program sheet 
title 
programmer 
sheet number 
date 
3 
Sequence No. 
1 
6 7 
t 
8 
1 1 
4 
12 
1ä 
20 
25 
30 
35 
40 
4 5 
50 
55 
60 
65 
70 72 
^ 
ident 
73 75 
ification 
80 
I 
é ! Ï é i ' é é .0 U A r>» Ô ×. Ô -ß : - Ô 
1 é I 
, Ñ × é Ï 
.
<
u
U
>
,
, 
, I , , , . 1 , , , , ! , , , , 
1 , • • • 1 , • é • 1 
I 
I 
I 
! 
i 
, 10,1, , é i Ñ é & é × Ci £l -.T. 
, é ß , é é 
, P L, c , • < w k > , . , . i . . . , 1 . . . . ! . , , , ! 
. 
, , , 
é , , , , 1 
q , , 
1 . , , . 
, , I 
é 
! 
1 
I 
, |0|i , , é ! V; AiL.Ui £é - é Ô é , é , , é 
, Ρ Ix, C 
,
<
u l 
l ,ΟΛ ,. I I , , , , 
é é é é I , é é é I é . . . 1 . . . . 1 
1 C l , 1 , , . . 
ι 
é I 1 
, Éè,3, , , !"h, Å"é£ ,t ; fej - é Ô , I • ! : 1 é 
.PIX.CL 
, A C 
1 , 5 1 ^ , . , I é .. é é I é é é é I é é é é I é 
, , , 1 é , , , 1 
. 
G il é 1 . , , , 
Ι 
, ! 
I 
, I , , , , ! , , , , ' , , , , I , , , , I , , , , I , , , ', I , , , , I , , , , I , , , ; I , , , , I , 
1 
1 1 1 ' 1 1 ' 
I 
Ñé C. ! 
ι 
i
 
1 
ß . , 
! , , , , I , , , , I , , , , ß , , , , I 
, . I é , , , 1 C L , I -, , , , 
, . 1 L I A . & I E Î I . ! , fc.F, C 0,£,2> , S , LißiEi 
On × Ô Ô å ô É ^ 
, , , 
é , é , ! , é é , I é é é é I > é é é I .é é i é I é ! l . . . J . . J _ l _ 
Q i L . 
I , , , , 
, , ! i.Arr.fl! 
é ß., Å C J fcCh, $ , , Á>] ÄL-£; 
! Ρ , Å ß × ÍéÔ\ 
I 
, rrio.T-iA.L.S L, f . é ,Jc",A,fc,X.wlc, ·, . . É . 
, , , 
é , , , , 1 
C L , 1 . , , , 
ß ï o o ο,.. I 
I
I
I 
Plß.|TT-. rjlT 
é Ëé Ul*T*l . I I I I \ • ! I ! ' 1 
, . I 
. . . , I . . . . I . . . . I . . . . I é , , , I , , , . 1 
Q | L, 
1 i ! é 1 
1 ! S". I é Ol© 
, . i 
0,11 
, IΙ.X.L.L.EU, 
,
,
,
,
,
,
, 
P,XC. 
,^Ι(,Ι,ΟΛ,.I , , , , 
, , , , I , , , , I . , , é I . , , , 
é , , , , 1 
_ L _ Ç.L. 1 
, é , 
0,1 
. 
l i p F i P i T , J C I O I > I Ê . J Ñ, é é é 
Pi=£C: 
I 
, XI! é é 
! , , . , I , , , , I , , . , I , , , , é , 
é , , , , 1 
C i L [
M
M 
! 
Oi 2 
, UiX.L.dJiCi , , é 
é , ; é 
Ñ , × ò -
I 
Ï Õ . ί . 
I , é ß , , , ! i , I I , 
! 1 I I ! É ! 
, , , 
é , , , , 1 
q,L L
i
,
, 
ι 
, , ι 
C I 
, |÷ôÃ.â,Ë,-1 Ñ, . , , , I , , , , 
, é é , ! , , 
, , I , , , , 1 
C L . ί , 1 1 , 
i 
, | è , 3 ' , , É÷º-ô, £.Λν-É dö,"b 
(ñ, . · ,ΡÉ×ÚΟ :×. C L ) ; . . . 
é é I I 
. º é I 
é é é é 
1 
, , , 
1 , , . . 1 
C L , 
I , , , , 
é , £Ë>, Ï,Ï 
, , ! 
, loi-ëÀ > i i flu 
el â, , ' ! i ! , I .plx.c, .÷, <É* ) . . .. I , . . . I . . . . I . . . . I . , , , 
é , , , , 1 
C L , 
I , , , , 
é ,5.^.0.0 
, , I 
, l o i i i , , l O i U , Á,Ν,ôÉÀÃÔ-, Õ,-, Ñé é , : 
, Pixie, 
, I , , , , ! , , , , I , , é , I , , , , 1 , , , , ! 
Q,L I , , . é 
I . ä|â |0 éÏ 
. , I 
, L,3, , é Ñ,×úÉ_.ß_;6-|â, , , é 
, , -, PIX.C, 
,×, ( . 5 º ; , · Ι . .1 . . Ι Ι I Ι Ι Ι Ι I . . . Ι I Ι . , , 
é , , , , I 
C L , 
I , , , , 
é ,5ΛιΟιΟ 
ι 
, Éο 131 , , IP./CX:, cel-iP, é , ! , é , , ΡÉ× C , ò , ß À ã >, , , ! , , , ," ! . . , , I , , , , I . , , , 
é , , , , 1 
C L, 
!
,
,
·
,
, 
é 
t) Ïé ÏéÏ 
é , I 
, | è , 2 , , , IF.X. u,L.rle, , , , I , • , 
,×,(.|ÀÃ.Õ. , é I , , . é I é , . é I é - é . I , 
, , , 
é , , , , 1 
C L , 
I , , , , 
, , I 
, Éï,3é , , IviÁ .u .uéåÉ - é Ñ, , , ! ß , , 
./•Le, 
9.Â.9.9, I .
.
.
. I .
.
.
. I . , , , 1 
é 
C L . I , , , , 
, ! 
, Éè,3, , , l^.xtL.LeU. 
,
,
,
,
,
, ,Px,c, , J s , y . . : \ . 
. . . I .
.
.
. I .
.
.
. 
I
. 
, . , 1 , . , , 1 
C L , 
I . , , , 
, , ! 
, |è·2é é . 
tailed*!-. 
Ñ. 
Ì
À
é
é 
.PIX.C. ^ Á.. Cl /...·?, J 1 - 1 
1 I ! é I é , é é I , é é é I é I , . I . , I , 
q , L , 
! , 
, 
, , 
, 
i t i U n O . O 
, , I á» 
, U,riL,L,el<: , . - : I , ! é . I é ! • é 
, PIX.C, 
C.U.L: ) , . . . , 1 I 1 1 1 1 1 1 1 1 1 M I I , 1 , 1 , , , , 
Ç,L, I , , , , 
121 

ææé 
Cobol 
program sheet 
title 
programmer 
sheet number 
date 
S e q u e n c e N o . 
t 
4 
^ 
i d e n t i f i c a t i o n 
73 75 
80 
1 
6 7 
8 
11 12 
15 
20 
25 
30 
35 
40 
4 5 
50 
55 
60 
65 
70 72 
^ 
i d e n t i f i c a t i o n 
73 75 
80 
é it-i-5,0 0 
O i l 
-TTOITIR] U SI · i é I é 
, I Ii , , é ! , , , 
I , , é , I , , é , 1 
1 , , 1 , 1 
Q l L , 
I ; , , , 
! i*>|k|ûlO 
, ! 
O i l , 
, 1 F, X i Li Li El'fci 
, , ι , , , , 
| ñ , « , , * (,5º<Ã,),. , , é é I , , 
, 1 , , , 1 1 , , , , 1 , , , 1 , , , , 1 C L , ! , , , , 
, 
( ο ^ , Ï , Ï 
, , I ï,α, , rrjo.-n-.J&s.c*. I , , , , |p,x,c ,Ji,l,r,V.| 
, , , , ! , , 
é 
1 
1 
1 
1 
CiL, ! , , , , 
1 
l4>|S|OiO 
! 
O i â i é UiüCLielßi 
. -J 
t. ^.., I , . . . I . , 
i , , é , I , , , , 1 
I , , , , 1 C,L, 1 . , , , 
! ifefl lOlQ ,, ι 
ï,3 , , lf,&,T,-,ûlu.A N . T . J r . V r 
, , P,X,C, ,òÀß,ã í., I , , , , I , , , I , , , , I , , , , 1 , , , 1 , , , , 1 CiL ! , , , , 
,, ι 
* l * l . I p l ^ L l LI eUl 
, I . , i , | Ρ * Ã , ,vl(,t,í., I , , , , I , , 
, 1 , , , , 1 , , , , 1 , , , 1 , , , , 1 C L , ! , , , , 
, ,*f,l iO,0 
, , I Ο,©, , ÃÔº0.ç-é - 1 JAIL õ,å, ! , , , , IPŒC, ,9.1c,9J ,B,9l9. é . , I , . 
h , , , 1 , , , , 1 
I , , , , ß 
CL, : · · . . , 
, , I Ο,Λ, , \f tsr, u ß, f\ t, 
,
,
,
,
,
, P,X,C 
, *| á-,<>,),.! , , , , I , , 
1 
1 
1 
! 
! 
C L , I , , , , 
, , I , , , ! , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , ! , , , , I , , , , I , 
I 
« , , I Ç Fi Ai^L-i Ν, Ci., I , 
, , I : , , , 
, , , , I , , , , 
, , , , I , , , , I , , , , ! , , , , ! , , , . I . . . , I , CL, ! , , , , 
, , ! O i i , 
, kcLLLgUi ! , , I , , , , lp,x,c, 
Ι,2,ΟΛ! . , , é , I , é 
1 
1 
1 
1 
, 1 CL, 
! . , , . 
, , ! 
, . I , , , . 
é iViSiö* 
÷ Í , ò , - s,T-,ôi e, Jc,£ 
ISIEICITIXIOI À · é é é , I , , , , I , , , , I , , 
, I , , , , i , , , , I , ,, ι , , , , 1 
C L , I , . , . 
ΝΛί, I 
ÏéÌßÁé JT,XITIVI-IWS , , I , , , , lp.r.c. 
,Ο,Éß,Ã, ), ×Ο,Λ,Ρ, ,slv,rsJ,C 
1 /dx-lCMiT, . i , , , 1 1 1 
1 , , , , i 
C L . I , , , , 
, 
é ^ , Ï , Ï 
7,7, I P|^it,η|g|-|U,5i ! , , , , I , , , , IpiXCi ,Ο,Éß,^,^, , . c L , i N A , 
islv.rJiC 
.jtlxi c,w,r,. I , , , , 1 , , , 1 , , , , 1 eu. I . . . , 
_ L 
I *Õ|â|Ï|0 
7,7, I 
V i A i L i J e , - , ^ , 
, é , , I , , , , Ñ ÷ , Ï , 4(, I ,©,) , lc.û-.Ë,Ñé 
IS , 
V . * J c, Éâ,÷,ò,Ç,ôôÉ., , , , 1 , 
1 , , , , 1 q.L, 
É, , , , 
é ,ÉÁ,Ο,Ρ 
7,7, I C,ö,hi,-rlerO , L , - è ! , , , , ! , , , , 
,q C, ^ ), , JA.UU.ÊI É× $, ZicJ&Oi 
I C I O L I P , ,Sivlr4,C .ULidcKT, . , 1 
CL, I , . . , 
é 
,€éÏ,0,ñ 
7,7, I 
c O i M . - r l / C O i L , - , J , , , , I , , , , ÉΡ.,.„ ,QIC,I,O,Î, IV.A.L.Ü. el . i s iJe",/C,Oi 
ICIO.AIPI ISIV.M C, 
ijdxiCiM.*7T. 1 
CL. I , , , , 
, ,8, 1,0,0 7,7, I 
, , I , , , , k x „ . ,9k, ,S,V, J e , fc.x.cL-r, . 
CL, I , , . , 
, , I . . . 
I . . . . I . . . , I . . . . I . . . . I . . . . I . . . . I . . . . I . . . . I . . . . I . . . . I 
I . 
é 
• 
, , I . . . I , . . , I , . . , I 
. . . . I . . . . I . . . . I . . . . I . . . . I . . . . I . . . . I . . . , I . , . . I . 
, , I . , , , 
, , I . , , I , , , , I , . , , I , , , , I , , , , I , , . , I , , , , I . , , , I , , , , I . , , . I , , , , I . , , , I , , . I , , , , 
,, Ã , , , ι , , , , ι , , . , ι , , , , ι 
ι . . . . ι . . . . ι . . . . ι . . . . ι . . . , ι . . , . ι , . . . ι , 
, , I , , , , 

123 
Cobol 
title 
program S h e e t 
programmer 
sheet number 
date 
5" 
equence No. 
1 
6 7 t 
8 
11 
4 
12 
15 
20 
25 
30 
35 
40 
45 
50 
55 
60 
65 
70 
^ identification 
73 75 
80 
é 
ä ß é Ï lO 
PißiOlC 
eVuifcltl 
i"i>.Xl vlxi SOTIOINI . é é é é· I é é é I I é I é é 1 1 1 1 1 1 1 i 1 1 1 1 1 1 1 1 I 1 1 1 I 1 1 ..!.!._] J_1._L_I—Li_ 
<?,L| 
Ι , , é ' é 
é SiJo o 
"2, EiClx" 
CIL, I , , é é 
é Ci Li Ο, Ο 
Ï,Ñ,Å,ÌΙ ,ÏÂßÌÑ.õΙ-Ãé , C , A , f c k , - , É i X J e , 
I O . U I T I P I U I T , , pjA.C-.-n JP.Ι.-.P.X1 CP. 
iPijJx.iM.Ti- é ^lx.CC,., 
1 , 1 1 , 1 
e.Li L , , ! 
é ! 8ι tSi Ï <5 
p,p e IA 
e.L. L . , . 
é 
8 ( ο è è 
^ é Ï , Ν / . J 
. X E . C O I E I Î , 
,ÔºοΙ ,L,rîisfi Ι I - I C O . U I J - r , .. 
. é I é . é é 1 t é I l I é é I . 1 l 
I 1 l l l I 1 1 1 1 1 1 
1 Q\L\ I , , , , 
é éäé^éÏ,Ï , , i 
h.O.V.el , ' * , , é I , é é é I é I é é 1 . é 1 I I é é . é I é é é é 1 . é é é I é é é é I I é 1 I Ι I é 1 1 1 1 1 1 t I 1 
Q.L. 
1 , , , , 
, , â 81 ο,ο , , 1 
"iS.ft.fll CL. , lits, S,U lEisI 
1 iLlX"isl-n é é é 1 
é é I I é I é I 1 1 1 1 I 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ! 1 I.L.I.... 
C , 
ß , , , , 
, 
g< * CÖ 
", , , 1 , ,", ,-rloi 
. H I E . A L J C . I N J . C . ' J ", é , , 1 , , , é 1 t é é é I é é é é I é é é é I é é é é I é é é é I é é é é I é 
C L . I , , , , 
é 
, ^ , Ï , Ï © 
, , 1 
W . I Î I I Î T I & 
I W . E I A L I T / . I N J . C . 
IftiÉiTïEi/d ,ËËéíéÁÀÍéÅé3ÃéÍ.èÉ iCi H. Á . Ν Ι Ν Ι Å º L. -, / 1 . . . é é 1 t é . é I é é é é I é t i.j.L.i. 
QiU Ι é é r é 
é · % \ Ïé Ï 
, 1 PYftiX/igl 
i S . P . A . J E l * . 
. T - i J . M i C . A . ^ Î . N . C . , I , é é . 1 é é é • 1 t é . • 1 é é é . 1 é •• • t 1 . é é » 1 é • t é 1 I <î,l 1 1 1 1 1 1 
ι 
^ é ο é Ï Ï 
P A C A 
<5,L, I , , , , 
é Ie) VOiO 
fc,e.A.il ,C,A,fti^l-!f=,X-iLiel 
éÁéÔé 
.FIN.^I .Col IT I OI é J r ^ l i a S Ä i M I . . . . . é é é é ! é é é é I é t é é I é é é é I é 
QiL 1 , , , , 
é 
9,li-iOO ,, 1 
X J F , 
.cJ-.O.P.-.cl 
II I S I 
-IJCVT-, ,E",Ju,A,/_, .ôÉ O. . 1 . .dû. .TTo. I p . f l . A . A i -
, é , . . . 1 .
.
.
. 1 C L , I , , , , 
, 
Á ^ , Ï é Ï 
, , ί r. i«. isL.A it_.L.-lar. S.S.U.tll 
<CiO. ,ôºè, , P.A.fcl A,-, S.» . I é . é . 1 . . é é 1 . é é é I é é é é i é é é é I é é é i 
Q,U I é é . é 
ι 
X, (i, .plfc.x.cÉi Ic.e,S.S. Éô.Ç.Á.éÏé I" ,Ïé I , Ï , ο Ι ο , ", 
, C , o l ,ÔÃ,Ï, , ñ| Á. Á Á. - . six. . . 
.
. I é é é . ! é é é é I é é > é I é 
Q.L, L i , , 
9 Ë À ï , ο 
I 
r;P. 
, d õ, Λ,M.r-, x i ô , V, .CEU.-S, ,Ô.ÇΙÁΙΝ. , Ι ,ΟΙ ,C.Û. ÃÃΙΟ. Ι Ñ, Á,ÁΙÁ,-, s , x , . I , . . . I . . . é I é . . é I . . é é ! é 
C „ I , , , , 
! , 9. S ,ο , ο 
Ñ, A,CA 
Q.L, 1 , , , , 
, ο, 9 ο ï 
I 
I 
I 
! 
1
 
! 
! 
! 
I 
I 
I 
I 
I 
P.C.C.P'o.C.^. 
ÑÁ ß Á - Ï! A L
C 
r H t u 
PIA, aA,-.c:o,M,T-X.olc. .. é é I é é é é I é é é , I é é- é é 1 é é é é 1..L-
e.u ! , , , , 
1 0 Ο ï ο 
ι 
Pi Rift, ί Ë 
C i . 1 i , . ! ! 
é é Ïé é ï Ο 
Ρ×.ο .\/, å! ,^.Áô,å! ,áô,é^, ,4ο, .b, Á,-Ã å,-,-ô, ., I , , , , I , , é . I , , . , I . , , . I . . . . I .· é . . I , , , • J . < U - 1 , - , , 
1 Ο  Ï Ï ,, 1 
I 
I 
I 
! 
! 
1
 
I 
I 
I 
I 
I 
! 
ΡÕΟ,Ν/,Å! .^,ñ,ñ,ôÉ-éï,ïË-åÉ 
,-ô,ï, ,^éå,ñ,ô,—,cio,^,Ê, — T t . , , , , ι , , , , é , · , , I ι , , , ! , , , é ι , ι , é é , 
C L , 
1 , , , , 
! I , Ï il ÏéÏ 
1 
1 1 
r v o . v . e ! ,x:-nE,n!-ic,o^,el 
m o . ,÷ίôºÅ,^,-, ïßï,^,å, -, ôÉ., , é é I é é é é I Ì é : I é é é é I é é é é I é é é i I ! 
QiL, 1 
, , 
, 
L _ 
J. C <4*<?.0. 
, , I 
/ç,Ï,í^ 
ιΟ, U A , JnX;T-,Vi-lvJ, & ,-ro , Ï, U-A .Ì ô-,×,Ô,ν,-ΙôÔ. , é é I é é é é I é é ι é I. é., é _ l _ J L 1 . t - 1 é é I . é é é • I ' 
C L ' , , , , 

124 
Cobol 
title 
sheet number 
program Sheet 
programmer 
date 
S e q u e n c e No. 
. 
identification 
f
t 
f 
1 
6 7 8 
1 1 12 
15 
20 
25 
30 
35 
40 
45 
50 
55 
60 
05 
70 72 73 75 
80 
I Ο ί ο ο 
! 
! 
I 
! 
1
 
i 
I 
I 
I 
! 
i 
! 
1 
ln.O'\<!6' ! Ρ' ÅΙ×' ΟΙÅ ! - 'Ü S 1 !-Ãè· |P||£;XlCl t l - l T T . I ! , I I I I I I I Ι Ι Ι ! I I . ! ! I I I , I I I ! I ι ! r • ' ! : ! 
Q 1 
1
 : , , , 
I O t Ο Ο 
! 
• 
I 
I 
i 
J 
I 
I 
I 
! 
I 
! 
! 
h;0,V fi i 
MIE:- :UJ;S ' 'Ôè> 
: V ; R (_, U é Fl - 1 ÔÇ , , 1 . , I 1 ! 1 I I ι . . ! I , ! | | | . , ! Ι | , ) . , ! , | • • 1 ! 
C L 
\ . , , , 
I ο -y ο Ο 
é 
I
l 
! 
t 
1 
1 
1 
1 
1 
1 
1 
! 
ß%ο,í:e\ ^bSicIfc: .-no. fe.&s.icej-.-n-., , | , , , , I , , , , ] , . , , ! , , 
, , I , , , , ! , , , , ! , , , 
· ί , 
CL, h 
, ι ι 
1 Ο 8 ï ο 
é 
, é I 
1 
! 
1 
! 
1 
! 
! 
1 
1 
I 
1 
! 
CL ι i . , , , 
I Ο 
Ο Ο 
J 
I 
ß 
! 
! 
1 
I 
1 
! 
1 
I 
1 
! 
CL. I · . , , 
Ì Ο,Οο 
Ρ, Ρ, K.U 
Ci Li ! ! ι . ι 
; I I 1 Ο ο 
, , ! 
Ρ 
Å:è!£..Ρν é Ρ! Á ι â. • Á, -, c Á. L.C, .TIH.^UI Ι PIA , £, Á,-, t! Ο,Ν,Ô, £, ok, . Ι ι . ! ι . ι ! ! . . t ι I ι ι ι t ! ι ι ι < i ι 
C, L I , , , , 
Ìι 5,ο ο 
i^.o.v.e: ."b.e.PTL I C O ; ï i m o , 
i^le.PiXi-, c i o - , p| ., , . . I ι , , . ! . , . ι I , , , , I , ι ι . I , . , . ! , Q.L ί , , , , 
1 i . 3 - 0 
0 
I r\o,v/,£i .÷-.ηå,Λ»!-.co.^.erl -no, ,×ÉÔ.ÅÃÎ%-,C!Û.^.E,-,Ρ., 
, , ι I , , , , I , , . , I , , , , I . . , , I , . . , ! , G L 
l i t Ο ï 
, , ß f*kû V.£ IQ.U.A.NIT.X.T.V ,JVJ,S, .-Ã,ο ,0,U,A,NIT,I:,T,V,-!P,. , , , I , ι , , I , , , , ! , , , , I , , , . I , , , , 
ι C L 
i , , , , 
, é é So ï 
I 
ç,ο.ν/,Å! Ρ cire £ - u s É-Ôο, ,p-eiiiCiE-.-.^l., > , , ! ι ι ι ι ! , , , , I , , , ι ! , , ι , ! , , , , I , , , , ! , C L I , , , , 
: ( I <èΟΟ 
i*VO,Vrd 
V A U õ ¸ , - US: ÉôÔÏ. ,V,AI L.<j.fc.-.pl. , ι M I ι I I ι I ι ι ι ι I ι ι Ì 
ι ι M I ι , ι ι I ι ι ι ι i ι 
C L j , , , , 
é é º ïï 
Ãº,Ο,ν,åΙ iVEiick 
,-Ã-,Ο, Li&Ι.Cifcl-.P. .ι ι I ι . , ι I ι , ι ι I ι ι ι ι I , ι ι ι I ι ι ι ι I ι ι ι ι I , ι ι . I . 
CL, I , , , , 
hi Soo 
Ρ,Á,Ê. Ρ 
! , . . . I , , , - I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , . , I , , , , I , CL, I , , i , 
• ß: é .q.o.o ,, I íß,â.é3=.ô·! Å, ,P,fc.ri Ν-Ô,-,Ο,UIT. ,Aif=i-r!ei/e., ,A,*JV,A,ÎVI,C,arl N,C, ,0, k 
NÎES |. , , , , 
, , , , I , , , , I , , , , 
, CL, 
I
I
!
,
, 
,1 SO ΟΟ 
, , é rvo.v.el 
S Ρ Ac å s, ,ôôοÉ ,P,R.:E N!XI-,O,U,TJ ., , , , I , , , , I , , , , ! , , , , | , , , ,. | , , , , | , , , , | , at. I , . . , 
i l A l i O O 
I Á,5>Λ, Lai .ô.ο· L,x, fJ.e, JciOiUi,s/.T-| . · , , , 
, , , , 
, , , , 
, , · , 
, ι , , 
, , , , 
, , , , 
, , , , 
, α÷, ! , , , , 
. / ä a ö o 
, , ί 
as ñ, , JxiN.e.-.cloiU,M,-r 
l&OiUiA.ulsî . ß . ο . Idο. ,-r,o! ,Ρ,Á,â, ÁÉ-, 2, IÉTIJS.Ê. .Col ,-r.o, , p| Á,â, A,-, 3Ι ., , , , I ι Ci-, 
I , , , 
Ρ. Á. «JA -.e.E.^E.cm .. I , , , , I , , , , 
, , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , 
α . 
. ».a Loo 
! 
i.X 
S. PL A V 
, *!C,A £,Ü>, Iß-.e.J-E.c l-re-.-i, , "I . C A . A i l - , Ν , Ο .. I . ι . . I . . ι ι I ι . , , I ι ι . . I . . . . I . CL, ! , , , , 
ι Ii S S 
, , ! Q,o. ð^ο· ,Ρ.Ρ,/t Ρ ι - , 3, . , I , , , , , , , , I , , , , I , , , , , , , , I , , , , I , , , , I , , , , I , , , , I , «.«.. I , . , , 
,1 ,ÛL.,0o 
P.p.fcU 
c.ft.u!c., , . I ! , , . ! , , , , I , , , , I , , , , I , . , , I , , , , I , , , , I , , , , I , , , , I , , , , I , C.L, ! , , , , 
ι. *\.vv r. r> 
. . I 
ç, 
Ã 

Cobol 
title 
sheet number 
7 
program S h e e t 
programmer 
date 
S e q u e n c e N o . 
| 
| 
^ 
i d e n t i f i c a t i o n 
1 
6 7 8 
11 12 
15 
20 
25 
30 
35 
40 
4 5 
50 
55 
60 
65 
70 72 73 75 
80 
1 
é 1 I 
r V o . V i F l 
iPiΙiticlei i-T-TOi >i<6iXiCi J - . U i i . é I é é é é I é é é é I é é é é I é é é é I é é é é I é é 1 1 1 t 1 ! 1 ! 1 
? L 
! é 5i9 é è ê > 
! 
f*VU. LIT! Β P.LI V. !diU é Á é Í - ô Ç ð Ô ú V,-itf!s. 
ifl.Vi 
1 P i E i X I C d l - I U / I S I 
i d a r . V.Xi « è ! 
I\/IA" 1 LiU 1 £i-iUi S> J 
M 
M 
1 1 M 
L G.L.. 1 , , , , 
, (, Z.o ,o iO 
-itieiNlritiCU. ß é . é . ! . , 1 1 1 , . , . I 1 1 . , ! 1 1 . 1 ! , , , , 1 é é 1 , I , 1 , 1 1 , , 1 , ' , 1 , , I , C u \ - , , , 
• 1 . ' i l l , 0 · Λ 
1 
1 1 1 
A 
I O I U I A . N . T I T I T I V · - : J s i 
é Ô Ú Ë À 
ICJÛIIM.T. ÄIO.L.-.Q, . I Ì 
é é 
1 1 1 1 1 1 1 é é 
é é ç 
é é 1 ! I é é ç 
1 
C : L ! 
! - , , , 
I , Zi2 lOrO 
1 
, , ! ÁÀ^Ëé 
i v . A . L . U • j - l W . Ä . 
À ô É ß Õ 
I C Ö I N I T ^ I O I L I - I N / I . 
I 1 I 1 I 
I 
M 1 
I 1 I 1 I 1 I 
M 
I 
I 
Ì I 
1 I 
I é 1 
M 
M 
! 
CL 
! • é , , 
é liîiîiOO 
. . . . . , ! 
. . . . 1 . . . . 1 . . . . 1 . . . . 1 . . . . 1 . . . . 1 , . . . 1 . . . . 1 . . . . 1 
1 . . . . 1 . 
C.L, ! . . , . 
1 3 LiO.O 
, , 1 m.o.x/å! .Cjo.fsiiTleio.Lr-.ol .-no, ,ô-Éï,-ð-,à,αΐÁ,Í,ô,ÅôÉí... , , 1 , . , , 1 , , • , 1 , , , , 1 , , , , 1 , , • , 1 , CL 
1 J S , O ß 
PVO.V.ÊI .C.Û.lJ.-Jft.O.L.-. J 
:TTÖ , ô ] Λ , Ô é - , Ν/, J u l i , £. ·é I . . . . I é é é . ! . . . é I , , é . ! é . . . I é é . . I , 
e.c_ 
, , , , 
. IÎ-LOO 
1 
: : 1 n o , í , e l 
, ' , ( L O J T ;È , O : L , 
!TTÛ,T,A.LIS. ,", ,-rlo, ,-ÃÏ,Ô!-.VÊ-.S.CIA. . é . I . . . . I . . . . I . . . . I . . . . ! < 
Q.L ! , , , , 
é IW.oo 
I W-fciX-.T-e. 
ITTCS.T! AI U : i . ,A A r . Ê f c 
U . V v . A . Jc.33M.C. 
,
,
,
,
,
,
, 
é 
é é > , , , , 
é CL ! 
• . 
! I &.&1Ï1Ï 
1 
I 
1 
! 
• 
1 
I 
J 
! 
! 
1 
I 
I 
é 
CL.O.SIE. 
. c . A . i d ^ i - . f î . r i L l Ê . .rn A.CI-,-ÐÁ, ñ,åÉ-,Λ÷-L, é 
, p,e , õ MJT,-, * ÷ L C . 
. , , i , , , , I , , , , I , , , • \ , CL, 
! , . , . ' 
1 
1 1 ! 
s.r.û.pi 
ift.w.N.. ' é , , é. ! , , , . I , , , . I , , , , ! , . , , I , , , . I , , , . ! , , . , ! , . , , I , , , , 1 , C L 
! , , , , 
1 
, , , ! . , , . ! , , , , 1 . , , , I , , , , I , , , , ! , , , , I , , , , I , , , , ! , , , , I , , , , 1 . , , , ! , 
, , ! , , , , 
i 
, , 1 , , , ! , , , , ! , , , , I , , , 
. I , , , , I , , , , I , , , , I , , , , I , , , , ! , , , , 1 . , , , 1 . , , , ! , 
ι 
! 
. . . 1 . . , . 1 , . , . 1 . . , , 1 , . . . 1 . . , . 1 , , . , 1 , , , , ! , , , . 1 . . , . 1 , , , , 1 , , , , ! , 
, 
! 
! 
! 
I 
I ! 
! 
ß 
! , , , I , , , , ! . , . . 1 . , . , I , , , . ! , , , , I , , , , ! , , , , I , , , , ! , , , , ! , , , , I , . , , 1 , 
. , ! , . , , 
1 , , . ! . , , , I , , . , I , , . , !. , , ,1 . , ,, ! , , ,, ß , , . , I , , , , I , , , , I , , , , ! , . , , 1, 
. , ! , , , 
! . . ,
! . . . .
1 . . . . I ... . ! . . ., 1 . . . . 1 . . . . 1 , ... 1 . . . . 1 
1 . . . . 1 . . . . 1 . 
, , I , , , 
. 
.
1 • • • • ; . • • .
1 . . . • ! . . . . é . . 
• . é . . . 
• ß . . . . é . . . . 
é . . 
. . ß . , . , é 
é, . . ! , , , . 
, , 1 , , ,
 ; , , . .
 j , , , . I , , , , ! , , , , I , , , , ! . , , , I . , , , I , , , , ! , , , , ß , , , , I , , , , I , 
, , I , , , , 
., 1 
, , , 
1 , , , , ! , , , , ! , , , . I , , , , ! . , , . é , , , , I , , , , I , , , , I , , , , ! , , , . I , , , , I , . , I , , . , 
, I : , • • • . , ! • . . : ! . , , . ! . , , . I . , , , ß , , , , ! , , , , I , , , , ! , , , , I , , , , I , , , , I , 
, , ! , . , . 
125 

P R O G R A M M I N G IN 
C O B O L 
P R O G R A M 
Q U E S T I O N 
2 
For this second program, I have done a less detailed flowchart than for 
program 1. 
Write the COBOL program which will perform the following (Fig. 11.2). 
Name 
Job number 
Occupation 
Hours 
Tax code 
Input Description 
Digits 
10 
4 
1 
3 
3 
Alphabetic 
Numeric 
Numeric 
Numeric 
Numeric 
Tax Regulations 
Tax-free allowance is two-ninths of gross wage. 
Tax is payable on the remainder at 30p in the £. 
Output Desciiption 
The results are tabulated under a major heading "wages record", 
followed by a subheading above the information to be printed out, 
describing that field—"name", "occupation", etc. 
Digits 
Name 
10 
Alphabetic 
Occupation 
2 
Numeric 
Job number 
4 
Numeric 
Rate 
2 
Numeric 
Hours worked 
3 
Numeric 
Tax code 
3 
Numeric 
Gross wage 
9 
Sterling 
Tax deductable 
8 
Sterling 
Net wage 
9 
Sterling 
The print-out should be neatly arranged with leading zeros suppressed 
as applicable. 
126 

P R O G R A M 
Q U E S T I O N S 
Read in input 
details from 
punched card 
Calculate gross 
wage 
(hours χ rate) 
Calculate tax 
free allowance 
( -| gross wage) 
Calculate tax 
payable 
(30p in the £) 
Calculate 
(gross ν 
net wage 
vage - tax) 
Tabulate 
results as 
per output 
specification 
FIG. 11.2. 
127 

P R O G R A M M I N G I N 
C O B O L 
Occupation 
Rate per hour 
Occupation code 
Clerk 
79p 
1 
Foreman 
86p 
2 
Fitter 
64p 
3 
Labourer 
59p 
4 
Turner 
64p 
5 
Chargehand 
72p 
6 
128 
Gross Wage 
The gross wage is calculated by multiplying the hours worked by the 
occupation. The rate of pay for each occupation is by reference to the 
following table. 

PROGRAM QUESTION 2—ANSWER 
Cobol 
program sheet 
title 
programmer 
sheet number 
date 
4 
S e q u e n c e N o . 
1 
6 7 4 
8 
1 1 4 
1 2 
1 5 
2 0 
2 5 
3 0 
3 5 
4 0 
4 5 
5 0 
5 5 
6 0 
6 5 
7 0 
7 2 
^ 
i d e n t i f i c a t i o n 
7 3 
7 5 
80 
ßÔéÔß éæ 1 ^ f i ×é ^ixJ Cl Ai-Tirrnolwi 
i!hiXi v i X I S i XJ Οι i d · I é ι ι 1 ι ι é é 1 I é é 1 1 é é é I I 1 1—1—1—1—!—I—I—1—1—1—1—1—I—I—!—1—I—1—1—I— 
C i L i f l 
é é t 1 
,, 1 
P . £ ,Ë,òÉ/C é Á é Ã º é - i x t a l . é 
I U I A IO , g , 0 , I é . 1 . é é é 1 é t • é 1 é é é t 1 é é é 1 1 é 1 1 1 1 1 1 1 1 1 1 1 1 I 1 1 ' ß 1 1 ' 
C 
, 
I 
, , é é 
,, 1 
. , 1 . , , , 
Ñ ! ê É , \/ X £ . O I N JI d f i N , "Ð é ' J j T i N / i m S. é xl O, t>Jt. ι ι 1 
ι ι ι ι I ι ι ι ι I ι ι ι t 1 | ! 
1—1—1—1—I—I—1—1—1—1—I—I—I—1—1—I—!—1—1—1—1—1—1—1— 
C i L , ' | 
i
.
i
i 
wlrt ι í 1 
C I O I HI f 
X i C i U , gl Á Ô × º Ï , J 
i S i f i C r f l x i O i f J i . é 1 é é é é 1 1 1 1_J 1 1 1 1 1 ! I 1 ! 1 ! 1 
1 — 1 — 1— 1 —1 — 1 — 1 — 1— 1— I —1 — 1 — 1— 1— I — I —1 — I — ' —1 — 
C , L , »1 , , , , 
é 1 ! 3*l<> Ï 
,, 1 
S t O . U . d c , £ , - i C i o i f t , P i U i - T i d / t i ·é 
iTJ <?! L , - , I , Q . o l / .. 1 
, 
. 1 1 1 
· 
1 1 1 1 
1 
1 1 
1 1 
1 t I 
1 . . . 1 . . , . 1 
, . . , 1 C L , 
i l 
, , , , 
,, 1 
O, ß,3"i 
ETCi-Ti—, C I O I M IP , Ì É Ô, Å º Ë É. é 
iZU d L - . 
º Q, Ol / é. . 
I 
I 1 1 I é é I é « I 
I I I ' ' é I é , . . 1 . . . . 1 , . , , 1 
1 
O.L. il , , , , 
, , 
, É , Ï é Ï 
, , 1 Ã Õ Å Ã . Ë . Ï É Å. V, 
i S a r l z i / a i 
i S i o l o . O . 
.If , 6 lfc.fr.*.. é 1 é • . é 1 • é t é 
1 é é é é 1 é é é I 1 é é é é 1 I l é é 1 é ' ' ' ' ' 
G, L, ι! , , , , 
, , I I 
, 
, 
, 
, , 
,g,OiO 
X i r J, p| U -ÔÃ—.Oiul-r. P i U . - Ã. 
I ^ C I C T- I X I O I I JI . é 
, 1 • • é 
' 
1 • ' 
' • 1 I I 
» ι 1 é é 
ι é 
1 é é 
I é 
é é 
é 
é é 
É 1 1 1 » é · é 1 é é 
I 1 Q i L . f l 
, , , , 
é é é Ï, é Ï Ο 
rix L! å — é C éÏ é d - Ô ι /CI ÏÉ LA . I ! é 
é é 
I é é é ι 
I é é é , 
ι
,
,
,
, 1 
,
,
,
. ι
,
,
,
, ι
,
,
,
, 1 , 
, , . 1 , . . . 1 . . . , 1 C L , 
11 
, 
, 
, 
, 
,, 1 
S i d L i d c i f i 
É Ë É ÁÉ Ì É - ,É 
C C - I Î - I ÉI 
É AI S É s l x i C i h / i 
. . , 1 , . , . 1 
. . , . 1 
1 ò , ^ ß ! , , , , 
, , I £,/T.i-,elc.-r, 
. P . d : f i N . - r . - . © l u , f i 
. A sls.x.c.ij. 
1 P / c x ^ - r l e - , * , 
é f. .1 . . . . I . . . . I é é é 
É 
É 
É 
É 1 
É 
É 
É 
É 
I É 
Q i i n ' ! 
, , , , 
, , 
1 
,
,
!
,
,
,, 
é ' f i d i O ' O 
i, â ι Ô| A 
,3>é×, v i J g ^ i X i O i l J . 
é é é é 1 é , é I I é é é é I é é , 
1 é é é é I L_! I I—I—I—I—1—I—I—1—1—I—!—I—1—1—!—1—1—1—1—I—1—'—'— 
G , L , ι! , , , , 
P . X, 
L I É" 
é 5 , £iC.lr-,XTOif^i , 
, , , é 1 , , , , 1 é , , , 1 é , é é 1 é é ' é 1 i ' 
' I I é é é é—I—é—é—é—é—1—é—é—é—é—I—'—é—é—é—'—1— 
e . t H i l 
• • • • 
1 
f»V Á ι Ç é - I I e ι × é i-iJt é 
I é é 
é é 
I é é é é 
I é é é é I t é 
é é I é é é é ι é é 
1 I 
I 
é—é—é—L-J—é—é—é—é—I—i-J—é—1—I—é—é—1—1—I—1— 
ò,ß-,éÉ , , , , 
ι , 11 S ^ O i O 
,, 1 
k i A i ô i d ^ j 
# r , d û . fc\fr .5. l'o.n. x r - r r d e ^ h . 
é é ! . . . . 1 .
.
.
. 1 é é é é 1 é é 
é—é—I—é—é—é—é—1—1_é—é—é—É—é—é—é—é—1—é— 
Q,Ui 
\ , , , , 
1 
1 ; Éâ, ý, Q ,, 1 
> Á . Ô É Á
É 
i / S i C i C i o k . i i 
éË¾ A I T J I -I I É. é 
I , , é é 
I 
. , é , 
I é é t é 
I é ! , 
1 1 
I t 
1—1—1—I 
1—1—I—1—1—1—l—J 1 
1—1—1—é 1—1_ 
Q , L , f 
I 
, 
, 
, 
, 
, , ι, 7,OiO 
0,1, 1 
C?|L-,| 
, é , é 
é 
1 ! 1 81 Ο ιΟ 
,, 1 
O i D , 
é Irti Á Ë É . Å é - I c i 
é é é I é é é é 
I P I X T
C .J^.r 
Λ .. 1 . . . . 1 . . . . 1 
.
.
.
. I é 
.,, 1 , 
. 
. . i 
. 
I 
, 
, . 
J , L , / ! , , , , 
é é I é9é Ï ¼ ,, 1 
o,i, 
é 
I I J O I - I C
I 
é 
I 
é 
é 
é 
é 
I P , X ,
C .dr.u,),., 1 . , , . I , , . , I , , . . 1 , ,,, 1 , . , . 1 , . . . C L , i l 
, , , é 
, 
a o o o 
,, 1 
Ï , Ï, 
ι lo.e.e.u.pl é . 
ι ι 1 
. ι ι ι 
I P . X I
C •d 
1 , 
.
.
. 1 . . . . 1 . . . . L . . , 1 . 
< ? , L , » | 
, , , , 
129 

130 
Cobol 
program sheet 
title 
programmer 
sheet number 
date 
S e q u e n c e N o 
1 
6 7 
t 
8 
11 
4 
1 2 
1 5 
2 0 
2 5 
30 
3 5 
4 0 
4 5 
5 0 
5 5 
6 0 
6 5 
7 0 
7 2 
^ 
i d e n t i f i c a t i o n 
7 3 
7 5 
8 0 
! 
1 5i » Ï 
Ï 
, , I ΟιΟ , 
. 
I H I O I U I £ . I . S L I C
I 
I 
I 
I 
I 
I 
! 
Ρ,×, Ci 
, Ο É Ì , Ι , . , 1 . . , . 1 . , , , 1 . , . I , , , , I é 
, 
, é 
I 
, , , , i 
G, U É\ 
, 
ι 
ι é 
é 
Ö S 
Ï , ï 
, , i ÏéËé 
ι 
! ô ι Á . × . - é d o i i i E " ! - i d 
! , I 
P x . c , 
. < * É Ë 2 Ë . . . 
1 . , , . 1 , . . , 1 , 
, , I , , , , I , 
, 
, , 
I 
, , , , ß 
e . c . l . . . , 
S i 
ï ï 
. é Ï , Ë, 
, 
IP . X . L . L . E IÄ 
,
,
,
!
,
,
, 
. v i r , 5 · . ò , v.l 
, . , , I , , , , I . 
! 
I 
1
 
1 
<S,L.,\ 
. 
, , , 
, 
, I 
," , 
, I , 
, , 
, I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , I , , , , é , , , , I , , , , é . , , I , , , , 
• a U- ï ï ^ 
! 
Ρΐ£.3ÃéÍÃÔé - , Ï , É - É Ã Ã! 
I 
I 
ι 
t 
I 
ι 
ι 
é 
é 
! 
, 
é 
é 
é 
I 
é 
Ã , 
é 
! 
ι 
, 
! 
é 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
. 
, 
, 
I 
, B . L . .I 
. 
. 
, 
, 
, , ! 
L . A ' . & . J L . 
. f c . e - . c L . e . i . i . 
l o . z h . x r r ô | â Ë , 
, , é , , , , é , , , , é . . , . é . , , é , ,. 
. 
, 
I 
, , 
, . I , , 
, 
, 
I 
Ci-. »1 
: 
, 
, 
, 
, , ß i i A m f i l 
ifeiç-;t i o U i ^ i S , 
,-rlx.-r. L , e - I i , 
r r . x . - r i 
2. 
É Ρ . Ë . Ë Ã . Ë , , Ô É - , 1. . . 
- I , 
, , 
! 
, 
, 
I 
I
 
I 
C, L, I I 
, 
, 
, 
, 
0 „ ß 
C
L , 
, 
. , . 
, . I ï, a , 
j • !<r, ÷ 
L . L . e l 
ft 
, 
, 
, I 
, 
, ι 
Ρ, ÷ , 
c ,*le,ι,o.).. I , , , , I , , , , I , 
, , I , , , 
, 
I 
, 
, 
, , I , , , , ! C L / 
, · , , , 
ι éäÁοο 
, 
• ! 
CO, , ' u , A . c e - . s l - . e . e - . c o U . i . s , 
! P.XTC. , x k i . u . Y . I 
, , , , I , , , , I , 
, 
, 
! , , 
I , 
, 
, , I 
, ! e.L.i! , , . , 
ι' , 3 · ο , è ι ο 
o, 5, 
, 
I ^ X Î C L . J «
. 
. 
. 
ι 
1 
. 
. 
. 
! 
IP.x.c, ^ k ^ t , . . ) , . ! 
, , ι , I , é , , I , 
I 
, , É , 
, 
, 
É 
! 
C L 
É 
, 
, 
, 
, 
é 
.
.
. 
1 .
.
.
. 
1 .
.
.
. 
1 .
.
.
. 
1 .
.
.
. 
1 .
.
.
. 
1
1 
,
,
,
.
!
.
.
,
. 
i 
.
.
.
. 
1 .
.
.
. 
1 .
.
.
. 
1 . 
ι 
2,1 , ï , Ο 
, 
ï, é, · 
é 
ι 
I 
I 
,
1
.
.
.
.
!
.
.
.
. 
I 
, 
, 
. . 
i 
. 
I 
, , 
, , 
I 
, , 
, , ! 
G æ_ ι i 
, 
. 
, , 
: 2 ,9 IP Ï 
1 
1
 
1 
: P x c 
, ÷ 
Ë / , Ë , Ï, Ú I . , 
, 
, 
, 
I 
, 
, 
, 
, 
, 
, , , I . . 
I 
I 
1 
CL.» 
, , , • 
, , 
, , , 
, . I : 
. 
. 
1 
. 
. 
. 
, 1 . . . . 
1 . . . .
 1 . . . 
. 
1 
,
,
.
.
!
,
,
,
, 
1 , , , , ! , , , , I , 
, 
, 
, 
I 
, , 
, 
, 
I 
, 
, 
, 
, i 
* é , 
I 
p . e . - r J - r - 
!
,
,
,
, 
1 , , , , ß , , , · , 1 ,
,
,
,
!
,
,
,
, 
1 , , , , ! , , , , 
1 , . . . 1 . . . . ! . . . . 
1 . 
C L é ! , , , , 
ι 
ι 3 ι ^ ï ï 
, , I o . d. 
, 
IP . X . Î _ . L . C IA 
,
,
,
!
.
,
,, 
Ρ,÷ô c, 
, ÷ É ß . Ë , ê 
, I , 
, 
, , 
I , , , , I , , , 
, ! , 
, 
, I , , , , I , , , , I C L I 
, 
, 
, , 
I 
ΐ 3 ΐ ^ ! è Ã è 
, , I 0 , 3, 
, 
É Í , Á , Ð . Å . -
É 
Ρ, 
, 
, 
, 
I 
. 
, 
, 
, I r j r . c , 
.Ë C / , o , V. I 
, 
, 
, , I , 
, 
, 
, 
I 
, , , , I , , 
, 
I 
, , 
, 
, i , , , , ! 
C 
L é 
, 
3 <ò» ιΟ ιΟ 
, , ! ï , ï , 
, 
^ x , t , i . , e l < e , 
, , , I , , , , 
P x - . c 
, x k ^ , . , 
I , , , , I , . , , I . . 
é 
, é . . . . 
é . . . . I 
O
L , 
, , , . 
, ,νί,ο,ο 
, , I Ï , 0 , 
, l o . C i C . u . P A.-r.x-,ï.^Ι-,Ρ, 
, , 
I 
I P Ä c, 
o ! q 
! , , , , 
I 
, 
, 
, 
, 
I 
. , 
, 
. 
I . 
. 
I 
Q L é 
, 
, , 
ι 
, À , â , Ï , à 
! o,i>, 
, k , r - , c , t _ . J / e . 
,
,
,
,
,
,
, Ip.xc 
. J , . , . 7 . U 
, 
, 
, 
, 
I , 
. 
, 
. 
I 
, , 
, ! . , , , I , , , ,
 1 
SA-., 
Q L. é 
: . . . 
é 
| 3 . Q | 0 , 0 
, é Ï Ë , 
, 
' ÷ ú Ο , & , - , Ì Ο , - , Ρ , 
. I . . é é 
,<ΙÉËÉ.Ë,.. 
I , . , , I , , , , I , , , . I . , 
, 
I . . . . 
I 
. 
.
. . 
' 
SA-., 
Q L. é 
: . . . 
, 
, α , ο , ο , ο 
, 
, 
I 
0 , 3 , 
, 
I f i x. U . L. E l Ι. 
, 
, 
, 
I 
, 
, 
, 
, 
IP.XT<Ü 
, × É Ë , Ï , ) , . ! 
, 
, 
. 
, 
! , 
, 
, , 
I 
, , 
I 
, ß , , , . \ , , , ,
 1 
Q.t-.l 
, _ 

Cobol 
program sheet 
t i t l e 
p r o g r a m m e r 
s h e e t 
n u m b e r 
d a t e 
3 
S e q u e n c e N o . 
1 
6 7 
t 
8 
11 12 
15 
20 
25 
30 
35 
40 
45 
50 
55 
60 
65 
70 72 
4 
i
d
e
i 
73 75 
i t i f i c a t i o n 
8 0 
. 
, 1 
0 | 3 | ι 
fciAiTiEJ-Ui 
ι ι ι I ι ι ι ι Ip.X.C. 
, « J ( , A Y. j 
j 
1 
1 1 1 1 
, 
1 , 
• ,
, 1 
CL, l| , , , , 
" • 
• 1 
ΟιΛ ! 1 
ñ-,÷, L U d e 
, é , ! , , , , 
! Ñ , × , c , d c , Ä ) , · , I , , , ,º , , , 
1 
, 
, 
, , 
! 
Ι 
ι 
I ι é ι ι 1 
é 
l U - i i i O i O 
, 
. 1 
O l d 1 1 Iw.o.u,e.d-.P. ι ι I ι ι é ι Px.C ,ò|(,2Ëé. , ι , , , , 
ι , , , 
I , ," ; , , , ι ι Ι 
. 1 . . , . 1 
q . L ^ I 
, 
• , , 
, , ! 
Ο.Λ ι ι IpiXiLiCidfci 
Ι 
Ι Ι I Ι Ι Ι Ι 
I P I XI C I ,d ),. , ι , , , , 
ι , , , 
1 , , , , .
.
. . 
1 
• 1 • , 
, 
, 1 
Q ; L| l | ι é 
M 
é iLi^iOl^S 
, 
I 1 
Οι J 
I 
, 
I . C . O Ä . C . J P
. 
ι é ι ! é ι ι ι 
P , X , C , 
, I , , , , I , , , 1 , , , , , 
, 
, 
, 1 , 1 1 , ι , , , , 
1 
. , , , 
- , 
• 1 
Ol J 1 , UiXiULiJe. , ι , I é ι é ι 
| p X , C , • d ( , t . y. 
1 , , , , ! 1 1 1 1 
P . L i l l , , , , 
1 
Οι 5, ι IciC.O.Si.sl-iWiA.Qirl-.P. ι , 
P . - T i C ,^l£,£,£,9,9l9,B,B,9,9l , , . 
1 
I ι - 1 
1 1 
1 1 1 1 1 
, ι , , , , 
1 
ò , ^ , Ι , , , , 
Lnff 
O A 
1 
, , 1 
o,j, , 
r^.x.L.L,Je. , , , 1 • . , . IPar.c, ,x It, L ) , . , I , , , , I , , , 1, , , , 1 1 1 I I 
. I , , , , ί 
ί Λ , . É 
, 
, 
, , 
1 
| L ; 9 l O .O 
, . 1 
ΙôÃÁ÷-, -, f\ 
, , , ι I , ι ι ι 
I P . X . C
. , £ £ £ £ , 9 , 9 9,B,6,9,9 , , , 
,
,
, , 
1 
, 1 ' , , , I 
, , , . 
1 l S* : O i O lO 
, . ! 
I^X.L.L.fi-U. 
P . X . C 
, ß , , , , ί , , , 1 , , , , , , , , ί , 
1 1 , I , , , , I C.L.» I , , , . 
ι é &\ · ι 0»|O 
, I 
o.Jt , 
Iw.A.c.e.-P, , , , I ι ι , ι Ip.X.C, JlJ£££L9,9;9,B,B,9.9! . . . , . 
k 
, , , 
1 
, I , , , , I ò,^,É , , , , 
, S i , ï ï 
, , 1 Ο, á, 
U.-riZ-.i-.d^i º ι ι I ι . ι ι Ip.X.C. 
I , , , , ,
,
, , 
1 
, I , , , , I ò , ^ , Ι , , , , 
, ! 
_ 
I , 
, 
, 
, I 
, 
, 
, 
, 
I , , , , 
I , , , , 
I 
, 
, 
, 
, 
! 
, 
, 
, 
, 
! 
, 
, 
, 
, 
I 
, 
. 
, 
, 
I 
, 
, 
, 
, 
I 
, , 
, 
, 
I 
, , 
, 
, 
! , 
. . ! . , , , 
. ,ü", J.o,-©, 
÷,ð,ò -IsiTiOiίifllciE, 
,5 i f f l c i T i X T O , d« , , , , i , , , , I , , , , I , , , 1 , , ,., 
, , 
1 
, I , , , , 1 
C,<-,'i , , , ,' 
„ 7 , 
1 
H,~iß -LiAiCe, 
1 ( , , é I , ι é ι IpiXiC. 
,dr,q,>, ,.clo,r>iPi 
i s l v i N i C , 
dx,c M ,r. 
V I AI t-iWid iX,S, • dfi-.Ι.o,., I 
C.L.A , , , , 
7,7, 
1 
Ç , ~ ,£ -IvJiA.CiE.-lli , ι , I , ι ι . 
I P I X .
C ACQ,) , , Ο Ο , Λ ν Ρ , 
, s | v , M , C 
d x . C . M . T . 
V l A l C l U l f cl 
iX^5 
.ale,*,ο, ·, I 
,
,
,
. 
ι ,S|k,0(O 
7,7, 1 ô",A .y -|p.£,^.fi. 1 . , , ι 1 ι • ι ι Ip.X.C , 9 k , q , ) , 
• do,η,Ρ, ,dv,*i,ci 
dx.C.W.T. 
V , A , u,u,Cl .« 
α å , Á à ., I 
c . , , ! , , , , 
, 
, S W i O i O 
7é"71 1 
T A ,y Jp.A.V, . I é , ι é I ι . · . IpXiC, ,q| C o , ) , .do.ftp. 
I S I V . M, c, , dx.c.w.-n 
V . A , L, U, d 
Ë 5 
, al £•,*,©, ., I 
C
M I 
, 
, 
, , 
, , £,S,o , o 
7,7, 
1 
TT Á· |V - L
e
a
, 
,
!
,
,
, , 
1 , ! , - 
I P U X . C, ,òΙ(,ò,), ,do,n,P, ,dv,M,c, , d x r C w . T , 
V/, A, i - . U , d X . .S 
c.,,,1 , , . . 
. ,£9,ï ï 1,7, t 
Í, 
, 
1 
1 
,
,
,
,
,
,
, 
, 
I P J C C
, ,q| , , . ,slv,si,c, 
,elx,c,M,T 
, X S , 
,2le,/C,0 ., ! 
I 
c,t,»l , , , , 
1 
, , ! , , , , 
t> ooo 
O l . 
1 
£é Ρ ι Ô e l - i O C i C é. I ι ι ι ι ! ι ι ι ι I ι ι ι 
, 
1 • 
, 
, , 1 , , , , 1 , , , , 1 , , , , 
1 
S 
ι 
C , L , | | 
, , , , 
, , fa, 1,0,0 
, 
• ! 
0 0 
l-rto.Ä.-.eUiT.c-. - I , , , , I , ι ι , h , , 
131 

132 
Cobol 
title 
sheet number U-
program Sheet 
programmer 
date 
S e q u e n c e N o . 
i d e n t i f i c a t i o n 
1 
6 7 8 
1 1 12 
15 
20 
25 
30 
35 
4 0 
45 
50 
55 
6 0 
65 
70 72 73 75 
8 0 
t 5 Ο Ο 
I 
, : , |0ΐ3· i I 'CL:E £ 
• ' 1 - ? I C 
1 9 Q, 
! V;Al / - 1 U 1 fi I |X|J | 7 : < ? | . | 
M
i
l 1 1 1 1 1 1 . 1 I I , 1 ! 1 II C,Ü ,1 , , , , 
ι 
ι t> J o Ο 
1 
ί 
j 
! 
ι 
Ι 
! 
1 
I 
i • , 
O 2 
, , f o. £ e- ^ A Nl , ι 
Ρ X C 
i 9 ^, 
ν A* L (J £ 
' Xi S ί 
S t . 
; , , ι j 
I 
! 
: 
Ci-.il .
.
. 
, U o o 
, , , Ï 3 , , Ý i
f f £ å , , , Ñ ÷ c 
q 9. 
V A L U E 
x s 
L, . 
! 
, ι , ¼ Æ · . L A ß ï u e r t . P i C 9 ° . · V A-c u å ÷ * 5"<*. . 
! - , , . , 
c e ! • . 
( 3 ( 0 . 0 0 
, , ! 
, , , Ιè,3, , . < U , 
, , . 
Ρ X 
C 
q 9· 
, V A L u i :T,S 
t L- . 
! , , , , 
1 , , . . ! , , , , ' . 
CL,1 
, 
t Y o o 
ß 
, , , Éο,é 
, . I c w . a e . c l e - u i A . w i » ! ,p,xc, 
V A L U T 
, a U ,7,2, . 1 , , , , 
C L I 
• . , , 
W : Û O 
, , ! Ο,ï, 
, !Ä,A,T.6- T I A , S, L,el 
.â,-Åº^,å Ip-Xri.f,^! 
,:Ã~0, ô , - 
A>Tï£, 
Ρ iX.C. 
1 ° , 
. O i C C U-IC-5. , Q 
, Ô ι × , ί º ι ^ , . , , , i , 
G L I : , : , 
! ... 1 .... 1 
1 . . , . ! . , . . 
1 . . . . 1 . . . . 1 
1 ... . . , , , ) , . , , ! , . , . \ 
: 
L ^ i O O 
1 
w L ι 
, , , , 
, 
Ô è Ο ; 0 
1 
*
.
,
.
!
,
.
.
. 
I 
.
.
.
, 1 . . . . ! . . . . 1 
. . . . 1 . . . . 1 . . . . 1 .
.
.
. 1 . . . . 1 . . . . 1 .
.
.
. 
1 
C L I 
. , 
^ l O O 
0, P, C , rj , X r 4 , P , u | - n 
,Λú,Á, J - , Ρ ι × , L , £ 
, C V U T T A L , T , 
. P, ( t l x , r/,-r,-, o l u r r , . , , L , 
, ι I ι , ι ι 
M ι ι 
, , , , ! , 5 L i 
, , , , 
t 
Ô Ï Ï 
Ñ , Å , × É Í 
! 
I 
1 
! 
I 
! 
i 
! 
! 
I 
! 
i 
Q.L.! , , , , 
, , I ç,ο,í,ίô! ,S,'P,A.C e,4, ,ô,ο! ,ôô÷ô, Je,-, »,. . 
, , , , I , , , , I , , , , I , , , , ! , , , , ! , , , , ! , , , , ! , C L I : 
, , 
. 
V L 0 0 
ç,ï,ν/,Å, , " , w A . d e , ß , ,Λ·åÊ; Q A ^ S 1 Ë <ï> ,WAA,CeU,- 
Å, d ο ^ , ί , . I 
, , , . ι . , , . ! , , , , 
, , , , i , 
G L / 
, 
, Y S , o o 
, , 1 
! 
! 
I 
! 
I 
! 
! 
Ι
!
ί 
ί
 
1 
U R.X ô Ý 
Ô ÷ Ô L £ - / 
A A r e £ 
C MA r>i *J ë. L — I . 
, , , I , , , , I , . , , ! , , . , ! , , , , ί , , , , ! 
G L I 
, , 1 f \ 0 V £ 
" , , ! , 
N f l f t f 
, , , É O C C U P A T ÷ ο 
Í» 
,
,
,
!
,
,
,
, 
-To ß> 
ri ï 
, , , ! , . 
/S. Á Ô £ , , ! , G L / 
, , , , 
, , 
1 
", , ;H!o,u,P.,S, ! . , , , I . , C : 0 , 1 Å 
, . , ! , , 
• C e o . S . Î , 
, l w , A , C £ i ! , , , ,-ÃÉÁ,×·, , , 
I , , , : !W,A,C,Ι, 
I , 
G L ι 
. 
i ", , . ί , ,", Ja .^L.,,-,*.! . . . , ! . . . . ! . . . . I , . , . I . . , . I . . , . I , , . , ! . , . . ! , C L / 
, , i Q . o o 
, , 1 ^ f t x . r l e , 
, - r , x - - r L , e , - ; X 
A , p , r , e , / e 
,A,>V,AUC,X,^C 
,Á .
,
,
-
,
,
,
,
,
,
,
,
,
,
, 
1 
,
,
,
,
,
,
,
, 
, 
G L:/ 
. 
, .€,0,0,0 
• , !' i\ov ,å! ,*,p,A.Je,<s, , ô , ο ! ^ T . C L J . , 
,
,
,
,
,
,
,
,
,
,
,
,
,
, 
,
,
,
,
,
,
,
,
,
,
,
,
,
, 
. 
G L / 
, , , , 
ι , 8,1 O O 
&,E,c|x-
, 
1 , , , , 1 
I , . , , ! , , , , ! , , . . 
1 
1 
1 ,
,
,
.
!
,
,
.
, 
1 
,
,
,
,
!
,
,
,
.
! 
, 
G,L,/| , , , , 
, 
, 8 , 0 , 0 0 
, , ! 
e , e , A , i l 
,pyÁ,ηί,-É P x , L , t , 
l e . e . c o i ß K , ,Á,Ô |&N,Ä, 
,ÏÉΟ, ,ôá, 
ÉÑ, Á, 
A, J ο , . , 
, ,' I , , , , 
I , , , , ! , , . ι I 
, Q, L. / ! , , , , 
, , 8, i ο ,© 
- 
I , , , , I , é . , 
I , , , , I , , , , i , , , , ! , , , , I , , , , I , , , , I , , , , I , , , , 
I 
I , 
Q,L,i! , , , , 

Cobol 
title 
sheet number 5" 
program S h e e t 
programmer 
date 
S e q u e n c e 
No. 
. 
. 
i d e n t i f i c a t i o n 
I 
6 7 8 
11 12 
15 
20 
25 
3 0 
3 5 
4 0 
45 
5 0 
5 5 
6 0 
6 5 
7 0 
7 2 7 3 
7 5 
8 0 
1 f*>Qivy,e! 
1 0, C, <L| 
| - Ã ; 0: 
IH-. ! é JL 
1
 ' . ; ! ! J . ! I l é ! 1 1 
1 Î ι 1 1 1 1 I ι ß I 1 1 1 1 1 I I 1 I I I ι ι I ι c u l , , , , 
é 
; 5 ι 5 ι Ο ι Ο 
nu.c-rlx, p,L,y, U - Á , ô , å , - I - T A I & . L , åί ( , N ). .dv. .N.o.ule , 5 , c , 
lc,x, v.^Jc. 
I W . - I * I - , Ê Á , ò , Å : ! ., , , , 
I 
, 
. 
, ι 1 , 
I 
C L , Ç , , , , 
é 
, g, 
IB IOO 
1 n,oio.cl ,ìΐ-,Å,-Ιõ,Á,ο,å, '-no. ,c ,*.!o ,s,.s,-, J A . C Ê , 
-, Ρ I. , 
,
,
,
,
,, 
1 L 1 M 
,
,
,
,
,
, 
,
,
,, 
1
, 
, 
C L , I | 
! 
, I I 
ι 8 , T , 0 ,0 
/Ë,Ο,ν,åΙ 
é M., ft-Ui 
A | Q , £: Ιηοι é H - I Ê , - M A - i o l ß . - . I, .é I é é 
, 
, I ι ι é ι I ι 1 1 1 I 1 é é é I ι ι ι é 
I é ι ι é 
I ι 
Ç , L , l | 
< , , : 
, 
, 3 , 8 , 0 © 
. , ! hiu,urlx AL,Vi 
H,-,e,-,ukc,£, ,fljy, ,2, .clxw.x.rf.cl .w -.ft-1 L / , A , C , £
, . I 
, 
, 
, 
, I , , , , I , 
, 
, 
, 
I 
, 
, 
. 
, 
1 , Cl-.fl , , , , 
, ,?,9,o,o 
, , 
1 >>iX,y, J % F, , ° é , Ix.rv.iTiO, 
Iw.-ift-.MA.Cfi. iclx, / , × , Ë / , Ï
! 
.-TT Áι Vi J 
Ñ*. £ , £ " , £ " ,
. 
I é ι 
. 
, I , 
, é é 
I é é 
, 
, 
I é . é é 
I ι 
CL/I , , , , 
e.Lwl , , , , 
, Ë ι,ο,ο 
s, u, &,ô[ â Á, CT, lr-,Á,ν,-,^Ι/å,Å·,^. •pie,è! Ë 
,wL,£,-.U/AICE*.-, », lq.xw,xî/Jη, 
. T Î A . X I - . P . A . V ,
. I , , 
, 
, 
I 
, 
, 
, 
, 
I , 
ι A s , © , ο 
, . ! r\u,u,Tlx,p,L,y, 
- Ã Á , ν , - , Ρ A,y, ,Ë,νΙ ,3,0, ,òΙ÷,νΛ÷,^,òΙ 
,ÔÁ,*-Ã}>,å73>,., 
, , , , ! , , , , 
, é , , 
, , , ι L q,L,/| 
é 
é Ñ , É, Ο ι © 
, , 
1 
i x , v , x U , £ ,Ι,οΙο, ar.rirrlo, 
, Ô , Á , * É
- ,ú>, åΟ>,. 
I 
, 
, 
, 
, ί , , , , I , , , , I , 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I , 
C
L
.
I
I
,
,
, , 
1 é °< é ktO éÏ 
ί s,u ,õôΙ/å, A C T, 
Éô,Á,í,-,Jc>, 
,Å . Å É Ï , Ð, 
, H,-Le,-,u,A,Q å",-,/, ,clx, • , × Ã Ë É Cl 
, U A,C,£"U,P, . , 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I , C L / I 
, ι , , 
, °. S o ο 
P , P , P J P 
C L , / ! 
, 
, 
, , 
, , Ρ Λ , ο ο 
Ρνο,í/,åΙ ,»>»•* r», el-.c ,-ô,ïÉ ,êñ«Ë* åι-,Ρ,., 
, I , , , , I , 
, 
, 
, 
I 
, 
, 
, 
, 
! 
, 
, 
, 
, 
I 
, 
, 
, 
, ! , , 
, , 
I 
• . 
. 
. 
I . â Λ , É 
, 
, 
, 
, 
, ,à,,¾,ο,ο 
• 1 
1 P V O . N / . Ê
I 
Ã Ô ï , Ë , - 
H , 0 , ~ , C
, 
Ι-ÐÏ, ,-ίÔèΙ Ë , - , Á / , Ï , - ÉΡ , . , 
, 
, I é ι ι é 
I ι ι é ι I é ι é ι I é é é é 
I ι é ι ι I ι ι é ι 
I é 
<S,L,,\ , , , ,' 
, 
I °MÂ , 0 <O 
, , 1 
I ^ OI V/ ÉI 
I O . C C I U P , ,ô,ï, lo.cc.uipUmx, Ο, J-,fl . , 
,. I 
, 
, 
, 
, 
I ι ι , 
, I , 
, 
, 
, 
I 
, 
, 
, é 
I ι , 
, 
, 
I 
, é é ι 
I , e . L i l 
, , , , 
, 1 
Ã \ 0 , \ É, Å É 
. - T . A . V . - I C . O ^ . C
I - I C 
, Ô, Ο , |ciO,i,£,-|p,. , 
, é 
I é ι é é 
I é , é é ! é é é é I é é é ι I é ι é é 
I é é é ι I Ι 
«,«.„1 , , , , 
ι tOiOO,© 
, , 
1 
Λη,÷/,åΙ 
I H O . O , * Î S . - , C
, ,ôßï, , Ç ï , õ * ^ , - , Ρ , . I , 
, 
, 
, 
I 
, 
, 
, 
, I , 
, 
, 
, I , 
, 
, 
, ! , 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I é G.L,,\ 
, , , , 
ι I, Οι I ι CO 
Ë , Ï , é / . e l .T.A.^J-b.f,^, ,ô|è, 
, Ô , Á , ÷ º - , Ρ , . , 
, I , 
, ι , 
, 
, 
, 
, 
I , , 
, 
, I , ι 
, 
, Ι , 
, , 
, 
I 
, ι 
, é 
I 
, 
, ι , 
I é 3 Λ . . É 
, 
, 
, , 
, 1 , 0 , 3 0
0 
1 1 ! ð,ï,í,å.1 ,£,Á,ô,å-,ô,Á,4,<-!å,Λê ), Ιô,ï, ,c, Á É Ô Ã Å -
, Ρ,.I 
, 
, 
, 
, 
I 
, 
, 
, ι 
I 
, 
, 
, 
, 
I 
, 
, ι , 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I ι Ci- 11 , , , . 
, 1 , 0 2 , 0 , 0 
P . R . Ê IP 
e,t,i| , , , , 
, I , OIU -I 
OiO 
W . Ê . X . T U
. 
,p,e,xU,T,-, ι, 
É Á , Ñ , Ô
, å*, el 
, Á , * , > / ,Ρ ! ^ , Ï .× ^,ò| 
, » , ., . I , 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
, 
, 
, 
I , C.L./I 
, , , , 
, t 
, 0 , ^ , 0 ,
0 
1 
. , 1 ç,ï,ν,åΙ .s.P.A.cle.s, 
, Ô , Ï! 
, P J C , 3 , / V I T , -
, ι , . , I , 
, 
, 
, I , 
, 
, 
, I , 
, 
, 
, 
I 
, 
, 
, 
, 
I 
, 
• 
, 
, 
I 
, 
, 
, 
, 
I 
, é ! é 
I , ou, 4 , , , , 
C o , 
i-rloi 
, Á , Å . Ï É × . Ë / , ._; ..., I , , , é é é I , é ι ι I I I Ì I ι ι I ι I é ι ι ι I ι ι ι ι I I É . Ì I ι ι ι ι I. ι ι ι é I ι 
e , L , . l 
, , , , 
133 

134 
Cobol 
title 
sheet number 
k 
program Sheet 
programmer 
date 
S e q u e n c e 
No. 
^ 
^ 
i d e n t i f i c a t i o n 
1 
0 7 8 
1 1 12 
15 
2 0 
2 5 
30 
3 5 
4 0 
4 5 
5 0 
5 5 
6 0 
6 5 
70 
7 2 7 3 
7 5 
8 0 
1 ( Ï Ë é Ï é Ï 
Ρ , Ñ , Å ÉÑ 
! , , , , I , , , , 1 , , , , ! , . , , I , . , , I , , , , I , , . . 1 , , , , ! , , , , I , , , , I , , , , 1 , 
C i - /! : , , , 
, 1 O - i O i O 
1 C^LiOiJci 
ifh.Ai J - | É | i " i L i < ; l 
, Ñ, Λ , × ß /J T , - I O | U I TJ . ι 
é 
ι 
é 
I 
é º 
ι 
I 
I 
ι 
é 
é ι 
I 
ι 
ι 
ι 
é I é 
ι 
t 
ι 
I 
ι 
é 
é 
> 
I 
ι 
ι 
ι 
ι I 
é 
3 , L . 
1 [ 
, 
, 
, 
é 
, é ο Á. ο Ï 
S . T . O . P
I 
éί é Ïé Ë/Ι . I 
é 
ι 
é 
é 
I 
ι 
ι 
é 
é 
ί 
é 
ι 
é 
é 
I 
ι 
é 
ι 
é 
Î 
é 
é 
ι 
ι 
I 
é 
é 
é 
é 
I 
é 
é 
é 
é 
ß 
é
 
é 
é 
é 
I 
ι 
é 
é 
é 
I 
I 
1 
1 
f 
I 
1 
e.L. é 
, , ι 
, 
I 
, . 1 . , 
, , 
, 
' 
1 ! 1 
. . . 1 . . . . 1 . . . . 1 , , . , ! . . . , I . . . , 1 
1 . . . . I , . . . I . . . , 1 .... 1 . . . . ! . ,, 1 , , , , 
. . . 1 . . . . 1 .
. . .'1 
1 
.
.
.. 
1 .
.
. . 1 
1 . . . . 1 .
.
. . 1 .... ι,... ι..., 1 . . , 1 . , , . 
1 , . , 1 . . 
. 
. 1 , , 
. 
. 1 , . , . 1 . , . . 1 . , 
. , 1 , . , . 1 . . , . 1 . . 
. 
. 1 . , . , 1 . . , , 1 . . . . 1 , 
, . ! , , , , 
, , 1 
, , ί 
! ... 1 . . . . I , , . . ! . , . , ! , . , . 1 . . . J . . , , 
1 . . , . ! . . . , 1 . . , ! . , . . I . . . , 1 , 
1 .,,
 
! .... 1
1 
. . . . 1 . . . . ! . , . , 1 , ... 1 . . . . 
1 .
.
.
.
!
.
.
.
. 
1 
.
.
.. 
1 
, 
I 
! 
! 
1 
1 
1 ' f . 
! 
! 
. 
, 
1 ... I , . . . 1 1 
. , . . ! . . . . 1 
.
.
.
. 
ß 
.
,
.
.
!
.
.
.
. 
1 . . . . ί 
1 . . . . 
1 1 
1 i 1 ! 
' 
1 
, 
, 
1 
.
. . 
1 
.
.
.. 
1 
.
.
.. 
1 
.
.
.. 
1 
.
.
.. 
1 
.
.
.. 
1 
.
.
.. 
1 
. 
.
. . 
1 
.
.
.
.
!
.
.
,
. 
1
 
.
.
.. 
1 
.
.
.. 
! 
. 
! 
! 
1 1 
, , . 
1 . . . . 
1 , . . . 
1 , . . . 
1 . . . . 
1 . . . . 
1 . . . . 
1 . , , . ! . . . . 
1 . . . . 
1 , . . . 
1 . . . . 
i . 
; 
, 
• 
! 
, , ! . , , , 1 , , , , 1 . , , , ! , , , , 
1 
1 . . . . 
1 
1 . . . . 
1 . . . . 
1 . . . , ! . . . . ! 
. 
1 
1 
.
. . 
1 . . . . I . . . , 
1 . . . . 
1 . . . . 1 
.
.
.. 
1 
1 
.
.
.
.
!
.
.
.
. 
1 . . . . 
i . . . . ! . . . . ! 
. 
ι 
, 
, 
! ... 1 , ... 1 
.
.
.. 
1 . . . . 
1 . . . . 
1 .
.
. . 1 . . . . 1 
.
.
.. 
1 . . . .'I . . . . 
1 . . . . i . . . . 
1 . ι 
! ... 1 1 
. , , , ! , , , . ! , . , , 
1 
, ... 1 
1 , . . , ! , , . , ! , , . S . . . . I , . . . ! , 
! 
... 1 . . . . 1 . . . . 1...,!.... 
1 . . . . 1 . . . . 1 . . . , 1 . . . . 1 . . . . 1 .... 1 .... 1 . 
! 
... 1 .... I , . . . 1 ....!.,..1 
. . . . 1 . . . . I . . . , 1 , . . . 1 . . . . 1 . . . . 1 .... 1 
... 1 . . . . I , . . . 
1 .... 1 . . . . 1 ... : 1 
f . . . , 1 , . , . ! , , , . 1 
. , , , ! . , , , ! 
, 
1 
, , 1 
.
.
. 
L 
1 
, 
.
.
. 
1 
.
.
.
. 
i
. 
.
.
. 
I
1 
1 
1 
,
,
.
.
!
,
.
,
. 
ß 
,
.
.
,
!
.
.
.
, 
1 
, , 1 , , , , 
I 
1 
I 
I 
ß 
ί 
1 
I 
1 
1 
! 
1 
1 
1 

A P P E N D I X 
Reserved Words 
I N THE following list, optional words are marked with a single asterisk [*]. 
Words which are sometimes optional and sometimes keywords, depending 
on the context, are marked with a double asterisk [**]. 
All the other members of the list are COBOL keywords. 
*ABOUT 
ACCEPT 
ACCESS 
ACTIVE-TIME 
ADD 
* ADVANCING 
AFTER 
ALL 
ALPHABETIC 
ALPHANUMERIC 
ALTER 
^ALTERNATE 
AN 
AND 
*ARE 
*AREA 
*AREAS 
ASSIGN 
AT 
BEFORE 
BIT-nn 
(where 0 0 < η η ^ 2 3 ) 
BITS 
BLANK 
BLOCK 
BY 
CALL 
CARD-PUNCH 
CARD-READER 
CASSETTES 
CASSETTE-* 
CHANNEL-1 
CHANNEL-2 
CHANNEL-3 
CHANNEL-4 
CHANNEL-5 
CHANNEL-6 
CHANNEL-7 
^CHARACTERS 
CHECK 
CHEQUE 
*CLASS 
CLOSE 
COMP 
COMPUTATIONAL 
COMP-1 
COMPUTATIONAL-1 
CONFIGURATION 
CONSTANT 
^CONTAINS 
^CONTROL 
COPY 
CORE-MT 
CORE-EDS 
^CURRENCY 
DATA 
*DATE 
DELETE 
DEPENDING 
DIGITS 
DIRECT 
DISPLAY 
DISPLAY-1 
DISPLAY-2 
DISPLAY-3 
DISPLAY-4 
DISPLAY-5 
DIVIDE 
DIVISION 
135 

A P P E N D I X 
EDS 
EDS-* 
ELSE 
*END 
ENTER 
ENVIRONMENT 
EQUAL 
EQUALS 
•ERROR 
•EVERY 
EXAMINE 
EXCEEDS 
EXIT 
FD 
FDS 
FDS-* 
FILE 
FILE-CONTROL 
FILLER 
FLOAT 
FROM 
GENERATION-NO 
GIVING 
GO 
GREATER 
HAND-KEYS 
HAND-VALUE 
HIGH-VALUES 
ID 
IDENTIFICATION 
IF 
IN 
INCLUDE 
INDEXED 
INPUT 
INPUT-OUTPUT 
INTO 
INVALID 
I-O-CONTROL 
**IS 
JUSTIFIED 
KEY 
KEYS 
LABEL 
LEAVING 
LEFT 
LESS 
*LINES 
LINKAGE 
•LOCATION 
LOCK 
LOW-VALUE 
LOW-VALUES 
LOWER-BOUND 
LOWER-BOUNDS 
MCF 
MCF-* 
MEMORY 
•MODE 
MOVE 
MULTIPLY 
NEGATIVE 
NEXT 
N O 
NOT 
NOTE 
N U M E R I C 
OBJECT-COMPUTER 
OBJECT-PROGRAM 
OCCURS 
**OP 
OFF 
OMITTED 
• • O N 
OPEN 
OR 
ORGANIZATION 
OTHERWISE 
OUTPUT 
PAPER-PUNCH 
PAPER-READER 
PERFORM 
PIC 
PICTURE 
•PLACES 
POINT 
POSITIVE 
PROCEDURE 
PROCEED 
PROCESSING 
PROGRAM-ID 
•PROTECT 
QUOTE 
QUOTES 
RANDOM 
RANGE 
READ 
**RECORD 
RECORDING 
RECORDS 
REDEFINES 
REEL 
RENAMES 
RERUN 
RESERVE 
REWIND 
REWRITE 
RIGHT 
R O U N D E D 
R U N 
SAME 
SECTION 
SEEK 
SEGMENT-LIMIT 
136 

A P P E N D I X 
SELECT 
* SENTENCE 
SEQUENCED 
SEQUENTIAL 
SIGN 
SIGNED 
SIZE 
SOURCE-COMPUTER 
SPACE 
SPACES 
SPECIAL-NAMES 
STANDARD 
*STATUS 
STOP 
SUBTRACT 
SUPPRESS 
SYMBOLIC 
SYNC 
SYNCHRONIZED 
TAPES 
TAPE-* 
*THAN 
*THEN 
T H R O U G H 
THRU 
*TIME 
TIMES 
TO 
TYPE 
TYPEWRITER 
UNEQUAL 
UNTIL 
UPON 
UPPER-BOUND 
UPPER-BOUNDS 
*USAGE 
USING 
VALUE 
VALUES 
VARYING 
*WHEN 
WITH 
WORDS 
WORKING-STORAGE 
WRITE 
ZERO 
ZEROES 
ZEROS 
137 

Index 
Accept 
50 
Active-time 
76 
Add 
25 
Advancing 
48, 49 
After 
48 
Algol 
2 
Alter 
63 
Alter . . . to proceed . 
Analysis stage 
112 
Arithmetic verbs 
23 
At end 
47 
Author 
18 
Before 
48 
Binary locations 
37 
Blank when zero 
89 
Block contains 
75 
Call 
68 
Character 9 81 
Character A 
82 
Character X 
82 
Character 1 82 
Character V 
83 
Character S 83 
Character Ρ 
83 
Character Ζ 
84 
Character * 
84 
Character £ 
85 
Character Β 
85 
Character . 
86 
Character , 
86 
Character 0 
86 
Character + 
86 
Character — 86 
Character CR 
86 
Character DB 
86 
Character set 
7 
Channel-n 
20 
Channels 
48 
Cheque protect 
89 
Class condition 
39 
Class is 
88 
Close 
46 
.to 
64 
COBOL'61 
3 
COBOL '65 
3 
COBOL Specification sheet 
12, 15 
Compiler 
4 
Computational 
91, 93 
Computational-1 
94 
Condition statements 
38 
Conditional names 
40, 106 
Conference in Data Systems Languages 
(CODASYL) 
3 
Configuration section 
19 
Consolidation 
4 
Consolidation stage 
4 
Constant section 
72,104 
Continuation indicator 
12, 13 
Copy 
69 
Core store print out 
113 
Data characters 
81 
Data division 
6, 7, 71 
Data maps 
112 
Data names 
9 
Data records 
76, 78 
Date-compiled 
18 
Date-written 
18 
Department for Defense (USA) 
3 
Disc 
2, 4, 45, 46, 50 
Display (usage clause) 
91, 92 
Display (verb) 
51 
Display-1 
93 
Display-2 
93 
139 

I N D E X 
Display-3 
93 
Display-4 
93 
Display-5 
93 
Divide 
32 
Editing characters 
84 
Editing clauses 
89 
Enter 
69 
Environment division 
6, 17 
Examine 
67 
Exit 
62 
Fields 
73 
Figurative constants 
11 
File contains 
74 
File-control 
20 
File description 
74 
File section 
71, 73 
Files 
1, 44, 72 
Filler 
79 
Float currency sign 
89 
Flowcharting 
110 
Fortran 
2 
From 
50 
Generation-number 
75 
Generation stage 
112 
Giving 
26, 30, 31 
Go to 
37, 47 
Identification 
75 
Identification division 
6, 17 
Identification sequence 
12, 13 
Identification symbols 
111 
If 
38 
Input 
44 
Input-output 
44 
Input-output section 
20 
Insertion characters 
85 
Installation 
18 
Key words 
8, 14 
Label records 
75 
Level numbers 
79 
Line printer 
45, 48 
Lines 
48 
Linkage section 
72, 105 
Literals—non-numeric 
9 
Literals—numeric 
10 
Lock 
46 
Logic 
111 
Low-level languages 
2 
Machine code 
2, 4 
Magnetic tape 
2, 4, 45, 46, 47 
Map 
112 
Memory size 
19 
Move 
36 
Multiply 
31 
Multiprogramming 
44 
No rewind 
46 
Notation 
14 
Note 
66 
Object-computer 
19 
Object program 
4 
Occurs 
96, 103, 107 
Off status 
20 
On size error 
28 
On status 
20 
Open 
44 
Operational characters 
83 
Optional words 
8, 16 
Output 
44 
Paper tape 
2, 4, 45 
Paragraphs 
7, 10, 24 
Perform 
55 
Picture 
81 
Point location 
89 
Print records 
48 
Procedure Division 
6, 7, 23 
Procedure names 
10 
Program-id 
17 
Program map 
112 
Program text 
12, 13 
Punched cards 
2, 4, 45 
Punctuation 
8 
Qualifying words 
11 
140 

I N D E X 
Read 
47 
Record 
72 
Record contains 
75 
Record description 
78 
Recording mode 
74 
Redefines 
99, 103 
Reel 
46 
Relation condition 
38 
Remainder 
33 
Remarks 
18 
Renames 
99 
Replace 
70 
Replacing 
67 
Report signs 
86 
Reserve . . . alternate area . . . 
20 
Reserved words 
14 
Rounded 
27 
Sections 
7, 10, 13, 23 
Security 
18 
Select... assign . . . 
20 
Sequence number 
12,112 
Sequenced on 
77 
Sign condition 
39 
Size 
88 
Source-computer 
19 
Source program 
4 
Special-names 
19 
Statements 
24 
Sterling locations 
37 
Stop 
65 
Stop run 
65 
Subscripting 
96 
Subtract 
30 
Synchronized 
94 
Syntax 
111 
Systematic desk checking 
110 
Tables 
103 
Tallying 
67 
Thru 
57, 100 
Truncating 
27 
Until 
60 
Upon 
51 
Usage clauses 
91 
Using 
68 
Value is 
99, 102, 106 
Value of identification 
76 
Varying 
61 
Verbs 
24 
Working-storage section 
72, 100 
Write 
47 
Zero suppression 
89 
141 

