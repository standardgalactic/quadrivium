An
In
tro
du tion
to
Programming
in
Ema s
Lisp


An
In
tro
du tion
to
Programming
in
Ema s
Lisp
Se ond
Edition
b
y
Rob
ert
J.
Chassell

Cop
yrigh
t
 

1990,
1991,
1992,
1993,
1994,
1995,
1997,
2001,
2002
F
ree
Soft
w
are
F
oundation,
In .
Published
b
y
the
F
ree
Soft
w
are
F
oundation,
In .
59
T
emple
Pla e,
Suite
330
Boston,
MA
02111-1307
USA
Edition
2.05,
2001
Jan
5
ISBN
1-882114-43-4
P
ermission
is
gran
ted
to
 op
y
,
distribute
and/or
mo
dify
this
do
 umen
t
under
the
terms
of
the
GNU
F
ree
Do
 umen
tation
Li ense,
V
ersion
1.1
or
an
y
later
v
ersion
published
b
y
the
F
ree
Soft
w
are
F
oundation;
there
b
eing
no
In
v
arian
t
Se tion,
with
the
F
ron
t-Co
v
er
T
exts
b
eing
\A
GNU
Man
ual",
and
with
the
Ba 
k-Co
v
er
T
exts
as
in
(a)
b
elo
w.
A
 op
y
of
the
li ense
is
in luded
in
the
se tion
en
titled
\GNU
F
ree
Do
 umen
tation
Li ense".
(a)
The
FSF's
Ba 
k-Co
v
er
T
ext
is:
\Y
ou
ha
v
e
freedom
to
 op
y
and
mo
dify
this
GNU
Man
ual,
lik
e
GNU
soft
w
are.
Copies
published
b
y
the
F
ree
Soft
w
are
F
oundation
raise
funds
for
GNU
dev
elopmen
t."

i
Short
Con
ten
ts
Prefa e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xi
1
List
Pro
 essing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
2
Pra ti ing
Ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
3
Ho
w
T
o
W
rite
F
un tion
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
4
A
F
ew
Buer{Related
F
un tions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
5
A
F
ew
More
Complex
F
un tions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63
6
Narro
wing
and
Widening
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
7
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
.
.
.
.
.
.
.
.
.
.
.
.
.
81
8
Cutting
and
Storing
T
ext
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
9
Ho
w
Lists
are
Implemen
ted
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
113
10
Y
anking
T
ext
Ba 
k
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
11
Lo
ops
and
Re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
12
Regular
Expression
Sear 
hes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
149
13
Coun
ting:
Rep
etition
and
Regexps
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
167
14
Coun
ting
W
ords
in
a
defun
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
181
15
Readying
a
Graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
16
Y
our
`.ema s'
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
17
Debugging
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
18
Con lusion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
239
App
endix
A
The
the-the
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
241
App
endix
B
Handling
the
Kill
Ring
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
App
endix
C
A
Graph
with
Lab
elled
Axes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
255
App
endix
D
GNU
F
ree
Do
 umen
tation
Li ense
.
.
.
.
.
.
.
.
.
.
.
279
Index
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
287

ii

iii
T
able
of
Con
ten
ts
Prefa e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xi
On
Reading
this
T
ext
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xi
F
or
Whom
This
is
W
ritten
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xii
Lisp
History
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiii
A
Note
for
No
vi es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiii
Thank
Y
ou
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiv
1
List
Pro
 essing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1.1
Lisp
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1.1.1
Lisp
A
toms
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1.1.2
Whitespa e
in
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
1.1.3
GNU
Ema s
Helps
Y
ou
T
yp
e
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
1.2
Run
a
Program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
1.3
Generate
an
Error
Message
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
1.4
Sym
b
ol
Names
and
F
un tion
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
6
1.5
The
Lisp
In
terpreter
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7
1.5.1
Byte
Compiling
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
1.6
Ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
1.6.1
Ev
aluating
Inner
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
1.7
V
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10
1.7.1
Error
Message
for
a
Sym
b
ol
Without
a
F
un tion
.
.
11
1.7.2
Error
Message
for
a
Sym
b
ol
Without
a
V
alue
.
.
.
.
11
1.8
Argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12
1.8.1
Argumen
ts'
Data
T
yp
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13
1.8.2
An
Argumen
t
as
the
V
alue
of
a
V
ariable
or
List
.
.
13
1.8.3
V
ariable
Num
b
er
of
Argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
1.8.4
Using
the
W
rong
T
yp
e
Ob
je t
as
an
Argumen
t
.
.
14
1.8.5
The
message
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16
1.9
Setting
the
V
alue
of
a
V
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
1.9.1
Using
set
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
1.9.2
Using
setq
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
18
1.9.3
Coun
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19
1.10
Summary
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20
1.11
Exer ises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20
2
Pra ti ing
Ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
2.1
Buer
Names
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
2.2
Getting
Buers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
25
2.3
Swit 
hing
Buers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26
2.4
Buer
Size
and
the
Lo
 ation
of
P
oin
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
2.5
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
28

iv
3
Ho
w
T
o
W
rite
F
un tion
Denitions
.
.
.
.
.
.
.
.
29
3.1
The
defun
Sp
e ial
F
orm
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
3.2
Install
a
F
un tion
Denition
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31
3.2.1
Change
a
F
un tion
Denition
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
32
3.3
Mak
e
a
F
un tion
In
tera tiv
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33
3.3.1
An
In
tera tiv
e
multiply-by-seven
.
.
.
.
.
.
.
.
.
.
.
.
.
34
3.4
Dieren
t
Options
for
intera tive
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35
3.5
Install
Co
de
P
ermanen
tly
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
3.6
let
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
3.6.1
The
P
arts
of
a
let
Expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
3.6.2
Sample
let
Expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38
3.6.3
Uninitialized
V
ariables
in
a
let
Statemen
t
.
.
.
.
.
.
.
39
3.7
The
if
Sp
e ial
F
orm
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39
3.7.1
The
type-of-animal
F
un tion
in
Detail
.
.
.
.
.
.
.
.
.
41
3.8
If{then{else
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
42
3.9
T
ruth
and
F
alseho
o
d
in
Ema s
Lisp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43
3.10
save-ex ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
3.10.1
T
emplate
for
a
save-ex ursion
Expression
.
.
.
.
45
3.11
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46
3.12
Exer ises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50
4
A
F
ew
Buer{Related
F
un tions
.
.
.
.
.
.
.
.
.
.
.
51
4.1
Finding
More
Information
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
4.2
A
Simplied
beginning-of-buffer
Denition
.
.
.
.
.
.
.
.
.
.
.
.
52
4.3
The
Denition
of
mark-whole-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54
4.3.1
Bo
dy
of
mark-whole-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55
4.4
The
Denition
of
append-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
56
4.4.1
The
append-to-buffer
In
tera tiv
e
Expression
.
.
.
57
4.4.2
The
Bo
dy
of
append-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
57
4.4.3
save-ex ursion
in
append-to-buffer
.
.
.
.
.
.
.
.
.
.
58
4.5
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
60
4.6
Exer ises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61

v
5
A
F
ew
More
Complex
F
un tions
.
.
.
.
.
.
.
.
.
.
.
63
5.1
The
Denition
of
 opy-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63
5.2
The
Denition
of
insert-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
64
5.2.1
The
In
tera tiv
e
Expression
in
insert-buffer
.
.
.
.
65
A
Read-only
Buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65
`b'
in
an
In
tera tiv
e
Expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65
5.2.2
The
Bo
dy
of
the
insert-buffer
F
un tion
.
.
.
.
.
.
.
65
5.2.3
insert-buffer
With
an
if
Instead
of
an
or
.
.
.
.
.
66
5.2.4
The
or
in
the
Bo
dy
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
67
5.2.5
The
let
Expression
in
insert-buffer
.
.
.
.
.
.
.
.
.
.
68
5.3
Complete
Denition
of
beginning-of-buffer
.
.
.
.
.
.
.
.
.
.
.
.
69
5.3.1
Optional
Argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
5.3.2
beginning-of-buffer
with
an
Argumen
t
.
.
.
.
.
.
.
71
What
happ
ens
in
a
large
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
71
What
happ
ens
in
a
small
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
5.3.3
The
Complete
beginning-of-buffer
.
.
.
.
.
.
.
.
.
.
.
73
5.4
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74
5.5
optional
Argumen
t
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75
6
Narro
wing
and
Widening
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
6.1
The
save-restri tion
Sp
e ial
F
orm
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
6.2
what-line
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78
6.3
Exer ise
with
Narro
wing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79
7
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
.
.
.
.
.
81
7.1
 ar
and
 dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
81
7.2
 ons
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83
7.2.1
Find
the
Length
of
a
List:
length
.
.
.
.
.
.
.
.
.
.
.
.
.
.
84
7.3
nth dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85
7.4
nth
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86
7.5
set ar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
87
7.6
set dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88
7.7
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88

vi
8
Cutting
and
Storing
T
ext
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
8.1
zap-to- har
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90
8.1.1
The
intera tive
Expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90
8.1.2
The
Bo
dy
of
zap-to- har
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
91
8.1.3
The
sear h-forward
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
92
8.1.4
The
progn
Sp
e ial
F
orm
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
93
8.1.5
Summing
up
zap-to- har
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
93
8.2
kill-region
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94
8.2.1
 ondition- ase
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95
8.2.2
delete-and-extra t-regi
on
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96
8.3
delete-and-extra t-regio
n:
Digressing
in
to
C
.
.
.
.
.
.
.
.
.
98
8.4
Initializing
a
V
ariable
with
defvar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100
8.4.1
defvar
and
an
asterisk
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101
8.5
 opy-region-as-kill
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
102
8.5.1
The
Bo
dy
of
 opy-region-as-kill
.
.
.
.
.
.
.
.
.
.
.
.
103
The
kill-append
fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
104
The
kill-new
fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105
8.6
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109
8.7
Sear 
hing
Exer ises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111
9
Ho
w
Lists
are
Implemen
ted
.
.
.
.
.
.
.
.
.
.
.
.
.
.
113
9.1
Sym
b
ols
as
a
Chest
of
Dra
w
ers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
115
9.2
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116
10
Y
anking
T
ext
Ba 
k
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
10.1
Kill
Ring
Ov
erview
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
10.2
The
kill-ring-yank-pointer
V
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
10.3
Exer ises
with
yank
and
nth dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
119
11
Lo
ops
and
Re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
11.1
while
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
11.1.1
A
while
Lo
op
and
a
List
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
122
11.1.2
An
Example:
print-elements-of-list
.
.
.
.
.
.
123
11.1.3
A
Lo
op
with
an
In remen
ting
Coun
ter
.
.
.
.
.
.
.
.
124
Example
with
in remen
ting
 oun
ter
.
.
.
.
.
.
.
.
.
.
.
125
The
parts
of
the
fun tion
denition
.
.
.
.
.
.
.
.
.
.
.
.
126
Putting
the
fun tion
denition
together
.
.
.
.
.
.
.
.
127
11.1.4
Lo
op
with
a
De remen
ting
Coun
ter
.
.
.
.
.
.
.
.
.
.
.
129
Example
with
de remen
ting
 oun
ter
.
.
.
.
.
.
.
.
.
.
.
129
The
parts
of
the
fun tion
denition
.
.
.
.
.
.
.
.
.
.
.
.
130
Putting
the
fun tion
denition
together
.
.
.
.
.
.
.
.
130
11.2
Sa
v
e
y
our
time:
dolist
and
dotimes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
131
The
dolist
Ma ro
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
132
The
dotimes
Ma ro
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
133

vii
11.3
Re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
134
11.3.1
Building
Rob
ots:
Extending
the
Metaphor
.
.
.
.
.
134
11.3.2
The
P
arts
of
a
Re ursiv
e
Denition
.
.
.
.
.
.
.
.
.
.
.
135
11.3.3
Re ursion
with
a
List
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
136
11.3.4
Re ursion
in
Pla e
of
a
Coun
ter
.
.
.
.
.
.
.
.
.
.
.
.
.
.
137
An
argumen
t
of
3
or
4
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
138
11.3.5
Re ursion
Example
Using
 ond
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
139
11.3.6
Re ursiv
e
P
atterns
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
140
Re ursiv
e
P
attern:
every
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
141
Re ursiv
e
P
attern:
a 
 umulate
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
142
Re ursiv
e
P
attern:
ke
ep
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
143
11.3.7
Re ursion
without
Defermen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
143
11.3.8
No
Defermen
t
Solution
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
145
11.4
Lo
oping
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
147
12
Regular
Expression
Sear 
hes
.
.
.
.
.
.
.
.
.
.
.
.
149
12.1
The
Regular
Expression
for
senten e-end
.
.
.
.
.
.
.
.
.
.
.
.
.
149
12.2
The
re-sear h-forward
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
150
12.3
forward-senten e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
151
The
while
lo
ops
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
153
The
regular
expression
sear 
h
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
154
12.4
forward-paragraph:
a
Goldmine
of
F
un tions
.
.
.
.
.
.
.
.
.
155
The
let*
expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
156
The
forw
ard
motion
while
lo
op
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
158
Bet
w
een
paragraphs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
159
Within
paragraphs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
160
No
ll
prex
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
160
With
a
ll
prex
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
161
Summary
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
161
12.5
Create
Y
our
Own
`TAGS'
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
163
12.6
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
164
12.7
Exer ises
with
re-sear h-forward
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
166
13
Coun
ting:
Rep
etition
and
Regexps
.
.
.
.
.
.
167
13.1
The
 ount-words-region
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
167
13.1.1
The
Whitespa e
Bug
in
 ount-words-region
.
.
170
13.2
Coun
t
W
ords
Re ursiv
ely
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
173
13.3
Exer ise:
Coun
ting
Pun tuation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
179

viii
14
Coun
ting
W
ords
in
a
defun
.
.
.
.
.
.
.
.
.
.
.
.
.
.
181
14.1
What
to
Coun
t?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
181
14.2
What
Constitutes
a
W
ord
or
Sym
b
ol?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
182
14.3
The
 ount-words-in-defun
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
183
14.4
Coun
t
Sev
eral
defuns
Within
a
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
186
14.5
Find
a
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
187
14.6
lengths-list-file
in
Detail
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
188
14.7
Coun
t
W
ords
in
defuns
in
Dieren
t
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
190
14.7.1
The
append
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
191
14.8
Re ursiv
ely
Coun
t
W
ords
in
Dieren
t
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
192
14.9
Prepare
the
Data
for
Displa
y
in
a
Graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
193
14.9.1
Sorting
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
193
14.9.2
Making
a
List
of
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
194
14.9.3
Coun
ting
fun tion
denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
197
15
Readying
a
Graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
15.1
The
graph-body-print
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
208
15.2
The
re ursive-graph-body-prin
t
F
un tion
.
.
.
.
.
.
.
.
.
.
.
210
15.3
Need
for
Prin
ted
Axes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
212
15.4
Exer ise
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
212
16
Y
our
`.ema s'
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
16.1
Site-wide
Initialization
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
16.2
Sp
e ifying
V
ariables
using
def ustom
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
214
16.3
Beginning
a
`.ema s'
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
216
16.4
T
ext
and
Auto
Fill
Mo
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
217
16.5
Mail
Aliases
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
16.6
Inden
t
T
abs
Mo
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
16.7
Some
Keybindings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
16.8
Keymaps
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
16.9
Loading
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
222
16.10
Autoloading
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
223
16.11
A
Simple
Extension:
line-to-top-of-window
.
.
.
.
.
.
.
.
224
16.12
X11
Colors
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
226
16.13
Mis ellaneous
Settings
for
a
`.ema s'
File
.
.
.
.
.
.
.
.
.
.
.
.
.
227
16.14
A
Mo
died
Mo
de
Line
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
228
17
Debugging
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
17.1
debug
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
17.2
debug-on-entry
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
232
17.3
debug-on-quit
and
(debug)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
234
17.4
The
edebug
Sour e
Lev
el
Debugger
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
235
17.5
Debugging
Exer ises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
237

ix
18
Con lusion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
239
App
endix
A
The
the-the
F
un tion
.
.
.
.
.
.
.
.
.
.
241
App
endix
B
Handling
the
Kill
Ring
.
.
.
.
.
.
.
.
243
B.1
The
rotate-yank-pointer
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
B.1.1
The
Bo
dy
of
rotate-yank-pointer
.
.
.
.
.
.
.
.
.
.
.
244
The
else-part
of
the
if
expression
.
.
.
.
.
.
.
.
.
.
.
.
.
245
The
%
remainder
fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
247
Using
%
in
rotate-yank-pointer
.
.
.
.
.
.
.
.
.
.
.
.
.
248
P
oin
ting
to
the
last
elemen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
248
B.2
yank
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
249
P
assing
the
argumen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
250
P
assing
a
negativ
e
argumen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
251
B.3
yank-pop
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
252
App
endix
C
A
Graph
with
Lab
elled
Axes
.
.
.
255
C.1
The
print-graph
V
arlist
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
C.2
The
print-Y-axis
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
C.2.1
Side
T
rip:
Compute
a
Remainder
.
.
.
.
.
.
.
.
.
.
.
.
.
.
258
C.2.2
Constru t
a
Y
Axis
Elemen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
259
C.2.3
Create
a
Y
Axis
Column
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
261
C.2.4
The
Not
Quite
Final
V
ersion
of
print-Y-axis
.
.
262
C.3
The
print-X-axis
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
263
C.3.1
X
Axis
Ti 
Marks
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
263
C.4
Prin
ting
the
Whole
Graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
267
C.4.1
T
esting
print-graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
270
C.4.2
Graphing
Num
b
ers
of
W
ords
and
Sym
b
ols
.
.
.
.
.
271
C.4.3
A
lambda
Expression:
Useful
Anon
ymit
y
.
.
.
.
.
.
.
272
C.4.4
The
map ar
F
un tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
274
C.4.5
Another
Bug
.
.
.
Most
Insidious
.
.
.
.
.
.
.
.
.
.
.
.
.
.
274
C.4.6
The
Prin
ted
Graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
277
App
endix
D
GNU
F
ree
Do
 umen
tation
Li ense
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
279
Index
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
287

x

On
Reading
this
T
ext
xi
Prefa e
Most
of
the
GNU
Ema s
in
tegrated
en
vironmen
t
is
written
in
the
pro-
gramming
language
 alled
Ema s
Lisp.
The
 o
de
written
in
this
program-
ming
language
is
the
soft
w
are|the
sets
of
instru tions|that
tell
the
 om-
puter
what
to
do
when
y
ou
giv
e
it
 ommands.
Ema s
is
designed
so
that
y
ou
 an
write
new
 o
de
in
Ema s
Lisp
and
easily
install
it
as
an
extension
to
the
editor.
(GNU
Ema s
is
sometimes
 alled
an
\extensible
editor",
but
it
do
es
m
u 
h
more
than
pro
vide
editing
 apabilities.
It
is
b
etter
to
refer
to
Ema s
as
an
\extensible
 omputing
en
vironmen
t".
Ho
w
ev
er,
that
phrase
is
quite
a
mouthful.
It
is
easier
to
refer
to
Ema s
simply
as
an
editor.
Moreo
v
er,
ev
erything
y
ou
do
in
Ema s|nd
the
Ma
y
an
date
and
phases
of
the
mo
on,
simplify
p
olynomials,
debug
 o
de,
manage
les,
read
letters,
write
b
o
oks|all
these
a tivities
are
kinds
of
editing
in
the
most
general
sense
of
the
w
ord.)
Although
Ema s
Lisp
is
usually
though
t
of
in
asso
 iation
only
with
Ema s,
it
is
a
full
 omputer
programming
language.
Y
ou
 an
use
Ema s
Lisp
as
y
ou
w
ould
an
y
other
programming
language.
P
erhaps
y
ou
w
an
t
to
understand
programming;
p
erhaps
y
ou
w
an
t
to
ex-
tend
Ema s;
or
p
erhaps
y
ou
w
an
t
to
b
e ome
a
programmer.
This
in
tro
du -
tion
to
Ema s
Lisp
is
designed
to
get
y
ou
started:
to
guide
y
ou
in
learning
the
fundamen
tals
of
programming,
and
more
imp
ortan
tly
,
to
sho
w
y
ou
ho
w
y
ou
 an
tea 
h
y
ourself
to
go
further.
On
Reading
this
T
ext
All
through
this
do
 umen
t,
y
ou
will
see
little
sample
programs
y
ou
 an
run
inside
of
Ema s.
If
y
ou
read
this
do
 umen
t
in
Info
inside
of
GNU
Ema s,
y
ou
 an
run
the
programs
as
they
app
ear.
(This
is
easy
to
do
and
is
explained
when
the
examples
are
presen
ted.)
Alternativ
ely
,
y
ou
 an
read
this
in
tro
du tion
as
a
prin
ted
b
o
ok
while
sitting
b
eside
a
 omputer
running
Ema s.
(This
is
what
I
lik
e
to
do;
I
lik
e
prin
ted
b
o
oks.)
If
y
ou
don't
ha
v
e
a
running
Ema s
b
eside
y
ou,
y
ou
 an
still
read
this
b
o
ok,
but
in
this
 ase,
it
is
b
est
to
treat
it
as
a
no
v
el
or
as
a
tra
v
el
guide
to
a
 oun
try
not
y
et
visited:
in
teresting,
but
not
the
same
as
b
eing
there.
Mu 
h
of
this
in
tro
du tion
is
dedi ated
to
w
alk-throughs
or
guided
tours
of
 o
de
used
in
GNU
Ema s.
These
tours
are
designed
for
t
w
o
purp
oses:
rst,
to
giv
e
y
ou
familiarit
y
with
real,
w
orking
 o
de
( o
de
y
ou
use
ev
ery
da
y);
and,
se ond,
to
giv
e
y
ou
familiarit
y
with
the
w
a
y
Ema s
w
orks.
It
is
in
teresting
to
see
ho
w
a
w
orking
en
vironmen
t
is
implemen
ted.
Also,
I
hop
e
that
y
ou
will
pi 
k
up
the
habit
of
bro
wsing
through
sour e
 o
de.
Y
ou
 an
learn
from
it
and
mine
it
for
ideas.
Ha
ving
GNU
Ema s
is
lik
e
ha
ving
a
dragon's
 a
v
e
of
treasures.
In
addition
to
learning
ab
out
Ema s
as
an
editor
and
Ema s
Lisp
as
a
programming
language,
the
examples
and
guided
tours
will
giv
e
y
ou
an

xii
Prefa e
opp
ortunit
y
to
get
a quain
ted
with
Ema s
as
a
Lisp
programming
en
viron-
men
t.
GNU
Ema s
supp
orts
programming
and
pro
vides
to
ols
that
y
ou
will
w
an
t
to
b
e ome
 omfortable
using,
su 
h
as
M-.
(the
k
ey
whi 
h
in
v
ok
es
the
find-tag
 ommand).
Y
ou
will
also
learn
ab
out
buers
and
other
ob
je ts
that
are
part
of
the
en
vironmen
t.
Learning
ab
out
these
features
of
Ema s
is
lik
e
learning
new
routes
around
y
our
home
to
wn.
Finally
,
I
hop
e
to
 on
v
ey
some
of
the
skills
for
using
Ema s
to
learn
asp
e ts
of
programming
that
y
ou
don't
kno
w.
Y
ou
 an
often
use
Ema s
to
help
y
ou
understand
what
puzzles
y
ou
or
to
nd
out
ho
w
to
do
something
new.
This
self-relian e
is
not
only
a
pleasure,
but
an
adv
an
tage.
F
or
Whom
This
is
W
ritten
This
text
is
written
as
an
elemen
tary
in
tro
du tion
for
p
eople
who
are
not
programmers.
If
y
ou
are
a
programmer,
y
ou
ma
y
not
b
e
satised
with
this
primer.
The
reason
is
that
y
ou
ma
y
ha
v
e
b
e ome
exp
ert
at
reading
referen e
man
uals
and
b
e
put
o
b
y
the
w
a
y
this
text
is
organized.
An
exp
ert
programmer
who
review
ed
this
text
said
to
me:
I
pr
efer
to
le
arn
fr
om
r
efer
en 
e
manuals.
I
\dive
into"
e
a h
p
ar
a-
gr
aph,
and
\ 
ome
up
for
air"
b
etwe
en
p
ar
agr
aphs.
When
I
get
to
the
end
of
a
p
ar
agr
aph,
I
assume
that
that
subje
 t
is
done,
nishe
d,
that
I
know
everything
I
ne
e
d
(with
the
p
ossible
ex 
eption
of
the
 
ase
when
the
next
p
ar
agr
aph
starts
talking
ab
out
it
in
mor
e
detail).
I
exp
e
 t
that
a
wel
l
written
r
efer
en 
e
manual
wil
l
not
have
a
lot
of
r
e
dundan y,
and
that
it
wil
l
have
ex 
el
lent
p
ointers
to
the
(one)
pla 
e
wher
e
the
information
I
want
is.
This
in
tro
du tion
is
not
written
for
this
p
erson!
Firstly
,
I
try
to
sa
y
ev
erything
at
least
three
times:
rst,
to
in
tro
du e
it;
se ond,
to
sho
w
it
in
 on
text;
and
third,
to
sho
w
it
in
a
dieren
t
 on
text,
or
to
review
it.
Se ondly
,
I
hardly
ev
er
put
all
the
information
ab
out
a
sub
je t
in
one
pla e,
m
u 
h
less
in
one
paragraph.
T
o
m
y
w
a
y
of
thinking,
that
imp
oses
to
o
hea
vy
a
burden
on
the
reader.
Instead
I
try
to
explain
only
what
y
ou
need
to
kno
w
at
the
time.
(Sometimes
I
in lude
a
little
extra
information
so
y
ou
w
on't
b
e
surprised
later
when
the
additional
information
is
formally
in
tro
du ed.)
When
y
ou
read
this
text,
y
ou
are
not
exp
e ted
to
learn
ev
erything
the
rst
time.
F
requen
tly
,
y
ou
need
only
mak
e,
as
it
w
ere,
a
`no
dding
a quain
tan e'
with
some
of
the
items
men
tioned.
My
hop
e
is
that
I
ha
v
e
stru tured
the
text
and
giv
en
y
ou
enough
hin
ts
that
y
ou
will
b
e
alert
to
what
is
imp
ortan
t,
and
 on en
trate
on
it.
Y
ou
will
need
to
\div
e
in
to"
some
paragraphs;
there
is
no
other
w
a
y
to
read
them.
But
I
ha
v
e
tried
to
k
eep
do
wn
the
n
um
b
er
of
su 
h
paragraphs.

A
Note
for
No
vi es
xiii
This
b
o
ok
is
in
tended
as
an
approa 
hable
hill,
rather
than
as
a
daun
ting
moun
tain.
This
in
tro
du tion
to
Programming
in
Ema s
Lisp
has
a
 ompanion
do
 -
umen
t,
The
GNU
Ema s
Lisp
Referen e
Man
ual.
The
referen e
man
ual
has
more
detail
than
this
in
tro
du tion.
In
the
referen e
man
ual,
all
the
infor-
mation
ab
out
one
topi 
is
 on en
trated
in
one
pla e.
Y
ou
should
turn
to
it
if
y
ou
are
lik
e
the
programmer
quoted
ab
o
v
e.
And,
of
 ourse,
after
y
ou
ha
v
e
read
this
In
tro
du tion,
y
ou
will
nd
the
Referen e
Man
ual
useful
when
y
ou
are
writing
y
our
o
wn
programs.
Lisp
History
Lisp
w
as
rst
dev
elop
ed
in
the
late
1950s
at
the
Massa 
h
usetts
Institute
of
T
e 
hnology
for
resear 
h
in
arti ial
in
telligen e.
The
great
p
o
w
er
of
the
Lisp
language
mak
es
it
sup
erior
for
other
purp
oses
as
w
ell,
su 
h
as
writing
editor
 ommands
and
in
tegrated
en
vironmen
ts.
GNU
Ema s
Lisp
is
largely
inspired
b
y
Ma lisp,
whi 
h
w
as
written
at
MIT
in
the
1960s.
It
is
somewhat
inspired
b
y
Common
Lisp,
whi 
h
b
e ame
a
standard
in
the
1980s.
Ho
w
ev
er,
Ema s
Lisp
is
m
u 
h
simpler
than
Common
Lisp.
(The
standard
Ema s
distribution
 on
tains
an
optional
extensions
le,
` l.el',
that
adds
man
y
Common
Lisp
features
to
Ema s
Lisp.)
A
Note
for
No
vi es
If
y
ou
don't
kno
w
GNU
Ema s,
y
ou
 an
still
read
this
do
 umen
t
prof-
itably
.
Ho
w
ev
er,
I
re ommend
y
ou
learn
Ema s,
if
only
to
learn
to
mo
v
e
around
y
our
 omputer
s reen.
Y
ou
 an
tea 
h
y
ourself
ho
w
to
use
Ema s
with
the
on-line
tutorial.
T
o
use
it,
t
yp
e
C-h
t.
(This
means
y
ou
press
and
release
the
h
CTRL
i
k
ey
and
the
h
at
the
same
time,
and
then
press
and
release
t.)
Also,
I
often
refer
to
one
of
Ema s'
standard
 ommands
b
y
listing
the
k
eys
whi 
h
y
ou
press
to
in
v
ok
e
the
 ommand
and
then
giving
the
name
of
the
 ommand
in
paren
theses,
lik
e
this:
M-C-\
(indent-region).
What
this
means
is
that
the
indent-region
 ommand
is
 ustomarily
in
v
ok
ed
b
y
t
yping
M-C-\.
(Y
ou
 an,
if
y
ou
wish,
 
hange
the
k
eys
that
are
t
yp
ed
to
in
v
ok
e
the
 ommand;
this
is
 alled
rebinding.
See
Se tion
16.8,
\Keymaps",
page
221.)
The
abbreviation
M-C-\
means
that
y
ou
t
yp
e
y
our
h
MET
A
i
k
ey
,
h
CTRL
i
k
ey
and
h
\
i
k
ey
all
at
the
same
time.
(On
man
y
mo
dern
k
eyb
oards
the
h
MET
A
i
k
ey
is
lab
elled
h
AL
T
i
.)
Sometimes
a
 om
bination
lik
e
this
is
 alled
a
k
ey 
hord,
sin e
it
is
similar
to
the
w
a
y
y
ou
pla
y
a
 
hord
on
a
piano.
If
y
our
k
eyb
oard
do
es
not
ha
v
e
a
h
MET
A
i
k
ey
,
the
h
ESC
i
k
ey
prex
is
used
in
pla e
of
it.
In
this
 ase,
M-C-\
means
that
y
ou
press
and
release
y
our
h
ESC
i
k
ey
and
then
t
yp
e
the
h
CTRL
i
k
ey
and
the
h
\
i
k
ey
at
the
same
time.
But
usually
M-C-\
means
press
the
h
CTRL
i
k
ey
along
with
the
k
ey
that
is
lab
elled
h
AL
T
i
and,
at
the
same
time,
press
the
h
\
i
k
ey
.

xiv
Prefa e
In
addition
to
t
yping
a
lone
k
ey 
hord,
y
ou
 an
prex
what
y
ou
t
yp
e
with
C-u,
whi 
h
is
 alled
the
`univ
ersal
argumen
t'.
The
C-u
k
ey 
hord
passes
an
argumen
t
to
the
subsequen
t
 ommand.
Th
us,
to
inden
t
a
region
of
plain
text
b
y
6
spa es,
mark
the
region,
and
then
t
yp
e
C-u
6
M-C-\
.
(If
y
ou
do
not
sp
e ify
a
n
um
b
er,
Ema s
either
passes
the
n
um
b
er
4
to
the
 ommand
or
otherwise
runs
the
 ommand
dieren
tly
than
it
w
ould
otherwise.)
See
se tion
\Numeri 
Argumen
ts"
in
The
GNU
Ema s
Man
ual
.
If
y
ou
are
reading
this
in
Info
using
GNU
Ema s,
y
ou
 an
read
through
this
whole
do
 umen
t
just
b
y
pressing
the
spa e
bar,
h
SPC
i
.
(T
o
learn
ab
out
Info,
t
yp
e
C-h
i
and
then
sele t
Info.)
A
note
on
terminology:
when
I
use
the
w
ord
Lisp
alone,
I
often
am
referring
to
the
v
arious
diale ts
of
Lisp
in
general,
but
when
I
sp
eak
of
Ema s
Lisp,
I
am
referring
to
GNU
Ema s
Lisp
in
parti ular.
Thank
Y
ou
My
thanks
to
all
who
help
ed
me
with
this
b
o
ok.
My
esp
e ial
thanks
to
Jim
Blandy,
Noah
F
riedman,
Jim
Kingdon
,
Roland
M Grath,
F
rank
Ritter,
Randy
Smith
,
Ri 
hard
M.
Stallman
,
and
Melissa
W
eisshaus.
My
thanks
also
go
to
b
oth
Philip
Johnson
and
Da
vid
Stamp
e
for
their
patien
t
en our-
agemen
t.
My
mistak
es
are
m
y
o
wn.
Rob
ert
J.
Chassell

Lisp
A
toms
1
1
List
Pro
 essing
T
o
the
un
tutored
ey
e,
Lisp
is
a
strange
programming
language.
In
Lisp
 o
de
there
are
paren
theses
ev
erywhere.
Some
p
eople
ev
en
 laim
that
the
name
stands
for
`Lots
of
Isolated
Silly
P
aren
theses'.
But
the
 laim
is
un-
w
arran
ted.
Lisp
stands
for
LISt
Pro
 essing,
and
the
programming
language
handles
lists
(and
lists
of
lists)
b
y
putting
them
b
et
w
een
paren
theses.
The
paren
theses
mark
the
b
oundaries
of
the
list.
Sometimes
a
list
is
pre eded
b
y
a
single
ap
ostrophe
or
quotation
mark,
`''.
Lists
are
the
basis
of
Lisp.
1.1
Lisp
Lists
In
Lisp,
a
list
lo
oks
lik
e
this:
'(rose
violet
daisy
butter up).
This
list
is
pre eded
b
y
a
single
ap
ostrophe.
It
 ould
just
as
w
ell
b
e
written
as
follo
ws,
whi 
h
lo
oks
more
lik
e
the
kind
of
list
y
ou
are
lik
ely
to
b
e
familiar
with:
'(rose
violet
daisy
butter up)
The
elemen
ts
of
this
list
are
the
names
of
the
four
dieren
t
o
w
ers,
separated
from
ea 
h
other
b
y
whitespa e
and
surrounded
b
y
paren
theses,
lik
e
o
w
ers
in
a
eld
with
a
stone
w
all
around
them.
Lists
 an
also
ha
v
e
n
um
b
ers
in
them,
as
in
this
list:
(+
2
2).
This
list
has
a
plus-sign,
`+',
follo
w
ed
b
y
t
w
o
`2's,
ea 
h
separated
b
y
whitespa e.
In
Lisp,
b
oth
data
and
programs
are
represen
ted
the
same
w
a
y;
that
is,
they
are
b
oth
lists
of
w
ords,
n
um
b
ers,
or
other
lists,
separated
b
y
white-
spa e
and
surrounded
b
y
paren
theses.
(Sin e
a
program
lo
oks
lik
e
data,
one
program
ma
y
easily
serv
e
as
data
for
another;
this
is
a
v
ery
p
o
w
erful
feature
of
Lisp.)
(In iden
tally
,
these
t
w
o
paren
theti al
remarks
are
not
Lisp
lists,
b
e ause
they
 on
tain
`;'
and
`.'
as
pun tuation
marks.)
Here
is
another
list,
this
time
with
a
list
inside
of
it:
'(this
list
has
(a
list
inside
of
it))
The
 omp
onen
ts
of
this
list
are
the
w
ords
`this',
`list',
`has',
and
the
list
`(a
list
inside
of
it)'.
The
in
terior
list
is
made
up
of
the
w
ords
`a',
`list',
`inside',
`of',
`it'.
1.1.1
Lisp
A
toms
In
Lisp,
what
w
e
ha
v
e
b
een
 alling
w
ords
are
 alled
atoms.
This
term
 omes
from
the
histori al
meaning
of
the
w
ord
atom,
whi 
h
means
`indivis-
ible'.
As
far
as
Lisp
is
 on erned,
the
w
ords
w
e
ha
v
e
b
een
using
in
the
lists
 annot
b
e
divided
in
to
an
y
smaller
parts
and
still
mean
the
same
thing
as
part
of
a
program;
lik
ewise
with
n
um
b
ers
and
single
 
hara ter
sym
b
ols
lik
e

2
Chapter
1:
List
Pro
 essing
`+'.
On
the
other
hand,
unlik
e
an
atom,
a
list
 an
b
e
split
in
to
parts.
(See
Chapter
7,
\ ar
 dr
&
 ons
F
undamen
tal
F
un tions",
page
81.)
In
a
list,
atoms
are
separated
from
ea 
h
other
b
y
whitespa e.
They
 an
b
e
righ
t
next
to
a
paren
thesis.
T
e 
hni ally
sp
eaking,
a
list
in
Lisp
 onsists
of
paren
theses
surrounding
atoms
separated
b
y
whitespa e
or
surrounding
other
lists
or
surrounding
b
oth
atoms
and
other
lists.
A
list
 an
ha
v
e
just
one
atom
in
it
or
ha
v
e
nothing
in
it
at
all.
A
list
with
nothing
in
it
lo
oks
lik
e
this:
(),
and
is
 alled
the
empt
y
list.
Unlik
e
an
ything
else,
an
empt
y
list
is
 onsidered
b
oth
an
atom
and
a
list
at
the
same
time.
The
prin
ted
represen
tation
of
b
oth
atoms
and
lists
are
 alled
sym
b
oli 
expressions
or,
more
 on isely
,
s-expressions.
The
w
ord
expression
b
y
itself
 an
refer
to
either
the
prin
ted
represen
tation,
or
to
the
atom
or
list
as
it
is
held
in
ternally
in
the
 omputer.
Often,
p
eople
use
the
term
expression
indis riminately
.
(Also,
in
man
y
texts,
the
w
ord
form
is
used
as
a
synon
ym
for
expression.)
In iden
tally
,
the
atoms
that
mak
e
up
our
univ
erse
w
ere
named
su 
h
when
they
w
ere
though
t
to
b
e
indivisible;
but
it
has
b
een
found
that
ph
ysi al
atoms
are
not
indivisible.
P
arts
 an
split
o
an
atom
or
it
 an
ssion
in
to
t
w
o
parts
of
roughly
equal
size.
Ph
ysi al
atoms
w
ere
named
prematurely
,
b
efore
their
truer
nature
w
as
found.
In
Lisp,
 ertain
kinds
of
atom,
su 
h
as
an
arra
y
,
 an
b
e
separated
in
to
parts;
but
the
me 
hanism
for
doing
this
is
dieren
t
from
the
me 
hanism
for
splitting
a
list.
As
far
as
list
op
erations
are
 on erned,
the
atoms
of
a
list
are
unsplittable.
As
in
English,
the
meanings
of
the
 omp
onen
t
letters
of
a
Lisp
atom
are
dieren
t
from
the
meaning
the
letters
mak
e
as
a
w
ord.
F
or
example,
the
w
ord
for
the
South
Ameri an
sloth,
the
`ai',
is
 ompletely
dieren
t
from
the
t
w
o
w
ords,
`a',
and
`i'.
There
are
man
y
kinds
of
atom
in
nature
but
only
a
few
in
Lisp:
for
example,
n
um
b
ers,
su 
h
as
37,
511,
or
1729,
and
sym
b
ols,
su 
h
as
`+',
`foo',
or
`forward-line'.
The
w
ords
w
e
ha
v
e
listed
in
the
examples
ab
o
v
e
are
all
sym
b
ols.
In
ev
eryda
y
Lisp
 on
v
ersation,
the
w
ord
\atom"
is
not
often
used,
b
e ause
programmers
usually
try
to
b
e
more
sp
e i 
ab
out
what
kind
of
atom
they
are
dealing
with.
Lisp
programming
is
mostly
ab
out
sym
b
ols
(and
sometimes
n
um
b
ers)
within
lists.
(In iden
tally
,
the
pre eding
three
w
ord
paren
theti al
remark
is
a
prop
er
list
in
Lisp,
sin e
it
 onsists
of
atoms,
whi 
h
in
this
 ase
are
sym
b
ols,
separated
b
y
whitespa e
and
en losed
b
y
paren
theses,
without
an
y
non-Lisp
pun tuation.)

GNU
Ema s
Helps
Y
ou
T
yp
e
Lists
3
In
addition,
text
b
et
w
een
double
quotation
marks|ev
en
sen
ten es
or
paragraphs|is
an
atom.
Here
is
an
example:
'(this
list
in ludes
"text
between
quotation
marks.")
In
Lisp,
all
of
the
quoted
text
in luding
the
pun tuation
mark
and
the
blank
spa es
is
a
single
atom.
This
kind
of
atom
is
 alled
a
string
(for
`string
of
 
hara ters')
and
is
the
sort
of
thing
that
is
used
for
messages
that
a
 omputer
 an
prin
t
for
a
h
uman
to
read.
Strings
are
a
dieren
t
kind
of
atom
than
n
um
b
ers
or
sym
b
ols
and
are
used
dieren
tly
.
1.1.2
Whitespa e
in
Lists
The
amoun
t
of
whitespa e
in
a
list
do
es
not
matter.
F
rom
the
p
oin
t
of
view
of
the
Lisp
language,
'(this
list
looks
like
this)
is
exa tly
the
same
as
this:
'(this
list
looks
like
this)
Both
examples
sho
w
what
to
Lisp
is
the
same
list,
the
list
made
up
of
the
sym
b
ols
`this',
`list',
`looks',
`like',
and
`this'
in
that
order.
Extra
whitespa e
and
newlines
are
designed
to
mak
e
a
list
more
readable
b
y
h
umans.
When
Lisp
reads
the
expression,
it
gets
rid
of
all
the
extra
whitespa e
(but
it
needs
to
ha
v
e
at
least
one
spa e
b
et
w
een
atoms
in
order
to
tell
them
apart.)
Odd
as
it
seems,
the
examples
w
e
ha
v
e
seen
 o
v
er
almost
all
of
what
Lisp
lists
lo
ok
lik
e!
Ev
ery
other
list
in
Lisp
lo
oks
more
or
less
lik
e
one
of
these
examples,
ex ept
that
the
list
ma
y
b
e
longer
and
more
 omplex.
In
brief,
a
list
is
b
et
w
een
paren
theses,
a
string
is
b
et
w
een
quotation
marks,
a
sym
b
ol
lo
oks
lik
e
a
w
ord,
and
a
n
um
b
er
lo
oks
lik
e
a
n
um
b
er.
(F
or
 ertain
situations,
square
bra 
k
ets,
dots
and
a
few
other
sp
e ial
 
hara ters
ma
y
b
e
used;
ho
w
ev
er,
w
e
will
go
quite
far
without
them.)
1.1.3
GNU
Ema s
Helps
Y
ou
T
yp
e
Lists
When
y
ou
t
yp
e
a
Lisp
expression
in
GNU
Ema s
using
either
Lisp
In
tera -
tion
mo
de
or
Ema s
Lisp
mo
de,
y
ou
ha
v
e
a
v
ailable
to
y
ou
sev
eral
 ommands
to
format
the
Lisp
expression
so
it
is
easy
to
read.
F
or
example,
pressing
the
h
T
AB
i
k
ey
automati ally
inden
ts
the
line
the
 ursor
is
on
b
y
the
righ
t
amoun
t.
A
 ommand
to
prop
erly
inden
t
the
 o
de
in
a
region
is
 ustomarily
b
ound
to
M-C-\.
Inden
tation
is
designed
so
that
y
ou
 an
see
whi 
h
elemen
ts
of
a
list
b
elongs
to
whi 
h
list|elemen
ts
of
a
sub-list
are
inden
ted
more
than
the
elemen
ts
of
the
en losing
list.
In
addition,
when
y
ou
t
yp
e
a
 losing
paren
thesis,
Ema s
momen
tarily
jumps
the
 ursor
ba 
k
to
the
mat 
hing
op
ening
paren
thesis,
so
y
ou
 an
see
whi 
h
one
it
is.
This
is
v
ery
useful,
sin e
ev
ery
list
y
ou
t
yp
e
in
Lisp
m
ust
ha
v
e

4
Chapter
1:
List
Pro
 essing
its
 losing
paren
thesis
mat 
h
its
op
ening
paren
thesis.
(See
se tion
\Ma
jor
Mo
des"
in
The
GNU
Ema s
Man
ual
,
for
more
information
ab
out
Ema s'
mo
des.)
1.2
Run
a
Program
A
list
in
Lisp|an
y
list|is
a
program
ready
to
run.
If
y
ou
run
it
(for
whi 
h
the
Lisp
jargon
is
ev
aluate
),
the
 omputer
will
do
one
of
three
things:
do
nothing
ex ept
return
to
y
ou
the
list
itself;
send
y
ou
an
error
message;
or,
treat
the
rst
sym
b
ol
in
the
list
as
a
 ommand
to
do
something.
(Usually
,
of
 ourse,
it
is
the
last
of
these
three
things
that
y
ou
really
w
an
t!)
The
single
ap
ostrophe,
',
that
I
put
in
fron
t
of
some
of
the
example
lists
in
pre eding
se tions
is
 alled
a
quote
;
when
it
pre edes
a
list,
it
tells
Lisp
to
do
nothing
with
the
list,
other
than
tak
e
it
as
it
is
written.
But
if
there
is
no
quote
pre eding
a
list,
the
rst
item
of
the
list
is
sp
e ial:
it
is
a
 ommand
for
the
 omputer
to
ob
ey
.
(In
Lisp,
these
 ommands
are
 alled
fun tions.)
The
list
(+
2
2)
sho
wn
ab
o
v
e
did
not
ha
v
e
a
quote
in
fron
t
of
it,
so
Lisp
understands
that
the
+
is
an
instru tion
to
do
something
with
the
rest
of
the
list:
add
the
n
um
b
ers
that
follo
w.
If
y
ou
are
reading
this
inside
of
GNU
Ema s
in
Info,
here
is
ho
w
y
ou
 an
ev
aluate
su 
h
a
list:
pla e
y
our
 ursor
immediately
after
the
righ
t
hand
paren
thesis
of
the
follo
wing
list
and
then
t
yp
e
C-x
C-e:
(+
2
2)
Y
ou
will
see
the
n
um
b
er
4
app
ear
in
the
e 
ho
area.
(In
the
jargon,
what
y
ou
ha
v
e
just
done
is
\ev
aluate
the
list."
The
e 
ho
area
is
the
line
at
the
b
ottom
of
the
s reen
that
displa
ys
or
\e 
ho
es"
text.)
No
w
try
the
same
thing
with
a
quoted
list:
pla e
the
 ursor
righ
t
after
the
follo
wing
list
and
t
yp
e
C-x
C-e:
'(this
is
a
quoted
list)
Y
ou
will
see
(this
is
a
quoted
list)
app
ear
in
the
e 
ho
area.
In
b
oth
 ases,
what
y
ou
are
doing
is
giving
a
 ommand
to
the
program
inside
of
GNU
Ema s
 alled
the
Lisp
in
terpreter|giving
the
in
terpreter
a
 ommand
to
ev
aluate
the
expression.
The
name
of
the
Lisp
in
terpreter
 omes
from
the
w
ord
for
the
task
done
b
y
a
h
uman
who
 omes
up
with
the
meaning
of
an
expression|who
\in
terprets"
it.
Y
ou
 an
also
ev
aluate
an
atom
that
is
not
part
of
a
list|one
that
is
not
surrounded
b
y
paren
theses;
again,
the
Lisp
in
terpreter
translates
from
the
h
umanly
readable
expression
to
the
language
of
the
 omputer.
But
b
efore
dis ussing
this
(see
Se tion
1.7,
\V
ariables",
page
10),
w
e
will
dis uss
what
the
Lisp
in
terpreter
do
es
when
y
ou
mak
e
an
error.
1.3
Generate
an
Error
Message
P
artly
so
y
ou
w
on't
w
orry
if
y
ou
do
it
a  iden
tally
,
w
e
will
no
w
giv
e
a
 ommand
to
the
Lisp
in
terpreter
that
generates
an
error
message.
This
is
a

Generate
an
Error
Message
5
harmless
a tivit
y;
and
indeed,
w
e
will
often
try
to
generate
error
messages
in
ten
tionally
.
On e
y
ou
understand
the
jargon,
error
messages
 an
b
e
in-
formativ
e.
Instead
of
b
eing
 alled
\error"
messages,
they
should
b
e
 alled
\help"
messages.
They
are
lik
e
signp
osts
to
a
tra
v
eller
in
a
strange
 oun
try;
de iphering
them
 an
b
e
hard,
but
on e
understo
o
d,
they
 an
p
oin
t
the
w
a
y
.
The
error
message
is
generated
b
y
a
built-in
GNU
Ema s
debugger.
W
e
will
`en
ter
the
debugger'.
Y
ou
get
out
of
the
debugger
b
y
t
yping
q.
What
w
e
will
do
is
ev
aluate
a
list
that
is
not
quoted
and
do
es
not
ha
v
e
a
meaningful
 ommand
as
its
rst
elemen
t.
Here
is
a
list
almost
exa tly
the
same
as
the
one
w
e
just
used,
but
without
the
single-quote
in
fron
t
of
it.
P
osition
the
 ursor
righ
t
after
it
and
t
yp
e
C-x
C-e:
(this
is
an
unquoted
list)
What
y
ou
see
dep
ends
on
whi 
h
v
ersion
of
Ema s
y
ou
are
running.
GNU
Ema s
v
ersion
21
pro
vides
more
information
than
v
ersion
20
and
b
efore.
First,
the
more
re en
t
result
of
generating
an
error;
then
the
earlier,
v
ersion
20
result.
In
GNU
Ema s
v
ersion
21,
a
`*Ba ktra e*'
windo
w
will
op
en
up
and
y
ou
will
see
the
follo
wing
in
it:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(void-fun tion
this)
(this
is
an
unquoted
list)
eval((this
is
an
unquoted
list))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
Y
our
 ursor
will
b
e
in
this
windo
w
(y
ou
ma
y
ha
v
e
to
w
ait
a
few
se onds
b
efore
it
b
e omes
visible).
T
o
quit
the
debugger
and
mak
e
the
debugger
windo
w
go
a
w
a
y
,
t
yp
e:
q
Please
t
yp
e
q
righ
t
no
w,
so
y
ou
b
e ome
 onden
t
that
y
ou
 an
get
out
of
the
debugger.
Then,
t
yp
e
C-x
C-e
again
to
re-en
ter
it.
Based
on
what
w
e
already
kno
w,
w
e
 an
almost
read
this
error
message.
Y
ou
read
the
`*Ba ktra e*'
buer
from
the
b
ottom
up;
it
tells
y
ou
what
Ema s
did.
When
y
ou
t
yp
ed
C-x
C-e,
y
ou
made
an
in
tera tiv
e
 all
to
the
 ommand
eval-last-sexp.
eval
is
an
abbreviation
for
`ev
aluate'
and
sexp
is
an
abbreviation
for
`sym
b
oli 
expression'.
The
 ommand
means
`ev
aluate
last
sym
b
oli 
expression',
whi 
h
is
the
expression
just
b
efore
y
our
 ursor.
Ea 
h
line
ab
o
v
e
tells
y
ou
what
the
Lisp
in
terpreter
ev
aluated
next.
The
most
re en
t
a tion
is
at
the
top.
The
buer
is
 alled
the
`*Ba ktra e*'
buer
b
e ause
it
enables
y
ou
to
tra 
k
Ema s
ba 
kw
ards.

6
Chapter
1:
List
Pro
 essing
A
t
the
top
of
the
`*Ba ktra e*'
buer,
y
ou
see
the
line:
Debugger
entered--Lisp
error:
(void-fun tion
this)
The
Lisp
in
terpreter
tried
to
ev
aluate
the
rst
atom
of
the
list,
the
w
ord
`this'.
It
is
this
a tion
that
generated
the
error
message
`void-fun tion
this'.
The
message
 on
tains
the
w
ords
`void-fun tion'
and
`this'.
The
w
ord
`fun tion'
w
as
men
tioned
on e
b
efore.
It
is
a
v
ery
imp
ortan
t
w
ord.
F
or
our
purp
oses,
w
e
 an
dene
it
b
y
sa
ying
that
a
fun tion
is
a
set
of
instru tions
to
the
 omputer
that
tell
the
 omputer
to
do
something.
No
w
w
e
 an
b
egin
to
understand
the
error
message:
`void-fun tion
this'.
The
fun tion
(that
is,
the
w
ord
`this')
do
es
not
ha
v
e
a
denition
of
an
y
set
of
instru tions
for
the
 omputer
to
 arry
out.
The
sligh
tly
o
dd
w
ord,
`void-fun tion',
is
designed
to
 o
v
er
the
w
a
y
Ema s
Lisp
is
implemen
ted,
whi 
h
is
that
when
a
sym
b
ol
do
es
not
ha
v
e
a
fun tion
denition
atta 
hed
to
it,
the
pla e
that
should
 on
tain
the
instru -
tions
is
`v
oid'.
On
the
other
hand,
sin e
w
e
w
ere
able
to
add
2
plus
2
su  essfully
,
b
y
ev
aluating
(+
2
2),
w
e
 an
infer
that
the
sym
b
ol
+
m
ust
ha
v
e
a
set
of
in-
stru tions
for
the
 omputer
to
ob
ey
and
those
instru tions
m
ust
b
e
to
add
the
n
um
b
ers
that
follo
w
the
+.
In
GNU
Ema s
v
ersion
20,
and
in
earlier
v
ersions,
y
ou
will
see
only
one
line
of
error
message;
it
will
app
ear
in
the
e 
ho
area
and
lo
ok
lik
e
this:
Symbol's
fun tion
definition
is
void:
this
(Also,
y
our
terminal
ma
y
b
eep
at
y
ou|some
do,
some
don't;
and
others
blink.
This
is
just
a
devi e
to
get
y
our
atten
tion.)
The
message
go
es
a
w
a
y
as
so
on
as
y
ou
t
yp
e
another
k
ey
,
ev
en
just
to
mo
v
e
the
 ursor.
W
e
kno
w
the
meaning
of
the
w
ord
`Symbol'.
It
refers
to
the
rst
atom
of
the
list,
the
w
ord
`this'.
The
w
ord
`fun tion'
refers
to
the
instru tions
that
tell
the
 omputer
what
to
do.
(T
e 
hni ally
,
the
sym
b
ol
tells
the
 omputer
where
to
nd
the
instru tions,
but
this
is
a
 ompli ation
w
e
 an
ignore
for
the
momen
t.)
The
error
message
 an
b
e
understo
o
d:
`Symbol's
fun tion
definition
is
void:
this'.
The
sym
b
ol
(that
is,
the
w
ord
`this')
la 
ks
instru tions
for
the
 omputer
to
 arry
out.
1.4
Sym
b
ol
Names
and
F
un tion
Denitions
W
e
 an
arti ulate
another
 
hara teristi 
of
Lisp
based
on
what
w
e
ha
v
e
dis ussed
so
far|an
imp
ortan
t
 
hara teristi :
a
sym
b
ol,
lik
e
+,
is
not
itself
the
set
of
instru tions
for
the
 omputer
to
 arry
out.
Instead,
the
sym
b
ol
is
used,
p
erhaps
temp
orarily
,
as
a
w
a
y
of
lo
 ating
the
denition
or
set
of
instru tions.
What
w
e
see
is
the
name
through
whi 
h
the
instru tions
 an
b
e
found.
Names
of
p
eople
w
ork
the
same
w
a
y
.
I
 an
b
e
referred
to
as

The
Lisp
In
terpreter
7
`Bob';
ho
w
ev
er,
I
am
not
the
letters
`B',
`o',
`b'
but
am
the
 ons iousness
 onsisten
tly
asso
 iated
with
a
parti ular
life-form.
The
name
is
not
me,
but
it
 an
b
e
used
to
refer
to
me.
In
Lisp,
one
set
of
instru tions
 an
b
e
atta 
hed
to
sev
eral
names.
F
or
example,
the
 omputer
instru tions
for
adding
n
um
b
ers
 an
b
e
link
ed
to
the
sym
b
ol
plus
as
w
ell
as
to
the
sym
b
ol
+
(and
are
in
some
diale ts
of
Lisp).
Among
h
umans,
I
 an
b
e
referred
to
as
`Robert'
as
w
ell
as
`Bob'
and
b
y
other
w
ords
as
w
ell.
On
the
other
hand,
a
sym
b
ol
 an
ha
v
e
only
one
fun tion
denition
at-
ta 
hed
to
it
at
a
time.
Otherwise,
the
 omputer
w
ould
b
e
 onfused
as
to
whi 
h
denition
to
use.
If
this
w
ere
the
 ase
among
p
eople,
only
one
p
erson
in
the
w
orld
 ould
b
e
named
`Bob'.
Ho
w
ev
er,
the
fun tion
denition
to
whi 
h
the
name
refers
 an
b
e
 
hanged
readily
.
(See
Se tion
3.2,
\Install
a
F
un tion
Denition",
page
31.)
Sin e
Ema s
Lisp
is
large,
it
is
 ustomary
to
name
sym
b
ols
in
a
w
a
y
that
iden
ties
the
part
of
Ema s
to
whi 
h
the
fun tion
b
elongs.
Th
us,
all
the
names
for
fun tions
that
deal
with
T
exinfo
start
with
`texinfo-'
and
those
for
fun tions
that
deal
with
reading
mail
start
with
`rmail-'.
1.5
The
Lisp
In
terpreter
Based
on
what
w
e
ha
v
e
seen,
w
e
 an
no
w
start
to
gure
out
what
the
Lisp
in
terpreter
do
es
when
w
e
 ommand
it
to
ev
aluate
a
list.
First,
it
lo
oks
to
see
whether
there
is
a
quote
b
efore
the
list;
if
there
is,
the
in
terpreter
just
giv
es
us
the
list.
On
the
other
hand,
if
there
is
no
quote,
the
in
terpreter
lo
oks
at
the
rst
elemen
t
in
the
list
and
sees
whether
it
has
a
fun tion
denition.
If
it
do
es,
the
in
terpreter
 arries
out
the
instru tions
in
the
fun tion
denition.
Otherwise,
the
in
terpreter
prin
ts
an
error
message.
This
is
ho
w
Lisp
w
orks.
Simple.
There
are
added
 ompli ations
whi 
h
w
e
will
get
to
in
a
min
ute,
but
these
are
the
fundamen
tals.
Of
 ourse,
to
write
Lisp
programs,
y
ou
need
to
kno
w
ho
w
to
write
fun tion
denitions
and
atta 
h
them
to
names,
and
ho
w
to
do
this
without
 onfusing
either
y
ourself
or
the
 omputer.
No
w,
for
the
rst
 ompli ation.
In
addition
to
lists,
the
Lisp
in
terpreter
 an
ev
aluate
a
sym
b
ol
that
is
not
quoted
and
do
es
not
ha
v
e
paren
theses
around
it.
The
Lisp
in
terpreter
will
attempt
to
determine
the
sym
b
ol's
v
alue
as
a
v
ariable.
This
situation
is
des rib
ed
in
the
se tion
on
v
ariables.
(See
Se tion
1.7,
\V
ariables",
page
10.)
The
se ond
 ompli ation
o
  urs
b
e ause
some
fun tions
are
un
usual
and
do
not
w
ork
in
the
usual
manner.
Those
that
don't
are
 alled
sp
e ial
forms.
They
are
used
for
sp
e ial
jobs,
lik
e
dening
a
fun tion,
and
there
are
not
man
y
of
them.
In
the
next
few
 
hapters,
y
ou
will
b
e
in
tro
du ed
to
sev
eral
of
the
more
imp
ortan
t
sp
e ial
forms.

8
Chapter
1:
List
Pro
 essing
The
third
and
nal
 ompli ation
is
this:
if
the
fun tion
that
the
Lisp
in
terpreter
is
lo
oking
at
is
not
a
sp
e ial
form,
and
if
it
is
part
of
a
list,
the
Lisp
in
terpreter
lo
oks
to
see
whether
the
list
has
a
list
inside
of
it.
If
there
is
an
inner
list,
the
Lisp
in
terpreter
rst
gures
out
what
it
should
do
with
the
inside
list,
and
then
it
w
orks
on
the
outside
list.
If
there
is
y
et
another
list
em
b
edded
inside
the
inner
list,
it
w
orks
on
that
one
rst,
and
so
on.
It
alw
a
ys
w
orks
on
the
innermost
list
rst.
The
in
terpreter
w
orks
on
the
innermost
list
rst,
to
ev
aluate
the
result
of
that
list.
The
result
ma
y
b
e
used
b
y
the
en losing
expression.
Otherwise,
the
in
terpreter
w
orks
left
to
righ
t,
from
one
expression
to
the
next.
1.5.1
Byte
Compiling
One
other
asp
e t
of
in
terpreting:
the
Lisp
in
terpreter
is
able
to
in
terpret
t
w
o
kinds
of
en
tit
y:
h
umanly
readable
 o
de,
on
whi 
h
w
e
will
fo
 us
ex lu-
siv
ely
,
and
sp
e ially
pro
 essed
 o
de,
 alled
b
yte
 ompiled
 o
de,
whi 
h
is
not
h
umanly
readable.
Byte
 ompiled
 o
de
runs
faster
than
h
umanly
readable
 o
de.
Y
ou
 an
transform
h
umanly
readable
 o
de
in
to
b
yte
 ompiled
 o
de
b
y
running
one
of
the
 ompile
 ommands
su 
h
as
byte- ompile-file.
Byte
 ompiled
 o
de
is
usually
stored
in
a
le
that
ends
with
a
`.el '
exten-
sion
rather
than
a
`.el'
extension.
Y
ou
will
see
b
oth
kinds
of
le
in
the
`ema s/lisp'
dire tory;
the
les
to
read
are
those
with
`.el'
extensions.
As
a
pra ti al
matter,
for
most
things
y
ou
migh
t
do
to
 ustomize
or
extend
Ema s,
y
ou
do
not
need
to
b
yte
 ompile;
and
I
will
not
dis uss
the
topi 
here.
See
se tion
\Byte
Compilation"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
a
full
des ription
of
b
yte
 ompilation.
1.6
Ev
aluation
When
the
Lisp
in
terpreter
w
orks
on
an
expression,
the
term
for
the
a -
tivit
y
is
 alled
ev
aluation.
W
e
sa
y
that
the
in
terpreter
`ev
aluates
the
expres-
sion'.
I'v
e
used
this
term
sev
eral
times
b
efore.
The
w
ord
 omes
from
its
use
in
ev
eryda
y
language,
`to
as ertain
the
v
alue
or
amoun
t
of;
to
appraise',
a  ording
to
W
ebster's
New
Collegiate
Di tionary.
After
ev
aluating
an
expression,
the
Lisp
in
terpreter
will
most
lik
ely
return
the
v
alue
that
the
 omputer
pro
du es
b
y
 arrying
out
the
instru tions
it
found
in
the
fun tion
denition,
or
p
erhaps
it
will
giv
e
up
on
that
fun tion
and
pro
du e
an
error
message.
(The
in
terpreter
ma
y
also
nd
itself
tossed,
so
to
sp
eak,
to
a
dieren
t
fun tion
or
it
ma
y
attempt
to
rep
eat
 on
tin
ually
what
it
is
doing
for
ev
er
and
ev
er
in
what
is
 alled
an
`innite
lo
op'.
These
a tions
are
less
 ommon;
and
w
e
 an
ignore
them.)
Most
frequen
tly
,
the
in
terpreter
returns
a
v
alue.

Ev
aluating
Inner
Lists
9
A
t
the
same
time
the
in
terpreter
returns
a
v
alue,
it
ma
y
do
something
else
as
w
ell,
su 
h
as
mo
v
e
a
 ursor
or
 op
y
a
le;
this
other
kind
of
a tion
is
 alled
a
side
ee t.
A tions
that
w
e
h
umans
think
are
imp
ortan
t,
su 
h
as
prin
ting
results,
are
often
\side
ee ts"
to
the
Lisp
in
terpreter.
The
jargon
 an
sound
p
e uliar,
but
it
turns
out
that
it
is
fairly
easy
to
learn
to
use
side
ee ts.
In
summary
,
ev
aluating
a
sym
b
oli 
expression
most
 ommonly
 auses
the
Lisp
in
terpreter
to
return
a
v
alue
and
p
erhaps
 arry
out
a
side
ee t;
or
else
pro
du e
an
error.
1.6.1
Ev
aluating
Inner
Lists
If
ev
aluation
applies
to
a
list
that
is
inside
another
list,
the
outer
list
ma
y
use
the
v
alue
returned
b
y
the
rst
ev
aluation
as
information
when
the
outer
list
is
ev
aluated.
This
explains
wh
y
inner
expressions
are
ev
aluated
rst:
the
v
alues
they
return
are
used
b
y
the
outer
expressions.
W
e
 an
in
v
estigate
this
pro
 ess
b
y
ev
aluating
another
addition
example.
Pla e
y
our
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e:
(+
2
(+
3
3))
The
n
um
b
er
8
will
app
ear
in
the
e 
ho
area.
What
happ
ens
is
that
the
Lisp
in
terpreter
rst
ev
aluates
the
inner
ex-
pression,
(+
3
3),
for
whi 
h
the
v
alue
6
is
returned;
then
it
ev
aluates
the
outer
expression
as
if
it
w
ere
written
(+
2
6),
whi 
h
returns
the
v
alue
8.
Sin e
there
are
no
more
en losing
expressions
to
ev
aluate,
the
in
terpreter
prin
ts
that
v
alue
in
the
e 
ho
area.
No
w
it
is
easy
to
understand
the
name
of
the
 ommand
in
v
ok
ed
b
y
the
k
eystrok
es
C-x
C-e:
the
name
is
eval-last-sexp.
The
letters
sexp
are
an
abbreviation
for
`sym
b
oli 
expression',
and
eval
is
an
abbreviation
for
`ev
aluate'.
The
 ommand
means
`ev
aluate
last
sym
b
oli 
expression'.
As
an
exp
erimen
t,
y
ou
 an
try
ev
aluating
the
expression
b
y
putting
the
 ursor
at
the
b
eginning
of
the
next
line
immediately
follo
wing
the
expression,
or
inside
the
expression.
Here
is
another
 op
y
of
the
expression:
(+
2
(+
3
3))
If
y
ou
pla e
the
 ursor
at
the
b
eginning
of
the
blank
line
that
immediately
follo
ws
the
expression
and
t
yp
e
C-x
C-e,
y
ou
will
still
get
the
v
alue
8
prin
ted
in
the
e 
ho
area.
No
w
try
putting
the
 ursor
inside
the
expression.
If
y
ou
put
it
righ
t
after
the
next
to
last
paren
thesis
(so
it
app
ears
to
sit
on
top
of
the
last
paren
thesis),
y
ou
will
get
a
6
prin
ted
in
the
e 
ho
area!
This
is
b
e ause
the
 ommand
ev
aluates
the
expression
(+
3
3).
No
w
put
the
 ursor
immediately
after
a
n
um
b
er.
T
yp
e
C-x
C-e
and
y
ou
will
get
the
n
um
b
er
itself.
In
Lisp,
if
y
ou
ev
aluate
a
n
um
b
er,
y
ou
get
the
n
um
b
er
itself|this
is
ho
w
n
um
b
ers
dier
from
sym
b
ols.
If
y
ou
ev
aluate
a
list
starting
with
a
sym
b
ol
lik
e
+,
y
ou
will
get
a
v
alue
returned
that
is
the

10
Chapter
1:
List
Pro
 essing
result
of
the
 omputer
 arrying
out
the
instru tions
in
the
fun tion
denition
atta 
hed
to
that
name.
If
a
sym
b
ol
b
y
itself
is
ev
aluated,
something
dieren
t
happ
ens,
as
w
e
will
see
in
the
next
se tion.
1.7
V
ariables
In
Ema s
Lisp,
a
sym
b
ol
 an
ha
v
e
a
v
alue
atta 
hed
to
it
just
as
it
 an
ha
v
e
a
fun tion
denition
atta 
hed
to
it.
The
t
w
o
are
dieren
t.
The
fun tion
denition
is
a
set
of
instru tions
that
a
 omputer
will
ob
ey
.
A
v
alue,
on
the
other
hand,
is
something,
su 
h
as
n
um
b
er
or
a
name,
that
 an
v
ary
(whi 
h
is
wh
y
su 
h
a
sym
b
ol
is
 alled
a
v
ariable).
The
v
alue
of
a
sym
b
ol
 an
b
e
an
y
expression
in
Lisp,
su 
h
as
a
sym
b
ol,
n
um
b
er,
list,
or
string.
A
sym
b
ol
that
has
a
v
alue
is
often
 alled
a
v
ariable.
A
sym
b
ol
 an
ha
v
e
b
oth
a
fun tion
denition
and
a
v
alue
atta 
hed
to
it
at
the
same
time.
Or
it
 an
ha
v
e
just
one
or
the
other.
The
t
w
o
are
separate.
This
is
somewhat
similar
to
the
w
a
y
the
name
Cam
bridge
 an
refer
to
the
 it
y
in
Massa 
h
usetts
and
ha
v
e
some
information
atta 
hed
to
the
name
as
w
ell,
su 
h
as
\great
programming
 en
ter".
Another
w
a
y
to
think
ab
out
this
is
to
imagine
a
sym
b
ol
as
b
eing
a
 
hest
of
dra
w
ers.
The
fun tion
denition
is
put
in
one
dra
w
er,
the
v
alue
in
another,
and
so
on.
What
is
put
in
the
dra
w
er
holding
the
v
alue
 an
b
e
 
hanged
without
ae ting
the
 on
ten
ts
of
the
dra
w
er
holding
the
fun tion
denition,
and
vi e-v
ersa.
The
v
ariable
fill- olumn
illustrates
a
sym
b
ol
with
a
v
alue
atta 
hed
to
it:
in
ev
ery
GNU
Ema s
buer,
this
sym
b
ol
is
set
to
some
v
alue,
usually
72
or
70,
but
sometimes
to
some
other
v
alue.
T
o
nd
the
v
alue
of
this
sym
b
ol,
ev
aluate
it
b
y
itself.
If
y
ou
are
reading
this
in
Info
inside
of
GNU
Ema s,
y
ou
 an
do
this
b
y
putting
the
 ursor
after
the
sym
b
ol
and
t
yping
C-x
C-e:
fill- olumn
After
I
t
yp
ed
C-x
C-e,
Ema s
prin
ted
the
n
um
b
er
72
in
m
y
e 
ho
area.
This
is
the
v
alue
for
whi 
h
fill- olumn
is
set
for
me
as
I
write
this.
It
ma
y
b
e
dieren
t
for
y
ou
in
y
our
Info
buer.
Noti e
that
the
v
alue
returned
as
a
v
ariable
is
prin
ted
in
exa tly
the
same
w
a
y
as
the
v
alue
returned
b
y
a
fun tion
 arrying
out
its
instru tions.
F
rom
the
p
oin
t
of
view
of
the
Lisp
in
terpreter,
a
v
alue
returned
is
a
v
alue
returned.
What
kind
of
expression
it
 ame
from
 eases
to
matter
on e
the
v
alue
is
kno
wn.
A
sym
b
ol
 an
ha
v
e
an
y
v
alue
atta 
hed
to
it
or,
to
use
the
jargon,
w
e
 an
bind
the
v
ariable
to
a
v
alue:
to
a
n
um
b
er,
su 
h
as
72;
to
a
string,
"su h
as
this";
to
a
list,
su 
h
as
(spru e
pine
oak);
w
e
 an
ev
en
bind
a
v
ariable
to
a
fun tion
denition.
A
sym
b
ol
 an
b
e
b
ound
to
a
v
alue
in
sev
eral
w
a
ys.
See
Se tion
1.9,
\Setting
the
V
alue
of
a
V
ariable",
page
17,
for
information
ab
out
one
w
a
y
to
do
this.

Error
Message
for
a
Sym
b
ol
Without
a
V
alue
11
1.7.1
Error
Message
for
a
Sym
b
ol
Without
a
F
un tion
When
w
e
ev
aluated
fill- olumn
to
nd
its
v
alue
as
a
v
ariable,
w
e
did
not
pla e
paren
theses
around
the
w
ord.
This
is
b
e ause
w
e
did
not
in
tend
to
use
it
as
a
fun tion
name.
If
fill- olumn
w
ere
the
rst
or
only
elemen
t
of
a
list,
the
Lisp
in
terpreter
w
ould
attempt
to
nd
the
fun tion
denition
atta 
hed
to
it.
But
fill-
 olumn
has
no
fun tion
denition.
T
ry
ev
aluating
this:
(fill- olumn)
In
GNU
Ema s
v
ersion
21,
y
ou
will
 reate
a
`*Ba ktra e*'
buer
that
sa
ys:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(void-fun tion
fill- olumn)
(fill- olumn)
eval((fill- olumn))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
(Remem
b
er,
to
quit
the
debugger
and
mak
e
the
debugger
windo
w
go
a
w
a
y
,
t
yp
e
q
in
the
`*Ba ktra e*'
buer.)
In
GNU
Ema s
20
and
b
efore,
y
ou
will
pro
du e
an
error
message
that
sa
ys:
Symbol's
fun tion
definition
is
void:
fill- olumn
(The
message
will
go
a
w
a
y
a
w
a
y
as
so
on
as
y
ou
mo
v
e
the
 ursor
or
t
yp
e
another
k
ey
.)
1.7.2
Error
Message
for
a
Sym
b
ol
Without
a
V
alue
If
y
ou
attempt
to
ev
aluate
a
sym
b
ol
that
do
es
not
ha
v
e
a
v
alue
b
ound
to
it,
y
ou
will
re eiv
e
an
error
message.
Y
ou
 an
see
this
b
y
exp
erimen
ting
with
our
2
plus
2
addition.
In
the
follo
wing
expression,
put
y
our
 ursor
righ
t
after
the
+,
b
efore
the
rst
n
um
b
er
2,
t
yp
e
C-x
C-e:
(+
2
2)
In
GNU
Ema s
21,
y
ou
will
 reate
a
`*Ba ktra e*'
buer
that
sa
ys:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(void-variable
+)
eval(+)
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
(As
with
the
other
times
w
e
en
tered
the
debugger,
y
ou
 an
quit
b
y
t
yping
q
in
the
`*Ba ktra e*'
buer.)

12
Chapter
1:
List
Pro
 essing
This
ba 
ktra e
is
dieren
t
from
the
v
ery
rst
error
message
w
e
sa
w,
whi 
h
said,
`Debugger
entered--Lisp
error:
(void-fun tion
this)'.
In
this
 ase,
the
fun tion
do
es
not
ha
v
e
a
v
alue
as
a
v
ariable;
while
in
the
other
error
message,
the
fun tion
(the
w
ord
`this')
did
not
ha
v
e
a
denition.
In
this
exp
erimen
t
with
the
+,
what
w
e
did
w
as
 ause
the
Lisp
in
terpreter
to
ev
aluate
the
+
and
lo
ok
for
the
v
alue
of
the
v
ariable
instead
of
the
fun tion
denition.
W
e
did
this
b
y
pla ing
the
 ursor
righ
t
after
the
sym
b
ol
rather
than
after
the
paren
thesis
of
the
en losing
list
as
w
e
did
b
efore.
As
a
 onse-
quen e,
the
Lisp
in
terpreter
ev
aluated
the
pre eding
s-expression,
whi 
h
in
this
 ase
w
as
the
+
b
y
itself.
Sin e
+
do
es
not
ha
v
e
a
v
alue
b
ound
to
it,
just
the
fun tion
denition,
the
error
message
rep
orted
that
the
sym
b
ol's
v
alue
as
a
v
ariable
w
as
v
oid.
In
GNU
Ema s
v
ersion
20
and
b
efore,
y
our
error
message
will
sa
y:
Symbol's
value
as
variable
is
void:
+
The
meaning
is
the
same
as
in
GNU
Ema s
21.
1.8
Argumen
ts
T
o
see
ho
w
information
is
passed
to
fun tions,
let's
lo
ok
again
at
our
old
standb
y
,
the
addition
of
t
w
o
plus
t
w
o.
In
Lisp,
this
is
written
as
follo
ws:
(+
2
2)
If
y
ou
ev
aluate
this
expression,
the
n
um
b
er
4
will
app
ear
in
y
our
e 
ho
area.
What
the
Lisp
in
terpreter
do
es
is
add
the
n
um
b
ers
that
follo
w
the
+.
The
n
um
b
ers
added
b
y
+
are
 alled
the
argumen
ts
of
the
fun tion
+.
These
n
um
b
ers
are
the
information
that
is
giv
en
to
or
passed
to
the
fun tion.
The
w
ord
`argumen
t'
 omes
from
the
w
a
y
it
is
used
in
mathemati s
and
do
es
not
refer
to
a
disputation
b
et
w
een
t
w
o
p
eople;
instead
it
refers
to
the
information
presen
ted
to
the
fun tion,
in
this
 ase,
to
the
+.
In
Lisp,
the
argumen
ts
to
a
fun tion
are
the
atoms
or
lists
that
follo
w
the
fun tion.
The
v
alues
returned
b
y
the
ev
aluation
of
these
atoms
or
lists
are
passed
to
the
fun tion.
Dieren
t
fun tions
require
dieren
t
n
um
b
ers
of
argumen
ts;
some
fun tions
require
none
at
all.
1
1
It
is
 urious
to
tra 
k
the
path
b
y
whi 
h
the
w
ord
`argumen
t'
 ame
to
ha
v
e
t
w
o
dier-
en
t
meanings,
one
in
mathemati s
and
the
other
in
ev
eryda
y
English.
A  ording
to
the
Oxford
English
Di tionary,
the
w
ord
deriv
es
from
the
Latin
for
`to
make
 lear,
prove';
th
us
it
 ame
to
mean,
b
y
one
thread
of
deriv
ation,
`the
eviden e
oered
as
pro
of
',
whi 
h
is
to
sa
y
,
`the
information
oered',
whi 
h
led
to
its
meaning
in
Lisp.
But
in
the
other
thread
of
deriv
ation,
it
 ame
to
mean
`to
assert
in
a
manner
against
whi 
h
others
ma
y
mak
e
 oun
ter
assertions',
whi 
h
led
to
the
meaning
of
the
w
ord
as
a
disputation.
(Note
here
that
the
English
w
ord
has
t
w
o
dieren
t
denitions
atta 
hed
to
it
at
the
same
time.
By
 on
trast,
in
Ema s
Lisp,
a
sym
b
ol
 annot
ha
v
e
t
w
o
dieren
t
fun tion
denitions
at
the
same
time.)

An
Argumen
t
as
the
V
alue
of
a
V
ariable
or
List
13
1.8.1
Argumen
ts'
Data
T
yp
es
The
t
yp
e
of
data
that
should
b
e
passed
to
a
fun tion
dep
ends
on
what
kind
of
information
it
uses.
The
argumen
ts
to
a
fun tion
su 
h
as
+
m
ust
ha
v
e
v
alues
that
are
n
um
b
ers,
sin e
+
adds
n
um
b
ers.
Other
fun tions
use
dieren
t
kinds
of
data
for
their
argumen
ts.
F
or
example,
the
 on at
fun tion
links
together
or
unites
t
w
o
or
more
strings
of
text
to
pro
du e
a
string.
The
argumen
ts
are
strings.
Con ate-
nating
the
t
w
o
 
hara ter
strings
ab ,
def
pro
du es
the
single
string
ab def.
This
 an
b
e
seen
b
y
ev
aluating
the
follo
wing:
( on at
"ab "
"def")
The
v
alue
pro
du ed
b
y
ev
aluating
this
expression
is
"ab def".
A
fun tion
su 
h
as
substring
uses
b
oth
a
string
and
n
um
b
ers
as
argu-
men
ts.
The
fun tion
returns
a
part
of
the
string,
a
substring
of
the
rst
argumen
t.
This
fun tion
tak
es
three
argumen
ts.
Its
rst
argumen
t
is
the
string
of
 
hara ters,
the
se ond
and
third
argumen
ts
are
n
um
b
ers
that
in-
di ate
the
b
eginning
and
end
of
the
substring.
The
n
um
b
ers
are
a
 oun
t
of
the
n
um
b
er
of
 
hara ters
(in luding
spa es
and
pun tuations)
from
the
b
eginning
of
the
string.
F
or
example,
if
y
ou
ev
aluate
the
follo
wing:
(substring
"The
qui k
brown
fox
jumped."
16
19)
y
ou
will
see
"fox"
app
ear
in
the
e 
ho
area.
The
argumen
ts
are
the
string
and
the
t
w
o
n
um
b
ers.
Note
that
the
string
passed
to
substring
is
a
single
atom
ev
en
though
it
is
made
up
of
sev
eral
w
ords
separated
b
y
spa es.
Lisp
 oun
ts
ev
erything
b
et
w
een
the
t
w
o
quotation
marks
as
part
of
the
string,
in luding
the
spa es.
Y
ou
 an
think
of
the
substring
fun tion
as
a
kind
of
`atom
smasher'
sin e
it
tak
es
an
otherwise
indivisible
atom
and
extra ts
a
part.
Ho
w
ev
er,
substring
is
only
able
to
extra t
a
substring
from
an
argumen
t
that
is
a
string,
not
from
another
t
yp
e
of
atom
su 
h
as
a
n
um
b
er
or
sym
b
ol.
1.8.2
An
Argumen
t
as
the
V
alue
of
a
V
ariable
or
List
An
argumen
t
 an
b
e
a
sym
b
ol
that
returns
a
v
alue
when
it
is
ev
aluated.
F
or
example,
when
the
sym
b
ol
fill- olumn
b
y
itself
is
ev
aluated,
it
returns
a
n
um
b
er.
This
n
um
b
er
 an
b
e
used
in
an
addition.
P
osition
the
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e:
(+
2
fill- olumn)
The
v
alue
will
b
e
a
n
um
b
er
t
w
o
more
than
what
y
ou
get
b
y
ev
aluating
fill- olumn
alone.
F
or
me,
this
is
74,
b
e ause
the
v
alue
of
fill- olumn
is
72.
As
w
e
ha
v
e
just
seen,
an
argumen
t
 an
b
e
a
sym
b
ol
that
returns
a
v
alue
when
ev
aluated.
In
addition,
an
argumen
t
 an
b
e
a
list
that
returns
a
v
alue
when
it
is
ev
aluated.
F
or
example,
in
the
follo
wing
expression,
the
argumen
ts

14
Chapter
1:
List
Pro
 essing
to
the
fun tion
 on at
are
the
strings
"The
"
and
"
red
foxes."
and
the
list
(number-to-string
(+
2
fill- olumn)).
( on at
"The
"
(number-to-string
(+
2
fill- olumn))
"
red
foxes.")
If
y
ou
ev
aluate
this
expression|and
if,
as
with
m
y
Ema s,
fill- olumn
ev
aluates
to
72|"The
74
red
foxes."
will
app
ear
in
the
e 
ho
area.
(Note
that
y
ou
m
ust
put
spa es
after
the
w
ord
`The'
and
b
efore
the
w
ord
`red'
so
they
will
app
ear
in
the
nal
string.
The
fun tion
number-to-string
 on
v
erts
the
in
teger
that
the
addition
fun tion
returns
to
a
string.
number-
to-string
is
also
kno
wn
as
int-to-string.)
1.8.3
V
ariable
Num
b
er
of
Argumen
ts
Some
fun tions,
su 
h
as
 on at,
+
or
*,
tak
e
an
y
n
um
b
er
of
argumen
ts.
(The
*
is
the
sym
b
ol
for
m
ultipli ation.)
This
 an
b
e
seen
b
y
ev
aluating
ea 
h
of
the
follo
wing
expressions
in
the
usual
w
a
y
.
What
y
ou
will
see
in
the
e 
ho
area
is
prin
ted
in
this
text
after
`
)
',
whi 
h
y
ou
ma
y
read
as
`ev
aluates
to'.
In
the
rst
set,
the
fun tions
ha
v
e
no
argumen
ts:
(+)
)
0
(*)
)
1
In
this
set,
the
fun tions
ha
v
e
one
argumen
t
ea 
h:
(+
3)
)
3
(*
3)
)
3
In
this
set,
the
fun tions
ha
v
e
three
argumen
ts
ea 
h:
(+
3
4
5)
)
12
(*
3
4
5)
)
60
1.8.4
Using
the
W
rong
T
yp
e
Ob
je t
as
an
Argumen
t
When
a
fun tion
is
passed
an
argumen
t
of
the
wrong
t
yp
e,
the
Lisp
in
terpreter
pro
du es
an
error
message.
F
or
example,
the
+
fun tion
exp
e ts
the
v
alues
of
its
argumen
ts
to
b
e
n
um
b
ers.
As
an
exp
erimen
t
w
e
 an
pass
it
the
quoted
sym
b
ol
hello
instead
of
a
n
um
b
er.
P
osition
the
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e:
(+
2
'hello)
When
y
ou
do
this
y
ou
will
generate
an
error
message.
What
has
happ
ened
is
that
+
has
tried
to
add
the
2
to
the
v
alue
returned
b
y
'hello,
but
the
v
alue
returned
b
y
'hello
is
the
sym
b
ol
hello,
not
a
n
um
b
er.
Only
n
um
b
ers
 an
b
e
added.
So
+
 ould
not
 arry
out
its
addition.

Using
the
W
rong
T
yp
e
Ob
je t
as
an
Argumen
t
15
In
GNU
Ema s
v
ersion
21,
y
ou
will
 reate
and
en
ter
a
`*Ba ktra e*'
buer
that
sa
ys:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(wrong-type-argument
number-or-marker-p
hello)
+(2
hello)
eval((+
2
(quote
hello)))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
As
usual,
the
error
message
tries
to
b
e
helpful
and
mak
es
sense
after
y
ou
learn
ho
w
to
read
it.
The
rst
part
of
the
error
message
is
straigh
tforw
ard;
it
sa
ys
`wrong
type
argument'.
Next
 omes
the
m
ysterious
jargon
w
ord
`number-or-marker-p'
.
This
w
ord
is
trying
to
tell
y
ou
what
kind
of
argumen
t
the
+
exp
e ted.
The
sym
b
ol
number-or-marker-p
sa
ys
that
the
Lisp
in
terpreter
is
try-
ing
to
determine
whether
the
information
presen
ted
it
(the
v
alue
of
the
argumen
t)
is
a
n
um
b
er
or
a
mark
er
(a
sp
e ial
ob
je t
represen
ting
a
buer
p
osition).
What
it
do
es
is
test
to
see
whether
the
+
is
b
eing
giv
en
n
um
b
ers
to
add.
It
also
tests
to
see
whether
the
argumen
t
is
something
 alled
a
mark
er,
whi 
h
is
a
sp
e i 
feature
of
Ema s
Lisp.
(In
Ema s,
lo
 ations
in
a
buer
are
re orded
as
mark
ers.
When
the
mark
is
set
with
the
C- 
or
C-
h
SPC
i
 ommand,
its
p
osition
is
k
ept
as
a
mark
er.
The
mark
 an
b
e
 onsidered
a
n
um
b
er|the
n
um
b
er
of
 
hara ters
the
lo
 ation
is
from
the
b
eginning
of
the
buer.)
In
Ema s
Lisp,
+
 an
b
e
used
to
add
the
n
umeri 
v
alue
of
mark
er
p
ositions
as
n
um
b
ers.
The
`p'
of
number-or-marker-p
is
the
em
b
o
dimen
t
of
a
pra ti e
started
in
the
early
da
ys
of
Lisp
programming.
The
`p'
stands
for
`predi ate'.
In
the
jargon
used
b
y
the
early
Lisp
resear 
hers,
a
predi ate
refers
to
a
fun tion
to
determine
whether
some
prop
ert
y
is
true
or
false.
So
the
`p'
tells
us
that
number-or-marker-p
is
the
name
of
a
fun tion
that
determines
whether
it
is
true
or
false
that
the
argumen
t
supplied
is
a
n
um
b
er
or
a
mark
er.
Other
Lisp
sym
b
ols
that
end
in
`p'
in lude
zerop,
a
fun tion
that
tests
whether
its
argumen
t
has
the
v
alue
of
zero,
and
listp,
a
fun tion
that
tests
whether
its
argumen
t
is
a
list.
Finally
,
the
last
part
of
the
error
message
is
the
sym
b
ol
hello.
This
is
the
v
alue
of
the
argumen
t
that
w
as
passed
to
+.
If
the
addition
had
b
een
passed
the
 orre t
t
yp
e
of
ob
je t,
the
v
alue
passed
w
ould
ha
v
e
b
een
a
n
um
b
er,
su 
h
as
37,
rather
than
a
sym
b
ol
lik
e
hello.
But
then
y
ou
w
ould
not
ha
v
e
got
the
error
message.

16
Chapter
1:
List
Pro
 essing
In
GNU
Ema s
v
ersion
20
and
b
efore,
the
e 
ho
area
displa
ys
an
error
message
that
sa
ys:
Wrong
type
argument:
number-or-marker-p,
hello
This
sa
ys,
in
dieren
t
w
ords,
the
same
as
the
top
line
of
the
`*Ba ktra e*'
buer.
1.8.5
The
message
F
un tion
Lik
e
+,
the
message
fun tion
tak
es
a
v
ariable
n
um
b
er
of
argumen
ts.
It
is
used
to
send
messages
to
the
user
and
is
so
useful
that
w
e
will
des rib
e
it
here.
A
message
is
prin
ted
in
the
e 
ho
area.
F
or
example,
y
ou
 an
prin
t
a
message
in
y
our
e 
ho
area
b
y
ev
aluating
the
follo
wing
list:
(message
"This
message
appears
in
the
e ho
area!")
The
whole
string
b
et
w
een
double
quotation
marks
is
a
single
argumen
t
and
is
prin
ted
in
toto.
(Note
that
in
this
example,
the
message
itself
will
ap-
p
ear
in
the
e 
ho
area
within
double
quotes;
that
is
b
e ause
y
ou
see
the
v
alue
returned
b
y
the
message
fun tion.
In
most
uses
of
message
in
programs
that
y
ou
write,
the
text
will
b
e
prin
ted
in
the
e 
ho
area
as
a
side-ee t,
without
the
quotes.
See
Se tion
3.3.1,
\multiply-by-seven
in
detail",
page
34,
for
an
example
of
this.)
Ho
w
ev
er,
if
there
is
a
`%s'
in
the
quoted
string
of
 
hara ters,
the
message
fun tion
do
es
not
prin
t
the
`%s'
as
su 
h,
but
lo
oks
to
the
argumen
t
that
follo
ws
the
string.
It
ev
aluates
the
se ond
argumen
t
and
prin
ts
the
v
alue
at
the
lo
 ation
in
the
string
where
the
`%s'
is.
Y
ou
 an
see
this
b
y
p
ositioning
the
 ursor
after
the
follo
wing
expression
and
t
yping
C-x
C-e:
(message
"The
name
of
this
buffer
is:
%s."
(buffer-name))
In
Info,
"The
name
of
this
buffer
is:
*info*."
will
app
ear
in
the
e 
ho
area.
The
fun tion
buffer-name
returns
the
name
of
the
buer
as
a
string,
whi 
h
the
message
fun tion
inserts
in
pla e
of
%s.
T
o
prin
t
a
v
alue
as
an
in
teger,
use
`%d'
in
the
same
w
a
y
as
`%s'.
F
or
example,
to
prin
t
a
message
in
the
e 
ho
area
that
states
the
v
alue
of
the
fill- olumn,
ev
aluate
the
follo
wing:
(message
"The
value
of
fill- olumn
is
%d."
fill- olumn)
On
m
y
system,
when
I
ev
aluate
this
list,
"The
value
of
fill- olumn
is
72."
app
ears
in
m
y
e 
ho
area
2
.
If
there
is
more
than
one
`%s'
in
the
quoted
string,
the
v
alue
of
the
rst
argumen
t
follo
wing
the
quoted
string
is
prin
ted
at
the
lo
 ation
of
the
rst
`%s'
and
the
v
alue
of
the
se ond
argumen
t
is
prin
ted
at
the
lo
 ation
of
the
se ond
`%s',
and
so
on.
2
A tually
,
y
ou
 an
use
%s
to
prin
t
a
n
um
b
er.
It
is
non-sp
e i .
%d
prin
ts
only
the
part
of
a
n
um
b
er
left
of
a
de imal
p
oin
t,
and
not
an
ything
that
is
not
a
n
um
b
er.

Using
set
17
F
or
example,
if
y
ou
ev
aluate
the
follo
wing,
(message
"There
are
%d
%s
in
the
offi e!"
(-
fill- olumn
14)
"pink
elephants")
a
rather
whimsi al
message
will
app
ear
in
y
our
e 
ho
area.
On
m
y
system
it
sa
ys,
"There
are
58
pink
elephants
in
the
offi e!".
The
expression
(-
fill- olumn
14)
is
ev
aluated
and
the
resulting
n
um-
b
er
is
inserted
in
pla e
of
the
`%d';
and
the
string
in
double
quotes,
"pink
elephants",
is
treated
as
a
single
argumen
t
and
inserted
in
pla e
of
the
`%s'.
(That
is
to
sa
y
,
a
string
b
et
w
een
double
quotes
ev
aluates
to
itself,
lik
e
a
n
um
b
er.)
Finally
,
here
is
a
somewhat
 omplex
example
that
not
only
illustrates
the
 omputation
of
a
n
um
b
er,
but
also
sho
ws
ho
w
y
ou
 an
use
an
expression
within
an
expression
to
generate
the
text
that
is
substituted
for
`%s':
(message
"He
saw
%d
%s"
(-
fill- olumn
34)
( on at
"red
"
(substring
"The
qui k
brown
foxes
jumped."
16
21)
"
leaping."))
In
this
example,
message
has
three
argumen
ts:
the
string,
"He
saw
%d
%s",
the
expression,
(-
fill- olumn
32),
and
the
expression
b
eginning
with
the
fun tion
 on at.
The
v
alue
resulting
from
the
ev
aluation
of
(-
fill-
 olumn
32)
is
inserted
in
pla e
of
the
`%d';
and
the
v
alue
returned
b
y
the
expression
b
eginning
with
 on at
is
inserted
in
pla e
of
the
`%s'.
When
I
ev
aluate
the
expression,
the
message
"He
saw
38
red
foxes
leaping."
app
ears
in
m
y
e 
ho
area.
1.9
Setting
the
V
alue
of
a
V
ariable
There
are
sev
eral
w
a
ys
b
y
whi 
h
a
v
ariable
 an
b
e
giv
en
a
v
alue.
One
of
the
w
a
ys
is
to
use
either
the
fun tion
set
or
the
fun tion
setq.
Another
w
a
y
is
to
use
let
(see
Se tion
3.6,
\let",
page
36).
(The
jargon
for
this
pro
 ess
is
to
bind
a
v
ariable
to
a
v
alue.)
The
follo
wing
se tions
not
only
des rib
e
ho
w
set
and
setq
w
ork
but
also
illustrate
ho
w
argumen
ts
are
passed.
1.9.1
Using
set
T
o
set
the
v
alue
of
the
sym
b
ol
flowers
to
the
list
'(rose
violet
daisy
butter up),
ev
aluate
the
follo
wing
expression
b
y
p
ositioning
the
 ursor
after
the
expression
and
t
yping
C-x
C-e.
(set
'flowers
'(rose
violet
daisy
butter up))

18
Chapter
1:
List
Pro
 essing
The
list
(rose
violet
daisy
butter up)
will
app
ear
in
the
e 
ho
area.
This
is
what
is
r
eturne
d
b
y
the
set
fun tion.
As
a
side
ee t,
the
sym
b
ol
flowers
is
b
ound
to
the
list
;
that
is,
the
sym
b
ol
flowers,
whi 
h
 an
b
e
view
ed
as
a
v
ariable,
is
giv
en
the
list
as
its
v
alue.
(This
pro
 ess,
b
y
the
w
a
y
,
illustrates
ho
w
a
side
ee t
to
the
Lisp
in
terpreter,
setting
the
v
alue,
 an
b
e
the
primary
ee t
that
w
e
h
umans
are
in
terested
in.
This
is
b
e ause
ev
ery
Lisp
fun tion
m
ust
return
a
v
alue
if
it
do
es
not
get
an
error,
but
it
will
only
ha
v
e
a
side
ee t
if
it
is
designed
to
ha
v
e
one.)
After
ev
aluating
the
set
expression,
y
ou
 an
ev
aluate
the
sym
b
ol
flowers
and
it
will
return
the
v
alue
y
ou
just
set.
Here
is
the
sym
b
ol.
Pla e
y
our
 ursor
after
it
and
t
yp
e
C-x
C-e.
flowers
When
y
ou
ev
aluate
flowers,
the
list
(rose
violet
daisy
butter up)
ap-
p
ears
in
the
e 
ho
area.
In iden
tally
,
if
y
ou
ev
aluate
'flowers,
the
v
ariable
with
a
quote
in
fron
t
of
it,
what
y
ou
will
see
in
the
e 
ho
area
is
the
sym
b
ol
itself,
flowers.
Here
is
the
quoted
sym
b
ol,
so
y
ou
 an
try
this:
'flowers
Note
also,
that
when
y
ou
use
set,
y
ou
need
to
quote
b
oth
argumen
ts
to
set,
unless
y
ou
w
an
t
them
ev
aluated.
Sin e
w
e
do
not
w
an
t
either
argumen
t
ev
aluated,
neither
the
v
ariable
flowers
nor
the
list
(rose
violet
daisy
butter up),
b
oth
are
quoted.
(When
y
ou
use
set
without
quoting
its
rst
argumen
t,
the
rst
argumen
t
is
ev
aluated
b
efore
an
ything
else
is
done.
If
y
ou
did
this
and
flowers
did
not
ha
v
e
a
v
alue
already
,
y
ou
w
ould
get
an
error
message
that
the
`Symbol's
value
as
variable
is
void';
on
the
other
hand,
if
flowers
did
return
a
v
alue
after
it
w
as
ev
aluated,
the
set
w
ould
attempt
to
set
the
v
alue
that
w
as
returned.
There
are
situations
where
this
is
the
righ
t
thing
for
the
fun tion
to
do;
but
su 
h
situations
are
rare.)
1.9.2
Using
setq
As
a
pra ti al
matter,
y
ou
almost
alw
a
ys
quote
the
rst
argumen
t
to
set.
The
 om
bination
of
set
and
a
quoted
rst
argumen
t
is
so
 ommon
that
it
has
its
o
wn
name:
the
sp
e ial
form
setq.
This
sp
e ial
form
is
just
lik
e
set
ex ept
that
the
rst
argumen
t
is
quoted
automati ally
,
so
y
ou
don't
need
to
t
yp
e
the
quote
mark
y
ourself.
Also,
as
an
added
 on
v
enien e,
setq
p
ermits
y
ou
to
set
sev
eral
dieren
t
v
ariables
to
dieren
t
v
alues,
all
in
one
expression.
T
o
set
the
v
alue
of
the
v
ariable
 arnivores
to
the
list
'(lion
tiger
leopard)
using
setq,
the
follo
wing
expression
is
used:
(setq
 arnivores
'(lion
tiger
leopard))
This
is
exa tly
the
same
as
using
set
ex ept
the
rst
argumen
t
is
automat-
i ally
quoted
b
y
setq.
(The
`q'
in
setq
means
quote.)

Coun
ting
19
With
set,
the
expression
w
ould
lo
ok
lik
e
this:
(set
' arnivores
'(lion
tiger
leopard))
Also,
setq
 an
b
e
used
to
assign
dieren
t
v
alues
to
dieren
t
v
ariables.
The
rst
argumen
t
is
b
ound
to
the
v
alue
of
the
se ond
argumen
t,
the
third
argumen
t
is
b
ound
to
the
v
alue
of
the
fourth
argumen
t,
and
so
on.
F
or
example,
y
ou
 ould
use
the
follo
wing
to
assign
a
list
of
trees
to
the
sym
b
ol
trees
and
a
list
of
herbiv
ores
to
the
sym
b
ol
herbivores:
(setq
trees
'(pine
fir
oak
maple)
herbivores
'(gazelle
antelope
zebra))
(The
expression
 ould
just
as
w
ell
ha
v
e
b
een
on
one
line,
but
it
migh
t
not
ha
v
e
t
on
a
page;
and
h
umans
nd
it
easier
to
read
ni ely
formatted
lists.)
Although
I
ha
v
e
b
een
using
the
term
`assign',
there
is
another
w
a
y
of
thinking
ab
out
the
w
orkings
of
set
and
setq;
and
that
is
to
sa
y
that
set
and
setq
mak
e
the
sym
b
ol
p
oint
to
the
list.
This
latter
w
a
y
of
thinking
is
v
ery
 ommon
and
in
forth oming
 
hapters
w
e
shall
 ome
up
on
at
least
one
sym
b
ol
that
has
`p
oin
ter'
as
part
of
its
name.
The
name
is
 
hosen
b
e ause
the
sym
b
ol
has
a
v
alue,
sp
e i ally
a
list,
atta 
hed
to
it;
or,
expressed
another
w
a
y
,
the
sym
b
ol
is
set
to
\p
oin
t"
to
the
list.
1.9.3
Coun
ting
Here
is
an
example
that
sho
ws
ho
w
to
use
setq
in
a
 oun
ter.
Y
ou
migh
t
use
this
to
 oun
t
ho
w
man
y
times
a
part
of
y
our
program
rep
eats
itself.
First
set
a
v
ariable
to
zero;
then
add
one
to
the
n
um
b
er
ea 
h
time
the
program
rep
eats
itself.
T
o
do
this,
y
ou
need
a
v
ariable
that
serv
es
as
a
 oun
ter,
and
t
w
o
expressions:
an
initial
setq
expression
that
sets
the
 oun
ter
v
ariable
to
zero;
and
a
se ond
setq
expression
that
in remen
ts
the
 oun
ter
ea 
h
time
it
is
ev
aluated.
(setq
 ounter
0)
;
Let's
 all
this
the
initializer.
(setq
 ounter
(+
 ounter
1))
;
This
is
the
in remen
ter.
 ounter
;
This
is
the
 oun
ter.
(The
text
follo
wing
the
`;'
are
 ommen
ts.
See
Se tion
3.2.1,
\Change
a
F
un tion
Denition",
page
32.)
If
y
ou
ev
aluate
the
rst
of
these
expressions,
the
initializer,
(setq
 ounter
0),
and
then
ev
aluate
the
third
expression,
 ounter,
the
n
um
b
er
0
will
app
ear
in
the
e 
ho
area.
If
y
ou
then
ev
aluate
the
se ond
expression,
the
in remen
ter,
(setq
 ounter
(+
 ounter
1)),
the
 oun
ter
will
get
the
v
alue
1.
So
if
y
ou
again
ev
aluate
 ounter,
the
n
um
b
er
1
will
app
ear
in
the
e 
ho
area.
Ea 
h
time
y
ou
ev
aluate
the
se ond
expression,
the
v
alue
of
the
 oun
ter
will
b
e
in remen
ted.
When
y
ou
ev
aluate
the
in remen
ter,
(setq
 ounter
(+
 ounter
1)),
the
Lisp
in
terpreter
rst
ev
aluates
the
innermost
list;
this
is
the
addition.
In

20
Chapter
1:
List
Pro
 essing
order
to
ev
aluate
this
list,
it
m
ust
ev
aluate
the
v
ariable
 ounter
and
the
n
um
b
er
1.
When
it
ev
aluates
the
v
ariable
 ounter,
it
re eiv
es
its
 urren
t
v
alue.
It
passes
this
v
alue
and
the
n
um
b
er
1
to
the
+
whi 
h
adds
them
together.
The
sum
is
then
returned
as
the
v
alue
of
the
inner
list
and
passed
to
the
setq
whi 
h
sets
the
v
ariable
 ounter
to
this
new
v
alue.
Th
us,
the
v
alue
of
the
v
ariable,
 ounter,
is
 
hanged.
1.10
Summary
Learning
Lisp
is
lik
e
 lim
bing
a
hill
in
whi 
h
the
rst
part
is
the
steep
est.
Y
ou
ha
v
e
no
w
 lim
b
ed
the
most
diÆ ult
part;
what
remains
b
e omes
easier
as
y
ou
progress
on
w
ards.
In
summary
,

Lisp
programs
are
made
up
of
expressions,
whi 
h
are
lists
or
single
atoms.

Lists
are
made
up
of
zero
or
more
atoms
or
inner
lists,
separated
b
y
whitespa e
and
surrounded
b
y
paren
theses.
A
list
 an
b
e
empt
y
.

A
toms
are
m
ulti- 
hara ter
sym
b
ols,
lik
e
forward-paragraph,
single
 
hara ter
sym
b
ols
lik
e
+,
strings
of
 
hara ters
b
et
w
een
double
quota-
tion
marks,
or
n
um
b
ers.

A
n
um
b
er
ev
aluates
to
itself.

A
string
b
et
w
een
double
quotes
also
ev
aluates
to
itself.

When
y
ou
ev
aluate
a
sym
b
ol
b
y
itself,
its
v
alue
is
returned.

When
y
ou
ev
aluate
a
list,
the
Lisp
in
terpreter
lo
oks
at
the
rst
sym
b
ol
in
the
list
and
then
at
the
fun tion
denition
b
ound
to
that
sym
b
ol.
Then
the
instru tions
in
the
fun tion
denition
are
 arried
out.

A
single-quote,
',
tells
the
Lisp
in
terpreter
that
it
should
return
the
follo
wing
expression
as
written,
and
not
ev
aluate
it
as
it
w
ould
if
the
quote
w
ere
not
there.

Argumen
ts
are
the
information
passed
to
a
fun tion.
The
argumen
ts
to
a
fun tion
are
 omputed
b
y
ev
aluating
the
rest
of
the
elemen
ts
of
the
list
of
whi 
h
the
fun tion
is
the
rst
elemen
t.

A
fun tion
alw
a
ys
returns
a
v
alue
when
it
is
ev
aluated
(unless
it
gets
an
error);
in
addition,
it
ma
y
also
 arry
out
some
a tion
 alled
a
\side
ee t".
In
man
y
 ases,
a
fun tion's
primary
purp
ose
is
to
 reate
a
side
ee t.
1.11
Exer ises
A
few
simple
exer ises:

Generate
an
error
message
b
y
ev
aluating
an
appropriate
sym
b
ol
that
is
not
within
paren
theses.

Exer ises
21

Generate
an
error
message
b
y
ev
aluating
an
appropriate
sym
b
ol
that
is
b
et
w
een
paren
theses.

Create
a
 oun
ter
that
in remen
ts
b
y
t
w
o
rather
than
one.

W
rite
an
expression
that
prin
ts
a
message
in
the
e 
ho
area
when
ev
alu-
ated.

22
Chapter
1:
List
Pro
 essing

Buer
Names
23
2
Pra ti ing
Ev
aluation
Before
learning
ho
w
to
write
a
fun tion
denition
in
Ema s
Lisp,
it
is
useful
to
sp
end
a
little
time
ev
aluating
v
arious
expressions
that
ha
v
e
already
b
een
written.
These
expressions
will
b
e
lists
with
the
fun tions
as
their
rst
(and
often
only)
elemen
t.
Sin e
some
of
the
fun tions
asso
 iated
with
buers
are
b
oth
simple
and
in
teresting,
w
e
will
start
with
those.
In
this
se tion,
w
e
will
ev
aluate
a
few
of
these.
In
another
se tion,
w
e
will
study
the
 o
de
of
sev
eral
other
buer-related
fun tions,
to
see
ho
w
they
w
ere
written.
Whenever
you
give
an
e
diting
 
ommand
to
Ema s
Lisp,
su 
h
as
the
 om-
mand
to
mo
v
e
the
 ursor
or
to
s roll
the
s reen,
you
ar
e
evaluating
an
ex-
pr
ession,
the
rst
elemen
t
of
whi 
h
is
a
fun tion.
This
is
how
Ema s
works.
When
y
ou
t
yp
e
k
eys,
y
ou
 ause
the
Lisp
in
terpreter
to
ev
aluate
an
expres-
sion
and
that
is
ho
w
y
ou
get
y
our
results.
Ev
en
t
yping
plain
text
in
v
olv
es
ev
aluating
an
Ema s
Lisp
fun tion,
in
this
 ase,
one
that
uses
self-insert-
 ommand,
whi 
h
simply
inserts
the
 
hara ter
y
ou
t
yp
ed.
The
fun tions
y
ou
ev
aluate
b
y
t
yping
k
eystrok
es
are
 alled
in
tera tiv
e
fun tions,
or
 ommands
;
ho
w
y
ou
mak
e
a
fun tion
in
tera tiv
e
will
b
e
illustrated
in
the
 
hapter
on
ho
w
to
write
fun tion
denitions.
See
Se tion
3.3,
\Making
a
F
un tion
In-
tera tiv
e",
page
33.
In
addition
to
t
yping
k
eyb
oard
 ommands,
w
e
ha
v
e
seen
a
se ond
w
a
y
to
ev
aluate
an
expression:
b
y
p
ositioning
the
 ursor
after
a
list
and
t
yping
C-x
C-e.
This
is
what
w
e
will
do
in
the
rest
of
this
se tion.
There
are
other
w
a
ys
to
ev
aluate
an
expression
as
w
ell;
these
will
b
e
des rib
ed
as
w
e
 ome
to
them.
Besides
b
eing
used
for
pra ti ing
ev
aluation,
the
fun tions
sho
wn
in
the
next
few
se tions
are
imp
ortan
t
in
their
o
wn
righ
t.
A
study
of
these
fun tions
mak
es
 lear
the
distin tion
b
et
w
een
buers
and
les,
ho
w
to
swit 
h
to
a
buer,
and
ho
w
to
determine
a
lo
 ation
within
it.
2.1
Buer
Names
The
t
w
o
fun tions,
buffer-name
and
buffer-file-name,
sho
w
the
dier-
en e
b
et
w
een
a
le
and
a
buer.
When
y
ou
ev
aluate
the
follo
wing
expression,
(buffer-name),
the
name
of
the
buer
app
ears
in
the
e 
ho
area.
When
y
ou
ev
aluate
(buffer-file-name),
the
name
of
the
le
to
whi 
h
the
buer
refers
app
ears
in
the
e 
ho
area.
Usually
,
the
name
returned
b
y
(buffer-name)
is
the
same
as
the
name
of
the
le
to
whi 
h
it
refers,
and
the
name
returned
b
y
(buffer-file-name)
is
the
full
path-name
of
the
le.
A
le
and
a
buer
are
t
w
o
dieren
t
en
tities.
A
le
is
information
re orded
p
ermanen
tly
in
the
 omputer
(unless
y
ou
delete
it).
A
buer,
on
the
other
hand,
is
information
inside
of
Ema s
that
will
v
anish
at
the
end
of
the
editing
session
(or
when
y
ou
kill
the
buer).
Usually
,
a
buer
 on
tains
information
that
y
ou
ha
v
e
 opied
from
a
le;
w
e
sa
y
the
buer
is
visiting
that
le.
This
 op
y
is
what
y
ou
w
ork
on
and
mo
dify
.
Changes
to
the
buer
do
not
 
hange

24
Chapter
2:
Pra ti ing
Ev
aluation
the
le,
un
til
y
ou
sa
v
e
the
buer.
When
y
ou
sa
v
e
the
buer,
the
buer
is
 opied
to
the
le
and
is
th
us
sa
v
ed
p
ermanen
tly
.
If
y
ou
are
reading
this
in
Info
inside
of
GNU
Ema s,
y
ou
 an
ev
aluate
ea 
h
of
the
follo
wing
expressions
b
y
p
ositioning
the
 ursor
after
it
and
t
yping
C-x
C-e.
(buffer-name)
(buffer-file-name)
When
I
do
this,
`"introdu tion.texinfo"'
is
the
v
alue
returned
b
y
ev
al-
uating
(buffer-name),
and
`"/gnu/work/intro/introdu 
tio
n.te
xinf
o"'
is
the
v
alue
returned
b
y
ev
aluating
(buffer-file-name).
The
former
is
the
name
of
the
buer
and
the
latter
is
the
name
of
the
le.
(In
the
expres-
sions,
the
paren
theses
tell
the
Lisp
in
terpreter
to
treat
buffer-name
and
buffer-file-name
as
fun tions;
without
the
paren
theses,
the
in
terpreter
w
ould
attempt
to
ev
aluate
the
sym
b
ols
as
v
ariables.
See
Se tion
1.7,
\V
ari-
ables",
page
10.)
In
spite
of
the
distin tion
b
et
w
een
les
and
buers,
y
ou
will
often
nd
that
p
eople
refer
to
a
le
when
they
mean
a
buer
and
vi e-v
ersa.
Indeed,
most
p
eople
sa
y
,
\I
am
editing
a
le,"
rather
than
sa
ying,
\I
am
editing
a
buer
whi 
h
I
will
so
on
sa
v
e
to
a
le."
It
is
almost
alw
a
ys
 lear
from
 on
text
what
p
eople
mean.
When
dealing
with
 omputer
programs,
ho
w
ev
er,
it
is
imp
ortan
t
to
k
eep
the
distin tion
in
mind,
sin e
the
 omputer
is
not
as
smart
as
a
p
erson.
The
w
ord
`buer',
b
y
the
w
a
y
,
 omes
from
the
meaning
of
the
w
ord
as
a
 ushion
that
deadens
the
for e
of
a
 ollision.
In
early
 omputers,
a
buer
 ushioned
the
in
tera tion
b
et
w
een
les
and
the
 omputer's
 en
tral
pro
 essing
unit.
The
drums
or
tap
es
that
held
a
le
and
the
 en
tral
pro
 essing
unit
w
ere
pie es
of
equipmen
t
that
w
ere
v
ery
dieren
t
from
ea 
h
other,
w
orking
at
their
o
wn
sp
eeds,
in
spurts.
The
buer
made
it
p
ossible
for
them
to
w
ork
together
ee tiv
ely
.
Ev
en
tually
,
the
buer
grew
from
b
eing
an
in
termediary
,
a
temp
orary
holding
pla e,
to
b
eing
the
pla e
where
w
ork
is
done.
This
transformation
is
rather
lik
e
that
of
a
small
seap
ort
that
grew
in
to
a
great
 it
y:
on e
it
w
as
merely
the
pla e
where
 argo
w
as
w
arehoused
temp
orarily
b
efore
b
eing
loaded
on
to
ships;
then
it
b
e ame
a
business
and
 ultural
 en
ter
in
its
o
wn
righ
t.
Not
all
buers
are
asso
 iated
with
les.
F
or
example,
when
y
ou
start
an
Ema s
session
b
y
t
yping
the
 ommand
ema s
alone,
without
naming
an
y
les,
Ema s
will
start
with
the
`*s rat h*'
buer
on
the
s reen.
This
buer
is
not
visiting
an
y
le.
Similarly
,
a
`*Help*'
buer
is
not
asso
 iated
with
an
y
le.
If
y
ou
swit 
h
to
the
`*s rat h*'
buer,
t
yp
e
(buffer-name),
p
osition
the
 ursor
after
it,
and
t
yp
e
C-x
C-e
to
ev
aluate
the
expression,
the
name
"*s rat h*"
is
returned
and
will
app
ear
in
the
e 
ho
area.
"*s rat h*"
is
the
name
of
the
buer.
Ho
w
ev
er,
if
y
ou
t
yp
e
(buffer-file-name)
in

Getting
Buers
25
the
`*s rat h*'
buer
and
ev
aluate
that,
nil
will
app
ear
in
the
e 
ho
area.
nil
is
from
the
Latin
w
ord
for
`nothing';
in
this
 ase,
it
means
that
the
`*s rat h*'
buer
is
not
asso
 iated
with
an
y
le.
(In
Lisp,
nil
is
also
used
to
mean
`false'
and
is
a
synon
ym
for
the
empt
y
list,
().)
In iden
tally
,
if
y
ou
are
in
the
`*s rat h*'
buer
and
w
an
t
the
v
alue
returned
b
y
an
expression
to
app
ear
in
the
`*s rat h*'
buer
itself
rather
than
in
the
e 
ho
area,
t
yp
e
C-u
C-x
C-e
instead
of
C-x
C-e.
This
 auses
the
v
alue
returned
to
app
ear
after
the
expression.
The
buer
will
lo
ok
lik
e
this:
(buffer-name)"*s rat h*"
Y
ou
 annot
do
this
in
Info
sin e
Info
is
read-only
and
it
will
not
allo
w
y
ou
to
 
hange
the
 on
ten
ts
of
the
buer.
But
y
ou
 an
do
this
in
an
y
buer
y
ou
 an
edit;
and
when
y
ou
write
 o
de
or
do
 umen
tation
(su 
h
as
this
b
o
ok),
this
feature
is
v
ery
useful.
2.2
Getting
Buers
The
buffer-name
fun tion
returns
the
name
of
the
buer;
to
get
the
buer
itself,
a
dieren
t
fun tion
is
needed:
the
 urrent-buffer
fun tion.
If
y
ou
use
this
fun tion
in
 o
de,
what
y
ou
get
is
the
buer
itself.
A
name
and
the
ob
je t
or
en
tit
y
to
whi 
h
the
name
refers
are
dieren
t
from
ea 
h
other.
Y
ou
are
not
y
our
name.
Y
ou
are
a
p
erson
to
whom
others
refer
b
y
name.
If
y
ou
ask
to
sp
eak
to
George
and
someone
hands
y
ou
a
 ard
with
the
letters
`G',
`e',
`o',
`r',
`g',
and
`e'
written
on
it,
y
ou
migh
t
b
e
am
used,
but
y
ou
w
ould
not
b
e
satised.
Y
ou
do
not
w
an
t
to
sp
eak
to
the
name,
but
to
the
p
erson
to
whom
the
name
refers.
A
buer
is
similar:
the
name
of
the
s rat 
h
buer
is
`*s rat h*',
but
the
name
is
not
the
buer.
T
o
get
a
buer
itself,
y
ou
need
to
use
a
fun tion
su 
h
as
 urrent-buffer.
Ho
w
ev
er,
there
is
a
sligh
t
 ompli ation:
if
y
ou
ev
aluate
 urrent-buffer
in
an
expression
on
its
o
wn,
as
w
e
will
do
here,
what
y
ou
see
is
a
prin
ted
represen
tation
of
the
name
of
the
buer
without
the
 on
ten
ts
of
the
buer.
Ema s
w
orks
this
w
a
y
for
t
w
o
reasons:
the
buer
ma
y
b
e
thousands
of
lines
long|to
o
long
to
b
e
 on
v
enien
tly
displa
y
ed;
and,
another
buer
ma
y
ha
v
e
the
same
 on
ten
ts
but
a
dieren
t
name,
and
it
is
imp
ortan
t
to
distinguish
b
et
w
een
them.
Here
is
an
expression
 on
taining
the
fun tion:
( urrent-buffer)
If
y
ou
ev
aluate
the
expression
in
the
usual
w
a
y
,
`#<buffer
*info*>'
app
ears
in
the
e 
ho
area.
The
sp
e ial
format
indi ates
that
the
buer
itself
is
b
eing
returned,
rather
than
just
its
name.
In iden
tally
,
while
y
ou
 an
t
yp
e
a
n
um
b
er
or
sym
b
ol
in
to
a
program,
y
ou
 annot
do
that
with
the
prin
ted
represen
tation
of
a
buer:
the
only
w
a
y
to
get
a
buer
itself
is
with
a
fun tion
su 
h
as
 urrent-buffer.
A
related
fun tion
is
other-buffer.
This
returns
the
most
re en
tly
se-
le ted
buer
other
than
the
one
y
ou
are
in
 urren
tly
.
If
y
ou
ha
v
e
re en
tly

26
Chapter
2:
Pra ti ing
Ev
aluation
swit 
hed
ba 
k
and
forth
from
the
`*s rat h*'
buer,
other-buffer
will
return
that
buer.
Y
ou
 an
see
this
b
y
ev
aluating
the
expression:
(other-buffer)
Y
ou
should
see
`#<buffer
*s rat h*>'
app
ear
in
the
e 
ho
area,
or
the
name
of
whatev
er
other
buer
y
ou
swit 
hed
ba 
k
from
most
re en
tly
1
.
2.3
Swit 
hing
Buers
The
other-buffer
fun tion
a tually
pro
vides
a
buer
when
it
is
used
as
an
argumen
t
to
a
fun tion
that
requires
one.
W
e
 an
see
this
b
y
using
other-buffer
and
swit h-to-buffer
to
swit 
h
to
a
dieren
t
buer.
But
rst,
a
brief
in
tro
du tion
to
the
swit h-to-buffer
fun tion.
When
y
ou
swit 
hed
ba 
k
and
forth
from
Info
to
the
`*s rat h*'
buer
to
ev
aluate
(buffer-name),
y
ou
most
lik
ely
t
yp
ed
C-x
b
and
then
t
yp
ed
`*s rat h*'
2
when
prompted
in
the
minibuer
for
the
name
of
the
buer
to
whi 
h
y
ou
w
an
ted
to
swit 
h.
The
k
eystrok
es,
C-x
b,
 ause
the
Lisp
in
terpreter
to
ev
al-
uate
the
in
tera tiv
e
fun tion
swit h-to-buffer.
As
w
e
said
b
efore,
this
is
ho
w
Ema s
w
orks:
dieren
t
k
eystrok
es
 all
or
run
dieren
t
fun tions.
F
or
example,
C-f
 alls
forward- har,
M-e
 alls
forward-senten e,
and
so
on.
By
writing
swit h-to-buffer
in
an
expression,
and
giving
it
a
buer
to
swit 
h
to,
w
e
 an
swit 
h
buers
just
the
w
a
y
C-x
b
do
es.
Here
is
the
Lisp
expression:
(swit h-to-buffer
(other-buffer))
The
sym
b
ol
swit h-to-buffer
is
the
rst
elemen
t
of
the
list,
so
the
Lisp
in
terpreter
will
treat
it
as
a
fun tion
and
 arry
out
the
instru tions
that
are
atta 
hed
to
it.
But
b
efore
doing
that,
the
in
terpreter
will
note
that
other-buffer
is
inside
paren
theses
and
w
ork
on
that
sym
b
ol
rst.
other-
buffer
is
the
rst
(and
in
this
 ase,
the
only)
elemen
t
of
this
list,
so
the
Lisp
in
terpreter
 alls
or
runs
the
fun tion.
It
returns
another
buer.
Next,
the
in
terpreter
runs
swit h-to-buffer,
passing
to
it,
as
an
argumen
t,
the
other
buer,
whi 
h
is
what
Ema s
will
swit 
h
to.
If
y
ou
are
reading
this
in
Info,
try
this
no
w.
Ev
aluate
the
expression.
(T
o
get
ba 
k,
t
yp
e
C-x
b
h
RET
i
.)
3
1
A tually
,
b
y
default,
if
the
buer
from
whi 
h
y
ou
just
swit 
hed
is
visible
to
y
ou
in
another
windo
w,
other-buffer
will
 
ho
ose
the
most
re en
t
buer
that
y
ou
 annot
see;
this
is
a
subtlet
y
that
I
often
forget.
2
Or
rather,
to
sa
v
e
t
yping,
y
ou
probably
t
yp
ed
just
part
of
the
name,
su 
h
as
*s ,
and
then
pressed
y
our
TAB
k
ey
to
 ause
it
to
expand
to
the
full
name;
and
then
t
yp
ed
y
our
RET
k
ey
.
3
Remem
b
er,
this
expression
will
mo
v
e
y
ou
to
y
our
most
re en
t
other
buer
that
y
ou
 annot
see.
If
y
ou
really
w
an
t
to
go
to
y
our
most
re en
tly
sele ted
buer,
ev
en
if
y
ou
 an
still
see
it,
y
ou
need
to
ev
aluate
the
follo
wing
more
 omplex
expression:
(swit h-to-buffer
(other-buffer
( urrent-buffer)
t))

Buer
Size
and
the
Lo
 ation
of
P
oin
t
27
In
the
programming
examples
in
later
se tions
of
this
do
 umen
t,
y
ou
will
see
the
fun tion
set-buffer
more
often
than
swit h-to-buffer.
This
is
b
e ause
of
a
dieren e
b
et
w
een
 omputer
programs
and
h
umans:
h
umans
ha
v
e
ey
es
and
exp
e t
to
see
the
buer
on
whi 
h
they
are
w
orking
on
their
 omputer
terminals.
This
is
so
ob
vious,
it
almost
go
es
without
sa
ying.
Ho
w-
ev
er,
programs
do
not
ha
v
e
ey
es.
When
a
 omputer
program
w
orks
on
a
buer,
that
buer
do
es
not
need
to
b
e
visible
on
the
s reen.
swit h-to-buffer
is
designed
for
h
umans
and
do
es
t
w
o
dieren
t
things:
it
swit 
hes
the
buer
to
whi 
h
Ema s'
atten
tion
is
dire ted;
and
it
swit 
hes
the
buer
displa
y
ed
in
the
windo
w
to
the
new
buer.
set-buffer,
on
the
other
hand,
do
es
only
one
thing:
it
swit 
hes
the
atten
tion
of
the
 omputer
program
to
a
dieren
t
buer.
The
buer
on
the
s reen
remains
un 
hanged
(of
 ourse,
normally
nothing
happ
ens
there
un
til
the
 ommand
nishes
running).
Also,
w
e
ha
v
e
just
in
tro
du ed
another
jargon
term,
the
w
ord
 all.
When
y
ou
ev
aluate
a
list
in
whi 
h
the
rst
sym
b
ol
is
a
fun tion,
y
ou
are
 alling
that
fun tion.
The
use
of
the
term
 omes
from
the
notion
of
the
fun tion
as
an
en
tit
y
that
 an
do
something
for
y
ou
if
y
ou
` all'
it|just
as
a
plum
b
er
is
an
en
tit
y
who
 an
x
a
leak
if
y
ou
 all
him
or
her.
2.4
Buer
Size
and
the
Lo
 ation
of
P
oin
t
Finally
,
let's
lo
ok
at
sev
eral
rather
simple
fun tions,
buffer-size,
point,
point-min,
and
point-max.
These
giv
e
information
ab
out
the
size
of
a
buer
and
the
lo
 ation
of
p
oin
t
within
it.
The
fun tion
buffer-size
tells
y
ou
the
size
of
the
 urren
t
buer;
that
is,
the
fun tion
returns
a
 oun
t
of
the
n
um
b
er
of
 
hara ters
in
the
buer.
(buffer-size)
Y
ou
 an
ev
aluate
this
in
the
usual
w
a
y
,
b
y
p
ositioning
the
 ursor
after
the
expression
and
t
yping
C-x
C-e.
In
Ema s,
the
 urren
t
p
osition
of
the
 ursor
is
 alled
p
oin
t.
The
expres-
sion
(point)
returns
a
n
um
b
er
that
tells
y
ou
where
the
 ursor
is
lo
 ated
as
a
 oun
t
of
the
n
um
b
er
of
 
hara ters
from
the
b
eginning
of
the
buer
up
to
p
oin
t.
Y
ou
 an
see
the
 
hara ter
 oun
t
for
p
oin
t
in
this
buer
b
y
ev
aluating
the
follo
wing
expression
in
the
usual
w
a
y:
(point)
As
I
write
this,
the
v
alue
of
point
is
65724.
The
point
fun tion
is
frequen
tly
used
in
some
of
the
examples
later
in
this
b
o
ok.
In
this
 ase,
the
rst
argumen
t
to
other-buffer
tells
it
whi 
h
buer
to
skip|the
 urren
t
one|and
the
se ond
argumen
t
tells
other-buffer
it
is
OK
to
swit 
h
to
a
visible
buer.
In
regular
use,
swit h-to-buffer
tak
es
y
ou
to
an
in
visible
windo
w
sin e
y
ou
w
ould
most
lik
ely
use
C-x
o
(other-window)
to
go
to
another
visible
buer.

28
Chapter
2:
Pra ti ing
Ev
aluation
The
v
alue
of
p
oin
t
dep
ends,
of
 ourse,
on
its
lo
 ation
within
the
buer.
If
y
ou
ev
aluate
p
oin
t
in
this
sp
ot,
the
n
um
b
er
will
b
e
larger:
(point)
F
or
me,
the
v
alue
of
p
oin
t
in
this
lo
 ation
is
66043,
whi 
h
means
that
there
are
319
 
hara ters
(in luding
spa es)
b
et
w
een
the
t
w
o
expressions.
The
fun tion
point-min
is
somewhat
similar
to
point,
but
it
returns
the
v
alue
of
the
minim
um
p
ermissible
v
alue
of
p
oin
t
in
the
 urren
t
buer.
This
is
the
n
um
b
er
1
unless
narro
wing
is
in
ee t.
(Narro
wing
is
a
me 
hanism
whereb
y
y
ou
 an
restri t
y
ourself,
or
a
program,
to
op
erations
on
just
a
part
of
a
buer.
See
Chapter
6,
\Narro
wing
and
Widening",
page
77.)
Lik
ewise,
the
fun tion
point-max
returns
the
v
alue
of
the
maxim
um
p
ermissible
v
alue
of
p
oin
t
in
the
 urren
t
buer.
2.5
Exer ise
Find
a
le
with
whi 
h
y
ou
are
w
orking
and
mo
v
e
to
w
ards
its
middle.
Find
its
buer
name,
le
name,
length,
and
y
our
p
osition
in
the
le.

The
defun
Sp
e ial
F
orm
29
3
Ho
w
T
o
W
rite
F
un tion
Denitions
When
the
Lisp
in
terpreter
ev
aluates
a
list,
it
lo
oks
to
see
whether
the
rst
sym
b
ol
on
the
list
has
a
fun tion
denition
atta 
hed
to
it;
or,
put
another
w
a
y
,
whether
the
sym
b
ol
p
oin
ts
to
a
fun tion
denition.
If
it
do
es,
the
 omputer
 arries
out
the
instru tions
in
the
denition.
A
sym
b
ol
that
has
a
fun tion
denition
is
 alled,
simply
,
a
fun tion
(although,
prop
erly
sp
eaking,
the
denition
is
the
fun tion
and
the
sym
b
ol
refers
to
it.)
All
fun tions
are
dened
in
terms
of
other
fun tions,
ex ept
for
a
few
primitiv
e
fun tions
that
are
written
in
the
C
programming
language.
When
y
ou
write
fun tions'
denitions,
y
ou
will
write
them
in
Ema s
Lisp
and
use
other
fun tions
as
y
our
building
blo
 
ks.
Some
of
the
fun tions
y
ou
will
use
will
themselv
es
b
e
written
in
Ema s
Lisp
(p
erhaps
b
y
y
ou)
and
some
will
b
e
primitiv
es
written
in
C.
The
primitiv
e
fun tions
are
used
exa tly
lik
e
those
written
in
Ema s
Lisp
and
b
eha
v
e
lik
e
them.
They
are
written
in
C
so
w
e
 an
easily
run
GNU
Ema s
on
an
y
 omputer
that
has
suÆ ien
t
p
o
w
er
and
 an
run
C.
Let
me
re-emphasize
this:
when
y
ou
write
 o
de
in
Ema s
Lisp,
y
ou
do
not
distinguish
b
et
w
een
the
use
of
fun tions
written
in
C
and
the
use
of
fun tions
written
in
Ema s
Lisp.
The
dieren e
is
irrelev
an
t.
I
men
tion
the
distin tion
only
b
e ause
it
is
in
teresting
to
kno
w.
Indeed,
unless
y
ou
in
v
estigate,
y
ou
w
on't
kno
w
whether
an
already-written
fun tion
is
written
in
Ema s
Lisp
or
C.
3.1
The
defun
Sp
e ial
F
orm
In
Lisp,
a
sym
b
ol
su 
h
as
mark-whole-buffer
has
 o
de
atta 
hed
to
it
that
tells
the
 omputer
what
to
do
when
the
fun tion
is
 alled.
This
 o
de
is
 alled
the
fun tion
denition
and
is
 reated
b
y
ev
aluating
a
Lisp
expression
that
starts
with
the
sym
b
ol
defun
(whi 
h
is
an
abbreviation
for
dene
fun tion
).
Be ause
defun
do
es
not
ev
aluate
its
argumen
ts
in
the
usual
w
a
y
,
it
is
 alled
a
sp
e ial
form.
In
subsequen
t
se tions,
w
e
will
lo
ok
at
fun tion
denitions
from
the
Ema s
sour e
 o
de,
su 
h
as
mark-whole-buffer.
In
this
se tion,
w
e
will
des rib
e
a
simple
fun tion
denition
so
y
ou
 an
see
ho
w
it
lo
oks.
This
fun tion
denition
uses
arithmeti 
b
e ause
it
mak
es
for
a
simple
example.
Some
p
eople
dislik
e
examples
using
arithmeti ;
ho
w
ev
er,
if
y
ou
are
su 
h
a
p
erson,
do
not
despair.
Hardly
an
y
of
the
 o
de
w
e
will
study
in
the
remainder
of
this
in
tro
du tion
in
v
olv
es
arithmeti 
or
mathemati s.
The
examples
mostly
in
v
olv
e
text
in
one
w
a
y
or
another.
A
fun tion
denition
has
up
to
v
e
parts
follo
wing
the
w
ord
defun:
1.
The
name
of
the
sym
b
ol
to
whi 
h
the
fun tion
denition
should
b
e
atta 
hed.
2.
A
list
of
the
argumen
ts
that
will
b
e
passed
to
the
fun tion.
If
no
argu-
men
ts
will
b
e
passed
to
the
fun tion,
this
is
an
empt
y
list,
().

30
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
3.
Do
 umen
tation
des ribing
the
fun tion.
(T
e 
hni ally
optional,
but
strongly
re ommended.)
4.
Optionally
,
an
expression
to
mak
e
the
fun tion
in
tera tiv
e
so
y
ou
 an
use
it
b
y
t
yping
M-x
and
then
the
name
of
the
fun tion;
or
b
y
t
yping
an
appropriate
k
ey
or
k
ey 
hord.
5.
The
 o
de
that
instru ts
the
 omputer
what
to
do:
the
b
o
dy
of
the
fun tion
denition.
It
is
helpful
to
think
of
the
v
e
parts
of
a
fun tion
denition
as
b
eing
organized
in
a
template,
with
slots
for
ea 
h
part:
(defun
fun tion-name
(argumen
ts
...)
"optional-do
 umen
tation...
"
(intera tive
argumen
t-passing-info
)
;
optional
b
o
dy
...
)
As
an
example,
here
is
the
 o
de
for
a
fun tion
that
m
ultiplies
its
argumen
t
b
y
7.
(This
example
is
not
in
tera tiv
e.
See
Se tion
3.3,
\Making
a
F
un tion
In
tera tiv
e",
page
33,
for
that
information.)
(defun
multiply-by-seven
(number)
"Multiply
NUMBER
by
seven."
(*
7
number))
This
denition
b
egins
with
a
paren
thesis
and
the
sym
b
ol
defun,
follo
w
ed
b
y
the
name
of
the
fun tion.
The
name
of
the
fun tion
is
follo
w
ed
b
y
a
list
that
 on
tains
the
argumen
ts
that
will
b
e
passed
to
the
fun tion.
This
list
is
 alled
the
argumen
t
list.
In
this
example,
the
list
has
only
one
elemen
t,
the
sym
b
ol,
number.
When
the
fun tion
is
used,
the
sym
b
ol
will
b
e
b
ound
to
the
v
alue
that
is
used
as
the
argumen
t
to
the
fun tion.
Instead
of
 
ho
osing
the
w
ord
number
for
the
name
of
the
argumen
t,
I
 ould
ha
v
e
pi 
k
ed
an
y
other
name.
F
or
example,
I
 ould
ha
v
e
 
hosen
the
w
ord
multipli and.
I
pi 
k
ed
the
w
ord
`n
um
b
er'
b
e ause
it
tells
what
kind
of
v
alue
is
in
tended
for
this
slot;
but
I
 ould
just
as
w
ell
ha
v
e
 
hosen
the
w
ord
`m
ultipli and'
to
indi ate
the
role
that
the
v
alue
pla ed
in
this
slot
will
pla
y
in
the
w
orkings
of
the
fun tion.
I
 ould
ha
v
e
 alled
it
foogle,
but
that
w
ould
ha
v
e
b
een
a
bad
 
hoi e
b
e ause
it
w
ould
not
tell
h
umans
what
it
means.
The
 
hoi e
of
name
is
up
to
the
programmer
and
should
b
e
 
hosen
to
mak
e
the
meaning
of
the
fun tion
 lear.
Indeed,
y
ou
 an
 
ho
ose
an
y
name
y
ou
wish
for
a
sym
b
ol
in
an
argumen
t
list,
ev
en
the
name
of
a
sym
b
ol
used
in
some
other
fun tion:
the
name
y
ou
use
in
an
argumen
t
list
is
priv
ate
to
that
parti ular
denition.
In
that
denition,
the
name
refers
to
a
dieren
t
en
tit
y
than
an
y
use
of
the
same
name
outside
the
fun tion
denition.
Supp
ose
y
ou
ha
v
e
a
ni 
k-name
`Short
y'
in
y
our
family;
when
y
our
family
mem
b
ers
refer
to
`Short
y',
they
mean
y
ou.
But
outside
y
our
family
,
in
a
mo
vie,
for
example,
the
name
`Short
y'
refers
to
someone
else.
Be ause
a
name
in
an
argumen
t
list
is
priv
ate
to
the
fun tion

Install
a
F
un tion
Denition
31
denition,
y
ou
 an
 
hange
the
v
alue
of
su 
h
a
sym
b
ol
inside
the
b
o
dy
of
a
fun tion
without
 
hanging
its
v
alue
outside
the
fun tion.
The
ee t
is
similar
to
that
pro
du ed
b
y
a
let
expression.
(See
Se tion
3.6,
\let",
page
36.)
The
argumen
t
list
is
follo
w
ed
b
y
the
do
 umen
tation
string
that
des rib
es
the
fun tion.
This
is
what
y
ou
see
when
y
ou
t
yp
e
C-h
f
and
the
name
of
a
fun tion.
In iden
tally
,
when
y
ou
write
a
do
 umen
tation
string
lik
e
this,
y
ou
should
mak
e
the
rst
line
a
 omplete
sen
ten e
sin e
some
 ommands,
su 
h
as
apropos,
prin
t
only
the
rst
line
of
a
m
ulti-line
do
 umen
tation
string.
Also,
y
ou
should
not
inden
t
the
se ond
line
of
a
do
 umen
tation
string,
if
y
ou
ha
v
e
one,
b
e ause
that
lo
oks
o
dd
when
y
ou
use
C-h
f
(des ribe-fun tion).
The
do
 umen
tation
string
is
optional,
but
it
is
so
useful,
it
should
b
e
in luded
in
almost
ev
ery
fun tion
y
ou
write.
The
third
line
of
the
example
 onsists
of
the
b
o
dy
of
the
fun tion
deni-
tion.
(Most
fun tions'
denitions,
of
 ourse,
are
longer
than
this.)
In
this
fun tion,
the
b
o
dy
is
the
list,
(*
7
number),
whi 
h
sa
ys
to
m
ultiply
the
v
alue
of
n
um
b
er
b
y
7.
(In
Ema s
Lisp,
*
is
the
fun tion
for
m
ultipli ation,
just
as
+
is
the
fun tion
for
addition.)
When
y
ou
use
the
multiply-by-seven
fun tion,
the
argumen
t
number
ev
aluates
to
the
a tual
n
um
b
er
y
ou
w
an
t
used.
Here
is
an
example
that
sho
ws
ho
w
multiply-by-seven
is
used;
but
don't
try
to
ev
aluate
this
y
et!
(multiply-by-seven
3)
The
sym
b
ol
number,
sp
e ied
in
the
fun tion
denition
in
the
next
se tion,
is
giv
en
or
\b
ound
to"
the
v
alue
3
in
the
a tual
use
of
the
fun tion.
Note
that
although
number
w
as
inside
paren
theses
in
the
fun tion
denition,
the
argumen
t
passed
to
the
multiply-by-seven
fun tion
is
not
in
paren
theses.
The
paren
theses
are
written
in
the
fun tion
denition
so
the
 omputer
 an
gure
out
where
the
argumen
t
list
ends
and
the
rest
of
the
fun tion
denition
b
egins.
If
y
ou
ev
aluate
this
example,
y
ou
are
lik
ely
to
get
an
error
message.
(Go
ahead,
try
it!)
This
is
b
e ause
w
e
ha
v
e
written
the
fun tion
denition,
but
not
y
et
told
the
 omputer
ab
out
the
denition|w
e
ha
v
e
not
y
et
installed
(or
`loaded')
the
fun tion
denition
in
Ema s.
Installing
a
fun tion
is
the
pro
 ess
that
tells
the
Lisp
in
terpreter
the
denition
of
the
fun tion.
Installation
is
des rib
ed
in
the
next
se tion.
3.2
Install
a
F
un tion
Denition
If
y
ou
are
reading
this
inside
of
Info
in
Ema s,
y
ou
 an
try
out
the
multiply-by-seven
fun tion
b
y
rst
ev
aluating
the
fun tion
denition
and
then
ev
aluating
(multiply-by-seven
3).
A
 op
y
of
the
fun tion
denition
follo
ws.
Pla e
the
 ursor
after
the
last
paren
thesis
of
the
fun tion
denition
and
t
yp
e
C-x
C-e.
When
y
ou
do
this,
multiply-by-seven
will
app
ear
in
the
e 
ho
area.
(What
this
means
is
that
when
a
fun tion
denition
is
ev
aluated,

32
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
the
v
alue
it
returns
is
the
name
of
the
dened
fun tion.)
A
t
the
same
time,
this
a tion
installs
the
fun tion
denition.
(defun
multiply-by-seven
(number)
"Multiply
NUMBER
by
seven."
(*
7
number))
By
ev
aluating
this
defun,
y
ou
ha
v
e
just
installed
multiply-by-seven
in
Ema s.
The
fun tion
is
no
w
just
as
m
u 
h
a
part
of
Ema s
as
forward-
word
or
an
y
other
editing
fun tion
y
ou
use.
(multiply-by-seven
will
sta
y
installed
un
til
y
ou
quit
Ema s.
T
o
reload
 o
de
automati ally
whenev
er
y
ou
start
Ema s,
see
Se tion
3.5,
\Installing
Co
de
P
ermanen
tly",
page
36.)
Y
ou
 an
see
the
ee t
of
installing
multiply-by-seven
b
y
ev
aluating
the
follo
wing
sample.
Pla e
the
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e.
The
n
um
b
er
21
will
app
ear
in
the
e 
ho
area.
(multiply-by-seven
3)
If
y
ou
wish,
y
ou
 an
read
the
do
 umen
tation
for
the
fun tion
b
y
t
yping
C-h
f
(des ribe-fun tion)
and
then
the
name
of
the
fun tion,
multiply-
by-seven.
When
y
ou
do
this,
a
`*Help*'
windo
w
will
app
ear
on
y
our
s reen
that
sa
ys:
multiply-by-seven:
Multiply
NUMBER
by
seven.
(T
o
return
to
a
single
windo
w
on
y
our
s reen,
t
yp
e
C-x
1.)
3.2.1
Change
a
F
un tion
Denition
If
y
ou
w
an
t
to
 
hange
the
 o
de
in
multiply-by-seven,
just
rewrite
it.
T
o
install
the
new
v
ersion
in
pla e
of
the
old
one,
ev
aluate
the
fun tion
denition
again.
This
is
ho
w
y
ou
mo
dify
 o
de
in
Ema s.
It
is
v
ery
simple.
As
an
example,
y
ou
 an
 
hange
the
multiply-by-seven
fun tion
to
add
the
n
um
b
er
to
itself
sev
en
times
instead
of
m
ultiplying
the
n
um
b
er
b
y
sev
en.
It
pro
du es
the
same
answ
er,
but
b
y
a
dieren
t
path.
A
t
the
same
time,
w
e
will
add
a
 ommen
t
to
the
 o
de;
a
 ommen
t
is
text
that
the
Lisp
in
terpreter
ignores,
but
that
a
h
uman
reader
ma
y
nd
useful
or
enligh
tening.
The
 ommen
t
is
that
this
is
the
\se ond
v
ersion".
(defun
multiply-by-seven
(number)
;
Se ond
v
ersion.
"Multiply
NUMBER
by
seven."
(+
number
number
number
number
number
number
number))
The
 ommen
t
follo
ws
a
semi olon,
`;'.
In
Lisp,
ev
erything
on
a
line
that
follo
ws
a
semi olon
is
a
 ommen
t.
The
end
of
the
line
is
the
end
of
the
 ommen
t.
T
o
stret 
h
a
 ommen
t
o
v
er
t
w
o
or
more
lines,
b
egin
ea 
h
line
with
a
semi olon.
See
Se tion
16.3,
\Beginning
a
`.ema s'
File",
page
216,
and
se tion
\Commen
ts"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
 ommen
ts.

Mak
e
a
F
un tion
In
tera tiv
e
33
Y
ou
 an
install
this
v
ersion
of
the
multiply-by-seven
fun tion
b
y
ev
al-
uating
it
in
the
same
w
a
y
y
ou
ev
aluated
the
rst
fun tion:
pla e
the
 ursor
after
the
last
paren
thesis
and
t
yp
e
C-x
C-e.
In
summary
,
this
is
ho
w
y
ou
write
 o
de
in
Ema s
Lisp:
y
ou
write
a
fun tion;
install
it;
test
it;
and
then
mak
e
xes
or
enhan emen
ts
and
install
it
again.
3.3
Mak
e
a
F
un tion
In
tera tiv
e
Y
ou
mak
e
a
fun tion
in
tera tiv
e
b
y
pla ing
a
list
that
b
egins
with
the
sp
e ial
form
intera tive
immediately
after
the
do
 umen
tation.
A
user
 an
in
v
ok
e
an
in
tera tiv
e
fun tion
b
y
t
yping
M-x
and
then
the
name
of
the
fun tion;
or
b
y
t
yping
the
k
eys
to
whi 
h
it
is
b
ound,
for
example,
b
y
t
yping
C-n
for
next-line
or
C-x
h
for
mark-whole-buffer.
In
terestingly
,
when
y
ou
 all
an
in
tera tiv
e
fun tion
in
tera tiv
ely
,
the
v
alue
returned
is
not
automati ally
displa
y
ed
in
the
e 
ho
area.
This
is
b
e ause
y
ou
often
 all
an
in
tera tiv
e
fun tion
for
its
side
ee ts,
su 
h
as
mo
ving
forw
ard
b
y
a
w
ord
or
line,
and
not
for
the
v
alue
returned.
If
the
returned
v
alue
w
ere
displa
y
ed
in
the
e 
ho
area
ea 
h
time
y
ou
t
yp
ed
a
k
ey
,
it
w
ould
b
e
v
ery
distra ting.
Both
the
use
of
the
sp
e ial
form
intera tive
and
one
w
a
y
to
displa
y
a
v
alue
in
the
e 
ho
area
 an
b
e
illustrated
b
y
 reating
an
in
tera tiv
e
v
ersion
of
multiply-by-seven.
Here
is
the
 o
de:
(defun
multiply-by-seven
(number)
;
In
tera tiv
e
v
ersion.
"Multiply
NUMBER
by
seven."
(intera tive
"p")
(message
"The
result
is
%d"
(*
7
number)))
Y
ou
 an
install
this
 o
de
b
y
pla ing
y
our
 ursor
after
it
and
t
yping
C-x
C-e.
The
name
of
the
fun tion
will
app
ear
in
y
our
e 
ho
area.
Then,
y
ou
 an
use
this
 o
de
b
y
t
yping
C-u
and
a
n
um
b
er
and
then
t
yping
M-x
multiply-by-
seven
and
pressing
h
RET
i
.
The
phrase
`The
result
is
...'
follo
w
ed
b
y
the
pro
du t
will
app
ear
in
the
e 
ho
area.
Sp
eaking
more
generally
,
y
ou
in
v
ok
e
a
fun tion
lik
e
this
in
either
of
t
w
o
w
a
ys:
1.
By
t
yping
a
prex
argumen
t
that
 on
tains
the
n
um
b
er
to
b
e
passed,
and
then
t
yping
M-x
and
the
name
of
the
fun tion,
as
with
C-u
3
M-x
forward-senten e;
or,
2.
By
t
yping
whatev
er
k
ey
or
k
ey 
hord
the
fun tion
is
b
ound
to,
as
with
C-u
3
M-e.
Both
the
examples
just
men
tioned
w
ork
iden
ti ally
to
mo
v
e
p
oin
t
forw
ard
three
sen
ten es.
(Sin e
multiply-by-seven
is
not
b
ound
to
a
k
ey
,
it
 ould
not
b
e
used
as
an
example
of
k
ey
binding.)

34
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
(See
Se tion
16.7,
\Some
Keybindings",
page
220,
to
learn
ho
w
to
bind
a
 ommand
to
a
k
ey
.)
A
prex
argumen
t
is
passed
to
an
in
tera tiv
e
fun tion
b
y
t
yping
the
h
MET
A
i
k
ey
follo
w
ed
b
y
a
n
um
b
er,
for
example,
M-3
M-e,
or
b
y
t
yping
C-
u
and
then
a
n
um
b
er,
for
example,
C-u
3
M-e
(if
y
ou
t
yp
e
C-u
without
a
n
um
b
er,
it
defaults
to
4).
3.3.1
An
In
tera tiv
e
multiply-by-seven
Let's
lo
ok
at
the
use
of
the
sp
e ial
form
intera tive
and
then
at
the
fun tion
message
in
the
in
tera tiv
e
v
ersion
of
multiply-by-seven.
Y
ou
will
re all
that
the
fun tion
denition
lo
oks
lik
e
this:
(defun
multiply-by-seven
(number)
;
In
tera tiv
e
v
ersion.
"Multiply
NUMBER
by
seven."
(intera tive
"p")
(message
"The
result
is
%d"
(*
7
number)))
In
this
fun tion,
the
expression,
(intera tive
"p"),
is
a
list
of
t
w
o
ele-
men
ts.
The
"p"
tells
Ema s
to
pass
the
prex
argumen
t
to
the
fun tion
and
use
its
v
alue
for
the
argumen
t
of
the
fun tion.
The
argumen
t
will
b
e
a
n
um
b
er.
This
means
that
the
sym
b
ol
number
will
b
e
b
ound
to
a
n
um
b
er
in
the
line:
(message
"The
result
is
%d"
(*
7
number))
F
or
example,
if
y
our
prex
argumen
t
is
5,
the
Lisp
in
terpreter
will
ev
aluate
the
line
as
if
it
w
ere:
(message
"The
result
is
%d"
(*
7
5))
(If
y
ou
are
reading
this
in
GNU
Ema s,
y
ou
 an
ev
aluate
this
expression
y
ourself.)
First,
the
in
terpreter
will
ev
aluate
the
inner
list,
whi 
h
is
(*
7
5).
This
returns
a
v
alue
of
35.
Next,
it
will
ev
aluate
the
outer
list,
passing
the
v
alues
of
the
se ond
and
subsequen
t
elemen
ts
of
the
list
to
the
fun tion
message.
As
w
e
ha
v
e
seen,
message
is
an
Ema s
Lisp
fun tion
esp
e ially
designed
for
sending
a
one
line
message
to
a
user.
(See
Se tion
1.8.5,
\The
message
fun tion",
page
16.)
In
summary
,
the
message
fun tion
prin
ts
its
rst
argu-
men
t
in
the
e 
ho
area
as
is,
ex ept
for
o
  urren es
of
`%d',
`%s',
or
`% '.
When
it
sees
one
of
these
 on
trol
sequen es,
the
fun tion
lo
oks
to
the
se ond
and
subsequen
t
argumen
ts
and
prin
ts
the
v
alue
of
the
argumen
t
in
the
lo
 ation
in
the
string
where
the
 on
trol
sequen e
is
lo
 ated.
In
the
in
tera tiv
e
multiply-by-seven
fun tion,
the
 on
trol
string
is
`%d',
whi 
h
requires
a
n
um
b
er,
and
the
v
alue
returned
b
y
ev
aluating
(*
7
5)
is
the
n
um
b
er
35.
Consequen
tly
,
the
n
um
b
er
35
is
prin
ted
in
pla e
of
the
`%d'
and
the
message
is
`The
result
is
35'.
(Note
that
when
y
ou
 all
the
fun tion
multiply-by-seven,
the
message
is
prin
ted
without
quotes,
but
when
y
ou
 all
message,
the
text
is
prin
ted
in
double
quotes.
This
is
b
e ause
the
v
alue
returned
b
y
message
is
what

Dieren
t
Options
for
intera tive
35
app
ears
in
the
e 
ho
area
when
y
ou
ev
aluate
an
expression
whose
rst
elemen
t
is
message;
but
when
em
b
edded
in
a
fun tion,
message
prin
ts
the
text
as
a
side
ee t
without
quotes.)
3.4
Dieren
t
Options
for
intera tive
In
the
example,
multiply-by-seven
used
"p"
as
the
argumen
t
to
intera tive.
This
argumen
t
told
Ema s
to
in
terpret
y
our
t
yping
either
C-u
follo
w
ed
b
y
a
n
um
b
er
or
h
MET
A
i
follo
w
ed
b
y
a
n
um
b
er
as
a
 ommand
to
pass
that
n
um
b
er
to
the
fun tion
as
its
argumen
t.
Ema s
has
more
than
t
w
en
t
y
 
hara ters
predened
for
use
with
intera tive.
In
almost
ev
ery
 ase,
one
of
these
options
will
enable
y
ou
to
pass
the
righ
t
information
in-
tera tiv
ely
to
a
fun tion.
(See
se tion
\Co
de
Chara ters
for
intera tive"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
F
or
example,
the
 
hara ter
`r'
 auses
Ema s
to
pass
the
b
eginning
and
end
of
the
region
(the
 urren
t
v
alues
of
p
oin
t
and
mark)
to
the
fun tion
as
t
w
o
separate
argumen
ts.
It
is
used
as
follo
ws:
(intera tive
"r")
On
the
other
hand,
a
`B'
tells
Ema s
to
ask
for
the
name
of
a
buer
that
will
b
e
passed
to
the
fun tion.
When
it
sees
a
`B',
Ema s
will
ask
for
the
name
b
y
prompting
the
user
in
the
minibuer,
using
a
string
that
follo
ws
the
`B',
as
in
"BAppend
to
buffer:
".
Not
only
will
Ema s
prompt
for
the
name,
but
Ema s
will
 omplete
the
name
if
y
ou
t
yp
e
enough
of
it
and
press
h
T
AB
i
.
A
fun tion
with
t
w
o
or
more
argumen
ts
 an
ha
v
e
information
passed
to
ea 
h
argumen
t
b
y
adding
parts
to
the
string
that
follo
ws
intera tive.
When
y
ou
do
this,
the
information
is
passed
to
ea 
h
argumen
t
in
the
same
order
it
is
sp
e ied
in
the
intera tive
list.
In
the
string,
ea 
h
part
is
separated
from
the
next
part
b
y
a
`\n',
whi 
h
is
a
newline.
F
or
example,
y
ou
 ould
follo
w
"BAppend
to
buffer:
"
with
a
`\n')
and
an
`r'.
This
w
ould
 ause
Ema s
to
pass
the
v
alues
of
p
oin
t
and
mark
to
the
fun tion
as
w
ell
as
prompt
y
ou
for
the
buer|three
argumen
ts
in
all.
In
this
 ase,
the
fun tion
denition
w
ould
lo
ok
lik
e
the
follo
wing,
where
buffer,
start,
and
end
are
the
sym
b
ols
to
whi 
h
intera tive
binds
the
buer
and
the
 urren
t
v
alues
of
the
b
eginning
and
ending
of
the
region:
(defun
name-of-fun tion
(buffer
start
end)
"do
 umen
tation...
"
(intera tive
"BAppend
to
buffer:
\nr")
b
o
dy-of-fun tion...
)
(The
spa e
after
the
 olon
in
the
prompt
mak
es
it
lo
ok
b
etter
when
y
ou
are
prompted.
The
append-to-buffer
fun tion
lo
oks
exa tly
lik
e
this.
See
Se tion
4.4,
\The
Denition
of
append-to-buffer",
page
56.)

36
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
If
a
fun tion
do
es
not
ha
v
e
argumen
ts,
then
intera tive
do
es
not
require
an
y
.
Su 
h
a
fun tion
 on
tains
the
simple
expression
(intera tive).
The
mark-whole-buffer
fun tion
is
lik
e
this.
Alternativ
ely
,
if
the
sp
e ial
letter- o
des
are
not
righ
t
for
y
our
appli ation,
y
ou
 an
pass
y
our
o
wn
argumen
ts
to
intera tive
as
a
list.
See
se tion
\Using
Intera tive"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
information
ab
out
this
adv
an ed
te 
hnique.
3.5
Install
Co
de
P
ermanen
tly
When
y
ou
install
a
fun tion
denition
b
y
ev
aluating
it,
it
will
sta
y
in-
stalled
un
til
y
ou
quit
Ema s.
The
next
time
y
ou
start
a
new
session
of
Ema s,
the
fun tion
will
not
b
e
installed
unless
y
ou
ev
aluate
the
fun tion
denition
again.
A
t
some
p
oin
t,
y
ou
ma
y
w
an
t
to
ha
v
e
 o
de
installed
automati ally
when-
ev
er
y
ou
start
a
new
session
of
Ema s.
There
are
sev
eral
w
a
ys
of
doing
this:

If
y
ou
ha
v
e
 o
de
that
is
just
for
y
ourself,
y
ou
 an
put
the
 o
de
for
the
fun tion
denition
in
y
our
`.ema s'
initialization
le.
When
y
ou
start
Ema s,
y
our
`.ema s'
le
is
automati ally
ev
aluated
and
all
the
fun tion
denitions
within
it
are
installed.
See
Chapter
16,
\Y
our
`.ema s'
File",
page
213.

Alternativ
ely
,
y
ou
 an
put
the
fun tion
denitions
that
y
ou
w
an
t
in-
stalled
in
one
or
more
les
of
their
o
wn
and
use
the
load
fun tion
to
 ause
Ema s
to
ev
aluate
and
thereb
y
install
ea 
h
of
the
fun tions
in
the
les.
See
Se tion
16.9,
\Loading
Files",
page
222.

On
the
other
hand,
if
y
ou
ha
v
e
 o
de
that
y
our
whole
site
will
use,
it
is
usual
to
put
it
in
a
le
 alled
`site-init.el'
that
is
loaded
when
Ema s
is
built.
This
mak
es
the
 o
de
a
v
ailable
to
ev
ery
one
who
uses
y
our
ma 
hine.
(See
the
`INSTALL'
le
that
is
part
of
the
Ema s
distribution.)
Finally
,
if
y
ou
ha
v
e
 o
de
that
ev
ery
one
who
uses
Ema s
ma
y
w
an
t,
y
ou
 an
p
ost
it
on
a
 omputer
net
w
ork
or
send
a
 op
y
to
the
F
ree
Soft
w
are
F
oun-
dation.
(When
y
ou
do
this,
please
li ense
the
 o
de
and
its
do
 umen
tation
under
a
li ense
that
p
ermits
other
p
eople
to
run,
 op
y
,
study
,
mo
dify
,
and
redistribute
the
 o
de
and
whi 
h
prote ts
y
ou
from
ha
ving
y
our
w
ork
tak
en
from
y
ou.)
If
y
ou
send
a
 op
y
of
y
our
 o
de
to
the
F
ree
Soft
w
are
F
oundation,
and
prop
erly
prote t
y
ourself
and
others,
it
ma
y
b
e
in luded
in
the
next
release
of
Ema s.
In
large
part,
this
is
ho
w
Ema s
has
gro
wn
o
v
er
the
past
y
ears,
b
y
donations.
3.6
let
The
let
expression
is
a
sp
e ial
form
in
Lisp
that
y
ou
will
need
to
use
in
most
fun tion
denitions.

The
P
arts
of
a
let
Expression
37
let
is
used
to
atta 
h
or
bind
a
sym
b
ol
to
a
v
alue
in
su 
h
a
w
a
y
that
the
Lisp
in
terpreter
will
not
 onfuse
the
v
ariable
with
a
v
ariable
of
the
same
name
that
is
not
part
of
the
fun tion.
T
o
understand
wh
y
the
let
sp
e ial
form
is
ne essary
,
 onsider
the
situa-
tion
in
whi 
h
y
ou
o
wn
a
home
that
y
ou
generally
refer
to
as
`the
house',
as
in
the
sen
ten e,
\The
house
needs
pain
ting."
If
y
ou
are
visiting
a
friend
and
y
our
host
refers
to
`the
house',
he
is
lik
ely
to
b
e
referring
to
his
house,
not
y
ours,
that
is,
to
a
dieren
t
house.
If
y
our
friend
is
referring
to
his
house
and
y
ou
think
he
is
referring
to
y
our
house,
y
ou
ma
y
b
e
in
for
some
 onfusion.
The
same
thing
 ould
happ
en
in
Lisp
if
a
v
ariable
that
is
used
inside
of
one
fun tion
has
the
same
name
as
a
v
ariable
that
is
used
inside
of
another
fun tion,
and
the
t
w
o
are
not
in
tended
to
refer
to
the
same
v
alue.
The
let
sp
e ial
form
prev
en
ts
this
kind
of
 onfusion.
The
let
sp
e ial
form
prev
en
ts
 onfusion.
let
 reates
a
name
for
a
lo
 al
v
ariable
that
o
v
ershado
ws
an
y
use
of
the
same
name
outside
the
let
ex-
pression.
This
is
lik
e
understanding
that
whenev
er
y
our
host
refers
to
`the
house',
he
means
his
house,
not
y
ours.
(Sym
b
ols
used
in
argumen
t
lists
w
ork
the
same
w
a
y
.
See
Se tion
3.1,
\The
defun
Sp
e ial
F
orm",
page
29.)
Lo
 al
v
ariables
 reated
b
y
a
let
expression
retain
their
v
alue
only
within
the
let
expression
itself
(and
within
expressions
 alled
within
the
let
ex-
pression);
the
lo
 al
v
ariables
ha
v
e
no
ee t
outside
the
let
expression.
Another
w
a
y
to
think
ab
out
let
is
that
it
is
lik
e
a
setq
that
is
temp
orary
and
lo
 al.
The
v
alues
set
b
y
let
are
automati ally
undone
when
the
let
is
nished.
The
setting
only
ee ts
expressions
that
are
inside
the
b
ounds
of
the
let
expression.
In
 omputer
s ien e
jargon,
w
e
w
ould
sa
y
\the
binding
of
a
sym
b
ol
is
visible
only
in
fun tions
 alled
in
the
let
form;
in
Ema s
Lisp,
s oping
is
dynami ,
not
lexi al."
let
 an
 reate
more
than
one
v
ariable
at
on e.
Also,
let
giv
es
ea 
h
v
ariable
it
 reates
an
initial
v
alue,
either
a
v
alue
sp
e ied
b
y
y
ou,
or
nil.
(In
the
jargon,
this
is
 alled
`binding
the
v
ariable
to
the
v
alue'.)
After
let
has
 reated
and
b
ound
the
v
ariables,
it
exe utes
the
 o
de
in
the
b
o
dy
of
the
let,
and
returns
the
v
alue
of
the
last
expression
in
the
b
o
dy
,
as
the
v
alue
of
the
whole
let
expression.
(`Exe ute'
is
a
jargon
term
that
means
to
ev
aluate
a
list;
it
 omes
from
the
use
of
the
w
ord
meaning
`to
giv
e
pra ti al
ee t
to'
(Oxford
English
Di tionary
).
Sin e
y
ou
ev
aluate
an
expression
to
p
erform
an
a tion,
`exe ute'
has
ev
olv
ed
as
a
synon
ym
to
`ev
aluate'.)
3.6.1
The
P
arts
of
a
let
Expression
A
let
expression
is
a
list
of
three
parts.
The
rst
part
is
the
sym
b
ol
let.
The
se ond
part
is
a
list,
 alled
a
v
arlist,
ea 
h
elemen
t
of
whi 
h
is
either
a
sym
b
ol
b
y
itself
or
a
t
w
o-elemen
t
list,
the
rst
elemen
t
of
whi 
h
is
a
sym
b
ol.
The
third
part
of
the
let
expression
is
the
b
o
dy
of
the
let.
The
b
o
dy
usually
 onsists
of
one
or
more
lists.

38
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
A
template
for
a
let
expression
lo
oks
lik
e
this:
(let
v
arlist
b
o
dy
...
)
The
sym
b
ols
in
the
v
arlist
are
the
v
ariables
that
are
giv
en
initial
v
alues
b
y
the
let
sp
e ial
form.
Sym
b
ols
b
y
themselv
es
are
giv
en
the
initial
v
alue
of
nil;
and
ea 
h
sym
b
ol
that
is
the
rst
elemen
t
of
a
t
w
o-elemen
t
list
is
b
ound
to
the
v
alue
that
is
returned
when
the
Lisp
in
terpreter
ev
aluates
the
se ond
elemen
t.
Th
us,
a
v
arlist
migh
t
lo
ok
lik
e
this:
(thread
(needles
3)).
In
this
 ase,
in
a
let
expression,
Ema s
binds
the
sym
b
ol
thread
to
an
initial
v
alue
of
nil,
and
binds
the
sym
b
ol
needles
to
an
initial
v
alue
of
3.
When
y
ou
write
a
let
expression,
what
y
ou
do
is
put
the
appropriate
expressions
in
the
slots
of
the
let
expression
template.
If
the
v
arlist
is
 omp
osed
of
t
w
o-elemen
t
lists,
as
is
often
the
 ase,
the
template
for
the
let
expression
lo
oks
lik
e
this:
(let
((v
ariable
v
alue
)
(v
ariable
v
alue
)
...
)
b
o
dy
...
)
3.6.2
Sample
let
Expression
The
follo
wing
expression
 reates
and
giv
es
initial
v
alues
to
the
t
w
o
v
ari-
ables
zebra
and
tiger.
The
b
o
dy
of
the
let
expression
is
a
list
whi 
h
 alls
the
message
fun tion.
(let
((zebra
'stripes)
(tiger
'fier e))
(message
"One
kind
of
animal
has
%s
and
another
is
%s."
zebra
tiger))
Here,
the
v
arlist
is
((zebra
'stripes)
(tiger
'fier e)).
The
t
w
o
v
ariables
are
zebra
and
tiger.
Ea 
h
v
ariable
is
the
rst
elemen
t
of
a
t
w
o-elemen
t
list
and
ea 
h
v
alue
is
the
se ond
elemen
t
of
its
t
w
o-elemen
t
list.
In
the
v
arlist,
Ema s
binds
the
v
ariable
zebra
to
the
v
alue
stripes,
and
binds
the
v
ariable
tiger
to
the
v
alue
fier e.
In
this
example,
b
oth
v
alues
are
sym
b
ols
pre eded
b
y
a
quote.
The
v
alues
 ould
just
as
w
ell
ha
v
e
b
een
another
list
or
a
string.
The
b
o
dy
of
the
let
follo
ws
after
the
list
holding
the
v
ariables.
In
this
example,
the
b
o
dy
is
a
list
that
uses
the
message
fun tion
to
prin
t
a
string
in
the
e 
ho
area.

The
if
Sp
e ial
F
orm
39
Y
ou
ma
y
ev
aluate
the
example
in
the
usual
fashion,
b
y
pla ing
the
 ur-
sor
after
the
last
paren
thesis
and
t
yping
C-x
C-e.
When
y
ou
do
this,
the
follo
wing
will
app
ear
in
the
e 
ho
area:
"One
kind
of
animal
has
stripes
and
another
is
fier e."
As
w
e
ha
v
e
seen
b
efore,
the
message
fun tion
prin
ts
its
rst
argumen
t,
ex ept
for
`%s'.
In
this
example,
the
v
alue
of
the
v
ariable
zebra
is
prin
ted
at
the
lo
 ation
of
the
rst
`%s'
and
the
v
alue
of
the
v
ariable
tiger
is
prin
ted
at
the
lo
 ation
of
the
se ond
`%s'.
3.6.3
Uninitialized
V
ariables
in
a
let
Statemen
t
If
y
ou
do
not
bind
the
v
ariables
in
a
let
statemen
t
to
sp
e i 
initial
v
alues,
they
will
automati ally
b
e
b
ound
to
an
initial
v
alue
of
nil,
as
in
the
follo
wing
expression:
(let
((bir h
3)
pine
fir
(oak
'some))
(message
"Here
are
%d
variables
with
%s,
%s,
and
%s
value."
bir h
pine
fir
oak))
Here,
the
v
arlist
is
((bir h
3)
pine
fir
(oak
'some)).
If
y
ou
ev
aluate
this
expression
in
the
usual
w
a
y
,
the
follo
wing
will
app
ear
in
y
our
e 
ho
area:
"Here
are
3
variables
with
nil,
nil,
and
some
value."
In
this
example,
Ema s
binds
the
sym
b
ol
bir h
to
the
n
um
b
er
3,
binds
the
sym
b
ols
pine
and
fir
to
nil,
and
binds
the
sym
b
ol
oak
to
the
v
alue
some.
Note
that
in
the
rst
part
of
the
let,
the
v
ariables
pine
and
fir
stand
alone
as
atoms
that
are
not
surrounded
b
y
paren
theses;
this
is
b
e ause
they
are
b
eing
b
ound
to
nil,
the
empt
y
list.
But
oak
is
b
ound
to
some
and
so
is
a
part
of
the
list
(oak
'some).
Similarly
,
bir h
is
b
ound
to
the
n
um
b
er
3
and
so
is
in
a
list
with
that
n
um
b
er.
(Sin e
a
n
um
b
er
ev
aluates
to
itself,
the
n
um
b
er
do
es
not
need
to
b
e
quoted.
Also,
the
n
um
b
er
is
prin
ted
in
the
message
using
a
`%d'
rather
than
a
`%s'.)
The
four
v
ariables
as
a
group
are
put
in
to
a
list
to
delimit
them
from
the
b
o
dy
of
the
let.
3.7
The
if
Sp
e ial
F
orm
A
third
sp
e ial
form,
in
addition
to
defun
and
let,
is
the
 onditional
if.
This
form
is
used
to
instru t
the
 omputer
to
mak
e
de isions.
Y
ou
 an
write
fun tion
denitions
without
using
if,
but
it
is
used
often
enough,
and
is
imp
ortan
t
enough,
to
b
e
in luded
here.
It
is
used,
for
example,
in
the
 o
de
for
the
fun tion
beginning-of-buffer.

40
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
The
basi 
idea
b
ehind
an
if,
is
that
\if
a
test
is
true,
then
an
expression
is
ev
aluated."
If
the
test
is
not
true,
the
expression
is
not
ev
aluated.
F
or
example,
y
ou
migh
t
mak
e
a
de ision
su 
h
as,
\if
it
is
w
arm
and
sunn
y
,
then
go
to
the
b
ea 
h!"
An
if
expression
written
in
Lisp
do
es
not
use
the
w
ord
`then';
the
test
and
the
a tion
are
the
se ond
and
third
elemen
ts
of
the
list
whose
rst
elemen
t
is
if.
Nonetheless,
the
test
part
of
an
if
expression
is
often
 alled
the
if-part
and
the
se ond
argumen
t
is
often
 alled
the
then-part.
Also,
when
an
if
expression
is
written,
the
true-or-false-test
is
usually
written
on
the
same
line
as
the
sym
b
ol
if,
but
the
a tion
to
 arry
out
if
the
test
is
true,
the
\then-part",
is
written
on
the
se ond
and
subsequen
t
lines.
This
mak
es
the
if
expression
easier
to
read.
(if
true-or-false-test
a tion-to- arry-out-if-test-is-true
)
The
true-or-false-test
will
b
e
an
expression
that
is
ev
aluated
b
y
the
Lisp
in
terpreter.
Here
is
an
example
that
y
ou
 an
ev
aluate
in
the
usual
manner.
The
test
is
whether
the
n
um
b
er
5
is
greater
than
the
n
um
b
er
4.
Sin e
it
is,
the
message
`5
is
greater
than
4!'
will
b
e
prin
ted.
(if
(>
5
4)
;
if-part
(message
"5
is
greater
than
4!"))
;
then-part
(The
fun tion
>
tests
whether
its
rst
argumen
t
is
greater
than
its
se ond
argumen
t
and
returns
true
if
it
is.)
Of
 ourse,
in
a tual
use,
the
test
in
an
if
expression
will
not
b
e
xed
for
all
time
as
it
is
b
y
the
expression
(>
5
4).
Instead,
at
least
one
of
the
v
ariables
used
in
the
test
will
b
e
b
ound
to
a
v
alue
that
is
not
kno
wn
ahead
of
time.
(If
the
v
alue
w
ere
kno
wn
ahead
of
time,
w
e
w
ould
not
need
to
run
the
test!)
F
or
example,
the
v
alue
ma
y
b
e
b
ound
to
an
argumen
t
of
a
fun tion
de-
nition.
In
the
follo
wing
fun tion
denition,
the
 
hara ter
of
the
animal
is
a
v
alue
that
is
passed
to
the
fun tion.
If
the
v
alue
b
ound
to
 hara teristi 
is
fier e,
then
the
message,
`It's
a
tiger!'
will
b
e
prin
ted;
otherwise,
nil
will
b
e
returned.
(defun
type-of-animal
( hara teristi )
"Print
message
in
e ho
area
depending
on
CHARACTERISTIC.
If
the
CHARACTERISTIC
is
the
symbol
`fier e',
then
warn
of
a
tiger."
(if
(equal
 hara teristi 
'fier e)
(message
"It's
a
tiger!")))

The
type-of-animal
F
un tion
in
Detail
41
If
y
ou
are
reading
this
inside
of
GNU
Ema s,
y
ou
 an
ev
aluate
the
fun tion
denition
in
the
usual
w
a
y
to
install
it
in
Ema s,
and
then
y
ou
 an
ev
aluate
the
follo
wing
t
w
o
expressions
to
see
the
results:
(type-of-animal
'fier e)
(type-of-animal
'zebra)
When
y
ou
ev
aluate
(type-of-animal
'fier e),
y
ou
will
see
the
follo
wing
message
prin
ted
in
the
e 
ho
area:
"It's
a
tiger!";
and
when
y
ou
ev
aluate
(type-of-animal
'zebra)
y
ou
will
see
nil
prin
ted
in
the
e 
ho
area.
3.7.1
The
type-of-animal
F
un tion
in
Detail
Let's
lo
ok
at
the
type-of-animal
fun tion
in
detail.
The
fun tion
denition
for
type-of-animal
w
as
written
b
y
lling
the
slots
of
t
w
o
templates,
one
for
a
fun tion
denition
as
a
whole,
and
a
se ond
for
an
if
expression.
The
template
for
ev
ery
fun tion
that
is
not
in
tera tiv
e
is:
(defun
name-of-fun tion
(argumen
t-list
)
"do
 umen
tation...
"
b
o
dy
...
)
The
parts
of
the
fun tion
that
mat 
h
this
template
lo
ok
lik
e
this:
(defun
type-of-animal
( hara teristi )
"Print
message
in
e ho
area
depending
on
CHARACTERISTIC.
If
the
CHARACTERISTIC
is
the
symbol
`fier e',
then
warn
of
a
tiger."
b
o
dy:
the
if
expression)
The
name
of
fun tion
is
type-of-animal;
it
is
passed
the
v
alue
of
one
argumen
t.
The
argumen
t
list
is
follo
w
ed
b
y
a
m
ulti-line
do
 umen
tation
string.
The
do
 umen
tation
string
is
in luded
in
the
example
b
e ause
it
is
a
go
o
d
habit
to
write
do
 umen
tation
string
for
ev
ery
fun tion
denition.
The
b
o
dy
of
the
fun tion
denition
 onsists
of
the
if
expression.
The
template
for
an
if
expression
lo
oks
lik
e
this:
(if
true-or-false-test
a tion-to- arry-out-if-the-test-returns-true
)
In
the
type-of-animal
fun tion,
the
 o
de
for
the
if
lo
oks
lik
e
this:
(if
(equal
 hara teristi 
'fier e)
(message
"It's
a
tiger!")))
Here,
the
true-or-false-test
is
the
expression:
(equal
 hara teristi 
'fier e)
In
Lisp,
equal
is
a
fun tion
that
determines
whether
its
rst
argumen
t
is
equal
to
its
se ond
argumen
t.
The
se ond
argumen
t
is
the
quoted
sym
b
ol

42
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
'fier e
and
the
rst
argumen
t
is
the
v
alue
of
the
sym
b
ol
 hara teristi |
in
other
w
ords,
the
argumen
t
passed
to
this
fun tion.
In
the
rst
exer ise
of
type-of-animal,
the
argumen
t
fier e
is
passed
to
type-of-animal.
Sin e
fier e
is
equal
to
fier e,
the
expression,
(equal
 hara teristi 
'fier e),
returns
a
v
alue
of
true.
When
this
happ
ens,
the
if
ev
aluates
the
se ond
argumen
t
or
then-part
of
the
if:
(message
"It's
tiger!").
On
the
other
hand,
in
the
se ond
exer ise
of
type-of-animal,
the
argu-
men
t
zebra
is
passed
to
type-of-animal.
zebra
is
not
equal
to
fier e,
so
the
then-part
is
not
ev
aluated
and
nil
is
returned
b
y
the
if
expression.
3.8
If{then{else
Expressions
An
if
expression
ma
y
ha
v
e
an
optional
third
argumen
t,
 alled
the
else-
part,
for
the
 ase
when
the
true-or-false-test
returns
false.
When
this
hap-
p
ens,
the
se ond
argumen
t
or
then-part
of
the
o
v
erall
if
expression
is
not
ev
aluated,
but
the
third
or
else-part
is
ev
aluated.
Y
ou
migh
t
think
of
this
as
the
 loudy
da
y
alternativ
e
for
the
de ision
`if
it
is
w
arm
and
sunn
y
,
then
go
to
the
b
ea 
h,
else
read
a
b
o
ok!".
The
w
ord
\else"
is
not
written
in
the
Lisp
 o
de;
the
else-part
of
an
if
expression
 omes
after
the
then-part.
In
the
written
Lisp,
the
else-part
is
usually
written
to
start
on
a
line
of
its
o
wn
and
is
inden
ted
less
than
the
then-part:
(if
true-or-false-test
a tion-to- arry-out-if-the-test-returns-true
a tion-to- arry-out-if-the-test-returns-false
)
F
or
example,
the
follo
wing
if
expression
prin
ts
the
message
`4
is
not
greater
than
5!'
when
y
ou
ev
aluate
it
in
the
usual
w
a
y:
(if
(>
4
5)
;
if-part
(message
"5
is
greater
than
4!")
;
then-part
(message
"4
is
not
greater
than
5!"))
;
else-part
Note
that
the
dieren
t
lev
els
of
inden
tation
mak
e
it
easy
to
distinguish
the
then-part
from
the
else-part.
(GNU
Ema s
has
sev
eral
 ommands
that
au-
tomati ally
inden
t
if
expressions
 orre tly
.
See
Se tion
1.1.3,
\GNU
Ema s
Helps
Y
ou
T
yp
e
Lists",
page
3.)
W
e
 an
extend
the
type-of-animal
fun tion
to
in lude
an
else-part
b
y
simply
in orp
orating
an
additional
part
to
the
if
expression.

T
ruth
and
F
alseho
o
d
in
Ema s
Lisp
43
Y
ou
 an
see
the
 onsequen es
of
doing
this
if
y
ou
ev
aluate
the
follo
wing
v
ersion
of
the
type-of-animal
fun tion
denition
to
install
it
and
then
ev
aluate
the
t
w
o
subsequen
t
expressions
to
pass
dieren
t
argumen
ts
to
the
fun tion.
(defun
type-of-animal
( hara teristi )
;
Se ond
v
ersion.
"Print
message
in
e ho
area
depending
on
CHARACTERISTIC.
If
the
CHARACTERISTIC
is
the
symbol
`fier e',
then
warn
of
a
tiger;
else
say
it's
not
fier e."
(if
(equal
 hara teristi 
'fier e)
(message
"It's
a
tiger!")
(message
"It's
not
fier e!")))
(type-of-animal
'fier e)
(type-of-animal
'zebra)
When
y
ou
ev
aluate
(type-of-animal
'fier e),
y
ou
will
see
the
follo
wing
message
prin
ted
in
the
e 
ho
area:
"It's
a
tiger!";
but
when
y
ou
ev
aluate
(type-of-animal
'zebra),
y
ou
will
see
"It's
not
fier e!".
(Of
 ourse,
if
the
 
hara teristi 
w
ere
fero ious,
the
message
"It's
not
fier e!"
w
ould
b
e
prin
ted;
and
it
w
ould
b
e
misleading!
When
y
ou
write
 o
de,
y
ou
need
to
tak
e
in
to
a  oun
t
the
p
ossibilit
y
that
some
su 
h
argumen
t
will
b
e
tested
b
y
the
if
and
write
y
our
program
a  ordingly
.)
3.9
T
ruth
and
F
alseho
o
d
in
Ema s
Lisp
There
is
an
imp
ortan
t
asp
e t
to
the
truth
test
in
an
if
expression.
So
far,
w
e
ha
v
e
sp
ok
en
of
`true'
and
`false'
as
v
alues
of
predi ates
as
if
they
w
ere
new
kinds
of
Ema s
Lisp
ob
je ts.
In
fa t,
`false'
is
just
our
old
friend
nil.
An
ything
else|an
ything
at
all|is
`true'.
The
expression
that
tests
for
truth
is
in
terpreted
as
true
if
the
result
of
ev
aluating
it
is
a
v
alue
that
is
not
nil.
In
other
w
ords,
the
result
of
the
test
is
 onsidered
true
if
the
v
alue
returned
is
a
n
um
b
er
su 
h
as
47,
a
string
su 
h
as
"hello",
or
a
sym
b
ol
(other
than
nil)
su 
h
as
flowers,
or
a
list,
or
ev
en
a
buer!
Before
illustrating
a
test
for
truth,
w
e
need
an
explanation
of
nil.
In
Ema s
Lisp,
the
sym
b
ol
nil
has
t
w
o
meanings.
First,
it
means
the
empt
y
list.
Se ond,
it
means
false
and
is
the
v
alue
returned
when
a
true-or-
false-test
tests
false.
nil
 an
b
e
written
as
an
empt
y
list,
(),
or
as
nil.
As
far
as
the
Lisp
in
terpreter
is
 on erned,
()
and
nil
are
the
same.
Humans,
ho
w
ev
er,
tend
to
use
nil
for
false
and
()
for
the
empt
y
list.
In
Ema s
Lisp,
an
y
v
alue
that
is
not
nil|is
not
the
empt
y
list|is
 on-
sidered
true.
This
means
that
if
an
ev
aluation
returns
something
that
is
not

44
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
an
empt
y
list,
an
if
expression
will
test
true.
F
or
example,
if
a
n
um
b
er
is
put
in
the
slot
for
the
test,
it
will
b
e
ev
aluated
and
will
return
itself,
sin e
that
is
what
n
um
b
ers
do
when
ev
aluated.
In
this
 onditional,
the
if
expres-
sion
will
test
true.
The
expression
tests
false
only
when
nil,
an
empt
y
list,
is
returned
b
y
ev
aluating
the
expression.
Y
ou
 an
see
this
b
y
ev
aluating
the
t
w
o
expressions
in
the
follo
wing
ex-
amples.
In
the
rst
example,
the
n
um
b
er
4
is
ev
aluated
as
the
test
in
the
if
expression
and
returns
itself;
 onsequen
tly
,
the
then-part
of
the
expression
is
ev
aluated
and
returned:
`true'
app
ears
in
the
e 
ho
area.
In
the
se ond
example,
the
nil
indi ates
false;
 onsequen
tly
,
the
else-part
of
the
expression
is
ev
aluated
and
returned:
`false'
app
ears
in
the
e 
ho
area.
(if
4
'true
'false)
(if
nil
'true
'false)
In iden
tally
,
if
some
other
useful
v
alue
is
not
a
v
ailable
for
a
test
that
returns
true,
then
the
Lisp
in
terpreter
will
return
the
sym
b
ol
t
for
true.
F
or
example,
the
expression
(>
5
4)
returns
t
when
ev
aluated,
as
y
ou
 an
see
b
y
ev
aluating
it
in
the
usual
w
a
y:
(>
5
4)
On
the
other
hand,
this
fun tion
returns
nil
if
the
test
is
false.
(>
4
5)
3.10
save-ex ursion
The
save-ex ursion
fun tion
is
the
fourth
and
nal
sp
e ial
form
that
w
e
will
dis uss
in
this
 
hapter.
In
Ema s
Lisp
programs
used
for
editing,
the
save-ex ursion
fun tion
is
v
ery
 ommon.
It
sa
v
es
the
lo
 ation
of
p
oin
t
and
mark,
exe utes
the
b
o
dy
of
the
fun tion,
and
then
restores
p
oin
t
and
mark
to
their
previous
p
ositions
if
their
lo
 ations
w
ere
 
hanged.
Its
primary
purp
ose
is
to
k
eep
the
user
from
b
eing
surprised
and
disturb
ed
b
y
unexp
e ted
mo
v
emen
t
of
p
oin
t
or
mark.
Before
dis ussing
save-ex ursion,
ho
w
ev
er,
it
ma
y
b
e
useful
rst
to
review
what
p
oin
t
and
mark
are
in
GNU
Ema s.
P
oin
t
is
the
 urren
t
lo
 ation
of
the
 ursor.
Wherev
er
the
 ursor
is,
that
is
p
oin
t.
More
pre isely
,
on
terminals
where
the
 ursor
app
ears
to
b
e
on
top
of
a
 
hara ter,
p
oin
t
is
immediately
b
efore
the
 
hara ter.
In
Ema s
Lisp,
p
oin
t
is
an
in
teger.
The
rst
 
hara ter
in
a
buer
is
n
um
b
er
one,
the
se ond
is
n
um
b
er
t
w
o,
and
so
on.
The
fun tion
point
returns
the
 urren
t
p
osition
of
the
 ursor
as
a
n
um
b
er.
Ea 
h
buer
has
its
o
wn
v
alue
for
p
oin
t.

T
emplate
for
a
save-ex ursion
Expression
45
The
mark
is
another
p
osition
in
the
buer;
its
v
alue
 an
b
e
set
with
a
 ommand
su 
h
as
C-
h
SPC
i
(set-mark- ommand).
If
a
mark
has
b
een
set,
y
ou
 an
use
the
 ommand
C-x
C-x
(ex hange-point-and-mark)
to
 ause
the
 ursor
to
jump
to
the
mark
and
set
the
mark
to
b
e
the
previous
p
osition
of
p
oin
t.
In
addition,
if
y
ou
set
another
mark,
the
p
osition
of
the
previous
mark
is
sa
v
ed
in
the
mark
ring.
Man
y
mark
p
ositions
 an
b
e
sa
v
ed
this
w
a
y
.
Y
ou
 an
jump
the
 ursor
to
a
sa
v
ed
mark
b
y
t
yping
C-u
C-
h
SPC
i
one
or
more
times.
The
part
of
the
buer
b
et
w
een
p
oin
t
and
mark
is
 alled
the
region.
Nu-
merous
 ommands
w
ork
on
the
region,
in luding
 enter-region,
 ount-
lines-region,
kill-region,
and
print-region.
The
save-ex ursion
sp
e ial
form
sa
v
es
the
lo
 ations
of
p
oin
t
and
mark
and
restores
those
p
ositions
after
the
 o
de
within
the
b
o
dy
of
the
sp
e ial
form
is
ev
aluated
b
y
the
Lisp
in
terpreter.
Th
us,
if
p
oin
t
w
ere
in
the
b
eginning
of
a
pie e
of
text
and
some
 o
de
mo
v
ed
p
oin
t
to
the
end
of
the
buer,
the
save-ex ursion
w
ould
put
p
oin
t
ba 
k
to
where
it
w
as
b
efore,
after
the
expressions
in
the
b
o
dy
of
the
fun tion
w
ere
ev
aluated.
In
Ema s,
a
fun tion
frequen
tly
mo
v
es
p
oin
t
as
part
of
its
in
ternal
w
ork-
ings
ev
en
though
a
user
w
ould
not
exp
e t
this.
F
or
example,
 ount-lines-
region
mo
v
es
p
oin
t.
T
o
prev
en
t
the
user
from
b
eing
b
othered
b
y
jumps
that
are
b
oth
unexp
e ted
and
(from
the
user's
p
oin
t
of
view)
unne essary
,
save-
ex ursion
is
often
used
to
k
eep
p
oin
t
and
mark
in
the
lo
 ation
exp
e ted
b
y
the
user.
The
use
of
save-ex ursion
is
go
o
d
housek
eeping.
T
o
mak
e
sure
the
house
sta
ys
 lean,
save-ex ursion
restores
the
v
alues
of
p
oin
t
and
mark
ev
en
if
something
go
es
wrong
in
the
 o
de
inside
of
it
(or,
to
b
e
more
pre ise
and
to
use
the
prop
er
jargon,
\in
 ase
of
abnormal
exit").
This
feature
is
v
ery
helpful.
In
addition
to
re ording
the
v
alues
of
p
oin
t
and
mark,
save-ex ursion
k
eeps
tra 
k
of
the
 urren
t
buer,
and
restores
it,
to
o.
This
means
y
ou
 an
write
 o
de
that
will
 
hange
the
buer
and
ha
v
e
save-ex ursion
swit 
h
y
ou
ba 
k
to
the
original
buer.
This
is
ho
w
save-ex ursion
is
used
in
append-
to-buffer.
(See
Se tion
4.4,
\The
Denition
of
append-to-buffer",
page
56.)
3.10.1
T
emplate
for
a
save-ex ursion
Expression
The
template
for
 o
de
using
save-ex ursion
is
simple:
(save-ex ursion
b
o
dy
...
)
The
b
o
dy
of
the
fun tion
is
one
or
more
expressions
that
will
b
e
ev
aluated
in
sequen e
b
y
the
Lisp
in
terpreter.
If
there
is
more
than
one
expression
in
the
b
o
dy
,
the
v
alue
of
the
last
one
will
b
e
returned
as
the
v
alue
of
the
save-ex ursion
fun tion.
The
other
expressions
in
the
b
o
dy
are
ev
aluated
only
for
their
side
ee ts;
and
save-ex ursion
itself
is
used
only
for
its
side
ee t
(whi 
h
is
restoring
the
p
ositions
of
p
oin
t
and
mark).

46
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
In
more
detail,
the
template
for
a
save-ex ursion
expression
lo
oks
lik
e
this:
(save-ex ursion
rst-expression-in-b
o
dy
se ond-expression-in-b
o
dy
third-expression-in-b
o
dy
...
last-expression-in-b
o
dy
)
An
expression,
of
 ourse,
ma
y
b
e
a
sym
b
ol
on
its
o
wn
or
a
list.
In
Ema s
Lisp
 o
de,
a
save-ex ursion
expression
often
o
  urs
within
the
b
o
dy
of
a
let
expression.
It
lo
oks
lik
e
this:
(let
v
arlist
(save-ex ursion
b
o
dy
...
))
3.11
Review
In
the
last
few
 
hapters
w
e
ha
v
e
in
tro
du ed
a
fair
n
um
b
er
of
fun tions
and
sp
e ial
forms.
Here
they
are
des rib
ed
in
brief,
along
with
a
few
similar
fun tions
that
ha
v
e
not
b
een
men
tioned
y
et.
eval-last-sexp
Ev
aluate
the
last
sym
b
oli 
expression
b
efore
the
 urren
t
lo
 ation
of
p
oin
t.
The
v
alue
is
prin
ted
in
the
e 
ho
area
unless
the
fun tion
is
in
v
ok
ed
with
an
argumen
t;
in
that
 ase,
the
output
is
prin
ted
in
the
 urren
t
buer.
This
 ommand
is
normally
b
ound
to
C-x
C-e.
defun
Dene
fun tion.
This
sp
e ial
form
has
up
to
v
e
parts:
the
name,
a
template
for
the
argumen
ts
that
will
b
e
passed
to
the
fun tion,
do
 umen
tation,
an
optional
in
tera tiv
e
de laration,
and
the
b
o
dy
of
the
denition.
F
or
example:
(defun
ba k-to-indentation
()
"Move
point
to
first
visible
 hara ter
on
line."
(intera tive)
(beginning-of-line
1)
(skip- hars-forward
"
\t"))
intera tive
De lare
to
the
in
terpreter
that
the
fun tion
 an
b
e
used
in
tera -
tiv
ely
.
This
sp
e ial
form
ma
y
b
e
follo
w
ed
b
y
a
string
with
one
or
more
parts
that
pass
the
information
to
the
argumen
ts
of
the
fun tion,
in
sequen e.
These
parts
ma
y
also
tell
the
in
terpreter
to
prompt
for
information.
P
arts
of
the
string
are
separated
b
y
newlines,
`\n'.

Review
47
Common
 o
de
 
hara ters
are:
b
The
name
of
an
existing
buer.
f
The
name
of
an
existing
le.
p
The
n
umeri 
prex
argumen
t.
(Note
that
this
`p'
is
lo
w
er
 ase.)
r
P
oin
t
and
the
mark,
as
t
w
o
n
umeri 
argumen
ts,
smallest
rst.
This
is
the
only
 o
de
letter
that
sp
e -
ies
t
w
o
su  essiv
e
argumen
ts
rather
than
one.
See
se tion
\Co
de
Chara ters
for
`intera tive'"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
a
 omplete
list
of
 o
de
 
har-
a ters.
let
De lare
that
a
list
of
v
ariables
is
for
use
within
the
b
o
dy
of
the
let
and
giv
e
them
an
initial
v
alue,
either
nil
or
a
sp
e ied
v
alue;
then
ev
aluate
the
rest
of
the
expressions
in
the
b
o
dy
of
the
let
and
return
the
v
alue
of
the
last
one.
Inside
the
b
o
dy
of
the
let,
the
Lisp
in
terpreter
do
es
not
see
the
v
alues
of
the
v
ariables
of
the
same
names
that
are
b
ound
outside
of
the
let.
F
or
example,
(let
((foo
(buffer-name))
(bar
(buffer-size)))
(message
"This
buffer
is
%s
and
has
%d
 hara ters."
foo
bar))
save-ex ursion
Re ord
the
v
alues
of
p
oin
t
and
mark
and
the
 urren
t
buer
b
efore
ev
aluating
the
b
o
dy
of
this
sp
e ial
form.
Restore
the
v
alues
of
p
oin
t
and
mark
and
buer
afterw
ard.
F
or
example,
(message
"We
are
%d
 hara ters
into
this
buffer."
(-
(point)
(save-ex ursion
(goto- har
(point-min))
(point))))
if
Ev
aluate
the
rst
argumen
t
to
the
fun tion;
if
it
is
true,
ev
aluate
the
se ond
argumen
t;
else
ev
aluate
the
third
argumen
t,
if
there
is
one.
The
if
sp
e ial
form
is
 alled
a
 onditional.
There
are
other
 on-
ditionals
in
Ema s
Lisp,
but
if
is
p
erhaps
the
most
 ommonly
used.

48
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
F
or
example,
(if
(string-equal
(number-to-string
21)
(substring
(ema s-version)
10
12))
(message
"This
is
version
21
Ema s")
(message
"This
is
not
version
21
Ema s"))
equal
eq
T
est
whether
t
w
o
ob
je ts
are
the
same.
equal
uses
one
meaning
of
the
w
ord
`same'
and
eq
uses
another:
equal
returns
true
if
the
t
w
o
ob
je ts
ha
v
e
a
similar
stru ture
and
 on
ten
ts,
su 
h
as
t
w
o
 opies
of
the
same
b
o
ok.
On
the
other
hand,
eq,
returns
true
if
b
oth
argumen
ts
are
a tually
the
same
ob
je t.
<
>
<=
>=
The
<
fun tion
tests
whether
its
rst
argumen
t
is
smaller
than
its
se ond
argumen
t.
A
 orresp
onding
fun tion,
>,
tests
whether
the
rst
argumen
t
is
greater
than
the
se ond.
Lik
ewise,
<=
tests
whether
the
rst
argumen
t
is
less
than
or
equal
to
the
se ond
and
>=
tests
whether
the
rst
argumen
t
is
greater
than
or
equal
to
the
se ond.
In
all
 ases,
b
oth
argumen
ts
m
ust
b
e
n
um
b
ers
or
mark
ers
(mark
ers
indi ate
p
ositions
in
buers).
string<
string-lessp
string=
string-equal
The
string-lessp
fun tion
tests
whether
its
rst
argumen
t
is
smaller
than
the
se ond
argumen
t.
A
shorter,
alternativ
e
name
for
the
same
fun tion
(a
defalias)
is
string<.
The
argumen
ts
to
string-lessp
m
ust
b
e
strings
or
sym
b
ols;
the
ordering
is
lexi ographi ,
so
 ase
is
signi an
t.
The
prin
t
names
of
sym
b
ols
are
used
instead
of
the
sym
b
ols
themselv
es.
An
empt
y
string,
`""',
a
string
with
no
 
hara ters
in
it,
is
smaller
than
an
y
string
of
 
hara ters.
string-equal
pro
vides
the
 orresp
onding
test
for
equalit
y
.
Its
shorter,
alternativ
e
name
is
string=.
There
are
no
string
test
fun tions
that
 orresp
ond
to
>,
>=,
or
<=.
message
Prin
t
a
message
in
the
e 
ho
area.
The
rst
argumen
t
is
a
string
that
 an
 on
tain
`%s',
`%d',
or
`% '
to
prin
t
the
v
alue
of
argumen
ts
that
follo
w
the
string.
The
argumen
t
used
b
y
`%s'
m
ust
b
e
a
string
or
a
sym
b
ol;
the
argumen
t
used
b
y
`%d'
m
ust
b
e
a
n
um
b
er.
The
argumen
t
used
b
y
`% '
m
ust
b
e
an
as ii
 o
de
n
um
b
er;
it
will
b
e
prin
ted
as
the
 
hara ter
with
that
as i
i
 o
de.

Review
49
setq
set
The
setq
fun tion
sets
the
v
alue
of
its
rst
argumen
t
to
the
v
alue
of
the
se ond
argumen
t.
The
rst
argumen
t
is
automati-
 ally
quoted
b
y
setq.
It
do
es
the
same
for
su  eeding
pairs
of
argumen
ts.
Another
fun tion,
set,
tak
es
only
t
w
o
argumen
ts
and
ev
aluates
b
oth
of
them
b
efore
setting
the
v
alue
returned
b
y
its
rst
argumen
t
to
the
v
alue
returned
b
y
its
se ond
argumen
t.
buffer-name
Without
an
argumen
t,
return
the
name
of
the
buer,
as
a
string.
buffer-file-name
Without
an
argumen
t,
return
the
name
of
the
le
the
buer
is
visiting.
 urrent-buffer
Return
the
buer
in
whi 
h
Ema s
is
a tiv
e;
it
ma
y
not
b
e
the
buer
that
is
visible
on
the
s reen.
other-buffer
Return
the
most
re en
tly
sele ted
buer
(other
than
the
buer
passed
to
other-buffer
as
an
argumen
t
and
other
than
the
 urren
t
buer).
swit h-to-buffer
Sele t
a
buer
for
Ema s
to
b
e
a tiv
e
in
and
displa
y
it
in
the
 urren
t
windo
w
so
users
 an
lo
ok
at
it.
Usually
b
ound
to
C-x
b.
set-buffer
Swit 
h
Ema s'
atten
tion
to
a
buer
on
whi 
h
programs
will
run.
Don't
alter
what
the
windo
w
is
sho
wing.
buffer-size
Return
the
n
um
b
er
of
 
hara ters
in
the
 urren
t
buer.
point
Return
the
v
alue
of
the
 urren
t
p
osition
of
the
 ursor,
as
an
in
teger
 oun
ting
the
n
um
b
er
of
 
hara ters
from
the
b
eginning
of
the
buer.
point-min
Return
the
minim
um
p
ermissible
v
alue
of
p
oin
t
in
the
 urren
t
buer.
This
is
1,
unless
narro
wing
is
in
ee t.
point-max
Return
the
v
alue
of
the
maxim
um
p
ermissible
v
alue
of
p
oin
t
in
the
 urren
t
buer.
This
is
the
end
of
the
buer,
unless
narro
wing
is
in
ee t.

50
Chapter
3:
Ho
w
T
o
W
rite
F
un tion
Denitions
3.12
Exer ises

W
rite
a
non-in
tera tiv
e
fun tion
that
doubles
the
v
alue
of
its
argumen
t,
a
n
um
b
er.
Mak
e
that
fun tion
in
tera tiv
e.

W
rite
a
fun tion
that
tests
whether
the
 urren
t
v
alue
of
fill- olumn
is
greater
than
the
argumen
t
passed
to
the
fun tion,
and
if
so,
prin
ts
an
appropriate
message.

Finding
More
Information
51
4
A
F
ew
Buer{Related
F
un tions
In
this
 
hapter
w
e
study
in
detail
sev
eral
of
the
fun tions
used
in
GNU
Ema s.
This
is
 alled
a
\w
alk-through".
These
fun tions
are
used
as
ex-
amples
of
Lisp
 o
de,
but
are
not
imaginary
examples;
with
the
ex eption
of
the
rst,
simplied
fun tion
denition,
these
fun tions
sho
w
the
a tual
 o
de
used
in
GNU
Ema s.
Y
ou
 an
learn
a
great
deal
from
these
denitions.
The
fun tions
des rib
ed
here
are
all
related
to
buers.
Later,
w
e
will
study
other
fun tions.
4.1
Finding
More
Information
In
this
w
alk-through,
I
will
des rib
e
ea 
h
new
fun tion
as
w
e
 ome
to
it,
sometimes
in
detail
and
sometimes
briey
.
If
y
ou
are
in
terested,
y
ou
 an
get
the
full
do
 umen
tation
of
an
y
Ema s
Lisp
fun tion
at
an
y
time
b
y
t
yping
C-h
f
and
then
the
name
of
the
fun tion
(and
then
h
RET
i
).
Similarly
,
y
ou
 an
get
the
full
do
 umen
tation
for
a
v
ariable
b
y
t
yping
C-h
v
and
then
the
name
of
the
v
ariable
(and
then
h
RET
i
).
In
v
ersions
20
and
higher,
when
a
fun tion
is
written
in
Ema s
Lisp,
des ribe-fun tion
will
also
tell
y
ou
the
lo
 ation
of
the
fun tion
denition.
If
y
ou
mo
v
e
p
oin
t
o
v
er
the
le
name
and
press
the
h
RET
i
k
ey
,
whi 
h
is
this
 ase
means
help-follow
rather
than
`return'
or
`en
ter',
Ema s
will
tak
e
y
ou
dire tly
to
the
fun tion
denition.
More
generally
,
if
y
ou
w
an
t
to
see
a
fun tion
in
its
original
sour e
le,
y
ou
 an
use
the
find-tags
fun tion
to
jump
to
it.
find-tags
w
orks
with
a
wide
v
ariet
y
of
languages,
not
just
Lisp,
and
C,
and
it
w
orks
with
non-
programming
text
as
w
ell.
F
or
example,
find-tags
will
jump
to
the
v
arious
no
des
in
the
T
exinfo
sour e
le
of
this
do
 umen
t.
The
find-tags
fun tion
dep
ends
on
`tags
tables'
that
re ord
the
lo
 ations
of
the
fun tions,
v
ariables,
and
other
items
to
whi 
h
find-tags
jumps.
T
o
use
the
find-tags
 ommand,
t
yp
e
M-.
(i.e.,
t
yp
e
the
h
MET
A
i
k
ey
and
the
p
erio
d
k
ey
at
the
same
time,
or
else
t
yp
e
the
h
ESC
i
k
ey
and
then
t
yp
e
the
p
erio
d
k
ey),
and
then,
at
the
prompt,
t
yp
e
in
the
name
of
the
fun tion
whose
sour e
 o
de
y
ou
w
an
t
to
see,
su 
h
as
mark-whole-buffer,
and
then
t
yp
e
h
RET
i
.
Ema s
will
swit 
h
buers
and
displa
y
the
sour e
 o
de
for
the
fun tion
on
y
our
s reen.
T
o
swit 
h
ba 
k
to
y
our
 urren
t
buer,
t
yp
e
C-x
b
h
RET
i
.
(On
some
k
eyb
oards,
the
h
MET
A
i
k
ey
is
lab
elled
h
AL
T
i
.)
Dep
ending
on
ho
w
the
initial
default
v
alues
of
y
our
 op
y
of
Ema s
are
set,
y
ou
ma
y
also
need
to
sp
e ify
the
lo
 ation
of
y
our
`tags
table',
whi 
h
is
a
le
 alled
`TAGS'.
F
or
example,
if
y
ou
are
in
terested
in
Ema s
sour es,
the
tags
table
y
ou
will
most
lik
ely
w
an
t,
if
it
has
already
b
een
 reated
for
y
ou,
will
b
e
in
a
sub
dire tory
of
the
`/usr/lo al/share/ema s/'
dire -
tory;
th
us
y
ou
w
ould
use
the
M-x
visit-tags-table
 ommand
and
sp
e -
ify
a
pathname
su 
h
as
`/usr/lo al/share/ema s/2
1.0.
100
/lis
p/TA
GS'

52
Chapter
4:
A
F
ew
Buer{Related
F
un tions
or
`/usr/lo al/sr /ema s/lisp/
TAGS
'.
If
the
tags
table
has
not
already
b
een
 reated,
y
ou
will
ha
v
e
to
 reate
it
y
ourself.
T
o
 reate
a
`TAGS'
le
in
a
sp
e i 
dire tory
,
swit 
h
to
that
dire tory
in
Ema s
using
M-x
 d
 ommand,
or
list
the
dire tory
with
C-x
d
(dired).
Then
run
the
 ompile
 ommand,
with
etags
*.el
as
the
 ommand
to
exe-
 ute
M-x
 ompile
RET
etags
*.el
RET
F
or
more
information,
see
Se tion
12.5,
\Create
Y
our
Own
`TAGS'
File",
page
163.
After
y
ou
b
e ome
more
familiar
with
Ema s
Lisp,
y
ou
will
nd
that
y
ou
will
frequen
tly
use
find-tags
to
na
vigate
y
our
w
a
y
around
sour e
 o
de;
and
y
ou
will
 reate
y
our
o
wn
`TAGS'
tables.
In iden
tally
,
the
les
that
 on
tain
Lisp
 o
de
are
 on
v
en
tionally
 alled
libraries.
The
metaphor
is
deriv
ed
from
that
of
a
sp
e ialized
library
,
su 
h
as
a
la
w
library
or
an
engineering
library
,
rather
than
a
general
library
.
Ea 
h
library
,
or
le,
 on
tains
fun tions
that
relate
to
a
parti ular
topi 
or
a tivit
y
,
su 
h
as
`abbrev.el'
for
handling
abbreviations
and
other
t
yping
short uts,
and
`help.el'
for
on-line
help.
(Sometimes
sev
eral
libraries
pro
vide
 o
de
for
a
single
a tivit
y
,
as
the
v
arious
`rmail...
'
les
pro
vide
 o
de
for
reading
ele troni 
mail.)
In
The
GNU
Ema s
Man
ual,
y
ou
will
see
sen
ten es
su 
h
as
\The
C-h
p
 ommand
lets
y
ou
sear 
h
the
standard
Ema s
Lisp
libraries
b
y
topi 
k
eyw
ords."
4.2
A
Simplied
beginning-of-
buf
fe
r
Denition
The
beginning-of-buffer
 ommand
is
a
go
o
d
fun tion
to
start
with
sin e
y
ou
are
lik
ely
to
b
e
familiar
with
it
and
it
is
easy
to
understand.
Used
as
an
in
tera tiv
e
 ommand,
beginning-of-buffer
mo
v
es
the
 ursor
to
the
b
eginning
of
the
buer,
lea
ving
the
mark
at
the
previous
p
osition.
It
is
generally
b
ound
to
M-<.
In
this
se tion,
w
e
will
dis uss
a
shortened
v
ersion
of
the
fun tion
that
sho
ws
ho
w
it
is
most
frequen
tly
used.
This
shortened
fun tion
w
orks
as
written,
but
it
do
es
not
 on
tain
the
 o
de
for
a
 omplex
option.
In
another
se tion,
w
e
will
des rib
e
the
en
tire
fun tion.
(See
Se tion
5.3,
\Complete
Denition
of
beginning-of-buffer",
page
69.)
Before
lo
oking
at
the
 o
de,
let's
 onsider
what
the
fun tion
denition
has
to
 on
tain:
it
m
ust
in lude
an
expression
that
mak
es
the
fun tion
in
tera tiv
e
so
it
 an
b
e
 alled
b
y
t
yping
M-x
beginning-of-buffer
or
b
y
t
yping
a
k
ey 
hord
su 
h
as
C-<;
it
m
ust
in lude
 o
de
to
lea
v
e
a
mark
at
the
original
p
osition
in
the
buer;
and
it
m
ust
in lude
 o
de
to
mo
v
e
the
 ursor
to
the
b
eginning
of
the
buer.

A
Simplied
beginning-of-buffer
Denition
53
Here
is
the
 omplete
text
of
the
shortened
v
ersion
of
the
fun tion:
(defun
simplified-beginning-of-buffer
()
"Move
point
to
the
beginning
of
the
buffer;
leave
mark
at
previous
position."
(intera tive)
(push-mark)
(goto- har
(point-min)))
Lik
e
all
fun tion
denitions,
this
denition
has
v
e
parts
follo
wing
the
sp
e ial
form
defun:
1.
The
name:
in
this
example,
simplified-beginning-of-b
uffe
r.
2.
A
list
of
the
argumen
ts:
in
this
example,
an
empt
y
list,
(),
3.
The
do
 umen
tation
string.
4.
The
in
tera tiv
e
expression.
5.
The
b
o
dy
.
In
this
fun tion
denition,
the
argumen
t
list
is
empt
y;
this
means
that
this
fun tion
do
es
not
require
an
y
argumen
ts.
(When
w
e
lo
ok
at
the
denition
for
the
 omplete
fun tion,
w
e
will
see
that
it
ma
y
b
e
passed
an
optional
argumen
t.)
The
in
tera tiv
e
expression
tells
Ema s
that
the
fun tion
is
in
tended
to
b
e
used
in
tera tiv
ely
.
In
this
example,
intera tive
do
es
not
ha
v
e
an
argumen
t
b
e ause
simplified-beginning-of-bu
ffe
r
do
es
not
require
one.
The
b
o
dy
of
the
fun tion
 onsists
of
the
t
w
o
lines:
(push-mark)
(goto- har
(point-min))
The
rst
of
these
lines
is
the
expression,
(push-mark).
When
this
ex-
pression
is
ev
aluated
b
y
the
Lisp
in
terpreter,
it
sets
a
mark
at
the
 urren
t
p
osition
of
the
 ursor,
wherev
er
that
ma
y
b
e.
The
p
osition
of
this
mark
is
sa
v
ed
in
the
mark
ring.
The
next
line
is
(goto- har
(point-min)).
This
expression
jumps
the
 ursor
to
the
minim
um
p
oin
t
in
the
buer,
that
is,
to
the
b
eginning
of
the
buer
(or
to
the
b
eginning
of
the
a  essible
p
ortion
of
the
buer
if
it
is
narro
w
ed.
See
Chapter
6,
\Narro
wing
and
Widening",
page
77.)
The
push-mark
 ommand
sets
a
mark
at
the
pla e
where
the
 ursor
w
as
lo
 ated
b
efore
it
w
as
mo
v
ed
to
the
b
eginning
of
the
buer
b
y
the
(goto-
 har
(point-min))
expression.
Consequen
tly
,
y
ou
 an,
if
y
ou
wish,
go
ba 
k
to
where
y
ou
w
ere
originally
b
y
t
yping
C-x
C-x.
That
is
all
there
is
to
the
fun tion
denition!
When
y
ou
are
reading
 o
de
su 
h
as
this
and
 ome
up
on
an
unfamiliar
fun tion,
su 
h
as
goto- har,
y
ou
 an
nd
out
what
it
do
es
b
y
using
the
des ribe-fun tion
 ommand.
T
o
use
this
 ommand,
t
yp
e
C-h
f
and
then
t
yp
e
in
the
name
of
the
fun tion
and
press
h
RET
i
.
The
des ribe-fun tion

54
Chapter
4:
A
F
ew
Buer{Related
F
un tions
 ommand
will
prin
t
the
fun tion's
do
 umen
tation
string
in
a
`*Help*'
win-
do
w.
F
or
example,
the
do
 umen
tation
for
goto- har
is:
One
arg,
a
number.
Set
point
to
that
number.
Beginning
of
buffer
is
position
(point-min),
end
is
(point-max).
(The
prompt
for
des ribe-fun tion
will
oer
y
ou
the
sym
b
ol
under
or
pre eding
the
 ursor,
so
y
ou
 an
sa
v
e
t
yping
b
y
p
ositioning
the
 ursor
righ
t
o
v
er
or
after
the
fun tion
and
then
t
yping
C-h
f
h
RET
i
.)
The
end-of-buffer
fun tion
denition
is
written
in
the
same
w
a
y
as
the
beginning-of-buffer
denition
ex ept
that
the
b
o
dy
of
the
fun tion
 on
tains
the
expression
(goto- har
(point-max))
in
pla e
of
(goto- har
(point-min)).
4.3
The
Denition
of
mark-whole-buff
er
The
mark-whole-buffer
fun tion
is
no
harder
to
understand
than
the
simplified-beginning-of-
buff
er
fun tion.
In
this
 ase,
ho
w
ev
er,
w
e
will
lo
ok
at
the
 omplete
fun tion,
not
a
shortened
v
ersion.
The
mark-whole-buffer
fun tion
is
not
as
 ommonly
used
as
the
beginning-of-buffer
fun tion,
but
is
useful
nonetheless:
it
marks
a
whole
buer
as
a
region
b
y
putting
p
oin
t
at
the
b
eginning
and
a
mark
at
the
end
of
the
buer.
It
is
generally
b
ound
to
C-x
h.
In
GNU
Ema s
20,
the
 o
de
for
the
 omplete
fun tion
lo
oks
lik
e
this:
(defun
mark-whole-buffer
()
"Put
point
at
beginning
and
mark
at
end
of
buffer."
(intera tive)
(push-mark
(point))
(push-mark
(point-max))
(goto- har
(point-min)))
Lik
e
all
other
fun tions,
the
mark-whole-buffer
fun tion
ts
in
to
the
template
for
a
fun tion
denition.
The
template
lo
oks
lik
e
this:
(defun
name-of-fun tion
(argumen
t-list
)
"do
 umen
tation...
"
(in
tera tiv
e-expression...
)
b
o
dy
...
)
Here
is
ho
w
the
fun tion
w
orks:
the
name
of
the
fun tion
is
mark-whole-
buffer;
it
is
follo
w
ed
b
y
an
empt
y
argumen
t
list,
`()',
whi 
h
means
that
the
fun tion
do
es
not
require
argumen
ts.
The
do
 umen
tation
 omes
next.
The
next
line
is
an
(intera tive)
expression
that
tells
Ema s
that
the
fun tion
will
b
e
used
in
tera tiv
ely
.
These
details
are
similar
to
the
simplified-beginning-of-
buff
er
fun tion
des rib
ed
in
the
previous
se -
tion.

Bo
dy
of
mark-whole-buffer
55
4.3.1
Bo
dy
of
mark-whole-buffer
The
b
o
dy
of
the
mark-whole-buffer
fun tion
 onsists
of
three
lines
of
 o
de:
(push-mark
(point))
(push-mark
(point-max))
(goto- har
(point-min))
The
rst
of
these
lines
is
the
expression,
(push-mark
(point)).
This
line
do
es
exa tly
the
same
job
as
the
rst
line
of
the
b
o
dy
of
the
simplified-beginning-of
-bu
ffer
fun tion,
whi 
h
is
written
(push-
mark).
In
b
oth
 ases,
the
Lisp
in
terpreter
sets
a
mark
at
the
 urren
t
p
osition
of
the
 ursor.
I
don't
kno
w
wh
y
the
expression
in
mark-whole-buffer
is
written
(push-
mark
(point))
and
the
expression
in
beginning-of-buffer
is
written
(push-mark).
P
erhaps
who
ev
er
wrote
the
 o
de
did
not
kno
w
that
the
ar-
gumen
ts
for
push-mark
are
optional
and
that
if
push-mark
is
not
passed
an
argumen
t,
the
fun tion
automati ally
sets
mark
at
the
lo
 ation
of
p
oin
t
b
y
default.
Or
p
erhaps
the
expression
w
as
written
so
as
to
parallel
the
stru -
ture
of
the
next
line.
In
an
y
 ase,
the
line
 auses
Ema s
to
determine
the
p
osition
of
p
oin
t
and
set
a
mark
there.
The
next
line
of
mark-whole-buffer
is
(push-mark
(point-max).
This
expression
sets
a
mark
at
the
p
oin
t
in
the
buer
that
has
the
highest
n
um
b
er.
This
will
b
e
the
end
of
the
buer
(or,
if
the
buer
is
narro
w
ed,
the
end
of
the
a  essible
p
ortion
of
the
buer.
See
Chapter
6,
\Narro
wing
and
Widening",
page
77,
for
more
ab
out
narro
wing.)
After
this
mark
has
b
een
set,
the
previous
mark,
the
one
set
at
p
oin
t,
is
no
longer
set,
but
Ema s
remem
b
ers
its
p
osition,
just
as
all
other
re en
t
marks
are
alw
a
ys
remem
b
ered.
This
means
that
y
ou
 an,
if
y
ou
wish,
go
ba 
k
to
that
p
osition
b
y
t
yping
C-u
C-
h
SPC
i
t
wi e.
(In
GNU
Ema s
21,
the
(push-mark
(point-max)
is
sligh
tly
more
 om-
pli ated
than
sho
wn
here.
The
line
reads
(push-mark
(point-max)
nil
t)
(The
expression
w
orks
nearly
the
same
as
b
efore.
It
sets
a
mark
at
the
highest
n
um
b
ered
pla e
in
the
buer
that
it
 an.
Ho
w
ev
er,
in
this
v
ersion,
push-mark
has
t
w
o
additional
argumen
ts.
The
se ond
argumen
t
to
push-
mark
is
nil.
This
tells
the
fun tion
it
should
displa
y
a
message
that
sa
ys
`Mark
set'
when
it
pushes
the
mark.
The
third
argumen
t
is
t.
This
tells
push-mark
to
a tiv
ate
the
mark
when
T
ransien
t
Mark
mo
de
is
turned
on.
T
ransien
t
Mark
mo
de
highligh
ts
the
 urren
tly
a tiv
e
region.
It
is
usually
turned
o.)
Finally
,
the
last
line
of
the
fun tion
is
(goto- har
(point-min))).
This
is
written
exa tly
the
same
w
a
y
as
it
is
written
in
beginning-of-buffer.
The
expression
mo
v
es
the
 ursor
to
the
minim
um
p
oin
t
in
the
buer,
that
is,
to
the
b
eginning
of
the
buer
(or
to
the
b
eginning
of
the
a  essible
p
ortion

56
Chapter
4:
A
F
ew
Buer{Related
F
un tions
of
the
buer).
As
a
result
of
this,
p
oin
t
is
pla ed
at
the
b
eginning
of
the
buer
and
mark
is
set
at
the
end
of
the
buer.
The
whole
buer
is,
therefore,
the
region.
4.4
The
Denition
of
append-to-buffe
r
The
append-to-buffer
 ommand
is
v
ery
nearly
as
simple
as
the
mark-
whole-buffer
 ommand.
What
it
do
es
is
 op
y
the
region
(that
is,
the
part
of
the
buer
b
et
w
een
p
oin
t
and
mark)
from
the
 urren
t
buer
to
a
sp
e ied
buer.
The
append-to-buffer
 ommand
uses
the
insert-buffer-substring
fun tion
to
 op
y
the
region.
insert-buffer-substring
is
des rib
ed
b
y
its
name:
it
tak
es
a
string
of
 
hara ters
from
part
of
a
buer,
a
\substring",
and
inserts
them
in
to
another
buer.
Most
of
append-to-buffer
is
 on erned
with
setting
up
the
 onditions
for
insert-buffer-substring
to
w
ork:
the
 o
de
m
ust
sp
e ify
b
oth
the
buer
to
whi 
h
the
text
will
go
and
the
region
that
will
b
e
 opied.
Here
is
the
 omplete
text
of
the
fun tion:
(defun
append-to-buffer
(buffer
start
end)
"Append
to
spe ified
buffer
the
text
of
the
region.
It
is
inserted
into
that
buffer
before
its
point.
When
 alling
from
a
program,
give
three
arguments:
a
buffer
or
the
name
of
one,
and
two
 hara ter
numbers
spe ifying
the
portion
of
the
 urrent
buffer
to
be
 opied."
(intera tive
"BAppend
to
buffer:
\nr")
(let
((oldbuf
( urrent-buffer)))
(save-ex ursion
(set-buffer
(get-buffer- reate
buffer))
(insert-buffer-substring
oldbuf
start
end))))
The
fun tion
 an
b
e
understo
o
d
b
y
lo
oking
at
it
as
a
series
of
lled-in
templates.
The
outermost
template
is
for
the
fun tion
denition.
In
this
fun tion,
it
lo
oks
lik
e
this
(with
sev
eral
slots
lled
in):
(defun
append-to-buffer
(buffer
start
end)
"do
 umen
tation...
"
(intera tive
"BAppend
to
buffer:
\nr")
b
o
dy
...
)
The
rst
line
of
the
fun tion
in ludes
its
name
and
three
argumen
ts.
The
argumen
ts
are
the
buffer
to
whi 
h
the
text
will
b
e
 opied,
and
the
start
and
end
of
the
region
in
the
 urren
t
buer
that
will
b
e
 opied.
The
next
part
of
the
fun tion
is
the
do
 umen
tation,
whi 
h
is
 lear
and
 omplete.

The
Bo
dy
of
append-to-buffer
57
4.4.1
The
append-to-buffer
In
tera tiv
e
Expression
Sin e
the
append-to-buffer
fun tion
will
b
e
used
in
tera tiv
ely
,
the
fun -
tion
m
ust
ha
v
e
an
intera tive
expression.
(F
or
a
review
of
intera tive,
see
Se tion
3.3,
\Making
a
F
un tion
In
tera tiv
e",
page
33.)
The
expression
reads
as
follo
ws:
(intera tive
"BAppend
to
buffer:
\nr")
This
expression
has
an
argumen
t
inside
of
quotation
marks
and
that
argu-
men
t
has
t
w
o
parts,
separated
b
y
`\n'.
The
rst
part
is
`BAppend
to
buffer:
'.
Here,
the
`B'
tells
Ema s
to
ask
for
the
name
of
the
buer
that
will
b
e
passed
to
the
fun tion.
Ema s
will
ask
for
the
name
b
y
prompting
the
user
in
the
minibuer,
using
the
string
follo
wing
the
`B',
whi 
h
is
the
string
`Append
to
buffer:
'.
Ema s
then
binds
the
v
ariable
buffer
in
the
fun tion's
argumen
t
list
to
the
sp
e ied
buer.
The
newline,
`\n',
separates
the
rst
part
of
the
argumen
t
from
the
se ond
part.
It
is
follo
w
ed
b
y
an
`r'
that
tells
Ema s
to
bind
the
t
w
o
argumen
ts
that
follo
w
the
sym
b
ol
buffer
in
the
fun tion's
argumen
t
list
(that
is,
start
and
end)
to
the
v
alues
of
p
oin
t
and
mark.
4.4.2
The
Bo
dy
of
append-to-buffer
The
b
o
dy
of
the
append-to-buffer
fun tion
b
egins
with
let.
As
w
e
ha
v
e
seen
b
efore
(see
Se tion
3.6,
\let",
page
36),
the
purp
ose
of
a
let
expression
is
to
 reate
and
giv
e
initial
v
alues
to
one
or
more
v
ariables
that
will
only
b
e
used
within
the
b
o
dy
of
the
let.
This
means
that
su 
h
a
v
ariable
will
not
b
e
 onfused
with
an
y
v
ariable
of
the
same
name
outside
the
let
expression.
W
e
 an
see
ho
w
the
let
expression
ts
in
to
the
fun tion
as
a
whole
b
y
sho
wing
a
template
for
append-to-buffer
with
the
let
expression
in
outline:
(defun
append-to-buffer
(buffer
start
end)
"do
 umen
tation...
"
(intera tive
"BAppend
to
buffer:
\nr")
(let
((v
ariable
v
alue
))
b
o
dy
...)
The
let
expression
has
three
elemen
ts:
1.
The
sym
b
ol
let;
2.
A
v
arlist
 on
taining,
in
this
 ase,
a
single
t
w
o-elemen
t
list,
(v
ariable
v
alue
);
3.
The
b
o
dy
of
the
let
expression.

58
Chapter
4:
A
F
ew
Buer{Related
F
un tions
In
the
append-to-buffer
fun tion,
the
v
arlist
lo
oks
lik
e
this:
(oldbuf
( urrent-buffer))
In
this
part
of
the
let
expression,
the
one
v
ariable,
oldbuf,
is
b
ound
to
the
v
alue
returned
b
y
the
( urrent-buffer)
expression.
The
v
ariable,
oldbuf,
is
used
to
k
eep
tra 
k
of
the
buer
in
whi 
h
y
ou
are
w
orking
and
from
whi 
h
y
ou
will
 op
y
.
The
elemen
t
or
elemen
ts
of
a
v
arlist
are
surrounded
b
y
a
set
of
paren
theses
so
the
Lisp
in
terpreter
 an
distinguish
the
v
arlist
from
the
b
o
dy
of
the
let.
As
a
 onsequen e,
the
t
w
o-elemen
t
list
within
the
v
arlist
is
surrounded
b
y
a
 ir ums ribing
set
of
paren
theses.
The
line
lo
oks
lik
e
this:
(let
((oldbuf
( urrent-buffer)))
...
)
The
t
w
o
paren
theses
b
efore
oldbuf
migh
t
surprise
y
ou
if
y
ou
did
not
realize
that
the
rst
paren
thesis
b
efore
oldbuf
marks
the
b
oundary
of
the
v
arlist
and
the
se ond
paren
thesis
marks
the
b
eginning
of
the
t
w
o-elemen
t
list,
(oldbuf
( urrent-buffer)).
4.4.3
save-ex ursion
in
append-to-buffer
The
b
o
dy
of
the
let
expression
in
append-to-buffer
 onsists
of
a
save-
ex ursion
expression.
The
save-ex ursion
fun tion
sa
v
es
the
lo
 ations
of
p
oin
t
and
mark,
and
restores
them
to
those
p
ositions
after
the
expressions
in
the
b
o
dy
of
the
save-ex ursion
 omplete
exe ution.
In
addition,
save-ex ursion
k
eeps
tra 
k
of
the
original
buer,
and
restores
it.
This
is
ho
w
save-ex ursion
is
used
in
append-to-buffer.
In iden
tally
,
it
is
w
orth
noting
here
that
a
Lisp
fun tion
is
normally
for-
matted
so
that
ev
erything
that
is
en losed
in
a
m
ulti-line
spread
is
inden
ted
more
to
the
righ
t
than
the
rst
sym
b
ol.
In
this
fun tion
denition,
the
let
is
inden
ted
more
than
the
defun,
and
the
save-ex ursion
is
inden
ted
more
than
the
let,
lik
e
this:
(defun
...
...
...
(let...
(save-ex ursion
...

save-ex ursion
in
append-to-buffer
59
This
formatting
 on
v
en
tion
mak
es
it
easy
to
see
that
the
t
w
o
lines
in
the
b
o
dy
of
the
save-ex ursion
are
en losed
b
y
the
paren
theses
asso
 iated
with
save-ex ursion,
just
as
the
save-ex ursion
itself
is
en losed
b
y
the
paren
theses
asso
 iated
with
the
let:
(let
((oldbuf
( urrent-buffer)))
(save-ex ursion
(set-buffer
(get-buffer- reate
buffer))
(insert-buffer-substring
oldbuf
start
end))))
The
use
of
the
save-ex ursion
fun tion
 an
b
e
view
ed
as
a
pro
 ess
of
lling
in
the
slots
of
a
template:
(save-ex ursion
rst-expression-in-b
o
dy
se ond-expression-in-b
o
dy
...
last-expression-in-b
o
dy
)
In
this
fun tion,
the
b
o
dy
of
the
save-ex ursion
 on
tains
only
t
w
o
expres-
sions.
The
b
o
dy
lo
oks
lik
e
this:
(set-buffer
(get-buffer- reate
buffer))
(insert-buffer-substring
oldbuf
start
end)
When
the
append-to-buffer
fun tion
is
ev
aluated,
the
t
w
o
expressions
in
the
b
o
dy
of
the
save-ex ursion
are
ev
aluated
in
sequen e.
The
v
alue
of
the
last
expression
is
returned
as
the
v
alue
of
the
save-ex ursion
fun tion;
the
other
expression
is
ev
aluated
only
for
its
side
ee ts.
The
rst
line
in
the
b
o
dy
of
the
save-ex ursion
uses
the
set-buffer
fun tion
to
 
hange
the
 urren
t
buer
to
the
one
sp
e ied
in
the
rst
argumen
t
to
append-to-buffer.
(Changing
the
buer
is
the
side
ee t;
as
w
e
ha
v
e
said
b
efore,
in
Lisp,
a
side
ee t
is
often
the
primary
thing
w
e
w
an
t.)
The
se ond
line
do
es
the
primary
w
ork
of
the
fun tion.
The
set-buffer
fun tion
 
hanges
Ema s'
atten
tion
to
the
buer
to
whi 
h
the
text
will
b
e
 opied
and
from
whi 
h
save-ex ursion
will
return.
The
line
lo
oks
lik
e
this:
(set-buffer
(get-buffer- reate
buffer))
The
innermost
expression
of
this
list
is
(get-buffer- reate
buffer).
This
expression
uses
the
get-buffer- reate
fun tion,
whi 
h
either
gets
the
named
buer,
or
if
it
do
es
not
exist,
 reates
one
with
the
giv
en
name.
This
means
y
ou
 an
use
append-to-buffer
to
put
text
in
to
a
buer
that
did
not
previously
exist.
get-buffer- reate
also
k
eeps
set-buffer
from
getting
an
unne essary
error:
set-buffer
needs
a
buer
to
go
to;
if
y
ou
w
ere
to
sp
e ify
a
buer
that
do
es
not
exist,
Ema s
w
ould
baulk.
Sin e
get-buffer- reate
will
 reate
a
buer
if
none
exists,
set-buffer
is
alw
a
ys
pro
vided
with
a
buer.

60
Chapter
4:
A
F
ew
Buer{Related
F
un tions
The
last
line
of
append-to-buffer
do
es
the
w
ork
of
app
ending
the
text:
(insert-buffer-substring
oldbuf
start
end)
The
insert-buffer-substring
fun tion
 opies
a
string
fr
om
the
buer
sp
e ied
as
its
rst
argumen
t
and
inserts
the
string
in
to
the
presen
t
buer.
In
this
 ase,
the
argumen
t
to
insert-buffer-substring
is
the
v
alue
of
the
v
ariable
 reated
and
b
ound
b
y
the
let,
namely
the
v
alue
of
oldbuf,
whi 
h
w
as
the
 urren
t
buer
when
y
ou
ga
v
e
the
append-to-buffer
 ommand.
After
insert-buffer-substring
has
done
its
w
ork,
save-ex ursion
will
restore
the
a tion
to
the
original
buer
and
append-to-buffer
will
ha
v
e
done
its
job.
W
ritten
in
sk
eletal
form,
the
w
orkings
of
the
b
o
dy
lo
ok
lik
e
this:
(let
(bind-oldbuf-to-v
alue-of- urrent-buffer)
(save-ex ursion
;
Keep
tra 
k
of
buer.
 
hange-buer
insert-substring-from-oldbuf-in
to-buer
)
 
hange-ba 
k-to-original-buer-when-nished
let-the-lo
 al-meaning-of-oldbuf-disapp
ear-when-nished
In
summary
,
append-to-buffer
w
orks
as
follo
ws:
it
sa
v
es
the
v
alue
of
the
 urren
t
buer
in
the
v
ariable
 alled
oldbuf.
It
gets
the
new
buer,
 reating
one
if
need
b
e,
and
swit 
hes
Ema s
to
it.
Using
the
v
alue
of
oldbuf,
it
inserts
the
region
of
text
from
the
old
buer
in
to
the
new
buer;
and
then
using
save-ex ursion,
it
brings
y
ou
ba 
k
to
y
our
original
buer.
In
lo
oking
at
append-to-buffer,
y
ou
ha
v
e
explored
a
fairly
 omplex
fun tion.
It
sho
ws
ho
w
to
use
let
and
save-ex ursion,
and
ho
w
to
 
hange
to
and
 ome
ba 
k
from
another
buer.
Man
y
fun tion
denitions
use
let,
save-ex ursion,
and
set-buffer
this
w
a
y
.
4.5
Review
Here
is
a
brief
summary
of
the
v
arious
fun tions
dis ussed
in
this
 
hapter.
des ribe-fun tion
des ribe-variable
Prin
t
the
do
 umen
tation
for
a
fun tion
or
v
ariable.
Con
v
en
tion-
ally
b
ound
to
C-h
f
and
C-h
v.
find-tag
Find
the
le
 on
taining
the
sour e
for
a
fun tion
or
v
ariable
and
swit 
h
buers
to
it,
p
ositioning
p
oin
t
at
the
b
eginning
of
the
item.
Con
v
en
tionally
b
ound
to
M-.
(that's
a
p
erio
d
follo
wing
the
h
MET
A
i
k
ey).

Exer ises
61
save-ex ursion
Sa
v
e
the
lo
 ation
of
p
oin
t
and
mark
and
restore
their
v
alues
after
the
argumen
ts
to
save-ex ursion
ha
v
e
b
een
ev
aluated.
Also,
remem
b
er
the
 urren
t
buer
and
return
to
it.
push-mark
Set
mark
at
a
lo
 ation
and
re ord
the
v
alue
of
the
previous
mark
on
the
mark
ring.
The
mark
is
a
lo
 ation
in
the
buer
that
will
k
eep
its
relativ
e
p
osition
ev
en
if
text
is
added
to
or
remo
v
ed
from
the
buer.
goto- har
Set
p
oin
t
to
the
lo
 ation
sp
e ied
b
y
the
v
alue
of
the
argumen
t,
whi 
h
 an
b
e
a
n
um
b
er,
a
mark
er,
or
an
expression
that
returns
the
n
um
b
er
of
a
p
osition,
su 
h
as
(point-min).
insert-buffer-substring
Cop
y
a
region
of
text
from
a
buer
that
is
passed
to
the
fun tion
as
an
argumen
t
and
insert
the
region
in
to
the
 urren
t
buer.
mark-whole-buffer
Mark
the
whole
buer
as
a
region.
Normally
b
ound
to
C-x
h.
set-buffer
Swit 
h
the
atten
tion
of
Ema s
to
another
buer,
but
do
not
 
hange
the
windo
w
b
eing
displa
y
ed.
Used
when
the
program
rather
than
a
h
uman
is
to
w
ork
on
a
dieren
t
buer.
get-buffer- reate
get-buffer
Find
a
named
buer
or
 reate
one
if
a
buer
of
that
name
do
es
not
exist.
The
get-buffer
fun tion
returns
nil
if
the
named
buer
do
es
not
exist.
4.6
Exer ises

W
rite
y
our
o
wn
simplified-end-of-buffe
r
fun tion
denition;
then
test
it
to
see
whether
it
w
orks.

Use
if
and
get-buffer
to
write
a
fun tion
that
prin
ts
a
message
telling
y
ou
whether
a
buer
exists.

Using
find-tag,
nd
the
sour e
for
the
 opy-to-buffer
fun tion.

62
Chapter
4:
A
F
ew
Buer{Related
F
un tions

The
Denition
of
 opy-to-buffer
63
5
A
F
ew
More
Complex
F
un tions
In
this
 
hapter,
w
e
build
on
what
w
e
ha
v
e
learned
in
previous
 
hapters
b
y
lo
oking
at
more
 omplex
fun tions.
The
 opy-to-buffer
fun tion
illustrates
use
of
t
w
o
save-ex ursion
expressions
in
one
denition,
while
the
insert-
buffer
fun tion
illustrates
use
of
an
asterisk
in
an
intera tive
expression,
use
of
or,
and
the
imp
ortan
t
distin tion
b
et
w
een
a
name
and
the
ob
je t
to
whi 
h
the
name
refers.
5.1
The
Denition
of
 opy-to-buffer
After
understanding
ho
w
append-to-buffer
w
orks,
it
is
easy
to
under-
stand
 opy-to-buffer.
This
fun tion
 opies
text
in
to
a
buer,
but
in-
stead
of
adding
to
the
se ond
buer,
it
repla es
the
previous
text
in
the
se ond
buer.
The
 o
de
for
the
 opy-to-buffer
fun tion
is
almost
the
same
as
the
 o
de
for
append-to-buffer,
ex ept
that
erase-buffer
and
a
se ond
save-ex ursion
are
used.
(See
Se tion
4.4,
\The
Denition
of
append-to-buffer",
page
56,
for
the
des ription
of
append-to-buffer.)
The
b
o
dy
of
 opy-to-buffer
lo
oks
lik
e
this
...
(intera tive
"BCopy
to
buffer:
\nr")
(let
((oldbuf
( urrent-buffer)))
(save-ex ursion
(set-buffer
(get-buffer- reate
buffer))
(erase-buffer)
(save-ex ursion
(insert-buffer-substring
oldbuf
start
end)))))
This
 o
de
is
similar
to
the
 o
de
in
append-to-buffer:
it
is
only
after
 
hanging
to
the
buer
to
whi 
h
the
text
will
b
e
 opied
that
the
denition
for
this
fun tion
div
erges
from
the
denition
for
append-to-buffer:
the
 opy-to-buffer
fun tion
erases
the
buer's
former
 on
ten
ts.
(This
is
what
is
mean
t
b
y
`repla emen
t';
to
repla e
text,
Ema s
erases
the
previous
text
and
then
inserts
new
text.)
After
erasing
the
previous
 on
ten
ts
of
the
buer,
save-ex ursion
is
used
for
a
se ond
time
and
the
new
text
is
inserted.
Wh
y
is
save-ex ursion
used
t
wi e?
Consider
again
what
the
fun tion
do
es.
In
outline,
the
b
o
dy
of
 opy-to-buffer
lo
oks
lik
e
this:
(let
(bind-oldbuf-to-v
alue-of- urrent-buffer)
(save-ex ursion
;
First
use
of
save-ex ursion.
 
hange-buer
(erase-buffer)
(save-ex ursion
;
Se ond
use
of
save-ex ursion.
insert-substring-from-oldbuf-in
to-buer
)))

64
Chapter
5:
A
F
ew
More
Complex
F
un tions
The
rst
use
of
save-ex ursion
returns
Ema s
to
the
buer
from
whi 
h
the
text
is
b
eing
 opied.
That
is
 lear,
and
is
just
lik
e
its
use
in
append-
to-buffer.
Wh
y
the
se ond
use?
The
reason
is
that
insert-buffer-
substring
alw
a
ys
lea
v
es
p
oin
t
at
the
end
of
the
region
b
eing
inserted.
The
se ond
save-ex ursion
 auses
Ema s
to
lea
v
e
p
oin
t
at
the
b
eginning
of
the
text
b
eing
inserted.
In
most
 ir umstan es,
users
prefer
to
nd
p
oin
t
at
the
b
eginning
of
inserted
text.
(Of
 ourse,
the
 opy-to-buffer
fun tion
returns
the
user
to
the
original
buer
when
done|but
if
the
user
then
swit 
hes
to
the
 opied-to
buer,
p
oin
t
will
go
to
the
b
eginning
of
the
text.
Th
us,
this
use
of
a
se ond
save-ex ursion
is
a
little
ni et
y
.)
5.2
The
Denition
of
insert-buffer
insert-buffer
is
y
et
another
buer-related
fun tion.
This
 ommand
 opies
another
buer
into
the
 urren
t
buer.
It
is
the
rev
erse
of
append-
to-buffer
or
 opy-to-buffer,
sin e
they
 op
y
a
region
of
text
fr
om
the
 urren
t
buer
to
another
buer.
In
addition,
this
 o
de
illustrates
the
use
of
intera tive
with
a
buer
that
migh
t
b
e
read-only
and
the
imp
ortan
t
distin tion
b
et
w
een
the
name
of
an
ob
je t
and
the
ob
je t
a tually
referred
to.
Here
is
the
 o
de:
(defun
insert-buffer
(buffer)
"Insert
after
point
the
 ontents
of
BUFFER.
Puts
mark
after
the
inserted
text.
BUFFER
may
be
a
buffer
or
a
buffer
name."
(intera tive
"*bInsert
buffer:
")
(or
(bufferp
buffer)
(setq
buffer
(get-buffer
buffer)))
(let
(start
end
newmark)
(save-ex ursion
(save-ex ursion
(set-buffer
buffer)
(setq
start
(point-min)
end
(point-max)))
(insert-buffer-substring
buffer
start
end)
(setq
newmark
(point)))
(push-mark
newmark)))
As
with
other
fun tion
denitions,
y
ou
 an
use
a
template
to
see
an
outline
of
the
fun tion:
(defun
insert-buffer
(buffer)
"do
 umen
tation...
"
(intera tive
"*bInsert
buffer:
")
b
o
dy
...
)

The
Bo
dy
of
the
insert-buffer
F
un tion
65
5.2.1
The
In
tera tiv
e
Expression
in
insert-buffer
In
insert-buffer,
the
argumen
t
to
the
intera tive
de laration
has
t
w
o
parts,
an
asterisk,
`*',
and
`bInsert
buffer:
'.
A
Read-only
Buer
The
asterisk
is
for
the
situation
when
the
buer
is
a
read-only
buer|
a
buer
that
 annot
b
e
mo
died.
If
insert-buffer
is
 alled
on
a
buer
that
is
read-only
,
a
message
to
this
ee t
is
prin
ted
in
the
e 
ho
area
and
the
terminal
ma
y
b
eep
or
blink
at
y
ou;
y
ou
will
not
b
e
p
ermitted
to
insert
an
ything
in
to
 urren
t
buer.
The
asterisk
do
es
not
need
to
b
e
follo
w
ed
b
y
a
newline
to
separate
it
from
the
next
argumen
t.
`b'
in
an
In
tera tiv
e
Expression
The
next
argumen
t
in
the
in
tera tiv
e
expression
starts
with
a
lo
w
er
 ase
`b'.
(This
is
dieren
t
from
the
 o
de
for
append-to-buffer,
whi 
h
uses
an
upp
er- ase
`B'.
See
Se tion
4.4,
\The
Denition
of
append-to-buffer",
page
56.)
The
lo
w
er- ase
`b'
tells
the
Lisp
in
terpreter
that
the
argumen
t
for
insert-buffer
should
b
e
an
existing
buer
or
else
its
name.
(The
upp
er-
 ase
`B'
option
pro
vides
for
the
p
ossibilit
y
that
the
buer
do
es
not
exist.)
Ema s
will
prompt
y
ou
for
the
name
of
the
buer,
oering
y
ou
a
default
buer,
with
name
 ompletion
enabled.
If
the
buer
do
es
not
exist,
y
ou
re eiv
e
a
message
that
sa
ys
\No
mat 
h";
y
our
terminal
ma
y
b
eep
at
y
ou
as
w
ell.
5.2.2
The
Bo
dy
of
the
insert-buffer
F
un tion
The
b
o
dy
of
the
insert-buffer
fun tion
has
t
w
o
ma
jor
parts:
an
or
expression
and
a
let
expression.
The
purp
ose
of
the
or
expression
is
to
ensure
that
the
argumen
t
buffer
is
b
ound
to
a
buer
and
not
just
the
name
of
a
buer.
The
b
o
dy
of
the
let
expression
 on
tains
the
 o
de
whi 
h
 opies
the
other
buer
in
to
the
 urren
t
buer.
In
outline,
the
t
w
o
expressions
t
in
to
the
insert-buffer
fun tion
lik
e
this:
(defun
insert-buffer
(buffer)
"do
 umen
tation...
"
(intera tive
"*bInsert
buffer:
")
(or
...
...
(let
(v
arlist
)
b
o
dy-of-let...
)

66
Chapter
5:
A
F
ew
More
Complex
F
un tions
T
o
understand
ho
w
the
or
expression
ensures
that
the
argumen
t
buffer
is
b
ound
to
a
buer
and
not
to
the
name
of
a
buer,
it
is
rst
ne essary
to
understand
the
or
fun tion.
Before
doing
this,
let
me
rewrite
this
part
of
the
fun tion
using
if
so
that
y
ou
 an
see
what
is
done
in
a
manner
that
will
b
e
familiar.
5.2.3
insert-buffer
With
an
if
Instead
of
an
or
The
job
to
b
e
done
is
to
mak
e
sure
the
v
alue
of
buffer
is
a
buer
itself
and
not
the
name
of
a
buer.
If
the
v
alue
is
the
name,
then
the
buer
itself
m
ust
b
e
got.
Y
ou
 an
imagine
y
ourself
at
a
 onferen e
where
an
usher
is
w
andering
around
holding
a
list
with
y
our
name
on
it
and
lo
oking
for
y
ou:
the
usher
is
\b
ound"
to
y
our
name,
not
to
y
ou;
but
when
the
usher
nds
y
ou
and
tak
es
y
our
arm,
the
usher
b
e omes
\b
ound"
to
y
ou.
In
Lisp,
y
ou
migh
t
des rib
e
this
situation
lik
e
this:
(if
(not
(holding-on-to-guest))
(find-and-take-arm-of-guest))
W
e
w
an
t
to
do
the
same
thing
with
a
buer|if
w
e
do
not
ha
v
e
the
buer
itself,
w
e
w
an
t
to
get
it.
Using
a
predi ate
 alled
bufferp
that
tells
us
whether
w
e
ha
v
e
a
buer
(rather
than
its
name),
w
e
 an
write
the
 o
de
lik
e
this:
(if
(not
(bufferp
buffer))
;
if-part
(setq
buffer
(get-buffer
buffer)))
;
then-part
Here,
the
true-or-false-test
of
the
if
expression
is
(not
(bufferp
buffer))
;
and
the
then-part
is
the
expression
(setq
buffer
(get-buffer
buffer))
.
In
the
test,
the
fun tion
bufferp
returns
true
if
its
argumen
t
is
a
buer|
but
false
if
its
argumen
t
is
the
name
of
the
buer.
(The
last
 
hara ter
of
the
fun tion
name
bufferp
is
the
 
hara ter
`p';
as
w
e
sa
w
earlier,
su 
h
use
of
`p'
is
a
 on
v
en
tion
that
indi ates
that
the
fun tion
is
a
predi ate,
whi 
h
is
a
term
that
means
that
the
fun tion
will
determine
whether
some
prop
ert
y
is
true
or
false.
See
Se tion
1.8.4,
\Using
the
W
rong
T
yp
e
Ob
je t
as
an
Argumen
t",
page
14.)
The
fun tion
not
pre edes
the
expression
(bufferp
buffer),
so
the
true-
or-false-test
lo
oks
lik
e
this:
(not
(bufferp
buffer))
not
is
a
fun tion
that
returns
true
if
its
argumen
t
is
false
and
false
if
its
argumen
t
is
true.
So
if
(bufferp
buffer)
returns
true,
the
not
expression
returns
false
and
vi e-v
ersa:
what
is
\not
true"
is
false
and
what
is
\not
false"
is
true.
Using
this
test,
the
if
expression
w
orks
as
follo
ws:
when
the
v
alue
of
the
v
ariable
buffer
is
a tually
a
buer
rather
then
its
name,
the
true-or-
false-test
returns
false
and
the
if
expression
do
es
not
ev
aluate
the
then-part.

The
or
in
the
Bo
dy
67
This
is
ne,
sin e
w
e
do
not
need
to
do
an
ything
to
the
v
ariable
buffer
if
it
really
is
a
buer.
On
the
other
hand,
when
the
v
alue
of
buffer
is
not
a
buer
itself,
but
the
name
of
a
buer,
the
true-or-false-test
returns
true
and
the
then-part
of
the
expression
is
ev
aluated.
In
this
 ase,
the
then-part
is
(setq
buffer
(get-buffer
buffer)).
This
expression
uses
the
get-buffer
fun tion
to
return
an
a tual
buer
itself,
giv
en
its
name.
The
setq
then
sets
the
v
ariable
buffer
to
the
v
alue
of
the
buer
itself,
repla ing
its
previous
v
alue
(whi 
h
w
as
the
name
of
the
buer).
5.2.4
The
or
in
the
Bo
dy
The
purp
ose
of
the
or
expression
in
the
insert-buffer
fun tion
is
to
ensure
that
the
argumen
t
buffer
is
b
ound
to
a
buer
and
not
just
to
the
name
of
a
buer.
The
previous
se tion
sho
ws
ho
w
the
job
 ould
ha
v
e
b
een
done
using
an
if
expression.
Ho
w
ev
er,
the
insert-buffer
fun tion
a tually
uses
or.
T
o
understand
this,
it
is
ne essary
to
understand
ho
w
or
w
orks.
An
or
fun tion
 an
ha
v
e
an
y
n
um
b
er
of
argumen
ts.
It
ev
aluates
ea 
h
argumen
t
in
turn
and
returns
the
v
alue
of
the
rst
of
its
argumen
ts
that
is
not
nil.
Also,
and
this
is
a
 ru ial
feature
of
or,
it
do
es
not
ev
aluate
an
y
subsequen
t
argumen
ts
after
returning
the
rst
non-nil
v
alue.
The
or
expression
lo
oks
lik
e
this:
(or
(bufferp
buffer)
(setq
buffer
(get-buffer
buffer)))
The
rst
argumen
t
to
or
is
the
expression
(bufferp
buffer).
This
expres-
sion
returns
true
(a
non-nil
v
alue)
if
the
buer
is
a tually
a
buer,
and
not
just
the
name
of
a
buer.
In
the
or
expression,
if
this
is
the
 ase,
the
or
expression
returns
this
true
v
alue
and
do
es
not
ev
aluate
the
next
expression|and
this
is
ne
with
us,
sin e
w
e
do
not
w
an
t
to
do
an
ything
to
the
v
alue
of
buffer
if
it
really
is
a
buer.
On
the
other
hand,
if
the
v
alue
of
(bufferp
buffer)
is
nil,
whi 
h
it
will
b
e
if
the
v
alue
of
buffer
is
the
name
of
a
buer,
the
Lisp
in
terpreter
ev
aluates
the
next
elemen
t
of
the
or
expression.
This
is
the
expression
(setq
buffer
(get-buffer
buffer)).
This
expression
returns
a
non-nil
v
alue,
whi 
h
is
the
v
alue
to
whi 
h
it
sets
the
v
ariable
buffer|and
this
v
alue
is
a
buer
itself,
not
the
name
of
a
buer.
The
result
of
all
this
is
that
the
sym
b
ol
buffer
is
alw
a
ys
b
ound
to
a
buer
itself
rather
than
to
the
name
of
a
buer.
All
this
is
ne essary
b
e ause
the
set-buffer
fun tion
in
a
follo
wing
line
only
w
orks
with
a
buer
itself,
not
with
the
name
to
a
buer.

68
Chapter
5:
A
F
ew
More
Complex
F
un tions
In iden
tally
,
using
or,
the
situation
with
the
usher
w
ould
b
e
written
lik
e
this:
(or
(holding-on-to-guest)
(find-and-take-arm-of-guest))
5.2.5
The
let
Expression
in
insert-buffer
After
ensuring
that
the
v
ariable
buffer
refers
to
a
buer
itself
and
not
just
to
the
name
of
a
buer,
the
insert-buffer
fun tion
 on
tin
ues
with
a
let
expression.
This
sp
e ies
three
lo
 al
v
ariables,
start,
end,
and
newmark
and
binds
them
to
the
initial
v
alue
nil.
These
v
ariables
are
used
inside
the
remainder
of
the
let
and
temp
orarily
hide
an
y
other
o
  urren e
of
v
ariables
of
the
same
name
in
Ema s
un
til
the
end
of
the
let.
The
b
o
dy
of
the
let
 on
tains
t
w
o
save-ex ursion
expressions.
First,
w
e
will
lo
ok
at
the
inner
save-ex ursion
expression
in
detail.
The
expression
lo
oks
lik
e
this:
(save-ex ursion
(set-buffer
buffer)
(setq
start
(point-min)
end
(point-max)))
The
expression
(set-buffer
buffer)
 
hanges
Ema s'
atten
tion
from
the
 urren
t
buer
to
the
one
from
whi 
h
the
text
will
 opied.
In
that
buer,
the
v
ariables
start
and
end
are
set
to
the
b
eginning
and
end
of
the
buer,
using
the
 ommands
point-min
and
point-max.
Note
that
w
e
ha
v
e
here
an
illustration
of
ho
w
setq
is
able
to
set
t
w
o
v
ariables
in
the
same
expression.
The
rst
argumen
t
of
setq
is
set
to
the
v
alue
of
its
se ond,
and
its
third
argumen
t
is
set
to
the
v
alue
of
its
fourth.
After
the
b
o
dy
of
the
inner
save-ex ursion
is
ev
aluated,
the
save-
ex ursion
restores
the
original
buer,
but
start
and
end
remain
set
to
the
v
alues
of
the
b
eginning
and
end
of
the
buer
from
whi 
h
the
text
will
b
e
 opied.
The
outer
save-ex ursion
expression
lo
oks
lik
e
this:
(save-ex ursion
(inner-save-ex ursion-expression
(go-to-new-buer-and-set-start-and-end)
(insert-buffer-substring
buffer
start
end)
(setq
newmark
(point)))
The
insert-buffer-substring
fun tion
 opies
the
text
into
the
 urren
t
buer
fr
om
the
region
indi ated
b
y
start
and
end
in
buffer.
Sin e
the
whole
of
the
se ond
buer
lies
b
et
w
een
start
and
end,
the
whole
of
the
se ond
buer
is
 opied
in
to
the
buer
y
ou
are
editing.
Next,
the
v
alue
of
p
oin
t,
whi 
h
will
b
e
at
the
end
of
the
inserted
text,
is
re orded
in
the
v
ariable
newmark.
After
the
b
o
dy
of
the
outer
save-ex ursion
is
ev
aluated,
p
oin
t
and
mark
are
relo
 ated
to
their
original
pla es.

Optional
Argumen
ts
69
Ho
w
ev
er,
it
is
 on
v
enien
t
to
lo
 ate
a
mark
at
the
end
of
the
newly
inserted
text
and
lo
 ate
p
oin
t
at
its
b
eginning.
The
newmark
v
ariable
re ords
the
end
of
the
inserted
text.
In
the
last
line
of
the
let
expression,
the
(push-mark
newmark)
expression
fun tion
sets
a
mark
to
this
lo
 ation.
(The
previous
lo
 ation
of
the
mark
is
still
a  essible;
it
is
re orded
on
the
mark
ring
and
y
ou
 an
go
ba 
k
to
it
with
C-u
C-
h
SPC
i
.)
Mean
while,
p
oin
t
is
lo
 ated
at
the
b
eginning
of
the
inserted
text,
whi 
h
is
where
it
w
as
b
efore
y
ou
 alled
the
insert
fun tion.
The
whole
let
expression
lo
oks
lik
e
this:
(let
(start
end
newmark)
(save-ex ursion
(save-ex ursion
(set-buffer
buffer)
(setq
start
(point-min)
end
(point-max)))
(insert-buffer-substring
buffer
start
end)
(setq
newmark
(point)))
(push-mark
newmark))
Lik
e
the
append-to-buffer
fun tion,
the
insert-buffer
fun tion
uses
let,
save-ex ursion,
and
set-buffer.
In
addition,
the
fun tion
illustrates
one
w
a
y
to
use
or.
All
these
fun tions
are
building
blo
 
ks
that
w
e
will
nd
and
use
again
and
again.
5.3
Complete
Denition
of
beginning-of-bu
ff
er
The
basi 
stru ture
of
the
beginning-of-buffer
fun tion
has
already
b
een
dis ussed.
(See
Se tion
4.2,
\A
Simplied
beginning-of-buffer
Def-
inition",
page
52.)
This
se tion
des rib
es
the
 omplex
part
of
the
denition.
As
previously
des rib
ed,
when
in
v
ok
ed
without
an
argumen
t,
beginning-
of-buffer
mo
v
es
the
 ursor
to
the
b
eginning
of
the
buer,
lea
ving
the
mark
at
the
previous
p
osition.
Ho
w
ev
er,
when
the
 ommand
is
in
v
ok
ed
with
a
n
um
b
er
b
et
w
een
one
and
ten,
the
fun tion
 onsiders
that
n
um
b
er
to
b
e
a
fra tion
of
the
length
of
the
buer,
measured
in
ten
ths,
and
Ema s
mo
v
es
the
 ursor
that
fra tion
of
the
w
a
y
from
the
b
eginning
of
the
buer.
Th
us,
y
ou
 an
either
 all
this
fun tion
with
the
k
ey
 ommand
M-<,
whi 
h
will
mo
v
e
the
 ursor
to
the
b
eginning
of
the
buer,
or
with
a
k
ey
 ommand
su 
h
as
C-u
7
M-<
whi 
h
will
mo
v
e
the
 ursor
to
a
p
oin
t
70%
of
the
w
a
y
through
the
buer.
If
a
n
um
b
er
bigger
than
ten
is
used
for
the
argumen
t,
it
mo
v
es
to
the
end
of
the
buer.
The
beginning-of-buffer
fun tion
 an
b
e
 alled
with
or
without
an
argumen
t.
The
use
of
the
argumen
t
is
optional.

70
Chapter
5:
A
F
ew
More
Complex
F
un tions
5.3.1
Optional
Argumen
ts
Unless
told
otherwise,
Lisp
exp
e ts
that
a
fun tion
with
an
argumen
t
in
its
fun tion
denition
will
b
e
 alled
with
a
v
alue
for
that
argumen
t.
If
that
do
es
not
happ
en,
y
ou
get
an
error
and
a
message
that
sa
ys
`Wrong
number
of
arguments'.
Ho
w
ev
er,
optional
argumen
ts
are
a
feature
of
Lisp:
a
k
eyw
ord
ma
y
b
e
used
to
tell
the
Lisp
in
terpreter
that
an
argumen
t
is
optional.
The
k
eyw
ord
is
&optional.
(The
`&'
in
fron
t
of
`optional'
is
part
of
the
k
eyw
ord.)
In
a
fun tion
denition,
if
an
argumen
t
follo
ws
the
k
eyw
ord
&optional,
a
v
alue
do
es
not
need
to
b
e
passed
to
that
argumen
t
when
the
fun tion
is
 alled.
The
rst
line
of
the
fun tion
denition
of
beginning-of-buffer
therefore
lo
oks
lik
e
this:
(defun
beginning-of-buffer
(&optional
arg)
In
outline,
the
whole
fun tion
lo
oks
lik
e
this:
(defun
beginning-of-buffer
(&optional
arg)
"do
 umen
tation...
"
(intera tive
"P")
(push-mark)
(goto- har
(if-there-is-an-argumen
t
gure-out-where-to-go
else-go-to
(point-min))))
The
fun tion
is
similar
to
the
simplified-beginning-of
-bu
ffer
fun -
tion
ex ept
that
the
intera tive
expression
has
"P"
as
an
argumen
t
and
the
goto- har
fun tion
is
follo
w
ed
b
y
an
if-then-else
expression
that
gures
out
where
to
put
the
 ursor
if
there
is
an
argumen
t.
The
"P"
in
the
intera tive
expression
tells
Ema s
to
pass
a
prex
argumen
t,
if
there
is
one,
to
the
fun tion.
A
prex
argumen
t
is
made
b
y
t
yping
the
h
MET
A
i
k
ey
follo
w
ed
b
y
a
n
um
b
er,
or
b
y
t
yping
C-u
and
then
a
n
um
b
er
(if
y
ou
don't
t
yp
e
a
n
um
b
er,
C-u
defaults
to
4).
The
true-or-false-test
of
the
if
expression
is
simple:
it
is
simply
the
argumen
t
arg.
If
arg
has
a
v
alue
that
is
not
nil,
whi 
h
will
b
e
the
 ase
if
beginning-of-buffer
is
 alled
with
an
argumen
t,
then
this
true-or-false-
test
will
return
true
and
the
then-part
of
the
if
expression
will
b
e
ev
aluated.
On
the
other
hand,
if
beginning-of-buffer
is
not
 alled
with
an
argumen
t,
the
v
alue
of
arg
will
b
e
nil
and
the
else-part
of
the
if
expression
will
b
e
ev
aluated.
The
else-part
is
simply
point-min,
and
when
this
is
the
out ome,
the
whole
goto- har
expression
is
(goto- har
(point-min)),
whi 
h
is
ho
w
w
e
sa
w
the
beginning-of-buffer
fun tion
in
its
simplied
form.

What
happ
ens
in
a
large
buer
71
5.3.2
beginning-of-buffer
with
an
Argumen
t
When
beginning-of-buffer
is
 alled
with
an
argumen
t,
an
expression
is
ev
aluated
whi 
h
 al ulates
what
v
alue
to
pass
to
goto- har.
This
expression
is
rather
 ompli ated
at
rst
sigh
t.
It
in ludes
an
inner
if
expression
and
m
u 
h
arithmeti .
It
lo
oks
lik
e
this:
(if
(>
(buffer-size)
10000)
;;
Av
oid
o
v
ero
w
for
large
buer
sizes!
(*
(prefix-numeri -value
arg)
(/
(buffer-size)
10))
(/
(+
10
(*
(buffer-size)
(prefix-numeri -value
arg)))
10))
Lik
e
other
 omplex-lo
oking
expressions,
the
 onditional
expression
within
beginning-of-buffer
 an
b
e
disen
tangled
b
y
lo
oking
at
it
as
parts
of
a
template,
in
this
 ase,
the
template
for
an
if-then-else
expression.
In
sk
eletal
form,
the
expression
lo
oks
lik
e
this:
(if
(buer-is-large
divide-buer-size-b
y-10-and-m
ultiply-b
y-arg
else-use-alternate- al ulation
The
true-or-false-test
of
this
inner
if
expression
 
he 
ks
the
size
of
the
buer.
The
reason
for
this
is
that
the
old
V
ersion
18
Ema s
used
n
um
b
ers
that
are
no
bigger
than
eigh
t
million
or
so
and
in
the
 omputation
that
follo
w
ed,
the
programmer
feared
that
Ema s
migh
t
try
to
use
o
v
er-large
n
um
b
ers
if
the
buer
w
ere
large.
The
term
`o
v
ero
w',
men
tioned
in
the
 ommen
t,
means
n
um
b
ers
that
are
o
v
er
large.
V
ersion
21
Ema s
uses
larger
n
um
b
ers,
but
this
 o
de
has
not
b
een
tou 
hed,
if
only
b
e ause
p
eople
no
w
lo
ok
at
buers
that
are
far,
far
larger
than
ev
er
b
efore.
There
are
t
w
o
 ases:
if
the
buer
is
large
and
if
it
is
not.
What
happ
ens
in
a
large
buer
In
beginning-of-buffer,
the
inner
if
expression
tests
whether
the
size
of
the
buer
is
greater
than
10,000
 
hara ters.
T
o
do
this,
it
uses
the
>
fun tion
and
the
buffer-size
fun tion.
The
line
lo
oks
lik
e
this:
(if
(>
(buffer-size)
10000)
When
the
buer
is
large,
the
then-part
of
the
if
expression
is
ev
aluated.
It
reads
lik
e
this
(after
formatting
for
easy
reading):
(*
(prefix-numeri -value
arg)
(/
(buffer-size)
10))
This
expression
is
a
m
ultipli ation,
with
t
w
o
argumen
ts
to
the
fun tion
*.

72
Chapter
5:
A
F
ew
More
Complex
F
un tions
The
rst
argumen
t
is
(prefix-numeri -value
arg).
When
"P"
is
used
as
the
argumen
t
for
intera tive,
the
v
alue
passed
to
the
fun tion
as
its
argumen
t
is
passed
a
\ra
w
prex
argumen
t",
and
not
a
n
um
b
er.
(It
is
a
n
um
b
er
in
a
list.)
T
o
p
erform
the
arithmeti ,
a
 on
v
ersion
is
ne essary
,
and
prefix-numeri -value
do
es
the
job.
The
se ond
argumen
t
is
(/
(buffer-size)
10).
This
expression
divides
the
n
umeri 
v
alue
of
the
buer
b
y
ten.
This
pro
du es
a
n
um
b
er
that
tells
ho
w
man
y
 
hara ters
mak
e
up
one
ten
th
of
the
buer
size.
(In
Lisp,
/
is
used
for
division,
just
as
*
is
used
for
m
ultipli ation.)
In
the
m
ultipli ation
expression
as
a
whole,
this
amoun
t
is
m
ultiplied
b
y
the
v
alue
of
the
prex
argumen
t|the
m
ultipli ation
lo
oks
lik
e
this:
(*
n
umeri -v
alue-of-prex-arg
n
um
b
er-of- 
hara ters-in-one-ten
th-of-the-buer
)
If,
for
example,
the
prex
argumen
t
is
`7',
the
one-ten
th
v
alue
will
b
e
m
ul-
tiplied
b
y
7
to
giv
e
a
p
osition
70%
of
the
w
a
y
through
the
buer.
The
result
of
all
this
is
that
if
the
buer
is
large,
the
goto- har
expression
reads
lik
e
this:
(goto- har
(*
(prefix-numeri -value
arg)
(/
(buffer-size)
10)))
This
puts
the
 ursor
where
w
e
w
an
t
it.
What
happ
ens
in
a
small
buer
If
the
buer
 on
tains
few
er
than
10,000
 
hara ters,
a
sligh
tly
dieren
t
 omputation
is
p
erformed.
Y
ou
migh
t
think
this
is
not
ne essary
,
sin e
the
rst
 omputation
 ould
do
the
job.
Ho
w
ev
er,
in
a
small
buer,
the
rst
metho
d
ma
y
not
put
the
 ursor
on
exa tly
the
desired
line;
the
se ond
metho
d
do
es
a
b
etter
job.
The
 o
de
lo
oks
lik
e
this:
(/
(+
10
(*
(buffer-size)
(prefix-numeri -value
arg)))
10))
This
is
 o
de
in
whi 
h
y
ou
gure
out
what
happ
ens
b
y
dis o
v
ering
ho
w
the
fun tions
are
em
b
edded
in
paren
theses.
It
is
easier
to
read
if
y
ou
reformat
it
with
ea 
h
expression
inden
ted
more
deeply
than
its
en losing
expression:
(/
(+
10
(*
(buffer-size)
(prefix-numeri -value
arg)))
10))

The
Complete
beginning-of-buffer
73
Lo
oking
at
paren
theses,
w
e
see
that
the
innermost
op
eration
is
(prefix-
numeri -value
arg),
whi 
h
 on
v
erts
the
ra
w
argumen
t
to
a
n
um
b
er.
This
n
um
b
er
is
m
ultiplied
b
y
the
buer
size
in
the
follo
wing
expression:
(*
(buffer-size)
(prefix-numeri -value
arg)
This
m
ultipli ation
 reates
a
n
um
b
er
that
ma
y
b
e
larger
than
the
size
of
the
buer|sev
en
times
larger
if
the
argumen
t
is
7,
for
example.
T
en
is
then
added
to
this
n
um
b
er
and
nally
the
large
n
um
b
er
is
divided
b
y
ten
to
pro
vide
a
v
alue
that
is
one
 
hara ter
larger
than
the
p
er en
tage
p
osition
in
the
buer.
The
n
um
b
er
that
results
from
all
this
is
passed
to
goto- har
and
the
 ursor
is
mo
v
ed
to
that
p
oin
t.
5.3.3
The
Complete
beginning-of-buffer
Here
is
the
 omplete
text
of
the
beginning-of-buffer
fun tion:
(defun
beginning-of-buffer
(&optional
arg)
"Move
point
to
the
beginning
of
the
buffer;
leave
mark
at
previous
position.
With
arg
N,
put
point
N/10
of
the
way
from
the
true
beginning.
Don't
use
this
in
Lisp
programs!
\(goto- har
(point-min))
is
faster
and
does
not
set
the
mark."
(intera tive
"P")
(push-mark)
(goto- har
(if
arg
(if
(>
(buffer-size)
10000)
;;
Av
oid
o
v
ero
w
for
large
buer
sizes!
(*
(prefix-numeri -value
arg)
(/
(buffer-size)
10))
(/
(+
10
(*
(buffer-size)
(prefix-numeri -value
arg)))
10))
(point-min)))
(if
arg
(forward-line
1)))
Ex ept
for
t
w
o
small
p
oin
ts,
the
previous
dis ussion
sho
ws
ho
w
this
fun tion
w
orks.
The
rst
p
oin
t
deals
with
a
detail
in
the
do
 umen
tation
string,
and
the
se ond
p
oin
t
 on erns
the
last
line
of
the
fun tion.
In
the
do
 umen
tation
string,
there
is
referen e
to
an
expression:
\(goto- har
(point-min))
A
`\'
is
used
b
efore
the
rst
paren
thesis
of
this
expression.
This
`\'
tells
the
Lisp
in
terpreter
that
the
expression
should
b
e
prin
ted
as
sho
wn
in
the

74
Chapter
5:
A
F
ew
More
Complex
F
un tions
do
 umen
tation
rather
than
ev
aluated
as
a
sym
b
oli 
expression,
whi 
h
is
what
it
lo
oks
lik
e.
Finally
,
the
last
line
of
the
beginning-of-buffer
 ommand
sa
ys
to
mo
v
e
p
oin
t
to
the
b
eginning
of
the
next
line
if
the
 ommand
is
in
v
ok
ed
with
an
argumen
t:
(if
arg
(forward-line
1)))
This
puts
the
 ursor
at
the
b
eginning
of
the
rst
line
after
the
appropriate
ten
ths
p
osition
in
the
buer.
This
is
a
ourish
that
means
that
the
 ursor
is
alw
a
ys
lo
 ated
at
le
ast
the
requested
ten
ths
of
the
w
a
y
through
the
buer,
whi 
h
is
a
ni et
y
that
is,
p
erhaps,
not
ne essary
,
but
whi 
h,
if
it
did
not
o
  ur,
w
ould
b
e
sure
to
dra
w
 omplain
ts.
5.4
Review
Here
is
a
brief
summary
of
some
of
the
topi s
 o
v
ered
in
this
 
hapter.
or
Ev
aluate
ea 
h
argumen
t
in
sequen e,
and
return
the
v
alue
of
the
rst
argumen
t
that
is
not
nil;
if
none
return
a
v
alue
that
is
not
nil,
return
nil.
In
brief,
return
the
rst
true
v
alue
of
the
argumen
ts;
return
a
true
v
alue
if
one
or
an
y
of
the
other
are
true.
and
Ev
aluate
ea 
h
argumen
t
in
sequen e,
and
if
an
y
are
nil,
return
nil;
if
none
are
nil,
return
the
v
alue
of
the
last
argumen
t.
In
brief,
return
a
true
v
alue
only
if
all
the
argumen
ts
are
true;
return
a
true
v
alue
if
one
and
ea 
h
of
the
others
is
true.
&optional
A
k
eyw
ord
used
to
indi ate
that
an
argumen
t
to
a
fun tion
de-
nition
is
optional;
this
means
that
the
fun tion
 an
b
e
ev
aluated
without
the
argumen
t,
if
desired.
prefix-numeri -value
Con
v
ert
the
`ra
w
prex
argumen
t'
pro
du ed
b
y
(intera tive
"P")
to
a
n
umeri 
v
alue.
forward-line
Mo
v
e
p
oin
t
forw
ard
to
the
b
eginning
of
the
next
line,
or
if
the
argumen
t
is
greater
than
one,
forw
ard
that
man
y
lines.
If
it
 an't
mo
v
e
as
far
forw
ard
as
it
is
supp
osed
to,
forward-line
go
es
forw
ard
as
far
as
it
 an
and
then
returns
a
 oun
t
of
the
n
um
b
er
of
additional
lines
it
w
as
supp
osed
to
mo
v
e
but
 ouldn't.
erase-buffer
Delete
the
en
tire
 on
ten
ts
of
the
 urren
t
buer.
bufferp
Return
t
if
its
argumen
t
is
a
buer;
otherwise
return
nil.

optional
Argumen
t
Exer ise
75
5.5
optional
Argumen
t
Exer ise
W
rite
an
in
tera tiv
e
fun tion
with
an
optional
argumen
t
that
tests
whether
its
argumen
t,
a
n
um
b
er,
is
greater
or
less
than
the
v
alue
of
fill-
 olumn,
and
tells
y
ou
whi 
h,
in
a
message.
Ho
w
ev
er,
if
y
ou
do
not
pass
an
argumen
t
to
the
fun tion,
use
56
as
a
default
v
alue.

76
Chapter
5:
A
F
ew
More
Complex
F
un tions

The
save-restri tion
Sp
e ial
F
orm
77
6
Narro
wing
and
Widening
Narro
wing
is
a
feature
of
Ema s
that
mak
es
it
p
ossible
for
y
ou
to
fo
 us
on
a
sp
e i 
part
of
a
buer,
and
w
ork
without
a  iden
tally
 
hanging
other
parts.
Narro
wing
is
normally
disabled
sin e
it
 an
 onfuse
no
vi es.
With
narro
wing,
the
rest
of
a
buer
is
made
in
visible,
as
if
it
w
eren't
there.
This
is
an
adv
an
tage
if,
for
example,
y
ou
w
an
t
to
repla e
a
w
ord
in
one
part
of
a
buer
but
not
in
another:
y
ou
narro
w
to
the
part
y
ou
w
an
t
and
the
repla emen
t
is
 arried
out
only
in
that
se tion,
not
in
the
rest
of
the
buer.
Sear 
hes
will
only
w
ork
within
a
narro
w
ed
region,
not
outside
of
one,
so
if
y
ou
are
xing
a
part
of
a
do
 umen
t,
y
ou
 an
k
eep
y
ourself
from
a  iden
tally
nding
parts
y
ou
do
not
need
to
x
b
y
narro
wing
just
to
the
region
y
ou
w
an
t.
(The
k
ey
binding
for
narrow-to-region
is
C-x
n
n.)
Ho
w
ev
er,
narro
wing
do
es
mak
e
the
rest
of
the
buer
in
visible,
whi 
h
 an
s are
p
eople
who
inadv
erten
tly
in
v
ok
e
narro
wing
and
think
they
ha
v
e
deleted
a
part
of
their
le.
Moreo
v
er,
the
undo
 ommand
(whi 
h
is
usually
b
ound
to
C-x
u)
do
es
not
turn
o
narro
wing
(nor
should
it),
so
p
eople
 an
b
e ome
quite
desp
erate
if
they
do
not
kno
w
that
they
 an
return
the
rest
of
a
buer
to
visibilit
y
with
the
widen
 ommand.
(The
k
ey
binding
for
widen
is
C-x
n
w.)
Narro
wing
is
just
as
useful
to
the
Lisp
in
terpreter
as
to
a
h
uman.
Often,
an
Ema s
Lisp
fun tion
is
designed
to
w
ork
on
just
part
of
a
buer;
or
 on
v
ersely
,
an
Ema s
Lisp
fun tion
needs
to
w
ork
on
all
of
a
buer
that
has
b
een
narro
w
ed.
The
what-line
fun tion,
for
example,
remo
v
es
the
narro
wing
from
a
buer,
if
it
has
an
y
narro
wing
and
when
it
has
nished
its
job,
restores
the
narro
wing
to
what
it
w
as.
On
the
other
hand,
the
 ount-
lines
fun tion,
whi 
h
is
 alled
b
y
what-line,
uses
narro
wing
to
restri t
itself
to
just
that
p
ortion
of
the
buer
in
whi 
h
it
is
in
terested
and
then
restores
the
previous
situation.
6.1
The
save-restri t
io
n
Sp
e ial
F
orm
In
Ema s
Lisp,
y
ou
 an
use
the
save-restri tion
sp
e ial
form
to
k
eep
tra 
k
of
whatev
er
narro
wing
is
in
ee t,
if
an
y
.
When
the
Lisp
in
terpreter
meets
with
save-restri tion,
it
exe utes
the
 o
de
in
the
b
o
dy
of
the
save-
restri tion
expression,
and
then
undo
es
an
y
 
hanges
to
narro
wing
that
the
 o
de
 aused.
If,
for
example,
the
buer
is
narro
w
ed
and
the
 o
de
that
follo
ws
save-restri tion
gets
rid
of
the
narro
wing,
save-restri tion
returns
the
buer
to
its
narro
w
ed
region
afterw
ards.
In
the
what-line
 ommand,
an
y
narro
wing
the
buer
ma
y
ha
v
e
is
undone
b
y
the
widen
 ommand
that
im-
mediately
follo
ws
the
save-restri tion
 ommand.
An
y
original
narro
wing
is
restored
just
b
efore
the
 ompletion
of
the
fun tion.

78
Chapter
6:
Narro
wing
and
Widening
The
template
for
a
save-restri tion
expression
is
simple:
(save-restri tion
b
o
dy
...
)
The
b
o
dy
of
the
save-restri tion
is
one
or
more
expressions
that
will
b
e
ev
aluated
in
sequen e
b
y
the
Lisp
in
terpreter.
Finally
,
a
p
oin
t
to
note:
when
y
ou
use
b
oth
save-ex ursion
and
save-
restri tion,
one
righ
t
after
the
other,
y
ou
should
use
save-ex ursion
out-
ermost.
If
y
ou
write
them
in
rev
erse
order,
y
ou
ma
y
fail
to
re ord
narro
wing
in
the
buer
to
whi 
h
Ema s
swit 
hes
after
 alling
save-ex ursion.
Th
us,
when
written
together,
save-ex ursion
and
save-restri tion
should
b
e
written
lik
e
this:
(save-ex ursion
(save-restri tion
b
o
dy
...
))
In
other
 ir umstan es,
when
not
written
together,
the
save-ex ursion
and
save-restri tion
sp
e ial
forms
m
ust
b
e
written
in
the
order
appro-
priate
to
the
fun tion.
F
or
example,
(save-restri tion
(widen)
(save-ex ursion
b
o
dy
...
))
6.2
what-line
The
what-line
 ommand
tells
y
ou
the
n
um
b
er
of
the
line
in
whi 
h
the
 ursor
is
lo
 ated.
The
fun tion
illustrates
the
use
of
the
save-restri tion
and
save-ex ursion
 ommands.
Here
is
the
text
of
the
fun tion
in
full:
(defun
what-line
()
"Print
the
 urrent
line
number
(in
the
buffer)
of
point."
(intera tive)
(save-restri tion
(widen)
(save-ex ursion
(beginning-of-line)
(message
"Line
%d"
(1+
( ount-lines
1
(point)))))))
The
fun tion
has
a
do
 umen
tation
line
and
is
in
tera tiv
e,
as
y
ou
w
ould
exp
e t.
The
next
t
w
o
lines
use
the
fun tions
save-restri tion
and
widen.
The
save-restri tion
sp
e ial
form
notes
whatev
er
narro
wing
is
in
ef-
fe t,
if
an
y
,
in
the
 urren
t
buer
and
restores
that
narro
wing
after
the
 o
de
in
the
b
o
dy
of
the
save-restri tion
has
b
een
ev
aluated.

Exer ise
with
Narro
wing
79
The
save-restri tion
sp
e ial
form
is
follo
w
ed
b
y
widen.
This
fun tion
undo
es
an
y
narro
wing
the
 urren
t
buer
ma
y
ha
v
e
had
when
what-line
w
as
 alled.
(The
narro
wing
that
w
as
there
is
the
narro
wing
that
save-
restri tion
remem
b
ers.)
This
widening
mak
es
it
p
ossible
for
the
line
 oun
ting
 ommands
to
 oun
t
from
the
b
eginning
of
the
buer.
Otherwise,
they
w
ould
ha
v
e
b
een
limited
to
 oun
ting
within
the
a  essible
region.
An
y
original
narro
wing
is
restored
just
b
efore
the
 ompletion
of
the
fun tion
b
y
the
save-restri tion
sp
e ial
form.
The
 all
to
widen
is
follo
w
ed
b
y
save-ex ursion,
whi 
h
sa
v
es
the
lo
 a-
tion
of
the
 ursor
(i.e.,
of
p
oin
t)
and
of
the
mark,
and
restores
them
after
the
 o
de
in
the
b
o
dy
of
the
save-ex ursion
uses
the
beginning-of-line
fun tion
to
mo
v
e
p
oin
t.
(Note
that
the
(widen)
expression
 omes
b
et
w
een
the
save-restri tion
and
save-ex ursion
sp
e ial
forms.
When
y
ou
write
the
t
w
o
save-
...
expressions
in
sequen e,
write
save-ex ursion
outermost.)
The
last
t
w
o
lines
of
the
what-line
fun tion
are
fun tions
to
 oun
t
the
n
um
b
er
of
lines
in
the
buer
and
then
prin
t
the
n
um
b
er
in
the
e 
ho
area.
(message
"Line
%d"
(1+
( ount-lines
1
(point)))))))
The
message
fun tion
prin
ts
a
one-line
message
at
the
b
ottom
of
the
Ema s
s reen.
The
rst
argumen
t
is
inside
of
quotation
marks
and
is
prin
ted
as
a
string
of
 
hara ters.
Ho
w
ev
er,
it
ma
y
 on
tain
`%d',
`%s',
or
`% '
to
prin
t
argumen
ts
that
follo
w
the
string.
`%d'
prin
ts
the
argumen
t
as
a
de imal,
so
the
message
will
sa
y
something
su 
h
as
`Line
243'.
The
n
um
b
er
that
is
prin
ted
in
pla e
of
the
`%d'
is
 omputed
b
y
the
last
line
of
the
fun tion:
(1+
( ount-lines
1
(point)))
What
this
do
es
is
 oun
t
the
lines
from
the
rst
p
osition
of
the
buer,
indi-
 ated
b
y
the
1,
up
to
(point),
and
then
add
one
to
that
n
um
b
er.
(The
1+
fun tion
adds
one
to
its
argumen
t.)
W
e
add
one
to
it
b
e ause
line
2
has
only
one
line
b
efore
it,
and
 ount-lines
 oun
ts
only
the
lines
b
efor
e
the
 urren
t
line.
After
 ount-lines
has
done
its
job,
and
the
message
has
b
een
prin
ted
in
the
e 
ho
area,
the
save-ex ursion
restores
p
oin
t
and
mark
to
their
original
p
ositions;
and
save-restri tion
restores
the
original
narro
wing,
if
an
y
.
6.3
Exer ise
with
Narro
wing
W
rite
a
fun tion
that
will
displa
y
the
rst
60
 
hara ters
of
the
 urren
t
buer,
ev
en
if
y
ou
ha
v
e
narro
w
ed
the
buer
to
its
latter
half
so
that
the
rst
line
is
ina  essible.
Restore
p
oin
t,
mark,
and
narro
wing.
F
or
this
exer ise,
y
ou
need
to
use
save-restri tion,
widen,
goto- har,
point-min,
buffer-
substring,
message,
and
other
fun tions,
a
whole
p
otp
ourri.

80
Chapter
6:
Narro
wing
and
Widening

 ar
and
 dr
81
7
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
In
Lisp,
 ar,
 dr,
and
 ons
are
fundamen
tal
fun tions.
The
 ons
fun tion
is
used
to
 onstru t
lists,
and
the
 ar
and
 dr
fun tions
are
used
to
tak
e
them
apart.
In
the
w
alk
through
of
the
 opy-region-as-kill
fun tion,
w
e
will
see
 ons
as
w
ell
as
t
w
o
v
arian
ts
on
 dr,
namely
,
set dr
and
nth dr.
(See
Se tion
8.5,
\ op
y-region-as-kill",
page
102.)
The
name
of
the
 ons
fun tion
is
not
unreasonable:
it
is
an
abbreviation
of
the
w
ord
` onstru t'.
The
origins
of
the
names
for
 ar
and
 dr,
on
the
other
hand,
are
esoteri :
 ar
is
an
a ron
ym
from
the
phrase
`Con
ten
ts
of
the
Address
part
of
the
Register';
and
 dr
(pronoun ed
` ould-er')
is
an
a ron
ym
from
the
phrase
`Con
ten
ts
of
the
De remen
t
part
of
the
Register'.
These
phrases
refer
to
sp
e i 
pie es
of
hardw
are
on
the
v
ery
early
 omputer
on
whi 
h
the
original
Lisp
w
as
dev
elop
ed.
Besides
b
eing
obsolete,
the
phrases
ha
v
e
b
een
 ompletely
irrelev
an
t
for
more
than
25
y
ears
to
an
y
one
thinking
ab
out
Lisp.
Nonetheless,
although
a
few
bra
v
e
s 
holars
ha
v
e
b
egun
to
use
more
reasonable
names
for
these
fun tions,
the
old
terms
are
still
in
use.
In
parti ular,
sin e
the
terms
are
used
in
the
Ema s
Lisp
sour e
 o
de,
w
e
will
use
them
in
this
in
tro
du tion.
7.1
 ar
and
 dr
The
 ar
of
a
list
is,
quite
simply
,
the
rst
item
in
the
list.
Th
us
the
 ar
of
the
list
(rose
violet
daisy
butter up)
is
rose.
If
y
ou
are
reading
this
in
Info
in
GNU
Ema s,
y
ou
 an
see
this
b
y
ev
alu-
ating
the
follo
wing:
( ar
'(rose
violet
daisy
butter up))
After
ev
aluating
the
expression,
rose
will
app
ear
in
the
e 
ho
area.
Clearly
,
a
more
reasonable
name
for
the
 ar
fun tion
w
ould
b
e
first
and
this
is
often
suggested.
 ar
do
es
not
remo
v
e
the
rst
item
from
the
list;
it
only
rep
orts
what
it
is.
After
 ar
has
b
een
applied
to
a
list,
the
list
is
still
the
same
as
it
w
as.
In
the
jargon,
 ar
is
`non-destru tiv
e'.
This
feature
turns
out
to
b
e
imp
ortan
t.
The
 dr
of
a
list
is
the
rest
of
the
list,
that
is,
the
 dr
fun tion
returns
the
part
of
the
list
that
follo
ws
the
rst
item.
Th
us,
while
the
 ar
of
the
list
'(rose
violet
daisy
butter up)
is
rose,
the
rest
of
the
list,
the
v
alue
returned
b
y
the
 dr
fun tion,
is
(violet
daisy
butter up).

82
Chapter
7:
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
Y
ou
 an
see
this
b
y
ev
aluating
the
follo
wing
in
the
usual
w
a
y:
( dr
'(rose
violet
daisy
butter up))
When
y
ou
ev
aluate
this,
(violet
daisy
butter up)
will
app
ear
in
the
e 
ho
area.
Lik
e
 ar,
 dr
do
es
not
remo
v
e
an
y
elemen
ts
from
the
list|it
just
returns
a
rep
ort
of
what
the
se ond
and
subsequen
t
elemen
ts
are.
In iden
tally
,
in
the
example,
the
list
of
o
w
ers
is
quoted.
If
it
w
ere
not,
the
Lisp
in
terpreter
w
ould
try
to
ev
aluate
the
list
b
y
 alling
rose
as
a
fun tion.
In
this
example,
w
e
do
not
w
an
t
to
do
that.
Clearly
,
a
more
reasonable
name
for
 dr
w
ould
b
e
rest.
(There
is
a
lesson
here:
when
y
ou
name
new
fun tions,
 onsider
v
ery
 arefully
what
y
ou
are
doing,
sin e
y
ou
ma
y
b
e
stu 
k
with
the
names
for
far
longer
than
y
ou
exp
e t.
The
reason
this
do
 umen
t
p
erp
etuates
these
names
is
that
the
Ema s
Lisp
sour e
 o
de
uses
them,
and
if
I
did
not
use
them,
y
ou
w
ould
ha
v
e
a
hard
time
reading
the
 o
de;
but
do,
please,
try
to
a
v
oid
using
these
terms
y
ourself.
The
p
eople
who
 ome
after
y
ou
will
b
e
grateful
to
y
ou.)
When
 ar
and
 dr
are
applied
to
a
list
made
up
of
sym
b
ols,
su 
h
as
the
list
(pine
fir
oak
maple),
the
elemen
t
of
the
list
returned
b
y
the
fun tion
 ar
is
the
sym
b
ol
pine
without
an
y
paren
theses
around
it.
pine
is
the
rst
elemen
t
in
the
list.
Ho
w
ev
er,
the
 dr
of
the
list
is
a
list
itself,
(fir
oak
maple),
as
y
ou
 an
see
b
y
ev
aluating
the
follo
wing
expressions
in
the
usual
w
a
y:
( ar
'(pine
fir
oak
maple))
( dr
'(pine
fir
oak
maple))
On
the
other
hand,
in
a
list
of
lists,
the
rst
elemen
t
is
itself
a
list.
 ar
returns
this
rst
elemen
t
as
a
list.
F
or
example,
the
follo
wing
list
 on
tains
three
sub-lists,
a
list
of
 arniv
ores,
a
list
of
herbiv
ores
and
a
list
of
sea
mammals:
( ar
'((lion
tiger
 heetah)
(gazelle
antelope
zebra)
(whale
dolphin
seal)))
In
this
example,
the
rst
elemen
t
or
 ar
of
the
list
is
the
list
of
 arniv
ores,
(lion
tiger
 heetah),
and
the
rest
of
the
list
is
((gazelle
antelope
zebra)
(whale
dolphin
seal)).
( dr
'((lion
tiger
 heetah)
(gazelle
antelope
zebra)
(whale
dolphin
seal)))
It
is
w
orth
sa
ying
again
that
 ar
and
 dr
are
non-destru tiv
e|that
is,
they
do
not
mo
dify
or
 
hange
lists
to
whi 
h
they
are
applied.
This
is
v
ery
imp
ortan
t
for
ho
w
they
are
used.

 ons
83
Also,
in
the
rst
 
hapter,
in
the
dis ussion
ab
out
atoms,
I
said
that
in
Lisp,
\ ertain
kinds
of
atom,
su 
h
as
an
arra
y
,
 an
b
e
separated
in
to
parts;
but
the
me 
hanism
for
doing
this
is
dieren
t
from
the
me 
hanism
for
splitting
a
list.
As
far
as
Lisp
is
 on erned,
the
atoms
of
a
list
are
unsplittable."
(See
Se tion
1.1.1,
\Lisp
A
toms",
page
1.)
The
 ar
and
 dr
fun tions
are
used
for
splitting
lists
and
are
 onsidered
fundamen
tal
to
Lisp.
Sin e
they
 annot
split
or
gain
a  ess
to
the
parts
of
an
arra
y
,
an
arra
y
is
 onsidered
an
atom.
Con
v
ersely
,
the
other
fundamen
tal
fun tion,
 ons,
 an
put
together
or
 onstru t
a
list,
but
not
an
arra
y
.
(Arra
ys
are
handled
b
y
arra
y-sp
e i 
fun tions.
See
se tion
\Arra
ys"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
7.2
 ons
The
 ons
fun tion
 onstru ts
lists;
it
is
the
in
v
erse
of
 ar
and
 dr.
F
or
example,
 ons
 an
b
e
used
to
mak
e
a
four
elemen
t
list
from
the
three
elemen
t
list,
(fir
oak
maple):
( ons
'pine
'(fir
oak
maple))
After
ev
aluating
this
list,
y
ou
will
see
(pine
fir
oak
maple)
app
ear
in
the
e 
ho
area.
 ons
puts
a
new
elemen
t
at
the
b
eginning
of
a
list;
it
atta 
hes
or
pushes
elemen
ts
on
to
the
list.
 ons
m
ust
ha
v
e
a
list
to
atta 
h
to.
1
Y
ou
 annot
start
from
absolutely
nothing.
If
y
ou
are
building
a
list,
y
ou
need
to
pro
vide
at
least
an
empt
y
list
at
the
b
eginning.
Here
is
a
series
of
 ons
expressions
that
build
up
a
list
of
o
w
ers.
If
y
ou
are
reading
this
in
Info
in
GNU
Ema s,
y
ou
 an
ev
aluate
ea 
h
of
the
expressions
in
the
usual
w
a
y;
the
v
alue
is
prin
ted
in
this
text
after
`
)
',
whi 
h
y
ou
ma
y
read
as
`ev
aluates
to'.
( ons
'butter up
())
)
(butter up)
( ons
'daisy
'(butter up))
)
(daisy
butter up)
( ons
'violet
'(daisy
butter up))
)
(violet
daisy
butter up)
( ons
'rose
'(violet
daisy
butter up))
)
(rose
violet
daisy
butter up)
In
the
rst
example,
the
empt
y
list
is
sho
wn
as
()
and
a
list
made
up
of
butter up
follo
w
ed
b
y
the
empt
y
list
is
 onstru ted.
As
y
ou
 an
see,
the
empt
y
list
is
not
sho
wn
in
the
list
that
w
as
 onstru ted.
All
that
y
ou
see
is
(butter up).
The
empt
y
list
is
not
 oun
ted
as
an
elemen
t
of
a
list
1
A tually
,
y
ou
 an
 ons
an
elemen
t
to
an
atom
to
pro
du e
a
dotted
pair.
Dotted
pairs
are
not
dis ussed
here;
see
se tion
\Dotted
P
air
Notation"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.

84
Chapter
7:
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
b
e ause
there
is
nothing
in
an
empt
y
list.
Generally
sp
eaking,
an
empt
y
list
is
in
visible.
The
se ond
example,
( ons
'daisy
'(butter up))
 onstru ts
a
new,
t
w
o
elemen
t
list
b
y
putting
daisy
in
fron
t
of
butter up;
and
the
third
example
 onstru ts
a
three
elemen
t
list
b
y
putting
violet
in
fron
t
of
daisy
and
butter up.
7.2.1
Find
the
Length
of
a
List:
length
Y
ou
 an
nd
out
ho
w
man
y
elemen
ts
there
are
in
a
list
b
y
using
the
Lisp
fun tion
length,
as
in
the
follo
wing
examples:
(length
'(butter up))
)
1
(length
'(daisy
butter up))
)
2
(length
( ons
'violet
'(daisy
butter up)))
)
3
In
the
third
example,
the
 ons
fun tion
is
used
to
 onstru t
a
three
elemen
t
list
whi 
h
is
then
passed
to
the
length
fun tion
as
its
argumen
t.
W
e
 an
also
use
length
to
 oun
t
the
n
um
b
er
of
elemen
ts
in
an
empt
y
list:
(length
())
)
0
As
y
ou
w
ould
exp
e t,
the
n
um
b
er
of
elemen
ts
in
an
empt
y
list
is
zero.
An
in
teresting
exp
erimen
t
is
to
nd
out
what
happ
ens
if
y
ou
try
to
nd
the
length
of
no
list
at
all;
that
is,
if
y
ou
try
to
 all
length
without
giving
it
an
argumen
t,
not
ev
en
an
empt
y
list:
(length
)
What
y
ou
see,
if
y
ou
ev
aluate
this,
is
the
error
message
Wrong
number
of
arguments:
#<subr
length>,
0
This
means
that
the
fun tion
re eiv
es
the
wrong
n
um
b
er
of
argumen
ts,
zero,
when
it
exp
e ts
some
other
n
um
b
er
of
argumen
ts.
In
this
 ase,
one
argumen
t
is
exp
e ted,
the
argumen
t
b
eing
a
list
whose
length
the
fun tion
is
measuring.
(Note
that
one
list
is
one
argumen
t,
ev
en
if
the
list
has
man
y
elemen
ts
inside
it.)
The
part
of
the
error
message
that
sa
ys
`#<subr
length>'
is
the
name
of
the
fun tion.
This
is
written
with
a
sp
e ial
notation,
`#<subr',
that
indi ates
that
the
fun tion
length
is
one
of
the
primitiv
e
fun tions
written
in
C
rather
than
in
Ema s
Lisp.
(`subr'
is
an
abbreviation
for
`subroutine'.)
See
se tion
\What
Is
a
F
un tion?"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
subroutines.

nth dr
85
7.3
nth dr
The
nth dr
fun tion
is
asso
 iated
with
the
 dr
fun tion.
What
it
do
es
is
tak
e
the
 dr
of
a
list
rep
eatedly
.
If
y
ou
tak
e
the
 dr
of
the
list
(pine
fir
oak
maple),
y
ou
will
b
e
returned
the
list
(fir
oak
maple).
If
y
ou
rep
eat
this
on
what
w
as
returned,
y
ou
will
b
e
returned
the
list
(oak
maple).
(Of
 ourse,
rep
eated
 dring
on
the
original
list
will
just
giv
e
y
ou
the
original
 dr
sin e
the
fun tion
do
es
not
 
hange
the
list.
Y
ou
need
to
ev
aluate
the
 dr
of
the
 dr
and
so
on.)
If
y
ou
 on
tin
ue
this,
ev
en
tually
y
ou
will
b
e
returned
an
empt
y
list,
whi 
h
in
this
 ase,
instead
of
b
eing
sho
wn
as
()
is
sho
wn
as
nil.
F
or
review,
here
is
a
series
of
rep
eated
 drs,
the
text
follo
wing
the
`
)
'
sho
ws
what
is
returned.
( dr
'(pine
fir
oak
maple))
)
(fir
oak
maple)
( dr
'(fir
oak
maple))
)
(oak
maple)
( dr
'(oak
maple))
)
(maple)
( dr
'(maple))
)
nil
( dr
'nil)
)
nil
( dr
())
)
nil
Y
ou
 an
also
do
sev
eral
 drs
without
prin
ting
the
v
alues
in
b
et
w
een,
lik
e
this:
( dr
( dr
'(pine
fir
oak
maple)))
)
(oak
maple)
In
this
example,
the
Lisp
in
terpreter
ev
aluates
the
innermost
list
rst.
The
innermost
list
is
quoted,
so
it
just
passes
the
list
as
it
is
to
the
innermost
 dr.
This
 dr
passes
a
list
made
up
of
the
se ond
and
subsequen
t
elemen
ts
of
the
list
to
the
outermost
 dr,
whi 
h
pro
du es
a
list
 omp
osed
of
the
third
and
subsequen
t
elemen
ts
of
the
original
list.
In
this
example,
the
 dr
fun tion
is
rep
eated
and
returns
a
list
that
 onsists
of
the
original
list
without
its
rst
t
w
o
elemen
ts.
The
nth dr
fun tion
do
es
the
same
as
rep
eating
the
 all
to
 dr.
In
the
follo
wing
example,
the
argumen
t
2
is
passed
to
the
fun tion
nth dr,
along
with
the
list,
and
the
v
alue
returned
is
the
list
without
its
rst
t
w
o
items,
whi 
h
is
exa tly
the
same
as
rep
eating
 dr
t
wi e
on
the
list:
(nth dr
2
'(pine
fir
oak
maple))
)
(oak
maple)

86
Chapter
7:
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
Using
the
original
four
elemen
t
list,
w
e
 an
see
what
happ
ens
when
v
arious
n
umeri 
argumen
ts
are
passed
to
nth dr,
in luding
0,
1,
and
5:
;;
Lea
v
e
the
list
as
it
w
as.
(nth dr
0
'(pine
fir
oak
maple))
)
(pine
fir
oak
maple)
;;
Return
a
 op
y
without
the
rst
elemen
t.
(nth dr
1
'(pine
fir
oak
maple))
)
(fir
oak
maple)
;;
Return
a
 op
y
of
the
list
without
three
elemen
ts.
(nth dr
3
'(pine
fir
oak
maple))
)
(maple)
;;
Return
a
 op
y
la 
king
all
four
elemen
ts.
(nth dr
4
'(pine
fir
oak
maple))
)
nil
;;
Return
a
 op
y
la 
king
all
elemen
ts.
(nth dr
5
'(pine
fir
oak
maple))
)
nil
7.4
nth
The
nth dr
fun tion
tak
es
the
 dr
of
a
list
rep
eatedly
.
The
nth
fun tion
tak
es
the
 ar
of
the
result
returned
b
y
nth dr.
It
returns
the
Nth
elemen
t
of
the
list.
Th
us,
if
it
w
ere
not
dened
in
C
for
sp
eed,
the
denition
of
nth
w
ould
b
e:
(defun
nth
(n
list)
"Returns
the
Nth
element
of
LIST.
N
 ounts
from
zero.
If
LIST
is
not
that
long,
nil
is
returned."
( ar
(nth dr
n
list)))
(Originally
,
nth
w
as
dened
in
Ema s
Lisp
in
`subr.el',
but
its
denition
w
as
redone
in
C
in
the
1980s.)
The
nth
fun tion
returns
a
single
elemen
t
of
a
list.
This
 an
b
e
v
ery
 on
v
enien
t.
Note
that
the
elemen
ts
are
n
um
b
ered
from
zero,
not
one.
That
is
to
sa
y
,
the
rst
elemen
t
of
a
list,
its
 ar
is
the
zeroth
elemen
t.
This
is
 alled
`zero-based'
 oun
ting
and
often
b
others
p
eople
who
are
a  ustomed
to
the
rst
elemen
t
in
a
list
b
eing
n
um
b
er
one,
whi 
h
is
`one-based'.

set dr
87
F
or
example:
(nth
0
'("one"
"two"
"three"))
)
"one"
(nth
1
'("one"
"two"
"three"))
)
"two"
It
is
w
orth
men
tioning
that
nth,
lik
e
nth dr
and
 dr,
do
es
not
 
hange
the
original
list|the
fun tion
is
non-destru tiv
e.
This
is
in
sharp
 on
trast
to
the
set ar
and
set dr
fun tions.
7.5
set ar
As
y
ou
migh
t
guess
from
their
names,
the
set ar
and
set dr
fun tions
set
the
 ar
or
the
 dr
of
a
list
to
a
new
v
alue.
They
a tually
 
hange
the
original
list,
unlik
e
 ar
and
 dr
whi 
h
lea
v
e
the
original
list
as
it
w
as.
One
w
a
y
to
nd
out
ho
w
this
w
orks
is
to
exp
erimen
t.
W
e
will
start
with
the
set ar
fun tion.
First,
w
e
 an
mak
e
a
list
and
then
set
the
v
alue
of
a
v
ariable
to
the
list,
using
the
setq
fun tion.
Here
is
a
list
of
animals:
(setq
animals
'(antelope
giraffe
lion
tiger))
If
y
ou
are
reading
this
in
Info
inside
of
GNU
Ema s,
y
ou
 an
ev
aluate
this
expression
in
the
usual
fashion,
b
y
p
ositioning
the
 ursor
after
the
expression
and
t
yping
C-x
C-e.
(I'm
doing
this
righ
t
here
as
I
write
this.
This
is
one
of
the
adv
an
tages
of
ha
ving
the
in
terpreter
built
in
to
the
 omputing
en
vironmen
t.)
When
w
e
ev
aluate
the
v
ariable
animals,
w
e
see
that
it
is
b
ound
to
the
list
(antelope
giraffe
lion
tiger):
animals
)
(antelope
giraffe
lion
tiger)
Put
another
w
a
y
,
the
v
ariable
animals
p
oin
ts
to
the
list
(antelope
giraffe
lion
tiger).
Next,
ev
aluate
the
fun tion
set ar
while
passing
it
t
w
o
argumen
ts,
the
v
ariable
animals
and
the
quoted
sym
b
ol
hippopotamus;
this
is
done
b
y
writing
the
three
elemen
t
list
(set ar
animals
'hippopotamus)
and
then
ev
aluating
it
in
the
usual
fashion:
(set ar
animals
'hippopotamus)
After
ev
aluating
this
expression,
ev
aluate
the
v
ariable
animals
again.
Y
ou
will
see
that
the
list
of
animals
has
 
hanged:
animals
)
(hippopotamus
giraffe
lion
tiger)
The
rst
elemen
t
on
the
list,
antelope
is
repla ed
b
y
hippopotamus.

88
Chapter
7:
 ar,
 dr,
 ons:
F
undamen
tal
F
un tions
So
w
e
 an
see
that
set ar
did
not
add
a
new
elemen
t
to
the
list
as
 ons
w
ould
ha
v
e;
it
repla ed
giraffe
with
hippopotamus;
it
 hange
d
the
list.
7.6
set dr
The
set dr
fun tion
is
similar
to
the
set ar
fun tion,
ex ept
that
the
fun tion
repla es
the
se ond
and
subsequen
t
elemen
ts
of
a
list
rather
than
the
rst
elemen
t.
T
o
see
ho
w
this
w
orks,
set
the
v
alue
of
the
v
ariable
to
a
list
of
domesti-
 ated
animals
b
y
ev
aluating
the
follo
wing
expression:
(setq
domesti ated-animals
'(horse
 ow
sheep
goat))
If
y
ou
no
w
ev
aluate
the
list,
y
ou
will
b
e
returned
the
list
(horse
 ow
sheep
goat):
domesti ated-animals
)
(horse
 ow
sheep
goat)
Next,
ev
aluate
set dr
with
t
w
o
argumen
ts,
the
name
of
the
v
ariable
whi 
h
has
a
list
as
its
v
alue,
and
the
list
to
whi 
h
the
 dr
of
the
rst
list
will
b
e
set;
(set dr
domesti ated-animals
'( at
dog))
If
y
ou
ev
aluate
this
expression,
the
list
( at
dog)
will
app
ear
in
the
e 
ho
area.
This
is
the
v
alue
returned
b
y
the
fun tion.
The
result
w
e
are
in
ter-
ested
in
is
the
\side
ee t",
whi 
h
w
e
 an
see
b
y
ev
aluating
the
v
ariable
domesti ated-animals:
domesti ated-animals
)
(horse
 at
dog)
Indeed,
the
list
is
 
hanged
from
(horse
 ow
sheep
goat)
to
(horse
 at
dog).
The
 dr
of
the
list
is
 
hanged
from
( ow
sheep
goat)
to
( at
dog).
7.7
Exer ise
Constru t
a
list
of
four
birds
b
y
ev
aluating
sev
eral
expressions
with
 ons.
Find
out
what
happ
ens
when
y
ou
 ons
a
list
on
to
itself.
Repla e
the
rst
elemen
t
of
the
list
of
four
birds
with
a
sh.
Repla e
the
rest
of
that
list
with
a
list
of
other
sh.

zap-to- har
89
8
Cutting
and
Storing
T
ext
Whenev
er
y
ou
 ut
or
 lip
text
out
of
a
buer
with
a
`kill'
 ommand
in
GNU
Ema s,
it
is
stored
in
a
list
and
y
ou
 an
bring
it
ba 
k
with
a
`y
ank'
 ommand.
(The
use
of
the
w
ord
`kill'
in
Ema s
for
pro
 esses
whi 
h
sp
e i ally
do
not
destro
y
the
v
alues
of
the
en
tities
is
an
unfortunate
histori al
a  iden
t.
A
m
u 
h
more
appropriate
w
ord
w
ould
b
e
` lip'
sin e
that
is
what
the
kill
 ommands
do;
they
 lip
text
out
of
a
buer
and
put
it
in
to
storage
from
whi 
h
it
 an
b
e
brough
t
ba 
k.
I
ha
v
e
often
b
een
tempted
to
repla e
globally
all
o
  urren es
of
`kill'
in
the
Ema s
sour es
with
` lip'
and
all
o
  urren es
of
`killed'
with
` lipp
ed'.)
When
text
is
 ut
out
of
a
buer,
it
is
stored
on
a
list.
Su  essiv
e
pie es
of
text
are
stored
on
the
list
su  essiv
ely
,
so
the
list
migh
t
lo
ok
lik
e
this:
("a
pie e
of
text"
"previous
pie e")
The
fun tion
 ons
 an
b
e
used
to
add
a
pie e
of
text
to
the
list,
lik
e
this:
( ons
"another
pie e"
'("a
pie e
of
text"
"previous
pie e"))
If
y
ou
ev
aluate
this
expression,
a
list
of
three
elemen
ts
will
app
ear
in
the
e 
ho
area:
("another
pie e"
"a
pie e
of
text"
"previous
pie e")
With
the
 ar
and
nth dr
fun tions,
y
ou
 an
retriev
e
whi 
hev
er
pie e
of
text
y
ou
w
an
t.
F
or
example,
in
the
follo
wing
 o
de,
nth dr
1
...
returns
the
list
with
the
rst
item
remo
v
ed;
and
the
 ar
returns
the
rst
elemen
t
of
that
remainder|the
se ond
elemen
t
of
the
original
list:
( ar
(nth dr
1
'("another
pie e"
"a
pie e
of
text"
"previous
pie e")))
)
"a
pie e
of
text"
The
a tual
fun tions
in
Ema s
are
more
 omplex
than
this,
of
 ourse.
The
 o
de
for
 utting
and
retrieving
text
has
to
b
e
written
so
that
Ema s
 an
gure
out
whi 
h
elemen
t
in
the
list
y
ou
w
an
t|the
rst,
se ond,
third,
or
whatev
er.
In
addition,
when
y
ou
get
to
the
end
of
the
list,
Ema s
should
giv
e
y
ou
the
rst
elemen
t
of
the
list,
rather
than
nothing
at
all.
The
list
that
holds
the
pie es
of
text
is
 alled
the
kill
ring.
This
 
hapter
leads
up
to
a
des ription
of
the
kill
ring
and
ho
w
it
is
used
b
y
rst
tra ing
ho
w
the
zap-to- har
fun tion
w
orks.
This
fun tion
uses
(or
` alls')
a
fun tion
that
in
v
ok
es
a
fun tion
that
manipulates
the
kill
ring.
Th
us,
b
efore
rea 
hing
the
moun
tains,
w
e
 lim
b
the
fo
othills.
A
subsequen
t
 
hapter
des rib
es
ho
w
text
that
is
 ut
from
the
buer
is
retriev
ed.
See
Chapter
10,
\Y
anking
T
ext
Ba 
k",
page
117.

90
Chapter
8:
Cutting
and
Storing
T
ext
8.1
zap-to- har
The
zap-to- har
fun tion
barely
 
hanged
b
et
w
een
GNU
Ema s
v
ersion
19
and
GNU
Ema s
v
ersion
21.
Ho
w
ev
er,
zap-to- har
 alls
another
fun -
tion,
kill-region,
whi 
h
enjo
y
ed
a
ma
jor
rewrite
on
the
w
a
y
to
v
ersion
21.
The
kill-region
fun tion
in
Ema s
19
is
 omplex,
but
do
es
not
use
 o
de
that
is
imp
ortan
t
at
this
time.
W
e
will
skip
it.
The
kill-region
fun tion
in
Ema s
21
is
easier
to
read
than
the
same
fun tion
in
Ema s
19
and
in
tro
du es
a
v
ery
imp
ortan
t
 on ept,
that
of
error
handling.
W
e
will
w
alk
through
the
fun tion.
But
rst,
let
us
lo
ok
at
the
in
tera tiv
e
zap-to- har
fun tion.
The
GNU
Ema s
v
ersion
19
and
v
ersion
21
implemen
tations
of
the
zap-
to- har
fun tion
are
nearly
iden
ti al
in
form,
and
they
w
ork
alik
e.
The
fun tion
remo
v
es
the
text
in
the
region
b
et
w
een
the
lo
 ation
of
the
 ursor
(i.e.,
of
p
oin
t)
up
to
and
in luding
the
next
o
  urren e
of
a
sp
e ied
 
hara -
ter.
The
text
that
zap-to- har
remo
v
es
is
put
in
the
kill
ring;
and
it
 an
b
e
retriev
ed
from
the
kill
ring
b
y
t
yping
C-y
(yank).
If
the
 ommand
is
giv
en
an
argumen
t,
it
remo
v
es
text
through
that
n
um
b
er
of
o
  urren es.
Th
us,
if
the
 ursor
w
ere
at
the
b
eginning
of
this
sen
ten e
and
the
 
hara ter
w
ere
`s',
`Thus'
w
ould
b
e
remo
v
ed.
If
the
argumen
t
w
ere
t
w
o,
`Thus,
if
the
 urs'
w
ould
b
e
remo
v
ed,
up
to
and
in luding
the
`s'
in
` ursor'.
If
the
sp
e ied
 
hara ter
is
not
found,
zap-to- har
will
sa
y
\Sear 
h
failed",
tell
y
ou
the
 
hara ter
y
ou
t
yp
ed,
and
not
remo
v
e
an
y
text.
In
order
to
determine
ho
w
m
u 
h
text
to
remo
v
e,
zap-to- har
uses
a
sear 
h
fun tion.
Sear 
hes
are
used
extensiv
ely
in
 o
de
that
manipulates
text,
and
w
e
will
fo
 us
atten
tion
on
them
as
w
ell
as
on
the
deletion
 ommand.
Here
is
the
 omplete
text
of
the
v
ersion
19
implemen
tation
of
the
fun tion:
(defun
zap-to- har
(arg
 har)
;
version
19
implementation
"Kill
up
to
and
in luding
ARG'th
o  urren e
of
CHAR.
Goes
ba kward
if
ARG
is
negative;
error
if
CHAR
not
found."
(intera tive
"*p\n Zap
to
 har:
")
(kill-region
(point)
(progn
(sear h-forward
( har-to-string
 har)
nil
nil
arg)
(point))))
8.1.1
The
intera tive
Expression
The
in
tera tiv
e
expression
in
the
zap-to- har
 ommand
lo
oks
lik
e
this:
(intera tive
"*p\n Zap
to
 har:
")
The
part
within
quotation
marks,
"*p\n Zap
to
 har:
",
sp
e ies
three
dieren
t
things.
First,
and
most
simply
,
the
asterisk,
`*',
 auses
an
error
to

The
sear h-forward
F
un tion
91
b
e
signalled
if
the
buer
is
read-only
.
This
means
that
if
y
ou
try
zap-to-
 har
in
a
read-only
buer
y
ou
will
not
b
e
able
to
remo
v
e
text,
and
y
ou
will
re eiv
e
a
message
that
sa
ys
\Buer
is
read-only";
y
our
terminal
ma
y
b
eep
at
y
ou
as
w
ell.
The
v
ersion
21
implemen
tation
do
es
not
ha
v
e
the
asterisk,
`*'.
The
fun -
tion
w
orks
the
same
as
in
v
ersion
19:
in
b
oth
 ases,
it
 annot
remo
v
e
text
from
a
read-only
buer
but
the
fun tion
do
es
 op
y
the
text
that
w
ould
ha
v
e
b
een
remo
v
ed
to
the
kill
ring.
Also,
in
b
oth
 ases,
y
ou
see
an
error
message.
Ho
w
ev
er,
the
v
ersion
19
implemen
tation
 opies
text
from
a
read-only
buer
only
b
e ause
of
a
mistak
e
in
the
implemen
tation
of
intera tive.
A  ording
to
the
do
 umen
tation
for
intera tive,
the
asterisk,
`*',
should
prev
en
t
the
zap-to- har
fun tion
from
doing
an
ything
at
all
when
the
buer
is
read
only
.
The
fun tion
should
not
 op
y
the
text
to
the
kill
ring.
It
is
a
bug
that
it
do
es.
In
v
ersion
21,
intera tive
is
implemen
ted
 orre tly
.
So
the
asterisk,
`*',
had
to
b
e
remo
v
ed
from
the
in
tera tiv
e
sp
e i ation.
If
y
ou
insert
an
`*'
and
ev
aluate
the
fun tion
denition,
then
the
next
time
y
ou
run
the
zap-to- har
fun tion
on
a
read-only
buer,
y
ou
will
not
 op
y
an
y
text.
That
 
hange
aside,
and
a
 
hange
to
the
do
 umen
tation,
the
t
w
o
v
ersions
of
the
zap-to- har
fun tion
are
iden
ti al.
Let
us
 on
tin
ue
with
the
in
tera tiv
e
sp
e i ation.
The
se ond
part
of
"*p\n Zap
to
 har:
"
is
the
`p'.
This
part
is
sepa-
rated
from
the
next
part
b
y
a
newline,
`\n'.
The
`p'
means
that
the
rst
argumen
t
to
the
fun tion
will
b
e
passed
the
v
alue
of
a
`pro
 essed
prex'.
The
prex
argumen
t
is
passed
b
y
t
yping
C-u
and
a
n
um
b
er,
or
M-
and
a
n
um
b
er.
If
the
fun tion
is
 alled
in
tera tiv
ely
without
a
prex,
1
is
passed
to
this
argumen
t.
The
third
part
of
"*p\n Zap
to
 har:
"
is
` Zap
to
 har:
'.
In
this
part,
the
lo
w
er
 ase
` '
indi ates
that
intera tive
exp
e ts
a
prompt
and
that
the
argumen
t
will
b
e
a
 
hara ter.
The
prompt
follo
ws
the
` '
and
is
the
string
`Zap
to
 har:
'
(with
a
spa e
after
the
 olon
to
mak
e
it
lo
ok
go
o
d).
What
all
this
do
es
is
prepare
the
argumen
ts
to
zap-to- har
so
they
are
of
the
righ
t
t
yp
e,
and
giv
e
the
user
a
prompt.
8.1.2
The
Bo
dy
of
zap-to- har
The
b
o
dy
of
the
zap-to- har
fun tion
 on
tains
the
 o
de
that
kills
(that
is,
remo
v
es)
the
text
in
the
region
from
the
 urren
t
p
osition
of
the
 ursor
up
to
and
in luding
the
sp
e ied
 
hara ter.
The
rst
part
of
the
 o
de
lo
oks
lik
e
this:
(kill-region
(point)
...
(point)
is
the
 urren
t
p
osition
of
the
 ursor.
The
next
part
of
the
 o
de
is
an
expression
using
progn.
The
b
o
dy
of
the
progn
 onsists
of
 alls
to
sear h-forward
and
point.

92
Chapter
8:
Cutting
and
Storing
T
ext
It
is
easier
to
understand
ho
w
progn
w
orks
after
learning
ab
out
sear h-
forward,
so
w
e
will
lo
ok
at
sear h-forward
and
then
at
progn.
8.1.3
The
sear h-forward
F
un tion
The
sear h-forward
fun tion
is
used
to
lo
 ate
the
zapp
ed-for- 
hara ter
in
zap-to- har.
If
the
sear 
h
is
su  essful,
sear h-forward
lea
v
es
p
oin
t
immediately
after
the
last
 
hara ter
in
the
target
string.
(In
zap-to- har,
the
target
string
is
just
one
 
hara ter
long.)
If
the
sear 
h
is
ba 
kw
ards,
sear h-forward
lea
v
es
p
oin
t
just
b
efore
the
rst
 
hara ter
in
the
target.
Also,
sear h-forward
returns
t
for
true.
(Mo
ving
p
oin
t
is
therefore
a
`side
ee t'.)
In
zap-to- har,
the
sear h-forward
fun tion
lo
oks
lik
e
this:
(sear h-forward
( har-to-string
 har)
nil
nil
arg)
The
sear h-forward
fun tion
tak
es
four
argumen
ts:
1.
The
rst
argumen
t
is
the
target,
what
is
sear 
hed
for.
This
m
ust
b
e
a
string,
su 
h
as
`"z"'.
As
it
happ
ens,
the
argumen
t
passed
to
zap-to- har
is
a
single
 
hara -
ter.
Be ause
of
the
w
a
y
 omputers
are
built,
the
Lisp
in
terpreter
ma
y
treat
a
single
 
hara ter
as
b
eing
dieren
t
from
a
string
of
 
hara ters.
Inside
the
 omputer,
a
single
 
hara ter
has
a
dieren
t
ele troni 
format
than
a
string
of
one
 
hara ter.
(A
single
 
hara ter
 an
often
b
e
re orded
in
the
 omputer
using
exa tly
one
b
yte;
but
a
string
ma
y
b
e
longer,
and
the
 omputer
needs
to
b
e
ready
for
this.)
Sin e
the
sear h-forward
fun tion
sear 
hes
for
a
string,
the
 
hara ter
that
the
zap-to- har
fun -
tion
re eiv
es
as
its
argumen
t
m
ust
b
e
 on
v
erted
inside
the
 omputer
from
one
format
to
the
other;
otherwise
the
sear h-forward
fun tion
will
fail.
The
 har-to-string
fun tion
is
used
to
mak
e
this
 on
v
ersion.
2.
The
se ond
argumen
t
b
ounds
the
sear 
h;
it
is
sp
e ied
as
a
p
osition
in
the
buer.
In
this
 ase,
the
sear 
h
 an
go
to
the
end
of
the
buer,
so
no
b
ound
is
set
and
the
se ond
argumen
t
is
nil.
3.
The
third
argumen
t
tells
the
fun tion
what
it
should
do
if
the
sear 
h
fails|it
 an
signal
an
error
(and
prin
t
a
message)
or
it
 an
return
nil.
A
nil
as
the
third
argumen
t
 auses
the
fun tion
to
signal
an
error
when
the
sear 
h
fails.
4.
The
fourth
argumen
t
to
sear h-forward
is
the
rep
eat
 oun
t|ho
w
man
y
o
  urren es
of
the
string
to
lo
ok
for.
This
argumen
t
is
optional
and
if
the
fun tion
is
 alled
without
a
rep
eat
 oun
t,
this
argumen
t
is
passed
the
v
alue
1.
If
this
argumen
t
is
negativ
e,
the
sear 
h
go
es
ba 
k-
w
ards.

Summing
up
zap-to- har
93
In
template
form,
a
sear h-forward
expression
lo
oks
lik
e
this:
(sear h-forward
"target-string
"
limit-of-sear 
h
what-to-do-if-sear 
h-fails
rep
eat- oun
t
)
W
e
will
lo
ok
at
progn
next.
8.1.4
The
progn
Sp
e ial
F
orm
progn
is
a
sp
e ial
form
that
 auses
ea 
h
of
its
argumen
ts
to
b
e
ev
aluated
in
sequen e
and
then
returns
the
v
alue
of
the
last
one.
The
pre eding
ex-
pressions
are
ev
aluated
only
for
the
side
ee ts
they
p
erform.
The
v
alues
pro
du ed
b
y
them
are
dis arded.
The
template
for
a
progn
expression
is
v
ery
simple:
(progn
b
o
dy
...
)
In
zap-to- har,
the
progn
expression
has
to
do
t
w
o
things:
put
p
oin
t
in
exa tly
the
righ
t
p
osition;
and
return
the
lo
 ation
of
p
oin
t
so
that
kill-
region
will
kno
w
ho
w
far
to
kill
to.
The
rst
argumen
t
to
the
progn
is
sear h-forward.
When
sear h-
forward
nds
the
string,
the
fun tion
lea
v
es
p
oin
t
immediately
after
the
last
 
hara ter
in
the
target
string.
(In
this
 ase
the
target
string
is
just
one
 
hara ter
long.)
If
the
sear 
h
is
ba 
kw
ards,
sear h-forward
lea
v
es
p
oin
t
just
b
efore
the
rst
 
hara ter
in
the
target.
The
mo
v
emen
t
of
p
oin
t
is
a
side
ee t.
The
se ond
and
last
argumen
t
to
progn
is
the
expression
(point).
This
expression
returns
the
v
alue
of
p
oin
t,
whi 
h
in
this
 ase
will
b
e
the
lo
 ation
to
whi 
h
it
has
b
een
mo
v
ed
b
y
sear h-forward.
This
v
alue
is
returned
b
y
the
progn
expression
and
is
passed
to
kill-region
as
kill-region's
se ond
argumen
t.
8.1.5
Summing
up
zap-to- har
No
w
that
w
e
ha
v
e
seen
ho
w
sear h-forward
and
progn
w
ork,
w
e
 an
see
ho
w
the
zap-to- har
fun tion
w
orks
as
a
whole.
The
rst
argumen
t
to
kill-region
is
the
p
osition
of
the
 ursor
when
the
zap-to- har
 ommand
is
giv
en|the
v
alue
of
p
oin
t
at
that
time.
Within
the
progn,
the
sear 
h
fun tion
then
mo
v
es
p
oin
t
to
just
after
the
zapp
ed-
to- 
hara ter
and
point
returns
the
v
alue
of
this
lo
 ation.
The
kill-region
fun tion
puts
together
these
t
w
o
v
alues
of
p
oin
t,
the
rst
one
as
the
b
eginning
of
the
region
and
the
se ond
one
as
the
end
of
the
region,
and
remo
v
es
the
region.
The
progn
sp
e ial
form
is
ne essary
b
e ause
the
kill-region
 ommand
tak
es
t
w
o
argumen
ts;
and
it
w
ould
fail
if
sear h-forward
and
point
ex-

94
Chapter
8:
Cutting
and
Storing
T
ext
pressions
w
ere
written
in
sequen e
as
t
w
o
additional
argumen
ts.
The
progn
expression
is
a
single
argumen
t
to
kill-region
and
returns
the
one
v
alue
that
kill-region
needs
for
its
se ond
argumen
t.
8.2
kill-region
The
zap-to- har
fun tion
uses
the
kill-region
fun tion.
This
fun tion
 lips
text
from
a
region
and
 opies
that
text
to
the
kill
ring,
from
whi 
h
it
ma
y
b
e
retriev
ed.
The
Ema s
21
v
ersion
of
that
fun tion
uses
 ondition- ase
and
 opy-
region-as-kill,
b
oth
of
whi 
h
w
e
will
explain.
 ondition- ase
is
an
imp
ortan
t
sp
e ial
form.
In
essen e,
the
kill-region
fun tion
 alls
 ondition- ase,
whi 
h
tak
es
three
argumen
ts.
In
this
fun tion,
the
rst
argumen
t
do
es
nothing.
The
se ond
argumen
t
 on
tains
the
 o
de
that
do
es
the
w
ork
when
all
go
es
w
ell.
The
third
argumen
t
 on
tains
the
 o
de
that
is
 alled
in
the
ev
en
t
of
an
error.
W
e
will
go
through
the
 ondition- ase
 o
de
in
a
momen
t.
First,
let
us
lo
ok
at
the
 omplete
denition
of
kill-region,
with
 ommen
ts
added:
(defun
kill-region
(beg
end)
"Kill
between
point
and
mark.
The
text
is
deleted
but
saved
in
the
kill
ring."
(intera tive
"r")
;;
1.
` ondition- ase'
takes
three
arguments.
;;
If
the
first
argument
is
nil,
as
it
is
here,
;;
information
about
the
error
signal
is
not
;;
stored
for
use
by
another
fun tion.
( ondition- ase
nil
;;
2.
The
se ond
argument
to
` ondition- ase'
;;
tells
the
Lisp
interpreter
what
to
do
when
all
goes
well.
;;
The
`delete-and-extra t-region'
fun tion
usually
does
the
;;
work.
If
the
beginning
and
ending
of
the
region
are
both
;;
the
same,
then
the
variable
`string'
will
be
empty,
or
nil
(let
((string
(delete-and-extra t-region
beg
end)))
;;
`when'
is
an
`if'
 lause
that
 annot
take
an
`else-part'.
;;
Ema s
normally
sets
the
value
of
`last- ommand'
to
the
;;
previous
 ommand.

 ondition- ase
95
;;
`kill-append'
 on atenates
the
new
string
and
the
old.
;;
`kill-new'
inserts
text
into
a
new
item
in
the
kill
ring.
(when
string
(if
(eq
last- ommand
'kill-region)
;;
if
true,
prepend
string
(kill-append
string
(<
end
beg))
(kill-new
string)))
(setq
this- ommand
'kill-region))
;;
3.
The
third
argument
to
` ondition- ase'
tells
the
interpreter
;;
what
to
do
with
an
error.
;;
The
third
argument
has
a
 onditions
part
and
a
body
part.
;;
If
the
 onditions
are
met
(in
this
 ase,
;;
if
text
or
buffer
is
read-only)
;;
then
the
body
is
exe uted.
((buffer-read-only
text-read-only)
;;
this
is
the
if-part
;;
then...
( opy-region-as-kill
beg
end)
(if
kill-read-only-ok
;;
usually
this
variable
is
nil
(message
"Read
only
text
 opied
to
kill
ring")
;;
or
else,
signal
an
error
if
the
buffer
is
read-only;
(barf-if-buffer-read-only)
;;
and,
in
any
 ase,
signal
that
the
text
is
read-only.
(signal
'text-read-only
(list
( urrent-buffer)))))))
8.2.1
 ondition- ase
As
w
e
ha
v
e
seen
earlier
(see
Se tion
1.3,
\Generate
an
Error
Message",
page
4),
when
the
Ema s
Lisp
in
terpreter
has
trouble
ev
aluating
an
expres-
sion,
it
pro
vides
y
ou
with
help;
in
the
jargon,
this
is
 alled
\signaling
an
error".
Usually
,
the
 omputer
stops
the
program
and
sho
ws
y
ou
a
message.
Ho
w
ev
er,
some
programs
undertak
e
 ompli ated
a tions.
They
should
not
simply
stop
on
an
error.
In
the
kill-region
fun tion,
the
most
lik
ely
error
is
that
y
ou
will
try
to
kill
text
that
is
read-only
and
 annot
b
e
remo
v
ed.
So
the
kill-region
fun tion
 on
tains
 o
de
to
handle
this
 ir umstan e.
This
 o
de,
whi 
h
mak
es
up
the
b
o
dy
of
the
kill-region
fun tion,
is
inside
of
a
 ondition- ase
sp
e ial
form.
The
template
for
 ondition- ase
lo
oks
lik
e
this:
( ondition- ase
v
ar
b
o
dyform
error-handler
...
)
The
se ond
argumen
t,
b
o
dyform,
is
straigh
tforw
ard.
The
 ondition-
 ase
sp
e ial
form
 auses
the
Lisp
in
terpreter
to
ev
aluate
the
 o
de
in
b
o
dy-

96
Chapter
8:
Cutting
and
Storing
T
ext
form.
If
no
error
o
  urs,
the
sp
e ial
form
returns
the
 o
de's
v
alue
and
pro
du es
the
side-ee ts,
if
an
y
.
In
short,
the
b
o
dyform
part
of
a
 ondition- ase
expression
determines
what
should
happ
en
when
ev
erything
w
orks
 orre tly
.
Ho
w
ev
er,
if
an
error
o
  urs,
among
its
other
a tions,
the
fun tion
gener-
ating
the
error
signal
will
dene
one
or
more
error
 ondition
names.
An
error
handler
is
the
third
argumen
t
to
 ondition
 ase.
An
error
handler
has
t
w
o
parts,
a
 ondition-name
and
a
b
o
dy.
If
the
 ondition-name
part
of
an
error
handler
mat 
hes
a
 ondition
name
generated
b
y
an
error,
then
the
b
o
dy
part
of
the
error
handler
is
run.
As
y
ou
will
exp
e t,
the
 ondition-name
part
of
an
error
handler
ma
y
b
e
either
a
single
 ondition
name
or
a
list
of
 ondition
names.
Also,
a
 omplete
 ondition- ase
expression
ma
y
 on
tain
more
than
one
error
handler.
When
an
error
o
  urs,
the
rst
appli able
handler
is
run.
Lastly
,
the
rst
argumen
t
to
the
 ondition- ase
expression,
the
v
ar
argumen
t,
is
sometimes
b
ound
to
a
v
ariable
that
 on
tains
information
ab
out
the
error.
Ho
w
ev
er,
if
that
argumen
t
is
nil,
as
is
the
 ase
in
kill-region,
that
information
is
dis arded.
In
brief,
in
the
kill-region
fun tion,
the
 o
de
 ondition- ase
w
orks
lik
e
this:
If
no
errors,
run
only
this
 o
de
but,
if
errors,
run
this
other
 o
de.
8.2.2
delete-and-extra t-region
A
 ondition- ase
expression
has
t
w
o
parts,
a
part
that
is
ev
aluated
in
the
exp
e tation
that
all
will
go
w
ell,
but
whi 
h
ma
y
generate
an
error;
and
a
part
that
is
ev
aluated
when
there
is
an
error.
First,
let
us
lo
ok
at
the
 o
de
in
kill-region
that
is
run
in
the
exp
e tation
that
all
go
es
w
ell.
This
is
the
 ore
of
the
fun tion.
The
 o
de
lo
oks
lik
e
this:
(let
((string
(delete-and-extra t-region
beg
end)))
(when
string
(if
(eq
last- ommand
'kill-region)
(kill-append
string
(<
end
beg))
(kill-new
string)))
(setq
this- ommand
'kill-region))
It
lo
oks
 ompli ated
b
e ause
w
e
ha
v
e
the
new
fun tions
delete-and-
extra t-region,
kill-append,
and
kill-new
as
w
ell
as
the
new
v
ariables,
last- ommand
and
this- ommand.
The
delete-and-extra t-region
fun tion
is
straigh
tforw
ard.
It
is
a
built-in
fun tion
that
deletes
the
text
in
a
region
(a
side
ee t)
and
also
returns
that
text.
This
is
the
fun tion
that
a tually
remo
v
es
the
text.
(And
if
it
 annot
do
that,
it
signals
the
error.)

delete-and-extra t-regio
n:
Digressing
in
to
C
97
In
this
let
expression,
the
text
that
delete-and-extra t-region
re-
turns
is
pla ed
in
the
lo
 al
v
ariable
 alled
`string'.
This
is
the
text
that
is
remo
v
ed
from
the
buer.
(T
o
b
e
more
pre ise,
the
v
ariable
is
set
to
p
oin
t
to
the
address
of
the
extra ted
text;
to
sa
y
it
is
`pla ed
in'
the
v
ariable
is
simply
a
shorthand.)
If
the
v
ariable
`string'
do
es
p
oin
t
to
text,
that
text
is
added
to
the
kill
ring.
The
v
ariable
will
ha
v
e
a
nil
v
alue
if
no
text
w
as
remo
v
ed.
The
 o
de
uses
when
to
determine
whether
the
v
ariable
`string'
p
oin
ts
to
text.
A
when
statemen
t
is
simply
a
programmers'
 on
v
enien e.
A
when
statemen
t
is
an
if
statemen
t
without
the
p
ossibilit
y
of
an
else
 lause.
In
y
our
mind,
y
ou
 an
repla e
when
with
if
and
understand
what
go
es
on.
That
is
what
the
Lisp
in
terpreter
do
es.
T
e 
hni ally
sp
eaking,
when
is
a
Lisp
ma ro.
A
Lisp
ma ro
enables
y
ou
to
dene
new
 on
trol
 onstru ts
and
other
language
features.
It
tells
the
in
ter-
preter
ho
w
to
 ompute
another
Lisp
expression
whi 
h
will
in
turn
 ompute
the
v
alue.
In
this
 ase,
the
`other
expression'
is
an
if
expression.
F
or
more
ab
out
Lisp
ma ros,
see
se tion
\Ma ros"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
The
C
programming
language
also
pro
vides
ma ros.
These
are
dieren
t,
but
also
useful.
W
e
will
briey
lo
ok
at
C
ma ros
in
Se tion
8.3,
\delete-and-extra t-region:
Digressing
in
to
C",
page
98.
If
the
string
has
 on
ten
t,
then
another
 onditional
expression
is
exe uted.
This
is
an
if
with
b
oth
a
then-part
and
an
else-part.
(if
(eq
last- ommand
'kill-region)
(kill-append
string
(<
end
beg))
(kill-new
string)))
The
then-part
is
ev
aluated
if
the
previous
 ommand
w
as
another
 all
to
kill-region;
if
not,
the
else-part
is
ev
aluated.
last- ommand
is
a
v
ariable
that
 omes
with
Ema s
that
w
e
ha
v
e
not
seen
b
efore.
Normally
,
whenev
er
a
fun tion
is
exe uted,
Ema s
sets
the
v
alue
of
last- ommand
to
the
previous
 ommand.
In
this
segmen
t
of
the
denition,
the
if
expression
 
he 
ks
whether
the
previous
 ommand
w
as
kill-region.
If
it
w
as,
(kill-append
string
(<
end
beg))
 on atenates
a
 op
y
of
the
newly
 lipp
ed
text
to
the
just
previously
 lipp
ed
text
in
the
kill
ring.
(If
the
(<
end
beg))
expression
is
true,
kill-append
prep
ends
the
string
to
the
just
previously
 lipp
ed
text.
F
or
a
detailed
dis-
 ussion,
see
\The
kill-append
fun tion",
page
104.)
If
y
ou
then
y
ank
ba 
k
the
text,
i.e.,
`paste'
it,
y
ou
get
b
oth
pie es
of
text
at
on e.
That
w
a
y
,
if
y
ou
delete
t
w
o
w
ords
in
a
ro
w,
and
then
y
ank
them
ba 
k,
y
ou
get
b
oth
w
ords,
in
their
prop
er
order,
with
one
y
ank.
(The
(<
end
beg))
expression
mak
es
sure
the
order
is
 orre t.)

98
Chapter
8:
Cutting
and
Storing
T
ext
On
the
other
hand,
if
the
previous
 ommand
is
not
kill-region,
then
the
kill-new
fun tion
is
 alled,
whi 
h
adds
the
text
to
the
kill
ring
as
the
latest
item,
and
sets
the
kill-ring-yank-pointer
v
ariable
to
p
oin
t
to
it.
8.3
delete-and-ext
ra
 t
-r
egi
on
:
Digressing
in
to
C
The
zap-to- har
 ommand
uses
the
delete-and-extra t-regio
n
fun -
tion,
whi 
h
in
turn
uses
t
w
o
other
fun tions,
 opy-region-as-kill
and
del_range_1.
The
 opy-region-as-kill
fun tion
will
b
e
des rib
ed
in
a
follo
wing
se tion;
it
puts
a
 op
y
of
the
region
in
the
kill
ring
so
it
 an
b
e
y
ank
ed
ba 
k.
(See
Se tion
8.5,
\ opy-region-as-kill",
page
102.)
The
delete-and-extra t-region
fun tion
remo
v
es
the
 on
ten
ts
of
a
region
and
y
ou
 annot
get
them
ba 
k.
Unlik
e
the
other
 o
de
dis ussed
here,
delete-and-extra t-regio
n
is
not
written
in
Ema s
Lisp;
it
is
written
in
C
and
is
one
of
the
primitiv
es
of
the
GNU
Ema s
system.
Sin e
it
is
v
ery
simple,
I
will
digress
briey
from
Lisp
and
des rib
e
it
here.
Lik
e
man
y
of
the
other
Ema s
primitiv
es,
delete-and-extra t-regio
n
is
written
as
an
instan e
of
a
C
ma ro,
a
ma ro
b
eing
a
template
for
 o
de.
The
 omplete
ma ro
lo
oks
lik
e
this:
DEFUN
("delete-and-extra t-region
",
Fdelete_and_extra t_region,
Sdelete_and_extra t_region,
2,
2,
0,
"Delete
the
text
between
START
and
END
and
return
it.")
(start,
end)
Lisp_Obje t
start,
end;
{
validate_region
(&start,
&end);
return
del_range_1
(XINT
(start),
XINT
(end),
1,
1);
}
Without
going
in
to
the
details
of
the
ma ro
writing
pro
 ess,
let
me
p
oin
t
out
that
this
ma ro
starts
with
the
w
ord
DEFUN.
The
w
ord
DEFUN
w
as
 
hosen
sin e
the
 o
de
serv
es
the
same
purp
ose
as
defun
do
es
in
Lisp.
The
w
ord
DEFUN
is
follo
w
ed
b
y
sev
en
parts
inside
of
paren
theses:

The
rst
part
is
the
name
giv
en
to
the
fun tion
in
Lisp,
delete-and-
extra t-region.

The
se ond
part
is
the
name
of
the
fun tion
in
C,
Fdelete_and_
extra t_region.
By
 on
v
en
tion,
it
starts
with
`F'.
Sin e
C
do
es
not
use
h
yphens
in
names,
unders ores
are
used
instead.

The
third
part
is
the
name
for
the
C
 onstan
t
stru ture
that
re ords
information
on
this
fun tion
for
in
ternal
use.
It
is
the
name
of
the
fun tion
in
C
but
b
egins
with
an
`S'
instead
of
an
`F'.

The
fourth
and
fth
parts
sp
e ify
the
minim
um
and
maxim
um
n
um
b
er
of
argumen
ts
the
fun tion
 an
ha
v
e.
This
fun tion
demands
exa tly
2
argumen
ts.

delete-and-extra t-regio
n:
Digressing
in
to
C
99

The
sixth
part
is
nearly
lik
e
the
argumen
t
that
follo
ws
the
intera tive
de laration
in
a
fun tion
written
in
Lisp:
a
letter
follo
w
ed,
p
erhaps,
b
y
a
prompt.
The
only
dieren e
from
the
Lisp
is
when
the
ma ro
is
 alled
with
no
argumen
ts.
Then
y
ou
write
a
0
(whi 
h
is
a
`n
ull
string'),
as
in
this
ma ro.
If
y
ou
w
ere
to
sp
e ify
argumen
ts,
y
ou
w
ould
pla e
them
b
et
w
een
quo-
tation
marks.
The
C
ma ro
for
goto- har
in ludes
"NGoto
 har:
"
in
this
p
osition
to
indi ate
that
the
fun tion
exp
e ts
a
ra
w
prex,
in
this
 ase,
a
n
umeri al
lo
 ation
in
a
buer,
and
pro
vides
a
prompt.

The
sev
en
th
part
is
a
do
 umen
tation
string,
just
lik
e
the
one
for
a
fun -
tion
written
in
Ema s
Lisp,
ex ept
that
ev
ery
newline
m
ust
b
e
written
expli itly
as
`\n'
follo
w
ed
b
y
a
ba 
kslash
and
 arriage
return.
Th
us,
the
rst
t
w
o
lines
of
do
 umen
tation
for
goto- har
are
written
lik
e
this:
"Set
point
to
POSITION,
a
number
or
marker.\n\
Beginning
of
buffer
is
position
(point-min),
end
is
(point-max).
In
a
C
ma ro,
the
formal
parameters
 ome
next,
with
a
statemen
t
of
what
kind
of
ob
je t
they
are,
follo
w
ed
b
y
what
migh
t
b
e
 alled
the
`b
o
dy'
of
the
ma ro.
F
or
delete-and-extra t-region
the
`b
o
dy'
 onsists
of
the
follo
wing
t
w
o
lines:
validate_region
(&start,
&end);
return
del_range_1
(XINT
(start),
XINT
(end),
1,
1);
The
rst
fun tion,
validate_region
 
he 
ks
whether
the
v
alues
passed
as
the
b
eginning
and
end
of
the
region
are
the
prop
er
t
yp
e
and
are
within
range.
The
se ond
fun tion,
del_range_1,
a tually
deletes
the
text.
del_range_1
is
a
 omplex
fun tion
w
e
will
not
lo
ok
in
to.
It
up
dates
the
buer
and
do
es
other
things.
Ho
w
ev
er,
it
is
w
orth
lo
oking
at
the
t
w
o
argumen
ts
passed
to
del_range.
These
are
XINT
(start)
and
XINT
(end)
.
As
far
as
the
C
language
is
 on erned,
start
and
end
are
t
w
o
in
tegers
that
mark
the
b
eginning
and
end
of
the
region
to
b
e
deleted
1
.
In
early
v
ersions
of
Ema s,
these
t
w
o
n
um
b
ers
w
ere
thirt
y-t
w
o
bits
long,
but
the
 o
de
is
slo
wly
b
eing
generalized
to
handle
other
lengths.
Three
of
the
a
v
ailable
bits
are
used
to
sp
e ify
the
t
yp
e
of
information
and
a
fourth
bit
is
used
for
handling
the
 omputer's
memory;
the
remaining
bits
are
used
as
` on
ten
t'.
`XINT'
is
a
C
ma ro
that
extra ts
the
relev
an
t
n
um
b
er
from
the
longer
 olle tion
of
bits;
the
four
other
bits
are
dis arded.
1
More
pre isely
,
and
requiring
more
exp
ert
kno
wledge
to
understand,
the
t
w
o
in
tegers
are
of
t
yp
e
`Lisp
Ob
je t',
whi 
h
 an
also
b
e
a
C
union
instead
of
an
in
teger
t
yp
e.

100
Chapter
8:
Cutting
and
Storing
T
ext
The
 ommand
in
delete-and-extra t-regi
on
lo
oks
lik
e
this:
del_range_1
(XINT
(start),
XINT
(end),
1,
1);
It
deletes
the
region
b
et
w
een
the
b
eginning
p
osition,
start,
and
the
ending
p
osition,
end.
F
rom
the
p
oin
t
of
view
of
the
p
erson
writing
Lisp,
Ema s
is
all
v
ery
simple;
but
hidden
underneath
is
a
great
deal
of
 omplexit
y
to
mak
e
it
all
w
ork.
8.4
Initializing
a
V
ariable
with
defvar
Unlik
e
the
delete-and-extra t-region
fun tion,
the
 opy-region-as-
kill
fun tion
is
written
in
Ema s
Lisp.
Tw
o
fun tions
within
it,
kill-
append
and
kill-new,
 op
y
a
region
in
a
buer
and
sa
v
e
it
in
a
v
ariable
 alled
the
kill-ring.
This
se tion
des rib
es
ho
w
the
kill-ring
v
ariable
is
 reated
and
initialized
using
the
defvar
sp
e ial
form.
(Again
w
e
note
that
the
term
kill-ring
is
a
misnomer.
The
text
that
is
 lipp
ed
out
of
the
buer
 an
b
e
brough
t
ba 
k;
it
is
not
a
ring
of
 orpses,
but
a
ring
of
resurre table
text.)
In
Ema s
Lisp,
a
v
ariable
su 
h
as
the
kill-ring
is
 reated
and
giv
en
an
initial
v
alue
b
y
using
the
defvar
sp
e ial
form.
The
name
 omes
from
\dene
v
ariable".
The
defvar
sp
e ial
form
is
similar
to
setq
in
that
it
sets
the
v
alue
of
a
v
ariable.
It
is
unlik
e
setq
in
t
w
o
w
a
ys:
rst,
it
only
sets
the
v
alue
of
the
v
ariable
if
the
v
ariable
do
es
not
already
ha
v
e
a
v
alue.
If
the
v
ariable
already
has
a
v
alue,
defvar
do
es
not
o
v
erride
the
existing
v
alue.
Se ond,
defvar
has
a
do
 umen
tation
string.
(Another
sp
e ial
form,
def ustom,
is
designed
for
v
ariables
that
p
eople
 ustomize.
It
has
more
features
than
defvar.
(See
Se tion
16.2,
\Setting
V
ariables
with
def ustom",
page
214.)
Y
ou
 an
see
the
 urren
t
v
alue
of
a
v
ariable,
an
y
v
ariable,
b
y
using
the
des ribe-variable
fun tion,
whi 
h
is
usually
in
v
ok
ed
b
y
t
yping
C-h
v.
If
y
ou
t
yp
e
C-h
v
and
then
kill-ring
(follo
w
ed
b
y
h
RET
i
)
when
prompted,
y
ou
will
see
what
is
in
y
our
 urren
t
kill
ring|this
ma
y
b
e
quite
a
lot!
Con
v
ersely
,
if
y
ou
ha
v
e
b
een
doing
nothing
this
Ema s
session
ex ept
read
this
do
 umen
t,
y
ou
ma
y
ha
v
e
nothing
in
it.
Also,
y
ou
will
see
the
do
 umen
tation
for
kill-
ring:
Do umentation:
List
of
killed
text
sequen es.
Sin e
the
kill
ring
is
supposed
to
intera t
ni ely
with
 ut-and-paste
fa ilities
offered
by
window
systems,
use
of
this
variable
should

 opy-region-as-kill
101
intera t
ni ely
with
`interprogram- ut-fun tion'
and
`interprogram-paste-fun tion'
.
The
fun tions
`kill-new',
`kill-append',
and
` urrent-kill'
are
supposed
to
implement
this
intera tion;
you
may
want
to
use
them
instead
of
manipulating
the
kill
ring
dire tly.
The
kill
ring
is
dened
b
y
a
defvar
in
the
follo
wing
w
a
y:
(defvar
kill-ring
nil
"List
of
killed
text
sequen es.
...
")
In
this
v
ariable
denition,
the
v
ariable
is
giv
en
an
initial
v
alue
of
nil,
whi 
h
mak
es
sense,
sin e
if
y
ou
ha
v
e
sa
v
ed
nothing,
y
ou
w
an
t
nothing
ba 
k
if
y
ou
giv
e
a
yank
 ommand.
The
do
 umen
tation
string
is
written
just
lik
e
the
do
 umen
tation
string
of
a
defun.
As
with
the
do
 umen
tation
string
of
the
defun,
the
rst
line
of
the
do
 umen
tation
should
b
e
a
 omplete
sen
ten e,
sin e
some
 ommands,
lik
e
apropos,
prin
t
only
the
rst
line
of
do
 umen
ta-
tion.
Su  eeding
lines
should
not
b
e
inden
ted;
otherwise
they
lo
ok
o
dd
when
y
ou
use
C-h
v
(des ribe-variable).
8.4.1
defvar
and
an
asterisk
In
the
past,
Ema s
used
the
defvar
sp
e ial
form
b
oth
for
in
ternal
v
ari-
ables
that
y
ou
w
ould
not
exp
e t
a
user
to
 
hange
and
for
v
ariables
that
y
ou
do
exp
e t
a
user
to
 
hange.
Although
y
ou
 an
still
use
defvar
for
user
 us-
tomizable
v
ariables,
please
use
def ustom
instead,
sin e
that
sp
e ial
form
pro
vides
a
path
in
to
the
Customization
 ommands.
(See
Se tion
16.2,
\Set-
ting
V
ariables
with
def ustom",
page
214.)
When
y
ou
sp
e ied
a
v
ariable
using
the
defvar
sp
e ial
form,
y
ou
 ould
distinguish
a
readily
settable
v
ariable
from
others
b
y
t
yping
an
asterisk,
`*',
in
the
rst
 olumn
of
its
do
 umen
tation
string.
F
or
example:
(defvar
shell- ommand-default-error-bu
ffer
nil
"*Buffer
name
for
`shell- ommand'
...
error
output.
...
")
This
means
that
y
ou
 ould
(and
still
 an)
use
the
edit-options
 ommand
to
 
hange
the
v
alue
of
shell- ommand-default-err
or-b
uff
er
temp
orarily
.
Ho
w
ev
er,
options
set
using
edit-options
are
set
only
for
the
duration
of
y
our
editing
session.
The
new
v
alues
are
not
sa
v
ed
b
et
w
een
sessions.
Ea 
h
time
Ema s
starts,
it
reads
the
original
v
alue,
unless
y
ou
 
hange
the
v
alue
within
y
our
`.ema s'
le,
either
b
y
setting
it
man
ually
or
b
y
using
 ustomize.
See
Chapter
16,
\Y
our
`.ema s'
File",
page
213.
F
or
me,
the
ma
jor
use
of
the
edit-options
 ommand
is
to
suggest
v
ari-
ables
that
I
migh
t
w
an
t
to
set
in
m
y
`.ema s'
le.
I
urge
y
ou
to
lo
ok
through
the
list.
(See
se tion
\Editing
V
ariable
V
alues"
in
The
GNU
Ema s
Man
ual
.)

102
Chapter
8:
Cutting
and
Storing
T
ext
8.5
 opy-region-as
-k
il
l
The
 opy-region-as-kill
fun tion
 opies
a
region
of
text
from
a
buer
and
(via
either
kill-append
or
kill-new)
sa
v
es
it
in
the
kill-ring.
If
y
ou
 all
 opy-region-as-kill
immediately
after
a
kill-region
 om-
mand,
Ema s
app
ends
the
newly
 opied
text
to
the
previously
 opied
text.
This
means
that
if
y
ou
y
ank
ba 
k
the
text,
y
ou
get
it
all,
from
b
oth
this
and
the
previous
op
eration.
On
the
other
hand,
if
some
other
 ommand
pre edes
the
 opy-region-as-kill,
the
fun tion
 opies
the
text
in
to
a
separate
en
try
in
the
kill
ring.
Here
is
the
 omplete
text
of
the
v
ersion
21
 opy-region-as-kill
fun -
tion:
(defun
 opy-region-as-kill
(beg
end)
"Save
the
region
as
if
killed,
but
don't
kill
it.
In
Transient
Mark
mode,
dea tivate
the
mark.
If
`interprogram- ut-fun tion'
is
non-nil,
also
save
the
text
for
a
window
system
 ut
and
paste."
(intera tive
"r")
(if
(eq
last- ommand
'kill-region)
(kill-append
(buffer-substring
beg
end)
(<
end
beg))
(kill-new
(buffer-substring
beg
end)))
(if
transient-mark-mode
(setq
dea tivate-mark
t))
nil)
As
usual,
this
fun tion
 an
b
e
divided
in
to
its
 omp
onen
t
parts:
(defun
 opy-region-as-kill
(argumen
t-list
)
"do
 umen
tation...
"
(intera tive
"r")
b
o
dy
...
)
The
argumen
ts
are
beg
and
end
and
the
fun tion
is
in
tera tiv
e
with
"r",
so
the
t
w
o
argumen
ts
m
ust
refer
to
the
b
eginning
and
end
of
the
region.
If
y
ou
ha
v
e
b
een
reading
though
this
do
 umen
t
from
the
b
eginning,
under-
standing
these
parts
of
a
fun tion
is
almost
b
e oming
routine.
The
do
 umen
tation
is
somewhat
 onfusing
unless
y
ou
remem
b
er
that
the
w
ord
`kill'
has
a
meaning
dieren
t
from
its
usual
meaning.
The
`T
ransien
t
Mark'
and
interprogram- ut-fun tion
 ommen
ts
explain
 ertain
side-
ee ts.
After
y
ou
on e
set
a
mark,
a
buer
alw
a
ys
 on
tains
a
region.
If
y
ou
wish,
y
ou
 an
use
T
ransien
t
Mark
mo
de
to
highligh
t
the
region
temp
orarily
.
(No
one
w
an
ts
to
highligh
t
the
region
all
the
time,
so
T
ransien
t
Mark
mo
de
highligh
ts
it
only
at
appropriate
times.
Man
y
p
eople
turn
o
T
ransien
t
Mark
mo
de,
so
the
region
is
nev
er
highligh
ted.)

The
Bo
dy
of
 opy-region-as-kill
103
Also,
a
windo
wing
system
allo
ws
y
ou
to
 op
y
,
 ut,
and
paste
among
dier-
en
t
programs.
In
the
X
windo
wing
system,
for
example,
the
interprogram-
 ut-fun tion
fun tion
is
x-sele t-text,
whi 
h
w
orks
with
the
windo
wing
system's
equiv
alen
t
of
the
Ema s
kill
ring.
The
b
o
dy
of
the
 opy-region-as-kill
fun tion
starts
with
an
if
 lause.
What
this
 lause
do
es
is
distinguish
b
et
w
een
t
w
o
dieren
t
situa-
tions:
whether
or
not
this
 ommand
is
exe uted
immediately
after
a
previ-
ous
kill-region
 ommand.
In
the
rst
 ase,
the
new
region
is
app
ended
to
the
previously
 opied
text.
Otherwise,
it
is
inserted
in
to
the
b
eginning
of
the
kill
ring
as
a
separate
pie e
of
text
from
the
previous
pie e.
The
last
t
w
o
lines
of
the
fun tion
prev
en
t
the
region
from
ligh
ting
up
if
T
ransien
t
Mark
mo
de
is
turned
on.
The
b
o
dy
of
 opy-region-as-kill
merits
dis ussion
in
detail.
8.5.1
The
Bo
dy
of
 opy-region-as-kill
The
 opy-region-as-kill
fun tion
w
orks
in
m
u 
h
the
same
w
a
y
as
the
kill-region
fun tion
(see
Se tion
8.2,
\kill-region",
page
94).
Both
are
written
so
that
t
w
o
or
more
kills
in
a
ro
w
 om
bine
their
text
in
to
a
single
en
try
.
If
y
ou
y
ank
ba 
k
the
text
from
the
kill
ring,
y
ou
get
it
all
in
one
pie e.
Moreo
v
er,
kills
that
kill
forw
ard
from
the
 urren
t
p
osition
of
the
 ursor
are
added
to
the
end
of
the
previously
 opied
text
and
 ommands
that
 op
y
text
ba 
kw
ards
add
it
to
the
b
eginning
of
the
previously
 opied
text.
This
w
a
y
,
the
w
ords
in
the
text
sta
y
in
the
prop
er
order.
Lik
e
kill-region,
the
 opy-region-as-kill
fun tion
mak
es
use
of
the
last- ommand
v
ariable
that
k
eeps
tra 
k
of
the
previous
Ema s
 ommand.
Normally
,
whenev
er
a
fun tion
is
exe uted,
Ema s
sets
the
v
alue
of
this-
 ommand
to
the
fun tion
b
eing
exe uted
(whi 
h
in
this
 ase
w
ould
b
e
 opy-
region-as-kill).
A
t
the
same
time,
Ema s
sets
the
v
alue
of
last- ommand
to
the
previous
v
alue
of
this- ommand.
In
the
rst
part
of
the
b
o
dy
of
the
 opy-region-as-kill
fun tion,
an
if
expression
determines
whether
the
v
alue
of
last- ommand
is
kill-region.
If
so,
the
then-part
of
the
if
expression
is
ev
aluated;
it
uses
the
kill-append
fun tion
to
 on atenate
the
text
 opied
at
this
 all
to
the
fun tion
with
the
text
already
in
the
rst
elemen
t
(the
 ar)
of
the
kill
ring.
On
the
other
hand,
if
the
v
alue
of
last- ommand
is
not
kill-region,
then
the
 opy-
region-as-kill
fun tion
atta 
hes
a
new
elemen
t
to
the
kill
ring
using
the
kill-new
fun tion.

104
Chapter
8:
Cutting
and
Storing
T
ext
The
if
expression
reads
as
follo
ws;
it
uses
eq,
whi 
h
is
a
fun tion
w
e
ha
v
e
not
y
et
seen:
(if
(eq
last- ommand
'kill-region)
;;
then-part
(kill-append
(buffer-substring
beg
end)
(<
end
beg))
;;
else-part
(kill-new
(buffer-substring
beg
end)))
The
eq
fun tion
tests
whether
its
rst
argumen
t
is
the
same
Lisp
ob
je t
as
its
se ond
argumen
t.
The
eq
fun tion
is
similar
to
the
equal
fun tion
in
that
it
is
used
to
test
for
equalit
y
,
but
diers
in
that
it
determines
whether
t
w
o
represen
tations
are
a tually
the
same
ob
je t
inside
the
 omputer,
but
with
dieren
t
names.
equal
determines
whether
the
stru ture
and
 on
ten
ts
of
t
w
o
expressions
are
the
same.
If
the
previous
 ommand
w
as
kill-region,
then
the
Ema s
Lisp
in
ter-
preter
 alls
the
kill-append
fun tion
The
kill-append
fun tion
The
kill-append
fun tion
lo
oks
lik
e
this:
(defun
kill-append
(string
before-p)
"Append
STRING
to
the
end
of
the
latest
kill
in
the
kill
ring.
If
BEFORE-P
is
non-nil,
prepend
STRING
to
the
kill.
If
`interprogram- ut-fun tion'
is
set,
pass
the
resulting
kill
to
it."
(kill-new
(if
before-p
( on at
string
( ar
kill-ring))
( on at
( ar
kill-ring)
string))
t))
The
kill-append
fun tion
is
fairly
straigh
tforw
ard.
It
uses
the
kill-new
fun tion,
whi 
h
w
e
will
dis uss
in
more
detail
in
a
momen
t.
First,
let
us
lo
ok
at
the
 onditional
that
is
one
of
the
t
w
o
argumen
ts
to
kill-new.
It
uses
 on at
to
 on atenate
the
new
text
to
the
 ar
of
the
kill
ring.
Whether
it
prep
ends
or
app
ends
the
text
dep
ends
on
the
results
of
an
if
expression:
(if
before-p
;
if-part
( on at
string
( ar
kill-ring))
;
then-part
( on at
( ar
kill-ring)
string))
;
else-part
If
the
region
b
eing
killed
is
b
efore
the
region
that
w
as
killed
in
the
last
 ommand,
then
it
should
b
e
prep
ended
b
efore
the
material
that
w
as
sa
v
ed
in
the
previous
kill;
and
 on
v
ersely
,
if
the
killed
text
follo
ws
what
w
as
just
killed,
it
should
b
e
app
ended
after
the
previous
text.
The
if
expression
dep
ends
on
the
predi ate
before-p
to
de ide
whether
the
newly
sa
v
ed
text
should
b
e
put
b
efore
or
after
the
previously
sa
v
ed
text.

The
kill-new
fun tion
105
The
sym
b
ol
before-p
is
the
name
of
one
of
the
argumen
ts
to
kill-
append.
When
the
kill-append
fun tion
is
ev
aluated,
it
is
b
ound
to
the
v
alue
returned
b
y
ev
aluating
the
a tual
argumen
t.
In
this
 ase,
this
is
the
ex-
pression
(<
end
beg).
This
expression
do
es
not
dire tly
determine
whether
the
killed
text
in
this
 ommand
is
lo
 ated
b
efore
or
after
the
kill
text
of
the
last
 ommand;
what
is
do
es
is
determine
whether
the
v
alue
of
the
v
ariable
end
is
less
than
the
v
alue
of
the
v
ariable
beg.
If
it
is,
it
means
that
the
user
is
most
lik
ely
heading
to
w
ards
the
b
eginning
of
the
buer.
Also,
the
result
of
ev
aluating
the
predi ate
expression,
(<
end
beg),
will
b
e
true
and
the
text
will
b
e
prep
ended
b
efore
the
previous
text.
On
the
other
hand,
if
the
v
alue
of
the
v
ariable
end
is
greater
than
the
v
alue
of
the
v
ariable
beg,
the
text
will
b
e
app
ended
after
the
previous
text.
When
the
newly
sa
v
ed
text
will
b
e
prep
ended,
then
the
string
with
the
new
text
will
b
e
 on atenated
b
efore
the
old
text:
( on at
string
( ar
kill-ring))
But
if
the
text
will
b
e
app
ended,
it
will
b
e
 on atenated
after
the
old
text:
( on at
( ar
kill-ring)
string))
T
o
understand
ho
w
this
w
orks,
w
e
rst
need
to
review
the
 on at
fun -
tion.
The
 on at
fun tion
links
together
or
unites
t
w
o
strings
of
text.
The
result
is
a
string.
F
or
example:
( on at
"ab "
"def")
)
"ab def"
( on at
"new
"
( ar
'("first
element"
"se ond
element")))
)
"new
first
element"
( on at
( ar
'("first
element"
"se ond
element"))
"
modified")
)
"first
element
modified"
W
e
 an
no
w
mak
e
sense
of
kill-append:
it
mo
dies
the
 on
ten
ts
of
the
kill
ring.
The
kill
ring
is
a
list,
ea 
h
elemen
t
of
whi 
h
is
sa
v
ed
text.
The
kill-append
fun tion
uses
the
kill-new
fun tion
whi 
h
in
turn
uses
the
set ar
fun tion.
The
kill-new
fun tion
The
kill-new
fun tion
lo
oks
lik
e
this:
(defun
kill-new
(string
&optional
repla e)
"Make
STRING
the
latest
kill
in
the
kill
ring.
Set
the
kill-ring-yank
pointer
to
point
to
it.
If
`interprogram- ut-fun tion'
is
non-nil,
apply
it
to
STRING.
Optional
se ond
argument
REPLACE
non-nil
means
that
STRING
will
repla e
the
front
of
the
kill
ring,
rather
than
being
added
to
the
list."

106
Chapter
8:
Cutting
and
Storing
T
ext
(and
(fboundp
'menu-bar-update-yank-menu)
(menu-bar-update-yank-menu
string
(and
repla e
( ar
kill-ring))))
(if
(and
repla e
kill-ring)
(set ar
kill-ring
string)
(setq
kill-ring
( ons
string
kill-ring))
(if
(>
(length
kill-ring)
kill-ring-max)
(set dr
(nth dr
(1-
kill-ring-max)
kill-ring)
nil)))
(setq
kill-ring-yank-pointer
kill-ring)
(if
interprogram- ut-fun tion
(fun all
interprogram- ut-fun tion
string
(not
repla e))))
As
usual,
w
e
 an
lo
ok
at
this
fun tion
in
parts.
The
rst
line
of
the
do
 umen
tation
mak
es
sense:
Make
STRING
the
latest
kill
in
the
kill
ring.
Let's
skip
o
v
er
the
rest
of
the
do
 umen
tation
for
the
momen
t.
Also,
let's
skip
o
v
er
the
rst
t
w
o
lines
of
 o
de,
those
in
v
olving
menu-bar-
update-yank-menu.
W
e
will
explain
them
b
elo
w.
The
 riti al
lines
are
these:
(if
(and
repla e
kill-ring)
;;
then
(set ar
kill-ring
string)
;;
else
(setq
kill-ring
( ons
string
kill-ring))
(if
(>
(length
kill-ring)
kill-ring-max)
;;
a
v
oid
o
v
erly
long
kill
ring
(set dr
(nth dr
(1-
kill-ring-max)
kill-ring)
nil)))
(setq
kill-ring-yank-pointer
kill-ring)
(if
interprogram- ut-fun tion
(fun all
interprogram- ut-fun tion
string
(not
repla e))))
The
 onditional
test
is
(and
repla e
kill-ring)
.
This
will
b
e
true
when
t
w
o
 onditions
are
met:
the
kill
ring
has
something
in
it,
and
the
repla e
v
ariable
is
true.
The
kill-append
fun tion
sets
repla e
to
b
e
true;
then,
when
the
kill
ring
has
at
least
one
item
in
it,
the
set ar
expression
is
exe uted:
(set ar
kill-ring
string)
The
set ar
fun tion
a tually
 
hanges
the
rst
elemen
t
of
the
kill-ring
list
to
the
v
alue
of
string.
It
repla es
the
rst
elemen
t.
On
the
other
hand,
if
the
kill
ring
is
empt
y
,
or
repla e
is
false,
the
else-part
of
the
 ondition
is
exe uted:
(setq
kill-ring
( ons
string
kill-ring))
(if
(>
(length
kill-ring)
kill-ring-max)
(set dr
(nth dr
(1-
kill-ring-max)
kill-ring)
nil))

The
kill-new
fun tion
107
This
expression
rst
 onstru ts
a
new
v
ersion
of
the
kill
ring
b
y
prep
ending
string
to
the
existing
kill
ring
as
a
new
elemen
t.
Then
it
exe utes
a
se ond
if
 lause.
This
se ond
if
 lause
k
eeps
the
kill
ring
from
gro
wing
to
o
long.
Let's
lo
ok
at
these
t
w
o
expressions
in
order.
The
setq
line
of
the
else-part
sets
the
new
v
alue
of
the
kill
ring
to
what
results
from
adding
the
string
b
eing
killed
to
the
old
kill
ring.
W
e
 an
see
ho
w
this
w
orks
with
an
example:
(setq
example-list
'("here
is
a
 lause"
"another
 lause"))
After
ev
aluating
this
expression
with
C-x
C-e,
y
ou
 an
ev
aluate
example-
list
and
see
what
it
returns:
example-list
)
("here
is
a
 lause"
"another
 lause")
No
w,
w
e
 an
add
a
new
elemen
t
on
to
this
list
b
y
ev
aluating
the
follo
wing
expression:
(setq
example-list
( ons
"a
third
 lause"
example-list))
When
w
e
ev
aluate
example-list,
w
e
nd
its
v
alue
is:
example-list
)
("a
third
 lause"
"here
is
a
 lause"
"another
 lause")
Th
us,
the
third
 lause
w
as
added
to
the
list
b
y
 ons.
This
is
exa tly
similar
to
what
the
setq
and
 ons
do
in
the
fun tion.
Here
is
the
line
again:
(setq
kill-ring
( ons
string
kill-ring))
No
w
for
the
se ond
part
of
the
if
 lause.
This
expression
k
eeps
the
kill
ring
from
gro
wing
to
o
long.
It
lo
oks
lik
e
this:
(if
(>
(length
kill-ring)
kill-ring-max)
(set dr
(nth dr
(1-
kill-ring-max)
kill-ring)
nil))
The
 o
de
 
he 
ks
whether
the
length
of
the
kill
ring
is
greater
than
the
maxim
um
p
ermitted
length.
This
is
the
v
alue
of
kill-ring-max
(whi 
h
is
60,
b
y
default).
If
the
length
of
the
kill
ring
is
to
o
long,
then
this
 o
de
sets
the
last
elemen
t
of
the
kill
ring
to
nil.
It
do
es
this
b
y
using
t
w
o
fun tions,
nth dr
and
set dr.
W
e
lo
ok
ed
at
set dr
earlier
(see
Se tion
7.6,
\set dr",
page
88).
It
sets
the
 dr
of
a
list,
just
as
set ar
sets
the
 ar
of
a
list.
In
this
 ase,
ho
w
ev
er,
set dr
will
not
b
e
setting
the
 dr
of
the
whole
kill
ring;
the
nth dr
fun tion
is
used
to
 ause
it
to
set
the
 dr
of
the
next
to
last
elemen
t
of
the
kill
ring|
this
means
that
sin e
the
 dr
of
the
next
to
last
elemen
t
is
the
last
elemen
t
of
the
kill
ring,
it
will
set
the
last
elemen
t
of
the
kill
ring.
The
nth dr
fun tion
w
orks
b
y
rep
eatedly
taking
the
 dr
of
a
list|it
tak
es
the
 dr
of
the
 dr
of
the
 dr
.
.
.
It
do
es
this
N
times
and
returns
the
results.

108
Chapter
8:
Cutting
and
Storing
T
ext
Th
us,
if
w
e
had
a
four
elemen
t
list
that
w
as
supp
osed
to
b
e
three
elemen
ts
long,
w
e
 ould
set
the
 dr
of
the
next
to
last
elemen
t
to
nil,
and
thereb
y
shorten
the
list.
Y
ou
 an
see
this
b
y
ev
aluating
the
follo
wing
three
expressions
in
turn.
First
set
the
v
alue
of
trees
to
(maple
oak
pine
bir h),
then
set
the
 dr
of
its
se ond
 dr
to
nil
and
then
nd
the
v
alue
of
trees:
(setq
trees
'(maple
oak
pine
bir h))
)
(maple
oak
pine
bir h)
(set dr
(nth dr
2
trees)
nil)
)
nil
trees
)
(maple
oak
pine)
(The
v
alue
returned
b
y
the
set dr
expression
is
nil
sin e
that
is
what
the
 dr
is
set
to.)
T
o
rep
eat,
in
kill-new,
the
nth dr
fun tion
tak
es
the
 dr
a
n
um
b
er
of
times
that
is
one
less
than
the
maxim
um
p
ermitted
size
of
the
kill
ring
and
sets
the
 dr
of
that
elemen
t
(whi 
h
will
b
e
the
rest
of
the
elemen
ts
in
the
kill
ring)
to
nil.
This
prev
en
ts
the
kill
ring
from
gro
wing
to
o
long.
The
next
to
last
expression
in
the
kill-new
fun tion
is
(setq
kill-ring-yank-pointer
kill-ring)
The
kill-ring-yank-pointer
is
a
global
v
ariable
that
is
set
to
b
e
the
kill-ring.
Ev
en
though
the
kill-ring-yank-pointer
is
 alled
a
`pointer',
it
is
a
v
ariable
just
lik
e
the
kill
ring.
Ho
w
ev
er,
the
name
has
b
een
 
hosen
to
help
h
umans
understand
ho
w
the
v
ariable
is
used.
The
v
ariable
is
used
in
fun tions
su 
h
as
yank
and
yank-pop
(see
Chapter
10,
\Y
anking
T
ext
Ba 
k",
page
117).
No
w,
to
return
to
the
rst
t
w
o
lines
in
the
b
o
dy
of
the
fun tion:
(and
(fboundp
'menu-bar-update-yank-menu)
(menu-bar-update-yank-menu
string
(and
repla e
( ar
kill-ring))))
This
is
an
expression
whose
rst
elemen
t
is
the
fun tion
and.
The
and
sp
e ial
form
ev
aluates
ea 
h
of
its
argumen
ts
un
til
one
of
the
argumen
ts
returns
a
v
alue
of
nil,
in
whi 
h
 ase
the
and
expression
returns
nil;
ho
w
ev
er,
if
none
of
the
argumen
ts
returns
a
v
alue
of
nil,
the
v
alue
resulting
from
ev
aluating
the
last
argumen
t
is
returned.
(Sin e
su 
h
a
v
alue
is
not
nil,
it
is
 onsidered
true
in
Ema s
Lisp.)
In
other
w
ords,
an
and
expression
returns
a
true
v
alue
only
if
all
its
argumen
ts
are
true.
In
this
 ase,
the
expression
tests
rst
to
see
whether
menu-bar-update-
yank-menu
exists
as
a
fun tion,
and
if
so,
 alls
it.
The
fboundp
fun tion
returns
true
if
the
sym
b
ol
it
is
testing
has
a
fun tion
denition
that
`is
not
v
oid'.
If
the
sym
b
ol's
fun tion
denition
w
ere
v
oid,
w
e
w
ould
re eiv
e
an
error

Review
109
message,
as
w
e
did
when
w
e
 reated
errors
in
ten
tionally
(see
Se tion
1.3,
\Generate
an
Error
Message",
page
4).
Essen
tially
,
the
and
is
an
if
expression
that
reads
lik
e
this:
if
the-men
u-bar-fun tion-exists
then
exe ute-it
menu-bar-update-yank-me
nu
is
one
of
the
fun tions
that
mak
e
it
p
ossi-
ble
to
use
the
`Sele t
and
P
aste'
men
u
in
the
Edit
item
of
a
men
u
bar;
using
a
mouse,
y
ou
 an
lo
ok
at
the
v
arious
pie es
of
text
y
ou
ha
v
e
sa
v
ed
and
sele t
one
pie e
to
paste.
Finally
,
the
last
expression
in
the
kill-new
fun tion
adds
the
newly
 opied
string
to
whatev
er
fa ilit
y
exists
for
 op
ying
and
pasting
among
dif-
feren
t
programs
running
in
a
windo
wing
system.
In
the
X
Windo
wing
sys-
tem,
for
example,
the
x-sele t-text
fun tion
tak
es
the
string
and
stores
it
in
memory
op
erated
b
y
X.
Y
ou
 an
paste
the
string
in
another
program,
su 
h
as
an
Xterm.
The
expression
lo
oks
lik
e
this:
(if
interprogram- ut-fun tion
(fun all
interprogram- ut-fun tion
string
(not
repla e))))
If
an
interprogram- ut-fun tion
exists,
then
Ema s
exe utes
fun all,
whi 
h
in
turn
 alls
its
rst
argumen
t
as
a
fun tion
and
passes
the
remaining
argumen
ts
to
it.
(In iden
tally
,
as
far
as
I
 an
see,
this
if
expression
 ould
b
e
repla ed
b
y
an
and
expression
similar
to
the
one
in
the
rst
part
of
the
fun tion.)
W
e
are
not
going
to
dis uss
windo
wing
systems
and
other
programs
fur-
ther,
but
merely
note
that
this
is
a
me 
hanism
that
enables
GNU
Ema s
to
w
ork
easily
and
w
ell
with
other
programs.
This
 o
de
for
pla ing
text
in
the
kill
ring,
either
 on atenated
with
an
existing
elemen
t
or
as
a
new
elemen
t,
leads
us
to
the
 o
de
for
bringing
ba 
k
text
that
has
b
een
 ut
out
of
the
buer|the
y
ank
 ommands.
Ho
w
ev
er,
b
efore
dis ussing
the
y
ank
 ommands,
it
is
b
etter
to
learn
ho
w
lists
are
implemen
ted
in
a
 omputer.
This
will
mak
e
 lear
su 
h
m
ysteries
as
the
use
of
the
term
`p
oin
ter'.
8.6
Review
Here
is
a
brief
summary
of
some
re en
tly
in
tro
du ed
fun tions.
 ar
 dr
 ar
returns
the
rst
elemen
t
of
a
list;
 dr
returns
the
se ond
and
subsequen
t
elemen
ts
of
a
list.

110
Chapter
8:
Cutting
and
Storing
T
ext
F
or
example:
( ar
'(1
2
3
4
5
6
7))
)
1
( dr
'(1
2
3
4
5
6
7))
)
(2
3
4
5
6
7)
 ons
 ons
 onstru ts
a
list
b
y
prep
ending
its
rst
argumen
t
to
its
se ond
argumen
t.
F
or
example:
( ons
1
'(2
3
4))
)
(1
2
3
4)
nth dr
Return
the
result
of
taking
 dr
`n'
times
on
a
list.
The
n
th
 dr.
The
`rest
of
the
rest',
as
it
w
ere.
F
or
example:
(nth dr
3
'(1
2
3
4
5
6
7))
)
(4
5
6
7)
set ar
set dr
set ar
 
hanges
the
rst
elemen
t
of
a
list;
set dr
 
hanges
the
se ond
and
subsequen
t
elemen
ts
of
a
list.
F
or
example:
(setq
triple
'(1
2
3))
(set ar
triple
'37)
triple
)
(37
2
3)
(set dr
triple
'("foo"
"bar"))
triple
)
(37
"foo"
"bar")
progn
Ev
aluate
ea 
h
argumen
t
in
sequen e
and
then
return
the
v
alue
of
the
last.
F
or
example:
(progn
1
2
3
4)
)
4
save-restri tion
Re ord
whatev
er
narro
wing
is
in
ee t
in
the
 urren
t
buer,
if
an
y
,
and
restore
that
narro
wing
after
ev
aluating
the
argumen
ts.
sear h-forward
Sear 
h
for
a
string,
and
if
the
string
is
found,
mo
v
e
p
oin
t.

Sear 
hing
Exer ises
111
T
ak
es
four
argumen
ts:
1.
The
string
to
sear 
h
for.
2.
Optionally
,
the
limit
of
the
sear 
h.
3.
Optionally
,
what
to
do
if
the
sear 
h
fails,
return
nil
or
an
error
message.
4.
Optionally
,
ho
w
man
y
times
to
rep
eat
the
sear 
h;
if
nega-
tiv
e,
the
sear 
h
go
es
ba 
kw
ards.
kill-region
delete-region
 opy-region-as-kill
kill-region
 uts
the
text
b
et
w
een
p
oin
t
and
mark
from
the
buer
and
stores
that
text
in
the
kill
ring,
so
y
ou
 an
get
it
ba 
k
b
y
y
anking.
delete-and-extra t-regio
n
remo
v
es
the
text
b
et
w
een
p
oin
t
and
mark
from
the
buer
and
thro
ws
it
a
w
a
y
.
Y
ou
 annot
get
it
ba 
k.
 opy-region-as-kill
 opies
the
text
b
et
w
een
p
oin
t
and
mark
in
to
the
kill
ring,
from
whi 
h
y
ou
 an
get
it
b
y
y
anking.
The
fun tion
do
es
not
 ut
or
remo
v
e
the
text
from
the
buer.
8.7
Sear 
hing
Exer ises

W
rite
an
in
tera tiv
e
fun tion
that
sear 
hes
for
a
string.
If
the
sear 
h
nds
the
string,
lea
v
e
p
oin
t
after
it
and
displa
y
a
message
that
sa
ys
\F
ound!".
(Do
not
use
sear h-forward
for
the
name
of
this
fun tion;
if
y
ou
do,
y
ou
will
o
v
erwrite
the
existing
v
ersion
of
sear h-forward
that
 omes
with
Ema s.
Use
a
name
su 
h
as
test-sear h
instead.)

W
rite
a
fun tion
that
prin
ts
the
third
elemen
t
of
the
kill
ring
in
the
e 
ho
area,
if
an
y;
if
the
kill
ring
do
es
not
 on
tain
a
third
elemen
t,
prin
t
an
appropriate
message.

112
Chapter
8:
Cutting
and
Storing
T
ext

Ho
w
Lists
are
Implemen
ted
113
9
Ho
w
Lists
are
Implemen
ted
In
Lisp,
atoms
are
re orded
in
a
straigh
tforw
ard
fashion;
if
the
implemen-
tation
is
not
straigh
tforw
ard
in
pra ti e,
it
is,
nonetheless,
straigh
tforw
ard
in
theory
.
The
atom
`rose',
for
example,
is
re orded
as
the
four
 on
tiguous
letters
`r',
`o',
`s',
`e'.
A
list,
on
the
other
hand,
is
k
ept
dieren
tly
.
The
me 
hanism
is
equally
simple,
but
it
tak
es
a
momen
t
to
get
used
to
the
idea.
A
list
is
k
ept
using
a
series
of
pairs
of
p
oin
ters.
In
the
series,
the
rst
p
oin
ter
in
ea 
h
pair
p
oin
ts
to
an
atom
or
to
another
list,
and
the
se ond
p
oin
ter
in
ea 
h
pair
p
oin
ts
to
the
next
pair,
or
to
the
sym
b
ol
nil,
whi 
h
marks
the
end
of
the
list.
A
p
oin
ter
itself
is
quite
simply
the
ele troni 
address
of
what
is
p
oin
ted
to.
Hen e,
a
list
is
k
ept
as
a
series
of
ele troni 
addresses.
F
or
example,
the
list
(rose
violet
butter up)
has
three
elemen
ts,
`rose',
`violet',
and
`butter up'.
In
the
 omputer,
the
ele troni 
address
of
`rose'
is
re orded
in
a
segmen
t
of
 omputer
memory
along
with
the
ad-
dress
that
giv
es
the
ele troni 
address
of
where
the
atom
`violet'
is
lo
 ated;
and
that
address
(the
one
that
tells
where
`violet'
is
lo
 ated)
is
k
ept
along
with
an
address
that
tells
where
the
address
for
the
atom
`butter up'
is
lo
 ated.
This
sounds
more
 ompli ated
than
it
is
and
is
easier
seen
in
a
diagram:
rose
violet
buttercup
nil
In
the
diagram,
ea 
h
b
o
x
represen
ts
a
w
ord
of
 omputer
memory
that
holds
a
Lisp
ob
je t,
usually
in
the
form
of
a
memory
address.
The
b
o
xes,
i.e.
the
addresses,
are
in
pairs.
Ea 
h
arro
w
p
oin
ts
to
what
the
address
is
the
address
of,
either
an
atom
or
another
pair
of
addresses.
The
rst
b
o
x
is
the
ele troni 
address
of
`rose'
and
the
arro
w
p
oin
ts
to
`rose';
the
se ond
b
o
x
is
the
address
of
the
next
pair
of
b
o
xes,
the
rst
part
of
whi 
h
is
the
address
of
`violet'
and
the
se ond
part
of
whi 
h
is
the
address
of
the
next
pair.
The
v
ery
last
b
o
x
p
oin
ts
to
the
sym
b
ol
nil,
whi 
h
marks
the
end
of
the
list.
When
a
v
ariable
is
set
to
a
list
with
a
fun tion
su 
h
as
setq,
it
stores
the
address
of
the
rst
b
o
x
in
the
v
ariable.
Th
us,
ev
aluation
of
the
expression
(setq
bouquet
'(rose
violet
butter up))

114
Chapter
9:
Ho
w
Lists
are
Implemen
ted
 reates
a
situation
lik
e
this:
bouquet
rose
violet
buttercup
nil
In
this
example,
the
sym
b
ol
bouquet
holds
the
address
of
the
rst
pair
of
b
o
xes.
This
same
list
 an
b
e
illustrated
in
a
dieren
t
sort
of
b
o
x
notation
lik
e
this:
bouquet
car
rose
cdr
car
violet
cdr
car
butter-
cup
cdr
nil
(Sym
b
ols
 onsist
of
more
than
pairs
of
addresses,
but
the
stru ture
of
a
sym
b
ol
is
made
up
of
addresses.
Indeed,
the
sym
b
ol
bouquet
 onsists
of
a
group
of
address-b
o
xes,
one
of
whi 
h
is
the
address
of
the
prin
ted
w
ord
`bouquet',
a
se ond
of
whi 
h
is
the
address
of
a
fun tion
denition
atta 
hed
to
the
sym
b
ol,
if
an
y
,
a
third
of
whi 
h
is
the
address
of
the
rst
pair
of
address-b
o
xes
for
the
list
(rose
violet
butter up),
and
so
on.
Here
w
e
are
sho
wing
that
the
sym
b
ol's
third
address-b
o
x
p
oin
ts
to
the
rst
pair
of
address-b
o
xes
for
the
list.)
If
a
sym
b
ol
is
set
to
the
 dr
of
a
list,
the
list
itself
is
not
 
hanged;
the
sym
b
ol
simply
has
an
address
further
do
wn
the
list.
(In
the
jargon,
 ar
and
 dr
are
`non-destru tiv
e'.)
Th
us,
ev
aluation
of
the
follo
wing
expression
(setq
flowers
( dr
bouquet))
pro
du es
this:
rose
violet
buttercup
nil
flowers
bouquet

Sym
b
ols
as
a
Chest
of
Dra
w
ers
115
The
v
alue
of
flowers
is
(violet
butter up),
whi 
h
is
to
sa
y
,
the
sym
b
ol
flowers
holds
the
address
of
the
pair
of
address-b
o
xes,
the
rst
of
whi 
h
holds
the
address
of
violet,
and
the
se ond
of
whi 
h
holds
the
address
of
butter up.
A
pair
of
address-b
o
xes
is
 alled
a
 ons
 ell
or
dotted
pair.
See
se tion
\List
T
yp
e
"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
and
se tion
\Dot-
ted
P
air
Notation"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
information
ab
out
 ons
 ells
and
dotted
pairs.
The
fun tion
 ons
adds
a
new
pair
of
addresses
to
the
fron
t
of
a
series
of
addresses
lik
e
that
sho
wn
ab
o
v
e.
F
or
example,
ev
aluating
the
expression
(setq
bouquet
( ons
'lily
bouquet))
pro
du es:
violet
flowers
nil
buttercup
rose
lily
bouquet
Ho
w
ev
er,
this
do
es
not
 
hange
the
v
alue
of
the
sym
b
ol
flowers,
as
y
ou
 an
see
b
y
ev
aluating
the
follo
wing,
(eq
( dr
( dr
bouquet))
flowers)
whi 
h
returns
t
for
true.
Un
til
it
is
reset,
flowers
still
has
the
v
alue
(violet
butter up);
that
is,
it
has
the
address
of
the
 ons
 ell
whose
rst
address
is
of
violet.
Also,
this
do
es
not
alter
an
y
of
the
pre-existing
 ons
 ells;
they
are
all
still
there.
Th
us,
in
Lisp,
to
get
the
 dr
of
a
list,
y
ou
just
get
the
address
of
the
next
 ons
 ell
in
the
series;
to
get
the
 ar
of
a
list,
y
ou
get
the
address
of
the
rst
elemen
t
of
the
list;
to
 ons
a
new
elemen
t
on
a
list,
y
ou
add
a
new
 ons
 ell
to
the
fron
t
of
the
list.
That
is
all
there
is
to
it!
The
underlying
stru ture
of
Lisp
is
brillian
tly
simple!
And
what
do
es
the
last
address
in
a
series
of
 ons
 ells
refer
to?
It
is
the
address
of
the
empt
y
list,
of
nil.
In
summary
,
when
a
Lisp
v
ariable
is
set
to
a
v
alue,
it
is
pro
vided
with
the
address
of
the
list
to
whi 
h
the
v
ariable
refers.
9.1
Sym
b
ols
as
a
Chest
of
Dra
w
ers
In
an
earlier
se tion,
I
suggested
that
y
ou
migh
t
imagine
a
sym
b
ol
as
b
eing
a
 
hest
of
dra
w
ers.
The
fun tion
denition
is
put
in
one
dra
w
er,
the

116
Chapter
9:
Ho
w
Lists
are
Implemen
ted
v
alue
in
another,
and
so
on.
What
is
put
in
the
dra
w
er
holding
the
v
alue
 an
b
e
 
hanged
without
ae ting
the
 on
ten
ts
of
the
dra
w
er
holding
the
fun tion
denition,
and
vi e-v
ersa.
A tually
,
what
is
put
in
ea 
h
dra
w
er
is
the
address
of
the
v
alue
or
fun tion
denition.
It
is
as
if
y
ou
found
an
old
 
hest
in
the
atti ,
and
in
one
of
its
dra
w
ers
y
ou
found
a
map
giving
y
ou
dire tions
to
where
the
buried
treasure
lies.
(In
addition
to
its
name,
sym
b
ol
denition,
and
v
ariable
v
alue,
a
sym
b
ol
has
a
`dra
w
er'
for
a
prop
ert
y
list
whi 
h
 an
b
e
used
to
re ord
other
infor-
mation.
Prop
ert
y
lists
are
not
dis ussed
here;
see
se tion
\Prop
ert
y
Lists"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
Here
is
a
fan iful
represen
tation:
symbol name
Chest of Drawers
Contents of Drawers
bouquet
[none]
(rose violet buttercup)
[not described here]
directions to
map to
map to
symbol definition
directions to
variable name
directions to
property list
directions to
9.2
Exer ise
Set
flowers
to
violet
and
butter up.
Cons
t
w
o
more
o
w
ers
on
to
this
list
and
set
this
new
list
to
more-flowers.
Set
the
 ar
of
flowers
to
a
sh.
What
do
es
the
more-flowers
list
no
w
 on
tain?

The
kill-ring-yank-pointer
V
ariable
117
10
Y
anking
T
ext
Ba 
k
Whenev
er
y
ou
 ut
text
out
of
a
buer
with
a
`kill'
 ommand
in
GNU
Ema s,
y
ou
 an
bring
it
ba 
k
with
a
`y
ank'
 ommand.
The
text
that
is
 ut
out
of
the
buer
is
put
in
the
kill
ring
and
the
y
ank
 ommands
insert
the
appropriate
 on
ten
ts
of
the
kill
ring
ba 
k
in
to
a
buer
(not
ne essarily
the
original
buer).
A
simple
C-y
(yank)
 ommand
inserts
the
rst
item
from
the
kill
ring
in
to
the
 urren
t
buer.
If
the
C-y
 ommand
is
follo
w
ed
immediately
b
y
M-y,
the
rst
elemen
t
is
repla ed
b
y
the
se ond
elemen
t.
Su  essiv
e
M-y
 ommands
repla e
the
se ond
elemen
t
with
the
third,
fourth,
or
fth
elemen
t,
and
so
on.
When
the
last
elemen
t
in
the
kill
ring
is
rea 
hed,
it
is
repla ed
b
y
the
rst
elemen
t
and
the
 y le
is
rep
eated.
(Th
us
the
kill
ring
is
 alled
a
`ring'
rather
than
just
a
`list'.
Ho
w
ev
er,
the
a tual
data
stru ture
that
holds
the
text
is
a
list.
See
App
endix
B,
\Handling
the
Kill
Ring",
page
243,
for
the
details
of
ho
w
the
list
is
handled
as
a
ring.)
10.1
Kill
Ring
Ov
erview
The
kill
ring
is
a
list
of
textual
strings.
This
is
what
it
lo
oks
lik
e:
("some
text"
"a
different
pie e
of
text"
"yet
more
text")
If
this
w
ere
the
 on
ten
ts
of
m
y
kill
ring
and
I
pressed
C-y,
the
string
of
 
hara ters
sa
ying
`some
text'
w
ould
b
e
inserted
in
this
buer
where
m
y
 ursor
is
lo
 ated.
The
yank
 ommand
is
also
used
for
dupli ating
text
b
y
 op
ying
it.
The
 opied
text
is
not
 ut
from
the
buer,
but
a
 op
y
of
it
is
put
on
the
kill
ring
and
is
inserted
b
y
y
anking
it
ba 
k.
Three
fun tions
are
used
for
bringing
text
ba 
k
from
the
kill
ring:
yank,
whi 
h
is
usually
b
ound
to
C-y;
yank-pop,
whi 
h
is
usually
b
ound
to
M-y;
and
rotate-yank-pointer,
whi 
h
is
used
b
y
the
t
w
o
other
fun tions.
These
fun tions
refer
to
the
kill
ring
through
a
v
ariable
 alled
the
kill-
ring-yank-pointer.
Indeed,
the
insertion
 o
de
for
b
oth
the
yank
and
yank-
pop
fun tions
is:
(insert
( ar
kill-ring-yank-pointer))
T
o
b
egin
to
understand
ho
w
yank
and
yank-pop
w
ork,
it
is
rst
ne essary
to
lo
ok
at
the
kill-ring-yank-pointer
v
ariable
and
the
rotate-yank-
pointer
fun tion.
10.2
The
kill-ring-yank
-p
oi
nt
er
V
ariable
kill-ring-yank-pointer
is
a
v
ariable,
just
as
kill-ring
is
a
v
ariable.
It
p
oin
ts
to
something
b
y
b
eing
b
ound
to
the
v
alue
of
what
it
p
oin
ts
to,
lik
e
an
y
other
Lisp
v
ariable.

118
Chapter
10:
Y
anking
T
ext
Ba 
k
Th
us,
if
the
v
alue
of
the
kill
ring
is:
("some
text"
"a
different
pie e
of
text"
"yet
more
text")
and
the
kill-ring-yank-pointer
p
oin
ts
to
the
se ond
 lause,
the
v
alue
of
kill-ring-yank-pointer
is:
("a
different
pie e
of
text"
"yet
more
text")
As
explained
in
the
previous
 
hapter
(see
Chapter
9,
\List
Implemen
ta-
tion",
page
113),
the
 omputer
do
es
not
k
eep
t
w
o
dieren
t
 opies
of
the
text
b
eing
p
oin
ted
to
b
y
b
oth
the
kill-ring
and
the
kill-ring-yank-pointer.
The
w
ords
\a
dieren
t
pie e
of
text"
and
\y
et
more
text"
are
not
dupli ated.
Instead,
the
t
w
o
Lisp
v
ariables
p
oin
t
to
the
same
pie es
of
text.
Here
is
a
diagram:
a different piece of text
kill-ring-yank-pointer
nil
yet more text
some text
kill-ring
Both
the
v
ariable
kill-ring
and
the
v
ariable
kill-ring-yank-pointer
are
p
oin
ters.
But
the
kill
ring
itself
is
usually
des rib
ed
as
if
it
w
ere
a tually
what
it
is
 omp
osed
of.
The
kill-ring
is
sp
ok
en
of
as
if
it
w
ere
the
list
rather
than
that
it
p
oin
ts
to
the
list.
Con
v
ersely
,
the
kill-ring-yank-
pointer
is
sp
ok
en
of
as
p
oin
ting
to
a
list.
These
t
w
o
w
a
ys
of
talking
ab
out
the
same
thing
sound
 onfusing
at
rst
but
mak
e
sense
on
ree tion.
The
kill
ring
is
generally
though
t
of
as
the
 omplete
stru ture
of
data
that
holds
the
information
of
what
has
re en
tly
b
een
 ut
out
of
the
Ema s
buers.
The
kill-ring-yank-pointer
on
the
other
hand,
serv
es
to
indi ate|that
is,
to
`p
oin
t
to'|that
part
of
the
kill
ring
of
whi 
h
the
rst
elemen
t
(the
 ar)
will
b
e
inserted.
The
rotate-yank-pointer
fun tion
 
hanges
the
elemen
t
in
the
kill
ring
to
whi 
h
the
kill-ring-yank-pointer
p
oin
ts;
when
the
p
oin
ter
is
set
to
p
oin
t
to
the
next
elemen
t
b
ey
ond
the
end
of
the
kill
ring,
it
automati ally
sets
it
to
p
oin
t
to
the
rst
elemen
t
of
the
kill
ring.
This
is
ho
w
the
list
is
transformed
in
to
a
ring.
The
rotate-yank-pointer
fun tion
itself
is
not
diÆ ult,
but
 on
tains
man
y
details.
It
and
the
m
u 
h
simpler
yank
and
yank-
pop
fun tions
are
des rib
ed
in
an
app
endix.
See
App
endix
B,
\Handling
the
Kill
Ring",
page
243.

Exer ises
with
yank
and
nth dr
119
10.3
Exer ises
with
yank
and
nth dr

Using
C-h
v
(des ribe-variable),
lo
ok
at
the
v
alue
of
y
our
kill
ring.
Add
sev
eral
items
to
y
our
kill
ring;
lo
ok
at
its
v
alue
again.
Using
M-y
(yank-pop),
mo
v
e
all
the
w
a
y
around
the
kill
ring.
Ho
w
man
y
items
w
ere
in
y
our
kill
ring?
Find
the
v
alue
of
kill-ring-max.
W
as
y
our
kill
ring
full,
or
 ould
y
ou
ha
v
e
k
ept
more
blo
 
ks
of
text
within
it?

Using
nth dr
and
 ar,
 onstru t
a
series
of
expressions
to
return
the
rst,
se ond,
third,
and
fourth
elemen
ts
of
a
list.

120
Chapter
10:
Y
anking
T
ext
Ba 
k

while
121
11
Lo
ops
and
Re ursion
Ema s
Lisp
has
t
w
o
primary
w
a
ys
to
 ause
an
expression,
or
a
series
of
expressions,
to
b
e
ev
aluated
rep
eatedly:
one
uses
a
while
lo
op,
and
the
other
uses
re ursion.
Rep
etition
 an
b
e
v
ery
v
aluable.
F
or
example,
to
mo
v
e
forw
ard
four
sen
ten es,
y
ou
need
only
write
a
program
that
will
mo
v
e
forw
ard
one
sen
ten e
and
then
rep
eat
the
pro
 ess
four
times.
Sin e
a
 omputer
do
es
not
get
b
ored
or
tired,
su 
h
rep
etitiv
e
a tion
do
es
not
ha
v
e
the
deleterious
ee ts
that
ex essiv
e
or
the
wrong
kinds
of
rep
etition
 an
ha
v
e
on
h
umans.
P
eople
mostly
write
Ema s
Lisp
fun tions
using
while
lo
ops
and
their
kin;
but
y
ou
 an
use
re ursion,
whi 
h
pro
vides
a
v
ery
p
o
w
erful
w
a
y
to
think
ab
out
and
then
to
solv
e
problems
1
.
11.1
while
The
while
sp
e ial
form
tests
whether
the
v
alue
returned
b
y
ev
aluating
its
rst
argumen
t
is
true
or
false.
This
is
similar
to
what
the
Lisp
in
terpreter
do
es
with
an
if;
what
the
in
terpreter
do
es
next,
ho
w
ev
er,
is
dieren
t.
In
a
while
expression,
if
the
v
alue
returned
b
y
ev
aluating
the
rst
argu-
men
t
is
false,
the
Lisp
in
terpreter
skips
the
rest
of
the
expression
(the
b
o
dy
of
the
expression)
and
do
es
not
ev
aluate
it.
Ho
w
ev
er,
if
the
v
alue
is
true,
the
Lisp
in
terpreter
ev
aluates
the
b
o
dy
of
the
expression
and
then
again
tests
whether
the
rst
argumen
t
to
while
is
true
or
false.
If
the
v
alue
returned
b
y
ev
aluating
the
rst
argumen
t
is
again
true,
the
Lisp
in
terpreter
again
ev
aluates
the
b
o
dy
of
the
expression.
The
template
for
a
while
expression
lo
oks
lik
e
this:
(while
true-or-false-test
b
o
dy
...
)
So
long
as
the
true-or-false-test
of
the
while
expression
returns
a
true
v
alue
when
it
is
ev
aluated,
the
b
o
dy
is
rep
eatedly
ev
aluated.
This
pro
 ess
is
 alled
a
lo
op
sin e
the
Lisp
in
terpreter
rep
eats
the
same
thing
again
and
again,
lik
e
an
airplane
doing
a
lo
op.
When
the
result
of
ev
aluating
the
true-
or-false-test
is
false,
the
Lisp
in
terpreter
do
es
not
ev
aluate
the
rest
of
the
while
expression
and
`exits
the
lo
op'.
Clearly
,
if
the
v
alue
returned
b
y
ev
aluating
the
rst
argumen
t
to
while
is
alw
a
ys
true,
the
b
o
dy
follo
wing
will
b
e
ev
aluated
again
and
again
.
.
.
and
again
.
.
.
forev
er.
Con
v
ersely
,
if
the
v
alue
returned
is
nev
er
true,
the
1
Y
ou
 an
write
re ursiv
e
fun tions
to
b
e
frugal
or
w
asteful
of
men
tal
or
 omputer
resour es;
as
it
happ
ens,
metho
ds
that
p
eople
nd
easy|that
are
frugal
of
`men
tal
resour es'|sometimes
use
 onsiderable
 omputer
resour es.
Ema s
w
as
designed
to
run
on
ma 
hines
that
w
e
no
w
 onsider
limited
and
its
default
settings
are
 onserv
ativ
e.
Y
ou
ma
y
w
an
t
to
in rease
the
v
alues
of
max-spe pdl-size
and
max-lisp-eval-depth.
In
m
y
`.ema s'
le,
I
set
them
to
15
and
30
times
their
default
v
alue.

122
Chapter
11:
Lo
ops
and
Re ursion
expressions
in
the
b
o
dy
will
nev
er
b
e
ev
aluated.
The
 raft
of
writing
a
while
lo
op
 onsists
of
 
ho
osing
a
me 
hanism
su 
h
that
the
true-or-false-test
returns
true
just
the
n
um
b
er
of
times
that
y
ou
w
an
t
the
subsequen
t
expressions
to
b
e
ev
aluated,
and
then
ha
v
e
the
test
return
false.
The
v
alue
returned
b
y
ev
aluating
a
while
is
the
v
alue
of
the
true-or-false-
test.
An
in
teresting
 onsequen e
of
this
is
that
a
while
lo
op
that
ev
aluates
without
error
will
return
nil
or
false
regardless
of
whether
it
has
lo
op
ed
1
or
100
times
or
none
at
all.
A
while
expression
that
ev
aluates
su  essfully
nev
er
returns
a
true
v
alue!
What
this
means
is
that
while
is
alw
a
ys
ev
aluated
for
its
side
ee ts,
whi 
h
is
to
sa
y
,
the
 onsequen es
of
ev
aluating
the
expressions
within
the
b
o
dy
of
the
while
lo
op.
This
mak
es
sense.
It
is
not
the
mere
a t
of
lo
oping
that
is
desired,
but
the
 onsequen es
of
what
happ
ens
when
the
expressions
in
the
lo
op
are
rep
eatedly
ev
aluated.
11.1.1
A
while
Lo
op
and
a
List
A
 ommon
w
a
y
to
 on
trol
a
while
lo
op
is
to
test
whether
a
list
has
an
y
elemen
ts.
If
it
do
es,
the
lo
op
is
rep
eated;
but
if
it
do
es
not,
the
rep
etition
is
ended.
Sin e
this
is
an
imp
ortan
t
te 
hnique,
w
e
will
 reate
a
short
example
to
illustrate
it.
A
simple
w
a
y
to
test
whether
a
list
has
elemen
ts
is
to
ev
aluate
the
list:
if
it
has
no
elemen
ts,
it
is
an
empt
y
list
and
will
return
the
empt
y
list,
(),
whi 
h
is
a
synon
ym
for
nil
or
false.
On
the
other
hand,
a
list
with
elemen
ts
will
return
those
elemen
ts
when
it
is
ev
aluated.
Sin e
Ema s
Lisp
 onsiders
as
true
an
y
v
alue
that
is
not
nil,
a
list
that
returns
elemen
ts
will
test
true
in
a
while
lo
op.
F
or
example,
y
ou
 an
set
the
v
ariable
empty-list
to
nil
b
y
ev
aluating
the
follo
wing
setq
expression:
(setq
empty-list
())
After
ev
aluating
the
setq
expression,
y
ou
 an
ev
aluate
the
v
ariable
empty-
list
in
the
usual
w
a
y
,
b
y
pla ing
the
 ursor
after
the
sym
b
ol
and
t
yping
C-x
C-e;
nil
will
app
ear
in
y
our
e 
ho
area:
empty-list
On
the
other
hand,
if
y
ou
set
a
v
ariable
to
b
e
a
list
with
elemen
ts,
the
list
will
app
ear
when
y
ou
ev
aluate
the
v
ariable,
as
y
ou
 an
see
b
y
ev
aluating
the
follo
wing
t
w
o
expressions:
(setq
animals
'(gazelle
giraffe
lion
tiger))
animals
Th
us,
to
 reate
a
while
lo
op
that
tests
whether
there
are
an
y
items
in
the
list
animals,
the
rst
part
of
the
lo
op
will
b
e
written
lik
e
this:
(while
animals
...

An
Example:
print-elements-of-list
123
When
the
while
tests
its
rst
argumen
t,
the
v
ariable
animals
is
ev
aluated.
It
returns
a
list.
So
long
as
the
list
has
elemen
ts,
the
while
 onsiders
the
results
of
the
test
to
b
e
true;
but
when
the
list
is
empt
y
,
it
 onsiders
the
results
of
the
test
to
b
e
false.
T
o
prev
en
t
the
while
lo
op
from
running
forev
er,
some
me 
hanism
needs
to
b
e
pro
vided
to
empt
y
the
list
ev
en
tually
.
An
oft-used
te 
hnique
is
to
ha
v
e
one
of
the
subsequen
t
forms
in
the
while
expression
set
the
v
alue
of
the
list
to
b
e
the
 dr
of
the
list.
Ea 
h
time
the
 dr
fun tion
is
ev
aluated,
the
list
will
b
e
made
shorter,
un
til
ev
en
tually
only
the
empt
y
list
will
b
e
left.
A
t
this
p
oin
t,
the
test
of
the
while
lo
op
will
return
false,
and
the
argumen
ts
to
the
while
will
no
longer
b
e
ev
aluated.
F
or
example,
the
list
of
animals
b
ound
to
the
v
ariable
animals
 an
b
e
set
to
b
e
the
 dr
of
the
original
list
with
the
follo
wing
expression:
(setq
animals
( dr
animals))
If
y
ou
ha
v
e
ev
aluated
the
previous
expressions
and
then
ev
aluate
this
ex-
pression,
y
ou
will
see
(giraffe
lion
tiger)
app
ear
in
the
e 
ho
area.
If
y
ou
ev
aluate
the
expression
again,
(lion
tiger)
will
app
ear
in
the
e 
ho
area.
If
y
ou
ev
aluate
it
again
and
y
et
again,
(tiger)
app
ears
and
then
the
empt
y
list,
sho
wn
b
y
nil.
A
template
for
a
while
lo
op
that
uses
the
 dr
fun tion
rep
eatedly
to
 ause
the
true-or-false-test
ev
en
tually
to
test
false
lo
oks
lik
e
this:
(while
test-whether-list-is-empt
y
b
o
dy
...
set-list-to- dr-of-list
)
This
test
and
use
of
 dr
 an
b
e
put
together
in
a
fun tion
that
go
es
through
a
list
and
prin
ts
ea 
h
elemen
t
of
the
list
on
a
line
of
its
o
wn.
11.1.2
An
Example:
print-elements-of-list
The
print-elements-of-list
fun tion
illustrates
a
while
lo
op
with
a
list.
The
fun tion
requires
sev
eral
lines
for
its
output.
If
y
ou
are
reading
this
in
Ema s
21
or
a
later
v
ersion,
y
ou
 an
ev
aluate
the
follo
wing
expression
inside
of
Info,
as
usual.
If
y
ou
are
using
an
earlier
v
ersion
of
Ema s,
y
ou
need
to
 op
y
the
ne es-
sary
expressions
to
y
our
`*s rat h*'
buer
and
ev
aluate
them
there.
This
is
b
e ause
the
e 
ho
area
had
only
one
line
in
the
earlier
v
ersions.
Y
ou
 an
 op
y
the
expressions
b
y
marking
the
b
eginning
of
the
region
with
C-
h
SPC
i
(set-mark- ommand),
mo
ving
the
 ursor
to
the
end
of
the
region
and
then
 op
ying
the
region
using
M-w
( opy-region-as-kill).
In
the
`*s rat h*'
buer,
y
ou
 an
y
ank
the
expressions
ba 
k
b
y
t
yping
C-y
(yank).
After
y
ou
ha
v
e
 opied
the
expressions
to
the
`*s rat h*'
buer,
ev
aluate
ea 
h
expression
in
turn.
Be
sure
to
ev
aluate
the
last
expression,
(print-
elements-of-list
animals),
b
y
t
yping
C-u
C-x
C-e,
that
is,
b
y
giving
an

124
Chapter
11:
Lo
ops
and
Re ursion
argumen
t
to
eval-last-sexp.
This
will
 ause
the
result
of
the
ev
alua-
tion
to
b
e
prin
ted
in
the
`*s rat h*'
buer
instead
of
b
eing
prin
ted
in
the
e 
ho
area.
(Otherwise
y
ou
will
see
something
lik
e
this
in
y
our
e 
ho
area:
^Jgiraffe^J^Jgazelle^J^Jli
on^J
^Jt
iger
^Jni
l,
in
whi 
h
ea 
h
`^J'
stands
for
a
`newline'.)
If
y
ou
are
using
Ema s
21
or
later,
y
ou
 an
ev
aluate
these
expressions
dire tly
in
the
Info
buer,
and
the
e 
ho
area
will
gro
w
to
sho
w
the
results.
(setq
animals
'(gazelle
giraffe
lion
tiger))
(defun
print-elements-of-list
(list)
"Print
ea h
element
of
LIST
on
a
line
of
its
own."
(while
list
(print
( ar
list))
(setq
list
( dr
list))))
(print-elements-of-list
animals)
When
y
ou
ev
aluate
the
three
expressions
in
sequen e,
y
ou
will
see
this:
giraffe
gazelle
lion
tiger
nil
Ea 
h
elemen
t
of
the
list
is
prin
ted
on
a
line
of
its
o
wn
(that
is
what
the
fun tion
print
do
es)
and
then
the
v
alue
returned
b
y
the
fun tion
is
prin
ted.
Sin e
the
last
expression
in
the
fun tion
is
the
while
lo
op,
and
sin e
while
lo
ops
alw
a
ys
return
nil,
a
nil
is
prin
ted
after
the
last
elemen
t
of
the
list.
11.1.3
A
Lo
op
with
an
In remen
ting
Coun
ter
A
lo
op
is
not
useful
unless
it
stops
when
it
ough
t.
Besides
 on
trolling
a
lo
op
with
a
list,
a
 ommon
w
a
y
of
stopping
a
lo
op
is
to
write
the
rst
argumen
t
as
a
test
that
returns
false
when
the
 orre t
n
um
b
er
of
rep
etitions
are
 omplete.
This
means
that
the
lo
op
m
ust
ha
v
e
a
 oun
ter|an
expression
that
 oun
ts
ho
w
man
y
times
the
lo
op
rep
eats
itself.
The
test
 an
b
e
an
expression
su 
h
as
(<
 ount
desired-number)
whi 
h
returns
t
for
true
if
the
v
alue
of
 ount
is
less
than
the
desired-number
of
rep
etitions
and
nil
for
false
if
the
v
alue
of
 ount
is
equal
to
or
is
greater
than
the
desired-number.
The
expression
that
in remen
ts
the
 oun
t
 an
b
e
a
simple
setq
su 
h
as
(setq
 ount
(1+
 ount)),
where
1+
is
a
built-
in
fun tion
in
Ema s
Lisp
that
adds
1
to
its
argumen
t.
(The
expression

Example
with
in remen
ting
 oun
ter
125
(1+
 ount)
has
the
same
result
as
(+
 ount
1)
,
but
is
easier
for
a
h
uman
to
read.)
The
template
for
a
while
lo
op
 on
trolled
b
y
an
in remen
ting
 oun
ter
lo
oks
lik
e
this:
set- oun
t-to-initial-v
alue
(while
(<
 ount
desired-number)
;
true-or-false-test
b
o
dy
...
(setq
 ount
(1+
 ount)))
;
in remen
ter
Note
that
y
ou
need
to
set
the
initial
v
alue
of
 ount;
usually
it
is
set
to
1.
Example
with
in remen
ting
 oun
ter
Supp
ose
y
ou
are
pla
ying
on
the
b
ea 
h
and
de ide
to
mak
e
a
triangle
of
p
ebbles,
putting
one
p
ebble
in
the
rst
ro
w,
t
w
o
in
the
se ond
ro
w,
three
in
the
third
ro
w
and
so
on,
lik
e
this:










(Ab
out
2500
y
ears
ago,
Pythagoras
and
others
dev
elop
ed
the
b
eginnings
of
n
um
b
er
theory
b
y
 onsidering
questions
su 
h
as
this.)
Supp
ose
y
ou
w
an
t
to
kno
w
ho
w
man
y
p
ebbles
y
ou
will
need
to
mak
e
a
triangle
with
7
ro
ws?
Clearly
,
what
y
ou
need
to
do
is
add
up
the
n
um
b
ers
from
1
to
7.
There
are
t
w
o
w
a
ys
to
do
this;
start
with
the
smallest
n
um
b
er,
one,
and
add
up
the
list
in
sequen e,
1,
2,
3,
4
and
so
on;
or
start
with
the
largest
n
um
b
er
and
add
the
list
going
do
wn:
7,
6,
5,
4
and
so
on.
Be ause
b
oth
me 
hanisms
illustrate
 ommon
w
a
ys
of
writing
while
lo
ops,
w
e
will
 reate
t
w
o
examples,
one
 oun
ting
up
and
the
other
 oun
ting
do
wn.
In
this
rst
example,
w
e
will
start
with
1
and
add
2,
3,
4
and
so
on.
If
y
ou
are
just
adding
up
a
short
list
of
n
um
b
ers,
the
easiest
w
a
y
to
do
it
is
to
add
up
all
the
n
um
b
ers
at
on e.
Ho
w
ev
er,
if
y
ou
do
not
kno
w
ahead
of
time
ho
w
man
y
n
um
b
ers
y
our
list
will
ha
v
e,
or
if
y
ou
w
an
t
to
b
e
prepared
for
a
v
ery
long
list,
then
y
ou
need
to
design
y
our
addition
so
that
what
y
ou
do
is
rep
eat
a
simple
pro
 ess
man
y
times
instead
of
doing
a
more
 omplex
pro
 ess
on e.
F
or
example,
instead
of
adding
up
all
the
p
ebbles
all
at
on e,
what
y
ou
 an
do
is
add
the
n
um
b
er
of
p
ebbles
in
the
rst
ro
w,
1,
to
the
n
um
b
er
in
the
se ond
ro
w,
2,
and
then
add
the
total
of
those
t
w
o
ro
ws
to
the
third
ro
w,
3.
Then
y
ou
 an
add
the
n
um
b
er
in
the
fourth
ro
w,
4,
to
the
total
of
the
rst
three
ro
ws;
and
so
on.

126
Chapter
11:
Lo
ops
and
Re ursion
The
 riti al
 
hara teristi 
of
the
pro
 ess
is
that
ea 
h
rep
etitiv
e
a tion
is
simple.
In
this
 ase,
at
ea 
h
step
w
e
add
only
t
w
o
n
um
b
ers,
the
n
um
b
er
of
p
ebbles
in
the
ro
w
and
the
total
already
found.
This
pro
 ess
of
adding
t
w
o
n
um
b
ers
is
rep
eated
again
and
again
un
til
the
last
ro
w
has
b
een
added
to
the
total
of
all
the
pre eding
ro
ws.
In
a
more
 omplex
lo
op
the
rep
etitiv
e
a tion
migh
t
not
b
e
so
simple,
but
it
will
b
e
simpler
than
doing
ev
erything
all
at
on e.
The
parts
of
the
fun tion
denition
The
pre eding
analysis
giv
es
us
the
b
ones
of
our
fun tion
denition:
rst,
w
e
will
need
a
v
ariable
that
w
e
 an
 all
total
that
will
b
e
the
total
n
um
b
er
of
p
ebbles.
This
will
b
e
the
v
alue
returned
b
y
the
fun tion.
Se ond,
w
e
kno
w
that
the
fun tion
will
require
an
argumen
t:
this
ar-
gumen
t
will
b
e
the
total
n
um
b
er
of
ro
ws
in
the
triangle.
It
 an
b
e
 alled
number-of-rows.
Finally
,
w
e
need
a
v
ariable
to
use
as
a
 oun
ter.
W
e
 ould
 all
this
v
ari-
able
 ounter,
but
a
b
etter
name
is
row-number.
That
is
b
e ause
what
the
 oun
ter
do
es
is
 oun
t
ro
ws,
and
a
program
should
b
e
written
to
b
e
as
understandable
as
p
ossible.
When
the
Lisp
in
terpreter
rst
starts
ev
aluating
the
expressions
in
the
fun tion,
the
v
alue
of
total
should
b
e
set
to
zero,
sin e
w
e
ha
v
e
not
added
an
ything
to
it.
Then
the
fun tion
should
add
the
n
um
b
er
of
p
ebbles
in
the
rst
ro
w
to
the
total,
and
then
add
the
n
um
b
er
of
p
ebbles
in
the
se ond
to
the
total,
and
then
add
the
n
um
b
er
of
p
ebbles
in
the
third
ro
w
to
the
total,
and
so
on,
un
til
there
are
no
more
ro
ws
left
to
add.
Both
total
and
row-number
are
used
only
inside
the
fun tion,
so
they
 an
b
e
de lared
as
lo
 al
v
ariables
with
let
and
giv
en
initial
v
alues.
Clearly
,
the
initial
v
alue
for
total
should
b
e
0.
The
initial
v
alue
of
row-number
should
b
e
1,
sin e
w
e
start
with
the
rst
ro
w.
This
means
that
the
let
statemen
t
will
lo
ok
lik
e
this:
(let
((total
0)
(row-number
1))
b
o
dy
...
)
After
the
in
ternal
v
ariables
are
de lared
and
b
ound
to
their
initial
v
alues,
w
e
 an
b
egin
the
while
lo
op.
The
expression
that
serv
es
as
the
test
should
return
a
v
alue
of
t
for
true
so
long
as
the
row-number
is
less
than
or
equal
to
the
number-of-rows.
(If
the
expression
tests
true
only
so
long
as
the
ro
w
n
um
b
er
is
less
than
the
n
um
b
er
of
ro
ws
in
the
triangle,
the
last
ro
w
will
nev
er
b
e
added
to
the
total;
hen e
the
ro
w
n
um
b
er
has
to
b
e
either
less
than
or
equal
to
the
n
um
b
er
of
ro
ws.)

Putting
the
fun tion
denition
together
127
Lisp
pro
vides
the
<=
fun tion
that
returns
true
if
the
v
alue
of
its
rst
argumen
t
is
less
than
or
equal
to
the
v
alue
of
its
se ond
argumen
t
and
false
otherwise.
So
the
expression
that
the
while
will
ev
aluate
as
its
test
should
lo
ok
lik
e
this:
(<=
row-number
number-of-rows)
The
total
n
um
b
er
of
p
ebbles
 an
b
e
found
b
y
rep
eatedly
adding
the
n
um-
b
er
of
p
ebbles
in
a
ro
w
to
the
total
already
found.
Sin e
the
n
um
b
er
of
p
ebbles
in
the
ro
w
is
equal
to
the
ro
w
n
um
b
er,
the
total
 an
b
e
found
b
y
adding
the
ro
w
n
um
b
er
to
the
total.
(Clearly
,
in
a
more
 omplex
situation,
the
n
um
b
er
of
p
ebbles
in
the
ro
w
migh
t
b
e
related
to
the
ro
w
n
um
b
er
in
a
more
 ompli ated
w
a
y;
if
this
w
ere
the
 ase,
the
ro
w
n
um
b
er
w
ould
b
e
repla ed
b
y
the
appropriate
expression.)
(setq
total
(+
total
row-number))
What
this
do
es
is
set
the
new
v
alue
of
total
to
b
e
equal
to
the
sum
of
adding
the
n
um
b
er
of
p
ebbles
in
the
ro
w
to
the
previous
total.
After
setting
the
v
alue
of
total,
the
 onditions
need
to
b
e
established
for
the
next
rep
etition
of
the
lo
op,
if
there
is
one.
This
is
done
b
y
in remen
ting
the
v
alue
of
the
row-number
v
ariable,
whi 
h
serv
es
as
a
 oun
ter.
After
the
row-number
v
ariable
has
b
een
in remen
ted,
the
true-or-false-test
at
the
b
eginning
of
the
while
lo
op
tests
whether
its
v
alue
is
still
less
than
or
equal
to
the
v
alue
of
the
number-of-rows
and
if
it
is,
adds
the
new
v
alue
of
the
row-number
v
ariable
to
the
total
of
the
previous
rep
etition
of
the
lo
op.
The
built-in
Ema s
Lisp
fun tion
1+
adds
1
to
a
n
um
b
er,
so
the
row-
number
v
ariable
 an
b
e
in remen
ted
with
this
expression:
(setq
row-number
(1+
row-number))
Putting
the
fun tion
denition
together
W
e
ha
v
e
 reated
the
parts
for
the
fun tion
denition;
no
w
w
e
need
to
put
them
together.
First,
the
 on
ten
ts
of
the
while
expression:
(while
(<=
row-number
number-of-rows)
;
true-or-false-test
(setq
total
(+
total
row-number))
(setq
row-number
(1+
row-number)))
;
in remen
ter
Along
with
the
let
expression
v
arlist,
this
v
ery
nearly
 ompletes
the
b
o
dy
of
the
fun tion
denition.
Ho
w
ev
er,
it
requires
one
nal
elemen
t,
the
need
for
whi 
h
is
somewhat
subtle.
The
nal
tou 
h
is
to
pla e
the
v
ariable
total
on
a
line
b
y
itself
after
the
while
expression.
Otherwise,
the
v
alue
returned
b
y
the
whole
fun tion
is
the
v
alue
of
the
last
expression
that
is
ev
aluated
in
the
b
o
dy
of
the
let,
and
this
is
the
v
alue
returned
b
y
the
while,
whi 
h
is
alw
a
ys
nil.
This
ma
y
not
b
e
eviden
t
at
rst
sigh
t.
It
almost
lo
oks
as
if
the
in re-
men
ting
expression
is
the
last
expression
of
the
whole
fun tion.
But
that

128
Chapter
11:
Lo
ops
and
Re ursion
expression
is
part
of
the
b
o
dy
of
the
while;
it
is
the
last
elemen
t
of
the
list
that
starts
with
the
sym
b
ol
while.
Moreo
v
er,
the
whole
of
the
while
lo
op
is
a
list
within
the
b
o
dy
of
the
let.
In
outline,
the
fun tion
will
lo
ok
lik
e
this:
(defun
name-of-fun tion
(argumen
t-list
)
"do
 umen
tation...
"
(let
(v
arlist
)
(while
(true-or-false-test
)
b
o
dy-of-while
...
)
...
)
;
Need
nal
expression
here.
The
result
of
ev
aluating
the
let
is
what
is
going
to
b
e
returned
b
y
the
defun
sin e
the
let
is
not
em
b
edded
within
an
y
 on
taining
list,
ex ept
for
the
defun
as
a
whole.
Ho
w
ev
er,
if
the
while
is
the
last
elemen
t
of
the
let
expression,
the
fun tion
will
alw
a
ys
return
nil.
This
is
not
what
w
e
w
an
t!
Instead,
what
w
e
w
an
t
is
the
v
alue
of
the
v
ariable
total.
This
is
returned
b
y
simply
pla ing
the
sym
b
ol
as
the
last
elemen
t
of
the
list
starting
with
let.
It
gets
ev
aluated
after
the
pre eding
elemen
ts
of
the
list
are
ev
aluated,
whi 
h
means
it
gets
ev
aluated
after
it
has
b
een
assigned
the
 orre t
v
alue
for
the
total.
It
ma
y
b
e
easier
to
see
this
b
y
prin
ting
the
list
starting
with
let
all
on
one
line.
This
format
mak
es
it
eviden
t
that
the
v
arlist
and
while
expressions
are
the
se ond
and
third
elemen
ts
of
the
list
starting
with
let,
and
the
total
is
the
last
elemen
t:
(let
(v
arlist
)
(while
(true-or-false-test
)
b
o
dy-of-while
...
)
total)
Putting
ev
erything
together,
the
triangle
fun tion
denition
lo
oks
lik
e
this:
(defun
triangle
(number-of-rows)
;
V
ersion
with
;
in remen
ting
 oun
ter.
"Add
up
the
number
of
pebbles
in
a
triangle.
The
first
row
has
one
pebble,
the
se ond
row
two
pebbles,
the
third
row
three
pebbles,
and
so
on.
The
argument
is
NUMBER-OF-ROWS."
(let
((total
0)
(row-number
1))
(while
(<=
row-number
number-of-rows)
(setq
total
(+
total
row-number))
(setq
row-number
(1+
row-number)))
total))

Example
with
de remen
ting
 oun
ter
129
After
y
ou
ha
v
e
installed
triangle
b
y
ev
aluating
the
fun tion,
y
ou
 an
try
it
out.
Here
are
t
w
o
examples:
(triangle
4)
(triangle
7)
The
sum
of
the
rst
four
n
um
b
ers
is
10
and
the
sum
of
the
rst
sev
en
n
um
b
ers
is
28.
11.1.4
Lo
op
with
a
De remen
ting
Coun
ter
Another
 ommon
w
a
y
to
write
a
while
lo
op
is
to
write
the
test
so
that
it
determines
whether
a
 oun
ter
is
greater
than
zero.
So
long
as
the
 oun
ter
is
greater
than
zero,
the
lo
op
is
rep
eated.
But
when
the
 oun
ter
is
equal
to
or
less
than
zero,
the
lo
op
is
stopp
ed.
F
or
this
to
w
ork,
the
 oun
ter
has
to
start
out
greater
than
zero
and
then
b
e
made
smaller
and
smaller
b
y
a
form
that
is
ev
aluated
rep
eatedly
.
The
test
will
b
e
an
expression
su 
h
as
(>
 ounter
0)
whi 
h
returns
t
for
true
if
the
v
alue
of
 ounter
is
greater
than
zero,
and
nil
for
false
if
the
v
alue
of
 ounter
is
equal
to
or
less
than
zero.
The
expression
that
mak
es
the
n
um
b
er
smaller
and
smaller
 an
b
e
a
simple
setq
su 
h
as
(setq
 ounter
(1-
 ounter)),
where
1-
is
a
built-in
fun tion
in
Ema s
Lisp
that
subtra ts
1
from
its
argumen
t.
The
template
for
a
de remen
ting
while
lo
op
lo
oks
lik
e
this:
(while
(>
 ounter
0)
;
true-or-false-test
b
o
dy
...
(setq
 ounter
(1-
 ounter)))
;
de remen
ter
Example
with
de remen
ting
 oun
ter
T
o
illustrate
a
lo
op
with
a
de remen
ting
 oun
ter,
w
e
will
rewrite
the
triangle
fun tion
so
the
 oun
ter
de reases
to
zero.
This
is
the
rev
erse
of
the
earlier
v
ersion
of
the
fun tion.
In
this
 ase,
to
nd
out
ho
w
man
y
p
ebbles
are
needed
to
mak
e
a
triangle
with
3
ro
ws,
add
the
n
um
b
er
of
p
ebbles
in
the
third
ro
w,
3,
to
the
n
um
b
er
in
the
pre eding
ro
w,
2,
and
then
add
the
total
of
those
t
w
o
ro
ws
to
the
ro
w
that
pre edes
them,
whi 
h
is
1.
Lik
ewise,
to
nd
the
n
um
b
er
of
p
ebbles
in
a
triangle
with
7
ro
ws,
add
the
n
um
b
er
of
p
ebbles
in
the
sev
en
th
ro
w,
7,
to
the
n
um
b
er
in
the
pre eding
ro
w,
whi 
h
is
6,
and
then
add
the
total
of
those
t
w
o
ro
ws
to
the
ro
w
that
pre edes
them,
whi 
h
is
5,
and
so
on.
As
in
the
previous
example,
ea 
h
addition
only
in
v
olv
es
adding
t
w
o
n
um
b
ers,
the
total
of
the
ro
ws
already
added
up
and
the
n
um
b
er
of
p
ebbles
in
the
ro
w
that
is
b
eing
added
to
the
total.
This
pro
 ess
of
adding
t
w
o
n
um
b
ers
is
rep
eated
again
and
again
un
til
there
are
no
more
p
ebbles
to
add.

130
Chapter
11:
Lo
ops
and
Re ursion
W
e
kno
w
ho
w
man
y
p
ebbles
to
start
with:
the
n
um
b
er
of
p
ebbles
in
the
last
ro
w
is
equal
to
the
n
um
b
er
of
ro
ws.
If
the
triangle
has
sev
en
ro
ws,
the
n
um
b
er
of
p
ebbles
in
the
last
ro
w
is
7.
Lik
ewise,
w
e
kno
w
ho
w
man
y
p
ebbles
are
in
the
pre eding
ro
w:
it
is
one
less
than
the
n
um
b
er
in
the
ro
w.
The
parts
of
the
fun tion
denition
W
e
start
with
three
v
ariables:
the
total
n
um
b
er
of
ro
ws
in
the
triangle;
the
n
um
b
er
of
p
ebbles
in
a
ro
w;
and
the
total
n
um
b
er
of
p
ebbles,
whi 
h
is
what
w
e
w
an
t
to
 al ulate.
These
v
ariables
 an
b
e
named
number-of-rows,
number-of-pebbles-in-row
,
and
total,
resp
e tiv
ely
.
Both
total
and
number-of-pebbles-in-row
are
used
only
inside
the
fun tion
and
are
de lared
with
let.
The
initial
v
alue
of
total
should,
of
 ourse,
b
e
zero.
Ho
w
ev
er,
the
initial
v
alue
of
number-of-pebbles-in-ro
w
should
b
e
equal
to
the
n
um
b
er
of
ro
ws
in
the
triangle,
sin e
the
addition
will
start
with
the
longest
ro
w.
This
means
that
the
b
eginning
of
the
let
expression
will
lo
ok
lik
e
this:
(let
((total
0)
(number-of-pebbles-in-row
number-of-rows))
b
o
dy
...
)
The
total
n
um
b
er
of
p
ebbles
 an
b
e
found
b
y
rep
eatedly
adding
the
n
um-
b
er
of
p
ebbles
in
a
ro
w
to
the
total
already
found,
that
is,
b
y
rep
eatedly
ev
aluating
the
follo
wing
expression:
(setq
total
(+
total
number-of-pebbles-in-row))
After
the
number-of-pebbles-in-row
is
added
to
the
total,
the
number-
of-pebbles-in-row
should
b
e
de remen
ted
b
y
one,
sin e
the
next
time
the
lo
op
rep
eats,
the
pre eding
ro
w
will
b
e
added
to
the
total.
The
n
um
b
er
of
p
ebbles
in
a
pre eding
ro
w
is
one
less
than
the
n
um
b
er
of
p
ebbles
in
a
ro
w,
so
the
built-in
Ema s
Lisp
fun tion
1-
 an
b
e
used
to
 ompute
the
n
um
b
er
of
p
ebbles
in
the
pre eding
ro
w.
This
 an
b
e
done
with
the
follo
wing
expression:
(setq
number-of-pebbles-in-row
(1-
number-of-pebbles-in-row))
Finally
,
w
e
kno
w
that
the
while
lo
op
should
stop
making
rep
eated
addi-
tions
when
there
are
no
p
ebbles
in
a
ro
w.
So
the
test
for
the
while
lo
op
is
simply:
(while
(>
number-of-pebbles-in-row
0)
Putting
the
fun tion
denition
together
W
e
 an
put
these
expressions
together
to
 reate
a
fun tion
denition
that
w
orks.
Ho
w
ev
er,
on
examination,
w
e
nd
that
one
of
the
lo
 al
v
ariables
is
unneeded!

Sa
v
e
y
our
time:
dolist
and
dotimes
131
The
fun tion
denition
lo
oks
lik
e
this:
;;;
First
subtra tiv
e
v
ersion.
(defun
triangle
(number-of-rows)
"Add
up
the
number
of
pebbles
in
a
triangle."
(let
((total
0)
(number-of-pebbles-in-row
number-of-rows))
(while
(>
number-of-pebbles-in-row
0)
(setq
total
(+
total
number-of-pebbles-in-row))
(setq
number-of-pebbles-in-row
(1-
number-of-pebbles-in-row)))
total))
As
written,
this
fun tion
w
orks.
Ho
w
ev
er,
w
e
do
not
need
number-of-pebbles-in-row
.
When
the
triangle
fun tion
is
ev
aluated,
the
sym
b
ol
number-of-rows
will
b
e
b
ound
to
a
n
um
b
er,
giving
it
an
initial
v
alue.
That
n
um
b
er
 an
b
e
 
hanged
in
the
b
o
dy
of
the
fun tion
as
if
it
w
ere
a
lo
 al
v
ariable,
without
an
y
fear
that
su 
h
a
 
hange
will
ee t
the
v
alue
of
the
v
ariable
outside
of
the
fun tion.
This
is
a
v
ery
useful
 
hara teristi 
of
Lisp;
it
means
that
the
v
ariable
number-of-rows
 an
b
e
used
an
ywhere
in
the
fun tion
where
number-of-pebbles-in-row
is
used.
Here
is
a
se ond
v
ersion
of
the
fun tion
written
a
bit
more
 leanly:
(defun
triangle
(number)
;
Se ond
v
ersion.
"Return
sum
of
numbers
1
through
NUMBER
in lusive."
(let
((total
0))
(while
(>
number
0)
(setq
total
(+
total
number))
(setq
number
(1-
number)))
total))
In
brief,
a
prop
erly
written
while
lo
op
will
 onsist
of
three
parts:
1.
A
test
that
will
return
false
after
the
lo
op
has
rep
eated
itself
the
 orre t
n
um
b
er
of
times.
2.
An
expression
the
ev
aluation
of
whi 
h
will
return
the
v
alue
desired
after
b
eing
rep
eatedly
ev
aluated.
3.
An
expression
to
 
hange
the
v
alue
passed
to
the
true-or-false-test
so
that
the
test
returns
false
after
the
lo
op
has
rep
eated
itself
the
righ
t
n
um
b
er
of
times.
11.2
Sa
v
e
y
our
time:
dolist
and
dotimes
In
addition
to
while,
b
oth
dolist
and
dotimes
pro
vide
for
lo
oping.
Sometimes
these
are
qui 
k
er
to
write
than
the
equiv
alen
t
while
lo
op.
Both
are
Lisp
ma ros.
(See
se tion
\Ma ros"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
)

132
Chapter
11:
Lo
ops
and
Re ursion
dolist
w
orks
lik
e
a
while
lo
op
that
` drs
do
wn
a
list':
dolist
auto-
mati ally
shortens
the
list
ea 
h
time
it
lo
ops|tak
es
the
 dr
of
the
list|and
binds
the
 ar
of
ea 
h
shorter
v
ersion
of
the
list
to
the
rst
of
its
argumen
ts.
dotimes
lo
ops
a
sp
e i 
n
um
b
er
of
time:
y
ou
sp
e ify
the
n
um
b
er.
The
dolist
Ma ro
Supp
ose,
for
example,
y
ou
w
an
t
to
rev
erse
a
list,
so
that
\rst"
\se ond"
\third"
b
e omes
\third"
\se ond"
\rst".
In
pra ti e,
y
ou
w
ould
use
the
reverse
fun tion,
lik
e
this:
(setq
animals
'(gazelle
giraffe
lion
tiger))
(reverse
animals)
Here
is
ho
w
y
ou
 ould
rev
erse
the
list
using
a
while
lo
op:
(setq
animals
'(gazelle
giraffe
lion
tiger))
(defun
reverse-list-with-while
(list)
"Using
while,
reverse
the
order
of
LIST."
(let
(value)
;
make
sure
list
starts
empty
(while
list
(setq
value
( ons
( ar
list)
value))
(setq
list
( dr
list)))
value))
(reverse-list-with-while
animals)
And
here
is
ho
w
y
ou
 ould
use
the
dolist
ma ro:
(setq
animals
'(gazelle
giraffe
lion
tiger))
(defun
reverse-list-with-dolist
(list)
"Using
dolist,
reverse
the
order
of
LIST."
(let
(value)
;
make
sure
list
starts
empty
(dolist
(element
list
value)
(setq
value
( ons
element
value)))))
(reverse-list-with-dolist
animals)
In
Info,
y
ou
 an
pla e
y
our
 ursor
after
the
 losing
paren
thesis
of
ea 
h
ex-
pression
and
t
yp
e
C-x
C-e;
in
ea 
h
 ase,
y
ou
should
see
(tiger
lion
giraffe
gazelle)
in
the
e 
ho
area.
F
or
this
example,
the
existing
reverse
fun tion
is
ob
viously
b
est.
The
while
lo
op
is
just
lik
e
our
rst
example
(see
Se tion
11.1.1,
\A
while
Lo
op
and
a
List",
page
122).
The
while
rst
 
he 
ks
whether
the
list
has
elemen
ts;
if
so,
it
 onstru ts
a
new
list
b
y
adding
the
rst
elemen
t
of
the
list
to
the

The
dotimes
Ma ro
133
existing
list
(whi 
h
in
the
rst
iteration
of
the
lo
op
is
nil).
Sin e
the
se ond
elemen
t
is
prep
ended
in
fron
t
of
the
rst
elemen
t,
and
the
third
elemen
t
is
prep
ended
in
fron
t
of
the
se ond
elemen
t,
the
list
is
rev
ersed.
In
the
expression
using
a
while
lo
op,
the
(setq
list
( dr
list))
ex-
pression
shortens
the
list,
so
the
while
lo
op
ev
en
tually
stops.
In
addition,
it
pro
vides
the
 ons
expression
with
a
new
rst
elemen
t
b
y
 reating
a
new
and
shorter
list
at
ea 
h
rep
etition
of
the
lo
op.
The
dolist
expression
do
es
v
ery
m
u 
h
the
same
as
the
while
expression,
ex ept
that
the
dolist
ma ro
do
es
some
of
the
w
ork
y
ou
ha
v
e
to
do
when
writing
a
while
expression.
Lik
e
a
while
lo
op,
a
dolist
lo
ops.
What
is
dieren
t
is
that
it
automat-
i ally
shortens
the
list
ea 
h
time
it
lo
ops
|
it
` drs
do
wn
the
list'
on
its
o
wn
|
and
it
automati ally
binds
the
 ar
of
ea 
h
shorter
v
ersion
of
the
list
to
the
rst
of
its
argumen
ts.
In
the
example,
the
 ar
of
ea 
h
shorter
v
ersion
of
the
list
is
referred
to
using
the
sym
b
ol
`element',
the
list
itself
is
 alled
`list',
and
the
v
alue
returned
is
 alled
`value'.
The
remainder
of
the
dolist
expression
is
the
b
o
dy
.
The
dolist
expression
binds
the
 ar
of
ea 
h
shorter
v
ersion
of
the
list
to
element
and
then
ev
aluates
the
b
o
dy
of
the
expression;
and
rep
eats
the
lo
op.
The
result
is
returned
in
value.
The
dotimes
Ma ro
The
dotimes
ma ro
is
similar
to
dolist,
ex ept
that
it
lo
ops
a
sp
e i 
n
um
b
er
of
times.
The
rst
argumen
t
to
dotimes
is
assigned
the
n
um
b
ers
0,
1,
2
and
so
forth
ea 
h
time
around
the
lo
op,
and
the
v
alue
of
the
third
argumen
t
is
returned.
Y
ou
need
to
pro
vide
the
v
alue
of
the
se ond
argumen
t,
whi 
h
is
ho
w
man
y
times
the
ma ro
lo
ops.
F
or
example,
the
follo
wing
binds
the
n
um
b
ers
from
0
up
to,
but
not
in luding,
the
n
um
b
er
3
to
the
rst
argumen
t,
n
um
b
er,
and
then
 onstru ts
a
list
of
the
three
n
um
b
ers.
(The
rst
n
um
b
er
is
0,
the
se ond
n
um
b
er
is
1,
and
the
third
n
um
b
er
is
2;
this
mak
es
a
total
of
three
n
um
b
ers
in
all,
starting
with
zero
as
the
rst
n
um
b
er.)
(let
(value)
;
otherwise
a
value
is
a
void
variable
(dotimes
(number
3
value)
(setq
value
( ons
number
value))))
)
(2
1
0)
dotimes
returns
value,
so
the
w
a
y
to
use
dotimes
is
to
op
erate
on
some
expression
n
um
b
er
n
um
b
er
of
times
and
then
return
the
result,
either
as
a
list
or
an
atom.

134
Chapter
11:
Lo
ops
and
Re ursion
Here
is
an
example
of
a
defun
that
uses
dotimes
to
add
up
the
n
um
b
er
of
p
ebbles
in
a
triangle.
(defun
triangle-using-dotimes
(number-of-rows)
"Using
dotimes,
add
up
the
number
of
pebbles
in
a
triangle."
(let
((total
0))
;
otherwise
a
total
is
a
void
variable
(dotimes
(number
number-of-rows
total)
(setq
total
(+
total
(1+
number))))))
(triangle-using-dotimes
4)
11.3
Re ursion
A
re ursiv
e
fun tion
 on
tains
 o
de
that
tells
the
Lisp
in
terpreter
to
 all
a
program
that
runs
exa tly
lik
e
itself,
but
with
sligh
tly
dieren
t
argumen
ts.
The
 o
de
runs
exa tly
the
same
b
e ause
it
has
the
same
name.
Ho
w
ev
er,
ev
en
though
it
has
the
same
name,
it
is
not
the
same
thread
of
exe ution.
It
is
dieren
t.
In
the
jargon,
it
is
a
dieren
t
`instan e'.
Ev
en
tually
,
if
the
program
is
written
 orre tly
,
the
`sligh
tly
dieren
t
ar-
gumen
ts'
will
b
e ome
suÆ ien
tly
dieren
t
from
the
rst
argumen
ts
that
the
nal
instan e
will
stop.
11.3.1
Building
Rob
ots:
Extending
the
Metaphor
It
is
sometimes
helpful
to
think
of
a
running
program
as
a
rob
ot
that
do
es
a
job.
In
doing
its
job,
a
re ursiv
e
fun tion
 alls
on
a
se ond
rob
ot
to
help
it.
The
se ond
rob
ot
is
iden
ti al
to
the
rst
in
ev
ery
w
a
y
,
ex ept
that
the
se ond
rob
ot
helps
the
rst
and
has
b
een
passed
dieren
t
argumen
ts
than
the
rst.
In
a
re ursiv
e
fun tion,
the
se ond
rob
ot
ma
y
 all
a
third;
and
the
third
ma
y
 all
a
fourth,
and
so
on.
Ea 
h
of
these
is
a
dieren
t
en
tit
y;
but
all
are
 lones.
Sin e
ea 
h
rob
ot
has
sligh
tly
dieren
t
instru tions|the
argumen
ts
will
dier
from
one
rob
ot
to
the
next|the
last
rob
ot
should
kno
w
when
to
stop.
Let's
expand
on
the
metaphor
in
whi 
h
a
 omputer
program
is
a
rob
ot.
A
fun tion
denition
pro
vides
the
blueprin
ts
for
a
rob
ot.
When
y
ou
install
a
fun tion
denition,
that
is,
when
y
ou
ev
aluate
a
defun
sp
e ial
form,
y
ou
install
the
ne essary
equipmen
t
to
build
rob
ots.
It
is
as
if
y
ou
w
ere
in
a
fa tory
,
setting
up
an
assem
bly
line.
Rob
ots
with
the
same
name
are
built
a  ording
to
the
same
blueprin
ts.
So
they
ha
v
e,
as
it
w
ere,
the
same
`mo
del
n
um
b
er',
but
a
dieren
t
`serial
n
um
b
er'.
W
e
often
sa
y
that
a
re ursiv
e
fun tion
` alls
itself
'.
What
w
e
mean
is
that
the
instru tions
in
a
re ursiv
e
fun tion
 ause
the
Lisp
in
terpreter
to
run
a
dieren
t
fun tion
that
has
the
same
name
and
do
es
the
same
job
as
the
rst,
but
with
dieren
t
argumen
ts.

Re ursion
with
a
List
135
It
is
imp
ortan
t
that
the
argumen
ts
dier
from
one
instan e
to
the
next;
otherwise,
the
pro
 ess
will
nev
er
stop.
11.3.2
The
P
arts
of
a
Re ursiv
e
Denition
A
re ursiv
e
fun tion
t
ypi ally
 on
tains
a
 onditional
expression
whi 
h
has
three
parts:
1.
A
true-or-false-test
that
determines
whether
the
fun tion
is
 alled
again,
here
 alled
the
do-again-test.
2.
The
name
of
the
fun tion.
When
this
name
is
 alled,
a
new
instan e
of
the
fun tion|a
new
rob
ot,
as
it
w
ere|is
 reated
and
told
what
to
do.
3.
An
expression
that
returns
a
dieren
t
v
alue
ea 
h
time
the
fun tion
is
 alled,
here
 alled
the
next-step-expression.
Consequen
tly
,
the
argu-
men
t
(or
argumen
ts)
passed
to
the
new
instan e
of
the
fun tion
will
b
e
dieren
t
from
that
passed
to
the
previous
instan e.
This
 auses
the
 onditional
expression,
the
do-again-test,
to
test
false
after
the
 orre t
n
um
b
er
of
rep
etitions.
Re ursiv
e
fun tions
 an
b
e
m
u 
h
simpler
than
an
y
other
kind
of
fun tion.
Indeed,
when
p
eople
rst
start
to
use
them,
they
often
lo
ok
so
m
ysteriously
simple
as
to
b
e
in omprehensible.
Lik
e
riding
a
bi y le,
reading
a
re ursiv
e
fun tion
denition
tak
es
a
 ertain
kna 
k
whi 
h
is
hard
at
rst
but
then
seems
simple.
There
are
sev
eral
dieren
t
 ommon
re ursiv
e
patterns.
A
v
ery
simple
pattern
lo
oks
lik
e
this:
(defun
name-of-re ursiv
e-fun tion
(argumen
t-list
)
"do
 umen
tation...
"
(if
do-again-test
b
o
dy
...
(name-of-re ursiv
e-fun tion
next-step-expression)))
Ea 
h
time
a
re ursiv
e
fun tion
is
ev
aluated,
a
new
instan e
of
it
is
 reated
and
told
what
to
do.
The
argumen
ts
tell
the
instan e
what
to
do.
An
argumen
t
is
b
ound
to
the
v
alue
of
the
next-step-expression.
Ea 
h
instan e
runs
with
a
dieren
t
v
alue
of
the
next-step-expression.
The
v
alue
in
the
next-step-expression
is
used
in
the
do-again-test.
The
v
alue
returned
b
y
the
next-step-expression
is
passed
to
the
new
in-
stan e
of
the
fun tion,
whi 
h
ev
aluates
it
(or
some
transmogri ation
of
it)
to
determine
whether
to
 on
tin
ue
or
stop.
The
next-step-expression
is
de-
signed
so
that
the
do-again-test
returns
false
when
the
fun tion
should
no
longer
b
e
rep
eated.
The
do-again-test
is
sometimes
 alled
the
stop
 ondition,
sin e
it
stops
the
rep
etitions
when
it
tests
false.

136
Chapter
11:
Lo
ops
and
Re ursion
11.3.3
Re ursion
with
a
List
The
example
of
a
while
lo
op
that
prin
ted
the
elemen
ts
of
a
list
of
n
um
b
ers
 an
b
e
written
re ursiv
ely
.
Here
is
the
 o
de,
in luding
an
expression
to
set
the
v
alue
of
the
v
ariable
animals
to
a
list.
If
y
ou
are
using
Ema s
20
or
b
efore,
this
example
m
ust
b
e
 opied
to
the
`*s rat h*'
buer
and
ea 
h
expression
m
ust
b
e
ev
aluated
there.
Use
C-u
C-
x
C-e
to
ev
aluate
the
(print-elements-re ursiv
ely
animals)
expression
so
that
the
results
are
prin
ted
in
the
buer;
otherwise
the
Lisp
in
terpreter
will
try
to
squeeze
the
results
in
to
the
one
line
of
the
e 
ho
area.
Also,
pla e
y
our
 ursor
immediately
after
the
last
 losing
paren
thesis
of
the
print-elements-re ursivel
y
fun tion,
b
efore
the
 ommen
t.
Other-
wise,
the
Lisp
in
terpreter
will
try
to
ev
aluate
the
 ommen
t.
If
y
ou
are
using
Ema s
21
or
later,
y
ou
 an
ev
aluate
this
expression
dire tly
in
Info.
(setq
animals
'(gazelle
giraffe
lion
tiger))
(defun
print-elements-re ursively
(list)
"Print
ea h
element
of
LIST
on
a
line
of
its
own.
Uses
re ursion."
(if
list
;
do-again-test
(progn
(print
( ar
list))
;
b
o
dy
(print-elements-re ursively
;
re ursiv
e
 all
( dr
list)))))
;
next-step-expression
(print-elements-re ursively
animals)
The
print-elements-re ursive
ly
fun tion
rst
tests
whether
there
is
an
y
 on
ten
t
in
the
list;
if
there
is,
the
fun tion
prin
ts
the
rst
elemen
t
of
the
list,
the
 ar
of
the
list.
Then
the
fun tion
`in
v
ok
es
itself
',
but
giv
es
itself
as
its
argumen
t,
not
the
whole
list,
but
the
se ond
and
subsequen
t
elemen
ts
of
the
list,
the
 dr
of
the
list.
Put
another
w
a
y
,
if
the
list
is
not
empt
y
,
the
fun tion
in
v
ok
es
another
instan e
of
 o
de
that
is
similar
to
the
initial
 o
de,
but
is
a
dieren
t
thread
of
exe ution,
with
dieren
t
argumen
ts
than
the
rst
instan e.
Put
in
y
et
another
w
a
y
,
if
the
list
is
not
empt
y
,
the
rst
rob
ot
assem
blies
a
se ond
rob
ot
and
tells
it
what
to
do;
the
se ond
rob
ot
is
a
dieren
t
individual
from
the
rst,
but
is
the
same
mo
del.
When
the
se ond
ev
aluation
o
  urs,
the
if
expression
is
ev
aluated
and
if
true,
prin
ts
the
rst
elemen
t
of
the
list
it
re eiv
es
as
its
argumen
t
(whi 
h
is
the
se ond
elemen
t
of
the
original
list).
Then
the
fun tion
` alls
itself
'
with
the
 dr
of
the
list
it
is
in
v
ok
ed
with,
whi 
h
(the
se ond
time
around)
is
the
 dr
of
the
 dr
of
the
original
list.

Re ursion
in
Pla e
of
a
Coun
ter
137
Note
that
although
w
e
sa
y
that
the
fun tion
` alls
itself
',
what
w
e
mean
is
that
the
Lisp
in
terpreter
assem
bles
and
instru ts
a
new
instan e
of
the
program.
The
new
instan e
is
a
 lone
of
the
rst,
but
is
a
separate
individual.
Ea 
h
time
the
fun tion
`in
v
ok
es
itself
',
it
in
v
ok
es
itself
on
a
shorter
v
ersion
of
the
original
list.
It
 reates
a
new
instan e
that
w
orks
on
a
shorter
list.
Ev
en
tually
,
the
fun tion
in
v
ok
es
itself
on
an
empt
y
list.
It
 reates
a
new
instan e
whose
argumen
t
is
nil.
The
 onditional
expression
tests
the
v
alue
of
list.
Sin e
the
v
alue
of
list
is
nil,
the
if
expression
tests
false
so
the
then-part
is
not
ev
aluated.
The
fun tion
as
a
whole
then
returns
nil.
When
y
ou
ev
aluate
(print-elements-re ursiv
ely
animals)
in
the
`*s rat h*'
buer,
y
ou
see
this
result:
giraffe
gazelle
lion
tiger
nil
11.3.4
Re ursion
in
Pla e
of
a
Coun
ter
The
triangle
fun tion
des rib
ed
in
a
previous
se tion
 an
also
b
e
written
re ursiv
ely
.
It
lo
oks
lik
e
this:
(defun
triangle-re ursively
(number)
"Return
the
sum
of
the
numbers
1
through
NUMBER
in lusive.
Uses
re ursion."
(if
(=
number
1)
;
do-again-test
1
;
then-part
(+
number
;
else-part
(triangle-re ursively
;
re ursiv
e
 all
(1-
number)))))
;
next-step-expression
(triangle-re ursively
7)
Y
ou
 an
install
this
fun tion
b
y
ev
aluating
it
and
then
try
it
b
y
ev
aluating
(triangle-re ursively
7).
(Remem
b
er
to
put
y
our
 ursor
immediately
after
the
last
paren
thesis
of
the
fun tion
denition,
b
efore
the
 ommen
t.)
The
fun tion
ev
aluates
to
28.
T
o
understand
ho
w
this
fun tion
w
orks,
let's
 onsider
what
happ
ens
in
the
v
arious
 ases
when
the
fun tion
is
passed
1,
2,
3,
or
4
as
the
v
alue
of
its
argumen
t.
First,
what
happ
ens
if
the
v
alue
of
the
argumen
t
is
1?
The
fun tion
has
an
if
expression
after
the
do
 umen
tation
string.
It
tests
whether
the
v
alue
of
number
is
equal
to
1;
if
so,
Ema s
ev
aluates
the

138
Chapter
11:
Lo
ops
and
Re ursion
then-part
of
the
if
expression,
whi 
h
returns
the
n
um
b
er
1
as
the
v
alue
of
the
fun tion.
(A
triangle
with
one
ro
w
has
one
p
ebble
in
it.)
Supp
ose,
ho
w
ev
er,
that
the
v
alue
of
the
argumen
t
is
2.
In
this
 ase,
Ema s
ev
aluates
the
else-part
of
the
if
expression.
The
else-part
 onsists
of
an
addition,
the
re ursiv
e
 all
to
triangle-
re ursively
and
a
de remen
ting
a tion;
and
it
lo
oks
lik
e
this:
(+
number
(triangle-re ursively
(1-
number)))
When
Ema s
ev
aluates
this
expression,
the
innermost
expression
is
ev
al-
uated
rst;
then
the
other
parts
in
sequen e.
Here
are
the
steps
in
detail:
Step
1
Evaluate
the
innermost
expr
ession.
The
innermost
expression
is
(1-
number)
so
Ema s
de remen
ts
the
v
alue
of
number
from
2
to
1.
Step
2
Evaluate
the
triangle-re ursively
fun tion.
The
Lisp
in
terpreter
 reates
an
individual
instan e
of
triangle-
re ursively.
It
do
es
not
matter
that
this
fun tion
is
 on
tained
within
itself.
Ema s
passes
the
result
Step
1
as
the
argumen
t
used
b
y
this
instan e
of
the
triangle-re ursively
fun tion
In
this
 ase,
Ema s
ev
aluates
triangle-re ursively
with
an
argumen
t
of
1.
This
means
that
this
ev
aluation
of
triangle-
re ursively
returns
1.
Step
3
Evaluate
the
value
of
number.
The
v
ariable
number
is
the
se ond
elemen
t
of
the
list
that
starts
with
+;
its
v
alue
is
2.
Step
4
Evaluate
the
+
expr
ession.
The
+
expression
re eiv
es
t
w
o
argumen
ts,
the
rst
from
the
ev
al-
uation
of
number
(Step
3)
and
the
se ond
from
the
ev
aluation
of
triangle-re ursively
(Step
2).
The
result
of
the
addition
is
the
sum
of
2
plus
1,
and
the
n
um
b
er
3
is
returned,
whi 
h
is
 orre t.
A
triangle
with
t
w
o
ro
ws
has
three
p
ebbles
in
it.
An
argumen
t
of
3
or
4
Supp
ose
that
triangle-re ursively
is
 alled
with
an
argumen
t
of
3.
Step
1
Evaluate
the
do-again-test.
The
if
expression
is
ev
aluated
rst.
This
is
the
do-again
test
and
returns
false,
so
the
else-part
of
the
if
expression
is
ev
aluated.
(Note
that
in
this
example,
the
do-again-test
 auses
the
fun tion
to
 all
itself
when
it
tests
false,
not
when
it
tests
true.)
Step
2
Evaluate
the
innermost
expr
ession
of
the
else-p
art.
The
innermost
expression
of
the
else-part
is
ev
aluated,
whi 
h
de remen
ts
3
to
2.
This
is
the
next-step-expression.

Re ursion
Example
Using
 ond
139
Step
3
Evaluate
the
triangle-re ursively
fun tion.
The
n
um
b
er
2
is
passed
to
the
triangle-re ursively
fun tion.
W
e
kno
w
what
happ
ens
when
Ema s
ev
aluates
triangle-
re ursively
with
an
argumen
t
of
2.
After
going
through
the
sequen e
of
a tions
des rib
ed
earlier,
it
returns
a
v
alue
of
3.
So
that
is
what
will
happ
en
here.
Step
4
Evaluate
the
addition.
3
will
b
e
passed
as
an
argumen
t
to
the
addition
and
will
b
e
added
to
the
n
um
b
er
with
whi 
h
the
fun tion
w
as
 alled,
whi 
h
is
3.
The
v
alue
returned
b
y
the
fun tion
as
a
whole
will
b
e
6.
No
w
that
w
e
kno
w
what
will
happ
en
when
triangle-re ursively
is
 alled
with
an
argumen
t
of
3,
it
is
eviden
t
what
will
happ
en
if
it
is
 alled
with
an
argumen
t
of
4:
In
the
re ursiv
e
 all,
the
ev
aluation
of
(triangle-re ursively
(1-
4))
will
return
the
v
alue
of
ev
aluating
(triangle-re ursively
3)
whi 
h
is
6
and
this
v
alue
will
b
e
added
to
4
b
y
the
addition
in
the
third
line.
The
v
alue
returned
b
y
the
fun tion
as
a
whole
will
b
e
10.
Ea 
h
time
triangle-re ursively
is
ev
aluated,
it
ev
aluates
a
v
ersion
of
itself|a
dieren
t
instan e
of
itself|with
a
smaller
argumen
t,
un
til
the
argumen
t
is
small
enough
so
that
it
do
es
not
ev
aluate
itself.
Note
that
this
parti ular
design
for
a
re ursiv
e
fun tion
requires
that
op
erations
b
e
deferred.
Before
(triangle-re ursively
7)
 an
 al ulate
its
answ
er,
it
m
ust
 all
(triangle-re ursively
6);
and
b
efore
(triangle-re ursively
6)
 an
 al ulate
its
answ
er,
it
m
ust
 all
(triangle-re ursively
5);
and
so
on.
That
is
to
sa
y
,
the
 al ulation
that
(triangle-re ursively
7)
mak
es
m
ust
b
e
deferred
un
til
(triangle-re ursively
6)
mak
es
its
 al ulation;
and
(triangle-re ursively
6)
m
ust
defer
un
til
(triangle-re ursively
5)
 ompletes;
and
so
on.
If
ea 
h
of
these
instan es
of
triangle-re ursively
are
though
t
of
as
dieren
t
rob
ots,
the
rst
rob
ot
m
ust
w
ait
for
the
se ond
to
 omplete
its
job,
whi 
h
m
ust
w
ait
un
til
the
third
 ompletes,
and
so
on.
There
is
a
w
a
y
around
this
kind
of
w
aiting,
whi 
h
w
e
will
dis uss
in
Se tion
11.3.7,
\Re ursion
without
Defermen
ts",
page
143.
11.3.5
Re ursion
Example
Using
 ond
The
v
ersion
of
triangle-re ursively
des rib
ed
earlier
is
written
with
the
if
sp
e ial
form.
It
 an
also
b
e
written
using
another
sp
e ial
form
 alled

140
Chapter
11:
Lo
ops
and
Re ursion
 ond.
The
name
of
the
sp
e ial
form
 ond
is
an
abbreviation
of
the
w
ord
` onditional'.
Although
the
 ond
sp
e ial
form
is
not
used
as
often
in
the
Ema s
Lisp
sour es
as
if,
it
is
used
often
enough
to
justify
explaining
it.
The
template
for
a
 ond
expression
lo
oks
lik
e
this:
( ond
b
o
dy
...
)
where
the
b
o
dy
is
a
series
of
lists.
W
ritten
out
more
fully
,
the
template
lo
oks
lik
e
this:
( ond
(rst-true-or-false-test
rst- onsequen
t
)
(se ond-true-or-false-test
se ond- onsequen
t
)
(third-true-or-false-test
third- onsequen
t
)
...
)
When
the
Lisp
in
terpreter
ev
aluates
the
 ond
expression,
it
ev
aluates
the
rst
elemen
t
(the
 ar
or
true-or-false-test)
of
the
rst
expression
in
a
series
of
expressions
within
the
b
o
dy
of
the
 ond.
If
the
true-or-false-test
returns
nil
the
rest
of
that
expression,
the
 on-
sequen
t,
is
skipp
ed
and
the
true-or-false-test
of
the
next
expression
is
ev
al-
uated.
When
an
expression
is
found
whose
true-or-false-test
returns
a
v
alue
that
is
not
nil,
the
 onsequen
t
of
that
expression
is
ev
aluated.
The
 onse-
quen
t
 an
b
e
one
or
more
expressions.
If
the
 onsequen
t
 onsists
of
more
than
one
expression,
the
expressions
are
ev
aluated
in
sequen e
and
the
v
alue
of
the
last
one
is
returned.
If
the
expression
do
es
not
ha
v
e
a
 onsequen
t,
the
v
alue
of
the
true-or-false-test
is
returned.
If
none
of
the
true-or-false-tests
test
true,
the
 ond
expression
returns
nil.
W
ritten
using
 ond,
the
triangle
fun tion
lo
oks
lik
e
this:
(defun
triangle-using- ond
(number)
( ond
((<=
number
0)
0)
((=
number
1)
1)
((>
number
1)
(+
number
(triangle-using- ond
(1-
number))))))
In
this
example,
the
 ond
returns
0
if
the
n
um
b
er
is
less
than
or
equal
to
0,
it
returns
1
if
the
n
um
b
er
is
1
and
it
ev
aluates
(+
number
(triangle-
using- ond
(1-
number)))
if
the
n
um
b
er
is
greater
than
1.
11.3.6
Re ursiv
e
P
atterns
Here
are
three
 ommon
re ursiv
e
patterns.
Ea 
h
in
v
olv
es
a
list.
Re ursion
do
es
not
need
to
in
v
olv
e
lists,
but
Lisp
is
designed
for
lists
and
this
pro
vides
a
sense
of
its
primal
 apabilities.

Re ursiv
e
P
attern:
every
141
Re ursiv
e
P
attern:
every
In
the
every
re ursiv
e
pattern,
an
a tion
is
p
erformed
on
ev
ery
elemen
t
of
a
list.
The
basi 
pattern
is:

If
a
list
b
e
empt
y
,
return
nil.

Else,
a t
on
the
b
eginning
of
the
list
(the
 ar
of
the
list)
 through
a
re ursiv
e
 all
b
y
the
fun tion
on
the
rest
(the
 dr)
of
the
list,
 and,
optionally
,
 om
bine
the
a ted-on
elemen
t,
using
 ons,
with
the
results
of
a ting
on
the
rest.
Here
is
example:
(defun
square-ea h
(numbers-list)
"Square
ea h
of
a
NUMBERS
LIST,
re ursively."
(if
(not
numbers-list)
;
do-again-test
nil
( ons
(*
( ar
numbers-list)
( ar
numbers-list))
(square-ea h
( dr
numbers-list)))))
;
next-step-expression
(square-ea h
'(1
2
3))
)
(1
4
9)
If
numbers-list
is
empt
y
,
do
nothing.
But
if
it
has
 on
ten
t,
 onstru t
a
list
 om
bining
the
square
of
the
rst
n
um
b
er
in
the
list
with
the
result
of
the
re ursiv
e
 all.
(The
example
follo
ws
the
pattern
exa tly:
nil
is
returned
if
the
n
um
b
ers'
list
is
empt
y
.
In
pra ti e,
y
ou
w
ould
write
the
 onditional
so
it
 arries
out
the
a tion
when
the
n
um
b
ers'
list
is
not
empt
y
.)
The
print-elements-re ursivel
y
fun tion
(see
Se tion
11.3.3,
\Re ur-
sion
with
a
List",
page
136)
is
another
example
of
an
every
pattern,
ex ept
in
this
 ase,
rather
than
bring
the
results
together
using
 ons,
w
e
prin
t
ea 
h
elemen
t
of
output.
The
print-elements-re ursively
fun tion
lo
oks
lik
e
this:
(setq
animals
'(gazelle
giraffe
lion
tiger))

142
Chapter
11:
Lo
ops
and
Re ursion
(defun
print-elements-re ursively
(list)
"Print
ea h
element
of
LIST
on
a
line
of
its
own.
Uses
re ursion."
(if
list
;
do-again-test
(progn
(print
( ar
list))
;
b
o
dy
(print-elements-re ursively
;
re ursiv
e
 all
( dr
list)))))
;
next-step-expression
(print-elements-re ursively
animals)
The
pattern
for
print-elements-re ursive
ly
is:

If
the
list
b
e
empt
y
,
do
nothing.

But
if
the
list
has
at
least
one
elemen
t,
 a t
on
the
b
eginning
of
the
list
(the
 ar
of
the
list),
 and
mak
e
a
re ursiv
e
 all
on
the
rest
(the
 dr)
of
the
list.
Re ursiv
e
P
attern:
a 
 umulate
Another
re ursiv
e
pattern
is
 alled
the
a  umulate
pattern.
In
the
a  umulate
re ursiv
e
pattern,
an
a tion
is
p
erformed
on
ev
ery
elemen
t
of
a
list
and
the
result
of
that
a tion
is
a  um
ulated
with
the
results
of
p
erform-
ing
the
a tion
on
the
other
elemen
ts.
This
is
v
ery
lik
e
the
`ev
ery'
pattern
using
 ons,
ex ept
that
 ons
is
not
used,
but
some
other
 om
biner.
The
pattern
is:

If
a
list
b
e
empt
y
,
return
zero
or
some
other
 onstan
t.

Else,
a t
on
the
b
eginning
of
the
list
(the
 ar
of
the
list),
 and
 om
bine
that
a ted-on
elemen
t,
using
+
or
some
other
 om
bin-
ing
fun tion,
with
 a
re ursiv
e
 all
b
y
the
fun tion
on
the
rest
(the
 dr)
of
the
list.
Here
is
an
example:
(defun
add-elements
(numbers-list)
"Add
the
elements
of
NUMBERS-LIST
together."
(if
(not
numbers-list)
0
(+
( ar
numbers-list)
(add-elements
( dr
numbers-list)))))
(add-elements
'(1
2
3
4))
)
10
See
Se tion
14.9.2,
\Making
a
List
of
Files",
page
194,
for
an
example
of
the
a  um
ulate
pattern.

Re ursion
without
Defermen
ts
143
Re ursiv
e
P
attern:
ke
ep
A
third
re ursiv
e
pattern
is
 alled
the
keep
pattern.
In
the
keep
re ursiv
e
pattern,
ea 
h
elemen
t
of
a
list
is
tested;
the
elemen
t
is
a ted
on
and
the
results
are
k
ept
only
if
the
elemen
t
meets
a
 riterion.
Again,
this
is
v
ery
lik
e
the
`ev
ery'
pattern,
ex ept
the
elemen
t
is
skipp
ed
unless
it
meets
a
 riterion.
The
pattern
has
three
parts:

If
a
list
b
e
empt
y
,
return
nil.

Else,
if
the
b
eginning
of
the
list
(the
 ar
of
the
list)
passes
a
test
 a t
on
that
elemen
t
and
 om
bine
it,
using
 ons
with
 a
re ursiv
e
 all
b
y
the
fun tion
on
the
rest
(the
 dr)
of
the
list.

Otherwise,
if
the
b
eginning
of
the
list
(the
 ar
of
the
list)
fails
the
test
 skip
on
that
elemen
t,
 and,
re ursiv
ely
 all
the
fun tion
on
the
rest
(the
 dr)
of
the
list.
Here
is
an
example
that
uses
 ond:
(defun
keep-three-letter-words
(word-list)
"Keep
three
letter
words
in
WORD-LIST."
( ond
;;
First
do-again-test:
stop- ondition
((not
word-list)
nil)
;;
Se ond
do-again-test:
when
to
a t
((eq
3
(length
(symbol-name
( ar
word-list))))
;;
 ombine
a ted-on
element
with
re ursive
 all
on
shorter
list
( ons
( ar
word-list)
(keep-three-letter-words
( dr
word-list))))
;;
Third
do-again-test:
when
to
skip
element;
;;
re ursively
 all
shorter
list
with
next-step
expression
(t
(keep-three-letter-words
( dr
word-list)))))
(keep-three-letter-words
'(one
two
three
four
five
six))
)
(one
two
six)
It
go
es
without
sa
ying
that
y
ou
need
not
use
nil
as
the
test
for
when
to
stop;
and
y
ou
 an,
of
 ourse,
 om
bine
these
patterns.
11.3.7
Re ursion
without
Defermen
ts
Let's
 onsider
again
what
happ
ens
with
the
triangle-re ursively
fun -
tion.
W
e
will
nd
that
the
in
termediate
 al ulations
are
deferred
un
til
all
 an
b
e
done.

144
Chapter
11:
Lo
ops
and
Re ursion
Here
is
the
fun tion
denition:
(defun
triangle-re ursively
(number)
"Return
the
sum
of
the
numbers
1
through
NUMBER
in lusive.
Uses
re ursion."
(if
(=
number
1)
;
do-again-test
1
;
then-part
(+
number
;
else-part
(triangle-re ursively
;
re ursiv
e
 all
(1-
number)))))
;
next-step-expression
What
happ
ens
when
w
e
 all
this
fun tion
with
a
argumen
t
of
7?
The
rst
instan e
of
the
triangle-re ursively
fun tion
adds
the
n
um-
b
er
7
to
the
v
alue
returned
b
y
a
se ond
instan e
of
triangle-re ursively,
an
instan e
that
has
b
een
passed
an
argumen
t
of
6.
That
is
to
sa
y
,
the
rst
 al ulation
is:
(+
7
(triangle-re ursively
6)
The
rst
instan e
of
triangle-re ursively|y
ou
ma
y
w
an
t
to
think
of
it
as
a
little
rob
ot| annot
 omplete
its
job.
It
m
ust
hand
o
the
 al ulation
for
(triangle-re ursively
6)
to
a
se ond
instan e
of
the
program,
to
a
se ond
rob
ot.
This
se ond
individual
is
 ompletely
dieren
t
from
the
rst
one;
it
is,
in
the
jargon,
a
`dieren
t
instan
tiation'.
Or,
put
another
w
a
y
,
it
is
a
dieren
t
rob
ot.
It
is
the
same
mo
del
as
the
rst;
it
 al ulates
triangle
n
um
b
ers
re ursiv
ely;
but
it
has
a
dieren
t
serial
n
um
b
er.
And
what
do
es
(triangle-re ursively
6)
return?
It
returns
the
n
um-
b
er
6
added
to
the
v
alue
returned
b
y
ev
aluating
triangle-re ursively
with
an
argumen
t
of
5.
Using
the
rob
ot
metaphor,
it
asks
y
et
another
rob
ot
to
help
it.
No
w
the
total
is:
(+
7
6
(triangle-re ursively
5)
And
what
happ
ens
next?
(+
7
6
5
(triangle-re ursively
4)
Ea 
h
time
triangle-re ursively
is
 alled,
ex ept
for
the
last
time,
it
 reates
another
instan e
of
the
program|another
rob
ot|and
asks
it
to
mak
e
a
 al ulation.
Ev
en
tually
,
the
full
addition
is
set
up
and
p
erformed:
(+
7
6
5
4
3
2
1)
This
design
for
the
fun tion
defers
the
 al ulation
of
the
rst
step
un
til
the
se ond
 an
b
e
done,
and
defers
that
un
til
the
third
 an
b
e
done,
and
so
on.
Ea 
h
defermen
t
means
the
 omputer
m
ust
remem
b
er
what
is
b
eing
w
aited
on.
This
is
not
a
problem
when
there
are
only
a
few
steps,
as
in
this
example.
But
it
 an
b
e
a
problem
when
there
are
more
steps.

No
Defermen
t
Solution
145
11.3.8
No
Defermen
t
Solution
The
solution
to
the
problem
of
deferred
op
erations
is
to
write
in
a
manner
that
do
es
not
defer
op
erations
2
.
This
requires
writing
to
a
dieren
t
pattern,
often
one
that
in
v
olv
es
writing
t
w
o
fun tion
denitions,
an
`initialization'
fun tion
and
a
`help
er'
fun tion.
The
`initialization'
fun tion
sets
up
the
job;
the
`help
er'
fun tion
do
es
the
w
ork.
Here
are
the
t
w
o
fun tion
denitions
for
adding
up
n
um
b
ers.
They
are
so
simple,
I
nd
them
hard
to
understand.
(defun
triangle-initialization
(number)
"Return
the
sum
of
the
numbers
1
through
NUMBER
in lusive.
This
is
the
`initialization'
 omponent
of
a
two
fun tion
duo
that
uses
re ursion."
(triangle-re ursive-helper
0
0
number))
(defun
triangle-re ursive-helper
(sum
 ounter
number)
"Return
SUM,
using
COUNTER,
through
NUMBER
in lusive.
This
is
the
`helper'
 omponent
of
a
two
fun tion
duo
that
uses
re ursion."
(if
(>
 ounter
number)
sum
(triangle-re ursive-helper
(+
sum
 ounter)
;
sum
(1+
 ounter)
;
 oun
ter
number)))
;
n
um
b
er
Install
b
oth
fun tion
denitions
b
y
ev
aluating
them,
then
 all
triangle-
initialization
with
2
ro
ws:
(triangle-initialization
2)
)
3
The
`initialization'
fun tion
 alls
the
rst
instan e
of
the
`help
er'
fun tion
with
three
argumen
ts:
zero,
zero,
and
a
n
um
b
er
whi 
h
is
the
n
um
b
er
of
ro
ws
in
the
triangle.
The
rst
t
w
o
argumen
ts
passed
to
the
`help
er'
fun tion
are
initializa-
tion
v
alues.
These
v
alues
are
 
hanged
when
triangle-re ursive-helpe
r
in
v
ok
es
new
instan es.
3
2
The
phrase
tail
re ursiv
e
is
used
to
des rib
e
su 
h
a
pro
 ess,
one
that
uses
` onstan
t
spa e'.
3
The
jargon
is
mildly
 onfusing:
triangle-re ursive-helper
uses
a
pro
 ess
that
is
iterativ
e
in
a
pro
 edure
that
is
re ursiv
e.
The
pro
 ess
is
 alled
iterativ
e
b
e ause
the
 omputer
need
only
re ord
the
three
v
alues,
sum,
 ounter,
and
number;
the
pro
 edure
is
re ursiv
e
b
e ause
the
fun tion
` alls
itself
'.
On
the
other
hand,
b
oth
the
pro
 ess
and
the
pro
 edure
used
b
y
triangle-re ursively
are
 alled
re ursiv
e.
The
w
ord
`re ursiv
e'
has
dieren
t
meanings
in
the
t
w
o
 on
texts.

146
Chapter
11:
Lo
ops
and
Re ursion
Let's
see
what
happ
ens
when
w
e
ha
v
e
a
triangle
that
has
one
ro
w.
(This
triangle
will
ha
v
e
one
p
ebble
in
it!)
triangle-initialization
will
 all
its
help
er
with
the
argumen
ts
0
0
1.
That
fun tion
will
run
the
 onditional
test
whether
(>
 ounter
number):
(>
0
1)
and
nd
that
the
result
is
false,
so
it
will
in
v
ok
e
the
then-part
of
the
if
 lause:
(triangle-re ursive-helper
(+
sum
 ounter)
;
sum
plus
 oun
ter
)
sum
(1+
 ounter)
;
in remen
t
 oun
ter
)
 oun
ter
number)
;
n
um
b
er
sta
ys
the
same
whi 
h
will
rst
 ompute:
(triangle-re ursive-helper
(+
0
0)
;
sum
(1+
0)
;
 oun
ter
1)
;
n
um
b
er
whi 
h
is:
(triangle-re ursive-helper
0
1
1)
Again,
(>
 ounter
number)
will
b
e
false,
so
again,
the
Lisp
in
terpreter
will
ev
aluate
triangle-re ursive-helper
,
 reating
a
new
instan e
with
new
argumen
ts.
This
new
instan e
will
b
e;
(triangle-re ursive-helper
(+
sum
 ounter)
;
sum
plus
 oun
ter
)
sum
(1+
 ounter)
;
in remen
t
 oun
ter
)
 oun
ter
number)
;
n
um
b
er
sta
ys
the
same
whi 
h
is:
(triangle-re ursive-helper
1
2
1)
In
this
 ase,
the
(>
 ounter
number)
test
will
b
e
true!
So
the
instan e
will
return
the
v
alue
of
the
sum,
whi 
h
will
b
e
1,
as
exp
e ted.
No
w,
let's
pass
triangle-initialization
an
argumen
t
of
2,
to
nd
out
ho
w
man
y
p
ebbles
there
are
in
a
triangle
with
t
w
o
ro
ws.
That
fun tion
 alls
(triangle-re ursive-helper
0
0
2).
In
stages,
the
instan es
 alled
will
b
e:
sum
 oun
ter
n
um
b
er
(triangle-re ursive-helper
0
1
2)
(triangle-re ursive-helper
1
2
2)
(triangle-re ursive-helper
3
3
2)

Lo
oping
Exer ise
147
When
the
last
instan e
is
 alled,
the
(>
 ounter
number)
test
will
b
e
true,
so
the
instan e
will
return
the
v
alue
of
sum,
whi 
h
will
b
e
3.
This
kind
of
pattern
helps
when
y
ou
are
writing
fun tions
that
 an
use
man
y
resour es
in
a
 omputer.
11.4
Lo
oping
Exer ise

W
rite
a
fun tion
similar
to
triangle
in
whi 
h
ea 
h
ro
w
has
a
v
alue
whi 
h
is
the
square
of
the
ro
w
n
um
b
er.
Use
a
while
lo
op.

W
rite
a
fun tion
similar
to
triangle
that
m
ultiplies
instead
of
adds
the
v
alues.

Rewrite
these
t
w
o
fun tions
re ursiv
ely
.
Rewrite
these
fun tions
using
 ond.

W
rite
a
fun tion
for
T
exinfo
mo
de
that
 reates
an
index
en
try
at
the
b
eginning
of
a
paragraph
for
ev
ery
` dfn'
within
the
paragraph.
(In
a
T
exinfo
le,
` dfn'
marks
a
denition.
F
or
more
information,
see
\Indi ating
Denitions,
Commands,
et ."
in
T
exinfo,
The
GNU
Do
 u-
men
tation
F
ormat.)

148
Chapter
11:
Lo
ops
and
Re ursion

The
Regular
Expression
for
senten e-end
149
12
Regular
Expression
Sear 
hes
Regular
expression
sear 
hes
are
used
extensiv
ely
in
GNU
Ema s.
The
t
w
o
fun tions,
forward-senten e
and
forward-paragraph,
illustrate
these
sear 
hes
w
ell.
They
use
regular
expressions
to
nd
where
to
mo
v
e
p
oin
t.
The
phrase
`regular
expression'
is
often
written
as
`regexp'.
Regular
expression
sear 
hes
are
des rib
ed
in
se tion
\Regular
Expression
Sear 
h"
in
The
GNU
Ema s
Man
ual
,
as
w
ell
as
in
se tion
\Regular
Expres-
sions"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
In
writing
this
 
hapter,
I
am
presuming
that
y
ou
ha
v
e
at
least
a
mild
a quain
tan e
with
them.
The
ma
jor
p
oin
t
to
remem
b
er
is
that
regular
expressions
p
ermit
y
ou
to
sear 
h
for
patterns
as
w
ell
as
for
literal
strings
of
 
hara ters.
F
or
example,
the
 o
de
in
forward-senten e
sear 
hes
for
the
pattern
of
p
ossible
 
hara ters
that
 ould
mark
the
end
of
a
sen
ten e,
and
mo
v
es
p
oin
t
to
that
sp
ot.
Before
lo
oking
at
the
 o
de
for
the
forward-senten e
fun tion,
it
is
w
orth
 onsidering
what
the
pattern
that
marks
the
end
of
a
sen
ten e
m
ust
b
e.
The
pattern
is
dis ussed
in
the
next
se tion;
follo
wing
that
is
a
des rip-
tion
of
the
regular
expression
sear 
h
fun tion,
re-sear h-forward.
The
forward-senten e
fun tion
is
des rib
ed
in
the
se tion
follo
wing.
Finally
,
the
forward-paragraph
fun tion
is
des rib
ed
in
the
last
se tion
of
this
 
hap-
ter.
forward-paragraph
is
a
 omplex
fun tion
that
in
tro
du es
sev
eral
new
features.
12.1
The
Regular
Expression
for
senten e-end
The
sym
b
ol
senten e-end
is
b
ound
to
the
pattern
that
marks
the
end
of
a
sen
ten e.
What
should
this
regular
expression
b
e?
Clearly
,
a
sen
ten e
ma
y
b
e
ended
b
y
a
p
erio
d,
a
question
mark,
or
an
ex lamation
mark.
Indeed,
only
 lauses
that
end
with
one
of
those
three
 
hara ters
should
b
e
 onsidered
the
end
of
a
sen
ten e.
This
means
that
the
pattern
should
in lude
the
 
hara ter
set:
[.?!℄
Ho
w
ev
er,
w
e
do
not
w
an
t
forward-senten e
merely
to
jump
to
a
p
erio
d,
a
question
mark,
or
an
ex lamation
mark,
b
e ause
su 
h
a
 
hara ter
migh
t
b
e
used
in
the
middle
of
a
sen
ten e.
A
p
erio
d,
for
example,
is
used
after
abbreviations.
So
other
information
is
needed.
A  ording
to
 on
v
en
tion,
y
ou
t
yp
e
t
w
o
spa es
after
ev
ery
sen
ten e,
but
only
one
spa e
after
a
p
erio
d,
a
question
mark,
or
an
ex lamation
mark
in
the
b
o
dy
of
a
sen
ten e.
So
a
p
erio
d,
a
question
mark,
or
an
ex lamation
mark
follo
w
ed
b
y
t
w
o
spa es
is
a
go
o
d
indi ator
of
an
end
of
sen
ten e.
Ho
w
ev
er,
in
a
le,
the
t
w
o
spa es
ma
y
instead
b
e
a
tab
or
the
end
of
a
line.
This
means
that
the
regular
expression
should
in lude
these
three
items
as
alternativ
es.

150
Chapter
12:
Regular
Expression
Sear 
hes
This
group
of
alternativ
es
will
lo
ok
lik
e
this:
\\($\\|
\\|
\\)
^
^^
TAB
SPC
Here,
`$'
indi ates
the
end
of
the
line,
and
I
ha
v
e
p
oin
ted
out
where
the
tab
and
t
w
o
spa es
are
inserted
in
the
expression.
Both
are
inserted
b
y
putting
the
a tual
 
hara ters
in
to
the
expression.
Tw
o
ba 
kslashes,
`\\',
are
required
b
efore
the
paren
theses
and
v
erti al
bars:
the
rst
ba 
kslash
quotes
the
follo
wing
ba 
kslash
in
Ema s;
and
the
se ond
indi ates
that
the
follo
wing
 
hara ter,
the
paren
thesis
or
the
v
erti al
bar,
is
sp
e ial.
Also,
a
sen
ten e
ma
y
b
e
follo
w
ed
b
y
one
or
more
 arriage
returns,
lik
e
this:
[
℄*
Lik
e
tabs
and
spa es,
a
 arriage
return
is
inserted
in
to
a
regular
expression
b
y
inserting
it
literally
.
The
asterisk
indi ates
that
the
h
RET
i
is
rep
eated
zero
or
more
times.
But
a
sen
ten e
end
do
es
not
 onsist
only
of
a
p
erio
d,
a
question
mark
or
an
ex lamation
mark
follo
w
ed
b
y
appropriate
spa e:
a
 losing
quotation
mark
or
a
 losing
bra e
of
some
kind
ma
y
pre ede
the
spa e.
Indeed
more
than
one
su 
h
mark
or
bra e
ma
y
pre ede
the
spa e.
These
require
a
expression
that
lo
oks
lik
e
this:
[℄\"')}℄*
In
this
expression,
the
rst
`℄'
is
the
rst
 
hara ter
in
the
expression;
the
se ond
 
hara ter
is
`"',
whi 
h
is
pre eded
b
y
a
`\'
to
tell
Ema s
the
`"'
is
not
sp
e ial.
The
last
three
 
hara ters
are
`'',
`)',
and
`}'.
All
this
suggests
what
the
regular
expression
pattern
for
mat 
hing
the
end
of
a
sen
ten e
should
b
e;
and,
indeed,
if
w
e
ev
aluate
senten e-end
w
e
nd
that
it
returns
the
follo
wing
v
alue:
senten e-end
)
"[.?!℄[℄\"')}℄*\\($\\|
\\|
\\)[
℄*"
12.2
The
re-sear h-forw
ar
d
F
un tion
The
re-sear h-forward
fun tion
is
v
ery
lik
e
the
sear h-forward
fun -
tion.
(See
Se tion
8.1.3,
\The
sear h-forward
F
un tion",
page
92.)
re-sear h-forward
sear 
hes
for
a
regular
expression.
If
the
sear 
h
is
su  essful,
it
lea
v
es
p
oin
t
immediately
after
the
last
 
hara ter
in
the
target.
If
the
sear 
h
is
ba 
kw
ards,
it
lea
v
es
p
oin
t
just
b
efore
the
rst
 
hara ter
in
the
target.
Y
ou
ma
y
tell
re-sear h-forward
to
return
t
for
true.
(Mo
ving
p
oin
t
is
therefore
a
`side
ee t'.)

forward-senten e
151
Lik
e
sear h-forward,
the
re-sear h-forward
fun tion
tak
es
four
argu-
men
ts:
1.
The
rst
argumen
t
is
the
regular
expression
that
the
fun tion
sear 
hes
for.
The
regular
expression
will
b
e
a
string
b
et
w
een
quotations
marks.
2.
The
optional
se ond
argumen
t
limits
ho
w
far
the
fun tion
will
sear 
h;
it
is
a
b
ound,
whi 
h
is
sp
e ied
as
a
p
osition
in
the
buer.
3.
The
optional
third
argumen
t
sp
e ies
ho
w
the
fun tion
resp
onds
to
failure:
nil
as
the
third
argumen
t
 auses
the
fun tion
to
signal
an
error
(and
prin
t
a
message)
when
the
sear 
h
fails;
an
y
other
v
alue
 auses
it
to
return
nil
if
the
sear 
h
fails
and
t
if
the
sear 
h
su  eeds.
4.
The
optional
fourth
argumen
t
is
the
rep
eat
 oun
t.
A
negativ
e
rep
eat
 oun
t
 auses
re-sear h-forward
to
sear 
h
ba 
kw
ards.
The
template
for
re-sear h-forward
lo
oks
lik
e
this:
(re-sear h-forward
"regular-expression"
limit-of-sear 
h
what-to-do-if-sear 
h-fails
rep
eat- oun
t
)
The
se ond,
third,
and
fourth
argumen
ts
are
optional.
Ho
w
ev
er,
if
y
ou
w
an
t
to
pass
a
v
alue
to
either
or
b
oth
of
the
last
t
w
o
argumen
ts,
y
ou
m
ust
also
pass
a
v
alue
to
all
the
pre eding
argumen
ts.
Otherwise,
the
Lisp
in
terpreter
will
mistak
e
whi 
h
argumen
t
y
ou
are
passing
the
v
alue
to.
In
the
forward-senten e
fun tion,
the
regular
expression
will
b
e
the
v
alue
of
the
v
ariable
senten e-end,
namely:
"[.?!℄[℄\"')}℄*\\($\\|
\\|
\\)[
℄*"
The
limit
of
the
sear 
h
will
b
e
the
end
of
the
paragraph
(sin e
a
sen
ten e
 annot
go
b
ey
ond
a
paragraph).
If
the
sear 
h
fails,
the
fun tion
will
return
nil;
and
the
rep
eat
 oun
t
will
b
e
pro
vided
b
y
the
argumen
t
to
the
forward-
senten e
fun tion.
12.3
forward-senten 
e
The
 ommand
to
mo
v
e
the
 ursor
forw
ard
a
sen
ten e
is
a
straigh
tforw
ard
illustration
of
ho
w
to
use
regular
expression
sear 
hes
in
Ema s
Lisp.
Indeed,
the
fun tion
lo
oks
longer
and
more
 ompli ated
than
it
is;
this
is
b
e ause
the
fun tion
is
designed
to
go
ba 
kw
ards
as
w
ell
as
forw
ards;
and,
optionally
,
o
v
er
more
than
one
sen
ten e.
The
fun tion
is
usually
b
ound
to
the
k
ey
 ommand
M-e.

152
Chapter
12:
Regular
Expression
Sear 
hes
Here
is
the
 o
de
for
forward-senten e:
(defun
forward-senten e
(&optional
arg)
"Move
forward
to
next
senten e-end.
With
argument,
repeat.
With
negative
argument,
move
ba kward
repeatedly
to
senten e-beginning.
Senten e
ends
are
identified
by
the
value
of
senten e-end
treated
as
a
regular
expression.
Also,
every
paragraph
boundary
terminates
senten es
as
well."
(intera tive
"p")
(or
arg
(setq
arg
1))
(while
(<
arg
0)
(let
((par-beg
(save-ex ursion
(start-of-paragraph-text)
(point))))
(if
(re-sear h-ba kward
( on at
senten e-end
"[^
\t\n℄")
par-beg
t)
(goto- har
(1-
(mat h-end
0)))
(goto- har
par-beg)))
(setq
arg
(1+
arg)))
(while
(>
arg
0)
(let
((par-end
(save-ex ursion
(end-of-paragraph-text)
(point))))
(if
(re-sear h-forward
senten e-end
par-end
t)
(skip- hars-ba kward
"
\t\n")
(goto- har
par-end)))
(setq
arg
(1-
arg))))
The
fun tion
lo
oks
long
at
rst
sigh
t
and
it
is
b
est
to
lo
ok
at
its
sk
eleton
rst,
and
then
its
m
us le.
The
w
a
y
to
see
the
sk
eleton
is
to
lo
ok
at
the
expressions
that
start
in
the
left-most
 olumns:
(defun
forward-senten e
(&optional
arg)
"do
 umen
tation...
"
(intera tive
"p")
(or
arg
(setq
arg
1))
(while
(<
arg
0)
b
o
dy-of-while-lo
op
(while
(>
arg
0)
b
o
dy-of-while-lo
op
This
lo
oks
m
u 
h
simpler!
The
fun tion
denition
 onsists
of
do
 umen
ta-
tion,
an
intera tive
expression,
an
or
expression,
and
while
lo
ops.
Let's
lo
ok
at
ea 
h
of
these
parts
in
turn.
W
e
note
that
the
do
 umen
tation
is
thorough
and
understandable.
The
fun tion
has
an
intera tive
"p"
de laration.
This
means
that
the
pro
 essed
prex
argumen
t,
if
an
y
,
is
passed
to
the
fun tion
as
its
argumen
t.
(This
will
b
e
a
n
um
b
er.)
If
the
fun tion
is
not
passed
an
argumen
t
(it
is
optional)
then
the
argumen
t
arg
will
b
e
b
ound
to
1.
When
forward-

The
while
lo
ops
153
senten e
is
 alled
non-in
tera tiv
ely
without
an
argumen
t,
arg
is
b
ound
to
nil.
The
or
expression
handles
the
prex
argumen
t.
What
it
do
es
is
either
lea
v
e
the
v
alue
of
arg
as
it
is,
but
only
if
arg
is
b
ound
to
a
v
alue;
or
it
sets
the
v
alue
of
arg
to
1,
in
the
 ase
when
arg
is
b
ound
to
nil.
The
while
lo
ops
Tw
o
while
lo
ops
follo
w
the
or
expression.
The
rst
while
has
a
true-
or-false-test
that
tests
true
if
the
prex
argumen
t
for
forward-senten e
is
a
negativ
e
n
um
b
er.
This
is
for
going
ba 
kw
ards.
The
b
o
dy
of
this
lo
op
is
similar
to
the
b
o
dy
of
the
se ond
while
 lause,
but
it
is
not
exa tly
the
same.
W
e
will
skip
this
while
lo
op
and
 on en
trate
on
the
se ond
while
lo
op.
The
se ond
while
lo
op
is
for
mo
ving
p
oin
t
forw
ard.
Its
sk
eleton
lo
oks
lik
e
this:
(while
(>
arg
0)
;
true-or-false-test
(let
v
arlist
(if
(true-or-false-test
)
then-part
else-part
(setq
arg
(1-
arg))))
;
while
lo
op
de remen
ter
The
while
lo
op
is
of
the
de remen
ting
kind.
(See
Se tion
11.1.4,
\A
Lo
op
with
a
De remen
ting
Coun
ter",
page
129.)
It
has
a
true-or-false-test
that
tests
true
so
long
as
the
 oun
ter
(in
this
 ase,
the
v
ariable
arg)
is
greater
than
zero;
and
it
has
a
de remen
ter
that
subtra ts
1
from
the
v
alue
of
the
 oun
ter
ev
ery
time
the
lo
op
rep
eats.
If
no
prex
argumen
t
is
giv
en
to
forward-senten e,
whi 
h
is
the
most
 ommon
w
a
y
the
 ommand
is
used,
this
while
lo
op
will
run
on e,
sin e
the
v
alue
of
arg
will
b
e
1.
The
b
o
dy
of
the
while
lo
op
 onsists
of
a
let
expression,
whi 
h
 reates
and
binds
a
lo
 al
v
ariable,
and
has,
as
its
b
o
dy
,
an
if
expression.
The
b
o
dy
of
the
while
lo
op
lo
oks
lik
e
this:
(let
((par-end
(save-ex ursion
(end-of-paragraph-text)
(point))))
(if
(re-sear h-forward
senten e-end
par-end
t)
(skip- hars-ba kward
"
\t\n")
(goto- har
par-end)))
The
let
expression
 reates
and
binds
the
lo
 al
v
ariable
par-end.
As
w
e
shall
see,
this
lo
 al
v
ariable
is
designed
to
pro
vide
a
b
ound
or
limit
to
the
regular
expression
sear 
h.
If
the
sear 
h
fails
to
nd
a
prop
er
sen
ten e
ending
in
the
paragraph,
it
will
stop
on
rea 
hing
the
end
of
the
paragraph.

154
Chapter
12:
Regular
Expression
Sear 
hes
But
rst,
let
us
examine
ho
w
par-end
is
b
ound
to
the
v
alue
of
the
end
of
the
paragraph.
What
happ
ens
is
that
the
let
sets
the
v
alue
of
par-end
to
the
v
alue
returned
when
the
Lisp
in
terpreter
ev
aluates
the
expression
(save-ex ursion
(end-of-paragraph-text)
(point))
In
this
expression,
(end-of-paragraph-text)
mo
v
es
p
oin
t
to
the
end
of
the
paragraph,
(point)
returns
the
v
alue
of
p
oin
t,
and
then
save-ex ursion
restores
p
oin
t
to
its
original
p
osition.
Th
us,
the
let
binds
par-end
to
the
v
alue
returned
b
y
the
save-ex ursion
expression,
whi 
h
is
the
p
osition
of
the
end
of
the
paragraph.
(The
(end-of-paragraph-text)
fun tion
uses
forward-paragraph,
whi 
h
w
e
will
dis uss
shortly
.)
Ema s
next
ev
aluates
the
b
o
dy
of
the
let,
whi 
h
is
an
if
expression
that
lo
oks
lik
e
this:
(if
(re-sear h-forward
senten e-end
par-end
t)
;
if-part
(skip- hars-ba kward
"
\t\n")
;
then-part
(goto- har
par-end)))
;
else-part
The
if
tests
whether
its
rst
argumen
t
is
true
and
if
so,
ev
aluates
its
then-part;
otherwise,
the
Ema s
Lisp
in
terpreter
ev
aluates
the
else-part.
The
true-or-false-test
of
the
if
expression
is
the
regular
expression
sear 
h.
It
ma
y
seem
o
dd
to
ha
v
e
what
lo
oks
lik
e
the
`real
w
ork'
of
the
forward-
senten e
fun tion
buried
here,
but
this
is
a
 ommon
w
a
y
this
kind
of
op
er-
ation
is
 arried
out
in
Lisp.
The
regular
expression
sear 
h
The
re-sear h-forward
fun tion
sear 
hes
for
the
end
of
the
sen
ten e,
that
is,
for
the
pattern
dened
b
y
the
senten e-end
regular
expression.
If
the
pattern
is
found|if
the
end
of
the
sen
ten e
is
found|then
the
re-
sear h-forward
fun tion
do
es
t
w
o
things:
1.
The
re-sear h-forward
fun tion
 arries
out
a
side
ee t,
whi 
h
is
to
mo
v
e
p
oin
t
to
the
end
of
the
o
  urren e
found.
2.
The
re-sear h-forward
fun tion
returns
a
v
alue
of
true.
This
is
the
v
alue
re eiv
ed
b
y
the
if,
and
means
that
the
sear 
h
w
as
su  essful.
The
side
ee t,
the
mo
v
emen
t
of
p
oin
t,
is
 ompleted
b
efore
the
if
fun tion
is
handed
the
v
alue
returned
b
y
the
su  essful
 on lusion
of
the
sear 
h.
When
the
if
fun tion
re eiv
es
the
v
alue
of
true
from
a
su  essful
 all
to
re-sear h-forward,
the
if
ev
aluates
the
then-part,
whi 
h
is
the
expression
(skip- hars-ba kward
"
\t\n").
This
expression
mo
v
es
ba 
kw
ards
o
v
er
an
y
blank
spa es,
tabs
or
 arriage
returns
un
til
a
prin
ted
 
hara ter
is
found
and
then
lea
v
es
p
oin
t
after
the
 
hara ter.
Sin e
p
oin
t
has
already
b
een
mo
v
ed
to
the
end
of
the
pattern
that
marks
the
end
of
the
sen
ten e,
this
a tion
lea
v
es
p
oin
t
righ
t
after
the
 losing
prin
ted
 
hara ter
of
the
sen
ten e,
whi 
h
is
usually
a
p
erio
d.
On
the
other
hand,
if
the
re-sear h-forward
fun tion
fails
to
nd
a
pattern
marking
the
end
of
the
sen
ten e,
the
fun tion
returns
false.
The

forward-paragraph:
a
Goldmine
of
F
un tions
155
false
then
 auses
the
if
to
ev
aluate
its
third
argumen
t,
whi 
h
is
(goto- har
par-end):
it
mo
v
es
p
oin
t
to
the
end
of
the
paragraph.
Regular
expression
sear 
hes
are
ex eptionally
useful
and
the
pattern
il-
lustrated
b
y
re-sear h-forward,
in
whi 
h
the
sear 
h
is
the
test
of
an
if
expression,
is
handy
.
Y
ou
will
see
or
write
 o
de
in orp
orating
this
pattern
often.
12.4
forward-paragra
ph
:
a
Goldmine
of
F
un tions
The
forward-paragraph
fun tion
mo
v
es
p
oin
t
forw
ard
to
the
end
of
the
paragraph.
It
is
usually
b
ound
to
M-}
and
mak
es
use
of
a
n
um
b
er
of
fun tions
that
are
imp
ortan
t
in
themselv
es,
in luding
let*,
mat h-beginning,
and
looking-at.
The
fun tion
denition
for
forward-paragraph
is
 onsiderably
longer
than
the
fun tion
denition
for
forward-senten e
b
e ause
it
w
orks
with
a
paragraph,
ea 
h
line
of
whi 
h
ma
y
b
egin
with
a
ll
prex.
A
ll
prex
 onsists
of
a
string
of
 
hara ters
that
are
rep
eated
at
the
b
eginning
of
ea 
h
line.
F
or
example,
in
Lisp
 o
de,
it
is
a
 on
v
en
tion
to
start
ea 
h
line
of
a
paragraph-long
 ommen
t
with
`;;;
'.
In
T
ext
mo
de,
four
blank
spa es
mak
e
up
another
 ommon
ll
prex,
 reating
an
inden
ted
paragraph.
(See
se tion
\Fill
Prex"
in
The
GNU
Ema s
Man
ual
,
for
more
information
ab
out
ll
prexes.)
The
existen e
of
a
ll
prex
means
that
in
addition
to
b
eing
able
to
nd
the
end
of
a
paragraph
whose
lines
b
egin
on
the
left-most
 olumn,
the
forward-paragraph
fun tion
m
ust
b
e
able
to
nd
the
end
of
a
paragraph
when
all
or
man
y
of
the
lines
in
the
buer
b
egin
with
the
ll
prex.
Moreo
v
er,
it
is
sometimes
pra ti al
to
ignore
a
ll
prex
that
exists,
esp
e-
 ially
when
blank
lines
separate
paragraphs.
This
is
an
added
 ompli ation.
Rather
than
prin
t
all
of
the
forward-paragraph
fun tion,
w
e
will
only
prin
t
parts
of
it.
Read
without
preparation,
the
fun tion
 an
b
e
daun
ting!
In
outline,
the
fun tion
lo
oks
lik
e
this:
(defun
forward-paragraph
(&optional
arg)
"do
 umen
tation...
"
(intera tive
"p")
(or
arg
(setq
arg
1))
(let*
v
arlist
(while
(<
arg
0)
;
ba 
kw
ard-mo
ving- o
de
...
(setq
arg
(1+
arg)))
(while
(>
arg
0)
;
forw
ard-mo
ving- o
de
...
(setq
arg
(1-
arg)))))

156
Chapter
12:
Regular
Expression
Sear 
hes
The
rst
parts
of
the
fun tion
are
routine:
the
fun tion's
argumen
t
list
 onsists
of
one
optional
argumen
t.
Do
 umen
tation
follo
ws.
The
lo
w
er
 ase
`p'
in
the
intera tive
de laration
means
that
the
pro-
 essed
prex
argumen
t,
if
an
y
,
is
passed
to
the
fun tion.
This
will
b
e
a
n
um
b
er,
and
is
the
rep
eat
 oun
t
of
ho
w
man
y
paragraphs
p
oin
t
will
mo
v
e.
The
or
expression
in
the
next
line
handles
the
 ommon
 ase
when
no
argu-
men
t
is
passed
to
the
fun tion,
whi 
h
o
  urs
if
the
fun tion
is
 alled
from
other
 o
de
rather
than
in
tera tiv
ely
.
This
 ase
w
as
des rib
ed
earlier.
(See
Se tion
12.3,
\forw
ard-sen
ten e",
page
151.)
No
w
w
e
rea 
h
the
end
of
the
familiar
part
of
this
fun tion.
The
let*
expression
The
next
line
of
the
forward-paragraph
fun tion
b
egins
a
let*
expres-
sion.
This
is
a
dieren
t
kind
of
expression
than
w
e
ha
v
e
seen
so
far.
The
sym
b
ol
is
let*
not
let.
The
let*
sp
e ial
form
is
lik
e
let
ex ept
that
Ema s
sets
ea 
h
v
ariable
in
sequen e,
one
after
another,
and
v
ariables
in
the
latter
part
of
the
v
arlist
 an
mak
e
use
of
the
v
alues
to
whi 
h
Ema s
set
v
ariables
in
the
earlier
part
of
the
v
arlist.
In
the
let*
expression
in
this
fun tion,
Ema s
binds
t
w
o
v
ariables:
fill-
prefix-regexp
and
paragraph-separate.
The
v
alue
to
whi 
h
paragraph-
separate
is
b
ound
dep
ends
on
the
v
alue
of
fill-prefix-regexp.
Let's
lo
ok
at
ea 
h
in
turn.
The
sym
b
ol
fill-prefix-regexp
is
set
to
the
v
alue
returned
b
y
ev
aluating
the
follo
wing
list:
(and
fill-prefix
(not
(equal
fill-prefix
""))
(not
paragraph-ignore-fill-prefix
)
(regexp-quote
fill-prefix))
This
is
an
expression
whose
rst
elemen
t
is
the
and
sp
e ial
form.
As
w
e
learned
earlier
(see
\The
kill-new
fun tion",
page
105),
the
and
sp
e ial
form
ev
aluates
ea 
h
of
its
argumen
ts
un
til
one
of
the
argumen
ts
returns
a
v
alue
of
nil,
in
whi 
h
 ase
the
and
expression
returns
nil;
ho
w
ev
er,
if
none
of
the
argumen
ts
returns
a
v
alue
of
nil,
the
v
alue
resulting
from
ev
aluating
the
last
argumen
t
is
returned.
(Sin e
su 
h
a
v
alue
is
not
nil,
it
is
 onsidered
true
in
Lisp.)
In
other
w
ords,
an
and
expression
returns
a
true
v
alue
only
if
all
its
argumen
ts
are
true.
In
this
 ase,
the
v
ariable
fill-prefix-regexp
is
b
ound
to
a
non-nil
v
alue
only
if
the
follo
wing
four
expressions
pro
du e
a
true
(i.e.,
a
non-nil)
v
alue
when
they
are
ev
aluated;
otherwise,
fill-prefix-regexp
is
b
ound
to
nil.

The
let*
expression
157
fill-prefix
When
this
v
ariable
is
ev
aluated,
the
v
alue
of
the
ll
prex,
if
an
y
,
is
returned.
If
there
is
no
ll
prex,
this
v
ariable
returns
nil.
(not
(equal
fill-prefix
"")
This
expression
 
he 
ks
whether
an
existing
ll
prex
is
an
empt
y
string,
that
is,
a
string
with
no
 
hara ters
in
it.
An
empt
y
string
is
not
a
useful
ll
prex.
(not
paragraph-ignore-fill-pre
fix)
This
expression
returns
nil
if
the
v
ariable
paragraph-ignore-
fill-prefix
has
b
een
turned
on
b
y
b
eing
set
to
a
true
v
alue
su 
h
as
t.
(regexp-quote
fill-prefix)
This
is
the
last
argumen
t
to
the
and
sp
e ial
form.
If
all
the
argumen
ts
to
the
and
are
true,
the
v
alue
resulting
from
ev
aluat-
ing
this
expression
will
b
e
returned
b
y
the
and
expression
and
b
ound
to
the
v
ariable
fill-prefix-regexp,
The
result
of
ev
aluating
this
and
expression
su  essfully
is
that
fill-
prefix-regexp
will
b
e
b
ound
to
the
v
alue
of
fill-prefix
as
mo
died
b
y
the
regexp-quote
fun tion.
What
regexp-quote
do
es
is
read
a
string
and
return
a
regular
expression
that
will
exa tly
mat 
h
the
string
and
mat 
h
nothing
else.
This
means
that
fill-prefix-regexp
will
b
e
set
to
a
v
alue
that
will
exa tly
mat 
h
the
ll
prex
if
the
ll
prex
exists.
Otherwise,
the
v
ariable
will
b
e
set
to
nil.
The
se ond
lo
 al
v
ariable
in
the
let*
expression
is
paragraph-separate.
It
is
b
ound
to
the
v
alue
returned
b
y
ev
aluating
the
expression:
(if
fill-prefix-regexp
( on at
paragraph-separate
"\\|^"
fill-prefix-regexp
"[
\t℄*$")
paragraph-separate)))
This
expression
sho
ws
wh
y
let*
rather
than
let
w
as
used.
The
true-or-
false-test
for
the
if
dep
ends
on
whether
the
v
ariable
fill-prefix-regexp
ev
aluates
to
nil
or
some
other
v
alue.
If
fill-prefix-regexp
do
es
not
ha
v
e
a
v
alue,
Ema s
ev
aluates
the
else-
part
of
the
if
expression
and
binds
paragraph-separate
to
its
lo
 al
v
alue.
(paragraph-separate
is
a
regular
expression
that
mat 
hes
what
separates
paragraphs.)
But
if
fill-prefix-regexp
do
es
ha
v
e
a
v
alue,
Ema s
ev
aluates
the
then-
part
of
the
if
expression
and
binds
paragraph-separate
to
a
regular
ex-
pression
that
in ludes
the
fill-prefix-regexp
as
part
of
the
pattern.
Sp
e i ally
,
paragraph-separate
is
set
to
the
original
v
alue
of
the
para-
graph
separate
regular
expression
 on atenated
with
an
alternativ
e
expres-
sion
that
 onsists
of
the
fill-prefix-regexp
follo
w
ed
b
y
a
blank
line.
The

158
Chapter
12:
Regular
Expression
Sear 
hes
`^'
indi ates
that
the
fill-prefix-regexp
m
ust
b
egin
a
line,
and
the
op-
tional
whitespa e
to
the
end
of
the
line
is
dened
b
y
"[
\t℄*$"
.)
The
`\\|'
denes
this
p
ortion
of
the
regexp
as
an
alternativ
e
to
paragraph-separate.
No
w
w
e
get
in
to
the
b
o
dy
of
the
let*.
The
rst
part
of
the
b
o
dy
of
the
let*
deals
with
the
 ase
when
the
fun tion
is
giv
en
a
negativ
e
argumen
t
and
is
therefore
mo
ving
ba 
kw
ards.
W
e
will
skip
this
se tion.
The
forw
ard
motion
while
lo
op
The
se ond
part
of
the
b
o
dy
of
the
let*
deals
with
forw
ard
motion.
It
is
a
while
lo
op
that
rep
eats
itself
so
long
as
the
v
alue
of
arg
is
greater
than
zero.
In
the
most
 ommon
use
of
the
fun tion,
the
v
alue
of
the
argumen
t
is
1,
so
the
b
o
dy
of
the
while
lo
op
is
ev
aluated
exa tly
on e,
and
the
 ursor
mo
v
es
forw
ard
one
paragraph.
This
part
handles
three
situations:
when
p
oin
t
is
b
et
w
een
paragraphs,
when
p
oin
t
is
within
a
paragraph
and
there
is
a
ll
prex,
and
when
p
oin
t
is
within
a
paragraph
and
there
is
no
ll
prex.
The
while
lo
op
lo
oks
lik
e
this:
(while
(>
arg
0)
(beginning-of-line)
;;
b
et
w
een
paragraphs
(while
(prog1
(and
(not
(eobp))
(looking-at
paragraph-separate))
(forward-line
1)))
;;
within
paragraphs,
with
a
ll
prex
(if
fill-prefix-regexp
;;
There
is
a
ll
prex;
it
o
v
errides
paragraph-start.
(while
(and
(not
(eobp))
(not
(looking-at
paragraph-separate))
(looking-at
fill-prefix-regexp))
(forward-line
1))
;;
within
paragraphs,
no
ll
prex
(if
(re-sear h-forward
paragraph-start
nil
t)
(goto- har
(mat h-beginning
0))
(goto- har
(point-max))))
(setq
arg
(1-
arg)))
W
e
 an
see
immediately
that
this
is
a
de remen
ting
 oun
ter
while
lo
op,
using
the
expression
(setq
arg
(1-
arg))
as
the
de remen
ter.

Bet
w
een
paragraphs
159
The
b
o
dy
of
the
lo
op
 onsists
of
three
expressions:
;;
b
et
w
een
paragraphs
(beginning-of-line)
(while
b
o
dy-of-while
)
;;
within
paragraphs,
with
ll
prex
(if
true-or-false-test
then-part
;;
within
paragraphs,
no
ll
prex
else-part
When
the
Ema s
Lisp
in
terpreter
ev
aluates
the
b
o
dy
of
the
while
lo
op,
the
rst
thing
it
do
es
is
ev
aluate
the
(beginning-of-line)
expression
and
mo
v
e
p
oin
t
to
the
b
eginning
of
the
line.
Then
there
is
an
inner
while
lo
op.
This
while
lo
op
is
designed
to
mo
v
e
the
 ursor
out
of
the
blank
spa e
b
et
w
een
paragraphs,
if
it
should
happ
en
to
b
e
there.
Finally
,
there
is
an
if
expression
that
a tually
mo
v
es
p
oin
t
to
the
end
of
the
paragraph.
Bet
w
een
paragraphs
First,
let
us
lo
ok
at
the
inner
while
lo
op.
This
lo
op
handles
the
 ase
when
p
oin
t
is
b
et
w
een
paragraphs;
it
uses
three
fun tions
that
are
new
to
us:
prog1,
eobp
and
looking-at.

prog1
is
similar
to
the
progn
sp
e ial
form,
ex ept
that
prog1
ev
aluates
its
argumen
ts
in
sequen e
and
then
returns
the
v
alue
of
its
rst
argumen
t
as
the
v
alue
of
the
whole
expression.
(progn
returns
the
v
alue
of
its
last
argumen
t
as
the
v
alue
of
the
expression.)
The
se ond
and
subsequen
t
argumen
ts
to
prog1
are
ev
aluated
only
for
their
side
ee ts.

eobp
is
an
abbreviation
of
`End
Of
Buffer
P'
and
is
a
fun tion
that
returns
true
if
p
oin
t
is
at
the
end
of
the
buer.

looking-at
is
a
fun tion
that
returns
true
if
the
text
follo
wing
p
oin
t
mat 
hes
the
regular
expression
passed
looking-at
as
its
argumen
t.
The
while
lo
op
w
e
are
studying
lo
oks
lik
e
this:
(while
(prog1
(and
(not
(eobp))
(looking-at
paragraph-separate))
(forward-line
1)))
This
is
a
while
lo
op
with
no
b
o
dy!
The
true-or-false-test
of
the
lo
op
is
the
expression:
(prog1
(and
(not
(eobp))
(looking-at
paragraph-separate))
(forward-line
1))
The
rst
argumen
t
to
the
prog1
is
the
and
expression.
It
has
within
in
it
a
test
of
whether
p
oin
t
is
at
the
end
of
the
buer
and
also
a
test
of
whether

160
Chapter
12:
Regular
Expression
Sear 
hes
the
pattern
follo
wing
p
oin
t
mat 
hes
the
regular
expression
for
separating
paragraphs.
If
the
 ursor
is
not
at
the
end
of
the
buer
and
if
the
 
hara ters
fol-
lo
wing
the
 ursor
mark
the
separation
b
et
w
een
t
w
o
paragraphs,
then
the
and
expression
is
true.
After
ev
aluating
the
and
expression,
the
Lisp
in
ter-
preter
ev
aluates
the
se ond
argumen
t
to
prog1,
whi 
h
is
forward-line.
This
mo
v
es
p
oin
t
forw
ard
one
line.
The
v
alue
returned
b
y
the
prog1
ho
w
ev
er,
is
the
v
alue
of
its
rst
argumen
t,
so
the
while
lo
op
 on
tin
ues
so
long
as
p
oin
t
is
not
at
the
end
of
the
buer
and
is
b
et
w
een
paragraphs.
When,
nally
,
p
oin
t
is
mo
v
ed
to
a
paragraph,
the
and
expression
tests
false.
Note
ho
w
ev
er,
that
the
forward-line
 ommand
is
 arried
out
an
yho
w.
This
means
that
when
p
oin
t
is
mo
v
ed
from
b
et
w
een
paragraphs
to
a
paragraph,
it
is
left
at
the
b
eginning
of
the
se ond
line
of
the
paragraph.
Within
paragraphs
The
next
expression
in
the
outer
while
lo
op
is
an
if
expression.
The
Lisp
in
terpreter
ev
aluates
the
then-part
of
the
if
when
the
fill-prefix-
regexp
v
ariable
has
a
v
alue
other
than
nil,
and
it
ev
aluates
the
else-part
when
the
v
alue
of
if
fill-prefix-regexp
is
nil,
that
is,
when
there
is
no
ll
prex.
No
ll
prex
It
is
simplest
to
lo
ok
at
the
 o
de
for
the
 ase
when
there
is
no
ll
prex
rst.
This
 o
de
 onsists
of
y
et
another
inner
if
expression,
and
reads
as
follo
ws:
(if
(re-sear h-forward
paragraph-start
nil
t)
(goto- har
(mat h-beginning
0))
(goto- har
(point-max)))
This
expression
a tually
do
es
the
w
ork
that
most
p
eople
think
of
as
the
primary
purp
ose
of
the
forward-paragraph
 ommand:
it
 auses
a
regular
expression
sear 
h
to
o
  ur
that
sear 
hes
forw
ard
to
the
start
of
the
next
paragraph
and
if
it
is
found,
mo
v
es
p
oin
t
there;
but
if
the
start
of
another
paragraph
if
not
found,
it
mo
v
es
p
oin
t
to
the
end
of
the
a  essible
region
of
the
buer.
The
only
unfamiliar
part
of
this
is
the
use
of
mat h-beginning.
This
is
another
fun tion
that
is
new
to
us.
The
mat h-beginning
fun tion
returns
a
n
um
b
er
sp
e ifying
the
lo
 ation
of
the
start
of
the
text
that
w
as
mat 
hed
b
y
the
last
regular
expression
sear 
h.
The
mat h-beginning
fun tion
is
used
here
b
e ause
of
a
 
hara teristi 
of
a
forw
ard
sear 
h:
a
su  essful
forw
ard
sear 
h,
regardless
of
whether
it
is
a
plain
sear 
h
or
a
regular
expression
sear 
h,
will
mo
v
e
p
oin
t
to
the
end
of
the
text
that
is
found.
In
this
 ase,
a
su  essful
sear 
h
will
mo
v
e
p
oin
t
to

Summary
161
the
end
of
the
pattern
for
paragraph-start,
whi 
h
will
b
e
the
b
eginning
of
the
next
paragraph
rather
than
the
end
of
the
 urren
t
one.
Ho
w
ev
er,
w
e
w
an
t
to
put
p
oin
t
at
the
end
of
the
 urren
t
paragraph,
not
at
the
b
eginning
of
the
next
one.
The
t
w
o
p
ositions
ma
y
b
e
dieren
t,
b
e ause
there
ma
y
b
e
sev
eral
blank
lines
b
et
w
een
paragraphs.
When
giv
en
an
argumen
t
of
0,
mat h-beginning
returns
the
p
osition
that
is
the
start
of
the
text
that
the
most
re en
t
regular
expression
sear 
h
mat 
hed.
In
this
 ase,
the
most
re en
t
regular
expression
sear 
h
is
the
one
lo
oking
for
paragraph-start,
so
mat h-beginning
returns
the
b
eginning
p
osition
of
the
pattern,
rather
than
the
end
of
the
pattern.
The
b
eginning
p
osition
is
the
end
of
the
paragraph.
(In iden
tally
,
when
passed
a
p
ositiv
e
n
um
b
er
as
an
argumen
t,
the
mat h-
beginning
fun tion
will
pla e
p
oin
t
at
that
paren
thesized
expression
in
the
last
regular
expression.
It
is
a
useful
fun tion.)
With
a
ll
prex
The
inner
if
expression
just
dis ussed
is
the
else-part
of
an
en losing
if
expression
whi 
h
tests
whether
there
is
a
ll
prex.
If
there
is
a
ll
prex,
the
then-part
of
this
if
is
ev
aluated.
It
lo
oks
lik
e
this:
(while
(and
(not
(eobp))
(not
(looking-at
paragraph-separate))
(looking-at
fill-prefix-regexp))
(forward-line
1))
What
this
expression
do
es
is
mo
v
e
p
oin
t
forw
ard
line
b
y
line
so
long
as
three
 onditions
are
true:
1.
P
oin
t
is
not
at
the
end
of
the
buer.
2.
The
text
follo
wing
p
oin
t
do
es
not
separate
paragraphs.
3.
The
pattern
follo
wing
p
oin
t
is
the
ll
prex
regular
expression.
The
last
 ondition
ma
y
b
e
puzzling,
un
til
y
ou
remem
b
er
that
p
oin
t
w
as
mo
v
ed
to
the
b
eginning
of
the
line
early
in
the
forward-paragraph
fun tion.
This
means
that
if
the
text
has
a
ll
prex,
the
looking-at
fun tion
will
see
it.
Summary
In
summary
,
when
mo
ving
forw
ard,
the
forward-paragraph
fun tion
do
es
the
follo
wing:

Mo
v
e
p
oin
t
to
the
b
eginning
of
the
line.

Skip
o
v
er
lines
b
et
w
een
paragraphs.

Che 
k
whether
there
is
a
ll
prex,
and
if
there
is:
|
Go
forw
ard
line
b
y
line
so
long
as
the
line
is
not
a
paragraph
sep-
arating
line.

162
Chapter
12:
Regular
Expression
Sear 
hes

But
if
there
is
no
ll
prex,
|
Sear 
h
for
the
next
paragraph
start
pattern.
|
Go
to
the
b
eginning
of
the
paragraph
start
pattern,
whi 
h
will
b
e
the
end
of
the
previous
paragraph.
|
Or
else
go
to
the
end
of
the
a  essible
p
ortion
of
the
buer.
F
or
review,
here
is
the
 o
de
w
e
ha
v
e
just
b
een
dis ussing,
formatted
for
 larit
y:
(intera tive
"p")
(or
arg
(setq
arg
1))
(let*
(
(fill-prefix-regexp
(and
fill-prefix
(not
(equal
fill-prefix
""))
(not
paragraph-ignore-fill-prefix)
(regexp-quote
fill-prefix)))
(paragraph-separate
(if
fill-prefix-regexp
( on at
paragraph-separate
"\\|^"
fill-prefix-regexp
"[
\t℄*$")
paragraph-separate)))
omitted-ba 
kw
ard-mo
ving- o
de
...
(while
(>
arg
0)
;
forw
ard-mo
ving- o
de
(beginning-of-line)
(while
(prog1
(and
(not
(eobp))
(looking-at
paragraph-separate))
(forward-line
1)))
(if
fill-prefix-regexp
(while
(and
(not
(eobp))
;
then-part
(not
(looking-at
paragraph-separate))
(looking-at
fill-prefix-regexp))
(forward-line
1))
;
else-part:
the
inner-if
(if
(re-sear h-forward
paragraph-start
nil
t)
(goto- har
(mat h-beginning
0))
(goto- har
(point-max))))
(setq
arg
(1-
arg)))))
;
de remen
ter
The
full
denition
for
the
forward-paragraph
fun tion
not
only
in ludes
this
 o
de
for
going
forw
ards,
but
also
 o
de
for
going
ba 
kw
ards.

Create
Y
our
Own
`TAGS'
File
163
If
y
ou
are
reading
this
inside
of
GNU
Ema s
and
y
ou
w
an
t
to
see
the
whole
fun tion,
y
ou
 an
t
yp
e
C-h
f
(des ribe-fun tion)
and
the
name
of
the
fun tion.
This
giv
es
y
ou
the
fun tion
do
 umen
tation
and
the
name
of
the
library
 on
taining
the
fun tion's
sour e.
Pla e
p
oin
t
o
v
er
the
name
of
the
library
and
press
the
RET
k
ey;
y
ou
will
b
e
tak
en
dire tly
to
the
sour e.
(Be
sure
to
install
y
our
sour es!
Without
them,
y
ou
are
lik
e
a
p
erson
who
tries
to
driv
e
a
 ar
with
his
ey
es
sh
ut!)
Or
{
a
go
o
d
habit
to
get
in
to
{
y
ou
 an
t
yp
e
M-.
(find-tag)
and
the
name
of
the
fun tion
when
prompted
for
it.
This
will
tak
e
y
ou
di-
re tly
to
the
sour e.
If
the
find-tag
fun tion
rst
asks
y
ou
for
the
name
of
a
`TAGS'
table,
giv
e
it
the
name
of
the
`TAGS'
le
su 
h
as
`/usr/lo al/share/ema s/21
.0.1
00/l
isp
/TAG
S'.
(The
exa t
path
to
y
our
`TAGS'
le
dep
ends
on
ho
w
y
our
 op
y
of
Ema s
w
as
installed.)
Y
ou
 an
also
 reate
y
our
o
wn
`TAGS'
le
for
dire tories
that
la 
k
one.
12.5
Create
Y
our
Own
`TAGS'
File
The
M-.
(find-tag)
 ommand
tak
es
y
ou
dire tly
to
the
sour e
for
a
fun tion,
v
ariable,
no
de,
or
other
sour e.
The
fun tion
dep
ends
on
tags
tables
to
tell
it
where
to
go.
Y
ou
often
need
to
build
and
install
tags
tables
y
ourself.
They
are
not
built
automati ally
.
A
tags
table
is
 alled
a
`TAGS'
le;
the
name
is
in
upp
er
 ase
letters.
Y
ou
 an
 reate
a
`TAGS'
le
b
y
 alling
the
etags
program
that
 omes
as
a
part
of
the
Ema s
distribution.
Usually
,
etags
is
 ompiled
and
installed
when
Ema s
is
built.
(etags
is
not
an
Ema s
Lisp
fun tion
or
a
part
of
Ema s;
it
is
a
C
program.)
T
o
 reate
a
`TAGS'
le,
rst
swit 
h
to
the
dire tory
in
whi 
h
y
ou
w
an
t
to
 reate
the
le.
In
Ema s
y
ou
 an
do
this
with
the
M-x
 d
 ommand,
or
b
y
visiting
a
le
in
the
dire tory
,
or
b
y
listing
the
dire tory
with
C-x
d
(dired).
Then
run
the
 ompile
 ommand,
with
etags
*.el
as
the
 ommand
to
exe ute
M-x
 ompile
RET
etags
*.el
RET
to
 reate
a
`TAGS'
le.
F
or
example,
if
y
ou
ha
v
e
a
large
n
um
b
er
of
les
in
y
our
`~/ema s'
dire -
tory
,
as
I
do|I
ha
v
e
137
`.el'
les
in
it,
of
whi 
h
I
load
12|y
ou
 an
 reate
a
`TAGS'
le
for
the
Ema s
Lisp
les
in
that
dire tory
.
The
etags
program
tak
es
all
the
usual
shell
`wild ards'.
F
or
example,
if
y
ou
ha
v
e
t
w
o
dire tories
for
whi 
h
y
ou
w
an
t
a
single
`TAGS
file',
t
yp
e
etags
*.el
../elisp/*.el
,
where
`../elisp/'
is
the
se ond
dire tory:
M-x
 ompile
RET
etags
*.el
../elisp/*.el
RET

164
Chapter
12:
Regular
Expression
Sear 
hes
T
yp
e
M-x
 ompile
RET
etags
--help
RET
to
see
a
list
of
the
options
a  epted
b
y
etags
as
w
ell
as
a
list
of
supp
orted
languages.
The
etags
program
handles
more
than
20
languages,
in luding
Ema s
Lisp,
Common
Lisp,
S 
heme,
C,
C++,
Ada,
F
ortran,
Ja
v
a,
LaT
eX,
P
as al,
P
erl,
Python,
T
exinfo,
mak
eles,
and
most
assem
blers.
The
program
has
no
swit 
hes
for
sp
e ifying
the
language;
it
re ognizes
the
language
in
an
input
le
a  ording
to
its
le
name
and
 on
ten
ts.
`etags'
is
v
ery
helpful
when
y
ou
are
writing
 o
de
y
ourself
and
w
an
t
to
refer
ba 
k
to
fun tions
y
ou
ha
v
e
already
written.
Just
run
etags
again
at
in
terv
als
as
y
ou
write
new
fun tions,
so
they
b
e ome
part
of
the
`TAGS'
le.
If
y
ou
think
an
appropriate
`TAGS'
le
already
exists
for
what
y
ou
w
an
t,
but
do
not
kno
w
where
it
is,
y
ou
 an
use
the
lo ate
program
to
attempt
to
nd
it.
T
yp
e
M-x
lo ate
RET
TAGS
RET
and
Ema s
will
list
for
y
ou
the
full
path
names
of
all
y
our
`TAGS'
les.
On
m
y
system,
this
 ommand
lists
34
`TAGS'
les.
On
the
other
hand,
a
`plain
v
anilla'
system
I
re en
tly
installed
did
not
 on
tain
an
y
`TAGS'
les.
If
the
tags
table
y
ou
w
an
t
has
b
een
 reated,
y
ou
 an
use
the
M-x
visit-
tags-table
 ommand
to
sp
e ify
it.
Otherwise,
y
ou
will
need
to
 reate
the
tag
table
y
ourself
and
then
use
M-x
visit-tags-table.
Building
T
ags
in
the
Ema s
sour es
The
GNU
Ema s
sour es
 ome
with
a
`Makefile'
that
 on
tains
a
sophis-
ti ated
etags
 ommand
that
 reates,
 olle ts,
and
merges
tags
tables
from
all
o
v
er
the
Ema s
sour es
and
puts
the
information
in
to
one
`TAGS'
le
in
the
`sr /'
dire tory
b
elo
w
the
top
lev
el
of
y
our
Ema s
sour e
dire tory
.
T
o
build
this
`TAGS'
le,
go
to
the
top
lev
el
of
y
our
Ema s
sour e
dire tory
and
run
the
 ompile
 ommand
make
tags:
M-x
 ompile
RET
make
tags
RET
(The
make
tags
 ommand
w
orks
w
ell
with
the
GNU
Ema s
sour es,
as
w
ell
as
with
some
other
sour e
pa 
k
ages.)
F
or
more
information,
see
se tion
\T
ag
T
ables"
in
The
GNU
Ema s
Man-
ual
.
12.6
Review
Here
is
a
brief
summary
of
some
re en
tly
in
tro
du ed
fun tions.
while
Rep
eatedly
ev
aluate
the
b
o
dy
of
the
expression
so
long
as
the
rst
elemen
t
of
the
b
o
dy
tests
true.
Then
return
nil.
(The
expression
is
ev
aluated
only
for
its
side
ee ts.)

Review
165
F
or
example:
(let
((foo
2))
(while
(>
foo
0)
(insert
(format
"foo
is
%d.\n"
foo))
(setq
foo
(1-
foo))))
)
foo
is
2.
foo
is
1.
nil
(The
insert
fun tion
inserts
its
argumen
ts
at
p
oin
t;
the
format
fun tion
returns
a
string
formatted
from
its
argumen
ts
the
w
a
y
message
formats
its
argumen
ts;
\n
pro
du es
a
new
line.)
re-sear h-forward
Sear 
h
for
a
pattern,
and
if
the
pattern
is
found,
mo
v
e
p
oin
t
to
rest
just
after
it.
T
ak
es
four
argumen
ts,
lik
e
sear h-forward:
1.
A
regular
expression
that
sp
e ies
the
pattern
to
sear 
h
for.
2.
Optionally
,
the
limit
of
the
sear 
h.
3.
Optionally
,
what
to
do
if
the
sear 
h
fails,
return
nil
or
an
error
message.
4.
Optionally
,
ho
w
man
y
times
to
rep
eat
the
sear 
h;
if
nega-
tiv
e,
the
sear 
h
go
es
ba 
kw
ards.
let*
Bind
some
v
ariables
lo
 ally
to
parti ular
v
alues,
and
then
ev
al-
uate
the
remaining
argumen
ts,
returning
the
v
alue
of
the
last
one.
While
binding
the
lo
 al
v
ariables,
use
the
lo
 al
v
alues
of
v
ariables
b
ound
earlier,
if
an
y
.
F
or
example:
(let*
((foo
7)
(bar
(*
3
foo)))
(message
"`bar'
is
%d."
bar))
)
`bar'
is
21.
mat h-beginning
Return
the
p
osition
of
the
start
of
the
text
found
b
y
the
last
regular
expression
sear 
h.
looking-at
Return
t
for
true
if
the
text
after
p
oin
t
mat 
hes
the
argumen
t,
whi 
h
should
b
e
a
regular
expression.
eobp
Return
t
for
true
if
p
oin
t
is
at
the
end
of
the
a  essible
part
of
a
buer.
The
end
of
the
a  essible
part
is
the
end
of
the
buer
if
the
buer
is
not
narro
w
ed;
it
is
the
end
of
the
narro
w
ed
part
if
the
buer
is
narro
w
ed.

166
Chapter
12:
Regular
Expression
Sear 
hes
prog1
Ev
aluate
ea 
h
argumen
t
in
sequen e
and
then
return
the
v
alue
of
the
rst.
F
or
example:
(prog1
1
2
3
4)
)
1
12.7
Exer ises
with
re-sear h-for
wa
rd

W
rite
a
fun tion
to
sear 
h
for
a
regular
expression
that
mat 
hes
t
w
o
or
more
blank
lines
in
sequen e.

W
rite
a
fun tion
to
sear 
h
for
dupli ated
w
ords,
su 
h
as
`the
the'.
See
se tion
\Syn
tax
of
Regular
Expressions"
in
The
GNU
Ema s
Man
ual
,
for
information
on
ho
w
to
write
a
regexp
(a
regular
expression)
to
mat 
h
a
string
that
is
 omp
osed
of
t
w
o
iden
ti al
halv
es.
Y
ou
 an
devise
sev
eral
regexps;
some
are
b
etter
than
others.
The
fun tion
I
use
is
des rib
ed
in
an
app
endix,
along
with
sev
eral
regexps.
See
App
endix
A,
\the-the
Dupli ated
W
ords
F
un tion",
page
241.

The
 ount-words-region
F
un tion
167
13
Coun
ting:
Rep
etition
and
Regexps
Rep
etition
and
regular
expression
sear 
hes
are
p
o
w
erful
to
ols
that
y
ou
often
use
when
y
ou
write
 o
de
in
Ema s
Lisp.
This
 
hapter
illustrates
the
use
of
regular
expression
sear 
hes
through
the
 onstru tion
of
w
ord
 oun
t
 ommands
using
while
lo
ops
and
re ursion.
The
standard
Ema s
distribution
 on
tains
a
fun tion
for
 oun
ting
the
n
um
b
er
of
lines
within
a
region.
Ho
w
ev
er,
there
is
no
 orresp
onding
fun tion
for
 oun
ting
w
ords.
Certain
t
yp
es
of
writing
ask
y
ou
to
 oun
t
w
ords.
Th
us,
if
y
ou
write
an
essa
y
,
y
ou
ma
y
b
e
limited
to
800
w
ords;
if
y
ou
write
a
no
v
el,
y
ou
ma
y
dis ipline
y
ourself
to
write
1000
w
ords
a
da
y
.
It
seems
o
dd
to
me
that
Ema s
la 
ks
a
w
ord
 oun
t
 ommand.
P
erhaps
p
eople
use
Ema s
mostly
for
 o
de
or
t
yp
es
of
do
 umen
tation
that
do
not
require
w
ord
 oun
ts;
or
p
erhaps
they
restri t
themselv
es
to
the
op
erating
system
w
ord
 oun
t
 ommand,
w .
Alternativ
ely
,
p
eople
ma
y
follo
w
the
publishers'
 on
v
en
tion
and
 ompute
a
w
ord
 oun
t
b
y
dividing
the
n
um
b
er
of
 
hara ters
in
a
do
 umen
t
b
y
v
e.
In
an
y
ev
en
t,
here
are
 ommands
to
 oun
t
w
ords.
13.1
The
 ount-words-re
gi
on
F
un tion
A
w
ord
 oun
t
 ommand
 ould
 oun
t
w
ords
in
a
line,
paragraph,
region,
or
buer.
What
should
the
 ommand
 o
v
er?
Y
ou
 ould
design
the
 ommand
to
 oun
t
the
n
um
b
er
of
w
ords
in
a
 omplete
buer.
Ho
w
ev
er,
the
Ema s
tra-
dition
en ourages
exibilit
y|y
ou
ma
y
w
an
t
to
 oun
t
w
ords
in
just
a
se tion,
rather
than
all
of
a
buer.
So
it
mak
es
more
sense
to
design
the
 ommand
to
 oun
t
the
n
um
b
er
of
w
ords
in
a
region.
On e
y
ou
ha
v
e
a
 ount-words-
region
 ommand,
y
ou
 an,
if
y
ou
wish,
 oun
t
w
ords
in
a
whole
buer
b
y
marking
it
with
C-x
h
(mark-whole-buffer).
Clearly
,
 oun
ting
w
ords
is
a
rep
etitiv
e
a t:
starting
from
the
b
eginning
of
the
region,
y
ou
 oun
t
the
rst
w
ord,
then
the
se ond
w
ord,
then
the
third
w
ord,
and
so
on,
un
til
y
ou
rea 
h
the
end
of
the
region.
This
means
that
w
ord
 oun
ting
is
ideally
suited
to
re ursion
or
to
a
while
lo
op.
First,
w
e
will
implemen
t
the
w
ord
 oun
t
 ommand
with
a
while
lo
op,
then
with
re ursion.
The
 ommand
will,
of
 ourse,
b
e
in
tera tiv
e.
The
template
for
an
in
tera tiv
e
fun tion
denition
is,
as
alw
a
ys:
(defun
name-of-fun tion
(argumen
t-list
)
"do
 umen
tation...
"
(in
tera tiv
e-expression...
)
b
o
dy
...
)
What
w
e
need
to
do
is
ll
in
the
slots.
The
name
of
the
fun tion
should
b
e
self-explanatory
and
similar
to
the
existing
 ount-lines-region
name.
This
mak
es
the
name
easier
to
remem-
b
er.
 ount-words-region
is
a
go
o
d
 
hoi e.

168
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
The
fun tion
 oun
ts
w
ords
within
a
region.
This
means
that
the
argumen
t
list
m
ust
 on
tain
sym
b
ols
that
are
b
ound
to
the
t
w
o
p
ositions,
the
b
eginning
and
end
of
the
region.
These
t
w
o
p
ositions
 an
b
e
 alled
`beginning'
and
`end'
resp
e tiv
ely
.
The
rst
line
of
the
do
 umen
tation
should
b
e
a
single
sen-
ten e,
sin e
that
is
all
that
is
prin
ted
as
do
 umen
tation
b
y
a
 ommand
su 
h
as
apropos.
The
in
tera tiv
e
expression
will
b
e
of
the
form
`(intera tive
"r")',
sin e
that
will
 ause
Ema s
to
pass
the
b
eginning
and
end
of
the
region
to
the
fun tion's
argumen
t
list.
All
this
is
routine.
The
b
o
dy
of
the
fun tion
needs
to
b
e
written
to
do
three
tasks:
rst,
to
set
up
 onditions
under
whi 
h
the
while
lo
op
 an
 oun
t
w
ords,
se ond,
to
run
the
while
lo
op,
and
third,
to
send
a
message
to
the
user.
When
a
user
 alls
 ount-words-region,
p
oin
t
ma
y
b
e
at
the
b
eginning
or
the
end
of
the
region.
Ho
w
ev
er,
the
 oun
ting
pro
 ess
m
ust
start
at
the
b
eginning
of
the
region.
This
means
w
e
will
w
an
t
to
put
p
oin
t
there
if
it
is
not
already
there.
Exe uting
(goto- har
beginning)
ensures
this.
Of
 ourse,
w
e
will
w
an
t
to
return
p
oin
t
to
its
exp
e ted
p
osition
when
the
fun tion
nishes
its
w
ork.
F
or
this
reason,
the
b
o
dy
m
ust
b
e
en losed
in
a
save-ex ursion
expression.
The
 en
tral
part
of
the
b
o
dy
of
the
fun tion
 onsists
of
a
while
lo
op
in
whi 
h
one
expression
jumps
p
oin
t
forw
ard
w
ord
b
y
w
ord,
and
another
expression
 oun
ts
those
jumps.
The
true-or-false-test
of
the
while
lo
op
should
test
true
so
long
as
p
oin
t
should
jump
forw
ard,
and
false
when
p
oin
t
is
at
the
end
of
the
region.
W
e
 ould
use
(forward-word
1)
as
the
expression
for
mo
ving
p
oin
t
for-
w
ard
w
ord
b
y
w
ord,
but
it
is
easier
to
see
what
Ema s
iden
ties
as
a
`w
ord'
if
w
e
use
a
regular
expression
sear 
h.
A
regular
expression
sear 
h
that
nds
the
pattern
for
whi 
h
it
is
sear 
hing
lea
v
es
p
oin
t
after
the
last
 
hara ter
mat 
hed.
This
means
that
a
su  ession
of
su  essful
w
ord
sear 
hes
will
mo
v
e
p
oin
t
forw
ard
w
ord
b
y
w
ord.
As
a
pra ti al
matter,
w
e
w
an
t
the
regular
expression
sear 
h
to
jump
o
v
er
whitespa e
and
pun tuation
b
et
w
een
w
ords
as
w
ell
as
o
v
er
the
w
ords
themselv
es.
A
regexp
that
refuses
to
jump
o
v
er
in
terw
ord
whitespa e
w
ould
nev
er
jump
more
than
one
w
ord!
This
means
that
the
regexp
should
in lude
the
whitespa e
and
pun tuation
that
follo
ws
a
w
ord,
if
an
y
,
as
w
ell
as
the
w
ord
itself.
(A
w
ord
ma
y
end
a
buer
and
not
ha
v
e
an
y
follo
wing
whitespa e
or
pun tuation,
so
that
part
of
the
regexp
m
ust
b
e
optional.)
Th
us,
what
w
e
w
an
t
for
the
regexp
is
a
pattern
dening
one
or
more
w
ord
 onstituen
t
 
hara ters
follo
w
ed,
optionally
,
b
y
one
or
more
 
hara ters
that
are
not
w
ord
 onstituen
ts.
The
regular
expression
for
this
is:
\w+\W*
The
buer's
syn
tax
table
determines
whi 
h
 
hara ters
are
and
are
not
w
ord
 onstituen
ts.
(See
Se tion
14.2,
\What
Constitutes
a
W
ord
or
Sym
b
ol?",
page
182,
for
more
ab
out
syn
tax.
Also,
see
se tion
\The
Syn
tax
T
able"
in

The
 ount-words-region
F
un tion
169
The
GNU
Ema s
Man
ual
,
and
se tion
\Syn
tax
T
ables"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
The
sear 
h
expression
lo
oks
lik
e
this:
(re-sear h-forward
"\\w+\\W*")
(Note
that
paired
ba 
kslashes
pre ede
the
`w'
and
`W'.
A
single
ba 
kslash
has
sp
e ial
meaning
to
the
Ema s
Lisp
in
terpreter.
It
indi ates
that
the
fol-
lo
wing
 
hara ter
is
in
terpreted
dieren
tly
than
usual.
F
or
example,
the
t
w
o
 
hara ters,
`\n',
stand
for
`newline',
rather
than
for
a
ba 
kslash
follo
w
ed
b
y
`n'.
Tw
o
ba 
kslashes
in
a
ro
w
stand
for
an
ordinary
,
`unsp
e ial'
ba 
kslash.)
W
e
need
a
 oun
ter
to
 oun
t
ho
w
man
y
w
ords
there
are;
this
v
ariable
m
ust
rst
b
e
set
to
0
and
then
in remen
ted
ea 
h
time
Ema s
go
es
around
the
while
lo
op.
The
in remen
ting
expression
is
simply:
(setq
 ount
(1+
 ount))
Finally
,
w
e
w
an
t
to
tell
the
user
ho
w
man
y
w
ords
there
are
in
the
region.
The
message
fun tion
is
in
tended
for
presen
ting
this
kind
of
information
to
the
user.
The
message
has
to
b
e
phrased
so
that
it
reads
prop
erly
regardless
of
ho
w
man
y
w
ords
there
are
in
the
region:
w
e
don't
w
an
t
to
sa
y
that
\there
are
1
w
ords
in
the
region".
The
 oni t
b
et
w
een
singular
and
plural
is
ungrammati al.
W
e
 an
solv
e
this
problem
b
y
using
a
 onditional
expression
that
ev
aluates
dieren
t
messages
dep
ending
on
the
n
um
b
er
of
w
ords
in
the
region.
There
are
three
p
ossibilities:
no
w
ords
in
the
region,
one
w
ord
in
the
region,
and
more
than
one
w
ord.
This
means
that
the
 ond
sp
e ial
form
is
appropriate.
All
this
leads
to
the
follo
wing
fun tion
denition:
;;;
First
v
ersion;
has
bugs!
(defun
 ount-words-region
(beginning
end)
"Print
number
of
words
in
the
region.
Words
are
defined
as
at
least
one
word- onstituent
 hara ter
followed
by
at
least
one
 hara ter
that
is
not
a
word- onstituent.
The
buffer's
syntax
table
determines
whi h
 hara ters
these
are."
(intera tive
"r")
(message
"Counting
words
in
region
...
")
;;;
1.
Set
up
appropriate
 onditions.
(save-ex ursion
(goto- har
beginning)
(let
(( ount
0))
;;;
2.
Run
the
while
lo
op.
(while
(<
(point)
end)
(re-sear h-forward
"\\w+\\W*")
(setq
 ount
(1+
 ount)))

170
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
;;;
3.
Send
a
message
to
the
user.
( ond
((zerop
 ount)
(message
"The
region
does
NOT
have
any
words."))
((=
1
 ount)
(message
"The
region
has
1
word."))
(t
(message
"The
region
has
%d
words."
 ount))))))
As
written,
the
fun tion
w
orks,
but
not
in
all
 ir umstan es.
13.1.1
The
Whitespa e
Bug
in
 ount-words-region
The
 ount-words-region
 ommand
des rib
ed
in
the
pre eding
se tion
has
t
w
o
bugs,
or
rather,
one
bug
with
t
w
o
manifestations.
First,
if
y
ou
mark
a
region
 on
taining
only
whitespa e
in
the
middle
of
some
text,
the
 ount-words-region
 ommand
tells
y
ou
that
the
region
 on
tains
one
w
ord!
Se ond,
if
y
ou
mark
a
region
 on
taining
only
whitespa e
at
the
end
of
the
buer
or
the
a  essible
p
ortion
of
a
narro
w
ed
buer,
the
 ommand
displa
ys
an
error
message
that
lo
oks
lik
e
this:
Sear h
failed:
"\\w+\\W*"
If
y
ou
are
reading
this
in
Info
in
GNU
Ema s,
y
ou
 an
test
for
these
bugs
y
ourself.
First,
ev
aluate
the
fun tion
in
the
usual
manner
to
install
it.
If
y
ou
wish,
y
ou
 an
also
install
this
k
eybinding
b
y
ev
aluating
it:
(global-set-key
"\C- ="
' ount-words-region)
T
o
 ondu t
the
rst
test,
set
mark
and
p
oin
t
to
the
b
eginning
and
end
of
the
follo
wing
line
and
then
t
yp
e
C- 
=
(or
M-x
 ount-words-region
if
y
ou
ha
v
e
not
b
ound
C- 
=):
one
two
three
Ema s
will
tell
y
ou,
 orre tly
,
that
the
region
has
three
w
ords.
Rep
eat
the
test,
but
pla e
mark
at
the
b
eginning
of
the
line
and
pla e
p
oin
t
just
b
efor
e
the
w
ord
`one'.
Again
t
yp
e
the
 ommand
C- 
=
(or
M-x
 ount-words-region).
Ema s
should
tell
y
ou
that
the
region
has
no
w
ords,
sin e
it
is
 omp
osed
only
of
the
whitespa e
at
the
b
eginning
of
the
line.
But
instead
Ema s
tells
y
ou
that
the
region
has
one
w
ord!
F
or
the
third
test,
 op
y
the
sample
line
to
the
end
of
the
`*s rat h*'
buer
and
then
t
yp
e
sev
eral
spa es
at
the
end
of
the
line.
Pla e
mark
righ
t
after
the
w
ord
`three'
and
p
oin
t
at
the
end
of
line.
(The
end
of
the
line
will
b
e
the
end
of
the
buer.)
T
yp
e
C- 
=
(or
M-x
 ount-words-region)
as
y
ou
did
b
efore.
Again,
Ema s
should
tell
y
ou
that
the
region
has
no
w
ords,

The
Whitespa e
Bug
in
 ount-words-region
171
sin e
it
is
 omp
osed
only
of
the
whitespa e
at
the
end
of
the
line.
Instead,
Ema s
displa
ys
an
error
message
sa
ying
`Sear h
failed'.
The
t
w
o
bugs
stem
from
the
same
problem.
Consider
the
rst
manifestation
of
the
bug,
in
whi 
h
the
 ommand
tells
y
ou
that
the
whitespa e
at
the
b
eginning
of
the
line
 on
tains
one
w
ord.
What
happ
ens
is
this:
The
M-x
 ount-words-region
 ommand
mo
v
es
p
oin
t
to
the
b
eginning
of
the
region.
The
while
tests
whether
the
v
alue
of
p
oin
t
is
smaller
than
the
v
alue
of
end,
whi 
h
it
is.
Consequen
tly
,
the
regular
expression
sear 
h
lo
oks
for
and
nds
the
rst
w
ord.
It
lea
v
es
p
oin
t
after
the
w
ord.
 ount
is
set
to
one.
The
while
lo
op
rep
eats;
but
this
time
the
v
alue
of
p
oin
t
is
larger
than
the
v
alue
of
end,
the
lo
op
is
exited;
and
the
fun tion
displa
ys
a
message
sa
ying
the
n
um
b
er
of
w
ords
in
the
region
is
one.
In
brief,
the
regular
expression
sear 
h
lo
oks
for
and
nds
the
w
ord
ev
en
though
it
is
outside
the
mark
ed
region.
In
the
se ond
manifestation
of
the
bug,
the
region
is
whitespa e
at
the
end
of
the
buer.
Ema s
sa
ys
`Sear h
failed'.
What
happ
ens
is
that
the
true-or-false-test
in
the
while
lo
op
tests
true,
so
the
sear 
h
expression
is
exe uted.
But
sin e
there
are
no
more
w
ords
in
the
buer,
the
sear 
h
fails.
In
b
oth
manifestations
of
the
bug,
the
sear 
h
extends
or
attempts
to
extend
outside
of
the
region.
The
solution
is
to
limit
the
sear 
h
to
the
region|this
is
a
fairly
simple
a tion,
but
as
y
ou
ma
y
ha
v
e
 ome
to
exp
e t,
it
is
not
quite
as
simple
as
y
ou
migh
t
think.
As
w
e
ha
v
e
seen,
the
re-sear h-forward
fun tion
tak
es
a
sear 
h
pattern
as
its
rst
argumen
t.
But
in
addition
to
this
rst,
mandatory
argumen
t,
it
a  epts
three
optional
argumen
ts.
The
optional
se ond
argumen
t
b
ounds
the
sear 
h.
The
optional
third
argumen
t,
if
t,
 auses
the
fun tion
to
return
nil
rather
than
signal
an
error
if
the
sear 
h
fails.
The
optional
fourth
argumen
t
is
a
rep
eat
 oun
t.
(In
Ema s,
y
ou
 an
see
a
fun tion's
do
 umen
tation
b
y
t
yping
C-h
f,
the
name
of
the
fun tion,
and
then
h
RET
i
.)
In
the
 ount-words-region
denition,
the
v
alue
of
the
end
of
the
region
is
held
b
y
the
v
ariable
end
whi 
h
is
passed
as
an
argumen
t
to
the
fun -
tion.
Th
us,
w
e
 an
add
end
as
an
argumen
t
to
the
regular
expression
sear 
h
expression:
(re-sear h-forward
"\\w+\\W*"
end)
Ho
w
ev
er,
if
y
ou
mak
e
only
this
 
hange
to
the
 ount-words-region
deni-
tion
and
then
test
the
new
v
ersion
of
the
denition
on
a
stret 
h
of
whitespa e,
y
ou
will
re eiv
e
an
error
message
sa
ying
`Sear h
failed'.
What
happ
ens
is
this:
the
sear 
h
is
limited
to
the
region,
and
fails
as
y
ou
exp
e t
b
e ause
there
are
no
w
ord- onstituen
t
 
hara ters
in
the
region.
Sin e
it
fails,
w
e
re eiv
e
an
error
message.
But
w
e
do
not
w
an
t
to
re eiv
e
an
error
message
in
this
 ase;
w
e
w
an
t
to
re eiv
e
the
message
that
"The
region
do
es
NOT
ha
v
e
an
y
w
ords."

172
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
The
solution
to
this
problem
is
to
pro
vide
re-sear h-forward
with
a
third
argumen
t
of
t,
whi 
h
 auses
the
fun tion
to
return
nil
rather
than
signal
an
error
if
the
sear 
h
fails.
Ho
w
ev
er,
if
y
ou
mak
e
this
 
hange
and
try
it,
y
ou
will
see
the
message
\Coun
ting
w
ords
in
region
...
"
and
.
.
.
y
ou
will
k
eep
on
seeing
that
message
.
.
.
,
un
til
y
ou
t
yp
e
C-g
(keyboard-quit).
Here
is
what
happ
ens:
the
sear 
h
is
limited
to
the
region,
as
b
efore,
and
it
fails
b
e ause
there
are
no
w
ord- onstituen
t
 
hara ters
in
the
region,
as
exp
e ted.
Consequen
tly
,
the
re-sear h-forward
expression
returns
nil.
It
do
es
nothing
else.
In
parti ular,
it
do
es
not
mo
v
e
p
oin
t,
whi 
h
it
do
es
as
a
side
ee t
if
it
nds
the
sear 
h
target.
After
the
re-sear h-forward
expression
returns
nil,
the
next
expression
in
the
while
lo
op
is
ev
aluated.
This
expression
in remen
ts
the
 oun
t.
Then
the
lo
op
rep
eats.
The
true-or-
false-test
tests
true
b
e ause
the
v
alue
of
p
oin
t
is
still
less
than
the
v
alue
of
end,
sin e
the
re-sear h-forward
expression
did
not
mo
v
e
p
oin
t.
.
.
.
and
the
 y le
rep
eats
.
.
.
The
 ount-words-region
denition
requires
y
et
another
mo
di ation,
to
 ause
the
true-or-false-test
of
the
while
lo
op
to
test
false
if
the
sear 
h
fails.
Put
another
w
a
y
,
there
are
t
w
o
 onditions
that
m
ust
b
e
satised
in
the
true-or-false-test
b
efore
the
w
ord
 oun
t
v
ariable
is
in remen
ted:
p
oin
t
m
ust
still
b
e
within
the
region
and
the
sear 
h
expression
m
ust
ha
v
e
found
a
w
ord
to
 oun
t.
Sin e
b
oth
the
rst
 ondition
and
the
se ond
 ondition
m
ust
b
e
true
together,
the
t
w
o
expressions,
the
region
test
and
the
sear 
h
expression,
 an
b
e
joined
with
an
and
sp
e ial
form
and
em
b
edded
in
the
while
lo
op
as
the
true-or-false-test,
lik
e
this:
(and
(<
(point)
end)
(re-sear h-forward
"\\w+\\W*"
end
t))
(F
or
information
ab
out
and,
see
Se tion
12.4,
\forward-paragraph:
a
Gold-
mine
of
F
un tions",
page
155.)
The
re-sear h-forward
expression
returns
t
if
the
sear 
h
su  eeds
and
as
a
side
ee t
mo
v
es
p
oin
t.
Consequen
tly
,
as
w
ords
are
found,
p
oin
t
is
mo
v
ed
through
the
region.
When
the
sear 
h
expression
fails
to
nd
another
w
ord,
or
when
p
oin
t
rea 
hes
the
end
of
the
region,
the
true-or-false-test
tests
false,
the
while
lo
op
exists,
and
the
 ount-words-region
fun tion
displa
ys
one
or
other
of
its
messages.
After
in orp
orating
these
nal
 
hanges,
the
 ount-words-region
w
orks
without
bugs
(or
at
least,
without
bugs
that
I
ha
v
e
found!).
Here
is
what
it
lo
oks
lik
e:
;;;
Final
v
ersion:
while
(defun
 ount-words-region
(beginning
end)
"Print
number
of
words
in
the
region."
(intera tive
"r")
(message
"Counting
words
in
region
...
")

Coun
t
W
ords
Re ursiv
ely
173
;;;
1.
Set
up
appropriate
 onditions.
(save-ex ursion
(let
(( ount
0))
(goto- har
beginning)
;;;
2.
Run
the
while
lo
op.
(while
(and
(<
(point)
end)
(re-sear h-forward
"\\w+\\W*"
end
t))
(setq
 ount
(1+
 ount)))
;;;
3.
Send
a
message
to
the
user.
( ond
((zerop
 ount)
(message
"The
region
does
NOT
have
any
words."))
((=
1
 ount)
(message
"The
region
has
1
word."))
(t
(message
"The
region
has
%d
words."
 ount))))))
13.2
Coun
t
W
ords
Re ursiv
ely
Y
ou
 an
write
the
fun tion
for
 oun
ting
w
ords
re ursiv
ely
as
w
ell
as
with
a
while
lo
op.
Let's
see
ho
w
this
is
done.
First,
w
e
need
to
re ognize
that
the
 ount-words-region
fun tion
has
three
jobs:
it
sets
up
the
appropriate
 onditions
for
 oun
ting
to
o
  ur;
it
 oun
ts
the
w
ords
in
the
region;
and
it
sends
a
message
to
the
user
telling
ho
w
man
y
w
ords
there
are.
If
w
e
write
a
single
re ursiv
e
fun tion
to
do
ev
erything,
w
e
will
re eiv
e
a
message
for
ev
ery
re ursiv
e
 all.
If
the
region
 on
tains
13
w
ords,
w
e
will
re eiv
e
thirteen
messages,
one
righ
t
after
the
other.
W
e
don't
w
an
t
this!
Instead,
w
e
m
ust
write
t
w
o
fun tions
to
do
the
job,
one
of
whi 
h
(the
re ur-
siv
e
fun tion)
will
b
e
used
inside
of
the
other.
One
fun tion
will
set
up
the
 onditions
and
displa
y
the
message;
the
other
will
return
the
w
ord
 oun
t.
Let
us
start
with
the
fun tion
that
 auses
the
message
to
b
e
displa
y
ed.
W
e
 an
 on
tin
ue
to
 all
this
 ount-words-region.
This
is
the
fun tion
that
the
user
will
 all.
It
will
b
e
in
tera tiv
e.
Indeed,
it
will
b
e
similar
to
our
previous
v
ersions
of
this
fun tion,
ex ept
that
it
will
 all
re ursive- ount-words
to
determine
ho
w
man
y
w
ords
are
in
the
region.

174
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
W
e
 an
readily
 onstru t
a
template
for
this
fun tion,
based
on
our
pre-
vious
v
ersions:
;;
Re ursiv
e
v
ersion;
uses
regular
expression
sear 
h
(defun
 ount-words-region
(beginning
end)
"do
 umen
tation...
"
(in
tera tiv
e-expression...
)
;;;
1.
Set
up
appropriate
 onditions.
(explanatory
message
)
(set-up
fun tions
...
;;;
2.
Coun
t
the
w
ords.
re ursiv
e
 all
;;;
3.
Send
a
message
to
the
user.
message
pro
viding
w
ord
 oun
t
))
The
denition
lo
oks
straigh
tforw
ard,
ex ept
that
someho
w
the
 oun
t
re-
turned
b
y
the
re ursiv
e
 all
m
ust
b
e
passed
to
the
message
displa
ying
the
w
ord
 oun
t.
A
little
though
t
suggests
that
this
 an
b
e
done
b
y
making
use
of
a
let
expression:
w
e
 an
bind
a
v
ariable
in
the
v
arlist
of
a
let
expression
to
the
n
um
b
er
of
w
ords
in
the
region,
as
returned
b
y
the
re ursiv
e
 all;
and
then
the
 ond
expression,
using
binding,
 an
displa
y
the
v
alue
to
the
user.
Often,
one
thinks
of
the
binding
within
a
let
expression
as
someho
w
se ondary
to
the
`primary'
w
ork
of
a
fun tion.
But
in
this
 ase,
what
y
ou
migh
t
 onsider
the
`primary'
job
of
the
fun tion,
 oun
ting
w
ords,
is
done
within
the
let
expression.
Using
let,
the
fun tion
denition
lo
oks
lik
e
this:
(defun
 ount-words-region
(beginning
end)
"Print
number
of
words
in
the
region."
(intera tive
"r")
;;;
1.
Set
up
appropriate
 onditions.
(message
"Counting
words
in
region
...
")
(save-ex ursion
(goto- har
beginning)
;;;
2.
Coun
t
the
w
ords.
(let
(( ount
(re ursive- ount-words
end)))

Coun
t
W
ords
Re ursiv
ely
175
;;;
3.
Send
a
message
to
the
user.
( ond
((zerop
 ount)
(message
"The
region
does
NOT
have
any
words."))
((=
1
 ount)
(message
"The
region
has
1
word."))
(t
(message
"The
region
has
%d
words."
 ount))))))
Next,
w
e
need
to
write
the
re ursiv
e
 oun
ting
fun tion.
A
re ursiv
e
fun tion
has
at
least
three
parts:
the
`do-again-test',
the
`next-step-expression',
and
the
re ursiv
e
 all.
The
do-again-test
determines
whether
the
fun tion
will
or
will
not
b
e
 alled
again.
Sin e
w
e
are
 oun
ting
w
ords
in
a
region
and
 an
use
a
fun tion
that
mo
v
es
p
oin
t
forw
ard
for
ev
ery
w
ord,
the
do-again-test
 an
 
he 
k
whether
p
oin
t
is
still
within
the
region.
The
do-again-test
should
nd
the
v
alue
of
p
oin
t
and
determine
whether
p
oin
t
is
b
efore,
at,
or
after
the
v
alue
of
the
end
of
the
region.
W
e
 an
use
the
point
fun tion
to
lo
 ate
p
oin
t.
Clearly
,
w
e
m
ust
pass
the
v
alue
of
the
end
of
the
region
to
the
re ursiv
e
 oun
ting
fun tion
as
an
argumen
t.
In
addition,
the
do-again-test
should
also
test
whether
the
sear 
h
nds
a
w
ord.
If
it
do
es
not,
the
fun tion
should
not
 all
itself
again.
The
next-step-expression
 
hanges
a
v
alue
so
that
when
the
re ursiv
e
fun -
tion
is
supp
osed
to
stop
 alling
itself,
it
stops.
More
pre isely
,
the
next-step-
expression
 
hanges
a
v
alue
so
that
at
the
righ
t
time,
the
do-again-test
stops
the
re ursiv
e
fun tion
from
 alling
itself
again.
In
this
 ase,
the
next-step-
expression
 an
b
e
the
expression
that
mo
v
es
p
oin
t
forw
ard,
w
ord
b
y
w
ord.
The
third
part
of
a
re ursiv
e
fun tion
is
the
re ursiv
e
 all.
Somewhere,
also,
w
e
also
need
a
part
that
do
es
the
`w
ork'
of
the
fun tion,
a
part
that
do
es
the
 oun
ting.
A
vital
part!
But
already
,
w
e
ha
v
e
an
outline
of
the
re ursiv
e
 oun
ting
fun tion:
(defun
re ursive- ount-words
(region-end)
"do
 umen
tation...
"
do-again-test
next-step-expression
re ursiv
e
 all
)
No
w
w
e
need
to
ll
in
the
slots.
Let's
start
with
the
simplest
 ases
rst:
if
p
oin
t
is
at
or
b
ey
ond
the
end
of
the
region,
there
 annot
b
e
an
y
w
ords
in
the
region,
so
the
fun tion
should
return
zero.
Lik
ewise,
if
the
sear 
h
fails,
there
are
no
w
ords
to
 oun
t,
so
the
fun tion
should
return
zero.
On
the
other
hand,
if
p
oin
t
is
within
the
region
and
the
sear 
h
su  eeds,
the
fun tion
should
 all
itself
again.

176
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
Th
us,
the
do-again-test
should
lo
ok
lik
e
this:
(and
(<
(point)
region-end)
(re-sear h-forward
"\\w+\\W*"
region-end
t))
Note
that
the
sear 
h
expression
is
part
of
the
do-again-test|the
fun tion
returns
t
if
its
sear 
h
su  eeds
and
nil
if
it
fails.
(See
Se tion
13.1.1,
\The
Whitespa e
Bug
in
 ount-words-region",
page
170,
for
an
explanation
of
ho
w
re-sear h-forward
w
orks.)
The
do-again-test
is
the
true-or-false
test
of
an
if
 lause.
Clearly
,
if
the
do-again-test
su  eeds,
the
then-part
of
the
if
 lause
should
 all
the
fun tion
again;
but
if
it
fails,
the
else-part
should
return
zero
sin e
either
p
oin
t
is
outside
the
region
or
the
sear 
h
failed
b
e ause
there
w
ere
no
w
ords
to
nd.
But
b
efore
 onsidering
the
re ursiv
e
 all,
w
e
need
to
 onsider
the
next-
step-expression.
What
is
it?
In
terestingly
,
it
is
the
sear 
h
part
of
the
do-
again-test.
In
addition
to
returning
t
or
nil
for
the
do-again-test,
re-sear h-
forward
mo
v
es
p
oin
t
forw
ard
as
a
side
ee t
of
a
su  essful
sear 
h.
This
is
the
a tion
that
 
hanges
the
v
alue
of
p
oin
t
so
that
the
re ursiv
e
fun tion
stops
 alling
itself
when
p
oin
t
 ompletes
its
mo
v
emen
t
through
the
region.
Con-
sequen
tly
,
the
re-sear h-forward
expression
is
the
next-step-expression.
In
outline,
then,
the
b
o
dy
of
the
re ursive- ount-words
fun tion
lo
oks
lik
e
this:
(if
do-again-test-and-next-step- om
bined
;;
then
re ursiv
e- all-returning- oun
t
;;
else
return-zero
)
Ho
w
to
in orp
orate
the
me 
hanism
that
 oun
ts?
If
y
ou
are
not
used
to
writing
re ursiv
e
fun tions,
a
question
lik
e
this
 an
b
e
troublesome.
But
it
 an
and
should
b
e
approa 
hed
systemati ally
.
W
e
kno
w
that
the
 oun
ting
me 
hanism
should
b
e
asso
 iated
in
some
w
a
y
with
the
re ursiv
e
 all.
Indeed,
sin e
the
next-step-expression
mo
v
es
p
oin
t
forw
ard
b
y
one
w
ord,
and
sin e
a
re ursiv
e
 all
is
made
for
ea 
h
w
ord,
the
 oun
ting
me 
hanism
m
ust
b
e
an
expression
that
adds
one
to
the
v
alue
returned
b
y
a
 all
to
re ursive- ount-words.
Consider
sev
eral
 ases:

If
there
are
t
w
o
w
ords
in
the
region,
the
fun tion
should
return
a
v
alue
resulting
from
adding
one
to
the
v
alue
returned
when
it
 oun
ts
the
rst
w
ord,
plus
the
n
um
b
er
returned
when
it
 oun
ts
the
remaining
w
ords
in
the
region,
whi 
h
in
this
 ase
is
one.

If
there
is
one
w
ord
in
the
region,
the
fun tion
should
return
a
v
alue
resulting
from
adding
one
to
the
v
alue
returned
when
it
 oun
ts
that

Coun
t
W
ords
Re ursiv
ely
177
w
ord,
plus
the
n
um
b
er
returned
when
it
 oun
ts
the
remaining
w
ords
in
the
region,
whi 
h
in
this
 ase
is
zero.

If
there
are
no
w
ords
in
the
region,
the
fun tion
should
return
zero.
F
rom
the
sk
et 
h
w
e
 an
see
that
the
else-part
of
the
if
returns
zero
for
the
 ase
of
no
w
ords.
This
means
that
the
then-part
of
the
if
m
ust
return
a
v
alue
resulting
from
adding
one
to
the
v
alue
returned
from
a
 oun
t
of
the
remaining
w
ords.
The
expression
will
lo
ok
lik
e
this,
where
1+
is
a
fun tion
that
adds
one
to
its
argumen
t.
(1+
(re ursive- ount-words
region-end))
The
whole
re ursive- ount-words
fun tion
will
then
lo
ok
lik
e
this:
(defun
re ursive- ount-words
(region-end)
"do
 umen
tation...
"
;;;
1.
do-again-test
(if
(and
(<
(point)
region-end)
(re-sear h-forward
"\\w+\\W*"
region-end
t))
;;;
2.
then-part:
the
re ursiv
e
 all
(1+
(re ursive- ount-words
region-end))
;;;
3.
else-part
0))
Let's
examine
ho
w
this
w
orks:
If
there
are
no
w
ords
in
the
region,
the
else
part
of
the
if
expression
is
ev
aluated
and
 onsequen
tly
the
fun tion
returns
zero.
If
there
is
one
w
ord
in
the
region,
the
v
alue
of
p
oin
t
is
less
than
the
v
alue
of
region-end
and
the
sear 
h
su  eeds.
In
this
 ase,
the
true-or-false-test
of
the
if
expression
tests
true,
and
the
then-part
of
the
if
expression
is
ev
aluated.
The
 oun
ting
expression
is
ev
aluated.
This
expression
returns
a
v
alue
(whi 
h
will
b
e
the
v
alue
returned
b
y
the
whole
fun tion)
that
is
the
sum
of
one
added
to
the
v
alue
returned
b
y
a
re ursiv
e
 all.
Mean
while,
the
next-step-expression
has
 aused
p
oin
t
to
jump
o
v
er
the
rst
(and
in
this
 ase
only)
w
ord
in
the
region.
This
means
that
when
(re ursive- ount-words
region-end)
is
ev
aluated
a
se ond
time,
as
a
result
of
the
re ursiv
e
 all,
the
v
alue
of
p
oin
t
will
b
e
equal
to
or
greater
than
the
v
alue
of
region
end.
So
this
time,
re ursive- ount-words
will
return
zero.
The
zero
will
b
e
added
to
one,
and
the
original
ev
aluation
of
re ursive- ount-words
will
return
one
plus
zero,
whi 
h
is
one,
whi 
h
is
the
 orre t
amoun
t.
Clearly
,
if
there
are
t
w
o
w
ords
in
the
region,
the
rst
 all
to
re ursive-
 ount-words
returns
one
added
to
the
v
alue
returned
b
y
 alling
re ursive-
 ount-words
on
a
region
 on
taining
the
remaining
w
ord|that
is,
it
adds
one
to
one,
pro
du ing
t
w
o,
whi 
h
is
the
 orre t
amoun
t.

178
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps
Similarly
,
if
there
are
three
w
ords
in
the
region,
the
rst
 all
to
re ursive- ount-words
returns
one
added
to
the
v
alue
returned
b
y
 alling
re ursive- ount-words
on
a
region
 on
taining
the
remaining
t
w
o
w
ords|
and
so
on
and
so
on.
With
full
do
 umen
tation
the
t
w
o
fun tions
lo
ok
lik
e
this:
The
re ursiv
e
fun tion:
(defun
re ursive- ount-words
(region-end)
"Number
of
words
between
point
and
REGION-END."
;;;
1.
do-again-test
(if
(and
(<
(point)
region-end)
(re-sear h-forward
"\\w+\\W*"
region-end
t))
;;;
2.
then-part:
the
re ursiv
e
 all
(1+
(re ursive- ount-words
region-end))
;;;
3.
else-part
0))
The
wrapp
er:
;;;
Re ursiv
e
v
ersion
(defun
 ount-words-region
(beginning
end)
"Print
number
of
words
in
the
region.
Words
are
defined
as
at
least
one
word- onstituent
 hara ter
followed
by
at
least
one
 hara ter
that
is
not
a
word- onstituent.
The
buffer's
syntax
table
determines
whi h
 hara ters
these
are."
(intera tive
"r")
(message
"Counting
words
in
region
...
")
(save-ex ursion
(goto- har
beginning)
(let
(( ount
(re ursive- ount-words
end)))
( ond
((zerop
 ount)
(message
"The
region
does
NOT
have
any
words."))
((=
1
 ount)
(message
"The
region
has
1
word."))
(t
(message
"The
region
has
%d
words."
 ount))))))

Exer ise:
Coun
ting
Pun tuation
179
13.3
Exer ise:
Coun
ting
Pun tuation
Using
a
while
lo
op,
write
a
fun tion
to
 oun
t
the
n
um
b
er
of
pun tuation
marks
in
a
region|p
erio
d,
 omma,
semi olon,
 olon,
ex lamation
mark,
and
question
mark.
Do
the
same
using
re ursion.

180
Chapter
13:
Coun
ting:
Rep
etition
and
Regexps

What
to
Coun
t?
181
14
Coun
ting
W
ords
in
a
defun
Our
next
pro
je t
is
to
 oun
t
the
n
um
b
er
of
w
ords
in
a
fun tion
denition.
Clearly
,
this
 an
b
e
done
using
some
v
arian
t
of
 ount-word-region.
See
Chapter
13,
\Coun
ting
W
ords:
Rep
etition
and
Regexps",
page
167.
If
w
e
are
just
going
to
 oun
t
the
w
ords
in
one
denition,
it
is
easy
enough
to
mark
the
denition
with
the
C-M-h
(mark-defun)
 ommand,
and
then
 all
 ount-word-region.
Ho
w
ev
er,
I
am
more
am
bitious:
I
w
an
t
to
 oun
t
the
w
ords
and
sym
b
ols
in
ev
ery
denition
in
the
Ema s
sour es
and
then
prin
t
a
graph
that
sho
ws
ho
w
man
y
fun tions
there
are
of
ea 
h
length:
ho
w
man
y
 on
tain
40
to
49
w
ords
or
sym
b
ols,
ho
w
man
y
 on
tain
50
to
59
w
ords
or
sym
b
ols,
and
so
on.
I
ha
v
e
often
b
een
 urious
ho
w
long
a
t
ypi al
fun tion
is,
and
this
will
tell.
Des rib
ed
in
one
phrase,
the
histogram
pro
je t
is
daun
ting;
but
divided
in
to
n
umerous
small
steps,
ea 
h
of
whi 
h
w
e
 an
tak
e
one
at
a
time,
the
pro
je t
b
e omes
less
fearsome.
Let
us
 onsider
what
the
steps
m
ust
b
e:

First,
write
a
fun tion
to
 oun
t
the
w
ords
in
one
denition.
This
in ludes
the
problem
of
handling
sym
b
ols
as
w
ell
as
w
ords.

Se ond,
write
a
fun tion
to
list
the
n
um
b
ers
of
w
ords
in
ea 
h
fun tion
in
a
le.
This
fun tion
 an
use
the
 ount-words-in-defun
fun tion.

Third,
write
a
fun tion
to
list
the
n
um
b
ers
of
w
ords
in
ea 
h
fun tion
in
ea 
h
of
sev
eral
les.
This
en
tails
automati ally
nding
the
v
arious
les,
swit 
hing
to
them,
and
 oun
ting
the
w
ords
in
the
denitions
within
them.

F
ourth,
write
a
fun tion
to
 on
v
ert
the
list
of
n
um
b
ers
that
w
e
 reated
in
step
three
to
a
form
that
will
b
e
suitable
for
prin
ting
as
a
graph.

Fifth,
write
a
fun tion
to
prin
t
the
results
as
a
graph.
This
is
quite
a
pro
je t!
But
if
w
e
tak
e
ea 
h
step
slo
wly
,
it
will
not
b
e
diÆ ult.
14.1
What
to
Coun
t?
When
w
e
rst
start
thinking
ab
out
ho
w
to
 oun
t
the
w
ords
in
a
fun tion
denition,
the
rst
question
is
(or
ough
t
to
b
e)
what
are
w
e
going
to
 oun
t?
When
w
e
sp
eak
of
`w
ords'
with
resp
e t
to
a
Lisp
fun tion
denition,
w
e
are
a tually
sp
eaking,
in
large
part,
of
`sym
b
ols'.
F
or
example,
the
follo
wing
multiply-by-seven
fun tion
 on
tains
the
v
e
sym
b
ols
defun,
multiply-
by-seven,
number,
*,
and
7.
In
addition,
in
the
do
 umen
tation
string,
it
 on
tains
the
four
w
ords
`Multiply',
`NUMBER',
`by',
and
`seven'.
The
sym
b
ol
`number'
is
rep
eated,
so
the
denition
 on
tains
a
total
of
ten
w
ords
and
sym
b
ols.
(defun
multiply-by-seven
(number)
"Multiply
NUMBER
by
seven."
(*
7
number))

182
Chapter
14:
Coun
ting
W
ords
in
a
defun
Ho
w
ev
er,
if
w
e
mark
the
multiply-by-seven
denition
with
C-M-h
(mark-
defun),
and
then
 all
 ount-words-region
on
it,
w
e
will
nd
that
 ount-
words-region
 laims
the
denition
has
elev
en
w
ords,
not
ten!
Something
is
wrong!
The
problem
is
t
w
ofold:
 ount-words-region
do
es
not
 oun
t
the
`*'
as
a
w
ord,
and
it
 oun
ts
the
single
sym
b
ol,
multiply-by-seven,
as
 on
taining
three
w
ords.
The
h
yphens
are
treated
as
if
they
w
ere
in
terw
ord
spa es
rather
than
in
tra
w
ord
 onne tors:
`multiply-by-seven'
is
 oun
ted
as
if
it
w
ere
written
`multiply
by
seven'.
The
 ause
of
this
 onfusion
is
the
regular
expression
sear 
h
within
the
 ount-words-region
denition
that
mo
v
es
p
oin
t
forw
ard
w
ord
b
y
w
ord.
In
the
 anoni al
v
ersion
of
 ount-words-region,
the
regexp
is:
"\\w+\\W*"
This
regular
expression
is
a
pattern
dening
one
or
more
w
ord
 onstituen
t
 
hara ters
p
ossibly
follo
w
ed
b
y
one
or
more
 
hara ters
that
are
not
w
ord
 onstituen
ts.
What
is
mean
t
b
y
`w
ord
 onstituen
t
 
hara ters'
brings
us
to
the
issue
of
syn
tax,
whi 
h
is
w
orth
a
se tion
of
its
o
wn.
14.2
What
Constitutes
a
W
ord
or
Sym
b
ol?
Ema s
treats
dieren
t
 
hara ters
as
b
elonging
to
dieren
t
syn
tax
 ate-
gories.
F
or
example,
the
regular
expression,
`\\w+',
is
a
pattern
sp
e ifying
one
or
more
wor
d
 
onstituent
 
hara ters.
W
ord
 onstituen
t
 
hara ters
are
mem
b
ers
of
one
syn
tax
 ategory
.
Other
syn
tax
 ategories
in lude
the
 lass
of
pun tuation
 
hara ters,
su 
h
as
the
p
erio
d
and
the
 omma,
and
the
 lass
of
whitespa e
 
hara ters,
su 
h
as
the
blank
spa e
and
the
tab
 
hara ter.
(F
or
more
information,
see
se tion
\The
Syn
tax
T
able"
in
The
GNU
Ema s
Man
ual
,
and
se tion
\Syn
tax
T
ables"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
Syn
tax
tables
sp
e ify
whi 
h
 
hara ters
b
elong
to
whi 
h
 ategories.
Usu-
ally
,
a
h
yphen
is
not
sp
e ied
as
a
`w
ord
 onstituen
t
 
hara ter'.
Instead,
it
is
sp
e ied
as
b
eing
in
the
` lass
of
 
hara ters
that
are
part
of
sym
b
ol
names
but
not
w
ords.'
This
means
that
the
 ount-words-region
fun tion
treats
it
in
the
same
w
a
y
it
treats
an
in
terw
ord
white
spa e,
whi 
h
is
wh
y
 ount-words-region
 oun
ts
`multiply-by-seven'
as
three
w
ords.
There
are
t
w
o
w
a
ys
to
 ause
Ema s
to
 oun
t
`multiply-by-seven'
as
one
sym
b
ol:
mo
dify
the
syn
tax
table
or
mo
dify
the
regular
expression.
W
e
 ould
redene
a
h
yphen
as
a
w
ord
 onstituen
t
 
hara ter
b
y
mo
difying
the
syn
tax
table
that
Ema s
k
eeps
for
ea 
h
mo
de.
This
a tion
w
ould
serv
e
our
purp
ose,
ex ept
that
a
h
yphen
is
merely
the
most
 ommon
 
hara ter
within
sym
b
ols
that
is
not
t
ypi ally
a
w
ord
 onstituen
t
 
hara ter;
there
are
others,
to
o.

The
 ount-words-in-defun
F
un tion
183
Alternativ
ely
,
w
e
 an
redene
the
regular
expression
used
in
the
 ount-
words
denition
so
as
to
in lude
sym
b
ols.
This
pro
 edure
has
the
merit
of
 larit
y
,
but
the
task
is
a
little
tri 
ky
.
The
rst
part
is
simple
enough:
the
pattern
m
ust
mat 
h
\at
least
one
 
hara ter
that
is
a
w
ord
or
sym
b
ol
 onstituen
t".
Th
us:
"\\(\\w\\|\\s_\\)+"
The
`\\('
is
the
rst
part
of
the
grouping
 onstru t
that
in ludes
the
`\\w'
and
the
`\\s_'
as
alternativ
es,
separated
b
y
the
`\\|'.
The
`\\w'
mat 
hes
an
y
w
ord- onstituen
t
 
hara ter
and
the
`\\s_'
mat 
hes
an
y
 
hara ter
that
is
part
of
a
sym
b
ol
name
but
not
a
w
ord- onstituen
t
 
hara ter.
The
`+'
follo
wing
the
group
indi ates
that
the
w
ord
or
sym
b
ol
 onstituen
t
 
hara ters
m
ust
b
e
mat 
hed
at
least
on e.
Ho
w
ev
er,
the
se ond
part
of
the
regexp
is
more
diÆ ult
to
design.
What
w
e
w
an
t
is
to
follo
w
the
rst
part
with
\optionally
one
or
more
 
hara ters
that
are
not
 onstituen
ts
of
a
w
ord
or
sym
b
ol".
A
t
rst,
I
though
t
I
 ould
dene
this
with
the
follo
wing:
"\\(\\W\\|\\S_\\)*"
The
upp
er
 ase
`W'
and
`S'
mat 
h
 
hara ters
that
are
not
w
ord
or
sym
b
ol
 onstituen
ts.
Unfortunately
,
this
expression
mat 
hes
an
y
 
hara ter
that
is
either
not
a
w
ord
 onstituen
t
or
not
a
sym
b
ol
 onstituen
t.
This
mat 
hes
an
y
 
hara ter!
I
then
noti ed
that
ev
ery
w
ord
or
sym
b
ol
in
m
y
test
region
w
as
follo
w
ed
b
y
white
spa e
(blank
spa e,
tab,
or
newline).
So
I
tried
pla ing
a
pattern
to
mat 
h
one
or
more
blank
spa es
after
the
pattern
for
one
or
more
w
ord
or
sym
b
ol
 onstituen
ts.
This
failed,
to
o.
W
ords
and
sym
b
ols
are
often
separated
b
y
whitespa e,
but
in
a tual
 o
de
paren
theses
ma
y
follo
w
sym
b
ols
and
pun tuation
ma
y
follo
w
w
ords.
So
nally
,
I
designed
a
pattern
in
whi 
h
the
w
ord
or
sym
b
ol
 onstituen
ts
are
follo
w
ed
optionally
b
y
 
hara ters
that
are
not
white
spa e
and
then
follo
w
ed
optionally
b
y
white
spa e.
Here
is
the
full
regular
expression:
"\\(\\w\\|\\s_\\)+[^
\t\n℄*[
\t\n℄*"
14.3
The
 ount-words-in
-d
ef
un
F
un tion
W
e
ha
v
e
seen
that
there
are
sev
eral
w
a
ys
to
write
a
 ount-word-region
fun tion.
T
o
write
a
 ount-words-in-defun,
w
e
need
merely
adapt
one
of
these
v
ersions.
The
v
ersion
that
uses
a
while
lo
op
is
easy
to
understand,
so
I
am
going
to
adapt
that.
Be ause
 ount-words-in-defun
will
b
e
part
of
a
more
 omplex
program,
it
need
not
b
e
in
tera tiv
e
and
it
need
not
displa
y
a
message
but
just
return
the
 oun
t.
These
 onsiderations
simplify
the
denition
a
little.
On
the
other
hand,
 ount-words-in-defun
will
b
e
used
within
a
buer
that
 on
tains
fun tion
denitions.
Consequen
tly
,
it
is
reasonable
to
ask
that

184
Chapter
14:
Coun
ting
W
ords
in
a
defun
the
fun tion
determine
whether
it
is
 alled
when
p
oin
t
is
within
a
fun tion
denition,
and
if
it
is,
to
return
the
 oun
t
for
that
denition.
This
adds
 omplexit
y
to
the
denition,
but
sa
v
es
us
from
needing
to
pass
argumen
ts
to
the
fun tion.
These
 onsiderations
lead
us
to
prepare
the
follo
wing
template:
(defun
 ount-words-in-defun
()
"do
 umen
tation...
"
(set
up
...
(while
lo
op
...
)
return
 oun
t
)
As
usual,
our
job
is
to
ll
in
the
slots.
First,
the
set
up.
W
e
are
presuming
that
this
fun tion
will
b
e
 alled
within
a
buer
 on-
taining
fun tion
denitions.
P
oin
t
will
either
b
e
within
a
fun tion
denition
or
not.
F
or
 ount-words-in-defun
to
w
ork,
p
oin
t
m
ust
mo
v
e
to
the
b
egin-
ning
of
the
denition,
a
 oun
ter
m
ust
start
at
zero,
and
the
 oun
ting
lo
op
m
ust
stop
when
p
oin
t
rea 
hes
the
end
of
the
denition.
The
beginning-of-defun
fun tion
sear 
hes
ba 
kw
ards
for
an
op
ening
delimiter
su 
h
as
a
`('
at
the
b
eginning
of
a
line,
and
mo
v
es
p
oin
t
to
that
p
osition,
or
else
to
the
limit
of
the
sear 
h.
In
pra ti e,
this
means
that
beginning-of-defun
mo
v
es
p
oin
t
to
the
b
eginning
of
an
en losing
or
pre-
 eding
fun tion
denition,
or
else
to
the
b
eginning
of
the
buer.
W
e
 an
use
beginning-of-defun
to
pla e
p
oin
t
where
w
e
wish
to
start.
The
while
lo
op
requires
a
 oun
ter
to
k
eep
tra 
k
of
the
w
ords
or
sym
b
ols
b
eing
 oun
ted.
A
let
expression
 an
b
e
used
to
 reate
a
lo
 al
v
ariable
for
this
purp
ose,
and
bind
it
to
an
initial
v
alue
of
zero.
The
end-of-defun
fun tion
w
orks
lik
e
beginning-of-defun
ex ept
that
it
mo
v
es
p
oin
t
to
the
end
of
the
denition.
end-of-defun
 an
b
e
used
as
part
of
an
expression
that
determines
the
p
osition
of
the
end
of
the
denition.
The
set
up
for
 ount-words-in-defun
tak
es
shap
e
rapidly:
rst
w
e
mo
v
e
p
oin
t
to
the
b
eginning
of
the
denition,
then
w
e
 reate
a
lo
 al
v
ariable
to
hold
the
 oun
t,
and
nally
,
w
e
re ord
the
p
osition
of
the
end
of
the
denition
so
the
while
lo
op
will
kno
w
when
to
stop
lo
oping.
The
 o
de
lo
oks
lik
e
this:
(beginning-of-defun)
(let
(( ount
0)
(end
(save-ex ursion
(end-of-defun)
(point))))
The
 o
de
is
simple.
The
only
sligh
t
 ompli ation
is
lik
ely
to
 on ern
end:
it
is
b
ound
to
the
p
osition
of
the
end
of
the
denition
b
y
a
save-ex ursion
expression
that
returns
the
v
alue
of
p
oin
t
after
end-of-defun
temp
orarily
mo
v
es
it
to
the
end
of
the
denition.
The
se ond
part
of
the
 ount-words-in-defun,
after
the
set
up,
is
the
while
lo
op.

The
 ount-words-in-defun
F
un tion
185
The
lo
op
m
ust
 on
tain
an
expression
that
jumps
p
oin
t
forw
ard
w
ord
b
y
w
ord
and
sym
b
ol
b
y
sym
b
ol,
and
another
expression
that
 oun
ts
the
jumps.
The
true-or-false-test
for
the
while
lo
op
should
test
true
so
long
as
p
oin
t
should
jump
forw
ard,
and
false
when
p
oin
t
is
at
the
end
of
the
denition.
W
e
ha
v
e
already
redened
the
regular
expression
for
this
(see
Se tion
14.2,
\Syn
tax",
page
182),
so
the
lo
op
is
straigh
tforw
ard:
(while
(and
(<
(point)
end)
(re-sear h-forward
"\\(\\w\\|\\s_\\)+[^
\t\n℄*[
\t\n℄*"
end
t)
(setq
 ount
(1+
 ount)))
The
third
part
of
the
fun tion
denition
returns
the
 oun
t
of
w
ords
and
sym
b
ols.
This
part
is
the
last
expression
within
the
b
o
dy
of
the
let
expres-
sion,
and
 an
b
e,
v
ery
simply
,
the
lo
 al
v
ariable
 ount,
whi 
h
when
ev
aluated
returns
the
 oun
t.
Put
together,
the
 ount-words-in-defun
denition
lo
oks
lik
e
this:
(defun
 ount-words-in-defun
()
"Return
the
number
of
words
and
symbols
in
a
defun."
(beginning-of-defun)
(let
(( ount
0)
(end
(save-ex ursion
(end-of-defun)
(point))))
(while
(and
(<
(point)
end)
(re-sear h-forward
"\\(\\w\\|\\s_\\)+[^
\t\n℄*[
\t\n℄*"
end
t))
(setq
 ount
(1+
 ount)))
 ount))
Ho
w
to
test
this?
The
fun tion
is
not
in
tera tiv
e,
but
it
is
easy
to
put
a
wrapp
er
around
the
fun tion
to
mak
e
it
in
tera tiv
e;
w
e
 an
use
almost
the
same
 o
de
as
for
the
re ursiv
e
v
ersion
of
 ount-words-region:
;;;
In
tera tiv
e
v
ersion.
(defun
 ount-words-defun
()
"Number
of
words
and
symbols
in
a
fun tion
definition."
(intera tive)
(message
"Counting
words
and
symbols
in
fun tion
definition
...
")
(let
(( ount
( ount-words-in-defun)))
( ond
((zerop
 ount)
(message
"The
definition
does
NOT
have
any
words
or
symbols."))

186
Chapter
14:
Coun
ting
W
ords
in
a
defun
((=
1
 ount)
(message
"The
definition
has
1
word
or
symbol."))
(t
(message
"The
definition
has
%d
words
or
symbols."
 ount)))))
Let's
re-use
C- 
=
as
a
 on
v
enien
t
k
eybinding:
(global-set-key
"\C- ="
' ount-words-defun)
No
w
w
e
 an
try
out
 ount-words-defun:
install
b
oth
 ount-words-in-
defun
and
 ount-words-defun,
and
set
the
k
eybinding,
and
then
pla e
the
 ursor
within
the
follo
wing
denition:
(defun
multiply-by-seven
(number)
"Multiply
NUMBER
by
seven."
(*
7
number))
)
10
Su  ess!
The
denition
has
10
w
ords
and
sym
b
ols.
The
next
problem
is
to
 oun
t
the
n
um
b
ers
of
w
ords
and
sym
b
ols
in
sev
eral
denitions
within
a
single
le.
14.4
Coun
t
Sev
eral
defuns
Within
a
File
A
le
su 
h
as
`simple.el'
ma
y
ha
v
e
80
or
more
fun tion
denitions
within
it.
Our
long
term
goal
is
to
 olle t
statisti s
on
man
y
les,
but
as
a
rst
step,
our
immediate
goal
is
to
 olle t
statisti s
on
one
le.
The
information
will
b
e
a
series
of
n
um
b
ers,
ea 
h
n
um
b
er
b
eing
the
length
of
a
fun tion
denition.
W
e
 an
store
the
n
um
b
ers
in
a
list.
W
e
kno
w
that
w
e
will
w
an
t
to
in orp
orate
the
information
regarding
one
le
with
information
ab
out
man
y
other
les;
this
means
that
the
fun tion
for
 oun
ting
denition
lengths
within
one
le
need
only
return
the
list
of
lengths.
It
need
not
and
should
not
displa
y
an
y
messages.
The
w
ord
 oun
t
 ommands
 on
tain
one
expression
to
jump
p
oin
t
forw
ard
w
ord
b
y
w
ord
and
another
expression
to
 oun
t
the
jumps.
The
fun tion
to
return
the
lengths
of
denitions
 an
b
e
designed
to
w
ork
the
same
w
a
y
,
with
one
expression
to
jump
p
oin
t
forw
ard
denition
b
y
denition
and
another
expression
to
 onstru t
the
lengths'
list.
This
statemen
t
of
the
problem
mak
es
it
elemen
tary
to
write
the
fun tion
denition.
Clearly
,
w
e
will
start
the
 oun
t
at
the
b
eginning
of
the
le,
so
the
rst
 ommand
will
b
e
(goto- har
(point-min)).
Next,
w
e
start
the
while
lo
op;
and
the
true-or-false
test
of
the
lo
op
 an
b
e
a
regular
expression
sear 
h
for
the
next
fun tion
denition|so
long
as
the
sear 
h
su  eeds,
p
oin
t
is
mo
v
ed
forw
ard
and
then
the
b
o
dy
of
the
lo
op
is
ev
aluated.
The
b
o
dy
needs
an
expression
that
 onstru ts
the
lengths'
list.
 ons,
the
list
 onstru tion
 ommand,
 an
b
e
used
to
 reate
the
list.
That
is
almost
all
there
is
to
it.

lengths-list-file
in
Detail
187
Here
is
what
this
fragmen
t
of
 o
de
lo
oks
lik
e:
(goto- har
(point-min))
(while
(re-sear h-forward
"^(defun"
nil
t)
(setq
lengths-list
( ons
( ount-words-in-defun)
lengths-list)))
What
w
e
ha
v
e
left
out
is
the
me 
hanism
for
nding
the
le
that
 on
tains
the
fun tion
denitions.
In
previous
examples,
w
e
either
used
this,
the
Info
le,
or
w
e
swit 
hed
ba 
k
and
forth
to
some
other
buer,
su 
h
as
the
`*s rat h*'
buer.
Finding
a
le
is
a
new
pro
 ess
that
w
e
ha
v
e
not
y
et
dis ussed.
14.5
Find
a
File
T
o
nd
a
le
in
Ema s,
y
ou
use
the
C-x
C-f
(find-file)
 ommand.
This
 ommand
is
almost,
but
not
quite
righ
t
for
the
lengths
problem.
Let's
lo
ok
at
the
sour e
for
find-file
(y
ou
 an
use
the
find-tag
 om-
mand
or
C-h
f
(des ribe-fun tion)
to
nd
the
sour e
of
a
fun tion):
(defun
find-file
(filename)
"Edit
file
FILENAME.
Swit h
to
a
buffer
visiting
file
FILENAME,
 reating
one
if
none
already
exists."
(intera tive
"FFind
file:
")
(swit h-to-buffer
(find-file-nosele t
filename)))
The
denition
p
ossesses
short
but
 omplete
do
 umen
tation
and
an
in-
tera tiv
e
sp
e i ation
that
prompts
y
ou
for
a
le
name
when
y
ou
use
the
 ommand
in
tera tiv
ely
.
The
b
o
dy
of
the
denition
 on
tains
t
w
o
fun tions,
find-file-nosele t
and
swit h-to-buffer.
A  ording
to
its
do
 umen
tation
as
sho
wn
b
y
C-h
f
(the
des ribe-
fun tion
 ommand),
the
find-file-nosele t
fun tion
reads
the
named
le
in
to
a
buer
and
returns
the
buer.
Ho
w
ev
er,
the
buer
is
not
sele ted.
Ema s
do
es
not
swit 
h
its
atten
tion
(or
y
ours
if
y
ou
are
using
find-file-
nosele t)
to
the
named
buer.
That
is
what
swit h-to-buffer
do
es:
it
swit 
hes
the
buer
to
whi 
h
Ema s
atten
tion
is
dire ted;
and
it
swit 
hes
the
buer
displa
y
ed
in
the
windo
w
to
the
new
buer.
W
e
ha
v
e
dis ussed
buer
swit 
hing
elsewhere.
(See
Se tion
2.3,
\Swit 
hing
Buers",
page
26.)
In
this
histogram
pro
je t,
w
e
do
not
need
to
displa
y
ea 
h
le
on
the
s reen
as
the
program
determines
the
length
of
ea 
h
denition
within
it.
Instead
of
emplo
ying
swit h-to-buffer,
w
e
 an
w
ork
with
set-buffer,
whi 
h
redire ts
the
atten
tion
of
the
 omputer
program
to
a
dieren
t
buer
but
do
es
not
redispla
y
it
on
the
s reen.
So
instead
of
 alling
on
find-file
to
do
the
job,
w
e
m
ust
write
our
o
wn
expression.
The
task
is
easy:
use
find-file-nosele t
and
set-buffer.

188
Chapter
14:
Coun
ting
W
ords
in
a
defun
14.6
lengths-list-fi
le
in
Detail
The
 ore
of
the
lengths-list-file
fun tion
is
a
while
lo
op
 on
taining
a
fun tion
to
mo
v
e
p
oin
t
forw
ard
`defun
b
y
defun'
and
a
fun tion
to
 oun
t
the
n
um
b
er
of
w
ords
and
sym
b
ols
in
ea 
h
defun.
This
 ore
m
ust
b
e
sur-
rounded
b
y
fun tions
that
do
v
arious
other
tasks,
in luding
nding
the
le,
and
ensuring
that
p
oin
t
starts
out
at
the
b
eginning
of
the
le.
The
fun tion
denition
lo
oks
lik
e
this:
(defun
lengths-list-file
(filename)
"Return
list
of
definitions'
lengths
within
FILE.
The
returned
list
is
a
list
of
numbers.
Ea h
number
is
the
number
of
words
or
symbols
in
one
fun tion
definition."
(message
"Working
on
`%s'
...
"
filename)
(save-ex ursion
(let
((buffer
(find-file-nosele t
filename))
(lengths-list))
(set-buffer
buffer)
(setq
buffer-read-only
t)
(widen)
(goto- har
(point-min))
(while
(re-sear h-forward
"^(defun"
nil
t)
(setq
lengths-list
( ons
( ount-words-in-defun)
lengths-list)))
(kill-buffer
buffer)
lengths-list)))
The
fun tion
is
passed
one
argumen
t,
the
name
of
the
le
on
whi 
h
it
will
w
ork.
It
has
four
lines
of
do
 umen
tation,
but
no
in
tera tiv
e
sp
e i ation.
Sin e
p
eople
w
orry
that
a
 omputer
is
brok
en
if
they
don't
see
an
ything
going
on,
the
rst
line
of
the
b
o
dy
is
a
message.
The
next
line
 on
tains
a
save-ex ursion
that
returns
Ema s'
atten
tion
to
the
 urren
t
buer
when
the
fun tion
 ompletes.
This
is
useful
in
 ase
y
ou
em
b
ed
this
fun tion
in
another
fun tion
that
presumes
p
oin
t
is
restored
to
the
original
buer.
In
the
v
arlist
of
the
let
expression,
Ema s
nds
the
le
and
binds
the
lo
 al
v
ariable
buffer
to
the
buer
 on
taining
the
le.
A
t
the
same
time,
Ema s
 reates
lengths-list
as
a
lo
 al
v
ariable.
Next,
Ema s
swit 
hes
its
atten
tion
to
the
buer.
In
the
follo
wing
line,
Ema s
mak
es
the
buer
read-only
.
Ideally
,
this
line
is
not
ne essary
.
None
of
the
fun tions
for
 oun
ting
w
ords
and
sym
b
ols
in
a
fun tion
denition
should
 
hange
the
buer.
Besides,
the
buer
is
not
going
to
b
e
sa
v
ed,
ev
en
if
it
w
ere
 
hanged.
This
line
is
en
tirely
the
 onsequen e
of
great,
p
erhaps
ex essiv
e,
 aution.
The
reason
for
the
 aution
is
that
this
fun tion
and
those
it
 alls
w
ork
on
the
sour es
for
Ema s
and
it
is
v
ery

lengths-list-file
in
Detail
189
in on
v
enien
t
if
they
are
inadv
erten
tly
mo
died.
It
go
es
without
sa
ying
that
I
did
not
realize
a
need
for
this
line
un
til
an
exp
erimen
t
w
en
t
a
wry
and
started
to
mo
dify
m
y
Ema s
sour e
les
.
.
.
Next
 omes
a
 all
to
widen
the
buer
if
it
is
narro
w
ed.
This
fun tion
is
usually
not
needed|Ema s
 reates
a
fresh
buer
if
none
already
exists;
but
if
a
buer
visiting
the
le
already
exists
Ema s
returns
that
one.
In
this
 ase,
the
buer
ma
y
b
e
narro
w
ed
and
m
ust
b
e
widened.
If
w
e
w
an
ted
to
b
e
fully
`user-friendly',
w
e
w
ould
arrange
to
sa
v
e
the
restri tion
and
the
lo
 ation
of
p
oin
t,
but
w
e
w
on't.
The
(goto- har
(point-min))
expression
mo
v
es
p
oin
t
to
the
b
eginning
of
the
buer.
Then
 omes
a
while
lo
op
in
whi 
h
the
`w
ork'
of
the
fun tion
is
 arried
out.
In
the
lo
op,
Ema s
determines
the
length
of
ea 
h
denition
and
 onstru ts
a
lengths'
list
 on
taining
the
information.
Ema s
kills
the
buer
after
w
orking
through
it.
This
is
to
sa
v
e
spa e
inside
of
Ema s.
My
v
ersion
of
Ema s
19
 on
tained
o
v
er
300
sour e
les
of
in
terest;
Ema s
21
 on
tains
o
v
er
800
sour e
les.
Another
fun tion
will
apply
lengths-list-file
to
ea 
h
of
the
les.
Finally
,
the
last
expression
within
the
let
expression
is
the
lengths-list
v
ariable;
its
v
alue
is
returned
as
the
v
alue
of
the
whole
fun tion.
Y
ou
 an
try
this
fun tion
b
y
installing
it
in
the
usual
fashion.
Then
pla e
y
our
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e
(eval-last-
sexp).
(lengths-list-file
"/usr/lo al/share/ema s/21.0
.100
/lisp
/ema
 s-li
sp/d
ebug
.el")
(Y
ou
ma
y
need
to
 
hange
the
pathname
of
the
le;
the
one
here
w
ork
ed
with
GNU
Ema s
v
ersion
21.0.100.
T
o
 
hange
the
expression,
 op
y
it
to
the
`*s rat h*'
buer
and
edit
it.
(Also,
to
see
the
full
length
of
the
list,
rather
than
a
trun ated
v
ersion,
y
ou
ma
y
ha
v
e
to
ev
aluate
the
follo
wing:
( ustom-set-variables
'(eval-expression-print-lengt
h
nil))
(See
Se tion
16.2,
\Setting
V
ariables
with
def ustom",
page
214.
Then
ev
aluate
the
lengths-list-file
expression.)

190
Chapter
14:
Coun
ting
W
ords
in
a
defun
The
lengths'
list
for
`debug.el'
tak
es
less
than
a
se ond
to
pro
du e
and
lo
oks
lik
e
this:
(77
95
85
87
131
89
50
25
44
44
68
35
64
45
17
34
167
457)
(Using
m
y
old
ma 
hine,
the
v
ersion
19
lengths'
list
for
`debug.el'
to
ok
sev
en
se onds
to
pro
du e
and
lo
ok
ed
lik
e
this:
(75
41
80
62
20
45
44
68
45
12
34
235)
(The
new
er
v
ersion
of
`debug.el'
 on
tains
more
defuns
than
the
earlier
one;
and
m
y
new
ma 
hine
is
m
u 
h
faster
than
the
old
one.)
Note
that
the
length
of
the
last
denition
in
the
le
is
rst
in
the
list.
14.7
Coun
t
W
ords
in
defuns
in
Dieren
t
Files
In
the
previous
se tion,
w
e
 reated
a
fun tion
that
returns
a
list
of
the
lengths
of
ea 
h
denition
in
a
le.
No
w,
w
e
w
an
t
to
dene
a
fun tion
to
return
a
master
list
of
the
lengths
of
the
denitions
in
a
list
of
les.
W
orking
on
ea 
h
of
a
list
of
les
is
a
rep
etitious
a t,
so
w
e
 an
use
either
a
while
lo
op
or
re ursion.
The
design
using
a
while
lo
op
is
routine.
The
argumen
t
passed
the
fun -
tion
is
a
list
of
les.
As
w
e
sa
w
earlier
(see
Se tion
11.1.1,
\Lo
op
Example",
page
122),
y
ou
 an
write
a
while
lo
op
so
that
the
b
o
dy
of
the
lo
op
is
ev
alu-
ated
if
su 
h
a
list
 on
tains
elemen
ts,
but
to
exit
the
lo
op
if
the
list
is
empt
y
.
F
or
this
design
to
w
ork,
the
b
o
dy
of
the
lo
op
m
ust
 on
tain
an
expression
that
shortens
the
list
ea 
h
time
the
b
o
dy
is
ev
aluated,
so
that
ev
en
tually
the
list
is
empt
y
.
The
usual
te 
hnique
is
to
set
the
v
alue
of
the
list
to
the
v
alue
of
the
 dr
of
the
list
ea 
h
time
the
b
o
dy
is
ev
aluated.
The
template
lo
oks
lik
e
this:
(while
test-whether-list-is-empt
y
b
o
dy
...
set-list-to- dr-of-list
)
Also,
w
e
remem
b
er
that
a
while
lo
op
returns
nil
(the
result
of
ev
aluat-
ing
the
true-or-false-test),
not
the
result
of
an
y
ev
aluation
within
its
b
o
dy
.
(The
ev
aluations
within
the
b
o
dy
of
the
lo
op
are
done
for
their
side
ee ts.)
Ho
w
ev
er,
the
expression
that
sets
the
lengths'
list
is
part
of
the
b
o
dy|and
that
is
the
v
alue
that
w
e
w
an
t
returned
b
y
the
fun tion
as
a
whole.
T
o
do
this,
w
e
en lose
the
while
lo
op
within
a
let
expression,
and
arrange
that
the
last
elemen
t
of
the
let
expression
 on
tains
the
v
alue
of
the
lengths'
list.
(See
\Lo
op
Example
with
an
In remen
ting
Coun
ter",
page
125.)

The
append
F
un tion
191
These
 onsiderations
lead
us
dire tly
to
the
fun tion
itself:
;;;
Use
while
lo
op.
(defun
lengths-list-many-files
(list-of-files)
"Return
list
of
lengths
of
defuns
in
LIST-OF-FILES."
(let
(lengths-list)
;;;
true-or-false-test
(while
list-of-files
(setq
lengths-list
(append
lengths-list
;;;
Generate
a
lengths'
list.
(lengths-list-file
(expand-file-name
( ar
list-of-files)))))
;;;
Mak
e
les'
list
shorter.
(setq
list-of-files
( dr
list-of-files)))
;;;
Return
nal
v
alue
of
lengths'
list.
lengths-list))
expand-file-name
is
a
built-in
fun tion
that
 on
v
erts
a
le
name
to
the
absolute,
long,
path
name
form
of
the
dire tory
in
whi 
h
the
fun tion
is
 alled.
Th
us,
if
expand-file-name
is
 alled
on
debug.el
when
Ema s
is
visiting
the
`/usr/lo al/share/ema s/2
1.0
.100
/lis
p/e
ma s
-lis
p/'
dire tory
,
debug.el
b
e omes
/usr/lo al/share/ema s/21.0.1
00/l
isp/e
ma s
-lisp
/deb
ug.e
l
The
only
other
new
elemen
t
of
this
fun tion
denition
is
the
as
y
et
un-
studied
fun tion
append,
whi 
h
merits
a
short
se tion
for
itself.
14.7.1
The
append
F
un tion
The
append
fun tion
atta 
hes
one
list
to
another.
Th
us,
(append
'(1
2
3
4)
'(5
6
7
8))
pro
du es
the
list
(1
2
3
4
5
6
7
8)
This
is
exa tly
ho
w
w
e
w
an
t
to
atta 
h
t
w
o
lengths'
lists
pro
du ed
b
y
lengths-list-file
to
ea 
h
other.
The
results
 on
trast
with
 ons,
( ons
'(1
2
3
4)
'(5
6
7
8))

192
Chapter
14:
Coun
ting
W
ords
in
a
defun
whi 
h
 onstru ts
a
new
list
in
whi 
h
the
rst
argumen
t
to
 ons
b
e omes
the
rst
elemen
t
of
the
new
list:
((1
2
3
4)
5
6
7
8)
14.8
Re ursiv
ely
Coun
t
W
ords
in
Dieren
t
Files
Besides
a
while
lo
op,
y
ou
 an
w
ork
on
ea 
h
of
a
list
of
les
with
re ursion.
A
re ursiv
e
v
ersion
of
lengths-list-many-files
is
short
and
simple.
The
re ursiv
e
fun tion
has
the
usual
parts:
the
`do-again-test',
the
`next-
step-expression',
and
the
re ursiv
e
 all.
The
`do-again-test'
determines
whether
the
fun tion
should
 all
itself
again,
whi 
h
it
will
do
if
the
list-
of-files
 on
tains
an
y
remaining
elemen
ts;
the
`next-step-expression'
resets
the
list-of-files
to
the
 dr
of
itself,
so
ev
en
tually
the
list
will
b
e
empt
y;
and
the
re ursiv
e
 all
 alls
itself
on
the
shorter
list.
The
 omplete
fun tion
is
shorter
than
this
des ription!
(defun
re ursive-lengths-list-many-fil
es
(list-of-files)
"Return
list
of
lengths
of
ea h
defun
in
LIST-OF-FILES."
(if
list-of-files
;
do-again-test
(append
(lengths-list-file
(expand-file-name
( ar
list-of-files)))
(re ursive-lengths-list-many-fi
les
( dr
list-of-files)))))
In
a
sen
ten e,
the
fun tion
returns
the
lengths'
list
for
the
rst
of
the
list-
of-files
app
ended
to
the
result
of
 alling
itself
on
the
rest
of
the
list-
of-files.
Here
is
a
test
of
re ursive-lengths-list-ma
ny-f
ile
s,
along
with
the
results
of
running
lengths-list-file
on
ea 
h
of
the
les
individually
.
Install
re ursive-lengths-list-man
y-f
iles
and
lengths-list-file,
if
ne essary
,
and
then
ev
aluate
the
follo
wing
expressions.
Y
ou
ma
y
need
to
 
hange
the
les'
pathnames;
those
here
w
ork
when
this
Info
le
and
the
Ema s
sour es
are
lo
 ated
in
their
 ustomary
pla es.
T
o
 
hange
the
expres-
sions,
 op
y
them
to
the
`*s rat h*'
buer,
edit
them,
and
then
ev
aluate
them.
The
results
are
sho
wn
after
the
`
)
'.
(These
results
are
for
les
from
Ema s
V
ersion
21.0.100;
les
from
other
v
ersions
of
Ema s
ma
y
pro
du e
dieren
t
results.)
( d
"/usr/lo al/share/ema s/21.0.
100/"
)
(lengths-list-file
"./lisp/ma ros.el")
)
(273
263
456
90)
(lengths-list-file
"./lisp/mail/mailalias.el")
)
(38
32
26
77
174
180
321
198
324)

Sorting
Lists
193
(lengths-list-file
"./lisp/makesum.el")
)
(85
181)
(re ursive-lengths-list-many-
file
s
'("./lisp/ma ros.el"
"./lisp/mail/mailalias.el"
"./lisp/makesum.el"))
)
(273
263
456
90
38
32
26
77
174
180
321
198
324
85
181)
The
re ursive-lengths-list-m
any
-fil
es
fun tion
pro
du es
the
out-
put
w
e
w
an
t.
The
next
step
is
to
prepare
the
data
in
the
list
for
displa
y
in
a
graph.
14.9
Prepare
the
Data
for
Displa
y
in
a
Graph
The
re ursive-lengths-list-ma
ny-
file
s
fun tion
returns
a
list
of
n
um
b
ers.
Ea 
h
n
um
b
er
re ords
the
length
of
a
fun tion
denition.
What
w
e
need
to
do
no
w
is
transform
this
data
in
to
a
list
of
n
um
b
ers
suitable
for
generating
a
graph.
The
new
list
will
tell
ho
w
man
y
fun tions
denitions
 on
tain
less
than
10
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain
b
et
w
een
10
and
19
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain
b
et
w
een
20
and
29
w
ords
and
sym
b
ols,
and
so
on.
In
brief,
w
e
need
to
go
through
the
lengths'
list
pro
du ed
b
y
the
re ursive-lengths-list-m
any-
file
s
fun tion
and
 oun
t
the
n
um
b
er
of
defuns
within
ea 
h
range
of
lengths,
and
pro
du e
a
list
of
those
n
um
b
ers.
Based
on
what
w
e
ha
v
e
done
b
efore,
w
e
 an
readily
foresee
that
it
should
not
b
e
to
o
hard
to
write
a
fun tion
that
` drs'
do
wn
the
lengths'
list,
lo
oks
at
ea 
h
elemen
t,
determines
whi 
h
length
range
it
is
in,
and
in remen
ts
a
 oun
ter
for
that
range.
Ho
w
ev
er,
b
efore
b
eginning
to
write
su 
h
a
fun tion,
w
e
should
 onsider
the
adv
an
tages
of
sorting
the
lengths'
list
rst,
so
the
n
um
b
ers
are
ordered
from
smallest
to
largest.
First,
sorting
will
mak
e
it
easier
to
 oun
t
the
n
um
b
ers
in
ea 
h
range,
sin e
t
w
o
adja en
t
n
um
b
ers
will
either
b
e
in
the
same
length
range
or
in
adja en
t
ranges.
Se ond,
b
y
insp
e ting
a
sorted
list,
w
e
 an
dis o
v
er
the
highest
and
lo
w
est
n
um
b
er,
and
thereb
y
determine
the
largest
and
smallest
length
range
that
w
e
will
need.
14.9.1
Sorting
Lists
Ema s
 on
tains
a
fun tion
to
sort
lists,
 alled
(as
y
ou
migh
t
guess)
sort.
The
sort
fun tion
tak
es
t
w
o
argumen
ts,
the
list
to
b
e
sorted,
and
a
predi ate
that
determines
whether
the
rst
of
t
w
o
list
elemen
ts
is
\less"
than
the
se ond.
As
w
e
sa
w
earlier
(see
Se tion
1.8.4,
\Using
the
W
rong
T
yp
e
Ob
je t
as
an
Argumen
t",
page
14),
a
predi ate
is
a
fun tion
that
determines
whether

194
Chapter
14:
Coun
ting
W
ords
in
a
defun
some
prop
ert
y
is
true
or
false.
The
sort
fun tion
will
reorder
a
list
a  ord-
ing
to
whatev
er
prop
ert
y
the
predi ate
uses;
this
means
that
sort
 an
b
e
used
to
sort
non-n
umeri 
lists
b
y
non-n
umeri 
 riteria|it
 an,
for
example,
alphab
etize
a
list.
The
<
fun tion
is
used
when
sorting
a
n
umeri 
list.
F
or
example,
(sort
'(4
8
21
17
33
7
21
7)
'<)
pro
du es
this:
(4
7
7
8
17
21
21
33)
(Note
that
in
this
example,
b
oth
the
argumen
ts
are
quoted
so
that
the
sym
b
ols
are
not
ev
aluated
b
efore
b
eing
passed
to
sort
as
argumen
ts.)
Sorting
the
list
returned
b
y
the
re ursive-lengths-list-m
any-
file
s
fun tion
is
straigh
tforw
ard;
it
uses
the
<
fun tion:
(sort
(re ursive-lengths-list-many
-fil
es
'("../lisp/ma ros.el"
"../lisp/mailalias.el"
"../lisp/makesum.el"))
'<
whi 
h
pro
du es:
(85
86
116
122
154
176
179
265)
(Note
that
in
this
example,
the
rst
argumen
t
to
sort
is
not
quoted,
sin e
the
expression
m
ust
b
e
ev
aluated
so
as
to
pro
du e
the
list
that
is
passed
to
sort.)
14.9.2
Making
a
List
of
Files
The
re ursive-lengths-list-man
y-fi
les
fun tion
requires
a
list
of
les
as
its
argumen
t.
F
or
our
test
examples,
w
e
 onstru ted
su 
h
a
list
b
y
hand;
but
the
Ema s
Lisp
sour e
dire tory
is
to
o
large
for
us
to
do
for
that.
Instead,
w
e
will
write
a
fun tion
to
do
the
job
for
us.
In
this
fun tion,
w
e
will
use
b
oth
a
while
lo
op
and
a
re ursiv
e
 all.
W
e
did
not
ha
v
e
to
write
a
fun tion
lik
e
this
for
older
v
ersions
of
GNU
Ema s,
sin e
they
pla ed
all
the
`.el'
les
in
one
dire tory
.
Instead,
w
e
w
ere
able
to
use
the
dire tory-files
fun tion,
whi 
h
lists
the
names
of
les
that
mat 
h
a
sp
e ied
pattern
within
a
single
dire tory
.
Ho
w
ev
er,
re en
t
v
ersions
of
Ema s
pla e
Ema s
Lisp
les
in
sub-
dire tories
of
the
top
lev
el
`lisp'
dire tory
.
This
re-arrangemen
t
eases
na
vigation.
F
or
example,
all
the
mail
related
les
are
in
a
`lisp'
sub-dire tory
 alled
`mail'.
But
at
the
same
time,
this
arrangemen
t
for es
us
to
 reate
a
le
listing
fun tion
that
des ends
in
to
the
sub-dire tories.
W
e
 an
 reate
this
fun tion,
 alled
files-in-below-dire tory,
using
familiar
fun tions
su 
h
as
 ar,
nth dr,
and
substring
in
 onjun tion
with
an
existing
fun tion
 alled
dire tory-files-and-attr
ibut
es.
This
latter

Making
a
List
of
Files
195
fun tion
not
only
lists
all
the
lenames
in
a
dire tory
,
in luding
the
names
of
sub-dire tories,
but
also
their
attributes.
T
o
restate
our
goal:
to
 reate
a
fun tion
that
will
enable
us
to
feed
lenames
to
re ursive-lengths-list-man
y-fi
les
as
a
list
that
lo
oks
lik
e
this
(but
with
more
elemen
ts):
("../lisp/ma ros.el"
"../lisp/mail/rmail.el"
"../lisp/makesum.el")
The
dire tory-files-and-attrib
ute
s
fun tion
returns
a
list
of
lists.
Ea 
h
of
the
lists
within
the
main
list
 onsists
of
13
elemen
ts.
The
rst
elemen
t
is
a
string
that
 on
tains
the
name
of
the
le
{
whi 
h,
in
GNU/Lin
ux,
ma
y
b
e
a
`dire tory
le',
that
is
to
sa
y
,
a
le
with
the
sp
e ial
attributes
of
a
dire tory
.
The
se ond
elemen
t
of
the
list
is
t
for
a
dire tory
,
a
string
for
sym
b
oli 
link
(the
string
is
the
name
link
ed
to),
or
nil.
F
or
example,
the
rst
`.el'
le
in
the
`lisp/'
dire tory
is
`abbrev.el'.
Its
name
is
`/usr/lo al/share/ema s/21.
0.1
00/l
isp/
abb
rev.
el'
and
it
is
not
a
dire tory
or
a
sym
b
oli 
link.
This
is
ho
w
dire tory-files-and-attri
but
es
lists
that
le
and
its
attributes:
("/usr/lo al/share/ema s/21.0
.100
/lisp
/abb
rev.e
l"
nil
1
1000
100
(15019
32380)
(14883
48041)
(15214
49336)
11583
"-rw-rw-r--"
t
341385
776)
On
the
other
hand,
`mail/'
is
a
dire tory
within
the
`lisp/'
dire tory
.
The
b
eginning
of
its
listing
lo
oks
lik
e
this:
("/usr/lo al/share/ema s/21.0
.100
/lisp
/mai
l"
t
...
)
(Lo
ok
at
the
do
 umen
tation
of
file-attributes
to
learn
ab
out
the
dif-
feren
t
attributes.
Bear
in
mind
that
the
file-attributes
fun tion
do
es
not
list
the
lename,
so
its
rst
elemen
t
is
dire tory-files-and-attri
but
es's
se ond
elemen
t.)

196
Chapter
14:
Coun
ting
W
ords
in
a
defun
W
e
will
w
an
t
our
new
fun tion,
files-in-below-dire tory,
to
list
the
`.el'
les
in
the
dire tory
it
is
told
to
 
he 
k,
and
in
an
y
dire tories
b
elo
w
that
dire tory
.
This
giv
es
us
a
hin
t
on
ho
w
to
 onstru t
files-in-below-dire tory:
within
a
dire tory
,
the
fun tion
should
add
`.el'
lenames
to
a
list;
and
if,
within
a
dire tory
,
the
fun tion
 omes
up
on
a
sub-dire tory
,
it
should
go
in
to
that
sub-dire tory
and
rep
eat
its
a tions.
Ho
w
ev
er,
w
e
should
note
that
ev
ery
dire tory
 on
tains
a
name
that
refers
to
itself,
 alled
`.',
(\dot")
and
a
name
that
refers
to
its
paren
t
dire tory
,
 alled
`..'
(\double
dot").
(In
`/',
the
ro
ot
dire tory
,
`..'
refers
to
itself,
sin e
`/'
has
no
paren
t.)
Clearly
,
w
e
do
not
w
an
t
our
files-in-below-
dire tory
fun tion
to
en
ter
those
dire tories,
sin e
they
alw
a
ys
lead
us,
dire tly
or
indire tly
,
to
the
 urren
t
dire tory
.
Consequen
tly
,
our
files-in-below-dire tor
y
fun tion
m
ust
do
sev
eral
tasks:

Che 
k
to
see
whether
it
is
lo
oking
at
a
lename
that
ends
in
`.el';
and
if
so,
add
its
name
to
a
list.

Che 
k
to
see
whether
it
is
lo
oking
at
a
lename
that
is
the
name
of
a
dire tory;
and
if
so,
 Che 
k
to
see
whether
it
is
lo
oking
at
`.'
or
`..';
and
if
so
skip
it.
 Or
else,
go
in
to
that
dire tory
and
rep
eat
the
pro
 ess.
Let's
write
a
fun tion
denition
to
do
these
tasks.
W
e
will
use
a
while
lo
op
to
mo
v
e
from
one
lename
to
another
within
a
dire tory
,
 
he 
king
what
needs
to
b
e
done;
and
w
e
will
use
a
re ursiv
e
 all
to
rep
eat
the
a tions
on
ea 
h
sub-dire tory
.
The
re ursiv
e
pattern
is
`a  um
ulate'
(see
\Re ursiv
e
P
attern:
a 
 umulate
",
page
142),
using
append
as
the
 om
biner.
Here
is
the
fun tion:
(defun
files-in-below-dire tory
(dire tory)
"List
the
.el
files
in
DIRECTORY
and
in
its
sub-dire tories."
;;
Although
the
fun tion
will
be
used
non-intera tively,
;;
it
will
be
easier
to
test
if
we
make
it
intera tive.
;;
The
dire tory
will
have
a
name
su h
as
;;
"/usr/lo al/share/ema s/21.
0.100
/lis
p/"
(intera tive
"DDire tory
name:
")
(let
(el-files-list
( urrent-dire tory-list
(dire tory-files-and-attribut
es
dire tory
t)))
;;
while
we
are
in
the
 urrent
dire tory
(while
 urrent-dire tory-list

Coun
ting
fun tion
denitions
197
( ond
;;
 he k
to
see
whether
filename
ends
in
`.el'
;;
and
if
so,
append
its
name
to
a
list.
((equal
".el"
(substring
( ar
( ar
 urrent-dire tory-list))
-3))
(setq
el-files-list
( ons
( ar
( ar
 urrent-dire tory-list))
el-files-list)))
;;
 he k
whether
filename
is
that
of
a
dire tory
((eq
t
( ar
( dr
( ar
 urrent-dire tory-list))))
;;
de ide
whether
to
skip
or
re urse
(if
(equal
(or
"."
"..")
(substring
( ar
( ar
 urrent-dire tory-list))
-1))
;;
then
do
nothing
if
filename
is
that
of
;;
 urrent
dire tory
or
parent
()
;;
else
des end
into
the
dire tory
and
repeat
the
pro ess
(setq
el-files-list
(append
(files-in-below-dire tory
( ar
( ar
 urrent-dire tory-list)))
el-files-list)))))
;;
move
to
the
next
filename
in
the
list;
this
also
;;
shortens
the
list
so
the
while
loop
eventually
 omes
to
an
end
(setq
 urrent-dire tory-list
( dr
 urrent-dire tory-list)))
;;
return
the
filenames
el-files-list))
The
files-in-below-dire tor
y
dire tory-files
fun tion
tak
es
one
argumen
t,
the
name
of
a
dire tory
.
Th
us,
on
m
y
system,
(length
(files-in-below-dire tory
"/usr/lo al/share/ema s/21.0
.100/
lisp
/"))
tells
me
that
m
y
v
ersion
21.0.100
Lisp
sour es
dire tory
 on
tains
754
`.el'
les.
files-in-below-dire tor
y
returns
a
list
in
rev
erse
alphab
eti al
order.
An
expression
to
sort
the
list
in
alphab
eti al
order
lo
oks
lik
e
this:
(sort
(files-in-below-dire tory
"/usr/lo al/share/ema s/21.0
.100/
lisp
/")
'string-lessp)
14.9.3
Coun
ting
fun tion
denitions
Our
immediate
goal
is
to
generate
a
list
that
tells
us
ho
w
man
y
fun tion
denitions
 on
tain
few
er
than
10
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain

198
Chapter
14:
Coun
ting
W
ords
in
a
defun
b
et
w
een
10
and
19
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain
b
et
w
een
20
and
29
w
ords
and
sym
b
ols,
and
so
on.
With
a
sorted
list
of
n
um
b
ers,
this
is
easy:
 oun
t
ho
w
man
y
elemen
ts
of
the
list
are
smaller
than
10,
then,
after
mo
ving
past
the
n
um
b
ers
just
 oun
ted,
 oun
t
ho
w
man
y
are
smaller
than
20,
then,
after
mo
ving
past
the
n
um
b
ers
just
 oun
ted,
 oun
t
ho
w
man
y
are
smaller
than
30,
and
so
on.
Ea 
h
of
the
n
um
b
ers,
10,
20,
30,
40,
and
the
lik
e,
is
one
larger
than
the
top
of
that
range.
W
e
 an
 all
the
list
of
su 
h
n
um
b
ers
the
top-of-ranges
list.
If
w
e
wished,
w
e
 ould
generate
this
list
automati ally
,
but
it
is
simpler
to
write
a
list
man
ually
.
Here
it
is:
(defvar
top-of-ranges
'(10
20
30
40
50
60
70
80
90
100
110
120
130
140
150
160
170
180
190
200
210
220
230
240
250
260
270
280
290
300)
"List
spe ifying
ranges
for
`defuns-per-range'.")
T
o
 
hange
the
ranges,
w
e
edit
this
list.
Next,
w
e
need
to
write
the
fun tion
that
 reates
the
list
of
the
n
um
b
er
of
denitions
within
ea 
h
range.
Clearly
,
this
fun tion
m
ust
tak
e
the
sorted-
lengths
and
the
top-of-ranges
lists
as
argumen
ts.
The
defuns-per-range
fun tion
m
ust
do
t
w
o
things
again
and
again:
it
m
ust
 oun
t
the
n
um
b
er
of
denitions
within
a
range
sp
e ied
b
y
the
 urren
t
top-of-range
v
alue;
and
it
m
ust
shift
to
the
next
higher
v
alue
in
the
top-
of-ranges
list
after
 oun
ting
the
n
um
b
er
of
denitions
in
the
 urren
t
range.
Sin e
ea 
h
of
these
a tions
is
rep
etitiv
e,
w
e
 an
use
while
lo
ops
for
the
job.
One
lo
op
 oun
ts
the
n
um
b
er
of
denitions
in
the
range
dened
b
y
the
 urren
t
top-of-range
v
alue,
and
the
other
lo
op
sele ts
ea 
h
of
the
top-of-range
v
alues
in
turn.
Sev
eral
en
tries
of
the
sorted-lengths
list
are
 oun
ted
for
ea 
h
range;
this
means
that
the
lo
op
for
the
sorted-lengths
list
will
b
e
inside
the
lo
op
for
the
top-of-ranges
list,
lik
e
a
small
gear
inside
a
big
gear.
The
inner
lo
op
 oun
ts
the
n
um
b
er
of
denitions
within
the
range.
It
is
a
simple
 oun
ting
lo
op
of
the
t
yp
e
w
e
ha
v
e
seen
b
efore.
(See
Se tion
11.1.3,
\A
lo
op
with
an
in remen
ting
 oun
ter",
page
124.)
The
true-or-false
test
of
the
lo
op
tests
whether
the
v
alue
from
the
sorted-lengths
list
is
smaller
than
the
 urren
t
v
alue
of
the
top
of
the
range.
If
it
is,
the
fun tion
in remen
ts
the
 oun
ter
and
tests
the
next
v
alue
from
the
sorted-lengths
list.

Coun
ting
fun tion
denitions
199
The
inner
lo
op
lo
oks
lik
e
this:
(while
length-elemen
t-smaller-than-top-of-range
(setq
number-within-range
(1+
number-within-range))
(setq
sorted-lengths
( dr
sorted-lengths)))
The
outer
lo
op
m
ust
start
with
the
lo
w
est
v
alue
of
the
top-of-ranges
list,
and
then
b
e
set
to
ea 
h
of
the
su  eeding
higher
v
alues
in
turn.
This
 an
b
e
done
with
a
lo
op
lik
e
this:
(while
top-of-ranges
b
o
dy-of-lo
op
...
(setq
top-of-ranges
( dr
top-of-ranges)))
Put
together,
the
t
w
o
lo
ops
lo
ok
lik
e
this:
(while
top-of-ranges
;;
Coun
t
the
n
um
b
er
of
elemen
ts
within
the
 urren
t
range.
(while
length-elemen
t-smaller-than-top-of-range
(setq
number-within-range
(1+
number-within-range))
(setq
sorted-lengths
( dr
sorted-lengths)))
;;
Mo
v
e
to
next
range.
(setq
top-of-ranges
( dr
top-of-ranges)))
In
addition,
in
ea 
h
 ir uit
of
the
outer
lo
op,
Ema s
should
re ord
the
n
um
b
er
of
denitions
within
that
range
(the
v
alue
of
number-within-range)
in
a
list.
W
e
 an
use
 ons
for
this
purp
ose.
(See
Se tion
7.2,
\ ons",
page
83.)
The
 ons
fun tion
w
orks
ne,
ex ept
that
the
list
it
 onstru ts
will
 on-
tain
the
n
um
b
er
of
denitions
for
the
highest
range
at
its
b
eginning
and
the
n
um
b
er
of
denitions
for
the
lo
w
est
range
at
its
end.
This
is
b
e ause
 ons
atta 
hes
new
elemen
ts
of
the
list
to
the
b
eginning
of
the
list,
and
sin e
the
t
w
o
lo
ops
are
w
orking
their
w
a
y
through
the
lengths'
list
from
the
lo
w
er
end
rst,
the
defuns-per-range-list
will
end
up
largest
n
um
b
er
rst.
But
w
e
will
w
an
t
to
prin
t
our
graph
with
smallest
v
alues
rst
and
the
larger
later.
The
solution
is
to
rev
erse
the
order
of
the
defuns-per-range-list.
W
e
 an
do
this
using
the
nreverse
fun tion,
whi 
h
rev
erses
the
order
of
a
list.
F
or
example,
(nreverse
'(1
2
3
4))
pro
du es:
(4
3
2
1)
Note
that
the
nreverse
fun tion
is
\destru tiv
e"|that
is,
it
 
hanges
the
list
to
whi 
h
it
is
applied;
this
 on
trasts
with
the
 ar
and
 dr
fun tions,
whi 
h
are
non-destru tiv
e.
In
this
 ase,
w
e
do
not
w
an
t
the
original
defuns-
per-range-list,
so
it
do
es
not
matter
that
it
is
destro
y
ed.
(The
reverse
fun tion
pro
vides
a
rev
ersed
 op
y
of
a
list,
lea
ving
the
original
list
as
is.)

200
Chapter
14:
Coun
ting
W
ords
in
a
defun
Put
all
together,
the
defuns-per-range
lo
oks
lik
e
this:
(defun
defuns-per-range
(sorted-lengths
top-of-ranges)
"SORTED-LENGTHS
defuns
in
ea h
TOP-OF-RANGES
range."
(let
((top-of-range
( ar
top-of-ranges))
(number-within-range
0)
defuns-per-range-list)
;;
Outer
lo
op.
(while
top-of-ranges
;;
Inner
lo
op.
(while
(and
;;
Need
n
um
b
er
for
n
umeri 
test.
( ar
sorted-lengths)
(<
( ar
sorted-lengths)
top-of-range))
;;
Coun
t
n
um
b
er
of
denitions
within
 urren
t
range.
(setq
number-within-range
(1+
number-within-range))
(setq
sorted-lengths
( dr
sorted-lengths)))
;;
Exit
inner
lo
op
but
remain
within
outer
lo
op.
(setq
defuns-per-range-list
( ons
number-within-range
defuns-per-range-list))
(setq
number-within-range
0)
;
Reset
 oun
t
to
zero.
;;
Mo
v
e
to
next
range.
(setq
top-of-ranges
( dr
top-of-ranges))
;;
Sp
e ify
next
top
of
range
v
alue.
(setq
top-of-range
( ar
top-of-ranges)))
;;
Exit
outer
lo
op
and
 oun
t
the
n
um
b
er
of
defuns
larger
than
;;
the
largest
top-of-range
v
alue.
(setq
defuns-per-range-list
( ons
(length
sorted-lengths)
defuns-per-range-list))
;;
Return
a
list
of
the
n
um
b
er
of
denitions
within
ea 
h
range,
;;
smallest
to
largest.
(nreverse
defuns-per-range-list)))

Coun
ting
fun tion
denitions
201
The
fun tion
is
straigh
tforw
ard
ex ept
for
one
subtle
feature.
The
true-or-
false
test
of
the
inner
lo
op
lo
oks
lik
e
this:
(and
( ar
sorted-lengths)
(<
( ar
sorted-lengths)
top-of-range))
instead
of
lik
e
this:
(<
( ar
sorted-lengths)
top-of-range)
The
purp
ose
of
the
test
is
to
determine
whether
the
rst
item
in
the
sorted-lengths
list
is
less
than
the
v
alue
of
the
top
of
the
range.
The
simple
v
ersion
of
the
test
w
orks
ne
unless
the
sorted-lengths
list
has
a
nil
v
alue.
In
that
 ase,
the
( ar
sorted-lengths)
expression
fun tion
returns
nil.
The
<
fun tion
 annot
 ompare
a
n
um
b
er
to
nil,
whi 
h
is
an
empt
y
list,
so
Ema s
signals
an
error
and
stops
the
fun tion
from
attempting
to
 on
tin
ue
to
exe ute.
The
sorted-lengths
list
alw
a
ys
b
e omes
nil
when
the
 oun
ter
rea 
hes
the
end
of
the
list.
This
means
that
an
y
attempt
to
use
the
defuns-per-
range
fun tion
with
the
simple
v
ersion
of
the
test
will
fail.
W
e
solv
e
the
problem
b
y
using
the
( ar
sorted-lengths)
expression
in
 onjun tion
with
the
and
expression.
The
( ar
sorted-lengths)
expres-
sion
returns
a
non-nil
v
alue
so
long
as
the
list
has
at
least
one
n
um
b
er
within
it,
but
returns
nil
if
the
list
is
empt
y
.
The
and
expression
rst
ev
aluates
the
( ar
sorted-lengths)
expression,
and
if
it
is
nil,
returns
false
without
ev
aluating
the
<
expression.
But
if
the
( ar
sorted-lengths)
expression
returns
a
non-nil
v
alue,
the
and
expression
ev
aluates
the
<
expression,
and
returns
that
v
alue
as
the
v
alue
of
the
and
expression.
This
w
a
y
,
w
e
a
v
oid
an
error.
See
Se tion
12.4,
\forward-paragraph:
a
Goldmine
of
F
un tions",
page
155,
for
more
information
ab
out
and.
Here
is
a
short
test
of
the
defuns-per-range
fun tion.
First,
ev
aluate
the
expression
that
binds
(a
shortened)
top-of-ranges
list
to
the
list
of
v
alues,
then
ev
aluate
the
expression
for
binding
the
sorted-lengths
list,
and
then
ev
aluate
the
defuns-per-range
fun tion.
;;
(Shorter
list
than
w
e
will
use
later.)
(setq
top-of-ranges
'(110
120
130
140
150
160
170
180
190
200))
(setq
sorted-lengths
'(85
86
110
116
122
129
154
176
179
200
265
300
300))
(defuns-per-range
sorted-lengths
top-of-ranges)

202
Chapter
14:
Coun
ting
W
ords
in
a
defun
The
list
returned
lo
oks
lik
e
this:
(2
2
2
0
0
1
0
2
0
0
4)
Indeed,
there
are
t
w
o
elemen
ts
of
the
sorted-lengths
list
smaller
than
110,
t
w
o
elemen
ts
b
et
w
een
110
and
119,
t
w
o
elemen
ts
b
et
w
een
120
and
129,
and
so
on.
There
are
four
elemen
ts
with
a
v
alue
of
200
or
larger.

Readying
a
Graph
203
15
Readying
a
Graph
Our
goal
is
to
 onstru t
a
graph
sho
wing
the
n
um
b
ers
of
fun tion
deni-
tions
of
v
arious
lengths
in
the
Ema s
lisp
sour es.
As
a
pra ti al
matter,
if
y
ou
w
ere
 reating
a
graph,
y
ou
w
ould
probably
use
a
program
su 
h
as
gnuplot
to
do
the
job.
(gnuplot
is
ni ely
in
tegrated
in
to
GNU
Ema s.)
In
this
 ase,
ho
w
ev
er,
w
e
 reate
one
from
s rat 
h,
and
in
the
pro
 ess
w
e
will
re-a quain
t
ourselv
es
with
some
of
what
w
e
learned
b
efore
and
learn
more.
In
this
 
hapter,
w
e
will
rst
write
a
simple
graph
prin
ting
fun tion.
This
rst
denition
will
b
e
a
protot
yp
e,
a
rapidly
written
fun tion
that
enables
us
to
re onnoiter
this
unkno
wn
graph-making
territory
.
W
e
will
dis o
v
er
dragons,
or
nd
that
they
are
m
yth.
After
s outing
the
terrain,
w
e
will
feel
more
 onden
t
and
enhan e
the
fun tion
to
lab
el
the
axes
automati ally
.
Sin e
Ema s
is
designed
to
b
e
exible
and
w
ork
with
all
kinds
of
terminals,
in luding
 
hara ter-only
terminals,
the
graph
will
need
to
b
e
made
from
one
of
the
`t
yp
ewriter'
sym
b
ols.
An
asterisk
will
do;
as
w
e
enhan e
the
graph-
prin
ting
fun tion,
w
e
 an
mak
e
the
 
hoi e
of
sym
b
ol
a
user
option.
W
e
 an
 all
this
fun tion
graph-body-print;
it
will
tak
e
a
numbers-list
as
its
only
argumen
t.
A
t
this
stage,
w
e
will
not
lab
el
the
graph,
but
only
prin
t
its
b
o
dy
.
The
graph-body-print
fun tion
inserts
a
v
erti al
 olumn
of
asterisks
for
ea 
h
elemen
t
in
the
numbers-list.
The
heigh
t
of
ea 
h
line
is
determined
b
y
the
v
alue
of
that
elemen
t
of
the
numbers-list.
Inserting
 olumns
is
a
rep
etitiv
e
a t;
that
means
that
this
fun tion
 an
b
e
written
either
with
a
while
lo
op
or
re ursiv
ely
.
Our
rst
 
hallenge
is
to
dis o
v
er
ho
w
to
prin
t
a
 olumn
of
asterisks.
Usually
,
in
Ema s,
w
e
prin
t
 
hara ters
on
to
a
s reen
horizon
tally
,
line
b
y
line,
b
y
t
yping.
W
e
ha
v
e
t
w
o
routes
w
e
 an
follo
w:
write
our
o
wn
 olumn-
insertion
fun tion
or
dis o
v
er
whether
one
exists
in
Ema s.
T
o
see
whether
there
is
one
in
Ema s,
w
e
 an
use
the
M-x
apropos
 om-
mand.
This
 ommand
is
lik
e
the
C-h
a
( ommand-aprop
os)
 ommand,
ex-
 ept
that
the
latter
nds
only
those
fun tions
that
are
 ommands.
The
M-x
apropos
 ommand
lists
all
sym
b
ols
that
mat 
h
a
regular
expression,
in luding
fun tions
that
are
not
in
tera tiv
e.
What
w
e
w
an
t
to
lo
ok
for
is
some
 ommand
that
prin
ts
or
inserts
 olumns.
V
ery
lik
ely
,
the
name
of
the
fun tion
will
 on
tain
either
the
w
ord
`prin
t'
or
the
w
ord
`insert'
or
the
w
ord
` olumn'.
Therefore,
w
e
 an
simply
t
yp
e
M-x
apropos
RET
print\|insert\| olumn
RET
and
lo
ok
at
the
result.
On
m
y
system,
this
 ommand
tak
es
quite
some
time,
and
then
pro
du es
a
list
of
79
fun tions
and
v
ariables.
S anning
do
wn
the
list,
the
only
fun tion
that
lo
oks
as
if
it
migh
t
do
the
job
is
insert-re tangle.

204
Chapter
15:
Readying
a
Graph
Indeed,
this
is
the
fun tion
w
e
w
an
t;
its
do
 umen
tation
sa
ys:
insert-re tangle:
Insert
text
of
RECTANGLE
with
upper
left
 orner
at
point.
RECTANGLE's
first
line
is
inserted
at
point,
its
se ond
line
is
inserted
at
a
point
verti ally
under
point,
et .
RECTANGLE
should
be
a
list
of
strings.
W
e
 an
run
a
qui 
k
test,
to
mak
e
sure
it
do
es
what
w
e
exp
e t
of
it.
Here
is
the
result
of
pla ing
the
 ursor
after
the
insert-re tangle
ex-
pression
and
t
yping
C-u
C-x
C-e
(eval-last-sexp).
The
fun tion
inserts
the
strings
`"first"',
`"se ond"',
and
`"third"'
at
and
b
elo
w
p
oin
t.
Also
the
fun tion
returns
nil.
(insert-re tangle
'("first"
"se ond"
"third"))first
se ond
third
nil
Of
 ourse,
w
e
w
on't
b
e
inserting
the
text
of
the
insert-re tangle
expres-
sion
itself
in
to
the
buer
in
whi 
h
w
e
are
making
the
graph,
but
will
 all
the
fun tion
from
our
program.
W
e
shall,
ho
w
ev
er,
ha
v
e
to
mak
e
sure
that
p
oin
t
is
in
the
buer
at
the
pla e
where
the
insert-re tangle
fun tion
will
insert
its
 olumn
of
strings.
If
y
ou
are
reading
this
in
Info,
y
ou
 an
see
ho
w
this
w
orks
b
y
swit 
hing
to
another
buer,
su 
h
as
the
`*s rat h*'
buer,
pla ing
p
oin
t
somewhere
in
the
buer,
t
yping
M-:,
t
yping
the
insert-re tangle
expression
in
to
the
minibuer
at
the
prompt,
and
then
t
yping
h
RET
i
.
This
 auses
Ema s
to
ev
aluate
the
expression
in
the
minibuer,
but
to
use
as
the
v
alue
of
p
oin
t
the
p
osition
of
p
oin
t
in
the
`*s rat h*'
buer.
(M-:
is
the
k
eybinding
for
eval-expression.)
W
e
nd
when
w
e
do
this
that
p
oin
t
ends
up
at
the
end
of
the
last
inserted
line|that
is
to
sa
y
,
this
fun tion
mo
v
es
p
oin
t
as
a
side-ee t.
If
w
e
w
ere
to
rep
eat
the
 ommand,
with
p
oin
t
at
this
p
osition,
the
next
insertion
w
ould
b
e
b
elo
w
and
to
the
righ
t
of
the
previous
insertion.
W
e
don't
w
an
t
this!
If
w
e
are
going
to
mak
e
a
bar
graph,
the
 olumns
need
to
b
e
b
eside
ea 
h
other.
So
w
e
dis o
v
er
that
ea 
h
 y le
of
the
 olumn-inserting
while
lo
op
m
ust
rep
osition
p
oin
t
to
the
pla e
w
e
w
an
t
it,
and
that
pla e
will
b
e
at
the
top,
not
the
b
ottom,
of
the
 olumn.
Moreo
v
er,
w
e
remem
b
er
that
when
w
e
prin
t
a
graph,
w
e
do
not
exp
e t
all
the
 olumns
to
b
e
the
same
heigh
t.
This
means
that
the
top
of
ea 
h
 olumn
ma
y
b
e
at
a
dieren
t
heigh
t
from
the
previous
one.
W
e
 annot
simply
rep
osition
p
oin
t
to
the
same
line
ea 
h
time,
but
mo
v
ed
o
v
er
to
the
righ
t|or
p
erhaps
w
e
 an
.
.
.
W
e
are
planning
to
mak
e
the
 olumns
of
the
bar
graph
out
of
asterisks.
The
n
um
b
er
of
asterisks
in
the
 olumn
is
the
n
um
b
er
sp
e ied
b
y
the
 urren
t
elemen
t
of
the
numbers-list.
W
e
need
to
 onstru t
a
list
of
asterisks
of
the
righ
t
length
for
ea 
h
 all
to
insert-re tangle.
If
this
list
 onsists
solely
of
the
requisite
n
um
b
er
of
asterisks,
then
w
e
will
ha
v
e
p
osition
p
oin
t
the
righ
t

Readying
a
Graph
205
n
um
b
er
of
lines
ab
o
v
e
the
base
for
the
graph
to
prin
t
 orre tly
.
This
 ould
b
e
diÆ ult.
Alternativ
ely
,
if
w
e
 an
gure
out
some
w
a
y
to
pass
insert-re tangle
a
list
of
the
same
length
ea 
h
time,
then
w
e
 an
pla e
p
oin
t
on
the
same
line
ea 
h
time,
but
mo
v
e
it
o
v
er
one
 olumn
to
the
righ
t
for
ea 
h
new
 olumn.
If
w
e
do
this,
ho
w
ev
er,
some
of
the
en
tries
in
the
list
passed
to
insert-
re tangle
m
ust
b
e
blanks
rather
than
asterisks.
F
or
example,
if
the
max-
im
um
heigh
t
of
the
graph
is
5,
but
the
heigh
t
of
the
 olumn
is
3,
then
insert-re tangle
requires
an
argumen
t
that
lo
oks
lik
e
this:
("
"
"
"
"*"
"*"
"*")
This
last
prop
osal
is
not
so
diÆ ult,
so
long
as
w
e
 an
determine
the
 olumn
heigh
t.
There
are
t
w
o
w
a
ys
for
us
to
sp
e ify
the
 olumn
heigh
t:
w
e
 an
arbitrarily
state
what
it
will
b
e,
whi 
h
w
ould
w
ork
ne
for
graphs
of
that
heigh
t;
or
w
e
 an
sear 
h
through
the
list
of
n
um
b
ers
and
use
the
maxim
um
heigh
t
of
the
list
as
the
maxim
um
heigh
t
of
the
graph.
If
the
latter
op
eration
w
ere
diÆ ult,
then
the
former
pro
 edure
w
ould
b
e
easiest,
but
there
is
a
fun tion
built
in
to
Ema s
that
determines
the
maxim
um
of
its
argumen
ts.
W
e
 an
use
that
fun tion.
The
fun tion
is
 alled
max
and
it
returns
the
largest
of
all
its
argumen
ts,
whi 
h
m
ust
b
e
n
um
b
ers.
Th
us,
for
example,
(max
3
4
6
5
7
3)
returns
7.
(A
 orresp
onding
fun tion
 alled
min
returns
the
smallest
of
all
its
argumen
ts.)
Ho
w
ev
er,
w
e
 annot
simply
 all
max
on
the
numbers-list;
the
max
fun -
tion
exp
e ts
n
um
b
ers
as
its
argumen
t,
not
a
list
of
n
um
b
ers.
Th
us,
the
follo
wing
expression,
(max
'(3
4
6
5
7
3))
pro
du es
the
follo
wing
error
message;
Wrong
type
of
argument:
number-or-marker-p,
(3
4
6
5
7
3)
W
e
need
a
fun tion
that
passes
a
list
of
argumen
ts
to
a
fun tion.
This
fun tion
is
apply.
This
fun tion
`applies'
its
rst
argumen
t
(a
fun tion)
to
its
remaining
argumen
ts,
the
last
of
whi 
h
ma
y
b
e
a
list.
F
or
example,
(apply
'max
3
4
7
3
'(4
8
5))
returns
8.
(In iden
tally
,
I
don't
kno
w
ho
w
y
ou
w
ould
learn
of
this
fun tion
without
a
b
o
ok
su 
h
as
this.
It
is
p
ossible
to
dis o
v
er
other
fun tions,
lik
e
sear h-
forward
or
insert-re tangle,
b
y
guessing
at
a
part
of
their
names
and
then
using
apropos.
Ev
en
though
its
base
in
metaphor
is
 lear|`apply'
its
rst
argumen
t
to
the
rest|I
doubt
a
no
vi e
w
ould
 ome
up
with
that
parti ular
w
ord
when
using
apropos
or
other
aid.
Of
 ourse,
I
 ould
b
e
wrong;
after
all,
the
fun tion
w
as
rst
named
b
y
someone
who
had
to
in
v
en
t
it.)

206
Chapter
15:
Readying
a
Graph
The
se ond
and
subsequen
t
argumen
ts
to
apply
are
optional,
so
w
e
 an
use
apply
to
 all
a
fun tion
and
pass
the
elemen
ts
of
a
list
to
it,
lik
e
this,
whi 
h
also
returns
8:
(apply
'max
'(4
8
5))
This
latter
w
a
y
is
ho
w
w
e
will
use
apply.
The
re ursive-lengths-
list-many-files
fun tion
returns
a
n
um
b
ers'
list
to
whi 
h
w
e
 an
apply
max
(w
e
 ould
also
apply
max
to
the
sorted
n
um
b
ers'
list;
it
do
es
not
matter
whether
the
list
is
sorted
or
not.)
Hen e,
the
op
eration
for
nding
the
maxim
um
heigh
t
of
the
graph
is
this:
(setq
max-graph-height
(apply
'max
numbers-list))
No
w
w
e
 an
return
to
the
question
of
ho
w
to
 reate
a
list
of
strings
for
a
 olumn
of
the
graph.
T
old
the
maxim
um
heigh
t
of
the
graph
and
the
n
um
b
er
of
asterisks
that
should
app
ear
in
the
 olumn,
the
fun tion
should
return
a
list
of
strings
for
the
insert-re tangle
 ommand
to
insert.
Ea 
h
 olumn
is
made
up
of
asterisks
or
blanks.
Sin e
the
fun tion
is
passed
the
v
alue
of
the
heigh
t
of
the
 olumn
and
the
n
um
b
er
of
asterisks
in
the
 olumn,
the
n
um
b
er
of
blanks
 an
b
e
found
b
y
subtra ting
the
n
um
b
er
of
asterisks
from
the
heigh
t
of
the
 olumn.
Giv
en
the
n
um
b
er
of
blanks
and
the
n
um
b
er
of
asterisks,
t
w
o
while
lo
ops
 an
b
e
used
to
 onstru t
the
list:
;;;
First
v
ersion.
(defun
 olumn-of-graph
(max-graph-height
a tual-height)
"Return
list
of
strings
that
is
one
 olumn
of
a
graph."
(let
((insert-list
nil)
(number-of-top-blanks
(-
max-graph-height
a tual-height)))
;;
Fill
in
asterisks.
(while
(>
a tual-height
0)
(setq
insert-list
( ons
"*"
insert-list))
(setq
a tual-height
(1-
a tual-height)))
;;
Fill
in
blanks.
(while
(>
number-of-top-blanks
0)
(setq
insert-list
( ons
"
"
insert-list))
(setq
number-of-top-blanks
(1-
number-of-top-blanks)))
;;
Return
whole
list.
insert-list))
If
y
ou
install
this
fun tion
and
then
ev
aluate
the
follo
wing
expression
y
ou
will
see
that
it
returns
the
list
as
desired:
( olumn-of-graph
5
3)

Readying
a
Graph
207
returns
("
"
"
"
"*"
"*"
"*")
As
written,
 olumn-of-graph
 on
tains
a
ma
jor
a
w:
the
sym
b
ols
used
for
the
blank
and
for
the
mark
ed
en
tries
in
the
 olumn
are
`hard- o
ded'
as
a
spa e
and
asterisk.
This
is
ne
for
a
protot
yp
e,
but
y
ou,
or
another
user,
ma
y
wish
to
use
other
sym
b
ols.
F
or
example,
in
testing
the
graph
fun tion,
y
ou
man
y
w
an
t
to
use
a
p
erio
d
in
pla e
of
the
spa e,
to
mak
e
sure
the
p
oin
t
is
b
eing
rep
ositioned
prop
erly
ea 
h
time
the
insert-re tangle
fun tion
is
 alled;
or
y
ou
migh
t
w
an
t
to
substitute
a
`+'
sign
or
other
sym
b
ol
for
the
asterisk.
Y
ou
migh
t
ev
en
w
an
t
to
mak
e
a
graph- olumn
that
is
more
than
one
displa
y
 olumn
wide.
The
program
should
b
e
more
exible.
The
w
a
y
to
do
that
is
to
repla e
the
blank
and
the
asterisk
with
t
w
o
v
ariables
that
w
e
 an
 all
graph-blank
and
graph-symbol
and
dene
those
v
ariables
separately
.
Also,
the
do
 umen
tation
is
not
w
ell
written.
These
 onsiderations
lead
us
to
the
se ond
v
ersion
of
the
fun tion:
(defvar
graph-symbol
"*"
"String
used
as
symbol
in
graph,
usually
an
asterisk.")
(defvar
graph-blank
"
"
"String
used
as
blank
in
graph,
usually
a
blank
spa e.
graph-blank
must
be
the
same
number
of
 olumns
wide
as
graph-symbol.")
(F
or
an
explanation
of
defvar,
see
Se tion
8.4,
\Initializing
a
V
ariable
with
defvar",
page
100.)
;;;
Se ond
v
ersion.
(defun
 olumn-of-graph
(max-graph-height
a tual-height)
"Return
MAX-GRAPH-HEIGHT
strings;
ACTUAL-HEIGHT
are
graph-symbols.
The
graph-symbols
are
 ontiguous
entries
at
the
end
of
the
list.
The
list
will
be
inserted
as
one
 olumn
of
a
graph.
The
strings
are
either
graph-blank
or
graph-symbol."
(let
((insert-list
nil)
(number-of-top-blanks
(-
max-graph-height
a tual-height)))
;;
Fill
in
graph-symbols.
(while
(>
a tual-height
0)
(setq
insert-list
( ons
graph-symbol
insert-list))
(setq
a tual-height
(1-
a tual-height)))

208
Chapter
15:
Readying
a
Graph
;;
Fill
in
graph-blanks.
(while
(>
number-of-top-blanks
0)
(setq
insert-list
( ons
graph-blank
insert-list))
(setq
number-of-top-blanks
(1-
number-of-top-blanks)))
;;
Return
whole
list.
insert-list))
If
w
e
wished,
w
e
 ould
rewrite
 olumn-of-graph
a
third
time
to
pro
vide
optionally
for
a
line
graph
as
w
ell
as
for
a
bar
graph.
This
w
ould
not
b
e
hard
to
do.
One
w
a
y
to
think
of
a
line
graph
is
that
it
is
no
more
than
a
bar
graph
in
whi 
h
the
part
of
ea 
h
bar
that
is
b
elo
w
the
top
is
blank.
T
o
 onstru t
a
 olumn
for
a
line
graph,
the
fun tion
rst
 onstru ts
a
list
of
blanks
that
is
one
shorter
than
the
v
alue,
then
it
uses
 ons
to
atta 
h
a
graph
sym
b
ol
to
the
list;
then
it
uses
 ons
again
to
atta 
h
the
`top
blanks'
to
the
list.
It
is
easy
to
see
ho
w
to
write
su 
h
a
fun tion,
but
sin e
w
e
don't
need
it,
w
e
will
not
do
it.
But
the
job
 ould
b
e
done,
and
if
it
w
ere
done,
it
w
ould
b
e
done
with
 olumn-of-graph.
Ev
en
more
imp
ortan
t,
it
is
w
orth
noting
that
few
 
hanges
w
ould
ha
v
e
to
b
e
made
an
ywhere
else.
The
enhan emen
t,
if
w
e
ev
er
wish
to
mak
e
it,
is
simple.
No
w,
nally
,
w
e
 ome
to
our
rst
a tual
graph
prin
ting
fun tion.
This
prin
ts
the
b
o
dy
of
a
graph,
not
the
lab
els
for
the
v
erti al
and
horizon
tal
axes,
so
w
e
 an
 all
this
graph-body-print.
15.1
The
graph-body-pri
nt
F
un tion
After
our
preparation
in
the
pre eding
se tion,
the
graph-body-print
fun tion
is
straigh
tforw
ard.
The
fun tion
will
prin
t
 olumn
after
 olumn
of
asterisks
and
blanks,
using
the
elemen
ts
of
a
n
um
b
ers'
list
to
sp
e ify
the
n
um
b
er
of
asterisks
in
ea 
h
 olumn.
This
is
a
rep
etitiv
e
a t,
whi 
h
means
w
e
 an
use
a
de remen
ting
while
lo
op
or
re ursiv
e
fun tion
for
the
job.
In
this
se tion,
w
e
will
write
the
denition
using
a
while
lo
op.
The
 olumn-of-graph
fun tion
requires
the
heigh
t
of
the
graph
as
an
argumen
t,
so
w
e
should
determine
and
re ord
that
as
a
lo
 al
v
ariable.
This
leads
us
to
the
follo
wing
template
for
the
while
lo
op
v
ersion
of
this
fun tion:
(defun
graph-body-print
(numbers-list)
"do
 umen
tation...
"
(let
((height
...
...
))
(while
numbers-list
insert- olumns-and-rep
osition-p
oin
t
(setq
numbers-list
( dr
numbers-list)))))

The
graph-body-print
F
un tion
209
W
e
need
to
ll
in
the
slots
of
the
template.
Clearly
,
w
e
 an
use
the
(apply
'max
numbers-list)
expression
to
deter-
mine
the
heigh
t
of
the
graph.
The
while
lo
op
will
 y le
through
the
numbers-list
one
elemen
t
at
a
time.
As
it
is
shortened
b
y
the
(setq
numbers-list
( dr
numbers-list))
expression,
the
 ar
of
ea 
h
instan e
of
the
list
is
the
v
alue
of
the
argumen
t
for
 olumn-of-graph.
A
t
ea 
h
 y le
of
the
while
lo
op,
the
insert-re tangle
fun tion
inserts
the
list
returned
b
y
 olumn-of-graph.
Sin e
the
insert-re tangle
fun -
tion
mo
v
es
p
oin
t
to
the
lo
w
er
righ
t
of
the
inserted
re tangle,
w
e
need
to
sa
v
e
the
lo
 ation
of
p
oin
t
at
the
time
the
re tangle
is
inserted,
mo
v
e
ba 
k
to
that
p
osition
after
the
re tangle
is
inserted,
and
then
mo
v
e
horizon
tally
to
the
next
pla e
from
whi 
h
insert-re tangle
is
 alled.
If
the
inserted
 olumns
are
one
 
hara ter
wide,
as
they
will
b
e
if
sin-
gle
blanks
and
asterisks
are
used,
the
rep
ositioning
 ommand
is
simply
(forward- har
1);
ho
w
ev
er,
the
width
of
a
 olumn
ma
y
b
e
greater
than
one.
This
means
that
the
rep
ositioning
 ommand
should
b
e
written
(forward-
 har
symbol-width).
The
symbol-width
itself
is
the
length
of
a
graph-
blank
and
 an
b
e
found
using
the
expression
(length
graph-blank).
The
b
est
pla e
to
bind
the
symbol-width
v
ariable
to
the
v
alue
of
the
width
of
graph
 olumn
is
in
the
v
arlist
of
the
let
expression.
These
 onsiderations
lead
to
the
follo
wing
fun tion
denition:
(defun
graph-body-print
(numbers-list)
"Print
a
bar
graph
of
the
NUMBERS-LIST.
The
numbers-list
 onsists
of
the
Y-axis
values."
(let
((height
(apply
'max
numbers-list))
(symbol-width
(length
graph-blank))
from-position)
(while
numbers-list
(setq
from-position
(point))
(insert-re tangle
( olumn-of-graph
height
( ar
numbers-list)))
(goto- har
from-position)
(forward- har
symbol-width)
;;
Dra
w
graph
 olumn
b
y
 olumn.
(sit-for
0)
(setq
numbers-list
( dr
numbers-list)))
;;
Pla e
p
oin
t
for
X
axis
lab
els.
(forward-line
height)
(insert
"\n")
))

210
Chapter
15:
Readying
a
Graph
The
one
unexp
e ted
expression
in
this
fun tion
is
the
(sit-for
0)
expres-
sion
in
the
while
lo
op.
This
expression
mak
es
the
graph
prin
ting
op
eration
more
in
teresting
to
w
at 
h
than
it
w
ould
b
e
otherwise.
The
expression
 auses
Ema s
to
`sit'
or
do
nothing
for
a
zero
length
of
time
and
then
redra
w
the
s reen.
Pla ed
here,
it
 auses
Ema s
to
redra
w
the
s reen
 olumn
b
y
 olumn.
Without
it,
Ema s
w
ould
not
redra
w
the
s reen
un
til
the
fun tion
exits.
W
e
 an
test
graph-body-print
with
a
short
list
of
n
um
b
ers.
1.
Install
graph-symbol,
graph-blank,
 olumn-of-graph,
whi 
h
are
in
Chapter
15,
\Readying
a
Graph",
page
203,
and
graph-body-print.
2.
Cop
y
the
follo
wing
expression:
(graph-body-print
'(1
2
3
4
6
4
3
5
7
6
5
2
3))
3.
Swit 
h
to
the
`*s rat h*'
buer
and
pla e
the
 ursor
where
y
ou
w
an
t
the
graph
to
start.
4.
T
yp
e
M-:
(eval-expression).
5.
Y
ank
the
graph-body-print
expression
in
to
the
minibuer
with
C-y
(yank).
6.
Press
h
RET
i
to
ev
aluate
the
graph-body-print
expression.
Ema s
will
prin
t
a
graph
lik
e
this:
*
*
**
*
****
***
****
*********
*
************
*************
15.2
The
re ursive-grap
h-
bo
dy
-p
ri
nt
F
un tion
The
graph-body-print
fun tion
ma
y
also
b
e
written
re ursiv
ely
.
The
re ursiv
e
solution
is
divided
in
to
t
w
o
parts:
an
outside
`wrapp
er'
that
uses
a
let
expression
to
determine
the
v
alues
of
sev
eral
v
ariables
that
need
only
b
e
found
on e,
su 
h
as
the
maxim
um
heigh
t
of
the
graph,
and
an
inside
fun tion
that
is
 alled
re ursiv
ely
to
prin
t
the
graph.

Need
for
Prin
ted
Axes
211
The
`wrapp
er'
is
un ompli ated:
(defun
re ursive-graph-body-print
(numbers-list)
"Print
a
bar
graph
of
the
NUMBERS-LIST.
The
numbers-list
 onsists
of
the
Y-axis
values."
(let
((height
(apply
'max
numbers-list))
(symbol-width
(length
graph-blank))
from-position)
(re ursive-graph-body-print-i
ntern
al
numbers-list
height
symbol-width)))
The
re ursiv
e
fun tion
is
a
little
more
diÆ ult.
It
has
four
parts:
the
`do-again-test',
the
prin
ting
 o
de,
the
re ursiv
e
 all,
and
the
`next-step-
expression'.
The
`do-again-test'
is
an
if
expression
that
determines
whether
the
numbers-list
 on
tains
an
y
remaining
elemen
ts;
if
it
do
es,
the
fun -
tion
prin
ts
one
 olumn
of
the
graph
using
the
prin
ting
 o
de
and
 alls
itself
again.
The
fun tion
 alls
itself
again
a  ording
to
the
v
alue
pro
du ed
b
y
the
`next-step-expression'
whi 
h
 auses
the
 all
to
a t
on
a
shorter
v
ersion
of
the
numbers-list.
(defun
re ursive-graph-body-print-inte
rnal
(numbers-list
height
symbol-width)
"Print
a
bar
graph.
Used
within
re ursive-graph-body-print
fun tion."
(if
numbers-list
(progn
(setq
from-position
(point))
(insert-re tangle
( olumn-of-graph
height
( ar
numbers-list)))
(goto- har
from-position)
(forward- har
symbol-width)
(sit-for
0)
;
Dra
w
graph
 olumn
b
y
 olumn.
(re ursive-graph-body-print-in
tern
al
( dr
numbers-list)
height
symbol-width))))
After
installation,
this
expression
 an
b
e
tested;
here
is
a
sample:
(re ursive-graph-body-print
'(3
2
5
6
7
5
3
4
6
4
3
2
1))
Here
is
what
re ursive-graph-body-prin
t
pro
du es:
*
**
*
****
*
****
***
*
*********
************
*************

212
Chapter
15:
Readying
a
Graph
Either
of
these
t
w
o
fun tions,
graph-body-print
or
re ursive-graph-
body-print,
 reate
the
b
o
dy
of
a
graph.
15.3
Need
for
Prin
ted
Axes
A
graph
needs
prin
ted
axes,
so
y
ou
 an
orien
t
y
ourself.
F
or
a
do-on e
pro
je t,
it
ma
y
b
e
reasonable
to
dra
w
the
axes
b
y
hand
using
Ema s'
Pi ture
mo
de;
but
a
graph
dra
wing
fun tion
ma
y
b
e
used
more
than
on e.
F
or
this
reason,
I
ha
v
e
written
enhan emen
ts
to
the
basi 
print-graph-
body
fun tion
that
automati ally
prin
t
lab
els
for
the
horizon
tal
and
v
erti al
axes.
Sin e
the
lab
el
prin
ting
fun tions
do
not
 on
tain
m
u 
h
new
material,
I
ha
v
e
pla ed
their
des ription
in
an
app
endix.
See
App
endix
C,
\A
Graph
with
Lab
elled
Axes",
page
255.
15.4
Exer ise
W
rite
a
line
graph
v
ersion
of
the
graph
prin
ting
fun tions.

Site-wide
Initialization
Files
213
16
Y
our
`.ema s'
File
\Y
ou
don't
ha
v
e
to
lik
e
Ema s
to
lik
e
it"
{
this
seemingly
parado
xi al
statemen
t
is
the
se ret
of
GNU
Ema s.
The
plain,
`out
of
the
b
o
x'
Ema s
is
a
generi 
to
ol.
Most
p
eople
who
use
it,
 ustomize
it
to
suit
themselv
es.
GNU
Ema s
is
mostly
written
in
Ema s
Lisp;
this
means
that
b
y
writing
expressions
in
Ema s
Lisp
y
ou
 an
 
hange
or
extend
Ema s.
There
are
those
who
appre iate
Ema s'
default
 onguration.
After
all,
Ema s
starts
y
ou
in
C
mo
de
when
y
ou
edit
a
C
le,
starts
y
ou
in
F
ortran
mo
de
when
y
ou
edit
a
F
ortran
le,
and
starts
y
ou
in
F
undamen
tal
mo
de
when
y
ou
edit
an
unadorned
le.
This
all
mak
es
sense,
if
y
ou
do
not
kno
w
who
is
going
to
use
Ema s.
Who
kno
ws
what
a
p
erson
hop
es
to
do
with
an
unadorned
le?
F
undamen
tal
mo
de
is
the
righ
t
default
for
su 
h
a
le,
just
as
C
mo
de
is
the
righ
t
default
for
editing
C
 o
de.
But
when
y
ou
do
kno
w
who
is
going
to
use
Ema s|y
ou,
y
ourself|then
it
mak
es
sense
to
 ustomize
Ema s.
F
or
example,
I
seldom
w
an
t
F
undamen
tal
mo
de
when
I
edit
an
otherwise
undistinguished
le;
I
w
an
t
T
ext
mo
de.
This
is
wh
y
I
 ustomize
Ema s:
so
it
suits
me.
Y
ou
 an
 ustomize
and
extend
Ema s
b
y
writing
or
adapting
a
`~/.ema s'
le.
This
is
y
our
p
ersonal
initialization
le;
its
 on
ten
ts,
written
in
Ema s
Lisp,
tell
Ema s
what
to
do.
1
A
`~/.ema s'
le
 on
tains
Ema s
Lisp
 o
de.
Y
ou
 an
write
this
 o
de
y
ourself;
or
y
ou
 an
use
Ema s'
 ustomize
feature
to
write
the
 o
de
for
y
ou.
Y
ou
 an
 om
bine
y
our
o
wn
expressions
and
auto-written
Customize
expressions
in
y
our
`.ema s'
le.
(I
m
yself
prefer
to
write
m
y
o
wn
expressions,
ex ept
for
those,
parti ularly
fon
ts,
that
I
nd
easier
to
manipulate
using
the
 ustomize
 ommand.
I
 om
bine
the
t
w
o
metho
ds.)
Most
of
this
 
hapter
is
ab
out
writing
expressions
y
ourself.
It
des rib
es
a
simple
`.ema s'
le;
for
more
information,
see
se tion
\The
Init
File"
in
The
GNU
Ema s
Man
ual
,
and
se tion
\The
Init
File"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
16.1
Site-wide
Initialization
Files
In
addition
to
y
our
p
ersonal
initialization
le,
Ema s
automati ally
loads
v
arious
site-wide
initialization
les,
if
they
exist.
These
ha
v
e
the
same
form
as
y
our
`.ema s'
le,
but
are
loaded
b
y
ev
ery
one.
1
Y
ou
ma
y
also
add
`.el'
to
`~/.ema s'
and
 all
it
a
`~/.ema s.el'
le.
In
the
past,
y
ou
w
ere
forbidden
to
t
yp
e
the
extra
k
eystrok
es
that
the
name
`~/.ema s.el'
requires,
but
no
w
y
ou
ma
y
.
The
new
format
is
 onsisten
t
with
the
Ema s
Lisp
le
naming
 on
v
en
tions;
the
old
format
sa
v
es
t
yping.

214
Chapter
16:
Y
our
`.ema s'
File
Tw
o
site-wide
initialization
les,
`site-load.el'
and
`site-init.el',
are
loaded
in
to
Ema s
and
then
`dump
ed'
if
a
`dump
ed'
v
ersion
of
Ema s
is
 reated,
as
is
most
 ommon.
(Dump
ed
 opies
of
Ema s
load
more
qui 
kly
.
Ho
w
ev
er,
on e
a
le
is
loaded
and
dump
ed,
a
 
hange
to
it
do
es
not
lead
to
a
 
hange
in
Ema s
unless
y
ou
load
it
y
ourself
or
re-dump
Ema s.
See
se tion
\Building
Ema s"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
and
the
`INSTALL'
le.)
Three
other
site-wide
initialization
les
are
loaded
automati ally
ea 
h
time
y
ou
start
Ema s,
if
they
exist.
These
are
`site-start.el',
whi 
h
is
loaded
b
efor
e
y
our
`.ema s'
le,
and
`default.el',
and
the
terminal
t
yp
e
le,
whi 
h
are
b
oth
loaded
after
y
our
`.ema s'
le.
Settings
and
denitions
in
y
our
`.ema s'
le
will
o
v
erwrite
 oni ting
settings
and
denitions
in
a
`site-start.el'
le,
if
it
exists;
but
the
settings
and
denitions
in
a
`default.el'
or
terminal
t
yp
e
le
will
o
v
erwrite
those
in
y
our
`.ema s'
le.
(Y
ou
 an
prev
en
t
in
terferen e
from
a
terminal
t
yp
e
le
b
y
setting
term-file-prefix
to
nil.
See
Se tion
16.11,
\A
Simple
Extension",
page
224.)
The
`INSTALL'
le
that
 omes
in
the
distribution
 on
tains
des riptions
of
the
`site-init.el'
and
`site-load.el'
les.
The
`loadup.el',
`startup.el',
and
`loaddefs.el'
les
 on
trol
loading.
These
les
are
in
the
`lisp'
dire tory
of
the
Ema s
distribution
and
are
w
orth
p
erusing.
The
`loaddefs.el'
le
 on
tains
a
go
o
d
man
y
suggestions
as
to
what
to
put
in
to
y
our
o
wn
`.ema s'
le,
or
in
to
a
site-wide
initialization
le.
16.2
Sp
e ifying
V
ariables
using
def ustom
Y
ou
 an
sp
e ify
v
ariables
using
def ustom
so
that
y
ou
and
others
 an
then
 an
use
Ema s'
 ustomize
feature
to
set
their
v
alues.
(Y
ou
 annot
use
 ustomize
to
write
fun tion
denitions;
but
y
ou
 an
write
defuns
in
y
our
`.ema s'
le.
Indeed,
y
ou
 an
write
an
y
Lisp
expression
in
y
our
`.ema s'
le.)
The
 ustomize
feature
dep
ends
on
the
def ustom
sp
e ial
form.
Al-
though
y
ou
 an
use
defvar
or
setq
for
v
ariables
that
users
set,
the
def ustom
sp
e ial
form
is
designed
for
the
job.
Y
ou
 an
use
y
our
kno
wledge
of
defvar
for
writing
the
rst
three
argu-
men
ts
for
def ustom.
The
rst
argumen
t
to
def ustom
is
the
name
of
the
v
ariable.
The
se ond
argumen
t
is
the
v
ariable's
initial
v
alue,
if
an
y;
and
this
v
alue
is
set
only
if
the
v
alue
has
not
already
b
een
set.
The
third
argumen
t
is
the
do
 umen
tation.
The
fourth
and
subsequen
t
argumen
ts
to
def ustom
sp
e ify
t
yp
es
and
options;
these
are
not
featured
in
defvar.
(These
argumen
ts
are
optional.)
Ea 
h
of
these
argumen
ts
 onsists
of
a
k
eyw
ord
follo
w
ed
b
y
a
v
alue.
Ea 
h
k
eyw
ord
starts
with
the
 
hara ter
:.

Sp
e ifying
V
ariables
using
def ustom
215
F
or
example,
the
 ustomizable
user
option
v
ariable
text-mode-hook
lo
oks
lik
e
this:
(def ustom
text-mode-hook
nil
"Normal
hook
run
when
entering
Text
mode
and
many
related
modes."
:type
'hook
:options
'(turn-on-auto-fill
flyspell-mode)
:group
'data)
The
name
of
the
v
ariable
is
text-mode-hook;
it
has
no
default
v
alue;
and
its
do
 umen
tation
string
tells
y
ou
what
it
do
es.
The
:type
k
eyw
ord
tells
Ema s
what
kind
of
data
text-mode-hook
should
b
e
set
to
and
ho
w
to
displa
y
the
v
alue
in
a
Customization
buer.
The
:options
k
eyw
ord
sp
e ies
a
suggested
list
of
v
alues
for
the
v
ari-
able.
Curren
tly
,
y
ou
 an
use
:options
only
for
a
ho
ok.
The
list
is
only
a
suggestion;
it
is
not
ex lusiv
e;
a
p
erson
who
sets
the
v
ariable
ma
y
set
it
to
other
v
alues;
the
list
sho
wn
follo
wing
the
:options
k
eyw
ord
is
in
tended
to
oer
 on
v
enien
t
 
hoi es
to
a
user.
Finally
,
the
:group
k
eyw
ord
tells
the
Ema s
Customization
 ommand
in
whi 
h
group
the
v
ariable
is
lo
 ated.
This
tells
where
to
nd
it.
F
or
more
information,
see
se tion
\W
riting
Customization
Denitions"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
Consider
text-mode-hook
as
an
example.
There
are
t
w
o
w
a
ys
to
 ustomize
this
v
ariable.
Y
ou
 an
use
the
 us-
tomization
 ommand
or
write
the
appropriate
expressions
y
ourself.
Using
the
 ustomization
 ommand,
y
ou
 an
t
yp
e:
M-x
 ustomize
and
nd
that
the
group
for
editing
les
of
data
is
 alled
`data'.
En
ter
that
group.
T
ext
Mo
de
Ho
ok
is
the
rst
mem
b
er.
Y
ou
 an
 li 
k
on
its
v
arious
options
to
set
the
v
alues.
After
y
ou
 li 
k
on
the
button
to
Save
for
Future
Sessions
Ema s
will
write
an
expression
in
to
y
our
`.ema s'
le.
It
will
lo
ok
lik
e
this:
( ustom-set-variables
;;
 ustom-set-variables
was
added
by
Custom
--
;;
don't
edit
or
 ut/paste
it!
;;
Your
init
file
should
 ontain
only
one
su h
instan e.
'(text-mode-hook
(quote
(turn-on-auto-fill
text-mode-hook-identify))))
(The
text-mode-hook-identify
fun tion
tells
toggle-text-mode-auto-
fill
whi 
h
buers
are
in
T
ext
mo
de.)
In
spite
of
the
w
arning,
y
ou
 ertainly
ma
y
edit,
 ut,
and
paste
the
ex-
pression!
I
do
all
time.
The
purp
ose
of
the
w
arning
is
to
s are
those
who
do
not
kno
w
what
they
are
doing,
so
they
do
not
inadv
erten
tly
generate
an
error.

216
Chapter
16:
Y
our
`.ema s'
File
The
 ustom-set-variables
w
orks
somewhat
dieren
tly
than
a
setq.
While
I
ha
v
e
nev
er
learned
the
dieren es,
I
do
mo
dify
the
 ustom-set-
variables
expressions
in
m
y
`.ema s'
le
b
y
hand:
I
mak
e
the
 
hanges
in
what
app
ears
to
me
to
b
e
a
reasonable
manner
and
ha
v
e
not
had
an
y
problems.
Others
prefer
to
use
the
Customization
 ommand
and
let
Ema s
do
the
w
ork
for
them.
Another
 ustom-set-...
fun tion
is
 ustom-set-fa es.
This
fun tion
sets
the
v
arious
fon
t
fa es.
Ov
er
time,
I
ha
v
e
set
a
 onsiderable
n
um
b
er
of
fa es.
Some
of
the
time,
I
re-set
them
using
 ustomize;
other
times,
I
simply
edit
the
 ustom-set-fa es
expression
in
m
y
`.ema s'
le
itself.
The
se ond
w
a
y
to
 ustomize
y
our
text-mode-hook
is
to
set
it
y
ourself
in
y
our
`.ema s'
le
using
 o
de
that
has
nothing
to
do
with
the
 ustom-
set-...
fun tions.
When
y
ou
do
this,
and
later
use
 ustomize,
y
ou
will
see
a
message
that
sa
ys
this
option
has
been
 hanged
outside
the
 ustomize
buffer.
This
message
is
only
a
w
arning.
If
y
ou
 li 
k
on
the
button
to
Save
for
Future
Sessions
Ema s
will
write
a
 ustom-set-...
expression
near
the
end
of
y
our
`.ema s'
le
that
will
b
e
ev
aluated
after
y
our
hand-written
expression.
It
will,
there-
fore,
o
v
errule
y
our
hand-written
expression.
No
harm
will
b
e
done.
When
y
ou
do
this,
ho
w
ev
er,
b
e
 areful
to
remem
b
er
whi 
h
expression
is
a tiv
e;
if
y
ou
forget,
y
ou
ma
y
 onfuse
y
ourself.
So
long
as
y
ou
remem
b
er
where
the
v
alues
are
set,
y
ou
will
ha
v
e
no
trouble.
In
an
y
ev
en
t,
the
v
alues
are
alw
a
ys
set
in
y
our
initialization
le,
whi 
h
is
usually
 alled
`.ema s'.
I
m
yself
use
 ustomize
for
hardly
an
ything.
Mostly
,
I
write
expressions
m
yself.
16.3
Beginning
a
`.ema s'
File
When
y
ou
start
Ema s,
it
loads
y
our
`.ema s'
le
unless
y
ou
tell
it
not
to
b
y
sp
e ifying
`-q'
on
the
 ommand
line.
(The
ema s
-q
 ommand
giv
es
y
ou
a
plain,
out-of-the-b
o
x
Ema s.)
A
`.ema s'
le
 on
tains
Lisp
expressions.
Often,
these
are
no
more
than
expressions
to
set
v
alues;
sometimes
they
are
fun tion
denitions.
See
se tion
\The
Init
File
`~/.ema s'"
in
The
GNU
Ema s
Man
ual
,
for
a
short
des ription
of
initialization
les.
This
 
hapter
go
es
o
v
er
some
of
the
same
ground,
but
is
a
w
alk
among
extra ts
from
a
 omplete,
long-used
`.ema s'
le|m
y
o
wn.
The
rst
part
of
the
le
 onsists
of
 ommen
ts:
reminders
to
m
yself.
By
no
w,
of
 ourse,
I
remem
b
er
these
things,
but
when
I
started,
I
did
not.

T
ext
and
Auto
Fill
Mo
de
217
;;;;
Bob's
.ema s
file
;
Robert
J.
Chassell
;
26
September
1985
Lo
ok
at
that
date!
I
started
this
le
a
long
time
ago.
I
ha
v
e
b
een
adding
to
it
ev
er
sin e.
;
Ea h
se tion
in
this
file
is
introdu ed
by
a
;
line
beginning
with
four
semi olons;
and
ea h
;
entry
is
introdu ed
by
a
line
beginning
with
;
three
semi olons.
This
des rib
es
the
usual
 on
v
en
tions
for
 ommen
ts
in
Ema s
Lisp.
Ev
ery-
thing
on
a
line
that
follo
ws
a
semi olon
is
a
 ommen
t.
Tw
o,
three,
and
four
semi olons
are
used
as
se tion
and
subse tion
mark
ers.
(See
se tion
\Commen
ts"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
 ommen
ts.)
;;;;
The
Help
Key
;
Control-h
is
the
help
key;
;
after
typing
 ontrol-h,
type
a
letter
to
;
indi ate
the
subje t
about
whi h
you
want
help.
;
For
an
explanation
of
the
help
fa ility,
;
type
 ontrol-h
two
times
in
a
row.
Just
remem
b
er:
t
yp
e
C-h
t
w
o
times
for
help.
;
To
find
out
about
any
mode,
type
 ontrol-h
m
;
while
in
that
mode.
For
example,
to
find
out
;
about
mail
mode,
enter
mail
mode
and
then
type
;
 ontrol-h
m.
`Mo
de
help',
as
I
 all
this,
is
v
ery
helpful.
Usually
,
it
tells
y
ou
all
y
ou
need
to
kno
w.
Of
 ourse,
y
ou
don't
need
to
in lude
 ommen
ts
lik
e
these
in
y
our
`.ema s'
le.
I
in luded
them
in
mine
b
e ause
I
k
ept
forgetting
ab
out
Mo
de
help
or
the
 on
v
en
tions
for
 ommen
ts|but
I
w
as
able
to
remem
b
er
to
lo
ok
here
to
remind
m
yself.
16.4
T
ext
and
Auto
Fill
Mo
de
No
w
w
e
 ome
to
the
part
that
`turns
on'
T
ext
mo
de
and
Auto
Fill
mo
de.
;;;
Text
mode
and
Auto
Fill
mode
;
The
next
three
lines
put
Ema s
into
Text
mode
;
and
Auto
Fill
mode,
and
are
for
writers
who
;
want
to
start
writing
prose
rather
than
 ode.
(setq
default-major-mode
'text-mode)
(add-hook
'text-mode-hook
'text-mode-hook-identify)
(add-hook
'text-mode-hook
'turn-on-auto-fill)

218
Chapter
16:
Y
our
`.ema s'
File
Here
is
the
rst
part
of
this
`.ema s'
le
that
do
es
something
b
esides
remind
a
forgetful
h
uman!
The
rst
of
the
t
w
o
lines
in
paren
theses
tells
Ema s
to
turn
on
T
ext
mo
de
when
y
ou
nd
a
le,
unless
that
le
should
go
in
to
some
other
mo
de,
su 
h
as
C
mo
de.
When
Ema s
reads
a
le,
it
lo
oks
at
the
extension
to
the
le
name,
if
an
y
.
(The
extension
is
the
part
that
 omes
after
a
`.'.)
If
the
le
ends
with
a
`. '
or
`.h'
extension
then
Ema s
turns
on
C
mo
de.
Also,
Ema s
lo
oks
at
rst
non
blank
line
of
the
le;
if
the
line
sa
ys
`-*-
C
-*-'
,
Ema s
turns
on
C
mo
de.
Ema s
p
ossesses
a
list
of
extensions
and
sp
e i ations
that
it
uses
automati ally
.
In
addition,
Ema s
lo
oks
near
the
last
page
for
a
p
er-buer,
\lo
 al
v
ariables
list",
if
an
y
.
See
se tions
\Ho
w
Ma
jor
Mo
des
are
Chosen"
and
\Lo
 al
V
ariables
in
Files"
in
The
GNU
Ema s
Man
ual.
No
w,
ba 
k
to
the
`.ema s'
le.
Here
is
the
line
again;
ho
w
do
es
it
w
ork?
(setq
default-major-mode
'text-mode)
This
line
is
a
short,
but
 omplete
Ema s
Lisp
expression.
W
e
are
already
familiar
with
setq.
It
sets
the
follo
wing
v
ariable,
default-major-mode,
to
the
subsequen
t
v
alue,
whi 
h
is
text-mode.
The
single
quote
mark
b
efore
text-mode
tells
Ema s
to
deal
dire tly
with
the
text-mode
v
ariable,
not
with
whatev
er
it
migh
t
stand
for.
See
Se tion
1.9,
\Setting
the
V
alue
of
a
V
ariable",
page
17,
for
a
reminder
of
ho
w
setq
w
orks.
The
main
p
oin
t
is
that
there
is
no
dieren e
b
et
w
een
the
pro
 edure
y
ou
use
to
set
a
v
alue
in
y
our
`.ema s'
le
and
the
pro
 edure
y
ou
use
an
ywhere
else
in
Ema s.
Here
are
the
next
t
w
o
lines:
(add-hook
'text-mode-hook
'text-mode-hook-identify)
(add-hook
'text-mode-hook
'turn-on-auto-fill)
In
these
t
w
o
lines,
the
add-hook
 ommand
rst
adds
text-mode-hook-
identify
to
the
v
ariable
 alled
text-mode-hook
and
then
adds
turn-on-
auto-fill
to
the
v
ariable.
turn-on-auto-fill
is
the
name
of
a
program,
that,
y
ou
guessed
it!,
turns
on
Auto
Fill
mo
de.
text-mode-hook-identify
is
a
fun tion
that
tells
toggle-text-mode-auto-fill
whi 
h
buers
are
in
T
ext
mo
de.
Ev
ery
time
Ema s
turns
on
T
ext
mo
de,
Ema s
runs
the
 ommands
`ho
ok
ed'
on
to
T
ext
mo
de.
So
ev
ery
time
Ema s
turns
on
T
ext
mo
de,
Ema s
also
turns
on
Auto
Fill
mo
de.
In
brief,
the
rst
line
 auses
Ema s
to
en
ter
T
ext
mo
de
when
y
ou
edit
a
le,
unless
the
le
name
extension,
rst
non-blank
line,
or
lo
 al
v
ariables
tell
Ema s
otherwise.
T
ext
mo
de
among
other
a tions,
sets
the
syn
tax
table
to
w
ork
 on
v
e-
nien
tly
for
writers.
In
T
ext
mo
de,
Ema s
 onsiders
an
ap
ostrophe
as
part

Inden
t
T
abs
Mo
de
219
of
a
w
ord
lik
e
a
letter;
but
Ema s
do
es
not
 onsider
a
p
erio
d
or
a
spa e
as
part
of
a
w
ord.
Th
us,
M-f
mo
v
es
y
ou
o
v
er
`it's'.
On
the
other
hand,
in
C
mo
de,
M-f
stops
just
after
the
`t'
of
`it's'.
The
se ond
and
third
lines
 auses
Ema s
to
turn
on
Auto
Fill
mo
de
when
it
turns
on
T
ext
mo
de.
In
Auto
Fill
mo
de,
Ema s
automati ally
breaks
a
line
that
is
to
o
wide
and
brings
the
ex essiv
ely
wide
part
of
the
line
do
wn
to
the
next
line.
Ema s
breaks
lines
b
et
w
een
w
ords,
not
within
them.
When
Auto
Fill
mo
de
is
turned
o,
lines
 on
tin
ue
to
the
righ
t
as
y
ou
t
yp
e
them.
Dep
ending
on
ho
w
y
ou
set
the
v
alue
of
trun ate-lines,
the
w
ords
y
ou
t
yp
e
either
disapp
ear
o
the
righ
t
side
of
the
s reen,
or
else
are
sho
wn,
in
a
rather
ugly
and
unreadable
manner,
as
a
 on
tin
uation
line
on
the
s reen.
In
addition,
in
this
part
of
m
y
`.ema s'
le,
I
tell
the
Ema s
ll
 ommands
to
insert
t
w
o
spa es
after
a
 olon:
(setq
 olon-double-spa e
t)
16.5
Mail
Aliases
Here
is
a
setq
that
`turns
on'
mail
aliases,
along
with
more
reminders.
;;;
Mail
mode
;
To
enter
mail
mode,
type
`C-x
m'
;
To
enter
RMAIL
(for
reading
mail),
;
type
`M-x
rmail'
(setq
mail-aliases
t)
This
setq
 ommand
sets
the
v
alue
of
the
v
ariable
mail-aliases
to
t.
Sin e
t
means
true,
the
line
sa
ys,
in
ee t,
\Y
es,
use
mail
aliases."
Mail
aliases
are
 on
v
enien
t
short
names
for
long
email
addresses
or
for
lists
of
email
addresses.
The
le
where
y
ou
k
eep
y
our
`aliases'
is
`~/.mailr '.
Y
ou
write
an
alias
lik
e
this:
alias
geo
george foobar.wiz.edu
When
y
ou
write
a
message
to
George,
address
it
to
`geo';
the
mailer
will
automati ally
expand
`geo'
to
the
full
address.
16.6
Inden
t
T
abs
Mo
de
By
default,
Ema s
inserts
tabs
in
pla e
of
m
ultiple
spa es
when
it
formats
a
region.
(F
or
example,
y
ou
migh
t
inden
t
man
y
lines
of
text
all
at
on e
with
the
indent-region
 ommand.)
T
abs
lo
ok
ne
on
a
terminal
or
with
ordinary
prin
ting,
but
they
pro
du e
badly
inden
ted
output
when
y
ou
use
T
E
X
or
T
exinfo
sin e
T
E
X
ignores
tabs.

220
Chapter
16:
Y
our
`.ema s'
File
The
follo
wing
turns
o
Inden
t
T
abs
mo
de:
;;;
Prevent
Extraneous
Tabs
(setq-default
indent-tabs-mode
nil)
Note
that
this
line
uses
setq-default
rather
than
the
setq
 ommand
that
w
e
ha
v
e
seen
b
efore.
The
setq-default
 ommand
sets
v
alues
only
in
buers
that
do
not
ha
v
e
their
o
wn
lo
 al
v
alues
for
the
v
ariable.
See
se tions
\T
abs
vs.
Spa es"
and
\Lo
 al
V
ariables
in
Files"
in
The
GNU
Ema s
Man
ual.
16.7
Some
Keybindings
No
w
for
some
p
ersonal
k
eybindings:
;;;
Compare
windows
(global-set-key
"\C- w"
' ompare-windows)
 ompare-windows
is
a
nift
y
 ommand
that
 ompares
the
text
in
y
our
 urren
t
windo
w
with
text
in
the
next
windo
w.
It
mak
es
the
 omparison
b
y
starting
at
p
oin
t
in
ea 
h
windo
w,
mo
ving
o
v
er
text
in
ea 
h
windo
w
as
far
as
they
mat 
h.
I
use
this
 ommand
all
the
time.
This
also
sho
ws
ho
w
to
set
a
k
ey
globally
,
for
all
mo
des.
The
 ommand
is
global-set-key.
It
is
follo
w
ed
b
y
the
k
eybinding.
In
a
`.ema s'
le,
the
k
eybinding
is
written
as
sho
wn:
\C- 
stands
for
` on
trol-
 ',
whi 
h
means
`press
the
 on
trol
k
ey
and
the
 
k
ey
at
the
same
time'.
The
w
means
`press
the
w
k
ey'.
The
k
eybinding
is
surrounded
b
y
double
quotation
marks.
In
do
 umen
tation,
y
ou
w
ould
write
this
as
C- 
w.
(If
y
ou
w
ere
binding
a
h
MET
A
i
k
ey
,
su 
h
as
M- ,
rather
than
a
h
CTL
i
k
ey
,
y
ou
w
ould
write
\M- .
See
se tion
\Rebinding
Keys
in
Y
our
Init
File"
in
The
GNU
Ema s
Man
ual
,
for
details.)
The
 ommand
in
v
ok
ed
b
y
the
k
eys
is
 ompare-windows.
Note
that
 ompare-windows
is
pre eded
b
y
a
single
quote;
otherwise,
Ema s
w
ould
rst
try
to
ev
aluate
the
sym
b
ol
to
determine
its
v
alue.
These
three
things,
the
double
quotation
marks,
the
ba 
kslash
b
efore
the
`C',
and
the
single
quote
mark
are
ne essary
parts
of
k
eybinding
that
I
tend
to
forget.
F
ortunately
,
I
ha
v
e
 ome
to
remem
b
er
that
I
should
lo
ok
at
m
y
existing
`.ema s'
le,
and
adapt
what
is
there.
As
for
the
k
eybinding
itself:
C- 
w.
This
 om
bines
the
prex
k
ey
,
C- ,
with
a
single
 
hara ter,
in
this
 ase,
w.
This
set
of
k
eys,
C- 
follo
w
ed
b
y
a
single
 
hara ter,
is
stri tly
reserv
ed
for
individuals'
o
wn
use.
(I
 all
these
`o
wn'
k
eys,
sin e
these
are
for
m
y
o
wn
use.)
Y
ou
should
alw
a
ys
b
e
able
to
 reate
su 
h
a
k
eybinding
for
y
our
o
wn
use
without
stomping
on
someone
else's
k
eybinding.
If
y
ou
ev
er
write
an
extension
to
Ema s,
please
a
v
oid
taking
an
y
of
these
k
eys
for
publi 
use.
Create
a
k
ey
lik
e
C- 
C-w
instead.
Otherwise,
w
e
will
run
out
of
`o
wn'
k
eys.

Keymaps
221
Here
is
another
k
eybinding,
with
a
 ommen
t:
;;;
Keybinding
for
`o  ur'
;
I
use
o  ur
a
lot,
so
let's
bind
it
to
a
key:
(global-set-key
"\C- o"
'o  ur)
The
o  ur
 ommand
sho
ws
all
the
lines
in
the
 urren
t
buer
that
 on
tain
a
mat 
h
for
a
regular
expression.
Mat 
hing
lines
are
sho
wn
in
a
buer
 alled
`*O  ur*'.
That
buer
serv
es
as
a
men
u
to
jump
to
o
  urren es.
Here
is
ho
w
to
un
bind
a
k
ey
,
so
it
do
es
not
w
ork:
;;;
Unbind
`C-x
f'
(global-unset-key
"\C-xf")
There
is
a
reason
for
this
un
binding:
I
found
I
inadv
erten
tly
t
yp
ed
C-x
f
when
I
mean
t
to
t
yp
e
C-x
C-f.
Rather
than
nd
a
le,
as
I
in
tended,
I
a  iden
tally
set
the
width
for
lled
text,
almost
alw
a
ys
to
a
width
I
did
not
w
an
t.
Sin e
I
hardly
ev
er
reset
m
y
default
width,
I
simply
un
b
ound
the
k
ey
.
The
follo
wing
rebinds
an
existing
k
ey:
;;;
Rebind
`C-x
C-b'
for
`buffer-menu'
(global-set-key
"\C-x\C-b"
'buffer-menu)
By
default,
C-x
C-b
runs
the
list-buffers
 ommand.
This
 ommand
lists
y
our
buers
in
another
windo
w.
Sin e
I
almost
alw
a
ys
w
an
t
to
do
something
in
that
windo
w,
I
prefer
the
buffer-menu
 ommand,
whi 
h
not
only
lists
the
buers,
but
mo
v
es
p
oin
t
in
to
that
windo
w.
16.8
Keymaps
Ema s
uses
k
eymaps
to
re ord
whi 
h
k
eys
 all
whi 
h
 ommands.
When
y
ou
use
global-set-key
to
set
the
k
eybinding
for
a
single
 ommand
in
all
parts
of
Ema s,
y
ou
are
sp
e ifying
the
k
eybinding
in
 urrent-global-map.
Sp
e i 
mo
des,
su 
h
as
C
mo
de
or
T
ext
mo
de,
ha
v
e
their
o
wn
k
eymaps;
the
mo
de-sp
e i 
k
eymaps
o
v
erride
the
global
map
that
is
shared
b
y
all
buers.
The
global-set-key
fun tion
binds,
or
rebinds,
the
global
k
eymap.
F
or
example,
the
follo
wing
binds
the
k
ey
C-x
C-b
to
the
fun tion
buffer-menu:
(global-set-key
"\C-x\C-b"
'buffer-menu)
Mo
de-sp
e i 
k
eymaps
are
b
ound
using
the
define-key
fun tion,
whi 
h
tak
es
a
sp
e i 
k
eymap
as
an
argumen
t,
as
w
ell
as
the
k
ey
and
the
 ommand.
F
or
example,
m
y
`.ema s'
le
 on
tains
the
follo
wing
expression
to
bind
the
texinfo-insert- group
 ommand
to
C- 
C- 
g:
(define-key
texinfo-mode-map
"\C- \C- g"
'texinfo-insert- group)
The
texinfo-insert- group
fun tion
itself
is
a
little
extension
to
T
exinfo
mo
de
that
inserts
` group'
in
to
a
T
exinfo
le.
I
use
this
 ommand
all
the
time
and
prefer
to
t
yp
e
the
three
strok
es
C- 
C- 
g
rather
than
the
six
strok
es
 
g
r
o
u
p.
(` group'
and
its
mat 
hing
` end
group'
are
 ommands

222
Chapter
16:
Y
our
`.ema s'
File
that
k
eep
all
en losed
text
together
on
one
page;
man
y
m
ulti-line
examples
in
this
b
o
ok
are
surrounded
b
y
` group
...
 end
group'.)
Here
is
the
texinfo-insert- group
fun tion
denition:
(defun
texinfo-insert- group
()
"Insert
the
string
 group
in
a
Texinfo
buffer."
(intera tive)
(beginning-of-line)
(insert
" group\n"))
(Of
 ourse,
I
 ould
ha
v
e
used
Abbrev
mo
de
to
sa
v
e
t
yping,
rather
than
write
a
fun tion
to
insert
a
w
ord;
but
I
prefer
k
ey
strok
es
 onsisten
t
with
other
T
exinfo
mo
de
k
ey
bindings.)
Y
ou
will
see
n
umerous
define-key
expressions
in
`loaddefs.el'
as
w
ell
as
in
the
v
arious
mo
de
libraries,
su 
h
as
`  -mode.el'
and
`lisp-mode.el'.
See
se tion
\Customizing
Key
Bindings"
in
The
GNU
Ema s
Man
ual
,
and
se tion
\Keymaps"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
information
ab
out
k
eymaps.
16.9
Loading
Files
Man
y
p
eople
in
the
GNU
Ema s
 omm
unit
y
ha
v
e
written
extensions
to
Ema s.
As
time
go
es
b
y
,
these
extensions
are
often
in luded
in
new
releases.
F
or
example,
the
Calendar
and
Diary
pa 
k
ages
are
no
w
part
of
the
standard
GNU
Ema s.
(Cal ,
whi 
h
I
 onsider
a
vital
part
of
Ema s,
w
ould
b
e
part
of
the
stan-
dard
distribution
ex ept
that
it
w
as
so
large
it
w
as
pa 
k
aged
separately
and
no
one
has
 
hanged
that.)
Y
ou
 an
use
a
load
 ommand
to
ev
aluate
a
 omplete
le
and
thereb
y
install
all
the
fun tions
and
v
ariables
in
the
le
in
to
Ema s.
F
or
example:
(load
"~/ema s/slowsplit")
This
ev
aluates,
i.e.
loads,
the
`slowsplit.el'
le
or
if
it
exists,
the
faster,
b
yte
 ompiled
`slowsplit.el '
le
from
the
`ema s'
sub-dire tory
of
y
our
home
dire tory
.
The
le
 on
tains
the
fun tion
split-window-quietly,
whi 
h
John
Robinson
wrote
in
1989.
The
split-window-quietly
fun tion
splits
a
windo
w
with
the
minim
um
of
redispla
y
.
I
installed
it
in
1989
b
e ause
it
w
ork
ed
w
ell
with
the
slo
w
1200
baud
terminals
I
w
as
then
using.
No
w
ada
ys,
I
only
o
  asionally
 ome
a ross
su 
h
a
slo
w
 onne tion,
but
I
 on
tin
ue
to
use
the
fun tion
b
e ause
I
lik
e
the
w
a
y
it
lea
v
es
the
b
ottom
half
of
a
buer
in
the
lo
w
er
of
the
new
windo
ws
and
the
top
half
in
the
upp
er
windo
w.

Autoloading
223
T
o
repla e
the
k
ey
binding
for
the
default
split-window-verti ally,
y
ou
m
ust
also
unset
that
k
ey
and
bind
the
k
eys
to
split-window-quietly,
lik
e
this:
(global-unset-key
"\C-x2")
(global-set-key
"\C-x2"
'split-window-quietly)
If
y
ou
load
man
y
extensions,
as
I
do,
then
instead
of
sp
e ifying
the
exa t
lo
 ation
of
the
extension
le,
as
sho
wn
ab
o
v
e,
y
ou
 an
sp
e ify
that
dire tory
as
part
of
Ema s'
load-path.
Then,
when
Ema s
loads
a
le,
it
will
sear 
h
that
dire tory
as
w
ell
as
its
default
list
of
dire tories.
(The
default
list
is
sp
e ied
in
`paths.h'
when
Ema s
is
built.)
The
follo
wing
 ommand
adds
y
our
`~/ema s'
dire tory
to
the
existing
load
path:
;;;
Ema s
Load
Path
(setq
load-path
( ons
"~/ema s"
load-path))
In iden
tally
,
load-library
is
an
in
tera tiv
e
in
terfa e
to
the
load
fun -
tion.
The
 omplete
fun tion
lo
oks
lik
e
this:
(defun
load-library
(library)
"Load
the
library
named
LIBRARY.
This
is
an
interfa e
to
the
fun tion
`load'."
(intera tive
"sLoad
library:
")
(load
library))
The
name
of
the
fun tion,
load-library,
 omes
from
the
use
of
`library'
as
a
 on
v
en
tional
synon
ym
for
`le'.
The
sour e
for
the
load-library
 om-
mand
is
in
the
`files.el'
library
.
Another
in
tera tiv
e
 ommand
that
do
es
a
sligh
tly
dieren
t
job
is
load-
file.
See
se tion
\Libraries
of
Lisp
Co
de
for
Ema s"
in
The
GNU
Ema s
Man
ual
,
for
information
on
the
distin tion
b
et
w
een
load-library
and
this
 ommand.
16.10
Autoloading
Instead
of
installing
a
fun tion
b
y
loading
the
le
that
 on
tains
it,
or
b
y
ev
aluating
the
fun tion
denition,
y
ou
 an
mak
e
the
fun tion
a
v
ailable
but
not
a tually
install
it
un
til
it
is
rst
 alled.
This
is
 alled
autoloading.
When
y
ou
exe ute
an
autoloaded
fun tion,
Ema s
automati ally
ev
alu-
ates
the
le
that
 on
tains
the
denition,
and
then
 alls
the
fun tion.
Ema s
starts
qui 
k
er
with
autoloaded
fun tions,
sin e
their
libraries
are
not
loaded
righ
t
a
w
a
y;
but
y
ou
need
to
w
ait
a
momen
t
when
y
ou
rst
use
su 
h
a
fun tion,
while
its
 on
taining
le
is
ev
aluated.
Rarely
used
fun tions
are
frequen
tly
autoloaded.
The
`loaddefs.el'
li-
brary
 on
tains
h
undreds
of
autoloaded
fun tions,
from
bookmark-set
to
wordstar-mode.
Of
 ourse,
y
ou
ma
y
 ome
to
use
a
`rare'
fun tion
frequen
tly
.

224
Chapter
16:
Y
our
`.ema s'
File
When
y
ou
do,
y
ou
should
load
that
fun tion's
le
with
a
load
expression
in
y
our
`.ema s'
le.
In
m
y
`.ema s'
le
for
Ema s
v
ersion
21,
I
load
12
libraries
that
 on
tain
fun tions
that
w
ould
otherwise
b
e
autoloaded.
(A tually
,
it
w
ould
ha
v
e
b
een
b
etter
to
in lude
these
les
in
m
y
`dump
ed'
Ema s
when
I
built
it,
but
I
forgot.
See
se tion
\Building
Ema s"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
and
the
`INSTALL'
le
for
more
ab
out
dumping.)
Y
ou
ma
y
also
w
an
t
to
in lude
autoloaded
expressions
in
y
our
`.ema s'
le.
autoload
is
a
built-in
fun tion
that
tak
es
up
to
v
e
argumen
ts,
the
nal
three
of
whi 
h
are
optional.
The
rst
argumen
t
is
the
name
of
the
fun tion
to
b
e
autoloaded;
the
se ond
is
the
name
of
the
le
to
b
e
loaded.
The
third
argumen
t
is
do
 umen
tation
for
the
fun tion,
and
the
fourth
tells
whether
the
fun tion
 an
b
e
 alled
in
tera tiv
ely
.
The
fth
argumen
t
tells
what
t
yp
e
of
ob
je t|autoload
 an
handle
a
k
eymap
or
ma ro
as
w
ell
as
a
fun tion
(the
default
is
a
fun tion).
Here
is
a
t
ypi al
example:
(autoload
'html-helper-mode
"html-helper-mode"
"Edit
HTML
do uments"
t)
(html-helper-mode
is
an
alternativ
e
to
html-mode,
whi 
h
is
a
standard
part
of
the
distribution).
This
expression
autoloads
the
html-helper-mode
fun tion.
It
tak
es
it
from
the
`html-helper-mode.el'
le
(or
from
the
b
yte
 ompiled
le
`html-helper-mode.el ',
if
it
exists.)
The
le
m
ust
b
e
lo
 ated
in
a
dire tory
sp
e ied
b
y
load-path.
The
do
 umen
tation
sa
ys
that
this
is
a
mo
de
to
help
y
ou
edit
do
 umen
ts
written
in
the
Hyp
erT
ext
Markup
Language.
Y
ou
 an
 all
this
mo
de
in
tera tiv
ely
b
y
t
yping
M-x
html-helper-mode.
(Y
ou
need
to
dupli ate
the
fun tion's
regular
do
 umen
tation
in
the
autoload
expression
b
e ause
the
regular
fun tion
is
not
y
et
loaded,
so
its
do
 umen
tation
is
not
a
v
ailable.)
See
se tion
\Autoload"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
information.
16.11
A
Simple
Extension:
line-to-top-of
-w
in
do
w
Here
is
a
simple
extension
to
Ema s
that
mo
v
es
the
line
p
oin
t
is
on
to
the
top
of
the
windo
w.
I
use
this
all
the
time,
to
mak
e
text
easier
to
read.
Y
ou
 an
put
the
follo
wing
 o
de
in
to
a
separate
le
and
then
load
it
from
y
our
`.ema s'
le,
or
y
ou
 an
in lude
it
within
y
our
`.ema s'
le.

A
Simple
Extension:
line-to-top-of-window
225
Here
is
the
denition:
;;;
Line
to
top
of
window;
;;;
repla e
three
keystroke
sequen e
C-u
0
C-l
(defun
line-to-top-of-window
()
"Move
the
line
point
is
on
to
top
of
window."
(intera tive)
(re enter
0))
No
w
for
the
k
eybinding.
No
w
ada
ys,
fun tion
k
eys
as
w
ell
as
mouse
button
ev
en
ts
and
non-as i
i
 
hara ters
are
written
within
square
bra 
k
ets,
without
quotation
marks.
(In
Ema s
v
ersion
18
and
b
efore,
y
ou
had
to
write
dieren
t
fun tion
k
ey
bindings
for
ea 
h
dieren
t
mak
e
of
terminal.)
I
bind
line-to-top-of-window
to
m
y
h
F6
i
fun tion
k
ey
lik
e
this:
(global-set-key
[f6℄
'line-to-top-of-window)
F
or
more
information,
see
se tion
\Rebinding
Keys
in
Y
our
Init
File"
in
The
GNU
Ema s
Man
ual
.
If
y
ou
run
t
w
o
v
ersions
of
GNU
Ema s,
su 
h
as
v
ersions
20
and
21,
and
use
one
`.ema s'
le,
y
ou
 an
sele t
whi 
h
 o
de
to
ev
aluate
with
the
follo
wing
 onditional:
( ond
((string-equal
(number-to-string
20)
(substring
(ema s-version)
10
12))
;;
evaluate
version
20
 ode
(
...
))
((string-equal
(number-to-string
21)
(substring
(ema s-version)
10
12))
;;
evaluate
version
21
 ode
(
...
)))
F
or
example,
in
 on
trast
to
v
ersion
20,
v
ersion
21
blinks
its
 ursor
b
y
default.
I
hate
su 
h
blinking,
as
w
ell
as
some
other
features
in
v
ersion
21,
so
I
pla ed
the
follo
wing
in
m
y
`.ema s'
le
2
:
(if
(string-equal
"21"
(substring
(ema s-version)
10
12))
(progn
(blink- ursor-mode
0)
;;
Insert
newline
when
you
press
`C-n'
(next-line)
;;
at
the
end
of
the
buffer
(setq
next-line-add-newlines
t)
;;
Turn
on
image
viewing
(auto-image-file-mode
t)
2
When
I
start
instan es
of
Ema s
that
do
not
load
m
y
`.ema s'
le
or
an
y
site
le,
I
also
turn
o
blinking:
ema s
-q
--no-site-file
-eval
'(blink- ursor-mode
nil)'

226
Chapter
16:
Y
our
`.ema s'
File
;;
Turn
on
menu
bar
(this
bar
has
text)
;;
(Use
numeri 
argument
to
turn
on)
(menu-bar-mode
1)
;;
Turn
off
tool
bar
(this
bar
has
i ons)
;;
(Use
numeri 
argument
to
turn
on)
(tool-bar-mode
nil)
;;
Turn
off
tooltip
mode
for
tool
bar
;;
(This
mode
 auses
i on
explanations
to
pop
up)
;;
(Use
numeri 
argument
to
turn
on)
(tooltip-mode
nil)
;;
If
tooltips
turned
on,
make
tips
appear
promptly
(setq
tooltip-delay
0.1)
;
default
is
one
se ond
))
(Y
ou
will
note
that
instead
of
t
yping
(number-to-string
21),
I
de ided
to
sa
v
e
t
yping
and
wrote
`21'
as
a
string,
"21",
rather
than
 on
v
ert
it
from
an
in
teger
to
a
string.
In
this
instan e,
this
expression
is
b
etter
than
the
longer,
but
more
general
(number-to-string
21).
Ho
w
ev
er,
if
y
ou
do
not
kno
w
ahead
of
time
what
t
yp
e
of
information
will
b
e
returned,
then
the
number-to-string
fun tion
will
b
e
needed.)
16.12
X11
Colors
Y
ou
 an
sp
e ify
 olors
when
y
ou
use
Ema s
with
the
MIT
X
Windo
wing
system.
I
dislik
e
the
default
 olors
and
sp
e ify
m
y
o
wn.
Here
are
the
expressions
in
m
y
`.ema s'
le
that
set
v
alues:
;;
Set
 ursor
 olor
(set- ursor- olor
"white")
;;
Set
mouse
 olor
(set-mouse- olor
"white")
;;
Set
foreground
and
ba kground
(set-foreground- olor
"white")
(set-ba kground- olor
"darkblue")
;;;
Set
highlighting
 olors
for
isear h
and
drag
(set-fa e-foreground
'highlight
"white")
(set-fa e-ba kground
'highlight
"blue")
(set-fa e-foreground
'region
" yan")
(set-fa e-ba kground
'region
"blue")
(set-fa e-foreground
'se ondary-sele tion
"skyblue")
(set-fa e-ba kground
'se ondary-sele tion
"darkblue")

A
Mo
died
Mo
de
Line
227
;;
Set
 alendar
highlighting
 olors
(setq
 alendar-load-hook
'(lambda
()
(set-fa e-foreground
'diary-fa e
"skyblue")
(set-fa e-ba kground
'holiday-fa e
"slate
blue")
(set-fa e-foreground
'holiday-fa e
"white")))
The
v
arious
shades
of
blue
so
othe
m
y
ey
e
and
prev
en
t
me
from
seeing
the
s reen
i 
k
er.
Alternativ
ely
,
I
 ould
ha
v
e
set
m
y
sp
e i ations
in
v
arious
X
initialization
les.
F
or
example,
I
 ould
set
the
foreground,
ba 
kground,
 ursor,
and
p
oin
ter
(i.e.,
mouse)
 olors
in
m
y
`~/.Xresour es'
le
lik
e
this:
Ema s*foreground:
white
Ema s*ba kground:
darkblue
Ema s* ursorColor:
white
Ema s*pointerColor:
white
In
an
y
ev
en
t,
sin e
it
is
not
part
of
Ema s,
I
set
the
ro
ot
 olor
of
m
y
X
windo
w
in
m
y
`~/.xinitr '
le,
lik
e
this
3
:
#
I
use
TWM
for
window
manager.
xsetroot
-solid
Navy
-fg
white
&
16.13
Mis ellaneous
Settings
for
a
`.ema s'
File
Here
are
a
few
mis ellaneous
settings:
 Set
the
shap
e
and
 olor
of
the
mouse
 ursor:
;
Cursor
shapes
are
defined
in
;
`/usr/in lude/X11/ ursorfon
t.h'
;
;
for
example,
the
`target'
 ursor
is
number
128;
;
the
`top_left_arrow'
 ursor
is
number
132.
(let
((mpointer
(x-get-resour e
"*mpointer"
"*ema s*mpointer")))
;;
If
you
have
not
set
your
mouse
pointer
;;
then
set
it,
otherwise
leave
as
is:
(if
(eq
mpointer
nil)
(setq
mpointer
"132"))
;
top_left_arrow
(setq
x-pointer-shape
(string-to-int
mpointer))
(set-mouse- olor
"white"))
3
I
o
  asionally
run
more
mo
dern
windo
w
managers,
su 
h
as
Sa
wsh
with
GNOME,
Enligh
tenmen
t,
SCWM,
or
KDE;
in
those
 ases,
I
often
sp
e ify
an
image
rather
than
a
plain
 olor.

228
Chapter
16:
Y
our
`.ema s'
File
16.14
A
Mo
died
Mo
de
Line
Finally
,
a
feature
I
really
lik
e:
a
mo
died
mo
de
line.
When
I
w
ork
o
v
er
a
net
w
ork,
I
forget
whi 
h
ma 
hine
I
am
using.
Also,
I
tend
to
I
lose
tra 
k
of
where
I
am,
and
whi 
h
line
p
oin
t
is
on.
So
I
reset
m
y
mo
de
line
to
lo
ok
lik
e
this:
-:--
foo.texi
rattlesnake:/home/bob/
Line
1
(Texinfo
Fill)
Top
I
am
visiting
a
le
 alled
`foo.texi',
on
m
y
ma 
hine
`rattlesnake'
in
m
y
`/home/bob'
buer.
I
am
on
line
1,
in
T
exinfo
mo
de,
and
am
at
the
top
of
the
buer.
My
`.ema s'
le
has
a
se tion
that
lo
oks
lik
e
this:
;;
Set
a
Mode
Line
that
tells
me
whi h
ma hine,
whi h
dire tory,
;;
and
whi h
line
I
am
on,
plus
the
other
 ustomary
information.
(setq
default-mode-line-format
(quote
(#("-"
0
1
(help-e ho
"mouse-1:
sele t
window,
mouse-2:
delete
others
..."))
mode-line-mule-info
mode-line-modified
mode-line-frame-identifi ation
"
"
mode-line-buffer-identifi atio
n
"
"
(:eval
(substring
(system-name)
0
(string-mat h
"\\..+"
(system-name))))
":"
default-dire tory
#("
"
0
1
(help-e ho
"mouse-1:
sele t
window,
mouse-2:
delete
others
..."))
(line-number-mode
"
Line
%l
")
global-mode-string

A
Mo
died
Mo
de
Line
229
#("
%[("
0
6
(help-e ho
"mouse-1:
sele t
window,
mouse-2:
delete
others
..."))
(:eval
(mode-line-mode-name))
mode-line-pro ess
minor-mode-alist
#("%n"
0
2
(help-e ho
"mouse-2:
widen"
lo al-map
(keymap
...)))
")%℄
"
(-3
.
"%P")
;;
"-%-"
)))
Here,
I
redene
the
default
mo
de
line.
Most
of
the
parts
are
from
the
original;
but
I
mak
e
a
few
 
hanges.
I
set
the
default
mo
de
line
format
so
as
to
p
ermit
v
arious
mo
des,
su 
h
as
Info,
to
o
v
erride
it.
Man
y
elemen
ts
in
the
list
are
self-explanatory:
mode-line-modified
is
a
v
ariable
that
tells
whether
the
buer
has
b
een
mo
died,
mode-name
tells
the
name
of
the
mo
de,
and
so
on.
Ho
w
ev
er,
the
format
lo
oks
 ompli ated
b
e ause
of
t
w
o
features
w
e
ha
v
e
not
dis ussed.
The
rst
string
in
the
mo
de
line
is
a
dash
or
h
yphen,
`-'.
In
the
old
da
ys,
it
w
ould
ha
v
e
b
een
sp
e ied
simply
as
"-".
But
no
w
ada
ys,
Ema s
 an
add
prop
erties
to
a
string,
su 
h
as
highligh
ting
or,
as
in
this
 ase,
a
help
feature.
If
y
ou
pla e
y
our
mouse
 ursor
o
v
er
the
h
yphen,
some
help
information
ap-
p
ears
(By
default,
y
ou
m
ust
w
ait
one
se ond
b
efore
the
information
app
ears.
Y
ou
 an
 
hange
that
timing
b
y
 
hanging
the
v
alue
of
tooltip-delay.)
The
new
string
format
has
a
sp
e ial
syn
tax:
#("-"
0
1
(help-e ho
"mouse-1:
sele t
window,
..."))
The
#(
b
egins
a
list.
The
rst
elemen
t
of
the
list
is
the
string
itself,
just
one
`-'.
The
se ond
and
third
elemen
ts
sp
e ify
the
range
o
v
er
whi 
h
the
fourth
elemen
t
applies.
A
range
starts
after
a
 
hara ter,
so
a
zero
means
the
range
starts
just
b
efore
the
rst
 
hara ter;
a
1
means
that
the
range
ends
just
after
the
rst
 
hara ter.
The
third
elemen
t
is
the
prop
ert
y
for
the
range.
It
 onsists
of
a
prop
ert
y
list,
a
prop
ert
y
name,
in
this
 ase,
`help-e ho',
follo
w
ed
b
y
a
v
alue,
in
this
 ase,
a
string.
The
se ond,
third,
and
fourth
elemen
ts
of
this
new
string
format
 an
b
e
rep
eated.
See
se tion
\T
ext
Prop
erties
in
String"
in
The
GNU
Ema s
Lisp
Refer-
en e
Man
ual
,
and
see
se tion
\Mo
de
Line
F
ormat"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
information.
mode-line-buffer-identi
fi 
atio
n
displa
ys
the
 urren
t
buer
name.
It
is
a
list
b
eginning
(#("%12b"
0
4
...
.
The
#(
b
egins
the
list.
The
`"%12b"'
displa
ys
the
 urren
t
buer
name,
using
the
buffer-name
fun tion
with
whi 
h
w
e
are
familiar;
the
`12'
sp
e ies
the
maxim
um
n
um
b
er
of
 
hara ters
that
will
b
e
displa
y
ed.
When
a
name
has
few
er
 
hara ters,
whitespa e
is
added
to
ll
out
to
this
n
um
b
er.
(Buer
names
 an
and
often

230
Chapter
16:
Y
our
`.ema s'
File
should
b
e
longer
than
12
 
hara ters;
this
length
w
orks
w
ell
in
a
t
ypi al
80
 olumn
wide
windo
w.)
:eval
is
a
new
feature
in
GNU
Ema s
v
ersion
21.
It
sa
ys
to
ev
aluate
the
follo
wing
form
and
use
the
result
as
a
string
to
displa
y
.
In
this
 ase,
the
expression
displa
ys
the
rst
 omp
onen
t
of
the
full
system
name.
The
end
of
the
rst
 omp
onen
t
is
a
`.'
(`p
erio
d'),
so
I
use
the
string-mat h
fun tion
to
tell
me
the
length
of
the
rst
 omp
onen
t.
The
substring
from
the
zeroth
 
hara ter
to
that
length
is
the
name
of
the
ma 
hine.
This
is
the
expression:
(:eval
(substring
(system-name)
0
(string-mat h
"\\..+"
(system-name))))
`%['
and
`%℄'
 ause
a
pair
of
square
bra 
k
ets
to
app
ear
for
ea 
h
re ursiv
e
editing
lev
el.
`%n'
sa
ys
`Narro
w'
when
narro
wing
is
in
ee t.
`%P'
tells
y
ou
the
p
er en
tage
of
the
buer
that
is
ab
o
v
e
the
b
ottom
of
the
windo
w,
or
`T
op',
`Bottom',
or
`All'.
(A
lo
w
er
 ase
`p'
tell
y
ou
the
p
er en
tage
ab
o
v
e
the
top
of
the
windo
w.)
`%-'
inserts
enough
dashes
to
ll
out
the
line.
Remem
b
er,
\Y
ou
don't
ha
v
e
to
lik
e
Ema s
to
lik
e
it"
|
y
our
o
wn
Ema s
 an
ha
v
e
dieren
t
 olors,
dieren
t
 ommands,
and
dieren
t
k
eys
than
a
default
Ema s.
On
the
other
hand,
if
y
ou
w
an
t
to
bring
up
a
plain
`out
of
the
b
o
x'
Ema s,
with
no
 ustomization,
t
yp
e:
ema s
-q
This
will
start
an
Ema s
that
do
es
not
load
y
our
`~/.ema s'
initialization
le.
A
plain,
default
Ema s.
Nothing
more.

debug
231
17
Debugging
GNU
Ema s
has
t
w
o
debuggers,
debug
and
edebug.
The
rst
is
built
in
to
the
in
ternals
of
Ema s
and
is
alw
a
ys
with
y
ou;
the
se ond
requires
that
y
ou
instrumen
t
a
fun tion
b
efore
y
ou
 an
use
it.
Both
debuggers
are
des rib
ed
extensiv
ely
in
se tion
\Debugging
Lisp
Pro-
grams"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
In
this
 
hapter,
I
will
w
alk
through
a
short
example
of
ea 
h.
17.1
debug
Supp
ose
y
ou
ha
v
e
written
a
fun tion
denition
that
is
in
tended
to
return
the
sum
of
the
n
um
b
ers
1
through
a
giv
en
n
um
b
er.
(This
is
the
triangle
fun tion
dis ussed
earlier.
See
\Example
with
De remen
ting
Coun
ter",
page
129,
for
a
dis ussion.)
Ho
w
ev
er,
y
our
fun tion
denition
has
a
bug.
Y
ou
ha
v
e
mist
yp
ed
`1='
for
`1-'.
Here
is
the
brok
en
denition:
(defun
triangle-bugged
(number)
"Return
sum
of
numbers
1
through
NUMBER
in lusive."
(let
((total
0))
(while
(>
number
0)
(setq
total
(+
total
number))
(setq
number
(1=
number)))
;
Error
here.
total))
If
y
ou
are
reading
this
in
Info,
y
ou
 an
ev
aluate
this
denition
in
the
normal
fashion.
Y
ou
will
see
triangle-bugged
app
ear
in
the
e 
ho
area.
No
w
ev
aluate
the
triangle-bugged
fun tion
with
an
argumen
t
of
4:
(triangle-bugged
4)
In
GNU
Ema s
v
ersion
21,
y
ou
will
 reate
and
en
ter
a
`*Ba ktra e*'
buer
that
sa
ys:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(void-fun tion
1=)
(1=
number)
(setq
number
(1=
number))
(while
(>
number
0)
(setq
total
(+
total
number))
(setq
number
(1=
number)))
(let
((total
0))
(while
(>
number
0)
(setq
total
...)
(setq
number
...))
total)
triangle-bugged(4)

232
Chapter
17:
Debugging
eval((triangle-bugged
4))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
(I
ha
v
e
reformatted
this
example
sligh
tly;
the
debugger
do
es
not
fold
long
lines.
As
usual,
y
ou
 an
quit
the
debugger
b
y
t
yping
q
in
the
`*Ba ktra e*'
buer.)
In
pra ti e,
for
a
bug
as
simple
as
this,
the
`Lisp
error'
line
will
tell
y
ou
what
y
ou
need
to
kno
w
to
 orre t
the
denition.
The
fun tion
1=
is
`v
oid'.
In
GNU
Ema s
20
and
b
efore,
y
ou
will
see:
Symbol's
fun tion
definition
is
void:
1=
whi 
h
has
the
same
meaning
as
the
`*Ba ktra e*'
buer
line
in
v
ersion
21.
Ho
w
ev
er,
supp
ose
y
ou
are
not
quite
 ertain
what
is
going
on?
Y
ou
 an
read
the
 omplete
ba 
ktra e.
In
this
 ase,
y
ou
need
to
run
GNU
Ema s
21,
whi 
h
automati ally
starts
the
debugger
that
puts
y
ou
in
the
`*Ba ktra e*'
buer;
or
else,
y
ou
need
to
start
the
debugger
man
ually
as
des rib
ed
b
elo
w.
Read
the
`*Ba ktra e*'
buer
from
the
b
ottom
up;
it
tells
y
ou
what
Ema s
did
that
led
to
the
error.
Ema s
made
an
in
tera tiv
e
 all
to
C-x
C-
e
(eval-last-sexp),
whi 
h
led
to
the
ev
aluation
of
the
triangle-bugged
expression.
Ea 
h
line
ab
o
v
e
tells
y
ou
what
the
Lisp
in
terpreter
ev
aluated
next.
The
third
line
from
the
top
of
the
buer
is
(setq
number
(1=
number))
Ema s
tried
to
ev
aluate
this
expression;
in
order
to
do
so,
it
tried
to
ev
aluate
the
inner
expression
sho
wn
on
the
se ond
line
from
the
top:
(1=
number)
This
is
where
the
error
o
  urred;
as
the
top
line
sa
ys:
Debugger
entered--Lisp
error:
(void-fun tion
1=)
Y
ou
 an
 orre t
the
mistak
e,
re-ev
aluate
the
fun tion
denition,
and
then
run
y
our
test
again.
17.2
debug-on-entry
GNU
Ema s
21
starts
the
debugger
automati ally
when
y
our
fun tion
has
an
error.
GNU
Ema s
v
ersion
20
and
b
efore
did
not;
it
simply
presen
ted
y
ou
with
an
error
message.
Y
ou
had
to
start
the
debugger
man
ually
.
Y
ou
 an
start
the
debugger
man
ually
for
all
v
ersions
of
Ema s;
the
ad-
v
an
tage
is
that
the
debugger
runs
ev
en
if
y
ou
do
not
ha
v
e
a
bug
in
y
our
 o
de.
Sometimes
y
our
 o
de
will
b
e
free
of
bugs!

debug-on-entry
233
Y
ou
 an
en
ter
the
debugger
when
y
ou
 all
the
fun tion
b
y
 alling
debug-
on-entry.
T
yp
e:
M-x
debug-on-entry
RET
triangle-bugged
RET
No
w,
ev
aluate
the
follo
wing:
(triangle-bugged
5)
All
v
ersions
of
Ema s
will
 reate
a
`*Ba ktra e*'
buer
and
tell
y
ou
that
it
is
b
eginning
to
ev
aluate
the
triangle-bugged
fun tion:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--entering
a
fun tion:
*
triangle-bugged(5)
eval((triangle-bugged
5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
In
the
`*Ba ktra e*'
buer,
t
yp
e
d.
Ema s
will
ev
aluate
the
rst
expres-
sion
in
triangle-bugged;
the
buer
will
lo
ok
lik
e
this:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--beginning
evaluation
of
fun tion
 all
form:
*
(let
((total
0))
(while
(>
number
0)
(setq
total
...)
(setq
number
...))
total)
*
triangle-bugged(5)
eval((triangle-bugged
5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
No
w,
t
yp
e
d
again,
eigh
t
times,
slo
wly
.
Ea 
h
time
y
ou
t
yp
e
d,
Ema s
will
ev
aluate
another
expression
in
the
fun tion
denition.

234
Chapter
17:
Debugging
Ev
en
tually
,
the
buer
will
lo
ok
lik
e
this:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--beginning
evaluation
of
fun tion
 all
form:
*
(setq
number
(1=
number))
*
(while
(>
number
0)
(setq
total
(+
total
number))
(setq
number
(1=
number)))
*
(let
((total
0))
(while
(>
number
0)
(setq
total
...)
(setq
number
...))
total)
*
triangle-bugged(5)
eval((triangle-bugged
5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
 all-intera tively(eval-las
t-se
xp)
----------
Buffer:
*Ba ktra e*
----------
Finally
,
after
y
ou
t
yp
e
d
t
w
o
more
times,
Ema s
will
rea 
h
the
error,
and
the
top
t
w
o
lines
of
the
`*Ba ktra e*'
buer
will
lo
ok
lik
e
this:
----------
Buffer:
*Ba ktra e*
----------
Debugger
entered--Lisp
error:
(void-fun tion
1=)
*
(1=
number)
...
----------
Buffer:
*Ba ktra e*
----------
By
t
yping
d,
y
ou
w
ere
able
to
step
through
the
fun tion.
Y
ou
 an
quit
a
`*Ba ktra e*'
buer
b
y
t
yping
q
in
it;
this
quits
the
tra e,
but
do
es
not
 an el
debug-on-entry.
T
o
 an el
the
ee t
of
debug-on-entry,
 all
 an el-debug-on-entry
and
the
name
of
the
fun tion,
lik
e
this:
M-x
 an el-debug-on-entry
RET
triangle-bugged
RET
(If
y
ou
are
reading
this
in
Info,
 an el
debug-on-entry
no
w.)
17.3
debug-on-quit
and
(debug)
In
addition
to
setting
debug-on-error
or
 alling
debug-on-entry,
there
are
t
w
o
other
w
a
ys
to
start
debug.
Y
ou
 an
start
debug
whenev
er
y
ou
t
yp
e
C-g
(keyboard-quit)
b
y
setting
the
v
ariable
debug-on-quit
to
t.
This
is
useful
for
debugging
innite
lo
ops.

The
edebug
Sour e
Lev
el
Debugger
235
Or,
y
ou
 an
insert
a
line
that
sa
ys
(debug)
in
to
y
our
 o
de
where
y
ou
w
an
t
the
debugger
to
start,
lik
e
this:
(defun
triangle-bugged
(number)
"Return
sum
of
numbers
1
through
NUMBER
in lusive."
(let
((total
0))
(while
(>
number
0)
(setq
total
(+
total
number))
(debug)
;
Start
debugger.
(setq
number
(1=
number)))
;
Error
here.
total))
The
debug
fun tion
is
des rib
ed
in
detail
in
se tion
\The
Lisp
Debugger"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
17.4
The
edebug
Sour e
Lev
el
Debugger
Edebug
is
a
sour e
lev
el
debugger.
Edebug
normally
displa
ys
the
sour e
of
the
 o
de
y
ou
are
debugging,
with
an
arro
w
at
the
left
that
sho
ws
whi 
h
line
y
ou
are
 urren
tly
exe uting.
Y
ou
 an
w
alk
through
the
exe ution
of
a
fun tion,
line
b
y
line,
or
run
qui 
kly
un
til
rea 
hing
a
breakp
oin
t
where
exe ution
stops.
Edebug
is
des rib
ed
in
se tion
\Edebug"
in
The
GNU
Ema s
Lisp
Ref-
eren e
Man
ual
.
Here
is
a
bugged
fun tion
denition
for
triangle-re ursively.
See
Se tion
11.3.4,
\Re ursion
in
pla e
of
a
 oun
ter",
page
137,
for
a
review
of
it.
(defun
triangle-re ursively-bugged
(number)
"Return
sum
of
numbers
1
through
NUMBER
in lusive.
Uses
re ursion."
(if
(=
number
1)
1
(+
number
(triangle-re ursively-bugged
(1=
number)))))
;
Error
here.
Normally
,
y
ou
w
ould
install
this
denition
b
y
p
ositioning
y
our
 ursor
after
the
fun tion's
 losing
paren
thesis
and
t
yping
C-x
C-e
(eval-last-sexp)
or
else
b
y
p
ositioning
y
our
 ursor
within
the
denition
and
t
yping
C-M-x
(eval-
defun).
(By
default,
the
eval-defun
 ommand
w
orks
only
in
Ema s
Lisp
mo
de
or
in
Lisp
In
tera tiv
e
mo
de.)

236
Chapter
17:
Debugging
Ho
w
ev
er,
to
prepare
this
fun tion
denition
for
Edebug,
y
ou
m
ust
rst
instrumen
t
the
 o
de
using
a
dieren
t
 ommand.
Y
ou
 an
do
this
b
y
p
osi-
tioning
y
our
 ursor
within
the
denition
and
t
yping
M-x
edebug-defun
RET
This
will
 ause
Ema s
to
load
Edebug
automati ally
if
it
is
not
already
loaded,
and
prop
erly
instrumen
t
the
fun tion.
After
instrumen
ting
the
fun tion,
pla e
y
our
 ursor
after
the
follo
wing
expression
and
t
yp
e
C-x
C-e
(eval-last-sexp):
(triangle-re ursively-bugged
3)
Y
ou
will
b
e
jump
ed
ba 
k
to
the
sour e
for
triangle-re ursively-bugge
d
and
the
 ursor
p
ositioned
at
the
b
eginning
of
the
if
line
of
the
fun tion.
Also,
y
ou
will
see
an
arro
whead
at
the
left
hand
side
of
that
line.
The
arro
whead
marks
the
line
where
the
fun tion
is
exe uting.
(In
the
follo
wing
examples,
w
e
sho
w
the
arro
whead
with
`=>';
in
a
windo
wing
system,
y
ou
ma
y
see
the
arro
whead
as
a
solid
triangle
in
the
windo
w
`fringe'.)
=>?(if
(=
number
1)
In
the
example,
the
lo
 ation
of
p
oin
t
is
displa
y
ed
with
a
star,
`?'
(in
Info,
it
is
displa
y
ed
as
`-!-').
If
y
ou
no
w
press
h
SPC
i
,
p
oin
t
will
mo
v
e
to
the
next
expression
to
b
e
exe uted;
the
line
will
lo
ok
lik
e
this:
=>(if
?(=
number
1)
As
y
ou
 on
tin
ue
to
press
h
SPC
i
,
p
oin
t
will
mo
v
e
from
expression
to
expression.
A
t
the
same
time,
whenev
er
an
expression
returns
a
v
alue,
that
v
alue
will
b
e
displa
y
ed
in
the
e 
ho
area.
F
or
example,
after
y
ou
mo
v
e
p
oin
t
past
number,
y
ou
will
see
the
follo
wing:
Result:
3
=
C- 
This
means
the
v
alue
of
number
is
3,
whi 
h
is
as i
i
` on
trol- '
(the
third
letter
of
the
alphab
et).
Y
ou
 an
 on
tin
ue
mo
ving
through
the
 o
de
un
til
y
ou
rea 
h
the
line
with
the
error.
Before
ev
aluation,
that
line
lo
oks
lik
e
this:
=>
?(1=
number)))))
;
Error
here.
When
y
ou
press
h
SPC
i
on e
again,
y
ou
will
pro
du e
an
error
message
that
sa
ys:
Symbol's
fun tion
definition
is
void:
1=
This
is
the
bug.
Press
q
to
quit
Edebug.
T
o
remo
v
e
instrumen
tation
from
a
fun tion
denition,
simply
re-ev
aluate
it
with
a
 ommand
that
do
es
not
instrumen
t
it.
F
or
example,
y
ou
 ould
pla e
y
our
 ursor
after
the
denition's
 losing
paren
thesis
and
t
yp
e
C-x
C-e.
Edebug
do
es
a
great
deal
more
than
w
alk
with
y
ou
through
a
fun tion.
Y
ou
 an
set
it
so
it
ra es
through
on
its
o
wn,
stopping
only
at
an
error
or
at
sp
e ied
stopping
p
oin
ts;
y
ou
 an
 ause
it
to
displa
y
the
 
hanging
v
alues
of

Debugging
Exer ises
237
v
arious
expressions;
y
ou
 an
nd
out
ho
w
man
y
times
a
fun tion
is
 alled,
and
more.
Edebug
is
des rib
ed
in
se tion
\Edebug"
in
The
GNU
Ema s
Lisp
Ref-
eren e
Man
ual
.
17.5
Debugging
Exer ises

Install
the
 ount-words-region
fun tion
and
then
 ause
it
to
en
ter
the
built-in
debugger
when
y
ou
 all
it.
Run
the
 ommand
on
a
region
 on
taining
t
w
o
w
ords.
Y
ou
will
need
to
press
d
a
remark
able
n
um
b
er
of
times.
On
y
our
system,
is
a
`ho
ok'
 alled
after
the
 ommand
nishes?
(F
or
information
on
ho
oks,
see
se tion
\Command
Lo
op
Ov
erview"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)

Cop
y
 ount-words-region
in
to
the
`*s rat h*'
buer,
instrumen
t
the
fun tion
for
Edebug,
and
w
alk
through
its
exe ution.
The
fun tion
do
es
not
need
to
ha
v
e
a
bug,
although
y
ou
 an
in
tro
du e
one
if
y
ou
wish.
If
the
fun tion
la 
ks
a
bug,
the
w
alk-through
 ompletes
without
problems.

While
running
Edebug,
t
yp
e
?
to
see
a
list
of
all
the
Edebug
 ommands.
(The
global-edebug-prefix
is
usually
C-x
X,
i.e.
h
CTL
i
-x
follo
w
ed
b
y
an
upp
er
 ase
X;
use
this
prex
for
 ommands
made
outside
of
the
Edebug
debugging
buer.)

In
the
Edebug
debugging
buer,
use
the
p
(edebug-boun e-point)
 ommand
to
see
where
in
the
region
the
 ount-words-region
is
w
ork-
ing.

Mo
v
e
p
oin
t
to
some
sp
ot
further
do
wn
fun tion
and
then
t
yp
e
the
h
(edebug-goto-here)
 ommand
to
jump
to
that
lo
 ation.

Use
the
t
(edebug-tra e-mode)
 ommand
to
 ause
Edebug
to
w
alk
through
the
fun tion
on
its
o
wn;
use
an
upp
er
 ase
T
for
edebug-Tra e-
fast-mode.

Set
a
breakp
oin
t,
then
run
Edebug
in
T
ra e
mo
de
un
til
it
rea 
hes
the
stopping
p
oin
t.

238
Chapter
17:
Debugging

Con lusion
239
18
Con lusion
W
e
ha
v
e
no
w
rea 
hed
the
end
of
this
In
tro
du tion.
Y
ou
ha
v
e
no
w
learned
enough
ab
out
programming
in
Ema s
Lisp
to
set
v
alues,
to
write
simple
`.ema s'
les
for
y
ourself
and
y
our
friends,
and
write
simple
 ustomizations
and
extensions
to
Ema s.
This
is
a
pla e
to
stop.
Or,
if
y
ou
wish,
y
ou
 an
no
w
go
on
w
ard,
and
tea 
h
y
ourself.
Y
ou
ha
v
e
learned
some
of
the
basi 
n
uts
and
b
olts
of
programming.
But
only
some.
There
are
a
great
man
y
more
bra 
k
ets
and
hinges
that
are
easy
to
use
that
w
e
ha
v
e
not
tou 
hed.
A
path
y
ou
 an
follo
w
righ
t
no
w
lies
among
the
sour es
to
GNU
Ema s
and
in
The
GNU
Ema s
Lisp
Referen e
Man
ual.
The
Ema s
Lisp
sour es
are
an
adv
en
ture.
When
y
ou
read
the
sour es
and
 ome
a ross
a
fun tion
or
expression
that
is
unfamiliar,
y
ou
need
to
gure
out
or
nd
out
what
it
do
es.
Go
to
the
Referen e
Man
ual.
It
is
a
thorough,
 omplete,
and
fairly
easy-
to-read
des ription
of
Ema s
Lisp.
It
is
written
not
only
for
exp
erts,
but
for
p
eople
who
kno
w
what
y
ou
kno
w.
(The
Referen e
Man
ual
 omes
with
the
standard
GNU
Ema s
distribution.
Lik
e
this
in
tro
du tion,
it
 omes
as
a
T
exinfo
sour e
le,
so
y
ou
 an
read
it
on-line
and
as
a
t
yp
eset,
prin
ted
b
o
ok.)
Go
to
the
other
on-line
help
that
is
part
of
GNU
Ema s:
the
on-line
do
 umen
tation
for
all
fun tions,
and
find-tags,
the
program
that
tak
es
y
ou
to
sour es.
Here
is
an
example
of
ho
w
I
explore
the
sour es.
Be ause
of
its
name,
`simple.el'
is
the
le
I
lo
ok
ed
at
rst,
a
long
time
ago.
As
it
happ
ens
some
of
the
fun tions
in
`simple.el'
are
 ompli ated,
or
at
least
lo
ok
 ompli ated
at
rst
sigh
t.
The
open-line
fun tion,
for
example,
lo
oks
 ompli ated.
Y
ou
ma
y
w
an
t
to
w
alk
through
this
fun tion
slo
wly
,
as
w
e
did
with
the
forward-senten e
fun tion.
(See
Se tion
12.3,
\forward-senten e",
page
151.)
Or
y
ou
ma
y
w
an
t
to
skip
that
fun tion
and
lo
ok
at
another,
su 
h
as
split-line.
Y
ou
don't
need
to
read
all
the
fun tions.
A  ording
to
 ount-words-in-defun,
the
split-line
fun tion
 on
tains
27
w
ords
and
sym
b
ols.
Ev
en
though
it
is
short,
split-line
 on
tains
four
expressions
w
e
ha
v
e
not
studied:
skip- hars-forward,
indent-to,
 urrent- olumn
and
`?\n'.
Consider
the
skip- hars-forward
fun tion.
(It
is
part
of
the
fun tion
denition
for
ba k-to-indentation,
whi 
h
is
sho
wn
in
Se tion
3.11,
\Re-
view",
page
46.)
In
GNU
Ema s,
y
ou
 an
nd
out
more
ab
out
skip- hars-forward
b
y
t
yping
C-h
f
(des ribe-fun tion)
and
the
name
of
the
fun tion.
This
giv
es
y
ou
the
fun tion
do
 umen
tation.

240
Chapter
18:
Con lusion
Y
ou
ma
y
b
e
able
to
guess
what
is
done
b
y
a
w
ell
named
fun tion
su 
h
as
indent-to;
or
y
ou
 an
lo
ok
it
up,
to
o.
In iden
tally
,
the
des ribe-fun tion
fun tion
itself
is
in
`help.el';
it
is
one
of
those
long,
but
de ipherable
fun -
tions.
Y
ou
 an
lo
ok
up
des ribe-fun tion
using
the
C-h
f
 ommand!
In
this
instan e,
sin e
the
 o
de
is
Lisp,
the
`*Help*'
buer
 on
tains
the
name
of
the
library
 on
taining
the
fun tion's
sour e.
Y
ou
 an
put
p
oin
t
o
v
er
the
name
of
the
library
and
press
the
RET
k
ey
,
whi 
h
in
this
situation
is
b
ound
to
help-follow,
and
b
e
tak
en
dire tly
to
the
sour e,
in
the
same
w
a
y
as
M-.
(find-tag).
The
denition
for
des ribe-fun tion
illustrates
ho
w
to
 ustomize
the
intera tive
expression
without
using
the
standard
 
hara ter
 o
des;
and
it
sho
ws
ho
w
to
 reate
a
temp
orary
buer.
(The
indent-to
fun tion
is
written
in
C
rather
than
Ema s
Lisp;
it
is
a
`built-in'
fun tion.
help-follow
only
pro
vides
y
ou
with
the
do
 umen
tation
of
a
built-in
fun tion;
it
do
es
not
tak
e
y
ou
to
the
sour e.
But
find-tag
will
tak
e
y
ou
to
the
sour e,
if
prop
erly
set
up.)
Y
ou
 an
lo
ok
at
a
fun tion's
sour e
using
find-tag,
whi 
h
is
b
ound
to
M-.
Finally
,
y
ou
 an
nd
out
what
the
Referen e
Man
ual
has
to
sa
y
b
y
visiting
the
man
ual
in
Info,
and
t
yping
i
(Info-index)
and
the
name
of
the
fun tion,
or
b
y
lo
oking
up
skip- hars-forward
in
the
index
to
a
prin
ted
 op
y
of
the
man
ual.
Similarly
,
y
ou
 an
nd
out
what
is
mean
t
b
y
`?\n'.
Y
ou
 an
try
using
Info-index
with
`?\n'.
It
turns
out
that
this
a tion
w
on't
help;
but
don't
giv
e
up.
If
y
ou
sear 
h
the
index
for
`\n'
without
the
`?',
y
ou
will
b
e
tak
en
dire tly
to
the
relev
an
t
se tion
of
the
man
ual.
(See
se tion
\Chara ter
T
yp
e"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.
`?\n'
stands
for
the
newline
 
hara ter.)
Other
in
teresting
sour e
les
in lude
`paragraphs.el',
`loaddefs.el',
and
`loadup.el'.
The
`paragraphs.el'
le
in ludes
short,
easily
understo
o
d
fun tions
as
w
ell
as
longer
ones.
The
`loaddefs.el'
le
 on
tains
the
man
y
standard
autoloads
and
man
y
k
eymaps.
I
ha
v
e
nev
er
lo
ok
ed
at
it
all;
only
at
parts.
`loadup.el'
is
the
le
that
loads
the
standard
parts
of
Ema s;
it
tells
y
ou
a
great
deal
ab
out
ho
w
Ema s
is
built.
(See
se tion
\Building
Ema s"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
building.)
As
I
said,
y
ou
ha
v
e
learned
some
n
uts
and
b
olts;
ho
w
ev
er,
and
v
ery
imp
ortan
tly
,
w
e
ha
v
e
hardly
tou 
hed
ma
jor
asp
e ts
of
programming;
I
ha
v
e
said
nothing
ab
out
ho
w
to
sort
information,
ex ept
to
use
the
predened
sort
fun tion;
I
ha
v
e
said
nothing
ab
out
ho
w
to
store
information,
ex ept
to
use
v
ariables
and
lists;
I
ha
v
e
said
nothing
ab
out
ho
w
to
write
programs
that
write
programs.
These
are
topi s
for
another,
and
dieren
t
kind
of
b
o
ok,
a
dieren
t
kind
of
learning.
What
y
ou
ha
v
e
done
is
learn
enough
for
m
u 
h
pra ti al
w
ork
with
GNU
Ema s.
What
y
ou
ha
v
e
done
is
get
started.
This
is
the
end
of
a
b
eginning.

The
the-the
F
un tion
241
App
endix
A
The
the-the
F
un tion
Sometimes
when
y
ou
y
ou
write
text,
y
ou
dupli ate
w
ords|as
with
\y
ou
y
ou"
near
the
b
eginning
of
this
sen
ten e.
I
nd
that
most
frequen
tly
,
I
dupli ate
\the';
hen e,
I
 all
the
fun tion
for
dete ting
dupli ated
w
ords,
the-the.
As
a
rst
step,
y
ou
 ould
use
the
follo
wing
regular
expression
to
sear 
h
for
dupli ates:
\\(\\w+[
\t\n℄+\\)\\1
This
regexp
mat 
hes
one
or
more
w
ord- onstituen
t
 
hara ters
follo
w
ed
b
y
one
or
more
spa es,
tabs,
or
newlines.
Ho
w
ev
er,
it
do
es
not
dete t
dupli ated
w
ords
on
dieren
t
lines,
sin e
the
ending
of
the
rst
w
ord,
the
end
of
the
line,
is
dieren
t
from
the
ending
of
the
se ond
w
ord,
a
spa e.
(F
or
more
information
ab
out
regular
expressions,
see
Chapter
12,
\Regular
Expression
Sear 
hes",
page
149,
as
w
ell
as
se tion
\Syn
tax
of
Regular
Expressions"
in
The
GNU
Ema s
Man
ual
,
and
se tion
\Regular
Expressions"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
.)
Y
ou
migh
t
try
sear 
hing
just
for
dupli ated
w
ord- onstituen
t
 
hara ters
but
that
do
es
not
w
ork
sin e
the
pattern
dete ts
doubles
su 
h
as
the
t
w
o
o
  urren es
of
`th'
in
`with
the'.
Another
p
ossible
regexp
sear 
hes
for
w
ord- onstituen
t
 
hara ters
follo
w
ed
b
y
non-w
ord- onstituen
t
 
hara ters,
redupli ated.
Here,
`\\w+'
mat 
hes
one
or
more
w
ord- onstituen
t
 
hara ters
and
`\\W*'
mat 
hes
zero
or
more
non-
w
ord- onstituen
t
 
hara ters.
\\(\\(\\w+\\)\\W*\\)\\1
Again,
not
useful.
Here
is
the
pattern
that
I
use.
It
is
not
p
erfe t,
but
go
o
d
enough.
`\\b'
mat 
hes
the
empt
y
string,
pro
vided
it
is
at
the
b
eginning
or
end
of
a
w
ord;
`[^ 
\n\t℄+'
mat 
hes
one
or
more
o
  urren es
of
an
y
 
hara ters
that
are
not
an
 -sign,
spa e,
newline,
or
tab.
\\b\\([^ 
\n\t℄+\\)[
\n\t℄+\\1\\b
One
 an
write
more
 ompli ated
expressions,
but
I
found
that
this
ex-
pression
is
go
o
d
enough,
so
I
use
it.
Here
is
the
the-the
fun tion,
as
I
in lude
it
in
m
y
`.ema s'
le,
along
with
a
handy
global
k
ey
binding:
(defun
the-the
()
"Sear h
forward
for
for
a
dupli ated
word."
(intera tive)
(message
"Sear hing
for
for
dupli ated
words
...")
(push-mark)

242
App
endix
A:
The
the-the
F
un tion
;;
This
regexp
is
not
perfe t
;;
but
is
fairly
good
over
all:
(if
(re-sear h-forward
"\\b\\([^ 
\n\t℄+\\)[
\n\t℄+\\1\\b"
nil
'move)
(message
"Found
dupli ated
word.")
(message
"End
of
buffer")))
;;
Bind
`the-the'
to
C- 
\
(global-set-key
"\C- \\"
'the-the)
Here
is
test
text:
one
two
two
three
four
five
five
six
seven
Y
ou
 an
substitute
the
other
regular
expressions
sho
wn
ab
o
v
e
in
the
fun -
tion
denition
and
try
ea 
h
of
them
on
this
list.

The
rotate-yank-pointer
F
un tion
243
App
endix
B
Handling
the
Kill
Ring
The
kill
ring
is
a
list
that
is
transformed
in
to
a
ring
b
y
the
w
orkings
of
the
rotate-yank-pointer
fun tion.
The
yank
and
yank-pop
 ommands
use
the
rotate-yank-pointer
fun tion.
This
app
endix
des rib
es
the
rotate-yank-
pointer
fun tion
as
w
ell
as
b
oth
the
yank
and
the
yank-pop
 ommands.
B.1
The
rotate-yank-po
in
te
r
F
un tion
The
rotate-yank-pointer
fun tion
 
hanges
the
elemen
t
in
the
kill
ring
to
whi 
h
kill-ring-yank-pointer
p
oin
ts.
F
or
example,
it
 an
 
hange
kill-ring-yank-pointer
from
p
oin
ting
to
the
se ond
elemen
t
to
p
oin
t
to
the
third
elemen
t.
Here
is
the
 o
de
for
rotate-yank-pointer:
(defun
rotate-yank-pointer
(arg)
"Rotate
the
yanking
point
in
the
kill
ring."
(intera tive
"p")
(let
((length
(length
kill-ring)))
(if
(zerop
length)
;;
then-part
(error
"Kill
ring
is
empty")
;;
else-part
(setq
kill-ring-yank-pointer
(nth dr
(%
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
length)
kill-ring)))))
The
rotate-yank-pointer
fun tion
lo
oks
 omplex,
but
as
usual,
it
 an
b
e
understo
o
d
b
y
taking
it
apart
pie e
b
y
pie e.
First
lo
ok
at
it
in
sk
eletal
form:
(defun
rotate-yank-pointer
(arg)
"Rotate
the
yanking
point
in
the
kill
ring."
(intera tive
"p")
(let
v
arlist
b
o
dy
...
)
This
fun tion
tak
es
one
argumen
t,
 alled
arg.
It
has
a
brief
do
 umen-
tation
string;
and
it
is
in
tera tiv
e
with
a
small
`p',
whi 
h
means
that
the
argumen
t
m
ust
b
e
a
pro
 essed
prex
passed
to
the
fun tion
as
a
n
um
b
er.
The
b
o
dy
of
the
fun tion
denition
is
a
let
expression,
whi 
h
itself
has
a
b
o
dy
as
w
ell
as
a
v
arlist.

244
App
endix
B:
Handling
the
Kill
Ring
The
let
expression
de lares
a
v
ariable
that
will
b
e
only
usable
within
the
b
ounds
of
this
fun tion.
This
v
ariable
is
 alled
length
and
is
b
ound
to
a
v
alue
that
is
equal
to
the
n
um
b
er
of
items
in
the
kill
ring.
This
is
done
b
y
using
the
fun tion
 alled
length.
(Note
that
this
fun tion
has
the
same
name
as
the
v
ariable
 alled
length;
but
one
use
of
the
w
ord
is
to
name
the
fun tion
and
the
other
is
to
name
the
v
ariable.
The
t
w
o
are
quite
distin t.
Similarly
,
an
English
sp
eak
er
will
distinguish
b
et
w
een
the
meanings
of
the
w
ord
`ship'
when
he
sa
ys:
"I
m
ust
ship
this
pa 
k
age
immediately
."
and
"I
m
ust
get
ab
oard
the
ship
immediately
.")
The
fun tion
length
tells
the
n
um
b
er
of
items
there
are
in
a
list,
so
(length
kill-ring)
returns
the
n
um
b
er
of
items
there
are
in
the
kill
ring.
B.1.1
The
Bo
dy
of
rotate-yank-pointer
The
b
o
dy
of
rotate-yank-pointer
is
a
let
expression
and
the
b
o
dy
of
the
let
expression
is
an
if
expression.
The
purp
ose
of
the
if
expression
is
to
nd
out
whether
there
is
an
ything
in
the
kill
ring.
If
the
kill
ring
is
empt
y
,
the
error
fun tion
stops
ev
aluation
of
the
fun tion
and
prin
ts
a
message
in
the
e 
ho
area.
On
the
other
hand,
if
the
kill
ring
has
something
in
it,
the
w
ork
of
the
fun tion
is
done.
Here
is
the
if-part
and
then-part
of
the
if
expression:
(if
(zerop
length)
;
if-part
(error
"Kill
ring
is
empty")
;
then-part
...
If
there
is
not
an
ything
in
the
kill
ring,
its
length
m
ust
b
e
zero
and
an
error
message
sen
t
to
the
user:
`Kill
ring
is
empty'.
The
if
expression
uses
the
fun tion
zerop
whi 
h
returns
true
if
the
v
alue
it
is
testing
is
zero.
When
zerop
tests
true,
the
then-part
of
the
if
is
ev
aluated.
The
then-part
is
a
list
starting
with
the
fun tion
error,
whi 
h
is
a
fun tion
that
is
similar
to
the
message
fun tion
(see
Se tion
1.8.5,
\message",
page
16),
in
that
it
prin
ts
a
one-line
message
in
the
e 
ho
area.
Ho
w
ev
er,
in
addition
to
prin
ting
a
message,
error
also
stops
ev
aluation
of
the
fun tion
within
whi 
h
it
is
em
b
edded.
This
means
that
the
rest
of
the
fun tion
will
not
b
e
ev
aluated
if
the
length
of
the
kill
ring
is
zero.
(In
m
y
opinion,
it
is
sligh
tly
misleading,
at
least
to
h
umans,
to
use
the
term
`error'
as
the
name
of
the
error
fun tion.
A
b
etter
term
w
ould
b
e
` an el'.
Stri tly
sp
eaking,
of
 ourse,
y
ou
 annot
p
oin
t
to,
m
u 
h
less
rotate
a
p
oin
ter
to
a
list
that
has
no
length,
so
from
the
p
oin
t
of
view
of
the
 omputer,
the
w
ord
`error'
is
 orre t.
But
a
h
uman
exp
e ts
to
attempt
this
sort
of
thing,
if
only
to
nd
out
whether
the
kill
ring
is
full
or
empt
y
.
This
is
an
a t
of
exploration.
(F
rom
the
h
uman
p
oin
t
of
view,
the
a t
of
exploration
and
dis o
v
ery
is
not
ne essarily
an
error,
and
therefore
should
not
b
e
lab
elled
as
one,
ev
en
in
the
b
o
w
els
of
a
 omputer.
As
it
is,
the
 o
de
in
Ema s
implies
that
a
h
uman
who
is
a ting
virtuously
,
b
y
exploring
his
or
her
en
vironmen
t,
is
making
an

The
else-part
of
the
if
expression
245
error.
This
is
bad.
Ev
en
though
the
 omputer
tak
es
the
same
steps
as
it
do
es
when
there
is
an
`error',
a
term
su 
h
as
` an el'
w
ould
ha
v
e
a
 learer
 onnotation.)
The
else-part
of
the
if
expression
The
else-part
of
the
if
expression
is
dedi ated
to
setting
the
v
alue
of
kill-ring-yank-pointer
when
the
kill
ring
has
something
in
it.
The
 o
de
lo
oks
lik
e
this:
(setq
kill-ring-yank-pointer
(nth dr
(%
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
length)
kill-ring)))))
This
needs
some
examination.
Clearly
,
kill-ring-yank-pointer
is
b
e-
ing
set
to
b
e
equal
to
some
 dr
of
the
kill
ring,
using
the
nth dr
fun tion
that
is
des rib
ed
in
an
earlier
se tion.
(See
Se tion
8.5,
\ op
y-region-as-kill",
page
102.)
But
exa tly
ho
w
do
es
it
do
this?
Before
lo
oking
at
the
details
of
the
 o
de
let's
rst
 onsider
the
purp
ose
of
the
rotate-yank-pointer
fun tion.
The
rotate-yank-pointer
fun tion
 
hanges
what
kill-ring-yank-
pointer
p
oin
ts
to.
If
kill-ring-yank-pointer
starts
b
y
p
oin
ting
to
the
rst
elemen
t
of
a
list,
a
 all
to
rotate-yank-pointer
 auses
it
to
p
oin
t
to
the
se ond
elemen
t;
and
if
kill-ring-yank-pointer
p
oin
ts
to
the
se ond
elemen
t,
a
 all
to
rotate-yank-pointer
 auses
it
to
p
oin
t
to
the
third
ele-
men
t.
(And
if
rotate-yank-pointer
is
giv
en
an
argumen
t
greater
than
1,
it
jumps
the
p
oin
ter
that
man
y
elemen
ts.)
The
rotate-yank-pointer
fun tion
uses
setq
to
reset
what
the
kill-
ring-yank-pointer
p
oin
ts
to.
If
kill-ring-yank-pointer
p
oin
ts
to
the
rst
elemen
t
of
the
kill
ring,
then,
in
the
simplest
 ase,
the
rotate-yank-
pointer
fun tion
m
ust
 ause
it
to
p
oin
t
to
the
se ond
elemen
t.
Put
another
w
a
y
,
kill-ring-yank-pointer
m
ust
b
e
reset
to
ha
v
e
a
v
alue
equal
to
the
 dr
of
the
kill
ring.
That
is,
under
these
 ir umstan es,
(setq
kill-ring-yank-pointer
("some
text"
"a
different
pie e
of
text"
"yet
more
text"))
(setq
kill-ring
("some
text"
"a
different
pie e
of
text"
"yet
more
text"))

246
App
endix
B:
Handling
the
Kill
Ring
the
 o
de
should
do
this:
(setq
kill-ring-yank-pointer
( dr
kill-ring))
As
a
result,
the
kill-ring-yank-pointer
will
lo
ok
lik
e
this:
kill-ring-yank-pointer
)
("a
different
pie e
of
text"
"yet
more
text"))
The
a tual
setq
expression
uses
the
nth dr
fun tion
to
do
the
job.
As
w
e
ha
v
e
seen
b
efore
(see
Se tion
7.3,
\n
th dr",
page
85),
the
nth dr
fun tion
w
orks
b
y
rep
eatedly
taking
the
 dr
of
a
list|it
tak
es
the
 dr
of
the
 dr
of
the
 dr
.
.
.
The
t
w
o
follo
wing
expressions
pro
du e
the
same
result:
(setq
kill-ring-yank-pointer
( dr
kill-ring))
(setq
kill-ring-yank-pointer
(nth dr
1
kill-ring))
In
the
rotate-yank-pointer
fun tion,
ho
w
ev
er,
the
rst
argumen
t
to
nth dr
is
a
rather
 omplex
lo
oking
expression
with
lots
of
arithmeti 
inside
of
it:
(%
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
length)
As
usual,
w
e
need
to
lo
ok
at
the
most
deeply
em
b
edded
expression
rst
and
then
w
ork
our
w
a
y
to
w
ards
the
ligh
t.
The
most
deeply
em
b
edded
expression
is
(length
kill-ring-yank-
pointer).
This
nds
the
length
of
the
 urren
t
v
alue
of
the
kill-ring-
yank-pointer.
(Remem
b
er
that
the
kill-ring-yank-pointer
is
the
name
of
a
v
ariable
whose
v
alue
is
a
list.)
The
measuremen
t
of
the
length
is
inside
the
expression:
(-
length
(length
kill-ring-yank-pointer))
In
this
expression,
the
rst
length
is
the
v
ariable
that
w
as
assigned
the
length
of
the
kill
ring
in
the
let
statemen
t
at
the
b
eginning
of
the
fun tion.
(One
migh
t
think
this
fun tion
w
ould
b
e
 learer
if
the
v
ariable
length
w
ere
named
length-of-kill-ring
instead;
but
if
y
ou
lo
ok
at
the
text
of
the
whole
fun tion,
y
ou
will
see
that
it
is
so
short
that
naming
this
v
ariable
length
is
not
a
b
other,
unless
y
ou
are
pulling
the
fun tion
apart
in
to
v
ery
tin
y
pie es
as
w
e
are
doing
here.)
So
the
line
(-
length
(length
kill-ring-yank-pointer)
)
tells
the
dif-
feren e
b
et
w
een
the
length
of
the
kill
ring
and
the
length
of
the
list
whose
name
is
kill-ring-yank-pointer.
T
o
see
ho
w
all
this
ts
in
to
the
rotate-yank-pointer
fun tion,
let's
b
egin
b
y
analyzing
the
 ase
where
kill-ring-yank-pointer
p
oin
ts
to
the
rst
elemen
t
of
the
kill
ring,
just
as
kill-ring
do
es,
and
see
what
happ
ens
when
rotate-yank-pointer
is
 alled
with
an
argumen
t
of
1.

The
%
remainder
fun tion
247
The
v
ariable
length
and
the
v
alue
of
the
expression
(length
kill-ring-
yank-pointer)
will
b
e
the
same
sin e
the
v
ariable
length
is
the
length
of
the
kill
ring
and
the
kill-ring-yank-pointer
is
p
oin
ting
to
the
whole
kill
ring.
Consequen
tly
,
the
v
alue
of
(-
length
(length
kill-ring-yank-pointer))
will
b
e
zero.
Sin e
the
v
alue
of
arg
will
b
e
1,
this
will
mean
that
the
v
alue
of
the
whole
expression
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
will
b
e
1.
Consequen
tly
,
the
argumen
t
to
nth dr
will
b
e
found
as
the
result
of
the
expression
(%
1
length)
The
%
remainder
fun tion
T
o
understand
(%
1
length),
w
e
need
to
understand
%.
A  ording
to
its
do
 umen
tation
(whi 
h
I
just
found
b
y
t
yping
C-h
f
%
h
RET
i
),
the
%
fun tion
returns
the
remainder
of
its
rst
argumen
t
divided
b
y
its
se ond
argumen
t.
F
or
example,
the
remainder
of
5
divided
b
y
2
is
1.
(2
go
es
in
to
5
t
wi e
with
a
remainder
of
1.)
What
surprises
p
eople
who
don't
often
do
arithmeti 
is
that
a
smaller
n
um
b
er
 an
b
e
divided
b
y
a
larger
n
um
b
er
and
ha
v
e
a
remainder.
In
the
example
w
e
just
used,
5
w
as
divided
b
y
2.
W
e
 an
rev
erse
that
and
ask,
what
is
the
result
of
dividing
2
b
y
5?
If
y
ou
 an
use
fra tions,
the
answ
er
is
ob
viously
2/5
or
.4;
but
if,
as
here,
y
ou
 an
only
use
whole
n
um
b
ers,
the
result
has
to
b
e
something
dieren
t.
Clearly
,
5
 an
go
in
to
2
zero
times,
but
what
of
the
remainder?
T
o
see
what
the
answ
er
is,
 onsider
a
 ase
that
has
to
b
e
familiar
from
 
hildho
o
d:

5
divided
b
y
5
is
1
with
a
remainder
of
0;

6
divided
b
y
5
is
1
with
a
remainder
of
1;

7
divided
b
y
5
is
1
with
a
remainder
of
2.

Similarly
,
10
divided
b
y
5
is
2
with
a
remainder
of
0;

11
divided
b
y
5
is
2
with
a
remainder
of
1;

12
divided
b
y
5
is
1
with
a
remainder
of
2.
By
 onsidering
the
 ases
as
parallel,
w
e
 an
see
that

zero
divided
b
y
5
m
ust
b
e
zero
with
a
remainder
of
zero;

1
divided
b
y
5
m
ust
b
e
zero
with
a
remainder
of
1;

2
divided
b
y
5
m
ust
b
e
zero
with
a
remainder
of
2;
and
so
on.

248
App
endix
B:
Handling
the
Kill
Ring
So,
in
this
 o
de,
if
the
v
alue
of
length
is
5,
then
the
result
of
ev
aluating
(%
1
5)
is
1.
(I
just
 
he 
k
ed
this
b
y
pla ing
the
 ursor
after
the
expression
and
t
yping
C-x
C-e.
Indeed,
1
is
prin
ted
in
the
e 
ho
area.)
Using
%
in
rotate-yank-pointer
When
the
kill-ring-yank-pointer
p
oin
ts
to
the
b
eginning
of
the
kill
ring,
and
the
argumen
t
passed
to
rotate-yank-pointer
is
1,
the
%
expres-
sion
returns
1:
(-
length
(length
kill-ring-yank-pointer))
)
0
therefore,
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
)
1
and
 onsequen
tly:
(%
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
length)
)
1
regardless
of
the
v
alue
of
length.
As
a
result
of
this,
the
setq
kill-ring-yank-pointer
expression
simplies
to:
(setq
kill-ring-yank-pointer
(nth dr
1
kill-ring))
What
it
do
es
is
no
w
easy
to
understand.
Instead
of
p
oin
ting
as
it
did
to
the
rst
elemen
t
of
the
kill
ring,
the
kill-ring-yank-pointer
is
set
to
p
oin
t
to
the
se ond
elemen
t.
Clearly
,
if
the
argumen
t
passed
to
rotate-yank-pointer
is
t
w
o,
then
the
kill-ring-yank-pointer
is
set
to
(nth dr
2
kill-ring);
and
so
on
for
dieren
t
v
alues
of
the
argumen
t.
Similarly
,
if
the
kill-ring-yank-pointer
starts
out
p
oin
ting
to
the
se -
ond
elemen
t
of
the
kill
ring,
its
length
is
shorter
than
the
length
of
the
kill
ring
b
y
1,
so
the
 omputation
of
the
remainder
is
based
on
the
expression
(%
(+
arg
1)
length).
This
means
that
the
kill-ring-yank-pointer
is
mo
v
ed
from
the
se ond
elemen
t
of
the
kill
ring
to
the
third
elemen
t
if
the
argumen
t
passed
to
rotate-yank-pointer
is
1.
P
oin
ting
to
the
last
elemen
t
The
nal
question
is,
what
happ
ens
if
the
kill-ring-yank-pointer
is
set
to
the
last
elemen
t
of
the
kill
ring?
Will
a
 all
to
rotate-yank-pointer
mean
that
nothing
more
 an
b
e
tak
en
from
the
kill
ring?
The
answ
er
is
no.
What
happ
ens
is
dieren
t
and
useful.
The
kill-ring-yank-pointer
is
set
to
p
oin
t
to
the
b
eginning
of
the
kill
ring
instead.

yank
249
Let's
see
ho
w
this
w
orks
b
y
lo
oking
at
the
 o
de,
assuming
the
length
of
the
kill
ring
is
5
and
the
argumen
t
passed
to
rotate-yank-pointer
is
1.
When
the
kill-ring-yank-pointer
p
oin
ts
to
the
last
elemen
t
of
the
kill
ring,
its
length
is
1.
The
 o
de
lo
oks
lik
e
this:
(%
(+
arg
(-
length
(length
kill-ring-yank-pointer)))
length)
When
the
v
ariables
are
repla ed
b
y
their
n
umeri 
v
alues,
the
expression
lo
oks
lik
e
this:
(%
(+
1
(-
5
1))
5)
This
expression
 an
b
e
ev
aluated
b
y
lo
oking
at
the
most
em
b
edded
inner
expression
rst
and
w
orking
out
w
ards:
The
v
alue
of
(-
5
1)
is
4;
the
sum
of
(+
1
4)
is
5;
and
the
remainder
of
dividing
5
b
y
5
is
zero.
So
what
rotate-yank-pointer
will
do
is
(setq
kill-ring-yank-pointer
(nth dr
0
kill-ring))
whi 
h
will
set
the
kill-ring-yank-pointer
to
p
oin
t
to
the
b
eginning
of
the
kill
ring.
So
what
happ
ens
with
su  essiv
e
 alls
to
rotate-yank-pointer
is
that
it
mo
v
es
the
kill-ring-yank-pointer
from
elemen
t
to
elemen
t
in
the
kill
ring
un
til
it
rea 
hes
the
end;
then
it
jumps
ba 
k
to
the
b
eginning.
And
this
is
wh
y
the
kill
ring
is
 alled
a
ring,
sin e
b
y
jumping
ba 
k
to
the
b
eginning,
it
is
as
if
the
list
has
no
end!
(And
what
is
a
ring,
but
an
en
tit
y
with
no
end?)
B.2
yank
After
learning
ab
out
rotate-yank-pointer,
the
 o
de
for
the
yank
fun -
tion
is
almost
easy
.
It
has
only
one
tri 
ky
part,
whi 
h
is
the
 omputation
of
the
argumen
t
to
b
e
passed
to
rotate-yank-pointer.
The
 o
de
lo
oks
lik
e
this:
(defun
yank
(&optional
arg)
"Reinsert
the
last
stret h
of
killed
text.
More
pre isely,
reinsert
the
stret h
of
killed
text
most
re ently
killed
OR
yanked.
With
just
C-U
as
argument,
same
but
put
point
in
front
(and
mark
at
end).
With
argument
n,
reinsert
the
nth
most
re ently
killed
stret h
of
killed
text.
See
also
the
 ommand
\\[yank-pop℄."

250
App
endix
B:
Handling
the
Kill
Ring
(intera tive
"*P")
(rotate-yank-pointer
(if
(listp
arg)
0
(if
(eq
arg
'-)
-1
(1-
arg))))
(push-mark
(point))
(insert
( ar
kill-ring-yank-pointer))
(if
( onsp
arg)
(ex hange-point-and-mark)))
Glan ing
o
v
er
this
 o
de,
w
e
 an
understand
the
last
few
lines
readily
enough.
The
mark
is
pushed,
that
is,
remem
b
ered;
then
the
rst
elemen
t
(the
 ar)
of
what
the
kill-ring-yank-pointer
p
oin
ts
to
is
inserted;
and
then,
if
the
argumen
t
passed
the
fun tion
is
a
 ons,
p
oin
t
and
mark
are
ex 
hanged
so
the
p
oin
t
is
put
in
the
fron
t
of
the
inserted
text
rather
than
at
the
end.
This
option
is
explained
in
the
do
 umen
tation.
The
fun tion
itself
is
in
tera tiv
e
with
"*P".
This
means
it
will
not
w
ork
on
a
read-only
buer,
and
that
the
unpro
 essed
prex
argumen
t
is
passed
to
the
fun tion.
P
assing
the
argumen
t
The
hard
part
of
yank
is
understanding
the
 omputation
that
determines
the
v
alue
of
the
argumen
t
passed
to
rotate-yank-pointer.
F
ortunately
,
it
is
not
so
diÆ ult
as
it
lo
oks
at
rst
sigh
t.
What
happ
ens
is
that
the
result
of
ev
aluating
one
or
b
oth
of
the
if
expressions
will
b
e
a
n
um
b
er
and
that
n
um
b
er
will
b
e
the
argumen
t
passed
to
rotate-yank-pointer.
Laid
out
with
 ommen
ts,
the
 o
de
lo
oks
lik
e
this:
(if
(listp
arg)
;
if-part
0
;
then-part
(if
(eq
arg
'-)
;
else-part,
inner
if
-1
;
inner
if
's
then-part
(1-
arg))))
;
inner
if
's
else-part
This
 o
de
 onsists
of
t
w
o
if
expression,
one
the
else-part
of
the
other.
The
rst
or
outer
if
expression
tests
whether
the
argumen
t
passed
to
yank
is
a
list.
Oddly
enough,
this
will
b
e
true
if
yank
is
 alled
without
an
argumen
t|b
e ause
then
it
will
b
e
passed
the
v
alue
of
nil
for
the
optional
argumen
t
and
an
ev
aluation
of
(listp
nil)
returns
true!
So,
if
no
argumen
t
is
passed
to
yank,
the
argumen
t
passed
to
rotate-yank-pointer
inside
of
yank
is
zero.
This
means
the
p
oin
ter
is
not
mo
v
ed
and
the
rst
elemen
t
to
whi 
h
kill-ring-yank-pointer
p
oin
ts
is
inserted,
as
w
e
exp
e t.
Similarly
,
if
the
argumen
t
for
yank
is
C-u,
this
will
b
e
read
as
a
list,
so
again,
a
zero
will
b
e
passed
to
rotate-yank-pointer.
(C-u
pro
du es
an
unpro
 essed
prex
argumen
t
of
(4),
whi 
h
is
a
list
of
one
elemen
t.)
A
t
the
same
time,
later
in
the
fun tion,
this
argumen
t
will
b
e
read
as
a
 ons
so
p
oin
t
will
b
e
put
in
the

P
assing
a
negativ
e
argumen
t
251
fron
t
and
mark
at
the
end
of
the
insertion.
(The
P
argumen
t
to
intera tive
is
designed
to
pro
vide
these
v
alues
for
the
 ase
when
an
optional
argumen
t
is
not
pro
vided
or
when
it
is
C-u.)
The
then-part
of
the
outer
if
expression
handles
the
 ase
when
there
is
no
argumen
t
or
when
it
is
C-u.
The
else-part
handles
the
other
situations.
The
else-part
is
itself
another
if
expression.
The
inner
if
expression
tests
whether
the
argumen
t
is
a
min
us
sign.
(This
is
done
b
y
pressing
the
h
MET
A
i
and
-
k
eys
at
the
same
time,
or
the
h
ESC
i
k
ey
and
then
the
-
k
ey).
In
this
 ase,
the
rotate-yank-pointer
fun tion
is
passed
-1
as
an
argumen
t.
This
mo
v
es
the
kill-ring-yank-pointer
ba 
kw
ards,
whi 
h
is
what
is
desired.
If
the
true-or-false-test
of
the
inner
if
expression
is
false
(that
is,
if
the
argumen
t
is
not
a
min
us
sign),
the
else-part
of
the
expression
is
ev
aluated.
This
is
the
expression
(1-
arg).
Be ause
of
the
t
w
o
if
expressions,
it
will
only
o
  ur
when
the
argumen
t
is
a
p
ositiv
e
n
um
b
er
or
when
it
is
a
negativ
e
n
um
b
er
(not
just
a
min
us
sign
on
its
o
wn).
What
(1-
arg)
do
es
is
de remen
t
the
n
um
b
er
and
return
it.
(The
1-
fun tion
subtra ts
one
from
its
argumen
t.)
This
means
that
if
the
argumen
t
to
rotate-yank-pointer
is
1,
it
is
redu ed
to
zero,
whi 
h
means
the
rst
elemen
t
to
whi 
h
kill-ring-yank-pointer
p
oin
ts
is
y
ank
ed
ba 
k,
as
y
ou
w
ould
exp
e t.
P
assing
a
negativ
e
argumen
t
Finally
,
the
question
arises,
what
happ
ens
if
either
the
remainder
fun -
tion,
%,
or
the
nth dr
fun tion
is
passed
a
negativ
e
argumen
t,
as
they
quite
w
ell
ma
y?
The
answ
ers
 an
b
e
found
b
y
a
qui 
k
test.
When
(%
-1
5)
is
ev
aluated,
a
negativ
e
n
um
b
er
is
returned;
and
if
nth dr
is
 alled
with
a
negativ
e
n
um
b
er,
it
returns
the
same
v
alue
as
if
it
w
ere
 alled
with
a
rst
argumen
t
of
zero.
This
 an
b
e
seen
b
e
ev
aluating
the
follo
wing
 o
de.
Here
the
`
)
'
p
oin
ts
to
the
result
of
ev
aluating
the
 o
de
pre eding
it.
This
w
as
done
b
y
p
ositioning
the
 ursor
after
the
 o
de
and
t
yping
C-x
C-e
(eval-last-sexp)
in
the
usual
fashion.
Y
ou
 an
do
this
if
y
ou
are
reading
this
in
Info
inside
of
GNU
Ema s.
(%
-1
5)
)
-1
(setq
animals
'( ats
dogs
elephants))
)
( ats
dogs
elephants)
(nth dr
1
animals)
)
(dogs
elephants)
(nth dr
0
animals)
)
( ats
dogs
elephants)

252
App
endix
B:
Handling
the
Kill
Ring
(nth dr
-1
animals)
)
( ats
dogs
elephants)
So,
if
a
min
us
sign
or
a
negativ
e
n
um
b
er
is
passed
to
yank,
the
kill-
ring-yank-point
is
rotated
ba 
kw
ards
un
til
it
rea 
hes
the
b
eginning
of
the
list.
Then
it
sta
ys
there.
Unlik
e
the
other
 ase,
when
it
jumps
from
the
end
of
the
list
to
the
b
eginning
of
the
list,
making
a
ring,
it
stops.
This
mak
es
sense.
Y
ou
often
w
an
t
to
get
ba 
k
to
the
most
re en
tly
 lipp
ed
out
pie e
of
text,
but
y
ou
don't
usually
w
an
t
to
insert
text
from
as
man
y
as
thirt
y
kill
 ommands
ago.
So
y
ou
need
to
w
ork
through
the
ring
to
get
to
the
end,
but
w
on't
 y le
around
it
inadv
erten
tly
if
y
ou
are
trying
to
 ome
ba 
k
to
the
b
eginning.
In iden
tally
,
an
y
n
um
b
er
passed
to
yank
with
a
min
us
sign
pre eding
it
will
b
e
treated
as
 1.
This
is
eviden
tly
a
simpli ation
for
writing
the
program.
Y
ou
don't
need
to
jump
ba 
k
to
w
ards
the
b
eginning
of
the
kill
ring
more
than
one
pla e
at
a
time
and
doing
this
is
easier
than
writing
a
fun tion
to
determine
the
magnitude
of
the
n
um
b
er
that
follo
ws
the
min
us
sign.
B.3
yank-pop
After
understanding
yank,
the
yank-pop
fun tion
is
easy
.
Lea
ving
out
the
do
 umen
tation
to
sa
v
e
spa e,
it
lo
oks
lik
e
this:
(defun
yank-pop
(arg)
(intera tive
"*p")
(if
(not
(eq
last- ommand
'yank))
(error
"Previous
 ommand
was
not
a
yank"))
(setq
this- ommand
'yank)
(let
((before
(<
(point)
(mark))))
(delete-region
(point)
(mark))
(rotate-yank-pointer
arg)
(set-mark
(point))
(insert
( ar
kill-ring-yank-pointer))
(if
before
(ex hange-point-and-mark)))
)
The
fun tion
is
in
tera tiv
e
with
a
small
`p'
so
the
prex
argumen
t
is
pro
 essed
and
passed
to
the
fun tion.
The
 ommand
 an
only
b
e
used
after
a
previous
y
ank;
otherwise
an
error
message
is
sen
t.
This
 
he 
k
uses
the
v
ariable
last- ommand
whi 
h
is
dis ussed
elsewhere.
(See
Se tion
8.5,
\ op
y-
region-as-kill",
page
102.)
The
let
 lause
sets
the
v
ariable
before
to
true
or
false
dep
ending
whether
p
oin
t
is
b
efore
or
after
mark
and
then
the
region
b
et
w
een
p
oin
t
and
mark
is
deleted.
This
is
the
region
that
w
as
just
inserted
b
y
the
previous
y
ank
and
it
is
this
text
that
will
b
e
repla ed.
Next
the
kill-ring-yank-pointer
is
rotated
so
that
the
previously
inserted
text
is
not
reinserted
y
et
again.
Mark
is
set
at
the
b
eginning
of
the
pla e
the
new
text
will
b
e
inserted
and

yank-pop
253
then
the
rst
elemen
t
to
whi 
h
kill-ring-yank-pointer
p
oin
ts
is
inserted.
This
lea
v
es
p
oin
t
after
the
new
text.
If
in
the
previous
y
ank,
p
oin
t
w
as
left
b
efore
the
inserted
text,
p
oin
t
and
mark
are
no
w
ex 
hanged
so
p
oin
t
is
again
left
in
fron
t
of
the
newly
inserted
text.
That
is
all
there
is
to
it!

254
App
endix
B:
Handling
the
Kill
Ring

A
Graph
with
Lab
elled
Axes
255
App
endix
C
A
Graph
with
Lab
elled
Axes
Prin
ted
axes
help
y
ou
understand
a
graph.
They
 on
v
ey
s ale.
In
an
earlier
 
hapter
(see
Chapter
15,
\Readying
a
Graph",
page
203),
w
e
wrote
the
 o
de
to
prin
t
the
b
o
dy
of
a
graph.
Here
w
e
write
the
 o
de
for
prin
ting
and
lab
elling
v
erti al
and
horizon
tal
axes,
along
with
the
b
o
dy
itself.
Sin e
insertions
ll
a
buer
to
the
righ
t
and
b
elo
w
p
oin
t,
the
new
graph
prin
ting
fun tion
should
rst
prin
t
the
Y
or
v
erti al
axis,
then
the
b
o
dy
of
the
graph,
and
nally
the
X
or
horizon
tal
axis.
This
sequen e
la
ys
out
for
us
the
 on
ten
ts
of
the
fun tion:
1.
Set
up
 o
de.
2.
Prin
t
Y
axis.
3.
Prin
t
b
o
dy
of
graph.
4.
Prin
t
X
axis.
Here
is
an
example
of
ho
w
a
nished
graph
should
lo
ok:
10
-
*
*
*
*
**
*
***
5
-
*
*******
*
***
*******
*************
***************
1
-
****************
|
|
|
|
1
5
10
15
In
this
graph,
b
oth
the
v
erti al
and
the
horizon
tal
axes
are
lab
elled
with
n
um
b
ers.
Ho
w
ev
er,
in
some
graphs,
the
horizon
tal
axis
is
time
and
w
ould
b
e
b
etter
lab
elled
with
mon
ths,
lik
e
this:
5
-
*
*
**
*
*******
**********
**
1
-
**************
|
^
|
Jan
June
Jan
Indeed,
with
a
little
though
t,
w
e
 an
easily
 ome
up
with
a
v
ariet
y
of
v
erti al
and
horizon
tal
lab
elling
s 
hemes.
Our
task
 ould
b
e ome
 ompli-
 ated.
But
 ompli ations
breed
 onfusion.
Rather
than
p
ermit
this,
it
is
b
etter
 
ho
ose
a
simple
lab
elling
s 
heme
for
our
rst
eort,
and
to
mo
dify
or
repla e
it
later.

256
App
endix
C:
A
Graph
with
Lab
elled
Axes
These
 onsiderations
suggest
the
follo
wing
outline
for
the
print-graph
fun tion:
(defun
print-graph
(numbers-list)
"do
 umen
tation...
"
(let
((height
...
...
))
(print-Y-axis
height
...
)
(graph-body-print
numbers-list)
(print-X-axis
...
)))
W
e
 an
w
ork
on
ea 
h
part
of
the
print-graph
fun tion
denition
in
turn.
C.1
The
print-graph
V
arlist
In
writing
the
print-graph
fun tion,
the
rst
task
is
to
write
the
v
arlist
in
the
let
expression.
(W
e
will
lea
v
e
aside
for
the
momen
t
an
y
though
ts
ab
out
making
the
fun tion
in
tera tiv
e
or
ab
out
the
 on
ten
ts
of
its
do
 umen
tation
string.)
The
v
arlist
should
set
sev
eral
v
alues.
Clearly
,
the
top
of
the
lab
el
for
the
v
erti al
axis
m
ust
b
e
at
least
the
heigh
t
of
the
graph,
whi 
h
means
that
w
e
m
ust
obtain
this
information
here.
Note
that
the
print-graph-body
fun tion
also
requires
this
information.
There
is
no
reason
to
 al ulate
the
heigh
t
of
the
graph
in
t
w
o
dieren
t
pla es,
so
w
e
should
 
hange
print-
graph-body
from
the
w
a
y
w
e
dened
it
earlier
to
tak
e
adv
an
tage
of
the
 al ulation.
Similarly
,
b
oth
the
fun tion
for
prin
ting
the
X
axis
lab
els
and
the
print-
graph-body
fun tion
need
to
learn
the
v
alue
of
the
width
of
ea 
h
sym
b
ol.
W
e
 an
p
erform
the
 al ulation
here
and
 
hange
the
denition
for
print-
graph-body
from
the
w
a
y
w
e
dened
it
in
the
previous
 
hapter.
The
length
of
the
lab
el
for
the
horizon
tal
axis
m
ust
b
e
at
least
as
long
as
the
graph.
Ho
w
ev
er,
this
information
is
used
only
in
the
fun tion
that
prin
ts
the
horizon
tal
axis,
so
it
do
es
not
need
to
b
e
 al ulated
here.
These
though
ts
lead
us
dire tly
to
the
follo
wing
form
for
the
v
arlist
in
the
let
for
print-graph:
(let
((height
(apply
'max
numbers-list))
;
First
v
ersion.
(symbol-width
(length
graph-blank)))
As
w
e
shall
see,
this
expression
is
not
quite
righ
t.
C.2
The
print-Y-axis
F
un tion
The
job
of
the
print-Y-axis
fun tion
is
to
prin
t
a
lab
el
for
the
v
erti al
axis
that
lo
oks
lik
e
this:

Side
T
rip:
Compute
a
Remainder
257
10
-
5
-
1
-
The
fun tion
should
b
e
passed
the
heigh
t
of
the
graph,
and
then
should
 onstru t
and
insert
the
appropriate
n
um
b
ers
and
marks.
It
is
easy
enough
to
see
in
the
gure
what
the
Y
axis
lab
el
should
lo
ok
lik
e;
but
to
sa
y
in
w
ords,
and
then
to
write
a
fun tion
denition
to
do
the
job
is
another
matter.
It
is
not
quite
true
to
sa
y
that
w
e
w
an
t
a
n
um
b
er
and
a
ti 
ev
ery
v
e
lines:
there
are
only
three
lines
b
et
w
een
the
`1'
and
the
`5'
(lines
2,
3,
and
4),
but
four
lines
b
et
w
een
the
`5'
and
the
`10'
(lines
6,
7,
8,
and
9).
It
is
b
etter
to
sa
y
that
w
e
w
an
t
a
n
um
b
er
and
a
ti 
mark
on
the
base
line
(n
um
b
er
1)
and
then
that
w
e
w
an
t
a
n
um
b
er
and
a
ti 
on
the
fth
line
from
the
b
ottom
and
on
ev
ery
line
that
is
a
m
ultiple
of
v
e.
The
next
issue
is
what
heigh
t
the
lab
el
should
b
e?
Supp
ose
the
maxim
um
heigh
t
of
tallest
 olumn
of
the
graph
is
sev
en.
Should
the
highest
lab
el
on
the
Y
axis
b
e
`5
-',
and
should
the
graph
sti 
k
up
ab
o
v
e
the
lab
el?
Or
should
the
highest
lab
el
b
e
`7
-',
and
mark
the
p
eak
of
the
graph?
Or
should
the
highest
lab
el
b
e
10
-,
whi 
h
is
a
m
ultiple
of
v
e,
and
b
e
higher
than
the
topmost
v
alue
of
the
graph?
The
latter
form
is
preferred.
Most
graphs
are
dra
wn
within
re tangles
whose
sides
are
an
in
tegral
n
um
b
er
of
steps
long|5,
10,
15,
and
so
on
for
a
step
distan e
of
v
e.
But
as
so
on
as
w
e
de ide
to
use
a
step
heigh
t
for
the
v
er-
ti al
axis,
w
e
dis o
v
er
that
the
simple
expression
in
the
v
arlist
for
 omputing
the
heigh
t
is
wrong.
The
expression
is
(apply
'max
numbers-list).
This
returns
the
pre ise
heigh
t,
not
the
maxim
um
heigh
t
plus
whatev
er
is
ne es-
sary
to
round
up
to
the
nearest
m
ultiple
of
v
e.
A
more
 omplex
expression
is
required.
As
usual
in
 ases
lik
e
this,
a
 omplex
problem
b
e omes
simpler
if
it
is
divided
in
to
sev
eral
smaller
problems.
First,
 onsider
the
 ase
when
the
highest
v
alue
of
the
graph
is
an
in
tegral
m
ultiple
of
v
e|when
it
is
5,
10,
15
,or
some
higher
m
ultiple
of
v
e.
W
e
 an
use
this
v
alue
as
the
Y
axis
heigh
t.
A
fairly
simply
w
a
y
to
determine
whether
a
n
um
b
er
is
a
m
ultiple
of
v
e
is
to
divide
it
b
y
v
e
and
see
if
the
division
results
in
a
remainder.
If
there
is
no
remainder,
the
n
um
b
er
is
a
m
ultiple
of
v
e.
Th
us,
sev
en
divided
b
y
v
e
has
a
remainder
of
t
w
o,
and
sev
en
is
not
an
in
tegral
m
ultiple
of
v
e.
Put
in
sligh
tly
dieren
t
language,
more
reminis en
t
of
the
 lassro
om,
v
e
go
es
in
to

258
App
endix
C:
A
Graph
with
Lab
elled
Axes
sev
en
on e,
with
a
remainder
of
t
w
o.
Ho
w
ev
er,
v
e
go
es
in
to
ten
t
wi e,
with
no
remainder:
ten
is
an
in
tegral
m
ultiple
of
v
e.
C.2.1
Side
T
rip:
Compute
a
Remainder
In
Lisp,
the
fun tion
for
 omputing
a
remainder
is
%.
The
fun tion
returns
the
remainder
of
its
rst
argumen
t
divided
b
y
its
se ond
argumen
t.
As
it
happ
ens,
%
is
a
fun tion
in
Ema s
Lisp
that
y
ou
 annot
dis o
v
er
using
apropos:
y
ou
nd
nothing
if
y
ou
t
yp
e
M-x
apropos
h
RET
i
remainder
h
RET
i
.
The
only
w
a
y
to
learn
of
the
existen e
of
%
is
to
read
ab
out
it
in
a
b
o
ok
su 
h
as
this
or
in
the
Ema s
Lisp
sour es.
The
%
fun tion
is
used
in
the
 o
de
for
rotate-yank-pointer,
whi 
h
is
des rib
ed
in
an
app
endix.
(See
Se tion
B.1.1,
\The
Bo
dy
of
rotate-yank-pointer",
page
244.)
Y
ou
 an
try
the
%
fun tion
b
y
ev
aluating
the
follo
wing
t
w
o
expressions:
(%
7
5)
(%
10
5)
The
rst
expression
returns
2
and
the
se ond
expression
returns
0.
T
o
test
whether
the
returned
v
alue
is
zero
or
some
other
n
um
b
er,
w
e
 an
use
the
zerop
fun tion.
This
fun tion
returns
t
if
its
argumen
t,
whi 
h
m
ust
b
e
a
n
um
b
er,
is
zero.
(zerop
(%
7
5))
)
nil
(zerop
(%
10
5))
)
t
Th
us,
the
follo
wing
expression
will
return
t
if
the
heigh
t
of
the
graph
is
ev
enly
divisible
b
y
v
e:
(zerop
(%
height
5))
(The
v
alue
of
height,
of
 ourse,
 an
b
e
found
from
(apply
'max
numbers-
list).)
On
the
other
hand,
if
the
v
alue
of
height
is
not
a
m
ultiple
of
v
e,
w
e
w
an
t
to
reset
the
v
alue
to
the
next
higher
m
ultiple
of
v
e.
This
is
straigh
tforw
ard
arithmeti 
using
fun tions
with
whi 
h
w
e
are
already
familiar.
First,
w
e
divide
the
v
alue
of
height
b
y
v
e
to
determine
ho
w
man
y
times
v
e
go
es
in
to
the
n
um
b
er.
Th
us,
v
e
go
es
in
to
t
w
elv
e
t
wi e.
If
w
e
add
one
to
this
quotien
t
and
m
ultiply
b
y
v
e,
w
e
will
obtain
the
v
alue
of
the
next
m
ultiple
of
v
e
that
is
larger
than
the
heigh
t.
Fiv
e
go
es
in
to
t
w
elv
e
t
wi e.
Add
one
to
t
w
o,
and
m
ultiply
b
y
v
e;
the
result
is
fteen,
whi 
h
is
the
next
m
ultiple
of
v
e
that
is
higher
than
t
w
elv
e.
The
Lisp
expression
for
this
is:
(*
(1+
(/
height
5))
5)
F
or
example,
if
y
ou
ev
aluate
the
follo
wing,
the
result
is
15:
(*
(1+
(/
12
5))
5)

Constru t
a
Y
Axis
Elemen
t
259
All
through
this
dis ussion,
w
e
ha
v
e
b
een
using
`v
e'
as
the
v
alue
for
spa ing
lab
els
on
the
Y
axis;
but
w
e
ma
y
w
an
t
to
use
some
other
v
alue.
F
or
generalit
y
,
w
e
should
repla e
`v
e'
with
a
v
ariable
to
whi 
h
w
e
 an
assign
a
v
alue.
The
b
est
name
I
 an
think
of
for
this
v
ariable
is
Y-axis-label-
spa ing.
Using
this
term,
and
an
if
expression,
w
e
pro
du e
the
follo
wing:
(if
(zerop
(%
height
Y-axis-label-spa ing))
height
;;
else
(*
(1+
(/
height
Y-axis-label-spa ing))
Y-axis-label-spa ing))
This
expression
returns
the
v
alue
of
height
itself
if
the
heigh
t
is
an
ev
en
m
ultiple
of
the
v
alue
of
the
Y-axis-label-spa ing
or
else
it
 omputes
and
returns
a
v
alue
of
height
that
is
equal
to
the
next
higher
m
ultiple
of
the
v
alue
of
the
Y-axis-label-spa ing.
W
e
 an
no
w
in lude
this
expression
in
the
let
expression
of
the
print-
graph
fun tion
(after
rst
setting
the
v
alue
of
Y-axis-label-spa ing):
(defvar
Y-axis-label-spa ing
5
"Number
of
lines
from
one
Y
axis
label
to
next.")
...
(let*
((height
(apply
'max
numbers-list))
(height-of-top-line
(if
(zerop
(%
height
Y-axis-label-spa ing))
height
;;
else
(*
(1+
(/
height
Y-axis-label-spa ing))
Y-axis-label-spa ing)))
(symbol-width
(length
graph-blank))))
...
(Note
use
of
the
let*
fun tion:
the
initial
v
alue
of
heigh
t
is
 omputed
on e
b
y
the
(apply
'max
numbers-list)
expression
and
then
the
resulting
v
alue
of
height
is
used
to
 ompute
its
nal
v
alue.
See
\The
let*
expression",
page
156,
for
more
ab
out
let*.)
C.2.2
Constru t
a
Y
Axis
Elemen
t
When
w
e
prin
t
the
v
erti al
axis,
w
e
w
an
t
to
insert
strings
su 
h
as
`5
-'
and
`10
-
'
ev
ery
v
e
lines.
Moreo
v
er,
w
e
w
an
t
the
n
um
b
ers
and
dashes
to
line
up,
so
shorter
n
um
b
ers
m
ust
b
e
padded
with
leading
spa es.
If
some
of
the
strings
use
t
w
o
digit
n
um
b
ers,
the
strings
with
single
digit
n
um
b
ers
m
ust
in lude
a
leading
blank
spa e
b
efore
the
n
um
b
er.
T
o
gure
out
the
length
of
the
n
um
b
er,
the
length
fun tion
is
used.
But
the
length
fun tion
w
orks
only
with
a
string,
not
with
a
n
um
b
er.
So
the

260
App
endix
C:
A
Graph
with
Lab
elled
Axes
n
um
b
er
has
to
b
e
 on
v
erted
from
b
eing
a
n
um
b
er
to
b
eing
a
string.
This
is
done
with
the
number-to-string
fun tion.
F
or
example,
(length
(number-to-string
35))
)
2
(length
(number-to-string
100))
)
3
(number-to-string
is
also
 alled
int-to-string;
y
ou
will
see
this
alterna-
tiv
e
name
in
v
arious
sour es.)
In
addition,
in
ea 
h
lab
el,
ea 
h
n
um
b
er
is
follo
w
ed
b
y
a
string
su 
h
as
`
-
',
whi 
h
w
e
will
 all
the
Y-axis-ti 
mark
er.
This
v
ariable
is
dened
with
defvar:
(defvar
Y-axis-ti 
"
-
"
"String
that
follows
number
in
a
Y
axis
label.")
The
length
of
the
Y
lab
el
is
the
sum
of
the
length
of
the
Y
axis
ti 
mark
and
the
length
of
the
n
um
b
er
of
the
top
of
the
graph.
(length
( on at
(number-to-string
height)
Y-axis-ti )))
This
v
alue
will
b
e
 al ulated
b
y
the
print-graph
fun tion
in
its
v
arlist
as
full-Y-label-width
and
passed
on.
(Note
that
w
e
did
not
think
to
in lude
this
in
the
v
arlist
when
w
e
rst
prop
osed
it.)
T
o
mak
e
a
 omplete
v
erti al
axis
lab
el,
a
ti 
mark
is
 on atenated
with
a
n
um
b
er;
and
the
t
w
o
together
ma
y
b
e
pre eded
b
y
one
or
more
spa es
dep
ending
on
ho
w
long
the
n
um
b
er
is.
The
lab
el
 onsists
of
three
parts:
the
(optional)
leading
spa es,
the
n
um
b
er,
and
the
ti 
mark.
The
fun tion
is
passed
the
v
alue
of
the
n
um
b
er
for
the
sp
e i 
ro
w,
and
the
v
alue
of
the
width
of
the
top
line,
whi 
h
is
 al ulated
(just
on e)
b
y
print-graph.
(defun
Y-axis-element
(number
full-Y-label-width)
"Constru t
a
NUMBERed
label
element.
A
numbered
element
looks
like
this
`
5
-
',
and
is
padded
as
needed
so
all
line
up
with
the
element
for
the
largest
number."
(let*
((leading-spa es
(-
full-Y-label-width
(length
( on at
(number-to-string
number)
Y-axis-ti )))))
( on at
(make-string
leading-spa es
?
)
(number-to-string
number)
Y-axis-ti )))
The
Y-axis-element
fun tion
 on atenates
together
the
leading
spa es,
if
an
y;
the
n
um
b
er,
as
a
string;
and
the
ti 
mark.

The
Not
Quite
Final
V
ersion
of
print-Y-axis
261
T
o
gure
out
ho
w
man
y
leading
spa es
the
lab
el
will
need,
the
fun tion
subtra ts
the
a tual
length
of
the
lab
el|the
length
of
the
n
um
b
er
plus
the
length
of
the
ti 
mark|from
the
desired
lab
el
width.
Blank
spa es
are
inserted
using
the
make-string
fun tion.
This
fun tion
tak
es
t
w
o
argumen
ts:
the
rst
tells
it
ho
w
long
the
string
will
b
e
and
the
se ond
is
a
sym
b
ol
for
the
 
hara ter
to
insert,
in
a
sp
e ial
format.
The
format
is
a
question
mark
follo
w
ed
b
y
a
blank
spa e,
lik
e
this,
`?
'.
See
se tion
\Chara ter
T
yp
e"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
a
des ription
of
the
syn
tax
for
 
hara ters.
The
number-to-string
fun tion
is
used
in
the
 on atenation
expression,
to
 on
v
ert
the
n
um
b
er
to
a
string
that
is
 on atenated
with
the
leading
spa es
and
the
ti 
mark.
C.2.3
Create
a
Y
Axis
Column
The
pre eding
fun tions
pro
vide
all
the
to
ols
needed
to
 onstru t
a
fun -
tion
that
generates
a
list
of
n
um
b
ered
and
blank
strings
to
insert
as
the
lab
el
for
the
v
erti al
axis:
(defun
Y-axis- olumn
(height
width-of-label)
"Constru t
list
of
Y
axis
labels
and
blank
strings.
For
HEIGHT
of
line
above
base
and
WIDTH-OF-LABEL."
(let
(Y-axis)
(while
(>
height
1)
(if
(zerop
(%
height
Y-axis-label-spa ing))
;;
Insert
lab
el.
(setq
Y-axis
( ons
(Y-axis-element
height
width-of-label)
Y-axis))
;;
Else,
insert
blanks.
(setq
Y-axis
( ons
(make-string
width-of-label
?
)
Y-axis)))
(setq
height
(1-
height)))
;;
Insert
base
line.
(setq
Y-axis
( ons
(Y-axis-element
1
width-of-label)
Y-axis))
(nreverse
Y-axis)))
In
this
fun tion,
w
e
start
with
the
v
alue
of
height
and
rep
etitiv
ely
sub-
tra t
one
from
its
v
alue.
After
ea 
h
subtra tion,
w
e
test
to
see
whether
the
v
alue
is
an
in
tegral
m
ultiple
of
the
Y-axis-label-spa ing.
If
it
is,
w
e
 onstru t
a
n
um
b
ered
lab
el
using
the
Y-axis-element
fun tion;
if
not,

262
App
endix
C:
A
Graph
with
Lab
elled
Axes
w
e
 onstru t
a
blank
lab
el
using
the
make-string
fun tion.
The
base
line
 onsists
of
the
n
um
b
er
one
follo
w
ed
b
y
a
ti 
mark.
C.2.4
The
Not
Quite
Final
V
ersion
of
print-Y-axis
The
list
 onstru ted
b
y
the
Y-axis- olumn
fun tion
is
passed
to
the
print-Y-axis
fun tion,
whi 
h
inserts
the
list
as
a
 olumn.
(defun
print-Y-axis
(height
full-Y-label-width)
"Insert
Y
axis
using
HEIGHT
and
FULL-Y-LABEL-WIDTH.
Height
must
be
the
maximum
height
of
the
graph.
Full
width
is
the
width
of
the
highest
label
element."
;;
Value
of
height
and
full-Y-label-width
;;
are
passed
by
`print-graph'.
(let
((start
(point)))
(insert-re tangle
(Y-axis- olumn
height
full-Y-label-width))
;;
Pla e
p
oin
t
ready
for
inserting
graph.
(goto- har
start)
;;
Mo
v
e
p
oin
t
forw
ard
b
y
v
alue
of
full-Y-label-width
(forward- har
full-Y-label-width)))
The
print-Y-axis
uses
the
insert-re tangle
fun tion
to
insert
the
Y
axis
lab
els
 reated
b
y
the
Y-axis- olumn
fun tion.
In
addition,
it
pla es
p
oin
t
at
the
 orre t
p
osition
for
prin
ting
the
b
o
dy
of
the
graph.
Y
ou
 an
test
print-Y-axis:
1.
Install
Y-axis-label-spa ing
Y-axis-ti 
Y-axis-element
Y-axis- olumn
print-Y-axis
2.
Cop
y
the
follo
wing
expression:
(print-Y-axis
12
5)
3.
Swit 
h
to
the
`*s rat h*'
buer
and
pla e
the
 ursor
where
y
ou
w
an
t
the
axis
lab
els
to
start.
4.
T
yp
e
M-:
(eval-expression).
5.
Y
ank
the
graph-body-print
expression
in
to
the
minibuer
with
C-y
(yank).
6.
Press
h
RET
i
to
ev
aluate
the
expression.
Ema s
will
prin
t
lab
els
v
erti ally
,
the
top
one
b
eing
`10
-
'.
(The
print-
graph
fun tion
will
pass
the
v
alue
of
height-of-top-line,
whi 
h
in
this
 ase
w
ould
end
up
as
15.)

X
Axis
Ti 
Marks
263
C.3
The
print-X-axis
F
un tion
X
axis
lab
els
are
m
u 
h
lik
e
Y
axis
lab
els,
ex ept
that
the
ti s
are
on
a
line
ab
o
v
e
the
n
um
b
ers.
Lab
els
should
lo
ok
lik
e
this:
|
|
|
|
1
5
10
15
The
rst
ti 
is
under
the
rst
 olumn
of
the
graph
and
is
pre eded
b
y
sev
eral
blank
spa es.
These
spa es
pro
vide
ro
om
in
ro
ws
ab
o
v
e
for
the
Y
axis
lab
els.
The
se ond,
third,
fourth,
and
subsequen
t
ti s
are
all
spa ed
equally
,
a  ording
to
the
v
alue
of
X-axis-label-spa ing.
The
se ond
ro
w
of
the
X
axis
 onsists
of
n
um
b
ers,
pre eded
b
y
sev
eral
blank
spa es
and
also
separated
a  ording
to
the
v
alue
of
the
v
ariable
X-
axis-label-spa ing.
The
v
alue
of
the
v
ariable
X-axis-label-spa ing
should
itself
b
e
mea-
sured
in
units
of
symbol-width,
sin e
y
ou
ma
y
w
an
t
to
 
hange
the
width
of
the
sym
b
ols
that
y
ou
are
using
to
prin
t
the
b
o
dy
of
the
graph
without
 
hanging
the
w
a
ys
the
graph
is
lab
elled.
The
print-X-axis
fun tion
is
 onstru ted
in
more
or
less
the
same
fash-
ion
as
the
print-Y-axis
fun tion
ex ept
that
it
has
t
w
o
lines:
the
line
of
ti 
marks
and
the
n
um
b
ers.
W
e
will
write
a
separate
fun tion
to
prin
t
ea 
h
line
and
then
 om
bine
them
within
the
print-X-axis
fun tion.
This
is
a
three
step
pro
 ess:
1.
W
rite
a
fun tion
to
prin
t
the
X
axis
ti 
marks,
print-X-axis-ti -line.
2.
W
rite
a
fun tion
to
prin
t
the
X
n
um
b
ers,
print-X-axis-numbered-
line.
3.
W
rite
a
fun tion
to
prin
t
b
oth
lines,
the
print-X-axis
fun tion,
using
print-X-axis-ti -line
and
print-X-axis-numbered-line
.
C.3.1
X
Axis
Ti 
Marks
The
rst
fun tion
should
prin
t
the
X
axis
ti 
marks.
W
e
m
ust
sp
e ify
the
ti 
marks
themselv
es
and
their
spa ing:
(defvar
X-axis-label-spa ing
(if
(boundp
'graph-blank)
(*
5
(length
graph-blank))
5)
"Number
of
units
from
one
X
axis
label
to
next.")
(Note
that
the
v
alue
of
graph-blank
is
set
b
y
another
defvar.
The
boundp
predi ate
 
he 
ks
whether
it
has
already
b
een
set;
boundp
returns
nil
if
it
has
not.
If
graph-blank
w
ere
un
b
ound
and
w
e
did
not
use
this
 onditional
 onstru tion,
in
GNU
Ema s
21,
w
e
w
ould
en
ter
the
de-
bugger
and
see
an
error
message
sa
ying
`Debugger
entered--Lisp
error:
(void-variable
graph-blank)
'.)

264
App
endix
C:
A
Graph
with
Lab
elled
Axes
Here
is
the
defvar
for
X-axis-ti -symbol:
(defvar
X-axis-ti -symbol
"|"
"String
to
insert
to
point
to
a
 olumn
in
X
axis.")
The
goal
is
to
mak
e
a
line
that
lo
oks
lik
e
this:
|
|
|
|
The
rst
ti 
is
inden
ted
so
that
it
is
under
the
rst
 olumn,
whi 
h
is
inden
ted
to
pro
vide
spa e
for
the
Y
axis
lab
els.
A
ti 
elemen
t
 onsists
of
the
blank
spa es
that
stret 
h
from
one
ti 
to
the
next
plus
a
ti 
sym
b
ol.
The
n
um
b
er
of
blanks
is
determined
b
y
the
width
of
the
ti 
sym
b
ol
and
the
X-axis-label-spa ing.
The
 o
de
lo
oks
lik
e
this:
;;;
X-axis-ti -element
...
( on at
(make-string
;;
Mak
e
a
string
of
blanks.
(-
(*
symbol-width
X-axis-label-spa ing)
(length
X-axis-ti -symbol))
?
)
;;
Con atenate
blanks
with
ti 
sym
b
ol.
X-axis-ti -symbol)
...
Next,
w
e
determine
ho
w
man
y
blanks
are
needed
to
inden
t
the
rst
ti 
mark
to
the
rst
 olumn
of
the
graph.
This
uses
the
v
alue
of
full-Y-label-
width
passed
it
b
y
the
print-graph
fun tion.
The
 o
de
to
mak
e
X-axis-leading-spa es
lo
oks
lik
e
this:
;;
X-axis-leading-spa es
...
(make-string
full-Y-label-width
?
)
...
W
e
also
need
to
determine
the
length
of
the
horizon
tal
axis,
whi 
h
is
the
length
of
the
n
um
b
ers
list,
and
the
n
um
b
er
of
ti s
in
the
horizon
tal
axis:
;;
X-length
...
(length
numbers-list)
;;
ti -width
...
(*
symbol-width
X-axis-label-spa ing)

X
Axis
Ti 
Marks
265
;;
number-of-X-ti s
(if
(zerop
(%
(X-length
ti -width)))
(/
(X-length
ti -width))
(1+
(/
(X-length
ti -width))))
All
this
leads
us
dire tly
to
the
fun tion
for
prin
ting
the
X
axis
ti 
line:
(defun
print-X-axis-ti -line
(number-of-X-ti s
X-axis-leading-spa es
X-axis-ti -element)
"Print
ti s
for
X
axis."
(insert
X-axis-leading-spa es)
(insert
X-axis-ti -symbol)
;
Under
rst
 olumn.
;;
Insert
se ond
ti 
in
the
righ
t
sp
ot.
(insert
( on at
(make-string
(-
(*
symbol-width
X-axis-label-spa ing)
;;
Insert
white
spa e
up
to
se ond
ti 
sym
b
ol.
(*
2
(length
X-axis-ti -symbol)))
?
)
X-axis-ti -symbol))
;;
Insert
remaining
ti s.
(while
(>
number-of-X-ti s
1)
(insert
X-axis-ti -element)
(setq
number-of-X-ti s
(1-
number-of-X-ti s))))
The
line
of
n
um
b
ers
is
equally
straigh
tforw
ard:
First,
w
e
 reate
a
n
um
b
ered
elemen
t
with
blank
spa es
b
efore
ea 
h
n
um-
b
er:
(defun
X-axis-element
(number)
"Constru t
a
numbered
X
axis
element."
(let
((leading-spa es
(-
(*
symbol-width
X-axis-label-spa ing)
(length
(number-to-string
number)))))
( on at
(make-string
leading-spa es
?
)
(number-to-string
number))))
Next,
w
e
 reate
the
fun tion
to
prin
t
the
n
um
b
ered
line,
starting
with
the
n
um
b
er
\1"
under
the
rst
 olumn:
(defun
print-X-axis-numbered-line
(number-of-X-ti s
X-axis-leading-spa es)
"Print
line
of
X-axis
numbers"
(let
((number
X-axis-label-spa ing))
(insert
X-axis-leading-spa es)
(insert
"1")

266
App
endix
C:
A
Graph
with
Lab
elled
Axes
(insert
( on at
(make-string
;;
Insert
white
spa e
up
to
next
n
um
b
er.
(-
(*
symbol-width
X-axis-label-spa ing)
2)
?
)
(number-to-string
number)))
;;
Insert
remaining
n
um
b
ers.
(setq
number
(+
number
X-axis-label-spa ing))
(while
(>
number-of-X-ti s
1)
(insert
(X-axis-element
number))
(setq
number
(+
number
X-axis-label-spa ing))
(setq
number-of-X-ti s
(1-
number-of-X-ti s)))))
Finally
,
w
e
need
to
write
the
print-X-axis
that
uses
print-X-axis-
ti -line
and
print-X-axis-numbered-li
ne.
The
fun tion
m
ust
determine
the
lo
 al
v
alues
of
the
v
ariables
used
b
y
b
oth
print-X-axis-ti -line
and
print-X-axis-numbered-lin
e,
and
then
it
m
ust
 all
them.
Also,
it
m
ust
prin
t
the
 arriage
return
that
separates
the
t
w
o
lines.
The
fun tion
 onsists
of
a
v
arlist
that
sp
e ies
v
e
lo
 al
v
ariables,
and
 alls
to
ea 
h
of
the
t
w
o
line
prin
ting
fun tions:
(defun
print-X-axis
(numbers-list)
"Print
X
axis
labels
to
length
of
NUMBERS-LIST."
(let*
((leading-spa es
(make-string
full-Y-label-width
?
))
;;
symbol-width
is
pro
vided
b
y
graph-body-print
(ti -width
(*
symbol-width
X-axis-label-spa ing))
(X-length
(length
numbers-list))
(X-ti 
( on at
(make-string
;;
Mak
e
a
string
of
blanks.
(-
(*
symbol-width
X-axis-label-spa ing)
(length
X-axis-ti -symbol))
?
)
;;
Con atenate
blanks
with
ti 
sym
b
ol.
X-axis-ti -symbol))
(ti -number
(if
(zerop
(%
X-length
ti -width))
(/
X-length
ti -width)
(1+
(/
X-length
ti -width)))))
(print-X-axis-ti -line
ti -number
leading-spa es
X-ti )
(insert
"\n")
(print-X-axis-numbered-line
ti -number
leading-spa es)))

Prin
ting
the
Whole
Graph
267
Y
ou
 an
test
print-X-axis:
1.
Install
X-axis-ti -symbol,
X-axis-label-spa ing,
print-X-axis-
ti -line,
as
w
ell
as
X-axis-element,
print-X-axis-numbered-li
ne,
and
print-X-axis.
2.
Cop
y
the
follo
wing
expression:
(progn
(let
((full-Y-label-width
5)
(symbol-width
1))
(print-X-axis
'(1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16))))
3.
Swit 
h
to
the
`*s rat h*'
buer
and
pla e
the
 ursor
where
y
ou
w
an
t
the
axis
lab
els
to
start.
4.
T
yp
e
M-:
(eval-expression).
5.
Y
ank
the
test
expression
in
to
the
minibuer
with
C-y
(yank).
6.
Press
h
RET
i
to
ev
aluate
the
expression.
Ema s
will
prin
t
the
horizon
tal
axis
lik
e
this:
|
|
|
|
|
1
5
10
15
20
C.4
Prin
ting
the
Whole
Graph
No
w
w
e
are
nearly
ready
to
prin
t
the
whole
graph.
The
fun tion
to
prin
t
the
graph
with
the
prop
er
lab
els
follo
ws
the
out-
line
w
e
 reated
earlier
(see
App
endix
C,
\A
Graph
with
Lab
elled
Axes",
page
255),
but
with
additions.
Here
is
the
outline:
(defun
print-graph
(numbers-list)
"do
 umen
tation...
"
(let
((height
...
...
))
(print-Y-axis
height
...
)
(graph-body-print
numbers-list)
(print-X-axis
...
)))
The
nal
v
ersion
is
dieren
t
from
what
w
e
planned
in
t
w
o
w
a
ys:
rst,
it
 on
tains
additional
v
alues
 al ulated
on e
in
the
v
arlist;
se ond,
it
 arries
an
option
to
sp
e ify
the
lab
els'
in remen
t
p
er
ro
w.
This
latter
feature
turns
out
to
b
e
essen
tial;
otherwise,
a
graph
ma
y
ha
v
e
more
ro
ws
than
t
on
a
displa
y
or
on
a
sheet
of
pap
er.

268
App
endix
C:
A
Graph
with
Lab
elled
Axes
This
new
feature
requires
a
 
hange
to
the
Y-axis- olumn
fun tion,
to
add
verti al-step
to
it.
The
fun tion
lo
oks
lik
e
this:
;;;
Final
v
ersion.
(defun
Y-axis- olumn
(height
width-of-label
&optional
verti al-step)
"Constru t
list
of
labels
for
Y
axis.
HEIGHT
is
maximum
height
of
graph.
WIDTH-OF-LABEL
is
maximum
width
of
label.
VERTICAL-STEP,
an
option,
is
a
positive
integer
that
spe ifies
how
mu h
a
Y
axis
label
in rements
for
ea h
line.
For
example,
a
step
of
5
means
that
ea h
line
is
five
units
of
the
graph."
(let
(Y-axis
(number-per-line
(or
verti al-step
1)))
(while
(>
height
1)
(if
(zerop
(%
height
Y-axis-label-spa ing))
;;
Insert
lab
el.
(setq
Y-axis
( ons
(Y-axis-element
(*
height
number-per-line)
width-of-label)
Y-axis))
;;
Else,
insert
blanks.
(setq
Y-axis
( ons
(make-string
width-of-label
?
)
Y-axis)))
(setq
height
(1-
height)))
;;
Insert
base
line.
(setq
Y-axis
( ons
(Y-axis-element
(or
verti al-step
1)
width-of-label)
Y-axis))
(nreverse
Y-axis)))
The
v
alues
for
the
maxim
um
heigh
t
of
graph
and
the
width
of
a
sym
b
ol
are
 omputed
b
y
print-graph
in
its
let
expression;
so
graph-body-print
m
ust
b
e
 
hanged
to
a  ept
them.

Prin
ting
the
Whole
Graph
269
;;;
Final
v
ersion.
(defun
graph-body-print
(numbers-list
height
symbol-width)
"Print
a
bar
graph
of
the
NUMBERS-LIST.
The
numbers-list
 onsists
of
the
Y-axis
values.
HEIGHT
is
maximum
height
of
graph.
SYMBOL-WIDTH
is
number
of
ea h
 olumn."
(let
(from-position)
(while
numbers-list
(setq
from-position
(point))
(insert-re tangle
( olumn-of-graph
height
( ar
numbers-list)))
(goto- har
from-position)
(forward- har
symbol-width)
;;
Dra
w
graph
 olumn
b
y
 olumn.
(sit-for
0)
(setq
numbers-list
( dr
numbers-list)))
;;
Pla e
p
oin
t
for
X
axis
lab
els.
(forward-line
height)
(insert
"\n")))
Finally
,
the
 o
de
for
the
print-graph
fun tion:
;;;
Final
v
ersion.
(defun
print-graph
(numbers-list
&optional
verti al-step)
"Print
labelled
bar
graph
of
the
NUMBERS-LIST.
The
numbers-list
 onsists
of
the
Y-axis
values.
Optionally,
VERTICAL-STEP,
a
positive
integer,
spe ifies
how
mu h
a
Y
axis
label
in rements
for
ea h
line.
For
example,
a
step
of
5
means
that
ea h
row
is
five
units."
(let*
((symbol-width
(length
graph-blank))
;;
height
is
b
oth
the
largest
n
um
b
er
;;
and
the
n
um
b
er
with
the
most
digits.
(height
(apply
'max
numbers-list))
(height-of-top-line
(if
(zerop
(%
height
Y-axis-label-spa ing))
height
;;
else
(*
(1+
(/
height
Y-axis-label-spa ing))
Y-axis-label-spa ing)))
(verti al-step
(or
verti al-step
1))
(full-Y-label-width
(length

270
App
endix
C:
A
Graph
with
Lab
elled
Axes
( on at
(number-to-string
(*
height-of-top-line
verti al-step))
Y-axis-ti ))))
(print-Y-axis
height-of-top-line
full-Y-label-width
verti al-step)
(graph-body-print
numbers-list
height-of-top-line
symbol-width)
(print-X-axis
numbers-list)))
C.4.1
T
esting
print-graph
W
e
 an
test
the
print-graph
fun tion
with
a
short
list
of
n
um
b
ers:
1.
Install
the
nal
v
ersions
of
Y-axis- olumn,
graph-body-print,
and
print-graph
(in
addition
to
the
rest
of
the
 o
de.)
2.
Cop
y
the
follo
wing
expression:
(print-graph
'(3
2
5
6
7
5
3
4
6
4
3
2
1))
3.
Swit 
h
to
the
`*s rat h*'
buer
and
pla e
the
 ursor
where
y
ou
w
an
t
the
axis
lab
els
to
start.
4.
T
yp
e
M-:
(eval-expression).
5.
Y
ank
the
test
expression
in
to
the
minibuer
with
C-y
(yank).
6.
Press
h
RET
i
to
ev
aluate
the
expression.
Ema s
will
prin
t
a
graph
that
lo
oks
lik
e
this:
10
-
*
**
*
5
-
****
*
****
***
*
*********
************
1
-
*************
|
|
|
|
1
5
10
15
On
the
other
hand,
if
y
ou
pass
print-graph
a
verti al-step
v
alue
of
2,
b
y
ev
aluating
this
expression:
(print-graph
'(3
2
5
6
7
5
3
4
6
4
3
2
1)
2)

Graphing
Num
b
ers
of
W
ords
and
Sym
b
ols
271
The
graph
lo
oks
lik
e
this:
20
-
*
**
*
10
-
****
*
****
***
*
*********
************
2
-
*************
|
|
|
|
1
5
10
15
(A
question:
is
the
`2'
on
the
b
ottom
of
the
v
erti al
axis
a
bug
or
a
feature?
If
y
ou
think
it
is
a
bug,
and
should
b
e
a
`1'
instead,
(or
ev
en
a
`0'),
y
ou
 an
mo
dify
the
sour es.)
C.4.2
Graphing
Num
b
ers
of
W
ords
and
Sym
b
ols
No
w
for
the
graph
for
whi 
h
all
this
 o
de
w
as
written:
a
graph
that
sho
ws
ho
w
man
y
fun tion
denitions
 on
tain
few
er
than
10
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain
b
et
w
een
10
and
19
w
ords
and
sym
b
ols,
ho
w
man
y
 on
tain
b
et
w
een
20
and
29
w
ords
and
sym
b
ols,
and
so
on.
This
is
a
m
ulti-step
pro
 ess.
First
mak
e
sure
y
ou
ha
v
e
loaded
all
the
requisite
 o
de.
It
is
a
go
o
d
idea
to
reset
the
v
alue
of
top-of-ranges
in
 ase
y
ou
ha
v
e
set
it
to
some
dieren
t
v
alue.
Y
ou
 an
ev
aluate
the
follo
wing:
(setq
top-of-ranges
'(10
20
30
40
50
60
70
80
90
100
110
120
130
140
150
160
170
180
190
200
210
220
230
240
250
260
270
280
290
300)
Next
 reate
a
list
of
the
n
um
b
er
of
w
ords
and
sym
b
ols
in
ea 
h
range.

272
App
endix
C:
A
Graph
with
Lab
elled
Axes
Ev
aluate
the
follo
wing:
(setq
list-for-graph
(defuns-per-range
(sort
(re ursive-lengths-list-many
-fil
es
(dire tory-files
"/usr/lo al/ema s/lisp"
t
".+el$"))
'<)
top-of-ranges))
On
m
y
ma 
hine,
this
tak
es
ab
out
an
hour.
It
lo
oks
though
303
Lisp
les
in
m
y
 op
y
of
Ema s
v
ersion
19.23.
After
all
that
 omputing,
the
list-for-
graph
has
this
v
alue:
(537
1027
955
785
594
483
349
292
224
199
166
120
116
99
90
80
67
48
52
45
41
33
28
26
25
20
12
28
11
13
220)
This
means
that
m
y
 op
y
of
Ema s
has
537
fun tion
denitions
with
few
er
than
10
w
ords
or
sym
b
ols
in
them,
1,027
fun tion
denitions
with
10
to
19
w
ords
or
sym
b
ols
in
them,
955
fun tion
denitions
with
20
to
29
w
ords
or
sym
b
ols
in
them,
and
so
on.
Clearly
,
just
b
y
lo
oking
at
this
list
w
e
 an
see
that
most
fun tion
deni-
tions
 on
tain
ten
to
thirt
y
w
ords
and
sym
b
ols.
No
w
for
prin
ting.
W
e
do
not
w
an
t
to
prin
t
a
graph
that
is
1,030
lines
high
.
.
.
Instead,
w
e
should
prin
t
a
graph
that
is
few
er
than
t
w
en
t
y-v
e
lines
high.
A
graph
that
heigh
t
 an
b
e
displa
y
ed
on
almost
an
y
monitor,
and
easily
prin
ted
on
a
sheet
of
pap
er.
This
means
that
ea 
h
v
alue
in
list-for-graph
m
ust
b
e
redu ed
to
one-
ftieth
its
presen
t
v
alue.
Here
is
a
short
fun tion
to
do
just
that,
using
t
w
o
fun tions
w
e
ha
v
e
not
y
et
seen,
map ar
and
lambda.
(defun
one-fiftieth
(full-range)
"Return
list,
ea h
number
one-fiftieth
of
previous."
(map ar
'(lambda
(arg)
(/
arg
50))
full-range))
C.4.3
A
lambda
Expression:
Useful
Anon
ymit
y
lambda
is
the
sym
b
ol
for
an
anon
ymous
fun tion,
a
fun tion
without
a
name.
Ev
ery
time
y
ou
use
an
anon
ymous
fun tion,
y
ou
need
to
in lude
its
whole
b
o
dy
.

The
map ar
F
un tion
273
Th
us,
(lambda
(arg)
(/
arg
50))
is
a
fun tion
denition
that
sa
ys
`return
the
v
alue
resulting
from
dividing
whatev
er
is
passed
to
me
as
arg
b
y
50'.
Earlier,
for
example,
w
e
had
a
fun tion
multiply-by-seven;
it
m
ultiplied
its
argumen
t
b
y
7.
This
fun tion
is
similar,
ex ept
it
divides
its
argumen
t
b
y
50;
and,
it
has
no
name.
The
anon
ymous
equiv
alen
t
of
multiply-by-seven
is:
(lambda
(number)
(*
7
number))
(See
Se tion
3.1,
\The
defun
Sp
e ial
F
orm",
page
29.)
If
w
e
w
an
t
to
m
ultiply
3
b
y
7,
w
e
 an
write:
(multiply-by-seven 3)
function
argument
This
expression
returns
21.
Similarly
,
w
e
 an
write:
((lambda (number) (* 7 number)) 3)
anonymous function
argument
If
w
e
w
an
t
to
divide
100
b
y
50,
w
e
 an
write:
((lambda (arg) (/ arg 50)) 100)
anonymous function argument
This
expression
returns
2.
The
100
is
passed
to
the
fun tion,
whi 
h
divides
that
n
um
b
er
b
y
50.
See
se tion
\Lam
b
da
Expressions"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
lambda.
Lisp
and
lam
b
da
expressions
deriv
e
from
the
Lam
b
da
Cal ulus.

274
App
endix
C:
A
Graph
with
Lab
elled
Axes
C.4.4
The
map ar
F
un tion
map ar
is
a
fun tion
that
 alls
its
rst
argumen
t
with
ea 
h
elemen
t
of
its
se ond
argumen
t,
in
turn.
The
se ond
argumen
t
m
ust
b
e
a
sequen e.
The
`map'
part
of
the
name
 omes
from
the
mathemati al
phrase,
`map-
ping
o
v
er
a
domain',
meaning
to
apply
a
fun tion
to
ea 
h
of
the
elemen
ts
in
a
domain.
The
mathemati al
phrase
is
based
on
the
metaphor
of
a
surv
ey
or
w
alking,
one
step
at
a
time,
o
v
er
an
area
he
is
mapping.
And
` ar',
of
 ourse,
 omes
from
the
Lisp
notion
of
the
rst
of
a
list.
F
or
example,
(map ar
'1+
'(2
4
6))
)
(3
5
7)
The
fun tion
1+
whi 
h
adds
one
to
its
argumen
t,
is
exe uted
on
e
a h
elemen
t
of
the
list,
and
a
new
list
is
returned.
Con
trast
this
with
apply,
whi 
h
applies
its
rst
argumen
t
to
all
the
re-
maining.
(See
Chapter
15,
\Readying
a
Graph",
page
203,
for
a
explanation
of
apply.)
In
the
denition
of
one-fiftieth,
the
rst
argumen
t
is
the
anon
ymous
fun tion:
(lambda
(arg)
(/
arg
50))
and
the
se ond
argumen
t
is
full-range,
whi 
h
will
b
e
b
ound
to
list-for-
graph.
The
whole
expression
lo
oks
lik
e
this:
(map ar
'(lambda
(arg)
(/
arg
50))
full-range))
See
se tion
\Mapping
F
un tions"
in
The
GNU
Ema s
Lisp
Referen e
Man
ual
,
for
more
ab
out
map ar.
Using
the
one-fiftieth
fun tion,
w
e
 an
generate
a
list
in
whi 
h
ea 
h
elemen
t
is
one-ftieth
the
size
of
the
 orresp
onding
elemen
t
in
list-for-
graph.
(setq
fiftieth-list-for-graph
(one-fiftieth
list-for-graph))
The
resulting
list
lo
oks
lik
e
this:
(10
20
19
15
11
9
6
5
4
3
3
2
2
1
1
1
1
0
1
0
0
0
0
0
0
0
0
0
0
0
4)
This,
w
e
are
almost
ready
to
prin
t!
(W
e
also
noti e
the
loss
of
information:
man
y
of
the
higher
ranges
are
0,
meaning
that
few
er
than
50
defuns
had
that
man
y
w
ords
or
sym
b
ols|but
not
ne essarily
meaning
that
none
had
that
man
y
w
ords
or
sym
b
ols.)
C.4.5
Another
Bug
.
.
.
Most
Insidious
I
said
`almost
ready
to
prin
t'
!
Of
 ourse,
there
is
a
bug
in
the
print-
graph
fun tion
.
.
.
It
has
a
verti al-step
option,
but
not
a
horizontal-

Another
Bug
.
.
.
Most
Insidious
275
step
option.
The
top-of-range
s ale
go
es
from
10
to
300
b
y
tens.
But
the
print-graph
fun tion
will
prin
t
only
b
y
ones.
This
is
a
 lassi 
example
of
what
some
 onsider
the
most
insidious
t
yp
e
of
bug,
the
bug
of
omission.
This
is
not
the
kind
of
bug
y
ou
 an
nd
b
y
studying
the
 o
de,
for
it
is
not
in
the
 o
de;
it
is
an
omitted
feature.
Y
our
b
est
a tions
are
to
try
y
our
program
early
and
often;
and
try
to
arrange,
as
m
u 
h
as
y
ou
 an,
to
write
 o
de
that
is
easy
to
understand
and
easy
to
 
hange.
T
ry
to
b
e
a
w
are,
whenev
er
y
ou
 an,
that
whatev
er
y
ou
ha
v
e
written,
wil
l
b
e
rewritten,
if
not
so
on,
ev
en
tually
.
A
hard
maxim
to
follo
w.
It
is
the
print-X-axis-numbered-li
ne
fun tion
that
needs
the
w
ork;
and
then
the
print-X-axis
and
the
print-graph
fun tions
need
to
b
e
adapted.
Not
m
u 
h
needs
to
b
e
done;
there
is
one
ni et
y:
the
n
um
b
ers
ough
t
to
line
up
under
the
ti 
marks.
This
tak
es
a
little
though
t.
Here
is
the
 orre ted
print-X-axis-numbered-li
ne:
(defun
print-X-axis-numbered-line
(number-of-X-ti s
X-axis-leading-spa es
&optional
horizontal-step)
"Print
line
of
X-axis
numbers"
(let
((number
X-axis-label-spa ing)
(horizontal-step
(or
horizontal-step
1)))
(insert
X-axis-leading-spa es)
;;
Delete
extra
leading
spa es.
(delete- har
(-
(1-
(length
(number-to-string
horizontal-step)))))
(insert
( on at
(make-string
;;
Insert
white
spa e.
(-
(*
symbol-width
X-axis-label-spa ing)
(1-
(length
(number-to-string
horizontal-step)))
2)
?
)
(number-to-string
(*
number
horizontal-step))))
;;
Insert
remaining
n
um
b
ers.
(setq
number
(+
number
X-axis-label-spa ing))
(while
(>
number-of-X-ti s
1)
(insert
(X-axis-element
(*
number
horizontal-step)))
(setq
number
(+
number
X-axis-label-spa ing))
(setq
number-of-X-ti s
(1-
number-of-X-ti s)))))

276
App
endix
C:
A
Graph
with
Lab
elled
Axes
If
y
ou
are
reading
this
in
Info,
y
ou
 an
see
the
new
v
ersions
of
print-X-
axis
print-graph
and
ev
aluate
them.
If
y
ou
are
reading
this
in
a
prin
ted
b
o
ok,
y
ou
 an
see
the
 
hanged
lines
here
(the
full
text
is
to
o
m
u 
h
to
prin
t).
(defun
print-X-axis
(numbers-list
horizontal-step)
...
(print-X-axis-numbered-line
ti -number
leading-spa es
horizontal-step))
(defun
print-graph
(numbers-list
&optional
verti al-step
horizontal-step)
...
(print-X-axis
numbers-list
horizontal-step))

The
Prin
ted
Graph
277
C.4.6
The
Prin
ted
Graph
When
made
and
installed,
y
ou
 an
 all
the
print-graph
 ommand
lik
e
this:
(print-graph
fiftieth-list-for-graph
50
10)
Here
is
the
graph:
1000
-
*
**
**
**
**
750
-
***
***
***
***
****
500
-
*****
******
******
******
*******
250
-
********
*********
*
***********
*
*************
*
50
-
*****************
*
*
|
|
|
|
|
|
|
|
10
50
100
150
200
250
300
350
The
largest
group
of
fun tions
 on
tain
10
{
19
w
ords
and
sym
b
ols
ea 
h.

278
App
endix
C:
A
Graph
with
Lab
elled
Axes

GNU
F
ree
Do
 umen
tation
Li ense
279
App
endix
D
GNU
F
ree
Do
 umen
tation
Li ense
V
ersion
1.1,
Mar 
h
2000
Cop
yrigh
t
 

2000
F
ree
Soft
w
are
F
oundation,
In .
59
T
emple
Pla e,
Suite
330,
Boston,
MA
02111-1307,
USA
Ev
ery
one
is
p
ermitted
to
 op
y
and
distribute
v
erbatim
 opies
of
this
li ense
do
 umen
t,
but
 
hanging
it
is
not
allo
w
ed.
0.
PREAMBLE
The
purp
ose
of
this
Li ense
is
to
mak
e
a
man
ual,
textb
o
ok,
or
other
written
do
 umen
t
free
in
the
sense
of
freedom:
to
assure
ev
ery
one
the
ee tiv
e
freedom
to
 op
y
and
redistribute
it,
with
or
without
mo
difying
it,
either
 ommer ially
or
non ommer ially
.
Se ondarily
,
this
Li ense
preserv
es
for
the
author
and
publisher
a
w
a
y
to
get
 redit
for
their
w
ork,
while
not
b
eing
 onsidered
resp
onsible
for
mo
di ations
made
b
y
others.
This
Li ense
is
a
kind
of
\ op
yleft",
whi 
h
means
that
deriv
ativ
e
w
orks
of
the
do
 umen
t
m
ust
themselv
es
b
e
free
in
the
same
sense.
It
 om-
plemen
ts
the
GNU
General
Publi 
Li ense,
whi 
h
is
a
 op
yleft
li ense
designed
for
free
soft
w
are.
W
e
ha
v
e
designed
this
Li ense
in
order
to
use
it
for
man
uals
for
free
soft-
w
are,
b
e ause
free
soft
w
are
needs
free
do
 umen
tation:
a
free
program
should
 ome
with
man
uals
pro
viding
the
same
freedoms
that
the
soft-
w
are
do
es.
But
this
Li ense
is
not
limited
to
soft
w
are
man
uals;
it
 an
b
e
used
for
an
y
textual
w
ork,
regardless
of
sub
je t
matter
or
whether
it
is
published
as
a
prin
ted
b
o
ok.
W
e
re ommend
this
Li ense
prin ipally
for
w
orks
whose
purp
ose
is
instru tion
or
referen e.
1.
APPLICABILITY
AND
DEFINITIONS
This
Li ense
applies
to
an
y
man
ual
or
other
w
ork
that
 on
tains
a
noti e
pla ed
b
y
the
 op
yrigh
t
holder
sa
ying
it
 an
b
e
distributed
under
the
terms
of
this
Li ense.
The
\Do
 umen
t",
b
elo
w,
refers
to
an
y
su 
h
man-
ual
or
w
ork.
An
y
mem
b
er
of
the
publi 
is
a
li ensee,
and
is
addressed
as
\y
ou".
A
\Mo
died
V
ersion"
of
the
Do
 umen
t
means
an
y
w
ork
 on
taining
the
Do
 umen
t
or
a
p
ortion
of
it,
either
 opied
v
erbatim,
or
with
mo
di a-
tions
and/or
translated
in
to
another
language.
A
\Se ondary
Se tion"
is
a
named
app
endix
or
a
fron
t-matter
se tion
of
the
Do
 umen
t
that
deals
ex lusiv
ely
with
the
relationship
of
the
pub-
lishers
or
authors
of
the
Do
 umen
t
to
the
Do
 umen
t's
o
v
erall
sub
je t
(or
to
related
matters)
and
 on
tains
nothing
that
 ould
fall
dire tly
within
that
o
v
erall
sub
je t.
(F
or
example,
if
the
Do
 umen
t
is
in
part
a
textb
o
ok
of
mathemati s,
a
Se ondary
Se tion
ma
y
not
explain
an
y

280
App
endix
D:
GNU
F
ree
Do
 umen
tation
Li ense
mathemati s.)
The
relationship
 ould
b
e
a
matter
of
histori al
 onne -
tion
with
the
sub
je t
or
with
related
matters,
or
of
legal,
 ommer ial,
philosophi al,
ethi al
or
p
oliti al
p
osition
regarding
them.
The
\In
v
arian
t
Se tions"
are
 ertain
Se ondary
Se tions
whose
titles
are
designated,
as
b
eing
those
of
In
v
arian
t
Se tions,
in
the
noti e
that
sa
ys
that
the
Do
 umen
t
is
released
under
this
Li ense.
The
\Co
v
er
T
exts"
are
 ertain
short
passages
of
text
that
are
listed,
as
F
ron
t-Co
v
er
T
exts
or
Ba 
k-Co
v
er
T
exts,
in
the
noti e
that
sa
ys
that
the
Do
 umen
t
is
released
under
this
Li ense.
A
\T
ransparen
t"
 op
y
of
the
Do
 umen
t
means
a
ma 
hine-readable
 op
y
,
represen
ted
in
a
format
whose
sp
e i ation
is
a
v
ailable
to
the
general
publi ,
whose
 on
ten
ts
 an
b
e
view
ed
and
edited
dire tly
and
straigh
t-
forw
ardly
with
generi 
text
editors
or
(for
images
 omp
osed
of
pixels)
generi 
pain
t
programs
or
(for
dra
wings)
some
widely
a
v
ailable
dra
wing
editor,
and
that
is
suitable
for
input
to
text
formatters
or
for
automati 
translation
to
a
v
ariet
y
of
formats
suitable
for
input
to
text
formatters.
A
 op
y
made
in
an
otherwise
T
ransparen
t
le
format
whose
markup
has
b
een
designed
to
th
w
art
or
dis ourage
subsequen
t
mo
di ation
b
y
readers
is
not
T
ransparen
t.
A
 op
y
that
is
not
\T
ransparen
t"
is
 alled
\Opaque".
Examples
of
suitable
formats
for
T
ransparen
t
 opies
in lude
plain
as i
i
without
markup,
T
exinfo
input
format,
LaT
E
X
input
format,
sgml
or
xml
using
a
publi ly
a
v
ailable
dtd,
and
standard- onforming
sim-
ple
html
designed
for
h
uman
mo
di ation.
Opaque
formats
in lude
P
ostS ript,
pdf,
proprietary
formats
that
 an
b
e
read
and
edited
only
b
y
proprietary
w
ord
pro
 essors,
sgml
or
xml
for
whi 
h
the
dtd
and/or
pro
 essing
to
ols
are
not
generally
a
v
ailable,
and
the
ma 
hine-generated
html
pro
du ed
b
y
some
w
ord
pro
 essors
for
output
purp
oses
only
.
The
\Title
P
age"
means,
for
a
prin
ted
b
o
ok,
the
title
page
itself,
plus
su 
h
follo
wing
pages
as
are
needed
to
hold,
legibly
,
the
material
this
Li ense
requires
to
app
ear
in
the
title
page.
F
or
w
orks
in
formats
whi 
h
do
not
ha
v
e
an
y
title
page
as
su 
h,
\Title
P
age"
means
the
text
near
the
most
prominen
t
app
earan e
of
the
w
ork's
title,
pre eding
the
b
eginning
of
the
b
o
dy
of
the
text.
2.
VERBA
TIM
COPYING
Y
ou
ma
y
 op
y
and
distribute
the
Do
 umen
t
in
an
y
medium,
either
 om-
mer ially
or
non ommer ially
,
pro
vided
that
this
Li ense,
the
 op
yrigh
t
noti es,
and
the
li ense
noti e
sa
ying
this
Li ense
applies
to
the
Do
 u-
men
t
are
repro
du ed
in
all
 opies,
and
that
y
ou
add
no
other
 onditions
whatso
ev
er
to
those
of
this
Li ense.
Y
ou
ma
y
not
use
te 
hni al
mea-
sures
to
obstru t
or
 on
trol
the
reading
or
further
 op
ying
of
the
 opies
y
ou
mak
e
or
distribute.
Ho
w
ev
er,
y
ou
ma
y
a  ept
 omp
ensation
in
ex-
 
hange
for
 opies.
If
y
ou
distribute
a
large
enough
n
um
b
er
of
 opies
y
ou
m
ust
also
follo
w
the
 onditions
in
se tion
3.

GNU
F
ree
Do
 umen
tation
Li ense
281
Y
ou
ma
y
also
lend
 opies,
under
the
same
 onditions
stated
ab
o
v
e,
and
y
ou
ma
y
publi ly
displa
y
 opies.
3.
COPYING
IN
QUANTITY
If
y
ou
publish
prin
ted
 opies
of
the
Do
 umen
t
n
um
b
ering
more
than
100,
and
the
Do
 umen
t's
li ense
noti e
requires
Co
v
er
T
exts,
y
ou
m
ust
en lose
the
 opies
in
 o
v
ers
that
 arry
,
 learly
and
legibly
,
all
these
Co
v
er
T
exts:
F
ron
t-Co
v
er
T
exts
on
the
fron
t
 o
v
er,
and
Ba 
k-Co
v
er
T
exts
on
the
ba 
k
 o
v
er.
Both
 o
v
ers
m
ust
also
 learly
and
legibly
iden
tify
y
ou
as
the
publisher
of
these
 opies.
The
fron
t
 o
v
er
m
ust
presen
t
the
full
title
with
all
w
ords
of
the
title
equally
prominen
t
and
visible.
Y
ou
ma
y
add
other
material
on
the
 o
v
ers
in
addition.
Cop
ying
with
 
hanges
limited
to
the
 o
v
ers,
as
long
as
they
preserv
e
the
title
of
the
Do
 umen
t
and
satisfy
these
 onditions,
 an
b
e
treated
as
v
erbatim
 op
ying
in
other
resp
e ts.
If
the
required
texts
for
either
 o
v
er
are
to
o
v
oluminous
to
t
legibly
,
y
ou
should
put
the
rst
ones
listed
(as
man
y
as
t
reasonably)
on
the
a tual
 o
v
er,
and
 on
tin
ue
the
rest
on
to
adja en
t
pages.
If
y
ou
publish
or
distribute
Opaque
 opies
of
the
Do
 umen
t
n
um
b
ering
more
than
100,
y
ou
m
ust
either
in lude
a
ma 
hine-readable
T
ranspar-
en
t
 op
y
along
with
ea 
h
Opaque
 op
y
,
or
state
in
or
with
ea 
h
Opaque
 op
y
a
publi ly-a  essible
 omputer-net
w
ork
lo
 ation
 on
taining
a
 om-
plete
T
ransparen
t
 op
y
of
the
Do
 umen
t,
free
of
added
material,
whi 
h
the
general
net
w
ork-using
publi 
has
a  ess
to
do
wnload
anon
ymously
at
no
 
harge
using
publi -standard
net
w
ork
proto
 ols.
If
y
ou
use
the
latter
option,
y
ou
m
ust
tak
e
reasonably
pruden
t
steps,
when
y
ou
b
egin
distribution
of
Opaque
 opies
in
quan
tit
y
,
to
ensure
that
this
T
ranspar-
en
t
 op
y
will
remain
th
us
a  essible
at
the
stated
lo
 ation
un
til
at
least
one
y
ear
after
the
last
time
y
ou
distribute
an
Opaque
 op
y
(dire tly
or
through
y
our
agen
ts
or
retailers)
of
that
edition
to
the
publi .
It
is
requested,
but
not
required,
that
y
ou
 on
ta t
the
authors
of
the
Do
 umen
t
w
ell
b
efore
redistributing
an
y
large
n
um
b
er
of
 opies,
to
giv
e
them
a
 
han e
to
pro
vide
y
ou
with
an
up
dated
v
ersion
of
the
Do
 umen
t.
4.
MODIFICA
TIONS
Y
ou
ma
y
 op
y
and
distribute
a
Mo
died
V
ersion
of
the
Do
 umen
t
under
the
 onditions
of
se tions
2
and
3
ab
o
v
e,
pro
vided
that
y
ou
release
the
Mo
died
V
ersion
under
pre isely
this
Li ense,
with
the
Mo
died
V
ersion
lling
the
role
of
the
Do
 umen
t,
th
us
li ensing
distribution
and
mo
di ation
of
the
Mo
died
V
ersion
to
who
ev
er
p
ossesses
a
 op
y
of
it.
In
addition,
y
ou
m
ust
do
these
things
in
the
Mo
died
V
ersion:
A.
Use
in
the
Title
P
age
(and
on
the
 o
v
ers,
if
an
y)
a
title
distin t
from
that
of
the
Do
 umen
t,
and
from
those
of
previous
v
ersions
(whi 
h
should,
if
there
w
ere
an
y
,
b
e
listed
in
the
History
se tion
of
the
Do
 umen
t).
Y
ou
ma
y
use
the
same
title
as
a
previous
v
ersion
if
the
original
publisher
of
that
v
ersion
giv
es
p
ermission.

282
App
endix
D:
GNU
F
ree
Do
 umen
tation
Li ense
B.
List
on
the
Title
P
age,
as
authors,
one
or
more
p
ersons
or
en
ti-
ties
resp
onsible
for
authorship
of
the
mo
di ations
in
the
Mo
died
V
ersion,
together
with
at
least
v
e
of
the
prin ipal
authors
of
the
Do
 umen
t
(all
of
its
prin ipal
authors,
if
it
has
less
than
v
e).
C.
State
on
the
Title
page
the
name
of
the
publisher
of
the
Mo
died
V
ersion,
as
the
publisher.
D.
Preserv
e
all
the
 op
yrigh
t
noti es
of
the
Do
 umen
t.
E.
Add
an
appropriate
 op
yrigh
t
noti e
for
y
our
mo
di ations
adja-
 en
t
to
the
other
 op
yrigh
t
noti es.
F.
In lude,
immediately
after
the
 op
yrigh
t
noti es,
a
li ense
noti e
giving
the
publi 
p
ermission
to
use
the
Mo
died
V
ersion
under
the
terms
of
this
Li ense,
in
the
form
sho
wn
in
the
Addendum
b
elo
w.
G.
Preserv
e
in
that
li ense
noti e
the
full
lists
of
In
v
arian
t
Se tions
and
required
Co
v
er
T
exts
giv
en
in
the
Do
 umen
t's
li ense
noti e.
H.
In lude
an
unaltered
 op
y
of
this
Li ense.
I.
Preserv
e
the
se tion
en
titled
\History",
and
its
title,
and
add
to
it
an
item
stating
at
least
the
title,
y
ear,
new
authors,
and
publisher
of
the
Mo
died
V
ersion
as
giv
en
on
the
Title
P
age.
If
there
is
no
se tion
en
titled
\History"
in
the
Do
 umen
t,
 reate
one
stating
the
title,
y
ear,
authors,
and
publisher
of
the
Do
 umen
t
as
giv
en
on
its
Title
P
age,
then
add
an
item
des ribing
the
Mo
died
V
ersion
as
stated
in
the
previous
sen
ten e.
J.
Preserv
e
the
net
w
ork
lo
 ation,
if
an
y
,
giv
en
in
the
Do
 umen
t
for
publi 
a  ess
to
a
T
ransparen
t
 op
y
of
the
Do
 umen
t,
and
lik
ewise
the
net
w
ork
lo
 ations
giv
en
in
the
Do
 umen
t
for
previous
v
ersions
it
w
as
based
on.
These
ma
y
b
e
pla ed
in
the
\History"
se tion.
Y
ou
ma
y
omit
a
net
w
ork
lo
 ation
for
a
w
ork
that
w
as
published
at
least
four
y
ears
b
efore
the
Do
 umen
t
itself,
or
if
the
original
publisher
of
the
v
ersion
it
refers
to
giv
es
p
ermission.
K.
In
an
y
se tion
en
titled
\A 
kno
wledgmen
ts"
or
\Dedi ations",
pre-
serv
e
the
se tion's
title,
and
preserv
e
in
the
se tion
all
the
substan e
and
tone
of
ea 
h
of
the
 on
tributor
a 
kno
wledgmen
ts
and/or
dedi-
 ations
giv
en
therein.
L.
Preserv
e
all
the
In
v
arian
t
Se tions
of
the
Do
 umen
t,
unaltered
in
their
text
and
in
their
titles.
Se tion
n
um
b
ers
or
the
equiv
alen
t
are
not
 onsidered
part
of
the
se tion
titles.
M.
Delete
an
y
se tion
en
titled
\Endorsemen
ts".
Su 
h
a
se tion
ma
y
not
b
e
in luded
in
the
Mo
died
V
ersion.
N.
Do
not
retitle
an
y
existing
se tion
as
\Endorsemen
ts"
or
to
 oni t
in
title
with
an
y
In
v
arian
t
Se tion.
If
the
Mo
died
V
ersion
in ludes
new
fron
t-matter
se tions
or
app
endi es
that
qualify
as
Se ondary
Se tions
and
 on
tain
no
material
 opied
from
the
Do
 umen
t,
y
ou
ma
y
at
y
our
option
designate
some
or
all
of
these

GNU
F
ree
Do
 umen
tation
Li ense
283
se tions
as
in
v
arian
t.
T
o
do
this,
add
their
titles
to
the
list
of
In
v
arian
t
Se tions
in
the
Mo
died
V
ersion's
li ense
noti e.
These
titles
m
ust
b
e
distin t
from
an
y
other
se tion
titles.
Y
ou
ma
y
add
a
se tion
en
titled
\Endorsemen
ts",
pro
vided
it
 on
tains
nothing
but
endorsemen
ts
of
y
our
Mo
died
V
ersion
b
y
v
arious
parties|
for
example,
statemen
ts
of
p
eer
review
or
that
the
text
has
b
een
ap-
pro
v
ed
b
y
an
organization
as
the
authoritativ
e
denition
of
a
standard.
Y
ou
ma
y
add
a
passage
of
up
to
v
e
w
ords
as
a
F
ron
t-Co
v
er
T
ext,
and
a
passage
of
up
to
25
w
ords
as
a
Ba 
k-Co
v
er
T
ext,
to
the
end
of
the
list
of
Co
v
er
T
exts
in
the
Mo
died
V
ersion.
Only
one
passage
of
F
ron
t-Co
v
er
T
ext
and
one
of
Ba 
k-Co
v
er
T
ext
ma
y
b
e
added
b
y
(or
through
ar-
rangemen
ts
made
b
y)
an
y
one
en
tit
y
.
If
the
Do
 umen
t
already
in ludes
a
 o
v
er
text
for
the
same
 o
v
er,
previously
added
b
y
y
ou
or
b
y
arrange-
men
t
made
b
y
the
same
en
tit
y
y
ou
are
a ting
on
b
ehalf
of,
y
ou
ma
y
not
add
another;
but
y
ou
ma
y
repla e
the
old
one,
on
expli it
p
ermission
from
the
previous
publisher
that
added
the
old
one.
The
author(s)
and
publisher(s)
of
the
Do
 umen
t
do
not
b
y
this
Li ense
giv
e
p
ermission
to
use
their
names
for
publi it
y
for
or
to
assert
or
imply
endorsemen
t
of
an
y
Mo
died
V
ersion.
5.
COMBINING
DOCUMENTS
Y
ou
ma
y
 om
bine
the
Do
 umen
t
with
other
do
 umen
ts
released
under
this
Li ense,
under
the
terms
dened
in
se tion
4
ab
o
v
e
for
mo
died
v
ersions,
pro
vided
that
y
ou
in lude
in
the
 om
bination
all
of
the
In
v
ari-
an
t
Se tions
of
all
of
the
original
do
 umen
ts,
unmo
died,
and
list
them
all
as
In
v
arian
t
Se tions
of
y
our
 om
bined
w
ork
in
its
li ense
noti e.
The
 om
bined
w
ork
need
only
 on
tain
one
 op
y
of
this
Li ense,
and
m
ultiple
iden
ti al
In
v
arian
t
Se tions
ma
y
b
e
repla ed
with
a
single
 op
y
.
If
there
are
m
ultiple
In
v
arian
t
Se tions
with
the
same
name
but
dieren
t
 on
ten
ts,
mak
e
the
title
of
ea 
h
su 
h
se tion
unique
b
y
adding
at
the
end
of
it,
in
paren
theses,
the
name
of
the
original
author
or
publisher
of
that
se tion
if
kno
wn,
or
else
a
unique
n
um
b
er.
Mak
e
the
same
adjustmen
t
to
the
se tion
titles
in
the
list
of
In
v
arian
t
Se tions
in
the
li ense
noti e
of
the
 om
bined
w
ork.
In
the
 om
bination,
y
ou
m
ust
 om
bine
an
y
se tions
en
titled
\History"
in
the
v
arious
original
do
 umen
ts,
forming
one
se tion
en
titled
\His-
tory";
lik
ewise
 om
bine
an
y
se tions
en
titled
\A 
kno
wledgmen
ts",
and
an
y
se tions
en
titled
\Dedi ations".
Y
ou
m
ust
delete
all
se tions
en
ti-
tled
\Endorsemen
ts."
6.
COLLECTIONS
OF
DOCUMENTS
Y
ou
ma
y
mak
e
a
 olle tion
 onsisting
of
the
Do
 umen
t
and
other
do
 u-
men
ts
released
under
this
Li ense,
and
repla e
the
individual
 opies
of
this
Li ense
in
the
v
arious
do
 umen
ts
with
a
single
 op
y
that
is
in luded
in
the
 olle tion,
pro
vided
that
y
ou
follo
w
the
rules
of
this
Li ense
for
v
erbatim
 op
ying
of
ea 
h
of
the
do
 umen
ts
in
all
other
resp
e ts.

284
App
endix
D:
GNU
F
ree
Do
 umen
tation
Li ense
Y
ou
ma
y
extra t
a
single
do
 umen
t
from
su 
h
a
 olle tion,
and
distribute
it
individually
under
this
Li ense,
pro
vided
y
ou
insert
a
 op
y
of
this
Li ense
in
to
the
extra ted
do
 umen
t,
and
follo
w
this
Li ense
in
all
other
resp
e ts
regarding
v
erbatim
 op
ying
of
that
do
 umen
t.
7.
A
GGREGA
TION
WITH
INDEPENDENT
W
ORKS
A
 ompilation
of
the
Do
 umen
t
or
its
deriv
ativ
es
with
other
separate
and
indep
enden
t
do
 umen
ts
or
w
orks,
in
or
on
a
v
olume
of
a
storage
or
distribution
medium,
do
es
not
as
a
whole
 oun
t
as
a
Mo
died
V
er-
sion
of
the
Do
 umen
t,
pro
vided
no
 ompilation
 op
yrigh
t
is
 laimed
for
the
 ompilation.
Su 
h
a
 ompilation
is
 alled
an
\aggregate",
and
this
Li ense
do
es
not
apply
to
the
other
self- on
tained
w
orks
th
us
 ompiled
with
the
Do
 umen
t,
on
a  oun
t
of
their
b
eing
th
us
 ompiled,
if
they
are
not
themselv
es
deriv
ativ
e
w
orks
of
the
Do
 umen
t.
If
the
Co
v
er
T
ext
requiremen
t
of
se tion
3
is
appli able
to
these
 opies
of
the
Do
 umen
t,
then
if
the
Do
 umen
t
is
less
than
one
quarter
of
the
en
tire
aggregate,
the
Do
 umen
t's
Co
v
er
T
exts
ma
y
b
e
pla ed
on
 o
v
ers
that
surround
only
the
Do
 umen
t
within
the
aggregate.
Otherwise
they
m
ust
app
ear
on
 o
v
ers
around
the
whole
aggregate.
8.
TRANSLA
TION
T
ranslation
is
 onsidered
a
kind
of
mo
di ation,
so
y
ou
ma
y
distribute
translations
of
the
Do
 umen
t
under
the
terms
of
se tion
4.
Repla ing
In
v
arian
t
Se tions
with
translations
requires
sp
e ial
p
ermission
from
their
 op
yrigh
t
holders,
but
y
ou
ma
y
in lude
translations
of
some
or
all
In
v
arian
t
Se tions
in
addition
to
the
original
v
ersions
of
these
In
v
arian
t
Se tions.
Y
ou
ma
y
in lude
a
translation
of
this
Li ense
pro
vided
that
y
ou
also
in lude
the
original
English
v
ersion
of
this
Li ense.
In
 ase
of
a
disagreemen
t
b
et
w
een
the
translation
and
the
original
English
v
ersion
of
this
Li ense,
the
original
English
v
ersion
will
prev
ail.
9.
TERMINA
TION
Y
ou
ma
y
not
 op
y
,
mo
dify
,
subli ense,
or
distribute
the
Do
 umen
t
ex-
 ept
as
expressly
pro
vided
for
under
this
Li ense.
An
y
other
attempt
to
 op
y
,
mo
dify
,
subli ense
or
distribute
the
Do
 umen
t
is
v
oid,
and
will
automati ally
terminate
y
our
righ
ts
under
this
Li ense.
Ho
w
ev
er,
par-
ties
who
ha
v
e
re eiv
ed
 opies,
or
righ
ts,
from
y
ou
under
this
Li ense
will
not
ha
v
e
their
li enses
terminated
so
long
as
su 
h
parties
remain
in
full
 omplian e.
10.
FUTURE
REVISIONS
OF
THIS
LICENSE
The
F
ree
Soft
w
are
F
oundation
ma
y
publish
new,
revised
v
ersions
of
the
GNU
F
ree
Do
 umen
tation
Li ense
from
time
to
time.
Su 
h
new
v
ersions
will
b
e
similar
in
spirit
to
the
presen
t
v
ersion,
but
ma
y
dier
in
detail
to
address
new
problems
or
 on erns.
See
http://www.gnu.org/ opyl
eft/
.
Ea 
h
v
ersion
of
the
Li ense
is
giv
en
a
distinguishing
v
ersion
n
um
b
er.
If
the
Do
 umen
t
sp
e ies
that
a
parti ular
n
um
b
ered
v
ersion
of
this

GNU
F
ree
Do
 umen
tation
Li ense
285
Li ense
\or
an
y
later
v
ersion"
applies
to
it,
y
ou
ha
v
e
the
option
of
follo
wing
the
terms
and
 onditions
either
of
that
sp
e ied
v
ersion
or
of
an
y
later
v
ersion
that
has
b
een
published
(not
as
a
draft)
b
y
the
F
ree
Soft
w
are
F
oundation.
If
the
Do
 umen
t
do
es
not
sp
e ify
a
v
ersion
n
um
b
er
of
this
Li ense,
y
ou
ma
y
 
ho
ose
an
y
v
ersion
ev
er
published
(not
as
a
draft)
b
y
the
F
ree
Soft
w
are
F
oundation.

286
App
endix
D:
GNU
F
ree
Do
 umen
tation
Li ense

Index
287
Index
%
%
(remainder
fun tion)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
258
(
(debug)
in
 o
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
235
*
*
(m
ultipli ation)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31
*
for
read-only
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65
`*s rat h*'
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
123
.
`.ema s'
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
`.ema s'
le,
b
eginning
of
.
.
.
.
.
.
.
.
.
.
.
216
/
/
(division)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
>
>
(greater
than)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
40
<
<=
(less
than
or
equal)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
127
A
A  um
ulate,
t
yp
e
of
re ursiv
e
pattern
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
142
add-hook
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
218
and
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108,
156
and,
in
tro
du ed
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108
Anon
ymous
fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
272
append-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
56
apply
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
205
apropos
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
Argumen
t
as
lo
 al
v
ariable
.
.
.
.
.
.
.
.
.
.
131
`argument'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12
`argument
list'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30
Argumen
t,
wrong
t
yp
e
of
.
.
.
.
.
.
.
.
.
.
.
.
.
14
Argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12
Argumen
ts'
data
t
yp
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13
Argumen
ts,
v
ariable
n
um
b
er
of
.
.
.
.
.
.
.
.
14
Asterisk
for
read-only
buer
.
.
.
.
.
.
.
.
.
.
65
Auto
Fill
mo
de
turned
on
.
.
.
.
.
.
.
.
.
.
.
218
autoload
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
223
Automati 
mo
de
sele tion
.
.
.
.
.
.
.
.
.
.
.
218
Axis,
prin
t
horizon
tal
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
263
Axis,
prin
t
v
erti al
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
B
beginning-of-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
69
`bind'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
`body'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30
Bo
dy
of
graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
Buer
size
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
Buer,
history
of
w
ord
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24
buffer-file-name
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
buffer-menu,
b
ound
to
k
ey
.
.
.
.
.
.
.
.
.
221
buffer-name
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
Bug,
most
insidious
t
yp
e
.
.
.
.
.
.
.
.
.
.
.
.
274
Building
rob
ots
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
134
Building
T
ags
in
the
Ema s
sour es
.
.
164
Byte
 ompiling
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
C
C
language
primitiv
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
C,
a
digression
in
to
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
98
` all'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
 an el-debug-on-entry
.
.
.
.
.
.
.
.
.
.
.
.
.
234
 ar,
in
tro
du ed
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
81
 dr,
in
tro
du ed
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
81
Changing
a
fun tion
denition
.
.
.
.
.
.
.
.
32
Chest
of
Dra
w
ers,
metaphor
for
a
sym
b
ol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
115
Clipping
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
Co
de
installation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
` ommand'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
Commen
ts
in
Lisp
 o
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
32
Common
Lisp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiii
 ompare-windows
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
 on at
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13
 ond
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
139
 ondition- ase
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95

288
Index
Conditional
't
wixt
t
w
o
v
ersions
of
Ema s
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
225
Conditional
with
if
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39
 ons,
example
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107
 ons,
in
tro
du ed
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83
 opy-region-as-kill
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
102
 opy-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63
Coun
t
w
ords
re ursiv
ely
.
.
.
.
.
.
.
.
.
.
.
.
.
173
 ount-words-in-defun
.
.
.
.
.
.
.
.
.
.
.
.
.
.
185
 ount-words-region
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
167
Coun
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19
Coun
ting
w
ords
in
a
defun
.
.
.
.
.
.
181,
183
 urrent-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
25
Customizing
y
our
`.ema s'
le
.
.
.
.
.
.
.
213
Cutting
and
storing
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
D
Data
t
yp
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13
debug
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
debug-on-entry
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
232
debug-on-quit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
234
debugging
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
default-mode-line-format
.
.
.
.
.
.
.
.
.
228
`default.el'
init
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
def ustom
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
214
Defermen
t
in
re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
143
Defermen
tless
solution
.
.
.
.
.
.
.
.
.
.
.
.
.
.
145
Denition
installation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31
Denition
writing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
Denition,
ho
w
to
 
hange
.
.
.
.
.
.
.
.
.
.
.
.
.
32
defun
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
defvar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100
defvar
for
a
user
 ustomizable
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101
defvar
with
an
asterisk
.
.
.
.
.
.
.
.
.
.
.
.
.
101
delete-and-extra t-region
.
.
.
.
.
.
96,
98
Deleting
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
des ribe-fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53
des ribe-fun tion,
in
tro
du ed
.
.
.
.
.
.
51
Digression
in
to
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
98
dire tory-files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
194
Division
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
dolist
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
132
dotimes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
133
Dra
w
ers,
Chest
of,
metaphor
for
a
sym
b
ol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
115
Dupli ated
w
ords
fun tion
.
.
.
.
.
.
.
.
.
.
.
241
E
edebug
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
235
edit-options
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101
Else
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
42
Ema s
v
ersion,
 
ho
osing
.
.
.
.
.
.
.
.
.
.
.
.
.
225
`empty
list'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2
`empty
string'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48
eobp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
159
eq
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48
eq
(example
of
use)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
104
equal
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48
Erasing
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
error
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
244
Error
for
sym
b
ol
without
fun tion
.
.
.
.
.
11
Error
for
sym
b
ol
without
v
alue
.
.
.
.
.
.
.
11
Error
message
generation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
etags
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
163
`evaluate'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
Ev
aluating
inner
lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
Ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
Ev
aluation
pra ti e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
Ev
ery
,
t
yp
e
of
re ursiv
e
pattern
.
.
.
.
.
.
141
Example
v
ariable,
fill- olumn
.
.
.
.
.
.
.
10
`expression'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2
F
F
alseho
o
d
and
truth
in
Ema s
Lisp
.
.
.
.
43
FDL,
GNU
F
ree
Do
 umen
tation
Li ense
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
279
files-in-below-dire tory
.
.
.
.
.
.
.
.
.
194
fill- olumn,
an
example
v
ariable
.
.
.
.
10
Find
a
File
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
187
Find
fun tion
do
 umen
tation
.
.
.
.
.
.
.
.
.
51
Find
sour e
of
fun tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
find-tags
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
Flo
w
ers
in
a
eld
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
F
o
 using
atten
tion
(narro
wing)
.
.
.
.
.
.
.
77
`form'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2
F
ormatting
 on
v
en
tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58
F
ormatting
help
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
forward-paragraph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
155
forward-senten e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
151
`fun tion'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
5,
6
`fun tion
definition'
dened
.
.
.
.
.
.
.
.
29
F
un tion
denition
installation
.
.
.
.
.
.
.
.
31
F
un tion
denition
writing
.
.
.
.
.
.
.
.
.
.
.
29
F
un tion
denition,
ho
w
to
 
hange
.
.
.
.
32
F
un tions,
primitiv
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29

Index
289
G
Generate
an
error
message
.
.
.
.
.
.
.
.
.
.
.
.
.
4
Getting
a
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
25
Global
set
k
ey
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
global-set-key
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
global-unset-key
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Graph
protot
yp
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
Graph,
prin
ting
all
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
267
graph-body-print
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
208
graph-body-print
Final
v
ersion.
.
.
.
.
.
268
H
Handling
the
kill
ring
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
Help
t
yping
lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
Horizon
tal
axis
prin
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
263
I
if
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39
`if-part'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
40
indent-tabs-mode
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
Inden
tation
for
formatting
.
.
.
.
.
.
.
.
.
.
.
.
58
Initialization
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
Initializing
a
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100
Inner
list
ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
insert-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
64
insert-buffer-substring
.
.
.
.
.
.
.
.
.
.
.
56
Insidious
t
yp
e
of
bug
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
274
Install
a
F
un tion
Denition
.
.
.
.
.
.
.
.
.
.
31
Install
 o
de
p
ermanen
tly
.
.
.
.
.
.
.
.
.
.
.
.
.
36
intera tive
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33
`intera tive
fun tion'
dened
.
.
.
.
.
.
.
23
In
tera tiv
e
fun tions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33
In
tera tiv
e
options
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35
intera tive,
example
use
of
.
.
.
.
.
.
.
.
.
65
In
terpreter,
Lisp,
explained
.
.
.
.
.
.
.
.
.
.
.
.
4
In
terpreter,
what
it
do
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7
K
Keep,
t
yp
e
of
re ursiv
e
pattern
.
.
.
.
.
.
143
Key
setting
globally
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
Key
un
binding
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Keymaps
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Keyw
ord
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
Kill
ring
handling
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
Kill
ring
o
v
erview
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
kill-append
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
104
kill-new
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105
kill-region
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94
Killing
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
L
lambda
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
272
length
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
84
lengths-list-file
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
188
lengths-list-many-files
.
.
.
.
.
.
.
.
.
.
190
let
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
let
expression
sample
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38
let
expression,
parts
of
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
let
v
ariables
uninitialized
.
.
.
.
.
.
.
.
.
.
.
.
39
Library
,
as
term
for
`le'
.
.
.
.
.
.
.
.
.
.
.
.
.
52
line-to-top-of-window
.
.
.
.
.
.
.
.
.
.
.
.
.
224
Lisp
A
toms
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
Lisp
history
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiii
Lisp
in
terpreter,
explained
.
.
.
.
.
.
.
.
.
.
.
.
.
4
Lisp
in
terpreter,
what
it
do
es
.
.
.
.
.
.
.
.
.
.
7
Lisp
Lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
Lisp
ma ro
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
97
list-buffers,
reb
ound
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Lists
in
a
 omputer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
113
load-library
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
223
load-path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
223
Loading
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
222
`lo al
variable'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
37
Lo
 al
v
ariables
list,
p
er-buer,
.
.
.
.
.
.
.
218
Lo
 ation
of
p
oin
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
looking-at
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
159
Lo
ops
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
Lo
ops
and
re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
M
Ma lisp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xiii
Ma ro,
lisp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
97
Mail
aliases
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
make
tags
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
164
make-string
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
261
map ar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
274
mark
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
mark-whole-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54
mat h-beginning
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
161
max
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
205
message
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16
min
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
205
Mo
de
line
format
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
228

290
Index
Mo
de
sele tion,
automati 
.
.
.
.
.
.
.
.
.
.
.
218
Motion
b
y
sen
ten e
and
paragraph
.
.
.
149
N
Narro
wing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
`narrowing'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
28
nil
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43
nil,
history
of
w
ord
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24
No
defermen
t
solution
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
145
nreverse
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
199
nth
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86
nth dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85,
102
nth dr,
example
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107
number-to-string
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
259
O
o  ur
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
optional
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
Optional
argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
Options
for
intera tive
.
.
.
.
.
.
.
.
.
.
.
.
.
35
or
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
67
other-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
25
P
P
aragraphs,
mo
v
emen
t
b
y
.
.
.
.
.
.
.
.
.
.
.
149
P
arts
of
a
Re ursiv
e
Denition
.
.
.
.
.
.
.
135
P
arts
of
let
expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
P
assing
information
to
fun tions
.
.
.
.
.
.
12
P
asting
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
P
atterns,
sear 
hing
for
.
.
.
.
.
.
.
.
.
.
.
.
.
.
149
P
er-buer,
lo
 al
v
ariables
list
.
.
.
.
.
.
.
.
218
P
ermanen
t
 o
de
installation
.
.
.
.
.
.
.
.
.
.
36
point
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
`point'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
P
oin
t
lo
 ation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
P
oin
t,
mark,
buer
preserv
ation
.
.
.
.
.
.
.
44
Pra ti ing
ev
aluation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
Preserving
p
oin
t,
mark,
and
buer
.
.
.
.
44
Primitiv
e
fun tions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
Primitiv
es
written
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
Prin
t
horizon
tal
axis
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
263
Prin
t
v
erti al
axis
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
print-elements-of-list
.
.
.
.
.
.
.
.
.
.
.
123
print-elements-re ursively
.
.
.
.
.
.
.
136
print-graph
Final
v
ersion.
.
.
.
.
.
.
.
.
.
.
269
print-graph
v
arlist
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
print-X-axis
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
266
print-X-axis-numbered-line
.
.
.
.
.
.
.
265
print-X-axis-ti -line
.
.
.
.
.
.
.
.
.
.
.
.
.
265
print-Y-axis
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
262
Prin
ting
the
whole
graph
.
.
.
.
.
.
.
.
.
.
.
.
267
prog1
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
159
progn
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
93
Program,
running
one
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
Protot
yp
e
graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
R
re-sear h-forward
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
150
Read-only
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65
Readying
a
graph
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
203
Rebinding
k
eys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Re ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
134
Re ursion
and
lo
ops
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
Re ursion
without
Defermen
ts
.
.
.
.
.
.
.
143
Re ursiv
e
Denition
P
arts
.
.
.
.
.
.
.
.
.
.
.
135
Re ursiv
e
pattern:
a  um
ulate
.
.
.
.
.
.
.
142
Re ursiv
e
pattern:
ev
ery
.
.
.
.
.
.
.
.
.
.
.
.
141
Re ursiv
e
pattern:
k
eep
.
.
.
.
.
.
.
.
.
.
.
.
.
143
Re ursiv
e
P
atterns
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
140
re ursive- ount-words
.
.
.
.
.
.
.
.
.
.
.
.
.
178
re ursive-graph-body-print
.
.
.
.
.
.
.
210
re ursive-lengths-list-many-
file
s
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
192
Re ursiv
ely
 oun
ting
w
ords
.
.
.
.
.
.
.
.
.
.
173
regexp-quote
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
157
Region,
what
it
is
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
Regular
expression
sear 
hes
.
.
.
.
.
.
.
.
.
.
149
Regular
expressions
for
w
ord
 oun
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
167
Remainder
fun tion,
%
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
258
Rep
etition
(lo
ops)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
Rep
etition
for
w
ord
 oun
ting
.
.
.
.
.
.
.
.
167
Retrieving
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
reverse
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
199
Ring,
making
a
list
lik
e
a
.
.
.
.
.
.
.
.
.
.
.
.
243
Rob
ots,
building
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
134
rotate-yank-pointer
.
.
.
.
.
.
.
.
.
.
117,
243
Run
a
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4

Index
291
S
Sample
let
expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38
save-ex ursion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
save-restri tion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
sear h-forward
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
92
Sear 
hes,
illustrating
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
149
senten e-end
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
149
Sen
ten es,
mo
v
emen
t
b
y
.
.
.
.
.
.
.
.
.
.
.
.
.
149
set
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
set-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26
set ar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
87
set dr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88
set dr,
example
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107
setq
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
18
Setting
a
k
ey
globally
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
220
Setting
v
alue
of
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
`side
effe t'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
Simple
extension
in
`.ema s'
le
.
.
.
.
.
224
simplified-beginning-of-buffe
r
.
.
.
.
52
`site-init.el'
init
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
`site-load.el'
init
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
Size
of
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27
Solution
without
defermen
t
.
.
.
.
.
.
.
.
.
.
145
sort
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
193
Sour e
lev
el
debugger
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
235
Sp
e ial
form
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7
Sp
e ial
form
of
defun
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29
Storing
and
 utting
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89
`string'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
swit h-to-buffer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26
Swit 
hing
to
a
buer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26
Sym
b
ol
names
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
6
Sym
b
ol
without
fun tion
error
.
.
.
.
.
.
.
.
11
Sym
b
ol
without
v
alue
error
.
.
.
.
.
.
.
.
.
.
.
11
Sym
b
oli 
expressions,
in
tro
du ed
.
.
.
.
.
.
.
2
Sym
b
ols
as
a
Chest
of
Dra
w
ers
.
.
.
.
.
.
.
115
Syn
tax
 ategories
and
tables
.
.
.
.
.
.
.
.
.
182
T
T
abs,
prev
en
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
`TAGS'
le,
 reate
o
wn
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
163
T
ags
in
the
Ema s
sour es
.
.
.
.
.
.
.
.
.
.
.
164
T
A
GS
table,
sp
e ifying
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
T
ext
b
et
w
een
double
quotation
marks
.
.
3
T
ext
Mo
de
turned
on
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
218
T
ext
retriev
al
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
the-the
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
241
`then-part'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
40
top-of-ranges
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
198
triangle-bugged
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
triangle-re ursively
.
.
.
.
.
.
.
.
.
.
.
.
.
.
137
T
ruth
and
falseho
o
d
in
Ema s
Lisp
.
.
.
.
43
T
yp
es
of
data
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13
U
Un
binding
k
ey
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
Uninitialized
let
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
39
V
V
ariable
initialization
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100
V
ariable
n
um
b
er
of
argumen
ts
.
.
.
.
.
.
.
.
14
V
ariable,
example
of,
fill- olumn
.
.
.
.
10
V
ariable,
setting
v
alue
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17
V
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10
`varlist'
dened
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
V
ersion
of
Ema s,
 
ho
osing
.
.
.
.
.
.
.
.
.
.
225
V
erti al
axis
prin
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
W
what-line
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78
while
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
121
Whitespa e
in
lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
Whole
graph
prin
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
267
Widening
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
Widening,
example
of
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78
W
ord
 oun
ting
in
a
defun
.
.
.
.
.
.
.
.
.
.
.
181
W
ords
and
sym
b
ols
in
defun
.
.
.
.
.
.
.
.
.
181
W
ords,
 oun
ted
re ursiv
ely
.
.
.
.
.
.
.
.
.
.
173
W
ords,
dupli ated
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
241
W
riting
a
fun tion
denition
.
.
.
.
.
.
.
.
.
.
29
W
rong
t
yp
e
of
argumen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
X
X
axis
prin
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
263
X-axis-element
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
265
Y
Y
axis
prin
ting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
256
Y-axis- olumn
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
261
Y-axis- olumn
Final
v
ersion.
.
.
.
.
.
.
.
.
268
Y-axis-label-spa ing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
259
Y-axis-ti 
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
260

292
Index
yank
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117,
249
yank-pop
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
252
Z
zap-to- har
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90
zerop
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
244



Ab
out
the
Author
Rob
ert
J.
Chassell
has
w
ork
ed
with
GNU
Ema s
sin e
1985.
He
writes
and
edits,
tea 
hes
Ema s
and
Ema s
Lisp,
and
sp
eaks
throughout
the
w
orld
on
soft
w
are
freedom.
Chassell
w
as
a
found-
ing
Dire tor
and
T
reasurer
of
the
F
ree
Soft
w
are
F
oundation,
In .
He
is
 o-author
of
the
T
exinfo
man
ual,
and
has
edited
more
than
a
dozen
other
b
o
oks.
He
graduated
from
Cam
bridge
Univ
ersit
y
,
in
England.
He
has
an
abiding
in
terest
in
so
 ial
and
e onomi 
history
and
ies
his
o
wn
airplane.


