

 
World Headquarters
Jones & Bartlett Learning
25 Mall Road
Burlington, MA 01803
978-443-5000
info@jblearning.com
www.jblearning.com
Jones & Bartlett Learning books and products are available through most bookstores and
online booksellers. To contact Jones & Bartlett Learning directly, call 800-832-0034, fax 978-
443-8000, or visit our website, www.jblearning.com.
Substantial discounts on bulk quantities of Jones & Bartlett Learning publications are
available to corporations, professional associations, and other qualified organizations. For
details and specific discount information, contact the special sales department at Jones &
Bartlett Learning via the above contact information or send an email to
specialsales@jblearning.com.
Copyright © 2023 by Jones & Bartlett Learning, LLC, an Ascend Learning Company
All rights reserved. No part of the material protected by this copyright may be reproduced or
utilized in any form, electronic or mechanical, including photocopying, recording, or by any
information storage and retrieval system, without written permission from the copyright owner.
The content, statements, views, and opinions herein are the sole expression of the respective
authors and not that of Jones & Bartlett Learning, LLC. Reference herein to any specific
commercial product, process, or service by trade name, trademark, manufacturer, or
otherwise does not constitute or imply its endorsement or recommendation by Jones &
Bartlett Learning, LLC and such reference shall not be used for advertising or product
endorsement purposes. All trademarks displayed are the trademarks of the parties noted
herein. Programming and Problem Solving with C++, Seventh Edition is an independent
publication and has not been authorized, sponsored, or otherwise approved by the owners of
the trademarks or service marks referenced in this product.
There may be images in this book that feature models; these models do not necessarily
endorse, represent, or participate in the activities represented in the images. Any screenshots
in this product are for educational and instructive purposes only. Any individuals and scenarios
featured in the case studies throughout this product may be real or fictitious but are used for
instructional purposes only.
16603-3
Production Credits
Vice President, Product Management: Marisa R. Urbano
Vice President, Content Strategy and Implementation: Christine Emerton
Director, Content Management: Donna Gridley

Director, Project Management and Content Services: Karen Scott
Product Manager: Ned Hinman
Content Strategist: Melissa Duffy
Content Coordinator: Mark Restuccia
Manager, Program Management: Kristen Rogers
Project Manager: Madelene Nieman
Senior Digital Project Specialist: Angela Dooley
Director of Marketing: Andrea DeFronzo
Marketing Manager: Mark Adamiak
Content Services Manager: Colleen Lamy
Vice President, Manufacturing and Inventory Control: Therese Connell
Product Fulfillment Manager: Wendy Kilborn
Composition: Straive
Media Development Editor: Faith Brosnan
Rights & Permissions Manager: John Rusk
Rights Specialist: James Fortney
Cover Image (Title Page, Part Opener, Chapter Opener): © Joost Lagerweij/EyeEm/Getty
Images
Printing and Binding: LSC Communications
Library of Congress Cataloging-in-Publication Data
Names: Dale, Nell (Nell B.), author. | Weems, Chip, author. | Richards, Tim (Computer
scientist), author.
Title: Programming and problem solving with C++ / Nell Dale, University of Texas-Austin, Chip
Weems, UMASS Amherst, Tim Richards, UMASS Amherst.
Description: Seventh edition. | Burlington, Massachusetts : Jones & Bartlett Learning, [2023] |
Includes bibliographical references and index. | Summary: "Programming and Problem
Solving with C++ is appropriate for the introductory C++ programming course at the
undergraduate level. Due to its coverage, it can be used in a one or two semester course.
Competitive advantages of this title include: The reputation of the authors Appropriate and
thorough coverage of C++ topics for the beginner programmer Clear examples and
exercises, with hands-on examples and case studies"-- Provided by publisher.
Identifiers: LCCN 2021045333 | ISBN 9781284157321 (paperback)
Subjects: LCSH: C++ (Computer program language)
Classification: LCC QA76.73.C153 D34 2023 | DDC 005.13/3--dc23
LC record available at https://lccn.loc.gov/2021045333
6048
Printed in the United States of America
26 25 24 23 22 10 9 8 7 6 5 4 3 2 1

Description
Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.
BRIEF CONTENTS
Preface
1  Overview of Programming and Problem Solving
2  C++ Syntax and Semantics, and the Program Development Process
3  Numeric Types, Expressions, and Output
4  Program Input and the Software Design Process
5  Conditions, Logical Expressions, and Selection Control Structures
6  Looping
7  Additional Control Structures
8  Functions
9  Scope, Lifetime, and More on Functions

10 User-Defined Data Types
11 Arrays
12 Classes and Abstraction
13 Array-Based Lists
14 Dynamic Data and Linked Lists
15 Inheritance, Polymorphism, and Object-Oriented Design
16 Templates, Operator Overloading, and Exceptions
17 Introduction to Data Structures Using the Standard Template Library
18 Recursion
Appendices
INDEX

Description
Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.
CONTENTS
Preface
1 Overview of Programming and Problem Solving
1.1 Overview of Programming
What Is Programming?
How Do We Write a Program?
What Is an Algorithm?
What Is a Programming Language?
1.2 How Does a Computer Run a Program?
What Kinds of Instructions Can Be Written in a Programming Language?
What Is Software Maintenance?
Software Maintenance Case Study An Introduction to Software
Maintenance
1.3 What’s Inside the Computer?
1.4 Ethics and Responsibilities in the Computing Profession
Data Piracy
Privacy of Data
Use of Computer Resources
Software Engineering

1.5 Problem-Solving Techniques
Ask Questions
Look for Things That Are Familiar
Solve by Analogy
Means-Ends Analysis
Divide and Conquer
The Building-Block Approach
Merging Solutions
Mental Blocks: The Fear of Starting
Algorithmic Problem Solving
Problem-Solving Case Study Leap Year Algorithm
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Case Study Follow-Up
Line Number
2 C++ Syntax and Semantics, and the Program Development Process
2.1 The Elements of C++ Programs
C++ Program Structure
Syntax and Semantics
Syntax Templates
Naming Program Elements: Identifiers
Data and Data Types
Naming Elements: Declarations
Taking Action: Executable Statements
Beyond Minimalism: Adding Comments to a Program
2.2 Program Construction
Blocks (Compound Statements)
The C++ Preprocessor
Software Maintenance Case Study Adding Titles to Names
2.3 More About Output
Creating Blank Lines
Inserting Blanks Within a Line
Special Characters
2.4 Program Entry, Correction, and Execution
Entering a Program
Compiling and Running a Program

Problem-Solving Case Study Printing a Chessboard
Testing and Debugging
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
3 Numeric Types, Expressions, and Output
3.1 Overview of C++ Data Types
3.2 Numeric Data Types
Integral Types
Floating-Point Types
3.3 Declarations for Numeric Types
Named Constant Declarations
Variable Declarations
3.4 Simple Arithmetic Expressions
Arithmetic Operators
Increment and Decrement Operators
3.5 Compound Arithmetic Expressions
Precedence Rules
Type Coercion and Type Casting
Software Maintenance Case Study Precedence Error
3.6 Function Calls and Library Functions
Value-Returning Functions
Library Functions
Void Functions
3.7 Formatting Output
Integers and Strings
Floating-Point Numbers
3.8 Additional string Operations
The length and size Functions
The find Function
The substr Function
Accessing Characters Within a String: The at Function
Converting to Lowercase and Uppercase
Problem-Solving Case Study Mortgage Payment Calculator
Testing and Debugging

Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
4 Program Input and the Software Design Process
4.1 Getting Data into Programs
Input Streams and the Extraction Operator (>>)
The Reading Marker and the Newline Character
Reading Character Data with the get Function
Skipping Characters with the ignore Function
Reading String Data
4.2 Interactive Input/Output
4.3 Noninteractive Input/Output
4.4 File Input and Output
Files
Using Files
Software Maintenance Case Study Adding File Input/Output to a Program
Run-Time Input of File Names
4.5 Input Failure
4.6 Software Design Methodologies
4.7 Functional Decomposition
Modules
Implementing the Design
A Perspective on Design
Problem-Solving Case Study Displaying a Name in Multiple Formats
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
5 Conditions, Logical Expressions, and Selection Control Structures

5.1 Flow of Control
Selection
5.2 Conditions and Logical Expressions
The bool Data Type
Logical Expressions
5.3 The If Statement
The If-Then-Else Form
Blocks (Compound Statements)
The If-Then Form
A Common Mistake
Software Maintenance Case Study Incorrect Output
5.4 Nested If Statements
The Dangling else
5.5 Logical Operators
Precedence of Operators
Relational Operators with Floating-Point Types
5.6 Testing the State of an I/O Stream
Problem-Solving Case Study Recording Studio Design
Graphical User Interface (GUI)
Testing and Debugging
Testing in the Problem-Solving Phase: The Algorithm Walk-Through
Testing in the Implementation Phase
The Test Plan
Tests Performed Automatically During Compilation and Execution
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
6 Looping
6.1 The While Statement
6.2 Phases of Loop Execution
6.3 Loops Using the While Statement
Count-Controlled Loops
Event-Controlled Loops
Looping Subtasks

Software Maintenance Case Study Make a Program General
6.4 How to Design Loops
Designing the Flow of Control
Designing the Process Within the Loop
The Loop Exit
6.5 Nested Logic
Designing Nested Loops
Problem-Solving Case Study Recording Studio Design
Graphical User Interface (GUI)
Testing and Debugging
Loop-Testing Strategy
Test Plans Involving Loops
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
7 Additional Control Structures
7.1 The Switch Statement
7.2 The Do-While Statement
7.3 The For Statement
Software Maintenance Case Study Changing a Loop Implementation
7.4 The Break and Continue Statements
7.5 Guidelines for Choosing a Looping Statement
7.6 Additional C++ Operators
Assignment Operators and Assignment Expressions
Increment and Decrement Operators
Bitwise Operators
The Cast Operation
The sizeof Operator
The ?: Operator
Operator Precedence
Type Coercion in Arithmetic and Relational Expressions
Problem-Solving Case Study The Rich Uncle
Graphical User Interface (GUI)
Testing and Debugging

Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
8 Functions
8.1 Functional Decomposition with Void Functions
When to Use Functions
Why Do Modules Need an Interface Design?
Designing Interfaces
Writing Modules as Void Functions
8.2 An Overview of User-Defined Functions
Flow of Control in Function Calls
Function Parameters
8.3 Syntax and Semantics of Void Functions
Function Call (Invocation)
Function Declarations and Definitions
Local Variables
The Return Statement
8.4 Parameters
Value Parameters
Reference Parameters
Software Maintenance Case Study Refactoring a Program
A Last Word of Caution About Argument and Parameter Lists
Writing Assertions as Function Documentation
Problem-Solving Case Study Lawn Care Company Billing
Graphical User Interface (GUI)
Testing and Debugging
The assert Library Function
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up

9 Scope, Lifetime, and More on Functions
9.1 Scope of Identifiers
Scope Rules
Variable Declarations and Definitions
Namespaces
9.2 Lifetime of a Variable
Software Maintenance Case Study Debug a Simple Program
Initializations in Declarations
9.3 Interface Design
Side Effects
Global Constants
9.4 Value-Returning Functions
Complete Example
Boolean Functions
Interface Design and Side Effects
When to Use Value-Returning Functions
9.5 Type Coercion in Assignments, Argument Passing, and Return of a Function
Value
Problem-Solving Case Study Health Profile
Testing and Debugging
Stubs and Drivers
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
10 User-Defined Data Types
10.1 Built-In Simple Types
Numeric Types 525 Characters
10.2 User-Defined Simple Types
The Typedef Statement
Enumeration Types
Named and Anonymous Data Types
10.3 Simple Versus Structured Data Types
10.4 Records (Structs)

Accessing Individual Components
Aggregate Operations on Structs
More About Struct Declarations
Binding Like Items
Software Maintenance Case Study Changing a Loop Implementation
10.5 Hierarchical Records
10.6 Unions
10.7 Pointers
Pointer Variables
Pointer Expressions
10.8 Reference Types
Problem-Solving Case Study Stylistic Analysis of Text
Graphical User Interface (GUI)
Testing and Debugging
Coping with Input Errors
Debugging with Pointers
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
11 Arrays
11.1 One-Dimensional Arrays
Declaring Arrays
Accessing Individual Components of an Array
Out-of-Bounds Array Indexes
Initializing Arrays in Declarations
(Lack of) Aggregate Array Operations
Examples of Declaring and Accessing Arrays
Passing Arrays as Arguments
Commenting Arrays
Software Maintenance Case Study Modularizing a Program
Using Typedef with Arrays
Pointer Expressions and Arrays
C-Style Strings
11.2 Arrays of Records

Arrays of Records
11.3 Special Kinds of Array Processing
Subarray Processing
Indexes with Semantic Content
11.4 Two-Dimensional Arrays
11.5 Passing Two-Dimensional Arrays as Arguments
11.6 Processing Two-Dimensional Arrays
Sum the Rows
Sum the Columns Revised
Sum the Columns
Initialize the Array
Output the Array
11.7 Another Way of Defining Two-Dimensional Arrays
11.8 Multidimensional Arrays
Problem-Solving Case Study Calculating Exam Statistics
Graphical User Interface (GUI)
Problem-Solving Case Study Favorite Rock Group
Graphical User Interface (GUI)
Testing and Debugging
One-Dimensional Arrays
Complex Structures
Multidimensional Arrays
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
12 Classes and Abstraction
12.1 Abstract Data Types
12.2 C++ Classes
Implementing the Member Functions
Classes, Objects, and Members
Built-in Operations on Objects
Class Scope
12.3 Information Hiding
User-Written Header Files

Specification and Implementation Files
Compiling and Linking a Multifile Program
12.4 What Is an Object?
12.5 Class Design Principles
Encapsulation
Abstraction
Designing for Modifiability and Reuse
Mutability
Software Maintenance Case Study Comparing Two TimeOfDay Objects
12.6 The Name ADT
Specification of the ADT
Implementation File
12.7 Composition
Design of an Entry Class
12.8 UML Diagrams
Diagramming a Class
Diagramming Composition of Classes
Problem-Solving Case Study Create an Array of Name Objects
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging with a Graphical User Interface
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
13 Array-Based Lists
13.1 What Is a List?
13.2 The List as an Abstract Data Type
Refining Responsibilities
Data Representation
Example Program
13.3 Implementation of List ADT
Basic Operations
Insertion and Deletion
Sequential Search

Iterators
Software Maintenance Case Study Enhancing Class List with a Sort
13.4 Sorted Lists
Basic Operations
Insertion
Sequential Search
Binary Search Deletion
13.5 Sorted List of Classes
IsThere
Insert and Delete
13.6 More on UML Diagrams
Problem-Solving Case Study Calculating Exam Statistics Revisited
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
14 Dynamic Data and Linked Lists
14.1 Dynamic Data
Allocating Dynamic Data
Deleting Dynamic Data
Constants and Dynamic Data
14.2 Sequential Versus Linked Structures
14.3 Creating a Dynamic Linked List: A Walk-Through Example
14.4 Dynamic Implementation of ADT List
Creating an Empty Linked List
Inserting into a Linked List
Traversals of a Linked List
Deleting from a Linked List
Resetting the List
Getting the Next Item
Testing for the Full Linked List
Searching the List
14.5 Destructors and Copy-Constructors

Destructor
Shallow Versus Deep Copying
Copy-Constructor
14.6 Sorted Linked List
Insert(20)
Insert(60) (pick up with loop)
Insert(100)
Deleting from a Linked List
Problem-Solving Case Study Creating a Sorted List of Entry Objects
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
15 Inheritance, Polymorphism, and Object-Oriented Design
15.1 Object -Oriented Programming
15.2 Inheritance
An Analogy
Inheritance and the Object-Oriented Design Process
Deriving One Class from Another Class
Specification of the ExpandedEntry Class
Implementation of the ExpandedEntry Class
Constructor Execution Order
Software Maintenance Case Study Extending TimeOfDay with Support for
a Time Zone
15.3 Dynamic Binding and Virtual Functions
The Slicing Problem
Virtual Functions
15.4 Object -Oriented Design
Brainstorming
Filtering
Scenario Exploration
Responsibility Algorithms
A Final Word
15.5 Implementing a Design

Problem-Solving Case Study Creating an Appointment Calendar
Graphical User Interface (GUI)
Creating an Empty Window
Adding Button Widgets
Adding Form Widgets
Adding the List Widget
Adding the Main Widget
Adding Application State
Responding to Events
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
16 Templates, Operator Overloading, and Exceptions
16.1 Template Classes
Defining a Class Template
Instantiating a Class Template
Another Way of Implementing Incoming Parameters: const References
Organization of Program Code
A Word of Caution
16.2 Generic Functions
Function Overloading
Defining a Function Template Outside a Class
Instantiating a Function Template
16.3 Operator Overloading
Using *this
16.4 Exceptions
The throw Statement
The try-catch Statement
Nonlocal Exception Handlers
Rethrowing an Exception
Standard Exceptions
Software Maintenance Case Study Adding Exceptions to the Date Class
Problem-Solving Case Study Aircraft Weight and Balance

Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
17 Introduction to Data Structures Using the Standard Template Library
17.1 Abstract Data Structures Versus Implementations
17.2 Additional Linear Structures
Stacks
Queues
Priority Queues
17.3 Bidirectional Linear Structures
Bidirectional Lists
Deques
17.4 An Introduction to the STL
Iterators
The vector Template
The array Template
The list Template
The stack Template
The queue Template
The priority_queue Template
The deque Template
Software Maintenance Case Study Appointment Calendar Using STL
17.5 Nonlinear Structures
Binary Trees
Hash Tables
17.6 Associative Containers
The set Template
The map Template
Problem-Solving Case Study Creating a Deck of Cards
Graphical User Interface (GUI)
Testing and Debugging
Testing and Debugging Hints

Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
18 Recursion
18.1 What Is Recursion?
18.2 Recursive Algorithms with Simple Variables
18.3 Towers of Hanoi
18.4 Recursive Algorithms with Structured Variables
Software Maintenance Case Study Substituting Binary Search for Linear
Search
18.5 Recursion Using Pointer Variables
Printing a Dynamic Linked List in Reverse Order
Copying a Dynamic Linked List
18.6 Recursion or Iteration?
Problem-Solving Case Study Quicksort
Testing and Debugging
Testing and Debugging Hints
Summary
Quick Check Answers
Exam Preparation Exercises
Programming Warm-Up Exercises
Programming Problems
Case Study Follow-Up
APPENDIX A Reserved Words
APPENDIX B Operator Precedence
APPENDIX C A Selection of Standard Library Routines
APPENDIX D Setting up the GUI Development Environment
APPENDIX E The ASCII Character Set
APPENDIX F Program Style, Formatting, and Documentation
APPENDIX G More on Floating-Point Numbers
APPENDIX H Using C Strings
APPENDIX I C++ char Constants
INDEX

Description
Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.
PREFACE
Introduction to the Seventh Edition
The first six editions of Programming and Problem Solving with C++ have consistently been
among the best-selling computer science textbooks in the United States. These editions have
been accepted widely as model textbooks for ACM/IEEE-recommended curricula for
introductory computer science courses.
Throughout the successive editions of this book, one thing has not changed: our
commitment to the student. As always, our efforts are directed toward making the sometimes
difficult concepts of computer science more accessible to all students. This edition of
Programming and Problem Solving with C++ continues to reflect our philosophy that a
textbook should be like a guide, blazing a trail and leading its readers through territory that can
initially seem difficult to navigate.
Changes to the Seventh Edition
Programming and Problem Solving with C++, Seventh Edition continues to offer coverage
enabling the book to be used across two terms, thereby providing greater value for students.
Recognizing that much has changed in the eight years since publication of the Sixth Edition,
as growth in the use of smartphones and apps has caused major cultural changes worldwide
and made many technologies obsolete or less common, we have gone through the entire text,
updating its language to reflect the modern computing landscape. Many examples and

analogies have thus been adjusted or replaced, to make them more relevant. Because
reading patterns have also changed as students engage more with smaller screens, we have
shifted the writing style throughout every chapter to be more direct and concise. Despite the
massive change in the text, instructors will be pleased to know that we have not changed the
order of presentation, with the exception of some new special features.
The most prominent of the new features is the introduction of graphical user interfaces
(GUIs) as optional sections at the end of each chapter, beginning with the chapter on program
input. Most modern students come into our courses having never seen console input/output,
which is a relic of 20th-century systems that preceded the Internet.
Not only is GUI I/O more familiar to current students, but its more advanced forms provide
a natural means of introducing event handling. When students see how a GUI widget triggers
an event handler, it lays a conceptual framework for working with the multithreading that is
becoming an essential element of computational problem solving in a world of multicore
processors. In this way, we are also anticipating increased emphasis on early coverage of
parallel and distributed computing in the ACM/IEEE 202X curriculum standard that is currently
in development.
Each of these sections examines how to transform a Problem-Solving Case Study program
from using console I/O to accomplishing the same task with a GUI. Many of the programming
patterns that are taught in introductory courses are founded on the need to check free-form
console input for errors—error checking that modern systems avoid by using specialized GUI
widgets that prevent erroneous input. Where we can thus simplify the case study code, or
enhance its robustness using a GUI, we draw attention to the improvement.
Our GUI coverage uses the popular Qt system, which is available for all popular operating
systems and has been implemented for multiple languages. We have provided, in the source
code files for each chapter, a C++ header file that initializes the environment with the
necessary defaults and some basic widgets so that students can easily write GUI programs
that initially depend on only simple function calls. Their programs are then able to show
familiar-looking input dialogs for yes/no responses, numbers, text, and a file picker, and
various ways to display textual output, all using simple, intuitive calls. The source code is
available at go.jblearning.com/PPS7e.
Later, after classes and objects are covered, in a step-by-step process, we introduce the
tools for creating custom GUIs that include buttons to trigger events. The use of these more
advanced widgets and components serves to illustrate the power of object-oriented
programming. Students also get a taste of modern software engineering, which depends
heavily on creating a chain of type casts to enable objects of one type to work with the
information stored in objects of other types.
It is our hope that instructors will find these optional sections useful as a step toward shifting
their courses to more fully embracing the modern GUI model.
With this edition we have also updated coverage to include features of the C++ standards
that have emerged since publication of the prior edition, as appropriate for a first course in
programming.
Pedagogical Approach
Our approach, as always, is to provide a gradual layering of concepts, rather than piling on
details and related alternatives that can be overwhelming. For example, many texts begin by

introducing numeric types. Instead, we start with char and string types in Chapter 2 so that
students can focus on the mechanics of constructing a C++ program that performs basic
output and quickly get a working demonstration running. Once they are comfortable with the
basics, in Chapter 3 we add numeric types. By separating the conceptual hurdles of
statement and program syntax from the complexities of types that involve numeric precision,
signedness, casting, and precedence, we make it possible for more students to succeed
early in the course.
Based on the research of Elliot Soloway with novice programmers, we continue to initially
cover selection using only the If statement, and loops using only the While statement.
However, because many instructors like to cover all selection control structures together and
all looping control structures together, the chapter on additional control structures is directly
after the chapters on selection and looping.
Similarly, students find it easier to comprehend the struct type, with its named fields that can
mix types, than the array type with indexes that often involve arithmetic expressions for
access. Thus, Chapter 10 introduces struct and union types, whereas arrays are deferred to
Chapter 11. We also present simple uses of pointers and reference types in Chapter 10 and
defer usage of pointers with arrays and dynamic allocation until Chapter 11 so that students
can become comfortable with indirect access prior to working with values on the heap.
Recognizing that many students learn programming from mimicking existing solutions, we
include numerous short example programs in every chapter. These programs illustrate
chapter concepts in a more complete context than code segments and appear immediately
after the introduction of new concepts. We have also organized chapters so that the
discussion moves more quickly from a concept to its practical application early in the chapter,
before moving on to related concepts. Chapters thus offer a series of concrete examples that
serve as intermediate waypoints on the path to the major case studies.
C++ and Object-Oriented Programming
Some educators reject C and C++ as too permissive and too conducive to writing cryptic,
unreadable programs. Our experience does not support this view, provided that the use of
language features is modeled appropriately. The fact that the C family permits a terse,
compact programming style cannot be labeled simply as “good” or “bad.” Almost any
programming language can be used to write in a style that is too terse and clever to be easily
understood. Although the C family may, indeed, be used in this manner more often than other
languages, we have found that with careful instruction in software engineering and use of a
programming style that is straightforward, disciplined, and free of intricate language features,
students can learn to use C++ to produce clear, readable code.
It must be emphasized that although we use C++ as a vehicle for teaching computer
science concepts, the book is not a language manual: It does not attempt to cover the whole
of the C++ language. Instead, the language constructs are introduced in parallel with the
appropriate theory as a way to demonstrate its practical application.
There are diverse opinions about when to introduce the topic of object-oriented
programming (OOP). Some educators advocate an immersion in OOP from the very
beginning, whereas others (for whom this book is intended) favor a more heterogeneous
approach, in which both functional decomposition and object-oriented design are presented as
design tools. The chapter organization of Programming and Problem Solving with C++,

Seventh Edition reflects a transitional approach to OOP. Classes and object-oriented
terminology are presented in Chapter 12, but inheritance, polymorphism, and object-oriented
design are deferred until Chapter 15. The intervening chapters offer ample time and
experience for students to become comfortable with the practice of using classes.
Synopsis
Chapter 1 is designed to create a comfortable rapport between students and the subject. The
basics of hardware and software are presented, issues in computer ethics are raised, C++
syntax is first encountered in a Software Maintenance Case Study, and problem-solving
techniques are introduced and reinforced in a Problem-Solving Case Study.
Instead of overwhelming the student right away with the various numeric types available in
C++, Chapter 2 concentrates on only two types: char and string. With fewer data types to
keep track of, students can focus on overall program structure and get an earlier start on
creating and running a simple program. Chapter 3 follows with a discussion of the C++
numeric types and then moves on to cover arithmetic expressions, function calls, and output.
Unlike many books that detail all of the C++ data types and all of the C++ operators at once,
these two chapters focus on only the int, float, char, and string types, as well as the basic
arithmetic operators. The discussion of other data types is postponed until Chapter 10.
Input and programming methodology are the major topics of Chapter 4. The distinction
between object-oriented design (OOD) and functional decomposition is explained, and the
functional decomposition methodology is then presented in more depth. Students thus gain
the perspective early that there are two design methodologies—not just one—in widespread
use and that each serves a specific purpose. Chapter 4 also covers file I/O. The early
introduction of files permits the assignment of programming problems that require the use of
sample data files. This is where the graphical user interface (GUI) is first introduced, with
dialogs for text input and output, and pickers for files and directories. The pickers both avoid
some cause that would cases stream failure and enable use of complete paths to files, rather
than the way that the console-based approach relies on files being in the same directory as
the executable.
Chapter 5 begins with the concept of flow of control and branching before moving into
relational and Boolean operations. Selection, using the If-Then and If-Then-Else structures,
demonstrates the distinction between physical ordering of statements and logical ordering. We
also develop the concept of nested control structures. Chapter 5 concludes with a lengthy
“Testing and Debugging” section that expands on the modular design discussion by
introducing preconditions and postconditions. The algorithm walk-through and code walk-
through are introduced as means of preventing errors, and the execution trace is used to find
errors that may have made their way into the code. We also cover data validation and testing
strategies extensively in this section. In the GUI section, dialogs for entry of numerical values
are introduced, and students see how setting range limits within the widget avoids the need for
range checking the input with their own code. We also introduce a yes/no dialog that returns a
Boolean result.
Chapter 6 is devoted to loop control strategies and looping operations using the syntax of
the While statement. Rather than introduce multiple syntactical structures, our approach is to
teach the concepts of looping using only the While statement. In the GUI section we focus on
gaining further experience with the widgets introduced in Chapter 5. Chapter 7 then covers the

remaining “ice cream and cake” control structures in C++ (Switch, Do-While, and For), along
with the Break and Continue statements. Like their dessert counterparts, these structures are
nice to have, but not essential. The section on additional C++ operators is also in this chapter,
because these operators are useful but not indispensable. In the GUI section we see how a
file picker avoids the need to check whether a file exists.
By Chapter 8, students are already comfortable with breaking problems into modules and
using library functions, and they are receptive to the idea of writing their own functions.
Chapter 8 focuses on passing arguments by value and covers flow of control in function calls,
arguments and parameters, local variables, and interface design. Coverage of interface
design includes preconditions and postconditions in the interface documentation, control
abstraction, encapsulation, and physical versus conceptual hiding of an implementation. The
GUI section introduces a New File dialog to let a user create an output file. Chapter 9 expands
on Chapter 8’s coverage of functions to include value-returning functions, reference
parameters, scope and lifetime, stubs and drivers, and more on interface design, including
side effects. Because Chapters 9 through 11 have a high density of new programming
concepts, their GUI sections do not introduce new widgets; instead, they focus on refactoring
the case studies with components that have already been covered.
Chapter 10 begins the transition between the control structure orientation of the first part of
the book and the data structure orientation of the second part. We revisit the built-in simple
data types in terms of the set of values represented by each type and the allowable operations
on those values. Enumeration types, structs, and unions are covered. In addition, Chapter 10
includes a discussion of simple versus structured data types, including pointers and reference
types.
In Chapter 11, the array is introduced as a homogeneous data structure whose components
are accessed by position rather than by name. One-dimensional arrays are examined in
depth, including arrays of structs. Material on C strings, two-dimensional arrays, three-
dimensional arrays, and multidimensional arrays rounds out the discussion of the array type.
The chapter concludes with using pointers with arrays and the dynamic allocation of data.
Chapter 12 formalizes the concept of an abstract data type as an introduction to the
discussion of the class construct. Object-oriented terminology is presented, emphasizing the
distinction between a class and an object. Good class design principles are stressed. The use
of specification files and implementation files is presented as a form of information hiding.
Although mutability is discussed and illustrated in a brief example, all of the classes developed
in this chapter are intentionally immutable: students have enough new software design
concepts to digest at this point without adding this aspect to the mix. In the GUI section we
see another example of using a file dialog and also introduce a time of day picker and some of
the basics of developing custom widgets. Mutable classes are demonstrated repeatedly in the
next chapter, however.
Chapter 13 integrates the material from Chapters 11 and 12 by defining the list as an ADT,
which is then implemented by a class containing an array. Because we have already
introduced classes and arrays, we can clearly distinguish between arrays and lists from the
very beginning of this discussion. The array is a built-in, fixed-size data structure. The list is a
user-defined, variable-size structure, represented in this chapter as a length variable and an
array of items bound together in a class object. In Chapter 13, we design C++ classes for
unsorted and sorted list ADTs, and we code the list algorithms as class member functions.
The GUI section illustrates how common components can be combined in a custom widget
that is provided in the online code files for the text. Our goal is to have students see what they
will be working toward in Chapters 14 through 16. Chapter 14 examines dynamic allocation

and deallocation of data. Pointers are then used to provide a dynamic linked implementation of
the unsorted and sorted list ADTs from Chapter 13. Now that students have some experience
using objects, the GUI section is able to introduce events and event handlers.
Chapter 15 extends the concepts of data abstraction and C++ classes to an exploration of
object-oriented software development. The notion of inheritance is introduced, and students
learn to distinguish between inheritance and composition. This chapter also introduces C++
virtual functions, which support polymorphism in the form of run-time binding of operations.
Object-oriented design, introduced briefly in Chapter 4 and further developed in Chapter 12, is
revisited in greater depth here as well. We present an outline of how to move from the problem
statement through the design phase of a software solution. We then follow this outline in the
case study, implement the design, and discuss testing strategies. In the GUI section, students
see how a custom GUI is a container object to which other widget objects are added in
specific arrangements and connected to event handlers. With this section, we are moving into
significant new territory that demonstrates the power of object-oriented programming.
Chapter 16 introduces C++ templates, operator overloading, and exception handling. The
GUI section shows how a custom UI can go beyond console input to enhance the capabilities
of a program in a way that is natural for the user. Chapter 17 discusses classic data
structures and introduces their STL equivalents. Several of the STL container classes are
used to reimplement programs from previous chapters. Our final GUI section again illustrates
the superiority of a custom UI by refactoring the playing card case study to show images of
cards as the user clicks on the generated list.
Chapter 18 concludes the text by introducing the concept of recursion. This chapter is
broken into three parts: recursion with simple variables, recursion with arrays, and recursion
with pointers. Its organization allows an instructor to cover all of recursion as a separate topic
or piece-by-piece in conjunction with the presentation of value-returning functions, arrays, and
pointers, according to their preference.
Additional Features
Special Sections
Five kinds of features are set off from the main text:
Theoretical Foundations sections present material related to the fundamental theory
behind various branches of computer science.
Software Engineering Tips discuss methods of making programs more reliable, robust, or
efficient.
Matters of Style address stylistic issues in the coding of programs.
Background Information sections explore side issues that enhance the student’s general
knowledge of computer science.
May We Introduce sections contain biographies of computing pioneers such as Blaise
Pascal, Charles Babbage, Ada Lovelace, Katherine Johnson, Tony Hoare, Kathleen
McNulty, and Grace Murray Hopper.

Goals
Each chapter begins with a list of goals for the student, broken into two categories: knowledge
goals and skill goals. Both types of goals are reinforced and tested in the end-of-chapter
exercises.
Demonstration Programs
Much shorter and simpler than the case study examples, demonstration programs provide a
bridge between syntactic concepts and their application in a problem-solving context. Each
chapter now includes multiple complete demonstration programs, interspersed with coverage
of new programming and language topics. All of these programs are available at
go.jblearning.com/PPS7e so that students can easily experiment with them and reuse the
code in their own projects.
Software Maintenance Case Studies
The majority of modern software engineering work involves maintaining legacy code. Given
this fact, it is essential that students learn the skills associated with reading, understanding,
extending, and fixing existing programs. Such skills are rarely taught in an introductory
course, where the focus tends to be on writing new programs from problem specifications. It
turns out that these same maintenance skills are actually an important aspect of successfully
writing new programs: Once a modest amount of code has been written, the process of
getting it to work correctly is, at its essence, synonymous with maintenance. These case
studies are intended to build the skills of reading, dissecting, modifying, and testing existing
code.
Problem-Solving Case Studies
Problem solving is best demonstrated through case studies. In each of the Problem-Solving
Case Studies, we present a problem and use problem-solving techniques to develop a
manual solution. Next, we expand the solution to an algorithm using functional decomposition,
object-oriented design, or both; then we code the algorithm in C++. We show sample test data
and output, and then follow up with a discussion of what is involved in thoroughly testing the
program.
Testing and Debugging
Testing and Debugging sections follow the case studies in each chapter and consider in depth
the implications of the chapter material with regard to the thorough testing of programs. These
sections conclude with a list of testing and debugging hints.
Quick Checks
At the end of each section are questions that test the student’s recall of major points
associated with the chapter goals. On reading each question, the student immediately should

know the answer, which he or she can then verify by glancing at the answers at the end of the
chapter.
Exam Preparation Exercises
The Exam Preparation Exercises are intended to help the student prepare for tests. The
questions usually have objective answers and are designed to be answered with only a few
minutes of work.
Programming Warm-Up Exercises
The Programming Warm-Up Exercises provide the student with experience in writing C++
code fragments. The student can practice the syntactic constructs in each chapter without the
burden of writing a complete program.
Programming Problems
Programming Problems, which are drawn from a wide range of disciplines, require the student
to design solutions and write complete programs. Some of the problems are carried through
multiple chapters, with subsequent chapters’ Programming Problems asking the student to
reimplement the solution using new constructs or techniques as a way of illustrating that one
problem can be solved by many different approaches.
Case Study Follow-Up
The Case Study Follow-Up exercises give the student an opportunity to strengthen his or her
software maintenance skills by answering questions that require reading the case study code
or making changes to it.
Supplements
Instructor’s Resources
The online resources are powerful teaching aids available to adopters on request from the
publisher. They include a complete set of exercise answers, a Test Bank, PowerPoint lecture
outlines, and the complete programs from the text. To request access, contact your account
representative or visit go.jblearning.com/PPS7e.
Programs
The source code for all of the complete programs that appear within the textbook is available
as a free download for instructors and students from the publisher’s website
(go.jblearning.com/ PPS7e). This code includes all of the case study programs, plus the
demonstration programs that appear interspersed within the various chapters. The program

files can be viewed or edited using any standard text editor, but a C++ compiler must be used
to compile and run the programs.
Acknowledgments
We would like to thank the many individuals who have helped us in the preparation of this
Seventh Edition. In particular, we are indebted to the members of the faculties of the
Computer Science departments at the University of Texas at Austin and the University of
Massachusetts at Amherst.
We extend special thanks to Jeff Brumfield for developing the syntax template meta-
language and allowing us to use it in the text.
For their many helpful suggestions, we thank the lecturers, teaching assistants,
consultants, and student proctors who run the courses for which this book was written, as
well as the students themselves.
We are grateful to the following people who took the time to offer their comments on
potential changes for this and previous editions: Ziya Arnavut, SUNY Fredonia; Trudee
Bremer, Illinois Central College; Mira Carlson, Northeastern Illinois University; Kevin Daimi,
University of Detroit, Mercy; Bruce Elenbogen, University of Michigan, Dearborn; Letha
Etzkorn, University of Alabama–Huntsville; Ilga Higbee, Black Hawk College; Sue Kavli,
Dallas Baptist University; Sandria Kerr, Winston-Salem State University; Alicia Kime,
Fairmont State College; Shahadat Kowuser, University of Texas, Pan America; Bruce Maxim,
University of Michigan, Dearborn; William McQuain, Virginia Tech; Xiannong Meng, Bucknell
University; William Minervini, Broward University; Janet Remen, Washtenaw Community
College; Viviana Sandor, Oakland University; Mehdi Setareh, Virginia Tech; Katherine Snyder,
University of Detroit, Mercy; Tom Steiner, University of Michigan, Dearborn; John Weaver,
West Chester University; Charles Welty, University of Southern Maine; Cheer-Sun Yang,
West Chester University.
We also thank the many people at Jones & Bartlett Learning who contributed so much to
this book, especially Madelene Nieman, Project Specialist; Melissa Duffy, Content Strategist;
James Fortney, Rights Specialist; and Faith Brosnan, Media Development Editor.
Anyone who has ever written a book—or is related to someone who has—can appreciate
the amount of time involved in such a project. To our families—all of the Dale clan and the
extended Dale family (too numerous to name), and to Lisa, Charlie, and Abby, and to Jody,
Caleb, and Hazel—thanks for your tremendous support and indulgence.
N. D.
C. W.
T. R.
To quote Mephistopheles, one of the chief devils and tempter of Faust,
...My friend, I shall be pedagogic,
And say you ought to start with Logic...
...Days will be spent to let you know
That what you once did at one blow,
Like eating and drinking so easy and free,
Can only be done with One, Two, Three.

Yet the web of thought has no such creases
And is more like a weaver’s masterpieces
J. W. von Goethe, Faust, Walter Kaufman trans., New York, 1963, 199.
As you study this book, do not let the logic of algorithms bind your imagination, but rather
make it your tool for weaving masterpieces of thought.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1
Overview of
Programming and
Problem Solving
KNOWLEDGE GOALS
To understand what a computer program is.
To understand what an algorithm is.
To learn what a high-level programming language is.
To understand the compilation and execution processes.
To learn the history of the C++ language.
To learn what the major components of a computer are and how they work together.
To learn about some of the basic ethical issues confronting computing professionals.
SKILL GOALS
To be able to:
List the basic stages involved in writing a computer program.
Describe what a compiler is and what it does.
Distinguish between hardware and software.
Choose an appropriate problem-solving method for developing an algorithmic solution
to a problem.

1.1 Overview of Programming
com•put•er 
 n. often attrib (1646): one that computes; specif: a
programmable electronic device that can store, retrieve, and process data.1
What a brief definition for something that has, in just a few decades, changed the way of life
worldwide! Computers touch all areas of our lives. This is a text to teach you how to program
this ubiquitous tool.
What Is Programming?
Much of human behavior and thought is characterized by logical sequences. Since infancy,
you have been learning how to act, how to do things.
A lot of what you do every day, you do automatically. Fortunately, it is not necessary for you
to consciously think of every step involved in a process as simple as turning a page by hand:
1. Lift hand.
2. Move hand to right side of book.
3. Grasp top-right corner of page.
4. Move hand from right to left until page is positioned so that you can read what is on the
other side.
5. Let go of page.
Much of what you do unconsciously you once had to learn step by step. On a broader
scale, mathematics often depends on logical sequences of steps for solving problems. Mass
production involves operations taking place in a certain order. Our whole civilization is based
on the order of things and actions.
We create such ordering through a process we call programming. This text is concerned
with programming the computer.
Programming Planning or scheduling the performance of a task or an event.
Computer A programmable device that can store, retrieve, and process data.
Just as a concert program lists the order in which the players perform pieces, so a
computer program lists the sequence of steps the computer performs. From now on, when
we use the words programming and program, we mean computer programming and
computer program.
Computer program Instructions for solving a problem, to be performed by a computer.
Computer programming The process of planning the instructions for a computer to
follow.

The computer allows us to do tasks more quickly and accurately than we could by hand—if
we could do them by hand at all. To use this powerful tool, we must specify what we want
done and the order in which we want it done. We do this through programming.
How Do We Write a Program?
A computer is not intelligent. It cannot analyze a problem and come up with a solution.
Instead, a human (the programmer) must analyze the problem, develop instructions for
solving the problem, and then communicate it to the computer. Once we have written the
solution for the computer, it can repeat the solution very quickly and consistently. The
computer frees people from repetitive and boring tasks.
To write instructions for a computer to follow, we must go through a two-phase process:
problem solving and implementation (see FIGURE 1.1).
FIGURE 1.1 Programming Process
Description

Problem-Solving Phase
1. Analysis and specification: Understand (define) the problem and what the solution must
do.
2. General solution (algorithm): Develop instructions for solving the problem, using a
combination of a human language, such as English, and mathematical notation.
3. Verify: Follow the instructions exactly to see if the solution really does solve the problem.
Implementation Phase
1. Concrete solution (program): Translate the algorithm into a programming language.
2. Test: Have the computer follow the instructions, then manually check the results. If you
find errors, analyze the program and the algorithm to determine the source of the errors,
and then make corrections.
Once a program has been written, it enters a third phase: maintenance.
Maintenance Phase
1. Use: Use the program.
2. Maintain: Modify the program to meet changing requirements or to correct any errors that
show up in using it.
This series of stages is known as the waterfall model of software development. Other
development models exist that are used in different situations. For example, the spiral model
involves developing an initial specification of the problem, programming a portion of the
solution, having the client evaluate the result, and then revising the specification and repeating
the process until the client is satisfied. The spiral model is appropriate when a problem is not
well defined initially or when aspects of the problem are changing during the development.
Solutions to scientific or engineering research problems are often developed using the spiral
model. We use the waterfall model throughout this text because it is well suited for solving the
kinds of clearly defined problems that you’ll encounter in an introductory programming course.
Waterfall model A software development approach that works from a specification to an
implementation.
Spiral model A software development approach in which specification and implementation
evolve together iteratively.
What Is an Algorithm?
The programmer begins the programming process by analyzing the problem and developing a
general solution called an algorithm. Understanding and analyzing a problem take up much

more time thanFigure 1.1 implies. These steps are the heart of the programming process.
Algorithm A procedure for solving a problem in a finite amount of time.
If our definitions of a computer program and an algorithm look similar, it is because all
programs are algorithms. A program is simply an algorithm that has been written for a
computer.
An algorithm is a verbal or written description of the actions that must be taken to solve a
problem. We use algorithms every day. Recipes, instructions, and directions are all examples
of algorithms that are not programs.
When you start your car, you follow a step-by-step procedure. The algorithm might look
something like this:
1. Depress the brake pedal.
2. Make sure the transmission is in Park.
3. Press the start button.
4. If the engine doesn’t start, wait five seconds and repeat Steps 1 through 3, but not more
than five times.
5. If the car doesn’t start, call the repair shop.
Without the phrase “but not more than five times” in Step 4, you could be trying to start the
car forever. Why? Because if something is wrong with the car, repeating Steps 1 through 3
will not start it. This never-ending situation is called an infinite loop. If we leave the phrase “but
not more than five times” out of Step 4, we do not have an algorithm. An algorithm must
terminate in a finite amount of time for all possible conditions.
Suppose a programmer needs an algorithm to determine an employee’s weekly wages in a
business where the overtime rate is 1.5 times the regular pay rate. The algorithm reflects what
would be done by hand:
1. Look up the employee’s pay rate.
2. Determine the number of hours worked during the week.
3. If the number of hours worked is less than or equal to 40, pay is hours × pay rate.
4. If the number of hours worked is greater than 40, pay is 40 × pay rate + (hours – 40) ×
pay rate × 1.5.
The steps the computer follows are often the same steps you would use to do the
calculations by hand.
After developing a general solution, the programmer tests the algorithm, performing each
step manually. If the algorithm doesn’t work, the programmer repeats the problem-solving
process, coming up with another algorithm. Often the second algorithm is just a variation of
the first. When the algorithm is correct, the programmer translates it into a programming
language. We use the C++ programming language in this text.

Programming language A set of rules, symbols, and special words used to construct a
computer program.
What Is a Programming Language?
A programming language is a simplified form of English (with math symbols) that adheres to a
strict set of grammatical rules. English can be ambiguous, meaning the same statement can
have multiple meanings. A computer program must have exactly one meaning because a
computer doesn't “know” what we mean. Programming languages, because they limit
vocabulary and grammar, are unambiguous.
The simplicity of a programming language may necessitate writing instructions that are
tedious in their amount of detail. Try giving someone directions to the nearest airport using a
vocabulary of no more than 45 words, and you’ll begin to see the problem. Programming
forces you to write very simple, exact instructions.
BACKGROUND INFORMATION Origins of Some Basic Terms
Writing a program is called coding because the first computers were programmed directly
with numbers. Instructions were entered as numbers, such as 1 meaning add, 2 meaning
input, and so on. The process was very similar to converting a message into a secret
code, where letters and words are represented by corresponding numbers.
The term debugging, with respect to computers, originated from a situation in which an
early computer, which used mechanical switches called relays, stopped working. The
cause was found to be a moth caught between the contacts of one of the switches. It was
taped into the log book with the note “First actual case of a bug being found.” The term bug
had long been used before that to refer to problems in mechanical devices other than
computers.
Translating an algorithm into a programming language is called coding the algorithm. The
product of that translation—the program—is tested by running (executing) it on the computer.
If the program fails to produce the desired results, the programmer must debug it—that is,
determine what is wrong and then modify the program, or even the algorithm, to fix it. The
combination of coding and testing an algorithm is called implementation.
There is no single way to implement an algorithm. For example, an algorithm can be
translated into more than one programming language. When two people translate the same
algorithm into the same programming language, they are likely to come up with different
implementations, because a programming language allows flexibility in how an algorithm is
coded (see FIGURE 1.2). Given this flexibility, people adopt their own coding styles.
Throughout this text, we offer tips on good programming style.

FIGURE 1.2 Differences in Implementations
Description
It’s tempting to try to go directly from the problem definition to coding the program (see
FIGURE 1.3). However, this kind of shortcut actually takes more time and effort. Developing

an algorithm before you start coding helps you manage the problem, keep your thoughts
straight, and avoid mistakes. If you don’t think out your algorithm first, you’ll spend a lot of
extra time debugging and revising your program.
FIGURE 1.3 Programming Shortcut?
Description
Once a program has been put into use, it may become necessary to fix an error that is
discovered during its use or change the program in response to new user requirements. Each
time the program is modified, the problem-solving and implementation phases must be
repeated for those aspects of the program. This phase of the programming process, known
as maintenance, accounts for the majority of the work done on most programs. A program
may be implemented in a few months, but is then maintained for many years. Thus, it is a
cost-effective investment of time to develop the initial problem solution and program
implementation carefully.
Because maintenance often involves programmers other than those who wrote the first
implementation, documentation is an important part of the programming process.
Documentation includes written explanations of the problem being solved and the organization
of the solution, comments embedded within the program itself, and user manuals that
describe how to use the program. Maintainers must be able to read and understand the code.
Documentation The written text and comments that make a program easier for others to
understand, use, and modify.
In running a program, you must give the computer the necessary data. Information is any
knowledge that can be communicated, including abstract ideas and concepts such as “the
earth is round.” Data is information in a form the computer can use—for example, the
numbers and letters making up the formulas that relate the earth’s radius to its volume and
surface area. Part of the programming process involves deciding how to represent the
information in a problem as data.

Information Any knowledge that can be communicated.
Data Information in a form a computer can use.
THEORETICAL FOUNDATIONS Binary Representation of Data
In a computer, data are represented by pulses of electricity. Given an electric circuit that
can be either on or off, we say when the circuit is on it represents the number 1; when off,
it represents 0. Any kind of data can be represented by combinations of enough 1s and 0s.
Inside the computer, some combination represents each piece of data we are using. For
example, the designers of the C++ language could have arbitrarily chosen the pattern
1101000110 to represent the name “C++.”
Data represented by 1s and 0s are in binary form. The binary, or base-2, number
system uses only 1s and 0s to represent numbers. (The decimal, or base-10, number
system uses the digits 0 through 9.) The word bit (short for binary digit) refers to a single 1
or 0. Thus, the pattern 1101000110 has 10 bits. A binary number with three bits can
represent 23, or eight, different patterns. The eight patterns are shown here, together with
some examples of base-2 arithmetic:
Description
A 10-digit binary number can represent 210 (1024) distinct patterns. Thus, you can use
your fingers to count in binary from 0 to 1023! A byte is a group of eight bits; it can
represent 28 (256) patterns. Inside the computer, each character (such as the letter A, the
letter g, the digit 7, a question mark, or a blank) is usually represented by either one or two
bytes.2 For example, in one scheme, 01001101 represents M and 01101101 represents m.

(Look closely—the third bit from the left is the only difference.) Groups of 16, 32, and 64
bits are generally referred to as words.
The process of assigning bit patterns to pieces of data is also called coding, because
the first computers recognized only one language, which was binary in form. Back then,
programming meant translating both data and algorithms into binary numbers.
The patterns of bits that represent data can vary from one family of computers to
another and from one programming language to another; even a single programming
language may use the same pattern to represent different things in different contexts.
(People do this, too: The four letters that form the word tack have different meanings
depending on whether you are talking about upholstery, sailing, sewing, paint, or horseback
riding.) The point is that patterns of bits by themselves are meaningless. Rather, it is the
way the patterns are used that gives them their meaning. That’s why we combine data
with operations to form meaningful objects.
Fortunately, today, coding is just a matter of writing down the data in letters, numbers,
and symbols. The computer automatically converts these into binary form. Still, as you
work with computers, you will often run into numbers that are related to powers of 2, such
as 256, 32,768, and 65,536. They are reminders that the binary number system is lurking
in the background.
QUICK CHECK
1.1.1 What do we call instructions that are executed by a computer to solve a
problem?
1.1.2 Is a computer capable of analyzing a problem to come up with a solution?
1.1.3 How does an algorithm differ from a computer program?
1.1.4 Describe the three important phases of the waterfall model we go through to
write instructions for a computer.
1.1.5 How does a programming language differ from a human language?
Answers to Quick Check questions are given at the end of the chapter.
1 Reproduced from Merriam-Webster. 1994. “Merriam-Webster’s Collegiate Dictionary, tenth
edition.” Merriam-Webster Inc.
2 Older programming languages use the American Standard Code for Information Interchange
(ASCII) to represent the English alphabet and other symbols. Each ASCII character is stored
in a single byte. Newer languages use a standard called Unicode, which includes the
alphabets of many other languages. A single Unicode character takes up two bytes in the
computer’s memory. With a little extra work on the part of the programmer, C++ can also
process Unicode.

1.2 How Does a Computer Run a Program?
In the computer, all of the instructions and data for a program are stored and used in binary
codes—that is, as strings of 1s and 0s. This scheme makes it possible for the computer to
process its own instructions as a form of data.
When computers were first developed, the only programming language available was the
primitive instruction set built into each machine, the machine language, or machine code.
Machine language The language, made up of binary-coded instructions, that is used
directly by the computer.
Even though most computers perform the same kinds of operations, their designers
choose different binary codes for the instructions. Thus the machine code for one computer is
not the same as for another computer.
When programmers used machine language for programming, they had to enter the binary
codes for the various instructions, a tedious process that was prone to error. Moreover,
programs were difficult to read and modify. In time, assembly languages were developed to
make the programmer’s job easier.
Assembly language A low-level programming language in which a mnemonic is used to
represent each of the machine language instructions for a particular computer.
Instructions in an assembly language are in an easy-to-remember form called a mnemonic
(pronounced nee-MAHN-ik). Typical instructions for addition and subtraction might look like
this:
Description
Although assembly language is easier for humans to work with, the computer cannot
directly execute it. One of the fundamental discoveries in computer science is that, because a
computer can process its own instructions as data, it is possible to write a program to
translate the assembly language instructions into machine code.
Such a program is called an assembler. The name comes from the fact that much of what
an assembler does is to look up the pieces of an instruction in a table to find the
corresponding binary code (such as ADD = 1001, R1 = 001, R3 = 011, R5 = 101), and then
assemble these binary pieces of the instruction into a complete machine language instruction

(1001 001 011 101). The assembler also puts the instructions together in the specified
sequence to create a complete program.
Assembler A program that translates an assembly language program into machine code.
Assembly language is a step in the right direction, but it still makes us think in terms of
machine instructions. Eventually, computer scientists developed high-level programming
languages. These languages are easier to use than assembly language because they are
closer to English and other natural languages (see FIGURE 1.4).
FIGURE 1.4 Levels of Abstraction
Description
A program called a compiler translates programs written in high-level languages (C++, for
example) into machine language. A program in a high-level language can run on any
computer that has the appropriate compiler. This is possible because most high-level
languages are standardized, which means that an official description of the language exists.

Compiler A program that translates a high-level language into machine code.
A program in a high-level language is called a source program. To the compiler, a source
program is just input data. It translates the source program into a machine language program
called an object program (see FIGURE 1.5). If there are errors in the program, the compiler
instead generates messages indicating the nature and location of the errors.
Source program A program written in a high-level programming language.
Object program The machine language version of a source program.
FIGURE 1.5 High-Level Programming Languages Allow Programs to Be Compiled on
Different Systems
Description
One benefit of using standardized high-level languages is that they allow you to write
portable (or machine-independent) code. AsFigure 1.5 emphasizes, a single C++ program
can be used on different machines, whereas a program written in assembly language for an
Intel computer (as found in many laptops) will not run on an Arm computer (as found in most
phones).

It is important to understand that compilation and execution are two distinct processes.
During compilation, the computer runs the compiler program. During execution, the object
program is loaded into the computer’s memory unit, replacing the compiler program. The
computer then runs the object program, doing whatever the program instructs it to do (see
FIGURE 1.6).
FIGURE 1.6 Compilation and Execution
Description
BACKGROUND INFORMATION Compilation Versus
Interpretation
Some programming languages—Python and JavaScript, for example—are translated by
an interpreter rather than by a compiler. An interpreter translates and executes each
instruction in the source program, one at a time. In contrast, a compiler translates the
entire source program into machine language, after which execution of the object program
takes place. The difference between compilation and interpretation is like the difference
between translating a book into another language (say, translating Goethe’s Faust from
German to English) and a live interpretation into English of a speech being given in
German.
What Kinds of Instructions Can Be Written in a Programming
Language?

The instructions in a programming language reflect the operations a computer can perform:
A computer can transfer data from one place to another.
A computer can input data from an input device (a keyboard or mouse, for example) and
output data to an output device (a screen, for example).
A computer can store data into and retrieve data from its memory and secondary storage
(parts of a computer that we discuss in the next section).
A computer can compare two data values for equality or inequality.
A computer can perform arithmetic operations (addition and subtraction, for example)
very quickly.
Programming languages require that we use certain control structures to express
algorithms as programs. There are five basic ways of structuring statements (instructions) in
most programming languages: sequentially, conditionally, repetitively, with subprograms, and
concurrently (see FIGURE 1.7).


Description
FIGURE 1.7 Basic Control Structures of Programming Languages
A sequence is a series of statements that are executed one after another.
Selection, the conditional control structure, executes different statements depending on
certain conditions.
The repetitive control structure, called a loop, repeats statements while certain conditions
are met.
The subprogram allows us to structure a program by breaking it into smaller units.
Concurrency allows multiple operations to happen at the same time.
Each of these ways of structuring statements controls the order in which the computer
executes the statements, which is why they are called control structures.
Imagine you’re driving a car. Going down a straight stretch of road is like following a
sequence of instructions. When you come to a fork in the road, you must decide which way to
go and then take one or the other branch of the fork. This is what the computer does when it
encounters a selection control structure (also called a branch) in a program. Sometimes you
have to go around the block several times to find a place to park. The computer does the
same sort of thing when it encounters a loop in a program.
A subprogram is a process that consists of multiple steps. Every day, for example, you
follow a procedure to get from home to work. It makes sense, then, for someone to give you
directions to a meeting by saying, “Go to the office, then go four blocks west” without
specifying all the steps for getting to the office. Subprograms simplify the task of writing large
programs.
Concurrency is like sending someone to the bakery to get a birthday cake while you go to a
party store to get decorations. Most computers today actually consist of multiple processors
(called cores), meaning that programs can split up independent pieces of a problem to run
simultaneously, and thus finish more quickly.
What Is Software Maintenance?
In the life cycle of a program, the maintenance phase accounts for the majority of a typical
program’s existence. Programmers will develop a program to meet a set of specifications, but
cannot foresee how it will be used in the future. If the initial implementation is inadequate to
support some future use, a new team of programmers will need to modify the program. After

many such modifications, the code can become so complicated that it is difficult to identify the
purpose of some of the original instructions.
Successive attempts to extend a program will often produce errors because programmers
fail to comprehend the ways that earlier changes to the program will interact with new
changes. In some cases, testing fails to reveal those errors before the modified program is
released, and users discover the error. Then, fixing the bugs becomes a new maintenance
task that is often done hastily because users are clamoring for their software to work. The
result is code that is even harder to understand. In time, it can become so bad that every
attempt to fix errors produces new errors. Although the best solution may be to start over, the
cost of a complete rewrite for a large software package may be so great that a company can’t
afford it, even though users are moving to a competitor.
SOFTWARE MAINTENANCE CASE STUDY
An Introduction to Software Maintenance
The preceding discussion is intended to illustrate the importance of developing skills not
just in writing new code, but also in working with existing code. These Software
Maintenance Case Study sections walk you through the process of typical maintenance
tasks. Unlike the Problem-Solving Case Study sections, where we begin with a problem,
solve it, and then code a program, here we begin with a program and see how to
understand what it does before making some change.
Let’s start with something extremely simple, just to get a sense of what we’ll be doing in
future Software Maintenance Case Study sections. We keep this example so simple that
you don’t even have to know anything about C++ to follow what’s happening. But in
following our steps through this process, you’ll get a sense of what’s involved in working
with programs.
MAINTENANCE TASK: Enter the “Hello World” application program, changing it to output
“Hello Universe” instead.
EXISTING CODE
Description
DISCUSSION: The classic first application that is written by many beginners is generically
known as “Hello World.” Its sole purpose is to display a greeting from the computer to the

programmer. There are many variations of the message, but the traditional one is “Hello
World!” The maintenance task is to change the existing message to “Hello Universe!”
Looking at this code, you can immediately see the message, enclosed in quotes. Your
first temptation would be to just change the word “World” to “Universe”. (Even without
knowing any C++, you’re already programming!) In such a simple case, that strategy may
be adequate; with a larger application, however, such an approach could result in the
creation of more problems. With any maintenance effort, we must first observe and record
the current behavior of the application. If it isn’t working initially, you may think that your
changes are the source of a preexisting problem and waste time attempting to fix the
problem by correcting your changes.
Thus the first step in this maintenance task is to enter the application exactly as it is
written and run it to ensure that it works. Unless you’ve written programs before, it is hard
to appreciate how precisely you must type C++ code. Every letter, every capitalization,
every punctuation mark is significant. There are exceptions, which you’ll see later, but for
now, it is good practice to enter this application exactly as it appears here. For example,
can you spot the error in the following version of the code that fails to run? All you have to
do is compare it, letter by letter, with the preceding version, to find the difference.3
Description
Once we are sure that the program works as claimed, we can be sure that new
problems are associated with our modifications.
Entering an application involves typing it into the computer with an editor. A word
processor is one example of an editor. Most programming systems use a specialized
code editor that has features to help us enter programs. For example, a code editor may
indent lines automatically to show relationships between them, and color-code elements of
the code to help us locate them.
Depending on the programming system that you are using, you may need to begin by
creating a new “project,” which is the system’s way of organizing the information it keeps
about your application. Typically, creating a new project involves selecting the “New
Project” item from the File menu of the programming system and entering a project name
in a dialog box that appears.

Description
In another programming system, you may need to create a new file directory manually
and tell the editor to store your code file there. There are too many different C++
programming systems for us to show them all here. You should consult a tutorial or help
screens for your particular system to learn the specifics.
Once the application has been entered, you run it (the programming system compiles it
and directs the computer to execute the object file). Here’s what happens when we try to
run the erroneous version of Hello World in one system: A red mark appears in the margin
next to the fifth line, and the message, “error: ‘Cout’ was not declared within this scope”
appears in another window.

Description
Every programmer gets these kinds of error messages at some time. Very few of us
are perfect typists! Rather than being afraid of seeing such messages, we come to expect
them, and are pleasantly surprised on the rare occasions when we’ve entered code
without typos. Usually, we enter some code, look it over for mistakes, and run it to see if
the computer finds any more. We then use the error messages to help us find remaining
typos and fix them. Here’s what happens when the application is at last correct:
Now we know that the program works, and we can start changing it. Of the seven lines
of code after the comments, the first three and the sixth are general instructions that
appear in almost all programs. The braces are a form of punctuation in a C++ application.
It is the fifth line that is specific to this problem.

Description
Now, let’s try making our change, substituting “Universe” for “World”—in two places. We
must also change the documentation comments. Here’s the revised application, with
“Universe” substituted for “World”.
Description
Running this application produces just the result that we desire:
Is that it? Could it really be so simple? Well, actually no. We edited our existing Hello
World file, so we no longer have the original code. It’s better to change a copy of the
working version of a program. That way, we keep a working baseline to compare against
the new version. And if things really go wrong with our changes, we can start over from a
new copy of the working code.
To correct this situation, we really should have created a new project, perhaps called
HelloUniverse, and copied the code from our existing project into the new one. Then we
can edit the fifth line and save the change without affecting the original.
Software Maintenance Tips
1. Check that the existing code works as claimed.

2. Make changes to a copy of the existing code. With extensive changes, focus on
making one change work at a time and save a copy of that version of the code before
moving on to the next change.
3. Even if the desired functionality has been achieved, it is necessary to change related
aspects of the program to leave clean, consistent code for the next maintenance
programmer.
4. Update the documentation to reflect the changes.
QUICK CHECK
1.2.1 What is the input and output of a compiler?
1.2.2 Which of the following tools translates a C++ program into machine language:
editor, operating system, compiler, or assembler?
1.2.3 What are the five basic ways of structuring instructions in most programming
languages?
1.2.4 What happens when a program encounters a selection statement during
execution?
1.2.5 What happens when a program encounters a loop statement during execution?
1.2.6 What are subprograms used for?
3 In the fifth line following the introductory comments, the word “cout” has been capitalized
instead of being typed entirely in lowercase.

1.3 What’s Inside the Computer?
You can learn how to write and run programs without knowing much about computers. But if
you know something about the parts of a computer, you can better understand the effect of
each instruction in a program.
Most computers have five basic components: the memory unit, the arithmetic/ logic unit,
the control unit, input devices, and output devices. FIGURE 1.8 is a stylized diagram of the
basic components of a computer.
FIGURE 1.8 Basic Components of a Computer
Description
The memory unit consists of storage cells, each capable of holding a piece of data. Each
cell has a distinct address to which a machine language program refers when it stores data
into it or retrieves data from it. These storage cells are called memory locations.4 The
memory unit holds data and instructions, as shown in FIGURE 1.9.
Memory unit Internal data storage in a computer.
The part of the computer that follows instructions is called the central processing unit
(CPU). The CPU usually has two components. The arithmetic/logic unit (ALU) performs
arithmetic operations (addition, subtraction, multiplication, and division) and logical operations
(comparing two values). The control unit directs the actions of the other components so that
program instructions are executed in the correct order.

Central processing unit (CPU) The part of the computer that executes the instructions
(program) stored in memory; made up of the arithmetic/logic unit and the control unit.
Arithmetic/logic unit (ALU) The component of the central processing unit that performs
arithmetic and logical operations.
Control unit The component of the central processing unit that controls the actions of the
other components so that instructions (the program) are executed in the correct sequence.
FIGURE 1.9 Memory
Description
For computers to be useful, there must be ways of getting data into and out of them.
Input/output (I/O) devices handle these types of operations. Keyboards and trackpads are
common input devices. A display screen is a common output device, as are printers. Some
devices, such as secondary storage or a connection to a computer network, are used for both
input and output.
Input /output (I/O) devices The parts of the computer that accept data to be processed
(input) and take the results of processing from the computer (output).
For the most part, computers simply move and combine data in memory. The many types
of computers differ primarily in the size of their memories, the speed with which data can be
recalled, the efficiency with which data can be moved or combined, and limitations on I/O
devices.
When a program is executing, the computer carries out a series of steps for each
instruction, referred to as the fetch–execute cycle:
1. The control unit retrieves the next machine-language instruction from memory (fetch).
2. The instruction is translated into control signals (decode).
3. The control signals tell the appropriate unit (arithmetic/logic unit, memory, I/O device) to
perform (execute) the instruction.
4. Save results of computation as necessary (write).
5. The sequence repeats from Step 1.

Computers can have a wide variety of peripheral devices attached to them. An auxiliary
storage device, or secondary storage device, holds data and programs for the computer
outside of its main memory. Typical auxiliary storage devices are disk drives and flash
memory. A disk drive uses a thin disk made out of magnetic material. A read/write head
containing an electromagnet travels across the spinning disk, retrieving or recording data in
the form of magnetized spots on the surface of the disk. A flash memory is a silicon chip
containing electronic switches that can be locked into either the on or off state, representing a
binary 1 or 0, respectively. Unlike normal computer memory, disk and flash memory retain
their contents when the power is turned off.
Peripheral device An input, output, or auxiliary storage device attached to a computer.
Auxiliary storage device A device that stores data outside the computer’s main memory.
Other examples of peripheral devices include the following:
Scanners, which convert images on paper into data
DVD (digital versatile disc), which was developed to store video
WiFi radios that connect a computer to wireless networks
Audio speakers and headphones (wired and wireless)
Microphones and electronic musical instruments
Game controllers
Digital cameras
Together, all of these physical components are known as hardware. The programs that
control the hardware are called software. Hardware usually is fixed in design; software is
easily changed. In fact, the ease with which software can be manipulated is what makes the
computer such a versatile, powerful tool.
Hardware The physical components of a computer.
Software Computer programs; the set of all programs available on a computer.
In addition to the programs that we write or run, some software is integral to making
computers usable. The operating system simplifies the user/computer interface, making it
easier for humans to use the machine and manage the efficient use of the computer’s
resources (see FIGURE 1.10). It executes programs, manages windows on the screen,
optimizes secondary storage, secures the computer against unauthorized use, and controls
connections to networks.
Operating system Software that manages all of the computer’s resources
User/computer interface A connecting link that translates between the computer’s
internal representation of data and representations that humans are able to work with.

FIGURE 1.10 User/Computer Interface
Description
Although solitary (standalone) computers are sometimes used, most computers are
connected to a network. In a local area network (LAN), computers are connected by wired or
wireless routers and must be reasonably close together, as in a single building. In a wide area
network (WAN), the computers can be far apart geographically. The most well-known wide-
area network is the Internet, which was originally used by universities, businesses, and
government agencies to exchange research information. The Internet exploded in popularity
with the establishment of the World Wide Web, a system of links for accessing web pages.
BACKGROUND INFORMATION What Makes One Computer
Faster Than Another?
The faster a computer is, the more quickly it responds to our commands. But what factors
affect the speed of a computer? In general, the answer is rather complex, but we can
easily appreciate the essential issues.
In computer advertising you often see numbers such as 3.2 GHz, and the ads clearly
imply that this is an important contributor to speed. But what does it really reflect? GHz is
the abbreviation for gigahertz, meaning billions of cycles per second. What’s cycling at this
speed is an electrical signal called the clock, which is a continuous sequence of precisely
regulated on/off pulses that coordinates the actions of the other circuitry in the computer.
As an analogy, think of it like the rhythmic swinging of an orchestra conductor’s baton,
keeping all of the instruments playing in time with each other. The clock ensures that the
components of the computer are doing their jobs in unison. The faster the clock, the faster
the components work. But that’s just one factor that affects speed.
Clock An electrical circuit that sends out a train of pulses to coordinate the actions of
the computer’s hardware components. The speed of the clock is measured in Hertz

(cycles per second).
Although we have described the fetch–execute cycle as if the computer fetches an
instruction and executes it to completion before fetching the next one, modern computers
are not so simple. They often execute multiple instructions at once. For example, most
can simultaneously do integer and real arithmetic, while retrieving values from memory. In
addition, they start fetching the next instruction from memory while executing prior
instructions. Most computers today have multiple cores, each of which is a CPU with
some dedicated memory. Different cores can be running different programs or different
parts of the same program at the same time (parallel processing).
The number of instructions that the computer can execute simultaneously also has a
significant effect on speed. A 1.8-GHz computer that can process many instructions at
once can be significantly faster than a 3.6-GHz computer that handles fewer instructions in
parallel. The only way to accurately judge the speed of a computer is to run an application
and measure the time it takes to execute.
Other major hardware factors that affect speed are the amount of main memory (RAM)
and speed of secondary storage. When a computer has more RAM, it can work on more
programs and data at once. With less RAM, it must keep more of the programs and data
on secondary storage, shuffling them in and out of RAM as it needs them. Secondary
storage can take as much as a million times longer to access than RAM, so you can see
that a computer with too little RAM can be slowed down tremendously.
Software also affects speed. As you will see in Chapter 6, where we discuss analysis of
algorithms, problems can be solved more or less efficiently. A program based on an
inefficient solution can be vastly slower than one that is more efficient. As a programmer,
then, you can have a strong influence on how fast the computer seems to be.
QUICK CHECK
1.3.1 What are the five basic components most computers have?
1.3.2 Besides data, what else is held by the memory unit?
1.3.3 What do we call the combination of the control unit and the arithmetic/logic unit?
1.3.4 What is the general term that we use to refer to the physical components of the
computer?
1.3.5 What are the steps taken by the computer’s fetch–execute cycle
4 The memory unit is also referred to as RAM, an acronym for random-access memory (so
called because we can access any location at random).

1.4 Ethics and Responsibilities in the Computing
Profession
Every profession operates with a set of ethics that helps to define the responsibilities of its
practitioners. For example, medical professionals have an ethical responsibility to keep
information about their patients confidential. Engineers must protect the public and
environment from harm that may result from their work. Writers are ethically bound not to
plagiarize, and so on.
The computer can affect people and the environment in dramatic ways. As a consequence,
it challenges society with ethical issues. Some existing ethical practices apply to the
computer, whereas other situations require new rules. In some cases, it will be up to you to
decide what is ethical.
Data Piracy
Digital data is easy to copy. But just like physical books, data is usually copyrighted—it is
illegal to copy data without the permission of its creator. Such copying is called data piracy.
Data piracy The unauthorized copying of data for either personal use or use by others.
Copyright laws exist to protect the creators of books and art so they can make a profit. A
major movie or computer game can cost millions of dollars to develop, which is reflected in its
purchase price. Well-recorded music is also costly to produce. If people make unauthorized
copies, then the creators are not compensated.
Data pirates sometimes rationalize their theft with the excuse that they’re just making one
copy for their own use. It’s not as if they’re selling a bunch of bootleg copies, after all.
Nevertheless, they are cheating the creators out of being paid for their work.
Computing professionals have an ethical obligation to not engage in data piracy and to try to
stop it from occurring. You should never copy protected content without permission, which
often just involves a small fee.
This rule isn’t restricted to duplicating copyrighted content; it includes plagiarism of all or
part of code that belongs to anyone else. If someone gives you permission to copy some of
their code, then, just like any responsible writer, you should acknowledge that person with a
citation in the comments.
Privacy of Data
The computer enables the compilation of databases containing useful information about
people, companies, and so on. These databases allow employers to issue payroll checks,
banks to cash a customer’s check at any branch, the government to collect taxes, and mass
merchandisers to send out spam email. Even though we may not care for every use of

databases, they generally have positive benefits. However, they can also be used in negative
ways.
For example, a car thief who gains access to a state’s motor vehicle database could print
out a “shopping list” of valuable car models with their owners’ addresses. An industrial spy
might steal data from one company and sell it to a competitor. Although these are obviously
illegal acts, computer professionals face other situations that are not as clear-cut.
Suppose your job includes managing the company payroll database. You might be tempted
to poke around in it to see how your salary compares to others—but that is an unethical
invasion of your associates’ privacy. Any information about a person that is not clearly public
should be considered confidential. An example of public information is a phone number on a
company web page. Private information is anything that has been provided with an
understanding that it will be used only for a specific purpose (such as the data on a loan
application).
A computing professional has a responsibility to avoid taking advantage of special access
that they may have to confidential data. The professional also has a responsibility to guard
that data from unauthorized access. Guarding data can involve such simple measures as
using passwords that are difficult to guess or implementing more complex measures such as
file encryption.
Use of Computer Resources
A computer is an unusual resource because there is no significant physical difference
between a computer that is working and one that is sitting idle. By contrast, a car is in motion
when it is working. Thus to use a car without permission requires taking it physically—stealing
it. However, someone can make unauthorized use of a computer without physically taking it,
by using its time and resources, often referred to as hacking.
Hackers may have malicious intentions, such as stealing data or using a compromised
computer to hide their identity while committing other crimes. One destructive kind of program
is a virus—a program that replicates itself, with the goal of spreading to other computers,
usually via email or shared files. Some viruses can be very destructive. Incidents have
occurred in which viruses have cost millions of dollars in data losses. In contrast to a virus,
which is spread by contact between users, a worm exploits gaps in a computer’s security,
hijacking it to search the Internet for other computers with the same gaps. When a computer
is taken over and used for some other purpose, such as sending fake social media posts, it is
called a zombie.
Virus Malicious code that replicates and spreads to other computers through email
messages and file sharing, without authorization, and possibly with the intent of doing
harm.
Worm Malicious code that replicates and spreads to other computers through security
gaps in the computer’s operating system, without authorization, and possibly with the
intent of doing harm.
Zombie A computer that has been taken over for unauthorized use.
Harmful programs such as these are collectively known as malware. Now that spam
accounts for the majority of worldwide email traffic, some viruses have extorted money from

their victims, and zombies have been used to shut down parts of the Internet, the effects of
malware on the computing industry are significant.
Malware Software written with malicious purposes in mind.
Computing professionals should never engage in hacking. We also have a responsibility to
help guard computers we use by watching for signs of unusual activity, writing applications
without introducing security loopholes, installing security updates when they are released,
checking files for viruses, and so on.
Software Engineering
Humans have come to depend greatly on computers in many aspects of their lives. That
reliance is fostered by the perception that computers function reliably; that is, they work
correctly most of the time. However, the reliability of a computer depends on the care that is
taken in writing its software.
Errors in a program can have serious consequences, as the following examples of real
incidents involving software errors illustrate:
An error in the control software of the F-18 jet fighter caused it to flip upside down the first
time it flew across the equator.
A rocket launch went out of control and the rocket had to be blown up because a comma
was typed in place of a period in its control software.
A radiation therapy machine killed several patients because a software error caused the
machine to operate at full power when the operator typed certain commands too quickly.
Even when software is used in less critical situations, errors can have significant effects.
Examples of such errors include the following:
An error in your word processor causes your term paper to be lost just hours before it is
due.
An error in a statistical program causes a scientist to draw a wrong conclusion and
publish a paper that must later be retracted.
An error in a tax preparation program produces an incorrect return, leading to a fine for
the taxpayer.
Programmers have a responsibility to develop software that is free from errors. The
process used to develop correct software is known as software engineering.
Software engineering The application of traditional engineering methodologies and
techniques to the development of software.

Software engineering has many aspects. The software life cycle described at the beginning
of this chapter outlines the stages in the development of software. Different techniques are
used at each stage, and we address many of these in this text. In Chapter 4, we introduce
methodologies for developing correct algorithms. We discuss strategies for testing and
validating programs in every chapter. We use a programming language that enables us to
write readable, well-organized programs, and so on. Some aspects of software engineering,
such as the development of a formal, mathematical specification for a program, are beyond
the scope of this text.
QUICK CHECK
1.4.1 How can you help to keep confidential data private?

1.5 Problem-Solving Techniques
You solve problems every day, often unaware of the process you are going through. In a
learning environment, you usually are given most of the information you need: a clear
statement of the problem, the necessary input, and the required output. In real life, the process
is not always so simple. You often have to define the problem yourself and then decide what
information you have to work with and what the results should be.
After you understand and analyze a problem, you must come up with a solution—an
algorithm. Earlier we defined an algorithm as a procedure for solving a problem in a finite
amount of time. Although you work with algorithms all the time, most of your experience is in
following them. You follow a recipe, play a game, assemble a toy, take medicine. In contrast,
in the problem-solving phase of programming, you will design algorithms. Doing so requires
that you become conscious of the strategies you use to solve problems.
Ask Questions
If you are given a task orally, you ask questions—When? Why? Where?—until you
understand exactly what you have to do. If your instructions are written, you might put
questions in the margin or in some other way indicate that the task is not clear. Your questions
may be answered by a later paragraph, or you might have to discuss them with the person
who gave you the task.
These are some of the questions you might ask in the context of programming:
What do I have to work with—that is, what is my data?
What do the data items look like?
How much data is there?
How will I know when I have processed all the data?
What should my output look like?
How many times will the process be repeated?
What special error conditions might come up?
Look for Things That Are Familiar
Never reinvent the wheel. If you’ve solved a similar problem before, just repeat your solution.
People are good at recognizing similar situations. We don’t have to learn how to go to the
store to buy milk, and then separately learn how to go buy eggs. We know that going to the
store is always the same; only what we buy is different.
In programming, certain problems occur again and again in different guises. A good
programmer immediately recognizes a subtask they have solved before and plugs in the
solution. For example, finding the daily high and low temperatures is really the same problem
as finding the highest and lowest grades on a test: You want the largest and smallest values in
a set of numbers (see FIGURE 1.11).

FIGURE 1.11 Look for Things That Are Familiar
Description
Solve by Analogy
Often a problem may remind you of a similar problem you have seen before. You may find
solving the problem at hand easier if you remember how you solved the other problem. In
other words, draw an analogy between the two problems. For example, a solution to a
perspective-projection problem from an art class might help you figure out how to compute
distances between points in a mapping program. As you work your way through the new
problem, you may find differences from the old problem, but usually these are things you can
deal with one at a time.
Analogy is really just a broader application of the strategy of looking for things that are
familiar. When you are trying to find an algorithm for solving a problem, don’t limit yourself to
computer-oriented solutions. Step back and try to get a larger view of the problem. Don’t
worry if your analogy doesn’t match perfectly—the only reason for using an analogy is that it
gives you a place to start (see FIGURE 1.12). The best programmers are people who have
broad experience solving all kinds of problems.

FIGURE 1.12 Analogy
Description
Means-Ends Analysis
Often the beginning state and the ending state are given; the problem is to identify the actions
that get you from one to the other. Suppose you want to go from Boston, Massachusetts, to
Austin, Texas. You know the beginning state (Boston) and the ending state (Austin). What
actions will get you from one to the other? You can fly, drive, take a bus, and so on. Your
choice depends on the circumstances. If you’re in a hurry, you’ll probably fly.
Once you’ve identified an overall strategy, you have to work out the details. It may help to
establish intermediate goals. Suppose there is a really cheap, direct flight to Austin out of
Chicago. You might decide to divide the trip into legs: Boston to Chicago, and then Chicago to
Austin. Your intermediate goal is to get from Boston to Chicago. Now you just have to
examine the means of meeting that intermediate goal (see FIGURE 1.13).
FIGURE 1.13 Means-Ends Analysis
Description
The overall strategy of means-ends analysis is to define the ends and then to analyze your
means of getting between them. This process translates easily to programming. You begin by
writing down what the input is and what the output should be. Then you consider the actions a
computer can perform and identify the actions that transform the data into the results.
Divide and Conquer
We often break up large problems into smaller units that are easier to handle. Cleaning the
whole house may seem overwhelming; cleaning the rooms one at a time seems much more
manageable. If we have friends to help us, dividing the labor makes the overall task go much
faster (parallel processing). The same principle applies to programming: We can break up a
large problem into smaller pieces that we can solve separately (see FIGURE 1.14). The

functional decomposition and object-oriented programming methodologies described in
Chapter 4 are based on the principle of divide and conquer.
FIGURE 1.14 Divide and Conquer
Description
The Building-Block Approach
Another way of attacking a large problem is to see if any solutions for smaller pieces of the
problem exist. It may be possible to combine these solutions to solve most of the big problem.
This strategy is a combination of the look-for-familiar-things and divide-and-conquer
approaches. You look at the big problem and see that it can be divided into smaller problems
for which solutions already exist. Solving the big problem is just a matter of putting the existing
solutions together, like mortaring together blocks to form a wall (see FIGURE 1.15).

FIGURE 1.15 Building-Block Approach
Description
Merging Solutions
Another way to combine existing solutions is to merge them on a step-by-step basis. For
example, to compute the average of a list of values, we must both sum and count the values.
If we already have separate solutions for summing values and for counting values, we can
combine them. But if we first do the summing and then do the counting, we have to read the
list twice. We can save steps if we merge these two solutions: Read a value, add it to the
running total, and add 1 to our count before going on to the next value. Whenever the solutions
to subproblems duplicate steps, think about merging them instead of joining them end to end
(see FIGURE 1.16).
FIGURE 1.16 Merging Solutions
Description
Mental Blocks: The Fear of Starting
Writers are all too familiar with the experience of staring at a blank page, not knowing where to
begin. Programmers have the same difficulty when they first tackle a problem. How do we
start?
Remember that you always have a way to begin solving any problem: Write it down on
paper in your own words so that you understand it. Once you paraphrase the problem, you
can focus on the subparts individually instead of trying to tackle it all at once. This process

helps you see pieces of the problem that look familiar or that are analogous to other problems
you have solved, and it pinpoints areas where something is unclear and you need more
information.
As you write down a problem, you tend to group things together into small, understandable
chunks, which may be natural places to split the problem up—to divide and conquer. Your
description of the problem may collect all of the information about data and results into one
place for easy reference. Then you can see the beginning and ending states necessary for
means-ends analysis.
Most mental blocks are caused by a failure to really understand the problem. Rewriting the
problem in your own words is a great way to break the ice and start seeing what is required
for a solution.
Algorithmic Problem Solving
Coming up with a procedure for solving a particular problem is not always a cut-and-dried
process. In fact, it often involves trial-and-error attempts and refinements. You test each
attempt to see if it really solves the problem. If it does, great. If it doesn’t, you try again. Don’t
be afraid to try something. Every failure makes you wiser. Solving any nontrivial problem
typically requires a combination of the techniques we’ve described.
Remember that the computer can only do certain things (see What Kinds of Instructions
Can Be Written in a Programming Language?). Your primary concern, then, is how to make it
transform or process the input data to produce the desired output. Once you are familiar with
the allowable instructions in your programming language, you won’t design an algorithm that is
difficult to code.
In the Problem-Solving Case Study that follows, we develop a program to determine
whether a year is a leap year. This case study typifies the thought processes involved in
writing an algorithm and coding it as a program, and it shows you what a complete C++
program looks like.
BACKGROUND INFORMATION The Origins of C++
In the late 1960s and early 1970s, Dennis Ritchie created the C programming language at
AT&T Bell Labs for use in the development of the UNIX operating system. C combines the
low-level features of assembly language with the ease of use of a high-level language.
Roughly 90% of UNIX was written in C and the remainder in assembly language.
People often wonder where the name “C” came from. In the 1960s, a programming
language named BCPL (Basic Combined Programming Language) had a small but loyal
following, primarily in Europe. From BCPL, another language arose with its name
abbreviated to B. For his language, Dennis Ritchie adopted features from the B language
and decided that its successor should be named C. So the progression was from BCPL to
B to C.
In 1985, Bjarne Stroustrup, also of Bell Labs, invented the C++ programming language.
To the C language he added features for data abstraction and object-oriented programming
(topics we discuss in Chapters 10 and 12). Instead of naming the language D, the Bell
Labs group named it C++. ++ signifies the increment operation in the C and C++
languages. Given a variable x, the expression x++ means to increment (add one to) the

current value of x. Therefore, the name C++ suggests an enhanced (“incremented”)
version of the C language.
As C++ grew in popularity, different companies began adding different features to it, so
that C++ programs were no longer portable. The programming community agreed that the
language needed to be standardized, so a joint committee of the International Organization
for Standardization (ISO) and the American National Standards Institute (ANSI) developed
the ISO/ANSI language standard for C++, which was officially approved in mid1998. The
standard was subsequently updated with new features in 2011, 2014, and 2017.
Although C was created as a systems programming language, both C and C++ are
widely used today in industry and personal computing. C++ is powerful and versatile,
embodying a wide range of programming concepts. In this text you will learn a substantial
portion of the language, but C++ incorporates sophisticated features that go well beyond
the scope of an introductory course.
QUICK CHECK
1.5.1 Who invented the C++ programming language?
1.5.2 When would you use the building-block approach to solve a problem?
1.5.3 What does it mean to use divide and conquer to solve a problem?
1.5.4 What is the overall strategy of means-ends analysis?
1.5.5 Which problem-solving technique should be used as an alternative to the
building-block approach when we want to save steps?
Problem-Solving Case Study
LEAP YEAR ALGORITHM
PROBLEM: You need to write a set of instructions that can be used to determine whether
a year is a leap year. The instructions must be very clear because they will be used by a
class of fourth graders who have just learned about multiplication and division. To check
that the algorithm works correctly, you will code it as a C++ program and test it.
DISCUSSION: The rule for determining whether a year is a leap year is that a year must
be evenly divisible by 4, but not a multiple of 100. When the year is a multiple of 400, it is a
leap year anyway. We need to write this set of rules as a process (an algorithm) that can
be followed easily by the fourth graders.
First, we break this into major steps using the divide-and-conquer approach. There are
three obvious steps in almost any problem of this type:
1. Get the data.
2. Compute the results.
3. Output the results.

What does it mean to “get the data”? By get, we mean read or input the data. We need
one value: a four-digit year. So that the user knows when to enter the value, we have the
computer output a message indicating when it is ready to accept the value (this is called a
prompting message, or a prompt). Therefore, to get the data, we have the computer do
these two steps:
Get Data
Prompt the user to enter a four-digit year
Read the year
Next, we check whether the year can be a leap year (is divisible by 4), and then we
check to see if it is one of the exceptional cases. Using divide and conquer, we are going
to make the Is Leap Year test a separate subalgorithm within the main algorithm. That way
we can focus on its details and keep the main algorithm simple. Our high-level Is Leap
Year subalgorithm is as follows:
Is Leap Year
IF the year is not divisible by 4
then the year is not a leap year
ELSE check for exceptions
Clearly, we need to expand these steps with more detailed instructions, because neither
the fourth graders nor the computer knows what “divisible” means. We use means-ends
analysis to solve the problem of how to determine when something is divisible by 4. Our
fourth graders know how to do simple division that results in a quotient and a remainder.
We can tell them to divide the year by 4, and if the remainder is zero, then it is divisible by
4. Thus the first line is expanded into the following:
Is Leap Year revised
Divide the year by 4
IF the remainder is not 0
then the year is not a leap year
ELSE check for exceptions
Checking for exceptions when the year is divisible by 4 can be further divided into two
parts: checking whether the year is also divisible by 100 and whether it is further divisible
by 400. Given how we did the first step, this is easy:
Checking for exceptions
Divide the year by 100
IF the remainder is 0
then the year is not a leap year
Divide the year by 400
IF the remainder is 0
then the year is a leap year
These steps are confusing by themselves. When the year is divisible by 400, it is also
divisible by 100, so we have one test that says it is a leap year and one that says it is not.

What we need to do is to treat the steps as building blocks and combine them. One of the
operations that we can use in such situations is to check when a condition does not exist.
For example, if the year is divisible by 4 but not by 100, then it must be a leap year. If it is
divisible by 100 but not by 400, then it is definitely not a leap year. Thus the third step
(check for exceptions when the year is divisible by 4) expands to the following three tests:
Checking for exceptions revised
IF the year is not divisible by 100
then it is a leap year
IF the year is divisible by 100 but not by 400
then it is not a leap year
IF the year is divisible by 400
then it is a leap year
We can simplify the second test because the check for being divisible by 100 is just the
opposite of the first test—if the subalgorithm determines that year is not a leap year in the
first test, it can return to the main algorithm, conveying this fact. The second test will then
be performed only if the year is actually divisible by 100. Similarly, the last test is really just
the “otherwise” case of the second test. If the second test did not return, then we know that
the year has to be divisible by 400. Once we translate these simplified tests into steps that
the fourth graders know how to perform, we can write the subalgorithm that returns true if
the year is a leap year and false otherwise. Let’s call this subalgorithm IsLeapYear and put
the year it is to test in parentheses beside the name.
The only piece left is to write the results. If IsLeapYear returns true, then we write that
the year is a leap year; otherwise, we write that it is not a leap year. Now we can write the
complete algorithm for this problem.
Main Algorithm
Prompt the user to enter a four-digit year
Read the year
IF IsLeapYear(year)
Write year is a leap year

ELSE
Write year is not a leap year
Not only is this algorithm clear, concise, and easy to follow, but by the time we get to
Chapter 5, you will see that it is easy to translate into a C++ program. We present the
program here so that you can compare it to the algorithm. You do not need to know how to
read C++ programs to begin to see the similarities. Note that the symbol % is what C++
uses to calculate the remainder, and whatever appears between // and the end of the line
is a comment that is ignored by the compiler.

Description
Here is the input and the output of a test run:
Description

Summary
Computers are everywhere in our lives, affecting how we work and enabling many
aspects of modern life. But computers are dumb; they must be told what to do. A true
computer error is extremely rare (usually due to a component malfunction). Because we
tell the computer what to do, most of their errors are really human errors.
Computer programming is the activity of planning a process for a computer to follow. It
involves problem-solving and implementation phases. After analyzing a problem, we
develop and test a general solution (algorithm). The algorithm becomes a concrete solution
—a program—when we write it in a high-level programming language. The instructions that
make up our program are then compiled into machine code, the language the computer
uses. After correcting any errors (“bugs”) that show up during testing, our program is
ready to use.
Once we begin to use the program, it enters the maintenance phase. Maintenance
involves correcting any errors discovered while it is being used and changing it to reflect
changes in the user’s requirements.
Data and instructions are represented as binary numbers (numbers consisting of just 1s
and 0s) in computers. The process of converting data and instructions into a form usable
by the computer is called coding.
A programming language reflects the range of operations a computer can perform. The
control structures in a programming language—sequence, selection, loop, subprogram,
and concurrent—are based on these operations. In this text, you will learn to write
programs in the high-level programming language called C++.
Computers are composed of five basic parts: the memory unit, the arithmetic/logic unit,
the control unit, input devices, and output devices. The arithmetic/logic unit and control unit
together are called the central processing unit. The physical parts of the computer are
called hardware. The programs executed by the computer are called software.
The operating system is software designed to simplify the user/computer interface and
efficiently manage the computer’s resources.
Computing professionals are guided by a set of ethics, as are members of other
professions. Copying content only with permission, including attribution to other
programmers when we make use of their code, guarding the privacy of confidential data,
using computer resources only with permission, and carefully engineering our programs
so that they work correctly are among the responsibilities that we have.
Problem solving is an integral part of the programming process. Although you may have
little experience programming computers, you have lots of experience solving problems.
The key is to stop and think about which strategies you use to solve problems, and then to
use those strategies to devise workable algorithms. Among those strategies are asking
questions, looking for things that are familiar, solving by analogy, applying means-ends
analysis, dividing the problem into subproblems, using existing solutions to small problems
to solve a larger problem, merging solutions, and paraphrasing the problem to overcome a
mental block.
The computer is one of the most common tools in all of human society. Learning to
program in C++ can help you use this powerful tool effectively.


Quick Check Answers
The Quick Checks are intended to help you decide if you’ve met the goals set forth at the
beginning of each chapter. If you understand the material in the chapter, the answer to
each question should be fairly obvious. After reading a question, check your response
against the answers listed at the end of the chapter. If you don’t know an answer or don’t
understand the answer that’s provided, turn to the section(s) preceding the question to
review the material.
1.1.1 A computer program. 1.1.2 No, a computer is not intelligent. A human must analyze
the problem and create a sequence of instructions for solving the problem. A computer
can repeat that sequence of instructions over and over again. 1.1.3 An algorithm can be
written in any language, to be carried out by a person or a processor of any kind. A
program is written in a programming language, for execution by a computer. 1.1.4 The
Problem-Solving phase focuses on understanding the problem and developing a general
solution, the Implementation phase translates the algorithm into a computer program, and
the Maintenance phase emphasizes the use and maintenance of a computer program.
1.1.5 A programming language has a very small vocabulary of words and symbols and a
very precise set of rules that specify the form and meaning of valid language constructs.
1.2.1 The compiler inputs a source program written in a high-level language and outputs an
equivalent program in machine language. Compilers also output error messages when
errors are detected. 1.2.2 Compiler. 1.2.3 Sequentially, conditionally, repetitively, in
subprograms, and concurrently. 1.2.4 It will execute different statements depending on
certain conditions. 1.2.5 The program repeats statements while a certain condition is met.
1.2.6 They allow us to write parts of a program separately. 1.3.1 The memory unit, the
arithmetic/logic unit, the control unit, input devices, and output devices. 1.3.2 The memory
unit also holds program instructions. 1.3.3 The central processing unit. 1.3.4 Hardware.
1.3.5 (1) Fetch an instruction, (2) translate the instruction into control signals (decode), (3)
the control signals tell the computer how to execute the instruction, (4) save results of
computations as needed (write), and (5) repeat this sequence starting at (1). 1.4.1 Use
passwords that are difficult to guess, and encrypting stored data. 1.5.1 Bjarne Stroustrup
at Bell Laboratories. 1.5.2 When you see that a problem can be divided into pieces that
may correspond to subproblems for which solutions are already known. 1.5.3 We can
break up a large problem into smaller pieces that we can solve individually to make it
easier to handle. 1.5.4 The overall strategy of means-ends analysis is to define the ends
and then to analyze your means of getting between them. 1.5.5 Merging solutions.

Exam Preparation Exercises
1.1 Match the following terms to their definitions, given below:
a. Programming
b. Computer
c. Algorithm
d. Computer program
e. Programming language
f. Documentation
g. Information
h. Data
i. A programmable device that can store, retrieve, and process data.
ii. Information in a form a computer can use.
iii. A sequence of instructions to be performed by a computer.
iv. A set of rules, symbols, and special words used to construct a computer
program.
v. Planning or scheduling the performance of a task or event.
vi. Any knowledge that can be communicated.
vii. The written text and comments that make a program easier for others to
understand, use, and modify.
viii. A step-by-step procedure for solving a problem in a finite amount of
time.
1.2 List the three steps in the problem-solving phase of the software life cycle.
1.3 List the steps in the implementation phase of the software life cycle.
1.4 If testing uncovers an error, to which step in the software life cycle does the
programmer return?
1.5 Explain why the following series of steps isn’t an algorithm, and then rewrite the
steps to make a valid algorithm:
Wake up.
Go to school.
Come home.
Go to sleep.

Repeat from first step.
1.6 Match the following terms with their definitions, given below:
a. Machine language
b. Assembly language
c. Assembler
d. Compiler
e. Source program
f. Object program
i. A program that translates a high-level language into machine code.
ii. A low-level programming language in which a mnemonic is used to
represent each of the instructions for a particular computer.
iii. The machine language version of a source program.
iv. A program that translates an assembly language program into machine
code.
v. The language, made up of binary coded instructions, that is used directly
by the computer.
vi. A program written in a high-level programming language.
1.7 What is the advantage of writing a program in a standardized programming
language?
1.8 What does the control unit do?
1.9 The editor is a peripheral device. True or false?
1.10 Memory (RAM) is a peripheral device. True or false?
1.11 Is it a case of data piracy if you let a friend copy a movie that you bought and
downloaded?
1.12 Match the following problem-solving strategies to the descriptions below:
a. Ask questions.
b. Look for things that are familiar.
c. Solve by analogy.
d. Means-ends analysis.
e. Divide and conquer.
f. Building-block approach.
g. Merging solutions.
i. Break up the problem into more manageable pieces.
ii. Gather more information to help you discover a solution.

iii. Identify aspects of the problem that are similar to a problem in a different
domain.
iv. Combine the steps in two or more different algorithms.
v. Identify aspects of the problem that you’ve solved before.
vi. Join existing problem solutions together.
vii. Look at the input, output, and available operations and find a sequence of
operations that transform the input into the output.

Programming Warm-Up Exercises
1.1 In the following algorithm for making black-and-white photographs in an old-
fashioned darkroom, identify the steps that are branches (selection), loops, or
references to subalgorithms defined elsewhere.
a. Mix developer according to instructions on package.
b. Pour developer into tray.
c. Mix stop bath according to instructions on package.
d. Pour stop bath into tray.
e. Mix fixer according to instructions on package.
f. Pour fixer into tray.
g. Turn off white lights and turn on safelight.
h. Place negative in enlarger and turn on.
i. Adjust size of image and focus, and then turn off enlarger.
j. Remove one piece of printing paper from paper safe and place in enlarging
easel.
k. Turn enlarger on for 30 seconds and then off.
l. Place paper in developer for 1 minute, stop bath for 30 seconds, and fixer for 1
minute.
m. Turn on white lights and inspect the first print, and then turn off white lights.
n1. If first print is too light:
Remove one piece of paper from paper safe, place on easel, and expose for 60
seconds to create a too-dark print. Then place in developer for 1 minute, stop
bath for 30 seconds, and fixer for 1 minute.
n2. If first print is too dark:
Remove one piece of paper from paper safe, place on easel, and expose for 15
seconds to create a too-light print. Then place in developer for 1 minute, stop bath
for 30 seconds, and fixer for 1 minute.
n3. If first print is about right:
Remove one piece of paper from paper safe, place on easel, and expose for 60
seconds to create a too-dark print. Then place in developer for 1 minute, stop
bath for 30 seconds, and fixer for 1 minute. Remove one piece of paper from
paper safe, place on easel, and expose for 15 seconds to create a too-light print.
Then place in developer for 1 minute, stop bath for 30 seconds, and fixer for 1
minute.

o. Analyze too-light and too-dark prints to estimate base exposure time, and then
identify highlights and shadows that require less or more exposure and estimate
the necessary time for each area.
p. Remove one piece of paper from paper safe, place on easel, and expose for
base exposure time, covering shadow areas for estimated time, and then cover
entire print except for highlight areas, which are further exposed as estimated.
Then place print in developer for 1 minute, stop bath for 30 seconds, and fixer for
1 minute.
q. Analyze print from Step p and adjust estimates of times as appropriate.
r. Repeat Steps p and q until a print is obtained with the desired exposure.
s. Document exposure times that result in desired print.
t. Remove one piece of paper from paper safe, place on easel, and expose
according to documentation from Step s. Then place in developer for 1 minute,
stop bath for 30 seconds, and fixer for 4 minutes. Place print in print washer.
u. Repeat step t to create as many prints as needed.
v. Wash all prints for 1 hour.
w. Place prints in print dryer.
1.2 Write an algorithm for brushing teeth. The instructions must be very simple and
exact because the person who will follow them has never done this activity before and
takes every word literally.
1.3 Identify the steps in your solution to Exercise 1.2 that are branches, loops, and
references to subalgorithms defined elsewhere.
1.4 Change the algorithm in Warm-Up Exercise 1.1 so that 10 properly exposed prints
are created each time it is executed.

Case Study Follow-Up
1. Use the algorithm in the leap year case study to decide whether the following years
are leap years.
a 1900
b 2000
c 1996
d 1998
2. Given the algorithm from the leap year case study with the lines numbered as
follows:
1. Divide the year by 4
2. IF the remainder isn’t 0 (Not divisible by 4)
3. RETURN false (We know the year is not a leap year)
4. Divide the year by 100 (To get to this step, year must be divisible by 4)
5. IF the remainder isn’t 0 (Not divisible by 100)
6. RETURN true (We know the year is a leap year)
7. Divide the year by 400
8. IF the remainder isn’t 0 (Not divisible by 400)
9. RETURN false (We know the year is not a leap year)
10. RETURN true (The year is a divisible-by-400 leap year)
Indicate which line of the algorithm tells you whether the date is a leap year in each of
the following cases.
a. 1900 Line =
b. 1945 Line =
c. 1600 Line =
d. 1492 Line =
e. 1776 Line =
3. How would you extend the leap year algorithm to tell you when a year is a
millennium year (a multiple of 1000)?
4. Use the leap year algorithm to determine whether you were born in a leap year.
5. Extend the leap year algorithm so that it tells you when the next leap year will be, if
the input year is not a leap year.
6. Compare the algorithm for determining the leap year with the C++ program that is
shown in the Problem-Solving Case Study. Using the numbering scheme for the
algorithm from Question 2, decide which line (or lines) of the algorithm correspond(s)
to which line (or lines) of the program shown here:
Line Number


Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  2
C++ Syntax and
Semantics, and the
Program Development
Process
KNOWLEDGE GOALS
To understand how a C++ program is composed of one or more subprograms
(functions).
To know what a metalanguage is and how it is used.
To understand the concept of a data type.
To learn the steps involved in entering and running a program.
SKILL GOALS
To be able to:
Read syntax templates so as to understand the formal rules governing C++
programs.
Create and recognize legal C++ identifiers.
Declare named constants and variables of type char and string.
Distinguish reserved words in C++ from user-defined identifiers.
Assign values to variables.
Construct simple string expressions made up of constants, variables, and the
concatenation operator.
Construct a statement that writes to an output stream.
Determine what is printed by a given output statement.

Use comments to clarify your programs.
Construct simple C++ programs.

2.1 The Elements of C++ Programs
In this chapter, we start looking at the rules and symbols that make up the C++ programming
language. We also review the steps required to create and run a program.
C++ Program Structure
In Chapter 1, we talked about the five basic structures for expressing actions in a
programming language: sequence, selection, loop, subprogram, and concurrent. We said that
subprograms allow us to write parts of our program separately and then assemble them into a
working whole. In C++, subprograms are called functions, and a C++ program is a collection
of one or more functions.
Function A subprogram in C++.
Description

Every C++ program must have a function named main. Execution of the program always
begins with the main function. You can think of main as coordinating the actions of the other
functions. For example, when main wants a function named Square to perform a task, main
calls (or invokes) Square. When the Square function completes execution, it returns control to
main, so it can continue executing.
Let’s look at an example of a C++ program with three functions: main, Square, and Cube.
Don’t be too concerned with the details in the program—just observe its overall look and
structure.
Description
In each of the three functions, the left brace ( { ) and the right brace ( } ) mark the beginning
and the end of the statements to be executed. Statements appearing between the braces are
known as the body of the function.
Execution of a program always begins with the first statement of the main function. In our
program, the first statement is
This output statement causes information to appear on the computer’s screen. You will learn
how to construct output statements later in the chapter. Briefly, this statement displays two
items. The first is the message

The second item to be displayed is the value obtained by calling Square, with the value 27 as
the number to be squared. The Square function calculates the square of the number and sends
the computed result (729) back to its caller, main. Now main can display the value 729 and
proceed to its next statement.
In a similar fashion, the second statement in main outputs the message
and then invokes Cube and displays the result, 19683. The complete output from this program
is, therefore,
Both Square and Cube are examples of value-returning functions. A value-returning function
returns a single value to its caller. The word int at the beginning of the first line of the Square
function
states that the function returns an integer value.
Now look at the main function again. You’ll see that the first line of the function is
The word int indicates that main is a value-returning function that returns an integer value. As
you can see, the last line of main is
which returns the value 0 to its caller. But who calls the main function? The operating system.
In C++ programs, the operating system is considered to be the caller of main. The operating
system expects main to return a value when main finishes executing. By convention, a return
value of 0 means everything went okay. A return value of anything else (typically 1, 2, . . . )
means something went wrong. Usually we conclude execution of main by returning 0.
We have now seen what a C++ program looks like—a collection of one or more functions,
including main. We have seen that main is a required function, where execution begins, and
that it returns a value to the operating system. Next we introduce some notation that will help
us precisely define components of the C++ language.
Syntax and Semantics
A programming language is defined by a set of rules that specify how to write valid statements
and what those statements will do when executed. In particular, there are rules for both
syntax (grammar) and semantics (meaning).

Syntax The formal rules governing how valid instructions are written in a programming
language.
Semantics The set of rules that determines the meaning of instructions written in a
programming language.
Syntax is a formal set of rules that defines exactly how combinations of letters, numbers,
and symbols can be used in a programming language. As we saw in Chapter 1, there is no
room for ambiguity in a programming language because the computer doesn’t “know what we
mean.” To avoid ambiguity, syntax rules themselves must be written in a very simple, precise,
formal language called a metalanguage.
Metalanguage A language that is used to write the syntax rules for another language.
Learning to read a metalanguage is like learning to read the notation used in a rule book for
a sport. You may be able to play casual games in a sport after watching others play it for a
while, but professionals need to know the actual rules. Similarly, you could figure out how to
write some simple C++ code by following the examples in this text. But as a professional
programmer, you should learn how to read metalanguage notation.
Syntax rules show us how to take the basic building blocks of the language and assemble
them into constructs, which are syntactically correct structures. If our program doesn’t match
the rules of the language—by misspelling a word or leaving out a comma, for instance—the
program is said to have syntax errors and cannot be compiled.
THEORETICAL FOUNDATIONS Metalanguages
Metalanguage is the word language with the prefix meta, which means “beyond.” In other
words, a metalanguage is a language that goes beyond a normal language by allowing us
to speak precisely about that language. It is a language for talking about languages.
One of the first computer-oriented metalanguages was the Backus–Naur Form (BNF),
which is named for John Backus and Peter Naur, who developed it in 1960. BNF is an
extremely simple language, in the sense that it has very few symbols and rules.
Unfortunately, its minimalist design necessitates using many symbols for even the most
basic definitions. In this text, we use a metalanguage called a syntax template, which
shows at a glance the form of a C++ construct.
Note that syntax rules show only how to write instructions that the compiler can
translate. They do not define what those instructions do (their semantics). Formal
languages for describing semantics exist, but they can be challenging to read. In this text,
we describe the semantics of C++ in English.
Syntax Templates

In this text, we write the syntax rules for C++ using a metalanguage called a syntax template.
A syntax template is a generic example of a C++ construct. Graphic conventions show which
portions are optional and which portions can be repeated. A boldface word or symbol is
written precisely that way in C++. A nonboldface word can be replaced by another template. A
curly brace is used to indicate a list of items, from which one can be chosen.
Let’s look at an example. This template defines an identifier in C++:
Description
The shading indicates a part of the definition that is optional. The three dots ( . . . ) mean that
the preceding symbol or shaded block can be repeated. Thus an identifier in C++ must begin
with a letter or underscore and is optionally followed by one or more letters, underscores, or
digits.
Remember that a word not in boldface can be replaced with another template. Here are the
templates for Letter and Digit:

Description
In these templates, the braces again indicate lists of items from which one item can be
chosen. So a letter can be any one of the uppercase or lowercase letters, and a digit can be
any of the numeric characters 0 through 9.
Now let’s look at the syntax template for the C++ main function:

Description
The main function begins with the word int, followed by the word main and then left and right
parentheses. This first line of the function is the heading. After the heading, the left brace
signals the start of the statements in the function body. The shading and the three dots
indicate that the function body consists of zero or more statements. (In this diagram we have
placed the three dots vertically to suggest that statements usually are arranged vertically.) The
right brace indicates the end of the function body.
In principle, the syntax template allows the function body to be empty. In practice, it should
include a return statement because the int in the function heading states that main returns an
integer value. Thus the shortest C++ program possible is
As you might guess, this program does nothing and then returns to the operating system. To
make it useful, we must insert other C++ statements before the return statement. But before
we can talk about writing statements, we must look at how names are written in C++ and at
some of the elements of a program.
Naming Program Elements: Identifiers
In C++, identifiers are used to name things—things such as subprograms and places in the
computer’s memory. As we just saw, identifiers are made up of letters (A–Z, a–z), digits (0–9),
and the underscore character ( _ ), but must begin with a letter or underscore.
Identifier A name associated with a function or data object and used to refer to that
function or data object.
Remember that an identifier must start with a letter or underscore:

Description
Identifiers beginning with an underscore have special meanings in some C++ systems, so it
is best to begin with a letter. Here are some examples of valid identifiers:
Description
And here are some examples of invalid identifiers and the reasons why they are invalid:
Invalid Identifier
Explanation
40Hours
Identifiers cannot begin with a digit.
Get Data
Blanks are not allowed in identifiers.
box - 22
The hyphen ( -) is a math symbol (minus) in C++.
cost_in_$
Symbols such as $ are not allowed.
int
The word int is predefined in the C++ language.
The last identifier in the table, int, is an example of a reserved word. Reserved words
have specific uses in C++; you cannot use them as programmer-defined identifiers. Appendix
A lists all of the reserved words in C++.
Reserved word A word that has special meaning in C++; it cannot be used as a
programmer-defined identifier.
The LeapYear program introduced in Chapter 1 uses the programmerdefined identifiers in
the following list. (Most of the other words in the program are reserved words.) Notice that we
chose the names to convey how they are used.
Identifier
How It Is Used
year
Year to be tested
IsLeapYear
Whether year is a leap year
MATTERS OF STYLE Using Meaningful, Readable Identifiers

The names we use to refer to things in our programs are totally meaningless to the
computer. The computer behaves in the same way whether we call the value 3.14159265
pi or cake, as long as we always call it the same thing. However, it is much easier for
someone to figure out how a program works if our names actually tell something about
them. Whenever you have to make up a name for something in a program, try to pick one
that would be meaningful to someone else.
C++ is a case-sensitive language, meaning that it considers uppercase letters to be
different from lowercase letters. The identifiers
are four distinct names and are not interchangeable. As you can see, the last of these
forms is the easiest to read. In this text, we describe and follow conventions for using
uppercase letters, lowercase letters, and underscores in identifiers to improve readability.
Now that we’ve seen how to write identifiers, let’s look at some of the things that C++ allows
us to name.
Data and Data Types
A computer program operates on data and produces output. In C++, each piece of data must
be of a specific data type. The data type determines how the data is represented in the
computer and the kinds of processing the computer can perform on it.
Data type A specific set of data values, along with a set of operations on those values.
Some types of data are used so frequently that C++ defines them for us. Examples of
these standard (or built-in) types include int (for working with integer numbers), float (for
working with real numbers having decimal points), and char (for working with character data).
Additionally, C++ allows programmers to define their own data types—known as
programmerdefined (or user-defined) types. Beginning in Chapter 10, we show you how to
define your own data types.
In this chapter, we focus on two data types—one for representing data consisting of a single
character, the other for representing strings of characters. In Chapter 3, we examine the
numeric types in detail.
BACKGROUND INFORMATION Data Storage
Where does a program get the data it needs to operate? Data is stored in the computer’s
memory. Recall that memory consists of cells, each of which can hold a piece of data.
Each memory cell has a unique address (called its location) to which we refer when we
access data there. We can visualize memory as a set of post office boxes, with the box
numbers as the addresses used to designate particular locations.

Description
Programmers often use the term location as a shorthand for saying “the memory cell
whose location is given by this address.” Of course, the actual address of each location is
a binary number in machine language. In C++, we use identifiers to name memory
locations; the compiler translates them into binary for us. This is one of the advantages of
a high-level programming language: It frees us from having to keep track of the numeric
addresses of the memory cells in which our data and instructions are stored.
The char Data Type
The built-in type char describes data consisting of one character—a letter, a digit, or a special
symbol:
Description
Each machine uses a particular character set, the set of characters it can represent. Notice
that each character is enclosed in single quotes (apostrophes). The C++ compiler needs the
quotes to differentiate, say, between the character data ' 8 ' and the integer value 8 because
the two are stored differently inside the machine. Notice also that the blank, ' ', is a valid
character.1
You wouldn’t want to add the character ' A' to the character ' B ' or subtract the character
' 3 ' from the character ' 8 ', but you might want to compare character values. The
character set has a collating sequence, a predefined ordering of all the characters. In ASCII,
for example, ' A' compares less than ' B ', ' B ' less than ' C', and so forth. Also, ' 1 '

compares less than ' 2 ', ' 2 ' less than ' 3 ', and so on. None of the identifiers in the
LeapYear program is of type char.
The string Data Type
Whereas a value of type char is limited to a single character, a string is a sequence of
characters, such as a word, name, or sentence, enclosed in double quotes. For example, the
following are strings in C++:
Description
A string must be typed entirely on one line. For example, the string
Description
is not valid because it is split across two lines. In this situation, the C++ compiler issues an
error message at the first line. The message may say something like UNTERMINATED STRING,
depending on the particular compiler.
The quotes are not considered to be part of the string but are simply there to distinguish the
string from other parts of a C++ program. For example, "amount" (in double quotes) is the
character string made up of the letters a, m, o, u, n, and t in that order. By contrast, amoun t
(without the quotes) is an identifier, perhaps the name of a memory location. The symbols
"12345" represent a string made up of the characters 1, 2, 3, 4, and 5 in that order. If we write
12345 without the quotes, it is an integer that can be used in calculations.
A string containing no characters is called the null string (or empty string). We write the null
string using two double quotes with nothing (not even spaces) between them:
Description
The null string is not equivalent to a string of spaces; it is a special string that contains no
characters.
To work with string data, we use a data type named string. Type string is not one of the
C++ language’s built-in types; rather, string is a programmer-defined type that is supplied by
the C++ standard library, a large collection of prewritten functions and data types that any
C++ programmer can use. Operations on string data include comparing the values of strings,
searching a string for a particular character, and joining one string to another. We look at
some of these operations in this chapter, and cover more of them in Chapter 3. None of the
identifiers in the LeapYear program is of type string, although string values are used directly in
several places.
Naming Elements: Declarations

Identifiers can be used to name both constants and variables. In other words, an identifier can
be the name of a memory location whose contents are not allowed to change or it can be the
name of a location whose contents can change.
How do we tell the computer what an identifier represents? By using a declaration, a
statement that associates a name (an identifier) with a description of an element in a C++
program (just as a dictionary definition associates a name with a description of the thing being
named). In a declaration, we name an identifier and indicate what it represents. For example,
the LeapYear program uses the declaration
to announce that year is the name of a variable whose contents are of type int. When we
declare a variable, the compiler picks a location in memory to be associated with the identifier.
Declaration A statement that associates an identifier with a data object, a function, or a
data type so that the programmer can refer to that item by name.
Suppose that when we mailed a letter, we only had to put a person’s name on it, and the
post office would look up the address. Of course, everybody in the world would need a
different name; otherwise, the post office wouldn’t be able to figure out the correct address.
The same is true in C++. Each identifier can represent just one thing (except under special
circumstances, which we talk about in Chapters 7 and 8). Every identifier in a program must
be different from all others.
Constants and variables are collectively called data objects. Both data objects and the
actual instructions in a program are stored in various memory locations. You have seen that a
group of instructions—a function—can be given a name. A name also can be associated with
a programmerdefined data type.
In C++, you must declare every identifier before it is used. This practice allows the compiler
to verify that the use of the identifier is consistent with what it was declared to be. If you
declare an identifier to be a constant and later try to change its value, for example, the
compiler detects this inconsistency and issues an error message.
There is a different form of declaration statement for each kind of data object, function, or
data type in C++. The forms of declarations for variables and constants are introduced here,
and additional forms of declaration statements will be a focus of Chapters 8 through 12.
Variables
While a program is executing, different data values may be stored in the same memory
location at different times. This kind of memory location is called a variable, and its content is
the variable value. The symbolic name that we associate with a memory location is the
variable name or variable identifier (see FIGURE 2.1). In practice, we often refer to the
variable name more briefly as the variable.
Variable A location in memory, referenced by an identifier, that contains a data value that
can be changed.

FIGURE 2.1 Variable
Description
Declaring a variable means specifying both the variable’s name and its data type. The
declaration tells the compiler to associate a name with a memory location whose contents are
of a specific type (for example, char or string). The following statement declares that the
identifier myChar will be used to refer to a variable of type char:
In C++, a variable can contain a data value only of the type specified in its declaration.
Because of the preceding declaration, the variable myChar can contain only a char value. If the
C++ compiler comes across an instruction that tries to store a float value into myChar, it
generates extra instructions to convert the float value to the proper type. In Chapter 3, we
examine how such type conversions take place.
Here’s the syntax template for a variable declaration:
Description
where DataType is the name of a data type such as char or string. Notice that a variable
declaration always ends with a semicolon.
From the syntax template, you can see that it is possible to declare several variables in one
statement:
Description
Here, all three variables are declared to be char variables. Our preference, though, is to
declare each variable with a separate statement:

Description
This form makes it easier, when modifying a program, to add new variables to the list or
delete ones you no longer want.
Declaring each variable with a separate statement also allows you to attach comments to
the right of each declaration, as shown here:
Description
These declarations tell the compiler to create three float variables—payRate, hours, and wages
—and one int variable, empNum. The comments tell someone reading the program what each
variable represents.
Now that we’ve seen how to declare variables, let’s look at how to declare constants.
Constants
All single characters (enclosed in single quotes) and strings (enclosed in double quotes) are
constants.
Description
In C++, as in mathematics, a constant is something whose value never changes. When we
use the actual value of a constant in a program, we are using a literal value (or literal).
Literal value Any constant value written in a program.
An alternative to the literal constant is the named constant (or symbolic constant), which
is introduced in a declaration statement. A named constant is just another way of representing
a literal value. Instead of using the literal value in our code, we give it a name in a declaration
statement, then use that name instead. For example, we can write an instruction that outputs
the title of our book using the literal string "Programming and Problem Solving with C++".
Alternatively, w can declare a named constant called BOOK_TITLE that equals the same string
and then use the constant name in the instruction. That is, we can use either

Description
or
Description
in the instruction.
Named constant (symbolic constant) A location in memory, referenced by an identifier,
that contains a data value that cannot be changed.
Using a literal value may seem easier than declaring a named constant and then referring to
it. But, in fact, named constants make a program easier to read because they make the
meaning clearer. Named constants also make it easier to change a program at a later time.
Here is the syntax template for a constant declaration:
Description
Notice that the reserved word const begins the declaration, and an equal sign (=) appears
between the identifier and the literal value.
The following are examples of constant declarations:
Description
As we have done above, many C++ programmers capitalize the entire identifier of a named
constant and separate the English words with an underscore. The idea is to let the reader
quickly distinguish between variable names and constant names when they appear in the
middle of a program.
It’s a good idea to add comments to constant declarations as well as variable declarations.
We describe in comments what each constant represents:

Description
Here is a program that contains just declarations:
Description
MATTERS OF STYLE Capitalization of Identifiers
Programmers often use capitalization as a quick visual clue to what an identifier
represents. Different programmers adopt different conventions for using uppercase and
lowercase letters. Some people use only lowercase, separating the English words in an
identifier with the underscore:
Description
The conventions we use in this text are as follows:
For identifiers representing variables, we begin with a lowercase letter and capitalize
each successive English word.
Description
Names of programmer-written functions and programmer-defined data types
(covered in Chapters 8 through 12) are capitalized in the same manner as variable
names, except that they begin with capital letters.

Description
Capitalizing the first letter allows a person reading the program to tell at a glance that
an identifier represents a function name or data type rather than a variable. However,
we cannot use this capitalization convention everywhere. C++ expects every
program to have a function named main—all in lowercase letters—so we cannot name
it Main. Nor can we use Char for the built-in data type char. C++ reserved words use all
lowercase letters, as do most of the identifiers declared in the standard library (such
as string).
For identifiers representing named constants, we capitalize every letter and use
underscores to separate the English words.
Description
This convention, which is widely used by C++ programmers, is an immediate signal
that BOOK_TITLE is a named constant and not a variable, a function, or a data type.
These conventions are only that—conventions. In other words, C++ does not require this
particular style of capitalizing identifiers. You may wish to capitalize identifiers in a different
fashion. But whatever system you use, it is essential that you use a consistent style
throughout your program. A person reading your program will be confused or misled if you
use a random style of capitalization.
Taking Action: Executable Statements
Up to this point, we’ve looked at ways of declaring data objects in a program. Now we turn our
attention to ways of acting, or performing operations, on data.
Assignment
The value of a variable can be set or changed through an assignment statement. For
example,
Description
assigns the string value "Lincoln" to the variable lastName; that is, it stores the sequence of
characters "Lincoln" into the memory associated with the variable named lastName.
Assignment statement A statement that stores the value of an expression into a variable.

Here’s the syntax template for an assignment statement:
Description
The semantics (meaning) of the assignment operator (=) is “store”; the value of the
expression is stored into the variable. Any previous value in the variable is destroyed and
replaced by the value of the expression.
Expression An arrangement of identifiers, literals, and operators that can be evaluated to
compute a value of a given type.
Only one variable can be on the left-hand side of an assignment statement. An assignment
statement is not like a math equation (x + y = z + 4); the expression (what is on the right-hand
side of the assignment operator) is evaluated, and the resulting value is stored into the single
variable on the left of the assignment operator. A variable keeps its assigned value until
another statement stores a new value into it.
Evaluate To compute a new value by performing a specified set of operations on given
values.
Given the declarations
Description
the following assignment statements are valid:

Description
However, these assignments are not valid:
Invalid Assignment Statement
Reason
middleInitial ="A.";
middleInitial is of type char; "A." is of type string.
letter = firstName;
letter is of type char; firstName is of type string.
firstName = Thomas;
Thomas is an undeclared identifier.
"Edison" = lastName;
Only a variable can appear to the left of =.
lastName = ;
The expression to the right of = is missing.
String Expressions
Although we can’t perform arithmetic on strings, the string data type provides a special string
operation, called concatenation, that uses the + operator. The result of concatenating (joining)
two strings is a new string containing the characters from both strings. For example, given the
statements
Description
we could write
Description
This statement retrieves the value of phrase 1 from memory and concatenates the value of
phrase 2 to form a new, temporary string containing the characters

Description
This temporary string (which is of type string) is then assigned to (stored into) bookTitle.
The order of the strings in the expression determines how they appear in the resulting
string. If we write
Description
then bookTitle contains
Description
Concatenation works with named string constants, literal strings, and char data, as well as
with string variables. The only restriction is that at least one of the operands of the + operator
must be a string variable or named constant (so you cannot use expressions like "Hi"
+"there" or 'A' + 'B'). For example, if we have declared the following constants
Description
then we could write the following assignment statement to store the title of our book into the
variable bookTitle:
Description
As a result, bookTitle contains the string
Description
The preceding example demonstrates how we can combine identifiers, char data, and literal
strings in a concatenation expression. Of course, if we simply want to assign the complete
string to bookTitle, we can do so directly:
Description

Occasionally we may encounter a situation in which we want to add some characters to an
existing string value. Suppose that bookTitle already contains "Programming and Problem
Solving" and now we wish to complete the title. We could use a statement of the form
Description
Such a statement retrieves the value of bookTitle, concatenates the string "with C++" to form
a new string, and then stores the new string back into bookTitle. The new string replaces the
old value of bookTitle (which is destroyed).
Keep in mind that concatenation works only with values of type string. Even though an
arithmetic plus sign is used for the operation, we cannot concatenate values of numeric data
types, such as int and float, with strings.
Here is a program that shows how declarations and assignment statements could be
arranged with respect to one another.
Description
Output
You now know enough C++ syntax to tell the computer to assign values to variables and to
concatenate strings, but the computer won’t give you the results until you tell it to write them
out.
In C++, we can write out information using a special variable named cout (pronounced
“see-out”) along with the insertion operator (<<):
Description

This statement displays the characters Hello on the standard output device , which is usually
a window that appears on your screen, called the system console.
The variable cout is predefined in C++ systems to denote an output stream. You can think
of an output stream variable as a doorway through which we send a sequence of characters
to an output device.
The insertion operator << (often pronounced as “put to”) takes two operands. Its left-hand
operand is a stream expression (in the simplest case, just a stream variable such as cout). Its
right-hand operand is an expression, as in the following two examples:
Description
The insertion operator converts its right-hand operand to a sequence of characters and sends
them to the output device through the stream variable.2 Notice how the << operator points in
the direction the data is going—from the expression written on the right to the output stream
on the left.
You can use the << operator several times in a single output statement. Each occurrence
appends the next data item to the output stream. For example, we can write the preceding two
output statements as
Description
If bookTitle contains "American History", both versions produce the same output:
The output statement has the following form:
Description
The following output statements yield the output shown. These examples assume that the
char variable ch contains the value '2', the string variable firstName contains "Marie", and
the string variable lastName contains "Curie".
Statement
What Is Output (  means blank)
cout << ch;
2
cout <<"ch =" << ch;
ch = 2
cout << firstName +"" + lastName;
Marie Curie
cout << firstName << lastName;
MarieCurie
cout << firstName << ' ' << lastName;
Marie Curie

Statement
What Is Output (  means blank)
cout <<"ERROR MESSAGE";
ERROR MESSAGE
cout <<"Error=" << ch ;
Error=2
An output statement prints literal strings exactly as they appear. Remember to use double
quotes to enclose the string. If you want to output a string that includes a double quote, you
must type a backslash (\) character immediately before the double quote. For example, to
output the characters
Description
the output statement would look like this:
Description
To conclude this introductory look at C++ output, we should mention how to terminate an
output line. Normally, successive output statements cause the output to continue along the
same line of the display screen. For example, the sequence
Description
writes the following to the screen, all on the same line:
To output the two words on separate lines, we can write this:
Description
The output from these statements is
Description
The identifier endl (meaning “end line”) is a special C++ feature called a manipulator . We
discuss manipulators in detail in Chapter 3. For now, the important thing to note is that endl

lets you have output go to the next line.
Here is a program that contains declarations, assignment statements, and output
statements. Note that it takes an overly complicated approach to outputting a simple
message, just so we can illustrate most of the C++ features we’ve seen, all in one place.
We’re not suggesting that you write your own programs this way!
Description
Description
Beyond Minimalism: Adding Comments to a Program
All you need to create a working program is the correct combination of declarations and
executable statements. The compiler ignores comments, but they are of enormous help to
anyone who must read your code. Comments can appear anywhere in a program except in
the middle of an identifier, a reserved word, or a literal constant.
C++ comments come in two forms. The first is any sequence of characters that appears
between / * and * /. The compiler ignores anything between them, even extending over
multiple lines. Here’s an example:

Description
The second, and more common, form begins with two slashes (/ /):
Description
The compiler ignores anything after the two slashes, to the end of that line.
Writing fully commented programs is good programming style. A comment should appear
at the beginning of a program to explain what the program does:
Description
As we’ve seen in several examples, comments often appear beside declarations, to explain
how each identifier is used. In addition, comments should introduce each function, and they
should explain anything that is unusual or difficult to read (for example, a lengthy formula).
It is important to arrange comments so that they are easy to see and it is clear what they
refer to. If comments crowd the code, they make the program more difficult to read—just the
opposite of their purpose! In this text, we use color to distinguish comments, as do many code
editors.
QUICK CHECK
2.1.1. What is the name of the one function that every C++ program must have?
2.1.2. What is the purpose of a metalanguage?
2.1.3. What is a data type?
2.1.4. Use the following syntax template to decide if the string “C++ 7th edition” is a
valid “Sentence.”

Description
2.1.5. Which of the following are valid C++ identifiers?
Description
2.1.6. The only difference between a variable declaration and a constant declaration is
that the reserved word const precedes the declaration. True or false?
2.1.7. Reserved words cannot be used as identifiers. True or false?
2.1.8. Write a statement to assign the letter “A” to the char variable initial.
2.1.9. What value is stored in the string variable name by the following statement?
Description
2.1.10. Write a statement that sends the value in variable name to the stream cout.
2.1.11. What is output by the following statement, given the value assigned to name in
Exercise 2.1.10?
Description
2.1.12. What are the two ways to write comments in C++?
1 As noted in Chapter 1, older programming languages, like C++, use the ASCII character
set. C++ provides the data type wchar_t (for “wide character”) to accommodate larger
character sets such as Unicode. In C++, the notation L'something' denotes a value of type
wchar_t, where the something depends on the particular wide character set being used. We do
not examine wide characters any further in this text.
2 In C++ terminology, it is said that the stream expression is “appended to” the output stream.

2.2 Program Construction
We have looked at basic elements of C++ programs: identifiers, declarations, variables,
constants, expressions, statements, and comments. We also saw an example of a complete
program that obviously had some other elements in it. Now let’s look at how to construct a
program. As you know, C++ programs are made up of functions, one of which must be
named main. A program also can have declarations that lie outside of any function. The syntax
template for a program looks like this:
Description
A function definition consists of a function heading and a body (statements enclosed by left
and right braces):
Description
Here’s an example of a program with just one function, the main function:

Description
The program begins with a comment that explains what the program does. Immediately
after the comment, the following lines appear:
Description
The #include lines instruct the C++ system to insert the contents of files named iostream
and string into our program in those places. The iostream file contains C++ code for functions
and data objects that are necessary for us to output values to a stream such as cout. The
second file contains code needed for working with type string. Insertion happens before the
compiler starts translating, so it translates the inserted code along with ours. We further
discuss these #include lines and the using statement a little later in the chapter.
Next comes a declaration section in which we define the constants FIRST, LAST, andMIDDLE.3
Comments explain how each identifier is used. The rest of the program is the function
definition for our main function. The first line is the function heading: the reserved word int, the
name of the function, and then opening and closing parentheses. (The parentheses indicate

thatmain is the name of a function, and not a variable or constant.) The body of the function
includes the declarations of two variables, firstLast and lastFirst, followed by a list of
executable statements.
Our main function finishes by returning 0 as the function value:
Description
Recall that main returns an integer value to the operating system when it completes execution.
This value is called the exit status. As we’ve seen, 0 is the normal exit status value. Here is
the output from the program.
Description
Notice how we neatly arrange the code in the PrintName program. We use blank lines to
group related statements, and we indent the body of the main function. The compiler doesn’t
require us to format the program this way; it just makes the code more readable.
Blocks (Compound Statements)
The body of a function is an example of a block (or compound statement). This is the syntax
template for a block:
Description
A block is just a sequence of zero or more statements enclosed (delimited) by a { } pair.
Now we can redefine a function definition as a heading followed by a block:

Description
In later chapters, when we learn how to write functions other than main, we will define the
syntax of the heading in detail. In the case of the main function, the heading is simply
Here is the syntax template for a statement, limited to the C++ statements discussed in this
chapter:
Description
A statement can be empty (the null statement). The null statement is just a semicolon and
looks like this:
It does nothing at execution time; execution just proceeds to the next statement. The null
statement is rarely used.
As the syntax template shows, a statement can also be a declaration, an executable
statement, or even a block. The last term means that you can use an entire block wherever a
single statement is allowed. When we introduce the syntax for branching and looping
structures, we’ll see that this is very important.
We use blocks often, especially as parts of other statements. Leaving out a { } pair can
dramatically change the meaning as well as the execution of a program. This is why we
always indent the statements inside a block—the indentation makes blocks easy to spot in a
long stretch of code.
Notice in the syntax templates for the block and the statement that there is no mention of
semicolons—yet the PrintName program contains many semicolons. If you look back at the
templates for constant declaration, variable declaration, assignment statement, and output

statement, you can see that a semicolon is required at the end of each kind of statement.
However, the syntax template for the block shows no semicolon after the right brace. The rule
for using semicolons in C++, then, is quite simple: Terminate each statement except a
compound statement (block) with a semicolon.
One more thing about blocks and statements: According to the syntax template for a
statement, a declaration is officially considered to be a statement. A declaration, therefore,
can appear wherever an executable statement can. In a block, we can mix declarations and
executable statements if we wish:
Description
We prefer, however, to group the declarations together before the start of the executable
statements:
Description
The C++ Preprocessor
Imagine that you are the C++ compiler. You are presented with the following program. You are
to check it for syntax errors and, if there are none, you are to translate it into machine
language code.

Description
You, the compiler, recognize the identifier int as a C++ reserved word and the identifier main
as the name of a required function. But what about the identifiers cout and endl ? The
programmer has not declared them, and they are not reserved words. You have to issue an
error message and give up.
To fix this program, the first thing we must do is insert a line near the top that says
Description
just as we did in the PrintName program (and earlier sample programs). As we’ve seen, this
line says to insert the contents of a file named iostream at that point. This file contains
declarations of cout, endl, and other items related to stream input and output. We also said
that the file is inserted before the C++ compiler runs. The insertion is done by another
program known as the preprocessor.
The preprocessor concept is fundamental to C++. It acts as a filter during the compilation
phase. Your source program passes through the preprocessor on its way to the compiler (see
FIGURE 2.2).
FIGURE 2.2 C++ Preprocessor
Description
A line beginning with a # sign is not actually a C++ language statement (and thus is not
terminated by a semicolon). Instead, it is called a preprocessor directive. The preprocessor
handles an #include directive by inserting the contents of the named file into your source
code. A file whose name appears in an #include directive is called a header file . Header files
contain constant, variable, data type, and function declarations needed by a program.
In the directives

Description
the angle brackets < > are required. They tell the preprocessor to look for the files in the
standard include directory, which contains all the header files that are related to the C++
standard library. The file iostream contains declarations of input/output facilities, and the file
string contains declarations for the string data type. In Chapter 3, we make use of header
files other than iostream and string.4
Using the std Namespace
Header files for different libraries give us a rich collection of code that we can use without
writing any of it ourselves. But recall that C++ requires every identifier to be unique. It would
be impossible for the authors of every header file to check that they are not using names that
duplicate declarations in any other header. For example, the identifier count is the obvious
choice whenever code has to count something.
To solve this problem, C++ has the concept of a namespace. The author of a header file
can declare that its identifiers have a prefix that distinguishes them from others. For example,
the author of header file exWhyZee could specify that it uses namespace xyz while the author of
emEnOh might use a namespace called mno. In a program that imports both header files, their
different count variables can be distinguished as xyz::count and mno::count.
In our HappyBirthday program, even after adding the directive #include <iostream>, the
program will not compile because the header file iostream (and, in fact, every standard header
file) declares all of its identifiers to be in a namespace block called std:
Description
Don’t worry about writing namespace block declarations for now; the important point is that an
identifier declared within a namespace block can be accessed directly only by statements
within that same block. To access an identifier that is “hidden” inside a namespace, we can
insert a statement called a using directive
Description
near the top of the program before the main function. Doing so makes all the identifiers in the
std namespace accessible to our program without using the std:: prefix.

Description
We’ve used this directive in our earlier sample programs and will continue to do so until
Chapter 8, where we discuss why it is not advisable in large programs.
SOFTWARE MAINTENANCE CASE STUDY Adding Titles to
Names
In Chapter 1, we saw the essential steps of any software maintenance process:
1. Check the operation of the existing code.
2. Understand sufficiently how the code works to do the maintenance task.
3. Create a working copy of the code.
4. Make the modifications.
5. Test the new code.
6. Clean up any inconsistencies and update any related documentation.
For the HelloWorld program in Chapter 1, the code was so simple that we could
understand it and make the changes without knowing C++ syntax. In the following
scenario, the code is not so simple. We’ll need to study it to discover how it works and
what needs to be changed.
MAINTENANCE TASK: Add the title “Mr.” to each of the name formats in the PrintName
application.
EXISTING CODE

Description
CODE ANALYSIS: To understand any sizable piece of code, we look for recognizable
chunks into which we can partition it. One of our goals is to set aside portions that are
unlikely to be related to our maintenance task. In this case, we see that there are opening
comments:
Description
The next chunk is made up of the i nc l ude and using statements. These also are
unrelated to the maintenance task.
Description
Next comes the declaration of the three constants:

Description
Because the heading of main simply follows the standard formula, we can also set aside
that line of code and its associated braces. Thus the portion of this application that we
must focus on is the block within main. That block can be further partitioned into a section
of declarations:
Description
And a section that generates and outputs each of the two name formats:
Description
Thus the major steps in the application are declarations and output.
SOLUTION: Our task is to modify the application to incorporate a title in each of the
formats. How are we to do this? We must begin with the problem-solving technique of
asking questions.
How do we get the title? We can declare a string constant TITLE that contains the string
"Mr.".
Description
How is the title to be incorporated into the formats? For the first format, it simply appears
at the beginning of the name. For the second format, it appears after the last name. Now
we must decide how to accomplish this within the application. There are two places where
we could add the title to each format. One place is within the assignment statements that
generate the format. For example:
Description
The other place is within the output statements that print the names:

Description
With the second format, the change is not so simple, because the title must be inserted
between the names. We could still change the output statement, but it would not make use
of the contents of lastFirst, which would be wasteful.
In this short application, it doesn’t really matter which approach we choose. But in a
larger application, we would need to check whether the firstLast and lastFirst variables
are used elsewhere. If they are, then we must understand how they are used. In this case,
however, let’s simply insert the title into the assignment statements.
REVISED CODE: Here is the revised application with the inserted or modified code
highlighted.
Description
As you can see, the actual changes are quite small. By analyzing the original code and
breaking it into meaningful sections, we could isolate the steps that required modification. It
was then obvious how and where to make each of the changes. Here is the output:

Description
Software Maintenance Tips
1. Break a long block of code into smaller chunks according to their distinct purposes.
2. Identify portions of the code that you are sure you can ignore.
3. Focus on those code sections that are clearly related to the maintenance task.
4. Make sure that you understand which changes are required. Ask questions about
anything that is unclear. Formally, this information would be written as a specification
document.
5. Consider the major steps that you’ve identified in the existing code. Then establish
how you would solve the maintenance task within that overall approach. For example,
in a simple application whose steps are input, process, and output, think about how
the task relates to each of these steps. It doesn’t help to develop a solution for a
maintenance task that takes a completely different approach from the existing code.
You must work within the given context.
6. Look for how your changes affect other parts of the application. If you’re changing the
content of an existing variable, check whether it is used elsewhere and how it is used.
7. Document your changes. In our example, we highlighted the updated code. Some
companies have standards for how code changes are recorded. For example, each
line may have a comment that identifies the programmer and the date of the change.
There are also code management tools that automatically record this information.
QUICK CHECK
2.2.1 What is an exit status?
2.2.2 What value is returned as the exit status on most computing systems when a
program completes successfully?
2.2.3 What is a block (compound statement)?
2.2.4 What is an example of a block in this section?
2.2.5 What are the five statements discussed in this section?
2.2.6 What character is used to terminate a statement?
2.2.7 Which statement does not need to be terminated?
2.2.8 What part of the C++ system handles #include <iostream>?
2.2.9 What is the #include called?
2.2.10 Every standard header file declares all of its identifiers to be in a “hidden” place
called std. What is the general term used for std?
2.2.11 Fill in the blanks in the following statements, which appear at the beginning of a
program that uses strings and stream output.

Description
3 As with our earlier demonstration programs, we could have declared these constants within
main. Here we place them before main as an example of what are called global declarations
(which are covered in Chapter 9).
4 In the C language and in prestandard C++, the standard header files end in the suffix .h (for
example, iostream.h), where the h suggests “header file.” In ISO/ANSI C++, the standard
header files no longer use the .h suffix.

2.3 More About Output
We can control both the horizontal and vertical spacing of our output to make it more
appealing (and understandable). Let’s look first at vertical spacing.
Creating Blank Lines
We control vertical spacing by using the endl manipulator in an output statement. You have
seen that a sequence of output statements continues to write characters across the current
line until an endl terminates the line. Here are some examples:
Statements
Output Produced5
cout <<"Hi there,";
cout <<"Lois Lane." << endl;
Hi there, Lois Lane.
cout <<"Have you seen";
cout <<"Clark Kent?" << endl;
Have you seen Clark Kent?
cout <<"Hi there," << endl;
cout <<"Lois Lane." << endl;
Hi there,
Lois Lane.
cout <<"Have you seen" << endl;
cout <<"Clark Kent?" << endl;
Have you seen
Clark Kent?
cout <<"Hi there," << endl;
cout <<"Lois Lane.";
cout <<"Have you seen" << endl;
cout <<"Clark Kent?" << endl;
Hi there,
Lois Lane. Have you seen Clark Kent?
What do you think the following statements output?
Description
The first output statement causes the words Hi there, to be output; the endl causes the
console window cursor to go to the next line. The next statement outputs nothing but goes on
to the next line. The third statement outputs the words Lois Lane. and terminates the line. The
resulting output is the three lines
Description

Whenever you use an endl immediately after another endl, a blank line is produced. As you
might guess, three consecutive uses of endl produce two blank lines, four consecutive uses
produce three blank lines, and so forth.
Note that we have a great deal of flexibility in how we write an output statement in C++. We
could combine the three preceding statements into two:
Description
In fact, we could do it all in one statement. One possibility is this:
Description
Here’s another:
Description
The last example shows that you can spread a single C++ statement onto more than one line
of the program. The compiler treats the semicolon—not the physical end of a line—as the end
of a statement.
Inserting Blanks Within a Line
To control the horizontal spacing of the output, one technique is to send extra spaces to the
output stream. (Remember that the space is actually a character in C++.)
For example, to produce this output:
you would use these statements:
Description

All of the blanks and asterisks are enclosed in double quotes, so they print literally as they are
written in the program. The extra endl manipulators give you the blank lines between the rows
of asterisks.
If you want blanks to be output, you must enclose them in quotes. The statement
Description
produces the following output:
Description
Despite all of the blanks we included in the output statement, the asterisks print side by side
because the blanks are not enclosed by quotes.
Special Characters
We have already mentioned that to include a double-quote mark within a string, it must be
preceded by a backslash ( \"). C++ defines some additional special characters using the
backslash prefix. Here we discuss three that are particularly useful.
We use the endl manipulator in an output stream to go to the next line. You can also use the
newline character \n to place a newline operation directly in a string. The following two
statements both produce the same output:
Description
They each display:
Description
The second statement is clearly more readable, of course. Starting with Chapter 8, we’ll
encounter cases where embedding \n in a string makes sense. For now, we recommend
always using endl.
If you want to include a single quote mark as a char literal within an output stream, then it
must also be preceded by a backslash: '\''. Note that there is no problem including single
quote marks in strings or writing a double quote as a char literal. For example, to output a
double quote followed by a single quote, we can write either:

Description
or
Description
Given that the backslash has these special uses, it is natural to wonder how a backslash
would be output. The answer is that we must write two backslashes in a row:
Description
QUICK CHECK
2.3.1 What is used to control vertical spacing in an output statement?
2.3.2 What is the special character for newline?
5 The output lines are shown next to the output statement that ends each of them. There are
no blank lines in the actual output from these statements.

2.4 Program Entry, Correction, and Execution
In this section, we examine the program entry process in general. You should consult the
manual for your specific computer to learn the details.
Entering a Program
The first step in entering a program is to tell the computer to run a development environment,
which includes a code editor. The code editor allows you to create and modify the code for a
program, which is stored on a file.
File A named area in secondary storage that is used to hold a collection of data; the
collection of data itself.
There are so many different types of editors, each with different features, that we can’t
begin to describe them all here. But we can describe some of their general characteristics.
A code editor is very much like a word processor. It allows you to type in a window and
move around the file to make changes. In most development environments, the code editor
also colorcodes different parts of C++ syntax to make it easier to distinguish keywords,
variables, comments, and so on. It will also automatically indent lines of code. Some code
editors check syntax as you type, flagging parts of your code that may not compile.
In many development environments, the compiler will automatically use the code editor to
display the point where it detects an error in your code. Note, however, that a compiler
sometimes detects an error in a place other than where it actually occurred. For example, the
compiler will point out the first place that an undeclared variable name is used, when the
source of the error may be a missing using statement.
Compiling and Running a Program
Once your program is entered, you compile it by issuing a command to run the C++ compiler.
The compiler translates the program, and if there are no errors, it then stores the machine
language version into a file. The development environment may instead indicate errors in the
code, either in a separate window or in the editor.
If there are errors, you have to determine their cause, fix them in the editor, and then run the
compiler again. Once your program compiles without errors, you can run it.
Some systems automatically run a program when it compiles successfully. On other
systems, you have to issue a separate command to run it. Still other systems require that you
specify an extra step called linking between compiling and running a program. Whatever
series of commands your system uses, the result is the same: Your program is loaded into
memory and executed by the computer.
Even though a program runs, it may still have errors in its design. The computer does
exactly what you tell it to do, even if that’s not what you wanted it to do. If your program
doesn’t do what it should (a logic error), you have to return to the algorithm and fix it, and then

go back to the editor and fix the program. Finally, you compile and run the program again. This
debugging process is repeated until the program does what it is supposed to do (see FIGURE
2.3).
Description
FIGURE 2.3 Debugging Process
QUICK CHECK
2.4.1 What does a compiler translate a program into?
2.4.2 What do we call an error that occurs when the program is executing?

PROBLEM-SOLVING CASE STUDY Printing a Chessboard
PROBLEM: Your college is hosting a chess tournament, and the people running it want to
record the final positions of the pieces in each game on a sheet of paper with a
chessboard preprinted on it. Your job is to write a program to preprint these pieces of
paper. The chessboard is an eight-by-eight pattern of squares that alternate between black
and white, with the upper-left square being white. You need to print out squares of light
characters (spaces) and dark characters (such as *) in this pattern to form the
chessboard.
DISCUSSION: You could simply type up a program consisting of a series of output
statements with alternating patterns of blanks and asterisks. But the organizers of the
tournament aren’t sure exactly what they want the chessboard to look like, and you decide
it would be safer to write the program in a manner that allows the design of the chessboard
to be modified easily.
It is easy to make a changeable chessboard if the design is built up using string
variables. You can begin by defining string constants for rows of characters that make up
the black and white areas. Then you can concatenate these constants to form variables
containing the alternating patterns of black and white that are repeated to output a row of
chessboard squares. For example, suppose your initial design for the chessboard looks
like this:

Description
You can begin by defining constants forWHITE and BLACK that contain eight blanks and
eight asterisks, respectively, and then concatenate these together into variables that follow
the patterns

Description
and
Description
These variables can then be output with cout statements the appropriate number of times
to create the chessboard. (In reality, we would need to use a different stream to send the
output to a printer, but we’ll let the console window stand in for that instead.)
From this discussion we know that there are two constants and two variables, as
summarized in the following tables:
CONSTANTS
Name
Value
Function
BLACK
"********"
Characters forming one line of a black square
WHITE
""
Characters forming one line of a white square
VARIABLES
Name
Data Type
Description
whiteRow
string
A row beginning with a white square
blackRow
string
A row beginning with a black square
If we look carefully at the chessboard, the algorithm jumps out at us. We need to output
five whiteRows, five blackRows, five whiteRows, five blackRows, five whiteRows, five
blackRows, five whiteRows, and five blackRows. We can summarize this in our algorithm to
output the five whiteRows and five blackRows four times.
Repeat four times
Output five whiteRows
Output five blackRows


Description
There are eight blocks of five lines that look alike. In Chapter 6, we introduce a looping
statement that allows us to shorten this program considerably.
After you show the printout from this program to the organizers of the tournament, they
suggest that the board would look better with the "#" character instead of "*" filling the
black squares. You cheerfully agree to make this change because you know that the only
difference in the program is that the value of the constant BLACK becomes "########".

Testing and Debugging
2.1 Every identifier that isn’t a C++ reserved word must be declared. If you use a name
that hasn’t been declared—either with your own declaration statements or by including a
header file—you get an error message.
2.2 If you try to declare an identifier that is the same as a reserved word in C++, you get
an error message. See Appendix A for a list of reserved words.
2.3 C++ is a case-sensitive language. Two identifiers that are capitalized differently are
treated as two different identifiers. The word main and all C++ reserved words use only
lowercase letters.
2.4 To use identifiers from the standard library, such as cout and string, you must put a
using directive near the top of your program:
Description
2.5 Check for mismatched quotes in char and string literals. Each char literal begins and
ends with an apostrophe (a single quote). Each string literal begins and ends with a
double quote.
2.6 Be sure to use only the apostrophe ( ') to enclose char literals. Most keyboards also
have a reverse apostrophe ('), which is easily confused with the apostrophe. If you use
the reverse apostrophe, you will get an error message.
2.7 To use a double quote within a literal string, use the two symbols \" in a row. If you
use just a double quote, it ends the string, and the compiler then sees the remainder of
the string as an error.
2.8 In an assignment statement, be sure that the identifier to the left of = is a variable and
not a named constant.
2.9 In assigning a value to a string variable, the expression to the right of = must be a
string expression, a string literal, or a char.
2.10 In a concatenation expression, at least one of the two operands of + must be of type
string. For example, the operands cannot both be literal strings or char values.6
2.11 Make sure your statements end in semicolons (except blocks, which do not have a
semicolon after the right brace).
6 The invalid concatenation expression "Hi" +"t here" results in a confusing syntax error
message such as INVALID POINTER ADDITION. For now, just keep in mind that such a message

may indicate a concatenation expression that doesn’t include a variable.

Summary
The syntax (grammar) of the C++ language is defined by a metalanguage. In this text, we
use a form of metalanguage called syntax templates. We describe the semantics
(meaning) of C++ statements in English.
Identifiers are used in C++ to name things. Some identifiers, called reserved words,
have predefined meanings in the language; others are created by the programmer. The
identifiers you invent are restricted to those not reserved by the C++ language. Reserved
words are listed in Appendix A.
Identifiers are associated with memory locations by declarations. A declaration may
give a name to a location whose value does not change (a constant) or to one whose
value can change (a variable). Every constant and variable has an associated data type.
C++ provides many built-in data types; the most commonly used are int, float, and char.
Additionally, C++ permits programmer-defined types, such as the string type from the
standard library.
The assignment operator is used to change the value of a variable by assigning it the
value of an expression. At execution time, the expression is evaluated and the result is
stored into the variable. With the string type, the plus sign (+) is an operator that
concatenates two strings. A string expression can concatenate any number of strings to
form a new string value.
Program output is accomplished by means of the output stream variable cout, along
with the insertion operator (<<). Each insertion operation sends output data to the standard
output device. When an endl manipulator appears instead of a data item, the computer
terminates the current output line and goes on to the next line.
Output should be clear, understandable, and neatly arranged. Messages in the output
should describe the significance of values. Blank lines (produced by successive uses of
the endl manipulator) and blank spaces within lines help to organize the output and
improve its appearance.
A C++ program is a collection of one or more function definitions (and optionally some
declarations outside of any function). One of the functions must be named main. Execution
of a program always begins with the main function. Collectively, the functions all cooperate
to produce the desired results.

Quick Check Answers
2.1.1 main 2.1.2 To provide a language for expressing the syntax rules of a programming
language. 2.1.3 A specific set of values, together with a set of operations that can be
applied to those values. 2.1.4 No. According to the template, a Sentence must end in a
period, exclamation point, or question mark. 2.1.5 Hello, Bob, maximum, and all_4_one are
the valid C++ identifiers. 2.1.6 False. The constant declaration also assigns a literal value
to the identifier. 2.1.7 True. Identifiers must differ from reserved words. 2.1.8 initial = '
A'; 2.1.9 Alexander Q. Smith 2.1.10 cout << name;2.1.11 The string Alexander Q. Smith Jr.
is output and then successive output will appear on the next line. 2.1.12 Between the
delimiters / * and * /, or following // to the end of the line. 2.2.1 The exit status is an
integer value that is returned from the main function to the operating system when it
completes execution. 2.2.2 A 0 value indicates success. 2.2.3 A block is a sequence of
zero or more statements enclosed by a { } pair. 2.2.4 The body of a function. 2.2.5 Null,
Declaration, Assignment, Output, and Block. 2.2.6 A semicolon (;). 2.2.7 Block. 2.2.8 The
preprocessor. 2.2.9 A preprocessor directive. 2.2.10 A namespace.
Description
2.3.1 end l 2.3.2 '\n' 2.4.1 Machine language. 2.4.2 A logic error or runtime error.

Exam Preparation Exercises
2.1 Mark the following identifiers as either valid or invalid.
Valid
Invalid
a. theDog
_____
_____
b. all-In-One
_____
_____
c. const
_____
_____
d. recycling
_____
_____
e. DVD_ROM
_____
_____
f. elizabeth_the_2nd
_____
_____
g. 2morrow
_____
_____
h. page#
_____
_____
2.2 Match the following terms with the definitions given below.
a. Function
b. Syntax
c. Semantics
d. Metalanguage
e. Identifier
f. Data type
g. Variable
h. Named constant
i. Literal
j. Expression
i. An identifier referring to a value that can be changed.
ii. A specific set of values, along with operations that can be applied to those
values.
iii. A value that appears in a program.
iv. The set of rules that determines the meaning of instructions written in a
programming language.
v. A language that is used to write the rules for another language.
vi. A subprogram in C++.
vii. A name that is used to refer to a function or data object.

viii. An arrangement of identifiers, literals, and operators that can be
evaluated.
ix. The formal rules governing how valid instructions are written in a
programming language.
x. An identifier referring to a value that cannot be changed.
2.3 A reserved word is a named constant that is predefined in C++. True or false?
2.4 What is wrong with the following syntax template for a C++ identifier?
Description
2.5 A char literal can be enclosed in either single or double quotes. True or false?
2.6 The null string represents a string containing no characters. True or false?
2.7 Concatenation works with a char value only when its other operand is a string
value. True or false?
2.8 What is output by the following statement?
Description
2.9 Given these assignments to string variables:
Description
What is the value of the following expression?

Description
2.10 How do we insert a double quote into a string?
2.11 What danger is associated with the use of the /* and */ form of comment, and is
avoided by use of the // comment form?
2.12 What are the limitations associated with the // form of comment?
2.13 What is the name of the << operator, and how might we pronounce it in reading a
line of code that contains it?
2.14 Can we concatenate endl with a string in an expression? Explain.
2.15 What does the #include preprocessor directive do?
2.16 For the following output statement, the compiler reports this error message:
UNDECLARED IDENTIFIER: cout.
Description
The program includes the statement
Description
What is the most likely source of this error?
2.17 What is the name of the C++ construct that begins with { and ends with }?
2.18 How can you create a string when it is too long to fit on a single line in your editor
window?
2.19 Reorder the following lines to make a working program.

Description

Programming Warm-Up Exercises
2.1 Write an output statement that prints today’s date and then goes to the next line.
2.2 Write a single output statement that outputs the following three lines:
Description
2.3 Write declarations for the following:
a. A named constant, called ANSWER, of type string, with the value "True"
b. A char variable with the name middleInitial
c. A string variable with the name courseTitle
d. A named char constant, called PERCENT, with the value '%'
2.4 Change the three declarations in the PrintName program in the Program
Construction section so that it outputs your name.
2.5 Given the following declarations:
Description
Write an output statement that prints the title of this text, using only the cout stream,
the stream insertion operator, and the above-named constants.
2.6 Write an expression that results in a string containing the title of this text, using
only the concatenation operator and the declarations of Exercise 2.5.
2.7 Write C++ output statements to print the following exactly as shown (a portion of
the material found in the preface of this text, relating the action of a weaver’s loom to
the complexity of human thought). You should write one output statement for each line
of text.

Description
2.8 Fill in the missing lines in the following program, which outputs:
Description
2.9 Enter and run the following program. Be sure to type it exactly as it appears here,
but substitute your name and the date as indicated.

Description
2.10 Find the 10 missing items in the following program.
Description

Programming Problems
2.1 Write a program that outputs your course schedule for a single week. Here’s an
example of the output for one day:
Description
Use named string constants wherever possible to avoid retyping any words or
numbers. Be sure to include appropriate comments in your code, choose meaningful
identifiers, and use indentation as we do with the programs in this chapter.
2.2 Write a program that outputs all six permutations of the ordering of the following
three lines. Declare a named constant for each line and write an output statement for
each permutation. Be sure to include appropriate comments in your code, choose
meaningful identifiers, and use indentation as we do with the programs in this chapter.
Description
2.3 Write a program that displays a checkerboard pattern made of stars and blanks,
as shown below. A checkerboard is eight squares by eight squares. This will be
easier if you first declare two named string constants representing the two different
row patterns. Be sure to include appropriate comments in your code, choose
meaningful identifiers, and use indentation as we do with the programs in this chapter.

Description
2.4 Write a program that outputs business cards for yourself (using console output to
simulate printing). A card should include your name, street address, phone
number(s), and email address. You also can make up a company name and put that
on the card if you wish. To save paper, the program should output eight cards per
page, arranged in two columns of four cards. To reduce typing, you should declare a
named string constant for each line of the card, and then write output statements to
print the eight cards using those constants. Be sure to include appropriate comments
in your code, choose meaningful identifiers, and use indentation as we do with the
programs in this chapter.

Case Study Follow-Up
1. What change would you have to make to the Chessboard program to cause the
black squares to be output with the "%" character instead of "*"?
2. How would you change the Chessboard program to print periods in the white
squares instead of blanks?
3. How would you change the Chessboard program if you wanted to reverse the colors
(that is, make black squares white, and vice versa) without changing the constant
declarations or the values of whiteRow and blackRow?
4. Change the Chessboard program so that the squares are 10 characters wide by 8
rows high.
5. The organizers of the chess tournament find it difficult to write in the black squares
of the printed chessboard. They want you to change the program so that the black
squares have a blank space in their center that is four characters wide and two lines
high. (Hint: You may have to define another string constant.)
6. How many characters are stored in each of the string variables in the Chessboard
program?

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  3
Numeric Types,
Expressions, and Output
KNOWLEDGE GOALS
To understand implicit type coercion and explicit type conversion.
To recognize and understand the purpose of function arguments.
To learn and use additional operations associated with the string type.
To learn how to format program statements in a clear and readable fashion.
SKILL GOALS
To be able to:
Declare named constants and variables of type int and float.
Construct simple arithmetic expressions.
Evaluate simple arithmetic expressions.
Construct and evaluate expressions that contain multiple arithmetic operations.
Call (invoke) a value-returning function.
Use C++ library functions in expressions.
Call (invoke) a void function (one that does not return a function value).
Use C++ manipulators to format output.
In Chapter 2, we examined enough C++ syntax to be able to construct simple programs. We
focused on the char and string types and expressions using the concatenation operator. In
this chapter, we expand our ability to write programs by introducing additional built-in data
types: int and float. These types are supported by numerous operators that allow us to
construct any arithmetic expressions we need. We then see how to make expressions even

more powerful by using library functions—prewritten functions that are available for use by
any program.
We also return to the subject of formatting output. In particular, we will discuss formatting
numbers as they are output. We finish by looking at some additional operations on string
data.

3.1 Overview of C++ Data Types
The C++ built-in data types are organized into simple types, structured types, and address
types (see FIGURE 3.1). Do not feel overwhelmed by the quantity of data types shown in
Figure 3.1. Our purpose is simply to give you an overall picture of what is available in C++.
This chapter concentrates on the integral and floating types. Details of the other types come
later in the text. First we look at the integral types (those used primarily to represent integers),
and then we consider the floating types (used to represent real numbers containing decimal
points).
FIGURE 3.1 C++ Data Types
Description

3.2 Numeric Data Types
You already are familiar with the concepts of integer and real numbers in math, which are
infinite sets of numbers. However, in a computer, because memory is divided into cells that
are fixed in size, the corresponding data types must be finite in the ranges of values they can
have.
Integral Types
The data types char, short, int, and long are known as integral (or integer) types because
they refer to integer values—whole numbers with no fractional part. (We consider the
remaining integral type, bool, in Chapter 5.)
In C++, the simplest form of integer value is a sequence of one or more digits:
Description
Commas are not allowed.
A minus sign preceding an integer value makes the integer negative:
Description
In C++, there is an exception, however, because the language also has versions of its integer
types that do not allow negative values. For example, there is a type called unsigned int. An
unsigned integer value can be only positive or zero. The unsigned types are used primarily in
specialized situations. We rarely use unsigned in this text.
The data types char, short, int, and long are intended to represent different sizes of
integers, from smaller (fewer bits) to larger (more bits). The sizes are machine dependent;
that is, they may vary from machine to machine. The following table shows sample ranges:

Description
On another machine, the size of an int might be the same as the size of a long. In general,
the more bytes in the memory cell, the larger the integer value that can be stored there. On an
embedded computer, such as the controller for a microwave oven, the range of int values
might be from −32,768 through +32,767.
Although we used the char type in Chapter 2 to store character data such as 'A', C++
classifies char as an integral type because it also allows char to be used for storing integer
values with a very limited range.
In the LeapYear program in Chapter 1, the identifier, year, is of type int. You nearly always
use int for manipulating integer values, but sometimes you have to use long if your program
requires values larger than the maximum int value. If your program tries to compute a value
larger than your machine’s maximum value, the result is integer overflow. Some machines
display an error message when overflow occurs, but others don’t. We talk more about
overflow in later chapters.
One caution about integer values in C++: A literal constant beginning with a zero is taken to
be an octal (base-8) number instead of a decimal (base-10) number. Thus, if you write
Description
the C++ compiler takes this to mean the decimal number 25. If you aren’t familiar with the
octal number system, don’t worry about why octal 31 is the same as decimal 25.1 The
important thing to remember is that you should not start a decimal integer constant with a zero

(unless you simply want the number 0, which is the same in both octal and decimal). In
Chapter 10, we discuss the various integral types in more detail.
Floating-Point Types
Floating-point types (or floating types) are used to represent real numbers. Floating-point
numbers have an integer part and a fractional part, with a decimal point in between. Either the
integer part or the fractional part, but not both, may be missing. Here are some examples:
Description
Starting 0.57 with a zero does not make it an octal number. That rule is only for integer
literals. Just as the integral types in C++ come in different sizes (char, short, int, and long),
so do the floating-point types. In increasing order of size, the floating-point types are float,
double (meaning double precision), and long double. Again, the exact sizes are machine
dependent. Each larger size potentially gives us a wider range of values and more precision
(the number of significant digits in the number), but at the expense of more memory space to
hold the number.
Floating-point values also can have an exponent, as in scientific notation (where a number
is written as a value multiplied by 10 to some power). Instead of writing 3.504 × 1012, in C++
we write 3.504E12. The E means exponent of base-10. The number preceding the letter E
doesn’t need to include a decimal point. Here are some examples of floating-point numbers in
scientific notation:
Description
Most programs don’t need the double and long double types. The float type usually
provides a sufficient precision and range of values. Typically, float values have a precision of
six or seven significant digits and a maximum value of about 3.4E38. We use float to
represent money and interest rate values in the case study at the end of this chapter. The
following table shows sample ranges for floating-point data types:
Description

QUICK CHECK
3.2.1 What are the four integral types discussed in this section?
3.2.2 What does an integral type refer to?
3.2.3 What reserved word must be used for values that are only positive?
3.2.4 What are the smallest and largest integral types, in terms of bytes, studied in
this section?
3.2.5 What are the smallest and largest integral types in terms of values?
3.2.6 What is the result if your program tries to compute a value larger than your
machine’s maximum value?
3.2.7 What type is typically used to represent real numbers?
3.2.8 What are the floating-point types?
3.2.9 How do we write the real number 3.504 × 1012 as a C++ literal value?
There is one more thing you should know about floating-point numbers: Computers cannot
always represent real numbers exactly. Because of limited precision, a number like one third
will be approximated by something like 0.3333333. If you add one third to itself three times, in
math, it equals 1.0. But in the computer you will get 0.9999999. In most cases, slight
inaccuracies are to be expected and are not the result of programmer error.
1 There is an old joke that a computer scientist can’t tell the difference between Halloween
and Christmas because Oct 31 = Dec 25.

3.3 Declarations for Numeric Types
Just as with the types char and string, we can declare named constants and variables of
type int and float. Such declarations use the same syntax as before, except that the literals
and the names of the data types are different.
Named Constant Declarations
In the case of named constant declarations, the literal values in the declarations are numeric
instead of being characters in quotes. Here are some example constant declarations for
values of type int and float. For comparison, declarations of char and string values are
included.
Description
Although character and string literals are put in quotes, literal integers and floating-point
numbers are not, because there is no chance of confusing them with identifiers. Why?
Because identifiers must start with a letter or underscore, and numbers must start with a digit
or sign.
Variable Declarations
We declare numeric variables the same way in which we declare char and string variables,
except that we use the names of numeric types. The following are valid variable declarations:
Description
Given the declarations

Description
SOFTWARE ENGINEERING TIP Using Named Constants
Instead of Literals
It’s a good idea to use named constants instead of literals. In addition to making your
program more readable, named constants can make your program easier to modify.
Suppose you wrote a program last year to compute taxes. In several places you used the
literal 0.05, which was the sales tax rate at the time. Now the rate has gone up to 0.06. To
change your program, you must locate every literal 0.05 and change it to 0.06. If 0.05 is
used for some other reason—to compute deductions, for example—you also need to look
at each place where it is used, figure out what it is used for, and then decide whether to
change it.
The process is much simpler if you use a named constant. Suppose you had declared a
named constant, TAX_RATE, with a value of 0.05. To change your program, you would
simply change the declaration, setting TAX_RATE equal to 0.06. This one modification
automatically changes all of the tax rate computations without affecting the other places
where 0.05 is used.
C++ allows us to declare constants with different names but the same value. If a value
has different meanings in different parts of a program, it makes sense to declare and use a
constant with an appropriate name for each meaning.
Named constants are also reliable—they protect us from mistakes. If you mistype the
name PI as PO, for example, the C++ compiler tells you that PO has not been declared. In
contrast, even though we recognize that the 3.14149 is a mistyped version of pi (3.14159),
it is perfectly acceptable to the compiler. As a consequence, it won’t warn us that anything
is wrong.
the following are appropriate assignment statements:
Description
In each of these assignment statements, the data type of the expression matches the data
type of the variable to which it is assigned. Later in the chapter we see what happens if the

data types do not match.
QUICK CHECK
3.3.1 Write a named constant declaration for the mathematical value of ? = 3.14159.
3.3.2 Given the variable declarations:
What is the type of the expression:
3.3.3 How does the declaration of named constants and variables of type int and
float differ from declarations of named constants and variables of type string?

3.4 Simple Arithmetic Expressions
Now that we have looked at declaration and assignment, let’s consider how to calculate with
numeric types. Calculations are performed with expressions. Here, we look at simple
expressions with at most one operator so we may examine each operator in detail. Later, we
move on to expressions that combine multiple operations.
Arithmetic Operators
Expressions can contain constants, variables, and operators. Here are five examples of valid
expressions:
Description
The operators allowed in an expression depend on the data types of the constants and
variables in the expression. The arithmetic operators are:
OperatorMeaning
Valid Types
+
Unary plus
Integral,
Floating
–
Unary minus
Integral,
Floating
+
Addition
Integral,
Floating
–
Subtraction
Integral,
Floating
*
Multiplication
Integral,
Floating
/
Floating-point division (floating-point result), or Integer division (no
fractional part)
Floating
Integral
%
Modulus (remainder from integer division)
Integral
The first two operators are unary operators—they take just one operand. The remaining
five are binary operators, taking two operands. Unary plus and minus are used as follows:
Description
Programmers rarely use the unary plus. Without any sign, a numeric constant is assumed to
be positive anyway.

Unary operator An operator that has just one operand.
Binary operator An operator that has two operands.
You may not be familiar with integer division and modulus (%). Let’s look at them more
closely. Note that % is used only with integers. When you divide one integer by another, you
get an integer quotient and a remainder. Integer division gives only the integer quotient, and %
gives only the remainder. (If either operand is negative, the sign of the remainder may vary
from one C++ compiler to another.2)
Description
In contrast, floating-point division yields a floating-point result. For example, the expression
Description
yields the value 3.5.
Here are some expressions using arithmetic operators and their values:
Expression
Value
3 + 6
9
3 . 4 - 6 . 1
–2 . 7
2 * 3
6
8 / 2
4
8 . 0 / 2 . 0
4 . 0
8 / 8
1
8 / 9
0
8 / 7
1
8 % 8
0
8 % 9
8
8 % 7
1
0 % 7
0
5 % 2.3
error (Both operands must be integers.)
Be careful with division and modulus. The computer cannot divide by zero. The expressions 7
/ 0 and 7 % 0 both produce errors. With floating-point, 7.0 / 0.0, produces a special infinity
value, displayed as “inf” when output.

Because variables are allowed in expressions, the following are valid assignments:
Description
As we saw with assignment statements involving s t r i ng expressions, the same
variable can appear on both sides of the assignment operator. In the case of
Description
the value in num and the value in alpha are added together, and then the sum of the two values
is stored back into num, replacing the previous value stored there. This example shows the
difference between mathematical equality and assignment. The mathematical equality
Description

Description
is true only when alpha equals 0. The assignment statement
Description
is valid for any value of alpha.
Here’s a simple program that uses arithmetic expressions.
The program begins with a comment that explains what it does. Next comes a section
where we define the constants FREEZE_PT and BOIL_PT. The body of the main function includes
a declaration of the variable avgTemp and then a sequence of executable statements. These
statements output a message, add FREEZE_PT and BOIL_PT, divide the sum by 2, and finally
print the result. Here is the output:
Description
Increment and Decrement Operators

In addition to the arithmetic operators, C++ provides increment and decrement operators:
++ Increment (add 1 to)
-- Decrement (subtract 1 from)
These unary operators take a single variable name as an operand. For integer and floating-
point operands, the effect is to add 1 to (or subtract 1 from) the operand. If num currently
contains the value 8, the statement
Description
causes num to contain 9. You can achieve the same effect with this assignment statement:
Description
Recall from Chapter 1 how the C++ language got its name: C++ is an “incremented” version
of the C language.
The ++ and -- operators can be either prefix operators:
Description
or postfix operators:
Description
When used as standalone statements, both forms behave the same way. Normally, C++
programmers use the postfix version.
C++ allows the use of ++ and -- in the middle of a larger expression:
Description
In this case, the postfix form does not give the same result as the prefix form. We will explain
the difference in Chapter 7. For now, you should use the ++ and -- operators only to increment
or decrement a variable as a separate, standalone statement:

Description
QUICK CHECK
3.4.1 If integer1 contains 37 and integer2 contains 7, what is the result of the
expression 37 % 7?
3.4.2 What does the expression 7 / 0 produce?
3.4.3 What value does the expression 7.0 / 0.0 produce?
3.4.4 What effect does the expression num++ produce?
2 This inconsistency between compilers can result in subtle bugs when a program is moved
to a different computer system. We recommend avoiding the use of the remainder with
negative integers. The abs function (described in the section Function Calls and Library
Functions) can be used to take the absolute value of an int before applying %. In Chapter 5,
we see how to check for negative values and skip a computation that would otherwise use
them.

3.5 Compound Arithmetic Expressions
The expressions we have used so far have contained at most a single arithmetic operator.
We have also been careful not to mix integer and floating-point values in the same expression.
Now we look at more complicated expressions—ones that are composed of several
operators and ones that contain mixed data types.
Precedence Rules
Arithmetic expressions can be made up of many constants, variables, operators, and
parentheses. In what order are the operations performed? For example, in the assignment
statement
Description
is FREEZE_PT + BOIL_PT calculated first or is BOIL_PT / 2.0 calculated first?
The basic arithmetic operators (unary +, unary –, + for addition, – for subtraction, * for
multiplication, / for division, and % for modulus) are ordered the same way mathematical
operators are, according to precedence rules:
Precedence Level
Operators
Highest precedence level:
Unary + Unary -
Middle level:
* / %
Lowest level:
+ -
Because division has higher precedence than addition, the expression in the example given
earlier is implicitly parenthesized as
Description
That is, we first divide BOIL_PT by 2.0 and then add FREEZE_PT to the result.
You can change the order of evaluation by using parentheses. In the statement
Description
FREEZE_PT and BOIL_PT are added first, and then their sum is divided by 2.0. We evaluate
subexpressions in parentheses first and then follow the precedence of the operators.
When an arithmetic expression has several binary operators with the same precedence,
their grouping order (or associativity) is from left to right. The expression

Description
means (int1 – int2) + int3, not int1 – (int2 + int3). As another example, we would use
the expression
to evaluate the expression in parentheses first, then divide the sum by float1, and finally
multiply the result by 3.0. Following are some more examples.
Expression
Value
10 / 2 * 3
15
10 % 3 – 4 / 2
–1
5.0 * 2.0 / 4.0 * 2.0
5.0
5.0 * 2.0 / ( 4.0 * 2.0 )
1.25
5.0 + 2.0 / ( 4.0 * 2.0 )
5.25
In C++, all unary operators (such as unary + and unary -) have right-to-left associativity.
Although this fact may seem strange at first, it turns out to be the natural grouping order. For
example, – + x means – (+ x) rather than the meaningless (- +) x.
Type Coercion and Type Casting
Integer values and floating-point values are stored differently inside a computer’s memory.
The pattern of bits that represents the constant 2 does not look at all like the pattern of bits that
represents the constant 2.0. What happens if we mix integer and floating-point values together
in an assignment statement or an arithmetic expression? Let’s look first at assignment
statements.
Assignment Statements
If you make the declarations
Description
then someInt can hold only integer values, and someFloat can hold only floating-point values.
The assignment statement
Description

may seem to store the integer value 12 into someFloat, but the computer refuses to store
anything other than a float value into someFloat. The compiler inserts extra instructions to
convert 12 into 12.0 before storing it into someFloat. This implicit (automatic) conversion of a
value from one type to another is known as type coercion.
Type coercion The implicit (automatic) conversion of a value from one data type to
another.
The statement
Description
also causes type coercion. When a floating-point value is assigned to an int variable, the
fractional part is truncated (cut off). As a result, someInt is assigned the value 4.
In both cases, the program would be less confusing to read if we avoided mixing data
types:
Description
Entire expressions may be involved in type coercion. Both of the assignments
lead to type coercion. Storing the result of an int expression into a float variable generally
doesn’t cause loss of information; the integer 24 can be represented in floating-point form as
24.0. However, storing the result of a floating-point expression into an int variable can lose
information when the fractional part is truncated. It is easy to overlook coercion of a floating-
point value to an integral value when we try to discover why a program is producing wrong
answers.
To make our programs as clear (and error free) as possible, we can use explicit type
casting (or type conversion). A C++ cast operation consists of a data type name and then,
within parentheses, the expression to be converted:3
Description

Type casting The explicit conversion of a value from one data type to another; also called
type conversion.
Both of the statements
Description
produce identical results, but with the cast operation, it is perfectly clear that the mixing of
types is intentional, not an oversight. Countless errors have resulted from unintentional mixing
of types.
Here is how to round off rather than truncate a floating-point value before storing it into an
int variable:
Description
With pencil and paper, see for yourself what gets stored into someInt when someFloat
contains 4.7. Now try it again, assuming someFloat contains 4.2. (This technique assumes
that someFloat is a positive number.)
Arithmetic Expressions
So far we have been talking about mixing data types across the assignment operator (=). It’s
also possible to mix data types within an expression:
Description
Such expressions are called mixed type (or mixed mode) expressions.
Mixed type expression An expression that contains operands of different data types; also
called mixed mode expression.
Whenever an integer value and a floating-point value are joined by an operator, implicit type
coercion occurs:
1. The integer value is coerced to create a temporary floating-point value.
2. The operation is performed with the temporary value.
3. The result is a floating-point value.

Let’s examine how the machine evaluates the expression 4.8 + someInt – 3, where
someInt contains the value 2. First, the operands of the + operator have mixed types, so the
value of someInt is coerced to 2.0. (This conversion creates a separate temporary value; it
does not affect the value stored in someInt.) The addition takes place, yielding a value of 6.8.
Next, the subtraction (-) operator joins a floating-point value (6.8) and an integer value (3). The
value 3 is coerced to 3.0, the subtraction takes place, and the result is the floating-point value
3.8.
Just as with assignment statements, you can use explicit type casts within expressions to
lessen the risk of errors. Writing expressions such as
Description
makes it clear what your intentions are.
Explicit type casts are not only valuable for program clarity, but also necessary in some
cases for correct calculation. Given the declarations
Description
suppose that sum and count currently contain 60 and 80, respectively. If sum represents the
sum of a group of integer values and count represents the number of values, let’s find the
average value:
Description
Unfortunately, this statement stores the value 0.0 into average. Here’s why: The expression is
not mixing types. Both operands of the / operator are of type int, so integer division is
performed. When 60 is divided by 80, it yields the integer value 0. Next, the value 0 is coerced
to 0.0 before being stored into average.
Here is the way to find the average correctly, as well as clearly:
This statement does floating-point division instead of integer division. As a result, the value
0.75 is stored into average.
As a final remark about type coercion and type conversion, you may have noticed that we
have concentrated on the int and float types. It is also possible to stir char, short, and double
values into the pot. The results can be confusing and unexpected. In Chapter 10, we return to
this topic with a more detailed discussion. Until then, you should avoid mixing values of these
types within an expression.

SOFTWARE MAINTENANCE CASE STUDY Precedence Error
PROBLEM: Numerous programming errors result from writing expressions that fail to
take the precedence rules into account. For example, take a look at the following program,
which is supposed to compute the radius of a circle from its circumference.
Description
The problem is that, given a circumference of 10, for which the radius is approximately
1.59, the program outputs 15.707963265. What’s wrong? Because the circumference is
stored as a constant, the only remaining potential source of error must be the expression
that computes the radius.
We know that to get the radius from the circumference, we divide the circumference by
2 times pi, which is what the statement does. Or does it? Division and multiplication have
the same precedence, so they are evaluated from left to right. The expression is really
computing
Description
In our test case, the application divides 10.0 by 2.0, giving 5.0, which is multiplied by pi
to get 15.707963265. What we really want is this:
Description
Whenever you face a debugging task, take the time first to narrow down your search for
the bug by a process of elimination. Once you isolate the section of code that is the most
likely source of the error, consider the common mistakes associated with those kinds of

statements. Efficient debugging is not a hit-or-miss process. It takes careful thought and
organization to zero in on a bug.
MAY WE INTRODUCE Blaise Pascal
© GeorgiosArt/iStock/Getty Images Plus/Getty Images.
One of the great historical figures in the world of computing was the French mathematician
and religious philosopher Blaise Pascal (1623–1662), the inventor of one of the earliest
known mechanical calculators.
Pascal’s father, Etienne, was a noble in the French court, a tax collector, and a
mathematician. Pascal’s mother died when Pascal was 3 years old. Five years later, the
family moved to Paris and Etienne took over the education of the children. Pascal quickly
showed a talent for mathematics. When he was only 17, he published a mathematical
essay that earned the jealous envy of René Descartes, one of the founders of modern
geometry. (Pascal’s work actually had been completed before he was 16.) It was based on
a theorem, which he called the hexagrammum mysticum, or mystic hexagram, that
described the inscription of hexagons in conic sections (parabolas, hyperbolas, and
ellipses). In addition to the theorem (now called Pascal’s theorem), his essay included
more than 400 corollaries.
When Pascal was about 20, he constructed a mechanical calculator that performed
addition and subtraction of eight-digit numbers. The calculator required the user to dial in
the numbers to be added or subtracted; the sum or difference then appeared in a set of
windows. It is believed that his motivation for building this machine was to aid his father in
collecting taxes. The earliest version of the machine did, indeed, split the numbers into six
decimal digits and two fractional digits, as would be used for calculating sums of money.

The machine was hailed by his contemporaries as a great advance in mathematics, and
Pascal built several more in different forms. It achieved such popularity that many fake,
nonfunctional copies were built by others and displayed as novelties. Several of Pascal’s
calculators are now exhibited in various museums.
Pascal’s box, as it is called, was long believed to be the first mechanical calculator.
However, in 1950, a letter from Wilhelm Shickard to Johannes Kepler, written in 1624, was
discovered. This letter described an even more sophisticated calculator built by Shickard
20 years prior to Pascal’s box. Unfortunately, the machine was destroyed in a fire and
never rebuilt.
During his twenties, Pascal solved several difficult problems related to the cycloid curve,
indirectly contributing to the development of differential calculus. Working with Pierre de
Fermat, he laid the foundation of the calculus of probabilities and combinatorial analysis.
One of the results of this work came to be known as Pascal’s triangle, which simplifies the
calculation of the coefficients of the expansion of (x + y)n, where n is a positive integer.
Pascal also published a treatise on air pressure and conducted experiments showing
that barometric pressure decreases with altitude, which helped to confirm theories that had
been proposed by Galileo and Torricelli. His work on fluid dynamics forms a significant part
of the foundation of that field. Among the most famous of his contributions is Pascal’s law,
which states that pressure applied to a fluid in a closed vessel is transmitted uniformly
throughout the fluid.
When Pascal was 23, his father became ill, and the family was visited by two disciples
of Jansenism, a reform movement in the Catholic Church that had begun six years earlier.
The family converted, and five years later one of his sisters entered a convent. Initially,
Pascal was not so taken with the new movement, but by the time he was 31, his sister
had persuaded him to abandon the world and devote himself to religion.
Pascal’s religious works are considered no less brilliant than his mathematical and
scientific writings. Some consider Provincial Letters, his series of 18 essays on various
aspects of religion, to mark the beginning of modern French prose.
Pascal returned briefly to mathematics when he was 35. A year later his health, which
had always been poor, took a turn for the worse. Unable to perform his usual work, he
devoted himself to helping the less fortunate. Three years later, he died while staying with
his sister, having given his own house to a poor family.
QUICK CHECK
3.5.1 What happens to the fractional portion of a floating-point number when it is
converted to an integer type?
3.5.2 What operators studied in this section have the highest precedence level?
3.5.3 What operators studied in this section have the lowest precedence level?
3.5.4 What must we use to force the evaluation of a subexpression outside of the
regular precedence rules?
3.5.5 What must we use in order to mix integer and floating-point values in the same
expression?

3.5.6 Assume we have a variable x declared as an int and a variable y declared as a
float and the following expression: x = y + 1.25. What explicit type cast must be
used to make this a valid expression?
3.5.7 How must the following expression be modified in order to correctly produce the
correct percentage for a student’s score and the total points available in an
assignment. Assume that score and total have type int.
Description
3.5.8 What is the result of the following expression?
Description
3 There are two other ways of writing a cast operation in C++, which have some advantages
over this syntax. We will wait until Chapter 7 to introduce and explain them. Until then, this
simpler notation will be adequate for your programming needs.

3.6 Function Calls and Library Functions
Value-Returning Functions
At the beginning of Chapter 2, we showed a program consisting of three functions: main,
Square, and Cube. Here is a listing of a portion of the program:
Description
At the time we introduced the program, we said that all three functions are value-returning
functions. Square returns to its caller a value—the square of the number sent to it. Cube returns
a value—the cube of the number sent to it. Likewise, main returns to the operating system a
value—the program’s exit status.
Let’s focus for a moment on the Cube function. The main function contains the following
statement:
Description
In this statement, the master (main) causes the servant (Cube) to compute the cube of 27 and
give the result back to main. The portion that reads
Description

is a function call or function invocation. The computer temporarily puts the main function on
hold and starts the Cube function running. When Cube has finished doing its work, the computer
goes back to main and picks up where it left off.
Function call The mechanism that transfers control to a function; also called a function
invocation.
In the preceding function call, the number 27 is known as an argument (or actual
parameter). Arguments make it possible for a function to work on different values. For
example, we can write the following statements to take the cube of 4 and of 16, respectively:
Description
Here’s the syntax template for a function call:
Description
The argument list is a way for functions to communicate with one another. Some functions,
such as Square and Cube, have a single argument in the list. Other functions, such as main,
have no arguments. Other functions may have two, three, or more arguments in the list,
separated by commas.
Argument list A mechanism by which functions communicate with one another.
Value-returning functions are used in expressions in much the same way that variables and
constants are. The value computed by a function simply takes its place in the expression. For
example, the statement
stores the value 80 into someInt. First the Cube function is executed to compute the cube of 2,
which is 8. The value 8—now available for use in the rest of the expression—is then multiplied
by 10. Note that a function call has higher precedence than multiplication, which makes sense
if you consider that the function result must be available before the multiplication takes place.
Here are several facts about value-returning functions:

The function call is used within an expression; it does not appear as a separate
statement.
The function computes a value (result) that is then available for use in the expression.
The function returns exactly one result—no more, no less.
The Cube function expects to be given (or passed) an argument of type int. What happens if
the caller passes a float argument? The compiler applies type coercion. Thus, Cube(6.9)
computes the cube of 6, not 6.9.
Although we have been using literal constants as arguments to Cube, the argument could
just as easily be a variable or a named constant. In fact, the argument can be any expression
of the appropriate type. In the statement
Description
the expression in the argument list is evaluated first, and its result is passed to the function.
For example, if int1 contains 3 and int2 contains 5, the preceding function call passes 34 as
the argument to Cube.
An expression in a function’s argument list can even include calls to functions. For
example, we could use the Square function to rewrite the preceding assignment statement as
follows:
Description
Library Functions
Certain computations, such as square root and absolute value, are very common in
programs. It would be a waste of time if every programmer had to start from scratch and
create such functions. To help make our life easier, every C++ system includes a standard
library—a large collection of prewritten functions, data types, and other items that we can use.
The functions in the library are divided into separate files called header files. Here is a very
small sample of some standard library functions:

Description
Technically, the entries in the table marked float should all say double. These library functions
perform their work using double-precision floating-point values. Because of type coercion,
however, the functions also work when you pass float values to them.
Using a library function is easy. First, you place an #include directive near the top of your
program, specifying the appropriate header file. This directive causes the C++ preprocessor
to insert declarations into your program that give the compiler some information about the
function. Then, whenever you want to use the function, you just make a function call. Here’s a
sample program that calls functions, along with its output:

Description
Output:
Description
The C++ standard library provides dozens of functions for you to use. Appendix C lists a
much larger selection than we have presented here. You should glance briefly at this appendix
now, keeping in mind that some of the terminology and C++ language notation will make
sense only after you have read more of this text.
Void Functions
Thus far, we have looked only at value-returning functions. In fact, C++ provides another kind
of function. Look at the following definition for function CalcPay. Notice how it begins with the
word void instead of a data type like int or float:
Description

CalcPay is an example of a function that doesn’t return a value. Instead, it just performs some
action and then quits. We refer to a function like this as a non-value-returning function, a void-
returning function, or, most briefly, a void function. In some programming languages, a void
function is known as a procedure.
Void function (procedure) A function that does not return a function value to its caller and
is invoked as a separate statement.
Void functions are invoked differently from value-returning functions. With a value-
returning function, the function call appears in an expression. With a void function, the function
call is a separate, standalone statement. In the LeapYear program, main calls the IsLeapYear
function using an expression like this:
Description
Value-returning function A function that returns a single value to its caller and is invoked
from within an expression.
By comparison, a call to a void function has the flavor of a command or built-in instruction:
Description
For the next few chapters, we won’t be writing our own functions (except main). Instead,
we’ll be concentrating on how to use existing functions, including functions for stream input
and output. Some of these functions are value-returning functions; others are void functions.
Again, we emphasize the difference in how you invoke these two kinds of functions: A call to a
value-returning function occurs in an expression, whereas a call to a void function occurs as a
separate statement.
QUICK CHECK
3.6.1 Where do arguments appear, and what is their purpose?
3.6.2 Write an expression that computes the square root of 17.5.
3.6.3 How does a call to a void function differ from a call to a value-returning function?
3.6.4 What does the computer do to main when a function is invoked?
3.6.5 What are in libraries and what are they used for?
3.6.6 How does a programmer use a library?


3.7 Formatting Output
To format a program’s output means to control how it appears visually on the screen. In
Chapter 2, we considered two kinds of output formatting: creating extra blank lines by using
the endl manipulator and putting extra blanks into literal strings. In this section, we examine
how to format output values themselves.
Integers and Strings
By default, consecutive integer and string values are output with no spaces between them. If
the variables i, j, and k contain the values 15, 2, and 6, respectively, the statement
Description
outputs the following stream of characters:
Description
Without spacing between the numbers, this output is difficult to interpret.
To separate the output values, you could print a single blank (as a char constant) between
the numbers:
Description
This statement produces the following output:
Description
If you want even more spacing between items, you can use literal strings containing blanks:
Description
The resulting output is shown here:
Description

Another way to control the horizontal spacing of the output is to use manipulators. For some
time now, we have been using the endl manipulator to terminate an output line. In C++, a
manipulator is a rather curious thing that behaves like a function but travels in the disguise of a
data object. Like a function, a manipulator causes some action to occur. But like a data object,
a manipulator can appear in the midst of a series of insertion operations:
Description
Manipulators are used only in input and output statements.
Here’s a revised syntax template for the output statement, showing that not only arithmetic
and string expressions, but also manipulators are allowed:
Description
The C++ standard library supplies many manipulators, but for now we look at only five of
them: endl, setw, fixed, showpoint, and setprecision. The endl, fixed, and showpoint
manipulators come “for free” when we #include the header file iostream to perform I/O. The
other two manipulators, setw and setprecision, require that we also #include the header file
iomanip:
Description
The manipulator setw—meaning “set width”—lets us control how many character positions
the next data item should occupy when it is output. (setw is typically used for formatting
numbers and strings, rather than char data.) The argument to setw is an integer expression
called the fieldwidth specification; the group of character positions is called the field. The next
data item to be output is printed right-justified (filled with blanks on the left to fill up the field).
Let’s look at an example. Suppose two int variables have been assigned values as follows:

Description
Then the following output statements produce the output shown to their right:
Description
In Example 1, each value is specified to occupy enough positions so that there is at least
one space separating them. In Example 2, the values all run together because the fieldwidth
specified for each value is just large enough to hold the value. This output obviously is not
very readable. It’s better to make the fieldwidth larger than the minimum size required so that
some space is left between values. Example 3 includes extra blanks for readability; Example
4 does not. In Example 5, the fieldwidth is not large enough for the value in ans, so it
automatically expands to make room for all of the digits.
Setting the fieldwidth is a one-time action. This preference holds only for the very next item
to be output. After this output, the fieldwidth resets to 0, meaning “extend the field to exactly as
many positions as are needed.” For example, in the statement
Description
the fieldwidth resets to 0 after ans is output. As a result, we get the output
Description

Here is a short program that illustrates these manipulators, followed by the output.
Description
Output:
Description
Floating-Point Numbers
You can specify a fieldwidth for floating-point values just as for integer values. When doing so,
you must remember to allow for the decimal point when you specify the number of character
positions. For example, the value 4.85 requires four output positions, not three. If x contains
the value 4.85, the statement
Description
produces the following output:

Description
In the third line, a fieldwidth of 3 isn’t sufficient, so the field automatically expands to
accommodate the number.
Several other issues arise when we are working with the output of floating-point numbers.
First, large floating-point values are output in scientific (E) notation. The value 123456789.5
may output on some systems as
Description
You can use the manipulator named fixed to force all subsequent floating-point output to
appear in decimal form rather than scientific notation:
Description
Second, if the number is a whole number, C++ doesn’t output a decimal point. Thus the
value 95.0 is output as
To force decimal points to be displayed in subsequent floating-point output, even for whole
numbers, you can use the manipulator showpoint:
Description
Third, you often would like to control the number of decimal places (digits to the right of the
decimal point) that are displayed. If your program is supposed to output the 5% sales tax on a
certain amount, for example, the statement
Description
may produce the following output:
Description
Obviously, you would prefer to display the result to two decimal places. To do so, use the
setprecision manipulator as follows:

Description
Provided that fixed has already been specified, the argument to setprecision specifies the
desired number of decimal places. Unlike setw, which applies only to the very next item
output, the value sent to setprecision remains in effect for all subsequent output (until you
change it with another call to setprecision). Here are some examples in which setprecision
is used in conjunction with setw, given that x is 310.0 and y is 4.827:
Description
Again, the total number of print positions is expanded if the fieldwidth specified by setw is too
narrow. However, the number of positions for fractional digits is controlled entirely by the
argument to setprecision.
In some applications, it may be desirable to force output values to be in scientific notation,
which is accomplished using the scientific manipulator. When the output stream is in
scientific mode, setprecision determines the number of digits displayed after the decimal
point. We should also note that if neither fixed nor scientific mode has been set, then
setprecision determines the number of digits displayed preceding the exponent. Here are two
examples:
Description
In the first case, scientific notation is output because the number is big enough to cause the
output stream to automatically change to e notation. (If a smaller number is subsequently
output, the stream switches back to normal formatting.) Because no manipulator for fixed or
scientific formatting has previously been inserted into the stream, setprecision formats the

number to have five digits preceding the e. In the second case, the scientific manipulator
switches the stream into scientific mode. In this mode, setprecision formats the number with
five digits between the decimal point and the e. Subsequent output will be in scientific notation
until a fixed manipulator is used.
The following table summarizes the manipulators we have discussed in this section.
Manipulators without arguments are available through the header file iostream. Those with
arguments require the header file iomanip.
Description
The following program and output demonstrate the use of these manipulators.
Description

Output:
Description
MATTERS OF STYLE Program Formatting
As far as the compiler is concerned, C++ statements are free format: They can appear
anywhere on a line, more than one can appear on a single line, and one statement can
span several lines. The compiler needs blanks (or comments or new lines) only to
separate important symbols, and it needs semicolons only to terminate statements. Of
course, these restrictions are the bare minimum. In fact, it is extremely important that your
programs be readable, both for your sake and for the sake of anyone else who has to
examine them.
When you write an outline for an English paper, you follow certain rules of indentation to
make it readable. These same kinds of rules can make your programs easier to read. It is
much easier to spot a mistake in a neatly formatted program than in a messy one. Thus
you should keep your program neatly formatted while you are working on it. If you’ve
gotten lazy and let your program become messy while you were making a series of
changes, take the time to straighten it up. Often the source of an error becomes obvious
during the process of formatting the code. Some code editors will even do this formatting
for you.
Take a look at the following program for computing the cost per square foot of a house.
Although it compiles and runs correctly, it does not conform to any formatting standards.

Description
Now look at the same program with proper formatting:

Description
Need we say more?
Appendix F talks about programming style. Use it as a guide when you are writing
programs.
QUICK CHECK
3.7.1 Neatly formatting a program makes it easier to find errors. True or false?
3.7.2 Which stream manipulator would you use to set the output precision for
floatingpoint values?
3.7.3 What library must be included to set the output precision for floating-point
values?

3.7.4 What does the setw manipulator do for us?
3.7.5 What does the showpoint manipulator do?
3.7.6 What manipulator is used to output scientific notation?

3.8 Additional string Operations
Now that we have introduced numeric types and function calls, we can take advantage of
additional features of the string data type. In this section, we introduce four functions that
operate on strings: length, size, find, and substr.
The length and size Functions
The length function, when applied to a string variable, returns an unsigned integer value that
equals the number of characters currently in the string. If myName is a string variable, a call to
the length function looks like this:
Description
You write the name of a string variable (here, myName), then a dot (period), and then the function
name and argument list. The length function requires no arguments, but you still must use
parentheses to signify an empty argument list. Also, length is a value-returning function, so
the function call must appear within an expression:
Description
Perhaps you are wondering about the syntax in a function call like
Description
This expression uses a C++ notation called dot notation. There is a dot (period) between the
variable name firstName and the function name length. As we noted in Chapter 1, C++ is an
object-oriented language. The string type is an example of a C++ object type, and dot
notation is required when calling functions associated with objects. Suppose you forget to use
dot notation, writing the function call as

You will get a compile-time error message, something like UNDECLARED IDENTIFIER. The
compiler thinks you are trying to call an ordinary function named length, not the length
function associated with the string object. In Chapter 4, we discuss C++ objects. For now it is
enough to know that their function calls use dot notation.
Some people refer to the length of a string as its size. To accommodate both terms, the
string type provides a function named size. Both firstName.size() and firstName.length()
return the same value.
The length and size functions return an unsigned integer value of type string::size_type.
Most C++ compilers, however, allow you to assign the result to a variable of type int.4
Description
Before leaving the length and size functions, we should remark on capitalization
conventions for identifiers. In the guidelines given in Chapter 2, we said that in this text we
begin the names of programmer-defined functions and data types with uppercase letters. We
follow this convention when we write our own functions and data types in later chapters.
However, we have no control over the capitalization of items supplied by the C++ standard
library. Identifiers in the standard library generally use all lowercase letters.
The find Function
The find function searches a string to find the first occurrence of a particular substring and
returns an unsigned integer value (of type string::size_type) giving the result of the search.
The substring, passed as an argument to the function, can be a literal string or a string
expression. If str1 and str2 are of type string, all of the following are valid function calls:
Description
In each of the three cases, str1 is searched to see if the specified substring can be found
within it. If so, the function returns the position within str1 where the match begins. (Positions
are numbered starting at 0, so the first character in a string is in position 0, the second is in
position 1, and so on.) For a successful search, the match must be exact, including identical
capitalization. If the substring could not be found, the function returns the special value
string::npos, a named constant meaning “not a position within the string.” (string::npos is the
largest possible value of type string::size_type, a number like 4294967295 on many
machines. This value is suitable for “not a valid position” because the string operations do not
let any string become this long.)
Given the code segment

Description
the statement
Description
assigns to position the value 12, whereas the statement
Description
assigns to position the value string::npos, because there was no match.
The argument to the find function can also be a char value. In this case, find searches for
the first occurrence of that character within the string and returns its position (or string::npos,
if the character was not found). For example, the following program
Description
outputs
Description
which is the position of the first occurrence of a lowercase a in theString.

Below are some more examples of calls to the find function, assuming the following code
segment has been executed:
Description
Function Call
Value Returned by Function
str1.find ("and")
12
str1.find ("Programming")
0
str2.find ("and")
string::npos
str1.find ("Pro")
0
str1.find ("ro" + str2)
1
str1.find ("Pr" + str2)
string::npos
str1.find (' ')
11
In the fourth example, there are two copies of the substring "Pro" in str1, but find returns
only the position of the first copy. Also notice that the copies can be either separate words or
parts of words—find merely tries to match the sequence of characters given in the argument.
The final example demonstrates that the argument can be as simple as a single character,
even a single blank.
The substr Function
The substr function returns a particular substring of a string. Assuming myString is of type
string, here is a sample function call:
Description
The first argument is an unsigned integer that specifies a position within the string, and the
second is an unsigned integer that specifies the length of the desired substring. The function
returns the piece of the string that starts with the specified position and continues for the
number of characters given by the second argument. Note that substr doesn’t change
myString. Instead, it returns a new, temporary string value that is a copy of a portion of the
string. Following are some examples, assuming the statement
Description

has been executed.
Function Call
String Contained in Value Returned by Function
myString.substr(0, 7)
"Program"
myString.substr(7, 8)
"ming and"
myString.substr(10, 0)
""
myString.substr(24, 40)
"Solving"
myString.substr(40, 24)
None; program terminates with an execution error message
In the third example, specifying a length of 0 produces the null string as the result. The
fourth example shows what happens if the second argument specifies more characters than
are present after the starting position: substr returns the characters from the starting position
to the end of the string. The last example illustrates that the first argument, the position, must
not be beyond the end of the string.
Because substr returns a value of type string, you can use it with the concatenation
operator (+) to copy pieces of strings and join them together to form new strings. The find and
length functions can be useful in determining the location and end of a piece of a string to be
passed to substr as arguments.
Here is a program that uses find and substr to break a string into parts.
Description
Output:

Description
The program uses find to locate the first blank and substr to extract the substring beginning
with the first character and extending to just before the first blank. This substring is stored in
firstName. The original string is redefined to contain the string following the first blank through
to the end. The process is repeated to extract the middle name. The remaining string is stored
in lastName. Perhaps this process seems trivial—after all, we could have just created the three
separate strings. However, in Chapter 4, when we examine how to read a string from the
keyboard, this general algorithm will prove useful for breaking an input string into different
parts.
Accessing Characters Within a String: The at Function
Sometimes it would be very useful to access characters directly by their position. C++ allows
us to do so using the at function. Here is an example call to this function:
Description
Remember that within a string, the first character is at position 0. Therefore, the value of
somePosition must be greater than or equal to 0 and less than or equal to the string length
minus 1. For example, if inputStr is a string object and letter is a char variable, the
statement
Description
accesses the character at position 2 of the string (the third character) and copies it into
letter. Calling at with a value that lies outside the allowable range will generate an error
message.
Converting to Lowercase and Uppercase
When working with character data, you may sometimes find that you need to convert a
lowercase letter to uppercase, or vice versa. Fortunately, such conversions are easy—a call
to a library function is all it takes. Through the header file <cctype>, the standard library
provides two value-returning functions named toupper and tolower. Here are their
descriptions:

Description
The value returned by each function is just the original character if the condition is not met.
For example, tolower('M') returns the character 'm', whereas tolower('+') returns '+'.
The following program uses toupper to ensure that the first letter of a string is uppercase.
The first letter is extracted and changed to uppercase. Then the string is concatenated with
the original string with the first character removed.
Description
Output:

Description
The following table summarizes the string and character operations we have looked at in
this chapter.
Description
SOFTWARE ENGINEERING TIP Understanding Before
Changing
When you are trying to get a program to run and you come across an error, it’s tempting to
start changing parts of the program in an attempt to make it work. Don’t! You’ll nearly
always make things worse. It’s essential that you understand what is causing the error and

carefully think through the solution. The only thing you should try is running the program
with different data to determine the pattern of the unexpected behavior.
There is no magic trick that can automatically fix a program. If the compiler tells you that
a semicolon or a right brace is missing, you need to examine the program and determine
precisely what the problem is. Perhaps you accidentally typed a colon instead of a
semicolon. Or maybe there’s an extra left brace.
A good rule of thumb is, don’t edit or recompile the program until you are confident that a
change will fix the problem. And always keep a copy of the unchanged code that you can
return to, in case your changes don’t solve the problem. Some programming environments
provide a version control system that automatically logs changes and lets you back them
out of the code if necessary.
QUICK CHECK
3.8.1 What is the value of the following expression, given that the string variable
quickCheck contains the string "My friend I shall be pedagogic"?
3.8.2 What is the result of the following expression if myString contains "Hello"?
3.8.3 What is the result of the following expression if myString contains "Hello"?
3.8.4 What library function can be used to make a character lowercase?
PROBLEM-SOLVING CASE STUDY Mortgage Payment
Calculator
PROBLEM: Your parents are thinking about refinancing their mortgage and have asked
you to help them with the calculations. Now that you’re learning C++, you realize that you
can save yourself a lot of calculator button-pressing by writing a program to do the
calculations automatically.
DISCUSSION: In the case study in Chapter 1, we said that there are often three obvious
steps in almost any problem of this type:
1. Get the data.
2. Compute the results.
3. Output the results.

The data we need in this case are the amount of money to borrow, the number of years
for the loan, and the interest rate. From these three values, the monthly payment can be
calculated. You can make the data values be constants now; later, when you learn how to
input values, you can rewrite the program.
After a chat with your parents, you find that they still owe $50,000 on the house and
have exactly 7 years worth of payments to go. The latest quote from their credit union is
for an interest rate of 5.24% with no closing costs.
Define Constants
Set LOAN_AMOUNT = 50000.00
Set NUMBER_OF_YEARS = 7
Set INTEREST_RATE = 0.0524
You go to the Internet to look up the formula for determining payments, using compound
interest.
Description
Two values taken to the number of payments power looks daunting. Fortunately, the
C++ <cmath> header file, which we saw earlier, contains a power function (pow). Before you
actually enter the values in the formula, two intermediate values need to be calculated:
monthly interest rate and number of payments.
Calculate Values
Set monthlyInterest to YEARLY_INTEREST divided by 12
Set numberOfPayments to NUMBER_OF_YEARS times 12
Set payment to (LOAN_AMOUNT * pow(1+monthlyInterest, numberOfPayments) *
monthlyInterest) / (pow(1+monthlyInterest, numberOfPayments) –1)
All that is left is to display the answer, clearly formatted. Let’s use fixed format and a
precision of 2 for the floating-point values.
Output Results
Set mode to fixed and precision to 2.
Print “For a loan amount of ” LOAN_AMOUNT “ with an interest rate of ”
YEARLY_INTEREST “ and a ” NUMBER_OF_YEARS “ year mortgage, ”
Print “your monthly payments are $” payment “.”
From the algorithm, we can create tables of constants and variables to help us write the
declarations for the program.
CONSTANTS
Name
Value
Function
LOAN_AMOUNT
50000.00
Amount of the loan

Name
Value
Function
YEARLY_ INTEREST
0.0524
Yearly interest rate
NUMBER_OF_YEARS
7
Number of years
VARIABLES
Name
Data Type
Description
monthlyInterest
float
Monthly interest rate
numberOfPayments
int
Total number of payments
payment
int
Monthly payment

Description
Output:
Description
Something looks strange about the output: The interest should be 0.0524, not 0.05. The
decision to use a precision of 2 was correct for dollars and cents, but not for interest rates,
which are rarely whole percentages. You are asked to make this correction in Case Study
Follow-Up Exercise 3.1.
4 In Chapter 10, we explain why it is better programming practice to use a type supplied by
string itself. In all of the examples we see before raising that point, int is adequate.

Testing and Debugging
3.1. An int constant other than 0 should not start with a zero. If it starts with a zero, it is
an octal (base-8) number.
3.2. Watch out for integer division. The expression 47/100 yields 0, the integer quotient.
This is a common source of erroneous output in C++ programs.
3.3. When using the / and % operators, remember that division by zero is not allowed.
3.4. Double-check every expression against the precedence rules to be sure that the
operations are performed in the desired order.
3.5. Avoid mixing integer and floating-point values in expressions. If you must mix them,
use explicit type casts to reduce the chance of mistakes.
3.6. For each assignment statement, check that the expression result has the same data
type as the variable to the left of the assignment operator (=). If not, consider using an
explicit type cast for clarity and safety. Also, remember that storing a floating-point value
into an int variable truncates the fractional part.
3.7. For every library function you use in your program, be sure to #include the
appropriate header file.
3.8. Examine each call to a library function to confirm that you have the right number of
arguments and that the data types of the arguments are correct.
3.9. With the string type, positions of characters within a string are numbered starting at
0, not 1.
3.10. If the cause of an error in a program is not obvious, change your program only after
you take the time to understand the source of the error.

Summary
C++ provides several built-in numeric data types, of which the most commonly used are
int and float. The integral types are based on mathematical integers, but the computer
limits the range of integer values that can be represented. The floating-point types are
based on the mathematical notion of real numbers. As with integers, the computer limits
the range of floating-point numbers that can be represented. Also, it limits the number of
digits of precision in floating-point values. We can write literals of type float in several
forms, including scientific (E) notation.
Much of the computation of a program is performed in arithmetic expressions.
Expressions can contain more than one operator. The order in which the operations are
performed is determined by precedence rules. In arithmetic expressions, multiplication,
division, and modulus are performed first, followed by addition and subtraction. Multiple
binary (two-operand) operations of the same precedence are grouped from left to right. You
can use parentheses to override the precedence rules.
Expressions may include function calls. C++ supports two kinds of functions: value-
returning functions and void functions. A value-returning function is called by writing its
name and argument list as part of an expression. A void function is called by writing its
name and argument list as a complete C++ statement. Calls to functions associated with
C++ objects use dot notation.
The C++ standard library is part of every C++ system. It contains many prewritten data
types, functions, and other items we can use. These items are accessed by using
#include directives to the C++ preprocessor, which then inserts the appropriate header
files into the program.
In output statements, the setw, showpoint, fixed, and setprecision manipulators can be
used to control the appearance of values. These manipulators do not affect the values
actually stored in memory—only their appearance when displayed.
Not only should the output produced by a program be easy to read, but the program
itself should also be clear and readable. C++ is a free-format language. Using a consistent
style that incorporates indentation, blank lines, and spaces within lines will help you (and
other programmers) understand and work with your programs.
The string object type provides a collection of useful functions that can be applied to
strings: length and size return the number of characters in a string, find looks for a
substring within a larger string, and substr returns a specified substring of a string. The
functions toupper and tolower allow us to force a character to be uppercase or lowercase,
respectively. Characters within a string can be accessed by using the at function.

Quick Check Answers
3.2.1 char, short, int, and long 3.2.2 Integer values (whole numbers without a fractional
part). 3.2.3 unsigned 3.2.4 smallest: char or unsigned char; largest: long or unsigned long.
3.2.5 smallest: long; largest: unsigned long. 3.2.6 The result is integer overflow. 3.2.7 The
floating-point type. 3.2.8 float, double, long double. 3.2.9 3.504E12 3.3.1 const float PI =
3.14159. 3.3.2 int 3.3.3 The declarations are exactly the same, except that we use the
reserved word int or float instead of string, and we assign a numerical value to the
constant rather than a string value. 3.4.1 37 % 7 = 2 3.4.2 An error. 3.4.3 A special infinity
value displayed as “inf”. 3.4.4 It adds 1 to the value of the variable num. 3.5.1 The frac-
tional part is truncated. 3.5.2 Unary + and -. 3.5.3 Binary + and -. 3.5.4 Parentheses ( )
3.5.5 Type casting 3.5.6 x = int(y + 1.25). 3.5.7 float percentage = (float(score) /
float(total)) * 100.0; 3.5.8 27 + ( 8 * 6) – (44 % 5) = 27 + 48 – 4 = 71 3.6.1 They
appear in the call to a function, between parentheses, and are used to pass data to or from
a function. 3.6.2 sqrt(17.5) 3.6.3 A void function call appears as a separate statement
rather than being part of an expression. 3.6.4 It puts main temporarily on hold. 3.6.5
Libraries contain commonly used functions so programmers do not need to start from
scratch. 3.6.6 They use the #include directive to get access to the library. 3.7.1 True. 3.7.2
setprecision 3.7.3 iomanip 3.7.4 It lets us control how many character positions the next
data item should occupy when it is output. 3.7.5 It forces a decimal point to be displayed in
subsequent floating- point output. 3.7.6 scientific 3.8.1 "I shall be pedagogic My
friend." 3.8.2 'l' 3.8.3 0 3.8.4 tolower

Exam Preparation Exercises
3.1 The integer and floating-point types in C++ are considered (simple, address,
structured) data types. (Circle one)
3.2 What are the four integral types in C++? List them in order of size, from smallest
to largest.
3.3 What is the result if the computer tries to calculate a value that is larger than the
maximum integer allowed for a given integral type?
3.4 In a floating-point value, what does it mean when the letter E appears as part of a
number?
3.5 Label each of the following as an integer or floating-point declaration, and indicate
whether it is a constant or a variable declaration.
Integer/Floating Point Constant/Variable
a. const int tracksOnDisk = 17;
_________
_________
b. float timeOfTrack;
_________
_________
c. const float maxTimeOnDisk = 74.0;
_________
_________
d. short tracksLeft;
_________
_________
e. float timeLeft;
_________
_________
f. long samplesInTrack;
_________
_________
g. const double sampleRate = 262144.5; _________
_________
3.6 What are the two meanings of the / operator?
3.7 What is the result of each of the following expressions?
a. 27 + 8 / 5 – 7
b. 27.0 + 8.0 / 5.0 – 7.0
c. 25 % 7 + 9.0
d. 17++
e. int(15.0 + 12.0 * 2.2 – 3 * 7)
f. 23 --
g. 18 / 1.0
3.8 List the following operators in the order of highest precedence to lowest
precedence. If a set of operators has the same precedence, write them enclosed in
square brackets within the ordered list.

Description
3.9 The increment and decrement operators can either precede or follow their
operand. True or false?
3.10. Match the following terms to the definitions given below.
a. Unary operator
b. Binary operator
c. Type coercion
d. Type casting
e. Mixed type expression
f. Argument list
g. Void function
i. A computation involving both floating-point and integer values
ii. An operator with two operands
iii. A function that is called as a separate statement
iv. Explicitly changing a value of one type into another
v. The values that appear between the parentheses in a function call
vi. An operator with just one operand
vii. Implicitly changing a value of one type into another
3.11 The statement
Description
is equivalent to which C++ operator?
3.12 How do you write a C++ cast operation?
3.13 Is main a value-returning function or a void function?
3.14 Show precisely what the following statement outputs:
Description
3.15 The prefix and postfix forms of the increment operator (++) always behave the
same way. We can use them interchangeably anywhere in C++ code. True or false?
Explain your answer.

3.16 Which data type do we use to declare a variable to hold the result of applying the
length function to a string?
3.17 Given that the string variables str1 and str2 contain
Description
and
Description
respectively, what is the result of each of the following expressions?
a. str1.length ()
b. str1.find (str 2)
c. str1.substr (4, 25)
d. str1.substr (4, 25).find (str 2)
e. str1.substr.(str1.find ("logic"), 3)
f. str1.substr (24, 5).find (str2.substr (0, 1))
g. str1.find (" end")
3.18 What does the manipulator fixed do?
3.19 What does the function toupper do?
3.20 What does the function tolower do?

Programming Warm-Up Exercises
3.1 Write an expression to convert a time stored in the int variables hours, minutes,
and seconds into the number of seconds represented by the time. For example, if
hours contains 2, minutes contains 20, and seconds contains 12, then the result of your
expression should be 8412.
3.2 Given an int variable days that contains a number of days:
a. Write an expression that gives the number of whole weeks corresponding to
days. For example, if days contains 23, then the number of whole weeks is 3.
b. Write an expression that gives the number of days remaining after taking the
whole weeks out of the value in days. For example, if days contains 23, then the
number of days remaining after 3 whole weeks is 2.
3.3 Given int variables called dollars, quarters, dimes, nickels, and pennies, write an
expression that computes the total amount of the money represented in the variables.
The result should be an integer value representing the number of pennies in the total.
3.4 Given the same variables as in Exercise 3, compute the total but store it in a
floating-point variable so that the integral part is dollars and the fractional part is cents.
3.5 Write an assignment statement that adds 3 to the value in the int variable count.
3.6 Write expressions that implement the following formulas:

Description
3.7 Write a series of assignment statements that find the first three positions of the
string "and" in a string variable sentence. The positions should be stored in int
variables called first, second, and third. You may declare additional variables if
necessary. The contents of sentence should remain unchanged.
3.8 Write an assignment statement to find the first blank in a string variable called
name. Store the result plus one in the int variable startOfMiddle.
3.9 Write an output statement that prints the value in the float variablemoney in eight
spaces on the line, with a leading dollar sign ($) and two digits of decimal precision.
3.10 Write an output statement that prints the value in the double variable distance in
15 spaces on a line with 5 digits of decimal precision.
3.11 If you include the header file climits in a program, the constants INT_MAX and
INT_MIN are provided, which give the highest and lowest int values that can be
represented. Write the include statement for this file as well as an output statement
that displays the two values, identified with appropriate labels.
3.12 Write the statement that accesses the third character in string variable mystring.
3.13 Write the statement that changes the char variable l e tt er to lowercase.
3.14 Write the statement that changes the char variable l e tt er to uppercase.
3.15 Complete the following C++ program. The program should compute and output
the Celsius value corresponding to the given Fahrenheit value.
Description

Programming Problems
3.1 Write a C++ program that computes and outputs the volume of a cone, given the
diameter of its base and its height. The formula for computing the cone’s volume is:
Description
Be sure to use proper formatting and appropriate comments in your code. The output
should be labeled clearly.
3.2 Write a C++ program that computes the mean and standard deviation of a set of
four integer values. The mean is the sum of the four values divided by 4, and the
formula for the standard deviation is
Description
Where n = 4, xi refers to each of the four values, and 
 is the mean. Note that
although the individual values are integers, the results are floating-point values. Be
sure to use proper formatting and appropriate comments in your code. The output
should be labeled clearly and formatted neatly.
3.3 The factorial of a number n (written n!) is the number times the factorial of itself
minus one. This self-referential definition is easiest to understand through an example:
The factorial of 2 is 2 * 1; the factorial of 3 is 3 * 2 * 1; the factorial of 4 is 4 * 3 * 2 * 1;
and so on. Factorials grow very large, very quickly. An approximation to the factorial
for larger values is given by Stirling’s formula:
Description
The exp function in the <cmath> header file gives the value of e raised to given power
(see Appendix C.5). We’ve already discussed all of the other functions that are
needed to write this formula. Write a C++ program that computes the factorial of 15
both directly and with Stirling’s formula, and outputs both results, together with their

difference. You will need to use the double type for this computation. Be sure to use
proper formatting and appropriate comments in your code. The output should be
labeled clearly and formatted neatly.
3.4 Write a C++ program that computes a student’s grade for an assignment as a
percentage given the student’s score and the total points. The final score should be
rounded up to the nearest whole value using the ceil function in the <cmath> header
file. You should also display the floating-point result up to 5 decimal places.
3.5 Given the following string:
“Program testing can be used to show the presence of bugs, but never to show their
absence”
Write a C++ program that will construct a new string in uppercase from the string
above such that the new string is:
“I CAN WRITE CODE THAT RUNS”
3.6 The number of permutations of a set of n items taken r at a time is given by the
following formula:
Description
where n! is the factorial of n. (See Programming Problem 3.3 for a discussion of ways
to compute the factorial.) If there are 18 people in your class and you want to divide
the class into programming teams of 3 members, you can compute the number of
different teams that can be arranged using this formula. Write a C++ program that
determines the number of potential team arrangements. You will need to use the
double type for this computation. Be sure to use proper formatting and appropriate
comments in your code. The output should be labeled clearly and formatted neatly.
3.7 Write a C++ program that takes a string containing a full name and outputs each
part of the name separately. The name should be in the form of first, middle, and last
name, separated from each other by a single space. For example, if the name string
contains
Description
then the program would output

Description
3.8 Extend Programming Problem 3.7 to output the length of each name. This
problem can be solved using a combination of the string operations presented in this
chapter. Be sure to use proper formatting and appropriate comments in your code.
The output should be labeled clearly and formatted neatly.

Case Study Follow-Up
1. Change the output statements in the Mortgage Payment Calculator program so that
the interest rate is output with four decimal places, but the dollar amounts continue to
have two decimal places.
2. The program assumes that the number of months left on the old mortgage is an
even multiple of 12. Change the program so that the constant is the number of months
left, not the number of years.
3. We usually speak of interest rates as percentages. Rewrite the program so that
YEARLY_INTEREST is set as a percentage—that is, as 5.24 rather than 0.0524. You
can compensate for this change by modifying expressions that make use of the
constant.
4. The calculation of 1 + monthlyInterest is made twice. Rewrite the program so that
it makes this calculation only once. In your judgment, which version of the program is
better? Justify your answer.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  4
Program Input and the
Software Design Process
KNOWLEDGE GOALS
To understand the value of appropriate prompting messages for interactive programs.
To know when noninteractive input/output is appropriate and how it differs from
interactive input/output.
To understand the distinction between functional decomposition and objectoriented
design.
SKILL GOALS
To be able to:
Construct input statements to read values into a program.
Determine the contents of variables assigned values by input statements.
Write programs that use data files for input and output.
Apply the functional decomposition methodology to solve a simple problem.
Take a functional decomposition and code it in C++, using self-documenting code.
A program needs data on which to operate. Up to this point, we have been writing data values
in the program itself. If this were the only way to enter data, we would have to modify and
recompile a program for each new set of values. In this chapter, we see how to enter data into
a running program.
With the ability to enter data, we can start solving more interesting problems. For a simple
problem, it’s easy to choose a solution strategy, write the algorithm, and code the program. As
problems become more complex, however, we have to be more methodical in how we solve
them. In the second part of this chapter, we look at two general methodologies: object-oriented
design and functional decomposition.

4.1 Getting Data into Programs
If we want a program that we can use with many different sets of data, we must keep the data
separate from the program until it is executed. Then instructions in the program copy values
from the data set into variables in the program, enabling the program to work with them (see
FIGURE 4.1).
Description
FIGURE 4.1 Separating the Data from the Program
Getting values from an outside data set into variables in a program is called input. We say
that the computer reads data into variables. Data can come from an input device, from a file
on an auxiliary storage device, or from across a network. We look at file input later in this
chapter; here we consider the standard input device, the keyboard. Because of its complexity,
we do not consider network input in this text.
Input Streams and the Extraction Operator (>>)

In addition to output streams, C++ supports input streams. You can think of an input stream
as a doorway through which characters come into your program from an input device.
To use stream input/output (I/O), we write the preprocessor directive
Description
The header file iostream includes definitions of two data types: istream and ostream. These
data types represent input streams and output streams, respectively. The header file also
contains declarations that look like this:
Description
The first declaration says that cin (pronounced “see-in”) is a variable of type istream. The
second says that our old friend cout is a variable of type ostream. The stream cin is
associated with the standard input device (the keyboard).
You can output values to cout by using the insertion operator (<<), which is sometimes
pronounced “put to”:
Description
In a similar fashion, you can input data from cin by using the extraction operator (>>),
sometimes pronounced “get from”:
Description
When the computer executes this statement, it inputs the next number you type on the
keyboard (425, for example) and stores it into the variable cost.
The extraction operator >> takes two operands. Its left-hand operand is a stream expression
(in the simplest case, just the variable cin). Its right-hand operand is a variable into which we
store the input data. For now, let’s assume the variable is of a simple type (char, int , float ,
and so forth). Later in the chapter we discuss the input of string data.
You can use the >> operator multiple times in a statement. Each occurrence inputs the next
data item from the stream. For example, there is no difference between the statement
Description
and the pair of statements

Description
Writing a sequence of extractions in one statement is just more convenient.
At first, it can be easy to confuse the extraction operator (>>) with the insertion operator (<<).
Here is a way to remember which is which: Begin the statement with either cin or cout , and
use the operator that points in the direction the data are going. The statement
Description
sends data from the variable someInt to the output stream. The statement
Description
sends data from the input stream to the variable someInt . The following program
demonstrates the use of cin and cout.
Description
Here is the output, with the data entered by the user highlighted:

Description
Here’s the syntax template for an input statement:
Description
Unlike the items in an output statement, which can be expressions, the items in an input
statement can only be variables. Why? Because an input statement needs a place to store
the incoming value. Only variables are able to take on new values while a program is running.
When entering data at the keyboard, you must be sure that each value is appropriate for the
data type of the variable in the input statement.
Data Type of Variable in
an >> Operation
Valid Input Data
char
A single printable character other than a blank
int
An int literal constant, optionally preceded by a sign
float
An int or float literal constant (possibly in scientific, or E,
notation), optionally preceded by a plus or minus sign
When you input a number into a float variable, the input value doesn’t need a decimal point.
That’s because an integer is automatically coerced to a float value. Any other mismatches,
such as entering a float value into an int variable or a char value into a float variable, can
produce unwanted results. Later in this chapter we discuss what might happen.
When looking for the next input value in the stream, the >> operator skips any leading
whitespace characters, including blanks and certain invisible characters, such as the
character that marks the end of a line. (We talk about this end-of-line character in the next
section.) After skipping whitespace, the >> operator extracts the next data value from the input
stream. If the destination variable has the char type, input stops as soon as a single character
is input. If the variable is an int or float , input stops at the first character that is inappropriate
for the data type, such as a whitespace character. Here are some examples, where i , j , and
k are int variables, ch is a char variable, and x is a float variable:
Statement
Data
Contents After Input
1. cin >> i;
32
i = 32

Statement
Data
Contents After Input
2. cin >> i >> j;
4 60
i = 4, j = 60
3. cin >> i >> ch >> x;
25 A 16.9
i = 25 , ch = 'A' , x = 16.9
4. cin >> i >> ch >> x ;
25
A
16.9
i = 25 , ch = 'A' , x = 16.9
5. cin >> i >> ch >> x ;
25A16.9
i = 25 , ch = 'A' , x = 16.9
6. cin >> i >> j >> x;
12 8
i = 12, j = 8 (Computer waits for a third number.)
7. cin >> i >> x;
46 32.4 15 i = 46, x = 32.4 (15 is held for later input.)
Examples 1 and 2 show integer input. Example 3 shows that you do not use quotes around
character input values (unlike character constants in a program, where quotes distinguish
them from identifiers). Example 4 demonstrates how skipping whitespace characters includes
going to the next line if necessary. Example 5 shows that the first character encountered that
is inappropriate for a numeric data type ends the number. Input for the variable i stops at the
input character A, after which the A is stored into ch, and then input for x stops at the end of the
input line. Example 6 shows that if you don’t enter enough values to satisfy the input
statement, the computer waits (and waits and waits . . .) for more data. Example 7 shows that
if you enter more values than there are variables in the input statement, the extra values
remain waiting in the input stream to be read by the next input statement. If extra values are
left over when the program ends, the computer disregards them.
The Reading Marker and the Newline Character
To better explain stream input, we introduce the concept of the reading marker, which keeps
track of the point in the input stream where the computer should continue reading—the next
character to be read. The extraction operator >> leaves the reading marker on the character
following the last piece of data that was input.
Each input line has an invisible end-of-line (or newline) character that tells the computer
where one line ends and the next begins. To find the next input value, the >> operator crosses
these line boundaries if necessary.
Where does the newline character come from? When you are entering data on a keyboard,
you generate a newline character each time you press the Return or Enter key. Your program
generates a newline character when it inserts the endl manipulator in an output stream. You
can also insert a newline character in output by using \n. Both endl and \n tell the screen
cursor to go to the next line.
Let’s look at some examples of input using the reading marker and the newline character. In
the following table, i is an int variable, ch is a char variable, and x is a float variable. The
input statements produce the results shown. The part of the input stream printed in color is
what has been extracted by input statements. The reading marker, denoted by the shaded
block, indicates the next character waiting to be read. The \n denotes the newline character.

Description
Reading Character Data with the get Function
As we have discussed, the >> operator skips any leading whitespace characters while looking
for the next value in the input stream. Suppose that ch1 and ch2 are char variables and the

program executes the following statement
Description
If the input stream consists of
Description
then the extraction operator stores 'R' into ch1, skips the blank, and stores '1' into ch2. (Note
that the char value '1' is not the same as the int value 1. The two are represented in different
ways in a computer’s memory. The extraction operator will interpret the same sequence of
characters in an input stream differently, as needed, to fill different types of variables.)
What if we had wanted to input three characters from the input line, where one was a blank?
With the extraction operator, it’s not possible, because it skips blanks.
The istream data type provides another way to read character data: The get function inputs
the very next character in the input stream without skipping whitespace characters. The
function call looks like this:
Description
The get function is associated with the cin object, so we use dot notation to make a function
call. (Recall that we used dot notation in Chapter 3 to invoke certain functions associated with
string objects. Later in this chapter we take a closer look at dot notation.) Notice that get uses
the syntax for calling a void function, not a value-returning function. The function call is a
statement, rather than part of an expression.
The effect of this function call is to input the next character waiting in the stream—even if it
is a whitespace character—and store it into the variable somechar. The argument to the get
function must be a variable because its purpose is receive the input character as a new value.
The following program demonstrates the use of the get function to read three characters
and store them in three different places.

Description
Here is the output, with user input highlighted:
Description
Because the middle character is a blank, we could have used the following three lines to input
the data:
Description
However, the first version always works.
Here are some more examples of character input using both the >> operator and the get
function. ch1, ch2, and ch3 are all char variables. As before, \n denotes the newline character.

Description

THEORETICAL FOUNDATIONS More About Functions and
Arguments
When your main function tells the computer to go execute the instructions in another
function, SomeFunc, the main function is calling SomeFunc. In the call to SomeFunc, the
arguments in the argument list are passed to the function. When SomeFunc finishes,
execution returns to the statement following the call.
With some functions you have seen, such as sqrt and abs, you can pass constants,
variables, and arbitrary expressions to the function. But, as we just saw, the get function
accepts only a variable as an argument. Even though get is called as a void function—not
a value-returning function—it returns or passes back a value through its argument list. The
point to remember is that you can use arguments both to send data into a function and to
get results back out.
Skipping Characters with the ignore Function
Most of us have a specialized tool laying somewhere, gathering dust because we rarely use
it. Of course, when we suddenly need it, we’re glad we have it. The ignore function associated
with the istream type is analogous. We rarely use ignore; but when we need it, we’re glad it’s
available.
The ignore function is used to skip (read and discard) characters in the input stream. It is a
function with two arguments, called like this:
Description
The first argument is an int expression; the second, a char value. This particular function call
tells the computer to skip the next 200 input characters or to skip characters until a newline
character is read, whichever comes first.
Here are some examples that use a char variable ch and three int variables, i, j, and k:

Description
Example 1 shows the most common use of the ignore function, which is to skip the rest of
the data on the current input line. Example 2 demonstrates the use of a character other than \
n as the second argument. We skip over all input characters until a comma has been found,
and then read the next input number into i . In both Example 1 and Example 2, we are
focusing on the second argument to the ignore function, and we arbitrarily choose any large
number, such as 100, for the first argument. In Example 3, we change our focus and
concentrate on the first argument. Our intention is to skip the next two input characters on the
current line.
Reading String Data

To input a character string into a string variable, we have two options. First, we can use the
extraction operator (>>). When reading characters into a string variable, the >> operator skips
leading whitespace characters. It then reads successive characters into the variable, stopping
at the first trailing whitespace character (which is not consumed, but remains as the first
character waiting in the input stream). For example, given the following code:
Description
if the input stream initially looks like this (where   denotes a blank):
Description
then our input statement stores the four characters Mary into firstName, stores the five
characters Smith into lastName, and leaves the input stream as
Description
Although the >> operator is convenient for string input, it cannot read a string containing
blanks. This limitation leads us to the second option for string input: the getline function. A call
to getline looks like this:
Description
This call, which does not use dot notation, requires two arguments: an input stream variable
(here, cin) and a string variable. The getline function reads from the current marker position
to the next newline character; that is, getline reads the remainder of the current input line,
embedded blanks and all. Note that with getline, the newline character is consumed (but is
not stored into the string variable). Given the code segment
Description
and the input line

Description
the result of the call to getline is that all 17 characters on the input line are stored into
inputStr, and the reading marker is positioned at the beginning of the next input line.
The following table summarizes the differences between the >> operator and the getline
function when reading string data into string variables.
Statement
Skips Leading
Whitespace?
Stops Reading When?
cin >> inputStr; Yes
When a trailing whitespace character is encountered
(which is not consumed)
getline (cin,
inputStr);
No
When \n is encountered (which is consumed)
The following program demonstrates the use of getline and cin.
Description

Here is a sample run of the program. The data entered by the user are highlighted, and are
followed by the output.
Description
QUICK CHECK
4.1.1 Write an input statement that reads three integer values into variables a, b, and c.
4.1.2 If an input line contains
what will be the values in the string variables first, middle, and last when the
following statement is executed?
4.1.3 What do we call the process of placing values from an outside data set into
variables in a program?
4.1.4 Which operator do you use for program input, >> or <<?
4.1.5 Why can an input statement specify only variables as its operands?
4.1.6 What is a reading marker used for?
4.1.7 What function can we use to read a character into a char variable ch and not
skip spaces?
4.1.8 Write a C++ statement that invokes a function to skip 10 characters or skip
characters until a space is encountered?

4.2 Interactive Input/Output
An interactive program is one in which the user communicates directly with the computer.
Most of the programs you are familiar with are probably interactive.
To get data into an interactive program, we begin with input prompts—that is, messages
explaining what the user should enter. Without these messages, the user won’t know what
values to type. A program may also display the entered values so the user can verify their
correctness. Showing the input values is called echo printing.
Here’s a program showing the proper use of prompts:

Description
Here is the output, with user input highlighted:

Description
Go back and look at the program in the previous section. It is the same program with no
prompts. If you were the person entering the information, which program would you prefer to
use?
The amount of information you should put into prompts depends on who will use the
program. With a program for novice users, prompts should be more detailed. For example, a
prompt might read, “Type a four-digit part number, then press the Enter key.” If the program
will be used frequently by the same people, you might shorten the prompts: “Enter PN” and
“Enter Qty.”
The decision about whether a program should echo print also depends on how experienced
the users are with the nature of the input. If the users are experienced and the prompts are
clear, then echo printing is probably not required. If the users are novices or multiple values
can be input at once, echo printing should be used. If the program takes a large quantity of
data as input and the users are experienced, rather than echo print the data, it may be stored
in a file that can be checked afterward. We discuss how to store data into a file later in this
chapter.
In addition to prompts, it can be helpful to have a program output some general instructions
at the beginning (“Enter a negative number when done.”). When data are entered incorrectly, a
message that indicates the problem should be output. It’s important that error messages be
informative and “friendly.” The message
Description
is likely to upset the user, and it doesn’t offer any constructive information. A much better
message would be
Description

In Chapter 5, we introduce the statements that allow us to test for erroneous data.
QUICK CHECK
4.2.1 Why do we need to use prompts for interactive I/O?
4.2.2 What is an input prompt?

4.3 Noninteractive Input/Output
Although we tend to use examples of interactive I/O in this text, many programs are written
using noninteractive I/O; for example, a program that takes as input a file containing semester
grades for thousands of students and creates grade reports to be sent out to them.
When a program must read a large volume of data, the usual practice is to store the data in
a file. When a program is designed to output lots of data, the output can be sent directly to
another file. After the program has been run, a user can examine the data at leisure. In the
next section, we discuss input and output with files.
Programs designed for noninteractive I/O do not display prompting messages for input.
Because noninteractive programs tend to output large amounts of data, their output may take
the form of a table—columns with descriptive headings.
Most C++ programs are written for interactive use. The flexibility of the language allows you
to write noninteractive programs as well. The biggest difference is in the input/output
requirements. Noninteractive programs are generally more rigid about the organization and
format of the input and output data.

4.4 File Input and Output
In everything we’ve done so far, we’ve assumed that the input to our programs comes from
the keyboard and that the output goes to the screen. We look now at input/output with files.
Files
A file is a named area in secondary storage that holds a collection of information (for example,
the program code we have typed into the editor). The information in a file usually is stored on
an auxiliary storage device, such as a solid-state drive. Our programs can read data from a
file in the same way they read data from the keyboard, and they can write output to a file in the
same way they write output to the screen.
Besides being more appropriate than interactive entry for working with a large amount of
data, a file output from one program can be input into another one. Files provide a means for a
collection of programs to share data.
Using Files
If we want a program to use file I/O, we have to do four things:
1. Tell the preprocessor to include the header file fstream.
2. Declare the file streams we will use.
3. Prepare each file for reading or writing by using a function named open.
4. Specify the name of the file stream in each input or output statement.
Including the Header File fstream
Suppose we want the Mortgage program from Chapter 3 to read data from a file and write its
output to a file. The first thing we must do is add the following preprocessor directive:
Description
Through the header file fstream, the C++ standard library defines two data types, ifstream and
ofstream (standing for input file stream and output file stream, respectively). Consistent with
the general idea of streams in C++, the ifstream data type represents a stream of characters
coming from an input file, whereas ofstream represents a stream of characters going to an
output file.
All of the istream operations you have learned about—the extraction operator (>>), the get
function, and the ignore function—are also valid for the ifstream type. Likewise, all of the
ostream operations, such as the insertion operator (<<) and the endl, s e tw, and setprecision
manipulators, apply to the ofstream type. To these basic operations, the ifstream and ofstream
types add operations specifically for file I/O.

Declaring File Streams
You declare stream object variables the same way you declare any variable—specify the type
and the name:
Description
(We don’t have to declare the cin and cout streams because the header file iostream
automatically does that.)
For our program, which relates to mortgages, let’s name the input and output file stream
objects inData and outData. We declare them like this:
Description
Note that the ifstream type is for input files only, and the ofstream type is for output files
only. With these data types, you cannot read from and write to the same file.
Opening Files
The third thing we have to do is prepare each file for reading or writing by opening the file.
Opening a file causes the operating system to make the file ready for use.
In our example, we want to read from inData and write to outData. We can open the files like
this:
Description
Both of these statements are function calls. In each function call, the argument is a string. The
first statement calls a function named open, associated with inData. The second statement
calls another function (also named open) associated with outData. As we saw earlier, we use
dot notation to call functions associated with objects.
Exactly what does an open function do? First, it associates a stream variable in your
program with a file on the computer. Our first function call creates a connection between the
stream object inData and the actual file, named loan.in. (Names of streams must be
identifiers; they are variables in your program. But operating systems use a different syntax
for file names. For example, many systems allow or even require a dot within a file name.)
Similarly, the second function call associates the stream object outData with the file loan.out
.1

The next thing the open function does depends on whether the file is for input or output. With
an input file, open sets the file’s reading marker to the first piece of data in the file. (Each input
file has its own reading marker.)
With an output file, open checks whether the file already exists. If the file doesn’t exist, open
creates a new, empty file. If the file already exists, open erases the old contents of the file.
Then the writing marker is set at the beginning of the empty file (see FIGURE 4.2). As output
proceeds, each successive output operation advances the writing marker to add data to the
end of the file.
FIGURE 4.2 The Effect of Opening a File
Description
Because we open files to prepare them for reading or writing, we must open them before
using any input or output statements with the files. It’s a good idea to open files right at the
start of the program to be sure that the files are ready before any attempt to perform file I/O.
Description
In addition to the open function, a close function is associated with both the ifstream and
ofstream types. This function has no arguments and may be used as follows:

Description
Closing a file causes the operating system to perform certain wrap-up activities on it and to
break the connection between the stream variable and the file.
In some programming languages, it’s important that you close each file. In C++, however, a
file is automatically closed when program control leaves the block (compound statement) in
which the stream variable is declared. (Until we get to Chapter 8, this block will be the main
function for our examples.) When control leaves the block, a special function associated with
each stream object, called a destructor, is implicitly called to close the file. Typically, we only
call close explicitly when we want to disconnect a stream from a file without leaving the block.
For example, if we want to write some data to a file, and then read it back in, we have to close
it first (disconnect it from the output stream) so we can reopen it with an input stream.
Specifying File Streams in Input/Output Statements
As we said earlier, all istream operations also are valid for the ifstream type, and all ostream
operations are valid for the ofstream type. So, the last difference in file I/O is that for each
operation on a file, we substitute the appropriate file stream variable for cin or cout . In
ourMortgage program, we would use a statement like
Description
to read from inData. Similarly, output statements will specify outData, not cou t, as the
destination:
Description
What is nice about C++ stream I/O is that we have a uniform syntax for performing I/O
operations, regardless of whether we’re working with the keyboard and screen, with files, or

with other I/O devices.
SOFTWARE MAINTENANCE CASE STUDY Adding File
Input/Output to a Program
We have used the Mortgage program as an example to demonstrate file input and output. In
this maintenance case study, we rework the complete program to use files.
The first steps in any maintenance project involve examining the original program,
understanding how the code works, and creating a copy of the original code with which to
work. Here is a listing of the program with some analysis of it interspersed.
Description
These first four lines remain the same for any program that uses screen input/output,
math functions, and formatting manipulators. Now, however, we will use file input/output.
Thus the first line must be changed to include fstream rather than iostream.
Description
These constants must be removed and variable declarations inserted for loanAmount,
yearlyInterest, and numberOfYears. These declarations should be placed within the
function main along with the other declarations.
Description
These declarations should remain the same, followed by the declarations for the values
that were previously constants.

Description
These assignment statements must have the names of the constants replaced with the
corresponding variable names. But before we do that, we must read the values for the
variables from the input file.
Description
The constants need to be replaced by the variable names in these output statements.
While we are making the changes, let’s change the output to be in tabular form rather than
sentence form.
Let’s list the tasks necessary to make the changes.
Remove constants and insert variable declarations.
Read in the values for the variables.
Change assignments to use variables instead of constants.
Change output statements from constants to appropriate variables.
Make the output in table form.
Have we forgotten anything? Yes: We must declare the file variables, which in turn
means we must include fstream and open the files. Although it isn’t required, we also close
the files so that you can see an example of doing this.
Here is a listing of the revised program with the changes highlighted.


Description
Before running the program, you would use the editor to create and save a file loan.in to
serve as input. The contents of loan.in and loan.out are shown here:
loan.in
Description
loan.out

Description
In writing the new Mortgage program, what happens if you mistakenly specify cout
instead of outData in an output statement? The output of that statement goes to the screen
instead of the file. And what if, by mistake, you specify cin instead of inData in the input
statement? The result is not as obvious: When you run the program, the computer will
appear to go dead (to hang). Here’s why: Execution reaches the input statement and the
computer waits for you to enter the data from the keyboard. Of course, you don’t know that
the computer is waiting, because there is no prompt, and you are assuming that the
program is reading the file. So the computer waits, and you wait, and you wait, and you
wait, until you give up and tell the operating system to force the program to quit.
Run-Time Input of File Names
Until now, our examples of opening a file for input have included code similar to the following:
Description
The open function requires an argument that specifies the name of the file. When it is a literal
string, the file name is fixed at compile time, so the program works for only this particular file.
We often want a program to be able to choose the file name at run time. For example, we
could prompt the user for the name of the file, read the response into a variable, and pass the
variable to the open function. In principle, the following code should work, but the compiler
does not allow it.
Description
The problem is that open does not take an argument of type string. Instead, it expects a C
string, so named because it originated in the C language, the forerunner of C++. A C string is
a limited form of string. A literal string happens to be a C string and thus is acceptable as an
argument to open.

To make this code work correctly, we need to convert the string variable’s value to a C
string. The string data type provides a value-returning function named c_str that is applied to
a string object using dot notation:
Description
This function returns the C string that is equivalent to the contents of the fileName variable.
(The original string contained in fileName is not changed by the function call.) The primary
purpose of the c_str function is to allow programmers to call library functions that expect C
strings, instead of string objects, as arguments.
The following program reads in a file name and stores the first line in the file. The file and
output are shown following the program.
Description
File testData.in:
Description
Output:

Description
QUICK CHECK
4.4.1 What is a file?
4.4.2 Why might we want a program to read from a file instead of the keyboard?
4.4.3 Why might we want a program to write output to a file instead of the screen?
4.4.4 What are the four things we must do to have a program use file I/O?
4.4.5 Which data type is used for a file input stream?
4.4.6 Which data type is used for a file output stream?
4.4.7 What is wrong with the following code:
4.4.8 What conditions would you look for in a problem to decide whether interactive or
noninteractive input is appropriate?
4.4.9 After including the header file fstream and declaring a file stream, what is the
next step in using file I/O?
1 C++ provides a second means to declare a file variable and associate a file name with it, all
in one statement. You can instead write
These statements are examples of what C++ calls parameterized constructors. This term is
related to the object-oriented aspect of C++.

4.5 Input Failure
When a program inputs data, things can go wrong. Suppose a program prompts us to enter
an integer, but we type some letters. The input operation fails because of the invalid data. In
C++ terminology, the cin stream has entered the fail state. Once a stream has entered the fail
state, any further I/O operations using that stream become null operations—that is, they have
no effect. Unfortunately for us, the computer does not halt the program or display any error
message. It just continues executing the program, silently ignoring each additional attempt to
use that stream.
Invalid data are the most common reason for input failure. When your program takes an int
value as input, it expects to find only digits in the input stream, possibly preceded by a plus or
minus sign. If there is a decimal point somewhere within the digits, does the input operation
fail? Not necessarily. Let’s look at an example.
Assume that a program has int variables i, j, and k, whose contents are currently 10, 20,
and 30, respectively. The program executes the following two statements:
Description
If we type these characters for the input data:
Description
then the program produces this output:
Description
Let’s see why.
Remember that when reading int or float data, the extraction operator >> stops reading at
the first inappropriate character. In our example, the input operation for i succeeds. The
computer extracts the first four characters from the input stream and stores the integer value
1234 into i. The reading marker is now on the decimal point:
Description
The next input operation (for j ) fails; an int value cannot begin with a decimal point. The cin
stream is now in the fail state, and the current value of j (20) remains unchanged. The third
input operation (for k) is ignored, as are any subsequent statements that read from cin.

Another way to make a stream enter the fail state is to try to open an input file that doesn’t
exist. Suppose you have a data file named myfile.dat . Your program includes the following
statements:
Description
In the call to open, the file name is misspelled. At run time, the attempt to open the file fails, so
the stream inFile enters the fail state. The input operations for i, j, and k become null
operations. Without issuing an error message, the program then uses the (unknown) contents
of i, j, and k in calculations. The results are likely to be incorrect.
The point of this discussion is not to make you nervous about I/O but rather to make you
aware of its limitations. The “Testing and Debugging” section at the end of this chapter offers
suggestions for avoiding input failure, and Chapters 5 and 6 introduce ways to test the state of
a stream.

4.6 Software Design Methodologies
Over the last two chapters and the first part of this one, we have introduced elements of the
C++ language that let us input data, perform calculations, and output results. The programs
we have written so far have been short and straightforward because the problems to be
solved were simple. We are now ready to write programs for more complicated problems—
but first we need to step back and look at the overall process of programming.
The programming process consists of a problem-solving phase and an implementation
phase. The problem-solving phase includes analysis (understanding the problem to be
solved) and design (solving the problem). Given a complex problem—one that results in a
10,000-line program, for example—it’s not effective to skip the design process and go directly
to writing C++ code. What we need is a systematic way of designing a solution to a problem,
no matter how complicated the problem is.
In the remainder of this chapter, we describe two methodologies for designing solutions to
more complex problems: functional decomposition and object-oriented design. These
methodologies help us create solutions that can be easily implemented as C++ programs.
The resulting programs are readable, understandable, and easy to debug and modify.
One software design methodology in widespread use is known as objectoriented design
(OOD). C++ evolved from the C language primarily to facilitate the use of the OOD
methodology. In this chapter we present the essential concepts of OOD; we expand our
treatment of the approach later in the text. OOD is often used in conjunction with the other
methodology that we discuss in this chapter, functional decomposition.
Object-oriented design (OOD) A technique for developing software in which the solution
is expressed in terms of objects—self-contained entities composed of data and operations
on that data.
Functional decomposition A technique for developing software in which the problem is
divided into more easily handled subproblems, the solutions of which create a solution to
the overall problem.
OOD focuses on entities (objects) consisting of data and operations on the data. In OOD,
we solve a problem by identifying the components that make up a solution and identifying how
those components interact with one another through operations on the data that they contain.
The result is a design for a set of objects that can be assembled to form a solution to a
problem. In contrast, functional decomposition views the solution to a problem as a task to be
accomplished. It focuses on the sequence of operations that are required to complete the
task. When the problem requires a sequence of steps that is long or complex, we divide it into
subproblems that are easier to solve.
The choice of which methodology to use depends on the problem at hand. For example, a
large problem might involve several sequential phases of processing, such as gathering data
and verifying its correctness, analyzing the data, and generating reports at the conclusion of
the analysis. This process has a natural functional decomposition. Each of the phases,
however, may best be solved by a set of objects that represent the data and the operations

that can be applied to it. Some of the objects or operations may be sufficiently complex that
they require further decomposition into additional objects or operations.
If it is natural to think about a problem in terms of a collection of component parts, then you
can use OOD to solve it. For example, a banking problem may require a checkingAccount
object with associated operations OpenAccount ,WriteCheck ,MakeDeposit, and IsOverdrawn . The
checkingAccount object will consist of both data (the account number and current balance, for
example) and these operations, bound together into one unit.
By contrast, if you find that it is natural to think of the solution to the problem as a series of
steps, you should use functional decomposition. For example, when computing some
statistical measures on a large data set, it is natural to decompose the problem into steps that
read a value, perform calculations, and then repeat the process. The C++ language and the
standard library supply the operations that we need, and we simply write a sequence of those
operations to solve the problem.
To summarize, functional decomposition focuses on the process of transforming the input
into the output, resulting in a set of tasks. Object-oriented design focuses on the data objects
that are to be transformed, resulting in a collection of objects. In reality, these design methods
are often combined, with functional decomposition used to describe the operations associated
with the objects in an object-oriented design.
QUICK CHECK
4.6.1 What is the first step in the object-oriented design process?

4.7 Functional Decomposition
In functional decomposition (also called structured design, top-down design, stepwise
refinement, and modular programming), we work from an abstract list of the major steps in
our solution to concrete algorithmic instructions that can be translated directly into C++. You
can also think of this methodology as working from a high-level algorithm, leaving the details
of the implementation unspecified, down to a fully detailed algorithm.
The easiest way to solve a problem is to give it to someone else and say, “Solve this.” The
most abstract level of a problem solution encompasses the entire problem without specifying
details of implementation. It’s at this point that we programmers are called in. Our job is to turn
the abstract solution into a concrete solution, a program.
If the solution clearly involves a series of major steps, we break it down (decompose it) into
those pieces. In the process, we move to a lower level of abstraction—that is, some
implementation details are now specified. Each major step becomes an independent
subproblem to solve separately. In a large project, the chief architect (or team leader) hands
the subproblems to team members, saying, “Solve this problem.” With a small project, we
give the subproblems to ourselves, choosing one at a time to solve. We may break a
subproblem into another series of steps that, in turn, become smaller subproblems. Or we
may identify components that are naturally represented as objects. The process continues
until each subproblem cannot be divided further or has an obvious solution.
Why do we work this way? Why not simply start writing the details? Because it is easier to
focus on one problem at a time. For example, suppose you are working on a program and
discover that you need a complex formula to calculate an appropriate fieldwidth for an output
statement. Calculating a fieldwidth is not your current focus. If you shift your focus to that, you
may forget some detail of what you were working on. So you make a note—“Calculate
fieldwidth”—and go on. After solving the current subproblem, you can return to the calculation.
By subdividing the problem, you create a hierarchical structure called a tree structure. Each
level of the tree is a complete solution to the problem that is more concrete than the level
above it. FIGURE 4.3 shows a generic solution tree for a problem. Steps that are shaded in
green have enough detail to be translated directly into C++; these are concrete steps. Those
that are shaded in purple are abstract steps; they reappear as subproblems in the next level
down. Each box in the figure represents a module. Modules are the basic building blocks in a
functional decomposition. The diagram in Figure 4.3 is also called a module structure chart.
Concrete step A step for which the implementation details are fully specified.
Abstract step A step for which some implementation details remain unspecified.
Module A self-contained collection of steps that solves a problem or subproblem; can
contain both concrete and abstract steps.

FIGURE 4.3 Hierarchical Solution Tree
Description
Functional decomposition uses the divide-and-conquer approach to problem solving; in
other words, it breaks up large problems into smaller units that are easier to handle. OOD
does this, too, but in OOD the units are objects, whereas the units in functional decomposition
are modules.
Modules
A module originates as an abstract step in the next-higher level of the solution tree. It is
complete when it specifies a series of steps that does the same thing as the higher-level
abstract step. At this stage, a module is functionally equivalent to the abstract step. (Don’t
confuse our use of function here with C++ functions. Here we use the term to refer to the
specific role that the module or step plays in an algorithmic solution.)
Functional equivalence A property of a module that performs exactly the same operation
as the abstract step it defines. A pair of modules are also functionally equivalent to each
other when they perform exactly the same operation.

In a properly written module, its concrete steps directly address the given subproblem;
significant new subproblems are written as abstract steps. This is called functional
cohesion.
Functional cohesion A property of a module in which all concrete steps are directed
toward solving just one problem, and any significant subproblems are written as abstract
steps.
The idea behind functional cohesion is that each module should do just one thing and do it
well. Functional cohesion is not a precisely defined property; there is no quantitative measure
of cohesion. Rather, it is based on our ability to judge when something is clear and
understandable. Knowing which details to make concrete and which to leave abstract is a
matter of experience. For example, you might decide to include a fieldwidth calculation in an
output module if the rest of the module is so simple that it won’t be confusing. In contrast, if the
calculation is performed several times, it makes sense to write it as a separate module and
just refer to it each time you need it.
Writing Cohesive Modules
Here’s one approach to writing modules that are cohesive:
1. Think about how you would solve the subproblem by hand.
2. Write down the major steps.
3. If you can see how to implement a step directly in C++, it is at the concrete level; it
doesn’t need further refinement.
4. If you think implementing a step will take multiple C++ statements, it is still at an abstract
level.
5. If you are trying to write a series of steps and start to feel overwhelmed by details, you
probably are bypassing one or more levels of abstraction. Stand back and look for pieces
you can write as abstract steps.
We could call this the “procrastinator’s technique.” If a step is cumbersome or difficult, put it
off to a lower level; don’t think about it today, think about it tomorrow. Of course, tomorrow
does come, but the whole process can be applied again to the subproblem. A trouble spot
often seems much simpler when you can focus on it. And eventually the whole problem is
broken up into manageable units.
As you work your way down the solution tree, you make a series of design decisions. If a
decision proves awkward or wrong (and many times it does!), you can go back up the tree to
a higher-level module and try something else. You don’t have to scrap your whole design—
only the small part you are working on. You may explore many intermediate steps and trial
solutions before you reach a final design.
Pseudocode

You’ll find it easier to implement a design if you write the steps in pseudocode. Pseudocode is
a mixture of English statements and C++-like control structures that can be translated easily
into C++. (We’ve been using pseudocode in the algorithms in the Problem-Solving Case
Studies.) When a concrete step is written in pseudocode, it should be possible to rewrite it
directly as a C++ statement in a program.
Implementing the Design
The product of functional decomposition is a hierarchical solution to a problem with multiple
levels of abstraction. FIGURE 4.4 shows a functional decomposition for the revised Mortgage
program. This kind of solution forms the basis for the implementation phase of programming.
FIGURE 4.4 Solution Tree of Mortgage Program
Description
How do we translate a functional decomposition into a C++ program? If you look closely at
Figure 4.4, you can see that the concrete steps (which are shaded in green) can be
assembled into a complete algorithm for solving the problem. The order in which they are
assembled is determined by their position in the tree. We start at the top of the tree, at level 0,
with the first step, “Open Files.” Because it is abstract, we must go to the next level, level 1.
There we find a series of concrete steps that correspond to this step; this series of steps
becomes the first part of our algorithm. Because the conversion process is now concrete, we
can go back to level 0 and go on to the next step, “Input Values.” Because it is abstract, we go
to level 1 and find a series of concrete steps that correspond to this step; this series of steps
becomes the next part of our algorithm. Returning to level 0, we go on to the next step,
“Calculate Values.” Finally we return to level 0 for the last time and complete the last steps,
“Output Results” and “Close Files.”

Description
From this algorithm we can construct a table of the variables required and then write the
declarations and executable statements of the program.
In practice, you write your design not as a tree diagram, but rather as a series of modules
grouped by levels of abstraction.

Description
If you look at the C++ program forMortgage, you can see that it closely resembles this
solution. The names of the modules are also paraphrased as comments in the code.
The type of implementation that we’ve introduced here is called a flat or inline
implementation. We are flattening the two-dimensional, hierarchical structure of the solution by
writing all of the steps as one long sequence. This kind of implementation is adequate when a
solution is short and has only a few levels of abstraction. The programs it produces are clear
and easy to understand, assuming appropriate comments and good style.
Longer programs, with more levels of abstraction, are difficult to work with as flat
implementations. For those types of programs, it is preferable to implement a hierarchical
solution by using a hierarchical implementation, in which we implement many of the modules
by writing them as separate C++ functions, and the abstract steps in the design are then
replaced with calls to those functions.
One advantage of implementing modules as functions is that they can be called from
different places in a program. For example, if a problem requires that the volume of a cylinder
be computed in several places, we could write a function to perform the calculation and simply
call it in each place. This gives us a semihierarchical implementation. Such an implementation
does not preserve a pure hierarchy because abstract steps at various levels of the solution
tree share one implementation of a module (see FIGURE 4.5). A shared module actually falls
outside the hierarchy because it doesn’t really belong at any one level.

FIGURE 4.5 A Semihierarchical Module Structure Chart with a Shared Module
Description
Another advantage of implementing modules as functions is that you can reuse them in
other programs. Over time, you will build a library of your own functions to complement those
supplied by the C++ standard library.
We postpone discussion of hierarchical implementations until Chapter 8. For now, our
programs remain short enough for flat implementations.
From now on, we use the following outline for the functional decompositions in our case
studies, and we recommend that you adopt a similar outline in solving your own programming
problems:
Problem statement
Input description
Output description
Discussion Assumptions (if any)
Main module
Remaining modules by levels
Module structure chart

In some of our case studies, this outline is reorganized a bit, so that the input and output
descriptions follow the discussion. We may also expand upon it. Don’t think of this outline as a
rigid prescription—it is more like a “to-do list.” We want to be sure to do everything on the list,
but the individual circumstances of each problem guide the steps we use and the order in
which we do them.
A Perspective on Design
We have looked at two design methodologies, object-oriented design and functional
decomposition. Until we learn about additional C++ language features that support OOD, we
will use functional decomposition to develop problem solutions.
Keep in mind that functional decomposition and OOD are not separate, disjointed
techniques. OOD decomposes a problem into objects. Objects contain both data and
associated operations. Those operations require algorithms. Sometimes the algorithms must
be decomposed using functional decomposition. Experienced programmers are familiar with
both methodologies and know when to use one or the other, or a combination of the two.
SOFTWARE ENGINEERING TIP Documentation
As you create your functional decomposition or object-oriented design, you are developing
documentation for your program. Documentation includes the written problem
specifications, design, development history, and actual code of a program.
Good documentation helps other programmers read and understand a program and is
invaluable when software is being debugged and modified (maintained). If you haven’t
looked at your program for six months and need to change it, you’ll be happy that you
documented it well. Of course, if someone else has to use and modify your program,
documentation is indispensable.
Documentation is both external and internal to the program. External documentation
includes the specifications, the development history, and the design documents. Internal
documentation includes the program format and self-documenting code—meaningful
identifiers and comments. You can use the pseudocode from the design process as
comments in your programs.
Self-documenting code Program code containing meaningful identifiers as well as
judiciously used clarifying comments.
This kind of documentation may be sufficient for someone reading or maintaining your
programs. However, if a program will be used by people who are not programmers, you
must provide a user’s manual as well.
Be sure to keep documentation up to date. Indicate any changes you make in a program
in all of the pertinent documentation. Use self-documenting code to make your programs
more readable.

Remember that the problem-solving phase of the programming process takes time. If you
spend the bulk of your time analyzing and designing a solution, then implementing the
program should take relatively little time.
QUICK CHECK
4.7.1 What characterizes a concrete step in a functional decomposition design?
4.7.2 If you are given a functional decomposition design, how do you implement it?
4.7.3 In functional decomposition we work from the ______________ to the
______________.
4.7.4 If a solution clearly involves a series of major steps, what must we do?
4.7.5 What is a module?
4.7.6 What is functional cohesion?
4.7.7 What is pseudocode?
4.7.8 Where do we start when translating a functional decomposition into a C++
program?
Now let’s look at a case study that demonstrates functional decomposition.
Problem-Solving Case Study
DISPLAYING A NAME IN MULTIPLE FORMATS
PROBLEM: You are beginning to work on a problem that needs to output names in
several formats along with the corresponding Social Security number. As a start, you
decide to write a short C++ program that takes a Social Security number as input and a
single name and displays them in the different formats so you can be certain that all of
your string expressions are correct.
INPUT: The Social Security number and a name in three parts, on file name.dat, each
separated by one or more whitespace characters.
OUTPUT: The name is to be written in four different formats on file name.out:
1. First name, middle name, last name, Social Security number
2. Last name, first name, middle name, Social Security number
3. Last name, first name, middle initial, Social Security number
4. First name, middle initial, last name
DISCUSSION: You could easily type the Social Security number and the name in the four
formats as string literals in the code, but the purpose of this exercise is to develop and test
the string expressions needed for the larger problem. The problem statement doesn’t say

in which order the parts of the name are entered on the file, but it does say that they are
separated by whitespace. You assume that they are in first name, middle name or initial,
and last name order. Because the data are on a file, you don’t need to prompt for the
values. Once you have the Social Security number and the name, you just write them out
in the various formats.
ASSUMPTION: The name is in first, middle, and last order on the file.
Main Module
Level 0
Open files
Get Social Security number
Get name
Write data in proper formats
Close files
Open Files
Level 1
Open inData
Open outData
The “Get Social Security number” step can be directly implemented by reading into the
string variable. Thus it doesn’t require expansion at Level 1 of our design.
Get Name
Get first name
Get middle name or initial
Get last name
Does reading the middle name present a problem if the file contains an initial rather than
a middle name? Not really. You just assume that a middle name is entered and extract the
initial from the middle name when you need it for the third and fourth formats. If the initial
was entered for the middle name, then the second and third output forms will be the same.
What about punctuation in the output? If the last name comes first, it should be followed
by a comma, and the middle initial should be followed by a period. Thus, if an initial is
entered rather than a middle name, it must be followed by a period. This must be added to
the assumptions.
ASSUMPTION: The name is in first, middle, and last order, and a period must follow the
middle initial if it is entered instead of a middle name.
Write Data in Proper Formats
Write first name, blank, middle name, blank, last name, blank, Social Security number
Write last name, comma, blank, first name, blank, middle name, blank, Social
Security number
Write last name, comma, blank, first name, blank, middle initial, period, blank, Social
Security number
Write first name, blank, middle initial, period, blank, last name

The only thing left to define is the middle initial. We can directly access the first
character in the middle name.
Middle Initial
Level 2
Set initial to middleName.at(0)
Close Files
Close inData
Close outData
MODULE STRUCTURE CHART
Description
Below is the program. The input data and the output follow the program.

Description
Input file:
Description
Output:

Description

Graphical User Interface (GUI)
Although stream-based input provides us with a simple mechanism for our programs to
receive input from a user, most modern programs interact with humans through a graphical
user interface (GUI). For example, previously, we let the user enter a file name using code like
this:
Description
But it is more pleasant for a human to click buttons and select files from a list than it is to
type input in response to a prompt. It also avoids the problem of having the user mistype the
name of an existing file. Let’s rework the Format Names program from our Problem Solving
Case Study to allow the user to enter the file names, as we did with the Mortgage program in
the Software Maintenance Case Study. But instead of using cin and cout, we will use a more
modern and familiar GUI interface.
The Qt GUI library provides the components we need for this kind of interaction. Those
components are known as dialogs. We access the Qt dialog library with this include
statement:
Description
Qt provides different dialogs for different kinds of interaction. One, called a TextDialog,
simply lets the user enter a string, as we have done with cin. Another, OutputDialog, displays
a string as a message, similar to writing to cout. The difference is that, instead of using the
standard I/O window, each of these displays its own dedicated window with a button that
allows the user to indicate when they are done with it.
Just as we must declare a stream variable before we can use a stream, each dialog object
has to be declared before we use it. For example, we can use a TextDialog to get an output
file name from the user as follows:
Description

The declaration of the TextDialog object, getOutputName, specifies the prompt that it will
display. We then call the display function for the dialog object (using dot notation):
Description
Which displays a window like this:
Screen shot(s) reprinted with permission from Apple Inc.
Description
When the user clicks the OK button, the value they have entered is returned and stored into
the string ou t pu t F il e. The name of the output file is entered as a string because it
doesn’t exist yet (the program will create it). But to get the name of a file that already exists,
we can use a different kind of dialog, called a F il eDi a l og. Note that its use follows the
same pattern.
Description
However, when this dialog displays, instead of providing a text entry field, it shows a view of
the file system and lets us choose a file.

Screen shot(s) reprinted with permission from Apple Inc.
Description
The string that is returned to be assigned to inputFilePath will have not just the file name,
but also the directory in which it resides. The full combination of the directory and the file name
is called the file path. The value in outputFile, however, is just a file name. We should really
specify the directory for the output file, to be consistent. Qt gives us the ability to select a
directory using a DirectoryDialog. Again, it uses the same pattern as the other dialogs.
Description
But it displays a third style of dialog:

Screen shot(s) reprinted with permission from Apple Inc.
In this window, the user can select a directory and click the Open button. A string containing
the full location and name of the directory is thus stored in outputDirectory. However, what is
stored in outputDirectory is only the path to the directory. To get the complete path to the file
we wish to open we must append the output file name to the end of the output directory’s path.
To make things easier at this point we introduce a utility library function (from the utils.h
header file) called pathAppend.
Description
Although we don’t need to show the created file path on the screen, doing so gives us a
chance to see one more type of dialog, called an OutputDialog.
Description

Screen shot(s) reprinted with permission from Apple Inc.
We can use an OutputDialog to display any text that we want the user to see. When they
click OK, the window disappears. Here we put all of the pieces together into a version of the
Format Names program that uses a GUI interface to get the names of the files. The sections
pertaining to the Qt GUI interface are shaded. Other than the GUI code, the only change to the
code from the case study is that the variables inputFilePath and outputFilePath replace the
literal strings we used previously to specify the files in the calls to open.


Description
Notice the pattern for using the Qt GUI components. Each of the required GUI components
is created before we use them to interact with the user. Each GUI component provides a

display () method that shows the component on the screen. Once the component has been
created, we can display it whenever we need it. For example, if we needed the user to enter a
series of text values, we could create a TextDialog for that interaction and display it as many
times as there are values to enter.
If the GUI component is an input component it will also return a string result that can be
used by the program. It is important in all applications to test the return result of any method.
This is especially important for GUI components because the user can click a Cancel button
instead of entering a value or making a selection. In that case, the empty string is returned.
To make things easier for us we introduce another utility library function (from the utils.h
header file), quitWithEmptystring (), that helps our application determine if a string is empty,
and if it is empty (e.g., ""), the program quits immediately to avoid opening a file using the
empty string. The following code fragment shows this change to the previous code:
Description
If you compile and run the program in the Qt Creator IDE you will be presented with a series
of dialogs that let you specify the files to be used by the Format Names program, and it will then
read the input from one file and write the output to another.

Testing and Debugging
An important part of implementing a program is testing it (checking the results). Don’t trust the
computer to give you the correct answers until you’ve verified enough of them by hand to be
sure that the program is working.
From here on, these “Testing and Debugging” sections offer tips on how to test your
programs and what to do if a program doesn’t work the way you expect it to work. But don’t
wait until you’ve found a bug to read the “Testing and Debugging” sections—it’s much easier
to prevent bugs than to fix them.
When testing programs that receive data values from a file as input, it’s possible for input
operations to cause the file stream to enter the fail state. The two most common reasons for
input failure are invalid data and the end-of-file error.
An end-of-file error occurs when the program has read the entire file and still needs more
data to fill the variables in its input statements. It might be that the data file simply was not
prepared properly. Perhaps it contains fewer data items than the program requires. Or
perhaps the format of the input data is wrong. Leaving out whitespace between numeric
values, for instance, can cause this trouble.
As an example, suppose we want a data file to contain three integer values: 25, 16, and 42.
Look what happens with this data:
Description
and this code:
Description
The first two input operations use up the data in the file, leaving the third with no data to read.
The stream inFile enters the fail state, so k isn’t assigned a new value and the computer
goes to the next statement without issuing an error message.
If the data file is prepared correctly and an end-of-file error still occurs, the problem lies in
the program logic. For some reason, it is attempting too many input operations. The error
could be something simple such as specifying too many variables in an input statement. It
could be a misuse of the ignore function, causing values to be skipped inadvertently. Or it
could be a serious flaw in the algorithm. You should check all of these possibilities.
The other major source of input failure—invalid data—has several possible causes. The
most common is an error in the preparation of the data. Numeric and character data mixed
inappropriately can cause an input stream to fail; for example, if it tries to read a numeric value
when the reading marker is on a non-numeric character. Another cause is using a wrong
variable name (which happens to be of the wrong data type). Declaring a variable to be of the
wrong data type is a variation of that problem. Finally, leaving out a variable (or including an
extra one) in an input statement can cause the reading marker to end up positioned on the
wrong type of data.

Another oversight is to use cin or cout in an I/O statement when you meant to specify a file
stream. If you mistakenly use cin instead of an input file stream, the program waits for input
from the keyboard. If you mistakenly use cout instead of an output file stream, you get
unexpected output on the screen.
By giving you a framework that can help you organize and keep track of the details involved
in designing and implementing a program, functional decomposition (and, later, object-oriented
design) should help you avoid many of these errors in the first place.
In later chapters, you’ll see how to test modules separately. If you make sure that each
module works by itself, your program should work when you put the modules together.
Testing modules separately is less work than trying to test an entire program. In a smaller
section of code, it’s less likely that multiple errors will combine to produce behavior that is
difficult to analyze.
Testing and Debugging Hints
1. Input and output statements always begin with the name of a stream object, and the >>
and << operators point in the direction in which the data are going. The statement
Description
sends data to the output stream cout, and the statement
Description
sends data to the variable n.
2. When a program takes input from or sends output to a file, each I/O statement from or
to the file should use the name of the file stream, not cin or cout.
3. The open function associated with an ifstream or ofstream object requires a C string as
an argument. The argument cannot be a string object. At this point in the text, the
argument can only be (a) a literal string or (b) the C string returned by the function call
mystring.c_str (), where mystring is of type string.
4. When you open a data file for input, make sure that the argument to the open function
supplies the correct name of the file.
5. When reading a character string into a string object, the >> operator stops at, but does
not consume, the first trailing whitespace character.
6. Each input statement must specify the correct number of variables, and each of those
variables must be of the correct data type.

7. If your input data is mixed (character and numeric values), be sure to deal with
intervening blanks.
8. Echo print the input data to verify that each value is where it belongs and is in the
proper format. (This is crucial, because an input failure in C++ doesn’t produce an error
message or terminate the program.)

Summary
Programs operate on data. If data and programs are kept separate, the data are available
to use with other programs, and the same program can be run with different sets of input
data.
The extraction operator (>>) inputs data from the keyboard or a file, storing the data into
the variable specified as its right-hand operand. The extraction operator skips any leading
whitespace characters and finds the next data value in the input stream. The get function
does not skip leading whitespace characters; instead, it takes the very next character and
stores it into the char variable specified in its argument list. Both the >> operator and the
get function leave the reading marker positioned at the next character to be read. The next
input operation begins reading at the point indicated by the marker.
The newline character (denoted by \n) marks the end of a data line. You create a
newline character each time you press the Return or Enter key. Your program generates a
newline each time you use the endl manipulator or output the \n character. Newline is an
invisible character that controls the movement of the screen cursor.
Interactive programs prompt the user for each data entry and directly inform the user of
results and errors. Designing interactive dialogs through the use of prompts is an exercise
in the art of communication.
Noninteractive input/output allows data to be prepared before a program is run and
allows the program to run again with the same data in the event that a problem crops up
during processing.
Data files often are used for noninteractive processing and to permit the output from one
program to be used as input to another program. To use these files, you must do four
things: (1) include the header file fstream, (2) declare the file streams along with your other
variable declarations, (3) prepare the files for reading or writing by calling the open function,
and (4) specify the name of the file stream in each input or output statement that uses it.
Object-oriented design and functional decomposition are methodologies for tackling
nontrivial programming problems. Object-oriented design produces a problem solution by
focusing on objects and their associated operations. Functional decomposition begins with
an abstract solution that then is divided into major steps. Each step becomes a
subproblem that is analyzed and subdivided further. A concrete step is one that can be
translated directly into C++; those steps that need more refining are called abstract steps.
A module is a collection of concrete and abstract steps that solves a subproblem.
Programs can be built out of modules using a flat implementation, a hierarchical
implementation, or a semihierarchical implementation.
Careful attention to program design, formatting, and documentation produces well-
organized and readable programs.

Quick Check Answers
4.1.1 cin >> a >> b >> c;
Description
4.1.3 Input. 4.1.4 << 4.1.5 Because an input statement indicates where input data values
should be stored. 4.1.6 To keep track of the point in the input stream where the computer
should continue reading. 4.1.7 cin.get(ch) 4.1.8 cin.ignore(10, ''); 4.2.1 To tell the user
how and when to enter values as input. 4.2.2 A message explaining what the user should
enter. 4.4.1 A named area in secondary storage that holds a collection of information. 4.4.2
If a program will read a large quantity of data, it is easier to enter the data into a file with an
editor than to enter it while the program is running. 4.4.3 The contents of a file can be
displayed on a screen, printed, or used as input to another program. 4.4.4 (1) Include the
fstream library; (2) Declare the file streams we will use; (3) Use the open function to open a
file; and (4) Use the file stream in each input or output statement. 4.4.5 ifstream 4.4.6
ofstream 4.4.7 We must use the fileName.c_str function to return a C string because that
is what the inFile.open function expects as its argument type. 4.4.8 The amount of data to
be input, and whether the data can be prepared for entry before the program is run. 4.4.9
Preparing the file for reading or writing with the open function. 4.6.1 To identify the major
objects in the problem. 4.7.1 It is a step that can be implemented directly in a programming
language. 4.7.2 By identifying all of the concrete steps, starting from the top of the tree and
arranging them in the proper order. The sequence of steps is then converted step-by-step
into code. 4.7.3 Abstract, particular. 4.7.4 We break the problem down into pieces. 4.7.5 A
module is an abstract step in the next-higher level of the solution tree. 4.7.6 A property of a
module in which all concrete steps are directed toward solving just one problem, and any
significant subproblems are written as abstract. 4.7.7 A mixture of English statements and
C++-like control structures that can be translated easily into C++. 4.7.8 We start with the
concrete steps at the bottom of the decomposition tree.

Exam Preparation Exercises
4.1 The statement
Description
is equivalent to the two statements:
Description
True or false?
4.2 What is wrong with each of the following statements?
a. cin << score;
b. cout >> maximum;
c. cin >>"Enter data";
d. cin.ignore ('Y', 35 );
e. getline (some string, cin);
4.3 Suppose the input data are entered as follows:
Description
The input statements that read it are
Description

What are the contents of the variables a, b, c, d, e, and f after the statements have
executed?
4.4 Suppose the input data are entered as follows:
Description
The input statements that read it are
Description
What are the contents of the variables a, b, c, d, e, and f after the statements have
executed?
4.5 Given the input data
Description
and the input statement
Description
a. What is contained in each of the string variables after the statement is
executed?
b. Where is the reading marker after the statement is executed?
4.6 Given the input data
Description

and the input statement
Description
a. What is contained in the string variable after the statement is executed?
b. Where is the reading marker after the statement is executed?
4.7 Given the input data
Description
and the input statement (where the type of each variable is given by its name)
Description
a. What is contained in each of the variables after the statement is executed?
b. Where is the reading marker after the statement is executed?
4.8 If the reading marker is on the newline character at the end of a line, and you call
the get function, what value does it return in its argument?
4.9 What do the two arguments to the ignore function specify?
4.10 You are writing a program whose input is a date in the form of mm/dd/yyyy.
a. Write an output statement to prompt an inexperienced user to enter a date.
b. Write an output statement to prompt an experienced user to input a date.
4.11 What are the four steps necessary to use a file for input or output?
4.12 What are the two file stream data types discussed in this chapter?
4.13 What is the purpose of the following statements?
Description
4.14 Correct the following code segment so that it opens the file whose name is
entered via the input statement.

Description
4.15 What happens when an input operation is performed on a file that is in the fail
state?
4.16 When you try to open a file that doesn’t exist, C++ outputs an error message and
terminates execution of the program. True or false?
4.17 Just opening an input file stream cannot cause it to enter the fail state. True or
false?
4.18 You’re writing a program for a rental car company that keeps track of vehicles.
What are the major objects in this problem?
4.19 Define the following terms:
a. Concrete step
b. Abstract step
c. Module
d. Functional equivalence
e. Functional cohesion
4.20 Which C++ construct do we use to implement modules?
4.21 Which of the following are member functions of the istream class?
a. >>
b. ignore
c. get
d. getline
e. cin
4.22 The open function is associated with both the ifstream and the ofstream data
types. True or false?

Programming Warm-Up Exercises
4.1 Write a C++ input statement that reads three integer values into the variables int1,
int2, and int3, in that order.
4.2 Write a prompting output statement and then an input statement that reads a name
into three string variables: first, middle, and last. The name is to be entered in the
following format: first middle last.
4.3 Write a prompting output statement and then an input statement that reads a name
into a single string variable, name. The name is to be entered on one line, in the
following format: first middle last.
4.4 Write the statements necessary to prompt for and input three floating-point values,
and then output their average. For this exercise, assume that the user has no prior
experience with computers and needs very detailed instructions. To help avoid errors,
the user should enter each value separately.
4.5 Write the statements necessary to prompt for and input three floating-point values,
and then output their average. For this exercise, assume that the user has plenty of
experience with computers and needs minimal instructions. The user should enter all
three values on one line.
4.6 Write the declarations and input statements necessary to read each of the
following sets of data values into variables of the appropriate types. You choose the
names of the variables. In some cases, punctuation marks or special symbols must
be skipped.
a. 100 A 98.6
b. February 23 March 19
c. 19, 25, 103.876
d. A a B b
e. $56.45
4.7 Write a single input statement that reads the following lines of data into the
variables streetNum, street1, street2, town, state, and zip.
Description

4.8 Write the statements necessary to prepare a file called temperatures.dat for
reading as an ifstream called temps.
4.9 The file temperatures.dat contains a list of six temperatures, arranged one per
line. Assuming that the file has already been prepared for reading, as described in
Exercise 4.8, write the statements to read in the data from the file and output the
average temperature. You will also need to declare the necessary float variables to
accomplish this task.
4.10 Fill in the blanks in the following program:

Description
4.11 Modify the program in Exercise 4.10 so that it allows the user to enter the name
of the output file instead of having the program use outData.dat.
4.12 The file stream inFile contains two integer values. Write an input statement that
will cause it to enter the fail state.
4.13 Write a code segment that prompts the user for a file name, reads the file name
into a string called fileName, and then opens the file stream userFile using the
supplied name.
4.14 Use functional decomposition to write an algorithm for writing and mailing a
business letter.

Programming Problems
4.1 Write a C++ program that computes a student’s grade for an assignment as a
percentage given the student’s score and the total points. The final score should be
rounded up to the nearest whole value using the ceil function in the <cmath> header
file. You should also display the floating-point result up to five decimal places. The
input to the program must come from a file containing a single line with the score and
total separated by a space.
4.2 Write a program that reads a line from a file called quote.txt containing the text
Description
and writes the uppercase version of that line in reverse to the output file named
upquote.txt.
4.3 Write an interactive C++ program that inputs a name from the user in the following
format:
Description
The program should then output the name in the following format:
Description
The program will have to use string operations to remove the comma from the end of
the last name. Be sure to use proper formatting and appropriate comments in your
code. The input should have an appropriate prompt, and the output should be labeled
clearly and formatted neatly.
4.4 Write an interactive C++ program whose input is a series of 12 temperatures from
the user. It should write out on file tempdata.dat each temperature as well as the
difference between the current temperature and the one preceding it. The difference is
not output for the first temperature that is input. At the end of the program, the average
temperature should be displayed for the user via cout. For example, given the input
data

Description
file tempdata.dat would contain
Description
Be sure to use proper formatting and appropriate comments in your code. The input
should be collected through appropriate prompts, and the output should be labeled
clearly and formatted neatly.
4.5 Write an interactive C++ program that computes and outputs the mean and
standard deviation of a set of four integer values that are input by the user. (If you did
Programming Problem 3.2 in Chapter 3, then you can reuse much of that code here.)
The mean is the sum of the four values divided by 4, and the formula for the standard
deviation is
Description
where n = 4, xi refers to each of the four values, and 
 is the mean. Although the
individual values are integers, the results are floating-point values. Be sure to use
proper formatting and appropriate comments in your code. Provide appropriate
prompts to the user. The output should be labeled clearly and formatted neatly.
4.6 Write a C++ program that reads data from a file whose name is input by the user,
and outputs the first word following each of the first three commas in the file. For
example, if the file contains the text of this problem, then the program would output

Description
Assume that a comma appears within at least every 200 characters in the file. Be
sure to use proper formatting and appropriate comments in your code. Provide
appropriate prompts to the user. The output should be labeled clearly and formatted
neatly.
4.7 Write a C++ program that allows the user to enter the percentage of the moon’s
face that appears illuminated and outputs the surface area of that portion of the moon.
The formula for the surface area of a segment of a sphere is
Description
where R is the radius of the sphere (the moon’s radius is 1738.3 km) and θ is the
angle of the wedge in radians. There are 2π radians in a circle, so the hemisphere of
the moon that we see accounts for at most π radians. If the user enters 100% (full
moon), the angle of the wedge is π and the formula can be evaluated as follows:
Description
If the user enters 50% (first or last quarter), then the angle of the wedge is π × 0.5,
and so on. Be sure to use proper formatting and appropriate comments in your code.
Provide appropriate prompts to the user. The output should be labeled clearly and
formatted neatly. (Limit the decimal precision to three places as in the example
above.)

Case Study Follow-Up
1. Replace Clara Jones Jacobey’s information with your own name as input to the
Format Names program.
2. Change this program so that the Social Security number is written on a line by itself
with the various name formats indented five spaces on the next four lines.
3. Change the program so that the name of the input file name is read from the
keyboard.
4. Change the program so that the names of both the input file and the output file are
read from the keyboard.
5. Rewrite the Mortgage program, prompting for and reading the variables from the
keyboard.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  5
Conditions, Logical
Expressions, and
Selection Control
Structures
KNOWLEDGE GOALS
To understand how the Boolean operators work.
To understand the flow of control in a branching statement.
To understand the flow of control in a nested branching statement.
To know what preconditions and postconditions are.
SKILL GOALS
To be able to:
Construct a simple logical (Boolean) expression to evaluate a given condition.
Construct a complex logical expression to evaluate a given condition.
Construct an If-Then-Else statement to perform a specific task.
Construct an If-Then statement to perform a specific task.
Construct a set of nested If statements to perform a specific task.
Trace the execution of a C++ program.
Test and debug a C++ program.
So far, our program statements have executed in their written order. The first statement
executes, then the second, and so on, to the end. But what if we need a different order?

Suppose we want to either perform a calculation if an input value is valid or display an error
message if it is not. To do so, we must be able to ask a question (Is the data valid?) and,
based on the answer, choose one or another course of action.
The If statement allows us to accomplish this. We can ask a question with it and do one
thing if the answer is yes (true) or another thing if the answer is no (false). In the first part of
this chapter, we deal with asking questions; in the second part, we deal with the If statement
itself.

5.1 Flow of Control
The order in which program statements execute is called the flow of control. The computer
is really under the control of just one statement at a time. Once a statement is done executing,
the next statement takes over (see FIGURE 5.1).
When we want to change the ordinary flow of control, we use control structures, special
statements that can transfer control to a statement other than the one that appears next in our
code. Control structures are so useful and diverse that we focus on them through Chapter 9.
Flow of control The order in which the computer executes statements in a program.
Control structure A statement used to alter the normally sequential flow of control.
FIGURE 5.1 Flow of Control
Description

FIGURE 5.2 Selection (Branching) Control Structure
Description
Selection
We use a selection (or branching) control structure when we want the computer to choose
between alternative actions. Within the control structure, we ask a true/false question, which
we refer to as the branching condition. If the answer is true, the computer executes one
statement; if it is false, it executes another (see FIGURE 5.2).
The LeapYear program in Chapter 1 shows the selection process at work. The computer
must decide whether a year is a leap year. It does so by asking if the year is not divisible by 4.
If the answer is true, the computer returns a value indicating that it’s not a leap year. If the
answer is false, the computer goes on to check the exceptions to the general rule. In Chapter
1, we said that this construct is like a fork in a road.
Before we examine selection control structures, let’s look at how we get the computer to
make decisions.

QUICK CHECK
5.1.1 What does “flow of control” mean?
5.1.2 What is the “normal” flow of control for a program?
5.1.3 What control structure do we use when we want a computer to choose between
alternative actions?
5.1.4 What does a branch allow the computer to do?

5.2 Conditions and Logical Expressions
To ask a true/false question, we don’t phrase it as a question; we state it as an assertion. For
example, on a true/false quiz, you wouldn't see the question, “How much is 2 + 2?” Instead,
you would see the assertion, “2 + 2 equals 4,” for which you could check true or false as the
answer.
Asking a question in C++ turns into making an assertion that is either true or false. The
computer evaluates the assertion, checking it against some internal condition (the values
stored in certain variables, for instance) to see whether it is true or false.
The bool Data Type
In C++, the bool data type is a built-in type consisting of just two values, the constants true
and false. The reserved word bool is short for Boolean (pronounced “BOOL-e-un”).1 Boolean
data are used for testing conditions in a program so that the computer can make decisions
(with a selection control structure).
We declare variables of type bool the same as with other types—by writing the name of the
data type and an identifier:
Description
Each variable of type bool can contain either true or false. It’s important to understand right
from the beginning that true and false are not variable names and they are not strings. They
are special constants in C++ and, in fact, are reserved words.
Logical Expressions
In programming languages, assertions take the form of logical expressions (also called
Boolean expressions). Just as an arithmetic expression is made up of numeric values and
operations, so a logical expression is made up of logical values and operations. Every logical
expression evaluates to either true or false.
Here are some examples of logical expressions:
A Boolean variable or constant
An expression followed by a relational operator followed by an expression
A logical expression followed by a logical operator followed by a logical expression
Let’s look at each of these in detail.

Boolean Variables and Constants
As we have seen, a Boolean variable is a variable declared to be of type bool, and it can
contain either the value true or the value false. For example, if dataOK is a Boolean variable,
then
Description
is a valid assignment statement.
Relational Operators
We can also set a Boolean variable equal to the result of comparing two expressions with a
relational operator. Relational operators test a relationship between two values, such as less
than, equal to, or greater than.
Let’s look at an example. In the following, lessThan is a Boolean variable, and i and j are
int variables:
Description
By comparing two values, we assert that a relationship (such as “less than”) exists between
them. If the relationship does exist, the assertion is true; if not, it is false. We can test for the
following relationships in C++:
Operator
Relationship Tested
==
Equal to
!=
Not equal to
>
Greater than
<
Less than
>=
Greater than or equal to
<=
Less than or equal to
An expression followed by a relational operator followed by an expression is called a
relational expression. The result of a relational expression is of type bool. For example, if x is
5 and y is 10, the following expressions all have the value true:

Description
If x is the character 'M' and y is 'R', the values of the expressions are still true because the
relational operator <, when used with letters, means “comes before in the alphabet” or, more
properly, “comes before in the collating sequence of the character set.” For example, in the
widely used ASCII character set, all of the uppercase letters are in alphabetical order, as are
the lowercase letters, but all of the uppercase letters come before the lowercase letters. So
Description
and
Description
have the value true, but
Description
has the value false.
Of course, we have to be careful about data types when we compare things. The safest
approach is to always compare ints with ints, floats with floats, chars with chars, and so
on. If you mix data types in a comparison, implicit type coercion takes place, just as it does in
arithmetic expressions. If an int value and a float value are compared, the computer
temporarily coerces the int value to its float equivalent before making the comparison. As
with arithmetic expressions, it’s wise to use explicit type casting to make your intentions
known:
Description
If you compare a bool value with a numeric value (probably by mistake), the value false is
temporarily coerced to the number 0, and true is coerced to 1. Therefore, if boolVar is a bool
variable, the expression

Description
yields true because 0 and 1 are both less than 5.
Until you learn more about the char type in Chapter 10, be careful to compare char values
only with other char values. For example, the comparisons
Description
and
Description
are appropriate, but
Description
generates an implicit type coercion and a result that probably isn’t what you expect.
We can use relational operators not only to compare variables or constants, but also to
compare the values of arithmetic expressions. In the following table, we compare the results
of adding 3 to x and multiplying y by 10 for different values of x and y.
Description
Caution: It’s easy to confuse the assignment operator (=) and the == relational operator.
These two operators have very different effects in a program. Some people pronounce the
relational operator as “equals-equals” to remind themselves of the difference.
The following program shows the output from comparing five sets of integer values:

Description
Output from a test run:
Description
What are those 1s and 0s? C++ stores true as the value 1 and false as the value 0. Later in
the chapter, we will show you how to convert the numbers 1 and 0 to the words “true” and
“false”.
Comparing Strings
In C++, the string type is an example of a class—a type from which you declare variables
called objects. Recall that C++ is an object-oriented language. Within each string object is a
character string that you can compare using the relational operators. Syntactically, the
operands of a relational operator can either be two string objects, as in
Description
or a string object and a C string, as in

Description
However, both operands cannot be C strings.
Comparison of strings follows the collating sequence of the machine’s character set (ASCII,
for instance). When the computer tests a relationship between two strings, it begins with the
first character of each string, compares those characters according to the collating sequence,
and if they are the same repeats the comparison with the next character in each string. The
character-by-character test proceeds until either a mismatch is found or the final characters
have been compared and are equal. If all their characters are equal, then the two strings are
equal. If a mismatch is found, then the string with the character that comes before the other is
the “lesser” string.
For example, given the statements
Description
the relational expressions in the following table have the indicated values.
Expression
Value
Reason
word1 == word2
false
They are unequal in the first character.
word1 = word2
true
‘T’ comes after ‘S’ in the collating sequence.
word1 < “Tremble” false
Fifth characters don’t match, and ‘b’ comes before ‘e’.
word2 == “Small”
true
They are equal.
“cat“ < “dog”
Unpredictable The operands cannot both be C strings.2
In most cases, the ordering of strings corresponds to alphabetical ordering; however, when
strings have mixed-case letters, we can get nonalphabetical results. For example, in a
contacts list we expect to see Macauley before MacPherson, but in the ASCII collating
sequence, all the uppercase letters come before the lowercase letters, so the string
"MacPherson" compares as less than "Macauley" because "P" is less than "c". To compare
strings for strict alphabetical ordering, all the characters must be in the same case.2 The
toupper and tolower functions will provide a way to convert strings to the same case, once we
introduce looping in Chapter 6.
If two strings with different lengths are compared and the comparison is equal up to the end
of the shorter string, then the shorter string compares as less than the longer string. For
example, if word2 contains "Small", the expression
Description

yields true, because the strings are equal up to their fifth character position (the end of the
string on the left), and the string on the right is longer.
QUICK CHECK
5.2.1 What are the two values that are the basis for Boolean logic?
5.2.2 Write a Boolean expression that is true when the value of the variable
temperature is greater than 32.
5.2.3 In C++, how many values does the bool data type consist of?
5.2.4 What is a logical expression made up of?
5.2.5 What are possible values for x and y such that the following Boolean expression
evaluates to false?
Description
1 The word Boolean is a tribute to George Boole, a nineteenth-century English mathematician
who described a system of logic using variables with just two values: true and false. (See the
“May We Introduce” feature later in this chapter.)
2 The expression is syntactically legal in C++ but results in a pointer comparison, not a string
comparison. Pointers are not discussed until Chapter 10.

5.3 The If Statement
Now let’s see how to use logical expressions to alter the flow of control in a program. The If
statement is a control structure that allows us to ask a question and choose a course of
action: If a certain condition exists, then perform one action, else perform a different action.
At run time, the computer performs just one of the two actions, depending on the result of
the condition being tested. Notice how we must include the code for both actions in the
program, because, depending on the circumstances, the computer can choose to execute
either of them.
The If-Then-Else Form
In C++, the If statement comes in two forms: the If-Then-Else form and the If-Then form.
Let’s look first at the If-Then-Else. Here is its syntax template:
Description
The expression in parentheses can be of any simple data type. Almost without exception, it
will be a logical (Boolean) expression; if not, its value is implicitly coerced to type bool. At run
time, the computer evaluates the expression. If the value is true, the computer executes
Statement1A. If the value of the expression is false, it executes Statement1B. Statement1A
often is called the then-clause; Statement1B, the else-clause. FIGURE 5.3 illustrates the flow
of control of the If-Then-Else. In the figure, Statement2 is the next statement in the program
after the entire If statement.
Notice that a C++ If statement uses the reserved words if and else but does not include
the word then. We use the term If-Then-Else because it corresponds to how we say things in
English: “If something is true, then do this, else do that.”
The following is an example If statement in a program. Observe the indentation of the then-
clause and the else-clause, which makes the statement easier to read. Also notice the
placement of the statement following the If statement.

Description
This code effectively says, “If hours is less than or equal to 40.0, compute the regular pay and
then go on to execute the output statement. But if hours is greater than 40, compute the
regular pay and the overtime pay, and then go on to execute the output statement.” FIGURE
5.4 shows the flow of control of this If statement.
FIGURE 5.3 If-Then-Else Flow of Control
Description

FIGURE 5.4 Flow of Control for Calculating Pay
Description
If we want to check the validity of input, the If-Then-Else is a natural choice. For example,
before we ask the computer to divide by a data value, we should make sure the value is not
zero. If the divisor is zero, our program should display an error message. Here’s the code:
Description
As another example of an If-Then-Else, suppose we want to determine where in a string
variable the first occurrence (if any) of the letter A is located and the first occurrence (if any) of
the letter B. The string class has a member function named find, which returns the position
where the item was found (or the named constant string::npos if the item wasn’t found). The
following program outputs the result of such a search, including one that succeeds and one
that doesn’t.
Description

Here is the result of running the program:
Description
Notice that, according to the If-Then-Else syntax template, the If statement doesn’t end with
a semicolon. In the program fragments we have seen so far, however, there seems to be a
semicolon at the end of each If statement. Actually, these semicolons belong to the
statements in the else-clauses. If the If statement required a semicolon of its own, we would
often be forced to write two semicolons in a row.
Blocks (Compound Statements)
In our division-by-zero example, suppose that when the divisor is zero we want to both
display the error message and set the variable named result equal to a special value like
9999. We would need two statements in the same branch, but the syntax template seems to
limit us to one.
What we really want to do is turn the else-clause into a sequence of statements. This is
easy. The compiler treats the block (compound statement)
Description
like a single statement. If you put a { } pair around the sequence of statements you want in a
branch of the If statement, the sequence of statements becomes a single block. For example:

Description
If the value of divisor is 0, the computer both displays the error message and sets the
value of result to 9999 before continuing with whatever statement follows the If statement.
Blocks can be used in both branches of an If-Then-Else, as shown in the following program.
Description
Here is an example that succeeds:

Description
Here is one in which the division fails:
Description
If statements don’t end with semicolons and blocks don’t end with semicolons, so
remember: Never use a semicolon after the right brace of a block. Semicolons only terminate
simple statements such as assignment, input, and output statements.
MATTERS OF STYLE Braces and Blocks
C++ programmers use different styles when it comes to locating the left brace of a block.
The style we use in this text puts the left and right braces directly below the words if and
else, with each brace appearing on its own line:
Description
Another popular style is to place the left braces at the end of the if line and the else line;
the right braces still line up directly below the words if and else. This way of formatting the
If statement originated with programmers using the C language, the predecessor of C++.

Description
It makes no difference to the C++ compiler which style you use (and there are other
styles as well). It’s a matter of personal preference. Whichever style you use, though, you
should always use the same style throughout a program. Inconsistency can confuse the
person reading your program and give the impression of carelessness.
The If-Then Form
Sometimes you run into a situation where you want to say, “If a certain condition exists, then
perform some action; otherwise, don’t do anything.” In other words, you want the computer to
skip a sequence of instructions if a certain condition isn’t met. You could do this by leaving the
else branch empty, using only the null statement:
Description
Better yet, you can simply leave off the else part. The resulting statement is the If-Then
form of the If statement. This is its syntax template:
Description
Here’s an example of an If-Then. Notice the indentation and the placement of the statement
that follows the If-Then.

Description
This statement means that if age is less than 18, first output “Not an eligible ” and then output
“voter.” If age is not less than 18, skip the first output statement and go directly to output
“voter.” FIGURE 5.5 shows the flow of control for an If-Then statement.
Of course, the branch in an If-Then can be a block. For example, suppose you are writing a
program to compute income taxes. One of the lines on the tax form reads “Subtract line 23
from line 17 and enter result on line 24; if result is less than zero, enter zero and check box
24A.” You can use an If-Then to do this in C++:
Description
FIGURE 5.5 If-Then Flow of Control
Description

This code does exactly what the tax form says it should: It computes the result of subtracting
line 23 from line 17. Then it looks to see if result is less than 0. If it is, the fragment displays a
message telling the user to check box 24A and then sets result to 0. Finally, the calculated
result (or 0, if the result is less than 0) is stored into a variable named line24.
What happens if we leave out the left and right braces in the code fragment? Let’s look at it:
Description
Despite the way we have indented the code, the compiler takes the then-clause to be a
single statement—the output statement. If result is less than 0, the computer executes the
output statement, then sets result to 0, and then stores result into line24. So far, so good.
But if result is initially greater than or equal to 0? Then the computer skips the then-clause
and proceeds to the statement following the If statement—the assignment statement that sets
result to 0. Either way, result ends up as 0, regardless of its initial value!
The moral here is not to rely on indentation alone. If you want a compound statement for a
then- or else-clause, you must include the left and right braces.
A Common Mistake
Earlier we warned against confusing the = operator with the == operator. Here is an example of
a mistake that every C++ programmer is guaranteed to make at least once in their career:
Description
This code segment always outputs
Description
no matter what was input for n.
Here is the reason: The expression n = 3 is not a logical expression; it’s an assignment
expression. (Writing an assignment expression as a separate statement ending with a
semicolon turns it into an assignment statement.) An assignment expression has a value
(here, it’s 3) and a side effect (storing 3 into n). In the If statement of our example, the

computer finds the value of the tested expression to be 3. Because 3 is a nonzero value, it is
thus coerced to true, and the then-clause is executed, no matter what the value of n is. Worse
yet, the side effect of the assignment expression is to store 3 into n, destroying what was
there.
Our intention is not to focus on assignment expressions. What’s important now is that you
see the effect of using = when you meant to use ==. The program compiles correctly but runs
incorrectly. When debugging a faulty program, always look at your If statements to see
whether you’ve made this particular mistake.
SOFTWARE MAINTENANCE CASE STUDY Incorrect Output
MAINTENANCE TASK: To help your parents with their mortgage loan, you wrote a
program to determine the monthly payments given the amount to be borrowed, the interest
rate, and the number of years. You gave the same program to a friend to use when she
was buying a car. She says that the program gives very strange results. You ask for an
example of the erroneous output. She said it gave a ridiculously high payment for an
amount of $3000 for 2 years at an interest rate of 6.8%.
VERIFYING THE BEHAVIOR: Whenever a user reports a bug, you should begin by
making sure that you can generate the reported behavior yourself. This sets up the
necessary conditions for isolating the problem and testing your modifications. You run the
program using the data your friend supplied and the answers seem reasonable.
Description
Because you can’t get the program to exhibit the bug, you go back to your friend to ask
more questions. (Remember, that’s one of our problem-solving strategies, and they apply
just as much to debugging as to writing new applications.) “What sort of ridiculously high
payment did you get?” you ask her. Your friend says that she got 1700.0355647311262 as
the payment amount. Clearly, $1700.03 per month for 2 years is not correct. What could
have gone wrong?
Just as a mechanic may have to go for a drive with a car’s owner to understand what’s
wrong, sometimes you have to sit and watch a user run your application. You ask your
friend to show you what happened. Here’s what she did:
Description

Aha! You wrote the code to read the interest rate as a decimal fraction, and she is entering
it as a percentage! There’s an easy solution to this problem. You can tell her to enter the
interest rate as a decimal fraction, and you won’t have to change the code at all. Such a
“fix” is known as a workaround.
She can do this, but says, “It’s annoying to have to do the math in my head. Why can’t
you fix the program so that it takes the percentage the way that people normally write it?”
She has a good point. As a programmer, you wrote the code in a way that made it easier
for you. But a good application should be designed to make it easier for the user, which is
what we mean by user friendly. If other people will be using your application, you must
think in those terms.
So you have to change the program to first divide the input percentage by 100. But then
you remember that you’ve also given the program to a friend who is a math major and who
prefers to enter percentages as decimal fractions. The program could ask the user for their
preference, but again, that’s more work for the user. What to do? How to accommodate
both kinds of users with the least hassle?
Obviously, there has to be a branch somewhere in the application that chooses between
dividing the percentage by 100 and using it as entered. Interest rates on loans are
generally no more than about 25% and no less than 0.25%. So we could simply say that
any number greater than or equal to 0.25 is assumed to be a percentage, and any number
less than that is a decimal fraction. Thus, the necessary If statement would be written as
follows:
Description
Is that the only change? That’s all that’s required to make the program do the proper
calculations. However, your friend indicated that it would be nice to have a version that
used the keyboard for input and output rather than files. Let’s make this version use
keyboard input and output and include our assumptions in the input prompts.
MODIFIED CODE: You call up the file with your source code so that you can modify it.
You also refamiliarize yourself with the compound interest formula:
Description
You then insert the revised input and output and the If statement. The changes are
highlighted in the code below.

Description

Here is the output from two test runs of the application, one with data entered as a
percentage and one with data entered as a decimal:
Description

Description
QUICK CHECK
5.3.1 Write an If-Then-Else statement that uses the test from Question 5.2.2 to output
either “Above freezing.” or “Freezing or below.”
5.3.2 Why must we provide code for both actions of an If statement?
5.3.3 What data type must the expression in parentheses of an If statement evaluate
to?

5.4 Nested If Statements
There are no restrictions on what the statements in an If can be. Therefore, an If within an If is
okay. In fact, an If within an If within an If is legal. The only limitation here is that it’s hard to
follow a structure that is too involved, and readability is one measure of a good program.
Description
When we place an If within an If, we are creating a nested control structure. Control
structures nest much like mixing bowls do, with smaller ones tucked inside larger ones.
Here’s a pseudocode example:
When a problem that involves a multiway branch (more than two alternative courses of
action) it can be coded using nested If statements. For example, to output the name of a
month given its number, we could use a sequence of If statements (unnested):
Description
But the equivalent nested If structure,

Description
is more efficient because it makes fewer comparisons. The first version always tests all 12
month numbers, even if the month is January. In contrast, the nested If skips the remaining
tests after one has been selected. As fast as modern computers are, many applications
require so much computation that inefficient algorithms can waste hours of computer time.
Always be on the lookout for ways to make your programs more efficient, as long as doing so
doesn’t make them hard to understand. It’s usually better to sacrifice a little efficiency for
readability.
In the last example, notice how the indentation of the then- and else-clauses causes the
statements to keep stepping to the right. Alternatively, we can use a special indentation style
with nested If-Then-Else statements to indicate that the structure is just choosing one of a set
of alternatives. This general multiway branch is known as an If-Then-Else-If control structure:
Description
This style prevents the indentation from marching continuously to the right, and it visually
conveys that we are using a 12-way branch based on the variable month.

There is one important difference between the sequence of If statements and the nested If:
More than one alternative can be taken by the sequence of Ifs, but the nested If can select
only one option. To appreciate this distinction, consider the analogy of filling out an online form.
Some questions are like a sequence of If statements, asking you to click on all the items in a
list that apply to you (such as your hobbies). Other questions have you select one item in a
list (your age group, for example) and are thus like a nested If structure. Both kinds of
questions occur in programming problems. Being able to recognize these different situations
helps you to select the appropriate control structure.
Another use of the nested If is selecting from a series of consecutive ranges of values. For
example, suppose that we want to display out an appropriate activity for the outdoor
temperature, given the following information:
Activity
Temperature
Swimming
temperature > 85
Tennis
70 < temperature <= 85
Golf
32 < temperature <= 70
Skiing
0 < temperature <= 32
Dancing
indoors temperature <= 0
At first glance, you may be tempted to write a separate If statement for each range of
temperatures. On closer examination, however, it is clear that if one of the If statements is
executed, the remainder can be skipped. We are really selecting one alternative from a set of
possibilities—just the sort of situation in which we can use a nested If structure. The only
difference between this problem and our earlier example is that we check ranges of numbers
in the If expressions of the branches.
When the ranges are consecutive, we can take advantage of that fact to make our code
more efficient. We arrange the branches in consecutive order by range. Then, if a particular
branch has been reached, we know that the preceding ranges have been eliminated from
consideration. Thus the If expressions must compare the temperature to only the lowest value
of each range. To see how this works, look at the following Activity program.
Description

To understand how the If-Then-Else-If structure in this program works, consider the branch
that tests for temperature greater than 70. If it has been reached, we know that temperature
must be less than or equal to 85 because that condition causes this particular else branch to
be taken. Thus we need to test only whether temperature is above the bottom of this range (>
70). If that test fails, then we enter the next else-clause knowing that temperature must be less
than or equal to 70. Each successive branch checks the bottom of its range until we reach the
final else, which takes care of all the remaining possibilities.
If the ranges aren’t consecutive, however, we must test the data value against both the
highest and lowest values of each range. We still use an If-Then-Else-If because that is the
best structure for selecting a single branch from multiple possibilities, and we may arrange the
ranges in consecutive order to make them easier for a human reader to follow. In such a
case, there is no way to reduce the number of comparisons when there are gaps between the
ranges.
The Dangling else
When If statements are nested, you may find yourself confused about the if-else pairings;
that is, to which if does an else belong? For example, suppose that if a student’s average is
below 60, we want to output “Failing”; if the average is at least 60 but less than 70, we want to
output “Passing but marginal”; and if it is 70 or greater, we don’t want to output anything. We
code this information with an If-Then-Else nested within an If-Then:

Description
How do we know to which if the else belongs? Here is the rule that the C++ compiler
follows: In the absence of braces, an else is always paired with the closest preceding if that
doesn’t already have an else paired with it. We indented the code to reflect this pairing.
Suppose we write the fragment like this:
Description
Here we want the else branch attached to the outer If statement, not the inner If, so we indent
the code as you see it. Of course, indentation does not affect the execution of the code. Even
though the else aligns with the first if, the compiler pairs it with the second if. An else that
follows a nested If-Then is called a dangling else. It doesn’t logically belong with the nested If
but is attached to it by the compiler.
To attach the else to the first if, not the second, you can turn the outer then-clause into a
block:
Description
The { } pair indicates that the inner If statement is complete, so the else must belong to the
outer if.
QUICK CHECK
5.4.1 What purpose does a nested branch serve?
5.4.2 Write nested If statements to output messages indicating whether a temperature
is below freezing, freezing, above freezing but not boiling, or boiling and above.

5.4.3 What type of control structure do we have when an If statement is within another
If statement?
5.4.4 What type of branching control structure is used when we have many (more
than two) alternative courses of action?
5.4.5 What problem does a C++ compiler solve using the rule: In the absence of
braces, an else is always paired with the closest preceding if that doesn’t already
have an else paired with it.

5.5 Logical Operators
In mathematics, the logical (or Boolean) operators AND, OR, and NOT take logical
expressions as operands. C++ uses special symbols for the logical operators: && (for AND),
|| (for OR), and ! (for NOT). By combining relational operators with logical operators, we can
make more complex assertions. For example, in the previous section we used two If
statements to determine if an average was greater than 60.0 but less than 70.0. In C++, we
would write the expression this way:
Description
The AND operation (&&) requires both relationships to be true for the overall result to be true. If
either or both of the relationships are false, the entire result is false.
The OR operation (||) takes two logical expressions and combines them. If either or both
are true, the result is true. Both values must be false for the result to be false. For example,
we can determine whether the midterm grade is an A or the final grade is an A. If either grade
equals A, the assertion is true. In C++, we write the expression like this:
Description
The && and || operators always appear between two expressions; they are binary (two-
operand) operators. The NOT operator (!) is a unary (one-operand) operator. It precedes a
single logical expression and gives its opposite as the result. If (grade == 'A') is false, then !
(grade == 'A') is true. NOT gives us a convenient way of reversing the meaning of an
assertion. For example,
Description
is the equivalent of
Description
In some contexts, the first form is clearer; in others, the second makes more sense.
The following pairs of expressions are equivalent:
Expression
Equivalent Expression
!(a == b)
a != b
!(a == b || a == c)
a != b && a != c

!(a == b && c > d)
a != b || c <= d
Take a close look at these expressions to be sure you understand why they are equivalent.
Try evaluating them with some values for a, b, c, and d. Notice the pattern: The expression on
the left is just the one to its right with ! added and the relational and logical operators reversed
(for example, == instead of != and || instead of &&). Remember this pattern. It allows you to
rewrite expressions in the simplest form.3
Logical operators can be applied to the results of comparisons. They can also be applied
directly to variables of type bool. For example, instead of writing
Description
to assign a value to the Boolean variable isElector, we could use two intermediate Boolean
variables, isVoter and isConstituent:
Description
The following two tables summarize the results of applying && and || to a pair of logical
expressions (represented here by Boolean variables x and y).
Value of x
Value of y
Value of x && y
true
true
true
true
false
false
false
true
false
false
false
false
Value of x
Value of y
Value of x || y
true
true
true
true
false
true
false
true
true
false
false
false
The following table summarizes the results of applying the ! operator to a logical expression
(represented by Boolean variable x):
Value of x
Value of !x
true
false

false
true
Technically, the C++ operators !, &&, and || are not required to have logical expressions as
operands. Their operands can be of any simple data type, even floating-point types. If an
operand is not of type bool, its value is temporarily coerced to type bool as follows: A 0 value
is coerced to false, and any nonzero value is coerced to true. As an example, you
sometimes encounter C++ code that looks like this:
Description
The assignment statement says to set badData to true if the coerced value of height is false;
that is, the statement is really saying, “Set badData to true if height equals 0.0.” Although this
assignment statement works correctly in the C++ language, the following statement is more
readable:
Description
Throughout this text we apply the logical operators only to logical expressions, not to
arithmetic expressions.
Caution: It’s easy to confuse the logical operators && and || with two other C++ operators, &
and |. We don’t discuss the & and | operators here, but we’ll tell you that they are used for
manipulating individual bits within a memory cell—a role quite different from that of the logical
operators. If you accidentally use & instead of &&, or | instead of ||, you won’t get an error
message from the compiler, but your program probably will compute wrong answers. Some
programmers pronounce && as “and-and” and || as “or-or” to avoid making mistakes.
The preceding assignment statement can also be implemented using an If statement; that
is,
Description
can be implemented as

Description
As you can see, the first form is simpler to write and, with a little practice, is easier to read.
The following application sets the Boolean variables walk, movie, and book to true or false
depending on what the temperature is and whether it is raining. An If statement is then used to
output the results.
Description

Following are the results of running the program on four different sets of input:

Description
Short-Circuit Evaluation
Consider the logical expression
Description
Some programming languages use full evaluation of logical expressions. With full evaluation,
the computer first evaluates both subexpressions (both i == 1 and j > 2) before applying the
&& operator to produce the final result.
In contrast, C++ uses short-circuit (or conditional) evaluation of logical expressions.
Evaluation proceeds from left to right, and the computer stops evaluating subexpressions as
soon as possible—that is, as soon as it knows the Boolean value of the entire expression.
How can the computer know if a lengthy logical expression yields true or false if it doesn’t
examine all the subexpressions? Let’s look first at the AND operation.
Short-circuit (conditional) evaluation Evaluation of a logical expression in left-to-right
order, with evaluation stopping as soon as the final truth value can be determined.
An AND operation yields the value true only if both of its operands are true. In the earlier
expression, suppose that the value of i happens to be 95. The first subexpression yields
false, so it isn’t necessary even to look at the second subexpression. The computer stops
evaluation and produces the final result of false.
With the OR operation, the left-to-right evaluation stops as soon as a subexpression
yielding true is found. Remember that an OR produces a result of true if either one or both of
its operands are true. Suppose we have this expression:

Description
If the first subexpression is true, evaluation stops and the entire result is true. The computer
doesn’t waste time with an unnecessary evaluation of the second subexpression.
MAY WE INTRODUCE George Boole
Boolean algebra is named for its inventor, English mathematician George Boole, who was
born in 1815. His father, a tradesman, began teaching George mathematics at an early
age, but Boole initially was more interested in classical literature, languages, and religion—
interests he maintained throughout his life. By the time he was 20, he had taught himself
French, German, and Italian. He was well versed in the writings of Aristotle, Spinoza,
Cicero, and Dante, and wrote several philosophical papers himself.
At 16, to help support his family, Boole took a position as a teaching assistant in a
private school. His work there and a second teaching job left him little time to study. A few
years later, he opened a school and began to learn higher mathematics on his own. In
spite of his lack of formal training, his first scholarly paper was published in the Cambridge
Mathematical Journal when he was just 24. Boole went on to publish more than 50 papers
and several major works before he died in 1864, at the peak of his career.
Boole’s The Mathematical Analysis of Logic was published in 1847. It would eventually
form the basis for the development of digital computers. In the book, Boole set forth the
formal axioms of logic (much like the axioms of geometry) on which the field of symbolic
logic is built.
Boole drew on the symbols and operations of algebra in creating his system of logic. He
associated the value 1 with the universal set (the set representing everything in the
universe) and the value 0 with the empty set, and restricted his system to these two
quantities. He then defined operations that are analogous to subtraction, addition, and
multiplication. Variables in the system have symbolic values. For example, if a Boolean

variable P represents the set of all plants, then the expression 1 – P refers to the set of all
things that are not plants. We can simplify the expression by using – P to mean “not
plants.” (0 – P is simply 0 because we can’t remove elements from the empty set.) The
subtraction operator in Boole’s system corresponds to the ! (NOT) operator in C++. In a
C++ program, we might set the value of the Boolean variable plant to true when the name
of a plant is entered, whereas !plant is true when the name of anything else is input.
The expression 0 + P is the same as P. However, 0 + P + F, where F is the set of all
foods, is the set of all things that are either plants or foods. So the addition operator in
Boole’s algebra is the same as the C++ || (OR) operator.
The analogy can be carried to multiplication: 0 × P is 0, and 1 × P is P. But what is P × F
? It is the set of things that are both plants and foods. In Boole’s system, the multiplication
operator is the same as the && (AND) operator.
In 1854, Boole published An Investigation of the Laws of Thought, on Which Are
Founded the Mathematical Theories of Logic and Probabilities. In the book, he described
theorems built on his axioms of logic and extended the algebra to show how probabilities
could be computed in a logical system. Five years later, Boole published Treatise on
Differential Equations, and then Treatise on the Calculus of Finite Differences. The latter
book is one of the cornerstones of numerical analysis, which deals with the accuracy of
computations. (In Chapter 10, we examine the important role numerical analysis plays in
computer programming.)
Boole received little recognition and few honors for his work. Given the importance of
Boolean algebra in modern technology, it is hard to believe that his system of logic was not
taken seriously until the early twentieth century. George Boole was truly one of the
founders of computer science.
Precedence of Operators
In Chapter 3, we discussed the rules of precedence—the rules that govern the evaluation of
complex arithmetic expressions. C++’s rules of precedence govern not only complex
arithmetic expressions, but also govern relational and logical operators. Here’s a list showing
the order of precedence for the arithmetic, relational, and logical operators (with the
assignment operator thrown in as well):
Description

Operators on the same line have the same precedence. If an expression contains several
operators with the same precedence, most of the operators group (or associate) from left to
right. For example, the expression
Description
means (a / b) * c, not a / (b * c). However, the unary operators (!, unary +, unary -)
group from right to left. Although you’d never want to use this expression,
Description
its meaning is !(!badData) rather than the meaningless (!!)badData. Appendix B,
“Precedence of Operators,” lists the order of precedence for all operators in C++. In the
appendix, you can see a few more operators that associate from right to left (for similar
reasons).
Parentheses override the precedence rules in evaluating an expression. If you’re not sure if
parentheses are needed, use them anyway. The compiler disregards unnecessary
parentheses. So, if they clarify an expression, use them. Some programmers like to use
parentheses when assigning a relational expression to a Boolean variable:
Description
The parentheses aren’t needed here; assignment has lower precedence than ==. So we could
just write
Description
But because If statements require their logical expressions to be enclosed in parentheses, the
parenthesized version is a signal that the expression gives a logical result.
One final comment about parentheses: C++ requires them to be used in pairs. Whenever
you write a complicated expression, take a minute to check that all of the opening
parentheses have closing counterparts.
SOFTWARE ENGINEERING TIP Changing English Statements
into Logical Expressions
In most cases, you can write a logical expression directly from an English statement or
mathematical term in an algorithm; however, you have to watch out for some tricky
situations. Remember our sample logical expression:

Description
In English, you would be tempted to write this expression: “Midterm grade or final grade
equals A.” In C++, you can’t write the expression as you would in English; that is,
Description
won’t work because the || operator is connecting a char value (midtermGrade) and a
logical expression (finalGrade == 'A'). The two operands of || should be logical
expressions. (Note that this expression is wrong in terms of what it does, but it isn’t
“wrong” to the C++ compiler. Recall that the || operator may connect two expressions of
any data type, so this example won’t generate an error message. The program will run, but
it won’t work the way you intended.)
A variation of this mistake is to express the English assertion “i equals either 3 or 4” as
follows:
Description
Again, the syntax is correct but the semantics are not. This expression always evaluates
to true. The first subexpression, i == 3, may be true or false. But the second
subexpression, 4, is nonzero and, therefore, is coerced to the value true. Thus the ||
operator causes the entire expression to be true. We repeat: Use the || operator (and the
&& operator) only to connect two logical expressions. Here’s what we want:
Description
In math books, you might see a notation like this:
Description
which means “y is between 12 and 24.” This expression is legal in C++ but gives an
unexpected result. First, the relation 12 < y is evaluated, giving the result true or false.
The computer then coerces this result to 1 or 0 to compare it with the number 24. Because
both 1 and 0 are less than 24, the result is always true. Another way to read the math
notation is that “12 is less than y and y is less than 24.” Thus, to write this expression
correctly in C++, you must use the && operator as follows:

Description
Relational Operators with Floating-Point Types
So far, we’ve talked about comparing int, char, and string values. Here we look at float
values.
Do not compare floating-point numbers for equality. Because small errors in the rightmost
decimal places are likely to arise when calculations are performed on floating-point numbers,
two float values rarely are exactly equal. For example, consider the following code that uses
two float variables named oneThird and x:
Description
We would expect x to contain the value 1.0, but it probably doesn’t. The first assignment
statement stores an approximation of 1/3 into oneThird, perhaps 0.333333. The second
statement stores a value like 0.999999 into x. If we now ask the computer to compare x with
1.0, the comparison yields false.
Instead of testing floating-point numbers for equality, we test for near equality. To do so, we
compute the difference between the two numbers and test whether the result is less than
some maximum allowable difference. For example, we often use comparisons like this:
Description
where fabs is the floating-point absolute value function from the C++ standard library. The
expression fabs(r – s) computes the absolute value of the difference between two float
variables r and s. If the difference is less than 0.00001, the two numbers are close enough to
call them equal.
QUICK CHECK
5.5.1 What are the C++ Boolean operators that correspond to the logical operators
AND, OR, and NOT?
5.5.2 Write an equivalent Boolean expression for (a != b && c < d) that uses the
operators == and >= and !.
5.5.3 Write a single assignment statement that corresponds to the following If
statement (assuming that grade is type float and failed is type bool):
5.5.4 In which direction is a logical expression evaluated in C++?
5.5.5 Write a Boolean expression such that it demonstrates short-circuit evaluation.
Highlight the part of the expression that is not executed.

Description
3 In Boolean algebra, the pattern is formalized by a theorem called De Morgan’s law.

5.6 Testing the State of an I/O Stream
In Chapter 4, we talked about input and output streams in C++. Part of that discussion
introduced the classes istream, ostream, ifstream, and ofstream. Recall that any of the
following can cause an input stream to enter the fail state:
Invalid input data
An attempt to read beyond the end of a file
An attempt to open a nonexistent file for input
C++ provides a way to check whether a stream is in the fail state. In a logical expression,
you simply use the name of the stream object (such as cin) as if it were a Boolean variable:
Description
This is called testing the state of the stream. The result of the test is either true (meaning
the last operation on that stream succeeded) or false (meaning some preceding operation
caused the stream to enter the fail state). Think of a stream object in a logical expression as
being a Boolean variable with a value true (the stream state is okay) or false (the state isn’t
okay).
Testing the state of a stream The act of using a C++ stream object in a logical
expression as if it were a Boolean variable; the result is true if the last I/O operation on that
stream succeeded, and false otherwise.
In an If statement, the way you phrase the logical expression depends on what you want
the then-clause to do. The statement

Description
executes the then-clause if the last I/O operation on inFile succeeded. The statement
Description
executes the then-clause if inFile is in the fail state.
Here’s an example that shows how to check whether an input file was opened successfully:
Description
In this program, we begin by attempting to open the file measures.dat for input. Immediately,
we check whether the attempt succeeded. If it was successful, the value of the expression
!inFile in the If statement is false and the then-clause is skipped. The program proceeds to
read data from the file and then perform a computation. It concludes by executing the
statement

Description
With this statement, the main function returns control to the operating system. Recall that the
function value returned by main is known as the exit status. The value 0 signifies normal
completion of the program. Any other value (typically 1, 2, 3, . . .) means that something went
wrong.
Let’s trace through the program again, assuming we weren’t able to open the input file.
Upon return from the open function, the stream inFile is in the fail state. In the If statement,
the value of the expression !inFile is true. Thus the then-clause is executed. The program
displays an error message to the user and then terminates, returning an exit status of 1 to
inform the operating system of an abnormal termination. (Our choice of the value 1 for the exit
status is purely arbitrary. Programmers sometimes use several different values in a program
to signal different reasons for program termination, but most people just use the value 1.)
Whenever you open a data file for input, be sure to test the stream state before proceeding.
If you forget to do so, and the computer cannot open the file, your program quietly continues
executing and ignores any input operations on the file.
QUICK CHECK
5.6.1 Write an If statement that tests whether the standard input stream is in the fail
state.
5.6.2 What terminology is used when you are trying to determine whether a stream is
in the fail state?
5.6.3 What happens if you do not test the state of a file input stream before using it?
Problem-Solving Case Study
BMI CALCULATOR
PROBLEM: A great deal has been said about how overweight much of the American
population is today. Rather than looking at a chart that shows the average weight for a
particular height, a measure called the body mass index (BMI), which computes a ratio of
your weight and height, has become a popular tool to determine an appropriate weight. The
formula for nonmetric values is
Description
BMI correlates with the amount of body fat, which can be used to determine whether a
weight is unhealthy for a certain height.

The BMI formula was developed by Adolphe Quetelet, a nineteenth-century Belgian
statistician. Do a search of the Internet for “body mass index” and you will find more than a
million hits. In these references, the formula remains the same but the interpretation of the
result varies, depending upon age and gender. Here is the most commonly used generic
interpretation:
BMI
Interpretation
< 20
Underweight
20–25
Normal
26–30
Overweight
> 30
Obese
Write a program that calculates the BMI given a weight and height and displays an
appropriate message.
INPUT: The problem statement says that the formula is for nonmetric values, so the
weight is in pounds and the height is in inches. Thus the input should be two float values:
weight and height.
OUTPUT:
Prompts for the input values
A message based on the BMI
DISCUSSION: To calculate BMI, you read in the weight and height and plug them into the
formula. If you square the height, you must include <cmath> to access the pow function. It is
more efficient to just multiply height by itself.
Description
If you were calculating this index by hand, you would probably notice if the weight or
height were negative and question it. If the semantics of your data imply that the values
should be nonnegative, then your program should test each value and use a Boolean
variable to report the results. Here is the main module for this algorithm.
Main
Level 0
Test data
IF data are okay
Calculate BMI
Display message indicating status
ELSE
Display “Invalid data; weight and height must be positive.”
Which of these steps require expansion? Get data, Test data, and Display message
indicating status all require multiple statements to solve their particular subproblem. By
contrast, we can translate Display “Invalid data; . . .” directly into a C++ output statement.
What about the step Calculate BMI? We can write it as a single C++ statement, but there’s

another level of detail that we must fill in—the actual formula to be used. Because the
formula is at a lower level of detail than the rest of the main module, we choose to expand
Calculate BMI as a Level 1 module.
Get Data
Level 1
Prompt for weight
Read weight
Prompt for height
Read height
Test Data
IF weight < 0 OR height < 0
Set dataAreOk to false
ELSE
Set dataAreOk to true
Calculate BMI
Set bodyMassIndex to weight * 703 / (height * height)
Display Message Indicating Status
Display Message Indicating Status
The problem doesn’t say exactly what the message should be, other than reporting the
status. Why not jazz up the output a little by including an appropriate message along with
the status.
Status
Message
Underweight
Have a milkshake.
Normal
Have a glass of milk.
Overweight
Have a glass of iced tea.
Obese
See your doctor.
Display “Your body mass index is ”, bodyMassIndex, “.”
Display “Interpretation and instructions.”
IF bodyMassIndex <20
Display “Underweight: Have a milkshake.”
ELSE IF bodyMassIndex <= 25
Display “Normal: Have a glass of milk.”
ELSE IF bodyMassIndex <= 30
Display “Overweight: Have a glass of iced tea.”
ELSE
Display “Obese: See your doctor.”
MODULE STRUCTURE CHART

Description


Description
Here are outputs of runs with various heights and weights and with both good and bad
data.
Description
In this program, we use a nested If structure that is easy to understand although
somewhat inefficient. We assign a value to dataAreOK in one statement before testing it in

the next. We could reduce the code by writing
Description
Using De Morgan’s law, we also could write this statement as
Description
In fact, we could reduce the code even more by eliminating the variable dataAreOK and
using
Description
in place of
Description
To convince yourself that these three variations work, try them by hand with some test
data. If all of these statements do the same thing, how do you choose which one to use? If
your goal is efficiency, the final variation—the compound condition in the main If statement
—is the best choice. If you are trying to express as clearly as possible what your code is
doing, the longer form shown in the program may be the best option. The other variations
lie somewhere in between. (Some people would find the compound condition in the main If
statement to be not only the most efficient, but also the clearest to understand.) There are
no absolute rules to follow here, but the general guideline is to strive for clarity, even if you
must sacrifice a little efficiency.

Graphical User Interface (GUI)
This chapter focuses on control flow structures and how to use them to choose which parts of
the code to execute. For example, the BMI calculator accepts user input for weight and height
and uses If-Then-Else statements to either compute the body mass index and output an
interpretation of the result or report that the input was invalid. In this example, we will modify
the program to demonstrate how we can use GUI components to provide input that controls
execution of a program and see how GUI widgets can provide input validation to simplify our
programs.
Most modern programs interact with humans through a GUI. In our case study, the BMI
Calculator program has the user enter their weight and height using code like this:
Description
The Qt GUI library provides the components we need for this kind of interaction. Recall that
such components are known as dialogs. To access the Qt dialog library, we use this include
statement:
Description
Qt provides different dialogs for different kinds of user interaction. The BMI program
requires input to be a float rather than a string. The case study version does this by reading
from cin into a float variable. For our GUI version we can use a FloatDialog widget, which
allows the user to input a floating-point value. Thus, we can replace the stream variable
declarations with dialog object declarations as follows:
Description
The above declarations create two dialogs for accepting input for weight and height. We
then call the display() method on the FloatDialog objects to display them on the screen so

the user can type in floating-point values for their height and weight.
Description
The display() method causes the widget to appear on the screen, allowing the user to enter
weight and height, respectively. Here is what this looks like:
Description
Description
When the user presses the OK button for each widget, the value entered is returned and
stored into the corresponding float variable. We can then perform the same actions as the
previous version of the BMI program to determine if the user input is valid:

Description
As before, if the input is valid we would like to compute the body mass index and use that
value to give the user some helpful advice. However, this is a GUI application, so we want to
use a graphical widget to display the results. We need to change the original BMI program to
collect the output in a string and use the OutputDialog we saw in Chapter 4 to display the
results. The modified code looks like this:
Description
We first declare a new string called message that we will use to collect the output to the user.
The original BMI program used output streams to display the results. In this version we
replace each of the output operators with string concatenation to combine the body mass
index calculation and the interpretation into a single message string. Notice that we also use
the message variable to store a response to the user if the provided input is not valid. Lastly, we
use the message variable to create a new OutputDialog widget and display the final result to the
user:

Description
Here is the output if we enter a weight of 182.4 pounds and a height of 69.4 inches:
Description
Here is the complete GUI version of the BMI program. The sections pertaining to the Qt
GUI interface are shaded. Other than the GUI code, the only change to the code from the
case study is the introduction of the message variable for holding the output string and the use
of concatenation instead of stream output.


Description
Although this shows the use of some new GUI components, there is more that we can
achieve using a GUI. Many of the widgets in a framework such as Qt provide additional
capabilities to ensure that the data entered by a user are valid. For example, in the original
BMI program we test whether weight or height is less than zero after they are input. Wouldn’t it
be nice if our GUI widgets restricted the input values so we don’t need to perform these
checks in our code? The Qt framework can do this for us as part of the implementation of a
widget.
When we create a FloatDialog we can indicate what the acceptable input values are. The
dialog is given a string with the prompt for the user, for example, “Enter your weight in
pounds.” In addition, we can provide the starting value (a value initially displayed as the default
value), the minimum value, and the maximum value, in that order. Suppose we want to
restrict the range of input values to be 30 pounds as a minimum and 600 pounds as the
maximum, and set the starting value also to 30:
Description
The heightDialog can also be configured with sensible starting, minimum, and maximum
allowable height values:
Description
These additional parameters allow us to display dialogs that restrict the user input:
Description

Description
As you can see, both the weight and the height dialogs are displayed with their specified
starting units. Furthermore, if the user enters an input that is not within the specified range, the
GUI widget will disable the OK button:
Description
Because the test is done in a widget, we can remove the If-Then-Else statement checking if
the weight and height are appropriate. To complete this second GUI version of the BMI
program, and to show a new type of widget, we now introduce a component that allows us to
ask a yes/no type question that can be used in any conditional situation.
Some days, the user may not want to see the weight-loss suggestion. We can change our
application so that the user can ignore it for today (at least for when they run the program!).
We can have our BMI program ask the user if they want to calculate their BMI. If the user
chooses NO, we end the program; if they choose YES, we continue with asking them
questions about their height and weight.

Description
The new YesNoDialog component will display a GUI widget to ask the user for a yes or no
answer:
Description
As you can see in the code, the data type that is returned by the display() method is a bool
value. We can use this value in an If-Then-Else that will either execute the BMI GUI code or
display a message to the user. The final version of our code is as follows:

Description

Testing and Debugging
Testing is an integral part of the both the problem-solving and implementation phase of
computer programming. Here, we test both phases of the process used to develop the BMI
program. Testing in the problem-solving phase is done after the solution is developed but
before it is implemented. In the implementation phase, we do testing after the algorithm is
coded as a program and again after the program has compiled successfully. The compilation
itself constitutes another stage of testing that is performed automatically.
Testing in the Problem-Solving Phase: The Algorithm Walk-
Through
Determining Preconditions and Postconditions
To test during the problem-solving phase, we do a walk-through of the algorithm. For each
module in the functional decomposition, we establish an assertion called a precondition and
another called a postcondition. A precondition is an assertion that must be true before a
module is executed for the module to execute correctly. A postcondition is an assertion that
should be true after the module has executed, if it has done its job correctly. To test a module,
we “walk through” the algorithmic steps to confirm that they produce the required
postcondition, given the stated precondition.
Postcondition An assertion that must be true before a module begins executing.
Postcondition An assertion that should be true after a module has executed.
Our case study algorithm has five modules: the main module, Get Data, Test Data,
Calculate BMI, and Display Message Indicating Status. Usually there is no precondition for a
main module. Our main module’s postcondition is that it outputs the correct results, given the
correct input. More specifically, the postcondition for the main module is as follows:
The computer has input two real values into weight and height.
If the input is invalid, an error message has been displayed; otherwise, the body mass
index has been calculated and an appropriate message has been displayed based on the
result.
Because Get Data is the first module executed in the algorithm and because it does not
assume anything about the contents of the variables it is about to manipulate, it has no
precondition. Its postcondition is that it has input two real values into weight and height.
The precondition for module Test Data is that weight and height have been assigned
meaningful values. Its postcondition is that dataAreOK contains true if the values in weight and
height are nonnegative; otherwise, dataAreOK contains false.

The precondition for module Calculate BMI is that weight and height contain meaningful
values. Its postcondition is that the variable named bodyMassIndex contains the evaluation of
the BMI formula (weight * 703 / (height * height)).
The precondition for module Display Message Indicating Status is that bodyMassIndex
contains the result of evaluating the BMI formula. Its postcondition is that appropriate
documentation and the value in bodyMassIndex have been shown, along with the corresponding
message.
The module preconditions and postconditions are summarized in the following table. In the
table, we use AND with its usual meaning in an assertion—the logical AND operation. Also, a
phrase like “someVariable is assigned” is an abbreviated way of asserting that someVariable
has already been assigned a meaningful value.
Module Precondition
Postcondition
Main
Two float values have been input AND if the input is valid, the
BMI formula is calculated and the value is output with an
appropriate message; otherwise, an error message has been
output.
Get Data
weight and height have been input.
Test
Data
weight and height
are assigned
values.
dataAreOK contains true if weight and height are nonnegative;
otherwise, dataAreOK contains false.
Calculate
BMI
weight and height
are assigned
values.
bodyMassIndex contains the evaluation of the BMI formula.
Display
Message
bodyMassIndex
contains the
evaluation of the
BMI formula.
The value of bodyMassIndex has been output, along with a
message interpreting the value.
Performing the Algorithm Walk-Through
Now that we’ve established the preconditions and postconditions, we walk through the main
module. At this point, we are concerned only with the steps in the main module, so we assume
that each lower-level module is correct. At each step, we determine the current conditions. If
the step is a reference to another module, we check that the module’s precondition is met by
the current conditions.
The first statement in the main module, Get Data, does not have a precondition, and we
assume that Get Data correctly inputs two real values into weight and height.
The precondition for module Test Data is that weight and height are assigned values, which
matches Get Data’s postcondition. Again, because we are concerned only with what happens
at Level 0, we assume that Test Data satisfies its postcondition that dataAreOK contains true
or false.

Next, the If statement checks to see if dataAreOK is true. If it is, the algorithm performs the
then-clause. Assuming that Calculate BMI and Display Message Indicating Status work
correctly, then the If statement’s then-clause is correct. If the value in dataAreOK is false, the
algorithm performs the else-clause and displays an error message.
We now have verified that the main (Level 0) module is correct, assuming the Level 1
modules are correct. The next step is to examine each module at Level 1 to see if it does
what it is supposed to do, assuming the Level 2 modules (if any) are correct. We simply
repeat the walk-through process for each module, starting with its particular precondition. In
this example, there are no Level 2 modules, so the Level 1 modules must be complete.
Get Data correctly reads in two values—weight and height—thereby satisfying its
postcondition. (The next refinement is to code this instruction in C++. Whether it is coded
correctly is not an issue in this phase; we deal with the code when we perform testing in the
implementation phase.)
Test Data checks whether both variables contain nonnegative values. The If condition
correctly uses OR operators to combine the relational expressions so that if either of them is
true, the then-clause is executed. It thus assigns false to dataAreOK if either of the numbers is
negative; otherwise, it assigns true. The module, therefore, satisfies its postcondition.
Calculate BMI evaluates the BMI formula: weight * 703 / (height * height). The required
postcondition, therefore, is true. But what if the value of height is 0? Oh, dear! We checked
that the inputs are nonnegative, but forgot that height is used as a divisor and thus cannot be
0. We’ll need to fix this problem before we release this program for general use.
Display Message Indicating Status outputs the value in bodyMassIndex with appropriate
documentation. It then compares the result to the standards and outputs the appropriate
interpretation. Thus the module satisfies its postcondition.
Once we’ve completed the algorithm walk-through, we have to correct any discrepancies
and repeat the process. When we know that the modules do what they are supposed to do,
we start translating the algorithm into our programming language.
A standard postcondition for any program is that the user has been notified of invalid data.
You should validate every input value for which any restrictions apply. A data-validation If
statement tests an input value and outputs an error message if the value is not acceptable.
(We validated the data when we tested for negative scores in the BMI program.) The best
place to validate data is immediately after it is input. To satisfy the data-validation
postcondition, the algorithm should also test the input values to ensure that they aren’t too
large or too small.
Testing in the Implementation Phase
Now that we’ve talked about testing in the problem-solving phase, we turn to testing in the
implementation phase. In this phase, you need to test at several points.
Code Walk-Through
After the code is written, you should go over it line by line to be sure that you’ve faithfully
reproduced the algorithm—a process known as a code walk-through. In a team programming
situation, you ask other team members to walk through the algorithm and code with you, to
double-check the design and code.

Execution Trace
You also should take some actual values and hand-calculate what the output should be by
doing an execution trace (or hand trace). When the program is executed, you can use these
same values as input and check the results.
The computer is a very literal device—it does exactly what we tell it to do, which may or
may not be what we want it to do. We try to make sure that a program does what we want by
tracing the execution of the statements.
We use a nonsense program below to demonstrate the technique. We keep track of the
values of the program variables on the right-hand side. Variables with undefined values are
indicated with a dash. When a variable is assigned a value, that value is listed in the
appropriate column.
Description

Now that you’ve seen how the technique works, let’s apply it to the BMI program. We list
only the executable statement portion here. The input values are 124 and 63.5.
The then-clause of the first If statement is not executed for these input data, so we do not fill
in any of the variable columns to its right. The then-clause of the second If statement is
executed; thus the else-clause is not. The else-clause of the third If statement is executed,
which is another If statement. The then-clause is executed here, leaving the rest of the code
unexecuted.
We always create columns for all of the variables, even if we know that some will stay
empty. Why? Because it’s possible that later we’ll encounter an erroneous reference to an
empty variable; having a column for the variable reminds us to check for just such an error.
Description
When a program contains branches, it’s a good idea to retrace its execution with different
input data so that each branch is traced at least once. In the next section, we describe how to
develop data sets that test all of a program’s branches.

Testing Selection Control Structures
To test a program with branches, we need to execute each branch at least once and verify the
results. For example, the BMI program contains five If-Then-Else statements (see FIGURE
5.6). We need a series of data sets to test the different branches. For example, the following
sets of input values for weight and height cause all of the branches to be executed:
Description
FIGURE 5.7 shows the flow of control through the branching structure of the BMI program
for each of these data sets. Every branch in the program is executed at least once through
this series of test runs; eliminating any of the test data sets would leave at least one branch
untested. This series of data sets provides what is called minimum complete coverage of the
program’s branching structure. Whenever you test a program with branches in it, you should
design a series of tests that cover all of the branches. It may help to draw diagrams like those
in Figure 5.7 so that you can see which branches are being executed.
Because an action in one branch of a program often affects processing in a later branch, it
is critical to test as many combinations of branches, or paths, through a program as possible.
By doing so, we can be sure that there are no interdependencies that could cause problems.
Of course, some combinations of branches may be impossible to follow. For example, if the
else-clause is executed in the first branch of the BMI program, the else-clause in the second
branch cannot be executed. Shouldn’t we try all possible paths? Yes, in theory we should.
However, even in a small program, the number of paths can be very large.
The approach to testing that we’ve used here is called code coverage because the test data
are designed by looking at the code of the program. Code coverage also is called white-box
(or clear-box) testing because we are allowed to see the program code while designing the
tests. Another approach to testing, called data coverage, attempts to test as many allowable
data values as possible without regard to the program code. Because we need not see the
code in this form of testing, it also is called black-box testing—we would design the same set
of tests even if the code were hidden in a black box.
Complete data coverage is as impractical as complete code coverage for many programs.
For example, if a program has four int input values, there are approximately (2 × INT_MAX)4
possible inputs. (INT_MAX and INT_MIN are constants declared in the header file <climits>.
They represent the largest and smallest possible int values, respectively, on your particular
computer and C++ compiler.)

Often, testing entails a combination of these two strategies. Instead of trying every possible
data value (data coverage), we examine the code (code coverage) and look for ranges of
values for which processing is identical. Then we test the values at the boundaries and,
sometimes, a value in the middle of each range. For example, a simple condition such as
FIGURE 5.6 Branching Structure for BMI Program
Description

FIGURE 5.7 Flow of Control Through BMI Program for Each of Five Data Sets
Description
Description
divides the integers into two ranges:
1. INT_MIN through –1
2. 0 through INT_MAX
Thus we should test the four values INT_MIN, –1, 0, and INT_MAX. A compound condition such
as
Description
divides the integers into three ranges:
1. INT_MIN through —1
2. 0 through 100
3. 101 through INT_MAX
Thus we have six values to test. In addition, to verify that the relational operators are correct,
we should test for values of 1 (> 0) and 99 (< 100).
Conditional branches are only one factor in developing a testing strategy. We consider more
of these factors in later chapters.
The Test Plan

Whenever we write a program, we must design a test plan—a document that specifies the
test cases that should be tried, the reason for each test case, and the expected output. Test
plan implementation involves running the program using the data specified by the test cases
and checking the results.
Test plan A document that specifies how a program is to be tested.
Test plan implementation Using the test cases specified in a test plan to verify that a
program outputs the predicted results.
The test plan should be developed together with the functional decomposition. As you
create each module, write out its precondition and postcondition and note the test data
required to verify them. Consider code coverage and data coverage to see if you’ve left out
tests for any aspects of the program. (If you’ve forgotten something, it probably indicates that
a precondition or postcondition is incomplete.)
The following table shows a partial test plan for the BMI program. It has six test cases. The
first four cases test the different paths through the program for valid data. Two more test
cases check that weight and height are validated appropriately by separately entering an
invalid score for each.
We should test the program on the end cases—that is, where the BMI is exactly 20, 25, and
30. Because the BMI is calculated and not input, we have to work backward from the desired
answers to get the appropriate input values. The Case Study Follow-Up Exercises ask you to
look at this problem, complete this test plan, and implement it.

Description
Implementing a test plan does not guarantee that a program is completely correct.
(Remember that the BMI program still doesn’t catch a height of zero as invalid input.) It
means only that systematic testing hasn’t revealed any bugs.
Tests Performed Automatically During Compilation and
Execution
Once a program is coded and test data have been prepared, it is ready for compiling. The
compiler has two responsibilities: to report any errors and (if there are no errors) to translate
the program into object code.
Errors can be syntactic or semantic. The compiler finds syntactic errors; for example, the
compiler warns you when reserved words are misspelled, identifiers are undeclared, and
semicolons are missing. But it won’t find all of your typing errors. If you type > instead of <, for
example, you won’t get an error message; instead, you will get erroneous results when you

test the program. It’s up to you to design a test plan and carefully check the code to detect
such errors.
Semantic errors (also called logic errors) are mistakes that give you the wrong answer.
They are more difficult to locate than syntactic errors and usually surface when a program is
executing. C++ detects only the most obvious semantic errors—those that result in an invalid
operation (dividing by zero, for example). Although semantic errors sometimes are caused by
typing errors, they are more often a product of a faulty algorithm design. The lack of checking
whether height is 0—the potential problem that we found in the algorithm walk-through for the
BMI problem—is a typical semantic error. By walking through the algorithm and the code,
tracing the execution of the program, and developing a thorough test strategy, you should be
able to avoid, or at least quickly locate, semantic errors in your programs.
FIGURE 5.8 illustrates the testing process we’ve been discussing. The figure shows where
syntax and semantic errors occur and in which phase they can be corrected.
FIGURE 5.8 Testing Process
Description
Testing and Debugging Hints
1. C++ has three pairs of operators that are similar in appearance but very different in
effect: == and =, && and &, and || and |. Double-check all of your logical expressions to be
sure you’re using the “equals-equals,” “and-and,” and “or-or” operators.
2. If you use extra parentheses for clarity, be sure that the opening and closing
parentheses match up. To verify that parentheses are properly paired, start with the

innermost pair and draw a line connecting them. Do the same for the others, working
your way out to the outermost pair. For example,
Description
Here is a quick way to tell whether you have an equal number of opening and closing
parentheses. The scheme uses a single number (the “magic number”), whose value initially is
0. Scan the expression from left to right. At each opening parenthesis, add 1 to the magic
number; at each closing parenthesis, subtract 1. At the final closing parenthesis, the magic
number should be 0. For example,
Description
3. Don’t use =< to mean “less than or equal to”; only the symbol <= works for this purpose.
Likewise, => is invalid for “greater than or equal to”; you must use >= for this operation.
4. In an If statement, remember to use a { } pair if the then-clause or else-clause is a
sequence of statements. Also, be sure not to put a semicolon after the right brace.
5. Echo all input data. By doing so, you know that your input values are what they are
supposed to be.
6. Test for bad data. If a data value must be positive, use an If statement to test the value.
If the value is negative or 0, an error message should be displayed; otherwise,
processing should continue. For example, the following code segment tests whether
three test scores are less than 0 or greater than 100:

Description
These If statements test the limits of reasonable scores; the rest of the program continues
only if the data values are reasonable.
7. When an If statement is inadvertently applied to an int value, it returns true if the value
is nonzero and false otherwise. The compiler does not report this result as an error.
8. Take some sample values and try them by hand as we did for the BMI program.
(There’s more on this method in Chapter 6.)
9. If your program reads data from an input file, it should verify that the file was opened
successfully. Immediately after the call to the open function, an If statement should test
the state of the file stream.
10. If your program produces an answer that does not agree with a value you’ve
calculated by hand, try these suggestions:
a. Redo your arithmetic.
b. Recheck your input data.
c. Carefully go over the section of code that does the calculation. If you’re in doubt about
the order in which the operations are performed, insert clarifying parentheses.
d. Check for integer overflow. The value of an int variable may have exceeded INT_MAX
in the middle of a calculation. Some systems give an error message when this happens,
but most do not.
e. Check the conditions in branching statements to be sure that the correct branch is
taken under all circumstances.

Summary
Using logical expressions is a way of asking questions while a program is running. The
program evaluates each logical expression, producing the value true if the expression is
true or the value false if the expression is not true.
The If statement allows you to take different paths through a program based on the
value of a logical expression. The If-Then-Else statement is used to choose between two
courses of action; the If-Then statement is used to choose whether to take a particular
course of action. The branches of an If-Then or If-Then-Else can be any statement, simple
or compound. They can even be other If statements.
The algorithm walk-through requires us to define a precondition and a postcondition for
each module in an algorithm. Then we need to verify that those assertions are true at the
beginning and end of each module. By testing our design in the problem-solving phase, we
can eliminate errors that can be more difficult to detect in the implementation phase.
An execution trace is a way of finding program errors once we’ve entered the
implementation phase. It’s a good idea to trace a program before you run it, so that you
have some sample results against which to check the program’s output. A written test plan
is an essential part of any program development effort.

Quick Check Answers
5.1.1 The order in which statements are executed in a program. 5.1.2 Sequential. 5.1.3
Selection or branching control structure. 5.1.4 It allows the computer to choose between
alternative courses of action, depending on a test of certain conditions. 5.2.1 true and
false 5.2.2 temperature > 32 5.2.3 2 5.2.4 Logical values and logical operations. 5.2.5 x =
1, y = 5
5.3.1 
Description
5.3.2 Because the computer can choose to execute either of them depending on the
circumstances.
5.3.3 It must evaluate to a bool data type.
5.4.1 It allows the computer to select among any number of alternative courses of action.
5.4.2 
Description
5.4.3 A nested control structure. 5.4.4 A multiway branch. 5.4.5 The dangling else
problem.
5.5.1 &&, ||, ! 5.5.2 !(a == b || c >= d) 5.5.3 failed = (grade <= 50.0); 5.5.4 From
left to right. 5.5.5 5 >= 2 && x != 7
5.6.1 if (cin) … 5.6.2 Testing the state of the stream. 5.6.3 Your program will quietly
continue to execute and ignore any input/output operations on the file.

Exam Preparation Exercises
5.1 Define the term “flow of control.”
5.2 The values true and false are keywords in C++. True or false?
5.3 The “equals or greater” operator in C++ is written =>. True or false?
5.4 Why is it that 'A' < 'B' and 'a' < 'b' are both true, but 'a' < 'B' is false?
5.5 If int1 has the value 12, int2 has the value 18, and int3 has the value 21, what is
the result of each of the following Boolean expressions?
5.6 If string1 has the value “miniscule”, string2 has the value “minimum”, and string3
has the value “miniature”, what is the result of each of the following expressions?
5.7 Why won’t the following expression result in a division-by-zero error when someInt
has the value 0?
Description

5.8 The bool operators have lower precedence than the arithmetic operators, with the
exception of the ! operator, which has the same precedence as unary minus. True or
false?
5.9 We enclose the logical expression in an If statement in parentheses only to make
the code more readable. C++ doesn’t require the parentheses. True or false?
5.10 What does the following If statement do when the value in someInt is 77?
Description
5.11 What does the following If statement do when the value in string1 is “The”?
Description
5.12 What does the following If statement do when the value in float1 is 3.15?
Description
5.13 Why does the following If statement always output “false” regardless of the
value in someInt?

Description
5.14 What is output by the following code segment when score has the value 85?
Description
5.15 What is output by the following code segment when score has the value 85?

Description
5.16 How do you fix a nested If statement that has a dangling else?
5.17 How would you write a Boolean expression in an If statement if you want the
statement’s then-clause to execute when file inData is in the fail state?
5.18 Is there any limit to how deeply we can nest If statements?

Programming Warm-Up Exercises
5.1 Write a Boolean expression that is true when the bool variable moon has the value
“blue” or the value “Blue”.
5.2 Write a Boolean expression that is true when both inFile1 and inFile2 are in the
fail state.
5.3 Write a branching statement that reads into a string variable called someString,
from a file called inFile, if the file is not in the fail state.
5.4 Write a branching statement that tests whether one date comes before another.
The dates are stored as integers representing the month, day, and year. The variables
for the two dates are called month1, day1, year1, month2, day2, and year2. The
statement should output an appropriate message depending on the outcome of the
test. For example:
Description
5.5 Change the branching statement that you wrote for Exercise 4 so that when the
first date doesn’t come before the second, it sets the first date equal to the second
date in addition to displaying the message.
5.6 Write a Boolean expression that is true when either of the bool variables bool1 or
bool2 is true, but is false whenever both of them are true or neither of them is true.
5.7 Write a branching statement that tests whether score is in the range of 0 to 100,
and outputs an error message if it is not within that range.
5.8 Change the branching statement that you wrote for Exercise 5.7 so that when
score is in the proper range, it adds score to a running total variable called scoreTotal
and increments a counter called scoreCount.
5.9 Write a code segment that reads an int value from each of two files, infile1 and
infile2. If neither file is in the fail state, the program writes the lesser value of the two
to a file called outfile, and reads another value from the file that had the lesser value.
If either of the files is in the fail state, then the value from the file that is not in the fail

state is written to outfile. If both files are in the fail state, then an error message is
output to cout. The int values can be input into variables value1 and value2.
5.10 Change the following series of If-Then statements into a nested If-Else-If
structure.
Description
5.11 Write an If structure that outputs the least of three values, count1, count2, and
count3. If more than one variable has the same lowest value, then output the value as
many times as it is found in those variables.
5.12 The following program segment is not supposed to output anything, yet it outputs
the first error message, “Error in maximum: 100”. What’s wrong, and how would you
correct it? Why doesn’t the code output both error messages?
Description
5.13 Write an If statement that takes the square root of the variable area only when its
value is nonnegative. Otherwise, the statement should set area equal to its absolute
value and then take the square root of the new value. The result should be assigned to
the variable root.
5.14 Write a test plan for the following branching structure.

Description
5.15 Write a test plan for the following branching structure. (Note that the test for a
leap year given here does not include the special rules for century years.)
Description

Programming Problems
5.1 Write a C++ program that computes a student’s grade for an assignment as a
percentage given the student’s score and the total points. The final score should be
rounded up to the nearest whole value using the ceil function in the <cmath> header
file. You should also display the floating-point result up to five decimal places. The
input to the program must come from a file containing a single line with the score and
total separated by a space. In addition, you should display “Excellent” if the grade is
greater than 90, “Well Done” if the grade is greater than 80, “Good” if the grade is
greater than 70, “Need Improvement” if the grade is greater than or equal to 60, and
“Fail” if the grade is less than 60.
5.2 ROT13 (rotate by 13 places) is a simple letter substitution cipher that is an
instance of a Caesar cipher developed in ancient Rome and used by Julius Caesar in
his private correspondence. ROT13 replaces a letter with the letter 13 letters after it in
the alphabet. The following table demonstrates the translation in ROT13:
A
↔
N
B
↔
O
C
↔
P
D
↔
Q
E
↔
R
F
↔
S
G
↔
T
H
↔
U
I
↔
V
J
↔
W
K
↔
X
L
↔
Y
M
↔
Z
Thus, the translation of the word JULIUS using ROT13 would be WHYVHF. Write a C++
program that inputs a letter and outputs the corresponding letter using the ROT13
encoding scheme above. Your output should look like G -> T.
5.3 Use functional decomposition to write a C++ program that inputs a letter and
outputs the corresponding International Civil Aviation Organization alphabet word.

(These are the words that pilots use when they need to spell something out over a
noisy radio channel.) The alphabet is as follows:
A
Alpha
B
Bravo
C
Charlie
D
Delta
E
Echo
F
Foxtrot
G
Golf
H
Hotel
I
India
J
Juliet
K
Kilo
L
Lima
M
Mike
N
November
O
Oscar
P
Papa
Q
Quebec
R
Romeo
S
Sierra
T
Tango
U
Uniform
V
Victor
W
Whiskey
X
X-ray
Y
Yankee
Z
Zulu
Be sure to use proper formatting and appropriate comments in your code. Provide
appropriate prompts to the user. The output should be labeled clearly and formatted neatly.
5.4 Use functional decomposition to write a C++ program that asks the user to enter
their weight and the name of a planet. The program then outputs how much the user
would weigh on that planet. The following table gives the factor by which the weight
must be multiplied for each planet. The program should output an error message if the
user doesn’t type a correct planet name. The prompt and the error message should

make it clear to the user how a planet name must be entered. Be sure to use proper
formatting and appropriate comments in your code. The output should be labeled
clearly and formatted neatly.
Mercury
0.4155
Venus
0.8975
Earth
1.0
Moon
0.166
Mars
0.3507
Jupiter
2.5374
Saturn
1.0677
Uranus
0.8947
Neptune
1.1794
5.5 Use functional decomposition to write a C++ program that takes a number in the
range of 1 to 12 as input, and outputs the corresponding month of the year, where 1 is
January, and so on. The program should output an error message if the number
entered is not in the required range. The prompt and the error message should make
it clear to the user how a month number must be entered. Be sure to use proper
formatting and appropriate comments in your code. The output should be labeled
clearly and formatted neatly.
5.6 Use functional decomposition to write a C++ program that takes a number in the
range of 0 to 6 and a second number in the range of 1 to 366 as input. The first
number represents the day of the week on which the year begins, where 0 is Sunday,
and so on. The second number indicates the day of the year. The program then
outputs the name of the day of the week corresponding to the day of the year. The
number of the day of the week can be computed as follows:
Description
The program should output an error message if the numbers entered are not in the
required ranges. The prompt and the error message should make it clear to the user how
the numbers must be entered. Be sure to use proper formatting and appropriate
comments in your code. The output should be labeled clearly and formatted neatly.
5.7 Use functional decomposition to write a C++ program that takes a number in the
range of 1 to 365 as input. The number represents the day of the year. The program
then outputs the name of the month. (Assume the year is not a leap year.) You can do
this by comparing the day of the year to the number of days in the year that precede

the start of each month. For example, 59 days precede March, which has 31 days.
So, if the day of the year is in the range of 60 through 91, then your program would
output March. The program should output an error message if the number entered is
not in the required range. The prompt and the error message should make it clear to
the user how the number must be entered. Be sure to use proper formatting and
appropriate comments in your code. The output should be labeled clearly and
formatted neatly.
5.8 Use functional decomposition to write a C++ program that takes as input three
numbers representing the number of pins knocked down by a bowler in three throws.
The rules of bowling are that if the first throw is a strike (all 10 pins knocked down),
then the score is equal to those 10 points plus the number knocked down in the next
two throws. Thus the maximum score (three strikes) is 30. If the first throw knocks
down fewer than 10 pins, but the second throw knocks down the remainder of the 10
pins (a spare), then the score is those 10 points plus the number of pins knocked
down on the third throw. If the first two throws fail to knock down all of the pins (a
blow), then the score is just the total number of pins knocked down in the first two
throws. Your program should output the computed score and also should check for
erroneous input. For example, a throw may be in the range of 0 through 10 points, and
the total of the first two throws must be less than or equal to 10, except when the first
throw is a strike. Be sure to use proper formatting and appropriate comments in your
code. The output should be labeled clearly and formatted neatly, and the error
messages should be informative.
5.9 Use functional decomposition to write a C++ program that computes a dance
competition score. There are four judges who mark the dancers in the range of 0 to
10, and the overall score is the average of the three highest scores (the lowest score
is excluded). Your program should output an error message, instead of the average, if
any of the scores are not in the correct range. Be sure to use proper formatting and
appropriate comments in your code. The output should be labeled clearly and
formatted neatly, and the error message should indicate clearly which score was
invalid.
5.10 Use functional decomposition to write a C++ program that determines the
median of three input numbers. The median is the middle number when the three
numbers are arranged in order by size. However, the user can input the values in any
order, so your program must determine which value is between the other two. For
example, if the user enters
Description

then the program would output
Description
Once you have the three-number case working, extend the program to handle five
numbers. Be sure to use proper formatting and appropriate comments in your code. The
output should be labeled clearly and formatted neatly.

Case Study Follow-Up
1. How might you go about choosing values for weight and height so that the BMI
values of 20, 25, and 30 are tested?
2. Change the program so that the BMI is rounded. Choose appropriate cases to test
the end conditions. Implement your test plan.
3. Change the program so that it takes metric values for the weight and height. Go on
the Internet to find the correct formula.
4. Change the original program so that the height is entered in feet and inches. Prompt
for and enter them separately.
5. A negative input value for weight or height was considered an error condition in the
BMI program. Are there other values for weight or height that should be considered
error conditions? Explain.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  6
Looping
KNOWLEDGE GOALS
To understand the flow of control in a loop.
To understand the differences between count-controlled, event-controlled, and flag-
controlled loops.
To understand counting and summing operations within a loop.
To know how to choose the correct type of loop for a given problem.
SKILL GOALS
To be able to:
Construct syntactically correct While loops.
Construct count-controlled, event-controlled, and flag-controlled loops using a While
statement.
Use the end-of-file condition to control the input of data.
Construct counting and summing loops with a While statement.
Construct nested While loops.
Choose data sets that test a looping program comprehensively.
In Chapter 5 we saw that the flow of control in a program can differ from the written order of
the statements. The order in which we want the statements to be executed is called,
reasonably enough, the execution order.
The If statement is one way of changing the execution order. Looping control structures are
another. A loop executes the same statement (simple or compound) over and over, as long
as a condition is satisfied.

Loop A control structure that causes a statement or group of statements to be executed
repeatedly.
In this chapter, we discuss different kinds of loops and explore how they are constructed
using the While statement. We also discuss nested loops (loops that contain other loops) and
introduce a notation for comparing the amount of work done by different algorithms.

6.1 The While Statement
The While statement, like the If statement, tests a condition. Here is the syntax template for
the While statement:
Description
Here is an example of one:
Description
The While statement is a looping control structure. The “Statement” in the syntax template is
called the body of the loop, or loop body. In the preceding example, the body is the input
statement. This While statement says to execute the body repeatedly as long as the input
value does not equal 25. The While loop stops when inputVal equals 25. The effect of this
loop is to consume and ignore all the values in the input stream until 25 is input.
Just like the condition in an If statement, the condition in a While statement can be an
expression of any simple data type. Usually it is a logical (Boolean) expression; if not, its
value is implicitly coerced to type bool.

Description
FIGURE 6.1 While Statement Flow of Control
The meaning of a While statement is, “If the value of the expression is true, execute the
body and then go back and test the expression again. If the expression’s value is false, skip
the body and go to the statement following the body.” The loop body is thus executed over and
over as long as the expression is true when it is tested. When the expression is tested and its
value is false, the program skips the body and execution continues at the statement
immediately following the loop. Of course, if the expression is false initially, the body is never
executed. FIGURE 6.1 shows the flow of control of the While statement, where Statement1 is
the body of the loop and Statement2 is the statement following the loop.
The body of a loop can be a compound statement (block), which allows us to execute any
group of statements repeatedly. Most often we use While loops in the following form:
Description
In this structure, if the expression is true, the statements in the block are executed, and then
the expression is checked again. If it is still true, the statements are executed again. The
cycle continues until the expression becomes false.

Although in some ways the If and While statements are alike, some fundamental
differences distinguish them (see FIGURE 6.2). In the If structure, Statement1 is either
skipped or executed exactly once. In the While structure, Statement1 can be skipped,
executed once, or executed over and over. The If is used to choose a course of action; the
While is used to repeat a course of action.
FIGURE 6.2 A Comparison of If and While
Description
QUICK CHECK
6.1.1 What is the name of the looping control structure studied in this section?
6.1.2 What is the data type of the condition expression used in a While statement?
6.1.3 What if the condition expression used in a While statement does not have type
bool?
6.1.4 An If statement is used to choose a course of action whereas the While
statement is used to _____________ a course of action.

6.2 Phases of Loop Execution
The body of a loop is executed in several phases:
The moment that the flow of control reaches the first statement inside the loop body is the
loop entry.
Each time the body of a loop is executed, a pass is made through the loop. This pass is
called an iteration.
Before each iteration, control is transferred to the loop test at the beginning of the loop.
When the last iteration is complete and the flow of control has passed to the first
statement following the loop, the program has exited the loop. The condition that causes
a loop to be exited is the termination condition. In the case of a While loop, the
termination condition is that when the While expression is checked, it is false.
Loop entry The point at which the flow of control reaches the first statement inside a loop.
Iteration An individual pass through, or repetition of, the body of a loop.
Loop test The point at which the While expression is evaluated and the decision is made
either to begin a new iteration or to skip to the statement immediately following the loop.
Loop exit The point at which the repetition of the loop body ends and control passes to the
first statement following the loop.
Termination condition The condition that causes a loop to be exited.
Notice that the loop exit occurs at only one point: when the loop test is performed. Even
though the termination condition may become satisfied midway through the execution of the
loop, the current iteration is completed before the computer checks the While expression
again.
The concept of looping is fundamental to programming. In this chapter, we spend some
time looking at typical algorithmic examples of loops and ways of implementing them with the
While statement. These looping situations come up again and again when you are analyzing
problems and designing algorithms.
QUICK CHECK
6.2.1 What are the four phases of loop execution?

6.3 Loops Using the While Statement
In solving problems, you will come across two major algorithmic uses of loops: count-
controlled loops, which repeat a specified number of times, and event-controlled loops,
which repeat until something happens within the loop.
If you are making an angel food cake and the recipe reads, “Beat the mixture 300 strokes,”
you are executing a count-controlled loop. If you are making a pie crust and the recipe reads,
“Cut with a pastry blender until the mixture resembles coarse meal,” you are executing an
event-controlled loop; you don’t know ahead of time the exact number of loop iterations.
Count-controlled loop A loop that executes a specified number of times.
Event-controlled loop A loop that terminates when something happens inside the loop
body to signal that the loop should be exited.
Count-Controlled Loops
A count-controlled loop uses a variable we call the loop control variable in the loop test. Before
we enter a count-controlled loop, we have to initialize (set the initial value of) the loop control
variable and then test it. Then, as part of each iteration of the loop, we must increment
(increase by 1) the loop control variable. Note that there is nothing special about the loop
control variable other than how we use it. We simply refer to it this way as a convenient
means to distinguish it from other variables we might use within a loop. Here’s an example in
a program that repeatedly outputs “Hello!” on the screen:

Description
In the Hello program, loopCount is our loop control variable. It is set to 1 before loop entry.
The While statement tests the expression
Description
and executes the loop body as long as the expression is true. Inside the loop body, the main
action we want to be repeated is the output statement. The last statement in the loop body
increments loopCount by adding 1 to it.
Notice the form of the statement in which we increment the loop control variable:
Description
This statement adds 1 to the current value of the variable, and the result replaces the old
value. Variables that are used this way are called counters. In the Hello program, loopCount is
incremented with each iteration of the loop—we use it to count the iterations. The loop control
variable of a count-controlled loop is always a counter.
Of course, we’ve encountered another way of incrementing a variable in C++. The
incrementation operator (++) increments the variable that is its operand. The statement
Description
has precisely the same effect as the assignment statement
Description
From here on, we typically use the ++ operator, as do most C++ programmers.
When designing loops, it is the programmer’s responsibility to see that the condition to be
tested is set correctly (initialized) before the While statement begins. The programmer also
must make sure that the condition changes within the loop so that it eventually becomes
false; otherwise,

Description
A loop that never exits is called an infinite loop because, in theory, it executes forever. In the
preceding code, omitting the incrementing of loopCount leads to an infinite loop; the While
expression is always true because the value of loopCount is forever 1. If your program goes
on running for much longer than you expect, chances are you’ve created an infinite loop. You
may have to issue an operating system command to stop the program.
How many times does the loop in our Hello program execute—9 or 10? To answer this
question, we look at the initialization and exit test for the loop control variable. Because
loopCount starts at 1 and runs up through 10, the loop body executes 10 times. If we want the
loop to execute 11 times, we either initialize loopCount to 0 or change the test to
Description
Remember the program we developed in Chapter 2 that displays a chessboard? Here is
the algorithm:
Repeat four times
  Output five whiteRows
  Output five blackRows
Before we knew how to write loops, we had to repeat the code four times. Here is the program
using a loop:

Description

Event-Controlled Loops
Several kinds of event-controlled loops exist: sentinel controlled, end-of-file controlled, and
flag controlled. In all of these loops, the termination condition depends on some event
occurring while the loop body is executing.
Sentinel-Controlled Loops
Loops are often used to read in and process long lists of data. Each time the loop body is
executed, a new piece of data is read and processed. Often a special data value, called a
sentinel or trailer value, is used to signal the program that no more data remain to be
processed. Looping continues as long as the data value read is not the sentinel; the loop stops
when the program recognizes the sentinel. In other words, reading the sentinel value is the
event that controls the looping process.
A sentinel value must be something that never shows up in the normal input to a program.
For example, if a program reads calendar dates, we could use February 31 as a sentinel
value:
Description
But this loop has a problem: The values of month and day are not defined before loop entry.
Somehow we have to initialize these variables. We could assign them values that ensure the
loop is entered, but then what happens if the first values input are the sentinel values? They
would be processed as data, even though they are invalid. Also, it’s inefficient to initialize
variables with values that are never used.
We can solve this problem by reading the first set of data values before entering the loop.
This practice is called a priming read. (The idea is similar to priming a pump by pouring a
bucket of water into the mechanism before starting it.) Let’s add the priming read to the loop:
Description

With the priming read, if the first values input are the sentinel values, then the loop correctly
does not process them. We’ve solved one problem, but now there is a problem when the first
values input are valid data. The first thing the program does inside the loop is to get a date,
which replaces the values obtained by the priming read. Thus the first date entered is never
processed. Given the priming read, the first thing that the loop body should do is process the
data that’s already been read. But at what point do we then read the next data set? We do this
last in the loop. In this way, the While condition is applied to the next data set before it gets
processed. Here’s how it looks:
Description
This code works correctly. The first data set is read in; if it is not the sentinel, it gets
processed. At the end of the loop, the next data set is read in, and we go back to the beginning
of the loop. If the new data set is not the sentinel, it gets processed just like the first. When the
sentinel value is read, the While expression becomes false and the loop exits (without
processing the sentinel).
Often the problem dictates the value of the sentinel. For example, if the problem does not
allow data values of 0, then the sentinel value should be 0. Sometimes a combination of
values is invalid. The combination of February and 31 as a date is such a case. Sometimes a
range of values (negative numbers, for example) is the sentinel.
When you process char data one line of input at a time, the newline character ('\n') often
serves as the sentinel. Here’s a program that reads and displays all of the characters from
one line of an input file:

Description
Notice that for this particular task we use the get function, not the >> operator, to input a
character. Recall that the >> operator skips whitespace characters—including blanks and
newlines—to find the next data value in the input stream. In this program, we want to input
every character, even a blank and especially the newline character.
What if there aren’t any invalid data values that you can use as a sentinel? Then you may
have to input an extra value in each iteration, a value whose only purpose is to signal the end
of the data. For example, with each iteration you could ask the user if there are more data to
enter, and have them input Y for yes and N for no.
What happens if you forget to enter the sentinel value? In an interactive program, the loop
executes again, prompting for input. At that point, you can enter the sentinel value. If the input
to the program comes from a file, once all the data have been read, the loop body is executed
again. However, because the computer has reached the end of the file, the file stream enters
the fail state. In the next section, we see how to use end-of-file as a loop termination condition.

Before we move on, recall the mistake of using the assignment operator (=) instead of the
equals operator (==) in an If condition. This same mistake can happen with While statements.
See what happens when we use the wrong operator in the previous example:
Description
This mistake creates an infinite loop. The termination condition is now an assignment
expression, not a relational expression. The expression’s value is 1 (interpreted in the loop
test as true because it’s nonzero), and its side effect is to store the value 1 into sentinel,
replacing the value just read. Because the While expression is always true, the loop never
stops.
End-of-File-Controlled Loops
You have already learned that an input stream (such as cin or an input file stream) goes into
the fail state (1) if it encounters unacceptable input data, (2) if the program tries to open a
nonexistent input file, or (3) if the program tries to read past the end of an input file. Let’s look
at the third of these three possibilities.
After a program has read the last piece of data from an input file, the computer is at the end
of the file (EOF, for short). At this moment, the stream state is in a successful state. But if we
try to input even one more value, the stream goes into the fail state. We can use this fact to
our advantage: To write a loop that inputs an unknown number of data items, we can use the
failure of the input stream as a form of sentinel.
Recall how, in Chapter 5, we introduced testing the state of a stream. To test the state of a
stream in a logical expression, we use the name of the stream as though it were a Boolean
variable:
Description
In such a test, the result is true if the most recent I/O operation succeeded, or false if it failed.
In a While statement, testing the state of a stream works the same way. Suppose we have a
data file containing integers. If inData is the name of the file stream in our program, here’s a
loop that reads and echoes all the data values in the file:

Description
Let’s trace this code, assuming the file contains three values: 10, 20, and 30. The priming
read inputs the value 10. The While condition is true because the input succeeded, and the
computer executes the loop body. The body outputs 10, and then inputs the second value, 20.
Looping back to the loop test, inData is true because the input succeeded. The body
executes again, displaying 20 and reading 30 from the file. Looping back to the test, the
expression is true. Even though we are at the end of the file, the stream state is still okay—
the previous input operation succeeded. The body executes a third time, displaying 30 and
executing the input statement. This time, the input statement fails, because we’re trying to
read beyond the end of the file. The stream inData enters the fail state. Returning to the loop
test, the value of the expression is false and we exit the loop.
When we write EOF-controlled loops like the previous example, we expect that the end of
the file will be the reason for stream failure. But keep in mind that any input error causes
stream failure. The preceding loop terminates, for example, if input fails because of invalid
characters in the input data. This fact emphasizes again the importance of echo printing. It
helps us verify that all the data were read correctly before EOF was encountered.
EOF-controlled loops are similar to sentinel-controlled loops in that exit is caused by an
event. In the case of sentinel-controlled loops, the program encounters the sentinel value.
With EOF-controlled loops, it reaches EOF.
The following program uses an EOF-controlled loop to read and display the int values from
a file:

Description
Here is its output from a sample run:
Description
Flag-Controlled Loops
A flag is a Boolean variable used to cause a change in the control flow of a program. We can
set a Boolean variable to true before a While loop; then, when we want to stop executing the
loop, we can reset it to false. That is, we can use the Boolean variable to record whether the
event that controls the process has occurred. For example, the following code segment reads
and sums values until the input value is negative. (nonNegative is the Boolean flag; all of the
other variables are of type int.)

Description
Notice that we can code sentinel-controlled loops with flags. In fact, this code uses a negative
value as a sentinel.
You do not have to initialize flags to true; you can initialize them to false. If you do, you
must use the NOT operator (!) in the While expression and reset the flag to true when the
event occurs. The following program, which calculates the square root of an input value, uses
this approach. An initial value for the square root (guess) is calculated, goodEnough is set to
false, and the loop continues recalculating guess until the absolute value of guess*guess is
within 0.001 of the original value. Function fabs in <cmath> calculates the absolute value.

Description
Here is the output from a sample run:
Description
Looping Subtasks
We have been looking at ways to use loops to affect the flow of control in programs. In fact,
looping by itself does nothing. The loop body must perform a task for the loop to accomplish
something. In this section, we look at three tasks—counting, summing, and keeping track of a
previous value—that often are performed in loops.

Counting
A common task in a loop is to keep track of the number of times the loop has been executed.
For example, the following program fragment reads and counts input characters until it comes
to a period. (inChar is of type char; count is of type int.) The loop in this example has a
counter variable, but the loop is not a count-controlled loop because the variable is not being
used as a loop control variable.
Description
The loop continues until a period is read. After the loop is finished, count contains one less
than the number of characters read; that is, it counts the number of characters up to, but not
including, the sentinel value (the period). Notice that if a period is the first character, the loop
body is not entered and count contains 0, as it should. We use a priming read here because
the loop is sentinel controlled.
The counter variable in this example is called an iteration counter because its value
equals the number of iterations through the loop.
According to our definition, the loop control variable of a count-controlled loop is an iteration
counter. However, as you’ve just seen, not all iteration counters are loop control variables.
Iteration counter A counter variable that is incremented with each iteration of a loop.
Summing
Another common looping task is to sum a set of data values. Notice in the following example
that the summing operation is written the same way, regardless of how the loop is controlled.

Description
We initialize sum to 0 before the loop starts so that the first time the loop body executes, the
statement
Description
adds the current value of sum (0) to number to produce the new value of sum. After the entire
code fragment has executed, sum contains the total of the 10 values read, count contains 11,
and number contains the last value read.
In the preceding example, count is being incremented in each iteration. For each new value
of count, there is a new value for number. Does this mean we could decrement count by 1 and
inspect the previous value of number? No. Once a new value has been read into number, the
previous value is gone forever—that is, unless we’ve saved it in another variable. We’ll see
how to do so in the next section.
Let’s look at another example. We want to count and sum the first 10 odd numbers in a data
set. We need to test each number to see if it is even or odd. (We can use the modulus
operator to find out: If number % 2 equals 1, number is odd; otherwise, it’s even.) If the input
value is even, we do nothing. If it is odd, we increment the counter and add the value to our
sum. We use a flag to control the loop because this is not a normal count-controlled loop.
Here is a listing of the application and the output.

Description
Sample output:
Description
In this example, there is no relationship between the value of the counter variable and the
number of times the loop is executed. We could have written the While expression this way:
Description

but this might mislead a reader into thinking that the loop is count controlled in the normal way.
Instead, we control the loop with the flag lessThanTen to emphasize that count is incremented
only when an odd number is read. The counter in this example is an event counter; it is
initialized to 0 and incremented only when a certain event occurs. The counter in the previous
example was an iteration counter; it was initialized to 1 and incremented during each iteration
of the loop.
Event counter A variable that is incremented each time a particular event occurs.
Before we leave this example, we need to point out a shortcut we used in the code. Look at
the following two statements:
Description
We declared these two variables and initialized them in the same statement. This practice is
quite legal. In fact, we used this shortcut once before in an earlier program. Did you notice it?
In Chapter 9, we look at this construct a little more closely.
Keeping Track of a Previous Value
Sometimes we want to remember the previous value of a variable. Suppose we want to write
a program that counts the number of not-equal operators (!=) in a file that contains a C++
program. We can do so by simply counting the number of times an exclamation mark (!)
followed by an equal sign (=) appears in the input. One way in which to accomplish this task is
to read the input file one character at a time, keeping track of the two most recent characters
—that is, the current value and the previous value. In each iteration of the loop, a new current
value is read and the old current value becomes the previous value. When EOF is reached,
the loop is finished. Here’s a program that counts not-equal operators in this way:

Description
Description
Output:

Description
Study this loop carefully, because it’s going to come in handy. There are many problems in
which you must keep track of the last value read in addition to the current value.
SOFTWARE MAINTENANCE CASE STUDY Make a Program
General
MAINTENANCE TASK: In Chapter 5, we updated program Mortgage to read from the
keyboard and take interest rates as either decimals or percentages. Several friends are
currently using the Mortgage program, and one has asked if it could be modified to give the
total amount of interest paid over the term of the loan. Now that you know about loops, you
can enclose the program in a loop. A negative loan amount doesn’t make any sense, so
let’s use a negative value to end the program.
You realize that what started out as a program to help your parents has turned into a
general-purpose program to handle loans of many kinds. Rather than modify program
Mortgage, you decide to create a new program called LoanPayments based on program
Mortgage. The original functionality will remain, the total amount of interest over the period
of the loan will be shown, and the user can continue entering values.
CHANGES: Because you worked on the program so recently, you do not need to study
the code. The following changes will be required for the code:
Change the name of the program and update its documentation.
Update the prompt to say that a negative loan amount ends the program.
Calculate the total amount of interest.
Display the total amount of interest.
Enclose the whole program within a loop.
You look back over the program to see if any of the output needs changing and find that
all the labels are neutral; that is, they do not refer to mortgage payments. You finish the
changes, run the program, and it goes into an infinite loop. You isolate the loop and
examine it.

Description
The solution jumps out at you: New values for the variables weren’t read in. The input
statement must be repeated at the end of the loop. Is there anything else? Of course! The
prompt must be repeated. You make these changes and try again. Now the program
doesn’t quit when you enter a negative loan amount; it just sits there waiting for something.
This new behavior draws your attention to the input statements.
Description
The program is waiting for something—it is waiting for the rest of the data. Because you
didn’t need it, you just entered a negative loan amount and stopped. You could tell the user
to always enter three values, but a better solution exists: Read the loan amount outside the
loop, and finish reading the data in the loop. Then the last statement can read just the loan
amount. The calculation of numberOfPayments must also be moved inside the loop.
Here is the new program with the new or changed lines highlighted:


Description
This program looks long and complicated, more so than it actually is. In Chapter 8, we
cover a way to make the code look cleaner and simpler. Here is sample output from the
program:

Description
The amount of interest looked so high that you calculated it by hand to be sure. However, it is
correct.
QUICK CHECK
6.3.1 What are the two major types of loops encountered when solving problems?
6.3.2 Give a real-life example of the two major types of loops when solving problems.
6.3.3 How is a flag-controlled loop like a sentinel-controlled loop, and how do the two
types of loops differ?
6.3.4 Does averaging a set of values that are input by a loop involve summing,
counting, or both?
6.3.5 Write a While statement that exits when the int variable count is greater than 10
or the Boolean flag found is true.
6.3.6 Add a test for the condition end-of-file on cin to the loop in Question 6.3.5, and
add statements to the loop that perform a priming read and an updating read of inData
from cin.
6.3.7 Add initialization and update operations to the loop in Question 6.3.6 that cause it
to count the occurrences of the value 1 that are input to variable inData and to sum all
of the values read into inData.

6.4 How to Design Loops
It’s one thing to understand how a loop works when you look at it, and something else again to
design a loop that solves a given problem. In this section, we consider the process of
designing loops. We can divide this process into two tasks: designing the control flow and
designing the processing within the loop. We can, in turn, break each task into three phases:
the task itself, initialization, and update. It’s also important to specify the state of the program
when it exits the loop, because a loop that leaves variables and files in a mess is not well
designed.
There are seven points to consider in designing a loop:
1. What is the condition that ends the loop?
2. How should the condition be initialized?
3. How should the condition be updated?
4. What is the process being repeated?
5. How should the process be initialized?
6. How should the process be updated?
7. What is the state of the program on exiting the loop?
We use these questions as a checklist. The first three help us design the parts of the loop that
control its execution. The next three help us design the processing within the loop. The last
question reminds us to make sure that the loop exits in an appropriate manner.
Designing the Flow of Control
The most important step in loop design is deciding what should make the loop stop. If the
termination condition isn’t well thought out, our program might potentially contain infinite loops
and other mistakes. So here is our first question:
What is the condition that ends the loop?
This question usually can be answered through a close examination of the problem statement.
The following table lists some examples:
Key Phrase in Problem Statement
Termination Condition
“Sum 365 temperatures”
The loop ends when a counter reaches 365 (count-
controlled loop).
“Process all the data in the file”
The loop ends when EOF occurs (EOFcontrolled
loop).
“Process until 10 odd integers have
been read”
The loop ends when 10 odd numbers have been input
(event counter).

“The end of the data is indicated by a
negative test score”d
The loop ends when a negative input value is
encountered (sentinel-controlled loop).
Now we need statements that make sure the loop gets started correctly and statements
that allow the loop to reach the termination condition. At this point, we ask the next two
questions:
How should the condition be initialized?
How should the condition be updated?
The answers to these questions depend on the type of termination condition.
Count-Controlled Loops
If the loop is count controlled, we initialize the condition by giving the loop control variable an
initial value. For count-controlled loops in which the loop control variable is also an iteration
counter, the initial value is usually 1. If the process requires the counter to run through a
specific range of values, the initial value should be the lowest value in that range.
The condition is updated by increasing the value of the counter by 1 for each iteration.
(Occasionally, you may come across a problem that requires a counter to count from some
value down to a lower value. In this case, the initial value is the greater value, and the counter
is decremented by 1 for each iteration.) So, for count-controlled loops that use an iteration
counter, these are the answers to the key questions:
Initialize the iteration counter to 1.
Increment the iteration counter at the end of each iteration.
If the loop is controlled by a variable that is counting an event within the loop, the control
variable is usually initialized to 0 and is incremented each time the event occurs. For count-
controlled loops that use an event counter, these are the answers to the key questions:
Initialize the event counter to 0.
Increment the event counter each time the event occurs.
Sentinel-Controlled Loops
In sentinel-controlled loops, a priming read may be the only initialization necessary. If the
source of input is a file rather than the keyboard, it may also be necessary to open the file in
preparation for reading. To update the condition, a new value is read at the end of each
iteration. So, for sentinel-controlled loops, we answer our key questions this way:
Open the file, if necessary, and input a value before entering the loop (priming read).
Input a new value for processing at the end of each iteration.
EOF-Controlled Loops

EOF-controlled loops require the same initialization as sentinel-controlled loops. You must
open the file, if necessary, and perform a priming read. Updating the loop condition happens
implicitly; the stream state is updated to reflect success or failure every time a value is input.
However, if the loop doesn’t read any data, it can never reach EOF; thus updating the loop
condition means the loop must keep reading data.
Flag-Controlled Loops
In flag-controlled loops, the Boolean flag variable must be initialized to true or false and then
updated when the condition changes.
Initialize the flag variable to true or false, as appropriate.
Update the flag variable as soon as the condition changes.
In a flag-controlled loop, the flag variable essentially remains unchanged until it is time for
the loop to end. Then the code detects some condition and changes the value of the flag.
Because the update depends on what the process does, sometimes we may have to design
the process before we can decide how to update the condition.
Designing the Process Within the Loop
Once we’ve selected the type of looping structure, we can fill in the details of the process. In
designing the process, we first decide what we want a single iteration to do. Assume for a
moment that the process will execute only once. Which tasks must the process perform?
What is the process being repeated?
To answer this question, we have to take another look at the problem statement. The definition
of the problem may require the process to sum up data values or to keep a count of data
values that satisfy some test. For example:
Count the number of integers in the file howMany.
This statement tells us that the process to be repeated is a counting operation.
Here’s another example:
Read a stock price for each business day in a week and compute the average price.
In this case, part of the process involves reading a data value. We conclude from our
knowledge of how an average is computed that this process must also involve summing the
data values.
In addition to counting and summing, another common loop process is reading data,
performing a calculation, and writing out the result. Many other operations can appear in
looping processes. We’ve mentioned only the simplest here; we look at some other
processes later on.
After we’ve determined the operations to be performed if the process is executed only once,
we design the parts of the process that are necessary for it to be repeated correctly. We often
have to add some steps to account for the fact that the loop executes more than once. This
part of the design typically involves initializing certain variables before the loop and then

reinitializing or updating them before each subsequent iteration, and it leads to our next two
questions:
How should the process be initialized?
How should the process be updated?
For example, if the process within a loop requires that several different counts and sums be
performed, each must have its own statements to initialize variables, increment counting
variables, or add values to sums. Just deal with each counting or summing operation by itself
—that is, first write the initialization statement, and then write the incrementing or summing
statement. After you’ve done this for one operation, go on to the next.
The Loop Exit
When the termination condition occurs and the flow of control passes to the statement
following the loop, the variables used in the loop still contain values. If the cin stream has been
used, the reading marker has also been left at some position in the stream. Or maybe an
output file has new contents. If these variables or files are used later in the program, the loop
must leave them in an appropriate state. Thus the final step in designing a loop is answering
this question:
What is the state of the program on exiting the loop?
To answer this question, we have to consider the consequences of our design and double-
check its validity. For example, suppose we’ve used an event counter and that later
processing depends on the number of events. It’s important to make sure (with an algorithm
walk-through) that the value left in the counter is the exact number of events—that it is not off
by 1. Off-by-one bugs are sometimes referred to as OBOBs.
Look at this code segment:
Description
This loop reads characters from an input line and counts the number of commas on the line.
However, when the loop terminates, commaCount equals the actual number of commas plus 1
because the loop initializes the event counter to 1 before any events take place. By

determining the state of commaCount at loop exit, we’ve detected a flaw in the initialization.
commaCount should be initialized to 0.
Designing correct loops depends as much on experience as it does on the application of
design methodology. At this point, you may want to read through the Problem-Solving Case
Study at the end of the chapter to see how the loop design process is applied to a real
problem.
QUICK CHECK
6.4.1 Which type of loop would you use to read a file of drivers’ license numbers until
a specific number is input?
6.4.2 Write the initialization and update portions for the termination condition of the loop
in Question 6.3.5. The variable found becomes true when the int variable inData
contains 0. The count starts at 1 and is incremented in each iteration.
6.4.3 What are the seven points to consider in designing a loop?
6.4.4 Write a loop that will count the number of lines of an input file named inFile.
Assume that you have the variables inChar of type char to store the current character
in the file and lineCount of type int to keep track of the number of lines.

6.5 Nested Logic
Just as we can nest If statements, we can nest While statements. By nesting, we can create
even more powerful control structures.
Suppose we want to extend our code for counting commas on one line, repeating it for all
the lines in a file. We just have to nest it inside an EOF-controlled loop:
Description
Because both of these loops read from the same file and need a priming read, we moved the
priming read from just before the inner (comma-counting) loop to just before the outer (EOF-
controlled) loop. That way, it primes both loops with a single read. It would be a mistake to
include another priming read just before the inner loop, because the character read by the
outer priming read would be destroyed before we could test it.
Let’s examine the general pattern of a simple nested loop. The dots represent places where
the processing and update may take place in the outer loop.

Description
Notice that each loop has its own initialization, test, and update operation. It’s possible for an
outer loop to do no processing other than to execute the inner loop repeatedly. Conversely, the
inner loop might be just a small part of the processing done by the outer loop; there could be
many statements preceding or following the inner loop.
Let’s look at another example. For nested count-controlled loops, the pattern looks like this
(where outCount is the counter for the outer loop, inCount is the counter for the inner loop, and
limit1 and limit2 are the number of times each loop should be executed):
Description

Here, both loops are count-controlled loops, but the pattern can be used with any combination
of loops.
The following program shows a count-controlled loop nested within an event-controlled loop.
The outer loop inputs an integer value telling how many asterisks to display across a row of
the screen.
Description
Output:

Description
To see how this code works, let’s trace its execution with the data values shown in the
sample session. Notice that the event that controls the loop is entering a letter when cin
expects a number. This puts the input stream into the fail state, returning false when tested.
We’ll keep track of the variables starCount and loopCount, as well as the logical
expressions. To do so, we’ve numbered each line within the loops (except those containing
only a left or right brace). As we trace the program, we indicate the first execution of line 3 by
3.1, the second by 3.2, and so on. Each loop iteration is enclosed by a large brace, and true
and false are abbreviated as T and F (see Table 6.1).
Because starCount and loopCount are variables, their values remain the same until they are
explicitly changed, as indicated by the repeating values in Table 6.1. The values of the logical
expressions cin and loopCount <= starCount exist only when the test is made. We indicate
this fact with dashes in those columns at all other times.

Description
Designing Nested Loops
To design a nested loop, we begin with the outer loop. The process being repeated includes
the nested loop as one of its steps. Because that step is more complex than a single
statement, our functional decomposition methodology tells us to make it a separate module.
We can come back to it later and design the nested loop just as we would any other loop.
For example, here’s the design process for the preceding code segment:
1. What is the condition that ends the loop? 'Q' entered.
2. How should the condition be initialized? A priming read should be performed before the
loop starts.

3. How should the condition be updated? An input statement should occur at the end of
each iteration.
4. What is the process being repeated? Using the value of the current input integer, the code
should display that many asterisks across one output line.
5. How should the process be initialized? No initialization is necessary.
6. How should the process be updated? A sequence of asterisks is output and then a
newline character is output. There are no counter variables or sums to update.
7. What is the state of the program on exiting the loop? The cin stream is in the fail state,
starCount contains the last integer read, and the rows of asterisks have been displayed
along with a concluding message.
From the answers to these questions, we can write this much of the algorithm:
Read starCount
WHILE Stream okay
   Output starCount asterisks
   Output newline
   Prompt
   Read starCount
Output “Goodbye”
After designing the outer loop, it’s obvious that the process in its body requires us to design
an inner loop, so we repeat the methodology for the corresponding lower-level module:
1. What is the condition that ends the loop? An iteration counter exceeds the value of
starCount.
2. How should the condition be initialized? The iteration counter should be initialized to 1.
3. How should the condition be updated? The iteration counter is incremented at the end of
each iteration.
4. What is the process being repeated? Output a single asterisk on the standard output
device.
5. How should the process be initialized? No initialization is needed.
6. How should the process be updated? No update is needed.
7. What is the state of the program on exiting the loop? A row of asterisks has been
displayed, the writing marker is at the end of the current line, and loopCount is one greater
than the current value of starCount.
Now we can write the algorithm:
Read starCount
WHILE Stream okay

  Set loopCount = 1
  WHILE loopCount <= starCount
   Output ‘*’
   Increment loopCount
  Output newline
  Read starCount
Output “Goodbye”
Of course, nested loops themselves can contain nested loops (called doubly nested loops),
which can also contain nested loops (triply nested loops), and so on. You can use this design
process for any number of levels of nesting. The trick is to defer details by using the functional
decomposition methodology—that is, focus on the outermost loop first and treat each new
level of nested loop as a module within the loop that contains it.
It’s also possible for the process within a loop to include more than one loop. For example,
we rewrote the chessboard program earlier in this chapter using a loop. Now let’s rewrite it
again, this time using two loops nested within the outer loop. Here is the algorithm followed by
the code.
Chessboard program
Set up whiteRow
Set up blackRow
Set loopCount to 0
WHILE loopCount < 4
   Output whiteRows
   Output blackRows
   Increment loopCount
  
Output whiteRows
Set loopCount2 to 0
WHILE loopCount2 < 5
   Output whiteRow
   Increment loopCount2
  
Output blackRows
Set loopCount2 to 0
WHILE loopCount 2 < 5
   Output blackRow
   Increment loopCount2


Description
THEORETICAL FOUNDATIONS Analysis of Algorithms
If you were given the choice of cleaning a room with a toothbrush or a broom, you probably
would choose the broom. Using a broom sounds like less work than using a toothbrush.
True, if the room were in a dollhouse, it might be easier to use the toothbrush, but in
general a broom is the faster way to clean. If you were given the choice of adding numbers
together with a pencil and paper or a calculator, you would probably choose the calculator
because it is usually less work. If you were given the choice of walking or driving to a
meeting, you would probably choose to drive; it sounds like less work.
What do these examples have in common? In each situation, one of the choices seems
to involve less work. Precisely measuring the work is difficult because there are
unknowns. How large is the room? How many numbers are there? How far away is the
meeting? In each case, the unknown information is related to the size of the problem. If the
problem is especially small (for example, adding 2 plus 2), our original choice of approach
(calculator) might be wrong. However, our intuition is usually correct, because most
problems are reasonably large.
In computer science, we need a way of measuring the work done by an algorithm
relative to the size of a problem. There is usually more than one algorithm to solve a given
problem, and we must choose the most efficient one—the one that does the least work for
a given size.
The amount of work involved in executing an algorithm relative to the size of the problem
is called the complexity of the algorithm. We would like to be able to look at an algorithm
and determine its complexity. Then we could take two algorithms that perform the same
task and determine which is more efficient (requires less work).
Complexity A measure of the effort expended by the computer in performing a
computation, relative to the size of the computation.
How do we measure the work required to execute an algorithm? We use the total
number of steps executed as a measure. One statement, such as an assignment, may
require only one step; another, such as a loop, may require many steps. We define a step
as any operation roughly equivalent in complexity to a comparison, an I/O operation, or an
assignment.

Given an algorithm with just a sequence of simple statements (no branches or loops),
the number of steps is directly related to the number of statements. When we introduce
branches, however, we make it possible to skip statements in the algorithm. But because
we usually want to express work in terms of the worst-case scenario, we use the number
of steps in the longest branch.
Now consider that if a loop repeats a sequence of 15 simple statements 10 times, it
performs 150 steps. Loops allow us to multiply the work done in an algorithm without
physically adding statements.
Now consider that if a loop repeats a sequence of 15 simple statements 10 times, it
performs 150 steps. Loops allow us to multiply the work done in an algorithm without
physically adding statements.
Now that we have a measure for work, we can compare algorithms. For example, if
algorithm A always executes 3124 steps and algorithm B always does the same task in
1321 steps, then we can say that algorithm B is more efficient—that is, it takes fewer
steps to accomplish the same task.
If an algorithm always takes the same number of steps or fewer, we say that it executes
in an amount of time bounded by a constant. Such algorithms are referred to as having
constant-time complexity. Be careful: Constant time doesn’t mean small; it means that the
work does not exceed some amount from one run to another. When a loop executes a
fixed number of times, the work is greater than the physical number of statements but is
still constant.
What if the number of iterations changes from one run to the next? Suppose a file
contains N data values to be processed in a loop. If the loop reads and processes one
value per iteration, then it executes N iterations. The amount of work depends on a
variable, the number of data values. N determines the size of the problem in this example.
If a loop executes N times, the total number of steps is N times the number of steps in a
single iteration of the loop. Specifically, the work done by an algorithm with an N-iteration
loop is given by the following expression:
Description
where S1 is the number of steps in the loop body (a constant for a simple loop), N is the
number of iterations (a variable representing the size of the problem), and S0 is the
number of steps outside the loop. Mathematicians call expressions of this form linear;
hence, algorithms such as this are said to have linear-time complexity. Notice that if N
grows very large, the term S1 × N dominates the execution time; that is, S0 becomes an
insignificant part of the total execution time. For example, if S0 and S1 are each 20 steps,
and N is 1,000,000, then the total number of steps is 20,000,020. The 20 steps contributed
by S0 are a tiny fraction of the total.
What about a data-dependent loop that contains a nested loop? The number of steps in
the inner loop, S2, and the number of iterations performed by the inner loop, L, must be

multiplied by the number of iterations in the outer loop:
Description
By itself, the inner loop performs S2 × L steps, but because it is repeated N times by the
outer loop, it accounts for a total of S2 × L × N steps. If L is a constant, then the algorithm
still executes in linear time.
Now suppose that for each of the N outer loop iterations, the inner loop performs N
steps (L = N ). Here the formula for the total steps is
Description
or
Description
Because N2 grows much faster than N (for large values of N ), the inner loop term (S2 ×
N2) accounts for the majority of steps executed and of the work done. The corresponding
execution time is thus essentially proportional to N 2. Mathematicians call this type of
formula quadratic. If we have a doubly nested loop in which each loop depends on N, then
the expression is
Description
and the work and time are proportional to N3 whenever N is reasonably large. Such a
formula is called cubic.
The following table shows the number of steps required for each increase in the
exponent of N, where N is a size factor for the problem, such as the number of input
values.

Description
As you can see, each time the exponent increases by 1, the number of steps is
multiplied by an additional order of magnitude (factor of 10); that is, if N is made 10 times
greater, the work involved in an N 2 algorithm increases by a factor of 100, and the work
involved in an N 3 algorithm increases by a factor of 1000. To put this in more concrete
terms, an algorithm with a doubly nested loop in which each loop depends on the number
of data values takes 1000 steps for 10 input values and 1 quadrillion steps for 100,000
values. On a computer that executes 1 billion instructions per second, the latter case
would take about 12 days to run.
The table also shows that the steps outside of the innermost loop account for an
insignificant portion of the total number of steps as N gets bigger. Because the innermost
loop dominates the total time, we classify the complexity of an algorithm according to the
highest order of N that appears in its complexity expression, called the order of magnitude,
or simply the order, of that expression. So we talk about algorithms having “order N
squared complexity” (or cubed or so on) or we describe them with what is called Big-O
notation. We express the complexity by putting the highest-order term in parentheses with
a capital O in front. For example, O(1) is constant time, O(N) is linear time, O(N2) is
quadratic time, and O(N 3) is cubic time.
Determining the complexities of different algorithms allows us to compare the work they
require without having to program and execute them. For example, if you had an O(N 2)
algorithm and a linear algorithm that performed the same task, you probably would choose
the linear algorithm. We say probably because an O(N 2) algorithm actually may execute
fewer steps than an O(N) algorithm for small values of N. Remember that if the size factor
N is small, the constants and lower-order terms in the complexity expression may be
significant.
Let’s look at an example. Suppose that algorithm A is O(N 2) and that algorithm B is
O(N). For large values of N, we would normally choose algorithm B because it requires
less work than A. But suppose that in algorithm B, S0 = 1000 and S1 = 1000. If N = 1, then
algorithm B takes 2000 steps to execute. Now suppose that for algorithm A, S0 = 10, S1 =
10, and S2 = 10. If N = 1, then algorithm A takes only 30 steps. Here is a table that
compares the number of steps taken by these two algorithms for different values of N.

N
Algorithm A
Algorithm B
1
30
2000
2
70
3000
3
130
4000
10
1110
11,000
20
4210
21,000
N
Algorithm A
Algorithm B
30
9310
31,000
50
25,510
51,000
100
101,010
101,000
1000
10,010,010
1,001,000
10,000
1,000,100,010
10,001,000
From this table we can see that the O(N 2) algorithm A is actually faster than the O(N)
algorithm B, up to the point that N equals 100. Beyond that point, algorithm B becomes
more efficient. Thus, if we know that N is always less than 100 in a particular problem, we
would choose algorithm A. For example, if the size factor N is the number of test scores
on an exam and the class size is limited to 30 students, algorithm A would be more
efficient. Conversely, if N is the number of scores at a university with 25,000 students, we
would choose algorithm B.
Constant, linear, quadratic, and cubic expressions are all examples of polynomial
expressions. Algorithms whose complexity is characterized by such expressions are,
therefore, said to execute in polynomial time and form a broad class of algorithms that
encompasses everything we’ve discussed so far.
In addition to polynomial-time algorithms, there are logarithmic-time, factorial (O(N!)),
exponential (O(NN)), and hyperexponential (O(NNN )) classes of algorithms, which can
require vast amounts of time to execute and are beyond the scope of this text. For now,
the important point to remember is that different algorithms that solve the same problem
can vary significantly in the amount of work they do.
QUICK CHECK
6.5.1 Write a loop that will output the total number of characters per line (excluding the
'\n' character) from an input file named inFile. Assume that you have the variable
inChar of type char used to store the current character, lineCount of type int to keep
track of the number of lines, and count of type int to keep track of the number of
characters.
6.5.2 What is the term that refers to measuring the work performed by an algorithm?
6.5.3 What measurement is used to determine the amount of work performed by an
algorithm?
6.5.4 How would you extend the loop from Question 6.3.7 so that it would be repeated
in its entirety five times?

Problem-Solving Case Study
RECORDING STUDIO DESIGN
PROBLEM: You’ve gone to work for a consulting firm that specializes in converting
existing rooms into recording studios. Your employers have asked you to write a program
that inputs a set of loudness measurements for a room and displays basic statistics. The
measurements are made by playing a series of 12 different tones and recording the
readings from a soundlevel meter onto a file. The meter readings range from 50 to 126
decibels (a measure of loudness). Your program, however, is to output the measurements
relative to the first tone— that is, to show how much each individual reading differs from
the first. After all the data have been read, the program is to output the highest and lowest
readings.
INPUT: Twelve real numbers, representing the meter readings, on file acoustic.dat.
OUTPUT
The 12 input values (echo print) and their values relative to the first reading
At the end of the program, the actual value, relative value, and sequence number of
both the highest reading and the lowest
DISCUSSION: This problem is easy to calculate by hand. We simply scan the list,
subtracting the first value from each value in the list. As we scan the list, we also keep
track of which value from the list is the highest and which is the lowest.
How do we translate this process into an algorithm? Let’s take a closer look at what we
are doing. To find the largest number in a list, we compare the first and second numbers
and remember the larger one. Then we compare that number with the third one,
remembering the larger number. We repeat the process for all of the numbers, and the one
we remember at the end is the largest. We use the same process to find the smallest
number, except that we remember the smaller number instead of the larger one.
Consider a sample data set:
Reading Number
Actual Reading
Relative Reading
1
86.0
0.0
2
86.5
0.5
3
88.0
2.0
4
83.5
–2.5
5
88.3
2.3
6
89.6
3.6
7
80.1
–5.9
Reading Number
Actual Reading
Relative Reading
8
84.0
–2.0
9
86.7
0.7
10
79.3
–6.7

11
74.0
–12.0
12
73.5
–12.5
The maximum reading for this data set was number 6 at 89.6 decibels. The lowest was
reading 12 at 73.5 decibels.
“Scan the list” in our by-hand algorithm translates into a loop. Now that we understand
the process, let’s design the looping algorithm using our checklist.
1. What is the condition that ends the loop? Because there are 12 values, we use a
counter to control the loop. When it exceeds 12, the loop exits.
2. How should the condition be initialized? The first value will be input before the loop
because it is a special case—it is the value that is subtracted from all the other values
to get their relative values. Also, its relative value is automatically 0.0. Thus, the first
iteration of the loop gets the second value, so the counter will start at 2.
3. How should the condition be updated? The counter should be incremented at the end
of each iteration.
4. What is the process being repeated? The process reads a value, echoes it, subtracts
the first value from it, outputs the result, and checks whether the new value should
replace the current high or low value.
5. How should the process be initialized? The first number must be read in. Its relative
value is automatically output as 0.0. It is the initial high and low, and it is also saved as
the base reading. The sequence number for both the high and low values will be set to
1 and their relative values will be 0.0.
6. How should the process be updated? In each iteration, a new current reading is input.
If the current reading is greater than high, it replaces the current high. If the current
reading is lower than the current low, it becomes the new low. We must also save the
reading number of the highest and lowest values, and their relative values.
7. What is the state of the program on exiting the loop? Twelve readings have been input
and echo printed together with 12 relative values. The loop control variable equals 13.
high contains the greatest value read, highNumber the number of that value, and
highRelative the relative value for that reading. low contains the lowest value,
lowNumber holds the number of that reading, and lowRelative has the corresponding
relative value.
ASSUMPTIONS: At least 12 real numbers will be input, and all will be within the proper
range.
Main Module
Level 0
Initialize process
Initialize loop ending condition
WHILE readingNumber <= 12 DO
Update process
Update ending condition
Output high and low readings
Close file

Initialize Process
Level 1
Open input file
IF not opened okay
Write error message
Return 1
Output heading for output
Get baseValue
Output readingNumber 1, baseValue, relativeValue 0.0
Set high to baseValue
Set highNumber to 1
Set highRelative to 0.0
Set low to baseValue
Set lowNumber to 1
Set lowRelative to 0.0
Initialize Loop Ending Condition
Set readingNumber to 2
Update Process
Get current
Set relative to current – baseValue
Output readingNumber, current, relative
Check for new high
Check for new low
Update Loop Ending Condition
Increment readingNumber
Output High and Low Readings
Output ‘Highest reading number is ’, highNumber
Output ‘Highest reading is ’, high
Output ‘Highest relative value is ’, highRelative
Output ‘Lowest reading number is ’, lowNumber
Output ‘Lowest reading is ’, low
Output ‘Lowest relative value is ’, lowRelative
Check for New High
Level 2
IF current > high
Set high to current
Set highNumber to readingNumber
Set highRelative to relative
Check for New Low

IF current < low
Set low to current
Set lowNumber to readingNumber
Set lowRelative to relative
MODULE STRUCTURE CHART
Description
Here is the program:


Description
Here is the output:

Description
Now that you have written the program, you call the president of the consulting firm and
email her the results. After studying the results, she is silent for a moment. “Oh. Right. I’m
sorry,” she says, “but I told you to keep track of the wrong value. We’re not interested in
the lowest value, but in the lowest dip in the readings. You see, the last value is almost
always the lowest because it’s the lowest tone, and we know that most rooms respond
poorly to bass notes. There’s nothing we can do about that. But the lowest dip in the
readings often occurs with a higher tone, and that’s usually a sign of a problem that we can
fix. Can you change the program to output the lowest dip?” You confirm that a dip is a
reading followed by a higher reading.
Now you have to figure out how to recognize a dip in the readings. You draw some
graphs with random squiggles on them and pick out the lowest dips by hand. Then you
make up some data sets that would generate the graphs. You find that a dip is usually a
series of decreasing values followed by increasing values. But it can also just be a series
of equal values followed by greater values. The bottom of a dip is merely the lowest value
before values start increasing. You know how to keep track of a lowest value, but how do
you tell if it is followed by a greater value?

Description
The answer is that you check for this condition after the next value is input; that is, when
you read in a new value, you check whether the preceding value was lower. If it was, then
you check whether it was the lowest value input so far. You’ve seen the algorithm for
keeping track of a previous value—now you just have to add it to the program.
Now we can return to the checklist and see what must change. The control of the loop
stays the same; only the process changes. Thus, we can skip the first three questions.
4. What is the process being repeated? It is the same as before, except where we
check for the lowest value. Instead, we first check whether the preceding value is less
than the current value. If it is, then we check whether preceding should replace the
lowest value so far. In replacing the lowest value, we must assign readingNumber
minus one to lowNumber, because the dip occurred with the previous reading. We
could also keep track of the previous value of readingNumber, but it is easier to
calculate it.
5. How should the process be initialized? The change here is that we must initialize
preceding. We can set it equal to the first value. We also have to initialize the
precedingRelative value to 0.0.
6. How should the process be updated? We add steps to set preceding equal to
current at the end of the loop, and to save Relative in precedingRelative for use in
the next iteration.

7. What is the state of the program on exiting the loop? At this point, preceding holds
the last value input and precedingRelative holds the last relative value computed. low
holds the value of the lowest dip, lowNumber contains the reading number of the lowest
dip, and lowRelative is the difference between the lowest dip and the first value.
Now let’s look at the modules that have changed. We’ll use highlighting to indicate the
steps that are different:
Initialize Process
Level 1
Open input file
If not opened okay
   Write error message
   Return 1
Output heading for output
Get baseValue
Output readingNumber 1, baseValue, relativeValue 0.0
Set preceding to baseValue
Set precedingRelative to 0.0
Set high to baseValue
Set highNumber to 1
Set highRelative to 0.0
Set low to baseValue
Set lowNumber to 1
Set lowRelative to 0.0
Update Process
Prompt for current
Get current
Set relative to current – baseValue
Output readingNumber, current, relative
Check for new high
Check for new low
Set preceding to current
Set precedingRelative to relative
Output High and Low Readings
Output ‘Highest reading number is ’, highNumber
Output ‘Highest reading is ’, high
Output ‘Highest relative value is ’, highRelative
Output ‘Lowest dip is number ’, lowNumber
Output ‘Lowest dip reading is ’, low
Output ‘Lowest relative dip is ’, lowRelative
Check for New Low

IF current > preceding
IF preceding < low
   Set low to preceding
   Set lowNumber to readingNumber – 1
   Set lowRelative to precedingRelative
Here’s the new version of the program:


Description
Here is the output:

Description

Graphical User Interface (GUI)
The case study program is an example of a looping algorithm. Now, we will extend it with a
GUI. In particular, we will add a graphical component to ask the user if they would like to get
meter readings from a file. If they do, the program will run as it did before. If the answer is “no,”
our new version will ask the user how many readings will be provided and what the base
loudness value is, and prompt the user for each of the loudness measurements. Lastly, we
will use a GUI widget to display the statistics.
We will be using five GUI components: YesNoDialog, FileDialog, IntDialog, Float-Dialog,
and OutputDialog. Four of these should be familiar, and IntDialog is very similar to
FloatDialog, which we saw in Chapter 5. We will also need a way to display formatted values
as in the original version; however, in our GUI version, instead of using cout, we are
displaying strings in GUI components. Fortunately, the C++ standard library provides a
special stream that acts like cout but writes to a string instead. This special stream is referred
to as an output string stream, and it allows us to easily replace cout without changing our
formatting code. Now, let us go line by line describing how to turn the original program into a
GUI application.
The Qt GUI library provides the components we need for this kind of interaction. Recall that
those components are known as dialogs. To build our GUI we need to access the Qt dialog
library by including the dialog.h header file. Furthermore, to get access to the output string
stream we must also include the sstream library, which provides a new type of object referred
to as an ostringstream. We will see shortly how to use this object to write formatted output to
a string. Here are the necessary Include statements:
Description
Inside the main function, along with the existing variables, we add a variable declaration for
our output string stream object:
Description
In the original program we used cout to initialize the output with a header:
Because ostringstream objects support the same stream operations as standard output
streams, we can simply replace cout with output and leave everything else the same:

Description
We can then replace all other uses of cout with output to write formatted output to a string. We
will explain later how we hand the formatted string to a GUI widget for display. Next, we want
our application to ask the user if they would like to retrieve frequency readings from a file or
enter them in manually. To do this we use a YesNoDialog widget:
Description
The display() method renders the widget to the screen, allowing the user to answer Yes or
No:
Description
When the user presses the Yes button, the return value of the display() method will be the
bool value true; otherwise, it will be false. The user response to this dialog determines two
possible paths in our program. If the user chooses Yes, we will use a FileDialog to allow the
user to choose a data file to read. If the user chooses No, we will allow the user to enter
frequency measurements manually. We determine which path to follow using an If statement:

Description
If response is true, we prompt the user to choose an input file using the FileDialog widget:
Description
The display() method puts a widget like this on the screen:
Description
The rest of the code in the true branch of the If statement is like the original program except
for replacing cout with output; that is, we iterate over each of the frequency values in the file
and use those values to compute statistics. This branch is done except for displaying the
results, which we look at later.

Next we see how to add GUI support if the user wants to enter frequency data manually.
We first need to ask the user how many frequencies will be provided as input and what the
base frequency value is. The following code fragment accomplishes this nicely:
Description
We declare an IntDialog to ask for the number of frequencies and a FloatDialog to ask for the
base frequency value. After calling the display method for each of these widgets, they appear
as follows:
Description

Description
The number of frequency values is recorded in the frequencyNumber variable, and the base
frequency value is assigned to the baseValue variable. Next, we initialize some variables that
depend on the base value and write the first line of output:
Description
The only change here is the replacement of cout with output. The remaining changes involve
reading in the number of frequency values the user specified and computing the statistics for
each input value. To do this, we modify the While loop of the original implementation in two
ways. First, we change the termination condition to use frequencyNumber instead of the
constant 12. Second, in the loop body, we use a GUI widget to prompt for each frequency
individually:

Description
The While loop’s termination condition is now based on the number of frequency values
requested by the user instead of the hardcoded 12 from the original version. On each pass
through the While loop, we create a new FloatDialog asking the user to enter a frequency
value. We also customize the FloatDialog's display to the number of the frequency value
being requested. Notice how we use the to_string function to change the integer value into a
string. For frequency values 2 and 3, the GUI display looks like this:
Description

Description
Each frequency value provided as input is used to calculate the statistics in each iteration of
the loop. After we have input the requested number of frequency values, we are done.
The final job of this program is to report the results back to the user. It doesn’t matter which
path our program took based on the Yes or No response from the user. Either way, the output
statistics are the same. We use an OutputDialog widget to display the results:
Description
Notice that we have replaced cout with output as we have done throughout the entire
program. We also declare a new OutputDialog. We need to initialize an OutputDialog widget
with a string, which we can get from an ostringstream object using its str() method. Here is
what the OutputDialog looks like when its display() method is called (given manual input of
five readings):

Description
The final version of our code is as follows, with highlighted portions representing the significant
parts that were changed from the original acoustics program.




Description

Testing and Debugging
Loop-Testing Strategy
Even if a loop has been properly designed and verified, it is still important to test it rigorously:
Errors can always creep in during implementation. Because loops allow us to input many data
sets in one run, and because each iteration may be affected by preceding ones, the test data
for a looping program is usually more extensive. To test a loop thoroughly, we must check for
the proper execution of both a single iteration and multiple iterations.
Remember that a loop has seven parts (corresponding to the seven questions in our
checklist). A test strategy must test each part. Although all seven parts aren’t implemented
separately in every loop, the checklist reminds us that some loop operations serve multiple
purposes, each of which should be tested. For example, the incrementing statement in a
count-controlled loop may be updating both the process and the ending condition, so it’s
important to verify that it performs both actions properly with respect to the rest of the loop.
To test a loop, we try to devise data sets that could cause the variables to go out of range or
leave the files in improper states that violate either the loop postcondition (an assertion that
must be true immediately after loop exit) or the postcondition of the module containing the
loop.
It’s also good practice to test a loop for four special cases: (1) when it is skipped entirely, (2)
when the body is executed just once, (3) when it executes some normal number of times, and
(4) when the loop fails to exit.
Statements following a loop often depend on its processing. If a loop can be skipped, those
statements may not execute correctly. If it’s possible to execute a single iteration of a loop, the
results can show whether the body performs correctly in the absence of the effects of
previous iterations; this strategy can be very helpful when you’re trying to isolate the source of
an error. Obviously, it’s important to test a loop under normal conditions, with a wide variety of
inputs. If possible, you should test the loop with real data in addition to mock data sets. Count-
controlled loops should be tested to confirm they execute exactly the right number of times.
Finally, if there is any chance that a loop might never exit, your test data should try to make
that happen.
Testing a program can be as challenging as writing it. To test a program, you need to step
back, take a fresh look at what you’ve written, and then attack it in every way possible to
make it fail. This isn’t always easy to do, but it’s necessary to ensure that your programs are
reliable. (A reliable program works consistently and without errors regardless of whether the
input data are valid or invalid.)
Test Plans Involving Loops
In Chapter 5, we introduced formal test plans and discussed the testing of branches. Those
guidelines still apply to programs with loops, but here we provide some additional guidelines
that are specific to loops.
Unfortunately, when a loop is embedded in a larger program, it may be difficult to control and
observe the conditions under which the loop executes using test data and output alone. In

some cases we must use indirect tests. For example, if a loop reads floating-point values
from a file and outputs their average without echo printing them, you cannot tell directly that
the loop processes all the data—if the data values are all the same, then the average appears
correct as long as even one of them is processed. You must construct the input file so that the
average is a unique value that can be arrived at only by processing all the data.
To simplify our testing of such loops, we would like to observe the values of the variables
associated with the loop at the start of each iteration. How can we observe the values of
variables while a program is running? Two common techniques are to use the system’s
debugger program and to include extra output statements designed solely for debugging
purposes. We discuss these techniques in the “Testing and Debugging Hints” section.
Now let’s look at some test cases that are specific to the different types of loops we’ve
seen in this chapter.
Count-Controlled Loops
When a loop is count controlled, you should include a test case that specifies the output for all
the iterations. It may help to add an extra column to the test plan that lists the iteration number.
If the loop reads data and outputs a result, then each input value should produce a different
output to make it easier to spot errors. For example, in a loop that is supposed to read and
display 100 data values, it is easier to tell that the loop executes the correct number of
iterations when the values are 1, 2, 3, . . . , 100 than when they are all the same.
If the program inputs the iteration count for the loop, you need to test the cases in which an
invalid count, such as a negative number, is input (an error message should be output and the
loop should be skipped), a count of 0 is input (the loop should be skipped), a count of 1 is input
(the loop should execute once), and some typical number of iterations is input (the loop should
execute the specified number of times).
Event-Controlled Loops
In an event-controlled loop, you should test the situation in which the event occurs before the
loop, in the first iteration, and in a typical number of iterations. For example, if the event is that
EOF occurs, then try test data consisting of an empty file, a file with one data set, and another
file with several data sets. If your testing involves reading from test files, you should attach
copies of the files to the test plan and identify each in some way so that the plan can refer to
them. It also helps to identify where each iteration begins in the Input and Expected Output
columns of the test plan.
When the event is the input of a sentinel value, you need the following test cases: The
sentinel is the only data set, the sentinel follows one data set, and the sentinel follows a typical
number of data sets. For file input, you should also try a case where the file omits the sentinel.
Given that sentinel-controlled loops involve a priming read, it is especially important to verify
that the first and last data sets are processed properly.
Testing and Debugging Hints
1. Plan your test data carefully to test all sections of a program.
2. Beware of infinite loops, in which the expression in the While statement never
becomes false. The symptom: The program doesn’t stop.

If you have created an infinite loop, check your logic and the syntax of your loops. Be sure
no semicolon appears immediately after the right parenthesis of the While condition:
Description
This semicolon causes an infinite loop in most cases; to the compiler, the loop body is the null
statement. In a count-controlled loop, make sure the loop control variable is incremented
within the loop. In a flag-controlled loop, make sure the flag eventually changes.
As always, watch for the = versus == problem in While conditions as well as in If conditions.
The line
Description
produces an infinite loop. The value of the assignment (not relational) expression is always 5,
which is interpreted as true.
3. Check the loop termination condition carefully and be sure that something in the loop
causes it to be met. Watch closely for values that cause one iteration too many or too few
(the “off-by-one-bug” syndrome).
4. Remember to use the get function rather than the >> operator in loops that are
controlled by detection of a newline character.
5. Perform an algorithm walk-through to verify that all of the appropriate preconditions and
postconditions occur in the right places.
6. Trace the execution of the loop by hand with a code walk-through. Simulate the first
few passes and the last few passes very carefully to see how the loop really behaves.
7. Use a debugger if your system provides one. A debugger is a program that runs your
program in “slow motion,” allowing you to execute one instruction at a time and to
examine the contents of variables as they change. If you haven’t already done so, check
whether a debugger is available on your system.
8. If all else fails, use debug output statements—output statements inserted into a
program to help debug it. They output messages that indicate the flow of execution in the
program or report the values of variables at certain points in the program.
For example, if you want to know the value of variable beta at a certain point in a program,
you could insert this statement:
Description

If this output statement appears in a loop, you will get as many values of beta output as there
are iterations of the body of the loop.
After you have debugged your program, you can remove the debug output statements or
just precede them with // so that they’ll be treated as comments. (This practice is referred to
as commenting out a piece of code.) You can remove the double slashes if you need to use
the statements again.
9. An ounce of prevention is worth a pound of debugging. Use the checklist questions to
design your loop correctly at the outset. It may seem like extra work, but it pays off in the
long run.

Summary
The While statement is a looping construct that allows a program to repeat a statement as
long as the value of an expression is true. When the value of the While expression
becomes false, the body of the loop is skipped and execution continues with the first
statement following the loop. With the While statement, you can construct both count-
controlled loops and event-controlled loops.
In a count-controlled loop, the loop body is repeated a specified number of times. You
initialize a counter variable right before the While statement. This loop control variable is
then tested against the limit in the While expression. The last statement in the loop body
increments the control variable.
Event-controlled loops continue executing until something inside the body signals that
looping should stop. Event-controlled loops include those that test for a sentinel value, for
end of file, or for a change in a flag variable.
Sentinel-controlled loops are input loops that use a special data value as a signal to stop
reading. EOF-controlled loops are loops that continue to input (and process) data values
until no more data remain. To implement them with a While statement, you must test the
state of the input stream by using the name of the stream object as if it were a Boolean
variable. The test yields false when there are no more data values. A flag is a variable that
is set in one part of the program and tested in another part of the program. In a flag-
controlled loop, you must set the flag before the loop begins, test it in the While expression,
and change it in the body of the loop.
Counting is a looping operation that keeps track of how many times a loop is repeated or
how many times some event occurs. This count can be used in computations or to control
the loop. A counter is a variable that is used for counting. It may take the form of a loop
control variable in a count-controlled loop, an iteration counter in a counting loop, or an
event counter that counts the number of times a particular condition occurs in a loop.
Summing is a looping operation that keeps a running total of certain values. It is like
counting in that the variable that holds the sum is initialized outside the loop. The summing
operation, however, adds up unknown values; the counting operation adds a constant (1)
to the counter each time.
When you design a loop, you should consider seven points: how the termination
condition is initialized, tested, and updated; how the process in the loop is initialized,
performed, and updated; and the state of the program upon exiting the loop. By answering
the checklist questions, you can bring each of these points into focus.
To design a nested loop structure, begin with the outermost loop. When you get to where
the inner loop must appear, make it a separate module and come back to its design later.
The process of testing a loop is based on the answers to the checklist questions and the
patterns the loop might encounter (for example, executing a single iteration, multiple
iterations, an infinite number of iterations, or no iterations at all).

Quick Check Answers
6.1.1 While statement. 6.1.2 bool 6.1.3 It is coerced to false for a zero value and true for
any nonzero value. 6.1.4 repeat 6.2.1 Entry, iteration, test, exit. 6.3.1 Count-controlled
loops and event-controlled loops. 6.3.2 Count-controlled loop: Hop on one foot 10 times;
event-controlled loop: Hop on one foot until you are tired. 6.3.3 Both types of loops exit
when an event occurs. The sentinel-controlled loop tests for the event at the start of each
iteration, whereas the flag-controlled loop checks for the event in the middle of the iteration,
setting a flag to be tested at the start of the next iteration. 6.3.4 Both. 6.3.5 while (count <=
10 && !found)
6.3.6 
Description
6.3.7 

Description
6.4.1 An event-controlled loop. (The events would be the input of the number or reaching
end-of-file.)
6.4.2 
Description
6.4.3 (1) What is the condition that ends the loop? (2) How should the condition be
initialized? (3) How should the condition be updated? (4) What is the process being
repeated? (5) How should the process be initialized? (6) How should the process be
updated? (7) What is the state of the program on exiting the loop?
6.4.4 
Description

6.5.1 
Description
6.5.2 Complexity. 6.5.3 The total number of steps required to execute an algorithm. 6.5.4
Nest it within a counting loop that counts from 1 to 5.

Exam Preparation Exercises
6.1 The While statement exits when the termination condition becomes true. True or
false?
6.2 The body of the While statement is always executed at least once. True or false?
6.3 Using a block as the body of the While statement enables us to place any number
of statements within a loop. True or false?
6.4 Match the following list of terms with the definitions given below.
a. Loop entry
b. Iteration
c. Loop test
d. Loop exit
e. Termination condition
f. Count-controlled loop
g. Event-controlled loop
h. Iteration counter
i. Event counter
i. A loop that executes a specified number of times
ii. When the flow of control reaches the first statement inside a loop
iii. A variable that is incremented each time a particular condition is encountered
iv. When the decision is made whether to begin a new iteration or to exit
v. A loop that exits when a specific condition is encountered
vi. The condition that causes the loop to exit
vii. A variable that is incremented with each iteration of a loop
viii. When control passes to the statement following the loop
ix. An individual pass through a loop
6.5 How many times does the following loop execute, and what is its output?

Description
6.6 How many times does the following loop execute, and what is its output?
Description
6.7 How many times does the following loop execute, and what is its output?
Description
6.8 What does the following nested loop structure output?

Description
6.9 What does the following nested loop structure output?
Description
6.10 The following loop is supposed to sum all of the input values on file indata.
What’s wrong with it? Change the code so that it works correctly.

Description
6.11 Which sentinel value would you choose for a program that reads names as
strings?
6.12 The following code segment is supposed to write out the odd numbers from 1 to
19. What does it actually output? Change the code so that it works correctly.
Description
6.13 Priming reads aren’t necessary when a loop is controlled by a sentinel value.
True or false?
6.14 What are the seven questions that must be answered to design a loop?
6.15 The following code segment is supposed to output the average of the five
numbers on each input line for all of the lines in the file. Instead, it simply outputs the
sum of all of the numbers in the file. What’s wrong with the code segment? Change
the code so that it works correctly.

Description

Programming Warm-Up Exercises
6.1 Write a code segment using a While loop that outputs the numbers from –10 to 10.
6.2 Write a code segment using a While loop that sums the integers, counting up from
1, and stops when the sum is greater than 10,000, displaying the integer that was
most recently added to the sum.
6.3 Write a looping code segment that takes as input up to 20 integer scores from file
indata and outputs their average. If the file contains fewer than 20 scores, the
segment should still output the correct average. If the file contains more than 20
scores, the additional numbers should be ignored. Be sure to consider what happens
if the file is empty.
6.4 Write a code segment that reads lines of text from file chapter6 and outputs the
number of lines in the file that contain the string “code segment”.
6.5 Write a code segment that reads a string from cin. The string should be one of the
following: “Yes”, “No”, “yes”, or “no”. If it is not, the user should be prompted to input
an appropriate response, and the process should repeat. Once a valid response is
received, the bool variable yes should be assigned true if the response is “Yes” or
“yes” and false if the response is “No” or “no”.
6.6 Write a code segment that outputs the days of a month in calendar format. The
day of the week on which the month begins is represented by an int variable
startDay. When startDay is zero, the month begins on a Sunday. The int variable
days contains the number of days in the month. Display a heading with the days of the
week as the first line of output. The day numbers should be neatly aligned under these
column headings.
6.7 We could extend the code from Exercise 6.6 to display a calendar for a year by
nesting it within a loop that repeats the code 12 times.
a. Which formula would you use to compute the new start day for the next
month?
b. Which additional information would you need to display the calendar for each
month?
6.8 Write a code segment that reads all of the characters on file textData and then
outputs the percentage of the characters that are the letter 'z'.
6.9 Change the code segment in Exercise 6.8 so that it stops reading either at the end
of the file or after 10,000 characters have been input.

6.10 Write a code segment that outputs the Fibonacci numbers that are less than
30,000. Each Fibonacci number is the sum of its two predecessors. The first two
Fibonacci numbers are 1 and 1. Thus, the sequence begins with
1, 1, 2, 3, 5, 8, 13, 21, 34, . . .
Output each number on a separate line.
6.11 Modify the code segment in Exercise 6.10 so that it also outputs the position of
the Fibonacci number in the sequence. For example:
1
1
2
1
3
2
4
3
5
5
6
8
7
13
6.12. Write a code segment that inputs an integer from cin and then outputs a row of
that many stars on cout.
6.13. How did you answer the loop checklist questions for the code segment you
wrote in Exercise 6.12?
6.14. Change the code segment for Exercise 6.12 to read a series of numbers from
file indata and display a row of stars on cout for each number read. (You can think of
this problem as outputting a bar graph of a data file.)
6.15. What sort of test data would you use to test the code segment in Exercise 6.14?

Programming Problems
6.1 Write a C++ program that computes student grades for an assignment as a
percentage given each student’s score and the total points. The final score should be
rounded up to the nearest whole value using the ceil function in the <cmath> header
file. You should also display the floating-point result up to five decimal places. The
input to the program must come from a file containing multiple lines with students’ last
names, scores, and totals separated by a space. In addition, you should output to the
console “Excellent” if the grade is greater than 90, “Well Done” if the grade is greater
than 80, “Good” if the grade is greater than 70, “Need Improvement” if the grade is
greater than or equal to 60, and “Fail” if the grade is less than 60. Here is an example
of what the input file might look like:
Description
The output of your program should look like this:
Description
6.2 ROT13 (rotate by 13 places) is a simple letter substitution cipher that is an
instance of a Caesar cipher developed in ancient Rome and used by Julius Caesar in
his private correspondence. ROT13 replaces a letter with the letter 13 letters after it in
the alphabet. The following table demonstrates the translation in ROT13:

A
↔
N
B
↔
O
C
↔
P
D
↔
Q
E
↔
R
F
↔
S
G
↔
T
H
↔
U
I
↔
V
J
↔
W
K
↔
X
L
↔
Y
M
↔
Z
Thus, the translation of the word JULIUS using ROT13 would be WHYVHF. Write a C++
program that asks the user for the name of an input file and translates the contents of that
input file using ROT13. Your program should output the translation into a secondary file
with a .rot13 file extension. The uppercase ASCII characters, in order, go from A = 65 to Z
= 90. Recalling that type char is an integral type, you should be able to derive a formula to
translate a character into ROT13.
6.3. Design and write a C++ program that inputs a series of 24 hourly temperatures
from a file and outputs a bar chart (using stars) of the temperatures for the day. The
temperature should be displayed to the left of the corresponding bar, and there should
be a heading that gives the scale of the chart. The range of temperatures should be
from –30 to 120. Because it is hard to display 150 characters on the screen, you
should have each star represent a range of 3 degrees. That way, the bars will be at
most 50 characters wide. Here is a partial example, showing the heading, the output
for a negative temperature, and the output for various positive temperatures. Note
how the temperatures are rounded to the appropriate number of stars.

Description
Use meaningful variable names, proper indentation, and appropriate comments.
Thoroughly test the program using your own data sets.
6.4. The standard deviation of a set of data values gives us a sense of the dispersion
of values within their range. For example, a set of test scores with a small standard
deviation indicates that most people’s scores were very close to the average score.
Some instructors use the standard deviation as a way of determining the range of
values to assign a particular grade.
Design and write a C++ program that reads a set of scores from the file scores.dat and
outputs their mean and standard deviation on cout. The formula for the standard deviation
is
Description
where n is the number of values and xi represents the individual values. Thus, to compute
the standard deviation you must sum the squares of the individual values and also square
the sum of the values. All of this reading and summing can be done with a single loop, after
which the mean and standard deviation of the scores are computed. Be sure to properly
label the output. Use meaningful variable names, proper indentation, and appropriate
comments. Thoroughly test the program using your own data sets.
6.5. You are creating a playlist for a party being held by a club you belong to. The
organizers want the dancing portion to be 90 minutes of the evening. You’d like your

playlist to come as close as possible to that time limit. To do so, you want to figure out
the total time for a group of songs and see how well they fit. Write a design and a C++
program to help you accomplish this task. The data are on file songs.dat. The time is
entered as seconds. For example, if a song is 7 minutes and 42 seconds long, the
data entered for that song would be
After all the data have been read, the application should output a message indicating the
time remaining.
The output should be in the form of a table with columns and headings written on a file.
For example:
Description
Note that the output converts the input from seconds to minutes and seconds. Use
meaningful variable names, proper indentation, and appropriate comments. Thoroughly
test the program using your own data sets.
6.6 A palindrome is a phrase that reads the same both forward and backward. Write a
C++ program that reads a line from cin, displays its characters in reverse order on
cout, and then pronounces judgment on whether the input line is a palindrome. For
example, here are two sample runs of the program:

Description
Hint: Use the substr function within a loop to extract and output the characters one by one
from the string, starting at the end of the string; at the same time, extract the
corresponding character starting at the beginning of the string to compare with it.
Use a prompting message, meaningful variable names, proper indentation, and
appropriate comments. Thoroughly test the program using your own data sets.
6.7 You’re working for a company that’s building an email list from files of mail
messages. Your boss would like you to write a program that reads a file called
mail.dat and outputs every string containing the @ sign to file addresses.dat. For the
purpose of this project, a string is defined as it is by the C++ stream reader—a
contiguous sequence of nonwhitespace characters. Given the data
Description
the program would output the following information on file addresses.dat:
Description
Use meaningful variable names, proper indentation, and appropriate comments.
Thoroughly test the program using your own data sets.

Case Study Follow-Up
1. The first version of program Acoustic remembers the reading number of the highest
reading. If there are multiple readings with the same value, it remembers only the first
one. Change the program so that it remembers the last of these values instead. Hint:
You need to add only one character to the program.
2. The second version of program Acoustic keeps track of the lowest dip in the
readings. If there are two dips that are equal, it remembers the first one. Change the
program so that it remembers the last one.
3. Does the loop in program Acoustic use a priming read?
4. Which type of loop, event-controlled or count-controlled, is used in program
Acoustic?
5. The problem for the Case Study states that the readings are on a file. They could
equally well have been entered from the keyboard. Change the revised program so
that the values are entered in real time.
6. How might you determine whether it is better to enter data from a file or from the
keyboard?
7. Discuss how you might go about devising a test plan for program Acoustic.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  7
Additional Control
Structures
KNOWLEDGE GOALS
To know how to choose the most appropriate looping statement for a given problem.
To understand the purpose of the Break and Continue statements.
To be familiar with specialized C++ operators and expressions.
SKILL GOALS
To be able to:
Write a Switch statement for a multiway branching problem.
Write a Do-While statement and contrast it with a While statement.
Write a For statement to implement a count-controlled loop.
Cast a value from one type to another.
In some cases, there is more than one way to implement C++ control structures for selection
and loop. For example, selection may be done with an If-Then or an If-Then-Else. The If-Then
statement can implement any selection structure, but C++ provides an If-Then-Else because
two-way branches are common in programming.
This chapter introduces five new statements that similarly add convenience. One, the
Switch statement, simplifies writing multiway branches. Two new looping statements, For and
Do-While, make it easier to write certain types of loops. The last two, Break and Continue, are
used together with looping and selection structures.

7.1 The Switch Statement
The Switch statement allows us to easily write multiway branches, similar to nested If
statements. The value of the switch expression determines which of the branches is
executed. For example, look at the following statement:
Switch expression The expression whose value determines which switch label is
selected. It cannot be a floating-point or string expression.
Description
In this example, letter is the switch expression. The statement means “If letter is 'X',
execute Statement1, break out of the Switch statement, and proceed with Statement5. If
letter is 'L' or 'M', execute Statement2 and break out to Statement5. If letter is 'S',
execute Statement3 and go to Statement5. If letter is none of the characters mentioned,
execute Statement4 and exit to Statement5.” The Break statement causes an immediate exit
from the Switch statement. We’ll see shortly what happens if we omit the Break statements.
The syntax template for the Switch statement is

IntegralOrEnumExpression is an expression of integral type—char, short, int, long, bool—or
of enum type. (We discuss enum in Chapter 10.) The optional SwitchLabel is either a case label
or a default label:
In a case label, ConstantExpression is an integral or enum expression whose operands must
be literal or named constants, so that the compiler can compute the case label values at
compile time. The following are examples of constant integral expressions (where CLASS_SIZE
is a named constant of type int):
Description
The data type of ConstantExpression is coerced, if necessary, to match the type of the switch
expression.
In our opening example that tests the value of letter, the case labels have the following
form:
Description
As that example shows, a single statement may be preceded by more than one case label.
Each case value may appear only once in a given Switch statement. If a value appears more
than once, it is a syntax error. Also, there can be only one default label in a Switch statement.
The flow of control through a Switch statement goes like this. First, the switch expression is
evaluated. If this value matches one of the values in the case labels, control branches to the
statement following that case label. From there, control proceeds sequentially until either a
Break statement or the end of the Switch statement is encountered. If the value of the switch
expression doesn’t match any case value, then one of two things happens. If there is a default
label, control branches to the statement following it. If there is no default label, all statements
within the Switch are skipped and control proceeds to the statement following the entire
Switch statement.

The following Switch statement outputs an appropriate comment based on a student’s
grade (grade is of type char):
Description
Description
Notice that the final Break statement is unnecessary. Programmers often include it anyway,
because it’s easier to insert another case label at the end if a Break statement is already
present.
If grade doesn't contain one of 'A', 'B', 'C', 'D', or 'F', none of the statements in the Switch is
executed. Unless a precondition of the Switch statement says that grade always contains one
of those letters, it should include a default branch:
Description

A Switch statement with a Break after each case behaves exactly like an If-Then-Else-If
structure. Our Switch statement is equivalent to the following code:
Description
Is either of these two approaches better? For this particular example, the Switch is easier to
understand. But if a multiway branch includes ranges of values, it can be tedious to list them
all as case labels. Before writing a multiway branch, consider how both options would look,
and choose the one that will be simplest to understand. Keep in mind that C++ provides the
Switch for convenience. It’s not always the best choice for every multiway branch.
Finally, we said we would look at what happens if we omit the Break statements. Here is our
letter grade example without them:
Description
If grade happens to be ‘H’, control branches to the statement at the default label and the output
is
Unfortunately, this is the only branch that works correctly. If grade is 'A', the output is:

Remember—after a branch goes to a specific case label, control proceeds sequentially until
either a Break or the end of the Switch is encountered. Forgetting a Break in a case is a
common source of errors in C++ programs.
In Chapter 5, we saw a program that displayed different messages depending on the
temperature and whether it was raining. Here is the same program using a Switch rather than
If Statements.
Description

Description
When this program is run four times, it produces the following output. It is functionally
equivalent to the other one, as long as the user always enters 1 or 0 for raining. Can you tell
how it differs if they don't?
Description
Description
MAY WE INTRODUCE Admiral Grace Murray Hopper

© Cynthia Johnson/The Chronicle Collection/Getty Images
From 1943 until her death on New Year’s Day in 1992, Admiral Grace Murray Hopper was
intimately involved with computing. In 1991, she was awarded the National Medal of
Technology “for her pioneering accomplishments in the development of computer
programming languages that simplified computer technology and opened the door to a
significantly larger universe of users.”
Admiral Hopper was born Grace Brewster Murray in New York City on December 9,
1906. She attended Vassar College and received a Ph.D. in mathematics from Yale
University. For the next 10 years, she taught mathematics at Vassar.
In 1943, Hopper joined the U.S. Navy and was assigned to the Bureau of Ordnance
Computation Project at Harvard University as a programmer on the Mark I. After the war,
she remained at Harvard as a faculty member and continued work on the Navy’s Mark II
and Mark III computers. From her time there, she loved to tell the story of the discovery of
the first computer “bug”—a moth caught in the hardware. In 1949, she joined Eckert-
Mauchly Computer Corporation and worked on the UNIVAC I.
Admiral Hopper had a working compiler in 1952, at a time when the conventional
wisdom was that computers could do only arithmetic. Although not on the committee that
designed the computer language COBOL, she was active in its design, implementation,
and use. COBOL (which stands for Common Business-Oriented Language) was
developed in the early 1960s and is still widely used in business data processing.
Admiral Hopper retired from the Navy in 1966, only to be recalled within a year to full-
time active duty. Her mission was to oversee the Navy’s efforts to maintain uniformity in
programming languages. It has been said that just as Admiral Hyman Rickover was the
father of the nuclear navy, Admiral Hopper was the mother of computer data processing in

the Navy. She served with the Naval Data Automation Command until she retired again in
1986 with the rank of rear admiral. At the time of her death, she was a senior consultant at
Digital Equipment Corporation.
During her lifetime, Admiral Hopper received honorary degrees from more than 40
colleges and universities. She was honored by her peers on several occasions, including
the first Computer Sciences Man of the Year award given by the Data Processing
Management Association, and the Contributions to Computer Science Education Award
given by the Special Interest Group for Computer Science Education of the ACM
(Association for Computing Machinery).
Admiral Hopper loved young people and enjoyed giving talks on college and university
campuses. She often handed out colored wires, which she called nanoseconds because
they were cut to a length of about one foot—the distance that light travels in a nanosecond
(one billionth of a second). Her advice to the young was, “You manage things; you lead
people. We went overboard on management and forgot about leadership.”
When asked which of her many accomplishments she was most proud of, she
answered, “All the young people I have trained over the years.”
QUICK CHECK
7.1.1 A Switch statement is specifically designed for what type of branches?
7.1.2 What does a break statement do?
7.1.3 The expression in a Switch statement must be of what type?
7.1.4 Describe the flow of control followed in a Switch statement.
7.1.5 In converting an If-Then-Else-If multiway branching structure to a Switch
statement, which part of the Switch corresponds to the final Else branch?

7.2 The Do-While Statement
The Do-While statement is a looping control structure in which the loop condition is tested at
the end (bottom). Doing so guarantees that the loop body executes at least once. Here is the
syntax template for the Do-While:
As usual, Statement is either a single statement or a block. Also, note that the Do-While ends
with a semicolon.
The statement
Description
means “Execute the statements between do and while as long as the Expression is true at
the end of the loop.”
Let’s compare a While loop and a Do-While loop that do the same task: They find the first
period in a file of data. Assume that there is at least one period in the file.
Description

The While solution requires a priming read so that inputChar has a value before loop entry.
The Do-While doesn’t need it because the input statement within the loop executes before the
condition is evaluated.
Let’s look at another example. Suppose a program needs to read a person’s age
interactively. The program requires that the age be positive. The following loops ensure that
the input value is positive before the program proceeds any further.
Description
Do-While Solution
Description
Notice that in the Do-While solution the prompt and input steps appear just once—but it has to
test the input value twice.
We can also use the Do-While to implement a count-controlled loop if we know that the loop
body should always execute at least once. Following are two versions of a loop to sum the
integers from 1 through n.

Description
If n is a positive number, both versions are equivalent. But if n is 0 or negative, the loops give
different results. In the While version, the final value of sum is 0 because the loop body is
skipped. In the Do-While version, the final value of sum is 1 because the body executes once
before exiting.
Because the While statement tests the condition before executing its body, it is called a
pretest loop. The Do-While statement does the opposite and thus is known as a posttest loop.
FIGURE 7.1 compares the flow of control in the While and Do-While loops.
FIGURE 7.1 While and Do-While Loops

Description
Here is a program that encloses the activity message code in a Do-While statement:
Description

Description
Here is a sample run of this program:

Description
You might wonder why we would want to repeat this particular process, because the
weather doesn’t change that often. The preceding is an example of what is called a test
harness (or driver)—a very simple program that surrounds a module so we can directly enter
a series of test data values. In many situations, a module’s implementation can be destined
for placement deep inside a complex program, where it would be difficult to thoroughly test. By
separately enclosing it in a test driver, we gain complete control of its environment and can
directly supply the module’s inputs and check its outputs to ensure that it is correct. Once it
has been tested, the code can be transplanted to its final place in the real program, where we
can have confidence that it works correctly.
QUICK CHECK

7.2.1 Which looping statement always executes its body at least once?
7.2.2 Translate the following While loop into a Do-While loop:
Description
7.2.3 What is another name for a Do-While loop?

7.3 The For Statement
The For statement is designed to simplify the writing of count-controlled loops. The following
statement outputs the integers from 1 through n:
Description
This For statement means “Initialize the loop control variable count to 1. While count is less
than or equal to n, execute the output statement and increment count by 1. Stop the loop after
count has been incremented to n+ 1.”
In C++, a For statement is merely a compact notation for a While loop. In fact, the compiler
essentially translates a For statement into an equivalent While loop as follows:
Description
The syntax template for a For statement is shown here:
Why doesn’t the syntax template show a semicolon between InitStatement and Expression1,
as in the preceding example? Because InitStatement always ends with its own semicolon.
InitStatement can be any of: the null statement (just a semicolon), a declaration statement
(which ends in a semicolon), or an expression statement (an expression ending in a
semicolon). That’s why a semicolon always appears before Expression1. Expression1 is the
exit condition. Expression2 is evaluated at the end of each loop iteration.

A For statement is usually written so that InitStatement initializes a loop control variable,
and Expression2 increments or decrements that variable. Here are two loops that execute the
same number of times (50):
Description
Just like While loops, Do-While and For loops may be nested. For example, this nested For
structure
Description
displays the following triangle of numbers:
Description
Although For statements are used primarily to implement count-controlled loops, C++
allows you to write any While loop as a For statement. To use For loops intelligently, you
should know the following facts:
1. In the syntax template, InitStatement can be the null statement, and Expression2 is
optional. If Expression2 is omitted, there is no statement for the compiler to insert at the
bottom of the loop. As a result, you could write the While loop
Description

Description
2. According to the syntax template, Expression1—the While condition—is optional. If
you omit it, the expression is assumed to be true. The loop
Description
is equivalent to the While loop
Description
Both of these are infinite loops that output “Hi” endlessly.
3. As highlighted here, the initializing statement, InitStatement, can be a declaration with
initialization:
Description
Here, the variable i has local scope that extends only to the end of the For statement. Like
any local variable, i is inaccessible outside its scope (that is, outside the For statement).
Because i is local to the For statement, it’s possible to write code like this:
Description
This code does not generate a compile-time error (such as MULTIPLY DEFINED IDENTIFIER). We
have declared two distinct variables named i, each of which exists only within its own For
statement.
As you have seen by now, the For statement in C++ is a very flexible structure. Its use can
range from a simple count-controlled loop to a general-purpose While loop. Some

programmers squeeze a lot of work into the heading (the first line) of a For statement. For
example, the While loop
Description
can be written as the following For loop (the density of highlighting shows the corresponding
parts of the loops):
Description
Because all the work is done in the For heading, there is nothing for the loop body to do, so it
is the null statement.
With For statements, our advice is to keep it simple. The trickier the code is, the harder it is
to understand and debug. In this text, we use For loops for count-controlled loops only.
The following program contains both a For and a Switch. It analyzes the first 100 characters
entered and reports how many are letters, periods, question marks, and exclamation points.
For the first category (letters), we use the library function isalpha, which returns true if its
argument is a letter and false otherwise.

Description

Here is the output of a sample run:
Description
The totals here look strange: They add up to only 85 characters. Where are the other 15?
Well, the numbers are not counted in the totals, so that gives 94. But that still leaves 6
unaccounted for. Careful examination of the data shows that reading must end partway
through the seventh line. Aha! The end-of-line characters on the first 6 lines of input account
for the other missing characters!
Now we see that the code is actually correct—it was just our expectation of the results that
was off. As you can see, sometimes the expected output in a test plan fails to take everything
into consideration. Testing isn’t always a one-way street where we have all the answers ahead
of time and simply verify the code. In some cases, we find errors in the test plan, and need to
fix it instead.
SOFTWARE MAINTENANCE CASE STUDY Changing a Loop
Implementation
MAINTENANCE TASK: You are given a program you have never seen before and asked
to change the loop from a While loop to a For loop. The first step in converting one loop to
another is to identify the parts of the loop that relate to its control.
1. Identify the loop control variable (LCV).
2. Determine where the LCV is declared.
3. Determine where the LCV is initialized.
4. Determine where and how the LCV is updated.
5. Identify the loop termination condition.
How can we do this in an unfamiliar program? We begin by reading the documentation
to see what the program is supposed to accomplish.

Description
This calculation is familiar, but the difference is the last statement—the program prompts
the user to input the number of data cases to be processed. The next step is to examine
the declarations.
The first four are not related to the loop, but the fifth, count, is. Next we locate the code that
uses count:
Now we have all the information we need:
count is the LCV.
count is initialized by prompting for and reading its value.
count is updated by decrementing its value by 1.
The loop termination condition is when count is equal to 0.
Here is the complete code, with the For statement highlighted:

Description
Description

QUICK CHECK
7.3.1 Write a For statement that counts from –10 to 10.
7.3.2 What does a For loop try to simplify?
7.3.3 Translate the following While loop into a For loop:
Description
7.3.4 Write a For loop that reads characters from cin until a '\n' character is
encountered.

7.4 The Break and Continue Statements
The Break statement, which we introduced with Switch, can also be used with loops. A Break
statement causes an immediate exit from the innermost Switch, While, Do-While, or For in
which it appears. Notice the word innermost. If break is in a loop that is nested in another loop,
control exits the inner loop but not the outer loop.
One way of using break with loops is to set up an infinite loop and use If tests to exit the
loop. Suppose we want to input 10 pairs of integers, performing data validation and computing
the square root of the sum of each pair. For data validation, assume that the first number of
each pair must be less than 100 and the second must be greater than 50. Also, after each
input, we want to test the state of the stream for EOF. Here’s a loop using Break statements to
accomplish the task:
Description
Note that we could have used a For loop to count from 1 to 10, breaking out of it as necessary.
However, this loop is both count controlled and event controlled, so we prefer to use a While.
When someone is reading code and sees a For loop, they expect it to be purely count
controlled.
The preceding loop contains three distinct exit points. Many programmers adhere to the
single-entry, single-exit approach to writing a loop. With this philosophy, control enters a loop at
the top of the body and exits only at the end of the body, because multiple exits make the
program logic harder to follow and debug. Other programmers feel it is acceptable to use
break within a loop when the logic is clear. If we did not use break in this loop, it would contain
nested If statements that could make it harder to spot the actual computation.
Our advice is to use break sparingly; overuse can lead to confusing code. A good rule of
thumb is this: Use break within loops only as a last resort. Specifically, use it only to avoid
baffling combinations of compound Boolean expressions and nested Ifs.

Another statement that alters the flow of control in a C++ program is the Continue
statement. This statement, which is valid only in loops, terminates the current loop iteration
(but not the entire loop). It causes an immediate branch to the bottom of the loop—skipping
the rest of the statements in the loop body—in preparation for the next iteration. Here is an
example of a reading loop in which we want to process only the positive numbers in an input
file:
Description
If inputVal is less than or equal to 0, control branches to the bottom of the loop. Then, as with
any For loop, the computer increments dataCount and performs the loop test before going on
to the next iteration.
The Continue statement is not used often, but we present it for completeness (and because
you may run across it in other people’s programs). Its primary purpose is to avoid obscuring
the main process of the loop that would result from indenting the process within an If
statement. For example, the previously given code would be written without a Continue
statement as follows:
Description
Be sure to note the difference between continue and break. Continue means “Abandon the
current iteration of the loop, and go to the next iteration.” Break means “Exit the entire loop

immediately.”
QUICK CHECK
7.4.1 Write a For loop that reads numbers from cin until a '\n' character is
encountered, continues if it encounters a number less than 10, breaks if it encounters
a number greater than 20, and outputs the number otherwise.
7.4.2 When it is executed within a loop, to where does a Break statement transfer
control? Where does control proceed from a Continue statement?

7.5 Guidelines for Choosing a Looping Statement
Here are some guidelines to help you decide when to use each of the three looping
statements (While, Do-While, and For):
1. If the loop is a simple count-controlled loop, the For statement is a natural. Collecting the
three loop control actions—initialize, test, and increment/decrement—into one location
(the heading of the For statement) reduces the chances of forgetting to include one of
them.
2. If the loop is an event-controlled loop whose body should execute at least once, a Do-
While statement is appropriate.
3. If the loop is an event-controlled loop and nothing is known about the first execution, use
a While statement.
4. When in doubt, use a While statement.
5. An infinite loop with Break statements sometimes clarifies the code but more often
reflects an undisciplined loop design. Use it only after careful consideration of While, Do-
While, and For.
Bear in mind that most programmers, when encountering a For statement, expect the loop to
be purely count controlled. Using a For to implement an event-controlled loop leads to tricky
code and is to be avoided.
QUICK CHECK
7.5.1 If a problem calls for a pure count-controlled loop, would you use a While, a Do-
While, or a For statement to implement the loop?

7.6 Additional C++ Operators
C++ has a rich, sometimes bewildering, variety of operators that allow you to manipulate
values of the simple data types. Operators you have learned about so far include the
assignment operator (=), the arithmetic operators (+, -, *, /, %), the increment and decrement
operators (++, --), the relational operators (==, !=, <, <=, >, >=), and the logical operators (!, &&,
||). In certain cases, a pair of parentheses is also considered to be an operator—namely, the
function call operator,
and the type cast operator,
C++ also has many specialized operators. Here is a table of these additional operators. As
you inspect the table, don’t panic—a quick scan will do.
Operator
Remarks
Combined Assignment Operators
+=
Add and assign
-=
Subtract and assign
*=
Multiply and assign
/=
Divide and assign
Increment and Decrement
Operators
++
Pre-increment Example: ++someVar
++
Post-increment Example: someVar++
--
Pre-decrement Example: --someVar
--
Post-decrement Example: someVar--
Bitwise Operators
Integer operands only
<<
Left shift
>>
Right shift
&
Bitwise AND Logical AND of the bits in its operands
|
Bitwise OR Logical OR of the bits in its operands
^
Bitwise exclusive OR Logical XOR of the bits in its
operands
~
Complement (invert all bits) Single operand
More Combined Assignment
Integer operands only

Operators
%=
Modulus and assign
<<=
Shift left and assign
>>=
Shift right and assign
&=
Bitwise AND and assign
|=
Bitwise OR and assign
^=
Bitwise exclusive OR and assign
Other Operators
()
Cast
sizeof
Size of operand in bytes Form: sizeof Expr or
sizeof(Type)
?:
Conditional operator Form: Expr1 ? Expr2 : Expr3
The operators in this table, along with those you already know, account for most—but not all
—of the C++ operators. We introduce a few more operators in later chapters as the need
arises.
Assignment Operators and Assignment Expressions
C++ has several assignment operators. The equal sign (=) is the basic assignment operator.
When combined with its two operands, it forms an assignment expression (not an
assignment statement). Every assignment expression has a value and a side effect—namely,
that the value is stored into the object denoted by the left-hand side. For example, the
expression
Assignment expression A C++ expression with (1) a value and (2) the side effect of
storing the expression value into a memory location.
Expression statement A statement formed by appending a semicolon to an expression.
has the value 24 and the side effect of storing this value into delta.
In C++, any expression becomes an expression statement when it is terminated by a
semicolon. All three of the following are valid C++ statements, although the first two have no
effect at run time:
The third expression statement is useful because of its side effect of storing 24 into delta.

Because an assignment is an expression, not a statement, you can use it anywhere an
expression is allowed. Here is a statement that stores the value 20 into firstInt, the value 30
into secondInt, and the value 35 into thirdInt:
Some people use this style of coding because they think it is clever, but most find it hard to
read and error prone.
In addition to the = operator, C++ has several combined assignment operators (+=, *=, and
the others listed in the preceding table). The combined assignment operators are
conveniences for writing code a bit more compactly, but you can easily get by without them.
Increment and Decrement Operators
The increment and decrement operators (++ and --) operate only on variables, not on
constants or expressions. Suppose a variable someInt contains the value 3. The expression
++someInt denotes pre-incrementation. The side effect of incrementing someInt occurs first, so
the resulting value of the expression is 4. In contrast, the expression someInt++ denotes post-
incrementation. The value of the expression is 3, and then the side effect of incrementing
someInt takes place. The following code illustrates the difference between pre- and post-
incrementation:
Description
Using side effects in the middle of larger expressions is always a bit dangerous. It’s easy to
make semantic errors, and the code may be confusing to read. Look at this example:
Some people make a game of seeing how much they can do in the fewest keystrokes. But
they should remember that serious software engineering requires writing code that other
programmers can read and understand. Use of side effects hinders this goal. By far the most
common use of ++ and -- is to increment or decrement a variable as a separate expression
statement:
Here, the value of the expression is unused, but we get the desired side effect of incrementing
count. In this example, it doesn’t matter whether you use pre-incrementation or post-
incrementation. The choice is yours.

Bitwise Operators
The bitwise operators listed in the operator table (<<, >>, &, |, and so forth) are used for
manipulating individual bits within a memory cell. We won’t explore their use; the topic of bit-
level operations is most often covered in a course on computer organization and assembly
language programming. However, we point out two things about the bitwise operators.
First, the built-in operators << and >> are the left shift and right shift operators, respectively.
Their purpose is to take the bits within a memory cell and shift them to the left or right. Of
course, we have been using these operators all along, but in a different context—stream input
and output. The header file iostream uses an advanced C++ technique called operator
overloading to give additional meanings to these two operators. An overloaded operator is one
that has multiple meanings, depending on the data types of its operands. When looking at the
<< operator, the compiler determines by context whether a left shift operation or an output
operation is desired. Specifically, if the first (left-hand) operand denotes an output stream, then
it is an output operation. If the first operand is an integer variable, it is a left shift operation.
Second, do not confuse the && and || operators with the & and | operators. The statement
Description
is syntactically correct because & is a valid operator (bitwise AND). The program containing
this statement compiles but executes incorrectly. Be careful to use the relational operators &&
and || in your logical expressions.
The Cast Operation
You have seen that C++ is very liberal about letting the programmer mix data types in
expressions, assignment operations, argument passing, and returning a function value.
However, implicit type coercion takes place when values of different data types are mixed
together. Instead of relying on implicit type coercion in a statement such as
we have recommended using an explicit type cast to show that the type conversion is
intentional:
In C++, the cast operation comes in three forms:
Description

The first form is called functional notation because it looks like a function call. It isn’t really a
function call (there is no predefined function named int), but it has the syntax and appearance
of one. In the second form, prefix notation, the parentheses surround the name of the data
type, not the expression being converted. The third form uses a keyword and angle brackets
to explicitly specify a cast operation. Prefix notation was the form used in the C language; the
original version of C++ added functional notation and, with the definition of the C++ standard,
keyword notation was included.
Functional notation is limited in its use because the data type name must be a single
identifier. If the type name consists of multiple identifiers, you must use prefix or keyword
notation; for example,
Description
Keyword cast is now the recommended style. For one thing, it is easier to notice the
keyword. But there are also more advanced aspects of C++, involving object-oriented
programming, where static_cast causes the compiler to perform additional checks that help
to spot errors.
C++ defines three more forms of the keyword cast that have special purposes. We do not
explain them further, but we list them here so you will be aware of them: const_cast,
dynamic_cast, and reinterpret_cast.
The sizeof Operator
The sizeof operator is a unary operator that yields the size, in bytes, of its operand. The
operand can be a variable name, as in
Alternatively, the operand can be the name of a data type, enclosed in parentheses:
You could find out the sizes of various data types on your machine by using code like this:
Description
The ?: Operator
The last operator in our operator table is the ?: operator, sometimes called the conditional
operator. It is a ternary (three-operand) operator with the following syntax:

Here’s how it works. First, the computer evaluates Expression1. If the value is true, then
the value of the entire expression is Expression2; otherwise, its value is Expression3. (Only
one of Expression2 and Expression3 is evaluated, but both of them must evaluate to the
same data type.) A classic example of the ?: operator’s use is to set a variable max equal to
the larger of two variables a and b. Using an If statement, we would do it this way:
Description
With the ?: operator, we can use the following assignment statement:
Here is another example. The absolute value of a number x is defined as
To compute the absolute value of a variable x and store it into y, you could use the ?: operator
as follows:
In both examples, we placed parentheses around Expression1. These parentheses are
unnecessary because the conditional operator has very low precedence. Even so, it is
customary to include them for clarity.
Operator Precedence
The following table summarizes operator precedence for the C++ operators we have
encountered so far, excluding the bitwise operators. (Appendix B contains the complete list.)
In the table, the operators are grouped by precedence level, and a horizontal line separates
each precedence level from the next-lower level.
Operator
Associativity
Remarks
()
Left to right
Function call and function-style cast

++ --
Right to left
++ and -- as postfix operators
++ -- ! Unary + Unary -
Right to left
++ and -- as prefix operators
(cast) sizeof
Right to left
* / %
Left to right
+ -
Left to right
< <= > >=
Left to right
== !=
Left to right
&&
Left to right
||
Left to right
?:
Right to left
= += -= *= /=
Right to left
The column labeled Associativity describes grouping order. Within a precedence level,
most operators group from left to right. For example,
means
and not
Certain operators, though, group from right to left—specifically, the unary operators, the
assignment operators, and the ?: operator. Look at the assignment operators, for example.
The expression
means
This associativity makes sense because the assignment operation is naturally a right-to-left
operation.
A word of caution: Although operator precedence and associativity dictate the grouping of
operators with their operands, C++ does not define the order in which subexpressions are
evaluated. Therefore, using side effects in expressions requires extra care. For example, if i
currently contains 5, the statement
stores either 11 or 12 into j, depending on the particular compiler being used. Let’s see why.
There are three operators in this expression statement: =, ++, and +. The ++ operator has the

highest precedence, so it operates just on i, not the expression i + i. The addition operator
has higher precedence than the assignment operator, giving implicit parentheses as follows:
So far, so good. But now we ask this question: In the addition operation, is the left operand or
the right operand evaluated first? The C++ language doesn’t dictate the order. If a compiler
generates code to evaluate the left operand first, the result is 6 + 6, or 12. Another compiler
might generate code to evaluate the right operand first, yielding 6 + 5, or 11. To be assured of
left-to-right evaluation in this example, you should force the ordering with two separate
statements:
The moral here is that if you use multiple side effects in expressions, you increase the risk of
unexpected results.
Type Coercion in Arithmetic and Relational Expressions
Suppose that an arithmetic expression consists of one operator and two operands—for
example, 3.4*sum or var1/var2. If the two operands are of different data types, then one of
them is temporarily promoted (or widened) to match the data type of the other. To
understand exactly what promotion means, let’s look at the rule for type coercion in an
arithmetic expression.1
Promotion (widening) The conversion of a value from a “lower” type to a “higher” type
according to a programming language’s precedence of data types.
Step 1: Each char, short, bool, or enumeration value is promoted (widened) to int. If both
operands are now int, the result is an int expression.
Step 2: If Step 1 still leaves a mixed type expression, the following precedence of types is
used:
Description
The value of the operand of the “lower” type is promoted to that of the “higher” type, and the
result is an expression of that type.

A simple example is the expression someFloat+2. This expression has no char, short, bool,
or enumeration values in it, so Step 1 leaves a mixed type expression. In Step 2, int is a
“lower” type than float, so the value 2 is coerced temporarily to the float value—say, 2.0.
Then the addition is done, and the type of the result is float.
This description of type coercion also holds for relational expressions such as
The value of someInt is temporarily coerced to floating-point before the comparison. The
difference between arithmetic and relational expressions is that the result type of a relational
expression is always bool.
Here is a table that describes the result of promoting a value from one simple type to
another in C++:
From
To
Result of Promotion
double
long double
Same value, occupying more memory space
float
double
Same value, occupying more memory space
Integral
type
Floating-point type
Floating-point equivalent of the integer value; fractional
part is zero
Integral
type
Its unsigned counterpart Same value if original number is nonnegative; a radically
different positive number if original number is negative
Signed
integral
type
Longer signed integral
type
Same value, occupying more memory space
Unsigned
integral
type
Longer integral type
(either signed or
unsigned)
Same nonnegative value, occupying more memory
space
Note: The result of promoting a char to an int is compiler dependent. Some compilers treat
char as unsigned char, so promotion always yields a nonnegative integer. With other
compilers, char meanssigned char, so promotion of a negative value yields a negative integer.
The note at the bottom of the table suggests a potential problem if you are trying to write a
portable C++ program. If you use the char type only to store character data, there is no
problem. C++ guarantees that each character in a machine’s character set is represented as a
nonnegative value. Using character data, promotion from char to int gives the same result on
any machine with any compiler.
If you try to save memory by using the char type for manipulating small signed integers,
however, then promotion of these values to the int type can produce different results on
different machines! One machine may promote negative char values to negative int values,
whereas another machine might promote negative char values to positive int values. If you
use char to store only character data, you won’t have any problems.

QUICK CHECK
7.6.1 What is the value of y and z after executing the following statements?
7.6.2 Give an example of a common problem associated with assignment
expressions.
7.6.3 What is the difference between the && operator and the & operator?
Problem-Solving Case Study
THE RICH UNCLE
PROBLEM: Your rich uncle has just died, and in his desk you find two wills. One of them,
dated several months ago, leaves you and your relatives a substantial part of his fortune;
the other, dated last week, gives everything to his next-door neighbor. Being suspicious
that the second will is a forgery, you decide to write a program to analyze writing style and
compare the wills. The program reads and categorizes each character. When the entire
file has been read, it outputs a summary table showing the percentage of uppercase
letters, lowercase letters, decimal digits, blanks, and end-of-sentence punctuation marks
in the data file. The names of the input and output files are read from the keyboard. The
name of the input file should be included in the output.
INPUT: Text on a file whose name is read from the keyboard. OUTPUT: A table giving the
name of each category and the percentage of the total that the category represents on the
file whose name is read from the keyboard.
DISCUSSION: Doing this task by hand would be tedious but straightforward: Set up five
places to make hash marks, one for each of the categories to be counted. Then read the
text character by character, determining the category for each one, and making a hash
mark in the appropriate place.
You can determine the category of a character with an If structure that has branches for
the uppercase letters, the lowercase letters, the digits, a blank, and end-of-sentence
punctuation marks. Before you start writing algorithms to recognize the categories,
however, you look in the library to see if it has functions that can help. Sure enough,
header file <cctype> contains functions to recognize uppercase letters, lowercase letters,
and digits.
Function isspace returns true if the character is a blank, newline, tab, carriage return, or
form feed. But the problem specifically asks for the number of blanks, so we can’t use it.
There is also a function to recognize punctuation, but not end-of-sentence punctuation. The

problem doesn’t state what end-of-sentence marks are, but you can assume they are a
period, question mark, or exclamation point.
Here is a summary of the functions in <cctype> that we will use:
These functions don’t return Boolean values. How can they be used in a Boolean
expression? Remember that where a Boolean expression is expected, nonzero values are
coerced to true, and 0 is coerced to false. We return to these functions in Chapter 9.
ASSUMPTIONS: File is not empty.
Main
Level 0
Open files for processing
IF files not opened okay
Display error message
return 1
Get a character
DO
Increment appropriate character count
Get a character
WHILE (more data)
Output table
Several of the counters are incremented based on the results of a function; others are
based on the character itself. We must use If statements for the group characters, but we
can use a Switch statement for the individual characters.
Increment Counters
Level 1
IF (isupper(character))
Increment uppercaseCounter
ELSE IF (islower(character))
Increment lowercaseCounter
ELSE IF (isdigit(character))
Increment digitCounter
SWITCH (character)
Case ‘ ’ : Increment blankCounter
Case ‘.’ :
Case ‘!’ :
Case ‘? ’ : Increment punctuationCounter
At this point you realize that the instructions do not indicate whether the percentages
are to be taken of all the characters read, including those outside of the categories, or just
the characters that can be categorized. You decide to assume that all characters should

be counted, and add a branch that increments allElseCounter for everything else. Your
assumption needs to be documented in the comments. This branch can be the default
option of the Switch statement.
 
Output Table
Set Total to sum of 6 counters
Output “Percentage of uppercase letters:”, uppercaseCounter / Total * 100
Output “Percentage of lowercase letters:”, lowercaseCounter / Total * 100
Output “Percentage of decimal digits:”, digitCounter / Total * 100
Output “Percentage of blanks:”, blankCounter / Total * 100
Output “Percentage of end-of-sentence punctuation:”, punctuationCounter / Total * 100
MODULE STRUCTURE CHART
Description

Description

Description
TESTING: To be tested thoroughly, the RichUncle program must be run with all possible
combinations of the categories of characters being counted. Following is the minimum set

of cases that must be tested:
1. All the categories of characters are present.
2. Four of the categories are present; one is not. (This alone will require five test runs.)
3. Only characters that fall into one of the five categories are present.
4. Other characters are present.
The output listed below was run on a file containing more than 4000 characters. (It isn’t a
will, but it is sufficient for testing.)
Description
1 The rule we give for type coercion is a simplified version of the rule found in the C++
language definition. The complete rule has more to say about unsigned types, which we rarely
use in this text.

Graphical User Interface (GUI)
Here we re-implement the “Rich Uncle” program using a GUI. The changes will be
straightforward given the GUI components we have already covered: add a FileDialog GUI
widget to ask the user for an input file and use an OutputDialog to display the results of the
history analysis. We will also take advantage of ostringstream as we did in the previous
chapter to replace cout with writing output to a string. We need these include statements:
As in the original program, we first declare several variables inside the main function for
recording the counts of various types of characters in the file. To these we add a variable
declaration for our output string stream object:
Description
Description
We can then replace all uses of cout with output. Next, we want our application to ask the
user for the input file, so we use a FileDialog to do that:
Description
The display() method puts the widget on the screen, allowing the user to choose a file:

Description
Here, selecting history.in provides the program the input to read. It then performs the Do-
While loop identically as before. It is important to note that one of the advantages of using a
GUI over a console-based program is the built-in checks. In particular, in the original program
we had to make sure the file name we entered actually exists, using the following code
fragment:
Description
This error checking is important, but no longer necessary with our GUI version, because it is
impossible to select a file that does not exist. So, we can safely delete this code. We then
replace all instances of cout with output as shown here:

Description
Description
Lastly, we use an OutputDialog widget to display the results to the user:
Description
The final output looks like this:
Description
Of course, the path for the input file depends on the organization of files on the particular
system. The final version of our code is as follows, with highlighted portions representing the
most significant parts that were changed.

Description

Description

Description

Testing and Debugging
The same testing techniques used with While loops apply to Do-While and For loops. There
are, however, a few additional considerations with these loops.
The body of a Do-While loop always executes at least once. Thus you should try data sets
that show the result of executing a Do-While loop for the minimal number of times.
With a data-dependent For loop, it is important to test for proper results when the loop
executes zero times. This occurs when the starting value is greater than the ending value (or
less than the ending value if the loop control variable is being decremented).
When a program contains a Switch statement, you should test it with enough different data
sets to ensure that each branch is selected and executed correctly. You should also test the
program with a switch expression whose value is not found in any of the case labels.
Testing and Debugging Hints
1. In a Switch statement, make sure there is a Break statement at the end of each case
alternative. Otherwise, control “falls through” to the code in the next case alternative.
2. Case labels in a Switch statement are made up of values, not variables. They may,
however, include named constants and expressions involving only constants.
3. A switch expression cannot be a floating-point or string expression, and a case constant
cannot be a floating-point or string constant.
4. If there is a possibility that the value of the switch expression might not match one of the
case constants, you should provide a default alternative. In fact, it is a good practice to
always include a default alternative.
5. Double-check long Switch statements to make sure that you haven’t omitted any
branches.
6. The Do-While loop is a posttest loop. If there is a possibility that the loop body should be
skipped entirely, use a While statement or a For statement.
7. The For statement heading (the first line) always has three pieces within the parentheses.
Most often, the first piece initializes a loop control variable, the second tests the variable,
and the third increments or decrements the variable. The three pieces are separated by
semicolons. Any of these pieces can be omitted, but the semicolons must still be
present.
8. With nested control structures, the Break statement exits from only one level of nesting—
the innermost Switch or loop in which the break is located.

Summary
The Switch statement is a multiway selection statement. It allows the program to choose
among a set of branches. A Switch containing Break statements can always be simulated
by an If-Then-Else-If structure. If a Switch can be used, however, it often makes the code
easier to read and understand. A Switch statement cannot be used with floating-point or
string values in the case labels.
The Do-While is a general-purpose looping statement. It is like the While loop except that
its test occurs at the end of the loop, guaranteeing at least one execution of the body. As
with a While, a Do-While continues as long as the condition is true. A Do-While is
convenient for loops that test input values and repeat if the input is incorrect.
The For statement is technically a general-purpose looping statement, but it is really for
implementing count-controlled loops. The initialization, testing, and update of the loop
control variable are centralized in the first line of the For statement.
C++ provides a wealth of additional operators. Many—such as the extra assignment
operations increment and decrement—involve a combination of a side effect and the return
of a value. Although use of side effects can save a few keystrokes, it usually results in
code that is harder to understand.
The For, Do-While, and Switch statements are the “ice cream and cake” of C++. We
can live without them if we absolutely must, but they are very nice to have.

Quick Check Answers
7.1.1 Multiway branches. 7.1.2 It causes an immediate exit from the Switch
statement. 7.1.3 An integral type. 7.1.4 First, the switch expression is evaluated. If this
value matches one of the values in the case labels, control branches to the statement
following the case label. From there, control proceeds sequentially until a Break
statement is encountered or the end of the Switch statement. 7.1.5 The default
branch. 7.2.1 Do-While.
7.2.2 
Description
7.2.3 A posttest loop. 7.3.1 for (int count = -10; count <= 10; count++) 7.3.2 The
writing of count-controlled loops.
7.3.3 
Description
7.3.4 
Description
7.4.1 
Description
7.4.2 The Break statement immediately exits the loop; the Continue statement sends
control to the end of the loop. 7.5.1 A For statement. 7.6.1 y = 6, z = 5; 7.6.2 if (x =

10) ...
7.6.3 && is a logical AND of a pair of bool values; & is a bitwise AND of a pair of
integral values.

Exam Preparation Exercises
7.1 A switch expression may be of type bool, char, int, or long, but not of type float.
True or false?
7.2 A variable declared in the initialization statement of a For loop has global scope.
True of false?
7.3 Any While loop can be directly rewritten as a Do-While merely by changing the
statement syntax and moving the exit condition to the end of the loop. True or false?
7.4 A Break statement is not allowed in a For loop, but a Continue statement is. True
or false?
7.5 Which of the looping statements in C++ are pretest loops and which are posttest
loops?
7.6 What happens when you forget to include the Break statements in a Switch
statement?
7.7 If you omit all of the clauses within a For loop (for ( ; ; )), what would be the
condition in an equivalent While loop?
7.8 How many times is the inner loop body executed in the following nested loop?
Description
7.9 Which looping statement would you choose for a problem in which the decision to
repeat a process depends on an event, and the event cannot occur until the process
is executed at least once?
7.10 Which looping statement would you choose for a problem in which the decision
to repeat the process depends on an iteration counter and on the state of an input file,
and the process may be skipped if the file is empty?
7.11 What is output by the following code segment if wood contains 'O'?

Description
7.12 What is output by the following code segment if month contains 8?
Description
7.13 What is output by the following code segment?

Description
7.14 What is output by the following code segment?
Description
7.15 Rewrite the code segment in Exercise 7.14 using While loops.
7.16 What is output by the following code segment?
Description
7.17 Write a single simple statement that has the same effect on cout as the code
segment in Exercise 7.16.
7.18 What does the following code segment (which is written in poor style) output?

Description
7.19 The difference between an assignment expression and an assignment statement
is a semicolon. True or false?
7.20 The sizeof operator can be used to determine whether a machine’s int type is
32 or 64 bits long. True or false?
7.21 Which group of C++ operators has the lowest precedence of all?
7.22 What is the difference in effect of writing count++ versus ++count?
7.23 In what situation is it necessary to use prefix notation for the cast operation
instead of functional notation?

Programming Warm-Up Exercises
7.1 Write a Switch statement that outputs the day of the week to cout according to the
int value in day that ranges from 0 to 6, with 0 being Sunday.
7.2 Extend the Switch statement in Exercise 7.1 so that it outputs “Error” if the value
in day is not in the range of 0 through 6.
7.3 Write a For loop that outputs the days of the week, each on a separate line,
starting from Saturday and working backward to Sunday.
7.4 Change the For loop in Exercise 7.3 so that it outputs the days of the week in
forward order, starting on Wednesday and going through Tuesday.
7.5 Write a Do-While loop that prompts for and inputs a user entry of “Y” or “N”. If the
user fails to enter a correct value, the loop outputs an error message and then repeats
the request for the user to enter the value.
7.6 Write a code segment that adds up the positive integers, starting at 1, until the
sum equals or exceeds a value read from the keyboard, and then displays the last
integer added to the sum. Use a Do-While loop to do the summing.
7.7 Write a nested For loop that outputs a multiplication table for the integers 1 through
10.
7.8 Write a nested For loop that outputs a filled right triangle of stars, one star on the
first line, two on the next, and so on, up to the tenth line having ten stars.
7.9 Rewrite the nested loop in Exercise 7.8 with Do-While loops.
7.10 Rewrite the nested loop in Exercise 7.8 with While loops.
7.11 Write a code segment, using For loops, that outputs a hollow rectangle of stars
whose width and height are specified by two values read from the keyboard. The top
and bottom of the rectangle is a solid row of stars, each row between the top and
bottom consists of a star, then width-2 spaces, and another star.
7.12 Write a nested For loop that outputs the hours and minutes in the period from
3:15 to 7:30.
7.13 Extend the loop in Exercise 7.12 to also output seconds.
7.14 How many lines do the loops in Exercises 7.12 and 7.13 output?
7.15 Write assignment expression statements that do the following:
a. Add 7 to the variable days
b. Multiply the value in the variable radius by 6.2831853

c. Subtract 40 from the variable workHours
d. Divide the variable average by the variable count
7.16 Write an expression whose result is the number of bits in a value of type long.
7.17 Use the C++ precedence rules to remove any unnecessary parentheses from
the following expressions:
Description

Programming Problems
7.1 Programming Problem 5.3 asked you to write a program that takes a letter as
input and outputs the corresponding word in the International Civil Aviation
Organization (ICAO) Alphabet. Extend the program so that it inputs a string and
outputs the series of ICAO words that would be used to spell it out. For example:
Write the program so that it determines the word corresponding to a specified letter using a
Switch statement instead of an If structure. For ease of reference, the ICAO alphabet is
repeated here:
A
Alpha
B
Bravo
C
Charlie
D
Delta
E
Echo
F
Foxtrot
G
Golf
H
Hotel
I
India
J
Juliet
K
Kilo
L
Lima
M
Mike
N
November
O
Oscar
P
Papa
Q
Quebec
R
Romeo
S
Sierra
T
Tango
U
Uniform
V
Victor

W
Whiskey
X
X-ray
Y
Yankee
Z
Zulu
Be sure to use proper formatting and appropriate comments in your code. Provide
appropriate prompts to the user. The output should be clearly labeled and neatly formatted.
7.2 Programming Problem 5.4 asked you to write a C++ program that asks the user
to enter their weight and the name of a planet. The program was then to output how
much the user would weigh on that planet. Rewrite that program so that the selection
of the factor to use in computing the weight is made with a Switch statement instead
of an If structure.
For ease of reference, the information for the original problem is repeated here. The
following table gives the factor by which the weight must be multiplied for each planet. The
program should output an error message if the user doesn’t type a correct planet name.
The prompt and the error message should make it clear to the user how a planet name
must be entered. Be sure to use proper formatting and appropriate comments in your
code. The output should be clearly labeled and neatly formatted.
Mercury
0.4155
Venus
0.8975
Earth
1.0
Moon
0.166
Mars
0.3507
Jupiter
2.5374
Saturn
1.0677
Uranus
0.8947
Neptune
1.1794
7.3 You are working for a company that has traveling salespeople. The salespeople
call in their sales to a fulfillment desk, where the sales are all entered into a file. Each
sale is recorded as one line on the file sales.dat as a salesperson ID number, an item
number, and a quantity, with all three items separated by blanks. There are 10
salespeople, with IDs of 1 through 10. The company sells eight different products, with
IDs of 7 through 14 (some older products have been discontinued). The unit prices of
the products are given here:
Product Number
Unit Price
7
345.00

8
853.00
9
471.00
10
933.00
11
721.00
12
663.00
13
507.00
14
259.00
You have been asked to write a program that reads in the sales file and generates a
separate file for each salesperson containing just that individual’s sales. Each line from the
sales file is copied to the appropriate salesperson file (salespers1.dat through
salespers10. dat), with the salesperson ID omitted. The total for the sale (quantity times
unit price) is appended to the record. At the end of processing, the total sales for each
salesperson should be output with informative labels to cout. Use functional decomposition
to design the program. Be sure that the program handles invalid ID numbers. If a
salesperson ID is invalid, write an error message to cout. If a product number is invalid,
write the error message to the salesperson’s file and don’t compute a total for that sale.
There should be ample opportunity to use Switch statements and value-returning functions
in this application.
7.4 Write a number-guessing game in which the computer selects a random number
in the range of 0 to 100, and users get a maximum of 20 attempts to guess it. At the
end of each game, users should be told whether they won or lost, and then be asked
whether they want to play again. When the user quits, the program should output the
total number of wins and losses. To make the game more interesting, the program
should vary the wording of the messages that it outputs for winning, for losing, and for
asking for another game. Create as many as 10 different messages for each of these
cases, and use random numbers to choose among them. See Appendix C.7 for
information on the C++ random-number generator functions. This application should
provide a good opportunity for you to use a Do-While statement and Switch
statements. Use functional decomposition to solve the problem, write your C++ code
using good style and documenting comments, and have fun thinking up some
messages that will surprise the user.
7.5 Write a functional decomposition and a C++ program that reads a time in numeric
form and displays it in English. The time is input as hours and minutes, separated by
a space. Hours are specified in 24-hour time (e.g., 15 is 3 p.m.), but the output should
be in 12-hour a.m./p.m. form. Note that noon and midnight are special cases. Here
are some examples:

Description
Write your C++ code using good style and documenting comments. This application
should provide you with ample opportunity to use Switch statements.
7.6 Extend the program in Problem 7.5 so that it asks the user if they want to enter
another time, and then repeats the process until the response to the question is “no.”
You should be able to code this easily using a Do-While statement.

Case Study Follow-Up
1. What changes would be necessary in the RichUncle program if uppercase letters
and lowercase letters were to be counted as members of the same category?
2. You decide that you are interested in counting the number of words in the text. How
might you estimate this number?
3. Given that you can calculate the number of words in the text, how can you
calculate the average word length?
4. Can you think of any other characteristics of a person’s writing style that you might
be able to measure?

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  8
Functions
KNOWLEDGE GOALS
To know how functions can be used to reflect the structure of a functional
decomposition.
To understand the difference between value and reference parameters.
To know how to use arguments and parameters.
SKILL GOALS
To be able to:
Write a module of your own design as a void function.
Design the parameter list for each module of a functional decomposition.
Code a program using functions.
Define and use local variables correctly.
Write a program that uses multiple calls to a single function.
You have been using C++ functions since we introduced standard library routines such as
sqrt in Chapter 3. By now, you should be comfortable with the idea of calling functions to

perform a task. But we have not yet considered how to create our own functions, other than
main. That is the topic of this chapter and the next.
You might wonder why we waited to look at user-defined subprograms. The reason—and
the major purpose for using functions—is that we write them to help organize larger programs.
Until now, our programs have been relatively small, but we are about to begin writing larger
and more complex programs, so it is time to learn this important means of organizing our
code.

8.1 Functional Decomposition with Void Functions
As a brief refresher, let’s review the two kinds of subprograms in C++: value-returning and
void functions. A value-returning function receives data through its argument list and returns a
value to the calling code. The caller invokes (calls) a value-returning function by using it in an
expression:
In contrast, a void function does not return a value, and its call is a standalone statement. An
example is the get function associated with the istream and ifstream classes:
In this chapter, we see how to create our own void functions. In Chapter 9, we consider value-
returning functions.
All along, you have been designing your programs as collections of modules. Many of these
modules can be implemented as user-defined void functions in C++.
When to Use Functions
In general, you can code any module as a function, although some are so simple that doing so
doesn’t help. In designing a program, then, we need to decide which modules to code as
functions, based on whether the overall program is easier to understand as a result. Other
factors can affect this decision, but for now this is the simplest strategy.
If a module is a single line, it is usually best to write it directly in the program. Turning it into
a function actually complicates the code, which defeats the purpose of using functions.
Conversely, if a module is many lines long, it usually makes a good function.
One case where we might implement a short module as a function is when it is used in
several places in the program. Coding the module in one place and calling it from many
places yields a better design for two reasons. First, if we code the module directly in multiple
places, there are more opportunities for us to make a mistake. We are less likely to introduce
an error if we code the module once and just call it where it’s needed. Second, if we later must
change the module algorithm, we only need to make the change once, within the function,
rather than searching the code for every place that we inserted the module directly.
Keep in mind that implementing a module as a function should affect only the readability of
the program and may make it more or less convenient to change the program later. It should
not alter the functioning of the program. We say should because whether this is true depends
on how we implement the interface to the function. We have not yet examined this aspect of
module design, which we now consider.
Why Do Modules Need an Interface Design?
Before we look at how to convert a module to a function, we need to revisit how we design a
module. Until now, our modules have simply been groups of statements that have access to

all of the values in a program. That’s fine for small problems, but it doesn’t work when we
have big problems with lots of modules.
To see why allowing every module to access every value is a bad idea, consider an
analogy. At home, people tend to keep their doors open, and they share most of their
belongings. Now suppose that you check into a hotel that’s based on the same principle—
none of the rooms have doors. There would be no privacy or security. Everyone would have
free access to everyone else’s things. (And the snoring would be terrible!) To make the hotel
safe, we need to have a lockable door on each room.
Modules in larger problems need to be designed with the equivalent of doors. They should
not have direct access to each other’s values, and information should enter and leave them
via just one carefully controlled route. We call this aspect of a module’s design its interface.
There are two views that we can take of the interface: external and internal. In our hotel room
analogy, from outside you can see just the door to the room. From inside, you can see the
door and the contents of the room. We start the interface design process with the external
view.
Designing Interfaces
From now on, we consider a module as a separate block within a design whose
implementation details are “hidden” (walled-off) from view.
How can we work with such a module? From the external perspective, as long as you
know what a module does and how to call it, you can use it without knowing how it
accomplishes its task. For example, you don’t know how the code for sqrt is written (its
implementation is hidden from view), yet you still can use it effectively.
The specification of what a module does and how it is invoked defines its interface (see
FIGURE 8.1). Hiding a module implementation is called encapsulation. When a module is
encapsulated, we don’t have to worry that it will accidentally access the values in other
modules or that other modules will be able to change its values.
Another advantage of encapsulation is that we can make internal changes to a module, as
long as the interface remains the same. For example, you can rewrite the body of an
encapsulated module using a more efficient algorithm.
Interface The formal description of what a subprogram does and how we communicate
with it.
Encapsulation Hiding a module implementation in a separate block with a formally
specified interface.

FIGURE 8.1 Module Interface (Visible) and Implementation (Hidden)
Description
One way to specify the interface to a module is to write down its purpose, its precondition
and postcondition, and the information it takes and returns. If the specification is sufficiently
complete, we could hand it to someone else, and that person could then implement the
module for us. Interfaces and encapsulation are the basis for team programming, in which a
group of programmers work together to solve a large problem.
Thus, designing a module can (and should) be divided into two tasks: designing the external
interface and designing the internal implementation. For the external interface, we focus on the
what, not the how. We define the behavior of the module (what it does) and the mechanism for
communicating with it.
To define the mechanism for communicating with the module, we make a list of the
following items:
1. Incoming values that the module receives from the caller
2. Outgoing values that the module produces and returns to the caller
3. Incoming/outgoing values—values the caller has that the module changes (receives and
returns)
Next, we turn to the internal view of the interface as the starting point for our
implementation. We choose names for variable identifiers inside the module, each of which
matches a value in our list. These identifiers become what we call the parameter list for the
module.
Henceforth, we write the parameters in the module heading. Any other variables that the
module needs are said to be local, and we declare them within its body. We do this for any
module that we anticipate implementing as a function. As part of the module interface, we also
document the direction of data flow for each parameter.
Now that we’ve seen how to design a module for implementation as a function, we are
ready to start coding modules in C++.

Module parameter list A set of variables within a module that hold values that are either
incoming to the module, outgoing to the caller, or both. Data flow The direction of flow of
information between the caller and a module through each parameter.Module parameter
list A set of variables within a module that hold values that are either incoming to the
module, outgoing to the caller, or both.
Data flow The direction of flow of information between the caller and a module through
each parameter.
Writing Modules as Void Functions
It is quite a simple matter to turn a module into a void function in C++. Basically, a void
function looks like the main function except that the function heading uses void rather than int
as the data type of the function. Additionally, the body of a void function does not contain a
statement like
as does main. That’s because a void function doesn’t return a value to its caller.
Let’s look at a program using void functions. We’ll start with a very simple example that
doesn’t have any parameters. A friend of yours is returning from a long trip, and you want to
write a program that prints the following message:
Description
Here is a design for the program:
Main
Print two lines of asterisks
Print “Welcome Home!”
Print four lines of asterisks
Level 0
Print 2 Lines
Print “***************”
Print “***************”
Level 1
Print 4 Lines
Print “***************”
Print “***************”
Level 1
 

Print “***************”
Print “***************”
 
If we write the two first-level modules as void functions, the main function is simply this:
Description
Notice how similar this code is to the main module of our functional decomposition. It
contains two function calls—one to a function named Print2Lines and another to a function
named Print4Lines. Both of these functions have empty argument lists.
The following code should look familiar to you, but look carefully at the function heading.
Description
This segment is a function definition. A function definition is the code that extends from the
function heading to the end of the block that is the body of the function. The function heading
begins with the word void, signaling to the compiler that this is not a value-returning function.
The body of the function executes some ordinary statements and does not contain a return
statement.
Now look again at the function heading. Just like any other identifier in C++, the name of a
function cannot include blanks, even though our module names do. Following the function
name is an empty parameter list—there is nothing between the parentheses. Later we see
what goes inside the parentheses if a function uses arguments.
Now let’s put main and the other two functions together to form a complete program.

Description
C++ function definitions can appear in any order. We could have chosen to place the main
function last instead of first, but C++ programmers typically put main first and any supporting
functions after it.
In the Welcome program, the two statements just before the main function are called function
prototypes. These declarations are necessary because C++ requires you to declare an
identifier before you use it. Our main function calls functions Print2Lines and Print4Lines, but
their definitions don’t appear until later. We supply the function prototypes to inform the
compiler in advance that Print2Lines and Print4Lines are void functions that have no
arguments. In addition, we include comments describing these two functions for the reader so

that the main function makes sense. We say more about function prototypes later in the
chapter.
Because the Welcome program is so simple initially, it may seem more complicated with its
modules written as functions. Upon closer inspection, however, it is clear that it much more
closely resembles our functional decomposition. If you handed this code to someone, the
person could look at the main function and tell you immediately what the program does—it
prints two lines of something, prints “Welcome Home!”, and prints four lines of something. If
you asked the person to be more specific, they could then look up the details in the function
definitions. The person is able to begin with a top-level view of the program and then study the
lower-level modules as necessary, without having to read the entire program or look at a
module structure chart. As our programs grow to include many modules nested several levels
deep, the ability to read a program at different levels of detail aids greatly in the development
and debugging process.
QUICK CHECK
8.1.1 Which elements of a functional decomposition correspond to functions in C++?
8.1.2 If the same module appears in multiple places in a functional decomposition,
how do you convert it into code in a program?
8.1.3 What items define the mechanism for communicating with a module?
8.1.4 What is the name of the specification of what a module does and how it is
invoked?
8.1.5 Write a void function called PrintName that outputs your name.
MAY WE INTRODUCE Kathleen McNulty Mauchly Antonelli
Kay McNulty in her high school graduation portrait, 1938.
Any algorithm can be expressed using the sequence, branch, and loop control structures,
a fact that has been known for over a thousand years. But with the development of the first
digital computers, with their very limited memory, it became necessary to extend this list
with the ability to refer to sequences of instructions that could be called from multiple

places in a program. The invention of this idea, originally called a subroutine, is credited to
Kathleen (Kay) McNulty, one of the programmers of the ENIAC (Electronic Numerical
Integrator And Calculator).
McNulty was born in Ireland in 1921 and emigrated to the United States at the age of
three. She attended Chestnut Hill College in Philadelphia, where she majored in
mathematics and took every math course the college offered. At the same time, she also
took as many business courses as she could, anticipating that she would look for work as
an actuary in an insurance company after graduation.
Fresh out of college, in 1942, she took a job as a “computer” for the U.S. Army. Before
the development of digital computers, the term computer was a job classification, referring
to people who carried out calculations using mechanical calculators. Her work took place
at the Moore School of Engineering, at the University of Pennsylvania, and involved
calculating ballistics tables used for aiming artillery in World War II. Each trajectory
calculation for the tables required 30 to 40 hours of work by a human computer.
Meanwhile, the Moore School also began construction of the ENIAC, one of the first
digital computers, with the goal of automating the ballistics calculations and improving their
accuracy. As it was about to become ready for use, McNulty was invited to become one of
its programmers, along with five of the other Moore School computers: Betty Jean
Jennings Bartik, Frances Elizabeth Snyder Holberton, Ruth Lichterman Teitelbaum, and
Marylin Wescoff Meltzer. Together they are known as the original ENIAC Six.
Because the ENIAC project was classified, the programmers were initially not allowed to
see the machine itself; they had to figure out how to program it by studying its circuit
diagrams. Eventually, once they had written some programs, they were allowed access to
the machine. Programming this early machine actually involved not just coding, but also
connecting wires between its different units to change the flow of data through it and setting
large banks of switches.
At one point, the team encountered a problem: the ENIAC did not have enough logic
circuits to compute some trajectories. McNulty proposed the idea of the subroutine, which
would allow a sequence of instructions to be called from multiple places in the program.
Early programming languages, such as Fortran, actually used the term subroutine; later
languages adopted alternate names, such as procedure, method, or function. We owe our
ability to more effectively organize large programs with user-defined functions to McNulty’s
pioneering insight.
In 1948, McNulty married John Mauchly, one of the lead engineers on the ENIAC
project. John Mauchly and another of the engineers, J. Presper Eckert, left the project to
start the UNIVAC company, which built some of the first computers to be sold
commercially. Kay McNulty Mauchly joined her husband at the company, working on
software for its products.
John Mauchly died in 1980. In 1985, Kay married photographer Severno Antonelli, who
died in 1996. She spent her later years lecturing, writing articles, and giving interviews
about the ENIAC project, and was inducted into the Women in Technology International
Hall of Fame in 1997. Kathleen McNulty Mauchly Antonelli died in 2006. In 2017, the Dublin
City University named its new computer science building after her, and in 2019, the Irish
Centre for High-End Computing named its new supercomputer Kay, in her honor.

8.2 An Overview of User-Defined Functions
Now that we’ve seen an example of how a program is written with functions, let’s look briefly
and informally at some of the more important points of function construction and use.
Flow of Control in Function Calls
We said that C++ function definitions may be arranged in any order. During compilation,
functions are translated in the order that they appear in the code. When the program is
executed, however, control begins at the first statement in main and proceeds in execution
order.1
When a function call is encountered, control goes to the first statement in that function’s
body and follows its remaining statements in execution order. After the last statement is
executed, control returns to the point immediately following the function call. Because function
calls alter the order of execution, functions are considered control structures. FIGURE 8.2
illustrates this physical versus execution ordering of functions. In the figure, functions A, B,
and C are coded in the order A, B, C but are executed in the order C, B, A.
In the Welcome program, execution begins with the first executable statement in the main
function (the call to Print2Lines). When Print2Lines is called, control passes to its first
statement and subsequent statements in its body. After the last statement in Print2Lines has
executed, control returns to main at the point following the call (the statement that prints
“Welcome Home!”).

Description
FIGURE 8.2 Physical Versus execution Order of Functions
Function Parameters
Looking at the Welcome program, you can see that Print2Lines and Print4Lines are very
similar functions. They differ only in the number of lines they print. Do we really need two
different functions in this program? Maybe we should write just one function that prints any
number of lines, where the “any number of lines” is passed as an argument by the caller
(main). Deciding to use only one function changes the design.
Main
Print lines (2)
Print “Welcome Home!”
Print lines (4)
Level 0
Print Lines (In: numLines) Level 1
FOR count going from 1 to numLines
Level 1

Print “***************”
 
Here is a second version of the program, with just one function to do the printing. We call it
NewWelcome.
Description
In the function heading of PrintLines, you see some code between the parentheses that
looks like a variable declaration. This code is a parameter declaration.
The items listed in the call to a function are its arguments. The variables declared in the
function heading are parameters. They provide identifiers within the function by which we can
refer to the values supplied through the arguments. Parameters are the internal view of the
function interface.
In the NewWelcome program, the arguments in the two function calls are the constants 2 and
4, and the parameter in the PrintLines function is named numLines. When the main function
calls PrintLines with an argument of 2, control is turned over to PrintLines, and numLines is
initialized to 2. Within PrintLines, the count-controlled loop executes twice, and the function
returns. The second time PrintLines is called, numLines is initialized to 4, the value of the
argument. The loop executes four times, and the function returns.
Here is another version of main, just to show that arguments can be variables instead of
constants:

Argument A variable or expression listed in a call to a function.
Parameter A variable declared in a function heading.
Description
In this version, each time main calls PrintLines, a copy of the value in lineCount is passed to
the function to initialize the parameter numLines. As you can see, the argument and the
parameter can have different names.
NewWelcome illustrates that a function can be called from many places in main (or from other
functions). If a task must be done in more than one place in a program, we can avoid
repetitive coding by writing it as a function and then calling it wherever we need it.
If more than one argument is passed to a function, the arguments and parameters are
matched by their relative positions in the two lists. For example, if you want PrintLines to print
lines consisting of any selected character, not only asterisks, you could rewrite the function so
that its heading is
A call to this function might look like this:
The first argument, 3, is matched with numLines because numLines is the first parameter.
Likewise, the second argument, '#', is matched with the second parameter, whichChar.
QUICK CHECK
8.2.1 When a function call is encountered, where does control pass to?
8.2.2 When a function returns, where is control passed to?
8.2.3 What is the difference between a function argument and a function parameter?
8.2.4 If more than one argument is passed to a function, in what order are they
matched with the parameters?

1 Actually, some parts of a C++ program execute prior to main, such as the initialization of cin
and cout. For the programs we are writing, however, it is simplest to think of execution as
starting with main.

8.3 Syntax and Semantics of Void Functions
Function Call (Invocation)
As we’ve seen, to call (or invoke) a void function, we use its name as a statement, with its
arguments in parentheses. Here is the syntax template of a function call to a void function:
Note that the argument list is optional, but the parentheses are required even if the list is
empty.
If the list includes two or more arguments, you must separate them with commas. Here is
the syntax template for ArgumentList:
When a function call is executed, the arguments are passed to the parameters in the
matching positions, and control is then transferred to the first executable statement in the
function body. When the last statement in the function has executed, control returns to the
point following the function call.
Function Declarations and Definitions
In C++, a function’s declaration must physically precede any call to it. The declaration gives
the compiler the name of the function, the form of the function’s return value (either void or a
data type like int or float), and the data types of the parameters.
The NewWelcome program contains three function declarations. The first one (the statement
with the comment // Function prototype) does not include the body of the function. The
remaining two—main and PrintLines—include bodies.
As we have already noted, informally, in C++ terminology, a function declaration that omits
the body is called a function prototype, and a declaration that includes the body is called a
function definition. We can use a Venn diagram to illustrate that all definitions are
declarations, but not all declarations are definitions:
Function prototype A function declaration without the body of the function.
Function definition A function declaration that includes the body of the function.

In general, C++ distinguishes declarations from definitions by whether memory space is
allocated as a result. For example, a function prototype is a declaration—it just tells the
compiler the properties of a function. A function definition goes a step further: it causes the
compiler to allocate space for the instructions in the function.2
The rule throughout C++ is that you can declare an item as many times as you wish, but
you can define it only once. In the NewWelcome program, we could include many function
prototypes for PrintLines (though we have no reason to do so), but only one function definition
is allowed.
Function Prototypes
Function prototypes allow us to declare functions before they are defined, so that we can
arrange their definitions in any order. As we’ve noted, C++ programmers typically define main
first, followed by all other functions.
Aside from style, there is a situation in C++ where function prototypes are essential.
Suppose that two functions, A and B, call each other. If we write the definition of A followed by
the definition of B, then within A the call to B generates a message that identifier B is
undeclared. Of course, reversing the order of the definitions won’t solve the problem. The
solution is to write a prototype for B preceding the definition of A, so that B is declared before it
is used in A. Because the prototype for B omits the function body, it doesn’t contain a call to A.
As a result, it avoids referring to A before it is declared. Notice that this special case is
automatically covered when we adopt the style of writing prototypes for all of our functions
preceding main.
A prototype for a void function has the following syntax:
As you can see in the template, no body is included for the function, and a semicolon
terminates the declaration. The parameter list is optional, to allow for parameterless functions.
If the parameter list is present, it has the following form:

The ampersand (&) attached to the name of a data type is optional and is explained later in the
chapter.
In a function prototype, the parameter list must specify the data types of the parameters,
but their names are optional. You could write either
or
It’s helpful for reading the code to supply names for the parameters, but be aware that the
compiler ignores them.
Function Definitions
As you are already aware, from having written the function main, a function definition consists
of two parts: the function’s heading and its body, which is syntactically a block (compound
statement). Here’s the syntax template for a void function definition:
Notice that the function heading does not end in a semicolon the way a function prototype
does. Including a semicolon will generate a syntax error.
The syntax of the parameter list differs from the function prototype in that you must specify
the names of the parameters. Also, it’s our style preference (but not a C++ language
requirement) to declare each parameter on a separate line:

Local Variables
Because a function body is a block, any function—not just main—can include variable
declarations. These variables are called local variables because they are accessible only
within the block in which they are declared. As far as the calling code is concerned, they don’t
exist. If you tried to output the contents of a local variable from another function, a compile-
time error such as UNDE CLARED IDENTIFIER would occur. You saw an example of a local
variable in the NewWelcome program—the count variable declared within the PrintLines function.
In contrast to local variables, variables declared outside of all the functions in a program are
called global variables. We return to the topic of global variables in Chapter 9.
Local variables occupy memory space only while the function is executing. When the
function is called, memory space is allocated for its local variables. When the function returns,
the memory space for its local variables is recycled for future use. Therefore, every time the
function is called, its local variables start out with undefined values. That means you must
initialize local variables within the function itself. Also, because their memory is recycled when
the function returns, you cannot use local variables to store values between calls to the
function.
The following code segment illustrates each of the parts of the function declaration and
calling mechanism:
Local variable A variable declared within a block and not accessible outside of that block.

Description
The Return Statement
The main function uses the statement
to return the value 0 to its caller, the operating system.
As we’ve seen, a void function does not return a function value. Control returns from the
function when it “falls off ” the end of the body—that is, after the final statement has executed.
As you saw in the NewWelcome program, the PrintLines function simply prints some lines of
asterisks and then returns.
Alternatively, you can use a second form of the Return statement. It looks like this:
This statement is valid only for void functions. It can appear anywhere in the body of the
function; it causes control to exit the function immediately and return to the caller. Here’s an
example:

Description
In this (nonsense) example, there are two ways for control to exit the function. At function
entry, the value of n is tested. If it is greater than 50, the function prints a message and returns
without executing any more statements. If n is less than or equal to 50, the If statement’s body
is skipped, and control proceeds to the assignment statement. After the last statement,
control returns to the caller.
Another way of writing this function is to use an If-Then-Else structure:
Description
If you asked different programmers about these two versions of the function, you would get
differing opinions. Some prefer the first version, saying that it is most straightforward to use
Return statements whenever it logically makes sense. Others insist on a single-entry, single-
exit approach. With this philosophy, control enters a function at one point only (the first
executable statement) and exits at one point only (the end of the body). These programmers
argue that multiple exits make the code harder to follow and debug. Other programmers take
a position somewhere between the two extremes, allowing occasional use of the Return
statement when the logic is clear. Our advice is to use the Return statement sparingly;
overuse can lead to confusing code.
MATTER S OF STYLE Naming Void Functions

When you choose a name for a void function, keep in mind how calls to it will look. A call is
written as a statement; therefore, it should sound like an imperative verb or have an
imperative verb as part of it. (An imperative verb calls for an action: Do this!) For example,
the statement
has no verb. Adding the verb Print makes the name sound like an action:
When picking a name for a void function, try to find one that sounds like a command to the
computer.
QUICK CHECK
8.3.1 Where do declarations of functions that are called by main appear in the program
with respect to main?
8.3.2 Which parts of a program can access a local variable declared within a
function’s block?
8.3.3 What is a function prototype?
8.3.4 Why are function prototypes useful?
8.3.5 Write a void function prototype for a function called UpdateRace that takes an
integer and floating-point parameter in that order.
8.3.6 What is a variable called when it is declared within a block and not accessible
outside of that block?
2 Technically, all of the variable declarations we‘ve used so far have been variable idefinitions
as well as declarations—they allocate memory for the variable. In Chapter 9, we see
examples of variable declarations that aren‘t variable definitions.

8.4 Parameters
When a function is executed, it uses the arguments given to it in the call. How is this done?
The answer depends on the nature of the parameters. C++ supports two kinds of parameters:
value parameters and reference parameters. With a value parameter, the function receives
a copy of the argument’s value. This is the kind of parameter we’ve been using so far. With a
reference parameter, the function receives the location (memory address) of the caller’s
argument. A reference parameter is declared by adding an ampersand (&) to the data type
name. Before we examine in detail the difference between these two kinds of parameters, let’s
look at an example of a function heading with a mixture of reference and value parameter
declarations:
Value parameter A parameter that receives a copy of the value of the corresponding
argument.
Reference parameter A parameter that receives the location (memory address) of the
caller’s argument.
Description
With simple data types—int, char, float, and so on—a value parameter is the default
(assumed) kind of parameter. In other words, if you don’t do anything special (add an
ampersand), a parameter is assumed to be a value parameter. To specify a reference
parameter, you have to do something extra (attach an ampersand).
Now let’s look at both kinds of parameters, starting with value parameters.
Value Parameters
In the NewWelcome program, the PrintLines function heading is
The parameter numLines is a value parameter because its data type name doesn’t end in &. If
the function is called using an argument lineCount,
then the parameter numLines is initialized with a copy of the value of lineCount. At this
moment, there are two copies of the data in different memory locations—one in the argument
lineCount and one in the parameter numLines. If a statement inside the PrintLines function

changes the value of numLines, the change doesn’t affect the argument lineCount.
(Remember, lineCount and numLines are stored in two different memory locations.) As you
can see, using value parameters helps us avoid unintentional changes to arguments.
Because value parameters are passed copies of their arguments, anything that has a value
may be passed to a value parameter. This includes constants, variables, and even arbitrarily
complicated expressions. (The expression is simply evaluated, and a copy of the result is
sent to the corresponding value parameter.) For the PrintLines function, the following function
calls are all valid:
Description
There must be the same number of arguments in a function call as there are parameters in
the function heading.3 Also, each argument should have the same data type as the parameter
in the same position. Notice how each parameter in the following example is matched to the
argument in the same position (the data type of each argument is what you would assume
from its name):
If the matched items are not of the same data type, implicit type coercion takes place. For
example, if a parameter is of type int, an argument that is a float expression is coerced to an
int value before it is passed to the function. As usual in C++, you can avoid unintended type
coercion by using an explicit type cast or, better yet, by not mixing data types at all.
As we have stressed, a value parameter receives a copy of the argument and, therefore,
the caller’s argument cannot be accessed directly or changed. When a function returns, the
contents of its value parameters are destroyed, along with the contents of its local variables.
The difference between value parameters and local variables is that the values of local
variables are undefined when a function starts to execute, whereas value parameters are
automatically initialized to the values of the corresponding arguments.
Because the contents of value parameters are destroyed when the function returns, they
cannot be used to return information to the calling code. What if we do want to return
information by modifying the caller’s arguments? We must use reference parameters.
Reference Parameters
A reference parameter is one that you declare by attaching an ampersand to the name of its
data type. It is called a reference parameter because the called function can refer to the

corresponding argument directly. Specifically, the function is allowed to inspect and modify the
caller’s argument.
When a function is invoked using a reference parameter, it is the location (memory
address) of the argument—not its value—that is passed to the function. Only one copy of the
information exists, and it is used by both the caller and the function. The argument and the
parameter are synonyms for the same location in memory. If the function assigns a new value
to the parameter, it is also changing the argument. Thus, when the function returns, the
contents of the argument may have changed, which is not possible with a value parameter
(see FIGURE 8.3).
FIGURE 8.3 Using a Reference Parameter to Access an Argument
Description
You must be careful when using a reference parameter, because any change made to it
affects the argument in the calling code. Here is an example of a heading and a call:
Description
For the highlighted arguments, the addresses of floatVar and charVar are passed to num1 and
letter, respectively. Because num2 is a value parameter, it receives the value stored in intVar.

Another important difference between value and reference parameters relates to matching
arguments with parameters. With value parameters, we said that implicit type coercion
occurs. (The value of the argument is coerced, if possible, to the data type of the parameter.)
In contrast, reference parameters require that the matched items must have exactly the same
data type. And because the argument passed to a reference parameter can be changed, it
must be a variable. Unlike value parameters, we cannot pass constants or expressions to a
reference parameter.
Earlier in this chapter, we discussed documenting data flow direction in modules. Function
parameters corresponding to Out and In/out module parameters must have an ampersand
attached to their type when converting them to C++ code. We do not attach an ampersand to
In parameters.
The following table summarizes the usage of arguments and parameters.
Item
Usage
Argument Appears in a function call. The corresponding parameter may be either a reference
parameter or a value parameter.
Value
parameter
Appears in a function heading. Receives a copy of the value of the corresponding
argument, which will be coerced if necessary. Its argument can be a variable, a
constant, or an expression.
Reference
parameter
Appears in a function heading. Receives the address of the corresponding
argument. Its corresponding type must have an ampersand (&) appended to it. The
type of an argument must exactly match the type of the parameter, and it must be
a variable.
SOFTWARE MAINTENANCE CASE STUDY R efactoring a
Program
MAINTENANCE TASK: For the Problem-Solving Case Study in Chapter 3, we wrote a
mortgage payment calculator. In the Software Maintenance Case Study in Chapter 4, we
changed it to use file I/O. In Chapter 5, we revised the input to allow interest to be entered
either as a decimal or as a percentage. In Chapter 6, we expanded the program’s
capabilities, including calculation of the total interest paid over the period of the loan and
allowing entry of data for multiple loans in one run. Needless to say, by now this program
has gotten quite long and complicated. It’s time to refactor it.
When the goal of a maintenance project is to improve the maintainability of a program
without changing its functionality, the process is called refactoring. Because this program
has been changed so much, let’s start over with a problem statement and a functional
decomposition. In a refactoring situation, however, our decomposition is done in light of the
known solution. In many cases, the process involves arranging existing statements into
encapsulated functions so the code is easier to understand and modify.
Refactoring Modifying code to improve its quality without changing itsfunctionality.

PROBLEM STATEMENT: Write a program that calculates the monthly payment for a loan,
given the loan amount, the length of the loan in years, and the interest rate in either decimal
or percentage form. The input values, the monthly payment, and the total interest paid
should be output on the standard I/O device.
The loop that we added was based on a sentinel value: A negative loan payment ended
the processing. We do the same here. The main module can be written from this problem
statement with no further discussion.
Main
Level 0
Get loan amount
WHILE loan amount is greater than zero
Get rest of input (interest and number of years)
Set numberOfPayments to numberOfYears * 12
Determine payment
Set totalInterest to payment * numberOfPayments — loanAmount
Output results
Get loan amount
GetLoanAmt(Out: loanAmount)
Level 1
In the original design, we displayed all the prompts together and displayed them again at
the end of the loop. A better design is to separate the prompt for the loan amount from the
prompts for the other values, and to issue each prompt just before the respective value is
read.
Display “Input loan amount. A negative loan amount ends the processing.”
Read loanAmount
GetRest(Out: monthlyInterest, numberOfYears)
Level 1
Get monthlyInterest
Get Years
GetInterest(Out: monthlyInterest)
Level 2
Remember that the yearly interest can be entered either as a percentage or as a decimal
value. The GetInterest module can decide which form was used for input and send the
appropriate value back to the calling module.
Display “Input interest rate. An interest rate of less than 0.25 is assumed to be ” “a
decimal rather than a percentage.”
Read yearlyInterest
IF (yearlyInterest greater than or equal to 0.25)

Set yearlyInterest to yearlyInterest / 100
Set monthlyInterest to yearlyInterest / 12
GetYears(Out: numberOfYears)
Level 2
Display “Enter number of years of the loan.”
Read numberOfYears
DeterminePayment(Out: 
payment; 
In: 
loanAmount, 
monthlyInterest,
numberOfPayments)
Level
1
Set payment to (loanAmount * pow(1 + monthlyInterest, numberOfPayments) *
monthlyInterest)/(pow(1 + monthlyInterest, numberOfPayments) - 1);
OutputResults(In: loanAmount, yearlyInterest, numberOfPayments, payment,
totalInterest)
Level
1
Previously, we computed the total interest in the output statement because the calculation
was an add-on feature. Here we have put it where it belongs in the main module. However,
we leave conversion of the interest rate to a percentage as part of the output.
Display “Loan amount: ” loanAmount
Display “Interest rate: ” interestRate * 100, “%”
Display “Number of payments: ” numberOfPayments
Display “Monthly payments: ” payment
Display “Total interest: ” totalInterest
There are several things to note about this decomposition. First, issuing the prompts
when they are needed keeps us from repeating an extra request for the interest rate and
length of the loan. Second, one module—GetLoanAmt—is called from two different places
in the design. Third, module OutputResults has no formatting information. At the design
stage, we can specify what the output should look like, but not how the formatting is done,
which is specific to the C++ implementation. If there are specific formatting requirements,
they would appear in the problem statement.
MODULE STRUCTURE CHART

Description
This looks like a complicated design for such a simple problem. Do we need to
represent each module as a C++ function? The answer depends on your programming
style. Some modules definitely should be functions—for example, OutputResults. Other
modules probably should not—for example, GetYears. Whether to implement a module as
a function is up to the programmer. As we stated earlier, the key question is whether using
a function makes the code easier to understand.
Here, we choose to turn all of the modules except GetYears into functions. Although
GetLoanAmt is only two lines long, it is called from two places and, therefore, should be a
function. Module DeterminePayment is only one statement long, but it is a complicated
statement. It is appropriate to push the formula to a lower level. When reading main we
don’t need to know how the payment amount is calculated.
The first step is to create the function prototypes, being sure that all Out and In/out
parameters have ampersands attached to their data types. We include parameter names
in the prototypes because meaningful identifiers help document what each parameter
does.
Description
We suggest documenting modules with a descriptive comment beside each parameter
and marking the direction of flow. We do show the direction of flow on each module

parameter, but it is necessary to document (comment) a parameter in the code only when
the name isn’t self-explanatory.
In C++, the absence of an ampersand on the type indicates that its direction of flow is In.
If the parameter has an ampersand, it is either an Out or an In/out parameter. Out is more
common, so we do not explicitly document this case. When the value is both used and
changed, then adding a comment identifying it as In/out would be useful. There is no such
example in this problem.
Description


Description
Description
Sample output:
Description
THEORETICAL FOUNDAT IONS A rgument-Passing
Mechanisms
There are two major ways of passing arguments to and from subprograms. C++ supports
both mechanisms. Some languages, such as Java, support just one.
C++ reference parameters employ a mechanism called pass by address or pass by
location, in which a memory address is passed to the function. Another name for this

technique is pass by reference, so called because the function can refer directly to the
caller’s variable that is specified in the argument list.
C++ value parameters are an example of the pass by value mechanism. The function
receives a copy of the value of the caller’s argument. Passing by value can be less
efficient than passing by address because the value of an argument may occupy many
memory locations, whereas an address usually occupies only a single location. For the
simple data types int, char, bool, and float, the efficiency of either mechanism is about
the same. Java supports only pass by value, although many of its data types are
represented by an address that references the actual information, so in practice it passes
arguments with efficiency comparable to C++.
A third method of passing arguments is called pass by name. With this mechanism, the
argument is passed to the function as a character string that must be interpreted by
special run-time support software called a thunk. Passing by name is less efficient than
the other two argument-passing mechanisms. It is supported by the older ALGOL and
LISP programming languages, but not by C++. More recently, a research language called
Haskell has implemented a variation of pass by name, called pass by need, which
remembers the interpretation of the string between calls so that subsequent calls can be
more efficient.
There are two different ways of matching arguments with parameters, although C++
supports only one of them. Most programming languages (C++ among them) match
arguments and parameters based on their relative positions in the argument and
parameter lists. This technique is called positional matching, relative matching, or implicit
matching. A few languages, such as Ada, also support explicit or named matching. In
explicit matching, the argument list specifies the name of the parameter to be associated
with each argument. Explicit matching allows arguments to be written in any order in the
function call. The real advantage is that each call documents precisely which values are
being passed to which parameters.
A Last Word of Caution About Argument and Parameter Lists
It is the programmer’s responsibility to make sure that the argument list and parameter list
match up semantically as well as syntactically. For example, suppose we had written the
modification to the LoanCalculator program as follows. Can you spot the error?

Description
The argument list in the last function call matches the parameter list in its number and type of
arguments, so there is no syntax error. However, the output would be wrong because the first
two arguments are switched. If a function has two parameters of the same data type, you
must be careful that the arguments are in the correct order.
SOFTWARE ENGINEERING TIP Conceptual Versus Physical
Hiding of a Function Implementation
In some programming languages, the encapsulation of an implementation is purely
conceptual. The function implementation and interface are written together. C++, however,
permits function implementations to be written and stored separately from main.
Larger C++ programs are usually split into separate files. One file might contain the
source for main; another file, the source for functions invoked by main; and so on. This
organization is called a multifile program. The compiler translates the source code in each
file into object code. A program called the linker then collects all the resulting object code
into a single executable program file.
When you write a program that invokes a function located in another file, it isn’t
necessary for that function’s source code to be available. You just need to include a
function prototype so that the compiler can check the syntax of each call. After the
compiler finishes its work, the linker finds the object code for that function and links it with
your main function’s object code. We do this whenever we invoke library functions. C++
systems supply only the object code—not the source code—for library functions like sqrt.
The source code for their implementations is physically hidden from view.
One advantage of physical hiding is that it prevents programmers from taking advantage
of any unusual features of a function’s implementation. For example, suppose we want a
program to read temperatures and output activities repeatedly. Knowing that the GetTemp
function doesn’t perform range checking on the input, we might be tempted to use -1000
as a sentinel for the loop:

Description
This code works for now, but what if another programmer improves GetTemp so it checks
for a valid temperature range (as it should):
Description
Unfortunately, this improvement causes main to enter an infinite loop because GetTemp
won’t let us enter —1000. If the original implementation of GetTemp had been physically
hidden, we would not have relied on the fact that it does not perform error checking.
Later in the text, you will learn how to write multifile programs and hide implementations
physically. In the meantime, we conscientiously avoid writing code that depends on the
internal workings of a function.
Writing Assertions as Function Documentation

We have been talking informally about preconditions and postconditions, but we can include
formal preconditions and postconditions as comments to document function interfaces.
Here’s an example:
Description
The precondition is an assertion describing everything that the function requires to be true at
invocation. The postcondition describes what will have happened by the time the function
finishes executing.
You can think of the precondition and the postcondition as forming a contract. The contract
states that if the precondition is true at function entry, then the postcondition must be true at
function exit. The caller is responsible for ensuring the precondition, and the function body
must ensure the postcondition. If the caller fails to satisfy its part of the contract (the
precondition), the function cannot guarantee that the postcondition will be true.
In the preceding example, the precondition warns the caller to make sure that sum has been
assigned a meaningful value and that count is positive. If this precondition is true, the function
guarantees it will satisfy the postcondition. If count isn’t positive when OutputAverage is
invoked, the effect of the module is undefined. (For example, if count equals 0, the
postcondition surely isn’t satisfied—the module crashes!)
Sometimes the caller doesn’t need to satisfy any precondition before calling a function. In
this case, the precondition can be omitted. In the following example, no precondition is
necessary:
Description
MATTERS OF STYLE Function Documentation

Preconditions and postconditions, when well written, provide a concise but accurate
description of the behavior of a function. A person reading your function should be able to
see at a glance how to use the function simply by looking at its interface (the heading and
the precondition and postcondition). The reader should never have to look into the function
body to understand its purpose or use.
A function interface describes what the function does, not the details of how it works its
magic. For this reason, the postcondition should mention (by name) each outgoing
parameter and its value but should not mention any local variables. Local variables are
implementation details; they are irrelevant to the module’s interface.
Some programmers place comments next to the parameters to explain how each
parameter is used and use embedded comments to indicate which of the data flow
categories each parameter belongs to.
Description
To write a postcondition that refers to initial parameter values versus values assigned to
them later, you can use the expression “at entry” or abbreviate it by appending the variable
name with @entry. For example, the following Swap function exchanges, or swaps, the
contents of its two parameters and gives us an opportunity to show both ways of indicating
their initial values.
Description
QUICK CHECK
8.4.1 Why does C++ allow only variables to be passed as an argument to a reference
parameter?
8.4.2 Why is it important for a programmer to make sure that the argument list and
parameter list match up not only syntactically, but also semantically?

8.4.3 Which character do we use to indicate a reference parameter, and where does it
appear in the parameter’s declaration?
8.4.4 Where do arguments appear, and where do parameters appear?
8.4.5 You are writing a function to return the first name from a string containing a full
name. How many parameters does the function have, and which of them are
reference parameters and which are value parameters?
8.4.6 Which kind of parameter would you use for an incoming value from an
argument? For an outgoing value? For a value that comes in, is changed, and returns
to the argument?
Problem-Solving Case Study
LAWN CARE COMPA NY BILLING
PROBLEM: A lawn care company has hired you to write a program to help with monthly
billing. The company works for each client several times a month. Customers are billed by
the number of hours spent on each job. The monthly record for a client consists of a sheet
with the client’s name, address, and a series of times in hours and minutes. Your program
will read this information from a file, print a bill for each client, and then output the monthly
total billed and average job time and charges for the company.
INPUT: A file contains a series of client records. Each client record begins with the
customer’s name and address. On the following line is a number indicating how many jobs
were done for the client that month. Following that number are a series of times, one on
each line, made up of a pair of integer values (hours and minutes). The name is written in
last, first, middle format, with blanks separating the three parts. An address consists of a
street address, a city, a state, and a ZIP code. The street address is on one line, and the
city, state, and ZIP code are on the next line, separated by blanks. Here’s an example of a
client record:
Description
The input file name may change, so the user should be prompted to enter the input file
name.
OUTPUT

File: A file made up of each client’s bill, which contains a labeled copy of the input
record, the total hours worked, and the payment amount. The output file name may
change, so the user must be prompted to enter the output file’s name. The file on
which the output is based (the input file’s name) must be written on the output file.
Screen: A summary statement showing the monthly total of all charges and the
average time and charges for the company.
DISCUSSION: The processing takes place in two parts: producing the client’s bill and
calculating the summary statistics. The input file doesn’t contain the number of records, so
the processing must be based on reaching the end-of-file condition. What about the hourly
rate? We should ask the user to input the hourly rate at the beginning of each run.
Main
Level 0
Open files
IF files don’t open properly
Display “Error opening files”
Quit
Get hourly rate
Process Clients
Close files
OpenFiles(In/out: inFile, outFile)
Level 1
We have marked the files as In/out. Although we only read from the input file, it must be
marked In/out because the reading pointer in the file changes during the reading process.
Likewise, we only write to the output file, but the file itself is input to the module, which then
changes the file’s contents.
Display “Enter the name of the input file.”
Read inFileName
Open inFile with inFileName
Display “Enter the name of the output file.”
Read outFileName
Open outFile with outFileName
Write on outFile “Billing for clients on file ” inFileName
GetHourlyRate(Out: hourlyRate)
Level 1
Display “Enter hourly rate.”
Read hourlyRate
ProcessClients(In/out: inFile, outFile; In: hourlyRate)
Level 1
Module ProcessClients reads and processes all the bills. The loop is an end-of-file loop, so
we need a priming read before the loop. We read the name before the loop and again at the
end of each iteration. We then output the name as the first step in the loop body. We do not
need to keep a running total of the charges, because we can calculate it given the total

time and the hourly rate. We do, however, have to keep a count of the number of clients so
that we can calculate the averages.
Set totalTime to 0
Set numberOfBills to 0
Get name
WHILE inFile
Write name
ProcessAClient
Increment numberOfBills
Get name
Print results
Before we continue with the decomposition, we need to think more about printing the
bills. The client’s name is written in last, first, middle format on the file. Is it okay to print the
bills with the name still in this format? If so, the name can simply be kept as a string; it
doesn’t have to be broken up into first, last, and middle parts. There is nothing in the
instructions that gives us any information about what the format of the name should be on
the bill, so we call the customer. She says that any format is fine for the output. Thus
modules GetName and WriteName do not need further decomposition.
ProcessAClient(In/out: inFile, outFile, totalTme; In: hourlyWages)
Level 2
The number of jobs follows the client address. This value can be used to control a loop
that reads and sums hours and minutes. For calculating purposes, we would prefer to
have the time in a form that can be multiplied by the hourly rate. We can convert the time
either to a float, representing hours and the fraction of an hour, or to an int, representing
minutes. For calculating the individual charges, it makes no difference which way we
represent the time. In summing up the total time, however, it will be more accurate to add
up a series of int values than float values. float values can have small errors in their
least significant digits. The more of them we add up, the greater this total error will be.
Thus, we change the time to minutes, divide it by 60 (the number of minutes in an hour),
and multiply that value by the hourly rate. We’ll also keep totalTime in minutes. We can
convert the minutes back to hours and minutes before outputting the final summary.
Set time to 0
Read numberOfJobs
Write “Number of jobs: ” numberOfJobs
Get Address
Print Address
FOR count going from 1 through numberOfJobs
Read hours
Read minutes
Set time to hours * 60 + minutes + time

Write “Job ”, count, “: ”, hours, “ and ”, minutes, “ minutes ”
Set cost to totalTime / 60 * hourlyRate
Write “Amount of bill: $” cost
Set totalTime to totalTime + time
The address is formatted in the file as it should be on the bill, so the address can just be
written to the output file as it is read. Thus GetAddress and WriteAddress should be
combined into one module.
GetAndPrintAddress(In/out: inFile, outFile)
Level 3
Read street line
Write street line
Read city line
Write city line
PrintResults(In: numberOfBills, totalMinutes)
Level 2
Print “Total amount billed this month is ” totalMinutes/60 * hourlyRate
Print “Average time worked per job is ” totalMinutes / numberOfBills / 60
Print “Average customer bill is ” totalMinutes/60 * hourlyRate / numberOfBills
Description

The only module that is simple enough to code directly is GetHourlyRate. All of the other
modules should be coded as functions. However, before we start coding, we need to
consider whether any problems might come up in the translation from pseudocode to C++.
Two common places where errors often lurk are complex input and mixed-mode
arithmetic; both occur here.
Let’s first look at the input, which occurs across several modules. The following table
shows the variables in the order they are read, the function in which the reads occur, the
types of input statement to use, and the positions in which the reads leave the file. Recall
that the stream input operator (>>) cannot be used with strings that might contain blanks.
Description
We input hourlyRate from the keyboard, and the remaining input comes from the file. The
name and address (two lines) are read, leaving the file pointer at the beginning of the line
following the address, ready to read the integer numberOfJobs. The three integer values
(numberOfJobs, hours, and minutes) are read, skipping any extra blanks or lines. There
is, however, a problem. Look at where the input operator leaves the file pointer after the
last numeric read: at the blank or end of line (eoln) that ended the numeric read. Thus the
input statement that should read the name reads the eoln and stores it into name. How can
we get around this problem? We issue a getline command immediately after the minutes
are read, moving the file pointer to the beginning of the next line.
What about mixed-mode arithmetic? Let’s examine the variables, their types, and the
expressions in which they occur. Here is a table listing the variables, the places where
they are declared, and their data types.
Variable
Location Declared
Type
hourlyRate
main
float
totalTime
ProcessClients
int
time
ProcessAClient
int

hours
ProcessAClient
int
minutes
ProcessAClient
int
cost
ProcessAClient
float
numberOfJobs
ProcessAClient
int
Now let’s look at the types of the variables in the context of the expressions in which
they are used. We show each expression rewritten as a comment where we’ve replaced
the variable names with their types. Here’s ProcessAClient:
Description
The calculations of time and totalTime are okay, but the calculation of cost will give the
wrong answer. The first int value (time) must be cast to a float for the calculations to be
accurate. We should also change the int constant 60 to the float constant 60.0.
Next we look at PrintResults:
Description
There are problems in all three of these expressions. For starters, totalMinutes is an int
parameter. The first statement in the function should declare a local float variable and set
it to the argument cast as a float. The expressions should all be written using this local
variable. We should also use 60.0 instead of 60 and explicitly cast numberOfBills to float.
Now the modules can be converted to C++ and the program tested. If we had not looked
at these two possible problem areas in advance, we would have spent much time trying to
decipher why the output was wrong. Here is the code:

Description


Description


Description
Description
TESTING: Devising a test plan for this program brings up an interesting question: Should
the program include tests to confirm that the input file is correctly formatted or should
correctly formatted input be a precondition? If we want to include some checks, how would
we do that? For example, how would the application recognize that an address contains
only one line? What if the name line is missing? And if the program did check input
formatting, what should it do in the case of errors? In this case, given that checking input is
more complicated than processing it, we make the correct format a precondition.
Given that the program assumes correct input, which cases do we need to check during
testing? We need to have customers who have no jobs, one job, and more than one job.
We also need runs with no customers, one customer, and more than one customer.
The following input file contains multiple customers with varying numbers of jobs. You
are asked to test the program with no customers and one customer in the Case Study
Follow-Up exercises.

Description
Description
OUTPUT FILE Lawn.out

Description
3 This statement is not the whole truth. C++ has a special language feature—called default
parameters—that lets you call a function with fewer arguments than parameters. We do not
cover default parameters in this text.

Graphical User Interface (GUI)
This chapter is about functions and their value for abstraction as an aspect of software
engineering and good program design. In the case study we decomposed the problem into
independent functions. In this section we will change the code in the functions we defined
previously to use GUI widgets. As you will see, most functions remain untouched; only those
that require user interaction are modified. Not only are functions a powerful mechanism for
decomposing a program into individual parts, but they are also critical for the separation of the
design from the implementation in a manner that enables future modification.
In this section we focus only on the functions that we change and any new functions we
introduce. Note how using functions is enabling us to focus our GUI discussion on a smaller
portion of the application. We need to introduce three new functions to handle aspects of the
user interaction. The following are the prototypes for these functions:
Description
The GetInputFileName function will ask the user for the file name containing the billing
information, the GetOutputFileName will prompt the user for the file to generate the report to,
and the GetHourlyRate function will have the user input the hourly rate. Both the GetInput-
FileName and GetOutputFileName functions are given a string reference parameter to which
the function will assign the response from the user. Let’s first look at the original main function:

Description
We first declare the important variables for hourly rate, input, and output file names. Next, we
call OpenFiles, passing references to inFile and outFile as parameters. The goal of
OpenFiles is to ask the user for the input and output files and assign the new files to inFile
and outFile. The previous program asked the user to type in the names. Our new program is
going to use GUI widgets. Here is our new version of the OpenFiles function:

Description
We have modified this function to include a third parameter to indicate if opening the files was
successful or not, which will be useful when we return from this function and need to
determine if it opened the files properly. We also include calls to GetInputFileName and
GetOutputFileName, which will create the appropriate GUI widgets to interact with the user. The
GetInputFileName function is straightforward:
Description
We create a FileDialog widget allowing the user to choose the input file containing the lawn
care billing information. The GetOutputFileName function then asks the user for the output file:

Description
Description
In this function we use a new GUI widget called NewFileDialog. The NewFileDialog is similar to
the FileDialog in that it allows you to select a file; however, the NewFileDialog also allows you
to create a new file if it does not already exist. Here are the two GUI widgets so you can see
their differences:
Description

Description
Notice that both allow you to select a file. However, the second dialog has a button labeled
“Save” rather than “Open”. There is also a space that allows the user to type in the name of a
file that does not exist, which the GUI widget will create.
After we get the input and output files, we need a GUI widget to input the hourly rate as a
floating point value. The original main function simply uses cin for this. We will replace that with
the GetHourlyRate function:
Description
With these three function definitions we can rewrite the original main function as follows:

Description
We define an additional Boolean variable, filesOK, that we use to determine if OpenFiles is
successful or not. The If statement checks the filesOK variable and if it is false (the input and
output files were not opened correctly), we create a MessageDialog GUI widget to
communicate to the user that there was a problem. It looks like this:
Description
We then call GetHourlyRate to get the hourly rate floating point value and feed the results to
ProcessClients to do most of the work. The ProcessClients function displays the final results
to the console, so we need to update that function to use a GUI widget for the output:

Description
As you can see, we use an ostringstream object rather than cout to capture the output and
create a new OutputDialog widget to display the final results. Note that the interface to the
PrintResults function didn’t change. We only modified its operation, so there is no need to
change its call within main. Such a change is know as code refactoring, and it is another
example of how functions enable us to separate the design of a solution from its
implementation. Here is an example of the final result dialog:
Description
The entirety of the GUI version of the program is listed below.

Description

Description


Description

Description


Testing and Debugging
The parameters declared by a function and the arguments that are passed to the function by
the caller must satisfy the interface to the function. Errors that occur with functions often are
due to incorrect use of the interface.
One source of errors is mismatched argument and parameter lists. The C++ compiler
ensures that the lists have the same number of items with compatible types. It is the
programmer’s responsibility, however, to verify that each argument list contains the correct
items. We must always check the parameter declarations against the argument list in every
call to the function. This job is much easier if the function heading gives each parameter a
distinct name and further describes its purpose in a comment, if necessary. You can avoid
mistakes in the argument list by using descriptive variable names to indicate exactly what
information is being passed to the function.
Another source of errors is failure to ensure that the precondition for a function is met before
it is called. For example, if a function assumes that the input file is not at EOF when it is
called, then the calling code must ensure that this assumption holds before making the call. If
a function behaves incorrectly, review its precondition, then trace the program execution up to
the point of the call to verify the precondition. You can waste a lot of time trying to locate an
error in a correct function when the error is really in how the program sets up the call.
If the arguments match the parameters and the precondition is correctly established, then
the source of the error is most likely in the function itself. Trace the function to verify that it
transforms the precondition into the postcondition. Determine whether all local variables are
initialized properly. Parameters that are supposed to return data to the caller must be declared
as reference parameters (with an & symbol attached to the data type name).
An important technique for debugging a function is to use your system’s debugger, if one is
available, to step through the execution of the function. If a debugger is not available, you can
insert debug output statements to display the values of the arguments immediately before and
after calls to the function. It also may help to display the values of local variables from within
the function. This information provides a snapshot of the function (a picture of its status at a
particular moment in time), which is useful in verifying hand traces.
To test a function thoroughly, you must arrange the incoming values so that the precondition
is pushed to its limits; then the postcondition must be verified. For example, if a function
requires a parameter to be within a certain range, try calling the function with values in the
middle of that range and at its extremes.
The assert Library Function
We have discussed how function preconditions and postconditions are useful for debugging
and for testing. To state the preconditions and postconditions for our functions, we’ve been
writing them as comments:
Of course, the compiler ignores comments. They are not executable statements; they are for
humans to examine.

The C++ standard library also gives us a way to write executable assertions. Through the
header file cassert, the library provides a void function named assert. This function takes a
logical (Boolean) expression as an argument and halts the program if the expression is false.
Here’s an example:
Description
The argument to the assert function must be a valid C++ logical expression. If its value is
true, nothing happens; execution just continues. If its value is false, execution of the program
terminates immediately with a message stating (1) the assertion as it appears in the argument
list, (2) the name of the file containing the program source code, and (3) the line number in the
program. In the preceding example, if the value of studentCount is less than or equal to 0, the
program halts after displaying a message like this:
(This message doesn’t mean that studentCount is greater than 0. In fact, it’s just the opposite.
The message tells you that the assertion studentCount > 0 is false.)
Executable assertions have a profound advantage over assertions expressed as
comments: The effect of a false assertion is highly visible. (The program terminates with an
error message.) The assert function is, therefore, valuable in software testing. A program
under development may have many calls to assert to help identify where errors are occurring.
If an assertion is false, the error message gives the precise line number of the failed
assertion.
There is also a convenient way to disable the assertions without removing them. Insert the
preprocessor directive #define NDEBUG before the include, like this:
Then all calls to the assert function are ignored when you run the program. (NDEBUG stands for
“No debug,” and a #define directive is a preprocessor feature that we won’t discuss right
now.) After a program is tested, you can thus “turn off” assertion checking without having to
remove the assertion code. If you need to turn checking back on, just put // before the #define
NDEBUG to turn the line into a comment.
As useful as the assert function is, it has two limitations. First, the argument to the function
must be expressed as a C++ logical expression. We can turn a comment such as

into an executable assertion with the following statement:
Conversely, there is no easy way to turn the comment
into a C++ logical expression.
The second limitation is that the assert function is appropriate only for testing a program
under development. A production program (one that has been released to the public) must
give helpful error messages to the user. You can imagine how baffled a user would be if a
program suddenly quit and displayed an error message such as:
Despite these limitations, you should consider using assert as a regular tool for testing and
debugging.
Testing and Debugging
1. Follow documentation guidelines carefully when writing functions (see Appendix F). As
your programs become more complex, it becomes increasingly important to adhere to
documentation and formatting standards. Include comments for the function precondition
(if any) and postcondition and comments that explain the purposes of all parameters and
local variables whose roles are not obvious.
2. Provide a function prototype near the top of your program for each function. Make sure
that the prototype and its corresponding function heading are an exact match (except for
the semicolon at the end of the prototype).
3. Be sure each function prototype ends in a semicolon and each function heading does not.
Because it’s common to copy and paste one for the other, it’s an easy mistake to get one
of them wrong.
4. Make sure the parameter list gives the data type of each parameter.
5. Use value parameters unless a result is returned through a parameter. Reference
parameters can change the contents of the caller’s argument; value parameters cannot.
However, file names must be reference parameters.
6. In a parameter list, make sure the data type of each reference parameter ends with an
ampersand (&). Without the ampersand, the parameter is a value parameter.
7. Make sure that the argument list of every function call matches the parameter list in
terms of number and order of items, and be very careful with their data types. The
compiler will catch mismatches in the number of arguments. If there is a mismatch in

data types, however, the compiler may not give an error message. With a pass by value
parameter, a type mismatch can lead to implicit type coercion rather than a compile-time
error.
8. Remember that an argument matching a reference parameter must be a variable,
whereas an argument for a value parameter can be any expression that supplies a value
of the same data type (except as noted in Hint 7).
9. Become familiar with all the tools available to you when you’re trying to locate the
sources of errors—the algorithm walk-through, hand tracing, the system’s debugger
program, the assert function, and debug output statements.

Summary
C++ allows us to write programs in modules expressed as functions. The structure of a
program, therefore, can parallel its functional decomposition even when the program is
complicated. To make your main function look exactly like Level 0 of your functional
decomposition, simply write each lower-level module as a function. The main function then
calls these other functions in the required sequence.
Functions communicate by means of two lists: the parameter list (which specifies the
data type of each identifier) in the function heading and the argument list in the calling code.
The items in these lists must agree in number and position, and they should agree in data
type.
Part of the functional decomposition process involves determining which data must be
received by a lower-level module and which information must be returned from it. The
names of these data items, together with the precondition and postcondition of a module,
define its interface. The names of the data items become the parameter list, and the
module name becomes the name of the function. With void functions, a call to the function
is accomplished by writing the function’s name as a statement, enclosing the appropriate
arguments in parentheses.
C++ supports two kinds of parameters: reference and value. Reference parameters
have data types ending in & in the parameter list, whereas value parameters do not.
Parameters that return values from a function must be reference parameters. All others
should be value parameters. This practice minimizes the risk of errors, because only a
copy of the value of an argument is passed to a value parameter, which protects the
argument from change.
In addition to the variables declared in its parameter list, a function may have local
variables declared within it. These variables are accessible only within the block in which
they are declared. Local variables must be initialized each time the function containing
them is called because their values are destroyed when the function returns.
You may call functions from more than one place in a program. The positional matching
mechanism allows the use of different variables as arguments to the same function.
Multiple calls to a function, from different places and with different arguments, can simplify
the coding of complex programs.

Quick Check Answers
8.1.1 Modules. 8.1.2 You code the module once, placing it, or its prototype, before any
reference to it in the rest of the program. You then call the module from each place in
the program that corresponds to its appearance in the functional decomposition. 8.1.3
Incoming values, outgoing values, and incoming/outgoing values. 8.1.4 Interface.
8.1.5 
Description
8.2.1 To the first statement in that function’s body, with its remaining statements
performed in execution order. 8.2.2 To the statement immediately following the
function call. 8.2.3 An argument is a variable or expression listed in a call to a function,
whereas a parameter is a variable declared in a function heading. 8.2.4 Arguments
and parameters are matched by their relative ordering in the two lists. 8.3.1 They
must be declared before they are used, so they appear before main. However, the
declaration may simply be a function prototype and the actual definition can then
appear anywhere. 8.3.2 Only the statements within the block, following the
declaration. 8.3.3 A function declaration without the body of the function. 8.3.4 They
allow you to declare a function before they are defined so that we can arrange function
definitions in any order. 8.3.5 void UpdateRace(int, float); 8.3.6 Local variable. 8.4.1
Because a function can assign a new value to the argument. 8.4.2 Because a function
could possibly have two or more parameters of the same data type. 8.4.3 The &
character appears at the end of the type name of the parameter. 8.4.4 Arguments
appear in function calls; parameters appear in function headings. 8.4.5 It should have
two parameters, one for each string. The full name parameter should be a value
parameter, and the first name parameter should be a reference parameter. 8.4.6
Incoming values use value parameters. Values that return to the argument (Out or
In/out) must be passed through reference parameters.

Exam Preparation Exercises
8.1 What three things distinguish a void function from main?
8.2 A function prototype must specify the name of a function and the name and type
of each of its parameters. True or false?
8.3 When and to where does control return from a void function?
8.4 Match the following terms with the definitions given below.
a. Argument
b. Parameter
c. Function call
d. Function prototype
e. Function definition
f. Local variable
g. Value parameter
h. Reference parameter
i. A function declaration without a body.
ii. A parameter that receives a copy of the argument’s value.
iii. A variable declared in a function heading.
iv. A function declaration with a body.
v. A variable or expression listed in a call to a function.
vi. A statement that transfers control to a function.
vii. A parameter that receives the location of the argument.
viii. A variable declared within a block.
8.5 In the following function heading, which parameters are value parameters and
which are reference parameters?
8.6 If a function has six parameters, how many arguments must appear in a call to the
function?
8.7 What happens if a function assigns a new value to a value parameter? What
happens if it assigns a new value to a reference parameter?
8. 8 What’s wrong with this function prototype?

8.9 Arguments can appear in any order as long as they have the correct types, and
C++ will figure out the correspondence. True or false?
8.10 Define encapsulation.
8.11 For which direction(s) of data flow do you use reference parameters?
8.12 What is wrong with the following function?
Description
8.13 What is wrong with the following function?
Description
8.14 What is wrong with the following function?

Description
8.15 What is wrong with the following function?
Description
8.16 A local variable can be referenced anywhere within the block in which it is
declared. True or false?
8.17 Functions can be called from other functions in addition to main. True or false?
8.18 What would be the precondition for a function that reads a file of integers and
returns their mean?

Programming Warm-Up Exercises
8.1 Write the heading for a void function called Max that has three int parameters:
num1, num2, and greatest. The first two parameters receive data from the caller, and
greatest returns a value. Document the data flow of the parameters with appropriate
comments.
8.2 Write the function prototype for the function in Exercise 8.1.
8.3 Write the function definition of the function in Exercise 8.1 so that it returns the
greatest of the two input parameters.
8.4 Write the heading for a void function called GetLeast that takes an ifstream
parameter called infile as an input parameter that is changed and that has an int
parameter called lowest that returns a value. Document the data flow of the
parameters with appropriate comments.
8.5 Write the function prototype for the function in Exercise 8.4.
8.6 Write the function definition for the function in Exercise 8.4 so that it reads all of
infile as a series of int values and returns the lowest integer input from infile.
8.7 Add comments to the function definition you wrote in Exercise 8.6 that state its
precondition and postcondition.
8.8 Write the heading for a function called Reverse that takes two string parameters. In
the second parameter, the function returns a string that is the character-by-character
reverse of the string in the first parameter. The parameters are called original and
lanigiro. Document the data flow of the parameters with appropriate comments.
8.9 Write the function prototype for the function in Exercise 8.8.
8.10 Write the function definition for the function in Exercise 8.8.
8.11 Add comments to the function definition you wrote in Exercise 8.10 that state its
precondition and postcondition.
8.12 Write a void function called LowerCount that reads a line from cin, and that returns
an int(count) containing the number of lowercase letters in the line. In Appendix C,
you will find the description of function islower, which returns true if its char
parameter is a lowercase character. Document the data flow of the parameters with
appropriate comments.
8.13 Add comments to the function definition you wrote in Exercise 8.12 that state its
precondition and postcondition.

8.14 Write a void function called GetNonemptyLine that takes an ifstream(infile) as an
In/ out parameter and that reads lines from the file until it finds a line that contains
characters. It should then return the line via a string parameter called line.
Document the data flow of the parameters with appropriate comments.
8.15 Write a void function called SkipToEmptyLine that takes an ifstream (infile) as
an In/out parameter and that reads lines from the file until it finds a line that contains
no characters. It should then return the number of lines skipped via an int parameter
called skipped. Document the data flow of the parameters with appropriate comments.
8.16 Write a void function called TimeAdd that takes parameters representing two times
in days, hours, and minutes, and then adds those parameters to get a new time. Each
part of the time is an int. Hours range from 0 to 23, and minutes range from 0 to 59.
There is no limit on the range of days. We assume that the time to be added is
positive. The values in the parameters representing the first time are replaced by the
result of adding the two times. Here is an example call in which 3 days, 17 hours, and
49 minutes is added to 12 days, 22 hours, and 14 minutes:
After the call, the values in the variables are as follows:
Description
8.17 Extend function TimeAdd in Exercise 8.16 to include seconds.
8.18 Write a void function called SeasonPrint that takes int parameters representing a
month and a day and that outputs to cout the name of the season. For the purposes of
this exercise, spring begins on March 21, summer begins June 21, fall begins
September 21, and winter begins December 21. Note that the year begins and ends
during winter. The function can assume that the values in the month and day
parameters have been validated before it is called.

Programming Problems
8.1 Write a C++ program that computes student grades for an assignment as a
percentage given each student’s score and the total points. The final score should be
rounded up to the nearest whole value using the ceil function in the <cmath> header
file. You should also display the floating point result up to five decimal places. You
should have a function to output the last name of the student and another function to
compute and output the percentage as well as “Excellent” if the grade is greater than
90, “Well Done” if the grade is greater than 80, “Good” if the grade is greater than 70,
“Need Improvement” if the grade is greater than or equal to 60, and “Fail” if the grade
is less than 60. The main function is responsible for reading the input file and passing
the appropriate arguments to your functions. Here is an example of what the input file
might look like:
Description
The output of your program should look like this:
Description
8.2 ROT13 (rotate by 13 places) is a simple letter substitution cipher that is an
instance of a Caesar cipher developed in ancient Rome and used by Julius Caesar in

his private correspondence. ROT13 replaces a letter with the letter 13 letters after it in
the alphabet. The following table demonstrates the translation in ROT13:
A
↔
N
B
↔
O
C
↔
P
D
↔
Q
E
↔
R
F
↔
S
G
↔
T
H
↔
U
I
↔
V
J
↔
W
K
↔
X
L
↔
Y
M
↔
Z
Thus, the translation of the word JULIUS using ROT13 would be WHYVHF. Write a C++
program that asks the user for the name of an input file and translates the contents of that
input file using ROT13. Your main function should be responsible for reading the input file
and coordinating calls to a function named Rot13 that will do the translation for each
character and WriteTranslatedChar that will write the translated character to a secondary
file. The Rot13 function should be defined with a reference parameter that will be the initial
character as input and the translated character as output. The second function named
WriteTranslatedChar will have two parameters, the translated character and a reference to
an ifstream data type for a secondary file named output.rot13, and write that translated
character to this file.
8.3 In mathematics, the Fibonacci numbers are the series of numbers that exhibit the
following pattern:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
In mathematical notation the sequence Fn of Fibonacci numbers is defined by the
following recurrence relation:
With the initial values of F0 = 0 and F1 = 1. Thus, the next number in the series is the sum
of the previous two numbers. Write a program that asks the user for a positive integer N
and generates the Nth Fibonacci number. Your main function should handle user input and

pass that data to a function called Fib that takes an integer value N as input and a
reference parameter that is assigned the Nth Fibonacci number.
8.4 Consider the following maze:
Description
The maze begins at S and ends at E. We represent the current position in the maze using
two integer variables named posX and posY. The starting location (S) is thus represented as
posX = 0 and posY = 0. Movement through the maze is defined by the following rules:
Description
Define functions for each of the above rules such that each function has an integer
reference parameter. Use these function declarations to write a C++ program that defines
posX and posY, initialized to 0, and the corresponding calls to your functions that will
correctly move your position in the maze from S to E ending at posX = 0, posY = 11.
Output the value of posX and posY after each function call.

8.5 Rewrite the program from Programming Problem 6.3 using functions. The
program is to output a bar chart of the hourly temperatures for one day, given the data
on a file. You should have a function to output the chart’s heading and another function
that outputs the bar of stars for a given temperature value. Note that the second
function does not output the value to the left of the bar graph. The main program
coordinates the process of inputting values and calling these functions as necessary.
Now that your programs are becoming more complex, it is even more important for
you to use proper indentation and style, meaningful identifiers, and appropriate
comments.
8.6 You’re working for a company that lays ceramic floor tile, and its employees need
a program that estimates the number of boxes of tile for a job. A job is estimated by
taking the dimensions of each room in feet and inches and converting these
dimensions into a multiple of the tile size (rounding up any partial multiple) before
multiplying to get the number of tiles for the room. A box contains 20 tiles, so the total
number needed should be divided by 20 and rounded up to get the number of boxes.
The tiles are assumed to be square.
The program should initially prompt the user for the size of the tile in inches and the
number of rooms to be covered with tile. It should then input the dimensions for each room
and output the number of tiles needed for that room. After data for the last room is input,
the program should output the total number of tiles needed, the number of boxes of tile
needed, and how many extra tiles will be left over.
Here is an example of how a run might appear:
Description
Use functional decomposition to solve this problem, and code the solution using functions
wherever it makes sense to do so. Your program should check for invalid data such as
nonpositive dimensions, number of rooms less than 1, number of inches greater than 11,
and so on. It should prompt the user for corrected input whenever it detects invalid input.

Now that your programs are becoming more complex, it is even more important for you to
use proper indentation and style, meaningful identifiers, and appropriate comments.
8.7 Programming Problem 5.8 asked you to write a program to compute the score for
one frame in a game of tenpin bowling. In this exercise, you will extend this algorithm
to compute the score for an entire game for one player. A game consists of 10
frames, but the tenth frame has some special cases that were not described in
Chapter 5.
A frame is played by first setting up the 10 pins. The player then rolls the ball to knock
them down. If all 10 are knocked down on the first throw, it is called a strike, and the frame
is over. If fewer than 10 are knocked down on the first throw, the number knocked down is
recorded, and the player gets a second throw. If the remaining pins are all knocked down
on the second throw, it is called a spare. The frame ends after the second throw, even if
there are pins left standing. If the second throw fails to knock all of the pins down, then the
number that it knocked down is recorded, and the score for the frame is just the number of
pins knocked down by the two throws. However, in the case of a strike or a spare, the
score for the frame depends on throws in the next frame and possibly the frame after that.
If the frame is a strike, then the score is equal to 10 points plus the number of pins
knocked down in the next two throws. Thus the maximum score for a frame is 30, which
occurs when the frame is a strike and the two following frames are also strikes. If the
frame is a spare, then the score is those 10 points plus the number of pins knocked down
on the next throw.
The last frame is played somewhat differently. If the player gets a strike, then they get
two more throws so that the score for the strike can be computed. Similarly, if it is a spare,
then one extra throw is given. If the first two throws fail to knock down all of the pins, then
the score for the last frame is just the number knocked down, and there is no extra throw.
Here is an example of how the I/O might appear for the start of a run:
Description

Description
Your program should take as input the number of pins knocked down by each throw, and
output the score for each frame as it is computed. The program must recognize when a
frame has ended (due to either a strike or a second throw). The program also should
check for erroneous input. For example, a throw may be in the range of 0 through 10 pins,
and the total of the two throws in any of the first nine frames must be less than or equal to
10.
Use functional decomposition to solve this problem and code the solution using
functions as appropriate. Be sure to use proper formatting and appropriate comments in
your code. The output should be labeled clearly and formatted neatly, and the error
messages should be informative.
8.8 Write a simple telephone directory program in C++ that looks up phone numbers
in a file containing a list of names and phone numbers. The user should be prompted
to enter a first and last name, and the program should then either output the
corresponding number or indicate that the name isn’t present in the directory. After
each lookup, the program should ask the user whether they want to look up another
number, and then either repeat the process or exit the program. The data on the file
should be organized so that each line contains a first name, a last name, and a phone
number, separated by blanks. You can return to the beginning of the file by closing it
and opening it again.
Use functional decomposition to solve this problem and code the solution using
functions as appropriate. Be sure to use proper formatting and appropriate comments in
your code. The output should be labeled clearly and formatted neatly, and the error
messages should be informative.
8.9 Extend the program in Problem 8.8 to look up addresses as well as phone
numbers. Change the file format so that the name and phone number appear on one
line, and the address appears on the following line for each entry. The program should
ask the user whether they want to look up a phone number, an address, or both, and
then perform the lookup and output the requested information. The program should
recognize an invalid request and prompt the user to enter the request again. As in
Problem 8.8, the program should allow the user to keep entering queries until the user
indicates that they are finished.
8.10 Programming Problem 5.3 asked you to write a program that inputs a letter and
outputs the corresponding word in the International Civil Aviation Organization (ICAO)
phonetic alphabet. This problem asks you to turn that program into a function and use
it to convert a string input by the user into the series of words that would be used to
spell it out phonetically. For example:

Description
For ease of reference, the ICAO alphabet is repeated here:
A
Alpha
B
Bravo
C
Charlie
D
Delta
E
Echo
F
Foxtrot
G
Golf
H
Hotel
I
India
J
Juliet
K
Kilo
L
Lima
M
Mike
N
November
O
Oscar
P
Papa
Q
Quebec
R
Romeo
S
Sierra
T
Tango
U
Uniform
V
Victor
W
Whiskey
X
X-ray
Y
Yankee
Z
Zulu
Be sure to use proper formatting and appropriate comments in your code. Provide
appropriate prompts to the user. The output should be labeled clearly and formatted neatly.
8.11 You’ve been asked to write a program to grade a multiple-choice exam. The
exam has 20 questions, each answered with a letter in the range of 'a' through 'f'.

The data are stored on a file (exams.dat) where the first line is the key, consisting of a
string of 20 characters. The remaining lines on the file are exam answers; each
consists of a student ID number, a space, and a string of 20 characters. The program
should read the key, read each exam, and output the ID number and score to file
scores.dat. Erroneous input should result in an error message. For example, given
the data
Description
the program would output the following data on scores.dat:
Use functional decomposition to solve the problem and code the solution using functions
as appropriate. Be sure to use proper formatting and appropriate comments in your code.
The output should be formatted neatly, and the error messages should be informative.

Case Study Follow-Up
1. Test the LawnCare application using a file with no data. What happens? If this input
causes an error, rewrite the program to handle this situation.
2. Test the LawnCare application using a file with only one customer. What happens? If
this input causes an error, rewrite the program to handle this situation.
3. The current version of LawnCare writes a bill with a zero amount due if there are no
jobs. Rewrite the application so that no bill is written if there are no jobs.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  9
Scope, Lifetime, and
More on Functions
KNOWLEDGE GOALS
To know what a global reference is.
To understand and be able to avoid unwanted side effects.
To know when to use a value-returning function.
SKILL GOALS
To be able to:
Determine which variables in a program are local.
Determine which variables are accessible in a given block.
Determine the lifetime of each variable in a program.
Design and code a value-returning function for a specified task.
Invoke a value-returning function properly.

As programs get larger, the number of identifiers in them increases. We use more function,
variable, and constant identifiers. Some identifiers are declared inside blocks; others—
function names, for example—are declared outside of any block. This chapter examines the
C++ rules by which a function may access identifiers that are declared outside its own block.
Using these rules, we return to the discussion of interface design that we began in Chapter 8.
Next, we look at the value-returning function. Unlike void functions, which return results (if
any) through the parameter list, a value-returning function returns a single result—the function
value—to the expression from which it was called. In this chapter, we see how to write such
functions.

9.1 Scope of Identifiers
Recall that local identifiers are those declared inside a block, such as the body of a function,
and that they cannot be accessed outside the block that contains them.
Any block—not just a function body—can contain identifier declarations. For example, this If
statement contains a block that declares a local variable number:
Description
Like any other local identifier, number cannot be accessed by any statement outside the block
containing its declaration. It is defined for all statements that follow it within its block, and it is
undefined outside of the block.
If we listed all the places from which an identifier could be accessed legally, we would
describe that identifier’s scope of visibility or scope of access, often just called its scope.
C++ defines several categories of scope for any identifier. We begin by describing three of
these categories.
Scope The region of program code where it is legal to reference (use) an identifier.
1. Class scope: This term refers to the data type called a class, which we mentioned briefly
in Chapter 4. We will postpone our detailed discussion of class scope until Chapter 12.
2. Local scope: The scope of an identifier declared inside a block extends from the point of
declaration to the end of that block. Also, the scope of a function parameter extends from
the heading to the end of the function body. You can think of a parameter’s scope as being
the same as if it was a local variable declared before anything else in the function body.
3. Global scope: The scope of an identifier declared outside all functions and classes
extends from the point of declaration to the end of the entire file containing it.
C++ function names have global scope. (We discuss an exception to this rule in Chapter
12.) Once a function name is declared, it can be invoked by any other function in the rest of
the program. In C++, there is no such thing as a local function—that is, you cannot nest a
function definition inside another function definition.
Global variables and constants are those declared outside all functions. In the following
code fragment, gamma is a global variable and can be accessed directly by statements in main

and SomeFunc:
Description
When a function declares a local identifier with the same name as a global identifier, the
local identifier takes precedence within the function. This principle is called name precedence
or name hiding.
Here’s an example that uses both local and global declarations:
Name precedence The precedence that a local identifier in a function has over a global
identifier with the same name in any references that the function makes to that identifier;
also called name hiding.
Description

Description
In this example, function SomeFunc accesses global constant A but declares its own local
variable b and parameter c. Thus the output is
Local variable b takes precedence over global variable b, effectively hiding global b from the
statements in function SomeFunc. Parameter c also blocks access to global variable c from
within the function. Function parameters act just like local variables in this respect; that is,
parameters have local scope.
Scope Rules
C++ programmers rarely declare global variables. There are negative aspects to using them,
which we discuss later. But when you have a compelling need for global variables, it pays to
know how C++ handles them. The rules for where an identifier is accessible are called scope
rules.
In addition to local and global access, the C++ scope rules define what happens when
blocks are nested within other blocks. When a block contains a nested block, anything
declared in the outer block is nonlocal to the inner block. (Global identifiers are nonlocal to all
blocks.) If a block accesses an identifier declared outside its own block, it is termed a
nonlocal access.
Here are the detailed scope rules, excluding class scope and certain language features we
have not yet discussed:
Scope rules The rules that determine where in the program an identifier may be
accessed, given the point where that identifier is declared.

Nonlocal identifier With respect to a given block, any identifier declared outside that
block.
1. A function name has global scope. Function definitions cannot be nested within function
definitions.
2. The scope of a function parameter is identical to the scope of a local variable declared in
the outermost block of the function body.
3. The scope of a global variable or constant extends from its declaration to the end of the
file, except as noted in Rule 5.
4. The scope of a local variable or constant extends from its declaration to the end of the
block in which it is declared. This scope includes any nested blocks, except as noted in
Rule 5.
5. The scope of an identifier does not include any nested block that contains a locally
declared identifier with the same name. (Local identifiers have name precedence.)
Here is a sample program that demonstrates C++ scope rules. To simplify the example,
only the declarations and headings are spelled out. Note how the While loop body labeled
Block3, located within function Block2, contains its own local variable declarations.

Description
Let’s look at the ScopeRules program in terms of the blocks it defines and see just what
these rules mean. FIGURE 9.1 shows the headings and declarations in the ScopeRules
program, with the scopes of visibility being indicated by boxes.
Anything inside a box can refer to anything in a surrounding box. Outside-in references
aren’t allowed. Thus a statement in Block3 could access any identifier declared in Block2 or
any global variable. A statement in Block3 could not access identifiers declared in Block1
because it would have to enter the Block1 box from outside.

Notice that the parameters for a function are inside the function’s box, but the function name
itself is outside the box. If the name of the function were inside the box, no function could call
another function. This point demonstrates merely that function names have global scope.
Imagine the boxes in Figure 9.1 as rooms with walls made of two-way mirrors, with the
reflective side facing out and the see-through side facing in. If you stood in the room for
Block3, you would be able to see out through all the surrounding rooms to the declarations of
the global variables (and anything between). You would not be able to see into any other
rooms (such as Block1), however, because their mirrored outer surfaces would block your
view. Because of this analogy, the term visible is often used in describing a scope of access;
for example, variable a2 is visible throughout the program, meaning that it can be accessed
from anywhere.
FIGURE 9.1 Scope Diagram for Scope rules program
Description

Figure 9.1 does not tell the whole story, however; it represents only scope Rules 1 through
4, but not Rule 5. Variable a1 is declared in three different places. Because of the name
precedence rules, Block2 and Block3 access the a1 declared in Block2 rather than the global
a1. Similarly, the scope of the variable b2 declared in Block2 does not include the “hole” created
by the declaration of variable b2 in Block3.
Name precedence rules are implemented by the compiler as follows: When an expression
refers to an identifier, the compiler first checks the local declarations. If the identifier isn’t local,
the compiler works its way outward through each level of nesting until it finds an identifier with
the same name. There it stops. If there is an identifier with the same name declared at a level
even farther out, it is never reached.
If the compiler reaches the global declarations (including identifiers inserted by #include
directives) and still can’t find the identifier, an error message such as UNDECLARED IDENTIFIER
is issued. Such a message most likely indicates a misspelling or an incorrect capitalization, or
it could mean that the identifier was not declared before the reference to it or was not declared
at all. It may also indicate that the blocks are nested so that the identifier’s scope doesn’t
include the reference.1
Variable Declarations and Definitions
In Chapter 8, you learned that C++ distinguishes between function declarations and
definitions. Definitions cause memory space to be reserved, whereas declarations do not.
C++ applies the same terminology to variable declarations. A variable declaration becomes
a variable definition if it also reserves memory for the variable. All of the variable declarations
we have seen so far have been variable definitions. What would a variable declaration look
like if it was not also a definition?
In Chapter 8, we talked about multifile programs. C++ has a reserved word, extern, that lets
you reference a global variable located in another file. A definition such as
causes the compiler to reserve a memory location for someInt. By contrast, the statement
is known as an external declaration. It states that someInt is a global variable located in
another file and that no storage should be reserved for it here. In C++ terminology, the
preceding statement is a declaration but not a definition of someInt. It associates a variable
name with a data type so that the compiler can perform type checking. In C++, you can
declare a variable or a function many times, but there can be only one definition.
Except where it’s important to distinguish between declarations and definitions of variables,
we’ll continue to use the more general phrase variable declaration instead of the more specific
variable definition.
Namespaces
For some time, we have been including the following using directive in our programs:

In Chapter 2, we noted that without this directive, we would have to refer to cout using the
qualified name
Now that we have explored the concept of scope, we can answer the question: What is a
namespace? It is a mechanism by which the programmer can create a named scope.2 For
example, the standard header file cstdlib contains function prototypes for several library
functions, one of which is the absolute value function, abs. The declarations are contained
within a namespace definition as follows:
Description
A namespace definition consists of the word namespace, then an identifier of the
programmer’s choice, and then the namespace body between braces. Identifiers declared
within the namespace body are said to have namespace scope. Such identifiers cannot be
accessed outside the body except by using one of three methods.
The first method is to use a qualified name: the name of the namespace, followed by the
scope resolution operator (::), followed by the desired identifier. Here is an example:
Description
We inform the compiler that we are referring to the abs declared in the std namespace, and
not to some other abs (such as a function named abs that we might have written ourselves).
The second method is to use a statement called a using declaration as follows:

Description
These using declarations allow the identifiers abs and cout to be used throughout the body of
main as synonyms for the longer std::abs and std::cout, respectively.
The third method—the one we’re familiar with—is the using directive (which is different from
a using declaration):
Description
With a using directive, all identifiers from the specified namespace are accessible, but only in
the scope in which the directive appears. In the preceding fragment, the using directive is in
local scope (within a block), so identifiers from the std namespace are accessible only within
main. If we put the using directive outside all functions (as we have been doing), like this:

Description
Then the using directive is in global scope; making identifiers from the std namespace
accessible globally.
Placing a using directive in global scope is a convenience. For example, all of the functions
we write can refer to identifiers such as abs, cin, and cout without our having to insert a using
directive in each function.
Creating global using directives is considered a bad idea when we are creating large,
multifile programs, where programmers often use multiple libraries. Two or more libraries
may, just by coincidence, use the same identifier for different purposes. Global using
directives then lead to name clashes (multiple definitions of the same identifier), because all
the library identifiers are in the same global scope. (C++ programmers refer to this problem as
“polluting the global namespace.”)
We continue to use global using directives for the std namespace because our programs
are relatively small and, therefore, name clashes aren’t likely. Also, the identifiers in the std
namespace are so commonly used that most C++ programmers avoid duplicating them.
Given the concept of namespace scope, we refine our description of C++ scope categories
as follows:
1. Class scope: This term refers to the class data type, which we discuss in Chapter 12.
2. Local scope: The scope of an identifier declared inside a block extends from the point of
declaration to the end of that block. Also, the scope of a function parameter (formal
parameter) extends from the point of declaration to the end of the block that is the body of
the function.
3. Namespace scope: The scope of an identifier declared in a namespace definition extends
from the point of declaration to the end of the namespace body, and its scope includes the
scope of any using directive specifying that namespace.
4. Global (or global namespace) scope: The scope of an identifier declared outside all
namespaces, functions, and classes extends from the point of declaration to the end of
the entire file containing the program code.
Note that these are general descriptions of scope categories and not scope rules. The
descriptions do not account for name hiding.
QUICK CHECK

9.1.1 If a function references a variable that is not declared in its block or its
parameter list, is the reference global or local?
9.1.2 What is the exception to the scope rule that dictates that a local variable or
constant extends from its declaration to the end of the block in which it is declared?
9.1.3 What are the four scope categories mentioned in this section?
1 C++ provides syntax to work around name precedence and access a global identifier even
when an identifier with the same name is declared locally. We can use the :: operator without
specifying a namespace. For example, if we have declared a local constant called A1, we can
write ::A1 to refer to a global constant called A1.
2 As a general concept, namespace is another word for scope. Here we consider it as a
specific C++ language feature.

9.2 Lifetime of a Variable
Scope rules determine where an identifier is accessible, but each identifier also has a property
called its lifetime—the period when it actually has memory allocated to it during program
execution. Storage for local variables is created (allocated) at the moment a function is called.
The variables remain “live” while the function executes, and the storage is recycled
(deallocated) when the function exits. In contrast, a global variable’s lifetime is the execution of
the entire program. Its memory is allocated when the program begins executing and is
deallocated when the program terminates. Observe that scope is a compile-time property,
whereas lifetime is a run-time property.
Lifetime The period of time during program execution when an identifier has memory
allocated to it.
In C++, an automatic variable has its storage allocated at block entry and deallocated at
block exit. A static variable has its storage allocated for the duration of the entire program. All
global variables are static. By default, variables declared within a block are automatic.
However, you can use the reserved word static when you declare a local variable, and then
its value persists from function call to function call.
The next program contains a function that keeps track of the number of times it is called.
The output is shown following the program.
Automatic variable A variable for which memory is allocated and deallocated when
control enters and exits the block in which it is declared.
Static variable A variable for which memory remains allocated throughout the execution
of the entire program.

Description
Here is the program’s output:
Description
It is generally better practice to declare a static local variable than to use a global variable.
Just like a global variable, the memory for a static variable remains allocated throughout
execution of the program; however, its local scope prevents other functions from accessing it.

Initializations in Declarations
One of the most common things we do in programs is first declare a variable and then, in a
separate statement, assign an initial value to the variable. Here’s a typical example:
As we saw in Chapter 8, C++ allows you to combine these two statements. The result is
known as an initialization in a declaration. Here we initialize sum as part of its declaration:
In a declaration, the expression that specifies the initial value is called an initializer. In the
preceding statement, the initializer is 0. Implicit type coercion takes place if the data types of
the initializer and the variable don’t match.
An automatic variable is initialized to the specified value each time control enters the block:
Description
In contrast, initialization of a static variable (a global variable or a local variable declared
static) occurs once—the first time control reaches its declaration. Here’s an example in which
two local static variables are initialized the first time the function is called:
Description
An initialization just gives a variable an initial value; we can reassign it another value during
program execution.
SOFTWARE MAINTENANCE CASE STUDY Debug a Simple
Program

MAINTENANCE TASK: Most of our maintenance problems have involved enhancing a
program and then testing the changes. This time a friend came to you with a short
program that just reads a file and for each line in the file outputs a line number and the
number of characters on the line—or at least that is what it is supposed to do. How can
such a simple program not work? You agree to look at it.
The first step is to look at the input and the results, which your friend supplies. She has
counted the number of characters on each line of test data: 61, 62, 60, 61, 59, 63, 54, 62,
29.
Description
The next step is to determine what is correct and what is not. The first line number is
correct, and the number of characters on each line seems okay. The rest of the line
numbers are way off, and the number of lines at the bottom is off. But you notice a pattern:
Each incorrect line number is one more than the number of characters on the previous
line, except for the last line, which is the same as the number of characters on the
previous line. The line counter and the letter counter are getting confused. Now we know
where to begin debugging. Let’s examine the code line by line and isolate the interaction
between the two counters.

Description
Description
First of all, there is no documenting header for the program. You make a note to remind
your friend to add this information. Continuing, you see that the first few lines access the
necessary files and determine the namespace. The next two statements are prototypes of
the functions used: LetterCount and LineCount. The documentation states that LineCount
returns the number of lines, and LetterCount returns the number of characters. Does each
function do what it is supposed to do? LineCount inputs a line, increments and outputs the
line counter, and invokes LetterCount. The documentation may not be complete, but the

function is not incorrect. LetterCount takes a line and outputs the number of characters in
the line. But it also returns a value: The reference parameter count is used like a local
variable to store a value. However, this value is sent back to the calling program,
corrupting the line count.
Both functions have count as a reference parameter; thus, they are both accessing the
same place in memory. The same parameter is being used for two purposes: counting the
lines and counting the characters. LetterCount doesn’t need a counter as a parameter; the
count in this function should be a local variable. Let’s make that correction and rerun the
program. Be careful: Changing a parameter means changing the code in three places: the
prototype, the function heading, and the invoking statement.
Description
Description
Well, that’s progress. But now the program says there are 10 lines when there are only
9. Also, note that line 10 has the same number of characters as line 9. It looks like the last
line is being read twice. Let’s examine the code that does the reading:
Description
Of course! Because the loop is an EOF loop, we need a priming read. When the last read
causes the file to go into the fail state but the loop continues, the variable line is
unchanged, so the last line is processed twice. Once this change is made, the results are
correct.

Here is the corrected program. Note that documentation has been added and updated.
Description

QUICK CHECK
9.2.1 A program has two functions, Quick1 and Quick2. The program itself declares
variables check and qc. Function Quick1 declares variables called quest and qc.
Function Quick2 declares one variable called quest and a static variable called
forever. Which of these variables are local?
9.2.2 In Question 9.2.1, which variables are accessible within function Quick1?
9.2.3 In Question 9.2.1, what is the lifetime of each of the six variables?
9.2.4 At what point in time is the concept of a variable’s lifetime considered?
9.2.5 How is a variable’s lifetime related to memory?
9.2.6 What is an automatic variable?
9.2.7 What is the lifetime of a static variable?
9.2.8 In a declaration, what do we call the expression that specifies the initial value?
9.2.9 How many times is a static variable initialized?
9.2.10 How many times is an automatic variable initialized?

9.3 Interface Design
We return now to the issue of interface design, which we began in Chapter 8. Recall that the
data flow through a module interface can take three forms: incoming (In), outgoing (Out), and
incoming/ outgoing (In/out). Any item that is purely In should be a value parameter. Items in
the remaining two categories (Out and In/out) must be reference parameters; the only way the
function can send results to the caller’s arguments is to use their addresses.
Sometimes it is tempting to skip the interface design step and let a module communicate
with other modules via global variables. Don’t! Without a conscious interface design, you
would actually be creating a poorly structured and undocumented interface. Except in well-
justified circumstances, the use of global variables is a poor programming practice that can
lead to program errors. These errors are extremely hard to locate and usually take the form of
unwanted side effects.
Side Effects
Suppose you made a call to the sqrt library function in your program:
Description
You expect the call to sqrt to do one thing only: compute the square root of the variable x. You
would be surprised if sqrt also changed the value of your variable x because sqrt, by
definition, does not make such changes. This outcome would be an example of an
unexpected and unwanted side effect.
Side effect Any effect of one function on another function that is not a part of the explicitly
defined interface between them.
Side effects can be caused by a combination of reference parameters and careless coding
in a function. If the function code tries to use a reference parameter as a normal variable, it
can inadvertently change the value of an argument in the calling code. As we have said, value
parameters avoid this type of side effect by preventing the change from reaching the
argument. We saw an example of this in the last Software Maintenance Case Study.
Side effects also can occur when a function accesses a global variable. For example, if you
forget to declare a local variable, and there happens to be a global variable with the same
name, the compiler won’t report an error. But you will encounter a side effect when the
function unintentionally changes the global variable. The error doesn’t appear until after the
function returns and the caller accesses the global variable. Because of how nonlocal scope
works in C++, every function has the potential to produce this kind of side effect.
Side-effect errors are especially hard to find because the trouble shows up in one part of the
program when its cause is in another part that may be completely unrelated. Every
programmer has had the experience of attempting to isolate a bug that makes no sense and

even seems to violate the rules of the programming language. When you begin to think that an
error is a bug in the compiler, you’re probably dealing with a side-effect bug!
Given their challenging nature, avoiding such errors is the best strategy. The only external
effect that a module should have is to transfer information through the well-structured interface
of the parameter list (see FIGURE 9.2). To be more explicit: The only variables used in a
module should be either parameters or local. In addition, In parameters should be value
parameters. This approach isolates each module from other parts of the program so side
effects cannot occur. When a module is free of side effects, we can treat it as independent
code and reuse it in other programs. Modules with side effects are almost never reusable.
FIGURE 9.2 Side Effects
Description
Program Trouble, below, runs but produces incorrect results because of global variables
and side effects:

Description
Description
Program Trouble is supposed to output the number of integers on each line of input. As a
final output, it should display the number of lines. But each time the program is run, it reports

that the number of lines is the same as the number of integers in the last line. Your first
thought would be to look closely at main for a logic error in counting the number of lines. But
the algorithm in main is fine. Where could the bug be? The problem is that the CountInts
function uses the global variable count to store the number of integers. The programmer
probably intended to declare a local variable called count and forgot.
Furthermore, there is no reason for count to be a global variable. If a local variable count had
been declared in main, then the compiler would have reported that CountInts was using an
undeclared identifier. With local variables called count declared in both main and CountInts, the
program works correctly. There is no conflict between the two variables, because each is
visible only within its own block.
This side-effect error was easy to locate because we had just one other function to
examine. In a program with hundreds of functions, it would be much harder to determine
which one was causing main to behave strangely.
The Trouble program also demonstrates one common exception to the rule of not
accessing global variables. Technically, cin and cout are global objects declared in the header
file iostream. The CountInts function accesses them directly. To fully isolate CountInts, cin and
cout should be passed as arguments. However, cin and cout are fundamental I/O facilities in
C++, so by convention, functions often access them directly.
Global Constants
Contrary to what you might think, it is acceptable to reference named constants globally.
Because the values of constants cannot change, no side effects can occur.
There are two advantages to referencing constants globally: ease of change and
consistency. It’s easier to change one global declaration of a constant than to change a local
declaration in every function. By declaring a constant in only one place, we also ensure that all
parts of the program use exactly the same value.
This is not to say that you should declare all constants globally. If a constant is used in only
one function, then declare it locally.
At this point, you may want to turn to the Problem-Solving Case Study at the end of this
chapter, which further illustrates interface design and the use of value and reference
parameters.
QUICK CHECK
9.3.1 How do references to global variables contribute to the potential for unwanted
side effects?
9.3.2 What is a side effect?
9.3.3 What important property of interface design is maintained if a module is free of
side effects?
9.3.4 Which global variables used by convention are exceptions to the rule of not
using global variables?
9.3.5 What type of variable is acceptable to use globally?

MAY WE INTRODUCE Katherine G. Johnson
© Sean Smith/NASA.
Value-returning functions, as we see in the next section, were developed to mimic
mathematical functions, for use in programming complex calculations. Early computers
were often employed for solving mathematically complex problems, such as the ballistics
trajectories computed by the ENIAC or orbital paths of satellites and spacecraft. One of
the pioneers in the latter of those applications was Katherine G. Johnson, who worked for
NASA and its predecessor, NACA (National Advisory Committee for Aeronautics).
Johnson graduated summa cum laude from West Virginia State in 1937, at the age of
18, with degrees in mathematics and French. She had taken every math class offered at
the college, and one of her professors added new courses just for her. In 1953, she went
to work as a computer (a person doing calculations on a mechanical calculator) at NACA.
Her mathematical abilities were so impressive that when she was temporarily loaned from
the Guidance and Navigation department to the Flight Research team, they decided to
have her join them. Johnson was Black, however, and so her work at NACA was
hampered by state and federal racial segregation laws and policies, which required her to
use separate spaces for working and eating and separate restrooms, sometimes at
significant distances from her White colleagues.
After NACA became NASA in 1958, the facility was desegregated, but there was still
both racial and gender discrimination that required extra effort to overcome. For example,
there was a policy that women could not be named as authors of reports. At one point, she
was writing a report with a male colleague, and their supervisor was insisting that the man
be listed as the author. But then the man left for another NASA facility before the report
was done, telling the supervisor to put Johnson’s name on it, because she had done most
of the work. Thus, she became the first woman in her NASA division to officially author a
report.

Johnson then moved to the Spacecraft Controls branch, where the focus was on
research. There, she was responsible for calculating the trajectories of the first suborbital
Mercury spaceflights. NASA switched to using electronic computers for calculating the
path of the first orbital flight, to be piloted by John Glenn; however, Glenn had gained such
deep confidence in Johnson that he insisted upon having her verify the results from the
computers, and refused to fly until she had done so.
Johnson then took up programming the computers and was able to establish that they
could be made to produce results as accurate as the human computers, overcoming that
early skepticism. She subsequently helped with calculating the path for Apollo 11, the first
moon landing mission. Her calculations for backup plans, and for a navigation system
based on a single reference star, helped to save the Apollo 13 mission after an explosion
in its service module crippled the main spacecraft. Later, she worked with the Space
Shuttle program and on plans for a Mars mission.
After 28 years at NASA, Johnson retired in 1986, having authored or co-authored 26
scientific papers. She received the Presidential Medal of Freedom in 2015. In 2016, the
nonfiction book Hidden Figures, by Margot Lee Shetterly, was published, detailing the story
of Johnson and two other Black women, Mary Jackson and Dorothy Vaughn, who had
worked with her as computers in the early days of NACA and NASA. In 2017, a movie
version of the book appeared, under the same title, receiving critical acclaim and wide
success at the box office.
Also in 2017, NASA opened the new Katherine G. Johnson Computational Research
Facility in Hampton, Virginia, and in 2019, it renamed a facility in Fairmont, West Virginia,
the Katherine Johnson Independent Verification and Validation Facility. In 2018, Johnson
was given an honorary doctorate by the College of William and Mary, and West Virginia
State established a scholarship in her name, unveiling a life-size statue of her on the
campus. Katherine Johnson lived to the age of 101, passing away in February 2020. As a
highly regarded, pioneering computational scientist with a rich and inspiring career and
biography, she spent many of her postretirement years on efforts to encourage students to
enter science, technology, engineering, and mathematics careers.

9.4 Value-Returning Functions
Up to now we have concentrated on writing void functions. We now turn to value-returning
functions. You are already familiar with such functions from the C++ standard library: sqrt,
abs, fabs, and others. From the caller’s perspective, the main difference between void and
value-returning functions is how they are called. A call to a void function is a complete
statement; a value-returning function is called within an expression.
From a design perspective, value-returning functions are used when a module has exactly
one result, and it is to be used directly in an expression. Let’s look at an example. The C++
standard library doesn’t supply a power function for int values, so let’s build one. The function
receives two integers, number and n (where n is greater than or equal to 0), and computes
numbern. A simple solution is multiplying repeatedly by number. Because the number of
iterations is known, a count-controlled loop is appropriate. The loop counts down to 0 from the
initial value of n. For each iteration, the previous product is multiplied by number.
Description
The first thing to note is that the heading begins with the data type int instead of the word
void. The second thing to observe is the Return statement at the end, which includes an
integer expression.
A value-returning function returns one value—not through a parameter, but via a Return
statement. The data type at the beginning of the heading declares the type of value the
function returns. This type is called the function type, although a more precise term is
function value type (or function return type or function result type).
Function value type The data type of the result value returned by a function.

The program shown in FIGURE 9.3 invokes function Power. The last statement in the Power
function returns the result as the function value.
You now have seen two forms of the Return statement. The form
is valid only in void functions. It causes control to immediately return to the caller. In contrast,
the form
FIGURE 9.3 Returning a Function Value to the Expression That Called the Function
Description
is valid only in value-returning functions. It returns control to the caller, sending back the value
of Expression as the function value. (If the data type of Expression differs from the function
type, its value is coerced to the function type.)
In Chapter 8, we presented a syntax template for the function definition of a void function.
We now update the syntax template to cover both void functions and value-returning
functions:
Description
If DataType is the word void, the function is a void function; otherwise, it is a value-returning
function. Notice from the shading in the syntax template that DataType is optional. If you omit
the data type of a function, a data type of int is assumed. We mention this only because you
sometimes encounter programs where the DataType is missing. Many programmers
consider this to be poor programming style.

The parameter list for a value-returning function has the same form as for a void function: a
list of parameter declarations separated by commas. Also, a function prototype for a value-
returning function looks just like the prototype for a void function except it begins with a data
type instead of void.
Remember your friend’s program that was so buggy? The function LineCount used a
reference parameter to return the number of lines in the file. It should be a value-returning
function, where the return value is the number of lines. The change requires the following
steps:
1. Replace the word void with the word int in the prototype for function LineCount.
2. Remove count from the parameter list.
3. Make the same changes in the function definition.
4. Declare a local variable to count the number of lines.
5. Return the value of the line count variable.
6. Remove the declaration of count from the main program.
7. Insert the call to LineCount into the output statement.
8. Correct the documentation.
Here is this program with LineCount rewritten. The changed lines are shaded.

Description

Complete Example
Let’s look at another problem. Suppose we are writing a program that calculates a prorated
tuition refund for students who withdraw in the middle of a semester. The amount to be
refunded is the total tuition times the remaining fraction of the semester (the number of days
remaining divided by the days in the semester). The users want to enter the dates on which
the semester begins and ends and the date of withdrawal.
Because each semester at this school begins and ends in the same calendar year, we can
calculate the number of days in a period by determining the day number of each date and
subtracting the starting day number from the ending day number. The day number is the
number of days since the beginning of the year, starting with day 1 on January 1. December
31 is day 365, except in leap years, when it is 366. For example, if a semester begins on
1/3/23 and ends on 5/17/23, the calculation is as follows:
The day number of 1/3/23 is 3.
The day number of 5/17/23 is 137.
The length of the semester is 137 - 3 + 1 = 135.
We add 1 to the difference because we count the first day as part of the period.
The algorithm for calculating the day number for a date is complicated by leap years and by
months of different lengths. Let’s look at how the calling code would appear, assuming we
have a value-returning function named Day that returns the day number for a date:
Description
Because Day is a value-returning function, this code segment is intuitive and readable.
Let’s look at the function definition for Day. Don’t worry about how Day works; for now, you
should concentrate on its syntax and structure.
Description

Description
See how useful it is to have a collection of functions we can use later? We created the
IsLeap-Year function in Chapter 1, and we can now just use it here. We can embed function
Day in a driver (test) program that gets three dates and displays the tuition refund. For testing,
the tuition is a constant. In the real program, it would be input.

Description

Description

Description
Here is the output:
Description
Boolean Functions
As we just saw, value-returning functions are not restricted to returning numerical results.
Boolean functions can be useful when a branch or loop depends on some complex condition.
Rather than code the condition directly into the If or While statement, we can call a Boolean
function as the controlling expression.
Suppose we are writing a program that works with triangles and it reads three angles as
floating-point numbers. Before using those angles, however, we must check that they form a
triangle by confirming that their sum equals 180 degrees. We can write a Boolean function that

takes the three angles as parameters. Such a function would look like this (recall from
Chapter 5 that you should test floating-point numbers only for near equality):
Description
The following program shows how IsTriangle is called. (We omit the documentation to save
space.)

Description
Here is the output:

Description
In the main function of the Triangle program, the If statement is much easier to understand
with the function call than with the condition coded directly. When a conditional test is
complicated, a Boolean function is in order.
MATTERS OF STYLE Naming Value-Returning Functions
In Chapter 8, we said that it’s good style to use imperative verbs when naming void
functions:
Description
This naming scheme, however, doesn’t work well with value-returning functions. A
statement such as
sounds awkward when you read it aloud: “Set z equal to 6.7 times the compute maximum
of d, e, and f.”
With a value-returning function, the call represents a value within an expression. Things
that represent values, such as variables and value-returning functions, are best given
names that are nouns or, occasionally, adjectives. For example:
You would read this as “Set z equal to 6.7 times the maximum of d, e, and f.” Other names
that suggest values rather than actions include SquareRoot, Factorial, StudentCount, and
SocialSecurityNum. As you see, they are all nouns or noun phrases.

Boolean value-returning functions are often named using adjectives or phrases
beginning with Is. Here are a few examples:
Description
Interface Design and Side Effects
The interface to a value-returning module is straightforward. We simply write down a list of
what the module needs and what it must return. Because value-returning modules return only
one value, there is only one item labeled “Out”: the return value. Everything else in the list is
labeled “In,” and there aren’t any items labeled “In/out.”
Returning more than one value from a value-returning module (by modifying the caller’s
arguments) is a side effect and, as such, should be avoided. If your interface design calls for
multiple values to be returned, then you should use a void function instead of a value-returning
function.
A rule of thumb is to avoid reference parameters in the parameter list of a value-returning
module and to use value parameters exclusively. Let’s look at a function that demonstrates
the importance of this rule. Suppose we define the following function:
Description
This function returns the square of its incoming value, but it also increments the caller’s
argument before returning. Now suppose we call this function with the following statement:
If x is originally 2, what value is stored into y? The answer depends on the order in which your
compiler generates code to evaluate the expression. If the compiled code calls the function
first, then the answer is 7. If it accesses x first in preparation for adding it to the function result,
then the answer is 6. This uncertainty is precisely why you should not use reference
parameters with value-returning functions. A function that causes an unpredictable result has
no place in a well-written program.
An exception to this rule is when a module uses an I/O stream object as a parameter.
Recall that C++ requires stream objects to be passed as reference parameters. Keep in mind

that reading from or writing to a file within a function is really a side effect and should be clearly
documented in the postcondition.
There is another advantage to using only value parameters in a value-returning function
definition: You can use constants and expressions as arguments. For example, we can call
the IsTriangle function using literals and other expressions:
Description
When to Use Value-Returning Functions
There aren’t any formal rules that specify when to use void versus value-returning functions,
but here are some guidelines:
1. If the module must return more than one value or modify any of the caller’s arguments,
do not use a value-returning function.
2. Avoid using value-returning functions to perform I/O. If you must, clearly document the
side effect in the postcondition.
3. If only one value is returned from the module and it is a Boolean value, a value-returning
function is appropriate.
4. If only one value is returned and it is to be used immediately in an expression, a value-
returning function is appropriate.
5. When in doubt, use a void function. You can recode any value-returning function as a void
function by adding an extra outgoing parameter to carry back the computed result.
6. If both a void function and a value-returning function are acceptable, use the form you feel
more comfortable implementing.
Value-returning functions were included in C++ to provide a way of simulating the
mathematical concept of a function. The C++ standard library supplies a set of commonly
used mathematical functions through the header file cmath. A list of these appears in Appendix
C.
QUICK CHECK
9.4.1 If a module has three In parameters and one Out parameter, should it be
implemented as a void function or a value-returning function?
9.4.2 What distinguishes a value-returning function from a void function?

9.4.3 Given the following function heading, how would you write a call to it that will
pass it the value 98.6 and assign the result to the variable fever?
9.4.4 How many values are returned from a value-returning function?
9.4.5 What is a function value type?
9.4.6 What are the two forms of the Return statement?

9.5 Type Coercion in Assignments, Argument Passing,
and Return of a Function Value
In general, promotion of a value from one type to another does not cause loss of information.
Think of promotion like moving to a bigger house. All your furniture fits with room to spare. By
comparison, demotion (or narrowing) of values can lose information. Demotion is like
moving into a smaller house—something has to be thrown out.
Demotion (narrowing) The conversion of a value from a “higher” type to a “lower” type
according to a programming language’s precedence of data types. Demotion may cause
loss of information.
Consider the assignment operation
where v is a variable and e is an expression. Regarding the data types of v and e, there are
three possibilities:
If the types of v and e are the same, no type coercion is necessary.
If the type of v is “higher” than that of e, then the value of e is promoted to v’s type before
being stored into v.
If the type of v is “lower” than that of e, then the value of e is demoted to v’s type before
being stored into v.
Here are some examples of how demotion can lose information:
Demotion from a longer integral type to a shorter integral type (such as from long to int)
discards the leftmost (most significant) bits in the binary number. The result may be a
drastically different number.
Demotion from a floating-point type to an integral type causes truncation of the fractional
part (and an undefined result if the whole-number part will not fit into the destination
variable). The result of truncating a negative number varies from one machine to another.
Demotion from a longer floating-point type to a shorter floating-point type (such as from
double to float) may result in a loss of digits of precision.
Our description of type coercion in an assignment operation also holds for argument
passing and returning a function value with a Return statement. For example, assume that
INT_MAX on your machine is 32767 and that you have the following function:

Description
If the function is called with the statement
then the value 50000 (which is implicitly of type long because it is larger than INT_MAX) is
demoted to a completely different, smaller value that fits into an int location. In a similar
fashion, execution of the function
Description
causes demotion of the value 70000 to a smaller int value because int is the type of the
function return value.
One interesting consequence of implicit type coercion is the futility of declaring a variable to
be unsigned, in hopes that the compiler will prevent you from making a mistake like this:
The compiler does not complain at all. It generates code to coerce the int value to an
unsigned int value. But if you now display the value of unsignedVar, you’ll see a strange-
looking positive integer. As we have pointed out before, it’s best to avoid using unsigned for
ordinary numeric computations.
To be safe, avoid implicit coercion whenever you can!
BACKGROUND INFORMAT ION Ignoring a Function Value
A peculiarity of the C++ language is that it lets you ignore the value returned by a
valuereturning function. For example, you could write the following statement in your
program without any complaint from the compiler:
When this statement is executed, the value returned by sqrt is discarded. This function
call has no effect except to waste time.

Clearly, this call to sqrt is a mistake. But sometimes it does make sense to write a
valuereturning function in a way that allows the caller to ignore the function value.
Consider the example of the remove function from the C++ standard library, which is
used to delete a file from the system. It takes a single argument—a C string specifying the
name of the file—and returns a function value. This function value is an integer notifying
you of the status: 0 if the operation succeeded, and nonzero if it failed. Here is how you
might call remove:
Description
If you assume the system always succeeds at deleting a file, you can ignore the return
value by calling remove like a void function:
The remove function is sort of a hybrid between a void and a value-returning function.
Conceptually, it is a void function; its principal purpose is to delete a file, not to compute a
status value. Literally, though, it’s a value-returning function.
In this text, we don’t write hybrid functions. We prefer to keep the concept of a void
function distinct from a value-returning function. Nevertheless, there are two reasons why
every C++ programmer should know about the possibility of ignoring a function value.
First, if you accidentally call a value-returning function as a void function, the compiler
won’t flag the mistake. Second, you sometimes encounter this style of coding in other
people’s programs and in the C++ library.
QUICK CHECK
9.5.1 What can occur with the demotion of a data value?
9.5.2 What happens when we assign a long value to an int value?
9.5.3 Give an example of automatic coercion that may be dangerous and lead to
unexpected results.
9.5.4 What parts of a function are affected by type coercion?
Problem-Solving Case Study
HEALTH PROFILE
PROBLEM: Your grandmother has just come back from the doctor’s office and is
confused about all the numbers that were used to evaluate her health. The nurse weighed

her, took her blood pressure, and noted her cholesterol levels from her lab work on his
tablet. Later, the doctor came in, read that data on her tablet, smiled, and said she was
fine. In looking over the report she gave your grandmother, you realize that it could be
useful to have a program that explains this information to patients.
Before you can state the input and output from this program, you need to go to the Web
and do some research. You find that there are two important types of cholesterol:
highdensity lipoprotein (HDL; good) and low-density lipoprotein (LDL; bad). The ratio of the
two is also important. You find several references that give you interpretations for a range
of HDL and LDL values.
The interpretation of your weight depends on a ratio of your weight to your size as
represented in the body mass index (BMI). Good! You already have a program to calculate
BMI.
Blood pressure is made up of two values: systolic and diastolic. When talking about
blood pressure, the readings are usually given as “something” over “something,” such as
120/80. The first value is the systolic pressure, and the second is the diastolic pressure.
Now, you have enough information to determine the input.
INPUT: Patient’s name, HDL, LDL, weight in pounds, height in inches, systolic pressure,
and diastolic pressure.
OUTPUT: Patient’s name, each of the input values, and interpretations of the cholesterol,
weight, and blood pressure readings are written on file “Profile.”
DISCUSSION: The decomposition of this problem into tasks is straightforward. The data
values are prompted for, entered, and evaluated. The only question is whether to enter the
data all at once and evaluate them or to have each evaluation module input its own data.
The principle of information hiding suggests that we include the input process within the
modules that evaluate the data.
Here are the interpretations you found on the Web concerning cholesterol:
HDL
Interpretation
< 40
Too low
≥ 40 and < 60
Is okay
≥ 60
Excellent
LDL
Interpretation
> 100
Optimal
≥ 100 and < 130
Near optimal
≥ 130 and < 160
Borderline high
≥ 160 and < 190
High
≥ 190
Very high
Ratio HDL/LDL
Interpretation
> 0.3
Ratio is good.
≤ 0.3
Ratio is not good.
Fortunately, you already have the BMI calculator that can simply be turned into a
function with the food suggestions removed. What about blood pressure readings? Again,
here is what you found on the Web concerning blood pressure readings:

Systolic
Interpretation
< 120
Optimal
< 130
Normal
< 140
Normal high
< 160
Stage 1 hypertension
< 180
Stage 2 hypertension
≥ 180
Stage 3 hypertension
Diastolic
Interpretation
< 80
Optimal
< 85
Normal
< 90
High normal
< 100
Stage 1 hypertension
< 110
Stage 2 hypertension
≥ 110
Stage 3 hypertension
Main
Level 0
Open output file
IF output file not opened okay
   Write error message
   Return 1
Get name
Evaluate cholesterol
Evaluate BMI
Evaluate blood pressure
Close output file
Get Name (Out: String function value)
Level 1
Prompt for first name
Get first name
Prompt for last name
Get last name
Prompt for middle initial
Get middle initial
return first + ‘ ’ + middle + “. ” + last
Evaluate Cholesterol (In/out: healthProfile; In: name)
Prompt for name’s input
Get data
Output data
Evaluate input according to charts
Output message
Name has been added to the parameter list so that the user can prompt for the specific
patient’s data. The first two lines can be directly translated into C++. We can output as we
evaluate, so these two tasks are implemented together.
Evaluate Input and Output (In: HDL, LDL)
IF (HDL < 40)

Output on healthProfile ”   HDL is too low”
ELSE if (HDL < 60)
Output on healthProfile ”   HDL is okay”
ELSE
Output on healthProfile ”   HDL is excellent”
IF (LDL < 100)
Output on healthProfile ”   LDL is optimal”
ELSE IF (LDL < 130)
Output on healthProfile ”   LDL is near optimal”
ELSE IF (LDL < 160)
Output on healthProfile ”   LDL is borderline high”
ELSE IF (LDL < 190)
Output on healthProfile ”   LDL is high”
ELSE
Output on healthProfile ”   LDL is very high”
IF (ratio = 0.3)
Output on healthProfile ”   Ratio of HDL to LDL is good” ;
ELSE
Output on healthProfile ”   Ratio of HDL to LDL is not good”
The algorithm for Evaluate BMI is discussed in Chapter 5. We can use it here by
changing only the output. Evaluate Blood Pressure is identical in form, so we leave its
development as Case Study Follow-Up Exercise 3.
Which modules should be functions and which should be coded inline? GetName should
be a value-returning function; Evaluate Cholesterol, Evaluate BMI, and Evaluate Blood
Pressure should be void functions. The question is whether the Evaluate Input and Output
modules should be separate functions. If we were coding this in a language that allowed us
to nest a function within a function, we could make them separate functions. However,
C++ does not. These modules would have to be coded at the same level as the functions
that call them. Thus they will be coded inline. Another reason for doing so is that Evaluate
Cholesterol, Evaluate BMI, and Evaluate Blood Pressure are tightly knit functions with a
clearly stated purpose and interface.

Description
Description

Description

Description


Description


Description
Description
Here is sample input and output.
CONSOLE
Description
FILE PROFILE

Description
TESTING: There are nine inputs to this program: two strings and a character in Name, two
integer values in EvaluateCholesterol, two floating-point values in EvaluateBMI, and two
integer values in EvaluateBloodPressure. The input to Name is just output, so a simple test to
see that it reads and concatenates its input is sufficient. The other functions need to be
checked to ensure they work correctly for each data value range. We demonstrate this
testing process in the Testing and Debugging section.
SOFTWARE ENGINEERING TIP Conceptual Versus Physical
Hiding of a Function Implementation
Although program Profile is somewhat complex, the main function looks simple; it
doesn’t even contain a control structure. All of the control structures are in the individual
functions. This is an example of how the complexity of a program is hidden by reducing
major control structures to abstract actions performed by functions. For example,
evaluating a patient’s BMI is an abstract action that appears in main as a call to
EvaluateBMI. What the action does is separated from how it does it. This aspect of a design
is called control abstraction.
Control abstraction can serve as a guideline for deciding which modules to code as
functions versus directly. If a module contains a control structure, it is a good candidate for
being a function. Even if a module does not contain a control structure, you should still
consider other factors. If the module is lengthy, or called from multiple places, you should
use a function.
A related design concept is functional cohesion, which states that a module should
perform exactly one abstract action. If you can state the action that a module performs in
one sentence with no conjunctions (ands), then it is highly cohesive. A module that has
more than one primary purpose lacks cohesion. Apart from main, all of the functions in
program Profile have good cohesion.
A module that only partially fulfills a purpose also lacks cohesion. Such a module should
be combined with whatever other modules are directly related to it. For example, it makes
no sense to have a function that outputs the first digit of a date, because outputting a date
is one abstract action.
A third aspect of a module’s design is its communication complexity, which reflects the
amount of data that passes through its interface—for example, the number of arguments.
A module’s communication complexity is often an indicator of its cohesiveness. Usually,
if a module requires a large number of arguments, either it is trying to accomplish too
much or it is only partially fulfilling a purpose. In such a case, you should step back and
see if there is an alternative way of dividing up the problem so that a minimal amount of
data is communicated between modules. The modules in 
Profile have low
communication complexity.
Control abstraction The separation of the logical properties of an action from its
implementation.

Functional cohesion The principle that a module should perform exactly one abstract
action.
Communication complexity A measure of the quantity of data passing through a
module’s interface.

Testing and Debugging
One of the advantages of a modular design is that you can start testing before the code is
written for all of the modules. If we test each module individually, we can assemble the
modules into a complete program with much greater confidence that it is correct. In this
section, we introduce a technique for testing a module separately.
Stubs and Drivers
Suppose you were given the code for a module and your job was to test it. How would you
test a single module by itself? First, it must be called by something (unless it is main). Second,
it may have calls to other modules that aren’t available to you. To test the module, you must fill
in these missing links.
When a module contains calls to other modules, we can write dummy functions called
stubs to satisfy those calls. A stub usually consists of an output statement that displays a
message such as “Function such-and-such just got called.” Even though the stub is a
dummy, it allows us to determine whether the function is called at the right time by main or
another function.
A stub also can be used to display the set of values that are passed to it; such output tells
us whether the module under test is supplying the correct information. Sometimes a stub
assigns new values to its reference parameters to simulate return results to give the calling
module something on which to keep working. Because we can choose the values that are
returned by the stub, we have better control over the conditions of the test.
Here is a stub that simulates the Name function in the Profile program by returning an
arbitrary name:
Stub A dummy function that assists in testing part of a program. A stub has the same
name and interface as a function that actually would be called by the part of the program
being tested, but is usually much simpler than the real function.
Description
This stub is simpler than the function it simulates, which is typical because we use a stub is to
provide a predictable environment for the module under test.

In addition to supplying a stub for each call within the module, you must provide a dummy
program—a driver—to call the module itself. A driver contains the bare minimum of code
required to execute the call.
By surrounding a module with a driver and stubs, you gain complete control of the
conditions under which it executes. This allows you to test different situations and
combinations that may reveal errors. You write a test plan for a module, and then a driver
implements that test plan.
Here is a test plan and a driver for the EvaluateCholesterol function in the Profile program.
This test plan is based on the interpretation guidelines used to write the function. Each
category is taken once. Case Study Follow-Up Exercise 1 asks you to determine if this test
plan is sufficient.
Driver A simple main function that is used to call a function being tested. The use of a
driver permits direct control of the testing process.
Test Plan for EvaluateCholesterol Function

Description


Description
Description
The driver calls the function eight times, which allows the points in the If statements to be
executed. Here are the input and the output for this code:
Input

Description
Output

Description
Stubs and drivers are important tools in a team programming environment. With this
approach, the programmers develop the overall design and the interfaces between the
modules. Each programmer then designs and codes one or more of the modules and uses
drivers and stubs to test the code. When all of the modules have been coded and tested, they
are assembled into what should be a working program.
For team programming to succeed, it is essential that all of the module interfaces be defined
explicitly and that the coded modules adhere strictly to the specifications for those interfaces.
Obviously, global variable references must be carefully avoided in a team-programming
situation because it is impossible for each person to know how the rest of the team is using
every variable.

Graphical User Interface (GUI)
Fortunately, the changes we need to make to leverage GUI components for the health profile
program are very straightforward. In particular, we only need to focus on changes to the user
input requirements for the Name, EvaluateCholesterol, and EvaluateBMI functions. Each of
these functions used the console to get input from the user such as name, weight, height, and
so forth. This version will use GUI components we have seen in previous chapters. In
particular, we will be using only two GUI components: TextDialog and IntDialog.
We will change the Name function to use the TextDialog widget to get the first name, last
name, and middle initial of the user. The original program read in a character for the middle
initial. This version will use a string so we can use our existing TextDialog widget. Here is the
original code:
Description
This is the modified version with the GUI additions in place:
Description

Description
Because we changed the type of the middleInitial variable to string instead of a char, it is
possible for the user to enter more than one character for the middle initial. To ensure that we
have a single character, we extract the first character from the string, using the at(0) method
call. This is what the GUI looks like when it is rendered to the screen:
Description
In the EvaluateCholesterol function we replace the stream input/output with IntDialog widgets
(the rest of the code remains unchanged):
Description
Lastly, we replace the calls to the input/output streams in EvaluateBMI with GUI components
to retrieve the input values for weight and height from the user.

Description
These widgets are rendered with buttons that allow the user to increment and decrement
the values for the weight and height or type them in directly. They also protect the user from
inputting non-integer values. This is what they look like when rendered to the screen:
Description
The full GUI version of the program is listed below, with the changes highlighted. If you look
closely, you will notice that none of these changes required a change in the interface of any of
the functions. That’s another example of the process of refactoring, which functions enable.
Description

Description


Description

Description

Description
Description

Testing and Debugging
Testing and Debugging Hints
1. Make sure that variables used as arguments to a function are declared in the block
where the function call is made.
2. Carefully define the precondition, postcondition, and parameter list to eliminate side
effects. Variables used only in a function should be declared as local variables. Do not
use global variables in your programs. (Exception: It is acceptable to reference cin and
cout globally.)
3. If the compiler displays a message such as UNDECLARED IDENTIFIER, check that the
identifier isn’t misspelled (and that it is, in fact, declared), that the identifier is declared
before it is referenced, and that the scope of the identifier includes the reference to it.
4. If you intend to use a local name that is the same as a nonlocal name, be aware that a
misspelling in the local declaration will wreak havoc. The C++ compiler won’t complain,
but will cause every reference to the local name to go to the nonlocal name instead.
5. Remember that the same identifier cannot be used in both the parameter list and the
outermost local declarations of a function.
6. With a value-returning function, be sure the function heading and prototype begin with the
correct data type for the function return value.
7. With a value-returning function, don’t forget to use a Return statement:
return Expression;
Make sure the expression is of the correct type, or implicit type coercion will occur.
8. Remember that a call to a value-returning function is part of an expression, whereas a
call to a void function is a separate statement. (C++ softens this distinction, however, by
letting you call a value-returning function as if it were a void function, ignoring the return
value. Be careful here.)
9. In general, don’t use reference parameters in the parameter list of a value-returning
function. A reference parameter must be used, however, when an I/O stream object is
passed as a parameter.
10. If necessary, use your system’s debugger (or use debug output statements) to determine
when a function is called and if it is executing correctly. The values of the arguments can
be displayed immediately before the call to the function (to show the incoming values)
and immediately after the call completes (to show the outgoing values). You also may
want to display the values of local variables in the function itself to indicate what happens
each time it is called.

Summary
The scope of an identifier refers to the parts of the program in which it is visible. C++
function names have global scope, as do the names of variables and constants that are
declared outside all functions and namespaces. Variables and constants declared within a
block have local scope; they are not visible outside the block. The parameters of a function
have the same scope as local variables declared in the outermost block of the function.
With rare exceptions, it is poor practice to declare global variables and reference them
directly from within a function. All communication between the modules of a program
should be through the argument and parameter lists (and the function value for a value-
returning function). The use of global constants, by contrast, is considered an acceptable
programming practice because it adds consistency and makes a program easier to
change while avoiding the pitfalls of side effects. Well-designed and well-documented
functions that are free of side effects can often be reused in other programs. Many
programmers, in fact, keep a library of functions that they use repeatedly.
The lifetime of a variable is the period of time during program execution when memory is
allocated to it. Global variables have a static lifetime: Memory remains allocated for the
duration of the program’s execution. By default, local variables have an automatic lifetime:
Memory is allocated and deallocated at block entry and block exit. A local variable may be
given static lifetime by using the word static in its declaration. This variable has the
lifetime of a global variable but the scope of a local variable.
C++ allows a variable to be initialized in its declaration. For a static variable, initialization
occurs once—when control first reaches its declaration. An automatic variable is initialized
each time control reaches the declaration.
C++ provides two kinds of subprograms, void and value-returning functions. A value-
returning function is called from within an expression and returns a single result that takes
its place in the expression. For the function value to be returned, the function must execute
a Return statement with an expression of the appropriate type.
All the scope rules, as well as the rules about reference and value parameters, apply to
both void functions and value-returning functions. It is considered poor programming
practice, however, to use reference parameters in a value-returning function definition.
Doing so increases the potential for unintended side effects. (An exception is when I/O
stream objects are passed as parameters. Other exceptions are noted in later chapters.)
We can use stubs and drivers to test functions in isolation from the rest of a program.
They are particularly useful in the context of team programming projects.

Quick Check Answers
9.1.1 Global. 9.1.2 When a nested block contains a locally declared identifier with the same
name.
9.1.3 Class scope, Local scope, Namespace scope, and Global scope. 9.2.1 Variables
declared within the functions are local. In Quick1, quest and qc. In Quick2, quest and
forever. 9.2.2 check, quest, and the locally declared qc. 9.2.3 check and qc in the program,
together with forever, are static. The variables in Quick1 and the variable quest in Quick2
are automatic. 9.2.4 During the execution time of a program. 9.2.5 The lifetime of a variable
is the period of time in which memory has actually been allocated to it. 9.2.6 A variable
whose storage is allocated at block entry and deallocated at block exit. 9.2.7 The duration
of the entire program. 9.2.8 An initializer. 9.2.9 Only once. 9.2.10 An automatic variable is
initialized each time control enters the block in which it is declared. 9.3.1 They enable a
function to affect the state of the program through a means other than the well-defined
interface of the parameter list. 9.3.2 Any effect of one function on another function that is
not part of the explicitly defined interface between them. 9.3.3 Reusability. 9.3.4 The cin
and cout I/O facilities provided by the standard libraries. 9.3.5 Global constants. 9.4.1 A
value-returning function. 9.4.2 Using a type name in place of void, and using a Return
statement to pass a value back to the caller. 9.4.3 fever = TempCheck(98.6); 9.4.4 One.
9.4.5 The data type of the result value returned by a function. 9.4.6 return; and return
Expression; 9.5.1 Loss of information. 9.5.2 The long value is demoted and the leftmost
bits in the binary number will be discarded. 9.5.3 unsigned x = -1; 9.5.4 A function’s
parameters and return values.

Exam Preparation Exercises
9.1 A function parameter is local to the entire block that is the body of the function.
True or false?
9.2 A reference parameter has the same scope as a global variable. True or false?
9.3 A global variable can be referenced anywhere within the program. True or false?
9.4 Function names have global scope. True or false?
9.5 Match the following terms with the definitions given below.
a. Scope
b. Name precedence
c. Scope rules
d. Nonlocal identifier
e. Lifetime
f. Automatic variable
g. Static variable
h. Side effect
i. The semantics that specify where we can reference nonlocal identifiers.
ii. A variable for which memory is allocated for the duration of the program.
iii. When one function affects another function in a manner that isn’t defined by
their interface.
iv. The precedence that a local identifier has over a global identifier with the same
name.
v. The region of program code where it is legal to reference an identifier.
vi. A variable that has memory allocated at block entry and deallocated at block
exit.
vii. An identifier declared outside of the current block.
viii. The period in which an identifier has memory allocated to it.
9.6 Identify the side effect in the following function:

Description
9.7 Identify the side effect in the following program (which uses poor style for naming
variables):

Description
9.8 What is the scope of a namespace that is specified in a using directive outside of
all functions?
9.9 What is the scope of the std namespace in the following code?
Description
9.10 What is the lifetime of each of the following?
a. A global variable.
b. A local variable in a function.
c. A local, static variable in a function.
9.11 Rewrite the following declaration and initialization as a single statement:
9.12 If a local, static variable is initialized in its declaration within a function, when does
the variable get initialized and how often?
9.13 If a local, nonstatic variable is initialized in its declaration within a function, when
does the variable get initialized and how often?
9.14 A value-returning function can have just one Return statement. True or false?
9.15 What’s wrong with the following function?
Description
9.16 What’s wrong with the following function?

Description
9.17 What’s wrong with the following function?
Description
9.18 Using a reference parameter in a value-returning function makes which kind of
programming error more likely?

Programming Warm-Up Exercises
9.1 The following program is written in a very poor style that uses global variables
instead of parameters and arguments, resulting in unwanted side effects. Rewrite it
using good style.
Description
9.2 Write the heading for a bool function Equals that has two value float parameters, x
and y.
9.3 Write the function prototype for the function in Exercise 9.2.
9.4 Write a body for the function in Exercise 9.2 that compares x and y, returning true
if their difference is less than 0.00000001 and false otherwise.

9.5 Write the heading and function prototype for a float function called ConeVolume that
takes two value float parameters, radius and height.
9.6 Write the body for the function heading in Exercise 9.5. It computes the volume of
a cone using the formula:
9.7 Rewrite the void function described in Programming Warm-Up Exercises 8.4 and
8.6 as a value-returning function. The function, which is called GetLeast, takes an
ifstream parameter called infile as an input parameter that is changed. It returns an
int value that is the lowest value read from the file.
9.8 Rewrite void function Reverse, described in Programming Warm-Up Exercises 8.8
and 8.10, as a value-returning function. It should take a string parameter as input.
The function returns a string that is the character-by-character reverse of the string in
the parameter. The parameter is called original.
9.9 Rewrite void function LowerCount, described in Programming Warm-Up Exercise
12 of Chapter 8, as a value-returning function. The function reads a line from cin and
returns an int containing the number of lowercase letters in the line. In Appendix C,
you will find the description of function islower, which returns true if its char
parameter is a lowercase character.
9.10 Write a value-returning float function called SquareKm that takes two float
parameters, length and width, representing a length and width in miles, and outputs a
return value of the area in square kilometers. The conversion factor for kilometers
from miles is 1.6.
9.11 Write a value-returning bool function called Exhausted that takes an int
parameter called prints. The function keeps track of how many prints have been
produced by a photo-printing machine. When the total number of prints exceeds 5000,
it returns true. Each time the function is called, the value in the parameter is added to
the total. When the total exceeds 5000, the variable containing the total is reset to zero
before the function returns, under the assumption that the ink will be replaced before
more prints are made.
9.12 Write a value-returning string function called MonthAbbrev that takes an int value
as a parameter. The parameter, month, represents the number of the month. The
function returns a string containing the three-letter abbreviation for the corresponding
month number. Assume that the month number is in the range of 1 to 12.

9.13 Modify the function in Exercise 9.12 to handle invalid month numbers by
returning the string “Inv”.
9.14 Write a value-returning float function called RunningAvg that takes a float
variable, value, as its input and returns the running average of all the values passed to
the function since the program first called it.

Programming Problems
9.1 Write a C++ program that defines value-returning functions for the arithmetic
integer binary operations plus, minus, multiply, and divide. You should also write a
value-returning function for the unary operation negate. Use your function declarations
to compute the following as a single expression:
Description
Your main function should not declare a single variable, but it should display as output the
result of computing this expression. Your implementation is correct if your output yields the
value –11.
9.2 Use your function declarations in Problem 9.1 to define two additional integer
functions for power and factorial. Use your new function declarations to compute as a
single expression the following:
(5! + 4!)3
Your main function should not declare a single variable, but it should display as output the
result of computing this expression. Your implementation is correct if your output yields the
value 2985984.
9.3 ROT13 (rotate by 13 places) is a simple letter substitution cipher that is an
instance of a Caesar cipher developed in ancient Rome and used by Julius Caesar in
his private correspondence. ROT13 replaces a letter with the letter 13 letters after it in
the alphabet. The following table demonstrates the translation in ROT13:
A
↔
N
B
↔
O
C
↔
P
D
↔
Q
E
↔
R
F
↔
S
G
↔
T
H
↔
U
I
↔
V

J
↔
W
K
↔
X
L
↔
Y
M
↔
Z
Thus, the translation of the word JULIUS using ROT13 would be WHYVHF. Write a C++
program that asks the user for the name of an input file and translates its contents using
ROT13. Your main function should read the input file and coordinate calls to a value-
returning function named Rot13 that does the translation for each character, and a void
function WriteTranslatedChar that writes the translated character to a second file. The
Rot13 function takes as input the character to be translated and returns the translated
character. WriteTranslatedChar will have two parameters, the translated character and a
reference to an ifstream data type for a file named output.rot13, and it writes the
translated character to this file.
9.4 In mathematics, the Fibonacci numbers are the series of numbers that exhibit the
following pattern:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
In mathematics the sequence Fn of Fibonacci numbers is defined by the following
recurrence relation:
Fn = Fn-1 + Fn-2
with the initial values of F0 = 0 and F1 = 1. Thus, the next number in the series is the sum
of the previous two numbers. Write a program that asks the user for a positive integer N
and generates the Nth Fibonacci number. Your main function should handle user input and
pass those data to a function called Fib that takes an integer value N as input and returns
the Nth Fibonacci number.
9.5 You are working on a project that requires climate data for a location. The
maximum daily change in barometric pressure is one aspect of climate that your
company needs. You have a file (barometric.dat) containing hourly barometer
readings taken over the course of a year. Each line of the file contains the readings for
a single day, separated by blanks. Each reading is expressed in inches of mercury, so
it is a decimal number ranging from approximately 28.00 to 32.00. For each line of
data, you need to determine the maximum and minimum readings, and output the
difference between those readings to file differences.dat. Each output value should
appear on a separate line of the file. Once the file has been read, the program should
output the greatest and least differences for the year on cout. Develop the program
using functional decomposition, and use proper style and documentation in your code.
Your program should make appropriate use of value-returning functions in solving this

problem. Extend the program in Problem 9.5 so that it also outputs the maximum and
minimum barometric readings for each day on file differences.dat, and then outputs
the maximum and minimum readings for the year on cout at the end of the run. You’re
working for a lumber company, and your employer would like a program that
calculates the cost of lumber for an order. The company sells pine, fir, cedar, maple,
and oak. Lumber is priced by board feet. One board foot equals 1 square foot, 1 inch
thick. The price per board foot is given in the following table: The size of lumber is
specified in inches of width and height, and feet of length that need to be converted to
board feet. For example, a 2 × 4 × 8 piece is 2 inches wide, 4 inches high, and 8 feet
long, and is equivalent to 5.333 board feet. The user will enter a letter and four integer
numbers. The integers are the number of pieces, width, height, and length. The letter
will be one of P, F, C, M, O (corresponding to the five kinds of wood) or T, meaning total.
When the letter is T, there are no integers following it on the line. The program should
display the price for each entry and display the total after T is entered. Here is an
example run:
9.6 Extend the program in Problem 9.5 so that it also outputs the maximum and
minimum barometric readings for each day on file differences.dat, and then outputs
the maximum and minimum readings for the year on cout at the end of the run.
9.7 You’re working for a lumber company, and your employer would like a program
that calculates the cost of lumber for an order. The company sells pine, fir, cedar,
maple, and oak. Lumber is priced by board feet. One board foot equals 1 square foot,
1 inch thick. The price per board foot is given in the following table:
Pine
1.89
Fir
2.09
Cedar
3.26
Maple
5.50
Oak
4.10
The size of lumber is specified in inches of width and height, and feet of length that need to
be converted to board feet. For example, a 2 × 4 × 8 piece is 2 inches wide, 4 inches high,
and 8 feet long, and is equivalent to 5.333 board feet. The user will enter a letter and four
integer numbers. The integers are the number of pieces, width, height, and length. The
letter will be one of P, F, C, M, O (corresponding to the five kinds of wood) or T, meaning
total. When the letter is T, there are no integers following it on the line. The program should
display the price for each entry and display the total after T is entered. Here is an example
run:

Description
Develop the program using functional decomposition, and use proper style and
documentation in your code. Your program should make appropriate use of value-returning
functions in solving this problem. Be sure that the user prompts are clear and that the
output is labeled appropriately.
9.8 Write a program that determines the day of the week for a given date. You can
invent your own complex algorithm that takes into account the special leap year rules
and changes in calendars, but this is a case where it makes sense to look for things
that are familiar. Who else might need to compute values from dates over a wide span
of time? Historians work with dates, but generally don’t compute from them.
Astronomers, however, need to know the difference in time between orbital events in
the solar system that span hundreds of years. Consulting an astronomy text, you find
that there is a standard way of representing a date, called the Julian Day Number
(JDN). This value is the number of days that have elapsed since January 1, 4713 b.c.
Given the JDN for a date, there is a simple formula that tells the day of the week:
The result is in the range of 0 to 6, with 0 representing Sunday.
The only remaining problem is how to compute the JDN, which is not so simple. The
algorithm computes several intermediate results that are added together to give the JDN.
We look at the computation of each of these three intermediate values in turn.
If the date comes from the Gregorian calendar (later than October 15, 1582), then
compute intRes1 with the following formula; otherwise, let intRes1 be zero.
The second intermediate result is computed as follows:
We compute the third intermediate value with this formula:
Finally, the JDN is computed this way:

Your program should make appropriate use of value-returning functions in solving this
problem. These formulas require nine significant digits; you may have to use the integer
type long and the floating-point type double. Your program should prompt the user
appropriately for input and properly label the output.
9.9. Reusing functions from Problem 9.8 as appropriate, write a C++ program that
computes the number of days between two dates. If your design for Problem 9.8 used
good functional decomposition, this should be easy. You merely input two dates,
convert them to their JDNs, and take the difference of the JDNs.
Your program should make appropriate use of value-returning functions in solving this
problem. These formulas require nine significant digits; you may have to use the integer
type long and the floating-point type double. Your program should prompt the user
appropriately for input and properly label the output.

Case Study Follow-Up
1. Was the test plan outlined for function EvaluateCholesterol complete? If not, why
not?
2. The BMI measure is calculated as an integer. Is this sufficient? Would it be a better
idea to make this a real value? What would have to be changed to do so?
3. Write the algorithm for the Evaluate Blood Pressure module.
4. Write a test plan and a driver to test function EvaluateBloodPressure.
5. Add a Boolean function to the three Evaluate modules that is true if the data are
okay and false otherwise. Test the input within each module for negative or zero input
values, which should be considered errors. If an error occurs, state in which module it
occurs and set the error flag.
6. Rewrite main to test the flag set in Exercise 5 after each call and exit the program if
an error occurs.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 0
User-Defined Data Types
KNOWLEDGE GOALS
To know all of the simple data types provided by the C++ language.
To understand the concept of an enumerated type.
To understand the difference between external and internal representations of
character data.
To understand the concept of a record type.
To understand the concept of a pointer variable.
To understand the general concept of a C++ union type.
SKILL GOALS
To be able to:
Use a Typedef statement.
Declare and use an enumeration type.
Use the For and Switch statements with user-defined enumeration types.
Distinguish a named user-defined type from an anonymous user-defined type.
Declare a struct (record) data type, a data structure whose components may be
heterogeneous.
Access a member of a struct variable.
Define a hierarchical record structure.
Access values stored in a hierarchical record.
Declare variables of pointer types.
Take the addresses of variables and access the variables through pointers.
Write an expression that selects a member of a class, struct, or union that is pointed
to by a pointer.

This chapter represents a transition in your study of programming. So far, we have
emphasized simple variables and control structures. In this chapter, the focus shifts to
structuring (organizing) data. To begin this transition, we examine the concept of data types in
greater detail.
Until now, we have worked primarily with the data types int, char, bool, and float. These
four types are technically adequate for solving any problem, but sometimes, representing the
data in a program becomes cumbersome using only the built-in types. C++ has several
mechanisms for creating user-defined data types; that is, new data types we ourselves
define. This chapter introduces one such mechanism, the enumeration type.
We also expand the definition of a data type to include structured types, which represent
collections of components. We begin with the idea of structured types in general and then look
at two examples provided by C++: struct and union.

10.1 Built-In Simple Types
In Chapter 2, we defined a data type as a set of values (called the domain) along with a set of
operations on those values. For the int type, the domain is the set of whole numbers from
INT_MIN through INT_MAX, and the operations we have seen so far are +, –, *, /, %, ++, ––, and
the relational and logical operations. The domain of the float type is the set of real numbers a
particular computer is capable of representing, and the operations are similar to the int type
except that modulus (%) is excluded. For the bool type, the domain is the values true and
false, and the operations are the logical (!, &&, ||) and relational operations. The char type,
although used primarily to represent characters, is classified as an integral type because it
uses integers to stand for characters. Later in the chapter we see how that works.
The int, char, bool, and float types have a property in common: The domain of each is
made up of indivisible, or atomic, values. Data types with this property are called simple ( or
atomic) data types. An atomic value does not have component parts that are accessed
separately; for example, a single character of type char is atomic, but the string “Good
Morning” is composed of 12 individual characters that we can also access.
Another way of describing a simple type is to say that only one value can be associated
with a variable of that type. In contrast, a structured type is one in which an entire collection of
values can be associated with a variable. As we just noted, a string holds a collection of
characters, and it can be assigned to a variable that represents it.
Simple (atomic) data type A data type in which each value is atomic (indivisible).
FIGURE 10.1 C++ Simple Types
Description
FIGURE 10.1 shows the simple types that are built into the C++ language. This figure is a
portion of the complete diagram of C++ data types presented in Figure 3.1.
In this figure, one of the types—enum—is not a data type in the same sense that int and
float are. Instead, it is a mechanism we can use to define new simple data types of our own.
We look at enum later in this chapter.

Numeric Types
The types char, short, int, and long represent integers of different sizes. Similarly, the types
float, double, and long double refer to floating-point numbers of different sizes. What do we
mean by sizes?
In C++, sizes are measured in multiples of the size of a char. By definition, the size of a
char is 1. On most—but not all—computers, the 1 means one byte. (Recall from Chapter 1
that a byte is a group of eight bits.)
Let’s use the notation sizeof (SomeType) to denote the size of a value of type SomeType.
Then, by definition, sizeof (char) = 1. Other than char, the sizes of data objects in C++ are
machine dependent. On one machine, it might be the case that
sizeof (char) =1
sizeof (short) =2
sizeof (int) =4
sizeof (long) =8
On another machine, the sizes might be as follows:
sizeof (char) = 1
sizeof (short) =2
sizeof (int) =2
sizeof (long) =4
Despite these variations, the C++ language guarantees that the following statements are
true:
1 = sizeof (char) <= sizeof (short) <= sizeof (int) <= sizeof (long).
1 <= sizeof (bool) <= sizeof (long).
sizeof (float) <= sizeof (double) <= sizeof (long double).
A char is at least 8 bits.
A short is at least 16 bits.
A long is at least 32 bits.
For numeric data, the size determines the range of values. We showed a table of the range
of values for numeric types in Chapter 3. Be careful: The actual range of a numeric data type
is machine dependent. Making assumptions about the actual range in a program may cause
problems when it is run on another machine.
Recall that the reserved word unsigned may precede the name of certain integral types—
unsigned char, unsigned short, unsigned int, and unsigned long. Values of these types are
nonnegative integers with values from 0 through some machine-dependent maximum value.
Although we rarely use unsigned types in this text, we mention them here for thoroughness.

C++ systems provide the C header file climits, from which you can determine the
maximum and minimum values for your machine. This header file defines the constants
CHAR_MAX and CHAR_MIN, SHRT_MAX and SHRT_MIN, INT_MAX and INT_MIN, and LONG_MAX and
LONG_MIN. The unsigned types have a minimum value of 0 and maximum values defined by
UCHAR_MAX, USHRT_MAX, UINT_MAX, and ULONG_MAX. To find out the values specific to your
computer, you could output them like this:
Range of values The interval within which values of a numeric type must fall, specified as
the largest and smallest allowable values.
Description
Code designed for portability should check these limits where needed within the program.
Likewise, the standard C header file cfloat defines the constants FLT_MAX and FLT_MIN,
DBL_MAX and DBL_MIN, and LDBL_MAX and LDBL_MIN. To determine the ranges of values for your
machine, you could write a short program that outputs these constants.
Note that the C++ standard adds header files called limits.h and float.h that also contain
these definitions.
Characters
Each computer uses a particular character set. The ASCII set, which consists of 128 different
characters, was historically used by a majority of computers. An extended version of ASCII
provides 256 characters, which is enough for English but not for international use. This
limitation gave rise to the Unicode character set.
Unicode allows many more characters. It was invented primarily to accommodate the
diversity of alphabets and symbols of many human languages, and more recently emojis. In
C++, the data type wchar_t rather than char is used for Unicode. In this text, to keep things
simple, we limit our code to the char type and ASCII; however, it is worth learning the
specifics of wchar_t if you find yourself writing a program for international deployment.
Whichever character set is used, each character has an external representation— the
way it looks on an I/O device like a screen—and an internal representation—the way it is
stored in the computer’s memory. If you use the char constant 'A' in a C++ program, its
external representation is the letter A; that is, if you display it, you will see an A, as you would
expect. Its internal representation, though, is an data value is stored inside integer value. The
128 ASCII characters have internal representations 0 through the memory unit. 127. For

example, the ASCII table in Appendix E shows that the character 'A' has internal
representation 65, and the character 'b' has internal representation 98.
Let’s look again at the following statement:
External representation The visual (character) form of a data value.
Internal representation The form in which a data value is stored inside the memory unit.
The compiler translates the constant 'A' into the integer 65. We could also have written the
statement as follows:
Both statements have the same effect—storing 65 into someChar. However, the first is more
understandable.
Earlier we mentioned that the computer cannot tell the difference between character and
integer data in memory because both are stored as integers. However, when we perform I/O
operations, the computer does the right thing—it uses the external representation that
corresponds to the data type of the expression being output. Look at this code segment, for
example:
Description
When these statements are executed, the output is
When the << operator outputs someInt, it generates the sequence of characters 9 and 7. For
someChar, it outputs the single character a. Even though both variables contain the value 97
internally, the data type of each variable determines how it is output.
What do you think is output by the following sequence of statements?

If you answered E, you are right. The first statement declares ch and initializes it to 68. The
next statement increments ch to 69, and then its external representation (the letter E) is
output. Extending this idea of incrementing a char variable, we could output the letters A
through G as follows:
Description
This code initializes ch to 'A' (65). Each time through the loop, the external representation of
ch is output. On the final loop iteration, the 'G' is output and ch is incremented to 'H' (72). The
loop then terminates.
QUICK CHECK
10.1.1 Is bool considered an integral type or an enum type?
10.1.2 What property do the built-in types int, char, bool, and float have in common?
10.1.3 Other than char, what are the sizes of data objects in C++ dependent on?
10.1.4 What is the name of the character set that provides enough characters for the
English language? How many characters can it represent?
10.1.5 What is the name of the character set that can accommodate alphabets of
many languages?
10.1.6 What is the difference between the external and internal representation of a
character?

10.2 User-Defined Simple Types
The concept of a data type is fundamental to all popular programming languages. One
strength of C++ is that it allows programmers to create new data types, tailored to meet the
needs of a particular program. Much of the remainder of this text deals with user-defined
types. In this section, we see how to create our own simple types.
The Typedef Statement
The Typedef statement allows you to introduce a new name for an existing type. Its syntax
template is
Before the bool data type was part of the C++ language, many programmers used code like
the following to simulate a Boolean type:
Description
Description
In this code, the Typedef statement causes the compiler to substitute the word int for every
occurrence of the word Boolean in the rest of the program.
The Typedef statement provides a very limited way of defining our own types. In fact,
Typedef does not create a new type at all: It merely creates a synonym for an existing type.
As far as the compiler is concerned, the domain and operations of the Boolean type in the
previous example are identical to those of the int type.
Despite the fact that Typedef cannot truly create a new data type, it is a valuable tool for
writing more readable programs. Before bool was a built-in type, code that used Boolean, TRUE,
and FALSE was more descriptive than code that used int, 1, and 0 for Boolean operations.

Names of user-defined types obey the same scope rules as identifiers in general. Most
types, like the Boolean example, are defined globally, although it is reasonable to define a new
type within a subprogram if that is the only place it is used. The guidelines that determine
where a named constant should be defined also apply to data types.
In Chapter 3, we said that various string operations took as parameters or returned as
results unsigned integers, but that we could use int instead. Actually these values should be
of type size_type, a type defined in string as
But what is size_t? It is a type provided in the C std header file that is implementation
dependent. This unsigned integer type defines the maximum length of a string for the
particular compiler. Given this fact, it is better style to use string::size_type when working
with string operations.
string::npos is the largest possible value of type string::size_type, a number like
4294967295 on many machines. This value can be taken to mean “not a valid position,”
because string operations do not let any string become this long.
Enumeration Types
C++ allows the user to define a new simple type by listing (enumerating) the literal values that
make up the domain of the type. The literal values are identifiers, separated by commas, and
the list is enclosed in braces. Data types defined in this way are called enumeration types.
Here’s an example:
This declaration creates a new data type named Days. Whereas Typedef creates a synonym
for an existing type, an enumeration type like Days is truly a new type and distinct from any
existing type.
The values in the Days type—SUN, MON, TUE, and so forth—are called enumerators. The
enumerators are ordered, in the sense that SUN<MON<TUE. . . values in the domain of an
enumeration type. <FRI<SAT. Applying relational operators to enumerators is like applying
them to characters: The relation that is tested is whether an enumerator “comes before” or
“comes after” in the ordering of the data type.
Enumeration type A user-defined data type whose domain is an ordered set of literal
values expressed as identifiers.
Enumerator One of the values in the domain of an enumeration type.
Earlier we saw that the internal representation of a char is a nonnegative integer. Values in
an enumeration type are also represented internally as integers. By default, the first
enumerator has the value 0, the second has the value 1, and so forth. Our declaration of the
Days enumeration type is similar to the following set of declarations:

Description
If you want different internal values for the enumerators, you can specify them explicitly like
this:
There is, however, rarely a reason to do so. With the Days type, we care about the days of the
week, not the way the machine stores them. We don’t use this feature in our code, but you
may occasionally see it in C++ programs.
Notice our capitalization style. Because enumerators are similar to named constants, we
capitalize the entire identifier. This is purely a style choice. Many programmers use both
uppercase and lowercase letters in enumerators.
Here is the syntax template for the declaration of an enumeration type. It is a simplified
version; later in the chapter we expand it.
Each enumerator has the following form:
where the optional ConstIntExpression is an integer expression composed only of literal or
named constants.
The identifiers used as enumerators must follow the rules for any C++ identifier. For
example,
Description
is not legal because the items are not identifiers. The declaration

is not legal because identifiers cannot begin with digits. In the declarations
Description
types Starch and Grain are legal separately, but together they are not. Identifiers in the same
scope must be unique, so CORN cannot be defined twice.
Suppose you are writing a program for a veterinary clinic. The program must keep track of
many different kinds of animals. The following enumeration type might be used for this
purpose:
Description
Here RODENT is a literal, one of the values in type Animals. It’s important to understand that
RODENT is not a variable name. Instead, RODENT is one of the values that can be stored into the
variables inPatient and outPatient.
Next, let’s look at the kinds of operations we might want to perform on variables of
enumeration types.
Assignment
The assignment statement
does not assign the character string “DOG” to inPatient, nor the contents of a variable named
DOG. Instead, it assigns the value DOG, which is one of the values in the domain of the data type
Animals.
Assignment is a valid operation, as long as the value being stored is of type Animals. Both of
the statements
are acceptable. Each expression on the right-hand side is of type Animals—DOG is a literal of
type Animals, and inPatient is a variable of type Animals. Although we know that the internal

representation of DOG is the integer 2, the compiler prevents us from making this assignment:
Here is the precise rule:
Implicit type coercion is defined from an enumeration type to an
integral type but not from an integral type to an enumeration type.
Applying this rule to the statements
we see that the first statement stores 2 into someInt (because of implicit type coercion), but
the second produces a compile-time error. The restriction against storing an integer value into
a variable of type Animals is intended to keep you from accidentally storing an out-of range
value:
Incrementation
Suppose that you want to “increment” the value in inPatient so that it becomes the next value
in the domain:
This statement is illegal. The right-hand side is acceptable because implicit type coercion lets
you add inPatient to 1; the result is an int value. The assignment operation is not valid,
however, because you can’t store an int value into inPatient. The statement
is also invalid because the compiler considers it to have the same semantics as the earlier
assignment statement. However, you can escape the type coercion rule by using an explicit
type conversion—a type cast—as follows:
Description
When you use the type cast, the compiler assumes that you know what you are doing and
allows it.
The ability to increment a variable of an enumeration type is very useful in loops.
Sometimes we need a loop that processes all the values in the domain of the type. We might
try the following For loop:

Description
However, as we explained earlier, the compiler will complain about the expression patient++.
To increment patient, we must use an assignment expression and a type cast:
Description
Be careful here. When control exits the loop, the value of patient is 1 greater than the largest
value in the domain (SHEEP). If you want to use patient outside the loop, you must give it a
value within the range for the Animals type.
Comparison
Comparison is an operation we often perform on values of enumeration types. When you
compare values, their ordering is determined by the order in which they were listed in the type
declaration. For instance, the expression
Description
has the value true if inPatient contains the value RODENT, CAT, DOG, or BIRD.
You can also use values of an enumeration type in a Switch statement. Because RODENT,
CAT, and so on are literals, they can appear in case labels:

Description
Input and Output
Stream I/O is defined only for the basic built-in types (int, float, and so on), but not for user-
defined enumeration types. Values of enumeration types must be input or output indirectly.
To input values, one strategy is to read a string and translate it to one of the literals in the
enumeration type by looking at as many letters as are necessary to determine what the string
is.
For example, the veterinary clinic program could read the kind of animal as a string, then
assign one of the values of type Animals to that patient. Cat, dog, horse, and sheep can be
determined by their first letter. Bovine, bird, rodent, and reptile cannot be determined until the
second letter is examined. The following program fragment reads in a string representing an
animal name and converts it to one of the values in type Animals:
Description
Enumeration type values cannot be output directly either. Output is accomplished by using
a Switch statement where each branch has a character string corresponding to the value.

Description
The following program reads in a value of an enumerated type and outputs the
corresponding string:


Description
Here is sample output of this program:
Description
You might ask, why not use just a pair of letters or an integer number as a code to represent
each animal in a program? The answer is that we use enumeration types to make our
programs more readable and self-documenting.
Returning a Function Value

So far, we have been using value-returning functions to compute and return values of built-in
types:
Description
C++ allows a function return value to be of any data type—built in or user defined—except an
array (a data type we examine in later chapters, and for which there are special rules
regarding return from a function).
In the previous section, we wrote a Switch statement to convert a string into a value of type
Animals. Now let’s write a value-returning function for that. Notice how the function heading
declares the return type to be Animals:
Description
You may wonder why we didn’t include a Break after each case alternative. When an
alternative executes a Return statement, control exits the function, so it’s not possible for
control to “fall through” to the next alternative.
Here is the main function of the previous program, which calls the StrToAnimal function to
convert a string into a value of type Animals:

Description
Named and Anonymous Data Types
The enumeration types we have looked at, Animals and Days, are called named types because
their declarations included names for the types. Variables of these new data types are
declared separately using the type identifiers Animals and Days.
C++ also lets us introduce a new type directly in a variable declaration. Instead of the
declarations

Description
we could write
Description
A new type declared in a variable declaration is called an anonymous type because it does
not have a name—that is, it does not have a type identifier associated with it.
If we can create a data type in a variable declaration, why bother with a separate named
type declaration? Named types, like named constants, make a program more readable and
easier to modify. Also, declaring a type and declaring a variable of that type are two distinct
concepts; it is best to keep them separate.
We now give a more complete syntax template for an enumeration type declaration. This
template shows that the type name is optional (yielding an anonymous type) and that a list of
variables may optionally be included in the declaration.
Anonymous type A type that does not have an associated type identifier.
Description
QUICK CHECK
10.2.1 Write an enumeration type definition for the four seasons.
10.2.2 Write a For loop heading that iterates through the Seasons type defined in
Question 10.2.1.
10.2.3 What is the Typedef statement used for?
10.2.4 What is the difference between a named data type and an anonymous data
type?

MAY WE INTRODUCE Charles Babbage
The British mathematician Charles Babbage (1791–1871) is generally credited with
designing the world’s first computer. Unlike today’s electronic computers, however,
Babbage’s machine was mechanical. It was made of gears and levers, the predominant
technology of the 1820s and 1830s.
Babbage actually designed two different machines. The first, called the Difference
Engine, was to be used in computing mathematical tables. For example, the Difference
Engine could produce a table of squares:
© Photos.com/Getty Images Plus/Getty Images.
x
x2
1
1
2
4
3
9
4
16
.
.
.
.
.
.
Babbage’s Difference Engine was essentially a complex calculator that could not be
programmed. It was designed to improve the accuracy of the computation of similar
mathematical tables, not the speed. At that time, all tables were produced by hand, a

tedious and error-prone job. Because much of science and engineering in Babbage’s day
depended on accurate tables of information, an error could have serious consequences.
Even though the Difference Engine could perform the calculations only a little faster than a
human could, it did so without error. In fact, one of its most important features was that the
device would stamp its output directly onto copper plates, which could then be placed into
a printing press, thereby avoiding even typographical errors.
By 1833, the project to build the Difference Engine had run into financial trouble. The
engineer whom Babbage had hired to do the construction was dishonest and had drawn
the project out as long as possible to extract more money from Babbage’s sponsors in the
British government. Eventually the sponsors became tired of waiting for the machine and
withdrew their support. At about the same time, Babbage lost interest in the project
because he had developed the idea for a much more powerful machine, which he called
the Analytical Engine—a truly programmable computer.
The idea for the Analytical Engine came to Babbage as he toured Europe to survey the
best technology of the time in preparation for constructing the Difference Engine. One of
the technologies that he saw was the Jacquard automatic loom, in which a series of paper
cards with punched holes was fed through the machine to produce a woven cloth pattern.
The pattern of holes constituted a program for the loom and made it possible to weave
patterns of arbitrary complexity automatically. In fact, its inventor even had a detailed
portrait of himself woven by one of his machines.
Babbage realized that this sort of device could be used to control the operation of a
computing machine. Instead of calculating just one type of formula, such a machine could
be programmed to perform arbitrarily complex computations, including the manipulation of
algebraic symbols. As his associate, Ada Lovelace (the world’s first computer
programmer), elegantly put it, “We may say most aptly that the Analytical Engine weaves
algebraical patterns.” It is clear that Babbage and Lovelace fully understood the power of a
programmable computer and even contemplated the notion that someday such machines
could achieve artificial thought.
Unfortunately, Babbage never completed construction of either of his machines. Some
historians believe that he never finished them because the technology of the period could
not support such complex machinery. But most feel that Babbage’s failure was his own
doing. He was both brilliant and somewhat eccentric (it is known that he was afraid of
Italian organ grinders, for example). As a consequence, he had a tendency to abandon
projects midstream so that he could concentrate on newer and better ideas. He always
believed that his new approaches would enable him to complete a machine in less time
than his old ideas would.
When he died, Babbage had many pieces of computing machines and partial drawings
of designs, but none of the plans were complete enough to produce a single working
computer. After his death, his ideas were dismissed and his inventions ignored. Only after
modern computers were developed did historians realize the true importance of his
contributions. Babbage recognized the potential of the computer an entire century before
one was fully developed. Today, we can only imagine how different the world would be if he
had succeeded in constructing his Analytical Engine.

10.3 Simple Versus Structured Data Types
A value in a simple type cannot be broken into component parts. For example, each int value
is a single integer and cannot be further decomposed. In contrast, in a structured data type,
each value is a collection of component items. The entire collection is given a single name,
yet each component can still be accessed individually.
An example of a structured type in C++ is the string class, which is used to represent
strings. When you declare a variable myString to be of type string, myString does not
represent just one atomic data value; rather, it represents a collection of characters. Even so,
each of the components in the string can be accessed individually with an expression such as
myString.at(3), which accesses the char value at position 3.
Simple data types, both built in and user defined, are the building blocks for structured
types. A structured type gathers together a set of component values and usually imposes an
arrangement on them (see FIGURE 10.2). The method used to access the components of a
structured type depends on how the components are arranged.
FIGURE 10.3 shows the structured types available in C++. This figure is a portion of the
complete diagram presented in Figure 3.1.
Structured data type A data type in which each value is a collection of components and
whose organization is characterized by the method used to access individual components.
The operations on a structured data type include the storage and retrieval of individual
components.
FIGURE 10.2 Atomic (Simple) and Structured Data Types

Description
FIGURE 10.3 C++ Structured Types
Description
The struct and union data types are discussed in this chapter. The array is presented in
Chapter 11; the class is the topic of Chapter 12.
QUICK CHECK
10.3.1 Simple data types are the building blocks of what?
10.3.2 What are the four structured types in C++?

10.4 Records (Structs)
In computer science, a record is a heterogeneous structured data type. By heterogeneous,
we mean that the individual components of a record can be of different data types. Each
component is called a field of the record, and each field is given a field name. C++ uses its
own terminology with records. A record is a structure called a struct, the fields of a record are
called members of the struct, and each member has a member name.1
In C++, record data types are most commonly declared according to the following syntax:
Record (struct, in C++) A structured data type with a fixed number of components that
are accessed by name. The components may be heterogeneous (of different types).
Field (member, in C++) A component of a record.
where TypeName is an identifier giving a name to the data type, and MemberList is defined as
The reserved word struct is an abbreviation for structure. Because the word structure has
many other meanings in computer science, we’ll use struct or record to avoid confusion about
what we are referring to.
You will probably notice that the syntax of a member list is similar to a series of variable
declarations. Be careful: A struct declaration is defining a new data type. No memory is
allocated by the type declaration. Once the type is defined, we can declare variables of the
type. Each such variable then has memory allocated for the complete set of its members.
Let’s look at an example that groups together the parts of a mailing address:

Description
The MailingAddress struct has four members representing the street address, city, state,
and ZIP code. Note that each member is given a type. Also, member names must be unique
within a struct, just as variable names must be unique within a block.
The declaration of the MailingAddress type specifies the form that variables of this type will
have. When we define a variable of type MailingAddress, the C++ compiler allocates space for
its four members. If we define another MailingAddress variable, it will separately have space
allocated for its members.
Notice, both in this example and in the syntax template, that a struct declaration ends with
a semicolon. This seems to conflict with the rule of not putting a semicolon after the right
brace of a compound statement (block). However, the member list in a struct declaration is
not a compound statement; the braces are simply required syntax in the declaration. A struct
declaration, like all C++ declarations, ends with a semicolon.
Let’s look at another example. We can use a struct to describe a student in a class. We
want to store the student’s first and last names, the overall grade-point average prior to this
class, the grade on programming assignments, the grade on quizzes, the final exam grade,
and the final course grade.

Description
FIGURE 10.4 Pattern for a Struct
Description
In this example, firstName, lastName, gpa, programGrade, quizGrade, finalExam, and courseGrade
are member names within the struct type StudentRec. These member names make up the
member list. firstName and lastName are of type string. gpa is a float member. programGrade,
quizGrade, and finalExam are int members. courseGrade is of an enumeration type made up of
the grades A through D and F.
Just as we saw with our MailingAddress example, none of the struct members are
allocated memory until we declare a variable of the StudentRec type. StudentRec is merely a
pattern for a struct (see FIGURE 10.4).

The variables firstStudent and student are variables of type StudentRec. Each variable
contains space for storing seven member values, according to the pattern specified in the
type declaration.
Accessing Individual Components
To access an individual member of a struct variable, you give the name of the variable,
followed by a dot (period), and then the member name. This expression is called a member
selector. The syntax template is
Member selector The expression used to access components of a struct variable. It is
formed by using the struct variable name and the member name, separated by a dot
(period).
This syntax for selecting individual components of a struct is often called dot notation. To
access the grade-point average of firstStudent, we would write
To access the final exam score for a student, we would write
FIGURE 10.5 Struct Variable student with Member Selectors
Description

The component of a struct accessed by the member selector is treated like any other
variable of its type. It may be used in an assignment statement, passed as an argument, and
so on. FIGURE 10.5 shows the struct variable student, along with the member selector for
each member. In this example, we assume that some processing has already taken place, so
values are stored in some of the components.
Here’s an example of using these member selectors. The following function takes in a
StudentRec struct as a parameter; adds up the program, quiz, and final exam grades; and
returns a letter grade as the result:
Description
Aggregate Operations on Structs
In addition to accessing individual components of a struct variable, we can in some cases
use aggregate operations. An aggregate operation is one that manipulates the struct as an
entire unit.
Aggregate operation An operation on a data structure as a whole, as opposed to an
operation on an individual component of the data structure.
The following table summarizes the aggregate operations that C++ supports for struct
variables:
Aggregate Operation
Supported for Structs?
I/O
No
Assignment
Yes
Arithmetic
No
Comparison
No

Argument passage
Yes, by value or by reference
Return as a function’s return value
Yes
According to the table, one struct variable can be assigned to another. To do so, however,
both variables must be declared to be of the same type. For example, given the declarations
the statement
copies the entire contents of the struct variable student to the variable anotherStudent,
member by member.
In contrast, aggregate arithmetic operations and comparisons are not supported (primarily
because they wouldn’t make sense):
Description
Furthermore, aggregate I/O is not supported:
We must input or output a struct variable one member at a time:
Description
Note that an entire struct can be passed as an argument, as in the function example. We
used pass by value for the parameter aStudent because we did not need to change any fields
in the argument. Had we needed to do so, we would have passed it as a reference parameter.
A struct can also be returned by a value-returning function.
Let’s define another function that takes a StudentRec variable as a parameter. This function
will determine if a student’s grade in a course is consistent with their overall GPA. We define
consistent to mean that the course grade corresponds to the rounded GPA. The GPA is based
on a scale, where A is 4, B is 3, C is 2, D is 1, and F is 0. For example, if the rounded GPA is
4 and the course grade is A, then the function returns true. If the rounded GPA is 4 and the
course grade is not A, then the function returns false.
The Consistent function is below. The parameter aStudent, of type StudentRec, is again
passed by value.

Description
More About Struct Declarations
Expanding on this initial look at C++ structs, here is a more complete syntax template for a
struct declaration:
As you can see in the template, two items are optional: TypeName (the name of the struct
type being declared) and VariableList (a list of variable names between the right brace and the
semicolon). The variable list allows you to declare a struct type and to declare variables of
that type, all in one statement. For example, you could write the declarations
Description

more compactly in the form
Description
In this text, we avoid combining type and variable declarations, preferring to keep the two
steps separate.
If you omit the type name but include the variable list, you create an anonymous type:
Description
Here, someVar has an anonymous type. No other variables of that type can be declared
because the type has no name. Therefore, someVar cannot participate in aggregate operations
such as assignment or argument passing. The cautions given previously against anonymous
typing of enumeration types apply to struct types as well.
Binding Like Items
When data are obviously related, they should be collected into a record. For example, a name
is made up of a first, middle, and last name. Rather than keeping these values as separate
variables, they can be bound into a record.
Description
In the billing program for a lawn care service in Chapter 8, input and output files were
passed to each module. It would be easier to bind these files into a record and pass them as
one variable rather than two.

Description
SOFTWARE MAINTENANCE CASE STUDY Changing a Loop
Implementation
MAINTENANCE TASK: Remember the Rich Uncle case study in Chapter 7? This
problem counted the number of times certain characters were used in a text file. Now that
we how to implement modules as functions, let’s rewrite the program. Rather than looking
at the code, we go back to the top-down design.
Main
Level 0
Open files for processing
IF file not opened okay
   Write error message
   Return 1
Get a character
DO
   Process character
   Get a character
WHILE (more data)
   Output table
   Close files
Let’s incorporate the file processing within a separate module, which takes the name of the
file as a parameter.
PrepareFile (In/out: text)
Prompt for file name
Read file name
Open file
IF file not opened okay
   Write error message
   Return 1
Return
The next module is where the counters get incremented. The counters can be bound
together in a record (Counters) and passed as a parameter to the module, along with the
character.
IncrementCounters(In/out: counters, In: character)
Level 1

IF (isupper(character))
   Increment uppercaseCounter
ELSE IF (islower(character))
   Increment lowercaseCounter
ELSE IF (isdigit(character))
   Increment digitCounter
SWITCH (character)
   Case ‘ ’ : Increment blankCounter
   Case ‘.’ :
   Case ‘!’ :
   Case ‘?’ : Increment punctuationCounter
The last module calculates and outputs the percentages. Because the output goes to the
standard I/O device, only the record containing the counters is passed as a parameter.
Calculate and Print Percentages(In: counters)
Set Total to sum of 6 counters
Output ‘Percentage of uppercase letters:’, uppercaseCounter / Total * 100
Output ‘Percentage of lowercase letters:’, lowercaseCounter / Total * 100
Output ‘Percentage of decimal digits:’, digitCounter / Total * 100
Output ‘Percentage of blanks:’, blankCounter / Total * 100
Output ‘Percentage of end-of-sentence punctuation:’, punctuationCounter / Total * 100
Coding these modules is very straightforward. We show the declaration of the record and
the function prototypes here and leave the rest of the coding as an exercise. Note that
because the counters are encapsulated into a record named Counters, we remove the
word “Counter” from the variable names. Also, we need to add one more module: Initialize
Counters. This initialization could be done within main, but creating a separate function to
handle this task would be better style.

Description
QUICK CHECK
10.4.1 Can an anonymous user-defined type be a parameter in a function?
10.4.2 What is contained between the braces of a struct definition?
10.4.3 Which operator is used as the member selector of a struct?
10.4.4 When is memory allocated to a C++ struct?
1 Technically, a C++ struct type is almost identical to the class type that we introduce in
Chapter 12. However, in C a struct has the properties of a record, and most C++
programmers continue to use the struct in its traditional role of directly representing a record.
In this text we retain this standard practice.

10.5 Hierarchical Records
We have seen examples in which the components of a record are simple variables and
strings. A component of a record can also be another record. Records with components that
are also records are called hierarchical records.
Let’s look at an example in which a hierarchical structure is appropriate. Suppose a small
machine shop keeps information about each of its machines. These data include descriptive
information, such as the identification number, a description of the machine, the purchase
date, and the cost. They also include statistical information, such as the number of down
days, the failure rate, and the date of last service. What is a reasonable way of representing all
this information? First, let’s look at a flat (nonhierarchical) record structure that holds this
information.
Hierarchical record A record in which at least one of the components is itself a record.
Description
The MachineRec type has 11 members. There is so much detailed information here that it is
difficult to quickly get a feeling for what the record represents. We can reorganize it into a
hierarchical structure that makes more sense. Let’s divide the information into two groups:
information that changes and information that does not. There are also two dates to be kept:
date of purchase and date of last service. These observations suggest use of a record
describing a date, a record describing the statistical data, and an overall record containing the
other two as components. The following type declarations reflect this structure.

Description
The contents of a machine record are now clearer. Two of the components of type
MachineRec are themselves structs: purchaseDate is of struct type Date, and history is of
struct type Statistics. One of the components of struct type Statistics is, in turn, a struct
of type Date.
How do we access the components of a hierarchical structure such as this one? We build
the accessing expressions (member selectors) for the members of the embedded structs
from left to right, beginning with the struct variable name. Here are some expressions and the
components they access:
Expression
Component Accessed
machine.purchaseDate
Date struct variable
machine.purchaseDate.month
month member of a Date struct variable
machine.purchaseDate.year
year member of a Date struct variable
machine.history.lastServiced.year year member of a Date struct variable contained in a
struct of type Statistics

FIGURE 10.6 is a pictorial representation of machine with values. Look carefully at how each
component is accessed.
FIGURE 10.6 Hierarchical Records in machine Variable
Description
QUICK CHECK
10.5.1 What do we call a data structure that is implemented by a struct that contains
other struct types?
10.5.2 How would you write an expression to access the hour member of a struct
that is itself a member, called time, of a struct variable called date?
10.5.3 Why are hierarchical records useful?

10.6 Unions
In Figure 10.3, we presented a diagram showing the four structured types available in C++.
We have discussed struct types and now look briefly at union types.
In C++, a union is defined to be a struct that holds only one of its members at a time during
program execution. Here is a declaration of a union type and a union variable:
Description
The syntax for declaring a union type is identical to the syntax that we showed earlier for the
struct type, except that the word union is substituted for struct.
At run time, the memory allocated to the variable weight does not include room for three
components. Instead, weight can contain only one of the following: either a long value or an
int value or a float value. This union would be useful for a program that stores a weight value
that could be in ounces, pounds, or tons, where each requires a different data type. The
purpose of a union is to conserve memory by allowing different types of values to use the
same memory space at different times. The following code shows how weight might be used:
Description
After the last assignment statement, the previous float value 4.83 is gone, replaced by the
int value 35.
It can be argued that a union is not a data structure. It does not represent a collection of
values; it represents a single value from among several potential values. Nevertheless,
unions are grouped together with the structured types in C++ because of their similarity to
structs.
There is much more to be said about unions, including subtle issues related to their
declaration and usage. However, these issues are more appropriate in an advanced study of
data structures and systems programming. We have introduced unions here solely to

complete the picture of the C++ structured types and to acquaint you with the general idea in
case you encounter unions in other C++ programs.
In the previous sections, we looked at the simple types and structured types available in
C++. Now we have only two built-in data types left to cover: pointer types and reference types
(see FIGURE 10.7). These are simple data types, yet in Figure 10.7 we list them separately
from the other simple types because their purpose is so special. We refer to pointer types and
reference types as address types.
FIGURE 10.7 C++ Data Types
Description
A variable of one of these types does not contain a data value; it contains the memory
address of another variable or structure. Address types have two main purposes: They can
make a program more efficient—either in terms of speed or in terms of memory usage—and
they can be used to build complex data structures. It is the latter use that we emphasize here.
QUICK CHECK
10.6.1 What is a C++ union?
10.6.2 How much space is allocated to a union?
10.6.3 How does a C++ union conserve memory space?

10.7 Pointers
Pointers are what their name implies: variables that tell where to find something else. That is,
pointers contain the addresses or locations of other variables. Technically, a pointer type is a
simple data type that consists of a set of unbounded values, each of which addresses the
location of a variable of a given type.
Let’s begin this discussion by looking at how pointer variables are declared in C++.
Pointer type A simple data type consisting of an unbounded set of values, each of which
addresses or otherwise indicates the location of a variable of a given type. Among the
operations defined on pointer variables are assignment and testing for equality.
Pointer Variables
Surprisingly, the word “pointer” isn’t used in declaring pointer variables; the symbol * (asterisk)
is used instead. The declaration
states that intPtr is a variable that can point to (that is, contain the address of) an int
variable. Here is the syntax template for declaring pointer variables:
Description
This syntax template shows two forms, one for declaring a single variable and the other for
declaring multiple variables. In the first form, the compiler does not care where the asterisk is
placed; it can be placed either to the right of the data type or to the left of the variable. Both of
the following declarations are equivalent:
Although C++ programmers use both styles, we prefer the first. Attaching the asterisk to the
data type name instead of the variable name readily suggests that intPtr is of type “pointer to
int.”
According to the syntax template, if you declare several variables in one statement, you
must precede each with an asterisk. Otherwise, only the first is taken to be a pointer variable;

subsequent variables are not. To avoid unintended errors, it is safest to declare each pointer
variable in a separate statement.
Given the declarations
we can make intPtr point to beta by using the unary & operator, which is called the address-
of operator. At run time, the assignment statement
takes the memory address of beta and stores it into intPtr. Alternatively, we could initialize
intPtr in its declaration as follows:
Suppose that intPtr and beta happen to be located at memory addresses 5000 and 5008,
respectively. Then storing the address of beta into intPtr results in the relationship pictured in
FIGURE 10.8.
FIGURE 10.8 Machine-Level View of a Pointer Variable
Description

FIGURE 10.9 Graphical Representation of a Pointer
Description
Rather than use made-up numerical addresses to illustrate the relationships between
pointers and what they point to, in subsequent discussions, we use the common convention
of drawing them with rectangles and arrows, as illustrated in FIGURE 10.9. Keep in mind,
however, that whenever we draw a box with an arrow emerging from it, it represents a
variable containing a memory address. A box that has an arrowhead touching its exterior is a
pointed-to value.
To access a variable that a pointer points to, we use the unary * operator—the dereference
or indirection operator. The expression *intPtr denotes the variable pointed to by intPtr. In
our example, intPtr currently points to beta, so the statement
uses the address in intPtr to find beta and then stores the value 28 into beta. The step of
getting the address from intPtr and using it to locate beta is referred to as dereferencing
intPtr. This statement can also be described as doing indirect addressing of beta: The
machine first accesses intPtr, then uses its contents to locate beta. In contrast, the
statement
represents direct addressing of beta. Direct addressing is like opening a post office box
(P.O. Box 15, for instance) and finding a package, whereas indirect addressing is like opening
P.O. Box 23 and finding a note that says your package is sitting in P.O. Box 15.
It's important to be clear about this terminology. Dereferencing refers to the pointer and how
we use the address contained in it to find the thing it points to. Indirect addressing refers to the
pointed-to value and how we use the address from the pointer to access it. The term direct
addressing is just a new name we are giving to the familiar way we have accessed values up
to now, so we can distinguish it from the new technique of indirect addressing.
Continuing with our example, if we execute the statements
Indirect addressing Accessing a variable in two steps by first using a pointer that gives
the location of the variable.
Direct addressing Accessing a variable in one step by using the variable name.

Description
then the output is
The first output statement displays the contents of intPtr (5008); the second outputs the
contents of the variable pointed to by intPtr (28).
Pointers can point to any type of variable. For example, we can define a pointer to a struct
as illustrated here:
Description
The expression *patientPtr would then access patient. To access the members of
patient indirectly, via 
patientPtr, we use the expressions 
(*patientPtr).idNum,
(*patientPtr). height, and (*patientPtr).weight. Notice how the accessing expression is
built.
patientPtr
A pointer variable of type “pointer to a value of type PatientRec.”
*patientPtr
A struct variable of type PatientRec. In this case, patient.
(*patientPtr). weight
The weight member of the struct variable of type PatientRec.
The expression (*patientPtr).weight combines pointer dereferencing (*) and struct
member selection (.) operators. The parentheses in the expression are necessary because
the dot operator has higher precedence than the dereference operator. Without the
parentheses, the expression *patientPtr.weight would be interpreted incorrectly as *
(patientPtr. weight).
When a pointer points to a struct (or a class or a union) variable, enclosing the pointer
dereference within parentheses can become tedious. In addition to the dot operator, C++
provides another member selection operator: ->. This arrow operator consists of two
consecutive symbols: a hyphen and a greater-than symbol. By definition,
is equivalent to

As a consequence, we can write
Description
The general guideline for choosing between the two member selection operators (dot and
arrow) is the following: Use the dot operator if the first operand denotes a struct, class, or
union variable; use the arrow operator if the first operand denotes a pointer to a struct, class,
or union variable. That is, use the dot for direct addressing and the arrow for indirect
addressing.
Pointer Expressions
You learned in the early chapters of this text that an arithmetic expression is made up of
variables, constants, operator symbols, and parentheses. Similarly, pointer expressions are
composed of pointer variables, pointer constants, certain allowable operators, and
parentheses. We have already discussed pointer variables—variables that hold addresses of
other variables. Let’s look now at pointer constants.
In C++, there is only one literal pointer constant: the value 0. The pointer constant 0, called
the NULL pointer, points to absolutely nothing. The statement
Description
stores the NULL pointer into intPtr. This statement does not cause intPtr to point to memory
location zero. In C++, the NULL pointer is guaranteed to be distinct from any actual memory
address. Because the NULL pointer does not point to anything, we diagram the NULL pointer as
follows, instead of using an arrow to point somewhere:
Description
Rather than using the literal 0, many programmers prefer to use the named constant NULL,
as supplied by the standard header file cstddef:2
Description

As with any named constant, the identifier NULL makes a program more self-documenting. Its
use also reduces the chance of confusing the NULL pointer with the integer constant 0.
It is an error to dereference the NULL pointer, because it does not point to anything. The NULL
pointer is used only as a special value that a program can test for:
Description
We have now seen three C++ operators that are valid for pointers: =, *, and ->. In addition,
the relational operators may be applied to pointers. For example, we can ask if a pointer points
to anything with the following test:
Description
It is important to keep in mind that the operations are applied to pointers, not to the pointed-
to variables. For example, if intPtr1 and intPtr2 are variables of type int*, the test
compares the pointers, not the variables to which they point. In other words, we are
comparing memory addresses, not int values. To compare the integers that intPtr1 and
intPtr2 point to, we would need to write
QUICK CHECK
10.7.1 In declaring a pointer variable called compass that points to an int, there are two
ways that you can write the declaration in C++. What are they?
2 The C++ standard was recently amended with a new keyword, called nullptr, which will
eventually replace NULL. Because nullptr is a keyword, it is not necessary to include a header
file to use it.

10.8 Reference Types
According to Figure 10.7, there is only one built-in type remaining: the reference type. Like
pointer variables, reference variables contain the addresses of other variables. The statement
Reference type A simple data type consisting of an unbounded set of values, each of
which is the address of a variable of a given type. The only operation defined on a
reference variable is initialization, after which every appearance of the variable is implicitly
dereferenced. Unlike a pointer, a reference cannot be set to 0.
declares that intRef is a variable that can contain the address of an int variable. Here is the
syntax template for declaring reference variables:
Description
Although both reference variables and pointer variables contain addresses of data objects,
there are two fundamental differences between them. First, the dereferencing and address-of
operators (* and &) are not used to dereference reference variables. After a reference variable
has been declared, the compiler invisibly dereferences every single appearance of that
reference variable. If you were to use * or & with a reference variable, it would be applied
instead to the object that the variable references.

Description
Some programmers like to think of a reference variable as an alias for another variable. In the
preceding code, we can think of intRef as an alias for gamma. After intRef is initialized in its
declaration, everything we do to intRef is actually happening to gamma.
The second difference between reference and pointer variables is that the value of a
reference variable cannot be reassigned after being initialized; that is, we cannot make intRef
point to another variable. In this case, it will always point to gamma. Any attempt to change
intRef just assigns a new value to gamma. It should also be noted that a reference variable
cannot be initialized to 0 or NULL; a reference has to point to something that actually exists. In
contrast, a pointer can be set to NULL to indicate that it points to nothing.
By now, you have probably noticed that the ampersand (&) has several meanings in the
C++ language. To avoid errors, it is critical to recognize these distinct meanings. The following
table summarizes the different uses of the ampersand. Note that a prefix operator precedes
its operand(s), an infix operator lies between its operands, and a postfix operator comes after
its operand(s).
PositionUsage
Meaning
Prefix
&Variable
Address-of operation
Infix
Expression
&
Expression
Bitwise AND operation (See Appendix B)
Infix
Expression
&&
Expression
Logical AND operation
Postfix
DataType& Data type (specifically, a reference type) Exception: To declare two
variables of a reference type, the & must be attached to each variable
name: int & var1, &var2;

Problem-Solving Case Study
STYLISTIC ANALYSIS OF TEXT
PROBLEM: Earlier in this chapter, we rewrote the Rich Uncle case study program,
implementing the modules as functions. The Case Study Follow-Up Exercises to the
original program intrigued you, so you decide to change and enhance the program. Rather
than calculating percentages of groups of characters, you will just show counts. You also
will determine the average word length and the average sentence length. Because you
have just learned about enumerated types, you decide to redo the design using these
constructs.
DISCUSSION: The Case Study Follow-Up exercise answers in Chapter 7 suggest that
the number of new lines, punctuation marks, and blanks gives a good approximation to the
number of words. However, if any of these characters appear consecutively, only the first
should be counted as an end-of-word symbol. You can use a Boolean variable endOfWord
that is set to true when an end-of-word symbol is found. The word counter should be
incremented only when endOfWord is false, after which endOfWord is set to true. When an
alphanumeric character is read, endOfWord is set to false.
INPUT: Text on the file whose name is read from the keyboard.
OUTPUT: A table giving the file whose name is read from the keyboard, showing the
following values:
Description
The main and OpenFiles modules are almost the same as those for the revision in the
Software Maintenance Case Study. It is the IncrementCounters module that will change.
INCREMENT COUNTERS: In the Rich Uncle program, you used a combination of If and
Switch statements to determine to which category a character belonged. In the revised
program, you will use a Switch statement with case labels of an enumerated type. The
categories are uppercase, lowercase, digits, end-of-word, end-of-sentence, and ignore.

This module is where the endOfWord switch must be set. It should be set to false when it
is declared, set to true when an end-of-word symbol is found, and reset to false when an
alphanumeric character is found. For this process to work properly, endOfWord must be
marked as a static variable. Recall that a static variable is a local variable that maintains
its value from invocation to invocation.
IncrementCounters (In/out: counters, character)
Level 1
Set (static) endOfWord to false
SWITCH (Decode(character))
UPPER :
Increment counters.uppercase
Set endOfWord to false
LOWER :
Increment lowercase
Set endOfWord to false
DIGIT :
Increment digit
Set endOfWord to false
EOW :
IF NOT endOfWord
Increment word
Set endOfWord to true;
EOS:
Increment sentence
IGNORE:
Increment ignore
DECODE: This module takes a character and returns the enumerated type for the
category into which it falls. We can use part of the algorithm from the original version,
adding the code for the end of a word and the end of a sentence.
Decode(In: character)
Out: function value—Features
IF isupper(character)
Return UPPER
ELSE IF islower(character)
Return LOWER
ELSE IF isdigit(character)
Return DIGIT
ELSE
SWITCH (character)
‘.’ :
‘?’ :
‘!’ : return EOS
‘ ‘ :
‘,’ :
‘;’ :
‘:’ :
‘\n’ : return EOW;

Return IGNORE;
Notice that a Switch statement can be used in the last else clause because characters
can be used as case labels. If neither of the first two are matched, control flows into the
third case, which has a return beside it that causes execution to jump to the end of the
Switch statement. The same is true of the fourth through seventh case labels, which flow
through into the last case label, which has a return beside it.
As you look at this algorithm, you realize that the end-of-sentence markers are also
endof-word markers! Yet, you also want to keep the counts separate. You decide to take
care of this problem in module CalculateAndPrint by adding the number of sentences to
the number of words.
CalculateAndPrint (In/out: table, In: counters)
Level 1
Set totalAlphaNum to counters.uppercase + counters.lowercase + counters.digit
Output on table “Total number of alphanumeric characters: ” totalAlphaNum
Output on table “Number of uppercase letters: ” counters.uppercase
Output on table “Number of lowercase letters: ” counters.lowercase
Output on table “Number of digits: ” counters.digit
Output on table “Number of characters ignored: ” counters.ignore
Set counters.word to counters.word + counters.sentence
Output on table “Number of words: ” counters.word
Output on table “Number of sentences: ” counters.sentence
Output on table “Average word length: ” float(totalAlphaNum)/counters.word
Output on table “Average sentence length: ” float(counters.word)/counters.sentence
“CalculateAndPrint” is a little long. Let’s call the function PrintTable instead.
MODULE STRUCTURE CHART
Description

Description


Description


Description
Description
TESTING: Let’s take a sample of text, calculate the statistics by hand, and compare the
results with the output from the program.
Input
Description
Expected Results
Total number of alphanumeric characters:
527
Number of uppercase letters:
15
Number of lowercase letters:
512

Number of digits:
0
Number of characters ignored:
5 (two pairs of parentheses and a hyphen)
Number of words:
96
Number of sentences:
5
Average word length:
5.489
Average sentence length:
19.2
Output from the Program
Description
The number of words, average word length, and average sentence length are wrong.
You recount the number of words and again come up with 96. You took care of the case
where end-of-sentence markers end words by adding the number of sentences to the
number of words. But endOfWord wasn’t reset when end-of-sentence markers were found.
You correct the problem in function ProcessCharacter like this:
Description
When you rerun the program, you get this output:
Description

The number of words is still off by one. Now you see it. You counted “gear-driven” as
two words; the program counts it as one. You are asked to examine a solution to this
problem in the Case Study Follow-Up Exercises.

Graphical User Interface (GUI)
The changes we need to make to the stylistic analysis program to incorporate a GUI are
small. The original program asked the user to enter an input file. Likewise, it generated the
analysis of that input file to the screen as text output. Thus, refactoring this program to use a
graphical interface requires us to replace the console input and output. Fortunately, we have
already seen both GUI widgets that enable us to make these changes. In particular, we can
use a FileDialog to choose a file and an OutputDialog to display the analysis.
As we have done in our GUI programs from previous chapters, we first include the
necessary header files:
Description
The dialog.h header file includes the definition of all our GUI widgets and the sstream allows
us to create ostringstream objects. If you recall from previous chapters, we use the
ostringstream objects to record output for our GUI components using the same interface as
the standard cout output stream object.
To capture output for our GUI we need to change the heading for any function that produced
output in the original program to now take an ostringstream reference as a parameter. This
includes the OpenFile and PrintTable prototype declarations and function definitions. In
addition to replacing cout with a string output stream, we also change OpenFile to use a
FileDialog instead of cin. Here is a summary of these changes:

Description

Description
The only additional changes needed are to declare an ostringstream object in the main
function, pass that object to our calls to OpenFile and PrintTable, and create an OutputDialog
GUI component to display the analysis results to the user. After these changes are made, we
have successfully converted our text analysis console-based program into a graphical
program. Here is what the analysis output looks like in our GUI:
Description
The full GUI version of the program is listed below, with the changes highlighted.
Description

Description


Description

Description
Description

Testing and Debugging
Coping with Input Errors
Several times, we’ve had our programs test for invalid data and write error messages for
incorrect input. Writing an error message is only the first step in handling errors. We must also
decide what the program should do next. The problem itself and the severity of the error
determine the action taken in any error condition.
In a program that reads its data only from an input file, there is no interaction with the person
who entered the data. The program, therefore, should try to account for the bad data items, if
at all possible.
If an invalid data item is not essential, the program can skip it and continue; for example, if a
program averaging test grades encounters a negative score, it could simply skip it. If there is
a default value for replacing bad input, it can be set to that value before being processed. In
either event, a message should be output stating that invalid data were encountered and how
they were handled. Such messages form an exception report.
If the data item is essential and default is specified, processing should stop. A message
should be output containing as much information as possible about the invalid data.
In an interactive environment, we can prompt the user to supply another value. The
program should indicate what is wrong with the original data. Another possibility is to list a set
of actions and ask the user to choose one.
These suggestions on how to handle bad data assume that the program recognizes bad
data values. There are two approaches to error detection: passive and active. Passive error
detection leaves it to the system to detect errors. This may seem easier, but the programmer
relinquishes control of processing when an error occurs. An example of passive error
detection is the system’s division-by-zero error.
Active error detection means that the program checks for possible errors and determines
an appropriate action if an error occurs. An example of active error detection would be to read
a value and use an If statement to see if the value is 0 before dividing it into another number.
Debugging with Pointers
Programs that use pointers are more difficult to write and debug than programs without
pointers. Indirect addressing never seems quite as “normal” as direct addressing when you
want to get at the contents of a variable.
Two errors commonly associated with the use of pointer variables are as follows:
1. Confusing the pointer variable with the variable it points to
2. Trying to dereference the NULL pointer or an uninitialized pointer
Let’s look at each of these potential problems in turn.
If ptr is a pointer variable, care must be taken not to confuse the expressions ptr and *ptr.
The expression

accesses the variable ptr (which contains a memory address). The expression *ptr
accesses the variable that ptr points to.
ptr1 = ptr2 Copies the contents of ptr2 into ptr1.
*ptr1 =
*ptr2
Copies the contents of the variable pointed to by ptr2 into the variable pointed to
by ptr1.
*ptr1 =
ptr2
Illegal—one is a pointer and one is a variable being pointed to.
ptr1 =
*ptr2
Illegal—one is a pointer and one is a variable being pointed to.
The second common error is to dereference NULL or an uninitialized pointer. On some
systems, an attempt to dereference the NULL pointer produces a run-time error message such
as NULL POINTER DEREFERENCE, followed immediately by termination of the program. When this
event occurs, you have at least some notion of what went wrong. The situation is worse,
though, if your program dereferences an uninitialized pointer. In the code fragment
Description
Description
the variable intPtr has not been assigned any value before we dereference it. Initially, it
contains some meaningless value such as 315988, but the computer does not know that it is
meaningless. The machine simply accesses memory location 315988 and copies whatever it
finds there into num. There is no way to test whether a pointer variable contains an undefined
value. The only advice we can give for avoiding this problem is to check the code carefully to
make sure that every pointer variable is assigned a value before being dereferenced.
Testing and Debugging Hints
1. Avoid using unnecessary side effects in expressions. The test

Description
is less clear and more prone to error than the equivalent sequence of statements
Description
Also, if you accidentally omit the parentheses around the assignment operation, like this:
Description
then, according to C++ operator precedence, x is not assigned the value of y. Instead, it is
assigned the value 1 or 0 (the coerced value of the Boolean result of the relational expression
y < z).
2. If your program increases the value of a positive integer and the result suddenly
becomes a negative number, you should suspect integer overflow. On most computers,
adding 1 to INT_MAX yields INT_MIN, a negative number.
3. Consider using enumeration types to make your programs more readable,
understandable, and modifiable.
4. Avoid anonymous data typing. Give each user-defined type a name.
5. Enumeration type values cannot be input or output directly.
6. The declaration of a struct type must end with a semicolon.
7. Be sure to specify the full member selector when referencing a component of a struct
variable or class object.
8. To declare two pointer variables in the same statement, you must use
Description
You cannot use
Description
Similarly, you must use

Description
to declare two reference variables in the same statement.
9. Do not confuse a pointer with the variable to which it points.
10. Before dereferencing a pointer variable, be sure it has been assigned a meaningful
value other than NULL.
11. Pointer variables must be of the same data type to be compared or assigned to one
another.

Summary
A data type is a set of values (the domain) along with the operations that can be applied to
those values. Simple data types are data types whose values are atomic (indivisible).
The integral types in C++ are char, short, int, long, and bool. The most commonly used
integral types are int and char. The char type can be used for storing small (usually one-
byte) numeric integers or, more often, for storing character data. Character data include
both visible and nonvisible characters.
C++ allows the programmer to define additional data types. The Typedef statement is a
simple mechanism that just renames an existing type. In contrast, an enumeration type,
which is created by listing the identifiers that make up the domain, is a new data type.
Values of an enumeration type may be assigned, compared in relational expressions, used
as case labels in a Switch statement, passed as arguments, and returned as function
values. Enumeration types are extremely useful in the writing of clear, readable programs.
In addition to being able to create user-defined atomic data types, we can create
structured data types. In a structured data type, a name is given to a group of
components. With many structured types, the group can be accessed as a whole, or each
individual component can be accessed separately.
A record is a data structure for grouping together heterogeneous data—that is, data
items that are of different types. Individual components of a record are accessed by name.
In C++, records are referred to as structures or simply structs. We can use a struct
variable to refer to the struct as a whole, or we can use a member selector to access any
individual member (component) of the struct. Entire structs of the same type may be
assigned directly to each other, passed as arguments, or returned as function return
values. Comparison, reading, and writing of structs, however, must be done member by
member.
Pointer and reference types are simple types for storing memory addresses. Variables
of these types contain the addresses of other variables or data structures. Pointer
variables require explicit dereferencing using the * operator. Reference variables are
dereferenced implicitly.

Quick Check Answers
10.1.1 It is an integral type. 10.1.2 The domain of each type is made up of indivisible, or
atomic, data values. 10.1.3 The machine the C++ program is executing on. 10.1.4 ASCII;
256 10.1.5 Unicode 10.1.6 The external representation is what you see when it is output.
The internal representation is the numeric code used by the computer to represent the
character. 10.2.1 enum Seasons {SPRING, SUMMER, WINTER, AUTUMN}; 10.2.2 for (quarter =
SPRING; quarter <= AUTUMN; quarter = static_cast<Seasons>(quarter + 1)) 10.2.3 It is
used to introduce a new name for an existing type. 10.2.4 A named data type is associated
with a name as part of its declaration and can be used by any number of subsequent
declarations. An anonymous data type is used only once and is included directly in a
variable declaration. 10.3.1 Structured data types. 10.3.2 Array, struct, union, and class.
10.4.1 No. 10.4.2 A list of the members of the struct. 10.4.3 The dot (period). 10.4.4 When
you declare a variable of the type of the struct. 10.5.1 A hierarchical record. 10.5.2
date.time.hour 10.5.3 They help organize the information they represent, making it easier
to understand. 10.6.1 A C++ union is defined to be a struct that holds only one of its
members at a time during program execution. 10.6.2 The maximum of the union’s
members. 10.6.3 By allowing a type to have values of different types at different times,
avoiding the need to allocate storage for all of the different types at once. 10.7.1 int*
compass; int *compass;

Exam Preparation Exercises
10.1 All of the integral types in C++ can be signed or unsigned. True or false?
10.2 The sizeof operator can be used to determine whether a machine’s int type is
32 or 64 bits long. True or false?
10.3 Floating-point numbers are seldom exactly equal. True or false?
10.4 The values of enumerator types must be written in uppercase letters. True or
false?
10.5 What are the five integral types in C++?
10.6 What is wrong with the following pair of enumeration type declarations?
Description
10.7 Given the declaration of Colors in Exercise 10.6, what is the value of the
expression (YELLOW + 1)?
10.8 Given the code segment:
Description
Why does the compiler give an invalid type error message for the last line?
10.9 Why is it impossible to use an anonymous type with a function parameter?
10.10 A struct cannot have another struct as a member. True or false?
10.11 A union is a struct that can hold just one of its members at a time. True or
false?
10.12 Given the following declarations:

Description
What are the contents of the two Name variables after each of the following statements,
assuming they are executed in the order listed?
Description
10.13 What are the three aggregate operations allowed on structs?
10.14 How does a union differ from an enumeration type?
10.15 Given the declaration of the Name type in Exercise 10.12 and the following
declarations:
Description
a. How would you assign the name Sally Ellen Strong to the studentName field of
variable sally?
b. How would you assign the grade number 7 to that field of sally?

c. How would you assign the fourth letter from the grades field to the char variable
spring?
10.16 What happens when a struct is passed as an argument to a value parameter of
a function? How does this differ from passing it to a reference parameter?
10.17 Given the following union declaration:
Description
What does each of the following statements do, assuming they are executed in the order
shown?
Description
10.18 Assigning the value NULL to a pointer causes it to point to nothing. True or false?
10.19 A reference variable can be reassigned a new address value at any time. True
or false?

Programming Warm-Up Exercises
10.1 Declare an enumeration type consisting of the eight planets in their order by
distance from the Sun (Mercury first, Neptune last).
10.2 Write a value-returning function that converts the name of a planet given as a
string parameter to a value of the enumeration type declared in Exercise 10.1. If the
string isn’t a proper planet name, return “EARTH”.
10.3 Write a value-returning function that converts a planet of the enumeration type
declared in Exercise 10.1 into the corresponding string. The planet is an input
parameter, and the string is returned by the function. If the input is not a valid planet,
return “Error”.
10.4 Write a For statement that outputs the names of the planets in order, using the
enumeration type declared in Exercise 10.1 and the function declared in Exercise
10.3.
10.5 Declare a struct type, Time, that represents an amount of time consisting of
minutes and seconds.
10.6 Write statements that assign the time 6 minutes and 54 seconds to a variable,
someTime, of type Time, as declared in Exercise 10.5.
10.7 Declare a struct type, Song, that represents a song entry in an MP3 library. It
should have fields for title, album, artist, playing time in minutes and seconds (use the
type declared in Exercise 10.5), and music category. The music category is
represented by an enumeration type called Category.
10.8 Write statements to declare a variable called mySong of type Song, and assign it a
set of values. For the playing time, use the variable someTime declared in Exercise
10.6. Make up values for the other fields. Assume that the enumeration type Category
includes any song category that you wish to use.
10.9 Write a statement to output the playing time from mySong, as declared in Exercise
10.8, in the format mm:ss.
10.10 Write a declaration of a union type called Temporal that can hold a time
represented as a string, as an integer, or as a value of type Time, as declared in
Exercise 10.5.
10.11 Write the declaration of a variable called shift of type Temporal, as declared in
Exercise 10.10, and a statement that assigns the value of someTime, as declared in

Exercise 10.6, to shift.
10.12 Declare a pointer variable intPointer and initialize it to point to an int variable
named someInt. Write two assignment statements, the first of which stores the value
451 directly into someInt and the second of which indirectly stores 451 into the variable
pointed to by intPointer.

Programming Problems
10.1 Programming Problem 5.4 asked you to write a C++ program that asks the user
to enter their weight and the name of a planet. In Programming Problem 7.2 asked
you to rewrite the program using a Switch statement. Now, rewrite the program so it
uses an enumerated type to represent the planet.
For ease of reference, the information for the original problem is repeated here. The
following table gives the factor by which the weight must be multiplied for each planet. The
program should output an error message if the user doesn’t input a correct planet name.
The prompt and the error message should make it clear to the user how a planet name
must be entered. Be sure to use proper formatting and appropriate comments in your
code. The output should be labeled clearly and formatted neatly.
Mercury
0.4155
Venus
0.8975
Earth
1.0
Moon
0.166
Mars
0.3507
Jupiter
2.5374
Saturn
1.0677
Uranus
0.8947
Neptune
1.1794
10.2 Programming Problem 7.3 asked you to write a program that generates sales-
report files for a set of traveling salespeople. In the original problem, we used an
integer in the range of 1 through 10 to represent ID numbers for the salespeople.
Rewrite the program so that it uses an enumeration type whose values are the names
of the salespeople (you can make up the names). The sales file format should replace
the salesperson ID number with a string that is the person’s last name, so that a line
of the file contains a name, an item number, and a quantity. For convenience, the
other information concerning the problem is repeated here. The company sells eight
different products, with IDs numbered 7 through 14. (Some older products have been
discontinued.) The unit prices of the products are given here:
Product
Number Unit Price
7
345.00

8
853.00
9
471.00
10
933.00
11
721.00
12
663.00
13
507.00
14
259.00
The program reads in the sales file and generates a separate file for each salesperson
containing just their sales. Each line from the sales file is copied to the appropriate
salesperson’s file, with the salesperson’s name omitted. The file names should be the
name of the salesperson with .dat appended. (You may have to adjust names that don’t
work as file names on your computer, such as hyphenated names or names with
apostrophes.) The total for the sale (quantity times unit price) is then appended to the
record. At the end of processing, the total sales for each salesperson should be output with
informative labels to cout. Use functional decomposition to design the program. Make sure
that the program handles invalid salespersons’ names. If a salesperson’s name is invalid,
write out an error message to cout. If a product number is invalid, write the error message
to the salesperson’s file and don’t compute a total for the sale.
10.3 You are taking a geology class, and the professor wants you to write a program
to help students learn the periods of geologic time. The program should let the user
enter a range of prehistoric dates (in millions of years), and then output the periods
that are included in that range. Each time this output is done, the user is asked if they
want to continue. The goal of the exercise is for the student to try to figure out when
each period began, so that they can make a chart of geologic time.
Within the program, represent the periods with an enumeration type made up of their
names. You will probably want to create a function that determines the period
corresponding to a date, and another function that returns the string corresponding to each
identifier in the enumeration. Then you can use a For loop to output the series of periods in
the range. The periods of geologic time are given here:
Period Name
Starting Date (millions of years ago)
Neogene
23
Paleogene
66
Cretaceous
145
Jurassic
201
Triassic
252
Permian
299
Carboniferous
359

Devonian
419
Silurian
444
Ordovician
485
Cambrian
541
Precambrian
4500 or earlier
Use functional decomposition to solve this problem. Be sure to use good coding style and
documenting comments. The prompts and error messages that are output should be clear
and informative.
10.4 The educational program that you wrote for Problem 10.3 was a big success.
Now the geology professor wants you to write another program to help teach geologic
time. In this program, the computer picks a date in geologic time and presents it to the
student. The student then guesses which period corresponds to the date. The student
is allowed to continue guessing until they get the right answer. Then the program asks
the student whether they want to try again and repeats the process if the answer is
“yes.” To solve this problem, you should again use an enumeration type consisting of
the names of the periods. In this case, you’ll probably want to make a function that
returns the period corresponding to a string containing the name of a period. (The
program should work with any style of capitalization of the names.) You also may
want a function that returns the period for a given date.
Use functional design to solve this problem. Be sure to use good coding style and
include helpful documenting comments. The prompts and error messages that are output
should be clear and informative. You may want to add some interest to the program by
keeping track of the number of guesses taken by the user and offering differing levels of
praise and encouragement depending on how well the user is doing.
10.5 Write a C++ program that determines the largest number for which your
computer can represent its factorial exactly using the longdouble type. A factorial is
the product of all numbers from 1 to the given number. For example, 10 factorial
(written 10!) is
1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 × 9 × 10 = 3,628,800
As you can see, the factorial grows to be a large number very quickly. Your program
should keep multiplying the prior factorial by the next integer, then subtract 1 and check
whether the difference between the factorial and the factorial minus 1 is less than 1—an
error tolerance. When the maximum precision of the type is reached, and least significant
digits are truncated to allow the most significant digits of the product to be stored, then
subtracting 1 should have no effect on the value. Because floating-point representations
may not be exact, however, the expression

Description
may not exactly equal 1. That’s why you need to include a small error tolerance in the
comparison.
Use functional decomposition to solve this problem. Code the program using good style
and include helpful documenting comments. To keep the user informed of progress, you
may wish to output all of the intermediate factorial values. The greatest number and its
factorial should be clearly labeled.

Case Study Follow-Up
1. How could you determine whether a hyphen should be counted as an end-of-word
symbol or a break in the word due to spacing issues?
2. Implement the change outlined in your answer to Exercise 1.
3. The endOfWord variable is reset to false every time an alphanumeric character is
read. Thus it is set to itself over and over again. Can you think of a scheme that would
allow you to set it only once?
4. Should error detection be added to program Style? Explain.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  11
Arrays
KNOWLEDGE GOALS
To understand the structure of a one-dimensional array.
To know how to use a one-dimensional array in solving a problem.
To understand the structure of arrays of records.
To know how index values can be chosen to have semantic content.
To understand the structure of a two-dimensional array.
To understand the structure of a multidimensional array.
SKILL GOALS
To be able to:
Declare a one-dimensional array, with and without initialization.
Perform fundamental operations on one-dimensional arrays.
Apply subarray processing to a one-dimensional array.
Declare a two-dimensional array.
Perform fundamental operations on a two-dimensional array.
Use arrays as parameters and arguments.
Declare and process a multidimensional array.
Data structures are important in the design process because they determine the algorithms
used to process data. In Chapter 10, we saw how the record (struct) let us refer to a group of
components by name, which simplifies the design of many programs.
In many problems, however, a data structure has so many components that it would be
infeasible to give each one a unique name. For example, suppose we needed to represent the
male and female population figures for all 50 states. If we used a struct, we would need 100
different member names. Then we would have to write 100 input statements and 100 output

statements to read and display them—an incredibly tedious task! An array—the third of the
structured data types supported by C++—allows us to easily program operations of this kind.

11.1 One-Dimensional Arrays
If we want to input 1000 integer values and output them in reverse order, we could write a
program of this form:
Description

This program is more than 3000 lines long and uses 1000 variables. Note that all the
variables have the same name except for an appended number that distinguishes them.
Wouldn’t it be convenient if we could put the number into a counter and use For loops to go
from 0 through 999, and then from 999 back down to 0? For example, if the counter is number,
we can replace the 2000 original input/output statements with the following four lines of code
(where highlighted below, we enclose number in brackets to set it apart from value):
Description
This code fragment is correct in C++ if we declare value to be a one-dimensional array. A
one-dimensional array is a collection of values, all of the same type. The array variable name
is followed by an index value enclosed in square brackets. In our example, the value stored in
number is called the index.
The declaration of a one-dimensional array variable specifies the data type of the values in
the array, the name of the variable, and the size of the array—that is, the number of values it
can hold. For example:
This declaration creates an array called value with 1000 components, all of type int. The first
component has index 0, the second component has index 1, and the last component has
index 999.
Here is the ReverseNumbers program, using array notation. It is certainly much shorter
than our first version.
Description

Here is the input and the output for a version of the program with an array size of 10, to
save space:
Description
As a data structure, an array differs from a struct in two fundamental ways:
1. An array is a homogeneous data structure (its components are all the same data type),
whereas a struct is heterogeneous (its components may be of different types).
2. An array component is accessed by position, whereas a struct component is accessed
by a member name.
Let’s now define arrays formally and look at the rules for accessing individual components.
Declaring Arrays
A one-dimensional array is a structured collection of components (often called array
elements) accessed individually by specifying the position of a component with an index
value.
One-dimensional array A structured collection of components, all of the same type, that
is given a single name. Each component (array element) is accessed by an index that
indicates the component’s position within the collection.

Here is a syntax template describing the simplest form of a one-dimensional array
declaration:
In the syntax template, DataType describes what is stored in each component of the array.
Array components may be of almost any type, but for now we limit our discussion to atomic
components.
Description
FIGURE 11.1 angle and testScore Arrays
In the syntax template, ConstIntExpression is an integer expression composed only of
literal or named constants. This expression, which specifies the number of components in the
array, must have a value greater than 0. If the value is n, the range of index values is 0
through n − 1, not 1 through n. For example, the declarations

create the arrays shown in FIGURE 11.1. The angle array has four components, each
capable of holding one float value. The testScore array has a total of 10 components, all of
type int.
Accessing Individual Components of an Array
As we have seen, to access an array component, we write the array name followed by an
expression in square brackets. The expression specifies the component to access.
The index expression may be as simple as a constant or as complex as a combination of
variables, operators, and function calls, as long as it results in an integer value. Index
expressions can be of type char, short, int, long, or bool, because these are all integral
types. Additionally, values of enumeration types can be used as index expressions, with an
enumeration value implicitly being coerced to an integer.
FIGURE 11.2 angle Array with Values
Description
The simplest form of index expression is a constant. Using our angle array, the sequence of
assignment statements
Description
fills the array components one at a time (see FIGURE 11.2).
Each angle array component—angle[2], for instance—can be treated exactly the same
way as a variable of type float. For example, we can do the following to angle[2]:

Description
Now let’s look at more complicated index expressions. Returning to our 1000-element value
array:
We can execute these two statements:
Description
In the first statement, 5 is stored into an array component. If counter is 0, 5 is stored into the
first component of the array. If counter is 1, 5 is stored into the second component, and so
forth.
In the second statement, the expression number+1 selects an array component. The specific
array component accessed is divided by 10 and checked to see if the remainder is nonzero. If
number+1 is 0, we are testing the value in the first component; if number+1 is 1, we are testing
the second component; and so on. FIGURE 11.3 shows the index expression as a constant,
a variable, and a more complex expression.

FIGURE 11.3 An Index as a Constant, a Variable, and an Arbitrary Expression
Description
In earlier chapters, we saw how the string class allows us to access an individual character
within a string:
Description
Although string is a class (not an array), it was written using the advanced C++ technique
of operator overloading to give the [] operator another meaning (string component selection)
in addition to its standard meaning (array element selection). Because of this, we can use the
same syntax to access a character in a string as if it was an element in an array of
characters. For example, the following two statements output the same thing:
Description

Even though C++ supports this syntax, we recommend using at because it checks
whether the requested position exists within the string. Accessing a string with array index
notation doesn’t perform this check.
Out-of-Bounds Array Indexes
Given the declaration
the valid range of index values is 0 through 99. What happens if we execute the statement
when i is less than 0 or greater than 99? A memory location outside the array is accessed.
C++ does not check for invalid (out-of-bounds) array indexes. If i happens to be 100 in the
preceding statement, the computer puts 62.4 into the next memory location past the end of
the array, destroying whatever was previously there. It is your responsibility to make sure that
the index expression stays within the array. Out-of-bounds accesses can produce errors that
are extremely hard to debug and can also open up opportunities for security breaches of
online systems.
Out-of-bounds array index An index value that, in C++, is either less than 0 or greater
than the array size minus 1.
Array-processing algorithms often use For loops to step through the elements one at a time.
Here is a loop to zero out our 100-element alpha array (i is an int variable):
Description
We could also write the first line as
However, C++ programmers typically prefer to use the first version so that the number in the
loop test (100) is the same as the array size. With this pattern, always remember to test for
less-than, not less-than-or-equal.
The following program shows what happens when you access places beyond the array
bounds.

Description
Output:
Description
The first four values are the ones stored by the program. The next two are whatever was in
the two memory locations beyond the array.
Initializing Arrays in Declarations
You learned in Chapter 8 that C++ allows you to initialize a variable in its declaration:
You also can initialize an array in its declaration by using a list of values separated by
commas and enclosed within braces:
In this declaration, age[0] is initialized to 23, age[1] is initialized to 10, and so on. If you list too
many values, the compiler outputs an error message. If you list too few, the remaining
elements are initialized to zero.

Arrays follow the same rule as simple variables about the time(s) at which initialization
occurs. A static array (one that is either global or declared as static within a block) is
initialized once only, when control reaches its declaration. An automatic array (one that is local
and not declared as static) is reinitialized each time control reaches its declaration.
You are also allowed to omit the size of an array when you initialize it in a declaration:
The compiler determines the size of the array (here, 3) based on how many values are listed.
(Lack of) Aggregate Array Operations
In Chapter 10, we defined an aggregate operation as an operation on a data structure as a
whole. Some programming languages allow aggregate operations on arrays, but C++ does
not. If one and two are declared as
there is no aggregate assignment of two to one:
To copy array two into array one, you must do it element by element:
Description
Similarly, there is no aggregate I/O of arrays:1
s
Nor is there aggregate arithmetic on arrays:
Comparison of arrays is possible, but it doesn’t do what you expect:
Rather than comparing the values stored in the two arrays, this statement checks whether the
arrays are stored at the same address in memory. Similarly, attempting to return an array as
the value of a value-returning function passes back the memory address of the first element
of the array:

The only thing you can do to an array as a whole is to pass it as an argument to a function:
Passing an array as an argument gives the function access to the entire array. The following
table compares arrays and structs with respect to aggregate operations.
Aggregate Operation
Arrays
Structs
I/O
No (except C strings)
No
Assignment
No
Yes
Arithmetic
No
No
Comparison
No
No
Argument passage
By reference
By value or by reference
Return as a function’s return value
No
Yes
Later in this chapter, we look in detail at the process of passing arrays as arguments.
Examples of Declaring and Accessing Arrays
Let’s look at some examples of declaring and accessing arrays. Here are some declarations
that a program might use to analyze occupancy rates in an apartment building:
Description
Here occupants is a 350-element array of integers (see FIGURE 11.4). occupants[0] = 3 if the
first apartment has three occupants; occupants[1] = 5 if the second apartment has five; and
so on. The following code totals the number of occupants in the building:

FIGURE 11.4 occupants Array
Description
Description
The first time through the loop, counter is 0. We add the contents of occupants[0] to
totalOccupants, storing the result back into totalOccupants. Next, the value of counter
becomes 1 and we add occupants[1] to totalOccupants. Eventually, the loop adds
occupants[349] to the sum and control exits the loop.
Note how we used the named constant BUILDING_SIZE in both the array declaration and the
For loop. Using a constant in this manner simplifies changes. If the number of apartments
increases to 400, we need to change only the declaration of BUILDING_SIZE. If we had used the
literal value 350 in place of BUILDING_SIZE, we would need to look for and update every
statement that uses 350.
The following program uses the occupants array. It fills the array with data from a file and
then lets the user interactively look up the number of occupants in an apartment.

Description
Description
Look closely at the last output statement in this program. The user enters an apartment
number (apt) in the range 1 through BUILDING_SIZE, but the array has indexes 0 through

BUILDING_SIZE − 1. Therefore, we subtract 1 from apt to ensure that the index refers to the
proper place in the array.
The constant BUILDING_SIZE was changed to 10 for the following test run.
Input on apt.dat: 3 4 0 3 4 1 1 2 3 2
Output:
Description
FIGURE 11.5 salesAmt Array
Description
Because an array index is an integer value, using an int index is a common way of working
with an array. C++, however, provides more flexibility by allowing an index to be of any integral
or enumeration type. Here we see an example of indexing with an enumeration type:

Description
The enumerators in type Drink (ORANGE, COLA, . . . , LEMON) are internally represented by 0
through 5. salesAmt is an array of six float components representing sales figures for each
kind of drink (see FIGURE 11.5). The following code outputs the values in the array:
Description
Here is another example:
Description
The grade array is pictured in FIGURE 11.6. Values are shown in the components, as if some
processing of the array has already occurred. Following are some simple examples showing
how the array might be used:
Reads the next nonwhitespace character from the input
stream and stores it into the component in grade indexed by 2.
Assigns the character ‘A’ to the component in grade indexed
by 3.
Assigns 5 to the index variable idNumber.
Assigns the character ‘C’ to the component of grade indexed
by idNumber (that is, by 5).
Loops through the grade array, showing each component. For
this loop, the output would be FBCAFCAACB.
Loops through grade, showing components in a more
readable form.

FIGURE 11.6 grade Array Filled with Values
In the last example, idNumber is used as the index, but it also has semantic content—it is the
student’s identification number. Here is the output of executing the code:
Description
Here is one last example. Suppose we want to count the occurrences of characters in
some text. We can set up an array with 26 elements, where each element is a counter for one
letter in the alphabet (uppercase or lowercase). Because a value of type char is an integral
value, it can be used as an index. But the value of ‘A’ isn’t 0. So how can we use it to index the
first element of the array?
Recall that in ASCII (or Unicode) the uppercase letters are in order and the lowercase
letters are in order. If we subtract ‘A’ from any uppercase letter, we get the letter’s position in
the collating sequence. Likewise, if we subtract ‘a’ from any lowercase letter, we get its
position in the collating sequence. That is,

FIGURE 11.7 counters Array
Description
Description
We can read a character and, if it is a letter, convert it to uppercase and use the result of
subtracting 'A' from it as an index into the array of counters. See FIGURE 11.7.
Here is the program that uses the array to count the letters in a file of text. The output is
based on the data for the Rich Uncle program in Chapter 7.

Description
Description

Output (in four columns to save space):
Description
Notice that the index has to be converted back to a character before it is output. This
conversion is the reverse of the original operation: The letter 'A' is added to the index and the
result cast back to a character.
Passing Arrays as Arguments
In Chapter 8, we said that a variable should be passed to a function by value instead of by
reference, unless the function needs to change the argument. We specifically excluded
stream variables (such as files) from this rule and noted that one more exception would be
discussed later. Now we can reveal that arrays are the exception.
By default, C++ simple variables are always passed by value. To pass a simple variable by
reference, you must append an ampersand (&) to the data type name in the function’s
parameter list:
Description
In C++, arrays are always passed by reference.2 Therefore, you should never use & when
declaring an array as a parameter. When an array is passed as an argument, its base
address—the memory address of the first element of the array—is sent to the function. The
function then knows where the caller’s actual array is located and can access any element of
the array.
Base address The memory address of the first element of an array.
Here is a C++ function that will zero out a one-dimensional int array of any size:

Description
In the parameter list, the declaration of intArray does not include a size. If it is specified, the
compiler ignores it. Recall that C++ doesn’t do bounds checking, so it doesn’t care about the
size. Therefore, we need to include a second parameter—the number of array elements—to
provide the termination condition of the For loop.
Calling code can invoke ZeroOut for an int array of any size. The following code fragment
zeroes out two arrays of different sizes. Notice how an array parameter is declared in a
function prototype.
Description
Description
Keep in mind that within a function, an array parameter is simply a variable holding the
address of the first element of the argument array. The array argument in the call gives its
address to the array parameter, causing it to refer to that array. The call is not copying the
array’s elements. It’s a common mistake to forget this distinction.
With simple variables, we use pass-by-value to prevent a function from modifying the
caller’s argument. Although arrays are not passed by value in C++, you can still achieve the
same effect. To do so, you use the reserved word const in the declaration of the parameter.
Following is a function that copies one int array into another. The first parameter—the
destination array—is expected to be modified; the second array is not.

Description
Using const ensures that any attempt to modify the source array by the Copy function results in
a compile-time error. The following table summarizes argument passage for simple variables
and one-dimensional arrays:
Argument
Parameter Declaration for a Pass
by Value
Parameter Declaration for a Pass by
Reference
Simple
variable
int cost
int& price
Array
Not allowed*
int table[]
*Prefixing the array declaration with the word const prevents the function from modifying the
parameter.
One common mistake is to pass an array element to a function when you intended to pass
the array. For example, our ZeroOut function expects an int array as its first argument. In the
following code, the call is incorrect:
Description
The problem is that counters[26] denotes a single array element—one int number—and not
an array. Furthermore, there is no array element with an index of 26. The indexes for counters
run from 0 through 25.
BACKGROUND INFORMATION C, C++, and Arrays as
Arguments
Some programming languages allow arrays to be passed either by value or by reference.
Because passing by value means a copy of the argument is sent to the function, when an

array is passed by value, the entire array is copied. Passing by reference sends only the
address of the array to the function. Obviously, passing large arrays by reference saves
both memory and time.
The C programming language—the predecessor of C++—was designed to be a system
programming language. System programs, such as compilers, assemblers, linkers, and
operating systems, must be both fast and economical with memory space. In designing
the C language, passing arrays by value was judged to be too slow and costly. Therefore,
both C and C++ pass arrays by reference.
Of course, using a reference parameter can lead to inadvertent errors if the values are
changed within the function. In early versions of C, there was no way to protect the caller’s
array from being modified by the function.
C++ (and recent versions of C) added the ability to declare an array parameter as const.
When the array is declared as const, a compile-time error occurs if the function attempts
to modify the array. As a result, C++ supports the efficiency of passing arrays by
reference yet also provides protection from inadvertent modification of the argument.
Whenever your design of a function’s interface identifies an array parameter as
incoming only (to be inspected but not modified by the function), declare the array as const
to ensure the argument is protected.
Commenting Arrays
In comments, we often need to refer to a range of array elements:
Description
To specify such ranges, it is more convenient to use an abbreviated notation consisting of two
dots:
or more briefly:
Note that this dot-dot notation is not valid syntax in C++. We use it only in comments.
As an example, here is how we would write the precondition and postcondition for our
ZeroOut function:
Description
SOFTWARE MAINTENANCE CASE STUDY Modularizing a
Program

MAINTENANCE TASK: The character counting program mentioned earlier in this chapter
consisted of straight-line code. The task here is to modularize it using functions. Let’s
examine the action part of the code.
Description
The comment says it all: We need a function to zero out the counters.
Description
Again, the comments tell us what the loop body does: It accesses each character and
increments its counter if it is a letter. Processing the text should be carried out through a
function that takes the array of counters and the file name as parameters. The following
section of code generates the output:
Description
We can turn this code into a function that takes the array of counters as a parameter.
Here is the character counting program reorganized using functions and proper
documentation:

Description


Description
TESTING: The program was run with the same data, giving these results.
Description
This makes no sense! Some of the totals are correct and some are way off. It looks like
an initialization problem, but the ZeroOut function is correct: It sets each counter to 0—
oops, we forgot to call it! Whatever happened to be in a cell was just incremented.
We add the call to ZeroOut and again run the program.
Description
This is better, but the count for 'A' is still incorrect. Let’s look at the code for ZeroOut:
Description
Of course! The loop should begin at 0 and stop when the counter is numElements. When
this bug is corrected, the program gives the correct results.
Note that before the correction, the location one beyond the array was set to 0. It did not
affect program execution, but that was just by luck. It could have just as easily caused a
bug that would seem completely unrelated to the function.

MAY WE INTRODUCE Ada Lovelace
On December 10, 1815 (the same year in which George Boole was born), a daughter—
Augusta Ada Byron—was born to Anna Isabella (Annabella) Byron and George Gordon,
Lord Byron. In England at that time, Byron’s fame derived not only from his poetry, but also

from his wild, scandalous behavior. The marriage was strained from the beginning, and
Annabella left Byron shortly after Ada’s birth. By April 1816, the two had signed separation
papers. Byron left England, never to return. Throughout the rest of his life, he regretted
being unable to see his daughter. At one point, he wrote of her:
I see thee not. I hear thee not.
But none can be so wrapt in thee.
Before he died in Greece at age 36, he exclaimed, “Oh my poor dear child! My dear Ada!
My God, could I but have seen her!”
Meanwhile, Annabella, who would eventually become a baroness in her own right, and
who was educated as both a mathematician and a poet, carried on with Ada’s upbringing
and education. Annabella gave Ada her first instruction in mathematics, but it soon
became clear that Ada was gifted in the subject and should receive more extensive
tutoring. Ada received further training from Augustus DeMorgan, famous today for one of
the basic theorems of Boolean algebra (DeMorgan’s law), the logical foundation for
modern computers. By age 8, Ada had also demonstrated an interest in mechanical
devices and was building detailed model boats.
When she was 18, Ada visited the Mechanics Institute to hear Dr. Dionysius Lardner’s
lectures on the Difference Engine, a mechanical calculating machine being built by Charles
Babbage. She became so interested in the device that she arranged to be introduced to
Babbage. It was said that, upon seeing Babbage’s machine, Ada was the only person in
the room to understand immediately how it worked and to recognize its significance. Ada
and Charles Babbage became lifelong friends. She worked with him, helping to document
his designs, translating writings about his work, and developing programs for his
machines. In fact, today Ada is recognized as the first computer programmer in history,
and the Ada programming language is named in her honor.
When Babbage designed his Analytical Engine, Ada foresaw that it could go beyond
arithmetic computations and become a general manipulator of symbols and, therefore,
would have far-reaching capabilities. She even suggested that such a device could
eventually be programmed with rules of harmony and composition so that it could produce
“scientific” music. In effect, Ada foresaw the field of artificial intelligence more than 180
years ago.
In 1842, Babbage gave a series of lectures in Turin, Italy, on his Analytical Engine. One
of the attendees was Luigi Menabrea, who was so impressed that he wrote an account of
Babbage’s lectures. At age 27, Ada decided to translate the account into English with the
intent of adding a few of her own notes about the machine. In the end, her notes were twice
as long as the original material, and the document, “The Sketch of the Analytical Engine,”
became the definitive work on the subject.
It is obvious from Ada’s letters that her “notes” were entirely her own and that Babbage
was sometimes making unsolicited editorial changes. At one point, Ada wrote to him,
I am much annoyed at your having altered my Note. You know I am always
willing to make any required alterations myself, but that I cannot endure another
person to meddle with my sentences.
Ada gained the title Countess of Lovelace when she married Lord William Lovelace. The
couple had three children, whose upbringing was left to Ada’s mother while Ada pursued
her work in mathematics. Her husband was supportive of her work, but for a woman of

that day, such behavior was considered almost as scandalous as some of her father’s
exploits.
Ada Lovelace died of cancer in 1852, just one year before a working Difference Engine
was built in Sweden from one of Babbage’s designs. Like her father, Ada lived only to age
36. Even though they led very different lives, she had undoubtedly admired him and taken
inspiration from his unconventional, rebellious nature. In the end, Ada asked to be buried
beside him at the family’s estate.
Using Typedef with Arrays
In Chapter 10, we discussed the Typedef statement as a way of giving an additional name to
an existing data type. We can use Typedef to give a name to an array type. Here’s an
example:
This statement says that the type FloatArray is the same as the type “100-element array of
float.” We can now declare variables to be of type FloatArray:
The compiler essentially translates these declarations into
In this text, we rarely use Typedefs to give names to one-dimensional array types. However,
when we discuss multidimensional arrays later in the chapter, we’ll see that this technique can
come in quite handy.
Pointer Expressions and Arrays
Although 0 is the only literal constant of the pointer type, we can have a constant pointer
expression consisting of an array name without any index brackets. The value of the
expression is the base address of the array. Given the declarations
the assignment statement
has exactly the same effect as

Both of these statements store the base address of anArray into ptr. Because C++ allows us
to assign an array to a pointer, it is a common misperception to think that the pointer variable
and the array identifier are then effectively identical, but they are not. If you apply the sizeof
operator to the pointer, it returns the number of bytes in the pointer. Applying it to the array
identifier returns the number of bytes in the array.
Although we did not explain it at the time, you have already used an array name without
brackets as a pointer expression. Consider the following code, which calls ZeroOut for an
array whose size is the second argument:
Description
In the function call, the velocity argument is a pointer expression. Its value is the base
address of the array. We can write the ZeroOut function heading in one of two ways. The
approach we have used declares the first parameter to be an array of unspecified size:
Alternatively, we can declare the parameter to be of type float*, because it holds the address
of a float variable (the address of the first array element):
Whether we declare the parameter as float floatArray[] or as float* floatArray, the
result is the same: Within the ZeroOut function, floatArray is a variable that points to the
beginning of the caller’s array. However, the first form documents for the reader that the
parameter represents an array. Even though floatArray is a pointer variable within the ZeroOut
function, we are still allowed to attach an index expression to the name floatArray:
Indexing is allowed for any pointer, not just an array name. (However, it makes sense only if
the pointer points to an array.)
C-Style Strings

In Chapter 3, we introduced the C++ string type and associated functions, such as length().
In this section, we introduce an alternate string representation based on arrays, and
operations specific to this implementation.
Strings as Arrays
As we noted in Chapter 1, the C++ programming language is a superset of the earlier C
programming language. C had only a primitive mechanism for representing strings: as an
array of characters. C++ inherits all of C’s support for array-style string representation.
In an abstract sense, a string can be viewed as an array of characters. For example, the
string “dogs” can be viewed as the sequence of characters ‘d’, ‘o’, ‘g’, ‘s’. The following C++
code would be one way of setting up an array with this sequence:
Description
We declare an array of four chars and assign to each element the characters for the string
“dogs”. Although this works, it is cumbersome. Fortunately, it is also possible to declare a C-
style string using literal notation:
However, there is an important difference between this version and the previous approach.
Instead of having length 4, the array has length 5. The additional element holds the null
character to indicate the end of the string. The null character is represented by the special
sequence '\0'. Thus, to truly declare a C-style string without using string literal notation, we
would write:
Description
This array declaration corresponds identically to creating the array with string literal notation.
C provides no built-in facilities for string manipulation (except initializing a char array). In
contrast, the C++ string data type provides a rich set of operations such as substr().
C String Operations
Although the C-style string is not as rich as its C++ counterpart, there are a number of useful
operations available in the string.h header file. The following table shows samples of some of
the functions provided:
Function
Description
size_t strlen(const
char *s);
Computes the length of the string s.
int strcmp(const
char *s1, const
Lexicographically compares strings s1 and s2 and returns an integer
greater than, equal to, or less than 0.

char *s2);
char* strncat(char
*s1, const char
*s2, size_t n);
Appends a copy of n characters from the string s2 to the end of the
string s1. The string s1 must be sufficiently long to hold the result.
Returns a pointer to the new string.
char* strncpy(char
*s1, const char
*s2, size_t n);
Copies n characters from the string s2 to the string s1. Returns a
pointer to the new string.
char* strchr(const
char *s, int c);
Locates the first occurrence of the character c in the string s.
Returns a pointer to the location of the character in the string.
char* strstr(const
char *s1, const
char *s2);
Locates the first occurrence of the string s2 in the string s1 and
returns a pointer to the start of that string.
It is important to note that C-style strings are mutable. For example, assigning a character to
any location in the string will overwrite that character with the one you specify. Likewise, many
of the string operations in the table overwrite their arguments. For instance, strncpy overwrites
its first argument. In addition, because C-style strings are just pointers, you must be very
careful in using functions such as strncat. The strncat function requires that its first argument
must be sufficiently long to hold the result of appending the second argument. Remember that
C++ doesn't check array bounds, so if it is too short, the result will overwrite memory beyond
the end of the string, possibly leading to a crash.
Converting C Strings to C++ Strings
Programming in C++ will eventually lead to using a library that requires C-style strings. We
may need to call a function that requires a C-style string argument or a function that returns a
C-style string. Converting from C-style strings to C++ strings is easy. There is a constructor
for creating C++ strings from C strings:
We can convert a C++ string into a C-style string with the c_str() function:
The c_str() operation returns a C-style string, which can then be assigned to a variable of
type char*.
Which String Representation to Use

Given that we have two different string representations, which is best to use? In most cases,
you should choose the C++ string because it provides a safer abstraction. The C-style string
is just an array of characters that can be changed in arbitrary ways. A C++ string is a real
data type, with associated operations. When you must use functions that expect C-style
strings, it is easy to convert them to or from the C++ string data type.
QUICK CHECK
11.1.1 Why do we say that an array is a homogeneous data structure?
11.1.2 You are solving a problem that requires you to store 24 temperature readings.
Which structure would be most appropriate for this problem: a record, a union, a
class, or an array?
11.1.3 Write a declaration of an array variable called temps that holds 24 values of type
float.
11.1.4 Write a For loop that fills every element of the temps array declared in Exercise
11.1.3 with the value 32.0.
11.1.5 How is a component of an array accessed?
11.1.6 A string in C++ can be treated like an array using the [] operator. Why is it
preferred to use the at operation to access a character in a string?
1 C++ allows one exception: Aggregate I/O is permitted for C strings, which are implemented
as special char arrays. We cover C strings at the end of this section.
2 Here we are referring to passing arrays directly via parameters. There is an indirect way in
which an array can be passed by value. Because a struct is passed by value, when an array
is a field within a struct, its values are copied along with all of the other members. The same is
true when an array is passed as a member of a class.

11.2 Arrays of Records
Many applications involve a collection of records; for example, a business needs a list of parts
records, and a teacher needs a list of students in a class. Arrays are ideal for these
applications. We simply define an array whose components are records.
Arrays of Records
In Chapter 10, we defined a student record using a struct. Suppose we now need a collection
of these student records. How do we implement a “collection”? We can declare an array of
student records. To make things a little more interesting, let’s add a user-defined type
GradeType and an array of exam scores. This is the beginning of a program, so we show the
structure as code.
Description

Description
FIGURE 11.8 gradeBook Array with Records as Elements
This data structure can be visualized as shown in FIGURE 11.8.
An element of gradeBook is selected by an index. For example, gradeBook[2] is the third
element in the array gradeBook. Each component of gradeBook is a record of type StudentRec.
To access the course grade of the third student, for example, we use the following expression:
Description
The record component gradeBook[2].examScore is an array. We can access the individual
elements in this component just as we would access the elements of any other array: We
give the name of the array followed by the index, which is enclosed in brackets.

Description
The next step is to write a function that reads values from a file into the fields of the records.
The file name and the record are parameters of the function. Both must be reference
parameters: Files are always passed by reference, and we are sending back values to the
calling code through the record.
Description
The only tricky part is getting past the eoln at the end of each student’s entry. This eoln
follows the letter grade entered as a character. We can’t use a regular character read
operation because it returns the first letter of the next student’s name. Instead, we must use
inFile.get.
The function to write each student’s record is a mirror image of the input function.

Description
Now we must create a main program that uses these two functions to input the file of
records, store them into an array, and output them to a file.
Description

Here is an input file and the resulting output file. The constant for MAX_STUDENTS was changed
to 5 for this run (for obvious reasons).
Description
QUICK CHECK
11.2.1 How would you access the third letter in a string data member (called street)
of a struct variable that is the twelfth element of an array called mailList?
11.2.2 Imagine we are extending a web browser with functionality that requires an
array of records to maintain the coordinates for HTML elements in the browser
window. How might you declare the struct representing coordinates and an array of
1000 elements for holding these records?

11.3 Special Kinds of Array Processing
Two types of array processing occur especially often: using only part of the declared array (a
subarray) and using index values that have meaning within the problem (indexes with
semantic content). We describe both of these methods briefly here and give further examples
later.
Subarray Processing
The size of an array—the declared number of array components—is established at compile
time. We declare an array to be as big as it will ever need to be. Because the number of
values to be put into the array often depends on the data themselves, however, we may not fill
all of the components. To avoid processing empty positions in the array, we must keep track
of how many components are actually filled.
As values are put into the array, we keep a count of them. We then use this count to
process only those components that have values in them; any remaining places are not
processed. For example, if there are 250 students in a class, a program to analyze test
grades would set aside 250 locations for the grades. However, some students might be
absent for the test. So the number of grades must be counted, and that number—rather than
250—is used to control processing of the array.
When an array has fewer values stored in it than its declared size, functions to which we
pass the array must also receive the number of values as a parameter. For example, in the
ZeroOut function, we passed the array and the number of values as parameters. However,
there is a better way: The array and the count of its values can be bound together in a record.
Consider, for example, the collection of student records. We could change the problem a
little and say that the actual number of student records is not known. The reading loop would
be an eof loop rather than a For loop. Let’s extend ReadValues and PrintValues to take the
record containing the array and number of items. The loops would then be within the functions,
not in main.
Here is the complete program with these changes. The definition of the data structure and
the function prototypes are highlighted.


Description

Description
This program was run with the same data set used previously. It is always comforting to get
the same results.
Indexes with Semantic Content
In some problems, an array index has meaning beyond simple position; that is, the index has
semantic content. An example is the salesAmt array we showed earlier. This array is indexed
by a value of enumeration type Drink. The index of a specific sales amount is the kind of soft
drink sold; for example, salesAmt[ROOT_BEER] is the sales figure (in dollars) for root beer.
In the next section we will see some additional examples of indexes with semantic content.
QUICK CHECK
11.3.1 Explain how the index of an array of 24 hourly temperature readings has
semantic content, if the index is an integer ranging from 0 through 23.
11.3.2 Write a loop that reads values from file indata into the temps array of Exercise
11.1.3 until either the end-of-file is reached or 24 values are input. The loop should
keep track of the number of values in the array in an int variable called count.
11.3.3 At what time is the size of an array established?
11.3.4 How might we avoid processing empty positions in an array?

11.4 Two-Dimensional Arrays
A one-dimensional array may be used to represent items in a list. In many problems,
however, the relationships between data items are more complex. A two-dimensional array
can be used to represent items in a table with rows and columns, where each item is of the
same data type; for example, board games such as chess.
Two-dimensional array A collection of components, all of the same type, structured in
two dimensions. Each component is accessed by a pair of indexes that represent the
component’s position in each dimension.
A component in a two-dimensional array is accessed by specifying the row and column
indexes of the item in the array. FIGURE 11.9 shows a two-dimensional array with 100 rows
and 9 columns. The rows are accessed by an integer ranging from 0 through 99; the columns
are accessed by an integer ranging from 0 through 8. Each component is accessed by a row
—column pair—for example, 0, 5.
FIGURE 11.9 Two-Dimensional Arrays
A two-dimensional array is declared in the same way as a one-dimensional array, except
that sizes must be specified for both dimensions. Here is the syntax template for declaring an
array with more than one dimension:

Description
The following example declares alpha to be a two-dimensional array, all of whose
components are float values. The declaration creates the array that is pictured in Figure
11.9.
Description
To access an individual component of the alpha array, two expressions (one for each
dimension) are used to specify its position. Each expression appears in its own pair of
brackets next to the name of the array:
The syntax template for accessing an array component is
As with one-dimensional arrays, each index expression must result in an integer value.
Now let’s look at some examples. Here is the declaration of a two-dimensional array with
364 integer components (52 × 7 = 364):

hiTemp is an array with 52 rows and 7 columns. Each place in the array (each component) can
contain any int value. The array will hold high temperatures for each day in a year. Each row
represents one of the 52 weeks in a year, and each column represents one of the 7 days in a
week. (To keep the example simple, we ignore the fact that there are 365—and sometimes
366—days in a year.) The expression hiTemp[2][6] refers to the int value in the third row
(row 2) and the seventh column (column 6). hiTemp[2][6] is thus the temperature for the
seventh day of the third week. The code fragment shown in FIGURE 11.10 outputs the
temperatures for the third week.
Another representation of the same data might be as follows:
Description
FIGURE 11.10 hiTemp Array
Description

Description
FIGURE 11.11 hiTemp Array (Alternate Form)
Description
Here hiTemp is declared as before, but now we can use an expression of type DayType for the
column index. hiTemp[2][SUNDAY] is equivalent to hiTemp[2][6] in the first example. (Recall
that enumerators such as MONDAY, TUESDAY, . . . are represented internally as the integers 0, 1,
2, . ...) If day is of type DayType and week is of type int, the code fragment shown in FIGURE
11.11 sets the entire array to 0. (Notice that by using DayType, the values in the array begin
with the first Monday of the year, which is not necessarily January 1.)
Another way of looking at a two-dimensional array is to see it as a structure in which each
component has two features. Consider the following code:

Description
This data structure uses one dimension to represent the color and the other to represent the
make of automobile. In other words, both indexes have semantic content—a concept we
discussed in the previous section.
QUICK CHECK
11.4.1 How does a two-dimensional array differ syntactically from a one-dimensional
array?
11.4.2 Write the declaration for a two-dimensional array, called allTemps, that holds the
24 hourly readings for each day of a year (up to 366 days).
11.4.3 What generic structure is a two-dimensional array typically used to represent?
11.4.4 Imagine we are using a two-dimensional array as the basis for creating the
game battleship. In the game of battleship a ‘~’ character entry in the array represents
ocean (i.e., not a ship), a ‘#’ character represents a place in the ocean where part of a
ship is present, and an ‘H’ character represents a place in the ocean where part of a
ship is present and has been hit by a torpedo. Thus, a ship with all ‘H’ characters
means the ship has been sunk. Declare a two-dimensional array that is 25 × 25 that
represents the entire ocean and an If statement that outputs “HIT” if a torpedo hits a
ship given the coordinates x and y.

11.5 Passing Two-Dimensional Arrays as Arguments
Previously, we said that when one-dimensional arrays are declared as function parameters,
the size of the array usually is omitted:
If you include a size in the brackets, the compiler ignores it.
Just as with a one-dimensional array, when a two-dimensional array is passed as an
argument, the base address of the caller’s array is sent to the function. However, you cannot
omit the sizes of both dimensions. You can omit the size of the first dimension (the number of
rows) but not the second (the number of columns). Here is why.
In the computer’s memory, C++ stores two-dimensional arrays in row order. If we think of
memory as one long line of memory cells, the first row of the array is followed by the second
row, which is followed by the third row, and so on (see FIGURE 11.12).
To locate beta[1][0] in Figure 11.12, a function that receives beta’s base address must be
able to determine that there are four elements in each row—that is, that the array has four
columns. Therefore, the declaration of a two-dimensional array parameter must specify the
number of columns:
Description
The number of columns in the caller’s array must be exactly the same as the number of
columns declared for the parameter because the function will calculate the location of each
element in memory on that basis. As you can tell from Figure 11.12, any discrepancy in the
number of columns will cause the function to access the wrong location in memory (and
possibly go beyond the bounds of the caller’s array).

FIGURE 11.12 Memory Layout for a Two-Row by Four-Column Array
Description
Our AnotherFunc function works for a two-dimensional array with any number of rows, as
long as the array has four columns. In practice, we seldom use arrays with a varying number
of rows but a fixed number of columns. To avoid problems with mismatches, we can use a
Typedef statement to define a two-dimensional array type and then declare both the argument
and the parameter to be of that type. For example, we can write
Description
and then the following function, to initialize all elements of an array of that type to a specified
value:

Description
The calling code could then declare and initialize one or more arrays of type ArrayType by
making calls to the Initialize function. For example:
Description
QUICK CHECK
11.5.1 Write the heading for a function that accepts the temps array of Exercise 11.1.3
and its length as parameters. Call the function Quick and have it be a void function.
11.5.2 What does the C++ compiler do if you provide the size of an array of one
dimension in a parameter declaration?
11.5.3 Why can you omit the size of the first dimension but not the second dimension
in a two-dimensional array?
11.5.4 What part of an array is passed as an argument to a function?

11.6 Processing Two-Dimensional Arrays
Processing data in a two-dimensional array generally means accessing the array in one of
four patterns: by individual location, along rows, along columns, or throughout the entire array.
Each of these methods may also involve subarray processing.
The simplest way to access a component is to look directly in a given location. For
example, a user might enter latitude and longitude coordinates that we use as indexes into an
array of city names to look up the name at those coordinates. This process is sometimes
referred to as random access because the input data may specify any set of coordinates at
random.
In many cases, we need to process all the elements of a particular row or column in an
array. Consider the hiTemp array defined previously, in which the rows represent weeks and
the columns represent days. If we wanted to find the average high temperature for a given
week, we would sum the values in that row and divide by 7. If we wanted to find the average
high temperature for a given day of the week, we would sum the values in that column and
divide by 52. The former case is access by row; the latter is access by column.
Now suppose that we wish to determine the average high temperature for the year. We
must access every element in the array, sum their values, and divide by 364. In this case, the
order of access—by row or by column—is not important. (The same is true when we initialize
every element of an array.) This is access throughout the array.
Sometimes, however, the order is important. For example, if we want the average high
temperature for every week, we need to process each row in turn. However, if we want the
average for each day of the week, we process the whole array column by column.
Let’s take a closer look at these patterns of access by considering four common examples of
array processing.
1. Sum the rows.
2. Sum the columns.
3. Initialize the array to all zeros (or some special value).
4. Output the array.
First we define some constants and variables using general identifiers, such as row and col,
rather than problem-specific identifiers. Then, we look at each algorithm in terms of
generalized two-dimensional array processing.
Description

Sum the Rows
Suppose we want to sum row number 3 in the array and output the result. We can do this
easily with a For loop:
Description
This For loop runs through the columns of table, with the row index fixed at 3. Every value in
row 3 is added to total.
If we want to sum and output rows 2 and 3, we can use a nested loop and make the row
index a variable:
Description
The outer loop controls the rows, and the inner loop controls the columns. For each value of
row, every column is processed; then the outer loop moves to the next row. In the first iteration
of the outer loop, row is held at 2 and col goes from 0 through NUM_COLS-1. Therefore, the array
is accessed in the following order:
Description

FIGURE 11.13 Partial Array Processing by Row
In the second iteration of the outer loop, row is incremented to 3, and the array is accessed as
follows:
Description
We could run through every row of the array by having the outer loop run from 0 through
NUM_ROWS-1; however, if we want to access only part of the array (subarray processing), given
variables declared as
Description
then we write the code fragment as follows:

Description
FIGURE 11.13 illustrates subarray processing by row.
Sum the Columns Revised
Before we look at different processing algorithms, let’s do what we did with our one-
dimensional array: Redesign our structure to be a record that contains the array and two
variables, rowsFilled and colsFilled. Rather than writing code fragments, we also code at
them as functions.
Description
The algorithm for summing a specific row in a two-dimensional array is illustrated in the
following function:
Description
The following function uses function PrintRowSums to output the sums of each of the rows,
calling SumRows to do the summing:

Description
Why did we break the process of outputting the sums of the rows of a two-dimensional
array into two functions? Good style dictates that a function should accomplish only one task:
The second function calls the first to return the row sum and then outputs it.
Sum the Columns
Suppose we want to sum and output each column. The code to perform this task follows.
Again, we sum only the portion of the array that contains valid data.
Description

FIGURE 11.14 Partial Array Processing by Column
In this case, the outer loop controls the column, and the inner loop controls the row. All of the
components in the first column are accessed and summed before the outer loop index
changes and the components in the second column are accessed. FIGURE 11.14 illustrates
subarray processing by column.
Initialize the Array
As with one-dimensional arrays, we can initialize a two-dimensional array either in its
declaration or with assignment statements. If the array is small, it is easy to initialize it in its
declaration. To fill a two-row by three-column array with these values:
we can use the following declaration:

Description
In this declaration, the initializer list consists of two items, each of which is itself an initializer
list. The first inner initializer list stores 14, 3, and −5 into row 0 of the array; the second stores
0, 46, and 7 into row 1. The use of two initializer lists makes sense if you think of each row as
being a one-dimensional array of three int values. The first initializer list initializes the first
array (the first row), and the second is for the second array (the second row). Later in this
chapter, we will revisit this notion of viewing a two-dimensional array as an array of arrays.
Initializing an array in its declaration is impractical if the array is large. For a 100-row by
100-column array, you don’t want to list 10,000 values. If the values are all different, you
should store them in a file and input them into the array at run time. If the values are all the
same, the usual approach is to use nested For loops and an assignment statement. Here is a
function that zeros out an array of type TwoDArray:
Description
In this case, we initialized the array one row at a time, but we could just as easily have run
through each column instead. The order doesn’t matter so long as we access every element.
Output the Array
If we wish to output an array with one row per line, then we have another case of row
processing:
Description

This code fragment outputs values in columns that are 15 characters wide. As a matter of
proper style, this fragment should be preceded by code that outputs headings over the
columns to identify their contents.
There’s no rule saying that we have to output each row on a line. If we liked, we could turn
the array sideways and output each column on one line simply by exchanging the two For
loops. When you are outputting a two-dimensional array, you must consider which order of
presentation makes the most sense and how the array fits on the page. For example, an array
with 6 columns and 100 rows should be output as 6 columns, 100 lines long.
Almost all processing of data stored in a two-dimensional array involves either processing
by row or processing by column. In most of our examples, the index type has been int;
however, the pattern of operation of the loops is the same no matter what types the indexes
are.
The looping patterns for row processing and column processing are so useful that we
summarize them below. To make them more general, we use minRow for the first row number
and minCol for the first column number. Remember that row processing places the row index
in the outer loop, and column processing places the column index in the outer loop.
Description
Description
The following prototypes and main function use each of these functions to read the values into
an array, output them, output the sum of the rows, and output the sum of the columns.


Description
Output:

Description
QUICK CHECK
11.6.1 Write a nested For loop that outputs the contents of the allTemps array declared
in Exercise 11.4.2, with the 24 temperatures for a day on a line and 366 lines of days.
11.6.2 What is the process called when a two-dimensional array is accessed by
index?
11.6.3 What are the four patterns of accessing a two-dimensional array?
11.6.4 Write a nested For loop that outputs the average hourly temperature across
366 days of the allTemps array declared in Exercise 11.4.2, with the average hourly
temperature on a line and 24 lines of hours.
11.6.5 Write a declaration for a two-dimensional array for a tic-tac-toe board, where
we represent an empty square as 0, a square with an X as 1, and a square with a O
as 2, that is initialized without assignment statements with the following board state:
X
O
O
EMPTY
X
EMPTY
X
EMPTY
O

11.7 Another Way of Defining Two-Dimensional Arrays
We noted earlier that a two-dimensional array can be viewed as an array of arrays. This view
is supported by C++ in the sense that the components of a one-dimensional array do not have
to be atomic. The components can themselves be structured—structs, class objects (which
we introduce in Chapter 12), or even arrays. For example, our hiTemp array could be declared
as follows:
Description
With this declaration, the 52 components of the hiTemp array are one-dimensional arrays of
type WeekType. In other words, hiTemp has two dimensions. We can refer to each row as an
entity: For example, hiTemp[2] refers to the array of temperatures for week 2. We can also
access each individual component of hiTemp by specifying both indexes: For example,
hiTemp[2][0] accesses the temperature on the first day of week 2.
Does it matter which way we declare a two-dimensional array? Not to C++. The choice
should be based on readability and understandability. Sometimes the relationships of the data
are better represented if both indexes are specified in a single declaration. At other times, it is
more meaningful if one dimension is defined first as a one-dimensional array type.
The following example shows a case in which the rows have been defined first as a one-
dimensional array type, allowing each row to be passed to a function whose parameter is a
one-dimensional array of the same type. The following function calculates and returns the
maximum value in an array of type WeekType.
Description
Our two-part declaration of hiTemp permits us to call Maximum using a component of hiTemp
as follows:

Row 20 of hiTemp is passed to Maximum, which treats it like any other one-dimensional array of
type WeekType (see FIGURE 11.15). It makes sense to pass the row as an argument because
both it and the function parameter are of the same named type, WeekType.
FIGURE 11.15 A One-Dimensional Array of One-Dimensional Arrays
Description
With hiTemp declared as an array of arrays, we can output the maximum temperature of
each week of the year with the following code:

11.8 Multidimensional Arrays
C++ does not place a limit on the number of dimensions an array can have. We can
generalize our definition of an array to cover all cases.
Array A collection of components, all of the same type, ordered on N dimensions (N ≥ 1).
Each component is accessed by N indexes, each of which represents the component’s
position within that dimension.
Given that you can have as many dimensions as you want, how many should you have in
a particular case? Use as many as there are features that describe the components in the
array.
Consider, for example, a chain of stores. Monthly sales figures must be kept for each item
by store. Three important pieces of information about each item are identified: the month when
it was sold, the store where it was purchased, and the item number. We can define an array
type to summarize this data as follows:
Description
FIGURE 11.16 provides a graphic representation of the sales array.

FIGURE 11.16 Graphic Representation of sales Array
Description
The number of components in sales is 12,000 (10 × 12 × 100). If sales figures are available
only for January through June, then half of the array is empty. If we want to process the data
in the array, we must use subarray processing. The following code sums and outputs the total
number of each item sold this year to date by all stores:
Description
Because item controls the outer For loop, we are summing each item’s sales by month and
store. If we want to find the total sales for each store, we use store to control the outer For
loop, summing its sales by month and item with the inner loops.

Description
It takes two loops to access each component in a two-dimensional array; it takes three
loops to access each component in a three-dimensional array. The task to be accomplished
determines which index controls the outer loop, the middle loop, and the inner loop. If we want
to calculate monthly sales by store, month controls the outer loop and store controls the
middle loop. If we want to calculate monthly sales by item, month controls the outer loop and
item controls the middle loop.
If we want to keep track of the department that sold each item, we can add a fourth
dimension to the array:
Description
If we want the number of sales in store 1 during June for item number 4 in department C, we
simply access the following array element:
When a multidimensional array is declared as a parameter in a function, we specify the
sizes of all dimensions except the first. For our four-dimensional version of SalesType, a
function heading would look like this:
or, better yet, like this:
The second version is the safest (and the most uncluttered for readers). It ensures that the
sizes of all dimensions of the parameter match those of the argument exactly. With the first
version, the reason that you must declare the sizes of all but the first dimension is the same
as for two-dimensional arrays: Because array elements are stored linearly in memory, the
compiler needs this size information to locate an element within the array.
QUICK CHECK

11.8.1 Write a declaration for a multidimensional array for representing network
access points in a building that has 15 floors, 10 rooms per floor, and up to 12 network
access points per room. Each network access point is labeled with its state as being
on or off; if it is on, it has the month it was turned on.
11.8.2 Which aspect of a problem would lead you to consider using a
multidimensional array as the representation of its data structure?
11.8.3 Write a declaration for a multidimensional array that stores 24 hourly
temperatures for each day of a year for a decade. Call the array decadeTemps.
Problem-Solving Case Study
CALCULATING EXAM STATISTICS
PROBLEM: You are the grader for a Political Science class. The instructor has asked you
to prepare the following statistics for each exam: average grade, maximum grade,
minimum grade, number of grades above the average, and number of grades below the
average. You decide to write a program to calculate these statistics.
DISCUSSION: Let’s abstract this problem from the given context and look at the tasks in
isolation. Three separate things must be done in this problem: compute an average of
values on a file, find the minimum value and maximum value in a file, and compare each
value to the average. There are several approaches to the solution to this problem. In the
next chapter, we will look at an entirely different solution technique; however, here we base
our solution on the fact that the values in the list are between 0 and 100. We use an array
where the indexes have semantic content: Each index represents a grade.
The by-hand analogy is to mark off 101 lines on a sheet of paper and number the lines
from 0 to 100. Each line number represents a possible grade. As you read a grade, make
a hash mark on the line with that number. The average is the sum of the grades divided by
their number. You compute the sum by summing the products of each grade (line number)
times the number of hash marks on that line. You can either count the number of grades
as you read them or later, as you go through the list to sum them up.
To calculate the lowest grade, start at line 0 and look down the list; the number of the first
line with a hash mark is the lowest grade. To calculate the highest grade, start looking
backward from line 100; the line number where you find the first hash mark is the highest
grade. To determine how many grades are above average, start at the line whose number
is the average grade plus 1 and count the hash marks on the lines from there through line
100. To determine how many grades are below the average, sum the hash marks from the
line whose number is the truncated average through line 0.
The data structure equivalent of your sheet of paper is an integer array of size 101. The
index is the line number; the component corresponds to where you make hash marks
(increment the component) each time the grade corresponding to the index occurs, as
shown in FIGURE 11.17.
INPUT: A file, whose name is input from the keyboard, containing test grades.

OUTPUT: A file, whose name is input from the keyboard, showing the following statistics
properly labeled:
Number of grades
Average grade
Lowest grade
Highest grade
Number of grades above the average
Number of grades below the average
FIGURE 11.17 Graphic Representation of grades Array
Description
DATA STRUCTURE: The array of grades and the values to be calculated should be
bound together into a record.

Description
Main
Level 0
Open files
Calculate statistics
Print results
Close files
We can use the same “open files” function we have used in several other programs;
however, the heading that is output needs to be changed.
Calculate Statistics
This function must input the grades and calculate the statistics. It needs the input file name
and the record of type GradeStatistics. Let’s call this parameter statistics. We pass it to
all of the modules, so they can access the values.
CalculateStatistics (In/out: inData, statistics)
Input grades
Calculate average
Calculate highest
Calculate lowest
Calculate number above average
Calculate number below average
Input Grades
Level 1
This function needs the file name and the array as parameters. As we said, the number of
grades can be calculated as the grades are read, so we count them up here and pass the
count as an argument to the function that computes the average.
InputGrades(In/out: statistics, inData)
Set numGrades to 0
Read grade
WHILE NOT eof
Increment statistics.grades[grade]
Increment statistics.numGrades
Read grade
CalculateAverage(In/out: statistics)
Set sum to 0

FOR index going from 0 through 100
Set sum to sum + statistics.grades[index] * index;
Set statistics.average to float(sum) / float(statistics.numGrades)
CalculateHighest(In/out: statistics)
Set highGrade to 100;
WHILE statistics.grades[highGrade] equal to 0
Decrement highGrade
Set statistics.highest to highGrade
CalculateLowest(In/out: statistics)
Set lowGrade to 0
WHILE statistics.grades[lowGrade] equal to 0
Increment lowGrade
Set statistics.lowest to lowGrade
CalculateAboveAverage(In/out: statistics)
Set averagePlus to int(statistics.average) + 1
Set number to zero
FOR index going from averagePlus to 100
Set number to number + statistics.grades[index]
Set statistics.aboveAverage to number
CalculateBelowAverage(In/out: statistics)
Set truncatedAverage to (int) statistics.average
Set number to zero
FOR index going from 0 to truncatedAverage
Set number to number + statistics.grades[index]
Set statistics.belowAverage to number
PrintResults(In/out: outData; In: statistics)
Write on outData “The average grade is ” statistics.average
Write on outData “The highest grade is ” statistics.highest
Write on outData “The lowest grade is ” statistics.lowest
Write on outData “The number of grades above the average is ” statistics.aboveAverage
Write on outData “The number of grades below the average is ” statistics.belowAverage
MODULE STRUCTURE CHART

Description

Description

Description
Description


Description
TESTING: When testing this program, it is the values of grades—not the size of the file—
that determines the test cases. We must include values of MinGrade, MaxGrade, and
values in between. The following data set meets this criterion. It is shown below in
columns to save space.
Description
Here is the output:
Description

Graphical User Interface (GUI)
Similar to the prior chapter, the changes we need to make to the exam analysis program to
incorporate a GUI are small. The original program asked the user to enter an input and output
file from the console. Likewise, it generated the analysis of that input file to the output file as
text. Thus, refactoring this program to use a graphical interface requires us to replace the
console input and output. Fortunately, we have already seen both GUI widgets that enable us
to make these changes. In particular, we can use a FileDialog to choose an input file to read
exam scores and a NewFileDialog to create an output file to write the grade statistics.
As we have done in previous chapters, we first include the necessary header file for the
dialog widgets:
The original program used standard output to prompt the user for the exam data file and
standard input to read the name of the file. Likewise, it used standard output and input to ask
the user for the output file to save the exam statistics. The user interaction happened in the
OpenFiles function, and the corresponding files were opened using the given ifstream and
ofstream parameters.
To capture the input and output file names in our GUI version we simply replace the use of
cout and cin in the original version with a FileDialog and NewFileDialog widget. This not only
provides an improved human interactive experience, but also takes care of any errors that
may result from manually typing in file names! Here is a summary of these changes:
Description
Here is what the two file dialog widgets look like when we run the GUI version:

Description
Description
We omit the full GUI program listing because it is identical except for the include file and
OpenFiles function discussed above.
Problem-Solving Case Study
FAVORITE ROCK GROUP
PROBLEM: At a small college, four campus rock groups have organized a fund-raising
project in which there will be a playoff among the groups. Each student gets to vote for

their favorite group. Two prizes will be awarded: The best group gets a prize and the class
with the most participation gets a prize.
INPUT: An arbitrary number of votes in a file voteFile, with each vote represented as a
pair of numbers—a class number (1 through 4) and a rock group number (1 through 4)—
and group names entered from the keyboard (to be used for generating the output).
OUTPUT: The following three items, written to a file reportFile: a tabular report showing
how many votes each rock group received in each class, the total number of votes for
each rock group, and the total number of votes cast by each class.
DISCUSSION: There will be a pair of numbers for each vote. The first is the class
number; the second is the rock group number.
If we were doing the analysis by hand, our first task would be to go through the data,
counting how many people in each class voted for each group. We could create a table
with classes down the side and rock groups across the top. Each vote would be recorded
as a hash mark in the appropriate row and column (see FIGURE 11.18).
When all of the votes have been recorded, a sum of each column tells us how many
votes each group received. A sum of each row tells us how many people voted in each
class.
As is so often the case, we can use this by-hand algorithm directly in our program. A
two-dimensional array can represent our table; for example, the value indexed by [1][0]
would be the counter for the votes in class 2 (sophomore) for group 1, keeping in mind that
C++ arrays are indexed beginning at 0. When we input the data, we must remember to
subtract 1 from each value before using it to index into the array. Likewise, we must add 1
to an array index that represents a class or group number before outputting it.
DATA STRUCTURES: (1) A two-dimensional array named votes, where the rows
represent classes and the columns represent groups. (2) A one-dimensional array of
strings containing the names of the groups, to be used for output (see FIGURE 11.19).
FIGURE 11.18 Vote-Counting Table
Description

FIGURE 11.19 Data Structures for Favorite Rock Group Program
Description
In our discussion we have used the word “class” to represent freshman, sophomore,
junior, or senior. However, we cannot use the word “class” in our program because it is a
reserved word (as we see in the next chapter). Let’s use the word “level” instead. In the
design that follows, we use the named constants NUM_LEVELS and NUM_ROCK_GROUPS in place
of the literal constants 4 and 4.
Main
Level 0
Get group names
Set votes array to 0
Read level, group from voteFile
WHILE NOT EOF on voteFile
Increment votes[level–1][group–1] by 1
Read level, rockGroup from voteFile
Write report to reportFile
Write totals per group to reportFile
Write totals per level to reportFile
Get RockGroup Names(Out: name)
Level 1
Print “Enter the names of the rock groups, one per line, in the order they appear on the
ballot.”
FOR rockGroup going from 0 through NUM_ROCK_GROUPS − 1
Read name[rockGroup]
Note that each rock group’s name is stored in the slot in the name array corresponding to
its group’s number (minus 1). These names are useful when the totals are output.
Set Votes to Zero(Out: votes)
FOR each level
   FOR each group
      Set votes[level][group] to 0
Write Report(In: votes, name; In/out: reportFile)

FOR each rockGroup // Set up headings
     Write name[rockGroup] to reportFile
FOR each level // Output array by row
     FOR each rockGroup
          Write votes[level][rockGroup] to reportFile
Write Totals per RockGroup(In: votes, name; In/out: reportFile)
FOR each rockGroup
     Set total = 0
FOR each level // Compute column sum
     Add votes[level][rockGroup] to total
     Write “Total votes for”, name[rockGroup], total to reportFile
Write Totals per Level(In: votes; In/out: reportFile)
FOR each level
     Set total = 0
     FOR each rockGroup // Compute row sum
          Add votes[level][rockGroup] to total
     Write “Total votes for level”, level, ‘:’, total to reportFile
MODULE STRUCTURE CHART
Description
Description

Description

Description


Description
Description
TESTING: This program was executed with the file data listed below. (Shown in three
columns to save space.) The keyboard I/O is shown after the file contents. In this data set,
there is at least one vote for each group in each level. Case Study Follow-Up Exercise 7
asks you to outline a complete testing strategy for this program.
Input data on file Votes.dat:
Description
Keyboard I/O:

Description
Output on file Votes.out:
Description

Graphical User Interface (GUI)
Similar to the exam statistics program in the previous case study, we must ask the user for an
input file to analyze and an output file to record the results. As usual, we include the
necessary header file for the dialog widgets:
Although these two case study programs differ in their analysis, the GUI updates are
similar. In particular, we can use a FileDialog to choose an input file to read voting data and a
NewFile-Dialog to create an output file to write the voting statistics. In addition, we will use a
TextDialog widget to replace the console-based interface asking the user to type in band
names. We will display the TextDialog component for each band name that is requested.
Converting the original program to a GUI version requires changes to only two functions:
OpenFiles and GetNames. Here is a summary of these changes:
Description

Description
Here is what the three dialog widgets look like when we run the GUI version:
Description

Description
Description
We omit the full GUI program listing because it is identical except for the include file and the
OpenFiles and GetNames functions discussed above.

Testing and Debugging
One-Dimensional Arrays
The most common array processing error is an out-of-bounds index; that is, attempting to
access a component using an index that is either less than 0 or greater than the array size
minus 1. For example, given the declarations
Description
the following For statement would output the 100 elements of the line array and then output a
101st value—the value that resides in memory immediately beyond the end of the array:
Description
This error is easy to spot because 101 characters are output instead of 100. The loop test
should be counter < 100.
You won’t always use a simple For statement when accessing arrays, however. Suppose
we read data into the line array in another part of the program. Let’s use a While statement
that reads to the newline character:
Description
This code seems reasonable enough, but what if a line has more than 100 characters? After
the hundredth character is read and stored into the array, the loop continues to execute with
the array index out of bounds. Characters are stored into locations past the end of the array,
wiping out other data values (or even instructions in the program!).
The moral of the story is this: When processing arrays, pay close attention to the loop
termination conditions. Always ask yourself if the loop could possibly keep going after the last
array component has been processed.
Whenever an array index goes out of bounds, your first suspicion should be that a loop has
failed to terminate properly. The second thing to check is any array access involving an index

that is based on input data or a calculation. When an array index is input as data, a data
validation check is an absolute necessity.
Complex Structures
As we have demonstrated in many examples in this chapter and the last, data structures may
be combined in various ways: structs whose components are structs, structs whose
components are arrays, arrays whose components are structs, arrays whose components
are arrays (multidimensional arrays), and so forth. When arrays and structs are combined,
confusion can arise about precisely where to place the operators for array element selection
([]) and struct member selection (.).
To summarize the correct placement of these operators, let’s use the StudentRec type we
introduced earlier in this chapter:
Description
If we declare a variable of type StudentRec,
Description
then what is the syntax for selecting the first exam score of the student (that is, for selecting
element 0 of the examScore member of student)? The dot operator is a binary (two-operand)
operator; its left operand denotes a struct variable, and its right operand is a member name:
Description
The [] operator is a unary (one-operand) operator; it comes immediately after an expression
denoting an array:
Description
Therefore, the expression
student
denotes a struct variable; the expression
Description

denotes an array; and the expression
Description
denotes an integer—the integer located in element 0 of the student.examScore array.
With arrays of structs or class objects, you must once again make sure that the [] and .
operators are in the proper positions. Given the declaration
Description
we can access the gpa member of the first element of the gradeBook array with the following
expression:
Description
The index [0] is attached to the array identifier gradeBook. Furthermore, the expression
Description
denotes a struct, so the dot operator selects the gpa member of this struct.
Multidimensional Arrays
Errors made while working with multidimensional arrays usually fall into two major categories:
index expressions that are out of order and index range errors.
Suppose we were to expand the rock group program to accommodate 10 rock groups and
4 levels. Let’s declare the votes array as
Description
The first dimension represents the levels, and the second represents the rock groups. An
example of the first kind of error—incorrect order of the index expressions—would be to
output the votes array as follows:
Description

In the highlighted part of the code, the output statement specifies the array indexes in the
wrong order. The loops march through the array with the first index ranging from 0 through 9
(instead of 0 through 3) and the second index ranging from 0 through 3 (instead of 0 through
9). Depending on the computer system, the program may output the wrong array components
and continue executing, or it may crash with a memory access error.
An example of the second kind of error—an incorrect index range in an otherwise correct
loop—can be seen in this code:
Description
Here the output statement correctly uses level for the first index and rockGroup for the second
index. However, as the highlighting points out, the For statements use the opposite upper
limits for the index variables—there are supposed to be 4 levels and 10 groups. As with the
preceding example, the effect of executing this code is undefined but is certainly wrong. A
valuable way to prevent this kind of error is to use named constants instead of the literals 10
and 4. In the case study, we used NUM_LEVELS and NUM_ROCK_GROUPS. You are much more likely
to spot an error (or to avoid making an error in the first place) if you write something like:
Description
than if you use a literal constant as the upper limit for the index variable.
Testing and Debugging Hints
1. When an individual component of a one-dimensional array is accessed, the index must
be within the range 0 through the array size minus 1. Attempting to use an index value
outside this range will cause the program to access memory locations outside the array.
2. The individual components of an array are themselves variables of the component type.
When values are stored into an array, they should either be of the component type or be
explicitly converted to the component type; otherwise, implicit type coercion occurs.
3. C++ does not allow aggregate operations on arrays, such as aggregate assignment,
aggregate comparison, aggregate I/O, or aggregate arithmetic. You must write code to do
these operations, one array element at a time.
4. Omitting the size of a one-dimensional array in its declaration is permitted only in two
cases: (1) when an array is declared as a parameter in a function heading and (2) when

an array is initialized in its declaration. In all other declarations, you must specify the size
of the array with a constant integer expression.
5. If an array parameter is incoming only, declare the parameter as const to prevent the
function from accidentally modifying the caller’s argument.
6. Don’t pass an individual array component as an argument when the function expects to
receive the base address of an entire array.
7. The size of an array is fixed at compile time, but the number of values actually stored
there is determined at run time. Therefore, an array must be declared to be as large as it
could ever be for the particular problem. Subarray processing is used to process only
those components that contain data.
8. When functions perform subarray processing on a one-dimensional array, you must pass
both the array and the number of items actually used or combine the array name and the
number of items in a record.
9. With multidimensional arrays, you must use the proper number of indexes when
referencing an array component. You should also make sure the indexes are in the
correct order.
10. In loops that process multidimensional arrays, double-check the upper and lower bounds
on each index variable to be sure they are correct for that dimension of the array.
11. When declaring a multidimensional array as a parameter, you must state the sizes of all
but the first dimension. Also, these sizes must agree exactly with the sizes of the caller’s
argument.
12. To eliminate the chance of a size mismatch (see item 11), use a Typedef statement to
define a multidimensional array type.
13. If subarray processing is being used, combine the multidimensional array type and the
number of actual values stored in each dimension into a record. Pass the record as a
parameter.
14. In an expression, an array name without any index brackets is a pointer expression; its
value is the base address of the array. The array name is considered a constant
expression, so no assignment to it is possible. The following code shows correct and
incorrect assignments:
Description

Summary
The one-dimensional array is a homogeneous data structure that gives a name to a
sequential group of like components. Each component is accessed by its relative position
within the group (rather than by name, as in a struct), and each component is a variable of
the component type. To access a particular component, we give the name of the array and
an index that specifies which component we want. The index can be an expression of any
integral type, as long as it evaluates to an integer from 0 through the array size minus 1.
Array components can be accessed in random order directly, or they can be accessed
sequentially by stepping through the index values one at a time.
Two-dimensional arrays are useful for processing information that is represented
naturally in tabular form. Processing data in two-dimensional arrays usually takes one of
two forms: processing by row or processing by column. An array of arrays, which is useful
if rows of the array must be passed as arguments, is an alternative way of defining a two-
dimensional array.
A multidimensional array is a collection of like components that are ordered on more
than one dimension. Each component is accessed by a set of indexes, one for each
dimension, that represents the component’s position on the various dimensions. Each
index may be thought of as describing a feature of a given array component.
If subarray processing is used, the array and the actual values stored in each dimension
should be bound together into a record. This record should be passed as a parameter to
functions.

Quick Check Answers
11.1.1 Because its elements are all of the same type.
11.1.2 An array.
11.1.3 float temps[24];
Description
11.1.5 By its position.
11.1.6 The at operation checks the bounds of the array, whereas the[] operator does not.
11.2.1 mailList[12].street.at(2)
Description
11.3.1 The index represents the hour during which the reading was taken, based on a 24-
hour clock.
Description
11.3.3 At compile time.
11.3.4 We need to keep track of how many entries are actually filled.
11.4.1It is declared and accessed with two index values instead of one.
11.4.2 floatallTemps[24] [366];
11.4.3 A table.
11.4.4 char board[25][25]; if (board[X][Y] == '#') cout << "HIT" << endl;
11.5.1 void Quick (float table[], int numElements)
11.5.2 Nothing, it ignores it.
11.5.3 Because C++ stores a two-dimensional array in row order. Thus, you can leave off
the number of rows, but not the number of columns.

11.5.4 The base address.
Description
11.6.2 This process is referred to as random access.
11.6.3 Randomly, along rows, along columns, and throughout the entire array.
Description
Description
Description
11.8.2 If the problem has a homogeneous collection of data that is ordered by more than
two indexes.
Description

Exam Preparation Exercises
11.1 The components of an array can be of different types. True or false?
11.2 Arrays can have any type for their components. True or false?
11.3 Multidimensional arrays are limited to no more than four dimensions. True or
false?
11.4 When you are declaring a one-dimensional array, its size must be specified with
an integer. True or false?
11.5 The type of an index expression can be any of the integral types or an
enumeration type. True or false?
11.6 What happens if a program tries to access an array using an index of −1?
11.7 Which aggregate operations are allowed on arrays?
11.8 To what does the term “base address of an array” refer, and how is it used in a
function call?
11.9 Which special type of array can be returned by a value-returning function?
11.10 If you want to use a nested loop to process a two-dimensional array row-by-
row, which dimension’s index (row or column) would you increment in the inner loop
and which would you increment in the outer loop?
11.11 How many elements are there in each of the following arrays?
Description
11.12What’s wrong with the following code segment?
Description
11.13 What’s wrong with the following code segment?

Description
11.14 What’s wrong with the following code segment?
Description
11.15 What’s wrong with the following code segment?
Description
11.16 What’s the potential danger in the following code segment?
Description
11.17 What is the side effect of the following function?

Description
11.18 What does the following code segment output?
Description
11.19 Given the declaration of pattern in Exercise 11.18, what does the following loop
output?

Description
11.20 Given the declaration of pattern in Exercise 11.18, what does the following loop
output?
Description
11.21 Given the following declaration:
Description
a. Write a loop to output the first row of the array on one line on cout.
b. Write a loop to output the first column of the array on one line on cout.
c. Write a loop to output the first seven rows of the array, each on a single line.
d. Write a loop to output the entire array backward and upside down, so that the last
line appears first, with the last column on the left.
11.22 An index expression (like those used with arrays) can be attached to any
pointer variable, even if it doesn’t point to an array. True or false?

Programming Warm-Up Exercises
11.1 Write the following declarations.
a. An array called topTenList, containing 10 values of type string.
b. An enumeration type of the seven major colors of the spectrum and a matching
array declaration that can be indexed by the spectrum type. The array should be
called colorMix and should contain values of type float.
c. A two-dimensional array representing the days on a calendar page with up to six
weeks. Call the array month, and declare an enumeration type consisting of the
names of the days, which can be used to index the array columns. The weeks
should be indexed by an int. For the component type of the array, declare a struct
consisting of an int field called day and a string field called activity.
11.2 Write a declaration of a named array type, and then declare three arrays of that
type. The array type should be called DataSet, and the three arrays should be called
input, output, and working. Each array should hold five float values.
11.3 Using the DataSet type declared in Exercise 11.2, declare an array of three data
sets called set.
11.4 Using the set array declared in Exercise 11.3, write a nested For loop that
initializes all of the values of the three data sets to 0.0.
11.5 Write a function heading for a function called Equals that takes two arrays of the
DataSet type declared in Exercise 11.2 and returns a bool result. The array
parameters should be const, because they are input-only parameters to the function.
11.6 Write the body of the Equals function described in Exercise 11.5. It should return
true if each element of the first array is equal to its corresponding element in the
second array.
11.7 A gallery needs to keep track of its paintings and photographs. It keeps at most
120 artworks on its walls. Each one is described by the following information:
Artist (string)
Title (string)
Medium (oil, watercolor, pastel, acrylic, print, color photo, black-and-white photo)
Size (struct)
    Height (int)
    Width (int)
Room where it is hung (main, green, blue, north, south, entry, balcony)
Price (float)

Write a declaration for a struct that represents a piece of art. Declare struct and
enumeration types as needed to make up the fields of the Artwork type. Write an
additional declaration of a named array type that holds the list of all the artworks in the
gallery. Lastly, declare an array of this type called currentList and an int variable
numPieces. The numPieces variable contains the number of pieces represented in the
array.
11.8 Write expressions that retrieve the following values from the array declared in
Exercise 11.7.
a. The 37th work of art
b. The title of the 12th work of art
c. The width of the 85th work of art
d. The room for the 120th work of art
e. The first letter of the artist’s name for the 78th work of art
11.9 Write a For loop that outputs a list of the artist, title, and price for every artwork in
the currentList array defined in Exercise 11.7.
11.10 Write a code segment that sums the prices of the artworks in the gallery
described in Exercise 11.7.
11.11 Write a code segment that outputs the titles of the artworks in the blue room of
the gallery described in Exercise 11.7.
11.12 Write a code segment that sums the prices of the oil paintings in the gallery
described in Exercise 11.7 that are larger than 400 square inches in size.
11.13 A piano is tuned in a scale that is slightly unequal (called a “well-tempered
scale”), rather than a perfectly scientific scale in which each note sounds at twice the
frequency of the same note an octave below (called a “just scale”). For this reason,
we can’t simply calculate the frequency of a note, but must keep it in a table. Declare
a two-dimensional array (scale) to hold the frequencies of the well-tempered scale. A
frequency is represented by a float value. The row dimension is indexed by an int
value representing the octave (there are eight octaves, numbered 0 through 7), and
the other should be indexed by an enumeration type (Notes) consisting of the names
of the notes. When you write the declaration of the enumeration type, use only sharps
(no flats). Thus the note names of an octave are C, CSHARP, D, DSHARP, E, F, FSHARP, G,
GSHARP, A, ASHARP, and B, in that order.
11.14 Write a code segment that reads a table of frequencies into the scale array
declared in Exercise 11.13 from a file called frequencies.dat. The frequency values
are arranged one per line on the file.
11.15 Write a code segment that outputs the frequencies of the notes in the fourth
octave of the scale array declared in Exercise 11.13.

11.16 Write a code segment that outputs the frequencies of all C notes in the scale
array declared in Exercise 11.13.
11.17 Write a declaration for a four-dimensional array called humidity that is indexed
by 10 years (0—9), 52 weeks (0—51), the 50 states (0—49), and an enumeration
type consisting of MAX, MIN, and AVERAGE, called Type. The array holds humidity
measurements (each component is a float).
11.18 Write a C++ function called Reset, which sets all of the components to zero in
the humidity array declared in Exercise 11.17.
11.19 Write a declaration of a struct type called TimePlace that has three fields, one
for each for the first three index values (year, week, state) in the humidity array
declared in Exercise 11.17. TimePlace should have a fourth field called difference,
which is a float. Then write a C++ function called MaxSpread that takes the humidity
array as a parameter; scans through it to find the year, week, and state with the
greatest difference in humidity over the course of a week; and returns these values as
a TimePlace struct. If there is more than one week with the greatest difference, then
the first one should be returned.
11.20 Write a code segment that outputs the AVERAGE component of the humidity array
of Exercise 11.17 for all the weeks in the last 5 years for the 23rd state.
11.21 Declare a pointer variable charArrPointer and initialize it to point to the first
element of a four-element char array named initials. Write assignment statements
to indirectly store 'A', 'E', and 'W' into the first three elements of the array pointed to
by charArrPointer.

Programming Problems
11.1 Imagine we are using a two-dimensional array as the basis for creating the game
battleship. In the game of battleship, a ‘~’ character entry in the array represents
ocean (i.e., not a ship), a ‘#’ character represents a place in the ocean where part of a
ship is present, and an ‘H’ character represents a place in the ocean where part of a
ship is present and has been hit by a torpedo. Thus, a ship with all ‘H’ characters
means the ship has been sunk. Declare a two-dimensional array that is 25 × 25 that
represents the entire ocean and an If statement that outputs “HIT” if a torpedo hits a
ship given the coordinates x and y. Write a C++ program that will read in a file
representing a game board with 25 lines where each line has 25 characters
corresponding to the description above. An example file might look like:

You should write a function called Fire that will take an x and y coordinate and output
“HIT” if a ship is hit and “MISS” if a ship is missed. If a ship is hit, you should update
the array with an ‘H’ character to indicate the ship was hit. If a ship is hit that has
already been hit at that location, you should output “HIT AGAIN”. You should write a
second function called FleetSunk that will determine if all the ships have been sunk.
Your C++ program must then call these functions until all the ships have been sunk, at
which point the program should display “The fleet was destroyed!”
11.2 Write a program to play a game in which you try to sink a fleet of five navy
vessels by guessing their locations on a grid. The program uses random numbers to
position its ships on a 15 × 15 grid. The ships are of different lengths as follows:
Frigate: 2 locations
Tender: 2 locations

Destroyer: 3 locations
Cruiser: 3 locations
Carrier: 4 locations
The program must pick one square as the starting location, pick the direction of the
ship on the board, and then mark off the number of squares in that direction to
represent the size of the ship. It must not allow a ship to overlap with another ship or
to run off the board.
The user enters coordinates in the range of 1 through 15 for the rows and A through
O for the columns. The program checks this location and reports whether it is a hit or
a miss. If it is a hit, the program also checks whether the ship has been hit in every
location that it occupies. If so, the ship is reported as sunk, and the program identifies
which ship it is.
The user gets 60 shots to attempt to sink the fleet. If the user sinks all of the ships
before using all 60 shots, then he or she wins the game. At the end of the game, the
program should output the grid so the user can see where the ships are located.
11.3 Programming Warm-Up Exercises 11.7 to 11.12 deal with an array representing
the inventory for an art gallery. Using the same representation, write a C++ program
that reads the gallery’s inventory from a file called art.dat into the array. Then allow
the user to look up the art by specifying any field in the record. As a reminder, here
are the fields:
Artist (string)
Title (string)
Medium (oil, watercolor, pastel, acrylic, print, color photo, black-and-white photo)
Size (struct)
    Height (int)
    Width (int)
Room where it is hung (main, green, blue, north, south, entry, balcony)
Price (float)
The user should be able to specify a field and a value for that field, and the program
then returns all artworks that match those criteria. For example, the user may specify
Artist and Smithely, and the program will output all of the information concerning every
work in the gallery by that artist.
11.4 Programming Problem 7.1 asked you to write a program that takes a string as
input and then outputs the corresponding words in the International Civil Aviation
Organization (ICAO) alphabet that would be used to spell it out phonetically. For that
program, you should have used a large Switch statement. Rewrite that program using
an array of strings to hold the words of the alphabet, and index the array by the
positions of the letters of the alphabet. By using an index with semantic content, you
can avoid the need for the Switch statement. Be sure that you don’t try to index into
the array using nonalphabetic characters, because that will result in an out-of-bounds
access. For ease of reference, the ICAO alphabet is repeated here from Chapter 7:
A
Alpha

B
Bravo
C
Charlie
D
Delta
E
Echo
F
Foxtrot
G
Golf
H
Hotel
I
India
J
Juliet
K
Kilo
L
Lima
M
Mike
N
November
O
Oscar
P
Papa
Q
Quebec
R
Romeo
S
Sierra
T
Tango
U
Uniform
V
Victor
W
Whiskey
X
X-ray

Y
Yankee
Z
Zulu
Be sure to use proper formatting and appropriate comments in your code. Provide
appropriate prompts to the user. The output should be clearly labeled and neatly formatted.
11.5 Programming Problem 6.6 asked you to write a program to check whether an
input line is a palindrome (a word or phrase that is the same when read backward and
forward). At that time, we needed to use the substring function to extract individual
characters from a string. Because this is a cumbersome way to work with a string,
we limited our definition of palindromes to just perfect palindromes—every letter and
blank exactly the same in both forward and backward versions. Now that we know
how to use arrays, we can expand the definition to ignore blanks, punctuation, and
letter case. Thus
madam I’m adam
becomes
madamimadam
which is now a palindrome. Write a C++ program that reads a line of input and checks
whether it is a palindrome on the basis of this less restrictive definition. Output the
reversed line, with all blanks and punctuation removed, and all letters converted to
lowercase along with the program’s decision.
11.6 Create a record representing a song on a CD or in an MP3 library. Write a C++
program that allows the user to specify the name of a data file containing songs
(assume there are fewer than 200 songs on the file) and then reads the song data
from the file into an array of songs. The user should then be allowed to enter the name
of an artist, and the program will output all of the songs by that artist, along with any
other information about the song that is in the array.

Case Study Follow-Up
1. There is no error checking in the Calculating Exam Statistics program. List at least
two errors that could easily be checked.
2. All of the functions in the Calculating Exam Statistics program except OpenFiles,
InputGrades, and PrintResults are value-returning functions. Rather than calculating
and storing the values these functions calculate, could the values be calculated as
they are being output in PrintResults? If so, would it be a good idea to do it?
3. The solution to the exam statistics problem makes use of a technique called
indexes with semantic content. Explain what this means in relation to this problem.
4. The heading for the output of the Calculating Exam Statistics program is coded
directly in the OpenFiles function. Remove this statement, prompt the user to enter a
heading, and write this heading on the output file.
5. Exercise 4 had the heading in the exam statistics program written in the OpenFiles
function. Would it be better to have the PrintResults function prompt for the heading?
6. Rewrite the Favorite Rock Group program using an enumerated type for class (or
level). Which code is more readable and self-documenting?
7. Design a complete testing strategy for the Favorite Rock Group program.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 2
Classes and Abstraction
KNOWLEDGE GOALS
To understand the difference between specification and implementation of an abstract
data type.
To understand the concepts of encapsulation and abstraction.
To understand how control and data abstraction facilitate modifiability and reuse.
To understand the basic class design principles.
To understand how encapsulation and information hiding are enforced by the C++
compiler.
SKILL GOALS
To be able to:
Declare a C++ class type.
Declare class objects, given the declaration of a class type.
Write client code that invokes class member functions.
Implement class member functions.
Organize the code for a C++ class into two files: the specification (.h) file and the
implementation file.
Write a C++ class constructor.
Chapter 9 introduced the concept of control abstraction, in which the outward operation of a
function is separated from its internal implementation. In this chapter, we add the analogous
concept of data abstraction, the separation of a data type’s logical properties from its
implementation. Data abstraction and control abstraction, together, are embodied by the
concept of the abstract data type. We first review abstract data types, and then introduce the
C++ syntax we can use to implement them: the class. Classes bind data and actions together

into self-contained entities called objects—which are the foundation of object-oriented
programming.

12.1 Abstract Data Types
We live in a complex world. To cope with complexity, the human mind engages in abstraction
—the act of separating the essential qualities of an idea or object from its details.
With abstraction, we focus on the what, not the how. For example, with respect to
automobiles, most of us know what the engine does, but fewer of us know precisely how the
engine works. Abstraction allows us to drive cars without having to be automotive engineers.
In the world of software, abstraction is essential for managing immense, complex projects.
In computer science courses, programs are usually understandable in their entirety. By
comparison, large software products, based on millions of lines of code, can only be
developed and maintained by using abstraction. To manage complexity, software engineers
regularly use two important techniques: control abstraction and data abstraction.
In Chapter 9, we defined control abstraction as the separation of the logical properties of an
action from its implementation. We engage in control abstraction whenever we reduce an
algorithm to an action performed by a function call. By invoking a library function, as in the
expression
we depend only on the function’s specification, which tells us what it does. We can use the
function without having to know its implementation (the algorithm that produces the result).
The sqrt function simplifies our program because the details involved in computing square
roots are hidden.
Abstraction techniques also apply to data. Every data type consists of a set of values (the
domain) and the allowable operations on those values. Data abstraction is the separation of a
data type’s logical properties from its implementation details. When we create a data type that
is not built into the programming language, we are engaging in data abstraction. The new type
is initially designed as an abstract data type (ADT), specifying its logical properties and
deferring the details of its implementation.
Abstract data type (ADT) A data type whose properties (domain and operations) are
specified independently of any particular implementation.
As with control abstraction, an abstract data type has both a specification (the what) and an
implementation (the how). The specification of an ADT describes the characteristics of the
data values and the behavior of its operations. The user of the ADT should need to see only
the specification, not the implementation, to use it.
Here’s a very informal specification of a list ADT that contains integer numbers:
TYPE
IntList
DOMAIN
Each IntList value is a collection of up to 100 separate integer numbers.
OPERATIONS

Create a list.
Insert an item into the list.
Delete an item from the list.
Search the list for an item.
Return the current length of the list.
Sort the list into ascending order.
Output the list.
Notice the absence of implementation details. We have not specified how the data are stored
(they could be in an array, or on a file, or in a struct) or algorithms for the operations.
Concealing the implementation prevents users from writing code that depends on it and frees
the implementor to refactor the implementation later, to make improvements.
Following is the specification of another ADT, one that might be useful for representing
TimeOfDay in a program.
TYPE TimeOfDay
DOMAIN
Each TimeOfDay value is a time of day in the form of hours, minutes, and seconds.
OPERATIONS
Create a time object.
Output the time.
Return an object containing the time, incremented by one second.
Compare two times for equality.
Determine if one time is “less than” (comes before) another.
Although we refer to “time” in our list of operations, we are careful to call this ADT
“TimeOfDay” to differentiate it from elapsed time, which also might be a useful ADT.
The specification of an ADT defines data values and operations in an abstract form that can
be given as documentation to both the user and the programmer. Ultimately, of course, the
ADT must be implemented in code. To implement an ADT, the programmer must do two
things:
1. Choose a concrete data representation of the abstract data, using existing data types.
2. Implement each of the allowable operations in terms of program instructions.
Data representation The concrete form of data used to represent the abstract values of
an abstract data type.
To implement the IntList ADT, we could choose a concrete data representation consisting of
a record with two items: a 100-element array in which to store the items and an int variable
that keeps track of the number of items in the list. To implement the IntList operations, we
must create algorithms based on the chosen data representation.
To implement the TimeOfDay ADT, we might use three int variables—one for the hours,
one for the minutes, and one for the seconds. Alternatively, we might use three strings. Or we
might keep the TimeOfDay as seconds and convert it to hours, minutes, and seconds as
needed. The specification does not confine us to any particular representation. As long as we

satisfy the specification, we are free to choose among alternative representations and their
associated algorithms. Our choice may be based on time efficiency (speed of execution),
space efficiency (amount of memory space), or simplicity and readability of the algorithms.
Over time, you will acquire knowledge and experience that will help you decide which
implementation is best for a particular context.
THEORETICAL FOUNDATIONS Categories of Abstract Data
Type Operations
In general, the operations associated with an ADT fall into one of three categories:
constructors, transformers, and observers.
An operation that creates a new instance of an ADT (such as a list) is a constructor.
Operations that change the value of an ADT, such as inserting an item into a list, are
transformers. (In the programming languages research community, they are also called
mutators because they yield a mutation of the ADT’s value.) A function that returns true if
a list is empty and false otherwise is an example of an observer (also known as an
accessor).
Some operations are combinations of observers and constructors. An operation that
takes two lists and merges them into a (new) third list is both an observer (of the two
existing lists) and a constructor (of the third list).
In addition to the three basic categories of ADT operations, two other categories are
sometimes defined: destructors and iterators. A destructor is the opposite of a
constructor; it cleans up an instance of an ADT just before its storage is released for
reuse. An example of an iterator is an operation that returns successive items in a list
each time it is called.
Constructor An operation that initializes a new instance (variable) of an ADT.
Transformer An operation that changes the value of the ADT; also known as a
mutator.
Observer An operation that allows us to observe the state of an instance of an ADT
without changing it; also known as an accessor.
Destructor An operation that cleans up the state of an ADT instance just prior to
releasing its storage for reuse.
Iterator An operation that allows us to process—one at a time—all the components
QUICK CHECK
12.1.1 What does the specification of an ADT describe?
12.1.2 What two things must a programmer do to implement an ADT?

12.2 C++ Classes
Thus far we have passed values to and from functions as arguments, on which our functions
performed some operation. We took the same approach even when we defined new data
types, such as a student record; that is, we have viewed data values as passive quantities
and the operations on them as separate actions (See FIGURE 12.1.)
However, an ADT consists of both data values and operations on them. Therefore, our
approach of passive data and separate, active functions is inappropriate for an ADT. It is
preferable to view an ADT as defining an active data structure—one that contains both data
and operations within a single, cohesive unit (see FIGURE 12.2). C++ supports this view
through the structured type known as a class.
Class A data type in a programming language that is used to represent an abstract data
type.
FIGURE 12.1 Data and Operations as Separate Entities

Description
FIGURE 12.2 Data and Operations as Separate Entities
In Figure 10.3, in Chapter 10, we listed the four structured types available in C++: array, struct,
union, and class. A class has components (class members) that include both data and
functions that manipulate those data.1
Class member A component of a class. Class members may be either data or functions.
Here is the syntax template for the C++ class:
Description
AccessModifier is defined as either of the two keywords, public or private:

Description
Later, we will add another modifier, protected. MemberList is one or more declarations of
fields or functions:
Description
Here is a C++ class declaration corresponding to the TimeOfDay ADT that we defined in
the previous section:
Description

Description
(For now, ignore the word const in the function prototypes. We explain this use of const later in
the chapter.)
The TimeOfDay class has nine members—four member functions (Increment, Write, Equal,
LessThan), three member variables (hours, minutes, seconds), and two constructs that look
something like functions, but with no return value. The latter are examples of a special
function called a class constructor. A constructor is a member function that is implicitly
invoked whenever a class object is declared (created). A constructor is always given the
name of the class itself. It is not preceded by either a return type or the keyword void.
Our class declaration includes two constructors, differentiated by their parameter lists. The
first constructor is parameterless and initializes a TimeOfDay object to some default value,
such as 00:00:00, when it is declared. Such a constructor is known in C++ as a default
constructor. The second has three int parameters, which, in this case, are used to initialize
the private data members when a TimeOfDay object is declared.
Description
As you might guess, the three data member variables (hours, minutes, and seconds) form
the concrete data representation for the TimeOfDay ADT. The member functions correspond
to the operations we listed for the TimeOfDay ADT: return a TimeOfDay object incremented by
one second, output the time, compare two times for equality, and determine if one TimeOfDay
object is less than another. Although the Equal and LessThan functions compare two TimeOfDay
variables, their parameter lists have only one parameter—a TimeOfDay variable. We’ll see why
when we look at the implementation of the class.
The declaration of the TimeOfDay class defines a data type but does not create variables of
the type. As shown earlier, class variables (more often referred to as class objects or class
instances) are created separately using normal variable declarations. Any software that
declares and manipulates TimeOfDay objects is called a client of the class.

Class object (class instance) A variable of a class type.
Client Software that declares and manipulates objects of a particular class.
Looking at the TimeOfDay class, you will see the reserved words public and private, each
followed by a colon. Class members declared following public and before private constitute
the public interface; clients can access these members directly. Class members declared
after the word private are not directly accessible to clients. If client code attempts to access a
private member, the compiler gives an error message.
Private members can be accessed only by the class’s member functions. In the TimeOfDay
class, the private variables hours, minutes, and seconds can be accessed only within
Increment, Write, Equal, and LessThan, not by client code. This separation of class members
into private and public parts is a hallmark of ADT design. To preserve the control and data
abstractions of an ADT, an instance of the ADT should be manipulated only through the public
interface. We will revisit this issue later in the chapter.
C++ does not require public and private members to appear in a specific order. By default,
class members are private; public turns on public access for succeeding declarations. To
switch back to declaring private members, use the private reserved word, as in the preceding
example. A class can have multiple public and private sections.
We can now explain the distinction between C++ structs and classes: in a struct, members
are public by default; in a class, they are private by default. In the C language, structs did not
allow functions as components. Therefore, in C++, most programmers use the struct as it
was used in C, to represent a record structure containing only data members, and then
implement ADTs only with classes.
MATTERS OF STYLE Declaring Public and Private Class
Members
Because the members of a class are private by default, we could write the TimeOfDay class
declaration as follows:
Description

The variables hours, minutes, and seconds are automatically private. The public part in this
example extends from the word public to the end of the class declaration.
Our preference is to write the public part first, emphasizing the public interface and
deemphasizing the private members. Because this practice also explicitly indicates which
members are private, it is more self-documenting.
Description
In this version, the reader immediately sees the public interface for the class, and there
is no question that the data members are private. We use this style throughout the
remainder of the text.
Implementing the Member Functions
Let’s take a look at how we implement the TimeOfDay class. There are some details we have
yet to cover formally, which we’ll point out along the way. Later, we’ll come back to the relevant
C++ rules. For now, we want to look at some concrete code, so you can see how a class is
implemented.
Constructors
The constructors for TimeOfDay are straightforward. In the default constructor, 0 is stored in
each data member.

Description
In the parameterized constructor, the parameters are stored in the corresponding members.
Description
Note how the name of the class precedes the name of each function, along with the :: scope
resolution operator, to specify the class to which the function definition belongs.
Increment
In this function we are returning a new object that is the same as the current object, but
incremented by one second. In C++, we also refer to the current object as the current
instance, meaning the object to which a member function is applied. Member functions are
defined within a class; thus, when you invoke one of them, it is running in the context of the
declarations within its class. This is a different way of working with a function than we’re used
to—the member function is not running separately at the level of main . We use different
terminology (instance to which it is applied) as a reminder that the function is executing in a
different environment.
The first step in Increment is creating a duplicate of the TimeOfDay object to which the
function is applied. To do so, we call the parameterized constructor, passing it the data
members of the current instance.
Description
Notice that we do not pass anything into Increment . Because it executes in the context of the
current instance, it automatically has access to the instance’s data members.
Next the seconds data member (of the duplicate) is incremented. If this action makes the
value greater than 59, seconds must be set to 0, and the minutes data member must be
incremented. If that makes minutes greater than 59, then it is set to 0, and the hours data
member is incremented. If the hours data member becomes greater than 23, it gets set to 0.

Description
Notice how we access the members of the instance as compared to the members of the
result object. We refer directly to members of the current instance (hours, minutes, seconds ).
Accessing members of any other object, however, requires dot notation (result.hours,
result.minutes, result.seconds ).
Wait—how can we access the data members of the result object? Aren’t they private?
Yes, but in C++, private only restricts access by client code. Within the implementation of a
class, we can access private members of objects of the same class.
Write
To make the time uniform, we want to output two digits for each field, so we must check
whether a value is a single digit. If it is, we output a leading 0. Again, notice that nothing is
passed into Write —it automatically has access to the members of the instance.

Description
LessThan
This Boolean operation compares two objects of class TimeOfDay : The first is the instance,
and the second is passed in through a parameter. As we saw with Increment, the members of
the other object must be accessed with dot notation.
How do we compare times? First we check the hours. If they are the same, we then check
the minutes. If they are the same, we check the seconds. Let’s look at this process in
algorithm form.
LessThan(In: otherTime)
Return value: Boolean
IF (hours < otherTime.hours)
Return True
ELSE IF (hours > otherTime.hours)
Return False
ELSE IF (minutes < otherTime.minutes)
Return True
ELSE IF (minutes > otherTime.minutes)
Return False
ELSE IF (seconds < otherTime.seconds)
Return True
ELSE
Return False
This algorithm can also be expressed using logical operators, as shown here:
hours < otherTime.hours || hours == otherTime.hours
&& minutes < otherTime.minutes || hours == otherTime.hours
&& minutes == otherTime.minutes &&
seconds < otherTime.seconds)
Which depiction is better? This is purely a matter of style. The first version is easier to read
and, therefore, to debug. The second version is more elegant. In this case we opt for
elegance.
Description
Equal

The two objects being compared by Equal are the current instance and the parameter. Equal
returns true only if all three pairs of data fields match.
Classes, Objects, and Members
Always remember that a class defines a type. Like any type, a class is a pattern for creating
values of that type. With a class, the values are objects. We say that we instantiate the class
to make an object. An object is an instance (concrete example) of its class. Think of a class
as a cookie cutter and objects of that class as the cookies.
Description
create two objects that are instances of the TimeOfDay class: time1 and time2 .
The pattern specified by the class is that each object of type TimeOfDay has member
variables called hours, minutes, and seconds . Thus time1 has its own variables called hours,
minutes, and seconds, and time2 has a separate set of variables called hours, minutes, and
seconds. time1 ’s hours, minutes, and seconds contain the values 0, 0, and 0, whereas time2 ’s
variables contain the values 17, 58, and 2. FIGURE 12.3 depicts the objects time1 and time2 .
In truth, the C++ compiler does not waste memory by placing duplicate copies of a member
function—say, Increment —into both time1 and time2 . Instead, the compiler generates just
one copy of Increment, which is executed whenever it is called from any class instance.
Nevertheless, the diagram in Figure 12.3 is a good mental picture of two different class
objects.
Be sure you are clear about the difference between the terms object and member. Figure
12.3 depicts two objects of the TimeOfDay class, and each object has nine members.

FIGURE 12.3 Conceptual View of Two Objects
Built-in Operations on Objects
Programmer-defined classes have many similarities to built-in types. For example, you can
declare as many objects of a class as you like. You can pass objects to functions and return
them as function values. Like any variable, an object can be automatic (created each time
control reaches its declaration and destroyed when control exits its surrounding block) or
static (created once when control reaches its declaration and destroyed when the program
terminates).
In other ways, C++ treats objects differently from built-in types. Most of the built-in
operations do not apply to objects. For example, you cannot use the + operator to add two
TimeOfDay objects, nor can you use the == operator to compare two TimeOfDay objects for
equality.
Two built-in operations that are valid for objects are member selection (.) and assignment
(=). You select an individual member with dot notation. The statement
Description
invokes the Increment function for the time1 object, creating a new object that is one second
later than time1, and assigning it to time3 . Assignment performs aggregate assignment of one
object to another with the following semantics: If x and y are objects of the same class, then

the assignment x = y copies the data members of y into x . Following is client code that
demonstrates member selection and assignment:
From the very beginning, you have been working with C++ classes for input and output.
The standard header file iostream contains the declarations of two classes—istream and
ostream . The C++ standard library declares cin and cout to be objects of these classes:
The istream class has many member functions, two of which—get and ignore —you have
seen in statements like these:
As with any C++ object, we use dot notation to select a particular member function to invoke.
You have also used C++ classes for file I/O. Header file fstream contains declarations for
the ifstream and ofstream classes. The client code
declares ifstream object dataFile, and then invokes its member function open to open file
input.dat for input.
As you can see, classes and objects are fundamental to all I/O activity in a C++ program.
Class Scope
In Chapter 9 we mentioned four kinds of C++ scope: local, global, namespace, and class
scope. Class scope applies to member names within structs, unions, and classes. To say
that a member has class scope means its name is bound to that class (or struct or union). If
an identifier with the same name is declared outside the class, the two identifiers are distinct.

Let’s look at an example. TimeOfDay has a member function named Write . In the same
program, another class (say, SomeClass ) could also have a member function named Write .
Furthermore, the program might have a global Write function. If the program has statements
like
Description
then the C++ compiler can distinguish among the three Write functions. In the first two, dot
notation denotes member selection for the specific objects. The first statement invokes the
Write function of the TimeOfDay class for the checkInTime object. The second statement
invokes the Write function of SomeClass for the someObject instance of that class. Because the
final statement does not use dot notation, the global Write function is called.
QUICK CHECK
12.2.1 Which C++ construct is designed to implement ADTs?
12.2.2 What distinguishes a class constructor from other member functions?
12.2.3 What is an active data structure?
12.2.4 Any software that declares and manipulates objects of a particular class X is
called what?
12.2.5 Write the declaration of a class object, called today, of class Date.
12.2.6 How would you call member function GetDay (which takes no parameters) of an
object called today of class Date?
1 In C++, a struct is almost identical to a class; however, because of its heritage from the C
struct construct, most programmers use class to implement an ADT, and limit their use of
struct to applications where a record is needed that has no associated operations.

12.3 Information Hiding
Conceptually, an object has an invisible wall around it, called the abstraction barrier, which
protects private data and functions from being accessed by client code. The barrier also
prohibits the object from directly accessing data and functions outside the object. This barrier
is a critical characteristic of classes and abstract data types.
For an object to share information with client code, the abstraction barrier needs an opening:
the public interface—the members of which are declared to be public . If the only public
members are functions and constants, and if all of the member variables are private, then the
client can only manipulate the object’s internal values indirectly—by calling functions in the
public interface.
Electrical engineers work with a similar concept called a black box, which is a module
whose inner workings remain hidden. Its user knows from a written specification what the box
does, but not how it does it. If the user connects wires to the box according to the
specification, then it works correctly (see FIGURE 12.4).
In software design, the same concept is called information hiding. Information hiding
enables client code to use a class without knowing anything about its implementation.
Information hiding also assures that the client cannot access private code or data in a way
that would compromise the correctness of the implementation.
Abstraction barrier The invisible wall around an object that encapsulates implementation
details. The wall can be breached only through the public interface.
Black box A module whose inner workings remain hidden from view.
Information hiding The encapsulation and hiding of implementation details to keep the
user of an abstraction from depending on or incorrectly manipulating these details.
FIGURE 12.4 Black Box
We have discussed encapsulation and information hiding previously. In Chapter 8, we
mentioned the possibility of hiding a function’s implementation in a separate file. Now we look
at hiding the implementations of class member functions by placing them in files that are kept
separate from client code.

The creator of a C++ class chooses which members will be private versus public. Because
information hiding is so fundamental to data abstraction, most classes exhibit a typical pattern:
Data variables are private, and the functions that manipulate them are public. Making
variables public would allow the client to inspect and modify their values directly, which would
compromise the abstraction.
The TimeOfDay class exemplifies this organization. Its variables are private, so the client
can’t access them. As a consequence, the following client statement results in a compile-time
error:
Description
Because only the class’s member functions can access the private data, the creator of the
class has complete control over how client code uses it. If it is desirable to let the client
inspect private data, then a class can provide observer functions. The TimeOfDay class has
four observers: Write, Increment, Equal, and LessThan. Because these functions shouldn’t
modify the private data, they are declared with const following the parameter list:
Description
C++ refers to these as const member functions. Within the body of a const member function,
a compile-time error occurs if a statement tries to modify any private instance variables. You
should use const with member functions that are not supposed to modify private data, as a
way of ensuring that they don’t.
User-Written Header Files
As you create your own ADTs, you will often find that they can be useful in more than one
program. For example, consider an enumeration type consisting of the names of the 12
months of the year. Instead of typing
at the beginning of every program that uses the Months type, you can put this declaration into a
file named, say, months.h. You can then use #include, specifying months.h, to have the C++
preprocessor insert the contents of the file, just as we do for standard header files like

iostream. (Although many C++ systems use the file name extension .h [or no extension at all]
to denote header files, other systems use extensions such as .hpp or .hxx.)
There is just one small difference that you need to keep in mind. When a header file name is
written in angle brackets, like this:
the preprocessor looks for the file in the standard C++ include directory. For your own header
files, you should enclose the name in double quotes,
Description
which causes the preprocessor to look for the file in the current directory (the one containing
your program code), as shown in FIGURE 12.5.
Header files also play a role in preserving information hiding when we implement a class, as
we see next.
Description
FIGURE 12.5 Including Header Files
Specification and Implementation Files
An ADT consists of two parts: a specification and an implementation. The specification
sufficiently describes the behavior of the data type to enable a client to use it. The
implementation, consisting of both the concrete data representation and the code for the
operations, is hidden.

The TimeOfDay class declaration serves as its specification, presenting the public interface
to the user in the form of function prototypes. To implement TimeOfDay, we provide function
definitions for its member functions.
In C++, it is customary (but not required) to place the class declaration and the class
implementation in separate files. One file—the specification file—is a header (.h ) file
containing only the class declaration. The second file—the implementation file—contains the
function definitions. Let’s look first at the specification file.
The Specification File
Following is the specification file for TimeOfDay. This is the same as what we saw before, but
including preconditions and postconditions to specify the semantics of the member functions
as unambiguously as possible.
Description
In principle, a specification file should not reveal any implementation details to the user of
the class. The file should specify what each member function does without disclosing how it

does it. However, as you can see in the preceding class declaration, some implementation
details are visible: The concrete data representation is listed in the private part. Nonetheless,
the data representation is still considered hidden information in the sense that the compiler
prohibits client code from accessing the data directly.
Here is a client program that manipulates two objects of class TimeOfDay. This program is
written without knowing how the class is implemented.

Description
Description
Description
The Implementation File
The specification (.h ) file for TimeOfDay contains only the class declaration. The
implementation file provides the function definitions for all the class member functions. In the
opening comments of the implementation file below, we document the file name as
TimeOfDay.cpp. Your system may use a different file name suffix for source code files—
perhaps .c, .C, or .cxx.
Here is the code shown previously. We do not repeat the documentation from the function
prototypes in the specification file. We do add documentation for the programmers who will
maintain the code. Immediately following the program code, we explain the new features.

Description


Description
This implementation file demonstrates several important points.
1. The file begins with the preprocessor directive
Description
Both the implementation file and the client code must #include the specification file.
FIGURE 12.6 illustrates this shared access to the specification file, which guarantees
that all declarations related to an abstraction are consistent. That is, both client.cpp and
TimeOfDay.cpp reference the same declaration of the TimeOfDay class, located in
TimeOfDay.h.
2. In the heading of each function definition, the name of the member function is prefixed by
the class name (TimeOfDay ) and the C++ scope resolution operator (::). As discussed
earlier, several different classes might potentially have member functions with the same
name—say, Write. In addition, there may be a global Write function that is not a member
of any class. The scope resolution operator eliminates any uncertainty about which
particular function is being defined.

FIGURE 12.6 Shared Access to a Specification File
3. Although clients of a class must use the dot operator to refer to class members (for
example, startTime.Write() ), members of a class refer to one another directly without
using dot notation. Looking at the body of the Increment function, you can see that the
statements refer directly to the member variables hours, minutes, and seconds without
using the dot operator.
An exception to this rule occurs when a member function manipulates two or more
class objects. Consider the Equal function. Suppose that the client code has two class
objects, startTime and endTime, and uses the statement
At execution time, the startTime object is the object to which the Equal function is applied.
In the body of the Equal function, the relational expression
Description
refers to members of two different objects. The unadorned identifier hours refers to the
hours member of the instance for which the function is invoked (that is, startTime ). The
expression otherTime.hours refers to the hours member of the object that is passed to the
parameter, otherTime, as a function argument: endTime.
4. Increment, Write, Equal, and LessThan are observer functions; they do not modify the
private data. Because we have declared them to be const member functions, the
compiler prevents these functions from assigning new values to the private data. The use

of const is both an aid to the user of the class (a visual signal that this function does not
modify any private data) and an aid to the class implementor (a way of preventing
accidental modification of the data). Note that the word const must appear in both the
function prototype (in the class declaration) and the heading of the function definition.
Compiling and Linking a Multifile Program
Now that we have created a specification file and an implementation file for our TimeOfDay
class, how do we (or any other programmer) make use of these files in our programs? Let’s
begin our exploration of this issue by looking at the notion of separate compilation of source
code files.
In earlier chapters, we have referred to the concept of a multifile program—a program
divided up into several files containing source code. In C++, each of these files may be
compiled separately and at different times. In this process, the compiler translates each
source code file into an object code file. FIGURE 12.7 shows a multifile program consisting of
the source code files myprog.cpp, file2.cpp, and file3.cpp. We can compile each of these
files independently, yielding the object code files myprog.obj, file2.obj, and file3.obj.
Although each .obj file contains machine language code, it is not yet in executable form. The
system’s linker program brings the object code together to form an executable program file.
(In Figure 12.7, we use the file name suffixes .cpp, .obj, and .exe. Your C++ system may use
different file name conventions.)
Files such as file2.cpp and file3.cpp typically contain definitions for functions that are
called by the code in myprog.cpp. With separate compilation, modifying the code in one file
requires recompiling only that file. The new .obj file is then relinked with the other existing .obj
files. Of course, if a modification changes a function’s public interface, then client files must
also be modified and recompiled.
Returning to our TimeOfDay class, let’s assume we have created the TimeOfDay.h and
TimeOfDay.cpp files. Now we can compile TimeOfDay.cpp into object code. You are probably
using a C++ system that provides an integrated environment—a program that bundles the
editor, the compiler, and the linker into one package. Integrated environments put you back
into the editor when a compile-time or link-time error occurs, pinpointing the location of the
error. Some integrated environments also manage project files. Project files contain
information about all the constituent files of a multifile program. With project files, the system
automatically recompiles or relinks any files that have become out of date because of
changes to other files of the program.
If you are using a command line system, you will write one-line commands to the operating
system telling it to compile or link certain files. Whichever environment you use—integrated
environment or the command line—the overall effect is the same: The source code files are
compiled into object code files, which are linked into an executable program, which is then
executed.

Description
FIGURE 12.7 Separate Compilation and Linking
Before leaving the topic of multifile programs, we must stress an important point. In the
example in Figure 12.6, the files TimeOfDay.h and TimeOfDay.obj must be available to users of
the TimeOfDay class. The user needs to examine TimeOfDay.h to see what TimeOfDay objects do
and how to use them. A user must also be able to link their program with TimeOfDay.obj to
produce an executable program. However, the user does not need to see TimeOfDay.cpp. To
use the terminology introduced earlier, the implementation of TimeOfDay should be treated as a
black box.
The main purpose of abstraction is to simplify the programmer’s job by reducing complexity.
Users of an abstraction should not have to look at its implementation to learn how to use it,
nor should they have to write programs that depend on implementation details. In the latter
case, any changes in the implementation could “break” the user’s programs. In Chapter 8, the
Software Engineering Tip box entitled “Conceptual Versus Physical Hiding of a Function
Implementation” discussed the hazards of writing code that relies on implementation details.
QUICK CHECK
12.3.1 How does the use of a specification file help to provide encapsulation and
information hiding for a class?
12.3.2 Where does the :: scope resolution operator appear in a member function
definition within an implementation file?
12.3.3 What is information hiding?

12.3.4 What type of file is created as part of the compilation of a multifile program
before an executable is produced?
12.3.5 Which file, specification or implementation, omits member function bodies?

12.4 What Is an Object?
We started this chapter by talking about abstraction and abstract data types. We then
examined the class construct, which is the C++ mechanism for implementing an ADT. We
have discussed how information hiding can be accomplished through the design of the public
interface and by having specification and implementation files. Now let’s step back and take a
broader view of objects and their use.
In object-oriented programming (OOP), the term object has a specific meaning: It is a self-
contained entity encapsulating data and operations on the data. In other words, an object
represents an instance of an ADT. An object has an internal state (the current values of its
data, called attributes ), and it has a set of methods (operations, which are implemented by
functions in C++). If a class is properly designed, the methods are the only means by which
an object’s state can be modified by another object. To inspect the state of the object,
methods are also employed; in addition, some objects provide public constants that can be
inspected. For example, the string class makes the npos constant public, so we can
determine the maximum size of a string.
Attributes The data represented by an object; its internal state.
An object-oriented program consists of a collection of objects that communicate with one
another by message passing. If object A wants object B to perform some task, object A
sends a message with the name of the object (B, in this case) and the name of the method to
execute. Object B responds by executing this method in its own way, possibly changing its
state and sending messages to other objects.
As you can tell, an object is conceptually quite different from a traditional data structure. A C
struct is a passive data structure that contains only data and is acted upon by a program. In
contrast, an object is an active data structure; the data and the code that manipulates the data
are bound together within the object. In OOP jargon, an object knows how to manipulate its
own state.
The vocabulary of the Smalltalk programming language, which pioneered many ideas
related to object-oriented programming, has influenced the vocabulary of OOP. The literature
of OOP is full of phrases such as “methods,” “attributes,” and “sending a message to.” Here
are some OOP terms and their C++ equivalents:
OOP
C++
Object
Object or class instance
Attribute
Data member
Method
Member function
Message passing
Function application (of a public member function)

Let’s review the TimeOfDay class, albeit changed slightly to reflect object-oriented
terminology and principles. There are six public methods (called responsibilities in object-
oriented terminology): Increment, Write, Equal, LessThan, and the two constructors. One
constructor takes the hours, minutes, and seconds as parameters, and the other sets the
TimeOfDay to zero.
Responsibilities The public operations provided by a class for outside use.
In object-oriented terminology, two types of responsibilities (operations) exist: action
responsibilities and knowledge responsibilities. All of TimeOfDay ’s public methods are either
constructors or knowledge responsibilities. None of them takes action (changes the state of
the object). As you can see, it is important for an object to be able to report on its own status;
that is, each object should have methods that report the internal state of its private data in a
manner that is appropriate to the information-hiding goals of its public interface. Given such
methods, we do not need a Write method. If the client code can inspect the internal state (not
change it), then the code can output a TimeOfDay object in a form that is relevant to the
problem using the ADT.
Here is the revised specification for the TimeOfDay class in which the Write function has
been removed. We omit the documentation that hasn’t changed.
Description
Here is the part of the implementation file for class TimeOfDay that implements the new
functions:

MAY WE INTRODUCE John von Neumann
Description

John von Neumann was a brilliant mathematician, physicist, logician, and computer
scientist. His astonishing memory and the phenomenal speed at which he solved
problems are legendary. Von Neumann used his talents not only for furthering his
mathematical theories, but also for memorizing entire books and reciting them years after
he had read them.
John von Neumann was born in Hungary in 1903, the oldest son of a wealthy Jewish
banker. He was able to divide eight-digit numbers in his head by the age of 6. He entered
high school by the time he was 11, and it wasn’t long before his math teachers
recommended that he be tutored by university professors. In spite of his interest in
mathematics, von Neumann enrolled at the University of Berlin in 1921 to study chemistry.
This decision was a compromise with his father, who wanted him to have a career that
would allow him to make money. Five years later, he received his diploma in chemical
engineering from the Technische Hochschule in Zürich. In the same year, however, von
Neumann also received his doctorate in mathematics from the University of Budapest,
with a thesis on set theory! During the period from 1926 to 1929, von Neumann lectured in
Berlin and Hamburg while holding a Rockefeller fellowship for postdoctoral studies at the
University of Göttingen.
Von Neumann came to the United States in the early 1930s to teach at Princeton, while
still keeping his academic posts in Germany. He resigned the German posts when the
Nazis came to power. While at Princeton, he worked with the talented British student Alan
Turing, who would later become an important figure in computing theory. During World War
II, von Neumann was hired as a consultant for the U.S. Armed Forces. Because of his
knowledge of hydrodynamics, he was also called upon to participate in the construction of
the atomic bomb in 1943.
Even though bombs and their performance fascinated von Neumann for many years, a
fortuitous meeting in 1944 with Herbert Goldstine, a developer of one of the first electronic
digital computers, introduced the mathematician to this new field. Von Neumann’s chance
conversation with Goldstine in a train station sparked a new fascination for him. He started
working on the stored program concept and concluded that internally storing a program
eliminated the hours of tedious labor required to reprogram computers (in those days). He
also developed a new computer architecture to perform this storage task. In fact, today’s
computers are often referred to as von Neumann machines because the principles he
described have proven so successful. Changes in computers over the past 40 years have
been primarily in terms of the speed and composition of the circuits; the basic concepts
developed by von Neumann have remained largely intact.
During the 1950s, von Neumann was a consultant for IBM, where he reviewed
advanced technology projects. One such project was John Backus’s FORTRAN, one of
the first high-level programming languages. Von Neumann reportedly questioned why its
development was necessary, asking why anyone would want more than one machine
language. Von Neumann died in Washington, D.C., at the age of 54. We can only imagine
the contributions that his brilliant mind might have made to computer science, had he lived
longer.
QUICK CHECK
12.4.1 What is an object?

12.4.2 What is message passing?

12.5 Class Design Principles
Because classes are a fundamental building block of object-oriented programming, we now
consider the principles that result in a well-designed class that can be used in the context of
larger problems.
Encapsulation
A primary principle for class design is encapsulation. The dictionary tells us that a capsule
is a sealed container that protects its contents from outside contaminants or harsh conditions.
To encapsulate something is to place it into a capsule. In object-oriented programming, the
capsule is a class, and its attributes are the contents we want to protect. By itself, the class
construct doesn’t protect its attributes. Instead, we must consciously provide that protection
by defining a formal interface that limits access from other classes.
Formal interface The components of a class that are externally accessible, which consist
of the class’s nonprivate attributes and responsibilities.
Reliable The property of a unit of software that it can be counted on to always operate
consistently, according to the specification of its interface.
What is a formal interface? In terms of class design, it is a description of all the ways the
class may interact with other classes. The collection of responsibilities and nonprivate
attributes defines the formal interface. In C++, we implement responsibilities with functions,
and attributes are data fields.
If an object’s state can be changed only through a well-designed interface, then bugs in the
rest of the application can’t affect it in unintended ways. As long as we design the class so
that its objects can handle any data that are consistent with interface, we know it is a reliable
unit of software.
Here’s an analogy that illustrates the difference between a class that is encapsulated and
one that is not. Suppose you are a builder, building a house in a new development. Other
builders are working in the same development. If each builder keeps their equipment and
materials within the property lines of the house they are building, and enters and leaves the
site only via its driveway, then construction proceeds smoothly. The property lines
encapsulate the individual construction sites, and the driveway is the only interface by which
people, equipment, and materials can enter or leave a site. Now imagine the chaos that would
occur if builders started putting their materials and equipment in other sites without telling one
another. And what would happen if they began driving through other sites with heavy
equipment to get to their own? The materials would get used in the wrong houses, tools would
be lost or run over by stray vehicles, and the whole process would break down. FIGURE 12.8
illustrates this situation.

Description
FIGURE 12.8 Encapsulation Draws Clear Boundaries Around Classes; Failing to Encapsulate
Classes Can Lead to Chaos
Let’s make this analogy concrete in C++ by looking at two interface designs for the same
Date class—one encapsulated and the other not encapsulated.
Description
The interface on the right allows client code to directly change the fields of a Date object.
Thus, if the client code assigns the values 14, 206, and 83629 to these fields, you end up with
a nonsense date of the 206th day of the 14th month of the year 83629. The encapsulated
implementation on the left makes these fields private. It then provides a public method that
takes date values as arguments and checks that the date is valid before changing the fields
within the object.

This example shows that there is no special C++ syntax for encapsulation. Rather, we
achieve encapsulation by carefully designing an interface to ensure that objects have
complete control over what information enters and leaves them.
Encapsulation greatly simplifies the work of a programming team, because each class can
be developed by a different team member, without worrying about how other classes are
implemented. In a large project, encapsulation permits programmers to work independently on
different pieces. As long as each class meets its design specification, then the separate
classes can interact safely.
Design specification The written description of the behavior of a class with respect to its
interface.
What do we mean by design specification? Given a formal interface to a class, the design
specification is additional written documentation that describes how a class will behave for
each possible interaction through the interface. We should be very clear here that we are
referring to the problem-solving phase. The design specification is part of stating the problem.
It is distinct from the specification file in the implementation phase, which defines the interface
to a class. Depending on the context, we may refer to the design specification simply as the
specification.
The formal interface is where we define how we will call a method, and the design
specification is where we describe what the method will do. You can think of the formal
interface as the syntax of a class, and the specification as its semantics. By definition, the
specification includes the formal interface. We have seen how this information can be written
as preconditions and postconditions.
Abstraction
Encapsulation is the basis for abstraction in programming. We’ve seen that there are two
types of abstraction: data abstraction and control abstraction. As an example of data
abstraction, consider that the external representation of a date might be integer values for the
day and year, and a string that specifies the name of the month. But we might implement the
date within the class using a standard value that calendar makers call the Julian day, which is
the number of days since January 1, 4713 b.c.
Abstraction The separation of the logical properties (interface and specification) of an
object from its implementation (internal data representation and algorithms)
The advantage of using the Julian day is that it simplifies arithmetic on dates, such as
computing the number of days between dates. All of the complexity of dealing with leap years
and the different number of days in the months is captured in formulas that convert between
the conventional representation of a date and the Julian day. From the user’s perspective,
however, the methods of a Date object receive and return a date as two integers and a string.
FIGURE 12.9 shows the two implementations, having the same external abstraction.

In many cases, the external and internal representations are identical. We don’t tell the user
that, however, because we may want to change the implementation in the future. For
example, we might initially develop a Date class using variables for the month, day, and year.
Later, if we decide that a Julian day representation is more efficient, we can rewrite the
implementation. Because encapsulation has provided data abstraction, the change doesn’t
affect the client code.
This example also illustrates control abstraction. Suppose that the specification for the Date
class says that it handles leap-year rules. In the Julian day implementation, only the
conversion formulas handle those rules; the other responsibilities merely perform arithmetic
on the Julian day number.
A user may assume that every Date responsibility separately deals with leap years. Control
abstraction lets us program a more efficient implementation and then hide those details from
the user.
Description
FIGURE 12.9 Data Abstraction Permits Different Internal Representations for the Same
External Abstraction
Designing for Modifiability and Reuse
Applying the principle of abstraction has two additional benefits: modifiability and reuse.
Modifiability The property of an encapsulated class definition that allows the
implementation to be changed without having an effect on code that uses it (except in
terms of speed or memory space).
Reuse The ability to include a class in client code without additional modification to either
the class or the client code.

Encapsulation enables us to modify the implementation of a class after its initial
development. Perhaps we are rushing to meet a deadline, so we create a simple but inefficient
implementation. In the maintenance phase, we then replace the implementation with a more
efficient version. The modification is undetectable with the exception that applications run
faster and require less memory.
An encapsulated class is self-contained, which means we can import and use it in other
applications. Reuse also means that a class can be extended to form new related classes.
For example, a utility company has software to manage its fleet of vehicles. As shown in
FIGURE 12.10, a class that describes a Vehicle can be used in multiple applications. Each
application can add extensions to the Vehicle class to suit its particular requirements. Reuse
is a way to save programming effort. It also ensures that objects have consistent behavior
wherever they are used, which helps avoid errors.
Of course, preparing a class that is suitable for wider reuse requires us to think beyond the
immediate situation. Such a class should provide certain basic services that enable it to be
used more generally; for example, it should have observers that enable client code to retrieve
any information from an object that we envision as potentially useful.
Not every class needs to be designed for general reuse. In some cases, we merely need a
class that has specific properties for the problem at hand and that won’t be used elsewhere. If
you are designing a class that may be used in other situations, however, then it is a good idea
to make it more general.
Keep in mind that even though C++’s class construct provides a mechanism to support
encapsulation, it is up to the programmer to use this capability in a way that results in actual
encapsulation. There is no keyword or construct that distinguishes a class as encapsulated.
Instead, the programmer must draw the boundaries around the class in a manner that keeps
other code out.
Description
FIGURE 12.10 Reuse
There are two types of boundaries we can draw: physical and visual. We can physically keep
a user from accessing members in a class by declaring them to be private, and we can make
the class implementation invisible to a user by the appropriate use of the header and
implementation files.

Mutability
An immutable object cannot be changed after it is instantiated; a mutable object has at least
one function (method) that allows the client to change the value of a data member in the
object. Mutability is a key distinguishing characteristic of the interface of an object. Although
immutable objects are naturally encapsulated, because they are immune to change, we must
take special care to ensure that mutable objects remain encapsulated.
Mutability The ability of a client to change the value(s) of an object’s state (data
members) after it is created.
Our TimeOfDay class is immutable because none of its methods allow the client to change
any of its values. Had the Increment function actually changed the instance to which it was
applied, the class would have been mutable instead.
Let’s look at an example of a mutable object. Suppose we are creating a database of birth
records for a hospital. A birth record is an object that contains the following information:
Birth Record
Date of birth
Time of day of birth
Mother’s name
Father’s name
Baby’s name
Baby’s weight
Baby’s length
Baby’s gender
A nurse enters this information into the database shortly after the baby is born. In some
cases, the parents may not have chosen a name for the baby yet. Rather than keep the nurse
waiting, the database allows all of the other information to be entered and creates a Birth
Record object with an empty string for the name. Later, when the name is chosen, the nurse
changes the name in the database.
There are two ways to change this database record. One would be to call a method that
directly changes the value in the baby’s name field. For example, we could write the function
as follows:
Given an instance of the BirthRecord class called newBaby, we can call this method with the
following statement:
Description

Such a method is called a transformer or a mutator. Having a transformer makes Birth-
Record a mutable class. Note that there is no special C++ syntax to denote that SetBabyName is
a transformer. Instead, a method is a transformer simply by virtue of what it does: It changes
the information stored in an existing object. We can ensure that a method is not a transformer
only by using const in its heading.
Wouldn’t it be easier to just make the babysName field public and to assign a new value to it
without calling a method? Yes, but that would break the encapsulation of the BirthRecord
class. Making the change through a transformer preserves encapsulation because it permits
us to employ data and control abstraction. For example, we could later enhance this
transformer to check that the new name contains only alphabetic characters.
Alternatively, we could make BirthRecord an immutable class. For such a design, we create
a new record, using the information, except the name, from the old record, and insert the new
name at that point. For example, the following is a constructor that takes a BirthRecord object
as an argument and automatically does the copying:
We would then update the birth record as follows:
Note that this statement doesn’t change the old object, but rather it creates a new object.
As you can see, using the transformer is simpler. It is also faster for the computer to assign
a new value to a field than to create a new object.
SOFTWARE MAINTENANCE CASE STUDY Comparing Two
TimeOfDay Objects
MAINTENANCE TASK: The TimeOfDay class has two Boolean functions: LessThan and
Equal. You are asked to enhance this class with a Boolean function that compares two
TimeOfDay objects and returns the value of an enumerated type that describes the
relationship between the instance and the parameter. The return type of this function must
be a member of RelationType, an enumeration type with three values:

Description
If the object to which the function is applied comes before the parameter object, the
function returns BEFORE. If the instance object comes after the parameter object, the
function returns AFTER. Otherwise, the function returns SAME.
You may wonder why the enumeration type doesn’t have EARLIER, SAME, and LATER values,
which would make more sense with time. But we are designing RelationType to make
sense in comparing almost anything from money to names to dates’ another example of
abstraction at work again, and especially in the service of reuse.
This looks easy. The following algorithm should work:
Description
This certainly works, but the TimeOfDay class seems to be a work in progress, so why not
remove the LessThan and Equal functions and keep just the ComparedTo function? You check
with the person asking for the enhancement and she says that this was her plan all along.
Now the algorithm has to be rewritten so that it does not depend on LessThan. First we
compare to see if hours is greater or less than the hours in the other time. If it is neither,
then it is equal and we go on to repeat the comparison for minutes. If the minutes are equal,
we test the seconds. At each stage we either return BEFORE or AFTER or we go on to the next
stage, until we get to seconds. Then, if the seconds are also equal, we return SAME.
Description

Description
If RelationType is going to be used with other classes, then its declaration should be put
into a header file and included in the TimeOfDay class. Here is the revised class and a client
class that creates and manipulates the new version.
File RelationType.h:
enum RelationType {BEFORE, SAME, AFTER};
Here is the revised TimeOfDay.h specification file:

Description
Here is the revised TimeOfDay.cpp implementation file:
Description

Description
Here is a driver program to demonstrate use of the new TimeOfDay class:
Description

Description
Finally, here is the output:
QUICK CHECK

12.5.1 What is a design specification?
12.5.2 What do we call a method that changes the state of an object?
12.5.3 How can you determine if a class is immutable?

12.6 The Name ADT
We have presented the ADT TimeOfDay and implemented it as a C++ class. It can be
used in any program that needs a TimeOfDay object. Now let’s look at another ADT that will be
useful in the future: the Name ADT.
In Chapter 4, we displayed a name in different formats. In Chapter 9, the Health Profile
program used a name. Adding a name to the BMI and the Mortgage programs would make
sense. Let’s stop this duplication of effort and do the job once and for all—as an abstract data
type.
We need to make the domain and operations general enough that they can be used in any
program that keeps track of a name. The informal specification of the ADT is given here:
TYPE
Name
DOMAIN
Each Name is a name in the form of first name, middle name, and last name.
OPERATIONS
Construct a Name instance
Inspect the first name
Inspect the middle name
Inspect the last name
Inspect the middle initial
Compare two names for “before,” “same,” and “after”
Note that there is no operation to output the name. Because we allow the user to inspect
the parts of the name, they can combine the parts to suit their purpose.
We create the Name ADT in two stages: specification, followed by implementation. The
result of the first stage is a C++ specification (.h ) file containing the declaration of a Name
class. This file must also describe the semantics of each ADT operation.
The second stage—implementation—requires us to (1) choose a concrete data
representation for a name, and (2) implement each of the operations as a C++ function
definition. The result is a C++ implementation file.
Specification of the ADT
The domain of our ADT is the set of all names made up of a first, middle, and last name. To
represent the Name ADT as program code, we use a C++ class named Name. The ADT
operations become public member functions of the class. Let’s now specify the operations
more carefully.
Construct a Name Instance
We use a C++ default constructor to create an instance of a Name ADT. The default
constructor for TimeOfDay sets the hours, seconds, and minutes to zero. Blanks would be the
logical equivalent for class Name.

The parameterized constructor must supply three arguments for this operation: first name,
middle name, and last name. Although we haven’t yet determined a concrete data
representation for a name, we must decide which data types the client should use for these
arguments. The logical choice is for each value to be represented by a string. But what if we
want to change a name after it has been constructed? Let’s not allow the user to do this; that
is, let’s make Name an immutable class.
Inspect the Name’s First, Middle, and Last Names
All three of these operations are observer operations. They give the client access—albeit
indirectly— to the private data. In the Name class, we represent these operations as value-
returning member functions with the following prototypes:
Inspect the Middle Initial
This operation returns the first letter of the middle name. Should we return it as a string or as a
char variable? It doesn’t matter, as long as we are consistent in our code and documentation.
Let’s make this a char function.
Compare Two Names
This operation compares two names and determines whether the first name comes before the
second, the names are the same, or the first name comes after the second. To indicate the
result of the comparison, we use the enumeration type we used for the TimeOfDay class:
Then we can code the comparison operation as a member function that returns a value of
type RelationType. Here is the function prototype:
Description
Note that the name being compared to otherName is the object (instance) for which the
member function is invoked. For example, the following client code tests whether name1
comes before name2:
Description

Description
We are now almost ready to write the C++ specification file for our Name class. However, the
class declaration requires us to include the private part—the private variables that are the
concrete data representation of the ADT. Choosing a concrete data representation properly
belongs in the ADT implementation phase, not the specification phase. To satisfy the C++
class declaration requirement, however, we now choose a data representation. The simplest
representation for a name is three string values—one each for the first, middle, and last. Here,
then, is the specification file containing the Name class declaration.

Description
Description
Notice that we use the word “Get” in the name of our observer functions. We did the same
in the TimeOfDay class. Using “Get” as a prefix to the field name is an object-oriented
convention used by many programmers. The corresponding name for transformers that
change the value of a field would be “Set” preceding the field. In fact, many programmers refer
to these kinds of operations generically as getters and setters.
Implementation File
We have already chosen a concrete data representation for a name, shown in the
specification file as the string variables first, middle, and last. Now we implement each
class member function, placing the definitions into a C++ implementation file named Name.cpp.
The implementations of all but the ComparedTo function are so straightforward that no
discussion is needed.
To compare two names, first we look at the last names. If they are different, we decide
which name is alphabetically first. If the last names are the same, we next look at the first
names. If the first names are the same, we have to look at the middle name. As so often
happens, we can use this algorithm directly in our function.

Description

Description
Here is a driver program that creates two Name objects and manipulates them:

Description
Description
Finally, here, is the output:
Description
QUICK CHECK

12.6.1 Does the Name ADT create instances of mutable or immutable objects?
12.6.2 What are the observer methods of the Name ADT?

12.7 Composition
Two classes typically exhibit one of three relationships: They are independent of each other,
they are related by inheritance, or they are related by composition. Here we cover
composition : the relationship in which the internal data of one class includes an object of
another class as a data member. Stated another way, an object is contained within another
object.
Composition The relationship between classes in which one class contains an instance
of another class as one of its attributes.
C++ does not have (or need) any special language notation for composition. You simply
declare an object of one class to be one of the data members of another class. Let’s look at
an example.
Design of an Entry Class
You are developing a program to represent an appointment book. Each Day object will be a
sorted list of Appointment objects. In preparation, you decide to build an Entry ADT with two
fields, an object of a Name ADT and an object of a TimeOfDay ADT. You may need to add
more information for an Appointment object later, but this gives you a start. Constructing this
object should be easy because you already have a TimeOfDay class and a Name class. For the
purpose of an appointment calendar, you decide to ignore the person’s middle name or initial
and the seconds in the time. You can always add the middle name later. Of course, you do
need operations that return the name and TimeOfDay to the client program.
Let’s call the operations GetNameStr, which returns a name composed of the first and last
names, and GetTimeStr, which returns the hours and minutes with a colon between the two
values. Of course, we need constructors. How many? Well, you know that the Name class has
two constructors: one that takes the parts of the name as parameters and one that sets the
fields to blanks. The same is true of the TimeOfDay class. Thus we should have a default
constructor for the Entry class, which calls the default constructors for Name and TimeOfDay,
and a parameterized constructor, which passes its parameters to Name ’s and Time ’s
parameterized constructors.
We now know enough to write the specification file.

Description
Implementing the default class constructor just involves invoking the default constructors for
the Name and TimeOfDay objects. In C++, default constructors are called automatically (although
we’ve shown them explicitly in prior examples, as a matter of good documentation).
Therefore, we can also leave the body of the default constructor for Entry empty, which we do
here so you can see an example of this coding style.
The parameterized constructor must pass its parameters to the Name and Time constructors.
To do so, we use a constructor initializer. This C++ construct allows you to pass the
information needed to construct an object that is declared in another class. The syntax is the
heading of the containing class’s constructor followed by a colon (: ) and the name of a
member object followed by a parameter list corresponding to the parameterized constructor

for the class of the member object. If multiple constructor initializers are present, they are
separated by commas.
Description
The body for this function will be empty. The system takes care of constructing the Name and
TimeOfDay objects. Here is the implementation file for class Entry :
Description
Description
Here is a simple driver that creates and outputs a couple of Entry objects:

When we try to run this simple program, we get the following error:
Description
How can that be? Isn’t there just one copy of file RelationType.h ? Yes, but it is included in
both TimeOfDay and Name. As a consequence, the preprocessor thinks RelationType is defined
more than once. This happens often, so we have to tell the preprocessor to include file
RelationType.h only if it hasn’t been included before. The widely used solution to this problem
is to write RelationType.h this way:
Description
The lines beginning with # are directives to the preprocessor. RELATION (or any identifier you
wish to use) is a preprocessor identifier, not a C++ program identifier. In effect, these
directives say:
If the preprocessor identifier RELATION has not already been defined, then
1. Define RELATION as an identifier known to the preprocessor, and
2. Let the declaration of the enum RelationType pass through to the compiler.

If a subsequent #include "RelationType.h” is encountered, the test #ifndef RELATION will
fail. The declaration will not pass through to the compiler a second time.
The multiple definition error has now been resolved, but there is another error:
Description
What could be wrong with this statement? We just created a string out of a string, an integer
value, a colon, and another integer value. We have used concatenation to build strings since
Chapter 2. Numbers are converted to strings for output. What’s different about this statement?
C++ automatically converts integers to strings for output, but there is no type cast from
integers to strings anywhere except for output.
To create a string including integers, we could write it out to a file and then read it back in as
a string. This approach would work, but it would be very slow. (File access can take more
than a million times longer than memory access.) Fortunately, there is a class called
ostringstream, which allows us to write values to a string as if we were writing them to a file.
Because the data are kept in memory, the conversion is fast.
We declare an object of class ostringstream and use the insertion operator (<< ) to send the
integers to the object. To get them back as a string, we use the str member function of class
ostringstream. Here is the corrected version of GetTimeStr, using an object of class
ostringstream, followed by the output from the driver:
Once this function is inserted, the driver produces this output:

Description
QUICK CHECK
12.7.1 What is composition?
12.7.2 Does C++ require a special language notation for composition?
12.7.3 What must we use to construct an object that is declared within another class
that is dependent on information provided by the constructor of that class?
12.7.4 Which preprocessor directives are used to avoid multiple inclusion?

12.8 UML Diagrams
It can be difficult to understand the operation of an application just by looking at the written
documentation. When many classes are interacting, keeping track of their relationships
involves building a mental picture. Before long, we start drawing diagrams just to keep
everything straight. Perhaps we use boxes to represent classes, and lines between them to
represent collaborations (classes calling methods in other classes). Inside the boxes, we
make notes about the classes. Eventually, we have a diagram that captures the important
structural information about the application. The trouble is, no one else knows what our
diagram means! If programmers used a common set of symbols, then they could read one
another’s diagrams.
The Unified Modeling Language (UML) is just such a collection of symbols. It was
developed specifically for diagramming object-oriented applications. Even though it has the
word language in its name, UML is not a programming language; it is just a collection of
graphical symbols. It is unified in the sense that it was created from a combination of three
different sets of symbols that were in use prior to its development. Each of those earlier
conventions had its own strengths and weaknesses, so UML was created to provide a single
set of symbols incorporating all of their best features.
The UML symbols are divided into subsets that are used for different purposes. There are
UML diagrams for documenting just about every aspect of programming, from analyzing the
problem to deploying the code on customers’ computers. You could take an entire course in
drawing UML diagrams!
We begin by looking at the simplest form of diagrams: the Class diagram.
Diagramming a Class
A class is represented in UML by a box that’s divided into three sections. The top section
holds the name of the class, the middle section lists its attributes (the data members of the
class), and the bottom section lists responsibilities (methods). Here’s a UML diagram of the
TimeOfDay class:

Description
As you can see, the diagram lists the attributes and their types in the middle section. The
minus sign in front of each attribute is shorthand for private. UML uses + to mean public. You
can see that all of TimeOfDay ’s responsibilities are listed in the bottom section, showing
parameters and return types for value-returning methods. As you can also see by the plus
signs, TimeOfDay ’s functions are all public.
Diagramming Composition of Classes
When a class contains an instance of another class, such as the Name class field contained in
the Entry class, we draw a solid diamond at the end of the line next to the containing class.
(We just show the constructor as an example responsibility—in a proper UML diagram, all of
the responsibilities would be listed.)
Description
This is how UML documents composition. The class with the solid diamond is composed of
(among other things) an instance of the class at the other end of the arrow. Notice that the
name of the instance (name ) is indicated beside the arrow.
QUICK CHECK

12.8.1 What is UML used for?
12.8.2 What symbols are used to represent public data and private data in a UML
diagram?
Problem-Solving Case Study
CREATE AN ARRAY OF NAME OBJECTS
PROBLEM: As a first pass of an appointment book, you decide to create a 24-hour listing
of names organized by their associated hour. You have a file of entry data that needs to be
converted to this form and then output.
INPUT: The file of values that can be used to make Entry objects.
OUTPUT: The hour of the day and the associated name, ordered by hour.
DISCUSSION: We can read the data for an entry object, get the hour associated with the
object, and use it as an index into the array. FIGURE 12.11 describes this structure.
Description
FIGURE 12.11 Names Array Indexed by Hours

What happens if there is more than one person with the same hour? Well, let’s store the
name the first time we see an hour. If a subsequent entry has the same hour, we can write
an error message. Here is the main algorithm:
Main
Level 0
Open files
IF files not ok
Write error message
Return 1
Get entry
WHILE more entries
Process entry
Get entry
Write time and name
Close files
We have been opening and checking files for many chapters now. We can consider this a
concrete step.
GetEntry(In/out: inFile) GetEntry(In/out: inFile)
Level 1
Read Name
Read Time
Create newEntry
Return newEntry
ProcessEntry(In/out: array Names, In: entry)
Get Hours
Set Names[hours] to entry.GetNameStr
Get Hours . . . How are we going to do that? We can get a string with the hours
embedded and try to access the hours. However, if we have a TimeOfDay object rather than
an Entry object, we can access the hours directly. We don’t need an Entry object: We need
a Name object and a TimeOfDay object. We let the fact that the file contains data
corresponding to Entry objects mislead us. This design needs to be redone, but first we
need to see an example of the file format.
Description
This information makes the processing even easier. We read the first, middle, and last
names and create a Name object. The next value on the line is the hours. We don’t need
the minutes and seconds, but we will have to read past them. In fact, we don’t need a
TimeOfDay object at all; we can just use the hours directly.
Main (Revised)
Level 0
Open files
IF files not ok

Write error message
Return 1
Get name
WHILE more data
Get hours
Set names[hours] to name
Get name
Write time and name
Close files
GetEntry(In/out: inFile) Return value: Entry
Get first, middle, last from inFile
name = Name(first, middle, last)
Return name
WriteTimeName(In/out: outFile, In: names)
FOR hour going from 0 to 23
Write 
“Hour: 
”, 
hour, 
“Name”, 
names[hour].GetFirstName(), 
“ 
”,
names[hour].GetMiddleName(), “ ” on outFile
OpenFiles, GetName, and WriteTimeName should be coded as functions. Have we
forgotten anything? Yes: We haven’t taken care of duplicate hours. We must set every cell
in the array to a default Name object. Before we store a Name object into the array, we must
check whether an object there has a first name that is a blank. Again, we update the main
module.
Main (Second revision)
Level 0
Open files
IF files not ok
Write error message
Return 1
Set array names to all default Name objects
Get name
WHILE more data
Get hours
IF names[hours].GetFirstName() is a blank
   Set names[hours] to name
ELSE
   Write hours, “ is already taken” on outFile
Get name
Write time and name
Close files
WriteTimeName(In/out: outFile, In: names) (Revised)
FOR hour going from 0 to 23
IF names[hour].GetFirstName() != “ ”
Write “Hour: ”, hour, “Name”, names[hour].GetFirstName(),
      “ ”, names[hour].GetMiddleName(), “ ”,
         names[hour].GetLastName(), endl on outFile
 ELSE

Write “Hour: ”, “None was scheduled.”, endl on outFile
Here is a program listing, the input, and the output:
Description

Description

Description
Input File
Description
Output File

Graphical User Interface (GUI)
Like the previous chapter, refactoring this program to use a graphical interface just involves
replacing the console I/O for getting the file name. It is, in fact, so similar that we can simply
show the necessary code changes, which should be familiar to you by now. Of course, we
need to include the header file for the dialog widgets:
Description
And then we replace the use of cout and cin with calls to FileDialog and NewFileDialog
widgets.
Description
Here is what the two file dialog widgets look like when we run the GUI version:

Description
Description
We omit the full GUI program listing because it is identical except for the code changes
shown above.

Testing and Debugging
Testing and debugging a C++ class amounts to testing and debugging each member function
of the class. All of the techniques you have learned about so far—algorithm walk-throughs,
code walkthroughs, hand traces, test drivers, verification of preconditions and postconditions,
the system debugger, the assert function, and debug outputs—may be brought into play.
Consider how we might test this chapter’s TimeOfDay class. Here is the class declaration,
abbreviated by leaving out the function preconditions and postconditions:
Description
Description
To test this class fully, we must test each of the member functions. Let,s step through the
process of testing just one of them: the Increment function.
Before we implemented the Increment function, we started with a pseudocode algorithm,
performed an algorithm walk-through, and translated the pseudocode into the following C++
function:

Description
Now we perform a code walk-through, verifying that the C++ code faithfully matches the
pseudocode algorithm. At this point (or earlier, during the algorithm walk-through), we do a
hand trace to confirm that the logic is correct.
For the hand trace, we should pick values of hours, minutes, and seconds that ensure code
coverage. To execute every path through the control flow, we need cases in which the
following conditions occur:
1. The first If condition is false.
2. The first If condition is true and the second is false.
3. The first If condition is true, the second is true, and the third is false.
4. The first If condition is true, the second is true, and the third is true.
Below is a table displaying values of hours, minutes, and seconds that correspond to these four
cases. For each case we also write down what we hope will be the values of the variables
after executing the algorithm.

Description
Using the initial values for each case, a hand trace of the code confirms that the algorithm
produces the desired results.
Finally, we write a test driver for the Increment function, just to be sure that our
understanding of the algorithm logic is the same as the computer’s! Here is a possible test
driver:

Description
For input data, we supply at least the four test cases discussed earlier. The program’s
output should match the desired results—and it does. Notice that, because we are interested
in checking the actual values from the observer methods, we do not have our driver apply
output formatting to ensure that minutes and seconds have two digits when their values are
less than 10.
Now that we have tested the Increment function, we can apply the same steps to the
remaining member functions. We can create a separate test driver for each function, or we
can write one driver that tests all of the functions. The disadvantage of writing just one driver is
that devising combinations of input values to test several functions at once can become
complicated.
Before leaving the topic of testing a class, we must emphasize an important point: Even
though a class has been tested thoroughly, it is still possible for errors to arise. Let’s look at
two examples using the TimeOfDay class. The first example is the client statement
Description
The precondition on the parameterized constructor requires the first argument to have a value
from 0 through 23. We don’t prevent an erroneous time from being constructed when the client
ignores the precondition. The second example is the comparison
Description

where the programmer intends time1 to be 11:00:00 on a Wednesday and time2 to be 1:20:00
on a Thursday. (The result of the test is AFTER, not BEFORE as the programmer expects.) The
implicit precondition of ComparedTo requires the two times to be on the same day, not on two
different days. This implicit precondition should be made explicit.
Do you see the common problem? In each example, the client has violated the function
precondition. If a class has been well tested but errors occur when the client code uses the
class, always check the member function preconditions. You can waste many hours trying to
debug a class member function when, in fact, the function is correct but the error lies in the
client code.
Testing and Debugging with a Graphical User Interface
In previous chapters we created GUIs to enhance the usability of applications for the end
user. It turns out that a GUI is also useful in the context of testing the programs we write. In
the previous section we created a console-based test driver program to test the TimeOfDay.
Increment() method. The test driver asked the programmer to enter the hour, minute, and
second to construct a TimeOfDay object. We then invoked the TimeOfDay.Increment() method
to return a new TimeOfDay object with the time incremented. The programmer would then
visually compare the two times to ensure that the original time that we entered was
incremented properly. The program repeats until the user enters the sentinel value of 0 for the
hour.
An important aspect of many graphical widgets is that they not only enhance usability, but
also can constrain the input values to a correct range. For example, we’ve seen how the file
dialog widgets avoid entering erroneous file names. We can also use a GUI widget to ensure
that hour, minute, and seconds values are within the expected ranges, and of the correct
types, when a user enters a time of day. Specifically, the proper GUI widget will restrict the
hour value to range from 0 to 23, and minutes and seconds values from 0 to 59. The console-
based version did not check if the user typed in an integer within these ranges. In fact, it didn’t
even check if they were integers at all! Thus, using a GUI for testing can lead to a more robust
test driver, giving us more assurance that our class is working as expected.
The console-based program prompts the user for the time of day and terminates when the
input for the hour is 0. It might occur to you that when a GUI component restricts input to valid
values, doing so also eliminates the possibility of using an invalid value as a sentinel to end a
loop. Because we still want the functionality for choosing to run another test or stop, the new
version will need one widget for entering the time of day and a separate one for continuing or
quitting the program. Eliminating the use of a sentinel value, and constraining the input values
by range and type, necessitates a more sophisticated interface. Lastly, we need a widget to
display the time we entered along with the result of calling the TimeOfDay.Increment() method
so we can verify that it is working as designed.
As we continue our exploration of graphical applications, we will begin to expose parts of the
GUI framework that enable us to create more complex interfaces. As before, we include the
necessary header file for the YesNoDialog and OutputDialog components, and then we include
a new header file that provides finer control over the initialization and exiting of our graphical
application:

The QApplication object represents a graphical application. Its primary goal is to handle
events that occur from interacting with graphical components. For example, the clicking of a
button is an event that may cause some action to be performed, such as incrementing the
time of day. In our previous GUIs this was hidden because we used prebuilt components with
predefined events and actions. In this chapter, we begin exploring the basics of user-defined
events and actions, and we will add further details in the chapters to come.
We also include the header file that specifies the TimeOfDay class:
The main function of the application will begin with the creation of a QApplication object:
The arguments to the constructor of a QApplication are simply parameters that are passed
into the main function. Up until now, we have declared main with an empty parameter list. But
C++ enables users to enter additional information when launching a program, which is passed
into main through a set of parameters (something we haven’t needed to use). Because the
GUI tools are designed to work with such programs, they assume the heading for main takes
that form. Thus, we’ll adopt that syntax for our GUI programs, even though we will just ignore
anything that is actually passed in as arguments. This change is all we need to do to make
our application ready to define and handle the new forms of user interaction we’ll be adding to
our GUI application.
First, we use a YesNoDialog to ask the user if they want to run a time of day test:
Description
If you recall, the YesNoDialog widget has a display() method that returns a Boolean value that
is true if the user clicks “Yes” or false if the user clicks “No.” This component takes the place
of using a sentinel value to continue or terminate testing. Now, rather than terminate when the
hour is set to 0, we will terminate when the display() method of the runTestDialog object
returns false. The skeleton of the while loop looks like this:
Description
This is what the GUI looks like when we run this code (ignoring the loop body for the
moment):

Description
In the body of the while loop we introduce a custom-made widget called TimeOfDayWindow for
entering an hour, minute, and second, which can then be used to construct a new TimeOfDay
object. We do not cover the internals of custom-made widgets until later chapters. Fortunately,
the standard form of this widget does what we need, without customization. Here is the code
that will declare and display this widget:
Description
Here is what this GUI component looks like when the display() method is called:
Description
This widget comes predefined with an input box containing the current time in hours,
minutes, and seconds. The time can be incremented or decremented using the up and down
arrow buttons, and can also be changed by typing directly into the input box. The box ensures
that the entered values are in the proper ranges for hours, minutes, and seconds; for example,
you are not able to enter a value below 0 or above 24 for the hour. Modifying the time will also
update the “Selected Time” label to reflect the time that is entered into the input box. When the
user clicks the Enter button, it will record the hour, minute, and second to be used by the client
of the GUI.
After the Enter button is clicked, the display() method returns, allowing us to create a new
TimeOfDay object using the time entered into the GUI. The hour, minute, and second are

retrieved using the corresponding observer methods of the TimeOfDayWindow object. We then
call the Increment() method to construct a new time of day object as we did in the previous
test driver program. Here is the code that accomplishes this:
Description
The rest of the loop body builds a string used to display the original time and the incremented
time. This string is given to an OutputDialog widget for the user to validate that the Increment()
method is working properly. The code for this is similar to GUI applications we have seen in
previous chapters:
Description
The resulting GUI looks like this:

After we click OK or Cancel, the output GUI closes and the loop repeats by asking the user
again with the YesNoDialog if they want to run a time of day test. If the user clicks No, the loop
terminates. The last thing we need to do is shut down the GUI system properly by calling the
exit() method on the QApplication object:
Description
The full GUI version of the program is listed below.
Description

Description
Testing and Debugging Hints
1. The declaration of a class within the specification header file must end with a semicolon.
2. Be sure to specify the full member selector when referencing a component of a class
object.
3. Regarding semicolons, the declarations and definitions of class member functions are
treated the same as any C++ function. The member function prototype, which is located
in the class declaration, ends with a semicolon. The function heading—the part of the
function definition preceding the body—does not end with a semicolon.
4. When implementing a class member function, don’t forget to prefix the function name with
the name of the class and the scope resolution operator (:: ).
Description
5. For now, the only built-in operations that we apply to class objects are member selection
(. ) and assignment (= ). To perform other operations, such as comparing two class
objects, you must write class member functions.

6. If a class member function inspects but does not modify the private data, it is a good idea
to make it a const member function.
7. A class member function does not use dot notation to access private members of the
class object for which the function is invoked. In contrast, a member function must use
dot notation to access the private members of a class object that is passed to it as an
argument.
8. A class constructor is declared without a return value type and cannot returna function
value.
9. If a client of a class has errors that seem to be related to the class, start by checking the
preconditions of the class member functions. The errors may reside in the client, not the
class.
10. If a class has a member that is an object of another class, and this member object’s
constructor requires arguments, you must pass these arguments using a constructor
initializer:
Description
If there is no constructor initializer, the member object’s default constructor is invoked.

Summary
Abstraction is a powerful technique for reducing the complexity and increasing the
reliability of programs. Separating the properties of a data type from the details of its
implementation frees the user of the type from having to write code that depends on a
particular implementation of the type. This separation also assures the implementor of the
type that client code cannot accidentally compromise a correct implementation.
An abstract data type (ADT) is a type whose specification is separate from its
implementation. The specification announces the abstract properties of the type. The
implementation consists of (1) a concrete data representation and (2) the implementations
of the ADT operations. In C++, an ADT can be realized by using the class mechanism.
Class members can be designated as public or private. Most commonly, the private
members are the concrete data representation of the ADT, and the public members are the
functions corresponding to the ADT operations.
In object-oriented terminology, instances of ADTs are objects; that is, a class defines a
pattern for instantiating an object. Among the public member functions of a class, the
programmer often includes one or more class constructors—functions that are invoked
automatically whenever a class object is created. When designing a class, the principles
of abstraction, encapsulation, modifiability, and reuse must be considered. An immutable
class provides no public function that changes a data value in the object; a mutable class
does provide such a function.
Separate compilation of program units is central to the separation of specification from
implementation. The declaration of a C++ class is typically placed in a specification (.h )
file, and the implementations of the class member functions reside in the implementation
file. The client code is compiled separately from the class implementation file, and the two
resulting object code files are linked together to form an executable file. Through separate
compilation, the user of an ADT can treat the ADT as an off-the-shelf component without
ever seeing how it is implemented.

Quick Check Answers
12.1.1 The characteristics of the data values as well as the behavior of each of the
operations on those values. 12.1.2 (1) Choose a concrete data representation using
existing data types, and (2) implement each of the allowable operations in terms of
program instructions. 12.2.1 The class. 12.2.2 Its name is identical to the name of the
class; it is not void, nor does it have a return value type. 12.2.3 One that contains both data
and operations within a single, cohesive unit. 12.2.4 A client of the class X. 12.2.5 Date
today; 12.2.6 today.GetDay(); 12.3.1 It enables client code to see the formal interface to
the class, but none of the implementation details that the creator of the class wishes to
hide. 12.3.2 In the heading, between the name of the class and the name of the function.
12.3.3 The encapsulation and hiding of implementation details to keep the user of an
abstraction from depending on or incorrectly manipulating the details. 12.3.4 An object
code file. 12.3.5 The specification file. 12.4.1 An object is a self-contained entity
encapsulating data and operations on the data—an instance of an ADT. 12.4.2 When one
object communicates to another object by invoking a method on that object. 12.5.1 The
written description of the behavior of a class with respect to its interface. 12.5.2 A
transformer or mutator method. 12.5.3 A class is immutable if there are no transformer
(mutator) member functions. 12.6.1 Immutable 12.6.2 GetFirstName, GetMiddleName,
GetLastName 12.7.1 The relationship between classes in which one class contains an
instance of another class as one of its attributes. 12.7.2 No, you simply declare an object
of one class to be one of the data members of another class. 12.7.3 We must use a
constructor initializer to pass the information needed to properly construct the contained
object. 12.7.4 #ifndef, #define, #endif 12.8.1 To diagram object-oriented applications.
12.8.2 + and —

Exam Preparation Exercises
12.1 Dot notation is used only by class clients to refer to members. Other class
members do not need to use dot notation. True or false?
12.2 Given the following declarations:
What are the contents of the two Name variables after each of the following statements,
assuming they are executed in the order listed?
12.3 What are the two major properties of an abstract data type that are defined in its
specification?
12.4 How does the data representation differ from the domain of an abstract data
type?
12.5 By default, are class members public or private?
12.6 Suppose you are given an object called current, of class Time. How would you
write the call to its void member function, called plus, that adds an integer number of
minutes to the current time? The number of minutes to add is found in variable period.
12.7 Which kind of operation—constructor, observer, transformer, or iterator—is
implemented by a function that is declared as const ?
12.8 A class may have multiple constructors, all with the same name. How does the
compiler decide which one to call?
12.9 A class called Calendar has a default constructor and a constructor that accepts
an integer value specifying the year. How would you invoke each of these

constructors for an object called primary ? Use the current year as the argument to
the second constructor.
12.10 Which C++ language mechanism implements composition?
12.11 List three design principles for good class design.
12.12 What is a constructor initializer?
12.13 If a header file is used by more than one class, how do you keep the
preprocessor from including the definition twice?
12.14 Distinguish between action responsibilities and knowledge responsibilities.

Programming Warm-Up Exercises
12.1 Write a specification of a Date ADT.
a. What would be a good class representation?
b. Name possible action responsibilities.
c. Name possible knowledge responsibilities.
12.2 Write the specification file for class Date that implements the Date ADT as
declared in Exercise 12.1.
12.3 Write the implementation for class Date from Exercise 12.2.
12.4 Write the specification for a Song ADT that represents a song entry in an MP3
library. It should have fields for title, album, artist, playing time in minutes and
seconds, and music category. The music category is represented by an enumeration
type called Category.
a. What operations should Song ADT have?
b. What observers should Song ADT have?
12.5 Write the specification file for the class Song that implements the Song ADT from
Exercise 12.4.
12.6 Write the implementation file for the class Song from Exercise 12.5.
12.7 Programming Problems 10.3 and 10.4 asked you to develop educational
programs for teaching the periods of geologic time. Now that you know how to write
classes, you can turn the Period ADT into a class. Write a specification file for class
Period, which has a private field that’s an enumeration type, representing the names
of the periods. Class Period should have functions that return the period as a string,
return the period as an int, return the starting date of the period, and increment the
period to the next most recent period. (If the period is already NEOGENE, the increment
operation should do nothing.) It should have a default constructor that sets the period
to PRECAMBRIAN and a constructor with a parameter of the enumeration type to allow the
user to create a Period object containing any period. For ease of reference, the table
of the time periods is repeated here from Chapter 10. Be sure to use appropriate
documenting comments.
Period Name
Starting Date (millions of years ago)
Paleogene
65
Cretaceous
136

Jurassic
192
Triassic
225
Permian
280
Carboniferous
345
Devonian
395
Silurian
435
Ordovician
500
Cambrian
570
Precambrian
4500
12.8 Using the Period class as specified in Exercise 12.7, write a For statement that
iterates through the periods of geologic times from earliest to most recent, writing out
the name of the period and its starting date.
12.9 Write the function definitions of the two constructors for the Period class as
specified in Exercise 12.7.
12.10 Write the function definition for the ToInt observer of the Period class specified
in Exercise 12.7.
12.11 What would the file name be for the file containing the specification of the Period
class in Exercise 12.7?
12.12 Write the include directive that would appear near the beginning of the Period
class implementation file to include the specification file for the Period class as
described in Exercise 12.7.
12.13 Because of floating-point representational errors, monetary amounts that need
to be exact should not be stored in floating-point types. Code the specification for a
class that represents an amount of money as dollars and cents. This class should
have a default constructor that creates an object with zero dollars and zero cents, an
observer for dollars, an observer for cents, and an observer that returns the amount
as a float. It also should have transformers that add and subtract other values of
class Money. Be sure to use appropriate documenting comments.
12.14 Write the function definitions of the two constructors for the Money class as
specified in Exercise 12.13.

12.15 What would be the file name for the file containing the specification of the Money
class in Exercise 12.13?
12.16 Write the include directive that would appear near the beginning of the Money
class implementation file to include the specification file for the Money class as
described in Exercise 12.13.
12.17 Write the function definitions for the observer in the Money class of Exercise
12.13 that returns the values as a float.

Programming Problems
12.1 Imagine you are working for an in-house software team for a company that
wants to monitor network access points in a building. Each building has a specified
number of floors, a certain number of rooms per floor, and some number of network
access points in a room. Each network access point is labeled with its state as being
on or off, and if it is on it has the month it was turned on. Design, implement, and test
classes that represent buildings, floors, and network access points. Your classes
should provide suitable observer methods that allow you to determine how many
floors are in a building, how many rooms are on a floor, how many access points are
in a room, and if an access point is on or off and which month it was turned on. You
should also provide mutator methods that allow you to turn a network access point on
or off and to set the month if it is turned on. You should use composition as a key
strategy in designing these classes—thus, a building should contain floors, floors
should contain rooms, and rooms should contain network access points.
12.2 A software company that develops games has just hired you! Before working on
the next version of Medieval Menace, they have given you the task of implementing
the tic-tac-toe game in C++. Tic-tac-toe consists of a 3 × 3 game board of squares
where each square is either empty, has an X marker, or has an O marker. Two
players represented by an X or an O play the game. The objective is for one player to
get three Xs or three Os in a row first. Design, implement, and test classes that
represent a tic-tac-toe game board and X and O markers. Your classes should
provide suitable observer and mutator methods for modifying the game board and
displaying the state of the game. Use your classes to create a game that prompts for
player X and player O to place markers at specified locations on the game board.
After each move your program should display the current game board to the console.
Your program should also check after each move if there is a winning configuration of
the game board. If so, the game should finish by indicating which player won.
12.3 Programming Problem 10.3 asked you to develop an educational program to
teach users about geologic time. Rewrite that program using a class to implement an
ADT representing a period of geologic time. If you did Programming Warm-Up
Exercises 12.7 through 12.12, this will be a relatively easy task. The program should
let the user enter a range of prehistoric dates (in millions of years), and then output the
periods that are included in that range. Each time this is done, the user is asked if they
want to continue. The goal of the exercise is for the student to try to figure out when

each period began, so that they can make a chart of geologic time. See Programming
Warm-Up Exercise 12.7 for a list of the geologic time periods and their starting dates.
12.4 Programming Problem 10.4 asked you to write a second educational program for
learning about geologic time. Rewrite that program using a class to implement an ADT
representing a period of geologic time. If you did Programming Warm-Up Exercises
12.7 through 12.12, then you’ve already done some of this work. The ADT in those
exercises needs to be enhanced with a constructor that takes a string as an argument
and converts the string to the corresponding Period value. (The constructor should
work with any style of capitalization of the period names.) In this program, the
computer picks a date in geologic time and presents it to the student. The student
guesses which period corresponds to the date. The student is allowed to continue
guessing until they get the right answer. The program then asks the user whether they
want to try again, and repeats the process if the answer is “yes.” You also may want
to write a function that returns the period for a given date; however, this function does
not need to be part of the class.
12.5 Several chapters since Chapter 5 have included Programming Problems that
ask you to develop or rewrite a program that outputs the user’s weight on different
planets. The goal has been for you to see how the same program can be
implemented in different ways. Here we would like you to rewrite the program using a
class to represent the planet and its gravity. The class should include a constructor
that allows a planet to be specified with a string, using any capitalization. (If the string
is not a planet name, then Earth should be assumed.) The default constructor for the
class will create an object representing Earth. The class has an observer operator
that takes a weight on Earth as an argument and returns the weight on the planet. It
should have a second observer that returns the name of the planet as a string with
proper capitalization.
For ease of reference, the information for the original problem is repeated here. The
following table gives the factor by which the weight must be multiplied for each planet.
The program should output an error message if the user doesn’t type a correct planet
name. The prompt and the error message should make it clear to the user how a
planet name must be entered. Be sure to use proper formatting and include
appropriate comments in your code. The output should be labeled clearly and
formatted neatly.
Mercury
0.4155
Venus
0.8975
Earth
1.0
Moon
0.166

Mars
0.3507
Jupiter
2.5374
Saturn
1.0677
Uranus
0.8947
Neptune
1.1794
Pluto
0.0899
12.6 Design, implement, and test a class that represents an amount of time in
minutes and seconds. The class should provide a constructor that sets the time to a
specified number of minutes and seconds. The default constructor should create an
object for a time of zero minutes and zero seconds. The class should provide
observers that return the minutes and the seconds separately, and an observer that
returns the total time in seconds (minutes × 60 + seconds). Boolean comparison
observers should be provided that test whether two times are equal, one time is
greater than the other, or one time is less than the other. (You may use RelationType
and function ComparedTo if you choose.) A function should be provided that adds one
time to another, and another function that subtracts one time from another. The class
should not allow negative times. (Subtraction of more time than is currently stored
should result in a time of 0:00.) This class should be immutable.
12.7 Design, implement, and test a class that represents a song on a CD or in an
MP3 library. If you did Programming Warm-Up Exercises 12.4 through 12.6, you
already have a good start. It should have members for title, album, artist, playing time
in minutes and seconds, and music category. The music category is represented by
an enumeration type called Category ; make up an enumeration of your favorite
categories. The class should have a constructor that allows all of the data members
to be set and a default constructor that sets all of the data members to appropriate
empty values. It should have an observer operation for each data member and an
observer that returns all of the data for the song as a string. An observer that
compares two songs for equality should be developed as well.
12.8 Design, implement, and test a class that represents a phone number. The
number should be represented by a country code, an area code, a number, and a
type. The first three values can be integers. The type member is an enumeration of
HOME, OFFICE, FAX, CELL, and OTHER. The class should provide a default constructor that
sets all of the integer values to zero and the type to CELL. A constructor that enables
all of the values to be set should be provided as well. You also should provide a

constructor that takes just the number and type as arguments and sets the country
and area codes to those of your location. The class will have observers that enable
each data member to be retrieved and transformers that allow each data member to
be changed. An additional observer should be provided that compares two phone
numbers for equality.

Case Study Follow-Up
1. Any duplicate time messages are written just before the listing of the events.
Change the program so that duplicate time messages are written to cout instead,
along with appropriate labels.
2. Add the name that goes with the duplicate time on the output.
3. Write a test plan for the case study program.
4. Implement the test plan written in Exercise 3.
5. The comparison function in class Name does not change the fields to all uppercase
or all lowercase before comparing them. That would result, for example, in a
comparison of the names MacTavish and Macauley indicating that MacTavish comes
first alphabetically. Rewrite function ComparedTo in class Name so that all the strings are
changed to all uppercase before the comparison is made.
6. Rerun the case study using the Name class as altered in Exercise 5.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 3
Array-Based Lists
KNOWLEDGE GOALS
To understand the structure of a list ADT.
To know the basic operations associated with a list ADT.
To recognize the difference between an array and a list.
To know how a linear search algorithm works.
To understand the properties of a sorted list ADT.
To know how an insertion sort works.
To understand the principle of “divide and conquer” as expressed in the binary search
algorithm.
SKILL GOALS
To be able to:
Represent a list ADT using a C++ class.
Add an item into a list.
Remove an item from a list.
Search for an item in a list.
Sort the items in a list into ascending or descending order.
Build a list in sorted order.
Search for an item in a sorted list using a linear search.
Search for an item using a binary search.
Chapter 11 introduced the array, a data structure that is a collection of components of the
same type given a single name. Often, a one-dimensional array is used to hold a list of items.
In this chapter, we examine array algorithms that represent data as a list. We all know

intuitively what a “list” is. We use lists all the time—grocery lists, to-do lists, lists of party
invites. In computer applications, lists are useful ways to organize the data.
Our algorithms will be implemented as general-purpose functions that can be modified
easily to work with many kinds of lists. We conclude with a case study that uses an array as
the main data structure.

13.1 What Is a List?
From a logical point of view, a list is a homogeneous, linear collection of elements. Here linear
means that, at the logical level, every element in the list (except the first and last elements)
has a unique predecessor and a unique successor.1 The number of items in the list, which we
refer to as its length, is a property of a list.
Lists can be unsorted—their elements may be placed into the list in no particular order—or
they can be sorted. For instance, a list of numbers can be sorted by value, a list of strings
can be sorted alphabetically, and a list of addresses could be sorted by ZIP code. When the
elements in a sorted list are of composite types, one of the members of the structure, called
the key, determines their logical order. For example, a list of students could be sorted
alphabetically by name or numerically by student identification number. In the first case, the
name is the key; in the second case, the identification number is the key. (See FIGURE 13.1.)
Linear relationship A relationship in which every element except the first has a unique
predecessor, and every element except the last has a unique successor.
Length The number of items in a list; it can vary over time.
Unsorted list A list in which data items are placed in no particular order with respect to
their content; the only relationships between data elements consist of the list predecessor
and successor relationships
Sorted list A list whose predecessor and successor relationships are determined by the
content of the keys of the items in the list; a semantic relationship exists among the keys
of the items in the list.
Key A member of a class whose value is used to determine the logical and/or physical
order of the items in a list.
If a list cannot contain items with duplicate keys, we say that it has unique keys. (See
FIGURE 13.2.) This chapter deals with both unsorted lists and lists of elements with unique
keys, sorted from smallest to largest key value. The items on the list can be of any type,
atomic or composite. In the following discussion, “item,” “element,” and “component” are
synonyms; they refer to what is stored in the list.
QUICK CHECK
13.1.1. What are the three main properties of a list?
13.1.2. What type can the elements of a list be?

Description
FIGURE 13.1 List Sorted by Two Different Keys
Description
FIGURE 13.2 List with Duplicate Keys and List with Unique Keys
1 At the implementation level, a relationship also exists between the elements, but the
physical relationship may not be the same as the logical one.

13.2 The List as an Abstract Data Type
In this section, we design a List ADT to be implemented as a general-purpose class in the
next section. Let’s think about this structure in terms of a to-do list. Usually the design of a
new ADT depends on how the client will use it. In this chapter, we’re exploring algorithms for
list implementation, so we will be our own client. To motivate our design choices, we will think
of the ADT as supporting a to-do list application.
Thinking in terms of a physical list, on a piece of paper, initially we start with an empty list,
and then we add things to it. As we accomplish a task on the list, we cross it off. We want to
check whether an item is already on the list, so we don’t add it again. We need a way to tell
whether the list is empty. We may want to know how many things we have left to do. And
when it’s time to pick a new task to tackle, we want to go through the list, looking at each item.
There’s one more situation to deal with—we have to decide what to do when we run out of
space on the paper.
Let’s translate these observations into operations (responsibilities) for the list. Notice that
constructors are obvious because they are prefaced by “create,” knowledge observers have
a “get” shown, and Boolean observers are prefaced with “is.” Likewise, the choice of identifier
for transformers gives their type away: “add” and “remove.” Our design also introduces the
iterator, an operation that allows us to access the items in a structure one at a time.
Type
List
Domain
Each instance of type List is a collection of up to MAX_LENGTH components, each of type
ItemType.
Operations
Create an initially empty list.
Is the list empty?
Is the list full?
Get the current length of the list.
Insert an item into the list.
Delete an item from the list.
Is an item in the list?
Iterate through the list, returning each item in turn.
These operations differ somewhat from those for the IntList ADT in Chapter 12. First, we
have identified the operations for a specific problem. Second, we have used the object-
oriented form of the operations, where the name indicates what it does. From this
representation of our ADT, we can develop the specification for the class that will implement
the List ADT.
Refining Responsibilities

Let’s go through the responsibilities, refining them to be more broadly useful for a general-
purpose class, and then converting them to function headings.
The observers, which test for full and empty lists and return the number of items, are
straight-forward. We can directly write their function headings with the appropriate
documentation:
Description
Description
The observer that checks whether an item is in the list must take the item as a parameter.
Let’s call this method isThere.
Description
In designing the transformers, we must make some decisions. For example, do we allow
duplicates in our list? This choice has implications for both removing and adding items. If we
allow duplicates, what do we mean by “deleting an item”? Do we delete one copy or all of
them?
For now we just make a decision and design our algorithms to fit it. We will examine the
effects of other choices in the exercises. Let’s allow only one copy of an item in the list. In that
case, deleting an item just removes that copy. But do we assume that the item to be deleted is
in the list? Is it an error if it is not? Or does the deletion operation mean “delete, if there”? It’s
extra work for the client to check whether an item is in the list before deleting it, so let’s use
the last meaning.
We now incorporate these decisions into the documentation for the method headings.
Description

The iterator allows the user to look at the items in the list, one by one. The method that
implements the “Get next item” responsibility will be called GetNextItem. The list must keep
track of the next item to return when the iterator is called. It does so with a data member that
records the position of the next item to be returned. The constructor initializes this position to
0, and it is incremented in GetNextItem.
The client could use the length of the list to control a loop that goes through the list. Another
approach is to provide an observer HasNext that asks if the list contains another item that has
not been seen. Let’s use this second approach and explore the first approach in the
exercises. Because invoking GetNextItem when HasNext is false causes an error, we must
state the assumption in the documentation that there is an item to be accessed when
GetNextItem is called.
What happens if a user adds or removes an item in the middle of an iteration? Depending
on whether an insertion or deletion occurs before or after the iteration point, our iteration loop
could end up skipping or repeating items.
We have several choices for handling this possibly dangerous situation. The list could reset
the current position to the beginning when items are added or deleted, or it could disallow
transformer operations while an iteration is taking place. We choose the latter option here by
way of an assumption in the documentation. In case the user wants to restart an iteration, let’s
provide a ResetList method that reinitializes the current position.
Description
All we have left to write is the constructor.
Description
Data Representation
As defined in Chapter 11, a one-dimensional array consists of a fixed number of
homogeneous components. One use for an array is to store a list of values. A list, then, is
made up of an array of values and an integer variable length that says how many list
elements are stored in the array. Let’s call our array data. The class construct is used to

encapsulate the length and the array of values. From our previous discussion of GetNextltem,
we know that the list must contain a variable that indicates where in the list the next item is to
be found in an iteration. Because we are working with arrays, we assume that this variable will
be an integer index. Let’s call it currentPos.
In FIGURE 13.3, you can see that the array goes from data[0] through data[MAX_LENGTH-1],
but the list elements stored in the array go from data[0] through data[length-1]. The number
of places in the array is fixed, but the number of values stored in the list may vary.
We can use a C++ class named List to represent the List ADT in our programs. For the
concrete data representation, we use three items: a one-dimensional array to hold the list
items, an int variable that stores the current length of the list, and an int variable that is used
for iteration. When we compile the List class, we need to supply definitions for MAX_LENGTH and
ItemType, the type of the items in the list.
Description

Description
FIGURE 13.3 The Structure of the List Class
Here is the complete specification for the class List that implements the ADT List. For this
implementation, we use a MAX_LENGTH of 100 and an ItemType of string.
Description

Description
In Chapter 12, we classified ADT operations as constructors, transformers, observers, and
iterators. IsEmpty, IsFull, GetLength, and IsThere are observers. Insert and Delete are
transformers. GetNextItem is an iterator. ResetList is a transformer that initializes the list
before the iterator GetNextItem is called. HasNext is an observer associated with an iteration.
ResetList, HasNext, and GetNextItem work together to allow an iteration to occur. The class
constructor is an ADT constructor operation.
To get a List object, we have to declare one:
myList contains three variables (two int, one array). (See FIGURE 13.4.)
Example Program

Let’s look at an example of a client program that takes advantage of our generalized design.
Suppose a data file contains a weather station’s daily maximum temperature readings for one
month, one integer value per day. Unfortunately, the temperature sensor is faulty and
occasionally registers a temperature of 200 degrees.
Description
FIGURE 13.4 myList: An Instance of Class List with Values
The following program uses the List class to store the temperature readings, delete
spurious readings of 200 degrees, and output the remaining readings in sorted order.
Presumably, the data file contains no more than 31 integers for the month, so its length should
be well within the List class’s MAX_LENGTH of 100. However, just in case the file erroneously
contains more than MAX_LENGTH values, the reading loop in the following program terminates
not only if end-of-file is encountered, but also if the list becomes full (IsFull). Another reason
to use the IsFull operation in this loop can be found by looking at the function specifications in
file list.h—namely, we must guarantee Insert’s precondition that the list is not full.

Description


Description
Here is the input file:
temps.dat
Description
Given an implementation of the List class, this is the expected output file:
temps.ans

Description
We now consider how to implement each of the ADT operations, given that the list items
are stored in an array.

QUICK CHECK
13.2.1 What are the observer methods of the List ADT discussed in this section?
13.2.2 What are the transformer methods of the List ADT discussed in this section?
13.2.3 Which two members of a list class are used to represent the data in a list?

13.3 Implementation of List ADT
Basic Operations
As we discussed in Chapter 12, an ADT should be implemented in C++ by using a
specification file and an implementation file. Here is how the implementation file List.cpp
starts out:
Description
Let’s look now at the implementations of the basic list operations.
Creating an Empty List
As we saw in FIGURE 13.4, list items are stored in array elements data[0] through
data[length-1]. To create an empty list, it is sufficient to set the length member to 0. We do
not need to store any special values into the data array to make the list empty, because only
elements data[0] through data[length-1] are processed by the list algorithms. We also need
to set currentPos to 0 to initialize the list for an iteration. We will revisit this initialization choice
when we look at the implementation of GetNextItem.
Description
The IsEmpty Operation
This operation returns true if the list is empty and false otherwise. Using our convention
that length equals 0 if the list is empty, the implementation is straightforward.

Description
The IsFull Operation
The list is full if there is no more room in the array—that is, if the list length equals
MAX_LENGTH.
Description
The GetLength Operation
This operation simply returns the current length of the list.
Description
Insertion and Deletion
To devise an algorithm for inserting a new item, we first observe that this is an unsorted list.
Nothing in the specification indicates that the values have to be in any particular order. As a
consequence, we can store a new value into the next available position in the array—
data[length] —and then increment length. This algorithm brings up two questions: Do we
need to check that the list has room for the new item? Do we need to be sure the item isn’t in
the list before we attempt to store it there? The answer to both questions is no. To see why,
look back at the precondition on the Insert prototype in the specification:
Description

The user is responsible for checking these two conditions; this code is written assuming the
precondition is true.
Description
Deleting a component from a list consists of two steps: finding the component and
removing it from the list. In our discussion of the delete operation earlier, we chose to make
this operation mean “Delete, if it’s there.” This decision is reflected in the Delete prototype’s
documentation.
Description
We start at the beginning of the list and search for the value to be deleted. If we find it, how
do we remove it? We take the last value in the list (the one stored in data[length-1]), put it
where the item to be deleted is located, and then decrement length. Moving the last item from
its original position is appropriate only for an unsorted list because we don’t need to preserve
the order of the items in the list.
To “Delete, if it’s there,” we examine each component in turn and stop looking when we find
the item to be deleted or when we reach the end of the list.
Description
To see how the While loop and the subsequent If statement work, let’s look at the two
possibilities: either item is in the list or it is not. If item is in the list, the loop terminates when

the expression index < length is true and the expression item != data[index] is false. After
the loop exit, the If statement finds the expression index <length to be true and removes the
item. Conversely, if item is not in the list, the loop terminates when the expression index <
length is false—that is, when index becomes equal to length. Subsequently, the If condition is
false, and the function returns without changing anything.
Sequential Search
In the Delete function, the algorithm we used to search for the item to be deleted is known as
a sequential or linear search in an unsorted list. We use the same algorithm to implement the
IsThere function of the List class.
Description
This algorithm is called a sequential search because it looks at each item in sequence. We
stop the search when we find the item (or when we reach the end of the list without finding it).
We can use this algorithm in any program requiring a list search. In the form shown here, it
searches a list of ItemType components, provided that ItemType is an integral type or the
string class; that is, values of ItemType can be compared using the relational operators.
However, using the relational operators between floating-point values may give unexpected
results. Perhaps a note should be added to the specification file giving this warning.
This sequential search algorithm begins at the beginning of the list and searches forward.
We could just as easily have begun searching from the last item backward. To modify the
algorithm to begin at the end, we would initialize index to length-1 and decrement index each
time through the loop, stopping when we found the item we wanted or when index became -1.
Here’s how code for searching in reverse would look:
Description

Before we leave the linear search algorithm, let’s introduce a variation that makes the
program more efficient, albeit a little more complex. The While loop contains a compound
condition: It stops when it either finds item or reaches the end of the list. We can insert a copy
of item into data[length] —that is, into the array component beyond the end of the list—to act
as a sentinel. By doing so, we are guaranteed to find item in the list. Then we can eliminate the
condition that checks for the end of the list (index < length).
Description
Is this algorithm better? Eliminating a condition saves the computer the time to test it. In this
case, time is saved every iteration of the loop, so the savings add up. Note, however, that we
are gaining efficiency at the expense of space. We must declare the array size to be one
larger than the user’s limit, to hold the sentinel value if the list becomes full. That is, we must
change the declaration of the array to be
The comment describes the processing of this loop. Recall that prototype (specification)
documentation is intended for the user and contains no implementation details. If the code
uses an unusual algorithm, this fact should be noted in the function’s definition documentation,
which is for the maintainer of the code.
Iterators
Iterators are used with composite types to allow the user to process an entire structure
component by component. To give the user access to each item in sequence, we provide
three operations: one to initialize the iteration (a process analogous to Open with a file), one to
determine if there are more items, and one to return a copy of the “next component” each time
it is called. The user can then set up a loop that processes each component. We call these
operations ResetList, HasNext, and GetNextItem. Note that ResetList and HasNext are not
iterators themselves, but rather are auxiliary functions that support the iteration. Yet another
type of iterator takes an operation and applies it to every element in the list.
The ResetList function just sets currentPos to 0. Because the constructor sets up the list for
the first iteration, ResetList is called only on subsequent iterations. However, if it is called for
the first iteration, no harm is done: currentPos is just set twice.
The GetNextItem operation accesses the next item (the one at currentPos), increments
currentPos, and returns the item it accessed. What happens if the last item has been

accessed? HasNext will return false. How can HasNext recognize when the last item has been
accessed? By testing whether currentPos equals length.
Description
Reset and GetNextltem are designed to be used in a loop in the client program that iterates
through all of the items in the list. The precondition in the specifications for GetNextltem
protects against trying to access an array element that is not in the list. Look back at the
Temperature program. HasNext and GetNextltem were used once to output the original list;
ResetList, HasNext, and GetNextltem were used once to output the corrected list.
SOFTWARE MAINTENANCE CASE STUDY Enhancing Class
List with a Sort
Although we are implementing an unsorted list ADT, sometimes the user of the List class
may want to rearrange the list components into a certain order just before outputting the
list. For example, the user might want to put a list of stock numbers into either ascending
or descending order, or the user might want to put a list of words into alphabetical order. In
software development, arranging list items into order is a very common operation and is
known as sorting.
Sorting Arranging the components of a list into order (for instance, words into
alphabetical order or numbers into ascending or descending order).

If you were given a sheet of paper with a column of 20 numbers on it and were asked to
write the numbers in ascending order, you would probably do the following:
1. Make a pass through the list, looking for the smallest number.
2. Write it on the paper in a second column.
3. Cross the number off the original list.
4. Repeat the process, always looking for the smallest number remaining in the original
list.
5. Stop when all the numbers have been crossed off.
We can implement this algorithm directly in C++, but we need two arrays—one for the
original list and a second for the sorted list. If the list is large, we might not have enough
memory for two copies of it. Also, how do we “cross off” an array component? We could
simulate crossing off a value by replacing it with some dummy value like INT_MAX; that is,
we would set the value of the crossed-off variable to something that would not interfere
with the processing of the rest of the components. However, a slight variation of our hand-
done algorithm allows us to sort the components in place. We do not have to use a second
array; we can put a value into its proper place in the list by having it swap places with the
component currently in that position.
We can state the algorithm as follows: We search for the smallest value in the list and
exchange it with the component in the first position in the list. We search for the next-
smallest value in the list and exchange it with the component in the second position in the
list. This process continues until all the components are in their proper places. FIGURE
13.5 illustrates how this algorithm works.
Observe that we perform length-1 passes through the list because count runs from 0
through length-2. The loop does not need to be executed when count equals length-1
because the last value, data[length-1], is in its proper place after the preceding
components have been sorted.
This sort, known as the straight selection sort, belongs to a class of sorts called
selection sorts. There are many types of sorting algorithms. Selection sorts are
characterized by finding the smallest (or largest) value left in the unsorted portion at each
iteration and swapping it with the value indexed by the iteration counter. Swapping the
contents of two variables requires a temporary variable so that no values are lost (see
FIGURE 13.6).
Here is the code for the sorting operation of the List class. Note that the documentation
for the function declaration says what the function does; the documentation for the function
definition says how the function does it.
We are looking for the minimum value in the rest of the list (data[passCount] through
data[length-1]) on each pass through the loop. Therefore, minIndex is initialized to
passCount and the inner loop runs from searchIndex equal to passCount + 1 through length-
1. Upon exit from the inner loop, minIndex contains the position of the smallest value. (Note
that the If statement is the only statement in the loop.)

Description
FIGURE 13.5 Straight Selection Sort
Description
FIGURE 13.6 Swapping the Contents of Two Variables, x and y

Description
We may also swap a component with itself—that happens when no value in the
remaining list is smaller than data[passCount]. We could avoid this unnecessary swap by
checking whether minIndex is equal to passCount. Because this comparison would be
made in each iteration of the outer loop, it is more efficient not to check for this possibility
and just to swap something with itself occasionally.
Here is the line inserted in the temperature program and the correct output with the
values sorted:
temps.Sort();

This algorithm sorts the components into ascending order. To sort them into descending
order, we would scan for the maximum value instead of the minimum value. To do so, we
would simply change the relational operator in the inner loop from ˂ to ˃. Of course,
minIndex would no longer be an appropriate identifier and should be changed to maxIndex.
By providing the user of the List class with a sorting operation, we have not turned our
unsorted list ADT into a sorted list ADT. The Insert and Delete algorithms do not preserve
ordering by value. Insert places a new item at the end of the list, regardless of its value,
and Delete moves the last item to a different position in the list. After Sort has executed,
the list items remain sorted only until the next insertion or deletion takes place. In the next
section, we look at a sorted list ADT, which preserves the order of the list components.
QUICK CHECK
13.3.1 Where do we insert a new value into a list that isn’t sorted?
13.3.2 If an item isn’t in the list, when does a linear search discover that it is missing?
13.3.3 What are the major steps in deleting a value from a list?
13.3.4 How many For loops are there in an implementation of a selection sort?
13.3.5 To create an empty list, what must the length member of the List ADT be
initialized to?
13.3.6 What must the IsEmpty operation check to determine if a list is empty?
13.3.7 In your own words, what does sequential search do to find an element in the
list?

13.4 Sorted Lists
In the List class, the searching algorithms assume that the list is unsorted. A drawback to
searching an unsorted list is that we must scan the entire list to discover that the search item
is not there. Think what it would be like if your phone’s contact list contained people’s names
in random order rather than alphabetical order. To look up Mary Anthony’s phone number, you
would have to scan sequentially, page after page, until you found it. In the worst case, you
might have to examine hundreds of names, only to find out that Mary’s name is not in your
contacts.
Of course, contact lists are alphabetized, and the alphabetical ordering makes searching
easier. If Mary Anthony’s name is not in the list, you discover this fact quickly by starting with
the A’s and stopping the search as soon as you have passed the place where her name
should be.
Let’s define a sorted list ADT in which the components always remain in order by value, no
matter which operations are applied. Following is the SortedList.h file that contains the
declaration of a SortedList class.
Description

Description
How does the declaration of SortedList differ from the declaration of our original List class?
Apart from a few changes in the documentation comments, there are only two differences:
1. The SortedList class does not supply a sorting operation to the client. Such an operation
is not needed, because the list components are kept in sorted order at all times.
2. The SortedList class has an additional class member in the private part: a BinarySearch
function. This function is an auxiliary (“helper”) function that is used only by other class

member functions and is inaccessible to clients. We discuss its purpose when we
examine the class implementation.
Let’s look at which changes, if any, are required in the algorithms for the ADT operations,
given that we are now working with a sorted list instead of an unsorted list.
Basic Operations
The algorithms for the class constructor, IsEmpty, IsFull, GetLength, ResetList, HasNext, and
GetNextItem, are identical to those used for the List class. The constructor sets length to 0,
IsEmpty reports whether length equals 0, IsFull reports whether length equals MAX_LENGTH,
GetLength returns the value of length, and the three iteration-related functions set up
subsequent iterations, determine whether there is an unseen item, and get the next item.
Insertion
To add a new value to an already sorted list, we could store the new value at data[length],
increment length, and sort the array. However, that’s not an efficient way of solving the
problem. Inserting five new items results in five separate sorting operations.
If we were to insert a value by hand into a sorted list, we would write the new value out to
the side and draw a line showing where it belongs. To find this position, we scan the list until
we find a value greater than the one we are inserting. The new value goes in the list just before
that point.
We can use a similar process in our Insert function. We find the proper place in the list
using the by-hand algorithm. Instead of writing the value to the side, we shift all the values
larger than the new one down one place to make room for it. The main algorithm is expressed
as follows, where item is the value being inserted:
Description
Assuming that index is the place where item is to be inserted, the algorithm for Shift List
Down is

Description
Description
FIGURE 13.7 Inserting an Item into a Sorted List
This algorithm is illustrated in FIGURE 13.7. It is based on how we would accomplish the task
by hand. Often, such an adaptation is the best way to solve a problem; however, in this case,
further thought reveals a slightly better way. Notice that we search from the front of the list
(people always do), and we shift down from the end of the list upward. We can combine the
searching and shifting by beginning at the end of the list.
If item is the new item to be inserted, we can compare item to the value in data[length-1]. If
item is less than this value, we put data[length-1] into data[length] and compare item to the

value in data[length-2]. This process continues until we find the place where item is greater
than or equal to the item in the list. We then store item directly below it. Here is the algorithm:
Description
Description
Notice that this algorithm works even if the list is empty. When the list is empty, length is 0
and the body of the While loop is not entered. Thus item is stored into data[0], and length is
incremented to 1. Does the algorithm work if item is the smallest? The largest? Let’s see: If
item is the smallest, the loop body is executed length times, and index is –1. Thus item is
stored into position 0, where it belongs. If item is the largest, the loop body is not entered. The
value of index is still length-1, so item is stored into data[length], where it belongs.
Are you surprised that the general case also takes care of the special cases? This situation
does not happen all the time, but it occurs often enough that it is good programming practice
to start with the general case. If we begin with the special cases, we may not realize that we
don’t need to handle them separately. So begin with the general case, then treat as special
cases only those situations that the general case does not handle correctly.
This algorithm is the basis for another general-purpose sorting algorithm—an insertion sort,
in which values are inserted one at a time into a list that was originally empty. The insertion
sort is often used when input data must be sorted; each value is put into its proper place as it
is read. We use this technique in the Problem-Solving Case Study at the end of this chapter.

Sequential Search
When we search for an item in an unsorted list, we won’t discover that the item is missing until
we reach the end of the list. If the list is already sorted, we know that an item is missing when
we pass the place where it should be in the list. For example, suppose a list contains these
values:
7
11
13
76
98
102
If we are looking for 12, we need only compare 12 with 7, 11, and 13 to know that 12 is not in
the list.
If the search item is greater than the current list component, we move on to the next
component. If the item is equal to the current component, we have found what we are looking
for. If the item is less than the current component, then we know that it is not in the list. In
either of the last two cases, we stop looking. We can restate this process algorithmically with
the following code, in which found is set to true if the search item was found:
Description
On average, searching a sorted list in this way takes the same number of iterations to find
an item as searching an unsorted list. The advantage of this new algorithm is that we find out
sooner if an item is missing. Thus it is slightly more efficient. There is an even better approach
to searching in a sorted list, however.
Binary Search
A second search algorithm on a sorted list is considerably faster than a sequential search
both for finding an item and for discovering that an item is missing. This algorithm is called a
binary search. A binary search divides the list in half (divides by 2—that’s why it’s called
binary search) and decides which half to look in next. Division of the selected portion of the list
is repeated until the item is found or it is determined that the item is not in the list.
This method is analogous to how we look up a word in a dictionary. We open the dictionary
in the middle and compare the word with one we find there. If the word we’re looking for
comes before this word, we continue our search in the left-hand section of the dictionary.

Otherwise, we continue in the right-hand section. We repeat this process until we find the
word. If it is not there, either we have misspelled the word or our dictionary isn’t complete.
The algorithm for a binary search is given below. In this algorithm, the list of values is in the
array data, and the value being looked for is item (see FIGURE 13.8).
1. Compare item to data[middle]. If item = data[middle], then we have found it. If item ˂
data[middle], then we look in the first half of data. If item ˃ data[middle], then we look in
the second half of data.
2. Redefine data to be the half of data that we search next, and repeat Step 1.
3. Stop when we have found item or know it is missing. We know it’s missing when there is
nowhere else to look and we still have not found it.
This algorithm should make sense. With each comparison, at best, we find the item for
which we are searching; at worst, we eliminate half of the remaining list from consideration.
We need to keep track of the first possible place to look (first) and the last possible place
to look (last). At any one time, we are looking only in data[first] through data[last]. When
the function begins, first is set to 0 and last is set to length-1 to encompass the entire list.
FIGURE 13.8 Binary Search
Our three previous search algorithms have been Boolean observer operations. They just
answer a simple question: Is this item in the list? Let’s code the binary search as a void
function that not only asks whether the item is in the list, but also asks which one it is (if the
item is there). To do so, we need to add two parameters to the parameter list: a Boolean flag
found (to tell us whether the item is in the list) and an integer variable position (to tell us which
item it is). If found is false, position is undefined.

Description
Should BinarySearch be a public member of the SortedList class? No. The function returns
the index of the array element where the item was found. An array index is useless to a client
of Sortedlist. The array containing the list items is inaccessible to clients. If you review the
SortedList class declaration, you’ll see that BinarySearch is a private (not public) class
member. We intend to use it as a helper function for the public operations IsThere and Delete.
The documentation reflects that it is a helper function: The function declaration has no
documentation, and the function definition states what algorithm is used.
Let’s do a code walk-through of the binary search algorithm. The value being searched for
is 24. FIGURE 13.9A shows the values of first, last, and middle during the first iteration. In
this iteration, 24 is compared with 103, the value in data[middle]. Because 24 is less than
103, last becomes middle-1 and first stays the same. FIGURE 13.9B shows the situation
during the second iteration. This time, 24 is compared with 72, the value in data[middle].
Because 24 is less than 72, last becomes middle-1 and first again stays the same.
In the third iteration (FIGURE 13.9C), middle and first are both 0. The value 24 is
compared with 12, the value in data[middle]. Because 24 is greater than 12, first becomes
middle+1.

Description

Description
FIGURE 13.9A, B, C and D Code Walk-Through of BinarySearch Function (item Is 13)
In the fourth iteration (FIGURE 13.9D), first, last, and middle are all the same. Again, 24 is
compared with the value in data[middle]. Because 24 is less than 64, last becomes middle-
1. Now that last is less than first, the process stops; found is false.
The binary search is the most complex algorithm that we have examined so far. The
following table shows first, last, middle, and data[middle] for searches of the values 106,
400, and 406, using the same data as in the previous example. Examine the results in this
table carefully.

Description
Notice in this table that whether we searched for 106, 400, or 406, the loop never executed
more than four times. In fact, it never executes more than four times in a list of 11 components
because the list is being cut in half each time through the loop. The following table compares a
sequential search and a binary search in terms of the average number of iterations needed to
find an item.
Average Number of Iterations
Length of List
Sequential Search
Binary Search
10
5.5
2.9
100
50.5
5.8
1000
500.5
9.0
10,000
5000.5
12.4
If the binary search is so much faster, why not use it all the time? It certainly is faster in
terms of the number of times through the loop, but more computations are performed within

the binary search loop than in the other search algorithms. Thus, if the number of components
in the list is small (say, fewer than 20 items), a sequential search algorithm is faster because it
performs less work at each iteration. As the number of components in the list increases, the
binary search algorithm becomes relatively more efficient. Remember, however, that the
binary search requires the list to be sorted, and sorting takes time. Keep three factors in mind
when you are deciding which search algorithm to use:
1. The length of the list to be searched
2. Whether the list is already sorted
3. The number of times the list is to be searched
Given the BinarySearch function (a private member of the SortedList class), it’s easy to
implement the IsThere function (a public member of the class).
Description
The body of IsThere calls BinarySearch, obtaining the result of the search in the variables
found and position. IsThere receives the value of found from BinarySearch and simply passes
it on to the client (via the Return statement). IsThere simply ignores the value returned in the
position argument. Why did we include this third argument when we designed BinarySearch?
The answer is that the Delete operation, which we look at next, does use the position
argument.
Deletion
In the List class’s Delete function, we deleted an item by moving up the last component in the
list to fill the deleted item’s position. Although this algorithm is fine for unsorted lists, it won’t
work for sorted lists. Moving the last component to an arbitrary position in the list is almost
certain to disturb the sorted order of the components. Instead, we need a new algorithm for
sorted lists.
Let’s call BinarySearch to tell us the position of the item to be deleted. Then we can
“squeeze out” the deleted item by shifting up all the remaining array elements by one position:

The algorithm for Shift List Up is
Description
Here is the coded version of this algorithm:
Description
Here is a similar client program that reads words, rather than numbers:

Description

Description
The only change necessary in the SortedList class was from
Description
THEORETICAL FOUNDATIONS Complexity of Searching and
Sorting
We introduced Big-O notation in Chapter 6 as a way of comparing the work done by
different algorithms. Let’s apply it to the algorithms that we’ve developed in this chapter
and see how they compare with each other. In each case, we have a list containing N
values.
In the worst case, our List::IsThere function scans all N values to locate an item. Thus,
it requires N steps to execute. On average, List::IsThere takes roughly N/2 steps to find
an item; however, recall that in Big-O notation, we ignore constant factors (as well as

lowerorder terms). Thus function List::IsThere is an order N— that is, an O(N)—
algorithm.
The alternative version of IsThere is also an O(N) algorithm because even though we
saved a comparison on each loop iteration, the same number of iterations is performed.
However, making the loop more efficient without changing the number of iterations
decreases the constant (the number of steps) that N is multiplied by in the algorithm’s
work formula. Thus, the alternative version of function List::IsThere is said to be a
constant factor faster than List::IsThere.
What about the algorithm we presented for a sequential search in a sorted list? The
number of iterations is decreased for the case in which the item is missing from the list.
However, all we have done is take a case that would require N steps and reduce its time,
on average, to N/2 steps. Therefore, this algorithm is also O(N).
Now consider BinarySearch. In the worst case, it eliminates half of the remaining list
components on each iteration. Thus, the worst-case number of iterations is equal to the
number of times N must be divided by 2 to eliminate all but one value. This number is
computed by taking the logarithm, base 2, of N (written log2N). Here are some examples
of log2N for different values of N:
Description
As you can see, for a list of more than 1 billion values, BinarySearch takes only 30
iterations. It is definitely the best choice for searching large lists. Algorithms such as
BinarySearch are said to be of logarithmic order.

Now let’s turn to sorting. Function Sort contains nested For loops. The total number of
iterations is the product of the iterations performed by the two loops. The outer loop
executes N – 1 times. The inner loop also starts out executing N – 1 times, but steadily
decreases until it performs just one iteration: The inner loop executes N/2 iterations. The
total number of iterations is thus
Ignoring the constant factor and lower-order term, this is N2 iterations, and Sort is an
O(N2) algorithm. Whereas BinarySearch takes only 30 iterations to search a sorted array
of 1 billion values, putting the array into order takes Sort approximately 1 billion times 1
billion iterations!
We mentioned that the SortedList::Insert algorithm forms the basis for an insertion
sort, in which values are inserted into a sorted list as they are input. On average,
SortedList::Insert must shift down half of the values (N/2) in the list; thus it is an O(N)
algorithm. If SortedList::Insert is called for each input value, we are executing an O(N)
algorithm N times; therefore, an insertion sort is an O(N2) algorithm.
Is every sorting algorithm O(N2) ? Most of the simpler ones are, but O(N x log2N)
sorting algorithms exist. Algorithms that are O(N x log2N) are much closer in performance
to O(N) algorithms than are O(N2) algorithms. For example, if N is 1 million, then an O(N2)
algorithm takes 1 million times 1 million (1 trillion) iterations, but an O(N x log2N) algorithm
takes only 20 million iterations—that is, it is 20 times slower than the O(N) algorithm but
50,000 times faster than the O(N2) algorithm.
QUICK CHECK
13.4.1 How does a sorted list ADT differ from a list ADT that includes a sort
operation?
13.4.2 When inserting into a sorted list, what happens to the components that precede
the insertion point and the components that follow it?
13.4.3 Where does the binary search algorithm get its name?
13.4.4 Which operations in a sorted list are different from the operations in an unsorted
list, and how do they differ?
13.4.5 What condition ends a binary search?
13.4.6 What is binary search analogous to in the real world?

13.5 Sorted List of Classes
In Chapter 12, we created an Entry class in preparation for an appointment calendar. Now
let’s create a sorted list of Entry objects. Sorted—by what? Name or time? Because we are
looking ahead toward creating an appointment calendar, let’s keep the list sorted by time.
Can we use our SortedList class as is or must we make some changes? If the items on
the list can be compared using the relational operators, then the only change necessary is the
type of ItemType. If the items on the list are of a type that cannot be compared by the relational
operators, the class must provide a comparison operator. Our Entry class does not have a
comparison function, but our TimeOfDay class does: ComparedTo. We can enhance class Entry
with a ComparedTo function, which merely calls the TimeOfDay ComparedTo function.
Which SortedList functions need to be changed because they compare objects? IsThere,
Insert, and Delete compare two objects. First we add function ComparedTo to class Entry.

Description

Description
Now we can examine the changes in the SortedList class.
IsThere
Because the list is sorted, we should first convert the BinarySearch algorithm. We need to
replace the cascading If statements with a Switch statement using the result of ComparedTo.
The initializations remain the same.
Description
Description

Here is the revised code for function BinarySearch. IsThere doesn’t change; it only calls
BinarySearch.
Description
Insert and Delete
Function Delete calls BinarySearch to find the item to delete and makes no further comparison;
therefore, we don’t need to make any changes in Delete. Insert repetitively compares item to
a list value until one is found that is greater than item or there are no more values to check.
Thus, the code can be changed without having to rewrite the algorithm. We will also need to
include the RelationType.h header file to perform the comparisons. The change is highlighted
in the following code:

Description
Description
Here is a client program that inserts entries into a sorted list, demonstrates a test for a
duplicate item, and then outputs the list:

Description
Output:
Description
A word of caution is in order here: When you have classes that contain other classes that
contain other classes, you should use the preprocessor commands

Description
around the lower-level classes, to avoid duplicate definitions.
QUICK CHECK
13.5.1 What value is used to keep a list of objects sorted?
13.5.2 What value can we use to keep a sorted list of Entry objects?

13.6 More on UML Diagrams
In Chapter 12, we introduced UML diagrams that show how classes relate to one another. It is
clear that the sorted list of Entry objects is quite complex. Let’s examine how the classes
relate to one another.
Class Entry contains (through composition) objects of classes Name and TimeOfDay.
In turn, class SortedList contains an array of Entry objects.
Now add the client program into the mix. What is its relationship to these classes? In our
example, main declares three variables of type Entry and then inserts them into a variable of
type SortedList. Through these, our client program also contains objects of classes Name and
TimeOfDay.

Technically, main is just a function. However, we give it a box in the UML diagram to show
its relationship with the other classes. In some other object-oriented programming languages,
such as Java, main or its equivalent would be defined within a class. Because C++ is based
on C, which is not object oriented, code can be organized into either classes or functions.
Some programmers would argue that, to make a C++ application more purely object oriented,
main should contain only a call to a method within a class; they would, therefore, omit main
from the UML class diagram. Because we find it useful to have main do more than this, we
diagram it as if it is in a separate class.
Problem-Solving Case Study
CALCULATING EXAM STATISTICS REVISITED
PROBLEM: You are the grader in your Government class. The teacher has asked you to
prepare the following statistics. (No, this isn’t a misprint! We are going to solve the same
problem that we solved in Chapter 11, but in an entirely different way.) However, she has
changed the input data and added some new output requirements. Each line in the input
file contains a grade, which may be in either integer or real form, and a name. Three
additional outputs must be provided: the name(s) of the students with the maximum grade,
the names of the students above the average, and the names of the students below the
average.
INPUT: A file, whose name is input from the keyboard, containing test grades.
OUTPUT: A file, whose name is input from the keyboard, showing the following statistics
properly labeled:
Number of grades
Average grade
Lowest grade

Highest grade
Number of grades above the average
Number of grades below the average
Name of student(s) with the maximum grade
Names of students above the average
Names of students below the average
DISCUSSION: We have just designed and implemented several variations of a List
class. Let’s think about our current problem in terms of a list of grades. The first five tasks
remain the same, but let’s look at them in terms of list operations. We need to average the
values in the list, find the maximum value in the list, find the minimum value in the list,
count the number of values above the average, and count the number of values below the
average. We know how to calculate an average: We sum the list of grades and divide by
the number of grades. We found the minimum and maximum values in a file of numbers in
the Studio Design program; the same algorithm can be used here. The third task involves
looking at each grade, comparing it to the average, and incrementing one of two counters.
If all we had to do was find the average and the minimum and maximum grades, we
could do the processing at the same time that we read the data values. However, the task
of outputting the number of grades above and below the average requires that each grade
be examined twice: once to calculate the average, and again to compare each grade to the
average. We can also find the minimum and maximum values as we initially read the
grades.
The passive way of implementing this problem would be to pass the list of
students/grades to functions that calculate the various statistics. The active (object-
oriented) way of viewing the problem is to bind the list together with the operations into a
class. But what would the structure look like? First we need a class that combines the
student name and the grade. We have a Name class, but would a simple string do as well?
You ask for a sample data file.
Description
The grade comes first, followed by the first and last names. Thus the entire name could
be read, stored, and output as a single string. Should the grade be represented by an
integer or a real number? Because both an integer and a real value can be read as a float,
we can represent the grade as a real number. Which list class should we use to hold the
grades? If we keep the list sorted by grade, we don’t have to search for the minimum
grade. Thus we need a ComparedTo function in the class that represents a student.

Description
Description
Here, then, is the specification for class Student:
Which other data members do we need in addition to our list? At first glance, it looks like
we need variables to hold the average, maximum grade, minimum grade, number below
the average, and number above the average. On second thought, however, we realize that
we can access the minimum grade directly, and we can calculate the number above the
average from the number of grades and the number below the average. The teacher
confirms that if a student has the average grade they will be counted in the above-average
group.

Description
Description
Now we can write the specification of our StatisticsList class:
Where do all the calculations take place? In the constructor! The operations are bound
within the class.
StatisticsList(In/out: inFile) (only constructor)
Get student

WHILE more students
Insert student into grade list
Set sum to sum plus student.GetGrade()
IF student.grade greater than maxSoFar
Set maxSoFar to student.GetGrade()
Get student
Set average to sum / list.GetLength()
WHILE (list.GetNextItem().GetGrade() < average)
Increment numBelow
Get Student(In/out: inFile)
Return value: Student
inFile >> student.grade >> student.getline
GetStudent should be coded inline within the constructor.
The next five functions are just one line long and don’t need further decomposition. The
last three involve going through the list and writing the names of students who have the
maximum grade, are above the average, or are below the average.
In getting the students with the maximum grade, there may be more than one such
student. So first, we must look for the maximum grade and output the associated student.
Then, we must cycle through the rest of the list outputting associated names.
Students with Max Grade(In/out: outFile)
list.ResetList()
Set student to GetNextItem()
WHILE maxGrade > (student.GetGrade())
Set student to GetNextItem()
Write on outFile student.GetName, “had the maximum score.”
WHILE list.HasNextO
Write on outFile list.GetNextItem().GetName, “ had the maximum score.”
Students Above Average(In/out: outFile)
We know that there are numBelow people whose scores are below the average. Thus, we
must simply access and skip these students; then we write the rest of the list.
list.ResetList()
FOR count going from 1 through numBelow
Set item to list.GetNextItem()
Write on outFile “Students who scored above the average:”
FOR count going from numBelow+1 list.GetLength()
Write on outFile list.GetNextItem.GetName()
Students Below(In/out: outFile)
We just need to access and output the first numBelow students, which are those students
whose grades are below the average.

list.ResetList()
Write on outFile “Students who scored below the average:”
FOR count going from 1 through numBelow
Write on outFile list.GetNextItem().GetName( )
We show only StatisticsList.cpp, the driver, and the input and output files here.
We’ve seen the other files in this application earlier. Note that the SortedList class must be
changed so that itemType is defined as Student.
Description

Description

Description

Description

Here is a sample input file and the output file generated by a run of the application:
Statistics.dat:
Description
Statistics.out:
Description

UML Diagrams: Here are the UML class diagrams for the classes in this problem.
Description
Description

Description
Here is the UML diagram that shows how all of these classes are related.
Description

TESTING: This implementation is based on a list of values. We must test for cases in
which there are no grades, one grade, a few grades, and exactly the maximum number of
grades. We already took care of the case where there were just a few grades. You are
asked in the Case Study Follow-Up questions to design a full test plan for this Problem-
Solving Case Study.
Which algorithm is more efficient: the array algorithm from Chapter 11 or the list
algorithm? We can’t answer that question because it depends on the range of possible
grades and the sizes of the data sets. The amount of work done in the first solution is
based on the range of grades; the loops go from 0 to 100 (or somewhere in between). The
amount of work done in the second solution is based on the number of grades; the loops
go from 0 to the number of grades. Thus, the choice of algorithm depends on the context in
which it will be used.

Graphical User Interface (GUI)
In Chapter 11 we refactored a similar exam statistics application to replace the console I/O for
getting file names. However, the program in this chapter provides additional functionality that
we would like to integrate into a user-friendly graphical interface. In particular, the
StatisticsList class defines methods for retrieving a list of students who are above the
average grade, below the average grade, have a maximum grade, and so forth. It would be
nice if we could build an interface that not only displays the statistics and student lists, but also
allows us to press buttons to view the different student lists as we wish.
To do this requires a specially designed GUI that is more tightly integrated with the program
than the dialog widgets we have seen previously. Although we delay the discussion of how
such GUIs are implemented until later chapters, here we begin looking at how a graphical
interface can be designed to convey more complex information to a user in response to user
actions such as button presses. To do that, we introduce a custom GUI that we have built and
included in the library that accompanies the book. Using that GUI requires us to make
changes to the existing application so that the output is sent to strings, for internal use by the
GUI, rather than to a file.
We will still rely on the off-the-shelf FileDialog widget to open an input file containing exam
data; however, the rest of the application will be driven by our custom GUI. As was the case
in previous chapters, we include the header file for the dialog widgets:
Because our GUI version will no longer be writing the statistics data to an output file, we will
refactor the OpenFiles function to require only a single parameter for the input file stream and
replace the console I/O with calls to create a FileDialog widget (and because it is just opening
a single file, we also change the name):
Description
As we saw in Chapter 12, all of our GUI applications moving forward will require us to first
create a new QApplication object that is passed the arguments to main to initialize the GUI
system to handle events and actions that are required by more complex interfaces:

We will then declare an ifstream object to be used by the OpenFile function to open the input
file containing the exam statistics and immediately after that call the OpenFile function passing
in the ifstream:
Description
Assuming the input file has been opened successfully, we can then instantiate a
StatisticsList object that will read in the exam statistics and build a sorted list of Student
objects:
We will then use our custom GUI to display the various statistics that are available from the
StatisticsList object. The creation and display of this graphical interface is similar to what we
have seen before; however, we introduce a new method for rendering the interface to the
screen, called show(). Previous widgets used the display() method that was specific to dialog
components. The show() method is used by the Qt graphical framework upon which the
dialogs are built and is what custom Qt GUI objects use to render to the screen.
The ExamStatisticsWindow is the GUI object that we have created specifically for this
application, to display the list of students; the average, maximum, and minimum grade; and
the list of students who achieved the max grade, above average grades, and below average
grades. When the window is created, it displays five text boxes. Two of the boxes are larger,
for showing lists, and three are smaller, for showing the statistics. The upper list box will
initially be populated with a list of all of the students and their grades. At the bottom of the
window are three buttons. Pressing any of them will cause the corresponding student list to be
shown in the lower list box. Here is how the GUI appears after the call to show:

Description
After this window appears on the screen, when the user presses one of the buttons, it will
call the corresponding StudentsMaxGrade, StudentsAbove, or StudentsBelow method from the
StatisticsList class, and then use the lower text box to display what the method returns.
In the existing code, these functions receive a reference to an ofstream and then write the
output to that file. To make them work with our GUI, we refactor them to take an ostringstream
reference parameter and then have them write the output as a string that is returned for
display by the GUI. Here are the rewritten methods:

Description
To enable our GUI to populate the upper text box with the complete student list, we also
create a new method for the StatisticsList class to write a list of all students and their exam
grades to a string for display in the GUI:
Description
Because main has changed significantly from the original version, we show its code here,
so you can see all of the changes in one place:

Description

These changes are sufficient to have our application send its output to our custom-designed
GUI to display useful information on demand. Here is what the ExamStatisticsWindow looks
like when we run the application and then press the Above Average Grades button:
Description
At this point we are not yet ready to explain how to construct a custom GUI like this. Our goal
here is just to show you the kind of interface that can be built, using the tools we will introduce
in the next four chapters. In Chapter 14, we explain how to build a window that has multiple
components for output and how we position them in the window. In Chapter 15, we explore the
design of a custom GUI for an appointment calendar application. We will introduce buttons
and a list widget, which generate what are called events, and how we write a method, called
an event handler, to respond to pressing a button and clicking a list item. In Chapter 16, we
convert a console-based interface into a custom GUI that further explores text boxes, buttons,
and events for determining the weight and center of gravity of an aircraft. By that point, you will

have learned enough of the Qt framework to be able to construct the interface we have just
seen. Lastly, in Chapter 17, we explore ways of displaying tables of values, taken from data
structures that we’ll also see in that chapter.

Testing and Debugging
In this chapter, we have discussed, designed, and coded algorithms to construct and
manipulate items in a list. In addition to the basic list operations IsFull, IsEmpty, GetLength,
ResetList, HasNext, and GetNextItem, the algorithms included three sequential searches, a
binary search, insertion into sorted and unsorted lists, deletion from sorted and unsorted lists,
and a selection sort. We have partially tested the List and SortedList classes, in which the
items are numeric values or strings, and the SortedList class, in which the items are objects.
We have tested our algorithms with lists of intermediate sizes. We should also test them with
lists containing no components, one component, two components, MAX_LENGTH-1 components,
and MAX_LENGTH components.
When we wrote the precondition stating that the list was not full for our list operations, we
indicated that we could handle the problem another way—we could include an error flag in the
function’s parameter list. The function could call IsFull and set the error flag. With this
approach, the insertion would not take place if the error flag were set to true. Both options are
acceptable ways of handling the problem. The important point is that we clearly state whether
the calling code or the called function is to check for the error condition. However, it is the
calling code that must decide what to do when an error condition occurs. In other words, if
errors are handled by means of preconditions, then the user must write the code to guarantee
the preconditions. If errors are handled by flags, then the user must write the code to monitor
the error flags.
Testing and Debugging Hints
1. Review the Testing and Debugging Hints for Chapter 12.
2. With string input, the >> operator stops at, but does not consume, the first trailing
whitespace character. Likewise, if the get or getline function stops reading early
because it encounters a newline character, the newline character is not consumed.
3. General-purpose functions (such as ADT operations) should be tested outside the
context of a particular program, using a test driver.
4. Choose test data carefully so that you test all end conditions and some conditions in the
middle. End conditions are those that reach the limits of the structure used to store them.
For example, when testing a list, the test data should include cases in which the number
of components is 0, 1, and MAX_LENGTH, as well as between 1 and MAX_LENGTH.
5. If a list ADT doesn’t specify a precondition requiring the client to ensure that the number
of items is less than a known maximum, be sure to include a test that verifies correct
handling of an attempt to insert too many items.
6. Enclose lower-level classes in

Description

Summary
This chapter provided practice in working with lists stored in one-dimensional arrays. We
examined algorithms that insert, delete, search, and sort data stored in a list, and we wrote
functions to implement these algorithms. We can use these functions again and again in
different contexts because they are members of general-purpose C++ classes (List and
SortedList) that represent list ADTs.
We also saw algorithms for sequential and binary search, and for selection and insertion
sorts. In developing our list classes, we explored the semantic distinctions between an
unsorted list, an unsorted list with a sort operation, and a sorted list. Through all of this design
effort, we gained greater experience in object-oriented design and the use of UML class
diagrams.

Quick Check Answers
13.1.1 Variable length, linear, and homogenous. 13.1.2 Any type. 13.2.1 isEmpty, isFull,
GetLength, IsThere, HasNext, GetNextItem 13.2.2 Insert, Delete, ResetList 13.2.3 A
data array containing the specified item type in each component, and a length represented
by an int. 13.3.1 At the end of the list (assuming the list isn’t already full). 13.3.2 When it
has examined the last element in the list. 13.3.3 Search for the value, delete the value, shift
any succeeding values up one place. 13.3.4 Two. 13.3.5 0 13.3.6 It must check whether
the length is equal to 0. 13.3.7 It starts at the beginning of the list and looks at each item in
sequence until it finds the element it is looking for. 13.4.1 The components of a sorted list
are always kept in order, but the components of a regular list are sorted only after the sort
operation executes, and remain in order only until the next insertion or deletion. 13.4.2 The
components that precede the insertion point remain where they are, and the ones following
the insertion point shift over one place to make room. 13.4.3 The name comes from its
pattern of dividing the area of the search by two on each iteration. 13.4.4 There is no
sorting operation in the sorted list. The insert operation inserts a new value in its proper
place rather than at the end of the list. The delete operation shifts the succeeding
components up one place, rather than moving the last component into the vacated
position. Searching in the sorted list can be done with a binary search rather than a linear
search. 13.4.5 Either the value is found or last is less than first and the value has not been
found. 13.4.6 How we look up a word in the dictionary. 13.5.1 It depends on the class of the
objects and how we want the list sorted. 13.5.2 Either name or time.

Exam Preparation Exercises
13.1 Why do we say that a list is a “linear data structure”?
13.2 What do we mean when we say that a list is “homogeneous”?
13.3 If the Length operation associated with an unsorted list returns 43, and we then
call the Delete operation for the list, passing it a value that matches the 21st item in
the list:
a. What is the index of the component that is deleted?
b. What is the index of the component that takes its place?
c. What does the Length operation return after the deletion?
d. How many components in the list change their positions as a result of the deletion?
13.4 If ItemType is float, how do we need to change the following While loop condition,
as written in the sequential search, and why do we need to change it?
13.5 The following statements are supposed to swap two values in an array, but they
are in the wrong order. Rearrange them into the proper order.
Description
13.6 In a selection sort, what is accomplished by the inner loop each time it executes?
13.7 If the GetLength operation associated with a sorted list returns 43, and we then
call the Delete operation for the list, passing it a value that matches the 21st item in
the list:
a. What is the index of the component that is deleted?
b. What is the index of the component that takes its place?
c. What does the Length operation return after the deletion?
d. How many components in the list change their positions as a result of the deletion?
13.8 On average, a sequential search of a sorted list takes the same number of
iterations as searching an unsorted list. True or false?

13.9 We should use a binary search for large sorted lists, but a sequential search is
more efficient when a list has few components. True or false?
13.10 What is the log (base 2) of 32?
13.11 Why don’t we need a separate sorting operation in a sorted list ADT?
13.12 A sorted list contains 16 elements, and the binary search operation is called
with a value that matches the 12th value in the list. How many iterations does it take
for the binary search to find this match?
13.13 Is the class Entry, as defined in this chapter, mutable?
13.14 Is our SortedList class mutable?

Programming Warm-Up Exercises
13.1 Write a C++ Boolean function named Deleted that has three parameters:
someItem (of type ItemType as used in this chapter), oldList, and newList (both of type
List as defined in this chapter). The function returns true if someItem is found in
oldList but is not present in newlist.
13.2 The List type in this chapter allows us to store only one copy of an item in the
list. Sometimes it is useful to have a list in which an item can appear any number of
times. Change the implementation of the Insert function so that it adds an item to the
list any time it is inserted.
13.3 What is wrong with the following code segment, and what must be changed in
type List to make it work correctly?
Description
Description
13.4 We would like to add a DeleteAll function to the List type from Exercise 13.2
that deletes all occurrences of an item from a list. Write the code that must be added
to the specification file for the type to enable us to add this function.
13.5 Write the implementation of the DeleteAll function as described in Exercise 13.4.
13.6 We would like to add a Replace function to the List type in this chapter that takes
two parameters, oldItem and newItem of ItemType. The function finds oldItem in the list,
deletes it, and inserts newItem in its place. The list is unchanged if oldItem is not
present in the list. Write the code that must be added to the specification file for the
type to enable us to add this function.
13.7 Write the implementation of the Replace function as described in Exercise 13.6.

13.8 The SortedList type keeps items in ascending order. Which function(s) would
need to be changed to make the list keep the items in descending order?
13.9 Change the implementation of the BinarySearch function so that it will work with a
list that keeps items in descending order.
13.10 In Exercise 13.5, you wrote a DeleteAll function for the List type with
duplicates. Implement a DeleteAll function for the SortedList type that allows
duplicates, taking advantage of the fact that all occurrences of the item are stored in
adjacent locations in the array. Note that the binary search does not necessarily return
the position of the first occurrence of an item; it can return the position of any
matching item. Thus, in this case, it may be more efficient to use a linear search to
find the starting position for the matching items. Be sure that your function updates the
length of the list as necessary.
13.11 In Exercise 13.6, you wrote a Replace function for the List type that deletes one
value and replaces it with another. Reimplement the Replace function for the
SortedList type. Note that in this case, the replacement value needs to be inserted in
the proper position in the list to maintain the ordering of the items.
13.12 Write a code segment that fills a SortedList called inData with values that are
input from a file called unsorted.

Programming Problems
13.1 Imagine you have been asked by a first grade teacher to create a hangman
game for her students to help them with spelling and word recognition. In the game of
hangman you are first presented with a list of blanks representing unknown letters of a
hidden word. You must then guess a letter to see if that letter exists in the word. If it
does, the blank that corresponds to the guessed letter is then displayed along with
blanks for the letters that have not been guessed yet. If you guess a previously
guessed letter, you get to try again. If you guess wrong, you incrementally move
toward being hung. You have eight bad guesses until you lose the game. To represent
the different states of “being hung” we will use the values PLATFORM, HEAD, BODY,
LEFT_ARM, RIGHT_ARM, LEFT_LEG, RIGHT_LEG, and HUNG. To implement the
game you should use the unsorted List ADT to represent the word being guessed.
Each element in the list should be a struct that stores the letter of the word and a
Boolean that indicates whether the letter or a blank should be displayed. You should
use a second list to represent the letters that have already been guessed and an
enumeration to represent the states of the game. Your program should keep asking
the user for another guess until either the entire word has been guessed or the state of
the game is HUNG. After each guess, the program should display the current state of
the word to be guessed, the list of characters already guessed, and the state of the
game.
13.2 Write a program using the List class from this chapter that implements a to-do
list. The to-do items will be entered as strings. The user should be prompted to enter a
command (add an item, mark an item as done or partially done, delete an item, and
output the list) and data as necessary. Simply storing items in the list is easy, but the
List class doesn’t directly support the recording of the status of each task. You might
want to go about this in several different ways. One approach would be to implement
a struct or a class that represents an item and its status, and then modify the List
class to work with this struct or class as its item type. Another way would be to keep
three lists: Done, Partial, and Undone. When an item is created, it enters the Undone list.
When its status is changed, it moves to one of the other lists as appropriate. Choose
the approach that you prefer, and implement the application using proper style,
effective prompts, and sufficient documentation.
13.3 Many instructors like to see the distribution of scores on an exam before they
assign grades. You’re working for an art history professor who has asked you to

develop a program that will read all of the scores from an exam and output a bar chart
that shows their distribution. The range of the scores varies from exam to exam, and
there are at most 250 students in the class. Use or modify the SortedList class from
this chapter as necessary to help you do this task. The integer scores are entered into
a file called exams.dat in random order. Your program’s job is to read in the data, sort
it, and output a bar chart with one * (star) for each exam that has a particular score.
The first bar in the chart should be the highest score, and the last bar in the chart
should be the lowest score. Each line of output should start with the score value,
followed by the appropriate number of stars. When there is a score value that didn’t
appear on any exams, just output the value and no stars, then go to the next line.
13.4 Enhance the program in Problem 13.3 as follows: The data file now contains a
score and a name. Modify the SortedList class so that it uses a struct consisting of
the score and the name as its fields. The program should input the file data into the
modified list. In addition to displaying the bar chart, the program should output the
sorted list to a file called byscore.dat.
13.5 You’ve gathered lists of email addresses from a variety of sources, and now you
want to send out a mass mailing to all of the addresses. However, you don’t want to
send out duplicate messages. All of the email addresses (represented as strings)
have been combined on a single file called rawlist.dat. You need to write a program
that reads all of the addresses and discards any that have been previously input. Use
one of the list classes from this chapter, modifying it as necessary to work with string
data and to deal with as many as 1000 items. After all of the data have been read,
output the new mailing list to a file called cleanlist.dat.
13.6 You’re working for the state vehicle registry, and it has just been discovered that
the people who make the license plates have been mistakenly producing occasional
duplicates. You have a file (platesmade.dat) containing a list of plate numbers, which
are recorded as the license plates are made. You need to write a program that reads
this file and identifies any duplicates in the list so that notices can be sent out to recall
them. The plate numbers, which consist of letters and numbers, should be stored as
strings. Output the duplicates into a file called recallplates.dat. Use the SortedList
class from this chapter to help you in writing this application, modifying it if necessary.

Case Study Follow-Up
1. Which of the two implementations of the statistics program (Chapter 11 or Chapter
13) do you think is clearer? Why?
2. For which function did StatisticsList not ensure the preconditions? Correct this
error and rerun the driver, being sure to test whether the precondition is checked.
3. Write a test plan for the statistics program.
4. Is the StatisticsList class mutable? Explain your answer.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 4
Dynamic Data and Linked
Lists
KNOWLEDGE GOALS
To understand the concept of a linked data structure.
To understand the difference between deep and shallow copy operations.
To know and understand the four member functions that should be present in any
class that manipulates dynamic data.
SKILL GOALS
To be able to:
Create, access, and destroy dynamic data.
Create linked data structures.
Manipulate data in a linked structure.
Distinguish between a reference variable and a pointer variable.
In Chapter 10 we looked at pointer types and reference types. A variable of one of these types
does not contain a data value; it contains the memory address of a value. We focused on
understanding how to create and manipulate pointers to static data defined in our C++
programs. The true power of pointers, however, becomes apparent with the introduction of
dynamic data. Dynamic data allow programs to operate over data structures without a
predetermined size and lifetime. Dynamic data structures can grow and shrink over the
execution of a program, providing flexibility to be efficient in both time and space. It is the
creation and manipulation of dynamic data that we emphasize here by studying the linked list
dynamic data structure.

14.1 Dynamic Data
In Chapter 9, we described two categories of program data in C++: static data and automatic
data. Any global variable is static, as is any local variable explicitly declared as static. The
lifetime of a static variable is the lifetime of the entire program. In contrast, an automatic
variable—a local variable not declared as static—is allocated (created) when control reaches
its declaration and is deallocated (destroyed) when control exits the block in which the
variable is declared.
With the aid of pointers, C++ provides a third category: dynamic data. Dynamic variables
are not declared with ordinary declarations; instead, they are explicitly allocated and
deallocated at execution time by means of two special operators, new and delete. When a
program requires an additional variable, it uses new to allocate the variable. When the program
no longer needs the variable, it uses delete to deallocate it. The lifetime of a dynamic variable
is, therefore, the time between the execution of new and the execution of delete. The
advantage of being able to create new variables at execution time is clear: When the nature of
a data structure is such that it can grow and shrink, we can perfectly match the allocation of
memory to whatever it needs.
Dynamic data Variables created during execution of a program by means of special
operations. In C++, these operations are new and delete.
Allocating Dynamic Data
The new operation has two forms, one for allocating a single variable and one for allocating an
array. Here is the syntax template:
Description
The first form is used for creating a single variable of type DataType. The second form creates
an array whose elements are of type DataType; the desired number of array elements is given
by IntExpression.
Here is an example that demonstrates both forms of the new operation:

Description
Normally, the new operator does two things: It creates an uninitialized variable (or an array)
of the designated type, and it returns the address of this variable (or the base address of an
array). It is this address that is stored into the pointer variable. If the computer system has run
out of space in which to store dynamic data, however, the program terminates with an error
message. In Chapter 16, we show how to test for this condition and keep the program from
terminating.
Variables created by new are said to reside on the free store (or heap), a region of memory
set aside for dynamic variables. The new operator obtains a chunk of memory from the free
store and, as we will see, the delete operator returns it to the free store.
Free store (heap) A pool of memory locations reserved for allocation and deallocation of
dynamic data.
A dynamic variable is unnamed and cannot be addressed directly. Instead, it must be
addressed indirectly through the pointer returned by the new operator. Following is an example
of creating dynamic data and then accessing the data through pointers:

Description
FIGURE 14.1 pictures memory after the effect of executing this code segment. Note that the
contents of the struct to which patientPtr points have not been changed. What patientPtr
points to was stored in the array, not a copy of the pointer.

Description
FIGURE 14.1 Picture of Memory After Execution of Code Segment
Deleting Dynamic Data
Dynamic data should be destroyed when it is no longer needed. The built-in operator delete is
used to destroy a dynamic variable. The delete operation has two forms: one for a single
variable, the other for an array.

Description
Using the previous example, we can deallocate the dynamic data pointed to by intPtr,
patientPtr, and patientArray with the following statements:
Description
After execution of these statements, the values pointed to by intPtr, patientPtr, and
patientArray are undefined; that is, they may or may not still contain the deallocated data.
Before using these pointers again, you must assign new values to them (that is, store new
memory addresses into them).
Until you gain experience with the new and delete operators, it is important to pronounce the
statement
accurately. Instead of saying, “Delete intPtr,” it is better to say, “Delete the value to which
intPtr points.” The delete operation does not delete the pointer; it deletes the pointed-to value.
When using the delete operator, you should keep two rules in mind:
1. Applying delete to the NULL pointer does no harm; the operation simply has no effect.
2. Excepting Rule 1, the delete operator must only be applied to a pointer value that was
obtained previously from the new operator.
The second rule is important to remember. If you apply delete to an arbitrary memory
address that is not in the free store, the result is undefined and could prove to be very
unpleasant.
The new operator lets you create variables only as they are needed. When you are finished
using a dynamic variable, you should delete it. It is counterproductive to keep dynamic
variables when they are no longer needed—a situation known as a memory leak. If a
memory leak is permitted to occur too often, you may run out of memory.

Memory leak The loss of available memory space that occurs when dynamic data are
allocated but never deallocated.
Let’s look at another example of using dynamic data.
Description
Here is a more detailed description of the effect of each statement:
Description

Description
FIGURE 14.2A and B Results from Sample Code Segment
In FIGURE 14.2D, notice that the variable pointed to by ptrl before the assignment statement
is still there. It cannot be accessed, however, because no pointer is pointing to it. This isolated
variable is called an inaccessible object. Leaving inaccessible objects on the free store
should be considered a logic error and is a cause of memory leaks.
Notice also that in FIGURE 14.2E, ptrl is now pointing to a variable that, in principle, no
longer exists. We call ptrl a dangling pointer. If the program later dereferences ptrl, the
result will be unpredictable. The pointed-to value might still be the original one (44), or it might
be a different value stored there if that space on the free store has been reused.
Inaccessible object A dynamic variable on the free store without any pointer pointing to it.
Dangling pointer A pointer that points to a variable that has been deallocated.
Both situations shown in FIGURE 14.2E—an inaccessible object and a dangling pointer—
can be avoided by deallocating *ptr1 before assigning ptr2 to ptrl, and by setting ptrl to NULL
after deallocating *ptr2.

Description
Description
FIGURE 14.2C, D, and E Results from Sample Code Segment
Description
Constants and Dynamic Data

There is another way to avoid the inaccessible object problem. Just as C++ allows us to
define constants of other simple types, so a pointer can be made constant. In the following
declaration, patientPtr is a constant pointer that is initialized to the address of a dynamic
memory location representing a struct of type PatientRec:
Once this code is executed, patientPtr will always point to the same location. We can
change the values stored in that location by dereferencing patientPtr, but we cannot assign a
new value to patientPtr itself; that is, we cannot make it point to another place in memory. As
a result, the location it points to can never become inaccessible. When we apply delete to a
constant pointer, we can be assured that we are deleting precisely what was originally
allocated, thereby preventing a memory leak.

Description

FIGURE 14.3 Results from Sample Code Segment After It Was Modified
In the next section we look at the use of pointers in another form of list implementation.
QUICK CHECK
14.1.1 What is the keyword that we use in writing a C++ allocation expression?
14.1.2 What is the keyword that we use in writing a C++ deallocation expression?
14.1.3 What is dynamic data?
14.1.4 What are the two things the new operator does?
14.1.5 Where do variables created by new reside?
14.1.6 What does the delete operator do in terms of the free store?

14.2 Sequential Versus Linked Structures
As we pointed out in Chapter 13, many problems in computing involve lists of items. In that
chapter, we implemented the List ADT using an array. The size of an array is fixed, but the
number of items in the list varies.
If the list we are implementing is a sorted list, certain operations can be made more
efficiently using an array representation. For example, searching for a particular value can use
a binary search. However, inserting and deleting items from a sorted list is inefficient with an
array representation. To insert a new item, we must shift the array elements to make room
(see FIGURE 14.4). Similarly, deleting an item from the list requires shifting the elements to
close the gap.
When insertions and deletions will occur frequently, there is a better data representation for
a list: the linked list. A linked list is a collection of items, called nodes, each of which has an
explicit connection to its successor in the list. Because of this, nodes do not have to be in
consecutive memory locations. Each node, typically represented as a struct, consists of two
members:
Linked list A list in which the order of the components is determined by an explicit link
member in each node, rather than by the sequential order of the components in memory.
A component or item member, which contains one of the data values in the list
A link member, which gives the location of the next node in the list
Description
FIGURE 14.4 Inserting into a Sequential Representation of a Sorted List

Description
FIGURE 14.5 Linked List
FIGURE 14.5 shows an abstract diagram of a linked list. An arrow is used in the link
member of each node to indicate the location of the next node. The slash (/) in the link
member of the last node signifies the end of the list. A separate named variable points to the
first node in the list; this pointer is called the external pointer to the list. This variable is not
within the list; rather, its purpose is to give the location of the first node. The identifier “head” is
sometimes used for the external pointer to a list.
External pointer A pointer that points to the first node in a linked list.
Description
As you look at FIGURE 14.5, you should observe two things. First, we have deliberately
arranged the nodes in random positions. We have done so to emphasize that the items in a
linked list are not necessarily in adjacent memory locations (as they are in the array
representation of FIGURE 14.4). Second, you may already be thinking of pointers when you
see the arrows in the figure—and you would be right.
QUICK CHECK
14.2.1 Why is it often more space efficient to implement a list using pointers rather
than an array?
14.2.2 Which member do we need in addition to the data members of a struct to use
the struct as a node in a linked list?
14.2.3 What is the primary difference between an array and a linked list?
14.2.4 What frequently occurring operations are more efficient for a linked list
representation?

14.2.5 What is an external pointer?

14.3 Creating a Dynamic Linked List: A WalkThrough
Example
In this section we walk through the creation of an example linked list so we can see how the
process works. We represent the list as a linked structure whose nodes are dynamically
allocated from the free store; the link member of each node contains the memory address of
the next node. In this data representation, called a dynamic linked list, the arrows in the
diagram of FIGURE 14. really do represent pointers (and the slash in the last node is the NULL
pointer). We access the list with a pointer variable that holds the address of the first node in
the list. This pointer variable, named head in FIGURE 14.5, is called the external pointer or
head pointer. Every node after the first node is accessed via the link member in the node
before it.
Such a list can expand or contract as the program executes. To insert a new item into the
list, we allocate more space from the free store. To delete an item, we deallocate the memory
assigned to it. We don’t have to know in advance how long the list will be (that is, how many
items it will hold). The only limitation is the amount of available memory space. Data
structures built using this technique are called dynamic data structures.
Dynamic linked list A linked list composed of dynamically allocated nodes that are linked
together by pointers.
External (head) pointer A pointer variable that points to the first node in a dynamic linked
list.
Dynamic data structure A data structure that can expand and contract during execution.
To create a dynamic linked list, we begin by allocating the first node and saving the pointer
to it in the external pointer. We then allocate a second node and store the pointer to it into the
link member of the first node. We continue this process—allocating a new node and storing
the pointer to it into the link member of the previous node—until we have finished adding
nodes to the list.
Let’s look at how we can use C++ pointer variables to create a dynamic linked list of float
values. We begin with the following declarations:

Description
The order of these declarations is important. The Typedef for NodePtr refers to the identifier
NodeType, so the declaration of NodeType must come first. (Remember that C++ requires every
identifier to be declared before it is used.) Within the declaration of NodeType, we would like to
declare link to be of type NodePtr, but we can’t because the identifier NodePtr hasn’t been
declared yet. However, C++ allows forward (or incomplete) declarations of structs, classes,
and unions:
Description
The advantage of using a forward declaration is that we can declare the type of link to be
NodePtr just as we declare head, currPtr, and newNodePtr to be of type NodePtr.
Given the preceding declarations, the following code fragment creates a dynamic linked list
with the values 12.8, 45.2, and 70.1 as the components in the list:

Description
Let’s go through each of these statements, describing and seeing what is happening.
head = new NodeType;
Description
A dynamic variable of type NodeType is created. The pointer to this
new node is stored into head. Variable head is the external pointer to
the list we are building.
head->component = 12.8;
Description
The value 12.8 is stored into the component member of the first
node.
newNodePtr = new
NodeType;
Description
A dynamic variable of type NodeType is created. The pointer to this
new node is stored into newNodePtr.
newNodePtr->component =
4 5.2;
The value 45.2 is stored into the component member of the new
node.

Description
head->link = newNodePtr;
Description
The pointer to the new node containing 45.2 in its component
member is copied into the link member of *head. Variable
newNodePtr still points to this new node. The node can be accessed
either as *newNodePtr or as *(head->link).
currPtr = newNodePtr;
Description
The pointer to the new node is copied into currPtr. Now currPtr,
newNodePtr, and head->link all point to the node containing 45.2 as
its component.
newNodePtr = new
NodeType;
Description
A dynamic variable of type NodeType is created. The pointer to this
new node is stored into newNodePtr.
newNodePtr->component =
70.1;
Description
The value 70.1 is stored into the component member of the new
node.
currPtr->link =
newNodePtr;
Description
The pointer to the new node containing 70.1 in the component
member is copied into the link member of the node that contains
45.2.
newNodePtr->link = NULL; The pointer constant NULL is stored into the link member of the last
node in the list. NULL in the link member of a node indicates the

Description
end of the list. NULL is shown in the diagram as a slash (/) in the
link member.
currPtr = newNodePtr;
currPtr is updated to point to the last node in the list (not shown).
We would like to generalize this algorithm so that we can use a loop to create a dynamic
linked list of any length. In the algorithm, we used three pointers:
1. head, which was used in creating the first node in the list and became the external pointer
to the list
2. newNodePtr, which was used in creating a new node when it was needed
3. currPtr, which was updated to always point to the last node in the linked list
When building any dynamic linked list by adding each new node to the end of the list, we
always need three pointers. The algorithm that we used is generalized here to build a linked
list of four integer values from the standard input device.
Set head to new node
Read a number
Set head->component to number
Set currPtr to head of list
FOR count going from 1 through 3
Set newNodePtr to new node
Set newNodePtr->component to next number
Set currPtr->link to new node
Set currPtr to newNodePtr
Set currPtr->link to NULL
Here is a program that implements this algorithm and outputs the values in the order in
which they were read. The part of the code that creates the linked list is highlighted. We cover
how to output the list later in the chapter.

Description
Description

Here is a sample run:
Description
Let’s do a code walk-through and see how this algorithm works.
Description
Description
Here is the linked list that results when the program is run with the data 32, 78, 99, and 21
as input. The final values are shown for the auxiliary variables.

Description
QUICK CHECK
14.3.1 What is a dynamic linked list?
14.3.2 What is a dynamic data structure?
14.3.3 What do we use to get access to the first node in a dynamic linked list?
14.3.4 Consider the task of adding a new node to a linked list of integers that already
contains a single node. Describe the process of adding this new node to the existing
linked list.

14.4 Dynamic Implementation of ADT List
Now that we have looked at two examples of creating a dynamic linked list, let’s examine the
algorithms that process nodes in a linked list. We need to be able to insert a node, delete a
node, search for a node, and traverse the list. For each of these operations, we make use of
the fact that NULL is in the link member of the last node. NULL, when assigned to a pointer
variable, means that it points to nothing. We can compare the link member of each node to
NULL, to determine when we have reached the end of the list.
As we develop these algorithms, we do so in the context of the ADT List. Here are the
prototypes for the class List, which form the specification for the data type:
Description
Description

Notice that the preconditions and postconditions mention nothing about linked lists. The
abstraction is a list, not a linked list. The user of the class is interested only in manipulating
lists of items and does not care how we implement the list. If we decide to use a different
implementation, the public interface remains the same.
The private data in the array-based implementation of Chapter 13 consisted of a data array,
a length field, and a currentPos field that held the current position for a traversal of the list.
What is the equivalent in a linked implementation? The array and current position are replaced
with pointers.
Description
Are there other changes to the specification file for our new implementation? Yes, we must
include a forward declaration for NodeType so that the private variable dataPtr can be
specified. In the spirit of information hiding, we place the complete declaration of NodeType
into the implementation file List.cpp. Now let’s look at the linked implementation for the class,
beginning with the constructor and the action responsibilities.
Creating an Empty Linked List
To create an empty linked list, we just assign NULL to the external pointer. For the List class,
the appropriate place to do this is in the constructor. currentPos and length must also be set.
length should be 0—but what about currentPos? This data field should be initialized to point to
the first item in the list: dataPtr.
Description
As we discussed in Chapter 13, the implementation documentation (the preconditions and
postconditions in the implementation file) is often stated differently from the abstract
documentation (in the specification file). Specification documentation is written for the user of

the ADT; implementation details should not be mentioned. In contrast, implementation
documentation can refer directly to variables and algorithms in the implementation code. In the
case of the List class constructor, the abstract postcondition simply states that an empty list
(not a linked list) has been created. By comparison, the implementation postcondition
is stated in terms of how this is done.
Inserting into a Linked List
A function for inserting a component into a linked list takes the item to be inserted as an
argument. The phrase inserting into a linked list could mean inserting the component as the
first node, inserting the component as the last node, or inserting the component into its proper
place according to some ordering (as in a sorted list). The list specification doesn’t mention
order, so either of the first two meanings is acceptable. In the case of the array-based list, we
inserted at the end because inserting at the beginning of the list is less efficient. In a linked
implementation, the logical place to insert an item is at the beginning of the list, because this
place is directly accessible via the external pointer. If we want to insert an item at the end of a
linked list, either we have to keep an additional pointer to the last node or we must traverse the
whole list for each insertion.
Because we are building an alternative implementation of an existing class, we want a
traversal of the two implementations to be identical. Thus we will insert the new item at the
end of the list.
As we noted, there are two ways of managing insertion at the end of a linked list. We
choose the approach of keeping a pointer to the last item in the list because it is faster than
traversing the list for each insertion. Thus we add the data field lastPtr to our class private
data. Our list now has the following general form:
Description
How do we initialize lastPtr? We initialize it to NULL: The list is empty, so there is no last
node. We insert the new node at the end and change lastPtr to point to that node. The
algorithm is very similar to the one we used to build a list of four numbers.

Description
Before we code this algorithm, we need to look at the end conditions. Does this algorithm
work if the list is empty? No, it doesn’t. Trying to access lastPtr->link when lastPtr is NULL
will cause the program to crash. Inserting into an empty list is a special case. If lastPtr is
NULL, we need to set both dataPtr and lastPtr to the new node. Here is the revised algorithm:
Description
Have we forgotten anything else? Yes—length must be incremented when an item is
inserted. This algorithm is coded in the following function:

Description
Traversals of a Linked List
Many of the following list algorithms require traversing the list node by node. Before
considering the rest of the functions, let’s examine a traversal of the four-element list example
in Section 14.3.
Description
In this code segment, the traveling pointer currentPtr is initialized to head. Then it goes
through the nodes, outputting the component part of each. When count == 3, currPtr is NULL,
and each element has been examined.
This internal traversal is different from the external traversal where a client would use
ResetList, HasNext, and GetNextItem. The preceding code segment illustrates a traversal by a
member function that needs to run through part or all of the list. However, because our linked
list will vary in size, we’ll need to use a While loop instead of a For loop.
Deleting from a Linked List
To delete a node from a linked list, we traverse the nodes until we find the one we want to
delete. The postcondition says only that the item is not in the list; there is no precondition.
Thus the item may or may not be in the list. However, we do know (by the precondition on
Insert) that the list contains at most one copy of the item. Thus our search has two ending

conditions: The item is found or the end of the list is encountered. Here is the loop for the
algorithm:
Description
If item is in the list, at this point currPtr->component equals item. To delete the node, we set
the link component of the node before it to its link field.
Description
But we don’t have access to the link field of the node before currPtr! Therefore, we must
keep track of two nodes in this loop: currPtr and the node before it. Let’s call it prevPtr. We
initialize prevPtr to NULL. Here is the revised algorithm:

Description
Are there any end conditions that we missed? If the node to be deleted is the first node, we
must update dataPtr. If the node to be deleted is the last node, we must update lastPtr. If the
node to be deleted is the only node in the list, both dataPtr and lastPtr must be updated.
These tests must be done before the deletion is made.
Description
Description

As a walk-through example to check our algorithm, let’s delete the node whose component
is 20. The structure is shown below, with the nodes labeled as they are when the While
statement is reached.
Description
Description
If the value to be deleted is in the first node, the node is unlinked by setting dataPtr to the
link field of the first node. If the value to be deleted is in the last node, lastPtr is moved to what
is about to be the new last node (prevPtr).
Resetting the List
This function initializes currentPos for a traversal. The constructor sets it originally; this
function must reset it to point to the head of the list: dataPtr.

Getting the Next Item
This algorithm is identical to the one in the array-based list implementation. We return the
contents of the node pointed to by currentPtr and then set currentPtr to point to the next node.
We don’t have to worry about dereferencing the NULL pointer, because the precondition for
the function states that there is another item to be returned.
Description
Having addressed the action responsibilities, only the knowledge responsibilities are left to
examine. Three of these are so straightforward that we show the code with no explanation:
Description
Testing for the Full Linked List
Theoretically, a linked list cannot be full. However, there is a possibility that the list might be so
long that the heap runs out of memory to supply to the new operator. We show how to handle
this situation in Chapter 16 when we cover exceptions. Until then, we just let function IsFull
return false.

Description
Searching the List
We actually saw this algorithm when we searched the list for an item to delete. In fact, we can
use the first part of the code directly. Because we are not deleting a component, we do not
need the pointer to the previous node.
Description
Now we can collect these functions in an implementation file and write a driver to test them.
Because this is an alternative implementation of a class, we can use the same driver we used
to test the array-based list implementation.
Here is the specification file:
Description

Description
Here is the implementation file:


Description

Description
Description
The same driver was used with this implementation, and here is the output. If you look back
to the previous chapter, you will see the output is identical.
Description
QUICK CHECK

14.4.1 What are the general steps necessary to insert a new node into a linked list
following a specific node?
14.4.2 What are the general steps necessary to delete a node from a linked list
following a specific node?
14.4.3 Write C++ code to traverse from beginning to end a linked list whose first
element is pointed to by the variable head outputting out the value of each node.
Assume that each node consists of a variable called value for the value and link for
the link to the next node.
14.4.4 What does the IsFull method of a linked list return and why?

14.5 Destructors and Copy-Constructors
Classes whose objects manipulate dynamic data on the free store should provide three
special operations: a constructor, a destructor, and a copy-constructor. You are familiar with
constructors; now we look at the other two operations.
Destructor
The purpose of the destructor is to deallocate the nodes in a dynamic linked list when a List
class object is destroyed. Without a destructor, the linked list would be left behind, still
allocated but inaccessible. The code for the destructor is easy to write. We just traverse the
list, deleting each node. Note that the destructor is defined exactly like a constructor except
that it has a tilde (~) before the class name.
Description
Shallow Versus Deep Copying
When we introduced arrays, we said that you could assign one array to another, but you
wouldn’t get what you expect. That’s because you would just be copying the address of one
array into another, not the contents of the array. The same is true of a linked list. After the
following operations
Description

listOne just points to the first node of listTwo. With the built-in assignment operator (=),
assignment of one class object to another copies only the class members; it does not copy
any data pointed to by the class members. See FIGURE 14.6.
The result is called a shallow copy operation: The pointer is copied, but the pointed-to data
are not. Shallow copying is fine if none of the class members are pointers. In the preceding
example, length, currentPos, and lastPtr are copied as you would expect. But if one or more
members are pointers to dynamic data, then shallow copying won’t include them. Only the
external pointer to the list (dataPtr) is copied into listOne, not the list to which it points. In
addition, the dynamic data originally pointed to by the listOne object have been left
inaccessible. See FIGURE 14.6.
Shallow copy An operation that copies one class object to another without copying any
pointed-to data.

Description

FIGURE 14.6 Shallow Copy (Initial State)
What we want is a deep copy operation—one that duplicates both the class members and
the pointed-to data.
Deep copy An operation that not only copies one class object to another, but also makes
copies of any pointed-to data.
Copy-Constructor
The issue of deep versus shallow copying also can crop up in another context: initialization of
one class object by another. C++ defines initialization to mean the following:
1. Initialization in a variable declaration:
Description
2. Passing a copy of an argument to a parameter (that is, passing by value)
3. Returning an object as the value of a function:
By default, C++ performs such initializations using shallow copy semantics; in other words,
the newly created class object is initialized via a member-by-member copy of the old object
without duplicating data to which the class members point. Both name1 and name2 end up
pointing to the same three strings; they do not each point to separate copies of the strings.
To handle this situation, C++ supports a special kind of constructor known as a copy-
constructor. In a class declaration, its prototype has the following form:
Description

Notice that the function prototype does not use any special words to say it is a copy-
constructor. You simply have to recognize the pattern of symbols: the class name followed by
a parameter list, which contains a single const reference parameter of its own type:
The copy-constructor is more challenging to write than the destructor. Before we look at this
task, we must stress the importance of providing a copy-constructor whenever we also
provide a destructor. Pretend that List doesn’t have a copy-constructor, and suppose that a
client passes a class object to a function using pass by value. (Remember that passing by
value sends a copy of the value of the argument to the function.) Within the function, the
parameter gets a copy of the caller’s class object, including the private external pointer to the
list. At this point, both the argument and the parameter are pointing to the same list. When the
client function returns, the class destructor is invoked for the parameter, destroying the only
copy of the linked list. Upon return from the function, the caller’s linked list has disappeared!
By providing a copy-constructor, we ensure deep copying of an argument to a parameter
whenever a pass by value occurs. The implementation of the copy-constructor, shown next,
employs a commonly used algorithm for creating a new linked list as a copy of another: We
set up the external pointer to the new list and copy the first node. We then use a While loop to
traverse the original list, copying each node and linking the copy into the new list.

Description
If a copy-constructor is present, the default method of initialization (member-by-member
copying) is circumvented. Instead, the copy-constructor is invoked whenever one object is
initialized by another.
In summary, the default operations of assignment and initialization may be dangerous when
objects point to dynamic data on the free store.1 Member-by-member assignment and
initialization cause only pointers to be copied, not the pointed-to data. If a class allocates and
deallocates dynamic data, it almost certainly needs the following suite of member functions to
ensure deep copying of dynamic data:

Description
QUICK CHECK
14.5.1 If you want to copy all of the pointed-to data in a struct or class, should you use
deep or shallow copying?
14.5.2 Two of the ways that C++ defines initialization are initialization in a variable
declaration and passing an argument by value. What is the third way that C++ defines
initialization?
14.5.3 Every class that manipulates dynamic data should have a constructor, a
destructor, and which other member function?
14.5.4 What is a copy-constructor?

14.6 Sorted Linked List
As we saw in the array-based list implementation, the only operations that differ between an
unsorted list and a sorted list are the insert and delete operations. The same is true in the
linked implementation.
To insert a component into its proper place in a sorted list, we traverse the nodes until we
find where the component belongs. Because the SortedList class keeps components in
ascending order, we can recognize where a component belongs by finding the node that
contains a value greater than the one being inserted. Our new node should be inserted directly
before the node with that value; therefore, we must keep track of the node before the current
one. We use a pointer prevPtr to point to this previous node as we did in the delete operation.
What are the special cases? When the list is empty, when the value to be inserted is less
than the first, and when the value to be inserted is greater than the last. Let’s check for the
empty list before we enter the loop. When the loop exits, there are two cases: If the current
pointer is NULL, the node is inserted at the end; otherwise, the node is inserted between the
trailing pointer and the current pointer. This method leads to the following algorithm:

Description
The following function implements our algorithm with these changes incorporated:
Description

Description
Lets go through this code for each of the three cases: inserting at the beginning (item is 20),
inserting in the middle (item is 60), and inserting at the end (item is 100). Each insertion begins
with the following list:
Description
The next diagram shows the status after initialization. The only thing that changes is the
value in the component field of newNodePtr.
Description
Insert(20)

Description
Description
Insert(60) (pick up with loop)
Description

Description
Description
Description

Description
Description
Description
Description

Insert(100)
We do not repeat the first part of the search, but pick up the walk-through where prevPtr is
pointing to the node whose component is 50, and currPtr is pointing to the node whose
component is 90.
Description
Description
Description

Description
Deleting from a Linked List
To delete an existing node from a linked list, we traverse until we find the node to delete. In
fact, the function written for the unordered list would work just fine here. However, we can
determine that the item is not present when we pass a value that is greater than the one we
are deleting. Thus, the While expression needs an additional test (which we show as shaded).
Description
Now there are two conditions that indicate that the item is not there: currPtr is NULL or
currPtr-=component < item. Here is the coded function with the changes shaded:

Description
Let’s see what happens when we delete the node whose component is 30. The structure is
shown below, with the nodes labeled with their state when the While statement is reached.
Because the While and If expressions are so long, we show only the part of the expression
responsible for the result.

Description
Delete(30)
Description
Delete(50)
The picture is the same except that item contains 50.

Description
We leave the walk-through of the other cases as an exercise. We could use this same
technique to improve the efficiency of IsThere. We leave its reimplementation as an exercise.
QUICK CHECK
14.6.1 What are the special cases for inserting a node into a sorted linked list?
Problem-Solving Case Study
CREATING A SORTED LIST OF ENTRY OBJECTS
PROBLEM: Create a sorted list of time/name pairs ordered by time.
DISCUSSION: We already have a Name class, a TimeOfDay class, and an Entry class
made up of Name and TimeOfDay objects. (See Chapter 12.) We have two List classes, one
unordered and one sorted. Because the list is to be returned in order by time, we must use
the sorted list. It looks like the solution to this problem involves simply putting building
blocks together, where the building blocks are classes. We can use each of these classes
directly, except for the List class.
The List class is a list of ItemType objects in which ItemType is set by a Typedef
statement. In the case study in Chapter 13, we used the List class to hold a list of
integers. Here we have a list of Entry objects, which should be ordered by time. That’s
okay; we have a SortedList class we can use. Uh-oh, on second thought, it really isn’t
okay: The SortedList operations compare items using the relational operators, but our
TimeOfDay class only supports a ComparedTo function that returns values of RelationType. If
we are going to have a sorted list of objects of class Entry, we must add to the class a

ComparedTo function that compares TimeOfDay objects. Then we need to change the
SortedList implementation to use the ComparedTo operation instead of the relational
operators.
As it stands now, there is only one parameterized constructor for class Entry, which
takes parameters representing the separate parts of a name and time, so that it can build
Name and TimeOfDay objects internally. Let’s include a second parameterized constructor
that takes already instantiated objects as parameters. Here are the coded functions:
Description
Description
SORTED LIST: Is our current SortedList class useless? No; we must rewrite the
functions that require comparisons: Insert, Delete, and IsThere. We replace the relational
operators with the ComparedTo function from the Entry class, thereby specializing the list.
But we can directly use the operations that do not require a comparison.
Is there some way that we could avoid this specialization and have a linked list that
works for many different types? Yes—several advanced features of C++ will allow us to
solve this problem by creating a general list. We look at one of them in Chapter 16.
Do we really need to change Delete? Our problem doesn’t indicate that we need to
delete an appointment, but we should anticipate such an operation in the future. Note that
“item” is of class Entry, and our comparisons are based on time, so ComparedTo in class
Entry just calls ComparedTo in class TimeOfDay. IsThere should also be changed because
the client needs to be sure the item isn’t in the list before inserting it.

Description
Description
We must remember to add to the specification file the Typedef statement that equates
itemtype with Entry.
DRIVER: The calls to the SortedList functions to implement the tasks currently go into the
driver. When we incorporate what we have done here into the bigger task, the driver will
become part of the class that manipulates a day’s events. We need to create Entry objects
and insert them into the sorted list. We must precede each insertion with a test to be sure
the item is not already present in the list. We should try to insert one copy to be sure
IsThere works correctly. Here is the driver program:

Description
Description

Graphical User Interface (GUI)
The driver in the preceding section is a simple program to test some of the operations in the
SortedList class. How might we create a graphical interface to do something similar? Like the
existing version, we want to create Entry objects, add them to a SortedList, delete them from
a SortedList, and display the Entry objects stored in the list. However, we need a GUI that
allows the user to enter information interactively, such as a name and a time to construct
Entry objects, and buttons to insert or delete those entries in a SortedList when they are
pressed. In addition, we want the GUI to display the updated list so we can see the results of
these operations.
A console-based application starts execution with the first statement in main and continues,
statement by statement, until it returns. A GUI application operates fundamentally differently. It
begins execution in main, creates a new GUI-based object, renders it to the screen, and then
waits for an event (a user action) to occur. Several types of events can happen when a user
interacts with a GUI; for example, pressing a button, typing on the keyboard, touching the
screen, swiping left or right, dragging a window, and many others that make interacting with a
computer program useful and convenient. Some events won’t be useful or even possible in
some cases; for example, we can’t detect a touch on a computer that doesn’t support a
touchscreen.
The mechanism used by a GUI program to wait for an event to occur is called an event
loop. The program first sets up a connection between each interesting event and a
corresponding event handler. The event handler is usually written as a function or class
method.
For example, a button object may have a “button pressed” event. The programmer writes a
method (event handler) to perform whatever action should take place when the button is
pressed. Then the memory address of the event handler method is passed to the button
object through a call to one of its methods. Once it has the event handler method’s address,
each time the button is pressed, it just calls the method.
After setting up handlers for the different kinds of events, the GUI code enters a loop that
waits for events. When an event occurs, the event handler connected to that event is invoked
to perform an action; for example, when the user presses the button, the button calls the event
handler method that was given to it.
The actions of an event handler often modify the state of the program (such as causing a
value in a text field to be placed into a variable), which may then lead to updating the GUI
display and possibly causing other events to happen. The event loop continues until the
graphical application is terminated by an action that “closes” the program.
What kinds of events will occur in a GUI program for testing a sorted list of Entry objects
and its operations? To answer this question, we need to have an idea of what the graphical
interface will look like and the widgets it will include. As mentioned previously, we need a way
to enter a person’s name and the time of day, and buttons to insert and delete entries in a
sorted list ADT. We also want the capability to display the list of entries when a change occurs
to the list. A GUI for such an application might look like this:

Description
Everything displayed in a GUI is a kind of graphical widget. The one above contains text
boxes for entering the first, middle, and last name of a person and a component for selecting
the time of day, each labeled appropriately. We also see two buttons labeled “Insert Entry” and
“Delete Entry” to convey to the user their purpose, and a larger text box labeled “Entries,”
indicating that the list of entries will be shown in the box.
The application’s “state” includes an instance of SortedList and the Entry objects it
contains. The events are clicking on the Insert Entry or Delete Entry buttons. The
corresponding event handlers perform the insertion or deletion of entries, respectively. In
addition, the Entries text box must be updated to display any changes to the list of entries. The
following figures demonstrate what the GUI looks like when a user enters a person’s name
and time of day, followed by clicking the Insert Entry button:

Description

Description
To connect the state of the program with the events generated by the GUI, we will create a
class called EventHandlers with methods to handle those events. This class also contains a
reference to the SortedList that is created in main. The EventHandlers class implements the
methods for manipulating the sorted list of entries when the corresponding buttons are
pressed and provides the GUI with the updated list of entries to be displayed. Before we see
how to connect the GUI’s widgets to the event handler methods in this class, let’s look at its
definition.
We need two event handlers to handle inserting and deleting an entry. Each will have input
parameters coming from the GUI: first name, middle name, last name, and time of day. We
also need a method the GUI code can call to update the Entries text box when an entry is
inserted or deleted. Here is the specification of this class:

Description
Description
The constructor for the EventHandlers class has a single parameter, which is a reference to
a SortedList. The insertButtonPushed() method does not need to return anything, so it is
specified as having a void return value. The deleteButtonPushed() method returns a Boolean to
indicate if an entry was found to delete. This will be used by the GUI to display an informative
message to the user to indicate whether the deletion was successful. The fill-TextBox()
method returns a string representation of the entry list. The sorted list of entries is private
because it need not be used outside of this class. Following is the implementation of the
constructor and methods:

Description
Description
We include the EventHandlers.h header file to have the definitions available for each of the
methods we need to implement. The fillTextBox() method uses an ostringstream to create
the string representation of the entry list, so we include sstream because it contains the
definition of the ostringstream class.

The EventHandlers constructor introduces a new piece of syntax that we have not seen
before, called an initializer list:
Description
The initializer list appears between the parameter list and the curly braces and consists of a
colon followed by a comma-separated list of expressions. In this case, the list has just one
expression, which uses a function-like notation to initialize the private entries member with
the address passed through entriesInit:
An initializer list is used to initialize constructs that must be initialized before the code within
the braces executes. A class member that is a reference type is one such construct because
C++ doesn’t allow it to be reinitialized once the constructor code begins executing, and it was
not initialized as part of its declaration. The initializer list thus provides a window in time for
initialization to happen just prior to execution of the constructor, but after the parameter values
have been received. Here, it allows us to initialize the member with a pointer to the SortedList
that is being passed from main to the GUI.
Although we have, up to this point, referred to the code between the curly braces as the of
the constructor, it should be noted that C++ officially defines the body as including the
initializer list. The remainder of the methods are straightforward.
The insertButtonPushed() method constructs an Entry object and inserts it into the entries
list. The deleteButtonPushed() method constructs a new Entry object, and then it checks
whether the entry exists. If it doesn’t exist, it returns false to indicate that there is no entry to
delete with the same hours, minutes, and seconds; otherwise, it deletes the entry and returns
true. Lastly, the fillTextBox() method iterates over the list of entries writing to an ostring-
stream object. After calling the ostringstream str() method to retrieve the string that was just
created, fillTextBox returns it.
The GUI itself is implemented by the EntriesWindow class. We defer explaining the
implementation details of a custom-designed GUI until Chapter 15. In this chapter, we are just
examining the concept of event handlers and how they are supplied to a custom GUI.
When the EntriesWindow object is created, we pass it an EventHandlers object. The
EventHandlers object is then used by the GUI to connect the events that are generated by the
GUI to the event handler methods provided by our EventHandlers class.
As we have seen in previous chapters, to use the GUI framework we must first create a
QAp- plication object, passing it the arguments from the main() function.
Next, we create a new SortedList, which we pass into the constructor of the EventHandlers
class. We then pass the resulting EventHandlers object into the constructor of the
EntriesWindow class.

Description
With this example, you can really see the power of object-oriented programming. We create
one object that we then use to create another object, that is then used to create a third object.
The SortedList is now wrapped in a collection of event handlers, which are further wrapped in
our custom GUI, enabling the user to easily manipulate and examine the contents of the list
using a familiar form of interface.
Finally, we invoke the show() method on the GUI widget to render the graphical interface and
call the exec() method to start the event loop we discussed earlier. The exec() method returns
an int status code, which we can use as the return value for the main() function. Thus, we
place the call to exec directly in the return statement, rather than assigning its return value to a
variable and then putting the variable in the return. The complete code for main is shown here:
Description
Description
In addition to the insertion and deletion support provided by the GUI, properly designing it
also ensures that we do not construct entries that have missing data. We have already seen
how use of the time widget forces us to have a valid time by its design. But we also do not
want to create an entry without a first or last name. Unlike the time widget, the text boxes for
first, middle, and last name do not have a default value, so we must enforce this as part of the
design of our custom GUI.
When either button is clicked, the text boxes are checked by the custom GUI to ensure that
something has been entered in each of them before the corresponding method in the
EventHandlers class is invoked. Custom validation checks on GUI widgets will be covered in

the next chapter. Here is an example of an informational message the GUI displays if any of
the text boxes are empty:
Description

Testing and Debugging
One common error—leaving inaccessible objects on the free store—usually results from
either a shallow copy operation or incorrect use of the new operator. In FIGURE 14.6, we
showed how the built-in assignment operator causes a shallow copy; the dynamic data object
originally pointed to by one pointer variable remains allocated but is inaccessible. Misuse of
the new operator also can leave dynamic data inaccessible. For example, execution of the
code fragment
Description
creates an inaccessible object: the dynamic variable containing 38.5. The problem is that we
assigned a new value to floatPtr in the last statement without first deallocating the variable it
pointed to. To guard against this kind of error, examine every use of the new operator in your
code. If the associated variable currently points to data, delete the pointed-to data before
executing the new operation.
Finally, dangling pointers are a source of errors and can be difficult to detect. One cause of
dangling pointers is the deallocation of a dynamic data object that is pointed to by more than
one pointer. Figures 14.2D and 14.2E picture this situation. A second cause of dangling
pointers is returning a pointer to an automatic variable from a function. The following function,
which returns a function value of type int*, is erroneous:
Description
Remember that automatic variables are implicitly created at block entry and implicitly
destroyed at block exit. The preceding function returns a pointer to the local variable n, but n
disappears as soon as control exits the function. The caller of the function, therefore, receives
a dangling pointer. Dangling pointers are hazardous for the same reason that uninitialized
pointers are hazardous: When your program dereferences incorrect pointer values, it will
access memory locations whose contents are unknown.

Testing and debugging a linked structure are complicated by the fact that each item in the
structure contains not only a data portion, but also a link to the next item. Algorithms must
correctly account for both the data and the link.
Testing and Debugging Hints
1. A function must not return a pointer to automatic local data; otherwise, a dangling pointer
will result.
2. If ptrA and ptrB point to the same dynamic data object, the statement
makes ptrB become a dangling pointer. You should now assign the value NULL to ptrB
rather than leave it dangling.
3. Deallocate dynamic data when they are no longer needed. Memory leaks can cause you
to run out of memory space.
4. Inaccessible objects—another cause of memory leaks—are caused by
a. Shallow copying of pointers that point to dynamic data. When designing C++ classes
whose data members point to dynamic data, be sure to provide a deep copy operation
and a copy-constructor.
b. Using the new operation when the associated variable already points to dynamic data.
Before executing new, use delete to deallocate the data that are currently pointed to.
5. Make sure that the link member in the last node of a dynamic linked list has been set to
NULL.
6. When visiting the components in a dynamic linked list, test for the end of the list in such a
way that you don’t try to dereference the NULL pointer. On many systems, dereferencing
the NULL pointer will cause a run-time error.
7. Be sure to initialize the external pointer to each dynamic data structure.
8. Do not use

to make currPtr point to the next node in a dynamic linked list. The list nodes are not
necessarily in consecutive memory locations on the heap.
9. Keep close track of pointers. Changing pointer values prematurely may cause problems
when you try to access the pointed-to variable.
10. If a C++ class that points to dynamic data has a class destructor but not a copy-
constructor, do not pass a class object to a function using pass by value. A shallow copy
will occur, and both the parameter and the argument will point to the same dynamic data.
When the function returns, the parameter’s destructor is executed, destroying the
argument’s dynamic data.
11. The delete operator must be applied to a pointer whose value was previously returned by
new. Also, the delete operation leaves the value of the pointer variable undefined; do not
use the variable again until you have assigned a new value to it.
12. A function must not return a pointer to automatic local data; otherwise, a dangling pointer
will result.

Summary
A powerful use of pointers is to create dynamic variables. Although a pointer variable can be
declared at compile time, the data to which the pointer points are only created at run time. The
built-in operator new creates a variable on the free store (heap) and returns the address of that
variable for storage in a pointer variable. A dynamic variable is not given a name, but rather is
accessed through a pointer variable.
The use of dynamic data saves memory space because a variable is created only when it
is needed at run time. When a dynamic variable is no longer needed, it can be deallocated
(using delete) and the memory space can be reused. Use of dynamic data can also save
machine (computing) time when large structures are being sorted. With this approach, we
simply rearrange the pointers to the large structures, rather than the large structures
themselves.
When C++ class objects point to data on the free store, it is important to distinguish
between shallow copy and deep copy operations. A shallow copy of one class object to
another copies only the pointers and results in two class objects pointing to the same dynamic
variable. A deep copy results in two distinct copies of the pointed-to data. Classes that
manipulate dynamic data usually require a complete collection of support routines: one or
more constructors, a destructor (for cleaning up the free store), a deep copy operation, and a
copy-constructor (for deep copying during initialization of one class object by another).
Dynamic data structures grow and contract during run time. They are made up of nodes
that contain two kinds of members: (1) the component and (2) one or more pointers to nodes
of the same type. The pointer to the first node is saved in a variable called the external pointer
to the structure.
A linked list is a data structure in which the components are logically next to each other,
rather than physically next to each other as they are in an array. A linked list can be
represented as a collection of dynamic nodes linked together by pointers. The end of a
dynamic linked list is indicated by the special pointer constant NULL. Common operations on
linked lists include inserting a node, deleting a node, and traversing the list (visiting each node
from first to last).
In this chapter, we used linked lists to implement lists. Linked lists are also used to
implement many data structures other than lists. The study of data structures forms a major
topic in computer science. Indeed, entire books have been written and courses developed to
cover the subject. A solid understanding of the fundamentals of linked lists is a prerequisite to
creating more complex structures.

Quick Check Answers
14.1.1 new 14.1.2 delete 14.1.3 Variables created during execution of a program by
means of special operators. In C++, these operators are new and delete. 14.1.4 It creates
an uninitialized variable (or array) and returns the address of this variable. 14.1.5 Free
store or heap. 14.1.6 It returns allocated memory to the free store. 14.2.1 Because
pointers allow us to dynamically create the list to be only as long as necessary. 14.2.2 A
pointer to the next node in the list. 14.2.3 A linked list is a collection of items that can be
scattered about in memory whereas an array is a sequential collection of items that reside
in consecutive memory locations. 14.2.4 Insert and delete. 14.2.5 A pointer that points to
the first node in a linked list. 14.3.1 A linked list composed of dynamically allocated nodes
that are linked together by pointers. 14.3.2 A data structure that can expand and contract
during execution. 14.3.3 The external head pointer. 14.3.4 Set the pointer of the existing
node in the linked list to point to the new node. 14.4.1 Allocate a new node. Assign the
value from the node pointer of the current node to the node pointer of the new node. Assign
the node pointer of the current node to equal the address of the new node. Assign any data
members to the new node as appropriate. 14.4.2 Assign the value of the node pointer of
the current node to a temporary pointer. Assign the value of the node pointer from the node
pointed to by the node pointer field of the current node to the node pointer field of the
current node. (Assign the address of the node following the one to be deleted to the node
pointer of the current node.) Delete the data associated with the temporary pointer.
Description
14.4.4 It always returns false because a linked list cannot be full. 14.5.1 Deep copying.
14.5.2 Returning an object as the value of a function. 14.5.3 A copy-constructor. 14.5.4 A
constructor that is specifically designed to construct a new object based on an old object
using deep copy semantics.
14.6.1 When the list is empty, when the value to be inserted is less than the first, and when
the value to be inserted is greater than the last.

Exam Preparation Exercises
14.1 Match the following terms with the definitions given below.
a. Pointer type
b. Indirect addressing
c. Direct addressing
d. Reference type
e. Shallow copy
f. Deep copy
i. Accessing a variable using its name
ii. Assigning the value of one object to another object, including the duplication of
any pointed-to data
iii. Accessing a variable using an address stored in a pointer
iv. A simple type that can only be initialized with the address of a variable
v. A simple type that can be assigned the address of a variable
vi. Assigning the value of one object to another without duplicating any pointed-to
data
14.2 Match the following terms with the definitions given below.
a. Heap
b. Memory leak
c. Inaccessible object
d. Dangling pointer
e. Destructor
f. Dynamic data
i. The loss of available space that occurs when dynamic data are not deallocated
properly
ii. The area of memory used for allocation and deallocation of dynamic data
iii. An object that has been allocated but has no pointer pointing to it
iv. Variables created with the new operation
v. A pointer that points to a deallocated object
vi. A member function invoked when an object goes out of scope
14.3 When an object goes out of scope, its pointer variables are automatically deleted,
but their pointed-to values are not automatically deleted. True or false?

14.4 Does delete return the pointer variable to the heap or the pointed-to data?
14.5 What happens to the pointer(s) and pointed-to data in an object if the object goes
out of scope without applying delete to the corresponding pointer(s)?
14.6 What is wrong with the following code segment?
Description
14.7 What is wrong with the following code segment?
Description
14.8 The copy-constructor for class faxLog should have one parameter. What should
the type of this parameter be?
14.9 Why is it a problem if you perform a shallow copy of one object to another object
and then delete the first object and all of its pointed-to dynamic data?
14.10 Which kind of member function does the following heading declare?
4.11 Applying delete to the NULL pointer produces an error message. True or false?
14.12 In the following expression, index is a pointer to an array and book is a member
of a struct of type libraryRecord:
Description

What is the type of the components that are contained in the array that index points
to?
14.13 Define the following terms:
a. Node
b. Component member
c. Link member
d. Current pointer
14.14 We only need an external pointer for a dynamic linked list. With an array-based
list, we can find the head automatically. True or false?
14.15 Using a forward declaration of the node pointer type allows us to avoid using an
anonymous type to declare the link field within the struct representing the node. True
or false?
14.16 Which value does each of the following expressions access? The variable
names have the same meanings as those we have used elsewhere in this chapter.
Description
14.17 a. Which special state of a list does the condition listPtr == NULL test for?
b. Which special condition does the expression currPtr == NULL test for?
14.18 What are the algorithmic steps for inserting a new node into a sorted linked list?
14.19 What are the algorithmic steps for deleting the successor of the current node,
assuming that the current node is not the last node in the list?
14.20 For each of the following operations, decide which is faster: a direct array
representation of a list or a linked representation of a list.
a. Inserting near the front of the list
b. Deleting the last element of the list
c. Accessing the nth element
d. Searching for an item in a sorted list
14.21 Why does the following code segment produce a compiler error? What is
missing from the declarations?

Description
14.22 For each of the following, decide whether a direct array implementation or a
dynamic linked list representation would be the best choice. Assume that memory
capacity is limited and that good speed of execution is desirable.
a. A list of book titles in a personal library, with not more than 500 books. Books are
deleted rarely and are added occasionally, and the most frequent operation on the
list is to search for a specific title.
b. A list of shipping orders to be processed. The orders are inserted as they come in,
and they are deleted as they are shipped out. The list can be quite large just before
the December holidays but may be nearly empty in January. The list is occasionally
searched for a specific item, to check its status.
c. An itinerary of customer visits for a salesperson. Visits may be added anywhere
within the itinerary, and they are deleted from the head after they have been
completed. The itinerary can be of any length.
14.23 What does the following code do?
Description
a. Increments the contents of atlas
b. Increments the contents of number
c. Increments the contents of both atlas and number
d. Adds 2 to number
e. Produces a dangling pointer
14.24 What does the following code do?

Description
a. Increments the contents of weathervane
b. Increments the contents of number
c. Increments the contents of both weathervane and number
d. Adds 2 to number
e. Produces a dangling pointer
14.25 What does the following code do?
Description
a. Increments the contents of finger
b. Increments the contents of number
c. Increments the contents of both finger and number
d. Adds 2 to number
e. Produces a dangling pointer

Programming Warm-Up Exercises
14.1 Extend the sorted linked list described in this chapter to include an additional
method called Split. The Split method takes a single parameter that is the type of
the element contained in the list and will search the list until it finds a matching
element. If it finds a matching element, it should return a new linked list of the
elements that start with the matching element until the end of the original linked list.
The original linked list should be modified such that the element before the matching
element becomes the last element in the list. If the element is not found, Split should
return NULL. You should reuse all the NodeType nodes in the original linked list in the
linked list that is returned.
14.2 Declare a pointer variable structPointer and initialize it to point to a struct
variable called newPhone, of type Phone, that has three int fields called country, area,
and number. Also write the declaration of the Phone type. Then write assignment
statements to indirectly store the values 1, 888, and 5551212, respectively, into these
fields.
14.3 Write a Boolean value-returning function called ShallowCompare that takes two
variables of type structPointer, as defined in Exercise 14.2, and returns true if they
point to the same struct and false otherwise.
14.4 Write a Boolean value-returning function called DeepCompare that takes two
variables of type structPointer, as defined in Exercise 14.2, and returns true if the
structs that they point to have identical values in their corresponding fields.
14.5 Write a For loop that scans through a dynamically allocated int array, pointed to
by a variable called dataPtr, keeping track of the greatest value in a static int variable
max. The array contains 100 values. At the end of the loop, the array should be
deleted.
14.6 Wrap the For loop written in Exercise 14.5 in an int-returning function called
Greatest that takes the array and its size as parameters and returns the value in max
after the array is deleted. Be sure to change the loop to work with the given array size
rather than the constant 100.
14.7 Write an int-returning function that prompts the user for the number of values to
be entered, creates an int array of that size, and reads that many values into it. The
function then passes this array to the Greatest function defined in Exercise 14.6 and

returns the result from that function as its own result. Call the new function
GetGreatestInput.
14.8 A class called Circuit has two private dynamic array data members called
source and sink. Write a destructor for the class that ensures that the dynamic data
are destroyed.
14.9 Write a code segment that checks whether the pointer oldValue actually points to
a valid memory location. If it does, then its contents are assigned to newValue. If not,
then newValue is assigned a new int variable from the heap.
14.10 Write a code segment that checks whether the pointers oldValue and newValue
point to different locations. If they do, then delete the value pointed to by oldValue;
otherwise, do nothing.
14.11 Given the dynamic linked implementation of a linked list shown below, write
expressions that do the following, assuming that currPtr is somewhere in the middle
of the list:
a. Access the component member of the first list element.
b. Advance currPtr to point to the next element.
c. Access the component member of the next element (the one that follows the
current element).
d. Access the component member of the element that follows the next element.
Description
14.12 Given the declarations in Exercise 14.11, write a code segment that creates a
new node, assigns the value 100 to the component member, links listPtr to the new
node, and sets currPtr to also point to the node.

14.13 Given the declarations in Exercise 14.11, and the fact that the first node has
been inserted into the list as in Exercise 14.12, write a code segment that creates a
new node with the component value equal to 212 and inserts this node at the end of
the list, updating any pointers as necessary.
14.14 Given the declarations in Exercise 14.11, assume that the list has a large
collection of members and that currPtr is somewhere in the middle of the list. Write a
code segment to insert a new node with the component value of 32 following the node
pointed to by currPtr, and update currPtr to point to the new node.
14.15 Given the declarations in Exercise 14.11, assume that the list has a large
collection of members and that currPtr is somewhere in the middle of the list. Write a
code segment to remove the node following the node pointed to by currPtr and
reinsert it at the head of the list.
14.16 Given the declarations in Exercise 14.11, write a void function that sorts the
elements of the list in ascending order. The sort algorithm will scan the list, keeping a
pointer to the lowest value seen thus far. When the end of the list is reached, the
lowest value will be removed from that point and inserted at the end of a new list. After
all of the elements have been moved from the original list to the new sorted list,
change listPtr and currPtr to point to the first element of the new list. That way,
when the function returns, the client code will simply see the list as having been
sorted.
14.17 Given the code for the sorted delete operation in section 14.6, and the linked list
shown here (for parts b and c), walk through the following deletion operations.
Description

a. Delete from an empty list.
b. Delete 20 from the list above.
c. Delete 90 from the list above.
14.18 Write the code for the sorted version of IsThere.

Programming Problems
14.1 Imagine you have been asked by a first grade teacher to create a hangman
game for her students to help them with spelling and word recognition. In the game of
hangman you are first presented with a list of blanks representing unknown letters of a
hidden word. You must then guess a letter to see if that letter exists in the word. If it
does, the blank that corresponds to the guessed letter is then displayed along with
blanks for the letters that have not been guessed yet. If you guess a previously
guessed letter, you get to try again. If you guess wrong, you incrementally move
toward being hung. You have eight bad guesses until you lose the game. To represent
the different states of “being hung” we will use the values PLATFORM, HEAD, BODY,
LEFT_ARM, RIGHT_ARM, LEFT_LEG, RIGHT_LEG, and HUNG. To implement the
game, you should use the Linked List ADT to represent the word being guessed.
Each element in the list should be an object of type Slot that stores the letter of the
word and a Boolean that indicates if the letter is to be displayed or if a blank should be
displayed. The Slot class should provide the appropriate observer and mutator
methods for accessing and manipulating a slot. You should use a second linked list to
represent the letters that have already been guessed and an enumeration to represent
the states of the game. Your program should keep asking the user for another guess
until either the entire word has been guessed or the state of the game is HUNG. After
each guess, the program should display the current state of the word to be guessed,
the list of characters already guessed, and the state of the game.
14.2 You are working for your state’s motor vehicle registry, and it has been
discovered that some people in the driver’s license database have multiple records.
The license records are stored in alphabetical order on a set of files, one file per letter
in the alphabet. The first file is licensesa. dat, and the last is licensesz.dat. For this
problem, we’ll just focus on getting the program to work for the licensesa.dat file.
Each record consists of a license number (an eight-digit integer), a name, and an
address, all on a single line. For the purposes of this problem, the name and address
can be stored in a single string because they are not processed separately. The
license number and the corresponding string should be kept together in a struct.
Use the functions of the SortedList class to create a list of numbers that contains
no duplicates. If a duplicate is found in the data file, write the contents of the original
entry (first one encountered) and the contents of any duplicates in the file on file
duplicates.dat.

14.3 You’re working for a company that wants to take client contact information as it is
entered by a salesperson from a stack of business cards that they have collected,
and output the information to a file (contacts.dat) in alphabetical order. The program
should prompt the salesperson for each of the following values for each card:
Last name
First name
Middle name or initial Title
Company name
Street address
City
State
ZIP code
Phone number
Fax number
Email address
After the data are entered for each card, the user should be asked if there is another
card to enter. Each card should be inserted into a sorted list whose key is the last
name. After all the data are entered, iterate through the list, writing each card onto file
contacts.dat. Use the SortedList modified in the Problem-Solving Case Study.
14.4 You are working for a company that has a collection of files, each of which
contains information from business cards. The files are created by another program
(see Problem 14.3 for a description of what this program outputs). The company
would like to merge the files into a single file, sorted alphabetically by last name. The
user should be prompted to enter the names of the files until a file name of “done” is
entered. Once all of the data have been input, the sorted data should be written back
out to a file called mergedcontacts.dat.
14.5 Create a new List ADT where duplicates are allowed. Define the delete operation
to delete all copies of an item. Implement both an unordered version of the list and a
sorted version.
14.6 Use the sorted list version defined and implemented in Problem 14.5 to solve
Problem 14.2.
14.7 Use the sorted list version defined and implemented in Problem 14.5 to solve
Problem 14.4.

Case Study Follow-Up
1. We did not discuss a copy-constructor or a destructor for the revised SortedList
class. Would these functions have to be changed to use ComparedTo? Explain.
2. The classes in this case study have been built up over several chapters. Does this
process demonstrate functional decomposition or object-oriented design? Explain.
3. Outline the next step in constructing an appointment calendar.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 5
Inheritance,
Polymorphism, and
Object-Oriented Design
KNOWLEDGE GOALS
To appreciate the distinction between structured (procedural) programming and
object-oriented programming.
To know the characteristics of an object-oriented language.
To understand the difference between static and dynamic binding of operations to
objects.
SKILL GOALS
To be able to:
Create a new C++ class from an existing class using inheritance.
Create a new C++ class hierarchy with a virtual function.
Apply the object-oriented design methodology to solve a problem.
Take an object-oriented design and code it in C++.
In Chapter 12, we introduced the concept of data abstraction—the separation of the logical
properties of a data type from the details of how it is implemented. We expanded on this
concept by defining the abstract data type (ADT) and using the C++ class mechanism to
incorporate both data and operations into a single data type. In that chapter and Chapter 13,
we saw how an object of a given class maintains its own private data and is manipulated via
its public member functions.
In this chapter, we examine how classes and objects can be used to guide the entire
software development process. Although the design usually precedes implementation in

software development, we reverse the order of presentation in this chapter. We begin with
object-oriented programming, describing its principles, terminology, and language features.
After presenting these concrete elements, we look more closely at object-oriented design.

15.1 Object-Oriented Programming
As you are now well aware, functional decomposition is a methodology in which we
decompose a problem into modules, each of which solves part of the overall problem. The
process of implementing a functional decomposition is often called structured (or
procedural) programming. Some modules are translated directly into C++ statements,
whereas others are coded as functions. The resulting program is a collection of interacting
functions (see FIGURE 15.1). With functional decomposition, data are considered a passive
entity to be acted upon.
Structured (procedural) programming The construction of programs that are collections
of interacting functions or procedures.
Functional decomposition is satisfactory for programming in the small (a concept we
discussed in Chapter 4) but often does not scale up for programming in the large. When we
are building large software systems, the approach has two important limitations. First, it yields
an inflexible structure. If the top-level algorithm requires modification, the changes may force
many lower-level algorithms to be modified as well. Second, the technique does not lead to
code that is easy to reuse in other sections of a program or in other programs. It is rare to be
able to take a complicated C++ function and reuse it easily in a different context.
A better methodology for creating large software systems is object-oriented design (OOD),
which we introduced briefly in Chapter 4. OOD decomposes a problem into objects—self-
contained entities composed of data and operations on the data. The process of implementing
an object-oriented design is called object-oriented programming (OOP). The end result is a
program that is a collection of interacting objects (see FIGURE 15.2). In OOD and OOP, data
play a leading role; the primary contribution of algorithms is to implement the operations on
objects. In this chapter, we’ll see why OOD tends to produce code that is easier to reuse.
Object-oriented programming (OOP) The use of data abstraction, inheritance, and
dynamic binding to construct programs that are collections of interacting objects.

FIGURE 15.1 Program Resulting from Functional Decomposition
Many programming languages have been created that support OOD and OOP: C++, Java,
C#, Swift, Python, and others. These object-oriented programming languages have facilities
that support:
Data abstraction
Inheritance
Dynamic binding
You have already seen that C++ supports data abstraction through the class mechanism.
Some non-OOP languages also have facilities for data abstraction, but only OOP languages
support inheritance and dynamic binding.
QUICK CHECK
15.1.1 How do programs based on functional decomposition differ from object-
oriented programs in terms of the components that interact with one another to solve
a problem?
15.1.2 What are the three main facilities that are provided by an object-oriented
language that support object-oriented programming?
15.1.3 What is procedural programming?
15.1.4 What plays a leading role in object-oriented programming?
15.1.5 What is the primary contribution of algorithms in object-oriented programming?

FIGURE 15.2 Program Resulting from Object-Oriented Programming

15.2 Inheritance
In the world at large, it is often possible to arrange concepts into an inheritance hierarchy—
that is, a hierarchy in which each concept inherits the properties of the concept immediately
above it in the hierarchy. For example, we might classify different kinds of vehicles according
to the inheritance hierarchy shown in FIGURE 15.3. Moving down the hierarchy, each kind of
vehicle is more specialized than its parent (and all of its ancestors) and is more general than
its child (and all of its descendants). A wheeled vehicle inherits properties common to all
vehicles (it holds one or more people and carries them from place to place) but has an
additional property that makes it more specialized (it has wheels). A car inherits properties
common to all wheeled vehicles but also has other, more specialized properties (four wheels,
an engine, a body, and so forth).
The inheritance relationship can be viewed as an is-a relationship. Every two-door car is a
car, every car is a wheeled vehicle, and every wheeled vehicle is a vehicle. This notion is
distinct from the principle of composition, where one object is contained within another object.
Composition is a has-a relationship: The enclosing object has a member that is another
object.
To better understand the principles underlying inheritance, let’s look at an analogy between
the work of an architect and the work of a programmer. The way an architect handles the
complexity of a large building design sheds some light on how we can organize our own
programming work. This analogy lets us consider the same concepts, but without the
distraction of C++ syntax.
FIGURE 15.3 Inheritance Hierarchy
Description
An Analogy

The architect begins by considering the overall requirements for a building: square footage,
number of occupants, usage, and so on. The architect faces a basic aspect of any design:
The building is composed of floors. In many buildings, the floors all have common
characteristics: the same size and shape; the same locations for elevator shafts, stairways,
and utility trunks; and so on. The architect begins by designing a basic empty floor with these
common elements. Once she installs this plan in the library of her computer-aided design
(CAD) program, she can use it as the starting point for designing each floor of the building.
The architect may further decide that the building has two main types of floors: office floors
and mechanical equipment floors. The office floors might be of two types: executive and
standard office spaces. Starting from the basic empty floor design, the architect adds
components such as lavatories and hallways to make an empty office floor. She can then add
offices and conference rooms to the empty space. In this way, each of the four types of floor
is derived from the basic empty floor and added to the library (see FIGURE 15.4). Drawing the
entire building then becomes a matter of creating an instance of one of these four floor plans
for each story.
The architect uses the same process to design the components that make up the floors.
She might design a basic type of office, and then derive several types of offices from that one
design. From a given type of office, such as secretarial, she might further refine the design
into subtypes such as general secretarial, secretary/receptionist, and executive secretary.
Creating hierarchies of designs simplifies the architect’s job. She begins each hierarchy
with the most general form of a building component, such as the basic empty floor, and then
derives new designs by adding details to the more general forms. The new designs inherit all
of the characteristics of the general form, saving the architect from having to redraw the
common pieces. In some cases she replaces existing parts of a design, such as when she
substitutes a wider door for a reception area than appears in the basic secretarial office. The
replacement part overrides what was originally specified in the more general form.
In addition to the components of individual floors, the architect can specify characteristics
that are common to all floors, such as a color scheme. Each floor will then inherit these
general properties. Sometimes she hides or deletes portions of the general properties, such
as when she customizes the color scheme for a particular floor that has been rented in
advance by a company with its own corporate colors.

FIGURE 15.4 A Hierarchy of Floor Types
Description
Inheritance and the Object-Oriented Design Process

Now let’s consider how a class hierarchy originates in the object-oriented design process.
During the problem-solving phase, we discover that we need a class that is a variation of an
existing one. For example, in the case study of Chapter 14, we discovered that the Entry
class from Chapter 12 was appropriate, but noted that it lacked a ComparedTo member
function. We also decided that the class should have a second parameterized constructor that
took a Name object and a TimeOfDay object as parameters.
We solved this problem by copying the code for Entry and then using that copy to create a
new class with the extra responsibilities. The result was two classes named Entry that are
unrelated. Later, if we find a bug in the original Entry class, we must remember to check the
extended class for the same bug. But wouldn’t it be nice if a fix or an improvement to the
original could be automatically propagated to any derived classes?
We can achieve this goal by making Entry a base class or superclass, and defining the
other class as a derived class or subclass of Entry. For example, if we add an email field
and responsibilities to Entry, the property of inheritance causes it to be added to all of the
derived classes automatically.
Base class (superclass) A class that is extended by one or more derived classes (its
subclasses).
Derived class (subclass) A class that is derived from another class (its base class).
Inheritance A mechanism by which one class (a derived class) acquires the properties—
the data and operations—of another class (its base class).
In general, you can take an existing class A, the base class, and create from it a new class
B, the derived class. The derived class B inherits the properties of its base class A. In doing
so, the data and operations defined for A become predefined for B. (Notice the is-a
relationship—every B is also an A.) Then you specialize class B, adding properties to those
inherited from A. To see how this process works, let’s look at an example in C++.
Deriving One Class from Another Class
Let’s solve the Entry problem with inheritance; that is, let’s create class Expand-edEntry that
has the ComparedTo function and the additional parameterized constructor. Here is the
specification file for the new class:

Description
The statement
states that ExpandedEntry is derived from Entry. The reserved word public declares Entry to
be a public base class of ExpandedEntry. As a consequence, all public members of Entry
(except constructors) are also public members of ExpandedEntry. In other words, Entry’s
member functions GetNameStr and GetTimeStr can also be invoked for ExpandedEntry objects.1
However, the public part of ExpandedEntry specializes the base class by adding the ComparedTo
function and an additional constructor. This relationship is pictured in FIGURE 15.5.

FIGURE 15.5 Class Interface Diagram for ExpandedEntry Class
Description
Figure 15.5 shows that each ExpandedEntry object is an Entry object, and more. C++ uses
the terms “base class” and “derived class” instead of “superclass” and “subclass.” The terms
“superclass” and “subclass” can be confusing because sub usually implies something smaller
(for example, a subset of a mathematical set). In contrast, a subclass often has more data
and/or functions than its superclass.
Figure 15.5 includes arrows between the two ovals labeled GetNameStr and Get-TimeStr.
Because Entry is a base class of ExpandedEntry, and because GetNameStr and GetTimeStr are
not redefined by ExpandedEntry, the two functions available to clients of ExpandedEntry are the
same as the ones in Entry. We use the arrow between the corresponding ovals to indicate this
fact. (Notice in Figure 15.5 that Entry’s constructors are operations on Entry, not on
ExpandedEntry. The ExpandedEntry class must have its own constructors.)

Specification of the ExpandedEntry Class
Following is the fully documented specification of the ExpandedEntry class with the default
constructor added. Notice that the preprocessor directive
is necessary for the compiler to verify the consistency of the derived class with its base
class.
Description
Implementation of the ExpandedEntry Class
When the default constructor of a derived class has no code, the default constructor for the
base class is automatically called in its place. Because there are no new data fields in
ExpandedEntry to be initialized, it makes sense to let the default constructor for Entry do the
work for us; however, we will need a constructor initializer for the new parameterized
constructor. We must take the name and time parameters and break them apart, because the
constructor for the Entry class takes them as individual values.

Description
The ComparedTo function compares the time in the instance with the time in the parameter.
Now we have a problem: We don’t have access to the time field in the Entry class from the
ExpandedEntry class.
With C++, inheritance does not imply unrestricted access. Although a derived class inherits
the members of its base class, both private and public, it cannot directly access the private
members of the base class. Figure 15.5 shows that variables name and time are encapsulated
within Entry. Neither external client code nor ExpandedEntry member functions can refer to
these variables directly. If a derived class could access the private members of its base
class, any programmer could write code to directly access them and thus bypass the
encapsulation.
The solution to the problem is to add a getter function to the base class—in this case, Entry.
The derived class can then see the value in the field without having access to it. To make
Entry as widely usable as possible, we should add two getter functions: GetTime and GetName.
We use GetTime to access the time in the instance and the time in the parameter.
Description
This Return statement illustrates two important concepts. First, the function GetTime by itself
applies to the class instance. Second, to get the time in the parameter, GetTime must be
explicitly applied to it. Because we are adding getter functions to the class, we can remove the
functions that return the name and time as strings. Users would then have the tools to format
name and time themselves.
Following is the specification file for the revised Entry class.
Description

Description
Here is the revised implementation file:

Description
Description
This experience illustrates why an important aspect of object-oriented design is planning
ahead for reuse of classes. If we had thought about Entry in more general terms when we first
designed it, we would have included these getter functions. Inheritance makes it so easy to
reuse classes by extending them that we almost always want to generalize our designs to
maximize their potential for future reuse.
Now we can write the implementation file for ExtendedEntry. As you look at this file, notice
how little additional code is required to extend the base class with this new functionality. That’s
precisely the point behind the use of inheritance in object-oriented programming.

Description
We compile the file ExpandedEntry.cpp into an object code file—say, ExpandedEntry. obj.
Next we write a test driver and compile it into test.obj. The development environment then
creates an executable file by linking these two files with the existing Entry. obj file.
We’re finally ready to test the resulting program. Here is the code for the test driver used to
test the revised Entry class in Chapter 13, followed by its output.

Description

Description
Output:
Description
The remarkable thing about extending a base class with inheritance is that modification of
the base class is unnecessary, assuming it has the necessary getter operations. If these had
already been present in the Entry class, we could have implemented ExtendedEntry without
having access to the code for Entry. The C++ compiler is able to get all of the information it
needs from the specification file for the base class without having to recompile its
implementation file. The linker then joins the object code for the derived class with the existing
object code for the base class to produce the executable file.
Further variations of the Entry ADT can be created in ways the creator never considered. A
class such as Entry can be used without modification in many different contexts, or it can be
adapted to a particular context by using inheritance. Inheritance allows us to create extensible
data abstractions—a derived class typically extends the base class by including additional
private data or public operations or both.
Constructor Execution Order
Having discussed both inheritance and composition, we can give a complete description of
the order in which constructors are executed:
Given a class X, if X is derived from base class Y:
1. The base class (Y) constructor is executed first.
2. Constructors for X’s member objects (if any) are then executed.
3. The body of X’s constructor is executed last.
For example, when an ExtendedEntry object is created, the constructor for the Entry class is
called first. This action triggers calls to the constructors for its Name and TimeOfDay members.
After that, the body of Entry’s constructor is executed, which is empty. Then the body of
ExtendedEntry’s constructor is executed, which also happens to be empty.
SOFTWARE MAINTENANCE CASE STUDY Extending TimeOfDay
with Support for a Time Zone

MAINTENANCE TASK: You’ve been given the task to modify the TimeOfDay class so that
it includes the time zone within the continental United States. You are to represent the time
zone as private data, using a variable of an enumeration type indicating the time zone—EST
for Eastern Standard Time, CST for Central Standard Time, MST for Mountain Standard
Time, and PST for Pacific Standard Time.
EXISTING CODE: Before tackling this task, we should review the public interface to the
class we are preparing to extend. As you’ll see, inheritance often enables us to add
functionality to an existing class without looking any further than its interface.
TimeOfDay provides two constructors; separate getter functions for hours, minutes,
and seconds; an observer that returns a new TimeOfDay that has been incremented by one
second; and another observer that allows us to compare two TimeOfDay objects.
Description
DISCUSSION: The approach in a language without inheritance would be to obtain the
source code for TimeOfDay.cpp, analyze it, and then modify and recompile it. This process
has several drawbacks. If TimeOfDay is from a purchased software package, the source
code may not be available. Even if it is available, modifying it may introduce bugs into a
previously debugged solution. Access to the source code also violates the main benefit of
abstraction: Users of an abstraction should not need to know how it is implemented.
A better approach for adding this feature is to use inheritance. Let’s derive a new class
from TimeOfDay and then specialize it. The new, extended time class—call it ExtTime—
inherits the members of its base class, TimeOfDay. We’ll need to modify the class
constructors to accommodate a time zone value. The Increment function, which returns a
time incremented by one second, does not need to be changed, but the comparison
function does need to change because of the time zones.
Here is the specification of ExtTime:

Description
Notice how few functions and data members are included in this specification. Two new
constructors must be provided because the name of the new class is different from the
name of its base class. The private part of ExtTime declares a new private member: zone.
The private members of ExtTime are, therefore, hours, minutes, seconds (inherited from
TimeOfDay), and zone.
All of the getters from TimeOfDay have been inherited, but we must add a new getter
function for the zone member. ExtTime also inherits the Increment operation. Because a
comparison that accounts for the time zone has a different semantic meaning than the
original comparison, we provide a new ComparedTo function that overrides the version in the
base class. FIGURE 15.6 pictures the relationship between the ExtTime and TimeOfDay
classes.
Implementing the constructors for ExtTime is easy because the constructors for
TimeOfDay handle most of the work. All we have to do is initialize the zone member. The
getter for zone is also quite simple: It merely returns the value of the variable.
The only tricky thing about the implementation is ExtTime’s ComparedTo function. If the two
time zones are the same, then the times can be compared as before. If the time zones are
different, however, then the time of one must be adjusted to be comparable with the other.
Does it matter whether the instance or the parameter is adjusted? No, it doesn’t. Let’s
adjust a copy of the instance to the same time zone as the parameter and use TimeOfDay’s
ComparedTo function to compare the adjusted copy and the parameter.

FIGURE 15.6 Class Interface Diagram for ExtTime Class
Description
We can take advantage of the numerical values of the time zones to simply compute the
difference in hours between the two zones, and then add this value to the hours from the
instance. The modulo operator provides an efficient way to ensure that when the new
hours value is 24 or greater, it is readjusted to be within the proper range of 0 to 23.
ComparedTo (In: otherTime)
Function Value: RelationType
Set difference to otherTime.zone minus zone
Set newHours to (GetHours() + difference) modulo 24
Create copy, a normalized TimeOfDay object initialized using newHours
RETURN copy.ComparedTo(otherTime)

Translating this algorithm into C++, we get the following implementation file:
Description
TESTING: Here is a test driver and output:
Description


Description
Description
QUICK CHECK
15.2.1 Suppose you have a class called Phone and you want to extend it to support a
country code, calling the new class InternationalPhone. How would you write the
class heading for the new subclass?
15.2.2 Suppose that in Question 15.2.1, you wanted to create InternationalPhone as a
separate class that contains an instance of Phone, rather than making it a subclass of
Phone. Describe how you would accomplish this task.
15.2.3 What is the relationship as viewed by inheritance?
15.2.4 What is inheritance in terms of object-oriented programming?
15.2.5 What type of access of an instance variable is required by a derived class in
order for the derived class to have direct access to the instance variable?
15.2.6 What part of a derived class constructor is required to invoke a constructor of a
base class?
15.2.7 What is the execution order of constructors given a class X, if X is derived from
a base class Y?

1 If a class declaration omits the word public and begins as
class DerivedClass : BaseClass
or if it explicitly uses the word private,
class DerivedClass : private BaseClass
then BaseClass is called a private base class of DerivedClass. Public members of BaseClass
are not public members of DerivedClass; that is, clients of DerivedClass cannot invoke
BaseClass operations on DerivedClass objects. We do not work with private base classes in
this text.

15.3 Dynamic Binding and Virtual Functions
Early in the chapter, we said that object-oriented programming languages provide language
features that support three concepts: data abstraction, inheritance, and dynamic binding. Data
abstraction is accomplished with the class construct; we have just covered inheritance. We
now cover dynamic binding.
The term dynamic binding means, more specifically, “dynamic binding of an operation to an
object.” To explain this concept, let’s look at an example. Given the TimeOfDay and ExtTime
classes described in this chapter, the following code creates four class objects and compares
them using the ComparedTo function:
Description
This code fragment invokes two different ComparedTo functions, even though the functions
appear to have the same name. The first function call invokes the ComparedTo function of the
TimeOfDay class; the second call invokes the ComparedTo function of the ExtTime class. In this
code fragment, the compiler uses static (compile-time) binding of the operation (ComparedTo)
to the specific object. The compiler can easily determine which ComparedTo function to call by
checking the data type of the associated object.
Static binding The compile-time determination of which function to call for a particular
object.
In some situations, the compiler cannot determine the type of an object, so the binding of an
operation to an object must occur at run time. One such situation involves passing objects as
arguments.
The basic C++ rule for passing objects as arguments is that the argument and the
parameter must be of identical types. With inheritance, C++ relaxes this rule to a certain
extent. You may pass an object of a derived class as an argument to a parameter whose type
is the base class, but not the other way around—that is, you cannot pass an object of a base
class as an argument to a parameter of a derived type.
More generally, you can pass an object of a descendant class as an argument to a
parameter whose type is any of its ancestor classes. This rule is incredibly useful: It allows us
to write a single function that applies to any descendant class instead of having to write a
different function for each subclass.

For example, let’s assume that both TimeOfDay and ExtTime have a Write function. We could
write a fancy Print function that takes as an argument an object of type TimeOfDay or any
class descended from TimeOfDay:
Description
Description
Description
the compiler lets us pass either a TimeOfDay object or an ExtTime object to the Print function.
However, when endTime is output, the zone CST is missing from the output. Let’s see why.
The Slicing Problem
Print uses passing by value for the parameter time. When you pass an object of a derived
class to an object of its base class using pass by value, only the data members they have in
common are copied. Recall that a derived class is often “larger” than its base class—that is, it
contains additional members. A TimeOfDay object has three data members (hours, minutes,
and seconds), but an ExtTime object has four data members (hours, minutes, seconds, and
zone). When the larger class object is copied to the smaller parameter using pass by value,
the extra data members are discarded or “sliced off.” This situation is called the slicing
problem (see FIGURE 15.7).
The slicing problem also occurs with assignment operations. In the statement
only the data members that the two objects have in common are copied. Additional data
members contained in derivedClassObject are not copied.
With passing by reference, the slicing problem does not occur because the address of the
caller’s argument is sent to the function. To see how this approach works, let’s change the
heading of our Print function so that someEntry is a reference parameter:

Now when we pass endTime as the argument, its address is sent to the function. Its ExtTime
zone member is not sliced off because no copying takes place. But the Print function still
outputs only three of endTime’s data members—hours, minutes, and seconds. Let’s see why.
Within the Print function, static binding is used in the statement
The compiler must generate object code for Print at compile time, but the type of the actual
argument (TimeOfDay or ExtTime) isn’t known until run time. How can the compiler know which
Write function to use—TimeOfDay::Write or ExtTime::Write? The compiler cannot know, so it
uses TimeOfDay::Write because the parameter time is of type TimeOfDay. Therefore, the Print
function always outputs just three values—hours, minutes, and seconds—regardless of the type
of the argument.
Fortunately, C++ provides a solution to the slicing problem: virtual functions.

FIGURE 15.7 The Slicing Problem Resulting from Passing by Value
Description
Virtual Functions
To make the function virtual, we make one small change to our TimeOfDay class declaration:
We begin the declaration of the Write function with the reserved word virtual.
Description
Declaring a member function to be virtual instructs the compiler to generate code that
guarantees dynamic (run-time) binding of a function to an object; that is, the determination of
which function to call is postponed until run time. (Note that to make Write a virtual function,
the word virtual appears in one place only—the TimeOfDay class declaration. It does not
appear in the Write function definition that is located in the TimeOfDay.cpp file, nor does it
appear in any descendant class—such as ExtTime—that redefines the Write function.)
Dynamic binding The run-time determination of which function to call for a particular
object.
Virtual functions work in the following way. If a class object is passed by reference to some
function, and if the body of that function contains a statement
then
1. If MemberFunc is not a virtual function, the type of the parameter determines which function
to call. (Static binding is used.)
2. If MemberFunc is a virtual function, the type of the argument determines which function to
call. (Dynamic binding is used.)
With the addition of just one word—virtual—the difficulties we encountered with our Print
function disappear entirely. If we declare Write to be a virtual function in the TimeOfDay class,

the function
Description
works correctly for arguments of either type TimeofDay or type ExtTime. The correct Write
function (TimeOfDay::Write or ExtTime::Write) is invoked because the argument includes the
information needed at run time to choose the appropriate function. With this approach, deriving
a new and unanticipated class from TimeOfDay presents no complications. If the new class
redefines the Write function, then our Print function still works correctly. Dynamic binding
ensures that each object knows how to output itself and that the appropriate version is
invoked. In OOP terminology, Write is a polymorphic operation—an operation that has
different meanings depending on the type of the object encountered at run time.
Polymorphic operation An operation that has different meanings depending on the type
of the object to which it is bound at run time.
Here are some key points when using virtual functions in C++:
1. To achieve dynamic binding, you must use pass by reference when passing a class
object to a function. If you use pass by value, the compiler does not use the virtual
mechanism; instead, member slicing and static binding occur.
2. In the declaration of a virtual function, the word virtual appears only in the base class,
not in any derived class.
3. If a base class declares a virtual function, it must implement that function, even if the
body is empty.
4. A derived class is not required to provide its own reimplementation of a virtual function. In
this case, the base class’s version is used by default.
5. A derived class cannot redefine the function return type of a virtual function.
QUICK CHECK
15.3.1 Is a virtual function bound statically or dynamically?
15.3.2 What is static binding of functions?
15.3.3 What is the slicing problem?


15.4 Object-Oriented Design
Now that we’ve seen the language features that let us implement an object-oriented design,
we turn to the design phase itself.
A program usually models some real-life activity or concept. For example, a banking
program models the real-life activities associated with a bank. A spreadsheet program models
a real spreadsheet, which was a large paper form used in the past by accountants. Programs
for some kinds of robots model human perceptions and motions.
Nearly always, the aspect of the world we are modeling consists of objects—checking
accounts, bank tellers, spreadsheet rows, spreadsheet columns, robot arms, robot legs.
OOD is based on the philosophy that programs are easier to write and understand if the major
objects in a coded solution correspond to the objects in the problem. The programmer then
focuses on how best to represent the real-world objects using the data types and operations
provided by the programming language.
OOD can follow different paths. Different software engineering researchers advocate
different techniques. Our purpose here is not to teach you one detailed technique or to
summarize the different techniques. Rather, we will introduce you to a straightforward four-
stage process that captures the essence of OOD. The four stages are brainstorming, filtering,
scenario exploration, and responsibility algorithm design.
Brainstorming is the stage in which we make a first pass at identifying the objects in the
problem. We freely list every possible object we can think of, in both the problem and solution
domains.
Filtering is the stage in which we review the objects proposed in the brainstorming stage.
We look for objects that are redundant or that can be combined, and perhaps notice some that
are missing. Each object that survives the filtering stage becomes a class in the solution and
is recorded on a CRC card. CRC stands for classes, responsibilities, and collaborations. A
CRC card is a convenient way of recording important features of a class interface that
emerge as we proceed through the design.
Scenario exploration is the stage in which the behavior of each class is determined.
Because a class is responsible for its own behavior, we call these behaviors responsibilities.
(You’ve already seen use of this terminology. Recall that we have referred to the getter
functions as “knowledge responsibilities.”) In this stage, we explore “what if” questions to be
sure we have examined all of the situations. When all of the responsibilities of each class
have been determined, they are recorded on the class’s CRC card. We also note the names
of any other classes with which the class must collaborate (interact) to complete each
responsibility.
In the last stage, responsibility algorithm design, we write the algorithms for each of the
responsibilities outlined on the CRC cards. This stage is very similar to what happens in
functional decomposition.

FIGURE 15.8 A Blank CRC Card
Description
However, in many cases the responsibility algorithms are so simple that further
decomposition isn’t necessary, and we can go directly to writing out the concrete steps. See
FIGURE 15.8 for an example of a CRC card.
Although these techniques were originally developed for use in programming teams, we can
apply them to our own individual thought processes as well. Now that you have a general idea
of how this OOD technique works, we can examine the specifics of each of the stages.
Brainstorming
Just exactly what is brainstorming? The dictionary defines it as a group problemsolving
technique that involves the spontaneous contribution of ideas from all members of the group.2
Brainstorming brings to mind a group of bright advertising people, tossing around ideas for a
slogan for the latest revolutionary product. Modern software engineering projects similarly
involve developing new and innovative solutions based on the creative collaborations of a
diverse team.
Brainstorming The process of freely listing all the objects that may contribute to the
solution of a problem.
In the context of object-oriented problem solving, brainstorming is a group activity designed
to produce a list of candidate classes to be used to solve a particular problem. Each
participant starts from understanding the requirements document and any additional
information relating to the technical aspects of the project.

How does this process relate to individual problem solving? The equivalent step in the
problemsolving process is “Understand the problem.” Ask questions; try rewriting the problem
statement in your own words. Take a sheet of paper and start writing down possible classes.
Look for nouns in the problem statement that may indicate objects in the problem domain.
Think about how the user will interact with the program. Review the classes that are available
in libraries to see if any might be useful in the solution domain (including through inheritance in
an extended class).
When you have a list of possible classes, you can then move to the next stage: filtering.
Filtering
The filtering step produces a smaller list of classes that we believe are sufficient to solve the
problem. As part of the filtering stage we may recognize alternative approaches and choose
one set of objects over another.
Filtering The process of reviewing the initial list of objects to identify duplicate and
unnecessary objects.
For example, when we are developing a highway traffic management system, we may list
managers, drivers, lights, and cars as potential objects. In filtering the list, we might see that
the problem can be solved either by representing managers and drivers or by representing
lights and cars—but we don’t need both. We may also find that the C++ Standard Template
Library contains objects we can use to implement items on our list.
Some classes may not really belong in the problem solution. For example, if we are writing
a calculator app, we might list the user as an object in the problem domain. However, the user
is not within the problem; the user is an entity that provides input to the app. Another problem
domain object is the on button. A little thought shows that the on button of a real calculator is
not actually part of the solution; it is represented by the fact that the user has started the app.
Scenario Exploration
The goal of the scenario exploration phase is to assign responsibilities to each class. The
responsibilities are the tasks that each class must perform. As we have seen, responsibilities
are eventually implemented as functions. At this stage we are interested only in what the
tasks are, not in how they might be carried out. To talk about what an object does, we need to
determine its internal state, referred to as its attributes. We do not need to determine how
these attributes are to be represented at this stage, only what they are.
Responsibilities The operations associated with a class of objects.
For example, our TimeOfDay class has three attributes: hours, seconds, and minutes. We
have represented them as three integer values. In fact, we could keep the time as one integer
value, seconds. GetHours and GetMinutes could then return these values by calculating them

from seconds. Thus, at the logical (design) level, there are three values; at the implementation
level, however, there may be only one value. The process we are describing is at the design
(logical) level.
We distinguish two types of responsibilities: what a class must know about itself
(knowledge) and what a class must be able to do (behavior). A class encapsulates its data
(attributes); objects in one class cannot directly access data in another class. Encapsulation
is a key to abstraction. However, each class has the responsibility of providing the information
about itself that is needed by classes with which it collaborates.
Collaborations The interactions between classes that are needed to solve a problem.
For example, a Student class should “know” its name and address. The responsibilities for
this knowledge might be called Get Name and Get Address. Whether the address is kept in
the Student class or whether the Student class must ask some other class to access the
address is irrelevant at this stage. The important fact is that the Student class is able to
access and return (get) its own name and address.
The responsibilities for behavior look more like the tasks we described in functional
decomposition. For example, a student object needs to calculate its GPA (grade-point
average). In functional decomposition, we would say that a task is to calculate the GPA given
the data. In OOD, we say that the student object is responsible for calculating its own GPA,
perhaps by collaborating with an object that contains the student’s grades.
This distinction is both subtle and profound. The final code for the calculation may be
similar, but it is executed in different ways. In a procedural design, the main program calls the
function that calculates the GPA, passing the student record as a parameter. In an object-
oriented program, a message is sent to the student object to calculate its GPA. There are no
parameters because the object to which the message is sent knows its own data.
How do we go about determining the responsibilities? The name for this phase gives a clue
as to how we would assign responsibilities to classes. For our purposes, a scenario
exploration is a sequence of steps that describes an interaction between a client (user or
object) and any objects with which it must collaborate to satisfy a goal (which may include the
main application).
Scenario exploration A walk-through of the interactions between a client (the user or an
object) and any objects (including the main application) with which the client must
collaborate to achieve a particular goal.
Here is how the process works. The team uses play-acting to test different scenarios.
During this exercise, each member of the team plays the role of one of the classes. Scenarios
are “what if” scripts that allow participants to act out different situations. When a class has
been sent a message, the actor holds up the CRC card and responds to the message,
perhaps sending messages to others if necessary. As the scripts are being acted out, missing
responsibilities are unearthed and unneeded responsibilities are detected. Sometimes the
need for new classes surfaces. Although waving cards in the air when “you” are active might

feel a little awkward at first, team members quickly get into the spirit of the action when they
see how effective the technique is. See FIGURE 15.9.
The output from this phase is a set of CRC cards representing the core classes in the
problem solution. The responsibilities for each class are listed on the card, along with the
classes with which each responsibility must collaborate.
Responsibility Algorithms
Eventually, the algorithms must be written for the responsibilities. Because we focus on data
rather than actions in the object-oriented view of design, the algorithms for carrying out
responsibilities tend to be fairly short. For example, knowledge responsibilities usually just
return the contents of a variable in the object or send a message to another object to retrieve
one of its attributes. Action responsibilities are a bit more complicated, often involving
calculations. Thus, the functional decomposition method of designing an algorithm is often
appropriate for behavior responsibility algorithms.
FIGURE 15.9 A Scenario Walk-Through in Progress
A Final Word
To summarize, functional decomposition focuses on the process of transforming the input into
the output, resulting in a hierarchy of tasks. By contrast, object-oriented design focuses on the
data objects that are to be transformed, resulting in a hierarchy of objects. The nouns in the
problem description become objects; the verbs become responsibilities. In a top-down design,
the verbs are the primary focus; in an object-oriented design, the nouns are the primary focus.
The methodology we have described makes use of the CRC card. This card is simply a
notational device to help you organize your classes; its use is not a methodology.

BACKGROUND INFORMATION What’s the Best Solution?
As we discuss OOD, keep in mind that many different correct solutions exist for most
problems. The techniques we use may seem imprecise, especially when contrasted with
the precision required by the computer. In fact, the computer merely demands that we
code a solution precisely. The process of deciding which particular solution to use involves
the skills of judgment and reasoning. It is our human ability to make choices without having
complete information that enables us to solve problems.
FIGURE 15.10 Alternative Choices of Objects in an Air Traffic Control Application
Description
For example, in developing a simulation of an air traffic control system, we might decide
that airplanes and control towers are objects that communicate with one another.
Alternatively, we might decide that pilots and controllers are the objects that communicate,
as shown in FIGURE 15.10. This choice affects how we subsequently view the
collaborations, and hence the responsibilities that we assign to the objects. Either choice
can lead to a working application. We may simply prefer the one with which we are most
familiar (recall the “look for things that are familiar” strategy from Chapter 1).
Some of our choices may lead to designs that are more or less efficient than others. For
example, keeping a list of names in alphabetical order rather than in random order makes
it possible for the computer to find a particular name much faster. Nevertheless, choosing
to leave the list randomly ordered still produces a valid (albeit slower) solution.
The key point is this: Don’t hesitate to begin solving a problem because you are waiting
for some flash of genius that leads to the perfect solution. There is no such thing. It is
better to jump in and try something, step back and see if you like the result, and then either
proceed in the same direction or make changes. The CRC card technique is a way to
easily explore different design choices and keep track of them.
QUICK CHECK

15.4.1 What are responsibilities in terms of object-oriented design?
15.4.2 What are the two types of responsibilities?
15.4.3 What are the four major steps in designing an object-oriented solution to a
problem?
2 Webster’s New Collegiate Dictionary.

15.5 Implementing a Design
In OOD, when we first identify an object, it is an abstract concept. We do not immediately
choose an exact data representation for its attributes. Similarly, the responsibilities of objects
begin as abstract operations, because there is no initial attempt to provide algorithms. Of
course, eventually we have to implement it. For each abstract object, we have two tasks:
Choose a suitable data representation for its attributes.
Create algorithms for its responsibilities.
To select a data representation for an object, you have three options:
1. Use a built-in data type.
2. Use or extend an existing class.
3. Create a new class.
A good rule of thumb is to consider these options in the order listed. A built-in type is the
easiest to use. If a built-in type is not adequate to represent an object, you can look through
the available ADTs in a class library (either the system’s or your own) to see if any classes
are similar to the abstract object. Because we can use inheritance, it’s not necessary to find
an exact match, as long as an extension of the class can cover the difference. If no suitable
ADT exists, you must design and implement a new one.
Next we implement the responsibility algorithms. With OOD, the algorithms for many
responsibilities consist of a few steps that can be directly translated into C++. Of course, this
is not always the case. If an operation is complex, it may be best to treat it as a new problem
and use functional decomposition on the control flow. In this situation, it is appropriate to apply
functional 
decomposition 
and 
object-oriented 
methodologies 
together. 
Experienced
programmers are familiar with both and often use them either independently or in combination.
QUICK CHECK
15.5.1 To select a data representation for an object, what three choices does a C++
programmer have?
15.5.2 In addition to the three data representations mentioned in the previous question,
what else must be considered for an abstract object?
Problem-Solving Case Study
CREATING AN APPOINTMENT CALENDAR

PROBLEM: Create an application that allows the user to edit entries on a list representing
an appointment calendar. The input file contains a list of Entry objects similar to those
defined in Chapter 12; however, each Entry object also contains a Date member. The user
enters a name, and the application displays the entry for that name. After that, the user
chooses which field to change and enters a new value. At the end of the processing, the
list of updated entries is then written back to the file.
IDENTIFYING INITIAL CLASSES: Here is the list of potential objects, based on the
problem statement and some brainstorming:
Appointment Calendar
List
User
Entry
Name
Time
Date
Input File
Output File Format
Field
Some of these items are clearly not a part of our solution, such as the User. The purpose
of brainstorming, however, is to generate ideas without any inhibitions. Once we’ve run out
of ideas, we move on to filtering them.
FILTERING: After brainstorming, we filter the classes. The discussion that takes place
during the filtering stage may reveal some classes that are really the same thing. For
example, Appointment Calendar, List, Input File, and Output File all refer to the same
information. Appointment Calendar is another name for the contents of the file on which the
data are stored. That file is input when the program starts up, and it is output before the
program exits. The List is the name of the data structure into which the information is
stored within the program. Thus we have two representations for the Appointment
Calendar: the external file and the internal representation. So do we need an Appointment
Calendar class? Let’s leave it in the filtered list; we may remove it later.
We may also find classes that were overlooked. For example, even though the User
isn’t an object in the problem, its presence in the brainstorming list reminds us that we
need a User Interface that takes care of input and output. In the design, we call it a class;
however, it can be implemented as the main program.
Here is our filtered list, indented to show objects that are contained within other objects:
Appointment Calendar
User Interface
List
Entry
Name

Time
Date
File
Field
For each class that survives the filtering stage, we create a CRC card, which is just an
index card with a line drawn down the middle. The name of the class is written at the top,
and the two columns have the headings Responsibilities and Collaborations. If a class is
involved in a hierarchical relationship, that fact is noted at the top of the CRC card.
We already have an Entry class composed of a Name class and a TimeOfDay class. We
do not need to make CRC cards for them: They are available to us from our library. We
can use inheritance to create an EntryWithDate class from either our Entry class or our
ExpandedEntry class. The ComparedTo operation provided in the ExpandedEntry class
compares the time field. It is logical to keep an appointment ordered by date, so let’s have
EntryWithDate inherit its attributes directly from Entry.
Description
SCENARIO WALK-THROUGH: To further expand the responsibilities of the classes and
see how they collaborate, we process the scenarios by hand. We ask a question such as
“What happens when the user wants to change the name?” We then answer the question
by observing how each object is involved in accomplishing this task. In a team setting, the
cards are distributed among team members. When an object of a class is doing
something, its card is held in the air to visually signify that it is active. If you’re walking
through the scenario by yourself, you may set the card off to one side or put it on a bulletin
board.
What are the responsibilities of the User Interface and Appointment Calendar for getting
the Entry and displaying it? Let’s have the User Interface input the name and date and
retrieve the appropriate Entry. To do so, it must ask the Appointment Calendar to provide
the Entry, based on the name and date. That responsibility is written down on the card.

Once the name and date are input, the User Interface must collaborate with the Name and
Date classes to instantiate Name and Date objects, and then ask the AppointmentCalendar
class to retrieve the appropriate entry from the list.
After the User Interface gets the entry to be edited, it must get the field to be changed
and input that changed field. If the name is to be changed, the User Interface must input
the new name and collaborate with the Name class to instantiate a Name object. The same
procedure would be carried out if the other fields were changed. The User Interface then
must collaborate with the Entry class to instantiate a new Entry object, which is sent to the
Appointment Calendar to be inserted.
What is the role of the Appointment Calendar? It must search the List for an entry with a
certain name and date. In fact, the AppointmentCalendar class should be responsible for
entering the original List of entries and writing out the changed List of entries. Because our
Entry hierarchy is a hierarchy of immutable objects, the object being changed must be
removed from the List and the changed entry object then inserted.
Description
SUBSEQUENT SCENARIOS: The preceding example illustrated using CRC cards in a
single scenario. This particular scenario was selected from a list that was developed in a
scenario brainstorming session. Here’s a list of initial scenarios for our appointment
calendar example:
What happens when the user
Wants to change the date?
Wants to change the name?
Wants to change the address?
Decides to not make any changes?
Wants to change more than one field?
Wants to change only one part of a field (such as the month)?

We walk through each scenario, adding responsibilities and collaborations to the CRC
cards as necessary, and possibly extending the list of scenarios as we discover the need
to do so (such as when we identify unanticipated error situations) or determining that we
will not let the user perform that action. When every scenario we can envision seems to be
feasible with the existing classes, responsibilities, and collaborations, the design is then
finished.
ATTRIBUTES AND THEIR INTERNAL REPRESENTATIONS: Because we have used
classes and subprograms already in our library—Name, Time, Entry, ifstream, and ofstream—
only the Date class needs to have its internal representation determined. Before we do that,
however, we should determine the responsibilities for ADT Date.
Our problem statement tells us nothing about the Date class except that we need one.
What sorts of operations will our ADT Date need to perform? Of course, we need a default
constructor and a parameterized constructor that takes month, day, and year as
parameters. We should also have observer operations that let us observe the values for
the month, day, and year. Finally, we should have an operation that lets us compare two
dates.
Type
Date
Domain
Each Date value is a single date after the year 1582 A.D. in the form of month,
day, and year.
Operations
Construct a new Date instance.
Construct a new Date instance with a given month, day, and year.
Inspect the date’s month.
Inspect the date’s day. Inspect the date’s year.
Compare two dates for “before,” “equal,” or “after.”
Here is the CRC card representing the Date ADT:

Description
The domain of our ADT is the set of all dates after the year 1582 A.D. in the form of a
month, a day, and a year. We restrict the year to be after 1582 A.D. so as to simplify the
ADT operations. (Ten days were skipped in 1582 in switching from the Julian to the
Gregorian calendar.)
Default Constructor
For this operation, we use a C++ default constructor that initializes the date to January 1 of
the year 1583.
Parameterized Constructor
The client must supply three arguments for this operation: month, day, and year. Although
we haven’t yet determined a concrete data representation for a date, we must decide
which data types the client should use for these arguments. We choose integers, where
the month must be in the range 1 through 12, the day must be in the range 1 through the
maximum number of days in the month, and the year must be greater than 1582. Notice
that these range restrictions will become the precondition for invoking this operation.
INSPECT THE DATE’S MONTH, INSPECT THE DATE’S DAY, AND INSPECT THE
DATE’S YEAR: All three of these operations are knowledge responsibilities. They give the
client access—albeit indirectly—to the private data. As in the past, we represent
knowledge responsibilities as value-returning member functions with the following
prototypes:
Description

COMPARE TWO DATES: This operation compares two dates and determines whether
the first one comes before the second one, they are the same, or the first one comes after
the second one. To indicate the result of the comparison, we use enumeration type
RelationType with three values:
Then we can code the comparison operation as a class member function that returns a
value of type RelationType. Here is the function prototype:
Because this is a class member function, the date being compared to otherDate is the
class object for which the member function is invoked. For example, the following client
code tests whether date1 comes before date2:
Description
We are now almost ready to write the C++ specification file for our Date class. The
simplest representation for a date is three int values—one each for the month, day, and
year. Thus our internal structure is the same as the parameters. Here, then, is the
specification file containing the Date class declaration:
Description

Description
And here is the implementation file:
Description

Description
EntryWithDate Class
The CRC card can be translated directly into the specification file for this class.
Description
The algorithm for the ComparedTo function is a little complex. We are required to return an
item of RelationType, but AppointmentCalendar is interested only in equality. If the name and
the date are not equal, what do we send back: BEFORE or AFTER? In this case, let’s use the
comparison of the dates to determine the order.

Description
AppointmentCalendar Class
Which type of list should we use: sorted or unordered? It really doesn’t matter in this case.
All we plan to do is insert, search, and delete entries. We must, however, change the
comparison operations to use the ComparedTo function rather than the relational operators
and update the ItemType typedef to be an EntryWithDate. This information, along with the
CRC card, gives us enough information to write the specification file.
Description

Description
CONSTRUCTOR: The constructor should read in the entries and insert them in the list.
Because AppointmentCalendar will also write out the revised file, we must determine what
the file looks like as well. There are three classes, each with three data values. Date’s and
TimeOfDay’s data are integer values, whereas Name’s data consist of strings. Let’s write the
integer values first followed by the strings. Which kind of loop shall we use to input the
data? Because we always update the file after each session, let’s have WriteListToFile
put the number of entries as the first value on the file. This value can be used in a count-
controlled loop to read in the entries.
AppointmentCalendar (In: ifstream)
Read number of entries
FOR counter going from 0 to numberEntries - 1
Read hours, minutes, seconds
Read month, day, year
Read first, middle, last
TimeOfDay time(hours, minutes, seconds)
Date date(month, day, year)
Name name(first, middle, last)
EntryWithDate entry(date, time, name)
ACTION RESPONSIBILITIES: GetEntry takes a name and a date. The comparison
operation used in the list compares only the name and date, but the object being compared

must be an EntryWithDate. Thus, before we set up the iteration through the list, we must
create a time object and then an EntryWithDate object using the time, name, and date.
GetEntry (In: name, date)
Function return value: EntryWithDate
TimeOfDay time;
EntryWithDate otherEntry(date, time, name)
Reset list
Set entry to list.GetNextItem( )
WHILE entry.comparedTo(otherEntry) != SAME
Set entry to list.GetNextItem( )
Delete entry from list
Return entry
What happens if there is no entry that matches the given date and time? In Chapter 16
we introduce a construct to handle such a case: exceptions and the try-catch statement.
For the moment, we make it a precondition that such an entry exists. We then add an
IsThere function to class AppointmentCalendar, thereby giving the client a tool to guarantee
the precondition.
InsertEntry just calls the Insert operation for the list. The WriteListToFile operation is the
inverse of the constructor.
WriteListToFile (In: ofstream)
Reset the list
Write list.GetLength( )
WHILE list.HasNext( )
Set entry to next item
Set time to entry.GetTime( )
Set name to entry.GetName( )
Set date to entry.GetDate( )
Write time.GetHours( ), time.GetMinutes( ), time.GetSeconds( )
Write date.GetMonth( ), date.GetDay( ), date.GetYear( )
Write name.GetFirstName, name.GetMiddleName, name.GetLastName( )
Here is the implementation file for class AppointmentCalendar:

Description

Description

Description
UserInterface Class (Implemented as main)
The UserInterface class is responsible for prompting for and inputting the name and
date of the entry to be updated, then asking AppointmentCalendar to retrieve the entry.
Once the entry is found and output, UserInterface must ask the client which field is to be
changed. Here we have a decision to make: Should we let the client change individual
fields within the name, time, or date? For now, let’s just have the client replace a complete
name, time, or date.
We can create a menu of three characters: 'T' for time, 'D' for date, and 'N' for name.
Once the client has indicated which field is to be changed, UserInterface prompts for and
inputs that field, creates an EntryWithDate, and inserts the revised entry back into the list.
At that point, UserInterface asks the client if they want to continue.
UserInterface (implemented as main)
Define input file
AppointmentCalendar calendar(inFile)
Get name and date of entry to change
DO
IF calendar.IsThere(name, date)
Set entry to calendar.GetEntry(name, date)
Set time to calendar.GetTime( )
Print entry
Set inputCode to GetInputCode( )
SWITCH (inputCode)
‘T’ : GetTime( )

‘D’ : GetDate( )
‘N’ : GetName( )
EntryWithDate entry(date, time, name)
calendar. I nsertEntry(entry)
ELSE
Write “No entry exists with this name and date”
Ask client to enter ‘Y’ to continue or ‘N’ to stop
Read yesOrNo
IF toupper(yesOrNo) == ‘Y’
Get name and date of entry to change
WHILE (toupper(yesOrNo) == ‘Y’)
Close inFile Define outFile
calendar.WriteListToFile(outFile)
Close outFile
GetInputCode, GetEntryToChange, GetTime, GetDate, and GetName can be implemented as
helper functions that prompt for and read the appropriate data. Here is the implementation
file:
Description

Description

Description

Description
Here is the input file, followed by a scenario of three changes:
Description
Script from interactive session (client input is shaded):
Description

Description

Graphical User Interface (GUI)
Creating an Empty Window
The previous case study demonstrated the usefulness of object-oriented design and
specifically inheritance as a mechanism for reusing functionality defined in a base class. It
also showed an elaborate console-based user interface allowing the user to interact with a
calendar in various ways and saving changes to the calendar entries in a file. How might a
graphical interface improve the user experience and interactivity with this application?
There are several observations we can make with the console-based version that will help
us in designing an effective GUI. First, to retrieve an entry from the calendar we must input
the first, middle, and last name, as well as the date, to find a matching entry if it exists. What if
we forget the date of an appointment? If you consider an appointment calendar containing a
dozen or more entries, this will quickly become impractical for the average person! Another
issue that arises is that everything must be typed exactly as requested by the program. If the
first and middle name are accidentally entered without a space, or the day and month are
mistakenly swapped, the appointment data can easily be wrong or become corrupted. A
sensibly designed GUI will make it easier for the user to interact with and, at the same time,
protect the appointment data from accidental erroneous user input.
To improve on the previous version of the program we want to consider several changes to
the GUI version such as displaying the calendar entries in a visual list, being able to select a
calendar entry in the list, populate a form with appointment data, validate appointment data in
the form, save changes made to the appointment data back to the visual list, and write those
changes to the underlying calendar file. Fortunately, in Chapter 14, we discussed a similar
GUI that displays entries and allows the user to insert new entries and delete existing ones.
The graphical interface for our calendar appointment application will mostly be the same
visually. However, we will allow the user to click on an entry in the displayed list, to load its
data into a form. The form will use a widget to display both the time and date, and it will have
one button to save the appointment data and another to exit the application. The final GUI we
are going to create will look like this:

Description
When we click on one of the appointment entries on the left, the data associated with an
entry will be loaded into the form on the right:

Description
Any changes we make to the form data will then be saved to the calendar file when we click
the Save button. When we are finished using the application, we can click on the Exit button.
We began exploring graphical applications by first using off-the-shelf widgets. In later
chapters, we started revealing the underlying Qt graphical framework bit by bit and presented
custom-designed interfaces, but we held off discussing their implementation. At this point we
have covered enough about C++ and object-oriented programming to explore a custom-
designed graphical interface using Qt. We will gradually develop the GUI in small pieces to
understand each part before moving on to the next.
The Qt framework has many different graphical widgets we can use as provided, or extend
using inheritance, to build the GUI we want. We will start by creating a new C++ class that
extends the Qt framework’s QMainWindow class. A QMainWindow provides an empty window for
displaying a GUI. Here is the class definition for AppointmentCalendarWindow that we use as the
container for our GUI:

Description
We start by including QMainWindow because we need access to the definition of the base
class. This is followed by the definition of AppointmentCalendarWindow, which extends
QMainWindow to inherit all of its functionality. Our new class only specifies a public constructor
and destructor at this point. Qt organizes GUI components such that every graphical widget
has a pointer to each of the widgets that are contained inside it. This relationship is created by
passing to a widget’s constructor a pointer to the parent. If we do not pass a pointer to the
constructor of our derived AppointmentCalendarWindow class, it will default to nullptr, which
indicates that there is no parent widget. A default parameter value is defined by assigning a
value to a constructor parameter as illustrated in the constructor above.
You will also notice that the first line of the class consists of the Q_OBJECT identifier. This is an
example of what C++ calls a macro. You’re already familiar with the C++ preprocessor, which
runs through our code before it is passed to the compiler, handling directives such as
#include and #define. The preprocessor actually supports a separate programming language
in which it is possible to have whole blocks of directives that dynamically edit code as it gets
added, including making multiple copies of code segments that each have some change to
specialize them for different uses. The macro facility is thus a powerful tool that goes far
beyond simply including library code. Writing macro programs is beyond the scope of this
text, and the specifics of what the Q_OBJECT macro does are not important. But the general idea
is that it sets up much of the code for the Qt framework that is required to properly specify a
GUI widget (or window). The implementation of our empty window is straightforward:

Description
At this point, our class just passes the constructor parameter to the constructor of the
QMainWindow base class. If we were to execute this code in a complete application, we would
see an empty window:
Adding Button Widgets
Now that we have an empty window, we want to fill it with a GUI widget that is specific to
the calendar application. We will start with the Save and Exit buttons, because they are the
most straightforward. First, we will extend the AppointmentCalendarWindow specification to
include two private variable declarations for the buttons and a method that creates the buttons
and adds them to the GUI.

Description
Qt provides a QPushButton widget that we can use directly. These are declared as pointer
types because the Qt framework uses pointers to widgets in adding them to GUI
components. We must include the QtWidgets header to have access to the QPushButton
definition. The Build-ButtonsWidget method will create the buttons. This method returns a
pointer to a QWidget that we explain shortly.
Before we discuss the implementation, it is important to know that a QMainWindow only allows
a single “central” widget to be added to it and rendered. If it can display only a single widget,
then how do we add more than one to the window? In this application, we plan to have two
buttons as well as other components. The answer is that we gather multiple widgets into a
single widget using a layout, which is an object that displays widgets in a particular
arrangement.
This is a good example of object-oriented design. The job of the QMainWindow is simply to
display a window that holds something. We can design windows with all kinds of widgets in
different arrangements, and it would overly complicate QMainWindow to have it also be
responsible for managing the placement of those widgets. Therefore, Qt delegates that
responsibility to another object, which gathers our widgets and our specifications of how to
arrange them into a single widget that is passed to QMainWindow.
There are three different layouts provided by Qt that we will see in this application. The first
is a class named QHBoxLayout that arranges components next to each other horizontally. We
will discuss the other layouts later.
A layout object has an addWidget method that we use to add widgets, such as our two
buttons. Because a layout object is not a widget itself, we must create an additional generic
QWidget widget (which we call buttonsWidget) and set its layout to be the one containing the
buttons (using its setLayout method). In the end, buttonsWidget will render the layout, which
will cause the window to display the buttons horizontally. The implementation of the above

specification is shown in the following code. Note that because we are working with pointers to
widget objects, we need to use the arrow operator for selecting their members.
Description
The BuildButtonsWidget method first creates a wrapper widget called buttonsWidget. We
then create a new QHBoxLayout called buttonsLayout and call the setLayout method on the
buttonsWidget object, passing in the buttonsLayout. Pay close attention to this pattern of
creating a widget and a layout and then connecting them. We’ll see it over and over as we
build interfaces with Qt.
Now that we have a widget connected with a layout, we proceed with creating the buttons
by instantiating two QPushButton objects, each initialized with a string that is used as the button
label. Lastly, we add the buttons to the layout and return the buttonsWidget. Note, the ordering
of adding the buttons to the layout determines the order in which they are displayed
horizontally from left to right. FIGURE 15.11 illustrates the containment hierarchy of the GUI
component objects.

FIGURE 15.11 Nesting of GUI Button Widgets Inside a Layout That Is Inside a General
Widget
Description
The constructor begins by calling the BuildButtonsWidget, which returns the widget
containing the buttons laid out horizontally. The QMainWindow class provides a method named
setCentralWidget, which sets the widget to be rendered by the window. We call this method,
passing it the widget containing the buttons. Lastly, we use the inherited setWindowTitle
method to give the window a sensible title. A good way to test what we have done is to run
this code to see what the GUI looks like so far. Here is a driver main function that instantiates
an Appointment-CalendarWindow to render the interface on the screen:
Description
The main function just creates an AppointmentCalendarWindow and calls its show and exec
methods to render the window to the screen and start the GUI event loop, as we discussed in
Chapter 14. If we execute this code, we will see that our window contains the two buttons we
created, arranged as expected.
Description
Adding Form Widgets

The remaining parts of the GUI include the list of appointments and the form to display and
modify appointment entries. We will focus on the form in this section. As was the case in the
previous section, we need to create each of the stock widgets that come with Qt such as
labels and text boxes and arrange them properly into a single generic form widget with a
layout object. The general design of the form is depicted in FIGURE 15.12. We include
editable text boxes to display the name data for a selected appointment entry and a popup
date and time widget for the appointment date and time. We also need a label to identify each
of the form widgets for the user.
As we did for the buttons, we will extend the AppointmentCalendarWindow with member
variables for each of the widgets we are creating and a method to build the form. Here is the
class definition code, with the additions highlighted:
Description
FIGURE 15.12 Appointment Calendar Form Design
Screen shot(s) reprinted with permission from Apple Inc.
Description

Description
The fixed labels will be implemented using the QLabel widget, and the editable text boxes will
be made from QLineEdit widgets. These are private because we do not want them accessible
outside of this class. As mentioned previously, Qt requires the widgets to be declared as
pointers. We also declare the BuildFormWidget method prototype, which will do the work of
creating all of the form widgets with the proper layout and returning a pointer to a QWidget
containing each of these widgets in the proper layout.
The arrangement of the form widget is more complicated than a horizontal layout can
handle, so here we introduce a second type of layout object. The QGridLayout arranges
widgets in a grid of rows and columns. Using this layout will make it easy to place each widget
using a row and column coordinate. In addition, we want to left-align the labels and text boxes
to make the GUI aesthetically pleasing, which we can do by specifying a parameter from an
enumerated type that Qt defines.
In FIGURE 15.13 we show the form overlayed with a grid and the placement of each widget
within the grid. This will allow us to easily place and locate each of the widgets in the form. For
example, the coordinate row 3, column 1 refers to the date and time widget.
The implementation of the BuildFormWidget method is shown in the following code along
with an updated constructor for the test driver:

Description
FIGURE 15.13 Form Grid Layout
Description

Description
First, we create a wrapper widget named formWidget and set its layout using a QGridLayout
object. We then proceed to create the labels by instantiating QLabel widgets and text boxes by
creating QLineEdit widgets. We initialize the labels with a string that will be displayed when
they are rendered. The text boxes will be empty, so we do not initialize them with anything. We
also create a new QDateTimeEdit widget, which we will use for the date and time. The current
date and time are passed to the QDateTimeEdit via its constructor. The Qt framework provides
the date and time as a static method called QDateTime::currentDateTime.
To set the display format for the date and time, we call the setDisplayFormat method,
passing in a string containing the format for the date and time. The format string indicates the
month, day, and year as “MM/dd/yyyy” and the hour, minute, and seconds as “h:mm:ss”. The
“ap” part of the format string indicates that the period, am or pm, should be displayed. To
enable our date and time widget to display a popup window for editing purposes, we invoke
the setCalendarPopup method, passing it in the Boolean value true.
Lastly, we add each of the graphical widgets we just created to the form layout. The
addWidget method of the QGridLayout class has three required parameters: the widget to add
to the grid, the row, and the column. An optional fourth parameter is the alignment. We add
each widget, specifying the desired grid location, along with its alignment; for example, the
label for the last name is placed in row 2, column 0, and left-aligned using the Qt::AlignLeft
constant. Qt lets us specify the alignment using constants from an enumerated type that it
defines. Other constants in the type are Qt::AlignRight and Qt::AlignCenter. We then return
the formWidget, which contains the layout, which further contains all the widgets.
For our test driver, we add a call to BuildFormWidget in the constructor for Appointment-
CalendarWindow and change the call to setCentralWidget so that it refers to the formWidget. At
this time, we are just testing the newest piece of the GUI to make sure that it renders each of
the widgets correctly. We’ll see how to combine the buttonsWidget and the formWidget later.

Description
The main function does not require any changes. If we execute this code, the formWidget
will be rendered to the screen as shown below.
Description
Adding The List Widget
The remaining visible widget we need to create is a component to display the list of names
associated with calendar appointments and a label to indicate the purpose of the list to the
user. First, we extend the AppointmentCalendarWindow class with the following two additional
variable declarations:
Description
The QLabel will be used to explain the list. Then we introduce a new widget type called
QListWidget, which can hold a list of items that can be added, removed, and displayed. We will
also add a prototype method that we will use to create and initialize the widgets:
The implementation of the BuildListWidget method is similar to what we have seen before,
except that we will use a third type of layout class, named QVBoxLayout, which arranges
internal widgets vertically, one on top of the other, in the order added. We will not add anything
to the list until we have completed the implementation of the GUI. Here is the code:

Description
Again, we update the constructor so we can test the layout of the list widget by setting the
central widget of the window to be the list widget built from the BuildListWidget method:
Description
Description
The main function does not require any changes. If we execute this code, the list widget will
be rendered to the screen as shown below.

Adding the Main Widget
Now that we have implemented all the main graphical parts for this application, we need to
combine them into a single widget to be rendered by the AppointmentCalendarWindow. To do
this, we extend the class specification to include a method prototype named BuildMainWidget
for building the main widget. This method has a parameter for each of the widgets we
previously constructed. The GUI will also need a place to display messages to the user when
any of the form text boxes are empty, for validation purposes. We will initially use an empty
label for this. The two additions to the class are:
Description
The implementation of BuildMainWidget will use a QGridLayout to arrange the previously
constructed components and the message label into a grid. We use the addWidget method to
add each of the widgets to the grid at the desired location. This grid layout will have 3 rows
and 2 columns. The first row will have the appointment list in the first column and the form in
the second column. The second row will have nothing in the first column and the buttons in the
second column (under the form).
The message label is initialized to the empty string and placed in row 2, column 0. We want
it centered under both the first and second column, so we use two additional optional

parameters to the addWidget method that follow the row and column coordinates. These
optional parameters define the row and column span in that order in the parameter list, to allow
a widget to span more than one column or row. We want the message label to span one row
and two columns. The implementation is shown here:
Description
Finally, we can update the constructor to create the QLabel for the messageLabel, build the
main widget, and set the window’s central widget to render the main widget.
Description
The construction of graphical components is now complete. We still need to connect the
GUI to the appointment calendar data and write event handlers to load and save calendar
entries. We will take care of this in the next sections. Running the application now will render
the full GUI for this application.

Description
Adding Application State
Now that the GUI is in place, we want to connect it with the application’s state (stored
information)—that is, the appointment calendar and the entries containing names and dates.
The graphical interface will need the list of appointments to populate the entry list widget.
Later, we will add code to populate the form with appointment data when an item on the list is
clicked and to save modifications when the Save button is clicked.
First, we need to give the GUI access to the calendar data. The AppointmentCalendar-
Window constructor must be modified to receive an AppointmentCalendar as a parameter, and
we need to add a member variable to reference it when we click and modify calendar entries.
We first update the AppointmentCalendarWindow class specification with the following code:
Description
The constructor implementation is updated to include the new parameter, and it initializes it
in its initializer list:

Description
Our next task is to use the appointment calendar data to populate the list widget in the GUI.
To do this, we need the ability to iterate over the entries in the calendar. The Appointment-
Calendar class doesn’t have iterator methods, so we need to add them. Fortunately, this is
easy because the List class we created in Chapter 14, which is used by AppointmentCalendar,
does have iterator support. Thus, our iterator implementation for AppointmentCalendar simply
calls the iterator methods in List. The following code shows the changes, omitting the details
of the rest of the List implementation:
Description
Now that we can iterate over the calendar entries, we can write the code to copy the
calendar data into the GUI so they can be rendered in the entry list widget. We add a method
prototype, void LoadListWidget, to the AppointmentCalendarWindow class and write the
following implementation:
Description
We start at the beginning of the calendar by calling the calendar’s ResetList method. Then
we loop until we reach the end of the appointments. For each appointment, we get the next
EntryWithDate item, call its GetName method to get its Name object, and then construct a string of

the first and last name that will be displayed in the list widget. The nameListWidget is a
QListWidget object, as we discussed previously. QListWidget defines an addItem method that
takes a pointer to a QListWidgetItem object as an argument. The QListWidgetItem is
constructed with a string to be displayed for a list entry. In this case, we pass the display
name we created to its constructor and then add the item to the list. The last remaining task is
to add a call to LoadListWidget in the constructor of AppointmentCalendarWindow.
After we compile and run the code, our GUI will now be rendered with the list of names
contained in the appointments:
Description
Now that we have our GUI connected to the data it will manipulate, we need to allow the
user to interact with the GUI by clicking on entries and buttons. We cover this in the next
section.
Responding to Events
In the previous chapter we discussed the EventHandlers class for handling events that occur
when buttons are pressed in the GUI. The purpose of that class was to separate the event
handling from the implementation of the GUI interface itself. In this application, we will include
the event handling code inside the implementation of the AppointmentCalendarWindow class.
There are many ways in which we could implement event handlers and how they are
connected to events generated by GUI components. In this case, we choose to follow the
approach suggested by the Qt developers, which is the most straightforward for this
application.

There are three aspects of writing an event-handling interface: knowing which events can
occur, knowing what the application needs to do for each event when it happens, and knowing
what part of the program’s state must be changed (if any) in response to an event. This
application has three events that we care about, and each event will cause an action to be
performed. We will use the following list to guide us with the implementation:
1. When an item in the list of appointment entries is clicked (event), the application will set
the form entries to the corresponding appointment data (action). The application will
remember which item in the list was clicked and the appointment calendar entry that was
used to load the data into the form (state change).
2. When the Save button is clicked (event), the application will get the potentially edited data
from the form and perform a validation check to make sure all the form fields are
nonempty. If any field is empty, it will display an error message and return. If the data are
valid, it will check to see if they are different from what is currently stored. If there is no
difference, it will display a message to that effect and return (action). If the data have
changed, it will remove the existing item from the appointment calendar, create a new
entry in the appointment calendar with the data from the form, and update the list widget
in the GUI (state change).
3. When the Exit button is clicked (event), the application will close (action, no explicit state
change).
We will begin by extending the AppointmentCalendarWindow class definition with method
prototypes for each of the event handlers from the preceding list. The Qt framework refers to
event handlers as slots and extends the C++ language to specify that particular methods are
slot (event handler) methods that will be used to handle events. The following is the code that
we need to add to the AppointmentCalendarWindow class:
Description
These methods are private to this class and are identified with the “slots” syntax. The last
two method prototypes do not have any parameters because we will connect the specific
button to the proper handler later in our code. However, because we do not know which item
will be clicked in the appointment entry list, the HandleEntryItemClickedEvent method will
receive the specific item that was clicked, as an argument. As our checklist reminds us, we
also add two member variables that we will use to remember the current widget item that was
clicked and the appointment entry that corresponds to it. The use of these variables will
become apparent when we discuss the implementation of the handler methods:

Description
The easiest event handler to implement is the HandleExitButtonClickedEvent method
because it only needs to do one thing: close the application. Here is its implementation:
Description
This 
method 
is 
straightforward—it 
simply 
calls 
the 
close 
method 
on 
this
AppointmentCalendarWindow object, and the Qt framework handles the exiting of the GUI
application. We see how we connect the handlers to the events once we have implemented
each handler.
The next handler we consider is the HandleEntryItemClickedEvent method and its
requirements. The goal of this handler is to load the form with the appointment data associated
with the name that was clicked in the lists. If you recall, we created each list entry in the GUI
by creating a QListWidgetItem and setting its displayed text to the first and last name of the
person in the appointment entry. However, we did not save the other appointment data along
with it. We could display all of the appointment data for each entry in the GUI list, but that
would be messy and duplicate what the form will show.
The QListWidgetItem class does provide support for associating other data with it.
Unfortunately, we can only associate Qt objects with list items. Thus, our solution will be to
convert an appointment entry into a Qt object that we can store in a QListWidgetItem. When
the user clicks it, we will then have access to the appointment data in the
HandleEntryItemClicked-Event handler.
Before we look at the event handler implementation, we need to refactor the code to add the
rest of the appointment data to the GUI list. Here is the new implementation for the LoadList-
Widget method with the changes highlighted:

Description
For each entry in the calendar, we create a new QListWidgetItem. In our previous
implementation, we passed the displayed string to the constructor. Here, we set the displayed
text via a method call, to make clear that there are two different types of data we are
associating with the list widget item. First, we get the name from the entry to construct the
string that the list widget item will render. We call the QListWidgetItem’s setText method to set
the text to be displayed.
Next, we want to associate the appointment data with the QListWidgetItem so we can
retrieve them in the HandleEntryItemClicked event handler method. We can’t use an
EntryWithDate object because QListWidgetItem only allows us to give it a Qt object. However,
Qt does provide its own string type named QString, which we can easily instantiate from a
built-in C++ string.
The only thing we need to do is be able to represent an appointment as a string. We do this
by extending the EntryWithDate class with a ToString method that returns a string
representation of the appointment entry. The string that is returned is simply each of the data
items contained in the EntryWithDate (e.g., first name, last name, day, hour, etc.) delimited by
spaces. We also add a static class method called FromString that will convert the string
representation of an appointment entry into an EntryWithDate object. The implementation of
these methods is straightforward, so we won’t show them here, but they are in the code listing
at the end of this section. Once we have converted an appointment entry into a standard C++
string, we convert it again, into a QString, using the Qt static class method fromStdString.
That’s what is accomplished by these two lines in the preceding code:
Description

Now we explain the next two lines, which are responsible for getting this string into the list
item. Items in a list widget can have many different attributes, such as the display font,
background color, and so on. Qt refers to each of these attributes as having a role in the
behavior of the item. It also provides a general purpose role, called Qt::UserRole, that lets us
store an associated data value in the item using a setData method. However, one more type
conversion needs to happen to our QString value before we call setData.
Qt needs to be able to flexibly pass different kinds of values into methods, so the designers
developed a union type that can hold many different data types. Recall that a union is a bit like
a struct, with a list of members, but at any given time it can only hold one of the various
possible types of values. The Qt designers thus call their union type QVariant. And one of the
many Qt types it can hold is a QString. As you might have already guessed, the setData
method expects to be passed a parameter of the QVariant type.
So, we simply construct a new QVariant by passing our QString representation of the entry
to its constructor. Then we can finally store the entry data in the list item using setData,
specifying that the role of the data is Qt::UserRole and giving it the QVariant object.
Description
Lastly, we add the item to the list widget. I
Now that we have the appointment data inside each of the list items, we can turn our focus
back to the implementation of the HandleEntryItemClicked event handler. Recall that when the
user clicks on an item, the handler responds by showing the entry data in the form and
remembering which item is loaded in the form and what the entry holds. Here is its code:
Description
Description

With all of the scaffolding in place, the implementation of this method is clear. First, if any
message is displayed on the GUI from a previous action, we want to clear it out. We will see
how this might happen when we look at the event handler for the Save button. Next, we get
the appointment entry that we associated with the item widget. We do this by calling its data
method and passing it the Qt::UserRole value so that it returns the data we associated with
the item. The type of the return value is QVariant, which we need to convert to a QString,
which we can then convert to a C++ string using toStdString. That string is then passed to
the FromString static method of the EntryWithDate class, which converts it back into an
EntryWithDate object. We fill the form by passing the entry to a SetFormFromEntry method,
whose definition we show next. Lastly, we set the currentItemLoaded variable to the item we
just clicked and currentEntry to the entry extracted from the list item. We need to remember
both of these values in case the form fields are modified and the Save button is clicked.
As you might expect from the preceding, getting the data from our entry into the form is
going to involve converting each of the entry members into corresponding Qt types, and then
setting the fields in the form to show those converted values. Because several of those
conversions are to QString, we will just define a single variable, qs, of that type, to temporarily
hold each value on its way into the form. Here is the implementation of the SetFormFromEntry
method:
Description
The first part of the method is straightforward. We extract the Name, Date, and TimeOfDay
objects from the entry. Then the parts of the name are converted to QString objects and used
to set the displayed text in each of the corresponding fields in the form.

The date and time widget requires some additional type conversions. It expects a QDate-
Time object that contains a date and time. However, Qt doesn’t provide a constructor to build a
QDateTime directly. Instead, we need to create a QDate object using the year, month, and day
from our Date object, and a QTime object from the hours, minutes, and seconds we get from
our TimeOfDay object. Then, we can at last create a QDateTime object from those QDate and
QTime objects. This layering of object types is a common approach in object-oriented design,
where the goal is for each object to have a very specific set of responsibilities.
The final event handler we need is HandleSaveButtonClickedEvent. The action of this handler
is to verify that there are no empty form fields and display an error message if there are, warn
the user if there was no change to save, save any changes to the appointment into the list
widget that is displayed to the user, save changes into the calendar appointment list, and write
the new calendar appointment list back to the calendar file. Fortunately, we have covered
many of the Qt details at this point, so the implementation of this method should be apparent.
Description

Description
When the Save button is clicked, the handler above is invoked. If any messages were
displayed on the GUI, we first clear those out. We then check that there are no empty form
fields. If any of the fields are empty, we display a message in the GUI and return.
Once we know that the form data are valid, we take the data from the form and convert
them into an EntryWithDate. We get the form data by calling GetEntryFromForm, which returns
an EntryWithDate object. We discuss the implementation of this method later. Then we check
to see if the form data are the same as the entry we used to load the form. If there are no
changes, we display a message and return.
If there are changes, we use the date to update the displayed appointment list and the state
of the calendar object. The currentItemLoaded variable refers to the list item that was clicked,
and we update its visible text by building the new string, converting it to a QString, and passing
that to its setText method. This is followed by updating the appointment data stored in the
UserRole of the list item widget. Doing so involves the same series of three type conversions
we used to initialize the list item widgets.
We then assign the currentEntry to be the entry we just created from the updated form
fields and then call SaveCalendarToFile to write the changes to the calendar file. We will not
discuss the details of SaveCalendarToFile because it is straightforward. We will include the
implementation in the code listing at the end of this section.
To complete our understanding of the HandleSaveButtonClickedEvent method, we now
discuss the implementation of the GetEntryFromForm method shown in the following code:
Description

We get the parts of a name as C++ strings by calling the text method for each of the
corresponding QLineEdit objects in the form. The text method returns a QString, which we
convert to a C++ string using the toStdString method. Then the strings are used to construct
a Name object. We then call the date and time methods of the QDateTimeEdit widget, which
return QDate and QTime objects, respectively. From these objects we extract their individual
parts of the date and time, using appropriately named observer methods, which we then use
to create our Date and TimeOfDay objects. Finally, we construct an EntryWithDate and return it.
Now that we have seen the implementation of the event handler methods, we need to
connect them with the events that invoke them. The Qt framework provides special functions
that allow us to connect an event to an event handler. In Qt terms, an event is called a signal
and, as we mentioned earlier, an event handler occupies a slot that the event loop uses to find
the event handler for a particular signal. The setup for this is done by a connect method that
we will call in the 
InitializeEventHandlers method that is invoked from the
AppointmentCalendarWindow constructor:
Description
The connect method has four arguments. The first is the widget that will produce the signal
(event), the second is the type of signal, the third is the object that will handle the signal, and
the fourth is the event handler to invoke. The types of signals a widget item can generate are
specified in the Qt documentation associated with the widget.
The QListWidget GUI component can produce an itemClicked signal that provides a pointer
to the QListWidgetItem that was clicked. We arrange for Qt to listen for that signal by
associating it with our HandleEntryItemClickedEvent signal handler, which receives the pointer
to the QListWidgetItem that was clicked. The QPushButton widget can produce a clicked signal,
so we have Qt listen for it and invoke our HandleSaveButtonClickedEvent event handler if the
button is clicked. Lastly, our HandleExitButtonClickedEvent handler is invoked if the Exit button
produces a clicked signal. Qt does quite a bit in the background to associate a signal with a
slot, with the goal of making it fairly straightforward for us to use the connect, SIGNAL, and SLOT
functions.
We list the changes to EntryWithDate (highlighted) and the specification and implementation
of AppointmentCalendarWindow below.


Description


Description

Description

Description

Description

Description

Description

Description

Testing and Debugging
Testing and debugging an object-oriented program is largely a process of testing and
debugging the C++ classes on which the program is built. The top-level driver also needs
testing, but this testing is usually uncomplicated—OOD tends to result in a simple driver.
To review how to test a C++ class, refer back to the “Testing and Debugging” section of
Chapter 9. There we walked through the process of testing each member function of a class.
We made the observation then that you could write a separate test driver for each member
function or you could write just one test driver that tests all of the member functions. The latter
approach is recommended only for classes with a few simple member functions.
When an object-oriented program uses inheritance and composition, the order in which you
test the classes is, in a sense, predetermined. If class X is derived from class Y, you cannot
test X until you have designed and implemented Y. Thus it makes sense to test and debug
class Y (the base class) before you test class X.
When class Y contains an object of class Z, then you should generally test Z before Y. If
you’re waiting for someone else to finish the implementation of Z, however, you can still
perform some initial tests on Y by writing a stub class for Z. A stub class provides a minimal
implementation of the interface that allows a client class to operate. For example, if we were
adding a function to determine the difference between two dates, we could code a stub that
always returns BEFORE. That’s sufficient to enable the client code to make the call and receive
a value.
Stub classes also allow you to control the testing of a class more precisely, because you
can write the stubs for the functions to return specific values. Why would that approach be
helpful? When your class uses an object of a very complex class, it can be challenging to
force the other class to return the values you need for testing. With a stub class, you have
total—and very direct—control over what is returned to the class you are testing.
Testing and Debugging Hints
1. Review the Testing and Debugging Hints in Chapter 12. They apply to the design and
testing of C++ classes, which are at the heart of OOP.
2. When using inheritance, don’t forget to include the word public when declaring the derived
class:
Description

The word public makes BaseClass be a public base class of DerivedClass. As a
consequence, clients of DerivedClass can apply any public BaseClass operation (except
constructors) to a DerivedClass object.
3. The header file containing the declaration of a derived class must #include the header file
containing the declaration of the base class.
4. Although a derived class inherits the private and public members of its base class, it
cannot directly access the inherited private members.
5. If a base class has a constructor, it is invoked before the body of the derived class’s
constructor is executed. If the base class constructor requires arguments, you must
pass these arguments using a constructor initializer:
Description
If you do not include a constructor initializer, the base class’s default constructor is
invoked.
6. If a class has a member that is an object of another class and this member object’s
constructor requires arguments, you must pass these arguments using a constructor
initializer:
Description
If there is no constructor initializer, the member object’s default constructor is invoked.
7. To achieve dynamic binding of an operation to an object when passing class objects as
arguments, you must
Pass the object by reference, not by value.
Declare the operation to be virtual in the base class declaration.

8. If a base class declares a virtual function, it must implement that function even if the body
is empty.
9. A derived class cannot redefine the function return type of a virtual function.

Summary
Object-oriented design (OOD) decomposes a problem into objects—self-contained entities
in which data and operations are bound together. In OOD, data are treated as an active,
rather than passive, quantity. Each object is responsible for one part of the solution, and
the objects communicate by invoking one another’s operations.
The OOD process begins by identifying potential objects and their operations.
Brainstorming is used to produce a list of possible classes in the problem. Filtering
reexamines the classes, looking for duplicate classes, unnecessary classes, and missing
classes. CRC cards are then written for the classes that survive the filtering phase. Next,
scenarios are examined to determine the responsibilities of the classes. Finally, algorithms
are written to carry out the responsibilities, and concrete data representations are chosen.
Object-oriented programming (OOP) is the process of implementing an object-oriented
design by using language mechanisms for data abstraction, inheritance, and dynamic
binding (polymorphism). Inheritance allows any programmer to take an existing class (the
base class) and create a new class (the derived class) that inherits both the data and the
operations of the base class. The derived class then specializes the base class by adding
new private data, adding new operations, or reimplementing inherited operations—all
without examining or modifying the implementation of the base class in any way.
Dynamic binding of operations to objects allows objects of many different derived types
to respond to a single function name, each in its own way. C++ supports dynamic binding
through the use of virtual functions. Together, inheritance and dynamic binding have been
shown to dramatically reduce the time and effort required to customize existing ADTs. The
result is truly reusable software components whose applications and lifetimes extend
beyond those conceived of by the original creator.

Quick Check Answers
15.1.1 In a structured program, functions interact with one another and with the data in the
program. In an object-oriented program, objects (which bind operations and data together)
are the components that interact. 15.1.2 Abstraction, inheritance, dynamic binding. 15.1.3
The construction of programs that are collections of interacting functions or procedures.
15.1.4 Data. 15.1.5 To implement the operations on objects. 15.2.1 
class
InternationalPhone : public Phone 15.2.2 By placing a member field within
InternationalPhone that is of class Phone. 15.2.3 An is-a relationship. 15.2.4 A mechanism
by which one class acquires the properties—the data and operations—of another class.
15.2.5 Public. 15.2.6 A constructor initializer. 15.2.7 (1) The base class (Y) constructor is
executed first. (2) Constructors for X’s member objects (if any) are then executed. (3) The
body of X’s constructor is executed last. 15.3.1 Dynamically. 15.3.2 The compile-time
determination of which function to call for a particular object. 15.3.3 When an object of a
derived class X is assigned to an object of a base class Y, only the data members that X
and Y have in common are copied to Y. 15.4.1 The operations associated with a class of
objects. 15.4.2 Knowledge (what a class must know about itself) and behavior (what a
class must be able to do). 15.4.3 Brainstorming, filtering, scenarios, responsibility
algorithms. 15.5.1 Use a built-in type. Use or extend an existing class. Create a new class.
15.5.2 The implementation of the responsibility algorithms.

Exam Preparation Exercises
15.1 Match the following terms with the definitions given below.
a. Structured (procedural) program
b. Object-oriented program
c. Inheritance
d. Superclass
e. Subclass
f. Composition
g. Static binding
h. Dynamic binding
i. Polymorphic
i. Determining, at run time, from which class to call a function
ii. A class from which properties are acquired
iii. A collection of classes designed using abstraction, inheritance, and
polymorphism
iv. An operation that has different meanings depending on its binding to an object
v. Including an object of one class within another class
vi. A class that acquires properties from another class
vii. Determining, at compile time, from which class to call a function
viii. A collection of functions, designed using functional decomposition
ix. Acquiring the properties of another class
15.2 Structured programming is better suited to developing small programs, whereas
object-oriented programming is better for writing large programs. True or false?
15.3 Inheritance allows us to reuse functions from a base class and add new
functions, but we cannot replace functions in the base class with new
implementations. True or false?
15.4 To solve the slicing problem, we use a combination of pass by reference and
virtual functions. True or false?
15.5 If we want a function to be virtual, where do we write the keyword: in the base
class declaration file, in the base class definition file, in the derived class declaration
file, or in the derived class definition file?
15.6 Which C++ language mechanism implements composition?
15.7 Suppose you have a subclass that contains several data members that are not
defined in its superclass. What happens to those data members if you assign an

object of the subclass to a variable of the superclass?
15.8 A client is supplied with the following declaration for a base class and a derived
class:
Description
The client writes the following code to call the constructor for an object of type
DerivedClass, and then outputs the fields in the newly created object.
Description
The compiler reports an error for the second statement. What’s wrong? How would
you fix this problem?
15.9 Consider the following base and derived class declarations:

Description
For each class, do the following:
a. List all private data members.
b. List all private data members that the class’s member functions can reference
directly.
c. List all functions that the class’s member functions can invoke.
d. List all member functions that a client of the class may invoke.
15.10 A class called DerivedClass is a subclass of a class called BaseClass.
DerivedClass also has a member field that is an object of class ComposedClass.
a. Which class’s constructor is called first when an object of class DerivedClass is
created?
b. Which class’s constructor is called last when an object of class DerivedClass is
created?
15.11 Why does slicing occur with pass by value but not with pass by reference when
a derived class object is passed to a parameter of its base class?
15.12 What’s wrong with the following class declarations?

Description
Description
15.13 Explain the difference between an is-a relationship and a has-a relationship.
15.14 When we code a derived class in separate files, which of the following steps do
we take?
a. Include the base class specification and implementation file in both the derived
class specification file and its implementation files.
b. Include the base class specification file in the derived class specification file, and
include the base class implementation file in the derived class implementation file.
c. Include the base class specification file in the derived class specification file.
d. Include the base class implementation file in the derived class implementation file.
15.15 What is the task of the brainstorming phase?
15.16 What is the task of the filtering phase?
15.17 What is the task of the scenario exploration phase?
15.18 What is the task of the responsibility algorithm phase?
15.19 At which phase is a concrete data representation chosen?

Programming Warm-Up Exercises
15.1 Given the following declaration for a TestScore class, write a derived class
declaration called IDScore that adds an integer student ID number as a private
member and that supplies (1) a constructor whose parameters correspond to the
three member fields, and (2) an observer that returns the ID number.
Description
15.2 Write the implementation file for the TestScore class in Exercise 15.1. The
constructor just assigns its parameters to the private data members, and the
observers simply return the corresponding member.
15.3 Write the implementation file for the IDScore class in Exercise 15.1. The
constructor just assigns its parameters to the private data members, and the
observer simply returns the corresponding member.
15.4 Write the specification file for a class called Exam that uses composition to create
an array of 100 objects of class IDScore as defined in Exercise 15.1. The class can
use the default constructor, and it will have a function that assigns an IDScore object to
a location in the array, given the object and the location as parameters. The class
should also have an observer that returns the IDScore object at the position specified
by its parameter.
15.5 Write the implementation file for class Exam as defined in Exercise 15.4.
15.6 The following class represents a telephone number in the United States:

Description
Using inheritance, we want to derive an international phone number class, InternPhone,
from the Phone class. For this exercise, we assume that the only change necessary is to
add a country code (an integer) that identifies the country or region. The public operations
of InternPhone are Write, which reimplements the Write function from the base class, and
a class constructor, which takes four parameters corresponding to the four member fields
in the class. Write the class declaration for the InternPhone class.
15.7 Implement the InternPhone class constructor as described in Exercise 15.6.
15.8 Implement the Write function of the InternPhone class as described in Exercise
15.6.
15.9 Write a global function WritePhone that takes a single parameter and uses
dynamic binding to output either a U.S. phone number (Phone class) or an international
phone number (InternPhone class). Make the necessary change(s) in the declaration
of the Phone class from Exercise 15.6 so that WritePhone executes correctly.
15.10 Given the following declaration for a class that represents a computer in a
company’s inventory, write a derived class declaration (for a class called
InstallRecord) that adds (1) a string field representing the location of the computer
and (2) a field of class SimpleDate that holds the installation date. The new class
should provide observers for each of the new fields. It should also reimplement the
Write function.
Description

Description
15.11 Implement the constructor for the Computer class declared in Exercise 15.10.
15.12 Implement the constructor for the InstallRecord class declared in Exercise
15.10.
15.13 Implement the Write function for the Computer class declared in Exercise 15.10.
It should output each member field on a separate line.
15.14 Implement the Write function for the InstallRecord class declared in Exercise
15.10. It should output each member field on a separate line. Assume that the
SimpleDate class provides a void function called Write() that outputs the date in a
standard format.

Programming Problems
15.1 Use object-oriented programming to develop an application for the game of
memory. Memory consists of a 20 x 20 grid of face-down cards where there is at
most one pair of each card in the grid. The types of cards that are available in this
version of the game are DOG, CAT, RAT, MOUSE, PENCIL, CRAYON, ROCK,
BOOK, BAG, and KEY. Adding a new type of card to the game should only require the
creation of a new class that inherits properties from an existing Card class. Each card
has a unique description associated with it that will give the player something to
remember that card by. Game play proceeds by flipping two cards over to determine if
a matching pair has been found. After the pair has been chosen, the application
should report the description of the card and if a match was found or not found. If a
matching pair has been found, those cards are no longer able to be chosen, and the
application should report if a card is chosen that already corresponds to a match and
will allow the player to choose a different card. The game continues until all matches
have been found or the user types in the command “quit”.
15.2 Use object-oriented programming to develop a game application that simulates a
roulette table. The roulette table has 36 numbers (1 to 36) that are arranged in three
columns of 12 rows. The first row has the numbers 1 through 3, the second row
contains 4 through 6, and so on. There is also a number 0 that is outside the table of
numbers. The numbers in the table are colored red and black (0 is green). The red
numbers are 1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, and 36. The
other half of the numbers are black. In a simplified set of rules, players can bet on an
individual number (including 0), the red numbers, the black numbers, the even
numbers, the odd numbers, the numbers 1 to 18, the numbers 19 to 36, and any of
the columns or rows in the table. The user should be allowed to enter one of the bets,
and the application uses the rand function from <cstdlib> as the basis for computing
the number that would be rolled on the wheel. It then compares this number to the bet
and reports whether it won or lost. The process repeats until the user enters a quit
command.
15.3 Use object-oriented programming to develop an extension to the application of
Problem 15.2. The new application should allow the user to enter an initial amount of
money into an account. In addition to placing a bet, the user specifies an amount to go
with the bet. This amount is deducted from the account; any winnings are added to the
account. The current winnings or losses (difference from the original amount) should

be displayed in addition to the value of the account. Winnings are computed as
follows:
Single-number bets pay 36 times the amount placed.
Row bets pay 12 times the amount placed.
Column bets pay 3 times the amount placed.
Odd/even, red/black, and high/low half-bets pay 2 times the amount placed.
The user should not be allowed to bet more than the amount in the account.
15.4 Use object-oriented programming to develop a game application that plays the
children’s game of rock, paper, scissors. The user enters a letter, indicating his or her
choice. When a choice is entered, the rand function from <cstdlib> is used to pick a
value in the range of 1 through 3, with 1 corresponding to rock, 2 corresponding to
paper, and 3 corresponding to scissors. The computer’s choice is compared to the
user’s choice according to these rules: rock breaks scissors, scissors cut paper,
paper covers rock. Choices that match are considered ties. Output a count of the
wins by the user and the computer, and of the ties. The application ends when the
user enters an invalid choice.
15.5 Use object-oriented programming to develop an extension to the application of
Problem 15.4. The new application should accept either the original single letter or the
full words (rock, paper, scissors). The capitalization of the words should not matter.
The extended application should end only when the user enters “q” or “quit” as a
choice and should prompt the user for one of the valid choices if an invalid value is
entered.
15.6 Use the Computer and InstallRecord classes declared in Programming Warm-Up
Exercises 15.10 to 15.4, together with the SortedList class developed in Chapter 13,
as the basis for an object-oriented program that keeps track of a company’s computer
inventory. The company has at most 500 computers. The following operations should
be supported:
Add a new computer to the list.
Delete a computer from the list.
Change the location of a computer.
Print a list of all computers in inventory-number order.
Print a list of all computers in a given location.
Print a list of all computers of a particular brand.
Print a list of all computers installed before a given date.</SUB_BL>
The application should keep the list sorted by inventory number. It should read an
initial list from a file called original.dat. At the end of processing, it should write the
current data in the list onto a file called update.dat in a format that could be read back

in by the program as an initial list. You will also need to develop the SimpleDate class
to the degree necessary to support the application.

Case Study Follow-Up
1. The name of the input file is given explicitly in the case study code. Write a function
that prompts for and inputs the file name. The file should be a parameter of the
function. The function should also have a Boolean parameter through which it returns
false if the input file cannot be found after giving the user three tries to enter a correct
file name. Have it return true if the file is opened properly. Change the code in main to
use this function.
2. Write and implement a test plan to verify that the change made in Exercise 1 is
correct.
3. We have implemented the TimeOfDay object using three values for hours, minutes, and
seconds. Seconds are not relevant in this problem; they are too fine a distinction.
Explore the idea of keeping the time of day as a single variable that represents the
time as a number of minutes. What changes would be required in the client code of
the case study if this change were made? Explain your answer.
4. Implement the alternative version of TimeOfDay using the scheme outlined in Exercise
3.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 6
Templates, Operator
Overloading, and
Exceptions
KNOWLEDGE GOALS
To understand the concept of a template.
To know what a generic operation is.
To understand the concept of an exception.
SKILL GOALS
To be able to:
Write a C++ class template.
Code the instantiation of a class template.
Write function definitions for members of a template class.
Design and code a C++ function template.
Write code that instantiates a function template.
Overload the relational operators.
Define an exception class and write code that throws an exception.
Write an exception handler.
This chapter introduces C++ language features that can have a powerful impact on how we
design and implement software: templates, operator overloading, and exceptions. A template,
as the name suggests, is a pattern from which we can create multiple instances of something.
C++ templates let us create specialized instances of functions or entire classes without
having to explicitly change or extend them.

Operator overloading allows us to redefine the standard C++ operators. In particular, we
can redefine the relational operators so that they can be used to compare class objects.
Exceptions are unusual events that happen during execution. The C++ exception-handling
mechanism allows one part of a program to detect that an exception has occurred and
another part of the program to respond to it. The part that does the detection is said to throw
an exception, and the part that responds (called an exception handler) is said to catch the
exception.

16.1 Template Classes
In Chapter 13, we defined a List abstract data type (ADT) that represented a list of unsorted
components, each of type ItemType. We coded this ADT as a C++ class named List, and the
header file List.h was written as follows (abbreviated here by omitting the function
preconditions and postconditions):
Description
The typedef statement lets us choose a particular type for ItemType, as long as it is a simple
type or the string class.
The List class is similar to a generic data type in the sense that if we change the ItemType
by changing the typedef statement, we can recompile the class without changing any of the
algorithms in the member functions.
However, the List class as written has two serious limitations. First, once the class is
compiled using, say, int as the ItemType, a client program’s List objects can only be lists of
ints. The client cannot have a list of ints and a list of floats within the same program.
Second, a client program cannot specify or change the ItemType; a programmer must modify
list.h manually.

To make a class such as List a truly generic type, we need a language construct that
allows ItemType to be a parameter to the class declaration. Fortunately, C++ provides such a
construct: the class template.
Generic data type A type for which the operations are defined but the data types of the
items being manipulated are not.
Class template A C++ language construct that allows the compiler to generate multiple
versions of a class through the use of parameterized data types.
Defining a Class Template
In C++, a class template allows you to write a class definition with “blanks” to be filled in by
the calling code. Most often, the “blanks” are the names of data types.
Here is the syntax for a class template:
where ClassDefinition is an ordinary class definition. The full syntax description of
TemplateParamList in C++ is quite complicated, and we simplify it for our purposes as
follows. TemplateParamList is a sequence of one or more parameter declarations separated
by commas, where each is defined as follows:
Here is a class template for our List class, with the class name changed to GList:

Description
As the highlighting indicates, this template is like the declaration for the List type, except that
it is preceded by template<class ItemType> and the class name is changed. Here, ItemType is
the template parameter. Just as before, we use ItemType wherever we need to refer to the
data type of a list element. The difference is that the type isn’t hard-coded with a typedef
statement, but instead is specified when the class is instantiated. You can use any identifier
for the template parameter; we just use ItemType in this example because we have been using
it in our List classes.
There are two things to note about template parameters. First, the use of the word class in
template<class ItemType> is simply required syntax and does not mean that the list items
must be objects of a C++ class. A list created from this template can hold any data type,
including built-in or user-defined types. (For this reason, some C++ programmers are moving
toward using the newer reserved word typename, although class is more traditional.) In the
example code in the next section, we use int, char, and float to instantiate three specific
classes from this template.
Second, the template parameter takes the place of an explicit type name within the code.
So what do we pass to this parameter? A data type name. This may seem strange at first,
because when we pass arguments to functions, we always pass variable names or
expressions, not data type names. Furthermore, passing an argument to a template has an
effect at compile time—the compiler generates a new class definition from the template. In
contrast, passing an argument to a function has an effect at run time.
Instantiating a Class Template
Given the GList class template, the client program can use code like the following to create
several lists whose components are of different data types:

Description
Description
In the declarations of list1, list2, and list3, the data type name enclosed in angle
brackets is the template argument. When the compiler encounters the declarations of list1,
list2, and list3, it generates (instantiates) three distinct class types and gives its own
internal name to each of the three types. You might imagine that the declarations are
transformed internally into something like this:
Description
In C++ terminology, the three new class types are called template classes or generated
classes (as opposed to the class template from which they were created). Individually, each
concrete class that is generated from a template is known as a specialization of the template.
When the compiler instantiates a template, it literally substitutes the template argument for
the template parameter throughout the class template. For example, the first time the compiler
encounters GList<int> in the client code, it generates a new class by substituting int for
every occurrence of ItemType in the class template:

Description
A useful perspective on class templates is this: Whereas an ordinary class declaration is a
pattern for stamping out individual objects, a class template is a pattern for stamping out
individual data types.
Now that we’ve seen how to write the definition of a class template, what do we do about
the definitions of the class member functions? We need to write them as function templates
so that the compiler can associate each one with the proper template class. Here is the
syntax diagram for a function template:
Function template A C++ language construct that allows the compiler to generate
multiple versions of a function by allowing parameterized data types.
As you can see, the FunctionTemplate is very similar to the ClassTemplate, with two
exceptions: the TemplateParamList can be omitted under some special circumstances,1 and
the template parameter specification is followed by a FunctionDefinition rather than a
ClassDefinition.
For example, we code the Insert function as the following function template:

Description
Notice how we must write GList with <ItemType> appended to it so that the compiler knows
to which specialization of GList we are referring. Multiple specializations within a class are
also possible (though no examples are provided here), and the compiler needs to be told
which one is which in every case.
If the client declares a type GList<float>, the compiler generates a function definition similar
to the following:
Description
Another Way of Implementing Incoming Parameters: const
References
Thus far we have used a very simple rule for parameters in our functions: Incoming
parameters are passed by value, and all other parameters are passed by reference. In this
way, we avoid certain kinds of side-effect errors. Reference parameters allow the function to
directly access the argument, which is necessary whenever a value must be passed back
through a parameter.
For parameters of built-in types and simple, small objects, the copying that takes place for a
value parameter is comparable in efficiency to the passing of an address that occurs with a
reference parameter. When we use objects that are larger, however, copying them consumes
more time. Templates make it simple to generate large and complex data structures—for
example, we can instantiate either a list of large objects or a list of ints from the same
implementation. As a result, we can create a template that is efficient for simple types, yet
horribly slow for complex types. Even when the operations performed by the template on the
complex types are fast, the cost of copying to value parameters dominates the processing
time.
What we need is a parameter-passing mechanism that is as efficient as pass by reference
but as safe as pass by value. C++ provides such a mechanism by allowing us to specify a
reference parameter as being constant. It is, therefore, important that we bring the constant
reference parameter mechanism to bear on our template function definitions. For example, the

following code shows how we should implement the GList insert operation, with the changes
highlighted:
Description
To convert a value parameter to a constant reference we precede the type name with const
and follow it with &. Are the value parameter and the constant reference equivalent? Definitely
not! Within the function, the constant reference parameter really is a constant—you cannot
assign a new value to it. This stands in contrast to the value parameter, which is a variable
within the function. Because a value parameter contains a copy of its argument, we can
assign a new value to it or modify its contents without affecting the argument.
In addition to the restriction that we cannot assign a new value to a constant reference,
when the type of the parameter is a class, we are not allowed to apply its transformer
(mutator) methods.
We can call only observers for an object passed as a constant reference. Recall from
Chapter 12 that we append const to the headings of functions that do not change the values
within an object. When an object is passed to a constant reference parameter, only its const
functions can be applied to it. The compiler issues an error message if we try to call any of the
object’s nonconstant functions.
Organization of Program Code
When working with template classes, we must change the ground rules regarding the file(s)
into which we put the source code. Previously, we placed the class declaration into a header
file called List.h and the member function definitions into an implementation file called
List.cpp. As a result, List.cpp could be compiled into object code independently of client
code. This strategy won’t work with templates. The compiler cannot instantiate a template
unless it knows the argument to the template, and this argument is located in the client code.
A general solution is to compile the client code and the class definition at the same time.
With our GList template, one technique is to dispense with an implementation file glist.cpp,
and instead place the template class declarations and member function definitions in the
same file, GList.h. Another technique is to retain two distinct files, GList.h and GList.cpp, but
place the directive #include "GList.cpp" at the end of the file GList.h. Either way, the compiler
has all the source code—both for the client code and for the class—available to it at once.
In the following code for the GList template, we use the first technique—namely, appending
the implementation to the specification in a single file.

Description

Description

Description
Here is the same driver program we used to test the List class in Chapter 13. The changes
necessary to run GList instead of List are shaded. (Yes, only two lines need to be changed.)
Because the output is the same as in Chapter 13, we do not repeat it here.

Description

Description
The file name in the include statement and the declaration of the list are the only changes.
The declaration is the type name with the definition of ItemType in brackets next to it. For

example,
Description
declares a GList named temps, for which the items on the list are specialized to be ints. If we
wanted the items on the list to be floats or strings, the following statements would declare
them:
Description
Although using templates allows us to create generic data types, as noted in the
comments, our implementation of the GList operations requires the items on the list to be
comparable using the relational operators. Thus we cannot define
Description
because class Name uses function ComparedTo rather than the relational operators. It is
important to document any restrictions on the types that can be used to instantiate a generic
class. In a later section, we discuss ways to redefine the relational operators so that they can
be applied to a class such as Name.
Another aspect of our GList type that’s not fully generic is that its size is fixed to 100
components. It would be useful if the client code could specify a value for MAX_LENGTH when
instantiating GList. C++ provides another mechanism to enable this behavior.
In addition to listing type names in the template parameter list, C++ permits us to include
non-type parameters there as well. We can use these parameters to initialize the
specialization. Non-type template parameters are restricted to just a few types: ints, enums,
pointers, and references. In this text, we look only at the use of int non-type template
parameters. Another restriction is that the value of an argument to such a parameter must be
fixed at compile time. Thus, for example, we can’t instantiate a template using an argument
value that is input by the user at run time.
Here is how we can enable instantiation of any size of GList. In the template declaration and
in each of the function templates, we change the heading to include an int parameter called
MAX_LENGTH, as highlighted here:
Description
Here we have made the parameter a constant and written the identifier in the style of a
constant. We’re not required to use const, but in this case we want to ensure that MAX_LENGTH
is not allowed to change. In the temperatures program, we then change the instantiation of the
GList class to the following:

Description
The result is identical to that produced by the earlier code. But now, if we discover that we
are running out of space in the list, we can just change the instantiation in the client code as
follows, rather than having to edit the declaration of GList:
Description
You are asked in the exercises to make these changes to the code and test them.
A Word of Caution
If you develop your programs using an integrated development environment (IDE) in which
the editor, compiler, and linker are bundled into one application, you must be careful when
using templates. With an IDE, you typically are asked to define a “project”—a list of the
individual files that constitute a program. With Chapter 13’s List class comprising two files
(list.h and list.cpp) and your client code located in a file myprog.cpp, you would specify
myprog.cpp and list. cpp in your project. The key idea is that these two files are compiled
separately and then their object code files are linked (by the linker) to form an executable file.
With templates, this situation may change. We do not want to separately compile
myprog.cpp and glist.h (or glist.cpp if we’re using the second approach to organizing the
code). The solution in this case is to specify only myprog.cpp in the project. Because
myprog.cpp says to include glist.h, and glist.h either contains the implementation code or
says to include glist.cpp, the compiler receives all of the source code to compile at once.
QUICK CHECK
16.1.1 What kind of ADT does a template enable us to write?
16.1.2 In mathematics, an ordered pair is a pair of numbers written in the form (a, b).
Rewrite the following OrdPair declaration as a class template so that clients can
manipulate ordered pairs of any simple type, not just ordered pairs of ints.
Description

16.1.3 Given the OrdPair class template from Question 16.1.2, write client code that
declares three class objects named pair1, pair2, and pair3 that represent the ordered
pairs (5, 6), (2.95, 6.34), and ('+', '#'), respectively, and outputs the ordered pairs
represented by pair1, pair2, and pair3.
16.1.4 Given the OrdPair class template from Question 16.1.2, write function
definitions for the member functions.
16.1.5 What is a generic data type?
16.1.6 What is a class template?
16.1.7 What are the two limitations of the List ADT defined in Chapter 13 as discussed
in this section?
16.1.8 What is the concrete class known as once it is generated from a template
class?
16.1.9 What mechanism is used in C++ to pass a reference parameter to a function
that is as safe as passing a parameter by value?
1 Once a template function is defined, an additional definition, called an explicit specialization,
can be written that redefines the function for a specific type. This redefinition is preceded by
template <>, and the heading of the function includes the type to appear in angle brackets
following the function name. There is controversy in the C++ community about the use of
explicit specializations, and their definition may change in a future version of the language.
Thus, we do not discuss them further here. Even so, you should be aware of the implications
of seeing template followed by empty brackets, in case you encounter such code elsewhere.

16.2 Generic Functions
Sometimes when we are designing or testing software, we discover a need for a single
algorithm that might be applied to objects of different data types at different times. We want to
be able to describe this algorithm without having to specify the data types of the items being
manipulated. Such an algorithm is often referred to as a generic algorithm. C++ supports
generic algorithms by providing two mechanisms: function overloading and template
functions.
Generic algorithm An algorithm in which the actions or steps are defined but the data
types of the items being manipulated are not.
Function overloading
Function overloading is the use of the same name for different functions, as long as their
parameter types are sufficiently different for the compiler to tell them apart. To see how it
works, let’s look at an example.
Function overloading The use of the same name for different functions, distinguished
from each other by their parameter lists.
Suppose we are debugging a program and want to trace its execution by outputting the
values of certain variables as the program executes. The variables we want to trace are of the
following six data types: int, char, float, double, short, and long. We could create six
functions with different names, such as PrintInt, PrintFloat, and so on, to output values of
different types. Instead of forcing us to invent different names for these similar functions,
however, C++ lets us use function overloading to call them by the same name—Print:

Description
The calls to these functions look like this:
Description
We can think of Print as a generic algorithm in the sense that the algorithm itself—
outputting the string "***Debug" and then the value of a variable—is independent of the data
type of the variable being output. As we program, we have to use only one name for this
algorithm (Print), even though there are really six distinct functions.
How does function overloading work? When the compiler encounters the function call
it compares the type of the actual argument with the types of the formal parameters of the six
functions. If someVar is of type int, then the compiler generates code to call the Print function
that has an int parameter. If someVar is of type float, then the compiler generates code to call
the Print function that has a float parameter, and so forth.
As you can see, function overloading benefits the programmer by eliminating the need to
come up with different names for functions that perform identical tasks on arguments of
different data types. Despite the benefits of function overloading, in our Print function example
we still had to supply six distinct function definitions. This entails a tedious amount of copy-

and-paste work in an editor, and the resulting code is cluttered with nearly identical function
definitions.
Defining a Function Template Outside a Class
A cleaner way to solve this problem is to use template functions. We have already seen that
this approach offers a way to implement the member functions of a template class; however,
C++ doesn’t restrict template functions to classes. They can be defined anywhere we can
define a normal function. Here we’ll use the alternate keyword, typename, just to emphasize
that Print doesn’t have to be part of a class.
Description
Instantiating a Function Template
Given this Print function template, we can make function calls as follows:
Description
In this code, the type name enclosed in angle brackets is the template argument. At compile
time, the compiler generates (instantiates) three different functions, each of which is
specialized for the particular template argument.
When the compiler instantiates a template, it literally substitutes the template argument for
the template parameter throughout the function template, just as you would do with a search-
and-replace operation in an editor. For example, the first time the compiler encounters
Print<float> in the calling code, it generates a new function by substituting float for every
occurrence of SomeType in the function template:
Description

Here is the syntax template for a call to a template function:
Description
As you can see, the template argument list in angle brackets is optional. In fact, most
programmers omit it. In that case, the compiler is said to deduce the template argument(s) by
examining the function argument list.
For example, our earlier example of calling code using explicit template arguments would
more likely be written as follows:
Description
In this code, when the compiler encounters Print(sum), it looks at the data type of the function
argument sum (which is int) and deduces that the template argument must be int. Therefore,
the function call is to the Print<int> specialization of the template.
In some situations, however, the compiler cannot deduce the proper specialization of a
function. For example, if the parameter is an object of a polymorphic class, the compiler
doesn’t know which subclass will be passed to the function at run time. Keep in mind that the
compiler must be able to do all of the work to instantiate a generic function at compile time. If it
can’t deduce the specialization from the code, you must specify the type explicitly.
QUICK CHECK
16.2.1 Write a function template for a value-returning function Thrice that receives a
parameter of any simple type and returns three times that value.
16.2.2 Write calling code that calls Thrice (from Question 16.2.1) two times, once with
an integer argument and once with a floating-point argument.
16.2.3 What is a generic algorithm?
16.2.4 What is function overloading?
16.2.5 How does function overloading benefit the programmer?
16.2.6 How can function overloading be improved when the function body performs
the same operations over many types?

16.3 Operator Overloading
In Chapter 14, we created a sorted linked list that contained items of class Entry. To
accomplish this task, we had to rewrite the list algorithms using function ComparedTo rather
than the relational operators. We can avoid that step by using another advanced feature of
C++: operator overloading.
Here is the Date class from the last chapter enhanced with functions that overload the
relational operators <, >, and ==. The function prototypes are shaded.
Description
The syntax for overloading a symbol is the word operator followed by the symbol to be
overloaded. When we use these operators, they each have two operands, yet only one
parameter is shown in the parameter list. Where is the other operand? The first operand is the
object to which the operator is applied, and the second operand is the parameter. Such
functions are known in C++ as operator functions. Here are their implementations:

Description
Here is a test driver to show how we use these functions. In the exercises, you are asked
to build a test plan for class Date and to overload the remaining relational operators.

Description
Description
Output:
Description
As you can see, objects of class Date can now be compared using the relational operators
<, >, and ==. In these examples, the operand to the left of the operator is passed as the
argument to the first operand in the function; that is, it is the object to which the function is
applied. The operand to the right of the operator is passed as the argument to the parameter in
the function’s parameter list.
Here are some guidelines for overloading operators:
1. All C++ operators may be overloaded except ::, ., sizeof, and ?:.
2. One operand of the overloaded operator must be a class instance.
3. You cannot change the standard order of operator precedence, define new operator
symbols, change the number of operands of an operator, or change an operator’s
associativity.
4. Overloading unary operators: If data is of type SomeClass, and you want to overload, say,
the unary minus operator, then you would write the operator function heading as
data.operator-(). The empty parameter list tells the compiler that you mean the unary
version of the minus operator. When you invoke the overloaded unary minus, the
operand to the right of the operator is the object to which the function is applied.2

5. Overloading binary operators: If data is of type SomeClass and you have overloaded, say,
the addition operator (+) in class SomeClass, then data + otherData is equivalent to
data.operator+(otherData).
As we noted in Guideline 1, all but a few of the C++ operators can be overloaded, including
assignment, array indexing, function calls, pointer dereferencing, and the stream (shift)
operators. You should consult a C++ reference before attempting to overload (), [], ->, <<,
and >>, because some additional considerations arise with these operators that we do not
cover here.
Using *this
In the preceding example, the > function is basically identical to the < function except that we
used the > relational operator in all of the If statements. Once < has been defined for Date, it
would be nice if we could avoid checking every member of a Date and just write the body of
the > function as follows:
The problem with this statement is that thisDate isn’t defined anywhere. How can we refer to
a whole object from within itself? C++ solves this problem by providing a reserved word, this,
that represents a pointer to the current object. To access the object, we have to dereference
this with the * operator. The > function can then be rewritten as follows:
Description
Operator overloading is a very powerful feature of C++ that can make a user-defined type
look nearly identical to a built-in type in terms of how it can be used in expressions and I/O.
Some debate has arisen within the programming languages community about the desirability
of operator overloading. (The designers of Java, for example, deliberately omitted the
capability from that language.) Within a particular context, such as creating a matrix algebra
package for scientific computing, the effect can enable programmers to express algorithms in
very natural and compact syntax. However, heavy use of operator overloading can also lead
to confusing code where it appears that expressions are manipulating built-in types when they
are actually operating on user-defined types. For this reason, careful documentation and use
of explanatory comments is important for operator overloading.
QUICK CHECK
16.3.1 Write a function heading for an operator function that overloads the less than
operator (<).

16.3.2 What is a benefit of using operator overloading?
16.3.3 What is a drawback of using operator overloading?
2 For the increment and decrement operators, this syntax overloads their prefix (e.g., ++x )
forms. Early C++ compilers did not allow overloading of the postfix (i.e., x++ ) forms of ++ and
-- . Newer compilers, however, support a heading of the form data.operator++(int dummy) .
Nothing is actually passed to the parameter dummy , and it automatically has the value 0. The
name of the parameter doesn’t have to be dummy ; any identifier will work. The presence of this
unused int parameter is just a syntactic trick to signal to the compiler that the function should
be applied to the object to the left of the operator.

16.4 Exceptions
Suppose we’re writing a program in which we frequently need to divide two integers and obtain
the quotient. In every case, we need to check for division by 0, so we write a function named
Quotient that returns the quotient of any two integers unless the denominator is 0:
Description
We are faced with a problem: What should this function do if the denominator is 0? This is
not an easy question to answer. Here are some possibilities, none of which is entirely
satisfactory:
1. Don’t perform the division, and silently return to the calling code.
2. Print an error message and return an arbitrary integer value.
3. Return a special value such as -9999 to the caller as a signal that something went wrong.
4. Rewrite the function with a third parameter, a Boolean flag indicating success or failure.
5. Print an error message and halt the program.
Choice 1 is clearly irresponsible. Choice 2 informs the user with an error message, but will not
notify the calling code that anything went wrong. Choice 3 might be acceptable in some
circumstances, but in general is not a good solution. If the numerator and the denominator are
allowed to be any integers, then -9999 is a perfectly valid quotient and cannot be distinguished
from a special signal value. Choice 4 is a reasonable approach and is used quite often by
programmers. Its disadvantage in our case is that we should change our value-returning
function (which returns just one value) into a void function so that two values can be returned
through the parameter list as reference parameters: the quotient and the Boolean flag. Choice
5 is almost never satisfactory. The calling code—not the called function—should be allowed to
decide what to do in case of an error. Perhaps the caller would like to take steps to recover
from the error and keep executing the program rather than terminating it.
One way out of our dilemma is to eliminate the dilemma! Use a function precondition as
follows:

Description
Here, the caller must ensure that the precondition is true before calling the function; as a
consequence, the function does not have to do any error detection. Instead, with this
approach, the caller is responsible for both error detection and error handling. Throughout this
text, we have used this strategy to eliminate error detection from called functions. In some
situations, however, errors can be detected only after an action has been attempted, not
before.
For example, a function ReadInt that is supposed to input an integer value may find that the
user has erroneously typed some letters (in which case the input variable is not changed, and
the cin stream goes into the fail state). In this case, we cannot set a precondition for ReadInt
that “The next input value is a valid integer” because there is no way for the caller to predict
what the input will be. To deal with errors of this kind (and for programmers who prefer not to
use the precondition approach), the C++ language provides an exception-handling
mechanism.
In the world of software, an exception is an unusual event, often an error, that requires
special processing. A section of program code that provides the necessary special
processing is called an exception handler. When a section of code announces that an
exception has occurred, it is said to throw (or raise) an exception, hoping that another section
of code (the exception handler) will catch the exception and process it. If no exception handler
exists for that particular exception, the entire program terminates with an error message.
Exception An unusual, often unpredictable event, detectable by software or hardware, that
requires special processing; also, in C++, a variable or class object that represents an
exceptional event.
Exception handler A section of program code that is executed when a particular
exception occurs.
Throw (raise) To signal the fact that an exception has occurred.
Catch To process a thrown exception. (The catching is performed by an exception
handler.)
Let’s look now at the mechanisms C++ provides for throwing and catching exceptions.
The throw Statement
In C++, the term “exception” not only has the general meaning of an unusual event, but also
has a more specific meaning: a variable or class object that represents such an event. To

throw (raise) an exception, the programmer uses a throw statement, whose syntax is as
follows:
In the throw statement, Expression can be a value or a variable of any data type, either built
in or user defined. Let’s look at three examples of throw statements.
Here is Example 1:
throw 5;
In this example, we throw an exception of type int with the expectation that one or more
exception handlers wants to catch an exception of type int. (We see how this is done in the
next section.)
In Example 2, we throw an exception of type string, the standard library class:
Example 3 throws an exception of a class type that we define ourselves:
Description
In Example 3, observe how we first declare a class object named sal and then throw that
object. More commonly, C++ programmers do the following:
Description
In this code, the throw statement creates an anonymous (unnamed) object of type
SalaryError by explicitly calling its default constructor (signified by the empty argument list)
and then passes this anonymous object to an exception handler. It would be a syntax error to
leave off the parentheses:

The reason is that the syntax for the throw statement requires an expression, not the name of
a data type.
Finally, notice in the syntax template that Expression is optional. We discuss later what
happens if the throw expression is absent.
The try-catch Statement
If one part of a program throws an exception, how does another part of the program catch the
exception and process it? The answer is by using a try-catch statement, which has the
following form:
Description
The syntax of FormalParameter is as follows:
Description
(In the latter syntax template, the three dots are literally three periods that are typed into the
program.)
As the first syntax template shows, the try-catch statement consists of a try-clause
followed by one or more catch-clauses. The try-clause consists of the reserved word try and
a block (a pair of brackets { } enclosing any number of statements). Each catch-clause
consists of the reserved word catch, a single parameter declaration enclosed in parentheses,
and a block. Each catch-clause is, in fact, an exception handler.
When a statement or group of statements in a program might result in an exception, we
enclose them in a try-clause. For each type of exception that can be produced by the
statements, we write a catch-clause (exception handler). Here is an example of a try-catch
statement involving the three types of exceptions (int, string, and SalaryError ) discussed
previously with the throw statement:

Description
The try-catch statement is meant to sound like a coach telling a gymnast, “Go ahead and
try this flip; I’ll catch you if you fall.” In our case, we tell the computer to try executing some
operations that might fail, and then we provide code to catch the potential exceptions.
Execution of try-catch
Execution of the preceding try-catch statement works as follows. If none of the statements in
the try-clause throws an exception, control transfers to the statement following the entire try-
catch statement; that is, we try some statements, and if everything goes according to plan, we
just continue with the succeeding statements. However, if an exception is thrown by a
statement in the try-clause, control immediately transfers to the appropriate exception handler
(catch-clause). Note that control jumps directly from whatever statement caused the
exception to the exception handler. If there are statements in the try-clause following the one
that caused the exception, they are skipped. When control reaches the exception handler,
statements to deal with the exception are executed. If these statements do not cause any new
exceptions and do not transfer control elsewhere (as with a return statement), then control
passes to the next statement following the entire try-catch structure.
Formal Parameters in Exception Handlers
When an exception is thrown, how does the computer know which of several exception
handlers is appropriate? It looks at the data type of the formal parameter declared in each
handler and selects the first one whose data type matches that of the thrown exception. A
formal parameter consisting solely of an ellipsis (three dots or periods), as shown earlier in the
syntax template for FormalParameter, is a “wild card”—it matches any exception type.
Because the computer searches the exception handlers for a matching parameter in

sequential order, a final exception handler with an ellipsis parameter serves as a “catch-all”
handler for any exception whose type hasn’t been listed:
Description
Note that the sequential search for a matching parameter type requires us to place the catch-
all handler last. If we placed it first in the structure, it would trap every exception, and the
remaining handlers would be ignored.
Another issue related to formal parameters in exception handlers is this: Should the
parameter declaration include a name for the parameter? (If you look at the syntax template
for FormalParameter, you’ll see that the parameter’s data type is required but its name is
optional.) In fact, the parameter’s name is needed only if statements in the body of the
exception handler use that variable. In our earlier example of catching int, string, and
SalaryError exceptions, the parameter lists for the first and third exception handlers contain
data type names only. In contrast, the parameter list for the second handler specifies string s
because the body of that handler uses the statement
to output the message contained in s.
Finally, we must address a very important issue in the programming of exceptions: the data
types of the exceptions themselves. In our int, string, and SalaryError example, we used all
three exception types simply to demonstrate the possibilities and to show how exception
handlers are written. In practice, exceptions of built-in types (int, float, and so on) and even
of class string have limited usefulness. If a try-clause throws several exceptions of type int
with different integer values, then an exception handler receiving an int value becomes
complicated. It must include logic that tests the integer to determine exactly which kind of
error occurred. Furthermore, statements such as

are much less readable and self-documenting than statements such as
Consequently, it is a better idea to use only user-defined classes (or structs) as exception
types, defining one type for each kind of exception and using descriptive identifiers:
Description
With all of our example exception handlers, the parameter has been passed by value. This
approach is sufficient for any of the standard types, and for the simple user-defined exception
types that we use in this text. However, it is possible to develop exception classes that are
quite complex, passing a considerable amount of information to a handler. These classes
may also be part of an entire class hierarchy. In such cases, passing by reference will be
more efficient and will also avoid the slicing problems that can occur when a subclass of an
exception is passed up to a level where only a parent class is defined.3
Nonlocal Exception Handlers
In our discussion so far, we have assumed that a throw statement is physically located
within the try-catch statement that is intended to catch the exception. In that case, if the
exception is thrown, control transfers to the catch-clause with the corresponding data type.

FIGURE 16.1 Throwing an Exception to Be Caught by the Calling Code
Description
In C++ programs, it is actually more common for the throw to occur inside a function that is
called from within a try-clause, as shown with functions Func3 and Func4 in FIGURE 16.1. At
run time, the computer first looks for a catch within Func4. When it fails to find one, it causes
Func4 to return immediately and pass the exception back to its caller, Func3. The computer
then looks around the point where Func4 was called, finds an appropriate catch-clause, and
executes the catch. As you can see in Figure 16.1, the exception was thrown in Func4, but the
exception handler is nonlocal. (It is found in the calling function, Func3.)
Suppose that there was no matching catch-clause in Func3 in Figure 16.1. Then Func3 would
return immediately and pass the exception back to its caller, perhaps Func2. Each function
that doesn’t know how to deal with the problem passes the exception back to the previous
function. This sequence of returns continues back through the chain of function calls until
either a matching exception handler is found or control reaches main. If main fails to catch the
exception (a situation known as an uncaught exception), the system terminates the program
and displays a relatively unhelpful message like “Abnormal program termination.” FIGURE
16.2 illustrates this process.
Even if a throw statement is physically present in the try-clause of a try-catch, if there is no
matching exception handler in that try-catch statement, the result is the same as we have
just described—namely, the enclosing function returns immediately and passes the exception
back up the calling chain.
You may wonder why C++ programs typically use nonlocal exception handlers. The reason
lies at the very heart of exception handling, no matter which programming language is used.
The fundamental purpose of exceptions is to allow one part of a program to report an error to
another part of the program if the error cannot be handled locally.

FIGURE 16.2 Exception Handling Over Multiple Levels of Function Calls
Description
Rethrowing an Exception
We have been using throw statements of the following form:

The syntax template for the throw statement, presented earlier in this chapter, shows that we
use the word throw, followed optionally by an expression. Therefore, the throw expression
may be omitted, as in
This statement is used within an exception handler that has caught an exception and
performed some actions, and then wishes to pass the exception along to its caller (rethrow
the exception) for further processing. Here is an example:
Description
Rethrowing an exception is C++’s way of allowing partial exception handling. In the preceding
code, the catch-clause handles the BadData exception partially (by writing an error message to
the file and closing it) and then returns, rethrowing the exception up the chain of function calls
until it is caught.
What would happen in this code if we deleted the throw statement? What would happen if
we changed throw to return? An Exam Preparation exercise at the end of this chapter asks
you to consider these questions.
Standard Exceptions
Not all exceptions are defined by you as a C++ programmer. Several exception classes are
predefined in the C++ standard library and are thrown either by C++ operations or by code
that is supplied in standard library routines.
Exceptions Thrown by the Language

Certain C++ operations throw exceptions if errors occur during their execution. These
operations are new, dynamic_cast, typeid, and something called an exception specification.
The last three are not covered in this text; instead, we discuss only the new operator here.
In Chapter 14, we said that the new operator obtains a chunk of memory from the free store
(heap) and returns a pointer to (the address of) the beginning of that chunk. For example, the
code
creates a 1000-element int array on the free store and assigns the base address of the array
to intPtr. We also said that if the system has run out of space on the free store, execution of
new causes the program to terminate with an error message. Now that we know about
exceptions, we can describe more completely what happens. If the new operator finds that the
free store is exhausted, it throws an exception of type bad_alloc, a C++ class that is
predefined in the standard library. If this exception is not caught by any exception handler, then
—as with any uncaught exception—the program halts with a generic message such as
“Abnormal program termination.” Alternatively, our program could catch the exception and
take some corrective action (or at least display a more specific error message). For example,
we might write the following code in our main function:
Description
Notice the return statement in this exception handler. This statement will terminate the
program only if it is in the main function. If we want the preceding code to be located in some
other function, we must change the return statement to something else. For example, we
could rethrow the bad_alloc exception to a higher-level function or throw a new exception
(naming it, say, OutOfMem) for a higher-level function to catch.
Exceptions Thrown by Standard Library Routines
The C++ standard library is really two libraries: facilities inherited from the C language (called
the C library) and facilities designed specifically for C++. In general, header files beginning
with the letter “c”—cmath and cctype, for example—are found in the C library, and other header
files are specific to C++. The C library doesn’t throw exceptions. Instead, it uses a global

integer errno that is a nonzero value after an error occurs in a library routine. If you want to
check for an error, set errno to 0, call the library routine, and then check if errno is nonzero.
One option at that point is to throw your own exception.
The portion of the library that is specific to C++ defines exception classes and throws
exceptions. For example, the exception classes include out_of_range and length_error, both
of which can be thrown when working with strings. Let’s see how we might work with these
exceptions.
In Chapter 3, we examined the substring function str.substr(pos, len). We said then that if
pos is too large, the program terminates with an error message. What really happens is that an
out_of_range exception is thrown; if it isn’t caught, the program terminates with an error
message. The length_error exception is thrown if you try to construct a string whose length is
greater than string::npos. Now we know enough to catch these exceptions and handle them:
Description
Both of these exceptions are defined in the header file <stdexcept>, which must be included in
a program that uses them.
We’ve looked at just two library exception classes to give you a sense of how they work. A
full description of the C++ library could fill a book by itself, so we do not cover the others here.
You will want to check for information about exceptions in the library documentation as you
expand your use of its capabilities.

QUICK CHECK
16.4.1 What is an exception?
16.4.2 a. Write the declaration of a user-defined exception type named BadData.
b. Write a void function GetAge that prompts for and inputs the user’s age (type int)
from the keyboard. The function returns the user’s age through the parameter list
unless the input value is a negative number, in which case a BadData exception is
thrown.
16.4.3 Write a try-catch statement that calls the GetAge function of Question 16.4.2b.
If a BadData exception is thrown, output an error message and rethrow the exception
to a caller; otherwise, execution should just continue.
16.4.4 When are preconditions not enough to deal with an erroneous argument to a
function?
16.4.5 What is an exception handler?
16.4.6 What statement is used in a section of code to announce that an exceptional
condition occurred?
16.4.7 What is the formal parameter and how is it used in an exception handler
declaration?
SOFTWARE MAINTENANCE CASE STUDY Adding Exceptions
to the Date Class
When we were designing our Date class, we said that the year must start with the year
1582 or the date would be incorrect. Let’s redesign the Date class to check its input
parameters for the parameterized constructor and throw exceptions if the input values are
not within proper ranges.
There are three possible errors: The month is not between 1 and 12, the day is not within
the day-range of the month, and the year is before 1582. We will create an exception class
for each possibility. Let’s call them MonthError, DayError, and YearError:
Description
Within the code of the parameterized constructor, we must recognize and throw the
appropriate error. It is easy to recognize a month error and a year error, but how do we
recognize if a day is not within the month’s bounds? We could write a complicated If
statement for each of the possible month lengths, or we can define an array of 12 values,

representing the days in the month for that index. Let’s use the latter method. How do we
handle a leap year? We can use the leap year function we wrote in Chapter 1.
Here is class Date that includes the exception handling. The code related to the
exceptions is shaded.

Description

Description

Description
To test this enhanced class, we must try to instantiate an object of class Date with
values that are within the range and values that are not correct. Here is a test plan that
covers the possible errors:
Description

Description
Let’s set up a loop in the test driver to continue reading in dates until a negative month is
read. The attempt to instantiate a Date object must be within a try statement. This is fairly
complex; let’s write the algorithm first.
Here is the driver:

Description
Here is the output:
Description

Description

Description
Problem-Solving Case Study
AIRCRAFT WEIGHT AND BALANCE
PROBLEM: The company you work for has just added a new plane to its corporate
aircraft fleet. As with any airplane, it is essential that the pilot know the total weight of the
loaded plane at takeoff and its center of gravity. If the plane weighs too much, it won’t be
able to lift off. If the center of gravity is outside the limits established for the plane, it might
be impossible to control. Either situation could potentially lead to a crash. You have been
asked to write a program that determines the weight and center of gravity of this plane,
based on the number and weight of crew members, the number and weight of passengers
and their luggage, the weight of the closet contents, and the amount of fuel. The pilot will
use the output of this program to determine if it is safe to take off.
Here are the formulas for total weight and center of gravity:
BRAINSTORMING INITIAL CLASSES: The nouns in the problem provide a starting point
for the objects in the problem. Here is a list of them:
Company
Fleet
Aircraft
New plane
Center of gravity

Pilot
Weight of plane
Loaded plane
Number of crew members
Number of passengers
Crew member
Weight of crew member
Passenger
Weight of passenger
Weight of luggage
Closet
Fuel
Distance from front of plane
Names
Service desk
This is quite a daunting list. In fact, it contains objects with which we are not familiar, such
as “center of gravity” and “distance from front of plane.” Let’s filter this list and then go
back for more information.
FILTERING: The company and the fleet are not part of the solution. Aircraft and new plane
are the same object. The aircraft has a closet and fuel. These are not objects, but rather
numeric attributes of the aircraft. The pilot, crew member, and passenger are all people
with names, who have weight. Passengers have luggage, which has weight. The service
desk is the person in charge of the processing. We will also need a user interface to
represent the service desk.
Here is the filtered list:
Aircraft
Closet
Fuel
Luggage
List of people
Name
Weight
Role {CREW, PASSENGER}
Luggage
User interface
We usually write the CRC cards at this point, one for each object. However, we need to
look at center of gravity a little more closely before we are ready to do so, because we
may need more information. The center of gravity is the sum of each weight multiplied by

its distance from the front of the airplane divided by the total weight. A weight times its
distance from the front of the plane is called a moment arm or simply a moment.
Distance from the front of the plane? We need to know where each passenger is sitting,
where the closet is, and where the baggage is stored. We go back to the aircraft’s manual
and find the following table:
Description
The manual also tells us that the aircraft has several fuel tanks, which are found in
different places in the plane. As fuel is added, it automatically flows into different tanks so
that the center of gravity changes as the tanks are filled. There are four formulas for
computing the distance from the nose to the “center” of the fuel tanks, depending on how
much fuel is being loaded into the plane. The following table lists these distance formulas:

Description
Before we finalize the design, let’s do a scenario walk-through. We usually perform this
check later, after the classes are determined, but our current problem is quite complex and
we need to get a better feel for what is happening.
Let’s look at the problem from the perspective of what the gate agent does now. She
says she enters the closet weight and the amount of fuel. She then enters the crew
members’ names and weights. As the passengers arrive, she enters their names,
weights, and baggage weights, and assigns row numbers. When the passengers are all on
board, the gate agent calculates the weights and center of gravity. If the pilot approves
these figures, she prints out the names of all on board, with each person marked as either
crew or passenger. If the pilot does not approve the weights and center of gravity, the flight
is halted.
At first glance, there appear to be two distinct ways to continue this design. The first
option is to collect the data and store them into the classes we listed in our first
brainstorming pass. After all of the data are collected, the total weight and center of gravity
can be calculated. This strategy mirrors what the gate agent does.
On reflection, however, we see that the only data that need to be kept consist of the
names of those on board the aircraft. All of the other data can be processed as they are
input. Thus, the only attributes that we need are a running total of the weights and a running
total of the moments. This streamlining makes a much simpler design. We do, however,
need a user interface that will be responsible for inputting the data.
Aircraft
Weight
Moment
List of people
Role {'C', 'P'}
User interface
Now we are ready to create the CRC cards for the classes. The weight and moment are
just running sums. We have a Name class, so we do not need to make a CRC card for Name.
Role is a char attribute, not a class. Here is the CRC card for the People class, followed by
the specification file for the class.
People Class

Description
Description
The implementation of these functions is so straightforward that we can go directly to the
code.
Description

Description
Aircraft Class
Description
The class representing the plane is of prime importance. It keeps a list of crew and
passengers, a running total of weights, and a running total of moments. It returns the total
weight and center of gravity, and writes a list of people on board. We can use GList
(defined earlier in this chapter) to keep the list of People objects.
Are there any exceptions that might occur? Yes, the gate agent might assign more than
two people to a row. For the moment, we just throw an exception when this happens
(class RowOverflow). In addition, we need to throw an exception if the weight is too high
(class TooHeavy) and an exception if the center of gravity is not within bounds (class
CofGWrong).
Here is the specification file:

Description
We need two auxiliary arrays to help with the calculations. First, we need a
onedimensional array to hold the number of people assigned to each row. Let’s call it row
and initialize the values to 0. Second, we need a parallel array that holds the distance each
row is located from the front of the plane. Let’s call this array rowDistance.
We also need to define certain constants, such as weight of the empty plane, moment of
the empty plane, and weight of a gallon of fuel. We find these values in the plane’s manual.

Here, then, are the declarations that go in the front of the implementation file:
Description
The constructor needs to initialize weight to EMPTY_WEIGHT and moment to EMPTY_ MOMENT.
The algorithm GetTotalWeight returns the weight, and GetCenterOfGravity returns the
moment divided by the weight. SetClosetAndFuel is more complex, so we decide to write
the algorithm first, based on the fuel moments in the manual.
InsertCrew is a simpler version of InsertPassenger. WriteNamesOnBoard is an
algorithm that we have used many times before. Here, then, is the implementation file:

Description

Description
UserInterface Class

Description
Description
SCENARIOS: Before we write the implementation file for the UserInterface class, let’s
further examine these responsibilities by creating a scenario from the algorithms. The
UserInterface (gate agent) prompts for and reads the closetWgt and fuelWgt and sends
them as parameters to the Aircraft function SetClosetAndFuel. The gate agent enters
each crew member’s name and weight and passes them as parameters to the Aircraft
function InsertCrew. The passengers come up to the gate and give their names. They are
weighed, their luggage is weighed, and they are given a row number. Each passenger’s
information is sent to the plane, and each passenger is then allowed to board. When the
gate agent closes the gate, the total weight and center of gravity are accessed, output, and
tested. If these values are within the appropriate range, the names of those on board are
written to the file and the plane takes off. If the weight or the center of gravity is not within
limits, an exception is thrown and the plane remains at the gate.
Which brings us to some questions: What is the maximum weight over which the plane
can’t fly? What is the range of the center of gravity within which it is safe to fly? We go
back to the manuals and find that the plane is safe to fly if its weight is less than or equal to
14,440 pounds. The safe center-of-gravity range is between 307 and 321.
The task for each of these functions is quite straightforward. Here, then, is the
implementation file for class UserInterface.
Description

Description

Description
TESTING: We must now write a test driver that sets all this activity in motion. The driver
will need to prompt for and enter the number of crew members and the number of
passengers. The gate agent must be told to enter the closet and fuel, the crew, and the
passengers, and then to close the doors. All of these tasks must be done within a try-
catch structure. Recall that there are three possible exceptions: RowOverflow, TooHeavy, and
CofGWrong. Here we have the handlers in the main driver, which is shown next:
Description

Description
Here is the output from a run where all of the parameters are acceptable and no
exceptions are thrown:
Description

3 Hierarchies of exception classes also affect how we order catch clauses. An exception
superclass in a catch-clause matches any of its subclasses as well as itself. Thus, when a
try-catch is used to catch exceptions at different levels of an exception class hierarchy, the
catch-clauses should be ordered so that the lowest-level subclasses come first, and the top-
level class comes last.

Graphical User Interface (GUI)
In Chapter 15 we designed and implemented a user interface for an appointment calendar
application. The implementation consisted of a single class that was responsible for building
the entire user interface. Although that made it easier to see how the various pieces are
connected, it isn’t a very modular approach and will thus be more challenging to refactor for
changes in the future.
In this section, we see how to use object-oriented techniques to structure our code so that it
is more maintainable. We will create custom widgets that inherit from classes in the Qt
framework, which will represent the major components in the GUI. The GUI and the classes
that implement it will replace the UserInterface class in the Aircraft Weight and Balance case
study.
As was the case with the console-based application, we will be computing the total weight
and center of gravity of the aircraft. We need to build a flight manifest by recording passenger
and crew information and use that to determine if the aircraft load is flightworthy. We will
record the name, weight, and baggage weight of a passenger as well as which row number
they will sit in for the duration of the flight. In addition, we will record the name and weight of
each crew member, the weight being held in the closet compartment, and the total number of
gallons of fuel. All of this information will need GUI widgets for the flight staff to easily check in
passengers and crew. We will also want to take greater advantage of the capabilities of a GUI
by displaying the passengers, crew, and running total of the aircraft weight and center of
gravity as passengers are recorded in the system.
In FIGURE 16.3 we can see a basic sketch of the major GUI components. We use an entry
form at the top for passenger and crew information. This is followed by two tables to display
the passenger and crew manifest. Below that is a smaller form to enter the closet weight and
gallons of fuel. At the bottom is a message to display the total weight and center of gravity.
Each component in the figure will be implemented by a custom widget containing other
widgets such as labels, text boxes, tables, and buttons. These custom widgets will then be
combined into a window via a layout for rendering to the screen.

FIGURE 16.3 Major GUI Components
Description
We start with the passenger and crew manifest tables because they are the easiest widgets
to implement. The passenger manifest is implemented by the PassengerManifestWidget. Here
is its class specification:

Description
There are various base classes in the Qt framework that can be used to implement a
widget. We use QWidget because it is the most generic and the one you will encounter
frequently in other Qt-based applications. To use QWidget, we need to include the QtWidgets
header file. Although we could just include QWidget, the QtWidgets header file is convenient
because it gives us access to all of the Qt widgets rather than writing an #include for every
widget we need. It also gives us access to the Q_OBJECT macro.
The PassengerManifestWidget class has one public constructor and one method. The
constructor is passed a pointer to a QWidget object that represents the parent widget when we
instantiate this class. Because the QWidget base class constructor requires this parameter,
the child class must provide it as well. The reason for having a pointer to a parent widget is
beyond the scope of this text. However, it is worth mentioning that it is necessary for
rendering the GUI properly and for handling the delivery of events to registered event
handlers. The default value of this constructor parameter is nullptr, indicating that it has no
parent widget.
This class also defines the AddPassenger method with parameters that are expected for a
passenger including their first name, last name, seat row, body weight, and baggage weight.
The parameters will be used to populate a new row in a table to be rendered to the screen.
The table is implemented using a Qt-provided widget called QTableWidget. We also declare an
integer called rowCount that will keep track of the next table row index.
The implementation of this class starts by including the header file for the specification. This
is followed by the constructor:
Description

The constructor creates a label to identify this widget in the main window. The rowCount is
set to 0 because a newly constructed manifest is empty. We then create a new QTableWidget
object called table. We will set the table’s number of columns to four, so it can show the
passenger’s name, row, body weight, and baggage weight. We then set the row count of the
table to the current rowCount. To explain the table data, we include header labels above the
columns. A QStringList is simply a list of QString objects that some Qt widgets use to
maintain a list of strings.
With that done, we arrange the widgets in a vertical layout to be rendered. That is all that is
necessary to put together a custom widget in Qt. Not only can we use this widget in this
application, but it could be used in other widgets/windows that require a passenger manifest
component. For example, we could write a similar application for when a flight arrives, as part
of the deboarding process. Such an application may need a flight manifest in its user interface,
but otherwise be entirely different.
With the contained widgets in place, we can add passenger data:
Description
Description
The AddPassenger method creates a QString from each of its parameters using static class
methods for converting C++ strings and floats into QString objects. As we saw in Chapter 15,
QString is ubiquitous in the Qt framework. Adding a row to the table requires us to create a
QTableWidgetItem for each data item. Next, we insert a new empty row into the table at the

location specified by rowCount and add each of the table items in the corresponding column.
Lastly, we increment the row count. The crew manifest is defined and implemented by the
CrewManifestWidget and is very similar in nature, so we just show the code here without
explanation.
Description

Description
Another widget that is easy to define and implement is the component used to display the
total weight and center of gravity. Here is its definition:
Description

Description
The constructor is like the PassengerManifestWidget in that it takes a pointer to a QWidget as
its only parameter. This class has two private variables that we will use to display the total
weight and center of gravity, respectively. The two public methods with corresponding names
are used to set these variables. The implementation of this class is not surprising:
Description
You will notice that we use a grid layout for this widget so we can place identifying labels
beside the labels we are using to display the total weight and center of gravity. The methods
for setting the member variables convert each float parameter into a QString and set the text
of the corresponding label to be rendered to the screen.

The two remaining widgets are not as simple. You may have noticed that we have not yet
had to deal with any application state (the list of people) or events (clicking buttons). That is
because it is all taken care of by the form widgets. We need a form for entering passenger
and crew information and another for entering closet weight and fuel. We will look at the former
by first starting with a sketch of how we want the form to look. A basic design is illustrated in
FIGURE 16.4 with each of the form widgets in roughly the place we plan to add them to the
passenger/crew entry form.
All of the form widgets, except for the button at the bottom, have labels to their left
identifying the purpose of the widget to its right. The top four are text boxes. The next two are
drop-down boxes allowing the user to select from the options listed in the diagram. Lastly, we
have a single button for adding the information in the form to the state of the application and
the manifest tables for either the passengers or the crew.
We will also want certain form elements to be disabled depending on the passenger type. A
passenger requires that all information be entered into the form. A crew member, however,
has a preassigned place to sit, and if they have baggage, it will be in the closet. So, we need
to disable those form entry widgets if the drop-down for the passenger type is set to “Crew.”
Lastly, the form can’t be submitted unless all the required fields are non-empty.
The passenger form must communicate with other objects in this application. To add
passengers to the aircraft, it must access the Aircraft object. It also has to add passenger or
crew information to the manifest tables, requiring communication with both a
PassengerManifestWidget and a CrewManifestWidget. Lastly, after a passenger or crew member
is added to the aircraft, the total weight and center of gravity are updated in the Aircraft object
and need to be passed to a WeightAndCofGWidget to be displayed. The data connection to each
of these components is shown in FIGURE 16.5.
Description
FIGURE 16.4 Passenger/Crew Form Design

FIGURE 16.5 Passenger/Crew Entry Form Connections
Description
The specification for the PassengerFormWidget is shown here:

Description
Description
The member variables for the PassengerFormWidget include pointers for all of the widget
components we will be using. We have seen both QLineEdit and QLabel before. A QComboBox is
a widget provided by Qt for building a drop-down box. Here we use it for the seat row and

passenger type. Because we need to warn the user when a form is incomplete, we use a
QLabel for displaying informational messages. There are pointers to each of the custom-built
widgets we already discussed and a reference to an Aircraft object. All the components we
need to get information from or add information to are passed into the constructor as
parameters and will be initialized in its body.
There are also several private methods that we define to help handle the clicking of the Add
button. There are two for adding either a passenger or a crew member, two for validating the
form for each, and two for taking care of communicating the weight and center of gravity
values to the WeightAndCofGWidget. The last two method definitions are Qt slot methods that
will be invoked when either the Add button is clicked or the passenger type combo box is
changed. First, let’s look at the implementation of the constructor for this class:
Description

Description

Description
Although the constructor code is lengthy, it is rather straightforward and doesn’t contain
anything we haven’t already seen. The incoming parameters are used to initialize the
corresponding member variables in the initializer list. Then it creates the labels used in the
form, followed by the corresponding text boxes (QLineEdit), drop-down boxes (QComboBox),
and the Add button (QPushButton).
The items for the combo boxes are added using the addItem method. Next, we use a grid
layout to place each of the components in the correct row and column according to our design
sketch. We make the button and message two columns wide, using the extra span
parameters. Then we set the layout of the PassengerFormWidget. Lastly, we connect the
textActivated event that occurs when a new item in a combo box is selected with the
HandleComboBoxActivated event handler and the clicked event with the HandleAddButtonClicked
event handler.
The first event handler we’ll examine is responding to the passenger type combo box being
changed. When it is set to Crew, the UI must disable the baggage weight and seat row
sections of the form. Changing the combo box triggers a textActivated event, which calls the
connected event handler, passing it a QString corresponding to the content shown by the
selected item. In our HandleComboBoxActivated event handler, we compare the string to Crew,
and if it matches, we disable the baggage weight text box and the seat row drop-down;
otherwise, we make sure they are enabled.
To disable a widget, we call its setEnabled method with false as the argument. We can also
change the background color to lightgrey, using its setStyleSheet method, to visually tell the
user that those buttons are no longer enabled. Qt style sheets offer too many options for
customizing the appearance of widgets for us to cover them all in this text. We merely give
one simple example here to whet your appetite for learning more from the Qt documentation.
If the selected item is not Crew, we enable both widgets and set their background color to
white, signifying that they are enabled and accepting input. Here is the code for this event
handler:

Description
Before we discuss event handling for the Add button, we will quickly introduce a set of utility
methods that are part of its implementation. Because we must ensure that the user filled the
required form entries, we create two validation methods: IsValidPassenger and IsValidCrew.
These two methods return true if the form is valid for the particular passenger type, and false
otherwise. The information in the form should only be recorded when they return true. There
are other checks that should be done, such as dealing with improperly formatted or out-of-
range weight values. We leave that as an exercise for the reader, and note that redesigning
the form to use a QSpinBox picker would simply avoid the possibility of erroneous input.
The other two utility methods check that the weight and center of gravity of the current
passenger and crew manifest are valid. The CheckWeightOfAircraft method displays a
message to the user if the weight of the aircraft is larger than 14,440. The CheckCofGOfAircraft
method notifies the user if the center of gravity is outside an acceptable range for a safe flight.
Both methods disable the entire passenger entry form if either is true. A fully featured
application would allow the user to undo the addition of the passenger or crew. The current
design requires the user to restart the application. The implementation of these four utility
methods is shown here:
Description

Description
The event handler for clicking the Add button first checks whether the data in the form are
for a passenger or a crew member. If they are for a passenger, it calls the
HandleAddingPassenger method to add the passenger to the flight and update the displayed
manifest table for passengers. If the data are for a crew member, it calls the HandleAddingCrew
method to add the crew and update the manifest. We see their implementations shortly. It then
displays the total weight and center of gravity in the WeightAndCofGWidget using its
SetTotalWeight and SetCofG methods. To prepare for a new entry, it clears the text boxes and
resets the seat row to the first index of the combo box (which is row 0). Lastly, it calls the
utility methods to check weight and center of gravity to see if any limits have been exceeded.
The code is as follows:

Description
Description
The job of the HandleAddingPassenger method is to take the data from the form, validate
them, and add the passenger to the aircraft and passenger manifest table. It validates the
form data using the IsValidPassenger method. If the data aren’t valid, it displays a message
and returns without making any changes; otherwise, it converts the form data from QString
objects into C++ standard types, inserts a new passenger by calling the InsertPassenger
method of the Aircraft object, and adds the passenger to the manifest by calling the
AddPassenger method of the PassengerManifestWidget object. If an exception is thrown by
InsertPassenger, it is caught and the user is informed by an appropriate message, as shown
in the following code:

Description
Description
The HandleAddingCrew method is a simpler version of the method above. The following code
is self-explanatory.

Description
The last widget we consider is the closet weight and fuel entry form, implemented by the
ClosetWeightAndFuelFormWidget class. This widget is separate from the other forms because
its values are independent of the crew and passengers. The form just provides text boxes for
entering the weight of whatever is in the aircraft closet and the gallons of fuel. It then adds
these values to the Aircraft object and displays the new weight and center of gravity. The
parts of the GUI this widget interacts with can be seen in FIGURE 16.6. This widget is special
in that the user can only enter the closet weight and fuel once. A more complete application
would allow us to change these values and recalculate the total weight and center of gravity if
adjustments were made before takeoff. Our goal here is to see the common design pattern of
a GUI widget that disables itself after data are entered.
The class specification for this widget is like those we have seen before. It inherits QWidget
and defines its constructor to take a pointer to the parent QWidget or default to nullptr if there
isn’t one. The constructor also receives a reference to an Aircraft object and a pointer to the
WeightAndCofGWidget so it can interact with those components. It defines private member
variables to hold the values of the constructor parameters and three widgets: two text boxes
for the closet weight and fuel, a button to enter these values, and the WeightAndCofGWidget to
update its values. Lastly, it defines an event handler method to handle the click of the button.
Here is the code for this class specification:

FIGURE 16.6 Closet Weight/Fuel Entry Form Connections
Description

Description
The implementation of this widget follows the same pattern we have seen in our previous
widgets. The constructor creates the internal widgets, adds them to a layout, and sets the
layout for the widget. The event handler is connected with the button’s clicked event, and the
event handler is implemented to respond when the button is clicked. The code for both the
constructor and the event handler are shown here:

Description
The HandleButtonClick event handler method gets values from the text boxes and calls the
SetClosetAndFuel method of the aircraft object. It then updates the values shown in the
WeightAndCofGWidget object. Lastly, the call setEnabled(false) disables this widget entirely, so
the user is unable to enter the closet weight and fuel again.

Now that we have covered all the necessary widgets and their connections, we can
combine them into a Qt window to display the GUI according to our sketch at the beginning of
this section. The class specification for AircraftMainWindow is just its constructor, so we will
not show the code here. Instead, we focus on its implementation:
Description
The constructor for the AircraftMainWindow class is passed an Aircraft object as an
argument. It creates each of the GUI components we discussed previously, passing other
widgets into their constructors as needed for them to communicate. It then creates a main
widget to hold the major widgets within a layout. We use a QVBoxLayout to arrange the major
widgets vertically.
Qt automatically resizes windows and widgets to accommodate their contents, so when a
user interface starts out empty, it can appear uncomfortably small. To avoid that, we must set
a minimum size for the window. In this case, some experimentation showed that 500 x 500
pixels results in both manifest tables displaying nicely when the application is first rendered to
the screen. Lastly, the constructor sets the central widget of the window.

The following code is the main routine used to instantiate the GUI:
Description
Here is how the GUI appears after adding a few passengers, crew, closet weight, and fuel:

Description

Testing and Debugging
When working with templates, it’s important to remember that a generated template function
or template class becomes an ordinary function or class and is subject to all the usual rules of
syntax and semantics.
To test a template function or template class, one approach is to start with a nontemplate
version, using a specific data type such as int. Apply the usual testing strategies we have
outlined in previous chapters for algorithms and classes. After all errors have been corrected,
convert the function or class into a templatized form, and continue testing by supplying
different data types as template arguments.
Another approach is to begin with the templatized class, but specialize it initially to a type
that you are confident is correct, such as int or string. It can be very frustrating to try to find
a bug in a template when it is actually in a class that is specified in its type argument. Once
you are confident that the template works for a reliable type, then test it for a range of classes
that you anticipate using.
A program that handles exceptions must be tested to ensure that the exceptions are
generated appropriately and then handled properly. Test cases must be included to cause
exceptions to be thrown and to specify the expected results from handling them.
The Problem-Solving Case Study program has three exceptions:
1. More than two people are assigned to a row.
2. The loaded plane is too heavy to take off.
3. The center of gravity is outside the acceptable limits.
At least four runs would be required to test these three cases: (1) Three people would be
assigned to a row; (2) the plane would be too heavy; (3) the center of gravity would be too low;
and (4) the center of gravity would be too high. You are asked to create test data for these four
cases in the Case Study Follow-Up exercises.
Testing and Debugging Hints
1. When declaring a template parameter, as in
remember to use the word class (or typename). However, the template argument used
when instantiating a template is not required to be the name of a C++ class. Any data
type, built in or user defined, is allowed.
2. In the restricted form discussed in this text, template arguments are data type names, not
variable names or expressions.
3. Template functions are usually called with implicit template arguments, but template
classes must use explicit template arguments.

4. Just as with nontemplate functions, if template function definitions are physically placed
after the code that calls the functions, then function prototypes (forward declarations)
must precede the calling code.
5. With template classes, the member function definitions must be compiled together with
the client code, not independently. One strategy is to group the class template and the
member function definitions into a single file (the .h file). Another strategy is to place the
class template into a .h file and the member function definitions into a .cpp file, with the .h
file including the .cpp file. In the latter approach, if you are using an IDE, do not list this
.cpp file in your “project.” Instead, include only the client code file in the project.
6. Avoid using built-in types as exception types. Throw objects of a user-defined class or
struct whose name suggests the nature of the error or exceptional event.
7. If BadData is the name of an exception class, be sure to throw an object of that class by
writing
rather than
8. Make sure that all exceptions are caught. An uncaught exception results in program
termination with a vague error message. It is best practice to catch exceptions at the
point nearest to their source where they can be properly handled.

Summary
C++ templates are a powerful and convenient mechanism for implementing generic data
types and algorithms. With a class template, we can define an entire family of class types
that differ only in terms of the data types of their internal data representations. With a
function template, we can define an entire family of functions that are the same except for
the data types of the items they manipulate.
A template is instantiated by placing the template argument in angle brackets next to the
name of the class or function. In the examples shown in this chapter, a template argument
is the name of a data type, not the name of a variable or expression. The compiler then
generates a new function or class by substituting the template argument for the template
parameter wherever the parameter appears in the template. With template classes, the
template argument must be explicit for the compiler to instantiate the template. With
template functions, the template argument is usually omitted, and the compiler deduces
the template argument by examining the function’s argument list.
Nearly all of the C++ operators can be overloaded. This goal is achieved by defining a
function called “operator,” followed by the symbol to be overloaded. When the symbol is
used between two instances of the class for which the symbol has been overloaded, the
operator function is called.
An exception is an unusual event that requires special processing. The primary purpose
of exception handling is to allow one part of a program to report an error to another part of
the program if the error cannot be handled locally. C++ supports exception handling by
means of the throw and try-catch statements. A section of code that detects an error uses
the throw statement to throw an exception, which is an object of some data type—usually
a class. The thrown exception is then caught by an enclosing try-catch statement that has
a catch-clause (exception handler) with a parameter whose type matches that of the
exception. If no matching exception handler is found, the enclosing function immediately
returns and passes the exception up to its calling function. This process continues up the
call chain until either a matching exception handler is found or control reaches the main
function. If main does not catch the exception, then the program terminates with an error
message.

Quick Check Answers
16.1.1 Generic ADT.
Description
Description

Description
Description
16.1.5 A type for which the operations are defined but the data types of the items
being manipulated are not. 16.1.6 A C++ language construct that allows the compiler
to generate multiple versions of a class through the use of parameterized data types.
16.1.7 (1) Once the List ADT is compiled for a specific item type X (e.g., int), a client
program can only use lists of that type X; (2) A client program cannot change the item
type X. 16.1.8 A specialization of the template class. 16.1.9 The reference parameter
is specified as being constant.

Description
16.2.3 An algorithm in which the actions or steps are defined but the data types of the
items being manipulated are not. 16.2.4 The use of the same name for different
functions, distinguished from each other by their parameter lists. 16.2.5 It allows
functions that perform the same action on different parameter types to have the same
name. 16.2.6 Function overloading can be improved by using a function template.
16.3.2 It can lead to algorithms that are specified in a natural and compact syntax for
a particular context (e.g., matrix multiplication). 16.3.3 Overuse of operator
overloading can lead to confusing code where it appears that expressions are
manipulating built-in types when they are actually operating on user-defined types.
16.4.1 An unusual, often unpredictable event that requires special processing.
Description

Description
16.4.4 When an argument is unpredictable. 16.4.5 An exception handler is a section of
program code that is executed when a particular exception occurs. 16.4.6 The throw
statement. 16.4.7 The formal parameter is the exact type of an exception that was
thrown and is used to determine which exception handler to execute.

Exam Preparation Exercises
16.1 In C++, two (nontemplate) functions can have the same name. True or false?
16.2 In C++, two (nontemplate) classes can have the same name. True or false?
16.3 Is the following a function template, a template function, or neither?
Description
16.4 In the statement
Group<char> oneGroup;
a. Is Group<char> a class template, a template class, or neither?
b. Is oneGroup a class template, a template class, or neither?
16.5 Define the following terms:
a. instantiate (a template)
b. specialization (of a template)
c. template parameter
d. user-defined specialization (of a template)
e. template argument
16.6 Consider this function call:
DoThis<float>(3.85)
a. Which item is the template argument?
b. Which item is the function argument?
c. Could the call be written as DoThis(3.85)?
16.7 Which C++ control structure should you use if you think an operation might throw
an exception?
16.8 Which C++ statement raises an exception?
16.9 Which part of the try-catch statement must be written with a formal parameter?
16.10 Mark the following statements as true or false. If a statement is false, explain
why.

a. There can be only one catch-clause for each try-catch statement.
b. A catch-clause is an exception handler.
c. A throw statement must be located within a try-clause.
16.11 In the WriteToFile function of Section 16.4:
a. What would happen if we deleted the throw statement in the exception handler?
b. What would happen if we changed throw to return?
16.12 Consider the division-by-zero program at the end of Section 16.4. How would
you change the main function so that the program terminates if a denominator is found
to be 0?
16.13 What happens if you call a function that throws an exception, without placing the
call in a try-clause?
16.14 What does the following statement do if it is written within an exception handler?
throw;
16.15 Which type of exception would be written as the parameter of a catch-clause if
the try-clause is calling new and we want to check whether the free store has run out
of space?
16.16 What do you call the following function?

Programming Warm-Up Exercises
16.1 Write a function template for a void function that squares and outputs the value
passed to its parameter. The type of the parameter is the template type.
16.2 Write statements that call the function in Exercise 16.1 for values of type int,
long, and float.
16.3 Write a user specialization of the function in Exercise 16.1 that accepts a string
argument and “squares” it by outputting it twice with no intervening spaces.
16.4 We would like to have a value-returning function that returns twice the value of its
incoming parameter.
a. Using function overloading, write two C++ function definitions for such a function:
one with an int parameter and one with a float parameter.
b. Write calling code that makes calls to both functions.
16.5 Write a function template for a function that returns the sum of all the elements in
a onedimensional array. The array elements can be of any simple numeric type, and
the function has two parameters: the base address of the array and the number of
elements in the array.
16.6 Write a function template for a void function, GetData, that receives a string
through the parameter list, uses that string to prompt the user for input, reads a value
from the console, and returns that value (as a reference parameter) through the
parameter list. The data type of the input value can be any type for which the >>
operator is defined.
16.7 Assume you have the following enumeration type:
Write a user-defined specialization of the GetData template (see Exercise 16.6) that
accommodates the AutoType type. For input, the user should type the character s for
sedan, c for coupe, and o (or anything else) otherwise.
16.8 Consider the GList class template of Section 16.1.
a. Write client code to instantiate the template twice, creating a list of ints and a list of
floats.
b. Assume that at some point in the client code the list of ints already contains values
known to be in the range 10 through 80 and the list of floats is empty. Write client
code that empties the list of ints as follows: As each item is removed from the list
of ints, multiply it by 0.5 and insert the result into the list of floats.

16.9 Write a MixedPair class template that is similar to the OrdPair template of Quick
Check Question 16.1.2 except that the pair of items can be of two different data types.
Hint: Begin the template with
16.10 Given the MixedPair class template of Exercise 16.9, write client code that
creates two class objects representing the pairs (5, 29.48) and (“Book”, 36).
16.11 Given the MixedPair class template of Exercise 16.9, write function definitions
for the class member functions.
16.12
a. Declare a user-defined exception class named MathError.
b. Write a statement that throws an exception of type MathError.
16.13 Write a try-catch statement—assumed to be in the main function—that
attempts to concatenate two string objects, but outputs an error message and
terminates the program if an exception is thrown. You may wish to review Section
16.4 to see which exceptions are thrown by the string class.
16.14 Write a Sum function that returns the sum of its two nonnegative int parameters
unless the sum would exceed INT_MAX, in which case it throws an exception. (Caution:
You cannot check for overflow after adding the numbers. On most machines, integer
overflow results in a change of sign, but you should not write code that depends on
this fact.)
16.15 Write a try-catch statement that calls the Sum function of Exercise 16.14 and, if
an exception is thrown, outputs an error message and rethrows the exception to a
caller.
16.16 Make the changes described in this chapter to the GList class and Temperatures
program so that Temperatures can instantiate a GList of any size. Test the change by
experimenting with different sizes of GList for a given input file to see which size is
necessary to accommodate all of the different temperature values.
16.17 The Date class in Section 16.3 overloads the <, > , and == operators. Add
functions to this class that overload the <=, >=, and != operators as well. You can code
these modifications very compactly by using *this.

Programming Problems
16.1 Imagine you are working for an in-house software team for a company that
wants to monitor network access points in a building. Each building has a specified
number of floors, a certain number of rooms per floor, and some number of network
access points in a room. Each network access point is labeled with its state as being
on or off; if it is on, it has the month it was turned on. Design, implement, and test
classes that represent buildings, floors, and network access points. Your classes
should provide suitable observer methods that allow you to determine how many
floors are in a building, how many rooms are on a floor, how many access points are
in a room, and if an access point is on or off and which month it was turned on. You
should also provide mutator methods that allow you to turn a network access point on
or off and to set the month if it is turned on. You should use composition as a key
strategy in designing these classes—thus, a building should contain floors, floors
should contain rooms, and rooms should contain network access points. Your
program should allow a user to add floors, rooms, and access points as well as turn
access points on and off. Your program should also report errors using exceptions if a
room, floor, or access point is chosen that does not exist.
16.2 A software company that develops games has just hired you! Before working on
the next version of Medieval Menace they have given you the task of implementing
tic-tac-toe in C++. Tic-tac-toe consists of a 3 x 3 game board of squares where each
square either is empty, has an X marker, or has an O marker. Two players
represented by an X or an O play the game. The objective is for one player to get
three X’s or three O’s in a row first. Design, implement, and test classes that
represent a tic-tac-toe game board and X and O markers. Your classes should
provide suitable observer and mutator methods for modifying the game board and
displaying the state of the game. Use your classes to create a game that prompts for
player X and player O to place markers at specified locations on the game board.
After each move, your program should display the current game board to the console.
Your program should also check after each move if there is a winning configuration of
the game board and use exceptions if an invalid board location (such as already full)
is chosen. If there is a winning configuration, the game should indicate which player
won.
16.3 Write a simple calculator program that allows a user to indicate simple arithmetic
operations from the console. Your calculator should support at least addition,
subtraction, multiplication, and division. The calculator should keep a running total

after each operation and use exceptions to handle erroneous input such as division by
0. You can also introduce other constraints on the running total such as restricting the
total by some maximum and minimum value. Here is an example of a typical
interaction:
Description
16.4 Programming Problem 7.1 asked you to output the ICAO word corresponding to
each letter in a word. Change the function that converts a letter to the matching word
so that it throws an exception if the letter is not in the alphabet, and add an exception
handler to the program that outputs “Invalid letter” and the offending letter whenever
the exception is thrown.
16.5 Programming Problem 7.2 asked you to compute a person’s weight on a
specified planet. Rewrite that program so that an erroneous planet name results in an
exception being thrown by the input routine and caught by the caller.
16.6 Programming Problem 11.3 asked you to write a simple database program for an
art gallery. The problem required that a user be able to search the database using any
of the values in a record for an artwork. Rewrite the program using a template for the
equality test function so that a single search function can be used for the different
types of values in the database.
16.7 You’re working for an observatory that keeps a database of stars. The most
prominent stars are indexed by name (a string); less prominent stars are indexed by
the name of the constellation in which they are found and a sequentially assigned
number (an int); and the least prominent stars are indexed by coordinates consisting
of two floating-point numbers. Each star record also contains a measurement of the
star’s brightness, called its magnitude (a float), and a letter indicating its color (a
char). Write a C++ program that reads the star data from three files (named.dat,
numbered.dat, and coord.dat) and places all of the data into a single list. The program

should then allow the user to retrieve the data for any star using the different kinds of
indexes. Use templates to simplify the coding of this application.
16.8 Programming Problem 7.5 asked you to write a program to input a time in
numeric form and output it in English. Rewrite the program to check for entry of
erroneous times in the input function, and throw an exception that is handled by the
caller.

Case Study Follow-Up
1. Complete the test plan for the Problem-Solving Case Study such that the three
exceptions are called as specified in the Testing and Debugging section.
2. Catch the RowOverflow exception in the Aircraft class. If a row is full, find a seat in
another row and put the passenger there. Continue with the processing. Note that if
one person is moved, another row may then be full. Thus passengers may be shifting
out of their assigned row, but as long as there are only eight passengers, all will find a
seat. (Hint: You will have to put a try statement in InsertPassenger.)
3. Consider the exception TooHeavy. Is there any reasonable action that the program
could take to solve the situation rather than causing the plane to not fly? Discuss your
answer.
4. Consider the exception CofGWrong. Is there any reasonable action that the program
could take to solve the situation rather than causing the plane to not fly? Discuss your
answer.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 7
Introduction to Data
Structures Using the
Standard Template
Library
KNOWLEDGE GOALS
To appreciate the distinction between the Standard Template Library (STL) and data
structures in the abstract sense.
To understand the operation of stacks, queues, and deques.
To understand the set and map as abstract data types.
To be aware of the structure and operations associated with tree and hash table
abstract types.
SKILL GOALS
To be able to:
Instantiate and use specializations of STL templates.
Work with STL iterators.
Apply STL algorithms to STL data structures.
Use the basic STL sequence containers: vector, list, and deque.
Use the STL sequence container adapters: stack and queue.
Use the associative STL containers: set and map.

In Chapter 10, we began our exploration of user-defined data types. In Chapter 11, we
introduced the array. Chapters 13 and 14 focused on the list data structure to illustrate how
data can be organized in the abstract sense and for recognizing how an ADT can have
different implementations that offer advantages under different circumstances. We are now
ready to survey a broader range of ways to organize data.
Most computer science curricula include one or more complete courses on data structures,
their related algorithms, and efficient implementation techniques. In this chapter, we can
merely whet your appetite for those more advanced studies by giving you a preview of what’s
to come.
That doesn’t mean, however, that we cannot delve into some practical uses of these more
advanced structuring techniques. The C++ library provides a wealth of existing
implementations of generic structured types, which we can use directly. In fact, the Standard
Template Library (STL) is so rich that entire books have been devoted to explaining the
subtleties of its operation! In this chapter, we consider the most commonly used STL types.

17.1 Abstract Data Structures Versus Implementations
By this point you are quite familiar with the array and list data structures. Both of them belong
to the family of linear data structures because their components can be arranged in a
sequence from one end to the other. The array is sequenced by its index values, and the list
is sequenced by the logical relationship between each node and the nodes that immediately
precede or follow it, as shown in FIGURE 17.1. As you know, lists may be implemented either
with arrays or via pointers (linked lists).
FIGURE 17.1 The Array and List as Linear Structures
Description
With a little thought, you should also appreciate that we could implement the abstract idea of
the array using a linked list. Under normal circumstances, a linked implementation of an array
would be inefficient. When an array with a large index range is sparsely filled with values,
however, a linked implementation can save a lot of space. As an example, imagine that a
wildlife biologist is plotting the location of geese on a lake using GPS coordinates received
from the geese’s tracking collars. The natural representation of these data is with a two-
dimensional array indexed by the coordinates, with each element representing the number of
geese in that area of the lake. Of course, when there are only a few geese, an array
implementation wastes memory space, which can be saved by switching to a linked
implementation, as shown in FIGURE 17.2.

FIGURE 17.2 A Linked Implementation of a Sparsely Filled Array Conserves Space
Description
The key idea is that every data structure has two aspects: its abstract (conceptual) form
and its implementation. Through the control and data abstraction supported in object-oriented
programming, it is possible to entirely divorce these aspects from each other. The advantage
is that client code can use a representation that is easy to understand, while obtaining the
benefits of an efficient underlying implementation.
As we proceed through this chapter, you might have thoughts such as, “But a stack is just
a restricted kind of list. Why do we need it as a separate type?” We all fall into this trap of
mixing abstract representation with implementation. As you’ll see when we demonstrate the
use of the stack, a simpler abstract type can make coding a solution easier than using a more
general abstraction in a restricted way. The stack abstraction also allows the implementor to
choose either a list-based or an array-based implementation.
Something else to keep in mind is that any implementation of a data structure is
representing a corresponding ADT. For example, a list class has an interface that represents
a list ADT. Because of this, when we look at a library of implementations such as the STL, it is
tempting to automatically use the provided list type to implement the abstract list in a
problem. But what if the problem requirements specify that the list is built from file data at the
start of the run, with few subsequent deletions and additions? That argues for an array-based
implementation.
The problem-solving strategy we use with data structures is as follows. In the problem-
solving phase, we design the structure and interface that most naturally solve the problem. In
the implementation phase, we consider how the structure will be used and which kind of
structure actually provides the most efficient solution. Next we define a class that wraps the

implementation structure with an interface for the abstract type. Lastly, we go to the library to
see if it provides a suitable data structure implementation that can be used within the class.
Having just spelled out this strategy, we need to note that many of the goals of this chapter
involve demonstrating the use of the STL. It’s much easier to see how an STL type works
without wrapping it in an interface for a different type. So be forewarned that our examples
aren’t necessarily meant to illustrate this approach: This is definitely a case of “Do as we say,
not as we do!”
QUICK CHECK
17.1.1 Why would you choose one data structure in the problem-solving phase and
then implement it with a different structure?
17.1.2 Every data structure has two aspects. What are they?

17.2 Additional Linear Structures
Outside of the context of a specific problem, it’s difficult to imagine a linear data structure
that’s not conceptually an array or a list—so let’s consider an example. Do shopping carts at
the supermarket wear out evenly? You’ve seen them arranged in neat columns, with people
taking them from the back and clerks wheeling them into place. But do the ones at the front of
the column ever get used? Are they rearranged enough so that all carts get the same amount
of wear? Other than curiosity, understanding how carts are used can help a supermarket
decide how many to buy or whether to rearrange the carts periodically.
Solving such a problem involves simulation. We can model the carts in their columns and
the time they spend roaming the aisles, and record how much total time of use each one
acquires. The speed of the computer enables us to evaluate years of use in a matter of
seconds.
Which data structures should we use to represent this situation? Given what we’ve seen so
far, an array could model a column of carts. When a simulated customer arrives, we remove
a cart from the back of the column. Then what do we do with it? We can randomly assign it a
return time and put it into a sorted list. As each minute passes, we check the list to see if the
cart at the head of the list is ready to be returned. Then we remove it from the list and place it
at the back of the column array. FIGURE 17.3 shows this arrangement.

FIGURE 17.3 Using an Array and a Sorted List to Simulate Shopping Carts
Description
Let’s consider these structures more closely. Do we need all of their capabilities to solve our
problem? Not really. For example, we won’t index into the array in random locations; instead,
we merely add and delete elements from one end of the array. In computer science, such a
structure is called a stack. What about the list? Do we ever traverse it, or delete elements
from the middle? No, we just insert elements into place and remove them from one end. This
structure, which is called a priority queue (pronounced like the letter “Q”), is one member of a
broader family of queue data structures.
At this point, you should start to see that differences in linear data structures are based on
how they are accessed. Arrays and lists support very general access. If access is restricted
in some way, however, we can define a data structure with a simpler interface. Also, in some
cases, the restrictions permit us to create a more efficient implementation.
Let’s take a closer look at stacks and queues.
Stacks

A stack is a data structure that can be accessed from only one end. We can insert an
element at the top (as the first element) and we can remove the top (first) element. This
structure models a property commonly encountered in real life. Accountants call it LIFO,
which stands for “last in, first out.” The plate holder in a cafeteria has this property. You can
take only the top plate. When you do, the one below it rises to the top so the next person can
take a plate. Cars in a noncircular driveway exhibit this property: The last car in must be the
first car out.
Stack A data structure in which insertions and deletions can be made from only one end.
The term push is used for the insertion operation, and the term pop is used for the deletion
operation. In some implementations of a stack, pop also returns the top element. In other
implementations, a separate operation, top, retrieves the top value and pop simply deletes it.
FIGURE 17.4 shows what happens when you push an element on a given stack and then pop
the stack.
Stacks are used frequently in systems software. For example, C++ uses a stack at run
time to keep track of nested method calls. The compiler uses a stack to translate arithmetic
expressions. Stacks can be used to recall a sequence of objects or actions in the reverse
order. An algorithm to read a file containing a series of lines and output the lines out in reverse
order, using a stack of strings, is shown here:
FIGURE 17.4 A Stack Showing Push, Top, and Pop Operations

Description
Reverse File
Create stack
Create file in
while in
     stack.push(in.getline)
while not stack.empty
     output stack.top
     stack.pop
As you can see from this algorithm, in addition to push, pop, and top, we need a way to test
whether the stack is empty. We may also want a way to find the size of a stack. Even with
those additions, the stack interface has only five responsibilities, making it a very simple
abstract type.
Queues
A queue is a linear data structure in which elements are entered at one end and removed
from the other end. Accountants call this property FIFO, which stands for “first in, first out.” A
waiting line in a bank or supermarket and a line of cars on a one-way street are types of
queues.1 Indeed, queues are often used in computer simulations of similar situations.
Queue A data structure in which insertions are made at one end and deletions are made at
the other.
Whereas the terminology for the insert and remove responsibilities on stacks is standard
(push, pop), no such standardization exists with queues. The operation of inserting an element
at the rear of the queue has many names in the literature: Insert, add, push, and enqueue are
four common ones. Correspondingly, the operation for removing from the front of the queue is
variously called delete, remove, pop, and dequeue.
C++ uses stack terminology for queues, where push applies to the back of the structure and
pop applies to the front. In place of top, the operation front returns the element at the head of
the queue. As with the stack, we need operations to check for an empty queue and to
determine its size. The C++ implementation of a queue is atypical in that one more operation,
back, returns the element at the rear of the queue. FIGURE 17.5 shows an empty queue (a),
insertion into a queue (b), and deletion from a queue (c).
FIGURE 17.5 A Queue Showing Insertion and Deletion Operations

Description
Priority Queues
As we said in our shopping cart problem, a priority queue is a member of the queue family of
structures. It behaves like a queue in that data are removed only from its front. Instead of
inserting elements at the rear, however, elements are inserted so that they are in a given
order, as shown in FIGURE 17.6. For example, passengers boarding an airplane may be
called to line up in order of their seat assignments. Schoolchildren preparing to have their
portraits taken may be told to line up in alphabetical order. In each case, the people enter the
line at whatever point puts them in the proper order, but they leave the line only at the front.
Priority queue A data structure in which insertions are made according to a specified
ordering and deletions are made at one end.
FIGURE 17.6 A Priority Queue, ADT Showing Insertion and Removal Points
Description
1 The word queue originates from French but is in widespread use around the globe. For
example, where Americans would ask people to “line up,” the British would ask them to
“queue up.”
a. An empty queue
b. Insertion into a queue

c. Deletion from a queue
As with queues, there is no standard terminology for priority queue responsibilities. C++
simply uses the stack terminology: push, pop, top, empty, and size. As a result, it is important
to be careful in naming stack and priority queue objects so it’s easy to tell what kind of object
each one is. We can’t rely on the operation names to help us identify the data type.
Here we should reiterate a key point made in Section 17.1: Data structures have a
conceptual structure and an implementation structure, which may differ. We have just
described the priority queue from the conceptual perspective. The STL typically uses a more
complex and more efficient structure to implement the priority queue. As we describe other
data structures in this chapter, keep in mind that we are looking at their conceptual
arrangement. Except for a few cases, we do not describe how the STL implements them.
QUICK CHECK
17.2.1 What are the two basic operations on a stack?
17.2.2 Is a queue a LIFO structure or a FIFO structure?
17.2.3 What aspect of linear data structures dictates their differences?
17.2.4 What benefit arises when a data structure requires restricted access?
17.2.5 Describe how a priority queue could be used to implement software for a
garage that performs an oil change on cars that are dropped off and given a specific
pickup time.

17.3 Bidirectional Linear Structures
Like the linked lists discussed in Chapter 14, queues are unidirectional structures. We
traverse our lists from front to back. Elements in queues move from back to front. Even
though elements in a stack move down and up, they can be implemented by links that point in
one direction.
Bidirectional Lists
When we want a structure that can be traversed in either direction, an array is a natural
choice. But when insertions and deletions in the middle are common and random access is
not as important, the array is no longer appropriate. Instead, we want a structure known as a
bidirectional list.
Bidirectional list A list data structure in which traversals can be made in either direction.
In a linked implementation of the bidirectional list, we augment our list nodes with a second
link that points in the opposite direction. We keep external references to the front and the back
of the list, and we can step through the nodes by going either forward or backward, as shown
in FIGURE 17.7.
FIGURE 17.7 A Bidirectional Linked List
Description
With this structure, every insertion and every deletion requires twice as many pointer
operations, and the nodes have twice as much space allocated to pointer members, so there
is an overall loss of efficiency. Thus, even though the bidirectional list is a more general
structure with many attractive capabilities, it should be used only when we need its extra
features. Just as you wouldn’t trim your houseplants with a chainsaw, similarly there are
many places where a bidirectional linked list is overkill. Having said that, be aware that the
STL provides only a bidirectional implementation of the list ADT. Instead of a unidirectional list,
it provides similar functionality with the set type, which has a much different implementation
that we describe later in the chapter.
Deques
A deque (pronounced like “deck”) is the bidirectional equivalent to the queue. With it, we can
insert and delete elements at either end, as shown in FIGURE 17.8. In fact, the name is a
word invented by computer scientists as a contraction of double-ended queue. If you want to

simulate a waiting line in which people get frustrated and also leave from the back, a deque
would be a good choice. It could also represent a train of railroad cars in a switchyard, where
cars can be added and removed from either end of the train.
Deque A data structure in which insertions and deletions are made at either end.
FIGURE 17.8 A Deque (Double-Ended Queue)
Description
There is no consensus on the naming of deque operations. C++ uses push_front and
push_back for insertions, pop_front and pop_back for deletions, and front and back for
accessing the head and tail values. As we see when we look at the STL implementation, the
C++ deque is really one huge class that uses a combination of the interfaces for the abstract
bidirectional list, the deque, and the array.
Now it’s time to take a look at the STL. We focus on the interfaces for these linear ADTs—
that is, how the conceptual view of them works. Data and control abstraction allow us to write
whatever client code is needed to make use of these structures, without concerning ourselves
about their internal implementations. We return to our survey of abstract data structures later
in the chapter, when we shift our focus to nonlinear organizations of data.
QUICK CHECK
17.3.1 What is the efficiency trade-off in using a bidirectional list?
17.3.2 What is the difference between a queue and a dequeue data structure?

17.4 An Introduction to the STL
As the name Standard Template Library implies, the STL is made up primarily of templates.
There are two main sections of the library: containers and algorithms. The containers portion
has templates for 16 generic structured data types. Seven of these data types are more
specialized and will not be covered in this text: forward_list, multiset, multimap,
unordered_set, unordered_multiset, unordered_map, and unordered_multimap. The other nine
are summarized in the following table.
Container The name used with respect to the C++ STL to refer to its generic data
structures that hold an arbitrary number of elements.
Description
The array class is different from the others and will be discussed separately. To declare and
specialize any of the other eight template classes, simply use its name, followed by the type
in angle brackets; for example:

Description
We’ll see different forms of constructors for each type as we look at them individually. The
type of a container’s elements can be either a built-in type or a class. The STL does impose
some requirements on element objects. In particular, they must support at least a minimal
subset of the overloaded relational operators. For most compilers, overloading < and == is
sufficient, but a few require more of the operators to be overloaded.
The algorithms portion of the STL has a large number of function templates that can be
used in many different contexts. In this text, we cover just a few of the algorithms in detail.
The following table summarizes some of the more commonly used functions. Not all of these
can be applied to every type of container.
Description
We will look in more detail at each of the container classes, bringing in some of these
algorithms as examples. Keep in mind that we are just skimming the surface of the
capabilities of these templates so that you can get a sense of how they work. For a deeper
treatment, you should consult one of the dedicated STL reference books.
Iterators
Before we begin, we must explore one key concept associated with container classes: the
iterator. We’ve discussed iterators in the past, as one kind of responsibility a class can have.
In the STL, an iterator is an object that points to some place in a container. One way to think of

an iterator is as a pointer that has been wrapped in a class to provide additional functionality. It
is called an iterator because the extra functionality includes operations that cause it to move in
a step-by-step fashion through an STL container.
Iterators in the STL come in two flavors: forward and reverse.2 Typically, a container has
methods called begin and end that return forward iterators pointing to its beginning and its end,
respectively. You can use the ++ operator to advance a forward iterator through the container.
Using -- shifts the iterator backward.
Methods called rbegin and rend return reverse iterators. The iterators returned by rbegin
and rend point to the end and the beginning of a container, respectively. Using ++ with a
reverse iterator moves it from the back toward the front, and applying -- causes a move
toward the back; that is, the semantics of a reverse iterator are the opposite of those of a
forward iterator. A reverse iterator begins at the end of a container and “advances” toward the
front. FIGURE 17.9 illustrates this relationship.
FIGURE 17.9 Forward and Reverse Iterators Associated with a List
Description
The design of these iterators is meant to make it especially easy to traverse a container
with a For loop. What end returns is actually an iterator referring to a point just beyond the last
element. Similarly, the iterator returned by rend refers to a position just before the start of the
container. As we’ll see, this odd-sounding convention simplifies the termination condition in
For loops. Be aware, however, that you cannot use the values returned by end and rend to
directly access the ends of the container.
With random-access containers (such as deque and vector), the arithmetic operators + and
- can be applied to iterators, just as we would use them with array indexes to compute the
location of another element. Many C++ programmers think of an iterator as just another kind
of pointer. In reality, the STL classifies a pointer the other way around—as a kind of iterator.
Keep in mind that an iterator is an object. Not only does it provide extra operations, but it may
also have restrictions that constrain its capabilities as compared to the capabilities of a
pointer. For example, a unidirectional data structure limits its iterators to forward motion alone.
2 The STL actually defines five types of iterators. To keep things simple, however, we focus
on just these two kinds of iterator behavior.

One very important aspect of iterators is the fact that they remain valid only as long as the
contents of the container do not change. When an element is inserted into or deleted from a
container, its iterators become invalid because C++ doesn’t guarantee how the contents of a
container are arranged after a change has occurred. The idea is that STL implementors are
free to reorganize the data so as to improve efficiency. The container class cannot keep track
of every iterator that’s pointing to it, so there is no way to update these iterators when a
change takes place.
Each iterator must be declared for the specific type of container with which it will be used;
for example, if we need iterators for a list of strings, we would declare them as follows:
Description
The vector Template
Our tour of the STL’s containers begins with one that, in the abstract, is very easy to
understand. The vector class template implements an array. Why would we want another way
to define an array? Well, there is one more thing about vector—it doesn’t have to be fixed in
size. As a consequence, we don’t have to worry about subarray processing or decide how big
to make the array when we declare it. Otherwise, however, you can almost directly substitute
this container for the built-in array.
We say “almost” because a vector is an object rather than a built-in structure. Thus it must
be instantiated with a constructor at run time. For this reason, we cannot declare it using an
initialization list, as we can an array. Here are some simple calls to vector constructors:
Description
The first statement makes sense—it’s similar to writing this code:
But why would we want to declare a vector with no space in it? The reason is that a vector
automatically expands to hold as much data as we put into it. Thus, if we don’t have any idea
of how many strings we will put into noSizeVec, we simply declare it with no elements and let
the structure grow as we insert values.
If a vector always adjusts its size to hold the data, why do we ever need to bother with
specifying a size? The answer is that this flexibility comes at a price. Every time a vector
grows, it can take quite a bit of work. The underlying implementation is an array, and the
template allocates a new, larger array and moves the old contents into it. Thus, when we
know a maximum size in advance, it makes sense to indicate that value in the constructor.
Let’s see an example of a vector in action. In Chapter 11, we wrote a program that allows
the user to look up the number of occupants in a given apartment. Here is that program

rewritten to use a vector with the changes highlighted. Recall that we fixed the number of
apartments at 10.
Description
As you can see, the vector almost directly replaces the array. Because the class overloads
the [] operator, we can access the elements using index notation, both in storing values in the

vector and in retrieving them. Our example, however, doesn’t fully illustrate the potential
power of the vector template. Let’s rewrite the program so that it grows the vector to hold as
much apartment data as is on the input file.
Of course, we have to change the loop from a For to a While, testing the state of the inFile
stream and using a priming read. The constant BUILDING_SIZE is no longer useful, so we
remove it. But how do we determine the size value to output? We use the vector size
method; for example:
Well, that’s simple enough. But what about adding elements to the vector? For that we have to
call the push_back method, which appends the element passed as its argument to the end of
the vector, increasing its size if necessary.
In the original program, we didn’t check whether the apartment number input by the user
was in the valid range. We could use the size method again, with an If statement that guards
the access to occupants[apt-1], but that solution also ignores another useful feature of vector.
If we use the at method instead of index access, the range is automatically checked, and we
can easily catch an out_of_range exception. (Remember that we have to include <stdexcept>
to access this exception class.)

Description

Description
Here, then, is the revised code with the changes highlighted, followed by a new data file
containing 18 values, and the output from a sample run. Data file:
Description
Test run:

Description
The preceding example demonstrates just a few of the operators available with vector. The
following table summarizes these and lists additional operators that are commonly used.

Description
There are a few additional things to note about these methods. The at method returns a
reference that can be used for either access or assignment; that is, we can also write

to set the fourth element of the vector to 5, with range checking of the index.
The capacity of a vector is not the same as its size. The capacity is the number of spaces
allocated for elements. In simple cases, the values of capacity and size may be the same.
We can also use reserve to increase the capacity beyond the size, however. The advantage
of doing so is that as the number of elements grows, the vector doesn’t have to allocate larger
and larger arrays, in addition to copying data between them. For example, if we insert
after declaring occupants, then our program would not have to do any reallocations or make
any copies of the data set we gave it. The test run would still show that size is 18, but if we
were to insert
in the program, the value 20 would be output. FIGURE 17.10 shows a vector<char> for which
10 spaces have been reserved and 6 elements have been inserted.
This is also different from calling the vector constructor with a number of elements
specified, as we did in the previous version of our program:
FIGURE 17.10 A vector<char> with capacity 10, After Insertion of Six Elements
Description

In this case, occupants is constructed with 10 elements, all initialized to the default value for
the type (0 for int). Thus its initial size and capacity are both 10.
One other form of constructor is particularly useful. We may not be able to use an initializer
list with a vector, but we can initialize it from an array of values; for example:
Description
This constructor takes two iterators as its parameters. Recall that whenever we pass an array
as an argument, what actually gets sent to the parameter is the memory address of the first
element (the base address). Thus the first argument, occData, is the base address of the
already initialized array. The second argument,
Description
is the address that is one greater than the location of the last element of the array. The formula
first determines the number of elements in occData by dividing its size (in bytes) by the size of
its element (in bytes). The number of elements is added to the address for the beginning of the
array to produce the address for the end of the array. C++ automatically casts these
addresses into iterators of the appropriate type as they are passed to the constructor. The
constructor is designed so that the address just beyond the end of the array is a sentinel value
—it doesn’t copy that location into the vector.
Lastly, the vector template provides a copy constructor that lets us simply pass another
vector as an argument, and a new vector is created with the same size and content.
The array Template
Given how vector so readily replaces an array, you may wonder why there is also an array
template. The answer is that after the STL gained popularity, programmers wanted a fixed-
size array type that is compatible with other STL containers and provides some of their
additional functionality. As you might expect, its constructor requires that we specify both the
element type and the size. Unlike vector, we can also use an initializer list with it. For
example:
Description
The array template overloads the [] operator so that we can access array objects using index
notation.
Description

An array template also keeps track of the number of elements in an array, which can be
accessed using the size observer method. For example, if we had instead created intArr with
partial initialization
Description
we could use the size method to find out how many elements are initialized:
Description
The array equivalent to the capacity operator for vector is max_size:
Description
Traditional C++ arrays do not support aggregate operations. Recall how, in Chapter 11, we
said that we need to use a For loop to copy one array to another and to do comparisons
between two arrays element by element. In part, that is because C++ arrays do not keep
track of their sizes, so they don’t know how much to copy or compare. But because STL
array containers know how many elements they contain, we can use their overloaded
assignment and relational operators to copy and compare arrays:
Description
To be compatible with the other containers in the STL, the array also supports iterators, with
begin, rbegin, and rend constructors and the usual operators for moving the iterator. These
are just the most commonly used capabilities of the array template, and you should consult
an STL reference for a complete guide.
The list Template
Now that we’ve seen how vector and array work, we can quickly introduce the remaining
containers. Many of their operations have similar functionality. For example, list also defines
back, begin, clear, empty, end, erase, front, insert, push_back, rbegin, rend, and size, with
essentially the same meanings as for vector. Because it is a linked implementation, list does
not define a capacity, max_size, or reserve. Also, because it doesn’t support random access,
the [] operator is not overloaded, nor is the at operation supported.
The four forms of constructors are also defined for list. We can create a list with zero
elements, a list with a specific number of elements initialized to a default value, a list
initialized from an array or another container, or a list created by using a copy constructor.
The following table describes some additional operators that list supports.

Description
Description
To see how list works, we present the following nonsense example program that creates a
list from user input, displays its contents in different ways, applies various mutator
operations, and merges it with another list. Here is the code:

Description

Description
Here is the output from a test run:

Description
Description
The stack Template
Unlike list, which provides a very general set of container operations, the goal of the stack
type is to model a LIFO push-down stack as simply as possible. It has only seven methods
associated with it, which are listed in the following table.

Description
There are two ways to create a stack, either as an empty container or as a copy of a
vector, list, or deque.
Description
Here is a short demonstration program that inputs some words, pushing them on the stack
and outputting them in reverse order as they are popped from the top.

Description
Here is a sample run:
Description

The queue Template
The design philosophy behind queue is the same as for stack: Keep it simple. The most
significant difference is that push inserts elements at one end of the data structure and pop
removes them from the other end. In addition to the observer, front, for the element that is
about to be popped, queue provides back to allow us to look at the element most recently
pushed. Here is a summary of its operations:
Description
As with stack, there are two forms of constructor for queue. The default creates an empty
queue, and the other form lets us initialize the queue with a copy of the contents of a vector,
list, or deque.
Here is a sample program, very similar to the one we showed for stack, illustrating the
basic differences between the two types.

Description
Description
Here is a test run with the same data that we used for our stack example. As you can see,
the words emerge in the order that they were entered, rather than in reverse order.
Description
The priority_queue Template

The priority_queue is a variation on the idea of a queue that also bears some resemblance to
a stack. The major difference is that the elements in the structure are kept in sorted order.
Thus, push inserts elements using an insertion sort so that they go directly to their proper
places in the ordering. At one end, top observes the element with the greatest value and
application of pop removes it. An example of a priority queue is what happens in an
emergency room at the hospital: Cases are arranged with the most urgent at the head of the
waiting line, and then the cases are taken in order. As subsequent cases arrive, they are
inserted in the waiting line according to their urgency.
The following table contains a summary of the priority_queue operations.
Description
One of the quirks of the STL’s organization is that priority_queue is not kept in its own
header file. Instead, it shares the same file with queue; thus we include <queue> instead of
<priority_queue>. This type supports the empty constructor, and more like list and
company, it provides a second constructor that allows us to initialize the values from another
container. Unlike with stack and queue, there is no straight copy constructor.
Here is a revision of our example stack program, adapted to the priority_queue so that we
can appreciate the difference in this structure’s behavior. Note that the queue outputs its
contents in reverse alphabetical order.

Description
Description
Here is the output for the revised program:

Description
The deque Template
Whereas stack and queue strive to keep things simple, the design for deque takes the opposite
approach. With deque, we get a panoply of features taken from the containers we’ve already
seen.
For example, deque replicates most of the operations of list: back, begin, clear, empty, end,
erase, front, insert, pop_back, pop_front, push_back, push_front, rbegin, rend, and size, with
essentially the same meanings. Like vector, it overloads [] and at to provide random access.
Being linked, it does not need to support capacity or reserve operations. Nor does it directly
support merge, remove, reverse, sort, or unique, because equivalent function templates with the
same names are defined in the algorithms section of the STL, all of which can be applied to
deque. This template provides constructors of the same four forms that list supplies: We can
create a deque with zero elements, a deque with a specific number of elements initialized to a
default value, a deque initialized from an array or another container, and a deque created with a
copy constructor.
If deque encompasses list and vector, why shouldn’t we always use it? As always, this
increase in capability costs us in terms of efficiency. The underlying array implementation of a
vector is usually much faster than that of a deque. We say “usually” because, if a large vector
must change its capacity frequently, the linked implementation of a deque can outperform it.
Random access in a deque is also not as efficient as for a vector. How does deque compare
with list? Because a list doesn’t have to support random access, deletions and insertions
at points other than its ends can be much faster. However, when you really need the
combination of vector and list features in one structure, deque is quite useful to have in the
library.
The naming of list and deque in the STL is really somewhat misleading, because both can
act as either a list or a deque in the abstract sense. The STL list is a general bidirectional list
with support for deque operations. The STL deque is also a bidirectional list, with support for
both deque operations and random-access indexing.
Because we’ve already seen the features of deque with other containers, an operation
summary table would be redundant. We will demonstrate the use of a deque in the Problem-
Solving Case Study at the end of the chapter.
MAY WE INTRODUCE Sir Charles Antony
Richard Hoare

Tony Hoare’s interest in computing was awakened in the early nineteen-fifties, when he
studied philosophy (together with Latin and Greek) at Oxford University, under the tutelage
of John Lucas. He was fascinated by the power of mathematical logic as an explanation of
the apparent certainty of mathematical truth. During his National Service (1956–1958), he
studied Russian in the Royal Navy. Then he took a qualification in statistics (and
incidentally) a course in programming given by Leslie Fox. In 1959, as a graduate student
at Moscow State University, he studied the machine translation of languages (together with
probability theory) in the school of Kolmogorov. To assist in efficient look-up of words in a
dictionary, he discovered the well-known sorting algorithm Quicksort.
On return to England in 1960, he worked as a programmer for Elliott Brothers, a small
scientific computer manufacturer. He led a team (including his later wife Jill) in the design
and delivery of the first commercial compiler for the programming language Algol 60. He
attributes the success of the project to the use of Algol itself as the design language for the
compiler, although the implementation used decimal machine code. Promoted to the rank
of Chief Engineer, he then led a larger team on a disastrous project to implement an
operating system. After managing a recovery from the failure, he moved as Chief Scientist
to the computing research division, where he worked on the hardware and software
architecture for future machines.
These machines were cancelled when the company merged with its rivals, and in 1968
Tony took a chance to apply for the Professorship of Computing Science at the Queen’s
University, Belfast. His research goal was to understand why operating systems were so
much more difficult than compilers, and to see if advances in programming theory and
languages could help with the problems of concurrency. In spite of civil disturbances, he
built up a strong teaching and research department, and published a series of papers on
the use of assertions to prove correctness of computer programs. He knew that this was
long-term research, unlikely to achieve industrial application within the span of his
academic career.
In 1977 he moved to Oxford University, and undertook to build up the Programming
Research Group, founded by Christopher Strachey. With the aid of external funding from
government initiatives, industrial collaborations, and charitable donations, Oxford now
teaches a range of degree courses in Computer Science, including an external Master’s
degree for software engineers from industry. The research of his teams at Oxford pursued
an ideal that takes provable correctness as the driving force for the accurate specification,
design and development of computing systems, both critical and non-critical. Well-known
results of the research include the Z specification language, and the CSP concurrent
programming model. A recent personal research goal has been the unification of a diverse
range of theories applying to different programming languages, paradigms, and
implementation technologies.

Throughout more than thirty years as an academic, Tony has maintained strong
contacts with industry, through consultancy, teaching, and collaborative research projects.
He took a particular interest in the sustenance of legacy code, where assertions are now
playing a vital role, not for his original purpose of program proof, but rather in
instrumentation of code for testing purposes. On reaching retirement age at Oxford, he
welcomed an opportunity to go back to industry as a senior researcher with Microsoft
Research in Cambridge. He hopes to expand the opportunities for industrial application of
good academic research, and to encourage academic researchers to continue the pursuit
of deep and interesting questions in areas of long-term interest to the software industry and
its customers.
The above biographical sketch was written by Sir Tony Hoare himself and reprinted with
his permission. What he does not say is that he received the Turing Award in 1980, at the
age of 46, for his fundamental contributions to the definition and design of programming
languages and was awarded a knighthood in 1999 for his services to education and
computer science.
SOFTWARE MAINTENANCE CASE STUDY Appointment
Calendar Using STL List
MAINTENANCE TASK: In Chapter 15, we developed a set of classes to support an
appointment calendar application, and a simple driver with which to test them. We used
our linked implementation of a list to hold the calendar data. Now that we have learned how
to use the STL list class, let’s see how much work it will take to convert our prior work to
make use of it. In theory, this should be fairly easy.
EXISTING CODE: Recall that our appointment calendar project had six underlying
classes. Three of these provide the attributes of an entry: Name, TimeOfDay, and Date. We
originally developed a base class called Entry, containing just Name and TimeOfDay. We then
derived a subclass from Entry, called EntryWithDate, that added support for a Date
attribute. The AppointmentCalendar class used our List class to create a list of
EntryWithDate objects that we could search and update. To keep things simple, we did not
actually make use of the TimeOfDay attribute, but distinguished appointments only by their
date and name.
Because our List class kept its data unsorted, we took the approach of performing a
linear search on the list, removing the element to be updated, and then appending the new
version to the end of the list.
In Chapter 16, we changed the Date class so that it uses the overloaded relational
operators rather than the ComparedTo function. Let’s also make this update to our
appointment calendar. That step will necessitate some changes to EntryWithDate, but we
know that its use of ComparedTo likewise must be revised to overload at least the < and ==
operators so that we can use this class with the list container.
DISCUSSON: Looking over the classes in our original solution, even at the abstract level,
we can see that Name, TimeOfDay, and Entry do not depend on any of the changes we are

making. We should be able to use them unchanged. Our goal should be to hide the
changes from the driver, within the encapsulating interface of AppointmentCalendar.
We know that EntryWithDate must be updated to use the relational operators supplied by
the revised Date class, and that it must itself supply overloaded relational operators for at
least < and == to enable the STL list to work with it. For generality’s sake, we can just
include all of the relational operators. Once we have < and == implemented, we can write
the others by cutting and pasting from them with minor changes (often called cookie-
cutter coding).
Recall that we defined equality for entries as having the same date and name. How
should we define “less than”? For now, let’s just use the date to order entries. The
implication of this choice is that within a single date, the ordering of entries isn’t significant.
In the future, we would clearly amend this definition to take into account the time and
perhaps to alphabetically order elements by name.
We now have enough information to code the new version of this class:
Description

Description

Description
Next we turn our attention to the AppointmentCalendar class, which makes use of the
list. Let’s look first at the original version of the specification file:

Description
Obviously, we need to include <list> rather than "List.h", and we will use
list<EntryWithDate> as the type for list. Oh no! We gave our entry list the same name as
the STL type. We should change it to entryList. Is there anything else to change here? If
we plan to hide the changes from the driver, then the only changes should be to the private
part of the interface; that means we are done with updating the specification file.
Here is the new version with the changes highlighted:
Description

Description
Thus far the changes have been very straightforward. As we expected, all of the
significant changes are confined to the implementation of AppointmentCalendar. Let’s go
through it method by method to see what we need to revise.
Here is the original version of the constructor, which reads a file and inserts it into the
list. Everything in the code is concerned with building up the pieces of an entry, which
hasn’t changed. (Even though the implementation of Date is different, it still uses the same
form of constructor.)
Description

Only the very last statement makes reference to list. Our class used Insert rather
than push_back to add elements to the end of the list. We change this one line to the
following and then move on to the next method:
The IsThere method checks whether an entry is in the calendar merely by constructing
an entry from its parameters and calling IsThere for the list. Now we have a problem: The
STL list template doesn’t provide an operation equivalent to a search. But wait! There are
more than 60 algorithms in the other portion of the STL. Maybe we can find something
there that will help us. Searching through our STL reference, we discover an algorithm
called find that sounds promising.
The documentation for find says that it searches a container, starting from a beginning
iterator up to an ending iterator, looking for a specified element. If it finds the element, it
returns an iterator pointing to it. (When there are multiple copies, find stops with the first
one.) If the element isn’t found, the iterator points to the same place that the end method
returns. Because we want to search the entire list, we can use begin and end to get the
range iterators. To convert the result of the search into a bool indicating whether the entry
is there, we just compare it with end. All we have to do is insert
at the top of the file and change the return statement to the following:
Description
Next comes the workhorse method of this class, GetEntry, which searches for an entry
to update and deletes it from the list.
Description
Our List class kept an iterator internally and allowed us to indirectly manage it by
providing methods called GetNextItem and ResetList. The client code was responsible for
looping through the list using these operations. The paradigm for the STL containers is to

allow any number of iterators to be kept externally and to supply algorithms that traverse
the data. We must now adapt this method to that alternate paradigm.
We already know that we can use find to replace the search operation. Obviously, that
means we can delete the entire looping structure. But what do we do with the result from
find? It returns a pointer to the entry, rather than the entry itself. We should declare an
iterator of the appropriate type, assign the find result to it, and then dereference it before
passing the entry back. At least the Delete operation has an equivalent form in list: We
just call erase.
As we start coding, one other stylistic change comes to light. We named otherEntry
because of how it would be used in the ComparedTo function. Given that it is the target of the
find function, that name now seems inappropriate. Let’s call it searchEntry instead.
Here is the revised code for GetEntry, with the changes highlighted:
Description
The change to the original InsertEntry method is trivial. We just replace the call to
Insert with a call to push_back. Lastly, we review the WriteListToFile method.
Description

Description
As before, we have to account for the change in the paradigm of how we create and
manage iterators in the STL versus our List ADT. However, we already know how to
traverse a list from beginning to end: We simply use a For loop along with calls to begin
and end. We also need to declare an iterator of the appropriate type, which we call
location. Because location is a pointer to an entry, we must dereference it and assign the
result to entry, instead of assigning the result of GetNextItem. Finally, our use of the
GetLength method becomes a call to size.
Here, then, is the complete implementation for AppointmentCalendar, with all of the
changes highlighted.

Description

Description
TESTING: Here is the driver’s output, using the same test data as before. The results
match what was output by the version in Chapter 15.

Here is the input file:
Description
Here is a test run:
Description

Description
Here is the output file:
Description
QUICK CHECK
17.4.1 How would you declare an STL queue called nums with a float specialization?
17.4.2 Which list operation returns an iterator that points just beyond the last
element?
17.4.3 Which STL algorithm would you use to search a deque for a value?
17.4.4 The STL stack and queue containers both have pop operations. How do they
differ?

17.4.5 What are the two main sections of the STL library?
17.4.6 What is a C++ STL container?
17.4.7 What is an important aspect of iterators with respect to the content in their
associated container?
17.4.8 What does the vector template implement?
17.4.9 What is the primary reason why you might use a vector over the built-in C++
array?
17.4.10 What is the difference between a vector’s size and capacity?

17.5 Nonlinear Structures
Early in the chapter, we noted that all of the structured types we had seen were linear in
nature. That’s still true: Vectors, lists, stacks, queues, deques, and priority queues all arrange
their elements one after another. In this section, we open the door to some other
arrangements. If you were surprised by how many variations could be created within the
limitations of a linear arrangement, it should be clear that when we remove this restriction, the
number of possibilities grows tremendously. Here we can touch on only a few nonlinear
arrangements.
We start with one of the simplest, in which elements have links that branch out in different
directions. This branching behavior gives the structure its name: tree. In particular, we focus
on the case where each node has just two branches and, therefore, is called a binary tree.
Binary Trees
We can expand the concept of a linked list to structures containing nodes with more than one
forward link field. One of these structures is known as a binary tree (FIGURE 17.11). Such a
tree is referenced by an external pointer to a specific node, called the root of the tree. The root
has two pointers: one to its left child and one to its right child. Each child also has two pointers:
one to its left child and one to its right child. The left and right children of a node are called
siblings.
Binary tree A linked data structure, each of whose nodes contains links to a left and right
child node.
FIGURE 17.11 A Binary Tree
Description

For any node in a tree, the left child of the node is the root of the left subtree of the node.
Likewise, the right child is the root of the right subtree. Nodes whose left and right children are
both NULL are called leaf nodes.
Although Figure 17.11 shows a binary tree with only seven nodes, there is no theoretical
limit on the number of nodes in a tree. If you turn the figure upside down, you can see why it is
called a tree.
A binary search tree is a special kind of binary tree with the additional property that the
values are arranged in a particular order. In a binary search tree, the component in any node
is greater than the component in its left child and any of its children (left subtree) and less than
the component in its right child and any of its children (right subtree). This definition assumes
no duplicates. The tree shown below is an example of a binary search tree.
Binary search tree A binary tree in which the value in any node is greater than the value
in its left child and any of its children and less than the value in its right child and any of its
children.
Description
A binary search tree is useful because, if we are looking for a certain item, we can tell which
half of the tree it is in by using just one comparison. We can then tell which half of that half the
item is in with one more comparison. This process continues until either we find the item (a
number in this case) or we determine that the item is not there. The process is analogous to a
binary search of a sorted array.
Let’s search for the number 50 in our binary search tree.

Description
Now let’s look for 18, a number that is not there.
Description
The left child of 19 is NULL, so we know that 18 isn’t in the tree. Not only do we know that 18 is
not there, but we are also at the right place to insert 18 if we want to do so.
To summarize, we compared the value we were looking for with the item in the tree and
took the appropriate branch if the value and the item were not the same. When we started to
take a branch that was NULL, we knew that the value was not in the tree. Just as the binary
search has algorithmic complexity of O(log2N), so does searching in a binary search tree.
If we want to output all of the values in a binary search tree in order, we traverse it as
follows:
Tree Traversal
If the left child isn’t null, traverse the left subtree.
Output the current item.
If the right child isn’t null, traverse the right subtree.
We start at the root of the tree. If it has a left child, we move to that node and repeat the
process. We continue in the same way down the left side of the tree until we reach a leaf,
which we output. Then we move back up to the parent of that leaf and output it before

traversing the subtree to its right. As an example, suppose we are given the following binary
search tree:
Description
Traversal begins with the root (36), proceeds to its left child (24) and then to the left child of
24, which is 12. Because 12 is a leaf, it is output, and we go back up to 24, which we also
output. Then we traverse its right subtree, which is the leaf, 30. After outputting 30, we go
back to 24. Because we are done with this subtree, we back up to 36 and output it. Then the
process is repeated with the right subtree, outputting 42, 48, and 60.
As we see in Chapter 18, this kind of algorithm, which calls itself to process a smaller
portion of the problem, is said to be recursive. In that chapter, we’ll also see that a stack is the
natural choice of structure for keeping track of where we are in the tree.
This particular form of traversal (visit left subtree, then root, then right sub-tree) is called an
in-order traversal. There are two other commonly used traversal patterns for a tree.
In-order traversal A traversal of a binary tree that proceeds in the pattern of “left subtree,
visit the root, then visit right subtrees.”
    Preorder Traversal
Visit the root.
Visit the left subtree.
Visit the right subtree.
   Postorder Traversal
Visit the left subtree.
Visit the right subtree.
Visit the root.
The names come from the place within the order of traversal that we visit the root. If we
visit it before we visit the subtrees, then it is preorder traversal. If we visit the root after the
subtrees, then it is postorder traversal. Depending on the data stored in a binary tree, each
order of traversal may have a particular use.
Preorder traversal A traversal of a binary tree that proceeds in the pattern of “visit the
root, then visit the left and right subtrees.”

Postorder traversal A traversal of a binary tree that proceeds in the pattern of “visit the
left and right subtrees, then visit the root.”
Trees are not limited to a binary branching factor. If we define a node to have three link
fields, we get a tree that has three branches per node. Nor are trees limited to having the
same number of branches in each node. For example, we can construct a tree that
represents a family genealogy, where the number of links from a node depends on the number
of children who were born to a given set of parents. To store a variable number of child links,
we might use a list as a field within a tree node.
Lists, stacks, queues, and trees all have the property that the links flow in one direction
(from head to tail, from root to leaf, and so on). We can form even more sophisticated
structures, called graphs, in which links can flow in any direction. We might use a graph to
represent the roads connecting a set of cities or the network connecting a set of computers.
As you can see, linked structures can become quite complex.
Graph A data structure in which the links can be arranged in any pattern.
Just as we were able to implement a list as an array or a dynamic structure, so we can
implement stacks, queues, trees, and graphs with dynamic structures or arrays. It is
important to remember that a data structure has both a logical organization and an
implementation structure. The two are distinct, and the choice of each depends on the
requirements of any given problem.
The STL does not actually provide a container that implements a tree in the abstract sense.
However, the set container that we examine in Section 17.6, “Associative Containers,” is
often implemented with a binary search tree.
Next we look at a different kind of logical structure that provides very fast searching under
certain conditions. We’ll again see that it can have multiple implementations.
Hash Tables
Your summer job at a drive-in theater includes changing the movie title on the sign each week.
The letters are kept in a box in the projection booth. Your first day on the job, you discover that
the letters are in random order, and you have to search through nearly all of them to find the
ones you need. You sort the letters into alphabetical order, which allows you to use a binary
search to locate each letter, but that’s still tedious. Finally, you make a set of 26 cards to
separate the letters, and then you are able to directly pull each letter from its place in the box.
Because you are searching for values within a known range, you’ve divided up the space
so that you can directly locate them. In general, if the items you are searching have this
property, you can merely index into an array based on their values and retrieve the items.
Given a set of N values, the searching algorithms we’ve seen so far have a maximum of
either N steps (linear search) or log2N steps (binary search). This new technique typically

takes just a few steps, regardless of the amount of data. We refer to this approach as
hashing.
Hashing A technique used to perform insertion and access of elements in a data structure
in approximately constant time, by using the value of each element to identify its location in
the structure.
Our letter-finding example is a perfect situation for using hashing because there are a small
number of possible values, and we can use them as indexes. Unfortunately, most data are not
equally well behaved. For example, if our data values are real numbers representing
temperatures, then the number of potential values is immense. C++ does not let us create an
array big enough to use a float value as an index.
Nevertheless, the temperatures might have a very limited range, such as 90.0 to 110.0
degrees Fahrenheit. If we are interested in precision only to one-tenth of a degree, then there
are actually just 201 distinct values. We could develop a method that takes a temperature and
returns an index in the range of 0 to 200; we could then store the temperatures using hashing.
Such a method is called a hash function. Assuming that the hash function takes a small
amount of time to compute, searching with hashing is still a very fast operation.
Hash function A function used to manipulate the value of an element to produce an index
that identifies its location in a data structure.
The preceding examples have ignored the problem of having duplicates in the data set.
Also, some data sets can have an irregular distribution of values. For example, if you are
sorting a group of names, you will find that many more begin with “A,” “M,” or “S” than with
“Q,” “X,” or “Z” (although those frequencies change with where you are in the world). Thus we
might end up trying to store multiple values into the same place in the array, a condition called
a collision.
Collision The condition resulting when a hash function maps multiple values to the same
location.
Several approaches can be taken to deal with collisions. For example, when we attempt to
store a value into a location that’s already full, we could simply increment the index until we
find an empty location. Unfortunately, that strategy tends to produce clusters of filled locations.
In the worst case, it can take as many accesses to find an empty slot as there are elements
in the array. In another approach, known as rehashing, we feed the output of the hash function
back into the function (or into another function) to select a new index.
Until now we’ve assumed the use of a simple linear array implementation, but hashing isn’t
limited to this kind of structure. We could, for example, use an array of linked lists. The hash
function might then index into this array and add the item to the linked list at that location. With
each collision on a given array slot, the associated list would simply grow one node longer. If

the hash function is well designed, the lists would remain reasonably short (few collisions), so
the search would still take just a few operations. FIGURE 17.12 shows such a structure,
called a chained hash table.
FIGURE 17.12 A Chained Hash Table
Description
The efficiency of hashing depends on having an array or table that is large enough to hold
the data set, with enough extra room to keep collisions to a minimum. Sometimes this is an
impractical condition to satisfy; for many other problems, hashing is a very effective means of
organizing data. For example, we could use a hash table to implement a list that has fast
insertion, deletion, and access capabilities, similar to the STL deque. A hash table is also a
candidate implementation structure for another kind of container that we look at in the next
section, the map.
Developing a good hash function can require a considerable amount of data analysis. Our
goal here is not to show you how to develop such functions, but merely to give you an
appreciation for both the benefits of hashing and its limitations.
QUICK CHECK
17.5.1 In what order does postorder traversal visit the nodes of a binary tree?
17.5.2 What is a collision in a hash table?
17.5.3 What is a binary tree?
17.5.4 What is the difference between a binary tree and a binary search tree?

17.5.5 What do we call the node in a binary tree that is referenced from an external
pointer?
17.5.6 What technique is used to access elements of a data structure in
approximately constant time?
17.5.7 Describe a hash function that we could use to produce an index into a data
structure where the input to the hash function is a value representing a student grade
between 0 and 100 and the output would be a value between 0 and 4 where 0
represents the grade of F and 4 is an A (no +/– letter grades).

17.6 Associative Containers
The STL divides its containers into three groups. The vector, list, and deque are referred to as
sequence containers. The simpler stack, queue, and priority queue types are called container
adapters because they are actually built on top of the sequence containers to provide a
simpler and more convenient interface. The third group includes the so-called associative
containers.
We locate values within an associative container not by their positions, but by their values.
Imagine, for example, that you have an array of structs, each of which contains a name and a
phone number. You can access a number by name by conducting a search of the array and
comparing a given name to the name stored in each location; you may eventually find a
match with this approach. Now, suppose instead that you could just write
to look up the number; that is, suppose you could find the phone number just by referring to its
associated value.
Computer scientists refer to this kind of lookup as access by association, associative
lookup, or content addressable access. The value that is used for searching is called the
key, and collectively these values must be ordered in a manner that allows two keys to be
compared. In many cases, the keys must also be unique. Associative lookup is the basis for
many kinds of database processing as well as having a wide variety of other uses.
Associative lookup (content-addressable access) The process of retrieving a value
based on an associated value called the key.
The STL offers five different associative containers. Here we examine just two of them: set
and map.
The set Template
The STL set template takes its name from the fact that, like the mathematical set, it stores
only unique values. If you try to insert a value that is already in a set, the set will be
unchanged. Not surprisingly, the STL takes the implementation of the set far beyond the
mathematical concept.
Internally, the values in a set are sorted from least to greatest, so the STL provides the
ability to use an iterator with begin and end, or a reverse_iterator with rbegin and rend, to
traverse the set as if it was a sorted list. (Most implementations use a binary search tree as
shown in FIGURE 17.13.) However, this is less efficient than traversing a sequence
container.

FIGURE 17.13 An Implementation of a set Using a Binary Search Tree
Description
What the set excels at is finding elements by their values. Thus the find operation is built
into the set interface, rather than being treated as a separate algorithm. After find provides an
iterator pointing to a value in a set, you can use it to erase the element or retrieve adjacent
elements. Here is a table of some of the more commonly used set operations.
Description

Description
The set type provides a default constructor that creates an empty set. A second form of
constructor follows the pattern of the sequence containers, in which another container or an
array can be used to initialize the set. Of course, any duplicate elements in the container are
not inserted into the set. A straight copy constructor that takes another set as a parameter is
available for creating a duplicate set.
In addition to the class methods in the preceding table, three of the algorithms described in
Section 17.4 apply to set: set_difference, set_intersection, and set_union. Keep in mind that
you must include <algorithm> to use these algorithms, and they are called like traditional
functions, rather than object methods. The example program later in this section
demonstrates the use of set_difference. All of the set algorithms use the same arrangement
of five parameters, all of which are iterators:
Description
The first two iterators specify a range in the first set, the next two specify a range in the
second set, and the last points to the beginning of the place where the result set should be
placed.
Oddly enough, the set algorithms are not designed to output their results directly as a value
of class set. Instead, they were written to be more generally applicable to other containers, so

their output can’t go directly into a set. (You can write the result directly to a vector, for
example.)
Another function template in the <iterator> package of algorithms, inserter, must be used
to force the set algorithms to generate their output in a way that enables a set to insert the
output into itself. The inserter takes two arguments: the destination container, followed by an
iterator that points to the place where the insertion should occur. Because set picks its own
insertion point, it doesn’t matter what the second value is, as long as it points to a place in the
set. We can use begin or end, for example. Here is how a call to set_difference looks, once
all of this has been factored in:
Description
In this example, set3 contains all of the elements of set1 that are not found in set2. We’ve
shown this behavior as a void function call. In reality, each of the set algorithms returns an
iterator pointing to the end of the result. Because we don’t need this result in our example, we
simply let the return value be discarded.
Here is a sample program using set:

Description

Description
Here is a sample run of the program:
Description
The map Template
An STL map type is like a set, but with one major difference: Whereas the set stores only key
values, a map associates a second value with each key. The map is, therefore, the standard
example of an associative container. It lets us implement the kind of name-indexed array that
we described at the beginning of this section, as shown in FIGURE 17.14. Although the map is
conceptually an array, internally it may be implemented with a linked structure such as a
binary search tree or a chained hash table.

FIGURE 17.14 A Conceptual Illustration of a map
Description
The operations for a map are nearly identical to those for a set. Its elements are sorted, and
it supports begin, clear, count, empty, end, erase, find, insert, lower_bound, rbegin, rend, size,
and upper_bound. As you might guess, however, the insert operation does not take a simple
value as its argument. Instead, it expects a value of the template type pair.
Here is an example definition of a map that could be used for a phone directory, and an
insert operation that places an entry into it:
Description
The following statements
Description
cause find to return an iterator pointing to this pair element of phonedirectory. After
dereferencing the iterator, we can use first and second to output the two parts of the pair.
The last statement erases the element.

This is all well and good, but a bit tedious to code. Wouldn’t it be nice if we could just use
array syntax? That’s the other big difference between the set and the map. With map, the []
operator is overloaded, enabling us to write the preceding code segment as follows:
Description
As we see in the following case study, a map can also be used to convert input strings to
enum values.
QUICK CHECK
17.6.1 What is an associative data structure?
17.6.2 What is the main difference between a set and a map
17.6.3 Which operator is overloaded in a map container that makes it easy to store and
retrieve values from it?
17.6.4 Why do we call a map an associative structure?
17.6.5 How would you insert the number 42 into a map called matches at a location with
the key value "answer"?
Problem-Solving Case Study
CREATING A DECK OF CARDS
PROBLEM: For a probability and statistics class, you are doing a project to empirically
explore the odds of certain kinds of hands occurring in various card games. You want to
begin by developing a set of classes that will allow you to simulate a deck of 52 cards
consisting of the four suits (hearts, clubs, diamonds, spades) with 13 values (ace through
king) in each suit. Once you have these working, you can easily construct the necessary
drivers to try out your hypotheses.
IDENTIFYING INITIAL CLASSES: Here is the list of potential classes, based on the
problem statement:
Deck
Card

Suits
Values
Hands
Games
FILTERING: With a little reflection, it’s clear that the last two classes pertain to the larger
problem rather than to the task immediately at hand. Clearly, we need a structure to
represent the card deck as well as an individual card. Do we really need separate classes
to represent suits and values, or can we just use a pair of enum values? You anticipate
wanting to be able to enter names of cards for some of the experiments, and it would be
nice to encapsulate the conversion of the enum values back into strings. So, yes, it makes
sense to build classes representing these objects.
Here is our filtered list:
Deck
Card
Suits
Values
INITIAL CLASS DESIGNS: Let’s begin by looking at the simplest classes, which
represent the suits and values. They are likely to be nearly identical, with the exception of
the particular enum. We can start with Suits, because it has a smaller range than Values.
We would like to be able to construct a suit value from a string or from an integer. As a
default, it should use the smallest value, CLUBS. We want observers to convert the value to
an int or a string. We can call these responsibilities toString and toInt. For comparison
purposes, we should also provide tests for less than and equal.
A quick walk-through of the responsibilities shows that most of them are straightforward.
In toString we can use an array of strings, indexed by the enum to convert the value to a
string. But how do we go in the other direction for the constructor that takes a string? As
we’ve just seen, a map is a perfect choice for this task. But there’s one more problem: We
need to convert an input string into all uppercase to properly match it. We could use a loop
to convert the string character-by-character to uppercase, but a quick browsing of the STL
reveals an algorithm called transform that can do the work for us. Here is a CRC card for
this class design:

Description
The Values class will be identical except for the name, so we don’t show its CRC card.
Here are the specification files for these two classes, based on the CRC card design. We
wait until after we’ve finished the rest of the design before considering their
implementations.
Description

Description
Description
Now let’s move up to considering the responsibilities for a Card. We should provide a
constructor that takes a value and a suit. We also want to be able to observe both of these
members. Because it will be necessary to compare cards against one another, we should
also support relational operators. Let’s go ahead and include all of them, just for future
convenience. Again, a quick walk-through reveals that most of these responsibilities are
trivial. However, comparisons require computing the rank of a card within the deck (its suit
value × 13 plus its face value). It will simplify our work if we create a helper function to do
this computation. Here is the CRC card for Card:

In fact, this class is so simple that we can implement it directly:

Description
Description

Description

All that remains is determining the responsibilities for class Deck. Initially it will be sufficient
to have the default constructor build a full deck of cards in order. We want the ability to
shuffle the deck, to deal out an individual card, to ask whether the deck is empty, and to
find out whether a given card is still in the deck. It’s also helpful to know how many cards
are left in the deck.
A walk-through reveals that we have a choice of STL containers with which we could
collaborate to represent the deck. Let’s use the deque, just to see it in action. We’ll need to
loop through the values and suits, creating the 52 cards to push into the deque. Once that’s
done, we can use the STL find algorithm to implement isThere. What about shuffling?
Again, the STL algorithms come to the rescue with a shuffle operation. Dealing is just a
matter of getting the front element of the deque and popping the card off of it. Here is a CRC
card that outlines those responsibilities:
Description
Here is the specification file for class Deck:
Description

Description
The implementations of most of these methods are straightforward. We can use the
empty and size functions from deque to implement the corresponding functions in this class.
We already know that find and shuffle from the STL algorithms can implement the
isThere and Shuffle functions, respectively. The shuffle function requires a random
number generator that is initialized with the current time as a starting point. We use the
provided pseudo-random number generator that is provided by the random header file and
use the chrono library to seed it. To deal a card, we just use the front and pop_front
operations from deque. The only part that requires much thought is the constructor. It’s
clear that we’ll use push_back to insert the cards into the deque—but how do we generate
the cards in order? A nested For loop, counting through the enum values, with Values in the
inner loop and Suits in the outer loop, can accomplish this task. A little refresher on how to
iterate through an enum, from Chapter 10, and we’re all set to write the implementation.
Description

Description
Now we can return to the implementation of Suits. As we noted, the only method that
needs further attention is the constructor that is initialized by a string. What we can do is
assign the string–enum pairs to a map using statements like
Description
To get the suit from the string, we just reverse the process:
Description

The one thing that stands in our way is converting the string to uppercase. The STL
transform algorithm can handle this task for us. It takes four arguments: The first two are
iterators to the start and end of the source container, the third is an iterator to the start of
the destination container, and the last is a function that is applied to each element of the
container as it is copied from the source to the destination. We can use the toupper
function to perform the conversion. But can we actually apply transform to a string?
This is where we see that string really is a class in the C++ library. It is actually another
container in the STL (albeit with some special properties). As a consequence, string also
supports begin and end operations, and it can have many of the STL algorithms applied to
its objects. The necessary call to transform looks like this:
Description
At last, we can implement Suits:
Description

Description
As we noted, the implementation of Values is virtually identical, except for the change in
the variable names and the different enum values.
Description

Description

Description
TESTING: A proper driver for these classes should exercise them as much as possible.
Here we are limited by space to some basic tests. We can create a deck and deal out
some cards to see that they are initially in order. Then the deck can be shuffled before we
test isThere with a random query that is input by the user. Using empty, we can control a
second loop that deals out the rest of the cards. At each stage, we can test size by
outputting the size of the deck. That covers all of the operations in Deck, which in turn runs
through all of the values in Card, although it does not cover the relational operators (except
as they are used by find). Again, with the exception of the relational operators, this
strategy covers all of the operations in Values and Suits.
Here is the driver that implements these tests:
Description

Description
Following is a run of the driver with the user input shaded. As you can see, the cards are
in order to start, and the last 42 are output in shuffled order. The user input mixes
uppercase and lowercase and still matches the card. At each point the correct size is
reported, and the final loop terminates when the deck is empty. After a little more testing,
these classes can go into production use for your experiments.
Description

Description

Description

Graphical User Interface (GUI)
The application in the previous section is intended to demonstrate the use of the STL in the
context of a deck of cards. Unfortunately, the interface is all console-based. Wouldn’t it be nice
if the user could see a card graphically? In this section we are going to build an application that
presents the user with a table of the cards in a deck and allows the user to click on a card in
the table to view the corresponding card visually. The application will also include a button to
reshuffle the deck. This is what the GUI will look like in the end:
Description
First, we need to identify exactly the widgets we need for this GUI. By this point, you should
anticipate the use of a QTableWidget for the table and a QPushButton for the shuffle button. To
display an image, we can actually use the familiar QLabel, because a QLabel widget provides
methods that allow us to add an image and render it properly. Let’s look at the class
specification of the window widget:

Description
The CardDeckMainWindow has a constructor that only takes a pointer to a parent QWidget. In
this graphical application we are not passing anything into the CardDeckMainWindow because we
will create a new Deck every time we shuffle. This means we do not have any external state to
worry about. In the private section we define a QTableWidget and QLabel pointer. We will
initialize both of those in the constructor and supporting methods. The InitTable method will
be used to initialize the table containing the card value and suit. The label and the image it
displays initially are taken care of by the InitLabel method. Lastly, the DisplayImage method
will take the row of the value and suit of a card and display the corresponding image.
There are two events that we need to handle:
1. When an item in the table of cards is clicked (event), the application will set the label
with the image that corresponds to the value and suit of the item that was clicked (action).
2. When the shuffle button is clicked (event), the application will create a new deck,
shuffle it, and add the cards to the table (action).
The HandleClickOnCard event handler (slot) will respond when an item in the table is clicked,
and the HandleShuffleButtonClicked will shuffle the cards and redisplay the table when the
Shuffle button is clicked. Now we look at the constructor for the CardDeckMainWindow:

Description
The constructor begins by initializing the table member variable to the nullptr (more on
why later) and then calling InitTable and InitLabel. It is good software engineering practice to
decompose your code into methods not only for reusability, but also for readability. For now,
we can assume these methods do what they say they do: initialize the table and label. We see
their implementation shortly. We then create the Shuffle button and add each widget to a grid
layout. Then a wrapper widget, deckWidget, is created, to which we add the layout containing
the main graphical components. Then we make it the central widget of the QMainWindow with
the setCentralWidget method.
Lastly, we connect the cellClicked signal from the table to the HandleClickOnCard slot of the
CardDeckMainWindow. Notice that the cellClicked signal has two integer arguments. When a
table entry is clicked, it passes the row and column of the table entry to the parameters of the
HandleClickOnCard event handler, which also has two integer parameters. The shuffleButton
and its clicked signal are connected to the HandleShuffleButtonClicked event handler. The
signal and slot method parameters must have matching types; otherwise, the application will
not compile.
Now that we have the GUI widgets in place, let’s look at how we initialize the table and label.
The InitTable method needs to create a new QTableWidget and fill it with the value and suit of
each card in a shuffled deck. Here is the code to do this:

Description
We create a new Deck and then call its Shuffle method. Next, we create a new QTableWidget
and set the number of columns to two (for the card value and suit) with the setColumnCount
method and then call the setRowCount method to set the number of rows to 52, so it can hold
all of the cards in a standard deck. Then, we iterate 52 times, calling the deck’s Deal method
to get the top card.
As we saw in Chapter 16, we must create a new QTableWidgetItem for each cell in the table.
Because this is a Qt class, we need to convert the string representation of the card’s value
and suit into a QString, which we pass to the QTableWidgetItem’s constructor. Lastly, we use
the table’s setItem method to add the QTableWidgetItem to the given row and column of the
table. The first parameter to the setItem method is the row, and the second parameter is the
column. The third parameter is the QTableWidgetItem containing the QString of the value and
suit of the card.
At this point, we have a table that will be displayed with each card’s value and suit. The
table would normally allow the user to edit the values interactively, but we do not want to allow
editing. The following addition to the InitTable method will disable a QTableWidgetItem for
editing:
Description
The QTableWidgetItem maintains a set of flags that turn certain item properties on or off.

One of those properties is whether the table item is editable. The flags are represented as
an integer, and the above code uses a bitwise AND operator (&) and the complement operator
(~) to unset the editable flag of a widget item.
We’re not going to cover the details of bitwise operations here, but we can explain that the
Qt framework is trying to be efficient when it creates a table (which may contain many items),
and manipulating flags using bitwise operations does save space and time.
Lastly, we want to add a bit of color to the items stored in the table, to help the user more
easily identify the suit of a card. The following code makes the value and suit items red if they
are hearts or diamonds. They default to black, so there is nothing to do for clubs and spades.
Description
If the suit is diamonds or hearts, we create a QBrush with the color red. Each table entry has
a foreground element (the text) and a background (the area around the text). So we set the
foreground color of the cardValueItem and cardSuitItem to red using the brush. (And yes, there
is also a setBackground method that would change the background color.) The complete code
for InitTable is shown here with these additions highlighted:
Description

Description
The code for initializing the label that holds the card image is straightforward and shown
below:
Description
First, we create a new label and set it to be the empty string. Next, we call the DisplayImage
method to display an image within the label. The DisplayImage method is passed the row of a
card in the table to display the corresponding image. In this case, when we initialize the image
label, we display the card in row 0. Now, we look at the DisplayImage method to understand
how this works:
Description
First, we get the text of the value and suit item using the item method of the table. The item
method is passed the row and column, and it returns the QTableWidgetItem object stored in

that location. Next, we use the text method to return the QString contained in the item. The 0
column contains the card value, and the 1 column contains the suit.
We then create a QPixmap object that will read the image into memory. We use the strings to
create the file path for an image file, and pass that to the QPixmap constructor. To make this
work, each image file has a name corresponding to the value and suit. So, if the value is
“ACE” 
and 
the 
suit 
is 
“HEARTS” 
then 
the 
path 
to 
the 
image 
will 
be
“:CardImages/ACE_HEARTS.png”.
The path begins with a colon (:), because the Qt framework requires special handling of
“resources” that are required for an application. In this case, the resources our application
requires are in a folder of images that we want to display, which Qt places in the program’s
working directory. Lastly, we use the setPixmap method of the label to display the image.
Before we do that, we scale the image to 300 × 300 pixels and indicate that we want to keep
the aspect ratio of the image so it doesn’t look stretched in either direction.
The remaining methods are the two event handlers. The HandleClickOnCard method is
simple. When an item in the table is clicked, this event handler is called with the row and
column of the item that was clicked. We pass the row to the DisplayImage method to display
the corresponding card image. Here is the implementation:
Description
The HandleShuffleButtonClicked event handler is also straightforward. When the Shuffle
button is clicked, we simply want to take a deck of cards, shuffle them, remove the cards
from the current table, and display what is in the shuffled deck. Fortunately, we already have a
method that does most of this, the InitTable method. But we need to make a minor addition to
InitTable 
to 
determine 
if 
it 
is 
being 
called 
from 
the 
constructor 
or 
from
HandleShuffleButtonClicked.
If InitTable is called from the constructor, then the table pointer will be set to the nullptr
(the first statement in the constructor). If that is the case, we create a new QTableWidget. If
InitTable is called from the HandleShuffleButtonClicked method, then the table has already
been created, so all we need to do is clear out the contents of the current table and fill it with a
newly shuffled deck. Fortunately, that is exactly what InitTable does. Here is the code for
HandleShuffleButtonClicked:
Description
Here is the final addition to the InitTable method with the new additions highlighted:

Description
Description
The only thing remaining for this GUI application is to instantiate the CardDeckMainWindow in
the main function. This is straightforward. The code for the entire application is shown below:

Description
Description

Description


Description
Description

Testing and Debugging
One of the advantages of working with the STL is that the classes and algorithms it provides
have already been thoroughly tested. It’s easy, however, to let this fact give you a false sense
of security. In this chapter, we’ve been able to touch on only the highlights of the STL; there
are many more features that we haven’t seen. For example, many of the operations and
constructors are overloaded by other versions or have default parameters. A mistake in
writing a call may not trigger a compiler error, but instead call a version of an operation with
which you’re not familiar. If you will work extensively with the STL, it is important to have
access to a complete reference for the STL, and to take the time to understand the
sometimes cryptic notation of templatized functions and parameters.
When testing a program that uses a container, we must watch out for some special cases.
Obviously, attempting to operate on an empty container and going beyond the bounds of the
container are among those situations. Also watch for iterators that are moving in the wrong
direction or by the wrong distance on each step. Popping the first element off of a stack or
queue at the start of a loop results in the equivalent of an off-by-one error, because the first
element of the container is never processed. Be aware of the special properties and boundary
conditions associated with each type of container you are using, and take the time to design
tests that ensure your code is not inadvertently violating them.
Testing and Debugging Hints
1. When accessing a container, remember that the values returned by end and rend point
outside of the structure.
2. An iterator must be dereferenced to obtain the value it points to.
3. When declaring an iterator, remember that it must be qualified by the type that it will
point to—for example, list<string>::iterator.
4. Forward iterators are incremented to advance them and decremented to move them
backward. Reverse iterators move backward when they are incremented.
5. Whenever the underlying structure of a container changes, its iterators become invalid.
Accessing an invalid iterator after an insertion or deletion operation will cause errors.
6. Whenever you are deleting elements from a container, make sure that you check
whether it is empty.
7. Keep in mind that not all algorithms work with all containers. Check the documentation
carefully.
8. Remember to copy the top element of a stack or queue before you pop it.
9. Choose a container that has the functionality you need. Additional capability often
comes at a cost in performance.

10. Many of the containers require that user-defined element types support some subset
of the relational operators. Be sure that your classes provide this support.

Summary
In this chapter, we explored the realm of data structures beyond arrays and singly linked
lists. Along the way we encountered vectors, bidirectional lists, stacks, queues, priority
queues, deques, trees, graphs, hash tables, sets, and maps. The programming universe
is full of other data structures, to the point that the options can sometimes feel
overwhelming. Always keep in mind that there are two sides to every data structure. The
abstract side is the interface that we use to clearly and conveniently solve a problem. The
implementation side is chosen for efficiency of operation. It is usually possible to wrap an
implementation within an interface in such a manner that we obtain the best of both worlds.
In the end, almost any choice of data structure will be a compromise in one way or
another, so the best strategy is to choose the abstract structure that best fits the problem,
and then to determine whether the same or another structure provides the most effective
implementation.
The stack is a structure in which we insert and delete elements at one end. It is useful
when we need to recall information in the order that is the reverse of how it was inserted.
We thus say that a stack is a “last in, first out” (LIFO) structure. The queue is another
linear structure, but in this case elements are added at one end (the back) and removed
from the other end (the front). Therefore, a queue is a “first in, first out” (FIFO) structure.
Queues are often used in simulations of real-world waiting lines. A priority queue inserts
information according to a given ordering, keeping the data sorted and returning them in
order.
Linear structures that have links running in both directions are said to be bidirectional.
We can traverse a bidirectional list from back to front as easily as we can go from front to
back. A second form of bidirectional structure is the double-ended queue, or deque. With it,
we can insert or remove elements at either end.
A binary tree is a branching data structure that has a root node with left and right
subtrees. Each of the subtrees has a pair of links to its own subtrees, and so on. Nodes
that have two NULL links are called leaves. A node with non-NULL links is said to be a
parent, and the nodes directly below it are called its children. By arranging the values in a
binary tree so that every left child’s value is less than its parent’s value, and every right
child’s value is greater than its parent’s value, we create a binary search tree. Finding a
value in a binary search tree containing N values takes log2(N) steps. An in-order traversal
of the tree will visit all of the elements in order; a binary tree may also be traversed in
preorder or postorder. Additional links enable us to build arbitrarily complex networks of
nodes, called graphs.
Hashing is a technique that computes an index for storing and retrieving values in a
structure in roughly constant time. The keys to effective hashing are developing a good
hash function and having enough extra space in the structure to minimize collisions. A
chained hash table uses an array of linked lists, where a collision results in a node being
added to the list associated with the array element where the collision occurred.
Binary search trees and hash tables are often used to implement associative lookup, in
which an arbitrarily complex key value may be used like an index to access associated
data. The set is a structure that stores unique values associatively, enabling us to

determine whether a given value is present in the set. A map extends the idea of a set by
pairing another value with the key so that we can retrieve it once the key has been located.
The C++ Standard Template Library provides templatized classes and functions that
represent many common data structures. Once you understand the principles behind the
STL, working with data structures becomes much easier. However, it is important to be
aware of the underlying properties of the STL classes so that you can choose the ones
that are most appropriate for a given problem.

Quick Check Answers
17.1.1 In problem solving, we want a structure that naturally fits the problem. In
implementation, efficiency is also a concern. 17.1.2 Its abstract form (interface) and its
implementation. 17.2.1 push and pop 17.2.2 FIFO. 17.2.3 How they are accessed. 17.2.4
A simpler interface. 17.2.5 The cars could be ordered by priority where priority is the
pickup time. The car at the front of the priority queue will be the one that will be picked up
the earliest. 17.3.1 A bidirectional list requires twice as many pointers per node and twice
as many pointer manipulation operations for every insert and delete; however, it provides
more flexibility than a unidirectional list. 17.3.2 The dequeue data structure allows us to
insert and delete elements from either end of a queue. 17.4.1 queue<float> nums; 17.4.2
end() 17.4.3 find 17.4.4 The stack pop removes the element at the back; the queue pop
removes the element at the front. 17.4.5 Containers and algorithms. 17.4.6 A generic data
structure that holds an arbitrary number of elements. 17.4.7 The iterator will remain valid
only as long as the contents of the container do not change. 17.4.8 A C++ array. 17.4.9
The vector doesn’t need to have a fixed size. 17.4.10 The size indicates the number of
elements contained in the vector, and the capacity is the maximum number of elements
the vector may hold. 17.5.1 Left subtree, right subtree, root. 17.5.2 The condition in which
the hash function maps two values to the same place in the structure. 17.5.3 A linked data
structure whose nodes contain links to a left and right child node. 17.5.4 A binary search
tree has an additional property where the elements are arranged in a particular order.
17.5.5 The root node. 17.5.6 Hashing. 17.5.7 The hash function would return the value 0 if
the grade is less than 59, 1 if the grade is between 60 and 69, 2 if the grade is between 70
and 79, 3 if the grade is between 80 and 89, and 4 if the grade is between 90 and 100.
17.6.1 A data structure that associates values within it not by their indexes, but by their
values. 17.6.2 A set stores only the key values whereas a map associates a second value
with each key. 17.6.3 The [] operator. 17.6.4 Because it associates key–value pairs and
allows us to look up values using their associated keys. 17.6.5 matches["answer"] = 42;

Exam Preparation Exercises
17.1 Given the following operations on a stack:
Description
a. How many elements are on the stack?
b. What is the value at the top of the stack?
17.2 Given the following operations on a queue:
Description
a. How many elements are in the queue?
b. What is the value at the front of the queue?
17.3 Given the following operations on a priority queue:
Description
a. How many elements are in the priority queue?
b. What is the value at the front of the priority queue?
c. What was the last value popped from the priority queue?
d. Where would the value 4 be inserted in the priority queue?
17.4 Given the following operations on a deque:
Description
a. How many elements are in the deque?
b. What is the value at the front of the deque?
c. What is the value at the back of the deque?
d. Write the current contents of the deque, indicating front and back.
17.5
a. Write an algorithm to perform in-order traversal of a binary tree.
b. Write an algorithm to perform preorder traversal of a binary tree.

c. Write an algorithm to perform postorder traversal of a binary tree.
17.6
a. What is the relationship of the values in the parent node and its two children in
a binary search tree?
b. If a binary search tree contains 63 nodes, what is the maximum time required
to search for a matching value among its nodes?
c. How many leaves are there in a binary search tree with seven nodes?
17.7
a. What problem can result from resolving a collision in a hash table by
incrementing the index and using the next location in the table?
b. What do we mean by the “chain” in a chained hash table?
17.8
a. Is an iterator the same as a pointer? Explain.
b. What happens to an iterator after a deletion from a container?
c. Which operator do you use to advance an iterator?
d. Which operator causes an iterator to move backward?
e. In which direction does a reverse_iterator move when it is incremented?
17.9
a. Which aspect of vector does deque implement?
b. Which aspect of list does deque implement?
c. What happens to a deque when the clear operation is called?
d. What happens to a deque when the erase operation is called?
17.10
a. What are the five operations provided by stack?
b. What are the six operations provided by queue?
17.11
a. What is the difference between the size and capacity of a vector?
b. How does the vector at operator differ from the [] operator?
c. When would you use the reserve operation with a vector?
17.12
a. For map and set, what is returned by the upper_bound operation?
b. Which primary capability does a map add to those of the set?
c. Name three set-theoretic operations from the STL algorithms library.

d. You want a data structure that keeps track of whether shareholders are
present at a corporate meeting. Would you choose a map or a set? Explain.

Programming Warm-Up Exercises
17.1 Given the following vector initialization:
Description
What is output by each of the following code segments?
Description
17.2 Given the following list initialization:
Description
What is output by each of the following code segments?

Description
17.3 Given the following deque initialization:
Description
What is output by each of the following code segments?

Description
17.4 Given the following list initialization:
Description
What is wrong with the following statement?
Description
17.5 Given the following stack operations:
Description
What is output?
17.6 Given the following queue operations:

Description
What is output?
17.7 Given the following priority_queue operations:
Description
What is output?
17.8
a. Write the declaration for a vector of int values, initialized to the numbers 1
through 10. You will need to define an array as part of the initialization process.
b. Write the declaration for an empty deque of int values.
c. Write statements that twice copy the contents of the vector declared in part
17.8a into the deque declared in part 17.8b. The first time, the elements should be
pushed in order at the back of the deque; the second time, they should be pushed
at the front so that they are in reverse order within the deque. Afterward, the
values of front and back, as applied to the deque, should both be 10, and the size
of the deque should be 20.
d. Assuming the operations in part 17.8c have been performed, write statements
to output the size of the deque, its first and last elements, and the values in
locations 9 and 10.
e. Assuming the operations in part 17.8c have been performed, write a loop that
pops an element from both ends of the deque on each iteration and outputs these
values in two columns. The loop terminates when the deque is empty.
17.9
a. Write the declarations for three set containers that can hold int values.
Initialize the first set to hold the odd numbers in the range 1 through 9. Initialize
the second set to hold the even numbers from 2 to 10.

b. Given the declarations in part 17.9a, write statements to store their difference
in the third set, and then output the contents of the third set. Does it matter
whether you pass the first set or the second set as the first argument to the
difference algorithm? That is, would the output differ if their places were reversed
in the call?
c. Given the declarations in part 17.9a, write statements to store the intersection
of the first two set s in the third set and then output its contents.
d. Given the declarations in part 17.9a, write statements to store the union of the
first two set s in the third set and then output its contents.
17.10
a. Write the declaration for a map that associates values of type long int with
values of type string. The long int will be the key (index), and the string will be
its associated data. You can imagine this data structure as holding Social
Security numbers (SSNs) and names.
b. Write a simple driver that inputs 10 SSNs, with corresponding names, and
stores them in the map declared in part 17.10a. It should then allow the user to
input an SSN, after which the matching name is output. Be sure that you handle
cases of SSNs that aren’t in the map.
c. Given the use of the map in part 17.10b, explain why it is a better choice of data
structure than an array indexed by the SSN.
17.11
a. Which STL algorithm would you use to search through a list?
b. If you want to convert a string to uppercase, which STL algorithm makes that
task easier?
c. You want to rearrange the elements of list into random order. Which STL
algorithm can take care of this task for you?
d. You want to search through a deque of int values, replacing every occurrence
of 21 with 18. Which STL algorithm would be a good choice?

Programming Problems
17.1 Write a program that will allow the user to evaluate postfix expressions. A postfix
expression is an arithmetic expression where the operator occurs after the
expression. For example, using infix notation we would add 4 and 5 using 4 + 5. In
postfix notation we would arrange the operator to occur at the end: 4 5 +. A postfix
expression can become arbitrarily complex such as 3 4 5 + – 2 *. This expression
would be expressed using infix notation like this: ((4 + 5) – 3) * 2. As you can see,
the postfix form does not require parentheses because the order of operations is
made explicit. It turns out that evaluating postfix expressions is quite easy when
combined with a stack data structure. We read a postfix expression from left to right,
pushing values onto the stack when a number is encountered and popping numbers
from the stack when an operator is encountered. For example, the expression 4 5 +
would require the following operations:
1. Push 4 onto the stack.
2. Push 5 onto the stack.
3. Pop the top two values off the stack, add them, and then push the result back
onto the stack.
Your program should support the basic arithmetic operators such as +, –, *, and / for
addition, subtraction, multiplication, and division. It should also provide the operator ^,
which pops the top value off the stack and outputs it to the console.
17.2 Extend Problem 17.1 above to allow multiline postfix expressions that may
include variables. For example, we would like to evaluate the following postfix
expression:
Description
The result of evaluating these expressions would be the value 27 output to the console.
You should continue to use a stack to implement your postfix evaluator. To implement
variables, you should use the map data structure from the STL to map variable names (e.g.,
X) to integer values. You should extend your postfix evaluator to support variables such
that when a variable is encountered from the input, it should pop the current value off the
top of the stack and associate it with that variable in the map. If the variable is preceded by

a '$', the postfix evaluator should simply retrieve the variable’s associated value from the
map and push it onto the stack. You should use exceptions to handle erroneous input from
the user.
17.3 You are registering people for a campus club that charges dues. New members
receive a discount, and returning members pay the full fee. You have a file that
contains the ID numbers (which are integers) of existing members, and a file
containing the ID numbers for people who have signed up for this year. Write an
application that determines which of the people who have signed up for this year are
new members and which are returning members. The application should combine the
two files so that there are no duplicates and write the result out as a new file of
existing members. It should also write out three additional files: the first contains the
ID numbers of past members who did not return, the second contains the ID numbers
of returning members, and the third contains the ID numbers of new members.
17.4 A local movie theater has three ticket windows and two computerized ticket
kiosks. Some transactions, such as group discounts, can only be done at the ticket
windows. An arriving customer looks at the lines and chooses to stand in the shortest
one that can handle their transaction. Group sales take four minutes to process.
Normal ticket sales take two minutes at a window or three minutes at a kiosk. Internet
ticket sales pickups take one minute at a kiosk or two minutes at a window. Write a
simulation of this process, using queues to represent the five lines. The data set
should consist of randomly arranged customer arrivals, with 5% group sales, 20%
Internet ticket sales pickups, and 75% regular ticket sales. A data set will contain 200
customers. All of the customers tend to arrive shortly before the start of a movie, so
we are simplifying the simulation to say that they all arrive at the same time. From this
simulation, the theater wants you to determine the maximum length of each line, the
average waiting time for each line, and the time required for each line to empty.
As a hint, think about using a list to create the data set by adding 10 group, 40 Internet,
and 150 regular customers and then shuffling the list. The list is then traversed,
transferring each customer to the shortest queue that can handle the customer’s
transaction.
17.5 Implement the shopping cart simulation described in Section 17.2 so that it runs
for a specified number of minutes. A counter can be used to keep track of the current
minute in the simulation. Each time the counter advances, the simulation code
handles all of the actions to be performed during that minute. You can use a stack to
represent the column of waiting carts, and a priority queue to represent the active
carts. Each Cart object should keep track of the total time it has been active. Use the
random-number generator to determine how many minutes (1 to 60) that a cart will be
active when it is taken out and how many customers take carts out in each minute.

Keep in mind that the priority queue pops the element with the greatest value, so you
will want the Cart object’s < operator to indicate that carts with a later return time have
lower values. One way to do so is to represent the time as a negative number. For
example, a simulation of 1000 minutes would start at –1 and end at –1000. When a
cart is taken out, its return time becomes the current minute minus the time it will be
active. That way, the cart at the head of the priority queue will have the return time that
is earliest in the simulation.
At the start of every minute, check the front of the priority queue to see if the front cart’s
return time is the same as the current minute, and move it back to the stack. Be sure to
check for more than one cart being returned in a given minute. Then determine the number
of carts to be taken out during that minute and their activity times, and push them into the
priority queue. Remember to watch out for empty container situations. At the end of the
simulation, any carts that remain active should be transferred back to the stack. Then, for
each cart, output its ID number and total activity time.
17.6 An application is needed to keep track of shareholders at an annual corporate
meeting. The application takes as input a file containing the shareholder names. When
a shareholder arrives, their name is checked against the list for permission to enter
the meeting. That name is then moved to a list of those present, which management
can request to see at any time. If the person leaves the meeting, their name should be
moved from the present list back to the shareholder list. We’ve described these data
structures as lists, but it should be apparent that a set is also a natural way of
representing the data, given that the only operations are to search the set and move
names in and out. You can also use the Name class that we developed for this text, but
the ComparedTo function should be replaced with overloaded relational operators.
17.7 In Programming Problem 7.2 involved an application to compute a person’s
weight on a different planet. Reimplement the application using a map, so that the
planet’s name (a string) can be used to retrieve the weight multiplication factor (a
float).
17.8 Use the Deck class developed in this chapter as part of implementing a program
that allows the user to play a game of solitaire. A list is a natural way to represent the
columns of cards, because it provides an operator called splice that lets us move
ranges of elements from one list to another. Here’s an example call:
The result of the call is that the elements of the column3 list, starting from the one
pointed to by the iterator place and going to its end, are removed from column3 and inserted
at the end of column5. The Deck class will provide a convenient way to deal out the initial
arrangement, and the Card class can be used to create the list elements.

Case Study Follow-Up
1. Expand the test driver for the Deck class so that it exercises the relational operators
supported by Deck, Suits, and Values.
2. Implement the remaining relational operators for the Suits and Values classes.
3. Some card games involve shuffling multiple decks. Add a parameterized
constructor to the Deck class that lets the caller specify how many standard 52-card
decks should be in the working deck.
4. Add support for begin and end operations that return iterators to the ends of the
deck. Also implement overloading of the [] operator to enable access to deck
elements. You can do so by simply calling the corresponding operators in the
underlying deque.
5. After completing Exercise 4, implement a driver that lets you issue various
commands to the deck: deal a given number of cards, reshuffle the deck, and view
the current contents of the deck.
6. Write a simulation that empirically determines the odds of being dealt four of a kind
in a five-card hand. As input, it should take the number of hands to try. Note that if
more than 10 hands are requested, the program will have to create a new deck after
50 cards have been dealt. You may have to simulate thousands of hands to get
significant results. For each hand, check whether four cards with the same value are
present, and increment a count. At the end, divide the total number of hands by this
count to get the odds. For example, if the result is 35, you can report the odds as 1 in
35 hands.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.

C H A P T E R  1 8
Recursion
KNOWLEDGE GOALS
To understand the concept of a recursive definition.
To understand the difference between iteration and recursion.
To understand the distinction between the base case(s) and the general case in a
recursive definition.
SKILL GOALS
To be able to:
Write a recursive algorithm for a problem involving only simple variables.
Write a recursive algorithm for a problem involving structured variables.
In C++, any function can call another function. A function can even call itself! When a
function calls itself, it is making a recursive call. The word recursive means “having the
characteristic of coming up again, or repeating.” In this case, a function call is being repeated
by the function itself. Recursion is a powerful technique that can be used in place of iteration
(looping).
Recursive call A function call in which the function being called is the same as the one
making the call.
Recursive solutions are generally less efficient than iterative solutions to the same problem.
However, some problems lend themselves to simple, elegant, recursive solutions and are
exceedingly cumbersome to solve iteratively. Some programming languages, such as early
versions of Fortran, Basic, and COBOL, do not allow recursion. Other languages are
especially oriented to recursive algorithms—LISP is one of these. C++ lets us take our
choice: We can implement both iterative and recursive algorithms.

Our examples are broken into two groups: problems that use only simple variables and
problems that use structured variables. If you are studying recursion before reading Chapters
11–16 on structured data types, then cover only the first set of examples and leave the rest
until you have completed the chapters on structured data types.

18.1 What Is Recursion?
You may have seen a set of gaily painted Russian dolls that fit inside one another. Inside the
first doll is a smaller doll, inside of which is an even smaller doll, inside of which is yet a
smaller doll, and so on. A recursive algorithm is like such a set of Russian dolls. It reproduces
itself with smaller and smaller examples of itself until a solution is found—that is, until there
are no more dolls. The recursive algorithm is implemented by using a function that makes
recursive calls to itself.
In Chapter 9, we wrote a function named Power that calculates the result of raising an integer
to a positive power. If X is an integer and N is a positive integer, the formula for XN is
Description
We could also write this formula as
Description
or even as
Description
In fact, we can write the formula most concisely as
Description
This definition of XN is a classic recursive definition—that is, a definition given in terms of
a smaller version of itself.
Recursive definition A definition in which something is defined in terms of smaller
versions of itself.
XN is defined in terms of multiplying X × X
N−1. How is X
N−1 defined? Why, as X × X
N−2, of
course! And X
N−2 is X × X
N−3; X
N−3 is X × X
N−4; and so on. In this example, “in terms of smaller
versions of itself ” means that the exponent is decremented each time.

When does the process stop? When we have reached a case for which we know the
answer without resorting to a recursive definition. In this example, it is the case where N
equals 1: X1 is X. The case (or cases) for which an answer is explicitly known is called the
base case. The case for which the solution is expressed in terms of a smaller version of itself
is called the recursive or general case. A recursive algorithm is an algorithm that
expresses the solution in terms of a call to itself, a recursive call. A recursive algorithm must
terminate; that is, it must have a base case.
Base case The case for which the solution can be stated nonrecursively.
General case The case for which the solution is expressed in terms of a smaller version
of itself; also known as the recursive case.
Recursive algorithm A solution that is expressed in terms of (1) smaller instances of
itself and (2) a base case.
The following program shows a recursive version of the Power function with the base case
and the recursive call marked. The function is embedded in a program that reads in a number
and an exponent and outputs the result.

Description
Each recursive call to Power can be thought of as creating a completely new copy of the
function, each with its own copies of the parameters x and n. The value of x remains the same
for each version of Power, but the value of n decreases by 1 for each call until it becomes 1.
Let’s trace the execution of this recursive function, with number equal to 2 and exponent
equal to 3. We use a new format to trace recursive routines: We number the calls and then
discuss what is happening in paragraph form.
Call 1: Power is called by main, with number equal to 2 and exponent equal to 3. Within
Power, the parameters x and n are initialized to 2 and 3, respectively. Because n is not
equal to 1, Power is called recursively with x and n − 1 as arguments. Execution of Call 1
pauses until an answer is sent back from this recursive call.
Call 2: x is equal to 2 and n is equal to 2. Because n is not equal to 1, the function Power is
called again, this time with x and n − 1 as arguments. Execution of Call 2 pauses until an
answer is sent back from this recursive call.

Call 3: x is equal to 2 and n is equal to 1. Because n equals 1, the value of x is to be
returned. This call to the function has finished executing, and the function return value
(which is 2) is passed back to the place in the statement from which the call was made.
Call 2: This call to the function can now complete the statement that contained the
recursive call because the recursive call has returned. Call 3’s return value (which is 2) is
multiplied by x. This call to the function has finished executing, and the function return
value (which is 4) is passed back to the place in the statement from which the call was
made.
Call 1: This call to the function can now complete the statement that contained the
recursive call because the recursive call has returned. Call 2’s return value (which is 4) is
multiplied by x. This call to the function has finished executing, and the function return
value (which is 8) is passed back to the place in the statement from which the call was
made. Because the first call (the nonrecursive call in main) has now completed, this is the
final value of the function Power.
This trace is summarized in FIGURE 18.1. Each box represents a call to the Power function.
The values for the parameters for that call are shown in each box.
FIGURE 18.1 Execution of Power(2,3)
Description
What happens if there is no base case? We have infinite recursion, the recursive
equivalent of an infinite loop. For example, if the condition
Description

were omitted, Power would be called over and over again. Infinite recursion also occurs if Power
is called with n less than or equal to 0.
Infinite recursion The situation in which a function calls itself over and over endlessly.
In actuality, recursive calls cannot go on forever. Here’s the reason: When a function is
called, either recursively or nonrecursively, the computer system creates temporary storage
for the parameters and the function’s (automatic) local variables. This temporary storage is a
region of memory called the run-time stack. When the function returns, its parameters and
local variables are released from the run-time stack. With infinite recursion, the recursive
function calls never return. Each time the function calls itself, a little more of the run-time stack
is used to store the new copies of the variables.
Eventually, all the memory space on the stack is used. At that point, the program crashes
with an error message such as “Run-time stack overflow” (or the computer may simply
hang).
QUICK CHECK
18.1.1 Which case causes a recursive algorithm to end its recursion: the base case
or the general case?
18.1.2 What is a recursive definition?
18.1.3 What is a recursive algorithm?
18.1.4 What happens if a recursive function does not have a base case?

18.2 Recursive Algorithms with Simple Variables
Let’s look at another example: calculating a factorial. The factorial of a number N (written N!)
is N multiplied by N − 1, N − 2, N − 3, and so on. Another way of expressing factorial is
Description
This expression looks like a recursive definition. (N − 1)! is a smaller instance of N!—that
is, it takes one less multiplication to calculate (N − 1)! than it does to calculate N! If we can
find a base case, we can write a recursive algorithm. Fortunately, we don’t have to look too
far: 0! is defined in mathematics to be 1.
Description
This algorithm can be coded directly as follows:
Description
Let’s trace this function with an original n of 4.
Call 1: n is 4. Because n is not 0, the else branch is taken. The Return statement cannot be
completed until the recursive call to Factorial with n - 1 as the argument has been
completed.
Call 2: n is 3. Because n is not 0, the else branch is taken. The Return statement cannot be
completed until the recursive call to Factorial with n - 1 as the argument has been
completed.
Call 3: n is 2. Because n is not 0, the else branch is taken. The Return statement cannot be
completed until the recursive call to Factorial with n - 1 as the argument has been
completed.

Call 4: n is 1. Because n is not 0, the else branch is taken. The Return statement cannot be
completed until the recursive call to Factorial with n - 1 as the argument has been
completed.
Call 5: n is 0. Because n equals 0, this call to the function returns, sending back 1 as the
result.
Call 4: The Return statement in this copy can now be completed. The value to be returned
is n (which is 1) times 1. This call to the function returns, sending back 1 as the result.
Call 3: The Return statement in this copy can now be completed. The value to be returned
is n (which is 2) times 1. This call to the function returns, sending back 2 as the result.
Call 2: The Return statement in this copy can now be completed. The value to be returned
is n (which is 3) times 2. This call to the function returns, sending back 6 as the result.
Call 1: The Return statement in this copy can now be completed. The value to be returned
is n (which is 4) times 6. This call to the function returns, sending back 24 as the result.
Because this is the last of the calls to Factorial, the recursive process is over. The value 24
is returned as the final value of the call to Factorial with an argument of 4.
FIGURE 18.2 summarizes the execution of the Factorial function with an argument of 4.
FIGURE 18.2 Execution of Factorial(4)
Description

Let’s organize what we have done in these two solutions into an outline for writing recursive
algorithms:
1. Understand the problem. (We threw this one in for good measure; it is always the first
step.)
2. Determine the base case(s).
3. Determine the recursive case(s).
We have used the factorial and the power algorithms to demonstrate recursion because
they are easy to visualize. In practice, one would never want to calculate either of these
functions using the recursive solution. In both cases, the iterative solutions are simpler and
much more efficient because starting a new iteration of a loop is a faster operation than calling
a function. Let’s compare the code for the iterative and recursive versions of the factorial
problem.
Description
Description
The iterative version has two local variables, whereas the recursive version has none.
There are usually fewer local variables in a recursive routine than in an iterative routine. Also,
the iterative version always has a loop, whereas the recursive version always has a selection
statement—either an If or a Switch. A branching structure is the main control structure in a
recursive routine. A looping structure is the main control structure in an iterative routine.

In the next section, we examine a more complicated problem—one in which the recursive
solution is not immediately apparent.
QUICK CHECK
18.2.1 In writing a recursive algorithm that computes the factorial of N, what would
you use as the base case? What would be the general case?
18.2.2 What are the steps for outlining a recursive algorithm?

18.3 Towers of Hanoi
One of your first toys may have been three pegs with colored circles of different diameters. If
so, you probably spent countless hours moving the circles from one peg to another. If we put
some constraints on how the circles or discs can be moved, we have an adult game called
the Towers of Hanoi. When the game begins, all the circles are on the first peg in order by
size, with the smallest on the top. The object of the game is to move the circles, one at a time,
to the third peg. The catch is that a circle cannot be placed on top of one that is smaller in
diameter. The middle peg can be used as an auxiliary peg, but it must be empty at the
beginning and at the end of the game.
To get a feel for how this might be done, let’s look at some sketches of what the
configuration must be at certain points if a solution is possible. We use four circles or discs.
Here is the beginning configuration:
Description
To move the largest circle (circle 4) to peg 3, we must move the three smaller circles to peg 2.
Then circle 4 can be moved into its final place:
Description
Let’s assume we can do this. Now, to move the next largest circle (circle 3) into place, we
must move the two circles on top of it onto an auxiliary peg (peg 1 in this case):
Description
To get circle 2 into place, we must move circle 1 to another peg, freeing circle 2 to be
moved to its place on peg 3:

Description
The last circle (circle 1) can now be moved into its final place, and we are finished:
Description
Notice that to free circle 4, we had to move three circles to another peg. To free circle 3, we
had to move two circles to another peg. To free circle 2, we had to move one circle to another
peg. This sounds like a recursive algorithm: To free the nth circle, we have to move n − 1
circles. Each stage can be thought of as beginning again with three pegs, but with one less
circle each time. Let’s see if we can summarize this process, using n instead of an actual
number.
Get n Circles Moved from Peg 1 to Peg 3
Get n–1 circles moved from peg1 to peg2
Move nth circle from peg1 to peg3
Get n–1 circles moved from peg2 to peg3
This algorithm certainly sounds simple; surely there must be more. But this really is all
there is to it.
Let’s write a recursive function that implements this algorithm. We can’t actually move
discs, of course, but we can display a message to do so. Notice that the beginning peg, the
ending peg, and the auxiliary peg keep changing during the algorithm. To make the algorithm
easier to follow, we call the pegs beginPeg, endPeg, and auxPeg. These three pegs, along with
the number of circles on the beginning peg, are the parameters of the function.
We have the recursive or general case, but what about a base case? How do we know when
to stop the recursive process? The clue is in the statement “Get n circles moved.” If we don’t
have any circles to move, we don’t have anything to do. We are finished with that stage.
Therefore, when the number of circles equals 0, we do nothing (that is, we simply return).

Description
It’s hard to believe that such a simple algorithm actually works, but we’ll prove it to you.
Following is a driver program that calls the DoTowers function. Output statements have been
added so you can see the values of the arguments with each recursive call. Because there
are two recursive calls within the function, we have indicated which recursive statement
issued the call.


Description
The output from a run with three circles follows. “Original” means that the parameters listed
beside it are from the nonrecursive call, which is the first call to DoTowers. “From first” means
that the parameters listed are for a call issued from the first recursive statement. “From
second” means that the parameters listed are for a call issued from the second recursive
statement. Notice that a call cannot be issued from the second recursive statement until the
preceding call from the first recursive statement has completed execution.

Description
QUICK CHECK
18.3.1 What is the base case in the recursive solution to the Tower of Hanoi problem?
18.3.2 How many recursive calls are in the recursive solution to the Tower of Hanoi
problem, and what do they do?

18.4 Recursive Algorithms with Structured Variables
In our definition of a recursive algorithm, we said there were two cases: the recursive or
general case, and the base case for which an answer can be expressed nonrecursively. In the
general case for all our algorithms so far, an argument was expressed in terms of a smaller
value each time. When structured variables are used, the recursive case is often given in
terms of a smaller structure rather than a smaller value; the base case occurs when there are
no values left to process in the structure.
Let’s examine a recursive algorithm for printing the contents of a one-dimensional array of n
elements to show what this means.
Description
The recursive case is to output the values in an array that is one element “smaller”; that is, the
size of the array decreases by 1 with each recursive call. The base case is when the size of
the array becomes 0—that is, when there are no more elements to output.
Our arguments must include the index of the first element (the one to be output). How do
we know when there are no more elements to print (that is, when the size of the array to be
output is 0)? We know we have output the last element in the array when the index of the next
element to be output is beyond the index of the last element in the array. Therefore, the index
of the last array element must be passed as an argument. We call these indexes first and
last. When first is greater than last, we are finished. The name of the array is data.
Description
Here is a code walk-through of the function call
Description

using the pictured array:
Description
Call 1: first is 0 and last is 4. Because first is less than last, the value in data[first]
(which is 23) is output. Execution of this call pauses while the array from first + 1 through
last is output.
Call 2: first is 1 and last is 4. Because first is less than last, the value in data[first]
(which is 44) is output. Execution of this call pauses while the array from first + 1 through
last is output.
Call 3: first is 2 and last is 4. Because first is less than last, the value in data[first]
(which is 52) is output. Execution of this call pauses while the array from first + 1 through
last is output.
Call 4: first is 3 and last is 4. Because first is less than last, the value in data[first]
(which is 61) is output. Execution of this call pauses while the array from first + 1 through
last is output.
Call 5: first is 4 and last is 4. Because first is equal to last, the value in data[first]
(which is 77) is output. Execution of this call pauses while the array from first + 1 through
last is output.
Call 6: first is 5 and last is 4. Because first is greater than last, the execution of this call
is complete. Control returns to the preceding call.
Call 5: Execution of this call is complete. Control returns to the preceding call.
Calls 4, 3, 2, and 1: Each execution is completed in turn, and control returns to the
preceding call.
Notice that once the deepest call (the call with the highest number) was reached, each of
the calls before it returned without doing anything. When no statements are executed after the
return from the recursive call to the function, the recursion is known as tail recursion. Tail
recursion often indicates that the problem could be solved more easily using iteration. We
used the array example because it made the recursive process easy to visualize; in practice,
an array should be output iteratively.
Tail recursion A recursive algorithm in which no statements are executed after the return
from the recursive call.

FIGURE 18.3 shows the execution of the Print function with the values of the parameters
for each call. Notice that the array gets smaller with each recursive call (data[first] through
data[last]). If we want to output the array elements in reverse order recursively, we can just
interchange the two statements within the If statement.
Description
FIGURE 18.3 Execution of Print(data, 0, 4)

SOFTWARE MAINTENANCE CASE STUDY
Substituting Binary Search for Linear
Search
MAINTENANCE TASK: In Chapter 13, we presented two algorithms that are often applied
to values in an array: sorting and searching. If the values in an array are sorted, there is a
better searching algorithm: binary search. Replace the sequential search used in the
searching example in Chapter 13 with a binary search.
CHANGES: Here is a skeleton of that program to remind us of the processing. The
function prototype and function call that are to be replaced are shaded. These clearly must
be changed.
Description
Are any other changes needed? Yes: The words in the array must be sorted if the binary
search algorithm is to be used. We can use the selection sort from Chapter 13. We simply
need to change the data type of the values to be sorted from int to string.
BINARY SEARCH ALGORITHM: Now let’s look at the binary search algorithm itself.
Think of how you might go about finding a word in a dictionary, and you can get an idea of a
faster way to search. Let’s look for the word “dimple.” We open the dictionary to the middle

and see that the words there begin with M. M is larger than D, so we search the first half of
the dictionary, the section that contains A to M. We turn to the middle of the first half and
see that the words there begin with G. G is larger than D, so we search the first half of this
section, from A to G. We turn to the middle page of this section, and find that the words
there begin with C. C is smaller than D, so we search the second half of this section—that
is, from D to G—and so on, until we are down to the single page that contains the word
“dimple.” This algorithm is illustrated in FIGURE 18.4.
FIGURE 18.4 A Binary Search of a Dictionary
Description

How can we translate this algorithm into operations on an array? We can define two
integer values first and last that bracket the portion of the array where we are looking.
We then compute the index of the middle item (middle) and compare the value at that
place to the item we are looking for. If the values are the same, we have found the location
of the item. If the value in that place is greater, we then look in the array from first to
middle-1. If the value in that place is less, we look in the array from middle+1 to last. How
do we know when the value isn’t there? When first is greater than last, we know the item
is not in the array.
Let’s express the algorithm in terms of our problem: searching for a word in an array of
words.
Description
This certainly looks like a recursive solution. There are two base cases: when we find
the item and when we know it isn’t there. What is the general case? There are two: when
we look in the first half and when we look in the last half. So the two statements “Search . .
.” become calls to the same binary search algorithm with changing parameters. Here is
the revised program and the results.



Description
Input file: Words.in
Description
Interactive input:

Description
QUICK CHECK
18.4.1 In writing a recursive algorithm that outputs the values in an array, what would
you use as the base case? What would be the general case?
18.4.2 What is tail recursion?
18.4.3 What does tail recursion often indicate about a problem?

18.5 Recursion Using Pointer Variables
The recursive algorithm for outputting a one-dimensional array could have been implemented
much more easily using iteration. Now we look at two algorithms that cannot be handled more
easily with iteration: printing a linked list in reverse order and creating a duplicate copy of a
linked list. We call the external pointer to the list listPtr.
Printing a Dynamic Linked List in Reverse Order
Description
Printing a linked list in order from first to last is easy. We set a running pointer (ptr) equal to
listPtr and cycle through the list until ptr becomes NULL.
Description
To output the list in reverse order, we must output the value in the last node first, then the
value in the next-to-last node, and so on. Another way of expressing this process is to say
that we do not output a value until the values in all the nodes following it have been output. We
might visualize the process as the first node turning to its neighbor and saying, “Tell me when
you have output your value. Then I’ll output my value.” The second node says to its neighbor,
“Tell me when you have output your value. Then I’ll output mine.” That node, in turn, says the
same to its neighbor, and so on, until there is nothing to output.
Because the number of neighbors gets smaller and smaller, we seem to have the makings
of a recursive solution. The end of the list is reached when the running pointer is NULL. When
that happens, the last node can output its value and send the message back to the one before
it. That node can then output its value and send the message back to the one before it, and so
on.

Description
This algorithm can be coded directly as the following function:
Description
This algorithm seems complex enough to warrant a code walk-through. We use the
following list:
Description
Call 1: listPtr points to the node containing 45 and is not NULL. Execution of this call
pauses until the recursive call with the argument listPtr->link has been completed.
Call 2: listPtr points to the node containing 78 and is not NULL. Execution of this call
pauses until the recursive call with the argument listPtr->link has been completed.
Call 3: listPtr points to the node containing 1066 and is not NULL. Execution of this call
pauses until the recursive call with the argument listPtr->link has been completed.
Call 4: listPtr points to the node containing 1492 and is not NULL. Execution of this call
pauses until the recursive call with the argument listPtr->link has been completed.
Call 5: listPtr is NULL. Execution of this call is complete. Control returns to the preceding
call.
Call 4: listPtr->component (which is 1492) is output. Execution of this call is complete.
Control returns to the preceding call.
Call 3: listPtr->component (which is 1066) is output. Execution of this call is complete.
Control returns to the preceding call.

Call 2: listPtr->component (which is 78) is output. Execution of this call is complete. Control
returns to the preceding call.
Call 1: listPtr->component (which is 45) is output. Execution of this call is complete.
Because this is the nonrecursive call, execution continues with the statement immediately
following RevPrint(listPtr).
FIGURE 18.5 shows the execution of the RevPrint function. The parameters are pointers
(memory addresses), so we use ⟶ 45 to mean the pointer to the node whose component is
45.
FIGURE 18.5 Execution of RevPrint
Description
Copying a Dynamic Linked List
When working with linked lists, we sometimes need to create a duplicate copy (sometimes
called a clone) of a linked list. For example, in Chapter 14, we wrote a copy-constructor for the
List class. This copy-constructor creates a new class object that is a copy of another class
object, including its dynamic linked list.
Suppose that we want to write a value-returning function that receives the external pointer to
a linked list (listPtr), makes a clone of the linked list, and returns the external pointer to the
new list as the function value. A typical call to the function would be the following:

Description
Using iteration to copy a linked list is rather complicated. The following algorithm is
essentially the same as the one used in the List copy-constructor.
Description
A recursive solution to this problem is far simpler, but it requires us to think recursively. To
copy the first node of the original list, we can allocate a new dynamic node and copy the
component value from the original node into the new node. However, we cannot yet fill in the
link member of the new node: We must wait until we have copied the second node, so that
we can store its address into the link member of the first node. Likewise, the copying of the
second node cannot complete until we have finished copying the third node. Eventually, we
copy the last node of the original list and set the link member of the copy node to NULL. At this
point, the last node returns its own address to the next-to-last node, which stores the address
into its link member. The next-to-last node returns its own address to the node before it, and
so forth. The process is complete when the first node returns its address to the first
(nonrecursive) call, yielding an external pointer to the new linked list.

Description
Like the solution to the Towers of Hanoi problem, this scheme looks too simple—yet it is the
full algorithm. Because the argument that is passed to each recursive call is fromPtr>link, the
number of nodes left in the original list becomes smaller with each call. The base case occurs
when the pointer into the original list becomes NULL. Following is the C++ function that
implements this algorithm.
Description
Let’s perform a code walk-through of the function call
Description
using the following list:

Description
Call 1: fromPtr points to the node containing 49 and is not NULL. A new node is allocated and
its component value is set to 49.
Description
Execution of this call pauses until the recursive call with the argument fromPtr->link has
been completed.
Call 2: fromPtr points to the node containing 50 and is not NULL. A new node is allocated and
its component value is set to 50.
Description
Execution of this call pauses until the recursive call with the argument fromPtr->link has
been completed.
Call 3: fromPtr points to the node containing 58 and is not NULL. A new node is allocated and
its component value is set to 58.

Description
Execution of this call pauses until the recursive call with the argument fromPtr->link has
been completed.
Call 4: fromPtr is NULL. The list is unchanged.
Description
Execution of this call is complete. NULL is returned as the function value to the preceding
call.
Call 3: Execution of this call resumes by assigning the returned function value (NULL) to
toPtr->link.
Description
Execution of this call is complete. The value of toPtr is returned to the preceding call.
Call 2: Execution of this call resumes by assigning the returned function value (the address
of the third node) to toPtr->link.
Description
Execution of this call is complete. The value of toPtr is returned to the preceding call.
Call 1: Execution of this call resumes by assigning the returned function value (the address
of the second node) to toPtr->link.

Description
Execution of this call is complete. Because this is the nonrecursive call, the value of toPtr
is returned to the assignment statement containing the original call. The variable newListPtr
now points to a copy of the original list.
QUICK CHECK
18.5.1 In writing a recursive algorithm that outputs the values in a linked list in reverse
order, what would you use as the base case? What would be the general case?

18.6 Recursion or Iteration?
Recursion and iteration are alternative ways of expressing repetition in a program. When
iterative control structures are used, processes are made to repeat by embedding code in a
looping structure such as a While, For, or Do-While. In recursion, a process is made to repeat
by having a function call itself; a selection statement is used to control the repeated calls.
Which is the better approach—recursion or iteration? There is no simple answer to this
question. The choice usually depends on two issues: efficiency and the nature of the problem
being solved.
Historically, the quest for efficiency, in terms of both execution speed and memory usage,
has favored iteration over recursion. Each time a recursive call is made, the system must
allocate stack space for all parameters and (automatic) local variables. The overhead
involved in any function call is time-consuming. On early, slow computers with limited
memory capacity, recursive algorithms were visibly—sometimes painfully—slower than the
iterative versions. By contrast, on modern, fast computers, the overhead of recursion is often
so small that the increase in computation time is almost unnoticeable to the user. Except in
cases where efficiency is absolutely critical, then, the choice between recursion and iteration
more often depends on the second issue—the nature of the problem being solved.
Consider the factorial and power algorithms discussed earlier in this chapter. In both cases,
iterative solutions were obvious and easy to devise. We imposed recursive solutions on these
problems simply to demonstrate how recursion works. As a rule of thumb, if an iterative
solution is more obvious or easier to understand, use it; it will be more efficient. In some other
problems, the recursive solution is more obvious or easier to devise, such as in the Towers of
Hanoi problem. (It turns out that the Towers of Hanoi problem is surprisingly difficult to solve
using iteration.) Computer science students should be aware of the power of recursion. If the
definition of a problem is inherently recursive, then a recursive solution should certainly be
considered.
QUICK CHECK
18.6.1 What factor dictates an iterative solution to an algorithm versus a recursive
one?
Problem-Solving Case Study
QUICKSORT
PROBLEM: Throughout the last half of this book, we have worked with lists of items, both
sorted and unsorted. At the logical level, sorting algorithms take an unsorted list and
convert it into a sorted list. At the implementation level, sorting algorithms take an array

and reorganize the data into some ordering. We have used straight selection to sort a list
of numbers, and we have inserted entries into place in a list ordered by time. In this case
study, we will create a function template that implements the Quicksort algorithm.
DISCUSSION: The Quicksort algorithm, which was developed by C. A. R. (Tony) Hoare,
is based on the idea that it is faster and easier to sort two small lists than one larger one.
The name comes from the fact that, in general, a Quicksort can sort a list of data elements
quite rapidly. The basic strategy of this sort is to “divide and conquer.”
If you were given a large stack of final exams to sort by name, you might use the
following approach: Pick a splitting value—say, L—and divide the stack of tests into two
piles, A–L and M–Z. (Note that the two piles do not necessarily contain the same number
of tests.) Then take the first pile and subdivide it into two piles, A–F and G–L. The A–F pile
can be further broken down into A–C and D–F. This division process goes on until the piles
are small enough to be easily sorted by hand. The same process is applied to the M–Z
pile. Eventually all of the small sorted piles can be stacked one on top of the other to
produce a sorted set of tests. (See FIGURE 18.6.)
FIGURE 18.6 Ordering a List Using the Quicksort Algorithm
Description
This strategy is based on recursion—on each attempt to sort the stack of tests, the
stack is divided and then the same approach is used to sort each of the smaller stacks (a
smaller case). This process goes on until the small stacks do not need to be further
divided (the base case). The parameter list of the Quicksort algorithm specifies the part of
the list that is currently being processed. Notice that we are sorting the list items stored in
the array—not an abstract list about whose implementation we know nothing. To make this
distinction clear, we call the array data rather than list.

Description
How do we select splitVal? One simple solution is to use whatever value is in
data[first] as the splitting value. Let’s look at an example using data[first] as splitVal.
Description
After the call to Split, all of the items less than or equal to splitVal are on the left side of the
data and all of those items greater than splitVal are on the right side of the data.
Description
The two “halves” meet at splitPoint, the index of the last item that is less than or equal to
splitVal. Note that we don’t know the value of splitPoint until the splitting process is
complete. We can then swap splitVal (data[first]) with the value at data[split].
Description
Our recursive calls to Quicksort use this index (splitPoint) to reduce the size of the
problem in the general case.
Quicksort(first, splitPoint-1) sorts the left “half” of the data; Quicksort(splitPoint+1,
last) sorts the right “half” of the data. (Note that the “halves” are not necessarily the same
size.) splitVal is already in its correct position in data[splitPoint].

What is the base case? When the segment being examined has only one item, we do
not need to go on. So “there is more than one item in data[first]..data[last]” translates
into “if (first < last)”. We can now code the function Quicksort.
Description
Now we must find a way to get all of the elements that are equal to or less than splitVal
on one side of splitVal and all of the elements that are greater than splitVal on the other
side. We do so by moving a pair of the indexes toward the middle of the data, looking for
items that are on the wrong side of the split point. When we find pairs that are on the wrong
side, we swap them and continue working our way into the middle of the data.
FIGURE 18.7A shows the initial state of the array to be sorted. We start out by moving
first to the right, toward the middle, comparing data[first] to splitVal. If data[first] is
less than or equal to splitVal, we keep incrementing first; otherwise, we leave first
where it is and begin moving last toward the middle. (See FIGURE 18.7B.)
Now data[last] is compared to splitVal. If it is greater, we continue decrementing last;
otherwise, we leave last in place (see FIGURE 18.7C). At this point, it is clear that
data[last] and data[first] are on the wrong sides of the array. Note that the elements to
the left of data[first] and to the right of data[last] are not necessarily sorted; they are
just on the correct side with respect to splitVal. To move data[first] and data[last] to
the correct sides, we merely swap them, and then increment first and decrement last
(see FIGURE 18.7D).

FIGURE 18.7 Function Split
Description
Now we repeat the whole cycle, incrementing first until we encounter a value that is
greater than splitVal, and then decrementing last until we encounter a value that is less
than or equal to splitVal(see FIGURE 18.7E).
When does the process stop? When first and last meet each other, no additional
swaps are necessary. They meet at the splitPoint. This is the location where splitVal
belongs, so we swap data[saveFirst], which contains splitVal, with the element at
data[splitPoint](FIGURE 18.7F). The index splitPoint is returned from the function, to
be used by Quicksort to set up the next recursive call.
To make the Quicksort function template truly generic, let’s assume that the items to be
sorted can be compared with the ComparedTo function.


Description
TESTING: These three functions are placed in a single file and included in a driver to be
tested. Class Name defines ComparedTo, so let’s read in names, sort them, and output them.
Here is the driver and output from the run:

Description
Sample run:

Description

Testing and Debugging
Recursion is a powerful technique when it is used correctly. When improperly used, however,
recursion can lead to difficult-to-diagnose errors. The best way to debug a recursive algorithm
is to construct it correctly in the first place. To be realistic, we give a few hints about where to
look if an error occurs.
Testing and Debugging Hints
1. Be sure there is a base case. If there is no base case, the algorithm continues to issue
recursive calls until all memory has been used. Each time the function is called, either
recursively or nonrecursively, stack space is allocated for the parameters and automatic
local variables. If there is no base case to end the recursive calls, the run-time stack
eventually overflows. An error message such as “Stack overflow” indicates that the base
case is missing.
2. Make sure you have not used a While structure. The basic structure in a recursive
algorithm is the If statement. There must be at least two cases: the recursive case and
the base case. If the base case does nothing, the else-clause is omitted. The selection
structure, however, must be present. If a While statement is used in a recursive
algorithm, the While statement usually should not contain a recursive call.
3. As with nonrecursive functions, do not reference global variables directly within a
recursive function unless you have justification for doing so.
4. Parameters that relate to the size of the problem must be value parameters, not
reference parameters. The arguments that relate to the size of the problem are usually
expressions. Arbitrary expressions can be passed only to value parameters.
5. Use your system’s debugger program (or use debug output statements) to trace a
series of recursive calls. Inspecting the values of parameters and local variables often
helps to pinpoint the locations of errors in a recursive algorithm.

Summary
A recursive algorithm is expressed in terms of a smaller instance of itself. It must include a
recursive case, for which the algorithm is expressed in terms of itself, and a base case, for
which the algorithm is expressed in nonrecursive terms.
In many recursive problems, the smaller instance refers to a numeric argument that is
being reduced with each call. In other problems, the smaller instance refers to the size of
the data structure being manipulated. The base case is the one in which the size of the
problem (in terms of either a value or a structure) reaches a point for which an explicit
answer is known.
1. In the example of outputting an array using recursion, the size of the problem was the
size of the array. When the array size became 0, the entire array had been output.
2. In the Towers of Hanoi game, the size of the problem was the number of discs to be
moved. When only one was left on the beginning peg, it could be moved to its final
destination.
Recursion incurs extra overhead that iteration doesn’t. Thus, in most cases, iteration is
more efficient. For some problems, however, a recursive algorithm is the natural solution.
In those situations, the corresponding iterative solution is likely to be more complex—
programming the iterative version often involves manually implementing the equivalent of
the call stack. Although you may not use recursion on a regular basis, it is a powerful tool
to have in your programming toolkit.

Quick Check Answers
18.1.1 The base case. 18.1.2 A definition given in terms of a smaller version of itself.
18.1.3 An algorithm that expresses the solution in terms of a call to itself, a recursive call.
18.1.4 We have infinite recursion, the recursive equivalent of an infinite loop. 18.2.1 The
base case would be that when N is 0, the result is 1. The general case would be that when
N is greater than 0, we multiply it by the product of the numbers from 1 to N − 1, as
returned from a recursive call. 18.2.2 1) Understand the problem; 2) Determine the base
case(s); 3) Determine the recursive case(s). 18.3.1 When the number of circles equals 0.
18.3.2 Two recursive calls. The first is to move n – 1 circles from the beginning peg to the
auxiliary peg, and the second is to move n – 1 circles from the auxiliary peg to the ending
peg. 18.4.1 The base case would be that if there are no elements remaining, we return.
The general case would be that if there are elements remaining, we output the first one,
then recurse to output the rest. 18.4.2 A recursive algorithm in which no statements are
executed after the return from the recursive call. 18.4.3 That it could be solved more easily
using iteration. 18.5.1 The base case would be that the link of the current node is NULL, so
we output it. The general case would be that if the link of the current node is not NULL, we
output the remainder of the list before outputting the current node. 18.6.1 The nature of the
problem in terms of its efficiency.

Exam Preparation Exercises
18.1 Recursion is an alternative to
a. branching.
b. looping.
c. function invocation.
d. event handling.
18.2 A recursive function can be void or value returning. True or false?
18.3 When a function calls itself recursively, its parameters and local variables are
saved on the run-time stack until it returns. True or false?
18.4 Tail recursion occurs when all of the processing happens at the end of the
function, after the return from the recursive call. True or false?
18.5 Given the recursive formula F(N) = F(N − 2), with the base case F(0) = 0, what
are the values of F(4), F(5), and F(6)? If any of the values are undefined, say so.
18.6 Given the recursive formula F(N) = F(N − 1) * 2, with the base case F(0) = 1,
what are the values of F(3), F(4), and F(5)? If any of the values are undefined, say so.
18.7 What happens when a recursive function never encounters a base case?
18.8 Which practical limitation prevents a function from calling itself recursively
forever?
18.9 A tail-recursive function would be more efficiently implemented with a loop in
most cases. True or false?
18.10 When you develop a recursive algorithm to operate on a simple variable, what
does the general case typically make smaller with each recursive call?
a. The data type of the variable
b. The number of times the variable is referenced
c. The value in the variable
18.11 When you develop a recursive algorithm to operate on a data structure, what
does the general case typically make smaller with each recursive call?
a. The number of elements in the structure
b. The number of times the variable is referenced
c. The distance to the end of the structure
18.12 Given the following input data:

Description
What is output by the following program?
Description
18.13 Repeat Exercise 12, replacing the Rev function with the following version:

Description
18.14 What is output by the following program?
Description

18.15 What does the program in Exercise 14 output if the initial call to Rec from main
uses "abcdef" as the argument?

Programming Warm-Up Exercises
18.1 Write a value-returning recursive function called DigitSum that computes the sum
of the digits in a given positive int argument. For example, if the argument is 12345,
then the function returns 1 + 2 + 3 + 4 + 5 = 15.
18.2 Write a value-returning recursive function that uses the DigitSum function of
Exercise 1 to compute the single digit to which the int argument’s digits ultimately
sum. For example, given the argument 999, the DigitSum result would be 9 + 9 + 9 =
27, but the recursive digit sum would then be 2 + 7 = 9.
18.3 Write a recursive version of a binary search of a sorted array of int values that
are in ascending order. The function’s arguments should be the array, the search
value, and the maximum and minimum indexes for the array. The function should
return the index where the match is found, or else −1.
18.4 Write a recursive function that asks the user to enter a positive integer number
each time it is called, until zero or a negative number is input. The function then
outputs the numbers entered in reverse order. For example, the I/O dialog might be
the following:
Description
The function then outputs
Description
18.5 Extend the function of Exercise 4 so that it also outputs a running total of the
numbers as they are entered. For example, the I/O dialog might be the following:

Description
The function then outputs
Description
18.6 Extend the function of Exercise 5 so that it also outputs a running total as the
numbers are output in reverse order. For example, the I/O dialog might be the
following:
Description
The function then outputs
Description
18.7 Extend the function of Exercise 4 so that it reports the greatest value entered, at
the end of its output. For example, the I/O dialog might be the following:

Description
The function then outputs
Description
18.8 Change the function of Exercise 7 so that it outputs the greatest number entered
thus far, as the user is entering the data. For example, the I/O dialog might be the
following:
Description
The function then outputs
Description
18.9 Change the function of Exercise 8 so that it also outputs the greatest number
thus far, as it outputs the numbers in reverse order. For example, the I/O dialog might
be the following:

Description
The function then outputs
Description
18.10 Given the following declarations:
Description
Assume that the list pointed to by list1 contains an arbitrary number of nodes. Write a
recursive function that makes a copy of this list in reverse order, which is pointed to by
list2.
18.11 Given the declarations in Exercise 10, assume that the list pointed to by list1
contains an arbitrary number of nodes. Write a recursive function that makes a copy
of this list in the same order, which is pointed to by list2.
18.12 Given the declarations in Exercise 10, assume that the list pointed to by list1
contains an arbitrary number of nodes. Write a recursive function that makes a single

list containing two copies of the list1 list. The first copy will be in the same order, and
the second copy will be in reverse order. The new list is pointed to by list2.

Programming Problems
18.1 In mathematics, the Fibonacci numbers are the series of numbers that exhibit
the following pattern:
Description
In mathematical notation, the sequence F n of Fibonacci numbers is defined by the
following recursive definition:
Description
with the initial values of F0 = 0 and F1 = 1. Thus, the next number in the series is the sum
of the previous two numbers. Write a program that asks the user for a positive integer N
and generates the Nth Fibonacci number. Your main function should handle user input and
pass that data to a recursive function called Fib that takes an integer value N as input and
returns the Nth Fibonacci number.
18.2 Write a recursive function that will display all permutations of characters in a
user-provided string.
18.3 The greatest common divisor (GCD) of two positive integers is the largest
integer that divides the numbers exactly. For example, the GCD of 14 and 21 is 7; for
13 and 22, it is 1; and for 45 and 27, it is 9. We can write a recursive formula for
finding the GCD, given that the two numbers are called a and b, as:
Description
Implement this recursive formula as a recursive C++ function, and write a driver program
that allows you to test it interactively.
18.4 Write a C++ program to output the binary (base-2) representation of a decimal
integer. The algorithm for this conversion is to repeatedly divide the decimal number
by 2, until it is 0. Each division produces a remainder of 0 or 1, which becomes a digit
in the binary number. For example, if we want the binary representation of decimal 13,
we would find it with the following series of divisions:

Description
Thus the binary representation of 13 (decimal) is 1101. The only problem with this
algorithm is that the first division generates the low-order binary digit, the next division
generates the second-order digit, and so on, until the last division produces the high-order
digit. Thus, if we output the digits as they are generated, they will be in reverse order. You
should use recursion to reverse the order of output.
18.5 Change the program for Problem 4 so that it works for any base up to 10. The
user should enter the decimal number and the base, and the program should output
the number in the given base.
18.6 Write a C++ program using recursion to convert a number in binary (from 1 to 10
digits in length) to a decimal number. The algorithm states that each successive digit
in the number is multiplied by the base (2) raised to the power corresponding to its
position in the number. The low-order digit is in position 0. We sum together all of
these products to get the decimal value. For example, if we have the binary number
111001, we convert it to decimal as follows:
Description
Decimal value = 1 + 0 + 0 + 8 + 16 + 32 = 57
A recursive formulation of this algorithm can extract each digit and compute the
corresponding power of the base by which to multiply. Once the base case is reached (the
last digit is extracted), the function can sum the products as it returns.
In C++ we can represent a binary number using integers. However, there is a danger—
the user can enter an invalid number by typing a digit that’s unrepresentable in the base.
For example, the number 1011201 is an invalid binary number because 2 isn’t allowed in
the binary number system. Your program should check for invalid digits as they are
extracted, handle the error in an appropriate way (that is, it shouldn’t output a numerical
result), and provide an informative error message to the user.
18.7 Modify the program from Problem 6 to work for any number base in the range of
1 through 10. The user should enter a number and a base, and the program should

output the decimal equivalent. If the user enters a digit that is invalid for the base, the
program should output an error message and not display a numerical result.
18.8 A maze is to be represented by a 12 × 12 array composed of three values: Open
(O), Wall (W), or Exit (E). There is one exit from the maze. Write a program to
determine whether it is possible to exit the maze from each possible starting point
(any open square can be a starting point). You may move vertically or horizontally to
any adjacent open square. You may not move to a square containing a wall. The input
consists of a series of 12 lines of 12 characters each, representing the contents of
each square in the maze; the characters are O, W, or E. Your program should check
that the maze has only one exit. As the data are entered, the program should make a
list of all of the starting-point coordinates. It can then run through this list, solving the
maze for each starting point.

Case Study Follow-Up
1. In the Problem-Solving Case Study, both sorting versions have an implicit
restriction on the data type of the elements in the array. What is the restriction?
2. If the array to be sorted and/or searched combined the array and the number of
elements into a struct, could the number of parameters to Sort, Search, and
BinarySearch be reduced? Explain.
3. In Chapter 16, we discussed operator functions. Rewrite the Name class, replacing
ComparedTo with operator functions for the relational operators.
4. Rewrite Quicksort using the relational operators. Rerun the test driver with the new
Name class and Quicksort.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.
A P P E N D I C E S
Appendix A Reserved Words
The following identifiers are reserved words—identifiers with predefined meanings in the C++
language. The programmer cannot declare them for other uses (for example, variable names)
in a C++ program.

Description
Description

Appendix B Operator Precedence
The following table summarizes C++ operator precedence. Several operators are not
discussed in this text (typeid, the comma operator, ->*, and .*, for instance). For information
on these operators, see Stroustrup’s The C++ Programming Language, Third Edition
(Addison-Wesley, 1997).
In the following table, the operators are grouped by precedence level (highest to lowest),
and a horizontal line separates each precedence level from the next-lower level.
In general, the binary operators group from left to right; the unary operators, from right to
left; and the ?: operator, from right to left. Exception: The assignment operators group from
right to left.
Description

Description

Appendix C A Selection of Standard Library Routines
The C++ standard library provides a wealth of data types, functions, and named constants.
This appendix details only some of the more widely used library facilities. It is a good idea to
consult the manual for your particular system to see what other types, functions, and
constants the standard library provides.
This appendix is organized alphabetically according to the header file your program must
#include before accessing the listed items. For example, to use a mathematics routine such
as sqrt, you would #include the header file cmath as follows:
Description
Note that every identifier in the standard library is defined to be in the namespace std. Without
the using directive above, you would write
C.1 The Header File cassert
assert(booleanExpr)
Argument:
Effect:
A logical (Boolean) expression
If the value of booleanExpr is true, execution of the program simply continues. If
the value of booleanExpr is false, execution terminates immediately with a
message stating the Boolean expression, the name of the file containing the
source code, and the line number in the source code.
Function
return
value:
None (a void function)
Note:
If the preprocessor directive #define NDEBUG is placed before the directive #include
<cassert>, all assert statements are ignored.
C.2 The Header File cctype
isalnum(ch)
Argument:
A char value ch
Function return

value:
An int value that is
Nonzero (true), if ch is a letter or a digit character (‘A’–‘Z’, ‘a’–‘z’ ‘0’–‘9’)
0 (false), otherwise
isalpha(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a letter (‘A’–‘Z’, ‘a’–‘z’)
0 (false), otherwise
iscntrl(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a control character (in ASCII, a character with
the value 0–31 or 127)
0 (false), otherwise
isdigit(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a digit character (‘0’–‘9’)
0 (false), otherwise
isgraph(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a nonblank printable character (in ASCII, ‘!’
through ‘~’)
0 (false), otherwise
islower(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a lowercase letter (‘a’–‘z’)
0 (false), otherwise

isprint(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a printable character, including the blank (in
ASCII, ‘ ’ through ‘~’)
0 (false), otherwise
ispunct(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a punctuation character (equivalent to
isgraph(ch) && !isalnum(ch))
0 (false), otherwise
isspace(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a whitespace character (blank, newline, tab,
carriage return, form feed)
0 (false), otherwise
isupper(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is an uppercase letter (‘A’–‘Z’)
0 (false), otherwise
isxdigit(ch)
Argument:
A char value ch
Function return
value:
An int value that is
Nonzero (true), if ch is a hexadecimal digit (‘0’–‘9’, ‘A’–‘F’, a’–‘f’)
0 (false), otherwise
tolower(ch)
Argument:
A char value ch
Function return
value:
A character that is

The lowercase equivalent of ch, if ch is an uppercase letter
ch, otherwise
toupper(ch)
Argument:
A char value ch
Function return
value:
A character that is
The uppercase equivalent of ch, if ch is a lowercase letter
ch, otherwise
C.3 The Header File cfloat
This header file supplies named constants that define the characteristics of floating-point
numbers on your particular machine. Among these constants are the following:
FLT_DIG Approximate number of significant digits in a float value on your machine
FLT_MAX Maximum positive float value on your machine
FLT_MIN Minimum positive float value on your machine
DBL_DIG Approximate number of significant digits in a double value on your machine
DBL_MAX Maximum positive double value on your machine
DBL_MIN Minimum positive double value on your machine
LDBL_DIG Approximate number of significant digits in a long double value on your machine
LDBL_MAX Maximum positive long double value on your machine
LDBL_MIN Minimum positive long double value on your machine
C.4 The Header File climits
This header file supplies named constants that define the limits of integer values on your
particular machine. Among these constants are the following:
CHAR_BITS
Number of bits in a byte on your machine (8, for example)
CHAR_MAX
Maximum char value on your machine
CHAR_MIN
Minimum char value on your machine
SHRT_MAX
Maximum short value on your machine
SHRT_MIN
Minimum short value on your machine
INT_MAX
Maximum int value on your machine
INT_MIN
Minimum int value on your machine
LONG_MAX
Maximum long value on your machine
LONG_MIN
Minimum long value on your machine
UCHAR_MAX
Maximum unsigned char value on your machine
USHRT_MAX
Maximum unsigned short value on your machine
UINT_MAX
Maximum unsigned int value on your machine
ULONG_MAX
Maximum unsigned long value on your machine

C.5 The Header File cmath
In the math routines listed below, the following notes apply:
Error handling for incalculable or out-of-range results is system dependent.
All arguments and function return values are technically of type double (doubleprecision
floating-point); however, single-precision (float) values may be passed to the functions.
acos(x)
Argument:
A floating-point expression x, where –1.0 ≤ x ≤ 1.0
Function return
value:
Arc cosine of x, in the range 0.0 through π
asin(x)
Argument:
A floating-point expression x, where –1.0 ≤ x ≤ 1.0
Function return
value:
Arc sine of x, in the range –π /2 through π /2
atan(x)
Argument:
A floating-point expression x
Function return
value:
Arc tangent of x, in the range –π /2 through π /2
ceil(x)
Argument:
A floating-point expression x
Function return
value:
“Ceiling” of x (the smallest whole number ≥ x)
cos(angle)
Argument:
A floating-point expression angle, measured in radians
Function return
value:
Trigonometric cosine of angle
cosh(x)
Argument:
A floating-point expression x
Function return
value:
Hyperbolic cosine of x
exp(x)
Argument:
A floating-point expression x
Function return
value:
The value e (2.718...) raised to the power x
fabs(x)

Argument:
A floating-point expression x
Function return
value:
Absolute value of x
floor(x)
Argument:
A floating-point expression x
Function return
value:
“Floor” of x (the largest whole number ≤ x)
log(x)
Argument:
A floating-point expression x, where x > 0.0
Function return
value:
Natural logarithm (base e) of x
log10(x)
Argument:
A floating-point expression x, where x > 0.0
Function return
value:
Common logarithm (base 10) of x
pow(x, y)
Arguments:
Floating-point expressions x and y. If x = 0.0, y must be positive; if x ≤ 0.0, y
must be a whole number.
Function return
value:
x raised to the power y
sin(angle)
Argument:
A floating-point expression angle, measured in radians
Function return
value:
Trigonometric sine of angle
sinh(x)
Argument:
A floating-point expression x
Function return
value:
Hyperbolic sine of x
sqrt(x)
Argument:
A floating-point expression x, where x ≥ 0.0
Function return
value:
Square root of x
tan(angle)
Argument:
A floating-point expression angle, measured in radians
Function return
value:
Trigonometric tangent of angle

tanh(x)
Argument:
A floating-point expression x
Function return
value:
Hyperbolic tangent of x
C.6 The Header File cstddef
This header file defines a few system-dependent constants and data types. From this header
file, the only item we use in this text is the following symbolic constant:
NULL
The null pointer constant 0
C.7 The Header File cstdlib
abs(i)
Argument: An int expression i
Function
return
value:
An int value that is the absolute value of i
atof(str)
Argument: A C string (null-terminated char array) str representing a floating point number,
possibly preceded by whitespace characters and a ‘+’ or ‘–’
Function
return
value:
A double value that is the floating-point equivalent of the characters in str
Note:
Conversion stops at the first character in str that is inappropriate for a floating-
point number. If no appropriate characters were found, the return value is system
dependent.
atoi(str)
Argument: A C string (null-terminated char array) str representing an integer number,
possibly preceded by whitespace characters and a ‘+’ or ‘–’
Function
return
value:
An int value that is the integer equivalent of the characters in str
Note:
Conversion stops at the first character in str that is inappropriate for an integer
number. If no appropriate characters were found, the return value is system
dependent.
atol(str)
Argument: A C string (null-terminated char array) str representing a long integer, possibly
preceded by whitespace characters and a ‘+’ or ‘–’
Function
A long value that is the long integer equivalent of the characters in str

return
value:
Note:
Conversion stops at the first character in str that is inappropriate for a long
integer number. If no appropriate characters were found, the return value is
system dependent.
exit(exitStatus)
Argument: An int expression exitStatus
Effect:
Program execution terminates immediately with all files properly closed.
Function
return
value:
None (a void function)
Note:
By convention, exitStatus is 0 to indicate normal program completion and is
nonzero to indicate an abnormal termination.
labs(i)
Argument: A long expression i
Function
return
value:
A long value that is the absolute value of i
rand()
Argument: None
Function
return
value:
A random int value in the range 0 through RAND_MAX, a constant defined in cstdlib
(RAND_MAX is usually the same as INT_MAX.)
Note:
See srand below.
srand(seed)
Argument: An int expression seed, where seed ≥ 0
Effect:
Using seed, the random number generator is initialized in preparation for
subsequent calls to the rand function.
Function
return
value:
None (a void function)
Note:
If srand is not called before the first call to rand, a seed value of 1 is assumed.
system(str)
Argument: A C string (null-terminated char array) str representing an operating system
command, exactly as it would be typed by a user on the operating system
command line
Effect:
The operating system command represented by str is executed.
Function
return
value:
An int value that is system dependent

Note:
Programmers often ignore the function return value, using the syntax of a void
function call rather than a value-returning function call.
C.8 The Header File cstring
The header file cstring (not to be confused with the header file named string) supports
manipulation of C strings (null-terminated char arrays).
strcat(toStr, fromStr)
Arguments: C strings (null-terminated char arrays) toStr and fromStr, where toStr must be
large enough to hold the result
Effect:
fromStr, including the null character '\0', is concatenated (joined) to the end of
toStr.
Function
return value:
The base address of toStr
Note:
Programmers usually ignore the function return value, using the syntax of a void
function call rather than a value-returning function call.
strcmp(str1, str2)
Arguments: C strings (null-terminated char arrays) str1 and str2
Function
return value:
An int value < 0, if str1 < str2 lexicographically
The int value 0, if str1 = str2 lexicographically
An int value > 0, if str1 > str2 lexicographically
strcpy(toStr, fromStr)
Arguments: toStr is a char array and fromStr is a C string (null-terminated char array), and
toStr must be large enough to hold the result.
Effect:
fromStr, including the null character '\0', is copied to toStr, overwriting what
was there.
Function
return value:
The base address of toStr
Note:
Programmers usually ignore the function return value, using the syntax of a void
function call rather than a value-returning function call.
strlen(str)
Argument:
A C string (null-terminated char array) str
Function
return value:
An int value ≥ 0 that is the length of str (excluding the '\0')
C.9 The Header File string
This header file supplies a programmer-defined data type (specifically, a class) named string.
Associated with the string type are a data type string::size_type and a named constant
string::npos, defined as follows:

string::size_type An unsigned integer type related to the number of characters in a string
string::npos
The maximum value of type string::size_type
There are dozens of functions associated with the string type. Below are several of the most
important ones. In the descriptions, s is assumed to be a variable (an object) of type string.
s.c str()
Arguments:None
Function
return
value:
The base address of a C string (null-terminated char array) corresponding to the
characters stored in s
s.find(arg)
Argument: An expression of type string or char, or a C string (such as a literal string)
Function
return
value:
A value of type string::size_type that gives the starting position in s where arg
was found. If arg was not found, the return value is string::npos.
Note:
Positions of characters within a string are numbered starting at 0.
getline(inStream, s)
Arguments:An input stream inStream (of type istream or ifstream) and a string object s
Effect:
Characters are input from inStream and stored into s until the newline character is
encountered. (The newline character is consumed but not stored into s.)
Function
return
value:
Although the function technically returns a value (which we do not discuss here),
programmers usually invoke the function as though it were a void function.
s.length()
Arguments:None
Function
return
value:
A value of type string::size_type that gives the number of characters in the
string
s.size()
Arguments:None
Function
return
value:
The same as s.length()
s.substr(pos, len)
Arguments:Two unsigned integers, pos and len, representing a position and a length. The
value of pos must be less than s.length().
Function
return
value:
A temporary string object that holds a substring of at most len characters,
starting at position pos of s. If len is too large, it means “to the end” of the string in
s.

Note:
Positions of characters within a string are numbered starting at 0.
C.10 The Header File sstream
This header file supplies various classes derived from iostream that enable the user to apply
stream-like operations to strings instead of files. In this text, we use only the ostringstream
class, which enables us to convert numeric types to formatted string values. We can apply
the insertion operator (<<) to an ostringstream object to append values to it, and then read
back its contents in string form, using the str member function. In the following, oss is an
ostringstream object.
ostringstream()
Argument: None
Return
value:
An empty osstringstream object
ostringstream(arg)
Argument: A string
Return
value:
An ostringstream object initialized to the argument string
Left
argument:
An ostringstream object
Right
argument:
An expression that can be converted to a string, including output manipulators.
Return
value:
An ostringstream object
Evaluated:Left to right
oss.str()
Argument: None
Return
value:
A string containing whatever has been appended to oss
oss.str(arg)
Argument: A string
Effect:
Assigns the value of the argument to oss. Using the empty string as the argument
effectively sets the content of the ostringstream object to be empty.

Appendix D Setting Up the GUI Development
Environment
Qt Creator 4.15.1 is the graphical development environment used in this text and is
compatible with the source code that is distributed with it. All code examples have been
compiled and tested against version 6.1.1 of the Qt Framework. Setting up the development
environment for working with the code examples is straightforward. Download Qt Creator
from https://www.qt.io/download for your host platform and run the installer. Qt is compatible
with several C++ compilers and will automatically detect which compilers you have available.
The Windows version is distributed with MinGW to alleviate the need for installing a separate
compiler; the MacOS and Linux versions typically have the GNU Compiler Collection already
installed.
After the installation process you can open Qt Creator. You will be presented with the
following interface:
Description
There are two buttons for working with projects, New and Open. The former creates a new
project from scratch, and the latter opens an existing project. Assuming you have downloaded
the code examples associated with this text, you can click on Open, and a dialog will display,
allowing you to choose a project as shown here:

Description
Qt projects exist in a folder containing a platform-independent configuration file that ends in the
.pro file extension. Both the folder and the configuration file share the same name. In the
example 
above, 
you 
will 
see 
that 
the 
NamesCaseStudy 
project 
contains 
a
NamesCaseStudy.pro file. To open the project, you double-click on the .pro file. Before you
can work with the code, you need to configure the project as shown in the figure below.
Description
Just click on the Configure Project button to proceed, after which, you will see the project
window and be able to open the code files in the editor. It is useful to know that after you
configure the project, it will generate a platform-specific configuration file in the project

directory that has a .pro.user file extension. If you copy the project folder to a different
computer, you should delete the .pro.user file to force Qt to reconfigure the project for that
platform.
Description
Before you proceed, you must make two changes to the configuration. First, click on the
Projects button with the wrench icon, in the left gutter of the window, to bring up the build
configuration, and deselect “Shadow build.” A Shadow build will put the compiled code in a
different directory than the source code. When you download one of our code examples, input
files are included in the same project directory as the source code; however, a Shadow build
doesn’t copy those input files to the new directory. So, if you then run the program and look for
an input file, it won’t be there. (You would have to use the file browser to navigate back to the
source code directory.)

Description
Second, if you are running a console-based application, click on the Run button between the
Build & Run and Project Settings sections, to bring up the Run Settings view. Then check the
“Run in terminal” checkbox. When you run the program, it will then automatically bring up a
terminal window, allowing you to interact with it via the cout and cin streams. This step is not
required for the GUI projects.

Description
You can now go back to the Edit view and compile and run the project by clicking on the green
triangle “play” button, in the bottom left gutter of the editor.
To create a new project, you can click on the Welcome button in the top left gutter, which
will bring you back to the screen that you started with when you opened Qt Creator. Next, you
click on the New button, and you are presented with options for different types of projects to
create.
Description

To create a GUI-based application, select Qt Widgets Application. If you want to create a
console-based application, click on Qt Console Application. Qt Creator will then allow you to
pick the location for the project and make any configuration changes that you wish.

Appendix E The ASCII Character Set
The following chart shows the American Standard Code for Information Interchange (ASCII)
character set. The internal representation for each character is shown in decimal; for
example, the letter A is represented internally as the integer 65. The space (blank) character
is denoted by a “□”.
Description
Codes 00–31 and 127 are the following nonprintable control characters:
Description

NUL
Null character
SOH
Start of header
STX
Start of text
ETX
End of text
EOT
End of transmission
ENQ
Enquiry
ACK
Acknowledge
BEL
Bell character (beep)
BS
Backspace
HT
Horizontal tab
LF
Line feed
VT
Vertical tab
FF
Form feed
CR
Carriage return
SO
Shift out
SI
Shift in
DLE
Data link escape
DC1
Device control one
DC2
Device control two
DC3
Device control three
DC4
Device control four
NAK
Negative acknowledge
SYN
Synchronous idle
ETB
End of transmitted block
CAN
Cancel
EM
End of medium
SUB
Substitute
ESC
Escape
FS
File separator
GS
Group separator
RS
Record separator
US
Unit separator
DEL
Delete

Appendix F Program Style, Formatting, and
Documentation
Throughout this text, we encourage the use of good programming style and documentation.
Although the programs you write for class assignments may not be looked at by anyone
except the person grading your work, outside of class you will write programs that will be used
by others.
Useful programs have very long lifetimes, during which they must be modified and updated.
When maintenance work must be done, either you or another programmer will have to do it.
Good style and documentation are essential if another programmer is to understand and work
with your program. You will also discover that after not working with your own program for a
few months, you’ll be amazed at how many of the details you’ve forgotten.
F.1 General Guidelines
The style used in the programs and fragments throughout this text provides a good starting
point for developing your own style. Our goals in creating this style were to make it simple,
consistent, and easy to read.
Style is of benefit only for a human reader of your program—differences in style make no
difference to the computer. Good style includes the use of meaningful variable names,
comments, and indentation of control structures, all of which help others to understand and
work with your program. Perhaps the most important aspect of program style is consistency.
If the style within a program is not consistent, then it becomes misleading and confusing.
Sometimes, a particular style is specified for you by your instructor or by the company you
work for. When you are modifying someone else’s code, you should use his or her style in
order to maintain consistency within the program. However, you will also develop your own,
personal programming style based on what you’ve been taught, your own experience, and
your personal taste.
F.2 Comments
Comments are extra information included to make a program easier to understand. You
should include a comment anywhere the code is difficult to understand. However, don’t
overcomment. Too many comments in a program can obscure the code and be a source of
distraction.
In our style, there are four basic types of comments: headers, declarations, in-line, and
sidebar. Header comments appear at the top of the program and should include your name,
the date that the program was written, and its purpose. It is also useful to include sections
describing input, output, and assumptions. Think of the header comments as the reader’s
introduction to your program. Here is an example:

Description
Header comments should also be included for all user-defined functions (see Chapters 8 and
9).
Declaration comments accompany the constant and variable declarations in the program.
Anywhere that an identifier is declared, it is helpful to include a comment that explains its
purpose. In programs in the text, declaration comments appear to the right of the identifier
being declared. For example:
Description
Notice that aligning the comments gives the code a neater appearance and is less distracting.
In-line comments are used to break long sections of code into shorter, more
comprehensible fragments. These are often the names of modules in your algorithm design,
although you may occasionally choose to include other information. It is generally a good idea
to surround in-line comments with blank lines to make them stand out; for example:

Description
Even if comments are not used, blank lines can be inserted wherever there is a logical
break in the code that you would like to emphasize.
Sidebar comments appear to the right of executable statements and are used to shed light
on the purpose of the statement. Sidebar comments are often just pseudocode statements
from the lowest levels of your design. If a complicated C++ statement requires some
explanation, the pseudocode statement should be written to the right of the C++ statement.
For example:
Description
In addition to the four main types of comments that we have discussed, there are some
miscellaneous comments that we should mention. After the main function, we recommend
using a row of asterisks (or dashes or equal signs or ... ) in a comment before and after each
function to help it to stand out; for example:
Description
In this text, we use C++’s alternative comment form
Description
to document the flow of information for each parameter of a function:

Description
Description
(Chapter 8 describes the purpose of labeling each parameter as /* in */, /* out */, or /*
inout */.)
Programmers sometimes place a comment after the right brace of a block (compound
statement) to indicate which control structure the block belongs to:
Description
Attaching comments in this fashion can help to clarify the code and aid in debugging
mismatched braces.
F.3 Identifiers
The most important consideration in choosing a name for a data item or function in a program
is that the name convey as much information as possible about what the data item is or what
the function does. The name should also be readable in the context in which it is used. For
example, the following names convey the same information but one is more readable than the
other:
datOfInvc invoiceDate

Identifiers for types, constants, and variables should be nouns, whereas names of void
functions (non-value-returning functions) should be imperative verbs or phrases containing
imperative verbs. Because of the way that value-returning functions are invoked, their names
should be nouns or occasionally adjectives. Here are some examples:
Variables
address, price, radius, monthNumber
Constants
PI, TAX_RATE, STRING_LENGTH, ARRAY_SIZE
Data types
NameType, CarMakes, RoomLists, Hours
Void functions
GetData, ClearTable, PrintBarChart
Value-returning functions
CubeRoot, Greatest, Color, AreaOf, IsEmpty
Although an identifier may be a series of words, very long identifiers can become quite
tedious and can make the program difficult to read.
The best approach to designing an identifier is to try writing out different names until you
reach an acceptable compromise—and then write an especially informative declaration
comment next to the declaration.
Capitalization is another consideration when choosing an identifier. C++ is a case-sensitive
language; that is, uppercase and lowercase letters are distinct. Different programmers use
different conventions for capitalizing identifiers. In this text, we begin each variable name with
a lowercase letter and capitalize the beginning of each successive English word. We begin
each function name and data type name with a capital letter and, again, capitalize the
beginning of each successive English word. For named constants, we capitalize the entire
identifier, separating successive English words with underscore (_) characters. Keep in mind,
however, that C++ reserved words such as main, if, and while are always lowercase letters,
and the compiler will not recognize them if you capitalize them differently.
F.4 Formatting Lines and Expressions
C++ allows you to break a long statement in the middle and continue onto the next line.
(However, you cannot split a line in the middle of an identifier, a literal constant, or a string.)
When you must split a line, it’s important to choose a breaking point that is logical and
readable. Compare the readability of the following code fragments:
Description
When you must split an expression across multiple lines, try to end each line with an
operator. Also, try to take advantage of any repeating patterns in the expression; for example,
Description

When writing expressions, also keep in mind that spaces improve readability. Usually you
should include one space on either side of the = operator and most other operators.
Occasionally, spaces are left out to emphasize the order in which operations are performed.
Here are some examples:
Description
F.5 Indentation
The purpose of indenting statements in a program is to provide visual cues to the reader and
to make the program easier to debug. When a program is properly indented, the way the
statements are grouped is immediately obvious. Compare the following two program
fragments:
Description
As a basic rule in this text, each nested or lower-level item is indented by two spaces. In
this appendix we are using four spaces to emphasize the effect of indentation. Exceptions to
this rule are parameter declarations and statements that are split across two or more lines.
Indenting by two spaces is a matter of personal preference. Some people prefer to indent by
three, four, five, or even more than five spaces.
In this text, we indent the entire body of a function. Also, in general, any statement that is
part of another statement is indented. For example, the If-Then-Else contains two parts, the
then-clause and the else-clause. The statements within both clauses are indented four spaces
beyond the beginning of the If-Then-Else statement. The If-Then statement is indented like the

If-Then-Else, except that there is no else-clause. Here are examples of the If-Then-Else and
the If-Then:
Description
For nested If-Then-Else statements that form a generalized multiway branch (the If-Then-
Else-If, described in Chapter 5), a special style of indentation is used in the text. Here is an
example:
Description
Description
The remaining C++ statements all follow the basic indentation guideline mentioned
previously. For reference purposes, here are examples of each:

Description

Appendix G More on Floating-Point Numbers
We have used floating-point numbers off and on since we introduced them in Chapter 2, but
we have not examined them in depth. Floating-point numbers have special properties when
used on the computer. In this appendix we consider them in detail.
G.1 Representation of Floating-Point Numbers
Let’s assume we have a computer in which each memory location is the same size and is
divided into a sign plus five decimal digits. When a variable or constant is defined, the location
assigned to it consists of five digits and a sign. When an int variable or constant is defined, the
interpretation of the number stored in that place is straightforward. When a float variable or
constant is defined, the number stored there has both a whole number part and a fractional
part, so it must be coded to represent both parts.
Let’s see what such coded numbers might look like. The range of whole numbers we can
represent with five digits is -99,999 through +99,999:
Description
Our precision (the number of digits we can represent) is five digits, and each number
within that range can be represented exactly.
Precision The maximum number of significant digits.
What happens if we allow one of those digits (the leftmost one, for example) to represent an
exponent?

Description
Then +82345 represents the number +2345 × 108. The range of numbers we now can
represent is much larger:
However, our precision is now only four digits; that is, only four-digit numbers can be
represented exactly in our system. What happens to numbers with more digits? The four
leftmost digits are represented correctly, and the rightmost digits, or least significant digits, are
lost (assumed to be 0). FIGURE G.1 shows what happens. Note that 1,000,000 can be
represented exactly but -4,932,416 cannot, because our coding scheme limits us to four
significant digits.
Significant digits The digits from the first nonzero digit on the left to the last nonzero digit
on the right (plus any 0 digits that are exact).
To extend our coding scheme to represent floating-point numbers, we must be able to
represent negative exponents. Examples are
7394 × 10-2 = 73.94
and
22 × 10-4 = .0022
Because our scheme does not include a sign for the exponent, let’s change it slightly. The
existing sign becomes the sign of the exponent, and we add a sign to the far left to represent
the sign of the number itself (see FIGURE G.2).

FIGURE G.1 Coding Using Positive Exponents
Description
FIGURE G.2 Coding Using Positive and Negative Exponents
Description

FIGURE G.3 Coding of Some Floating Point Numbers
Description
All the numbers between -9999 × 109 and 9999 × 109 can now be represented accurately to
four digits. Adding negative exponents to our scheme allows us to represent fractional
numbers as small as 1 × 10-9.
FIGURE G.3 shows how we would encode some floating-point numbers. Note that our
precision is still only four digits. The numbers 0.1032, -5.406, and 1,000,000 can be
represented exactly. The number 476.0321, however, with seven significant digits, is
represented as 476.0; the 321 cannot be represented. (We should point out that some
computers perform rounding rather than simple truncation when discarding excess digits.
Using our assumption of four significant digits, such a machine would store 476.0321 as 476.0
but would store 476.0823 as 476.1. We continue our discussion assuming simple truncation
rather than rounding.)
G.2 Arithmetic with Floating-Point Numbers
When we use integer arithmetic, our results are exact. Floating-point arithmetic, however, is
seldom exact. To understand why, let’s add the three floating-point numbers x,y, and z using
our coding scheme.
First, we add x to y and then we add z to the result. Next, we perform the operations in a
different order, adding y to z, and then adding x to that result. The associative law of arithmetic
says that the two answers should be the same—but are they? Let’s use the following values
for x, y, and z:
Here is the result of adding z to the sum of x and y:

Description
Description
Now here is the result of adding x to the sum of y and z:
Description
Representational error Arithmetic error that occurs when the precision of the true result
of an arithmetic operation is greater than the precision of the machine.
These two answers are the same in the thousands place but are different thereafter. The
error behind this discrepancy is called representational error.
Because of representational errors, it is unwise to use a floating-point variable as a loop
control variable. Because precision may be lost in calculations involving floating-point
numbers, it is difficult to predict when (or even if) a loop control variable of type float (or
double or long double) will equal the termination value. A count-controlled loop with a floating-
point control variable can behave unpredictably.
Also because of representational errors, you should never compare floatingpoint numbers
for exact equality. Rarely are two floating-point numbers exactly equal, and thus you should
compare them only for near equality. If the difference between the two numbers is less than
some acceptable small value, you can consider them equal for the purposes of the given
problem.

G.3 Implementation of Floating-Point Numbers in the Computer
All computers limit the precision of floating-point numbers, although modern machines use
binary rather than decimal arithmetic. In our representation, we used only 5 digits to simplify
the examples, and some computers really are limited to only 4 or 5 digits of precision. A more
typical system might provide 6 significant digits for float values, 15 digits for double values,
and 19 for the long double type. We have shown only a single-digit exponent, but most
systems allow 2 digits for the float type and up to 4-digit exponents for type long double.
When you declare a floating-point variable, part of the memory location is assumed to
contain the exponent, and the number itself (called the mantissa) is assumed to be in the
balance of the location. The system is called floating-point representation because the number
of significant digits is fixed, and the decimal point conceptually is allowed to float (move to
different positions as necessary). In our coding scheme, every number is stored as four
digits, with the leftmost digit being nonzero and the exponent adjusted accordingly. Numbers in
this form are said to be normalized. The number 1,000,000 is stored as
Description
and 0.1032 is stored as
Description
Normalization provides the maximum precision possible.
Model Numbers
Any real number that can be represented exactly as a floating-point number in the computer is
called a model number. A real number whose value cannot be represented exactly is
approximated by the model number closest to it. In our system with four digits of precision,
0.3021 is a model number. The values 0.3021409, 0.3021222, and 0.30209999999 are
examples of real numbers that are represented in the computer by the same model number.
The following table shows all of the model numbers for an even simpler floating-point system
that has one digit in the mantissa and an exponent that can be -1, 0, or 1. Zero is a special
case, because it has the same value regardless of the exponent.
0.1 × 10-1
0.1 × 100
0.1 × 10+1
0.2 × 10-1
0.2 × 100
0.2 × 10+1
0.3 × 10-1
0.3 × 100
0.3 × 10+1
0.4 × 10-1
0.4 × 100
0.4 × 10+1
0.5 × 10-1
0.5 × 100
0.5 × 10+1

0.6 × 10-1
0.6 × 100
0.6 × 10+1
0.7 × 10-1
0.7 × 100
0.7 × 10+1
0.8 × 10-1
0.8 × 100
0.8 × 10+1
0.9 × 10-1
0.9 × 100
0.9 × 10+1
The difference between a real number and the model number that represents it is a form of
representational error called rounding error. We can measure rounding error in two ways. The
absolute error is the difference between the real number and the model number; for example,
the absolute error in representing 0.3021409 by the model number 0.3021 is 0.0000409. The
relative error is the absolute error divided by the real number and sometimes is stated as a
percentage; for example, 0.0000409 divided by 0.3021409 is 0.000135, or 0.0135%.
The maximum absolute error depends on the model interval—the difference between two
adjacent model numbers. In our example, the interval between 0.3021 and 0.3022 is 0.0001.
The maximum absolute error in this system, for this interval, is less than 0.0001. Adding digits
of precision makes the model interval (and thus the maximum absolute error) smaller.
FIGURE G.4 A Graphical Representation of Model Numbers
Description
The model interval is not a fixed number; it varies with the exponent. To see why the interval
varies, consider that the interval between 3021.0 and 3022.0 is 1.0, which is 104 times larger
than the interval between 0.3021 and 0.3022. This makes sense, because 3021.0 is simply
0.3021 times 104. Thus, a change in the exponent of the model numbers adjacent to the
interval has an equivalent effect on the size of the interval. In practical terms, this means that
we give up significant digits in the fractional part in order to represent numbers with large
integer parts. FIGURE G.4 illustrates this by graphing all of the model numbers listed in the
preceding table.
We also can use relative and absolute error to measure the rounding error resulting from
calculations. For example, suppose we multiply 1.0005 by 1000. The correct result is 1000.5,
but because of rounding error, our four-digit computer produces 1000.0 as its result. The
absolute error of the computed result is 0.5, and the relative error is 0.05%. Now suppose we
multiply 100,050.0 by 1000. The correct result is 100,050,000, but the computer produces

100,000,000 as its result. If we look at the relative error, it is still a modest 0.05%, but the
absolute error has grown to 50,000. Notice that this example is another case of changing the
size of the model interval.
Whether it is more important to consider the absolute error or the relative error depends on
the situation. It is unacceptable for an audit of a company to discover a $50,000 accounting
error; the fact that the relative error is only 0.05% is not important. On the other hand, a 0.05%
relative error is acceptable in representing prehistoric dates because the error in
measurement techniques increases with age; that is, if we are talking about a date roughly
10,000 years ago, an absolute error of 5 years is acceptable; if the date is 100,000,000 years
ago, then an absolute error of 50,000 years is equally acceptable.
Comparing Floating-Point Numbers
We have cautioned against comparing floating-point numbers for exact equality. Our
exploration of representational errors in this chapter reveals why calculations may not
produce the expected results even though it appears that they should. In Chapter 5, we wrote
an expression that compares two floating-point variables r and s for near equality using the
floating-point absolute value function fabs:
From our discussion of model numbers, you now can recognize that the constant 0.00001 in
this expression represents a maximum absolute error. We can generalize this expression as
Description
where ERROR_TERM is a value that must be determined for each programming problem.
What if we want to compare floating-point numbers with a relative error measure? We must
multiply the error term by the value in the problem to which the error is relative. For example, if
we want to test whether r and s are “equal” within 0.05% of s, we write the following
expression:
Description
Keep in mind that the choice of the acceptable error and whether it should be absolute or
relative depends on the problem being solved. The error terms we have shown in our example
expressions are completely arbitrary and may not be appropriate for most problems. In
solving a problem that involves the comparison of floating-point numbers, you typically want
an error term that is as small as possible. Sometimes the choice is specified in the problem
description or is reasonably obvious. Some cases require careful analysis of both the
mathematics of the problem and the representational limits of the particular computer. Such
analyses are the domain of a branch of mathematics called numerical analysis and are
beyond the scope of this text.
Underflow and Overflow

In addition to representational errors, there are two other problems to watch out for in
floatingpoint arithmetic: underflow and overflow.
Underflow is the condition that arises when the value of a calculation is too small to be
represented. Going back to our decimal representation, let’s look at a calculation involving
small numbers:
Description
This value cannot be represented in our scheme because the exponent -13 is too small. Our
minimum is -9. One way to resolve the problem is to set the result of the calculation to 0.0.
Obviously, any answer depending on this calculation will not be exact.
Overflow is a more serious problem because there is no logical recourse when it occurs.
For example, the result of the calculation
Description
cannot be stored, so what should we do? To be consistent with our response to underflow, we
could set the result to 9999 × 109 (the maximum representable value in this case). Yet this
seems intuitively wrong. The alternative is to stop with an error message.
C++ does not define what should happen in the case of overflow or underflow. Different
implementations of C++ solve the problem in different ways. You might try to cause an
overflow with your system and see what happens. Some systems may print a run-time error
message such as “FLOATING POINT OVERFLOW.” On other systems, you may get the
largest number that can be represented.
Although we are discussing problems with floating-point numbers, integer numbers also can
overflow both negatively and positively. Most implementations of C++ ignore integer overflow.
To see how your system handles the situation, you should try adding 1 to INT_MAX and -1 to
INT_MIN. On most systems, adding 1 to INT_MAX sets the result to INT_MIN, a negative number.
Sometimes you can avoid overflow by arranging computations carefully. Suppose you want
to know how many different five-card poker hands can be dealt from a deck of cards. What
we are looking for is the number of combinations of 52 cards taken 5 at a time. The standard
mathematical formula for the number of combinations of n things taken r at a time is
Description
We could use the Factorial function we wrote in the Chapter 18 and write this formula in an
assignment statement:

Description
The only problem is that 52! is a very large number (approximately 8.065X × 1067). And 47!
is also large (approximately 2.5862 × 1059). Both of these numbers are well beyond the
capacity of most systems to represent exactly as integers (52! requires 68 digits of precision).
Even though they can be represented on many machines as floating-point numbers, most of
the precision is still lost. By rearranging the calculations, however, we can achieve an exact
result on any system with 9 or more digits of precision. How? Consider that most of the
multiplications in computing 52! are canceled when the product is divided by 47!
Description
So, we really only have to compute
Description
which means the numerator is 311,875,200 and the denominator is 120. On a system with 9
or more digits of precision, we get an exact answer: 2,598,960 poker hands.
Cancellation Error
Another type of error that can happen with floating-point numbers is called cancellation error, a
form of representational error that occurs when numbers of widely differing magnitudes are
added or subtracted. Let’s look at an example:
The laws of arithmetic say this equation should be true. But is it true if the computer does the
arithmetic?
Description
To four digits, the sum is 1000 × 10–3. Now the computer subtracts 1:
Description

The result is 0, not .00001234.
Sometimes you can avoid adding two floating-point numbers that are drastically different in
size by carefully arranging the calculations. Suppose a problem requires many small floating-
point numbers to be added to a large floating-point number. The result is more accurate if the
program first sums the smaller numbers to obtain a larger number and then adds the sum to
the large number.
BACKGROUND INFORMATION Practical Implications of
Limited Precision
A discussion of representational, overflow, underflow, and cancellation errors may seem
purely academic. In fact, these errors have serious practical implications in many
problems. We close this section with three examples illustrating how limited precision can
have costly or even disastrous effects.
During the Mercury space program, several of the spacecraft splashed down a
considerable distance from their computed landing points. This delayed the recovery of the
spacecraft and the astronaut, putting both in some danger. Eventually, the problem was
traced to an imprecise representation of the Earth’s rotation period in the program that
calculated the landing point.
As part of the construction of a hydroelectric dam, a long set of high-tension cables had
to be constructed to link the dam to the nearest power distribution point. The cables were
to be several miles long, and each one was to be a continuous unit. (Because of the high
power output from the dam, shorter cables couldn’t be spliced together.) The cables were
constructed at great expense and strung between the two points. It turned out that they
were too short, however, so another set had to be manufactured. The problem was traced
to errors of precision in calculating the length of the catenary curve (the curve that a cable
forms when hanging between two points).
An audit of a bank turned up a mysterious account with a large amount of money in it.
The account was traced to an unscrupulous programmer who had used limited precision
to his advantage. The bank computed interest on its accounts to a precision of a tenth of a
cent. The tenths of cents were not added to the customers’ accounts, so the programmer
had the extra tenths for all the accounts summed and deposited into an account in his
name. Because the bank had thousands of accounts, these tiny amounts added up to a
large amount of money. And because the rest of the bank’s programs did not use as much
precision in their calculations, the scheme went undetected for many months.
The moral of this discussion is twofold: (1) The results of floating-point calculations are
often imprecise, and these errors can have serious consequences; and (2) if you are
working with extremely large numbers or extremely small numbers, you need more
information than this text provides and should consult a numerical analysis text.

Appendix H Using C Strings1
Starting with Chapter 2, we use the string class to store and manipulate character strings.
Description
In some contexts, we think of a string as a single unit of data. In other contexts, we treat it
as a group of individually accessible characters. In particular, we think of a string as a
variable-length, linear collection of homogeneous components (of type char). The string class
from the standard library is one approach to implementing a data type with these properties.
However, before this class was developed, the C language, upon which C++ is built, had its
own approach: the C string.
C string In C and C++, a null-terminated sequence of characters stored in an array.
We are using a C string whenever we write a string constant. In C and C++, a string
constant is a sequence of characters enclosed by double quotes:
“Hi”
A string constant is not a member of the string class; rather, it is stored as a char array
with enough components to hold each specified character plus one more—the null character.
The null character, which is the first character in both the ASCII and EBCDIC character sets,
is internally represented by the value 0. In C++, the escape sequence \0 stands for the null
character. When the compiler encounters the string “Hi“ in a program, it stores the three
characters "H", ‘i’, and ‘\0’ into a three-element, anonymous (unnamed) char array as follows:
Description
The C string is the only kind of C++ array for which there exists an aggregate constant—the
string constant. Notice that in a C++ program, the symbols 'A' denote a single character,
whereas the symbols "A" denote two: the character ‘A’ and the null character.2

In addition to C string constants, we can create C string variables. To do so, we explicitly
declare a char array and store into it whatever characters we want to, finishing with the null
character. Here’s an example:
Description
In C++, all C strings (constants or variables) are assumed to be null-terminated. This
convention is agreed upon by all C++ programmers and standard library functions. The null
character serves as a sentinel value; it allows algorithms to locate the end of the string. For
example, here is a function that determines the length of any C string, not counting the
terminating null character:
Description
The value of i at loop exit is returned by the function. If the array being examined is

Description
then i equals 2 at loop exit. The string length is therefore 2.
The argument to the StrLength function can be a C string variable, as in the function call
Description
or it can be a string constant: cout
Description
In the first case, the base address of the myStr array is sent to the function, as we
discussed in Chapter 11. In the second case, a base address is also sent to the function—the
base address of the unnamed array that the compiler has set aside for the string constant.
There is one more thing we should say about our StrLength function. A C++ programmer
would not actually write this function. The standard library supplies several string-processing
functions, one of which is named strlen and does exactly what our StrLength function does.
Later in this appendix, we look at strlen and other library functions.
H.1 Initializing C Strings
In Chapter 11, we showed how to initialize an array in its declaration by specifying a list of
initial values within braces, like this:
Description
To initialize a C string variable in its declaration, you could use the same technique:
Description

However, C++ allows a more convenient way to initialize a C string. You can simply
initialize the array by using a string constant:
Description
This shorthand notation is unique to C strings because there is no other kind of array for
which there are aggregate constants.
We said in Chapter 12 that you can omit the size of an array when you initialize it in its
declaration (in which case, the compiler determines its size). This feature is often used with C
strings because it keeps you from having to count the number of characters; for example,
Description
Be very careful about one thing: C++ treats initialization (in a declaration) and assignment
(in an assignment statement) as two distinct operations. Different rules apply. Remember that
array initialization is legal, but aggregate array assignment is not.
Description
H.2 C String Input and Output
In Chapter 11, we emphasized that C++ does not provide aggregate operations on arrays.
There is no aggregate assignment, aggregate comparison, or aggregate arithmetic on arrays.
We also said that aggregate input/output of arrays is not possible, with one exception. C
strings are that exception. Let’s look first at output.
To output the contents of an array that is not a C string, you aren’t allowed to do this:
Description
Instead, you must write a loop and print the array elements one at a time. However,
aggregate output of a null-terminated char array (that is, a C string) is valid. The C string can
be a constant:
Description
or it can be a variable:

Description
In both cases, the insertion operator (<<) outputs each character in the array until the null
character is found. It is up to you to double-check that the terminating null character is present
in the array. If not, the << operator will march through the array and into the rest of memory,
printing out bytes until—just by chance—it encounters a byte whose integer value is 0.
To input C strings, we have several options. The first is to use the extraction operator (>>),
which behaves exactly the same as with string class objects. When reading input characters
into a C string variable, the >> operator skips leading whitespace characters and then reads
successive characters into the array, stopping at the first trailing whitespace character (which
is not consumed, but remains as the first character waiting in the input stream). The >>
operator also takes care of adding the null character to the end of the string. For example,
assume we have the following code:
Description
If the input stream initially looks like this (where ◊ denotes a blank):
Description
then our input statement stores ‘J’, ‘o’, ‘h’, ‘n’, and ‘\0’ into firstName[0] through firstName[4];
stores ‘S’, ‘m’, ‘i’, ‘t’, ‘h’, and ‘\0’ into lastName[0] through lastName[5]; and leaves the input
stream as
Description
The >> operator, however, has two potential drawbacks.
1. If the array isn’t large enough to hold the sequence of input characters (and the ‘\0’), the
>> operator will continue to store characters into memory past the end of the array.
2. The >> operator cannot be used to input a string that has blanks within it. (It stops reading
as soon as it encounters the first whitespace character.)
To cope with these limitations, we can use a variation of the get function, a member of the
istream class. We have used the get function to input a single character, even if it is a
whitespace character:

Description
The get function also can be used to input C strings, in which case the function call requires
two arguments. The first is the array name, and the second is an int expression.
Description
The get function does not skip leading whitespace characters and continues until it either
has read charCount characters or reaches the newline character '\n', whichever comes first.
It then appends the null character to the end of the string. With the statements
Description
the get function reads and stores an entire input line (to a maximum of 80 characters),
embedded blanks and all. If the line has fewer than 80 characters, reading stops at '\n' but
does not consume it. The newline character is now the first one waiting in the input stream. To
read two consecutive lines worth of strings, it is necessary to consume the new-line
character:
Description
The first function call reads characters up to, but not including, the '\n'. If the input of dummy
were omitted, then the input of string2 would read no characters because '\n' would
immediately be the first character waiting in the stream.
Finally, the ignore function can be useful in conjunction with the get function. The statement
Description
says to skip at most 200 input characters but stop if a newline was read. (The newline
character is consumed by this function.) If a program inputs a long string from the user but
only wants to retain the first four characters of the response, here is a way to do it:
Description

Description
The value 100 in the last statement is arbitrary. Any “large enough” number will do.
Here is a table that summarizes the differences between the >> operator and the get
function when reading C strings:
Description
Certain library functions and member functions of system-supplied classes require C
strings as arguments. An example is the ifstream class member function named open. To
open a file, we pass the name of the file as a C string, either a constant or a variable:
Description
If our file name is contained in a string class object, we still can use the open function,
provided we use the string class member function named c_str to convert the string to a C
string:
Description
Comparing these two code segments, you can observe a major advantage of the string
class over C strings: A string in a string class object has unbounded length, whereas the

length of a C string is bounded by the array size, which is fixed at compile time.
H.3 C String Library Routines
Through the header file cstring, the C++ standard library provides a large assortment of C
string operations. In this section, we discuss three of these library functions: strlen, which
returns the length of a string; strcmp, which compares two strings using the relations less-
than, equal, and greater-than; and strcpy, which copies one string to another. Here is a
summary of strlen, strcmp, and strcpy:
Description
The strlen function is similar to the StrLength function we wrote earlier. It returns the
number of characters in a C string prior to the terminating ‘\0’. Here’s an example of a call to
the function:
Description
The strcpy routine is important because aggregate assignment with the = operator is not
allowed on C strings. In the following code fragment, we show the wrong way and the right
way to perform a string copy.

Description
In strcpy’s argument list, the destination string is the one on the left, just as an assignment
operation transfers data from right to left. It is the caller’s responsibility to make sure that the
destination array is large enough to hold the result.
The strcpy function is technically a value-returning function; it not only copies one C string
to another, but also returns as a function value the base address of the destination array. The
reason why the caller would want to use this function value is not at all obvious, and we don’t
discuss it here. Programmers nearly always ignore the function value and simply invoke
strcpy as if it were a void function (as we did above). You may wish to review the Background
Information box in Chapter 9 entitled “Ignoring a Function Value.”
The strcmp function is used for comparing two strings. The function receives two C strings
as parameters and compares them in lexicographic order (the order in which they would
appear in a dictionary)—the same ordering used in comparing string class objects. Given the
function call strcmp(str1, str2), the function returns one of the following int values: a negative
integer, if str1 < str2 lexicographically; the value 0, if str1 = str2; or a positive integer, if str1
> str2. The precise values of the negative integer and the positive integer are unspecified. You
simply test to see if the result is less than 0, 0, or greater than 0. Here is an example:
Description
We have described only three of the string-handling routines provided by the standard
library. These three are the most commonly needed, but there are many more. If you are
designing or maintaining programs that use C strings extensively, you should read the
documentation on strings for your C++ system.
H.4 String Class or C Strings?
When working with string data, should you use a class like string or should you use C
strings? From the standpoints of clarity, versatility, and ease of use, there is no contest. Use a
string class. The standard library string class provides strings of unbounded length,
aggregate assignment, aggregate comparison, concatenation with the + operator, and so forth.
However, it is still useful to be familiar with C strings. Among the thousands of software
products currently in use that are written in C and C++, most (but a declining percentage) use
C strings to represent string data. In your next place of employment, if you are asked to
modify or upgrade such software, understanding C strings is essential.

Appendix I C++ char Constants
In C++, char constants come in two different forms. The first form is a single printable
character enclosed by apostrophes (single quotes):
Description
Notice that we said printable character. Character sets include both printable characters and
control characters (or nonprintable characters). Control characters are not meant to be
printed. In the early days of computing, including the period when the C language was first
developed, the primary interface to the computer was often a very simple printer or display
screen. Control characters were used to direct the actions of the screen, printer, and other
hardware devices. With modern graphical user interfaces, the control mechanisms are more
complex (as seen in the GUI sections of this text). However, C++ (and C) still preserve the
simpler interface in the form input and output to a console window, or terminal program, that
simulates the old-style hardware.
If you look at the listing of the ASCII character set in Appendix E, you will see that the
printable characters are those with integer values 32–126. The remaining characters (with
values 0–31 and 127) are nonprinting control characters.
To accommodate control characters, C++ provides a second form of char constant: the
escape sequence. An escape sequence is one or more characters preceded by a backslash
(\); for example, the escape sequence \n represents the newline character. Here is the
complete description of the two forms of char constant in C++:
1. A single printable character—except an apostrophe (') or backslash (\)—enclosed by
apostrophes
2. One of the following escape sequences, enclosed by apostrophes:
\n
Newline
\t
Horizontal tab
\v
Vertical tab
\b
Backspace
\r
Carriage return
\f
Form feed
\a
Alert (a bell or beep sound)
\\
Backslash
\'
Single quote (apostrophe)
\"
Double quote (quotation mark)
\0
Null character (all 0 bits)
\ddd Octal equivalent (one, two, or three octal digits specifying the integer value of the
desired character)
\xdddHexadecimal equivalent (one or more hexadecimal digits specifying the integer value of

the desired character)
Even though an escape sequence is written as two or more characters, each escape
sequence represents a single character in the character set. The alert character (\a) is the
same as what is called the BEL character in ASCII. On old mechanical printers, it actually
rang a bell. These days, it causes the terminal program to make a beeping sound. You can
output the alert character like this:
In the list of escape sequences above, the entries labeled Octal equivalent and
Hexadecimal equivalent let you refer to any character in your machine’s character set by
specifying its integer value in either octal (base-8) or hexadecimal (base-16). The reason for
using these seemingly strange number bases is that, being powers of two, they translate
more directly into binary.
Note that you can use an escape sequence within a string just as you can use any printable
character within a string. The statement
Description
beeps the beeper, displays Whoops!, and terminates the output line. The statement
Description
outputs
Description
and does not terminate the output line.
1 Note: This appendix assumes that you have already read about arrays in Chapter 11.
2 C string is not an official term used in C++ language manuals. Such manuals typically
use the term string. However, we use C string to distinguish between the general concept
of a string, the built-in array representation defined by the C and C++ languages, and the
string class in the standard library.

Chapter Opener: © Joost Lagerweij/EyeEm/Getty Images.
INDEX
Symbols
- - (double minus). See decrement operators (- -)
# (pound sign), directive syntax, 727
% (modulus) operator, 102
& (ampersand)
for declaring reference parameters, 407, 409
for passing arrays by reference, 605
&& (AND operator), 223–225
/* */, comment syntax, 65
*this, 992
:: (double colon), scope resolution operator, 464
@entry, function documentation, 420
_ (underscore), identifiers beginning with, 51
{ } (braces)
block syntax, 68, 212
C++ functions, 47
|| (OR operator), 223–225
} (right brace), C++ functions, 47
< > angle brackets, header syntax, 71
<< (left arrows)
bitwise operator, 365
insertion operator. See insertion operator (<<)
>> (right arrows)
bitwise operator, 365
extraction operator. See extraction operator (>>)
= (equals). See assignment operators (=)
== (double equals). See relational operators (==)
\ (backslash), printing strings, 64, 79
?: (conditional operator), 364, 367–368

/ (forward slash), division operator, 102
minus sign (-), in integral types, 97
! (NOT operator), 223–225, 281
. (period), member selector, 691
; (semicolon)
blocks and, 211
Do-While statement ending in, 349–350
expression statements and, 364
function prototype ending with, 443
infinite loops and, 328
For statements and, 354
" (double quotes), printings strings, 64, 79
( ) (parentheses)
overriding order or evaluation in expression, 229–230
testing and debugging hints, 255–256
A
abstract data structures, 1056–1058
abstract data types (ADTs)
array-based lists. See array-based lists
dynamic lists. See dynamic ADT lists
implementation of, 681–682
operation categories, 682
overview of, 680
specification of, 681
abstraction
abstract data types. See abstract data types (ADTs)
class design and, 710
control abstraction, 500, 680
data abstraction, 680
modifiability and reuse and, 711–712
abstraction barrier, 693.
See also information hiding
abstract steps, 172
access
to components of one-dimensional arrays, 593–595
in inheritance, 892
to one-dimensional arrays, 598–604
action responsibilities
public methods of objects, 704
transformers as example of, 713
actions
algorithms as logical sequence of, 4
control unit controlling other component, 21
means-end analysis of, 28–29
active error detection, 578
address-of operators, 562

ADTs. See abstract data types (ADTs)
aggregate operations
Aggregate I/O, 597
one-dimensional arrays, 597–598
on structs, 547–549
AircraftMainWindow class, 1042–1043
aircraft weight and balance (case study), 1011–1024
air traffic control simulation, 912
Algol 60, 1084
algorithms
analysis of, 301–305
coding, 6–7
generic functions, 986
overview of, 4–5
problem-solving case study. See leap year program (case study)
problem-solving using, 31
responsibility, 907, 910
using control structures to express, 13
allocating dynamic data, 820–822
ALU (arithmetic/logic unit), 21
American National Standards Institute (ANSI), 32
American Standard Code for Information Interchange (ASCII), 8
analogy, problem-solving using, 27–28
analysis, in problem-solving phase, 170
Analytical Engine, Babbage, 542, 612
AND operator (&&), 223–225
angle arrays, 593–594
anonymous data types, 540–541, 579
ANSI (American National Standards Institute), 32
Apollo 13 mission, 477
Apollo 11, path for, 477
application state, in GUI, 944–946
appointment calendar creation (case study), 913–931
attributes in, internal representation of, 917–918
constructors in, 918–921, 923
CRC cards in, 915, 917, 921
filtering in, 914–915
responsibilities in, 923
scenario explorations in, 915–916
script from interactive session, 930–931
UserInterface class, 926–927
appointment calendar using STL list (case study), 1086–1096
argument lists
defined, 114
parameter lists and, 417–418
testing and debugging tips, 443
testing functions, 441

voiding function, 402
arguments
caution about, 417–418
C+, C++, and arrays and, 607
defined, 401
functions and, 154
mechanisms for passing, 416–417
one-dimensional arrays as, 607
parameters and, 407–410
parameters lists and, 417–418
type coercion in passing of, 488–490
voiding function, 402
arithmetic expressions
compound, 105–109
mixed type expressions, 108–109
overview of, 101
relational operators for comparing values of, 204–205
simple, 101–105
type coercion in, 369–371
arithmetic/logic unit (ALU), 21
arithmetic operators
overview, 101–104
precedence rules for, 229
array-based lists, 755–817
as abstract data types, 757–758
of classes, generally, 790–791
creating empty, 766–767
data representation in, 760–762
deletion, 767–769
example program for, 762–766
graphical user interface, 806–811
insertion, 767–769
iterators, 770–771
overview of, 755–756
responsibilities of, 758–760
sequential searches of, 769–770
sorted. See sorted lists
testing and debugging, 811–812
UML diagrams, 794–796
array identifiers, 614
array of name objects, creating an (case study), 731–736
arrays, 589–677
abstract form vs. implementation of, 1056–1058
complex structures of, 662–663
defined, 640
elements of, 592
graphical user interface, 650–651, 659–661
indexes with semantic content, 624

introducing, 590–592
multidimensional, 640–642
one-dimensional. See one-dimensional arrays
overview of, 590
processing, special kinds of, 621–624
of records, 617–621
as structured data type, 540–541
subarray processing, 621–624
testing and debugging, 661–665
two-dimensional. See two-dimensional arrays
array template, 1074–1075
ASCII (American Standard Code for Information Interchange), 8
assembler program, 10
characters, 528–529
assembly languages, 10
assertions
asking questions as, 202
as logical expressions, 202–207
writing as function documentation, 419–420
assert library function, 441–443
assignment expressions
common mistake when using, 214
overview of, 364
assignment operators (=)
built-in operations on objects, 691
combined, 362, 364
common mistake when using, 214
enumeration types and, 533–534
overview of, 60, 364
placing declarations and, 62
simple arithmetic expressions, 103–104
type casting, 107–109
type coercion in, 107–109, 488–490
writing If statements, 205
associative containers, 1102–1108
associative lookups, 1102
atomic data types. See simple (atomic) data types
attributes
internal representation of, 917–918
of objects, 704
automatic variables, 467
auxiliary (storage) devices
defined, 21
input data coming from, 146
B
Babbage, Charles, 541–542, 612

Backus-Naur Form (BNF) metalanguage, 49
base addresses, 605
base cases, 1147–1153
base classes, 889
batch processing, as noninteractive I/O, 160
BCPL (Basic Combined Programming Language), 32
bidirectional linear structures, 1063–1064
bidirectional lists, 1063–1064
Big-O notation, 304
binary codes, data stored as, 9
binary operators, 102
binary representation of data
approximating floating-point values, 102
overview of, 8–9
binary search algorithms, 1159–1164
binary search trees, 1097–1099
binary searches
linear searches vs., 1159–1164
logarithmic order of, 789
in sorted lists, 776, 791
binary trees, 1097–1100
binding like items, structs, 550
bits, of data, 9
bitwise operators
overview of, 365–366
specialized, 362
black boxes, 693
black-box testing, 251
blank lines, creating, 77–78
blanks
extraction operator (>>) skipping, 151–153
output formatting using, 117
blocks (compound statements). See also scope, identifier
body of loop as, 271
braces and, 212
declaring automatic variables within, 467
overview of, 68–70
using in If statements, 210–211
BMI calculator (case study), 234–239
changing loop implementation (case study) and, 357–359
BNF (Backus-Naur Form) metalanguage, 49
body, of function, 46
body, of loop, 271
bool data type
domain of, 526
overview of, 202
simulating, 530

Boolean algebra, 228–229
Boolean expressions. See logical (Boolean) expressions
Boolean functions
LessThan operation, 689–690
naming, 486–487
overview of, 484–486
Boolean operators. See logical (Boolean) expressions
brainstorming, 907, 908–909
defined, 908
in object-oriented design, 907–908
Boolean variable
defined, 435
Boole, George, 228–229
branching control structure. See selection (branching) control structure
Break statement
flow of control using, 343–345
overview of, 360–361
testing and debugging, 381
building-block approach, to problemsolving, 30
built-in data types, 53
built-in operations, on objects, 691–692
built-in simple types, 526–530
characters, 528–530
numeric types, 527–528
overview of, 526–527
button widgets, in GUI, 934–937
Byron, Anna Isabella (Annabella), 611–613
Byron, Lord (George Gordon), 611–613
C
CAD (computer-aided) design, 887
calculators, Pascal, 111
case labels, Switch statement, 343–345
case studies. See problem-solving case studies
case-sensitivity
in C++, 52
enumerators, 532
using capitalization of identifiers, 59
cast operator ( )
defined, 362
overview of, 107–109, 366
catching exceptions
defined, 994
try-catch statement for, 995–998
central processing unit (CPU), 20
cfloat header file, 528
chained hash tables, 1101–1102

character data
input streams and extraction operator, 149–150
overview of, 528–530
reading marker and new line, 150–151
reading with get function, 151–154
skipping characters with ignore function, 154–155
using char to store, 371
character sets
adding to string value, 62
defined, 54
testing and debugging hints, 579
char data type
concatenation working with, 61
defined, 53
domain of, 526
as integral type, 96–98
measuring sizes in multiples of, 527
overview of, 54
storing character data, 371
char literal, 79
CheckCofGOfAircraft method, 1036
CheckWeightOfAircraft method, 1036
chessboard program (case study), 81–85, 93
children (of tree node), 1097–1100
cin variable
example of, 148
input failure, 169
inputting data from, 147
mistaken use of, 189
reading string data with, 156
C language, 167–168
class constructors, 685, 687
class design
abstraction, 710
encapsulation, 707–709
modifiability and reuse, 711–712
mutability, 712–713
classes
built-in operations on objects, 691–692
class objects (class instances), 685
composition, 724–729
constructors, 685, 687
design specification, 709
graphical user interface, 737–738
information hiding. See information hiding
instantiating, 976–978
member functions, 688

members, 684–685
objects and members and, 690–691
overview of, 683
scope, 458, 466, 692–693
as structured data type, 540–541
syntax template for, 684
in templates, 975–976
testing and debugging, 738–747
UML diagrams, 729–730
class members, 684
class scope, 458, 466, 692–693
clients, class, 685
climits header file, 528
clock, 22
clones, 1166
closing files, 163, 165–166
COBOL (Common Business-Oriented Language), 348
code coverage
developing test plan with, 251
testing using, 251
code editors
defined, 16
entering program using, 80
code refactoring, GUI, 436
code walk-through, 248
coding
algorithms, 6–7
binary representations of data and, 9
collaborations, 909
collating sequence, 54
collisions, 1101
column processing, 636–638
comments
assertions as function documentation, 419–420
on constant and variable declarations, 58
creating from debug output statements, 329
in one-dimensional arrays, 607
program construction using, 68
on programs, 65–66
pseudocode from design process as, 178
communication complexity, 500
ComparedTo
in binary searches, 790–791
in dynamic binding, 903
comparison operations
ADT operations, 720–722
enumeration types and, 535

compilation/compilers
defined, 10
interpretation vs. compilation, 12
multifile program compilation, 701–703
program compilation, 80–81
testing automatically during compilation, 254–255
compile time, 976
compile-time binding, 903
complexity, of algorithm, 301
composition, class
diagramming, 730
overview of, 724–729
compound arithmetic expressions
precedence rules, 106–107
type coercion and type casting, 107–109
computer-aided (CAD) design, 887
compound statements. See blocks (compound statements)
computer programming, 2
computer programs, 9–19
defined, 2
how it works, 9–12
interpretation vs. compilation, 12
programming language instructions, 12–14
software maintenance study, 14–15
writing, 2–4
computers
components of, 20–23
defined, 2
designing world’s first, 541
factors affecting speed of, 22–23
resources and ethics, 25
von Neumann’s role in development of, 706–707
concatenation, 61–62
conceptual hiding, of function
implementation, 418–419, 500
concrete steps, hierarchical solution tree, 172
conditional (short-circuit) evaluation, 227
conditional operator (?:), 364, 367–368
conditions, 202–207
bool data type, 202
logical (Boolean) expressions, 202
overview of, 202
postconditions. See postconditions
preconditions. See preconditions
constant pointer, 826, 832
constants
adding comments to declarations, 65

Boolean, 202–203
declaring, 57–59
dynamic data and, 825–826
global, 459, 475–476
identifiers, 55, 59
as member functions, 694
program construction using, 68
relational operators for comparing, 203–205
constant-time complexity, of algorithm, 302
ConstIntExpression, enumerators, 532
const references, 978–979
constructor execution orders, 896
constructor initializers, 726
constructors
in ADT operations, 682
class, 685
for dynamic linked lists, 848
implementing class member functions with, 687
for instances of objects, 720
constructs, 49
container adapters, 1102
containers, 1065
content addressable access, 1102
Continue statement, 360–361
control abstraction, 500, 680. See also abstraction
control structures
additional C++ operators, 362–364
algorithms and, 13–14
assignment operators and expressions, 364
bitwise operators, 365–366
Break statement, 360–361
cast operation, 366
conditional operator (?:), 367–368
Continue statement, 360–361
Do-While statement, 349–353
GUI, 376–380
increment and decrement operators, 365
looping. See loops/looping
nested, 218–222
operator precedence, 368–369
programming languages and, 13–14
For statement, 353–357
Switch statement, 342–347
testing and debugging, 380
type coercion and, 369–371
control unit, 21
copy-constructors, 848, 850–852

C++ origins, 32
count-controlled loops
defined, 273
designing flow of control, 290–291
implementing with For statement, 353–357, 362
overview of, 273–276
test plan for, 327
counters, variables as, 273
counting, looping and, 282
cout variable
denoting output stream with, 62
example of, 148
mistaken use of, 189
outputting values to, 147
CPU (central processing unit), 20
CRC (classes, responsibilities, and collaborations) cards
as notational device, 911
overview of, 907–908
in scenario explorations, 907, 909–910
C strings, 756
cubic expressions, 305
D
dangling pointers, 824
data
binary representation of, 8–9
defined, 7
input failure from invalid, 169, 189
privacy of, 24–25
separating/combining with operations, 683
storage, 53
data abstraction, 680, 710. See also abstraction
data coverage, 251
data flow, for parameters, 394
data[length], in sorted lists, 777–779
data objects, 55
data representation, of abstract data, 681–682
data representation of objects, 913
data structures, 1055–1143
abstract date structures vs. implementations, 1056–1058
associative containers, 1102–1108
bidirectional linear structures, 1063–1064
bidirectional lists, 1063–1064
binary trees, 1097–1100
debugging and testing, 1133–1134
deques, 1064
dynamic, 829

graphical user interface, 1123–1133
hash tables, 1100–1102
linear structures, additional, 1058–1063
map template, 1106–1108
nonlinear, 1097–1102
overview of, 1056
priority queues, 1061–1063
queues, 1061
set template, 1103–1106
stacks, 1060–1061
Standard Template Library for. See Standard Template Library (STL)
data types
abstract, 680–682
arrays. See arrays
built-in simple types, 526–530
char data type, 54
classes. See classes
information hiding. See information hiding
numeric. See numeric data types
overview of, 53–55, 96
string. See string data type
type coercion and, 369
user-defined. See user-defined data types
Date class, adding to (case study), 1004–1011
debugging. See also testing
array-based lists, 811–812
classes, 738–747
compiling and running program and, 80–81
control structures, 380
C++ syntax and semantics and, 85–86
data structures, 1133–1134
defined, 6
functions, 441–443
with GUI, 741–746
loops, 326–329
modular design and, 500–506
Null pointers, 870
numeric types, expressions and output, 135–136
object-oriented designs, 961–963
pointers, 869–871
process of elimination and, 110
program input, 188–190
recursion, 1179
user-defined data types, 577–578
debug output statements, 329
deck of cards creation (case study), 1108–1123
declarations

assignment operations and, 62
classes, 685, 686–687
constants, 57–59
defined, 55
definitions vs., 402–403
file streams, 161
functions, 402–403
initialization in, 468
mixing with executable statements in blocks, 69–70
numeric data types, 99–101
of one-dimensional arrays, 592–593, 598–604
overview of, 55
program construction using, 66–68
structs, 544–545, 549–550
variable, 463–464
variables, 55–57
void functions, 402–404
decrement operators (- -)
overview of, 365
specialized, 362
unary operators, 104–105
deep copy operations, 850–851
default constructor, 685
default labels, Switch statement, 343–344
default parameters, 408
definitions
declarations vs., 402–403
function, 396–397, 399
namespace, 464–466
variable, 463–464
deleting
delete operators for, 820, 822–825
dynamic data, 822–825
from dynamic linked lists, 839–842, 859
from sorted lists, 785–787
DeMorgan, Augustus, 612
demotion (narrowing), 488
deques, 1064
deque template, 1083–1084
derived classes, 889
Descartes, René, 111
design
of classes. See class design
computer-aided, 887
documentation of, 178
of interfaces. See interface design
loops, 289–293

module interface, 393
in problem-solving phase, 170
of recording studios, 306–317
of software. See software design methodologies
structured. See functional decomposition
design specification, classes, 709
destructors
in ADT operations, 682
closing files, 163
for dynamic linked lists, 848
development models, software, 4
development process
compiling and running program, 80–81
constructing program, 66–68
data and data types, 53–55
declarations, 55–59
entering program, 80
executable statements, 59–65
identifiers, 51–52
output, 75–76
program structure, 46–48
syntax and semantics, 48–49
syntax templates, 49–51
testing and debugging, 85–86
diagrams, UML (Unified Modeling Language)
of classes, generally, 729–730
dialogs in graphical user interface, 184
Difference Engine, Babbage, 542, 612
direct addressing, 559
directives, 727
DirectoryDialog, in graphical user interface, 185
disk drives, 21
divide and conquer problem-solving, 29–30
division (/) operator, 102
documentation
defined, 7
function, 443
functions, 419–421
tips for, 178
dot notation
overview of, 125
using get function with, 152
double data type, 98
doubly nested loops, 299
Do-While statement
Break statement with, 360–361
guidelines for choosing, 362

overview of, 349–353
testing and debugging, 380–381
drivers, 501, 514
duplicate keys, 756–757
dynamic ADT
overview of, 835–837
dynamic ADT lists. See also array-based lists
creating empty, 837
deleting from, 839–842
implementing generally, 842–848
inserting into, 837–839
resetting, 842
searching, 843
testing for full, 843
traversals of, 839
dynamic binding
overview of, 903–904
slicing issues in, 904–905
virtual functions in, 905–906
dynamic data
allocating, 820–822
constants and, 825–826
deleting, 822–825
in linked lists. See dynamic linked lists
overview of, 820
dynamic data structures, 829
dynamic linked lists
constructors for, 848
copy-constructors for, 848, 850–852
copying, 1166–1170
creating, 828–835
creating empty, 837
deleting from, 839–842
destructors for, 848
implementing generally, 834–838, 843–848
inserting into, 837–839
printing in reverse order, 1164–1166
resetting, 842
searching, 843
I shallow vs. deep copying of, 848–850
testing for full, 843
traversals of, 839
E
echo printing
interactive I/O using, 158–160
noninteractive I/O using, 160

testing and debugging, 190, 256
editors, entering existing code, 16
electric circuits
binary representations of data and, 8–9
clock generating, 22–23
Electronic Numerical Integrator And Calculator (ENIAC), 397–398, 476
elements, C++ programs
data and data types, 53–55
declarations, 55–59
executable statements, 59–65
identifiers, 51–52
program structure, 46–48
syntax and semantics, 48–49
syntax templates, 49–51
else clause
defined, 208
nested If statements and, 222
empty string, opening file using, 188
empty window creation, in GUI, 931–934
encapsulation
abstraction and, 710
class design and, 707–709
modifiability and reuse and, 711–712
mutability of objects and, 712–713
overview of, 393
endl manipulator
creating blank lines, 77–78
generating newline character in output statement, 150
inserting blanks within line, 78
ofstream data type, 161
output formatting using, 117, 122
terminating output line, 64
end-of-file (EOF)-controlled loops, 278–280, 291
end-of-file errors, 188
English statements, changing into logical expressions, 230–231
ENIAC (Electronic Numerical Integrator And Calculator), 397–398, 476
Entry class
deriving classes from other classes and, 889–891
expanded. See ExpandedEntry class
inheritance and object-oriented design for, 889
overview, 790–794
Entry objects (case study), 860–862
EntryWithDate class, 921–922, 1086–1089
enumeration data types
assignment, 533–534
comparison, 535
defining own simple types with, 526–527

incrementation, 534
input and output, 535–538
overview of, 531–533
returning function value, 538–540
testing and debugging, 577–578
EOF (end-of-file)-controlled loops, 278–280, 291
Equal operation, class member functions, 690
errors
coping with input, 577–578
function, 441–443
messages, 16–17
side effects in, 473–475
software engineering tip for handling, 131–132
syntactic or semantic tests, 254–255
ethical issues
data piracy, 24
privacy of data, 24–25
evaluate, 60
event-controlled loops, 276–285
defined, 273
end-of-file-controlled loops, 278–280
flag-controlled loops, 280–281
guidelines for choosing looping statement, 362
sentinel-controlled loops, 276–278
test plan for, 327–328
event counter, 284
EventHandlers, GUI and, 946–961
event-handling interface, in GUI, 946–961
exam statistics (case study), 642–650, 796–806
exception handlers
defined, 994
formal parameters in, 997–998
nonlocal, 998–1000
exceptions, 974, 993–1004
in aircraft weight and balance (case study). See aircraft weight and balance (case study)
defined, 994
exception handlers, formal parameters in, 997–998
exception handlers, nonlocal, 998–1000
graphical user interface in, 1025–1043
overview of, 993–994
rethrowing, 1001
standard, 1001
thrown by language, 1002
thrown by standard library routines, 1002–1003
throw statements for, 994–995
try-catch statements for, 995–996
executable assertions, 442

executable statements
mixing with declarations in blocks, 69–70
overview of, 59–65
program construction using, 68
execution
overview of, 12
programs, 6
testing automatically during compilation, 254–255
execution (hand) trace, 248–250
exiting loops, 292–293
exit status, 68
ExpandedEntry class. See also Entry class
constructor execution order in, 896
deriving classes from other classes with, 889–891
implementation of, 892–896
specifications for, 891
explicit matching, 417
explicit type casts, 109
exponentiation program, 1147
exponents, floating-point values an, 98
expressions
assignment, 214, 364
avoiding using side effects in, 579–580
compound arithmetic, 105–109
defined, 60, 364
library functions in, 114–116
logical, 202–207
performing calculations with, 101–102
of pointers, 613–614
relational, 369–371
simple arithmetic, 101–105
string, 61–62
switch, 342
external declaration, 463
external pointers
in copying dynamic linked lists, 1166
in empty linked lists, 837
in linked lists, 828, 829, 832
in recursion, 1164
external representation, character, 529
extraction operator (>>)
ifstream data type, 161
and input streams, 147–150
reading string data with getline function vs., 155–156
review, 190
skipping characters with ignore function, 154–155
skipping newline characters, 150

using get function with, 151–153
ExtTime class
in dynamic binding generally, 903
slicing issues in, 904–905
virtual functions with, 905–906
F
factorials, 1149
fail state, 169
failure, input
causes of, 188–189
overview of, 169–170
false value, bool type, 526
familiarity, problem-solving and, 27
fear of starting, as mental block to problem solving, 30–31
fetch-execute cycle
computer speed and, 23
overview of, 21
field, of record, 544
fieldwidth specification
floating-point values, 120–122
integer values, 118–119
FIFO (first in, first out), 1061
FileDialog, in graphical user interface, 184
file input/output (I/O), 160–169
declaring file streams, 161
graphical user interface, 183–188
including header file fstream, 161
input failure from, 169
opening files, 162–163
reading data from files, 160
runtime input of file names, 167–168
specifying file streams in I/O statements, 163–164
testing and debugging, 188–189
file path in graphical user interface, 184
files
closing, 163
defined, 80
opening, 162–163
filtering
defined, 907
in object-oriented design, 909
first in, first out (FIFO), 1061
fixed manipulator, output formatting using, 118, 121–122
flag-controlled loops, 280–281, 291–292
flash memory, 21
flat (inline) implementation, 176

float data type
in class templates, 975–978
constructing complex arithmetic expressions, 101–105
defined, 53
domain of, 526
as floating type, 98
in function overloading, 986–988
floating data types
division and, 103
output formatting, 120–122
overview of, 98–99
relational operators with, 231
float variable, GUI, 240–241
flow of control
conditions and logical expressions and, 202–207
defined, 200
English statements changed into logical expressions, 230–231
in function calls, 399–400
If statements, 207–218
loop design and, 289–293
nested If statements, 218–222
selection (branching) control structure, 201
Switch statements, 343–345
testing state of I/O stream, 232–234
test plan for, 253–254
tests performed automatically during
compilation and execution, 254–255
While and Do-While loops, 350–351
For loops
in multidimensional arrays, 641
summing rows with, 631–632
formal interfaces, encapsulation and, 708
formatting output. See output formatting
form widget, in GUI, 937–941
For statement
Break statement used with, 360–361
guidelines for choosing, 362
overview of, 353–357
testing and debugging, 380–381
Fortran language, 707
forward declarations, 829–833, 844
forward iterators, 1067–1068
free format language, 123–124, 136
free store, 821
fstream header file file I/O and, 161
functional cohesion, 172, 500
functional decomposition design perspective, 178–179

developing test plan with, 253
documentation in, 178
implementing design, 174–178
modules, 172–174
object-oriented design vs., 170–171, 191
overview of, 171–172
review, 190–191
software design using, 170
tree structure in, 172
with void functions, 392–397
functional equivalence, modules, 172
functional notation, cast operation, 366–367
function calls (invocation)
abstraction and, 680
defined, 113
in value-returning functions, 114
for void vs. value-returning functions, 116
function definitions
defined, 87, 396
flow of control in, 399
function declarations vs., 402–403
as heading followed by block, 69
overview of, 404
program construction using, 66–68
scope rules for, 460
testing and debugging tips, 443
for void functions, 404
function overloading, 986–987
function prototypes
defined, 402
testing and debugging tips, 443
for void functions, 403–404
functions
arguments and, 154
capitalization of, 58–59
conceptual vs. physical hiding of, 418–419
declarations, 402–403
functional decomposition with void, 392–397
graphical user interface, 432–440
interface design, 472–476
library, 114–116
modules implemented as, 175–178
naming void, 407
parameters. See parameters
scope of identifiers, 458–466
specification and implementation, 680
string data type, 125–129

as subprograms, 46–47
syntax and semantics of void, 402–407
testing and debugging, 441–443, 500–506
type coercion and, 488–490
user-defined, 399–402
value-returning. See value-returning functions
variable lifetime and, 466–468
void, 116
when to use, 392–393
writing assertions as documentation of, 419–420
function templates
outside classes, 987
overview of, 977–978
function value (return or result) type, 478–479
G
general cases, 1147
generated classes, 977
generic algorithms, 986
generic data type, 975
generic functions
algorithms, 986
function overloading, 986–987
function templates, defining outside classes, 987
get function
accepting only variable as argument, 154
ifstream data type, 161
in loops controlled by newline character, 278, 328
reading character data with, 151–153
getline function, 156–157
GetNextItem
iterators and, 770–771
overview of, 759, 762
GHz (gigahertz), 23
GList class template, 975–985. See also List class
cautions regarding, 985
const references and, 978–979
defining, 975–976
instantiating, 976–978
in program code organization, 979–984
global constants
defined, 459
example using, 459–460
interface design and, 475–476
global scope
defined, 459
namespaces, 466

using directives and, 466
global variables
defined, 459
example using, 459–460
local variables vs., 404–405
scope rules for, 460–463
side effects in, 473–475
as static variables, 467
Goldstine, Herbert, 707
grade record arrays
subarray processing of, 621–624
using, 601–602
grammar. See syntax (grammar)
graphical user interface (GUI), 183–188
array-based lists and, 806–811
arrays, 650–651, 659–661
classes and, 737–738
components, 187–188
control structures, 376–380
data structures, 1123–1133
dialogs in, 184
error checking in, 377
file path in, 184
functions, 432–440
loops, 317–326
loop termination condition and, 321
in object-oriented design, 931–961
adding application state, 944–946
adding button widgets, 934–937
adding form widget, 937–941
adding list widget, 941–942
adding main widget, 942–944
creating empty window, 931–934
responding to events, 946–961
pointers, 863–869
problem-solving phase, 239–245
in templates, 1025–1043
testing and debugging with, 741–746
use of components, 243
user-defined data types, 571–577
value-returning functions, 506–513
version of BMI program, 242
graphs, 1100
grouping order (associativity), arithmetic expressions, 106
GUI. See graphical user interface (GUI)
H

HandleAddingCrew method, 1038–1039
hardware, 22
hash function, 1101
hashing, 1100
hash tables, 1100–1102
header files
defined, 71
file I/O with, 161
user-written, 695
head pointers, 829–833
health profile program (case study), 491–499
testing and debugging, 501–506, 513
heaps, 821
Hello Universe!, 15–19
Hidden Figures (Shetterly), 477
hiding, name precedence or, 459
hiding, of function implementation, 418–419, 500
hierarchical implementation, 176
hierarchical records, 553–555
hierarchical solution tree, 173
high-level languages, 10–12
Hoare, Sir Charles Anthony Richard, 1084–1085, 1171
Hopper, Grace Murray (Admiral), 347–348
I
IBM, 707
identifiers
capitalization of, 58–59
comments appear beside declarations, 65
declaring, 55–59
meaningful, readable, 52
naming memory locations with, 53
overview of, 51–52
scope of. See scope, identifier
self-documenting code using meaningful, 178
IDEs (integrated development environments), 985
If statements
blocks, 210–211
Break statement used with, 360–361
common mistakes, 214
execution order and, 270
If-Then, 212–214
If-Then-Else, 207–210
nested, 218–222
overview of, 207
testing and debugging, 256
While statement vs., 271–272

written order and, 200
written order vs. execution order and, 270
ifstream data type
closing files, 163
defined, 161
opening files, 163
testing state of I/O stream, 232
If-Then-Else-If control structure, 219, 344
If-Then-Else statement, 207–210
If-Then statement, 212–214
ignore function
ifstream data type, 161
skipping characters with, 154–155
immutable objects, 712–713
implementation
conceptual vs. physical hiding of functions and, 418–419
defined, 6
differences in, 6–7
of dynamic linked lists, 833–837
functional decomposition and, 174–178
functions, 680
information hiding and, 696, 698–701
overview, 3
testing during, 248–253
implementation files, ADTs and, 722–724
implicit matching, 417
inaccessible objects, 824–826
#include directive
preprocessors and, 71
program construction using, 68
include statement,
accessing dialog library with, 183
adding titles to names, 73
incoming parameters, 978–979
incomplete declarations, 829
incorrect output (case study), 215–218
Increment function, class member functions, 688
increment operators (++)
enumeration types and, 534
incrementing variables using, 274
overview of, 365
specialized, 362
unary operators, 104–105
increment variable, loop control, 274
indexes
as constants, variables, and complex expressions, 594–595
defined, 591

out-of-bounds array, 595–597
with semantic content, 624
index values, 591
indirect addressing, 559, 578
infinite loop
Break statement with, 360–361
defined, 4, 274–275
testing and debugging, 328
infinite recursion, 1148–1149
information, 7
information hiding, 693–703
compiling and linking multifile programs, 701–703
implementation file and, 696, 698–701
overview of, 693–694
specification file and, 696–698
user-written header files and, 695
inheritance
constructor execution order in, 896
deriving classes from other classes, 889–891
in ExpandedEntry class, 892–896
object-oriented design and, 889
overview of, 884
TimeOfDay, extending with time zone support (case study), 897–902
initialization
in declarations, 468
loop control variable, 274
of one-dimensional arrays, 597
of two-dimensional arrays, 634–635
initializer, defined, 468
InitStatement, For statement, 353–357
in-order traversals, 1099
input
compilation and execution of, 12
error handling, 577
failure, 169–170
file I/O, 162–167
If-Then-Else for checking validity of, 208–209
input devices for, 12, 20–23, 146
interactive I/O, 158–160
manipulators for, 118
noninteractive I/O, 160
operating system carrying out, 22
source program as, 10–12
storing in auxiliary storage device, 21
testing and debugging, 188–190
input, into programs
input streams and extraction operator, 147–150

reading character data with get function, 151–154
reading marker and newline character, 150–151
reading string data, 155–157
skipping characters with ignore function, 154–155
input prompts, 158–160
input streams, 147–150
input values, of enumerated types, 535–538
input/output. See I/O (input/output)
inserting
into dynamic linked lists, 835, 837–839
into sorted lists, 777–779
insertion operator (<<)
extraction operator compared with, 147
ofstream data type, 161
output statements and, 62
insertion sorts, 779
instances
constructing, 720
object, 688
instantiation, object, 690
int array, 605
int data type, 48
constructing complex arithmetic expressions, 102
defined, 53
domain of, 526
input failure from, 169
as integral type, 96–98
syntax template for main function, 51
integers
converting to strings, 728
output formatting, 117–120
testing and debugging, 577
integral data types
division and, 102
overview of, 96–98
integrated development environments (IDEs), 985
integrated environment, C++, 702
interactive I/O
defined, 190
overview of, 158–160
interface design, 472–477
global constants, 475–476
modules, 393
overview of, 472–473
side effects, 473–475
value-returning functions and, 487
interfaces

defined, 393
encapsulation and, 707–709
user/computer, 22
internal representation, characters, 529
International Standards Organization (ISO), 32
Internet, 22
interpretation, compilation vs., 12
invalid data
coping with input errors, 577–578
as source of input failure, 169, 189
An Investigation of the Laws of Thought... (Boole), 229
invocation. See function calls (invocation)
I/O (input/output)
devices, 21–22
file I/O. See file input/output (I/O)
program I/O, 692
iostream header file, 161, 164
ISO (International Standards Organization), 32
IsThere
in binary searches, 785
in searching and sorting, 788
istream data type
get function, 151–154
ignore function, 154–155
managing program I/O with, 692
testing state of I/O stream, 232
iteration
in ADT operations, 682
defined, 272
recursion vs., 1170–1171
iteration counter, 282
iterators
in array-based lists, 770–771
in Standard Template Library, 1067–1068
J
Java
compiler and interpreter, 12
Unicode and, 8
Johnson Computational Research Facility (NASA), 477
Johnson, Katherine G., 476–477
K
keyboard
as input device, 21, 146–150
reading data from files vs., 160, 164

keys, 756
keyword cast, 366
knowledge responsibilities, public methods of objects, 704
L
LAN (local area network), 22
last in, first out (LIFO), 1060
lawn care application (case study), 421–431
leaf nodes, 1097–1100
leap year program (case study)
follow-up, 42–43
overview of, 33–36
reserved words in, 52
left children, 1097–1100
left subtrees, 1097–1100
length of lists, 756
library functions, 113–116
lifetime, variable, 466–468
LIFO (last in, first out), 1060
linear relationships, 756
linear searches. See sequential searches linear structures, 1058–1063
linear-time complexity, of algorithm, 302
linked lists
bidirectional, 1063–1064
defined, 827
dynamic. See dynamic linked lists
overview of, 820–827
pointers and. See pointers
sequential structures vs., 827–828
sorted. See sorted linked lists
linking multifile programs, 701–703
List class
class templates for, 975–978
sorts, enhancing with, 771–775
List, enhancing with sorts, 771–775
lists
abstract form vs. implementation of, 1056–1058
bidirectional, 1063–1064
length of, 756
linked. See linked lists
parameter. See parameter lists
sorted. See sorted lists
unsorted, 756
list template, 1075–1078
list widgets, in GUI, 941–942
literals, named constants instead of, 100
literal strings

concatenation working with, 61
output formatting, 117–120
output statements printing, 64
literal values
defined, 57
enumeration types and, 531–532
local area network (LAN), 22
local scope
defined, 459
rules for, 460–463
local variables
access rules for, 458
scope rules for, 462–463
static reserved word for declaring, 467
void functions and, 404–405
writing function documentation, 419–421
logarithmic order, 789
logical (Boolean) expressions
Boolean variables and constants, 202–203
conditions in While statement as, 270
English statements converted to, 230–231
If statements. See If statements
relational operators, 203–205
string comparison, 206–207
testing and debugging, 255–257
logical (Boolean) operators, 223–232
overview of, 223–227
precedence rules for, 229–230
short-circuit evaluation, 227
logical order, 202
logic errors, handling, 80
long data type, 96–97
long double data type, 97, 98
loop control pointers, 843, 858
loop control variables, 273–274
loop implementation (case study), 357, 550–553
loops/looping
analysis of algorithms, 301–305
Break statements, 360–361
Continue statements, 360–361
as control structure of programming language, 13
count-controlled, 273–276
count-controlled loops. See countcontrolled loops
counting and, 282
Do-While statements, 349–353
entry, 272
event-controlled. See event-controlled loops

exit, 272, 292–293
flow of control design, 290–292
For statement, 353–357
graphical user interface, 317–326
guidelines for choosing statement for, 362
keeping track of previous value, 284–285
overview of, 270
phases of loop execution, 272
process design, 292
sentinel-controlled loops. See sentinel-controlled loops summing and, 282–284
testing and debugging, 326–329
While statements, 270–272, 349–351
loop termination condition
defined, 272
designing flow of control, 290–292
GUI and, 321
loop exit and, 292–293
nested logic, 294
testing and debugging hints, 328
loop test, 272
Lovelace, Ada, 611–613
Lovelace, Lord William, 612
Lucas, John, 1084
M
machine language (code)
defined, 9
translating assembly language into, 10
macros, 934
main function
constructing programs, 67
executing programs, 87
GUI, 376
overview of, 46–48
syntax template for, 50–51
writing modules as void functions, 394–397
maintenance phase
effort expended in, 7
overview, 4
program life cycle and, 14
software, 14–15, 19
main widget, in GUI, 942–944
malware, 25
manipulators
defined, 64
specifying for floating-point values, 121–122
specifying for integer values, 117–120

map template, 1106–1108
markers, reading, 150–151
The Mathematical Analysis of Logic (Boole), 228
McNulty, Kathleen, 397–398
meaning. See semantics (meaning)
means-end analysis, for problem-solving, 28–29
member functions, const, 694
members, class
implementing functions, 687
objects and, 690–691
member selector, 546
memory leaks, 823
memory unit (RAM)
affecting computer speed, 23
defined, 20
mental blocks, to problem solving, 30–31
merging solutions, for problem-solving, 30
message passing, objects, 704
message variable, GUI, 241–243
metalanguages
defined, 48
overview of, 49
using identifiers to name things, 52
methods, object, 703–704
minimum complete coverage, 251
mixed type (mode) expressions, 108–109
mnemonic, 10
modifiability, class design, 711–712
modular programming. See functional decomposition
modularizing programs, 608–610
modules
coding as functions, 392–393, 413–416
documentation of, 413–414
functional decomposition and, 172–174
hierarchical solution tree, 173
implementing functional
decomposition, 175–178
interface design for, 393
summary, 191
testing separately, 189
writing as void functions, 394–397
modulus (%) operator, 102
mortgage program (case study)
expanding capabilities in, 285–288
functional decomposition
implementation for, 174–178
incorrect output in, 215–218

payment calculator in, 132–135, 143
refactoring in, 410–416
mouse, as input device, 21
multidimensional arrays, 640–642, 663–664
multifile programs
compiling and linking, 701–703
defined, 418
multiway branches
defined, 218–219
nested If statements for coding, 218–219
Switch statement as control structure for, 342–347
Murray (Hopper), Grace Brewster, 347
mutability, class design, 712–713
mutators. See transformers
N
\n (newline character)
defined, 79
get function in loops controlled by, 278, 328
reading, 150–151
review, 190
sentinel-controlled loops, 277
NACA (National Advisory Committee for Aeronautics), 476–477
named (symbolic) constants
capitalization of identifiers representing, 59
declarations for, 100
defined, 57
named data types, 540–541
named matching, 417
names
clashes, 466
elements, 55
memory locations, 53
precedence (hiding), 459
program elements, using identifiers, 52
run time input of file, 167–168
user-defined types, 530
value-returning functions, 487
void functions, 407
namespace keyword, 464–466
namespaces, 464–466
NASA, 477
National Advisory Committee for Aeronautics (NACA), 476–477
NDEBUG, 442
nested For statements, 354
nested If statements
dangling else and, 221–222

overview of, 218–221
Switch statement similar to, 342
nested logic, 294–301
analysis of algorithms, 301–305
designing nested loops, 298–301
overview of, 294–297
networks, 22
Neumann, John von, 706–707
new operators, 820–821
nodes
copying, 851–852
deallocating, 848–849
deleting from linked lists, 839–842
in dynamic implementation of ADT lists, 835–836
in inserting into linked lists, 837–839
leaf, 1097–1100
in linked lists, 827–835
in sorted link lists. See sorted linked lists
in traversals of linked lists, 836
noninteractive I/O, 160, 191
nonlinear data structures, 1097–1102
nonlocal identifier, 460
NOT operator (!)
flag-controlled loops using, 281
overview of, 223–225
Null pointers, 578–580
in copying dynamic linked lists, 1166–1170
in deleting from linked lists, 839–842
in dynamic implementation of ADT lists, 835
in dynamic linked lists, 829
in empty linked lists, 837
in inserting into linked lists, 838
introducing, 563
in recursion, 1164
reference types and, 578
in sorted link lists, 853
testing and debugging, 870–871
in traversals of linked lists, 839
null (empty) string, 54
numeric data types. See also arithmetic expressions; output formatting
as built-in simple types, 527–528
declarations for, 99–101
floating, 98–99
integral, 96–98
named constants vs. literals, 100
O

O(N) algorithms, 789
object-oriented design
graphical user interface, 931–961
object-oriented design (OOD)
brainstorming in, 908–909
dynamic binding and, 903–907
filtering in, 909
focus of, 907
functional decomposition in, 178
generally, 170, 178–179
implementing, 913
inheritance and. See inheritance
object-oriented programming and, 884–886
overview of, 884–885, 907–908
responsibility algorithms in, 910
scenario exploration in, 907, 909–910
software design using, 170
solutions, assessing, 911–912
testing and debugging, 961–963
object-oriented programming (OOP)
C++ equivalents of OOP terms, 703–704
in object-oriented design, 884–886
overview of, 703–707
object-oriented programming languages, 885
object program, 10
objects
attributes of, 703–704
built-in operations on, 691–692
as class values, 690
instances of, 688
mutability of, 712–713
OOP and, 703–707
overview of, 703–704
OBOBs (off-by-one bugs), 293
observer operations, ADTs, 682, 720
octal number system, 98
off-by-one bugs (OBOBs), 293
ofstream data type
clowwwqqqqsing files, 163
defined, 161
opening files, 162
testing state of I/O stream, 232
one-dimensional arrays
accessing components of, 593–595
accessing generally, 598–604
aggregate operations in, 597–598
as arguments, 607

commenting, 607
declaring, 592–593, 598–604
defined, 592
initializing, in declarations, 597
modularizing programs with, 608–610
out-of-bounds indexes and, 595–597
passing as arguments, 605–607
testing and debugging, 661–662
Typedef with, 613
OOD (object-oriented design). See object-oriented design (OOD)
OOP (object-oriented programming). See object-oriented programming (OOP)
open function
input failure from, 170
opening files, 162
testing and debugging, 190
opening files, preparing for reading or writing, 163
operating systems
calling main function, 48
defined, 22
operations
ADT categories, 682
built-in operations on objects, 691–692
separating/combining with data, 683
of sorted lists, 775
operator functions, 989
operator overloading, 973–974, 989–992
overview of, 989–991
review, programming warm-up exercises, 1049–1051
review, summary, 1045–1046
*this for, 992
operators
arithmetic, 101–104
assignment expressions and, 364
bitwise, 365–366
cast operation, 366–367
conditional, 367–368
increment and decrement, 104–105, 365
logical. See logical (Boolean) operators
overview of, 362–364
precedence, 229–230, 368–369
relational. See relational operators (==)
sizeof, 367
specialized, 362
order of magnitude, 303–304
OR operator (||), 223–225
ostream data type
managing program I/O with, 692

testing state of I/O stream, 232
ostringstream class, 728
out-of-bounds indexes, 595–597
output
enumerated type output values, 535, 538
file. See file input/output (I/O)
interactive I/O, 158–160
noninteractive I/O, 160
OutputDialog, in graphical user interface, 183, 185–186
outputDirectory, in graphical user interface, 185
output formatting, 117–124
creating blank lines, 77–78
floating-point numbers, 120–122
inserting blanks within line, 78
integers and strings, 117–120
matters of style, 122–124
output stream
denoting with cout variable, 62
terminating, 63–65
Oxford University, 1084
P
parameter lists
testing and debugging, 443
testing functions, 441
parameters
cautions regarding argument and parameter lists, 417–418
declaring, 401
defined, 401
incoming, 978–979
overview of, 407–408
reference, 409–410
scope rules for, 460–463
user-defined functions and, 399–402
value, 408–409
Pascal, Blaise, 110–111
pass by reference, 416. See also reference parameters
pass by value, 417. See also value parameters
passenger/crew entry form connections, 1032–1033
passenger/crew entry form design, 1032
PassengerManifestWidget, 1025–1043
passing as arguments
one-dimensional arrays, 605–607
two-dimensional arrays, 628–630
passive error detection, 578
pathAppend, in graphical user interface, 185
peripheral devices, computers, 21

physical hiding, of function implementation, 418–419, 500
physical order, of functions, 399–402
piracy, data, 23
pointers, 820–821
dynamic data and. See dynamic data
expressions of, 561–562
graphical user interface, 863–869
linked lists and. See linked lists
overview of, 820–821
testing and debugging, 869–871
types of, 557
variables of, 557–561, 562
pointer variables, 1164–1166
polymorphic operations, 906
polymorphism. See dynamic binding
polynomial expressions, 305
pop operations
in deques, 1064
in priority queues, 1061–1063
in priority_queue templates, 1081–1082
in queues, 1061
in stacks, 1060–1061
portable (machine-independent) code, 10
positional matching, 417
postconditions
assertions as function documentation, 419–420
developing test plan with, 253
problem-solving phase and, 246
testing functions, 441–442
writing function documentation, 419–420
postfix operators, 105
post-order traversals, 1099
posttest loop, 350
precedence rules
arithmetic expressions, 106–107
operators, 229–230, 369
preconditions
developing test plan with, 253
problem-solving phase and, 246
testing functions, 441
writing assertions as function documentation, 419–420
writing function documentation, 419–421
prefix notation, cast operation, 366
prefix operators, 105
pre-order traversals, 1099
preprocessor, 70–71
preprocessor directive

defined, 71
file I/O and, 160
stream I/O and, 147
pretest loop, 350
priming read, 276–277
printing
echo. See echo printing
two-dimensional arrays, 635–638
priority queues, 1061–1063
priority_queue template, 1081–1083
privacy of data, 24–25
private, declaring private class member, 686
problem-solving case studies
adding to Date class, 1004–1011
aircraft weight and balance. See aircraft weight and balance (case study)
appointment calendar creation, 913–931
appointment calendar using STL list. See appointment calendar using STL list (case
study)
array of name objects, creating an, 731–736
BMI calculator, 234–239, 267
chessboard program, 81–85, 93
deck of cards creation, 1108–1123
displaying name in multiple formats, 179–182
Entry objects, 860–862
exam statistics, 642–650, 796–806
health profile program, 491–499
lawn care company billing, 421–431
leap year program. See leap year program (case study)
mortgage payment calculator, 132–135, 143
Quicksort algorithm, 1171–1178
recording studio design, 306–317, 340
refactoring program, 410–416
RichUncle program, 371–376, 389
rock group, 652–659
software maintenance. See software maintenance (case study)
stylistic analysis of text, 564–571
TimeOfDay objects, 713–719
problem-solving phase
analysis and design in, 170
computer programming, 3
graphical user interface, 239–245
testing in, 246–248
problem-solving techniques
algorithms, 31
analogies, 27–28
building-block approach, 30
divide and conquer, 29–30

fear of starting, 30–31
looking for familiar things, 27
means-end analysis, 28–29
merging solutions, 30
questions, 27
procedural programming, 884
processing arrays, 621–624, 630–638
program code organization, 979–984
programming languages
assembly languages, 10
control structures and, 13–14
high-level languages, 10–12
metalanguages, 48, 49
OOP and, 703–707
overview of, 5–7
selection (branching) control structure and, 13
programs/programming. See also problem-solving techniques
algorithms, 4–5
binary representations of data and, 7
computer components, 20–23
computer programs. See computer programs
constructing programs, 66–76
definition of, 2
developing programs. See development process
entering programs, 80
ethics and responsibilities of, 24–26
executing programs, 6
linking multifile programs, 701–703
programming languages and, 5–7
running and compiling programs, 80
stages in writing, 2–4
structure of programs, 46–48
project files, in integrated environment, 702
promotion (widening), 369
prompts, input, 158–160
Provincial Letters (Pascal), 112
pseudocode, 174, 178
ptr (pointer)
in copying dynamic linked lists, 1166–1170
in printing dynamic linked lists in reverse order, 1164–1166
public, declaring public class member, 686
push operations
in deques, 1064
in priority queues, 1061–1063
in priority_queue templates, 1081–1082
in queues, 1061
in stacks, 1060–1061

Q
quadratic expressions, 305
qualified names, namespaces, 464
questions
asking as assertions in C++, 202
programming and, 27
queues, 1061
queue template, 1080–1081
Quicksort algorithm (case study), 1171–1178
R
raising exceptions, 994
RAM (memory unit)
affecting computer speed, 23
defined, 20
range of values, numeric data types, 528
reading
character data with get function, 151–154
marker and newline character, 150–151
string data, 155–157
records (structs), 544–549
accessing individual components, 546–547
aggregate operations on, 547–549
binding like items, 550
declarations, 549–550
defined, 543
hierarchical, 553–555
overview of, 544–546
recursion, 1146–1149
defined, 1146–1149
dynamic linked lists, copying, 1166–1170
dynamic linked lists, printing in reverse order, 1164–1166
iteration vs., 1170–1171
overview of, 1146
pointer variables in, 1164–1166
recursive algorithms with simple variables, 1149–1151
recursive algorithms with structured variables, 1156–1158
testing and debugging, 1179
in Towers of Hanoi game, 1152–1156
recursive algorithms
defined, 1147
with simple variables, 1149–1151
with structured variables, 1156–1158
recursive calls, 1146
recursive definitions, 1146
refactoring program (case study), 410–416
reference parameters

avoiding side effects in value-returning module, 487
coding outgoing and incoming/outgoing data as, 472–473
const, 978–979
defined, 407
overview of, 409–410
pass by address mechanism, 416
testing and debugging tips, 443
usage, 410
reference types, 562–563
relational expressions, 369–371
relational operators
common mistake, 214
with floating point types, 231
If statements, 205
overview of, 203–205
precedence rules for, 229–230
While statements, 278
relative matching, 417
reliable, software unit, 708
reserved words
defined, 52
public and private, 686
resetting dynamic linked lists, 842
resources, ethics and, 25
responding to events, in GUI, 946–961
responsibilities
algorithms for, 907
assigning to classes, 907, 910
defined, 907
in public methods of objects, 704
responsibility algorithms, 907, 910
rethrowing exceptions, 1001
Return statement
value-returning functions, 478–479
void function, 405–406
reuse, class design and, 711–712
reverse iterators, 1067–1068
ReverseNumbers program, 590–592
right children, 1097–1100
right subtrees, 1097–1100
Ritchie, Dennis, 32
rock group (case study), 652–659
row processing, 636
rowsFilled, 632–633
running pointer, 1164
run time, 976
binding. See dynamic binding

input of file names, 167–168
lifetime as issue of, 466
S
sales array, 641
scenario explorations
defined, 907
in object-oriented design, 909–910
scientific notation, 98
scope, class, 692–693
scope, identifier, 458–466
namespaces, 464–466
overview of, 458–460
scope rules, 460–464
variable declarations and definitions, 463–464
scope resolution operator (::), 464
scope rules
names of user-defined types obeying, 531
overview of, 460–463
searching
binary search trees in, 1097–1099
dynamic linked lists, 843
sorted lists, 788–789
selection (branching) control structure
overview of, 201
programming languages and, 13
Switch statement as, 360–361
testing, 248–253
self-documenting code, 178
semantics (meaning)
assignment operators and, 60
overview of, 48–49
semantic (logic) errors, 254–255
semihierarchical implementation, 176
sentinel-controlled loops
designing flow of control, 291
end-of-file-controlled loops vs., 279
overview of, 276–278
sentinel (trailer) value, 276–278
sequence, as control structure, 13
sequence containers, 1102
sequential searches, 779–780
sequential structures, 827–828
setprecision manipulator
ofstream data type, 161
output formatting using, 118, 121–122
set template, 1103–1106

setw manipulator
ofstream data type, 161
output formatting using, 118, 121–122
shallow copy operations, 849–850
Shetterly, Margot Lee, 477
Shickard, Wilhelm, 111
short-circuit (conditional) evaluation, 227
short data type, 96–97
showpoint manipulator, 118, 120, 122
siblings, 1097–1100
side effects
avoiding using in expressions, 579–580
functions and, 473–475
interface design and, 487
testing and debugging, 506
- (minus) sign, in integral types, 97
simple arithmetic expressions, 101–105
simple (atomic) data types
built-in, 526–530
defined, 526
enumerating. See enumeration data types
vs. structured data types, 543–544
user-defined, 530
size of arrays, 621
sizeof operator
defined, 367
measuring in multiples of char, 527–528
overview of, 367
slicing issues, 904–905
Smalltalk programming language, 704
software
affecting computer speed, 23
data, 23
defined, 22
maintenance, 14–15, 19
waterfall model of developing, 4
software design methodologies
documentation, 178
functional decomposition, 171–179
graphical user interface, 183–188
object-oriented design, 170–171
testing and debugging, 188–190
software engineering
conceptual vs. physical hiding of functions, 418–419, 500
documentation, 178
English statements converted to logical expressions, 230–231
named constants vs. literals, 100

overview of, 25–26
understanding errors before changing, 131–132
software maintenance (case study)
adding file I/O to program, 164–167
adding titles to names, 72–76
changing loop implementation, 550–553
in changing loop implementation (case study), 357–359
in creating general program (case study), 285–288
debugging simple program, 468–472
essential steps of, 15–19, 72
incorrect output in, 215–218
modularizing programs with arrays in, 608–610
precedence error in, 109–110
refactoring program in, 410–416
TimeOfDay, extending with time zone support, 897–902
solutions, problem-solving by merging, 30
sorted linked lists
deleting from, 858–859
of Entry objects (case study), 860–862
insert and, 858–858
overview of, 852–853
sorted lists, 775–789
binary searches and, 780–785
of classes, generally, 790–791
defined, 756
Delete, 792–794
deletions generally, 785–787
Insert, 792–794
insertions generally, 777–779
IsThere operation, 791
linked. See sorted linked lists
operations generally, 777
overview of, 775–777
searching, 788–789
sequential searches, 779–780
sorting, 788–789
sorting
complexity of, 788–789
defined, 771
lists. See sorted lists
source program
defined, 10
special characters, 79
specialization of templates, 977
specification files
ADTs and, 719–722
information hiding and, 696–698

specification, of function, 680
speed, factors affecting computer, 22
spiral model, of software development, 4
splitting data, 1172–1176
stacks, 1060–1061
stack template, 1078–1079
stand-alone computers, 22
standard (built-in) data types, 53
standard exceptions, 1001
Standard Template Library (STL)
appointment calendar using. See appointment calendar using STL list (case study)
data structures using. See data structures
array template in, 1074–1075
deque template in, 1083–1084
introduction to, 1065–1066
iterators in, 1067–1068
list template in, 1075–1078
priority_queue template in, 1081–1083
queue template in, 1080–1081
stack template in, 1078–1079
vector template in, 1068–1074
statement flow control, 200
static binding, 903
static_cast, 366
static variables, 467
std namespace, 71–72
stepwise refinement. See functional decomposition
STL (Standard Template Library). See Standard Template Library (STL)
storage
data, 53
storage (auxiliary) devices, 21, 146
Strachey, Christopher, 1085
straight selection sorts, 772
stream input/output (I/O), 147
string class, 543
string constants, 61
string expressions, 61–62
strings
character operations, 129–131
comparison of, 206–207
concatenation of, 61–62
find function, 126–128
at function, 129–130
integers converted to, 728
length and size functions, 125–126
null (empty) string, 54
output formatting, 117–120

overview of, 54–55
reading character string into, 190
reading data into, 155–157
substr function, 128–129
stringstream class, 728
string variables, 156, 167
Stroustrup, Bjarne, 32
struct data type. See records (structs)
structural programming, 884
structure
C++ program, 46–48
programming language control, 13–14
structured data types
arrays. See arrays
classes. See classes
vs. simple, 543–544
structured design. See functional decomposition
stubs, 501, 514
style
braces and blocks, 212
function documentation, 420–421
naming value-returning functions, 487
program formatting, 123–124
stylistical analysis of text (case study), 564–571, 587
subarray processing, 621–624
subclasses, 889
subprograms
as control structure, 13–14
C++ program structure, 46
subroutine, McNulty idea of, 397–398
subtrees, 1097–1100
summing
columns, 633–634
columns as functions, 632–633
rows, 631–632
superclasses, 889
supercomputer Kay, 398
switch expression, 342
overview of, 342–347
SwitchLabel, 343
Switch statement
testing and debugging, 380–381
using Break statement with, 360–361
syntax (grammar)
assignment operators, 60
blocks, 68
C++ (generally), 49–51

compound statements, 69
Do-While statements, 349
enumeration types, 532
errors, 49, 80, 254–255
function call to void function, 402
If-Then, 213
If-Then-Else, 207–208, 210
input statements, 148
overview of, 48–49
programs, 66
For statement, 354
Switch statement, 342
value-returning functions, 479
variable declarations, 56
void functions, 479
While statements, 270
T
tall recursions, 1158
team programming, 394
template arguments, 977, 987
template class, 977
templates, 974–985, 1053
cautions regarding, 985
class, defining, 975–976
class, instantiating, 976–978
const references and, 978–979
function, defining outside classes, 987
generic functions and. See generic functions
graphical user interface, 1025–1043
operator overloading and. See operator overloading
overview of, 974–975
parameters of, 976
in program code organization, 979–984
testing and debugging, 1044–1045
templates, C++, 49–51
testing
aircraft weight and balance, 1023–1024
array-based lists, 811–812
arrays, 661–665
automatically during compilation and execution, 254–255
classes, 738–747
control structures, 380
data structures, 1133–1134
dynamic linked lists, 843
functions, 441–443
with GUI, 741–746

in implementation phase, 248–253
loops, 326–329
modular design, 500–506, 513
multidimensional arrays, 663–664
numeric types, expressions and output, 135–136
object-oriented designs, 961–963
one-dimensional arrays, 661–662
plan for, 253–254
pointers, 578–579, 869–871
problem-solving phase and, 246–248
program input, 188–190
recursion, 1179
stream state, 232–234
syntax and semantics, 85–86
templates, 1044–1045
user-defined data types, 577–578
test plans
defined, 253
implementation, 253
for loops, 327–328
TextDialog, in graphical user interface, 183
then-clauses, 208
theoretical foundations, of algorithm, 301–305
throwing exceptions
defined, 994
by language, 1002
rethrowing, 1001
by standard library routines, 1002–1003
throw statements, 994–995
thunk, defined, 417
TimeOfDay class
assigning responsibilities to, 909
in dynamic binding generally, 903
implementing ExpandedEntry class with, 892–893
slicing issues in, 904–905
virtual functions with, 905–906
TimeOfDay objects (case study), 713–719
top-down design. See functional decomposition
Towers of Hanoi game, 1152–1156
trackpads, as input device, 21
trailing pointers, 841, 842, 853
transformers
in ADT operations, 682
as example of action responsibility, 713
traversals
of dynamic linked lists, 839
in-order, 1099

post-order, 1099
pre-order, 1099
Treatise on Differential Equations (Boole), 229
Treatise on the Calculus of Finite Differences (Boole), 229
tree structure
functional decomposition and, 172
implementing, 174–178
triply nested loops, 299
true value, bool type, 526
try-catch statements, 995–998
Turing, Alan, 707
two-dimensional arrays
defining, alternate method for, 638–640
initializing, 634–635
introducing, 624–627
passing as arguments, 628–630
printing, 635–638
processing, 630–638
summing columns as functions, 632–633
summing columns, generally, 632–633
summing rows, 631–632
type casting (conversion), 107–109
type coercion
in arithmetic and relational expressions, 369–371
in assignments, in argument passing, and in return of function values, 488–490
overview of, 107–109
Typedef statement, 530–531, 613
TypeName, record data type, 544
U
UML (Unified Modeling Language), 729–730
UML diagrams
array-based lists, 794–796
unary operators
defined, 102
increment and decrement, 104–105
Unicode
characters, 528
defined, 8
union data types
overview of, 555
as structured data type, 544
unique keys, 756–757
UNIVAC company, 398
unsigned integer value, 97
unsigned reserved word
numeric data types, 528

unsorted lists, 756
user/computer interface, 22
user-defined data types
built-in simple types, 526–530
capitalization of, 58–59
defined, 53
graphical user interface (GUI), 571–577
hierarchical records, 553–555
records (structs), 544–549
simple types, 530–541
simple vs. structured data types, 543–544
testing and debugging, 577–578
unions, 555–557
user-defined functions
flow of control, 399–402
parameters, 400–401
user friendly, 215
UserInterface class, 926–927
user-written header files, 695
using declaration, namespaces, 465
using directive
adding titles to names, 73
clashes, 466
utility library function, in GUI, 185
V
value parameters
arguments, 417
coding incoming data as, 472–473
defined, 407
overview of, 408–409
pass by value mechanism, 417
testing and debugging tips, 443
usage, 410
value-returning functions, 476
Boolean functions, 484–486
complete example of, 481–484
enumerated types as, 538–539
graphical user interface, 506–513
ignoring value returned by, 490
interface design and side effects, 487
invoking void functions vs., 116
naming, 487
overview of, 116, 478–480
testing and debugging, 506, 513
type coercion in, 488–490
void functions vs., 392

when to use, 488
values
atomic, 526
of enumerated types, 535
literal. See literal values
range of, 528
variable definition, 463–464
variables
assignment statements and, 60
Boolean, 202–203
capitalization of identifiers, 58–59
comments added to declarations, 58
as counters, 273
declaring, 55–57, 463–464
declaring numeric, 100–101
defined, 55
in expressions, 103
in function headings, as parameters, 401
global, 459
identifiers, 56
input statements and, 149, 190
keeping track of previous value of, 284–285
lifetime of, 466–468
of pointers, 557–561, 562
program construction using, 69
relational operators for comparing, 203–205
vector template, 1068–1074
virtual functions, 905–906
viruses, 25
void functions
declarations and definitions, 402–404
functional decomposition with, 392–397
function call to, 402
local variables, 404–405
naming, 407
overview of, 116
return statement and, 405–406
when to use, 488
W
WAN (wide area network), 22
waterfall model, of software development, 4
wchar_t data type, Unicode, 528
While statement
Break statement with, 360–361
defined, 270
Do-While statement vs., 349–351

For statement for writing, 354
guidelines for choosing, 360–361
white-box (clear-box) testing, 251
whitespace characters, 149–152
wide area network (WAN), 22
worms, 25
written order of statements, flow of control vs., 270
Z
ZeroOut function, 605, 608–610, 621
zombies, 25

The brief contents page of the book. A background image of a forest
is featured.
Back to Breif Contents
The contents page of the book. A background image of a forest is
featured.
Back to Contents
The preface page of the book. A background image of a forest is
featured.
Back to Preface
Vehicle is labeled at the top center. Vehicle is divided into 2 parts as
wheeled vehicle, and Boat. Wheeled vehicle is further divided into 2
parts as Car, and Bicycle. Car is further divided into 2 parts as Two-
door, and Four-door.
Back to Figure
6 illustrations are arranged 2 in each row. Row 1, illustration 1. A
stack of 3 rectangles is enclosed in a block labeled Basic Empty
Floor. The third rectangle from the top is divided into 2 parts. The
values in the stack from the top are as follows: Util dot Trunk, Stair,
Elev dot; and Janit dot. Row 1, illustration 2. A hierarchical chart.
Basic Empty Floor is labeled at the top center. It is further divided
into 2 parts as Empty Office Floor, and Mechanical Floor. Empty
Office Floor is further divided as Executive Office Floor, and
Standard Office Floor. Row 2, Illustration 3. A stack of 3 rectangles
is enclosed in a block labeled Mechanical Floor. The third rectangle
from the top is divided into 2 parts. The values in the stack from the
top are as follows: Util dot Trunk, Stair, Elev dot; and Janit dot. A
text that reads, Heating, slash, ventilation; Air conditioning is labeled
above the stack. A text that reads, Electrical transformer and
Distribution is labeled at the bottom left corner to the stack. A text
that reads, Phone and Data Networks is labeled at the bottom right
corner to the stack. Row 2, illustration 4. A stack of 4 rectangles is

enclosed in a block which is enclosed in a block labeled Empty
Office Floor. The first, and the fourth rectangle is divided into 2
parts. The values in the stack from the top are as follows: Lav dot;
and Lav dot, Util dot Trunk, Stair, Elev dot; and Janit dot. Row 3,
illustration 5. A stack of 4 rectangles is enclosed in a block which is
enclosed in a block labeled Executive Office Floor. The first, and the
fourth rectangle is divided into 2 parts. The values in the stack from
the top are as follows: Lav dot; and Lav dot, Util dot Trunk, Stair,
Elev dot; and Janit dot. A text that reads, Executive Office is labeled
at the top left corner to the block that encloses the stack. A text that
reads, Secretary, slash, Receptionist is labeled at the top center to
the block that encloses the stack. A text that reads, Executive Office
is labeled at the top right corner to the block that encloses the stack.
A text that reads, Secretary, slash, Receptionist is labeled at the
right center to the block that encloses the stack. A text that reads,
Executive Office is labeled at the bottom right corner to the block
that encloses the stack. A text that reads, Secretary, slash,
Receptionist is labeled at the bottom center to the block that
encloses the stack. A text that reads, Executive Office is labeled at
the bottom left corner to the block that encloses the stack. A text
that reads, Secretary, slash, Receptionist is labeled at the left center
to the block that encloses the stack. Row 3, illustration 6. A stack of
4 rectangles is enclosed in a block which is enclosed in a block
labeled Standard Office Floor. The first, and the fourth rectangle is
divided into 2 parts. The values in the stack from the top are as
follows: Lav dot; and Lav dot, Util dot Trunk, Stair, Elev dot; and
Janit dot. The standard Office floor block is divided into 12 segments
- 2 segments on each corners of the block, 1 segment on all four
sides, without disturbing the block that enclosed the stack. The 12
segments are each labeled as Office.
Back to Figure
"Line 1: class, Expanded Entry, colon, public, Entry.
Line 2: left brace.
Line 3: public, colon.
Line 4; indented once: Expanded Entry, left parenthesis, Name, new
Name, comma, Time Of Day, new Time, right parenthesis,
semicolon.

Line 5; indented once: 2 forward slashes. Creates an Expanded
Entry object with new Name as the name.
Line 6; indented once: 2 forward slashes. Attribute and new Entry as
the Entry attribute.
Line 7; indented once: Relation Type, Compared To, left parenthesis,
Expanded Entry, other Entry, right parenthesis, semicolon.
Line 8; indented once: 2 forward slashes. Post, colon, Returns.
Line 9; indented once: 2 forward slashes. Indented 4 times:
BEFORE if instance's time object is earlier than entry's.
Line 10; indented once: 2 forward slashes. Indented 4 times: SAME
if the are identical.
Line 11; indented once: 2 forward slashes. Indented 4 times: AFTER
if instance's time object is later than entry's.
Line 12: right brace."
Back to Figure
A circular diagram labeled Entry class is enclosed in the right center
of the circular Expanded Entry class. The Entry class comprises of a
block. The list of contents in the block are as follows. Line 1: private
data, colon. Line 2: name, followed by a rectangular box. Line 3:
time, followed by a rectangular box. 9 ellipses in 2 columns are
placed on the left side of the Entry class. The ellipses are arranged
as 5 on column 1, and 4 on the column 2. The column entries are as
follows. Column 1. Get Name S t r; Get Time S t r; Expanded Entry;
Expanded Entry, left parenthesis, Default, right parenthesis; and
Compared To. Column 2. Get Name S t r; Get Time S t r; Entry; and
Entry, left parenthesis, Default, right parenthesis. An arrow from Get
Name S t r in column 2 points to Get Name S t r in column 1. An
arrow from Get Time S t r in column 2 points to Get Time S t r in
column 1.
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keywords: include, const.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE. Left parenthesis,
Expanded Entry, dot, h, right parenthesis.

Line 3: 2 forward slashes. This file gives the specification of an
Expanded Entry abstract.
Line 4: 2 forward slashes. Data type period. The Entry class is a
public base class of.
Line 5: 2 forward slashes. Expanded Entry, comma, so public
operations of Entry are also public.
Line 6: 2 forward slashes. Operations of Expanded Entry.
Line 7: 2 forward slashes followed by asterisk till the end of the line.
Line 8: Hash include, double quotes, Entry, dot, h, double quotes.
Line 9: blank line.
Line 10: class, Expanded Entry, colon, public, Entry.
Line 11: left brace.
Line 12: public, colon.
Line 13; indented once: 2 forward slashes. Constructors.
Line 14; indented once: Expanded Entry, left parenthesis, right
parenthesis, semicolon.
Line 15; indented once: 2 forward slashes. Default constructor.
Line 16; indented once: Expanded Entry, left parenthesis, Name,
new Name, comma, Time Of Day, new Time, right parenthesis,
semicolon.
Line 17; indented once: 2 forward slashes. Creates an entry object
with new Name as the name attribute and.
Line 18; indented once: 2 forward slashes. new Time as the Time Of
Day attribute.
Line 19; indented once: Relation Type, Compared To, left
parenthesis, Expanded Entry, other Entry, right parenthesis, const,
semicolon.
Line 20; indented once: 2 forward slashes. Post, colon, Returns.
Line 21; indented once: 2 forward slashes. Indented 4 times:
BEFORE if instance's time object is earlier than entry's.
Line 22; indented once: 2 forward slashes. Indented 4 times: SAME
if they are identical.
Line 23; indented once: 2 forward slashes. Indented 4 times: AFTER
if instance's time object is later than entry's.
Line 24: right brace, semicolon."
Back to Figure

"Line 1: Expanded Entry, colon, colon, Expanded Entry, left
parenthesis, Name, new Name, comma, Time Of Day, new Time,
right parenthesis, colon.
Line 2; indented once: Entry, left parenthesis, new Name, dot, Get
First Name, left parenthesis, right parenthesis, comma, new Name,
dot, Get Middle Name, left parenthesis, right parenthesis, comma.
Line 3; indented thrice: new Name, dot, Get Last Name, left
parenthesis, right parenthesis, comma, new Time, dot, Get Hours,
left parenthesis, right parenthesis, comma.
Line 4; indented thrice: new Time, dot, Get Minutes, left parenthesis,
right parenthesis, comma, new Time, dot, Get Seconds, left
parenthesis, right parenthesis, right brace.
Line 5: left brace, right brace."
Back to Figure
"Line 1: Relation Type, Expanded Entry, colon, colon, Compared To,
left parenthesis, Expanded Entry, other Entry, right parenthesis.
Line 2: left brace.
Line 3; indented once: return, left parenthesis, Get Time, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Entry, dot, Get Time, left parenthesis, right parenthesis, right
parenthesis, right parenthesis, semicolon.
Line 4: right brace."
Back to Figure
"Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE. Left parenthesis,
Entry, dot, h, right parenthesis.
Line 3: 2 forward slashes. This file contains the specification of the
Entry ADT, which has.
Line 4: 2 forward slashes. Two contained classes, Name and Time.
Line 5: 2 forward slashes. A compared To function has been added
to this class."
Back to Figure

"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include,
string, int.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: blank line.
Line 3: Hash include, double quotes, Time Of Day, dot, h, double
quotes.
Line 4: Hash include, double quotes, Name, dot, h, double quotes.
Line 5: Hash include, double quotes, Relation Type, dot, h, double
quotes.
Line 6: blank line.
Line 7: class, Entry.
Line 8: left brace.
Line 9: public, colon.
Line 10; indented once: Entry, left parenthesis, right parenthesis,
semicolon.
Line 11; indented once: 2 forward slashes. Default constructor.
Line 12; indented once: 2 forward slashes. Post, colon, Entry object
has been constructed.
Line 13; indented once: 2 forward slashes. Indented 4 times, Name
and Time Of Day objects have been constructed using.
Line 14; indented once: 2 forward slashes. Indented 4 times, their
default constructors.
Line 15; indented once: Entry, left parenthesis, string, first Name,
comma, string, middle Name, comma, string last Name, comma.
Line 16; indented 4 times: int, init Hours, comma, int, init Minutes,
comma, int, init Seconds, right parenthesis, semicolon.
Line 17; indented once: 2 forward slashes. Parameterized
constructor.
Line 18; indented once: 2 forward slashes. Post, colon, Entry object
has been constructed.
Line 19; indented once: 2 forward slashes. Indented 4 times, Name
and Time Of Day objects have been constructed using.
Line 20; indented once: 2 forward slashes. Indented 4 times, their
parameterized constructors.
Line 21; indented once: 2 forward slashes. Knowledge
responsibilities.
Line 22; indented once: Time Of Day, Get Time, left parenthesis,
right parenthesis, const, semicolon.

Line 23; indented once: 2 forward slashes. The function returns the
time attribute.
Line 24; indented once: Name, Get Name, left parenthesis, right
parenthesis, const, semicolon.
Line 25; indented once: 2 forward slashes. This function returns the
name attribute.
Line 26: private, colon.
Line 27; indented once: Name, name, semicolon.
Line 28; indented once: Time Of Day, time, semicolon.
Line 29: right brace, semicolon."
Back to Figure
Program code. The words in the keywords are merged. The
program contains the following keywords: include, string, i o stream,
using namespace.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE. Left
parenthesis, Entry. c p p, right parenthesis.
Line 3: 2 forward slashes. This file contains the specification of the
Entry A D T.
Line 4: 2 forward slashes. Which has two contained classes, Name
and Time.
Line 5: 2 forward slashes followed by asterisk till the end of the line.
Line 6: blank line.
Line 7: Hash include, double quotes, Entry, dot, h, double quotes.
Line 8: Hash include, left angled bracket, string, right angled
bracket.
Line 9: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 10: blank line.
Line 11: using, namespace, s t d, semicolon.
Line 12: blank line.
Line 13: Entry, colon, colon, Entry, left parenthesis, right
parenthesis.
Line 14: left brace, right brace.
Back to Figure

"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: return,
string, int, const.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: Entry, colon, colon, Entry, left parenthesis, string, first Name,
comma, string, middle Name, comma, string, last Name, comma.
Line 3; indented 4 times: int, init Hours, comma, int, init Minutes,
comma, int, init Seconds, right parenthesis.
Line 4; indented once: colon, name, left parenthesis, first Name,
comma, middle Name, comma, last Name, right parenthesis,
comma.
Line 5; indented twice: time, left parenthesis, init Hours, comma, init
Minutes, comma, init Seconds, right parenthesis.
Line 6: left brace, right brace.
Line 7: blank line.
Line 8: 2 forward slashes followed by asterisk till the end of the line.
Line 9: blank line.
Line 10: Time Of Day, Entry, colon, colon, Get Time, left
parenthesis, right parenthesis, const.
Line 11: left brace, return, time, semicolon, right brace.
Line 12: blank line,
Line 13: 2 forward slashes followed by asterisk till the end of the line.
Line 14: Name, Entry, colon, colon, Get Name, left parenthesis, right
parenthesis, const.
Line 15: left brace, return, name, semicolon, right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include,
string, i o stream, using namespace, return, const.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE. Left
parenthesis, Expanded Entry, dot, c p p, right parenthesis.
Line 3: 2 forward slashes. This file gives the implementation for the
Expanded Entry ADT. 
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: Hash include, double quotes, Expanded Entry, dot, h, double
quotes.

Line 6: Hash include, left angled bracket, string, right angled
bracket.
Line 7: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 8: using, namespace, s t d, semicolon.
Line 9: blank line.
Line 10: 2 forward slashes followed by asterisk till the end of the line.
Line 11: blank line.
Line 12: Expanded Entry, colon, colon, Expanded Entry, left
parenthesis, right parenthesis.
Line 13: left brace, right brace.
Line 14: blank line.
Line 15: 2 forward slashes followed by asterisk till the end of the line.
Line 16: Expanded Entry, colon, colon, Expanded Entry, left
parenthesis, Name, new Name, comma, Time Of Day, new Time,
right parenthesis, colon.
Line 17; indented once: Entry, left parenthesis, new Name, dot, Get
First Name, left parenthesis, right parenthesis, comma, new Name,
dot, Get Middle Name, left parenthesis, right parenthesis, comma.
Line 18; indented thrice: new Name, dot, Get Last Name, left
parenthesis, right parenthesis, comma, new Time, dot, Get Hours,
left parenthesis, right parenthesis, comma.
Line 19; indented thrice: new Time, dot, Get Minutes, left
parenthesis, right parenthesis, comma, new Time, dot, Get
Seconds, left parenthesis, right parenthesis, right parenthesis.
Line 19: left brace, right brace.
Line 20: blank line.
Line 21: 2 forward slashes followed by asterisk till the end of the line.
Line 22: blank line.
Line 23: Relation Type, Expanded Entry, colon, colon, Compared To,
left parenthesis, Expanded Entry, other Entry, right parenthesis,
const.
Line 24: left brace.
Line 25; indented once: return, left parenthesis, Get Time, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Entry, dot, Get Time, left parenthesis, right parenthesis, right
parenthesis, right parenthesis, semicolon.
Line 26: right brace."

Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include, i o
stream, string, using namespace, int, c out, switch, case, break, end
l.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. DRIVER for class Expanded Entry.
Line 3: 2 forward slashes. This program tests the constructors and
return functions.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: blank line.
Line 6: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 7: Hash include, double quotes, Expanded Entry, dot, h, double
quotes.
Line 8: Hash include, double quotes, Relation Type, dot, h, double
quotes.
Line 9: Hash include, left angled bracket, string, right angled
bracket.
Line 10: blank line.
Line 11: using, namespace, std, semicolon.
Line 12: blank line.
Line 13: int, main, left parenthesis, right parenthesis.
Line 14: left brace.
Line 15; indented once: Name, name 1, left parenthesis, double
quotes, Sally, double quotes, comma, double quotes, Jane, double
quotes, comma, double quotes, Smith, double quotes, right
parenthesis, semicolon.
Line 16; indented once: Time Of Day, time 1, left parenthesis, 12,
comma, 20, comma, 0, right parenthesis, semicolon.
Line 17; indented once: Name, name 2, left parenthesis, double
quotes, Mary, double quotes, comma, double quotes, Beth, double
quotes, comma, double quotes, Jones, double quotes, right
parenthesis, semicolon.
Line 18; indented once: Time Of Day, time 2, left parenthesis, 10,
comma, 30, comma, 0, right parenthesis, semicolon.
Line 19; indented once: Expanded Entry, entry 1, left parenthesis,
name 1, comma, time 1, right parenthesis, semicolon.

Line 20; indented once: Expanded Entry, entry 2, left parenthesis,
name 2, comma, time 2, right parenthesis, semicolon.
Line 21; indented once: c out, 2 left angled brackets, double quotes,
Entry 1, colon, double quotes, 2 left angled brackets, entry 1, dot,
Get Name, left parenthesis, right parenthesis, dot, Get Last Name,
left parenthesis, right parenthesis, 2 left angled brackets, end l.
Line 22; indented 4 times: 2 left angled brackets, entry 1, dot, Get
Time, left parenthesis, right parenthesis, dot, Get Hours, left
parenthesis, right parenthesis, 
Line 23; indented 4 times: 2 left angled brackets, double quotes,
colon, double quotes, 2 left angled brackets, entry 1, dot, Get Time,
left parenthesis, right parenthesis, dot, Get Minutes, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon. 
Line 24; indented once: c out, 2 left angled brackets, double quotes,
Entry 2, colon, double quotes, 2 left angled brackets, entry 2, dot,
Get Name, left parenthesis, right parenthesis, dot, Get Last Name,
left parenthesis, right parenthesis, 2 left angled brackets, end l. 
Line 25; indented 4 times: 2 left angled brackets, entry 2, dot, Get
Time, left parenthesis, right parenthesis, dot, Get Hours, left
parenthesis, right parenthesis.
Line 26; indented 4 times: 2 left angled brackets, double quotes,
colon, double quotes, 2 left angled brackets, entry 2, dot, Get Time,
left parenthesis, right parenthesis, dot, Get Minutes, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon. 
Line 27; indented once: switch, left parenthesis, entry 1, dot,
Compared To, left parenthesis, entry 2, right parenthesis, right
parenthesis.
Line 28; indented once: left brace.
Line 29; indented twice: case, BEFORE, colon, c out, 2 left angled
brackets, double quotes, entry 1 comes before entry 2, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 30: break, semicolon.
Line 31; indented twice: case, SAME, colon, c out, 2 left angled
brackets, double quotes, two entries are the same, double quotes, 2
left angled brackets, end l, semicolon, break, semicolon.
Line 32; indented twice: case, AFTER, colon, c out, 2 left angled
brackets, double quotes, entry 1 comes after entry 2, double quotes,

2 left angled brackets, end l, semicolon, break, semicolon.
Line 33; indented once: right brace.
Line 34; indented once: switch, left parenthesis, entry 2, dot,
Compared To, left parenthesis, entry 1, right parenthesis, right
parenthesis.
Line 35; indented once: left brace.
Line 36; indented twice: case, BEFORE, colon, c out, 2 left angled
brackets, double quotes, entry 2 comes before entry 1, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 37: break, semicolon.
Line 38; indented twice: case, SAME, colon, c out, 2 left angled
brackets, double quotes, two entries are the same, double quotes, 2
left angled brackets, end l, semicolon, break, semicolon.
Line 39; indented twice: case, AFTER, colon, c out, 2 left angled
brackets, double quotes, entry 2 comes after entry 1, double quotes,
2 left angled brackets, end l, semicolon, break, semicolon.
Line 40; indented once: right brace.
Line 41; indented once: switch, left parenthesis, entry 1, dot,
Compared To, left parenthesis, entry 1, right parenthesis, right
parenthesis.
Line 42; indented once: left brace.
Line 43; indented twice: case, BEFORE, colon, c out, 2 left angled
brackets, double quotes, entry 1 comes before entry 2, double
quotes, 2 left angled brackets, end l, semicolon, break, semicolon."
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keywords: case, return, end l, break.
Line 1: indented twice: case, SAME, colon, c out, 2 left angled
brackets, double quotes, two entries are the same, double quotes, 2
left angled brackets, end l, semicolon, break, semicolon.
Line 2; indented twice: case, AFTER, colon, c out, 2 left angled
brackets, double quotes, entry 1 comes after entry 2, double quotes,
2 left angled brackets, end l, semicolon, break, semicolon.
Line 3; indented once: right brace.
Line 4; indented once: return, 0, semicolon.
Line 5: right brace."

Back to Figure
Line 1: Entry 1, colon, Smith. Line 2: 12, colon, 20. Line 3: Entry 2,
colon, Jones. Line 4: 10, colon, 30. Line 5: entry 1 comes after entry
2. Line 6: entry 2 comes before entry 1. Line 7: two entries are the
same.
Back to Figure
"Line 1: 2 forward slashes. Constructors.
Line 2: Time Of Day, left parenthesis, right parenthesis, semicolon.
Line 3: 2 forward slashes. Post, colon, hours, comma, minutes,
comma, and seconds have been set to 0.
Line 4: Time Of Day, left parenthesis, int, init Hours, comma, int, init
Minutes, comma, int, init Seconds, right parenthesis, semicolon.
Line 5: 2 forward slashes. Pre, colon, 0, left angled bracket, equals,
hours, left angled bracket, equals, 23, comma, 0, left angled
bracket, equals, minutes, left angled bracket, equals, 59, comma, 0,
left angled bracket, equals, seconds, left angled bracket, equals, 59.
Line 6: 2 forward slashes. Post, colon, Time is set according to the
incoming parameters.
Line 7: blank line.
Line 8: 2 forward slashes. Knowledge responsibilities.
Line 9: Time Of Day, Increment, left parenthesis, right parenthesis,
const, semicolon.
Line 10: 2 forward slashes. Post, colon, Returns a time that is the
instance plus one, comma.
Line 11: 2 forward slashes. Indented 5 times. With 23, colon, 59,
colon, 59 wrapping around to 0, colon, 0, colon, 0.
Line 12: int, Get Hours, left parenthesis, right parenthesis, const,
semicolon.
Line 13: 2 forward slashes. Returns hours.
Line 14: int, Get Minutes, left parenthesis, right parenthesis, const,
semicolon.
Line 15: 2 forward slashes. Returns minutes.
Line 16: int, Get Seconds, left parenthesis, right parenthesis, const,
semicolon.
Line 17: 2 forward slashes. Returns seconds. 
Line 18: Relation Type, Compared To, left parenthesis, Time Of Day,

other Day, right parenthesis, const, semicolon.
Line 19: 2 forward slashes. Post, colon, Returns BEFORE if instance
comes before other Day, semicolon.
Line 20: 2 forward slashes. Returns SAME if instance and other Day
are the same, semicolon.
Line 21: 2 forward slashes. Returns AFTER if instance comes after
other Day."
Back to Figure
"Line 1: enum, Zone Type, left brace, P S T, comma, M S T, comma,
C S T, comma, E S T, right brace, semicolon.
Line 2: blank line.
Line 3: class, E x t Time, colon, public, Time Of Day.
Line 4: left brace.
Line 5: public, colon.
Line 6; indented once: 2 forward slashes. Constructors.
Line 7; indented once: E x t Time, left parenthesis, int, new Hours,
comma, int, new Minutes, comma, int, new Seconds, comma. 
Line 8; indented 5 times: Zone Type, new Zone, right parenthesis,
semicolon. 
Line 9; indented once: E x t Time, left parenthesis, right parenthesis,
semicolon. 2 forward slashes. Setting time to 0, colon, 0 colon, 0 E
S T.
Line 10: blank line.
Line 11; indented once: 2 forward slashes. Knowledge
responsibilities.
Line 12; indented once: Zone Type, Get Zone, left parenthesis, right
parenthesis, const, semicolon.
Line 13; indented once: 2 forward slashes. Returns the time zone.
Line 14; indented once: Relation Type, Compared To, left
parenthesis, E x t Time, other Time, right parenthesis, const,
semicolon.
Line 15; indented once: 2 forward slashes. Post, colon, Returns.
Line 16; indented once: 2 forward slashes. Indented 6 times:
BEFORE if instance is earlier than other Time, semicolon. 
Line 17; indented once: 2 forward slashes. Indented 6 times: SAME
if they are identical, semicolon.
Line 18; indented once: 2 forward slashes. Indented 6 times: AFTER

if instance is later than other Time.
Line 19: private, colon.
Line 20; indented once: Zone Type, zone, semicolon.
Line 21: right brace, semicolon."
Back to Figure
A circular diagram labeled Time Of Day class is enclosed in the right
center of the circular E x t Time class. The Time Of Day class
comprises of a block. The list of contents in the block are as follows.
Line 1: Private data, colon. Line 2: hours, followed by a rectangular
box. Line 3: minutes, followed by a rectangular box. Line 4: seconds,
followed by a rectangular box. 15 ellipses in 2 columns are placed on
the left side of the Entry class. The ellipses are arranged as 8 on
column 1, and 7 on the column 2. The column entries are as follows.
Column 1. Increment; Get Hours; Get Minutes; Get Seconds;
Compared To; E x t Time, left parenthesis, First constructor, right
parenthesis; E x t Time, left parenthesis, Default constructor, right
parenthesis; and Get Zone. Column 2. Increment; Get Hours; Get
Minutes; Get Seconds; Compared To; Time Of Day, left parenthesis,
First constructor, right parenthesis; and Time Of Day, left
parenthesis, Default constructor, right parenthesis. An arrow from
Increment in column 2 points to Increment in column 1. An arrow
from Get Hours in column 2 points to Get Hours in column 1. An
arrow from Get Minutes in column 2 points to Get Minutes in column
1. An arrow from Get Seconds in column 2 points to Get Seconds in
column 1. An arrow from Compared To in column 2 points to
Compared To in column 1. A block is placed on the bottom left
corner of E x t Time class. The contents of the block are as follows.
Line 1: Private Data, colon. Line 2: zone, followed by a rectangular
box.
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keywords: include, i o stream, using
namespace, int, const, return.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for E x t Time,

comma, a derived.
Line 3: 2 forward slashes. Class from Time Of Day with a time zone.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: Hash include, double quotes, E x t Time, dot, h, double
quotes.
Line 6: Hash include, double quotes, Relation Type, dot, h, double
quotes.
Line 7: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 8: using, namespace, s t d, semicolon.
Line 9: blank line.
Line 10: E x t Time, colon, colon, E x t Time, left parenthesis, int,
new Hours, comma, int, new Minutes, comma, int, new Seconds,
comma.
Line 11; indented once: Zone Type, new Zone, right parenthesis.
Line 12; indented once: colon, Time Of Day, left parenthesis, new
Hours, comma, new Minutes, comma, new Seconds, right
parenthesis.
Line 13: left brace, zone, equals, new Zone, semicolon, right brace.
Line 14: blank line.
Line 15: 2 forward slashes followed by asterisk till the end of the line.
Line 16: E x t Time, colon, colon, E x t Time, left parenthesis, right
parenthesis.
Line 17: left brace, zone, equals, P S T, semicolon, right brace.
Line 18: blank line.
Line 19: 2 forward slashes followed by asterisk till the end of the line.
Line 20: Zone Type, E x t Time, colon, colon, Get Zone, left
parenthesis, right parenthesis, const.
Line 21: left brace, return, zone, semicolon, right brace.
Line 22: blank line.
Line 23: 2 forward slashes followed by asterisk till the end of the line.
Line 24: Relation Type, E x t Time, colon, colon, Compared To, left
parenthesis, E x t Time, other Time, right parenthesis, const.
Line 25: left brace.
Line 26; indented once: 2 forward slashes. A copy of the instance is
converted to the same.
Line 27; indented once: 2 forward slashes. Zone as other Time,
semicolon, Time Of Day's Compared To is.
Line 28; indented once: 2 forward slashes. Then used to compare

the copy and the parameter.
Line 29: blank line.
Line 30; indented once: int, difference, equals, int, left parenthesis,
other Time, dot, zone, right parenthesis, minus, int, left parenthesis,
zone, right parenthesis, semicolon.
Line 31; indented once: int, new Hours, equals, left parenthesis, Get
Hours, left parenthesis, right parenthesis, plus, difference, right
parenthesis, percentage, 24, semicolon.
Line 32; indented once: Time Of Day, copy, left parenthesis, new
Hours, comma, Get Minutes, left parenthesis, right parenthesis,
comma, Get Seconds, left parenthesis, right parenthesis, right
parenthesis, semicolon.
Line 33; indented once: return, copy, dot, Compared To, left
parenthesis, other Time, right parenthesis, semicolon.
Line 34: right brace."
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keywords: include, i o stream.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. Test driver for class E x t Time that
inherits from Time Of Day.
Line 3: 2 forward slashes followed by asterisk till the end of the line.
Line 4: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 5: Hash include, double quotes, E x t Time, dot, h, double
quotes. 2 forward slashes. For E x t Time class.
Line 6: Hash include, double quotes, Relation Type, dot, h, double
quotes."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: using
namespace, int, string, switch, case, void, end l, break.
Line 1: using, namespace, s t d, semicolon.
Line 2: string, T Z String, left parenthesis, E x t Time, time, right
parenthesis, semicolon.

Line 3: 2 forward slashes. Returns a string representing the time
zone.
Line 4: void, Compare, left parenthesis, E x t Time, time 1, comma,
E x t Time, time 2, right parenthesis, semicolon.
Line 5: 2 forward slashes. Prints the result of comparison of time 1
and time 2.
Line 6: blank line.
Line 7: int, main, left parenthesis, right parenthesis.
Line 8: left brace.
Line 9; indented once: E x t Time, time 1, left parenthesis, 5,
comma, 30, comma, 0, E S T, right parenthesis, semicolon. 2
forward slashes. Parameterized constructor used.
Line 10; indented once: E x t Time, time 2, semicolon. 2 forward
slashes. Create a time of 0, colon, 00, colon, 00 P S T.
Line 11: blank line.
Line 12; indented once: Compare, left parenthesis, time 1, comma,
time 2, right bracket, semicolon.
Line 13; indented once: time 2, equals, time 1, semicolon.
Line 14; indented once: Compare, left parenthesis, time 1, comma,
time 2, right bracket, semicolon. 
Line 15; indented once: E x t Time, time 3, left parenthesis, 5,
comma, 15, comma, 0, comma, C S T, right parenthesis, semicolon.
Line 16; indented once: Compare, left parenthesis, time 1, comma,
time 3, right bracket, semicolon.
Line 17; indented once: Compare, left parenthesis, time 3, comma,
time 1, right bracket, semicolon.
Line 18; indented once: E x t Time, time 4, left parenthesis, 3,
comma, 5, comma, 0, comma, M S T, right parenthesis, semicolon.
Line 19; indented once: Compare, left parenthesis, time 1, comma,
time 4, right bracket, semicolon.
Line 20; indented once: Compare, left parenthesis, time 4, comma,
time 1, right bracket, semicolon.
Line 21; indented once: E x t Time, time 5, left parenthesis, 3,
comma, 30, comma, 0, comma, P S T, right parenthesis, semicolon.
Line 22; indented once: Compare, left parenthesis, time 1, comma,
time 5, right bracket, semicolon.
Line 23; indented once: Compare, left parenthesis, time 5, comma,
time 1, right bracket, semicolon.
Line 24: right brace.

Line 25: blank line.
Line 26: string, T Z String, left parenthesis, E x t Time, time, right
parenthesis.
Line 27: left brace.
Line 28: blank line.
Line 29; indented once: switch, left parenthesis, time, dot, Get Zone,
left parenthesis, right parenthesis, right parenthesis. 
Line 30; indented once: left brace.
Line 31; indented twice: case, P S T, colon, return, double quotes, P
S T, double quotes, semicolon.
Line 32; indented twice: case, M S T, colon, return, double quotes,
M S T, double quotes, semicolon.
Line 33; indented twice: case, C S T, colon, return, double quotes, C
S T, double quotes, semicolon.
Line 34; indented twice: case, E S T, colon, return, double quotes, E
S T, double quotes, semicolon.
Line 35; indented once: right brace.
Line 36: right brace.
Line 37: blank line.
Line 38: void, Compare, left parenthesis, E x t Time, time 1, comma,
E x t Time, time 2, right parenthesis.
Line 39: left brace.
Line 40; indented once: c out, 2 left angled brackets, double quotes,
Time 1, colon, double quotes, 2 left angled brackets, time 1, dot,
Get Hours, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, colon, double quotes.
Line 41; indented 4 times: 2 left angled brackets, time 1, dot, Get
Minutes, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, space, double quotes, 2 left angled brackets, T Z
String, left parenthesis, time 1, right parenthesis, 2 left angled
brackets, end l, semicolon.
Line 42; indented once: c out, 2 left angled brackets, double quotes,
Time 2, colon, double quotes, 2 left angled brackets, time 2, dot,
Get Hours, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, colon, double quotes.
Line 43; indented 4 times: 2 left angled brackets, time 2, dot, Get
Minutes, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, space, double quotes, 2 left angled brackets, T Z
String, left parenthesis, time 2, right parenthesis, 2 left angled

brackets, end l, semicolon.
Line 44; indented once: switch, left parenthesis, time 1, dot, E x t
Time, colon, colon, Compared To, left parenthesis, time 2, right
parenthesis, right parenthesis.
Line 45; indented once: left brace.
Line 46; indented twice: case, BEFORE, colon, c out, 2 left angled
brackets, double quotes, Time 1 comes before time 2, double
quotes. 
Line 47; indented 11 times: 2 left angled brackets, end l, semicolon,
break, semicolon.
Line 48; indented twice: case, SAME, colon, c out, 2 left angled
brackets, double quotes, Time 1 is same as time 2, double quotes. 
Line 49; indented 11 times: 2 left angled brackets, end l, semicolon,
break, semicolon.
Line 50; indented twice: case, AFTER, colon, c out, 2 left angled
brackets, double quotes, Time 1 comes after time 2, double quotes. 
Line 51; indented 11 times: 2 left angled brackets, end l, semicolon,
break, semicolon.
Line 52; indented once: right brace.
Line 53: right brace."
Back to Figure
"Line 1: Time 1, colon, 5, colon, 30, E S T.
Line 2: Time 2, colon, 0, colon, 0, P S T.
Line 3: Time 1 comes after time 2.
Line 4: Time 1, colon, 5, colon, 30, E S T.
Line 5: Time 2, colon, 5, colon, 30, E S T.
Line 6: Time 1 is same as time 2.
Line 7: Time 1, colon, 5, colon, 30, E S T.
Line 8: Time 2, colon, 5, colon, 15, C S T.
Line 9: Time 1 comes after time 2.
Line 10: Time 1, colon, 5, colon, 15, C S T.
Line 11: Time 2, colon, 5, colon, 30, E S T.
Line 12: Time 1 comes before time 2.
Line 13: Time 1, colon, 5, colon, 30, E S T.
Line 14: Time 2, colon, 3, colon, 5, M S T.
Line 15: Time 1 comes after time 2.
Line 16: Time 1, colon, 3, colon 5, M S T.

Line 17: Time 2, colon, 5, colon, 30, E S T.
Line 18: Time 1 comes before time 2.
Line 19: Time 1, colon, 5, colon, 30, E S T.
Line 20: Time 2, colon, 5, colon, 30, P S T.
Line 21: Time 1 comes after time 2.
Line 22: Time 1, colon, 3, colon, 30, P S T.
Line 23: Time 2, colon, 5, colon, 30, E S T.
Line 24: Time 1 comes before time 2."
Back to Figure
"Line 1: Time Of Day, time 1, left parenthesis, 8, comma, 30,
comma, 30, right parenthesis, semicolon.
Line 2: Time Of Day, time 2, semicolon.
Line 3: blank line.
Line 4: E x t Time, time 3, left parenthesis, 10, comma, 45, comma,
0, comma, C S T, right parenthesis, semicolon.
Line 5: E x t Time, time 4, semicolon.
Line 6: blank line.
Line 7: Relation Type, result 1, equals, time 1, dot, Compared To,
left parenthesis, time 2, right parenthesis, semicolon.
Line 8: Relation Type, result 2, equals, time 3, dot, Compared To,
left parenthesis, time 4, right parenthesis, semicolon."
Back to Figure
"Line 1: void, Print, left parenthesis, Time of Day, time, right
parenthesis.
Line 2: left brace.
Line 3; indented once: c out, 2 left angled brackets, double quotes
followed by 25 asterisks, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 4; indented once: c out, 2 left angled brackets, double quotes, 2
asterisks, The time is, double quotes, semicolon.
Line 5; indented once: time, dot, write, left parenthesis, right
parenthesis, semicolon."
Back to Figure

"Line 1; indented once: c out, 2 left angled brackets, end l,
semicolon.
Line 2; indented once: c out, 2 left angled brackets, double quotes
followed by 25 asterisks, double quotes, 2 left angled brackets, end
l, semicolon.
Line 3: right brace."
Back to Figure
"Line 1: Time Of Day, start Time, left parenthesis, 8, comma, 30,
comma, 0, right parenthesis, semicolon.
Line 2: E x t Time, end Time, left parenthesis, 10, comma, 4,
comma, 0, comma, C S T, right parenthesis, semicolon.
Line 3: blank line.
Line 4: Print, left parenthesis, start Time, right parenthesis,
semicolon.
Line 5: Print, left parenthesis, end Time, right parenthesis,
semicolon."
Back to Figure
2 circles arranged one below the other. Circle 1. A block is enclosed
in a circle which is enclosed in the circle labeled as Argument of
Type E x t Time. The list of contents in the block are as follows. Line
1: Private Data, colon. Line 2: hours, followed by a rectangular box.
Line 3: minutes, followed by a rectangular box. Line 4: seconds,
followed by a rectangular box. Another block is placed on the bottom
left corner of the Argument of Type E x t Time circle. The list of
contents in the block are as follows. Line 1: Private Data, colon. Line
2: zone, followed by a rectangular box. Circle 2. A block is enclosed
in the circle labeled as Parameter of Type Time. The list of contents
in the block are as follows. Line 1: Private Data, colon. Line 2: hours,
followed by a rectangular box. Line 3: minutes, followed by a
rectangular box. Line 4: seconds, followed by a rectangular box. An
arrow from the circle that encloses private data block in circle 1
points to circle 2. The text near the arrow reads, A copy of the base
class sub object is passed. The zone variable is double quotes,
sliced off, double quotes.

Back to Figure
"Line 1: class, Time Of Day.
Line 2: left brace.
Line 3: public, colon.
Line 4; indented once: Three vertical dots.
Line 5; indented once: virtual, void, Write, left parenthesis, right
parenthesis, const, semicolon.
Line 6; indented once: Three vertical dots.
Line 7; indented once: private, colon.
Line 8; indented once: Three vertical dots.
Line 9: right brace, semicolon."
Back to Figure
"Line 1: void, Print, left parenthesis, Time Of Day ampersand, time,
right parenthesis.
Line 2: left brace.
Line 3; indented once: Three vertical dots.
Line 4; indented once: time, dot, Write, left parenthesis, right
parenthesis, semicolon.
Line 5: right brace."
Back to Figure
Row 1 has three columns with entries, Class Name, colon;
Superclass, colon; and Subclasses, colon respectively. From row 2
to 10, the table has 2 columns. The row 2 entries are
Responsibilities, and Collaborations respectively.
Back to Figure
The 2 illustrations are each divided into 2 parts. Illustration 1. An
illustration of a control tower and an airplane is displayed. Illustration
2. Illustrations of a controller working from a control tower and a pilot
operating from an airplane.
Back to Figure

Row 1 has three columns with entries Class Name, colon, Entry
With Date; Superclass, colon, Entry; and Subclasses, colon, None
respectively. From row 2 to 10, the table has 2 columns. The row
entries are as follows. Row 2: Responsibilities; Collaborations. Row
3: Create, Entry With Date, left parenthesis, Name, Time, Date, right
parenthesis; Name, Time Of Day, Date. Row 4: Get, Date, returns,
Date; Date. Row 5: Relation Type, Compared To, left parenthesis,
Entry With Date, right parenthesis; Date. The entries from row 6 to
10 are blank.
Back to Figure
Row 1 has three columns with entries Class Name, colon,
Appointment Calendar; Superclass, colon; and Subclasses, colon
respectively. From row 2 to 10, the table has 2 columns. The row
entries are as follows. Row 2: Responsibilities; Collaborations. Row
3: Create, Appointment Calendar, left parenthesis, File Name, right
parenthesis; i f stream. Row 4: Get, Entry By, left parenthesis,
Name, Date, right parenthesis, returns, Entry; Name, comma, Date.
Row 5: Insert, Entry, left parenthesis, Entry, right parenthesis; List.
Row 6: Write List To File, left parenthesis, File Name, right
parenthesis; o f stream. The entries from row 7 to 10 are blank.
Back to Figure
Row 1 has three columns with entries Class Name, colon, Date;
Superclass, colon; and Subclasses, colon respectively. From row 2
to 10, the table has 2 columns. The row entries are as follows. Row
2: Responsibilities; Collaborations. Row 3: Create, Date, left
parenthesis, Month, comma, Day, comma, Year, right parenthesis;
blank. Row 4: Get, Month, returning, Month; blank. Row 5: Get, Day,
returning, Day; blank. Row 6: Get, Year, returning, Year; blank. Row
7: Compared To, left parenthesis, Date, right parenthesis, returns,
Relation Type; blank. The entries from row 8 to 10 are blank.
Back to Figure
Line 1: int, Get Month, left parenthesis, right parenthesis, semicolon.
Line 2: int, Get Day, left parenthesis, right parenthesis, semicolon.

Line 3: int, Get Year, left parenthesis, right parenthesis, semicolon.
Back to Figure
"Line 1: Date, date 1, semicolon.
Line 2: Date, date 2, semicolon.
Line 3: dot.
Line 4: dot.
Line 5: dot.
Line 6: if, left parenthesis, date 1, dot, Compared To, left
parenthesis, date 2, right parenthesis, equals, equals, BEFORE,
right parenthesis.
Line 7; indented once: Do Something, left parenthesis, right
parenthesis, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include, int,
const.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: SPECIFICATION FILE for a Date A D T.
Line 3: 2 forward slashes followed by asterisk till the end of the line.
Line 4: blank line.
Line 5: Hash include, double quotes, Relation Type, dot, h, double
quotes.
Line 6: class, Date.
Line 7: left brace.
Line 8: public, colon.
Line 9; indented once: Date, left parenthesis, right parenthesis,
semicolon.
Line 10; indented once: Date, left parenthesis, int, init Month,
comma, int, init Day, comma, int, init Year, right parenthesis,
semicolon.
Line 11: 2 forward slashes. Knowledge responsibilities.
Line 12; indented once: int, Get Month, left parenthesis, right
parenthesis, const, semicolon.
Line 13; indented once: int, Get Day, left parenthesis, right
parenthesis, const, semicolon.

Line 14; indented once: int, Get Year, left parenthesis, right
parenthesis, const, semicolon.
Line 15; indented once: Relation Type, Compared To, left
parenthesis, Date, other Date, right parenthesis, const, semicolon.
Line 16; indented once: 2 forward slashes. Post, colon, Returns
BEFORE if instance comes before other Entry, semicolon.
Line 17; indented once: 2 forward slashes. Indented 5 times:
Returns SAME if instance and other Entry are the same, semicolon.
Line 18; indented once: 2 forward slashes. Indented 5 times:
Returns AFTER if instance comes after other Entry."
Back to Figure
"Program code. The program contains the following keyword: int.
Line 1: private, colon.
Line 2; indented once: int, month, semicolon.
Line 3; indented once: int, day, semicolon.
Line 4; indented once: int, year, semicolon.
Line 5: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include, int,
const, I o stream, using namespace, return.
Line 1: 2 forward slashes followed by asterisk till the end of the line. 
Line 2: 2 forward slashes. IMPLEMENTATION FILE for a Date A D
T.
Line 3: 2 forward slashes. Month, comma, day, comma, and year
are kept as integers.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 6: Hash include, double quotes, Dates, dot, h, double quotes.
Line 7: Hash include, double quotes, Relation Type, dot, h, double
quotes.
Line 8: using, namespace, s t d, semicolon.
Line 9: blank line.
Line 10: Date, colon, colon, Date, left parenthesis, right parenthesis.

Line 11: left brace.
Line 12; indented once: month, equals, 1, semicolon.
Line 13; indented once: day, equals, 1, semicolon.
Line 14; indented once: year, equals, 1582, semicolon.
Line 15: right brace.
Line 16: blank line.
Line 17: 2 forward slashes followed by asterisk till the end of the line.
Line 18: Date, colon, colon, Date, left parenthesis, int, init Month,
comma, int, init Day, comma, int, init Year, right parenthesis.
Line 19: left brace.
Line 20; indented once: month, equals, init Month, semicolon.
Line 21; indented once: day, equals, init Dat, semicolon.
Line 22; indented once: year, equals, init Year, semicolon.
Line 23: right brace.
Line 24: blank line.
Line 25: 2 forward slashes followed by asterisk till the end of the line.
Line 26: int, Date, colon, colon, Get Month, left parenthesis, right
parenthesis, const.
Line 27: left brace, return, month, semicolon, right brace.
Line 28: blank line.
Line 29: 2 forward slashes followed by asterisk till the end of the line.
Line 30: int, Date, colon, colon, Get Day, left parenthesis, right
parenthesis, const.
Line 31: left brace, return, day, semicolon, right brace.
Line 32: blank line.
Line 33: 2 forward slashes followed by asterisk till the end of the line.
Line 34: int, Date, colon, colon, Get Year, left parenthesis, right
parenthesis, const.
Line 35: left brace, return, year, semicolon, right brace.
Line 36: blank line.
Line 37: 2 forward slashes followed by asterisk till the end of the line.
Line 38: Relation Type, Date, colon, colon, Compared To, left
parenthesis, Date, other Date, right parenthesis, const."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: if, else, else
if, return.

Line 1: left brace.
Line 2; indented once: if, left parenthesis, year, left angled bracket,
other Date, dot, year, right parenthesis.
Line 3; indented twice: return, BEFORE, semicolon.
Line 4; indented once: else if, left parenthesis, year, right angled
bracket, other Date, dot, year, right parenthesis.
Line 5; indented twice: return, AFTER, semicolon.
Line 6; indented once: else if, left parenthesis, month, left angled
bracket, other Date, dot, month, right parenthesis.
Line 7; indented twice: return, BEFORE, semicolon.
Line 8; indented once: else if, left parenthesis, month, right angled
bracket, other Date, dot, month, right parenthesis.
Line 9; indented twice: return, AFTER, semicolon.
Line 10; indented once: else if, left parenthesis, day, left angled
bracket, other Date, dot, day, right parenthesis.
Line 11; indented twice: return, BEFORE, semicolon.
Line 12; indented once: else if, left parenthesis, day, right angled
bracket, other Date, dot, day, right parenthesis.
Line 13; indented twice: return, AFTER, semicolon.
Line 14; indented once: else, return, SAME, semicolon.
Line 15: right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include,
const.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: SPECIFICATION FILE for class Entry With Date.
Line 3: This class inherits from Entry.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: blank line.
Line 6: Hash include, double quotes, Date, dot, h, double quotes.
Line 7: Hash include, double quotes, Entry, dot, h, double quotes.
Line 8: blank line.
Line 9: class, Entry With Date, colon, public, Entry.
Line 10: left brace.
Line 11: public, colon.
Line 12; indented once: 2 forward slashes. Constructors.

Line 13; indented once: Entry With Date, left parenthesis, right
parenthesis, semicolon.
Line 14; indented once: Entry With Date, left parenthesis, Date, init
Date, comma, Time Of Day, init Time, comma, Name, init Name,
right parenthesis, semicolon.
Line 15; indented once: 2 forward slashes. Knowledge responsibility.
Line 16; indented once: Date, Get Date, left parenthesis, right
parenthesis, const, semicolon.
Line 17; indented once: Relation Type, Compared To, left
parenthesis, Entry With Date, other Entry, right parenthesis, const,
semicolon.
Line 18; indented once: 2 forward slashes. Post, colon, Returns
BEFORE is instance comes before other Entry, semicolon.
Line 19; indented once: 2 forward slashes. Indented 5 times:
Returns SAME if instance and other Entry are the same, semicolon.
Line 20; indented once: 2 forward slashes. Indented 5 times:
Returns AFTER if instance comes after other Entry.
Line 21: private, colon.
Line 22; indented once: Date, date, semicolon.
Line 23: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include,
return, const, if, else if, else.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class Entry
With Date.
Line 3: 2 forward slashes followed by asterisk till the end of the line.
Line 4: blank line.
Line 5: Hash include, double quotes, Entry With Date, dot, h, double
quotes.
Line 6: blank line.
Line 7: Entry With Date, colon, colon, Entry With Date, left
parenthesis, right parenthesis.
Line 8: left brace, right brace, semicolon.
Line 9: blank line.
Line 10: 2 forward slashes followed by asterisk till the end of the line.

Line 11: blank line.
Line 12: Entry With Date, colon, colon, Entry With Date, left
parenthesis, Date, init Date, comma.
Line 13; indented once: Time Of Day, init Time, comma, Name, init
Name, right parenthesis, colon.
Line 14; indented once: Entry, left parenthesis, init Name, dot, Get
First Name, left parenthesis, right parenthesis, comma, init Name,
dot, Get Middle Name, left parenthesis, right parenthesis, comma.
Line 15; indented twice: init Name, dot, Get Last Name, left
parenthesis, right parenthesis, comma, init Time, dot, Get Hours,
left parenthesis, right parenthesis, comma.
Line 16: indented twice: init Time, dot, Get Minutes, left parenthesis,
right parenthesis, comma, init Time, dot, Get Seconds, left
parenthesis, right parenthesis, right parenthesis.
Line 17: left brace.
Line 18; indented once: date, equals, init Date, semicolon.
Line 19: right brace.
Line 20: blank line.
Line 21: 2 forward slashes followed by asterisk till the end of the line.
Line 22: Date, Entry With Date, colon, colon, Get Date, left
parenthesis, right parenthesis, const.
Line 23: left brace, return, date, semicolon, right brace.
Line 24: blank line.
Line 25: 2 forward slashes followed by asterisk till the end of the line.
Line 26: Relation type, Entry With Date, colon, colon, Compared To,
left parenthesis, Entry With Date, other Date, right parenthesis.
Line 27: const.
Line 28: left brace.
Line 29; indented once: if, left parenthesis, Get Date, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Date, dot, Get Date, left parenthesis, right parenthesis, right
parenthesis, equals, equals, SAME.
Line 30; indented twice: ampersand, ampersand, Get Name, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Date, dot, Get Name, left parenthesis, right parenthesis, right
parenthesis, equals, equals, SAME, right parenthesis.
Line 31; indented twice: return, SAME, semicolon.
Line 32; indented once: else if, left parenthesis, Get Date, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,

other Date, dot, Get Date, left parenthesis, right parenthesis, right
parenthesis, equals, equals, BEFORE, right parenthesis.
Line 33; indented twice: return, BEFORE, semicolon.
Line 34; indented once: else, return, AFTER, semicolon.
Line 35: right brace."
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keyword: include.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE for class
Appointment Calendar.
Line 3: 2 forward slashes followed by asterisk till the end of the line.
Line 4: blank line.
Line 5: Hash include, double quotes, Entry With Date, dot, h, double
quotes.
Line 6: Hash include, double quotes, List, dot, h, double quotes."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include, f
stream, i f stream, o f stream, using namespace, bool, void.
Line 1: Hash include, left angled bracket, f stream, right angled
bracket.
Line 2: using, namespace, s t d, semicolon.
Line 3: blank line.
Line 4: class, Appointment Calendar.
Line 5: left brace.
Line 6: public, colon.
Line 7; indented once: 2 forward slashes. Constructor.
Line 8; indented once: Appointment Calendar, left parenthesis, i f
stream, ampersand, in File, right parenthesis, semicolon.
Line 9; indented once: 2 forward slashes. Knowledge responsibility.
Line 10; indented once: Entry With Date, Get Entry, left parenthesis,
Name, name, comma, Date, date, right parenthesis, semicolon.
Line 11; indented once: Returns entry with time field equal to time.
Line 12; indented once: Pre, colon, entry with time field equal to time

exists.
Line 13; indented once: bool, Is There, left parenthesis, Name,
name, comma, Date, date, right parenthesis, semicolon.
Line 14; indented once: 2 forward slashes. Post, colon, Returns true
if an entry is in the list and false otherwise.
Line 15; indented once: blank line.
Line 16; indented once: 2 forward slashes. Action responsibilities.
Line 17; indented once: void, Insert Entry, left parenthesis, Entry
With Date, init Entry, right parenthesis, semicolon.
Line 18; indented once: 2 forward slashes. Inserts entry into list.
Line 19; indented once: void, Write List To File, left parenthesis, o f
stream, ampersand, out File, right parenthesis, semicolon.
Line 20; indented once: 2 forward slashes. Writes list to out File.
Line 21: blank line.
Line 22: private, colon.
Line 23; indented once: List, list, semicolon.
Line 24: right brace, semicolon."
Back to Figure
"Program code. The words in the keywords are merged. The
program contains the following keyword: include, using namespace,
string, f stream, i o stream.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for Appointment
Calendar.
Line 3: 2 forward slashes followed by asterisk till the end of the line.
Line 4: blank line.
Line 5: Hash include, double quotes, Appointment Calendar, dot, h,
double quotes.
Line 6: Hash include, left angled bracket, string, right angled
bracket.
Line 7: Hash include, left angled bracket, f stream, right angled
bracket.
Line 8: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 9: using, namespace, s t d, semicolon."
Back to Figure

"Program code. The words in the variable names and keywords are
merged. The program contains the following keyword: int, string, for,
i f stream, bool, void, return, while, o f stream.
Line 1: Appointment Calendar, colon, colon, Appointment Calendar,
left parenthesis, i f stream, ampersand, in File, right parenthesis.
Line 2: left brace.
Line 3; indented once: int, hours, comma, minutes, comma,
seconds, semicolon. 2 forward slashes. For class Time Of Day. 
Line 4; indented once: int, month, comma, day, comma, year,
semicolon. 2 forward slashes. For class Date.
Line 5; indented once: string, first, comma, middle, comma, last,
semicolon. 2 forward slashes. For class Name.
Line 6; indented once: int, number Entries, semicolon.
Line 7; indented once: in File, 2 right angled brackets, number
Entries, semicolon.
Line 8; indented once: for, left parenthesis, int, counter, equals,
semicolon, counter, left angled bracket, number Entries, semicolon,
counter, plus, plus, right parenthesis.
Line 9; indented once: left brace.
Line 10; indented twice: in File, 2 right angled brackets, hours, 2
right angled brackets, minutes, 2 right angled brackets, seconds,
semicolon.
Line 11; indented twice: Time Of Day, time, left parenthesis, hours,
comma, minutes, comma, seconds, right parenthesis, semicolon.
Line 12; indented twice: in File, 2 right angled brackets, month, 2
right angled brackets, day, 2 right angled brackets, year, semicolon.
Line 13; indented twice: Date, date, left parenthesis, month, comma,
day, comma, year, right parenthesis, semicolon.
Line 14; indented twice: in File, 2 right angled brackets, first, 2 right
angled brackets, middle, 2 right angled brackets, last, semicolon.
Line 15; indented twice: Name, name, left parenthesis, first, comma,
middle, comma, last, right parenthesis, semicolon.
Line 16; indented twice: Entry With Date, entry, left parenthesis,
date, comma, time, comma, name, right parenthesis, semicolon.
Line 17; indented twice: list, dot, Insert, left parenthesis, entry, right
parenthesis, semicolon.
Line 18; indented once: right brace.
Line 19: right brace.
Line 20: blank line.

Line 21: 2 forward slashes followed by asterisk till the end of the line.
Line 22: bool, Appointment Calendar, colon, colon, Is There, left
parenthesis, Name, name, comma, Date, date, right parenthesis.
Line 23: left brace.
Line 24; indented once: Time Of Day, time, semicolon.
Line 25; indented once: Entry With Date, entry, left parenthesis,
date, comma, time, comma, name, right parenthesis, semicolon.
Line 26; indented once: return, dot, Is There, left parenthesis, entry,
right parenthesis, semicolon.
Line 27: right brace.
Line 28: blank line.
Line 29: 2 forward slashes followed by asterisk till the end of the line.
Line 30: blank line.
Line 31: Entry With Date, Appointment Calendar, colon, colon, Get
Entry, left parenthesis, Name, name, comma, Date, date, right
parenthesis.
Line 32: left brace.
Line 33; indented once: Time Of Day, time, semicolon.
Line 34; indented once: Entry With Date, other Entry, left
parenthesis, date, comma, time, comma, name, right parenthesis,
semicolon.
Line 35; indented once: Entry With Date, entry, semicolon.
Line 36; indented once: list, dot, Reset List, left parenthesis, right
parenthesis, semicolon.
Line 37; indented once: entry, equals, list, dot, Get Next Item, left
parenthesis, right parenthesis, semicolon.
Line 38; indented once: while, left parenthesis, entry, dot, Compared
To, left parenthesis, other Entry, right parenthesis, exclamation
mark, equals, SAME, right parenthesis.
Line 39; indented twice: entry, equals, list, dot, Get Next Item, left
parenthesis, right parenthesis, semicolon.
Line 40; indented once: list, dot, Delete, left parenthesis, entry, right
parenthesis, semicolon.
Line 41; indented once: return, entry, semicolon.
Line 42: right brace.
Line 43: blank line.
Line 44: 2 forward slashes followed by asterisk till the end of the line.
Line 45: void, Appointment Calendar, colon, colon, Insert Entry, left
parenthesis, Entry With Date, entry, right parenthesis.

Line 46: left brace, list, dot, Insert, left parenthesis, entry, right
parenthesis, semicolon, right brace.
Line 47: blank line.
Line 48: 2 forward slashes followed by asterisk till the end of the line.
Line 49: blank line.
Line 50: void, Appointment Calendar, colon, colon, Write List To File,
left parenthesis, o f stream, ampersand, out File, right parenthesis.
Line 51: left brace.
Line 52; indented once: Entry With Date, entry, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keyword: while, end l.
Line 1; indented once: Name, name, semicolon.
Line 2; indented once: Date, date, semicolon. 
Line 3; indented once: Time Of Day, time, semicolon.
Line 4; indented once: list, dot, Reset List, left parenthesis, right
parenthesis, semicolon.
Line 5; indented once: out File, 2 left angled brackets, list, dot, Get
Length, left parenthesis, right parenthesis, 2 left angled brackets,
end l, semicolon.
Line 6; indented once: while, left parenthesis, list, dot, Has Next, left
parenthesis, right parenthesis, right parenthesis.
Line 7; indented once: left brace.
Line 8; indented twice: entry, equals, list, dot, Get Next Item, left
parenthesis, right parenthesis, semicolon.
Line 9; indented twice: time, equals, entry, dot, Get Time, left
parenthesis, right parenthesis, semicolon. 
Line 10; indented twice: Out File, 2 left angled brackets, time, dot,
Get Hours, left parenthesis, right parenthesis, 2 left angled brackets,
single quotes, space, single quotes, 2 left angled brackets, time, dot,
Get Minutes, left parenthesis, right parenthesis, 2 left angled
brackets, single quotes, space, single quotes.
Line 11: indented 6 times: 2 left angled brackets, time, dot, Get
Seconds, left parenthesis, right parenthesis, 2 left angled brackets,
single quotes, space, single quotes, semicolon.
Line 12; indented twice: date, equals, entry, dot, Get Date, left
parenthesis, right parenthesis, semicolon.

Line 13; indented twice: out File, 2 left angled brackets, date, dot,
Get Month, left parenthesis, right parenthesis, 2 left angled
brackets, single quotes, space, single quotes, 2 left angled brackets,
date, dot, Get Day, left parenthesis, right parenthesis, 2 left angled
brackets, single quotes, space, single quotes.
Line 14; indented 6 times: 2 left angled brackets, date, dot, Get
Year, left parenthesis, right parenthesis, 2 left angled brackets,
single quotes, space, single quotes, semicolon. 
Line 15; indented twice: name, equals, entry, dot, Get Name, left
parenthesis, right parenthesis, semicolon.
Line 16; indented twice: out File, 2 left angled brackets, name, dot,
Get First Name, left parenthesis, right parenthesis, 2 left angled
brackets, single quotes, space, single quotes, 2 left angled brackets,
name, dot, Get Middle Name, left parenthesis, right parenthesis. 
Line 17; indented 6 times: 2 left angled brackets, single quotes,
space, single quotes, 2 left angled brackets, name, dot, Get Last
Name, left parenthesis, right parenthesis, 2 left angled brackets, end
l, semicolon.
Line 18; indented once: left brace.
Line 19; indented once: out File, dot, close, left parenthesis, right
parenthesis, semicolon.
Line 20: right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: include,
using namespace, i o stream, f stream, c c type, string, char, void,
int.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: DRIVER for Appointment Calendar problem.
Line 3: Implements User Interface class in design.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: blank line.
Line 6: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 7: Hash include, left angled bracket, f stream, right angled
bracket.
Line 8: Hash include, left angled bracket, c c type, right angled

bracket. 2 forward slashes. For to upper.
Line 9: Hash include, left angled bracket, string, right angled
bracket.
Line 10: Hash include, double quotes, Appointment Calendar, dot, h,
double quotes.
Line 11: using, namespace, s t d, semicolon.
Line 12: blank line.
Line 13: char, Get Input Code, left parenthesis, right parenthesis,
semicolon.
Line 14: 2 forward slashes. Prompts for and reads input code.
Line 15: Time Of Day, Get Time, left parenthesis, right parenthesis,
semicolon.
Line 16: 2 forward slashes. Prompts for and reads a time object.
Line 17: Date, Get Date, left parenthesis, right parenthesis,
semicolon.
Line 18: 2 forward slashes. Prompts for and reads a date object.
Line 19: Name, Get Name, left parenthesis, right parenthesis,
semicolon.
Line 20: 2 forward slashes. Prompts for and reads name object.
Line 21: void, Get Entry To Change, left parenthesis, Name
ampersand, name, comma, Date ampersand, date, right
parenthesis, semicolon.
Line 22: 2 forward slashes. Prompts for and reads name and date of
object to change.
Line 23: blank line.
Line 24: int, main, left parenthesis, right parenthesis.
Line 25: left brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: if, I f stream,
char, return, c out, do, switch, case, else, c in, to upper, break, end
l.
Line 1; indented once: i f stream, in File, semicolon.
Line 2; indented once: in File, dot, open, left parenthesis, double
quotes, Calendar File, double quotes, right parenthesis, semicolon.
Line 3; indented once: if, left parenthesis, exclamation, in File, right
parenthesis.

Line 4; indented once: left brace.
Line 5; indented twice: c out, 2 left angled brackets, double quotes,
File not found, period, double quotes, 2 left angled brackets, end l,
semicolon.
Line 6; indented twice: return, 1, semicolon.
Line 7; indented once: right brace.
Line 8; indented once: char, input Code, semicolon.
Line 9; indented once: Time Of Day, time, semicolon.
Line 10; indented once: Date, date, semicolon.
Line 11; indented once: Name, name, semicolon.
Line 12; indented once: Entry With Date, entry, semicolon.
Line 13; indented once: char, yes or No, semicolon.
Line 14; indented once: Appointment Calendar, calendar, left
parenthesis, in File, right parenthesis, semicolon.
Line 15: blank line.
Line 16; indented once: Get Entry To Change, left parenthesis,
name, comma, date, right parenthesis, semicolon.
Line 17; indented once: do.
Line 18; indented once: left brace.
Line 19; indented twice: if, left parenthesis, calendar, dot, Is There,
left parenthesis, name, comma, date, right parenthesis, right
parenthesis. 
Line 20; indented twice: left brace.
Line 21; indented thrice: entry, equals, calendar, dot, Get Entry, left
parenthesis, name, comma, date, right parenthesis, semicolon.
Line 22; indented thrice: Time Of Day, time, equals, entry, dot, Get
Time, left parenthesis, right parenthesis, semicolon.
Line 23; indented thrice: c out, 2 left angled brackets, double quotes,
Entry retrieved, colon, double quotes, end l, semicolon.
Line 24; indented thrice: c out, 2 left angled brackets, double quotes,
Time, double quotes, 2 left angled brackets, entry, dot, Get Time,
left parenthesis, right parenthesis, dot, Get Hours, left parenthesis,
right parenthesis, 2 left angled brackets, single quotes, colon, single
quotes.
Line 25; indented 6 times: 2 left angled brackets, entry, dot, Get
Time, left parenthesis, right parenthesis, dot, Get Minutes, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 26; indented thrice: c out, 2 left angled brackets, double quotes,

Date, double quotes, 2 left angled brackets, entry, dot, Get Date, left
parenthesis, right parenthesis, dot, Get Month, left parenthesis, right
parenthesis, 2 left angled brackets, single quotes, slash, single
quotes.
Line 27; indented 6 times: 2 left angled brackets, entry, dot, Get
Date, left parenthesis, right parenthesis, dot, Get Day, left
parenthesis, right parenthesis, 2 left angled brackets, single quotes,
slash, single quotes.
Line 28; indented 6 times: 2 left angled brackets, entry, dot, Get
Date, left parenthesis, right parenthesis, dot, Get Year, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 29; indented thrice: c out, 2 left angled brackets, double quotes,
Name, double quotes, 2 left angled brackets, entry, dot, Get Name,
left parenthesis, right parenthesis, dot, Get First Name, left
parenthesis, right parenthesis, 2 left angled brackets, single quotes,
space, single quotes.
Line 30; indented 6 times: 2 left angled brackets, entry, dot, Get
Name, left parenthesis, right parenthesis, dot, Get Last Name, left
parenthesis, right parenthesis, 2 left angled brackets, end l, 2 left
angled brackets, end l, semicolon.
Line 31; indented thrice: input Code, equals, Get Input Code, left
parenthesis, right parenthesis, semicolon.
Line 33; indented thrice: switch, left parenthesis, input Code, right
parenthesis.
Line 34; indented thrice: left brace.
Line 35; indented 4 times: case, single quotes, T, single quotes,
colon, time, equals, Get Time, left parenthesis, right parenthesis,
semicolon, break, semicolon.
Line 36; indented 4 times: case, single quotes, D, single quotes,
colon, date, equals, Get Date, left parenthesis, right parenthesis,
semicolon, break, semicolon.
Line 37; indented 4 times: case, single quotes, N, single quotes,
colon, name, equals, Get Name, left parenthesis, right parenthesis,
semicolon, break, semicolon.
Line 38; indented thrice: right brace.
Line 39; indented thrice: Entry With Date, entry, left parenthesis,
date, comma, time, comma, name, right parenthesis, semicolon.
Line 40; indented thrice: calendar, dot, Insert Entry, left parenthesis,

entry, right parenthesis, semicolon.
Line 41; indented twice: right brace.
Line 41; indented twice: else.
Line 42; indented thrice: c out, 2 left angled brackets, double quotes,
No entry exists with this name and date, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 43; indented twice: c out, 2 left angled brackets, double quotes,
Do you wish to continue changing entries, question mark. Single
quotes, Y, single quotes, or, single quotes, N, single quotes, double
quotes.
Line 44; indented 5 times: 2 left angled brackets, end l, semicolon.
Line 45; indented twice: c in, 2 right angled brackets, yes Or No,
semicolon.
Line 46; indented twice: if, left parenthesis, to upper, left
parenthesis, yes Or No, right parenthesis, equals, equals, single
quotes, Y, single quotes, right parenthesis.
Line 47; indented 4 times: Get Entry To Change, left parenthesis,
name, comma, date, right parenthesis, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: while, to
upper, o f stream, return, char, c in, c out, int, string, end l.
Line 1; indented twice: right brace, while, left parenthesis, left
parenthesis, to upper, left parenthesis, yes Or No, equals, equals,
single quotes, Y, single quotes, right parenthesis, right parenthesis,
right parenthesis, semicolon.
Line 2; indented once: in File, dot, close, left parenthesis, right
parenthesis, semicolon.
Line 3; indented once: o f stream, out File, semicolon.
Line 4; indented once: out File, dot, open, left parenthesis, double
quotes, Calendar File, double quotes, right parenthesis, semicolon.
Line 5; indented once: Calendar, dot, Write List To File, left
parenthesis, out File, right parenthesis, semicolon.
Line 6; indented once: out File, dot, close, left parenthesis, right
parenthesis, semicolon.
Line 7; indented once: return,0, semicolon.
Line 8; indented once: right brace.

Line 9: blank line. 
Line 10: 2 forward slashes followed by asterisk till the end of the line.
Line 11: blank line.
Line 12: char, Get Input Code, left parenthesis, right parenthesis.
Line 13: left brace.
Line 14; indented once: char, input Code, semicolon.
Line 15; indented once: c out, 2 left angled brackets, double quotes,
Enter field to change, colon, single quotes, T, single quotes, left
parenthesis, time, right parenthesis, single quotes, D, single quotes,
left parenthesis, date, right parenthesis, single quotes, N, single
quotes, left parenthesis, name, right parenthesis, double quotes.
Line 16; indented thrice: end l, semicolon.
Line 17; indented once: c in, 2 right angled brackets, input Code,
semicolon.
Line 18; indented once: return, to upper, left parenthesis, input
Code, right parenthesis, semicolon.
Line 19; right brace.
Line 20: blank line. 
Line 21: 2 forward slashes followed by asterisk till the end of the line.
Line 22: blank line.
Line 23: Time Of Day, Get Time, left parenthesis, right parenthesis.
Line 24: left brace.
Line 25; indented once: int, hours, comma, minutes, comma,
seconds, semicolon.
Line 26; indented once: c out, 2 left angled brackets, double quotes,
Enter time as hours, comma, minutes, comma, seconds, double
quotes, 2 left angled brackets, end l, semicolon.
Line 27; indented once: c in, 2 right angled brackets, hours, 2 right
angled brackets, minutes,2 right angled brackets, seconds,
semicolon.
Line 28; indented once: Time Of Day, time, left parenthesis, hours,
comma, minutes, comma, seconds, semicolon.
Line 29; indented once: return, time, semicolon.
Line 30: right brace.
Line 31: blank line. 
Line 32: 2 forward slashes followed by asterisk till the end of the line.
Line 33: blank line.
Line 34: Date, Get Date, left parenthesis, right parenthesis.
Line 35: left brace.

Line 36; indented once: int, month, comma, day, comma, year,
semicolon.
Line 37; indented once: c out, 2 left angled brackets, double quotes,
Enter date as month, comma, day, comma, and year, double
quotes, 2 left angled brackets, end l, semicolon.
Line 38; indented once: c in, 2 right angled brackets, month, 2 right
angled brackets, year, semicolon.
Line 39; indented once: Date, date, left parenthesis, month, comma,
day, comma, year, right parenthesis, semicolon.
Line 40; indented once: return, date, semicolon.
Line 41: right brace.
Line 42: blank line. 
Line 43: 2 forward slashes followed by asterisk till the end of the line.
Line 44: blank line.
Line 45: Name, Get Name, left parenthesis, right parenthesis.
Line 46: left brace.
Line 47; indented once: string, first, comma, middle, comma, last,
semicolon.
Line 48; indented once: c out, 2 left angled brackets, double quotes,
Enter name as first, comma, middle, comma, last, double quotes, 2
left angled brackets, end l, semicolon.
Line 49; indented once: c in, 2 right angled brackets, first, 2 right
angled brackets, middle, 2 right angled brackets, last, semicolon.
Line 50; indented once: Name, name, left parenthesis, first, comma,
middle, comma, last, right parenthesis, semicolon.
Line 51; indented once: return, name, semicolon.
Line 52: right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: void, c out,
end l.
Line 1: 2 forward slashes followed by asterisk till the end of the line. 
Line 2: blank line.
Line 3: void, Get Entry To Change, left parenthesis, Name
ampersand, name, comma, Date ampersand, date, right
parenthesis.
Line 4: left brace.

Line 5; indented once: c out, 2 left angled brackets, double quotes,
Enter name of entry to change, colon, double quotes.
Line 6; indented 4 times: 2 left angled brackets, end l, semicolon.
Line 7; indented once: name, equals, Get Name, left parenthesis,
right parenthesis, semicolon.
Line 8; indented once: c out, 2 left angled brackets, double quotes,
Enter date of entry to change, double quotes.
Line 9; indented 4 times: 2 left angled brackets, end l, semicolon.
Line 10; indented once: date, equals, Get Date, left parenthesis,
right parenthesis, semicolon.
Line 11: right brace."
Back to Figure
Line 1: Calendar File. Line 2: 5. Line 3: 8, 20, 0, 10, 12, 2023, Boris,
Becker, Brown. Line 4: 8, 45, 0, 10, 11, 2023, Sara, Jane, Jones.
Line 5: 12, 30,0, 10, 11, 2023, Susy, Smiley, Baker. Line 6: 8, 30, 0,
10, 12, 2023, Bill, Bradley, Britton. Line 7: 9, 30, 0, 11, 5, 2024,
Mary, Jane, Smith.
Back to Figure
"Line 1: Enter name of entry to change, colon.
Line 2: Enter name as first, comma, middle, comma, last.
Line 3: Mary Jane Smith. Line 3 is shaded.
Line 4: Enter date of entry to change.
Line 5: Enter date as month, day, and year.
Line 6: 11, 5, 2024. Line 6 is shaded.
Line 7: Entry retrieved, colon.
Line 8: Time, 9, colon, 30.
Line 9: Date, 11, slash, 5, slash, 2024.
Line 10: Name, Mary Smith.
Line 11: blank line
Line 12: Enter field to change, colon, single quotes, T, single quotes,
left parenthesis, time, right parenthesis, single quotes, D, single
quotes, left parenthesis, date, right parenthesis, single quotes, N,
single quotes, left parenthesis, name, right parenthesis.
Line 13: D. Line 13 is shaded.
Line 14: Enter date as month, comma, day, comma, and year.

Line 15: 11, 5, 2023. Line 15 is shaded.
Line 16: Do you wish to continue changing entries, question mark.
Single quotes, Y, single quotes, or, single quotes N, single quotes.
Line 17: Y. Line 17 is shaded.
Line 18: Enter name of entry to change, colon.
Line 19: Entry name as first, comma, middle, comma, last.
Line 20: Bill Bradley Britton. Line 20 is shaded."
Back to Figure
"Line 1: Enter date of entry to change.
Line 2: Enter date as month, comma, day, comma, and year.
Line 3: 10, 12, 2023. Line 3 is shaded.
Line 4: Entry retrieved, colon.
Line 5: Time, 8, colon, 30.
Line 6: Date, 10, slash, 12, slash, 2023.
Line 7: Name, Bill Britton.
Line 8: blank line.
Line 9: Enter field to change, colon, single quotes, T, single quotes,
left parenthesis, time, right parenthesis, single quotes, D, single
quotes, D, single quotes, left parenthesis, date, right parenthesis,
single quotes, N, single quotes, left parenthesis, name, right
parenthesis.
Line 10: T. Line 10 is shaded.
Line 11: Enter time as hours, comma, minutes, comma, seconds.
Line 12: 9,30, 0. Line 12 is shaded.
Line 13: Do you wish to continue changing entries, question mark.
Single quotes, Y, single quotes, or, single quotes, N, single quotes.
Line 14: Y. Line 14 is shaded.
Line 15: Enter name of entry to change, colon.
Line 16: Enter name as first, comma, middle, comma, last.
Line 17: Sara Jane Jones. Line 17 is shaded.
Line 18: Enter date of entry to change.
Line 19: Enter date as month, comma, day, comma, and year.
Line 20: 10, 11, 2023. Line 20 is shaded.
Line 21: Entry retrieved, colon.
Line 22: Time, 8, colon, 45.
Line 23: Date, 10, slash, 11, 2023.
Line 24: Name, Sara Jones.

Line 25: blank line.
Line 26: Enter field to change, colon, single quotes, T, single quotes,
left parenthesis, time, right parenthesis, single quotes, D, single
quotes, D, single quotes, left parenthesis, date, right parenthesis,
single quotes, N, single quotes, left parenthesis, name, right
parenthesis.
Line 27: N. Line 27 is shaded.
Line 28: Enter name as first, comma, middle, comma, last.
Line 29: Sara Jane Jones. Line 29 is shaded.
Line 30: Do you wish to continue changing entries, question mark.
Single quotes, Y, single quotes, or, single quotes, N, single quotes.
Line 31: Y. Line 31 is shaded.
Line 32: Enter date of entry to change.
Line 33: Enter name as first, comma, middle, comma, last.
Line 34: Sara Jane Jones. Line 34 is shaded.
Line 35: Enter date of entry to change.
Line 36: Enter date as month, comma, day, comma, and year.
Line 37: 10, 11, 2023. Line 37 is shaded.
Line 38: No entry exists with this name and date.
Line 39: Do you wish to continue changing entries, question mark.
Single quotes, Y, single quotes, or, single quotes, N, single quotes.
Line 40: N. Line 40 is shaded."
Back to Figure
The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is the text box for Entries. The value is as
follows. Line 1: Boris Brown. Line 2: Susy Baker. Line 3: Bill Britton.
Line 4: Mary Smith. Line 5: Sara Jones. On the right, is the lists of
contents which are as follows. Line 1: First Name, followed by a text
box. Line 2: Middle Name, followed by a text Box. Line 3: Last
Name, followed by a text box. Line 4: Time of Day, followed by a text
box with drop down arrow. 07, slash, 26, slash, 2021; 10, colon, 47,
colon, 20, A M is displayed. 2 buttons on the bottom right corner are
labeled as Save, and Exit.
Back to Figure

The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is the text box for Entries. The value is as
follows. Line 1: Susy Baker. Line 2: Bill Britton. Line 3: Mary Smith.
Line 4: Sara Jones. Line 5: Boris Brown. Susy Baker is highlighted.
On the right, is the lists of contents which are as follows. Line 1:
First Name, followed by a text box with a value Susy. Line 2: Middle
Name, followed by a text Box with a value Smiley. Line 3: Last
Name, followed by a text box with a value Baker. Line 4: Time of
Day, followed by a text box with drop down arrow. 10, slash, 11,
slash, 2023; 12, colon, 30, colon, 00, P M is displayed. A small
calendar of october 2023 is popped up below the Time of Day. The
date 11 is highlighted. A button on the bottom right corner is labeled
as Save.
Back to Figure
"Line 1: Hash include, left angled bracket, Q Main Window, right
angled bracket.
Line 2: blank line.
Line 3: class, Appointment Calendar Window, colon, public, Q Main
Window.
Line 4: left brace.
Line 5; indented once: Q, underscore, OBJECT.
Line 6: blank line.
Line 7: public, colon.
Line 8; indented once: Appointment Calendar Window, left
parenthesis, Q Widget, asterisk parent, equals, null p t r, right
parenthesis, semicolon. 2 forward slashes. Constructor.
Line 9; indented once: tilde, Appointment Calendar Window, left
parenthesis, right parenthesis, semicolon.
Line 10: right brace, semicolon."
Back to Figure
"Line 1: Hash include, double quotes, Appointment Calendar
Window, dot, h, double quotes.
Line 2: blank line.
Line 3: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk parent, right

parenthesis.
Line 4; indented twice: colon, Q Main Window, left parenthesis,
parent, right parenthesis, left brace, right brace.
Line 5: blank line.
Line 6: Appointment Calendar Window, colon, colon, tilde,
Appointment Calendar Window, left parenthesis, right parenthesis,
left brace, right brace."
Back to Figure
"Line 1: Hash include, left angled bracket, Q Main Window, right
angled brackets.
Line 2: Hash include, left angled bracket, Q Widgets, right angled
brackets.
Line 3: blank line.
Line 4: class, Appointment Calendar Window, colon, public, Q Main
Window.
Line 5: left brace.
Line 6; indented once: Q, underscore, OBJECT.
Line 7: blank line.
Line 8: public, colon.
Line 9; indented once: Appointment Calendar Window, left
parenthesis, Q Widget, asterisk, parent, equals, null p t r, right
parenthesis, semicolon.
Line 10: tilde, Appointment Calendar Window, left parenthesis, right
parenthesis, semicolon.
Line 11: blank line.
Line 12: private, colon.
Line 13; indented once: Q Push Button, asterisk, save Button,
semicolon.
Line 14; indented once: Q Push Button, asterisk, exit Button,
semicolon.
Line 15: blank line.
Line 16; indented once: Q Widget, asterisk, Build Buttons Widget,
left parenthesis, right parenthesis, semicolon.
Line 17: right brace, semicolon."
Back to Figure

"Line 1: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk, parent, right
parenthesis.
Line 2; indented twice: colon, Q Main Window, left parenthesis,
parent, right parenthesis.
Line 3: left brace.
Line 4; indented once: Q Widget, asterisk, buttons Widget, equals,
Build Button Widget, left parenthesis, right parenthesis, semicolon. 2
forward slashes. Get the widget with the buttons.
Line 5; indented once: set Central Widget, left parenthesis, buttons
Widget, right parenthesis, semicolon. 2 forward slashes. Put it in the
window.
Line 6; indented once: set Window Title, left parenthesis, double
quotes, Calendar Appointment A p p, double quotes, right
parenthesis, semicolon. 2 forward slashes. Add a title to the window.
Line 7: right brace.
Line 8: blank line.
Line 9: Q Widget, asterisk, Appointment Calendar Window, colon,
colon, Build Buttons Widget, left parenthesis, right parenthesis.
Line 10: left brace.
Line 11; indented once: Q Widget, asterisk, buttons Widget, equals,
new, Q Widget, semicolon. 2 forward slashes. Make an empty
Widget.
Line 12; indented once: Q H Box Layout, asterisk, buttons Layout,
equals, new, Q H Box Layout, semicolon. 2 forward slashes. Make
an empty layout object.
Line 13; indented once: buttons Widget, minus, right angled bracket,
set Layout, left parenthesis, buttons Layout, right parenthesis,
semicolon. 2 forward slashes. Put the layout in the widget.
Line 14: blank line.
Line 15; indented once: save Button, equals, new, Q Push Button,
left parenthesis, double quotes, Save, double quotes, right
parenthesis, semicolon. 2 forward slashes. Make a Save button.
Line 16; indented once: exit Button, equals, new, Q Push Button, left
parenthesis, double quotes, Exit, double quotes, right parenthesis,
semicolon. 2 forward slashes. Make an Exit button.
Line 17: blank line.
Line 18; indented once: buttons Layout, minus, right angled bracket,
add Widget, left parenthesis, save Button, right parenthesis,

semicolon. 2 forward slashes. Put Save Button in layout.
Line 19; indented once: buttons Layout, minus, right angled bracket,
add Widget, left parenthesis, exit Button, right parenthesis,
semicolon. 2 forward slashes. Put Exit Button in layout.
Line 20: blank line.
Line 21; indented once: return, buttons Widget, semicolon. 2 forward
slashes. Return the whole thing.
Line 22: right brace."
Back to Figure
2 button blocks each labeled Q Push Button is enclosed in a block of
rectangle labeled Q H Box Layout, which is enclosed in a block of
rectangle labeled Q Widget.
Back to Figure
"Line 1: Hash include, left angled bracket, Q Application, right angled
bracket. 
Line 2: blank line.
Line 3: Hash include, double quotes, Appointment Calendar Window,
dot, h, double quotes.
Line 4: using, namespace, s t d, semicolon.
Line 5: blank line.
Line 6: int, main, left parenthesis, int, a r g c, comma, char, asterisk
a r g v, left square bracket, right square bracket, right parenthesis.
Line 7: left brace.
Line 8; indented once: Q Application app, left parenthesis, a r g c,
comma, a r g v, right parenthesis, semicolon.
Line 9; indented once: Appointment Calendar Window, window,
semicolon.
Line 10; indented once: window, dot, show, left parenthesis, right
parenthesis, semicolon.
Line 11; indented once: return, a p p, dot, e x e c, left parenthesis,
right parenthesis, semicolon.
Line 12: right brace."
Back to Figure

The Calendar Appointment App with a window and two buttons
labeled Save and Exit.
Back to Figure
"Line 1: Hash include, left angled bracket, Q Main Window, right
angled bracket.
Line 2: Hash include, left angled bracket, Q t Widgets, right angled
bracket.
Line 3: class, Appointment Calendar Window, colon, public, Q Main
Window.
Line 4: left brace.
Line 5; indented once: Q, underscore, OBJECT."
Back to Figure
The design of the form for an Appointment Calendar. The form has
input fields for First Name, Middle Name, and Last Name. It has a
drop down menu for Time of Day.
Back to Figure
"Line 1: public, colon.
Line 2; indented once: Appointment Calendar Window, left
parenthesis, Q Widget, asterisk, parent, equals, null p t r, right
parenthesis, semicolon.
Line 3: tilde, Appointment Calendar Window, left parenthesis, right
parenthesis, semicolon.
Line 4: blank line.
Line 5: private, colon.
Line 6; indented once: Q Label, asterisk, first Name Label,
semicolon.
Line 7; indented once: Q Line Edit, asterisk, first Name Line Edit,
semicolon.
Line 8; indented once: blank line.
Line 9; indented once: Q Label, asterisk, middle Name Label,
semicolon.
Line 10; indented once: Q Line Edit, asterisk, middle Name Line
Edit, semicolon.

Line 11: blank line.
Line 12; indented once: Q Label, asterisk, last Name Label,
semicolon.
Line 13; indented once: Q Line Edit, asterisk, last Name Line Edit,
semicolon.
Line 14: blank line.
Line 15; indented once: Q Label, asterisk, time Of Day Label,
semicolon.
Line 16; indented once:Q Date Time Edit, asterisk, time Of Day
Time, semicolon.
Line 17: blank line.
Line 18; indented once: Q Push Button, asterisk, save Button,
semicolon.
Line 19; indented once: Q Push Button, asterisk, exit Button,
semicolon.
Line 20: blank line.
Line 21; indented once: Q Widget, asterisk, Build Buttons Widget,
left parenthesis, right parenthesis, semicolon.
Line 22; indented once: Q Widget, asterisk, Build Form Widget, left
parenthesis, right parenthesis, semicolon.
Line 23: right brace, semicolon."
Back to Figure
"Line 1: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk, parent, right
parenthesis.
Line 2; indented twice: colon, Q Main Window, left parenthesis,
parent, right parenthesis.
Line 3: left brace.
Line 4; indented once: Q Widget, asterisk, buttons Widget, equals,
Build Buttons Widget, left parenthesis, right parenthesis, semicolon.
Line 5; indented once: set Central Widget, left parenthesis, form
Widget, right parenthesis, semicolon.
Line 6; indented once: set Window Title, left parenthesis, double
quotes, Calendar Appointment A p p, double quotes, right
parenthesis, semicolon.
Line 7: right brace.
Line 8: blank line.

Line 9: Q Widget, asterisk, Appointment Calendar Window, colon,
colon, Build Form Widget, left parenthesis, right parenthesis.
Line 10: left brace.
Line 11; indented once: 2 forward slashes. Create a wrapper widget
and layout, comma, then connect them.
Line 12; indented once: Q Widget, asterisk, form Widget, equals,
new, Q Widget, semicolon.
Line 13; indented once: Q Grid Layout, asterisk, form Layout,
equals, new, Q Grid Layout, semicolon.
Line 14; indented once: form Widget, minus, right angled bracket,
set Layout, left parenthesis, form Layout, right parenthesis,
semicolon.
Line 15; indented once: 2 forward slashes. Create three labels and
corresponding text boxes.
Line 16; indented once: first Name Label, equals, new, Q Label, left
parenthesis, double quotes, First Name, double quotes, right
parenthesis, semicolon.
Line 17; indented once: first Name Line Edit, equals, new Q Line
Edit, semicolon.
Line 18; indented once: middle Name Label, equals, new, Q Label,
left parenthesis, double quotes, Middle Name, double quotes, right
parenthesis, semicolon.
Line 19; indented once: middle Name Line Edit, equals, new, Q Line
Edit, semicolon.
Line 20; indented once: last Name Label, equals, new, Q Label, left
parenthesis, double quotes, Last Name, double quotes, right
parenthesis, semicolon.
Line 21; indented once: last Name Line Edit, equals, new, Q Line
Edit, semicolon.
Line 22; indented once: 2 forward slashes. Create a label and a
widget with the current date and time.
Line 23; indented once: time Of Day Label, equals, new, Q Label,
left parenthesis, double quotes, Time of Day, double quotes, right
parenthesis, semicolon.
Line 24; indented once: time Of Day Time, equals, new, Q Date
Time Edit, left parenthesis, Q Date Time, colon, colon, current Date
Time, left parenthesis, right parenthesis, right parenthesis,
semicolon.
Line 25; indented once: Set the formatting of the date and time

widget.
Line 26; indented once: time Of Day Time, minus, right angled
bracket, set Display Format, left parenthesis, double quotes, M M,
slash, d d, slash, y y y y, h, colon, m m, colon, s s, a p, double
quotes, right parenthesis, semicolon.
Line 27; indented once: time Of Day Time, minus, right angled
bracket, set Calendar Popup, left parenthesis, true, right
parenthesis, semicolon.
Line 28; indented once: 2 forward slashes. Add the pieces to the
layout using row, comma, column, comma, left alignment.
Line 29; indented once: form Layout, minus, right angled bracket,
add Widget, left parenthesis, first Name Label, comma, 0, comma,
0, comma, Q t, colon, colon, Align Left, right parenthesis,
semicolon."
Back to Figure
The components in the form for an appointment calendar laid out
using Form Grid Layout. The form has two columns numbered 0 and
1 and four rows numbered from 0 to 3. In the first column, all the
names for the input fields are present. In the second row, the text
fields for input and the drop down box are present. In each row, we
have the names for the input fields and the input fields themselves.
Back to Figure
"Line 1; indented once: form Layout, minus, right angled bracket,
add Widget, left parenthesis, first Name Line Edit, comma, 0,
comma, 1, comma, Q t, colon, colon, Align Left, right parenthesis,
semicolon.
Line 2; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, middle Name Label, comma, 1, comma, 0,
comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.
Line 3; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, middle Name Line Edit, comma, 1, comma,
1, comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.
Line 4; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, last Name Label, comma, 2, comma, 0,
comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.

Line 5; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, last Name Line Edit, comma, 2, comma, 1,
comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.
Line 6; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, time Of Day Label, comma, 3, comma, 0,
comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.
Line 7; indented once: form Layout, minus, right angled bracket, add
Widget, left parenthesis, time Of Day Time, comma, 3, comma, 1,
comma, Q t, colon, colon, Align Left, right parenthesis, semicolon.
Line 8: blank line.
Line 9; indented once: return, form Widget, semicolon.
Line 10: right brace."
Back to Figure
"Line 1: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk, parent, right
parenthesis.
Line 2; indented twice: colon, Q Main Window, left parenthesis,
parent, right parenthesis.
Line 3: left parenthesis.
Line 4; indented once: Q Widget, asterisk, buttons Widget, equals,
Build Buttons Widget, left parenthesis, right parenthesis, semicolon.
Line 5; indented once: Q Widget, asterisk, form Widget, equals,
Build Form Widget, left parenthesis, right parenthesis, semicolon.
Line 6: blank line.
Line 7; indented once: set Central Widget, left parenthesis, form
Widget, right parenthesis, semicolon.
Line 8; indented once: set Window Title, left parenthesis, double
quotes, Calendar Appointment A p p, double quotes, right
parenthesis, semicolon.
Line 9: right brace."
Back to Figure
The following list of contents is displayed in the dialog box. Line 1:
First Name, followed by a text box. Line 2: Middle Name, followed by
a text box. Line 3: Last Name, followed by a text box. Line 4: Time

of day, followed by time box with drop down arrow. 08, slash, 06,
slash, 2021; 11, colon, 50, colon, 25, A M is displayed.
Back to Figure
Line 1: Q Label, asterisk entries List Label, semicolon. Line 2: Q List
Widget, asterisk name List Widget, semicolon.
Back to Figure
"Line 1: Q Widget, asterisk, Appointment Calendar Window, colon,
colon, Build List Widget, left parenthesis, right parenthesis.
Line 2: left brace.
Line 3; indented once: 2 forward slashes. Create a wrapper widget
and layout, comma, then connect them.
Line 4; indented once: Q Widget, asterisk, list Widget, equals, new,
Q Widget, semicolon.
Line 5; indented once: Q V Box Layout, asterisk, list Layout, equals,
new, Q V Box Layout, semicolon.
Line 6; indented once: entries Widget, minus, right angled bracket,
set Layout, left parenthesis, list Layout, right parenthesis, semicolon.
Line 7; indented once: 2 forward slashes. Create a label and a
widget to hold a list.
Line 8; indented once: entries List Label, equals, new, Q Label, left
parenthesis, double quotes, Entries, double quotes, semicolon.
Line 9; indented once: name List Widget, equals, new Q List Widget,
semicolon.
Line 10; indented once: 2 forward slashes. Add the pieces to the
layout vertically.
Line 11; indented once: list Layout, minus, right angled bracket, add
Widget, left parenthesis, entries List Label, right parenthesis,
semicolon.
Line 12; indented once: list Layout, minus, right angled bracket, add
Widget, left parenthesis, name List Widget, right parenthesis,
semicolon.
Line 13: blank line.
Line 14: return, list Widget, semicolon.
Line 15: right brace."

Back to Figure
"The words in the variable names are merged.
Line 1: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk, parent, right
parenthesis.
Line 2: indented thrice, colon, Q Main Window, left parenthesis,
parent, right parenthesis.
Line 3: left brace.
Line 4: indented once, Q Widget, asterisk buttons Widget, equals,
Build Buttons Widget, left and right parenthesis, semicolon.
Line 5: indented once, Q Widget, asterisk form Widget, equals, Build
Form Widget, left and right parenthesis, semicolon."
Back to Figure
"Line 1: indented once, Q Widget, asterisk, list Widget, equals, Build
List Widget, left and right parenthesis, semicolon.
Line 2: indented once, set Central Widget, left parenthesis, list
Widget, right parenthesis, semicolon.
Line 3: indented once, set Window Title, left parenthesis, double
quote, Calendar Appointment App, double quote, right parenthesis,
semicolon.
Line 4: right brace."
Back to Figure
Line 1: Q Label, asterisk message Label, semicolon. Line 2: Q
widget, asterisk Build Main Widget, left parenthesis, Q Widget,
asterisk entries Widget, comma, Q Widget, asterisk form Widget,
comma. Line 3; indented 6 times: Q Widget, asterisk buttons
Widget, right parenthesis, semicolon.
Back to Figure
"Program code. The words used in the variable names and
keywords are merged. The program contains the following
keywords: return.
Line 1: Q Widget, asterisk, Appointment Calendar Window, colon,

colon, Build Main Widget, left parenthesis, Q Widget, asterisk,
entries Widget, comma.
Line 2: indented 26 times: Q Widget, asterisk, form Widget, comma.
Line 3: indented 26 times: Q Widget, asterisk, buttons Widget,
comma. 
Line 4: indented 26 times: Q Widget, asterisk, message Label, right
parenthesis. 
Line 5: left brace. 
Line 6: indented once: 2 forward slashes, Create a wrapper widget
and layout, comma, then connect them.
Line 7: indented once: Q Widget, asterisk, main Widget, equals sign,
new Q Widget, semicolon. 
Line 8: indented once: Q Grid Layout, asterisk, main Layout, equals
sign, new Q Grid Layout, semicolon. 
Line 9: indented once: main Widget, hyphen, right angled bracket,
set Layout, left parenthesis, main Layout, right parenthesis,
semicolon. 
Line 10: indented once: 2 forward slashes, Create an empty label.
Line 11: indented once: message Label, equals sign, new Q Label,
left parenthesis, double quotes, double quotes, right parenthesis,
semicolon. 
Line 12: indented once: 2 forward slashes, Add the main pieces to
the layout using row, comma, column.
Line 13: indented once: main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, entries Widget, comma, 0, comma, 0,
right parenthesis, semicolon. 
Line 14: indented once: main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, form Widget, comma, 0, comma, 1,
right parenthesis, semicolon.
Line 15: indented once: main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, buttons Widget, comma, 1, comma, 1,
right parenthesis, semicolon. 
Line 16: indented once: 2 forward slashes, Add the label to the
layout using coordinates, comma, spans, comma, center alignment.
Line 17: indented once: main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, message Label, comma, 2, comma, 0,
comma, 1, comma, 2, comma, Q t, colon, colon, Align Center, right
parenthesis, semicolon. 
Line 18: blank.

Line 19: indented once: return main Widget, semicolon. 
Line 20: right brace."
Back to Figure
"Program code. The words used in the variable names are merged. 
Line 1: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis, Q Widget, asterisk, parent, right
parenthesis.
Line 2: indented twice: Q Main Window, left parenthesis, parent,
right parenthesis. 
Line 3: left brace.
Line 4: indented once: Q Widget, asterisk, buttons Widget, equals
sign, Build Buttons Widget, left parenthesis, right parenthesis,
semicolon. 
Line 5: indented once: Q Widget, asterisk, form Widget, equals sign,
Build Form Widget, left parenthesis, right parenthesis, semicolon. 
Line 6: indented once: Q Widget, asterisk, list Widget, equals sign,
Build List Widget, left parenthesis, right parenthesis, semicolon. 
Line 7: indented once: Q Widget, asterisk, message Label, equals
sign, new Q Label, left parenthesis, double quotes, double quotes,
right parenthesis, semicolon. 
Line 8: indented once: Q Widget, asterisk, main Widget, equals sign.
Line 9: indented thrice: Build Main Widget, left parenthesis, list
Widget, comma, form Widget, comma, buttons Widget, comma.
Line 10: message Label, right parenthesis, semicolon. 
Line 11: indented once: set Central Widget, left parenthesis, main
Widget, right parenthesis, semicolon. 
Line 12: indented once: set Window Title, left parenthesis, double
quotes, Calendar Appointment App, double quotes, right
parenthesis, semicolon. 
Line 13: right brace."
Back to Figure
The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is a blank text box for Entries. On the right,
is the lists of contents which are as follows. Line 1: First Name,
followed by a text box. Line 2: Middle Name, followed by a text Box.

Line 3: Last Name, followed by a text box. Line 4: Time of Day,
followed by a text box with drop down arrow. 07, slash, 26, slash,
2021; 2, colon, 58, colon, 27, P M is displayed. 2 buttons on the
bottom right corner are labeled as Save, and Exit.
Back to Figure
"Program code. The words used in the variable names are merged.
Line 1: 2 forward slashes, Appointment Calendar Window, dot, h.
Line 2: Appointment Calendar Window, left parenthesis, Appointment
Calendar, ampersand calendar In it, comma.
Line 3: indented 12 times: Q Widget, asterisk, parent, equals sign,
null p t r, right parenthesis, semicolon. 
Line 4: dot, dot, dot.
Line 5: Appointment Calendar, ampersand calendar, semicolon."
Back to Figure
"Program code. The words used in the variable names are merged.
Line 1: 2 forward slashes, Appointment Calendar Window, dot, c p p.
Line 2: Appointment Calendar Window, colon, colon, Appointment
Calendar Window, left parenthesis. 
Line 3: indented once: Appointment Calendar, ampersand, calendar
In it, comma, Q Widget, asterisk, parent, right parenthesis. 
Line 4: indented once: colon, Q Main Window, left parenthesis,
parent, right parenthesis, comma, calendar, left parenthesis,
calendar In it, right parenthesis. 
Line 5: left brace.
Line 6: dot, dot, dot.
Line 7: right brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: void, bool, return.
Line 1: 2 forward slashes, Appointment Calendar Window, dot, c p p.
Line 2: void Appointment Calendar, colon, colon, Reset List, left
parenthesis, right parenthesis, left brace, list, dot, Reset List, left
parenthesis, right parenthesis, semicolon, right brace. 

Line 3: bool Appointment Calendar, colon, colon, Has Next, left
parenthesis, right parenthesis, left brace, return list, dot, Has Next,
left parenthesis, right parenthesis, semicolon, right brace.
Line 4: Entry With Date Appointment Calendar, colon, colon, Get
Next Item, left parenthesis, right parenthesis, left brace, return list,
dot. 
Line 5: Get Next Item, left parenthesis, right parenthesis, semicolon,
right brace."
Back to Figure
"The words used in the variable names are merged.
Line 1: void Appointment Calendar Window, colon, colon, Load List
Widget, left and right parenthesis.
Line 2: left brace.
Line 3: indented once, calendar dot Reset List, left and right
parenthesis, semicolon.
Line 4: indented once, while, left parenthesis, calendar dot Has
Next, left and right parenthesis, right parenthesis.
Line 5: indented once, left brace.
Line 6: indented twice, Entry With Date, entry equals calendar dot
Get Next Item, left and right parenthesis, semicolon.
Line 7: indented twice, Name name, equals, entry dot Get Name,
left and right parenthesis, semicolon.
Line 8: indented twice, string display Name, equals, name dot Get
First Name, left and right parenthesis, plus, 2 double quotes, plus,
name dot Get Last Name, left and right parenthesis, semicolon.
Line 9: indented twice, Q List Widget Item, asterisk appointment
Item, equals.
Line 10: indented 4 times, new, Q List Widget Item, left parenthesis,
display Name, right parenthesis, semicolon.
Line 11: indented twice, name List Widget, minus, right angled
bracket, add Item, left parenthesis, appointment Item, right
parenthesis, semicolon.
Line 12: indented once, right brace.
Line 13: right brace."
Back to Figure

The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is the text box for Entries. The values in the
text box are as follows. Line 1: Boris Brown. Line 2: Susy Baker.
Line 3: Bill Britton. Line 4: Mary Smith. Line 5: Sara Jones. On the
right, is the lists of contents which are as follows. Line 1: First Name,
followed by a text box. Line 2: Middle Name, followed by a text Box.
Line 3: Last Name, followed by a text box. Line 4: Time of Day,
followed by a text box with drop down arrow. 07, slash, 26, slash,
2021; 10, colon, 47, colon, 20, A M is displayed. 2 buttons on the
bottom right corner are labeled as Save, and Exit.
Back to Figure
"The words in the variable names are merged.
Line 1: private slots, colon.
Line 2: indented once, void Handle Entry Item Clicked Event, left
parenthesis, Q List Widget Item, asterisk item, right parenthesis,
semicolon.
Line 3: indented once, void Handle Save Button Clicked Event, left
and right parenthesis, semicolon.
Line 4: indented once, void Handle Exit Button Clicked Event, left
and right parenthesis, semicolon."
Back to Figure
"Line 1: Q List Widget Item, asterisk current Item Loaded,
semicolon.
Line 2: Entry With Date, current Entry, semicolon."
Back to Figure
"Line 1: void Appointment Calendar Window, colon, colon, Handle
Exit Button Clicked Event, left and right parenthesis.
Line 2: left brace.
Line 3: indented once, this, minus, right angled bracket, close, left
and right parenthesis, semicolon.
Line 4: right brace."
Back to Figure

"The words in the variable names are merged.
Line 1: void Appointment Calendar Window, colon, colon, Load List
Widget, left and right parenthesis.
Line 2: left brace.
Line 3: indented once, calendar dot Reset List, left and right
parenthesis, semicolon.
Line 4: indented once, while, left parenthesis, calendar dot Has
Next, left and right parenthesis, right parenthesis.
Line 5: left brace.
Line 6: indented twice, Entry with Date entry, equals, calendar dot
Get Next Item, left and right parenthesis, semicolon.
Line 7: indented twice, Q List Widget Item, asterisk item, equals,
new Q List Widget Item, semicolon.
Line 7 is shaded.
Line 8: indented twice, Name name, equals, entry dot Get Name,
left and right parenthesis, semicolon.
Line 9: indented twice, string display Name, equals, name dot Get
First Name, left and right parenthesis, plus, 2 double quotes, plus,
name dot Get Last Name, left and right parenthesis, semicolon.
Line 10: indented twice, Q String, q name, equals, Q String, colon,
colon, from S t d, String, left parenthesis, display Name, right
parenthesis, semicolon.
Line 11: indented twice, item, minus, right angled bracket, set Text,
left parenthesis, q name, right parenthesis, semicolon.
Line 12: indented twice, string entry String, equals, entry dot To
String, left and right parenthesis, semicolon.
Line 13: indented twice, Q String, q string, equals, Q String, colon,
colon, from S t d, String, left parenthesis, entry String, right
parenthesis, semicolon.
Line 14: indented twice, Q Variant, entry Data, left parenthesis, q
string, right parenthesis, semicolon.
Line 15: item, minus, right angled bracket, set Data, left parenthesis,
Q t, colon, colon, User Role comma, entry Data, right parenthesis,
semicolon.
Lines 10 to 15 are shaded.
Line 16: indented twice, name List Widget, minus, right angled
bracket, add Item, left parenthesis, item, right parenthesis,
semicolon.

Line 17: indented once, right brace.
Line 18: right brace."
Back to Figure
"Line 1: string, entry String, equals, entry, dot, To String, left
parenthesis, right parenthesis, semicolon. 2 forward slashes.
Convert entry data to a string.
Line 2: Q String, q string, equals, Q String, colon, colon, from S t d
String, left parenthesis, entry String, right parenthesis, semicolon. 2
forward slashes. Convert string to Q String."
Back to Figure
"Line 1: Q Variant, entry Data, left parenthesis, q string, right
parenthesis, semicolon.
Line 2: item, minus, right angled bracket, set Data, left parenthesis,
Q t, colon, colon, user Role, comma, entry Data, right parenthesis,
semicolon."
Back to Figure
"The words in the variable names are merged.
Line 1: void Appointment Calendar Window, colon, colon, Handle
Entry Item Clicked Event, left parenthesis.
Line 2: indented 4 times, Q List Widget Item, asterisk item, right
parenthesis.
Line 3: left brace.
Line 4: indented once, message Label, minus, right angled bracket,
set Text, left parenthesis, 2 double quotes, right parenthesis,
semicolon.
Line 5: indented once, 2 forward slashes, Convert the data from the
item back into an entry.
Line 6: indented once, Q Variant, entry Data, equals, item, minus,
right angled bracket, data, left parenthesis, Q t, colon, colon, User
Role, right parenthesis, semicolon, 2 forward slashes, Get the data
as a Q Variant.
Line 7: indented once, Q String, q string, equals, entry Data dot to
String, left and right parenthesis, semicolon, 2 forward slashes,

Convert to a Q String.
Line 8: indented once, string, entry String, equals, q string dot to S t
d String, left and right parenthesis, semicolon, 2 forward slashes,
Convert to a string.
Line 9: indented once, Entry With Date entry, equals, Entry With
Date, colon, colon, From String, left parenthesis, entry String, right
parenthesis, semicolon, 2 forward slashes, Build an entry.
Line 10: indented once, 2 forward slashes, Fill the form with the
entry data.
Line 11: indented once, Set Form From Entry, left parenthesis, entry,
right parenthesis, semicolon."
Back to Figure
"The words in the variable names are merged.
Line 1: indented once, 2 forward slashes, Remember which item is
currently loaded from the list widget.
Line 2: indented once, current Item Loaded, equals, item,
semicolon.
Line 3: indented once, 2 forward slashes, Remember the current
entry value that is loaded.
Line 4: indented once, current Entry, equals, entry, semicolon.
Line 5: right brace."
Back to Figure
"Program code. The words used in the variable names and
keywords are merged. The program contains the following
keywords: void, s t d, string.
Line 1: void Appointment Calendar Window, colon, colon, Set Form
From Entry, left parenthesis, Entry With Date entry, right
parenthesis.
Line 2: left brace. 
Line 3: indented once: Name name, equals sign, entry, dot, Get
Name, left parenthesis, right parenthesis, semicolon. 
Line 4: indented once: Date date, equals sign, entry, dot, Get Date,
left parenthesis, right parenthesis, semicolon. 
Line 5: indented once: Time Of Day time, equals sign, entry, dot,
Get Time, left parenthesis, right parenthesis, semicolon. 

Line 6: blank.
Line 7: indented once: Q String q s, semicolon. 
Line 8: blank. 
Line 9: indented once: q s, equals sign, Q String, colon, colon, from
S t d, String, left parenthesis, name, dot, Get First Name, left
parenthesis, right parenthesis, right parenthesis, semicolon. 
Line 10: indented once: first Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon. 
Line 11: blank. 
Line 12: indented once: q s, equals sign, Q String, colon, from S t d
String, left parenthesis, name, dot, Get Middle Name, left
parenthesis, right parenthesis, right parenthesis, semicolon. 
Line 13: indented once: middle Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon. 
Line 14: blank.
Line 15: indented once: q s, equals sign, Q String, colon, colon, from
S t d String, left parenthesis, name, dot, Get Last Name, left
parenthesis, right parenthesis, right parenthesis, semicolon. 
Line 16: indented once: last Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon.
Line 17: blank.
Line 18: indented once: Q Date q date, left parenthesis, date, dot,
Get Year, left parenthesis, right parenthesis, comma, date, dot, Get
Month, left parenthesis, right parenthesis, comma, date, dot, Get
Day, left parenthesis, right parenthesis, right parenthesis, semicolon.
Line 19: indented once: Q Time q time, left parenthesis, time, dot,
Get Hours, left parenthesis, right parenthesis, comma, time, dot,
Get Minutes, left parenthesis, right parenthesis, comma, time, dot,
Get Seconds, left parenthesis, right parenthesis, right parenthesis,
semicolon. 
Line 20: indented once: Q Date Time q date time, left parenthesis, q
date, comma, q time, right parenthesis, semicolon. 
Line 21: indented once: time Of Day Time, hyphen, right angled
bracket, set Date Time, left parenthesis, q date time, right
parenthesis, semicolon. 
Line 22: right brace."
Back to Figure

"Program code. The words used in the variable names and
keywords are merged. The program contains the following
keywords: void, if, return, s t d, string. 
Line 1: void Appointment Calendar Window, colon, colon, Handle
Save Button Clicked Event, left parenthesis, right parenthesis. 
Line 2: left brace. 
Line 3: indented once: message Label, hyphen, right angled bracket,
set Text, left parenthesis, double quotes, double quotes, right
parenthesis, semicolon, 2 forward slashes, Clear any existing
message. 
Line 4: indented once: 2 forward slashes, Handle case of an empty
field.
Line 5: indented once: if, left parenthesis, Are Any Form Fields
Empty, left parenthesis, 2 right parentheses.
Line 6: indented once: left brace.
Line 7: indented twice: message Label, hyphen, right angled
bracket, set Text, left parenthesis, double quotes, All form fields
must be filled in. Nothing.
Line 8: saved, dot, double quotes, right parenthesis, semicolon. 
Line 9: indented twice: return, semicolon. 
Line 10: indented once: right brace.
Line 11: indented once: 2 forward slashes, Get the validated entry.
Line 12: indented once: Entry With Date new Entry, equals sign, Get
Entry From Form, left parenthesis, right parenthesis, semicolon. 
Line 13: indented once: 2 forward slashes, Handle case of nothing
changed.
Line 14: indented once: if, left parenthesis, new Entry, dot,
Compared To, left parenthesis, current Entry, right parenthesis, 2
equals signs, SAME, right parenthesis.
Line 15: indented once: left brace.
Line 16: indented twice: message Label, hyphen, right angled
bracket, set Text, left parenthesis. 
Line 17: indented thrice: double quotes, There are no changes to
this appointment, dot, Nothing saved, dot, double quotes, right
parenthesis, semicolon. 
Line 18: indented twice: return, semicolon. 
Line 19: indented once: right brace. 
Line 20: indented once: 2 forward slashes, Process valid changed
entry.

Line 21: indented once: 2 forward slashes, Replace the old entry by
calling Get Entry and Insert Entry.
Line 22: indented once: calendar, dot, Get Entry, left parenthesis,
current Entry, dot, Get Name, left parenthesis, right parenthesis,
comma, current Entry, dot, Get Date, left parenthesis, 2 right
parentheses, semicolon. 
Line 23: indented once: calendar, dot, Insert Entry, left parenthesis,
new Entry, right parenthesis, semicolon. 
Line 24: indented once: 2 forward slashes, Update the text of the
currently loaded item to the new entry.
Line 25: indented once: Name name, equals sign, new Entry, dot,
Get Name, left parenthesis, right parenthesis, semicolon. 
Line 26: indented once: string display Name, equals sign, name, dot,
Get First Name, left parenthesis, right parenthesis, plus, double
quotes, double quotes, plus, name, dot, Get Last Name, left
parenthesis, right parenthesis, semicolon. 
Line 27: indented once: Q String q name, equals sign, Q String,
colon, colon, from S t d String, left parenthesis, display Name, right
parenthesis, semicolon. 
Line 28: indented once: current Item Loaded, hyphen, left angled
bracket, set Text, left parenthesis, q name, right parenthesis,
semicolon. 
Line 29: indented once: 2 forward slashes, Store the new entry
string in the currently loaded list widget item.
Line 30: indented once: string entry String, equals sign, new Entry,
dot, To String, left parenthesis, right parenthesis, semicolon. 
Line 31: indented once: Q String q string, equals sign, Q String,
colon, colon, from S t d String, left parenthesis, entry String, right
parenthesis, semicolon. 
Line 32: indented once: Q Variant entry Data, left parenthesis, q
string, right parenthesis, semicolon. 
Line 33: indented once: current Item Loaded, hyphen, right angled
bracket, set Data, left parenthesis, Q t, colon, colon, User Role,
comma, entry Data, right parenthesis, semicolon."
Back to Figure
Program code. The words used in the variable names are merged.
Line 1; indented once: 2 forward slashes. Remember which item is

currently loaded from the list widget.
Line 2; indented once: current Item Loaded, equals, item,
semicolon.
Line 3; indented once: 2 forward slashes. Remember the current
entry value that is loaded.
Line 4; indented once: current Entry, equals, entry, semicolon.
Line 5: right brace.
Back to Figure
"Program code. The words in the variable names are merged.
Line 1: Entry With Date, Appointment Calendar Window, colon,
colon, Get Entry From Form, left and right parenthesis.
Line 2: Left brace.
Line 3: indented once, 2 forward slashes, Get the parts of the name
from the form and construct a Name Value.
Line 4: indented once, string first Name, equals, first Name Line
Edit, minus, right angled bracket, text, left and right parenthesis, dot,
to S t d String, left and right parenthesis, semicolon.
Line 5: indented once, string middle Name, equals, middle Name
Line Edit, minus, right angled bracket, text, left and right
parenthesis, dot, to S t d String, left and right parenthesis,
semicolon.
Line 6: indented once, string last Name, equals, last Name Line Edit,
minus, right angled bracket, text, left and right parenthesis, dot, to S
t d String, left and right parenthesis, semicolon.
Line 7: indented once, Name name, left parenthesis, first Name
comma, middle Name comma, last Name, right parenthesis,
semicolon.
Line 8: indented once, 2 forward slashes, Get the date and time
from the widget.
Line 9: indented once, Q Date, q date, equals, time Of Day Time,
minus, right angled bracket, date, left and right parenthesis,
semicolon.
Line 10: indented once, Q Time, q time, equals, time Of Day Time,
minus, right angled bracket, time, left and right angled bracket,
semicolon.
Line 11: indented once, 2 forward slashes, Get parts of date and
time from Q t types to build Date and.

Line 12: Time Of Day values.
Line 13: indented once, Date date, equals, Date, left parenthesis, q
date dot month, left and right parenthesis, comma, q date dot day,
left and right parenthesis, comma, q date dot year, left and right
parenthesis, right parenthesis, semicolon.
Line 14: indented once, Time Of Day time, equals, Time Of Day, left
parenthesis, q time dot hour, left and right parenthesis, comma, q
time dot minute, left and right parenthesis, comma, q time, end
period.
Line 15: second, left and right parenthesis, right parenthesis,
semicolon.
Line 16: indented once, 2 forward slashes, Build Entry With Date
from Date comma, Time Of Day comma, and Name values.
Line 17: indented once, Entry With Date, entry, left parenthesis, date
comma, time comma, name, right parenthesis, semicolon.
Line 18: indented once, return entry, semicolon.
Line 19: right brace."
Back to Figure
"Line 1, void Appointment Calendar Window, 2 colon symbols,
Initialize Event Handlers, left parenthesis, right parenthesis.
Line 2, left brace.
Line 3, indented once, 2 forward slash, Connect events to their
handlers, left parenthesis, signals to their slots, right parenthesis.
Line 4, indented once, connect, left parenthesis, name List Widget
comma, SIGNAL, left parenthesis, item Clicked, left parenthesis, Q
List Widget Item, asterisk, 2 right parenthesis comma, this comma.
Line 5, indented five times, SLOT, left parenthesis, Handle Entry
Item Clicked Event, left parenthesis, Q List Widget Item asterisk, 3
right parenthesis, semicolon.
Line 6, blank line.
Line 7, indented once, connect, left parenthesis, save button
comma, SIGNAL, left parenthesis, clicked, left parenthesis, 2 right
parenthesis, comma, this comma.
Line 8, indented five times, SLOT, left parenthesis, Handle Save
Button Clicked Event, left parenthesis, 3 right parenthesis,
semicolon.
Line 9, blank line.

Line 10, indented once, connect, left parenthesis, exit Button
comma, SIGNAL, left parenthesis, clicked, 2 right parenthesis
comma, this comma.
Line 11, indented five times, SLOT, left parenthesis, Handle Exit
Button Clicked Event, left parenthesis, 3 right parenthesis,
semicolon.
Line 12, right brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: include, if, else,
return.
Line 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, 2 forward slash, IMPLEMENTATION FILE for class Entry
With Date.
Line 3, 2 forward slash followed by asterisk till the end of the line.
Line 4, blank line.
Line 5, hashtag include, double quotes, Entry With Date dot h,
double quotes.
Line 6, hashtag include, left angled bracket, s stream, right angled
bracket.
Line 7, blank line.
Line 8, Entry With Date, 2 colon symbols, entry With Date, left
parenthesis, right parenthesis, left brace, right brace, semicolon.
Line 9, blank line.
Line 10, 2 forward slash followed by asterisks till the end of the line.
Line 11, blank line.
Line 12, Entry With Date, 2 colon symbols, Entry With Date, left
parenthesis, Date in it Date comma, Time of Day in it Time comma,
Name in it Name, right parenthesis.
Line 13, indented twice, colon, Entry, left parenthesis, in it Name dot
Get First Name, left parenthesis, right parenthesis comma, in it
Name dot Get Middle Name, left parenthesis, right parenthesis
comma.
Line 14, indented six times, in it Name dot Get Last Name, left
parenthesis, right parenthesis comma, in it Time dot Get Hours, left
parenthesis, right parenthesis comma, in it Time dot Get Minutes,
left parenthesis, right parenthesis comma.

Line 15, indented six times, in it Time dot Get Seconds, left
parenthesis, 2 right parenthesis.
Line 16, left brace.
Line 17, indented once, date equals, in it Date, semicolon.
Line 18, right brace.
Line 19, blank line.
Line 20, 2 forward slash followed by asterisks till the end of the line.
Line 21, Date Entry With Date, 2 colon symbols, Get Date, left
parenthesis, right parenthesis, const, left brace, return date,
semicolon, right brace.
Line 22, blank line.
Line 23, 2 forward slash followed by asterisks till the end of the line.
Line 24, Relation Type Entry With Date, 2 colon symbols, Compared
To, left parenthesis, Entry With Date other Date, right parenthesis,
const.
Line 25, left brace.
Line 26, indented once, if, left parenthesis, Get Date, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Date dot Get Date, left parenthesis, 2 right parenthesis, 2
equal to symbols SAME, 2 ampersand symbols.
Line 27, indented three times, Get Name, left parenthesis, right
parenthesis, dot, Compared To, left parenthesis, other Date dot Get
Name, left parenthesis, 2 right parenthesis, 2 equal to symbols,
SAME, right parenthesis.
Line 28, indented twice, return SAME, semicolon.
Line 29, indented once, else if, left parenthesis, Get Date, left
parenthesis, right parenthesis, dot, Compared To, left parenthesis,
other Date dot Get Date, left parenthesis, 2 right parenthesis, 2
equal to symbol, BEFORE, right parenthesis.
Line 30, indented twice, return BEFORE, semicolon.
Line 31, indented once, else.
Line 32, indented twice, return AFTER, semicolon.
Line 33, right brace.
Line 34, blank line.
Line 35, string Entry With Date, 2 colon symbols, To String, left
parenthesis, right parenthesis, const.
Line 36, left brace.
Line 37, indented once, o string stream o s s, semicolon.
Line 38, indented once, Name name equals, Get Name, left

parenthesis, right parenthesis, semicolon.
Line 39, indented once, Date date equals, Get Date, left
parenthesis, right parenthesis, semicolon.
Line 40, indented once, Time of Day time equals, Get Time, left
parenthesis, right parenthesis, semicolon.
Line 41, blank line.
Line 42, indented once, o s s, 2 left angled brackets, name dot Get
First Name, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, name dot Get Middle Name, left parenthesis, right
parenthesis, 2 left angled brackets, double quotes, blank space,
double quotes.
Line 43, indented three times, 2 left angled brackets, name dot Get
Last Name, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes, semicolon.
Line 44, blank line.
Line 45, indented once, o s s, 2 left angled brackets, date dot Get
Month, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, blank space, double quotes, 2 left angled brackets,
date dot Get Day, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, date dot Get Year, left parenthesis, right parenthesis.
Line 46, indented three times, 2 left angled brackets, double quotes,
blank space, double quotes, semicolon.
Line 47, blank line.
Line 48, indented once, o s s, 2 left angled brackets, time dot Get
Hours, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, blank space, double quotes, 2 left angled brackets,
time dot Get Minutes, left parenthesis, right parenthesis, 2 left
angled brackets, double quotes, blank space, double quotes.
Line 49, indented three times, 2 left angled brackets, time dot Get
Seconds, left parenthesis, right parenthesis, semicolon.
Line 50, blank line.
Line 51, indented once, return o s s dot s t r, left parenthesis, right
parenthesis, semicolon.
Line 52, right brace.
Line 53, blank line.
Line 54, Entry With Date Entry With Date, 2 colon symbols, From
String, left parenthesis, string entry string, right parenthesis.

Line 55, left brace.
Line 56, indented once, i string stream i s s, left parenthesis, entry
String, right parenthesis, semicolon."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: string, int, return,
include, class, public, private.
Line 1, indented once, string first comma, middle comma, last
semicolon.
Line 2, indented once, int month comma, day comma, year,
semicolon.
Line 3, indented once, int hour comma, minute comma, second,
semicolon.
Line 4, blank line.
Line 5, indented once, i s s, 2 right angled brackets, first, 2 right
angled bracket, middle, 2 right angled brackets, last, semicolon.
Line 6, indented once, i s s, 2 right angled brackets, month, 2 right
angled bracket, day, 2 right angled brackets, year, semicolon.
Line 7, indented once, i s s, 2 right angled brackets, hour, 2 right
angled bracket, minute, 2 right angled brackets, second, semicolon.
Line 8, blank line.
Line 9, indented once, Date date, left parenthesis, month comma,
day comma, year, right parenthesis, semicolon.
Line 10, indented once, Time of Day time, left parenthesis, hour
comma, minute comma, second, right parenthesis, semicolon.
Line 11, indented once, Name name, left parenthesis, first comma,
middle comma, last, right parenthesis, semicolon.
Line 12, blank line.
Line 13, Entry With Date entry, left parenthesis, Date comma, time
comma, name, right parenthesis, semicolon.
Line 14, blank line.
Line 15, indented once, return entry, semicolon.
Line 16, right brace.
Line 17, blank line.
Line 18, 2 forward slash followed by asterisks till the end of the line.
Line 19, 2 forward slash, SPECIFICATION FILE for class,
Appointment Calendar Window.

Line 20, 2 forward slash, This class inherits from Q Main Window.
Line 21, 2 forward slash followed by asterisks till the end of the line.
Line 22, blank line.
Line 23, hashtag include, left angled bracket, Q Main Window, right
angled bracket.
Line 24, hashtag include, left angled bracket, Q t Widgets, right
angled bracket.
Line 25, blank line.
Line 26, hashtag include, double quotes, Appointment Calendar dot
h, double quotes.
Line 27, class Appointment Calendar Window, colon, public Q Main
Window.
Line 28, left brace.
Line 29, Q underscore OBJECT.
Line 30, blank line.
Line 31, public, colon.
Line 32, indented once, Appointment Calendar Window, left
parenthesis, Appointment Calendar ampersand calendar In it
comma, 2 forward slash, Constructor.
Line 33, indented 16 times, Q Widget asterisk parent equals, null p t
r, right parenthesis, semicolon.
Line 34, indented once, tilde symbol, Appointment Calendar Window,
left parenthesis, right parenthesis, semicolon, 2 forward slash,
Destructor.
Line 35, blank line.
Line 36, private, colon.
Line 37, indented once, 2 forward slash, G U I state.
Line 38, Appointment Calendar ampersand, calendar, semicolon.
Line 39, blank line.
Line 40, indented once, 2 forward slash, G U I widgets.
Line 41, indented once, Q Label asterisk, first Name Label,
semicolon.
Line 42, indented once, Q Line Edit asterisk first Name Line Edit,
semicolon.
Line 43, blank line.
Line 44, indented once, Q Label asterisk middle Name Label,
semicolon.
Line 45, indented once, Q Line Edit asterisk middle Name Line Edit,
semicolon.

Line 46, blank line.
Line 47, indented once, Q Label asterisk last Name Label,
semicolon.
Line 48, indented once, Q Line Edit asterisk last Name Line Edit,
semicolon.
Line 49, blank line.
Line 50, indented once, Q Label asterisk time of Day Label,
semicolon.
Line 51, indented once, Q Date Time Edit asterisk time of Day Time,
semicolon.
Line 52, blank line.
Line 53, Q Push Button asterisk save Button, semicolon.
Line 54, Q Push Button asterisk exit Button, semicolon.
Line 55, blank line.
Line 56, Q Label asterisk, entries List Label, semicolon.
Line 57, Q List Widget asterisk, name List Widget, semicolon.
Line 58, blank line.
Line 59, indented once, Q Label asterisk message Label,
semicolon."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: void, include.
Line 1, indented once, 2 forward slash, G U I initialization methods.
Line 2, indented once, Q Widget asterisk, Build List Widget, left
parenthesis, right parenthesis, semicolon.
Line 3, indented once, Q Widget asterisk, Build Form Widget, left
parenthesis, right parenthesis, semicolon.
Line 4, indented once, Q Widget asterisk Build Buttons Widget, left
parenthesis, right parenthesis, semicolon.
Line 5, indented once, Q Widget asterisk Build Main Widget, left
parenthesis, Q Widget asterisk entries Widget comma, Q Widget
asterisk form Widget comma.
Line 6, indented 14 times, Q Widget asterisk, buttons Widget, right
parenthesis, semicolon.
Line 7, blank line.
Line 8, indented once, 2 forward slash, Remembers the currently
loaded item in the form dot.

Line 9, indented once, Q List Widget item asterisk, current Item
Loaded, semicolon.
Line 10, indented once, Entry With Date, curr net Entry, semicolon.
Line 11, blank line.
Line 12, indented once, 2 forward slash, Initializes the G U I list
display and event handlers.
Line 13, indented once, void Load List Widget, left parenthesis, right
parenthesis, semicolon.
Line 14, indented once, void Initialize Event Handlers, left
parenthesis, right parenthesis, semicolon.
Line 15, blank line.
Line 16, indented once, 2 forward slash, Utility methods.
Line 17, indented once, bool Are Any Form Fields Empty, left
parenthesis, right parenthesis, semicolon.
Line 18, indented once, Entry With Date, Get Entry From Form, left
parenthesis, right parenthesis, semicolon.
Line 19, indented once, void Set Form From Entry, left parenthesis,
Entry With Date entry, right parenthesis, semicolon.
Line 20, indented once, void Save Calendar To File, left parenthesis,
right parenthesis, semicolon.
Line 21, blank line.
Line 22, 2 forward slash, Event handlers.
Line 23, private slots, colon.
Line 24, indented once, void Handle Entry Item Clicked Event, left
parenthesis, Q List Widget Item asterisk item, right parenthesis,
semicolon.
Line 25, indented once, void Handle Save Button Clicked Entry, left
parenthesis, right parenthesis, semicolon.
Line 26, indented once, void Handle Exit Button Clicked Event, left
parenthesis, right parenthesis, semicolon.
Line 27, right brace, semicolon.
Line 28, blank line.
Line 29, indented once, 2 forward slash followed by asterisks till the
end of the line.
Line 30, indented once, 2 forward slash, IMPLEMENTATION FILE
for class Appointment Calendar Window.
Line 31, indented once, 2 forward slash followed by asterisks till the
end of the line.
Line 32, blank line.

Line 33, hashtag include, double quotes, Appointment Calendar
Window dot h, double quotes.
Line 34, blank line.
Line 35, hashtag include, double quotes, Relation Type dot h, double
quotes.
Line 36, blank line.
Line 37, Appointment Calendar Window, 2 colon symbols,
Appointment Calendar Window, left parenthesis.
Line 38, indented twice, Appointment Calendar ampersand calendar
In it comma, Q Widget asterisk parent, right parenthesis.
Line 39, indented three times, colon, Q Main Window, left
parenthesis, parent, right parenthesis comma, calendar, left
parenthesis, calendar In it, right parenthesis.
Line 40, left brace.
Line 41, indented once, Q Widget asterisk button Widget equals,
Build Buttons Widget, left parenthesis, right parenthesis, semicolon,
2 forward slash, Create the buttons.
Line 42, indented once, Q Widget asterisk form Widget equals, Build
Form Widget, left parenthesis, right parenthesis, semicolon, 2
forward slash, Create the form.
Line 43, indented once, Q Widget asterisk, list Widget equals, Build
List Widget, left parenthesis, right parenthesis, semicolon, 2 forward
slash, Create the list.
Line 44, indented once, 2 forward slash, Combine them into the
main Widget.
Line 45, indented once, Q Widget asterisk amin Widget equals, Build
Main Widget, left parenthesis, list Widget comma, form Widget
comma, button Widget, right parenthesis, semicolon.
Line 46, indented once, 2 forward slash, Fill the list with data and set
up event handlers.
Line 47, indented once, Load List Widget, left parenthesis, right
parenthesis, semicolon.
Line 48, indented once, Initialize Event handlers, left parenthesis,
right parenthesis, semicolon.
Line 49, indented once, 2 forward slash, Finally comma, set the
main widget and window title.
Line 50, indented once, set Central Widget, left parenthesis, main
Widget, right parenthesis, semicolon.
Line 51, indented once, set Window Title, left parenthesis, double

quotes, Calendar Appointment App, double quotes, right
parenthesis, semicolon.
Line 52, blank space.
Line 53, Q Widget, double quotes, Appointment Calendar Window, 2
colon symbols, Build Buttons Widget, left parenthesis, right
parenthesis.
Line 54, left brace.
Line 55, indented once, Q Widget asterisk buttons Widget equals,
new Q Widget, semicolon, 2 forward slash, Make an empty widget.
Line 56, indented once, Q H Box Layout asterisk buttons Layout,
new Q H Box Layout, semicolon, 2 forward slash, Make an empty
layout object.
Line 57, indented once, buttons Widget, hyphen, right angled
bracket, set Layout, buttons Layout, right parenthesis, semicolon, 2
forward slash, Put the layout in the widget."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: return.
Line 1, indented once, save Button equals, new Q Push Button, left
parenthesis, double quotes, Save, double quotes, semicolon, 2
forward slash, Make a Save button.
Line 2, indented once, exit Button equals, new Q Push Button, left
parenthesis, double quotes, Exit, double quotes, semicolon, 2
forward slash, Make an Exit button.
Line 3, blank line.
Line 4, indented once, buttons Layout, hyphen, right angled bracket,
add Widget, left parenthesis, save Button, right parenthesis,
semicolon, 2 forward slash, Put Save button is layout.
Line 5, indented once, buttons Layout, hyphen, right angled bracket,
add Widget, left parenthesis, exit Button, right parenthesis,
semicolon, 2 forward slash, Put Exit button in layout.
Line 6, blank line.
Line 7, indented once, return buttons Widget, semicolon, 2 forward
slash, Return the whole thing.
Line 8, right brace.
Line 9, blank line.
Line 10, Q Widget asterisk Appointment Calendar Window, 2 colon

symbols, Build Form Widget, left parenthesis, right parenthesis.
Line 11, left brace.
Line 12, indented once, 2 forward slash, Create a wrapper widget
and layout comma, then connect them.
Line 13, indented once, Q Widget asterisk form Widget equals, new
Q Widget, semicolon.
Line 14, indented once, Q Grid Layout, asterisk form Layout equals,
new Q Grid Layout, semicolon.
Line 15, indented once, form Widget, hyphen, right angled bracket,
set Layout, left parenthesis, form Layout, right parenthesis,
semicolon.
Line 16, indented once, 2 forward slash, Create three labels and
corresponding text boxes.
Line 17, indented once, first Name Label equals, new Q Label, left
parenthesis, double quotes, First Name, double quotes, right
parenthesis, semicolon.
Line 18, indented once, first Name Line Edit equals, new Q Line
Edit, semicolon.
Line 19, indented once, middle Name Label equals, new Q Label,
left parenthesis, double quotes, Middle Name, double quotes, right
parenthesis, semicolon.
Line 20, indented once, middle Name Line Edit equals, new Q Line
Edit, semicolon.
Line 21, indented once, last name Label equals, new Q Label, left
parenthesis, double quotes, Last Name, double quotes, right
parenthesis, semicolon.
Line 22, indented once, last Name Line Edit equals, new Q Line Edit,
semicolon.
Line 23, indented once, 2 forward slash, Create a label and a widget
with the current date and time.
Line 24, indented once, time of Day Label equals, new Q Label, left
parenthesis, double quotes, Time of Day, double quotes, right
parenthesis, semicolon.
Line 25, indented once, time of Day Time equals, new Q Date Time
Edit, left parenthesis, Q Date Time, 2 colon symbols, current Date
Time, left parenthesis, 2 right parenthesis, semicolon.
Line 26, indented once, 2 forward slash, Set the formatting of the
date and time widget.
Line 27, indented once, time of Day Time, hyphen, right angled

bracket, set Display Format, left parenthesis, double quotes, M M,
forward slash, d d, forward slash, y y y y, h colon, m colon, s a p,
double quotes, right parenthesis, semicolon.
Line 28, indented once, time of Day Time, hyphen, right angled
bracket, set Calendar Popup, left parenthesis, true, right
parenthesis, semicolon.
Line 29, indented once, 2 forward slash, Add the pieces to the layout
using row comma, column comma, left alignment.
Line 30, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, first Name Label comma, 0 comma, 0
comma, Q t, 2 colon symbols, Align Left, right parenthesis,
semicolon.
Line 31, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, first Name Line Edit comma, 0 comma,
1 comma, Q t, 2 colon symbols, Align Left, right parenthesis,
semicolon.
Line 33, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, middle Name Label comma, 1 comma,
0 comma, Q t, 2 colon symbols, Align Left, right parenthesis,
semicolon.
Line 34, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, middle Name Line Edit comma, 1
comma, 1 comma, Q t, 2 colon symbols, Align Left, right
parenthesis, semicolon.
Line 35, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, last Name Label comma, 2 comma, 0
comma, Q t, 2 colon symbols, Align Left, right parenthesis,
semicolon.
Line 36, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, last Name Line Edit comma, 2 comma,
0 comma, Q t, 1 colon symbols, Align Left, right parenthesis,
semicolon.
Line 37, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, time of Day Label comma, 3 comma, 0
comma, Q t, 2 colon symbols, Align Left, right parenthesis,
semicolon.
Line 38, indented once, form Layout, hyphen, right angled bracket,
add Widget, left parenthesis, time of Day Time comma, 3 comma, 1
comma, Q t, 2 colon symbols, Align Left, right parenthesis,

semicolon.
Line 39, blank line.
Line 40, indented once, return form Widget, semicolon.
Line 41, right brace.
Line 42, blank line.
Line 43, Q Widget asterisk Appointment Calendar Window, 2 colon
symbols, Build List Widget, left parenthesis, right parenthesis.
Line 44, left brace.
Line 45, indented once, 2 forward slash, Create a wrapper widget
and layout comma, time connect them.
Line 46, indented once, Q Widget asterisk last Widget equals, new
Q Widget, semicolon.
Line 47, indented once, Q V Box Layout, asterisk list Layout equals,
new Q V Box Layout semicolon.
Line 48, indented once, list Widget, hyphen, right angled bracket, set
Layout, left parenthesis, list Layout, right parenthesis, semicolon.
Line 49, indented once, 2 forward slash, Create a label and a widget
to hold a list.
Line 50, indented once, name List Widget equals, new Q List
Widget, semicolon.
Line 51, indented once, entries List Label equals, new Q Label, left
parenthesis, double quotes, Entries, double quotes, right
parenthesis, semicolon.
Line 52, indented once, 2 forward slash, Add the pieces to the layout
vertically.
Line 53, indented once, list Layout, hyphen, right angled bracket,
add Widget, left parenthesis, entries List Label, right parenthesis,
semicolon.
Line 54, indented once, list Layout, hyphen, right angled bracket,
add Widget, left parenthesis, name List Widget, semicolon.
Line 55, blank line.
Line 56, indented once, return list Widget, semicolon.
Line 57, right brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: return, void, while,
string.

Line 1, Q Widget asterisk, Appointment Calendar Window, 2 colon
symbols, Build Main Widget, left parenthesis, Q Widget asterisk
entries Widget comma.
Line 2, indented 26 times, Q Widget asterisk form Widget comma.
Line 3, indented 16 times, Q Widget asterisk buttons Widget, right
parenthesis.
Line 4, left brace.
Line 5, indented once, 2 forward slash, Create a wrapper widget and
layout comma, then connect them.
Line 6, indented once, Q Widget asterisk main Widget equals, new
Q Widget, semicolon.
Line 7, indented once, Q Grid Layout asterisk main Layout equals,
new Q Grid Layout, semicolon.
Line 8, indented once, main Widget, hyphen, right angled bracket,
set Layout, left parenthesis, main Layout, right parenthesis,
semicolon.
Line 9, indented once, 2 forward slash, Create an empty label.
Line 10, indented once, message Label equals, new Q Label, left
parenthesis, double quotes, double quotes, right parenthesis,
semicolon.
Line 11, indented once, 2 forward slash, Add the main pieces to the
layout using row comma column.
Line 12, indented once, main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, entries Widget comma, 0 comma, 0,
right parenthesis, semicolon.
Line 13, indented once, main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, form Widget comma, 0, comma, 1,
right parenthesis, semicolon.
Line 14, indented once, main Layout, hyphen, right angled bracket,
left parenthesis, buttons Widget comma, 1 comma, 1, right
parenthesis, semicolon.
Line 15, indented once, 2 forward slash, Add the label to the layout
using coordinates comma, spans comma, center alignment.
Line 16, indented once, main Layout, hyphen, right angled bracket,
add Widget, left parenthesis, message Label comma, 2 comma, 0
comma, 1 comma, 2 comma, Q t, 2 colon symbols, Align center,
right parenthesis, semicolon.
Line 17, blank line.
Line 18, return main Widget, semicolon.

Line 19, blank line.
Line 20, indented once, return main Widget, semicolon.
Line 21, blank line.
Line 22, void Appointment Calendar Window, 2 colon symbols, Load
List Widget, left parenthesis, right parenthesis.
Line 23, left brace.
Line 24, indented once, calendar dot Reset List, left parenthesis,
right parenthesis, semicolon.
Line 25, indented once, while, left parenthesis, calendar dot Has
Next, left parenthesis, 2 right parenthesis, left brace.
Line 26, indented twice, Entry With Date equals, calendar dot Get
Next Item, left parenthesis, right parenthesis, semicolon.
Line 27, blank line.
Line 28, indented once, Q List Widget Item asterisk item equals,
new Q List Widget Item, semicolon.
Line 29, blank line.
Line 30, indented twice, Name name equals, entry dot Get Name,
left parenthesis, right parenthesis, semicolon.
Line 31, indented twice, string display Name equals, name dot Get
First Name, left parenthesis, right parenthesis, plus, double quotes,
blank space, double quotes, plus, name dot Get Last Name, left
parenthesis, right parenthesis, semicolon.
Line 32, indented twice, Q String q name equals, Q String, 2 colon
symbols, from S t d, String, left parenthesis, display Name, right
parenthesis, semicolon.
Line 33, indented twice, item, hyphen, right angled bracket, set Text,
left parenthesis, q name, right parenthesis, semicolon.
Line 34, blank line.
Line 35, indented twice, name List Widget, hyphen, right angled
bracket, add Item, left parenthesis, item, right parenthesis,
semicolon.
Line 36, indented once, right brace.
Line 37, right brace.
Line 38, blank line.
Line 39, void Appointment Calendar Window, 2 colon symbols,
Initialize Event Handlers, left parenthesis, right parenthesis.
Line 40, left brace.
Line 41, indented once, 2 forward slash, Connect events to their
handlers, left parenthesis, signals to their slots, right parenthesis.

Line 42, indented once, connect, left parenthesis, name List Widget
comma, SIGNAL, left parenthesis, item clicked, left parenthesis, Q
List Widget Item asterisk, 2 right parenthesis comma, this comma.
Line 43, indented five times, SLOT, left parenthesis, Handle Entry
Item Clicked Event, left parenthesis, Q List Widget Item asterisk, 3
right parenthesis, semicolon.
Line 44, blank line.
Line 45, indented once, connect, left parenthesis, save Button
comma, SIGNAL, left parenthesis, clicked, left parenthesis, 2 right
parenthesis comma, this comma.
Line 46, indented five times, SLOT, left parenthesis, Handle Save
Button Clicked Event, left parenthesis, 3 right parenthesis,
semicolon.
Line 47, blank line.
Line 48, indented once, connect, left parenthesis, exit Button
comma, SIGNAL, left parenthesis, clicked, left parenthesis, 2 right
parenthesis comma, this comma.
Line 49, indented five times, LSOT, left parenthesis, Handle Exit
Button Clicked Event, left parenthesis, 2 right parenthesis,
semicolon.
Line 50, right brace.
Line 51, void Appointment Calendar Window, 2 colon symbols,
Handle Exit Button Clicked Event, left parenthesis, right parenthesis.
Line 52, left brace.
Line 53, indented once, this, hyphen close, left parenthesis, right
parenthesis, semicolon.
Line 54, right brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: void, if, return, string.
Line 1, void Appointment Calendar Window, 2 colon symbols, Handle
Entry Item Clicked Event, left parenthesis.
Line 2, indented four times, Q List Widget Item asterisk item, right
parenthesis.
Line 3, left brace.
Line 4, indented once, message Label, hyphen, Label, set Text, left
parenthesis, double quotes, double quotes, right parenthesis,

semicolon.
Line 5, blank line.
Line 6, indented once, 2 forward slash, Convert the data from the
item into an entry.
Line 7, indented once, Q Variant entry Data equals, item, hyphen,
data, left parenthesis, Q t, 2 colon symbols, User Role, right
parenthesis, semicolon, 2 forward slash, Get the data as a Q
Variant.
Line 8, indented once, Q String q string equals, entry Data dot to
String, left parenthesis, right parenthesis, semicolon, 2 forward
slash, Convert to a Q String.
Line 9, indented once, string entry String equals, q string dot to S t d
String, left parenthesis, right parenthesis, semicolon, 2 forward
slash, Convert to a string.
Line 10, indented once, Entry With Date entry equals, Entry With
Date, 2 colon symbols, From String, left parenthesis, entry String,
right parenthesis, semicolon, 2 forward slash, Build an entry.
Line 11, indented once, 2 forward slash, Fill the form with the entry
data.
Line 12, indented once, Set Form From Entry, left parenthesis, right
parenthesis, semicolon.
Line 13, indented once, 2 forward slash, Remember the item loaded
from the list widget.
Line 14, indented once, current Item Loaded equals, item,
semicolon.
Line 15, indented once, 2 forward slash, Remember the current
entry that is loaded dot.
Line 16, indented once, current Entry equals, entry, semicolon.
Line 17, right brace.
Line 18, blank line.
Line 19, void Appointment Calendar Window, 2 colon symbols,
Handle Save Button Clicked Event, left parenthesis, right
parenthesis.
Line 20, left brace.
Line 21, indented once, message Label, hyphen, right angled
bracket, set Text, left parenthesis, double quotes, double quotes,
right parenthesis, semicolon, 2 forward slash, Clear any existing
message.
Line 22, indented once, 2 forward slash, Handle case of an empty

field.
Line 23, indented once, if, left parenthesis, Are Any Form Fields
Empty, left parenthesis, 2 right parenthesis.
Line 24, indented once, left brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: bool, string, if, return,
void, if.
Line 1, bool Appointment Calendar Window, 2 colon symbols, Are
Any Form Fields Empty, left parenthesis, right parenthesis.
Line 2, left brace.
Line 3, indented once, string first Name equals, first Name Line Edit,
hyphen, right angled bracket, text, left parenthesis, right
parenthesis, dot, to S t d String, left parenthesis, right parenthesis,
semicolon.
Line 4, indented once, string middle Name equals, middle Name
Line Edit, hyphen, right angled bracket dot, to S t d String, left
parenthesis, right parenthesis, semicolon.
Line 5, indented once, string last Name equals, last Name Line Edit,
hyphen right angled brackets, text left parenthesis, right parenthesis,
dot, to S t d String, left parenthesis, right parenthesis, semicolon.
Line 6, indented once, if, left parenthesis, first Name, 2 equal to
symbol, double quotes, double quotes, 2 vertical bars, middle Name,
2 equal to symbols, double quotes, double quotes, 2 vertical bars,
last Name, 2 equal to symbols, double quotes, double quotes, right
parenthesis.
Line 7, indented once, left brace.
Line 8, indented twice, return true, semicolon.
Line 9, indented once, right brace.
Line 10, indented once, return false, semicolon.
Line 11, right brace.
Line 12, Entry With Date Appointment Calendar Window, 2 colon
symbols, Get Entry From Form, left parenthesis, right parenthesis.
Line 13, left brace.
Line 14, indented once, 2 forward slash, Get the parts of the name
from the form and construct a Name value.
Line 15, indented once, string first Name equals, first Name Line

Edit, hyphen, right angled bracket, text, left parenthesis, right
parenthesis, dot, to S t d String, left parenthesis, right parenthesis,
semicolon.
Line 16, indented once, string middle Name equals, middle Name
Line Edit, hyphen, right angled bracket, text, left parenthesis, right
parenthesis dot, to S t d String, left parenthesis, right parenthesis,
semicolon.
Line 17, indented once, string last Name equals, last Name Line
Edit, hyphen, right angled bracket, text, left parenthesis, right
parenthesis dot, to S t d, String, left parenthesis, right parenthesis,
semicolon.
Line 18, indented once, Name name, left parenthesis, first Name
comma, middle Name comma, last Name, right parenthesis,
semicolon.
Line 19, indented once, 2 forward slash, Get the date and time from
the widget.
Line 20, indented once, Q Date q date, equals, time of Day Time,
hyphen, right angled bracket, date, left parenthesis, right
parenthesis, semicolon.
Line 21, indented once, Q Time q time equals, time of Day Time,
hyphen, right angled bracket, time, left parenthesis, right
parenthesis, semicolon.
Line 22, indented once, 2 forward slash, Get parts of date and time
from Q t types to build Date and Time of Day Values.
Line 23, indented once, Date date equals, Date, left parenthesis, q
date dot month, left parenthesis, right parenthesis comma, q date
dot day, left parenthesis, right parenthesis comma, q date dot year,
left parenthesis, 2 right parenthesis, semicolon.
Line 24, indented once, Time of Day time equals, Time of Day, left
parenthesis, q time dot hour, left parenthesis, right parenthesis
comma, q time dot minute, left parenthesis, right parenthesis
comma, q time dot second, left parenthesis, 2 right parenthesis,
semicolon.
Line 23, indented once, 2 forward slash, Build Entry With Date from
Date comma, Time of Day comma, and Name values.
Line 24, indented once, Entry With Date entry, left parenthesis, date
comma, time comma, name, right parenthesis, semicolon.
Line 25, blank line.
Line 26, indented once, return entry, semicolon.

Line 27, right brace.
Line 28, void Appointment Calendar Window, 2 colon symbols, Set
Form From Entry, left parenthesis, Entry With Date entry, right
parenthesis.
Line 29, left brace.
Line 30, indented once, Name name equals, entry dot Get Name,
left parenthesis, right parenthesis, semicolon.
Line 31, indented once, Date date equals, entry dot Get Date, left
parenthesis, right parenthesis, semicolon.
Line 32, indented once, Time of Day time equals, entry dot Get
Time, left parenthesis, right parenthesis, semicolon.
Line 33, blank line.
Line 34, Q String q s, semicolon.
Line 35, blank line.
Line 36, indented once, q s equals, Q String, 2 colon symbols, from
S t d String, left parenthesis, name dot Get First Name, left
parenthesis, 2 right parenthesis, semicolon.
Line 37, indented once, first Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon.
Line 38, blank line.
Line 39, indented once, q s equals, Q String, 2 colon symbols, from
S t d string, left parenthesis, name dot Get Middle Name, left
parenthesis, 2 right parenthesis, semicolon.
Line 40, indented once, middle Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon.
Line 41, blank line.
Line 42, indented once, q s equals, Q String, 2 colon symbols, from
S t d, String, left parenthesis, name dot Get Last Name, left
parenthesis, 2 right parenthesis, semicolon.
Line 43, indented once, last Name Line Edit, hyphen, right angled
bracket, set Text, left parenthesis, q s, right parenthesis, semicolon.
Line 44, blank line.
Lien 45, indented once, Q Date q date, left parenthesis, date dot
Get Year, left parenthesis, right parenthesis comma, date dot Get
Month, left parenthesis, right parenthesis comma, date dot Get Day,
left parenthesis, 2 right parenthesis, semicolon.
Line 46, indented once, Q Time q time, left parenthesis, time dot
Get Hours, left parenthesis, right parenthesis comma, time dot Get
Minutes, left parenthesis, right parenthesis comma, time dot Get

Seconds, left parenthesis, 2 right parenthesis, semicolon.
Line 47, indented once, Q Date Time q date time, left parenthesis, q
date comma, q time, right parenthesis.
Line 48, indented once, time of Date Time, hyphen, right angled
bracket, set Date Time, left parenthesis, q date time, right
parenthesis, semicolon.
Line 49, right brace.
Line 50, blank line.
Line 51, void Appointment Calendar Window, 2 colon symbols, Save
Calendar To File, left parenthesis, right parenthesis.
Line 52, left brace.
Line 53, indented once, of stream out File, semicolon.
Line 54, indented once, out File dot open, left parenthesis, double
quotes, Calendar File, double quotes, right parenthesis, semicolon.
Line 55, indented once, if, left parenthesis, exclamation file, out File,
right parenthesis, left brace."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: return, include, using
namespace, int, main, c out, if.
Line 1, indented twice, message Label, hyphen, right angled
bracket, set Text, left parenthesis, double quotes, File not found dot.
Error dot, double quotes, right parenthesis, semicolon.
Line 2, indented twice, return, semicolon.
Line 3, indented once, right brace.
Line 4, indented once, calendar dot Write List To File, left
parenthesis, out File, right parenthesis, semicolon.
Line 5, blank line.
Line 6, indented once, out File dot close, left parenthesis, right
parenthesis, semicolon.
Line 7, right brace.
Line 8, blank line.
Line 9, Appointment Calendar Window, 2 colon symbols, tilde
symbol, Appointment Calendar Window, left parenthesis, right
parenthesis, left brace, right brace.
Line 10, blank line.
Line 11, 2 forward slash followed by asterisks till the end of the line.

Line 12, 2 forward slash, DRIVER for Appointment Calendar G U I
program.
Line 13, 2 forward slash followed by asterisks till the end of the line.
Line 14, blank line.
Line 15, hashtag include, left angled bracket, Q Application, right
angled bracket.
Line 16, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 17, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 18, blank line.
Line 19, hashtag include, double quotes, Appointment Calendar
Window dot h, double quotes.
Line 20, using namespace s t d, semicolon.
Line 21, blank line.
Line 22, int main, left parenthesis, int arg c comma, char asterisk
arg v, left square bracket, right square bracket, right parenthesis.
Line 23, left brace.
Line 24, indented once, Q Application app, left parenthesis, arg c
comma, arg v, right parenthesis.
Line 25, blank line.
Line 26, indented once, if stream in File, semicolon.
Line 27, indented once, in File dot open, left parenthesis, double
quotes, Calendar File, double quotes, right parenthesis, semicolon.
Line 28, indented once, if, left parenthesis, exclamation symbol, in
File, right parenthesis.
Line 29, indented once, left brace.
Line 30, indented twice, c out, 2 left angled brackets, double quotes,
File not found dot, double quotes, 2 left angled brackets, end l,
semicolon.
Line 31, indented twice, return 1, semicolon.
Line 32, indented once, right brace.
Line 33, blank line.
Line 34, indented once, Appointment Calendar calendar, left
parenthesis, in File, right parenthesis, semicolon.
Line 35, indented once, Appointment Calendar Window window, left
parenthesis, calendar, right parenthesis, semicolon.
Line 36, blank line.
Line 37, window dot show, left parenthesis, right parenthesis,

semicolon.
Line 38, blank line.
Line 39, indented once, return app dot exec, left parenthesis, right
parenthesis, semicolon.
Line 40, right brace."
Back to Figure
"Line 1, class Derived Class, colon, public Base Class.
Line 2, left brace.
Line 3, indented once, dot.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, right brace, semicolon."
Back to Figure
"Line 1, Derived Class, 2 colon symbols, Derived Class, left
parenthesis, dot dot dot, right parenthesis.
Line 2, indented twice, Base Class, left parenthesis, arg 1 comma,
arg 2, right parenthesis.
Line 3, left brace.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, indented once, dot.
Line 7, right brace, semicolon."
Back to Figure
"Line 1, Some Class, 2 colon symbols, Some Class, left parenthesis,
dot dot dot, right parenthesis.
Line 2, indented twice, colon, member Object, left parenthesis, arg 1
comma, arg 2, right parenthesis.
Line 3, left brace.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, indented once, dot.
Line 7, right brace."

Back to Figure
"Line 1, class Base Class.
Line 2, left brace.
Line 3, public, colon.
Line 4, indented once, void Print Fields, left parenthesis, right
parenthesis, const, semicolon.
Line 5, indented once, dot.
Line 6, indented once, dot.
Line 7, indented once, dot.
Line 8, right brace, semicolon.
Line 9, blank line.
Line 10, class Derived Class, colon, Base Class.
Line 11, left brace.
Line 12, public, colon.
Line 13, indented once, void New Function, left parenthesis, right
parenthesis, semicolon.
Line 14, indented once, Derived Class, left parenthesis, int Start
Value, right parenthesis, semicolon.
Line 15, indented once, dot.
Line 16, indented once, dot.
Line 17, indented once, dot.
Line 18, right brace, semicolon."
Back to Figure
Line 1: Derived Class, an Object, left parenthesis, 10, right
parenthesis, semicolon. Line 2: and Object, dot, Print Fields, left
parenthesis, right parenthesis, semicolon.
Back to Figure
"Line 1, class Base Class.
Line 2, left brace.
Line 3, public, colon.
Line 4, indented once, void Base Alpha, left parenthesis, right
parenthesis, semicolon.
Line 5, private, colon.
Line 6, indented once, void Base Beta, left parenthesis, right

parenthesis, semicolon.
Line 7, indented once, float base Field, semicolon.
Line 8, right brace, semicolon.
Line 9, blank line.
Line 10, class Derived Class, colon, public Base Class.
Line 11, left brace.
Line 12, public, colon.
Line 13, indented once, void Derived Alpha, left parenthesis, right
parenthesis, semicolon.
Line 14, indented once, void Derived Beta, left parenthesis, right
parenthesis, semicolon.
Line 15, private, colon.
Line 16, indented once, int derived Field, semicolon.
Line 17, right brace, semicolon."
Back to Figure
"Line 1, class Base Class.
Line 2, left brace.
Line 3, public, colon.
Line 4, indented once, virtual void, Base Alpha, left parenthesis, right
parenthesis, semicolon.
Line 5, private, colon.
Line 6, indented once, float base Field, semicolon.
Line 7, right brace, semicolon.
Line 8, blank line.
Line 9, class Derived Class, colon, public Base Class.
Line 10, left brace.
Line 11, public, colon."
Back to Figure
"Line 1, indented once, virtual void Base Alpha, left parenthesis,
right parenthesis, semicolon.
Line 2, private, colon.
Line 3, indented once, int derived Field, semicolon.
Line 4, right brace, semicolon."
Back to Figure

"Line 1, class Test Score.
Line 2, left brace.
Line 3, public, colon.
Line 4, indented once, Test Score, left parenthesis, string name
comma, int score, right parenthesis, semicolon.
Line 5, indented once, string Get Name, left parenthesis, right
parenthesis, const, semicolon.
Line 6, indented once, int Get Score, left parenthesis, right
parenthesis, const, semicolon.
Line 7, private, colon.
Line 8, indented once, string student Name, semicolon.
Line 9, indented once, int student Score, semicolon.
Line 10, right brace, semicolon."
Back to Figure
"Line 1, 2 forward slash, SPECIFICATION FILE, left parenthesis,
phone dot h, right parenthesis.
Line 2, blank line.
Line 3, enum Phone Type, left parenthesis, HOME comma, OFFICE
comma, CALL comma, FAX comma, SMS, right parenthesis,
semicolon.
Line 4, blank line.
Line 5, class Phone.
Line 6, left brace.
Line 7, public, colon.
Line 8, indented once, Phone, left parenthesis, new Area Code
comma, int new Number comma, Phone Type new Type, right
parenthesis, semicolon.
Line 9, indented once, void Write, left parenthesis, right parenthesis,
const, semicolon.
Line 10, private, colon.
Line 11, indented once, int area Code, semicolon.
Line 12, indented once, int number, semicolon.
Line 13, indented once, Phone Type type, semicolon.
Line 14, right brace."
Back to Figure

"Program code. The words used in the variable names are merged.
The program contains the following keywords: class, public.
Line 1, class Computer.
Line 2, left brace.
Line 3, public, colon."
Back to Figure
"Program code. The words used in the variable names are merged.
The program contains the following keywords: string, int, private.
Line 1, indented once, Computer, left parenthesis, string new Name
comma, string new Brand comma, string new Model comma.
Line 2, indented six times, int new Speed comma, string new Serial
comma, int new Number, right parenthesis, semicolon.
Line 3, indented once, string Get Name, left parenthesis, right
parenthesis, const, semicolon.
Line 4, indented once, string Get Brand, left parenthesis, right
parenthesis, const, semicolon.
Line 5, indented once, string Get Model, left parenthesis, right
parenthesis, const, semicolon.
Line 6, indented once, int Get Speed, left parenthesis, right
parenthesis, const, semicolon.
Line 7, indented once, string Get Serial, left parenthesis, right
parenthesis, const, semicolon.
Line 8, indented once, int Get Number, left parenthesis, right
parenthesis, const, semicolon.
Line 9, indented once, void Write, left parenthesis, right parenthesis,
const, semicolon.
Line 10, private, colon.
Line 11, indented once, string name, semicolon.
Line 12, indented once, string brand, semicolon.
Line 13, indented once, string model, semicolon.
Line 14, indented once, int speed, semicolon.
Line 15, indented once, string serial Number, semicolon.
Line 16, indented once, int inventory Number, semicolon.
Line 17, right brace, semicolon."
Back to Figure

"Program code. The words in the keywords, function names, and
variable names are merged. The code contains the following
keywords: const, int, type def, class, public, void, bool, private. 
Line 1: const int MAX underscore LENGTH equals 100, semicolon. 2
forward slashes. Maximum number of components. 
Line 2: type def int Item Type, semicolon. 2 forward slashes. Type of
each component. 
Line 3: blank. 
Line 4: class List. 
Line 5: left brace. 
Line 6: public, colon. 
Line 7, indented once: List, left parentheses, right parentheses,
semicolon. 
Line 8, indented once: 2 forward slashes: Action responsibilities. 
Line 9, indented once: void Insert, left parentheses, Item type item,
right parentheses, semicolon. 
Line 10, indented once: void Delete, left parentheses, Item type
item, right parentheses, semicolon. 
Line 11, indented once: void Reset List, left parentheses, right
parentheses, semicolon. 
Line 12, indented once: Item Type Get Next Item, left parentheses,
right parentheses, semicolon. 
Line 13, indented once: 2 forward slashes. Knowledge
responsibilities. 
Line 14, indented once: int Get Length, left parentheses, right
parentheses, const, semicolon. 
Line 15, indented once: bool Is Empty, left parentheses, right
parentheses, const, semicolon. 
Line 16, indented once: bool Is Full, left parentheses, right
parentheses, const, semicolon. 
Line 17, indented once: bool Is There, left parentheses, Item Type
item, right parentheses, const, semicolon. 
Line 18, indented once: bool Has Next, left parentheses, right
parentheses, const, semicolon. 
Line 19: private, colon. 
Line 20, indented once: int length, semicolon. 
Line 21, indented once: int current Pos, semicolon. 
Line 22, indented once: Item Type data, left bracket, MAX

underscore LENGTH, right bracket, semicolon. 
Line 23: right brace, semicolon."
Back to Figure
"Program code. The words in the function names, and variable
names are merged. The code contains the following keywords:
template, class, public, void, int, bool, private. 
Line 1: template, left angled bracket, class Item Type, right angled
bracket. 
Line 2: class G List. 
Line 3: left brace. 
Line 4: public, colon. 
Line 5, indented once: List, left parentheses, right parentheses,
semicolon. 
Line 6, indented once: 2 forward slashes. Action responsibilities. 
Line 7, indented once: void Insert, left parentheses, Item Type item,
right parentheses, semicolon. 
Line 8, indented once: void Delete, left parentheses, Item Type item,
right parentheses, semicolon. 
Line 9, indented once: void Reset List, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: Item Type Get Next Item, left parentheses,
right parentheses, semicolon. 
Line 11, indented once: 2 forward slashes. Knowledge
responsibilities. 
Line 12, indented once: int Get Length, left parentheses, right
parentheses, const, semicolon. 
Line 13, indented once: bool Is Empty, left parentheses, right
parentheses, const, semicolon. 
Line 14, indented once: bool Is Full, left parentheses, right
parentheses, const, semicolon. 
Line 15, indented once: bool Is There, left parentheses, Item Type
item, right parentheses, const, semicolon. 
Line 16, indented once: bool Has Next, left parentheses, right
parentheses, const, semicolon. 
Line 17, indented once: private, colon. 
Line 18, indented once: int length, semicolon. 
Line 19, indented once: int current Pos, semicolon. 

Line 20, indented once: Item Type data, left square bracket, MAX
underscore LENGTH, right square bracket, semicolon. 
Line 21: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: int, float, string. 
Line 1: 2 forward slashes. Client code. 
Line 2: G List, left angled bracket, int, right angled bracket, list 1,
semicolon. 
Line 3: G List, left angled bracket, float, right angled bracket, list 2,
semicolon. 
Line 4: G List, left angled bracket, string, right angled bracket, list 3,
semicolon."
"Line 1: list 1 dot Insert, left parentheses, 356, right parentheses,
semicolon. 
Line 2: list 2 dot Insert, left parentheses, 84.375, right parentheses,
semicolon. 
Line 3: list 3 dot Insert, left parentheses, double quotes, Muffler bolt,
double quotes, right parentheses."
Back to Figure
"Line 1: list 1 dot Insert, left parentheses, 356, right parentheses,
semicolon. 
Line 2: list 2 dot Insert, left parentheses, 84.375, right parentheses,
semicolon. 
Line 3: list 3 dot Insert, left parentheses, double quotes, Muffler bolt,
double quotes, right parentheses."
Back to Figure
"Line 1: G List underscore int list 1, semicolon. 
Line 2: G List underscore float list 2, semicolon. 
Line 3: G List underscore string list 3, semicolon."
Back to Figure

"Program code. The words in the function names are merged. The
code contains the following keywords: class, public, void, bool,
private, int. 
Line 1: class G List, underscore, int. 
Line 2: left brace. 
Line 3: public, colon. 
Line 4: dot, dot. 
Line 5, indented once: void Insert, left parentheses, Item Type item,
right parentheses, semicolon. 
The data type, Item Type is circled and an arrow pointing to the
circle reads, int. 
Line 6, indented once: void Delete, left parentheses, Item Type,
item, right parentheses, semicolon. 
The data type, Item Type is circled and an arrow pointing to the
circle reads, int. 
Line 7, indented once: bool Is Present, left parentheses, Item Type,
item, right parentheses, const, semicolon. 
The data type, Item Type is circled and an arrow pointing to the
circle reads, int. 
Line 8: dot, dot. 
Line 9: private, colon. 
Line 10, indented once: int length, semicolon. 
Line 11, indented once: Item Type data, left square bracket, MAX,
underscore, LENGTH, right square bracket, semicolon. 
The data type, Item Type is circled and an arrow pointing to the
circle reads, int. 
Line 12: right brace, semicolon."
Back to Figure
"Program code. The code contains the following keywords: template,
class, void. 
Line 1: template, left angled bracket, class, Item Type, right angled
bracket. 
Line 2: void G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Insert, left parentheses, Item Type item, right
parentheses. 
Line 3: left brace. 
Line 4, indented once: data, left square bracket, length, right square

bracket, equals item, semicolon. 
Line 5, indented once: length, plus, plus. 
Line 6: right brace."
Back to Figure
"Program code. The code contains the following keywords: void,
float. 
Line 1: void G List, left angled bracket, float, right angled bracket,
colon, colon, Insert, left parentheses, float item, right parentheses. 
Line 2: left brace. 
Line 3, indented once: data, left square bracket, length, right square
bracket, equals item, semicolon. 
Line 4, indented once: length, plus, plus. 
Line 5: right brace."
Back to Figure
"Line 1: template, left angled bracket, class Item Type, right angled
bracket. 
Line 2: void G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Insert, left parentheses, const Item Type
ampersand item, right parentheses. 
Line 3: left brace. 
Line 4, indented once: data, left square bracket, length, right square
bracket, equals, item, semicolon. 
Line 5, indented once: length plus, plus, semicolon. 
Line 5: right brace."
Back to Figure
"Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords: const, int, template, class, public, void, int, bool, private,
include, i o stream, using, name space, s t d. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION, left parentheses, g list
dot h, right parentheses. 
Line 3: 2 forward slashes. This is the specification of a generic List A

D T, period. 
Line 4: 2 forward slashes. The list components are not assumed to
be in order by value, comma. 
Line 5: 2 forward slashes. the maximum length of the list is 100
components, comma, and the. 
Line 6: 2 forward slashes. components must be comparable with the
relational operators, period. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: const int MAX underscore LENGTH equals 100, semicolon. 2
forward slashes. Maximum number of components. 
Line 9: blank. 
Line 10: template, left angled bracket, class Item Type, right angled
bracket. 2 forward slashes. Type of each component. 
Line 11: class G List. 
Line 12: left brace. 
Line 13: public, colon. 
Line 14, indented once: G List, left parentheses, right parentheses,
semicolon. 
Line 15, indented once: 2 forward slashes. Action responsibilities. 
Line 16, indented once: void Insert, left parentheses, const Item
Type ampersand item, right parentheses, semicolon. 
Line 17, indented once: void Delete, left parentheses, const Item
Type ampersand item, right parentheses, semicolon. 
Line 18, indented once: void Reset List, left parentheses, right
parentheses, semicolon. 
Line 19, indented once: Item Type Get Next Item, left parentheses,
right parentheses, semicolon. 
Line 20, indented once: 2 forward slashes. Knowledge
responsibilities. 
Line 21, indented once: int Get Length, left parentheses, right
parentheses, const, semicolon. 
Line 22, indented once: bool Is Empty, left parentheses, right
parentheses, const, semicolon. 
Line 23, indented once: bool Is Full, left parentheses, right
parentheses, const, semicolon. 
Line 24, indented once: bool Is There, left parentheses, const Item
Type ampersand item, right parentheses, const, semicolon. 
Line 25, indented once: bool Has Next, left parentheses, right
parentheses, const, semicolon. 

Line 26: private, colon. 
Line 27, indented once: int length, semicolon. 
Line 28, indented once: int current Pos, semicolon. 
Line 29, indented once: Item Type data, left square bracket, MAX
underscore LENGTH, right square bracket, semicolon. 
Line 30: right brace, semicolon. 
Line 31: 2 forward slashes followed by asterisks till the end of the
line. 
Line 32: 2 forward slashes. IMPLEMENTATION Code. 
Line 33: 2 forward slashes. Following is the implementation of the G
List member functions. 
Line 34: 2 forward slashes. List representation, colon, a one
dimensional array and a length. 
Line 35: 2 forward slashes. variable. 
Line 36: 2 forward slashes followed by asterisks till the end of the
line. 
Line 37: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 38: using name space s t d, semicolon. 
Line 39: template, left angled bracket, class Item Type, right angled
bracket. 
Line 40: G List, left angled bracket, Item Type, right angled bracket,
colon, G List, left parentheses, right parentheses. 2 forward slashes.
Constructor. 
Line 41: left brace."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
template, class, bool, Item Type, const, return, int, void, while, if. 
Line 1, indented once: length equals 0, semicolon. 
Line 2, indented once: current Pos equals 0, semicolon. 
Line 3: right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: template, left angled bracket, class Item Type, right angled
bracket. 
Line 6: bool G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Is Empty, left parentheses, right parentheses,

const. 
Line 7: left brace. 
Line 8, indented once: return, left parentheses, length equals 0, right
parentheses, semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: template, left angled bracket, class Item Type, right angled
bracket. 
Line 12: bool G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Is Full, left parentheses, right parentheses,
const. 
Line 13: left brace. 
Line 14, indented once: return, left parentheses, length equals
equals MAX underscore LENGTH, right parentheses, semicolon. 
Line 15: right brace. 
Line 16: 2 forward slashes followed by asterisks till the end of the
line. 
Line 17: template, left angled bracket, class Item Type, right angled
bracket. 
Line 18: int G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Get Length, left parentheses, right
parentheses, const. 
Line 19: left brace. 
Line 20, indented once: return length, semicolon. 
Line 21: right brace. 
Line 22: 2 forward slashes followed by asterisks till the end of the
line. 
Line 23: template, left angled bracket, class Item Type, right angled
bracket. 
Line 24: void G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Insert, left parentheses, const Item Type
ampersand item, right parentheses. 
Line 25: left brace. 
Line 26, indented once: data, left square bracket, length, right
square bracket, equals item, semicolon. 
Line 27, indented once: length plus, plus. 
Line 28: right brace. 
Line 29: 2 forward slashes followed by asterisks till the end of the

line. 
Line 30: template, left angled bracket, class Item Type, right angled
bracket. 
Line 31: void G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Delete, left parentheses, const Item Type
ampersand item, right parentheses. 
Line 32: left brace. 
Line 33, indented once: int index equals 0, semicolon. 
Line 34, indented once: while, left parentheses, index less than
length ampersand, ampersand, item not equal to data, left square
bracket, index, right square bracket, right parentheses. 
Line 35, indented twice: index plus, plus. 
Line 36, indented once: if, left parentheses, index less than length,
right parentheses. 
Line 37, indented once: left brace. 
Line 38, indented twice: data, left square bracket, index, right square
bracket, equals, data, left square bracket, length minus 1, right
square bracket, semicolon. 
Line 39, indented twice: length minus, minus, semicolon. 
Line 40, indented once: right brace. 
Line 41: right brace. 
Line 42: 2 forward slashes followed by asterisks till the end of the
line. 
Line 43: template, left angled bracket, class Item Type, right angled
bracket."
Back to Figure
"Program code. The words in the function names, and variable
names are merged. The code contains the following keywords: bool,
Item type, const, int, while, return, template, class, void. 
Line 1: bool G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Is There, left parentheses, const, Item Type
ampersand item, right parentheses, const. 
Line 2: left brace. 
Line 3, indented once: int index equals 0, semicolon. 
Line 4, indented once: while, left parentheses, index less than
length, ampersand, ampersand, item not equal to data, left square
bracket, index, right square bracket, right parentheses. 

Line 5, indented twice: index plus, plus. 
Line 6, indented once: return, left parentheses, index less than
length, right parentheses, semicolon. 
Line 7: right brace. 
Line 8: 2 forward slashes followed by asterisks till the end of the line.
Line 9: template, left angled bracket, class Item Type, right angled
bracket. 
Line 10: void G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Reset List, left parentheses, right
parentheses. 
Line 11: left brace. 
Line 12, indented once: current Pos equals 0, semicolon. 
Line 13: right brace. 
Line 14: 2 forward slashes followed by asterisks till the end of the
line. 
Line 15: template, left angled bracket, class Item Type, right angled
bracket. 
Line 16: bool G List, left angled bracket, Item Type, right angled
bracket, colon, colon, Has Next, left parentheses, right parentheses,
const. 
Line 17: left brace. 
Line 18, indented once: return, left parentheses, current Pos not
equal to length, right parentheses, semicolon. 
Line 19: right brace. 
Line 20: 2 forward slashes followed by asterisks till the end of the
line. 
Line 21: template, left angled bracket, class Item Type, right angled
bracket. 
Line 22: Item Type G List, left angled bracket, Item Type, right
angled bracket, colon, colon, Get Next Item, left parentheses, right
parentheses. 
Line 23: left brace. 
Line 24, indented once: Item Type item, semicolon. 
Line 25, indented once: item equals data, left square bracket,
current Pos, right square bracket, semicolon. 
Line 26, indented once: current Pos, plus, plus, semicolon. 
Line 27, indented once: return item, semicolon. 
Line 28: right brace."

Back to Figure
"Program code. The code contains the following keywords: include, f
stream, i o stream, using, name space, s t d, int, main. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program inputs one month’s
temperature readings from a file, comma. 
Line 3: 2 forward slashes. stores unique readings in a list, comma,
outputs the list, comma, removes a value. 
Line 4: 2 forward slashes. of 200, comma, and outputs the resulting
list, period. 
Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 2 forward slashes. For file I forward slash O. 
Line 7: hash include, double quotes, G List dot h, double quotes. 2
forward slashes. For List class. 
Line 8: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 9: using name space s t d, semicolon. 
Line 10: int main, left parentheses, right parentheses. 
Line 7 is highlighted."
Back to Figure
"Program code. The words used in the keywords, variable names,
and function names are merged. The code contains the following
keywords: int, i f stream, o f stream, if, return, while, end l, return. 
Line 1: left brace. 
Line 2, indented once: G List, left angled bracket, int, right angled
bracket, temps, semicolon. 2 forward slashes. List of temperature
readings. 
Line 3, indented once: int one Temp, semicolon. 2 forward slashes.
One temperature reading. 
Line 4, indented once: i f stream in Data, semicolon. 2 forward
slashes. File of temperature readings. 
Line 5, indented once: o f stream out Data, semicolon. 2 forward
slashes. Output file. 
Line 6: blank. 
Line 7, indented once: in Data dot open, left parentheses, double

quotes, temps dot d a t, double quotes, right parentheses,
semicolon. 
Line 8, indented once: if, left parentheses, exclamation mark, in
Data, right parentheses. 
Line 9, indented once: left brace. 
Line 10, indented twice: out Data, 2 left angled brackets, double
quotes, Can’t open file temps dot d a t, double quotes, 2 left angled
bracket, end l, semicolon. 
Line 11, indented twice: return 1, semicolon. 
Line 12, indented once: right brace. 
Line 13, indented once: out Data dot open, left parentheses, double
quotes, temps dot a n s, double quotes, right parentheses,
semicolon. 
Line 14, indented once: in Data, 2 right angled brackets, one Temp,
semicolon. 2 forward slashes. Get a temperature. 
Line 15, indented once: while, left parentheses, in Data ampersand,
ampersand, exclamation mark, temps dot Is Full, left parentheses,
right parentheses, right parentheses. 
Line 16, indented once: left brace. 
Line 17, indented twice: if, left parentheses, exclamation mark,
temps dot Is There, left parentheses, one Temp, right parentheses,
right parentheses. 
Line 18, indented thrice: temps dot Insert, left parentheses, one
Temp, right parentheses, semicolon. 
Line 19, indented twice: in Data, 2 right angled brackets, one Temp,
semicolon. 
Line 20, indented once: right brace. 
Line 21, indented once: 2 forward slashes. Output original list. 
Line 22, indented once: 2 forward slashes. Set up for an iteration. 
Line 23, indented once: out Data, 2 left angled brackets, double
quotes, No, period, of unique readings, colon, blank space, double
quotes, 2 left angled brackets, temps dot Get Length, left
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 24, indented once: while, left parentheses, temps dot Has Next,
left parentheses, right parentheses, right parentheses. 
Line 25, indented once: left brace. 
Line 26, indented twice: one Temp equals temps dot Get Next Item,
left parentheses, right parentheses, semicolon. 

Line 27, indented twice: out Data, 2 left angled brackets, one Temp,
2 left angled brackets, end l, semicolon. 
Line 28, indented once: right brace. 
Line 29, indented once: temps dot Delete, left parentheses, 200,
right parentheses, semicolon. 2 forward slashes. Remove 200 if
there, semicolon, cannot be more than one. 
Line 30, indented once: temps dot Reset List, left parentheses, right
parentheses, semicolon. 
Line 31, indented once: out Data, 2 left angled brackets, double
quotes, Readings without value of 200, period, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 32, indented once: while, left parentheses, temps dot Has Next,
left parentheses, right parentheses, right parentheses. 
Line 33, indented once: left brace. 
Line 34, indented twice: one Temp equals temps dot Get Next Item,
left parentheses, right parentheses, semicolon. 
Line 35, indented twice: out Data, 2 left angled brackets, one Temp,
2 left angled brackets, end l, semicolon. 
Line 36, indented once: right brace. 
Line 37, indented once: in Data dot close, left parentheses, right
parentheses, semicolon. 
Line 38, indented once: out Data dot close, left parentheses, right
parentheses, semicolon. 
Line 39, indented once: return 0, semicolon. 
Line 40: right brace."
Back to Figure
G List, left angled bracket, int, right angled bracket, temps,
semicolon.
Back to Figure
Line 1: G List, left angled bracket, float, right angled bracket, list Of
Floats, semicolon. Line 2: G List, left angled bracket, string, right
angled bracket, list Of Strings, semicolon.
Back to Figure

G List, left angled bracket, Name, right angled bracket, list Of
Names, semicolon.
Back to Figure
template, left angled bracket, class Item Type, comma, const int
MAX underscore LENGTH, right angled bracket. The parameter
const int MAX underscore LENGTH is highlighted.
Back to Figure
G List, left angled bracket, int, comma, 100, right angled bracket,
temps, semicolon. 2 forward slashes. List of temperature readings.
Back to Figure
G List, left angled bracket, int, comma, 275, right angled bracket,
temps, semicolon. 2 forward slashes. List of temperature readings.
Back to Figure
"Program code. The words in the variable names, and function
names are merged. The code contains the following keywords:
class, public, private, int, void, const. 
Line 1: class O r d Pair. 
Line 2: left brace. 
Line 3: public, colon. 
Line 4, indented once: int First, left parentheses, right parentheses,
blank space, const, semicolon. 2 forward slashes. Returns first
component of the pair. 
Line 5, indented once: int Second, left parentheses, right
parentheses, blank space, const, semicolon. 2 forward slashes.
Returns the second component of the pair. 
Line 6, indented once: void Print, left parentheses, right
parentheses, const, semicolon. 2 forward slashes. Outputs the pair. 
Line 7, indented once: O r d Pair, left parentheses, int m, comma, int
n, right parentheses, semicolon. 2 forward slashes. Constructor,
semicolon, creates ordered pair, left parentheses, m, comma, n,
right parentheses. 
Line 8: private, colon. 

Line 9, indented once: int first, semicolon. 
Line 10, indented once: int second, semicolon. 
Line 11: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names, and keywords are
merged. The code contains the following keywords: void, int, c out,
end l, char, float, double. 
Line 1: void Print, left parentheses, int number, right parentheses. 
Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
asterisk, asterisk, asterisk, Debug, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
Value is, blank space, double quotes, 2 left angled brackets, number,
2 left angled brackets, end l, semicolon. 
Line 5: right brace. 
Line 6: void Print, left parentheses, char character, right
parentheses. 
Line 7: left brace. 
Line 8, indented once: c out, 2 left angled brackets, double quotes,
asterisk, asterisk, asterisk, Debug, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 9, indented once: c out, 2 left angled brackets, double quotes,
Value is, blank space, double quotes, 2 left angled brackets,
character, 2 left angled brackets, end l, semicolon. 
Line 10: right brace. 
Line 11: void Print, left parentheses, float real Value, right
parentheses. 
Line 12: left brace. 
Line 13: dot, dot. 
Line 14: right brace. 
Line 15: void Print, left parentheses, double, double Value, right
parentheses. 
Line 16: left brace. 
Line 17: dot, dot. 
Line 18: right brace. 
Line 19: dot, dot. 2 forward slashes, E t c, period."

Back to Figure
Line 1: Print, left parentheses, some Int, right parentheses,
semicolon. Line 2: Print, left parentheses, some Float, right
parentheses, semicolon. Line 3: Print, left parentheses, some
Double, right parentheses, semicolon.
Back to Figure
"Line 1: template, left angled bracket, type name, Some Type, right
angled bracket. 
Line 2: void Print, left parentheses, Some Type val, right
parentheses. 
Line 3: left brace. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
asterisk, asterisk, asterisk, Debug, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Value is, blank space, double quotes, 2 left angled brackets, val, 2
left angled brackets, end l, semicolon. 
Line 6: right brace."
Back to Figure
Line 1: Print, left angled bracket, int, right angled bracket, left
parentheses, sum, right parentheses, semicolon. Line 2: Print, left
angled bracket, char, right angled bracket, left parentheses, initial,
right parentheses, semicolon. Line 3: Print, left angled bracket, float,
right angled bracket, left parentheses, angle, right parentheses,
semicolon.
Back to Figure
"Program code. The code contains the following keywords: void, c
out, end l, float. 
Line 1: void Print, left parentheses, Some Type v a l, right
parentheses. 
The data type, Some Type, is circled and an arrow pointing to the
circle reads, float. 

Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
asterisk, asterisk, asterisk, Debug, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
Value is, double quotes, 2 left angled brackets, v a l, 2 left angled
brackets, end l, semicolon. 
Line 5: right brace."
Back to Figure
Function Name, left angled bracket, Template A r g List, right angled
bracket, left parentheses, Function A r g List, right parentheses. The
words between the angled brackets are shaded.
Back to Figure
Line 1: Print, left parentheses, sum, right parentheses, semicolon. 2
forward slashes. Implicit, colon, Print, left angled bracket, int, right
angled bracket, left parentheses, sum, right parentheses. Line 2:
Print, left parentheses, initial, right parentheses, semicolon. 2
forward slashes. Implicit, colon, Print, left angled bracket, char, right
angled bracket, left parentheses, initial, right parentheses. Line 3:
Print, left parentheses, angle, right parentheses, semicolon. 2
forward slashes. Implicit, colon, Print, left angled bracket, float, right
angled bracket, left parentheses, angle, right parentheses.
Back to Figure
"Program code. The words in the function names, and variable
names are merged. The code contains the following keywords:
class, public, int, const, bool, private. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for a Date A D T. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: class Date. 
Line 6: left brace. 
Line 7: public, colon. 

Line 8, indented once: Date, left parentheses, right parentheses,
semicolon. 
Line 9, indented once: Date, left parentheses, int init Month, comma,
int init Day, comma, int init Year, right parentheses, semicolon. 
Line 10, indented once: 2 forward slashes. Knowledge
responsibilities. 
Line 11, indented once: int Get Month, left parentheses, right
parentheses, const, semicolon. 
Line 12, indented once: int Get Day, left parentheses, right
parentheses, const, semicolon. 
Line 13, indented once: int Get Year, left parentheses, right
parentheses, const, semicolon. 
Line 14, indented once: bool operator, left angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const, semicolon. 
Line 15, indented once: bool operator, right angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const, semicolon. 
Line 16, indented once: bool operator, equals equals, left
parentheses, const Date ampersand other Date, right parentheses,
const, semicolon. 
Line 17: private, colon. 
Line 18, indented once: int month, semicolon. 
Line 19, indented once: int day, semicolon. 
Line 20, indented once: int year, semicolon. 
Line 21: right brace, semicolon."
Back to Figure
"Program code. The words used in the variable names are merged.
The code contains the following keywords: bool, const, if, return,
true, else, false.
Line 1: bool Date, colon, colon, operator, left angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, year less than, other
Date dot year, right parentheses. 
Line 4, indented twice: return true, semicolon. 

Line 5, indented once: else if, left parentheses, year greater than
other Date dot year, right parentheses. 
Line 6, indented twice: return false, semicolon. 
Line 7, indented once: else if, left parentheses, month, less than,
other Date dot month, right parentheses. 
Line 8, indented twice: return true, semicolon. 
Line 9, indented once: else if, left parentheses, month greater than
other Date dot month, right parentheses. 
Line 10, indented twice: return false, semicolon. 
Line 11, indented once: else if, left parentheses, day less than other
Date dot Day, right parentheses. 
Line 12, indented twice: return true, semicolon. 
Line 13, indented once: else return false, semicolon. 
Line 14: right brace. 
Line 15: 2 forward slashes followed by asterisks till the end of the
line. 
Line 16: bool Date, colon, colon, operator, right angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 17: left brace. 
Line 18, indented once: if, left parentheses, year greater than other
Date dot year, right parentheses. 
Line 19, indented twice: return true, semicolon. 
Line 20, indented once: else if, left parentheses, year less than other
Date dot year, right parentheses. 
Line 21, indented twice: return false, semicolon. 
Line 22, indented once: else if, left parentheses, month greater than
other Date dot month, right parentheses. 
Line 23, indented twice: return true, semicolon. 
Line 24, indented once: else if, left parentheses, month less than
other Date dot month, right parentheses. 
Line 25, indented twice: return false, semicolon. 
Line 26, indented once: else if, left parentheses, day greater than
other Date dot day, right parentheses. 
Line 27, indented twice: return true, semicolon. 
Line 28, indented once: else return false, semicolon. 
Line 29: right brace. 
Line 30: 2 forward slashes followed by asterisks till the end of the
line. 

Line 31: bool Date, colon, colon, operator, equals, equals, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 32: left brace. 
Line 33, indented once: return, left parentheses, month, equals,
equals, other Date dot month, right parentheses, ampersand,
ampersand, left parentheses, day, equals, equals, other Date dot
day, right parentheses. 
Line 34, indented multiple times: ampersand, ampersand, left
parentheses, year, equals, equals, other Date dot year, right
parentheses, semicolon. 
Line 35: right brace."
Back to Figure
"Program code. The code contains the keyword include. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This is a test driver for class Date. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, double quotes, Date dot h, double quotes."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: using, name
space, s t d, int, main, if, c out, end l, return. 
Line 1: using name space s t d, semicolon. 
Line 2: blank. 
Line 3: int main, left parentheses, right parentheses. 
Line 4: left brace. 
Line 5, indented once: Date date 1, left parentheses, 1, comma, 1,
comma, 2023, right parentheses, semicolon. 
Line 6, indented once: Date date 2, left parentheses, 2, comma, 2,
comma, 2022, right parentheses, semicolon. 
Line 7, indented once: if, left parentheses, date 1, greater than, date
2, right parentheses. 
Line 8, indented twice: c out, 2 left angled brackets, double quotes,

date 1 is greater than date 2, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 9, indented once: if, left parentheses, date 2 less than date 1,
right parentheses. 
Line 10, indented twice: c out, 2 left angled brackets, double quotes,
date 2 is less than date 1, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 11, indented once: if, left parentheses, date 1, equals, equals,
date 1, right parentheses. 
Line 12, indented twice: c out, 2 left angled brackets, double quotes,
date 1 is equal to date 1, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 13, indented once: return 0, semicolon. 
Line 14: right brace."
Back to Figure
"Line 1: date 1 is greater than date 2. 
Line 2: date 2 is less than date 1. 
Line 3: date 1 is equal to date 1."
Back to Figure
"Program code. The code contains the following keywords: bool,
const, return, this. 
Line 1: bool Date, colon, colon, operator, right angled bracket, left
parentheses, const, Date ampersand other Date, right parentheses,
const. 
Line 2: left brace. 
Line 3, indented once: return other Date, left angled bracket,
asterisk, this, semicolon. 2 forward slashes. Compares parameter
with current object. 
Line 4: right brace."
Back to Figure
"Program code. The code contains the following keywords: int, if,
else. 
Line 1: int Quotient, left parentheses, int n u m e r, comma, int d e n

o m, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, d e n o m, exclamation
mark, equals sign, 0, right parentheses. 
Line 4, indented twice: return n u m e r, forward slash, d e n o m,
semicolon. 
Line 5, indented once: else. 
Line 6, indented twice: 2 forward slashes, What to do, question
mark. 
Line 7: right brace."
Back to Figure
"Program code. The code contains the keyword int. 
Line 1: int Quotient, left parentheses, int n u m e r, comma, int d e n
o m, right parentheses. 
Line 2: 2 forward slashes. Pre, colon, d e n o m is not zero. 
Line 3: 2 forward slashes. Post, colon, Return value is n u m e r,
forward slash, d e n o m. 
Line 4: left brace. 
Line 5, indented twice: return n u m e r, forward slash, d e n o m,
semicolon. 
Line 6: right brace."
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: class, throw. Line 1: class
Salary Error. Line 2: left brace, right brace, semicolon. 2 forward
slashes. Member list is empty. Line 3: dot, dot. Line 4: Salary Error s
a l, semicolon. Line 5: throw s a l, semicolon.
Back to Figure
Program code. The words in the variable name are merged. The
code contains the following keywords: class, throw. Line 1: class
Salary Error. Line 2: left brace, right brace, semicolon. 2 forward
slashes. Member list is empty. Line 3: dot, dot. Line 4: throw Salary
Error, left parentheses, right parentheses, semicolon.

Back to Figure
Syntax of the Try Catch Statement. The keywords used are as
follows: try, catch. Line 1: try. Line 2, indented once: Block. Line 3:
catch, left parentheses, Formal Parameter, right parentheses. Line
4, indented once: Block. Line 5: catch, left parentheses, Formal
Parameter, right parentheses. Line 6, indented once: Block. Line 7:
dot, dot. Lines 5 and 6 are shaded.
Back to Figure
Line 1: Data Type Variable Name. Line 2: dot, dot, dot. A left brace
encloses both lines on the left. In line 1, Variable Name is shaded.
Back to Figure
"Program code. The words in the variable name are merged. The
code contains the following keywords: try, catch, int, string, c out,
end l. 
Line 1: try. 
Line 2: left brace. 
Line 3: dot, dot. 2 forward slashes. Statements that process
personnel data and may throw. 
Line 4, indented multiple times: 2 forward slashes. Exceptions of
type int, comma, string, comma, and Salary Error. 
Line 5: right brace. 
Line 6: catch, left parentheses, int, right parentheses. 
Line 7: left brace. 
Line 8: dot, dot. 2 forward slashes. Statements to handle an int
exception. 
Line 9: right brace. 
Line 10: catch, left parentheses, string s, right parentheses. 
Line 11: left brace. 
Line 12, indented once: c out, 2 left angled brackets, s, 2 left angled
brackets, end l, semicolon. 2 forward slashes. Outputs double
quotes, Invalid customer age, double quotes. 
Line 13: dot, dot. 2 forward slashes. More statements to handle a
string exception. 
Line 14: right brace. 

Line 15: catch, left parentheses, Salary Error, right parentheses. 
Line 16: left brace. 
Line 17: dot, dot. 2 forward slashes. Statements to handle a salary
error. 
Line 18: right brace."
Back to Figure
"Program code. The code contains the following keywords: try,
catch, c out, end l. 
Line 1: try. 
Line 2: left brace. 
Line 3: dot, dot. 2 forward slashes. Statements that may throw and
exception. 
Line 4: right brace. 
Line 5: catch, left parentheses, Type 1, right parentheses. 
Line 6: left brace. 
Line 7: dot, dot. 2 forward slashes. Handle a Type 1 exception. 
Line 8: right brace. 
Line 9: catch, left parentheses, Type 2, right parentheses. 
Line 10: left brace. 
Line 11: dot, dot. 2 forward slashes. Handle a Type 2 exception. 
Line 12: right brace. 
Line 13: catch, left parentheses, dot, dot, dot, right parentheses. 2
forward slashes. Catch hyphen all handler. 
Line 14: left brace. 
Line 15, indented once: c out, 2 left angled brackets, double quotes,
Panic, exclamation mark, unexpected exception, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 16, indented once: dot, dot. 2 forward slashes. Statements to
deal with this situation. 
Line 17: right brace."
Back to Figure
Program code. The code contains the following keywords: class, if,
throw. Line 1: class Salary Error. 2 forward slashes. Exception class.
Line 2: left brace, right brace, semicolon. Line 3: class Bad Range. 2
forward slashes. Exception class. Line 4: left brace, right brace,

semicolon. Line 5: dot, dot. Line 6: if, left parentheses, condition,
right parentheses. Line 7, indented once: throw Salary Error, left
parentheses, right parentheses, semicolon. Line 8: dot, dot. Line 9:
if, left parentheses, condition, right parentheses. Line 10, indented
once: throw Bad Range, left parentheses, right parentheses,
semicolon.
Back to Figure
Program code. The code contains the following keywords: void, try,
catch, if, throw. The description of the first code fragment is as
follows. Line 1: void Func 3, left parentheses, right parentheses.
Line 2: left brace. Line 3: dot, dot, dot. Line 4, indented once: try.
Line 5, indented once: left brace. Line 6, indented twice: dot, dot,
dot. Line 7, indented twice: Func 4, left parentheses, right
parentheses, semicolon. Line 8, indented twice: dot, dot, dot. Line 9,
indented once: right brace. Line 10, indented once: catch, left
parentheses, E r r Type, right parentheses. Line 11, indented once:
left brace. Line 12, indented twice: dot, dot, dot. Line 13, indented
once: right brace. Line 14, indented twice: dot, dot, dot. Line 15:
right brace. The description of the second code fragment is as
follows. Line 1: void Func 4, left parentheses, right parentheses.
Line 2: left brace. Line 3, indented once: dot, dot, dot. Line 4,
indented once: if, left parentheses, error, right parentheses. Line 5,
indented twice: throw E r r Type, left parenthess, right parentheses,
semicolon. Line 6, indented once: dot, dot, dot. Line 7: right brace.
An arrow marked Function call is drawn from Line 7 of the first code
fragment to Line 1 of the second code fragment. An arrow marked
Normal return is drawn from Line 7 of the second code fragment to
Line 8 of the first code fragment. An arrow marked Return from
throw exception is drawn from Line 5 of the second code fragment
to Line 12 of the first code fragment.
Back to Figure
The description of the first diagram is as follows. a. Function F u n c
1 has a handler for E r r Type. The main function has No E r r Type
handler. The main function calls F u n c 1. F u n c 1 has a E r r Type
handler. F u n c 1 calls F u n c 2. F u n c 2 has No E r r Type

handler. F u n c 2 calls F u n c 3. F u n c 3 has No E r r Type
handler. F u n c 3 calls F u n c 4. F u n c 4 has no E r r Type handler
and it has a function labeled throw E r r Type, left parentheses, right
parentheses, semicolon. F u n c 4 has an immediate return to F u n
c 3. F u n c 3 has an immediate return to F u n c 2. F u n c 2 has an
immediate return to F u n c 1. The description of the second
diagram is as follows. b. No function has a handler for E r r Type.
The main function has No E r r Type handler. The main function calls
F u n c 1 which has No E r r Type handler. F u n c 1 calls F u n c 2
which has No E r r Type handler. F u n c 2 calls F u n c 3 which has
No E r r Type handler. F u n c 3 calls F u n c 4 which has No E r r
Type hander and it has a function labeled throw E r r Type, left
parentheses, right parentheses, semicolon. F u n c 4 has an
immediate return to F u n c 3. F u n c 3 has an immediate return to
F u n c 2. F u n c 2 has an immediate return to F u n c 1. F u n c 1
has an immediate return to the main function. After returning to the
main function, the program terminates immediately.
Back to Figure
"Program code. The words used in the function names are merged.
The code contains the following keywords: void, try, while, catch,
throw. 
Line 1: void Write To File, left parentheses, parameters, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: colon. 2 forward slashes. Open a file for
output. 
Line 4, indented once: try. 
Line 5, indented once: left brace. 
Line 6, indented twice: while, left parentheses, condition, right
parentheses. 
Line 7, indented twice: left brace. 
Line 8, indented thrice: Do Something, left parentheses, arguments,
right parentheses, semicolon. 2 forward slashes. May throw a Bad
Data exception. 
Line 9: Dot, dot. 2 forward slashes. Write to output file. 
Line 10, indented twice: right brace. 
Line 11, indented once: right brace. 

Line 12, indented once: catch, left parentheses, Bad Data, right
parentheses. 
Line 13, indented once: left brace. 
Line 14, indented twice: dot, dot. 2 forward slashes. Write message
to output file and close it. 
Line 15, indented twice: throw, semicolon. 2 forward slashes.
Rethrow the exception. 
Line 16, indented once: right brace. 
Line 17, indented once: dot, dot. 2 forward slashes. Continue
processing and close the output file. 
Line 18: right brace."
Back to Figure
Program code. The code contains the following keywords: float, try,
new, catch, c out, end l, return. Line 1: float asterisk a r r, semicolon.
Line 2: try. Line 3: left brace. Line 4, indented once: a r r equals new
float, left square bracket, 50000, right square bracket, semicolon.
Line 5: right brace. Line 6: catch, left parentheses, bad underscore a
l l o c, right parentheses. Line 7: left brace. Line 8, indented once: c
out, 2 left angled brackets, double quotes, asterisk, asterisk,
asterisk, blank space, Out of memory, period, Can't allocate array,
period, double quotes, 2 left angled bracket, end l, semicolon. Line
9, indented once: return 1, semicolon. 2 forward slashes. Terminate
the program. Line 10: right brace. Line 11: dot, dot. 2 forward
slashes. Continue. Allocation succeeded.
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The code contains the following
keywords: void, string, try, catch, c out, end l. Line 1: void Some
Func, left parentheses, parameters, right parentheses. Line 2: left
brace. Line 3, indented once: dot, dot. Line 4, indented once: string
s 1, comma, s 2, semicolon. Line 5, indented once: try. Line 6,
indented once: left brace. Line 7, indented twice: s 2 equals s 1 dot
sub s t r, left parentheses, p o s, comma, l e n, right parentheses,
semicolon. 2 forward slashes. May throw out, underscore, of,
underscore, range, left parentheses, right parentheses. Line 8,

indented twice: s 1 equals s 1 plus s 1 plus s 2, semicolon. 2 forward
slashes. May throw length underscore error, left parentheses, right
parentheses. Line 9, indented once: right brace. Line 10, indented
once: catch, left parentheses, out, underscore, of, underscore,
range, right parentheses. Line 11, indented once: left brace. Line 12,
indented twice: c out, 2 left angled brackets, double quotes,
Exception, colon, out, underscore, of, underscore, range in Some
Func, double quotes, 2 left angled brackets, end l, semicolon. Line
13, indented twice: dot, dot. Line 14, indented once: right brace.
Line 15, indented once: catch, left parentheses, length underscore
error, right parentheses. Line 16, indented once: left brace. Line 17,
indented twice: c out, 2 left angled brackets, double quotes,
Exception, colon, length underscore error in Some Func, double
quotes, 2 left angled brackets, end l, semicolon. Line 18, indented
once: right brace. Line 19, indented once: dot, dot. 2 forward
slashes. Continue if no errors. Line 20: right brace.
Back to Figure
Program code. The code contains the keyword class. Line 1: class
Month Error. Line 2: left brace, right brace, semicolon. Line 3: class
Day Error. Line 4: left brace, right brace, semicolon. Line 5: class
Year Error. Line 6: left brace, right brace, semicolon.
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
class, public, int, const, bool, private, include, using, name space, s t
d. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for a Date A D T. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: 2 forward slashes. Exception classes. 
Line 5: class Month Error. 
Line 6: left brace, right brace, semicolon. 
Line 7: class Day Error. 
Line 8: left brace, right brace, semicolon. 
Line 9: class Year Error. 

Line 10: left brace, right brace, semicolon. 
Line 11: blank. 
Line 12: class Date. 
Line 13: left brace. 
Line 14: public, colon. 
Line 15, indented once: Date, left parentheses, right parentheses,
semicolon. 
Line 16: Date, left parentheses, int init Month, comma, int init Day,
comma, int init Year, right parentheses, semicolon. 
Line 17, indented once: 2 forward slashes. Knowledge
responsibilities. 
Line 18, indented once: int Get Month, left parentheses, right
parentheses, const, semicolon. 
Line 19, indented once: int Get Day, left parentheses, right
parentheses, const, semicolon. 
Line 20, indented once: int Get Year, left parentheses, right
parentheses, const, semicolon. 
Line 21, indented once: bool operator, left angled bracket, left
parentheses, const Date ampersand other Date, right parentheses
const, semicolon. 
Line 22, indented once: bool operator, right angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const, semicolon. 
Line 23, indented once: bool operator, equals, equals, left
parentheses, const Date ampersand other Date, right parentheses,
const, semicolon. 
Line 24: private, colon. 
Line 25, indented once: int month, semicolon. 
Line 26, indented once: int day, semicolon. 
Line 27, indented once: int year, semicolon. 
Line 28: right brace, semicolon. 
Line 29: 2 forward slashes followed by asterisks till the end of the
line. 
Line 30: 2 forward slashes. IMPLEMENTATION File for a Date A D
T. 
Line 31: 2 forward slashes. Month, comma, day, comma, and year
are kept as integers. 
Line 32: 2 forward slashes followed by asterisks till the end of the
line. 

Line 33: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 34: hash include, double quotes, Date dot h, double quotes. 
Line 35: blank. 
Line 36: bool Is Leap Year, left parentheses, int year, right
parentheses, semicolon. 
Line 37: using name space s t d, semicolon. 
Line 38: Date, colon, colon, Date, left parentheses, right
parentheses. 
Line 39: left brace. 
Line 40, indented once: month equals 1, semicolon. 
Line 41, indented once: day equals 1, semicolon. 
Line 42, indented once: year equals 1582, semicolon. 
Line 43: right brace. 
Line 44: 2 forward slashes followed by asterisks till the end of the
line. 
Line 45: Date, colon, colon, Date, left parentheses, int init Month,
comma, int init Day, comma, int init Year, right parentheses. 
Line 46: left brace. Lines 5 to 10 are shaded."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
static, int, if, throw, const, return, bool, else, bool. 
Line 1, indented once: static int days In Month, left square bracket,
12, right square bracket, equals. 
Line 2, indented twice: left brace, 31, comma, 29, comma, 31,
comma, 30, comma, 31, comma, 30, comma, 31, comma, 31,
comma, 30, comma, 31, comma, 30, comma, 31, right brace,
semicolon. 
Line 3, indented once: if, left parentheses, init Month less than or
equal to 0, 2 pipes, init Month greater than 12, right parentheses. 
Line 4, indented twice: throw Month Error, left parentheses, right
parentheses. 
Line 5, indented once: month equals init Month, semicolon. 
Line 6, indented once: if, left parentheses, month equals equals 2
ampersand ampersand init Day equals equals 29 ampersand
ampersand exclamation mark Is Leap Year, left parentheses, init

Year, right parentheses, right parentheses. 
Line 7, indented twice: throw Day Error, left parentheses, right
parentheses, semicolon. 
Line 8, indented once: if, left parentheses, init Day less than or equal
to 0, 2 pipes, init Day greater than days In Month, left square
bracket, init Month minus 1, right square bracket, right parentheses. 
Line 9, indented twice: throw Day Error, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: day equals init Day, semicolon. 
Line 11, indented once: if, left parentheses, init Year less than 1582,
right parentheses. 
Line 12, indented twice: throw Year Error, left parentheses, right
parentheses, semicolon. 
Line 13, indented once: year equals init Year, semicolon. 
Line 14: right brace. 
Line 15: 2 forward slashes followed by asterisks till the end of the
line. 
Line 16: int Date, colon, colon, Get Month, left parentheses, right
parentheses, const. 
Line 17: left brace, return month, semicolon, right brace. 
Line 18: 2 forward slashes followed by asterisks till the end of the
line. 
Line 19: int Date, colon, colon, Get Day, left parentheses, right
parentheses, const. 
Line 20: left brace, return day, semicolon, right brace. 
Line 21: 2 forward slashes followed by asterisks till the end of the
line. 
Line 22: int Date, colon, colon, Get Year, left parentheses, right
parentheses, const. 
Line 23: left brace, return year, semicolon, right brace. 
Line 24: 2 forward slashes followed by asterisks till the end of the
line. 
Line 25: bool Date, colon, colon, operator, left angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 26: left brace. 
Line 27, indented once: if, left parentheses, year less than other
Date dot year, right parentheses. 
Line 28, indented twice: return true, semicolon. 

Line 29, indented once: else if, left parentheses, year greater than
other Date dot year, right parentheses. 
Line 30, indented twice: return false, semicolon. 
Line 31, indented once: else if, left parentheses, month less than
other Date dot month, right parentheses. 
Line 32, indented twice: return true, semicolon. 
Line 33, indented once: else if, left parentheses, month greater than
other Date dot month, right parentheses. 
Line 34, indented twice: return false, semicolon. 
Line 35, indented once: else if, left parentheses, day less than other
Date dot day, right parentheses. 
Line 36, indented twice: return true, semicolon. 
Line 37, indented once: else return false, semicolon. 
Line 38: right brace. 
Line 39: 2 forward slashes followed by asterisks till the end of the
line. 
Line 40: bool Date, colon, colon, operator, right angled bracket, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 41: left brace. 
Lines 1 to 4 are shaded. Lines 6 to 9 are shaded. Lines 11 and 12
are shaded."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
return, this, bool, const, int, if. 
Line 1, indented once: return other Date less than asterisk this,
semicolon. 
Line 2: right brace. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: bool Date, colon, colon, operator, equals, equals, left
parentheses, const Date ampersand other Date, right parentheses,
const. 
Line 5: left brace. 
Line 6, indented once: return, left parentheses, month, equals,
equals, other Date dot month, right parentheses, ampersand,
ampersand, left parentheses, day, equals, equals, other Date, dot,

day, right parentheses. 
Line 7, indented multiple times: ampersand, ampersand, left
parentheses, year, equals, equals, other Date dot year, right
parentheses, semicolon. 
Line 8: right brace. 
Line 9: 2 forward slashes followed by asterisks till the end of the line.
Line 10: bool Is Leap Year, left parentheses, int year, right
parentheses. 
Line 11: 2 forward slashes. Is Leap Year returns true if year is a leap
year and. 
Line 12: 2 forward slashes. false otherwise. 
Line 13: left brace. 
Line 14, indented once: if, left parentheses, year, percentage sign,
4, exclamation mark, equals, 0, right parentheses. 2 forward
slashes. Is year not divisible by 4, question mark. 
Line 15, indented twice: return false, semicolon. 2 forward slashes.
If so, comma, can’t be a leap year. 
Line 16, indented multiple times: 2 forward slashes. Must be divisible
by 4 at this point. 
Line 17, indented once: if, left parentheses, year, percentage sign,
100, exclamation mark, equals, 0, right parentheses. 2 forward
slashes. Is year not a multiple of 100, question mark. 
Line 18, indented twice: return true, semicolon. 2 forward slashes. If
so, comma, is a leap year. 
Line 19, indented multiple times: 2 forward slashes. Must be divisible
by 100 at this point. 
Line 20, indented once: if, left parentheses, year, percentage sign,
400, exclamation mark, equals, 0, right parentheses. 2 forward
slashes. Is year not a multiple of 400, question mark. 
Line 21, indented twice: return false, semicolon. 2 forward slashes.
If so, comma, then is not a leap year. 
Line 22, indented multiple times: 2 forward slashes. Must be divisible
by 400 at this point. 
Line 23, indented once: return true, semicolon. 2 forward slashes. Is
a leap year. 
Line 24: right brace."
Back to Figure

"The row entries are as follows. 
Row 1. Reason for Test Case: Month error. Input Values: 13,
comma, 1, comma, 2022. Expected Output: Attempt to create date
with invalid month. Observed Output: blank. 
Row 2. Reason for Test Case: Month error. Input Values: 0, comma,
1, comma, 2022. Expected Output: Attempt to create date with
invalid month. Observed Output: blank.
Row 3. Reason for Test Case: Day error. Input Values: 1, comma, 0,
comma, 2023. Expected Output: Attempt to create date with invalid
day. Observed Output: blank.
Row 4. Reason for Test Case: Day error. Input Values: 2, comma,
29, comma, 2021. Expected Output: Attempt to create date with
invalid day. Observed Output: blank.
Row 5. Reason for Test Case: Valid date. Input Values: 2, comma,
29, comma, 2024. Expected Output: Valid date. Observed Output:
blank."
Back to Figure
"The row entries are as follows. 
Row 1. Reason for Test Case: Day error. Input Values: 2, comma,
30, comma, 2022. Expected Output: Attempt to create date with
invalid day. Observed Output: blank. 
Row 2. Reason for Test Case: Day error. Input Values: 4, comma,
31, comma, 1945. Expected Output: Attempt to create date with
invalid day. Observed Output: blank.
Row 3. Reason for Test Case: Day error. Input Values: 6, comma,
31, comma, 2025. Expected Output: Attempt to create date with
invalid day. Observed Output: blank.
Row 4. Reason for Test Case: Day error. Input Values: 9, comma,
31, comma, 2000. Expected Output: Attempt to create date with
invalid day. Observed Output: blank.
Row 5. Reason for Test Case: Day error. Input Values: 11, comma,
31, comma, 2012. Expected Output: Attempt to create date with
invalid day. Observed Output: blank.
Row 6. Reason for Test Case: Year error. Input Values: 1, comma,
30, comma, 1066. Expected Output: Attempt to create date with
invalid year. Observed Output: blank.
Row 7. Reason for Test Case: Valid date. Input Values: 12, comma,

25, comma, 2022. Expected Output: Valid date. Observed Output:
blank.
Row 8. Reason for Test Case: Valid date. Input Values: 6, comma, 3,
comma, 2021. Expected Output: Valid date. Observed Output:
blank."
Back to Figure
Line 1: Test Driver. Line 2: Prompt for a month. Line 3: Read month.
Line 4: WHILE month greater than or equal to 0. Line 5, indented
once: Prompt for day and year. Line 6, indented once: Read day and
year. Line 7, indented once: TRY. Line 8, indented twice: Instantiate
Date with month, comma, day, comma, year. Line 9, indented once:
CATCH Month Error. Line 10, indented once: CATCH Day Error. Line
11, indented once: CATCH Year Error. Line 12, indented once:
Prompt for a month. Line 13, indented once: Read month.
"Program code. The words in the keywords and variable names are
merged. The code contains the following keywords: include, using,
name space, s t d, int, main, c out, end l, c in, while, try, catch,
return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Test driver for class Date, comma, which. 
Line 3: 2 forward slashes. is the Date class with exception handling. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, double quotes, Date dot h, double quotes. 
Line 7: using name space s t d, semicolon. 
Line 8: int main, left parentheses, right parentheses. 
Line 9: left brace. 
Line 10, indented once: int month, semicolon. 
Line 11, indented once: int day, semicolon. 
Line 12, indented once: int year, semicolon. 
Line 13: blank. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter month, period, Negative month stops test, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 15, indented once: c in, 2 right angled brackets, day, 2 right
angled brackets, year, semicolon. 

Line 16, indented once: try. 
Line 17, indented once: left brace. 
Line 18, indented twice: Date date 1, left parentheses, month,
comma, day, comma, year, right parentheses, semicolon. 
Line 19, indented twice: c out, 2 left angled brackets, double quotes,
Valid date, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 20, indented once: right brace. 
Line 21, indented twice: catch, left parentheses, Month Error error,
right parentheses. 
Line 22, indented twice: left brace. 
Line 23, indented thrice: c out, 2 left angled backets, double quotes,
Attempt to create date with invalid month, period, double quotes, 2
left angled brackets, end l, semicolon. 
Line 24, indented twice: right brace. 
Line 25, indented twice: catch, left parentheses, Day Error error,
right parentheses. 
Line 26, indented twice: left brace. 
Line 27, indented thrice: c out, 2 left angled brackets, double quotes,
Attempt to create date with invalid day, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 28, indented once: right brace. 
Line 29, indented once: catch, left parentheses, Year Error error,
right parentheses. 
Line 30, indented once: left brace. 
Line 31, indented thrice: c out, 2 left angled brackets, double quotes,
Attempt to create date with invalid year, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 32, indented twice: right brace. 
Line 33, indented twice: c out, 2 left angled brackets, double quotes,
Enter month, period, Negative month stops test, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 34, indented twice: c in, 2 right angled brackets, month,
semicolon. 
Line 35, indented once: right brace. 
Line 36, indented once: return 0, semicolon. 
Line 37: right brace."
Back to Figure

Line 1: Enter month. Negative month stops test. Line 2: 13. Line 3:
Enter day and year. Line 4: 1, blank space, 2022. Line 2 and line 4
are shaded.
Back to Figure
"Line 1: Attempt to create date with invalid month. 
Line 2: Enter month. Negative month stops test. 
Line 3: 0. Line 3 is shaded. 
Line 4: Enter day and year. 
Line 5: 1, blank space, 2022. Line 5 is shaded. 
Line 6: Attempt to create date with invalid month. 
Line 7: Enter month. Negative month stops test. 
Line 8: 2. Line 8 is shaded. 
Line 9: Enter day and year. 
Line 10: 29, blank space, 2021. Line 10 is shaded. 
Line 11: Attempt to create date with invalid day. 
Line 12: Enter month. Negative month stops test. 
Line 13: 2. Line 13 is shaded. 
Line 14: Enter day and year. 
Line 15: 29, blank space, 2024. Line 15 is shaded. 
Line 16: Valid date. 
Line 17: Enter month. Negative month stops test. 
Line 18: 2. Line 18 is shaded. 
Line 19: Enter day and year. 
Line 20: 30, blank space, 2022. Line 20 is shaded. 
Line 21: Attempt to create date with invalid day. 
Line 22: Enter month. Negative month stops test. 
Line 23: 4. Line 23 is shaded. 
Line 24: Enter day and year. 
Line 25: 31, blank space, 1945. Line 25 is shaded. 
Line 26: Attempt to create ate with invalid day. 
Line 27: Enter month. Negative month stops test. 
Line 28: 6. Line 28 is shaded. 
Line 29: Enter day and year. 
Line 30: 31, blank space, 2025. Line 30 is shaded. 
Line 31: Attempt to create date with invalid day. 
Line 32: Enter month. Negative month stops test. 
Line 33: 9. Line 33 is shaded. 

Line 34: Enter day and year. 
Line 35: 31, blank space, 2000. Line 35 is shaded. 
Line 36: Attempt to create date with invalid day. 
Line 37: Enter month. Negative month stops test. 
Line 38: 11. Line 38 is shaded. 
Line 39: Enter day and year. 
Line 40: 31, blank space, 2012. Line 40 is shaded. 
Line 41: Attempt to create date with invalid day."
Back to Figure
"Line 1: Enter month. Negative month stops test. 
Line 2: 1. Line 2 is shaded. 
Line 3: Enter day and year. 
Line 4: 30, blank space, 1066. Line 4 is shaded. 
Line 5: Attempt to create date with invalid year. 
Line 6: Enter month. Negative month stops test. 
Line 7: 12. Line 7 is shaded. 
Line 8: Enter day and year. 
Line 9: 25, blank space, 2022. Line 9 is shaded. 
Line 10: Valid date. 
Line 11: Enter month. Negative month stops test. 
Line 12: 6. Line 12 is shaded. 
Line 13: Enter day and year. 
Line 14: 3, blank space, 2021. Line 14 is shaded. 
Line 15: Valid date. 
Line 16: Enter month. Negative month stops test. 
Line 17: negative 1. Line 17 is shaded."
Back to Figure
"The row entries are as follows. 
Row 1. Loading Station: Crew seats. Distance From Nose in inches:
143. 
Row 2. Loading Station: Row 1 seats, left parentheses, 2, right
parentheses. Distance From Nose in inches: 219.
Row 3. Loading Station: Row 2 seats, left parentheses, 2, right
parentheses. Distance From Nose in inches: 265.
Row 4. Loading Station: Row 3 seats, left parentheses, 2, right

parentheses. Distance From Nose in inches: 295.
Row 5. Loading Station: Row 4 seats, left parentheses, 2, right
parentheses. Distance From Nose in inches: 341.
Row 6. Loading Station: Closet. Distance From Nose in inches: 182.
Row 7. Loading Station: Baggage. Distance From Nose in inches:
386."
Back to Figure
"The row entries are as follows. 
Row 1. Gallons of Fuel, uppercase g: 0 to 59. Distance Formula,
uppercase d: uppercase d equals 314.6 times uppercase g. 
Row 2. Gallons of Fuel, uppercase g: 60 to 360. Distance Formula,
uppercase d: uppercase d equals 305.8 plus, left square bracket,
negative 0.01233 times, left parentheses, uppercase g minus 60,
right parentheses, right square bracket.
Row 3. Gallons of Fuel, uppercase g: 361 to 520. Distance Formula,
uppercase d: uppercase d equals 303.0 plus left square bracket
0.12500 times left parentheses uppercase g minus 361, right
parentheses, right square bracket.
Row 4. Gallons of Fuel, uppercase g: 521 to 565. Distance Formula,
uppercase d: uppercase d equals 323.0 plus left square bracket,
negative 0.04444 times, left parentheses, uppercase g minus 521,
right parentheses, right square bracket."
Back to Figure
The description of the C R C card is as follows. Class Name: People.
Superclass: blank. Responsibilities: Create Person, left parentheses,
Name, comma, Role, right parentheses. Get Name returns Name.
Get Role returns Role. Collaborations: Name.
Back to Figure
"Line 1: 2 forward slashes followed by asterisks till the end of the
line. 
Line 2: 2 forward slashes. SPECIFICATION FILE for People Class. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Name dot h, double quotes. 

Line 5: class People. 
Line 6: left brace. 
Line 7: public, colon. 
Line 8, indented once: People, left parentheses, right parentheses,
semicolon. 
Line 9, indented once: People, left parentheses, Name init Name,
comma, char init Role, right parentheses, semicolon. 
Line 10, indented once: Name Get Name, left parentheses, right
parentheses, const, semicolon. 
Line 11, indented once: char Get Role, left parentheses, right
parentheses, const, semicolon. 
Line 12: private, colon. 
Line 13, indented once: Name name, semicolon. 
Line 14, indented once: char role, semicolon. 
Line 15: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: include, char. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for people class.
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, People dot h, double quotes. 
Line 5: People, colon, colon, People, left parentheses, right
parentheses. 
Line 6: left brace. 
Line 7, indented once: Name name, left parentheses, double quotes,
blank space, double quotes, comma, double quotes, blank space,
double quotes, comma, double quotes, blank space, double quotes,
right parentheses, semicolon. 
Line 8, indented once: role equals single quote, uppercase c, single
quote, semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: People, colon, colon, People, left parentheses, Name init
Name, comma, char init Role, right parentheses."

Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: return, const. 
Line 1: left brace. 
Line 2, indented once: name equals init Name, semicolon. 
Line 3, indented once: role equals init Role, semicolon. 
Line 4: right brace. 
Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: Name People, colon, colon, Get Name, left parentheses,
right parentheses, const. 
Line 7: left brace, return name, semicolon, right brace. 
Line 8: 2 forward slashes followed by asterisks till the end of the line.
Line 9: char People, colon, colon, Get Role, left parentheses, right
parentheses, const. 
Line 10: left brace, return role, semicolon, right brace."
Back to Figure
The description of the C R C card is as follows. Class Name: People.
Superclass: blank. Responsibilities: Create Aircraft, left parentheses,
right parentheses. Collaborations: blank. Responsibilities: Set Closet
And Fuel, left parentheses, Close W g t, comma, Fuel W g t, right
parentheses. Collaborations: blank. Responsibilities: Insert
Passenger, left parentheses, Name, comma, Weight, comma, Row
No, right parentheses. Collaborations: blank. Responsibilities: Insert
Crew, left parentheses, Name, comma, weight, right parentheses.
Collaborations: Name. Responsibilities: Get Total Weight returns
float. Collaborations: blank. Responsibilities: Get Center Of Gravity
returns float. Collaborations: blank. Responsibilities: Write Names
On Board, left parentheses, out File, right parentheses.
Collaborations: o f stream.
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
include, class, public, float, void, int, private. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.

Line 2: 2 forward slashes. SPECIFICATION FILE for class Aircraft. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, People dot h, double quotes. 
Line 5: hash include, double quotes, G List dot h, double quotes. 
Line 6: class Row Overflow. 2 forward slashes. More than 2
assigned to a row. 
Line 7: left brace, right brace, semicolon. 
Line 8: class Too Heavy. 2 forward slashes. Plane is too heavy to
take off. 
Line 9: left brace, right brace, semicolon. 
Line 10: class C of G Wrong. 2 forward slashes. Center of gravity
not within bounds. 
Line 11: left brace, right brace, semicolon. 
Line 12: class Aircraft. 
Line 13: left brace. 
Line 14: public, colon. 
Line 15, indented once: Aircraft, left parentheses, right parentheses,
semicolon. 
Line 16: blank. 
Line 17: 2 forward slashes. Knowledge responsibilities. 
Line 18, indented once: float Get Total Weight, left parentheses,
right parentheses, semicolon. 
Line 19, indented once: 2 forward slashes. Returns total weight. 
Line 20, indented once: float Get Center Of Gravity, left
parentheses, right parentheses, semicolon. 
Line 21, indented once: 2 forward slashes. calculates and returns
center of gravity. 
Line 22: blank. 
Line 23, indented once: 2 forward slashes. Action responsibilities. 
Line 24, indented once: void Set Closet And Fuel, left parentheses,
float closet W g t, comma, float fuel, right parentheses, semicolon. 
Line 25, indented once: 2 forward slashes. Post, colon, Closet
weight and fuel weight have been added to the total. 
Line 26, indented once: 2 forward slashes. weight, semicolon. 
Line 27, indented once: 2 forward slashes. Closet moment and fuel
moment have been added to total moment. 
Line 28, indented once: void Insert Passenger, left parentheses,
Name init Name, comma, float p Weight, comma, float b Weight,
comma. 

Line 29, indented multiple times: int row N o, right parentheses,
semicolon. 
Line 30, indented once: 2 forward slashes. Post, colon, Name and
role inserted into list, semicolon. 
Line 31, indented once: 2 forward slashes. Passenger and baggage
weight have been added to total weight, semicolon. 
Line 32, indented once: 2 forward slashes. Passenger and baggage
moment have been added to total moment. 
Line 33, indented once: void Insert Crew, left parentheses, Name init
Name, comma, float c Weight, right parentheses, semicolon. 
Line 34, indented once: 2 forward slashes. Post, colon, Name and
role inserted into list, semicolon. 
Line 35, indented once: 2 forward slashes. Crew weight added to
total weight, semicolon. 
Line 36, indented once: 2 forward slashes. Crew moment added to
total moment. 
Line 37, indented once: void Write Names On Board, left
parentheses, o f stream ampersand out File, right parentheses,
semicolon. 
Line 38, indented once: 2 forward slashes. Post, colon, Names and
role of all on board written to out File. 
Line 39: private, colon. 
Line 40, indented once: float weight, semicolon. 2 forward slashes.
Running weight. 
Line 41, indented once: float moment, semicolon. 2 forward slashes.
Running moments. 
Line 42, indented once: G List, left angled bracket, People, right
angled bracket, list, semicolon. 2 forward slashes. List of people on
board. 
Line 43, indented multiple times: 2 forward slashes. left
parentheses, People specialization of G List template, right
parentheses. 
Line 44: right brace, semicolon."
Back to Figure
Line 1: const float EMPTY underscore WEIGHT equals 9887.0,
semicolon. 2 forward slashes. Weight of empty airplane. Line 2:
const float EMPTY underscore MOMENT equals 3153953.0,

semicolon. 2 forward slashes. Moment of empty airplane. Line 3:
const float FUEL underscore WEIGHT equals 6.7, semicolon. 2
forward slashes. Fuel weight per gallon. Line 4: static int rows, left
square bracket, 4, right square bracket equals left brace 0, comma,
0, comma, 0, comma, 0, right brace, semicolon. 2 forward slashes.
Number in row. Line 5: static int row Distance, left square bracket, 4,
right square bracket, equals, left brace, 219, comma, 265, comma,
295, comma, 341, right brace, semicolon. 2 forward slashes.
Distance of row.
Back to Figure
"Program code. The words used in the variable names and function
names are merged. The code contains the following keywords:
include, const, float, static, int, if, else, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class
Aircraft. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Air Craft dot h, double quotes. 
Line 5: hash include, left angled bracket, f stream, right angled
bracket. 
Line 6: blank. 
Line 7: const float EMPTY underscore WEIGHT equals 9887.0,
semicolon. 2 forward slashes. Weight of empty airplane. 
Line 8: const float EMPTY underscore MOMENT equals 3153953.0,
semicolon. 2 forward slashes. Moment of empty airplane. 
Line 9: const float FUEL underscore WEIGHT equals 6.7,
semicolon. 2 forward slashes. Fuel weight per gallon. 
Line 10: static int rows, left square bracket, 4, right square bracket,
equals, left brace, 0, comma, 0, comma, 0, comma, 0, right
parentheses, semicolon. 2 forward slashes. Number in row. 
Line 11: blank. 
Line 12: static int row Distance, left square bracket, 4, right square
bracket, equals, left brace, 219, comma, 265, comma, 295, comma,
341, right brace, semicolon. 2 forward slashes. Distance of row. 
Line 13: blank. 
Line 14: Aircraft, colon, colon, Aircraft, left parentheses, right
parentheses. 

Line 15: left brace. 
Line 16, indented once: weight equals EMPTY underscore WEIGHT,
semicolon. 
Line 17, indented once: moment equals EMPTY underscore
MOMENT, semicolon. 
Line 18: right brace. 
Line 19: 2 forward slashes followed by asterisks till the end of the
line. 
Line 20: void Aircraft, colon, colon, set Closet And Fuel, left
parentheses, float close W g t, comma, float fuel, right parentheses.
Line 21: left brace. 
Line 22, indented once: float fuel W g t equals fuel asterisk FUEL
underscore WEIGHT, semicolon. 
Line 23, indented once: weight equals weight plus close W g t plus
fuel W g t, semicolon. 
Line 24, indented once: moment equals moment plus close W g t
asterisk 182, semicolon. 
Line 25, indented once: if, left parentheses, fuel less than 60, right
parentheses. 
Line 26, indented twice: moment equals moment plus 314.6 asterisk
fuel asterisk fuel W g t, semicolon. 
Line 27, indented once: else if, left parentheses, fuel less than 361,
right parentheses. 
Line 28, indented twice: moment equals moment plus, left
parentheses, 305.8, plus, left parentheses, negative 0.01233
asterisk, left parentheses, fuel minus 60, right parentheses, right
parentheses, right parentheses, asterisk, fuel W g t, semicolon. 
Line 29, indented once: else if, left parentheses, fuel less than 521,
right parentheses. 
Line 30, indented twice: moment equals moment plus, left
parentheses, 303.0, plus, left parentheses, 0.12500 asterisk, left
parentheses, fuel minus 361, right parentheses, right parentheses,
right parentheses, asterisk, fuel W g t, semicolon. 
Line 31, indented once: else. 
Line 32, indented twice: moment equals moment plus, left
parentheses, 323.0, plus, left parentheses, negative 0.0444 asterisk,
left parentheses, fuel minus 521, right parentheses, right
parentheses, right parentheses, asterisk, fuel W g t, semicolon. 
Line 33: right brace. 

Line 34: 2 forward slashes followed by asterisks till the end of the
line. 
Line 35: float Aircraft, colon, colon, Get Total Weight, left
parentheses, right parentheses. 
Line 36: left brace, return weight, semicolon, right brace. 
Line 37: 2 forward slashes followed by asterisks till the end of the
line. 
Line 38: float Aircraft, colon, colon, Get Center Of Gravity, left
parentheses, right parentheses. 
Line 39: left brace, return moment, forward slash, weight,
semicolon, right brace. 
Line 40: 2 forward slashes followed by asterisks till the end of the
line. 
Line 41: void Aircraft, colon, colon, Insert Passenger, left
parentheses, Name init Name, comma, float p Weight, comma. 
Line 42, indented multiple times: float b Weight, comma, int row N o,
right parentheses. 
Line 43: left parentheses. 
Line 44, indented once: weight equals weight plus p Weight plus b
Weight, semicolon. 
Line 45, indented once: rows, left square bracket, row N o, minus, 1,
right square bracket, plus, plus, semicolon. 
Line 46, indented once: if, left parentheses, rows, left square
bracket, row N o, minus, 1, right square bracket, greater than 2,
right parentheses. 
Line 47, indented twice: throw Row Overflow, left parentheses, right
parentheses, semicolon. 
Line 48, indented once: moment, equals, moment, plus, p Weight,
asterisk, row Distance, left square bracket, row N o, minus, 1, right
square brackets, plus, b Weight, asterisk, 386, semicolon."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords: void,
float, while, if, else, end l.
Line 1, indented once: People person, left parentheses, init Name,
comma, single quote, uppercase p, single quote, right parentheses,
semicolon. 

Line 2, indented once: list dot Insert, left parentheses, person, right
parentheses, semicolon. 
Line 3: right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: void Aircraft, colon, colon, Insert Crew, left parentheses,
Name init Name, comma, float c Weight, right parentheses. 
Line 6: left brace. 
Line 7, indented once: weight equals weight plus c Weight,
semicolon. 
Line 8, indented once: moment equals moment plus c Weight
asterisk 143, semicolon. 
Line 9, indented once: People person, left parentheses, init Name,
comma, single quote, uppercase c, single quote, right parentheses,
semicolon. 
Line 10, indented once: list dot Insert, left parentheses, person, right
parentheses, semicolon. 
Line 11: right brace. 
Line 12: 2 forward slashes followed by asterisks till the end of the
line. 
Line 13: void Aircraft, colon, colon, Write Names On Board, left
parentheses, o f stream ampersand out File, right parentheses. 
Line 14: left brace. 
Line 15, indented once: list dot Reset List, left parentheses, right
parentheses, semicolon. 
Line 16, indented once: People person, left parentheses, right
parentheses, semicolon. 
Line 17, indented once: while, left parentheses, list dot Has Next, left
parentheses, right parentheses, right parentheses. 
Line 18, indented once: left parentheses. 
Line 29, indented twice: person equals list dot Get Next Item, left
parentheses, right parentheses, semicolon. 
Line 30, indented twice: out File, 2 left angled brackets, person dot
Get Name, left parentheses, right parentheses, dot, Get First Name,
left parentheses, right parentheses, 2 left angled brackets, double
quotes, blank space, double quotes. 
Line 31, indented multiple times: 2 left angled brackets, person dot
Get Name, left parentheses, right parentheses, dot, Get Last Name,
left parentheses, right parentheses, semicolon. 
Line 32, indented twice: if, left parentheses, person dot Get Role,

left parentheses, right parentheses, equals, equals, single quote,
uppercase c, single quote, right parentheses. 
Line 33, indented thrice: out File, 2 left angled brackets, double
quotes, blank space, left parentheses, Crew, right parentheses,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 34, indented twice: else. 
Line 35, indented thrice: out File, 2 left angled brackets, double
quotes, blank space, left parentheses, Passenger, right
parentheses, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 36, indented once: right brace. 
Line 37: right brace."
Back to Figure
The description of the C R C card is as follows. Class Name: User
Interface. Superclass: blank. Responsibilities: Create User Interface.
Collaborations: blank. Responsibilities: Input Closet and fuel.
Collaborations: I o stream. Responsibilities: Input Crew.
Collaborations: Aircraft. Responsibilities: Input Passenger.
Collaborations: Aircraft. Responsibilities: Close Doors.
Collaborations: Aircraft.
Back to Figure
"Program code. The words in the function names are merged. The
code contains the following keywords: include, class, public, void,
private. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE for class User
Interface. 
Line 3: 2 forward slashes. This class acts as the gate agent. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, double quotes, Aircraft dot h, double quotes. 
Line 7: class User Interface. 
Line 8: left brace. 
Line 9: public, colon. 

Line 10, indented once: User Interface, left parentheses, right
parentheses, semicolon. 
Line 11, indented once: 2 forward slashes. Action responsibilities. 
Line 12, indented once: void Input Closet And Fuel, left parentheses,
right parentheses, semicolon. 
Line 13, indented once: void Input Crew, left parentheses, right
parentheses, semicolon. 
Line 14, indented once: void Input Passenger, left parentheses, right
parentheses, semicolon. 
Line 15, indented once: void Close Doors, left parentheses, o f
stream ampersand out File, right parentheses, semicolon. 
Line 16: private, colon. 
Line 17, indented once: Aircraft plane, semicolon. 
Line 18: right brace, semicolon."
Back to Figure
"Program code. The code contains the keyword include. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class User
Interface. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, User Interface dot h, double
quotes. 
Line 5: hash include, left angled bracket, i o stream, right angled
bracket."
Back to Figure
"Program code. The words in the function names and keywords are
merged. The code contains the following keywords: include, using,
name space, s t d, void, float, c out, end l, c in, string, int. 
Line 1: hash include, left angled bracket, f stream, right angled
bracket. 
Line 2: hash include, left angled bracket, string, right angled bracket.
Line 3: using name space s t d, semicolon. 
Line 4: blank. 
Line 5: User Interface, colon, colon, User Interface, left
parentheses, right parentheses. 

Line 6: left brace, right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: void User Interface, colon, colon, Input Closet And Fuel, left
parentheses, right parentheses. 
Line 9: left brace. 
Line 10, indented once: float closet, semicolon. 
Line 11, indented once: float fuel, semicolon. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Enter the closet weight and the gallons of fuel, double quotes. 
Line 13, indented twice: 2 left angled brackets, end l, semicolon. 
Line 14, indented once: c in, 2 right angled brackets, closet, 2 right
angled brackets, fuel, semicolon. 
Line 15, indented once: plane dot Set Closet And Fuel, left
parentheses, closet, comma, fuel, right parentheses, semicolon. 
Line 16: right brace. 
Line 17: 2 forward slashes followed by asterisks till the end of the
line. 
Line 18: void User Interface, colon, colon, Input Crew, left
parentheses, right parentheses. 
Line 19: left brace. 
Line 20, indented once: string first, semicolon. 
Line 21, indented once: string last, semicolon. 
Line 22, indented once: float weight, semicolon. 
Line 23, indented once: c out, 2 left angled brackets, double quotes,
Enter first name, comma, last name, comma, weight of crew
member, double quotes, 2 left angled brackets. 
Line 24: end l, semicolon. 
Line 25, indented once: c in, 2 right angled brackets, first, 2 right
angled brackets, last, 2 right angled brackets, weight, semicolon. 
Line 26, indented once: Name name, left angled bracket, first,
comma, double quotes, blank space, double quotes, comma, last,
right parentheses, semicolon. 
Line 27, indented once: plane dot Insert Crew, left parentheses,
name, comma, weight, right parentheses, semicolon. 
Line 28: right brace. 
Line 29: 2 forward slashes followed by asterisks till the end of the
line. 
Line 30: void User Interface, colon, colon, Input Passenger, left
parentheses, right parentheses. 

Line 31: left brace. 
Line 32, indented once: string first, semicolon. 
Line 33, indented once: string last, semicolon. 
Line 34, indented once: float weight, semicolon. 
Line 35, indented once: float baggage, semicolon. 
Line 36, indented once: int row N o, semicolon. 
Line 37, indented once: c out, 2 left angled brackets, double quotes,
Enter first name, comma, last name of passenger, comma, blank
space, double quotes, 2 left angled brackets, end l, semicolon. 
Line 38, indented once: c out, 2 left angled brackets, double quotes,
passenger’s weight, comma, and weight of luggage, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 39, indented once: c in, 2 right angled brackets, first, 2 right
angled brackets, last, 2 right angled brackets, weight, 2 right angled
brackets, baggage, semicolon. 
Line 40, indented once: c out, 2 left angled brackets, double quotes,
Enter row number, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 41, indented once: c in, 2 right angled brackets, row N o,
semicolon. 
Line 42, indented once: Name name, left parentheses, first, comma,
double quotes, blank space, double quotes, comma, last, right
parentheses, semicolon. 
Line 43, indented once: plane dot Insert Passenger, left
parentheses, name, comma, weight, comma, baggage, comma, row
N o, right parentheses, semicolon. 
Line 44: right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: void, float, c out,
end l, if, throw, else. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void User Interface, colon, colon, Close Doors, left
parentheses, o f stream ampersand out File, right parentheses. 
Line 3: left brace. 
Line 4, indented once: float weight equals plane dot Get Total
Weight, left parentheses, right parentheses, semicolon. 

Line 5, indented once: c out, 2 left angled brackets, double quotes,
Weight, colon, blank space, double quotes, 2 left angled brackets,
weight, 2 left angled brackets, end l, semicolon. 
Line 6, indented once: float C o f G equals plane dot Get Center Of
Gravity, left parentheses, right parentheses, semicolon. 
Line 7, indented once: c out, 2 left angled brackets, double quotes,
Center of Gravity, colon, blank space, double quotes, 2 left angled
brackets, C o f G, 2 left angled brackets, end l, semicolon. 
Line 8, indented once: if, left parentheses, weight, greater than,
14440, right parentheses. 
Line 9, indented twice: throw Too Heavy, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: else if, left parentheses, C o f G less than
307, 2 pipes, C o f G greater than 321, right parentheses. 
Line 11, indented twice: throw C o f G Wrong, left parentheses, right
parentheses, semicolon. 
Line 12, indented once: else. 
Line 13, indented twice: plane dot Write Names On Board, left
parentheses, out File, right parentheses, semicolon. 
Line 14: right brace."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
include, using, name space, s t d, int, main, c out, end l, c in, try, for.
Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: hash include, double quotes, User Interface dot h, double
quotes. 
Line 3: hash include, left angled bracket, f stream, right angled
bracket. 
Line 4: using name space s t d, semicolon. 
Line 5: int main, left parentheses, right parentheses. 
Line 6: left brace. 
Line 7, indented once: User Interface gate Agent, semicolon. 
Line 8, indented once: o f stream out File, semicolon. 
Line 9, indented once: int crew, semicolon. 2 forward slashes.
Number of crew members. 

Line 10, indented once: int passengers, semicolon. 2 forward
slashes. Number of passengers. 
Line 11, indented once: out File dot open, left parentheses, double
quotes, Passenger List, double quotes, right parentheses,
semicolon. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Enter number of crew members, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 13, indented once: c in, 2 right angled brackets, crew,
semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter number of passengers, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 15, indented once: c in, 2 right angled brackets, passengers,
semicolon. 
Line 16, indented once: try. 
Line 17, indented once: left brace. 
Line 18, indented twice: gate Agent dot Input Closet And Fuel, left
parentheses, right parentheses, semicolon. 
Line 19, indented twice: for, left parentheses, int number equals 1,
semicolon, number less than or equal to crew, semicolon, number
plus plus, right parentheses. 
Line 20, indented thrice: gate Agent dot Input Crew, left
parentheses, right parentheses, semicolon. 
Line 21, indented twice: for, left parentheses, int number equals 1,
semicolon, number less than or equal to passengers, semicolon,
number plus plus, right parentheses. 
Line 22, indented thrice: gate Agent dot Input Passenger, left
parentheses, right parentheses, semicolon."
Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: catch, c out, return, end l. 
Line 1, indented twice: gate Agent dot Close Doors, left
parentheses, out File, right parentheses, semicolon. 
Line 2, indented once: right brace. 
Line 3, indented once: catch, left parentheses, Too Heavy, right
parentheses. 

Line 4, indented once: left brace. 
Line 5, indented twice: c out, 2 left angled brackets, double quotes,
Cancel flight, colon, Weight is too heavy, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 6, indented once: right brace. 
Line 7, indented once: catch, left parentheses, C o f G Wrong, right
parentheses. 
Line 8, indented once: left brace. 
Line 9, indented twice: c out, 2 left angled brackets, double quotes,
Cancel flight, colon, Center of gravity exceeds limits, blank space,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 10, indented once: right brace. 
Line 11, indented once: catch, left parentheses, Row Overflow, right
parentheses. 
Line 12, indented once: left brace. 
Line 13, indented twice: c out, 2 left angled brackets, double quotes,
Too many passengers assigned to one row, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 14, indented once: right brace. 
Line 15, indented once: return 0, semicolon. 
Line 16: right brace."
Back to Figure
Line 1: Enter number of crew members. Line 2: 2. Line 2 is shaded.
Line 3: Enter number of passengers. Line 4: 3. Line 4 is shaded.
Back to Figure
The components are as follows. 1. Passenger or Crew Entry Form
Widget. 2. Passenger Manifest Table Widget. 3. Crew Manifest
Table Widget. 4. Closet Weight or Fuel Entry Form Widget. 5.
Weight or C o f G Display Widget.
Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: include, using, name space, s
t d, class, public, private, null p t r, int, string.

Line 1: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: using name space s t d, semicolon. 
Line 4: blank. 
Line 5: class Passenger Manifest Widget, colon, public, Q Widget. 
Line 6: left brace. 
Line 7, indented once: Q underscore OBJECT. 
Line 8: public, colon. 
Line 9, indented once: Passenger Manifest Widget, left parentheses,
Q Widget asterisk parent equals null p t r, right parentheses,
semicolon. 
Line 10, indented once: void Add Passenger, left parentheses, string
first Name, comma, string last Name, comma, int row, comma, int
weight, comma. 
Line 11, indented multiple times: int baggage Weight, right
parentheses, semicolon. 
Line 12: blank. 
Line 13: private, colon. 
Line 14, indented once: Q Tab Widget asterisk table, semicolon. 
Line 15, indented once: int row Count, semicolon. 
Line 16: right brace, semicolon."
Back to Figure
"Program code. The words in the file name, function names and
variable names are merged. The code contains the following
keywords: include, new. 
Line 1: hash include, double quotes, Passenger Manifest Widget dot
h, double quotes. 
Line 2: blank. 
Line 3: Passenger Manifest Widget, colon, colon, Passenger
Manifest Widget, left parentheses, Q Widget asterisk parent, right
parentheses. 
Line 4, indented twice: colon, Q Widget, left parentheses, parent,
right parentheses. 
Line 5: left brace. 
Line 6, indented once: row Count equals 0, semicolon. 2 forward
slashes. Initialize rows to 0. 

Line 7, indented once: Q Label asterisk label equals new Q Label,
left parentheses, double quotes, Passenger Manifest, double
quotes, right parentheses, semicolon. 2 forward slashes. Create a
label. 
Line 8, indented once: 2 forward slashes. Create a table widget an
set the number of columns and rows. 
Line 9, indented once: table equals new Q Table Widget, semicolon. 
Line 10, indented once: table, hyphen, right angled bracket, set
Column Count, left parentheses, 4, right parentheses, semicolon. 
Line 11, indented once: table, hyphen, right angled bracket, set Row
Count, left parentheses, row Count, right parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Create a list of strings to
use for column headings. 
Line 13, indented once: Q String List headers equals left brace,
double quotes, Name, double quotes, comma, double quotes, Row,
double quotes, comma, double quotes, Weight, double quotes,
comma, double quotes, Baggage Weight, double quotes, right
brace, semicolon. 
Line 14, indented once: table, hyphen, right angled bracket, set
Horizontal Header Labels, left parentheses, headers, right
parentheses, semicolon. 
Line 15, indented once: 2 forward slashes. Put the label and table in
a vertical layout. 
Line 16, indented once: Q V Box Layout asterisk layout equals new
Q V Box Layout, semicolon. 
Line 17, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, label, right parentheses, semicolon. 
Line 18, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, table, right parentheses, semicolon. 
Line 19, indented once: 2 forward slashes. Make this widget use the
layout. 
Line 20, indented once: set Layout, left parentheses, layout, right
parentheses, semicolon. 
Line 21: right brace."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords: void,

string, int. 
Line 1: void Passenger Manifest Widget, colon, colon, Add
Passenger, left parentheses, string first Name, comma, string last
Name, comma. 
Line 2, indented multiple times: int row, comma, int weight, comma. 
Line 3, indented multiple times: int baggage Weight, right
parentheses. 
Line 4: left brace. 
Line 5, indented once: 2 forward slashes. Convert strings to Q
Strings. 
Line 6, indented once: Q String q first Name equals Q String, colon,
colon, from S t d String, left parentheses, first Name, right
parentheses, semicolon. 
Line 7, indented once: Q String q last Name equals Q String, colon,
colon, from S t d String, left parentheses, last Name, right
parentheses, semicolon."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the keyword new. 
Line 1, indented once: Q String q row equals Q String, colon, colon,
number, left parentheses, row, right parentheses, semicolon. 
Line 2, indented once: Q String q weight equals Q String, colon,
colon, number, left parentheses, weight, right parentheses,
semicolon. 
Line 3, indented once: Q String q baggage Weight equals Q String,
colon, colon, number, left parentheses, baggage Weight, right
parentheses, semicolon. 
Line 4, indented twice: 2 forward slashes. Build table entry objects. 
Line 5, indented twice: Q Table Widget Item asterisk name Item
equals new Q Table Widget Item, left parentheses, q first Name plus
q last Name, right parentheses, semicolon. 
Line 6, indented twice: Q Table Widget Item asterisk row Item
equals new Q Table Widget Item, left parentheses, q row, right
parentheses, semicolon. 
Line 7, indented twice: Q Table Widget Item asterisk weight Item
equals new Q Table Widget Item, left parentheses, q weight, right
parentheses, semicolon. 

Line 8, indented twice: Q Table Widget Item asterisk baggage
Weight Item equals new Q Table Widget Item, left parentheses, q
baggage Weight, right parentheses, semicolon. 
Line 9, indented once: 2 forward slashes. Add the objects to the
table in the current row and appropriate column. 
Line 10, indented once: table, hyphen, right angled bracket, insert
Row, left parentheses, row Count, right parentheses, semicolon. 
Line 11, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 0, comma, name Item,
right parentheses, semicolon. 
Line 12, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 1, comma, row Item,
right parentheses, semicolon.
Line 13, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 2, comma, weight Item,
right parentheses, semicolon.
Line 14, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 3, comma, baggage
Weight Item, right parentheses, semicolon.
Line 15, indented once: 2 forward slashes. Go to the next row. 
Line 16, indented once: row Count, plus, plus. 
Line 17: right brace."
Back to Figure
"Program code. The words in the variable names, file names, and
function names are merged. The code contains the following
keywords: include, using, name space, s t d, class, public, void, null
p t r, string, int, private. 
Line 1: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: using name space s t d, semicolon. 
Line 4: blank. 
Line 5: class Crew Manifest Widget, colon, public Q Widget. 
Line 6: left brace. 
Line 7, indented once: Q underscore OBJECT. 
Line 8: public, colon. 
Line 9, indented once: Crew Manifest Widget, left parentheses, Q

Widget asterisk parent equals null p t r, right parentheses,
semicolon. 
Line 10, indented once: void Add Crew, left parentheses, string first
Name, comma, string last Name, comma, int weight, right
parentheses, semicolon. 
Line 11: blank. 
Line 12: private, colon. 
Line 13, indented once: Q Table Widget asterisk table, semicolon. 
Line 14, indented once: int row Count, semicolon. 
Line 15: right brace, semicolon. 
Line 16: hash include, double quotes, Crew Manifest Widget dot h,
double quotes. 
Line 17: Crew Manifest Widget, colon, colon, Crew Manifest Widget,
left parentheses, Q Widget asterisk parent, right parentheses, colon,
Q Widget, left parentheses, parent, right parentheses. 
Line 18: left brace."
Back to Figure
"Program code. The words used in the variable names, and function
names are merged. The code contains the following keywords: new,
void, string, int.
Line 1, indented once: row Count equals 0, semicolon. 2 forward
slashes. Initialize rows to.
Line 2, indented once: Q Label asterisk label equals new Q Label,
left parentheses, double quotes, Crew Manifest, double quotes, right
parentheses, semicolon. 2 forward slashes. Create a label. 
Line 3, indented once: 2 forward slashes. Create a table widget and
set the number of columns and rows. 
Line 4, indented once: table equals new Q Table Widget, semicolon. 
Line 5, indented once: table, hyphen, right angled bracket, set
Column Count, left parentheses, 2, right parentheses, semicolon. 
Line 6, indented once: table, hyphen, right angled bracket, set Row
Count, left parentheses, row Count, right parentheses, semicolon. 
Line 7, indented once: 2 forward slashes. Create a list of strings to
use for column headings. 
Line 8, indented once: Q String List headers equals, left brace,
double quotes, Name, double quotes, comma, double quotes,
Weight, double quotes, right brace, semicolon. 

Line 9, indented once: table, hyphen, right angled bracket, set
Horizontal Header Labels, left parentheses, headers, right
parentheses, semicolon. 
Line 10, indented once: 2 forward slashes. Put the label and table in
a vertical layout. 
Line 11, indented once: Q V Box Layout asterisk layout equals new
Q V Box Layout, semicolon. 
Line 12, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, label, right parentheses, semicolon. 
Line 13, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, table, right parentheses, semicolon. 
Line 14, indented once: 2 forward slashes. Make this widget use the
layout. 
Line 15, indented once: set Layout, left parentheses, layout, right
parentheses, semicolon. 
Line 16: right brace. 
Line 17: void Crew Manifest Widget, colon, colon, Add Crew, left
parentheses, string first Name, comma, string last Name, comma.
Line 18, indented multiple times: int weight, right parentheses.
Line 19: left brace. 
Line 20, indented once: 2 forward slashes. Convert strings to Q
Strings. 
Line 21, indented once: Q String q first Name equals Q String,
colon, colon, from S t d String, left parentheses, first Name, right
parentheses, semicolon. 
Line 22, indented once: Q String q last Name equals Q String, colon,
colon, from S t d String, left parentheses, last Name, right
parentheses, semicolon. 
Line 23, indented once: Q String q weight equals Q String, colon,
colon, number, left parentheses, weight, right parentheses,
semicolon. 
Line 24, indented once: 2 forward slashes. Build table entry objects. 
Line 25, indented once: Q Table Widget Item asterisk name Item
equals. 
Line 26, indented twice: new Q Table Widget Item, left parentheses,
q first Name, plus, double quotes, blank space, double quotes, plus,
q last Name, right parentheses, semicolon. 
Line 27, indented once: Q Table Widget Item asterisk weight Item
equals new Q Table Widget Item, left parentheses, q weight, right

parentheses, semicolon. 
Line 28, indented once: 2 forward slashes. Add the objects to the
table in the current row and appropriate column. 
Line 29, indented once: table, hyphen, right angled bracket, insert
Row, left parentheses, row Count, right parentheses, semicolon. 
Line 30, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 0, comma, name Item,
right parentheses, semicolon. 
Line 31, indented once: table, hyphen, right angled bracket, set
Item, left parentheses, row Count, comma, 1, comma, weight Item,
right parentheses, semicolon. 
Line 32, indented once: 2 forward slashes. Go to the next row. 
Line 33, indented once: row Count, plus, plus, semicolon. 
Line 34, indented once: right brace."
Back to Figure
"Program code. The words in the variable names, and function
names are merged. The code contains the following keywords:
class, public, null p t r, float, void. 
Line 1: class Weight And C o f G Widget, colon, public Q Widget. 
Line 2: left brace. 
Line 3, indented once: Q underscore OBJECT. 
Line 4: public, colon. 
Line 5, indented once: Weight And C o f G Widget, left parentheses,
Q Widget asterisk parent equals null p t r, right parentheses,
semicolon. 
Line 6, indented once: void Set Total Weight, left parentheses, float
weight, right parentheses, semicolon."
Back to Figure
"Program code. The words I the function names and variable names
are merged. The code contains the following keywords: void, float,
private. 
Line 1, indented once: void Set C o f G, left parentheses, float c o f
g, right parentheses, semicolon. 
Line 2: blank. 
Line 3: private, colon. 

Line 4, indented once: Q Label asterisk total Weight Label,
semicolon. 
Line 5, indented once: Q Label asterisk c o f g Label, semicolon. 
Line 6: right brace, semicolon."
Back to Figure
"Program code. The words used in the file name, function names,
and variable names are merged. The code contains the following
keywords: include, void. 
Line 1: hash include, double quotes, Weight And C o f G Widget dot
h, double quotes. 
Line 2: blank. 
Line 3: Weight And C o f G Widget, colon, colon, Weight And C o f
G Widget, left parentheses, Q Widget asterisk parent, right
parentheses, colon, Q Widget, left parentheses, parent, right
parentheses. 
Line 4: left brace. 
Line 5, indented once: Q Label asterisk total Weight Displayed Label
equals new Q Label, left parentheses, double quotes, Total Weight,
colon, double quotes, comma, this, right parentheses, semicolon. 
Line 6, indented once: Q Label asterisk c o f g Displayed Label
equals new Q Label, left parentheses, double quotes, Center of
Gravity, colon, double quotes, comma, this, right parentheses,
semicolon. 
Line 7: blank. 
Line 8, indented once: total Weight Label equals new Q Label, left
parentheses, double quotes, double quotes, comma, this, right
parentheses, semicolon. 
Line 9, indented once: c o f g Label equals new Q Label, left
parentheses, double quotes, double quotes, comma, this, right
parentheses, semicolon. 
Line 10: blank. 
Line 11, indented once: Q Grid Layout asterisk layout equals new Q
Grid Layout, left parentheses, this, right parentheses, semicolon. 
Line 12: blank. 
Line 13, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, total Weight Displayed Label, comma, 0,
comma, 0, right parentheses, semicolon. 

Line 14, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, total Weight Label, comma, 0, comma, 1,
right parentheses, semicolon. 
Line 15, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, c o f g Displayed Label, comma, 1,
comma, 0, right parentheses, semicolon. 
Line 16, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, c o f g Label, comma, 1, comma, 1, right
parentheses, semicolon. 
Line 17: blank. 
Line 18, indented once: set Layout, left parentheses, layout, right
parentheses, semicolon. 
Line 19: right brace. 
Line 20: void Weight And C o f G Widget, colon, colon, Set Total
Weight, left parentheses, float weight, right parentheses. 
Line 21: left brace. 
Line 22, indented once: Q String q weight equals Q String, colon,
colon, number, left parentheses, weight, right parentheses,
semicolon. 
Line 23, indented once: total Weight Label, hyphen, right angled
bracket, set Text, left parentheses, q weight, right parentheses,
semicolon. 
Line 24: right brace. 
Line 25: blank. 
Line 26: void Weight And C o f G Widget, colon, colon, Set C o f G,
left parentheses, float c o f g, right parentheses. 
Line 27: left brace. 
Line 28, indented once: Q String q c o f g equals Q String, colon,
colon, number, left parentheses, c o f g, right parentheses,
semicolon. 
Line 29, indented once: c o f g Label, hyphen, right angled bracket,
set Text, left parentheses, q c o f g, right parentheses, semicolon. 
Line 30: right brace."
Back to Figure
"The description of the form from top to bottom is as follows. 
Text label: First Name. A blank text box. 
Text label: Last Name. A blank text box. 

Text label: Weight. A blank text box. 
Text label: Baggage Weight. A blank text box. 
Text label: Row. A drop down box with 0, comma, 1, comma, 2,
comma, 3, selected. 
Text label: Passenger Type. A drop down box with Passenger,
comma, Crew selected. 
A button labeled Add."
Back to Figure
"The widgets in the Form are as follows: Passenger or Crew Entry
Form widget, Passenger Manifest Table Widget, Crew Manifest
Table Widget, Closet Weight or Fuel Entry Form Widget, and Weight
or C o f G Display Widget. A dashed arrow is drawn from the
Passenger or Crew Entry Form Widget to the other 4 widgets. A
double headed arrow is drawn between the Passenger or Crew
Entry Form Widget to the block labeled Aircraft."
Back to Figure
"Program code. The words in the file names, variable names, and
function names are merged. The code contains the following
keywords: include, class, public, private. 
Line 1: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: hash include, double quotes, Aircraft dot h, double quotes. 
Line 4: hash include, double quotes, Crew Manifest Widget dot h,
double quotes. 
Line 5: hash include, double quotes, Passenger Manifest Widget dot
h, double quotes. 
Line 6: hash include, double quotes, Weight And C o f G Widget dot
h, double quotes. 
Line 7: blank. 
Line 8: class Passenger Form Widget, colon, public Q Widget. 
Line 9: left brace. 
Line 10, indented once: Q underscore OBJECT. 
Line 11: public: 
Line 12, indented once: Passenger Form Widget, left parentheses,

Aircraft ampersand aircraft Init, comma. 
Line 13, indented multiple times: Passenger Manifest Widget. 
Line 14, indented multiple times: asterisk passenger Manifest
Widget Init, comma. 
Line 15, indented multiple times: Crew Manifest Widget asterisk
crew Manifest Widget Init, comma. 
Line 16, indented multiple times: Weight And C o f G Widget asterisk
weight And C o f G Widget Init, comma. 
Line 17, indented multiple times: Q Widget asterisk parent equals
null p t r, right parentheses, semicolon. 
Line 18: private, colon. 
Line 19, indented once: Q Line Edit asterisk first Name Line Edit,
semicolon."
Back to Figure
"Program code. The words used in the variable names, and function
names are merged. The code contains the following keywords: void,
bool, private, slots. 
Line 1, indented once: Q Line Edit asterisk last Name Line Edit,
semicolon. 
Line 2, indented once: Q Line Edit asterisk weight Line Edit,
semicolon. 
Line 3, indented once: Q Line Edit asterisk weight Baggage Line
Edit, semicolon. 
Line 4, indented once: Q Combo Box asterisk row Combo Box,
semicolon. 
Line 5, indented once: Q Combo Box asterisk passenger Type
Combo Box, semicolon. 
Line 6, indented once: Q Label asterisk messages, semicolon. 
Line 7, indented once: Aircraft ampersand aircraft, semicolon. 
Line 8, indented once: Passenger Manifest Widget asterisk
passenger Manifest Widget, semicolon. 
Line 9, indented once: Crew Manifest Widget asterisk crew Manifest
Widget, semicolon. 
Line 10, indented once: Weight And C o f G Widget asterisk weight
And C o f G Widget, semicolon. 
Line 11: blank. 
Line 12, indented once: void Handle Adding Passenger, left

parentheses, right parentheses, semicolon. 
Line 13, indented once: void Handle Adding Crew, left parentheses,
right parentheses, semicolon. 
Line 14, indented once: bool Is Valid Passenger, left parentheses,
right parentheses, semicolon. 
Line 15, indented once: bool Is Valid Passenger, left parentheses,
right parentheses, semicolon. 
Line 16, indented once: bool Is Valid Crew, left parentheses, right
parentheses, semicolon. 
Line 17, indented once: void Handle Adding Weight, left
parentheses, right parentheses, semicolon. 
Line 18, indented once: void Handle Adding C o f G, left
parentheses, right parentheses, semicolon. 
Line 19: blank. 
Line 20: blank. 
Line 21: private slots, colon. 
Line 22, indented once: void Handle Combo Box Activated, left
parentheses, const Q String ampersand text, right parentheses,
semicolon. 
Line 23, indented once: void Handle Add Button Clicked, left
parentheses, right parentheses, semicolon. 
Line 24: right brace, semicolon."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the keyword include. 
Line 1: hash include, double quotes, Passenger Form Widget dot h,
double quotes. 
Line 2: blank. 
Line 3: Passenger Form Widget, colon, colon, Passenger Form
Widget, left parentheses. 
Line 4, indented once: Aircraft ampersand aircraft Init, comma. 
Line 5, indented once: Passenger Manifest Widget asterisk
passenger Manifest Widget Init, comma. 
Line 6, indented once: Crew Manifest Widget asterisk crew Manifest
Widget Init, comma. 
Line 7, indented once: Weight And C o f G Widget asterisk weight
And C o f G Widget Init, comma."

Back to Figure
"Program code. The words in the variable names and function
names are merged. 
Line 1, indented once: Q Widget asterisk parent, right parentheses,
semicolon. 2 forward slashes. Initializer list. 
Line 2, indented twice: aircraft, left parentheses, aircraft Init, right
parentheses, comma. 
Line 3, indented twice: passenger Manifest Widget, left parentheses,
passenger Manifest Widget Init, right parentheses, comma. 
Line 4, indented twice: crew Manifest Widget, left parentheses, crew
Manifest Widget Init, right parentheses, comma. 
Line 5, indented twice: weight And C o f G Widget, weight And C o f
G Widget Init, right parentheses, comma. 
Line 6, indented twice: Q Widget, left parentheses, parent, right
parentheses. 
Line 7: left brace. 
Line 8, indented once: 2 forward slashes. Initialize the labels first. 
Line 9, indented once: Q Label asterisk first Name Label equals new
Q Label, left parentheses, double quotes, First, blank space, Name,
double quotes, comma, this, right parentheses, semicolon. 
Line 10, indented once: Q Label asterisk last Name Label equals
new Q Label, left parentheses, double quotes, Last, blank space,
Name, double quotes, comma, this, right parentheses, semicolon. 
Line 11, indented once: Q Label asterisk weight Label equals new Q
Label, left parentheses, double quotes, Weight, double quotes,
comma, this, right parentheses, semicolon. 
Line 12, indented once: Q Label asterisk weight Baggage Label
equals new Q Label, left parentheses, double quotes, Baggage
Weight, double quotes, comma, this, right parentheses, semicolon. 
Line 13, indented once: Q Label asterisk passenger Type Label
equals new Q Label, left parentheses, double quotes, Passenger
Type, double quotes, comma, this, right parentheses, semicolon. 
Line 14, indented once: Q Label asterisk row Label equals new Q
Label, left parentheses, double quotes, Row, double quotes, comma,
this, right parentheses, semicolon. 
Line 15, indented once: Set up the text boxes. 
Line 16, indented once: first Name Line Edit equals new Q Line Edit,
left parentheses, this, right parentheses, semicolon. 

Line 17, indented once: last Name Line Edit equals new Q Line Edit,
left parentheses, this, right parentheses, semicolon. 
Line 18, indented once: weight Line Edit equals new Q Line Edit, left
parentheses, this, right parentheses, semicolon. 
Line 19, indented once: weight Baggage Line Edit equals new Q Line
Edit, left parentheses, this, right parentheses, semicolon. 
Line 20, indented once: 2 forward slashes. Set up the passenger
type drop, hyphen, down menu. 
Line 21, indented once: passenger Type Combo Box equals new Q
Combo Box, left parentheses, this, right parentheses, semicolon. 
Line 22, indented once: passenger Type Combo Box, hyphen, right
angled bracket, set Editable, left parentheses, false, right
parentheses, semicolon. 
Line 23, indented once: passenger Type Combo Box, hyphen, right
angled bracket, add Item, left parentheses, double quotes,
Passenger, double quotes, right parentheses, semicolon. 
Line 24, indented once: passenger Type Combo Box, hyphen, right
angled bracket, add Item, left parentheses, double quotes, Crew,
double quotes, right parentheses, semicolon. 
Line 25, indented once: 2 forward slashes. Set up the row number
drop, hyphen, down menu. 
Line 26, indented once: row Combo Box equals new Q Combo Box,
left parentheses, this, right parentheses, semicolon. 
Line 27, indented once: row Combo Box, hyphen, right angled
bracket, add Item, left parentheses, double quotes, 0, double
quotes, right parentheses, semicolon. 
Line 28, indented once: row Combo Box, hyphen, right angled
bracket, add Item, left parentheses, double quotes, 1, double
quotes, right parentheses, semicolon. 
Line 29, indented once: row Combo Box, hyphen, right angled
bracket, add Item, left parentheses, double quotes, 2, double
quotes, right parentheses, semicolon.
Line 30, indented once: row Combo Box, hyphen, right angled
bracket, add Item, left parentheses, double quotes, 3, double
quotes, right parentheses, semicolon.
Line 31, indented once: 2 forward slashes. Create the Add button. 
Line 32, indented once: Q Push Button asterisk add Button equals
new Q Push Button, left parentheses, double quotes, Add, double
quotes, comma, this, right parentheses, semicolon. 

Line 33, indented once: 2 forward slashes. Create a label for
warning messages. 
Line 34, indented once: messages equals new Q Label, left
parentheses, double quotes, double quotes, right parentheses,
semicolon. 
Line 35, indented once: 2 forward slashes. Create a grid layout. 
Line 36, indented once: Q Grid Layout asterisk layout equals new Q
Grid Layout, left parentheses, this, right parentheses, semicolon. 
Line 37, indented Once: 2 forward slashes. Insert labels, comma,
text boxes, comma, and drop downs using row and column. 
Line 38, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, first Name Label, comma, 0, comma, 0,
right parentheses, semicolon. 
Line 39, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, last Name Label, comma, 1, comma, 0,
right parentheses, semicolon.
Line 40, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, weight Label, comma, 2, comma, 0, right
parentheses, semicolon.
Line 41, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, weight Baggage Label, comma, 3, comma,
0, right parentheses, semicolon.
Line 42, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, row Label, comma, 4, comma, 0, right
parentheses, semicolon.
Line 43, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, passenger Type Label, comma, 5, comma,
0, right parentheses, semicolon.
Line 44, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, first Name Line Edit, comma, 0, comma,
1, right parentheses, semicolon.
Line 45, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, last Name Line Edit, comma, 1, comma, 1,
right parentheses, semicolon.
Line 46, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, weight Line Edit, comma, 2, comma, 1,
right parentheses, semicolon.
Line 47, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, weight Baggage Line Edit, comma, 3,

comma, 1, right parentheses, semicolon.
Line 48, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, row Combo Box, comma, 4, comma, 1,
right parentheses, semicolon."
Back to Figure
"Program code. The words in the variable names and function
names are merged. 
Line 1, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, passenger Type Combo Box, comma, 5,
comma, 1, right parentheses, semicolon. 
Line 2, indented once: 2 forward slashes. Insert button and
message using row, comma, column, comma, row span, comma,
column span. 
Line 3, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, add Button, comma, 6, comma, 0,
comma, 1, comma, 2, right parentheses, semicolon. 
Line 4, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, messages, comma, 7, comma, 0, comma,
1, comma, 2, right parentheses, semicolon. 
Line 5, indented once: 2 forward slashes. Make this the layout for
the widget. 
Line 6, indented once: set Layout, left parentheses, layout, right
parentheses, semicolon. 
Line 7, indented once: 2 forward slashes. Connect events from the
widgets in the form to their handlers. 
Line 8, indented once: connect, left parentheses, passenger Type
Combo Box, comma, SIGNAL, left parentheses, text Activated, left
parentheses, const Q String ampersand, right parentheses, right
parentheses, comma, this, comma. 
Line 9, indented multiple times: SLOT, left parentheses, Handle
Combo Box Activated, left parentheses, const Q String ampersand,
right parentheses, right parentheses, right parentheses, semicolon. 
Line 10, indented once: connect, left parentheses, add Button,
comma, SIGNAL, left parentheses, clicked, left parentheses, right
parentheses, right parentheses, comma, this, comma, SLOT, left
parentheses, Handle Add Button Clicked, left parentheses, right

parentheses, right parentheses, right parentheses, semicolon. 
Line 11: right brace."
Back to Figure
"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
const, if, else, false, true. 
Line 1: void Passenger Form Widget, colon, colon, Handle Combo
Box Activated, left parentheses, const, Q String ampersand text,
right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, text, equals, equals,
double quotes, Crew, double quotes, right parentheses. 
Line 4, indented once: left brace. 
Line 5, indented twice: 2 forward slashes. Disable the widgets. 
Line 6, indented twice: weight Baggage Line Edit, hyphen, right
angled bracket, set Enabled, left parentheses, false, right
parentheses, semicolon. 
Line 7, indented twice: row Combo Box, hyphen, right angled
bracket, set Enabled, left parentheses, false, right parentheses,
semicolon. 
Line 8, indented twice: 2 forward slashes. Make background color
light grey. 
Line 9, indented twice: weight Baggage Line Edit, hyphen, right
angled bracket, set Style Sheet, left parentheses, double quotes,
background, hyphen, color, colon, light grey, double quotes, right
parentheses, semicolon. 
Line 10, indented twice: row Combo Box, hyphen, right angled
bracket, set Style Sheet, left parentheses, double quotes,
background, hyphen, colon, colon, light grey, double quotes, right
parentheses, semicolon. 
Line 11, indented once: right brace. 
Line 12, indented once: else. 
Line 13, indented once: left brace. 
Line 14, indented twice: 2 forward slashes. Enable the widgets. 
Line 15, indented twice: weight Baggage Line Edit, hyphen, right
angled bracket, set Enabled, left parentheses, true, right
parentheses, semicolon. 

Line 16, indented twice: row Combo Box, hyphen, right angled
bracket, set Enabled, left parentheses, true, right parentheses,
semicolon. 
Line 17, indented twice: 2 forward slashes. Make background color
white. 
Line 18, indented twice: weight Baggage Line Edit, hyphen, right
angled bracket, set Style Sheet, left parentheses, double quotes,
background, hyphen, color, colon, white, double quotes, right
parentheses, semicolon. 
Line 19, indented twice: row Combo Box, hyphen, right angled
bracket, set Style Sheet, left parentheses, double quotes,
background, hyphen, color, colon, white, double quotes, right
parentheses, semicolon. 
Line 20, indented once: right brace. 
Line 21: right brace."
Back to Figure
"Program code. The words in the function names and variable
names are merged. The code contains the following keywords: bool,
if, return, false. 
Line 1: bool Passenger Form Widget, colon, colon, Is Valid
Passenger, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, first Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, equals, equals, double quotes, double quotes, 2 pipes,
last Name Line Edit, hyphen, right angled bracket, text, left
parentheses, right parentheses, equals, equals, double quotes,
double quotes, 2 pipes. 
Line 4, indented multiple times: weight Line Edit, hyphen, right
angled bracket, text, left parentheses, right parentheses, equals,
equals, double quotes, double quotes, 2 pipes, weight Baggage Line
Edit, hyphen, right angled bracket, text, left parentheses, right
parentheses, equals, equals, double quotes, double quotes, right
parentheses. 
Line 5, indented twice: return false, semicolon."
Back to Figure

"Program code. The words in the variable names and function
names are merged. The code contains the following keywords:
return, true, bool, if, return, false, void, float, if. 
Line 1, indented once: return true, semicolon. 
Line 2: right brace. 
Line 3: bool Passenger Form Widget, colon, colon, Is Valid Crew, left
parentheses, right parentheses. 
Line 4: left parentheses. 
Line 5, indented once: if, left parentheses, first Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, equals, equals, double quotes, double quotes, 2 pipes,
last Name Line Edit, hyphen, right angled bracket, text, left
parentheses, right parentheses, equals, equals, double quotes,
double quotes. 
Line 6, indented twice: weight Line Edit, hyphen, right angled
bracket, text, left parentheses, right parentheses, equals, equals,
double quotes, double quotes, right parentheses. 
Line 7, indented twice: return false, semicolon. 
Line 8, indented once: return true, semicolon. 
Line 9: right brace. 
Line 10: void Passenger Form Widget, colon, colon, Check Weight
Of Aircraft, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12, indented once: float weight equals aircraft dot Get Total
Weight, left parentheses, right parentheses, semicolon. 
Line 13, indented once: if, left parentheses, weight greater than
14440, right parentheses. 
Line 14, indented once: left brace. 
Line 15, indented twice: messages, hyphen, right angled bracket,
set Text, left parentheses, double quotes, Cancel flight, colon,
Weight is too heavy, period, double quotes, right parentheses,
semicolon. 
Line 16, indented twice: set Disabled, left parentheses, true, right
parentheses, semicolon. 
Line 17, indented once: right brace. 
Line 18: right brace. 
Line 19: void Passenger Form Widget, colon, colon, Check C o f G
Of Aircraft, left parentheses, right parentheses. 
Line 20: right brace. 

Line 21, indented once: float c o f g equals aircraft dot Get Center
Of Gravity, left parentheses, right parentheses, semicolon. 
Line 22, indented once: if, left parentheses, c o f g less than 307, 2
pipes, c o f g greater than 321, right parentheses. 
Line 23, indented once: left brace. 
Line 24, indented twice: messages, hyphen, right angled bracket,
set Text, left parentheses, double quotes, Cancel flight, colon,
Center of Gravity exceeds limits, period, double quotes, right
parentheses, semicolon. 
Line 25, indented twice: set Disabled, left parentheses, true, right
parentheses, semicolon. 
Line 26, indented once: right brace. 
Line 27: right brace."
Back to Figure
"Program code. The words in the function names are merged. The
code contains the following keywords: void, if, else. 
Line 1: void Passenger Form Widget, colon, colon, Handle Add
Button Clicked, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, passenger Type Combo
Box, hyphen, right angled bracket, current Text, left parentheses,
right parentheses, equals, equals, double quotes, Passenger, double
quotes, right parentheses. 
Line 4, indented twice: Handle Adding Passenger, left parentheses,
right parentheses, semicolon. 
Line 5, indented once: else. 
Line 6, indented twice: Handle Adding Crew, left parentheses, right
parentheses, semicolon."
Back to Figure
"Program code. The words in the variable names and function
names are merged. 
Line 1, indented once: weight And C o f G Widget, hyphen, right
angled bracket, Set Total Weight, left parentheses, aircraft dot Get
Total Weight, left parentheses, right parentheses, right parentheses,
semicolon. 

Line 2, indented once: weight And C o f G Widget, hyphen, right
angled bracket, Set C o f G, left parentheses, aircraft dot Get
Center Of Gravity, left parentheses, right parentheses, right
parentheses, semicolon. 
Line 3: blank. 
Line 4, indented once: first Name Line Edit, hyphen, right angled
bracket, set Text, left parentheses, double quotes, double quotes,
right parentheses, semicolon. 
Line 5, indented once: last Name Line Edit, hyphen, right angled
bracket, set Text, left parentheses, double quotes, double quotes,
right parentheses, semicolon. 
Line 6, indented once: weight Line Edit, hyphen, right angled
bracket, set Text, left parentheses, double quotes, double quotes,
right parentheses, semicolon. 
Line 7, indented once: weight Baggage Line Edit, hyphen, right
angled bracket, set Text, left parentheses, double quotes, double
quotes, right parentheses, semicolon. 
Line 8, indented once: row Combo Box, hyphen, right angled
bracket, set Current Index, left parentheses, 0, right parentheses,
semicolon. 
Line 9: blank. 
Line 10, indented once: check Weight Of Aircraft, left parentheses,
right parentheses, semicolon. 
Line 11, indented once: check C o f G Of Aircraft, left parentheses,
right parentheses, semicolon. 
Line 12: right brace."
Back to Figure
"Program code. The words in the variable names, and function
names are merged. The code contains the following keywords: void,
if, return, string, float, int, try, catch. 
Line 1: void Passenger Form Widget, colon, colon, Handle Adding
Passenger, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, exclamation mark, Is
Valid Passenger, left parentheses, right parentheses, right
parentheses. 
Line 4, indented once: left brace. 

Line 5, indented twice: messages, hyphen, right angled bracket, set
Text, left parentheses, double quotes, Missing passenger form data,
period, Try again, period, double quotes, right parentheses,
semicolon. 
Line 6, indented twice: return, semicolon. 
Line 7, indented once: right brace. 
Line 8, indented once: convert form data from Q String to C, plus,
plus, types. 
Line 9, indented once: string first Name equals first Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to S t d String, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: string last Name equals last Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to S t d String, left parentheses, right
parentheses, semicolon. 
Line 11, indented once: Name name, left parentheses, first Name,
comma, double quotes, blank space, double quotes, comma, last
Name, right parentheses, semicolon. 
Line 12, indented once: float weight equals weight Line Edit, hyphen,
right angled bracket, text, left parentheses, right parentheses, dot to
Float, left parentheses, right parentheses, semicolon. 
Line 13, indented once: float weight Baggage equals weight
Baggage Line Edit, hyphen, right angled bracket, text, left
parentheses, right parentheses, dot, to Float, left parentheses, right
parentheses, semicolon. 
Line 14, indented once: int row equals row Combo Box, hyphen,
right angled bracket, current Text, left parentheses, right
parentheses, dot, to Int, left parentheses, right parentheses. 
Line 15, indented once: 2 forward slashes. Add passenger to aircraft
and displayed manifest, comma, catching error of row full. 
Line 16, indented once: try. 
Line 17, indented once: left brace. 
Line 18, indented twice: aircraft dot Insert Passenger, left
parentheses, name, comma, weight, comma, weight Baggage,
comma, row, right parentheses, semicolon. 
Line 19, indented twice: passenger Manifest Widget, hyphen, right
angled bracket, Add Passenger, left parentheses, first Name,
comma, last Name, comma, row, comma, weight, comma. 

Line 20, indented multiple times: weight Baggage, right parentheses,
semicolon. 
Line 21, indented twice: messages, hyphen, right angled bracket,
set Text, left parentheses, double quotes, Passenger added, period,
double quotes, right parentheses, semicolon. 
Line 22, indented once: right brace. 
Line 23: catch, left parentheses, Row Overflow, right parentheses."
Back to Figure
"Program code. The words in the function name is merged. The
code contains the keyword return. 
Line 1, indented once: left brace. 
Line 2, indented twice: messages, hyphen, right angled bracket, set
Text, left parentheses, double quotes, Not enough room in that row,
period, Try again, period, double quotes, right parentheses,
semicolon. 
Line 3, indented twice: return, semicolon. 
Line 4, indented once: right brace. 
Line 5: right brace."
Back to Figure
"Program code. The words in the variable names, and function
names are merged. The code contains the following keywords: void,
if, return, string, float. 
Line 1: void Passenger Form Widget, colon, colon, Handle Adding
Crew, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, exclamation mark, Is
Valid Crew, left parentheses, right parentheses, right parentheses. 
Line 4, indented once: left brace. 
Line 5, indented twice: messages, hyphen, right angled bracket, set
Text, left parentheses, double quotes, Missing crew form data,
period, Try again, period, double quotes, right parentheses,
semicolon. 
Line 6, indented twice: return, semicolon. 
Line 7, indented once: right brace. 
Line 8, indented once: 2 forward slashes. Convert form data from Q

String to C plus, plus, types. 
Line 9, indented once: string first Name equals first Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to S t d String, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: string last Name equals last Name Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to S t d String, left parentheses, right
parentheses, semicolon. 
Line 11, indented once: Name name, left parentheses, first Name,
comma, double quotes, blank space, double quotes, comma, last
Name, right parentheses, semicolon. 
Line 12, indented once: float weight equals weight Line Edit, hyphen,
right angled bracket, text, left parentheses, right parentheses, dot,
to Float, left parentheses, right parentheses, semicolon. 
Line 13, indented once: 2 forward slashes. Add crew to aircraft and
displayed manifest. 
Line 14, indented once: aircraft dot Insert Crew, left parentheses,
name, comma, weight, right parentheses, semicolon. 
Line 15, indented once: crew Manifest Widget, hyphen, right angled
bracket, Add Crew, left parentheses, first Name, comma, last Name,
comma, weight, right parentheses, semicolon. 
Line 16: blank. 
Line 17, indented once: messages, hyphen, right angled bracket, set
Text, left parentheses, double quotes, Crew member added, period,
double quotes, right parentheses, semicolon. 
Line 18: right brace."
Back to Figure
The widgets in the Form are as follows: Passenger or Crew Entry
Form widget, Passenger Manifest Table Widget, Crew Manifest
Table Widget, Closet Weight or Fuel Entry Form Widget, and Weight
or C o f G Display Widget. A dashed arrow is drawn between the
last 2 widgets. A double headed arrow is drawn between the block
labeled Aircraft and the Closet Weight or Fuel Entry Form Widget.
Back to Figure

"Program code. The words used in the variable names and function
names are merged. The code contains the following keywords:
include, class, public, private, void. 
Line 1: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: hash include, double quotes, Aircraft dot h, double quotes. 
Line 4: hash include, double quotes, Weight And C o f G Widgets
dot h, double quotes. 
Line 5: blank. 
Line 6: class Close Weight And Fuel Form Widget, colon, public Q
Widget. 
Line 7: left brace. 
Line 8, indented once: Q underscore OBJECT. 
Line 9: public, colon. 
Line 10, indented once: Closet Weight And Fuel Form Widget, left
parentheses, Aircraft ampersand aircraft Init, comma. 
Line 11, indented multiple times: Weight And C o f G Widget asterisk
c o f g Widget Init, comma. 
Line 12, indented multiple times: Q Widget asterisk parent equals
null p t r, right parentheses, semicolon. 
Line 13: private, colon. 
Line 14, indented once: Aircraft ampersand aircraft, semicolon. 
Line 15, indented once: Weight And C o f G Widget asterisk c o f g
Widget, semicolon. 
Line 16: blank. 
Line 17, indented once: Q Line Edit asterisk closet Weight Line Edit,
semicolon. 
Line 18, indented once: Q Line Edit asterisk gallons Of Fuel Line
Edit, semicolon. 
Line 19, indented once: Q Push Button asterisk set Weight And Fuel
Button, semicolon. 
Line 20: blank. 
Line 21: private slots, colon. 
Line 22, indented once: void Handle Button Click, left parentheses,
right parentheses, semicolon. 
Line 23: right brace, semicolon."
Back to Figure

"Program code. The words in the file name, function names, and
variable names are merged. The code contains the keywords
include, void, and false. 
Line 1: hash include, double quotes, Closet Weight And Fuel Form
Widget dot h, double quotes. 
Line 2: blank. 
Line 3: Closet Weight And Fuel Form Widget, colon, colon, Closet
Weight And Fuel Form Widget, left parentheses. 
Line 4, indented once: Aircraft ampersand aircraft Init, comma,
Weight And C o f G Widget asterisk c o f g Widget Init, comma. 
Line 5, indented once: Q Widget asterisk parent, right parentheses,
colon, aircraft, left parentheses, aircraft Init, right parentheses,
comma, c o f g Widget, left parentheses, c o f g Widget Init, right
parentheses, comma, Q Widget, left parentheses, parent, right
parentheses. 
Line 6: left brace. 
Line 7, indented once: 2 forward slashes. Labels for text boxes. 
Line 8, indented once: Q Label asterisk closet Weight Label equals
new Q Label, left parentheses, double quotes, Closet Weight, colon,
double quotes, comma, this, right parentheses, semicolon. 
Line 9, indented once: Q Label asterisk gallons Of Fuel Label equals
new Q Label, left parentheses, double quotes, Fuel, blank space,
left parentheses, gallons, right parentheses, colon, double quotes,
this, right parentheses, semicolon. 
Line 10, indented once: 2 forward slashes. Text boxes for data and
entry button. 
Line 11, indented once: close Weight Line Edit equals new Q Line
Edit, left parentheses, this, right parentheses, semicolon. 
Line 12, indented once: gallons Of Fuel Line Edit equals new Q Line
Edit, left parentheses, this, right parentheses, semicolon. 
Line 13, indented once: set Weight And Fuel Button equals new Q
Push Button, left parentheses, double quotes, Set, double quotes,
comma, this, right parentheses, semicolon. 
Line 14, indented once: 2 forward slashes, Create a horizontal
layout and fill it. 
Line 15, indented once: Q H Box Layout, asterisk, layout equals new
Q H Box Layout, left parentheses, this, right parentheses,
semicolon. 
Line 16, indented once: layout, hyphen, right angled bracket, add

Widget, left parentheses, closet Weight Label, right parentheses,
semicolon. 
Line 17, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, closet Weight Line Edit, right parentheses,
semicolon. 
Line 18, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, gallons Of Fuel Label, right parentheses,
semicolon. 
Line 19, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, gallons Of Fuel Line Edit, right
parentheses, semicolon. 
Line 20, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, set Weight And Fuel Button, right
parentheses, semicolon. 
Line 21, indented once: 2 forward slashes. Make it the layout for this
widget. 
Line 22, indented once: set Layout, left parentheses, layout, right
parentheses, semicolon. 
Line 23, indented once: 2 forward slashes. Connect the button’s
event to its handler. 
Line 24, indented once: connect, left parentheses, set Weight And
Fuel Button, comma, SIGNAL, left parentheses, clicked, left
parentheses, right parentheses, right parentheses, comma, this,
comma. 
Line 25, indented twice: SLOT, left parentheses, Handle Button
Click, left parentheses, right parentheses, right parentheses, right
parentheses, semicolon. 
Line 26: right brace. 
Line 27: 2 forward slashes. Event handler for the button. 
Line 28: void Close Weight And Fuel Form Widget, colon, colon,
Handle Button Click, left parentheses, right parentheses. 
Line 29: left brace. 
Line 30, indented once: 2 forward slashes. Convert Q Strings to C
plus plus types. 
Line 31, indented once: float weight equals close Weight Line Edit,
hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to Float, left parentheses, right parentheses,
semicolon. 
Line 32, indented once: float fuel equals gallons Of Fuel Line Edit,

hyphen, right angled bracket, text, left parentheses, right
parentheses, dot, to Float, left parentheses, right parentheses,
semicolon. 
Line 33, indented once: 2 forward slashes. Add the values to the
aircraft weight and C o f G calculation. 
Line 34, indented once: aircraft dot Set Closet And Fuel, left
parentheses, weight, comma, fuel, right parentheses, semicolon. 
Line 35, indented once: Update the weight and C o f G values in the
U I. 
Line 36, indented once: c o f g Widget, hyphen, right angled bracket,
Set Total Weight, left parentheses, aircraft dot Get Total Weight, left
parentheses, right parentheses, right parentheses, semicolon. 
Line 37, indented once: c o f g Widget, hyphen, right angled bracket,
Set C o f G, left parentheses, aircraft dot Get Total Weight, left
parentheses, right parentheses, right parentheses, semicolon. 
Line 38, indented once: c o f g Widget, hyphen, right angled bracket,
Set C o f G, left parentheses, aircraft dot Get Center Of Gravity, left
parentheses, right parentheses, right parentheses, semicolon. 
Line 39, indented once: 2 forward slashes. Disable this widget to
prevent repeated addition. 
Line 40, indented once: set Enabled, left parentheses, false, right
parentheses, semicolon. 
Line 41: right brace."
Back to Figure
"Program code. The words in the file names, keywords and variable
names are merged. The code contains the following keywords. 
Line 1: hash include, double quotes, Aircraft Main Window dot h,
double quotes. 
Line 2: blank. 
Line 3: hash include, double quotes, Aircraft dot h, double quotes. 
Line 4: hash include, double quotes, Closet Weight An Fuel Form
Widget dot h, double quotes. 
Line 5: hash include, double quotes, Crew Manifest Widget dot h,
double quotes. 
Line 6: hash include, double quotes, Passenger Form Widget dot h,
double quotes. 
Line 7: hash include, double quotes, Passenger Manifest Widget dot

h, double quotes. 
Line 8: hash include, double quotes, Weight And C o f G Widget dot
h, double quotes. 
Line 9: blank. 
Line 10: Aircraft Main Window, colon, colon, Aircraft Main Window,
left parentheses, Aircraft ampersand aircraft, comma, Q Widget
asterisk parent, right parentheses. 
Line 11, indented once: colon, Q Main Window, left parentheses,
parent, right parentheses. 
Line 12: left brace. 
Line 13, indented once: 2 forward slashes. Initialize the major
widgets in this G U I application. 
Line 14, indented once: Passenger Manifest Widget asterisk
passenger Manifest Widget equals. 
Line 15, indented twice: new Passenger Manifest Widget, left
parentheses, this, right parentheses, semicolon. 
Line 16, indented once: Crew Manifest Widget asterisk crew
Manifest Widget equals new Crew Manifest Widget, left
parentheses, this, right parentheses, semicolon. 
Line 17, indented once: Weight And C o f G Widget asterisk c o f g
equals new Weight And C o f G Widget, left parentheses, this, right
parentheses, semicolon. 
Line 18, indented once: Passenger Form Widget asterisk form
equals new Passenger Form Widget, left parentheses. 
Line 19, indented twice: aircraft, comma, passenger Manifest
Widget, comma, crew Manifest Widget, comma, c o f g, comma,
this, right parentheses, semicolon. 
Line 20, indented once: Closet Weight And Fuel Form Widget
asterisk closet Fuel Widget equals. 
Line 21, indented twice: new Closet Weight And Fuel Form Widget,
left parentheses, aircraft, comma, config, comma, this, right
parentheses, semicolon. 
Line 22, indented once: 2 forward slashes. Create a new general
widget. 
Line 23, indented once: Q Widget asterisk main Widget equals new
Q Widget, left parentheses, this, right parentheses, semicolon. 
Line 24, indented once: 2 forward slashes. Create a vertical layout
for the new widget and fill it with the major widgets. 
Line 25, indented once: Q V Box Layout asterisk layout equals new

Q V Box Layout, left parentheses, main Widget, right parentheses,
semicolon. 
Line 26, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, form, right parentheses, semicolon. 
Line 27, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, passenger Manifest Widget, right
parentheses, semicolon. 
Line 28, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, crew Manifest Widget, right parentheses,
semicolon. 
Line 29, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, closet Fuel Widget, right parentheses,
semicolon. 
Line 30, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, config, right parentheses, semicolon. 
Line 31, indented once: 2 forward slashes. Ensure the empty widget
begins at a reasonable size and put it in the window. 
Line 32, indented once: set Minimum Size, left parentheses, 500,
comma, 500, right parentheses, semicolon. 
Line 33, indented once: set Central Widget, left parentheses, main
Widget, right parentheses, semicolon. 
Line 34: right brace."
Back to Figure
"Program code. The words in the keywords, variable names, and
function names are merged. The code contains the following
keywords: include, Q Application, f stream, i o stream, using, name
space, s t d, int, main, a r g c, char, a r g v, return. 
Line 1: hash include, left angled bracket, Q Application, right angled
bracket. 
Line 2: hash include, left angled bracket, f stream, right angled
bracket. 
Line 3: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 4: blank. 
Line 5: hash include, double quotes, Aircraft Main Window dot h,
double quotes. 
Line 6: using name space s t d, semicolon. 

Line 7: int main, left parentheses, int a r g c, comma, char asterisk a
r g v, left square bracket, right square bracket, right parentheses. 
Line 8: left brace. 
Line 9, indented once: Q Application app, left parentheses, a r g c,
comma, a r g v, right parentheses, semicolon. 
Line 10, indented once: Aircraft aircraft, semicolon. 
Line 11, indented once: Aircraft Main Window, blank space, window,
left parentheses, aircraft, right parentheses, semicolon. 
Line 12, indented once: window dot show, left parentheses, right
parentheses, semicolon. 
Line 13, indented once: return app dot e x e c, left parentheses,
right parentheses, semicolon. 
Line 14: right brace."
Back to Figure
The window has 3 panes. The description of the first pane from top
to bottom is as follows. Text label First Name, empty text box. Text
label Last Name, empty text box. Text label Weight, empty text box.
Text label Baggage Weight, deactivated text box. Text label Row,
deactivated drop down menu. Text label Passenger Type, drop down
box with Crew selected. The button at the bottom of the first pane is
labeled Add. The text below the button reads: Crew member added.
The second pane has a table titled Passenger Manifest. The table
has 4 columns labeled Name, Row, Weight, and Baggage Weight.
The row entries are as follows. Row 1. Name: Kelley Gaddy. Row: 0.
Weight: 142. Baggage Weight: 45. Row 2. Name: Bob Marley. Row:
2. Weight: 175. Baggage Weight: 115. The third pane has a table
titled Crew Manifest. The table has 2 columns labeled Name, and
Weight. The row entry is as follows. Row 1. Name: Vebjorn
Nordhagen. Weight: 181. The deactivated text labels, text boxes and
button are as follows. Text label Closet Weight, colon. Text box 55.
Text label Fuel in gallons. Text box with entry 200. Button labeled
Set. The text below the third pane reads: Total Weight, colon, 11940.
Center of Gravity, colon, 310.338.
Back to Figure

"Program code. The words used in the variable names are merged.
The code contains the following keywords: template, class, public,
const, void, private. 
Line 1: template, left angled bracket, class some Type, right angled
bracket. 
Line 2: class O r d Pair. 
Line 3: left brace. 
Line 4: public, colon. 
Line 5, indented once: some Type First, left parentheses, right
parentheses, const, semicolon. 
Line 6, indented once: some Type Second, left parentheses, right
parentheses, const, semicolon. 
Line 7, indented once: void Print, left parentheses, right
parentheses, const, semicolon. 
Line 8, indented once: O r d Pair, left parentheses, Some Type m,
comma, Some Type n, right parentheses, semicolon. 
Line 9: private, colon. 
Line 10, indented once: Some Type first, semicolon. 
Line 11, indented once: Some Type second, semicolon. 
Line 12: right brace, semicolon."
Back to Figure
"Program code. The words used in the function names are merged.
The code contains the following keywords: int, float, char. 
Line 1: O r d Pair, left angled bracket, int, right angled bracket, pair
1, left parentheses, 5, comma, 6, right parentheses, semicolon. 
Line 2: O r d Pair, left angled bracket, float, right angled bracket, pair
2, left parentheses, 2.95, comma, 6.34, right angled bracket,
semicolon. 
Line 3: O r d Pair, left angled bracket, char, right angled bracket, pair
3, left parentheses, single quote, plus sign, single quote, comma,
single quote, hash, single quote, right parentheses, semicolon. 
Line 4: blank. 
Line 5: pair 1 dot Print, left parentheses, right parentheses,
semicolon. 
Line 6: pair 2 dot Print, left parentheses, right parentheses,
semicolon. 

Line 7: pair 3 dot Print, left parentheses, right parentheses,
semicolon."
Back to Figure
"Program code. The words in the variable names are merged. The
code contains the following keywords: template, class. 
Line 1: template, left angled bracket, class Some Type, right angled
bracket. 
Line 2: O r d Pair, left angled bracket, Some Type, right angled
bracket, colon, colon, O r d Pair, left parentheses, Some Type m,
comma, Some Type n, right parentheses. 
Line 3: 2 forward slashes. Constructor. 
Line 4: left brace. 
Line 5, indented once: first equals m, semicolon. 
Line 6, indented once: second equals n, semicolon. 
Line 7: right brace. 
Line 8: template, left angled bracket, class Some Type, right angled
bracket. 
Line 9: Some Type O r d Pair, left angled bracket, Some Type, right
angled bracket, colon, colon, First, left parentheses, right
parentheses, const. 
Line 10: left brace. 
Line 11, indented once: return first, semicolon. 
Line 12: right brace. 
Line 13: template, left angled bracket, class Some Type, right angled
bracket. 
Line 14: Some Type O r d Pair, left angled bracket, Some Type, right
angled bracket, colon, colon, Second, left parentheses, right
parentheses, const. 
Line 15: left brace. 
Line 16, indented once: return second, semicolon. 
Line 17: right brace. 
Line 18: template, left angled bracket, class Some Type, right angled
bracket. 
Line 19: void O r d Pair, left angled bracket, Some Type, right angled
bracket, colon, colon, Print, left parentheses, right parentheses,
const. 
Line 20: left brace. 

Line 21, indented once: c out, 2 left angled brackets, single quote,
left parentheses, single quote, 2 left angled brackets, first, 2 left
angled brackets, double quotes, comma, blank space, double
quotes, 2 left angled brackets, second, 2 left angled brackets, single
quote, right parentheses, single quote, 2 left angled brackets, end l,
semicolon."
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: template, class, return. Line
1: template, left angled bracket, class Simple Type, right angled
bracket. Line 2: Simple Type Thrice, left parentheses, Simple Type v
a l, right parentheses. Line 3: left brace. Line 4, indented once:
return 3 asterisk v a l, semicolon. Line 5: right brace.
Back to Figure
Line 1: c out, 2 left angled brackets, Thrice, left parentheses, 75,
right parentheses, 2 left angled brackets, single quote, blank space,
single quote, 2 left angled brackets, Thrice, left parentheses, 64.35,
right parentheses, semicolon. Line 2: c out, 2 left angled brackets,
Thrice, left angled bracket, int, right angled bracket, left
parentheses, 75, right parentheses, 2 left angled brackets, single
quote, blank space, single quote, 2 left angled brackets, Thrice, left
angled bracket, float, right angled bracket, left parentheses, 64.35,
right parentheses, semicolon.
Back to Figure
a. The description of the first code fragment is as follows. Line 1:
class Bad Data. Line 2: left brace, right brace, semicolon. 2 forward
slashes. Don't forget the semicolon. b. The description of the second
code fragment is as follows. Line 1: void Get Age, left parentheses,
int ampersand age, right parentheses. Line 2: left brace. Line 3,
indented once: c out, 2 left angled brackets, dobule quotes, Enter
your age, colon, blank space, double quotes, semicolon. Line 4,
indented once: c in, 2 right angled brackets, age, semicolon. Line 5,
indented once: if, left parentheses, age less than 0, right

parentheses. Line 6, indented twice: throw Bad Data, left
parentheses, right parentheses, semicolon. Line 7, indented once:
right brace.
Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords: try, catch, c out, end l, throw.
Line 1: try. Line 2: left brace. Line 3, indented once: Get Age, left
parentheses, age, right parentheses, semicolon. Line 4: right brace.
Line 5: catch, left parentheses, Bad Data, right parentheses. Line 6:
left brace. Line 7, indented once: c out, 2 left angled backets, double
quotes, Age must not be negative, period, double quotes, 2 left
angled brackets, end l, semicolon. Line 8, indented once: throw,
semicolon. Line 9: right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: template, class, return. Line
1: template, left angled bracket, class T, right angled bracket. Line 2:
T, One Less, left parentheses, T v a r, right parentheses. Line 3: left
brace. Line 4, indented once: return v a r minus 1, semicolon. Line
5: right brace.
Back to Figure
"The interaction is as follows. 
Line 1: right angled bracket, 32. 
Line 2: total equals 32. 
Line 3: right angled bracket, plus sign. 
Line 4: right angled bracket, 4. 
Line 5: total equals 36. 
Line 6: right angled bracket, forward slash. 
Line 7: right angled bracket, 0. 
Line 8: Error, colon, Cannot Divide by Zero, exclamation mark. 
Line 9: Total equals 36. 
Line 10: right angled bracket, quit."

Back to Figure
The reserved words are as follows: align as, align of, and, and
underscore e q, a s m, atomic underscore cancel, atomic
underscore commit, atomic underscore no except, auto, bit and, bit
or, bool, break, case, catch, char, char 8 underscore t, const int,
const underscore cast, continue, c o underscore await, c o
underscore return, c o underscore yield, d e c l type, default, delete,
do, double, dynamic underscore cast, else, enum, explicit, export,
extern, long, mutable, name space, new, no except, not, not
underscore e q, null p t r, operator, or, or underscore e q, private,
protected, public, r e f l e x p r, register, re interpret underscore cast,
struct, switch, synchronized, template, this, thread underscore local,
throw, true, try, type def, type i d, type name, union, unsigned,
using, virtual, void.
Back to Table
The reserved words are as follows: char 16 underscore t, char 32
underscore t, class, c o m p l, const, const eval, const e x p r, const
init, false, float, for, friend, go to, if, inline, int, requires, return, short,
signed, size of, static, static underscore assert, static underscore
cast, volatile, w char underscore t, while, x or, x or underscore e q.
Back to Table
"The table has 4 columns labelled Precedence Level, Operator,
Associativity, and Remarks. The row entries are as follows.
Row 1. Precedence Level: 1. Operator: colon, colon. Associativity:
Left to right. Remarks: Scope resolution, left parentheses, binary,
right parentheses.
Row 2. Precedence Level: 2. Operator: plus, plus, minus, minus.
Associativity: Left to Right. Remarks: plus, plus, and minus, minus,
as postfix operators.
Row 3. Precedence Level: 2. Operator: left parentheses, right
parentheses. Associativity: Left to Right. Remarks: Function call and
function style cast.
Row 4. Precedence Level: 2. Operator: left square bracket, right
square bracket. Associativity: Left to right. Remarks: Subscript.

Row 5. Precedence Level: 2. Operator: hyphen, right angled
bracket, dot. Associativity: Left to Right. Remarks: Member access.
Row 6. Precedence Level: 3. Operator: type i d, dynamic
underscore cast. Associativity: Right to Left. Remarks: blank."
Back to Table
"The table has 4 columns labelled Precedence Level, Operator,
Associativity, and Remarks. The row entries are as follows.
Row 1. Precedence Level: 3. Operator: static underscore cast, const
underscore cast. Associativity: Right to left. Remarks: blank. 
Row 2. Precedence Level: 3. Operator: reinterpret underscore cast.
Associativity: Right to left. Remarks: blank.
Row 3. Precedence Level: 3. Operator: plus, plus, minus, minus,
exclamation mark, unary plus, unary minus. Associativity: Right to
Left. Remarks: plus, plus, and minus, minus, as prefix operators.
Row 4. Precedence Level: 3. Operator: minus Unary, asterisk Unary,
ampersand. Associativity: Right to left. Remarks: blank.
Row 5. Precedence Level: 3. Operator: left parentheses, cast, right
parentheses, size of, new, delete. Associativity: Right to left.
Remarks: blank.
Row 6. Precedence Level: 4. Operator: hyphen, right angled
bracket, asterisk; dot asterisk. Associativity: Left to right. Remarks:
blank.
Row 7. Precedence Level: 5. Operator: asterisk, forward slash,
percentage. Associativity: Left to right. Remarks: blank.
Row 8. Precedence Level: 6. Operator: plus, minus. Associativity:
Left to right. Remarks: blank.
Row 9. Precedence Level: 7. Operator: 2 left angled brackets, 2
right angled brackets. Associativity: Left to right. Remarks: blank.
Row 10. Precedence Level: 8. Operator: left angled bracket, equals
sign, right angled bracket. Associativity: Left to right. Remarks:
Three way comparison.
Row 11. Precedence Level: 9. Operator: left angled bracket, left
angle bracket equals sign, right angled bracket, right angled bracket
equals sign. Associativity: Left to right. Remarks: blank.
Row 12. Precedence Level: 10. Operator: equals equals,
exclamation mark equals. Associativity: left to right. Remarks: blank.
Row 13. Precedence Level: 11. Operator: ampersand. Associativity:

left to right. Remarks: blank.
Row 14. Precedence Level: 12. Operator: caret. Associativity: Left
to right. Remarks: blank.
Row 15. Precedence Level: 13. Operator: pipe. Associativity: Left to
right. Remarks: blank.
Row 16. Precedence Level: 14. Operator: ampersand, ampersand.
Associativity: Left to right. Remarks: blank.
Row 17. Precedence Level: 15. Operator: 2 pipes. Associativity: Left
to right. Remarks: blank.
Row 18. Precedence Level: 16. Operator: question mark, colon.
Associativity: Right to left. Remarks: blank.
Row 19. Precedence Level: 16. Operator: equals; plus equals;
minus equals; asterisk equals; forward slash equals; percentage
equals. Associativity: Right to left. Remarks: blank.
Row 20. Precedence Level: 16. Operator: 2 left angled brackets
equals, 2 right angled brackets equals, ampersand equals, pipe
equals, caret equals. Associativity: Right to left. Remarks: blank.
Row 21. Precedence Level: 16. Operator: throw. Associativity: Right
to left. Remarks: blank.
Row 22. Precedence Level: 17. Operator: tick. Associativity: Left to
right. Remarks: The sequencing operator not the separator."
Back to Table
"Program code. The code contains the following keywords: include,
using, name space, s t d. 
Line 1: hash include, left angled bracket, c math, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: dot, dot, dot. 
Line 4: y equals s q r t, left parentheses, x, right parentheses,
semicolon."
Back to Code
The title bar is labeled Q t creator. The buttons on the left are as
follows: Projects, Examples, Tutorials, and Marketplace. The caption
below the buttons reads: New to Q t, question mark. The button
below is labeled Get Started Now. The text label at the top center

reads, Sessions. The button beside is labeled Manage. The text
label on the right reads, Projects. The 2 buttons beside the text are
labeled New and Open.
Back to Screenshot
The folders listed on the left pane of the window under the heading
Previous 30 days are as follows: Chapter 11, Chapter 04, Chapter
05, Chapter 12, Chapter 13, Chapter 14, Chapter 15, Chapter 15,
Chapter 16, and Chapter 17. The folder heading displayed at the top
center reads: Names Case Study. The search bar is at the top right.
The folders listed in the middle pane of the window under the
heading July are as follows: Names Case Study, and Names Case
Study G U I. The third pane on the right under the lists the files
contained within the folder under the heading July. The text within
the drop down box at the bottom center reads, All Projects, left
parentheses, asterisk dot p y project, asterisk, p y q t c, asterisk p,
dot, dot, dot. The 2 buttons at the bottom left of the window are
labeled New Folder, and Options. The 2 buttons at the bottom right
of the window are labeled Cancel and Close. The button labeled
Close is deactivated.
Back to Screenshot
The left pane of the window displays the following options. Manage
kits. Active Project. Names Case Study. Import Existing Build. Build
and Run. Project Settings. Editor. Code Style. Dependencies. C lang
Code Model. Environment. C lang Tools. Quick Fixes. Testing. The
right pane of the window displays the following options. Configure
Project. The following kits can be used for project Names Case
Study, colon. Type to filter kits by name. Select all kits. Desktop Q t
6 point 1 point 1 c lang 64 bit. The drop down selection box beside it
reads, Details. Import Build from, dot, dot, dot. The drop down box
beside it reads, Details. The button below is labeled Configure
Project.
Back to Screenshot

The pane on the left displays the Project folder and its contents. The
text in the right pane displays the steps involved in opening a
document.
Back to Screenshot
The options listed on the left pane are as follows. Active Project.
Names Case Study. Import Existing Build. Build and run. Desktop Q
t 6.1.1 c lang. Build. Run. Project Settings. Editor. Code Style.
Dependencies. C lang Code Model. C lang Tools. Quick Fixes.
Testing. The pane on the right displays the Build Settings. The
contents under the heading General are as follows. Shadow build is
checked. A caption pointing to this reads, Uncheck this. The other
options listed are as follows. Build directory. Tooltip in target
selection. Q M L debugging and profiling. Q t Quick Compiler and so
on. The tools selected under Build Steps are Q make and Make.
The tool selected under Clean Steps is Make. The option selected
under Build Environment is, Use System Environment. The option
under Custom Output Parsers reads, There are no output parsers
active.
Back to Screenshot
The left pane of the window lists the Active project, Build and Run
tools and Project settings. The right pane of the window lists the
Build Settings, General options, Build steps, and Clean steps. Under
the General options, the check box corresponding to shadow build is
selected. The build directory is listed. The other options listed are
Tooltip target selection, Separate debug mode, Q M L debugging
and profiling, Q t quick compiler and the make system directory. The
tools listed under the Build steps are q make and Make. The tool
listed under the Clean Steps is Make.
Back to Screenshot
The left pane of the window lists the Active Projects, Build and Run
options, and Project settings. The Run command under the Build
and Run options is selected. The right pane of the window lists the

Run settings. The checkbox corresponding to run in terminal is
selected under the options corresponding to Run.
Back to Screenshot
"The table has 3 columns labelled Left Digit, left parentheses, s,
right parentheses, Right digit and ASCII. The column labelled ASCII
is subdivided into 10 columns numbered from 0 to 9. The row entries
are as follows.
Row 1. Left Digit, left parentheses, s, right parentheses: 0. Right
digit: blank. ASCII, 0: N U L. ASCII, 1: S O H. ASCII, 2: S T X.
ASCII, 3: E T X. ASCII, 4: E O T. ASCII, 5: E N Q. ASCII, 6: A C K.
ASCII, 7: B E L. ASCII, 8: B S. ASCII, 9: H T. 
Row 2. Left Digit, left parentheses, s, right parentheses: 1. Right
digit: blank. ASCII, 0: L F. ASCII, 1: V T. ASCII, 2: F F. ASCII, 3: C
R. ASCII, 4: S O. ASCII, 5: S I. ASCII, 6: D L E. ASCII, 7: D C 1.
ASCII, 8: D C 2. ASCII, 9: D C 3.
Row 3. Left Digit, left parentheses, s, right parentheses: 2. Right
digit: blank. ASCII, 0: D C 4. ASCII, 1: N A K. ASCII, 2: S Y N.
ASCII, 3: E T B. ASCII, 4: C A N. ASCII, 5: E M. ASCII, 6: S U B.
ASCII, 7: E S C. ASCII, 8: F S. ASCII, 9: G S.
Row 4. Left Digit, left parentheses, s, right parentheses: 3. Right
digit: blank. ASCII, 0: R S. ASCII, 1: U S. ASCII, 2: square. ASCII,
3: exclamation mark. ASCII, 4: double quotes. ASCII, 5: hash.
ASCII, 6: dollar. ASCII, 7: percent. ASCII, 8: ampersand. ASCII, 9:
single quote.
Row 5. Left Digit, left parentheses, s, right parentheses: 4. Right
digit: blank. ASCII, 0: left parentheses. ASCII, 1: right parentheses.
ASCII, 2: asterisk. ASCII, 3: plus. ASCII, 4: comma. ASCII, 5:
minus. ASCII, 6: dot. ASCII, 7: forward slash. ASCII, 8: 0. ASCII, 9:
1.
Row 6. Left Digit, left parentheses, s, right parentheses: 5. Right
digit: blank. ASCII, 0: 2. ASCII, 1: 3. ASCII, 2: 4. ASCII, 3: 5. ASCII,
4: 6. ASCII, 5: 7. ASCII, 6: 8. ASCII, 7: 9. ASCII, 8: colon. ASCII, 9:
semicolon.
Row 7. Left Digit, left parentheses, s, right parentheses: 6. Right
digit: blank. ASCII, 0: less than. ASCII, 1: equals. ASCII, 2: greater
than. ASCII, 3: question mark. ASCII, 4: at. ASCII, 5: uppercase a.
ASCII, 6: uppercase b. ASCII, 7: uppercase c. ASCII, 8: uppercase

d. ASCII, 9: uppercase e.
Row 8. Left Digit, left parentheses, s, right parentheses: 7. Right
digit: blank. ASCII, 0: uppercase f. ASCII, 1: uppercase g. ASCII, 2:
uppercase h. ASCII, 3: uppercase i. ASCII, 4: uppercase j. ASCII, 5:
uppercase k. ASCII, 6: uppercase l. ASCII, 7: uppercase m. ASCII,
8: uppercase n. ASCII, 9: uppercase o."
Back to Table
"The table has 3 columns labelled Left Digit, left parentheses, s,
right parentheses, Right digit and ASCII. The column labelled ASCII
is subdivided into 10 columns numbered from 0 to 9. The row entries
are as follows. 
Row 1. Left Digit, left parentheses, s, right parentheses: 8. Right
digit: blank. ASCII, 0: uppercase p. ASCII, 1: uppercase q. ASCII, 2:
uppercase r. ASCII, 3: uppercase s. ASCII, 4: uppercase t. ASCII, 5:
uppercase u. ASCII, 6: uppercase v. ASCII, 7: uppercase w. ASCII,
8: uppercase x. ASCII, 9: uppercase y. 
Row 2. Left Digit, left parentheses, s, right parentheses: 9. Right
digit: blank. ASCII, 0: uppercase z. ASCII, 1: left square bracket.
ASCII, 2: back slash. ASCII, 3: right square bracket. ASCII, 4: caret.
ASCII, 5: underscore. ASCII, 6: tick. ASCII, 7: lowercase a. ASCII,
8: lowercase b. ASCII, 9: lowercase c.
Row 3. Left Digit, left parentheses, s, right parentheses: 10. Right
digit: blank. ASCII, 0: lowercase d. ASCII, 1: lowercase e. ASCII, 2:
lowercase f. ASCII, 3: lowercase g. ASCII, 4: lowercase h. ASCII, 5:
lowercase i. ASCII, 6: lowercase j. ASCII, 7: lowercase k. ASCII, 8:
lowercase l. ASCII, 9: lowercase m.
Row 4. Left Digit, left parentheses, s, right parentheses: 11. Right
digit: blank. ASCII, 0: lowercase n. ASCII, 1: lowercase o. ASCII, 2:
lowercase p. ASCII, 3: lowercase q. ASCII, 4: lowercase r. ASCII, 5:
lowercase s. ASCII, 6: lowercase t. ASCII, 7: lowercase u. ASCII, 8:
lowercase v. ASCII, 9: lowercase w.
Row 5. Left Digit, left parentheses, s, right parentheses: 12. Right
digit: blank. ASCII, 0: lowercase x. ASCII, 1: lowercase y. ASCII, 2:
lowercase z. ASCII, 3: left brace. ASCII, 4: pipe. ASCII, 5: right
brace. ASCII, 6: tilde. ASCII, 7: D E L. ASCII, 8: blank. ASCII, 9:
blank."

Back to Table
Line 1: 2 forward slashes. This program computes the sidereal time
for a given date and. Line 2: 2 forward slashes. Solar time. Line 3: 2
forward slashes. Line 4: 2 forward slashes. Written By, colon, Your
Name. Line 5: 2 forward slashes. Line 6: Date completed, colon, 4,
forward slash, 8, forward slash, 25. Line 7: 2 forward slashes. Line
8: 2 forward slashes. Input, colon, A date and time in the form M M
D D Y Y Y Y H H M M S S. Line 9: 2 forward slashes. Line 10: 2
forward slashes. Output, colon, Sidereal time in teh form H H M M S
S. Line 11: 2 forward slashes. Line 12: 2 forward slashes.
Assumptions, colon, Solar time is specified for a longitude of 0. Line
13: 2 foward slashes. degrees, left parentheses, G M T, comma, U
T, comma, or Z time zone, right parentheses.
Back to Example
Line 1: const float uppercase e equals 2.71828, semicolon. 2
forward slashes. The base of the natural logarithms. Line 2: blank.
Line 3: float delta uppercase x, semicolon. 2 forward slashes. The
difference in the x direction. Line 4: float delta uppercase y,
semicolon. 2 forward slashes. The difference in the y direction.
Back to Code
Line 1: 2 forward slashes. Prepare file for reading. Line 2: score File
dot open, left parentheses, double quotes, scores dot d a t, double
quotes, right parentheses, semicolon. Line 3: 2 forward slashes. Get
data. Line 4: score File, 2 right angled brackets, test 1, 2 right
angled brackets, weight 1, semicolon. Line 5: score File, 2 right
angled brackets, test 2, 2 right angled brackets, weight 2,
semicolon. Line 6: score File, 2 right angled brackets, test 3, 2 right
angled brackets, weight 3, semicolon. Line 7: 2 forward slashes.
Print heading. Line 8: c out, 2 left angled brackets, double quotes,
Test score weight, double quotes, 2 left angled brackets, end l,
semicolon.
Back to Code

Line 1: while, left parentheses, file 1, 2 ampersands, file 2, right
parentheses. 2 forward slashes. While neither file is empty, ellipsis.
Line 2: left brace. Line 3: dot, dot, dot.
Back to Code
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Print Second Heading, left parentheses, right
parentheses. Line 3: left brace. Line 4: dot, dot, dot. Line 5: right
brace. Line 6: 2 forward slashes followed by asterisks till the end of
the line.
Back to Code
forward slash, asterisk, some comment, asterisk, forward slash.
Back to Code
Line 1: void Get Data, left parentheses, forward slash, asterisk, out,
asterisk, forward slash, int age, comma, 2 forward slashes. Patient's
age. Line 2, indented multiple times: forward slash, asterisk, out,
asterisk, forward slash, int weight, right parentheses. 2 forward
slashes. Patient's weight.
Back to Code
Line 1: left brace. Line 2: dot, dot, dot. Line 3: right brace. Line 4:
void Print, left parentheses, forward slash, asterisk, in, asterisk,
forward slash, float v a l, comma. 2 forward slashes. Value to be
printed. Line 5, indented multiple times: forward slash, asterisk, in
out, asterisk, forward slash, int ampersand, count, right
parentheses. 2 forward slashes. Number of lines printed. Line 6,
indented multiple times: 2 forward slashes. so far. Line 7: left brace.
Line 8: dot, dot, dot. Line 9: right brace.
Back to Code
Line 1: while, left parentheses, num greater than or equal to 0, right
parentheses. Line 2: left brace. Line 3: dot, dot, dot. Line 4,
indented once: if, left parentheses, num, equals, equals, 25, right

parentheses. Line 5, indented once: left brace. Line 6: dot, dot, dot.
Line 7, indented once: right brace. 2 forward slashes. if. Line 8: right
brace. 2 forward slashes. while.
Back to Code
Line 1: c out, 2 left angled brackets, double quotes, For a radius of,
blank space, double quotes, 2 left angled brackets, radius, 2 left
angled brackets, double quotes, blank space, the diameter of the c i
r, double quotes. Line 2, indented multiple times: 2 left angled
brackets, double quotes, c l e is, double quotes, 2 left angled
brackets, diameter, 2 left angled brackets, end l, semicolon. Line 3:
c out, 2 left angled brackets, double quotes, For a radius of, blank
space, double quotes, 2 left angled brackets, radius. Line 4,
indented multiple times: 2 left angled brackets, double quotes, blank
space, the diameter of the circle is, blank space, double quotes, 2
left angled brackets, diameter, 2 left angled brackets, end l,
semicolon.
Back to Code
Line 1: mean Of Maxima, equals, left parentheses, Maximum, left
parentheses, set 1 Value 1, comma, set 1 Value 2, comma, set 1
Value 3, right parentheses, plus. Line 2, indented multiple times:
Maximum, left parentheses, set 2 Value 1, comma, set 2 Value 2,
comma, set 2 Value 3, right parentheses, plus. Line 3, indented
multiple times: Maximum, left parentheses, set 3 Value 1, comma,
set 3 Value 2, comma, set 3 Value 3, right parentheses, right
parentheses, forward slash, 3.0, semicolon.
Back to Code
Line 1: if, left parentheses, x plus y greater than y plus z, right
parentheses. Line 2, indented once: maximum equals x plus y,
semicolon. Line 3: else. Line 4, indented once: maximum equals y
plus z, semicolon. Line 5: hypotenuse, equals, s q r t, left
parentheses, a asterisk a, plus, b asterisk b, right parentheses,
semicolon.

Back to Code
Line 1: while, left parentheses, count, less than or equal to 10, right
parentheses. Line 2: left brace. Line 3: c in, 2 right angled brackets,
num, semicolon. Line 4: if, left parentheses, num, equals, equals, 0,
right parentheses. Line 5: left brace. Line 6: count, plus, plus,
semicolon. Line 7: num, equals, 1, semicolon. Line 8: right brace.
Line 9: c out, 2 left angled brackets, num, 2 left angled brackets,
end l, semicolon. Line 10: c out, 2 left angled brackets, count, 2 left
angled brackets, end l, semicolon. Line 11: right brace. Line 12:
while, left parentheses, count, less than or equal to 10, right
parentheses. Line 13: left brace. Line 14, indented once: c in, 2 right
angled brackets, num, semicolon. Line 15, indented once: if, left
parentheses, num, equals, equals, 0, right parentheses. Line 16,
indented once: left brace. Line 17, indented twice: count, plus, plus,
semicolon. Line 18, indented twice: num equals 1, semicolon. Line
19, indented once: right brace. Line 20, indented once: c out, 2 left
angled brackets, num, 2 left angled brackets, end l, semicolon. Line
21, indented once: c out, 2 left angled brackets, count, 2 left angled
brackets, end l, semicolon. Line 22: right brace.
Back to Code
Line 1: if, left parentheses, sex equals equals MALE, right
parentheses. Line 2: left brace. Line 3, indented once: male Salary
equals male Salary plus salary, semicolon. Line 4, indented once:
male Count, plus, plus, semicolon. Line 5: right brace. Line 7: else.
Line 8, indented once: female Salary equals female Salary plus
salary, semicolon. Line 9: if, left parentheses, count greater than 0,
right parentheses. Line 10, indented once: average equals total
forward slash count, semicolon.
Back to Code
Line 1: if, left parentheses, month equals equals JANUARY, right
parentheses. Line 2, indented once: month Number equals 1,
semicolon. Line 3: else if, left parentheses, month equals equals
FEBRUARY, right parentheses. Line 4, indented once: month
Number equals 2, semicolon. Line 5: else if, left parentheses,

month, equals, equals, MARCH, right parentheses. Line 6, indented
once: month Number equals 3, semicolon. Line 7: else if, left
parentheses, month equals equals APRIL, right parentheses.
Back to Code
Line 1: dot, dot, dot. Line 2: else. Line 3, indented once: month
Number equals 12, semicolon.
Back to Code
Line 1: while, left parentheses, count, less than or equal to 10, right
parentheses. Line 2: left brace. Line 3, indented once: c in, 2 right
angled brackets, value, semicolon. Line 4, indented once: sum
equals sum plus value, semicolon. Line 5, indented once: count,
plus, plus, semicolon. Line 6: right brace. Line 7: do. Line 8: left
brace. Line 9, indented once: Get Answer, left parentheses, letter,
right parentheses, semicolon. Line 10, indented once: Put Answer,
left parentheses, letter, right parentheses, semicolon. Line 11: right
brace, while, left parentheses, letter, exclamation mark, equals sign,
single quote, uppercase n, single quote, right parentheses,
semicolon. Line 12: for, left parentheses, count equals 1, semicolon,
count less than or equal to num Sales, semicolon, count, plus, plus,
right parentheses. Line 13, indented once: c out, 2 left angled
brackets, single quotes, asterisk, single quote, semicolon. Line 14:
for, left parentheses, count equals 10, semicolon, count greater than
or equal to 1, semicolon, count minus minus, right parentheses. Line
15: left brace. Line 16, indented once: in File, 2 right angled
brackets, data Item, semicolon. Line 17, indented once: out File, 2
left angled brackets, data Item, 2 left angled brackets, single quote,
blank space, single quote, 2 left angled brackets, count, 2 left angled
brackets, end l, semicolon. Line 18: right brace. Line 19: switch, left
parentheses, color, right parentheses. Line 20: left brace. Line 21,
indented once: RED, colon, c out, 2 left angled brackets, double
quotes, Red, double quotes, semicolon. Line 22, indented multiple
times: break, semicolon. Line 23, indented once: ORANGE, colon, c
out, 2 left angled brackets, double quotes, Orange, double quotes,
semicolon. Line 24, indented multiple times: break, semicolon. Line
25, indented once: YELLOW, colon, c out, 2 left angled brackets,

double quotes, Yellow, double quotes, semicolon. Line 26, indented
multiple times: break, semicolon. Line 27, indented once: GREEN,
colon. Line 28, indented once: BLUE, colon. Line 29, indented once:
INDIGO, colon. Line 30, indented once: VIOLET, colon, c out, 2 left
angled brackets, double quotes, Short visible wavelengths, double
quotes, semicolon. Line 31, indented multiple times: break,
semicolon. Line 32, indented once: WHITE, colon. Line 33, indented
once: BLACK, colon, c out, 2 left angled brackets, double quotes,
Not valid colors, double quotes, semicolon. Line 34, indented
multiple times: color equals NONE, semicolon. Line 35: right brace.
Back to Code
The largest positive number is represented as follows. plus, 99999.
Zero is represented as follows. plus 00000. The largest negative
number is represented as follows. minus 99999.
Back to Figure
The storage scheme is as follows. Sign: plus. Exponent: 8.
Mantissa: 2345.
Back to Figure
"The entries are as follows. 
Row 1. Number: plus 99,999. Power of ten notation: plus 9999 times
10 to the power of 1. Coded Representation: Sign, plus. Exponent,
1. Mantissa, 9999. Value: plus 99,990. 
Row 2. Number: minus 999,999. Power of ten notation: minus 9999
times 10 to the power of 2. Coded Representation: Sign, minus.
Exponent, 2. Mantissa: 9999. Value: minus 999,900. 
Row 3. Number: plus 1,000,000. Power of ten notation: minus 1000
times 10 to the power of 3. Coded Representation: Sign, plus.
Exponent, 3. Mantissa, 1000. Value: plus 1, 000,000. 
Row 4. Number: minus 4,932,416. Power of ten notation: minus
4932 times 10 to the power of 3. Coded Representation: Sign,
minus. Exponent, 3. Mantissa, 4932. Value: minus 4,932,000."
Back to Figure

1. Sign of number: plus. Sign of exponent: plus. Exponent: 9.
Mantissa: 9999. The largest positive number is plus 9999 times 10
to the power of 9. 2. Sign of number: minus. Sign of exponent: plus.
Exponent: 9. Mantissa: 9999. Largest negative number is minus
9999 times 10 to the power of 9. 3. Sign of number: plus. Sign of
exponent: minus. Exponent: 9. Mantissa: 0001. Smallest positive
number is plus 1 times 10 to the power of negative 9. 4. Sign of
number: minus. Sign of exponent: minus. Exponent: 9. Manitssa:
0001. Smallest negative number is negative 1 times 10 to the power
of minus 9.
Back to Figure
"The entries are as follows.
Row 1. Number: 0.1032. Power of ten notation: plus 1032 times 10
to the power of negative 4. Coded representation: Sign. Plus, minus.
Exponent. 4. Mantissa. 1032. Value: 0.1032. 
Row 2. Number: negative 5.4060. Power of ten notation: negative
5406 times 10 to the power of negative 3. Coded Representation:
sign. Minus, minus. Exponent: 3. Mantissa: 5406. Value: negative
5.406. 
Row 3. Number: negative 0.003. Power of ten notation: negative
3000 times 10 to the power of negative 6. Coded Representation:
Sign. Minus, minus. Exponent. 6. Mantissa. 3000. Value: negative
0.0030. 
Row 4. Number: 476.0321. Power of ten notation: plus 4760 times
10 to the power of negative 1. Coded Representation: Sign. Plus,
minus. Exponent. 1. Mantissa. 4760. Value: 476.0. 
Row 5. Number: 1,000,000. Power of ten notation: plus 1000 times
10 to the power of 3. Coded Representation: Sign. Plus, plus.
Exponent. 3. Mantissa. 1000. Value: 1,000,000."
Back to Figure
x: negative 1324 times 10 to the power of 3. y: 1325 times 10 to the
power of 3. Addition of x and y yields the following. 1 times 10 to the
power of 3 which equals 1000 times 10 to the power of 0.
Back to Figure

x + y: negative 1000 times 10 to the power of 0. z: 5424 times 10 to
the power of 0. The result of adding x plus y with z yields, 6424
times 10 to the power of 0.
Back to Figure
y: 1325000 times 10 to the power of 0. z: 5424 times 10 to the
power of 0. y plus z yields, 1330424 times 10 to the power of 0
which equals 1330 times 10 to the power of 3, truncated to 4 digits.
y plus z: 1330 times 10 to the power of 3. x: negative 1324 times 10
to the power of 3. x plus, left parentheses, y plus z, right
parentheses yields, 6 times 10 to the power of 3 which equals 6000
times 10 to the power of 0.
Back to Figure
The values from left to right are a follows. Plus sign, plus sign, 1, 0,
0, 0, 0.
Back to Figure
The values from left to right are as follows. Plus sign, minus sign, 4,
1, 0, 3, 2.
Back to Figure
Markings are drawn on the number line every 1 unit. 10 divisions are
marked between 0 and 1. Arrows point to divisions corresponding to
0.1, 0.2, and 0.5. The region between divisions 0 and 0.1 is shaded.
An arrow pointing to the shaded region reads, 0.01 to 0.09.
Back to Figure
f a b s, left parentheses, r minus s, right parentheses, less than,
ERROR, underscore, TERM.
Back to Figure
f a b s, left parentheses, r minus s, right parentheses, less than,
0.0005 asterisk s.

Back to Figure
4210 times 10 to the power of negative 8, times, 1324 times 10 to
the power of negative 8 yields 8420000 times 10 to the power of
negative 16 which equals 8420 times 10 to the power of negative 13.
Back to Figure
9999 times 10 to the power of 9, times, 1000 times 10 to the power
of 9 yields 9999000 times 10 to the power of negative 18 which
yields 9999 times 10 to the power of 21.
Back to Figure
n factorial divided by, r factorial times, left parentheses, n minus r,
right parentheses, factorial.
Back to Figure
hands equals Factorial, left parentheses, 52, right parentheses,
forward slash, left parentheses, Factorial, left parentheses, 5, right
parentheses, asterisk, Factorial, left parentheses, 47, right
parentheses, right parentheses, semicolon.
Back to Figure
52 factorial divided by quantity 5 factorial times 47, equals,
numerator over denominator. Numerator equals 52 times 51 times
50 times 49 times 48 times 47 times 46 times 45 times 44 times,
dot, dot, dot. Denominator equals left parentheses, 5 times 4 times
3 times 2 times 1, right parentheses, times, left parentheses, 47
times 46 times 45 times 44 times, dot, dot, dot, right parentheses.
Back to Figure
hands equals 52 asterisk 51 asterisk 50 asterisk 49 asterisk 48,
forward slash, Factorial, left parentheses, 5, right parentheses,
semicolon.
Back to Figure

100000000 times 10 to the power of negative 8, plus, 1234 times 10
to the power of negative 8 yields, 100001234 times 10 to the power
of negative 8.
Back to Figure
1000 times 10 to the power of negative 3, minus, 1000 times 10 to
the power of negative 3 yields 0.
Back to Figure
Line 1: string name, semicolon. Line 2: name equals double quotes,
James Smith, double quotes, semicolon. len equals name dot
length, left parentheses, right parentheses, semicolon. Line 3: dot,
dot, dot.
Back to Figure
The array has 3 memory locations. The array is labeled, Unnamed
array. The contents of the array are as follows. Index: left square
bracket, 0, right square bracket. Value: single quote, uppercase h,
single quote. Index: left square bracket, 1, right square bracket.
Value: single quote, lowercase i, single quote. Index: left square
bracket, 2, right square bracket. Value: single quote, back slash, 0,
single quote.
Back to Figure
Line 1: char my S t r, left square bracket, 8, right square bracket,
semicolon. 2 forward slashes. Room for 7 significant characters
plus, single quote, back slash, 0, single quote. Line 2: blank. Line 3:
my S t r, left square bracket, 0, right square bracket, equals, single
quote, uppercase h, single quote, semicolon. Line 4: my S t r, left
square bracket, 1, right square bracket, equals, single quote,
lowercase i, single quote, semicolon. Line 5: my S t r, left square
bracket, 2, right square bracket, equals, single quote, back slash, 0,
single quote, semicolon.
Back to Figure

Line 1: int S t r Length, left parentheses, const char s t r, left square
bracket, right square bracket, right parentheses. Line 2: 2 forward
slashes. Precondition, colon. Line 3: 2 forward slashes. s t r holds a
null terminated string. Line 4: 2 forward slashes, Post condition,
colon. Line 5: 2 forward slashes. Function value, equals, equals,
number of characters in s t r, left parentheses, excluding, single
quote, back slash, 0, single quote, right parentheses. Line 6: left
brace. Line 7, indented once: int i equals 0, semicolon. 2 forward
slashes. Index variable. Line 8, indented once: while, left
parentheses, s t r, left square bracket, i, right square bracket,
exclamation mark, equals, single quote, back slash, 0, single quote,
right parentheses. Line 9, indented once: i plus, plus, semicolon.
Line 10, indented once: return i, semicolon. Line 11: right brace.
Back to Figure
The contents of the array are as follows. Index: left square bracket,
0, right square bracket. Value: single quote, uppercase b, single
quote. Index: left square bracket, 1, right square bracket. Value:
single quote, lowercase y, single quote. Index: left square bracket, 2,
right square bracket. Value: single quote, back slash, 0, single
quote. Index: left square bracket, 3, right square bracket. Value:
blank. And so on.
Back to Figure
c out, 2 left angled brackets, S t r Length, left parentheses, my S t r,
right parentheses, semicolon.
Back to Figure
c out, 2 left angled brackets, S t r Length, left parentheses, double
quotes, Hello, double quotes, right parentheses, semicolon.
Back to Figure
int delta, left square bracket, 5, right square bracket, equals, left
brace, 25, comma, negative 3, comma, 7, comma, 13, comma, 4,
right brace, semicolon.

Back to Figure
char message, left square bracket, 8, right square bracket, equals,
left brace, single quote, uppercase w, single quote, comma, single
quote, lowercase h, single quote, comma, single quote, lowercase o,
single quote, comma, single quote, lowercase o, single quote,
comma, single quote, lowercase p, single quote, comma, single
quote, lowercase s, single quote, comma, single quote, exclamation
mark, single quote, comma, single quote, back slash, 0, single
quote, right brace, semicolon.
Back to Figure
char message, left square bracket, 8, right square bracket, equals,
double quotes, Whoops, exclamation mark, double quotes,
semicolon.
Back to Figure
Line 1: char prompt M s g, left square bracket, right square bracket,
equals, double quotes, Enter a positive number, colon, double
quotes, semicolon. 2 forward slashes. Size is 25. Line 2: char e r r
M s g, left square bracket, right square bracket, equals, double
quotes, Value must be positive, dot, double quotes, semicolon. 2
forward slashes. size is 24.
Back to Figure
Line 1. char my S t r, left square bracket, 20, right square bracket,
equals, double quotes, Hello, double quotes, semicolon. 2 forward
slashes. O K. Line 2: dot, dot, dot. Line 3: my S t r, equals, double
quotes, Howdy, double quotes, semicolon. 2 forward slashes. Not
allowed.
Back to Figure
Line 1: int alpha, left square bracket, 100, right square bracket,
semicolon. Line 2: dot, dot, dot. Line 3: c out, 2 left angled bracket,
alpha, semicolon. 2 forward slashes. Not allowed.

Back to Figure
c out, 2 left angled brackets, double quotes, Results are, colon,
double quotes, semicolon.
Back to Figure
Line 1: char m s g, left square bracket, 8, right square bracket,
equals, double quotes, Welcome, double quotes, semicolon. Line 2:
dot, dot, dot. Line 3: c out, 2 left angled brackets, m s g, semicolon.
Back to Figure
Line 1: char first Name, left square bracket, 31, right square
bracket, semicolon. 2 forward slashes. Room for 30 characters plus,
single quote, back slash, 0, single quote. Line 2: char last Name, left
square bracket, 31, right square bracket, semicolon. Line 3: c in, 2
right angled brackets, first Name, 2 right angled brackets, last
Name, semicolon.
Back to Figure
Line 1. blank space, blank space, John, blank space, Smth, blank
space, blank space, blank space, 25.
Back to Figure
Line 1: blank space, blank space, blank space, 25.
Back to Figure
c in dot get, left parentheses, input char, right parentheses,
semicolon.
Back to Figure
c in dot get, left parentheses, my S t r, comma, char Count plus 1,
right parentheses, semicolon.
Back to Figure

Line 1: char one Line, left square bracket, 81, right square bracket,
semicolon. 2 forward slashes. Room for 80 characters plus, single
quote, back slash, 0, single quote. Line 2: dot, dot, dot. Line 3: c in
dot get, left parentheses, one Line, comma, 81, right parentheses,
semicolon.
Back to Figure
Line 1: char dummy, semicolon. Line 2: dot, dot, dot. Line 3: c in dot
get, left parentheses, string 1, comma, 81, right parentheses,
semicolon. Line 3: c in dot get, left parentheses, dummy, right
parentheses, semicolon. Line 4: c in dot get, left parentheses,
dummy, right parentheses, semicolon. 2 forward slashes. Consume
new line before next, double quotes, get, double quotes.
Back to Figure
c in dot ignore, left parentheses, 200, comma, single quote, back
slash, n, single quote, right parentheses, semicolon.
Back to Figure
Line 1: char response, left square bracket, 5, right square bracket,
semicolon. 2 forward slashes. Room for 4 characters plus, single
quote, back slash, 0, single quote. Line 2: c in dot get, left
parentheses, response, comma, 5, right parentheses, semicolon. 2
forward slashes. Input at most 4 characters.
Back to Figure
Line 1: c in dot ignore, left parentheses, 100, comma, single quote,
back slash, n, single quote, right parentheses, semicolon. 2 forward
slashes. Skip remaining chars up to and. Line 2: 2 forward slashes.
Including, single quote, back slash, n, single quote.
Back to Figure
"The table has 3 columns labelled Statement, Skips Leading
Whitespace, question mark, and, Stops reading when, question
mark. The row entries are as follows. 

Row 1. Statement: c in, 2 right angled brackets, input S t r,
semicolon. Skips Leading Whitespace, question mark: Yes. Stops
Reading When, question mark: At the first trailing whitespace
character, left parentheses, which is not consumed, right
parentheses. 
Row 2. Statement: c in dot get, left parentheses, input S t r, comma,
21, right parentheses, semicolon. Skips Leading Whitespace,
question mark: No. Stops Reading When, question mark: When
either 20 characters are read or, single quote, back slash, n, single
quote, is encountered, left parentheses, which is not consumed,
right parentheses."
Back to Table
Line 1: i f stream file 1, semicolon. Line 2: i f stream file 2,
semicolon. Line 3: char file Name, left square bracket, 51, right
square bracket, semicolon. 2 forward slashes. Max 50 characters
plus, single quote, back slash, 0, single quote. Line 4: file 1 dot
open, left parentheses, double quotes, students dot dat, double
quotes, right parentheses, semicolon. Line 5: c in dot get, left
parentheses, file Name, comma, 51, right parentheses, semicolon. 2
forward slashes. Read at most 50 characters. Line 6: c in dot ignore,
left parentheses, 100, comma, single quote, back slash, n, single
quote, right parentheses, semicolon. 2 forward slashes. Skip rest of
input line. Line 7: file 2 dot open, left parentheses, file Name, right
parentheses, semicolon.
Back to Figure
Line 1: i f stream in File, semicolon. Line 2: string file Name,
semicolon. Line 3: blank. Line 4: c in, 2 right angled brackets, file
Name, semicolon. Line 5: in File dot open, left parentheses, file
Name dot c undrescore s t r, left parentheses, right parentheses,
right parentheses, semicolon.
Back to Figure
"The table has 4 columns labelled, Header File, Function, Function
Value, and Effect. The row entries are as follows. 

Row 1. Header file: left angled bracket, c string, right angled
bracket. Function: s t r len, left parentheses, s t r, right parentheses.
Function Value: Integer length of s t r, left parentheses, excluding,
single quote, back slash, 0, single quote. Effect: Computes length of
s t r.
Row 2. Header file: left angled bracket, c string, right angled
bracket. Function: s t r c m p, left parentheses, s t r 1, comma, s t r
2, right parentheses. Function Value: An integer less than 0, comma,
if s t r 1 less than s t r 2. Effect: Compares s t r 1 and s t r 2.
Row 3. Header file: blank. Function: blank. Function Value: The
integer 0, comma, if s t r 1 equals s t r 2. Effect: blank.
Row 4. Header file: blank. Function: blank. Function Value: An
integer greater than 0, if s t r 1 greater than s t r 2. Effect: blank.
Row 5. Header file: left angled bracket, c string, right angled
bracket. Function: s t r c y p, left parentheses, to S t r, comma, from
S t r. Function Value: Base address of to S t r, left parentheses,
usually ignored, right parentheses. Effect: Copies from S t r, left
parentheses, including, single quote, back slash, 0, single quote,
right parentheses, to, to S t r, overwriting what was there,
semicolon, to S t r must be large enough to hold the result."
Back to Table
Line 1: hash include, left angled bracket, c string, right angled
bracket. Line 2: dot, dot, dot. Line 3: char subject, left square
bracket, right square bracket, equals, double quotes, Computer
Science, double quotes, semicolon. Line 3: c out, 2 left angled
brackets, s t r len, left parentheses, subject, right parentheses,
semicolon. 2 forward slashes. Prints 16.
Back to Figure
Line 1: hash include, left angled bracket, c string, right angled
bracket. Line 2: dot, dot, dot. Line 3: char my S t r, left square
bracket, 100, right square bracket, semicolon. Line 4: dot, dot, dot.
Line 5: my S t r equals double quotes, A b r a c a d a b r a, double
quotes, semicolon. 2 forward slashes. No. Line 6: s t r c p y, left
parentheses, my S t r, comma, double quotes, A b r a c a d a b r a,

double quotes, right parentheses, semicolon. 2 forward slashes.
Yes.
Back to Figure
Line 1: if, left parentheses, s t r c m p, left parentheses, s t r 1,
comma, s t r 2, right parentheses, less than, 0, right parentheses, 2
forward slashes. If s t r 1 is less than s t r 2, dot, dot, dot.
Back to Figure
single quote, uppercase a, single quote, single quote, 8, single
quote, single quote, right parentheses, single quote, single quote,
plus, single quote.
Back to Figure
c out, 2 left angled brackets, double quotes, back slash, a, Whoops,
exclamation mark, back slash, n, double quotes, semicolon.
Back to Figure
c out, 2 left angled brackets, double quotes, She said, back slash,
double quotes, Hi, back slash, double quotes, double quotes,
semicolon.
Back to Figure
She said, double quotes, Hi, double quotes.
Back to Figure
The programming process has three phases. The problem-solving
phase, the implementation phase, and the maintenance phase. The
problem-solving phase involves the following steps. Analysis and
specification. General solution which provides an algorithm. Verify.
The implementation phase involves the following steps. Concrete
solution in the form of a program. Test. The implementation phase
also goes back to the steps in the problem-solving phase and the
implementation phase also runs repeatedly. The maintenance phase

involves the following step. Revise to address new requirements and
correct errors discovered in use.
Back to Figure
An algorithm can be translated into different programming
languages. An algorithm could be Nell's C plus plus program, Java
program, or Ada program. The same algorithm can be translated by
different people. An algorithm could be Nell's C plus plus program,
Chip's C plus plus program, or Mark's C plus plus program.
Back to Figure
The programming process involves taking up a problem and taking it
through the problem-solving phase which yields an algorithm and the
implementation phase which yields a program. It's tempting to take a
shortcut when considering a problem by directly taking it to the
implementation phase while avoiding the problem-solving phase.
This is not advisable.
Back to Figure
The following is a table of binary numbers and their decimal
equivalents. Binary: 000. Decimal Equivalent: 0. Binary: 0 0 1;
Decimal Equivalent: 1. Binary: 0 1 0; Decimal Equivalent: 2. Binary:
0 1 1; Decimal Equivalent: 3. Binary: 1 0 0; Decimal Equivalent: 4.
Binary: 1 0 1; Decimal Equivalent: 5. Binary: 0 1 0; Decimal
Equivalent: 6. Binary: 1 1 1; Decimal Equivalent: 7. Examples of
binary addition and their decimal equivalents. Binary Addition: 0 0 1
+ 0 0 1 = 0 1 0; Decimal Equivalent: 1 + 1 = 2. Binary Addition: 0 1 1
+ 0 1 0 = 1 0 1; Decimal Equivalent: 3 + 2 = 5. Binary Addition: 1 1 1
+ 0 0 1 = 1 0 0 0. Decimal Equivalent: 7 + 1 = 8. Examples of binary
subtraction. Binary Subtraction: 0 1 1 - 0 1 1 = 0 0 0; Decimal
Equivalent: 3 - 3 = 0 Binary Subtraction: 1 1 0 - 0 1 0 = 1 0 0;
Decimal Equivalent: 6 - 2 = 4. Binary Subtraction: 1 0 1 - 0 1 1 = 0 1
0. Decimal Equivalent: 5 - 3 = 2.
Back to Table

Two samples of Assembly language code. ADD R 1, R 3, R 5. SUB
R 2, R 6, R 1. The binary equivalent of the previous assembly
language code is the following. 1001 001 011 101. 1010 010 110
001. The first number is the operation. The second number is the
result. The third number is operand 1. The fourth number is operand
2. The meaning of the code is the following. Add R 3 to R 5 and put
result in R 1. Subtract R 1 from R 6 and put result in R 2.
Back to Figure
The levels of abstraction. Human thought can be expressed in
natural language such as English, French, German, et cetera. It can
be expressed in high-level language such as C plus plus, Java,
Visual Basic, et cetera. It can be expressed in low-level language
such as assembly language. It can also be expressed in machine
code understood by a computer.
Back to Figure
A source program written in C plus plus is executed by a translator
program known as a compiler installed on a computer. Compilers
exist for different kinds of computers such as Windows P Cs, Unix
Workstations, and Macintosh computers. The compilation process
produces an object program which is a machine language version of
the source program for the target computer. The computer then
executes the object program.
Back to Figure
The steps in the compilation and execution process of a program.
Compilation involves the following steps. Source program. Computer
executes compiler program. Machine language version of the source
program known as an object program is generated. The
intermediate step leading to execution is the loading of the object
program. Execution involves the following steps. Input data.
Computer executes machine language version of the source
program. The provides results.
Back to Figure

Some control structures in programming languages are sequences,
selections, loops, and subprograms. Sequence: A sequence is a set
of statements that execute one after the other. This is comparable to
milestones on a single stretch of a road. Selection: A selection is
also called a branch or decision. An if construct is an example of a
selection. An if construct has the following code structure. IF
condition THEN statement 1 ELSE statement 2. A condition is
evaluated in the if construct. If the condition evaluates to true
statement 1 is executed. If the condition is false, statement 2 is
evaluated. This is comparable to a stretch of road that splits into two
directions. Loop: A loop is also called a repetition or iteration. While
is an example of a looping construct which has the following code
structure. WHILE condition DO statement 1. A condition is evaluated
by WHILE. If the condition evaluates to true, statement 1 is
executed. If the condition evaluates to false, the WHILE loop is
exited. A while loop is similar to a circular racing track on a stretch of
road which can be entered and exited. Subprogram: A subprogram
is also called a procedure, function, method, or subroutine. A
subprogram has the following structure. A subprogram is a
meaningful collection of any of the programming constructs listed
previously. A subprogram is similar to the task that is accomplished
when one goes on a path from home to office. Subprogram 1 could
be the process of going to a bakery to purchase cake. Subprogram
2 could the process of going to a party store to purchase balloons.
Back to Figure
Listing of a C plus plus program that prints a message on the
console. Program code. Line 1: Forward slash, forward slash, a line
of asterisk. Line 2: Forward slash, forward slash, This, program,
outputs, Hello, World exclamation mark, period. Line 3: Forward
slash, forward slash, a line of asterisks. Line 4: Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5: using, name s
t d semicolon. Line 6: i n t, main, left parenthesis right parenthesis.
Line 7: Left brace. Line 8, indented once: c out, double left angle
bracket, open quotes, Hello, World exclamation mark close quotes,
semicolon. Line 9, indented once: return, 0, semicolon. Line 10:
Right brace.

Back to Figure
Listing of a C plus plus program that prints a message on the
console. Program code. Line 1: Forward slash, forward slash, a line
of asterisk. Line 2: Forward slash, forward slash, This, program,
outputs, Hello, World exclamation mark, period. Line 3: Forward
slash, forward slash, a line of asterisks. Line 4: Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5: using, name s
t d semicolon. Line 6: i n t, main, left parenthesis right parenthesis.
Line 7: Left brace. Line 8, indented once: capital C out, double left
angle bracket, open quotes, Hello, World exclamation mark, close
quotes, semicolon. Line 9, indented once: return, 0, semicolon. Line
10: Right brace.
Back to Figure
A screenshot of an integrated development environment which can
be used to develop C plus plus projects. Initially, a new project has
to be created by selecting"New Project" from the File menu in the
application and then the name of the project needs to be entered in
the dialog box that appears.
Back to Figure
A screenshot of code being executed in an integrated development
environment. There is some error in the code which shows up when
the program is compiled. In this case, a red mark is displayed in the
fifth line of the code with a message that says the keyword c out
was not declared within this scope.
Back to Figure
Listing of a C plus plus program that prints a message on the
console. Program code. Line 1: Forward slash, forward slash, a line
of asterisk. Line 2: Forward slash, forward slash, This, program,
outputs, Hello, World exclamation mark, period. Line 3: Forward
slash, forward slash, a line of asterisks. Line 4: Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5: using, name s
t d, semicolon. Line 6: i n t, main, left parenthesis, right parenthesis.

Line 7: Left brace. Line 8, indented once: c out, double left angle
bracket, open double quotes, Hello, World exclamation mark, close
quotes, semicolon. Line 9, indented once: return, 0, semicolon. Line
10: Right brace.
Back to Figure
Listing of a C plus plus program that prints a message on the
console. Program code. Line 1: Forward slash, forward slash, a line
of asterisk. Line 2: Forward slash, forward slash, This, program,
outputs, Hello, Universe exclamation mark, period. Line 3: Forward
slash, forward slash, a line of asterisks. Line 4: Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5: using, name s
t d, semicolon. Line 6: i n t, main, left parenthesis, right parenthesis.
Line 7: Left brace. Line 8, indented once: c out, double left angle
bracket, open double quotes, Hello, Universe exclamation mark,
close quotes, semicolon. Line 9, indented once: return, 0,
semicolon. Line 10: Right brace.
Back to Figure
A computer is made of an input device, a central processing unit, an
output devices and additional input and output devices as required.
The input device feeds input to the central processing unit. The
central processing unit contains a control unit and an arithmetic and
logic unit that constantly interacts with a memory unit. Once the
central processing unit has processed information it is sent to the
output device. Additional input and output devices are connected to
the central processing unit as needed.
Back to Figure
Memory is visualized as a grid of multiple cells. A 4 by 3 grid of cells
within the larger memory unit represents your data. Another grid of 6
by 6 cells in the memory unit represents your program.
Back to Figure
A girl is working on a laptop computer. The laptop is connected to a
pad input device on which the girl is drawing with her hand. The

output is displayed on the laptop's screen which is an output device.
Back to Figure
A list of temperatures and test scores are given. The temperatures
are 42, 18, 27, 95, 55, 72, 33, 78, 86, 61, 58, and 91. The test
scores are 27, 14, 55, 98, 72, 66, 45, 12, 39, 70, and 68. The same
method can be used to find the highest and lowest value in both
temperatures and test scores. The highest temperature is 95. The
lower temperature is 18. The highest test score is 98. The lowest
test score is 12.
Back to Figure
A library catalog system can give insight into how to organize a parts
inventory.
Back to Figure
An example of means-ends analysis. Start is Boston and the goal is
Austin. The means is to fly, walk, hitchhike, bike, drive, sail, or bus.
Start is Boston and the goal is Austin. The revised means is to fly to
Chicago and then Austin or fly to Atlanta and then to Austin. The
start is Boston. The intermediate goal is Chicago and the goal is
Austin. The means to the intermediate goal is commuter flight, walk,
hitchhike, bike, drive, or bus. The solution is to take a commuter
flight to Chicago and then catch a cheap flight to Austin.
Back to Figure
The divide and conquer strategy involves taking a hard problem and
dividing into an easy subproblem, hard subproblem, and an easy
subproblem. The hard subproblem is further divided into two more
easy subproblems.
Back to Figure
The building-block approach attacks a problem by checking if any
solutions for smaller pieces of the problem exists. Then these
solutions are combined together to solve the big problem. An

existing software may have a shipping system, receiving system,
accounts payable system, and accounts receivable system. A new
program for an inventory system is made with code that mortars
blocks together. The new program has modules for parts shipped,
parts received, parts on order, and parts sold and not shipped.
Back to Figure
The merging solutions strategy to solving problems. Let us there is
code solution for summing values on a file that has the following
steps. Open file. Set sum to 0. While data on file, Read value and
Add value to sum. Close file. Additionally, there is a code solution for
counting values on a file with the following steps. Open file. Set
count to 0. While data on file, Read value and add one to count.
Close file. Both these solutions can be merged to build a solution for
summing and counting values on a file with the following code. Open
file. Set sum to 0. Set count to 0. While data on file, read value, add
value to sum, and add one to count. Close file.
Back to Figure
Listing of a C plus plus program that says whether an entered year
is a leap year or not. Program code. Line 1: Forward slash, forward
slash, a line of asterisks. Line 2: Forward slash, forward slash, Leap
Year, program. Line 3: This, program, inputs, a, year, and, outputs,
whether, the, year. Line 4: is, a, leap, year. Line 5: Forward slash,
forward slash, a line of asterisks. Line 6: Hash, include, left angle
bracket, i o stream, right angle bracket, tab forward slash, forward
slash, Access, output, stream. Line 7: using, name s t d, semicolon.
Line 8: bool, Is Leap Year, left parenthesis, i n t, year, right
parenthesis, semicolon, forward slash, forward slash, Prototype, for,
sub algorithm. Line 9: i n t, main, left parenthesis, right parenthesis.
Line 10: Left brace. Line 11, indented once: i n t, year, semicolon,
tab forward slash, forward slash, Will, hold, year, to, be, tested. Line
12, indented once: c out, double left angle bracket, open quotes,
Enter, a, year, A D, comma,, for, example, comma,, 1997, period,
close quotes. Line 13, indented twice: Double left angle bracket, end
l, semicolon, tab forward slash, forward slash, Prompt, for, input.
Line 14, indented once: c in, double right angle bracket, year,

semicolon, tab forward slash, forward slash, Read, value, into, year.
Line 15, indented once: if, left parenthesis, Is Leap Year, left
parenthesis, year, right parenthesis, right parenthesis, forward slash,
forward slash, Test, for, leap, year. Line 16, indented twice: c out,
double left angle bracket, year, double left angle bracket, open
quotes,, is, a, leap, year, period, close quotes, double left angle
bracket, end l, semicolon. Line 17, indented once: else. Line 18,
indented twice: c out, double left angle bracket, year, double left
angle bracket, open quotes,, is, not, a, leap, year, period, close
quotes, double left angle bracket, end l, semicolon. Line 19,
indented once: return, 0, semicolon, tab Indicate, successful,
completion. Line 20: Right brace. Line 21: Forward slash, forward
slash, a line of asterisks. Line 22: bool, Is Leap Year, left
parenthesis, i n t, year, right parenthesis. Line 23: Forward slash,
forward slash, Is Leap Year, returns, true, if, year, is, a, leap, year,
and. Line 24: Forward slash, forward slash, false, otherwise. Line
25: Left brace. Line 26, indented once: if, left parenthesis, year,
percentage, 4, exclamation mark, equals, 0, right parenthesis, tab
Is, year, not, divisible, by, 4, question mark. Line 27, indented twice:
return, false, semicolon, tab forward slash, forward slash, If, so,
comma, can't, be, a, leap, year. Line 28: Tab spaces, forward slash,
forward slash, Must, be, divisible, by, 4, at, this, point. Line 29,
indented once: if, left parenthesis, year, percentage, 100,
exclamation mark, equals, 0, right parenthesis, forward slash,
forward slash, Is, year, not, a, multiple, of, hundred, question mark.
Line 30, indented twice: return, true, semicolon, tab If, so, comma,
is, a, leap, year. Line 31: Tab spaces, forward slash, forward slash,
Must, be, divisible, by, 100, at, this, point. Line 32, indented once: if,
left parenthesis, year, percentage, 400, exclamation mark, equals, 0,
right parenthesis, forward slash, forward slash, Is, year, not, a,
multiple, of, 400, question mark. Line 33, indented twice: return,
false, semicolon. Line 34: Tab spaces, forward slash, forward slash,
Must, be, divisible, by, 400, at, this, point. Line 35, indented twice:
return, true, semicolon. Line 36: Right brace.
Back to Figure
The output of the C plus plus program that says whether an entered
year is a leap year or not. Line 1: Enter a year A D, for example,

1997. Line 2: 2008. Line 3: 2008 is a leap year.
Back to Figure
A sample C plus plus program may have the main function, a square
function, and a cube function.
Back to Figure
Listing of a C plus plus program with three functions, main, Square,
and Cube. Program code. Line 1: Forward slash, forward slash, a
line of asterisks. Line 2: Forward slash, forward slash, This,
program, demonstrates, the, use, of, three, functions. Line 3:
Forward slash, forward slash, a line of asterisks. Line 4: Hash,
include, left angle bracket, i o stream, right angle bracket. Line 5:
using, name s t d, semicolon. Line 6: i n t, Square, left parenthesis, i
n t, space right parenthesis, semicolon. Line 7: i n t, Cube, left
parenthesis, i n t, right parenthesis, semicolon. Line 8: i n t, main,
left parenthesis, right parenthesis. Line 9: Left brace, forward slash,
forward slash, Start, of, main, function, body. Line 10, indented
once: c out, double left angle bracket, open double quotes, The
square of 27 is, close quotes, double left angle bracket, Square, left
parenthesis, 27, right parenthesis, double left angle bracket, end l,
semicolon. Line 11, indented once: c out, double left angle bracket,
open double quotes, and the cube of 27 is, close quotes, double left
angle bracket, Cube, left parenthesis, 27, right parenthesis, double
left angle bracket, end l, semicolon. Line 12, indented once: return,
0, semicolon. Line 13: Right brace, tab spaces, forward slash,
forward slash, End, of, main, function, body. Line 13: i n t, Square,
left parenthesis, i n t, n, right parenthesis. Line 14, Left brace, tab
spaces, forward slash, forward slash, Start, of, Square, function,
body. Line 15, indented once: return, n, asterisk, n, semicolon. Line
16: Right brace, tab spaces, forward slash, forward slash, End, of,
Square, function, body. Line 17: i n t, Cube, left parenthesis, i n t, n,
right parenthesis. Line 18: Left brace, tab spaces, forward slash,
forward slash, Start, of, Cube, function, body. Line 19, indented
once: return, n, asterisk, n, asterisk, n, semicolon. Line 20: Right
brace, tab spaces, forward slash, forward slash, End, of, Cube,
function, body.

Back to Figure
The template for an identifier is C plus plus. The template begins
with a curly brace which indicates a list of items from which one can
be chose. The first template shows a curly brace that is followed by
a Letter and an underscore. An identifier can thus begin with a letter
or an underscore. The second template shows a curly brace
followed by a letter, an underscore, a digit, and three dots. This
means that an identifier can begins with a letter, or an underscore
and can be optionally followed by one or more letters, underscore,
or digits.
Back to Figure
The template for letter shows a curly brace to the right of which are
the uppercase and lowercase alphabets. The template for digit
shows a curly brace to the right of which are the numbers from 0 to
9.
Back to Figure
The main function has the following syntax. Program code. Line 1: i
n t, main, left parenthesis, right parenthesis. Line 2: Left
parenthesis. Line 3: Indented statement or statements. Line 4: Right
brace.
Back to Figure
The template for an identifier is C plus plus. The template begins
with a curly brace which indicates a list of items from which one can
be chose. The first template shows a curly brace that is followed by
a Letter and an underscore. An identifier can thus begin with a letter
or an underscore. The second template shows a curly brace
followed by a letter, an underscore, a digit, and three dots. This
means that an identifier can begins with a letter, or an underscore
and can be optionally followed by one or more letters, underscore,
or digits.
Back to Figure

Examples of identifiers in C plus plus. sum underscore of
underscore squares. J 9. box underscore 22 capital A. Get Data. Bin
3 D 4. count.
Back to Figure
Computer memory visualized as a set of Post Office mail boxes. A
set of boxes are shown which are numbered from 100 to 149 in 5
rows of 10 boxes each. The box numbers as used as addresses that
designate particular locations in memory.
Back to Figure
The following are some examples of the char data type. Open single
quote, capital A, Close single quotes. Open single quotes, a, Close
single quotes. Open single quotes, 8, Close single quotes. Open
single quotes, 2, Close single quotes. Open single quotes, plus,
Close single quotes. Open single quotes, minus, Close single
quotes. Open single quotes, dollar, Close single quotes. Open single
quotes, question mark, Close single quotes. Open single quotes,
asterisk, Close single quotes. Open single quotes, character Close
single quotes.
Back to Figure
Examples of a string in C plus plus. Open quotes, Problem, Solving,
close quotes. Open quotes, C plus plus, close quotes. Open quotes,
Programming, and, close quotes. Open quotes, period, close
quotes.
Back to Figure
A string that is invalid because it has been typed in two lines. Line 1:
Open quotes, This, string, is invalid because it. Line 2: is, typed, on,
more, than, one, line, period, close quotes.
Back to Figure
An example of a null string. Open quotes, close double quotes.

Back to Figure
A diagram that shows how a variable is declared. The variable my
Char is declared. The identifier of this variable is my Char. It is
stored in the memory location 1 1 0 1 0 1 0 0 1 1. The value stored
for the variable is P. The variable belongs to the char data type.
Back to Figure
The syntax template for a variable declaration. Data Type, identifier,
identifier, three dots, semicolon.
Back to Figure
Several variables declared in one statement. Program code. Line 1.
char, letter, comma, middle Initial, comma, c h, semicolon.
Back to Figure
Variables declared in multiple statements. Program code. Line 1:
char, letter, semicolon. Line 2: char, middle Initial, semicolon. Line 3:
char, c h, semicolon.
Back to Figure
Comments added to variable declarations. Program code. Line 1:
float, pay Rate, semicolon, Forward slash, forward slash,
Employee’s, pay, rate. Line 2: float, hours, semicolon, Forward
slash, forward slash, Hours, worked. Line 3: float, wages, semicolon,
Forward slash, forward slash, Wages, earned. Line 4: i n t, emp
Num, semicolon, Forward slash, forward slash, Employee, I D,
number.
Back to Figure
Examples of characters and strings which are constants. Program
code. Open single quotes, capital A, close single quotes. Open
single quotes, at, close single quotes. Open double quotation marks,
Howdy boys, close double quotation marks. Open double quotation

marks, Please enter an employee number, colon, close double
quotation marks.
Back to Figure
An example of a literal string. Program code. Open quotes,
Programming, and, Problem, Solving, with, C plus plus, close
quotes.
Back to Figure
An example of a named constant. BOOK underscore TITLE.
Back to Figure
The syntax template for a constant declaration. Const, Data Type,
Identifier, equals, Literal Value, semicolon.
Back to Figure
Some examples of constant declarations. Program code. Line 1:
const, string, STARS, equals, open quotes, a few asterisks, close
double quotation marks, semicolon. Line 2: const, char, BLANK,
equals, open single quotes, character close single quotes,
semicolon. Line 3: const, string, BOOK underscore TITLE, equals,
open quotes, Programming, and, Problem, Solving, with , C plus
plus, close quotes, semicolon. Line 4: const, string, MESSAGE,
equals, open quotes, Error, condition, close quotes, semicolon.
Back to Figure
Constant declarations with comments added to them. Program
code. Line 1: const, float, MAX underscore HOURS, ,equals, 40.0,
semicolon, forward slash, forward slash, Maximum, normal, work,
hours. Line 2: const, float, OVER TIME, equals, 1.5, semicolon,
forward slash, forward slash, Overtime, pay, rate, factor.
Back to Figure

Listing of a C plus plus program that contains just declarations.
Program code. Line 1: Forward slash, forward slash, a line of
asterisk. Line 2: Forward slash, forward slash, This, program,
contains, only, declarations. Line 3: Forward slash, forward slash, a
line of asterisks. Line 4: Hash, include, left angle bracket, i o stream,
right angle bracket. Line 5: Hash, include, left angle bracket, string,
right angle bracket. Line 6: using, name s t d, semicolon. Line 7: i n
t, main, left parenthesis, right parenthesis. Line 8: Left brace. Line 9,
indented once: const, string, NAME, equals, open quotes, Susy,
Sunshine, close quotes, semicolon. Line 10, indented once: const,
char, INITIAL, equals, open single quotes, S, close single quotes,
semicolon. Line 11, indented once: const, float, TAX underscore
RATE, equals, 12.5, semicolon. Line 12, indented once: float, hourly
Wage, semicolon. Line 13, indented once: i n t, number Of
Dependents, semicolon. Line 14, indented once: string, job
Description, semicolon. Line 15, indented once: Forward slash,
forward slash, Rest, of, program. Line 16: Right brace.
Back to Figure
Some examples of identifiers used by programmers. pay underscore
rate. e m p underscore n u m. pay underscore file.
Back to Figure
Examples of convention used for identifiers. length In Yards. middle
Initial. hours.
Back to Figure
Examples of convention used for functions and data types. Calc Pay,
left parenthesis, pay Rate, comma, hours, comma, wages, right
parenthesis. Cube, left parenthesis, 27, right parenthesis. My Data
Type.
Back to Figure
Examples of convention used for named constants. BOOK
underscore TITLE. OVERTIME. MAX underscore LENGTH.

Back to Figure
An assignment statement. Program code. Line 1: last Name,,
equals, open double quotation marks, Lincoln, close double
quotation marks.
Back to Figure
The syntax template for an assignment statement. Variable equals
Expression, semicolon.
Back to Figure
Some declaration statements. Program code. Line 1: string, first
Name, semicolon. Line 2: string, middle Name, semicolon. Line 3:
string, last Name, semicolon. Line 4: string, title, semicolon. Line 5:
char, middle Initial, semicolon. Line 6: char, letter, semicolon.
Back to Figure
Some valid assignment statements. Program code. Line 1: first
Name, equals, open quotes, Abraham, close quotes, semicolon.
Line 2: middle Name, equals, , first Name, semicolon. Line 3: middle
Name, equals, open quotes, close quotes, semicolon. Line 4: last
Name, equals, open quotes, Lincoln, close quotes, semicolon. Line
5: title, equals, open quotes, President, close quotes, semicolon.
Line 6: middle Initial, equals, open single quotes, character close
single quotes, semicolon. Line 7: letter, equals, middle Initial,
semicolon.
Back to Figure
Some string variables declared. Program code. Line 1: string, book
Title, semicolon. Line 2: string, phrase 1, semicolon. Line 3: string,
phrase 2, semicolon. Line 4: phrase 1, equals, open quotes,
Programming, and, close quotes, semicolon. Line 5: phrase 2,
equals, open quotes, Problem, Solving, close quotes, semicolon.
Back to Figure

String concatenation. Program code. Line 1: book Title, equals,
phrase 1, plus, phrase 2, semicolon.
Back to Figure
Result of concatenating strings. Open quotes, Programming, and,
Problem, Solving, close quotes.
Back to Figure
String concatenation. book Title, equals, phrase 2, plus, phrase 1,
semicolon.
Back to Figure
Result of concatenating strings. Open quotes, Problem,
SolvingProgramming and, close quotes.
Back to Figure
Some constant declarations. Program code. Line 1: const, string,
WORD 1, equals, open quotes, Programming, close quotes,
semicolon. Line 2: const, string, WORD 3, equals, open quotes,
Solving, close quotes, semicolon. Line 3: const, string, WORD 5,
equals, open quotes, C plus plus, close quotes, semicolon.
Back to Figure
A line of code that assigns the title of the book to a variable.
Program code. Line 1: book Title, equals, open single quotes, P,
close single quotes, plus, WORD 1, plus, open quotes, and,
Problem, close quotes, plus, WORD 3 plus, open quotes, with, close
quotes, plus, WORD 5, semicolon.
Back to Figure
The contents of the variable boot Title. Open quotes, Programming,
and, Problem, Solving, with, C plus plus, close quotes.
Back to Figure

The title of a book being directly assigned to a variable. Program
code. Line 1: book Title, equals, open quotes, Programming, and,
Problem, Solving, with, C plus plus, close quotes, semicolon.
Back to Figure
String concatenation. Program code. Line 1: Book Title, equals,
book Title, plus, open quotes, with, C plus plus, close quotes,
semicolon.
Back to Figure
Listing of a C plus plus program that shows declarations and
assignment statements. Program code. Line 1: Forward slash,
forward slash, a line of asterisks. Line 2: Forward slash, forward
slash, This, program, shows, the, placement. Line 3: Forward slash,
forward slash, of, declarations, and, assignment operations. Line 4:
Forward slash, forward slash, a line of asterisks. Line 5: Hash,
include, left angle bracket, string, right angle bracket. Line 6: using,
name s t d, semicolon. Line 7: i n t, main, left parenthesis, right
parenthesis. Line 8: Left brace. Line 9, indented once: const, string,
first Part, equals, open quotes, Programming and Problem, close
quotes, Line 10, indented once: const, string, second Part, equals,
open quotes, Solving with C plus plus, close quotes. Line 11,
indented once: string, book Title, semicolon. Line 12, indented once:
string, new Edition, semicolon. Line 13, indented once: book Title,
equals, first Part, plus, second Part, semicolon. Line 14, indented
once: new Edition, equals, book Title, plus, open quotes, comma,
7th Edition, close quotes, semicolon. Line 15: Right brace.
Back to Figure
Code for writing out information. Program code: Line 1: c out, double
left angle bracket, open quotes, Hello, close quotes, semicolon.
Back to Figure
Code that prints out information on the console. Program code. Line
1: c out, double left angle bracket, open quotes, The title is, close
quotes, semicolon. Line 2: c out, double left angle bracket, book

Title, plus, open quotes, comma, 7th Edition, close quotes,
semicolon.
Back to Figure
A combined output statement. Program code. Line 1: c out, double
left angle bracket, open quotes, The title is, close quotes, double left
angle bracket, book Title, plus, open quotes, comma, 7th Edition,
semicolon.
Back to Figure
The output of a statement. The title is American History, comma, 7th
Edition.
Back to Figure
A line that needs to displayed in the console. A l open quotes, Butch,
close quotes, Jones.
Back to Figure
The output statement for the line that needs to be displayed in the
console. Program code. Line 1: c out, double left angle bracket,
open quotes, A 1, backslash, open quotes, Butch, backslash, open
quotes, Jones, close quotes, semicolon, forward slash, forward
slash, Example of using, backslash, open quotes, to insert a, open
quotes, in, a. Line 2. Tab spaces, string, literal.
Back to Figure
Code that outputs content along the same line on the display
screen. Program code. Line 1: c out, double left angle bracket, open
quotes, Hi, close quotes, semicolon. Line 2: c out, double left angle
bracket, open quotes, there, close quotes, semicolon.
Back to Figure
Code that outputs content on separate lines. Program code. Line 1:
c out, double left angle bracket, open quotes, Hi, close quotes,

double left angle bracket, end l, semicolon. Line 2: c out, double left
angle bracket, open quotes, there, close quotes, double left angle
bracket, end l, semicolon.
Back to Figure
The output of the previous code that prints two words on separate
lines. Line 1: Hi. Line 2: there.
Back to Figure
A program that contains declarations, assignment statements, and
output statements. Program code. Line 1. Forward slash, forward
slash, a line of asterisks. Line 2. Forward slash, forward slash,
Example, program, containing, declarations, comma. Line 3.
Forward slash, forward slash, string, assignment, statements, and
output. Line 4. Forward slash, forward slash, statements. Line 5.
Forward slash, forward slash, a line of asterisks. Line 6. Hash,
include, left angle bracket, i o stream, right angle bracket, forward
slash, forward slash, For, c out, comma, end l. Line 7. Hash, include,
left angle bracket, string, right angle bracket. Line 8. using, name s t
d, semicolon. Line 9. i n t, main, left parenthesis, right parenthesis.
Line 10. Left brace. Line 11, indented once. const, string, BORDER,
equals, open quotes, a line of asterisks, close quotes, semicolon.
Line 12, indented once. const, string, NAME, equals, open quotes,
Susy, Sunshine, close quotes, semicolon. Line 13, indented once.
const, string, MESSAGE, equals, open quotes, Good, Morning,
semicolon. Line 14, indented once. string, out Message, semicolon.
Line 15, indented once. c out, double left angle bracket, BORDER,
double left angle bracket, end l, semicolon. Line 16, indented once.
out Message, equals, MESSAGE, plus, open quotes, to,, close
quotes, plus,, open quotes, Miss, close quotes, plus, NAME,
semicolon. Line 17. c out, double left angle bracket, out Message,
double left angle bracket, open single quotes, exclamation mark,
close single quotes, double left angle bracket, end l, semicolon. Line
18. c out, double left angle bracket BORDER, double left angle
bracket, end l, semicolon. Line 19. return, 0, semicolon. Line 20.
Right brace.

Back to Figure
Output of the previous program. Line 1. A line of asterisks. Line 2.
Good Morning to Miss Susy Sunshine! Line 3. A line of asterisks.
Back to Figure
A C plus plus comment line. Program code. Line 1. string, i d
Number, semicolon, tab forward slash, asterisk, Identification,
number. Line 2. tab spaces, of, the, aircraft, asterisk, forward slash.
Back to Figure
A C plus plus comment line. Program code. Line 1. string, i d
Number, semicolon, tab forward slash, forward slash, Identification,
number, of, the, aircraft.
Back to Figure
Example of comment lines that appear at the beginning of a
program. Program code. Line 1. Forward slash, forward slash, This,
program, computes, the, weight, and, balance, of, a, Cessna. Line
2. Forward slash, forward slash, Citation, airplane, comma, given,
the, amount, of, fuel, comma, number, of. Line 3. Forward slash,
forward slash, passengers, comma, and, weight, of, luggage, in,
fore, and, aft, storage. Line 4. Forward slash, forward slash, It,
assumes, that, there, are, two, pilots, and, a, standard,
complement. Line 5. Forward slash, forward slash, of, equipment,
comma, and, that, passengers, weigh, 170, pounds, each.
Back to Figure
The syntax template to check if the string"C plus plus 7th edition" is
a valid"Sentence." Letter. Digit. Plus. Ellipsis. Period. Exclamation
mark. Question mark.
Back to Figure
The reader needs to identify the valid C plus plus identifiers among
the following. Hello Bob 7th hyphen edition C plus plus maximum all

underscore 4 underscore one.
Back to Figure
The reader needs to identify the value stored in the following string
variable. Program code. name, equals, open quotes, Alexander,
close quotes, plus, open quotes, Q, period, close quotes, plus, open
quotes, Smith, close quotes, semicolon.
Back to Figure
The reader has to identify the output of the following code. Program
code. Line 1. c out, double left angle bracket, name, double left
angle bracket, open quotes, J r, period, close quotes, double left
angle bracket, end l, semicolon.
Back to Figure
The syntax template for a program is the following. Declaration
followed by multiple function definitions.
Back to Figure
The syntax template for a function definition is the following. A
function definition has a function heading and a body. The
statements inside the function are enclosed by left and right braces.
Back to Figure
A program that has only one function, the main function. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, Print Name, program. Line 3.
Forward slash, forward slash, This, program, outputs, a, name, in,
two, different, formats. Line 4. Forward slash, forward slash, a line
of asterisks. Line 5. Hash, include, left angle bracket, i o stream,
right angle bracket, tab spaces, forward slash, forward slash, For, c
out, comma, end l. Line 6. Hash, include, left angle bracket, string,
right angle bracket. Line 7. using, name s t d, semicolon. Line 8.
const, string, FIRST, equals, open quotes, Herman, close quotes,
semicolon, tab forward slash, forward slash, Person’s, first, name.

Line 9. const, string, LAST, equals, open quotes, Smith, close
quotes, semicolon, tab forward slash, forward slash, Person’s, last,
name. line 10. const, char, MIDDLE, equals, open single quotes, G,
close single quotes, tab forward slash, forward slash, Person’s,
middle, initial. Line 11. i n t, main, left parenthesis, right parenthesis.
Line 12. Left brace. Line 13, indented once. string, first Last,
semicolon, tab spaces, forward slash, forward slash, Name, in, first
hyphen last, format. Line 14, indented once. string, last First,
semicolon, tab spaces, forward slash, forward slash, Name, in, last
hyphen first, format. Line 15, indented once. first Last, equals,
FIRST, plus, open quotes, close quotes, plus, LAST, semicolon. Line
16, indented once. c out, double left angle bracket, open quotes,
Name, in, first hyphen last, format, is, close quotes, double left
angle bracket, first Last, double left angle bracket, end l, semicolon.
Line 17, indented once. last First, equals, LAST, plus, open quotes,
comma, close quotes, plus, FIRST, plus, open quotes, comma,
close quotes, semicolon. Line 18, indented once. c out, double left
angle bracket, open quotes, Name, in, last hyphen first hyphen
initial, format, is, close quotes, semicolon. Line 19, indented once. c
out, double left angle bracket, last First, double left angle bracket,
MIDDLE, double left angle bracket, open single quotes, close single
quotes, double left angle bracket, end l, semicolon. Line 20,
indented once. return, 0, semicolon. Line 21. Right brace.
Back to Figure
Code with a comment line. Program code. Line 1. Hash, include, left
angle bracket, i o stream, right angle bracket, tab forward slash,
forward slash, For, c out, comma, end l. Line 2. Hash, include, left
angle bracket, string, right angle bracket. Line 3. using, name s t d,
semicolon.
Back to Figure
Code that returns the value 0. Program code. Line 1. return, 0,
semicolon.
Back to Figure

The output of the program. Line 1. Name in first-last format is
Herman Smith. Line 2. Name in last-first-initial format is Smith,
Herman, G.
Back to Figure
The syntax template for a block of code. A block of code begins with
a left brace. It is followed by one or more statements and ends with
a right brace.
Back to Figure
A function is defined as having a heading which is followed by a
block of code.
Back to Figure
The syntax template for a statement. A statement may be a null
statement, a declaration, an assignment statement, an output
statement, or a block.
Back to Figure
A block of code with declarations and executable statements.
Program code. Line 1. Left brace. Line 2, indented once. char, c h,
semicolon. Line 3. c h, equals, open single quotes, A, close single
quotes, semicolon. Line 4, indented once. c out, double left angle
bracket, c h, semicolon. Line 5, indented once. string, s t r,
semicolon. Line 6, indented once. s t r, equals, open quotes, Hello,
close quotes, semicolon. Line 7, indented once. c out, double left
angle bracket, str, semicolon. Line 8. Right brace.
Back to Figure
A block of code with declarations added before the start of
executable statements. Program code. Line 1. Left brace. Line 2,
indented once. char, c h, semicolon. Line 3, indented once. string, s
t r, semicolon. Line 4. c h, equals, open single quotes, A, close
single quotes, semicolon. Line 5, indented once. c out, double left
angle bracket, c h, semicolon. Line 6, indented once. s t r, equals,

open quotes, Hello, close quotes, semicolon. Line 7, indented once.
c out, double left angle bracket, str, semicolon. Line 8. Right brace.
Back to Figure
A program that outputs a Happy Birthday message. Program code.
Line 1. Forward slash, forward slash, a line of asterisks. Line 2.
Forward slash, forward slash, This, program, outputs, Happy,
Birthday. Line 3. Forward slash, forward slash, a line of asterisks.
Line 4. i n t, main, left parenthesis, right parenthesis. Line 5. Left
brace. Line 6, indented once. c out, double left angle bracket, open
quotes, Happy, Birthday, close quotes, double left angle bracket, end
l, semicolon. Line 7, indented once. return, 0, semicolon. Line 8.
Right brace.
Back to Figure
The line of code that needs to added to the top of the previous
program to make it work. Program code. Line 1. Hash, include, left
angle bracket, I o stream, right angle bracket, tab spaces, forward
slash, forward slash, For, c out, comma, end l.
Back to Figure
A source program along with a preprocessor becomes an expanded
source program which is compiled by a C plus plus compiler.
Back to Figure
Code that contains header declarations. Program code. Line 1.
Hash, include, left angle bracket, i o stream, right angle bracket, tab
spaces, forward slash, forward slash, For, c out, comma, end l. Line
2. Hash, include, left angle bracket, string, right angle bracket.
Back to Figure
The name space block called s t d. The name space block begins
with a left brace. It is followed by several lines of code containing
declarations of variables, data types, and so for the. The name
space block ends with a right brace.

Back to Figure
Program code. Line 1. using, name s t d, semicolon.
Back to Figure
The C plus plus program that prints a happy birthday message.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash forward slash, This, program,
outputs, Happy, Birthday. Line 3. Forward slash, forward slash, a line
of asterisks. Line 4. Hash, include, left angle bracket, i o stream,
right angle bracket, forward slash, forward slash, For, c out, comma,
end l. Line 5. using, name s t d, semicolon. Line 6. i n t, main, left
parenthesis, right parenthesis. Line 7. Left brace. Line 8, indented
once. c out, double left angle bracket, open quotes, Happy, Birthday,
close quotes, double left angle bracket, end l, semicolon. Line 9.
return, 0, semicolon. Line 10. Right brace.
Back to Figure
The existing code in the Print Name application. Program code. Line
1. Forward slash, forward slash, a line of asterisks. line 2. Forward
slash, forward slash, Print Name, program. Line 3. Forward slash,
forward slash, This, program, outputs, a, name, in, two, different,
formats. Line 4. Forward slash, forward slash, a line of asterisks.
Line 5. Hash, include, left angle bracket, i o stream, right angle
bracket, forward slash, forward slash, For, c out, comma, end l. Line
6. Hash, include, left angle bracket, string, right angle bracket. Line
7. using, name s t d, semicolon. Line 8. const, string, FIRST, equals,
, open quotes, Herman, close quotes, semicolon, forward slash,
forward slash, Person's, first, name. Line 9. const, string, LAST,
equals, open quotes, Smith, close quotes, semicolon, forward slash,
forward slash, Person's, last, name. Line 10. const, char, MIDDLE,
equals, open single quotes, G, close single quotes, forward slash,
forward slash, Person's, middle, initial. Line 11. i n t, main, left
parenthesis, right parenthesis. Line 12. Left brace. Line 13, indented
once. string, first Last, semicolon, forward slash, forward slash,
Name, in, first hyphen last, format. Line 14, indented once. string,
last First, semicolon, forward slash, forward slash, Name, in, last

hyphen first, format. Line 15, indented once. first Last, equals,
FIRST, plus, open quotes, close quotes, plus, LAST, semicolon. Line
16, indented once. c out, double left angle bracket, open quotes,
Name, in, first hyphen last, format, is, close quotes, double left
angle bracket, first Last, double left angle bracket, end l, semicolon.
Line 17, indented once. last First, equals, LAST, plus, open quotes,
comma, close quotes, plus, FIRST, plus, open quotes, comma,
close quotes, semicolon. Line 18, indented once. c out, double left
angle bracket, open quotes, Name, in, last hyphen first hyphen
initial, format, is, close quotes, semicolon. Line 19, indented once. c
out, double left angle bracket, last First, double left angle bracket,
MIDDLE, double left angle bracket, open single quotes, period, close
single quotes, double left angle bracket, end l, semicolon. Line 20,
indented once. return, 0, semicolon. Line 21. Right brace.
Back to Figure
The comment lines in the Print Name application. Program code.
Line 1. Forward slash, forward slash, a line of asterisk. Line 2.
Forward slash, forward slash, Print Name, program. Line 3. Forward
slash, forward slash, This, program, outputs, a, name, in, two,
different, formats. Line 4. Forward slash, forward slash, a line of
asterisks.
Back to Figure
The next chunk of the Print Name application with the include and
using statements. Program code. Line 1. Hash, include, left angle
bracket, i o stream, right angle bracket, tab spaces, forward slash,
forward slash, For, c out, comma, end l. Line 2. Hash, include, left
angle bracket, string, right angle bracket. Line 3. using, name s t d,
semicolon.
Back to Figure
The declaration of the three constants in the Print Name application.
Program code. Line 1. const, string, FIRST, equals, , open quotes,
Herman, close quotes, semicolon, forward slash, forward slash,
Person's, first, name. Line 2. const, string, LAST, equals, open

quotes, Smith, close quotes, semicolon, forward slash, forward
slash, Person's, last, name. Line 3. const, char, MIDDLE, equals,
open single quotes, G, close single quotes, forward slash, forward
slash, Person's, middle, initial.
Back to Figure
The declarations within the main block of the Print Name application.
Program code. Line 1. string, first Last, semicolon, forward slash,
forward slash, Name, in, first hyphen last, format. Line 2. string, last
First, semicolon, forward slash, forward slash, Name, in, last hyphen
first, format.
Back to Figure
The section of code in the Print Name application that generates and
outputs each of the two name formats. Program code. Line 1. first
Last, equals, FIRST, plus, open quotes, close quotes, plus, LAST,
semicolon. Line 2. c out, double left angle bracket, open quotes,
Name, in, first hyphen last, format, is, close quotes, double left
angle bracket, first Last, double left angle bracket, end l, semicolon.
Line 3. last First, equals, LAST, plus, open quotes, comma, close
quotes, plus, FIRST, plus, open quotes, comma, close quotes,
semicolon. Line 4. c out, double left angle bracket, open quotes,
Name, in, last hyphen first hyphen initial, format, is, close quotes,
semicolon. Line 5. c out, double left angle bracket, last First, double
left angle bracket, MIDDLE, double left angle bracket, open single
quotes, period, close single quotes, double left angle bracket, end l,
semicolon.
Back to Figure
A line of code with a string constant that contains the title Mister.
Program code. Line 1. const, string, TITLE, equals, open quotes, M
r period, close quotes, semicolon.
Back to Figure
An assignment statement that adds the title to the name. Program
code. Line 1. first Last, equals, TITLE, plus, open quotes, close

quotes, plus, FIRST, plus, open quotes, close quotes, plus, LAST,
semicolon.
Back to Figure
The output statement that prints the name. Program code. Line 1. c
out, double left angle bracket, open quotes, Name, in, first hyphen
last, format, is, close quotes, double left angle bracket, TITLE,
double left angle bracket, open quotes, close quotes. Line 2. Tab
double left angle bracket, first Last, double left angle bracket, end l,
semicolon.
Back to Figure
The revised Print Name application. Lines 11, 16, and 18 contain the
inserted or modified code. Program code. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. line 2. Forward
slash, forward slash, Print Name, program. Line 3. Forward slash,
forward slash, This, program, outputs, a, name, in, two, different,
formats. Line 4. Forward slash, forward slash, a line of asterisks.
Line 5. Hash, include, left angle bracket, i o stream, right angle
bracket, forward slash, forward slash, For, c out, comma, end l. Line
6. Hash, include, left angle bracket, string, right angle bracket. Line
7. using, name s t d, semicolon. Line 8. const, string, FIRST, equals,
, open quotes, Herman, close quotes, semicolon, forward slash,
forward slash, Person's, first, name. Line 9. const, string, LAST,
equals, open quotes, Smith, close quotes, semicolon, forward slash,
forward slash, Person's, last, name. Line 10. const, char, MIDDLE,
equals, open single quotes, G, close single quotes, forward slash,
forward slash, Person's, middle, initial. Line 11. const, string, TITLE,
equals, open quotes, M r period, close quotes, semicolon. Line 12. i
n t, main, left parenthesis, right parenthesis. Line 13. Left brace.
Line 14, indented once. string, first Last, semicolon, forward slash,
forward slash, Name, in, first hyphen last, format. Line 15, indented
once. string, last First, semicolon, forward slash, forward slash,
Name, in, last hyphen first, format. Line 16, indented once. first
Last, equals, TITLE, plus, open quotes, close quotes, plus, FIRST,
plus, open quotes, close quotes, plus, LAST, semicolon. Line 17,
indented once. c out, double left angle bracket, open quotes, Name,

in, first hyphen last, format, is, close quotes, double left angle
bracket, first Last, double left angle bracket, end l, semicolon. Line
18, indented once. last First, equals, LAST, plus, open quotes,
comma, close quotes, plus, TITLE, plus, open quotes, close quotes,
plus, FIRST, plus, open quotes, comma, close quotes, semicolon.
Line 19, indented once. c out, double left angle bracket, open
quotes, Name, in, last hyphen first hyphen initial, format, is, close
quotes, semicolon. Line 20, indented once. c out, double left angle
bracket, last First, double left angle bracket, MIDDLE, double left
angle bracket, open single quotes, period, close single quotes,
double left angle bracket, end l, semicolon. Line 21, indented once.
return, 0, semicolon. Line 22. Right brace.
Back to Figure
The output of the revised Print Name application. Line 1. Name in
first-last format is Mr. Herman Smith. Line 2. Name in last-first-initial
format is Smith, Mr. Herman, G.
Back to Figure
The reader has to fill the blanks with the statements that appear in
the beginning of a program that uses strings and streams output.
Program code. Line 1. Hash, include, left angle bracket, blank, right
angle bracket. Line 2. Hash, include, left angle bracket, blank, right
angle bracket. Line 3. using, name blank, semicolon.
Back to Figure
The reader has to say what the following statements output.
Program code. Line 1. c out, double left angle bracket, open quotes,
Hi, there, comma, close quotes, double left angle bracket, end l,
semicolon. Line 2. c out, double left angle bracket, end l, semicolon.
Line 3. c out, double left angle bracket, open quotes, Lois, Lane,
period, close quotes, double left angle bracket, end l, semicolon.
Back to Figure
The output of the previous statements. Line 1. Hi there, comma.
Line 2. Lois Lane, period.

Back to Figure
The preceding three output statements combined into two
statements. Program code. Line 1. c out, double left angle bracket,
open quotes, Hi, there, comma, close quotes, double left angle
bracket, end l, double left angle bracket, end l, semicolon. Line 2. c
out, double left angle bracket, open quotes, Lois, Lane, period, close
quotes, double left angle bracket, end l, semicolon.
Back to Figure
The preceding two output statements combined into one statement.
Program code. Line 1. c out, double left angle bracket, open quotes,
Hi, there, comma, close quotes, double left angle bracket, end l,
double left angle bracket, end l, double left angle bracket, open
quotes, Lois, Lane, period, close quotes, double left angle bracket,
end l, semicolon.
Back to Figure
Two output statements combined into one statement in an alternate
way. Program code. Line 1. c out, double left angle bracket, open
quotes, Hi, there, comma, close quotes, double left angle bracket,
end l, double left angle bracket, end l. Line 2. Tab double left angle
bracket, open quotes, Lois, Lane, period, close quotes, double left
angle bracket, end l, semicolon.
Back to Figure
The statements used to print the three line of asterisks. Program
code. Line 1. c out, double left angle bracket, open quotes, a few
asterisks with spaces in-between, close quotes, double left angle
bracket, end l, double left angle bracket, end l, semicolon. Line 2. c
out, double left angle bracket, open quotes, a few asterisks with
spaces in-between, close quotes, double left angle bracket, end l,
double left angle bracket, end l, semicolon. Line 3. c out, double left
angle bracket, open quotes, a few asterisks with spaces in-between,
close quotes, double left angle bracket, end l.
Back to Figure

g
A statement that does not have blanks enclosed in quotes. Program
code. Line 1. c out, double left angle bracket, open single quotes,
asterisk, close single quotes, double left angle bracket, tab open
single quotes, asterisk, close single quotes, semicolon.
Back to Figure
The output of the code that does not enclose spaces within quotes.
Line 1. asterisk, asterisk.
Back to Figure
The usage of the end l operator to make the output stream go to the
next line. Program code. Line 1. c out, double left angle bracket,
open quotes, The, answer, is, colon, backslash n 42, backslash n,
close quotes, semicolon. Line 2. c out, double left angle bracket,
open quotes, The, answer, is, colon, close quotes, double left angle
bracket, end l, double left angle bracket, open quotes, 42, close
quotes, double left angle bracket, end l, semicolon.
Back to Figure
The output of the two statements is the following. Line 1. The
answer is, colon. Line 2. 42.
Back to Figure
Printing double quotes and single quotes. Program code. Line 1. c
out, double left angle bracket, open single quotes, open quotes,
close single quotes, double left angle bracket, open quotes, open
single quotes, close quotes, semicolon, tab forward slash, forward
slash, Outputs, open quotes, open single quotes.
Back to Figure
Printing double quotes and single quotes. Program code. Line 1. c
out, double left angle bracket, open quotes, backslash, open quotes,
close quotes, double left angle bracket, open single quotes,
backslash, open single quotes, close single quotes, semicolon, tab

forward slash, forward slash, Also outputs, open quotes, open single
quotes.
Back to Figure
Printing a backslash. Program code. Line 1. c out, backslash, double
left angle bracket, open quotes, backslash, backslash, close quotes,
semicolon, tab forward slash, forward slash, Outputs, backslash.
Back to Figure
A flowchart depicting the debugging process. Step 1. Enter program.
Step 2. Compile program. Step 3. Compile-time errors? If Yes, then
figure out errors, get back into editor, and fix errors in program. Go
to Step 2. If No, then Step 4. Step 4. Run program. Step 5. Logic
errors? If Yes, then go back to algorithm and fix design. Get back
into editor and fix errors in program. Go to Step 2. If No, then Step
6. Success!
Back to Figure
A chessboard made out of printing asterisks. Each black space in
the chessboard is made out of printing four rows of 8 asterisks each.
The white spaces are made of blank space.
Back to Figure
Constants concatenated together to form white and black patterns.
Line 1. WHITE plus BLACK plus WHITE plus BLACK plus WHITE
plus BLACK plus WHITE plus BLACK.
Back to Figure
Constants concatenated together to form black and white patterns.
Line 1. BLACK plus WHITE plus BLACK plus WHITE plus BLACK
plus WHITE plus BLACK plus WHITE.
Back to Figure

A program that prints a chessboard pattern using strings of black
and white characters. Program code. Line 1. Forward slash, forward
slash, a line of asterisks. Line 2. Forward slash, forward slash,
Chessboard program. Line 3. Forward slash, forward slash, This
program outputs a chessboard pattern that is built up from. Line 4.
Forward slash, forward slash, basic strings of white and black
characters. Line 5. Forward slash, forward slash, a line of asterisks.
Line 6. Hash, include, left angle bracket, i o stream, right angle
bracket, tab space, forward slash, forward slash, For c out, comma,
end l. Line 7. Hash, include, left angle bracket, string, right angle
bracket. Line 8. using, name space, s t d, semicolon. Line 9. const,
string, BLACK, equals, open quotes, a few asterisks, close quotes,
semicolon, tab space, forward slash, forward slash, Define a line of
a black square. Line 10. const, string, WHITE, equals, open quotes,
space, close quotes, semicolon, tab space, forward slash, forward
slash, Define a line of a white square. Line 11. i n t, main, left
parenthesis, right parenthesis. Line 12. Left brace. Line 13, indented
once. string, white Row, semicolon. tab space, forward slash,
forward slash, A row beginning with a white square. Line 14,
indented once. string, black Row, semicolon, tab space, forward
slash, forward slash, A row beginning with a black square. Line 15,
indented once. Forward slash, forward slash, Create a white-black
row by concatenating the basic strings. Line 16, indented once.
white Row, equals, WHITE, plus, BLACK, plus, WHITE, plus,
BLACK, plus. Line 17, indented a few times. WHITE, plus, BLACK,
plus, WHITE, plus, BLACK, semicolon. Line 18, indented once.
Forward slash, forward slash, Create a black-white row by
concatenating the basic strings. Line 19, indented once. black Row,
equals, BLACK, plus, WHITE, plus, BLACK, plus, WHITE, plus. Line
20, indented a few times. BLACK, plus, WHITE, plus, BLACK, plus,
WHITE, semicolon. Line 21, indented once. Forward slash, forward
slash, Output five white-black rows. Line 22, indented once. c out,
double left angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 23, indented once. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 24,
indented once. c out, double left angle bracket, white Row, double
left angle bracket, end l, semicolon. Line 25, indented once. c out,
double left angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 26, indented once. c out, double left angle bracket,

white Row, double left angle bracket, end l, semicolon. Line 27,
indented once. Forward slash, forward slash, Output five black-white
rows. Line 28, indented once. c out, double left angle bracket, black
Row, double left angle bracket, end l, semicolon. Line 29, indented
once. c out, double left angle bracket, black Row, double left angle
bracket, end l, semicolon. Line 30, indented once. c out, double left
angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 31, indented once. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 32,
indented once. c out, double left angle bracket, black Row, double
left angle bracket, end l, semicolon. Line 33, indented once. Forward
slash, forward slash, Output five white-black rows. Line 34, indented
once. c out, double left angle bracket, white Row, double left angle
bracket, end l, semicolon. Line 35, indented once. c out, double left
angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 36, indented once. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 37,
indented once. c out, double left angle bracket, white Row, double
left angle bracket, end l, semicolon. Line 38, indented once. c out,
double left angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 39, indented once. Forward slash, forward slash,
Output five black-white rows. Line 40, indented once. c out, double
left angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 41, indented once. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 42,
indented once. c out, double left angle bracket, black Row, double
left angle bracket, end l, semicolon. Line 43, indented once. c out,
double left angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 44, indented once. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 45,
indented once. Forward slash, forward slash, Output five white-black
rows. Line 46, indented once. c out, double left angle bracket, white
Row, double left angle bracket, end l, semicolon. Line 47, indented
once. c out, double left angle bracket, white Row, double left angle
bracket, end l, semicolon. Line 48, indented once. c out, double left
angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 49, indented once. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 50,
indented once. c out, double left angle bracket, white Row, double

left angle bracket, end l, semicolon. Line 51, indented once. Forward
slash, forward slash, Output five black-white rows. Line 52, indented
once. c out, double left angle bracket, black Row, double left angle
bracket, end l, semicolon. Line 53, indented once. c out, double left
angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 54, indented once. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 55,
indented once. c out, double left angle bracket, black Row, double
left angle bracket, end l, semicolon. Line 56, indented once. c out,
double left angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 57, indented once. Forward slash, forward slash,
Output five white-black rows. Line 58, indented once. c out, double
left angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 59, indented once. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 60,
indented once. c out, double left angle bracket, white Row, double
left angle bracket, end l, semicolon. Line 61, indented once. c out,
double left angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 62, indented once. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 63,
indented once. Forward slash, forward slash, Output five black-white
rows. Line 64, indented once. c out, double left angle bracket, black
Row, double left angle bracket, end l, semicolon. Line 65, indented
once. c out, double left angle bracket, black Row, double left angle
bracket, end l, semicolon. Line 66, indented once. c out, double left
angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 67, indented once. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 68,
indented once. c out, double left angle bracket, black Row, double
left angle bracket, end l, semicolon. Line 69, indented once. return,
0, semicolon. Line 70. Right brace.
Back to Figure
The using directive that should be included to make use of c out and
string. Program code. Line 1. using, name s t d, semicolon.
Back to Figure

Answer to 2.2.11. Program code. Line 1. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 2. Hash, include, left
angle bracket, string, right angle bracket. Line 3. using, name s t d,
semicolon.
Back to Figure
The reader has to say what is wrong with the syntax template for a
C plus plus identifier. An identifier can contain a letter, or digit.
Back to Figure
The output of the following code needs to be stated. Program code.
Line 1. c out, double left angle bracket, open quotes, Four, score,
and, close quotes, double left angle bracket, end l, open quotes,
seven, years, ago, close quotes, Line 2. double left angle bracket,
open quotes, our, fathers, close quotes, double left angle bracket,
end l. Line 3. Double left angle bracket, open quotes, brought, forth,
on, this, close quotes, double left angle bracket, end l. Line 4.
Double left angle bracket, open quotes, continent, a, new, nation,
ellipsis, close quotes, double left angle bracket, end l, semicolon.
Back to Figure
Some string variable assignments. Program code. Line 1. string 1,
equals, open quotes, Bjarne, Stroustrup, close quotes, semicolon.
Line 2. string 2, equals, open quotes, C, close quotes, semicolon.
Line 3. string 3, equals, open quotes, programming, language, close
quotes, semicolon. Line 4. string 4, equals, open quotes, plus plus,
because, it, is, a, successor, to, the, close quotes, semicolon. Line
5. string 5, equals, open quotes, named, his, new, close quotes,
semicolon.
Back to Figure
The reader has to say the value of the following expression.
Program code. Line 1. string 1, plus, string 5, plus, string 3, plus,
open quotes, close quotes, plus, string 2, plus, string 4, plus. Line 2.
Tab string 2, plus, open quotes, close quotes, plus, string 3, plus,
open quotes, period, close quotes.

Back to Figure
The reader has to say why the following statement generates an
error.Program code. Line 1. c out, double left angle bracket, open
quotes, Hello, everybody, exclamation mark, close quotes, double
left angle bracket, end l, semicolon.
Back to Figure
The using statement. Program code. Line 1. using, name s t d,
semicolon.
Back to Figure
The lines in the code have to be reordered to make a working
program. Program code. Line 1. Left brace. Line 2. Right brace. Line
3. Hash, include, left angle bracket, i o stream, right angle bracket,
Line 4. const, string, TITLE, equals, open quotes, D r period, close
quotes, semicolon. Line 5. c out, double left angle bracket, open
quotes, Hello, close quotes, plus, TITLE, plus, open quotes,
Stroustrup, exclamation mark, close quotes, semicolon. Line 6. i n t,
main, left parenthesis, right parenthesis. Line 7. Hash include, left
angle bracket, string, right angle bracket. Line 8. return, 0,
semicolon. Line 8. using, name s t d, semicolon.
Back to Figure
A single output statement needs to be written which outputs the
listed lines. Line 1. He said,"How is that possible?" Line 2. She
replied,"Using manipulators." Line 3."Of course!" he exclaimed.
Back to Figure
Some declarations. Program code. Line 1. const, string, PART 1,
equals, open quotes, Pro, close quotes, semicolon. Line 2. const,
string, PART 2, equals, open quotes, gramming, and, close quotes,
semicolon. Line 3. const, string, PART 3, equals, open quotes, blem,
Solving, with, C plus plus, close quotes, semicolon.
Back to Figure

One output statement for each line of the following text needs to be
written. Line 1. Yet the web of thought has no such creases. Line 2.
And is more like a weaver's masterpieces; Line 3. One step a
thousand threads arise, Line 4. Hither and thither shoots each
shuttle, Line 5. The threads flow on unseen and subtle, Line 6. Each
blow effects a thousand ties.
Back to Figure
The missing lines in the program need to be filled up. The ouput line
is the following. Rev period H period G period Jones. The program is
the following. Program code. Line 1. Blank. Line 2. Blank. Line 3.
Blank. Line 4. const, string, TITLE, equals, open quotes, Rev,
period, close quotes, semicolon. Line 5. const, char, FIRST, equals,
open single quotes, H, close single quotes, semicolon. Line 6. const,
char, MID, open single quotes, G, close single quotes, semicolon.
Line 7. Blank. Line 8. Blank. Line 9. Left brace. Line 10. c out,
double left angle bracket, TITLE, double left angle bracket, FIRST,
double left angle bracket, DOT, double left angle bracket, MID,
double left angle bracket, DOT, double left angle bracket, open
quotes, Jones, close quotes, semicolon. Line 11. Blank.
Back to Figure
Program listed for question number 2.9 under programming warm-
up exercises. Program code. Line 1. Forward slash, forward slash, a
line of asterisks. Line 2. Forward slash, forward slash, Program
entry and compilation exercise. Line 3. Forward slash, forward slash,
Your name goes here. Line 4. Forward slash, forward slash, Today's
date goes here. Line 5. Forward slash, forward slash, a line of
asterisks. Line 6. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 7. Hash, include, left angle bracket, string, right
angle bracket. Line 8. using, name space, s t d, semicolon. Line 9.
const, string, STARS 35, equals, open quotes, a line of asterisks,
close quotes, semicolon. Line 10. const, char, STAR, equals, open
single quotes, asterisk, close single quotes, semicolon. Line 11.
const, string, BLANK S 33, equals, open quotes, space, close
quotes, semicolon. Line 12. const, string, M S G, equals, open
quotes, Welcome to C plus plus Programming, exclamation mark,

close quotes, semicolon. Line 13. const, string, BLANK S 3, equals,
close quotes, space, close quotes, semicolon. Line 14. i n t, main,
left parenthesis, right parenthesis. Line 15. Left brace. Line 16,
indented once. c out, double left angle bracket, STARS 35, double
left angle bracket, end l, double left angle bracket, STAR, double left
angle bracket, BLANKS 33, double left angle bracket, STAR, double
left angle bracket, end l, semicolon. Line 17, indented once. c out,
double left angle bracket, STAR, double left angle bracket, BLANKS
3, double left angle bracket, M S G, double left angle bracket,
BLANKS 3, double left angle bracket, STAR, double left angle
bracket, end l, semicolon. Line 18, indented once. c out, double left
angle bracket, STAR, double left angle bracket, BLANKS 33, double
left angle bracket, STAR, double left angle bracket, end l, double left
angle bracket, STARS 35, double left angle bracket, end l,
semicolon. Line 19. Right brace.
Back to Figure
Program listed for question number 2.10 under programming warm-
up exercises. Line 1. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 2. const, string, A, equals, open quotes, A,
close quotes, semicolon. Line 3. const, string, B, equals, open
quotes, B, close quotes, semicolon. Line 4. const, char, C, open
single quotes, C, close single quotes, semicolon. Line 5. i n t, main,
Line 6, indented once. string, forward. Line 7, indented once. string,
backward, semicolon. Line 8, indented once. forward, equals, A,
plus, close quotes, space, close quotes, plus, B, plus, open quotes,
space, close quotes, plus, C, semicolon. Line 9, indented once. c
out, open quotes, Forward order, colon, space, close quotes,
forward, double left angle bracket, end l, semicolon Line 10,
indented once. backward, equals, C, plus, open quotes, space,
close quotes, plus, B, plus, open quotes, space, close quotes,
semicolon. Line 11, indented once. c out, double left angle bracket,
open quotes, Backward order, colon, space, close quotes. Line 12,
indented once. c out, double left angle bracket, backward, double
left angle bracket, A, double left angle bracket, open quotes, end l,
semicolon. Line 13. Right brace.
Back to Figure

A program that outputs the following lines needs to be written. Line
1. Monday 9:00 Computer Science 101. Line 2. Monday 11:00
Physics 201. Line 3. Monday 2:00 Dance 153.
Back to Figure
A program that outputs all six permutations of the ordering of the
listed thre lines needs to be written. Line 1. I saw the big brown bear.
Line 2. The big brown bear saw me. Line 3. Oh! What a frightening
experience!
Back to Figure
A program that displays a checkerboard pattern of stars and blanks
needs to be written. The output displays 8 lines of 4 asterisks and
blanks. The lines alternatively begin with a blank and an asterisk.
Back to Figure
C plus plus data types include simple, address, and structured data
types. Simple data types are further divided into integral and floating
data types. Integral data types include char, short, i n t, long, and
bool data types. These data types can be unsigned. One simple
data type is e num. Floating data types include float, double, and
long double data types. Address data types include pointer and
reference data types. Structured data types include array, struct,
union, and class data types.
Back to Figure
Some integer values. 22, 16, 1, 498, 0, and 4600.
Back to Figure
Some negative integer values. Minus 378 and minus 912.
Back to Figure
A table listing the sample ranges for data types in C plus plus. The
table has 8 rows and 4 columns. It has the following column

headings. Type. Size in Bytes. Minimum Value. Maximum Value. The
row details are the following. Row 1: Type, char; Size in Bytes, 1;
Minimum Value, Minus 128; Maximum Value, 127. Row 2: Type,
unsigned char; Size in Bytes, 1; Minimum Value, 0; Maximum Value,
255. Row 3: Type, short; Size in Bytes, 2; Minimum Value, Minus
32,768; Maximum Value, 32,767. Row 4: Type, Unsigned short; Size
in Bytes, 2; Minimum Value, 0; Maximum Value, 65,535. Row 5:
Type, i n t; Size in Bytes, 4; Minimum Value, Minus 2,147,483,648;
Maximum Value, Plus 2,147,483,647. Row 6: Type, unsigned i n t;
Size in Bytes, 4; Minimum Value, 0; Maximum Value, Plus
4,294,967,295. Row 7: Type, long; Size in Bytes, 8; Minimum Value,
Minus 9,223,372,036,854,775,808; Maximum Value, Plus
9,223,372,036,854,775,807. Row 8: Type, unsigned long; Size in
Bytes, 8; Minimum Value, 0; Maximum Value, Plus
18,446,744,073,709,551,615. The minimum and maximum values
are for one particular machine. Your machine’s values may be
different.
Back to Table
An octal number. 031.
Back to Figure
Some floating-point values. 18.0, 127.54, 0.57, 4., 193145.8523,
and .8.
Back to Figure
Some floating-point values with exponents. 1.74536 E minus–12,
3.652442 E 4, and 7 E 20.
Back to Figure
A table listing the sample ranges for floating point data types in C
plus plus. The table has 3 rows and 4 columns. The column
headings are the following. Type. Size in Bytes. Minimum Positive
Value. Maximum Positive Value. The row details are the following.
Row 1: Type, float; Size in Bytes, 4; Minimum Positive Value, 3.4 E
hyphen 38; Maximum Positive Value, 3.4 E 38. Row 2: Type, double;

Size in Bytes, 8; Minimum Positive Value, 1.7 E hyphen 308;
Maximum Positive Value, 1.7 E 308. Row 3: Type, long double; Size
in Bytes, 10; Minimum Positive Value, 3.4 E hyphen 4932; Maximum
Positive Value, 1.1 E 4932. The minimum and maximum positive
values are for one particular machine. Your machine's values may
be different.
Back to Figure
Some named constant declarations. Program code. Line 1. const,
float, PI, equals, 3.14159, semicolon. Line 2. const, float, E, equals,
2.71828, semicolon. Line 3. const, i n t, MAX underscore SCORE,
equals, 100, semicolon. Line 4. const, i n t, MIN underscore
SCORE, equals, minus 100, semicolon. Line 5. const, char,
LETTER, equals, open single quotes, W, close single quotes,
semicolon. Line 6. const, string, NAME, equals, open quotes,
Elizabeth, semicolon.
Back to Figure
Some valid variable declarations. Program code. Line 1. i n t,
student Count, semicolon, forward slash, forward slash, Number, of,
students. Line 2. i n t, sum Of Scores, semicolon, forward slash,
forward slash, Sum, of, their, scores. Line 3. float, average,
semicolon, tab forward slash, forward slash, Average, of, the,
scores. Line 4. char, grade, semicolon, tab forward slash, forward
slash, Student's, letter, grade. Line 5. string, s t u Name, semicolon,
tab forward slash, forward slash, Student's, name.
Back to Figure
Some variable declarations. Program code. Line 1. i n t, num,
semicolon. Line 2. i n t, alpha, semicolon. Line 3. float, rate,
semicolon. Line 4. char, c h, semicolon.
Back to Figure
Some assignment statements. Program code. Line 1. alpha, equals,
2856, semicolon. Line 2. rate, equals, 0.36, semicolon. Line 3. c h,

equals, open single quotes, B, close single quotes, semicolon. Line
4. num, equals, alpha, semicolon.
Back to Figure
Some examples of valid expressions. alpha plus 2, rate minus 6.0, 4
minus alpha, rate, alpha asterisk num.
Back to Figure
How unary plus and unary minus are used. Minus 54, plus 259.65,
minus rate.
Back to Figure
The result of division and modulus shown with two examples. 6
divided by 2. The result of division is the quotient which is 3. 6
modulus 2. The result of modulus is the remainder of the division
which is 0. 7 divided by 2. The result of division is the quotient which
is 3. 7 modulus 2. The result of modulus is the remainder of the
division which is 1.
Back to Figure
Example of division with floating-point values which yields a floating-
point result. 7.0 divided by 2.0 yields the value 3.5.
Back to Figure
Some valid assignments. Program code. Line 1. alpha, equals, num,
plus, 6, semicolon. Line 2. alpha, equals, num, forward slash, 2,
semicolon. Line 3. num, equals, alpha, asterisk, 2, semicolon. Line
4. num, equals, 6, percentage, alpha, semicolon. Line 5. alpha,
equals, alpha, plus, 1, semicolon. Line 6. num, equals, num, plus,
alpha, semicolon.
Back to Figure
The same variable appearing in both sides of the expression.
Program code. Line 1. num, equals, num, plus, alpha, semicolon.

Back to Figure
The same variable appearing in both sides of the expression.
Program code. Line 1. num, equals, num, plus, alpha, semicolon.
Back to Figure
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, Freeze Boil
program. Line 3. Forward slash, forward slash, This program
computes the midpoint between. Line 4. Forward slash, forward
slash, the freezing and boiling points of water. Line 5. Forward slash,
forward slash, a line of asterisks. Line 6. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 7. using, name space,
s t d, semicolon. Line 8. const, float, FREEZE underscore P T,
equals, 32.0, semicolon, forward slash, forward slash, Freezing point
of water. Line 9. const, float, BOIL underscore P T, equals, 12.0,
semicolon, forward slash, forward slash, Boiling point of water. Line
10. i n t, main, left parenthesis, right parenthesis. Line 11. Left
brace. Line 12, indented once. float, a v g Temp, semicolon, tab
space, forward slash, forward slash, Holds the result of averaging.
Line 13, indented man times, forward slash, forward slash, FREEZE
underscore P T and BOIL underscore P T. Line 14, indented once. c
out, double left angle brackets, open quotes, Water freezes at,
space, close quotes, double left angle brackets, FREEZE
underscore P T, double left angle brackets, end l, semicolon. Line
15, indented once. c out, double left angle brackets, open quotes,
space, and boils at, space, close quotes, double left angle brackets,
BOIL underscore P T, double left angle brackets, open quotes,
space, degrees, dot, close quotes, double left angle brackets, end l,
semicolon. Line 16, indented once. a v g Temp, equals, FREEZE
underscore P T, plus, BOIL underscore P T, semicolon. Line 17,
indented once. a v g Temp, equals, a v g Temp, forward slash, 2.0,
semicolon. Line 18, indented once. c out, double left angle brackets,
open quotes, Halfway between is, space, close quotes, semicolon.
Line 19, indented once, c out, double left angle brackets, a v g
Temp, double left angle brackets, open quotes, space, degrees,
period, close quotes, double left angle brackets, end l, semicolon.
Line 20, indented once. return, 0, semicolon. Line 21. Right brace.

Back to Figure
An assignment statement. Program code. Line 1. num, equals, num,
plus, alpha, semicolon.
Back to Figure
The output of a program. Line 1. Water freezes at 32. Line 2. and
boils at 212 degrees. Line 3. Halfway between is 122 degrees.
Back to Figure
An increment statement. Program code. Line 1. num plus plus,
semicolon.
Back to Figure
An alternate way of writing an increment statement. Program code.
Line 1. num, equals, num, plus, 1, semicolon.
Back to Figure
The increment and decrement operators as prefix operators.
Program code. Line 1. Plus plus num, semicolon. Minus minus num,
semicolon.
Back to Figure
The increment and decrement operators as postfix operators.
Program code. Line 1. num, plus plus, semicolon. Num, minus,
minus, semicolon.
Back to Figure
Increment operator used in a larger expression. Program code. Line
1. alpha, equals, num plus plus, asterisk, 3, semicolon.
Back to Figure

The syntax templates for increment statements and decrement
statements. Increment statements. Variable plus plus, semicolon.
Plus plus Variable, semicolon. Decrement statements. Variable
minus minus, semicolon. Minus minus Variable, semicolon.
Back to Figure
An assignment statement. Program code. Line 1. a v g Temp,
equals, FREEZE underscore P T, plus, BOIL underscore P T,
forward slash, 2.0, semicolon.
Back to Figure
A parenthesized expression. Program code. Line 1. FREEZE
underscore P T, plus, left parenthesis, BOIL underscore P T, forward
slash, 2.0, right parenthesis.
Back to Figure
The order of evaluation in an expression changed using parenthesis.
Program code. Line 1. a v g Temp, equals, left parenthesis, FREEZE
underscore P T, plus, BOIL underscore P T, right parenthesis,
forward slash, 2.0, semicolon.
Back to Figure
With binary operators of same precedence, the order of precedence
is from left to right. i n t 1, minus, i n t 2, plus, i n t 3.
Back to Figure
Some declarations. Program code. Line 1. i n t, some I n t,
semicolon. Line 2. float, some Float, semicolon.
Back to Figure
An assignment statement. Program code. Line 1. some Float,
equals, 12, semicolon.
Back to Figure

Some assignment statements. Program code. Line 1. some Float,
equals, 12.0, semicolon. Line 2. some I n t, equals, 4, semicolon.
Back to Figure
Examples of type coercion. Program code. Line 1. some Float,
equals, 3, asterisk, some I n t, plus, 2, semicolon. Line 2. some I n t,
equals, 5.2, forward slash, some Float, minus, another Float,
semicolon.
Back to Figure
Examples of type casting. Program code. Line 1. some Float,
equals, float, left parenthesis, 3, asterisk, some I n t, plus 2, right
parenthesis, semicolon. Line 2. some I n t, equals, i n t, left
parenthesis, 5.2, forward slash, some Float, minus, another Float,
right parenthesis, semicolon.
Back to Figure
"Both listed statements produce the same result. Program code.
Line 1. some I n t, equals, some Float, plus, 8.2, semicolon. Line 2.
some I n t, equals, i n t, left parenthesis, some Float, plus, 8.2, right
parenthesis, semicolon."
Back to Figure
An example of rounding off. Program code. Line 1. some I n t,
equals, i n t, left parenthesis, some Float, plus 0.5, right parenthesis,
semicolon.
Back to Figure
Arithmetic expression with mixed data types. Program code. Line 1.
some I n t, asterisk, some Float. Line 2. 4.8, plus, some I n t, minus,
3.
Back to Figure

Examples of explicit type casts. Program code. Line 1. float, left
parenthesis, some I n t, right parenthesis, asterisk, some Float. Line
2. 4.8, plus, float, left parenthesis, some I n t, minus, 3, right
parenthesis.
Back to Figure
Some declarations. Program code. Line 1. i n t, sum, semicolon.
Line 2. i n t, count, semicolon. Line 3. float, average, semicolon.
Back to Figure
An example which gives the wrong result. Program code. Line 1.
average, equlas, sum, forward slash, count, semicolon, tab space,
forward slash, forward slash, Wrong.
Back to Figure
A program which computes the radius of a circle from its
circumference. Program code. Line 1. Forward slash, forward slash,
a line of asterisks. Line 2. Forward slash, forward slash, This
program computes the radius of a circle. Line 3. Forward slash,
forward slash, a line of asterisks. Line 4. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 5. using, name space,
s t d, semicolon. Line 6. i n t, main, left parenthesis, right
parenthesis. Line 7. Left brace. Line 8, indented once. const,
double, CIRCUMFERENCE, equals, 10.0, semicolon. Line 9,
indented once. double, radius, semicolon. Line 10, indented once.
radius, equals, CIRCUMFERENCE, forward slash, 2.0, asterisk,
3.14159265, semicolon. Line 11, indented once. c out, double left
angle bracket, open quotes, The radius is, space, close quotes,
double left angle bracket, radius, semicolon. Line 12, indented once.
return, 0, semicolon. Line 13. Right brace.
Back to Figure
An expression that computes the radius. Program code. Line 1.
radius, equals, left parenthesis, circumference, forward slash, 2.0,
right parenthesis, asterisk, 3.14159265, semicolon.

Back to Figure
An expression that computes the radius. Program code. Line 1.
radius, equals, circumference, forward slash, left parenthesis, 2.0,
asterisk, 3.14159265, right parenthesis, semicolon.
Back to Figure
The reader must modify the listed code to get the correct result.
Program code. Line 1. float, percentage, equals, left parenthesis,
score, forward slash, total, right parenthesis, asterisk, 100.0,
semicolon.
Back to Figure
The reader has to find the result of the following expression.
Program code. Line 1. 27, plus, 8, asterisk, 6, minus, 44,
percentage, 5.
Back to Figure
A program with three functions. Program code. Line 1. i n t, main,
left parenthesis, right parenthesis. Line 2. Left brace. Line 3,
indented once. c out, double left angle bracket, open quotes, The
square of 27 is, space, close quotes, double left angle bracket,
Square, left parenthesis, 27, right parenthesis, double left angle
bracket, end l, semicolon. Line 4, indented once. c out, double left
angle bracket, open quotes, and the cube of 27 is, space, close
quotes, double left angle bracket, Cube, left parentheis, 27, right
paernthesis, double left angle bracket, end l, semicolon. Line 5,
indented once. return, 0, semicolon. Line 6. Right brace. Line 7. i n
t, Square, left parenthesis, i n t, n, right parenthesis. Line 8. Left
brace. Line 9, indented once. return, n, asterisk, n, semicolon. Line
10. Right brace. Line 11. i n t, Cube, left parenthesis, i n t, n, right
parenthesis. Line 12. Left brace. Line 13, indented once. return, n,
asterisk, n, asterisk, n, semicolon. Line 14. Right brace.
Back to Figure

The statement in the main function of the previous program.
Program code. Line 1. c out, double left angle bracket, open quotes,
space, and the cube of 27 is, space, close quotes, double left angle
bracket, Cube, left parenthesis, 27, right parenthesis, double left
angle bracket, end l, semicolon.
Back to Figure
The function invocation in the previous statement. Program code.
Line 1. Cube, left parenthesis, 27, right parenthesis.
Back to Figure
Code that computes the cube of 4 and 16 respectively. Program
code. Line 1. c out, double left angle bracket, Cube, left parenthesis,
4, right parenthesis, semicolon. Line 2. c out, double left angle
bracket, Cube, left parenthesis, 16, right parenthesis, semicolon.
Back to Figure
A value computed by a function taking its place in an expression.
Program code. Some I n t, equals, Cube, left parenthesis, 2, right
parenthesis, asterisk, 10, semicolon.
Back to Figure
The argument in a function can be an expression. Program code.
Line 1. alpha, equals, Cube, left parenthesis, i n t 1, asterisk, i n t 1,
plus, i n t 2, asterisk, i n t 2, right parenthesis, semicolon.
Back to Figure
An argument to a function containing function calls. Program code.
Line 1. alpha, equals, Cube, left parenthesis, Square, left
parenthesis, i n t 1, right parenthesis, plus, Square, left parenthesis,
i n t 2, right parenthesis, right parenthesis, semicolon.
Back to Figure

A table listing some functions including details such as the header
file to which they belong to, the argument type, result type, and
value returned. The table has 7 rows and 5 columns. It has the
following column headings. Header File. Function. Argument Type.
Result Type. Result (Value Returned). The row details are the
following. Row 1: Header File, Left angle bracket, c s t d lib, right
angle bracket; Function, a b s, left parenthesis, i, right parenthesis;
Argument Type, i n t; Result Type, i n t; Result (Value Returned),
Absolute value of i. Row 2: Header File, Left angle bracket, c math,
right angle bracket; Function, cos, left parenthesis, i, right
parenthesis; Argument Type, float; Result Type, float; Result (Value
Returned), Cosine of x (x is in radians). Row 3: Header File, Left
angle bracket, c math, right angle bracket; Function, fab s, left
parenthesis, i, right parenthesis; Argument Type, float; Result Type,
float; Result (Value Returned), Absolute value of x. Row 4: Header
File, Left angle bracket, c s t d lib, right angle bracket; Function,
labs, left parenthesis, j, right parenthesis; Argument Type, long;
Result Type, long; Result (Value Returned), Absolute value of j. Row
5: Header File, Left angle bracket, c math, right angle bracket;
Function, pow, left parenthesis, x, comma, y, right angle bracket;
Argument Type, float; Result Type, float; Result (Value Returned), x
raised to the power y (if x equals 0.0, y must be positive; if x less
than or equals 0.0, y must be a whole number). Row 6: Header File,
Left angle bracket, c math, right angle bracket; Function, sin, left
parenthesis, x, right parenthesis; Argument Type, float; Result Type,
float; Result (Value Returned), Sine of x (x is in radians). Row 7:
Header File, Left angle bracket, c math, right angle bracket;
Function, s q r t, left parenthesis, x, right parenthesis; Argument
Type, float; Result Type, float; Result (Value Returned), Square root
of x (x greater than or equals 0.0).
Back to Table
A program that demonstrates function calls. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, This program demonstrates function calls. Line
3. Forward slash, forward slash, a line of asterisks. Line 4. Hash,
include, left parenthesis, i o stream, right angle bracket. Line 5.
Hash, include, left parenthesis, c math, right angle bracket, tab

space, forward slash, forward slash, For s q r t, left parenthesis,
right parenthesis, and f a b s, left parenthesis, right parenthesis.
Line 6. using, name space, s t d, semicolon. Line 7. i n t, main, left
parenthesis, right parenthesis. Line 8. Left brace. Line 9, indented
once. float, alpha, semicolon. Line 10, indented once. float, beta,
semicolon. Line 11. alpha, equals, s q r t, left parenthesis, 7.3, plus,
f a b s, left parenthesis, minus 100.0, right parenthesis, right
parenthesis, semicolon. Line 12, indented once. c out, double left
angle bracket, open quotes, alpha, space, close quotes, double left
angle bracket, alpha, double left angle bracket, end l, semicolon.
Line 13. beta, equals, pow, left parenthesis, alpha, comma, 2, right
parenthesis, semicolon. Line 14, indented once. c out, double left
angle bracket, open quotes, alpha squared, space, close quotes,
double left angle bracket, beta, double left angle bracket, end l,
semicolon. Line 15. Right brace.
Back to Figure
Output of the program that demonstrates function calls. Line 1.
alpha 10.3586. Line 2. alpha squared 107.3.
Back to Figure
The format for a void function. Program code. Line 1. void Calc Pay,
left parenthesis, ellipsis, right parenthesis. Line 2. Left brace. Line 3,
indented once. Colon. Line 4. Right brace.
Back to Figure
A value returning function called in an expression. Program code.
Line 1. if, left parenthesis, Is Leap Year, left parenthesis, year, right
parenthesis, right parenthesis.
Back to Figure
Calls to void functions. Program code. Line 1. Do This, left
parenthesis, x, comma, y, comma, z, right parenthesis, semicolon.
Line 2. Do That, left parenthesis, right parenthesis, semicolon.
Back to Figure

Consecutive integer and string values are output with no spaces
between them. Program code. Line 1. c out, double left angle
bracket, open quotes, Results, colon, space, double left angle
bracket, i, double left angle bracket, j, double left angle bracket, k,
semicolon.
Back to Figure
The output of the previous statement. Line 1. Results, colon, 1526.
Back to Figure
Single blank as a char constant between the numbers. Program
code. Line 1. c out, double left angle bracket, colon, Results, colon,
space, close quotes, double left angle bracket, i, open single quotes,
space, close single quotes, double left angle bracket, j, open single
quotes, space, close single quotes, double left angle bracket, k,
semicolon.
Back to Figure
The output of the previous statement. Line 1. Results, colon, 15 2 6.
Back to Figure
String literals containing blanks between the numbers. Program
code. Line 1. c out, double left angle bracket, open quotes, Results,
colon, space, close quotes, double left angle bracket, I, double left
angle bracket, open quotes, space, space, double left angle bracket,
j, double left angle bracket, open quotes, space, space, close
quotes, double left angle bracket, k, semicolon.
Back to Figure
The output of the previous statement. Line 1. Results, colon, 15 2 6.
Back to Figure
The use of manipulators. Program code. Line 1. c out, double left
angle bracket, some I n t, double left angle bracket, end l, double

left angle bracket, some Float, semicolon.
Back to Figure
The syntax template for the output statement. c out, double left
angle bracket, Expression Or Manipulator, double left angle bracket,
Expression Or Manipulator, ellipsis, semicolon.
Back to Figure
Usage of the set w manipulator. Program code. Line 1. Hash,
include, left angle bracket, i o stream, right angle bracket. Line 2.
Hash, include, left angle bracket, i o manip, right angle bracket. Line
3. using, name space, s t d, semicolon. Line 4. colon. Line 5. c out,
double left angle bracket, set w, left parenthesis, 5, right
parenthesis, double left angle bracket, some I n t, semicolon.
Back to Figure
Two i n t variables that have been assigned values. Program code.
Line 1. a n s, equals, 33, semicolon. Line 2. num, equals, 7132,
semicolon.
Back to Figure
Some output statements and the output produced by them detailed
in a table. The table has 5 rows and 2 columns. The details in the
table are as follows. Statement: 1. c out, double left angle bracket,
set w , left parenthesis, 4, right parenthesis, double left angle
bracket, a n s, double left angle bracket, set w, left parenthesis, 5,
right parenthesis, double left angle bracket, num, double left angle
bracket, set w, left parenthesis, 4, right parenthesis, double left
angle bracket, open quotes, Hi, close quotes, semicolon. Output:
Blank, blank, 33, blank, 7132, blank blank, Hi. This output is
composed of groups of 4, 5, and 4 characters. Statement: c cout,
double left angle bracket, set w, left parenthesis, 2, right
parenthesis, double left angle bracket, a n s, double left angle
bracket, set w, left parenthesis, 4, right parenthesis, double left
angle bracket, num, double left angle bracket, set w, left
parenthesis, 2, right parenthesis, double left angle bracket, open

quotes, Hi, close quotes, semicolon. Output: 337132Hi. This output
is composed of groups of 2, 4, and 2 characters. Statement: 3. c
out, double left angle bracket, set w, left parenthesis, 6, right
parenthesis, double left angle bracket, a n s, double left angle
bracket, set w, left parenthesis, 3, right parenthesis, double left
angle bracket, open quotes, Hi, close quotes, double left angle
bracket, set w, left parenthesis, 5, right parenthesis, double left
angle bracket, num, semicolon. Output: Blank, blank, blank, blank,
33, blank, Hi, blank, 7132. This output is composed of groups of 6,
3, and 5 characters. Statement: 4. c out, double left angle bracket,
set w, left parenthesis, 7, right parenthesis, double left angle
bracket, open quotes, Hi, close quotes, double left angle bracket,
set w, left parenthesis, 4, right parenthesis, double left angle
bracket, num, semicolon. Blank, blank, blank, blank, blank, blank, Hi,
7132. This output is composed of groups of 7 and 4 characters.
Statement: c out, double left angle bracket, set w, left parenthesis,
1, right parenthesis, double left angle bracket, a n s, double left
angle bracket, set w, left parenthesis, set w, left parenthesis, 5, right
parenthesis, double left angle bracket, num, semicolon. Output: 33,
blank, 7132. The last set of characters in this output is grouped into
5 characters. In the first set, the field automatically expands to fit the
two-digit value.
Back to Table
Using the set w manipulator. Program code. Line 1. c out, double left
angle bracket, open quotes, Hi, close quotes, double left angle
bracket, set w, left parenthesis, 5, right parenthesis, double left
angle bracket, a n s, double left angle bracket, num, semicolon.
Back to Figure
The output of the previous statement. Line 1. Hi 337132.
Back to Figure
A short program that illustrates manipulators. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, This program demonstrates the use of

manipulators. Line 3. Forward slash, forward slash, a line of
asterisks. Line 4. Hash, include, left angle bracket, i o stream, right
angle bracket, Line 5. Hash, include, left angle bracket, i o manip,
right angle bracket. Line 6. using, name space, s t d, semicolon.
Line 7. i n t, main, left parenthesis, right parenthesis. Line 8. Left
brace. Line 9, indented once. const, i n t, num 1, equals, 1066,
semicolon. Line 10, indented once. const, i n t, num 2, equals, 1492,
semicolon. Line 11, indented once. c out,, double left angle bracket,
set w, left parenthesis, 3, right parenthesis, double left angle
bracket, num 1, double left angle bracket, set w, left parenthesis, 5,
right parenthesis, double left parenthesis, num 2, double left angle
bracket, end l, semicolon. Line 12, indented once. c out, double left
angle bracket, num 1, double left angle bracket, num 2, semicolon.
Line 13, indented once. c out, double left angle bracket, set w, left
parenthesis, 4, right parenthesis, double left angle bracket, num 1,
double left angle bracket, set w, left parenthesis, 6, right
parenthesis, double left angle bracket, num 2, double left angle
bracket, num 1, double left angle bracket, end l, semicolon. Line 14,
indented once. return, 0, semicolon. Line 15. Right brace. The
output of the program is the following. Line 1. 1066 1492. Line 2.
106614921066 14921066.
Back to Figure
Setting field width for floating-point values. Program code. Line 1. c
out, double left angle bracket, set w, left parenthesis, 4, right
parenthesis, double left angle bracket, x, double left angle bracket,
end l. Line 2, indented once. double left angle bracket, set w, left
parenthesis, 6, right parenthesis, double left angle bracket, x, double
left angle bracket, end l. Line 3, indented once. double left angle
bracket, set w, left parenthesis, 3, right parenthesis, double left
angle bracket, x, double left angle bracket, end l, semicolon.
Back to Figure
The output of the previous code statements. Line 1. 4.85. Line 2,
indented once. 4.85. Line 3. 4.85.
Back to Figure

The output of large floating-point values. Line 1. 1.23457 e plus 0 8.
Back to Figure
The fixed manipulator. Program code. Line 1. c out, double left angle
bracket, fixed, double left angle bracket, 3.8, asterisk, x, semicolon.
Back to Figure
How a whole number is printed out. Line 1. 95
Back to Figure
The show point manipulator. Program code. Line 1. c out, double left
angle bracket, show point, double left angle bracket, float Var,
semicolon.
Back to Figure
Decimal places in the output. Program code. Line 1. c out, double
left angle bracket, open quotes, Tax is dollar, close quotes, double
left angle bracket, price, asterisk, 0.05, semicolon.
Back to Figure
The output of the previous code. Line 1. Tax is dollar 17.7435.
Back to Figure
The set precision manipulator. Program code. Line 1. c out, double
left angle bracket, fixed, double left angle bracket, set precision, left
parenthesis, 2, right parenthesis, double left angle bracket, open
quotes, Tax is dollar, close quotes, double left angle bracket, price,
asterisk, 0.05, semicolon.
Back to Figure
Some c out statements with manipulators and their respective
outputs. Statement: Program code. Line 1. c out, double left angle
bracket, fixed, semicolon. Line 2. c out, double left angle bracket,

set w, left parenthesis, 10, right parenthesis. Line 3, indented once.
double left angle bracket, set precision, left parenthesis, 2, right
parenthesis, double left angle bracket, x, semicolon. Output: Blank,
blank, blank, blank, 310.0. Statement: Program code. Line 1. c out,
double left angle bracket, set w, left parenthesis, 10, right
parenthesis. Line 2, indented once. set precision, left parenthesis, 5,
right parenthesis, double left angle bracket, x, semicolon. Output:
blank, 310.0000. Statement: Program code. c out, double left angle
bracket, set w, left parenthesis, 7, right parenthesis. Line 2, indented
once. set precision, left parenthesis, 5, right parenthesis, double left
angle bracket, x, semicolon. Output: 310.0000 (expands to nine
positions). Statement: Program code. Line 1. c out, double left angle
bracket, set w, left parenthesis, 6, right parenthesis. Line 2, indented
once. double left angle bracket, set precision, left parenthesis, 2,
right parenthesis, double left angle bracket, y, semicolon. Output:
Blank, blank, 4.83 (last displayed digit is rounded off). Statement:
Program code. c out, double left angle bracket, set w, left
parenthesis, 6, right parenthesis. Line 2, indented once. set
precision, left parenthesis, 1, right parenthesis, double left angle
bracket, y, semicolon. Output: blank, blank, blank, 4,8 (last displayed
digit is rounded off.
Back to Table
Some c out statements with manipulators and their respective
outputs. Statement: Program code. Line 1. c out, double left angle
bracket, set precision, left parenthesis, 5, right parenthesis, double
left angle bracket, 12345678.0, semicolon. Output: 1.2346 e plus 0
7. Statement: Program code. c out, double left angle bracket,
scientific, double left angle bracket, set precision, left parenthesis, 5,
right parenthesis, double left angle bracket, 12345678.0. Output:
1.23457 e plus 0 7.
Back to Table
A table listing completed details of manipulators. The table has 6
rows and 4 columns. The column headings are the following. Header
File. Manipulator. Argument Type. Effect. The row details are the
following. Row 1: Header File, Left angle bracket, i o stream, right

angle bracket,; Manipulator, end l; Argument Type, None; Effect,
Terminates the current output line. Row 2: Header File, Left angle
bracket, i o stream, right angle bracket; Manipulator, show point;
Argument Type, None; Effect, Forces display of a decimal point in
floating-point output. Row 3: Header File, Left angle bracket, i o
stream, right angle bracket; Manipulator, fixed; Argument Type,
None; Effect, Activates fixed-point notation in floating-point output.
Row 4: Header File, Left angle bracket, i o stream, right angle
bracket; Manipulator, scientific; Argument Type, None; Effect,
Activates scientific notation in floating-point output. Row 5: Header
File, Left angle bracket, i o manip, right angle bracket; Manipulator,
set w, left parenthesis, n, right parenthesis; Argument Type, i n t;
Effect, Sets the field width to n. Row 6: Header File, Left angle
bracket, i o manip, right angle bracket; Manipulator, set precision,
left parenthesis, n, right parenthesis; Argument Type, i n t; Effect,
Sets the floating-point precision to n digits.
Back to Table
A program demonstrating the use of manipulators. Program code.
Line 1. Forward slash, forward slash, a line of asterisk. Line 2.
Forward slash, forward slash, This program demonstrates floating-
point manipulators. Line 3. Forward slash, forward slash, a line of
asterisk. Line 4. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 5. Hash, include, left angle bracket, i o manip,
right angle bracket. Line 6. using, name space, s t d, semicolon.
Line 7. i n t, main, left parenthesis, right parenthesis. Line 8. Left
brace. Line 9, indented once. double, num, equals, 1000, semicolon.
Line 10, indented once. c out, double left angle bracket, set w, left
parenthesis, 3, right parenthesis, double left angle bracket, 1776,
double left angle bracket, open single quotes, space, close single
quotes, double left angle bracket, 44, double left angle bracket, end
l, semicolon. Line 11, indented once. c out, double left angle bracket,
set w, left parenthesis, 4, right parenthesis, double left angle
bracket, show point, double left angle bracket, num, double left
angle bracket, open single quotes, space, close single quotes,
double left angle bracket, 44.55, double left angle bracket, end l,
semicolon. Line 12, indented once. c out, double left angle bracket,
set precision, left parenthesis, 5, right parenthesis, double left angle

bracket, 1776.12, double left angle bracket, open single quotes,
space, close single quotes, double left angle bracket, num, double
left angle bracket, end l, semicolon. Line 13, indented once. c out,
double left angle bracket, num, semicolon. Line 14, indented once.
return, 0, semicolon. Line 15. Right brace.
Back to Figure
The output of the previous program. Line 1. 1776 44. Line 2.
1000.00 44.5500. Line 3. 1776.1 1000.0. Line 4. 1000.0.
Back to Figure
A program that computes the cost per square foot of living space for
a house. Program code. Line 1. Forward slash, forward slash,
House Cost program. Line 2. Forward slash, forward slash, This
program computes the cost per square foot of. Line 3. Forward
slash, forward slash, living space for a house, given the dimensions
of. Line 4. Forward slash, forward slash, the house, the number of
stories, the size of the. Line 5. Forward slash, forward slash, non
living space, and the total cost less land. Line 6. Hash, include, left
angle bracket, i o stream, right angle bracket. Line 7. Hash, include,
left angle bracket, i o manip, right angle bracket, forward slash,
forward slash, For set w, left parenthesis, right parenthesis, and set
precision, left parenthesis, right parenthesis. Line 8. using, name
space. Line 9. s t d, semicolon. Line 10. const, float, WIDTH,
equals, 30.0, semicolon, forward slash, forward slash, Width of the
house. Line 11, indented once. const, float, LENGTH, equals, 40.0,
semicolon, forward slash, forward slash, Length of the house. Line
12. const, float, STORIES, equals, 2.5, semicolon, forward slash,
forward slash, Number of full stories. Line 13. const, float, NON
underscore LIVING underscore SPACE, minus, 825.0, semicolon,
forward slash, forward slash, Garage, comma, closets, comma, e t
c, period. Line 14. const, float, PRICE, equals, 150000.0, semicolon,
forward slash, forward slash, Selling price less land. Line 15. i n t,
main, left parenthesis, right parenthesis, Left brace, float, gross
Footage, semicolon, forward slash, forward slash, Total square
footage. Line 16, indented once. float, living Footage, semicolon,
forward slash, forward slash, Living area. Line 17. float, cost Per

Foot, semicolon, forward slash, forward slash, Cost, forward slash,
foot of living area. Line 18, indented once. c out, double left angle
bracket, fixed, double left angle bracket, show point, semicolon,
forward slash, forward slash, Set up floating hyphen, p t, period.
Line 19. Forward slash, forward slash, output format. Line 20. gross
Footage equals, LENGTH, asterisk, WIDTH, asterisk, STORIES,
semicolon. living Footage, equals. Line 21. gross Footage, minus,
NON underscore LIVING underscore SPACE, semicolon, cost Per
Foot, equals, PRICE, forward slash. Line 22. living Footage,
semicolon. c out, double left angle bracket, open quotes, Cost per
square foot is, space, close quotes. Line 23. Double left angle
bracket, set w, left parenthesis, 6, right parenthesis, double left
angle bracket, set precision, left parenthesis, 2, right parenthesis,
double left angle bracket, cost Per Foot, double left angle bracket,
end l, semicolon. Line 24. return, 0, semicolon, right brace.
Back to Figure
The program that computes the cost per square foot of living space
for a house rewritten with proper formatting. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, House Cost program. Line 3. Forward slash,
forward slash, This program computes the cost per square foot of.
Line 4. Forward slash, forward slash, living space for a house, given
the dimensions of. Line 5. Forward slash, forward slash, the house,
the number of stories, the size of the. Line 6. Forward slash, forward
slash, nonliving space, and the total cost less land. Line 7. Forward
slash, forward slash, a line of asterisks. Line 8. Hash, include, left
angle bracket, i o stream, right angle bracket. Line 9. Hash, include,
left angle bracket, i o manip, right angle bracket, tab space, For set
w, left parenthesis, right parenthesis, and set precision, left
parenthesis, right parenthesis. Line 10. using, name space, s t d,
semicolon. Line 11. const, float, WIDTH, equals, 30.0, semicolon,
forward slash, forward slash, Width of the house. Line 12. const,
float, LENGTH, equals, 40.0, semicolon, forward slash, forward
slash, Length of the house. Line 13. const, float, STORIES, equals,
2.5, semicolon, forward slash, forward slash, Number of full stories.
Line 14. const, float, NON underscore LIVING underscore SPACE,
equals, 825.0, semicolon, tab space, forward slash, forward slash,

Garage, comma, closets, comma, e t c, period. Line 15. const, float,
PRICE, equals, 150000.0, semicolon, tab space, forward slash,
forward slash, Selling price less land. Line 16. i n t, main, left
parenthesis, right parenthesis. Line 17. Left brace. Line 18, indented
once. float, gross Footage, semicolon, forward slash, forward slash,
Total square footage. Line 19, indented once. float, living Footage,
semicolon, tab space, forward slash, forward slash, Living area. Line
20, indented once. float, cost Per Foot, semicolon, tab space,
forward slash, forward slash, Cost, forward slash, foot of living area.
Line 21, indented once. c out, double left angle bracket, fixed,
double left angle bracket, show point, semicolon, tab space, forward
slash, forward slash, Set up floating hyphen p t. Line 22, indented a
few times. forward slash, forward slash, output format. Line 23,
indented once. gross Footage, equals, LENGTH, asterisk, WIDTH,
asterisk, STORIES, semicolon. Line 24, indented once. living
Footage, equals, gross Footage, minus, NON underscore LIVING
underscore SPACE, semicolon. Line 25, indented once. cost Per
Foot, equals, PRICE, forward slash, living Footage, semicolon. Line
26, indented once. c out, double left angle bracket, open quotes,
Cost per square foot is, space, close quotes. Line 27, indented
twice. Double left angle bracket, set w, left parenthesis, 6, right
parenthesis, double left angle bracket, set precision, left
parenthesis, 2, right parenthesis, double left angle bracket, cost Per
Foot, double left angle bracket, end l, semicolon. Line 28, indented
once. return, 0, semicolon. Line 29. Right brace.
Back to Figure
The length function. Program code. Line 1. my Name, dot, length,
left parenthesis, right parenthesis.
Back to Figure
Code that calls the length function in an expression. Program code.
Line 1. string, first Name, semicolon. Line 2. string, full Name,
semicolon. Line 3. first Name, equals, open quotes, Alexandra, close
quotes, semicolon. Line 4. c out, double left angle bracket, first
Name, dot, length, left parenthesis, right parenthesis, double left
angle bracket, end l, semicolon, space, forward slash, forward slash,

Outputs 9. Line 5. full Name, equals, first Name, plus, open quotes,
space, Jones, close quotes, semicolon. Line 6. c out, double left
angle bracket, full Name, dot, length, left parenthesis, right
parenthesis, double left angle bracket, end l, semicolon, space,
forward slash, forward slash, Outputs 15.
Back to Figure
The length function. Program code. Line 1. first Name, dot, length,
left parenthesis, right parenthesis.
Back to Figure
The length function. Program code. Line 1. length, left parenthesis,
right parenthesis.
Back to Figure
Some valid find function calls. Program code. Line 1. s t r 1, dot,
find, left parenthesis, open quotes, the, close quotes, right
parenthesis. Line 2. s t r 1, dot, find, left parenthesis, s t r 2, right
parenthesis. Line 3. s t r 1, dot, find, left parenthesis, s t r 2, plus,
open quotes, a b c, close quotes, right parenthesis.
Back to Figure
A code segment. Program code. Line 1. string, phrase, semicolon.
Line 2. string, colon, colon, size underscore type, position,
semicolon. Line 3. phrase, equals, open quotes, The dog and the
cat, close quotes, semicolon.
Back to Figure
Example for the find function. Program code. Line 1. position,
equals, phrase, dot, find, left parenthesis, open quotes, the, close
quotes, right parenthesis, semicolon.
Back to Figure

Example for the find function. Program code. Line 1. position,
equals, phrase, dot, find, left parenthesis, open quotes, rat, close
quotes, right parenthesis, semicolon.
Back to Figure
A program that uses the find method on a string. Program code.
Line 1. Forward slash, forward slash, a line of asterisks. Line 2.
Forward slash, forward slash, String demo. Line 3. Forward slash,
forward slash, a line of asterisks. Line 4. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 5. Hash, include, left
angle bracket, string, right angle bracket, tab space, forward slash,
forward slash, For string type. Line 6. using, name space, s t d,
semicolon. Line 7. i n t, main, left parenthesis, right parenthesis.
Line 8. Left brace. Line 9, indented once. string, the String,
semicolon. Line 10, indented once. the String, equals, open quotes,
Abracadabra, close quotes, semicolon. Line 11. c out, double left
angle bracket, open quotes, Position, colon, space, close quotes,
double left angle bracket, the String, dot, find, left parenthesis, open
single quotes, a, close single quotes, right parenthesis, semicolon.
Line 12. Right brace.
Back to Figure
The output of the previous program. Line 1. Position 3.
Back to Figure
Some more examples of the find function. Program code. Line 1.
string, s t r 1, semicolon. Line 2. string, s t r 2, semicolon. Line 3. s t
r 1, equals, open quotes, Programming and Problem Solving, close
quotes, semicolon. Line 4. s t r 2, equals, open quotes, gram, close
quotes, semicolon.
Back to Figure
The sub s t r function. Program code. Line 1. my String, dot, sub s t
r, left parenthesis, 5, comma, 20, right parenthesis.
Back to Figure

A string assignment. Program code. Line 1. my String, equals, open
quotes, Programming and Problem Solving, close quotes.
Back to Figure
"A program that uses find and sub s t r to break a string into parts.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, Sub s t r Ops
program. Line 3. Forward slash, forward slash, This program
demonstrates find and substr operations. Line 4. Forward slash,
forward slash, al line of asterisks. Line 5. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 6. Hash, include, left
angle bracket, string, right angle bracket, tab space, forward slash,
forward slash, For string type. Line 7. using, name space, s t d,
semicolon. Line 8. i n t, main, left parenthesis, right parenthesis.
Line 9. Left brace. Line 10, indented once. string, name, equals,
open quotes, Olivia Johnson Peterson, close quotes, semicolon.
Line 11, indented once. i n t, index, semicolon. Line 12, indented
once. index, equals, name, dot, find, left parenthesis, open single
quotes, space, close single quotes, right parenthesis, semicolon.
Line 13, indented once. c out, double left angle bracket, open
quotes, First Name, colon, space, close quotes, double left angle
bracket, name, dot, sub s t r, left parenthesis, 0, comma, index, right
parenthesis, double left angle bracket, end l, semicolon. Line 14,
indented once. name, equals, name, dot, sub s t r, left parenthesis,
index, plus, 1, comma, name, dot, length, left parenthesis, right
parenthesis, minus, 1, right parenthesis, semicolon. Line 15,
indented once. index, equals, name, dot, find, left parenthesis, open
single quotes, space, close single quotes, right parenthesis,
semicolon. Line 16, indented once. c out, double left angle bracket,
open quotes, Middle Name, colon, space, close quotes, double left
angle bracket, name, dot, sub s t r, left parenthesis, 0, comma,
index, right parenthesis, double left angle bracket, end l, semicolon.
Line 17, indented once. name, equals, name, dot, sub s t r, left
parenthesis, index, plus, 1, comma, name, dot, length, left
parenthesis, right parenthesis, minus, 1, right parenthesis,
semicolon. Line 18, indented once. c out, double left angle bracket,
open quotes, Last Name, colon, space, close quotes, double left

angle bracket, name, semicolon. Line 19, indented once. return, 0,
semicolon. Line 20. Right brace."
Back to Figure
The output of the program that uses find and sub s t r to break a
string into parts. Line 1. First Name: Olivia. Line 2. Middle Name:
Johnson. Line 3. Last Name: Peterson.
Back to Figure
Code with a call to the at function. Program code. Line 1. Some
Char Variable, equals, some String, dot, at, left parenthesis, some
Position, right parenthesis, semicolon.
Back to Figure
Code with a call to the at function. Program code. Line 1. letter,
equals, input S t r, dot, at, left parenthesis, 2, right parenthesis,
semicolon.
Back to Figure
"A table detailing functions for converting to lowercase and
uppercase. The table has 2 rows and 4 columns. It has the following
column headings. Header File. Function. Function Type. Function
Value. The row information is the following. Row 1: Header File: Left
angle bracket, c c type, right angle bracket. Function: to upper, left
parenthesis, c h, right parenthesis. Function Type, char, asterisk.
Function Value: Uppercase equivalent of c h, if c h is a lowercase
letter; c h, otherwise. Row 2: Header File. Left angle bracket, c c
type, right angle bracket. Function: to lower, left parenthesis, c h,
right parenthesis. Function Type: char. Function Value: Lowercase
equivalent of c h, if ch is an uppercase letter; c h, otherwise."
Back to Table
A program that demonstrates the use of the sub s t r and to upper
functions. Program code. Line 1. Forward slash, forward slash, a
line of asterisks. Line 2. Forward slash, forward slash, This program

demonstrates the use of sub s t r and to upper. Line 3. Forward
slash, forward slash, a line of asterisks. Line 4. Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5. Hash, include,
left angle bracket, string, right angle bracket, Line 6. Hash, include,
left angle bracket, c c type, right angle bracket, Line 7. using, name
space, s t d, semicolon. Line 8. i n t, main, left parenthesis, right
parenthesis. Line 9. Left brace. Line 10, indented once. string, first
Name, equals, open quotes, mary, close quotes, semicolon. Line 11,
indented once. string, last Name, equals, open quotes, melrose,
close quotes, semicolon. Line 12, indented once. char, c h,
semicolon. Line 13, indented once. c h, equals, to upper, left
parenthesis, last Name, dot, at, left parenthesis, 0, right
parenthesis, right parenthesis, semicolon. Line 14, indented once.
last Name, equals, ch, plus, last Name, dot, sub s t r, left
parenthesis, 1, comma, last Name, dot, length, left parenthesis,
right parenthesis, right parenthesis, semicolon. Line 15, indented
once. c h, equals, to upper, left parenthesis, first Name, dot, at, left
parenthesis, 0, right parenthesis, right parenthesis, semicolon. Line
16, indented once. first Name, equals, c h, plus, first Name, dot, sub
s t r, left parenthesis, 1, comma, first Name, dot, length, left
parenthesis, right parenthesis, right parenthesis, semicolon. Line 17,
indented once. c out, double left angle bracket, first Name, double
left angle bracket, open quotes, space, close quotes, double left
angle bracket, last Name, double left angle bracket, end l,
semicolon. Line 18, indented once. return, 0, semicolon. Line 19.
Right brace.
Back to Figure
The output of the previous program. Line 1. Mary Melrose.
Back to Figure
"A table that summarizes string and character operations covered in
this chapter. The table has 6 rows and 4 columns. The column
headings are the following. Function Call (s is of type string).
Argument Types. Result Type. Result (Value Returned). The row
details are the following. Row 1: Function Call (s is of type string), s,
dot, length, left parenthesis, right parenthesis; Argument Types,

None; Result Type, string, colon, colon, size underscore type; Result
(Value Returned), Number of characters in string. Row 2: Function
Call (s is of type string), s, dot, find, left parenthesis, a r g, right
parenthesis; Argument Types, string, literal string, of char; Result
Type, string, colon, colon, size underscore type; Result (Value
Returned), Starting position in s where a r g was found; if not found,
result is string, colon, colon, n pos. Row 3: Function Call (s is of type
string), s, dot, sub s t r, left parenthesis, p o s, comma, len, right
parenthesis; Argument Types, i n t, i n t; Result Type, string; Result
(Value Returned), Sub string of at most len characters, starting at
position pos of s. If len is too large, it means “to the end” of string s.
If pos is too large, execution of the program is terminated. asterisk.
Row 4: Function Call (s is of type string), s, dot, at, left parenthesis,
p o s, right parenthesis; Argument Types, i n t; Result Type, char;
Result (Value Returned), Returns char at pos position in s. If pos is
too large, execution of the program is terminated. asterisk. Row 5:
Function Call (s is of type string), to upper, left parenthesis, c h, right
parenthesis; Argument Types, char; Result Type, char; Result (Value
Returned), Returns uppercase of c h if lowercase; otherwise, c h is
unchanged. Row 6: Function Call (s is of type string), to lower, left
parenthesis, c h, right parenthesis; Argument Types, char; Result
Type, char; Result (Value Returned), Returns lowercase of c h if
uppercase; otherwise, c h is unchanged. Note. Asterisk. Technically,
if pos is too large, the program generates what is called an out-of-
range exception. Unless we write additional program code to deal
explicitly with this exception, the program simply terminates with a
message such as ABNORMAL PROGRAM TERMINATION. Using
more advanced capabilities in C plus plus, it is possible to catch
such errors before the program halts and take corrective action."
Back to Table
The formula for determining payments based on compound interest.
Amount times (1 plus Monthly Interest) raised to the power of
Number of Payments times Monthly Interest, the whole divided by (1
plus Monthly Interest) raised to the power of Number of Payments
minus 1.
Back to Figure

A program that determines the monthly payments on a mortgage
given the loan amount, the yearly interest, and the number of years.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, Mortgage Payment
Calculator program. Line 3. Forward slash, forward slash, This
program determines the monthly payments on a mortgage given.
Line 4. Forward slash, forward slash, the loan amount, comma, the
yearly interest, comma, and the number of years, period. Line 5.
Forward slash, forward slash, a line of asterisk. Line 6. Hash,
include, left angle bracket, i o stream, right angle bracket, tab
spaces, forward slash, forward slash, Access c out. Line 7. Hash,
include, left angle bracket, c math, right angle bracket, tab spaces,
forward slash, forward slash, Access power function. Line 8. Hash,
include, left angle bracket, i o manip, right angle bracket, tab
spaces, forward slash, forward slash, Access manipulators. Line 9.
using, name space, s t d, semicolon; Line 10. const, float, LOAN
underscore AMOUNT, equals, 50000.00, semicolon, tab spaces,
forward slash, forward slash, Amount of the loan. Line 11. const,
float, YEARLY underscore INTEREST, equals, 0.0524, semicolon,
tab spaces, forward slash, forward slash, Yearly interest rate. Line
12. const, i n t, NUMBER underscore OF underscore YEARS,
equals, 7, semicolon, tab spaces, forward slash, forward slash,
Number of years. Line 13. i n t, main, left parenthesis, right
parenthesis. Line 14. Left brace. Line 15, indented once. Forward
slash, forward slash, Local variables. Line 16, indented once. float,
monthly Interest, semicolon, tab spaces, forward slash, forward
slash, Monthly interest rate. Line 17, indented once. i n t, number Of
Payments, semicolon, tab spaces, forward slash, forward slash,
Total number of payments. Line 18, indented once. float, payment,
semicolon, tab spaces, forward slash, forward slash, Monthly
payment. Line 19, indented once. forward slash, forward slash,
Calculate values. Line 20, indented once. monthly Interest, equals,
YEARLY underscore INTEREST, forward slash, 12, semicolon. Line
21, indented once. number Of Payments, equals, NUMBER
underscore OF underscore YEARS, asterisk, 12, semicolon. Line
22, indented once. payment, equals, left parenthesis, LOAN
underscore AMOUNT, asterisk, pow, left parenthesis, 1, plus,
monthly Interest, comma. Line 23, indented a few times. number Of
Payments, right parenthesis. Line 24, indented a few times. asterisk,

monthly Interest, right parenthesis, forward slash. Line 25, indented
a few times. Left parenthesis, pow, left parenthesis, 1, plus, monthly
Interest, comma, number Of Payments, right parenthesis, minus, 1,
right parenthesis, semicolon. Line 26, indented once. Forward slash,
forward slash, Output results. Line 27, indented once. c out, double
left angle bracket, fixed, double left angle bracket, set precision, left
parenthesis, 2, right parenthesis, open quotes, For a loan amount
of, space, close quotes. Line 28, indented twice. Double left angle
bracket, LOAN underscore AMOUNT, double left angle bracket,
open quotes, space, with an interest rate of, space, close quotes.
Line 29, indented twice. Double left angle bracket, YEARLY
underscore INTEREST, double left angle bracket, open quotes,
space, and a, space, close quotes, double left angle bracket,
NUMBER underscore OF underscore YEARS. Line 30, indented
twice. Double left angle bracket, open quotes, space, year
mortgage, comma, space, close quotes, double left angle bracket,
end l, semicolon. Line 31, indented once. c out, double left angle
bracket, open quotes, space, your monthly payments are dollar,
close quotes, double left angle bracket, payment. Line 32, indented
twice. Double left angle bracket, open quotes, period, close quotes,
double left angle bracket, end l, semicolon. Line 33, indented once.
return, 0, semicolon. Line 34. Right brace.
Back to Figure
The output of the previous program. Line 1. For a loan amount of
50000.00 with an interest rate of 0.05 and. Line 2. a 7 year
mortgage, Line 3, indented once. your monthly payments are
$712.35.
Back to Figure
Mathematical operators listed in question number 3.8 under exam
preparation exercises that need to be listed in the order of
precedence. Asterisk, plus, modulus, forward slash, minus, unary
minus, left parenthesis and right parenthesis.
Back to Figure

A statement listed in question number 3.11 under exam preparation
exercises. Program code. Line 1. count, equals, count, plus 1,
semicolon.
Back to Figure
An output statement listed in question number 3.14 under exam
preparation exercises. Program code. Line 1. c out, double left angle
bracket, set w, left parenthesis, 6, right parenthesis, double left
angle bracket, show point, double left angle bracket, set precision,
left parenthesis, 2, right parenthesis, double left angle bracket,
215.0, semicolon.
Back to Figure
A string listed in question number 3.17 under exam preparation
exercises. Program code. Line 1. Open quotes, you ought to start
with logic, close quotes.
Back to Figure
A string listed in question number 3.17 under exam preparation
exercises. Line 1. Open quotes, o u, close quotes.
Back to Figure
3 x plus y. A squared plus 2 times B plus C. (A plus B divided by C
minus D) times (X divided by Y). ((A squared plus 2 times B plus C)
divided by D) divided by X times Y. Square root of A minus B. X
raised to the power of minus cosine of Y.
Back to Figure
A program listed for question number 3.15 under programming
warm-up exercises. Program code. Line 1. Forward slash, forward
slash, a line of asterisks. Line 2. Forward slash, forward slash,
Celsius program. Line 3. Forward slash, forward slash, This program
outputs the Celsius temperature. Line 4. Forward slash, forward
slash, corresponding to a given Fahrenheit temperature. Line 5.
Forward slash, forward slash, a line of asterisks. Line 5. Hash,

include, left angle bracket, i o stream, right angle bracket. Line 6.
using, name space, s t d, semicolon. Line 7. i n t, main, left
parenthesis, right parenthesis. Line 8. Left brace. Line 9, indented
once. const, float, FAHRENHEIT, equals, 72.0, semicolon.
Back to Figure
1 divided by 3 times Radius squared times Height.
Back to Figure
s equals the square root of (Sigma i equals 1 to n of (x subscript I
minus x bar)) divided by n minus 1.
Back to Figure
n factorial equals e raised to the power of minus n times n raised to
the power of n times the square root of 2 time pi times n.
Back to Figure
n factorial divided by (r factorial times (n minus r) factorial.
Back to Figure
Open quotes, John Jacob Schmidt, close quotes.
Back to Figure
Line 1. First name: John. Line 2. Middle name: Jacob. Line 3. Last
name: Schmidt.
Back to Figure
A diagram shows the benefit of separating data from a program.
Program 1 has data as constants. The output of this program gives
certain results. This program must be changed to work with different
data values. Program 2 works by getting data as input from the
outside. When data set 1 is provided as input to program 2, the
output gives result set 1. When data set 2 is provided as input to

program 2, the output gives result set 2. Program 2 inputs its data
from outside, so it can work with different data sets without being
changed.
Back to Figure
The preprocessor directive for working with stream input and output.
Program code. Line 1. Hash, include, left angle bracket, i o stream,
right angle bracket.
Back to Figure
The declarations in the i o stream header file. Program code. Line 1.
i stream, c in, semicolon. Line 2. o stream, c out, semicolon.
Back to Figure
A c out statement that makes use of the insertion operator. Program
code. Line1. c out, double left angle bracket, 3, asterisk, price,
semicolon.
Back to Figure
A c in statement that makes use of the extraction operator. Program
code. Line 1. c in, double right angle bracket, cost, semicolon.
Back to Figure
The extraction operator being used multiple times in a statement.
Program code. Line 1. c in, double right angle bracket, length,
double right angle bracket, width, semicolon.
Back to Figure
A different way of writing the previous statement. Program code.
Line 1. c in, double right angle bracket, length, semicolon. Line 2. c
in, double right angle bracket, width, semicolon.
Back to Figure

An output statement. Program code. Line 1. c out, double left angle
bracket, some Int, semicolon.
Back to Figure
An input statement. Program code. Line 1. c in, double right angle
bracket, some Int, semicolon.
Back to Figure
"A program that demonstrates the use of c in and c out. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, This program demonstrates c in
and c out. Line 3. Forward slash, forward slash, a line of asterisks.
Line 4. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 5. Hash, include, left angle bracket, string, right angle
bracket. Line 6. using, name space, s t d, semicolon. Line 7. i n t,
main, left parenthesis, right parenthesis. Line 8. Left brace. Line 9,
indented once. i n t, year, semicolon. Line 10, indented once. i n t,
month, semicolon. Line 11, indented once. i n t, day, semicolon. Line
12, indented once. c out, double left angle bracket, open quotes,
Enter the month comma day comma and year in integer form,
period, close quotes. Line 13, indented twice. double left angle
bracket, end l, semicolon. Line 14, indented once. c in, double right
angle bracket, month, double right angle bracket, day, double right
angle bracket, year, semicolon. Line 15, indented once. c out,
double left angle bracket, month, double left angle bracket, open
quotes, forward slash, close quotes, double left angle bracket, day,
double left angle bracket, open quotes, forward slash, close quotes,
double left angle bracket, year, semicolon. Line 16, indented once.
return, 0, semicolon. Line 17. Right brace.}"
Back to Figure
The output of the previous program. The program prompts the user
with the following line. Enter the month, day, and year in integer
form. The user responds by entering 12, then 7, then 1491. The
program then prints the following as output. 12, forward slash, 7,
1941.

Back to Figure
The syntax template for an input statement. c in, double right angle
bracket, Variable, double right angle bracket, Variable, ellipsis,
semicolon.
Back to Figure
A table listing examples of input using the reading marker and the
newline character. In this table, i is an i n t variable, c h is a char
variable, and x is a float variable. First example set. The input is the
following. 25 A 16.9 backslash n. The reading marker is at 2. The
following statement executes. c in, double right angle bracket, i,
semicolon. The content after input is i equals 25. The input is the
following. 25 A 16.9 backslash n. The reading marker is in the space
after A. The following statement executes. c in, double right angle
bracket, c h, semicolon. The content after input is c h equals, open
single quotes, close single quotes. The input is the following. 25 A
16.9 backslash n. The reading marker is in the space after A. The
following statement executes. c in, double right angle bracket x,
semicolon. The content after input is the following. x equals 16.9.
The input is the following. 25 A 16.9 backslash n. The reading
marker is at the backslash n character. Example set 2. The input is
the following. A backslash n. The input is the following. 16.9
backslash n. The following statement executes c in, double right
angle bracket, i, semicolon. The content after input is i equals 25.
The input is the following 25 backslash n. The reading marker is at
the backslash n character. The input is the following. A backslash n.
The input is the following. 16.9 backslash n. The following statement
executes c in double right angle bracket, c h, semicolon. The
content after input is c h equals open single quotes A close single
quotes. The input is the following. 25 backslash n. The input is the
following. A backslash n. The reading marker is at the backslash n
character. The input is the following. 16.9 backslash n. The following
statement executes. c in, double right angle bracket, x, semicolon.
The content after input is x equals 16.9. The input is the following 25
backslash n. The input is the following. A backslash n. The input is
the following 16.9 backslash n. The reading marker is at the
backslash n character. The input is the following. 25 A 16.9

backslash n. The reading marked is at 2. Third example set. The
input is the following. 25 A 16.9 backslash n. The reading marker is
at 2. The following statement executes. c in, double right angle
bracket, i, semicolon. The content after input is i equals 25. The
input is the following. 25 A 16.9 backslash n. The reading marker is
at A. The following statement executes. c in, double right angle
bracket c h, semicolon. The content after input is c h equals open
single quotes, A, close single quotes. The input is the following. 25 A
16.9 backslash n. The reading marker is at 1. The following
statement executes. c in, double right angle bracket, x, semicolon.
The content after input is x equals 16.9. The input is the following.
25 A 16.9 backslash n.
Back to Table
An input statement. Program code. Line 1. c in, double right angle
bracket, c h 1, double right angle bracket, c h 2, semicolon.
Back to Figure
The input provided to the previous code. R 1.
Back to Figure
The function call to get. Program code. Line 1. c in, dot, get, left
parenthesis, some Char, right parenthesis, semicolon.
Back to Figure
"A program that demonstrates the use of the get function. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, This program demonstrates the use
of the get function. Line 3. Forward slash, forward slash, a line of
asterisks. Line 4. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 5. using, name space, s t d, semicolon. Line 6. i
n t, main, left parenthesis, right parenthesis. Line 7. Left brace. Line
8, indented once. char, c h 1, comma, c h 2, comma, c h 3,
semicolon. Line 9, indented once. c out, double left angle bracket,
open quotes, Enter three characters including a space, period, close
quotes, double left angle bracket, end l, semicolon. Line 10,

indented once. c in, dot, get, left parenthesis, c h 1, right
parenthesis, semicolon. Line 11, indented once. c in, dot, get, left
parenthesis, c h 2, right parenthesis, semicolon. Line 12, indented
once. c in, dot, get, left parenthesis, c h 3, right parenthesis,
semicolon. Line 13, indented once. c out, double left angle bracket,
open quotes, You entered, colon, space, close quotes, double left
angle bracket, c h 1, double left angle bracket, c h 2, double left
angle bracket, c h 3, double left angle bracket, end l, semicolon.
Line 14, indented once. return, 0, semicolon. Line 15. Right brace.}"
Back to Figure
The output of the previous program. The program prompts the user
with the following line. Enter three characters including a space. The
user responds by entering asterisk, A. The program then prints the
following as output. You entered, colon, asterisk, A. asterisk A is the
user input.
Back to Figure
An alternative way to have coded the previous program. Program
code. Line 1. c in, double right angle bracket, c h 1, semicolon. Line
2. c in, dot, get, left parenthesis, c h 2, right parenthesis, semicolon.
Line 3. c in, double right angle bracket, c h 3, semicolon.
Back to Figure
A table listing examples of character input using both the double
right angle bracket operator and the get function. C h 1, c h 2, and c
h 3 are all char variables. Backslash n denotes the newline
character. Example set 1. The following is the input. A B backslash
n. The reading marker is at A. The following is the input. C D
backslash n. The following statement executes. c in, double right
angle bracket, c h 1, semicolon. The content after input is c h 1
equals, open single quotes A close single quotes. The following is
the input. A B backslash n. The reading marker is in the space after
A. The following is the input. C D backslash n. The following
statement executes. c in, double right angle bracket, c h 2,
semicolon. The following is the input. c h 2 equals, open single

quotes, B, close single quotes. The following is the input. A B
backslash n. The reading marker is at backslash n. The following is
the input. C D backslash n. The following statement executes. c in,
double right angle bracket, c h 3, semicolon. The content after input
is c h 3 equals open single quotes, C, close single quotes. A B
backslash n. The following is the input. C D backslash n. The
reading marker is at D. Example set 2. The following is the input. A
B backslash n. The reading marker is at A. The following is the input.
C D backslash n. The following statement executes. c in, dot, get,
left parenthesis, c h 1, right parenthesis, semicolon. The content
after input is c h 1 equals, open single quotes, A, close single
quotes. The following is the input. A B backslash n. The reading
marker is at the space after A. The following is the input. C D
backslash n. The following statement executes. c in, dot, get, left
parenthesis, c h 2, right parenthesis, semicolon. The content after
input is c h 2 equals open single quotes, close single quotes. The
input is the following. A B backslash n. The reading marker is at B.
The following is the input. C D backslash n. The following statement
executes. c in, dot, get, left parenthesis, c h 3, right parenthesis,
semicolon. The content after input is c h 3 equals, open single
quotes, B, close single quotes. The input is the following. A B
backslash n. The reading markers is at backslash n. The input is the
following. C D backslash n. Example set 3. The input is the following.
A B backslash n. The reading marker is at A. The input is the
following. C D backslash n. The following statement executes. c in,
double right angle bracket c h 1, semicolon. The content after input
is c h 1 equals, open single quotes, A, close single quotes. The input
is the following. A B backslash n. The reading marker is at the space
after A. The input is the following. C D backslash n. The following
statement executes. c in, double right angle bracket, c h 2,
semicolon. The content after input is c h 2 equals, open single
quotes, B, close single quotes. The input is the following. A B
backslash n. The read marker is at backslash n. The input is the
following. C D backslash n. The following statement executes. c in,
dot, get, left parenthesis, c h 3, right parenthesis, semicolon. The
content after input is c h 3 equals, open single quotes, backslash, n,
close single quotes. The input is the following. A B backslash n. The
input is the following. C D backslash n.

Back to Table
The ignore function. Program code. Line 1. c in, dot, ignore, left
parenthesis, 200, comma, open single quotes, backslash, n, close
single quotes, right parenthesis, semicolon.
Back to Figure
A table listing examples of input using a char variable c h and three i
n t variables i, j, and k. Example set 1. The following is the input. 957
34 1235 backslash n. The reading marker is at 9. 128 96 backslash
n. The following statement executes. c in, double right angle
bracket, i, double right angle bracket, j, semicolon. The contents
after input is i equals 957. j equals 34. The input is the following. 957
34 1235 backlash n. The reading marker is at the space after 34.
The following is the input. 128 96 backslash n. The following
statement executes. c in, dot, ignore, left parenthesis, 100, comma,
open single quotes, backslash n, close single quotes, right
parenthesis, semicolon. The following is the input. 957 34 1235
backslash n. The following is the input. 128 96 backslash n. The
reading marker is at 1. The following statement executes. c in,
double right angle bracket, k, semicolon. The contents after input is
k equals 128. The following is the input. 957 34 1235 backslash n.
The following is the input. 128 96 backslash n. The reading marker is
at the space after 128. Example set 2. The following is the input. A
22 comma 16 comma 19 backslash n. The reading marker is at A.
The following statement executes. c in, double right angle bracket c
h, semicolon. The contents after input is c h, equals, open single
quotes, A, close single quotes. The following is the input. A 22
comma 16 comma 19 backslash n. The reading marker is at the
space after A. The following statement executes. c in, dot, ignore,
left parenthesis, 100, comma, open single quotes, comma, close
single quotes, right parenthesis, semicolon. The following is the
input. A 22, comma, 16, comma, 19 backslash n. The following
statement executes. c in, double right angle bracket, i, semicolon.
The contents after input is i equals 16. The following is the input. A
22, comma, 16, comma, 19 backslash n. The reading marker is at
the space after the first comma and at the second comma. Example
set 3. The following is the input. A B C D E F backslash n. The

reading marker is at A. The following statement executes. c in, dot,
ignore, left parenthesis, 2, comma, open single quotes, backslash,
n, close single quotes, right parenthesis, semicolon. The following is
the input. A B C D E F backslash n. the reading marker is at C The
following statement executes. c in, double right angle bracket, c h,
semicolon. The content after input is c h, equals, open single
quotes, C, close single quotes. The input is the following. A B C D E
F backslash n. The reading marker is at D.
Back to Figure
A section of code that gets input. Program code. Line 1. string, first
Name, semicolon. Line 2. string, last Name, semicolon. Line 3. c in,
right double angle bracket, first Name, right double angle bracket,
last Name, semicolon.
Back to Figure
Sample input for the previous code. Blank, blank, blank, Mary, blank,
Smith, blank, blank, blank, 18.
Back to Figure
In the previous input, the input stream is left with the following
characters. Blank, blank, blank, 18.
Back to Figure
A call to the get line function. Program code. Line 1. get line, left
parenthesis, c in, comma, my String, right parenthesis, semicolon.
Back to Figure
A sample code segment. Program code. Line 1. string, input S t r,
semicolon. Line 2. get line, left parenthesis, c in, comma, input S t r,
right parenthesis, semicolon.
Back to Figure

The input for the get line statement. Blank, blank, Mary, blank,
Smith, blank, blank, blank, 18.
Back to Figure
A program that demonstrates the use of get line and c in. Program
code. Line 1. Forward slash, forward slash, a line of asterisk. Line 2.
Forward slash, forward slash, This program demonstrates the use of
c in and. Line 3. Forward slash, forward slash, get line combined.
Line 4. Forward slash, forward slash, a line of asterisks. Line 5.
Hash, include, left angle bracket, i o stream, right angle bracket.
Line 6. include, left angle bracket, string, right angle bracket. Line 7.
using, name space, s t d, semicolon. Line 8, i n t, main, left
parenthesis, right parenthesis. Line 9. Left brace. Line 10, indented
once. i n t, part Number, semicolon. Line 11, indented once. i n t,
quantity, semicolon. Line 12, indented once. float, unit Price,
semicolon. Line 13, indented once. float, total Price, semicolon. Line
14. string, title, semicolon. Line 14, indented once. get line, left
parenthesis, c in, comma, title, right parenthesis, semicolon. Line
15, indented once. c in, double right angle bracket, part Number,
semicolon. Line 16, indented once. c in, double right angle bracket,
quantity, semicolon. Line 17, indented once. c in, double right angle
bracket, unit Price, semicolon. Line 18, indented once. total Price,
equals, quantity, asterisk, unit Price, semicolon. Line 19, indented
once. c out, double left angle bracket, title, double left angle bracket,
end l, semicolon. Line 20, indented once. c out, double left angle
bracket, part Number, double left angle bracket, open quotes,
space, close quotes, double left angle bracket, quantity, double left
angle bracket, open quotes, space, close quotes, double left angle
bracket, unit Price, double left angle bracket, open quotes, space,
close quotes, semicolon. Line 21, indented once. c out, double left
angle bracket, total Price, double left angle bracket, end l,
semicolon. Line 22, indented once. return, 0, semicolon. Line 23.
Right brace.
Back to Figure
Output. Line 1. Test run. Line 2. 23 6 33.40. Line 3. Test run. Line 4.
23 6 33.4 200.4. Lines 1 and 2 in the above output have been

highlighted.
Back to Figure
A program that demonstrates the proper use of prompts. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, This program demonstrates the use
of input prompts. Line 3. Forward slash, forward slash, a line of
asterisks. Line 4. Hash, include, left angle bracket, i o stream, right
angle bracket. Note. This line is highlighted. Line 5. Hash, include, i
o manip, right angle bracket, tab space, forward slash, forward
slash, For set precision, left parenthesis, right parenthesis. Line 6.
Hash, include, left parenthesis, string, right parenthesis. Line 7.
using, name space, s t d, semicolon. Line 8. i n t, main, left
parenthesis, right parenthesis. Line 9. Left brace. Line 10, indented
once. i n t, part Number, semicolon. Line 11, indented once. i n t,
quantity, semicolon. Line 12, indented once. float, unit Price,
semicolon. Line 13, indented once. float, total Price, semicolon. Line
14, indented once. string, title, semicolon. Line 15, indented once. c
out, double left angle bracket, fixed, double left angle bracket, show
point, tab space, forward slash, forward slash, Set up floating-point.
Line 16, indented twice. double left angle bracket, set precision, left
parenthesis, 2, right parenthesis, semicolon, forward slash, forward
slash, output format. Line 17, indented once. c out, double left angle
bracket, open quotes, Enter the title for this execution, period, close
quotes, double left angle bracket, end l, semicolon, forward slash,
forward slash, Prompt. Line 18, indented once. get line, left
parenthesis, c in, comma, title, right parenthesis, semicolon. Line
19, indented once. c out, double left angle bracket, open quotes,
Enter the part number, colon, close quotes, double left angle
bracket, end l, semicolon, forward slash, forward slash, Prompt. Line
20, indented once. c in, double right angle bracket, part Number,
semicolon. Line 21, indented once, c out, double left angle bracket,
open quotes, Enter the quantity of this part ordered, colon, close
quotes, tab space, forward slash, forward slash, Prompt. Line 22,
indented once, double left angle bracket, end l, semicolon. Line 23,
indented once: c in, double right angle bracket, quantity, semicolon.
Line 24, indented once. c out, double left angle bracket, open
quotes, Enter the unit price for this part, colon, close quotes, tab

space, forward slash, forward slash, Prompt. Line 25, indented
twice. end l, semicolon. Line 26, indented once. c in, double right
angle bracket, unit Price, semicolon. Line 27, indented once. total
Price, equals, quantity, asterisk, unit Price, semicolon. Line 28,
indented once. c out, double left angle bracket, title, double left
angle bracket, end l, semicolon. Line 29, indented once. c out,
double left angle bracket, open quotes, Part, space, close quotes,
double left angle bracket, part Number, tab space, forward slash,
forward slash, Echo print. Line 30, indented twice, double left angle
bracket, open quotes, comma, quantity, space, close quotes, double
left angle bracket, quantity. Line 31, indented twice. double left angle
bracket, open quotes, comma, at dollar, space, close quotes, double
left angle bracket, unit Price, double left angle bracket, open quotes,
space, each, close quotes, double left angle bracket, end l,
semicolon. Line 32, indented once. c out, double left angle bracket,
open quotes, totals dollar, space, close quotes, double left angle
bracket, total Price, double left angle bracket, end l, semicolon. Line
33, indented once. return 0; Line 34. Right brace.
Back to Figure
Output of the program. Line 1. Enter the title for this execution. Line
2. Demonstrating interactive input/output. Line 3. Enter the part
number, colon. Line 4. 23. Line 5. Enter the quantity of this part
ordered, colon. Line 6. 6. Line 7. Enter the unit price for this part,
colon. Line 8. 33.4. Line 9. Demonstrating interactive input/output.
Line 10. Part 23, quantity 6, at $ 33.40 each. Line 11. totals $
200.40. Lines 2, 4, 6, and 8 have been highlighted in the output.
Back to Figure
An unintuitive error message. Line 1. ILLEGAL DATA VALUES!!!!!!!
Back to Figure
A better error message. Line 1. That is not a valid part number. Line
2. Part numbers must be no more than four digits long. Line 3.
Please reenter the number in its proper form, colon.

Back to Figure
Program code. Line 1. Hash, include, left angle bracket, f stream,
right angle bracket.
Back to Figure
Some stream object variables declarations. Program code. Line 1. i
n t, some I n t, semicolon. Line 2. float, some Float, semicolon. Line
3. i f stream in File, semicolon. Line 4. o f stream, out File,
semicolon.
Back to Figure
An input and output file stream object. Program code. Line 1. i f
stream in Data, semicolon, tab space, forward slash forward slash,
Holds loan amount, interest, and length. Line 2. o f stream, out
Data, semicolon, tab space, forward slash, forward slash, Holds
input values and monthly payments.
Back to Figure
Program code. Line 1. in Data, dot, open, left parenthesis, open
quotes, loan, dot, in, close quotes, right parenthesis, semicolon. Line
2. out Data, dot, open, left parenthesis, open quotes, loan, dot, out,
close quotes, right parenthesis, semicolon.
Back to Figure
The effect of opening a file. When the file in Data is opened, a
reading marker is set in the file. In the file out Data, after opening, a
writing marker is set.
Back to Figure
Code for opening files. Program code. Line 1. i n t, main, left
parenthesis, right parenthesis. Line 2. Left brace. Line 3, indented
once. Forward slash, forward slash, Declarations. Line 4. Ellipsis.
Line 5, indented once. Forward slash, forward slash, Open the files.
Line 6, indented once. in Data, dot, open, left parenthesis, open

quotes, loan, dot, in, close quotes, right parenthesis, semicolon. Line
7, indented once. out Data, dot, open, left parenthesis, open quotes,
loan, dot, out, close quotes, right parenthesis, semicolon. Line 8.
Ellipsis. Line 9. Right brace.
Back to Figure
Program code. Line 1. i f stream, in File, semicolon. Line 2. in File,
dot, open, left parenthesis, open quotes, my data, dot, dat, close
quotes, right parenthesis, semicolon, forward slash, forward slash,
Open the file. Line 3. colon, forward slash, forward slash, Read and
process the file data. Line 4. in File, dot, close, left parenthesis, right
parenthesis, semicolon, forward slash, forward slash, Close the file.
Line 5. colon.
Back to Figure
Program code. Line 1. in Data, double right angle bracket, loan
Amount, double right angle bracket, yearly Interest, double right
angle bracket, number Of Years.
Back to Figure
Program code. Line 1. out Data, double left angle bracket, fixed,
double left angle bracket, set precision, left parenthesis, 2, right
parenthesis, double left angle bracket, open quotes, For a loan
amount of, space, close quotes. Line 2, indented once. Double left
angle bracket, loan Amount. Line 3, indented once. Double left angle
bracket, open quotes, space, with an interest rate of, space, close
quotes, double left angle bracket, set precision, left parenthesis, 4,
right parenthesis. Line 4, indented once. Double left angle bracket,
yearly Interest, double left angle bracket, open quotes, space, and
a, space, close quotes. Line 5, indented once. Double left angle
bracket, number Of Years, double left angle bracket, open quotes,
year mortgage, comma, space, close quotes, double left angle
bracket, end l, semicolon. Line 6. out Data, double left angle
bracket, fixed, double left angle bracket, set precision, left
parenthesis, 2, right parenthesis. Line 7, indented once. Double left
angle bracket, open quotes, your monthly payments are dollar, close

quotes, double left angle bracket, payment. Line 8. Double left angle
bracket, open quotes, dot, close quotes, double left angle bracket,
end l, semicolon.
Back to Figure
Code block for the Mortgage program. Program code. Line 1. Hash,
include, left angle bracket, i o stream, right angle bracket, tab space,
forward slash, forward slash, Access c out. Line 2. Hash, include,
left angle bracket, c math, right angle bracket, tab space, forward
slash, forward slash, Access power function. Line 3. Hash, include,
left angle bracket, i o manip, right angle bracket, forward slash,
forward slash, Access manipulators. Line 4. using, name space, s t
d, semicolon.
Back to Figure
Code block for the Mortgage program. Program code. Line 1. const,
float, LOAN underscore AMOUNT, equals, 50000.00, semicolon, tab
space, forward slash, forward slash, Amount of the loan. Line 2.
const, float, YEARLY underscore INTEREST, equals, 0.0524,
semicolon, forward slash, forward slash, Yearly interest rate. Line 3.
const, i n t, NUMBER underscore OF underscore YEARS, equals, 7,
semicolon, forward slash, forward slash, Number of years.
Back to Figure
Code block for the Mortgage program. Program code. Line 1. i n t,
main, left parenthesis, right parenthesis. Line 2. Left brace. Line 3,
indented once. Forward slash, forward slash, Local variables. Line 4.
float, monthly Interest, semicolon, forward slash, forward slash,
Monthly interest rate. Line 5. i n t, number Of Payments, semicolon,
tab space, forward slash, forward slash, Total number of payments.
Line 6. float, payment, semicolon, forward slash, forward slash,
Monthly payment.
Back to Figure
Code block for the Mortgage program. Program code. Line 1.
Forward slash, forward slash, Calculate values. Line 2. monthly

Interest, equals, YEARLY underscore INTEREST, forward slash, 12,
semicolon. Line 3. number Of Payments, equals, NUMBER
underscore OF underscore YEARS, asterisk, 12, semicolon. Line 4.
payment, equals, left parenthesis, LOAN underscore AMOUNT,
asterisk, pow, left parenthesis, 1, plus, monthly Interest, comma.
Line 5, indented once. number Of Payments, right parenthesis,
asterisk, monthly Interest, right parenthesis, forward slash. Line 6,
indented once. Left parenthesis, pow, left parenthesis, 1, plus,
monthly Interest, comma, number Of Payments, right parenthesis,
minus 1, right parenthesis, semicolon.
Back to Figure
Code block for the Mortgage program. Line 1. Forward slash,
forward slash, Output results. Line 2. c out, double left angle
bracket, fixed, double left angle bracket, set precision, left
parenthesis, 2, right parenthesis, double left angle bracket, open
quotes, For a loan amount of, space, close quotes. Line 3. Indented
once. Double left angle bracket, LOAN underscore AMOUNT, double
left angle bracket, open quotes, space, with an interest rate of,
space, close quotes. Line 4, indented once. Double left angle
brackets, YEARLY underscore INTEREST, double left angle bracket,
open quotes, space, and a, space, close quotes, double left angle
bracket, NUMBER underscore OF underscore YEARS. Line 5,
indented once, open quotes, space, year mortgage, comma, space,
close quotes, double left angle bracket, end l, semicolon. Line 6. c
out, double left angle bracket, open quotes, space, your monthly
payments are dollar, close quotes, double left angle bracket,
payment. Line 7, indented once. open quotes, dot, close quotes,
double left angle bracket, end l, semicolon.
Back to Figure
A listing of the revised mortgage program with the changes
highlighted. Line 1. Forward slash, forward slash, A line of asterisks.
Line 2. Forward slash, forward slash, Mortgage Payment Calculator
program. Line 3. Forward slash, forward slash, This program
determines the monthly payments on a mortgage. Line 4. Forward
slash, forward slash, given the loan amount, the yearly interest rate,

and the. Line 5. Forward slash, forward slash, number of years. Line
6. Forward slash, forward slash, A line of asterisks. Line 7. Hash,
include, left angle bracket, f stream, right angle bracket. Note. Line 7
is highlighted. Line 8. Hash, include, left angle bracket, c math, right
angle bracket. Line 9. Hash, include, left angle bracket, i o manip,
right angle bracket. Line 10. using, name space, s t d, semicolon.
Line 11. i n t, main, left parenthesis, right parenthesis. Line 12. Left
brace. Line 13, indented once. Forward slash, forward slash, Input
variables. Line 14, indented once. float, loan Amount, semicolon.
Line 15, indented once. float, yearly Interest, semicolon. Line 16,
indented once. i n t, number Of Years, semicolon. Line 17, indented
once. o f stream, out Data, semicolon. Line 18, indented once. i f
stream, in Data, semicolon. Note. Lines 17 and 18 are highlighted.
Line 19, indented once, forward slash, forward slash, Local
variables. Line 20, indented once. float, monthly Interest, semicolon.
Line 21, indented once: i n t, number Of Payments, semicolon. Line
22, indented once. float, payment, semicolon. Line 23, indented
once. forward slash, forward slash, Open files. Line 24, indented
once. in Data, dot, open, left parenthesis, open quotes, loan, dot, in,
close quotes, right parenthesis, semicolon. Line 25, indented once.
out Data, dot, open, left parenthesis, open quotes, loan, dot, out,
close quotes, right parenthesis, semicolon. Note. Lines 23 to 25 are
highlighted. Line 26, indented once. Forward slash, forward slash,
Read values. Line 27, indented once: in Data, double right angle
bracket, loan Amount, double right angle bracket, yearly Interest,
double right angle bracket, number Of Years, semicolon. Note. Line
27 is highlighted. Line 28, indented once. Forward slash, forward
slash, Calculate values. Line 29, indented once. monthly Interest,
equals, yearly Interest, forward slash, 12, semicolon. Line 30,
indented once. number Of Payments, equals, number Of Years,
asterisk, 12, semicolon. Line 31, indented once: payment, equals,
left parenthesis, loan Amount, asterisk, pow, left parenthesis, 1,
plus, monthly Interest, comma, number Of Payments, right
parenthesis. Line 32, ,indented twice: asterisk, monthly Interest,
right parenthesis, forward slash. Line 33, indented twice. Left
parenthesis, pow, left parenthesis, 1, plus, monthly Interest, comma,
number Of Payments, right parenthesis, minus, 1, right parenthesis,
semicolon. Line 34, indented once. Forward slash, forward slash,
Output results. Line 35, indented once. out Data, double left angle

bracket, fixed, double left angle bracket, open quotes, Loan amount,
colon, space, close quotes, double left angle bracket, set precision,
left parenthesis, 2, right parenthesis. Line 36, indented twice. Double
left angle bracket, loan Amount, double left angle bracket, end l,
double left angle bracket, open quotes, Interest rate, colon, space,
close quotes. Line 37, indented twice. Double left angle bracket, set
precision, left parenthesis, 4, right parenthesis, double left angle
bracket, yearly Interest, double left angle bracket, end l. Line 38,
indented twice. Double left angle bracket, open quotes, Number of
years, colon, space, close quotes, double left angle bracket, number
Of Years, double left angle bracket, end l, semicolon. Line 39,
indented once. out Data, double left angle bracket, fixed. Line 40,
indented twice: Double left angle bracket, open quotes, Monthly
payment, colon, space, close quotes, double left angle bracket, set
precision, left parenthesis, 2, right parenthesis, double left angle
bracket, payment, left double angle bracket, end l, semicolon. Lines
35 to 40 are highlighted. Line 41, indented once. Forward slash,
forward slash, Close files. Line 42, indented once. in Data, dot,
close, left parenthesis, right parenthesis, semicolon. Line 43,
indented once. out Data, dot, close, left parenthesis, right
parenthesis, semicolon. Note. Lines 41 to 43 are highlighted. Line
44, indented once. return, 0, semicolon. Line 45. Right brace.
Back to Figure
The contents of the loan dot in file. Line 1. 50000.00 0.0524 7.
Back to Figure
The contents of the loan dot out file. Line 1. Loan amount:
50000.00. Line 2. Interest rate: 0.0524. Line 3. Number of years: 7.
Line 4. Monthly payment: 712.35.
Back to Figure
Code for opening a file for input. Program code. Line 1. i f stream, in
File, semicolon. Line 2. in File, dot, open, left parenthesis, open
quotes, data file, dot, dat, close quotes, right parenthesis,
semicolon.

Back to Figure
Code that accepts the name of the file to open as input from the
user which raises a compile time error. Program code. Line 1. i f
stream, in File, semicolon. Line 2. string, file Name, semicolon. Line
3. c out, double left angle bracket, open quotes, Enter the input file
name, colon, space, close quotes, semicolon. Line 4. c in, double
right angle bracket, file Name, semicolon. Line 5. in File, dot, open,
left parenthesis, file Name, right parenthesis, semicolon, tab space,
forward slash, forward slash, Compile-time error.
Back to Figure
Code for converting a string variable's value to a C string. Program
code. Line 1. file Name, dot, c underscore s t r, left parenthesis,
right parenthesis.
Back to Figure
A program that reads in a file name and outputs the first line in the
file. Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, This program
demonstrates inputting file names. Line 3. Forward slash, forward
slash, a line of asterisks. Line 4. Hash, include, left angle bracket, f
stream, right angle bracket. Line 5. Hash, include, left angle bracket,
i o stream, right angle bracket. Line 6. Hash, include, left angle
bracket, string, right angle bracket. Line 7. using, name space, s t d,
semicolon. Line 8. i n t, main, left parenthesis, right parenthesis.
Line 9. Left brace. Line 10, indented once. i f stream, in File,
semicolon. Line 11, indented once. string, file Name, semicolon. Line
12, indented once. string, input String, semicolon. Line 13, indented
once. c out, double left angle bracket, open quotes, Enter the input
file name, colon, space, close quotes, semicolon. line 14, indented
once. c in, double right angle bracket, file Name, semicolon. Line 15,
indented once. in File, dot, open, left parenthesis, file Name, dot, c
underscore s t r, left parenthesis, right parenthesis, right
parenthesis, semicolon. Line 16, indented once. get line, left
parenthesis, in File, comma, input String, right parenthesis,
semicolon. Line 17, indented once. c out, double left angle bracket,

open quotes, First line of file, colon, space, close quotes, double left
angle bracket, input String, double left angle bracket, end l,
semicolon. Line 18. return, 0, semicolon. Line 19. Right brace.
Back to Figure
The contents of the file test Data dot in. Line 1. Oh what a beautiful
day! Line 2. Rest of the data. Line 3. on the file.
Back to Figure
The output of the program that demonstrates inputting file names.
The program prompts the user by printing the following line. Enter
the input file name, colon. The user responds by entering the file
name, test Data dot in. The program then prints the following line.
First line of file: Oh what a beautiful day!
Back to Figure
The reader has to find the error in the program. Program code. Line
1. string, file name, equals, open quotes, data, dot, t x t, close
quotes, semicolon. Line 2. i f stream, in File, semicolon. Line 3. in
File, dot, open, left parenthesis, file name, right parenthesis,
semicolon.
Back to Figure
Some variables that are printed. Program code. Line 1. c in, double
right angle bracket, i, double right angle bracket, j, double right angle
bracket, k, semicolon. Line 2. c out, double left angle bracket, open
quotes, i, colon, space, close quotes, double left angle bracket, i,
double left angle bracket, open quotes, j, colon, space, close quotes,
double left angle bracket, j, double left angle bracket, open quotes,
k, colon, space, close quotes, double left angle bracket, k,
semicolon.
Back to Figure
Three values that are entered as input. 1234.56 7 89

Back to Figure
The values that are entered are the following. 1234.56 7 89. The
reading marker is on the decimal point.
Back to Figure
Code listing for a program. Program code. Line 1. i f stream, in File,
semicolon. Line 2. in File, dot, open, left parenthesis, open quotes,
my f I l dot dat, close quotes, right parenthesis, semicolon. Line 3. in
File, double right angle bracket, i, double right angle bracket, j,
double right angle bracket, k, semicolon.
Back to Figure
A hierarchical solution tree. The diagram shows a flow diagram from
top to bottom. The flow diagram is abstract at the top and concrete
at the bottom. The flow diagram has 4 levels. Level 0, level 1, level
2, and level 3. At level 0 is the following step. Solve the problem.
Step 1, Step 2, and Step 3. At level 1, the flow diagram has the
following steps. Subproblem 1 with Step A and Step b. Subproblem
2 with Step C and Step D. Subproblem 3 with Step E and Step F. At
level 2, Subproblem 1 splits into Subproblem A with Step 1 and
Subproblem B with Step 2 and Step 3. At level 2, Subproblem 2
flows into Subproblem C with Step 4, Step 5, and Step 6. At level 2,
Subproblem 3 flows into Subproblem F with step 7 and Step 8. At
level 3, Subproblem B flows into Subproblem 2 with Step a, Step b,
and Step c.
Back to Figure
The solution tree for the mortgage program. The tree has the
following steps. The first step has the following processes. Open
Files. Input Values. Calculate Values. Output Results. Close Files.
The first step has the following sub steps. Open Files. Input Values.
Calculate Values. Output Results. Close Files. The step Open Files
has the following sub steps. Open in Data. Open out Data. The step
Input Values has the following sub steps. Input loan Amount, yearly
Interest, and number Of Year. The step Calculate Values has the

following calculations. monthly Interest, equals, yearly Interest / 2,
semicolon. number Of Payments, equals, number Of Years,
asterisk, 12, semicolon. payment, equals, loan Amount, and so on.
The step Output Results has the following sub steps. Print input
values and Print results. The step Close Files has the following sub
steps. Close in Data. Close out Data.
Back to Figure
Steps in the mortgage program. Line 1. Open in Data. Line 2. Open
out Data. Line 3. Input loan Amount, yearly Interest, number Of
Years. Line 4. Set monthly Interest to yearly Interest divided by 12.
Line 5. Set number Of Payments to number Of Years times 12. Line
6. Set payment to left parenthesis, loan Amount, asterisk, pow, left
parenthesis, 1 plus monthly Interest, number Of Payments, right
parenthesis. Line 7. Asterisk monthly Interest, right parenthesis,
forward slash, left parenthesis, pow, left parenthesis, 1, plus,
monthly Interest, number Of Payments, right parenthesis, minus 1,
right parenthesis. Line 8. Print, open quotes, For a loan amount of,
close quotes, loan Amount, open quotes, with an interest rate of,
close quotes. Line 9. yearly Interest, open quotes, and a, close
quotes, number Of Years, open quotes, year mortgage comma,
close quotes. Line 10. Print, open quotes, your monthly payments
are dollar, close quotes, payment, open quotes, period, close
quotes. Line 11. Close in Data.
Back to Figure
The mortgage program as a series of modules grouped by two
levels of abstraction. Heading: Main. Level 0. Line 1. Open Files.
Line 2. Input Values. Line 3. Calculate Values. Line 4. Output
Results. Line 5. Close Files. Heading: Open Files. Level 1. Line 6.
Open in Data. Line 7. Open out Data. Heading: Input Values. Line 8.
Input loan Amount. Line 9. Input yearly Interest. Line 10. Input
number Of years. Heading: Calculate Values. Line 11. Set monthly
Interest to yearly Interest divided by 12. Line 12. Set number Of
Payments to number Of Years times 12. Line 13. Set payment to left
parenthesis, loan Amount, asterisk, pow, left parenthesis, 1 plus
monthly Interest, comma, number Of Payments, right parenthesis.

Line 14. asterisk, monthly Interest, right parenthesis, forward slash,
left parenthesis, pow, left parenthesis, 1 plus monthly Interest,
comma, number Of Payments, right parenthesis, minus 1, right
parenthesis. Heading: Output. Line 15. Print, open quotes, Loan
amount, colon, close quotes, loan Amount. Line 16. Print, open
quotes, Interest rate, colon, close quotes, yearly Interest. Line 17.
Print, open quotes, Number of years, colon, close quotes, number
Of Years. Line 18. Print, open quotes, Monthly payment, colon,
close quotes, payment. Heading: Close Files. Line 19. Close in Data.
Line 20. Close out Data.
Back to Figure
A semi hierarchical module structure chart with a shared module.
The chart shows several steps with sub steps of which some of the
sub steps calculate cylinder volume. Cylinder volume is calculated as
set volume equals pi r squared h.
Back to Figure
A module structure chart. The file in Data after opening is depicted
with the file containing a reading marker. The file out Data after
opening is depicted with the file containing a writing marker.
Back to Figure
A program that displays a name in multiple formats. Program code.
Line 1. Forward slash, forward slash, a line of asterisks. Line 2.
Forward slash, forward slash, Format Names program. Line 3.
Forward slash, forward slash, This program reads in a Social
Security number, a first name, a. Line 4. Forward slash, forward
slash, middle name or initial, and a last name from file in Data. Line
5. Forward slash, forward slash, The name is written to file out Data
in four formats, colon. Line 6. Forward slash, forward slash, 1. First
name, middle name, last name, and Social Security number. Line 7.
Forward slash, forward slash, 2. Last name, first name, middle
name, and Social Security number. Line 8. 3. Last name, first name,
middle initial, and Social Security number. Line 9. 4. First name,
middle initial, last name. Line 10. Forward slash, forward slash, a

line of asterisks. Line 11. Hash, include, left angle bracket, f stream,
right angle bracket, tab spaces, forward slash, forward slash,
Access o f stream. Line 12. Hash, include, left angle bracket, string,
right angle bracket, forward slash, forward slash, Access string. Line
13. using, name space, s t d, semicolon. Line 14. i n t, main, left
parenthesis, right parenthesis. Line 15. Left brace. Line 16, indented
once. Forward slash, forward slash, Declare and open files. Line 17,
indented once. i f stream, in Data, semicolon. Line 18. o f stream,
out Data, semicolon. Line 19, indented once. in Data, dot, open, left
parenthesis, open quotes, name dot in, close quotes, right
parenthesis, semicolon. Line 20, indented once. out Data dot open,
left parenthesis, open quotes, name dot out, close quotes, right
parenthesis, semicolon. Line 21, indented once. Forward slash,
forward slash, Declare variables. Line 22, indented once. string,
social Num, semicolon, tab spaces, forward slash, forward slash,
Social Security number. Line 23, indented once. string, first Name,
semicolon, tab spaces, forward slash, forward slash, First name.
Line 24, indented once. string, last Name, semicolon, forward slash,
forward slash, Last name. Line 25, indented once. string, middle
Name, semicolon, tab spaces, forward slash, forward slash, Middle
name. Line 26, indented once. char, initial, semicolon, tab space,
forward slash, forward slash, Middle initial. Line 27. Forward slash,
forward slash, Read in data from file in Data. Line 28, indented
once. in Data, double right angle bracket, social Num, double right
angle bracket, first Name, double right angle bracket, middle Name,
double right angle bracket, last Name, semicolon. Line 29, indented
once, forward slash, forward slash, Access middle initial and append
a period. Line 30, indented once. initial, equals, middle Name dot at,
left parenthesis, 0, right parenthesis, semicolon. Line 31, indented
once. Forward slash, forward slash, Output information in required
formats. Line 32, indented once. out Data, double left angle bracket,
first Name, double left angle bracket, open single quotes, space,
close single quotes, double left angle bracket, middle Name, double
left angle bracket, open single quotes, space, close single quotes,
double left angle bracket, last Name. Line 33, indented twice. Double
left angle bracket, open single quotes, space, close single quotes,
double left angle bracket, social Num, double left angle bracket, end
l, semicolon. Line 34, indented once. out Data, double left angle
bracket, last Name, double left angle bracket, open quotes, comma,

space, close quotes, double left angle bracket, first Name, double
left angle bracket, open single quotes, space, close single quotes,
double left angle bracket, middle Name. Line 35, indented twice.
Double left angle bracket, open single quotes, space, close single
quotes, double left angle bracket, social Num, double left angle
bracket, end l, semicolon. Line 36, indented once. out Data, double
left angle bracket, last Name, double left angle bracket, open
quotes, comma, space, close quotes, double left angle bracket, first
Name, double left angle bracket, open single quotes, space, close
single quotes, double left angle bracket, initial. Line 37, indented
twice. Double left angle bracket, open quotes, period, space, close
quotes, double left angle bracket, social Num, double left angle
bracket, end l, semicolon. Line 38, indented once. out Data, double
left angle bracket, first Name, double left angle bracket, open single
quotes, space, close single quotes, double left angle bracket, initial,
double left angle bracket, open quotes, period, space, close quotes,
double left angle bracket, last Name, semicolon. Line 39, indented
once. Forward slash, forward slash, Close files. Line 40, indented
once. in Data dot close, left parenthesis, right parenthesis,
semicolon. Line 41, indented once. out Data dot close, left
parenthesis, right parenthesis, semicolon. Line 42, indented once.
return, 0, semicolon. Line 43. Right brace.
Back to Figure
The contents of the input file is the following one line. 333-55-3456
Clara Jones Jacobey.
Back to Figure
The output of the program that displays a name in multiple formats
is the following. Line 1. Clara Jones Jacobey 333-55-3456. Line 2.
Jacobey, Clara Jones 333-55-3456. Line 3. Jacobey, Clara J. 333-
55-3456. Line 4. Clara J. Jacobey
Back to Figure
"Code for entering a file name. Program code. Line 1. string, file
Name, semicolon. Line 2. string, input String, semicolon. Line 3. c

out, double left angle bracket, open quotes, Enter the input file
name, colon, space, close quotes, semicolon. Line 4. c in, double
right angle bracket, file Name, semicolon. Line 5. in File, dot, open,
left parenthesis, file Name, dot, c underscore s t r, left parenthesis,
right parenthesis, right parenthesis, semicolon."
Back to Figure
The include statement for accessing the Q t dialog library. Program
code. Line 1. Hash, include, open quotes, dialog dot h, close quotes,
forward slash, forward slash, Access GUI components.
Back to Figure
Code for creating a dialog to get the name of the output file.
Program code. Line 1. Forward slash, forward slash, Create the
dialog to get the name of the output file. Line 2. Text Dialog, get
Output Name, left parenthesis, open quotes, Enter Output File,
close quotes, right parenthesis, semicolon.
Back to Figure
Code for calling the display function for the dialog object. Program
code. Line 1. Forward slash, forward slash Ask user for the name of
the output file. Line 2. string, output File, equals, get Output Name
dot display, left parenthesis, right parenthesis, semicolon.
Back to Figure
The dialog box that is displayed for getting the file name of the
output file from the user. The dialog box has the text"Text Dialog"
displayed in the title bar. The label"S S N Output File" is displayed in
the dialog box along with a text field for user entry. There is a Cancel
and O K button below the text field.
Back to Figure
"Code for a File Dialog. Program code. Line 1. Forward slash,
forward slash, Create the dialog to get the name of the input file.
Line 2. File Dialog, get Input Name, left parenthesis, open quotes,

Select Input File, close quotes, right parenthesis, semicolon. Line 3.
Forward slash, forward slash, Ask user for the name of the input file.
Line 4. string, input File Path, equals, get Input Name dot display,
left parenthesis, right parenthesis, semicolon."
Back to Figure
The File dialog box that is displayed when the previous code is
executed.. Instead of providing a text entry field, the user is given a
view of the file system from which a file can be chosen.
Back to Figure
Code for a Directory Dialog. Program code. Line 1. Forward slash,
forward slash, Create the dialog to get the output directory. Line 2.
Directory Dialog, get Output Directory, left parenthesis, open quotes,
Enter Output Directory, close quotes, right parenthesis, semicolon.
Line 3. Forward slash, forward slash, Ask user for the name of the
output directory. Line 4. string, output Directory, equals, get Output
Directory dot display, left parenthesis, right parenthesis, semicolon.
Back to Figure
The path Append function. Program code. Line 1. Forward slash,
forward slash, Append the output file to the output directory. Line 2.
string, output File Path, equals, path Append, left parenthesis,
output Directory, comma, output File, right parenthesis, semicolon.
Back to Figure
Code for an Output Dialog. Program code. Line 1. Forward slash,
forward slash, Echo-display the directory and name for the user.
Line 2. Output Dialog, output, left parenthesis, output File Path, right
parenthesis, semicolon. Line 3. output dot display, left parenthesis,
right parenthesis, semicolon.
Back to Figure
A program that formats and prints out names. Program code. Line
1. Forward slash, forward slash, a line of asterisks. Line 2. Forward

slash, forward slash, Format Names program. Line 3. Forward
slash, forward slash, This program reads in a Social Security
number, a first name, a. Line 4. Forward slash, forward slash,
middle name or initial, and a last name from file in Data. Line 5.
Forward slash, forward slash, The name is written to file out Data in
four formats: Line 6. Forward slash, forward slash, 1. First name,
middle name, last name, and Social Security number. Line 7.
Forward slash, forward slash, 2. Last name, first name, middle
name, and Social Security number. Line 8. Forward slash, forward
slash, 3. Last name, first name, middle initial, and Social Security
number. Line 9. Forward slash, forward slash, 4. First name, middle
initial, last name. Line 10. Forward slash, forward slash, a line of
asterisks. Line 11. Hash, include, left angle bracket, f stream, right
angle bracket, tab space, forward slash, forward slash, Access o f
stream. Line 12. Forward slash, forward slash, hash, include, left
angle bracket, string, right angle bracket, tab space, forward slash,
forward slash, Access string. Line 13. Hash, include, open quotes,
dialog, dot, h, close quotes, tab space, forward slash, forward slash,
Access G U I components. Line 14. Hash, include, open quotes,
utils, dot, h, close quotes, tab space, forward slash, forward slash,
Access utility routines. Line 15. using, name space, s t d, semicolon.
line 16. i n t, main, left parenthesis, right parenthesis. Left brace.
Line 17, indented once. Forward slash, forward slash, Create the
dialog to get the name of the input file. Line 18, indented once. File
Dialog, get Input Name, left parenthesis, open quotes, Enter Input
File, close quotes, right parenthesis, semicolon. Line 19, indented
once. forward slash, forward slash, Create the dialog to get the
name of the output file. Line 20, indented once. Text Dialog, get
Output Name, left parenthesis, open quotes, Enter Output File,
close quotes, right parenthesis, semicolon. Line 21, indented once.
Forward slash, forward slash, Create the dialog to get the output
directory. Line 22, indented once. Directory Dialog, get Output
Directory, left parenthesis, open quotes, Enter Output Directory,
close quotes, right parenthesis, semicolon. Line 23, indented once.
forward slash, forward slash, Ask user for the name of the input file.
Line 24, indented once. string, input File Path, equals, get Input
Name, dot, display, left parenthesis, right parenthesis, semicolon.
Line 25, indented once. forward slash, forward slash, Ask user for
the name of the output file. Line 26, indented once. string, output

File, equals, get Output Name, dot, display, left parenthesis, right
parenthesis, semicolon. Line 27, indented once. Forward slash,
forward slash, Ask user for the name of the output directory. Line
28, indented once. string, output Directory, equals, get Output
Directory, dot, display, left parenthesis, right parenthesis, semicolon.
Line 29, indented once. forward slash, forward slash, Append the
output file to the output directory. Line 30, indented once. string,
output File Path, equals, path Append, left parenthesis, output
Directory, comma, output File, right parenthesis, semicolon. Line 31,
indented once. Forward slash, forward slash, Echo-display the
directory and name for the user. Line 32, indented once. Output
Dialog, output, left parenthesis, output File Path, right parenthesis,
semicolon. Line 33, indented once. output, dot, display, left
parenthesis, right parenthesis, semicolon. Line 34, indented once.
forward slash, forward slash, Declare and open files. Line 35,
indented once. i f stream, in Data, semicolon. Line 36, indented
once. o f stream, out Data, semicolon. Line 37, indented once. in
Data, dot, open, left parenthesis, input File Path, right parenthesis,
semicolon. Line 38, indented once. out Data, dot, open, left
parenthesis, output File Path, right parenthesis, semicolon. Line 39,
indented once. forward slash, forward slash, Declare variables. Line
40, indented once. string, social Num, semicolon, forward slash,
forward slash, Social Security number. Line 41, indented once.
string, first Name, semicolon, forward slash, forward slash, First
name. Line 42, indented once. string, last Name, semicolon, forward
slash, forward slash, Last name. Line 43, indented once. string,
middle Name, semicolon, forward slash, forward slash, Middle
name. Line 44, indented once. char, initial, semicolon, forward slash,
forward slash, Middle initial. Line 45, indented once. forward slash,
forward slash, Read in data from file in Data. Line 46, indented
once. in Data, double right angle bracket, social Num, double right
angle bracket, first Name, double right angle bracket, middle Name,
double right angle bracket, last Name, semicolon. Line 47, indented
once. forward slash, forward slash, Access middle initial and append
a period. Line 48, indented once. initial, equals, middle Name, dot,
at, left parenthesis, 0, right parenthesis, semicolon. Line 49,
indented once. forward slash, forward slash, Output information in
required formats. Line 50, indented once. out Data, double left angle
bracket, first Name, double left angle bracket, open single quotes,

space, close single quotes, double left angle bracket, middle Name,
double left angle bracket, open single quotes, space, close single
quotes, double left angle bracket, last Name, double left angle
bracket, open single quotes, space, close single quotes. Line 51,
indented a few times. Double left angle bracket, social Num, double
left angle bracket, end l, semicolon. Line 52, indented once. out
Data, double left angle bracket, last Name, double left angle bracket,
open quotes, comma, space, close quotes, double left angle
bracket, first Name, double left angle bracket, open single quotes,
space, close single quotes, double left angle bracket, middle Name,
double left angel bracket, open single quotes, space, close single
quotes. Line 53, indented a few times. double left angle bracket,
social Num, double left angle bracket, end l, semicolon. Line 54,
indented once. out Data, double left angle bracket, last Name,
double left angle bracket, open quotes, comma, space, close
quotes, double left angle bracket, first Name, double left angle
bracket, open single quotes, space, close single quotes, double left
angle bracket, initial, double left angle bracket, open quotes, period,
space, close quotes. Line 55, indented a few times. double left angle
bracket, social Num, double left angle bracket, end l, semicolon.
Line 56, indented once. out Data, double left angle bracket, first
Name, double left angle bracket, open single quotes, space, close
single quotes, double left angle bracket, initial, double left angle
bracket, open quotes, period, space, close quotes, double left angle
bracket, last Name, semicolon. Line 57, indented once. Forward
slash, forward slash, Close files. Line 58, indented once. in Data,
dot, close, left parenthesis, right parenthesis, semicolon. Line 59,
indented once. out Data, dot, close, left parenthesis, right
parenthesis, semicolon. Line 60, indented once. return, 0,
semicolon. Line 61. Right brace.
Back to Figure
Program code. Forward slash, forward slash, Ask user for the name
of the input file. Line 2. string, input File Path, equals, get Input
Name, dot, display, left parenthesis, right parenthesis, semicolon.
Line 3. quit With Empty String, left parenthesis, input File, right
parenthesis, semicolon. Line 4. Forward slash, forward slash, Ask
user for the name of the output file. Line 5. string, output File,

equals, get Output Name, dot, display, left parenthesis, right
parenthesis, semicolon. Line 6. quit With Empty String, left
parenthesis, output File, right parenthesis, semicolon. Line 7.
Forward slash, forward slash, Ask user for the name of the output
directory. Line 8. string, output Directory, equals, get Output
Directory, dot, display, left parenthesis, right parenthesis, semicolon.
Line 9. quit With Empty String, left parenthesis, output Directory,
right parenthesis, semicolon.
Back to Figure
The data in a file are the following. 2516 42.
Back to Figure
Program code. Line 1. in File, double right angle bracket, i, double
right angle bracket, j, double right angle bracket, k, semicolon.
Back to Figure
An output statement. Program code. Line 1. c out, double left angle
bracket, n, semicolon.
Back to Figure
An input statement. Program code. Line 1. c in, double right angle
bracket, n, semicolon.
Back to Figure
The answer for question 4.1.2. Program code. Line 1. first, equals,
open quotes, Jones, comma, close quotes. Line 2. middle, equals,
open quotes, Walker, close quotes. Line 3. last, equals, open
quotes, Thomas, close quotes.
Back to Figure
First set of code in exercise 4.1. Program code. Line 1. c in, double
right angle bracket, maximum, double right angle bracket, minimum,
semicolon.

Back to Figure
Second set of code in exam preparation exercise 4.1. Program
code. Line 1. c in, double right angle bracket, minimum, semicolon.
Line 2. c in, double right angle bracket, maximum, semicolon.
Back to Figure
The input data that is entered in exam preparation exercise 4.3. Line
1. 10 20. Line 2. 30 40. Line 3. 50 60. Line 4. 70 80.
Back to Figure
The input statements that read input data in exam preparation
exercise 4.3. Program code. Line 1. c in, double right angle bracket,
a, double right angle bracket, b, double right angle bracket, c,
semicolon. Line 2. c in, double right angle bracket, d, double right
angle bracket, e, double right angle bracket, f, semicolon. Line 3. c
in, double right angle bracket, a, double right angle bracket, b,
semicolon.
Back to Figure
Input data that is entered in exam preparation exam preparation
exercise 4.4. Line 1. 10 20 30 40 50 60. Line 2. 10 20 30 40 50 60.
Line 3. 10 20 30 40 50 60. Line 4. 70 80.
Back to Figure
The input statements that read input data in exam preparation
exercise 4.4. Program code. Line 1. c in, double right angle bracket,
a, double right angle bracket, b, double right angle bracket, c,
semicolon. Line 2. c in, dot, ignore, left parenthesis, 100, comma,
open single quotes, backslash, n, close single quotes, right
parenthesis, semicolon. Line 3. c in, dot, get, left parenthesis, c h 1,
right parenthesis, semicolon. Line 4. c in, double right angle bracket,
d, double right angle bracket, e, double right angle bracket, f,
semicolon. Line 5. c in, dot, ignore, left parenthesis, 100, comma,
open single quotes, backslash, n, close single quotes, right
parenthesis, semicolon. Line 6. c in, dot, ignore, left parenthesis,

100, comma, open single quotes, backslash, n, close single quotes,
right parenthesis, semicolon. Line 7. c in, double right angle bracket,
a, double right angle bracket, b, semicolon.
Back to Figure
The input data in exam preparation exercise 4.5 is the following.
January 25s, 2005.
Back to Figure
The input statement in exam preparation exercise 4.5 is the
following. Program code. Line 1. c in, double right angle bracket,
string 1, double right angle bracket, string 2, semicolon.
Back to Figure
The input data in exam preparation exercise 4.6 is the following.
January 25, 2005.
Back to Figure
The input statement in exam preparation exercise 4.6 is the
following. Program code. Line 1. get line, left parenthesis, c in,
comma, string 1, right parenthesis, semicolon.
Back to Figure
The input data in exam preparation exercise 4.7 is the following.
January 25, 2005.
Back to Figure
The input statement in exam preparation exercise 4.7 is the
following. c in, double right angle bracket, string 1, double right angle
bracket, i n t 1, double right angle bracket, char 1, double right angle
bracket, string 2, semicolon.
Back to Figure

The program code in exam preparation exercise 4.13 is the
following. Program code. Line 1. i f stream, in File, semicolon. Line
2. in File, dot, open, left parenthesis, open quotes, data file dot dat,
close quotes, right parenthesis, semicolon.
Back to Figure
Program code in exam preparation exercise 4.14. Program code.
Line 1. i f stream, in Data, semicolon. Line 2. string, name,
semicolon. Line 2. c out, double left angle bracket, open quotes,
Enter the name of the file, colon, space, close quotes, right
parenthesis, semicolon. Line 3. c in, double right angle bracket,
name, semicolon. Line 4. in file, dot, open, left parenthesis, name,
right parenthesis, semicolon.
Back to Figure
Program code in programming warm-up exercise 4.7. Program
code. Line 1. street Num, comma, street 1, comma, street 2,
comma, town, comma, state, comma, and zip. Line 2. 782 Maple
Avenue. Line 3. Blithe, comma, C O 56103.
Back to Figure
Code with blanks in programming warm-up exercise 4.10. Program
code. Line 1.
Back to Figure
The contents in a file in programming problem 4.2. Line 1. a b c d e
f.
Back to Figure
The format in which a name has to be input in programming problem
4.3. last, comma, first middle.
Back to Figure

The output in which the name has to be output in programming
problem 4.3. first middle last.
Back to Figure
The input data for programming problem 4.4. 34.5 38.6 42.4 46.8
51.3 63.1 60.2 55.9 60.3 56.7 50.3 42.2.
Back to Figure
The contents in the file temp data dot dat in programming problem
4.4. Line 1. 34. 5. Line 2. 38. 6. 4.1. Line 3. 42.4 3.8. Line 4. 46.8
4.4. Line 5. 51.3 4.5 Line 6. 63.1 11.8. Line 7. 60.2 minus 2.9. Line
8. 55.9 minus 4.3. Line 9. 60.3 4.4. Line 10. 56.7 minus 3.6. Line 11.
50.3 minus 6.4. Line 12. 42.2 minus 8.1.
Back to Figure
The formula for standard deviation in programming problem 4.5. S
equals square root of Sigma n comma I equals 1 of x_1 minus x bar
the whole squared divided by n minus 1.
Back to Figure
The output of programming problem 4.6. Line 1. and. Line 2. if. Line
3. then.
Back to Figure
The formula to be used in programming problem 4.7. S equals 2 R
squared theta.
Back to Figure
An example of how the formula needs to be used in programming
problem 4.7. S equals 2 times 1.738.3 squared times 3.14159
equals 1898581.672 square kilometers.
Back to Figure

Flow of control works when statements are executed one after the
other. Statement 1 executes followed by statements 2, 3, and 4.
Back to Figure
A selection or branching control structure works with a question
which can turn out to be true or false. If true, statement 1 A is
executed. If false, statement 1 B is executed. After one of the
statements is executed based on whether the question is true or
false, the control flow goes back to the main branch.
Back to Figure
A fork in the road is an example of how a selection or branching
control structure works. The computer is made to choose between
alternative actions.
Some variables of the type bool. Program code. Line 1. bool, data O
K, semicolon. Forward slash, forward slash, True if the input data is
valid. Line 2. bool, done, semicolon, forward slash, forward slash,
True if the process is done. Line 3. bool, taxable, semicolon.
Forward slash, forward slash, True if the item has sales tax.
Back to Figure
A bool assignment statement. Program code. Line 1. data OK,
equals, true, semicolon.
Back to Figure
Comparing int variables and assigning the resulting Boolean value to
a Boolean variable. Program code. Line 1. c in, double right angle
bracket, i, double right angle bracket, j, semicolon. Line 2. less
Than, equals, left parenthesis, i, less than, j, right parenthesis,
semicolon, forward slash, forward slash, Compare i and j with the,
open quotes, less than, close quotes. Line 3. Tab space, forward
slash, forward slash, relational operator, comma, and assign the.
Line 4. Tab space, forward slash, forward slash, resulting Boolean
value to less Than.

Back to Figure
Some relational expressions. Program code. Line 1. x is not equal to
y. Line 2. y greater than x. Line 3. x less than y. Line 4. y greater
than or equals x. Line 5. x less than or equals y.
Back to Figure
A relational expression. Program code. Line 1. open single quotes,
uppercase M, close single quotes, less than, open single quotes,
uppercase R, close single quotes.
Back to Figure
A relational expression. Program code. Line 1. open single quotes,
lowercase m, close single quotes, less than, open single quotes,
lowercase r, close single quotes.
Back to Figure
A relational expression. Program code. Line 1. open single quotes,
lowercase m, close single quotes, less than, open single quotes,
uppercase R, close single quotes.
Back to Figure
The use of typecasting. Program code. Line 1. some Float, greater
than or equals, float, left parenthesis, some I n t, right parenthesis.
Back to Figure
An expression with a bool value. Program code. Line 1. bool Var,
less than 5.
Back to Figure
An expression that uses char values. Program code. Line 1. open
single quotes, 0, close single quotes, less than, open single quotes,
9, close single quotes.

Back to Figure
An expression that uses char values. Program code. Line 1. 0, less
than, 9.
Back to Figure
An expression that uses char values. Program code. Line 1. Open
single quotes, 0, close single quotes, less than, 9.
Back to Figure
A table listing examples of how comparison operators evaluate an
expression. The table has 5 rows and 4 columns. The column
headings in the table are the following. Value of x. Value of y.
Expression. Result. The row details are the following. Row 1: Value
of x, 12; Value of y, 2; Expression, x plus 3 less than or equals y
times 10; Result, true. Row 2: Value of x, 20; Value of y, 2;
Expression, x plus 3 less than or equals y times 10; Result, false.
Row 3: Value of x, 7; Value of y, 1; Expression, x plus 3 is not equal
to y times 10; Result, false. Row 4: Value of x, 17; Value of y, 2;
Expression, x plus 3 equals equals y times 10; Result, true. Row 5:
Value of x, 100; Value of y, 5; Expression, x plus 3 greater than y
times 10; Result, true.
Back to Figure
A program that shows the output from comparing five sets of integer
values. Program code. Line 1. Forward slash, forward slash, a line
of asterisk. Line 2. Forward slash, forward slash, This program
compares integer values. Line 3. Forward slash, forward slash, a
line of asterisk. Line 4. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 5. using, name space, s t d, semicolon.
Line 6. i n t, main, left parenthesis, right parenthesis. Line 7. Left
brace. Line 8. c out, double left angle bracket, left parenthesis, 2,
equals, equals, 2, right parenthesis, double left angle bracket, end l,
semicolon. Line 9. c out, double left angle bracket, left parenthesis,
3, equals, equals, 2, right parenthesis, double left angle bracket, end
l, semicolon. Line 10. c out, double left angle bracket, left

parenthesis, minus 3, equals, equals, 2, right parenthesis, double
left angle bracket, end l, semicolon. Line 11. c out, double left angle
bracket, left parenthesis, minus 3, equals, equals, minus 3, right
parenthesis, double left angle bracket, end l, semicolon. Line 12. c
out, double left angle bracket, left parenthesis, minus 3, equals,
equals, minus 2, right parenthesis, double left angle bracket, end l,
semicolon. Line 13. return, 0, semicolon. Line 14. Right brace.
Back to Figure
The output from a test run of the previous program. Line 1. 1. Line
2. 0. Line 3. 0. Line 4. 1. Line 5. 0.
Back to Figure
An expression in which two string variables are compared. Program
code. Line 1. my String, less than, your String.
Back to Figure
A string object and a C string. Program code. Line 1. my String,
equals, open quotes, Johnson, close quotes.
Back to Figure
Some string assignments. Program code. Line 1. string, word 1,
semicolon. Line 2. string, word 2, semicolon. Line 3. word 1, equals,
open quotes, Tremendous, close quotes, semicolon. Line 4. word 2,
equals, open quotes, Small, close quotes, semicolon.
Back to Figure
A comparison statement. Program code. Line 1. word 2, less than,
open quotes, Smaller, close quotes.
Back to Figure
An expression. Program code. Line 1. Left parenthesis, x, plus, 3,
right parenthesis, asterisk, 2, less than or equals, x, asterisk, left
parenthesis, y, minus, 5, right parenthesis.

Back to Figure
The syntax template for the if-then-else construct. If Statement (the
if-Then-Else form). Line 1. If, (Expression). Line 2, indented once.
Statement 1 A. Line 3. else. Line 4, indented once. Statement B.
Back to Figure
Code that uses the if construct. Program code. Line 1. if, left
parenthesis, hours, less than or equals, 40.0, right parenthesis. Line
2, indented once. pay, equals, rate, asterisk, hours, semicolon. Line
3. else. Line 4, indented once. pay, equals, rate, asterisk, left
parenthesis, 40.0, plus, left parenthesis, hours, minus, 40.0, right
parenthesis, asterisk, 1.5, right parenthesis, semicolon. Line 5. c
out, double left angle bracket, pay, semicolon.
Back to Figure
The flow of control in an If-Then-Else construct. The if expression is
evaluated first. If the expression turns out to be true. Statement 1 A
is executed. Then, the flow of control goes to Statement 2 below the
if-Then-Else construct. If the expression turns out to be false, then,
the else part with Statement 1 B is executed. After this, control goes
to Statement 2 which is outside the if-then-else block.
Back to Figure
The flow of control for calculating pay. First, the if expression is
evaluated. It checks if hours is less than or equal to 40. If this
statement evaluates to true, the following statement is executed.
Pay, equals, rate times hours. Then control goes outside the if-then-
else block where the following statement is executed. c out, double
left angle bracket, pay. If the if expression evaluates to false, then
the following statement in the else block is executed. pay, equals,
rate times, left parenthesis, 40, plus, left parenthesis, plus, left
parenthesis, hours, minus, 40, right parenthesis, times, 1.5, right
parenthesis. Then, control goes outside the if-then-else block where
the calculated pay is printed out.
Back to Figure

g
Code that displays a message if the divisor is zero. Program code.
Line 1. if, left parenthesis, divisor, not equal to, 0, right parenthesis.
Line 2, indented once. Result, equals, dividend, forward slash,
divisor, semicolon. Line 3. else. Line 4, indented once. c out, double
left angle bracket, open quotes, Division by zero is not allowed,
period, close quotes, double left angle bracket, end l, semicolon.
Back to Figure
A program that outputs the position of an item. Line 1. Forward
slash, forward slash, a line of asterisks. Line 2. Forward slash,
forward slash, This program demonstrates the string function find.
Line 3. Forward slash, forward slash, with one successful and one
unsuccessful application. Line 4. Forward slash, forward slash, a line
of asterisks. Line 5. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 6. Hash, include, left angle bracket, string,
right angle bracket. Line 7. using, name space, s t d, semicolon.
Line 8. i n t, main, left parenthesis, right parenthesis. Line 9. Left
brace. Line 10, indented once. string, my String, equals, open
quotes, CAT, close quotes, semicolon. Line 11, indented once. i n t,
pos, semicolon. Line 12, indented once. pos, equals, my String, dot,
find, left parenthesis, open single quotes, A, close single quotes,
right parenthesis, semicolon. Line 13, indented once. if, left
parenthesis, pos, equals, equals, string, colon, colon, n pos, right
parenthesis. Line 14, indented twice. c out, double left angle
bracket, open quotes, No, open single quotes, A, close single
quotes, was found, close quotes, double left angle bracket, end l,
semicolon. Line 15, indented once. else. Line 16, indented twice. c
out, double left angle bracket, open quotes, An, open single quotes,
A, close single quotes, was found in position, space, close quotes,
double left angle bracket, pos, double left angle bracket, end l,
semicolon. Line 17, indented once. pos, equals, my String, dot, find,
left parenthesis, open single quotes, B, close single quotes, right
parenthesis, semicolon. Line 18, indented once. if, left parenthesis,
pos, equals, equals, string, colon, colon, n pos, right parenthesis.
Line 19, indented twice. c out, double left angle bracket, open
quotes, No, open single quotes, B, close single quotes, was found,
close quotes, double left angle bracket, end l, semicolon. Line 20,
indented once. else. Line 21, indented twice. c out, double left angle

bracket, open quotes, A, close single quotes, B, close single quotes,
was found in position, space, close quotes, double left angle
bracket, pos, double left angle bracket, end l, semicolon. Line 22,
indented once. return, 0, semicolon. Line 23. Right brace.
Back to Figure
The output of the program that prints the position of an item. Line 1.
An 'A' was found in position 1. Line 2. No 'B' was found.
Back to Figure
A code block. Program code. Line 1. Left brace. Line 2. Ellipsis. Line
3. Right brace.
Back to Figure
A program with a block of statements in it. Program code. Line 1. if,
left parenthesis, divisor, not equal to, 0, right parenthesis. Line 2,
indented once. result, equals, dividend, forward slash, divisor,
semicolon. Line 3. else. Line 4. Left brace. Line 5, indented once. c
out, double left angle bracket, open quotes, Division by zero is not
allowed, period, close quotes, double left angle bracket, end l,
semicolon. Line 5, indented once. result, equals, 9999, semicolon.
Line 6. Right brace.
Back to Figure
Program that divides a number and displays an error message if the
divisor is 0. Program code. Line 1. Forward slash, forward slash, a
line of asterisk. Line 2. Forward slash, forward slash, Division
program. Line 3. Forward slash, forward slash, Dividend and divisor
are prompted for and read. Line 4. Forward slash, forward slash, If
divisor is 0, comma, division is not performed, semicolon. Line 5.
Forward slash, forward slash, otherwise, comma, division is
performed and result is output. Line 6. Forward slash, forward slash,
a line of asterisks. Line 7. Hash, include, left angle bracket, i o
stream, right angle bracket. Line 8. using, name space, s t d,
semicolon. Line 9. i n t, main, left parenthesis, right parenthesis.
Line 10. Left brace. Line 11, indented once. i n t, dividend,

semicolon. Line 12, indented once, i n t, divisor, semicolon. Line 13, i
n t, result, semicolon. Line 14, indented once. c out, double left
angle bracket, open quotes, Enter dividend and divisor, close
quotes, double left angle bracket, end l, semicolon. Line 15,
indented once. c in, double right angle bracket, dividend, double
right angle bracket, divisor, semicolon. Line 16, indented once. if, left
parenthesis, divisor, is not equal to, 0, right parenthesis. Line 17,
indented once. Left brace. Line 18, indented twice. result, equals,
dividend, forward slash, divisor, semicolon. Line 19, indented twice. c
out, double left angle bracket, open quotes, Result is, space, close
quotes, double left angle bracket, result, double left angle bracket,
end l, semicolon. Line 20, indented once. Right brace. Line 21,
indented once. else. Line 22, indented once. Left brace. Line 23,
indented twice. c out, double left angle bracket, open quotes,
Division by zero is not allowed, period, close quotes, double left
angle bracket, end l, semicolon. Line 24, indented twice. result,
equals, 9999, semicolon. Line 25 indented once. Right brace. Line
26, indented once. return, 0, semicolon. Line 27. Right brace.
Back to Figure
The result of the program that succeeds in diving a number. Line 1.
Enter dividend and divisor. Line 2. 200 5. Line 3. Result is 40.
Back to Figure
The result of the program in which division fails. Line 1. Enter
dividend and divisor. Line 2. 200 0. Line 3. Division by zero is not
allowed.
Back to Figure
An if-else block with braces appearing in individual lines. Program
code. Line 1. If, left parenthesis, n, greater than or equals, 2, right
parenthesis. Line 2. Left brace. Line 3, indented once. alpha, equals,
5, semicolon. Line 4, indented once. beta, equals, 8, semicolon. Line
5. Right brace. Line 6. else. Line 7. Left brace. Line 8, indented
once. alpha, equals, 23, semicolon. Line 9, indented once. beta,
equals, 12, semicolon. Line 10. Right brace.

Back to Figure
An if-else block with an alternate style of placing braces. Program
code. Line 1. if, left parenthesis, n, greater than or equals, 2, right
parenthesis, left brace. Line 2, indented once. Alpha, equals, 5,
semicolon. Line 3, indented once. beta, equals, 8, semicolon. Line 4.
Right brace. Line 5. else, left brace. Line 6, indented once. alpha,
equals, 23, semicolon. Line 7, indented once. beta, equals, 12,
semicolon. Line 13. Right brace.
Back to Figure
The if-then construct. Program code. Line 1. if, left parenthesis, a,
less than or equals, b, right parenthesis. Line 2, indented once. c,
equals, 20, semicolon. Line 3. else. Line 4, indented once.
Semicolon.
Back to Figure
Syntax template for the if statement. The if-then form. Line 1. if,
(expression). Line 2. Indented once. Statement.
Back to Figure
Example code for the if-then construct. Program code. Line 1. if, left
parenthesis, age, less than, 18, right parenthesis. Line 2. c out,
double left parenthesis, open quotes, Not an eligible, space, close
quotes, semicolon. Line 3. c out, double left angle bracket, open
quotes, voter, period, close quotes, double left angle bracket, end l,
semicolon.
Back to Figure
Example code for the if-then construct. Program code. Line 1.
result, equals, line 17, minus, line 23, semicolon. Line 2. if, left
parenthesis, result, less than, 0.0, right parenthesis. Line 3. Left
brace. Line 4. c out, double left angle bracket, open quotes, Check
box 24 A, close quotes, double left angle bracket, end l, semicolon.
Line 5. result, equals, 0.0, semicolon. Line 6. Right brace. Line 7.
line 24, equals, result, semicolon.

Back to Figure
Flow of control in an if-then construct. The if expression is evaluated
first. If the expression turns out to true, then statement 1 is
executed. Then, control goes out of the if-then block. If the
expression turns out to be false, control goes out of the if-then block
and statement 2 is executed.
Back to Figure
Incorrect use of the If-then construct without braces. Program code.
Line 1. result, equals, line 17, minus, line 23, semicolon, tab space,
forward slash, forward slash, Incorrect version. Line 2. if, left
parenthesis, result, less than, 0.0, right parenthesis. Line 3, indented
once. c out, double angle bracket, open quotes, Check box 24 A,
close quotes, double left angle bracket, end l, semicolon. Line 4,
indented once. result, equals, 0.0, semicolon. Line 5. line 24, equals,
result, semicolon.
Back to Figure
Incorrect use of the equals equals operator. Program code. Line 1. c
in, double right angle bracket, n, semicolon. Line 2. if, left
parenthesis, n, equals, 3, right parenthesis, forward slash, forward
slash, Wrong. Line 3, indented once. c out, double left angle
bracket, open quotes, n equals 3, close quotes, semicolon. Line 4.
else. Line 5. c out, double left angle bracket, open quotes, open
quotes, n doesn't equal 3, close quotes, semicolon.
Back to Figure
The output of the previous code. Line 1. n equals 3.
Back to Figure
Output of a mortgage program. Line 1. Loan amount: 3000.00. Line
2. Interest rate: 0.0680. Line 3. Number of years: 2. Line 4. Monthly
payment: 134.05.
Back to Figure

Output of a mortgage program. Line 1. Loan amount: 3000.00. Line
2. Interest rate: 6.8000. Line 3. Number of years: 2. Line 4. Monthly
payment: 1700.04.
Back to Figure
An if statement. Program code. Line 1. if, left parenthesis, yearly
Interest, greater than or equals, 0.25, right parenthesis, forward
slash, forward slash, Assume percent entered. Line 2, indented
once. yearly Interest, equals, yearly Interest, forward slash, 100.0,
semicolon.
Back to Figure
The formula for compound interest. (Amount times, (1 plus Monthly
Interest)^ (Number of Payments) times Monthly Interest) / (1 plus
Monthly Interest)^(Number of Payments) minus 1.
Back to Figure
Program that calculates compound interest. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, Mortgage Payment Calculator program. Line 3.
Forward slash, forward slash, This program determines the monthly
payments on a loan given. Line 4. Forward slash, forward slash, the
loan amount, comma, the yearly interest rate, comma, and the
number of. Line 5. Forward slash, forward slash, years. Line 6.
Forward slash, forward slash, a line of asterisks. Line 7. Hash,
include, left angle bracket, c math, right angle bracket. Line 8. Hash,
include, left angle bracket, i o manip, right angle bracket. Line 9.
Hash, include, left angle bracket, i o stream, right angle bracket.
Note. This line is highlighted. Line 10. using, name space, s t d,
semicolon. Line 11. i n t, main, left parenthesis, right parenthesis.
Line 12. Left brace. Line 13, indented once. Forward slash, forward
slash, Input variables. Line 14, indented once. float, loan Amount,
semicolon. Line 15, indented once. float, yearly Interest, semicolon.
Line 16, indented once. i n t, number Of Years, semicolon. Line 17,
indented once. Forward slash, forward slash, Local variables. Line
18, indented once. float, monthly Interest, semicolon. Line 19,

indented once. i n t, number Of Payments, semicolon. Line 20,
indented once. float, payment, semicolon. Line 21, indented once.
Forward slash, forward slash, Prompts. Line 22, indented once. c
out, double left angle bracket, open quotes, Input loan amount,
comma, interest rate, comma, and number of years, period, close
quotes. Line 23, indented twice. Double left angle bracket. end l,
semicolon. Line 24, indented once. c out, double left angle bracket,
open quotes, An interest rate of less than 0.25 is assumed to be,
space, close quotes. Line 25, indented twice. Double left angle
bracket, end l, semicolon. Line 26, indented once. c out, double left
angle bracket, open quotes, a decimal rather than a percent, period,
close quotes, double left angle bracket, end l, semicolon. Line 27,
indented once. Forward slash, forward slash, Read values. Line 28,
indented once. c in, double right angle bracket, loan Amount, double
right angle bracket, yearly Interest, double right angle bracket,
number Of Years, semicolon. Note. Lines 21 to 28 are highlighted.
Line 29, indented once. Forward slash, forward slash, Calculate
values. Line 30, indented once. if, left parenthesis, yearly Interest,
greater than or equals, 0.25, right parenthesis, tab space, forward
slash, forward slash, Assume percent entered. Line 31, indented
once. yearly Interest, equals, yearly Interest, forward slash, 100.0,
semicolon. Lines 30 and 31 are highlighted. Line 32, indented once.
monthly Interest, equals, yearly Interest, forward slash, 12,
semicolon. Line 33, indented once. number Of Payments, equals,
number Of Years, asterisk, 12, semicolon. Line 34, indented once.
payment, equals, left parenthesis, loan Amount, asterisk, pow, left
parenthesis, 1, plus, monthly Interest, comma, number Of
Payments, right parenthesis. Line 35, indented several times.
monthly Interest, right parenthesis, forward slash. Line 36, indented
several times. Left parenthesis, pow, left parenthesis, 1, plus,
monthly Interest, comma, number Of Payments, right parenthesis,
minus, 1, right parenthesis, semicolon. Line 37, indented once.
Forward slash, forward slash, Output results. Line 38, indented
once. c out, double left angle bracket, fixed, double left angle
bracket, open quotes, Loan amount, colon, space, close quotes,
double left angle bracket, set precision, left parenthesis, 2, right
parenthesis. Line 39, indented twice. Double left angle bracket, loan
Amount, double left angle bracket, end l, double left angle bracket,
open quotes, Interest rate, colon, space, close quotes. Line 40,

indented twice. Double left angle bracket, set precision, left
parenthesis, 4, right parenthesis, double left angle bracket, yearly
Interest, asterisk, 100.0, double left angle bracket, open quotes,
percentage, close quotes, double left angle bracket, end l. Line 41,
indented once. Double left angle bracket, open quotes, Number of
years, colon, space, close quotes, double left angle bracket, number
Of Years, double left angle bracket, end l, semicolon. Line 42. c out,
double left angle bracket, fixed. Line 43, indented twice. Double left
angle bracket, open quotes, Monthly payment, colon, space, close
quotes, double left angle bracket, set precision, left parenthesis, 2,
right parenthesis, double left angle bracket, payment, double left
angle bracket, end l, semicolon. Line 44, indented once. return, 0,
semicolon. Line 45. Right brace.
Back to Figure
Output of first test run of the application that calculates compound
interest. Line 1. Input loan amount, interest rate, and number of
years. Line 2. An interest rate of less than 0.25 is assumed to be.
Line 3. a decimal rather than a percent. Line 4. 3000 6.8 2. Line 5.
Loan amount: 3000.00. Line 6. Interest rate: 6.80%. Line 7. Number
of years: 2. Line 8. Monthly payment: 134.05.
Back to Figure
Output of second test run of the application that calculates
compound interest. Line 1. Input loan amount, interest rate, and
number of years. Line 2. An interest rate of less than 0.25 is
assumed to be. Line 3. a decimal rather than a percent. Line 4.
3000 0.068 2. Line 5. Loan amount: 3000.00. Line 6. Interest rate:
6.80%. Line 7. Number of years: 2. Line 8. Monthly payment:
134.05.
Back to Figure
Code that uses nested if statements. Program code. Line 1. IF
today is Saturday or Sunday. Note. This is the outer if. Line 2,
indented twice. IF it is raining. Note. This is the Inner or nested if.
Line 3, indented 3 times. Sleep late. Line 4, indented twice. ELSE.

Line 5, indented 3 times. Get up and go outside. Line 6, indented
once. ELSE. Line 7, indented twice. Go to work.
Back to Figure
Code block that uses sequence of if statements to output the name
of a month given its number. Program code. Line 1. if, left
parenthesis, month, equals, equals, 1, right parenthesis. Line 2,
indented once. c out, double left angle bracket, open quotes,
January, close quotes, semicolon. Line 3 if, left parenthesis, month,
equals, equals, 2, right parenthesis. Line 4, indented once. c out,
double left angle bracket, open quotes, February, close quotes,
semicolon. Line 5. if, left parenthesis, month, equals, equals, 3, right
parenthesis. Line 6, indented once. c out, double left angle bracket,
open quotes, March, close quotes, semicolon. Line 7. Ellipsis. Line
8. if, left parenthesis, month, equals, equals, 12, right parenthesis.
Line 9, indented once. c out, double left angle bracket, open quotes,
December, close quotes, semicolon.
Back to Figure
"Code block that uses nested if statements to output the name of a
month given its number. Program code. Line 1. if, left parenthesis,
month, equals, equals, 1, right parenthesis. Line 2, indented once. c
out, double left angle bracket, open quotes, January, close quotes,
semicolon. Line 3. else. Line 4, indented once. if, left parenthesis,
month, equals, equals, 2, right parenthesis, tab space, forward
slash, forward slash, Nested If. Line 5, indented twice. c out, double
left angle bracket, open quotes, February, close quotes, semicolon.
Line 6, indented once. else. Line 7, indented twice. if, left
parenthesis, month, equals, equals, 3, right parenthesis, tab space,
forward slash, forward slash, Nested If. Line 8, indented 3 times. c
out, double left angle bracket, open quotes, March, close quotes,
semicolon. Line 9, indented twice. else. Line 10, indented 3 times. if,
left parenthesis, month, equals, equals, 4, right parenthesis, tab
space, forward slash, forward slash, Nested If."
Back to Figure

"Code block that uses If-Then-Else-If control structure to output the
name of a month given its number. Program code. Line 1. if, left
parenthesis, month, equals, equals, 1, right parenthesis. Line 2,
indented once. c out, double left angle bracket, open quotes,
January, close quotes, semicolon. Line 3. else, if, left parenthesis,
month, equals, equals, 2, right parenthesis, tab space, forward
slash, forward slash, Nested If. Line 4, indented once. c out, double
left angle bracket, open quotes, February, close quotes, semicolon.
Line 5. else, if, left parenthesis, month, equals, equals, 3, right
parenthesis, tab space, forward slash, forward slash, Nested If. Line
6, indented once. c out, double left angle bracket, open quotes,
March, close quotes, semicolon. Line 7. else, if, left parenthesis,
month, equals, equals, 4, right parenthesis, tab space, forward
slash, forward slash, Nested If. Note. Code continues in a similar
manner. Line 11. Else. Line 12, indented once. c out, double left
angle bracket, open quotes, December, close quotes, semicolon."
Back to Figure
"Program that displays an appropriate activity based on the outdoor
temperature. Program code. Line 1. Forward slash, forward slash, a
line of asterisks. Line 2. Forward slash, forward slash, Activity
program. Line 3. Forward slash, forward slash, This program
outputs an appropriate activity. Line 4. Forward slash, forward slash,
for a given temperature. Line 5. Forward slash, forward slash, a line
of asterisks. Line 6. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 7. using, name space, s t d, semicolon.
Line 8. i n t, main, left parenthesis, right parenthesis. Line 9. Left
brace. Line 10, indented once. i n t, temperature, semicolon, forward
slash, forward slash, The outside temperature. Line 11, indented
once, forward slash, forward slash, Read and echo temperature.
Line 12, indented once. c out, double left angle bracket, open
quotes, Enter the outside temperature, colon, close quotes, double
left angle bracket, end l, semicolon. Line 13, indented once. c in,
double right angle bracket, temperature, semicolon. Line 14,
indented once. c out, double left angle bracket, open quotes, The
current temperature is, space, close quotes, double left angle
bracket, temperature, double left angle bracket, end l, semicolon.
Line 15, indented once. Forward slash, forward slash, Display

activity. Line 16, indented once. c out, double left angle bracket,
open quotes, The recommended activity is, space, close quotes,
semicolon. Line 17, indented once. if, left parenthesis, temperature,
right angle bracket, 85, right parenthesis. Line 18, indented once. c
out, double left angle bracket, open quotes, swimming, period, close
quotes, double left angle bracket, end l, semicolon. Line 19,
indented once. else, if, left parenthesis, temperature, greater than,
70, right parenthesis. Line 20, indented twice. c out, double left
angle bracket, open quotes, tennis, period, close quotes, double left
angle bracket, end l, semicolon. Line 21, indented once. else, if, left
parenthesis, temperature, greater than, 32, right parenthesis. Line
22, indented twice. c out, double left angle bracket, open quotes,
golf, period, close quotes, double left angle bracket, end l,
semicolon. Line 23, indented once. else, if, left parenthesis,
temperature, greater than, 0, right parenthesis. Line 24, indented
twice. c out, double left angle bracket, open quotes, skiing, period,
close quotes, double left angle bracket, end l, semicolon. Line 25,
indented once. else. Line 26, indented twice. c out, double left angle
bracket, dancing indoors, period, close quotes, end l, semicolon.
Line 27, return, 0, semicolon. Line 28. Right brace."
Back to Figure
Code with an If-Then-Else nested within an If-Then. Program code.
Line 1. if, left parenthesis, average, less than, 70.0, right
parenthesis. Line 2, indented once. if, left parenthesis, average, less
than, 60.0, right parenthesis. Line 3, indented twice. c out, double
left angle bracket, open quotes, Failing, close quotes, semicolon.
Line 4, indented once. else. Line 5, indented twice. c out, double left
angle bracket, open quotes, Passing but marginal, close quotes,
semicolon.
Back to Figure
Code with an else that is paired with the closest preceding if.
Program code. Line 1. if, left parenthesis, average, greater than or
equals, 60.0, right parenthesis, forward slash, forward slash,
Incorrect version. Line 2, indented once. if, left parenthesis,
average, less than, 70.0, right parenthesis. Line 3, indented twice. c

out, double left angle bracket, open quotes, Passing but marginal,
close quotes, semicolon. Line 4. else. Line 5, indented twice. c out,
double left angle bracket, open quotes, Failing, close quotes,
semicolon.
Back to Figure
Correct version of the code in which an else is attached to the first if
in a nested If-Then-Else code. Program code. Line 1. if, left
parenthesis, average, greater than or equals, 60.0, right
parenthesis, forward slash, forward slash, Correct version. Line 2.
Left brace. Line 3, indented once. if, left parenthesis, average, less
than, 70.0, right parenthesis. Line 4, indented twice. c out, double
left angle bracket, open quotes, Passing but marginal, close quotes,
semicolon. Line 5. Right brace. Line 6. else. Line 7, indented once. c
out, double left angle bracket, open quotes, Failing, close quotes,
semicolon.
Back to Figure
A comparison statement. Program code. Line 1. average, greater
than or equals, 60.0, ampersand, ampersand, less than, 70.0.
Back to Figure
A comparison statement. Program code. Line 1. mid term Grade,
equals, equals, open single quotes, A, close single quotes, pipe,
pipe, final Grade, equals, equals, open single quotes, A, close single
quotes.
Back to Figure
A comparison statement. Program code. Line 1. Not, left
parenthesis, hours, right parenthesis, greater than, 40.
Back to Figure
A comparison statement. Program code. Line 1. hours, less than or
equals, 40.

Back to Figure
A logical statement. Program code. Line 1. is Elector, equals, left
parenthesis, age, greater than or equals, 18, ampersand,
ampersand, district, equals, equals, 23, right parenthesis,
semicolon.
Back to Figure
Some Boolean assignments. Program code. Line 1. is Voter, equals,
left parenthesis, age, greater than or equals, 18, right parenthesis,
semicolon. Line 2. is Constituent, equals, left parenthesis, district,
equals, equals, 23, right parenthesis, semicolon. Line 3. is Elector,
equals, is Voter, ampersand, ampersand, is Constituent, semicolon.
Back to Figure
Program code. Line 1. float, height, semicolon. Line 2. bool, bad
Data, semicolon. Line 3. Period. Line 4. Period. Line 5. Period. Line
6. c in, double right angle bracket, height. Line 7. bad Data, equals,
not height, semicolon.
Back to Figure
Program code. Line 1. bad Data, equals, left parenthesis, height,
equals, equals, 0.0, right parenthesis, semicolon.
Back to Figure
Program code. Line 1. bad Data, equals, left parenthesis, height,
equals, equals, 0.0, right parenthesis, semicolon.
Back to Figure
Program code. Line 1. if, left parenthesis, height, equals, equals,
0.0, right parenthesis. Line 2, indented once. bad Data, equals, true,
semicolon. Line 3. else. Line 4, indented once. bad Data, equals,
false, semicolon.
Back to Figure

Program that outputs an appropriate activity for a given
temperature. Program code. Line 1. Forward slash, forward slash, a
line of asterisks. Line 2. Forward slash, forward slash, Activity
program. Line 3. Forward slash, forward slash, This program
outputs an appropriate activity. Line 4. Forward slash, forward slash,
for a given temperature. Line 5. Forward slash, forward slash, a line
of asterisks. Line 6. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 7. Hash, include, left angle bracket, string,
right angle bracket. Line 8. using, name space, s t d, semicolon.
Line 9. i n t, main, left parenthesis, right parenthesis. Line 10. Left
brace. Line 11, indented once. i n t, temperature, semicolon, tab
space, forward slash, forward slash, The outside temperature. Line
12, indented once. bool, raining, semicolon. Line 13, indented once.
bool, walk, semicolon. Line 14, indented once. bool, movie,
semicolon. Line 15, indented once. bool, book, semicolon. Line 16,
indented once. Forward slash, forward slash, Read and echo
temperature. Line 17, indented once. c out, double left angle
bracket, open quotes, Enter the outside temperature, colon, close
quotes, double left angle bracket, end l, semicolon. Line 18,
indented once. c in, double right angle bracket, temperature,
semicolon. Line 19, indented once. c out, double left angle bracket,
open quotes, Enter 1 if it is raining and 0 if it is not, period, close
quotes, semicolon. Line 20, indented once. c in, double right angle
bracket, raining, semicolon. Line 21, indented once. c out, double
left angle bracket, open quotes, The current temperature is, space,
close quotes, double left angle bracket, temperature, semicolon.
Line 22, indented once. if, left parenthesis, raining, right parenthesis.
Line 23, indented twice. c out, double left angle bracket, open
quotes, space, and it is raining, period, close quotes, double left
angle bracket, end l, semicolon. Line 24, indented once. else. Line
25, indented twice. c out, double left angle bracket, open quotes,
space, and it is not raining, period, close quotes, double left angle
bracket, end l, semicolon. Line 26, indented once. Forward slash,
forward slash, Output activity. Line 27, indented once. walk, equals,
temperature, greater than, 60, ampersand, ampersand, not, raining,
semicolon. Line 28, indented once. movie, equals, temperature,
greater than, 60, ampersand, ampersand, raining, semicolon. Line
29, indented once. book, equals, temperature, less than, 60,
semicolon. Line 30, indented once. if, left parenthesis, walk, right

parenthesis. Line 31, indented twice. c out, double left angle
bracket, open quotes, Go for a walk, period, close quotes, double
left angle bracket, end l, semicolon. Line 32. else. Line 33, indented
twice. if, left parenthesis, movie, right parenthesis. Line 34, indented
3 times. c out, double left angle bracket, open quotes, Go to a
movie, period, close quotes, double left angle bracket, end l,
semicolon. Line 35, indented twice. else. Line 36, indented 3 times.
c out, double left angle bracket, open quotes, Read a good book,
period, close quotes, double left angle bracket, end l, semicolon.
Line 37, indented once. return, 0, semicolon. Line 38. Right brace.
Back to Figure
"Output of the program that outputs an appropriate activity for a
given temperature for four different sets of input. Line 1. Enter the
outside temperature, colon. Line 2. 50. Line 3. Enter 1 if it is raining
and 0 if it is not. Line 4. 0. Line 5. The current temperature is 50 and
it is not raining. Line 6. Read a good book. Line 1. Enter the outside
temperature, colon. Line 2. 50. Line 3. Enter 1 if it is raining and 0 if
it is not. Line 4. 1. Line 5. The current temperature is 50 and it is
raining. Line 6. Read a good book. Line 1. Enter the outside
temperature, colon. Line 2. 65. Line 3. Enter 1 if it is raining and 0 if
it is not. Line 4. 0. Line 5. The current temperature is 65 and it is not
raining. Line 6. Go for a walk. Line 1. Enter the outside temperature,
colon. Line 2. 65. Line 3. Enter 1 if it is raining and 0 if it is not. Line
4. 1. Line 5. The current temperature is 65 and it is raining. Line 6.
Go to a movie."
Back to Figure
A logical expression. Program code. Line 1. I, equals, equals, 1,
ampersand, ampersand, j, greater than, 2.
Back to Figure
A logical expression. Program code. Line 1. c, less than or equals,
pipe, pipe, e, equals, equals, f.
Back to Figure

Precedence of operators from highest precedence to lowest
precedence. 1. Not, Unary plus, unary minus. 2. asterisk, forward
slash, percentage. 3. Plus, minus. 4. Less than, less than or equal,
greater, greater than or equal. 5. Equals, equals, Not equals. 6.
ampersand, ampersand. 7. Pipe, pipe. 8. Equals.
Back to Figure
A mathematical expression. Program code. Line 1. a, forward slash,
b, asterisk, c.
Back to Figure
A mathematical expression. Program code. Line 1. not, not, bad
Data.
Back to Figure
An expression. Program code. Line 1. data Invalid, equals, left
parenthesis, input Val, equals, equals, 0, right parenthesis,
semicolon.
Back to Figure
An expression. Program code. Line 1. data Invalid, equals, input Val,
equals, equals, 0, semicolon.
Back to Figure
A logical expression. Program code. Line 1. mid term Grade, equals,
equals, open single quotes, A, close single quotes, pipe, pipe, final
Grade, equals, equals, open single quotes, A, close single quotes.
Back to Figure
A logical expression. Program code. Line 1. mid term Grade, pipe,
pipe, final Grade, equals, equals, open single quotes, A, close single
quotes.
Back to Figure

A logical expression. Program code. Line 1. i equals equals, 3, pipe,
pipe, 4.
Back to Figure
A logical expression. Program code. Line 1. i equals equals, 3, pipe,
pipe, i, equals, equals, 4.
Back to Figure
A comparison statement. Program code. Line 1. 12, less than, y,
less than, 24.
Back to Figure
A logical expression. Program code. Line 1. 12, less than, y,
ampersand, ampersand, y, less than, 24.
Back to Figure
Program code. Line 1. one Third, equals, 1.0, forward slash, 3.0,
semicolon. Line 2. x, equals, oneThird, plus, oneThird, plus,
oneThird, semicolon.
Back to Figure
A comparison statement. Program code. Line 1. fabs, left
parenthesis, r, minus, s, right parenthesis, less than, 0.00001.
Back to Figure
Program code. Line 1. if, left parenthesis, grade, less than or
equals, 50.0, right paernthesis. Line 2, indented once. failed, equals,
true, semicolon. Line 3. else. Line 4, indented once. failed, equals,
false, semicolon.
Back to Figure
Program code. Line 1. if, left parenthesis, c in. Line 2. period. Line 3.
period. Line 4. period. Line 5. if, left parenthesis, not, in File, right

parenthesis. Line 6. period. Line 7. period. Line 8. period.
Back to Figure
Program code. Line 1. if, left parenthesis, in File, right parenthesis.
Line 2. Period. Line 3. Period. Line 4. period.
Back to Figure
Program code. Line 1. if, left parenthesis, not, in File, right
parenthesis. Line 2. Period. Line 3. Period. Line 4. Period.
Back to Figure
A program that checks if an input file was opened successfully. Line
1. Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, Stream State program. Line 3. Forward slash,
forward slash, This program demonstrates testing the state of a
stream. Line 4. Forward slash, forward slash, a line of asterisks.
Line 5. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 6. Hash, include, left angle bracket, f stream, right
angle bracket, forward slash, forward slash, For file I, forward slash,
O. Line 7. using, name space, s t d, semicolon. Line 8. i n t, main,
left parenthesis, right parenthesis. Line 9. Left brace. Line 10,
indented once. i n t, height, semicolon. Line 11, indented once. i n t,
width, semicolon. Line 12, indented once. i f stream, in File,
semicolon. Line 13, indented once. in File, dot, open, left
parenthesis, open quotes, measures, dot, dat, close quotes, right
parenthesis, semicolon, tab space, Forward slash, forward slash,
Attempt to open file. Line 14, indented once, if, left parenthesis, not,
in File, right parenthesis, tab space, forward slash, forward slash,
Was it opened, question mark. Line 15, indented once. Left brace.
Line 16, indented twice. c out, double left angle bracket, open
quotes, Can't open the input file, period, close quotes, tab space,
forward slash, forward slash, No hyphen, hyphen, display message.
Line 17, indented twice. return, 1, semicolon, forward slash, forward
slash, Terminate program. Line 18, indented once. Right brace. Line
19, indented once. in File, double right angle bracket, height, double
right angle bracket, width, semicolon. Line 20, indented once. c out,

double left angle bracket, open quotes, For a height of, space, close
quotes, double left angle bracket, height, double left angle bracket,
end l. Line 21, indented 3 times. Double left angle bracket, open
quotes, and a width of, space, close quotes, double left angle
bracket, width, double left angle bracket, end l. Line 22, indented 3
times. Double left angle bracket, open quotes, the area is, space,
close quotes, double left angle bracket, height, asterisk, width,
double left angle bracket, end l, semicolon. Line 23, indented once.
return, 0, semicolon. Line 24. Right brace.
Back to Figure
Program code. Line 1. return, 0, semicolon.
Back to Figure
The formula for Body Mass Index is the following. B M I equals
weight times 703 divided by height squared.
Back to Figure
Formula for calculating B M I. B M I equals weight times 703 divided
by (height times height).
Back to Figure
The module structure chart for the algorithm that calculates B M I
and prints suitable messages. There is the main module. Below the
main module are the Get Data, Test Data, Calculate B M I, and Print
Message modules.
Back to Figure
A program that calculates body mass index. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, B M I Program. Line 3. Forward slash, forward
slash, This program calculates the body mass index (B M I) given a
weight. Line 4. Forward slash, forward slash, in pounds and a height
in inches and outputs a health message. Line 5. Forward slash,
forward slash, based on the B M I. Input in English measures. Line

6. Forward slash, forward slash, a line of asterisks. Line 7. Hash,
include, left angle bracket, i o stream, right angle bracket. Line 8.
using, name space, s t d, semicolon. Line 9. i n t, main, left
parenthesis, right parenthesis. Line 10. Left brace. Line 11, indented
once. const, i n t, B M I underscore CONSTANT, equals, 703,
semicolon, forward slash, forward slash, Constant in nonmetric
formula. Line 12, indented once. float, weight, semicolon, tab space,
forward slash, forward slash, Weight in pounds. Line 13, indented
once. float, height, semicolon, forward slash, forward slash, tab
space, forward slash, forward slash, Height in inches. Line 14,
indented once. float, body Mass Index, semicolon, tab space,
forward slash, forward slash, Appropriate B M I. Line 15, indented
once. bool, data Are O K, semicolon, tab space, forward slash,
forward slash, True if data are non negative. Line 16, indented once.
Forward slash, forward slash, Prompt for and input weight and
height. Line 17, indented once. c out, double left angle bracket, open
quotes, Enter your weight in pounds, period, space, close quotes,
double left angle bracket, end l, semicolon. Line 18, indented once. c
in, double right angle bracket, weight, semicolon. Line 19, indented
once. c out, double left angle bracket, open quotes, Enter your
height in inches, period, space, close quotes, double left angle
bracket, end l, semicolon. Line 20, indented once. c in, double right
angle bracket, height, semicolon. Line 21, indented once. forward
slash, forward slash, Test data. Line 22, indented once. if, left
parenthesis, weight, less than, 0, pipe, pipe, height, less than, 0,
right parenthesis. Line 23, indented twice. data Are O K, equals,
false, semicolon. Line 24, indented once. else. Line 25, indented
twice. data Are O K, equals, true, semicolon. Line 26, indented
once. if, left parenthesis, data Are O K, right parenthesis. Line 27,
indented once. Left brace. Line 28, indented twice. Forward slash,
forward slash, Calculate body mass index. Line 29, indented twice.
body Mass Index, equals, weight, asterisk, B M I underscore
CONSTANT, forward slash, left parenthesis, height, asterisks,
height, right parenthesis, semicolon. Line 30, indented twice.
Forward slash forward slash, Display message indicating status.
Line 31, indented twice. c out, double left angle bracket, open
quotes, Your body mass index is, space, close quotes, double left
angle bracket, body Mass Index. Line 32, indented a few times.
Double left angle bracket, open quotes, period, space, close quotes,

double left angle bracket, end l, semicolon. Line 33, indented twice.
c out, double left angle bracket, open quotes, Interpretation and
instructions, period, space, close quotes, double left angle bracket,
end l, semicolon. Line 34, indented twice. if, left parenthesis, body
Mass Index, less than, 20, right parenthesis. Line 35, indented 3
times. c out, double left angle bracket, open quotes, Underweight,
colon, Have a milkshake, period, close quotes, double left angle
bracket, end l, semicolon. Line 36, indented twice. else, if, left
parenthesis, body Mass Index, less than or equals, 25, right
parenthesis. Line 37, indented 3 times. c out, double left angle
bracket, open quotes, Normal, colon, Have a glass of milk, period
close quotes, double left angle bracket, end l, semicolon. Line 38,
indented twice. else, if, left parenthesis, body Mass Index, less than
or equals, 30, right parenthesis. Line 39, indented 3 times. c out,
double left angle bracket, open quotes, Overweight, colon, Have a
glass of iced tea, period, close quotes, double left angle bracket,
end l, semicolon. Line 40, indented twice. else. Line 41, indented 3
times. c out, double left angle bracket, open quotes, Obese, colon,
See your doctor, period, close quotes, double left angle bracket, end
l, semicolon. Line 42, indented once. Right brace. Line 43, indented
once. else. Line 44, indented 3 times. c out, double left angle
bracket, open quotes, Invalid data, semicolon, weight and height
must be positive, period, close quotes. Line 45, indented a few
times. Double left angle bracket, end l, semicolon. Line 46, indented
once. return, 0, semicolon. Line 47. Right brace.
Back to Figure
"Outputs of various runs of the B M I program with various heights
and weights and with both good and bad data. Line 1. Enter your
weight in pounds. Line 2. 132. Line 3. Enter your height in inches.
Line 4. 63. Line 5. Your body mass index is 23.3802. Line 6.
Interpretation and instructions. Line 7. Normal: Have a glass of milk.
Line 1. Enter your weight in pounds. Line 2. 145. Line 3. Enter your
height in inches. 63. Line 4. Your body mass index is 25.6828. Line
5. Interpretation and instructions. Line 6. Overweight: Have a glass
of iced tea. Line 1. Enter your weight in pounds. Line 2. 175. Line 3.
Enter your height in inches. Line 4. 63. Line 5. Your body mass
index is 30.9965. Line 6. Interpretation and instructions. Line 7.

Obese: See your doctor. Line 1. Enter your weight in pounds. Line 2.
175. Line 3. Enter your height in inches. Line 4. 68. Line 5. Your
body mass index is 26.6058. Line 6. Interpretation and instructions.
Line 7. Overweight: Have a glass of iced tea. Line 1. Enter your
weight in pounds. Line 2. minus 100. Line 3. Enter your height in
inches. Line 4. 64. Line 5. Invalid data; weight and height must be
positive. Line 1. Enter your weight in pounds. Line 2. 130. Line 3.
Enter your height in inches. Line 4. minus 65. Line 5. Invalid data;
weight and height must be positive."
Back to Figure
Succinct code. Program code. Line 1. data Are O K, equals, not, left
parenthesis, weight, less than, 0, pipe, pipe, height, less than, 0,
right parenthesis, semicolon.
Back to Figure
A statement written using De Morgan's law. Program code. Line 1.
data Are O K, equals, left parenthesis, weight, greater than or equal,
0, ampersand, ampersand, height, greater than or equals, 0, right
parenthesis, semicolon.
Back to Figure
Reduced code. Program code. Line 1. if, left parenthesis, weight,
equals or greater than, 0, ampersand, ampersand, height, greater
than or equal, 0, right parenthesis. Line 2. Period. Line 3. Period.
Line 4. Period.
Back to Figure
Initial code that was reduced later. Program code. Line 1. if, left
parenthesis, data Are O K, right parenthesis. Line 2. Period. Line 3.
Period. Line 4. Period.
Back to Figure
Code from the B M I Calculator program that makes the user enter
their height and weight. Program code. Line 1. float, weight,

semicolon, forward slash, forward slash, Weight in pounds. Line 2.
float, height, semicolon, forward slash, forward slash, Height in
inches. Line 3. Forward slash, forward slash, Prompt for and input
weight and height. Line 4. c out, double left angle bracket, open
quotes, Enter your weight in pounds, period, space, close quotes,
double left angle bracket, end l, semicolon. Line 5. c in, double right
angle bracket, weight, semicolon. Line 6. c out, double left angle
bracket, open quotes, Enter your height in inches, period, space,
close quotes, double left angle bracket, end l, semicolon. Line 7. c
in, double right angle bracket, height, semicolon.
Back to Figure
The include statement for accessing G U I components. Program
code. Line 1. Hash, include, open quotes, dialog, dot, h, close
quotes, forward slash, forward slash, Access G U I components.
Back to Figure
Some dialog object declarations. Program code. Line 1. Forward
slash, forward slash, Create the G U I widgets to display to the user.
Line 2. Float Dialog, weight Dialog, left parenthesis, open quotes,
Enter your weight in pounds, period, close quotes, right parenthesis,
semicolon. Line 2. Float Dialog, height Dialog, left parenthesis, open
quotes, Enter your height in inches, period, close quotes, right
parenthesis, semicolon.
Back to Figure
Code for displaying the G U I widgets. Program code. Line 1.
Forward slash, forward slash, Display the G U I widgets to get user
input for weight and height. Line 2. weight, equals, weight Dialog,
dot, display, left parenthesis, right parenthesis, semicolon. Line 3.
height, equals, height Dialog, dot, display, left parenthesis, right
parenthesis, semicolon.
Back to Figure
The dialog box that accepts the weight of the user. The title bar of
the dialog box has the title,"Float Dialog." The following text is

displayed in the dialog box followed by an input box."Enter your
weight in pounds." Below the input box is a Cancel and O K button.
Back to Figure
The dialog box that accepts the height of the user. The title bar of
the dialog box has the title,"Float Dialog." The following text is
displayed in the dialog box followed by an input box."Enter your
height in inches." Below the input box is a Cancel and O K button.
Back to Figure
Code that checks if the user input is valid in the B M I calculator
program. Program code. Line 1. Forward slash, forward slash, Test
data. Line 2. if, left parenthesis, weight, left angle bracket, 0, pipe,
pipe, height, less than, 0, right parenthesis. Line 3. data Are O K,
equals, false, semicolon. Line 4. else. Line 5. data Are O K, equals,
true, semicolon.
Back to Figure
The modified B M I program which collects the output in a string and
uses the Output Dialog. Program code. Line 1. string, message,
semicolon, forward slash, forward slash, Message to display to the
user in the G U I. Line 2. if, left parenthesis, data Are O K, right
parenthesis, left brace. Line 3, indented once. Forward slash,
forward slash, Calculate body mass index. Line 4, indented once.
body Mass Index, equals, weight, times, B M I underscore
CONSTANT, forward slash, left parenthesis, height, times, height,
right parenthesis, semicolon. Line 5, indented once. Forward slash,
forward slash, Create message to user. Line 6, indented once.
message, equals. Line 7, indented twice. open quotes, Your body
mass index is, space, close quotes, plus, to underscore string, left
parenthesis, body Mass Index, right parenthesis, plus, open quotes,
period, backslash, n, close quotes, plus. Line 8, indented twice.
open quotes, Interpretation and instructions, period, backslash, n,
close quotes, semicolon. Line 9, indented once. if, left parenthesis,
body Mass Index, single left angle bracket, 20, right parenthesis.
Line 10, indented twice. message, plus, equals, open quotes,

Underweight, colon, Have a milkshake, period, backslash, n, close
quotes, semicolon. Line 11, indented once. else, if, left parenthesis,
body Mass Index, left angle bracket, equals, 25, right parenthesis.
Line 12, indented twice. message, plus, equals, open quotes,
Normal, colon, Have a glass of milk, period, backslash, n, close
quotes, semicolon. Line 13, indented once. else, if, left parenthesis,
body Mass Index, left angle bracket, equals, 30, right parenthesis.
Line 14, indented twice. message, plus, equals, open quotes,
Overweight, colon, Have a glass of iced tea, period, backslash, n,
close quotes, semicolon. Line 15, indented once. else. Line 16,
indented twice. message, plus, equals, open quotes, Obese, colon,
See your doctor, period, backslash, n, close quotes, semicolon. Line
17. Right brace, else, left brace. Line 18, indented once. message,
equals, open quotes, Invalid data, semicolon, weight and height
must be positive, period, backslash, n, close quotes, semicolon. Line
19. Right brace.
Back to Figure
Code that displays the final result to the user in the B M I Calculator
program. Program code. Line 1. Output Dialog, b m i Output, left
parenthesis, open quotes, B M I Output, close quotes, right
parenthesis, semicolon. Line 2. b m i Output, dot, Set Output, left
parenthesis, message, right parenthesis, semicolon. Line 3. b m i
Output, dot, display, left parenthesis, right parenthesis, semicolon.
Back to Figure
The output dialog box that displays the result in the B M I Calculator
program. The dialog box has the following title in the title bar.
Multiline Text Dialog. The dialog box features a label that says
Output. In the multiline text box the following output is displayed.
Your body mass index is 26.623257. Interpretation and instructions.
Overweight: Have a glass of iced tea. Below the multiline text box,
there is a Cancel or O K button.
Back to Figure

Code for the G U I version of the B M I program. Program code.
Line 1. Hash, include, open quotes, dialog, dot, h, close quotes. This
line is highlighted. Line 2. using, name space, s t d, semicolon. Line
3. i n t, main, left parenthesis, right parenthesis. Left brace. Line 4,
indented once. string, message, semicolon, tab space, forward
slash, forward slash, Message to display to the user in the G U I.
This line is highlighted. Line 5, indented once. const, i n t, B M I
underscore CONSTANT, equals, 703, semicolon, tab space, forward
slash, forward slash, Constant in nonmetric formula. Line 6,
indented once. float, weight, semicolon, tab space, forward slash,
forward slash, Weight in pounds. Line 7, indented once. float, height,
semicolon, tab space, forward slash, forward slash, Height in inches.
Line 8, indented once. float, body Mass Index, semicolon, tab
space, forward slash, forward slash, Appropriate B M I. Line 9,
indented once. bool, data Are O K, semicolon, tab space, forward
slash, forward slash, True if data are nonnegative. Line 10, forward
slash, forward slash, Create the G U I widgets to display to the user.
Line 11, indented once. Float Dialog, weight Dialog, left parenthesis,
open quotes, Enter your weight in pounds, period, close quotes,
right parenthesis, semicolon. Line 12, indented once. Float Dialog,
height Dialog, left parenthesis, open quotes, Enter your height in
inches, period, close quotes, right parenthesis, semicolon. Line 13,
indented once. Forward slash, forward slash, Display the G U I
widgets to get user input for weight and height. Line 14, indented
once. weight, equals, weight Dialog, dot, display, left parenthesis,
right parenthesis, semicolon. Line 15, indented once. height, equals,
height Dialog, dot, display, left parenthesis, right parenthesis,
semicolon. Lines 10 to 15 are highlighted. Line 16, indented once.
Forward slash, forward slash, Test data. Line 17, indented once. if,
left parenthesis, weight, less than, 0, pipe, pipe, height, less than, 0,
right parenthesis. Line 18, indented twice. data Are O K, equals,
false, semicolon. Line 19, indented once. else. Line 20, indented
twice. data Are O K, equals, true, semicolon. Line 21, indented
once. if, left parenthesis, data Are O K, right parenthesis. Line 22,
indented once. Left brace. Line 23, indented twice. Forward slash,
forward slash, Calculate body mass index. Line 24, indented twice.
body Mass Index, equals, weight, asterisk, B M I underscore
CONSTANT, forward slash, left parenthesis, height, asterisk, height,
right parenthesis, semicolon. Line 25, indented twice. Forward slash,

forward slash, Create message to user. Line 26, indented twice.
message, equals. Line 27, indented twice. open quotes, Your body
mass index is, space, close quotes, plus, to underscore string, left
parenthesis, body Mass Index, right parenthesis, plus, open quotes,
period, backslash, n, close quotes, plus. Line 28, indented twice.
open quotes, Interpretation and instructions, period, backslash, n,
close quotes, semicolon. Lines 26 to 28 are highlighted. Line 29,
indented once. if, left parenthesis, body Mass Index, less than, 20,
right parenthesis. Line 30, indented twice. message, equals,
message, plus, open quotes, Underweight, colon, Have a milkshake,
period, backslash, n, close quotes, semicolon. This line is
highlighted. Line 31, indented once. else, if, left parenthesis, body
Mass Index, less than, 25, right parenthesis. Line 32, indented
twice. message, equals, message, plus, open quotes, Normal,
colon, Have a glass of milk, period, backslash, n, close quotes,
semicolon. This line is highlighted. Line 33, indented once else, if,
left parenthesis, body Mass Index, less than or equals, 30, right
parenthesis. Line 34, indented twice. message, message, plus, open
quotes, Overweight, colon, Have a glass of iced tea, period,
backslash, n, close quotes, semicolon. This line is highlighted. Line
35, indented once. else. Line 36, indented twice. message, equals,
message, plus, open quotes, Obese, colon, See your doctor, period,
backslash, n, close quotes, semicolon. This line is highlighted. Line
37, indented once. Right brace. Line 38, indented once. else. Line
39, indented a few times. message, equals, open quotes, Invalid
data, semicolon, weight and height must be positive, period,
backslash, n, close quotes, semicolon. Line 40, indented once.
Output Dialog, b m i Output, left parenthesis, open quotes, B M I
Output, close quotes, right parenthesis, semicolon. Line 41,
indented once. b m i Output, dot, Set Output, left parenthesis,
message, right parenthesis, semicolon. Line 42, indented once. b m
i Output, dot, display, left parenthesis, right parenthesis, semicolon.
Lines 39 to 42 are highlighted. Line 43. Right brace.
Back to Figure
Code that creates the G U I widgets to display to the user. Program
code. Line 1. Forward slash, forward slash, Create the G U I widgets
to display to the user. Line 2. Float Dialog, weight Dialog, left

parenthesis, open quotes, Enter your weight in pounds, period, close
quotes, comma, 30, comma, 30, comma, 600, right parenthesis,
semicolon.
Back to Figure
Code in which the height Dialog is configured with sensible starting,
minimum, and maximum allowable height values. Program code.
Line 1. Float Dialog, height Dialog, left parenthesis, open quotes,
Enter your height in inches, period, close quotes, comma, 48,
comma, 32, comma, 108, right parenthesis, semicolon.
Back to Figure
A dialog box that accepts weight from the user. The dialog box
displays the following text in the title bar. Float Dialog. The following
label is displayed in the dialog box. Enter your weight in pounds. An
input box is present and below the input box a Cancel and O K
button is present.
Back to Figure
A dialog box that accepts a height value from the user. The dialog
box displays the following text in the title bar. Float Dialog. The
following label is displayed in the dialog box. Enter your height in
inches. An input box is present in which the number 48 has been
entered. Below the input box a Cancel and O K button is present.
Back to Figure
A dialog box that accepts weight from the user. The dialog box
displays the following text in the title bar. Float Dialog. The following
label is displayed in the dialog box. Enter your weight in pounds. An
input box is present in which the number 29.9 has been entered.
Below the input box a Cancel and O K button is present.
Back to Figure
Code that provides the user with a choice for continuing to calculate
B M I. Program code. Line 1. Yes No Dialog, choice, left

parenthesis, open quotes, Continue with calculating B M I, question
mark, close quotes, right parenthesis, semicolon. Line 2. bool,
response, equals, choice, dot, display, left parenthesis, right
parenthesis, semicolon.
Back to Figure
A G U I widget that displays a Yes and No button. The widget
displays the following question. Continue with calculating B M I? The
user can respond with a yes or no answer.
Back to Figure
"Code for the G U I version of the B M I program. Program code.
Line 1. hash, include, open quotes, dialog, dot, h, close quotes. Line
2. using, name space, s t d, semicolon. Line 3. i n t, main, left
parenthesis, right parenthesis, left brace. Line 4, indented once. Yes
No Dialog, choice, left parenthesis, open quotes, Continue with
calculating B M I, question mark, close quotes, right parenthesis,
semicolon. Line 5, indented once. bool, response, equals, choice,
dot, display, left parenthesis, right parenthesis, semicolon. Line 6,
indented once. string, message, semicolon, forward slash, forward
slash, Message to display to the user in the G U I. Line 7, indented
once. if, left parenthesis, response, right parenthesis. Line 8,
indented once. Left brace. Line 9, indented twice. const, i n t, B M I
underscore CONSTANT, equals, 703, semicolon, tab space, forward
slash, forward slash, Constant in nonmetric formula. Line 10,
indented twice. float, weight, semicolon, tab space, forward slash,
forward slash, Weight in pounds. Line 11, indented twice. float,
height, semicolon, tab space, forward slash, forward slash, Height in
inches. Line 12, indented twice. float body Mass Index, semicolon,
tab space, forward slash, forward slash, Appropriate B M I. Line 13,
indented twice. bool, data Are O K, semicolon, tab space, forward
slash, forward slash, forward slash, forward slash, True if data are
nonnegative. Line 14, indented twice. Forward slash, forward slash,
Create the G U I widgets to display to the user. Line 15, indented
twice. Float Dialog, weight Dialog, left parenthesis, open quotes,
Enter your weight in pounds, period, close quotes, comma, 30,
comma, 30, comma, 600, right parenthesis, semicolon. Line 16,

indented twice. Float Dialog, height Dialog, left parenthesis, open
quotes, Enter your height in inches, period, close quotes, comma,
48, comma, 32, comma, 108, right parenthesis, semicolon. Line 17,
indented twice. Forward slash, forward slash, Display the G U I
widgets to get user input for weight and height. Line 18, indented
twice. weight, equals, weight Dialog, dot, display, left parenthesis,
right parenthesis, semicolon. Line 19, indented twice. height, equals,
height Dialog, dot, display, left parenthesis, right parenthesis,
semicolon. Line 20, indented twice. Forward slash, forward slash,
Calculate body mass index. Line 21, indented twice. body Mass
Index, equals, weight, asterisk, B M I underscore CONSTANT,
forward slash, left parenthesis, height, asterisk, height, right
parenthesis, semicolon. Line 22, indented twice. Forward slash,
forward slash, Create message to user. Line 23, indented twice.
message, equals. Line 24, indented 3 times. open quotes, Your body
mass index is, space, close quotes, plus, to underscore string, left
parenthesis, body Mass Index, right parenthesis, plus, open quotes,
period, backslash, n, close quotes, plus. Line 25, indented 3 times.
open quotes, Interpretation and instructions, period, backslash, n,
close quotes, semicolon. Line 26, indented twice. if, left parenthesis,
body Mass Index, less than, 20, right parenthesis. Line 27, indented
3 times. message, equals, message, plus, open quotes,
Underweight, colon, Have a milkshake, period, backslash, n, close
quotes, semicolon. Line 28, indented twice. else, if, left parenthesis,
body Mass Index, less than or equals, 25, right parenthesis. Line 29,
indented 3 times. message, equals, message, plus, open quotes,
Normal, colon, Have a glass of milk, period, backslash, n, close
quotes, semicolon. Line 30, indented twice. else, if, left parenthesis,
body Mass Index, less than or equals, 30, right parenthesis. Line 31,
indented 3 times. message, equals, message, plus, open quotes,
Overweight, colon, Have a glass of iced tea, period, backslash n,
close quotes, semicolon. Line 32, indented twice. else. Line 33,
indented 3 times. message, equals, message, plus, open quotes,
Obese, colon, See your doctor, period, backslash, n, close quotes,
semicolon. Line 34, indented once. Right brace, else. Line 35,
indented 3 times. message, equals, open quotes, Perhaps you want
to calculate your B M I next time, period, backslash, n, close quotes,
semicolon. Line 36, indented once. Output Dialog, b m i Output, left
parenthesis, open quotes, B M I Output, close quotes, right

parenthesis, semicolon. Line 37, indented once. b m i Output, dot,
Set Output, left parenthesis, message, right parenthesis, semicolon.
Line 38, indented once. b m i Output, dot, display, left parenthesis,
right parenthesis, semicolon. Line 39. Right brace."
Back to Figure
A table that lists the statements in a program line by line and the
values of the variables a, b, and c as the statements execute. The
table has the following information. Statement. Line 1. const, i n t, X
equals, 5, semicolon. Value of a: Blank. Value of b: Blank. Value of c:
blank. Statement: Line 2. i n t, main, left parenthesis, right
parenthesis. Value of a: blank. Value of b: blank. Value of c: blank.
Statement: Line 3. Left brace. Value of a: blank. Value of b: blank.
Value of c: blank. Statement: indented once. Line 4. i n t, a, comma,
b, comma, c, semicolon. Value of a: blank. Value of b: blank. Value
of c: blank. Statement: Line 5, indented once. b, equals, 1,
semicolon. Value of a: blank. Value of b: 1. Value of c: blank.
Statement. Line 6, indented once. c, equals, X, plus, b, semicolon.
Value of a: blank, Value of b: 1. Value of c. 6. Statement. Line 7,
indented once. a, equals, X, plus, 4, semicolon. Value of a: 9. Value
of b: 1. Value of c: 6. Statement. Line 8, indented once. a, equals, c,
semicolon. Value of a: 6. Value of b: 1. Value of c: 6. Statement. Line
9, indented once. b, equals, c, semicolon. Value of a: 6. Value of b:
6. Value of c: 6. Statement. Line 10, indented once. a, equals, a,
plus, b, plus, c, semicolon. Value of a: 18. Value of b: 6. Value of c:
6. Statement: Line 11, indented once. c, equals, c modulus, X,
semicolon. Value of a: 18. Value of b: 6. Value of c: 1. Statement.
Line 12, indented once. c, equals, c, asterisk, a, semicolon. Value of
a: 18. Value of b: 6. Value of c: 28. Statement. Line 13, indented
once. a, equals, a, modulus, b, semicolon. Value of a: 0. Value of b:
6. Value of c: 18. Statement. Line 14, indented once. c out, double
left angle bracket, a, double left angle bracket, b, double left angle
bracket, c, semicolon. Value of a: 0. Value of b: 6. Value of c: 18.
Statement. Line 15, indented once. return, 0, semicolon. Value of a:
0. Value of b: 6. Value of c: 18. Statement. Line 16. Right brace.
Value of a: blank. Value of b: blank. Value of c: blank.
Back to Figure

A table listing the B M I program line by line and the values in the
variables as each line is executed. The table has the following
column headings. Statement. weight. height. B M I. data Are O K.
The following is the content in the table. Statement, c out, double left
angle bracket, open quotes, Enter your weight in pounds, period,
space, double left angle bracket, end l, semicolon; weight, blank;
height, blank; B M I, blank; data Are O K, blank. Statement, c in,
double right angle bracket, weight, semicolon; weight, 124; height,
blank; B M I, blank; data Are O K, blank. Statement, c out, double
left angle bracket, open quotes, Enter your height in inches, period,
space, close quotes, double left angle bracket, end l, semicolon;
weight, 124; height, blank, B M I, blank; data Are O K, blank.
Statement, c in, double right angle bracket, height, semicolon;
weight, 124; heigh; 63.5; B M I, blank; data Are O K, blank.
Statement, if, left parenthesis, weight, less than, 0, pipe, pipe,
height, less than, 0, right parenthesis; weight, 124; height, 63.5; B M
I, blank; data Are O K, blank. Statement, indented once. data Are O
K, equals, false, semicolon. Statement, else. Statement, indented
once. data Are O K, equals, true, semicolon; weight, 124; height,
63.5; B M I, blank; data Are O K, true. Statement, if, left
parenthesis, data Are O K, right parenthesis; weight, 124; height,
63.5; B M I, blank; data Are O K, true. Statement, left brace.
Statement, indented once. body Mass Index, equals, weight,
asterisk, B M I underscore CONSTANT, forward slash. Statement,
indented twice, left parenthesis, height, asterisk, height, right
parenthesis, semicolon; weight, 124; height, 63.5; B M I, 21.087;
data Are O K, true. Statement, indented once. c out, double left
angle bracket, open quotes, Your body mass index is, space, close
quotes. Statement, indented twice. double left angle bracket, body
Mass Index, double left angle bracket, open quotes, period, space,
close quotes, double left angle bracket, end l, semicolon; weight,
124; height, 63.5; B M I, 21.087; data Are O K, true. Statement,
indented once. c out, double left angle bracket, open quotes,
Interpretation and instructions, period, space, close quotes.
Statement, indented twice. double left angle bracket, end l,
semicolon; weight; 124; height, 63.5; B M I, 21.087; data Are O K,
true. Statement, indented once. if, left parenthesis, body Mass
Index, less than, 20, right parenthesis; weight, 124; height, 63.5; B
M I, 21.087; data Are O K, true. Statement, indented twice. c out,

double left angle bracket, open quotes, Underweight, colon, Have a
milkshake, period, close quotes. Statement, indented twice. end l,
semicolon. Statement, indented once. c out, else, if, left parenthesis,
body Mass Index, less than or equals, right parenthesis; weight,
124; height, 63.5; B M I, 21.087; data Are O K, true. Statement,
indented twice. c out, double left angle bracket, open quotes,
Normal, colon, Have a glass of milk, period, close quotes.
Statement, indented twice. Double left angle bracket, end l,
semicolon; weight, 124; height, 63.5; B M I, 21.087; data Are O K,
true. Statement, indented once. else if, left parenthesis, body Mass
Index, less than or equals, 30, right parenthesis. Statement,
indented once. c out. Statement, indented 3 times. double left angle
bracket, open quotes, Overweight, colon Have a glass of iced tea,
period, close quotes. Statement, indented 3 times. double left angle
bracket, end l, semicolon. Statement, indented once. else.
Statement, indented twice. c out, double left angle bracket, open
quotes, Obese, colon see your doctor, period, close quotes, double
left angle bracket, end l, semicolon. Statement, right brace.
Statement, else. Statement, indented once. c out, double left angle
bracket, open quotes, Invalid data, semicolon, weight, asterisk.
Statement, indented a few times. Double left angle bracket, open
quotes, and height must be positive, period, close quotes.
Statement, indented a few times. double left angle bracket, end l,
semicolon. Statement, return, 0, semicolon; weight, 124; height,
63.5; B M I, 21.087; data Are O K, true.
Back to Figure
A table listing sets of input values for weight and height that cause
all branches in the B M I program to be executed. The table has 5
rows and 4 columns. It has the following column headings. Data Set.
Weight in Pounds. Height in inches. Status. The row details are the
following. Row 1: Data Set, 1; Weight in Pounds, 110.0; Height in
Inches, 67.5; Status, Underweight. Row 2: Data Set, 2; Weight in
Pounds, 120.0; Height in Inches, 63.0; Status, Normal. Row 3: Data
Set, 3; Weight in Pounds, 145.0; Height in Inches, 62.0; Status,
Overweight. Row 4: Data Set, 4; Weight in Pounds, 176.6; Height in
Inches, 60.0; Status, Obese. Row 5: Data Set, 5; Weight in Pounds,
minus 100; Height in Inches, 65.0; Status, Error message.

Back to Figure
The branching structure for the B M I program. The following are the
branching statements. Weight, less than 0 or height less than 0.
Statement branches into true or false. Data Are O K. Statement
branches into true or false. Next statement in the true branch is the
following. B M I less than 20. This statement branches into true of
false. Next statement in the false branch is the following. B M I less
than or equals 25. This statement branches into true or false. Next
statement in the false branch is the following. B M I less than or
equals 30. This statement branches into true or false. All the
branches merge into one.
Back to Figure
A set of five diagrams showing the flow of control through the B M I
program for each of five data sets. First diagram. Weight less than 0
or height less than 0 turns out to be true and control flow goes to
true branch. Data are O K turns out to be true and control flow goes
to true branch. B M I less than 20 turns out to be true and control
flow goes to true branch and flow merges. Second diagram. Weight
less than 0 or height less than 0 turns out to be true and control flow
goes to true branch. Data are O K turns out to be true and control
flow goes to true branch. B M I less than 20 turns out to be false
and control flow goes to false branch. B M I less than or equals 25
turns out to be true and control flow goes to true branch and flow
merges. Third diagram. Weight less than 0 or height less than 0
turns out to be true and control flow goes to true branch. Data are O
K turns out to be true and control flow goes to true branch. B M I
less than 20 turns out to be false and control flow goes to false
branch. B M I less than or equals 25 turns out to be false and
control flow goes to false branch. B M I less than or equals to 30
turns out to be true and control flow goes to the true branch and
flow merges. Fourth diagram. Weight less than 0 or height less than
0 turns out to be true and control flow goes to true branch. Data are
O K turns out to be true and control flow goes to true branch. B M I
less than 20 turns out to be false and control flow goes to false
branch. B M I less than or equals 25 turns out to be false and
control flow goes to false branch. B M I less than or equals to 30

turns out to be false and control flow goes to the false branch and
flow merges. Fifth diagram. Weight less than 0 or height less than 0
turns out to be false and control flow goes to false branch. Data are
O K turns out to be false and control flow goes to false branch and
the flow merges.
Back to Figure
Program code. Line 1. alpha, less than, 0.
Back to Figure
Program code. Line 1. alpha, greater than or equals, 0, ampersand,
ampersand, alpha, less than or equals, 100.
Back to Figure
A table detailing a test plan for a B M I program. The table has 6
rows and 4 columns. The column headings in the table are the
following. Reason for Test Case. Input Values. Expected Output.
Observed Output. The row details are the following. Row 1: Reason
for Test Case, Underweight case; Input Values, 110, 67.5; Expected
Output, Your body mass index is 16.9723. Interpretation and
instructions. Underweight: Have a milkshake; Observer Output,
Blank. Row 2: Reason for Test Case, Normal case; Input Values,
120, 63; Expected Output, Your body mass index is 21.3547.
Interpretation and instructions. Normal: Have a glass of milk;
Observer Output, Blank. Row 3: Reason for Test Case, Overweight
case; Input Values, 145, 62; Expected Output, Your body mass
index is 26.518. Interpretation and instructions. Overweight: Have a
glass of iced tea; Observer Output, Blank. Row 4: Reason for Test
Case, Obese case; Input Values, 176.6, 60; Expected Output, Your
body mass index is 34.4861. Interpretation and instructions. Obese:
See your doctor; Observer Output, Blank. Row 5: Reason for Test
Case, Negative weight; Input Values, minus 120, 63; Expected
Output, Invalid data; Weight and heigh must be positive; Observer
Output, Blank. Row 6: Reason for Test Case, Negative height; Input
Values, 120, minus 63; Expected Output, Invalid data; weight and
height must be positive; Observer Output, Blank.

Back to Figure
A diagram that lists out the testing process and where syntax and
semantic errors occur and in which phase they are corrected. The
diagram lists the phase, result, testing technique, and type of error.
The details in the diagram are explained further. Phase: Problem
solving. Result: Algorithm. Testing Technique: Algorithm walk-
through. Type of Error: Semantic. Phase: Implementation. Result:
Coded program. Testing Technique: Code walk-through. Type of
Error: Syntax and Semantic. Phase: Compilation. Result: Object
program. Testing Technique: Compiler-generated error messages.
Type of Error: Syntax. Phase: Execution. Result: Output. Testing
Technique: Implementation test plan. Type of Error: Typographical
semantic and Algorithm semantic. Sematic errors in the problem
solving phase are tested using the algorithm walk-through technique
in the same phase. Syntax errors in the implementation phase are
tested using the code walk-through and trace testing techniques in
the same phase. Semantic errors in the implementation phase are
tested using the algorithm walk-through testing technique in the
problem solving phase. Syntax errors in the compilation phase are
tested using the code walk-through and trace testing techniques in
the implementation phase. Typographical semantic errors in the
execution phase are tested using the code walk-through and trace
testing technique in the implementation phase. Algorithm semantic
errors int he execution phase are tested using the algorithm walk-
through technique in the problem solving phase.
Back to Figure
The matching left and right brackets in an expression are marked.
The expression is the following. Program code. Line 1. if, left
parenthesis, left parenthesis, left parenthesis, total, forward slash,
scores, right parenthesis, greater than, 50, right parenthesis,
ampersand, ampersand, left parenthesis, left parenthesis, total,
forward slash, left parenthesis, scores minus 1, right parenthesis,
right parenthesis, less than, 100, right parenthesis, right
parenthesis.
Back to Figure

The opening and closing parentheses in an expression matched
using a magic number. Program code. Line 1. if, 0, left parenthesis,
1, left parenthesis, 2, left parenthesis, 3, total, forward slash,
scores, right parenthesis, 2, greater than, 50, right parenthesis, 1,
ampersand, ampersand, left parenthesis, 2, left parenthesis, 3, total,
forward slash, left parenthesis, scores, 4, minus 1, right parenthesis,
3, right parenthesis, 2, less than, 100, right parenthesis, 1, right
parenthesis, 0.
Back to Figure
Code under point number 6 under Testing and Debugging Hints.
Program code. Line 1. data O K, equals, true, semicolon. Line 2. if
left parenthesis, test 1, less than, 0, pipe, pipe, test 2, less than, 0,
pipe, pipe, test 3, less than, 0, right parenthesis. Line 3. Left brace.
Line 4, indented once. c out, double left angle bracket, open quotes,
Invalid Data, colon, Score, left parenthesis, s, right parenthesis, less
than zero, period, close quotes, double left angle bracket, end l,
semicolon. Line 5, indented once. data O K, equals, false,
semicolon. Line 6. Right brace. Line 7. if, left parenthesis, test 1,
greater than, 100, pipe, pipe, test 2, greater than, 100, pipe, pipe,
test 3, greater than, 100, right parenthesis. Line 8. Left brace. Line
9, indented once. c out, double left angle bracket, open quotes,
Invalid Data, colon, Score, left parenthesis, s, right parenthesis,
greater than 100, period, close quotes, double left angle bracket,
end l, semicolon. Line 10. data O K, equals, false, semicolon. Line
11. Right brace.
Back to Figure
Code under Quick Check Answers for question number 5.3.1.
Program code. Line 1. if, left parenthesis, left parenthesis,
temperature, greater than, 32, right parenthesis. Line 2. c out,
double left angle bracket, open quotes, Above freezing, period, close
quotes, semicolon. Line 3. else. Line 4. c out, double left angle
bracket, open quotes, Freezing or below, period, close quotes,
semicolon.
Back to Figure

Code listed under Quick Check Answers for question number 5.4.2.
Program code. Line 1. if, left parenthesis, temperature, less than,
32, right parenthesis. Line 2. c out, double left angle bracket, open
quotes, Below freezing, period, close quotes, semicolon. Line 3.
else, if, left parenthesis, temperature, equals, equals, 32, right
parenthesis. Line 4. c out, double left angle bracket, open quotes,
Freezing, period, close quotes, semicolon. Line 5. else, if, left
parenthesis, temperature, less than, 212, right parenthesis. Line 6. c
out, double left angle bracket, open quotes, Above freezing and
below boiling, period, close quotes, semicolon. Line 7. else. Line 8. c
out, double left angle bracket, open quotes, Boiling and above,
period, close quotes, semicolon.
Back to Figure
Code in exam preparation exercise 5.7. Program code. Line 1. some
I n t, not equals, 0, ampersand, ampersand, 5, forward slash, some
I n t, greater than, 10.
Back to Figure
Code in exam preparation exercise 5.10. Program code. Line 1. if,
left parenthesis, some I n t, less than or equals, 44, right
parenthesis, pipe, pipe, left parenthesis, some I n t, minus, 37, less
than, 40, right parenthesis. Line 2, indented once. c out, double left
angle bracket, open quotes, The data is within range, period, close
quotes, semicolon. Line 3. else. Line 4, indented once. c out, double
left angle bracket, open quotes, The data doesn't make sense,
period, close quotes, semicolon.
Back to Figure
Code in exam preparation exercise 5.11. Program code. Line 1. if,
left parenthesis, string 1, dot, length, left parenthesis, right
parenthesis, equals, equals, 3, ampersand, ampersand, string 1,
dot, sub s t r, left parenthesis, 0, comma, 1, right parenthesis,
equals, open quotes, T, close quotes, right parenthesis. Line 2,
indented once. c out, double left angle bracket, open quotes, The
word may be, backslash, open quotes, The, backslash, open

quotes, close quotes, semicolon. Line 3. else. Line 4. Left brace.
Line 5, indented once. string 1, equals, open quotes, The, close
quotes, semicolon. Line 6, indented once. c out, double left angle
bracket, open quotes, The word is now, backslash, open quotes,
The, backslash, open quotes, close quotes, semicolon. Line 7. Right
brace.
Back to Figure
Code in exam preparation exercise 5.12. Program code. Line 1. if,
left parenthesis, open quotes, fabs, left parenthesis, float 1, minus,
3.14, right parenthesis, less than, 0.00000001, right parenthesis.
Line 2. Left brace. Line 3, indented once. c out, double left angle
bracket, open quotes, The area of the circle of radius 6.0, close
quotes. Line 4, indented twice. Double left angle bracket, open
quotes, is approximately, colon, close quotes, double left angle
bracket, end l, semicolon. Line 5, indented once. c out, double left
angle bracket, 6.0, asterisk, 6.0, asterisk, float 1, semicolon. Line 6.
Right brace.
Back to Figure
Code in exam preparation exercise 5.13. Program code. Line 1. if,
left parenthesis, some i n t, equals, 0, right parenthesis. Line 2,
indented once. c out, double left angle bracket, open quotes, true,
close quotes, semicolon. Line 3. else. Line 4. c out, double left angle
bracket, open quotes, false, close quotes, semicolon.
Back to Figure
Code block in exam preparation exercise 5.14. Program code. Line
1. if, left parenthesis, score, less than, 50, right parenthesis. Line 2,
indented once. c out, double left angle bracket, open quotes, Failing,
close quotes, semicolon. Line 3. else, if, left parenthesis, score, less
than, 60, right parenthesis. Line 4, indented once. c out, double left
angle bracket, open quotes, Below average, close quotes,
semicolon. Line 5. else, if, left parenthesis, score, less than, 70,
right parenthesis. Line 6, indented once. c out, double left angle
bracket, open quotes, Average, close quotes, semicolon. Line 7.

else, if, left parenthesis, score, less than, 80, right parenthesis. Line
8. c out, double left angle bracket, open quotes, Above average,
close quotes, semicolon. Line 9. else, if, left parenthesis, score, less
than, 90, right parenthesis. Line 10, indented once. c out, double left
angle bracket, open quotes, Very good, close quotes, semicolon.
Line 11. else, if, left parenthesis, score, less than, 100, right
parenthesis. Line 12. c out, double left angle bracket, open quotes,
Excellent, close quotes, semicolon.
Back to Figure
Code block in exam preparation exercise 5.15. Line 1. if, left
parenthesis, score, less than, 50, right parenthesis. Line 2, indented
once. c out, double left angle bracket, open quotes, Failing, close
quotes, semicolon. Line 3. else, if, left parenthesis, score, less than,
60, right parenthesis. Line 4, indented once. c out, double left angle
bracket, open quotes, Below average, close quotes, semicolon. Line
5. else, if, left parenthesis, score, less than, 70, right parenthesis.
Line 6, indented once. c out, double left angle bracket, open quotes,
Average, close quotes, semicolon. Line 7. else, if, left parenthesis,
score, less than, 80, right parenthesis. Line 8. c out, double left
angle bracket, open quotes, Above average, close quotes,
semicolon. Line 9. else, if, left parenthesis, score, less than, 90,
right parenthesis. Line 10, indented once. c out, double left angle
bracket, open quotes, Very good, close quotes, semicolon. Line 11.
else, if, left parenthesis, score, less than, 100, right parenthesis.
Line 12. c out, double left angle bracket, open quotes, Excellent,
close quotes, semicolon.
Back to Figure
The output in programming warm-up exercise 5.4. Line 1. 12/21/01
comes before 1/27/05. Line 2. or. Line 3. 7/14/04 does not come
before 7/14/04.
Back to Figure
Code with If-Then statements that needs to changed with a nested
If-Else-If structure. Line 1. if, left parenthesis, score, greater than,

100, right parenthesis. Line 2, indented once. c out, double left angle
bracket, open quotes, Duffer, period, close quotes, semicolon. Line
3. if, left parenthesis, score, less than or equals, 100, ampersand,
ampersand, score, greater than, 80, right parenthesis. Line 4,
indented once. c out, double left angle bracket, open quotes,
Weekend regular, period, close quotes, semicolon. Line 5. if, left
parenthesis, score, less than or equals, 80, ampersand, ampersand,
score, greater than, 72, right parenthesis. Line 6, indented once. c
out, double left angle bracket, open quotes, Competitive player,
period, close quotes, semicolon. Line 7. if, left parenthesis, score,
less than or equals, 72, ampersand, ampersand, score, greater
than, 68, right parenthesis. Line 8, indented once. c out, double left
angle bracket, open quotes, Turn pro, exclamation, close quotes,
semicolon. Line 9: if, left parenthesis, score, less than or equals, 68,
right parenthesis. Line 10, indented once. c out, double left angle
bracket, open quotes, Time to go on tour, exclamation mark, close
quotes, semicolon.
Back to Figure
A program segment that needs to be corrected. It should not output
anything, yet outputs the first error message. Program code. Line 1.
maximum, equals, 75, semicolon. Line 2. minimum, equals, 25,
semicolon. Line 2. if, left parenthesis, maximum, equals, 100, right
parenthesis. Line 3. c out, double left angle bracket, open quotes,
Error in maximum, colon, space, close quotes, double left angle
bracket, maximum, double left angle bracket, end l, semicolon. Line
4. if, left parenthesis, minimum, equals, 0, right parenthesis. Line 5.
c out, double left angle bracket, open quotes, Error in minimum,
colon, space, close quotes, double left angle bracket, minimum,
double left angle bracket, end l, semicolon.
Back to Figure
A branching structure in code for which a test plan needs to be
written. Program code. Line 1. c out, double left angle bracket, open
quotes, The water is a, space, close quotes, semicolon. Line 2. if,
left parenthesis, temp, greater than or equals, 212, right
parenthesis. Line 3, indented once. c out, double left angle bracket,

open quotes, gas, period, close quotes, semicolon. Line 4. else, if,
left parenthesis, temp, greater than, 32, right parenthesis. Line 5,
indented once. c out, double left angle bracket, open quotes, liquid,
period, close quotes, semicolon. Line 6. else. Line 7, indented once.
c out, double left angle bracket, open quotes, solid, period, close
quotes, semicolon.
Back to Figure
A branching structure in code for which a test plan needs to be
written. Program code. Line 1. if, left parenthesis, month, equals,
equals, 2, ampersand, ampersand, day, greater than, 28, right
parenthesis. Line 2, indented once. if, left parenthesis, year,
percentage, 4, not equals, 0, right parenthesis. Line 3, indented
twice. c out, double left angle bracket, open quotes, Date error,
period, Not a leap year, period, close quotes. Line 4, indented once.
else. Line 5, indented twice. if, left parenthesis, day, greater than,
29, right parenthesis. Line 6, indented 3 times. c out, double left
angle bracket, open quotes, Date error, period, Improper day for
February, period, close quotes.
Back to Figure
Code for computing the number of the day of the week in
programming problem 5.6. Program code. Line 1. Left parenthesis,
start day, plus day of the year, minus, 1, right parenthesis,
percentage, 7.
Back to Figure
The input entered by the user for the program in programming
problem 5.10. 41.52 27.18 96.03.
Back to Figure
The output of the program in programming problem 5.10. The
median of 41.52, 27.18, and 96.03 is 41.52.
Back to Figure

The syntax tempalte for a while statement. Line 1. while, left
parenthesis, Expression, right parenthesis. Line 2, indented once.
Statement.
Back to Figure
An example of a while loop in code. Program code. Line 1. while, left
parenthesis, input Val, exclamation mark, equals, 25, right
parenthesis. Line 2. c in, double right angle bracket, input Val,
semicolon.
Back to Figure
A diagram explaining the flow of control in a while statement. Initially,
the expression in the while statement is evaluted. If the expression
turns out to be true, control goes to Statement 1. After statement 1
is executed, control goes back to the while statement. If the
expression turns out to be false, the while loop is exited and control
goest to Statement 2 which is outside the while block.
Back to Figure
The commonly used form of a while loop. Program code. Line 1.
while, left parenthesis, expression, right parenthesis. Line 2. Left
brace. Line 3, indented once. Period. Line 4, indented once. Period.
Line 5, indented once. Period. Line 6, Right brace.
Back to Figure
Diagrams comparing if and while. The If-Then Statement. Initially,
the expression in the if statement is evaluated. If the expression
turns out to be true, control goest to Statement 1. After Statement 1
is executed, the flow goes on to Statement 2. If the expression turns
out to be false, control goes straight away to Statement 2. The while
statement. Initially, the expression in the while statement is
executed. If the expression turns out to be true, control goes to
Statement 1. After Statement 1 is executed, control goes back to
the while statement. If the expression turns out to be false,
Statement 2 that is outside the while block is executed.

Back to Figure
A program that repeatedly outputs"Hello!" on the screen. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. This program demonstrates a count-controlled loop. Line 3.
Forward slash, forward slash, a line of asterisks. Line 4. Hash,
include, left angle bracket, i o stream, right angle bracket. Line 5.
using, name space, s t d, semicolon. Line 6, i n t, main, left
parenthesis, right parenthesis. Line 7. Left brace. Line 8, indented
once. i n t, loop Count, semicolon, tab spaces, forward slash,
forward slash, Loop control variable. Line 9, indented once. loop
Count, equals, 1, semicolon, tab space, forward slash, forward
slash, Initialization. Line 10, indented once. while, left parenthesis,
loop Count, less than or equals, 10, right parenthesis, tab space,
forward slash, forward slash, Test. Line 11, indented once. Left
brace. Line 12, indented twice. c out, double left angle bracket, open
quotes, Hello, exclamation mark, close quotes, double left angle
bracket, end l, semicolon. Line 13, indented twice. loop Count,
equals, loop Count, plus, 1, semicolon, tab space, Icrementation.
Line 14, indented once. Right brace. Line 15, indented once. return,
0, semicolon. Line 16. Right brace.
Back to Figure
While statement with test expression. Program code. Line 1. loop
Count, less than or equals, 10.
Back to Figure
Code that increments the loop control variable. Program code. Line
1. variable, equals, variable, plus, 1, semicolon.
Back to Figure
Code that uses the incrementation operator. Program code. Line 1.
loop Count, plus, plus, semicolon.
Back to Figure

An alternate way of incrementing the loop counter. Program code.
Line 1. looop Count, equals, loop Count, plus, 1, semicolon.
Back to Figure
Code demonstrating how the loop counter works in a while loop.
Program code. Line 1. loop Count, equals, 1. Line 2. while, left
parenthesis, loop Count, less than or equals, 10, right parenthesis.
Line 3. Left brace. Line 4, indented once. Period. Line 5, indented
once. Period. Line 6, indented once. Period. Line 7, indented once.
loop Count, plus, plus. Line 8. Right brace.
Back to Figure
Test expression that makes a while loop execute 11 times. Program
code. Line 1. loop Count, less than or equals, 11.
Back to Figure
A program that displays a chessboard using a loop. Program code.
Line 1. Forward slash, forward slashs, a line of asterisks. Line 2.
Forward slash, forward slash, This program displays a chessboard
pattern that is built up from. Line 3. Forward slash, forward slash,
basic strings of white and black characters. Line 4. Forward slash,
forward slash, a line of asterisks. Line 5. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 6. Hash, include, left
angle bracket, string, right angle bracket. Line 7. using, name space,
s t d, semicolon. Line 8. const, string, BLACK, equals, open quotes,
a few asterisks, close quotes, semicolon, forward slash, forward
slash, Define a line of a black square. Line 9. const, string, WHITE,
equals, open quotes, space, close quotes, semicolon, forward slash,
forward slash, Define a line of a white square. Line 10. i n t, main,
left parenthesis, right parenthesis. Line 11, Left brace. Line 12,
indented once. string, white Row, semicolon, tab spaces, forward
slash, forward slash, A row beginning with a white square. Line 13,
indented once. string, black Row, semicolon, tab spaces, forward
slash, forward slash, A row beginning with a black square. Line 14,
indented once. i n t, loop Count, equals, 0, semicolon, tab spaces,
forward slash, forward slash, A loop counter initialized to zero. Line

15, indented once. Forward slash, forward slash, Create a white-
black row by concatenating the basic strings. Line 16, indented
once. white Row, equals, WHITE, plus, BLACK, plus, WHITE, plus,
BLACK, plus. Line 17, indented a few times. WHITE, plus, BLACK,
plus, WHITE, plus, BLACK, semicolon. Line 18, indented once.
Forward slash, forward slash, Create a black-white row by
concatenating the basic strings. Line 19, indented once. black Row,
equals, BLACK, plus, WHITE, plus, BLACK, plus, WHITE, plus. Line
20, indented a few times. BLACK, plus, WHITE, plus, BLACK, plus,
WHITE, semicolon. Line 21, indented once. while, left parenthesis,
loop Count, less than, 4, right parenthesis. Line 22, indented once.
forward slash, forward slash, Output four copies of white-black,
forward slash, black-white. Line 23, indented once. Left brace. Line
24, indented twice. forward slash, forward slash, Output five white-
black rows. Line 25, indented twice. c out, double left angle
brackets, white Row, double left angle brackets, end l, semicolon.
Line 26, indented twice. c out, double left angle bracket, white Row,
double left angle bracket, end l, semicolon. Line 27, indented twice.
c out, double left angle bracket, white Row, double left angle
bracket, end l, semicolon. Line 28, indented twice. c out, double left
angle bracket, white Row, double left angle bracket, end l,
semicolon. Line 29, indented twice. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 30,
indented twice. forward slash, forward slash, Output five black-white
rows. Line 31, indented twice. c out, double left angle bracket, black
Row, double left angle bracket, end l, semicolon. Line 32, indented
twice. c out, double left angle bracket, black Row, double left angle
bracket, end l, semicolon. Line 33, indented twice. c out, double left
angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 34, indented twice. c out, double left angle bracket,
black Row, double left angle bracket, end l, semicolon. Line 35,
indented twice. c out, double left angle bracket, black Row, double
left angle bracket, end l, semicolon. Line 36, indented twice. loop
Count, plus, plus, semicolon. Line 37, indented once. Right brace.
Line 38, indented once. Right brace. Line 39. Right brace.
Back to Figure

Incorrectly coded while block. Program code. Line 1. Forward slash,
forward slash, This code is incorrect, colon. Line 2. while, left
parenthesis, not, left parenthesis, month, equals, equals,
ampersand, ampersand, day, equals, equals, 31, right parenthesis,
right parenthesis. Line 3. Left brace. Line 4, indented once. c in,
double right angle bracket, month, double right angle bracket, day,
semicolon, tab space, forward slash, forward slash, Get a date. Line
5, indented once: forward slash, forward slash, Process it. Line 6:
Right brace.
Back to Figure
Incorrectly coded while block. Program code. Line 1. Forward slash,
forward slash, This is still incorrect. Line 2. c in, double right angle
bracket, month, double right angle bracket, day, semicolon, tab
space, forward slash, forward slash, Get a date, hyphen, hyphen,
priming read. Line 3. while, left parenthesis, not, left parenthesis,
equals, equals, 2, ampersand, ampersand, day, equals, equals, 31,
right parenthesis, right parenthesis. Line 4. Left brace. Line 5,
indented once. c in, double right angle bracket, month, double right
angle bracket, day, semicolon, tab space, forward slash, forward
slash, Get a date. Line 6, indented once. colon, tab space, forward
slash, forward slash, Process it. Line 7. Right brace.
Back to Figure
Correctly coded version of a while block. Program code. Line 1.
Forward slash, forward slash, This version is correct, colon. Line 2. c
in, double right angle bracket, month, double right angle bracket,
day, semicolon, tab spaces, forward slash, forward slash, Get a
date, hyphen, hyphen, priming read. Line 3. while, left parenthesis,
exclamation mark, month, equals, equals, 2, ampersand,
ampersand, day, equals, equals, 31, right parenthesis, right
parenthesis. Line 4. Left brace. Line 5, indented once. colon, tab
space, forward slash, forward slash, Process it. Line 6, indented
once: c in, double right angle bracket, month, double right angle
bracket, day, semicolon, tab spaces, Get the next date. Line 7: Right
brace.

Back to Figure
A program that reads and displays all of the charactersf rom one line
of an input file. Program code. Line 1. Forward slash, forward slash,
a line of asterisks. Line 2. Forward slash, forward slash, Echo Line
program. Line 3. Forward slash, forward slash, This program reads
and echoes the characters from one line. Line 4. Forward slash,
forward slash, of an input file. Line 5. Forward slash, forward slash,
a line of asterisk. Line 6. Hash, include, left angle bracket, i o
stream, right angle bracket. Line 7. Hash, include, left angle bracket,
f stream, right angle bracket, tab space, forward slash, forward
slash, For file I forward slash, O. Line 8. using, name space, s t d,
semicolon. Line 9. i n t, main, left parenthesis, right parenthesis.
Line 10. Left brace. Line 11, indented once. char, in Char, semicolon.
tab spaces, forward slash, forward slash, An input character. Line
12, indented once. i f stream, in File, semicolon, forward slash,
forward slash, Data file. Line 13, indented once. in File, dot, open,
left parenthesis, open quotes, text, dot, dat, close quotes, right
parenthesis, semicolon, tab spaces, forward slash, forward slash,
Attempt to open input file. Line 14, indented once. if, left
parenthesis, not, in File, right parenthesis, tab space, forward slash,
forward slash, Was it opened, question mark. Line 15, indented
once. Left brace. Line 16, indented twice. c out, double left angle
bracket, open quotes, Can't open the input file, period, close quotes,
semicolon, forward slash, forward slash, No, hyphen, hyphen,
display message. Line 17, indented twice. return, 1, semicolon, tab
space, forward slash, forward slash, Terminate program. Line 18,
indented once. Right brace. Line 19, indented once. in File, dot, get,
left parenthesis, in Char, right parenthesis, semicolon, forward slash,
forward slash, Get first character. Line 20, indented once. while, left
parenthesis, in Char, not, equals, open single quotes, backslash, n,
close single qutoes, right parenthesis. Line 21, indented once. Left
brace. Line 22, indented twice. c out, double left angle bracket, in
Char, semicolon, tab spaces, forward slash, forward slash, Echo it.
Line 23, indented twice. in File, dot, get, left parenthesis, in Char,
right parenthesis, semicolon, tab spaces, forward slash, forward
slash, Get next character. Line 24, indented once. Right brace. Line
25, indented once. c out, double left angle bracket, end l, semicolon.
Line 26, indented once. return, 0, semicolon. Line 27. Right brace.

Back to Figure
While block that uses the wrong operator. Program code. Line 1. c
in, double right angle bracket, data Value, double right angle bracket,
sentinel, semicolon. Line 2. while, left parenthesis, sentinel, equals,
1, right parenthesis, tab space, forward slash, forward slash, Oops,
exclamation mark. Line 3. Left brace. Line 4, indented once. ellipsis.
Line 5, indented once: c in, double right angle bracket, data Value,
double right angle bracket, sentinel, semicolon. Line 6. Right brace.
Back to Figure
The name of a stream used like a Boolean variable. Program code.
Line 1. if, left parenthesis, in File, right parenthesis. Line 2. Ellipsis.
Back to Figure
A while loop that reads and echoes all the data values in the file.
Program code. Line 1. in Data, double right angle bracket, i n t Val,
semicolon, tab spaces, forward slash, forward slash, Get first value.
Line 2. while, left parenthesis, in Data, right parenthesis, tab space,
forward slash, forward slash, While the input succeeded, dot, dot,
dot. Line 3. Left brace. Line 4, indented once. c out, double left
angle bracket, i n t Val, double left angle bracket, end l, semicolon,
tab space, forward slash, forward slash, Echo it. Line 5, indented
once. in Data, double right angle bracket, i n t Val, semicolon, tab
space, Get next value. Line 6. Right brace.
Back to Figure
A program that reads and displays all integer numbers from the file
using an end of file controlled loop. Program code. Line 1. Forward
slash, forward slash, a line of asterisks. Line 2. Forward slash,
forward slash, Program Read File reads and displays all integer
numbers on file. Line 3. Forward slash, forward slash, my Data, dot,
dat using an E O F controlled loop. Line 4. Forward slash, forward
slash, a line of asterisks. Line 5. Hash, include, left angle bracket, i o
stream, right angle bracket. Line 6. Hash, include, left angle bracket,
f stream, right angle bracket. Line 7. using, name space, s t d,

semicolon. Line 8. i n t, main, left parenthesis, right parenthesis.
Line 9. Left brace. Line 10, indented once. if stream, in Data,
semicolon. Line 11, indented once. in Data, dot, open, left
parenthesis, open quotes, my Data, dot, dat, close quotes, right
parenthesis, semicolon. Line 12, indented once. i n t, i n t Value,
semicolon. Line 13, indented once. c out, double left angle bracket,
open quotes, Numbers on file my Data, dot, dat, colon, space, close
quotes, double left angle bracket, end l, semicolon. Line 14,
indented once. in Data, double right angle bracket, i n t Value,
semicolon. Line 15, indented once. while, left parenthesis, in Data,
right parenthesis. Line 16, indented once. Left brace. Line 17,
indented twice. c out, double left angle bracket, i n t Value, double
left angle bracket, open quotes, space, close quotes, semicolon.
Line 18, indented twice. in Data, double right angle bracket, int
Value, semicolon. Line 19, indented once. Right brace. Line 20,
indented once. c out, double left angle bracket, end l, semicolon.
Line 21, indented once. in Data, dot, close, left parenthesis, right
parenthesis, semicolon. Line 22, indented once. return, 0,
semicolon. Line 23. Right brace.
Back to Figure
The output of the program that reads and displays all integer
numbers from the file using an end of file controlled loop. Line 1.
Numbers on file my Data, dot, dat, colon. Line 2. 1066 1492 766
1918 1935 1941 2008 2010.
Back to Figure
Code that uses a flag-controlled loop. Program code. Line 1. sum,
equals, 0, semicolon. Line 2. non Negative, equals, true, semicolon,
tab space, forward slash, forward slash, Initialize flag. Line 3. while,
left parenthesis, non Negative, right parenthesis. Line 4. Left brace.
Line 5, indented once. c in, double right angle bracket, number,
semicolon. Line 6, indented once. if, left parenthesis, number, less
than, 0, right parenthesis, tab space, forward slash, forward slash,
Test input value. Line 7, indented twice. non Negative, equals, false,
semicolon, forward slash, forward slash, Set flag if event occurred.

Line 8, indented once. else. Line 9, indented twice. sum, equals,
sum, plus, number, semicolon. Line 10. Right brace.
Back to Figure
A program that calculates a square root using approximations.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, This program
calculates a square root using approximations. Line 3. Forward
slash, forward slash, a line of asterisks. Line 4. Hash, include, left
angle bracket, i o stream, right angle bracket. Line 5. Hash, include,
left angle bracket, c math, right angle bracket. Line 6. using, name
space, s t d, semicolon. Line 7. i n t, main, left parenthesis, right
parenthesis. Line 8. Left brace. Line 9, indented once. float, square,
semicolon. Line 10, indented once. float, guess, semicolon. Line 11,
indented once. c out, double left angle bracket, open quotes, Enter a
floating-point value, close quotes, double left angle bracket, end l,
semicolon. Line 12, indented once. c in, double right angle bracket,
square, semicolon. Line 13, indented once. guess, equals, square,
forward slash, 4.0, semicolon. Line 14, indented once. bool, good
Enough, equals, false, semicolon. Line 15, indented once. while, left
parenthesis, not, good Enough, right parenthesis. Line 16, indented
once. Left brace. Line 17, indented twice. guess, equals, left
parenthesis, left parenthesis, square, forward slash, guess, right
parenthesis, plus, guess, right parenthesis, forward slash, 2.0,
semicolon. Line 18, indented twice. c out, double left angle bracket,
guess, double left angle bracket, end l, semicolon. Line 19, indented
twice. good Enough, equals, fabs, left parenthesis, square, minus,
guess, asterisk, guess, right parenthesis, less than, 0.001,
semicolon. Line 20, indented once. Right brace. Line 21, indented
once. c out, double left angle bracket, open quotes, The square root
of, space, close quotes, double left angle bracket, square, double
left angle bracket, open quotes, space, is, space, close quotes,
double left angle bracket, guess. Line 22, indented a few times.
Double left angle bracket, end l, semicolon. Line 23, indented once.
return, 0, semicolon. Line 24. Right brace.
Back to Figure

The output of the program that calculates a square root using
approximations. Line 1. Enter a floating-point value. Line 2. 66.3.
Line 3. 10.2875. Line 4. 8.36611. Line 5. 8.14547. Line 6. 8.14248.
Line 7. The square root of 66.3 is 8.14248.
Back to Figure
Code that fragment reads and counts input characters until it comes
to a period. Program code. Line 1. count, equals, 0, semicolon, tab
spaces, forward slash, forward slash, Initialize counter. Line 2. c in,
dot, get, left parenthesis, in Char, right parenthesis, semicolon, tab
spaces, forward slash, forward slash, Read the first character. Line
3. while, left parenthesis, in Char, not equals, open single quotes,
period, close single quotes, right parenthesis. Line 4. Left brace.
Line 5, indented once. count, plus, plus, semicolon, tab spaces,
forward slash, forward slash, Increment counter. Line 6, indented
once. c in, dot, get, left parenthesis, in Char, right parenthesis,
semicolon, tab spaces, forward slash, forward slash, Get the next
character. Line 7. Right brace.
Back to Figure
Code that uses a loop to sum a set of data values. Program code.
Line 1. sum, equals, 0, semicolon, tab spaces, forward slash,
forward slash, Initialize the sum. Line 2. count, equals, 1, semicolon.
Line 3. while, left parenthesis, count, less than or equals, 10, right
parenthesis. Line 4. Left brace. Line 5, indented once. c in, double
right angle bracket, number, semicolon, tab spaces, forward slash,
forward slash, Input a value. Line 6, indented once. sum, equals,
sum, plus, number, semicolon, tab spaces, forward slash, forward
slash, Add the value to sum. Line 7, indented once. count, plus,
plus, semicolon. Line 8. Right brace.
Back to Figure
Code that adds the current value of sum to number to produce the
new value of sum. Program code. Line 1. sum, equals, sum, plus,
number, semicolon.

Back to Figure
A program that reads and sums 10 odd numbers. Program code.
Line 1. Forward slash, forward slash, a line of asterisks. Line 2.
Forward slash, forward slash, This program reads and sums odd
numbers until 10 numbers. Line 3. Forward slash, forward slash,
have been read. Line 4. Forward slash, forward slash, a line of
asterisks. Line 5. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 6. using, name space, s t d, semicolon. Line 7. i
n t, main, left parenthesis, right parenthesis. Line 8. Left brace. Line
9, indented once. i n t, count, equals, 0, semicolon, tab spaces,
forward slash, forward slash, Initialize event counter. Line 10,
indented once. i n t, sum, equals, 0, semicolon, tab spaces, forward
slash, forward slash, Initialize sum. Line 11, indented once. bool,
less Than Ten, equals, true, semicolon, tab spaces, forward slash,
forward slash, Initialize loop control flag. Line 12, indented once. i n
t, number, semicolon, tab spaces, forward slash, forward slash,
Used for reading. Line 13, indented once. c out, double left angle
bracket, open quotes, Enter a data set that contains at least 10 odd
numbers, close quotes. Line 14, indented a few times. Double left
angle bracket, end l, semicolon. Line 15, indented once. while, left
parenthesis, less Than Ten, right parenthesis. Line 16, indented
once. Left brace. Line 17, indented twice. c in, double right angle
bracket, number, semicolon, tab spaces, forward slash, forward
slash, Get the next value. Line 18, indented twice. if, left
parenthesis, number, modulo, 2, equals, equals, 1, right parenthesis,
tab spaces, forward slash, forward slash, Is the value odd, question
mark. Line 19, indented twice. Left brace. Line 20, indented 3 times.
count, plus, plus, semicolon, tab spaces, forward slash, forward
slash, Yes, hyphen, hyphen, increment counter. Line 21, indented 3
times. sum, equals, sum, plus, number, semicolon, tab spaces,
forward slash, forward slash, Add value to sum. Line 22, indented 3
times. less Than Ten, equals, left parenthesis, count, less than, 10,
right parenthesis, semicolon, tab spaces, forward slash, forward
slash, Update loop control flag. Line 23, indented twice. Right brace.
Line 24, indented once. Right brace. Line 25, indented once. c out,
double left angle bracket, open quotes, The sum of the first 10 odd
numbers is, space, close quotes, double left angle bracket, sum.
Line 26, indented a few times. Double left angle bracket, open

quotes, period, close quotes, double left angle bracket, end l,
semicolon. Line 27, indented once. return, 0, semicolon. Line 28.
Right brace.
Back to Figure
Output of the program that reads and sums 10 odd numbers. Line
1. Enter a data set that contains at least 10 odd numbers. Line 2. 21
23 25 35 39 22 44 97 99 99 21 35 46 99. Line 3. The sum of the first
10 odd numbers is 494.
Back to Figure
One way of writing the while expression. Program code. Line 1.
while, left parenthesis, count, less than, 10, right parenthesis.
Back to Figure
Some initialization statements. Program code. Line 1. i n t, count,
equals, 0, semicolon. Line 2. i n t, sum, equals, 0, semicolon.
Back to Figure
A program that counts the occurrence of the not equals symbol in a
data file. Program code. Line 1. Forward slash, forward slash, a line
of asterisks. Line 2. Forward slash, forward slash, This program
counts the occurrences of open quotes, not equals, close quotes in
a data file. Line 3. Forward slash, forward slash, a line of asterisks.
Line 4. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 5. Hash, include, left angle bracket, f stream, right
angle bracket, forward slash, forward slash, For file I forward slash,
O. Line 6. using, name space, s t d, semicolon. Line 7. i n t, main,
left parenthesis, right parenthesis. Line 8. Left brace. Line 9,
indented once. i n t, count, semicolon, tab space, forward slash,
forward slash, Number of not equals, operators. Line 10, indented
once. char, prev Char, semicolon, tab space, forward slash, forward
slash, Last character read. Line 11, indented once. char, c u r r
Char, semicolon, tab space, forward slash, forward slash, Character
read in this iteration. Line 12, indented once. if stream, in File,
semicolon, forward slash, forward slash, Data file. Line 13, indented

once. in File, dot, open, left parenthesis, open quotes, my file, dot,
dat, close quotes, right parenthesis, semicolon, tab space, forward
slash, forward slash, Attempt to open file. Line 14, indented once. if,
left parenthesis, not, in File, right parenthesis. Line 15, indented
once. Left brace, forward slash, forward slash, If file wouldn't open,
comma, display message, comma, terminate program. Line 16,
indented twice. c out, double left angle bracket, open quotes, Can't
open input file, close quotes, double left angle bracket, end l,
semicolon. Line 17, indented twice. return, 1, semicolon. Line 18,
indented once. Right brace. Line 19, indented once. count, equals,
0, semicolon, tab space, forward slash, forward slash, Initialize
counter. Line 20, indented once. in File, dot, get, left parenthesis,
prev Char, right parenthesis, semicolon, tab space, forward slash,
forward slash, Initialize previous value. Line 21, indented once. in
File, dot, get, left parenthesis, c u r r Char, right parenthesis,
semicolon, tab space, forward slash, forward slash, Initialize current
value. Line 22, indented once. while, left parenthesis, in File, right
parenthesis, tab space, forward slash, forward slash, While input
succeeds, period, period, period. Line 23, indented once. Left brace.
Line 24, indented twice. if, left parenthesis, c u r r Char, equals,
equals, open single quotes, equals, close single quotes, ampersand,
ampersand, tab space, forward slash, forward slash, Test for not
equals. Line 25, indented a few times. prev Char, equals, equals,
open single quotes, exclamation mark, close single quotes, right
parenthesis. Line 26, indented 3 times. count, plus, plus, semicolon,
tab space, forward slash, forward slash, Increment counter. Line 27,
indented twice. prev Char, equals, c u r r Char, semicolon, tab
space, forward slash, forward slash, Update previous value to
current. Line 28, indented twice. in File, dot, get, left parenthesis, c u
r r Char, right parenthesis, semicolon, tab space, forward slash,
forward slash, Get next value. Line 29, indented once. Right brace.
Line 30, indented once. c out, double left angle bracket, count,
double left angle bracket, open quotes, not equals, operators were
found, period, close quotes, double left angle bracket, end l,
semicolon. Line 31, indented once. return, 0, semicolon. Line 32.
Right brace.
Back to Figure

The contents in the file, my file dot dat. Line 1. less than or equals,
not, not, not, equals, equals, equals, not equals, not, space, equals,
not equals.
Back to Figure
The output of the program that counts the occurrence of the not
equals symbol in a dat file. Line 1. 2 not equals operators were
found.
Back to Figure
Code that calculates mortgage payments. Program code. Line 1. c
in, double right angle bracket, loan Amount, double right angle
bracket, yearly Interest, double right angle bracket, number Of
Payments, semicolon. Line 2. number Of Payments, equals, number
Of Years, asterisk, 12, semicolon. Line 3. while, left parenthesis,
loan Amount, greater than, 0, right parenthesis. Line 4. Left brace.
Line 5, indented once. Forward slash, forward slash, Calculate
values. Line 6, indented once. if, left parenthesis, yearly Interest,
greater than or equals, 0.25, right parenthesis, tab space, forward
slash, forward slash, Assume percent entered. Line 7, indented
twice. yearly Interest, equals, yearly Interest, forward slash, 100.0,
semicolon. Line 8, indented once. monthly Interest, equals, yearly
Interest, forward slash, 12, semicolon. Line 9, indented once.
payment, equals, left parenthesis, loan Amount, asterisk, pow, left
parenthesis, 1, plus, monthly Interest, comma, number Of
Payments, right parenthesis. Line 10, indented twice. Asterisk,
monthly Interest, right parenthesis, forward slash. Line 11, indented
twice. left parenthesis, pow, left parenthesis, 1, plus, monthly
Interest, comma, number Of Payments, right parenthesis, minus, 1,
right parenthesis, semicolon. Line 12, indented once. Forward slash,
forward slash, Output results. Line 13, indented once. period,
period, period. Line 14. Right brace.
Back to Figure
Modified version of the code for mortgage payments. Program code.
Line 1. c in, double right angle bracket, loan Amount, double right

angle bracket, yearly Interest, double right angle bracket, number Of
Payments, semicolon. Line 2. number Of Payments, equals, number
Of Years, asterisk, 12, semicolon. Line 3. while, left parenthesis,
loan Amount, greater than, 0, right parenthesis. Line 4. Left brace.
Line 5, indented once. period, period, period. Line 6, indented once.
c in, double right angle bracket, loan Amount, double right angle
bracket, yearly Interest, double right angle bracket, number Of
Payments, semicolon. Line 7. Right brace.
Back to Figure
A program that calculates the monthly payments on a loan given,
the yearly interest rate, and the number of payments. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, Loan Payment program. Line 3.
Forward slash, forward slash, This program determines the monthly
payments on a loan given. Line 4. Forward slash, forward slash, the
loan amount, the yearly interest rate, and the number of. Line 5.
Forward slash, forward slash, months, left parenthesis, payments,
right parenthesis, period. Line 6. Forward slash, forward slash, The
process repeats until a negative loan amount is entered. Line 7.
Forward slash, forward slash, a line of asterisks. Lines 1 to 7 are
highlighted. Line 8. Hash, include, left angle bracket, c math, right
angle bracket. Line 9. Hash, include, left angle bracket, i o manip,
right angle bracket. Line 10. hash, include, left angle bracket, i o
stream, right angle bracket. Line 11. using, name space, s t d,
semicolon. Line 12. i n t, main, left parenthesis, right parenthesis.
Line 13. Left brace. Line 14, indented once. Forward slash, forward
slash, Input variables. Line 15. float, loan Amount, semicolon. Line
16, indented once. float, yearly Interest, semicolon. Line 17,
indented once. i n t, number Of Years, semicolon. Line 18, indented
once. Forward slash, forward slash, Local variables. Line 19,
indented once. float, monthly Interest, semicolon. Line 20, indented
once. i n t, number Of Payments, semicolon. Line 21, indented
once. float, payment, semicolon. Line 22, indented once. Forward
slash, forward slash, Prompts. Line 23, indented once. c out, double
left angle bracket, open quotes, Input loan amount, comma, interest
rate, comma, and number of years, period, close quotes. Line 24,
indented a few times. Double left angle bracket, end l, semicolon.

Line 25, indented once. c out, double left angle bracket, open
quotes, An interest rate of less than 0.25 is assumed to be, space,
close quotes. Line 26, indented a few times. Double left angle
bracket, end l, semicolon. Line 27, indented once. c out, double left
angle bracket, open quotes, a decimal rather than a percent, period,
close quotes, double left angle bracket, end l, semicolon. Line 28,
indented once. c out, double left angle bracket, open quotes, A
negative loan amount ends the program, period, close quotes,
double left angle bracket, end l, semicolon. This line is highlighted.
Line 29, indented once. Forward slash, forward slash, Read values.
Line 30, indented once. c in, double right angle bracket, loan
Amount, semicolon. Line 31, indented once. while, left parenthesis,
loan Amount, greater than, 0, right parenthesis. Lines 30 and 31 are
highlighted. Line 32, indented once. Left brace. Line 33, indented
twice. c in, double right angle bracket, yearly Interest, double right
angle bracket, number Of Payments, semicolon. This line is
highlighted. Line 34, indented twice. number Of Payments, equals,
number Of Years, asterisk, 12, semicolon. Line 35, indented twice.
Forward slash, forward slash, Calculate values. Line 36, indented
twice. if, left parenthesis, yearly Interest, greater than or equals,
0.25, right parenthesis, tab space, Forward slash, forward slash,
Assume percent entered. Line 37, indented 3 times. yearly Interest,
equals, yearly Interest, forward slash, 100.0, semicolon. Line 38,
indented twice. monthly Interest, equals, yearly Interest, forward
slash, 12, semicolon. Line 39, indented twice. payment, equals, left
parenthesis, loan Amount, asterisk, pow, left parenthesis, 1, plus,
monthly Interest, comma. Line 40, indented twice. number Of
Payments, right parenthesis, asterisk, monthly Interest, right
parenthesis, forward slash. Line 41, indented 3 times. left
parenthesis, pow, left parenthesis, 1, plus, monthly Interest, comma,
number Of Payments, right parenthesis, minus, 1, right parenthesis,
semicolon. Line 42, indented twice. Forward slash, forward slash,
Output results. Line 43, indented twice. c out, double left angle
bracket, fixed, double left angle bracket, open quotes, Loan amount,
colon, space, close quotes, double left angle bracket, set precision,
left parenthesis, 2, right parenthesis. Line 44, indented a few times.
Double left angle bracket, loan Amount, double left angle bracket,
end l, double left angle bracket, open quotes, Interest rate, colon,
space, close quotes. Line 45, indented a few times. Double left

angle bracket, set precision, left parenthesis, 4, right parenthesis,
double left angle bracket, yearly Interest, asterisk, 100.0, double left
angle bracket, open quotes, percentage, close quotes, double left
angle bracket, end l. Line 46, indented a few times. Double left angle
bracket, open quotes, Number of payments, colon, space, close
quotes, double left angle bracket, number Of Payments, double left
angle bracket, end l, semicolon. Line 47, indented twice. c out,
double left angle bracket, fixed. Line 48, indented a few times.
Double left angle bracket, open quotes, Monthly payments, colon,
space, double left angle bracket, set precision, left parenthesis, 2,
right parenthesis, double left angle brackets, payment, double left
angle bracket, end l, semicolon. Lines 39 to 48 are highlighted. Line
49, indented twice. c out, double left angle bracket, fixed, double left
angle bracket, open quotes, Total Interest, colon, a few spaces,
close quotes double left angle bracket, set precision, left
parenthesis, 2, right parenthesis. Line 50, indented a few times.
Double left angle bracket, left parenthesis, payment, asterisk,
number Of Payments, minus, loan Amount, right parenthesis,
double left angle bracket, end l, semicolon. Line 51, indented twice.
Forward slash, forward slash, Prompts. Line 52, indented twice. c
out, double left angle bracket, open quotes, Input loan amount,
comma, interest rate, comma, and number of months, period, close
quotes. Line 53, indented a few times. Double left angle bracket,
end l, semicolon. Line 54, indented twice. c out, double left angle
bracket, open quotes, An interest rate of less than 0.25 is assumed
to be, space, close quotes. Line 55, indented a few times. Double
left angle bracket, end l, semicolon. Line 56, indented twice. c out,
double left angle bracket, open quotes, a decimal rather than a
percent, period, close quotes, double left angle bracket, end l,
semicolon. Line 57, indented twice. c out, double left angle bracket,
open quotes, A negative loan amount ends the program, period,
close quotes, double left angle bracket, end l, semicolon. Line 58,
indented twice. c in, double right angle bracket, loan Amount,
semicolon. Line 59, indented once. Right brace. Line 60, indented
once. return, 0, semicolon. Line 61. Right brace.
Back to Figure

"The output of the program that calculates the monthly payments on
a loan given, the yearly interest rate, and the number of payments.
Line 1. Input loan amount, interest rate, and number of years. Line
2. An interest rate of less than 0.25 is assumed to be. Line 3. a
decimal rather than a percent. Line 4. A negative loan amount ends
the program. Line 5. 3000 6.8 24. This line is highlighted. Line 6.
Loan amount: 3000.00. Line 7. Interest rate: 6.8000%. Line 8.
Number of payments: 288. Line 9. Monthly payments: 21.16. Line
10. Total Interest: 3092.92. Line 11. Input loan amount, interest rate,
and number of months. Line 12. An interest rate of less than 0.25 is
assumed to be a decimal rather than a percent. Line 13. A negative
loan amount ends the program. Line 14. 25000 5.4 60. This line is
highlighted. Line 15. Loan amount: 25000.00. Line 16. Interest rate:
5.4000%. Line 17. Number of payments: 720. Line 18. Monthly
payments: 117.12. Line 19. Total Interest: 59326.53. Line 20. Input
loan amount, interest rate, and number of months. Line 21. An
interest rate of less than 0.25 is assumed to be. Line 22. a decimal
rather than a percent. Line 23. A negative loan amount ends the
program. Lines 17 to 23 are highlighted. Line 24. -2. This line is
highlighted."
Back to Figure
A code segment. Program code. Line 1. comma Count, equals, 1,
semicolon, tab space, forward slash, forward slash, This code is
incorrect. Line 2. c in, dot, get, left parenthesis, in Char, right
parenthesis, semicolon. Line 3. while, left parenthesis, in Char, not
equals, open single quotes, backslash, n, close single quotes, right
parenthesis. Line 4. Left brace. Line 5, indented once. if, left
parenthesis, in Char, equals, equals, open single quotes, comma,
close single quotes, right parenthesis. Line 6, indented twice.
comma Count, plus, plus, semicolon. Line 7, indented once. c in,
dot, get, left parenthesis, in Char, right parenthesis, semicolon. Line
8. Right brace. Line 9. c out, double left angle bracket, comma
Count, double left angle bracket, end l, semicolon.
Back to Figure

Code that contains nested logic. Program code. Line 1. c in, dot,
get, left parenthesis, in Char, right parenthesis, semicolon, tab
spaces, forward slash, forward slash, Initialize outer loop. Line 2.
while, left parenthesis, c in, right parenthesis, tab spaces, forward
slash, forward slash, Outer loop test. Line 3. Left brace. Line 4,
indented once. comma Count, equals, 0, semicolon, tab spaces,
forward slash, forward slash, Initialize inner loop. Line 4, indented a
few times. Forward slash, forward slash, left parenthesis, Priming
read is taken care of. Line 5, indented a few times. Forward slash,
forward slash, by outer loop's priming read, right parenthesis. Line 6,
indented once. while, left parenthesis, in Char, not equals, open
single quotes, backslash, n, close single quotes, right parenthesis,
tab spaces, forward slash, forward slash, Inner loop test. Line 7,
indented once. Left brace. Line 8, indented twice. if, left parenthesis,
in Char, equals, equals, open single quotes, comma, close single
quotes, right parenthesis. Line 8, indented 3 times. comma Count,
plus, plus, semicolon. Line 9, indented twice. c in, dot, get, left
parenthesis, in Char, right parenthesis, semicolon, forward slash,
forward slash, Update inner termination condition. Line 10, indented
once. Right brace. Line 11, indented once. c out, double left angle
bracket, comma Count, double left angle bracket, end l, semicolon.
Line 12. c in, dot, get, left parenthesis, in Char, right parenthesis,
semicolon, tab spaces, forward slash, forward slash, Update outer
termination condition. Line 13. Right brace.
Back to Figure
The general pattern of a simple nested loop. The dots represent
places where the processing and update may take place in the outer
loop. Line 1. Initialize outer loop. Line 2. while, left parenthesis,
Outer loop condition, right parenthesis. Line 3. Left brace. Line 4,
indented once. Dots. Line 5, indented once. Initialize inner loop. Line
6, indented once. while, left parenthesis, Inner loop condition, right
parenthesis. Line 7, indented once. Left brace. Line 8, indented
twice. Inner loop processing and update. Line 9, indented once.
Right brace. Line 10, indented once. Dots. Line 11. Right brace.
Back to Figure

Code for nested count-controlled loops. Program code. Line 1. out
Count, equals, 1, semicolon, tab spaces, forward slash, forward
slash, Initialize outer loop counter. line 2. while, left parenthesis, out
Count, less than or equals, limit 1, right parenthesis. Line 3. Left
brace. Line 4, indented once. Dots. Line 5, indented once. in Count,
equals, 1, semicolon, tab spaces, forward slash, forward slash,
Initialize inner loop counter. Line 6, indented once. while, left
parenthesis, in Count, less than or equals, limit 2, right parenthesis.
Line 7, indented once. Left brace. Line 8, indented once. Dots. Line
9, indented twice. in Count, plus, plus, semicolon, tab spaces,
forward slash, forward slash, Increment inner loop counter. Line 10,
indented once. Right brace. Line 11, indented once. Dots. Line 12,
indented once. out Count, plus, plus, semicolon, tab spaces, forward
slash, forward slash, Increment outer loop counter. Line 13. Right
brace.
Back to Figure
A program that reads in a number and displays that many asterisks.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, Program Stars
reads in a number and displays that. Line 3. Forward slash, forward
slash, many asterisks. Line 4. Forward slash, forward slash, a line of
asterisks. Line 5. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 6. using, name space, s t d, semicolon. Line 7. i
n t, main, left parenthesis, right parenthesis. Line 8. Left brace. Line
9, indented once. i n t, star Count, semicolon. Line 10, indented
once. i n t, loop Count, semicolon. Line 11, indented once. c out,
double left angle bracket, open quotes, Enter the number of stars,
semicolon, close quotes, double left angle bracket, end l. Line 12,
indented a few times. Double left angle bracket, open quotes, open
single quotes, Q, close single quotes, ends the program, period,
close quotes, double left angle bracket, end l, semicolon. Line 13,
indented once. c in, double right angle bracket, star Count,
semicolon, tab spaces, forward slash, forward slash, 1. Line 14,
indented once. while, left parenthesis, c in, right parenthesis, tab
space, forward slash, forward slash, 2. Line 15, indented once. Left
brace. Line 16, indent twice. loop Count, equals, 1, semicolon, tab
spaces, forward slash, forward slash, 3. Line 17, indented twice.

while, left parenthesis, loop Count, less than or equals, star Count,
right parenthesis, tab spaces, forward slash, forward slash, 4. Line
18, indented twice. Left brace. Line 19, indented 3 times. c out,
double left angle bracket, open single quotes, asterisk, close single
quotes, semicolon, tab spaces, forward slash, forward slash, 5. Line
20, indented 3 times. loop Count, plus, plus, semicolon, tab spaces,
forward slash, forward slash, 6. Line 21, indented twice. Right brace.
Line 22, indented twice. c out, double left angle bracket, end l,
semicolon, tab spaces, forward slash, forward slash, 7. Line 23,
indented twice. c out, double left angle bracket, open quotes, Enter
the number of stars, semicolon, space, close quotes, tab spaces,
forward slash, forward slash, 8. line 24, indented a few times.
Double left angle bracket, open quotes, open single quotes, Q, close
single quotes, ends the program, period, close quotes, double left
angle bracket, end l, semicolon. Line 25, indented twice. c in, double
right angle bracket, star Count, semicolon, tab spaces, forward
slash, forward slash, 9. Line 26, indented once. Right brace. Line
27, indented once. c out, double left angle bracket, open quotes,
Goodbye, close quotes, double left angle bracket, end l, semicolon,
tab spaces, forward slash, forward slash, 10. Line 28, indented
once. return, 0, semicolon. Line 29. Right brace.
Back to Figure
The output of the program that reads in a number and displays that
many asterisks. Line 1. Enter the number of stars; 'Q' ends the
program. Line 2. 3. Line 4. Asterisk, asterisk, asterisk. Line 4. Enter
the number of stars; 'Q' ends the program. Line 5. 5. Line 6.
Asterisk, asterisk, asterisk, asterisk, asterisk. Line 7. Enter the
number of stars; 'Q' ends the program. Line 8. 1. Line 9. Asterisk.
Line 10. Enter the number of stars; 'Q' ends the program. Line 11.
Q. Line 12. Goodbye.
Back to Figure
A table showing code trace for the program that reads in a number
and displays that many asterisks. The table has the following column
headings. Statement. Star Count variable. Loop Count variable. c in
logical expression. Loop count less than or equals star count logical

expression. Output. Row 1: Statement, 1.1; Star Count variable, 3;
Loop Count variable, blank; c in logical expression, blank; Loop
count less than or equals star count logical expression, blank;
Output, blank. Row 2: Statement, 2.1; Star Count variable, 3; Loop
Count variable, blank; c in logical expression, T; Loop count less
than or equals star count logical expression, blank; Output, blank.
Row 3: Statement, 3.1; Star Count variable, 3; Loop Count variable,
1; c in logical expression, blank; Loop count less than or equals star
count logical expression, blank; Output, blank. Row 4: Statement,
4.1; Star Count variable, 3; Loop Count variable, 1; c in logical
expression, blank; Loop count less than or equals star count logical
expression, T; Output, blank. Row 5: Statement, 5.1; Star Count
variable, 3; Loop Count variable, 1; c in logical expression, blank;
Loop count less than or equals star count logical expression, blank;
Output, asterisk. Row 6: Statement, 6.1; Star Count variable, 3;
Loop Count variable, 2; c in logical expression, blank; Loop count
less than or equals star count logical expression, blank; Output,
blank. Row 7: Statement, 4.2; Star Count variable, 3; Loop Count
variable, 2; c in logical expression, blank; Loop count less than or
equals star count logical expression, T; Output, blank. Row 8:
Statement, 5.2; Star Count variable, 3; Loop Count variable, 2; c in
logical expression, blank; Loop count less than or equals star count
logical expression, blank; Output, asterisk. Row 9: Statement, 6.2;
Star Count variable, 3; Loop Count variable, 3; c in logical
expression, blank; Loop count less than or equals star count logical
expression, blank; Output, blank. Row 10: Statement, 4.3; Star
Count variable, 3; Loop Count variable, 3; c in logical expression,
blank; Loop count less than or equals star count logical expression,
T; Output, blank. Row 11: Statement, 5.3; Star Count variable, 3;
Loop Count variable, 3; c in logical expression, blank; Loop count
less than or equals star count logical expression, blank; Output,
asterisk. Row 12: Statement, 6.3; Star Count variable, 3; Loop
Count variable, 4; c in logical expression, blank; Loop count less
than or equals star count logical expression, blank; Output, blank.
Row 13: Statement, 4.4; Star Count variable, 3; Loop Count
variable, 4; c in logical expression, blank; Loop count less than or
equals star count logical expression, F; Output, blank. Row 14:
Statement, 7.1; Star Count variable, 3; Loop Count variable, 4; c in
logical expression, blank; Loop count less than or equals star count

logical expression, blank; Output, backslash n (newline). Row 15:
Statement, 8.1; Star Count variable, 3; Loop Count variable, 4; c in
logical expression, blank; Loop count less than or equals star count
logical expression, blank; Output, (Prompt). Row 16: Statement, 9.1;
Star Count variable, 1; Loop Count variable, 4; c in logical
expression, blank; Loop count less than or equals star count logical
expression, blank; Output, blank. Row 17: Statement, 2.2; Star
Count variable, 1; Loop Count variable, 4; c in logical expression, T;
Loop count less than or equals star count logical expression, blank;
Output, blank. Row 18: Statement, 3.2; Star Count variable, 1; Loop
Count variable, 1; c in logical expression, blank; Loop count less
than or equals star count logical expression, blank; Output, blank.
Row 19: Statement, 4.5; Star Count variable, 1; Loop Count
variable, 1; c in logical expression, blank; Loop count less than or
equals star count logical expression, T; Output, blank. Row 20:
Statement, 5.4; Star Count variable, 1; Loop Count variable, 1; c in
logical expression, blank; Loop count less than or equals star count
logical expression, blank; Output, asterisk. Row 21: Statement, 6.4;
Star Count variable, 1; Loop Count variable, 2; c in logical
expression, blank; Loop count less than or equals star count logical
expression, blank; Output, blank. Row 22: Statement, 4.6; Star
Count variable, 1; Loop Count variable, 2; c in logical expression,
blank; Loop count less than or equals star count logical expression,
F; Output, blank. Row 23: Statement, 7.2; Star Count variable, 1;
Loop Count variable, 2; c in logical expression, blank; Loop count
less than or equals star count logical expression, blank; Output,
backslash n (newline). Row 24: Statement, 8.2; Star Count variable,
1; Loop Count variable, 2; c in logical expression, blank; Loop count
less than or equals star count logical expression, blank; Output,
(Prompt). Row 25: Statement, 9.2; Star Count variable, 1; Loop
Count variable, 2; c in logical expression, blank; Loop count less
than or equals star count logical expression, blank; Output,
underscore (null exception). Row 26: Statement, 2.3; Star Count
variable, 1; Loop Count variable, 2; c in logical expression, F; Loop
count less than or equals star count logical expression, blank;
Output, blank. Row 27: Statement, 10.1; Star Count variable, 1;
Loop Count variable, 2; c in logical expression, blank; Loop count
less than or equals star count logical expression, blank; Output,
Goodbye.

Back to Figure
A program that displays a chessboard pattern built up of basic
strings of white and black characters. Program code. Line 1.
Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, Chessboard program. Line 3. Forward slash,
forward slash, This program displays a chessboard pattern that is
built up from. Line 4. Forward slash, forward slash, basic strings of
white and black characters. Line 5. Forward slash, forward slash, a
line of asterisks. Line 6. Hash, include, left angle bracket, i o stream,
right angle bracket. Line 7. Hash, include, left angle bracket, string,
right angle bracket. Line 8. using, name space, s t d, semicolon.
Line 9. const, string, BLACK, equals, open quotes, a few asterisk,
close quotes, semicolon, tab space, forward slash, forward slash,
Define a line of a black square. Line 10. const, string, WHITE,
equals, open quotes, space, close quotes, semicolon, forward slash,
forward slash, Define a line of a white square. Line 11. i n t, main,
left parenthesis, right parenthesis. Line 12. Left brace. Line 13,
indented once. string, white Row, semicolon, tab space, forward
slash, forward slash, A row beginning with a white square. Line 14,
indented once. string, black Row, semicolon, forward slash, forward
slash, A row beginning with a black square. Line 15, indented once. i
n t, loop Count, semicolon, tab space, forward slash, forward slash,
A loop counter. Line 16, indented once. i n t, loop Count 2,
semicolon, forward slash, forward slash, Second loop counter. Line
17, indented once. Forward slash, forward slash, Create a white-
black row by concatenating the basic strings. Line 18, indented
once. white Row, equals, WHITE, plus, BLACK, plus, WHITE, plus,
BLACK, plus. Line 19, indented a few times. WHITE, plus, BLACK,
plus, WHITE, plus, BLACK, semicolon. Line 20, indented once.
Forward slash, forward slash, Create a black-white row by
concatenating the basic strings. Line 21, indented once. black Row,
equals, BLACK, plus, WHITE, plus, BLACK, plus, WHITE, plus. Line
22, indented a few times. BLACK, plus, WHITE, plus, BLACK, plus,
WHITE, semicolon. Line 23, indented once. loop Count, equals, 0,
semicolon. Line 24, indented once. while, left parenthesis, loop
Count, less than, 4, right parenthesis. Line 25, indented once.
Forward slash, forward slash, Output four copies of white-black,
forward slash, black-white. Line 26, indented once. Left brace. Line

27, indented twice. Forward slash, forward slash, Output five white-
black rows. Line 28, indented twice. loop Count, 2, equals, 0,
semicolon. Line 29, indented twice. while, left parenthesis, loop
Count 2, less than, 5, right parenthesis. Line 30, indented twice. Left
brace. Line 31, indented 3 times. c out, double left angle bracket,
white Row, double left angle bracket, end l, semicolon. Line 32,
indented 3 times. loop Count 2, plus, plus, semicolon. Line 33,
indented twice. Right brace. Line 34, indented twice. loop Count 2,
equals, 0, semicolon. Line 35, indented twice. Forward slash,
forward slash, Output five black-white rows. Line 36, indented twice.
while, left parenthesis, loop Count 2, less than, 5, right parenthesis.
Line 37, indented twice. Left brace. Line 38, indented 3 times. c out,
double left angle bracket, black Row, double left angle bracket, end l,
semicolon. Line 39, indented 3 times. loop Count 2, plus, plus,
semicolon. Line 40, indented twice. Right brace. Line 41, indented
twice. loop Count, plus, plus, semicolon. Line 42, indented once.
Right brace. Line 43, indented once. return, 0, semicolon. Line 44.
Right brace.
Back to Figure
The formula for the work done by an algorithm with an N-iteration
loop. S 1 times N plus S 0. S 1 times N refers to steps performed by
the loop. S 0 refers to steps performed outside the loop.
Back to Figure
The formula for the work done by an a data-dependent loop that
contains a nested loop. S 2 times L times N plus S 1 times N plus S
0. S 2 times L times N refers to the steps performed by the nested
loop. S 1 times N refers to the steps performed by the outer loop. S
0 refers to the steps performed outside the outer loop.
Back to Figure
The formula for the total steps supposing that for each of the N
outer loop iterations, the inner loop performs N steps, that is L
equals N. (S 2 times N times N) plus (S 1 times N) plus S 0.

Back to Figure
An alternate formula for the total steps supposing that for each of
the N outer loop iterations, the inner loop performs N steps, that is L
equals N. (S 2 times N^2) plus (S 1 times N) plus S 0.
Back to Figure
The formula for a doubly nested loop in which each loop depends on
N. (S 3 times N^3) plus (S 2 times N^2) plus (S 1 times N) plus S 0.
Back to Figure
A table showing the number of steps required for each increase in
the exponent of N, where N is a size factor for the problem, such as
the number of input values. The table has 6 rows and 5 columns. It
has the following column headings. N. N^0 (Constant). N^1 (Linear).
N^2 (Quadratic). N^3 (Cubic). The row details are the following. Row
1: N, 1; N^0 (Constant), 1; N^1 (Linear), 1; N^2 (Quadratic), 1; N^3
(Cubic), 1. Row 2: N, 10; N^0 (Constant), 1; N^1 (Linear), 10; N^2
(Quadratic), 100; N^3 (Cubic), 1000. Row 3: N, 100; N^0 (Constant),
1; N^1 (Linear), 100; N^2 (Quadratic), 10,000; N^3 (Cubic),
1,000,000. Row 4: N, 1000; N^0 (Constant), 1; N^1 (Linear), 1000;
N^2 (Quadratic), 1,000,000; N^3 (Cubic), 1,000,000,000. Row 5: N,
10,000; N^0 (Constant), 1; N^1 (Linear), 10,000; N^2 (Quadratic),
1,000,000,000; N^3 (Cubic), 1,000,000,000,000. Row 6: N, 100,000;
N^0 (Constant), 1; N^1 (Linear), 100,000; N^2 (Quadratic),
10,000,000,000; N^3 (Cubic), 1,000,000,000,000,000.
Back to Figure
Module structure chart for the recording studio design algorithm.
The main module is at the top of the hierarchy under which are the
following modules. Initialize process. Initialize loop ending condition.
Update process. Update loop ending condition. Print high and low
readings. The update process module has the following sub
modules. Check for new high. Check for new low.
Back to Figure

The program for the recording studio design problem. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, Acoustic program. Line 3. Forward
slash, forward slash, This program inputs 12 sound-level readings,
taken in a room. Line 4. Forward slash, forward slash, at different
frequencies. The first reading is used as a. Line 5. Forward slash,
forward slash, base value. For each reading, a value relative to the
base is. Line 6. Forward slash, forward slash, calculated and output.
The program ends by displaying the. Line 7. Forward slash, forward
slash, highest reading and the lowest reading. Line 8. Forward slash,
forward slash, a line of asterisks. Line 9. Hash, include, left angle
bracket, i o stream, right angle bracket. Line 10. Hash, include, left
angle bracket, f stream, right angle bracket. Line 11. Hash, include,
left angle bracket, i o manip, right angle bracket. Line 12. using,
name space, s t d, semicolon. Line 13. i n t, main, left parenthesis,
right parenthesis. Line 14. Left brace. Line 15, indented once.
Forward slash, forward slash, Declare variables. Line 16, indented
once. float, base Value, semicolon, tab spaces, forward slash,
forward slash, First reading. Line 17, indented once. float, current,
semicolon, tab spaces, forward slash, forward slash, Input during
each iteration. Line 18, indented once. float, relative, semicolon, tab
spaces, forward slash, forward slash, Current minus base value.
Line 19, indented once. float, high, semicolon, tab spaces, forward
slash, forward slash, Highest value input. Line 20, indented once.
float, high Relative, semicolon, tab spaces, forward slash, forward
slash, High minus base value. Line 21, indented once. float, low,
semicolon, tab spaces, forward slash, forward slash, Lowest value
input. Line 22, indented once. float, low Relative, semicolon, tab
spaces, forward slash, forward slash, Low minus base value. Line
23, indented once. i n t, high Number, semicolon, tab spaces,
forward slash, forward slash, Sequence number of high. Line 24,
indented once. i n t, low Number, semicolon, tab spaces, forward
slash, forward slash, Sequence number of low. Line 25, indented
once. i n t, reading Number, semicolon, tab spaces, forward slash,
forward slash, Sequence number of current. Line 26, indented a few
times. reading. Line 27, indented once. Forward slash, forward
slash, Declare and open input file. Line 28, indented once. if stream,
in Data, semicolon, tab spaces, forward slash, forward slash, Input
file of readings. Line 29, indented once. in Data, dot, open, left

parenthesis, open quotes, acoustic, dot, dat, close quotes, right
parenthesis, semicolon. Line 30, indented once. if, left parenthesis,
exclamation mark, in Data, right parenthesis, tab spaces, forward
slash, forward slash, Did input file open correctly, question mark.
Line 31, indented once. Left brace, forward slash, forward slash, no.
Line 32, indented once. c out, double left angle bracket, open
quotes, Can't open input file, period, close quotes, double left angle
bracket, end l, semicolon. Line 33, indented once. return 1,
semicolon, tab spaces, forward slash, forward slash, Terminate
program. Line 34, indented once. Right brace. Line 35, indented
once. Forward slash, forward slash, Initialize variables and output.
Line 36, indented once. reading Number, equals, 1, semicolon. line
37, indented once. relative, equals, 0.0, semicolon. Line 38,
indented once. c out, double left angle bracket, set w, left
parenthesis, 14, right parenthesis, double left angle bracket, open
quotes, Reading Number, close quotes, double left angle bracket,
set w, left parenthesis, 15, right parenthesis. Line 39, indented a few
times. Double left angle bracket, open quotes, Actual Reading, close
quotes, double left angle bracket, set w, left parenthesis, 18, right
parenthesis, double left angle bracket, open quotes, Relative
Reading, close quotes. Line 40, indented a few times. Double left
angle bracket, end l, semicolon. Line 41, indented once. in Data,
double right angle bracket, base Value, semicolon, tab spaces,
forward slash, forward slash, Input base value. Line 42, indented a
few times, forward slash, forward slash, Write first line of output.
Line 43, indented once. c out, double left angle bracket, fixed,
double left angle bracket, show point, double left angle bracket, set
precision, left parenthesis, 2, right parenthesis, double left angle
bracket, set w, left parenthesis, 7, right parenthesis. Line 44,
indented a few times. Double left angle bracket, reading Number,
double in left angel bracket, set w, left parenthesis, 19, right
parenthesis, double left angle bracket, base Value, double left angle
bracket, set w, left parenthesis, 15, right parenthesis. Line 45,
indented a few times. Double left angle bracket, relative, double left
angle bracket, end l, semicolon. Line 46, indented once. Forward
slash, forward slash, Initialize process. Line 47, indented once. high,
equals, base Value, semicolon. Line 48, indented once. high
Number, equals, 1, semicolon. Line 49, indented once. high Relative,
equals, 0.0, semicolon. Line 50, indented once. low, equals, base

Value, semicolon. Line 51, indented once. low Number, equals, 1,
semicolon. Line 52, indented once. low Relative, equals, 0.0,
semicolon. Line 53, indented once. reading Number, equals, 2,
semicolon, tab spaces, forward slash, forward slash, Initialize loop
ending. Line 54, indented once. while, left parenthesis, reading
Number, less than or equals, 12, right parenthesis. Line 55, indented
once. Left brace. Line 56, indented twice. in Data, double right angle
bracket, current, semicolon, tab spaces, forward slash, forward
slash, Input new reading. Line 57, indented twice. relative, equals,
current, minus, base Value, semicolon, tab spaces, forward slash,
forward slash, Calculate new relative. Line 58, indented twice. c out,
double left angle bracket, set w, left parenthesis, 7, right
parenthesis, double left angle bracket, reading Number, double left
angle bracket, set w, left parenthesis, 19, right parenthesis, double
left angle bracket, current. Line 59, indented a few times. Double left
angle bracket, set w, left parenthesis, 15, right parenthesis, double
left angle bracket, relative, double left angle bracket, end l,
semicolon. Line 60, indented twice. if, left parenthesis, current, right
angle bracket, high, right parenthesis, tab spaces, forward slash,
forward slash, Check for new high. Line 61, indented twice. Left
brace. Line 62, indented 3 times. high, equals, current, semicolon.
Line 63, indented 3 times. high Number, equals, reading Number,
semicolon. Line 64, indented 3 times. high Relative, equals, relative,
semicolon. Line 65, indented twice. Right brace. Line 66, indented
twice. if, left parenthesis, current, less than, low, right parenthesis,
tab spaces, forward slash, forward slash, Check for new low. Line
67, indented twice. Left brace. Line 68, indented 3 times. low,
equals, current, semicolon. Line 69, indented 3 times. low Number,
equals, reading Number, semicolon. Line 70, indented 3 times. low
Relative, equals, relative, semicolon. Line 71, indented twice. Right
brace Line 72, indented twice. reading Number, plus, plus,
semicolon, tab spaces, forward slash, forward slash, Increment
reading number. Line 73, indented once. Right brace. Line 74,
indented once. Forward slash, forward slash, Output high and low
readings. Line 75, indented once. c out, double left angle bracket,
end l, semicolon. Line 76, indented once. c out, double left angle
bracket, open quotes, Highest reading number is, space, close
quotes, double left angle bracket, high Number, double left angle
bracket, end l, semicolon. Line 77, indented once. c out, double left

angle bracket, open quotes, Highest reading is, space, close quotes,
double left angle bracket, high, double left angle bracket, end l,
semicolon. Line 78, indented once. c out, double left angle bracket,
open quotes, Highest relative value is, space, close quotes, double
left angle bracket, high Relative, double left angle bracket, end l,
semicolon. Line 79, indented once. c out, double left angle bracket,
end l, semicolon. Line 80, indented once. c out, double left angle
bracket, open quotes, Lowest reading number is, space, close
quotes, double left angle bracket, low Number, double left angle
bracket, end l, semicolon. Line 81, indented once. c out, double left
angle bracket, open quotes, Lowest reading is, space, close quotes,
double left angle bracket, low, double left angle bracket, end l,
semicolon. Line 82, indented once. c out, double left angle bracket,
open quotes, Lowest relative value is, space, close quotes, double
left angle bracket, low Relative, double left angle bracket, end l,
semicolon. Line 83, indented once. in Data, dot, close, left
parenthesis, right parenthesis, semicolon. Line 84, indented once.
return, 0, semicolon. Line 85. Right brace.
Back to Figure
The output of the recording studio design program. Line 1. Reading
Number Actual Reading Relative Reading. Line 2. 1 80.00 0.00. Line
3. 2. 86.50 0.50. Line Line 4. 3 88.00 2.00 Line 5. 4 83.50 minus
2.50. Line 6. 5 88.30 2.30. Line 7. 6 89.60 3.60 Line 8. 7 80.10
minus 5.90. Line 9. 8 84.00 minus 2.00. Line 10. 9 86.70 0.70. Line
11. 10 79.30 minus 6.70. Line 12. 11. 74.00 minus 12.00. Line 13.
12 73.50 minus 12.50. Line 14. Highest reading number is 6. Line
15. Highest reading is 89.60. Line 16. Highest relative value is 3.60.
Line 17. Blank. Line 18. Lowest reading number is 12. Line 20.
Lowest reading is 73.50. Line 21. Lowest relative value is minus
12.50.
Back to Figure
A graph that tracks the hight value among the readings in the
recording studio design problem. The horizontal axis measures the
reading number. The points 1, 6, and 12 are marked in the
horizontal axis. The vertical axis measures the reading and is

marked from 70 to 90 in intervals of 10. The graph shows a series of
points that dips from left to right. Among these points which are
connected by lines, the highest value, the lowest dip, and the lowest
value are marked. The highest value is 90. The lowest dip is 80. The
lowest value is 73.
Back to Figure
IF current greater than preceding. Indented, IF preceding less than
low. Indented twice. Set low to preceding. Indented twice. Set low
Number to reading Number minus 1. Indented twice. Set low
Relative to preceding Relative."
Back to Figure
The program for the recording studio design problem. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, Acoustic program. Line 3. Forward
slash, forward slash, This program inputs 12 sound-level readings,
taken in a room. Line 4. Forward slash, forward slash, at different
frequencies. The first reading is used as a base. Line 5. Forward
slash, forward slash, value. For each reading, a value relative to the
base is. Line 6. Forward slash, forward slash, calculated and output.
The program ends by outputting the. Line 7. Forward slash, forward
slash, lowest dip in the readings, where a dip is defined as a
reading. Line 8. Forward slash, forward slash, followed by a higher
reading. Line 9. Forward slash, forward slash, a line of asterisks.
Line 10. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 11. Hash, include, left angle bracket, f stream, right
angle bracket. Line 12. Hash, include, left angle bracket, i o manip,
right angel bracket. Line 13. using, name space, s t d, semicolon.
Line 14, i n t, main, left parenthesis, right parenthesis. Line 15. Left
brace. Line 16, indented once. Forward slash, forward slash,
Declare variables. Line 17, indented once. float, base Value,
semicolon, tab space, forward slash, forward slash, First reading.
Line 18, indented once. float, preceding, semicolon, tab space,
forward slash, forward slash, Reading preceding current. Line 19,
indented once. float, preceding Relative, semicolon, tab space,
forward slash, forward slash, Relative preceding current. Line 20,

indented once. float, current, semicolon, tab space, forward slash,
forward slash, Input during each iteration. Line 21, indented once.
float, relative, semicolon, tab space, forward slash, forward slash,
Current minus base value. Line 22, indented once. float, high,
semicolon, tab space, forward slash, forward slash, Highest value
input. Line 23, indented once. float, high Relative, semicolon, tab
space, forward slash, forward slash, High minus base value. Line
24, indented once. float, low, semicolon, tab space, forward slash,
forward slash, Lowest dip in the readings. Line 25, indented once.
float, low Relative, semicolon, tab space, forward slash, forward
slash, Relative value of low. Line 26, indented once. i n t, high
Number, semicolon, tab space, forward slash, forward slash,
Sequence number of high. Line 27, indented once. i n t, low Number,
semicolon, tab space, forward slash, forward slash, Sequence
number of lowest dip. Line 28, indented once. i n t, reading Number,
semicolon, forward slash, forward slash, Sequence number of
current reading. Line 29, indented once. Forward slash, forward
slash, Declare and open input file. Line 30, indented once. i f
stream, in Data, semicolon, tab space, forward slash, forward slash,
Input file of readings. Line 31, indented once. in Data, dot, open, left
parenthesis, open quotes, acoustic, dot, dat, close quotes, right
parenthesis, semicolon. Line 32, indented twice. if, left parenthesis,
not, in Data, right parenthesis, tab space, forward slash, forward
slash, Did input file open correctly, question mark. Line 33, indented
twice. Left brace, tab space, forward slash, forward slash, no. Line
34, indented 3 times. c out, double left angle bracket, open quotes,
Can't open input file, period, close quotes, double left angle bracket,
end l, semicolon. Line 35, indented 3 times. return, 1, semicolon, tab
space, forward slash, forward slash, Terminate program. Line 36,
indented twice. Right brace. Line 37, indented once. Forward slash,
forward slash, Initialize variables and output. Line 38, indented once.
c out, double left angle bracket, set w, left parenthesis, 14, right
parenthesis, open quotes, Reading Number, close quotes, double
left angle bracket, set w, left parenthesis, 15, right parenthesis. Line
39, indented twice. Double left angle bracket, open quotes, Actual
Reading, close quotes, double left angle bracket, set w, left
parenthesis, 18, right parenthesis, double left angle bracket, open
quotes, Relative Reading, close quotes. Line 40, indented twice.
Double left angle bracket, end l, semicolon. Line 41, indented once.

in Data, double right angle bracket, base Value, semicolon. Line 42,
indented once. preceding, equals, base Value, semicolon. Line 43,
indented once. preceding Relative, equals, 0.0, semicolon. Line 44,
indented once. high Number, equals, 1, semicolon. Line 45, indented
once. low Number, equals, 1, semicolon. Line 46, indented once.
high, equals, base Value, semicolon. Line 47, indented once. low,
equals, base Value, semicolon. Line 48, indented once. high
Relative, equals, 0.0, semicolon. Line 49, indented once. low
Relative, equals, 0.0, semicolon. Line 50, indented once. reading
Number, equals, 1, semicolon. Line 51, indented once. relative,
equals, 0.0, semicolon. Line 52, indented once. forward slash,
forward slash, Write first line of output. Line 53, indented once. c
out, double left angle bracket, fixed, double left angle bracket, show
point, double left angle bracket, set precision, left parenthesis, 2,
right parenthesis, double left angle bracket, set w, left parenthesis,
7, right parenthesis. Line 54, indented twice. Double left angle
bracket, reading Number, double left angle bracket, set w, left
parenthesis, 19, right parenthesis. Line 55, indented twice. Double
left angle bracket, base Value, double left angle bracket, set w, left
parenthesis, 15, right parenthesis, double left angle bracket, relative,
double left angle bracket, end l, semicolon. Line 56, indented once.
reading Number, equals, 2, semicolon, tab space, forward slash,
forward slash, Initialize loop end. Line 57, indented once. while, left
parenthesis, reading Number, less than or equals, 12, right
parenthesis. Line 58, indented once. Left brace. Line 59, indented
twice. in Data, double right angle bracket, current, semicolon, tab
space, forward slash, forward slash, Input new reading. Line 60,
indented twice. relative, equals, current, minus, base Value,
semicolon, tab space, forward slash, forward slash, Calculate new
relative. Line 61, indented twice. c out, double left angle bracket, set
w, left parenthesis, 7, right parenthesis, double left angle bracket,
reading Number, double left angle bracket, set w, left parenthesis,
19, right parenthesis, double left angle bracket, current. Line 62,
indented 3 times. Double left angle bracket, set w, left parenthesis,
15, right parenthesis, double left angle bracket, relative, double left
angle bracket, end l, semicolon. Line 63, indented twice. if, left
parenthesis, current, greater than, high, right parenthesis, tab
space, forward slash, forward slash, Check for new high. Line 64,
indented twice. Left brace. Line 65, indented 3 times. high, equals,

current, semicolon. Line 66, indented 3 times. high Number, equals,
reading Number, semicolon. Line 67, indented 3 times. high Relative,
equals, relative, semicolon. Line 68, indented twice. Right brace.
Line 69, indented twice. if, left parenthesis, current, greater than,
preceding, right parenthesis, tab space, forward slash, forward
slash, Check for new low. Line 70, indented twice. Left brace. Line
71, indented 3 times. if, left parenthesis, preceding, less than, low,
right parenthesis. Line 72, indented 3 times. Left brace. Line 73,
indented 4 times. low, equals, preceding, semicolon. Line 74,
indented 4 times. low Number, equals, reading Number, minus, 1,
semicolon. Line 75, indented 4 times. low Relative, equals,
preceding Relative, semicolon. Line 76, indented 3 times. Right
brace. Line 77, indented twice. Right brace. Line 78, indented twice.
preceding, equals, current, semicolon. Line 79, indented twice.
preceding Relative, equals, relative, semicolon. Line 80, indented
twice. reading Number, plus, plus, semicolon. Line 81, indented
once. Right brace. Line 82, indented once. Forward slash, forward
slash, Output high and low readings. Line 83, indented once. c out,
double left angle bracket, end l, semicolon. Line 84, indented once. c
out, double left angle bracket, open quotes, Highest reading number
is, space, close quotes, double left angle bracket, high Number,
double left angle bracket, end l, semicolon. Line 85, indented once. c
out, double left angle bracket, open quotes, Highest reading is,
space, close quotes, double left angle bracket, high, double left
angle bracket, end l, semicolon. Line 86, indented once. c out,
double left angel bracket, open quotes, Highest relative value is,
space, close quotes, double left angle bracket, high Relative. Line
87, indented twice. Double left angle bracket, end l, semicolon. Line
88, indented once. c out, double left angle bracket, end l, semicolon.
Line 89, indented once. c out, double left angle bracket, open
quotes, Lowest dip is number, space, close quotes, double left angle
bracket, low Number, double left angle bracket, end l, semicolon.
Line 90, indented once. c out, double left angle bracket, open
quotes, Lowest dip reading is, space, close quotes, double left angle
bracket, low, double left angle bracket, end l, semicolon. Line 91,
indented once. c out, double left angle bracket, open quotes, Lowest
relative dip is, space, close quotes, double left angle bracket, low
Relative, double left angle bracket, end l, semicolon. Line 92,
indented once. in Data, dot, close, left parenthesis, right

parenthesis, semicolon. Line 93, indented once. return, 0,
semicolon. Line 94. Right brace.
Back to Figure
The output of the recording studio design program. Line 1. Reading
Number Actual Reading Relative Reading. Line 2. 1 80.00 0.00. Line
3. 2. 86.50 0.50. Line 4. 3 88.00 2.00 Line 5. 4 83.50 minus 2.50.
Line 6. 5 88.30 2.30. Line 7. 6 89.60 3.60 Line 8. 7 80.10 minus
5.90. Line 9. 8 84.00 minus 2.00. Line 10. 9 86.70 0.70. Line 11. 10
79.30 minus 6.70. Line 12. 11. 74.00 minus 12.00. Line 13. 12 73.50
minus 12.50. Line 14. Highest reading number is 6. Line 15. Highest
reading is 89.60. Line 16. Highest relative value is 3.60. Line 17.
Blank. Line 18. Lowest dip is number 7. Line 20. Lowest dip reading
is 80.10. Line 21. Lowest relative dip is minus 5.90.
Back to Figure
The necessary include statements. Program code. Line 1. Hash,
include, open quotes, dialog, dot, h, close quotes, forward slash,
forward slash, Access G U I components. Line 2. Hash, include, left
angle bracket, s stream, right angle bracket, forward slash, forward
slash, Access o string stream.
Back to Figure
The variable declaration for the output string stream object. Program
code. Line 1. o string stream, output, semicolon, forward slash,
forward slash, Output to be displayed to user.
Back to Figure
Code in which c out is replaced with object. Program code. Line 1.
Forward slash, forward slash, Initialize output. Line 2. output, double
left angle bracket, set w, left parenthesis, 14, right parenthesis,
double left angle bracket, open quotes, Reading Number, close
quotes, double left angle bracket, set w, left parenthesis, 15, right
parenthesis. Line 3, indented twice. Double left angle bracket, open
quotes, Actual Reading, close quotes, double left angle bracket, set
w, left parenthesis, 18, right parenthesis, double left angle bracket,

open quotes, Relative Reading, close quotes. Line 4, indented twice.
Double left angle bracket, end l, semicolon.
Back to Figure
Code for a Yes No Dialog widget. Program code. Line 1. Forward
slash, forward slash, Create a G U I to ask the user how to get the
frequency data. Line 2. Yes No Dialog choice, left parenthesis, open
quotes, Would you like to choose an acoustic data file, question,
close quotes, right parenthesis, semicolon. Line 3. bool, response,
equals, choice, dot, display, left parenthesis, right parenthesis,
semicolon.
Back to Figure
The Yes or No Widget. A widget is displayed with the following text
displayed on it. Would you like to choose an acoustic data file?.
Below the text, there are buttons for Yes and No.
Back to Figure
Program code. Line 1. if, left parenthesis, response, equals, equals,
true, right parenthesis. Line 2. Left brace. Line 3, indented once.
Forward slash, forward slash, Prompt the user to choose a data file.
Line 4, indented once. Forward slash, forward slash, Read the data
file like the previous version. Line 5. Right brace. Line 6. else. Line
7. Left brace. Line 8, indented once. Forward slash, forward slash,
Read in the data manually using G U I widgets. Line 9. Right brace.
Back to Figure
Program code. Line 1. Forward slash, forward slash, Create the G U
I to get the name of the input file. Line 2. File Dialog, data Input File,
left parenthesis, open quotes, Acoustic Frequency Data File, close
quotes, right parenthesis, semicolon. Line 3. string, input File,
equals, data Input File, dot, display, left parenthesis, right
parenthesis, semicolon.
Back to Figure

Code that creates a G U I for entering the number of frequencies
and the base frequency value. Program code. Line 1. Forward slash,
forward slash, Create a G U I to ask how many frequencies will be
provided. Line 2. I n t Dialog, number Of Frequencies, left
parenthesis, open quotes, How many frequencies will be provided,
question mark, close quotes, right parenthesis, semicolon. Line 3. i n
t, frequency Number, equals, number Of Frequencies, dot, display,
left parenthesis, right parenthesis, semicolon. Line 4. Forward slash,
forward slash, Create a G U I to ask the user for the base value.
Line 5. Float Dialog weight Dialog, left parenthesis, open quotes,
What is the base frequency value, question mark, close quotes, right
parenthesis, semicolon. Line 6. base Value, equals, weight Dialog,
dot, display, left parenthesis, right parenthesis, semicolon.
Back to Figure
A widget is displayed. It shows the following text. How many
frequencies will be provided? Below the text is an input field for
entering the number of frequencies. Below the text field is a Cancel
and O K button.
Back to Figure
A widget is displayed. It shows the following text. What is the base
frequency value? Below the text is an input field for entering the
base frequency value. Below the text field is a Cancel and O K
button.
Back to Figure
Program code. Line 1. Forward slash, forward slash, Initialize
variables dependent on the base value. Line 2. preceding, equals,
base Value, semicolon. Line 3. high, equals, base Value, semicolon.
Line 4. low, equals, base Value, semicolon. Line 5. Forward slash,
forward slash, Write first line of output. Line 6. output, double left
angle bracket, fixed, double left angle bracket, show point, double
left angle bracket, set precision, left parenthesis, 2, right
parenthesis, double left angle bracket, set w, left parenthesis, 7,
right parenthesis. Line 7, indented once. Double left angle bracket,

reading Number, double left angle bracket, set w, left parenthesis,
19, right parenthesis. Line 8, indented once. Double left angle
bracket, base Value, double left angle bracket, set w, left
parenthesis, 15, right parenthesis, double left angle bracket, relative,
double left angle bracket, end l, semicolon.
Back to Figure
Code that displays a G U I widget prompt. Program code. Line 1.
Forward slash, forward slash, Loop to read in each of the frequency
values. Line 2. reading Number, equals, 2, semicolon. Line 3. while,
left parenthesis, reading Number, less than or equals, frequency
Number, right parenthesis. Line 4. Left brace. Line 5, indented once.
Forward slash, forward slash, Create a G U I to read in each
frequency value. Line 6, indented once. Float Dialog, frequency, left
parenthesis, open quotes, Enter Frequency Value, space, close
quotes, plus. Line 7, indented a few times. s t d, colon, colon, to
underscore string, left parenthesis, reading Number, right
parenthesis, plus, open quotes, colon, close quotes, right
parenthesis, semicolon. Line 8, indented once. current, equals,
frequency, dot, display, left parenthesis, right parenthesis,
semicolon. Line 9. Period. Line 10. Period. Line 11. Period. Line 12.
Right parenthesis.
Back to Figure
A G U I widget for accepting input from the user. The widget has the
following heading in the title bar. Float Dialog. It displays the
following text. Enter Frequency Value 2. Below this text is an input
field in which the user can enter frequency value 2. Below the input
field is a Cancel and O K button.
Back to Figure
A G U I widget for accepting input from the user. The widget has the
following heading in the title bar. Float Dialog. It displays the
following text. Enter Frequency Value 3. Below this text is an input
field in which the user can enter frequency value 2. Below the input
field is a Cancel and O K button.

Back to Figure
Code that outputs high and low readings. Line 1. Forward slash,
forward slash, Output high and low readings. Line 2. output, double
left angle bracket, end l, semicolon. Line 3. output, double left angle
bracket, open quotes, Highest reading number is, space, close
quotes, double left angle bracket, high Number, double left angle
bracket, end l, semicolon. Line 4. output, double left angle bracket,
open quotes, Highest reading is, space, close quotes, double left
angle bracket, high, double left angle bracket, end l, semicolon. Line
5. output, double left angle bracket, open quotes, Highest relative
value is, space, close quotes, double left angle bracket, high
Relative, double left angle bracket, end l, semicolon. Line 6. output,
double left angle bracket, end l, semicolon. Line 7. output, double
left angle bracket, open quotes, Lowest dip is number, space, close
quotes, double left angle bracket, low Number, double left angle
bracket, end l, semicolon. Line 8. output, double left angle bracket,
open quotes, Lowest dip reading is, space, close quotes, double left
angle bracket, low, double left angle bracket, end l, semicolon. Line
9. output, double left angle bracket, open quotes, Lowest relative dip
is, space, close quotes, double left angle bracket, low Relative,
double left angle bracket, end l, semicolon. Line 10. Output Dialog,
output Dialog, left parenthesis, output, dot, s t r, left parenthesis,
right parenthesis, right parenthesis, semicolon. Line 11. output
Dialog, dot, display, left parenthesis, right parenthesis, semicolon.
Back to Figure
A multiline text dialog box displays the output of a program. The
following output is displayed. A table with the following details is
displayed first. The headings of the table are Reading Number,
Actual Reading, and Relative Reading. The row information is the
following. 1, 86.00, 0.00. 2, 86.70, 0.70. 3, 85.00, minus 1.00. 4,
84.00, minus 2.00. 5, 83.00, minus 3.00. Below the table the
following lines are displayed. Highest reading number is 2. Highest
reading is 86.70. Highest relative value is 0.70. Lowest dip is number
1. Lowest dip reading is 86.00. Lowest relative dip is 0.00. The text
dialog box has a Cancel and O K button.

Back to Figure
GUI program for the recording studio design problem. Program
code. Line 1. Forward slash, forward slash, a line of asterisks. Line
2. Forward slash, forward slash, Acoustic Program G U I. Line 3.
Forward slash, This program inputs 12 sound-level readings, taken
in a room. Line 4. Forward slash, forward slash, at different
frequencies. The first reading is used as a base. line 5. Forward
slash, forward slash, value. For each reading, a value relative to the
base is. Line 6. Forward slash, forward slash, calculated and output.
The program ends by outputting the. Line 7. Forward slash, forward
slash, lowest dip in the readings, where a dip is defined as a
reading. Line 8. Forward slash, forward slash, followed by a higher
reading. Line 9. Forward slash, forward slash, a line of asterisks.
Line 10. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 11. Hash, include, left angle bracket, s stream, right
angle bracket, tab space, forward slash, forward slash, Access o
string stream. Line 12. Hash, include, left angle bracket, f stream,
right angle bracket. Line 13. Hash, include, left angle bracket, i o
manip, right angle bracket. Line 14. Hash, include, open quotes,
dialog, dot, h, close quotes, tab space, forward slash, forward slash,
Access G U I components. Line 15. using, name space, s t d,
semicolon. Line 16. i n t, main, left parenthesis, right parenthesis.
Line 16. Left brace. Line 17. indented once. Forward slash, forward
slash, Declare variables. Line 18. indented once. float, base Value,
semicolon, tab space, forward slash, forward slash, First reading.
Line 19, indented once. float, preceding, semicolon, tab space,
forward slash, forward slash, Reading preceding current. Line 20,
indented once. float, preceding Relative, semicolon, tab space,
forward slash, forward slash, Relative preceding current. Line 21,
indented once. float, current, semicolon, tab space, forward slash,
forward slash, Input during each iteration. Line 22, indented once.
float, relative, semicolon, tab space, forward slash, forward slash,
Current minus base value. Line 23, indented once. float, high,
semicolon, tab space, forward slash, forward slash, Highest value
input. Line 24, indented once. float, high Relative, semicolon, tab
space, forward slash, forward slash, High minus base value. Line
25, indented once. float, low, semicolon, tab space, forward slash,
forward slash, Lowest dip in the readings. Line 26, indented once.

float, low Relative, semicolon, tab space, forward slash, forward
slash, Relative value of low. Line 27, indented once. i n t, high
Number, semicolon, tab space, forward slash, forward slash,
Sequence number of high. Line 28, indented once. i n t, low Number,
semicolon, tab space, forward slash, forward slash, Sequence
number of lowest dip. Line 29, indented once. i n t, reading Number,
semicolon, tab space, forward slash, forward slash, Sequence
number of current reading. Line 30, indented once. o string stream,
output, semicolon, ,tab space, forward slash, forward slash, Output
to be displayed to user. Line 31, indented once. Forward slash,
forward slash, Initialize output. Line 32, indented once. output,
double left angle bracket, set w, left parenthesis, 14, right
parenthesis, double left angle bracket, open quotes, Reading
Number, close quotes, double left angle bracket, set w, left
parenthesis, 15, right parenthesis. Line 33, indented twice. Double
left angle bracket, open quotes, Actual Reading, close quotes,
double left angle bracket, set w, left parenthesis, 18, right
parenthesis, double left angel bracket, open quotes, Relative
Reading, close quotes. Line 34, indented twice. Double left angle
bracket, end l, semicolon. Line 35, indented once. Forward slash,
forward slash, Create a G U I to ask the user how to get the
frequency data. Line 36, indented once. Yes No Dialog, choice, left
parenthesis, open quotes, Would you like to choose an acoustic
data file, question mark, close quotes, right parenthesis, semicolon.
Line 37, indented once. bool, response, equals, choice, dot, display,
left parenthesis, right parenthesis, semicolon. Line 38, indented
once. Forward slash, forward slash, Initialize starting values that are
not dependent on the base. Line 39, indented once. preceding
Relative, equals, 0.0, semicolon. Line 40, indented once. high
Number, equals, 1, semicolon. Line 41, indented once. low Number,
equals, 1, semicolon. Line 42, indented once. high Relative, equals,
0.0, semicolon. Line 43, indented once. low Relative, equals, 0.0,
semicolon. Line 44, indented once. reading Number, equals, 1,
semicolon. Line 45, indented once. relative, equals, 0.0, semicolon.
Line 46, indented once. if, left parenthesis, response, equals,
equals, true, right parenthesis. Line 47, indented once. Left brace.
Line 48, indented twice. Forward slash, forward slash, Create the G
U I to get the name of the input file. Line 49, indented twice. File
Dialog, data Input File, left parenthesis, open quotes, Acoustic

Frequency Data File, close quotes, right parenthesis, semicolon.
Line 50, indented twice. string, input File, equals, data Input File,
dot, display, left parenthesis, right parenthesis, semicolon. Line 51,
indented twice. Forward slash, forward slash, Declare and open
input file. Line 52, indented twice. if stream, in Data, semicolon, tab
space, forward slash, forward slash, Input file of readings. Line 53,
indented twice. in Data, dot, open, left parenthesis, input File, right
parenthesis, semicolon. Line 54, indented twice. Forward slash,
forward slash, Initialize variables dependent on the base value. Line
55, indented twice. in Data, double right angle bracket, base Value,
semicolon. Line 56, indented twice. preceding, equals, base Value,
semicolon. Line 57, indented twice. high, equals, base Value,
semicolon. Line 58, indented twice. low, equals, base Value,
semicolon. Line 59, indented twice. Forward slash, forward slash,
Write first line of output. Line 60, indented twice. output, double left
angle bracket, fixed, double left angle bracket, show point, double
left angle bracket, set precision, left parenthesis, 2, right
parenthesis, set w, left parenthesis, 7, right parenthesis. Line 61,
indented 3 times. double left angle bracket, reading Number, double
left angle bracket, set w, left parenthesis, 19, right parenthesis. Line
62, indented 3 times. Double left angel bracket, base Value, double
left angle bracket, set w, left parenthesis, 15, right parenthesis,
double left angle bracket, relative, double left angle bracket, end l,
semicolon. Line 63, indented twice. reading Number, equals, 2,
semicolon, tab space, forward slash, forward slash, Initialize loop
end. Line 64, indented twice. while, left parenthesis, reading
Number, less than or equals, 12, right parenthesis. Line 65, indented
twice. Left brace. Line 66, indented twice. in Data, double right angle
bracket, current, semicolon, tab space, forward slash, forward slash,
Input new reading. Line 67, indented twice. relative, equals, current,
minus, base Value, semicolon, tab space, forward slash, forward
slash, Calculate new relative. Line 68, indented twice. output, double
left angle bracket, set w, left parenthesis, 7, right parenthesis,
double left angle bracket, reading Number, double left angle bracket,
set w, left parenthesis, 19, right parenthesis, double left angle
bracket, current. Line 69, indented 3 times. double left angle
bracket, set w, left parenthesis, 15, right parenthesis, double left
angle bracket, relative, double left angle bracket, end l, semicolon.
Line 70, indented twice. if, left parenthesis, current, greater than,

high, right parenthesis, forward slash, forward slash, Check for new
high. Line 71, indented twice. Left brace. Line 72, indented 3 times.
high, equals, current, semicolon. Line 73, indented 3 times. high
Number, equals, reading Number, semicolon. Line 74, indented 3
times. high Relative, equals, relative, semicolon. Line 75, indented
twice. Right brace. Line 76, indented twice. if, left parenthesis,
current, greater than, preceding, right parenthesis, tab space,
forward slash, forward slash, Check for new low. Line 77, indented
twice. Left brace. Line 78, indented 3 times. if, left parenthesis,
preceding, less than, low, right parenthesis. Line 79, indented 3
times. Left brace. Line 80, indented 4 times. low, equals, preceding,
semicolon. Line 81, indented 4 times. low Number, equals, reading
Number, minus, 1, semicolon. Line 82, indented 4 times. low
Relative, equals, preceding Relative, semicolon. Line 83, indented 3
times. Right brace. Line 84, indented twice. Right brace. Line 85,
indented twice. preceding, equals, current, semicolon. Line 86,
indented twice. preceding Relative, equals, relative, semicolon. Line
87, indented twice. reading Number, plus, plus, semicolon. Line 88,
indented once. Right brace. Line 89, indented once. in Data, dot,
close, left parenthesis, right parenthesis, semicolon. Line 90. Right
brace. Line 91. else. Line 92. Left brace. Line 93, indented once.
Forward slash, forward slash, Create a G U I to ask how many
frequencies will be provided. Line 94, indented once. I n t Dialog,
number Of Frequencies, left parenthesis, open quotes, How many
frequencies will be provided, question mark, close quotes, right
parenthesis, semicolon. Line 95, indented once. i n t, frequency
Number, equals, number Of Frequencies, dot, display, left
parenthesis, right parenthesis, semicolon. Line 96, indented once.
Forward slash, forward slash, Create a G U I to ask the user for the
base value. Line 97, indented once. Float Dialog, weight Dialog, left
parenthesis, open quotes, What is the base frequency value,
question mark, close quotes, right parenthesis, semicolon. Line 98,
indented once. base Value, equals, weight Dialog, dot, display, left
parenthesis, right parenthesis, semicolon. Line 99, indented once.
Forward slash, forward slash, Initialize variables dependent on the
base value. Line 100, indented once. preceding, equals, base Value,
semicolon. Line 101, indented once. high, equals, base Value,
semicolon. Line 102, indented once. low, equals, base Value,
semicolon. Line 103, indented once. Forward slash, forward slash,

Write first line of output. Line 104, indented once. output, double left
angle bracket, fixed, double left angle bracket, show point, double
left angle bracket, set precision, left parenthesis, 2, right
parenthesis, double left angle bracket, set w, left parenthesis, 7,
right parenthesis. Line 105. indented 3 times. double left angle
bracket, reading Number, double left angle bracket, set w, left
parenthesis, 19, right parenthesis. Line 106, indented 3 times.
Double left angle bracket, base Value, double left angle bracket, set
w, left parenthesis, 15, right parenthesis, double left angle bracket,
relative, double left angle bracket, end l, semicolon. Line 107,
indented once. Forward slash, forward slash, Loop to read in each
of the frequency values. Line 108, indented once. reading Number,
equals, 2, semicolon. Line 109, indented once. while, left
parenthesis, reading Number, less than or equals, frequency
Number, right parenthesis. Line 110, indented once. Left brace. Line
111, indented twice, indented twice. Forward slash, forward slash,
Create a G U I to read in each frequency value. Line 112, indented
twice. Float Dialog, frequency, left parenthesis, open quotes, Enter
Frequency Value, space, close quotes, plus. Line 113, indented a
few times. s t d, c o l, colon, colon, to underscore string, left
parenthesis, reading Number, right parenthesis, plus, open quotes,
colon, close quotes, right parenthesis, semicolon. Line 114, indented
twice. current, equals, frequency, dot, display, left parenthesis, right
parenthesis, semicolon. Line 115, indented twice. relative, equals,
current, minus, base Value, semicolon, tab space, forward slash,
forward slash, Calculate new relative. Line 116, indented twice.
output, double left angle bracket, set w, left parenthesis, 7, right
parenthesis, double left angle bracket, reading Number, double left
angle bracket, set w, left parenthesis, 19, right parenthesis, double
left angle bracket, current. Line 117, indented 3 times. double left
angle bracket, set w, left parenthesis, 15, right parenthesis, double
left angle bracket, relative, double left angle bracket, end l,
semicolon. Line 118, indented twice. if, left parenthesis, current,
greater than, high, right parenthesis, tab space, forward slash,
forward slash, Check for new high. Line 119, indented twice. Left
brace. Line 120, indented 3 times. high, equals, current, semicolon.
Line 121, indented 3 times. high Number, equals, reading Number,
semicolon. Line 122, indented 3 times. high Relative, equals,
relative, semicolon. Line 123, indented twice. Right brace. Line 124,

indented twice. if, left parenthesis, current, greater than, preceding,
right parenthesis, tab space, forward slash, forward slash, Check for
new low. Line 125, indented twice. Left brace. Line 126, indented 3
times. if, left parenthesis, preceding, less than, low, right
parenthesis. Line 127, indented 3 times. Left brace. Line 128,
indented 4 times. low, equals, preceding, semicolon. Line 129,
indented 4 times. low Number, equals, reading Number, minus, 1,
semicolon. Line 130, indented 4 times. low Relative, equals,
preceding Relative, semicolon. Line 131, indented 3 times. Right
brace. Line 132, indented twice. Right brace. Line 133, indented
twice. preceding, equals, current, semicolon. Line 134, indented
twice. preceding Relative, equals, relative, semicolon. Line 135,
indented twice. reading Number, plus, plus, semicolon. Line 136,
indented once. Right brace. Line 137. Right brace. Line 138.
Forward slash, forward slash, Output high and low readings. Line
139, indented once. output, double left angle bracket, end l,
semicolon. Line 140, indented once. output, double left angle
bracket, open quotes, Highest reading number is, space, double left
angle bracket, high Number, double left angle bracket, end l,
semicolon. Line 141, indented once. output, double left angle
bracket, open quotes, Highest reading is, space, close quotes,
double left angle bracket, high, double left angle bracket, end l,
semicolon. Line 142, indented once. output, double left angle
bracket, open quotes, Highest relative value is, space, close quotes,
double left angle bracket, high Relative, double left angle bracket,
end l, semicolon. Line 143. output, double left angle bracket, end l,
semicolon. Line 144. output, double left angle bracket, open quotes,
Lowest dip is number, space, close quotes, double left angle
bracket, low Number, double left angle bracket, end l, semicolon.
Line 145, indented once. output, double left angle bracket, open
quotes, Lowest dip reading is, space, close quotes, double left angle
bracket, low, double left angle bracket, end l, semicolon. Line 146,
indented once. output, double left angle bracket, open quotes,
Lowest relative dip is, space, close quotes, double left angle bracket,
low Relative, double left angle bracket, end l, semicolon. Line 147,
indented once. Output Dialog, output Dialog, left parenthesis, output,
dot, s t r, left parenthesis, right parenthesis, right parenthesis,
semicolon. Line 148, indented once. output Dialog, dot, display, left

parenthesis, right parenthesis, semicolon. Line 149, indented once.
return, 0, semicolon. Line 150. Right brace.
Back to Figure
Wrong usage of the while loop. Program code. Line 1. while, left
parenthesis, Expression, right parenthesis, semicolon, tab spaces,
forward slash, forward slash, Wrong. Line 2, indented once.
Statement.
Back to Figure
Wrong usage of the while loop. Program code. Line 1. while, left
parenthesis, some Var, equals, 5, right parenthesis, tab space,
forward slash, forward slash, Wrong, left parenthesis, should be,
equals, equals, right parenthesis.
Back to Figure
An output statement. Program code. Line 1. c out, double left angle
bracket, open quotes, beta, equals, close quotes, double left angle
bracket, beta, double left angle bracket, end l, semicolon.
Back to Figure
Code block under quick check answers question number 6.3.6.
Program code. Line 1. Line 1. count, equals, 1, semicolon. Line 2.
found, equals, false, semicolon. Line 3. c in, double right angle
bracket, in Data, semicolon. Line 4. while, left parenthesis, count,
less than or equals, 10, ampersand, ampersand, not, found,
ampersand, ampersand, c in, right parenthesis. Line 5. Left brace.
Line 6, indented once. count, plus, plus, semicolon. Line 7, indented
once. found, equals, in Data, equals, equals, 0, semicolon. Line 8,
indented once. c in, double right angle bracket, in Data, semicolon.
Line 9. Right brace.
Back to Figure
Code block under quick check answers question number 6.3.7.
Program code. Line 1. ones Count, equals, 0, semicolon. Line 2.

sum, equals, 0, semicolon. Line 3. count, equals, 1, semicolon. Line
4. found, equals, false, semicolon. Line 5. c in, double right angle
bracket, in Data, semicolon. Line 6. while, left parenthesis, count,
less than or equals, 10, ampersand, ampersand, not, found,
ampersand, ampersand, c in, right parenthesis. Line 7. Left brace.
Line 8, indented once. if, left parenthesis, in Data, equals, equals, 1,
right parenthesis. Line 9, indented twice. ones Count, plus, plus,
semicolon. Line 10, indented once. sum, equals, sum, plus, in Data,
semicolon. Line 11, indented once. count, plus, plus, semicolon. Line
12, indented once. found, equals, in Data, equals, equals, 0,
semicolon. Line 13, indented once. c in, double right angle bracket,
in Data, semicolon. Line 14. Right brace.
Back to Figure
Code block under question number 6.4.2 of quick check answers.
Line 1. count, equals, 1, semicolon. Line 2. found, equals, false,
semicolon. Line 3. while, left parenthesis, count, less than or equals,
10, ampersand, ampersand, not, found, right parenthesis. Line 4.
Left brace. Line 5, indented once. count, plus, plus, semicolon. Line
6, indented once. found, equals, in Data, equals, equals, 0,
semicolon. Line 7. Right brace.
Back to Figure
Code block under question number 6.4.4 of quick check answers.
Program code. Line 1. line Count, equals, 0, semicolon. Line 2.
while, left parenthesis, in File, dot, get, left parenthesis, in Char, right
parenthesis, right parenthesis. Line 3. Left brace. Line 4, indented
once. if, left parenthesis, in Char, equals, equals, open single
quotes, backslash, n, close single quotes, right parenthesis. Line 5,
indented a few times. line Count, plus, plus, semicolon. Line 6. Right
brace.
Back to Figure
Code block under question number 6.5.1 of quick check answers.
Program code. Line 1. while, left parenthesis, in File, dot, get, left
parenthesis, in Char, right parenthesis, right parenthesis. Line 2. Left

brace. Line 3, indented once. count, equals, 0, semicolon. Line 4,
indented once. while, left parenthesis, in File, ampersand,
ampersand, in Char, not equals, open single quotes, backslash, n,
close single quotes, right parenthesis. Line 5, indented once. Left
brace. Line 6, indented twice. count, plus, plus, semicolon. Line 7,
indented twice. in File, dot, get, left parenthesis, in Char, right
parenthesis, semicolon. Line 8, indented once. Right brace. Line 9,
indented once. c out, double left angle bracket, open quotes, Line,
space, close quotes, double left angle bracket, line Count, double
left angle bracket, open quotes, colon, space, close quotes, double
left angle bracket, count, double left angle bracket, end l, semicolon.
Line 10, indented once. line Count, plus, plus, semicolon. Line 11.
Right brace.
Back to Figure
Code block under question number 6.5 of exam preparation
exercises. Program code. Line 1. count, equals, 1, semicolon. Line
2. while, left parenthesis, count, less than or equals, 12, right
parenthesis. Line 3. Left brace. Line 4, indented once. c out, double
left angle bracket, count, double left angle bracket, end l, semicolon.
Line 5, indented once. count, plus, plus, semicolon. Line 6. Right
brace.
Back to Figure
Code block under question number 6.6 of exam preparation
exercises. Program code. Line 1. count, equals, 0, semicolon. Line
2. while, left parenthesis, count, less than, 11, right parenthesis. Line
3. Left brace. Line 4, indented once. c out, double left angle bracket,
count, double left angle bracket, open quotes, semicolon, space,
close quotes, semicolon. Line 5, indented once. count, plus, plus,
semicolon. Line 6. Right brace.
Back to Figure
Code block under question number 6.7 of exam preparation
exercises. Program code. Line 1. count, equals, 1, semicolon. Line
2. while, left parenthesis, count, less than, 13, right parenthesis.

Line 3. Left brace. Line 4, indented once. c out, double left angle
bracket, open quotes, dollar, close quotes, double left angle bracket,
count, double left angle bracket, open quotes, dot 0 0, close quotes,
double left angle bracket, end l, semicolon. Line 5, indented once.
count, plus, plus, semicolon. Line 6. Right brace.
Back to Figure
Code block under question number 6.8 of exam preparation
exercises. Program code. Line 1. count, equals, 1, semicolon. Line
2. while, left parenthesis, count, less than or equals, 11, right
parenthesis. Line 3. Left brace. Line 4, indented once. inner Count,
equals, 1. Line 5, indented once. while, left parenthesis, inner Count,
less than or equals, left parenthesis, 12, minus, count, right
parenthesis, forward slash, 2, right parenthesis. Line 6, indented
once. Left brace. Line 7, indented twice. c out, double left angle
bracket, open quotes, space, close quotes, semicolon. Line 8,
indented twice. inner Count, plus, plus, semicolon. Line 9, indented
once. Right brace. Line 10, indented once. inner Count, equals, 1,
semicolon. Line 11, indented once. while, left parenthesis, inner
Count, less than or quals, count, right parenthesis. Line 12, indented
once. Left brace. Line 13, indented twice. c out, double left angle
bracket, open quotes, at, close quotes, semicolon. Line 14, indented
twice. inner Count, plus, plus, semicolon. Line 15, indented once.
Right brace. Line 16, indented once. c out, double left angle bracket,
end l, semicolon. Line 17, indented once. count, plus, plus,
semicolon. Line 18. Right brace.
Back to Figure
Code block under question number 6.9 of exam preparation
exercises. Program code. Line 1. count, equals, 1, semicolon. Line
2. while, left parenthesis, count, less than or equals, 10, right
parenthesis. Line 3. Left brace. Line 4, indented once. inner Count,
equals, 1, semicolon. Line 5, indented once. while, left parenthesis,
inner Count, less than or equals, 10, right parenthesis. Line 6,
indented once. Left brace. Line 7, indented twice. c out, double left
angle bracket, set w, left parenthesis, 5, right parenthesis, double
left angle bracket, count, asterisk, inner count, semicolon. Line 8,

indented twice. inner Count, plus, plus, semicolon. Line 9, indented
once. Right brace. Line 10, indented once. c out, double left angle
bracket, end l, semicolon. Line 11, indented once. count, plus, plus,
semicolon. Line 12. Right brace.
Back to Figure
Code block under question number 6.10 of exam preparation
exercises. Program code. Line 1. sum, equals, 0, semicolon. Line 2.
in data, double right angle bracket, number, semicolon. Line 3. while,
left parenthesis, in data, right parenthesis. Line 4. Left brace. Line 5,
indented once. in data, double right angle bracket, number,
semicolon. Line 6, indented once. sum, equals, sum, plus, number,
semicolon. Line 7. Right brace.
Back to Figure
Code block under question number 6.12 of exam preparation
exercises. Program code. Line 1. number, equals, 1, semicolon. Line
2. while, left parenthesis, number, less than, 10, right parenthesis.
Line 3. Left brace. Line 4, indented once. number, plus, plus,
semicolon. Line 5, indented once. c out, double left angle bracket,
number, asterisk, 2, minus, 1, double left angle bracket, open
quotes, space, close quotes, semicolon. Line 6. Right brace.
Back to Figure
Code block under question number 6.15 of exam preparation
exercises. Program code. Line 1. sum, equals, 0, semicolon. Line 2.
while, left parenthesis, in data, right parenthesis. Line 3. Left brace.
Line 4, indented once. count, equals, 1, semicolon. Line 5, indented
once. while, left parenthesis, count, less than or equals, 5,
ampersand, ampersand, in data, right parenthesis. Line 6, indented
once. Left brace. Line 7, indented twice. c in, double right angle
bracket, number, semicolon. Line 8, indented twice. sum, equals,
sum, plus, number, semicolon. Line 9, indented once. Right brace.
Line 10, indented once. c out, double left angle bracket, sum,
forward slash, count, double left angle bracket, end l, semicolon.
Line 11. Right brace.

Back to Figure
The contents of the input file for question number 6.1 under
programming problems. Line 1. Weems 50 60. Line 2. Dale 51 60.
Line 3. Richards 57 60. Line 4. Smith 36 60. Line 5. Tomlin 44 60.
Line 6. Bird 45 60. Line 7. Ellipsis.
Back to Figure
The output of the program for question number 6.2 under
programming problems. Line 1. Weems 83% .83333 Well Done.
Line 2. Dale 85% .85000 Well Done. Line 3. Richards 95% .95000
Excellent. Line 4. Smith 60% .60000 Need Improvement. Line 5.
Tomlin 73% .73333 Good. Line 6. Bird 75% .75000 Good. Line 7.
Ellipsis.
Back to Figure
The output of the program for question number 6.3 under
programming problems. The output displays the temperatures for 24
hours using a pattern of asterisks. The heading"Temperatures for 24
hours" is displayed in the first line. In the next line, the temperatures
from minus 30 to 120 are printed with equal spaces in between in
intervals of 30 degrees. The temperatures for 24 hours are listed
line by line on the left margin of the output. The temperatures listed
are the following. minus 20. 1. 2. 3. 4. 5. 10. 50. 100. At the 0
degree heading, the pipe symbol is listed from top to bottom. For the
temperatures listed for 24 hours, the temperature is displayed using
a number of asterisks appropriately in the range between minus 30
to 120.
Back to Figure
The formula for standard deviation that needs to be used for
question number 6.4 under programming problems. s equals, sigma,
i equals 1 to n, x sub i squared, minus, (sigma, i equals 1 to n, x sub
i) squared the whole divided by n times (n minus 1).
Back to Figure

A playlist displayed as the output for question number 6.5 under
programming problems. The output shows a table like display using
text. The table has 7 rows and 5 columns. The column headings are
the following. Song Number. Song Time, Minutes. Song Time,
Seconds. Total Time, Minutes. Total Time, Seconds. The row details
are the following. Row 1: Song Number, 1; Song Time, Minutes, 5;
Song Time, Seconds, 10; Total Time, Minutes, 5; Total Time,
Seconds, 10. Row 2: Song Number, 2; Song Time, Minutes, 7; Song
Time, Seconds, 42; Total Time, Minutes, 12; Total Time, Seconds,
52. Row 3: Song Number, 5; Song Time, Minutes, 4; Song Time,
Seconds, 19; Total Time, Minutes, 17; Total Time, Seconds, 11. Row
4: Song Number, 3; Song Time, Minutes, 4; Song Time, Seconds,
33; Total Time, Minutes, 21; Total Time, Seconds, 44. Row 5: Song
Number, 4; Song Time, Minutes, 10; Song Time, Seconds, 27; Total
Time, Minutes, 32; Total Time, Seconds, 11. Row 6: Song Number,
6; Song Time, Minutes, 8; Song Time, Seconds, 55; Total Time,
Minutes, 41; Total Time, Seconds, 6. Row 7: Song Number, 7; Song
Time, Minutes, 5; Song Time, Seconds, 0; Total Time, Minutes, 46;
Total Time, Seconds, 6. Below the table, the following summary text
is displayed. There are 43 minutes and 54 seconds left to make a
90-minute playlist.
Back to Figure
The output that is displayed during 2 sample runs of the program in
question 6.6 under programming problems. Line 1. Enter string: able
was I ere I saw elba. Line 2. able was I ere I saw elba. Line 3. is a
palindrome. Line 4. Enter string: madam I'm adam. Line 4. madam
I'm adam. Line 5. is not a palindrome.
Back to Figure
The data that is read by the program in question 6.7 under
programming problems. Line 1. From: sharon at marzipan dot e d u.
Line 2. Date: Wed, 13 Aug 2003 17:12:33 E D T. Line 3. Subject:
Re: hi. Line 4. To: john at meringue dot com. Line 5. John,. Line 6.
Dave's email is dave underscore smith at icing dot o r g. Line 7. t t y
l, Line 8. sharon.

Back to Figure
The data that is written in the file addresses dot dat by the program
in question number 6.7 under programming problems. Line 1.
sharon at marzipan dot e d u. Line 2. john at meringue dot com.
Line 3. dave underscore smith at icing dot o r g.
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: switch, case,
break, default. 
Line 1: switch, left parentheses, letter, right parentheses. 
Line 2: Left brace. 
Line 3, indented once: case, single quote, uppercase x, single quote,
colon, Statement 1, semicolon. 
Line 4, indented 4 times: break, semicolon. 
Line 5, indented once: case, single quote, uppercase L, single
quote, colon. 
Line 6, indented once: case, single quote, uppercase M, single
quote, colon, Statement 2, semicolon. 
Line 7, indented 4 times: break, semicolon. 
Line 8, indented once: case, single quote, uppercase S, single
quote, colon, Statement 3, semicolon. 
Line 9, indented 4 times: break, semicolon. 
Line 10, indented once: default, colon, Statement 4, semicolon. 
Line 11: Right brace. 
Line 12: Statement 5, semicolon.
Back to Figure
Line 1: 3. Line 2: CLASS, underscore, SIZE. Line 3: single quote,
uppercase A, single quote. Line 4: 2, asterisk, CLASS underscore
SIZE plus 1.
Back to Figure
"The keyword used in the examples is case. 
Line 1: case, single quote, uppercase X, single quote, colon. 

Line 2: case, single quote, uppercase L, single quote, colon. 
Line 3: case, single quote, uppercase M, single quote, colon. 
Line 4: case, single quote, uppercase S, single quote, colon.
Back to Figure
"Program code. The words in the keywords are merged and the
code contains the following keywords: switch, case, c out, break. 
Line 1: switch, left parentheses, grade, right parentheses. 
Line 2: Left brace. 
Line 3, indented once: case, single quote, uppercase a, single
quote, colon. 
Line 4, indented once: case, single quote, uppercase b, single
quote, colon, c out, 2 left angled brackets, double quotes, Good,
blank space, Work, double quotes, semicolon. 
Line 5, indented 4 times: break, semicolon. 
Line 6, indented once: case, single quote, uppercase c, single quote,
colon, c out, 2 left angled brackets, double quotes, Average, blank
space, Work, double quotes, semicolon. 
Line 7, indented 4 times: break, semicolon."
Back to Figure
"Program code. The words in the variable names and keywords are
merged and the code contains the following keywords: case, c out,
break. 
Line 1, indented once: case, single quote, uppercase d, single
quote, colon. 
Line 2, indented once: case, single quote, uppercase f, single quote,
colon, c out, 2 left angled brackets, double quotes, Poor Work,
double quotes, semicolon. 
Line 3, indented 4 times: number In Trouble, plus, plus, semicolon. 
Line 4, indented 4 times: break, semicolon. 2 forward slashes,
Unnecessary, but a good habit. 
Line 5: right brace."
Back to Figure

"Program code. The words in the variable names and keywords are
merged and the code contains the following keywords: switch, case,
c out, break. 
Line 1: switch, left parentheses, grade, right parentheses. 
Line 2: left brace. 
Line 3, indented once: case, single quote, uppercase A, single
quote, colon. 
Line 4, indented once: case, single quote, uppercase B, single
quote, colon, c out, 2 left angled brackets, double quotes, Good,
blank space, Work, double quotes, semicolon. 
Line 5, indented 4 times: break, semicolon. 
Line 6, indented once: case, single quote, C, single quote, colon, c
out, 2 left angled brackets, double quotes, Average, blank space,
Work, double quotes, semicolon. 
Line 7, indented 4 times: break, semicolon. 
Line 8, indented once: case, single quote, D, single quote, colon. 
Line 9, indented once: case, single quote, F, single quote, colon, c
out, 2 left angled brackets, double quotes, Poor, blank space, Work,
double quotes, semicolon. 
Line 10, indented 4 times: number In Trouble, plus, plus, semicolon. 
Line 11, indented 4 times: break, semicolon. 
Line 12, indented once: default, colon, c out, 2 left angled brackets,
grade, 2 left angled brackets, double quotes, blank space, is not a
vali letter grade, dot, double quotes, semicolon. 
Line 13, indented 4 times: break, semicolon. 
Line 14. Right brace."
Back to Figure
"Program code. The words in the variable names and the keywords
are merged. The code contains the following keywords: if, c out,
else. 
Line 1. if, left parentheses, grade, 2 equals sign, single quote,
uppercase a, single quote, double pipe, grade, 2 equals sign, single
quote, uppercase b, single quote, right parentheses. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Good, blank space, Work, double quotes, semicolon. 
Line 3. else if, left parentheses, grade, 2 equals sign, single quote,
uppercase c, single quote, right parentheses. 

Line 4, indented once: c out, 2 left angled brackets, double quotes,
Average, blank space, Work, double quotes, semicolon. 
Line 5: else if, left parentheses, grade, 2 equals sign, single quote,
uppercase d, single quote, 2 vertical pipes, grade, 2 equals sign,
single quote, uppercase f, single quote, close parentheses. 
Line 6: Left brace. 
Line 7, indented once: c out, 2 left angled brackets, double quotes,
Poor, blank space, Work, double quotes, semicolon. 
Line 8, indented once: number In Trouble, plus, plus, semicolon. 
Line 9: Right brace. 
Line 10: else. 
Line 11, indented once: c out, 2 left angled brackets, grade, 2 left
angled brackets, double quotes, blank space, is not a valid letter
grade, dot, double quotes, semicolon.
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: switch, case,
c out, default. 
Line 1: switch, left parentheses, grade, right parentheses. 2 forward
slashes, Wrong version. 
Line 2: left brace. 
Line 3, indented once: case, single quote, uppercase a, single
quote, colon. 
Line 4, indented once: case, single quote, uppercase b, single
quote, colon, c out, 2 left angled brackets, double quotes, Good,
blank space, Work, double quotes, semicolon. 
Line 5, indented once: case, single quote, uppercase c, single quote,
uppercase c, single quote, colon, c out, 2 left angled brackets,
double quotes, Average, blank space, Work, double quotes,
semicolon. 
Line 6, indented once: case, single quote, uppercase d, single
quote, colon. 
Line 7, indented once: case, single quote, uppercase f, single quote,
colon, c out, 2 left angled brackets, double quotes, Poor, blank
space, Work, double quotes, semicolon. 
Line 8, indented 4 times: number In Trouble, plus, plus, semicolon. 
Line 9, indented once: default, colon, c out, 2 left angled brackets,

grade, 2 left angled brackets, double quotes, blank space, is not a
valid letter grade, dot, double quotes, semicolon. 
Line 10: Right brace."
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: include, i o
stream, string, using, name space, s t d, int, main, c out, c in, end l. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Activity program. 
Line 3: 2 forward slashes. This program outputs an appropriate
activity. 
Line 4: 2 forward slashes. for a given temperature. 
Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: hash, include, left angled bracket, i o stream, right angled
bracket. 
Line 7: hash, include, left angled bracket, string, right angled
bracket. 
Line 8: using name space s t d, semicolon. 
Line 9: blank. 
Line 10: int main, left parentheses, right parentheses. 
Line 11: Left brace. 
Line 12, indented once: int temperature, semicolon. 2 forward
slashes, The outside temperature. 
Line 13, indented once: int raining, semicolon. 
Line 14: blank. 
Line 15, indented once: 2 forward slashes, Read and echo
temperature. 
Line 16, indented once: c out, 2 left angled brackets, double quotes,
Enter the outside temperature, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 17, indented once: c in, 2 right angled brackets, temperature,
semicolon.
Back to Figure
"Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: c out, c in, end l,

switch, case, if, else, break, return.
Line 1, indented once: c out, 2 left angled brackets, double quotes,
Enter 1 if it is raining and 0 if it is not, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 2, indented once: c in, 2 left angled brackets, raining,
semicolon. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
The current temperature is, blank space, double quotes, 2 left
angled brackets, temperature, semicolon. 
Line 4, indented once: switch, left parentheses, raining, right
parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: case 0, colon, c out, 2 left angled brackets,
double quotes, blank space, and it is not raining, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 7, indented 4 times: if, left parentheses, temperature, greater
than, 60, right parentheses. 
Line 8, indented 5 times: c out, 2 left angled brackets, double
quotes, Go for a walk, period, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 9, indented 4 times: else. 
Line 10, indented 5 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 11, indented 4 times: break, semicolon. 
Line 12, indented twice: case 1, colon, c out, 2 left angled brackets,
double quotes, blank space, and it is raining, period, double quotes,
2 left angled brackets, end l, semicolon. 
Line 13, indented 4 times: if, left parentheses, temperature, greater
than, 60, right parentheses. 
Line 14, indented 5 times: c out, 2 left angled brackets, double
quotes, Go to a movie, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 15, indented 4 times: else. 
Line 16, indented 5 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 17, indented 4 times: break, semicolon. 
Line 18, indented once: right brace. 

Line 19, indented once: return 0, semicolon. 
Line 20: right brace."
Back to Figure
"Line 1: Enter the outside temperature, colon. 
Line 2: 65, underlined. 
Line 3: Enter 1 if it is raining and 0 if it is not, period. 
Line 4: 1, underlined. 
Line 5: The current temperature is 65 and it is raining, period. 
Line 6: Go to a movie, period. 
Line 7: blank. 
Line 8: Enter the outside temperature, colon. 
Line 9: 65, underlined. 
Line 10: Enter 1 if it is raining and 0 if it is not, period. 
Line 11: 0, underlined. 
Line 12: The current temperature is 65 and it is not raining, period. 
Line 13: Go for a walk, period. 
Line 14: blank. 
Line 15: Enter the outside temperature, colon. 
Line 16: 55, underlined. 
Line 17: Enter 1 if it is raining and 0 if it is not, period. 
Line 18: 0, underlined. 
Line 19: The current temperature is 55 and it is not raining, period."
Back to Figure
"Line 1: Read a good book, period. 
Line 2: Enter the outside temperature, colon. 
Line 3: 55, underline. 
Line 4: Enter 1 if it is raining and 0 if it is not, period. 
Line 5: 1, underline. 
Line 6: The current temperature is 55 and it is raining, period. 
Line 7: Read a good book, period."
Back to Figure
The keywords used are as follows: do, while. 
Line 1: do. 

Line 2: left brace. 
Line 3, indented once: Statement 1, semicolon. 
Line 4, indented once: Statement 2, semicolon. 
Line 5: dot. 
Line 6: dot. 
Line 7, indented once: Statement N, semicolon. 
Line 8: right brace, while, left parentheses, Expression, right
parentheses, semicolon.
Back to Figure
In the program code, the words in the variable names are merged
and the keywords are as follows: while, do. The while solution is as
follows. 
Line 1: data File, 2 right angled brackets, input Char, semicolon. 
Line 2: while, left parentheses, input char, exclamation mark, equals
sign, single quote, dot, single quote, right parentheses. 
Line 3, indented once: data File, 2 right angled brackets, input Char,
semicolon. 
The do while solution is as follows. 
Line 1: do. 
Line 2, indented once: data File, 2 right angled brackets, input Char,
semicolon. 
Line 3: while, left parentheses, input Char, exclamation mark,
equals, single quote, dot, single quote, right parentheses, semicolon.
Back to Figure
The keywords used are as follows: c out, c in. 
Line 1: c out, 2 left angled brackets, double quotes, Enter your age,
colon, blank space, double quotes, semicolon. 
Line 2: c in, 2 right angled brackets, age, semicolon.
Back to Figure
"The keywords used are as follows: while, c out, end l, c in, do, if.
The continuation of the while solution is as follows. 
Line 1: while, left parentheses, age, less than or equal to 0, right
parentheses. 

Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
Your age must be positive, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
Enter your age, colon, blank space, double quotes, semicolon. 
Line 5, indented once: c in, 2 right angled brackets, age, semicolon. 
Line 6: right brace.
The do while solution is as follows. 
Line 1: do. 
Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
Enter your age, colon, blank space, double quotes, semicolon. 
Line 4, indented once: c in, 2 right angled brackets, age, semicolon. 
Line 5, indented once: if, left parentheses, age less than or equal to
0, right parentheses. 
Line 6, indented twice: c out, 2 left angled brackets, double quotes,
Your age must be positive, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 7: right brace, while, left parentheses, age less than or equal to
0, right parentheses, semicolon.
Back to Figure
The keywords used in the program code are as follows: while, do.
The listing of the while solution is as follows. 
Line 1: sum, equals 0, semicolon. 
Line 2: counter, equals, 1, semicolon. 
Line 3: while, left parentheses, counter less than or equal to n, right
parentheses. 
Line 4: left brace. 
Line 5, indented once: sum, equals, sum, plus, counter, semicolon. 
Line 6, indented once: counter, plus, plus, semicolon. 
Line 7: right brace. 
The listing of the do while solution is as follows. 
Line 1: sum, equals, 0, semicolon. 
Line 2: counter, equals, 1, semicolon. 
Line 3: do. 
Line 4: left brace. 

Line 5, indented once: sum, equals, sum, plus, counter, semicolon. 
Line 6, indented once: counter, plus, plus. 
Line 7: right brace, while, left parentheses, counter, less than or
equal to n, right parentheses, semicolon.
Back to Figure
The flowchart for the while statement is as follows. 
Step 1: while, left parentheses, Expression, right parentheses. 
If step 1 evaluates to true, go to step 2. If step 1 evaluates to false,
skip step 2. 
Step 2: Statement. 
Go back to step 1. 
The flowchart for the do while statement is as follows. 
Step 1: do. 
Step 2: Statement. 
Step 3: while, left parentheses, Expression, right parentheses,
semicolon. 
If step 3 evaluates to true, go back to step 2. If step 3 evaluates to
false, go to next step.
Back to Figure
Program code. The words in the keywords are merged and the
program contains the following keywords: include, i o stream, string,
using, name space, s t d, int, char, do, c out, end l, c in, switch,
case, if, else. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes, Activity program. 
Line 3: 2 forward slashes, This program outputs an appropriate
activity. 
Line 4: 2 forward slashes, for a given temperature. 
Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: hash, include, left angled bracket, i o stream, right angled
bracket. 
Line 7: hash, include, left angled bracket, string, right angled
bracket. 
Line 8: using name space s t d, semicolon. 
Line 9: blank. 

Line 10: int main, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12, indented once: int temperature, semicolon. 2 forward
slashes, The outside temperature. 
Line 13, indented once: int raining, semicolon. 
Line 14, indented once: char signal, semicolon. 
Line 15, indented once: do. 2 forward slashes, Repeat while signal is
single quote c single quote. 
Line 16, indented once: left brace. 
Line 17, indented twice: 2 forward slashes, Read and echo
temperature. 
Line 18, indented twice: c out, 2 left angled brackets, double quotes,
Enter the outside temperature, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 19, indented twice: c in, 2 right angled brackets, temperature,
semicolon. 
Line 20, indented twice: c out, 2 left angled brackets, double quotes,
Enter 1 if it is raining and 0 if it is not, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 21, indented twice: c in, 2 right angled brackets, raining,
semicolon. 
Line 22, indented twice: c out, 2 left angled brackets, double quotes,
The current temperature is, blank space, double quotes, 2 left
angled brackets, temperature, semicolon. 
Line 23: blank. 
Line 24, indented twice: switch, left parentheses, raining, right
parentheses. 
Line 25, indented twice: left brace. 
Line 26, indented thrice: case 0, colon, c out, 2 left angled brackets,
double quotes, blank space, and it is not raining, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 27, indented 8 times: if, left parentheses, temperature greater
than 60, right parentheses. 
Line 28, indented 9 times: c out, 2 left angled brackets, double
quotes, Go for a walk, period, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 29, indented 8 times: else.
Back to Figure

Program code. The words used in the keywords are merged and the
code contains the following keywords: c out, end l, break, case, if,
else, c in, while, return. 
Line 1, indented 9 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 2, indented 8 times: break, semicolon. 
Line 3, indented thrice: case 1, colon, c out, 2 left angled brackets,
double quotes, blank space, and it is raining, period, double quotes,
2 left angled brackets, end l, semicolon. 
Line 4, indented 8 times: if, left parentheses, temperature greater
than 60, right parentheses. 
Line 5, indented 9 times: c out, 2 left angled brackets, double
quotes, Go to a movie, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6, indented 8 times: else. 
Line 7, indented 9 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 8, indented 8 times: break, semicolon. 
Line 9, indented twice: right brace. 
Line 10, indented twice: c out, 2 left angled brackets, double quotes,
Enter a single quote c single quote to continue or a single quote q
single quote to quit, period, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 11, indented twice: c in, 2 right angled brackets, signal,
semicolon. 
Line 12, indented once: right brace, while, left parentheses, signal, 2
equals sign, single quote, c, single quote, right parentheses,
semicolon. 
Line 13, indented once: return 0, semicolon. 
Line 14: right brace.
Back to Figure
Line 1, indented 9 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 2, indented 8 times: break, semicolon. 

Line 3, indented thrice: case 1, colon, c out, 2 left angled brackets,
double quotes, blank space, and it is raining, period, double quotes,
2 left angled brackets, end l, semicolon. 
Line 4, indented 8 times: if, left parentheses, temperature greater
than 60, right parentheses. 
Line 5, indented 9 times: c out, 2 left angled brackets, double
quotes, Go to a movie, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6, indented 8 times: else. 
Line 7, indented 9 times: c out, 2 left angled brackets, double
quotes, Read a good book, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 8, indented 8 times: break, semicolon. 
Line 9, indented twice: right brace. 
Line 10, indented twice: c out, 2 left angled brackets, double quotes,
Enter a single quote c single quote to continue or a single quote q
single quote to quit, period, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 11, indented twice: c in, 2 right angled brackets, signal,
semicolon. 
Line 12, indented once: right brace, while, left parentheses, signal, 2
equals sign, single quote, c, single quote, right parentheses,
semicolon. 
Line 13, indented once: return 0, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The program contains the following keywords: int,
while. 
Line 1: int x, equals, 1, semicolon. 
Line 2: int y, equals, 0, semicolon. 
Line 3: while, left parentheses, x less than or equal to 10, right
parentheses. 
Line 4: left brace. 
Line 5, indented twice: y equals x plus y, semicolon. 
Line 6: right brace.
Back to Figure

Program code. The program code contains the following keywords:
for, c out, end l. 
Line 1: for, left parentheses, count equals 1, semicolon, count less
than or equal to n, semicolon, count plus, plus, right parentheses. 
Line 2, indented once: c out, 2 left angled brackets, count, 2 left
angled brackets, end l, semicolon.
Back to Figure
The words used in the keywords are merged and the code contains
the following keywords: for, c out, end l, while. 
The statements corresponding to the for loop are as follows. 
Line 1: for, left parentheses, count equals 1, semicolon, count less
than or equal to n, semicolon, count plus, plus, right parentheses. 
Line 2, indented once: c out, 2 left angled brackets, count, 2 left
angled brackets, end l, semicolon. 
The statements corresponding to the while loop are as follows. 
Line 1: count, equals, 1, semicolon. 
Line 2: while, left parentheses, count less than or equal to n, right
parentheses. 
Line 3: left brace. 
Line 4, indented once: c out, 2 left angled brackets, count, 2 left
angled brackets, end l, semicolon. 
Line 5, indented once: count, plus, plus, semicolon. 
Line 6: right brace. 
An arrow is drawn from the statement, count equals 1, of the for
loop to the corresponding statement in the while loop. A second
arrow is drawn from the statement, count, less than or equal to n, to
the corresponding statement in the while loop. A third arrow is drawn
from the statement, count, plus, plus, in the for loop to the
corresponding statement in the while loop.
Back to Figure
Program code. The words in the variable names are merged and the
keyword used is as follows: for. 
Line 1: for, left parentheses, loop Count, equals, 1, semicolon, loop
Count, less than or equal to 50, semicolon, loop Count, plus, plus,
right parentheses. 

Line 2: Dot, dot. 
Line 3: for, left parentheses, loop Count, equals, 50, semicolon, loop
Count, greater than or equal to 1, semicolon, loop count, minus,
minus, right parentheses. 
Line 4: Dot, dot.
Back to Figure
Program code. The words used in the variables and the keywords
are merged and the code contains the following keywords: for, c out,
end l. 
Line 1: for, left parentheses, last Num, equals, 1, semicolon, last
Num, less than or equal to 7, semicolon, last Num, plus, plus, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: for, left parentheses, num To Print, equals, 1,
semicolon, num To Print less than or equal to last Num, semicolon,
num To Print, plus, plus, right parentheses. 
Line 4, indented twice: c out, 2 left angled brackets, num To Print,
semicolon. 
Line 5, indented once: c out, 2 left angled brackets, end l,
semicolon. 
Line 6: right brace.
Back to Figure
Line 1: 1. 
Line 2: 1 blank space 2. 
Line 3: 1 blank space 2 blank space 3. 
Line 4: 1 blank space 2 blank space 3 blank space 4. 
Line 5: 1 blank space 2 blank space 3 blank space 4 blank space 5. 
Line 6: 1 blank space 2 blank space 3 blank space 4 blank space 5
blank space 6. 
Line 7: 1 blank space 2 blank space 3 blank space 4 blank space 5
blank space 6 blank space 7.
Back to Figure

Program code. The words used in the variables and the keywords
are merged. The code contains the following keywords: while, c in. 
Line 1: while, left parentheses, input val, exclamation mark, equals,
999, right parentheses. 
Line 2, indented once: c in, 2 right angled brackets, input val,
semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: for, c in. 
Line 1: for, left parentheses, semicolon, input Val, exclamation mark,
equals sign, 999, semicolon, right parentheses. 
Line 2, indented once: c in, 2 right angled brackets, input Val,
semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: for, c out.
Line 1: for, left parentheses, semicolon, semicolon, right
parentheses. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Hi, double quotes, 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: while, true, c
out, end l.
Line 1: while, left parentheses, true, right parentheses. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Hi, double quotes, 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: for, c out,
int, end l.
Line 1: for, left parentheses, int i equals 1, semicolon. This

statement is underlined. i less than or equal to 20, semicolon, i plus,
plus, right parentheses. 
Line 2, indent once: c out, 2 left angled brackets, double quotes, Hi,
double quotes, 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: for, c out,
int, end l.
Line 1: for, left parentheses, int i equals 1, semicolon. This
statement is underlined. i less than or equal to 20, semicolon, i plus,
plus, right parentheses. 
Line 2, indented once: cout, 2 left angled brackets, double quotes,
Hi, double quotes, 2 left angled brackets, end l, semicolon. 
Line 3: for, left parentheses, int i equals 1, semicolon. This
statement is underlined. i less than or equal to 100, semicolon. i plus
plus, right parentheses. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
E d, double quotes, 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and the
keywords are merged. The code contains the following keywords: c
in, while. 
Line 1: c in, 2 right angled brackets, c h, semicolon. 
Line 2: while, left parentheses, c h, exclamation mark, equals, single
quote, dot, single quote, right parentheses. 
Line 3, indented once: c in, 2 right angled brackets, c h, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: for, c in. 
Line 1: for, left parentheses, c in, 2 right angled brackets, c h,
semicolon, c h, exclamation mark, equals, single quote, dot, single
quote, semicolon, c in, 2 right angled brackets, c h, right

parentheses. 
Line 2: semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, i
o stream, c c type, using, name space, s t d, int, main, char, c out,
end l, for, c in, if, else, switch, case, default, return. 
Line 1: 2 forward slashes, followed by asterisks till the end of the
line. 
Line 2: 2 forward slashes, This program counts the number of
letters, periods, question. 
Line 3: 2 forward slashes, marks, and exclamation marks found in
the first 100 input. 
Line 4: 2 forward slashes, characters. 
Line 5: 2 forward slashes, Assumption: Input consists of at least 100
characters. 
Line 6: 2 forward slashes, followed by asterisks till the end of the
line. 
Line 7: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 8: hash include, left angled bracket, c c type, right angled
bracket. 
Line 9: using name space s t d, semicolon. 
Line 10: blank. 
Line 11: int main, left parentheses, right parentheses. 
Line 12: left brace. 
Line 13, indented once: char in Char, semicolon. 2 forward slashes,
current input character. 
Line 14, indented once: int loop Count, semicolon. 2 forward
slashes, Loop control variable. 
Line 15, indented once: int letter Count equals 0, semicolon. 2
forward slashes, Number of letters. 
Line 16, indented once: int period Count equals 0, semicolon. 2
forward slashes, Number of periods. 
Line 17, indented once: int quest Count equals 0, semicolon. 2
forward slashes, Number of question marks. 
Line 18, indented once: int exclaim Count equals 0, semicolon. 2

forward slashes, Number of exclamation marks. 
Line 19: blank. 
Line 20, indented once: c out, 2 left angled brackets, double quotes,
Enter your text, colon, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 21, indented once: for, left parentheses, loop Count equals 1,
semicolon, loop Count less than or equal to 100, semicolon, loop
Count, plus, plus, right parentheses. 
Line 22, indented once: left brace. 
Line 23, indented twice: c in dot get, left parentheses, in Char, right
parentheses, semicolon. 
Line 24, indented twice: if, left parentheses, is alpha, left
parentheses, in Char, right parentheses, right parentheses. 
Line 25, indented thrice: letter Count, plus, plus. 
Line 26, indented twice: else. 
Line 27, indented thrice: switch, left parentheses, in Char, right
parentheses. 
Line 28, indented thrice: left brace. 
Line 29, indented 4 times: case, single quote, dot, single quote,
colon, period Count, plus, plus, semicolon. 
Line 30, indented 8 times: break, semicolon. 
Line 31, indented 4 times: case, single quote, question mark, single
quote, colon, quest Count, plus, plus, semicolon. 
Line 32, indented 8 times: break, semicolon. 
Line 33, indented 4 times: case, single quote, exclamation mark,
single quote, colon, e x c l a m Count, plus, plus, semicolon. 
Line 34, indented 8 times: break, semicolon. 
Line 35, indented 4 times: default, colon, semicolon. 2 forward
slashes, unnecessary but O K. 
Line 36, indented thrice: right brace. 
Line 37, indented once: right brace. 
Line 38, indented once: c out, 2 left angled brackets, end l,
semicolon. 
Line 39, indented once: c out, 2 left angled brackets, double quotes,
Input contained, double quotes, 2 left angled brackets, end l. 
Line 40, indented thrice: 2 left angled brackets, letter Count, 2 left
angled brackets, double quotes, letters, double quotes, 2 left angled
brackets, end l. 
Line 41, indented thrice: 2 left angled brackets, period Count, 2 left

angled brackets, double quotes, periods, double quotes, 2 left
angled brackets, end l. 
Line 42, indented thrice: 2 left angled brackets, quest Count, 2 left
angled brackets, double quotes, question marks, double quotes, 2
left angled brackets, end l. 
Line 43, indented thrice: 2 left angled brackets, e x c l a m Count, 2
left angled brackets, double quotes, exclamation marks, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 44, indented once: return 0, semicolon. 
Line 45: left brace."
"Line 1: Enter your text, colon. 
Line 2 contains the alphabets in lowercase from a to z. 
Line 3 contains the alphabets in uppercase from a to z. 
Line 4 contains the numbers from 1 to 9. 
Line 5 contains 4 question marks. 
Line 6 has 6 periods. 
Line 7 has 5 exclamation marks. 
Line 8 contains the alphabets in lowercase from a to z. 
Line 9: blank. 
Line 10: Input contained. 
Line 11: 70 letters. 
Line 12: 6 periods. 
Line 13: 4 question marks. 
Line 15: 5 exclamation marks."
"Line 1: 2 forward slashes followed by asterisks till the end of line. 
Line 2: 2 forward slashes, B M I Program. 
Line 3: 2 forward slashes, This program calculates the body mass
index, left parentheses, B M I, right parentheses, given a weight. 
Line 4: 2 forward slashes, in pounds and a height in inches and
outputs a health message. 
Line 5: 2 forward slashes, based on the B M I. Input in English
measures. 
Line 6: 2 forward slashes, The user is prompted to enter the number
of cases to be read. 
Line 7: 2 forward slashes followed by asterisks till the end of line.
Back to Figure

Program code. The words in the keywords are merged. The
program contains the following keywords: include, i o stream, using,
name space, s t d. 
Line 1: 2 forward slashes followed by asterisks till the end of line. 
Line 2: 2 forward slashes, B M I Program. 
Line 3: 2 forward slashes, This program calculates the body mass
index, left parentheses, B M I, right parentheses, given a weight. 
Line 4: 2 forward slashes, in pounds and a height in inches and
outputs a health message. 
Line 5: 2 forward slashes, based on the B M I. Input in English
measures. 
Line 6: 2 forward slashes, The user is prompted to enter the number
of cases to be read. 
Line 7: 2 forward slashes followed by asterisks till the end of line. 
Line 8: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 9: using name space s t d, semicolon."
Back to Figure
Program code. The words in the variable names and keywords are
merged and the program contains the following keywords: int, main,
const, float, c out, end l, c in, for, if, else, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: const int B M I underscore CONSTANT
equals 703, semicolon. 2 forward slashes, constant in non metric
formula. 
Line 4, indented once: float weight, semicolon. 2 forward slashes,
Weight in pounds. 
Line 5, indented once: float height, semicolon. 2 forward slashes,
Height in inches. 
Line 6, indented once: float body Mass Index, semicolon. 2 forward
slashes, Appropriate B M I. 
Line 7, indented once: int count, semicolon. 
Line 8: blank. 
Line 9, indented once: c out, 2 left angled brackets, double quotes,
Enter the number of cases to run, period, double quotes, 2 left
angled brackets, end l, semicolon. 

Line 10, indented once: c in, 2 right angled brackets, count,
semicolon. 
Line 11, indented once: for, left parentheses, semicolon, count,
exclamation mark, equals, 0, semicolon, count minus, minus, right
parentheses. Line 11 is underlined. 
Line 12, indented once: left brace. 
Line 13, indented twice: 2 forward slashes, Prompt for and input
weight and height. 
Line 14, indented twice: c out, 2 left angled brackets, double quotes,
Enter your weight in pounds, period, blank space, double quotes, 2
left angled brackets, end l, semicolon. 
Line 15, indented twice: c in, 2 right angled brackets, weight,
semicolon. 
Line 16, indented twice: c out, 2 left angled brackets, double quotes,
Enter your height in inches, period, blank space, double quotes, 2
left angled brackets, end l, semicolon. 
Line 17, indented twice: c in, 2 right angled brackets, height,
semicolon. 
Line 18, indented twice: 2 forward slashes, calculate body mass
index. 
Line 19, indented twice: body Mass Index equals weight asterisk B
M I underscore CONSTANT, forward slash, left parentheses, height
asterisk height, right parentheses, semicolon. 
Line 20, indented twice: 2 forward slashes, Output message
indicating status. 
Line 21, indented twice: 2 forward slashes, c out, 2 left angled
brackets, double quotes, Your body mass index is, blank space,
double quotes, 2 left angled brackets, body Mass Index. 
Line 22, indented thrice: 2 left angled brackets, double quotes, dot,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 23, indented twice: c out, 2 left angled brackets, double quotes,
Interpretation and instructions, period, blank space, double quotes, 2
left angled brackets, end l, semicolon. 
Line 24, indented twice: if, left parentheses, body Mass Index less
than 20, right parentheses. 
Line 25, indented thrice: c out, 2 left angled brackets, double quotes,
Underweight, colon, blank space, Have a milk shake, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 26, indented twice: else if, left parentheses, body Mass Index

less than or equal to 25, right parentheses. 
Line 27, indented thrice: c out, 2 left angled brackets, double quotes,
Normal, colon, blank space, Have a glass of milk, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 28, indented twice: else if, left parentheses, body Mass Index
less than or equal to 30, right parentheses. 
Line 29, indented thrice: c out, 2 left angled brackets, double quotes,
Overweight, colon, blank space, Have a glass of iced tea, period,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 30, indented twice: else. 
Line 31, indented thrice: c out, 2 left angled brackets, double quotes,
Obese, colon, blank space, See your doctor, period, double quotes,
2 left angled brackets, end l, semicolon. 
Line 32, indented once: right brace. 
Line 33, indented once: return 0, semicolon. 
Line 34: right brace.
Back to Figure
Program code. The code contains the following keywords: int, while. 
Line 1: int x equals 1, semicolon. 
Line 2: int y equals 0, semicolon. 
Line 3: while, left parentheses, x less than or equal to 10, right
parentheses. 
Line 4: left brace. 
Line 5, indented once: y equals x plus y, semicolon. 
Line 6: right brace.
Back to Figure
Program code. The words in the keywords and the variable names
are merged. The code has the following keywords: while, true, c in,
if, break, float.
Line 1: loop Count equals 1, semicolon. 
Line 2: while, left parentheses, true, right parentheses. 
Line 3: left brace. 
Line 4, indented once: c in, 2 right angled brackets, num 1,
semicolon. 
Line 5, indented once: if, left parentheses, exclamation mark, 2

vertical pipes, num 1 greater than or equal to 100, right
parentheses. 
Line 6, indented twice: break, semicolon. 
Line 7, indented once: c in, 2 right angled brackets, num 2,
semicolon. 
Line 8, indented once: if, left parentheses, exclamation mark, c in, 2
vertical pipes, num 2 less than or equal to 50, right parentheses. 
Line 9, indented twice: break, semicolon. 
Line 10, indented once: c out, 2 left angled brackets, s q r t, left
parentheses, float, left parentheses, num 1 plus num 2, right
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 11, indented once: loop Count, plus, plus, semicolon. 
Line 12, indented once: if, left parentheses, loop Count, greater
than, 10, right parentheses. 
Line 13, indented twice: break, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: for, if, continue,
c out. 
Line 1: for, left parentheses, data Count equals 1, semicolon, data
Count less than or equal to 500, semicolon, data Count plus, plus,
right parentheses. 
Line 2: left brace. 
Line 3, indented once: data File, 2 right angled braces, input V a l,
semicolon. 
Line 4, indented once: if, left parentheses, input V a l less than or
equal to 0, right parentheses. 
Line 5, indented twice: continue, semicolon. 
Line 6, indented once: c out, 2 left angled brackets, input V a l,
semicolon. 
Line 7: dot. 
Line 8: dot. 
Line 9: dot. 
Line 10: right brace.

Back to Figure
Program code. The words in the keywords and the variable names
are merged. The code has the following keywords: while, true, c in,
if, break, float. 
Line 1: loop Count equals 1, semicolon. 
Line 2: while, left parentheses, true, right parentheses. 
Line 3: left brace. 
Line 4, indented once: c in, 2 right angled brackets, num 1,
semicolon. 
Line 5, indented once: if, left parentheses, exclamation mark, 2
vertical pipes, num 1 greater than or equal to 100, right
parentheses. 
Line 6, indented twice: break, semicolon. 
Line 7, indented once: c in, 2 right angled brackets, num 2,
semicolon. 
Line 8, indented once: if, left parentheses, exclamation mark, c in, 2
vertical pipes, num 2 less than or equal to 50, right parentheses. 
Line 9, indented twice: break, semicolon. 
Line 10, indented once: c out, 2 left angled brackets, s q r t, left
parentheses, float, left parentheses, num 1 plus num 2, right
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 11, indented once: loop Count, plus, plus, semicolon. 
Line 12, indented once: if, left parentheses, loop Count, greater
than, 10, right parentheses. 
Line 13, indented twice: break, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: for, if, continue,
c out. 
Line 1: for, left parentheses, data Count equals 1, semicolon, data
Count less than or equal to 500, semicolon, data Count plus, plus,
right parentheses. 
Line 2: left brace. 
Line 3, indented once: data File, 2 right angled braces, input V a l,

semicolon. 
Line 4, indented once: if, left parentheses, input V a l less than or
equal to 0, right parentheses. 
Line 5, indented twice: continue, semicolon. 
Line 6, indented once: c out, 2 left angled brackets, input V a l,
semicolon. 
Line 7: dot. 
Line 8: dot. 
Line 9: dot. 
Line 10: right brace.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: for, if, c out. 
Line 1: for, left parentheses, data Count equals 1, semicolon, data
Count less than or equal to 500, semicolon, data Count, plus, plus,
right parentheses. 
Line 2: left brace. 
Line 3, indented once: data File, 2 right angled brackets, input V a l,
semicolon. 
Line 4, indented once: if, left parentheses, input V a l, greater than
0, right parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: c out, 2 left angled brackets, input V a l,
semicolon. 
Line 7: dot. 
Line 8: dot. 
Line 9: dot. 
Line 10, indented once: right brace. 
Line 11: right brace.
Back to Figure
Program code. The words in the variable names are merged. 
Line 1: int 1 equals 14, semicolon. 
Line 2: int 2 equals plus plus int 1, semicolon. 2 forward slashes, int
1 equals, equals, 15, ampersand, ampersand, int 2 equals, equals,
15. 

Line 3: blank. 
Line 4: int 1 equals 14, semicolon. 
Line 5: int 2 equals int 1 plus plus, semicolon. 2 forward slashes, int
1 equals, equals, 15, ampersand, ampersand, int 2, equals, equals,
14.
Back to Figure
Program code. 
Line 1: if, left parentheses, i equals, equals, 3, ampersand, j equals,
equals, 4, right parentheses. 2 forward slashes, Wrong. 
Line 2, indented once: k equals 20, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: int, static underscore cast. 
Line 1: int Var equals int, left parentheses, float Var, right
parentheses, semicolon. 2 forward slashes, Functional notation. 
Line 2: int Var equals left parentheses, int, right parentheses, float
Var, semicolon. 2 forward slashes, Prefix notation. 
Line 3: int Var equals static underscore cast, left angled bracket, int,
right angled bracket, left parentheses, float Var, right parentheses,
semicolon. 2 forward slashes, keyword notation.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: unsigned, int, static
underscore cast. 
Line 1: my Var equals unsigned int, left parentheses, some Float,
right parentheses, semicolon. 2 forward slashes, Not allowed. 
Line 2: my Var equals left parentheses, unsigned int, right
parentheses, some Float, semicolon. 2 forward slashes, Yes. 
Line 3: my Var equals static underscore cast, left angled bracket,
unsigned int, right angled bracket, some Float, semicolon. 2 forward
slashes, Yes.
Back to Figure

Program code. The words in the keywords are merged. 
Line 1: c out, 2 left angled brackets, double quotes, Size of a short
is, blank space, double quotes, 2 left angled brackets, size of, left
parentheses, short, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 2: c out, 2 left angled brackets, double quotes, Size of an int is,
blank space, double quotes, 2 left angled brackets, size of, left
parentheses, int, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 3: c out, 2 left angled brackets, double quotes, Size of a long is,
blank space, double quotes, 2 left angled brackets, size of, left
parentheses, long, right parentheses, 2 left angled brackets, end l,
semicolon.
Back to Figure
Program code. The code contains the following keywords: if, else. 
Line 1: if, left parentheses, a greater than b, right parentheses. 
Line 2, indented once: max equals a, semicolon. 
Line 3: else. 
Line 4, indented once: max equals b, semicolon.
Back to Figure
The datatypes listed from left to right are as follows: int, unsigned
int, long, unsigned long, float, double, long double. The left end has
the lowest precedence and the right end has the highest
precedence. The precedence increases when going from left to
right.
The modules are represented by rectangles. The rectangle at the
top center is labeled Main. The rectangles at the bottom left, bottom
center, and bottom right, are labeled, Open File, Increment
Counters, and Output Table, respectively. Lines are drawn from the
module labeled Main to the other 3 modules.
Back to Figure

Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: include, f
stream, i o stream, i o main p, c c type, using, name space, s t d,
int, main, i f stream, char, string, c out, c in, end l, if, return, do. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Rich uncle program. 
Line 3: 2 forward slashes. Percentage of characters in the file that
belong to five. 
Line 4, indented once: categories, colon. 
Line 5: 2 forward slashes. uppercase characters, lowercase
characters, decimal digits, 
Line 6, indented once: blanks, 
Line 7: 2 forward slashes. and end of sentence punctuation marks. 
Line 8: 2 forward slashes. Assumptions: Input file is not empty and
percentages are based. 
Line 9: 2 forward slashes. on total number of characters in the file. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: hash include, left angled bracket, f stream, right angled
bracket. 
Line 12: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 13: hash include, left angled bracket, i o manip, right angled
bracket. 
Line 14: hash include, left angled bracket, c c type, right angled
bracket. 
Line 15: blank. 
Line 16: using name space s t d, semicolon. 
Line 17: int main, left parentheses, right parentheses. 
Line 18: left brace. 
Line 19, indented once: 2 forward slashes. Prepare files for reading
and writing. 
Line 20, indented once: i f stream text, semicolon. 
Line 21, indented once: char character, semicolon. 
Line 22: blank. 
Line 23, indented once: 2 forward slashes. Declare and initialize
counters. 
Line 24, indented once: int uppercase Counter equals 0, semicolon.
2 forward slashes. Number of uppercase letters. 

Line 25, indented once: int lowercase Counter equals 0, semicolon.
2 forward slashes. Number of lowercase letters. 
Line 26, indented once: int blank Counter equals 0, semicolon. 2
forward slashes. Number of blanks. 
Line 27, indented once: int digit Counter equals 0, semicolon. 2
forward slashes. Number of digits. 
Line 28, indented once: int punctuation Counter equals 0, semicolon.
2 forward slashes. Number of end, single quote, dot, single quote,
single quote, question mark, single quote, single quote, exclamation
mark, single quote. 
Line 29, indented once: int all Else Counter equals 0, semicolon. 2
forward slashes. Remaining characters. 
Line 30: blank. 
Line 31, indented once: string in File Name, semicolon. 2 forward
slashes. User specified input file name. 
Line 32, indented once: c out, 2 left angled brackets, double quotes,
Enter the name of the file to be processed, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 33, indented once: c in, 2 right angled brackets, in File Name,
semicolon. 
Line 34, indented once: text dot open, left parentheses, in File Name
dot c underscore s t r, left parentheses, right parentheses, right
parentheses, semicolon. 
Line 35, indented once: if, left parentheses, exclamation mark, text,
right parentheses. 
Line 36, indented once: left brace. 
Line 37, indented twice: c out, 2 left angled brackets, double quotes,
File did not open successfully, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 38, indented twice: return 1, semicolon. 
Line 39, indented once: right brace. 
Line 40, indented once: text dot get, left parentheses, character,
right parentheses, semicolon. 2 right angled brackets. Input one
character. 
Line 41, indented once: do. 
Line 42, indented once: left brace. 
Line 43, indented twice: 2 forward slashes. Process each character. 
Line 44, indented twice: if, left parentheses, is upper, left
parentheses, character, right parentheses, right parentheses.

Back to Figure
Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: c out, c in,
end l, if, else, switch, case, default, break, while, float, return.
Line 1, indented thrice: uppercase Counter, plus, plus, semicolon. 
Line 2, indented twice: else if, left parentheses, is lower, left
parentheses, character, right parentheses, right parentheses. 
Line 3, indented thrice: lowercase Counter, plus, plus, semicolon. 
Line 4, indented twice: else if, left parentheses, is digit, left
parentheses, character, right parentheses, right parentheses. 
Line 5, indented thrice: digit Counter, plus, plus, semicolon. 
Line 6, indented twice: else. 
Line 7, indented thrice: switch, left parentheses, character, right
parentheses. 
Line 8, indented thrice: left brace. 
Line 9, indented 4 times: case, single quote, blank space, single
quote, colon, blank Counter, plus, plus, semicolon. 
Line 10, indented 8 times: break, semicolon. 
Line 11, indented 4 times: case, single quote, dot, single quote,
colon. 
Line 12, indented 4 times: case, single quote, question mark, single
quote, colon. 
Line 13, indented 4 times: case, single quote, exclamation mark,
single quote, colon, punctuation Counter, plus, plus, semicolon. 
Line 14, indented 8 times: break, semicolon. 
Line 15, indented 4 times: default, colon, all Else Counter, plus, plus,
semicolon. 
Line 16, indented 8 times: break, semicolon. 
Line 16, indented thrice: right brace. 
Line 17, indented twice: text dot get, left parentheses, character,
right parentheses, semicolon. 
Line 18, indented once: right brace, while, left parentheses, text,
right parentheses, semicolon. 
Line 19: blank. 
Line 20, indented once: 2 forward slashes. Calculate total number of
characters. 
Line 21, indented once: float total equals uppercase Counter, plus,
lowercase Counter. 

Line 22, indented twice: plus blank Counter, plus, digit Counter, plus,
punctuation Counter. 
Line 23, indented twice: plus all Else Counter, semicolon. 
Line 24, indented once: c out, 2 left angled brackets, double quotes,
Analysis of characters on input file, blank space, double quotes, 2
left angled brackets, in File Name, 2 left angled brackets. 
Line 25: end l, semicolon. 
Line 26: blank. 
Line 27, indented once: 2 forward slashes. Write output on standard
output device. 
Line 28, indented once: c out, 2 left angled brackets. fixed, 2 left
angled brackets, set precision, left parentheses, 3, right
parentheses. 
Line 29, indented twice: 2 left angled brackets, double quotes,
Percentage of uppercase characters, semicolon, blank space,
double quotes. 
Line 30, indented twice: 2 left angled brackets, uppercase Counter,
forward slash, total, asterisk, 100, 2 left angled brackets, end l,
semicolon. 
Line 31, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parentheses, 3, right
parentheses. 
Line 32, indented twice: 2 left angled brackets, double quotes,
Percentage of lowercase characters, colon, blank space, double
quotes. 
Line 33, indented twice: 2 left angled brackets, lowercase Counter,
forward slash, total, asterisk, 100, 2 left angled brackets, end l,
semicolon. 
Line 34, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parentheses, 3, right
parentheses, 2 left angled brackets, double quotes, Percentage of
blanks, colon, blank space, double quotes. 
Line 35, indented twice: 2 left angled brackets, blank Counter,
forward slash, total, asterisk 100, 2 left angled brackets, end l,
semicolon. 
Line 36, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parentheses, 3, right
parentheses, 2 left angled brackets, double quotes, Percentage of
digits, colon, blank space, double quotes. 

Line 37, indented twice: 2 left angled brackets, digit Counter, forward
slash, total, asterisk 100, 2 left angled brackets, end l, semicolon. 
Line 38, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parentheses, 3, right
parentheses, 2 left angled brackets, double quotes, Percentage of
end of sentence, double quotes. 
Line 39, indented twice: 2 left angled brackets, double quotes,
punctuation, blank space, double quotes, 2 left angled brackets,
punctuation Counter, forward slash, total, asterisk, 100, 2 left angled
brackets. 
Line 40: end l, semicolon. 
Line 41, indented once: return 0, semicolon. 
Line 42: right brace.
Back to Figure
The output is as follows. 
Line 1: Enter the name of the file to be processed. 
Line 2: Uncle Data. 
Line 3: Analysis of characters on input file Uncle Data. 
Line 4: Percentage of uppercase characters: 2.978. 
Line 5: Percentage of lowercase characters: 75.609. 
Line 6: Percentage of blanks: 16.805. 
Line 7: Percentage of digits: 0.331. 
Line 8: Percentage of end of sentence punctuation, blank space,
1.040.
Back to Figure
The words in the keywords are merged. Line 1: hash include, double
quotes, dialog dot h, double quotes. 2 forward slashes, Access G U
I components. Line 2: hash include, left angled brackets, s stream,
right angled brackets. 2 forward slashes, Access o string stream.
Back to Figure
The words in the keyword are merged. Line 1: o string stream, blank
space, output, semicolon. 2 forward slashes. Output to be displayed
to user.

Back to Figure
The words in the keywords are merged. Line 1: File Dialog data
Input File, left parentheses, double quotes, Choose the file to be
processed, double quotes, right parentheses, semicolon. Line 2:
string in File Name equals data Input File dot display, left
parentheses, right parentheses, semicolon.
Back to Figure
The search bar is at the top right. The folder view options are at the
top left. The button at the bottom left is labeled, New Folder. The
buttons at the bottom right are labeled, Cancel and Open. The Open
button is disabled. The contents of the folder are displayed in a
tabular format which lists the Name, Size, Kind, and Date Added.
The contents are as follows. 
Line 1: Name: Rich Uncle Case Study G U I. Size: 195 K B. Kind:
Unix Executable File. Date Added: Today at 4 58 A M. 
Line 2: Name: dialog dot o. Size: 1.9 M B. Kind: object code. Date
Added: Today at 4 58 A M. 
Line 3: Name: main dot o. Size: 333 K B. Kind: object code. Date
Added: Today at 4 58 A M. 
Line 4: Name: m o c underscore dialog dot o. Size: 613 K B. Kind:
object code. Date Added: Today at 4 58 A M. 
Line 5: Name: m o c underscore dialog dot c p p. Size: 3 K B. Kind:
C plus plus source code. Date Added: Today at 4 58 A M. 
Line 6: Name: m o c underscore pre d e f s dot h. Size: 14 K B.
Kind: C header code. Date Added: Today at 4 58 A M. 
Line 7: Name: Make file. Size: 53 K B. Kind: Document. Date Added:
Today at 4 58 A M. 
Line 8: Name: Rich Uncle Case Study G U I dot pro dot user. Size:
22 K B. Kind: Document. Date Added: Today at 4 58 A M. 
Line 9: Name: main dot c p p. Size: 3 K B. Kind: C plus plus source
code. Date Added: Today at 4 44 A M. 
Line 10: Name: history dot in. Size: 4 K B. Kind: Document. Date
Added: Today at 4 44 A M. 
Line 11: Name: dialog dot h. Size: 3 K B. Kind: C header code. Date
Added: Today at 4 44 A M. 
Line 12: Name: dialog dot c p p. Size: 11 K B. Kind: C plus plus

source code. Date Added: Today at 4 44 A M. 
Line 13: Name: Rich Uncle Case Study G U I dot pro. Size: 412
bytes. Kind: Q t Project File. Date Added: Today at 4 43 A M.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: if, c out, end l, return. 
Line 1: if, left parentheses, exclamation mark, text, right
parentheses, left brace. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Files did not open successfully, period, double quotes. 2 left angled
brackets, end l, semicolon. 
Line 3, indented once: return 1, semicolon. 
Line 4: right brace.
Back to Figure
Program code. The words in the keywords and variable names are
merged. The code contains the following keywords: float, output, in
File Name, end l. 
Line 1: 2 forward slashes. Calculate total number of characters. 
Line 2: float total equals uppercase Counter plus lowercase Counter
plus blank Counter plus. 
Line 3, indented once: digit Counter plus punctuation Counter plus
all Else Counter, semicolon. 
Line 4: output, 2 left angled brackets, double quotes, Analysis of
characters on input file, blank space, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, semicolon. 
Line 5: blank. 
Line 6: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled
brackets, double quotes, Percentage of uppercase characters,
colon, blank space, double quotes. 
Line 7, indented once: 2 left angled brackets, upper case Counter,
forward slash, total, asterisk, 100, 2 left angled brackets, end l,
semicolon. 
Line 8: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled

brackets, double quotes, Percentage of lowercase characters, colon,
blank space, double quotes. 
Line 9, indented once: 2 left angled brackets, lowercase Counter,
forward slash, total, asterisk, 100, 2 left angled brackets, end l,
semicolon. 
Line 10: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left angled bracket, 3, right angled bracket. 
Line 11, indented once: 2 left angled brackets, double quotes,
Percentage of blanks, colon, blank space, double quotes, 2 left
angled brackets, blank Counter, forward slash, total, asterisk 100, 2
left angled brackets, end l, semicolon.
Back to Figure
Program code. The words in the keywords and variable names are
merged. The code contains the following keywords: output, fixed,
end l. 
Line 1: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses. 
Line 2, indented once: 2 left angled brackets, double quotes,
Percentage of digits, colon, blank space, double quotes, 2 left
angled brackets, digit Counter, forward slash, total, asterisk 100, 2
left angled brackets, end l, semicolon. 
Line 3: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled
brackets, double quotes, Percentage of end hyphen of hyphen
sentence, blank space, double quotes. 
Line 4, indented once: 2 left angled brackets, double quotes,
punctuation, blank space, double quotes, 2 left angled brackets,
punctuation Counter, forward slash, total, asterisk 100, 2 left angled
brackets, end l, semicolon.
Back to Figure
Program code. The words in the keywords and variable names are
merged.
Line 1: Output Dialog output Dialog, left parentheses, output dot s t
r, left parentheses, right parentheses, right parentheses, semicolon. 

Line 2: output Dialog dot display, left parentheses, right parentheses,
semicolon.
Back to Figure
The label at the top left of the window is, Output, colon. The listing
within a text box below the label is as follows. 
Line 1: Analysis of characters on input file, blank space, forward
slash, Users, forward slash, tim, forward slash, Desktop, forward
slash, Chapter, blank space, 0 7, forward slash, Rich Uncle Case
Study G U I, forward slash. 
Line 2: Percentage of uppercase characters, colon, 3.042. 
Line 3: Percentage of lowercase characters, colon, 77.233. 
Line 4: Percentage of blanks, colon, 15.017. 
Line 5: Percentage of digits, colon, 0.338. 
Line 6: Percentage of end hyphen of hyphen sentence punctuation,
blank space, 1.062. 
The 2 buttons at the bottom right are labeled, Cancel, and O K.
Back to Figure
Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: include, c c
type, f stream, i o man i p, i o stream, s stream, using, name space,
s t d, int, main, i f stream, char. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes, Rich Uncle Program, left parentheses, G
U I Version, right parentheses. 
Line 3: 2 forward slashes, Percentage of characters in the file that
belong to five categories, colon. 
Line 4: 2 forward slashes, uppercase characters, comma, lowercase
characters, comma, decimal digits, comma, blanks, comma. 
Line 5: 2 forward slashes, and end hyphen of hyphen sentence
punctuation marks. 
Line 6: 2 forward slashes, Assumptions, colon, Input file is not
empty, comma, and percentages are based. 
Line 7: 2 forward slashes, on total number of characters in the file. 
Line 8: 2 forward slashes followed by asterisks till the end of the line.
Line 9: blank. 

Line 10: hash include, left angled bracket, c c type, right angled
bracket. 
Line 11: hash include, left angled bracket, f stream, right angled
bracket. 
Line 12: hash include, left angled bracket, i o man i p, right angled
bracket. 
Line 13: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 14: hash include, left angled bracket, s stream, right angled
bracket, 2 forward slashes, Access o string stream. 
Line 15: hash include, double quotes, dialog dot h, double quotes, 2
forward slashes, Access G U I components. 
Line 16: blank. 
Line 17: using name space s t d, semicolon. 
Line 18: int main, left parentheses, right parentheses. 
Line 19: left brace. 
Line 20, indented once: 2 forward slashes, Prepare file for reading. 
Line 21, indented once: i f stream text, semicolon. 
Line 22, indented once: char character, semicolon.
Lines 14 and 15 are highlighted.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: int, o string
stream, File dialog, string, do, if, else, switch, case, break, default,
while, float. 
Line 1: 2 forward slashes, Declare and initialize counters. 
Line 2: int uppercase Counter equals 0, semicolon. 2 forward
slashes, Number of uppercase letters. 
Line 3: int lowercase Counter equals 0, semicolon. 2 forward
slashes, Number of lowercase letters. 
Line 4: int blank Counter equals 0, semicolon. 2 forward slashes,
Number of blanks. 
Line 5: int digit Counter equals 0, semicolon. 2 forward slashes,
Number of digits. 
Line 6: int punctuation Counter equals 0, semicolon, semicolon. 2
forward slashes, Number of end single quote, period, single quote,
comma, single quote, question mark, single quote, comma, single

quote, exclamation mark, single quote. 
Line 7: int all Else Counter equals 0, semicolon. 2 forward slashes,
Remaining characters. 
Line 8: blank. 
Line 9: o string stream output, semicolon. 2 forward slashes, output
to be displayed to user. 
Line 10: blank. 
Line 11: File Dialog data Input File, left parentheses, double quotes,
Choose the file to be processed, double quotes, right parentheses,
semicolon. 
Line 12: string in File Name equals data Input File dot display, left
parentheses, right parentheses, semicolon. 
Line 13: blank. 
Line 14: text dot open, left parentheses, in File Name dot c
underscore s t r, left parentheses, right parentheses, right
parentheses, semicolon. 
Line 15: blank. 
Line 16: text dot get, left parentheses, character, right parentheses,
semicolon. 2 forward slashes, Input one character. 
Line 17: blank. 
Line 18: do. 
Line 19: left brace. 
Line 20, indented once: 2 right angled brackets, Process each
character. 
Line 21, indented once: if, left parentheses, is upper, left
parentheses, character, right parentheses, right parentheses. 
Line 22, indented twice: uppercase Counter, plus, plus, semicolon. 
Line 23, indented once: else if, left parentheses, is lower, left
parentheses, character, right parentheses, right parentheses. 
Line 24, indented twice: lowercase Counter, plus, plus, semicolon. 
Line 25, indented once: else if, left parentheses, is digit, left
parentheses, character, right parentheses, right parentheses. 
Line 26, indented twice: digit Counter, plus, plus, semicolon. 
Line 27, indented once: else. 
Line 28, indented twice: switch, left parentheses, character, right
parentheses. 
Line 29, indented twice: left brace. 
Line 30, indented thrice: case, single quote, blank space, single
quote, colon. 

Line 31, indented 4 times: blank Counter plus plus, semicolon. 
Line 32, indented 4 times: break, semicolon. 
Line 33, indented thrice: case, single quote, period, single quote,
colon. 
Line 34, indented thrice: case, single quote, question mark, single
quote, colon. 
Line 35, indented thrice: case, single quote, exclamation mark,
single quote, colon. 
Line 36, indented 4 times: punctuation Counter plus, plus,
semicolon. 
Line 37, indented 4 times: break, semicolon. 
Line 38, indented thrice: default, colon. 
Line 39, indented 4 times: all Else Counter, plus, plus, semicolon. 
Line 40, indented 4 times: break, semicolon. 
Line 41, indented twice: right brace. 
Line 42, indented once: text dot get, left parentheses, character,
right parentheses, semicolon. 
Line 43: right brace, while, left parentheses, text, right parentheses,
semicolon. 
Line 44: blank. 
Line 45: text dot close, left parentheses, right parentheses,
semicolon. 
Line 46: blank. 
Line 47: 2 forward slashes, calculate total number of characters. 
Line 48: float total equals uppercase Counter plus lowercase
Counter plus blank Counter plus. 
Line 49: digit Counter plus punctuation Counter plus all Else Counter,
semicolon. 
Lines 9, 11, and 12 are highlighted.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The program contains the following keywords: output, fixed,
end l, return. 
Line 1: output, 2 left angled brackets, double quotes, Analysis of
characters on input file, blank space, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, semicolon. 
Line 2: blank. 

Line 3: 2 forward slashes. Prepare output for display. 
Line 4: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled
brackets, double quotes, Percentage of uppercase characters,
colon, blank space, double quotes. 
Line 5, indented once: 2 left angled brackets, upper case Counter,
forward slash, total asterisk 100, 2 left angled brackets, end l,
semicolon. 
Line 6: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled
brackets, double quotes, Percentage of lowercase characters, colon,
blank space, double quotes. 
Line 7, indented once: 2 left angled brackets, lowercase counter,
forward slash, total, asterisk 100, 2 left angled brackets, end l,
semicolon. 
Line 8: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses. 
Line 9, indented once: 2 left angled brackets, double quotes,
Percentage of blanks, colon, blank space, double quotes, 2 left
angled brackets, blank Counter, forward slash, total, asterisk 100, 2
left angled brackets, end l, semicolon. 
Line 10: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses. 
Line 11, indented once: 2 left angled brackets, double quotes,
Percentage of digits, colon, blank space, double quotes, 2 left
angled brackets, digit Counter, forward slash, total asterisk 100.
Line 12: 2 left angled brackets, end l, semicolon. 
Line 13: output, 2 left angled brackets, fixed, 2 left angled brackets,
set precision, left parentheses, 3, right parentheses, 2 left angled
brackets, double quotes, Percentage of end hyphen of hyphen
sentence, blank space, double quotes. 
Line 14, indented once: 2 left angled brackets, double quotes,
punctuation, blank space, double quotes, 2 left angled brackets,
punctuation Counter, forward slash, total asterisk 100, 2 left angled
brackets, end l, semicolon. 
Line 15: blank. 
Line 16: Output Dialog output Dialog, left parentheses, output dot s t
r, left parentheses, right parentheses, right parentheses, semicolon. 
Line 17: output Dialog dot display, left parentheses, right

parentheses, semicolon. 
Line 18: blank. 
Line 19: return 0, semicolon. 
Line 20: right brace.
Back to Figure
Program code. The code contains the following keywords: int, do,
while. 
Line 1: int x equals 1, semicolon. 
Line 2: int y equals 0, semicolon. 
Line 3: do. 
Line 4: left brace. 
Line 5, indented once: y equals x plus y, semicolon. 
Line 6: right brace, while, left parentheses, x less than or equal to
10, right parentheses, semicolon.
Back to Figure
Program code. The code contains the following keywords: int, for. 
Line 1: int x, semicolon. 
Line 2: int y equals 0, semicolon. 
Line 3: for, left parentheses, x equals 1, semicolon, x less than or
equal to 10, semicolon, x plus plus, right parentheses. 
Line 4, indented once: y equals x plus y, semicolon.
Back to Figure
A program code. The words in the keywords are merged. The code
contains the following keywords: for, c in. 
Line 1: for, left parentheses, c in, 2 right angled brackets, c h,
semicolon, c h, exclamation mark, equals sign, single quote,
backward slash, n, single quote, semicolon, c in, 2 right angled
brackets, c h, right parentheses, semicolon.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: for, c in, if, continue, break, c out. 
Line 1: for, left parentheses, c in, 2 right angled brackets, c h,

semicolon, c h, exclamation mark, equals sign, single quotes,
backward slash, n, single quotes, semicolon, c in, 2 right angled
brackets, c h, right parentheses, left brace. 
Line 2: if, left parentheses, c h less than 10, right parentheses. 
Line 3, indented once: continue, semicolon. 
Line 4: if, left parentheses, c h greater than 20, right parentheses. 
Line 5, indented once: break, semicolon. 
Line 6: c out, 2 left angled brackets, c h, semicolon. 
Line 7: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: for, int, c out.
Line 1: for, left parentheses, int x equals 1, semicolon, x less than or
equal to 10, semicolon, x plus plus, right parentheses. 
Line 2, indented once: for, left parentheses, int y equals 1,
semicolon, y less than or equal to 10, semicolon, y plus plus, right
parentheses. 
Line 3, indented twice: for, left parentheses, int z equals 1,
semicolon, z less than or equal to 10, semicolon, z plus plus, right
parentheses. 
Line 4, indented thrice: c out, 2 left angled brackets, x plus y plus z,
semicolon.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: switch, case, c out, default. 
Line 1: switch, left parentheses, wood, right parentheses. 
Line 2: left brace. 
Line 3, indented once: case, single quote, uppercase p, single
quote, colon, c out, 2 left angled brackets, double quotes, Pine,
double quotes, semicolon. 
Line 4, indented once: case, single quote, uppercase f, single quote,
colon, c out, 2 left angled brackets, double quotes, Fir, double
quotes, semicolon. 
Line 5, indented once: case, single quote, uppercase c, single quote,
colon, c out, 2 left angled brackets, double quotes, Cedar, double

quotes, semicolon. 
Line 6, indented once: case, single quote, uppercase o, single
quote, colon, c out, 2 left angled brackets, double quotes, Oak,
double quotes, semicolon. 
Line 7, indented once: case, single quote, uppercase m, single
quote, colon, c out, 2 left angled brackets, double quotes, Maple,
double quotes, semicolon. 
Line 8, indented once: default, colon, c out, 2 left angled brackets,
double quotes, Error, double quotes, semicolon. 
Line 9: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: switch, case, c out, break, default. 
Line 1: switch, left parentheses, month, right parentheses. 
Line 2: left brace. 
Line 3, indented once: case 1, colon, c out, 2 left angled brackets,
double quotes, January, double quotes, semicolon, break,
semicolon. 
Line 4, indented once: case 2, colon, c out, 2 left angled brackets,
double quotes, February, double quotes, semicolon, break,
semicolon. 
Line 5, indented once: case 3, colon, c out, 2 left angled brackets,
double quotes, March, double quotes, semicolon, break, semicolon. 
Line 6, indented once: case 4, colon, c out, 2 left angled brackets,
double quotes, April, double quotes, semicolon, break, semicolon. 
Line 7, indented once: case 5, colon, c out, 2 left angled brackets,
double quotes, May, double quotes, semicolon, break, semicolon. 
Line 8, indented once: case 6, colon, c out, 2 left angled brackets,
double quotes, June, double quotes, semicolon, break, semicolon. 
Line 9, indented once: case 7, colon, c out, 2 left angled brackets,
double quotes, July, double quotes, semicolon, break, semicolon. 
Line 10, indented once: case 8, colon, c out, 2 left angled brackets,
double quotes, August, double quotes, semicolon, break, semicolon.
Line 11, indented once: case 9, colon, c out, 2 left angled brackets,
double quotes, September, double quotes, semicolon, break,
semicolon. 
Line 12, indented once: case 10, colon, c out, 2 left angled brackets,

double quotes, December, double quotes, semicolon, break,
semicolon. 
Line 13, indented once: default, colon, c out, 2 left angled brackets,
double quotes, Error, double quotes, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: do, c out, end l,
while. 
Line 1: do. 
Line 2: left brace. 
Line 3, indented once: in Count equals 3, semicolon. 
Line 4, indented once: do. 
Line 5, indented once: left brace. 
Line 6, indented twice: c out, 2 left angled brackets, out Count plus
in Count, 2 left angled brackets, end l, semicolon. 
Line 7, indented twice: in Count, minus minus, semicolon. 
Line 8, indented once: right brace, while, left parentheses, in Count
greater than 0, right parentheses, semicolon. 
Line 9, indented once: out Count plus plus, semicolon. 
Line 10: while, left parentheses, out Count less than 2, right
parentheses, semicolon.
Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: for, int, c out,
end l. 
Line 1: for, left parentheses, int out Count equals negative 1,
semicolon, out Count less than 2, semicolon, out Count plus plus,
right parentheses. 
Line 2, indented once: for, left parentheses, int in Count equals 3,
semicolon, in Count greater than 0, semicolon, in Count minus
minus, right parentheses. 
Line 3, indented twice: c out, 2 left angled brackets, out Count plus
in Count, 2 left angled brackets, end l, semicolon.

Back to Figure
"Program code. The words in the keywords are merged and the
code contains the following keywords: for, int, switch, case, c out,
break. 
Line 1: for, left parentheses, int count equals 1, semicolon, count,
less than or equal to 4, semicolon, count plus plus, right
parentheses. 
Line 2, indented once: switch, left parentheses, count, right
parentheses. 
Line 3, indented once: left brace. 
Line 4, indented twice: case 4, colon, c out, 2 left angled brackets,
double quotes, blank space, cow, question mark, double quotes,
semicolon, break, semicolon. 
Line 5, indented twice: case 2, colon, c out, 2 left angled brackets,
double quotes, blank space, now, double quotes, semicolon, break,
semicolon. 
Line 6, indented twice: case 1, colon, c out, 2 left angled brackets,
double quotes, How, double quotes, semicolon, break, semicolon. 
Line 7, indented twice: case 3, colon, c out, 2 left angled brackets,
double quotes, blank space, brown, double quotes, semicolon,
break, semicolon. 
Line 8, indented once: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: for, if, c out, else, break. 
Line 1: count equals 1, semicolon. 
Line 2: for, left parentheses, semicolon, semicolon, count plus plus,
right parentheses. 
Line 3, indented once: if, left parentheses, count less than 3, right
parentheses. 
Line 4, indented twice: c out, 2 left angled brackets, count,
semicolon. 
Line 5, indented once: else. 
Line 6, indented twice: break, semicolon.
Back to Figure

"The expressions are as follows. a. left parentheses, left
parentheses, a asterisk b, right parentheses, right parentheses,
plus, open parentheses, c asterisk d, right parentheses, right
parentheses. b. open parentheses, open parentheses, a asterisk b,
right parentheses, forward slash, right parentheses, c asterisk d,
right parentheses, right parentheses. c. left parentheses, left
parentheses, a plus b, right parentheses, plus, left parentheses, left
parentheses, c forward slash, left parentheses, d plus e, right
parentheses, right parentheses, asterisk f, right parentheses, right
parentheses. d. left parentheses, left parentheses, left parentheses,
a plus b, right parentheses, forward slash, left parentheses, c plus d,
right parentheses, right parentheses, asterisk, left parentheses, e
plus f, right parentheses, right parentheses. e. left parentheses, left
parentheses, negative a plus b, right parentheses, left angled
bracket, equals sign, left parentheses, c asterisk d, right
parentheses, right parentheses, ampersand, ampersand, left
parentheses, left parentheses, a plus b, right parentheses, right
angled bracket, equals sign, left parentheses, c minus d, right
parentheses, right parentheses.
Back to Figure
The first output is as follows. Line 1: Enter time, colon, 12, blank
space, 0 0. Line 2: Noon. The second output is as follows. Line 1:
Enter time, colon, 0, blank space, 0 0. Line 2: Midnight. The third
output is as follows. Line 1: Enter time, colon, 6, blank space, 44.
Line 2: Six forty four A M. The fourth output is as follows. Line 1:
Enter time, colon, 18, blank space, 11. Line 2: Six eleven P M.
Back to Figure
The visible portions are the heading, Precondition, and
postcondition. Heading: void Print Activity, left parentheses, int temp,
right parentheses. Precondition: temp is a temperature value in a
valid range. Postcondition: A message has been printed indicating
an appropriate activity given temperature temp. The Implementation
is the invisible portion of the module.
Back to Figure

Line 1: 15 asterisks. 
Line 2: 15 asterisks. 
Line 3: blank space. Welcome, blank space, Home, exclamation
mark. blank space. 
Line 4: 15 asterisks. 
Line 5: 15 asterisks. 
Line 6: 15 asterisks. 
Line 7: 15 asterisks.
Back to Figure
Line 1: int main, left parentheses, right parentheses, semicolon. 
Line 2: left brace. 
Line 3, indented once: Print 2 Lines, left parentheses, right
parentheses, semicolon. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
blank space, Welcome, blank space, Home, exclamation mark,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 5, indented once: Print 4 Lines, left parentheses, right
parentheses, semicolon. 
Line 6, indented once: return 0, semicolon. 
Line 7: right brace.
Back to Figure
Program code. The words in the keywords and function names are
merged. The program contains the following keywords: void, c out,
end l. 
Line 1: void Print 2 Lines, left parentheses, right parentheses. 2
forward slashes, Function heading. 
Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 4, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Back to Figure

Program code. The words in the keywords, and function names are
merged. The code contains the following keywords: include, i o
stream, using, name space s t d, void, int, main, return, c out, end l.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes, Welcome program. 
Line 3: 2 forward slashes, This program outputs a double quotes,
Welcome, blank space, Home, double quotes, message. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled brackets, i o stream, right angled
brackets. 
Line 6: using name space s t d, semicolon. 
Line 7: blank. 
Line 8: void Print 2 Lines, left parentheses, right parentheses,
semicolon. 2 forward slashes, function prototypes. 
Line 9: 2 forward slashes, This function prints 2 lines of asterisks. 
Line 10: void Print 4 Lines, left parentheses, right parentheses,
semicolon. 
Line 11: 2 forward slashes, This function prints 4 lines of asterisks. 
Line 12: int main, left parentheses, right parentheses. 
Line 13: left brace. 
Line 14, indented once: Print 2 Lines, left parentheses, right
parentheses, semicolon. 2 forward slashes, Function call. 
Line 15, indented once: c out, 2 left angled brackets, double quotes,
blank space, Welcome, blank space, Home, exclamation mark,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 16, indented once: Print 4 Lines, left parentheses, right
parentheses, semicolon. 2 forward slashes, Function call. 
Line 17, indented once: return 0, semicolon. 
Line 18: right brace. 
Line 19: blank. 
Line 20: 2 forward slashes followed by asterisks till the end of the
line. 
Line 21: void Print 2 Lines, left parentheses, right parentheses. 2
forward slashes, Function heading. 
Line 22: left brace. 
Line 23, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 24, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.

Line 25: right brace. 
Line 26: 2 forward slashes followed by asterisks till the end of the
line. 
Line 27: blank. 
Line 28: void Print 4 Lines, left parentheses, right parentheses. 2
forward slashes, Function heading. 
Line 29: left brace. 
Line 30, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 31, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 32, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 33, indented once: c out, 2 left angled brackets, double quotes,
15 asterisks, double quotes, 2 left angled brackets, end l, semicolon.
Line 34: right brace.
Back to Figure
The program listing is as follows. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3: dot. 
Line 4: dot. 
Line 5: dot. 
Line 6: uppercase c, left parentheses, right parentheses, semicolon. 
Line 7: uppercase b, left parentheses, right parentheses, semicolon.
Line 8: uppercase a, left parentheses, right parentheses, semicolon.
Line 9: return 0, semicolon. 
Line 10: right brace. 
Line 11: void uppercase a, left parentheses, right parentheses. 
Line 12: left brace. 
Line 13: dot. 
Line 14: dot. 
Line 15: dot. 
Line 16: right brace. 
Line 17: void uppercase b, left parentheses, right parentheses. 
Line 18: left brace. 
Line 19: dot.

Line 20: dot. 
Line 21: dot. 
Line 22: right brace. 
Line 23: void uppercase c, left parentheses, right parentheses. 
Line 24: left brace. 
Line 25: dot. 
Line 26: dot. 
Line 27: dot. 
Line 28: right brace.
Back to Figure
Program code. The words in the keywords and function names are
merged. The code contains the following keywords: include, i o
stream, using, name space, s t d, void, int, c out, return, for, end l. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes, New Welcome program. 
Line 3: 2 forward slashes, This program prints a double quotes,
Welcome, blank space, Home, double quotes, message. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled brackets, i o stream, right angled
brackets. 
Line 6: using name space s t d, semicolon. 
Line 7: blank. 
Line 8: void Print Lines, left parentheses, int num Lines, right
parentheses, semicolon. 2 forward slashes, Function prototype. 
Line 9: 2 forward slashes. This function prints lines of asterisks,
where. 
Line 10: 2 forward slashes. num Lines specifies how many lines to
print. 
Line 11: blank. 
Line 12: int main, left parentheses, right parentheses. 
Line 13: left brace. 
Line 14, indented once: Print Lines, left parentheses, 2, right
parentheses, semicolon. 
Line 15, indented once: c out, 2 left angled brackets, double quotes,
blank space, Welcome, blank space, Home, exclamation mark,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 16, indented once: Print Lines, left parentheses, 4, right

parentheses, semicolon. 
Line 17, indented once: return 0, semicolon. 
Line 18: right brace. 
Line 19: 2 forward slashes followed by asterisks till the end of the
line. 
Line 20: void Print Lines, left parentheses, int num Lines, right
parentheses. 
Line 21: left brace. 
Line 22, indented once: for, left parentheses, int count equals 1,
semicolon, count less than or equal to num Lines, semicolon, count
plus plus, right parentheses. 
Line 23, indented twice: c out, 2 left angled brackets, 15 asterisks
within double quotes, 2 left angled brackets, end l, semicolon. 
Line 24: right brace.
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The program contains the following
keywords: int, main, c out, end l, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: int line Count equals 2, semicolon. 
Line 4, indented once: Print Lines, left parentheses, line Count, right
parentheses, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
blank space, Welcome, blank space, Home, exclamation mark,
double quotes, 2 left angled brackets, end l, semicolon. 
Line 6, indented once: line Count equals line Count plus 2,
semicolon. 
Line 7, indented once: Print Lines, left parentheses, line Count, right
parentheses, semicolon. 
Line 8, indented once: return 0, semicolon. 
Line 9: right brace.
Back to Figure
Program code. The words in the keywords and variable names are
merged. The code uses the following keywords: include, i o stream,

using, namespace, s t d, void, int, main, float. 
Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: blank. 
Line 4: void Try This, left parentheses, int, comma, int, comma,
float, right parentheses, semicolon. 2 forward slashes. Function
prototype for Try This. 
Line 5: blank. 
Line 6: int main, left parentheses, right parentheses. 2 forward
slashes, Function definition for main. 
Line 7: left brace. 
Line 8, indented once: int int 1, semicolon. 2 forward slashes.
Variables local to main. 
Line 9, indented once: int int 2, semicolon. 
Line 10, indented once: float some Float, semicolon. 
Dot, dot, dot. 
Line 11, indented once: Try This, left parentheses, int 1, comma, int
2, comma, some Float, right parentheses, semicolon. 2 forward
slashes. Function call with. 
Line 12: 2 forward slashes. three arguments. 
Dot, dot, dot. 
Line 13: right brace. 
Line 14: blank. 
Line 15: void Try This, left parentheses, int param 1, comma. 2
forward slashes. Function definition for Try This. 
Line 16: int param 2, comma. 2 forward slashes. with three
parameters. 
Line 17: float param 3, right parentheses. 
Line 18: left brace. 
Line 19, indented once: int i, semicolon. 2 forward slashes. Variables
local to Try This. 
Line 20, indented once: float x, semicolon. 
Dot, dot, dot. 
Line 21: right brace.
Back to Figure

Program code. The words in the keywords and function names are
merged. The code contains the following keywords: void, int, if, c
out, return. 
Line 1: void Some Func, left parentheses, int n, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, n greater than 50, right
parentheses. 
Line 4, indented once: left brace. 
Line 5, indented twice: c out, 2 left angled brackets, double quotes,
The value is out of range, period, double quotes, semicolon. 
Line 6, indented twice: return, semicolon. 
Line 7, indented once: right brace. 
Line 8, indented once: n equals 412 asterisk n, semicolon. 
Line 9, indented once: c out, 2 left angled brackets, n, semicolon. 
Line 10: right brace.
Back to Figure
Program code. The words in the keywords and function names are
merged. The program contains the following keywords: void, if, c
out, else, c out. 
Line 1: void Some Func, left parentheses, n greater than 50, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, n greater than 50, right
parentheses. 
Line 4, indented twice: c out, 2 left angled brackets, double quotes,
The value is out of range, period, double quotes, semicolon. 
Line 5, indented once: else. 
Line 6, indented once: left brace. 
Line 7, indented twice: n equals 412 asterisk n, semicolon. 
Line 8, indented twice: c out, 2 left angled brackets, n, semicolon. 
Line 9, indented once: right brace. 
Line 10: right brace.
Back to Figure
Line 1: void Example, left parentheses, int ampersand param 1,
comma. 2 forward slashes. A reference parameter. 

Line 2: int param 2, comma. 2 forward slashes. A value parameter. 
Line 3: float param 3, right parentheses. 2 forward slashes. Another
value parameter.
Back to Figure
3 statements. Line 1: Print Lines, left parentheses, 3, right
parentheses, semicolon. Line 2: Print Lines, left parentheses, line
Count, right parentheses, semicolon. Line 3: Print Lines, left
parentheses, 2 asterisk a b s, left parentheses 10 minus some Int,
right parentheses, right parentheses, semicolon.
In both diagrams, 3 blocks are shown. The first block is labeled int
main, left parentheses, right parentheses. The second block is
labeled void Get Temp, left parentheses, int ampersand temp, right
parentheses. The third block corresponds to the variable
temperature. The variable temperature is declared by the main
function. In the first diagram, an arrow is drawn from the block
corresponding to the main function to the block corresponding to the
variable temperature. The caption above the first diagram reads:
When flow of control is in the main function, temperature can be
accessed as shown by the arrow.
Back to Figure
Function heading: void Show Match, left parentheses, float
ampersand num 1, comma, int num 2, comma, char ampersand
letter, right parentheses. Function call: Show Match, left
parentheses, float var, int var, char var. A double headed arrow is
drawn between float ampersand num 1 and float var. A second
double headed arrow is drawn between int num 2 and int var. A third
double headed arrow is drawn between char ampersand letter and
char var.
The modules under the Main module are, Get Loan A m t, Get Rest,
Loan Payment, and Output Results. The modules under the Get
Rest module are, Get Interest, and Get Years. The Get Loan A m t
module returns the loan Amount. The Get Rest module returns the
monthly Interest and number Of Years. The inputs to the Loan

Payment module are loan Amount, monthly Interest, and number Of
Payments. The output of the Loan Payment module is payments.
The inputs to the Output Results module are loan Amount, yearly
Interest, number Of Payments, payment, and total Interest. The Get
Interest module returns the monthly Interest. The Get Years module
returns the number Of Years.
The keywords used are as follows: void, float, int. The function
prototypes are as follows. 
Line 1: void Get Loan Amt, left parentheses, float ampersand loan
Amount, right parentheses. 
Line 2: void Get Rest, left parentheses, float ampersand monthly
Interest, comma, int ampersand number Of Years, right
parentheses. 
Line 3: void Get Interest, left parentheses, float ampersand monthly
Interest, right parentheses. 
Line 4: void Determine Payment, left parentheses, float loan
Amount, comma, int yearly Interest, comma, int number of
Payments, comma, float ampersand payment, right parentheses. 
Line 5: void Output Results, left parentheses, float loan Amount,
comma, float yearly Interest, comma, int number Of Payments,
comma, float payment, comma, float total Interest, right
parentheses, semicolon."
Back to Figure
Program code. The words in the keywords, variable names, and
function names are merged. The code contains the following
keywords: include, c math, i o man i p, i o stream, using, name
space, s t d, void, float, int, main, while.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes, Loan calculator program. 
Line 3: 2 forward slashes, This program determines the monthly
payments on a loan given. 
Line 4: 2 forward slashes, the loan amount, comma, yearly interest
rate, comma, number of years, comma. 
Line 5: 2 forward slashes, and total interest paid over the period of
the loan, period. 
Line 6: 2 forward slashes, The process repeats until a negative loan

amount is entered. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: hash include, left angled bracket, c math, right angled
bracket. 
Line 9: hash include, left angled bracket, i o man i p, right angled
bracket. 
Line 10: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 11: using name space s t d, semicolon. 
Line 12: blank. 
Line 13: 2 forward slashes, Function prototypes. 
Line 14: void Get Loan A m t, left parentheses, float ampersand loan
Amount, right parentheses, semicolon. 
Line 15: void Get Rest, left parentheses, float ampersand monthly
Interest, comma, int ampersand number Of Years, right
parentheses, semicolon. 
Line 16: void Get Interest, left parentheses, float ampersand
monthly Interest, right parentheses, semicolon. 
Line 17: void Determine Payment, left parentheses, float loan
Amount, comma, float monthly Interest, comma. 
Line 18: int number Of Payments, comma, float ampersand
payment, right parentheses, semicolon. 
Line 19: void Output Results, left parentheses, float loan Amount,
comma, float yearly Interest, comma. 
Line 20: int number Of Payments, comma, float payment, comma. 
Line 21: float total Interest, right parentheses, semicolon. 
Line 22: int main, left parentheses, right parentheses. 
Line 23: left brace. 
Line 24, indented once: 2 forward slashes, Variable declarations. 
Line 25, indented once: float loan Amount, semicolon. 
Line 26, indented once: int number Of Years, semicolon. 
Line 27, indented once: float monthly Interest, semicolon. 
Line 28, indented once: int number Of Payments, semicolon. 
Line 29, indented once: float payment, semicolon. 
Line 30, indented once: float total Interest, semicolon. 
Line 31, indented once: 2 forward slashes, calculate payments. 
Line 32, indented once: Get Loan A m t, left parentheses, loan
Amount, right parentheses, semicolon. 
Line 33, indented once: while, left parentheses, loan Amount greater

than 0, right parentheses. 
Line 34, indented once: left brace. 
Line 35, indented twice: Get Rest, left parentheses, monthly
Interest, comma, number Of Years, right parentheses, semicolon. 
Line 36, indented twice: number Of Payments equals number Of
Years asterisk 12, semicolon.
Back to Figure
Program code. The words in the keywords, variable names, and
function names are merged. The code contains the following
keywords: return, void, c out, end l, c in, float, if, int.Line 1, indented
twice: Determine Payment, left parentheses, loan Amount, comma,
monthly Interest, comma. 
Line 2: number Of Payments, comma, payment, right parentheses,
semicolon. 
Line 3, indented twice: total Interest equals payment asterisk
number of Payments minus loan Amount, semicolon. 
Line 4, indented twice: Output Results, left parentheses, loan
Amount, comma, monthly Interest, comma, number Of Payments,
comma. 
Line 5: payment, comma, total Interest, right parentheses,
semicolon. 
Line 6, indented twice: Get Loan A m t, left parentheses, loan
Amount, right parentheses, semicolon. 
Line 7, indented once: right brace. 
Line 8, indented once: return 0, semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: void Get Loan A m t, left parentheses, float ampersand loan
Amount, right parentheses. 
Line 12: left brace. 
Line 13, indented once: c out, 2 left angled brackets, double quotes,
Input loan amount, period, blank space, double quotes. 
Line 14, indented twice: 2 left angled brackets, double quotes, A
negative loan amount ends the processing, period, double quotes. 
Line 15, indented twice: 2 left angled brackets, end l, semicolon. 
Line 16, indented once: c in, 2 right angled brackets, loan Amount,

semicolon. 
Line 17: right brace. 
Line 18: 2 forward slashes followed by asterisks till the end of the
line. 
Line 19: void Get Rest, left parentheses, float ampersand monthly
Interest, comma, int ampersand number Of Years, right
parentheses. 
Line 20: left brace. 
Line 21, indented once: Get Interest, left parentheses, monthly
Interest, right parentheses, semicolon. 
Line 22, indented once: c out, 2 left angled brackets, double quotes,
Enter the number of years of the loan, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 23, indented once: c in, 2 right angled brackets, number Of
Years, semicolon. 
Line 24: right brace. 
Line 25: void Get Interest, left parentheses, float ampersand
monthly Interest, right parentheses. 
Line 26: left brace. 
Line 27, indented once: float yearly Interest, semicolon. 2 forward
slashes, Local variable. 
Line 28, indented once: c out, 2 left angled brackets, double quotes,
Input interest rate, period, blank space, double quotes. 
Line 29, indented twice: 2 left angled brackets, double quotes, An
interest rate of less than 0.25 is assumed, blank space, double
quotes. 
Line 30, indented twice: 2 left angled brackets, double quotes, blank
space, to be a decimal rather than a percent, period, double quotes,
2 left angled brackets, end l, semicolon. 
Line 31, indented once: c in, 2 right angled brackets, yearly Interest,
semicolon. 
Line 32, indented once: if, left parentheses, yearly Interest greater
than or equal to 0.25, right parentheses. 2 right angled brackets,
Assume percent entered. 
Line 33, indented twice: yearly Interest equals yearly Interest divided
by 100.0, semicolon. 
Line 34, indented once: monthly Interest equals yearly Interest
divided by 12, semicolon. 
Line 35: right brace. 

Line 36: 2 forward slashes followed by asterisks till the end of the
line. 
Line 37: void Determine Payment, left parentheses, float loan
Amount, comma, float monthly Interest, comma, int number Of
Payments, comma, float ampersand payment, right parentheses. 
Line 38: left brace. 
Line 39, indented once: using namespace s t d, semicolon. 
Line 40, indented once: payment equals left parentheses, loan
Amount asterisk p o w, left parentheses, 1 plus monthly Interest,
comma, number Of Payments, right parentheses. 
Line 41: asterisk monthly Interest, right parentheses, forward slash. 
Line 42: left parentheses, p o w, left parentheses, 1 plus monthly
Interest, comma, number Of Payments, right parentheses, minus 1,
right parentheses, semicolon. 
Line 43: right brace.
Back to Figure
Program code. The words in the keywords, variable names, and
function names are merged. The code contains the following
keywords: void, float, int, c out, end l.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Output Results, left parentheses, float loan Amount,
comma, float yearly Interest, comma. 
Line 3: int number Of Payments, comma, float payment, comma. 
Line 4: float total Interest, right parentheses. 
Line 5: left brace. 
Line 6, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, double quotes, Loan amount, colon, blank spaces,
double quotes, 2 left angled brackets, set precision, left
parentheses, 2, right parentheses. 
Line 7, indented twice: 2 left angled brackets, loan Amount, 2 left
angled brackets, end l, 2 left angled brackets, double quotes,
Interest rate, colon, blank spaces, double quotes. 
Line 8, indented twice: 2 left angled brackets, set precision, left
parentheses, 4, right parentheses, 2 left angled brackets, yearly
Interest asterisk 100.0, 2 left angled brackets, double quotes,
percent, double quotes, 2 left angled brackets, end l. 
Line 9, indented twice: 2 left angled brackets, double quotes,

Number of payments, colon, blank spaces, double quotes, 2 left
angled brackets, number Of Payments, 2 left angled brackets, end l,
semicolon. 
Line 10, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, double quotes, Monthly payments, colon, blank
spaces, double quotes, 2 left angled brackets, set precision, left
parentheses, 2, right parentheses. 
Line 11, indented twice: 2 left angled brackets, payment, 2 left
angled brackets, end l, semicolon. 
Line 12, indented once: c out, 2 left angled brackets, fixed, 2 left
angled brackets, double quotes, Total Interest, colon, blank spaces,
double quotes, 2 left angled brackets, set precision, left
parentheses, 2, right parentheses. 
Line 13, indented twice: 2 left angled brackets, left parentheses,
payment asterisk number Of Payments minus loan Amount, right
parentheses, 2 left angled brackets, end l, semicolon. 
Line 14: right brace.
Line 1: Input loan amount. A negative loan amount ends the
processing. 
Line 2: 3000. 3000 is shaded. 
Line 3: Input interest rate. An interest rate of less than 0.25 is
assumed. 
Line 4: to be a decimal rather than a percent. 
Line 5: 6.8. 6.8 is shaded. 
Line 6: Enter the number of years of the loan. 
Line 7: 2. 2 is shaded. 
Line 8: Loan amount, colon, 3000.00. 
Line 9: Interest rate, colon, 0.5667 percent. 
Line 10: Number of payments, colon, 24. 
Line 11: Monthly payments, colon, 134.05. 
Line 12: Total Interest, colon, 217.13. 
Line 13: Input loan amount. A negative loan amount ends the
processing. 
Line 14: negative 1. Negative 1 is shaded.
Back to Figure

Program code. The words in the variable names and function names
are merged. The code contains the following keywords. Int, main. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3: dot. 
Line 4: dot. 
Line 5: dot. 
Line 6: Get Rest, left parentheses, monthly Interest, comma,
number Of Years, right parentheses, semicolon. 
Line 7: number Of Payments equals number Of Years asterisk 12,
semicolon. 
Line 8: Determine Payment, left parentheses, monthly Interest,
comma, loan Amount, comma, number Of Payment, comma,
payment, right parentheses, semicolon. 
Line 9: dot. 
Line 10: dot. 
Line 11: dot. 
Line 12: right brace.
Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords. Int, main, while, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: int temperature, semicolon. 
Line 4, indented once: Get Temp, left parentheses, temperature,
right parentheses, semicolon. 
Line 5, indented once: while, left parentheses, temperature,
exclamation mark, equals sign, negative 1000, right parentheses. 
Line 6, indented once: left brace. 
Line 7, indented twice: Display Activity, left parentheses,
temperature, right parentheses, semicolon. 
Line 8, indented twice: Get Temp, left parentheses, temperature,
right parentheses, semicolon. 
Line 9, indented once: right brace. 
Line 10, indented once: return 0, semicolon. 
Line 11: right brace.

Back to Figure
Program code. The words in the keywords and the function names
are merged. The code contains the following keywords: void, c out,
int, c in, while, end l. 
Line 1: void Get Temp, left parentheses, int ampersand temp, right
parentheses. 
Line 2: 2 forward slashes. This function prompts for and reads a
temperature. 
Line 3: 2 forward slashes. and checks to be sure it is between
negative 50 and 130. 
Line 4: left brace. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Enter the outside temperature, left parentheses, negative 50
through 130, right parentheses, colon, blank space, double quotes,
semicolon. 
Line 6, indented once: c in, 2 right angled brackets, temp,
semicolon. 
Line 7, indented once: while, left parentheses, temp less than
negative 50, 2 vertical pipes, temp greater than 130, right
parentheses, right parentheses. 2 forward slashes. temp is invalid,
dot, dot, dot. 
Line 8, indented once: left brace. 
Line 9, indented twice: c out, 2 left angled brackets, double quotes,
Temperature must be, double quotes. 
Line 10, indented thrice: 2 left angled brackets, double quotes,
negative 50 through 130, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 11, indented twice: c out, 2 left angled brackets, double quotes,
Enter the outside temperature, colon, blank space, double quotes,
semicolon. 
Line 12, indented twice: c in, 2 right angled brackets, temp,
semicolon. 
Line 13, indented once: right brace. 
Line 14: right brace."
Back to Figure

Program code. The words in the function name is merged. The code
contains the following keywords: void, float, int, c out, end l. 
Line 1: void Output Average, left parentheses, float sum, comma, int
count, right parentheses. 
Line 2: 2 right angled brackets. Pre, colon, sum has been assigned
and count is greater than 0. 
Line 3: 2 right angled brackets. Post, colon, The average has been
output on one line. 
Line 4: left brace. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Average is, blank space, double quotes, 2 left angled brackets, sum,
forward slash, float, left parentheses, count, right parentheses, 2 left
angled brackets, end l, semicolon. 
Line 6: right brace."
Back to Figure
Program code. The words in the function name, variable names and
the keywords are merged. The code contains the following
keywords: void, int, c out, end l, c out. 
Line 1: void Get 2 Ints, left parentheses, int ampersand, int 1,
comma, int ampersand, int 2, right parentheses. 
Line 2: 2 forward slashes. Post, colon, User has been prompted to
enter two integers. 
Line 3: 2 forward slashes, tab space, int 1 is the first input value. 
Line 4: 2 forward slashes, tab space, int 2 is the second input value. 
Line 5: left brace. 
Line 6, indented once: c out, 2 left angled brackets, double quotes,
Please enter two integers, colon, blank space, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 7, indented once: c in, 2 right angled brackets, int 1, 2 right
angled brackets, int 2, semicolon. 
Line 8: right brace.
Program code. The keywords used are as follows. float, int. Line 1:
Print, left parentheses, forward slash, asterisk, In, asterisk, forward
slash. float v a l, comma, 2 forward slashes, Value to be printed.
Line 2: forward slash, asterisk, In, forward slash, out, asterisk,

forward slash, int count, right parentheses. 2 forward slashes.
Number of lines printed so far.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: void, int. 
Line 1: void Swap, left parentheses, forward slash, asterisk, In,
forward slash, out, asterisk, forward slash, int ampersand, first Int,
comma. 
Line 2, indented twice: forward slash, asterisk, In, forward slash,
out, asterisk, forward slash, int ampersand second Int, right
parentheses. 
Line 3: 2 forward slashes. Precondition, colon. 
Line 4: 2 forward slashes. tab space, first Int and second Int are
assigned.
Line 5: 2 forward slashes. Post condition, colon. 
Line 6: 2 forward slashes. tab space, first Int equals equals second
Int at entry. 
Line 7: 2 forward slashes. ampersand ampersand second int equals
equals first Int at entry. 
Line 8: left brace. 
Line 9, indented once: int temporary Int, semicolon. 
Line 10: blank. 
Line 11, indented once: temporary Int equals first Int, semicolon. 
Line 12, indented once: first Int equals second Int, semicolon. 
Line 13, indented once: second Int equals temporary Int, semicolon. 
Line 14: right brace.
Back to Figure
Line 1: Llewelynn Francis Gene. 
Line 2: 518034 West Elm Street. 
Line 3: Cypressville S D 58234. 
Line 4: 4. 
Line 5: 1, blank space, 30. 
Line 6: 1, blank space, 30. 
Line 7: 2, blank space, 15. 
Line 8: 1, blank space, 50.

The 4 modules under the Main module are as follows. Open Files.
Get Hourly Rate. Process Clients. Close Files. The modules under
Process Clients are as follows. Write Name. Process A Client. Get
Name. Print Results. The module under Process A Client is as
follows. Get and Print Address.
Back to Figure
The row entries are as follows.
Row 1. Variable: hourly Rate. Module: Main. Operator Used: 2 right
angled brackets. Position of the Reading Pointer: Only item read
from keyboard.
Row 2. Variable: name. Module: Process Clients. Operator Used:
get line. Position of the Reading Pointer: Pointer left at next line.
Row 3. Variable: address, left parentheses, two lines, right
parentheses. Module: Get And Print Address. Operator Used: 2
right angled brackets. Position of the Reading Pointer: Pointer left on
same line.
Row 4. Variable: number of Jobs. Module: Process A Client.
Operator Used: 2 right angled brackets. Position of the Reading
Pointer: Pointer left on same line.
Row 5. Variable: hours, comma, minutes. Module: Process A Client.
Operator used: 2 right angled brackets. Position of the Reading
Pointer: Pointer left on same line.
Row 6. Variable: name. Module: Process Clients. Operator used: get
line. Position of the Reading Pointer: Pointer left at next line.
Back to Figure
Program code. The words in the variable names and function names
are merged. 
Line 1: Process A Client, left parentheses, dot, dot, dot, total Time,
comma, hourly Rate, right parentheses. 
Line 2, indented once: time equals hours asterisk 60 plus minutes
plus time, semicolon. 2 forward slashes, int equals int asterisk int
plus int plus int. 
Line 3, indented once: cost equals time forward slash 60 asterisk
hourly Rate, semicolon. 2 forward slashes, float equals int forward
slash int asterisk float. 

Line 4, indented once: total Time equals total Time plus time,
semicolon. 2 forward slashes, int equals int plus int."
Back to Figure
Program code. The names in the keywords, function names, and
variable names are merged. The code contains the following
keywords: c out, end l, int, float. 
Line 1. Print Results, left parentheses, number Of Bills, comma,
total Minutes, comma, hourly Rate, right parentheses. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Total amount billed this month is, blank space, double quotes. 
Line 3, indented twice: 2 left angled brackets, total Minutes, forward
slash, 60, asterisk, hourly Rate, 2 left angled brackets, end l,
semicolon. 
Line 4, indented twice: 2 forward slashes, int forward slash int
asterisk float. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Average time worked per job is, blank space, double quotes. 
Line 6, indented twice: 2 left angled brackets, total Minutes, forward
slash, number Of Bills, forward slash, 60, 2 left angled brackets, end
l, semicolon. 
Line 7, indented twice: 2 forward slashes, int, forward slash, int,
forward slash, int. 
Line 8, indented once: c out, 2 left angled brackets, double quotes,
Average customer bill is, blank space, double quotes. 
Line 9, indented twice: 2 left angled brackets, total Minutes, forward
slash, 60, asterisk, hourly Rate, forward slash, number Of Bills. 
Line 10, indented twice: 2 forward slashes, int, forward slash, int,
asterisk, float, forward slash, int. 
Line 11, indented twice: 2 left angled brackets, end l, semicolon."
Back to Figure
Program code. The words in the keywords, function names, and
variable names are merged. The code uses the following keywords:
include, i o stream, f stream, string, i o man i p, using, name space,
s t d, void, i f stream, o f stream, float, int. 
Line 1: 2 forward slashes, followed by asterisks till the end of the

line. 
Line 2: 2 forward slashes. Program Lawn Care calculates and writes
the bills for a lawn care. 
Line 3: 2 forward slashes. service company. The names of the input
and output files are. 
Line 4: 2 forward slashes. prompted for and read from the keyboard.
Line 5: 2 forward slashes, followed by asterisks till the end of the
line. 
Line 6: Hash include, left angled bracket, i o stream, right angled
bracket. 
Line 7: Hash include, left angled bracket, f stream, right angled
bracket. 
Line 8: Hash include, left angled bracket, string, right angled
bracket. 
Line 9: Hash include, left angled bracket, i o man i p, right angled
bracket. 
Line 10: Blank. 
Line 11: using name space s t d, semicolon. 
Line 12: 2 forward slashes, Function prototypes. 
Line 13: Void Open Files, left parentheses, i f stream ampersand in
File, comma, o f stream ampersand out File, right parentheses,
semicolon. 
Line 14: 2 forward slashes. Open Files reads in the names of the
input file and the. 
Line 15: 2 forward slashes. output file and opens them for
processing. 
Line 16: void Process Clients, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma. 
Line 17, indented: float hourly Rate, right parentheses, semicolon. 
Line 18: 2 forward slashes. Process Clients writes bills for all of the
clients. 
Line 19: 2 forward slashes. whose records are on in File. 
Line 20: void Process A Client, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma. 
Line 21, indented: int ampersand total Time, comma, float hourly
Rate, right parentheses, semicolon. 
Line 22: 2 forward slashes. Process A Client writes the bill for one
client. 
Line 23: void Get And Print Address, left parentheses, i f stream

ampersand in File, comma, o f stream ampersand out File, right
parentheses, semicolon. 
Line 24: 2 forward slashes. Get And Print Address reads the
address from in File and. 
Line 25: 2 forward slashes. prints it on out File. 
Line 26: void Print Results, left parentheses, int number Of Bills,
comma, int total Minutes, comma, float hourly Rate, right
parentheses, semicolon."
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The code contains the following
keywords. int, main, float, i f stream, o f stream, if, c out, end l,
return, c in, string, void, while. 
Line 1: 2 forward slashes. Print Results prints total billed, comma,
average time per job, comma. 
Line 2: 2 forward slashes. and average bill. 
Line 3: int main, left parentheses, right parentheses. 
Line 4: left brace. 
Line 5, indented once: float hourly Rate, semicolon. 
Line 6, indented once: i f stream in File, semicolon. 
Line 7, indented once: o f stream out File, semicolon. 
Line 8, indented once: Open Files, left parentheses, in File, comma,
out File, right parentheses, semicolon. 
Line 9, indented once: if, left parentheses, exclamation mark, in File,
2 vertical pipes, exclamation mark, out File, right parentheses. 
Line 10, indented once: left brace. 
Line 11, indented twice: c out, 2 left angled brackets, double quotes,
Error opening files, blank space, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 12, indented twice: return 1, semicolon. 
Line 13, indented once: right brace. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter hourly rate, period, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 15, indented once: c in, 2 right angled brackets, hourly Rate,
semicolon. 
Line 16, indented once: Process Clients, left parentheses, in File,

comma, out File, comma, hourly Rate, right parentheses, semicolon.
Line 17, indented once: in File dot close, left parentheses, right
parentheses, semicolon. 
Line 18, indented once: out File dot close, left parentheses, right
parentheses, semicolon. 
Line 19, indented once: return 0, semicolon. 
Line 20: right brace. 
Line 21: 2 forward slashes, followed by asterisks till the end of the
line. 
Line 22: void Open Files, left parentheses, i f stream ampersand in
File, comma, o f stream, ampersand out File, right parentheses. 
Line 23: 2 forward slashes. Post, colon, Files have been opened. 
Line 24: left brace. 
Line 25, indented once: string in File Name, semicolon. 2 forward
slashes. User specified input file name. 
Line 26, indented once: string out File Name, semicolon. 2 forward
slashes. User specified output file name. 
Line 27, indented once: c out, 2 left angled brackets, double quotes,
Enter the name of the input file, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 28,indented once: c in, 2 right angled brackets, in File Name,
semicolon. 
Line 29, indented once: in File dot open, left parentheses, in File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 30: blank. 
Line 31, indented once: c out, 2 left angled brackets, double quotes,
Enter the name of the output file, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 32, indented once: c in, 2 right angled brackets, out File Name,
semicolon. 
Line 33, indented once: out File dot open, left parentheses, out File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 34, indented once: out File, 2 left angled brackets, double
quotes, Billing for clients on file, blank space, double quotes, 2 left
angled brackets, in File Name, 2 left angled brackets, end l,
semicolon. 
Line 35, indented once: out File, 2 left angled brackets, fixed,

semicolon. 
Line 36: left brace. 
Line 37: 2 forward slashes followed by asterisks till the end of the
line. 
Line 38: void Process Clients, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma,
float hourly Rate, right parentheses. 
Line 39: 2 forward slashes. Pre, colon, Files have been opened and
the hourly rate has been set. 
Line 40: 2 forward slashes. Post, colon, Each bill has been written
and the summary values have. 
Line 41: 2 forward slashes, tab space, been written to the screen. 
Line 42: left brace. 
Line 43, indented once: int total Time equals 0, semicolon. 
Line 44, indented once: int number Of Bills equals 0, semicolon. 
Line 45, indented once: string name, semicolon. 
Line 46, indented once: get line, left parentheses, in File, comma,
name, right parentheses, semicolon. 
Line 47, indented once: while, left parentheses, in File, right
parentheses.
Back to Figure
Program code. The words in the keywords, function names, and
variable names are merged. The code contains the following
keywords: end l, void, int, float, c out, string.
Line 1, indented once: left brace. 
Line 2, indented twice: out File, 2 left angled brackets, name, 2 left
angled brackets, end l, semicolon. 
Line 3, indented twice: Process A Client, left parentheses, in File,
comma, out File, comma, total Time, comma, hourly Rate, right
parentheses, semicolon. 
Line 4, indented twice: number Of Bills, plus, plus, semicolon. 
Line 5, indented twice: get line, left parentheses, in File, comma,
name, right parentheses, semicolon. 
Line 6, indented once: right brace. 
Line 7, indented once: 2 forward slashes. Print summary
information. 
Line 8, indented once: Print Results, left parentheses, number Of

Bills, comma, total Time, comma, hourly Rate, right parentheses,
semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: void Print Results, left parentheses, int number Of Bills,
comma, int total Minutes, comma, float hourly Rate, right
parentheses. 
Line 12: 2 forward slashes. Pre, colon, number of bills and total
minutes have been calculated. 
Line 13: 2 forward slashes. Post, colon, total billing and average
time and bill have been printed. 
Line 14: left brace. 
Line 15, indented once: float minutes equals static underscore cast,
left angled bracket, float, right angled bracket, left parentheses, total
Minutes, right parentheses, semicolon. 
Line 16, indented once: c out, 2 left angled brackets, double quotes,
Total amount billed this month is, blank space, double quotes. 
Line 17, indented twice: 2 left angled brackets, minutes forward
slash 60.0 asterisk hourly Rate, 2 left angled brackets, end l,
semicolon. 
Line 18, indented once: c out, 2 left angled brackets, double quotes,
Average time worked per job is, blank space, double quotes. 
Line 19, indented twice: 2 left angled brackets, minutes forward
slash float, left parentheses, number Of Bills, right parentheses,
forward slash, 60.0, 2 left angled brackets, end l, semicolon. 
Line 20, indented once: c out, 2 left angled brackets, double quotes,
Average customer bill is, blank space, double quotes. 
Line 21, indented twice: 2 left angled brackets, minutes forward
slash 60.0 asterisk hourly Rate forward slash float, left parentheses,
number Of Bills, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 22: right brace. 
Line 23: 2 forward slashes followed by asterisks till the end of the
line. 
Line 24: void Get And Print Address, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, right
parentheses. 
Line 25: 2 forward slashes. Pre, colon, files have been opened and

name has been read. 
Line 26: 2 forward slashes. Post, colon, address has been read from
in File and. 
Line 27: 2 forward slashes, tab space, written on out File. 
Line 28: left brace. 
Line 29, indented once: string line, semicolon. 
Line 30, indented once: get line, left parentheses, in File, comma,
line, right parentheses, semicolon. 2 forward slashes. Process street
line. 
Line 31, indented once: out File, 2 left angled brackets, line, 2 left
angled brackets, end l, 2 left angled brackets, end l, semicolon. 
Line 32: right brace. 
Line 33: 2 forward slashes followed by asterisks till the end of the
line. 
Line 34: void Process A Client, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma,
int ampersand total Time, comma, float hourly Rate, right
parentheses. 
Line 35: 2 forward slashes. Pre, colon, Files have been opened, total
time is total minutes. 
Line 36: 2 forward slashes. tab space, billed so far, and hourly Rate
has been set. 
Line 37: 2 forward slashes. Post, colon, Bill has been written on out
File. 
Line 38: left brace. 
Line 39, indented once: int time equals 0, semicolon. 
Line 40, indented once: int hours, semicolon. 
Line 41, indented once: int minutes, semicolon. 
Line 42, indented once: float cost, semicolon. 
Line 43, indented once: int number Of Jobs, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: for, int, end l, string. 
Line 1, indented once: Get And Print Address, left parentheses, in
File, comma, out File, right parentheses, semicolon. 
Line 2, indented once: in File, 2 right angled brackets, number Of
Jobs, semicolon. 

Line 3, indented once: out File, 2 left angled brackets, double
quotes, Number of jobs, colon, blank space, double quotes, 2 left
angled brackets, number Of Jobs, 2 left angled brackets, end l,
semicolon. 
Line 4, indented once: for, left parentheses, int count equals 1,
semicolon, count less than or equal to number Of Jobs, semicolon,
count plus plus, right parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: in File, 2 right angled brackets, hours, 2 right
angled brackets, minutes, semicolon. 
Line 7, indented twice: time equals hours asterisk 60 plus minutes
plus time, semicolon. 
Line 8, indented twice: out File, 2 left angled brackets, double
quotes, Job, blank space, double quotes, 2 left angled brackets,
count, 2 left angled brackets, double quotes, colon, blank space,
double quotes, 2 left angled brackets, hours, 2 left angled brackets,
double quotes, blank space, hours and, blank space, double quotes.
Line 9, indented thrice: 2 left angled brackets, minutes, 2 left angled
brackets, double quotes, blank space, minutes, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 10, indented once: right brace. 
Line 11, indented once: cost equals static underscore cast, left
angled bracket, float, right angled bracket, left parentheses, time,
right parentheses, forward slash, 60.0 asterisk hourly Rate,
semicolon. 
Line 12, indented once: total Time equals total Time plus time,
semicolon. 
Line 13, indented once: out File, 2 left angled brackets, double
quotes, Amount of bill, colon, blank space, dollar, double quotes, 2
left angled brackets, set precision, left parentheses, 2, right
parentheses, 2 left angled brackets, cost, 2 left angled brackets, end
l, 2 left angled brackets, end l, semicolon. 
Line 14, indented once: string skip, semicolon. 
Line 15, indented once: get line, left parentheses, in File, comma,
skip, right parentheses, semicolon. 
Line 16: right brace.
Back to Figure

Line 1: Davis, blank space, Allan, blank space, James. 
Line 2: 223, blank space, Red, blank space, Wing, blank space,
Terrace. 
Line 3: Altamont, blank space, W Y, blank space, 67606. 
Line 4: 5. 
Line 5: 1, blank space, 45. 
Line 6: 2, blank space, 0. 
Line 7: 0, blank space, 30. 
Line 8: 1, blank space, 30. 
Line 9: 2, blank space, 50. 
Line 10: Soucy, blank space, Steven, blank space, Carl. 
Line 11: 12, blank space, Wild blossom, blank space, Court.
Line 12: Englebrook, blank space, W Y, blank space, 67628.
Back to Figure
Line 1: 1. 
Line 2: 8, blank space, 45. 
Line 3: Castor, blank space, Julia, blank space, Maude. 
Line 4: 18472, blank space, East, blank space, Main, blank space,
Street. 
Line 5: Egremont, blank space, W Y, blank space, 67624. 
Line 6: 4. 
Line 7: 1, blank space, 30. 
Line 8: 1, blank space, 30. 
Line 9: 1, blank space, 30. 
Line 10: 1, blank space, 30. 
Line 11: Marengoni, blank space, Christina, blank space, Louise. 
Line 12: 25, blank space, Pomegranate Loop. 
Line 13: Egremont, blank space, W Y, blank space, 67624. 
Line 14: 0.
Back to Figure
Line 1: Billing for clients on file Lawn Care dot t x t. 
Line 2: Davis Allan James. 
Line 3: 223 Red Wing Terrace. 
Line 4: Altamont W Y 67606. 
Line 5: blank. 

Line 6: Number of jobs, colon, 5. 
Line 7: Job 1, colon, 1 hours and 45 minutes. 
Line 8: Job 2, colon, 2 hours and 0 minutes. 
Line 9: Job 3, colon, 0 hours and 30 minutes. 
Line 10: Job 4, colon, 1 hours and 30 minutes. 
Line 11: Job 5, colon, 2 hours and 50 minutes. 
Line 12: Amount of bill, colon, 300.42 dollars. 
Line 13: blank. 
Line 14: Soucy Steven Carl. 
Line 15: 12 Wild blossom Court. 
Line 16: Englebrook W Y 67628. 
Line 17: blank. 
Line 18: Number of jobs, colon, 1. 
Line 19: Job 1, colon, 8 hours and 45 minutes. 
Line 20: Amount of bill, colon, 306.25 dollars. 
Line 21: Castor Julia Maude. 
Line 22: 18472 East Main Street. 
Line 23: Egremont W Y 67624. 
Line 24: blank. 
Line 25: Number of jobs, colon, 4. 
Line 26: Job 1, colon, 1 hours and 30 minutes. 
Line 27: Job 2, colon, 1 hours and 30 minutes. 
Line 28: Job 3, colon, 1 hours and 30 minutes. 
Line 29: Job 4, colon, 1 hours and 30 minutes. 
Line 30: Amount of bill, colon, 210.00 dollars. 
Line 31: blank. 
Line 32: Marengoni Christina Louise. 
Line 33: 25 Pomegranate Loop. 
Line 24: Egremont W Y 67624. 
Line 25: blank. 
Line 26: Number of jobs, colon, 0. 
Line 27: Amount of bill, colon, 0.00 dollars."
Back to Figure
Program code. The words in the variable names and function names
are merged. The code uses the keyword void. 
Line 1: void Get Input File Name, left parentheses, string
ampersand, file Name, right parentheses, semicolon. 

Line 2: 2 forward slashes. Prompts the user to choose an input file. 
Line 3: void Get Output File Name, left parentheses, string
ampersand file Name, right parentheses, semicolon. 
Line 4: 2 forward slashes. Prompts the user to create a new output
file. 
Line 5: void Get Hourly Rate, left parentheses, float ampersand
hourly Rate, right parentheses, semicolon. 
Line 6: 2 forward slashes. Prompts the user for the hourly rate."
Back to Figure
Program code. The words in the variable name, function names, and
keywords are merged. The keywords used in the code are as
follows: int, main, float, i f stream, o f stream, if, c out, end l, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: float hourly Rate, semicolon. 
Line 4, indented once: i f stream in File, semicolon. 
Line 5, indented once: o f stream out File, semicolon. 
Line 6, indented once: Open Files, left parentheses, in File, comma,
out File, right parentheses, semicolon. 
Line 7, indented once: if, left parentheses, exclamation mark, in File,
2 vertical pipes, exclamation mark, out File, right parentheses. 
Line 8, indented once: left brace. 
Line 9, indented twice: c out, 2 left angled brackets, double quotes,
Error opening files, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 10, indented twice: return 1, semicolon. 
Line 11, indented once: right brace. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Enter hourly rate, period, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 13, indented once: c in, 2 right angled brackets, hourly Rate,
semicolon. 
Line 14, indented once: Process Clients, left parentheses, in File,
comma, out File, comma, hourly Rate, right parentheses, semicolon.
Line 15: blank. 
Line 16, indented once: in File dot close, left parentheses, right
parentheses, semicolon. 

Line 17, indented once: out File dot close, left parentheses, right
parentheses, semicolon. 
Line 18: blank. 
Line 19, indented once: return 0, semicolon. 
Line 20: right brace.
Back to Figure
Program code. The words in the function names, keywords, and
variable names are merged. The code uses the following keywords:
void, i f stream, o f stream, bool, string, if, return. 
Line 1: void Open Files, left parentheses, i f stream ampersand in
File, comma, o f stream ampersand out File, comma, bool
ampersand files O K, right parentheses. 
Line 2: left parentheses. 
Line 3, indented once: 2 forward slashes, Post, colon, Files have
been opened and files O K reflects the result. 
Line 4, indented once: 2 forward slashes, tab space, of the opening
process. 
Line 5, indented once: string in File Name, semicolon. 2 forward
slashes. User specified input file name. 
Line 6, indented once: string out File Name, semicolon. 2 forward
slashes. user specified output file name. 
Line 7, indented once: Get Input File Name, left parentheses, in File
Name, right parentheses, semicolon. 
Line 8, indented once: in File dot open, left parentheses, in File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 9, indented once: Get Output File Name, left parentheses, out
File Name, right parentheses, semicolon. 
Line 10, indented once: out File dot open, left parentheses, out File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 11, indented once: if, left parentheses, exclamation mark, in
File, 2 vertical pipes, exclamation mark, out File, right parentheses. 
Line 12, indented once: left brace. 
Line 13, indented twice: files O K equals false, semicolon. 
Line 14, indented twice: return, semicolon. 
Line 15, indented once: right brace. 

Line 16, indented once: files O K equals true, semicolon. 
Line 17, indented once: out File, 2 left angled brackets, double
quotes, Billing for clients on file, blank space, double quotes, 2 left
angled brackets, in File Name, 2 left angled brackets, end l,
semicolon. 
Line 18, indented once: out File, 2 left angled brackets, fixed,
semicolon. 
Line 19: right brace."
Back to Figure
Program code. The words in the function names and variable names
are merged. The code contains the following keywords: void, string. 
Line 1: void Get Input File Name, left parentheses, string ampersand
file Name, right parentheses. 
Line 2: left brace. 
Line 3, indented once: 2 forward slashes. Post, colon, file Name is
assigned the name of an input file. 
Line 4, indented once: 2 forward slashes, tab space, chosen by the
user. 
Line 5, indented once: File Dialog choose File, left parentheses,
double quotes, Choose an existing input file, period, double quotes,
right parentheses, semicolon. 
Line 6, indented once: file Name equals choose File dot display, left
parentheses, right parentheses, semicolon. 
Line 7: right brace."
Back to Figure
Program code. The words used in the variable name and function
name are merged. The code contains the following keywords: void,
string. 
Line 1: void Get Output File Name, left parentheses, string
ampersand file Name, right parentheses. 
Line 2: left brace. 
Line 3, indented once: 2 forward slashes, Post, colon, file Name is
assigned the name of an output file. 
Line 4, indented once: 2 forward slashes, tab space, created by the
user.

Back to Figure
2 buttons on the top left of the window are for selecting the folder
view options. The folder name is displayed at the top center. The
search bar is at the top right. The button at the bottom left is
labeled, New Folder. The buttons at the bottom right are labeled,
Cancel, and Open. The parameters labeled name, size, kind, and
Date added are listed in a tabular form at the center of the window.
The entries are as follows.
Row 1. Name: Lawn Care Billing Case Study G U I. Size: 207 K B.
Kind: Unix Executable File. Date Added: Today at 5 25 A M.
Row 2. Name: dialog dot o. Size: 1.9 M B. Kind: object code. Date
Added: Today at 5 25 A M.
Row 3. Name: main dot o. Size: 356 K B. Kind: object code. Date
Added: Today at 5 25 A M.
Row 4. Name: m o c underscore dialog dot o. Size: 613 K B. Kind:
object code. Date Added: Today at 5 25 A M.
Row 5. Name: m o c underscore dialog dot c p p. Size: 3 K B. Kind:
C plus plus source code. Date Added: Today at 5 25 A M.
Row 6. Name: m o c underscore pre defs dot h. Size: 14 K B. Kind:
C header code. Date Added: Today at 5 25 A M.
Row 7. Name: Make file. Size: 53 K B. Kind: Document. Date
Added: Today at 5 25 A M.
Row 8. Name: Lawn Care Billing Case Study G U I dot pro dot user.
Size: 23 K B. Kind: Document. Date Added: Today at 5 25 A M.
Row 9. Name: dialog dot c p p. Size: 11 K B. Kind: C plus plus
source code. Date Added: Today at 5 15 A M.
Row 10. Name: dialog dot h. Size: 3 K B. Kind: C header code. Date
Added: Today at 5 15 A M.
Row 11. Name: Lawn Care Billing Case Study G U I dot pro. Size:
412 bytes. Kind: Q t project file. Date Added: Today at 5 15 A M.
Row 12. Name: main dot c p p. Size: 6 K B. Kind: C plus plus source
code. Date Added: Today at 5 14 A M.
Row 13. Name: Lawn Care dot t x t. Size: 298 bytes. Kind: Plain
text. Date Added: Today at 5 14 A M.
Back to Figure

The text labels at the top center are, Save As, colon, and Tags,
colon and the contents of their corresponding text boxes are output
and blank, respectively. The buttons for selecting the folder view
options are at the top left. The folder name which is Lawn Care
Billing Case Study is at the top center. The search bar is at the top
right. The button at the bottom left is labeled New Folder. The
buttons at the bottom right are labeled Cancel, and Save,
respectively. The parameters labeled name, size, kind, and Date
added are listed in a tabular form at the center of the window. The
entries are as follows.
Row 1. Name: Lawn Care Billing Case Study G U I. Size: 207 K B.
Kind: Unix Executable File. Date Added: Today at 5 25 A M.
Row 2. Name: dialog dot o. Size: 1.9 M B. Kind: object code. Date
Added: Today at 5 25 A M.
Row 3. Name: main dot o. Size: 356 K B. Kind: object code. Date
Added: Today at 5 25 A M.
Row 4. Name: m o c underscore dialog dot o. Size: 613 K B. Kind:
object code. Date Added: Today at 5 25 A M.
Row 5. Name: m o c underscore dialog dot c p p. Size: 3 K B. Kind:
C plus plus source code. Date Added: Today at 5 25 A M.
Row 6. Name: m o c underscore pre defs dot h. Size: 14 K B. Kind:
C header code. Date Added: Today at 5 25 A M.
Row 7. Name: Make file. Size: 53 K B. Kind: Document. Date
Added: Today at 5 25 A M.
Row 8. Name: Lawn Care Billing Case Study G U I dot pro dot user.
Size: 23 K B. Kind: Document. Date Added: Today at 5 25 A M.
Row 9. Name: dialog dot c p p. Size: 11 K B. Kind: C plus plus
source code. Date Added: Today at 5 15 A M.
Row 10. Name: dialog dot h. Size: 3 K B. Kind: C header code. Date
Added: Today at 5 15 A M.
Back to Figure
Program code. The words used in the variable names and function
names are merged. 
Line 1, indented once: New File Dialog choose File, left parentheses,
double quotes, Create a new output file, period, double quotes, right
parentheses, semicolon. 
Line 2, indented once: file Name equals choose File dot display, left

parentheses, right parentheses, semicolon. 
Line 3: right brace."
Back to Figure
Program code. The words used in the function names and variable
names are merged. The code contains the following keywords: void,
float. 
Line 1: void Get Hourly Rate, left parentheses, float ampersand
hourly Rate, right parentheses. 
Line 2: left brace. 
Line 3, indented once: 2 forward slashes. Post, colon, hourly Rate is
assigned the hourly rate. 
Line 4, indented once: 2 forward slashes, tab space. provided by the
user. 
Line 5, indented once: Float Dialog hourly Rate Dialog, left
parentheses, double quotes, Provide the hourly rate, period, double
quotes, right parentheses, semicolon. 
Line 6, indented once: hourly Rate equals hourly Rate Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 7: right brace."
Back to Figure
Program code. The words used in the variable names, and function
names are merged. The code uses the following keywords: int,
main, float, i f stream, o f stream, bool, if, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: float hourly Rate, semicolon. 
Line 4, indented once: i f stream in File, semicolon. 
Line 5, indented once: o f stream out File, semicolon. 
Line 6, indented once: bool files O K, semicolon. 
Line 7, indented once: Open Files, left parentheses, in File, comma,
out File, comma, files O K, right parentheses, semicolon. 
Line 8, indented once: if, left parentheses, semicolon, files O K, right
parentheses. 
Line 9, indented once: left brace. 
Line 10, indented twice: Message Dialog error Dialog, left

parentheses, double quotes, Error opening files, double quotes,
close parentheses, semicolon. 
Line 11, indented twice: error Dialog dot display, left parentheses,
right parentheses, semicolon. 
Line 12, indented twice: return 1, semicolon. 
Line 13, indented once: right brace. 
Line 14, indented once: Get Hourly Rate, left parentheses, hourly
Rate, right parentheses, semicolon. 
Line 15, indented once: Process Clients, left parentheses, in File,
comma, out File, comma, hourly Rate, right parentheses, semicolon.
Line 16, indented once: in File dot close, left parentheses, right
parentheses, semicolon. 
Line 17, indented once: out File dot close, left parentheses, right
parentheses, semicolon. 
Line 18, indented once: return 0, semicolon. 
Line 19: right brace.
An exclamation mark within a yellow triangle is displayed on the left.
The text displayed is, Error opening files. The button at the bottom
right is labeled O K.
Back to Figure
Program code. The words in the function names and variable names
are merged. The code has the following keywords: void, int, float,
output, end l, o string stream. 
Line 1: void Print Results, left parentheses, int number Of Bills,
comma, int total Minutes, comma, float hourly Rate, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: 2 forward slashes. Pre, colon, number of bills
and total minutes have been calculated. 
Line 4, indented once: 2 forward slashes. Post, colon, total billing
and average time and bill have been printed. 
Line 5, indented once: o string stream output, semicolon. 
Line 6, indented once: float minutes equals static underscore cast,
left angled bracket, float, right angled bracket, left parentheses, total
Minutes, right parentheses, semicolon. 
Line 7, indented once: output, 2 left angled brackets, double quotes,

Total amount billed this month is, blank space, double quotes. 
Line 8, indented twice: 2 left angled brackets, minutes forward slash
60.0 asterisk hourly Rate. 
Line 9, indented twice: 2 left angled brackets, end l, semicolon. 
Line 10, indented once: output, 2 left angled brackets, double
quotes, Average time worked per job is, blank space, double quotes.
Line 11, indented twice: 2 left angled brackets, minutes forward
slash float, left parentheses, number Of Bills, right parentheses,
forward slash, 60.0, 2 left angled brackets, end l, semicolon. 
Line 12, indented once: output, 2 left angled brackets, double
quotes, Average customer bill is, blank space, double quotes. 
Line 13, indented twice: 2 left angled brackets, minutes forward
slash 60.0 asterisk hourly Rate forward slash float, left parentheses,
number Of Bills, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 14: Output Dialog results, left parentheses, output dot s t r, left
parentheses, right parentheses, right parentheses, semicolon. 
Line 15: results dot display, left parentheses, right parentheses,
semicolon. 
Line 16: right brace.
The buttons at the bottom right are labeled Cancel and O K. The
label within the window is marked Output, colon. The contents of a
text box below the label are as follows. Totl amount billed this month
is 303.333. Average time worked per job is 5.83333. Average
customer bill is 75.8333.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: include, f stream, i o man i p, i o
stream. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Program Lawn Care G U I calculates and
writes the bills for a lawn care service company. The names of the
input and output files are. 
Line 3: 2 forward slashes. prompted for and read from the keyboard.
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled brackets, f stream, right angled

brackets. 
Line 6: hash include, left angled brackets, i o man i p, right angled
brackets. 
Line 7: hash include, left angled brackets, i o stream, right angled
brackets."
Back to Figure
Program code. The words used in the keywords, variable names
and function names are merged. The code contains the following
keywords: include, s stream, string, using, name space, s t d, void,
float, bool, i f stream, o f stream, int, main, if, return. 
Line 1: hash include, left angled bracket, s stream, right angled
bracket. 2 forward slashes. Access o string stream. 
Line 2: hash include, left angled bracket, string, right angled bracket.
Line 3: hash include, double quotes, dialog dot h, double quotes. 2
forward slashes. Access G U I components. 
Line 4: using name space s t d, semicolon. 
Line 5: 2 forward slashes. Function prototypes. 
Line 6: void Get Input File Name, left parentheses, string ampersand
file Name, right parentheses, semicolon. 
Line 7: 2 forward slashes. Prompts the user to choose an input file. 
Line 8: void Get Output File Name, left parentheses, string
ampersand file Name, right parentheses, semicolon. 
Line 9: 2 forward slashes. Prompts the user to create a new output
file. 
Line 10: void Get Hourly Rate, left parentheses, float ampersand
hourly Rate, right parentheses, semicolon. 
Line 11: 2 forward slashes. Prompts the user for the hourly rate. 
Line 12: void Open Files, left parentheses, i f stream ampersand in
file, comma, o f stream ampersand out file, comma, bool ampersand
files O K, right parentheses, semicolon. 
Line 13: 2 forward slashes. Open Files reads in the names of the
input file and the. 
Line 14: 2 forward slashes. output file and opens them for
processing. If there is an. 
Line 15: 2 forward slashes. error, comma, files O K will be false. 
Line 16: void Process Clients, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out file, comma,

float hourly Rate, right parentheses. 
Line 17: 2 forward slashes. Process Clients writes bills for all of the
clients. 
Line 18: 2 forward slashes. whose records are on in File. 
Line 19: void Process A Client, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma,
int ampersand total Time, comma, float hourly Rate, right
parentheses, semicolon. 
Line 20: 2 forward slashes. Process A Client writes the bill for one
client. 
Line 21: void Get And Print Address, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, right
parentheses, semicolon. 
Line 22: 2 forward slashes. Get And Print Address reads the
address from in File and. 
Line 23: 2 forward slashes. prints it on out File. 
Line 24: void Print Results, left parentheses, int number Of Bills,
comma, int total Minutes, comma, float hourly Rate, right
parentheses, semicolon. 
Line 25: 2 forward slashes. Print Results prints total billed, comma,
average time per job, comma. 
Line 26: 2 forward slashes. and average bill. 
Line 27: int main, left parentheses, right parentheses. 
Line 28: left brace. 
Line 29, indented once: float hourly Rate, semicolon. 
Line 30, indented once: i f stream in File, semicolon. 
Line 31, indented once: o f stream out File, semicolon. 
Line 32, indented once: bool files O K, semicolon. 
Line 33, indented once: Open Files, left parentheses, in File,
comma, out File, comma, files O K, right parentheses, semicolon. 
Line 34, indented once: if, left parentheses, exclamation mark, files
O K, right parentheses. 
Line 35, indented once: left brace. 
Line 36, indented twice: Message Dialog error Dialog, left
parentheses, double quotes, Error opening files, double quotes, right
parentheses, semicolon. 
Line 37, indented twice: error Dialog dot display, left parentheses,
right parentheses, semicolon. 

Line 38, indented twice: return 1, semicolon. 
Line 39, indented once: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code uses the following keywords: return, void,
string. 
Line 1: Get Hourly Rate, left parentheses, hourly Rate, right
parentheses, semicolon. 
Line 2: Process Clients, left parentheses, in File, comma, out File,
comma, hourly Rate, right parentheses, semicolon. 
Line 3: in File dot close, left parentheses, right parentheses,
semicolon. 
Line 4: out File dot close, left parentheses, right parentheses,
semicolon. 
Line 5: return 0, semicolon. 
Line 6: right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: void Get Input File Name, left parentheses, string ampersand
file Name, right parentheses. 
Line 9: left brace. 
Line 10, indented once: 2 forward slashes. Post, colon, file Name is
assigned the name of an input file. 
Line 11, indented once: 2 forward slashes, tab space, chosen by the
user. 
Line 12, indented once: File Dialog choose File, left parentheses,
double quotes, Choose an existing input file, period, double quotes,
right parentheses, semicolon. 
Line 13, indented once: file Name equals choose File dot display, left
parentheses, right parentheses, semicolon. 
Line 14: right brace. 
Line 15: 2 forward slashes followed by asterisks till the end of the
line. 
Line 16: void Get Output File Name, left parentheses, string
ampersand file Name, right parentheses. 
Line 17: left brace. 
Line 18, indented once: 2 forward slashes. Post, colon, file Name is
assigned the name of an output file. 

Line 19, indented once: 2 forward slashes, tab space, created by the
user. 
Line 20, indented once: New File Dialog choose File, left
parentheses, double quotes, Create a new output file, period, double
quotes, right parentheses, semicolon. 
Line 21, indented once: file Name equals choose File dot display, left
parentheses, right parentheses, semicolon. 
Line 22: right brace. 
Line 23: 2 forward slashes followed by asterisks till the end of the
line. 
Line 24: void Get Hourly Rate, left parentheses, float ampersand
hourly Rate, right parentheses. 
Line 25: left brace. 
Line 26, indented once: 2 forward slashes. Post, colon, hourly Rate
is assigned the hourly rate. 
Line 27, indented once: 2 forward slashes. Tab space. provided by
the user. 
Line 28, indented once: Float Dialog hourly Rate Dialog, left
parentheses, double quotes, Provide the hourly rate, period, double
quotes, right parentheses, semicolon. 
Line 29, indented once: hourly Rate equals hourly Rate Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 30: right brace. 
Line 31: 2 forward slashes followed by asterisks till the end of the
line. 
Line 32: void Open Files, left parentheses, i f stream ampersand in
File, comma, o f stream ampersand out File, comma, bool
ampersand files O K, right parentheses. 
Line 33: left brace. 
Line 34, indented once: 2 forward slashes. Post, colon, Files have
been opened and files O K reflects the result. 
Line 35, indented once: 2 forward slashes. Tab space. of the
opening process. 
Line 36, indented once: string in File Name, semicolon. 2 forward
slashes. User specified input file name. 
Line 37, indented once: string out File Name, semicolon. 2 forward
slashes. User specified output file name. 
Line 38, indented once: Get Input File Name, left parentheses, in
File Name, right parentheses, semicolon. 

Line 39, indented once: in File dot open, left parentheses, in File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 40, indented once: Get Output File Name, left parentheses, out
File Name, right parentheses, semicolon. 
Line 41, indented once: out File dot open, left parentheses, out File
Name dot c underscore s t r, left parentheses, right parentheses,
right parentheses, semicolon.
Back to Figure
Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords: if, end l, void, float, i f stream, o f stream, int, string,
while, output. 
Line 1, indented once: if, left parentheses, exclamation mark in File,
2 vertical pipes, exclamation mark out File, right parentheses. 
Line 2: left brace. 
Line 3, indented twice: files O K equals false, semicolon. 
Line 4, indented twice: return, semicolon. 
Line 5, indented once: right brace. 
Line 6, indented once: files O K equals true, semicolon. 
Line 7, indented once: out File, 2 left angled brackets, double
quotes, Billing for clients on file, blank space, double quotes, 2 left
angled brackets, in File Name, 2 left angled brackets, end l,
semicolon. 
Line 8, indented once: out File, 2 left angled brackets, fixed,
semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: void Process Clients, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma,
float hourly Rate, right parentheses. 
Line 12: left brace. 
Line 13, indented once: 2 forward slashes. Pre, colon, Files have
been opened and the hourly rate has been set. 
Line 14, indented once: Post, colon, Each bill has been written and
the summary values have. 

Line 15, indented once: 2 forward slashes. Tab space. been written
to the screen. 
Line 16, indented once: int total Time equals 0, semicolon. 
Line 17, indented once: int number Of Bills equals 0, semicolon. 
Line 18, indented once: sting name, semicolon. 
Line 19, indented once: get line, left parentheses, in File, comma,
name, right parentheses, semicolon. 
Line 20, indented once: while, left parentheses, in File, right
parentheses, left brace. 
Line 21, indented twice: out File, 2 left angled brackets, name, 2 left
angled brackets, end l, semicolon. 
Line 22, indented twice: Process A Client, left parentheses, in File,
comma, out File, comma, total Time, comma, hourly Rate, right
parentheses, semicolon. 
Line 23, indented twice: number Of Bills, plus, plus, semicolon. 
Line 34, indented twice: get line, left parentheses, in File, comma,
name, right parentheses, semicolon. 
Line 35, indented once: right brace. 
Line 36, indented once: 2 forward slashes. Print summary
information. 
Line 37, indented once: Print Results, left parentheses, number Of
Bills, comma, total Time, comma, hourly Rate, right parentheses,
semicolon. 
Line 38: right brace. 
Line 39: 2 forward slashes followed by asterisks till the end of the
line. 
Line 40: void Print Results, left parentheses, int number Of Bills,
comma, int total Minutes, comma, float hourly Rate, right
parentheses. 
Line 41: left brace. 
Line 42, indented once: 2 forward slashes. Pre, colon, Number of
bills and total minutes have been calculated. 
Line 43, indented once: 2 forward slashes. Post, colon, Total billing
and average time and bill have been printed. 
Line 44, indented once: o string stream output, semicolon. 
Line 45, indented once: float minutes equals static underscore cast,
left angled brackets, float, right angled brackets, left parentheses,
total Minutes, right parentheses, semicolon. 
Line 46, indented once: output, 2 left angled brackets, double

quotes, Total amount billed this month is, double quotes. 
Line 46, indented twice: 2 left angled brackets, minutes forward
slash 60.0 asterisk hourly Rate.
Line 47, indented twice: 2 left angled brackets, end l, semicolon. 
Line 48, indented twice: output, 2 left angled brackets, double
quotes, Average time worked per job is, blank space, double quotes.
Line 49, indented twice: 2 left angled brackets, minutes forward
slash float, left parentheses, number Of Bills, right parentheses,
forward slash 60.0, 2 left angled brackets, end l, semicolon 
Line 50, indented once: output, 2 left angled brackets, double
quotes, Average customer bill is, blank space, double quotes. 
Line 51, indented twice: 2 left angled brackets, minutes forward
slash 60.0 asterisk hourly Rate forward slash float, left parentheses,
number Of Bills, right parentheses, 2 left angled brackets, end l,
semicolon.
Back to Figure
Program code. The words used in the variable names, function
names, and keywords are merged. The code contains the following
keywords: void, i f stream, o f stream, string, end l, int, float.
Line 1, indented once: Output Dialog results, left parentheses,
output dot s t r, left parentheses, right parentheses, right
parentheses, semicolon. 
Line 2, indented once: results dot display, left parentheses, right
parentheses, semicolon. 
Line 3: right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: void Get And Print Address, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, right
parentheses. 
Line 6: left brace. 
Line 7, indented once: 2 forward slashes. Pre, colon, Files have
been opened and name has been read. 
Line 8, indented once: 2 forward slashes. Post, colon, Address has
been read from in File and. 
Line 9, indented once: 2 forward slashes. Tab space. written on out
File. 
Line 10, indented once: string line, semicolon. 

Line 11, indented once: get line, left parentheses, in File, comma,
line, right parentheses, semicolon. 
Line 12, indented once: out File, 2 left angled brackets, line, 2 left
angled brackets, end l, semicolon. 
Line 13, indented once: get line, left parentheses, in File, comma,
line, right parentheses, semicolon. 
Line 14, indented once: out File, 2 left angled brackets, line, 2 left
angled brackets, end l, 2 left angled brackets, end l, semicolon. 
Line 15: right brace. 
Line 16: 2 forward slashes followed by asterisks till the end of the
line. 
Line 17: void Process A Client, left parentheses, i f stream
ampersand in File, comma, o f stream ampersand out File, comma,
int ampersand total Time, comma, float hourly Rate, right
parentheses. 
Line 18: left brace. 
Line 19, indented once: 2 forward slashes. Pre, colon, Files have
been opened, comma, total Time is total minutes. 
Line 20, indented once: 2 forward slashes. Tab space. billed so far,
comma, and hourly Rate has been set. 
Line 21, indented once: 2 forward slashes. Post, colon, Bill has been
written to out File. 
Line 22, indented once: int time equals 0, semicolon. 
Line 23, indented once: int hours, semicolon. 
Line 24, indented once: int minutes, semicolon. 
Line 25, indented once: float cost, semicolon. 
Line 26, indented once: int number Of Jobs, semicolon. 
Line 27, indented once: 2 forward slashes. Process. 
Line 28, indented once: Get And Print Address, left parentheses, in
File, comma, out File, close parentheses, semicolon. 
Line 29, indented once: in File, 2 right angled brackets, number Of
Jobs, semicolon. 
Line 30, indented once: out File, 2 left angled brackets, double
quotes, Number of Jobs, colon, blank space, double quotes, 2 left
angled brackets, number Of Jobs, 2 left angled brackets, end l,
semicolon. 
Line 31, indented once: for, left parentheses, int count equals 1,
semicolon, count less than or equal to number Of Jobs, semicolon,
count plus plus, right parentheses. 

Line 32, indented once: left brace. 
Line 33, indented twice: in File, 2 right angled brackets, hours, 2
right angled brackets, minutes, semicolon. 
Line 34, indented twice: time equals hours asterisk 60 plus minutes
plus time, semicolon. 
Line 35, indented twice: out File, 2 left angled brackets, double
quotes, Job, blank space, double quotes, 2 left angled brackets,
count, 2 left angled brackets, double quotes, colon, blank space,
double quotes, 2 left angled brackets, hours. 
Line 36, indented thrice: 2 left angled brackets, double quotes, blank
space, hours and, blank space, double quotes, 2 left angled
brackets, minutes. 
Line 37, indented thrice: 2 left angled brackets, double quotes, blank
space, minutes, blank space, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 38, indented once: right brace. 
Line 40, indented once: cost equals static underscore cast, left
angled bracket, float, right angled bracket, left parentheses, time,
right parentheses, forward slash, 60.0 asterisk hourly Rate,
semicolon. 
Line 41, indented once: total Time equals total Time plus time,
semicolon. 
Line 42, indented once: out File, 2 left angled brackets, double
quotes, Amount of bill, colon, blank space, dollar, double quotes, 2
left angled brackets, set precision, left parentheses, 2, right
parentheses. 
Line 43, indented twice: 2 left angled brackets, cost, 2 left angled
brackets, end l, 2 left angled brackets, end l, semicolon. 
Line 44, indented once: string skip, semicolon. 
Line 45, indented once: get line, left parentheses, in File, comma,
skip, right parentheses, semicolon. 
Line 46: right brace.
The words used in the variable names and keywords are merged.
The code contains the following keywords: include, c assert. 
Line 1: hash include, left angled bracket, c assert, right angled
bracket. 
Line 2: dot, dot, dot. 
Line 3: assert, left parentheses, student Count greater than 0, right

parentheses, semicolon. 
Line 4: average equals sum Of Scores, forward slash, student
Count, semicolon.
Program code. The words in the keywords are merged. The
program contains the following keywords: void, c out, end l. 
Line 1: void Print Name, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
Tim, double quotes, 2 left angled brackets, end l, semicolon. 
Line 4: right brace.
Program code. The code contains the following keywords: void, int,
return. 
Line 1: void Square, left parentheses, int ampersand x, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: x equals x asterisk x, semicolon. 
Line 4, indented once: return 0, semicolon. 
Line 5: right brace.
Back to Figure
Program code. The code contains the following keywords: void, int,
while. 
Line 1: void Power, left parentheses, int x, comma, int y, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: int result, semicolon. 
Line 4, indented once: result equals 1, semicolon. 
Line 5, indented once: while, left parentheses, y greater than 0, right
parentheses. 
Line 6, indented once: left brace. 
Line 7, indented twice: result equals result asterisk x, semicolon. 
Line 8, indented twice: y minus minus, semicolon. 
Line 9, indented once: right brace. 
Line 10: right brace.
Back to Figure

Program code. The code contains the following keywords: void, int,
while. 
Line 1: void Power, left parentheses, int x, comma, int y, comma, int
result, right parentheses. 
Line 2: left brace. 
Line 3, indented once: result equals 1, semicolon. 
Line 4, indented once: while, left parentheses, y greater than 0, right
parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: result equals result asterisk x, semicolon. 
Line 7, indented twice: y minus minus, semicolon. 
Line 8, indented once: right brace. 
Line 9: right brace.
Back to Figure
Program code. The keyword used in the program is while. 
Line 1: left brace. 
Line 2, indented once: result equals 1, semicolon. 
Line 3, indented once: while, left parentheses, y greater than 0, right
parentheses. 
Line 4, indented once: left brace. 
Line 5, indented twice: result equals result asterisk x, semicolon. 
Line 6, indented twice: y minus minus, semicolon. 
Line 7, indented once: right brace. 
Line 8: right brace.
Back to Figure
The statements are as follows. 
Line 1: days equals 12, semicolon. 
Line 2: hours equals 22, semicolon. 
Line 3: minutes equals 14, semicolon. The function call is as follows.
Time Add, left parentheses, days, comma, hours, comma, minutes,
comma, 3, comma, 17, comma, 49, right parentheses.
The entries are as follows. 
Line 1: Weems, blank space, 50, blank space, 60. 
Line 2: Dale, blank space, 51, blank space, 60. 

Line 3: Richards, blank space, 57, blank space, 60. 
Line 4: Smith, blank space, 36, blank space, 60. 
Line 5: Tomlin, blank space, 44, blank space, 60. 
Line 6: Bird, blank space, 45, blank space, 60. 
Line 7: dot, dot, dot.
Back to Figure
Line 1: Weems, blank space, 83 percent, blank space, point 8 3 3 3
3, blank space, Well, blank space, Done. 
Line 2: Dale, blank space, 85 percent, blank space, point 8 5 0 0 0,
blank space, Well, blank space, Done. 
Line 3: Richards, blank space, 95 percent, blank space, point 9 5 0 0
0, blank space, Excellent. 
Line 4: Smith, blank space, 60 percent, blank space, point 6 0 0 0 0,
blank space, Need, blank space, Improvement. 
Line 5: Tomlin, blank space, 73 percent, blank space, point 7 3 3 3
3, blank space, Good. 
Line 6: Bird, blank space, 75 percent, blank space, point 7 5 0 0 0,
blank space, Good. 
Line 7: dot, dot, dot.
Back to Figure
The maze consists of a square grid with 16 columns and 12 rows.
The square at row 1 and column 1 is marked S. The square at row
12 and column 1 is marked E. The maze consists of shaded and
unshaded squares. The positions of the groups of shaded squares
are as follows. The first shaded group includes the following
squares. Row 2, column 1. Row 2, column 2. Row 2, column 3. Row
2, column 4. The second shaded group includes the following
squares. Row 4, column 2. Row 4, column 3. Row 4, column 4. Row
4, column 5. Row 1, column 6. Row 2, column 6. Row 3, column 6.
Row 4, column 6. The third shaded group consists of the following
squares. Row 6, column 1. Row 6, column 2. Row 6, column 3. Row
6, column 4. Row 6, column 5, Row 6, column 6. Row 6, column 7.
Row 6, column 8. Row 5, column 8. Row 4, column 8. Row 3,
Column 8. Row 2, Column 8. The fourth shaded group consists of
the following squares. Row 1, column 10. Row 2, column 10. Row 3,

column 10. The fifth shaded group consists of the following squares.
Row 2, column 12. Row 2, column 13. Row 2, column 14. Row 2,
column 15. Row 3, column 12. Row 3, column 14. Row 3, column
15. Row 4, column 12. Row 4, column 14. Row 4, column 15. Row
5, column 10. Row 5, column 11. Row 5, column 12. Row 5, column
14. Row 5, column 15. Row 6, column 10. Row 7, column 10. Row
7, column 11. Row 7, column 12. Row 7, column 13. Row 7, column
14. Row 7, column 15. Row 8, column 12. Row 9, column 12. Row
9, column 13. Row 9, column 14. Row 9, column 15. Row 9, column
16. The sixth shaded group consists of the following squares. Row
8, column 2. Row 8, column 3. Row 8, column 4. Row 8, column 5.
Row 8, column 6. Row 8, column 7. Row 8, column 8. Row 9,
column 8. Row 9, column 9. Row 9, column 10. Row 10, column 1.
Row 10, column 2. Row 10, column 3. Row 10, column 4. Row 10,
column 5. Row 10, column 6. Row 10, column 7. Row 10, column 8.
Row 11, column 8. Row 11, column 9. Row 11, column 10. Row 11,
column 11. Row 11, column 12. Row 11, column 13. Row 11, column
14. Row 11, column 15. The seventh shaded group consists of the
following squares. Row 12, column 2. Row 12, column 3. Row 12,
column 4. Row 12, column 5. Row 12, column 6.
Back to Figure
Rule 1. Move Right, left parentheses, spaces, right parentheses,
colon, p o s Y equals p o s Y plus spaces. 
Rule 2. Move Left, left parentheses, spaces, right parentheses,
colon, p o s Y equals p o s Y minus spaces. 
Rule 3. Move Down, left parentheses, spaces, right parentheses,
colon, p o s X plus spaces. 
Rule 4. Move Up, left parentheses, spaces, right parentheses,
colon, p o s X equals p o s X minus spaces.
Back to Figure
Line 1: Enter number of rooms, colon, 2. 2 is shaded. 
Line 2: Enter size of tile in inches, colon, 12. 12 is shaded. 
Line 3: Enter room width, left parentheses, feet and inches, comma,
separated by a space, right parentheses, colon, 17, blank space, 4.
17 and 4 are shaded. 

Line 4: Enter room length, left parentheses, feet and inches,
comma, separated by a space, right parentheses, colon, 9, bank
space, 3. 9 and 3 are shaded. 
Line 5: Room requires 180 tiles. 
Line 6: Enter room width, left parentheses, feet and inches, comma,
separated by a space, right parentheses, colon, 11, blank space, 6.
11 and 6 are shaded. 
Line 7: Enter room length, left parentheses, feet and inches,
comma, separated by a space, right parentheses, colon, 11, blank
space, 9. 11 and 9 are shaded. 
Line 8: Room requires 144 tiles. 
Line 9: Total tiles required is 324. 
Line 10: Number of boxes needed is 17. 
Line 11: There will be 16 extra tiles.
Back to Figure
Line 1: Enter throw for frame 1, colon, 10. 10 is shaded. 
Line 2: Strike, exclamation mark. 
Line 3: Enter throw for frame 2, colon, 7. 7 is shaded. 
Line 4: Enter throw for frame 2, colon, 3. 3 is shaded. 
Line 5: Spare, exclamation mark. 
Line 6: Score for frame 1 is 20. Total is 20. 
Line 7: Enter throw for frame 3, colon, 5. 5 is shaded. 
Line 8: Score for frame 2 is 15. Total is 35.
Back to Figure
Line 1: Enter throw for frame 3, colon, 2. 2 is shaded. 
Line 2: Score for frame 3 is 7. Total is 42. 
Line 3: Enter score for frame 4, colon, 12. 12 is shaded. 
Line 4: Input error. Please enter number of pins in range of 0 to 10. 
Line 5: Enter score for frame 4, colon.
Back to Figure
Line 1: Enter string, colon, program. 
Line 2: Phonetic version is, colon, Papa, blank space, Romeo, blank

space, Oscar, blank space, Golf, blank space, Romeo, blank space,
Alpha, blank space, Mike.
Back to Figure
Line 1: a b c d e f a b c d e f a b c d e f a b. 
Line 2: 1 2 3 4 5 6 7, blank space, a b c d e f a b c d e f a b c d e f a
b. 
Line 3: 9 8 7 6 5 4 3, blank space, a b d d e f b b b d e f c b c d e f a
c. 
Line 4: 5 5 5 4 4 4 6, blank space, a b c d e f a b c d e f a b c d e f. 
Line 5: 4 4 4 5 5 5 6, blank space, a b c d e f a b c d e f a b c d e f a
b c d. 
Line 6: 3 3 3 2 2 2 1, blank space, a b c d e f g h i j k l m n o p q r s
t.
Back to Figure
Line 1: 1 2 3 4 5 6 7, blank space, 20. 
Line 2: 9 8 7 6 5 4 3, blank space, 15. 
Line 3: 5 5 5 4 4 4 6, blank space. Too few answers. 
Line 4: 4 4 4 5 5 5 6, blank space, Too many answers. 
Line 5: 3 3 3 2 2 2 1, blank space, Invalid answers.
Program code. The words in the keyword are merged. The code
contains the following keywords: if, int, and c in. 
Line 1: if, left parentheses, alpha, greater than, 3, right parentheses.
Line 2: left brace. 
Line 3, indented once: int number, semicolon. 2 forward slashes.
number is defined here. 
Line 4, indented once: c in, 2 right angled brackets, number,
semicolon. 
Line 5, indented once: beta equals beta plus number, semicolon. 
Line 6: right brace. 2 forward slashes. number becomes undefined
here.
Back to Figure

Program code. The words in the function name are merged. The
code contains the following keywords: int, main, and void. 
Line 1: int gamma, semicolon. 2 forward slashes. global variable. 
Line 2: int main, left parentheses, right parentheses. 
Line 3: left brace. 
Line 4, indented once: gamma equals 3, semicolon. 
Line 5: dot. 
Line 6: dot. 
Line 7: dot. 
Line 8: right brace. 
Line 9: void Some F u n c, left parentheses, right parentheses. 
Line 10: left brace. 
Line 11, indented once: gamma equals 5, semicolon. 
Line 12: dot. 
Line 13: dot. 
Line 14: dot. 
Line 15: right brace.
Back to Figure
Program code. The words in the function name and keyword are
merged. The code contains the following keywords: include, i o
stream, using, name space, s t d, void, const, and int. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates global and
local variables. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: Hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: using name space s t d, semicolon. 
Line 6: void Some F u n c, left parentheses, float, right parentheses,
semicolon. 
Line 7: const int uppercase a equals 17, semicolon. 2 forward
slashes. A global constant. 
Line 8: int b, semicolon. 2 forward slashes. A global variable. 
Line 9: int c, semicolon. 2 forward slashes. Another global.
Back to Figure

Program code. The words in the keywords and function names are
merged. The code contains the following keywords: int, main, return,
void, float, c out. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: b equals 4, semicolon. 2 forward slashes.
Assignment to global b. 
Line 4, indented once: c equals 6, semicolon. 2 forward slashes.
Assignment to global c. 
Line 5, indented once: Some F u n c, left parentheses, 42.8, right
parentheses, semicolon. 
Line 6, indented once: return 0, semicolon. 
Line 7: right brace. 
Line 8: 2 forward slashes followed by asterisks till the end of the line.
Line 9: void Some F u n c, left parentheses, float, c, right
parentheses. 2 forward slashes. Prevents access to global c. 
Line 10: left brace. 
Line 11, indented once: float b, semicolon. 2 forward slashes.
Prevents access to global b. 
Line 12, indented once: b equals 2.3, semicolon. 2 forward slashes.
Assignment to local b. 
Line 13, indented once: c out, 2 left angled brackets, double quotes,
blank space, uppercase a, equals, bank space, double quotes, 2 left
angled brackets, uppercase a, semicolon. 2 forward slashes. Output
global uppercase a, left parentheses 17, right parentheses. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
blank space, lowercase b, equals, blank space, double quotes, 2 left
angled brackets, lowercase b, semicolon. 2 forward slashes. Output
local lowercase b, left parentheses, 2.3, right parentheses. 
Line 15, indented once: c out, 2 left angled brackets, double quotes,
blank space, lowercase c, equals, blank space, double quotes, 2 left
angled brackets, lowercase c, semicolon. 2 forward slashes. Output
local c, left parentheses, 42.8, right parentheses. 
Line 16: right brace.
Back to Figure
Program code. The words in the keywords, function names, and
variable names are merged. The code contains the following

keywords: include, i o stream, using, name space, s t d, void, int,
char, main, while.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program shell demonstrates scope. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: Hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: using name space s t d, semicolon. 
Line 6: void Block 1, left parentheses, int, comma, char ampersand,
right parentheses, semicolon. 
Line 7: void Block 2, left parentheses, right parentheses, semicolon. 
Line 8: int a 1, semicolon. 2 forward slashes. One global variable. 
Line 9: char a 2, semicolon. 2 forward slashes. Another global
variable. 
Line 10: int main, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12: dot, dot, dot. 
Line 13: right brace. 
Line 14: 2 forward slashes followed by asterisks till the end of the
line. 
Line 15: void Block 1, left parentheses, int a 1, comma. 2 forward
slashes. Prevents access to global a 1. 
Line 16: char ampersand b 2, right parentheses. 2 forward slashes
Has same scope as c 1 and d 2. 
Line 17: left brace. 
Line 18, indented once: int c 1, semicolon. 2 forward slashes. A
variable local to Block 1. 
Line 19, indented once: int d 2, semicolon. 2 forward slashes.
Another variable local to Block 1. 
Line 20: dot, dot, dot. 
Line 21: right brace. 
Line 22: 2 forward slashes followed by asterisks till the end of the
line. 
Line 23: void Block 2, left parentheses, right parentheses. 
Line 24: left brace. 
Line 25, indented once: int a 1, semicolon. 2 forward slashes. Local
to block 2, semicolon, prevents access to global a 1. 
Line 26, indented once: int b 2, semicolon. 2 forward slashes. Local
to block 2, semicolon, no conflict with b 2 in Block 1. 

Line 27, indented once: while, left parentheses, dot, dot, dot, right
parentheses. 
Line 28, indented once: left brace. 2 forward slashes. Block 3. 
Line 29, indented twice: int c 1, semicolon. 2 forward slashes. Local
to Block 3, semicolon, no conflict with c 1 in Block 1. 
Line 30, indented twice: int b 2, semicolon. 2 forward slashes. Local
to block 3, semicolon, Prevents nonlocal access to b 2 in. 
Line 31: 2 forward slashes. block 2, semicolon, no conflict with b 2 in
block 1. 
Line 32: dot, dot, dot. 
Line 33, indented once: right brace. 
Line 34: right brace.
Back to Figure
The code fragment within a large purple box is as follows. 
Line 1: int a 1, semicolon. 
Line 2: char a 2, semicolon. 
Line 3: int main, left parentheses, right parentheses. 
Line 4: left brace. 
Line 5: right brace.
Back to Figure
Program code. The code contains the following keywords: name
space, s t d, int. 
Line 1: 2 forward slashes. In header file c s t d lib, colon. 
Line 2: name space s t d. 
Line 3: left brace. 
Line 4: dot, dot, dot. 
Line 5, indented once: int a b s, left parentheses, int, right
parentheses, semicolon. 
Line 6, indented once: dot, dot, dot. 
Line 7: right brace.
Back to Figure
Program code. The code contains the following keywords: include, c
s t d lib, int, main, s t d, c out. 

Line 1: hash include, left angled brackets, c s t d lib, right angled
brackets. 
Line 2: int main, left parentheses, right parentheses. 
Line 3: left brace. 
Line 4, indented once: int alpha, semicolon. 
Line 5, indented once: int beta, semicolon. 
Line 6: dot, dot, dot. 
Line 7, indented once: alpha equals s t d colon, colon, a b s, left
parentheses, beta, right parentheses, semicolon. 2 forward slashes.
A qualified name referring to a b s. 
Line 8, indented once: s t d, colon, colon, c out, 2 left angled
brackets, alpha, semicolon. 2 forward slashes. A qualified name
referring to c out. 
Line 9: dot, dot, dot. 
Line 10: right brace.
Back to Figure
Program code. The words in the keywords and function names are
merged. The code contains the following keywords: include, c s t d
lib, int, main, using, s t d, c out. 
Line 1: hash include, left angled bracket, c s t d lib, right angled
bracket. 
Line 2: int main, left parentheses, right parentheses. 
Line 3: left brace. 
Line 4, indented once: int alpha, semicolon. 
Line 5, indented once: int beta, semicolon. 
Line 6, indented once: using s t d, colon, colon, a b s, semicolon. 2
forward slashes. A using declaration for a b s. 
Line 7, indented once: using s t d, colon, colon, c out, semicolon. 2
forward slashes. A using declaration for c out. 
Line 8: dot, dot, dot. 
Line 9, indented once: alpha equals a b s, left parentheses, beta,
right parentheses, semicolon. 
Line 10, indented once: c out, 2 left angled brackets, alpha,
semicolon. 
Line 11: dot, dot, dot. 
Line 12: right brace.

Back to Figure
Program code. The words in the keywords and function names are
merged. The code contains the following keywords: include, c s t d
lib, int, main, using, name space, s t d, c out. 
Line 1: hash include, left angled bracket, c s t d lib, right angled
bracket. 
Line 2: int main, left parentheses, right parentheses. 
Line 3: left brace. 
Line 4, indented once: int alpha, semicolon. 
Line 5, indented once: int beta, semicolon. 
Line 6, indented once: using name space s t d, semicolon. 2 forward
slashes. A using directive. 
Line 7: dot, dot, dot. 
Line 8, indented once: alpha equals a b s, left parentheses, beta,
right parentheses, semicolon. 
Line 9, indented once: c out, 2 left angled brackets, alpha,
semicolon. 
Line 10: dot, dot, dot. 
Line 11: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
uses the following keywords: include, c s t d lib, using, name space,
s t d, int, main. 
Line 1: hash include, left angled bracket, c s t d lib, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: int main, left parentheses, right parentheses. 
Line 4: left brace. 
Line 5: dot, dot, dot. 
Line 6: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: include, i o stream, using, name
space, s t d, void, int, main, for, returning, static, c out, end l. 

Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: void counting, left parentheses, right parentheses,
semicolon. 
Line 4: 2 forward slashes. Function Counting outputs the value of a
counter. 
Line 5: 2 forward slashes. each time it is called. 
Line 6: int main, left parentheses, right parentheses. 
Line 7: left brace. 
Line 8, indented once: for, left parentheses, int count equals 1,
semicolon, count less than or equal to 10, semicolon, count plus
plus, right parentheses. 
Line 9, indented twice: counting, left parentheses, right parentheses,
semicolon. 
Line 10, indented once: return 0, semicolon. 
Line 11: right brace. 
Line 12: 2 forward slashes followed by asterisks till the end of the
line. 
Line 13: void counting, left parentheses, right parentheses. 
Line 14: left brace. 
Line 15, indented once: static int counter equals 0, semicolon. 2
forward slashes. counter is defined once, and its. 
Line 16: 2 forward slashes. value is not reinitialized to 0 on. 
Line 17: 2 forward slashes. subsequent calls to counting, left
parentheses, right parentheses. 
Line 18, indented once: counter plus plus, semicolon. 
Line 19, indented once: c out, 2 left angled brackets, double quotes,
count, colon, blank space, double quotes, 2 left angled brackets,
counter, 2 left angled brackets, end l, semicolon. 
Line 20: right brace. 2 forward slashes. counter is not deallocated
here.
Back to Figure
Line 1: count, colon, blank space, 1. 
Line 1: count, colon, blank space, 2.
Line 1: count, colon, blank space, 3.
Line 1: count, colon, blank space, 4.

Line 1: count, colon, blank space, 5.
Line 1: count, colon, blank space, 6.
Line 1: count, colon, blank space, 7.
Line 1: count, colon, blank space, 8.
Line 1: count, colon, blank space, 9.
Line 1: count, colon, blank space, 10."
Back to Figure
Program code. The words in the variable name and function name
are merged. The code contains the following keywords: void, int. 
Line 1: void Some F u n c, left parentheses, int some Param, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: int i equals 0, semicolon. 2 forward slashes.
Initialized each time. 
Line 4, indented once: int n equals 2 asterisk some Param plus 3,
semicolon. 2 forward slashes. Initialized each time. 
Line 4: dot, dot, dot. 
Line 5: right brace.
Back to Figure
Program code. The words in the function name are merged. The
code contains the following keywords: void, int, static, char. 
Line 1: void Another F u n c, left parentheses, int param, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: static char c h equals single quote, uppercase
a, single quote, semicolon. 2 forward slashes. Initialized once only. 
Line 4, indented once: static int m equals param plus 1, semicolon. 2
forward slashes. Initialized once only. 
Line 5: dot, dot, dot. 
Line 6: right brace.
Back to Figure
The input is as follows. 
Line 1: Ada Augusta, Countess of Lovelace, is a highly admired

figure. 
Line 2: in the history of computing. Ada, comma, the daughter of
Lord Byron. 
Line 3: left parentheses, the English poet, right parentheses,
comma, was herself quite a mathematician, period. She. 
Line 4: became interested in Baggage’s work on the analytical
engine. 
Line 5: and extended his ideas, left parentheses, and corrected
some of his errors, right parentheses, period. 
Line 6: Ada is credited with being the first programmer, period. The
concept. 
Line 7: of the loop, hyphen, hyphen, a series of instructions that
repeat, hyphen, hyphen, is. 
Line 8: attributed to her, period. Ada, comma, the language used by
the Department of Defense, comma, is named for her, period. The
output is as follows. 
Line 1: Line 1 has 61 characters, colon. 
Line 2: Line 62 has 62 characters, colon. 
Line 3: Line 63 has 60 characters, colon. 
Line 4: Line 61 has 61 characters, colon. 
Line 5: Line 62 has 59 characters, colon. 
Line 6: Line 60 has 63 characters, colon. 
Line 7: Line 64 has 54 characters, colon. 
Line 8: Line 55 has 62 characters, colon. 
Line 9: Line 63 has 29 characters, colon. 
Line 10: Line 30 has 29 characters, colon. 
Line 11: Number of lines, colon, 29.
Back to Figure
Program code. The words in the function name, and variable names
are merged. The code contains the following keywords: include, i o
stream, f stream, string, using, name space, s t d, void, int, i
stream, i f stream. 
Line 1: hash include, left angled brackets, i o stream, right angled
brackets. 
Line 2: hash include, left angled brackets, f stream, right angled
brackets. 
Line 3: hash include, left angled brackets, string, right angled

brackets. 
Line 4: using name space s t d, semicolon. 
Line 5: void Letter Count, left parentheses, string line, comma, int
ampersand count, right parentheses, semicolon. 
Line 6: 2 forward slashes. Number of letters in line is returned in
count. 
Line 7: void Line Count, left parentheses, i stream ampersand file,
comma, int ampersand count, right parentheses, semicolon. 
Line 8: 2 forward slashes. Number of lines in file is returned in count.
Line 9: int main, left parentheses, right parentheses. 
Line 10: left brace. 
Line 11, indented once: i f stream in file, semicolon. 
Line 12, indented once: in File dot open, left parentheses, double
quotes, test dot d a t, double quotes, right parentheses, semicolon. 
Line 13, indented once: int count equals 0, semicolon.
Back to Figure
Program code. The words in the function names, variable names,
and keywords are merged. The code contains the following
keywords: c out, end l, return, void, string, int, i stream, string, while.
Line 1, indented once: Line Count, left parentheses, in File, comma,
count, right parentheses, semicolon. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
Number of lines, colon, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, end l, semicolon. 
Line 3, indented once: return 0, semicolon. 
Line 4: right brace. 
Line 5: void Letter Count, left parentheses, string line, comma, int
ampersand count, right parentheses. 
Line 6: left brace. 
Line 7, indented once: count equals line dot length, left parentheses,
right parentheses, semicolon. 
Line 8, indented once: c out, 2 left angled brackets, double quotes,
blank space, has, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, double quotes, blank space,
characters, colon, blank space, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 9: right brace. 

Line 10: void Line Count, left parentheses, i stream ampersand file,
comma, int ampersand count, right parentheses. 
Line 11: left brace. 
Line 12, indented once: string line, semicolon. 
Line 13, indented once: while, left parentheses, file, right
parentheses. 
Line 14, indented once: left brace. 
Line 15, indented once: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 16, indented once: count plus plus, semicolon. 
Line 17, indented once: c out, 2 left angled brackets, double quotes,
Line, blank space, double quotes, 2 left angled brackets, count,
semicolon. 
Line 18, indented once: Letter Count, left parentheses, line, comma,
count, right parentheses, semicolon. 
Line 19, indented once: right brace. 
Line 20: right brace.
Back to Figure
Line 1: Line 1 has 61 characters, colon. 
Line 2: Line 2 has 62 characters, colon. 
Line 3: Line 3 has 60 characters, colon. 
Line 4: Line 4 has 61 characters, colon.
Back to Figure
Line 1: Line 5 has 59 characters, colon. 
Line 2: Line 6 has 63 characters, colon. 
Line 3: Line 7 has 54 characters, colon. 
Line 4: Line 8 has 62 characters, colon. 
Line 5: Line 9 has 29 characters, colon. 
Line 6: Line 10 has 29 characters, colon. 
Line 7: Number of lines, colon, 10.
Back to Figure
Program code. The words used in the keywords, variable names,
and function names are merged. The code contains the following

keywords: include, i o stream, f stream, string, using, name space, s
t d, void, int, main, c out, end l, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Program reads a file and outputs the line
number. 
Line 3: 2 forward slashes. and the number of characters in the line. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 
Line 7: hash include, left angled bracket, string, right angled bracket.
Line 8: using name space s t d, semicolon. 
Line 9: void Letter Count, left parentheses, string line, right
parentheses, semicolon. 
Line 10: 2 forward slashes. The number of characters in line is
output. 
Line 11: void Line Count, left parentheses, i stream ampersand file,
comma, int ampersand count, right parentheses, semicolon. 
Line 12: 2 forward slashes. Number of lines in file is returned in
count. 
Line 13: int main, left parentheses, right parentheses. 
Line 14: left brace. 
Line 15, indented once: i f stream in File, semicolon. 
Line 16, indented once: in File dot Open, left parentheses, double
quotes, test dot d a t, double quotes, right parentheses, semicolon. 
Line 17, indented once: int count equals 0, semicolon. 
Line 18, indented once: Line Count, left parentheses, in File,
comma, count, right parentheses, semicolon. 
Line 19, indented once: c out, 2 left angled brackets, double quotes,
Number of lines, colon, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, end l, semicolon. 
Line 20, indented once: return 0, semicolon. 
Line 21: right brace.
Back to Figure
Program code. The words in the function names, and keywords are
merged. The code contains the following keywords: void, string, int,

c out, end l, string, i stream, while. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Letter Count, left parentheses, string line, right
parentheses. 
Line 3: left brace. 
Line 4, indented once: int count equals line dot length, left
parentheses, right parentheses, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
blank space, has, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, double quotes, blank space,
characters, colon, blank space, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6: right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: void Line Count, left parentheses, i stream ampersand file,
comma, int ampersand count, right parentheses. 
Line 9: left brace. 
Line 10, indented once: string line, semicolon. 
Line 11, indented once: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 12, indented once: while, left parentheses, file, right
parentheses. 
Line 13, indented once: left brace. 
Line 14, indented twice: count plus plus, semicolon. 
Line 15, indented twice: c out, 2 left angled brackets, double quotes,
Line, blank space, double quotes, 2 left angled brackets, count,
semicolon. 
Line 16, indented twice: Letter Count, left parentheses, line, right
parentheses, semicolon. 
Line 17, indented twice: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 18, indented once: right brace. 
Line 19: right brace.
Back to Figure
Program code. The words in the function names, and keywords are
merged. The code contains the following keywords: void, string, int,
c out, end l, string, i stream, while. 

Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Letter Count, left parentheses, string line, right
parentheses. 
Line 3: left brace. 
Line 4, indented once: int count equals line dot length, left
parentheses, right parentheses, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
blank space, has, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, double quotes, blank space,
characters, colon, blank space, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6: right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: void Line Count, left parentheses, i stream ampersand file,
comma, int ampersand count, right parentheses. 
Line 9: left brace. 
Line 10, indented once: string line, semicolon. 
Line 11, indented once: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 12, indented once: while, left parentheses, file, right
parentheses. 
Line 13, indented once: left brace. 
Line 14, indented twice: count plus plus, semicolon. 
Line 15, indented twice: c out, 2 left angled brackets, double quotes,
Line, blank space, double quotes, 2 left angled brackets, count,
semicolon. 
Line 16, indented twice: Letter Count, left parentheses, line, right
parentheses, semicolon. 
Line 17, indented twice: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 18, indented once: right brace. 
Line 19: right brace.
Back to Figure
The 3 blocks in the diagram are as follows: main function and other
functions, Parameter list, A typical function. The block labeled
Parameter list is the communication interface between the block
representing the main function and other functions and the block

representing a typical function. Arrows are drawn from the block
representing the main function and other functions, and from the
block representing a typical function to the block representing the
parameter list. Arrows are also drawn from the block representing
the parameter list to the other 2 blocks. A dashed arrow is drawn
from the block representing the main function and other functions to
the block representing a typical function. Another dashed arrow is
drawn from the block representing a typical function to the block
representing the main function and other functions. Side effects are
represented by an x marked over the 2 dashed arrows.
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The code contains the following
keywords: include, using, name space, s t d, void, int, main, c in,
while, c out, end l, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This is an example of poor program
design, comma, which. 
Line 3: 2 forward slashes. causes an error when the program is
executed. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled brackets, i o stream, right angled
brackets. 
Line 6: using name space s t d, semicolon. 
Line 7: void Count Ints, left parentheses, right parentheses,
semicolon. 
Line 8: int count, semicolon. 2 forward slashes. Supposed to count
input lines, comma, but does it, question mark. 
Line 9: int int Val, semicolon. 2 forward slashes. Holds one input
integer. 
Line 10: int main, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12, indented once: count equals 0, semicolon. 
Line 13, indented once: c in, 2 right angled brackets, int Val,
semicolon. 
Line 14, indented once: while, left parentheses, c in, right
parentheses. 

Line 15, indented once: left brace. 
Line 16, indented twice: count plus plus, semicolon. 
Line 17, indented twice: Count Ints, left parentheses, right
parentheses, semicolon. 
Line 18, indented twice: c in, 2 right angled brackets, int Val,
semicolon. 
Line 19, indented once: right brace. 
Line 20, indented once: c out, 2 left angled brackets, count, 2 left
angled brackets, double quotes, blank space, lines of input
processed, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 21, indented once: return 0, semicolon. 
Line 22: right brace.
Back to Figure
Program code. The words in the function name, variable name, and
keywords are merged. The code contains the following keywords:
void, while, c in, c out, end l. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Count Ints, left parentheses, right parentheses. 
Line 3: 2 forward slashes. counts the number of integers on one
input line, left parentheses, where 99999. 
Line 4: 2 forward slashes. is a sentinel on each line, right
parentheses, and outputs the count. 
Line 5: 2 forward slashes. Note, colon, main, left parentheses, right
parentheses, has already read the first integer on a line. 
Line 6: left brace. 
Line 7, indented once: count equals 0, semicolon. 2 forward slashes.
side effect. 
Line 8, indented once: while, left parentheses, int Val not equal to
99999, right parentheses. 
Line 9, indented once: left brace. 
Line 10, indented twice: count plus plus, semicolon. 2 forward
slashes. Side effect. 
Line 11, indented twice: c in, 2 right angled brackets, int Val,
semicolon. 
Line 12, indented once: right brace. 
Line 13, indented once: c out, 2 left angled brackets, count, 2 left

angled brackets, double quotes, blank space, integers on this line,
period, double quotes, 2 left angled brackets, end l, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The code contains the following keywords: int, while,
return. 
Line 1: int Power, left parentheses, int number, comma. 2 forward
slashes, Base number. 
Line 2: int n, right parentheses. 2 forward slashes. Power to raise
base to. 
Line 3: 2 forward slashes. This function calculates and returns
number to the. 
Line 4: 2 forward slashes. n t h power. 
Line 5: 2 forward slashes. Pre, colon, n must be greater than or
equal to 0. 
Line 6: left brace. 
Line 7, indented once: int result equals 1, semicolon. 2 forward
slashes. Holds intermediate powers of x. 
Line 8, indented once: while, left parentheses, n greater than 0, right
parentheses. 
Line 9, indented once: left brace. 
Line 10, indented twice: result equals result asterisk number,
semicolon. 
Line 11, indented twice: n minus minus, semicolon. 
Line 12, indented once: right brace. 
Line 13, indented once: return result, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: include, i o stream, using, name
space, s t d, int, main, c out, end l, return, while. The code
corresponding to the main function is as follows. 
Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: using name space s t d, semicolon. 

Line 3: int Power, left parentheses, int, comma, int, right
parentheses, semicolon. 
Line 4: int main, left parentheses, right parentheses. 
Line 5: left brace. 
Line 6, indented once: c out. 
Line 7, indented once: 2 left angled brackets, double quotes, 5
raised to the 4 t h power is, double quotes. 
Line 8, indented once: 2 left angled brackets, Power, left
parentheses, 5, comma, 4, right parentheses, 2 left angled brackets,
end l, semicolon. 
Line 9, indented once: return 0, semicolon. 
Line 10: right brace. The definition of the function labeled Power is
as follows. 
Line 1: int Power, left parentheses, int number, comma, int n, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: int result equals 1, semicolon. 
Line 4, indented once: while, left parentheses, n greater than 0, right
parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: result equals result asterisk number,
semicolon. 
Line 7, indented twice: n minus minus, semicolon. 
Line 8, indented once: right brace. 
Line 9, indented once: return result, semicolon. 
Line 10: right brace. An arrow is drawn from Line 9 of the function
definition to Line 8 of the main program.
Back to Figure
Line 1: Data Type Function Name, left parentheses, Parameter List,
right parentheses. 
Line 2: left brace. 
Line 3, indented once: Statement. 
Line 4: dot, dot, dot. 
Line 5: right brace.
Back to Figure

Program code. The words used in the function names, and variable
names are merged. The code contains the following keywords:
include, i o stream, f stream, string, using, name space, s t d, void,
int, i stream, i f stream, c out, end l, return, while. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program reads a file and outputs the
line number. 
Line 3: 2 forward slashes. and the number of characters for each
line. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 
Line 7: hash include, left angled bracket, string, right angled bracket.
Line 8: using name space s t d, semicolon. 
Line 9: void Letter Count, left parentheses, string line, right
parentheses, semicolon. 
Line 10: 2 forward slashes. The number of characters in line is
output. 
Line 11: int Line Count, left parentheses, i stream ampersand file,
right parentheses, semicolon. 
Line 12: 2 forward slashes. Number of lines in file is returned. 
Line 13: int main, left parentheses, right parentheses. 
Line 14: left brace. 
Line 15, indented once: i f stream in File, semicolon. 
Line 16, indented once: in File dot open, left parentheses, double
quotes, test dot d a t, double quotes, right parentheses, semicolon. 
Line 17, indented once: c out, 2 left angled brackets, double quotes,
Number of lines, colon, blank space, double quotes, 2 left angled
brackets, Line Count, left parentheses, in File, right parentheses, 2
left angled brackets, end l, semicolon. 
Line 18, indented once: return 0, semicolon. 
Line 19: right brace. 
Line 20: 2 forward slashes followed by asterisks till the end of the
line. 
Line 21: void Letter Count, left parentheses, string line, right
parentheses. 
Line 22: left brace. 

Line 23, indented once: int count equals line dot length, left
parentheses, right parentheses, semicolon. 
Line 24, indented once: c out, 2 left angled brackets, double quotes,
blank space, has, blank space, double quotes, 2 left angled
brackets, count, 2 left angled brackets, double quotes, blank space,
characters, colon, blank space, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 25: right brace. 
Line 26: 2 forward slashes followed by asterisks till the end of the
line. 
Line 27: int Line Count, left parentheses, i stream ampersand file,
right parentheses. 
Line 28: left brace. 
Line 29, indented once: int count equals 0, semicolon. 
Line 30, indented once: string line, semicolon. 
Line 31, indented once: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 32, indented once: while, left parentheses, file, right
parentheses. 
Line 33, indented once: left brace. 
Line 34, indented twice: count plus plus, semicolon. 
Line 35, indented twice: c out, 2 left angled brackets, double quotes,
Line, blank space, double quotes, 2 left angled brackets, count,
semicolon. 
Line 36, indented twice: Letter Count, left parentheses, line, right
parentheses, semicolon. 
Line 37, indented twice: get line, left parentheses, file, comma, line,
right parentheses, semicolon. 
Line 38, indented once: right brace. 
Line 39, indented once: return count, semicolon. 
Line 40: right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: static, cast, float. 
Line 1: start equals Day, left parentheses, start Month, comma, start
Day, comma, start Year, right parentheses, semicolon. 
Line 2: last equals Day, left parentheses, last Month, comma, last

Day, comma, last Year, right parentheses, semicolon. 
Line 3: withdraw equals Day, left parentheses, withdraw Month,
comma, withdraw Day, comma, withdraw year, right parentheses,
semicolon. 
Line 4: fraction equals static underscore cast, left angled bracket,
float, right angled bracket, left parentheses, last minus withdraw plus
1, right parentheses, forward slash. 
Line 5, indented multiple times: static underscore cast, left angled
bracket, float, right angled bracket, left parentheses, last minus start
plus 1, right parentheses, semicolon. 
Line 6: refund equals tuition asterisk fraction, semicolon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: int, if,
switch. 
Line 1: int Day, left parentheses, int month, comma, int day Of
Month, comma, int year, right parentheses. 
Line 2: 2 forward slashes. This function computes and returns the
day number within a year, comma. 
Line 3: 2 forward slashes. given the date, period. It accounts
correctly for leap years. 
Line 4: 2 forward slashes. Pre, colon, The month, comma, day,
comma, and year are within the proper range. 
Line 5: left brace. 
Line 6, indented once: int correction equals 0, semicolon. 2 forward
slashes. Correction factor to account for leap year. 
Line 7, indented once: if, left parentheses, Is Leap Year, left
parentheses, year, right parentheses, right parentheses. 
Line 8, indented twice: correction equals 1, semicolon. 2 forward
slashes. Then add one for leap year. 
Line 9, indented once: 2 forward slashes. Correct for different length
months. 
Line 10: indented once: switch, left parentheses, month, right
parentheses.
Back to Figure

Program code. The words in the variable names are merged. The
code contains the following keywords: case, break, return. 
Line 1: left brace. 
Line 2, indented once: case 3, colon, correction equals correction
minus 1, semicolon. 
Line 3, indented multiple times: break, semicolon. 
Line 4, indented once: case 8, colon, correction equals correction
plus 2, semicolon. 
Line 5, indented multiple times: break, semicolon. 
Line 6, indented once: case 2, colon. 
Line 7, indented once: case 6, colon. 
Line 8, indented once: case 7, colon, correction equals correction
plus 1, semicolon. 
Line 9, indented multiple times: break, semicolon. 
Line 10, indented once: case 9, colon. 
Line 11, indented once: case 10, colon, correction equals correction
plus 3, semicolon. 
Line 12, indented multiple times: break, semicolon. 
Line 13, indented once: case 11, colon. 
Line 14, indented once: case 12, colon, correction equals correction
plus 4, semicolon. 
Line 15, indented multiple times: break, semicolon. 
Line 16: right brace. 
Line 17: return, left parentheses, month minus 1, right parentheses,
asterisk 30 plus correction plus day Of Month, semicolon. 
Line 18: right brace.
Back to Figure
Program code. The words in the function names, variable names,
and keywords are merged. The code contains the following
keywords: include, i o stream, i o manip, using, name space, s t d,
const, float, bool, int. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program calculates and outputs the
tuition refund. 
Line 3: 2 forward slashes. owed a student given the beginning and
ending dates of the. 
Line 4: 2 forward slashes. semester and the withdrawal date. 

Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 7: hash include, left angled bracket, i o manip, right angled
bracket. 
Line 8: using name space s t d, semicolon. 
Line 9: const float TUITION equals 35000.0, semicolon. 
Line 10: bool Is Leap Year, left parentheses, int year, right
parentheses, semicolon. 2 forward slashes. Prototype for sub
algorithm. 
Line 11: 2 forward slashes. Returns true if the year is a leap year. 
Line 12: int Day, left parentheses, int month, comma, int day Of
Month, comma, int year, right parentheses, semicolon. 
Line 13: 2 forward slashes. This function computes and returns the
day number within a year, comma. 
Line 14: 2 forward slashes. given the date, period. It accounts
correctly for leap years. 
Line 15: 2 forward slashes. Pre, colon, The month, comma, day,
comma, and year are within the proper range. 
Line 16: int main, left parentheses, right parentheses. 
Line 17: left brace. 
Line 18, indented once: int month, comma, day, comma, year,
semicolon. 
Line 19, indented once: int start, comma, last, comma, withdraw,
semicolon.
Back to Figure
Program code. The words in the keywords and function names are
merged. The code contains the following keywords: float, c out, end
l, c in, return, int, if, switch, case, break. 
Line 1, indented once: float fraction, semicolon. 
Line 2, indented once: float refund, semicolon. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
Enter the month, comma, day, comma, and year of beginning of
semester, period, double quotes. 
Line 4, indented twice: 2 left angled brackets, end l, semicolon. 
Line 5, indented once: c in, 2 right angled brackets, month, 2 right
angled brackets, day, 2 right angled brackets, year, semicolon. 

Line 6, indented once: start equals Day, left parentheses, month,
comma, day, comma, year, right parentheses, semicolon. 
Line 7, indented once: c out, 2 left angled brackets, double quotes,
Enter the month, comma, day, comma, and year of end of semester,
period, double quotes. 
Line 8, indented twice: 2 left angled brackets, end l, semicolon. 
Line 9, indented once: c in, 2 right angled brackets, month, 2 right
angled brackets, day, 2 right angled brackets, year, semicolon. 
Line 10, indented once: last equals Day, left parentheses, month,
comma, day, comma, year, right parentheses, semicolon. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Enter the month, comma, day, comma, and year of withdrawal,
period, double quotes. 
Line 12, indented twice: 2 left angled brackets, end l, semicolon. 
Line 13, indented once: c in, 2 right angled brackets, month, 2 right
angled brackets, day, 2 right angled brackets, year, semicolon. 
Line 14, indented once: withdraw equals Day, left parentheses,
month, comma, day, comma, year, right parentheses, semicolon. 
Line 15, indented once: fraction equals static underscore cast, left
angled bracket, float, right angled bracket, left parentheses, last
minus withdraw plus 1, right parentheses, forward slash. 
Line 16, indented multiple times: static underscore cast, left angled
bracket, float, right angled bracket, left parentheses, last minus start
plus 1, right parentheses, semicolon. 
Line 17, indented once: refund equals TUITION asterisk fraction,
semicolon. 
Line 18, indented once: c out, 2 left angled brackets, double quotes,
The student gets a refund of dollar sign, double quotes, 2 left angled
brackets, fixed. 
Line 19, indented twice: 2 left angled brackets, set precision, left
parentheses, 2, right parentheses, 2 left angled brackets, refund, 2
left angled brackets, end l, semicolon. 
Line 20, indented once: return 0, semicolon. 
Line 21: right brace. 
Line 22: 2 forward slashes followed by asterisks till the end of the
line. 
Line 23: int Day, left parentheses, int month, comma, int day Of
Month, comma, int year, right parentheses. 
Line 24: 2 forward slashes. This function computes and returns the

day number within a year, comma. 
Line 25: 2 forward slashes. given the date, period. It accounts
correctly for leap years. 
Line 26: 2 forward slashes. Pre, colon, The month, comma, day,
comma, and year are within the proper range. 
Line 27: left brace. 
Line 28, indented once: int correction equals 0, semicolon. 2 forward
slashes. Correction factor to account for leap year. 
Line 29, indented once: if, left parentheses, Is Leap Year, left
parentheses, year, right parentheses, right parentheses. 
Line 30, indented twice: correction equals 1, semicolon. 2 forward
slashes. Then add one for leap year. 
Line 31, indented once: 2 forward slashes. Correct for different
hyphen length months. 
Line 32, indented once: switch, left parentheses, month, right
parentheses. 
Line 33, indented once: left brace. 
Line 34, indented twice: case 3, colon, correction equals correction
minus 1, semicolon. 
Line 35, indented 4 times: break, semicolon. 
Line 36, indented twice: case 8, colon, correction equals correction
plus 2, semicolon. 
Line 37, indented 4 times: break, semicolon. 
Line 38, indented twice: case 2, colon. 
Line 39, indented twice: case 6, colon. 
Line 40, indented twice: case 7, colon. correction equals correction
plus 1, semicolon. 
Line 41, indented 4 times: break, semicolon. 
Line 42, indented twice: case 9, colon. 
Line 43, indented twice: case 10, colon. correction equals correction
plus 3, semicolon. 
Line 44, indented 4 times: break, semicolon.
Back to Figure
Program code. The words in the variable name, and function name
are merged. The code contains the following keywords: case, break,
return, bool, int, if, else. 
Line 1, indented twice: case 11, colon. 

Line 2, indented twice: case 12, colon, correction equals correction
plus 4, semicolon. 
Line 3, indented 4 times: break, semicolon. 
Line 4, indented once: right brace. 
Line 5, indented once: return, left parentheses, month minus 1, right
parentheses, asterisk 30, plus, correction plus day Of Month,
semicolon. 
Line 6: right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: bool Is Leap Year, left parentheses, int year, right
parentheses. 
Line 9: 2 forward slashes. Is Leap Year returns true if year is a leap
year and. 
Line 10: 2 forward slashes. false otherwise. 
Line 11: left brace. 
Line 12, indented once: if, left parentheses, year mod 4 not equal to
0, right parentheses. 2 forward slashes. Is year not divisible by 4,
question mark. 
Line 13, indented twice: return false, semicolon. 2 forward slashes.
If so, comma, can’t be a leap year. 
Line 14, indented once: else if, left parentheses, year mod 100 not
equal to 0, right parentheses. 2 forward slashes. Is year not a
multiple of 100, question mark. 
Line 15, indented twice: return true, semicolon. 2 forward slashes. If
so, comma, is a leap year. 
Line 16, indented once: else if, left parentheses, year mod 400 not
equal to 0, right parentheses. 2 forward slashes. Is year not a
multiple of 400, question mark. 
Line 17, indented twice: return false, semicolon. 2 forward slashes.
If so, comma, then is not a leap year. 
Line 18, indented once: else. 
Line 19, indented twice: return true, semicolon. 2 forward slashes. Is
a leap year. 
Line 20: right brace.
Back to Figure
Line 1: Enter the month, comma, day, comma, and year of
beginning of semester, period. 

Line 2: 1, blank space, 15, blank space, 2008. 
Line 3: Enter the month, comma, day, comma, and year of end of
semester, period. 
Line 4: 5, blank space, 15, blank space, 2008. 
Line 5: Enter the month, comma, day, comma, and year of
withdrawal, period. 
Line 6: 3, blank space, 3, blank space, 2008. Lines 2, 4, and 6 are
shaded.
Back to Figure
Program code. The words in the function names, and variable
names are merged. The code contains the following keywords:
include, c math, bool, float, return. 
Line 1: hash include, left angled bracket, c math, right angled
bracket. 2 forward slashes. For f a b s, left parentheses, right
parentheses. 
Line 2: dot, dot, dot. 
Line 3: bool Is Triangle, left parentheses, float angle 1, comma, float
angle 2, comma, float angle 3, right parentheses. 
Line 4: 2 forward slashes. This function returns true if its three
incoming values. 
Line 5: 2 forward slashes. add up to 180 degrees, comma, forming a
valid triangle, comma, and. 
Line 6: 2 forward slashes. false otherwise.
Line 7: left brace.
Line 8, indented once: return, left parenthesis, f a b s, left
parenthesis, angle 1 plus angle 2 plus angle 3 minus 180.0, right
parenthesis, less than 0.00000001, right parenthesis, semicolon.
Line 9: right brace."
Back to Figure
Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords. include, i o stream, c math, using, name space, s t d,
bool, float, int, c out, end l, c in, while, if, else, return, bool.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Triangle program. 

Line 3: 2 forward slashes. This program uses the Is Triangle
function. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, left angled bracket, c math, right angled
bracket. 2 forward slashes. For f a b s, left parentheses, right
parentheses. 
Line 7: using name space s t d, semicolon. 
Line 8: bool Is Triangle, left parentheses, float, comma, float,
comma, float, right parentheses, semicolon. 
Line 9: int main, left parentheses, right parentheses. 
Line 10: left brace. 
Line 11, indented once: float angle A, semicolon. 2 forward slashes.
Three angles of a potential triangle. 
Line 12, indented once: float angle B, semicolon. 
Line 13, indented once: float angle C, semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Triangle testing program, semicolon, blank space, double quotes. 
Line 15, indented multiple times: 2 left angled brackets, double
quotes, a negative first angle ends the processing, period, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 16, indented once: c out, 2 left angled brackets, double quotes,
Enter 3 angles, colon, blank space, double quotes, semicolon. 
Line 17, indented once: c in, 2 right angled brackets, angle A,
semicolon. 
Line 18, indented once: while, left parentheses, angle A greater than
or equal to 0, right parentheses. 
Line 19, indented once: left brace. 
Line 20, indented twice: c in, 2 right angled brackets, angle B, 2 right
angled brackets, angle C, semicolon. 
Line 21, indented twice: if, left parentheses, Is Triangle, left
parentheses, angle A, comma, Angle B, comma, angle C, right
parentheses, right parentheses. 
Line 22, indented thrice: c out, 2 left angled brackets, double quotes,
The 3 angles form a valid triangle, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 23, indented twice: else. 
Line 24, indented thrice: c out, 2 left angled brackets, double quotes,

The 3 angles do not form a triangle, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 25, indented twice: c out, 2 left angled brackets, double quotes,
Enter 3 angles, colon, blank space, double quotes, semicolon. 
Line 26, indented twice: c in, 2 right angled brackets, angle A,
semicolon. 
Line 27, indented once: right brace. 
Line 28, indented once: return 0, semicolon. 
Line 29: right brace. 
Line 30: 2 forward slashes followed by asterisks till the end of the
line. 
Line 31: bool Is Triangle, left parentheses, float angle 1, comma,
float angle 2, comma, float angle 3, right parentheses. 
Line 32: left brace. 
Line 33, indented once: return, left parentheses, f a b s, left
parentheses, angle 1, plus, angle 2, plus, angle 3, minus, 180.0,
right parentheses, less than 0.00000001, right parentheses,
semicolon. 
Line 34: right brace.
Back to Figure
Line 1: Triangle testing program, semicolon, a negative first angle
ends the. 
Line 2: processing, period. 
Line 3: Enter 3 angles, colon. 
Line 4: 45, blank space, 10, blank space, 35. 
Line 5: The 3 angles do not form a triangle, period. 
Line 6: Enter 3 angles, colon. 
Line 7: 45, blank space, 45, blank space, 90. 
Line 8: The 3 angles form a valid triangle, period. 
Line 9: Enter 3 angles, colon. 
Line 10: 90, blank space, 80, blank space, 35. 
Line 11: The 3 angles do not form a triangle, period. 
Line 12: Enter 3 angles, colon. 
Line 13: negative 10. 
Line 4, 7, 10, and 13 are shaded.
Back to Figure

Program code. The words in the function names are merged. 
Line 1: Show Results, left parentheses, a, comma, b, comma, c,
right parentheses, semicolon. 
Line 2: Do This, left parentheses, x, right parentheses, semicolon. 
Line 3: Do That, left parentheses, right parentheses, semicolon.
Back to Figure
Line 1: while, left parentheses, Valid, left parentheses, m, comma, n,
right parentheses, right parentheses. 
Line 2: if, left parentheses, Odd, left parentheses, n, right
parentheses, right parentheses. 
Line 3: if, left parentheses, Is Triangle, left parentheses, s 1,
comma, s 2, comma, s 3, right parentheses, right parentheses.
Back to Figure
Program code. The words in the function name are merged. The
code contains the following keywords: int, return. 
Line 1: int Side Effect, left parentheses, int ampersand, n, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: int result equals n asterisk n, semicolon. 
Line 4, indented once: n plus plus, semicolon. 2 forward slashes.
side effect. 
Line 5, indented once: return result, semicolon. 
Line 6: right brace.
Back to Figure
Program code. The words in the keywords, variable name, and
function name are merged. The code contains the following
keywords: if, c out, else. 
Line 1: if, left parentheses, Is Triangle, left parentheses, angle A,
comma, 60.0, comma, 30.0 plus 60.0, right parentheses, right
parentheses. 
Line 2, indented once: c out, 2 left angled brackets, double quotes,
The three angles form a valid triangle, period, double quotes,
semicolon. 

Line 3: else. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
The 3 angles do not form a triangle, period, double quotes,
semicolon.
Back to Figure
Program code. The words in the function name are merged. The
code contains the following keywords: void, int. 
Line 1: void Do Something, left parentheses, int n, right
parentheses. 
Line 2: left brace. 
Line 3: dot, dot, dot. 
Line 4: right brace.
Back to Figure
Program code. The words in the function name are merged. The
code contains the following keywords: int, float, return. 
Line 1: int Some F u n c, left parentheses, float x, right parentheses.
Line 2: left brace. 
Line 3: dot, dot, dot. 
Line 4, indented once: return 70000, semicolon. 
Line 5: right brace.
Back to Figure
Line 1: status equals remove, left parentheses, double quotes, junk
file dot d a t, double quotes, right parentheses, semicolon. 
Line 2: if, left parentheses, status, not equal to, 0, right parentheses.
Line 3, indented once: Show Error M s g, left parentheses, right
parentheses, semicolon.
Back to Figure
The modules under the Main module are as follows: Name, Evaluate
Cholesterol, Evaluate B M I, and Evaluate Blood Pressure. The
return value of the module labeled Name is name. The inputs to the
module labeled Evaluate Cholesterol are health Profile, and name.
The inputs to the module labeled Evaluate B M I are health Profile,

and name. The inputs to the module labeled Evaluate Blood
Pressure are health Profile and name.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: include, f stream, i o stream.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Profile Program. 
Line 3: 2 forward slashes. This program inputs a name, comma,
weight, comma, height, comma, blood pressure. 
Line 4: 2 forward slashes. readings, comma, and cholesterol values.
Appropriate health messages. 
Line 5: 2 forward slashes. are written for each of the input values on
file health Profile. 
Line 6: 2 forward slashes followed by asterisks till the end of the line.
Line 7: hash include, left angled bracket, f stream, right angled
bracket. 
Line 8: hash include, left angled bracket, i o stream, right angled
bracket.
Back to Figure
Program code. The words in the keywords, function names, and
variable names are merged. The code contains the following
keywords: include, string, i o mainip, using, name space, s t d, void,
o f stream, int, end l, return. 
Line 1: hash include, left angled bracket, string, right angled bracket.
Line 2: hash include, left angled bracket, i o manip, right angled
bracket. 
Line 3: using name space s t d, semicolon. 
Line 4: 2 forward slashes. Function prototypes. 
Line 5: string Name, left parentheses, right parentheses. 
Line 6: 2 forward slashes. This function inputs a name and returns it
in first, comma. 
Line 7: 2 forward slashes. middle initial, comma, and last order. 
Line 8: void Evaluate Cholesterol, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses,
semicolon. 

Line 9: 2 forward slashes. This function inputs H D L, left
parentheses, good cholesterol, right parentheses, and L D L, left
parentheses, bad. 
Line 10: 2 forward slashes. cholesterol, right parentheses, and
outputs a health message based on their. 
Line 11: 2 forward slashes. values on file health Profile. 
Line 12: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 13: void Evaluate B M I, left parentheses, o f stream,
ampersand, health Profile, comma, string name, right parentheses,
semicolon. 
Line 14: 2 forward slashes. This function inputs weight in pounds
and height in inches and. 
Line 15: 2 forward slashes. calculates the body mass index, left
parentheses, B M I, right parentheses, comma, then outputs a
health message. 
Line 16: 2 forward slashes. based on the B M I, period. Input is in
English weights. 
Line 17: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 18: void Evaluate Blood Pressure, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses,
semicolon. 
Line 19: 2 forward slashes. This function gets blood pressure
readings, left parentheses, systolic, forward slash, diastolic, right
parentheses. 
Line 20: 2 forward slashes. and outputs a health message based on
their values. 
Line 21: 2 forward slashes. on file health Profile. 
Line 22: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 23: int main, left parentheses, right parentheses. 
Line 24: left brace. 
Line 25, indented once: 2 forward slashes. Declare and open the
output file. 
Line 26, indented once: o f stream health Profile, semicolon. 
Line 27, indented once: health Profile dot open, left parentheses,
double quotes, Profile, double quotes, right parentheses, semicolon. 
Line 28, indented once: string name, semicolon. 

Line 29, indented once: name equals Name, left parentheses, right
parentheses, semicolon. 
Line 30, indented once: 2 forward slashes. Write patient’s name on
output file. 
Line 31, indented once: health Profile, 2 left angled brackets, double
quotes, Patient’s name, blank space, double quotes, 2 left angled
brackets, name, 2 left angled brackets, end l, semicolon. 
Line 32, indented once: 2 forward slashes. Evaluate the patient’s
statistics. 
Line 33, indented once: Evaluate Cholesterol, left parentheses,
health Profile, comma, name, right parentheses, semicolon. 
Line 34, indented once: Evaluate B M I, left parentheses, health
Profile, comma, name, right parentheses, semicolon. 
Line 35, indented once: Evaluate Blood Pressure, left parentheses,
health Profile, comma, name, right parentheses, semicolon. 
Line 36, indented once: health Profile, 2 left angled brackets, end l,
semicolon. 
Line 37, indented once: health Profile dot close, left parentheses,
right parentheses, semicolon. 
Line 38, indented once: return 0, semicolon. 
Line 39: right brace. 
Line 40: 2 forward slashes followed by asterisks till the end of the
line. 
Line 41: string Name, left parentheses, right parentheses. 
Line 42: 2 forward slashes. This function inputs a name and returns
it in first, comma. 
Line 43: 2 forward slashes. middle initial, comma, and last order.
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The code contains the following
keywords: string, char, c out, c in, return, void, o f stream, int, float,
end l, fixed, if, else. 
Line 1: left brace. 
Line 2, indented once: 2 forward slashes. Declare the patient’s
name. 
Line 3, indented once: string first Name, semicolon. 
Line 4, indented once: string last Name, semicolon. 

Line 5, indented once: char middle Initial, semicolon. 
Line 6, indented once: 2 forward slashes. Prompt for and enter the
patient’s name. 
Line 7, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s first name, colon, blank space, double quotes,
semicolon. 
Line 8, indented once: c in, 2 right angled brackets, first name,
semicolon. 
Line 9, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s last name, colon, blank space, double quotes,
semicolon. 
Line 10, indented once: c in, 2 right angled brackets, last Name,
semicolon. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s middle initial, colon, blank space, double quotes,
semicolon. 
Line 12, indented once: c in, 2 right angled brackets, middle Initial,
semicolon. 
Line 13, indented once: return first Name, plus, single quote, blank
space, single quote, plus, middle Initial, plus, double quotes, period,
blank space, double quotes, plus, last Name, semicolon. 
Line 14: right brace. 
Line 15: 2 forward slashes followed by asterisks till the end of the
line. 
Line 16: void Evaluate Cholesterol, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 17: 2 forward slashes. This function inputs H D L, left
parentheses, good cholesterol, right parentheses, and L D L, left
parentheses, bad. 
Line 18: 2 forward slashes. cholesterol, right parentheses, and
outputs a health message based on their. 
Line 19: 2 forward slashes. values on file health Profile. 
Line 20: left brace. 
Line 21, indented once: int H D L, semicolon. 
Line 22, indented once: int L D L, semicolon. 
Line 23, indented once: 2 forward slashes. Prompt for and enter H D
L and L D L. 
Line 24, indented once: c out, 2 left angled brackets, double quotes,
Enter H D L for, blank space, double quotes, 2 left angled brackets,

name, 2 left angled brackets, double quotes, colon, blank space,
double quotes, semicolon. 
Line 25, indented once: c in, 2 right angled brackets, H D L,
semicolon. 
Line 26, indented once: c out, 2 left angled brackets, double quotes,
Enter L D L for, blank space, double quotes, 2 left angled brackets,
name, 2 left angled brackets, double quotes, colon, blank space,
double quotes, semicolon. 
Line 27, indented once: c in, 2 right angled brackets, L D L,
semicolon. 
Line 28, indented once: float ratio equals static underscore cast, left
angled bracket, float, right angled bracket, left parentheses, H D L,
right parentheses, forward slash. 
Line 29, indented multiple times: static underscore cast, left angled
bracket, float, right angled bracket, left parentheses, L D L, right
parentheses, semicolon. 2 forward slashes. Calculate H D L to L D L
ratio. 
Line 30, indented once: health Profile, 2 left angled brackets, double
quotes, Cholesterol Profile, blank space, double quotes, 2 left angled
brackets, end l. 
Line 31, indented multiple times: 2 left angled brackets. double
quotes, blank space, H D L, colon, blank space, double quotes, 2
left angled brackets, H D L, 2 left angled brackets, double quotes,
blank space, L D L, colon, blank space, double quotes, 2 left angled
brackets, L D L, 2 left angled brackets, end l. 
Line 32, indented multiple times: 2 left angled brackets. double
quotes, blank space, Ratio, colon, blank space, double quotes, 2 left
angled brackets, fixed, 2 left angled brackets, set precision, left
parentheses, 4, right parentheses. 
Line 33, indented multiple times: 2 left angled brackets. 2 left angled
brackets, ratio, 2 left angled brackets, end l, semicolon. 
Line 34: 2 forward slashes. Output message based on H D L value. 
Line 35: if, left parentheses, H D L less than 40, right parentheses. 
Line 36, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is too low, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 37, indented once: else if, left parentheses, H D L less than 60,
right parentheses. 
Line 38, indented twice: health Profile, 2 left angled brackets, double

quotes, blank spaces, H D L is okay, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 39, indented once: else. 
Line 40, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is excellent, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 41, indented once: 2 forward slashes. Output message based
on L D L value. 
Line 42, indented once: if, left parentheses, L D L less than 100,
right parentheses. 
Line 43, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is optimal, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 44, indented once: else if, left parentheses, L D L less than
130, right parentheses. 
Line 45, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is near optimal, double quotes, 2 left
angled brackets, end l, semicolon.
Back to Figure
Program code. The words in the variable names, keywords, and
function names are merged. The code contains the following
keywords: else, if, end l, void, o f stream, string, const, int, c out, c
in.
Line 1, indented once: else if, left parentheses, L D L less than 160,
right parentheses. 
Line 2, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is borderline high, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 3, indented once: else if, left parentheses, L D L less than 190,
right parentheses. 
Line 4, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is high, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 5, indented once: else. 
Line 6, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is very high, double quotes, 2 left
angled brackets, end l, semicolon. 

Line 7, indented once: if, left parentheses, ratio greater than 0.3,
right parentheses. 
Line 8, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is good, double
quotes. 
Line 9, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 10, indented once: else. 
Line 11, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is not good, double
quotes. 
Line 12, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 13: right brace. 
Line 14: 2 forward slashes followed by asterisks till the end of the
line. 
Line 15: void Evaluate B M I, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 16: 2 forward slashes. This function inputs weight in pounds
and height in inches and. 
Line 17: 2 forward slashes. calculates the body mass index. Input in
English weights. 
Line 18: left brace. 
Line 19, indented once: const int B M I underscore CONSTANT
equals 703, semicolon. 2 forward slashes. Constant in English
formula. 
Line 20, indented once: int pounds, semicolon. 
Line 21, indented once: int inches, semicolon. 
Line 22, indented once: 2 forward slashes. Enter the patient’s weight
and height. 
Line 23, indented once: c out, 2 left angled brackets, double quotes,
Enter the weight in pounds for, blank space, double quotes, 2 left
angled brackets, name, 2 left angled brackets, double quotes, colon,
blank space, double quotes, semicolon. 
Line 24, indented once: c in, 2 right angled brackets, pounds,
semicolon. 
Line 25, indented once: c out, 2 left angled brackets, double quotes,
Enter the height in inches for, blank space, double quotes, 2 left
angled brackets, name, 2 left angled brackets, double quotes, colon,

blank space, double quotes, semicolon. 
Line 26, indented once: c in, 2 right angled brackets, inches,
semicolon. 
Line 27, indented once: health Profile, 2 left angled brackets, double
quotes, Body Mass Index Profile, double quotes, 2 left angled
brackets, end l. 
Line 28, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, Weight, colon, blank space, double quotes, 2
left angled brackets, pounds, 2 left angled brackets, double quotes,
blank space, Height, colon, blank space, double quotes. 
Line 29, indented multiple times: 2 left angled brackets, inches, 2 left
angled brackets, end l, semicolon. 
Line 30, indented once: Output body Mass Index. 
Line 31, indented once: health Profile, 2 left angled brackets, double
quotes, blank space, Body mass index is, blank space, double
quotes, 2 left angled brackets, body Mass Index. 
Line 32, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 33, indented once: health Profile, 2 left angled brackets, double
quotes, blank spaces, Interpretation of B M I, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 34, indented once: Output interpretation of B M I. 
Line 35, indented once: if, left parentheses, body Mass Index, less
than, 20, right parentheses. 
Line 36, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Underweight, double quotes. 
Line 37, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 38, indented once: else if, left parentheses, body Mass Index
less than or equal to 25, right parentheses. 
Line 39, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Normal, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 40, indented once: else if, left parentheses, body Mass Index
less than or equal to 30, right parentheses. 
Line 41, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Overweight, double quotes. 
Line 42, indented multiple times: 2 left angled brackets, end l,
semicolon. 

Line 43, indented once: else. 
Line 44, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Obese, double quotes. 
Line 45, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 46: right brace.
Back to Figure
Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords: void, o f stream, string, int, c out, c in, end l, if, else.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: void Evaluate Blood Pressure, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 3: 2 forward slashes. This function gets blood pressure
readings, left parentheses, systolic, forward slash, diastolic, right
parentheses. 
Line 4: 2 forward slashes. and outputs a health message based on
their values. 
Line 5: 2 forward slashes. on file health Profile. 
Line 6: left brace. 
Line 7, indented once: 2 forward slashes. Declare the blood
pressure readings. 
Line 8, indented once: int systolic, semicolon. 
Line 9, indented once: int diastolic, semicolon. 
Line 10, indented once: 2 forward slashes. Enter the patient’s blood
pressure readings. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Enter the systolic blood pressure reading for, blank space, double
quotes. 
Line 12, indented twice: 2 left angled brackets, name, 2 left angled
brackets, double quotes, colon, blank space, double quotes,
semicolon. 
Line 13, indented once: c in, 2 right angled brackets, systolic,
semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter the diastolic blood pressure reading for, blank space, double
quotes. 

Line 15, indented twice: 2 left angled brackets, name, 2 left angled
brackets, double quotes, colon, blank space, double quotes,
semicolon. 
Line 16, indented once: c in, 2 right angled brackets, diastolic,
semicolon. 
Line 17, indented once: 2 forward slashes. Output interpretation of
systolic reading. 
Line 18, indented once: health Profile, 2 left angled brackets, double
quotes, Blood Pressure Profile, blank space, double quotes, 2 left
angled brackets, end l. 
Line 19, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, back slash, Systolic, colon, blank space,
double quotes, 2 left angled brackets, systolic. 
Line 20, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, Diastolic, colon, blank space, double quotes,
2 left angled brackets, diastolic, 2 left angled brackets, end l,
semicolon. 
Line 21, indented once: if, left parentheses, systolic less than 120,
right parentheses. 
Line 22, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic reading is optimal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 23, indented once: else if, left parentheses, systolic less than
130, right parentheses. 
Line 24, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic reading is normal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 25, indented once: else if, left parentheses, systolic less than
140, right parentheses. 
Line 26, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic reading is high normal, double
quotes. 
Line 27, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 28, indented once: else if, left parentheses, systolic less than
160, right parentheses. 
Line 29, indented twice: health Profile, 2 left angled brackets. 
Line 30, indented thrice: double quotes, blank spaces, Systolic
indicates hypertension Stage 1, double quotes, 2 left angled

brackets, end l, semicolon. 
Line 31, indented once: else if, left parentheses, systolic less than
180, right parentheses. 
Line 32, indented twice: health Profile, 2 left angled brackets. 
Line 33, indented thrice: double quotes, blank spaces, Systolic
indicates hypertension Stage 2, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 34, indented once: else. 
Line 35, indented twice: health Profile, 2 left angled brackets. 
Line 36, indented thrice: double quotes, blank spaces, Systolic
indicates hypertension Stage 3, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 37, indented once: 2 forward slashes. Output interpretation of
diastolic reading. 
Line 38, indented once: if, left parentheses, diastolic less than 80,
right parentheses. 
Line 39, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is optimal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 40, indented once: else if, left parentheses, diastolic less than
85, right parentheses. 
Line 41, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is normal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 42, indented once: else if, left parentheses, diastolic less than
90, right parentheses. 
Line 43, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is high normal, double
quotes. 
Line 44, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 45, indented once: else if, left parentheses, diastolic, less than,
100, right parentheses. 
Line 46, indented twice: health Profile, 2 left angled brackets. 
Line 47, indented thrice: double quotes, blank spaces, Diastolic
indicates hypertension Stage 1, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 48, indented once: else if, left parentheses, diastolic less than
110, right parentheses.

Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: end l, else. 
Line 1, indented twice: health Profile, 2 left angled brackets. 
Line 2, indented thrice: double quotes, blank spaces, Diastolic
indicates hypertension Stage 2, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 3, indented once: else. 
Line 4, indented twice: health Profile, 2 left angled brackets. 
Line 5, indented thrice: double quotes, blank spaces, Diastolic
indicates hypertension Stage 3, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6: right brace.
Back to Figure
Line 1: Enter the patient’s first name, colon, Stephen. 
Line 2: Enter the patient’s last name, colon, Stark. 
Line 3: Enter the patient’s middle initial, colon, uppercase s. 
Line 4: Enter H D L for Stephen, blank space, uppercase s, period,
blank space, Stark, colon, 60. 
Line 5: Enter L D L for Stephen, blank space, uppercase s, period,
blank space, Stark, colon, 120. 
Line 6: Enter the weight in pounds for Stephen, blank space,
uppercase s, period, blank space, Stark, colon, 180. 
Line 7: Enter the height in inches for Stephen, blank space,
uppercase s, period, blank space, Stark, colon, 72. 
Line 8: Enter the systolic blood pressure reading for Stephen, blank
space, uppercase s, period, blank space, Start, colon, 130. 
Line 9: Enter the diastolic blood pressure reading for Stephen, blank
space, uppercase s, period, blank space, Stark, colon, 80.
Back to Figure
In all the lines, the entries following the colon are shaded.
Back to Figure

Line 1: Patient’s name Steven, blank space, uppercase s, period,
blank space, Stark. 
Line 2: Cholesterol Profile. 
Line 3, indented once: H D L, colon, 60, blank spaces, L D L, colon,
120. 
Line 4, indented once: Ratio, colon, 0.5000. 
Line 5, indented once: H D L is excellent. 
Line 6, indented once: L D L is near optimal. 
Line 7, indented once: Ratio of H D L to L D L is good. 
Line 8: Body Mass Index Profile. 
Line 9, indented once: weight, colon, 180, blank spaces, Height,
colon, 72. 
Line 10, indented once: Body mass index is 24. 
Line 11, indented once: Interpretation of B M I. 
Line 12, indented once: Normal. 
Line 13: Blood Pressure Profile. 
Line 14, indented once: Systolic, colon, 130, blank spaces, Diastolic,
colon, 80. 
Line 15, indented once: Systolic reading is high normal. 
Line 16, indented once: Diastolic reading is normal.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: string, c out, end l, and return. 
Line 1: string Name, left parentheses, right parentheses. 
Line 2: 2 forward slashes. stub for Name function in the Profile
program. 
Line 3: left brace. 
Line 4, indented once: c out, 2 left angled brackets, double quotes,
Name was called here, period, blank space, Returning, back slash,
double quotes, John, blank space, uppercase j, period, blank space,
Smith, back slash, double quotes, period, double quotes. 
Line 5, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 6, indented once: return double quotes, John, blank space,
uppercase j, period, blank space, Smith, double quotes, semicolon. 
Line 7: right brace.

Back to Figure
The table has 4 columns labeled Reason for Test, Input, Expected
Output, and Observed. The row entries are as follows.
Row 1. Reason for Test: H D L too low. Input: 39, comma, 99.
Expected output: H D L is too low, L D L is optimal, Ratio of H D L to
L D L is good. Observed: blank.
Row 2. Reason for Test: H D L is okay. Input: 59, comma, 99.
Expected Output: H D L is okay, L D L is optimal, Ratio of H D L to L
D L is good. Observed: blank.
Row 3. Reason for test: H D L is excellent. Input: 69, comma, 99.
Expected Output: H D L is excellent, L D L is optimal, Ratio of H D L
to L D L is good. Observed: blank.
Row 4. Reason for test: L D L is optimal. Input: 39, comma, 99.
Expected Output: H D L is too low, L D L is optimal, Ratio of H D L
to L D L is good. Observed: blank.
Row 5. Reason for test: L D L is near optimal. Input: 39, comma,
129. Expected Output: H D L is too low, L D L is near optimal, Ratio
of H D L to L D L is good. Observed: blank.
Row 6. Reason for test: L D L is borderline. Input: 39, comma, 159.
Expected Output: H D L is too low, L D L is borderline high, Ratio of
H D L to L D L is not good. Observed: blank.
Row 7. Reason for test: L D L is high. Input: 39, comma, 189.
Expected Output: H D L is too low, L D L is high, Ratio of H D L to L
D L is not good. Observed: blank.
Row 8. Reason for test: L D L is very high. Input: 39, comma, 195.
Expected Output: H D L is too low, L D L is very high, Ratio of H D L
to L D L is not good. Observed: blank.
Back to Figure
Program code. The words in the keywords, variable names, and
function name are merged. The code contains the following
keywords: include, i o stream, f stream, i o manip, using, name
space, s t d, void, o f stream, string, int, main, for, return, c out, c in,
float, end l, if, fixed. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program provides an environment for
testing the. 

Line 3: 2 forward slashes. Evaluate Cholesterol function in isolation
from program profile. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: Hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: Hash include, left angled bracket, f stream, right angled
bracket. 
Line 7: Hash include, left angled bracket, i o manip, right angled
bracket. 
Line 8: using name space, s t d, semicolon. 
Line 9: void Evaluate Cholesterol, left parentheses, o f stream
ampersand, comma, string, right parentheses, semicolon. 
Line 10: int main, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12, indented once: o f stream health Profile, semicolon. 
Line 13, indented once: health Profile dot open, left parentheses,
double quotes, Profile, double quotes, right parentheses, semicolon. 
Line 14, indented once: string name equals double quotes, John,
blank space, uppercase j, dot, blank space, Smith, double quotes,
semicolon. 
Line 15, indented once: for, left parentheses, int test equals 1,
semicolon, test less than or equal to 8, semicolon, test plus plus,
right parentheses. 
Line 17, indented twice: Evaluate Cholesterol, left parentheses,
health Profile, comma, name, right parentheses, semicolon. 
Line 18, indented once: health Profile dot close, left parentheses,
right parentheses, semicolon. 
Line 19, indented once: return 0, semicolon. 
Line 20: right brace. 
Line 21: 2 forward slashes followed by asterisks till the end of the
line. 
Line 22: void Evaluate Cholesterol, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 23: 2 forward slashes. This function inputs H D L, left
parentheses, good cholesterol, right parentheses, and L D L, left
parentheses, bad. 
Line 24: 2 forward slashes. cholesterol, right parentheses, and
outputs a health message based on their. 
Line 25: 2 forward slashes. values on file health Profile. 

Line 26: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 27: left brace. 
Line 28, indented once: int H D L, semicolon. 
Line 29, indented once: int L D L, semicolon. 
Line 30, indented once: 2 forward slashes. Prompt for and enter H D
L and L D L. 
Line 31, indented once: c out, 2 left angled brackets, double quotes,
Enter H D L for, blank space, double quotes, 2 left angled brackets,
name, 2 left angled brackets, double quotes, colon, blank space,
double quotes, semicolon. 
Line 32, indented once: c in, 2 right angled brackets, H D L,
semicolon. 
Line 33, indented once: c out, 2 left angled brackets, double quotes,
Enter L D L for, blank space, double quotes, 2 left angled brackets,
name, 2 left angled brackets, double quotes, colon, blank space,
double quotes, semicolon. 
Line 34, indented once: c in, 2 right angled brackets, L D L,
semicolon. 
Line 35, indented once: float ratio equals static underscore cast, left
angled bracket, float, right angled bracket, left parentheses, H D L,
right parentheses, forward slash. 
Line 36, indented multiple times: static underscore cast, left angled
bracket, float, right angled bracket, left parentheses, L D L, right
parentheses, semicolon. 2 forward slashes. Calculate H D L to L D L
ratio. 
Line 37, indented once: health Profile, 2 left angled brackets, double
quotes, Cholesterol Profile, blank space, double quotes, 2 left angled
brackets, end l. 
Line 38, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, H D L, colon, blank space, double quotes, 2
left angled brackets, H D L, 2 left angled brackets, double quotes,
blank spaces, L D L, colon, blank space, double quotes, 2 left
angled brackets, L D L, 2 left angled brackets, end l. 
Line 39, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, Ratio, colon, blank space, double quotes, 2
left angled brackets, fixed, 2 left angled brackets, set precision, left
parentheses, 4, right parentheses. 
Line 40, indented multiple times: 2 left angled brackets, ratio, 2 left

angled brackets, end l, semicolon. 
Line 41, indented once: 2 forward slashes. Output message based
on H D L value. 
Line 42, indented once: if, left parentheses, H D L less than 40, right
parentheses. 
Line 43, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is too low, double quotes, 2 left angled
brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The code contains the following keywords: else, if, end
l. 
Line 1, indented once: else if, left parentheses, H D L less than 60,
right parentheses. 
Line 2, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is okay, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 3, indented once: else. 
Line 4, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is excellent, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 5, indented once: 2 forward slashes, Output message based on
L D L value. 
Line 6, indented once: if, left parentheses, L D L less than 100, right
parentheses. 
Line 7, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is optimal, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 8, indented once: else if, left parentheses, L D L less than 130,
right parentheses. 
Line 9, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is near optimal, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 10, indented once: else if, left parentheses, L D L less than
160, right parentheses. 
Line 11, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is borderline high, double quotes, 2 left

angled brackets, end l, semicolon. 
Line 12, indented once: else if, left parentheses, L D L less than
190, right parentheses. 
Line 13, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is high, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 14, indented once: else. 
Line 15, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is very high, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 16, indented once: if, left parentheses, ratio greater than 0.3,
right parentheses. 
Line 17, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is good, double
quotes. 
Line 18, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 19, indented once: else. 
Line 20, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is not good, double
quotes. 
Line 21, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 22: right brace.
Back to Figure
Line 1: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 2: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 99. 
Line 3: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 59. 
Line 4: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 99. 
Line 5: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 69. 
Line 6: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 99. 

Line 7: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 8: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 99. 
Line 9: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 10: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 129. 
Line 11: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 12: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 159. 
Line 13: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 14: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 189. 
Line 15: Enter H D L for John, blank space, uppercase j, dot, Smith,
colon, 39. 
Line 16: Enter L D L for John, blank space, uppercase j, dot, Smith,
colon, 195. Line 1: Cholesterol Profile. 
Line 2, indented once: H D L, colon, 39, blank spaces, L D L, colon,
99. 
Line 3, indented once: Ratio, colon, 0.3939. 
Line 4, indented once: H D L is too low. 
Line 5, indented once: L D L is optimal. 
Line 6, indented once: Ratio of H D L to L D L is good. 
Line 7: Cholesterol Profile. 
Line 8, indented once: H D L, colon, 59, blank spaces, L D L, colon,
99. 
Line 9, indented once: Ratio, colon, 0.5960. 
Line 10, indented once: H D L is okay. 
Line 11, indented once: L D L is optimal. 
Line 12, indented once: Ratio of H D L to L D L is good. 
Line 13: Cholesterol Profile. 
Line 14, indented once: H D L, colon, 69, blank spaces, L D L,
colon, 99. 
Line 15, indented once: Ratio, colon, 0.6970. 
Line 16, indented once: H D L is excellent. 
Line 17, indented once: L D L is optimal. 

Line 18, indented once: Ratio of H D L to L D L is good. 
Line 19: Cholesterol Profile. 
Line 20, indented once: H D L, colon, 39, blank spaces, L D L,
colon, 99. 
Line 21, indented once: Ratio, colon, 0.3939. 
Line 22, indented once: H D L is too low. 
Line 23, indented once: L D L is optimal. 
Line 24, indented once: Ratio of H D L to L D L is good. 
Line 25: Cholesterol Profile. 
Line 26, indented once: H D L, colon, 39, blank spaces, L D L,
colon, 129. 
Line 27, indented once: Ratio, colon, 0.3023. 
Line 28, indented once: H D L is too low. 
Line 29, indented once: L D L is near optimal. 
Line 30, indented once: Ratio of H D L to L D L is good. 
Line 31: Cholesterol profile. 
Line 32, indented once: H D L, colon, 39, blank spaces, L D L,
colon, 159. 
Line 33, indented once: Ratio, colon, 0.2453. 
Line 34, indented once: H D L is too low. 
Line 35, indented once: L D L is borderline high. 
Line 36, indented once: Ratio of H D L to L D L is not good. 
Line 37: Cholesterol Profile. 
Line 38, indented once: H D L, colon, 39, blank spaces, L D L,
colon, 189. 
Line 39, indented once: Ratio, colon, 0.2063. 
Line 40, indented once: H D L is too low. 
Line 41, indented once: L D L is high. 
Line 42, indented once: Ratio of H D L to L D L is not good. 
Line 43: Cholesterol Profile. 
Line 44, indented once: H D L, colon, 39, blank spaces, L D L,
colon, 195. 
Line 45, indented once: Ratio, colon, 0.2000. 
Line 46, indented once: H D L is too low. 
Line 47, indented once: L D L is very high. 
Line 48, indented once: Ratio of H D L to L D L is not good.
Back to Figure

Program code. The words in the keywords, and variable names are
merged. The code contains the following keywords: string, char, c
out, c in, return. 
Line 1: string Name, left parentheses, right parentheses. 
Line 2: 2 forward slashes. This function inputs a name and returns it
in first, comma. 
Line 3: 2 forward slashes. middle initial, comma, and last order. 
Line 4: left brace. 
Line 5, indented once: 2 forward slashes. Declare the patient’s
name. 
Line 6, indented once: string first Name, semicolon. 
Line 7, indented once: string last Name, semicolon. 
Line 8, indented once: char middle Initial, semicolon. 
Line 9, indented once: 2 forward slashes. Prompt for and enter the
patient’s name. 
Line 10, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s first name, colon, blank space, double quotes,
semicolon. 
Line 11, indented once: c in, 2 right angled brackets, first Name,
semicolon. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s last name, colon, blank space, double quotes,
semicolon. 
Line 13, indented once: c in, 2 right angled brackets, last Name,
semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter the patient’s middle initial, colon, blank space, double quotes,
semicolon. 
Line 15, indented once: c in, 2 right angled brackets, middle Initial,
semicolon. 
Line 16, indented once: return first Name, plus, single quote, blank
space, single quote, plus, middle Initial, plus, double quotes, dot,
blank space, double quotes, plus, last Name, semicolon. 
Line 17: right brace.
Back to Figure
Program code. The code contains the keyword string. 
Line 1: string Name, left parentheses, right parentheses. 

Line 2: 2 forward slashes. This function inputs a name and returns it
in first, comma. 
Line 3: 2 forward slashes. middle initial, comma, and last order. 
Line 4: left brace.
Back to Figure
Program code. The code contains the keyword string. The words in
the variable names, and function names are merged. 
Line 1, indented once: 2 forward slashes. Declare the patient’s
name. 
Line 2, indented once: string first Name, semicolon. 
Line 3, indented once: string last Name, semicolon. 
Line 4, indented once: string middle Initial, semicolon. 
Line 5: blank. 
Line 6, indented once: 2 forward slashes. Prompt for and enter the
patient’s name. 
Line 7, indented once: Text Dialog, blank spaces, first Name Dialog,
left parentheses, double quotes, Enter the patient’s first name,
colon, blank space, double quotes, right parentheses, semicolon. 
Line 8, indented once: Text Dialog, blank space, last Name Dialog,
left parentheses, double quotes, Enter the patient’s last name,
colon, blank space, double quotes, right parentheses, semicolon. 
Line 9, indented once: Text dialog, blank space, middle Initial Dialog,
left parentheses, double quotes, Enter the patient’s middle initial,
colon, blank space, double quotes, right parentheses, semicolon. 
Line 10, indented once: first Name equals first Name Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 11, indented once: last Name equals last Name Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 12, indented once: middle Initial equals middle Initial Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 13, indented once: return first Name plus, single quote, blank
space, single quote, plus, middle Initial dot at, left parentheses, 0,
right parentheses, plus, double quotes, dot, blank space, double
quotes, plus, last Name, semicolon. 
Line 14: right brace.
Back to Figure

The text label within the window is, Enter the patient’s first name,
colon. The cursor is within the text box below the text label. The
buttons at the bottom end of the window are labeled Cancel and O
K.
Back to Figure
Program code. The words in the function names and the variable
names are merged. 
Line 1: Int Dialog, blank space, h d l Dialog, left parentheses, double
quotes, Enter H D L for, blank space, double quotes, plus, name,
plus, double quotes, colon, double quotes, right parentheses,
semicolon. 
Line 2: Int Dialog, blank space, l d l Dialog, left parentheses, double
quotes, Enter L D L for, blank space, double quotes, plus, name,
plus, double quotes, colon, double quotes, right parentheses,
semicolon. 
Line 3: H D L equals h d l Dialog, dot, display, left parentheses, right
parentheses, semicolon. 
Line 4: L D L equals l d l Dialog, dot, display, left parentheses, right
parentheses, semicolon.
Back to Figure
Program code. The words in the function names and the variable
names are merged. 
Line 1: Int Dialog, blank space, weight Dialog, left parentheses,
double quotes, Enter the weight in pounds for, blank space, double
quotes, plus, name, plus, double quotes, colon, blank space, double
quotes, right parentheses, semicolon. 
Line 2: Int Dialog, blank space, height Dialog, left parentheses,
double quotes, Enter the height in inches for, blank space, double
quotes, plus, name, plus, double quotes, colon, blank space, double
quotes, right parentheses, semicolon. 
Line 3: pounds equals weight Dialog dot display, left parentheses,
right parentheses, semicolon. 
Line 4: inches equals height Dialog dot display, left parentheses,
right parentheses, semicolon.

Back to Figure
The text label within the window is, Enter H D L for Tim D. Richards,
colon. The value within the text box below the text label is 39. The
text box has increment and decrement buttons on its right. The
buttons at the bottom end of the window are labeled Cancel and O
K.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: include, f stream, i o mainip, i o
stream. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Profile G U I program. 
Line 3: 2 forward slashes. This program inputs a name, comma,
weight, comma, height, comma, blood pressure. 
Line 4: 2 forward slashes. readings, comma, and cholesterol values,
period. Appropriate health messages. 
Line 5: 2 forward slashes. are written for each of the input values on
file health Profile. 
Line 6: 2 forward slashes followed by asterisks till the end of the line.
Line 7: hash include, left angled bracket, f stream, right angled
bracket. 
Line 8: hash include, left angled bracket, i o manip, right angled
bracket. 
Line 9: hash include, left angled bracket, i o stream, right angled
bracket.
Back to Figure
Program code. The words in the keywords, function names, and
variable names are merged. The code contains the following
keywords: include, string, using, name space, s t d, void, int, main, o
f stream, end l, return. 
Line 1: hash include, left angled bracket, string, right angled bracket.
Line 2: hash include, double quotes, dialog dot h, double quotes. 
Line 3: using name space s t d, semicolon. 
Line 4: 2 forward slashes. Function prototypes. 

Line 5: string Name, left parentheses, right parentheses, semicolon. 
Line 6: 2 forward slashes. This function inputs a name and returns it
in first, comma. 
Line 7: 2 forward slashes. middle initial, comma, and last order. 
Line 8: void Evaluate Cholesterol, left parentheses, o f stream,
ampersand, health Profile, comma, string name, right parentheses,
semicolon. 
Line 9: 2 forward slashes. This function inputs H D L, left
parentheses, good cholesterol, right parentheses, and L D L, left
parentheses, bad. 
Line 10: 2 forward slashes. cholesterol, right parentheses, and
outputs a health message based on their. 
Line 11: 2 forward slashes. values on file health Profile. 
Line 12: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 13: void Evaluate B M I, left parentheses, o f stream
ampersand, health Profile, comma, string name, right parentheses,
semicolon. 
Line 14: 2 forward slashes. This function inputs weight in pounds
and height in inches and. 
Line 15: 2 forward slashes. calculates the body mass index, left
parentheses, B M I, right parentheses, then outputs a health
message. 
Line 16: 2 forward slashes. based on the B M I, period. Input in
English weights. 
Line 17: 2 forward slashes. Pre, colon, Input file has been
successfully opened. 
Line 18: void Evaluate Blood Pressure, left parentheses, o f stream,
ampersand, health Profile, comma, string name, right parentheses,
semicolon. 
Line 19: 2 forward slashes. This function gets blood pressure
readings, left parentheses, systolic, forward slash, diastolic, right
parentheses. 
Line 20: 2 forward slashes. and outputs a health message based on
their values. 
Line 21: 2 forward slashes. on file health Profile, period. 
Line 22: Pre, colon, Input file has been successfully opened. 
Line 23: int main, left parentheses, right parentheses. 
Line 24: left brace. 

Line 25, indented once: 2 forward slashes. Declare and open the
output file. 
Line 26, indented once: o f stream health Profile, semicolon. 
Line 27, indented once: health Profile dot open, left parentheses,
double quotes, Profile, double quotes, right parentheses, semicolon. 
Line 28, indented once: string name, semicolon. 
Line 29, indented once: name equals Name, left parentheses, right
parentheses, semicolon. 
Line 30, indented once: 2 forward slashes. Write patient’s name on
output file. 
Line 31, indented once: health Profile, 2 left angled brackets, double
quotes, Patient’s name, blank space, double quotes, 2 left angled
brackets, name, 2 left angled brackets, end l, semicolon. 
Line 32, indented once: 2 forward slashes. Evaluate the patient’s
statistics. 
Line 33, indented once: Evaluate Cholesterol, left parentheses,
health Profile, comma, name, right parentheses, semicolon. 
Line 34, indented once: Evaluate B M I, left parentheses, health
Profile, comma, name, right parentheses, semicolon. 
Line 35, indented once: Evaluate Blood Pressure, left parentheses,
health Profile, comma, name, right parentheses, semicolon. 
Line 36, indented once: health Profile, 2 left angled brackets, end l,
semicolon. 
Line 37, indented once: blank space. 
Line 38, indented once: health Profile dot close, left parentheses,
right parentheses, semicolon. 
Line 39, indented once: return 0, semicolon. 
Line 40: left brace.
Back to Figure
Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords: string, return, void, o f stream, int, float, end l, if, else. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: string Name, left parentheses, right parentheses. 
Line 3: 2 forward slashes. This function inputs a name and returns it
in first, comma. 
Line 4: 2 forward slashes. middle initial, comma, and last order. 

Line 5: left brace. 
Line 6, indented once: 2 forward slashes. Declare the patient’s
name. 
Line 7, indented once: string first Name, semicolon. 
Line 8, indented once: string last Name, semicolon. 
Line 9, indented once: string middle Initial, semicolon. 
Line 10, indented once: 2 forward slashes. Prompt for and enter the
patient’s name. 
Line 11, indented once: Text Dialog first Name Dialog, left
parentheses, double quotes, Enter the patient’s first name, colon,
blank space, double quotes, right parentheses, semicolon. 
Line 12, indented once: Text Dialog last Name Dialog, left
parentheses, double quotes, Enter the patient’s last name, colon,
blank space, double quotes, right parentheses, semicolon. 
Line 13, indented once: Text Dialog middle Initial Dialog, left
parentheses, double quotes, Enter the patient’s middle initial, colon,
blank space, double quotes, right brace, semicolon. 
Line 14, indented once: first Name equals first Name Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 15, indented once: last Name equals last Name Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 16, indented once: middle Initial equals middle Initial Dialog dot
display, left parentheses, right parentheses, semicolon. 
Line 17, indented once: return first Name plus single quote, blank
space, single quote, plus middle Initial dot at, left parentheses, 0,
right parentheses, plus, double quotes, dot, blank space, double
quotes, plus, last Name, semicolon. 
Line 18: right brace. 
Line 19: 2 forward slashes followed by asterisks till the end of the
line. 
Line 20: void Evaluate Cholesterol, left parentheses, o f stream
ampersand, health Profile, comma, string name, right parentheses. 
Line 21: 2 forward slashes. This function inputs H D L, left
parentheses, good cholesterol, right parentheses, and L D L, left
parentheses, bad. 
Line 22: 2 forward slashes. cholesterol, right parentheses, and
outputs a health message based on their. 
Line 23: 2 forward slashes. values on file health Profile.
Line 24: left brace. 

Line 25, indented once: int H D L, semicolon. 
Line 26, indented once: int L D L, semicolon. 
Line 27, indented once: blank. 
Line 28, indented once: 2 forward slashes. Prompt for and enter H D
L and L D L. 
Line 29, indented once: Int Dialog h d l Dialog, left parentheses,
double quotes, Enter H D L for, blank space, double quotes, plus,
name, plus, double quotes, colon, double quotes, right parentheses,
semicolon. 
Line 30, indented once: Int Dialog l d l Dialog, left parentheses,
double quotes, Enter L D L for, blank space, double quotes, plus,
name, plus, double quotes, colon, double quotes, right parentheses,
semicolon. 
Line 31, indented once: H D L equals h d l Dialog dot display, left
parentheses, right parentheses, semicolon. 
Line 32, indented once: L D L equals l d l Dialog dot display, left
parentheses, right parentheses, semicolon. 
Line 33, indented once: blank. 
Line 34, indented once: float ratio equals H D L, forward slash, L D
L, semicolon. 
Line 35, indented once: blank. 
Line 36, indented once: health Profile, 2 left angled brackets, double
quotes, Cholesterol Profile, blank space, double quotes, 2 left angled
brackets, end l. 
Line 37, indented multiple times: 2 left angled brackets, double
quotes, blank space, H D L, colon, blank space, double quotes, 2
left angled brackets, H D L, 2 left angled brackets, double quotes,
blank space, L D L, colon, blank space, double quotes, 2 left angled
brackets, L D L, 2 left angled brackets, end l. 
Line 38, indented multiple times: 2 left angled brackets, double
quotes, blank space, Ratio, colon, blank space, double quotes, 2 left
angled brackets, fixed, 2 left angled brackets, set precision, left
precision, left parentheses, 4, right parentheses, 2 left angled
brackets, ratio. 
Line 39, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 40, indented once: 2 forward slashes. Output message based
on H D L value. 
Line 41, indented once: if, left parentheses, H D L less than 40, right

parentheses. 
Line 42, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is too low, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 43, indented once: else if, left parentheses, H D L less than 60,
right parentheses. 
Line 44, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is okay, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 45, indented once: else. 
Line 46, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, H D L is excellent, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 47, indented once: 2 forward slashes. output message based
on L D L value. 
Lines 9, 11 to 16, and 28 to 32 are shaded.
Back to Figure
Program code. The words in the variable names, function names,
and keywords are merged. The code contains the following
keywords: if, else, end l, void, o f stream, string, const, int.
Line 1, indented once: if, left parentheses, L D L less than 100, right
parentheses. 
Line 2, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is optimal, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 3, indented once: else if, left parentheses, L D L less than 130,
right parentheses. 
Line 4, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is near optimal, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 5, indented once: else if, left parentheses, L D L less than 160,
right parentheses. 
Line 6, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is borderline high, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 7, indented once: else if, left parentheses, L D L less than 190,
right parentheses. 

Line 8, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is high, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 9, indented once: else. 
Line 10, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, L D L is very high, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 11, indented once: if, left parentheses, ratio greater than 0.3,
right parentheses. 
Line 12, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is good, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 13, indented once: else. 
Line 14, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Ratio of H D L to L D L is not good, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 15: right brace. 
Line 16: 2 forward slashes followed by asterisks till the end of the
line. 
Line 17: void Evaluate B M I, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 18: 2 forward slashes. This function inputs weight in pounds
and height in inches and. 
Line 19: 2 forward slashes. calculates the body mass index. Input in
English weights. 
Line 20: left brace. 
Line 21, indented once: const int B M I, underscore, CONSTANT
equals 703, semicolon. 2 forward slashes. Constant in English
formula. 
Line 22, indented once: int pounds, semicolon. 
Line 23, indented once: int inches, semicolon. 
Line 24, indented once: 2 forward slashes. Enter the patient’s weight
and height. 
Line 25, indented once: Int Dialog weight Dialog, left parentheses,
double quotes, Enter the weight in pounds for, blank space, double
quotes, plus, name, plus, double quotes, colon, blank space, double
quotes, right parentheses, semicolon. 
Line 26, indented once: Int Dialog height Dialog, left parentheses,
double quotes, Enter the height in inches for, blank space, double

quotes, plus, name, plus, double quotes, colon, blank space, double
quotes, right parentheses, semicolon. 
Line 27, indented once: pounds equals weight Dialog dot display, left
parentheses, right parentheses, semicolon. 
Line 28, indented once: inches equals height Dialog dot display, left
parentheses, right parentheses, semicolon. 
Line 29, indented once: int body Mass Index equals pounds asterisk
B M I, underscore, CONSTANT, forward slash, left parentheses,
inches asterisk inches, right parentheses, semicolon. 
Line 30, indented once: health Profile, 2 left angled brackets, blank
spaces, double quotes, Body Mass Index Profile, double quotes, 2
left angled brackets, end l. 
Line 31, indented multiple times: 2 left angled brackets, blank
spaces, double quotes, blank spaces, Weight, colon, blank space,
double quotes, 2 left angled brackets, pounds, 2 left angled
brackets, double quotes, blank space, Height, colon, blank space,
double quotes, 2 left angled brackets. 
Line 32, indented multiple times: inches. 
Line 33, indented multiple times: end l, semicolon. 
Line 34, indented once: 2 forward slashes. Output body Mass Index.
Line 35, indented once: health Profile, 2 left angled brackets, blank
spaces, double quotes, Body mass index is, blank space, double
quotes, 2 left angled brackets, body Mass Index, 2 left angled
brackets, end l, semicolon. 
Line 36, indented once: health Profile, 2 left angled brackets, blank
spaces, double quotes, blank spaces, Interpretation of B M I, blank
space, double quotes, 2 left angled brackets, end l, semicolon. 
Line 37, indented once: Output interpretation of B M I. 
Line 38, indented once: if, left parentheses, body Mass Index less
than 20, right parentheses. 
Line 39, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Underweight, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 40, indented once: else if, left parentheses, body Mass Index,
less than or equal to 25, right parentheses. 
Line 41, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Normal, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 42, indented once: else if, left parentheses, body Mass Index,

less than or equal to 30, right parentheses. 
Line 43, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Overweight, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 44, indented once: else. 
Line 45, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Obese, double quotes, 2 left angled brackets,
end l, semicolon. Lines 25 to 28 are shaded.
Back to Figure
Program code. The words in the keywords, function names and
variable names are merged. The code uses the following keywords:
void, o f stream, string, int, end l, if, else.
Line 1: right brace. 
Line 2: 2 forward slashes followed by asterisks till the end of the line.
Line 3: void Evaluate Blood Pressure, left parentheses, o f stream
ampersand health Profile, comma, string name, right parentheses. 
Line 4: 2 forward slashes. This function gets blood pressure
readings, left parentheses, systolic, forward slash, diastolic, right
parentheses. 
Line 5: 2 forward slashes. and outputs a health message based on
their values. 
Line 6: 2 forward slashes. on file health Profile. 
Line 7: left brace. 
Line 8, indented once: 2 forward slashes. Declare the blood
pressure readings. 
Line 9, indented once: int systolic, semicolon. 
Line 10, indented once: int diastolic, semicolon. 
Line 11, indented once: 2 forward slashes. Enter the patient’s blood
pressure readings. 
Line 12, indented once: Int dialog systolic Dialog. 
Line 13, indented twice: left parentheses, double quotes, Enter the
systolic blood pressure reading for, blank space, double quotes,
plus, name, plus, double quotes, colon, blank space, double quotes,
right parentheses, semicolon. 
Line 14, indented once: Int Dialog diastolic Dialog. 
Line 15, indented twice: left parentheses, double quotes, Enter the
diastolic blood pressure reading for, blank space, double quotes,

plus, name, plus, double quotes, colon, blank space, double quotes,
right parentheses, semicolon. 
Line 16, indented once: systolic equals systolic Dialog dot display,
left parentheses, right parentheses, semicolon. 
Line 17, indented once: diastolic equals diastolic Dialog dot display,
left parentheses, right parentheses, semicolon. 
Line 18, indented once: 2 forward slashes. output interpretation of
systolic reading. 
Line 19, indented once: health Profile, 2 left angled brackets, double
quotes, Blood pressure Profile, blank space, double quotes, 2 left
angled brackets, end l. 
Line 20, indented multiple times: 2 left angled brackets, double
quotes, blank spaces, Systolic, colon, blank space, double quotes, 2
left angled brackets, systolic, 2 left angled brackets, double quotes,
blank spaces, Diastolic, colon, blank space, double quotes. 
Line 21, indented multiple times: 2 left angled brackets, diastolic. 
Line 22, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 23, indented once: if, left parentheses, systolic less than 120,
right parentheses. 
Line 24, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic reading is optimal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 25, indented once: else if, left parentheses, systolic less than
130, right parentheses. 
Line 26, indented twice: health Profile, 2 left angled brackets, double
quotes, blank space, Systolic reading is normal, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 27, indented once: else if, left parentheses, systolic less than
140, right parentheses. 
Line 28, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic reading is high normal, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 29, indented once: else if, left parentheses, systolic less than
140, right parentheses. 
Line 30, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic indicates hypertension stage 1,
double quotes. 
Line 31, indented multiple times: 2 left angled brackets, end l,

semicolon. 
Line 32, indented once: else if, left parentheses, systolic less than
180, right parentheses. 
Line 33, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic indicates hypertension Stage 2,
double quotes. 
Line 34, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 35, indented once: else. 
Line 36, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Systolic indicates hypertension Stage 3,
double quotes. 
Line 47, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 48, indented once: 2 forward slashes. Output interpretation of
diastolic reading. 
Line 49, indented once: if, left parentheses, diastolic, less than, 80,
right parentheses. 
Line 50, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is optimal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 51, indented once: else if, left parentheses, diastolic less than
85, right parentheses. 
Line 52, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is normal, double quotes, 2
left angled brackets, end l, semicolon. 
Line 53, indented once: else if, left parentheses, diastolic less than
90, right parentheses. 
Line 54, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic reading is high normal, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 55, indented once: else if, left parentheses, diastolic less than
100, right parentheses. 
Line 56, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic indicates hypertension Stage 1,
double quotes. 
Line 57, indented multiple times, 2 left angled brackets, end l,
semicolon. 
Lines 12 to 17 are shaded.

Back to Figure
Program code. The words in the variable names and keywords are
merged. The code contains the following keywords: else, if, end l. 
Line 1, indented once: else if, left parentheses, diastolic less than
110, right parentheses. 
Line 2, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic indicates hypertension Stage 2,
double quotes. 
Line 3, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 4, indented once: else. 
Line 5, indented twice: health Profile, 2 left angled brackets, double
quotes, blank spaces, Diastolic indicates hypertension Stage 3,
double quotes. 
Line 6, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 7: right brace.
Back to Figure
Program code. The words in the function names, and variable
names are merged. The code contains the following keywords: int,
if, return, else. 
Line 1: int Exam Prep, left parentheses, int param 1, comma, int
ampersand param 2, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, param 2 equals param 1,
right parentheses. 
Line 4, indented twice: return param 2, semicolon. 
Line 5, indented once: else if, left parentheses, param 2 greater
than param 1, right parentheses. 
Line 6, indented twice: return param 1, semicolon. 
Line 7, indented once: else. 
Line 8, indented twice: return param 1 asterisk param 2, semicolon. 
Line 9: right brace.
Back to Figure

Program code. The words in the function names, and keywords are
merged. The code contains the following keywords: include, i o
stream, using, name space, s t d, string, int, bool, int, main, c out, c
in, if, return. 
Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: string a, semicolon. 
Line 4: int w, semicolon. 
Line 5: bool Get Yes Or No, left parentheses, right parentheses,
semicolon. 
Line 6: int main, left parentheses, right parentheses. 
Line 7: left brace. 
Line 8, indented once: c out, 2 left angled brackets, double quotes,
Enter name, colon, double quotes, semicolon. 
Line 9, indented once: c in, 2 right angled brackets, a, semicolon. 
Line 10, indented once: w equals 0, semicolon. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Is there a weight value, question mark, double quotes, semicolon. 
Line 12, indented once: if, left parentheses, Get Yes Or No, left
parentheses, right parentheses, right parentheses, semicolon. 
Line 13, indented once: left brace. 
Line 14, indented twice: c out, 2 left angled brackets, double quotes,
Enter weight, colon, double quotes, semicolon. 
Line 15, indented twice: c in, 2 right angled brackets, w, semicolon. 
Line 16, indented once: right brace. 
Line 17, indented once: c out, 2 left angled brackets, double quotes,
Name is, blank space, double quotes, 2 left angled brackets, a, 2 left
angled brackets, double quotes, blank space, weight is, blank space,
double quotes, 2 left angled brackets, w, 2 left angled brackets, end
l, semicolon. 
Line 18: right brace. 
Line 19: bool Get Yes Or No, left parentheses, right parentheses. 
Line 20: left brace. 
Line 21, indented once: c out, 2 left angled brackets, double quotes,
Enter yes or no, colon, blank space, double quotes, semicolon. 
Line 22, indented once: c in, 2 right angled brackets, a, semicolon. 
Line 23, indented once: return a equals equals double quotes, yes,

double quotes, semicolon. 
Line 24: right brace.
Back to Figure
Program code. The words in the keywords are merged. The code
contains the following keywords: int, main, using, name space, s t d.
Line 1: 2 forward slashes. Include directives and function prototypes
here. 
Line 2: int main, left parentheses, right parentheses. 
Line 3: left brace. 
Line 4, indented once: using name space s t d, semicolon. 
Line 5, indented once: 2 forward slashes. Rest of main body is here.
Line 6: right brace. 
Line 7: 2 forward slashes. Function definitions are here.
Back to Figure
Program code. The code contains the following keywords: bool, int,
if, return, true. 
Line 1: bool Greater, left parentheses, int a, comma, int b, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, a greater than b, right
parentheses. 
Line 4, indented twice: return true, semicolon. 
Line 5: right brace.
Back to Figure
Program code. The code contains the following keywords: int,
return. 
Line 1: int Average, left parentheses, int a, comma, int b, comma,
int c, right parentheses. 
Line 2: left brace. 
Line 3, indented once: return, left parentheses, a plus b plus c, right
parentheses, forward slash, 3.0, semicolon. 
Line 4: right brace.

Back to Figure
Program code. The code contains the following keywords: void, int,
if, else, return. 
Line 1: void Maximum, left parentheses, int a, comma, int b,
comma, int ampersand max, right parentheses. 
Line 2: left brace. 
Line 3, indented once: if, left parentheses, a greater than b, right
parentheses. 
Line 4, indented twice: max equals a, semicolon. 
Line 5, indented once: else. 
Line 6, indented twice: max equals b, semicolon. 
Line 7, indented once: return max, semicolon. 
Line 8: right brace.
Back to Figure
Program code. The words in the keywords, and variable names are
merged. The code contains the following keywords. include, i o
stream, using, name space, s t d, int, c out, c in, while, return. 
Line 1: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 2: using name space s t d, semicolon. 
Line 3: int Power, left parentheses, right parentheses, semicolon. 
Line 4: int p o w, semicolon. 
Line 5: int x, semicolon. 
Line 6: int result, semicolon. 
Line 7: int main, left parentheses, right parentheses. 
Line 8: left brace. 
Line 9, indented once: c out, 2 left angled brackets, double quotes,
Enter power, colon, blank space, double quotes, semicolon. 
Line 10, indented once: c in, 2 right angled brackets, p o w,
semicolon. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Enter value to be raised to power, colon, blank space, double
quotes, semicolon. 
Line 12, indented once: c in, 2 right angled brackets, x, semicolon. 
Line 13, indented once: c out, 2 left angled brackets, Power, left
parentheses, x, comma, p o w, right parentheses, semicolon. 

Line 14: right brace. 
Line 15: int Power, left parentheses, right parentheses. 
Line 16: left brace. 
Line 17, indented once: result equals 1, semicolon. 
Line 18, indented once: while, left parentheses, p o w greater than
0, right parentheses. 
Line 19, indented once: left brace. 
Line 20, indented twice: result, equals result asterisk x, semicolon. 
Line 21, indented twice: p o w minus minus, semicolon. 
Line 22, indented once: right brace. 
Line 23, indented once: return result, semicolon. 
Line 24: right brace.
Back to Figure
minus, left parentheses, left parentheses, left parentheses, 5 minus
4, right parentheses, asterisk, left parentheses, 8, forward slash, 2,
right parentheses, right parentheses, plus 7, right parentheses.
Back to Figure
Line 1: Enter item, colon, P, blank space, 10, blank space, 2, blank
space, 4, blank space, 8. 
Line 2: 10, blank space, 2 x 4 x 8, blank space, Pine, comma, cost,
colon, blank space, dollar sign, 100.80. 
Line 3: 1, blank space, 1 x 12 x 8, blank space, Maple, comma,
blank space, cost, colon, blank space, dollar sign, 44.00. 
Line 4: Enter item, colon, blank space, uppercase t. 
Line 5: Total cost, colon, blank space, 144.80 dollars.
Back to Figure
The root node is labeled simple types. The root node has 3 child
nodes labeled integral, enum, and floating. The child nodes of the
node labeled integral are as follows: char, short, int, long, and bool.
The first 4 types are marked unsigned. The child nodes of the node
labeled floating are as follows: float, double, and long double.
Back to Figure

Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: include, c
limits, c out, long underscore max, long underscore min, end l.
Line 1: hash include, left angled bracket, c limits, right angled
bracket.
Line 2: using name space s t d, semicolon.
Line 3: dot.
Line 4: dot.
Line 5: dot.
Line 6: c out, left angled brackets, double quotes, Max, dot, long
equals, double quotes, left angled brackets, uppercase long
underscore max, left angled brackets, end l, semicolon.
Line 7: c out, left angled brackets, double quotes, Min, dot, long
equals, double quotes, left angled brackets, uppercase long
underscore min, left angled brackets, end l, semicolon.
Line 8: dot.
Line 9: dot.
Line 10: dot."
Back to Figure
Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: int, some int,
char, some char, c out, some int, end l.
Line 1: int, some Int equals 97, semicolon.
Line 2: char, some char equals, 97, semicolon.
Line 3: c out, left angled brackets, some Int, left angled brackets,
end l, semicolon.
Line 4: c out, left angled brackets, some char, left angled brackets,
end l, semicolon."
Back to Figure
Program code.
Line 1: c h arch, semicolon.
Line 2: for, left parenthesis, c h equals, single quote, uppercase A,
single quote, semicolon, c h, left angular bracket equals, single
quote, uppercase G, single quote, semicolon, c h plus plus, right

parenthesis.
Line 3: count, left angular brackets, c h, semicolon."
Back to Figure
Program code. 
Line 1: typedef, int, Boolean, semicolon.
Line 2: const, int, uppercase true, equals 1, semicolon.
Line 3: const, int, uppercase false, equals 0, semicolon.
Line 4: dot.
Line 5: dot.
Line 6: dot."
Back to Figure
program code. The words in the variable names are merged.
Line 1: Boolean, data OK, semicolon.
Line 2: dot.
Line 3: dot.
Line 4: dot. 
Line 5: data OK, equals, uppercase true, semicolon."
Back to Figure
Program code.
Line 1: typedef int days, semicolon.
Line 2: const int, uppercase sun, equals 0, semicolon.
Line 3: const int, uppercase mon, equals 1, semicolon.
Line 4: const int, uppercase tue, equals 2, semicolon.
Line 5: dot.
Line 6: dot.
Line 7: dot.
Line 8: const int, uppercase sat, equals 6, semicolon."
Back to Figure
Program code. enum Vowel, left brace, single quote, uppercase A
single quote, comma, single quote, uppercase E, single quote,
comma, single quote, uppercase I, single quote, comma, single

quote, uppercase O, single quote, comma, single quote, uppercase
U, single quote, right brace, semicolon, 2 forward slashes, Error."
Back to Figure
A declaration in a code is as follows.
Line 1: enum Starch, left brace, uppercase corn, comma, uppercase
rice, comma, uppercase potato, comma, uppercase bean, right
brace, semicolon.
Line 2: enum Grain, left brace, uppercase wheat, comma,
uppercase corn, comma, uppercase rye, comma, uppercase barley,
comma, uppercase sorghum, right brace, semicolon, 2 forward
slashes, Error."
Back to Figure
Program code.
Line 1: enum Animals, left brace, rodent, cat, dog, bird, reptile,
horse, bovine, sheep, right brace, semicolon. An arrow pointing to
enum animals is labeled type identifier, and the animal list is labeled
literal values in the domain.
Line 2: Animals inPatient, semicolon.
Line 3: Animals outPatient, semicolon. Lines 2 and 3 are labeled
creation of two variables of type animals."
Back to Figure
A type cast is as follows. inPatient equals, static underscore cast,
left angled bracket, animals, right angled bracket, left parenthesis,
inPatient plus 1, right parenthesis, semicolon, 2 forward slashes,
Correct."
Back to Figure
Program code.
Line 1: Animals patient, semicolon.
Line 2: for, left parenthesis, patient equals, uppercase rodent,
semicolon, patient, left angled bracket equals, uppercase sheep,
semicolon, patient plus plus, right parenthesis, 2 forward slashes,
Error."

Back to Figure
Program code.
Line 1: for, left parenthesis, patient equals, uppercase rodent,
semicolon, patient, left angled bracket equals, uppercase sheep,
semicolon.
Line 2: patient equals, static underscore cast, left angled bracket,
animals, right angled bracket, left parenthesis, patient plus 1, 2 right
parenthesis.
Line 3: dot.
Line 4: dot.
Line 5: dot."
Back to Figure
The words in the variable name are merged. 
Line 1. in Patient, less than or equal to, bird in uppercase."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: switch, case,
break, c out.
Line 1: switch, left parenthesis, inPatient, right parenthesis.
Line 2: Left brace.
Line 3: indented once: case, uppercase rodent, colon.
Line 4: indented once: case, uppercase cat, colon.
Line 5: indented once: case, uppercase dog, colon. 
Line 6: indented once: case, uppercase bird, c out, 2 left angled
brackets, double quotes, cage ward, double quotes, semicolon.
Line 7: indented 5 times: break, semicolon. 
Line 8: indented once: case, uppercase reptile, colon, c out, 2 left
angled brackets, double quotes, terrarium ward, double quotes,
semicolon. 
Line 9: indented 5 times: break, semicolon.
Line 10: indented once: case, uppercase horse, colon. 
Line 11: indented once: case, uppercase bovine, colon. 
Line 12: indented once: case, uppercase sheep, colon, c out, 2 left

angled brackets, double quotes, barn, double quotes, semicolon. 
Line 13: Right brace."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: switch, case,
break, c out, c in, to upper, if, else, default. 
Line 1: c in, 2 right angled brackets, animal name, semicolon.
Line 2: switch, left parenthesis, to upper, left parenthesis, animal
name, dot, at, left parenthesis, 0, 2 right parenthesis.
Line 3: left brace.
Line 4: indented once: case, single quote, uppercase r, colon, if, left
parenthesis, to upper, left parenthesis, animal name, dot, at, left
parenthesis, 1, 2 right parenthesis, 2 equals sign, single quote,
uppercase o, single quote, right parenthesis.
Line 5: indented 6 times: inpatient, equals sign, uppercase rodent,
semicolon. 
Line 6: indented 5 times: else. 
Line 7: indented 6 times: inpatient, equals sign, uppercase reptile,
semicolon. 
Line 8: indented 5 times: break, semicolon. 
Line 9: case, single quote, uppercase c, single quote, colon,
inpatient, equals sign, uppercase cat, semicolon. 
Line 10: indented 5 times, break, semicolon.
Line 11: case, single quote, uppercase d, single quote, colon,
inpatient, equals sign, uppercase dog, semicolon. 
Line 12: indented 5 times, break, semicolon.
Line 13: indented once: case, single quote, uppercase b, single
quote, colon, if, left parenthesis, to upper, left parenthesis, animal
name, dot, at, left parenthesis, 1, 2 right parenthesis, 2 equals sign,
single quote, uppercase i, single quote, right parenthesis.
Line 14: indented 6 times: inpatient, equals sign, uppercase bird,
semicolon. 
Line 15: indented 5 times: else. 
Line 16: indented 6 times: inpatient, equals sign, uppercase bovine,
semicolon. 
Line 17: indented 5 times: break, semicolon. 
Line 18: case, single quote, uppercase h, single quote, colon,

inpatient, equals sign, uppercase horse, semicolon. 
Line 19: indented 5 times, break, semicolon.
Line 20: default, colon, inpatient, equals sign, uppercase sheep,
semicolon. 
Line 21: right brace."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: switch, case,
break, c in. 
Line 1: switch, left parenthesis, inpatient, right parenthesis.
Line 2: left brace.
Line 3: indented once: case, uppercase rodent, colon, c out, 2 left
angled brackets, double quotes, uppercase rodent, double quotes,
semicolon. 
Line 4: indented 6 times: break, semicolon.
Line 5: indented once: case, uppercase cat, colon, c out, 2 left
angled brackets, double quotes, uppercase cat, double quotes,
semicolon. 
Line 6: indented 6 times: break, semicolon.
Line 7: indented once: case, uppercase dog, colon, c out, 2 left
angled brackets, double quotes, uppercase dog, double quotes,
semicolon. 
Line 8: indented 6 times: break, semicolon.
Line 9: indented once: case, uppercase bird, colon, c out, 2 left
angled brackets, double quotes, uppercase bird, double quotes,
semicolon. 
Line 10: indented 6 times: break, semicolon.
Line 11: indented once: case, uppercase reptile, colon, c out, 2 left
angled brackets, double quotes, uppercase reptile, double quotes,
semicolon. 
Line 12: indented 6 times: break, semicolon.
Line 13: indented once: case, uppercase horse, colon, c out, 2 left
angled brackets, double quotes, uppercase horse, double quotes,
semicolon. 
Line 14: indented 6 times: break, semicolon.
Line 15: indented once: case, uppercase bovine, colon, c out, 2 left
angled brackets, double quotes, uppercase bovine, double quotes,

semicolon. 
Line 16: indented 6 times: break, semicolon.
Line 17: indented once: case, uppercase sheep, colon, c out, 2 left
angled brackets, double quotes, uppercase sheep, double quotes,
semicolon. 
Line18: indented 6 times: break, semicolon.
Line 19: right brace."
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, i
o stream, c c type, string, to upper, using, name space, s t d, int,
main, enum, char, c out, end l, for, c in, if, else, switch, case,
default, return, break, while.
Line 1: 2 forward slashes, followed by asterisks till the end of the
line.
Line 2: 2 forward slashes, this program demonstrates input forward
slash output of enumerated.
Line 3: 2 forward slashes, types.
Line 4: 2 forward slashes, followed by asterisks till the end of the
line.
Line 5: hash include, left angled bracket, c c type, right angled
bracket, 2 forward slashes, for to upper, left parenthesis, right
parenthesis. 
Line 6: hash include, left angled bracket, string, right angled bracket,
2 forward slashes, for string type. 
Line 7: hash include, left angled bracket, I o stream, right angled
bracket. 
Line 8: using name space s t d, semicolon.
Line 9: blank.
Line 10: enum animals, left brace, rodent, comma, cat, comma,
dog, comma, bird, comma, reptile, comma, horse, comma, bovine,
comma, sheep, right brace, semicolon.
Line 11: int, main, left parenthesis, right parenthesis. 
Line 12: left brace. 
Line 13: indented once: string animal name, semicolon.
Line 14: indented once: animals inpatient.
Line 15: indented once: c out, 2 left angled brackets, double quotes,

enter the name of an animal, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 16: indented once: c out, 2 left angled brackets, double quotes,
Enter Quit to stop, period, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 17: blank. 
Line 18: indented once: c in, 2 right angled brackets, animal name,
semicolon. 
Line 19: indented once: while, 2 left parenthesis, to upper, left
parenthesis, animal name, dot, at, left parenthesis, 0, 3 right
parenthesis, exclamation mark, equals sign, single quote, uppercase
q, single quote, right parenthesis. 
Line 20: indented once: left brace. 
Line 21: blank.
Line 22: indented twice: switch, left parenthesis, to upper, left
parenthesis, animal name, dot, at, left parenthesis, 0, 3 right
parenthesis. 
Line 23: indented twice: left brace.
Line 24: indented thrice: case, single quote, uppercase r, single
quote, colon, if, left parenthesis, to upper, left parenthesis, animal
name, dot, at, left parenthesis, 1, 2 right parenthesis, 2 equals
signs, single quote, uppercase o, single quote, right parenthesis.
Line 25: indented 8 times: inpatient, equals sign, uppercase rodent,
semicolon. 
Line 26: indented 7 times: else. 
Line 27: indented 8 times: inpatient, equals sign, uppercase reptile,
semicolon.
Line 28: indented 7 times: break, semicolon. 
Line 29: indented thrice: case, single quote, uppercase c, single
quote, colon, inpatient, equals sign, uppercase cat, semicolon. 
Line 30: indented 7 times: break, semicolon.
Line 31: indented thrice: case, single quote, uppercase d, single
quote, colon, inpatient, equals sign, uppercase dog, semicolon. 
Line 32: indented 7 times: break, semicolon. 
Line 33: blank. 
Line 34: indented thrice: case, single quote, uppercase b, single
quote, colon, if, left parenthesis, to upper, left parenthesis, animal
name, dot, at, left parenthesis, 1, 2 right parenthesis, 2 equals
signs, single quote, uppercase i, single quote, right parenthesis. 

Line 35: indented 8 times: inpatient, equals sign, uppercase bird,
semicolon. 
Line 36: indented 7 times: else. 
Line 37: indented 8 times: inpatient, equals sign, uppercase bovine,
semicolon.
Line 38: indented 7 times: break, semicolon. 
Line 39: indented thrice: case, single quote, uppercase h, single
quote, colon, inpatient, equals sign, uppercase horse, semicolon. 
Line 40: indented 7 times: break, semicolon.
Line 41: indented four thrice: default, colon, inpatient, equals sign,
uppercase sheep, semicolon.
Line 42: indented twice: right brace. 
Line 43: indented twice: c out, 2 left angled brackets, double quotes,
you entered, double quotes, semicolon. 
Line 44: indented twice: switch, left parenthesis, inpatient, right
parenthesis.
Line 45: indented twice: left brace. 
Line 46: indented thrice: case, uppercase rodent, colon, c out, 2 left
angled brackets, double quotes, rodent, double quotes, semicolon.
Line 47: indented 9 times: break, semicolon. 
Line 48: indented thrice: case, uppercase cat, colon, c out, 2 left
angled brackets, double quotes, cat, double quotes, semicolon.
Line 49: indented 9 times: break, semicolon.
Line 50: indented thrice: case, uppercase dog, colon, c out, 2 left
angled brackets, double quotes, dog, double quotes, semicolon.
Line 51: indented 9 times: break, semicolon.
Line 52: indented thrice: case, uppercase bird, colon, c out, 2 left
angled brackets, double quotes, bird, double quotes, semicolon.
Line 53: indented 9 times: break, semicolon.
Line 54: indented thrice: case, uppercase reptile, colon, c out, 2 left
angled brackets, double quotes, reptile, double quotes, semicolon.
Line 55: indented 9 times: break, semicolon.
Line 56: indented thrice: case, uppercase horse, colon, c out, 2 left
angled brackets, double quotes, horse, double quotes, semicolon.
Line 57: indented 9 times: break, semicolon.
Line 58: indented thrice: case, uppercase bovine, colon, c out, 2 left
angled brackets, double quotes, bovine, double quotes, semicolon.
Line 59: indented 9 times: break, semicolon.
Line 60: indented thrice: case, uppercase sheep, colon, c out, 2 left

angled brackets, double quotes, rodent, double quotes, semicolon.
Line 61: indented twice: right brace.
Line 62: indented twice: c out, 2 left angled brackets, end l,
semicolon. 
Line 63: indented twice: c out, 2 left angled brackets, double quotes,
enter the name of an animal, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 64: indented twice: 2 left angled brackets, double quotes, enter
quit to stop, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 65: indented twice: c in, 2 right angled brackets, animal name,
semicolon. 
Line 66: indented once: right brace.
Line 67: indented once, return 0, semicolon. 
Line 68: right brace."
Back to Figure
Line 1: Enter the name of an animal, period. 
Line 2: Enter Quit to stop, period.
Line 3: rodent, underline. 
Line 4: You entered Rodent.
Line 5: Enter the name of an animal, period. 
Line 6: Enter Quit to stop, period. 
Line 7: Cat, underline. 
Line 8: You entered Cat.
Line 9: Enter the name of an animal, period. 
Line 10: Enter Quit to stop, period. 
Line 11: dog, underline. 
Line 12: You entered Dog.
Line 13: Enter the name of an animal, period. 
Line 14: Enter Quit to stop, period. 
Line 15: Bird, underline.
Line 16: You entered Bird.
Line 17: Enter the name of an animal, period. 
Line 18: Enter Quit to stop, period.
Line 19: Reptile, underline.
Line 20: You entered Reptile.
Line 21: Enter the name of an animal, period. 

Line 22: Enter Quit to stop, period. 
Line 23: Horse, underline.
Line 24: You entered Horse. 
Line 25: Enter the name of an animal, period. 
Line 26: Enter Quit to stop, period. 
Line 27: Bovine, underline.
Line 28: You entered Bovine.
Line 29: Enter the name of an animal, period. 
Line 30: Enter Quit to stop, period. 
Line 31: Sheep, underline.
Line 32: You entered Sheep.
Line 33: Enter the name of an animal, period. 
Line 34: Enter Quit to stop, period. 
Line 35: Quit, underline."
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, float. 
Line 1: int factorial, left parenthesis, int, right parenthesis,
semicolon. 
Line 2: float cargo moment, left parenthesis, int, right parenthesis,
semicolon."
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: switch,
to upper, if, else, return, case, default, string.
Line 1: animals s t r to animal, left parenthesis, string s t r, right
parenthesis.
Line 2: left brace.
Line 3: indented once: switch, left parenthesis, to upper, left
parenthesis, s t r, dot, at, left parenthesis, 0, right parenthesis.
Line 4: indented once: left brace.
Line 5: indented twice: case, single quote, uppercase r, single quote,
colon, if, left parenthesis, to upper, left parenthesis, s t r, dot, at, left
parenthesis, 1, 2 right parenthesis, 2 equals to , single quote,
uppercase o, single quote, right parenthesis.

Line 6: indented 7 times: return, uppercase rodent, semicolon.
Line 7: indented 6 times: else.
Line 8: indented 7 times: return, uppercase reptile, semicolon.
Line 9: indented twice: case, single quote, c, single quote, colon,
return, uppercase cat, semicolon.
Line 10: indented twice: case, single quote, d, single quote, colon,
return, uppercase, dog, semicolon.
Line 11: indented twice: case, single quote, uppercase b, single
quote, colon, if, left parenthesis, to upper, left parenthesis, s t r, dot,
at, left parenthesis, 1, 2 right parenthesis, 2 equals to, single quote,
uppercase i, single quote, right parenthesis.
Line 12: indented 7 times: return, uppercase bird, semicolon.
Line 13: indented 6 times: else.
Line 14: indented 7 times: return, uppercase bovine, semicolon.
Line 15: indented twice: case, single quote, h, single quote, colon,
return, uppercase horse, semicolon.
Line 16: indented twice: default, colon, return, uppercase sheep,
semicolon.
Line 17: indented once: right brace.
Line 18: right brace."
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: int, main,
string, c out, end l, c in, while, to upper, switch, case, break. 
Line 1: int main, left parenthesis, right parenthesis.
Line 2: left brace.
Line 3: indented once: string animal name, semicolon.
Line 4: indented once: animals inpatient, semicolon.
Line 5: indented once: c out, 2 left angled brackets, double quotes,
enter the name of an animal, period, double quotes, 2 left angled
brackets, end l, semicolon.
Line 6: indented once: 2 left angled brackets, double quotes, enter
quit to stop, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 7: blank.
Line 8: indented once: c in, 2 right angled brackets, animal name,
semicolon. 

Line 9: indented once: while, 2 left parenthesis, to upper, left
parenthesis, animal name, dot, at, left parenthesis, 0, 3 right
parenthesis, exclamation mark, equals sign, single quote, uppercase
q, single quote, right parenthesis. 
Line 10: indented once: left brace. 
Line 11: indented twice: c out, 2 left angled brackets, double quotes,
you entered, double quotes, semicolon. 
Line 12: indented twice: switch, left parenthesis, s t r to animal, left
parenthesis, animal name, 2 right parenthesis, 2 forward slashes,
converts string to animals.
Line 13: indented twice: left brace. 
Line 14: indented thrice: case, uppercase rodent, colon, c out, 2 left
angled brackets, double quotes, rodent, double quotes, semicolon.
Line 15: indented 8 times: break, semicolon. 
Line 16: indented thrice: case, uppercase cat, colon, c out, 2 left
angled brackets, double quotes, cat, double quotes, semicolon.
Line 17: indented 8 times: break, semicolon.
Line 18: indented thrice: case, uppercase dog, colon, c out, 2 left
angled brackets, double quotes, dog, double quotes, semicolon.
Line 19: indented 8 times: break, semicolon.
Line 20: indented thrice: case, uppercase bird, colon, c out, 2 left
angled brackets, double quotes, bird, double quotes, semicolon.
Line 21: indented 8 times: break, semicolon.
Line 22: indented thrice: case, uppercase reptile, colon, c out, 2 left
angled brackets, double quotes, reptile, double quotes, semicolon.
Line 23: indented 8 times: break, semicolon.
Line 24: indented thrice: case, uppercase horse, colon, c out, 2 left
angled brackets, double quotes, horse, double quotes, semicolon.
Line 25: indented 8 times: break, semicolon.
Line 26: indented thrice: case, uppercase bovine, colon, c out, 2 left
angled brackets, double quotes, bovine, double quotes, semicolon.
Line 27: indented 8 times: break, semicolon.
Line 28: indented thrice: case, uppercase sheep, colon, c out, 2 left
angled brackets, double quotes, sheep, double quotes, semicolon.
Line 29: indented twice: right brace. 
Line 30: indented twice: c out, 2 left angled brackets, end l,
semicolon. 
Line 31: indented twice: c out, 2 left angled brackets, double quotes,
enter the name of an animal, period, double quotes, 2 left angled

brackets, end l, semicolon.
Line 32: indented twice: c out, 2 left angled brackets, double quotes,
enter quit to stop, period, double quotes, 2 left angled brackets, end
l, semicolon.
Line 33: indented twice: c in, 2 right angled brackets, animal name,
semicolon. 
Line 34: right brace.
Back to Figure
Line 1: enum coin type, left brace, nickel, comma, dime, comma,
quarter, comma, half, underscore, dollar, right brace, semicolon. 
Line 2: enum status type, left brace, ok, comma, out, underscore,
of, underscore, stock, comma, back, underscore, ordered, right
brace, semicolon. 
Line 3: blank.
Line 4: coin type change, semicolon.
Line 5: status type status, semicolon."
Back to Figure
Line 1: enum, left brace, nickel, comma, dime, comma, quarter,
comma, half, underscore, dollar, right brace, change, semicolon.
Line 2: enum, left brace, ok, comma, out, underscore, of,
underscore, stock, comma, back, underscore, ordered, right brace,
status, semicolon."
Back to Figure
Enum, name, left brace, enumerator, comma, enumerator, dot, dot,
dot, right brace, variable name, comma, variable name, dot, dot,
dot, semicolon.
Back to Figure
The figure has two parts, labeled as, atomic and structured. The
part labeled atomic, depicts 5 disconnected values grouped together.
There are 3 illustrations of values, in the part labeled structured. The
first illustration of value depicts 4 points connected by a line. The
second illustration of value depicts 6 points arranged in the form of a

tree diagram with a root node and two child nodes. The third
illustration of value depicts 5 points arranged in a circular pattern.
Back to Figure
The root node is labeled C plus plus data types. The root node has 2
child nodes labeled simple and structured. The portion of the tree
below the node labeled simple is not listed. The node labeled
structured has 4 child nodes labeled array, struct, union, and class.
Back to Figure
Program code.
Line 1: 2 forward slashes, Type declaration, minus minus, does not
allocate memory.
Line 2: struct Mailing Address.
Line 3: left brace.
Line 4: indented once, string street, semicolon.
Line 5: indented once, string city, semicolon.
Line 6: indented once, string state, semicolon.
Line 7: indented once, int zipcode, semicolon.
Line 8: left brace, semicolon.
Line 9: 2 forward slashes, variable definitions.
Line 10: Mailing Address, home Address, semicolon, 2 forward
slashes, has memory allocated for its four members.
Line 11: Mailing Address, business Address, semicolon, 2 forward
slashes, has memory allocated for its four members."
Back to Figure
Program code. The words in the code are merged.
Line 1: 2 forward slashes, type declarations.
Line 2: enum, Grade Type, left brace, a, b, c, d, f, right brace,
semicolon.
Line 3: struct Student Rec.
Line 4: left brace.
Line 5: indented once, string, first Name, semicolon.
Line 6: indented once, string, last Name, semicolon.
Line 7: indented once, float, g p a, semicolon, 2 forward slashes,

grade minus point average.
Line 8: indented once, int, program Grade, semicolon, 2 forward
slashes, assume, 0 dot dot 400.
Line 9: indented once, int, quiz Grade, semicolon, 2 forward slashes,
assume, 0 dot dot 300.
Line 10: indented once, int, final Exam, semicolon, 2 forward
slashes, assume 0 dot dot 300.
Line 11: indented once, Grade Type, course Grade, semicolon.
Line 12: left brace, semicolon.
Line 13: 2 forward slashes, variable definitions.
Line 14: Student Rec, first Student, semicolon.
Line 15: Student Rec, student, semicolon.
Line 16: int grade, semicolon."
Back to Figure
The illustration is of stacked rectangles. The first two rectangles are
long and the remaining are shorter and of the same length. Each
rectangle has an arrow pointing to it which reads from top to bottom
as follows: first Name, last Name, g p a, program Grade, quiz
Grade, final Exam, course Grade.
Back to Figure
The illustration is of stacked rectangles. The first two rectangles are
long and the remaining are shorter and of the same length. The
label of the rectangles and their respective struct variable are as
follows: Alice, student dot first Name; Brinkman, student dot last
Name; 3.4, student dot g p a; 325, student dot program Grade; 275,
student dot quiz Grade; blank, student dot final Exam; blank,
student dot course Grade.
Back to Figure
Program code. The words in the keywords and variables are
merged. The code contains the following keywords: int, else if,
return.
Line 1: Grade Type, Calculate Grade, left parenthesis, Student
Record, a Student, right parenthesis.

Line 2: left brace.
Line 3: indented once, int grade, equals, a Student dot final Exam,
plus, a Student dot program Grade, plus.
Line 4: indented eight times, a Student dot quiz Grade, semicolon.
Line 5: indented once, if, left parenthesis, grade, right angled
bracket equals, 900, right parenthesis.
Line 6: indented twice, return A, semicolon.
Line 7: indented once, else if, left parenthesis, grade, right angled
bracket equals, 800, right parenthesis.
Line 8: indented twice, return B, semicolon.
Line 9: indented once, else if, left parenthesis, grade, right angled
bracket equals, 700, right parenthesis.
Line 10: indented twice, return C, semicolon.
Line 11: indented once, else if, left parenthesis, grade, right angled
bracket equals, 600, right parenthesis.
Line 12: indented twice, return D, semicolon.
Line 13: indented once, else.
Line 14: indented twice, return F, semicolon.
Line 15: right brace.
Back to Figure
Program code. The words in the variables are merged.
Line 1: student equals, student asterisk another Student, semicolon,
2 forward slashes, Not allowed.
Line 2: if, left parenthesis, student, left angled bracket, another
Student, right parenthesis, 2 forward slashes, not allowed."
Back to Figure
The words in the variables are merged.
Line 1: c in left angled brackets, student dot first Name, semicolon.
Line 2: c in left angled brackets, student dot last Name, semicolon.
Line 3: dot.
Line 4: dot.
Line 5: dot."
Back to Figure

The words in the variables are merged.
Line 1: bool Consistent, left parenthesis, Student Rec, a Student,
right parenthesis.
Line 2: 2 forward slashes, Returns true if the course grade is
consistent.
Line 3: 2 forward slashes, with the overall G P A, semicolon, false
comma otherwise.
Line 4: left brace.
Line 5: indented once, int, rounded G P A, equals, int, left
parenthesis, a Student dot g p a plus 0.5, right parenthesis,
semicolon.
Line 6: indented once, switch, left parenthesis, rounded G P A, right
parenthesis.
Line 7: indented once, right brace.
Line 8: indented twice, case 0, colon, return, left parenthesis, a
Student dot course Grade, equals equals, uppercase F, right
parenthesis, semicolon.
Line 9: indented twice, case 1, colon, return, left parenthesis, a
Student dot course Grade, equals equals, uppercase D, right
parenthesis, semicolon.
Line 10: indented twice, case 2, colon, return, left parenthesis, a
Student dot course Grade, equals equals, uppercase C, right
parenthesis, semicolon.
Line 11: indented twice, case 3, colon, return, left parenthesis, a
Student dot course Grade, equals equals, uppercase B, right
parenthesis, semicolon.
Line 12: indented twice, case 4, colon, return, left parenthesis, a
Student dot course Grade, equals equals, uppercase A, right
parenthesis, semicolon.
Line 13: indented once, right brace.
Line 14: right brace."
Back to Figure
The words in the variables are merged.
Line 1: struct Student Rec.
Line 2: left brace.
Line 3: indented once, string, first Name, semicolon.
Line 4: indented once, string, last Name, semicolon.

Line 5: dot.
Line 6: dot.
Line 7: dot.
Line 8: right brace, semicolon.
Line 9: Student Rec, first Student, semicolon.
Line 10: Student Rec, student, semicolon."
Back to Figure
The words in the variables are merged.
Line 1: struct Student Rec.
Line 2: left brace.
Line 3: indented once, string, first Name, semicolon.
Line 4: indented once, string, last Name, semicolon.
Line 5: dot.
Line 6: dot.
Line 7: dot.
Line 8: left brace, first Student comma, student, semicolon."
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: struct, int, float.
Line 1: struct.
Line 2: left brace.
Line 3, indented once: int, first Member, semicolon.
Line 4, indented once: float, second Member, semicolon.
Line 5: right brace, blank space, some Var, semicolon."
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: struct, string.
Line 1: struct name.
Line 2: left brace.
Line 3: indented once: string, colon, first name, semicolon. 
Line 4: indented once: string, colon, middle name, semicolon. 
Line 5: indented once: string, colon, last name, semicolon. 
Line 6: right brace, semicolon."

Back to Figure
Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: struct, i
stream, and o stream.
Line 1: struct, Files.
Line 2: left brace.
Line 3, indented once: i stream, colon, in File, semicolon.
Line 4, indented once: o stream, colon, out File, semicolon.
Line 5, right brace, semicolon."
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: struct,
int, void, I f stream, char.
Line 1: struct counters.
Line 2: left brace.
Line 3: indented once: int uppercase, semicolon, 2 forward slashes,
number of uppercase letters.
Line 4: indented once: int lowercase, semicolon, 2 forward slashes,
number of lowercase letters.
Line 5: indented once: int blank, semicolon, 2 forward slashes,
number of blanks.
Line 6: indented once: int digit, semicolon, 2 forward slashes,
number of digits.
Line 7: indented once: int punctuation, semicolon, 2 forward slashes,
number of end, single quote, period, single quote, comma, single
quote, question mark, single quote, comma, single quote,
exclamation mark, single quote.
Line 8: indented once: int all else, semicolon, 2 forward slashes,
remaining characters.
Line 9: right brace, semicolon.
Line 10: blank.
Line 11: void prepare file, left parenthesis, I f stream, ampersand,
text, right parenthesis, semicolon.
Line 12: 2 forward slashes, This function reads in a file name and
opens the file, period.
Line 13: 2 forward slashes, If the file is not found, comma, an error

code is returned.
Line 14: void Increment Counters, left parenthesis, Counters,
ampersand, counters, comma, char character, right parenthesis,
semicolon.
Line 15: 2 forward slashes, This function increments the appropriate
character counter.
Line 16: void Initialize Counters, left parenthesis, Counters,
ampersand, counters, right parenthesis, semicolon.
Line 17: 2 forward slashes, This function initializes the counter fields
to zero.
Line 18: void Calculate And Print, left parenthesis, Counters
counters, right parenthesis, semicolon.
Line 19: 2 forward slashes, This function outputs the percentage of
the total of each.
Line 20: 2 forward slashes, character category."
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: struct, int, string,
float. 
Line 1: struct machine r e c.
Line 2: left brace.
Line 3: indented once: int I d number, semicolon.
Line 4: indented once: string description, semicolon.
Line 5: indented once: float fail rate, semicolon.
Line 6: indented once: int last serviced month, semicolon, 2 forward
slashes, assume 1, dot, dot, 12.
Line 7: indented once: int last serviced day, semicolon, assume 1,
dot, dot, 31. 
Line 8: indented once: int last serviced year, semicolon, 2 forward
slashes, assume 1900, dot, dot, 2050. 
Line 9: indented once: int down days, semicolon. 
Line 10: indented once: int purchase date month, semicolon, 2
forward slashes, assume 1, dot, dot, 12. 
Line 11: indented once: int purchase date day, semicolon, assume 1,
dot, dot, 31.
Line 12: indented once: int purchase date year, semicolon, assume
1900, dot, dot, 2050.

Line 13: indented once: float cost, semicolon.
Line 14: right brace, semicolon."
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: struct, int, float,
string.
Line 1: struct date.
Line 2: left brace.
Line 3: indented once: int month, semicolon, 2 forward slashes,
assume 1, dot, dot, 12.
Line 4: indented once: int day, semicolon, 2 forward slashes,
assume 1, dot, dot, 31.
Line 5: indented once: int year, semicolon, 2 forward slashes,
assume 1900, dot, dot, 2050.
Line 6: right brace, semicolon. 
Line 7: struct Statistics
Line 8: left brace.
Line 9: indented once: float fail Rate, semicolon.
Line 10: indented once: Date last Serviced, semicolon.
Line 11: indented once: int down Days, semicolon. 
Line 12: right brace, semicolon. 
Line 13: struct Machine R e c.
Line 14: left brace. 
Line 15: indented once: int I d Number, semicolon.
Line 16: indented once: string description, semicolon. 
Line 17: indented once: Statistics history, semicolon. 
Line 18: indented once: Date purchase Date, semicolon.
Line 19: indented once: float cost, semicolon. 
Line 20: right brace, semicolon. 
Line 21: Machine R e c machine, semicolon."
Back to Figure
There are 4 sets of entry boxes. The first set has 5 entry boxes with
data as follows. Box 1 reads, 5179, denoting machine dot I d
number. Box 2 reads, drilling, dot, dot, dot, denoting machine dot
description. Box 3 is informed by the second set of entry boxes. Box

4 is informed by the third set of entry boxes. Box 5 reads, 8000
point 0 0 denoting, machine dot cost. The second set of boxes has 3
entry boxes with data as follows. Box 1 reads, point 0 2 denoting,
machine dot history dot fail rate. Box 2 is informed by the fourth set
of entry boxes. Box 3 reads, 4 denoting, machine dot history dot
down Days. The third set of boxes has 3 entry boxes with data as
follows. Box 1 reads, 3 denoting, machine dot purchase Date dot
month. Box 2 reads, 21 denoting, machine dot purchase Date dot
day. Box 3 reads, 1995 denoting, machine dot purchase Date dot
year. The fourth set of boxes has 3 entry boxes with data as follows.
Box 1 reads, 1 denoting, machine dot history dot last Serviced dot
month. Box 2 reads, 25 denoting, machine dot history dot last
Serviced dot day. Box 3 reads, 1996 denoting, machine dot history
dot last Serviced dot year.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: union, long, int, float. 
Line 1: union weight type.
Line 2: left brace.
Line 3: indented once: long w t In Ounces, semicolon. 
Line 4: indented once: int w t In Pounds, semicolon.
Line 5: indented once: float w t In Tons, semicolon.
Line 6: right brace, semicolon. 
Line 7: Weight Type weight, semicolon."
Back to Figure
Line 1: weight, dot, w t In Tons, equals sign, 4.83, semicolon.
Line 2: indented once: dot, dot, dot.
Line 3: 2 forward slashes, Weight in tons is no longer needed,
period, Reuse the memory space.
Line 4: weight, dot, w t In Pounds, equals sign, 35, semicolon.
Line 5: indented once: dot, dot, dot."
Back to Figure

The root node is labeled c plus plus data types. The root node has 3
child nodes labeled simple, address, and structured. The child nodes
of the node labeled simple are as follows: integral, enum, and
floating. The child nodes of the node labeled integral are as follows:
char, short, int, long, and bool. The first 4 types are marked
unsigned. The child nodes of the node labeled floating are as
follows: float, double, and long double. The child nodes of the node
labeled address are pointer and reference. The child nodes of the
node labeled structured are as follows: array, struct, union, and
class.
Back to Figure
A left brace covers two lines. 
Line 1: data type, asterisk variable, semicolon.
Line 2: data type, asterisk variable, comma, asterisk variable, dot,
dot, dot, semicolon."
Back to Figure
A set of 2 parallel lines, labeled memory, are bridged at 2 points.
The left hand side of the parallel lines is labeled address, and the
right hand side is labeled, variable name. The first bridge is labeled
5008, with 5000 written on the left hand side, and int p t r written on
the right hand side. The second bridge has 5008 written on the left
hand side, and beta written on the right hand side. Three dots are
arranged vertically at the following locations within the parallel lines:
above the first bridge, between the two bridges, and below the
second bridge.
Back to Figure
A rectangular box labeled int P t r is on the left. A dot is marked
within this box. Another rectangular box on the right is labeled beta.
An arrow points from the rectangular box labeled int P t r to the
rectangular box labeled beta.
Back to Figure

Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: c out, and
end l.
Line 1. asterisk, int P t r, equals, 28, semicolon.
Line 2. c out, 2 left angled brackets, int P t r, 2 left angled brackets,
end l, semicolon.
Line 3. c out, 2 left angled brackets, asterisk, int P t r, 2 left angled
brackets, end l, semicolon."
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: struct, int.
Line 1: struct Patient R e c.
Line 2: left brace.
Line 3: int I d n u m, semicolon.
Line 4: int height, semicolon. 
Line 5: int weight, semicolon. 
Line 6: right brace, semicolon. 
Line 7: Patient R e c patient, semicolon. 
Line 8: Patient R e c, asterisk, patient P t r, equals sign, ampersand,
patient, semicolon."
Back to Figure
Left parenthesis, asterisk, patient P t r, right parenthesis, dot, weight
as patient P t r, right arrow, weight.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. Line 1. i n t P t r, equals, 0, semicolon.
Back to Figure
A square bracket with a diagonal represeting the variable in P t r
which points to NULL.
Back to Figure

Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include,
int.
Line 1: hash include, left angled bracket, c s t d def, right angled
bracket.
Line 2: dot. 
Line 3: dot.
Line 4: dot.
Line 5: int p t r, equals sign, uppercase null, semicolon."
Back to Figure
Program code. The words in the keyword, variable name, and
function name are merged. The code contains the following
keywords: if and NULL. Line 1. if, left parenthesis, in P t r, equals,
equals, NULL, right parenthesis. Line 2, indented once. Do
Something, left parenthesis, right parenthesis, semicolon.
Back to Figure
Program code. The words in the keyword, variable name, and
function name are merged. The code contains the following
keywords: if and int.
Line 1: if, left parenthesis, P t r, exclamation mark, equals sign, Null
in uppercase, right parenthesis.
Line 2: indented once. Do Something, left parenthesis, right
parenthesis, semicolon."
Back to Figure
A left brace covers two lines. 
Line 1: data type ampersand, variable, semicolon.
Line 2: data type, ampersand variable, comma, ampersand variable,
dot, dot, dot, semicolon."
Back to Figure
The table has two columns labeled, Using a Reference Variable, and
using a pointer variable. Row 1. Using a Reference Variable: Line 1,
int gamma, equals sign, 26, semicolon. Using a Pointer Variable:

Line 1, int gamma, equals sign, 26, semicolon. Row 2: Line 2, Using
a Reference Variable: int ampersand, int R e f, equals sign, gamma,
semicolon. Using a Pointer Variable: Line 2, int asterisk, int P t r,
equals sign, ampersand gamma, semicolon. Row 3. Using a
Reference Variable: Line 3, 2 forward slashes, int R e f is a
reference. Using a Pointer Variable: line 3, 2 forward slashes, int P t
r is a pointer. Row 4. Using a Reference Variable: line 4, 2 forward
slashes, variable that points. Using a Pointer Variable: line 4, 2
forward slashes, variable that points. Row 5. Using a Reference
Variable: line 5, 2 forward slashes, to gamma. Using a Pointer
Variable: line 5, 2 forward slashes, to gamma. Row 6. Using a
Reference Variable: line 6, blank. Using a pointer Variable: line 6,
blank. Row 7. Using a Reference Variable: line 7, int R e f, equals
sign, 35, semicolon. Using a Pointer Variable: line 7, asterisk int P t r.
equals sign, 35, semicolon. Row 8. Using a Reference Variable: line
8, 2 forward slashes, gamma, 2 equal signs, 35. Using a pointer
Variable: line 8, 2 forward slashes, gamma, 2 equal signs, 35. Row
9. Using a Reference Variable: line 9, blank. Using a pointer Variable:
line 9, blank. Row 10. Using a Reference Variable: line 10, int R e f,
equals sign, int R e f, plus sign, 3, semicolon. Using a pointer
Variable: line 10, asterisk int p t r equals sign, asterisk int p t r plus
sign, 3, semicolon. Row 11. Using a Reference Variable: line 11, 2
forward slashes, gamma, 2 equal signs, 38. Using a pointer Variable:
line 11, 2 forward slashes, gamma, 2 equal signs, 38.
Back to Figure
Line 1: Total number of alphanumeric characters.
Line 2: Number of uppercase letters.
Line 3: Number of lowercase letters.
Line 4: Number of digits.
Line 5: Number of characters ignored.
Line 6: Number of words.
Line 7: Number of sentences.
Line 8: Average word length.
Line 9: Average sentence length."
Back to Figure

The modules under the Main module are as follows: Open Files,
Initialize Counters, Increment Counters, and Print Table. The input
and the return value of the Initialize Counters module is labeled
counters. The inputs to the Increment Counters module are labeled
counters, and character. The output of the Increment Counters
module is labeled counters. The input to the Print Table module is
labeled counters. The Decode module is under the Increment
Counters module. The input to the Decode module is labeled
character. The output of the Decode module is labeled feature.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, f stream, i o
stream, i o manip, c c type, using namespace, enum, int, struct,
void, c out, end l, and if.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, Style Program.
Line 3, 2 forward slash, The program calculate number of words,
comma, average word length, comma.
Line 4, 2 forward slash, number of sentences, comma, average
sentence length, comma, number of.
Line 5, 2 forward slash, uppercase letters, comma, number of
lowercase letters, comma, and number of.
Line 6, 2 forward slash, digits in a file of text.
Line 7, 2 forward slash followed by asterisks till the end of line.
Line 8, blank line.
Line 9, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 10, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 11, hashtag include, left angled bracket, i o manip, right angled
bracket.
Line 12, hashtag include, left angled bracket, c c type, right angled
bracket.
Line 13, blank line.
Line 14, using namespace s t d, semicolon.
Line 15, blank line.
Line 16, enum, Features, left brace, UPPER, comma, LOWER,

comma, DIGIT, comma, IGNORE, comma, E O W, comma, E O S,
right brace, semicolon.
Line 17, blank line.
Line 18, struct, Counters.
Line 19, left brace.
Line 20, indented once, int, uppercase, semicolon.
Line 21, indented once, int, lowercase, semicolon.
Line 22, indented once, int, digit, semicolon.
Line 23, indented once, int, word, semicolon.
Line 24, indented once, int, sentence, semicolon.
Line 25, indented once, int, ignore, semicolon.
Line 26, right brace, semicolon.
Line 27, 2 forward slash, Function prototypes.
Line 28, void, Open File, left parenthesis, if stream ampersand, right
parenthesis, semicolon.
Line 29, 2 forward slash, This function reads in a file name and
opens the file, dot.
Line 30, 2 forward slash, If the file is not found, comma, an error
code is returned.
Line 31, Features Decode, left parenthesis, char, character, right
parenthesis, semicolon.
Line 32, 2 forward slash, This function examines the character and
returns its type.
Line 33, void, Increment Counters, left parenthesis, Counters
ampersand counters, char, character, right parenthesis, semicolon.
Line 34, 2 forward slash, This function increments the appropriate
character counter.
Line 35, void, Print Table, left parenthesis, Counters counters, right
parenthesis, semicolon.
Line 36, 2 forward slash, Table is output.
Line 37, void, Initialize Counters, left parenthesis, Counters
ampersand counters, right parenthesis, semicolon.
Line 38, 2 forward slash, This function initializes the counters.
Line 40, blank line.
Line 41, int main, left parenthesis, right parenthesis.
Line 42, indented once, 2 forward slash, Prepare files for reading
and writing.
Line 43, indented once, if stream text, semicolon.
Line 44, indented once, Counters counters, semicolon.

Line 45, indented once, Open File, left parenthesis, text, right
parenthesis, semicolon.
Line 46, indented once, if, left parenthesis, exclamation mark, text,
right parenthesis.
Line 47, indented once, left brace.
Line 48, indented twice, c out, 2 left angled brackets, double quotes,
Files did not open successfully dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 49, indented twice, return, 1, semicolon.
Line 50, indented once, right brace."
Back to Figure
The words in the variable names are merged. The program contains
the following keywords: if, else, return, case, void, c out, c in, end l,
initialize, and Print Table.
Line 1: indented once, Initialize Counters, left parenthesis, counters,
right parenthesis, semicolon.
Line 2: indented twice, char character, semicolon, 2 forward slashes,
Input character.
Line 3: indented once, text dot get, left parenthesis, character, right
parenthesis, semicolon, 2 forward slashes, Input one character.
Line 4: indented once, do.
Line 5: indented once, left brace, 2 forward slashes, Process each
character.
Line 6: indented twice, Increment Counters, left parenthesis,
counters, character, right parenthesis, semicolon.
Line 7: indented twice, text dot get, left parenthesis, character, right
parenthesis, semicolon, 2 forward slashes, Input one character.
Line 8: indented once, right brace, while, left parenthesis, text, right
parenthesis, semicolon.
Line 9: indented once, Print Table, left parenthesis, counters, right
parenthesis, semicolon.
Line 10: indented once, text dot close, left parenthesis, right
parenthesis, semicolon.
Line 11: indented once, return 0, semicolon.
Line 12: right brace.
Line 13: 2 forward slashes, asterisks till the end of line.
Line 14: Features Decode, left parenthesis, char character, right

parenthesis.
Line 15: 2 forward slashes, This function examines the character
and returns its type.
Line 16: left brace.
Line 17: indented once, if, left parenthesis, is upper, left parenthesis,
character, 2 right parenthesis.
Line 18: indented twice, return, upper in uppercase, semicolon.
Line 19: indented once, else if, left parenthesis, is lower, left
parenthesis, character, 2 right parenthesis. 
Line 20: indented twice, return, lower in uppercase, semicolon.
Line 21: indented once, else if, left parenthesis, is digit, left
parenthesis, character, 2 right parenthesis.
Line 22: indented twice, return, digit in uppercase, semicolon.
Line 23: indented once, left brace.
Line 24: indented twice, case, single quote, dot, single quote, colon.
Line 25: indented twice, case, single quote, question mark, single
quote, colon.
Line 26: indented once, case, single quote, single quote, colon.
Line 27: indented twice, case, single quote, comma, single quote,
colon.
Line 28: indented twice, case, single quote, semicolon, single quote,
colon.
Line 29: indented twice, case, single quote, colon, single quote,
colon.
Line 30: indented twice, case, single quote, backward slash, n,
single quote, colon, return, eow in uppercase, semicolon.
Line 31: indented once, right brace.
Line 32: indented once, return, ignore in uppercase, semicolon.
Line 33: right brace.
Line 34: 2 forward slashes, asterisks till the end of line.
Line 35: void, Open File, left parenthesis, if stream ampersand, text,
right parenthesis.
Line 36: left brace.
Line 37: indented once, string, in File Name, semicolon, 2 forward
slashes, User specified input file name.
Line 38: indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the file to be processed, double quotes, 2 left
angled brackets, end l, semicolon.
Line 39: indented once, c in, 2 right angled brackets, in File Name,

semicolon.
Line 40: indented once, text dot open, left parenthesis, in File Name,
dot, c, underscore, s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 41: indented once, c out, 2 left angled brackets, double quotes,
Analysis of characters on input file, double quotes, 2 left angled
brackets, in File Name.
Line 42: indented 4 times, 2 left angled brackets, end l, 2 left angled
brackets, end l, semicolon.
Line 43: right brace."
Back to Figure
The words in the variable names are merged. The program contains
the following keywords: void, c out, case, break, if, float, cast, static,
end l and break.
Line 1: 2 forward slashes, asterisks till the end of line.
Line 2: void, Print Table, left parenthesis, Counters counters, right
parenthesis.
Line 3: 2 forward slashes, Function PrintTable outputs the
percentages represented by each.
Line 4: 2 forward slashes, of the five categories.
Line 5: left brace.
Line 6: indented once, int, total Alpha Num, semicolon.
Line 7: indented once, total Alpha Num, equals, counters dot
uppercase, plus, counters dot lowercase.
Line 8: plus counters dot digit, semicolon.
Line 9: indented once, 2 forward slashes, Output results on file c
out.
Line 10: indented once, c out, 2 left angled brackets, double quotes,
Total number of alphanumeric characters, colon, double quotes.
Line 11: indented 4 times, 2 left angled brackets, total Alpha Num, 2
left angled brackets, end l, semicolon.
Line 12: indented once, c out, 2 left angled brackets, double quotes,
Number of uppercase letters, colon, double quotes, 2 left angled
brackets, counters dot uppercase.
Line 13: indented four times, 2 left angled brackets, end l,
semicolon.
Line 14: indented once, c out, 2 left angled brackets, double quotes,

Number of lowercase letters, colon, double quotes, 2 left angled
brackets, counters dot lowercase.
Line 15: indented four times, 2 left angled brackets, end l,
semicolon.
Line 16: indented once, c out, 2 left angled brackets, double quotes,
Number of digits, colon, double quotes, 2 left angled brackets,
counters dot digit, 2 left angled brackets, end l, semicolon.
Line 17: indented once, c out, 2 left angled brackets, double quote,
Number of characters ignored, colon, double quote, 2 left angled
brackets, counters dot ignore.
Line 18: indented 4 times, 2 left angled brackets, end l, semicolon.
Line 19: indented once, 2 forward slashes, Add number of end of
sentence markers to the word count.
Line 20: indented once, counters dot word, equals, counter dot
word, plus, counters dot sentence, semicolon.
Line 21: indented once, 2 forward slashes, Write rest of results on
file c out.
Line 22: indented once, c out, 2 left angled brackets, double quotes,
Number of words, colon, double quotes, 2 left angled brackets,
counters dot word, 2 left angled brackets, end l, semicolon.
Line 23: indented once, 2 left angled brackets, double quotes,
number of sentences, colon, double quotes, 2 left angled brackets,
counters dot sentence, 2 left angled brackets, end l, semicolon.
Line 24: indented once, c out, 2 left angled brackets, double quotes,
Average word length, colon, double quotes, 2 left angled brackets,
fixed, 2 left angled brackets, set precision, left parenthesis, 2, right
parenthesis.
Line 25: indented 4 times, static underscore cast, left angled
bracket, float, right angled bracket, left parenthesis, total Alpha
Num, right parenthesis, forward slash, counters dot sentence, 2 left
angled brackets, end l, semicolon.
Line 26: right brace.
Line 27: 2 forward slashes, asterisks till the end of line.
Line 28: void, Increment Counters, left parenthesis, Counters
ampersand, char character, right parenthesis.
Line 29: 2 forward slashes, This function examines character and
increments the.
Line 30: 2 forward slashes, appropriate counter.
Line 31: left brace.

Line 32: indented once, static bool end Of Word, equals, false,
semicolon.
Line 33: indented once, switch, left parenthesis, Decode, left
parenthesis, character, 2 right parenthesis.
Line 34: indented once, left brace.
Line 35: indented twice, case, upper in uppercase, colon, counters
dot uppercase, plus plus, semicolon.
Line 36: indented 12 times, end Of Word, equals, false, semicolon.
Line 37: indented 12 times, break, semicolon.
Line 38: indented twice, case, lower in uppercase, colon, counters
dot lowercase, plus plus, semicolon.
Line 39: indented 12 times, end Of Word, equals, false, semicolon.
Line 40: indented 12 times, break, semicolon.
Line 41: indented twice, case, digit in uppercase, colon, counters dot
digit, plus plus, semicolon.
Line 42: indented 12 times, end Of Word, equals, false, semicolon.
Line 43: indented 12 times, break, semicolon.
Line 44: indented twice, case, eow in uppercase, colon, if, left
parenthesis, exclamation mark, end Of Word, right parenthesis.
Line 45: indented 12 times, left brace.
Line 46: indented 13 times, counters dot word, plus plus,
semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: case, break,
and void.
Line 1: indented 10 times, end of Word, equals, true, semicolon.
Line 2: indented 9 times, right brace.
Line 3: indented 10 times, break, semicolon.
Line 4: indented two times, case E O S, colon, counters dot
sentence, plus, plus, semicolon.
Line 5: indented 10 times, break, semicolon.
Line 6: indented two times, case IGNORE, colon, counters dot
ignore, plus, plus, semicolon.
Line 7: indented 10 times, break, semicolon.
Line 8: indented once, right brace.
Line 9: right brace.

Line 10: blank line.
Line 11: 2 forward slash followed by asterisks till the end of the line.
Line 12: blank line.
Line 13: void Initialize Counters, left parenthesis, Counters
ampersand counters, right parenthesis.
Line 14: left brace.
Line 15: indented once, counters dot uppercase, equals, 0,
semicolon.
Line 16: indented once, counters dot lowercase, equals, 0,
semicolon.
Line 17: indented once, counters dot digit, equals, 0, semicolon.
Line 18: indented once, counters dot word, equals, 0, semicolon.
Line 19: indented once, counters dot sentence, equals, 0,
semicolon.
Line 20: indented once, counters dot ignore, equals, 0, semicolon.
Line 21: right brace."
Back to Figure
The input contains text which reads as follows. Paragraph 1. The
Abacus, left parenthesis, which appeared in the sixteenth century,
right parenthesis, was the first calculator, dot. In the middle of the
seventeenth century Blaise Pascal, comma, a French
mathematician, comma, built and sold gear hyphen driven
mechanical machines which performed whole number addition and
subtraction, dot. Left parenthesis, Yes, comma, the language Pascal
is named for this, dot. Paragraph 2. Later in the seventeenth century
a German mathematician Gottfried Wilhelm von Leibniz built the first
mechanical device designed to do all four whole numbers
operations, colon, addition, comma, subtraction, comma,
multiplication, comma, and division, dot. The state of mechanical
gears and levers at that time was such that the Leibniz machine was
not very reliable, dot.
Back to Figure
Line 1, Total number of alphanumeric characters, colon, 527.
Line 2, Number of uppercase letters, colon, 15.
Line 3, Number of lowercase letters, colon, 512.

Line 4, Number of digits, colon, 0.
Line 5, Number of characters ignored, colon, 5.
Line 6, Number of words, colon, 100.
Line 7, Number of sentences, colon, 5.
Line 8, Average word length, colon, 5.27.
Line 9, Average sentence length, colon, 20.00."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: case, and
break.
Line 1, case E O S, colon, counters dot sentence, plus, plus,
semicolon.
Line 2, indented six times, end of Word, equals, true, semicolon.
Line 3, indented six times, break, semicolon."
Back to Figure
Line 1: Total number of alphanumeric characters, colon, 527.
Line 2: Number of uppercase letters, colon, 15.
Line 3: Number of lowercase letters, colon, 512.
Line 4: Number of digits, colon, 0.
Line 5: Number of characters ignored, colon, 5.
Line 6: Number of words, colon, 100.
Line 7: Number of sentences, colon, 5.
Line 8: Average word length, colon, 5.55.
Line 9: Average sentence length, colon, 19.00."
Back to Figure
Program code. The words in the keyword are merged. The program
contains the following keywords: include, and s stream.
Line 1. hash include, left angled bracket, s stream, right angled
bracket, 2 forward slashes, access o string stream.
Line 2. hash include, double quotes, dialog dot h, double quotes."
Back to Figure

Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: void, string,
output, int, and end l.
Line 1, void, Open File, left parenthesis, o string stream ampersand,
comma, if stream ampersand, right parenthesis, semicolon.
Line 2, void, Print Table, left parenthesis, o string stream
ampersand, comma, Counters counters, right parenthesis,
semicolon.
Line 3, blank line.
Line 4, void Open File, left parenthesis, o string stream ampersand
output, comma, if stream ampersand text, right parenthesis.
Line 5, left brace.
Line 6, indented twice, string, in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 7, indented twice, File Dialog choose A File Dialog, left
parenthesis, double quotes, Choose the file to be processed, double
quotes, semicolon.
Line 8, indented twice, in File Name, equals, choose A File Dialog
dot display, left parenthesis, right parenthesis, semicolon.
Line 9, indented twice, text dot open, left parenthesis, in File Name
dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 10, indented twice, output, 2 left angled brackets, double
quotes, Analysis of characters on input file, double quotes, 2 left
angled brackets, in File Name.
Line 11, indented five times, 2 left angled brackets, end l, 2 left
angled brackets, end l, semicolon.
Line 12, right brace.
Line 13, blank line.
Line 14, 2 forward slash followed by asterisks till the end of the line.
Line 15, blank line.
Line 16, void, Print Table, left parenthesis, o string stream
ampersand output, comma, Counters counters, right parenthesis.
Line 17, 2 forward slash, Function Prit Table shows the percentage
represented by each.
Line 18, 2 forward slash, of the five categories.
Line 19, left brace.
Line 20, indented once, int, total Alpha Num, semicolon.
Line 21, indented once, total Alpha Num, equals, counters dot

uppercase, plus counters dot lowercase.
Line 22, indented thrice, plus, counters dot digit, semicolon.
Line 23, blank line.
Line 24, indented once, 2 forward slash, Put results in output string
stream.
Line 25, indented once, output, 2 left angled brackets, double
quotes, Total number of alphanumeric characters, colon, double
quotes.
Line 26, indented five times, 2 left angled brackets, total Alpha Num,
2 left angled brackets, end l, semicolon.
Line 27, indented once, output, 2 left angled brackets, double
quotes, Number of uppercase letters, colon, double quotes, 2 left
angled brackets, counter dot uppercase, 2 left angled brackets.
Line 28, indented seven times, end l, semicolon.
Line 29, indented once, output, 2 left angled brackets, double
quotes, Number of lowercase, colon, double quotes, 2 left angled
brackets, counters dot lowercase, 2 left angled brackets.
Line 30, indented seven times, end l, semicolon.
Line 31, indented once, output, 2 left angled brackets, double
quotes, Number of digits, colon, 2 left angled brackets, counters dot
digit, 2 left angled brackets, end l, semicolon,
Line 32, indented once, output, 2 left angled brackets, double
quotes, Number of characters ignored, colon, double quotes, 2 left
angled brackets, counters dot ignore, 2 left angled brackets.
Line 33, indented seven times, indented seven times, end l,
semicolon."
Back to Figure
Program code. The words in the keywords and variable names are
merged. The program contains the following keywords: output, end l,
fixed, float, and set precision.
Line 1, indented once. 2 forward slashes, add number of end
hyphen of hyphen sentence markers to the word count.
Line 2, indented once. counters dot word, equals, counters dot
word, plus, counters dot sentence, semicolon.
Line 3. blank.
Line 4, indented once. 2 forward slashes, Write rest of results in
output string stream.

Line 5, indented once. output, 2 left angled brackets, double quotes,
Number of Words colon, blank space, double quotes, 2 left angled
brackets, counters dot word, 2 left angled brackets, end l,
semicolon.
Line 6, indented once. output, 2 left angled brackets, double quotes,
Number of Sentences colon, blank space, double quotes, 2 left
angled brackets, counters dot sentence, 2 left angled brackets, end
l, semicolon.
Line 7, indented once. output, 2 left angled brackets, double quotes,
Average word length colon, blank space, double quotes, 2 left
angled brackets, fixed, 2 left angled brackets, set precision, left
parenthesis, 2, right parenthesis, 2 left angled brackets, float, left
parenthesis, total Alpha Num, right parenthesis, forward slash,
counters dot word, 2 left angled brackets, end l, semicolon.
Line 8, indented once. output, 2 left angled brackets, double quotes,
Average sentence length colon, blank space, double quotes, 2 left
angled brackets, fixed, 2 left angled brackets, set precision, left
parenthesis, 2, right parenthesis, 2 left angled brackets, float, left
parenthesis, counters dot word, right parenthesis, forward slash,
counters dot sentence, 2 left angled brackets, end l, semicolon.
Line 9. right brace."
Back to Figure
The output is displayed in a multiline text dialog box. The heading is
given as output for a text box within with the following output is
displayed. Line 1. Analysis of characters on input file, forward slash,
Chapter 10, forward slash, Style Case Study G U I, forward slash,
history dot in. Line 2. Total number of alphanumeric characters,
colon, 527. Line 3. Number of uppercase letters, colon, 15. Line 4.
Number of lowercase letters, colon, 512. Line 5. Number of digits,
colon, 0. Line 6. Number of characters ignored, colon, 5. Line 7.
Number of Words, colon, 95. Line 8. Number of Sentences, colon,
5. Line 9. Average word length, colon, 5.55. Line 10. Average
sentence length, colon, 19.00.
Back to Figure

Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: include, f
stream, and i o stream.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, Style Program.
Line 3, 2 forward slash, The program calculates number of words,
comma, average word length, comma.
Line 4, number of.
Line 5, 2 forward slash, sentences, comma, average sentence
length, comma, number of uppercase letters, comma, 
Line 6, 2 forward slash, number of lowercase letters, comma, and
number of digits in a file of.
Line 7, text.
Line 8, 2 forward slash followed by asterisks till the end of the line.
Line 9, hashtag, include, left angled bracket, f stream, right angled
bracket.
Line 10, hashtag, include, left angled bracket, i o stream, right
angled bracket."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: include, i o
manip, c c type, s stream, dialog dot hm using namespace, enum,
struct, int, void, if, char, c out, end l, and return.
Line 1, hashtag, include, left angled bracket, i o manip, right angled
bracket.
Line 2, hashtag, include, left angled bracket, c c type, right angled
bracket.
Line 3, hashtag, include, left angled bracket, s stream, right angled
bracket, 2 forward slash, Access o string stream.
Line 4, hashtag, include, double quotes, dialog dot h, double quotes,
2 forward slash, Access G U I components.
Line 5, blank line.
Line 6, using namespace s t d, semicolon.
Line 7, blank line.
Line 8, enum, Features, left brace, UPPER, comma, LOWER,
comma, DIGIT, comma, IGNORE, comma, ROW, comma, E O W,
comma, E O S, right brace, semicolon.

Line 9, blank line.
Line 10, struct, Counters.
Line 11, left brace.
Line 12, indented once, int, uppercase, semicolon.
Line 13, indented once, int, lowercase, semicolon.
Line 14, indented once, int, digit, semicolon.
Line 15, indented once, int, word, semicolon.
Line 16, indented once, int, sentence, semicolon.
Line 17, indented once, int, ignore, semicolon.
Line 18, right brace, semicolon.
Line 19, blank line.
Line 20, 2 forward slash, Function prototypes.
Line 21, void, Open File, left parenthesis, o string stream
ampersand, comma, if stream ampersand, right parenthesis,
semicolon.
Line 22, 2 forward slash, This shows a dialog requesting a file name
and opens the file dot.
Line 23, 2 forward slash, If the file is not found, comma, an error
code is returned.
Line 24, blank line.
Line 25, Features Decode, left parenthesis, char, character, right
parenthesis, semicolon.
Line 26, 2 forward slash, This function examines the character and
return its type.
Line 27, blank line.
Line 28, void, Increment Counters, left parenthesis, Counters
ampersand counters, comma, char, character, right parenthesis,
semicolon.
Line 29, 2 forward slash, This function increments the appropriate
character counter.
Line 30, blank line.
Line 31, void, Print Table, left parenthesis, o string stream
ampersand, comma, Counters, counters, right parenthesis,
semicolon.
Line 32, 2 forward slash, Table is displayed.
Line 33, blank line.
Line 34, void, Initialize Counters, left parenthesis, Counters
ampersand, counters, right parenthesis, semicolon.
Line 35, 2 forward slash, This function initializes the counters.

Line 36, blank line.
Line 37, int main, left parenthesis, right parenthesis.
Line 38, left brace.
Line 39, indented twice, 2 forward slash, A string output stream to
gather output.
Line 40, indented twice, o string stream output, semicolon.
Line 41, blank line.
Line 42, indented twice, 2 forward slash, Prepare files for reading
and writing.
Line 43, indented twice, if stream, text, semicolon.
Line 44, indented twice, Counters, counters, semicolon.
Line 45, indented twice, Open File, left parenthesis, output, comma,
text, right parenthesis, semicolon.
Line 46, blank line.
Line 47, indented twice, if, left parenthesis, exclamation mark, text,
right parenthesis.
Line 48, left brace.
Line 49, blank line.
Line 50, indented three times, c out, 2 left angled brackets, double
quotes, Files did not open successfully, dot, double quotes, 2 left
angled brackets, end l, semicolon.
ink 51, indented three times, return 1, semicolon.
Line 52, indented twice, right brace."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: char, do
while, return, if, else if, else, switch, case, and void.
Line 1, indented twice, Initialize Counters, left parenthesis, counters,
right parenthesis, semicolon.
Line 2, indented twice, char, character, semicolon, 2 forward slash,
Input character.
Line 3, blank line.
Line 4, indented twice, text dot get, left parenthesis, character, right
parenthesis, semicolon, 2 forward slash, Input one character.
Line 5, indented twice, do.
Line 6, indented twice, left brace, 2 forward slash, Process each
statement.

Line 7, indented three times, Increment Counters, left parenthesis,
counters, comma, character, right parenthesis, semicolon.
Line 8, indented three times, text dot get, left parenthesis, character,
right parenthesis, semicolon, 2 forward slash, Input one character.
Line 9, indented twice, right brace, while, left parenthesis, text, right
parenthesis, semicolon.
Line 10, blank line.
Line 11, indented twice, Print Table, left parenthesis, output,
counters, right parenthesis, semicolon.
Line 12, indented twice, Output Dialog, output Dialog, left
parenthesis, output dot s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 13, indented twice, output Dialog dot display, left parenthesis,
right parenthesis, semicolon.
Line 14, blank line.
Line 15, indented twice, text dot close, left parenthesis, right
parenthesis, semicolon.
Line 16, indented twice, return, 0, semicolon.
Line 17, right brace.
Line 18, blank line.
Line 19, 2 forward slash followed by asterisks till the end of the line.
Line 20, blank line.
Line 21, Features Decode, left parenthesis, char, character, right
parenthesis.
Line 22, 2 forward slash, This function examines the character and
return its types.
Line 23, left brace.
Line 24, indented once, if, left parenthesis, is upper, left parenthesis,
character, 2 right parenthesis.
Line 25, indented twice, return, UPPER, semicolon.
Line 26, indented once, else if, left parenthesis, is lower, left
parenthesis, character, 2 right parenthesis.
Line 27, indented twice, return, LOWER, semicolon.
Line 28, indented once, else if, left parenthesis, is digit, left
parenthesis, character, 2 right parenthesis.
Line 29, indented twice, return, DIGIT, semicolon.
Line 30, indented once, else.
Line 31, indented once, switch, left parenthesis, character, right
parenthesis.

Line 32, indented once, left brace.
Line 33, indented twice, case, single quote, dot, single quote, colon.
Line 34, indented twice, case, single quote, question mark, single
quote, colon.
Line 35, indented twice, case, single quote, exclamation symbol,
single quote, colon, return E O S, semicolon.
Line 36, blank line.
Line 37, indented twice, case, single quote, blank space, single
quote, colon.
Line 38, indented twice, case, single quote, comma, single quote,
colon.
Line 39, indented twice, case, single quote, semicolon, single quote,
colon.
Line 40, indented twice, case, single quote, colon, single quote,
colon.
Line 41, indented twice, case, single quote, backward slash, single
quote, colon, return, E O W, semicolon.
Line 42, indented once, right brace.
Line 43, indented twice, return IGNORE, semicolon.
Line 44, right brace.
Line 45, blank line.
Line 46, 2 forward slash followed by asterisks till the end of the line.
Line 47, blank line.
Line 48, void Open File, left parenthesis, o string stream ampersand
output, comma, if stream ampersand text, right parenthesis.
Line 49, left brace.
Line 50, indented once, string, in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 51, indented once, File Dialog choose A File Dialog, left
parenthesis, double quotes, Choose the file to be processed, double
quotes, right parenthesis, semicolon.
Line 52, in File Name, equals, choose A File Dialog dot display, left
parenthesis, right parenthesis, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: void, output,
end l, int, static, switch, case, and break.

Line 1, indented once, text dot open, left parenthesis, in File Name
dot c, underscore, s t r, left parenthesis, right parenthesis, right
parenthesis, semicolon.
Line 2, indented once, output, 2 left angled brackets, double quotes,
Analysis of characters on input file, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, 2 left angled
brackets, end l, semicolon.
Line 3, right brace.
Line 4, blank line.
Line 5, 2 forward slash followed by asterisks till the end of the line.
Line 6, blank line.
Line 7, void, Print Table, left parenthesis, o string stream ampersand
output, Counters counters, right parenthesis.
Line 8, 2 forward slash, Function Print Table shows the percentages
represented by each.
Line 9, 2 forward slash, of the five categories.
Line 10, left brace.
Line 11, indented once, int, total Alpha Num, semicolon.
Line 12, indented once, total Alpha Num, equals, counters dot
uppercase, plus, counters dot lowercase.
Line 13, indented twice, plus, counters dot digit, semicolon.
Line 14, blank line.
Line 15, indented once, 2 forward slash, Put results in output string
stream.
Line 16, indented once, output, 2 left angled brackets, double
quotes, Total number of alphanumeric characters, colon, double
quotes.
Line 17, indented three times, 2 left angled brackets, total Alpha
Num, 2 left angled brackets, end l, semicolon.
Line 18, indented once, output, 2 left angled brackets, double
quotes, Number of uppercase letters colon, double quotes, 2 left
angled brackets, counters dot uppercase, 2 left angled brackets.
Line 19, indented seven times, end l, semicolon.
Line 20, indented once, output, 2 left angled brackets, double
quotes, Number of lowercase letters, colon, double quotes, 2 left
angled brackets, counters dot lowercase, 2 left angled brackets.
Line 21, indented seven times, end l, semicolon.
Line 22, indented once, output, 2 left angled brackets, double
quotes, Number of digits, colon, double quotes, 2 left angled

brackets, counters dot digit, 2 left angled brackets, end l, semicolon.
Line 23, indented once, output, 2 left angled brackets, double
quotes, Number of characters ignored, colon, double quotes, 2 left
angled brackets, counters dot ignore, 2 left angled brackets, end l,
semicolon.
Line 24, blank line.
Line 25, indented once, 2 forward slash, Add number of end hyphen
of hyphen sentence markers to the word count.
Line 26, indented once, counters dot word, equals, counters dot
word, plus, counters dot sentence, semicolon.
Line 27, blank line.
Line 28, indented once, 2 forward slash, Write rest of results in
output string stream.
Line 29, indented once, output, 2 left angled brackets, double
quotes, Number of Words, colon, double quotes, 2 left angled
brackets, counters dot word, 2 left angled brackets, end l,
semicolon.
Line 30, output, 2 left angled brackets, double quotes, Number of
Sentences, colon, double quotes, 2 left angled brackets, counters
dot sentence, 2 left angled brackets, end l, semicolon.
Line 31, output, 2 left angled brackets, double quotes, Average word
length, colon, double quotes, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parenthesis, 2, right parenthesis.
Line 32,indented three times, 2 left angled brackets, float, left
parenthesis, total Alpha Num, right parenthesis, forward slash,
counters dot word, 2 left angled brackets, end l, semicolon.
Line 33, indented once, output, 2 left angled brackets, double
quotes, Average sentence length, colon, double quotes, 2 left angled
brackets, fixed, 2 left angled brackets, set precision, left
parenthesis, 2, right parenthesis.
Line 34, indented three times, 2 left angled parenthesis, float, left
parenthesis, counters dot word, right parenthesis, forward slash,
counters dot sentence, 2 left angled brackets, end l, semicolon.
Line 35, right brace.
Line 36, blank line.
Line 37, 2 forward slash followed by asterisks till the end of the line.
Line 38, blank line.
Line 39, void, Increment Counters, left parenthesis, Counters,
ampersand, counters, char, character, right parenthesis.

Line 40, 2 forward slash, This function examines character and
increments the.
Line 41, 2 forward slash, appropriate counter.
Line 42, left brace.
Line 43, indented once, static bool, end of Word, equals, false,
semicolon.
Line 44, blank line.
Line 45 , indented once, switch, left parenthesis, Decode, left
parenthesis, character, 2 right parenthesis.
Line 46, indented once, left brace.
Line 47, indented twice, case, UPPER, colon, counters dot
uppercase plus plus, semicolon.
Line 48, indented nine times, end of Word, equals, false, semicolon.
Line 49, indented nine times, break, semicolon.
Line 50, indented twice, case, LOWER, colon, counters dot
lowercase plus plus, semicolon.
Line 51, indented nine times, end of Word, equals, false, semicolon.
Line 52, indented nine times, break, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: void, case,
and break.
Line 1, indented twice, case DIGIT, colon, counters dot digit, plus,
plus, semicolon.
Line 2, indented nine times, end of Word, equals, false, semicolon.
Line 3, indented nine times, break, semicolon.
Line 4, indented twice, case E O W, colon, if, left parenthesis,
exclamation symbol, end of Word, right parenthesis.
Line 5, indented nine times, left brace.
Line 6, indented ten times, counters dot word, plus, plus, semicolon.
Line 7, indented ten times, end of Word, equals, true, semicolon.
Line 8, indented nine times, right brace.
Line 9, indented nine times, break, semicolon.
Line 10, indented twice, case E O S, colon, counters dot sentence,
plus, plus, semicolon.
Line 11, indented nine times, end of Word, equals, true, semicolon.
Line 12, indented nine times, break, semicolon.

Line 13, indented twice, case IGNORE, colon, counters dot ignore,
plus, plus, semicolon.
Line 14, indented nine times, break, semicolon.
Line 15, indented twice, right brace.
Line 16, right brace.
Line 17, 2 forward slashes followed by asterisks till the end of the
line.
Line 18, void, Initialize Counters, left parenthesis, Counters,
ampersand, counters, right parenthesis.
Line 19, left brace.
Line 20, indented twice, counters dot uppercase, equals, 0,
semicolon.
Line 21, indented twice, counters dot lowercase, equals, 0,
semicolon.
Line 22, indented twice, counters dot digit, equals, 0, semicolon.
Line 23, indented twice, counters dot word, equals, 0, semicolon.
Line 24, indented twice, counters dot sentence, equals, 0,
semicolon.
Line 25, indented twice, counters dot ignore, equals, 0, semicolon.
Line 26, right brace.
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: int.
Line 1, int, num, semicolon.
Line 2, int, asterisk, int P t r, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged.
Line 1, num, equals symbol, asterisk, int P t r, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: if.
Line 1, if, 2 left parenthesis, x equals y, right parenthesis, less than

z, right parenthesis.
Line 2, dot.
Line 3, dot.
Line 4, dot."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: if.
Line 1, x, equals symbol, y, semicolon.
Line 2, if, left parenthesis, y less than z, right parenthesis.
Line 3, dot.
Line 4, dot.
Line 5, dot."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: if.
Line 1, if, left parenthesis, x, equals symbol, y, right left angled
bracket, z, right parenthesis."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: int.
Line 1, int, asterisk, p, blank space, asterisk, q, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: int.
Line 1, int, asterisk, blank space, p, blank space, q, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: int.
Line 1, int, ampersand, m, blank space, ampersand, n, semicolon."

Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: enum.
Line 1, enum, Colors, left brace, Red, comma, orange, comma,
yellow, comma, green, comma, green, blue, comma, indigo, comma,
violet, right brace, semicolon.
Line 2, enum, Flowers, left brace, rose, comma, daffodil, comma,
lily, comma, violet, comma, cosmos, comma, orchid, right brace,
semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: enum.
Line 1, enum, Flowers, left brace, Rose, comma, Daffodil, comma,
Lily, comma, Violet, comma, Cosmos, comma, Orchid, right brace,
semicolon.
Line 2, Flowers, choice, semicolon.
Line 3, choice, equals symbol, Lily, semicolon.
Line 4, choice, plus, plus, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: string.
Line 1, struct, Name.
Line 2, right brace.
Line 3, indented once, string, first, semicolon.
Line 4, indented once, string, middle, semicolon.
Line 5, indented once, string, last, semicolon.
Line 6, right brace, semicolon.
Line 7, Name, your Name, semicolon.
Line 8, Name, my Name, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged.

Line 1 labeled a: your Name dot first, equals symbol, double quotes,
George, double quotes, semicolon.
Line 2 labeled b: your Name dot last, equals symbol, double quotes,
Smith, double quotes, semicolon.
Line 3 labeled c: my Name, equals symbol, your Name, semicolon.
Line 4 labeled d: my Name dot middle, equals symbol, double
quotes, Nathaniel, double quotes, semicolon.
Line 5 labeled e: your Name dot middle, equals symbol, my Name
dot middle dot at, left parenthesis, 0, right parenthesis, plus symbol,
double quotes, dot, double quotes, semicolon."
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: struct, int, string.
Line 1. struct student Record.
Line 2. left brace.
Line 3, indented once. Name, student Name, semicolon.
Line 4, indented once. Name, teacher Name, semicolon.
Line 5, indented once. int, grade Number, semicolon.
Line 6, indented once. string, grades, semicolon.
Line 7. right brace.
Line 8. student Record, sally, semicolon."
Back to Figure
Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: union, char,
and int.
Line 1, union, Grade Union.
Line 2, left brace.
Line 3, indented once, char, grade Letter, semicolon.
Line 4, indented once, int, grade Number, semicolon.
Line 5, right brace.
Line 6, Grade Union, grade, semicolon."
Back to Figure

Program code. In the code, the words in the variable names are
merged, and the code contains the following keywords: c in, if, and
int.
Line 1 labeled a: c in, 2 right angled brackets, grade dot grade
Letter, semicolon.
Line 2 labeled b: if, left parenthesis, grade dot grade Letter, greater
than or equal to sign, single quote, uppercase A, single quote, 2
ampersand symbols, grade dot grade Letter, less than or equal to
symbol, single quote, uppercase D, single quote, right parenthesis.
Line 3 labeled c: grade dot grade Number, equal symbol, 4, minus,
int, left parenthesis, grade dot grade Letter, minus, single quote,
uppercase A, single quote, right parenthesis, semicolon."
Back to Figure
Line 1, a b s, 2 left parenthesis, number, minus, 1, right parenthesis,
minus, number, right parenthesis.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, I
o stream, name space, s t d, int, c in, c out, return, end l.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, reverse numbers program.
Line 3: 2 forward slashes, asterisk till the end of the line.
Line 4: hash include, left angled bracket, I o stream, right angled
bracket.
Line 5: blank.
Line 6: using name space s t d, semicolon.
Line 7: blank.
Line 8: int main, left parenthesis, right parenthesis.
Line 9: left brace.
Line 10: indented once: int value 0, semicolon.
Line 11: indented once: int value 1, semicolon.
Line 12: indented once: int value 2, semicolon.
Line 13: indented once: dot.
Line 14: indented once: dot.
Line 15: indented once: dot.

Line 16: indented once: int value 999, semicolon.
Line 17: blank.
Line 18: indented once: c in, 2 right angled brackets, value 0,
semicolon.
Line 19: indented once: c in, 2 right angled brackets, value 1,
semicolon.
Line 20: indented once: c in, 2 right angled brackets, value 2,
semicolon.
Line 21: indented once: dot.
Line 22: indented once: dot.
Line 23: indented once: dot.
Line 24: indented once: c in, 2 right angled brackets, value 0,
semicolon.
Line 25: indented once: c out, 2 left angled brackets, value 999, 2
left angled brackets, end l, semicolon.
Line 26: indented once: c out, 2 left angled brackets, value 998, 2
left angled brackets, end l, semicolon.
Line 27: indented once: c out, 2 left angled brackets, value 997, 2
left angled brackets, end l, semicolon.
Line 28: indented once: dot.
Line 29: indented once: dot.
Line 30: indented once: dot.
Line 31: indented once: c out, 2 left angled brackets, value 0, 2 left
angled brackets, end l, semicolon.
Line 32: return 0, semicolon.
Line 33: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: for, c in,
c out, end l.
Line 1: for, left parenthesis, number, equals sign, 0, semicolon,
number, left angled bracket, 1000, semicolon, number, plus, plus,
right parenthesis.
Line 2: indented once: c in, 2 right angled brackets, value, left
square bracket, number, right square bracket, semicolon.
Line 3: for, left parenthesis, number, equals sign, 999, semicolon,
number, right angled bracket, equals sign, 0, semicolon, number,

minus, minus, right parenthesis.
Line 4: indented once: c out, 2 left angled brackets, value, left
square bracket, number, right square bracket, 2 left angled brackets,
end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, I
o stream, name space, s t d, int, for, c in, c out, return, end l.
Line 1: Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, this program reverses the numbers in an
array.
Line 3: 2 forward slashes, asterisk till the end of the line.
Line 4: hash include, left angled bracket, I o stream, right angled
bracket.
Line 5: blank.
Line 6: using name space s t d, semicolon.
Line 7: int main, left parenthesis, right parenthesis.
Line 8: left brace.
Line 9: indented once: int value, left square bracket, 1000, right
square bracket, semicolon.
Line 11: indented once: int number, semicolon.
Line 12: blank.
Line 13: indented once: for, left parenthesis, number, equals sign, 0,
semicolon, number, left angled bracket, 1000, semicolon, number,
plus, plus, right parenthesis.
Line 14: indented twice: c in, 2 right angled brackets, value, left
square bracket, number, right square bracket, semicolon.
Line 15: indented once: for, left parenthesis, number, equals sign,
999, semicolon, number, right angled bracket, equals sign, 0,
number, minus, minus, right parenthesis.
Line 16: indented twice: c out, 2 left angled brackets, value, left
square bracket, number, right square bracket, 2 left angled brackets,
end l, semicolon.
Line 17: indented once: return, 0, semicolon.
Line 18: right brace.
Back to Figure

A group of 4 rectangles stacked vertically up is labeled, angle. Each
rectangle has the following entries made to its left hand side, from
top to bottom: angle, left square bracket, 0, right square bracket;
angle, left square bracket, 1, right square bracket; angle, left square
bracket, 2, right square bracket; angle, left square bracket, 3, right
square bracket. A group of 10 rectangles stacked vertically up is
labeled, test score. Each rectangle has the following entries made to
its left hand side, from top to bottom: test score, left square bracket,
0, right square bracket; test score, left square bracket, 1, right
square bracket; test score, left square bracket, 2, right square
bracket; test score, left square bracket, 3, right square bracket; test
score, left square bracket, 4, right square bracket; test score, left
square bracket, 5, right square bracket; test score, left square
bracket, 6, right square bracket; test score, left square bracket, 7,
right square bracket; test score, left square bracket, 8, right square
bracket; test score, left square bracket, 9, right square bracket.
Back to Figure
A group of 4 rectangles stacked vertically up is labeled, angle. Each
rectangle has the following entries made to its left hand side, from
top to bottom: angle, left square bracket, 0, right square bracket;
angle, left square bracket, 1, right square bracket; angle, left square
bracket, 2, right square bracket; angle, left square bracket, 3, right
square bracket. The values written within each rectangle, from top to
bottom, are as follows: 4.93, minus 15.2, 0.5, 1.67.
Back to Figure
Line 1: angle, left square bracket, 0, right square bracket, equals
sign, 4.93, semicolon.
Line 2: angle, left square bracket, 1, right square bracket, equals
sign, minus 15.2, semicolon.
Line 3: angle, left square bracket, 2, right square bracket, equals
sign, 0.5, semicolon.
Line 4: angle, left square bracket, 3, right square bracket, equals
sign, 1.67, semicolon.
Back to Figure

The table has two columns. The row entries are as follows. Row 1.
Code fragment 1: angle, left square bracket, 2, right square bracket,
equals sign, 9.6, semicolon. Function: assign it a value. Row 2:
Code fragment 2: c in, 2 right angled brackets, angle, left square
bracket, 2, right square bracket, semicolon. Function: read a value
into it. Row 3: Code fragment 3: c out, 2 left angled brackets, angle,
left square bracket, 2, right square bracket, semicolon. Function:
Write its contents. Row 4: Code fragment 4: y, equals sign, s q r t,
left parenthesis, angle, left square bracket, 2, right square bracket,
semicolon. Function: Pass it as an argument. Row 5: Code fragment
5: x, equals sign, 6.8, asterisk, angle, left square bracket, 2, right
square bracket, plus, 7.5, semicolon. Function: Use it in an
arithmetic expression.
Back to Figure
Program code. The program contains the keyword, if.
Line 1: value, left square bracket, counter, right square bracket,
equals sign, 5, semicolon.
Line 2: if, left parenthesis, value, left square bracket, number, plus,
1, right square bracket, percentage sign, 10, exclamation mark,
equals sign, 0, right parenthesis.
Line 3: dot.
Line 4: dot.
Line 5: dot.
Back to Figure
A group of 9 rectangles stacked vertically up is labeled, value. Each
rectangle has the following entries made to its left hand side, from
top to bottom: value, left square bracket, 0, right square bracket;
value, left square bracket, 1, right square bracket; value, left square
bracket, 2, right square bracket; three dots vertically arranged;
value, left square bracket, 9, right square bracket; three dots
vertically arranged; value, left square bracket, 25, right square
bracket; three dots vertically arranged; value, left square bracket,
999, right square bracket. A text pointed at the rectangle labeled,
value, left square bracket, 0, right square bracket, reads as follows:
value, left square bracket, 0, right square bracket; left parenthesis,

the index is a constant, right parenthesis. A text pointed at the
rectangle labeled, value, left square bracket, 9, right square bracket,
reads as follows: value, left square bracket, i, right square bracket,
where I equals to 9; Left parenthesis, the index is a variable, right
parenthesis. A text pointed at the rectangle labeled, value, left
square bracket, 25, right square bracket, reads as follows: value, left
square bracket, 7 asterisk j plus 4, right square bracket, where j
equals to 3; Left parenthesis, the index is a more complex
expression, right parenthesis.
Back to Figure
Program code. The words used in the keywords are merged. The
program contains the following keywords: string, c out.
Line 1: string, a string, semicolon.
Line 2: a string, equals sign, double quotes, hello, double quotes,
semicolon.
Line 3: c out, 2 left angled brackets, a string, dot, at, left
parenthesis, 1, right parenthesis, semicolon, 2 forward slashes,
outputs, single quote, e, single quote.
Back to Figure
Program code. The words used in the keywords are merged. The
program contains the following keywords: c out, string.
Line 1: c out, 2 left angled brackets, a string, dot, at, left
parenthesis, 1, right parenthesis, semicolon, 2 forward slashes,
outputs, single quote, e, single quote.
Line 2: c out, 2 left angled brackets, a string, left square bracket, 1,
right square bracket, semicolon, 2 forward slashes, also outputs,
single quote, e, single quote.
Back to Figure
Line 1: for, left parenthesis, i equals 0, semicolon, left angled
bracket, 100, semicolon, i plus plus, right parenthesis.
Line 2: indented twice, alpha, left square bracket, i, right square
bracket, equals, 0 point 0, semicolon.

Back to Figure
Program code. The words used in the keywords are merged. The
program contains the following keywords: include, I o stream, name
space, s t d, int, for, c out, return, end l.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, This program creates an array of four.
Line 3: 2 forward slashes, items, comma, stores values into the four.
Line 4: 2 forward slashes, places, comma, and overruns the array
by two places.
Line 5: 2 forward slashes, asterisk till the end of the line.
Line 6: blank.
Line 7: hash include, left angled bracket, I o stream, right angled
bracket.
Line 8: using name space s t d, semicolon.
Line 9: int main, left parenthesis, right parenthesis.
Line 10: left brace.
Line 11: indented once: int data, left square bracket, 4, right square
bracket, semicolon.
Line 12: indented once: for, left parenthesis, int I, equals sign, 1,
semicolon, I, left angled bracket, equals sign, 4, semicolon, I, plus,
plus, left parenthesis, 2 forward slashes, fill all 4 elements of array.
Line 13: indented twice: data, left square bracket, I, right square
bracket, equals, I, semicolon.
Line 14: indented once: for, left parenthesis, int I, equals 1,
semicolon, I, left angled bracket, equals sign, 6, semicolon, I, plus,
plus, right parenthesis, 2 forward slashes, Output 6 elements,
minus, minus, error.
Line 15: indented twice: c out, 2 left angled brackets, data, left
square bracket, 1, right square bracket, 2 left angled brackets, end l,
semicolon.
Line 16: indented once: return, 0, semicolon.
Line 17: right brace.
Back to Figure
Line 1: 1.
Line 2: 2.
Line 3: 3.

Line 4: 4.
Line 5: 0.
Line 6: minus 1881139893.
Back to Figure
Program code. The program code contains the keyword for.
Line 1: for, left parenthesis, index, equals sign, 0, semicolon, index,
left angled bracket, 50, semicolon, index, plus, plus, right
parenthesis.
Line 2: indented once: one, left square bracket, index, right square
bracket, equals sign, two, left square bracket, index, right square
bracket, semicolon.
Back to Figure
Line 1: cons tint, uppercase building, underscore, uppercase, size,
equals sign, 350, semicolon, 2 forward slashes, Number of
apartments.
Line 2: blank.
Line 3: int occupants, left square bracket, uppercase building,
underscore, uppercase size, right square bracket, semicolon, 2
forward slashes, occupants, left square bracket, I, right square
bracket, is the number of.
Line 4: indented 14 times: 2 forward slashes, occupants in
apartment i.
Line 5: int total occupants, semicolon, 2 forward slashes, total
number of occupants.
Line 6: int counter, semicolon, 2 forward slashes, loop control and
index variable.
Back to Figure
A group of 5 rectangles stacked vertically up is labeled, value. Each
rectangle has the following entries made to its left hand side, from
top to bottom: occupants, left square bracket, 0, right square
bracket; occupants, left square bracket, 1, right square bracket;
occupant, left square bracket, 2, right square bracket; three dots

vertically arranged; value, left square bracket, 349, right square
bracket.
Back to Figure
Program code. The program code contains the keyword for.
Line 1: total occupants, equals sign, 0, semicolon.
Line 2: for, left parenthesis, counter, equals sign, 0, semicolon,
counter, left angled bracket, uppercase building, underscore,
uppercase size, semicolon, counter, plus, plus, right parenthesis.
Line 3: indented once: total occupants, equals sign, total occupants,
plus, occupants, left square bracket, counter, right square bracket,
semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, i
o stream, f s stream, name space, s t d, const, int, I f stream.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, This program allows a building owner to
look up how many.
Line 3: 2 forward slashes, occupants are in a given apartment.
Line 4: 2 forward slashes, asterisk till the end of the line.
Line 5: hash include, left angled bracket, I o stream, right angled
bracket.
Line 6: hash include, left angled bracket, f stream, right angled
bracket, 2 forward slashes, for file I slash o.
Line 7: using name space s t d, semicolon.
Line 8: blank.
Line 9: const int, uppercase BUILDING, underscore, uppercase
SIZE, equals sign, 10, semicolon, 2 forward slashes, Number of
apartments.
Line 10: blank.
Line 11: int main, left parenthesis, right parenthesis.
Line 12: left brace.
Line 13: indented once: int occupants, left square bracket,
uppercase building, underscore, uppercase size, right square
bracket, semicolon, 2 forward slashes, occupants, left square

bracket, I, right square bracket, is the number of.
Line 14: indented 16 times: 2 forward slashes, occupants in
apartment i.
Line 15: indented once: int total occupants, semicolon, 2 forward
slashes, total number of occupants.
Line 16: indented once: int counter, semicolon, 2 forward slashes,
loop control and index variable.
Line 17: indented once: int apt, semicolon, 2 forward slashes, An
apartment number.
Line 18: indented once: I f stream in File, semicolon, 2 forward
slashes, File of occupant data, left parenthesis, one.
Line 19: indented 16 times: 2 forward slashes, integer per
apartment, right parenthesis.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: for, c
out, do, end l, c in, if, while, return.
Line 1: indented once: in File, dot, open, left parenthesis, double
quotes, a p t, dot, d a t, double quotes, left parenthesis, , semicolon.
Line 2: indented once: total Occupants, equals sign, 0, semicolon.
Line 3: indented once: for, left parenthesis, counter, equals sign, 0,
semicolon, counter, left angled bracket, uppercase BUILDING,
underscore, uppercase SIZE, semicolon, counter, plus, plus, right
parenthesis.
Line 4: indented once: left brace.
Line 5: indented twice: in File, 2 right angled brackets, occupants,
left square bracket, counter, right square bracket, semicolon.
Line 6: indented twice: total Occupants, equals sign, total
Occupants, plus, occupants, left square bracket, counter, right
square bracket, semicolon.
Line 7: indented once: right brace.
Line 8: indented once: c out, 2 left angled brackets, double quotes,
N o, dot, of a p t s, dot, is, double quote, 2 left angled brackets,
uppercase BUILDING, underscore, uppercase SIZE, 2 left angled
brackets, end l.
Line 9: indented thrice: 2 left angled brackets, double quotes, Total n
o, dot, of occupants is, double quotes, 2 left angled brackets, total

Occupants, 2 left angled brackets, end l, semicolon.
Line 10: blank.
Line 11: indented once: c out, 2 left angled brackets, double quotes,
Begin a p t, dot, look up, dot, dot, dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 12: indented once: do.
Line 13: left brace.
Line 14: indented twice: c out, 2 left angled brackets, double quotes,
A p t, dot, number, left parenthesis, 1 through, double quotes, 2 left
angled brackets, uppercase BUILDING, underscore, uppercase
SIZE.
Line 15: indented 4 times: 2 left angled brackets, double quotes,
comma, or 0 to quit, right parenthesis, colon, double quotes,
semicolon.
Line 16: indented twice: c in, right angled brackets, a p t, semicolon.
Line 17: indented twice: if, left parenthesis, a p t, right angled
bracket, 0, right parenthesis.
Line 18: indented thrice: c out, 2 left angled brackets, double quotes,
A p t, dot, double quotes, 2 left angled brackets, a p t, 2 left angled
brackets, double quotes, has, double quotes, 2 left angled brackets,
occupants, left square bracket, a p t, hyphen, 1, right square
bracket.
Line 19: indented 5 times: 2 left angled brackets, double quotes,
occupants, double quotes, 2 left angled brackets, end l, semicolon.
Line 20: indented once: right brace, while, left parenthesis, a p t,
right angled bracket, 0, left parenthesis, semicolon.
Line 21: indented once: return 0, semicolon.
Line 22: right brace.
Back to Figure
Line 1: N o, dot, of a p t s, dot, is 10.
Line 2: Total n o, dot, of occupants is 23.
Line 3: begin a p t, dot, look up, dot, dot, dot.
Line 4: A p t, dot, number, left parenthesis, 1 through 10, comma, or
0 to quit, right parenthesis, colon, 1 underlined.
Line 5: A p t, dot, 1 has 3 occupants.
Line 6: A p t, dot, number, left parenthesis, 1 through 10, comma, or
0 to quit, right parenthesis, colon, 3 underlined.

Line 7: A p t, dot, 3 has 0 occupants.
Line 8: A p t, dot, number, left parenthesis, 1 through 10, comma, or
0 to quit, right parenthesis, colon, 5 underlined.
Line 9: A p t, dot, 5 has 4 occupants.
Line 10: A p t, dot, number, left parenthesis, 1 through 10, comma,
or 0 to quit, right parenthesis, colon, 6 underlined.
Line 11: A p t, dot, 6 has 1 occupants.
Line 12: A p t, dot, number, left parenthesis, 1 through 10, comma,
or 0 to quit, right parenthesis, colon, 7 underlined.
Line 13: A p t, dot, 7 has 1 occupants.
Line 14: A p t, dot, number, left parenthesis, 1 through 10, comma,
or 0 to quit, right parenthesis, colon, 9 underlined.
Line 15: A p t, dot, 9 has 3 occupants.
Line 16: A p t, dot, number, left parenthesis, 1 through 10, comma,
or 0 to quit, right parenthesis, colon, 10 underlined.
Line 17: A p t, dot, 10 has 2 occupants.
Line 18: A p t, dot, number, left parenthesis, 1 through 10, comma,
or 0 to quit, right parenthesis, colon, 0 underlined.
Back to Figure
A group of 6 rectangles stacked vertically up is labeled, value. Each
rectangle has the following entries made to its left hand side, from
top to bottom. Rectangle 1: sales a m t, left square bracket,
uppercase orange, right square bracket, left parenthesis, I, dot, e,
dot, comma, sales a m t, left square bracket, 0, right square
bracket, left parenthesis. Rectangle 2: sales a m t, left square
bracket, uppercase cola, right square bracket, left parenthesis, I,
dot, e, dot, comma, sales a m t, left square bracket, 1, right square
bracket, left parenthesis. Rectangle 3: sales a m t, left square
bracket, uppercase root, underscore, uppercase beer, right square
bracket, left parenthesis, I, dot, e, dot, comma, sales a m t, left
square bracket, 2, right square bracket, left parenthesis. Rectangle
4: sales a m t, left square bracket, uppercase ginger, underscore,
uppercase ale, right square bracket, left parenthesis, I, dot, e, dot,
comma, sales a m t, left square bracket, 3, right square bracket, left
parenthesis. Rectangle 5: sales a m t, left square bracket,
uppercase cherry, right square bracket, left parenthesis, I, dot, e,
dot, comma, sales a m t, left square bracket, 4, right square

bracket, left parenthesis. Rectangle 6: sales a m t, left square
bracket, uppercase lemon, right square bracket, left parenthesis, I,
dot, e, dot, comma, sales a m t, left square bracket, 5, right square
bracket, left parenthesis.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: enum, float.
Line 1: enum Drink, right brace, ORANGE, comma, COLA, comma,
ROOT underscore BEER, comma, GINGER underscore ALE,
comma, CHERRY, comma, LEMON, right brace, semicolon.
Line 2: blank.
Line 3: float sales A m t, left square bracket, 6, right square bracket,
semicolon, 2 forward slashes, Array of 6 floats, comma, to be
indexed by Drink type.
Line 4: Drink flavour, semicolon, 2 forward slashes, Variable of the
index type.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: for, c
out, end l.
Line 1: for, left parenthesis, flavour, equals sign, uppercase
ORANGE, semicolon, flavour, left angled bracket, equals sign,
uppercase LEMON, semicolon, flavour, equals sign, Drink, left
parenthesis, flavour, plus, 1, 2 right parenthesis.
Line 2: indented once: c out, 2 left angled parenthesis, sales A m t,
left square bracket, flavour, right square bracket, 2 left angled
brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: const, int, char.
Line 1: const int, uppercase N, uppercase U, uppercase M,
underscore, uppercase STUDENTS, equals sign, 10, semicolon.
Line 2: blank.

Line 3: char grade, left square bracket, uppercase N, uppercase U,
uppercase M, underscore, uppercase STUDENTS, right square
bracket, semicolon, 2 forward slashes, Array of 10 student letter
grades.
Line 4: int I d Number, semicolon, 2 forward slashes, Student I D
number, left parenthesis, 0 through 9, right parenthesis.
Back to Figure
Line 1: Student 0 Grade F. Line 2: Student 1 Grade B.
Line 3: dot.
Line 4: dot.
Line 5: dot.
Line 6: Student 9 Grade B.
Back to Figure
A group of 6 rectangles stacked vertically up is labeled, counters.
Each rectangle has the following entries made to its left hand side,
from top to bottom: left square bracket, 0, right square bracket; left
square bracket, 1, right square bracket; left square bracket, 2, right
square bracket; three dots vertically arranged; left square bracket,
24, right square bracket; left square bracket, 25, right square
bracket. A text pointed at the rectangle labeled, left square bracket,
0, right square bracket, reads as follows: Incremented each time,
single quote, uppercase A, single quote, or, single quote, a, single
quote, is read. A text pointed at the rectangle labeled, left square
bracket, 1, right square bracket, reads as follows: Incremented each
time, single quote, uppercase C, single quote, or, single quote, c,
single quote, is read. A text pointed at the rectangle labeled, left
square bracket, 24, right square bracket, reads as follows:
Incremented each time, single quote, uppercase Y, single quote, or,
single quote, y, single quote, is read. A text pointed at the rectangle
labeled, left square bracket, 25, right square bracket, reads as
follows: Incremented each time, single quote, uppercase Z, single
quote, or, single quote, z, single quote, is read.
Back to Figure

Line 1: single quote, uppercase a, single quote, minus, single quote,
uppercase a, single quote, equals sign, 0.
Line 2: single quote, uppercase b, single quote, minus, single quote,
uppercase a, single quote, equals sign, 1.
Line 3: dot, dot, dot.
Line 4: single quote, a, single quote, minus, single quote, a, single
quote, equals sign, 0.
Line 5: single quote, b, single quote, minus, single quote, a, single
quote, equals sign, 1.
Line 6: dot, dot, dot.
Back to Figure
Program code. The words used in the keywords are merged. The
program contains the following keywords: include, I o stream, c c
type, f stream, I o stream, string, name space, s t d, int.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, This program counts and outputs the
frequency of.
Line 3: 2 forward slashes, occurrence of alphabetic characters in a
file.
Line 4: 2 forward slashes, asterisk till the end of the line.
Line 5: hash include, left angled bracket, I o stream, right angled
bracket.
Line 6: hash include, left angled bracket, c c type, right angled
bracket.
Line 7: hash include, left angled bracket, f stream, right angled
bracket.
Line 8: hash include, left angled bracket, I o stream, right angled
bracket.
Line 9: hash include, left angled bracket, string, right angled bracket.
Line 10: using name space s t d, semicolon.
Line 11: int main, left parenthesis, right parenthesis.
Line 12: left brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: int, I f

stream, string, for, while, get line, if, c out, end l, return, to upper.
Line 1: indented once: 2 forward slashes, Declarations.
Line 2: indented once: int counters, left square bracket, 26, right
square bracket, semicolon.
Line 3: indented once: I f stream in File, semicolon.
Line 4: indented once: in File, dot, open, left parenthesis, double
quotes, history, dot, in, double quotes, right parenthesis, semicolon.
Line 5: indented once: string line, semicolon.
Line 6: indented once: int limit, semicolon, 2 forward slashes,
Number of characters in a line.
Line 7: indented once: int index, semicolon.
Line 8: indented once: 2 forward slashes, Zero out the array of
counters.
Line 9: indented once: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, 26, semicolon, counter,
plus, plus, right parenthesis.
Line 10: indented twice: counters, left square bracket, counter, right
square bracket, equals sign, 0, semicolon.
Line 11: indented once: get line, left parenthesis, in File, comma,
line, right parenthesis, semicolon, 2 forward slashes, Read a line.
Line 12: indented once: while, left parenthesis, in File, right
parenthesis.
Line 13: indented once: left brace.
Line 14: indented twice: limit, equals sign, line, dot, length, left
parenthesis, right parenthesis, semicolon.
Line 15: indented twice: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, limit, semicolon, counter,
plus, plus, right parenthesis, left brace.
Line 16: indented thrice: 2 forward slashes, Access each character
in the line.
Line 17: indented thrice: if, left parenthesis, is alpha, left
parenthesis, line, dot, at, left parenthesis, counter, 3 right
parenthesis.
Line 18: indented thrice: left brace.
Line 19: indented four times: 2 forward slashes, Increment the
character's counter.
Line 20: indented four times: index, equals sign, to upper, left
parenthesis, line, dot, at, left parenthesis, counter, 2 right
parenthesis, minus, single quote, uppercase A, single quote,

semicolon.
Line 21: indented four times: counters, left square bracket, index,
right square bracket, plus, plus, semicolon.
Line 22: indented thrice: right brace.
Line 23: indented twice: right brace.
Line 24: indented twice: get line, left parenthesis, in File, comma,
line, right parenthesis, semicolon, 2 forward slashes, Read a line.
Line 25: indented once: right brace.
Line 26: indented once: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, 26, semicolon, counter,
plus, plus, right parenthesis.
Line 27: indented twice: c out, 2 left angled brackets, static,
underscore, cast, left angled bracket, char, 2 right angled bracket,
left parenthesis, counter, plus, single quote, uppercase A, single
quote, right parenthesis, 2 left parenthesis, double quotes, colon,
double quotes.
Line 28: indented four times: 2 left angled brackets, counters, left
square bracket, counter, right square bracket, 2 left angled brackets,
end l, semicolon.
Line 29: indented once: return 0, semicolon.
Line 30: right brace.
Back to Figure
Line 1: A, colon, 305, blank spaces, H, colon, 192, blank spaces, O,
colon, 204, blank spaces, V, colon, 32.
Line 2: B, colon, 54, blank spaces, I, colon, 254, blank spaces, P,
colon, 60, blank spaces, W, colon, 48.
Line 3: C, colon, 142, blank spaces, J, colon, 6, blank spaces, Q,
colon, 6, blank spaces, X, colon, 5.
Line 4: D, colon, 150, blank spaces, K, colon, 9, blank spaces, R,
colon, 195, blank spaces, Y, colon, 41.
Line 5: E, colon, 421, blank spaces, L, colon, 114, blank spaces, S,
colon, 184, blank spaces, Z, colon, 5.
Line 6: F, colon, 59, blank spaces, M, colon, 109, blank spaces, T,
colon, 327.
Line 7: G, colon, 49, blank spaces, N, colon, 258, blank spaces, U,
colon, 96.

Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, float, char.
Line 1: int Some F u n c, left parenthesis, float p a r a m 1, comma,
2 forward slashes, Pass, hyphen, by, hyphen, value.
Line 2: indented 6 times: char, ampersand, p a r a m 2, right
parenthesis, 2 forward slashes, Pass, hyphen, by, hyphen,
reference.
Line 3: left brace.
Line 4: dot.
Line 5: dot.
Line 6: dot.
Line 7: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void, int,
for.
Line 1: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, comma, int n u m Elements, right
parenthesis.
Line 2: left brace.
Line 3: indented once: int I, semicolon.
Line 4: indented once: for, left parenthesis, I, equals, 0, semicolon, I,
left angled bracket, n u m Elements, semicolon, I, plus, plus, right
parenthesis.
Line 5: indented twice: int Array, left square bracket, I, right square
bracket, equals sign, 0, semicolon.
Line 6: right brace.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, int.
Line 1: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, comma, int n u m Elements, right
parenthesis, 2 forward slashes, Function prototype.

Line 2: 2 forward slashes, This function sets the first n u m Elements
in int Array to zero.
Line 3: blank.
Line 4: int main, left parenthesis, right parenthesis.
Line 5: left brace.
Line 6: indented once: int counters, left square bracket, 26, right
square bracket, semicolon.
Line 7: indented once: int some Other Array, left square bracket,
9000, right square bracket, colon.
Back to Figure
Program code. The words used in the variable names are merged.
Line 1: indented once: Zero Out, left parenthesis, counters, comma,
26, right parenthesis, semicolon.
Line 2: indented once: Zero Out, left parenthesis, some Other Array,
comma, 9000, right parenthesis, semicolon.
Line 3: dot.
Line 4: dot.
Line 5: dot.
Line 6: right brace.
Back to Figure
Program code. The program contains the following keywords: void,
const, int, for.
Line 1: void Copy, left parenthesis, int destination, left square
bracket, right square bracket, comma, const int source, left square
bracket, right square bracket, comma, int size, right parenthesis.
Line 2: left brace.
Line 3: indented once: int 1, semicolon.
Line 4: indented once: for, left parenthesis, 1, equals sign, 0,
semicolon, I, left angled bracket, size, semicolon, I, plus, plus, right
parenthesis.
Line 5: indented twice: destination, left square bracket, I, right
square bracket, equals sign, source, left square bracket, I, right
square bracket, semicolon.
Line 6: right brace.

Back to Figure
Program code. The words used in the variable names are merged.
The program contains the keyword, int.
Line 1: int counters, left square bracket, 26, right square bracket,
semicolon.
Line 2: dot.
Line 3: dot.
Line 4: dot.
Line 5: Zero Out, left parenthesis, counters, left square bracket, 26,
right square bracket, comma, 25, left parenthesis, semicolon, 2
forward slashes, Error.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, int.
Line 1: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, comma, int n u m Elements, right
parenthesis.
Line 2: 2 forward slashes, Pre, colon, n u m Elements is assigned.
Line 3: 2 forward slashes, Post, colon, int Array, left square bracket,
0, dot, dot, n u m Elements, minus, 1, right square brackets, are
zero.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, int.
Line 1: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, comma, int n u m Elements, right
parenthesis.
Line 2: 2 forward slashes, Pre, colon, n u m Elements is assigned.
Line 3: 2 forward slashes, Post, colon, int Array, left square bracket,
0, dot, dot, n u m Elements, minus, 1, right square brackets, are
zero.
Back to Figure

Program code. The program contains the following keywords: for,
int.
Line 1: 2 forward slashes, Zero out the array of counters.
Line 2: for, left parenthesis, int counter, equals sign, 0, semicolon,
counter, left angled bracket, 26, semicolon, counter, plus, plus, right
parenthesis.
Line 3: indented once: counters, left square bracket, counter, right
square bracket, equals sign, 0, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: get line,
while, for, if.
Line 1: get line, left parenthesis, in File, comma, line, right
parenthesis, semicolon, 2 forward slashes, Read a line.
Line 2: while, left parenthesis, in File, right parenthesis.
Line 3: left brace.
Line 4: indented once: limit, equals sign, line, dot, length, left
parenthesis, right parenthesis, semicolon.
Line 5: indented once: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, limit, semicolon, counter,
plus, plus, right parenthesis.
Line 6: indented twice: 2 forward slashes, Access each character in
the line.
Line 7: indented twice: if, left parenthesis, is alpha, left parenthesis,
line, left square bracket, counter, right square bracket, 2 right
parenthesis.
Line 8: indented twice: left brace.
Line 9: indented thrice: 2 forward slashes, Increment the character's
counter.
Line 10: indented thrice: dot, dot, dot.
Line 11: indented twice: right brace.
Line 12: indented once: get line, left parenthesis, in File, comma,
line, right parenthesis, semicolon, 2 forward slashes, Read a line.
Line 13: right brace.
Back to Figure

Program code. The words used in the keywords are merged. The
program contains the following keywords: for, int, c out, char, end l.
Line 1: for, left parenthesis, int counter, equals sign, 0, semicolon,
counter, left angled brackets, 26, semicolon, counter, plus, plus, right
parenthesis.
Line 2: c out, 2 left angled brackets, left parenthesis, char, right
parenthesis, left parenthesis, counter, plus, single quote, uppercase,
A, single quote, right parenthesis, 2 left angled brackets, double
quotes, colon, double quotes, 2 left angled brackets, counters, left
square bracket, counter, right square bracket.
Line 3: 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, I
o stream, f stream, string, c c type, name space, s t d, void, int.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, This program counts and outputs the
frequency of.
Line 3: 2 forward slashes, occurrence of alphabetic characters in a
file.
Line 4: 2 forward slashes, Three functions are used, which take
array parameters.
Line 5: 2 forward slashes, asterisk till the end of the line.
Line 6: hash include, left angled bracket, I o stream, right angled
bracket.
Line 7: hash include, left angled bracket, f stream, right angled
bracket.
Line 8: hash include, left angled bracket, string, right angled bracket.
Line 9: hash include, left angled bracket, c c type, right angled
bracket.
Line 10: using name space s t d, semicolon.
Line 11: blank.
Line 12: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, int num Elements, right parenthesis,
semicolon.
Line 13: 2 forward slashes, Pre, colon, n u m Elements is assigned.
Line 14: 2 forward slashes, Post, colon, int Array, left square

bracket, 0, dot, dot, n u m Elements, minus, 1, right square bracket,
are zero.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void, int,
I stream, I f stream, return, for, string, get line, to upper, while, if, c
out, static, end l.
Line 1: void Process Text, left parenthesis, int counters, left square
bracket, right square bracket, I stream, ampersand, in File, right
parenthesis, semicolon.
Line 2: 2 forward slashes, Post, colon, counters, left square bracket,
0, dot, dot, 25, right square bracket, contain the frequency of each.
Line 3: 2 forward slashes, character in in File.
Line 4: void Print, left parenthesis, int counters, left square bracket,
right square bracket, right parenthesis, semicolon.
Line 5: 2 forward slashes, Post, colon, counters, left square bracket,
0, dot, dot, 25, right square bracket, have been output.
Line 6: blank.
Line 7: int main, left parenthesis, right parenthesis.
Line 8: left brace.
Line 9: indented once: 2 forward slashes, Declarations
Line 10: indented once: int counters, left square bracket, 26, right
square bracket, semicolon.
Line 11: indented once: I f stream in File, semicolon.
Line 12: indented once: in File, dot, open, left parenthesis, double
quotes, text, dot, dat, double quotes, right parenthesis, semicolon.
Line 13: indented once: Process Text, left parenthesis, counters, in
File, right parenthesis, semicolon.
Line 14: indented once: Print, left parenthesis, counters, right
parenthesis, semicolon.
Line 15: indented once: return 0, semicolon.
Line 16: right brace.
Line 17: 2 forward slashes, asterisk till the end of the line.
Line 18: void Zero Out, left parenthesis, int int Array, left square
bracket, right square bracket, int n u m Elements, right parenthesis.
Line 19: left brace.
Line 20: indented once: for, left parenthesis, int I, equals sign, 1,

semicolon, I, left angled bracket, equals sign, n u m Elements,
semicolon, I, plus, plus, right parenthesis.
Line 21: indented twice: int Array, left square bracket, I, right square
bracket, equals sign, 0, semicolon.
Line 22: right brace.
Line 23: 2 forward slashes, asterisk till the end of the line.
Line 24: blank.
Line 25: void Process Text, left parenthesis, int counters, left square
bracket, right square bracket, I stream, ampersand, in File, right
parenthesis.
Line 26: Left brace.
Line 27: indented once: string line, semicolon.
Line 28: indented once: int limit, semicolon, 2 forward slashes,
Number of characters in a line.
Line 29: indented once: int index, semicolon.
Line 30: blank.
Line 31: indented once: get line, left pparenthesis, in File, comma,
line, right parenthesis, semicolon, 2 forward slashes, Read a line.
Line 32: indented once: while, left parenthesis, in File, Right
parenthesis.
Line 33: indented once: left brace.
Line 34: indented twice: limit, equals, line, dot, length, left
parenthesis, right parenthesis, semicolon.
Line 34: indented twice: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, limit, semicolon, counter,
plus, plus, right parenthesis.
Line 34: indented twice: left brace, 2 forward slashes, Access each
character in the line.
Line 35: indented thrice: if, left parenthesis, I s alpha, left
parenthesis, line, left square bracket, counter, right square bracket,
2 right parenthesis.
Line 34: indented twice: left brace.
Line 35: indented four times: index, equals sign, to upper, left
parenthesis, line, left square bracket, counter, right square bracket,
right parenthesis, minus, single quote, uppercase A, single quote,
semicolon.
Line 36: indented four times: counters, left square bracket, index,
right square bracket, plus, plus, semicolon.
Line 37: indented thrice: right brace.

Line 38: indented twice: right brace.
Line 39: indented twice: get line, left parenthesis, in File, comma,
line, right parenthesis, semicolon.
Line 40: indented once: right brace.
Line 41: right brace.
Line 42: 2 forward slashes, asterisk till the end of the line.
Line 43: void Print, left parenthesis, int counters, left square bracket,
right square bracket, right parenthesis.
Line 44: left brace.
Line 45: indented once: for, left parenthesis, int counter, equals sign,
0, semicolon, counter, left angled bracket, 26, semicolon, counter,
plus, plus, right parenthesis.
Line 46: indented twice: c out, 2 left angled brackets, static,
underscore, cast, left parenthesis, counter, plus, single quote,
uppercase A, single quote, right parenthesis, 2 left angled brackets,
double quotes, colon, double quotes.
Line 47: indented four times: 2 left angled brackets, counters, left
square bracket, counter, right square bracket, 2 left angled brackets,
end l, semicolon.
Line 48: right brace.
Back to Figure
Line 1: A, colon, minus 1073743727, J, colon, minus 1880951530,
S, colon, 184.
Line 2: B, colon, minus 1073743898, K, colon, 13, T, colon, 327.
Line 3: C, colon, 142, L, colon, 114, U, colon, minus 1881139797.
Line 4: D, colon, 150, M, colon, 109, V, colon, 4128.
Line 5: E, colon, 421, N, colon, minus, 1881143618, W, colon, 48.
Line 6: F, colon, 59, O, colon, 204, X, colon, 5.
Line 7: G, colon, 49, P, colon, 60, Y, colon, minus 1073744011.
Line 8: H, colon, 201, Q, colon, 6, Z, colon, minus 1881141188.
Line 9: I, colon, minus 1881143874, R, colon, 195.
Back to Figure
Line 1: A, colon, minus 1073743727, j, colon, 6, s, colon, 184.
Line 2: b, colon, 54, k, colon, 9, t, colon, 327.
Line 3: c, colon, 142, l, colon, 114, u, colon, 96.

Line 4: d, colon, 150, m, colon, 109, v, colon, 32.
Line 5: e, colon, 421, n, colon, 258, w, colon, 48.
Line 6: f, colon, 59, o, colon, 204, x, colon, 5.
Line 7: g, colon, 49, p, colon, 60, y, colon, 41.
Line 8: h, colon, 192, q, colon, 6, z, colon, 5.
Line 9: 1, colon, 254, r, colon, 195.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void, int,
for.
Line 1: void Zero Out, left parenthesis, int int, Array, left square
bracket, right square bracket, comma, int n u m Elements, right
parenthesis.
Line 2: left brace.
Line 3: indented once: for, left parenthesis, int I, equals sign, 1,
semicolon, I, left angled bracket, equals sign, n u m Elements,
semicolon, I, plus, plus, right parenthesis.
Line 4: indented twice: int Array, left square bracket, I, right square
bracket, equals sign, 0, semicolon.
Line 5: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: int, float.
Line 1: int main, left parenthesis, right parenthesis.
Line 2: left brace.
Line 3: float velocity, left square bracket, 30, right square bracket,
semicolon.
Line 4: dot.
Line 5: dot.
Line 6: dot.
Line 7: Zero Out, left parenthesis, velocity, 30, right parenthesis,
semicolon.
Line 8: dot.
Line 9: dot.

Line 10: dot.
Line 11: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: char,
string.
Line 1: char m y string, left square bracket, 4, right square bracket,
equals sign, left brace, single quote, d, single quote, single quote, o,
single quote, single quote, g, single quote, single quote, s, single
quote, right brace, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: char,
string.
Line 1: char m y string, left square bracket, right square bracket,
equals sign, left brace, single quote, d, single quote, single quote, o,
single quote, single quote, g, single quote, single quote, s, single
quote, single quote, forward slash, 0, single quote, right brace,
semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, I
o stream, string, f stream, name space, s t d, const, int, enum,
struct, float.
Line 1: 2 forward slashes, asterisk till the end of the line.
Line 2: 2 forward slashes, This program manipulates an array of
grade records.
Line 3: 2 forward slashes, asterisk till the end of the line.
Line 4: hash include, left angled bracket, I o stream, right angled
bracket.
Line 5: hash include, left angled bracket, string, right angled bracket.
Line 6: hash include, left angled bracket, f stream, right angled
bracket.

Line 7: using name space s t d, semicolon.
Line 8: const int MAX, underscore, STUDENTS, equals sign, 150,
semicolon.
Line 9: enum Grade Type, left brace, A, B, C, D, F, right brace,
semicolon.
Line 10: struct Student R e c.
Line 11: left brace.
Line 12: indented once: string s t u Name, semicolon.
Line 13: indented once: float g p a, semicolon.
Line 14: indented once: int exam Score, left square bracket, 4, right
square bracket, semicolon.
Line 15: indented once: Grade Type course Grade, semicolon.
Line 16: right brace, semicolon.
Line 17: Student R e c grade Book, left square bracket, MAX,
underscore STUDENTS, right square bracket, semicolon.
Line 18: int main, left parenthesis, right parenthesis.
Line 19: left brace, right brace.
Back to Figure
A group of 5 rectangles stacked vertically up is labeled, grade book.
Each rectangle has the following entries made to its left hand side,
from top to bottom: value, left square bracket, 0, right square
bracket; value, left square bracket, 1, right square bracket; value,
left square bracket, 2, right square bracket; three dots vertically
arranged; value, left square bracket, 149, right square bracket. A
text pointed at the rectangle labeled, value, left square bracket, 0,
right square bracket, reads as follows: first record of type student r e
c. A text pointed at the rectangle labeled, value, left square bracket,
1, right square bracket, reads as follows: second record of type
student r e c. An arrow pointed at the rectangle labeled, value, left
square bracket, 2, right square bracket, denotes another
arrangement of 4 vertically stacked rectangles. A text pointed at the
first rectangle from this arrangement reads as follows, grade Book,
left square bracket, 2, right square bracket, dot, s t u Name. A text
pointed at the second rectangle from this arrangement reads as
follows, grade Book, left square bracket, 2, right square bracket,
dot, g p a. The third rectangle has three other rectangles arranged
horizontally, with the following text pointed at the stack, grade Book,

left square bracket, 2, right square bracket, dot, exam score. A text
pointed at the fourth rectangle from this arrangement reads as
follows, grade Book, left square bracket, 2, right square bracket,
dot, course grade.
Back to Figure
The expression reads as follows. grade Book, left square bracket, 2,
right square bracket, dot, course Grade. The part, grade Book, left
square bracket, 2, right square bracket, dot, Specifies third record in
array grade Book. The part, course Grade, Specifies course Grade
member in record grade Book, left square bracket, 2, right square
bracket.
Back to Figure
The expression reads as follows. grade Book, left square bracket, 2,
right square bracket, dot, exam Score, left square bracket, 0, right
square bracket. the part, grade Book, left square bracket, 2, right
square bracket, dot, Specifies third record in array grade Book. The
part, exam Score, Specifies exam Score member, left parenthesis,
an array, right parenthesis. The part, left square bracket, 0, right
square bracket, Specifies first score in exam Score member.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void, I f
stream, c h a r, get line, switch, case, break.
Line 1: void Read Values, left parenthesis, I f stream ampersand, in
File, comma, Student R e c ampersand, record, right parenthesis.
Line 2: left brace.
Line 3: indented once: c h a r letter, semicolon.
Line 4: indented once: c h a r throw Away, semicolon.
Line 5: indented once: get line, left parenthesis, in File, comma,
record, dot, s t u Name, right parenthesis, semicolon.
Line 6: indented once: in File, 2 right angled brackets, record, dot, g
p a, right angled brackets, record, dot, exam Score, left square
bracket, 0, right square bracket.

Line 7: indented four times: 2 right angled brackets, record, dot,
exam Score, left square bracket, 1, right square bracket, 2 right
angled brackets, record, dot, exam Score, left square bracket, 2,
right square bracket.
Line 8: indented four times: 2 right angled brackets, record, dot,
exam Score, left square bracket, 3, right square bracket, 2 right
angled brackets, letter, semicolon.
Line 9: indented once: in File, dot, get, left parenthesis, throw Away,
right parenthesis, semicolon.
Line 10: indented once: switch, left parenthesis, letter, right
parenthesis, 2 forward slashes, Convert from c h a r to Grade Type.
Line 11: indented once: left brace.
Line 12: indented twice: case, single quote, uppercase A, single
quote, colon, record, dot, course Grade, equals sign, uppercase A,
semicolon.
Line 13: indented six times: break, semicolon.
Line 14: indented twice: case, single quote, uppercase B, single
quote, colon, record, dot, course Grade, equals sign, uppercase B,
semicolon.
Line 15: indented six times: break, semicolon.
Line 16: indented twice: case, single quote, uppercase C, single
quote, colon, record, dot, course Grade, equals sign, uppercase C,
semicolon.
Line 17: indented six times: break, semicolon.
Line 18: indented twice: case, single quote, uppercase D, single
quote, colon, record, dot, course Grade, equals sign, uppercase D,
semicolon.
Line 19: indented six times: break, semicolon.
Line 20: indented twice: case, single quote, uppercase F, single
quote, colon, record, dot, course Grade, equals sign, uppercase F,
semicolon.
Line 21: indented six times: break, semicolon.
Line 22: indented once: right brace.
Line 23: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void, end

l, switch, case, break.
Line 1: void Print Values, left parenthesis, o f stream ampersand, out
File, comma, Student R e c ampersand, record, right parenthesis.
Line 2: left brace.
Line 3: indented once: out File, 2 left angled brackets, record, dot, s
t u Name, 2 left angled brackets, end l, semicolon.
Line 4: indented once: out File, 2 left angled brackets, record, dot, g
p a, 2 left angled brackets, single quote, blank space, single quote, 2
left angled brackets, record, dot, exam Score, left square bracket, 0,
right square bracket, 2 left angled brackets, Single quote, blank
space, single quote.
Line 5: indented four times: 2 left angled brackets, record, dot, exam
Score, left square bracket, 1, right square bracket, 2 left angled
brackets, single quote, blank space, single quote.
Line 6: indented four times: 2 left angled brackets, record, dot, exam
Score, left square bracket, 2, right square bracket, 2 left angled
brackets, single quote, blank space, single quote.
Line 7: indented four times: 2 left angled brackets, record, dot, exam
Score, left square bracket, 2, right square bracket, 2 left angled
brackets, single quote, blank space, single quote, semicolon.
Line 8: indented once: switch, left parenthesis, record, dot, course
Grade, right parenthesis.
Line 9: indented once: left brace.
Line 10: indented twice: case uppercase A, colon, out File, 2 left
angled brackets, single quote, uppercase A, single quote, semicolon.
Line 11: indented five times: break, semicolon.
Line 12: indented twice: case uppercase B, colon, out File, 2 left
angled brackets, single quote, uppercase B, single quote, semicolon.
Line 13: indented five times: break, semicolon.
Line 14: indented twice: case uppercase C, colon, out File, 2 left
angled brackets, single quote, uppercase C, single quote,
semicolon.
Line 15: indented five times: break, semicolon.
Line 16: indented twice: case uppercase D, colon, out File, 2 left
angled brackets, single quote, uppercase D, single quote,
semicolon.
Line 17: indented five times: break, semicolon.
Line 18: indented twice: case uppercase F, colon, out File, 2 left
angled brackets, single quote, uppercase F, single quote, semicolon.

Line 19: indented five times: break, semicolon.
Line 20: indented once: right brace.
Line 21: indented once: out File, 2 left angled brackets, end l,
semicolon.
Line 22: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: int, main,
o f stream, I f stream, for, return.
Line 1: int main, left parenthesis, right parenthesis.
Line 2: left brace.
Line 3: indented once: Student R e c record, left square bracket,
MAX underscore STUDENTS, right square bracket, semicolon.
Line 4: indented once: o f stream out File, semicolon.
Line 5: indented once: o f stream out File, semicolon.
Line 6: indented once: out File, dot, open, left parenthesis, double
quotes, r e c, dot, out, double quotes, right parenthesis, semicolon.
Line 7: indented once: I f stream in File, semicolon.
Line 8: indented once: in File, dot, open, left parenthesis, double
quotes, r e c, dot, in, double quotes, right parenthesis, semicolon.
Line 9: indented once: for, left parenthesis, int count, equals sign, 0,
semicolon, count, left angled bracket, MAX underscore, STUDENTS,
semicolon, count, plus, plus, right parenthesis.
Line 10: indented twice: Read Values, left parenthesis, in File,
comma, record, left square bracket, count, right square bracket,
right parenthesis, semicolon.
Line 11: indented once: for, left parenthesis, int count, equals sign,
0, semicolon, count, left angled bracket, MAX underscore,
STUDENTS, semicolon, count, plus, plus, right parenthesis.
Line 12: indented twice: Print Values, left parenthesis, out File,
comma, record, left square bracket, count, right square bracket,
right parenthesis, semicolon.
Line 13: indented once: in file, dot, close, left parenthesis, right
parenthesis, semicolon.
Line 14: indented once: out file, dot, close, left parenthesis, right
parenthesis, semicolon.

Line 15: return 0, semicolon.
Line 16: right brace.
Back to Figure
Line 1: Mary Abbott.
Line 2: 3.4, 80, 90, 60, 99, B.
Line 3: Bob Baker.
Line 4: 4.0, 90, 90, 90, 95, A.
Line 5: Sally Carter.
Line 6: 2.0, 70, 70, 70, 65, C.
Line 7: Bill Dansk.
Line 8: 3.0, 65, 50, 60, 70, D.
Line 9: JoEllen Zureck.
Line 10: 1.9, 90, 95, 80, 99, A.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: while, switch, case,
break, void, for.
Line 1, indented once, get line, left parenthesis, in File, comm, book
dot grades, left square bracket, count, right square bracket, dot, s t
u Name, right parenthesis, semicolon.
Line 2, indented once, while, left parenthesis, in File, right
parenthesis.
Line 3, left brace.
Line 4, indented twice, in File, 2 right angled brackets, book dot
grades, left square bracket, count dot g p a.
Line 5, indented five times, 2 right angled brackets, book dot grades,
left square bracket, exam Score, left square bracket, 0, right square
bracket.
Line 6, indented five times, 2 right angled brackets, book dot grades,
left square bracket, exam Score, ledt square bracket, 1, right square
bracket.
Line 7, indented five times, 2 right angled brackets, book dot grades,
left square bracket, exam Score, ledt square bracket, 2, right square
bracket.
Line 8, indented five times, 2 right angled brackets, book dot grades,

left square bracket, exam Score, ledt square bracket, 3, right square
bracket, 2 right angled brackets, letter, semicolon.
Line 9, indented twice, in File dot get, left parenthesis, throw Away,
right parenthesis, semicolon.
Line 10, indented twice, switch, left parenthesis, letter, right
parenthesis.
Line 11, indented twice, left brace.
Line 12, indented three times, case, single quote, uppercase A,
single quote, colon, book dot grades, left square bracket, count,
right square bracket, dot course Grade, equals uppercase A,
semicolon.
Line 13, indented seven times, break, semicolon.
Line 14, indented three times, case, single quote, uppercase B,
single quote, colon, book dot grades, left square bracket, count,
right square bracket, dot course Grade, equals uppercase B,
semicolon.
Line 15, indented seven times, break, semicolon.
Line 16, indented three times, case, single quote, uppercase C,
single quote, colon, book dot grades, left square bracket, count,
right square bracket, dot course Grade, equals uppercase C,
semicolon.
Line 17, indented seven times, break, semicolon.
Line 18, indented three times, case, single quote, uppercase D,
single quote, colon, book dot grades, left square bracket, count,
right square bracket, dot course Grade, equals uppercase D,
semicolon.
Line 19, indented seven times, break, semicolon.
Line 20, indented three times, case, single quote, uppercase F,
single quote, colon, book dot grades, left square bracket, count,
right square bracket, dot course Grade, equals uppercase F,
semicolon.
Line 21, indented seven times, break, semicolon.
Line 22, indented twice, right brace.
Line 23, indented twice, count plus plus, semicolon.
Line 24, indented twice, get line, left parenthesis, in File, comma,
book dot grades, left square bracket, count, right square bracket,
dot s t u Name, right parenthesis, semicolon.
Line 25, indented once, right brace.
Line 26, indented once, book dot num Elements equals count,

semicolon.
Line 27, right brace.
Line 28, 2 forward slash followed by the asterisks till the end of the
line.
Line 29, void Print Values, left parenthesis, of stream ampersand out
File, comma, Grade Book ampersand book, right parenthesis.
Line 30, left brace.
Line 31, indneted once, for, left parenthesis, int count equals 0,
semicolon, count less than book dot num Elements, semicolon,
count plus plus, right parenthesis.
Line 32, indented once, left brace.
Line 33, indented twice, out File, 2 left angled brackets, book dot
grades, left square bracket, count, right square bracket dot s t u
Name, 2 left angled brackets, end l, semicolon.
Line 34, indented twice, out File, 2 left angled brackets, book dot
grades, left square bracket, count, right square bracket dot g p a, 2
left angled brackets, single quote, blank space, single quote.
Line 35, indented five times, 2 left angled brackets, book dot grades,
left square bracket, count, right square bracket, dot exam Score, left
square bracket 0, right square bracket, 2 left angled bracket, single
quote, blank space, single quote.
Line 36, indented five times, 2 left angled brackets, book dot grades,
left square bracket, count, right square bracket, dot exam Score, left
square bracket 1, right square bracket, 2 left angled bracket, single
quote, blank space, single quote.
Line 37, indented five times, 2 left angled brackets, book dot grades,
left square bracket, count, right square bracket, dot exam Score, left
square bracket 2, right square bracket, 2 left angled bracket, single
quote, blank space, single quote.
Line 38, indented five times, 2 left angled brackets, book dot grades,
left square bracket, count, right square bracket, dot exam Score, left
square bracket 3, right square bracket, 2 left angled bracket, single
quote, blank space, single quote, semicolon.
Line 39, indented twice, switch, left parenthesis, book dot grades,
left square bracket, count, right square bracket, dot course Grade,
right parenthesis.
Line 40, indented twice, right brace.
Line 41, indented three times, case upperacse A, colon, out File, 2
left angled brackets, 2 left angled brackets, single quote, uppercase

A, single quote, semicolon.
Line 42, indented seven times, break, semicolon.
Line 43, indented three times, case upperacse B, colon, out File, 2
left angled brackets, 2 left angled brackets, single quote, uppercase
B, single quote, semicolon.
Line 44, indented seven times, break, semicolon.
Line 45, indented three times, case upperacse C, colon, out File, 2
left angled brackets, 2 left angled brackets, single quote, uppercase
C, single quote, semicolon.
Line 46, indented seven times, break, semicolon.
Line 47, indented three times, case upperacse D, colon, out File, 2
left angled brackets, 2 left angled brackets, single quote, uppercase
D, single quote, semicolon.
Line 48, indented seven times, break, semicolon.
Back to Figure
Line 1, indented three times, case upperacse F, colon, out File, 2 left
angled brackets, 2 left angled brackets, single quote, uppercase F,
single quote, semicolon.
Line 2, indented seven times, break, semicolon.
Line 3, indented twice, right brace.
Line 4, indented twice, out File, 2 left angled brackets, end l,
semicolon.
Line 5, indented once, right brace.
Line 6, right brace.
Back to Figure
Back to Figure
Line 1, const int NUM underscore ROWS equals 100, semicolon.
Line 2, const int NUM underscore COLS equals 9, semicolon.
Line 3, dot.
Line 4, dot.
Line 5, dot.
Line 6, float alpha, left square bracket, NUM underscore ROWS,
right square bracket, left square bracket, NUM underscore COLS,
right square bracket, semicolon. Text pointing to NUM underscore

ROWS on line 6 reads, first dimension. Text pointing to NUM
underscore COLS on line 6 reads, second dimension.
Line 1, enum Day Type.
Line 2, left brace.
Line 3, indented once, Monday, comma, Tuesday, comma,
Wednesday, comma, Thursday, comma, Friday, comma, Saturday,
comma, Sunday.
Line 4, right brace, semicolon.
Line 5, int hi Temp, left square bracket, 52, right square bracket, left
square bracket, 7, right square bracket, semicolon.
Back to Figure
A code to the side reads as follows.
Line 1, 2 forward slash, Print temperature values.
Line 2, 2 forward slash, for third week, row 2.
Line 3, blank line.
Line 4, for, left parenthesis, day equals 0, semicolon, day less than
7, semicolon, day plus plus, right parenthesis.
LIne 5, indented once, c out, 2 left angled brackets, single quote,
blank space, single quote, 2 left angled brackets, hi Temp, left
square bracket, 2, right square bracket, left square bracket, day,
right square bracket, semicolon.
Back to Figure
A code to the side reads as follows.
Line 1, 2 forward slash, Initialize entire array to zero.
Line 2, blank line.
Line 3, for, left parenthesis, week equals 0, semicolon, week less
than 52, semicolon, week plus plus, right parenthesis.
Line 4, indented once, for, left parenthesis, day equals MONDAY,
semicolon, day less than or equal to SUNDAY, semicolon, day
equals, Day Type, left square bracket, day plus 1, right square
bracket, right parenthesis.
Line 5, hi Temp, left square bracket, week, right square bracket, left
square bracket, day, right square bracket, equals 0, semicolon.

Back to Figure
Line 1, enum Colors, left brace, RED, ORANGE, YELLOW <
GREEN, BLUE, INDIGO, VIOLET, right brace, semicolon.
Line 2, enum Makes.
Line 3, left brace.
Line 4, indented once, FORD, TOYOTA, HYUNDAI, JAGUAR,
CITROEN, BMW, FIAT, SAAB.
Line 5, right brace, semicolon.
Line 6, const int NUM underscore COLORS, equals 7, semicolon.
Line 7, const int NUM underscore MAKES equals 8, semicolon.
Line 8, blank line.
Line 9, float sales, left square bracket, NUM underscore COLORS,
right square bracket, left square bracket, NUM underscore MAKES,
right square bracket, semicolon, 2 forward slash, Percent of sales by
color.
Line 10, 2 forward slash, for each manufacturer.
Line 11, dot.
Line 12, dot.
Line 13, dot.
Line 14, sales, left square bracket, BLUE, right square bracket, left
square bracket, JAGUAR, right square bracket, equals 0.23,
semicolon, 2 forward slash, Blue cars make up 23 percent of.
Line 15, 2 forward slash, Jaguar sales.
Line 16, sales, left square bracket, RED, right square bracket, left
square bracket, FORD, right square bracket, equals 0.19,
semicolon, 2 forward slash, Blue cars make up 19 percent of.
Line 17, 2 forward slash, Ford sales.
Line 1, void, Another Func, left parenthesis, int beta, left square
bracket, right square bracket, left square bracket, 4, right square
bracket, right parenthesis.
Line 2, left brace.
Line 3, indented once, dot.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, right brace.
Back to Figure

A section of the stack containing 8 memory boxes labeled, beta, left
square bracket, 0, right square bracket, left square bracket, 0, right
square bracket, beta, left square bracket, 0, right square bracket,
left square bracket, 1, right square bracket, beta, left square
bracket, 0, right square bracket, left square bracket, 2, right square
bracket, beta, left square bracket, 0, right square bracket, left
square bracket, 3, right square bracket, beta, left square bracket, 1,
right square bracket, left square bracket, 0, right square bracket,
beta, left square bracket, 1, right square bracket, left square
bracket, 1, right square bracket, beta, left square bracket, 1, right
square bracket, left square bracket, 2, right square bracket, beta,
left square bracket, 1, right square bracket, left square bracket, 3,
right square bracket. The address labeled bet, left square bracket,
0, right square bracket, left square bracket, 0, right square bracket,
is titled base address.
Back to Figure
Line 1, const int NUM underscore ROWS, equals 10, semicolon.
Line 2, const int NUM underscore COLS, equals 20, semicolon.
typedef, int Array Type, left square bracket, NUM underscore
ROWS, right square bracket, left square bracket, NUM underscore
COLS, right square bracket, semicolon.
Back to Figure
Line 1, void Initialize, left parenthesis, Array Type table, comma, int
initial Val, right parenthesis.
Line 2, 2 forward slash, Pre, colon, initial Val has an appropriate
value.
Line 3, 2 forward slash, Post, colon, table, left square bracket, 0,
dot, dot, NUM underscore ROWS minus 1, right square bracket, left
square bracket, 0, dot, dot, NUM underscore COLS minus 1, right
square bracket, has been set to initial Val.
Line 4, left brace.
Line 5, indented once, int row, semicolon.
Line 6, indented once, int col, semicolon.
Line 7, indented once, for, left parenthesis, row equals 0, semicolon,
row less than NUM underscore ROWS, semicolon, row plus plus,

right parenthesis.
Line 8, indented twice, for, left parenthesis, col equals 0, semicolon,
col less than NUM underscore COLS, semicolon, col plus plus, right
parenthesis.
Line 9, indented three times, table, left square bracket, row, right
square bracket, left square bracket, col, right square bracket,
equals, initial Val, semicolon.
Line 10, right brace.
Back to Figure
Line 1, Array Type delta, semicolon.
Line 2, Array Type game, semicolon.
Line 3, blank line.
Line 4, Initialize, left parenthesis, delta, comma, 1, right parenthesis,
semicolon.
Line 5, Initialize, left parenthesis, gamma, comma, negative 1, right
parenthesis, semicolon.
Line 6, dot.
Line 7, dot.
Line 8, dot.
Back to Figure
Line 1, const int NUM underscore ROWS equals 50, semicolon.
Line 2, const int NUM underscore COLS equals 50, semicolon.
Line 3, blank line.
Line 4, int table, left square bracket, NUM underscore ROWS, right
square brackets, left square brackets, NUM underscore COLS, right
square brackets, semicolon.2 forward slash, A two hyphen
dimensional array.
Line 5, int row, semicolon, 2 forward slash, A row index.
Line 6, int col, semicolon, 2 forward slash, A column index.
Line 7, int total, semicolon, 2 forward slash, A variable for summing.
Back to Figure
Line 1, total equals 0, semicolon.
Line 2, for, left parenthesis, col equals 0, semicolon, col less than

NUM underscore COLS, semicolon, col plus plus, right parenthesis.
Line 3, indented once, total equals, total plus table, left square
bracket, 3, right square bracket, left square bracket, col, right
square bracket, semicolon.
Line 4, c out, 2 left angled brackets, double quotes, Row sum, colon,
double quotes, 2 left angled brackets, total, 2 left angled brackets,
end l, semicolon.
Back to Figure
Line 1, for, left parenthesis, row equals 2, semicolon, row less than
4, semicolon, row plus plus, right parenthesis.
Line 2, left brace.
Line 3, indented once, total equals 0, semicolon.
Line 4, indented once, for, left parenthesis, col equals 0, semicolon,
col less than NUM underscore COLS, semicolon, col plus plus, right
parenthesis.
Line 5, indented twice, total equals, total plus table, left square
bracket, row, right square bracket, left square bracket, col, right
square bracket, semicolon.
Line 6, indented once, c out, 2 left angled brackets, double quotes,
Row sum, colon, double quotes, 2 left angled brackets, total, 2 left
angled brackets, end l, semicolon.
Line 7, right brace.
Back to Figure
Line 1, table, left square bracket, 2, right square bracket, left square
bracket, 0, right square bracket, blank space, left square bracket, 2,
right square bracket, blank space, left square bracket, 1, right
square bracket, blank space, left square bracket, 2, right square
bracket, blank space, left square bracket, 2, right square bracket,
blank space, left square bracket, 2, right square bracket, blank
space, left square bracket, 3, right square bracket, blank space, dot,
dot, dot, left square bracket, 2, right square bracket, blank space,
left square bracket, NUM underscore COLS minus 1, right square
bracket.
Back to Figure

Line 1, table, left square bracket, 3, right square bracket, left square
bracket, 0, right square bracket, blank space, left square bracket, 3,
right square bracket, blank space, left square bracket, 1, right
square bracket, blank space, left square bracket, 3, right square
bracket, blank space, left square bracket, 2, right square bracket,
blank space, left square bracket, 3, right square bracket, blank
space, left square bracket, 3, right square bracket, blank space, dot,
dot, dot, left square bracket, 3, right square bracket, blank space,
left square bracket, NUM underscore COLS minus 1, right square
bracket.
Back to Figure
Line 1, int rows Filled, semicolon, 2 forward slash, Data is in 0, dot,
dot, rows Filled, minus 1.
Line 2, int cols Filled, semicolon, 2 forward slash, Data is on 0, dot,
dot, cols Filled, minus 1.
Back to Figure
Line 1, for, left parenthesis, row equals 0, semicolon, row less than
rows Filled, semicolon, row plus plus, right parenthesis.
Line 2, left brace.
Line 3, indented once, total equals 0, semicolon.
Line 4, indented once, for, left parenthesis, col equals 0, semicolon,
col less than cols Filled, semicolon, col plus plus, right parenthesis.
Line 5, indented twice, total equals, total plus table, left square
bracket, row, right square bracket, left square bracket, col, right
square bracket, semicolon.
Line 6, indented once, c out, 2 left angled brackets, double quotes,
Row sum, colon, double quotes, 2 left angled brackets, total, 2 left
angled brackets, end l, semicolon.
Line 7, right brace.
Back to Figure
Line 1, struct Two D Array.
Line 2, left brace.
Line 3, indented once, int rows Filled, semicolon, 2 forward slash,

Rows with actual data.
Line 4, indented once, int cols Filled, semicolon, 2 forward slash,
Columns with actual data.
Line 5, indented once, Array Type, table, semicolon, 2 forward slash,
Two hyphen dimensional array.
Line 6, right brace, semicolon.
Line 7, Two D Array structures, semicolon.
Back to Figure
Line 1, int Sum Rows, left parenthesis, Two D Array structure,
comma, int row Num, right parenthesis.
Line 2, 2 forward slash, This function returns the sum of.
Line 3, 2 forward slash, structure dot table, left square bracket, row
Num, right square bracket, left square bracket, 0, dot, dot, cols
Filled, right square bracket.
Line 4, left brace.
Line 5, indented once, int total equals 0, semicolon.
Line 6, indented once, for, left parenthesis, int col equals 0,
semicolon, col less than structure dot cols Filled, semicolon, col plus
plus, right parenthesis.
Line 7, indented twice, total equals, total plus, structure dot table,
left square bracket, row Num, right square bracket, left square
bracket, col, right square bracket, semicolon.
Line 8, indented once, return total, semicolon.
Line 9, right brace.
Back to Figure
Line 1, void Print Row Sums, left parenthesis, Two D Array
structures, right parenthesis.
Line 2, left brace.
Line 3, indented once, for, left parenthesis, int row equals 0,
semicolon, row less than structure dot rows Filled, semicolon, row
plus plus, right parenthesis.
Line 4, indented once, left brace.
Line 5, indented twice, c out, 2 left angled bracket, double quotes,
Row, double quotes, 2 left angled brackets, row, 2 left angled
brackets, double quotes, colon, double quotes, 2 left angled

brackets, Sum Rows, left parenthesis, structure, comma, row, right
parenthesis.
Line 6, indented five times, 2 left angled brackets, end l, semicolon.
Line 7, indented once, right brace.
Line 8, right brace.
Back to Figure
Line 1, int Sum Cols, left parenthesis, Two D Array structure,
comma, int col Num, right parenthesis.
Line 2, 2 forward slash, This function returns the sum of.
Line 3, 2 forward slash, structure dot table, left square bracket, 0,
dot, dot, rows Filled, right square bracket, left square bracket, col
Num, right square bracket.
Line 4, left brace.
Line 5, indented once, int total equals 0, semicolon.
Line 6, indented once, for, left parenthesis, int row equals 0,
semicolon, row less than structure dot rows Filled, semicolon, row
plus plus.
Line 7, indented twice, total equals, total plus structure dot table, left
square bracket, row, right square bracket, left square bracket, col
Num, right square bracket, semicolon.
Line 8, indented once, return total, semicolon.
Line 9, right brace.
Back to Figure
Line 1, int table, left square bracket, 2, right square bracket, left
square bracket, 3, right square bracket, equals.
Line 2, left brace.
Line 3, indented once, left brace, 14, comma, 3, comma, negative 5,
right brace, comma.
Line 3, indented once, left brace, 0, comma, 46, comma, 7, right
brace.
Line 4, right brace, semicolon.
Back to Figure

Line 1, void Zero Array, left parenthesis, Two D Array structure, right
parenthesis.
Line 2, 2 forward slash, This function assigns zero to every element
of the.
Line 3, 2 forward slash, array member of structure.
Line 4, left brace.
Line 5, indented once, for, left parenthesis, int row equals 0,
semicolon, row less than structure dot rows Filled, semicolon, row
plus plus, right parenthesis.
Line 6, indented twice, for, left parenthesis, int col equals 0,
semicolon, col less than structure dot cols Filled, semicolon, col plus
plus, right parenthesis.
Line 7, indented threr times, structure dot table, left square bracket,
row, right square bracket, left square bracket, col, right square
bracket, eqials 0, semicolon.
Line 8, right brace.
Back to Figure
Line 1, hashtag include, left angled bracket, i o man i p, right angled
bracket, 2 forward slash, For set w, left parenthesis, right
parenthesis.
Line 2, dot, dot, dot.
Line 3, void Print Array, left parenthesis, Two D Array structure, right
parenthesis.
Line 4, 2 forward slash, This function outputs the values stored in
the table by row.
Line 5, left brace.
Line 6, indented once, for, left parenthesis, int row equals 0,
semicolon, row less than structure dot rows Filled, semicolon, row
plus plus, right parenthesis.
Line 7, indented once, left brace.
Line 8, indented twice, for, left parenthesis, int col equals 0,
semicolon, col less than structure dot cols Filled, semicolon, col plus
plus, right parenthesis.
Line 9, indented three times, c out, 2 left angled brackets, set w, left
parenthesis, 15, right parenthesis, 2 left angled brackets, structure
dot table, left square bracket, row, right square bracket, left square
bracket, col, right square bracket, semicolon.

Line 10, indented twice, c out, 2 left angled brackets, end l,
semicolon.
Line 11, indented once, right brace.
Line 12, right brace.
Back to Figure
Line 1, for, left parenthesis, row equals min Row, semicolon, row
less than rows Filled, semicolon, row plus plus, right parenthesis.
Line 2, indented once, for, left parenthesis, col equals min Col,
semicolon, col less than cols Filled, semicolon, col plus plus, right
parenthesis.
Line 3, dot, 2 forward slash, Whatever processing is required.
Line 4, dot.
Line 5, dot.
Back to Figure
Line 1, for, left parenthesis, col equals min Col, semicolon, col less
than cols Filled, semicolon, col plus plus, right parenthesis.
Line 2, indented once, for, left parenthesis, row equals min Row,
semicolon, row less than rows Filled, semicolon, row plus plus, right
parenthesis.
Line 3, dot, 2 forward slash, Whatever processing is required.
Line 4, dot.
Line 5, dot.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: include, using namespacxe,
const, int, typedef, struct, void, c in, c out, and return.
Line 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, 2 forward slash, This program reads in and manipulates data
in two dimensional.
Line 3, 2 forward slash, array bound into a record along with tha
number of actual values.
Line 4, 2 forward slash, stored in the array.
Line 5, 2 forward slash followed by asterisk till the end of the line.

Line 6, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 7, hashtag include, left angled bracket, i o man i p, right angled
bracket, 2 forward slash, For set w, left parenthesis, right
parenthesis.
Line 8, using namespace s t d, semicolon.
Line 9, blank line.
Line 10, const int NUM unserscore ROWS equals 6, semicolon.
Line 11, const int NUM underscore COLS, equals 5, semicolon.
Line 12, typedef int Array Type, left square bracket, NUM
underscore ROWS, right square bracket, left square bracket, NUM
underscore COLS, right square bracket, semicolon.
Line 13, struct Two D Array
Line 14, left brace.
Line 15, indented once, int rows Filled, semicolon, 2 forward slash,
Number of rows with actual data.
Line 16, indented once, it cols Filled, semicolon, 2 forward slash,
Number of columns with actual data.
Line 17, indented once Array type table, semicolon, Two hyphen
dimensional array.
Line 18, right brace, semicolon.
Line 19, blank line.
Line 20, void Print Row Sums, left parenthesis, Two D Array
structure, right parenthesis, semicolon.
Line 21, 2 forward slash, This function outputs the sum of the rows
in the structure.
Line 22, int Sum Rows, left parenthesis, Two D Array structure, int
row Num, right parenthesis, semicolon.
Line 23, 2 forward slash, This function return the sum of.
Line 24, 2 forward slash, structure dot table, left square bracket, row
Num, right square bracket, left square bracket, 0, dot, dot, cols
Filled, right square bracket.
Line 25, void, Print Array, left parenthesis, Two D Array structure,
right parenthesis, semicolon.
Line 26, 2 forward slash, This functions outputs the values stored in
the table by row.
Line 27, void Print Column Sums, left parenthesis, Two D Array
sreucture, right parenthesis, semicolon.
Line 28, 2 forward slash, This function outputs the sum of the

columns in the structure.
Line 29, int Sum Cols, left parenthesis, Two D Array structure,
comm, int col Num, right parenthesis, semicolon.
Line 30, 2 forward slash, This function returns the sum of.
Line 31, 2 forward slash, structure dot, table, left square bracket, 0,
dot, dot, rows Filled, right square bracket, left square bracket, col
Num, right square bracket.
Line 32, blank line.
Line 33, int main, left parenthesis, right parenthesis.
Line 34, left brace.
Line 35, indented once, Two D Array structure, semicolon.
Line 36, indented once, 2 forward slash, Number of rwos and
columns is prompted for and read.
Line 37, indented once, c out, 2 left angled brackets, double quotes,
Enter the number of rows and the number of columns, double
quotes.
Line 38, indented three times, 2 left angled brackets, end l,
semicolon.
Line 39, indented once, c in, 2 right angled brackets, structure dot
rows Filled, 2 right angled brackets, structure dot cols Filled,
semicolon.
Line 40, 2 forward slash, Values are read in by row.
Line 41, indented once, c out, 2 left angled brackets, double quotes,
Enter the data one row per line, double quotes, 2 left angled
brackets, end l, semicolon.
Line 42, indented once, for, left parenthesis, int rows, equals 0,
semicolon, rows less than structure dot rows Filled, semicolon, rows
plus plus, right parenthesis.
Line 43, indented twice, for, left parenthesis, int cols equals 0,
semicolon, cols less than structure dot cols Filled, semicolon, cols
plus plus, right parenthesis.
Line 44, indented three times, c in, 2 right angled brackets, structure
dot table, lef square bracket, rows, right square bracket, left square
bracket, cols, right square bracket, semicolon.
Line 45, indented once, Print Array, left parenthesis, structure, right
parenthesis, semicolon.
Line 46, indented once, Print Row Sums, left parenthesis, structure,
right parenthesis, semicolon.
Line 47, indented once, Print Column Sums, left parenthesis,

structure, right parenthesis, semicolon.
Line 48, indented once, return 0, semicolon.
Line 49, right brace.
Back to Figure
Line 1, Enter the number of rows and the number of columns.
Line 2, 4, 5.
Line 3, Enter the data one row per line.
Line 4, 1, 2, 3, 4, 5.
Line 5, 5, 4, 3, 2, 1.
Line 6, 6, 7, 8, 9, 0.
Line 7, 0, 9, 8, 7, 6.
Line 8, indented three times,1, 2, 3, 4, 5.
Line 9, indented three times, 5, 4, 3, 2, 1.
Line 10, indented three times, 6, 7, 8, 9, 0.
Line 11, indented three times, 0, 9, 8, 7, 6.
Line 12, Row Sums.
Line 13, Row 0, colon, 15.
Line 14, Row 1, colon, 15.
Line 15, Row 2, colon, 30.
Line 16, Row 3, colon, 30.
Line 17, Column Sums.
Line 18, Column 0, colon, 12.
Line 19, Column 1, colon, 22.
Line 20, Column 2, colon, 22.
Line 21, Column 3, colon, 22.
Line 22, Column 4, colon, 12.
Back to Figure
Line 1, typedef int Week Type, left square bracket, 7, right square
bracket, semicolon, 2 forward slash, Array type for 7 temperature
readings.
Line 2, Week Type hi Temp, left square bracket, 52, right square
bracket, semicolon, 2 forward slash, Array of 52 Week Type arrays.
Back to Figure

Line 1, int Maximum, left parenthesis, const Week Type data, right
parenthesis.
Line 2, 2 forward slash, Post, colon, Function return value is the
maximum value in data, left square bracket, 0, dot, dot, 6, right
square bracket.
Line 3, blank line.
Line 4, left brace.
Line 5, indented once, int max, semicolon, 2 forward slash,
Temporary max value.
Line 6, indented once, int index, semicolon, 2 forward slash, Loop
control and index variable.
Line 7, blank line.
Line 8, indented once, max equals, data, left square bracket, 0, right
square bracket, semicolon.
Line 9, indented once, for, left parenthesis, index equals 1,
semicolon, index less than 7, semicolon, index plus plus, right
parenthesis.
Line 10, indented twice, if, left parenthesis, data, left square bracket,
index, right square bracket, greater than max, right parenthesis.
Line 11, indented three times, max, equals, data, left square
bracket, index, right square bracket, semicolon.
Line 12, indented once, return max, semicolon.
Line 13, right brace.
Back to Figure
Text below the figure reads, the components of hi Temp are one
dimensional arrays of type Week Type.
Back to Figure
Line 1, c out, 2 left angled brackets, double quotes, Week
Maximum, double quotes, 2 left angled brackets, end l.
Line 2, indented three times, 2 left angled brackets, double quotes,
Number Temperature, double quotes, 2 left angled brackets, end l,
semicolon.
Line 3, for, left parenthesis, week equals 0, semicolon, week less
than 52, semicolon, week plus plus, right parenthesis.
Line 4, indented once, c out, 2 left angled brackets, set w, left

parenthesis, 6, right parenthesis, 2 left angled brackets, week.
Line 5, indented three times, 2 left angled brackets, set w, left
parenthesis, 9, right parenthesis, 2 left angled brackets, Maximum,
left angled bracket, hi Temp, left square bracket, week, right square
bracket, right parenthesis, 2 left angled brackets, end l, semicolon.
Line 1, const int NUM underscore ITEMS, equals 100, semicolon.
Line 2, const int NUM underscore STORES, equals 10, semicolon.
LIne 3, typedef int Sales Type, left square bracket, NUM underscore
STORES, right square bracket, left square bracket, 12, right square
bracket, left square bracket, NUM underscore ITEMS, right square
bracket, semicolon.
Line 4, blank line.
Line 5, Sales Type sales, semicolon, 2 forward slash, Array of sales
figures.
Line 6, int item, semicolon.
Line 7, int store, semicolon.
Line 8, int month, semicolon.
Line 9, int number Sold, semicolon.
Line 10, int current Month, semicolon.
Back to Figure
The three dimensional grid is in the shape of a cuboid. The
dimensions of the cuboid are labeled months, NUM underscore
STORES, and NUM underscore ITEMS.
Back to Figure
Line 1, for, left parenthesis, item equals 0, semicolon, item less than
NUM underscore ITEMS, semicolon, item plus plus, right
parenthesis.
Line 2, left brace.
Line 3, indented once, number Sold equals 0, semicolon.
Line 4, indented once, for, left parenthesis, store equals 0,
semicolon, store less than NUM underscore STORES, semicolon,
store plus plus, right parenthesis.
Line 5, indented twice, for, left parenthesis, month equals 0,
semicolon, month less than or equal to current Month, semicolon,

month plus plus, right parenthesis.
Line 6, indented three times, number Sold, equals, number Sold plus
sales, left square bracket store, right square bracket, left square
bracket, month, right square bracket, left square bracket, item , right
square bracket, semicolon.
Line 7, indented once, c out, 2 left angled brackets, double quotes,
Item hashtag, double quotes, 2 left angled brackets, item, 2 left
angled brackets, double quotes, Sales to date, equals, double
quotes, 2 left angled brackets, number Sold.
Line 8, indented four times, 2 left angled brackets, end l, semicolon.
Line 9, right brace.
Back to Figure
Line 1, for, left parenthesis, store equals 0, semicolon, store less
than NUM underscore STORES, semicolon, stores plus plus, right
parenthesis.
Line 2, left brace.
Line 3, indented once, number Sold equals 0, semicolon.
Line 4, indented once, for, left parenthesis, item equals 0,
semicolon, item less than NUM underscore ITEMS, semicolon, item
plus plus, right parenthesis.
Line 5, indented twice, for, left parenthesis, month equals 0,
semicolon, month less than or equal to current Month, semicolon,
month plus plus, right parenthesis.
Line 6, indented three times, number Sold, equals, number Sold plus
sales, left square bracket store, right square bracket, left square
bracket, month, right square bracket, left square bracket, item , right
square bracket, semicolon.
Line 7, indented once, c out, 2 left angled brackets, double quotes,
Store hashtag, double quotes, 2 left angled brackets, store, 2 left
angled brackets, double quotes, Sales to date, equals, double
quotes, 2 left angled brackets, number Sold.
Line 8, indented four times, 2 left angled brackets, end l, semicolon.
Line 9, right brace.
Back to Figure

Line 1, enum Departments, left brace, uppercase A, uppercase B,
uppercase C, uppercase D, uppercase E, uppercase F, uppercase
G, right brace, semicolon.
Line 2, const int NUM underscore DEPTS equals 7, semicolon.
Line 3, type def, int Sales Type, left square bracket, NUM
underscore STORES, right square bracket, left square bracket, 12,
right square bracket, left square bracket, NUM underscore ITEMS,
left square bracket, NUM underscore DEPTS, right square brackets,
semicolon.
Back to Figure
From top to bottom, the individual rows of the stack are labeled from
0 to 100, enclosed in square bracket. Text pointing to the row
labeled 2 reads, The number of times a grade of 2 occurs, left
parenthesis, not often comma, we trust excalamtion mark, right
parenthesis. Text pointing to the row labeled 75 reads, The number
of times a grade of 75 occurs. Text pointing to the row labeled 100
reads, The number of times a grade of 100 occurs.
Back to Figure
Line 1, struct Grade Statistics.
Line 2, left brace.
Line 3, indented once, int num Grades, semicolon, 2 forward slash,
Number of grades.
Line 4, indented once, float average, semicolon, 2 forward slash,
Average grade.
Line 5, indented once, int highest, semicolon, 2 forward slash,
Highest grade.
Line 6, indented once, int lowest, semicolon, 2 forward slash, Lowest
grade.
Line 7, indented once, int above Average, semicolon, 2 forward
slash, Number of grades above the average.
Line 8, indented once, int below Average, semicolon, 2 forward
slash, Number of grades below the average.
Line 9, indented once, int grades, left square bracket, 101, right
square bracket, semicolon, 2 forward slash, Array of grades.
Line 10, right brace, semicolon.

Back to Figure
The root node is labeled, main. The root node consists of three child
nodes: open Files, calculate statistics, print results. The input and
output to open files are labeled in Data and out Data respectively.
The input and output to calculate statistics is labeled in Data
statistics. The input and output to print results is labeled out Data
statistics. The node calculate statistics consists of six child nodes:
input grade, clacualte average, calcualte highest, calculate lowest,
calculate above average, calculate below average. The input and
output to input grade is labeled in Data statistics. The input and
output to calculate average is labeled statistics. The input and output
to calculate highest is labeled statistics. The input and output to
calculate lowest is labeled statistics. The input and output to
calculate above average is labeled statistics. The input and output to
calculate below average is labeled statistics.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: include, using namespace,
struct, int, float, and void.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, This program calculates the average,
comma, high schore comma, low score comma
Line 3, 2 forward slash, number above the average comma, and
number below the average for.
Line 4, 2 forward slash, a file of test scores.
Line 5, 2 forward slash, Assumption, colon, File contains at least one
non zero value.
Line 6, 2 forward slash followed by asterisk till the end of the line.
Line 7, blank line.
Line 8, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 9, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 10, hashtag include, left angled bracket, i o man i p, right
angled bracket.
Line 11, using namespace s t d, semicolon.

Line 12 , blank line.
Line 13, struct Grade Statistics.
Line 14, left brace.
Line 15, indented once, int num Grade, semicolon, 2 forward slash,
Number of grades.
Line 16, indented once, float average, semicolon, 2 forward slash,
Average grade.
Line 17, indented once, int highest, semicolon, 2 forward slash,
Highest grade.
Line 18, indented once, int lowest, semicolon, 2 forward slash,
Lowest grade.
Line 19, indented once, int above Average, semicolon, 2 forward
slash, Number of grades above the average.
Line 20, indented once, int below Average, semicolon, 2 forward
slash, Number of grades below the average.
Line 21, indented once, int grades, left square bracket, 101, right
square bracket, semicolon, 2 forward slash, Array of grades.
Line 22, right brace, semicolon.
Line 23, blank line.
Line 24, 2 forward slash, Declare function prototype.
Line 25, void, Calculate Statistics, left parenthesis, Grade Statistics
ampersand statistics, comma, if stream ampersand in Data, right
parenthesis, semicolon.
Line 26, 2 forward slash, Post, colon, Data has been read and
statistics calculated.
Line 27, void, Open Files, left parenthesis, if stream ampersand in
Data, comma, of stream ampersand out Data, right parenthesis,
semicolon.
Line 28, 2 forward slash, Post, colon, File names have been
prompted for and files are opened, semicolon.
Line 29, 2 forward slash, Input file name has been written on output
file.
Line 30, void, Input Grades, left parenthesis, Grade Statistics,
ampersand statistics, comma, if stream ampersand, in Data, right
parenthesis, semicolon.
Line 31, 2 forward slash, Pre, colon, in Data is assigned and not
empty.
Line 32, 2 forward slash, Post, colon, Grades have been read from
in Data comma.

Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: void, int, if, return, string, end l,
c in, and c out.
Line 1, 2 forward slash, num Grades is the number of grades in
Data.
Line 2, void, Calculate Average, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis, semicolon.
Line 3, 2 forward slash, Post, colon, Average grade has been
calculated.
Line 4, void, Calculate Highest, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis, semicolon.
Line 5, 2 forward slash, Post, colon, Highest grade has been
calculated.
Line 6, void, Calculate Lowest, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis, semicolon.
Line 7, 2 forward slash, Post, colon, Return value is the lowest
grade.
Line 8, void, Calculate Above Average, left parenthesis, Grade
Statistics ampersand statistics, right parenthesis, semicolon.
Line 9, 2 forward slash, Post, colon, Number of grades above the
average has been calculated.
Line 10, void, Calculate Below Average, left parenthesis, Grade
Statistics ampersand statistics, right parenthesis, semicolon.
Line 11, 2 forward slash, Post, colon, Number of grades below the
average has been calculated.
Line 12, void, Print Results, left parenthesis, Grade Statistics
statistics, of stream ampersand out Data, right parenthesis,
semicolon.
Line 13, 2 forward slash, Pre, colon, out Data has been opened.
Line 14, 2 forward slash, Post, colon, Output has been written on
out Data
Line 15, blank line.
Line 16, int main, left parenthesis, right parenthesis.
Line 17, left brace.
Line 18, indented once, Grade Statistics statistics, semicolon.
Line 19, indented once, 2 forward slash, Declare and open files.
Line 20, indented once, if stream in Data, semicolon.

Line 21, of stream out Data, semicolon.
Line 22, indented once, Open Files, left parenthesis, in Data, out
Data, right parenthesis, semicolon.
Line 23, indented once, if, left parenthesis, exclamation mark, in
Data, 2 vertical bars, exclamation mark, out Data, right parenthesis.
Line 24, indented once, left brace.
Line 25, indented twice, c out, 2 left angled brackets, double quotes,
Files not opened successfully dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 26, indented twice, return 1, semicolon.
Line 27, indented once, right brace.
Line 28, blank line.
Line 29, indented once, Calculate Statistics, left parenthesis,
statistics, comma, in Data, right parenthesis.
Line 30, indented once, Print Results, left parenthesis, statistics,
comma, out Data, right parenthesis, semicolon.
Line 31, indented once, in Data dot close, left parenthesis, right
parenthesis,semicolon.
Line 32, indented once, out Data dot close, left parenthesis, right
parenthesis, semicolon
Line 33, indented once, return 0, semicolon.
Line 34, right brace.
Line 35, blank line.
Line 36, 2 forward slash followed by asterisks till the end of the line.
Line 37, blank line.
Line 38, void, Open Files, left parenthesis, if stream ampersand text,
comma, of stream ampersand, out File, right parenthesis.
Line 39, left brace.
Line 40, indented once, string in File Name, semicolon.
Line 41, indented once, string out File Name, semicolon.
Line 42, indented once, c out, 2 left anlged brackets, double quotes,
Enter the name of the fiel to be processed, double quotes.
Line 43, indented four times, 2 left angled brackets, end l,
semicolon.
Line 44, indented once, c in, 2 right angled brackets, in File Name,
semicolon.
Line 45, indented once, text dot open, left parenthesis, in File Name
dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.

Line 46, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the output file, double quotes, 2 left angled
brackets, end l, semicolon.
Line 47, indented once, c in, 2 right angled brackets, out File Name,
semicolon.
Line 48, indented once, out File dot open, left parenthesis, out File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 49, indented once, out File, 2 left angled brackets, double
quotes, Analysis of exams on file, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, 2 left angled
brackets, semicolon.
Line 50, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: void, int, for, while.
Line 1, 2 forward slash followed by asterisk till the nd of the line,.
Line 2, blank line.
Line 3, void Calculate Average, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis.
Line 4, left brace.
Line 5, indented once, int sum equals 0, semicolon.
Line 6, indented once, 2 forward slash, Sum number of grades for
each index times the index.
Line 7, indented once, for, left parenthesis, int index equals 0,
semicolon, index less than or equal to 100, semicolon, index plus
plus, right parenthesis.
Line 8, indented twice, sum equals, sum plus statistics dot grades,
left square bracket, index, right square bracket, asterisk, index.
Line 9, indented once, statistics dot average, equals static
underscore case, left angled bracket, float, right angled bracket, left
parenthesis, sum, right parenthesis, forward slash.
Line 10, indented 11 times, static underscore cast, left angled
bracket, float, right angled bracket, left parenthesis, statistics dot
num Grades, right parenthesis, semicolon.
Line 11, right brace.
Line 12, blank line.

Line 13, 2 forward slash followed by asterisk till the end of the line.
Line 14, blank line.
Line 15, void, Input Grades, left parenthesis, Grade Statistics
ampersand statistics, comma, if stream ampersand in Data, right
parenthesis.
LIne 16, left brace.
Line 17, indented once, int grade, semicolon.
Line 18, indented once, 2 forward slash, Zero out the array of
counters.
Line 19, indented once, for, left parenthesis, int index equals 0,
semicolon, index less than or equal to 100, semicolon, index plus
plus, right parenthesis.
Line 20, indented twice, statistics dot grades, left square bracket,
index, right square bracket, equals 0, semicolon.
Line 21, indented once, statistics dot num Grades, equals 0,
semicolon.
Line 22, indented once, in Data, 2 right angled brackets, grade,
semicolon, 2 forward slash Priming rod.
Line 23, indented once, while, left angled bracket, in Data, right
angled bracket.
Line 24, indented once, left brace, 2 forward slash Process data.
Line 25, indented twice, statistics dot grades, left square bracket,
grade, right square bracket, plus plus, semicolon.
Line 26, indented twice, statistics dot num Grades plus plus,
semicolon.
Line 27, indented twice, in Data, 2 right angled brackets, grade,
semicolon, 2 forward slash, Subsequent reads.
Line 28, indented once, right brace.
Line 29, right brace.
Line 30, blank line.
Line 31, 2 forward slash followed by asterisks till the end of the line.
Line 32, blank line.
Line 33, void Calculate Lowest, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis.
Line 34, left brace.
Line 35, 2 forward slash, Index of first non zero grade from the
bottom is the low grade.
Line 36, indented once, int low Grade equals 0, semicolon.
Line 37, indented once, while, left parenthesis, statistics dot grades,

left square bracket, low Grade, right square bracket, 2 equal to
symbols, 0, right parenthesis.
Line 38, indented three times,low Grade plus plus, semicolon.
Line 39, indented twice, statistics dot lowest equals, low Grade,
semicolon.
Line 40, right brace.
Line 41, 2 forward slash followed by asterisk till the end of the line.
Line 42, blank line.
Line 43, void Calculate Hghest, left parenthesis, Grade Statistics
ampersand statistics, right parenthesis.
Line 44, left brace.
Line 45, indented once, 2 forward slash, Index of first non zero
grade from the top is the high grade.
Line 46, indented once, int high Grade equals 100, semicolon.
Line 47, indented once, while, left parenthesis, statistics dot grades,
left square bracket, high Grade, right square bracket, 2 equal to
symbols, 0, right parenthesis.
Line 48, indented twice, high Grade minus minus, semicolon.
Line 49, indented once, statistics dot highest equals, high Grade,
semicolon.
Line 50, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: void, int, for, and end l.
Line 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, blank line.
Line 3, void, Calculate Above Average, left parenthesis Grade
Statistics ampersand, statistics, right parenthesis.
Line 4, left brace.
Line 5, indented once, int average Plus, equals, left parenthesis int,
right parenthesis, left parenthesis, statistics dot average, right
parenthesis, plus 1, semicolon.
Line 6, indented once, int index, semicolon.
Line 7, indented once, int number equals 0, semicolon.
Line 8, indented once,2 forward slash, Sum number of grades above
average.
Line 9, indented once, for, left parenthesis, index equals average

Plus, semicolon, index less than or equal to 100, semicolon, index
plus plus, right parenthesis.
Line 10, indented twice, number equals, number plus statistics dot
grades, left square bracket, index, right square bracket, semicolon.
Line 11, indented once, statistics dot above Average, equals
number, semicolon.
Line 12, right brace.
Line 13, blank line.
Line 14, 2 forward slash followed by asterisk till the end of the line.
Line 15, blank line.
Line 16, void Calculate Below Average, left parenthesis, Grade
Statistics ampersand statistics, right parenthesis.
Line 17, left brace.
Line 18, indented once, int trucated Average, equals left
parenthesis, int, right parenthesis, left parenthesis, statistics dot
average, right parenthesis, semicolon.
Line 19, indented once, int index, semicolon.
Line 20, indented once, int number equals 0, semicolon.
Line 21, indented once, 2 forward slash, Sum of number of grades
at or below average.
Line 22, indented once, for, left parenthesis, index equals 0,
semicolon, index less than or equal to truncated Average,
semicolon, index plus plus, right parenthesis.
Line 23, indented twice, number equals, number plus, statistics dot
grades, left square bracket, index, right square bracket, semicolon.
Line 24, indented once, statistics dot below Average equals number,
semicolon.
Line 25, right brace.
Line 26, blank line.
Line 27, 2 forward slash followed by asterisk till the end of the line.
Line 28, blank line.
Line 39, void Calculate Statistics, left parenthesis, Grade Statistics
ampersand statistics, comma, of stream ampersand in Data, right
parenthesis.
Line 40, left brace.
Line 41, indented once, 2 forward slash Read and process grades.
Line 42, indented once, Input Grades, left parenthesis, statistics,
comma, in Data, right parenthesis, semicolon.
Line 43, indented once, Calculate Average, left parenthesis,

statistics, right parenthesis, semicolon.
Line 44, indented once, Calculate Highest, left parenthesis,
statistics, right parenthesis, semicolon.
Line 45, indented once, Calculate Lowest, left parenthesis, statistics,
right parenthesis, semicolon.
Line 46, indented once, Calculate Above Average, left parenthesis,
statistics, right parenthesis, semicolon.
Line 47, indented once, Calculate Below Average, left parenthesis,
statistics, right parenthesis, semicolon.
Line 48, right brace.
Line 49, blank line.
Line 50, 2 forward slash followed by asterisk till the end of the line.
Line 51, blank line.
Line 52, void Print Results, left parenthesis, Grade Statistics
statistics, comma, of stream ampersand out Data, right parenthesis.
Line 53, left brace.
Line 54, indented once, out Data, 2 left angled brackets, double
quotes, The number of grades is, double quotes, 2 left angled
brackets, statistics dot num Grades.
Line 55, indented five times, 2 left angled brackets, end l, semicolon.
Line 56, indented once, out Data, 2 left angled brackets, fixed, 2 left
angled brackets, set precision, left parenthesis, 2 right parenthesis.
Line 57, indented five times, 2 left angled brackets, double quotes,
The average grade is, double quotes, 2 left angled brackets,
statistics dot average, 2 left angled brackets, end l, semicolon.
Line 58, indented once, out Data, 2 left angled brackets, double
quotes, The highest grade is , double quotes, 2 left angled brackets,
statistics dot highest, 2 left angled brackets, end l, semicolon.
Line 59, indented once, out Data, 2 left angled brackets, double
quotes, The lowest grade is, double quotes, 2 left angled brackets,
statistics dot lowest, 2 left angled brackets, end l, semicolon.
Line 60, indented once, out Data, 2 left angled brackets, double
quotes, The number of grades above the average is, double quotes
Line 61, indented five times, 2 left angled brackets, statistics dot
above average, 2 left angled brackets, end l, semicolon.
Line 62, indented once, out Data, 2 let angled brackets, double
quotes, The number of grades below the average is, double quotes.
Line 63, indented five times, 2 left angled brackets, statistics dot

below Average, 2 left angled brackets, end l, semicolon.
Line 64, right brace.
Back to Figure
The values are displayed in a table format with 3 columns. Row
entries are as follows. Row 1: 88, 75, 99. Row 2: 87, 75, 87. Row 3:
88, 78, 44. Row 4: 66, 80, 34. Row 5: 55, 80, 0. Row 6: 56, 90, 100.
Back to Figure
LIne 1, Analysis of exam file stat dot data.
Line 2, blank line.
LIne 3, The number of grades is 18.
Line 4, The average grade is 71.22.
Line 5, The highest grade is 100.
Line 6, The lowest grade is 0.
Line 7, The number of grades above the average is 12.
Line 8, The number of grades below the average is 6.
Back to Figure
Line 1, void, Open Files, left parenthesis, if stream ampersand text,
comma, of stream ampersand out File, right parenthesis, left brace.
Line 2, indented twice, string out File Nmae, semicolon, 2 forward
slash, User hyphen specified output file name.
Line 3, indented twice, string in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 4, blank line.
Line 5, indented twice, 2 forward slash, Add a G U I widget for input.
Line 6, indented twice, File Dialog choose Input, left parenthesis,
double quotes, Choose the file to be processed, double quotes, right
parenthesis, semicolon.
Line 7, indented twice, in File Name equals choose Input dot display,
left parenthesis, right parenthesis, semicolon.
Line 8, indented twice, text dot open, left parenthesis, in File Nmae
dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 9, blank line.

Line 10, indented twice, 2 forward slash, Add a G U I widget for
output.
Line 11, indented twice, New File Dialog choose Output, left
parenthesis, double quotes, Choose the name of the output file,
double quotes, right parenthesis, semicolon.
Line 12, indented twice, out File Name, equals choose Output dot
display, left parenthesis, right parenthesis, semicolon.
Line 13, indented twice, out File dot open, left parenthesis, out File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 14, , indented once, right brace.
Back to Figure
The first file dialog widget when the G U I program exeuctes. The
widget displays the files contained in a particular folder. The dialog
box has a Cancel and Open button.
Back to Figure
The second file dialog widget when the G U I program exeuctes. The
file name is entered inside the Save As field. The dialog box has a
Cancel and Save button.
Back to Figure
The columns are labeled: Group 1, Group 2, Group 3, and Group 4.
The cells contain dash marks. The row entries, presented in the
format, Row label: number of dash marks in group 1, number of
dash marks in group 2, number of dash marks in group 3, number of
dash group 4, are as follows. Class 1: 8, 2, 14, 6. Class 2: 12, 2, 6,
3. Class 3: 2, 9, 18, 3. Class 4: 6, 9, 12, 2.
Back to Figure
The two dimensional array grid has four columns labeled : 0, 1, 2, 3
enclosed in square brackets. The four rows are labeled: 0, 1, 2, 3
enclosed in square brackets. The cell in the fourth row and second
column is highlighted. Text pointing to this cell reads, votes left
square bracket, 3, right square bracket, left square bracket, 1, right

square bracket, is a counter for votes for rock group 2, class 4. The
array stack labeled name consists of four rows labeled: 0, 1, 2, 3
enclosed in square brackets. The second row is highlighted and text
pointing to it reads, name left square bracket, 1, right square
bracket, us name of rock group number 2.
Back to Figure
The root node is labelled main. The root node has six child nodes
labeled: open files, get rock group names, set votes to zero, write
report, write totals per rock group, and write totals per level. The
input and output of the open files, is labeled some File. The output
from the get rock group names is labeled name. The output from the
set votes to zero is labeled votes. The input to the write report is
labeled report file and votes name. The output from write report is
labeled report File. The input to the write totals per rock group is
labeled votes name and report File. The output from the write totals
per rock group is labeled report file. The input to the write totals per
level is labeled votes and report file. The output from the write totals
per level is labeled report file.
Back to Figure
Program Code.
Line 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, 2 forward slash, Favorite Rock Group program.
Line 3, 2 forward slash, This program reads votes represented by
level number and
Line 4, 2 forward slash, rock group number from a data file, comma,
calculates the sems per.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: include, using namespace,
const, int, type def, void, string, if, while.
Line 1, 2 forward slash, level and per rock group, comma, and writes
all totals to an.
Line 2, 2 forward slash, output file.

Line 3, 2 forward slash followed by asterisk till the end of the line.
Line 4, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 5, hashtag include, left angled bracket, i o manip, right angled
bracket, 2 forward slash, For set w, left parenthesis, right
parenthesis.
Line 6, hashtag include, left angled bracket, f stream, right angled
bracket, 2 forward slash, For file I slash O.
Line 7, hashtag include, left angled bracket, string, right angled
bracket, 2 forward slash, For string type.
Line 8, blank line.
Line 9, using namespace s t d, semicolon.
Line 10, blank line.
Line 11, const int NUM underscore LEVELS, equals 4, semicolon.
Line 12, const int NUM underscore ROCK underscore GROUPS,
equals, 4, semicolon.
Line 13, type def int Vote Array, left square bracket, NUM
underscore LEVELS, right square bracket, left square bracket, NUM
underscore ROCK underscore GROUPS, right square bracket,
semicolon.
Line 14, blank line.
Line 15, void Get Names, left parenthesis, string names, left square
bracket, right square bracket, right parenthesis, semicolon.
Line 16, 2 forward slash, Rock group names have been prompted
for and read.
Line 17, void Open Files, left parenthesis, if stream ampersand vote
File, comma, o f stream ampersand report File, right parenthesis,
semicolon.
Line 18, 2 forward slash, File names have been prompted for and
read.
Line 19, void, Write Per Rock Group, left parenthesis, const Vote
Array votes, comma, const string name left square bracket, right
square bracket, comma, of stream ampersand report File, right
parenthesis, semicolon.
Line 20, 2 forward slash, The name of each rock group followed by
the number of.
Line 21, 2 forward slash, votes the group received have been written
on report File.
Line 22, void, Write Per Level, left parenthesis, const Vote Array

votes, comma, of stream ampersand report File, right parenthesis,
semicolon.
Line 23, 2 forward slash, The level and the number of votes cast by
the level.
Line 24, 2 forward slash, have been written on report File.
Line 25, void, Write Report, left parenthesis, const Vote Array votes,
comma, const string name, left square bracket, right square
bracket, comma, of stream ampersand report File, right parenthesis,
semicolon.
Line 26, 2 forward slash, The array of votes has been written in
tabular form on.
Line 27, 2 forward slash, report File.
Line 28, void Zero Votes, left parenthesis, Vote Array votes, right
parenthesis, semicolon.
Line 29, 2 forward slash, The array of votes has been set to all
zeros.
Line 30, blank line.
Line 31, int main, left parenthesis, right parenthesis.
Line 32, indented once, string name, left square bracket, NUM
underscore, ROCk, underscore, GROUPS, right square bracket,
semicolon, 2 forward slash, Array of rock Group names.
Line 33, indented once, Vote Array votes, semicolon, 2 forward
slash, Totals for level versus rock Groups.
Line 34, indented once, int rock Group, semicolon, 2 forward slash,
Group number from Vote File.
Line 35, indented once, int level, semicolon, 2 forward slash, Level
number input from Vote File.
Line 36, indented once, if stream vote File, semicolon, 2 forward
slash, Input file of level, comma rock Groups.
Line 37, indented once, of stream report File, semicolon, 2 forward
slash, Output file receiving summaries.
Line 38, blank line.
Line 39, indented once, Open Files, left parenthesis, vote File,
comma, report File, right parenthesis, semicolon.
Line 40, indented once, if, left parenthesis, exclamation symbol, vote
File, 2 vertical bar symbols, exclamation symbol, report File, right
parenthesis.
Line 41, indented once, left brace.
Line 42, indented twice, c out, 2 left angled brackets, double quotes,

Files did not open successfully dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 43
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: return, void, string, c out, c in,
end l, int, for.
Line 1, left brace.
Line 2, indented twice, votes, left square bracket, level minus 1, right
square bracket, left square bracket, rock Group minus 1, right
square bracket, plus plus, semicolon.
Line 3, indented twice, vote File, 2 right angled brackets, level, 2
right angled brackets, rock Group, semicolon.
Line 4, indented once, right brace.
Line 5, indented once, Write Report, left parenthesis, votes, comma,
name, comma, report File, right parenthesis, semicolon.
Line 6, indented once, Write Per Rock Group, left parenthesis,
votes, comma, name, comma, report File, right parenthesis,
semicolon.
Line 7, indented once, Write Per Level, left parenthesis, votes,
comma, report File, right parenthesis, semicolon.
Line 8, indented once, return 0, semicolon.
Line 9, right brace.
Line 10, blank line.
Line 11, 2 forward slash followed by asterisks till the end of the line.
Line 12, blank line.
Line 13, void Open Files, left parenthesis, if stream ampersand text,
comma, of stream ampersand out File, right parenthesis.
Line 14, left brace.
Line 15, indented once, string in File Name, semicolon.
Line 16, indented once, string out File Name, semicolon.
Line 17, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the file to be presented, double quotes.
Line 18, indented four times, 2 left angled brackets, end l,
semicolon.
Line 19, indented once, c in, 2 right angled brackets, in File Nmae,
semicolon.

Line 20, indented once, text dot open, left parenthesis, in File Name
dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 21, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the output file, double quotes, 2 left angled
brackets, end l, semicolon.
Line 22, indented once, c in, 2 right angled brackets, out File Name,
semicolon.
Line 23, indented once, out File dot open, left parenthesis, out File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 24, indented once, out File, 2 left angled brackets, double
quotes, Analysis of exams on file, double quotes, 2 left angled
brackets, in File Name.
Line 25, indented five times, 2 left angled brackets, end l, 2 left
angled brackets, end l, semicolon.
Line 26, right brace.
Line 27, blank line.
Line 28, 2 forward slash followed by asterisk till the end of the line.
Line 29, blank line.
Line 30, void Get Name, left parenthesis, string name, left square
bracket, right square bracket, right parenthesis.
Line 31, left brace.
Line 32, indented once, string input S t r, semicolon.
Line 33, indented once, int, rock Group, semicolon.
Line 34, blank line.
Line 35, indented once, c out, 2 left angled brackets, double quotes,
Enter the names of the rock groups, comma, one per litre comma,
double quotes.
Line 36, indented four times, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, in the order they appear on the
ballot dot, double quotes, 2 left angled brackets, end l, semicolon.
Line 37, indented once, get line, left parenthesis, c in, comma, input
S t r, right parenthesis, semicolon, 2 forward slash, Bypass coin.
Line 38, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCK
underscore GROUPS, semicolon, rock Group plus plus, right
parenthesis.
Line 39, indented once, left brace.

Line 40, indented twice, get line, left parenthesis, c in, comma, input
S t r, right parenthesis, semicolon.
Line 41, indented twice, name, left square bracket, rock Group, right
square bracket, equals, input S t r dot sub s t r, left parenthesis, 0
comma 16, right parenthesis, semicolon.
Line 42, indented once, right brace.
Line 43, right brace.
Line 45, blank line.
Line 46, 2 forward slash followed by asterisks till the end of the line.
Line 47, blank line.
Line 48, void, Zero Votes, left parenthesis, Vote Array votes, right
parenthesis.
Line 49, left brace.
Line 50, indented twice, int level, semicolon.
Line 51, indented twice, int rock Group, semicolon.
Line 52, indented once, left parenthesis, level equals 0, semicolon,
level less than NUM underscore LEVELS, semicolon, level plus plus,
right parenthesis.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: for, void, int, end l.
Line 1, indented twice, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCK
underscore GROUPS, semicolon, rock Group plus plus, right
parenthesis.
Line 2, indented three times, votes, left square bracket, level, right
square bracket, left square bracket, rock Group, right square
bracket, equals 0, semicolon.
Line 3, right brace.
Line 4, blank line.
Line 5, 2 forward slash followed by asterisk till the end of the line.
Line 6, blank line.
Line 7, void, Write Report, left parenthesis, const, Vote Array cotes,
comma, const string name, left square bracket, right square
bracket, comma, of stream ampersand report File, right parenthesis.
Line 8, left brace.
Line 9, indented once, int level, semicolon.

Line 10, indented once, int rock Group, semicolon.
Line 11, blank line.
Line 12, report File, 2 left angled brackets, double quotes, blank
space, double quotes, semicolon.
Line 13, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore Rock underscore
GROUPS, semicolon, rock Group plus plus, right parenthesis.
Line 14, indented twice, report File, 2 left angled brackets, set w, left
parenthesis, 17, right parenthesis, name, left square bracket, rock
Group, right square bracket, semicolon.
Line 15, indented once, report File, 2 left angled brackets, end l,
semicolon.
Line 16, blank line.
Line 17, indented once, 2 forward slash, Print array by row.
Line 18, indented once, for, left parenthesis, level equals 0,
semicolon, level less than NUM underscore LEVELS, semicolon,
level plus plus, right parenthesis.
Line 19, indented once, left brace.
Line 20, indented twice, report File, 2 left angled brackets, double
quotes, level, double quotes, 2 left angled brackets, set w, left
parenthesis, 4, right parenthesis, 2 left angled brackets, level plus 1,
semicolon.
Line 21, indented twice, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCK
underscore GROUPS, semicolon, rock Group plus plus, right
parenthesis.
Line 22, indented three times, report File, 2 left angled brackets, set
w, left parenthesis, 17, right parenthesis, 2 left angled brackets,
votes, left square bracket, level, right square bracket, left square
bracket, rock Group, right square bracket, semicolon.
Line 23, indented twice, report File, 2 left angled brackets, end l, 2
left angled brackets, end l, semicolon.
Line 24, indented once, right brace.
Line 25, right brace.
Line 26, blank line.
Line 27, 2 forward slash followed by asterisk till the end of the line.
Line 28, blank line.
Line 29, void Write Per Rock Group, left parenthesis, const Vote
Array votes, comma, const string name, left square bracket, right

square bracket, comma, of stream ampersand report File, right
parenthesis.
Line 30, left brace.
Line 31, indented once, int level, semicolon.
Line 32, indented once, int rock Group, semicolon.
Line 33, indented once, int total, semicolon, 2 forward slash, Total
votes for a rock Group.
Line 34, blank line.
Line 35, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCK
underscore GROUPS, semicolon, rock Group plus plus, right
parenthesis.
Line 36, indented once, left brace.
Line 37, indented twice, total equals 0, semicolon.
Line 38, blank line.
Line 39, indented twice, 2 forward slash, Compute column sum.
Line 40, indented twice, for, left parenthesis, levle equals 0,
semicolon, level less than NUM underscore LEVELS, semicolon,
level plus plus, right parenthesis.
Line 41, indented three times, total, equals, total plus votes, left
square bracket, level, right square bracket, left square bracket, rock
Group, right square bracket, semicolon.
Line 42, indented twice, report File, 2 left angled brackets, double
quotes, Total votes for, double quotes.
Line 43, indented seven times, 2 left angled brackets, set w, left
parenthesis, 17, right parenthesis, 2 left angled brackets, name, left
square bracket, rock Group, right square bracket, 2 left angled
brackets, double quote, colon, double quote.
Line 44, indented seven times, 2 left angled brackets, set w, left
parenthesis, 3, right parenthesis, 2 left angled brackets, total, 2 left
angled brackets, end l, semicolon.
Line 45, indented once, right brace.
Line 46, right brace.
Line 47, blank line.
Line 48, 2 forward slash followed by asterisk till the end of the line.
Line 49, blank line.
Line 50, void, Write Per Level, left parenthesis, const, Vote Array
votes, comma, of stream ampersand, report File, right parenthesis.
Line 51, right brace.

Line 52, indented once, int level, semicolon.
Line 53, indented once, int rock Group, semicolon.
Line 54, indented once, int total, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: for, set w, and end l.
Line 1, indented once, for, left parenthesis, level equals 0,
semicolon, level less than NUM underscore LEVELS, semicolon,
level plus plus, right parenthesis.
Line 2, indented once, left brace.
Line 3, indented twice, total equals 0, semicolon.
Line 4, blank line.
Line 5, indented twice, 2 forward slash, Compute row sum.
Line 6, indented twice, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCk underscore
GROUNDS, semicolon, rock Group plus plus, right parenthesis.
Line 7, indented three times, total equals, total plus, votes, left
square bracket, level, right square bracket, left square bracket, rock
Group, right square bracket, semicolon.
Line 8, blank line.
Line 9, indented twice, report File, 2 left angled brackets, double
quotes, Total votes for level, double quotes.
Line 10, indented seven times, 2 left angled brackets, set w, left
parenthesis, 3, right parenthesis, 2 left angled brackets, level plus 1,
2 left angled brackets, single quote, colon, single quote.
Line 11, indented seven times, 2 left angled brackets, set w, left
parenthesis, 5, right parenthesis, 2 left angled brackets, total, 2 left
angled brackets, end l, semicolon.
Line 12, indented once, right brace.
Line 13, right brace.
Back to Figure
Line 1, 1 1, 3 1, 3 3.
Line 2, 1 1, 4 3, 4 4.
Line 3, 1 2, 3 4, 4 4.
Line 4, 1 2, 3 2, 4 3.

Line 5, 1 3, 3 3, 4 4.
Line 6, 1 4, 2 1, 4 4.
Line 7, 2 2, 2 3, 4 1.
Line 8, 2 2, 4 3, 4 2.
Line 9, 2 3, 4 4, 2 4.
Back to Figure
Line 1, Enter the name of the file to be processed.
Line 2, blank line.
Line 3, Votes dot dat.
Line 4, blank line.
Line 5, Enter the name of the output file.
Line 6, blank line.
Line 7, Votes dot out.
Line 8, blank line.
Line 9, Enter the name of the rock groups, comma, one per line,
comma.
Line 10, in the order they appear on the ballot, dot.
Line 11, blank line.
Line 12, Chas B Abbage.
Line 13, Boole's Brothers.
Line 14, Ada Love.
Line 15, Augie DeM.
Back to Figure
The output depicts a table with four columns: Chas B Abbage,
Boole's Brothers, Ada Love, and Augie DeM. Row entries are as
follows. Level 1: 1, 2, 1, 1. Level 2: 2, 2, 2, 1. Level 3: 1, 2, 2, 1.
Level 4: 1, 1, 3, 6. The table is followed by the following lines.
Line 1, Total votes for Chas B Abbage, colon, 5.
Line 2, Total votes for Boole's Brothers, colon, 7.
Line 3, Total votes for Ada Love, colon, 8.
Line 4, Total votes for Augie DeM, colon, 9.
Line 5, blank line.
Line 6, Total votes for level 1, colon, 5.
Line 7, Total votes for level 2, colon, 7.

Line 8, Total votes for level 3, colon, 6.
Line 9, Total votes for level 4, colon, 11.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: void, string.
Line 1, void, Open Files, left parenthesis, if stream ampersand text,
comma, of stream ampersand out File, right panrethesis, left brace.
Line 2, indented once, string, in File Name, semicolon.
Line 3, indented once, string, out File Name, semicolon.
Line 4, indented once, blank line.
Line 5, indented once, 2 forward slash, Add a G U I wiget for input.
Line 6, indented once, File Dialog, choose Input, left parenthesis,
double quotes, Choose the file to be processed, double quotes, right
parenthesis, semicolon.
Line 7, in File Name, equals, choose Input dot display, left
parenthesis, right parenthesis, semicolon.
Line 8, text dot open, left parenthesis, in File Name dot, c
underscore s t r, left parenthesis, 2 right parenthesis, semicolon.
Line 9, indented once, 2 forward slash, Add a G U I wiget for output.
Line 10, indented once, New File Dialog, choose Output, left
parenthesis, double quotes, Choose the name of the output file,
double quotes, right parenthesis, semicolon.
Line 11, out File Name, equals, choose Output dot display, left
parenthesis, right parenthesis, semicolon.
Line 12, out File dot open, left parenthesis, out File Name dot, c
underscore s t r, left parenthesis, 2 right parenthesis, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
keywords in the code are as follows: end l, void, string, int, and for.
Line 1, indented once, out File, 2 left angled brackets, double
quotes, Analysis of exams on file, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, 2 left angled
brackets.
Line 2, end l, semicolon.
Line 3, right brace.

Line 4, void Get Name, left parenthesis, string name, left square
bracket, right square bracket, right parenthesis, left brace.
Line 5, indented once, string, input S t r, semicolon.
Line 6, indented once, int, rock Group, semicolon.
Line 7, blank line.
Line 8, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than NUM underscore ROCK
underscore GROUPS, semicolon, rock Group plus plus, right
parenthesis, left brace.
Line 9, indented twice, 2 forward slash, Add a G U I widget for input.
Line 10, indented once, Text Dialog get Rock Group, left
parenthesis, double quotes, Enter the name of a rock group, double
quotes, right parenthesis, semicolon.
Line 11, indented once, input S t r, equals, get Rock Group dot
display, left parenthesis, right parenthesis, semicolon.
Line 12, indented once, name , left square bracket, rock Group,
right square bracket, equals, input S t r dot sub s t r, left
parenthesis, 0, comma, 16, right parenthesis, semicolon.
Line 13 indented once, right brace.
Line 14, right brace.
Back to Figure
The look of the first dialog widget when the G U I Program is
executed. The files and folders insided a particular folder is
displayed. The dialog box has a Cancel and Open button.
Back to Figure
The look of the second dialog widget when the G U I Program is
executed. The file name to use is entered in the Save As field. The
dialog box has a Cance and Save button.
Back to Figure
The look of the third dialog widget when the G U I Program is
executed. The title bar of the dialog box displays the text"Text
Dialog." The name of a rock group can be entered in the text field.
The dialog box has a Cancel and O K button.

Back to Figure
Line 1, char, line, left square bracket, 100, right square bracket,
semicolon.
Line 2, int, counter, semicolon.
Back to Figure
Line 1, for, left parenthesis, counter equals 0, semicolon, counter
less than or equal to 100, semicolon, counter plus plus, right
parenthesis.
Line 2, indented once, c out, 2 left angled brackets, line, left square
bracket, counter, right square bracket, semicolon.
Back to Figure
Line 1, counter equals 0, semicolon.
Line 2, c in dot get, left parenthesis, c h, right parenthesis,
semicolon.
Line 3, while, left parenthesis, c h not equal to, single quote,
backward slash n, single quote, right parenthesis.
Line 4, left brace.
Line 5, indented once, line, left square bracket, counter, right square
bracket, equals c h, semicolon.
Line 6, indented once, counter plus plus, semicolon.
Line 7, indented once, c in dot get, left parenthesis, c h, right
parenthesis, semicolon.
Line 8, right brace.
Back to Figure
Line 1, struct Student Rec.
Line 2, left brace.
Line 3, indented once, string, s t u Name, semicolon.
Line 4, indented once, float, g p a, semicolon.
Line 5, indented once, int, exam Score, left square bracket, 4, right
square bracket, semicolon.
Line 6, indented once, Grade Type, course Grade, semicolon.
Line 7, right brace, semicolon.

Back to Figure
Line 1, Student Rec student, semicolon.
Back to Figure
Line 1, Struct Variable dot Member Name.
Back to Figure
Line 1, Array, left square bracket, Index Expression, right square
bracket.
Back to Figure
Line 1, student dot exam Score
Back to Figure
Line 1, student dot exam Score, left square bracket, 0, right square
bracket.
Back to Figure
Line 1, Student Rec grade Book, left square bracket, 150, right
square bracket, semicolon.
Back to Figure
Line 1, grade Book, left square bracket, 0, right square bracket, dot
g p a.
Back to Figure
Line 1, grade Book, left square bracket, 0, right square bracket.
Back to Figure
Line 1, int, votes, left square bracket, 4, right square bracket, left
square bracket, 10, right square bracket, semicolon.

Back to Figure
Line 1, for, left parenthesis, level equals 0, semicolon, level less than
4, semicolon, level plus plus, right parenthesis.
Line 2, left brace.
Line 3, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than 10, rock Group plus plus, right
parenthesis.
Line 4, indented twice, c out, 2 left angled brackets, set w, left
parenthesis, 4, right parenthesis, 2 left angled parenthesis, votes,
left square bracket, rock Group, right square bracket, left square
bracket, level, right square bracket, semicolon.
Line 5, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 6, right brace.
Back to Figure
Line 1, for, left parenthesis, level equals 0, semicolon, level less than
10, semicolon, level plus plus, right parenthesis.
Line 2, left brace.
Line 3, indented once, for, left parenthesis, rock Group equals 0,
semicolon, rock Group less than 4, rock Group plus plus, right
parenthesis.
Line 4, indented twice, c out, 2 left angled brackets, set w, left
parenthesis, 4, right parenthesis, 2 left angled parenthesis, votes,
left square bracket, level, right square bracket, left square bracket,
rock Group, right square bracket, semicolon.
Line 5, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 6, right brace.
Back to Figure
Line 1, for, left parenthesis, level equals 0, semicolon, level less than
NUM underscore LEVELS, semicolon, levels plus plus, right
parenthesis.
Back to Figure

Line 1, int, a r r uppercase A, left square bracket, 5, right square
bracket, equals, left brace, 10, comma, 20, comma, 30, comma, 40,
comma, 50, right brace, semicolon.
Line 2, int, a r r uppercase B, left square bracket, 5, right square
bracket, equals, left brace, 60, comma, 70, comma, 80, comma, 90,
comma, 100, right brace, semicolon.
Line 3, int asterisk, p t r, semicolon.
Line 4, blank line.
Line 5, p t r, equals, a r r uppercase B, 2 forward slash, O K, 2
hyphen symbol, you can assign to a variable.
Line 6, a r r uppercase A, equals, a r r uppercase B, 2 forward
slash, Wrong, 2 hyphen symbol, you cannot assign to a constant.
Back to Figure
Line 1, for, left parenthesis, int count equals 0, semicolon, count
lesser than or equal to 23, semicolon, count plus plus, right
parenthesis.
Line 2, temps, left square bracket, count, right square bracket,
equals, 32.0, semicolon.
Back to Figure
Line 1, mail List, left square bracket, 12, right square bracket, dot,
street, dot, at, left parenthesis, 2, right parenthesis.
Back to Figure
Line 1, count equals 0, semicolon.
Line 2, c in, 2 right angled brackets, in Temp, semicolon.
Line 3, while, left parenthesis, in data, 2 ampersand symbols, count
lesser then 24, right parenthesis.
Line 4, left brace.
Line 5, indented once, temps, left square bracket, count, right
square bracket, equals, in Temp, semicolon.
Line 6, indented once, c in, 2 right angled brackets, in Temp,
semicolon.
Line 7, indented once, count plus plus, semicolon.
Line 8, right brace.

Back to Figure
Line 1, for, left parenthesis, day equals 0, semicolon, day less than
ot equal to 365, semicolon, day plus plus, right parenthesis.
Line 2, left brace.
Line 3, indented once, for, left parenthesis, hour equals 0,
semicolon, hour less than or equal to 23, semicolon, hour plus plus,
right parenthesis.
Line 4, indented twice, c out, 2 left angled brackets, all Temps, left
square bracket, hour, right square bracket, left square bracket, day,
right square bracket, semicolon.
Line 5, indented once, c out, 2 left angled brackets, and l,
semicolon.
Line 6, right brace.
Back to Figure
Line 1, for, left parenthesis, day equals 0, semicolon, day less than
or equal to 356, semicolon, day plus plus, right parenthesis, left
brace.
Line 2, indented once, average equals 0, semicolon.
Line 3, indented once, total equals 0, semicolon.
Line 4, indented once, for, left parenthesis, hour equals 0,
semicolon, hour less than 24, semicolon, hour plus plus, right
parenthesis, left brace.
Line 5, indented twice, total, plus, equal to, all Temps, left square
bracket, hour, right square bracket, left square bracket, day, right
square bracket, semicolon.
Line 6, indented once, right brace.
Line 7, indented once, average equals, total divided by 24.0,
semicolon.
Line 8, indented once, c out, 2 left angled brackets, double quotes,
Day, blank space, double quotes, 2 left angled brackets, day, 2 left
angled brackets, double quotes, average equals blank space, double
quotes, 2 left angled brackets, average, 2 left angled brackets, end
l, semicolon.
Line 9, right brace.
Back to Figure

Line 1, int, game, left square bracket, 3, right square bracket, left
square bracket, 4, right square bracket, equals, left brace, left
brace, 1, comma, 2, comma, 2, right brace, comma, left brace, 0,
comma, 1, comma, 0, right brace, comma, left brace, 1, comma, 0,
comma, 2, right brace, right brace, semicolon.
Back to Figure
Line 1, struct, Access Point, left brace, int state, semicolon, string
month, semicolon, right brace, semicolon.
Line 2, Access Point building, left square bracet, 15, right square
bracket, left square bracket, 10, right square bracket, left square
bracket, 12, right square bracket, semicolon.
Back to Figure
Line 1, float, decade Temps, left square bracket, 24, right square
bracket, left square bracket, 366, right square bracket, left square
bracket, 10, right square bracket.
Back to Figure
Line 1 labelled a, int, x, left square bracket, 27, right square bracket,
semicolon.
Line 2 labelled b, const, int, base equals 10, semicolon.
Line 3 labelled c, int, y, left square bracket, base plus 5, right square
bracket, semicolon.
Line 4 labelled d, int, z, left square bracket, 100, right square
bracket, left square bracket, 100, right square bracket, left square
bracket, 100, right square bracket, left square bracket, 100, right
square bracket, semicolon.
Back to Figure
Line 1, int, e prep, left square bracket, 100, right square bracket,
semicolon.
Line 2, for, left parenthesis, int, index equals 1, semicolon, index less
than or equal to 100, semicolon, index plus plus, right parenthesis.
Line 3, indented once, prep, left square bracket, index, right square
bracket, equals 0, semicolon.

Back to Figure
Line 1, const, int, limit equals 100, semicolon.
Line 2, int, e prep, left square bracket, limit, right square bracket,
semicolon.
Line 3, int, exam p, left square bracket, limit, right square bracket,
semicolon.
Line 4, for, left parenthesis, int index equals 0, semicolon, index less
than or equal to, limit minus 1, semicolon, index plus plus, right
parenthesis.
Line 5, right brace.
Line 6, indented once, e prep, left square bracket, index, right
square bracet, equals, 0, semicolon.
Line 7, indented once, exam p, left square bracket, index, right
square bracket, equals, 0, semicolon.
Line 8, right brace.
Line 9, if, left parenthesis, e prep, 2 equals to symbol, exam p.
Line 10, indented once, c out, 2 left angled brackets, double quotes,
Equal, double quotes, semicolon.
Back to Figure
Line 1, type def, int, Exrep, left square bracket, 50, right square
bracket, semicolon.
Line 2, Exrep, Init, left parenthesis, Exrep, right parenthesis,
semicolon, 2 forward slash, Prototype.
Back to Figure
Line 1, int, prepex, left square bracket, 3, right square bracket, left
square bracket, 4, right square bracket, equals.
Line 2, left brace.
Line 3, indented once, left brace, 1, comma, 2, comma, 3, right
brace, comma.
Line 4, indented once, left brace, 4, comma, 5, comma, 6, right
brace, comma.
Line 5, indented once, left brace, 7, comma, 8, comma, 9, right
brace, comma.
Line 6, indented once, left brace, 0, comma, negative 1, comma,

negative 2, right brace.
Line 7, right brace, semicolon.
Back to Figure
Line 1, int, index, semicolon.
Line 2, int, value, semicolon.
Line 3, int, xeperp, left square bracket, 100, right square bracket,
semicolon.
Line 4, c in, 2 right angled brackets, index, 2 left angled brackets,
value, semicolon.
Line 5, xeperp, left square bracket, index, right square bracket,
equals, value, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: int, if, and return.
Line 1, int Max, left parenthesis, int trio, left square brackets, 3, right
square brackets, right parenthesis.
Line 2, left brace.
Line 3, indented once, int, temp, semicolon.
Line 4, indented once, if, left parenthesis, trio, left square bracket, 0,
right square bracket, greater than symbol, trio, left square bracket,
1, right square bracket, right parenthesis.
Line 5, indented once, left brace.
Line 6, indented twice, temp equals, trio, left square bracket, 1, right
square bracket, semicolon.
Line 7, indented twice, trio, left square bracket, 1, right square
bracket, equals, trio, left square bracket, 0, right square bracket,
semicolon.
Line 8, trio, left square bracket, 0, right square bracket, equals,
temp, semicolon.
Line 9, indented once, right brace.
Line 10, indented once, if, left parenthesis, trio, left square bracket,
1, right square bracket, greater than symbol, trio, left square
bracket, 2, right square bracket, right parenthesis.
Line 11, indented once, left brace.
Line 12, indented twice, temp equals, trio, left square bracket, 2,

right square bracket, semicolon.
Line 13, indented twice, trio, left square bracket, 2, right square
bracket, equals, trio, left square bracket, 1, right square bracket,
semicolon.
Line 14, trio, left square bracket, 1, right square bracket, equals,
temp, semicolon.
Line 15, indented once, right brace.
Line 16, return, trio, left square bracket, 2, right square bracket,
semicolon.
Line 17, right brace.
Back to Figure
Line 1, char, pattern, left square bracket, 5, right square bracket, left
square bracket, 5, right square bracket, equals.
Line 2, left brace.
Line 3, indented once, left brace, single quote, asterisk, single
quote, comma, single quote, blank space, single quote, comma,
single quote, asterisk, single quote, comma, single quote, blank
space, single quote, comma, single quote, asterisk, single quote,
right brace, comma.
Line 4, indented once, left brace, single quote, blank space, single
quote, comma, single quote, asterisk, single quote, comma, single
quote, blank space, single quote, comma, single quote, asterisk,
single quote, comma, single quote, blank space, single quote, right
brace, comma.
Line 5, indented once, left brace, single quote, asterisk, single
quote, comma, single quote, blank space, single quote, comma,
single quote, asterisk, single quote, comma, single quote, blank
space, single quote, comma, single quote, asterisk, single quote,
right brace, comma.
Line 6, indented once, left brace, single quote, blank space, single
quote, comma, single quote, asterisk, single quote, comma, single
quote, blank space, single quote, comma, single quote, asterisk,
single quote, comma, single quote, blank space, single quote, right
brace, comma.
Line 7, indented once, left brace, single quote, asterisk, single
quote, comma, single quote, blank space, single quote, comma,
single quote, asterisk, single quote, comma, single quote, blank

space, single quote, comma, single quote, asterisk, single quote,
right brace.
Line 8, right brace.
Line 9, for, left parenthesis, int outer equals 0, semicolon, outer less
than 5, semicolon, outer plus plus, right parenthesis.
Line 10, left brace.
Line 11, indented once, for, left parenthesis, int inner equals 1,
semicolon, inner less than or equal to 5, semicolon, inner plus plus,
right parenthesis.
Line 12, indented twice, c out, 2 left angled brackets, pattern, left
square bracket, outer, right square bracket, left square bracket,
inner percentage 5, right square bracket, semicolon.
Line 13, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 14, right brace.
Back to Figure
Line 1, for, left parenthesis, int, index equals 0, semicolon, index less
than 5, semicolon, index plus plus, right parenthesis.
Line 2, indented once, c out, 2 left angled brackets, pattern, left
square bracket, index, right square bracket, left square bracket, left
parenthesis, index plus 2, right parenthesis, percentage symbol, 5,
right square bracket, semicolon.
Back to Figure
Line 1, for, left parenthesis, int, outer, equals, 0, semicolon, outer
less than 5, semicolon, outer plus plus, right parenthesis.
Line 2, right brace.
Line 3, indented once, for, left parenthesis, int, inner equals 0,
semicolon, inner less than 5, semicolon, inner plus plus, right
parenthesis.
Line 4, indented twice, c out, 2 left angled brackets, pattern, left
square bracket, inner, right square bracket, left square bracket,
outer, right square bracket, semicolon.
Line 5, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 6, right brace.

Back to Figure
Line 1, int, exam Prep, left square bracket, 12, right square bracket,
left square bracket, 15, right square bracket, semicolon.
Back to Figure
Program code labelled, class declaration. 
Line 1: class type name.
Line 2: left brace.
Line 3: access modifier, colon, member list.
Line 4: dot. Line 5: dot. Line 6: dot. 
Line 7: right brace, variable list, semicolon.
Back to Figure
Access modifier. A left brace covers two lines. Line 1: public. Line 2:
private.
Back to Figure
Member list. There are two left braces.
The first left brace covers the following two lines.
Line 1: Data Type, Member Name, semicolon.
Line 2: Function Prototype, semicolon.
The second left brace covers the following two lines. 
Line 3: Data Type, Member Name, semicolon.
Line 4: Function Prototype, semicolon. 
Line 5: dot.
Line 6: dot. 
Line 7: dot.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, const. 
Line 1: class Time Of Day.
Line 2: left brace.
Line 3: public, colon. 
Line 4: indented once: Time Of Day, left parenthesis, right

parenthesis, semicolon. 
Line 5: indented once: 2 forward slashes, Creates a zero Time Of
Day object. 
Line 6: indented once: Time Of Day, left parenthesis, int hours,
comma, int minutes, comma, int seconds, right parenthesis,
semicolon. 
Line 7: indented once: 2 forward slashes, Creates a Time Of Day
object with the given time. 
Line 8: indented once: Time Of Day Increment, left parenthesis,
right parenthesis, const, semicolon. 
Line 9: indented once: 2 forward slashes, Returns a Time Of Day
object that is incremented by one second.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: void,
const, bool, int. 
Line 1: indented once: void Write, left parenthesis, right parenthesis,
const, semicolon. 
Line 2: indented once: 2 forward slashes, Writes the Time Of Day
object to c out. 
Line 3: indented once: bool Equal, left parenthesis, Time Of Day,
other Time, right parenthesis, const, semicolon. 
Line 4: indented once: 2 forward slashes, Returns true if this Time
Of Day object equals other Time.
Line 5: indented once: bool Less Than, left parenthesis, Time Of
Day, other Time, right parenthesis, const, semicolon. 
Line 6: indented once: 2 forward slashes, Returns true if this Time
Of Day object is earlier than other Time. 
Line 7: private, colon.
Line 8: indented once: int hours, semicolon. 
Line 9: indented once: int minutes, semicolon. 
Line 10: indented once: int seconds, semicolon. 
Line 11: right brace, semicolon.
Back to Figure

Program code. 
Line 1: Time Of Day, start Time, semicolon, 2 forward slashes,
Create a 0 Time Of Day object.
Line 2: Time Of Day, end Time, left parenthesis, 10, comma, 24,
comma, 3, right parenthesis, semicolon, 2 forward slashes, Create a
Time Of Day object with 10. 
Line 3: indented 14 times: 2 forward slashes, hours, 24 minutes, and
3 seconds.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, void, bool, const. 
Line 1: class Time Of Day.
Line 2: left brace, 2 forward slashes, Declarations automatically start
as private. 
Line 3: indented once: int hours, semicolon. 
Line 4: indented once: int minutes, semicolon.
Line 5: indented once: int seconds, semicolon. 
Line 6: public, colon, 2 forward slashes, Here they switch to public.
Line 7: indented once: Time Of Day, left parenthesis, right
parenthesis, semicolon. 
Line 8: indented once: Time Of Day, left parenthesis, int hours,
comma, int minutes, comma, int seconds, right parenthesis,
semicolon. 
Line 9: indented once: Time Of Day Increment, left parenthesis,
right parenthesis, const, semicolon. 
Line 10: indented once: void Write, left parenthesis, right
parenthesis, const, semicolon. 
Line 11: indented once: bool Equal, left parenthesis, Time Of Day,
other Time, right parenthesis, const, semicolon. 
Line 12: indented once: bool Less Than, left parenthesis, Time Of
Day, other Time, right parenthesis, const, semicolon. 
Line 13: right brace, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, const, bool, void.

Line 1: class, Time Of Day.
Line 2: left brace. 
Line 3: public, colon. 
Line 4: indented once: Time Of Day, left parenthesis, right
parenthesis, semicolon. 
Line 5: indented once: Time Of Day, left parenthesis, int in it Hours,
int in it Minutes, int in it Seconds, right parenthesis, semicolon. 
Line 6: indented once: Time Of Day Increment, left parenthesis,
right parenthesis, const, semicolon. 
Line 7: indented once: void Write, left parenthesis, right parenthesis,
const, semicolon. 
Line 8: indented once: bool Equal, left parenthesis, Time Of Day,
other Time, right parenthesis, const, semicolon. 
Line 9: indented once: bool Less Than, left parenthesis, Time Of
Day, other Time, right parenthesis, const, semicolon. 
Line 10: private, colon. 
Line 11: indented once: int hours, semicolon.
Line 12: indented once: int minutes, semicolon. 
Line 13: indented once: int seconds, semicolon. 
Line 14: right brace, semicolon.
Back to Figure
Program code. 
Line 1: Time Of Day, colon, colon, Time Of Day, left parenthesis,
right parenthesis.
Line 2: left brace.
Line 3: indented once: hours, equals sign, 0, semicolon. 
Line 3: indented once: minutes, equals sign, 0, semicolon.
Line 3: indented once: seconds, equals sign, 0, semicolon.
Line 6: right brace.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int.
Line 1: Time Of Day, colon, colon, Time Of Day, left parenthesis, int
in it Hours, comma, int in it Minutes, comma. 
Line 2: indented 10 times: int in it Seconds, right parenthesis.

Line 3: left brace.
Line 4: indented once: hours, equals sign, in it Hours, semicolon. 
Line 5: indented once: minutes, equals sign, in it minutes,
semicolon.
Line 6: indented once: seconds, equals sign, in it seconds,
semicolon.
Line 7: right brace.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: const. 
Line 1: Time Of Day, Time Of Day, colon, colon, Increment, left
parenthesis, right parenthesis, const. 
Line 2: left brace.
Line 3: indented once: 2 forward slashes, Create a duplicate of
instance.
Line 4: indented once: Time Of Day result, left parenthesis, hours,
comma, minutes, comma, seconds, right parenthesis, semicolon, 2
forward slashes, Constructor call.
Back to Figure
Program code. The program contains the following keywords: if,
return. 
Line 1: result, dot, seconds, plus, plus, semicolon, 2 forward
slashes, Increment seconds. 
Line 2: if, left parenthesis, result, dot, seconds, right angled bracket,
59, right parenthesis, 2 forward slashes, Adjust if seconds carry.
Line 3: left brace. 
Line 4: indented once: result, dot, seconds, equals sign, 0,
semicolon.
Line 6: indented once: result, dot, minutes, plus, plus, semicolon. 
Line 7: indented once: if, left parenthesis, result, dot, minutes, right
angled bracket, 59, right parenthesis, 2 forward slashes, Adjust if
minutes carry. 
Line 8: indented once: left brace. 
Line 9: indented twice: result, dot, minutes, equals sign, 0,
semicolon. 

Line 10: indented twice: result, dot, hours, plus, plus, semicolon. 
Line 11: indented twice: if, left parenthesis, result, dot, hours, right
angled bracket, 23, right parenthesis, 2 forward slashes, Adjust if
hours carry. 
Line 12: indented thrice: result, dot, hours, equals sign, 0,
semicolon. 
Line 13: indented twice: right brace.
Line 14: indented once: right brace. 
Line 15: indented once: return result, semicolon.
Line 16: right brace.
Back to Figure
Line 1: hours, left angled bracket, other Time, dot, hours, 2 vertical
bars, hours, equals sign, equals sign, other Time, dot, hours. 
Line 2: indented thrice: ampersand, ampersand, minutes, left angled
bracket, other Time, dot, minutes, 2 vertical bars, hours, equals
sign, equals sign, other Time, dot, hours. 
Line 3: indented thrice: ampersand, ampersand, minutes, equals
sign, equals sign, other Time, dot, minutes. 
Line 4: indented thrice: ampersand, ampersand, seconds, left
angled bracket, other Time, dot, seconds, right parenthesis.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: bool, const, return.
Line 1: bool Time Of Day, colon, colon, Less Than, left parenthesis,
Time Of Day, other Time, right parenthesis, const. 
Line 2: left brace. 
Line 3: indented once: return, left parenthesis, hours, left angled
bracket, other Time, dot, hours, 2 vertical bars, hours, equals sign,
equals sign, other Time, dot, hours.
Line 4: indented 4 times: ampersand, ampersand, minutes, left
angled bracket, other Time, dot, minutes, 2 vertical bars, hours,
equals sign, equals sign, other Time, dot, hours.
Line 5: indented 4 times: ampersand, ampersand, minutes, equals
sign, equals sign, other Time, dot, minutes.
Line 6: indented 4 times: ampersand, ampersand, seconds, left

angled bracket, other Time, dot, seconds, right parenthesis,
semicolon. 
Line 7: right brace.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: bool, const, return.
Line 1: bool Time Of Day, colon, colon, equal, left parenthesis, Time
Of Day, other Time, right parenthesis, const. 
Line 2: left brace. 
Line 3: indented once: return, left parenthesis, hours, equals sign,
equals sign, other Time, dot, hours. 
Line 4: indented 4 times: ampersand, ampersand, minutes, equals
sign, equals sign, other Time, dot, minutes.
Line 5: indented 4 times: ampersand, ampersand, seconds, equals
sign, equals sign, other Time, dot, seconds, right parenthesis,
semicolon. 
Line 6: right brace.
Back to Figure
Data of time 1 as follows. Time of Day: constructor code, Time of
Day: constructor code, Increment: function code, Write: function
code, Equal: function code, Less than: function code, Hours: 0,
Minutes: 0, Seconds: 0. Data of time 2 as follows. Time of Day:
constructor code, Time of Day: constructor code, Increment:
function code, Write: function code, Equal: function code, Less than:
function code, Hours: 17, Minutes: 58, Seconds: 2.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: int, c
out, c in, if.
Line 1: int input Hours semicolon. 
Line 2: int input Minutes, semicolon.
Line 3: int input Seconds, semicolon. 
Line 4: blank.

Line 5: Time Of Day time 1, left parenthesis, 5, comma, 20, comma,
0, right parenthesis, semicolon. 
Line 6: blank. 
Line 7: c out, 2 left angled brackets, double quotes, Enter hours,
comma, minutes, comma, seconds, colon, double quotes,
semicolon. 
Line 8: c in, 2 right angled brackets, input Hours, 2 right angled
brackets, input Minutes, 2 right angled brackets, input Seconds,
semicolon. 
Line 9: Time Of Day time 2, left parenthesis, input Hours, comma,
input Minutes, comma, input Seconds, right parenthesis, semicolon. 
Line 10: blank.
Line 11: if, left parenthesis, time 1, dot, Less Than, left parenthesis,
time 2, 2 right parentheses.
Line 12: indented once: Do Something, left parenthesis, right
parenthesis, semicolon. 
Line 13: time 2, equals sign, time 1, semicolon, 2 forward slashes,
Member, hyphen, by, hyphen, member assignment.
Line 14: time 2, dot, Write, left parenthesis, right parenthesis,
semicolon, 2 forward slashes, 05, colon, 20, colon, 00 has been
output.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int. 
Line 1: int n, semicolon.
Line 2: dot.
Line 3: dot.
Line 4: dot.
Line 5: check In Time, dot, Write, left parenthesis, right parenthesis,
semicolon. 
Line 6: some Object, dot, Write, left parenthesis, right parenthesis,
semicolon. 
Line 7: Write, left parenthesis, n, right parenthesis, semicolon.
Back to Figure

Program code. The words used in the variable names are merged.
The program contains the following keywords: void, bool, const. 
Line 1: void Write, left parenthesis, right parenthesis, const,
semicolon. 
Line 2: Time Of Day Increment, left parenthesis, right parenthesis,
const, semicolon. 
Line 3: bool Equal, left parenthesis, Time Of Day, right parenthesis,
const, semicolon. 
Line 4: bool Less Than, left parenthesis, Time Of Day, right
parenthesis, const.
Back to Figure
Program code. The program contains the following keywords: enum.
Line 1: enum Months.
Line 2: left brace.
Line 3: indented once: JANUARY, comma, FEBRUARY, comma,
MARCH, comma, APRIL, comma, MAY, comma, JUNE, comma. 
Line 4: indented once: JULY, comma, AUGUST, comma,
SEPTEMBER, comma, OCTOBER, comma, NOVEMBER, comma,
DECEMBER, comma. 
Line 5: right brace, semicolon.
Back to Figure
A program is indicated which has two include statements featuring
the i o stream and months header file. The i o stream header file is
included form the standard inlcude directory which has the i o
stream file. The months header file is included from the local
directory which has the months header file. The header file months
defines an enumeration of months in a year.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, bool, int, const.
Line 1: 2 forward slashes, asterisk till the the end of the line. 
Line 2: 2 forward slashes, SPECIFICATION FILE, left parenthesis,
Time Of Day, dot, h, right parenthesis.

Line 3: 2 forward slashes, This file gives the specification.
Line 4: 2 forward slashes, of a Time Of Day abstract data type.
Line 5: 2 forward slashes, asterisk till the the end of the line.
Line 6: blank. 
Line 7: class Time Of Day. 
Line 8: left brace.
Line 9: public, colon. 
Line 10: indented once: 2 forward slashes, Constructors. 
Line 11: indented once: Time Of Day, left parenthesis, right
parenthesis, semicolon.
Line 12: indented once: 2 forward slashes, Post, colon, hours,
comma, minutes, comma, and seconds have been set to 0.
Line 13: indented once: Time Of Day, left parenthesis, int in it Hours,
comma, int in it Minutes, comma, int in it Seconds, right parenthesis,
semicolon.
Line 14: indented once: 2 forward slashes, Pre, colon, 0, left angled
bracket, equals sign, hours, left angled bracket, equals sign, 23,
comma, 0, left angled bracket, equals sign, minutes, left angled
bracket, equals sign, 59, comma, 0, left angled bracket, equals sign,
seconds, left angled bracket, equals sign, 59. 
Line 15: indented once: 2 forward slashes, Post, colon, Time Of Day
is set according to the incoming parameters. 
Line 16: indented once: Time Of Day Increment, left parenthesis,
right parenthesis, const, semicolon. 
Line 17: indented once: 2 forward slashes, Post, colon, Returns a
Time Of Day that is the instance plus one, comma.
Line 18: indented once: 2 forward slashes, 23, colon, 59, colon, 59
wrapping around to 0, colon, 0, colon, 0.
Line 19: indented once: void Write, left parenthesis, right
parenthesis, const, semicolon.
Line 20: indented once: 2 forward slashes, Post, colon, Instance has
been output in the form HH, colon, MM, colon, SS.
Line 21: indented once: bool Equal, left parenthesis, Time Of Day
other Time Of Day, right parenthesis, const, semicolon. 
Line 22: indented once: 2 forward slashes, Post, colon, Returns true
if this instance equals other Time, comma.
Line 23: indented once: 2 forward slashes, false otherwise.
Line 24: indented once: bool Less Than, left parenthesis, Time Of
Day other Time Of Day, right parenthesis, const, semicolon. 

Line 25: indented once: 2 forward slashes, Post, colon, Returns true
if this instance comes earlier than.
Line 26: indented once: 2 forward slashes, other Time, comma,
false otherwise.
Line 27: indented once: private, colon. 
Line 28: indented once: int hours, semicolon. 
Line 29: indented once: int minutes, semicolon.
Line 30: indented once: int seconds, semicolon.
Line 31: right brace, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: include, using
namespace, int, main, c out, if, else, end l.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, A program to create two time objects.
Line 3, and manipulate time.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 6, hashtag include, double quotes, Time of Day dot h, double
quotes, 2 forward slash, For Time of Day class.
Line 7, using namespace s t d, semicolon.
Line 8, blank line.
Line 9, int main, left parenthesis, right parenthesis.
Line 10, left brace.
Line 11, indented once, Time of Day time 1, left parenthesis, 5
comma, 30 comma, 0, right parenthesis, semicolon, 2 forward slash,
Instantiate two Time of Day objects.
Line 12, indented once, Time of Day time 2, semicolon.
Line 13, indented once, int loop Count, semicolon.
Line 14, blank line.
Line 15, indented once, c out, 2 left angled brackets, double quotes,
time 1, colon, double quotes, semicolon, 2 forward slash, Output
them and compare them.
Line 16, indented once, time 1 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 17, indented once, c out, 2 left angled brackets, double quotes,

time 2, colon, double quotes, semicolon.
Line 18, indented once, time 2 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 19, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 20, indented once, if, left parenthesis, time 1 dot Equal, left
parenthesis, time 2, 2 right parenthesis.
Line 21, indented twice, c out, 2 left angled brackets, double quotes,
Times are equal, double quotes, 2 left angled brackets, end l,
semicolon.
Line 22, indented once, else.
Line 23, indented twice, c out, 2 left angled brackets, double quotes,
Times are NOT equal, double quotes, 2 left angled brackets, end l,
semicolon.
Line 24, blank line.
Line 25, indented once, time 2, equals time 1, semicolon, 2 forward
slash, Set them equal.
Line 26, blank line.
Line 27, indented once, c out, 2 left angled brackets, double quotes,
time 1, colon, double quotes, semicolon, 2 forward slash, Output
them and compare them.
Line 28, indented once, time 1 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 29, indented once, c out, 2 left angled brackets, double quotes,
time 2, colon, double quotes, semicolon.
Line 30, indented once, time 2 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 31, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 32, blank line.
Line 33, indented once, if, left parenthesis, time 1, dot Equal, left
parenthesis, time 2, 2 right parenthesis.
Line 34, indented twice, c out, 2 left angled brackets, double quotes,
Times are equal, double quotes, 2 left angled brackets, end l,
semicolon.
Line 35, indented once, else.
Line 36, indented twice, c out, 2 left angled brackets, double quotes,
Times are NOT equal, double quotes, 2 left angled brackets, end l,
semicolon.

Line 37, blank line.
Line 38, indented once, time 2 dot Increment, left parenthesis, right
parenthesis, semicolon.
Line 39, indented once, c out, 2 left angled brackets, double quotes,
New time 2, colon, double quotes, semicolon.
Line 40, indented once, time 2 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 41, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 42, indented once, if, left parenthesis, time 1 dot Less Than,
left parenthesis, time 2, 2 right parenthesis.
Line 43, indented twice, c out, 2 left angled brackets, double quotes,
time 1 is less than time 2, double quotes, 2 left angled brackets, end
l, semicolon.
Line 44, indented once, else.
Line 45, indented twice, c out, 2 left angled brackets, double quotes,
time 1 is NOT less than time 2, double quotes, 2 left angled
brackets, end l, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: if, c out, else, for, return.
Line 1, indented once, if, left parenthesis, time 2, dot Less Than, left
parenthesis, time 1, 2 right parenthesis.
Line 2, indented twice, c out, 2 left angled brackets, double quotes,
time 2 is less than time 1, double quotes, 2 left angled brackets, end
l, semicolon.
Line 3, indented once, else.
Line 4, indented twice, c out, 2 left angled brackets, double quotes,
time 2 is NOT less than time 1, double quotes, 2 left angled
brackets, end l, semicolon.
Line 5, blank line.
Line 6, indented once, Time of Day time 4, left parenthesis, 23
comma, 59 comma, 55, right parenthesis, semicolon, 2 forward
slash, Instantiate one near the maximum.
Line 7, indented once, c out, 2 left angled brackets, double quotes,
Incrementing time 1 from 23, colon, 59, colon, 55, colon, double
quotes, 2 left angled brackets, end l, semicolon.

Line 8, indented once, for, left parenthesis, loop Count equals 1,
semicolon, loop Count less than or equal to 10, semicolon, loop
Count plus plus, right parenthesis.
Line 9, indented once, left brace.
Line 10, indented twice, time 4 dot Write, left parenthesis, right
parenthesis, semicolon.
Line 11, indented twice, c out, 2 left angled brackets, single quote,
blank space, single quote, semicolon.
Line 12, indented twice, time 4 equals time 4 dot Increment, left
parenthesis, right parenthesis, semicolon, 2 forward slash, Check
that it overflows properly.
Line 13, indented once, right brace.
Line 14, indented once, c out, 2 left angled brackets, end l,
semicolon.
Line 15, indented once, return 0, semicolon.
Line 16, right brace.
Back to Figure
Line 1, time 1, colon, 0 5, colon, 30, colon, 0 0, time 2, colon, 0 0,
colon, 0 0, colon, 0 0
Line 2, Times are NOT equal.
Line 3, time 1, colon, 0 5, colon, 30, colon, 0 0, time 2, colon, 0 5,
colon, 30, colon, 0 0.
Line 4, Times are equal.
Line 5, New time 2, colon, 0 5, colon, 30, colon, 0 0.
Line 6, time 1 is NOT less than time 2.
Line 7, time 2 is NOT less than time 1.
Line 8, Incrementing time 1 from 23, colon, 59, colon, 55, colon.
Line 9, 23, colon, 59, colon 55, 23, colon, 59, colon, 56, 23, colon,
59, colon, 57, 23, colon, 59, colon, 58, 23, colon, 59, colon, 59, 0 0,
colon, 0 0, colon, 0 0, 0 0, colon, 0 0, colon, 0 1.
Line 10, 0 0, colon, 0 0, colon, 0 2, 0 0, colon, 0 0, colon, 0 3, 0 0,
colon, 0 0, colon, 0 4.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: include, using

namespace.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, IMPLEMENTATION FILE, left parenthesis,
Time of Day dot c p p, right parenthesis.
Line 3, 2 forward slash, This file implements the Time of Day
member functions.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, double quotes, Time of Day dot h, double
quotes.
Line 6, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 7, blank line.
Line 8, using namespace s t d, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: if, return, void, c out.
Line 1, Time of Day, 2 colon symbols, Time of Day, left parenthesis,
right parenthesis.
Line 2, left brace.
Line 3, indented once, hours equals 0, semicolon.
Line 4, indented once, minutes equals 0, semicolon.
Line 5, indented once, seconds equals 0, semicolon.
Line 6, right brace.
Line 7, blank line.
Line 8, 2 forward slash followed by asterisks till the end of the line.
Line 9, blank line.
Line 10, Time of Day, 2 colon symbols, Time of Day, left parenthesis,
int in it Hours comma, int in it Minutes comma, int.
Line 11, in it Seconds, right parenthesis.
Line 12, left brace.
Line 13, indented once, hours, equals in it Hours, semicolon.
Line 14, indented once, minutes, equals in it Minutes, semicolon.
Line 15, indented once, seconds equals in it Seconds, semicolon.
Line 16, right brace.
Line 17, blank line.
Line 18, 2 forward slash followed by asterisks till the end of the line.
Line 19, blank line.

Line 20, Time of Day, Time of Day, 2 colon symbols, Increment, left
parenthesis, right parenthesis, const.
Line 21, left brace.
Line 22, indented once, 2 forward slash, Create a duplicate of
instance and increment duplicate.
Line 23, indented once, Time of Day result, left parenthesis, hours
comma, minutes comma, seconds, right parenthesis, semicolon.
Line 24, indented once, result dot seconds plus plus, semicolon, 2
forward slash, Increment seconds.
Line 25, indented once, if, left parenthesis, result dot seconds
greater than 59, right parenthesis, 2 forward slash, Adjust if seconds
carry.
Line 26, indented once, left brace.
Line 27, indented twice, result dot seconds equals 0, semicolon.
Line 28, indented twice, result dot minutes plus plus, semicolon.
Line 29, indented twice, if, left parenthesis, result dot minutes
greater than 59, right parenthesis, 2 forward slash, Adjust if minutes
carry.
Line 30, indented twice, left brace.
Line 31, indented three times, result dot minutes, equals 0,
semicolon.
Line 32, indented three times, result dot hours plus plus, semicolon.
Line 33, indented three times, if , left parenthesis, result dot hours,
greater than 23, right parenthesis.
Line 34, indented four times, result dot hours equals 0, semicolon.
Line 35, indented twice, right brace.
Line 36, indented once, right brace.
Line 37, indented once, return result, semicolon.
Line 38, left brace.
Line 39, blank line.
Line 40, 2 forward slash followed by asterisks till the end of the line.
Line 41, blank line.
Line 42, void Time of Day, 2 colon symbols, Write, left parenthesis,
right parenthesis, const.
Line 43, left brace.
Line 44, indented once, 2 forward slash Insert extra 0 if there is only
one digit in a place.
Line 45, indented once, if, left parenthesis, hours less than 10, right
parenthesis.

Line 46, indented twice, c out, 2 left angled brackets, single quote,
0, single quote, semicolon.
Line 47, indented once, c out, 2 left angled brackets, hours, 2 left
angled brackets, single quote, colon, single quote, semicolon.
Line 48, indented once, if, left parenthesis, minutes less than 10,
right parenthesis.
Line 49, indented twice, c out, 2 left angled brackets, single quote,
0, single quote, semicolon.
Line 50, indented once, c out, 2 left angled brackets, minutes, 2 left
angled brackets, single quote, colon, single quote, semicolon.
Line 51, indented once, if, left parenthesis, seconds less than 10,
right parenthesis.
Line 52, indented twice, c out, 2 left angled brackets, single quote,
0, single quote, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: c out, return.
Line 1, indented once, c out, 2 left angled brackets, seconds,
semicolon.
Line 2, right brace.
Line 3, blank line.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, blank line.
Line 6, bool, Time of Day, 2 colon symbols, Equal, left parenthesis,
Time of Day other Time, right parenthesis, const.
Line 7, left brace.
Line 8, indented once, return, left parenthesis, hours, 2 equal to
symbols, other Time dot hours.
LIne 9, indented five times, 2 ampersand symbols, minutes, 2 equal
to symbols, other Time dot minutes.
Line 10, indented five times, 2 ampersand symbols, seconds, 2
equal to symbols, other Time dot seconds, right parenthesis,
semicolon.
Line 11, right brace.
Line 12, blank line.
Line 13, 2 forward slash followed by asterisks till the end of the line.
Line 14, blank line.

Line 15, bool, Time of Day, 2 colon symbols, Less Than, left
parenthesis, Time of Day, other Time, right parenthesis, const.
Line 16, left brace.
Line 17, indented once, return, left parenthesis, hours less than
other Time dot hours, 2 vertical bars, hours, 2 equal to symbols,
other Time dot hours.
Line 18, indented five times, 2 ampersand symbols, minutes less
than other Time dot minutes, 2 vertical bars, hours, 2 equal to
symbols, other Time dot hours.
Line 19, indented five times, 2 ampersand symbols, minutes, 2
equal to symbols, other Time dot minutes.
Line 20, indented five times, 2 ampersand symbols, seconds, less
than, other Time dot seconds, right parenthesis, semicolon.
Line 21, right brace.
Back to Figure
The diagram shows 3 files, Time of day dot h, client dot c p p, Time
of day dot c p p. Two dotted arrows are drawn from Time of day dot
h to other 2 files. The file client dot c p p is as follows. Line 1: hash
include, douuble quotes Time of day dot h double quotes. The file
Time of day dot c p p is as follows. Line 1: hash include, double
quotes, Time of day, dot, h, double quotes.
Back to Figure
The chart shows 3 separate blocks, my prog dot c p p, left
parenthesis, with main function, right parenthesis, file 2 dot c p p,
and file 3 dot c p p. 3 separate arrows are drawn from each block of
file to 3 separate compilers. 3 separate compilers results in 3 blocks
of object files, my prog dot obj, file 2 dot onj, and file 3. obj. All the 3
object files results to a linker which results in, my prog dot e x e
block of file.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: int, const, bool. 
Line 1: class, Time Of Day. 

Line 2: left brace. 
Line 3: public, colon. 
Line 4: 2 forward slashes, constructors. 
Line 5: Time Of Day, left parenthesis, right parenthesis, semicolon. 
Line 6: Time Of Day, left parenthesis, int, init Hours, comma, int, init
Minutes, comma, int, init Seconds, right parenthesis, semicolon. 
Line 7: 2 forward slashes, Knowledge responsibilities. 
Line 8: Time Of Day, Increment, left parenthesis, right parenthesis,
const, semicolon. 
Line 9: int, Get Hours, left parenthesis, right parenthesis, const,
semicolon. 
Line 10: 2 forward slashes, Post, colon, Returns hours. 
Line 11: int, Get Minutes, left parenthesis, right parenthesis, const,
semicolon. 
Line 12: 2 forward slashes, Post, colon, Returns minutes. 
Line 13: int, Get Seconds, left parenthesis, right parenthesis, const,
semicolon. 
Line 14: 2 forward slashes, Post, colon, Returns Seconds. 
Line 15: bool, Equal, left parenthesis, Time Of Day, other Time Of
Day, right parenthesis, const, semicolon. 
Line 16: bool, Less Than, left parenthesis, Time Of Day, other Time
Of Day, right parenthesis, const, semicolon. 
Line 17: private, colon. 
Line 18; indented once: int, hours, semicolon. 
Line 19; indented once: int, minutes, semicolon. 
Line 20; indented once: int, seconds, semicolon. 
Line 21: left brace, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: int, return, using, const. 
Line 1: hash include, Time Of Day, dot, h. 
Line 2: using, namespace, std, semicolon. 
Line 3: dot, dot, dot. 
Line 4: int, Time Of Day, colon, colon, Get Hours, left parenthesis,
right parenthesis, const. 
Line 5: left brace. 
Line 6; indented once: return, hours, semicolon. 

Line 7: right brace. 
Line 8: int, Time Of Day, colon, colon, Get Minutes, left parenthesis,
right parenthesis, const. 
Line 9: left brace. 
Line 10; indented once: return, minutes, semicolon. 
Line 11: right brace. 
Line 12: int, Time Of Day, colon, colon, Get Seconds, left
parenthesis, right parenthesis, const. Line 13: left brace. 
Line 14; indented once: return, seconds, semicolon. 
Line 15: right brace.
Back to Figure
The diagram shows 2 blocks. The first block shows 3 different
houses with some builders working in each house. The houses are
separated from each other using boundary lines and property lines.
The second block shows the same 3 houses with no boundary lines
and property lines. The materials and the builders are collapsed
among the three houses.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: void, int. 
Column 1. 
Line 1: 2 forward slashes, Encapsulated interface, hyphen, hyphen. 
Line 2: 2 forward slashes, avoids errors due to misuse. 
Line 3: private, colon. 
Line 4; indented once: int, month, semicolon. 
Line 5; indented once: int, day, semicolon. 
Line 6; indented once: int, year, semicolon. 
Line 7: A blank line. 
Line 8: public, colon. 
Line 9; indented once: void, set Date. 
Line 10; indented twice: left parenthesis, int, new Month, comma,
int, new Day, comma. 
Line 11; indented thrice: int, new Year, right parenthesis, semicolon. 
Line 12: 2 forward slashes, Checks that the new date is. 
Line 13: 2 forward slashes, valid, semicolon, otherwise, leaves the. 

Line 14: 2 forward slashes, value unchanged. 
Column 2. 
Line 1: 2 forward slashes, Unencapsulated interface, hyphen,
hyphen. 
Line 2: 2 forward slashes, potential source of bugs. 
Line 3: public, colon. 
Line 4; indented once: int, month, semicolon. 
Line 5; indented once: int, day, semicolon. 
Line 6; indented once: int, year, semicolon.
Back to Figure
Two ellipses depict the same external abstraction for both
implementations of the date class, January 12, 2006. First ellipse:
date class with month, day, and year internal representation;
contains the following text inside it:
Line 1: private, colon.
Line 2: string month, semicolon.
Line 3: int day, semicolon.
Line 4: int year, semicolon.
Second ellipse: date class with Julian day internal representation;
contains the following text inside it:
Line 1: private, colon.
Line 2: int, Julian Day, semicolon.
Back to Figure
A class called Vehicle is being reused in three different ways. 1.
Vehicle use scheduling application. 2. Vehicle maintenance
scheduling application. 3. Vehicle tax accounting application.
Back to Figure
Line 1: void, set Baby Name, left parenthesis, Name, new Name,
right parenthesis. 
Line 2: left brace. 
Line 3; indented once: babys Name, equals, new Name, semicolon. 
Line 4: Right brace.

Back to Figure
Line 1: Birth Record, left parenthesis, Birth Record, old Record,
comma. 2 forward slashes. Constructor. 
Line 2: indented 6 times: Name, new Name, right parenthesis. 
Line 3: Left brace. 
Line 4: date Of Birth, equals, old Record, dot, date Of Birth,
semicolon. 
Line 5: time Of Birth, equals, old Record, dot, time Of Birth,
semicolon. 
Line 6: mothers Name, equals, old Record, dot, mothers Name,
semicolon. 
Line 7: fathers Name, equals, old Record, dot, fathers Name,
semicolon. 
Line 8: babys Name, equals, new Name, semicolon. 2 forward
slashes. Change name to new name. 
Line 9: babys Weight, equals, old Record, dot, babys Weight,
semicolon. 
Line 10: babys Length, equals, old Record, dot, babys Length,
semicolon. 
Line 11: babys Gender, equals, old Record, dot, babys Gender,
semicolon, semicolon. 
Line 12: Right brace.
Back to Figure
Line 1, Compared To, left parenthesis, In colon other Time, right
parenthesis.
Line 2, indented once, Return value, colon, Relation Type.
Line 3, IF, left parenthesis, time dot Less Than, left parenthesis,
other TIme, 2 right parenthesis.
Line 4, indented once, Return BEFORE.
Line 5, ELSE IF, left parenthesis, other Time dot Less Than, left
parenthesis, time, 2 right parenthesis.
Line 6, indented once, Return AFTER.
LIne 7, ELSE.
Line 8, indented once, Return SAME.
Back to Figure

Line 1, Compared To, left parenthesis, In colon other Time, right
parenthesis.
Line 2, indented once, Return value, colon, Relation Type.
Line 3, IF, left parenthesis, hours less than other Time dot hours,
right parenthesis.
Line 4, indented once, Return BEFORE.
Line 5, ELSE IF, left parenthesis, hours greater than other Time dot
hours, right parenthesis.
Line 6, indented once, Return AFTER.
Line 7, ELSE IF, left parenthesis, minutes less than other Time dot
minutes, right parenthesis.
Line 8, indented once, Return BEFORE.
Line 9, ELSE IF, left parenthesis, minutes greater than other Time
dot minutes, right parenthesis.
Line 10, indented once, Return AFTER.
Line 11, ELSE IF, left parenthesis, seconds less than other Time
seconds, right parenthesis.
Back to Figure
Line 1, indented once, Return BEFORE.
Line 2, ELSE IF, left parenthesis, seconds greater than other TIme
dot seconds, right parenthesis.
Line 3, indented once, Return AFTER.
Line 4, ELSE.
LIne 5, indented once, Return SAME.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, class, public,
private, int.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, SPECIFICATION FILE, left parenthesis,
Time of Day dot h, right parenthesis.
Line 3, 2 forward slash, This file gives the specification of a Time of
Day abstract data.
Line 4, 2 forward slash, type as revised to show object hyphen
oriented features and a.

Line 5, 2 forward slash, comparison function.
Line 6, 2 forward slash followed by asterisks till the end of the line.
Line 7, hashtag include, double quotes, Relation Type dot h, double
quotes.
Line 8, class Time of Day.
Line 9, left brace.
Line 10, public, colon.
Line 11, indented once, 2 forward slash, Constructors.
Line 12, indented once, Time of Day, left parenthesis, right
parenthesis, semicolon.
Line 13, indented once, 2 forward slash, Post, colon, hours comma,
minutes comma, and seconds have been set to 0.
Line 14, indented once, Time of Day, left parenthesis, int in it Hours
comma, int in it Minutes comma, int in it Seconds, right parenthesis,
semicolon.
Line 15, indented once, 2 forward slash, Pre, colon, 0 less than or
equal to hours less than or equal to 23 comma, o less than or equal
to minutes less than or equal to 59 comma, 0 less than or equal to
seconds less than or equal to 59.
Line 16, indented once, 2 forward slash, Post, colon, Time is set
according to the incoming parameters.
Line 17, blank line.
Line 18, indented once, 2 forward slash, Knowledge responsibilities.
Line 19, indented once, Time of Day Increment, left parenthesis,
right parenthesis, const, semicolon.
Line 20, indented once, 2 forward slash, Post, colon, Returns a time
that is the instance plus one comma.
Line 21, indented once, 2 forward slash, 23, colon, 59 colon, 59
wrapping around to 0, colon, 0 colon, 0.
Line 22, indented once, int Get Hours, left parenthesis, right
parenthesis const, semicolon.
Line 23, indented once, 2 forward slash, Returns hours.
Line 24, indented once, int Get Minutes, left parenthesis, right
parenthesis, const, semicolon.
Line 25, indented once, 2 forward slash, Returns minutes.
Lien 26, indented once, int Get Seconds, left parenthesis, right
parenthesis, const semicolon.
Line 27, indented once, Returns seconds.
Line 28, indented once, Relation Type Compared To, left

parenthesis, Time of Day other Day, right parenthesis, semicolon.
Line 29, indented once, 2 forward slash, Post, colon, Returns
BEFORE if instance comes before other Day, semicolon.
Line 30, indented once, 2 forward slash, Returns SAME if instance
and other Day are the same, semicolon.
Line 31, indented once, 2 forward slash, Returns AFTER if instance
comes after other Day.
Line 32, private, colon.
Line 33, indented once, int hours, semicolon.
Line 34, indented once, int minutes, semicolon.
Line 35, indented once, int seconds, semicolon.
Line 36, right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, if, result.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, IMPLEMENTATION FILE, left parenthesis,
Time of Day dot c p p, right parenthesis.
Line 3, 2 forward slash, This file implements the Time of Day
number functions as revised.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, double quotes, Time of Day dot h, double
quotes.
Line 6, blank line.
Line 7, Time of Day, 2 colon symbol, Time of Day, left parenthesis,
right parenthesis.
Line 8, left brace.
Line 9, indented once, hours equals 0, semicolon.
Line 10, indented once, minutes equals 0, semicolon.
Line 11, indented once, secodns equals 0, semicolon.
Line 12, right brace.
Line 13, blank line.
Line 14, 2 forward slash followed by asterisks till the end of the line.
Line 15, blank line.
Line 16, Time of Day, 2 colon symbols, Time of Day, left parenthesis,
int in it Hours comma, int in it Minutes comma, int in it Seconds,
right parenthesis.

Line 17, left brace.
Line 18, indented once, hours equals in it Hours, semicolon.
Line 19, indented once, minutes equals in it Minutes, semicolon.
Line 20, indented once, seconds equals in it Seconds, semicolon.
Line 21, blank line.
Line 22, 2 forward slash followed by asterisks till the end of the line.
Line 23, blank line.
Line 24, Time of Day, Time of Day, 2 colon symbols, Increment, left
parenthesis, right parenthesis, const.
Line 25, left brace.
Line 26, indented once, 2 forward slash, Create a duplicate of
instance and incerment duplicate.
Line 27, indented once, Time of Day result, left parenthesis, hours
comma, miutes comma, seconds, right parenthesis semicolon.
Line 28, indented once, result dot seconds plus, plus, semicolon, 2
forward slash, Increment seconds.
Line 29, indented once, if, left parenthesis, result dot seconds
greater than 59, right parenthesis.
Line 30, indented once, left brace.
Line 31, indented twice, result dot seconds equals 0, semicolon.
Line 32, indented twice, result dot minutes plus plus, semicolon.
Line 33, indented twice, if, left parenthesis, result dot minutes
greater than 59, right parenthesis.
Line 34, indented twice, left brace.
Line 35, indented three times, result dot minutes equals 0,
semicolon.
Line 36, indented three times, result dot hours plus plus, semicolon.
Line 37, indented twice, if, left parenthesis, result dot hours greater
than 23, right parenthesis.
Line 38, indented four times, result dot hours equals 0, semicolon.
Line 39, indented twice, right brace.
Line 40, indented once, right brace.
Line 41, indented once, return result, semicolon.
Line 42, right brace.
Line 43, blank line.
Line 44, 2 forward slash followed by asterisks till the end of the line.
Line 45, blank line.
Line 46, int Time of Day, 2 colon symbols, Get Hours, left

parenthesis, right parenthesis, const.
Line 47, left brace, return hours, semicolon, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: int, return, if, else if, else,
and return.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, blank line.
Line 3, int Time of Day, 2 colon symbols, Get Minutes, left
parenthesis, right parenthesis, const.
Line 4, left brace, return minutes, semicolon, right brace.
Line 5, blank line.
Line 6, 2 forward slash followed by asterisks till the end of the line.
Line 7, blank line.
Line 8, int Time of Day, 2 colon symbols, Get Seconds, left
parenthesis, right parenthesis, const.
Line 9, left brace, return seconds, semicolon, right brace.
Line 10, blank line.
Line 11, 2 forward slash followed by asterisks till the end of the line.
Line 12, blank line.
Line 13, Relation Type Time of Day, 2 colon symbols, Compared To,
left parenthesis, Time of Day other Time, right parenthesis.
Line 14, left brace.
Line 15, indented once, if, left parenthesis, hours less than other
Time dot hours, right parenthesis.
Line 16, indented twice, return BEFORE, semicolon.
Line 17, indented once, else if, left parenthesis, hours greater than
other Time dot hours, right parenthesis.
Line 18, indented twice, return AFTER, semicolon.
Line 19, indented once, else if, left parenthesis, minutes less than
other Time dot minutes, right parenthesis.
Line 20, indented twice, return BEFORE, semicolon.
Line 21, indented once, else if, left parenthesis, minutes greater
than other Time dot minutes, right parenthesis.
Line 22, indented twice, return AFTER, semicolon.
Line 23, indented once, else if, left parenthesis, seconds less than
other Time dot seconds, right parenthesis.

Line 24, indented twice, return BEFORE, semicolon.
Line 25, indented once, else if, left parenthesis, seconds greater
than other Time dot seconds, right parenthesis.
Line 26, indented twice, return AFTER, semicolon.
Line 27, indented once, else.
Line 28, indented twice, return SAME, semicolon.
Line 29, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
int main, and c out.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, This program creates two times objects and
manipulates them using
Line 3, 2 forward slash, get function and a comparison function.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 6, hashtag include, double quotes, Time of Day dot h, double
quotes, 2 forward slash, For Time of Day class.
Line 7, using namespace s t d,semicolon.
Line 8, blank line.
Line 9, int main, left parenthesis, right parenthesis.
Line 10, left brace.
Line 11, indented once, Time of Day time 1, left parenthesis, 5
comma, 30 comma, 0, right parenthesis, semicolon.
Line 12, indented once, Time of Day time 2, semicolon.
Line 13, blank line.
Line 14, indented once, c out, 2 left angled brackets, double quotes,
time 1, colon, double quotes, 2 left angled brackets, time 1 dot Get
Hours, left parenthesis, right parenthesis, 2 left angled brackets,
single quote, colon, single quote.
Line 15, indented four times, 2 left angled brackets, time 1 dot Get
Minutes, left parenthesis, right parenthesis, 2 left angled brackets,
single quote, forward slash, single quote.
Line 16, indented four times, 2 left angled brackets, time 1 dot Get
Seconds, left parenthesis, right parenthesis, 2 left angled brackets,

end l, semicolon.
Line 17, indented once, c out, 2 left angled brackets, double quotes,
time 2, colon, double quotes, 2 left angled brackets, time 1 dot Get
Hours, left parenthesis, right parenthesis, 2 left angled brackets,
single quote, colon, single quote.
Line 18, indented four times, 2 left angled brackets, time 2 dot Get
Minutes, left parenthesis, right parenthesis, 2 left angled brackets,
single quote, colon, single quote.
Line 19, indented four times, 2 left angled brackets, time 2 dot Get
Seconds, left parenthesis, right parenthesis, 2 left angled brackets,
end l, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: switch, case, c out, break,
end l, and return.
Line 1, indented once, switch, left parenthesis, time 1 dot Compared
To, left parenthesis, time 2, 2 right parenthesis.
Line 2, indented once, left brace.
Line 3, indented twice, case BEFORE, colon, c out, 2 left angled
brackets, double quotes, first time comes before second time,
double quotes.
Line 4, indented 11 times, 2 left angled brackets, end l, semicolon.
Line 5, indented 8 times, break, semicolon.
Line 6, indented twice, case SAME, colon, c out, 2 left angled
brackets, double quotes, times are the same, double quotes, 2 left
angled brackets, end l, semicolon.
Line 7, indented 8 times, break, semicolon.
Line 8, indented twice, case AFTER, colon, c out, 2 left angled
brackets, double quotes, second time comes before first time,
double quotes.
Line 9, indented 11 times, end l, semicolon.
Line 10, indented 8 times, break, semicolon.
Line 11, indented once, right brace.
Line 12, blank line.
Line 13, indented once, switch, left parenthesis, time 2 dot
Compared To, left parenthesis, time 1, 2 right parenthesis.
Line 14, indented once, left brace.

Line 15, indented twice, case BEFORE, colon, c out, 2 left angled
brackets, double quotes, first time comes before second time,
double quotes.
Line 16, indented 11 times, 2 left angled brackets, end l, semicolon.
Line 17, indented 8 times, break, semicolon.
Line 18, indented twice, case SAME, colon, c out, 2 left angled
brackets, double quotes, times are the same, double quotes, 2 left
angled brackets, end l, semicolon.
Line 19, indented 8 times, break, semicolon.
Line 20, indented twice, case AFTER, colon, c out, 2 left angled
brackets, double quotes, second time comes before first time,
double quotes.
Line 21, indented 11 times, end l, semicolon.
Line 22, indented 8 times, break, semicolon.
Line 23, indented once, right brace.
Line 24, blank line.
Line 25, indented once, switch, left parenthesis, time 1 dot
Compared To, left parenthesis, time 1, 2 right parenthesis.
Line 26, indented once, left brace.
Line 27, indented twice, case BEFORE, colon, c out, 2 left angled
brackets, double quotes, first time comes before second time,
double quotes.
Line 28, indented 11 times, 2 left angled brackets, end l, semicolon.
Line 29, indented 8 times, break, semicolon.
Line 30, indented twice, case SAME, colon, c out, 2 left angled
brackets, double quotes, times are the same, double quotes, 2 left
angled brackets, end l, semicolon.
Line 31, indented eight times, break, semicolon.
Line 32, indented twice, case AFTER, colon, c out, 2 left angled
brackets, double quotes, second time comes before first time,
double quotes.
Line 33, indented 11 times, end l, semicolon.
Line 34, indented eight times, break, semicolon.
Line 35, indented once, right brace.
Line 36, indented once, return 0, semicolon.
Line 37, right brace.
Back to Figure

Line 1, time 1, colon, 5, colon, 30, colon.
Line 2, time 2, colon, 5, colon, 0, colon, 0.
Line 3, second time comes before first time.
Line 4, first time comes before second time.
Line 5, times are the same.
Back to Figure
Line 1, Name name 1, left parenthesis, string comma, string
comma, string, right parenthesis, semicolon.
Line 2, Name name 2, left parenthesis, string comma, string
comma, string, right parenthesis, semicolon.
Line 3, dot.
Line 4, dot.
Line 5, dot.
Back to Figure
Line 1, switch, left parenthesis, name 1 dot Compared To, left
parenthesis, name 2, 2 right parenthesis.
Line 2, left brace.
Line 3, indented once, case BEFORE, colon, dot, dot, dot.
Line 4, indented once, case SAME, colon, dot, dot, dot.
Line 5, indented once, case AFTER, colon, dot, dot, dot.
Line 6, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
class, public, string, and char.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, SPECIFICATION FILE, left parenthesis,
Name dot b, right parenthesis.
Line 3, 2 forward slash, This file gives the specification of the Name
abstract.
Line 4, 2 forward slash, data type dot. There are two constructores,
colon, one takes the first, comma.
Line 5, 2 forward slash, middle comma, and last name as

parameters and the second sets first comma.
Line 6, 2 forward slash, middle, comma and last to blanks.
Line 7, 2 forward slash followed by asterisks till the end of the line.
Line 8, blank line.
Line 9, hashtag include, left angled brackets, i o stream, right angled
brackets.
Line 10, hashtag include, left angled brackets, string, right angled
brackets.
Line 11, hashtag include, double quotes, Relation Type dot h, double
quotes.
Line 12, using namespace s t d, semicolon.
Line 13, class Name.
Line 14, left brace.
Line 15, public, colon.
Line 16, indented once, Name, left parenthesis, right parenthesis,
semicolon.
Line 17, indented once, 2 forward slash, Default constructor.
Line 18, indented once, 2 forward slash, Post, colon, first comma,
middle comma, and last have been set to blanks.
Line 19, indented once, Name, left parenthesis, string first Name
comma, string middle Name comma, string last Name, right
parenthesis, semicolon.
Line 20, indented once, 2 forward slash, Parameterized constructor.
Line 21, indented once, Post, colon, Data fields hae been set to
parameters.
Line 22, blank line.
Line 23, indented once, 2 forward slash, Knowledge Responsibilities.
Line 24, indented once, string Get First Name, left parenthesis, right
parenthesis, const, semicolon.
Line 25, indented once, 2 forward slash, Post, colon, Return value is
this person's first name.
Line 26, indented once, string Get Last Name, left parenthesis, right
parenthesis, const, semicolon.
Line 27, indented once, 2 forward slash, Post, colon, Return value is
this person's last name.
Line 28, string Get Middle Name, left parenthesis, right parenthesis,
const, semicolon.
Line 29, indented once, 2 forward slash, Post, colon, Return value is
this person's middle name.

Line 30, indented once, char Get Middle Initial, left parenthesis, right
parenthesis, const, semicolon.
Line 31, indented once, 2 forward slash, Post, colon, Return value is
this person's middle initial.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: private, string.
Line 1, indented once, Realtion Type Compared To, left parenthesis,
Name other Name, right parenthesis, const, semicolon.
Line 2, indented once, 2 forward slash, Post, colon, Return value is.
Line 3, indented once, 2 forward slash, BEFORE, coma, if this name
comes before other Name.
Line 4, indented once, 2 forward slash, SAME, comma, if this name
and otherwise are the same.
Line 5, indented once, 2 forward slash, AFTER, comma, if this name
is after other Name.
Line 6, blank line.
Line 7, private, colon.
Line 8, indented once, string first, semicolon, 2 forward slash,
Person's first name.
Line 9, indented once, string last, semicolon, 2 forward slash,
Person's last name.
Line 10, indented once, string middle, semicolon, 2 forward slash,
Person's middle name.
Line 11, right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, IMPLEMENTATION FILE, left parenthesis,
Name dot c p p, right parenthesis.
Line 3, 2 forward slash, The file implements the Name member
functions.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, double quotes, Name dot h, double quotes.

Line 6, hashtag include, left angled brackets, i o stream, right angled
brackets.
Line 7, Name, 2 colon symbols, Name, left parenthesis, right
parenthesis.
Line 8, left brace.
Line 9, indented once, first equals, double quotes, blank space,
double quotes, semicolon.
Line 10, indented once, middle equals, double quotes, blank space,
double quotes, semicolon.
Line 11, indented once, last equals, double quotes, blank space,
double quotes, semicolon.
Line 12, right brace.
Line 13, blank line.
Line 14, 2 forward slash followed by asterisks till the end of the line.
Line 15, blank line.
Line 16, Name, 2 colon symbols, Name, left parenthesis, string first
Name, comma, string middle Name, comma, string last Name, right
parenthesis.
Line 17, left brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: string, char, if, else if,
else, and return.
Line 1, indented once, first equals first Name, semicolon, 2 forward
slash, Assign parameters.
Line 2, indented once, last equals last Name, semicolon.
Line 3, indented once, middle equals middle Name, semicolon.
Line 4, right brace.
Line 5, blank line.
Line 6, 2 forward slash followed by asterisks till the end of the line.
Line 7, blank line.
Line 8, string Name, 2 colon symbols, Get First Name, left
parenthesis, right parenthesis, const.
Line 9, left brace, return first, semicolon, right brace.
Line 10, blank line.
Line 11, 2 forward slash followed by asterisks till the end of the line.
Line 12, blank line.

Line 13, string Name, 2 colon symbols, Get Last Name, left
parenthesis, right parenthesis, const.
Line 14, left brace, return last, semicolon, right brace.
Line 15, blank line.
Line 16, 2 forward slash followed by asterisks till the end of the line.
Line 17, blank line.
Line 18, string Name, 2 colon symbols, Get Middle Name, left
parenthesis, right parenthesis, const.
Line 19, left brace, return middle, semicolon, right brace.
Line 20, blank line.
Line 21, 2 forward slash followed by asterisks till the end of the line.
Line 22, blank line.
Line 23, char Name, 2 colon symbols, Get Middle Initial, left
parenthesis, right parenthesis, const.
Line 24, left brace, return middle dot at, left parenthesis, 0, right
parenthesis, semicolon, right brace.
Line 25, blank line.
Line 26, 2 forward slash followed by asterisks till the end of the line.
Line 27, blank line.
Line 28, Relation Type Name, 2 colon symbols, Compared To, left
parenthesis, Name other Name, right parenthesis, const.
Line 29, left brace.
Line 30, indented once, if, left parenthesis, last less than, other
Name dot last, right parenthesis.
Line 31, indented twice, return BEFORE, semicolon.
Line 32, indented once, else if, left parenthesis, other Name dot last
less than last, right parenthesis.
Line 33, indented twice, return AFTER, semicolon.
Line 34, indented once, else if, left parenthesis, first less than other
Name dot first, right parenthesis.
Line 35, indented twice, return BEFORE, semicolon.
Line 36, indented once, else if, left parenthesis, other Name dot first
less than first, right parenthesis.
Line 37, indented twice, return AFTER, semicolon.
Line 38, indented once, else if, left parenthesis, middle less than
other Name dot middle, right parenthesis.
Line 39, indented twice, return BEFORE, semicolon.
Line 40, indented once, else if, left parenthesis, other Name dot
middle less than middle, right parenthesis.

Line 41, indented twice, return AFTER, semicolon.
Line 42, indented once, else.
Line 43, indented twice, return SAME, semicolon.
Line 44, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace.
Line 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, 2 forward slash, This program creates two name objects and
manipulates them.
Line 3, 2 forward slash followed by asterisks till the end of the line.
Line 4, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 5, hashtag include, left angled bracket, string, right angled
bracket.
Line 6, hashtag include, double quotes, Name dot h, double quotes.
Line 7, using namespace s t d, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: int, c out, switch, case,
and return.
Line 1, int main, left parenthesis, right parenthesis.
Line 2, left brace.
Line 3, indented once, Name her Name, left parenthesis, double
quotes, Susy, double quotes, comma, double quotes, Sunshine,
double quotes, comma, double quotes, Smith, double quotes, right
parenthesis, semicolon.
Line 4, indented once, Name his Name, left parenthesis, double
quotes, Marvin, double quotes, comma, double quotes, Moonlight,
double quotes, comma, double quotes, Morgan, double quotes, right
parenthesis, semicolon.
Line 5, indented once, c out, 2 left angled brackets, double quotes,
Her name is, double quotes, 2 left angled brackets, her Nmae dot
Get First Name, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes.

Line 6, indented four times, her Name dot, Get Middle Name, left
parenthesis, right parenthesis.
Line 7, indented four times, double quotes, blank space, double
quotes, 2 left andgled brackets, her Name dot Get Last Name, left
parenthesis, right parenthesis, 2 left angled brackets,end l,
semicolon.
Line 8, indented once, c out, 2 left angled brackets, double quotes,
Her middle initial is, double quotes, 2 left angled brackets, her Name
dot Get Middle Initial, left parenthesis, right parenthesis.
Line 9, indented four times, 2 left angled brackets, end l, semicolon.
Line 10, indented once, c out, 2 left angled brackets, double quotes,
His name is, double quotes, 2 left angled brackets, his Name dot
Get First Name, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes.
Line 11, indented four times, 2 left angled brackets, his Name dot
Get Middle Name, left parenthesis, right parenthesis.
Line 12, indented four times, 2 left angled brackets, double quotes,
blank space, double quotes, 2 left angled brackets, his Name dot
Get Last Name, left parenthesis, right parenthesis, 2 left angled
brackets, end l, semicolon.
Line 13, indented once, switch, left parenthesis, his Name dot
Compared To, left parenthesis, her Name, 2 right parenthesis.
Line 14, indented once, left brace.
Line 15, indented twice, case BEFORE, colon, c out, 2 left angled
brackets, double quotes, His name comes before her name, double
quotes, 2 left angled brackets, end l, semicolon.
Line 16, indented nine times, break, semicolon.
Line 17, indented twice, case SAME, colon, c out, 2 left angled
brackets, double quotes, His name and her name are the same,
double quotes.
Line 18, indented 11 times, 2 left angled brackets, end l, semicolon.
Line 19, indented nine times, break, semicolon.
Line 20, indented twice, case AFTER, colon, c out, 2 left angled
brackets, double quotes, His name comes after her name, double
quotes, 2 left angled brackets, end l, semicolon.
Line 21, indented once, right brace.
Line 22, indented once, return o, semicolon.
Line 23, right brace.

Back to Figure
Line 1, Her name is Susy Sunshine Smith.
Line 2, Her middle initial is S.
Line 3, His name is Marvin Moonlight Morgan.
Line 4, His name comes before her name.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, class, public,
private, string.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, SPECIFICATION FILE, left parenthesis,
Entry dot h, right parenthesis.
Line 3, 2 forward slash, This file contains the specification of the
entry ADT, comma, which has
Line 4, 2 forward slash, two contained classes, comma, Name and
TIme.
Line 5, 2 forward slash followed by asterisks till the end of the line.
Line 6, blank line.
Line 7, hashtag include, double quotes, Time of Day dot h, double
quotes.
Line 8, hashtag include, double quotes, Name dot h, double quotes.
Line 9, hashtag include, left angled bracket, string, right angled
bracket.
Line 10, blank line.
Line 11, class Entry.
Line 12, left brace.
Line 13, public, colon.
Line 14, indented once, Entry, left parenthesis, right parenthesis,
semicolon.
Line 15, indented once, 2 forward slash, Default constructor.
Line 16, indented once, 2 forward slash, Post, colon, Entry object
has been constructed.
Line 17, indented once, 2 forward slash, Name and Time of Day
objects have been constructed using.
Line 18, indented once, 2 forward slash, their default constructors.
Line 19, indented once, Entry, left parenthesis, string first Name,

comma, string middle Name, comma, string last Name, comma.
Line 20, indented four times, int in it Hours, comma, int in it Minutes,
comma, int in it Seconds, right parenthesis, semicolon.
Line 21, indented once, 2 forward slash, Parameterized
cconstructor.
Line 22, indented once, 2 forward slash, Post, colon, Entry object
has been constructed.
Line 23, indented once, 2 forward slash, Name and Time of Day
objects hasve been constructed using.
Line 24, indented once, 2 forward slash, their parameterized
constructors.
Line 25, indented once, string Get Name S t r, left parenthesis, right
parenthesis, const, semicolon.
Line 26, indented once, Post, colon, Returns the first and last name
of Name object.
Line 27, indented once, 2 forward slash, with a blank in between.
Back to Figure
Line 1, indented once, string Get Time S t r, left parenthesis, right
parenthesis, const, semicolon.
Line 2, indented once, 2 forward slash, Post, colon, Returns the
hours and minutes from Time of Day object.
Line 3, indented once, 2 forward slash, with a colon in between.
Line 4, private, colon.
Line 5, indented once, Name, name, semicolon.
Line 6, indented once, Time of Day time, semicolon.
Line 7, right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, IMPLEMENTATION FILE, left parenthesis,
Entry dot c p p, right parenthesis.
Line 3, 2 forward slash, This file contains the specification of the
Entry ADT, comma.
Line 4, 2 forward slash, which has two contained classes, comma,

Name and Time.
Line 5, 2 forward slash followed by asterisks till the end of the line.
Line 6, hashtag include, double quotes, Entry dot h, double quotes.
Line 7, hashtag include, left angled bracket, string, right angled
bracket.
Line 8, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 9, using namespace s t d, semicolon.
Line 10, blank line.
Line 11, Entry 2 colon symbol, Entry, left parenthesis, right
parenthesis.
Line 12, left brace, blank line, right brace.
Line 13, blank line.
Line 14, Entry, 2 colon symbols, Entry, left parenthesis, string first
Name, comma, string middle Name, comma, string last Name,
comma.
Line 15, indented seven times, int in it Hours, comma int in it
Minutes, comma, int in it Seconds, right parenthesis.
LIne 16, indented six times, colon, name, left parenthesis, first
Name, comma, middle Name, comma, last Name, right parenthesis,
comma.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: string.
Line 1, six times, time, left parenthesis, in it Hours, comma in it
Minutes, comma, in it Seconds, right parenthesis.
Line 2, left brace, blannk space, right brace.
Line 3, string Entry, 2 colon symbols, Get Name S t r, left
parenthesis, right parenthesis, const.
Line 4, left brace, return, left parenthesis, name dot Get First Name,
left parenthesis, right parenthesis, plus, single quote, blank space,
single quote, plus, name dot, Get Last Name, left parenthesis, 2
right parenthesis, semicolon, right brace.
Line 5, blank line.
Line 6, string Entry, 2 colon symbols, Get Time S t r, left
parenthesis, right parenthesis, const.
Line 7, left brace, return, left parenthesis, name dot Get First Name,

left parenthesis, right parenthesis, plus, single quote, blank space,
single quote, plus, name dot Get Last Name, left parenthesis, 2 right
parenthesis, semicolon, right brace.
Back to Figure
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, DRIVER for class Entry.
Line 3, 2 forward slash, This program tests the constructors and
return functions.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 6, hashtag include, double quotes, Entry dot h, double quotes.
Line 7, hashtag include, left angled bracket, string, right angled
bracket.
Line 8, blank line.
Line 9, using namespace s t d, semicolon.
Line 10, int main, left parenthesis, right parenthesis.
Line 11, left brace.
Line 12, indented once, Entry entry 1, left parenthesis, double
quotes, Sally, double quotes, comma, double quotes, Jane, double
quotes, comma, double quotes, Smith, double quotes, comma, 12,
comma, 20, comma, 0, right parenthesis, semicolon.
Line 13, indented once, Entry entry 2, left parenthesis, double
quotes, Mary, double quotes, comma, double quotes, Beth, double
quotes, comma, double quotes, Jones, double quotes, comma, 10,
comma, 30, comma, 0, right parenthesis, semicolon.
Line 14, blank line.
Line 15, indented once, c out, 2 left angled brackets, double quotes,
Entry 1, colon, double quotes, 2 left angled brackets, entry 1 dot Get
Name S t r, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes.
Line 16, indented four times, 2 left angled brackets, entry 1 dot Get
Time S t r, left parenthesis, right parenthesis, 2 left angled brackets,
end l, semicolon.
Line 17, indented once, c out, 2 left angled brackets, double quotes,
Entry 2, colon, double quotes, 2 left angled brackets, entry dot 2 Get
Name S t r, left parenthesis, right parenthesis, 2 left angled

brackets, double quotes, blank space, double quotes.
Line 18, indented four times, 2 left angled brackets, entry 2 dot Get
Time S t r, left parenthesis, right parenthesis, 2 left angled brackets,
end l, semicolon.
Line 19, indented once, return 0, semicolon.
Line 20, right brace.
Back to Figure
Line 1, hashtag if n def, RELATION.
Line 2, hashtag define, REALATION.
Line 3, enum Relation Type, left brace, BEFORE, comma, Same,
comma, AFTER, right brace, semicolon.
Line 4, hashtag, end if.
Back to Figure
Line 1, Error colon, illegal operand.
Line 2, Entry E r dot c p p line 33.
Line 3, return double quotes, double quotes, plus time dot Get
Hours, left parenthesis, right parenthesis, plus, double quotes,
colon, double quotes, plus time dot Get Minutes, left parenthesis,
right parenthesis, semicolon.
Back to Figure
Line 1, hashtag include, left angled bracket, s stream, right angled
bracket, 2 forward slash, o string stream.
Line 2, string Entry, 2 colon symbols, Get Time S t r, left
parenthesis, right parenthesis, const.
Line 3, 2 forward slash, This function makes use of class s stream
to create and return.
Line 4, 2 forward slash, a string containing numeric values.
Line 5, left brace.
Line 6, indented once, string out S t r, semicolon.
Line 7, indented once, o string stream temp Out, semicolon, 2
forward slash, Declare an o string stream.
Line 8, blank line.
Line 9, indented once, if, left parenthesis, time dot Get Hours, left

parenthesis, right parenthesis, less than 10, right parenthesis.
Line 10, indented twice, temp Out, 2 left angled brackets, single
quote, 0, single quote, semicolon.
Line 11, indented once, temp Out, 2 left angled brackets, time dot
Get Hours, left parenthesis, right parenthesis, 2 left angled brackets,
double quotes, colon, double quotes, semicolon.
Line 12, indented once, if, left parenthesis, time dot Get Minutes, left
parenthesis, right parenthesis, less than 10, right parenthesis.
Line 13, indented twice, temp Out, 2 left angled brackets, single
quotes, 0, single quote, semicolon.
Line 14, indented once, temp out, 2 left anlged brackets, time dot
Get Minutes, left parenthesis, right parenthesis, 2 left anlged
brackets, double quotes, colon, double quotes, semicolon.
Line 15, indented once, if, left parenthesis, time dot Get Seconds,
left parenthesis, right parenthesis, less than 10, right parenthesis.
Line 16, indented twice, temp Out, 2 left angled brackets, single
quote 0, single quote, semicolon.
Line 17, indented once, temp Out, 2 left angled brackets, time dot
Get Seconds, left parenthesis, right parenthesis, semicolon.
Line 18, indented once, out S t r equals temp Out dot s t r, left
parenthesis, right parenthesis, semicolon.
Line 19, return out S t r, semicolon.
Line 20, right brace.
Back to Figure
The Time of the Day class. This class has the following variables.
hours with int datatype. minutes with int datatype. seconds with int
datatype. This class has the following methods. Time Of Day with
hours, minutes, and seconds parameters all of the int datatype.
Time of Day. Increment. Get Hours with int return type. Get Minutes
with int return type. Get Seconds with int return type. Increment with
Time of Day return type. Compared To with Other Time parameter
of Time datatype and Boolean return type.
Back to Figure
A U M L diagram showing a composition relationship between two
classes. Entry is a class that contains an instance of the Name

class. The relationship is drawn with an arrow drawn between the
Entry and the Name class. At the Entry end is a diamond shape and
at the Name end is an arrow mark with the word name next to it.
The Name class features the following variables. first, last, and
middle all belonging to the string datatype.
Back to Figure
A group of 6 rectangles stacked vertically up is labeled, Names.
Each rectangle has the following entries made to its left hand side,
from top to bottom: left square bracket, 0, right square bracket; left
square bracket, 1, right square bracket; left square bracket, 2, right
square bracket; three dots vertically arranged; left square bracket,
22, right square bracket; left square bracket, 23, right square
bracket. A text pointed at the rectangle labeled, left square bracket,
0, right square bracket, reads as follows: Person who has 0 for
hours. A text pointed at the rectangle labeled, left square bracket, 1,
right square bracket, reads as follows: Person who has 1 for hours.
A text pointed at the rectangle labeled, left square bracket, 2, right
square bracket, reads as follows: Person who has 2 for hours. A text
pointed at the rectangle labeled, left square bracket, 22, right square
bracket, reads as follows: Person who has 22 for hours. A text
pointed at the rectangle labeled, left square bracket, 23, right square
bracket, reads as follows: Person who has 23 for hours.
Back to Figure
Line 1, Mary Jane Smith, 12, 30, 0.
Line 2, Susy Olive Oliver, 11, 45, 5.
Line 3, Jane Birdsong Wren, 8, 15, 30.
Line 4, William Jennings Brian, 0, 35, 35.
Line 5, dot, dot, dot.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
void, int, if, and return.
Line 1, 2 forward slash followed by asterisks till the end of the line.

Line 2, 2 forward slash, This program reads a file of Entry onbjects
and.
Line 3, 2 forward slash, writes the hours from 0 dot dot 23 and the
associated.
Line 4, 2 forward slash, name dot. Duplicate hours are not recorded.
Line 5, 2 forward slash followed by asterisks till the end of the line.
Line 6, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 7, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 8, hashtag include, double quotes, Name dot h, double quotes.
Line 9, blank line.
Line 10, using namespace s t d, semicolon.
Line 11, blank line.
Line 12, void Open Files, left parenthesis, if stream ampersand in
File, comma, of stream ampersand out File, right parenthesis,
semicolon.
Line 13, 2 forward slash, Prompts for and reads file name.
Line 14, 2 forward slash, Opens files.
Line 15, Name Get Name, left parenthesis, if stream ampersand in
File, right parenthesis.
Line 16, 2 forward slash, Reads and returns Name object from in
File.
Line 17, void Write Time Name, left parenthesis, of stream
ampersand out File, comma Name names, left square bracket, right
square bracket, right parenthesis, semicolon.
Line 18, 2 forward slash, Writes each hour and the corresponding
name.
Line 19, blank line.
Line 20, int main, left parenthesis, right parenthesis.
Line 21, left brace.
Line 22, indented once, 2 forward slash, Declarations.
Line 23, indented once, if stream in File, semicolon.
Line 24, indented once, of stream out File, semicolon.
Line 25, indented once, Name names, left square bracket, 24, right
square bracket, semicolon.
Line 26, indented once, Name blank name, semicolon.
Line 27, indented once, Name name, semicolon.
Line 28, indented once, int hours, dummy, semicolon.

Line 29, for, left parenthesis, int index equals 0, semicolon, index
less than 24, semicolon index plus plus, right parenthesis.
Line 30, indented twice, names, left square bracket, index, right
square bracket, equals blank Name, semicolon.
Line 31, indented once, Open Files, left parenthesis, in File, comma,
out File, right parenthesis.
Line 32, indented once, if, left parenthesis, exclamation mark, in
File, 2 ampersand symbol, out File, right parenthesis.
Line 33, indented once, left brace.
Line 34, indented twice, c out, 2 left angled brackets, double quotes,
Files did not open properly, double quotes, 2 left angled brackets,
end l, semicolon.
Line 35, indented once, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: while, if, else, return,
string, c out, c in.
Line 1, indented once, 2 forward slash, Process file.
Line 2, indented once, name equals, Get Name, left parenthesis, in
File, right parenthesis, semicolon.
Line 3, indented once, while, left parenthesis, in File, right
parenthesis.
Line 4, indented once, left brace.
Line 5, indented twice, in File, 2 left angled brackets, hours, 2 left
angled brackets, dummy, 2 left angled brackets, dummy, semicolon.
Line 6, indented twice, if, left parenthesis, name, left square bracket
hours, right square bracket, dot Get First Name, left parenthesis,
right parenthesis, 2 equal to symbols, double quotes, blank space,
double quotes.
Line 7, indented three times, names, left square bracket, hours,
right square bracket, equals name, semicolon.
Line 8, indented twice, else.
Line 9, indented three times, out File, 2 left angled brackets, hours,
2 left angled brackets, double quotes, is already taken dot, double
quotes, 2 left angled brackets, end l, semicolon.
Line 10, indented twice, name equals Get Name, left parenthesis, in
File, right parenthesis,semicolon.

Line 11, indented once, right brace.
Line 12, indented once, Write Time Nmae, left parenthesis, out File,
comma, names, right parenthesis, semicolon.
Line 13, indented once, out File dot close, left parenthesis, right
parenthesis, semicolon.
Line 14, indented once, in File dot close, left parenthesis, right
parenthesis, semicolon.
Line 15, indented once, return 0, semicolon.
Line 16, right brace.
Line 17, blank line.
Line 18, 2 forward slash followed by asterisks till the end of the line.
Line 19, blank line.
Line 20, void Open Files, left parenthesis, if stream ampersand in
File, comma, of stream ampersand out File, right parenthesis.
Line 21, left brace.
Line 22, indented once, string in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 23, indented once, string out File Name, semicolon, 2 forward
slash, User hyphen specified output file name.
Line 24, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the file to be processed, double quotes, 2 left
angled brackets, end l, semicolon.
Line 25, indented once, c in, 2 right angled brackets, in File Name,
semicolon.
Line 26, indented once, in File dot open, left parenthesis, in File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 27, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the output file, double quotes, 2 left angled
brackets, end l, semicolon.
Line 28, indented once, c in, 2 right anlged brackets, out File Name,
semicolon.
Line 29, indented once, out File dot open, left parenthesis, out File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 30, right brace.
Line 31, blank line.
Line 32, 2 forward slash followed by asterisks till the end of the line.
Line 33, blank line.

Line 34, Name Get Name, left parenthesis, if stream ampersand in
File, right parenthesis.
Line 35, left brace.
Line 36, indented once, string first, comma, middle, comma, last,
semicolon.
Line 37, indented once, in File, 2 right angled brackets, first, 2 right
angled brackets, middle, 2 right angled brackets, last, semicolon.
Line 38, indented once, Name, name, left parenthesis, first, comma,
middle, comma, last, right parenthesis, semicolon.
Line 39, indented once, return name, semicolon.
Line 40, right brace.
Line 41, blank line.
Line 42, 2 forward slash followed by asterisks till the end of the line.
Line 43, blank line.
Line 44, void Write Time Name, left parenthesis, of stream
ampersand out File, comma, Nmae names, left square bracket, right
square bracket, right parenthesis.
Line 45, left brace.
Line 46, indented once, out File, 2 left angled brackets, double
quotes, A listing of the hour and the corresponding name, double
quotes.
Line 47, indented five times, 2 left angled brackets, end l, semicolon.
Line 48, indented once, for, left parenthesis, int hour equals 0,
semicolon, hour less than 24, semicolon, hour plus plus, right
parenthesis.
Line 49, indented once, left brace.
Line 50, indented twice, if, left parenthesis, names, left square
bracket, hour, right square bracket dot Get First Name, left
parenthesis, right parenthesis, not equal to, double quotes, balnk
space, double quotes, right parenthesis.
Line 51, indented three times, out File, 2 left angled brackets, double
quotes, Hour, double quotes, 2 left angled brackets, hour, 2 left
angled brackets, double quotes, colon, double quotes.
Line 52, indented seven times, 2 left angled brackets, names, left
square bracket, hour, right square bracket, dot Get Middle Name,
left parenthesis, right parenthesis, 2 left angled brackets, double
quotes, blank space, double quotes.
Line 53, indented seven times, 2 left angled brackets, names, left
square bracket, hour, right square bracket, dot Get Last Name, left

parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: else, end l.
Line 1, indented twice, else.
Line 3, indented three times, out File, 2 left angled brackets, double
quotes, Hour, double quotes, 2 left angled brackets, hour, 2 left
angled brackets, double quotes, colon, None was scheduled dot,
double quotes.
Line 4, indented seven times, 2 left angled brackets, end l,
semicolon.
Line 5, indented once, right brace.
Line 6, right brace.
Back to Figure
Line 1, Mary Jane Smith, 12, 30, 0.
Line 2, Susy Olive Oliver, 11, 45, 5.
Line 3, Jane Birdsong Wren, 8, 15, 30.
Line 4, William Jennings Brian, 0, 35, 35.
Line 5, Bill William Smith, 2, 4, 5.
Line 6, Brad Smith Williams, 4, 5, 6.
Line 7, Mary Margaret Jones, 5, 6, 7.
Line 8, Andrew Bill Summer, 6, 7, 9.
Line 9, Ann Betty Butler, 6, 7, 8.
Back to Figure
Line 1, 6 is already taken dot.
Line 2, A listing of the hour and the corresponding name.
Line 3, Hour 1, colon, William Jennings Brian.
Line 4, Hour 2, colon, Bill William Smith.
Line 5, Hour 3, colon, None was scheduled dot.
Line 6, Hour 4, colon, Brad Smith Williams.
Line 7, Hour 5, colon, Mary Margaret Jones.
Line 8, Hour 6, colon, Andrew Bill Summer.

Line 9, Hour 7, colon, None was scheduled dot.
Line 10, Hour 8, colon, Jane Birdsong Wren.
Line 11, Hour 9, colon, None was scheduled dot.
Line 12, Hour 10, colon, None was scheduled dot.
Line 13, Hour 11, colon, Susy Olive Oliver.
Line 14, Hour 12, colon, Mary Jane Smith.
Line 15, Hour 13, colon, None was scheduled dot.
Line 16, Hour 14, colon, None was scheduled dot.
Line 17, Hour 15, colon, None was scheduled dot.
Line 18, Hour 16, colon, None was scheduled dot.
Line 19, Hour 17, colon, None was scheduled dot.
Line 20, Hour 18, colon, None was scheduled dot.
Line 21, Hour 19, colon, None was scheduled dot.
Line 22, Hour 20, colon, None was scheduled dot.
Line 23, Hour 21, colon, None was scheduled dot.
Line 24, Hour 22, colon, None was scheduled dot.
Line 25, Hour 23, colon, None was scheduled dot.
Back to Figure
Line 1, void Open Files, left parenthesis, if stream ampersand text,
comma, of stream ampersand out File, right parenthesis.
Line 2, left brace.
Line 3, indented once, string out File Name, semicolon, 2 forward
slash, User hyphen specified output file name.
Line 4, indented once, string in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 5, blank line.
Line 6, indented once, 2 forward slash, Add a G U I widget for input.
Line 7, indented once, File Dialog, choose Input, left parenthesis,
double quotes, Choose the file to be processed, double quotes, right
parenthesis, semicolon.
Line 8, indented once, in File Name, equals choose Input dot display,
left parenthesis, right parenthesis, semicolon.
Line 9, indented once, text dot open, left parenthesis, in File Name
dot, c underscore s t r, left parenthesis, right parenthesis, left
parenthesis, 2 right parenthesis, semicolon.
Line 10, blank line.
Line 11, indented once, 2 forward slash, Add a G U I widget for

output.
Line 12, indented once, New File Dialog choose Output, left
parenthesis, double quotes, Choose the name of the output, double
quotes, right parenthesis, semicolon.
Line 13, indented once, out File Name equals, choose Output dot
display, left parenthesis, right parenthesis, semicolon.
Line 14, indented once, out File dot open, left parenthesis, out File
Name dot c underscore, s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 15, right brace.
Back to Figure
2 buttons on the top left of the window are for selecting the folder
view options. The folder name is displayed at the top center. The
search bar is at the top right. The button at the bottom left is
labeled, New Folder. The buttons at the bottom right are labeled,
Cancel, and Open. The parameters labeled Name, Date Modified,
Size, and Kind are listed in a tabular form at the center of the
window. The entries are as follows. Row 1. Name: 12, underscore,
appointment, underscore, book, underscore, g u i. Date Modified:
Today at 12 34 P M. Size: 10 K B. Kind: Unix Ex dot dot dot able
File. Row 2. Name: appointments dot d a t. Date Modified: Today at
11 50 A M. Size: 233 bytes. Kind: D A T file.
Back to Figure
The side panel of the dialog box lists the following: Favourites:
Dropbox, Tim, Music, Applicati dot dot dot, Movies, Pictures,
Downloads, On My Mac, C I C S Und dot dot dot; i Cloud: iCloud Dri
dot dot dot, Desktop, Documents. The text label at the top center,
Save As, colon, and Tags, colon and the contents of their
corresponding text boxes are appointments dot t x t and blank,
respectively. The buttons for selecting the folder view options are at
the top left. The folder name which is Lawn Care Billing Case Study
is at the top center. The search bar is at the top right. The button at
the bottom left is labeled New Folder. The buttons at the bottom
right are labeled Cancel, and Save, respectively. The entries are as

follows. Row 1. 12, underscore, appoint dot dot dot t, underscore,
book, underscore, g u i. Row 2. appointments dot d a t.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: class, public, int.
Line 1, class Time of Day.
Line 2, left brace.
Line 3, public, colon.
Line 4, indented once, Time of Day, left parenthesis, int init Hours,
comma, int init Minutes, comma, int init Seconds, right parenthesis,
semicolon.
Line 5, indented once, Time of Day, left parenthesis, right
parenthesis, semicolon.
Line 6, indented once, 2 forward slash, Action responsibilities.
Line 7, indented once, Time of Day Increment, left parenthesis, right
parenthesis, const, semicolon.
Line 8, indented once, Relation Type, Compared To, left parenthesis,
Time of Day, other Day, right parenthesis, semicolon.
Line 9, indented once, 2 forward slash, Knowledge responsibilities.
Line 10, indented once, int Get Hours, left parenthesis, right
parenthesis, const, semicolon.
Line 11, indented once, int Get Minutes, left parenthesis, right
parenthesis, const, semicolon.
Line 12, indented once, int Get Seconds, left parenthesis, right
parenthesis, const, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: int, private.
Line 1, private, colon.
Line 2, indented once, int hours, semicolon.
Line 3, indented once, int minutes, semicolon.
Line 4, indented once, int seconds, semicolon.
Line 5, right brace, semicolon.
Back to Figure

Line 1, Time of Day Time of Day, 2 colon, Increment, left
parenthesis, right parenthesis, const.
Line 2, left brace.
Line 3, indented once, 2 forward slash, Create a duplicate of
instance and increment duplicate.
Line 4, indented once, Time of Day result, left parenthesis, hours,
comma, minutes, comma, seconds, right parenthesis, semicolon.
Line 5, indented once, result dot seconds plus plus, semicolon, 2
forward slash, Increment seconds.
Line 6, if, left parenthesis, result dot seconds greater than 59, right
parenthesis, 2 forward slash, Adjust if seconds carry.
Line 7, indented once, left brace.
Line 8, indented twice, result dot seconds equals 0, semicolon.
Line 9, indented twice, result dot minutes plus plus, semicolon.
Line 10, indented once, if, left parenthesis, result dot minutes,
greater than 59, right parenthesis.
Line 11, indented once, left brace.
Line 12, indented twice, result dot minutes equals 0, semicolon.
Line 13, indented twice, result dot hours plus plus, semicolon.
Line 14, indented twice, if, left parenthesis, result dot hours greater
than 23, right parenthesis, 2 forward slash, Adjust if hours carry.
Line 15, indented three times, result dot hours, equals 0, semicolon.
Line 16, indented twice, right brace.
Line 17, indented once, right brace.
Line 18, indented once, return result, semicolon.
Line 19, right brace.
Back to Figure
The row entries are as follows. Row 1. Case: 1. Initial values; hours:
10, minutes: 5, seconds: 30. Expected results; hours: 10, minutes:
5, seconds: 31. Row 2: Case: 2. Initial values; hours: 4, minutes: 6,
seconds: 59. Expected results; hours: 4, minutes: 7, seconds: 0.
Row 3. Case: 3. Initial values; hours: 13, minutes: 59, seconds: 59.
Expected results; hours: 14, minutes: 0, seconds: 0. Row 4. Case:
4. Initial values; hours: 23, minutes: 59, seconds: 59. Expected
results; hours: 0, minutes: 0, seconds: 0.
Back to Figure

Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
int, main, c out, c in, while, and return.
Line 1, 2 forward slash followed by asterisks till the end of line.
Line 2, 2 forward slash, This program is a test driver for the
Increment function.
Line 3, 2 forward slash, in the Time of Day.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, blank line.
Line 6, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 7, hashtag include, double quotes, Time of Day dot h, double
quotes.
Line 8, using namespace s t d, semicolon.
Line 9, blank line.
Line 10, int main, left parenthesis, right parenthesis.
Line 11, left brace.
Line 12, indented once, int hours, semicolon.
Line 13, indented once, int minutes, semicolon.
Line 14, indented once, int seconds, semicolon.
Line 15, indented once, c out, 2 left angled brackets, double quotes,
Enter a Time of Day, left parenthesis, use hours less than 0 to quit,
right parenthesis, colon, double quotes, 2 left angled brackets, end l,
semicolon.
Line 16, indented once, c in, 2 right angled brackets, hours, 2 right
angled brackets, minutes, 2 right angled brackets, seconds,
semicolon.
Line 17, indented once, while, left angled brackets, hours greater
than or equal to 0, right parenthesis.
Line 18, indented once, left brace.
Line 19, indented twice, Time of Day time, left parenthesis, hours,
comma, minutes, comma, seconds, right parenthesis, semicolon.
Line 20, indented twice, Time of Day time Inc, equals time dot
Increment, left parenthesis, right parenthesis, semicolon.
Line 21, indented twice, c out, 2 left angled brackets, double quotes,
Incremented Time of Day is, double quotes, semicolon.
Line 22, indented twice, c out, 2 left angled brackets, time Inc dot
Get Hours, left angled brackets, right angled brackets, 2 left angled
brackets, single quote, colon, single quote, 2 left angled brackets,

time dot Inc dot Get Minutes, left angled brackets, right angled
brackets, 2 left angled brackets, single quote, colon, single quote.
Line 23, indented five times, 2 left angled brackets, time Inc dot Get
Seconds, left parenthesis, right parenthesis, 2 left angled brackets,
end l, semicolon.
Line 24, indented twice, c out, 2 left angled brackets, end l,
semicolon.
Line 25, indented twice, c out, 2 left angled brackets, double quotes,
Enter a Time of Day, left parenthesis use hours less than 0 to quit,
right parenthesis, colon, double quotes, 2 left angled brackets, end l,
semicolon.
Line 26, c in, 2 right angled brackets, hours, 2 right angled brackets,
minutes, 2 right angled brackets, seconds, semicolon.
Line 27, indented once, right brace.
Line 28, indented once, return 0, semicolon.
Line 29, right brace.
Back to Figure
Line 1, Enter a Time of Day, left parenthesis, use hours, less than 0
to quit, right parenthesis, colon.
Line 2, 10, 5, 30.
Line 3, Incremented Time of Day is 10, colon, 5, colon, 31.
Line 4, blank line.
Line 5, Enter a Time of Day, left parenthesis, use hours less than 0
to quit, right parenthesis, colon.
Line 6, 2, 4, 59.
Line 7, Incremented Time of Day is 2, colon, 5, colon, 0.
Line 8, blank line.
Line 9, Enter a Time of Day, left parenthesis, use hours less than 0
to quit, right parenthesis, colon.
Line 10, 13, 59, 59.
Line 11, Incremented Time of Day is 14, colon, 0, colon, 0.
Line 12, blank line.
Line 13, Enter a Time of Day, left parenthesis, use hours less than 0
to quit, right parenthesis, colon.
Line 14, 23, 59, 59.
Line 15, Incremented Time of Day is 0, colon, 0, colon, 0.
Line 16, blank line.

Line 17, Enter a Time of Day, left parenthesis, use hours less than 0
to quit, right parenthesis, colon.
Line 18, negative 1, 0, 0.
Back to Figure
Line 1: if, left parenthesis, time 1, dot, Compared To, left
parenthesis, time 2, right parenthesis, right parenthesis. 
Line 2: Dot. 
Line 3: Dot.
Back to Figure
Line 1: Hash include, double quotes, dialog dot h, double quotes. 
Line 2: Hash include, left angled bracket, Q Application, right angled
bracket.
Back to Figure
Line 1, while, left parenthesis, run Test Dialog dot display, left
parenthesis, 2 right parenthesis, left brace.
Line 2, dot, dot, dot.
Line 3, right brace.
Back to Figure
A question mark is displayed on the left. The text displayed is, Run
Time of Day tests question mark. 2 buttons at the bottom right is
labeled No, and Yes.
Back to Figure
Line 1: Time Of Day Window, time Window, semicolon. Line 2: time
Window, dot, display, left parenthesis, right parenthesis, semicolon.
Back to Figure
The dialog box shows an input box with up and down arrow buttons
in the left followed by an Enter button in the right. The time in input

box shows 16 34 42. Text below reads as, Selected Time, colon, 16,
colon, 34, colon, 42.
Back to Figure
Line 1, Time of Day time, left parenthesis, time Window dot get
Hour, left parenthesis, right parenthesis, comma, time Window dot
get Minute, left parenthesis, right parenthesis, comma.
Line 2, time Window dot get Second, left parenthesis, 2 right
parenthesis, semicolon.
Line 3, Time of Day time Inc, equals time dot Increment, left
parenthesis, right parenthesis, semicolon.
Back to Figure
Line 1, string output, equals, double quotes, Original Time of Day is,
right brace, plus.
Line 2, indented nine times, to underscore string, left parenthesis,
time dot Get Hours, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 3, indented nine times, to underscore string, left parenthesis,
time dot Get Minutes, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 4, indented nine times, to underscore string, left parenthesis,
time dot Get Seconds, left parenthesis, 2 right parenthesis, plus,
double quotes, backward slash n, double quotes, semicolon.
Line 5, blank line.
Line 6, output equals, output plus double quotes, Incremented Time
of Day is , double quotes, plus.
Line 7, indented six times, to underscore string, left parenthesis,
time Inc dot Get Hours, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 8, indented six times, to underscore string, left parenthesis,
time Inc dot Get Minutes, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 9, indented six times, to underscore string, left parenthesis,
time Inc dot Get Seconds, left parenthesis, 2 right parenthesis,
semicolon.
Line 10, blank line.

Line 11, Output Dialog output Time Dialog, left parenthesis, output,
right parenthesis, semicolon.
Line 12, output Time Dialog dot, display, left parenthesis, right
parenthesis, semicolon.
Back to Figure
The buttons at the bottom right are labeled Cancel and O K. The
label within the window is marked Output, colon. The contents of a
text box below the label are as follows. Original Time of Day is 16
colon 34 colon 42. Incremented Time of Day is 16 colon 34 colon 43.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
main, int, while.
LIne 1, 2 forward slash followed by asterisk till the end of the line.
Line 2, 2 forward slash, This program is a G U I test driver for the
Increment function.
Line 3, 2 forward slash, in the Time of Day class.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, left angled bracket, Q Application, right
angled bracket.
Line 6, blank line.
Line 7, hashtag include, double quotes, Time of day dot h, double
quotes.
Line 8, hashtag include, double quotes, dialog dot h, double quotes.
Line 9, blank line.
Line 10, int main, left parenthesis, int arg c, comma, char asterisk,
arg v, left square bracket, right square bracket, right parenthesis.
Line 11, left brace.
Line 12, indented once, Q Application app, left parenthesis, arg c,
comma, arg v, right parenthesis, semicolon.
Line 13, indented once, Yes No Dialog, run Test Dialog, left
parenthesis, double quotes, Run a Time of Day test, question mark,
double quotes, right parenthesis, semicolon.
Line 14, indented once, while, left parenthesis, run Test Dialog, dot
display, left parenthesis, 2 right parenthesis.

Line 15, indented once, left brace.
Line 16, indented twice, Time of Day Window time Window,
semicolon.
Line 17, indented twice, time Window dot display, left parenthesis,
right parenthesis, semicolon.
LIne 18, indented twice, Time of Day time, left parenthesis, time
Window dot get Hour, left parenthesis, right parenthesis,comma,
time Window dot get Minute, left parenthesis, right
parenthesis,comma.
LIne 19, time Window dot, get Second, left parenthesis, 2 roght
parenthesis, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: string, return.
Line 1, indented twice, Time of Day time Inc, equals time dot
Increment, left parenthesis, right parenthesis, semicolon.
Line 2, indented twice, string output, equals, double quotes, Original
Time of Day is, double quotes, plus.
Line 3, indented nine times, to underscore string, left parenthesis,
time dot Get Hours, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 4, indented nine times, to underscore string, left parenthesis,
time dot Get Minutes, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 5, indented nine times, to underscore string, left parenthesis,
time dot Get Seconds, left parenthesis, 2 right parenthesis, plus,
double quotes, backward slash n, double quotes, semicolon.
Line 6, indented once, output equals, output plus, double quotes,
Incremented Time of Day is, double quotes, plus.
Line 7, indented six times, to underscore string, left parenthesis,
time Inc dot Get Hours, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 8, indented six times, to underscore string, left parenthesis,
time Inc dot Get Minutes, left parenthesis, 2 right parenthesis, plus,
double quotes, colon, double quotes, plus.
Line 9, indented six times, to underscore string, left parenthesis,
time Inc dot Get Seconds, left parenthesis, 2 right parenthesis,

semicolon.
Line 10, blank line.
Line 11, indented twice, Output Dialog, output Time Dialog, left
parenthesis, output, right parenthesis, semicolon.
Line 12, indented twice, output Time Dialog dot display, left
parenthesis, right parenthesis, semicolon.
Line 13, indented once, right brace.
Line 14, indented once, app dot exit, left parenthesis, right
parenthesis, semicolon.
Line 15, indented once, return 0, semicolon.
Line 16, right brace.
Back to Figure
Line 1, Time of Day, Time of Day, 2 colon, Increment, left
parenthesis, right parenthesis, const.
Line 2, left brace.
Line 3, indented once, dot.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, right brace.
Back to Figure
Line 1, Some Class, 2 colon, Some Class, left parenthesis, dot, dot,
dot, right parenthesis, colon, member Object, left parenthesis, arg 1,
arg 2, right parenthesis.
Line 2, left brace.
Line 3, indented once, dot.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, right brace.
Back to Figure
Line 1, class Name.
Line 2, left brace.
Line 3, public, semicolon.
Line 4, indented once, string first, semicolon.

Line 5, indented once, string middle, semicolon.
Line 6, indented once, string last, semicolon.
Line 7, right brace, semicolon.
Line 8, Name, your Name, semicolon.
Line 9, Name, my Name, semicolon.
Back to Figure
The row entries for the table, sorted by I D Hash are as follows. Row
1: 001, Ziggle. Row 2: 204, Jones. Row 3: 317, Applebee. Row 4:
801, Worton. Row 5: 901, Gomez. The row entries for the table,
sorted by name are as follows. Row 1: 317, Applebee. Row 2: 901,
Gomez. Row 3: 204, Jones. Row 4: 801, Worton. Row 5: 001,
Ziggle.
Back to Figure
The row entries for the table, Duplicate Keys are as follows. Row 1:
001, Applebee. Row 2: 201, Gomez. Row 3: 317, Gomez. Row 4:
801, Ziggle. Row 5: 901, Ziggle. The row entries for the table,
Unique Keys are as follows. Row 1: 317, Applebee. Row 2: 901,
Gomez. Row 3: 204, Jones. Row 4: 801, Worton. Row 5: 001,
Ziggle.
Back to Figure
Line 1: bool, Is Empty, left parenthesis, right parenthesis, const,
semicolon. Line 2: 2 forward slashes. Post, colon, Returns true if list
is empty, semicolon, false otherwise.
Back to Figure
Line 1: bool Is Full, left parenthesis, right parenthesis, const,
semicolon.
Line 2: 2 forward slashes, Post, colon, Returns true if list is full,
semicolon, false otherwise.
Line 3: blank.
Line 4: int Get Length, left parenthesis, right parenthesis, const,
semicolon. 
Line 5: 2 forward slashes, Post, colon, Returns the length of the list.

Back to Figure
Line 1: bool Is There, left parenthesis, Item Type, item, right
parenthesis, const, semicolon. Line 2: 2 forward slashes. Post,
colon, returns true if item is in the list, semicolon, false otherwise.
Back to Figure
Line 1: void Insert, left parenthesis, Item Type item, right
parenthesis, semicolon. 
Line 2: 2 forward slashes, Pre, colon, List is not full and item is not
in the list. 
Line 3: 2 forward slashes, Post, colon, item is in the list and length
has been incremented. 
Line 4: blank. 
Line 5: void Delete, left parenthesis, Item Type item, right
parenthesis, semicolon. 
Line 6: 2 forward slashes, Post, colon, item is not in the list.
Back to Figure
Line 1: void Reset List, left parenthesis, right parenthesis.
Line 2: 2 forward slashes, The current position is reset to access the
first item in the list.
Line 3: bool Has Next, left parenthesis, right parenthesis. 
Line 4: 2 forward slashes, Returns true if there is another item to be
returned, semicolon, false. 
Line 5: 2 forward slashes, otherwise.
Line 6: Item Type Get Next Item, left parenthesis, right parenthesis.
Line 7: 2 forward slashes, Assumptions, colon, No transformers are
called during the iteration.
Line 8: 2 forward slashes, There is an item to be returned,
semicolon, that is, has Next is true when.
Line 9: 2 forward slashes, this method is invoked. 
Line 10: 2 forward slashes, Pre, colon, Reset List has been called if
this is not the first iteration.
Line 11: 2 forward slashes, Post, colon, Returns item at the current
position.

Back to Figure
Line 1: List, left parenthesis, right parenthesis, semicolon. Line 2: 2
forward slashes. Constructor. Line 3: 2 forward slashes. Post, colon,
Empty list has been created.
Back to Figure
Line 1: const int MAX, underscore, LENGTH, equals sign, a blank
rectangular box, 2 forward slashes, // Maximum possible number of.
Line 2: indented 10 times, 2 forward slashes, components needed. 
Line 3: type def, a blank rectangular box, Item Type, semicolon, 2
forward slashes, Type of each component.
Line 4: indented 10 times: left parenthesis, a simple type or the.
Line 5: indented 10 times: string class, right parenthesis.
Back to Figure
A group of 6 rectangles stacked vertically up is labeled, counters.
Each rectangle has the following entries made to its left hand side,
from top to bottom: left square bracket, 0, right square bracket; left
square bracket, 1, right square bracket; three dots vertically
arranged; left square bracket, length minus 1, right square bracket;
three dots vertically arranged; left square bracket, MAX, underscore,
LENGTH minus 1, right square bracket. The array stacked from left
square bracket, 0, right square bracket to left square bracket, length
minus 1, right square bracket is labeled as list items. The array
stacked from left square bracket, 0, right square bracket, to left
square bracket, MAX, underscore, LENGTH minus 1, right square
bracket is labeled as array. Two rectangles labeled length and
current Pos are placed below the stack one followed by the other
separately.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: int, include, const,
void. 
Line 1: 2 forward slashes, asterisk till the end of the line. 

Line 2: 2 forward slashes, SPECIFICATION FILE, left parenthesis,
List, dot, h, right parenthesis. 
Line 3: 2 forward slashes, This file gives the specification of a list
abstract data type.
Line 4: 2 forward slashes, The list components are not assumed to
be in order by value.
Line 5: 2 forward slashes, asterisk till the end of the line. 
Line 6: hash include, left angled bracket, string, right angled bracket.
Line 7: const int MAX, underscore, LENGTH, equals sign, 100,
semicolon, 2 forward slashes, Maximum number of components.
Line 8: type def int Item Type, semicolon, 2 forward slashes, Type of
each component. 
Line 9: blank.
Line 10: class List.
Line 11: left brace.
Line 12: public, colon.
Line 13: indented once: List, left parenthesis, right parenthesis,
semicolon.
Line 14: indented once: 2 forward slashes, Constructor. 
Line 15: indented once: 2 forward slashes, Post, colon, Empty list
has been created. 
Line 16: blank. 
Line 17: indented once: 2 forward slashes, Action responsibilities.
Line 18: indented once: void Insert, left parenthesis, Item Type item,
right parenthesis, semicolon. 
Line 19: indented once: 2 forward slashes, Pre, colon, List is not full
and item is not in the list.
Line 13: indented once: 2 forward slashes, Post, colon, item is in the
list and length has been incremented.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, int, bool, const.
Line 1: indented once: void Delete, left parenthesis, Item Type item,
right parenthesis, semicolon.
Line 2: indented once: 2 forward slashes, Post, colon, item is not in
the list. 
Line 3: indented once: void Reset List, left parenthesis, right

parenthesis, semicolon. 
Line 4: indented once: 2 forward slashes, The current position is
reset to access the first item in the list. 
Line 5: indented once: Item Type Get Next Item, left parenthesis,
right parenthesis, semicolon. 
Line 6: indented once: 2 forward slashes, Assumptions, colon, No
transformers are called during the iteration.
Line 7: indented once: 2 forward slashes, There is an item to be
returned, semicolon, that is, Has Next is true when.
Line 8: indented once: 2 forward slashes, this method is invoked. 
Line 9: indented once: 2 forward slashes, Pre, colon, Reset List has
been called if this is not the first iteration.
Line 10: indented once: 2 forward slashes, Post, colon, Returns item
at the current position.
Line 11: blank.
Line 12: indented once: 2 forward slashes, Knowledge
responsibilities.
Line 13: indented once: int Get Length, left parenthesis, right
parenthesis, const, semicolon.
Line 14: indented once: 2 forward slashes, Post, colon, Returns the
length of the list.
Line 15: indented once: bool Is Empty, left parenthesis, right
parenthesis, const, semicolon. 
Line 16: indented once: 2 forward slashes, Post, colon, Returns true
if list is empty, semicolon, false otherwise. 
Line 17: indented once: bool Is Full, left parenthesis, right
parenthesis, const, semicolon. 
Line 18: indented once: 2 forward slashes, Post, colon, Returns true
if list is full, semicolon, false otherwise. 
Line 19: indented once: bool Is There, left parenthesis, Item Type
item, right parenthesis, const, semicolon.
Line 20: indented once: 2 forward slashes, Post, colon, Returns true
if item is in the list, semicolon, false otherwise.
Line 21: indented once: bool Has Next, left parenthesis, right
parenthesis, const, semicolon. 
Line 22: indented once: 2 forward slashes, Returns true if there is
another item to be returned, semicolon, false.
Line 23: indented once: 2 forward slashes, otherwise. 
Line 24: blank.

Line 25: indented once: private, colon. 
Line 26: indented twice: int length, semicolon. 
Line 27: indented twice: int current Pos, semicolon.
Line 28: indented twice: Item Type data, left square bracket, MAX,
underscore, LENGTH, right square bracket, semicolon. 
Line 29: right brace, semicolon.
Back to Figure
A group of 6 rectangles stacked vertically up is labeled, counters.
Each rectangle has the following entries made to its left hand side,
from top to bottom: left square bracket, 0, right square bracket; left
square bracket, 1, right square bracket; three dots vertically
arranged; left square bracket, length minus 1, right square bracket;
three dots vertically arranged; left square bracket, MAX, underscore,
LENGTH minus 1, right square bracket. The array stacked from left
square bracket, 0, right square bracket to left square bracket, length
minus 1, right square bracket is labeled as list items. The array
stacked from left square bracket, 0, right square bracket, to left
square bracket, MAX, underscore, LENGTH minus 1, right square
bracket is labeled as array. Two rectangles labeled length and
current Pos are placed below the stack one followed by the other
separately. The values in each rectangle, from top to bottom, are as
follows: 70, 68, three vertical dots, 69, three vertical dots, blank. The
values for length and current Pos are 30, and 0.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, f
stream, I o stream, name space, s t d.
Line 1: 2 forward slashes, asterisk till the end of the line. 
Line 2: 2 forward slashes, This program inputs one month's
temperature readings from a file, comma.
Line 3: 2 forward slashes, stores unique readings in a list, outputs
the list, removes a value.
Line 4: 2 forward slashes, of 200, and outputs the resulting list. 
Line 5: 2 forward slashes, asterisk till the end of the line.
Line 6: hash include, left angled bracket, f stream, right angled

bracket, 2 forward slashes, For file, I, slash O. 
Line 7: hash include, double quotes, List, dot, h, double quotes, 2
forward slashes, For List class. 
Line 8: hash include, left angled bracket, I o stream, right angled
bracket. 
Line 9: using name space s t d, semicolon.
Back to Figure
The words in the variable names and keywords are merged. The
code contains the following keywords: int, if stream, of stream, if,
return, temps, while and return.
Line 1: int main, left and right parenthesis.
Line 2: left brace.
Line 3: indented once, List temps, semicolon, 2 forward slashes, List
of temperature readings.
Line 4: indented once, int one Temp, semicolon, 2 forward slashes,
One temperature reading.
Line 5: indented once, if stream, in Data, semicolon, 2 forward
slashes, File of temperature readings.
Line 6: indented once, of stream, out Data, semicolon, 2 forward
slashes, Output file.
Line 7: indented once, in Data dot open, left parenthesis, double
quote, temps dot dat, double quote, right parenthesis, semicolon.
Line 8: indented once, if, left parenthesis, exclamation mark, in
Data, right parenthesis.
Line 9: indented once, left brace.
Line 10: indented twice, out Data, 2 left angled brackets, double
quote, Cannot open file temps dot dat, double quote, 2 left angled
brackets, end l, semicolon.
Line 11: indented twice, return 1, semicolon.
Line 12: indented once, right brace.
Line 13: indented once, out Data dot open, left parenthesis, double
quote, temps dot ans, double quote, right parenthesis, semicolon.
Line 14: indented once, in Data, 2 right angled brackets, one Temp,
semicolon, 2 forward slashes, Get a temperature.
Line 15: indented once, while, left parenthesis, in Data, 2
ampersands, exclamation mark, temps dot Is Full, left parenthesis, 2
right parenthesis.

Line 16: indented once, left brace.
Line 17: indented twice, if, left parenthesis, exclamation mark, temps
dot Is There, left parenthesis, one Temp, 2 right parenthesis, 2
forward slashes, Reject duplicates.
Line 18: indented thrice, temps dot Insert, left parenthesis, one
Temp, right parenthesis, semicolon.
Line 19: indented twice, in Data, 2 right angled brackets, one Temp,
semicolon.
Line 20: indented once, right brace.
Line 21: indented once, 2 forward slashes, Output original list.
Line 22: indented once, 2 forward slashes, Set up for an iteration.
Line 23: indented once, out Data, 2 left angled brackets, double
quote, number of unique readings, colon, double quote, 2 left angled
brackets, temps dot Get Length, left and right parenthesis, 2 left
angled brackets, end l, semicolon.
Line 24: indented once, while, left parenthesis, temps dot Has Next,
left parenthesis, 2 right parenthesis.
Line 25: indented once, left brace.
Line 26: indented twice, one Temp, equals, temps dot Get Next
Item, left and right parenthesis, semicolon.
Line 27: indented twice, out Data, 2 left angled brackets, one Temp,
2 left angled brackets, end l, semicolon.
Line 28: indented once, right brace.
Line 29: indented once, temps dot Delete, left parenthesis 200, right
parenthesis, semicolon, 2 forward slashes, Remove 200 if there
comma, cannot be more than one.
Line 30: indented once, temps dot Reset List, left and right
parenthesis, semicolon.
Line 31: indented once, out Data, 2 left angled brackets, double
quote, Readings without value of 200, dot, double quote, 2 left
angled brackets, end l, semicolon.
Line 32: indented once, while, left parenthesis, temps dot Has Next,
left parenthesis, 2 right parenthesis.
Line 33: indented once, left brace.
Line 34: indented twice, one Temp, equals, temps dot Get Next
Item, left and right parenthesis, semicolon.
Line 35: indented twice, out Data, 2 left angled brackets, one Temp,
2 left angled brackets, end l, semicolon.
Line 36: indented once, right brace.

Line 37: indented once, in Data dot close, left and right parenthesis,
semicolon.
Line 38: indented once, out Data dot close, left and right
parenthesis, semicolon.
Line 39: indented once, return 0, semicolon.
Line 40: right brace.
Back to Figure
The input values are as follows. 
Line 1: 70, 68, 69, 68, 68, 68, 72, 123, 69, 87, 200. 
Line 2: 82, 200, 140, 81, 200, 75, 78, 68, 67, 200. 
Line 3: 65, 66, 119, 61, 71, 120, 77, 78, 69.
Back to Figure
Line 1: No dot of unique readings colon 20. 
Line 2: 70. 
Line 3: 68. 
Line 4: 69. 
Line 5: 72.
Line 6: 123. 
Line 6: 87. 
Line 7: 200. 
Line 8: 82. 
Line 9: 140. 
Line 10: 81. 
Line 11: 75. 
Line 12: 78. 
Line 13: 67. 
Line 14: 65. 
Line 15: 66. 
Line 16: 119. 
Line 17: 61. 
Line 18: 71. 
Line 19: 120. 
Line 20: 77. 
Line 21: Readings without value of 200. 
Line 22: 70. 

Line 23: 68. 
Line 24: 69. 
Line 25: 72. 
Line 26: 123. 
Line 27: 87. 
Line 28: 77. 
Line 29: 77. 
Line 30: 82. 
Line 31: 140. 
Line 32: 81. 
Line 33: 75. 
Line 34: 78. 
Line 35: 67.
Line 36: 65. 
Line 37: 66. 
Line 38: 119. 
Line 39: 61. 
Line 40: 71. 
Line 41: 120.
Back to Figure
The words in the keywords are merged. The code contains the
following keywords: include, i o stream, and name space.
Line 1: 2 forward slashes, asterisks till the end of line.
Line 2: 2 forward slashes, implementation file in uppercase, left
parenthesis, List dot c p p, right parenthesis.
Line 3: 2 forward slashes, This file implements the List class
member functions.
Line 4: 2 forward slashes, asterisks till the end of line.
Line 5: hash include, double quote, List dot h, double quote.
Line 6: hash include, left angled bracket, i o stream, right angled
bracket.
Line 7: using name space, s t d, semicolon.
Back to Figure
Line 1: List in uppercase, colon, colon, List in uppercase, left and
right parenthesis.

Line 2: left brace.
Line 3: indented once, length equals 0, semicolon.
Line 4: indented once, current Pos equals 0, semicolon.
Line 5: right brace.
Back to Figure
Line 1: bool List, colon, colon, Is Empty, left and right parenthesis,
const.
Line 2: left brace.
Line 3: indented once, return, left parenthesis, length, equals,
equals, 0, right parenthesis, semicolon.
Line 4: right brace.
Back to Figure
Line 1: bool List, colon, colon, Is Full, left and right parenthesis,
const.
Line 2: left brace.
Line 3: indented once, return, left parenthesis, length, equals,
equals, max underscore length in uppercase, right parenthesis,
semicolon.
Line 4: right brace.
Back to Figure
Line 1: int List, colon, colon, Get Length, left and right parenthesis,
const.
Line 2: left brace.
Line 3: indented once, return length, semicolon.
Line 4: right brace.
Back to Figure
Line 1: void, insert, left parenthesis, Item Type, item, right
parenthesis, semicolon. Line 2: 2 forward slashes. Pre, colon, List is
not full and item is not in the list. Line 3: 2 forward slashes. Post,
colon, item is in the list and length has been incremented.
Back to Figure

Line 1: void List, colon, colon, Insert, left parenthesis, Item Type
item, right parenthesis.
Line 2: left brace.
Line 3: indented once, data, left square bracket, length, right square
bracket, equals, item, semicolon.
Line 4: indented once, length plus plus, semicolon.
Line 5: right brace.
Back to Figure
Line 1: void, Delete, left parenthesis, Item Type, item, right
parenthesis, semicolon. 
Line 2: 2 forward slashes. Post, colon, item is not in the list.
Back to Figure
The words in the variable names and keywords are merged. The
code contains the following keywords: void, int, index, while, and if.
Line 1: void List, colon, colon, Delete, left parenthesis, Item Type
item, right parenthesis.
Line 2: left brace.
Line 3: indented once, int index equals 0, semicolon.
Line 4: indented once, while, left parenthesis, index, left angled
bracket, length, 2 ampersands, item, exclamation mark, equals,
data, left square bracket, index, right square bracket, right
parenthesis.
Line 5: indented twice, index plus plus, semicolon.
Line 6: indented once, if, left parenthesis, index, left angled bracket,
length, right parenthesis, 2 forward slashes, item found.
Line 7: indented once, left brace.
Line 8: indented twice, data, left square bracket, index, right square
bracket, equals, data, left square bracket, length minus 1, right
square bracket, semicolon.
Line 9: indented twice, length, minus minus, semicolon.
Line 10: indented once, right brace.
Line 11: right brace.
Back to Figure

The words in the keywords are merged. The code contains the
following keywords: Is There, const, int, while, index, and return.
Line 1: bool List, colon, colon, Is There, left parenthesis, Item Type
item, right parenthesis, const.
Line 2: left brace.
Line 3: indented once, int index equals 0, semicolon, 2 forward
slashes, Index variable.
Line 4: indented once, while, left parenthesis, index, left angled
bracket, length, 2 ampersands, exclamation mark, equals, data, left
square bracket, index, right square bracket, right parenthesis.
Line 5: indented twice, index plus plus, semicolon.
Line 6: indented once, return, left parenthesis, index, left angled
bracket, length, right parenthesis, semicolon.
Line 7: right brace.
Back to Figure
The words in the keywords are merged. The code contains the
following keywords: Is There, const, int, while, index, and return.
Line 1: bool List, colon, colon, Is There, left parenthesis, Item Type
item, right parenthesis, const.
Line 2: left brace.
Line 3: indented once, int index equals length minus 1, semicolon, 2
forward slashes, Index variable.
Line 4: indented once, while, left parenthesis, index, right angled
bracket equals 0, 2 ampersands, exclamation mark, equals, data,
left square bracket, index, right square bracket, right parenthesis.
Line 5: indented twice, index minus minus, semicolon.
Line 6: indented once, return, left parenthesis, index, left angled
bracket, length, right parenthesis, semicolon.
Line 7: right brace.
Back to Figure
The words in the keywords are merged. The code contains the
following keywords: Is There, const, int, while, index, and return.
Line 1: bool List, colon, colon, Is There, left parenthesis, Item Type
item, right parenthesis, const, 2 forward slashes, Alternative version.
Line 2: 2 forward slashes, Copy of item is stored at end of the list to

ensure it is found.
Line 3: left brace.
Line 4: indented once, int index equals 0, semicolon.
Line 5: indented once, data, left square bracket, length, right square
bracket, equals, item, semicolon, 2 forward slashes, Store item at
position beyond and.
Line 6: indented once, while, left parenthesis, item, exclamation
mark, equals, data, left square bracket, right square bracket, right
parenthesis.
Line 7: indented twice, index plus plus, semicolon.
Line 8: indented once, return, left parenthesis, index, left angled
bracket, length, semicolon.
Line 9: right brace.
Back to Figure
Line 1, void List, 2 colon symbols, Reset List, left parenthesis, right
parenthesis.
Line 2, left brace.
Line 3, indented once, current Pos equals 0, semicolon.
Line 4, right brace.
Line 5, blank line.
Line 6, bool List, 2 colon symbols, Has Next, left parenthesis, right
parenthesis, const.
Line 7, left brace.
Line 8, indented once, return, left parenthesis, current Pos,
exclamation symbol, equal to symbol, length, right parenthesis,
semicolon.
Line 9, right brace.
Line 10, blank line.
Line 11, Item Type List, 2 colon symbols, Get Next Item, left
parenthesis, right parenthesis.
Line 12, left brace.
Line 13, indented once, Item Type item, semicolon.
Line 14, indented once, item equals, data, left square bracket,
current Pos, right square bracket, semicolon.
Line 15, indented once, current Pos plus plus, semicolon.
Line 16, indented once, return item, semicolon.
Line 17, right brace.

Back to Figure
A group of 6 rectangles are stacked vertically up in all the 6 arrays.
The first array has the following entries made to its left hand side,
from top to bottom: left square bracket, 0, right square bracket; left
square bracket, 1, right square bracket; left square bracket, 2, right
square bracket; left square bracket, 3, right square bracket; left
square bracket, 4, right square bracket; left square bracket, 5, right
square bracket. The values in each rectangle, from top to bottom,
are as follows. Array 1. 1220, 1810, 1207, 1612, 1008, 1300. Array
2: 1008, 1810, 1207, 1612, 1220, 1300. Array 3: 1008, 1207, 1810,
1612, 1220, 1300. Array 4: 1008, 1207, 1220, 1612, 1810, 1300.
Array 5: 1008, 1207, 1220, 1300, 1810, 1612. Array 6: 1008, 1207,
1220, 1300, 1612, 1810. The swapping of values in each array
based on the position is mentioned with 2 arrows.
Back to Figure
The chart flows as follows: x; 1. Contents of x goes into temp. Temp;
3. Contents of temp goes into y. Y; 2. Contents of y goes into x.
Back to Figure
Line 1, void Sort, left parenthesis, right parenthesis, semicolon.
Line 2, 2 forward slash, Post, colon, List items have been put into
ascending order either alphabetical.
Line 3, 2 forward slash, or numeric depending on Item Type.
Line 4, void List, 2 colon symbols, Sort, left parenthesis, right
parenthesis.
Line 5, 2 forward slash, Post, colon, Straight selection sort has been
used to sort the list items.
Line 6, left brace.
Line 7, indented once, Item Type, semicolon.
Line 8, indented once, int pass Count, semicolon, 2 forward slash,
Outer loop control variable.
Line 9, indented once, int search Index, semicolon, 2 forward slash,
Inner loop control variable.
Line 10, indented once, int min Index, semicolon, 2 forward slash,
Index of minimum so far.

Line 11, blank line.
Line 12, indented once, for, left parenthesis, pass Count equals 0,
semicolon, pass Count less than length minus 1, semicolon, pass
Count plus plus, right parenthesis.
Line 13, indented once, left brace.
Line 14, indented twice, min Index, equals pass Count, semicolon.
Line 15, indented twice, 2 forward slash, Find the index of the
smallest component.
Line 16, indented twice, 2 forward slash, in data, left square bracket,
pass Count dot dot length minus 1, right square bracket.
Line 17, indented twice, for, left parenthesis, search Index equals,
pass Count plus 1, semicolon, search Index less than length
semicolon.
Line 18, indented four times, search Index plus plus, right
parenthesis.
Line 19, indented three times, if, left parenthesis, data, left square
bracket, search Index, right square bracket, less than, data, left
square bracket, min Index, right square bracket, right parenthesis.
Line 20, indented four times, min Index equals, search Index,
semicolon.
Line 21, indented twice, 2 forward slash, Swap data, left square
bracket, min Index, right square bracket, and min data, left square
bracket, pass Count, right square bracket.
Line 22, indented twice, temp equals data, left square bracket, min
Index, right square bracket, semicolon.
Line 23, indented twice, data, left square bracket, min Index, right
square bracket, equals, data, left square bracket, pass Count, right
square brackets, semicolon.
Line 24, indented twice, data, left square bracket, pass Count, right
square bracket, equals, temp, semicolon.
Line 35, indented once, right brace.
Line 36, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: const, int, type def, class,
public, void.
Line 1, 2 forward slash followed by asterisks till the end of the line.

Line 2, 2 forward slash, SPECIFICATION FILE, left parenthesis,
Sorted List dot h, right parenthesis.
Line 3, 2 forward slash, This file gives the specification of a Sorted
List abstract data.
Line 4, 2 forward slash, type dot, The components are assumed to
be in order by value.
Line 5, 2 forward slash followed by asterisks till the end of the line.
Line 6, const int MAX underscore LENGTH, equals 100, semicolon,
2 forward slash, Maximum number of components.
Line 7, type def int Item Type, semicolon, 2 forward slash, Type of
each component.
Line 8, blank line.
Line 9, class Sorted List.
Line 10, left brace.
Line 11, public, colon.
Line 12, indented once, 2 forward slash, Action responsibilities.
Line 13, indented once, void Insert, left parenthesis, Item Type item,
right parenthesis, semicolon.
Line 14, indented once, 2 forward slash, Pre, colon, List is not full
comma, item is not in the list comma, and.
Line 15, indented once, 2 forward slash, the list items are sorted in
ascending order.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: void, bool, int, private.
Line 1, indented once, 2 forward slash, Post, colon, item is in the list
comma, length has been incremented comma, and.
Line 2, indented once, 2 forward slash, the list items are sorted in
ascending order.
Line 3, indented once, void Delete, left parenthesis, Item Type item,
right parenthesis, semicolon.
Line 4, indented once, 2 forward slash, Pre, colon, The list items are
sorted in ascending order.
Line 5, indented once, 2 forward slash, Post, colon, item is not in the
list and the list items are sorted.
Line 6, indented once, 2 forward slash, in ascending order.
Line 7, indented once, void Reset List, left parenthesis, right

parenthesis, semicolon.
Line 8, indented once, The current position is reset to access the
first item in the list.
Line 9, indented once, Item Type Get Next Item, left parenthesis,
right parenthesis, semicolon.
Line 10, indented once, 2 forward slash, Assumptions, colon, No
transformers are called during the iteration dot.
Line 11, indented once, 2 forward slash, There is an item to be
returned semicolon, that is comma, Has Next is true when.
Line 12, indented once, 2 forward slash, this method is invoked dot.
Line 13, indented once, 2 forward slash, Pre, colon, Reset List has
been called if this not the first iteration.
Line 14, indented once, 2 forward slash, Post, colon, Returns item at
the current position.
Line 15, indented once, 2 forward slash, Knowledge responsibilities.
Line 16, indented once, bool Is Empty, left parenthesis, right
parenthesis, const, semicolon.
Line 17, indented once, 2 forward slash, Post, colon, Returns true if
list is empty, semicolon, false otherwise.
Line 18, indented once, bool Is Full, left parenthesis, right
parenthesis, const, semicolon.
Line 19, indented once, Post, colon, Returns true if list is full,
semicolon, false otherwise.
Line 20, indented once, int Get Length, left parenthesis, right
parenthesis, const, semicolon.
Line 21, indented once, 2 forward slash, Post, colon, Returns the
length of the list.
Line 22, indented once, bool Is There, left parenthesis, Item Type
item, right parenthesis, const, semicolon.
Line 23, indented once, 2 forward slash, Post, colon, Returns true if
item is in the list, semicolon, false otherwise.
Line 24, indented once, bool Has Next, left parenthesis, right
parenthesis, const, semicolon.
Line 25, indented once, 2 forward slash, Returns if there is another
item to be returned, semicolon false.
Line 26, indented once, 2 forward slash, otherwise.
Line 27, blank line.
Line 28, indented once, Sorted List, left parenthesis, right
parenthesis, semicolon.

Line 29, indented twice, 2 forward slash, Constructor.
Line 30, indented twice, 2 forward slash, Post, colon, Empty list has
been created.
Line 31, blank line.
Line 32, indented once, private, colon.
Line 33, indented twice, int length, semicolon.
Line 34, indented twice, int current Pos, semicolon.
Line 35, indented twice, Item Type data, left square bracket, MAX
underscore LENGTH, right square bracket, semicolon.
Line 36, indented twice, void Binary Search, left parenthesis, Item
Type item comma bool ampersand found comma, int ampersand
position, right parenthesis, const, semicolon.
Line 37, right brace, semicolon.
Back to Figure
Line 1, WHILE place not found AND more places to look.
Line 2, indented once, IF item greater than current component in
list.
Line 3, indented twice, Increment current position.
Line 4, indented once, ELSE.
Line 5, indented twice, Place found.
Line 6, Shift remainder of list down.
Line 7, Insert item.
Line 8, Increment length.
Back to Figure
Line 1, Set data, left square bracket, length, right square bracket,
equals, data, left square bracket length minus 1, right square
bracket.
Line 2, Set data, left square bracket, length minus 1, right square
bracket, equals, data, left square bracket, length minus 2, right
square bracket.
Line 3, dot, dot.
Line 4, dot, dot.
Line 5, dot, dot.
Line 6, Set data, left square bracket, index plus 1, right square

bracket, equals, data, left square bracket, index, right square
bracket.
Back to Figure
At the top is label, Insert that is followed by 5 values. Values inserted
to each array are as follows. Value 3 is inserted to array 1 in the first
position from top. Value 16 is inserted to array 2 labeled, Put 16 at
end of the list, in the second position from top. Value 12 is inserted
to array 3 labeled, Move 16 down and insert 12, in the second
position from top. Value 1 is inserted to array 4 labeled, Move 16,
12, and 3 down insert 1, in the first position from top. Value 2 is
inserted to array 5 labeled, Move 16, 12, and 3 down and insert 2, in
the second position from top.
Back to Figure
Line 1, Set index equals, length minus 1.
Line 2, WHILE, index greater than or equal to 0 AND item less than
data, left square bracket, index, right square bracket.
Line 3, indented once, Set data, left square bracket, index plus 1,
right square bracket, equals, data, left square bracket, index, right
square bracket.
Line 4, indented once, Decrement index.
Line 5, Set data, left square bracket, index plus 1, right square
bracket, equals item.
Line 6, Increment length.
Back to Figure
Line 1, void, Sorted List, 2 colon symbols, Insert, left parenthesis,
Item Type item, right parenthesis.
Line 2, 2 forward slash, Search for insertion point begins at the end
dot. Items are compared.
Line 3, 2 forward slash, and shifted until insertion place is found.
Line 4, left brace.
Line 5, indented once, int index, semicolon.
Line 6, indented once, index equals, length minus 1, semicolon.
Line 7, indented once, while, left parenthesis, index greater than or

equal to 0, 2 ampersand symbols, item less than data, left square
bracket, index, right square bracket, right parenthesis.
Line 8, indented once, left brace.
Line 9, indented twice, data, left square bracket, index plus 1, right
square bracket, equals, data, left square bracket, index, right square
bracket, semicolon.
Line 10, indented twice, index minus minus, semicolon.
Line 11, indented once, right brace.
Line 12, indented once, data, left square bracket, index plus 1, right
square bracket, equals index, semicolon, 2 forward slash, Insert
item.
Line 13, indented once, length plus plus, semicolon.
Line 14, right brace.
Back to Figure
Line 1, 2 forward slash, Sequential search in a sorted list.
Line 2, blank line.
Line 3, index equals 0, semicolon.
Line 4, while, left parenthesis, index less than length, 2 ampersand
symbols, item greater than data, left square bracket, index, right
square bracket, right parenthesis.
Line 5, indented one times, index plus plus, semicolon.
Line 6, found, equals, left parenthesis, index less than length, 2
ampersand symbols, item, 2 equal to symbol, data, left square
bracket, index, right square bracket, right parenthesis, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: void, int, while, if, else.
Line 1, void Sorted List, 2 colon symbols.
Line 2, indented three times, Binary Search, left parenthesis, Item
Type item comma, bool ampersand found comma, int ampersand
position, right parenthesis, const.
Line 3, 2 forward slash, Uses binary search algorithm to search list
for item dot.
Line 4, 2 forward slash, If item is found comma, found is true and
position is its index, semicolon.

Line 5, 2 forward slash, else found is false and position is undefined.
Line 6, left brace.
Line 7, indented once, int first equals 0, semicolon, 2 forward slash,
Lower bound on list.
Line 8, indented once, int last equals length minus 1, semicolon, 2
forward slash, Upper bound on list.
Line 9, indented once, int middle, semicolon, 2 forward slash, Middle
index.
Line 10, indented once, found equals false, semicolon.
Line 11, indented once, while, left parenthesis, last greater than or
equal to first, 2 ampersand symbols, exclamation symbol, found,
right parenthesis.
Line 12, indented once, left brace.
Line 13, indented twice, middle equals, left parenthesis, first plus
last, right parenthesis, divided by 2, semicolon.
Line 14, indented twice, if, left parenthesis, item less than data, left
square bracket, middle, right square bracket, right parenthesis.
Line 15, indented three times, 2 forward slash, item is not in data,
left square bracket, middle, dot dot dot, last, right square bracket.
Line 16, indented three times, last equals, middle minus 1,
semicolon.
Line 17, indented twice, else if, left parenthesis item greater than
data, left square bracket, middle, right square bracket, right
parenthesis.
Line 18, indented three times, 2 forward slash, items is not in the
data, left square bracket, first, dot dot, middle, right square bracket.
Line 19, indented three times, first equals middle plus 1, semicolon.
Line 20, indented twice, else.
Line 21, indented three times, 2 forward slash, item, 2 equal to
symbols, data, left square bracket, middle, right square bracket.
Line 22, indented three times, found equals true, semicolon.
Line 23, indented once, right brace.
Line 24, indented once, if, left parenthesis, found, right parenthesis.
Line 25, indented twice, position equals middle, semicolon.
Line 26, right brace.
Back to Figure

A group of 11 rectangles stacked vertically up. Each rectangle has
the following entries made to its left hand side, from top to bottom:
left square bracket, 0, right square bracket; left square bracket, 1,
right square bracket; left square bracket, 2, right square bracket; left
square bracket, 3, right square bracket; left square bracket, 4, right
square bracket; left square bracket, 5, right square bracket; left
square bracket, 6, right square bracket; left square bracket, 7, right
square bracket; left square bracket, 8, right square bracket; left
square bracket, 9, right square bracket; left square bracket, 10, right
square bracket. The values in each rectangle, from top to bottom,
are as follows: 12, 64, 72, 86, 92, 103, 106, 125, 200, 300, and 400.
A text pointed at the rectangle labeled, left square bracket, 0, right
square bracket, reads as follows: first. A text pointed at the
rectangle labeled, left square bracket, 5, right square bracket, reads
as follows: middle. A text pointed at the rectangle labeled, left
square bracket, 10, right square bracket, reads as follows: last.
Back to Figure
A group of 11 rectangles stacked vertically up. Each rectangle has
the following entries made to its left hand side, from top to bottom:
left square bracket, 0, right square bracket; left square bracket, 1,
right square bracket; left square bracket, 2, right square bracket; left
square bracket, 3, right square bracket; left square bracket, 4, right
square bracket; left square bracket, 5, right square bracket; left
square bracket, 6, right square bracket; left square bracket, 7, right
square bracket; left square bracket, 8, right square bracket; left
square bracket, 9, right square bracket; left square bracket, 10, right
square bracket. The values in each rectangle, from top to bottom,
are as follows: 12, 64, 72, 86, 92, 103, 106, 125, 200, 300, and 400.
A text pointed at the rectangle labeled, left square bracket, 0, right
square bracket, reads as follows: first and middle. A text pointed at
the rectangle labeled, left square bracket, 1, right square bracket,
reads as follows: last. A text labeled from the rectangle, left square
bracket, 2, right square bracket, to, left square bracket, 10, right
square bracket, reads as follows: 24 cannot be in this part of the list.
Back to Figure

Row entries are as follows. Row 1: 106, 0, 10, 5, 103, blank. Row 2:
Blank, 6, 10, 8, 200, blank. Row 3: Blank, 6, 7, 6, 106, found,
equals, true. Row 4: 400, 0, 10, 5, 103, blank. Row 5: Blank, 6, 10,
8, 200, blank. Row 6: Blank, 9, 10, 9, 300, blank. Row 7: Blank, 10,
10, 10, 400, found, equals, true. Row 8: 406, 0, 10, 5, 103, blank.
Row 9: blank, 0, 6, 10, 8, 200, blank. Row 10: blank, 9, 10, 9, 300,
blank. Row 11: Blank, 10, 10, 10, 400, blank. Row 12: Blank, 11, 10,
blank, blank, last, left angled bracket, first. Row 13: Blank, blank,
blank, blank, blank, found, equals, false.
Back to Figure
The words in the variable names are merged. The code has the
following keywords: bool, int, return, const, found, and position.
Line 1: bool, Sorted List, colon, colon, Is There, left parenthesis,
Item Type, item, right parenthesis, const.
Line 2: 2 forward slashes, Calls helper function, Binary Search, to
look for item.
Line 3: left brace.
Line 4: indented once, bool found, semicolon.
Line 5: indented once, int position, semicolon, 2 forward slashes,
Not used but required for Binary Search.
Line 6: indented once, Binary Search, left parenthesis, item comma,
found comma, position, right parenthesis, semicolon.
Line 7: indented once, return found, semicolon.
Line 8: right brace.
Back to Figure
Line 1: Set data, left square bracket, position, right square bracket,
equals, data, left square bracket, position plus 1, right square
bracket.
Line 2: Set data, left square bracket, position plus 1, right square
bracket, equals, data, left square bracket, position plus 2, right
square bracket.
Line 3: dot, dot.
Line 4: dot, dot.
Line 5: dot, dot.

Back to Figure
The words in the variable names are merged. The code has the
following keywords: bool, found, int, if, for, index, found, and
position.
Line 1: void, Sorted List, colon, colon, Delete, left parenthesis, Item
Type item, right parenthesis.
Line 2: 2 forward slashes, Calls helper function, Binary Search, to
find if the item is in the list.
Line 3: 2 forward slashes, and the index position if there.
Line 4: left brace.
Line 5: indented once, bool found, semicolon, 2 forward slashes,
True if item is found.
Line 6: indented once, int position, semicolon, 2 forward slashes,
Position of item, if found.
Line 7: indented once, int index, semicolon, 2 forward slashes, Index
and loop control variable.
Line 8: indented once, Binary Search, left parenthesis, item comma,
found comma, position, right parenthesis, semicolon.
Line 9: indented once, if, left parenthesis, found, right parenthesis.
Line 10: indented once, left brace.
Line 11: indented twice, 2 forward slashes, shift data, left square
bracket, position, dot dot, length minus 1, right square bracket, up
one position.
Line 12: indented twice, for, left parenthesis, index equals position,
semicolon, index, left angled bracket, length minus 1, semicolon,
index plus plus, right parenthesis.
Line 13: indented thrice, data, left square bracket, index, right
squared bracket, equals, data, left square bracket, index plus 1,
right squared bracket, semicolon.
Line 14: indented twice, length minus minus, semicolon.
Line 15: indented once, right brace.
Line 16: right brace.
Back to Figure
The words in the variable names are merged.
Line 1: 2 forward slashes, asterisks till the end of line.
Line 2: 2 forward slashes, This program inputs a file of words

comma, stores the words comma, removing.
Line 3: 2 forward slashes, duplicates comma, and outputs the list.
Line 4: 2 forward slashes, asterisks till the end of line.
Line 5: hash, include, left angled bracket, f stream, right angled
bracket, 2 forward slashes, For file I slash O.
Line 6: hash, include, double quote, Sorted List dot h, double quote,
2 forward slashes, For List class.
Line 7: using name space s t d, semicolon.
Line 8: int main, left parenthesis, right parenthesis.
Line 9: left brace.
Line 10: indented once, Sorted List, words, semicolon, 2 forward
slashes, List of words.
Line 11: indented once, string, one Word, semicolon, 2 forward
slashes, One word.
Line 12: indented once, if stream, in Data, semicolon, 2 forward
slashes, File of temperature readings.
Line 13: indented once, of stream, out Data, semicolon, 2 forward
slashes, Output file.
Line 14: indented once, in Data dot open, left parenthesis, double
quote, words dot dat, double quote, right parenthesis, semicolon.
Line 15: indented once, if, left parenthesis, exclamation mark, in
Data, right parenthesis.
Line 16: indented once, left brace.
Line 17: indented twice, out Data, 2 left angled brackets, double
quote, Cannot open file words dot dat, double quote, 2 left angled
brackets, end l, semicolon.
Line 18: indented twice, return 1, semicolon.
Line 19: indented once, left brace.
Line 20: indented once, out Data dot open, left parenthesis, double
quote, words dot a n s, double quote, right parenthesis, semicolon.
Line 21: indented once, in Data, 2 right angled brackets, one Word,
semicolon, 2 forward slashes, Get a word.
Line 22: indented once, while, left parenthesis, in Data, 2
ampersands, exclamation mark, words dot Is Full, left parenthesis, 2
right parenthesis.
Line 24: indented once, left brace.
Back to Figure

Line 1: indented twice, if, left parenthesis, exclamation mark, words
dot Is There, left parenthesis, one Word, 2 right parenthesis.
Line 2: indented thrice, words dot Insert, left parenthesis, one Word,
right parenthesis, semicolon.
Line 3: indented twice, in Data, 2 right angled brackets, one Word,
semicolon.
Line 4: indented once, right brace.
Line 5: indented once, 2 forward slashes, Output original list.
Line 6: indented once, 2 forward slashes, Set up for an iteration.
Line 7: indented once, out Data, 2 left angled brackets, words dot
Get Length, left parenthesis, right parenthesis, 2 left angled
brackets, double quote, unique words, end period, double quote, 2
left angled brackets, end l, semicolon.
Line 8: indented once, while, left parenthesis, words dot Has Next,
left parenthesis, 2 right parenthesis.
Line 9: indented once, left brace.
Line 10: indented twice, one Word, equals, words dot Get Next Item,
left and right parentheses, semicolon.
Line 11: indented twice, out Data, 2 left angled brackets, one Word,
2 left angled brackets, end l, semicolon.
Line 12: indented once, right brace.
Line 13: indented once, in Data dot close, left and right parentheses,
semicolon.
Line 14: indented once, out Data dot close, left and right
parentheses, semicolon.
Line 15: indented once, return 0, semicolon.
Line 16: right brace.
Back to Figure
Line 1: hash, include, left angled bracket, string, right angled
bracket.
Line 2: using name space s t d, semicolon.
Line 3: type def, string, Item Type, semicolon, 2 forward slashes,
Type of each component.
Back to Figure

Row entries are as follows. Row 1: 2; 1. Row 2: 4; 2. Row 3: 8; 3.
Row 4: 16; 4. Row 5: 32; 5. Row 6: 1024; 10. Row 7: 32,768; 15.
Row 8: 1,048,576; 20. Row 9: 33,554,432; 25. Row 10:
1,073,741,824; 30.
Back to Figure
The words in the variable names are merged. The code contains the
following keywords: include, const, return, private, int and public.
Line 1: 2 forward slashes, asterisks till the end of line.
Line 2: 2 forward slashes, specification file in uppercase, left
parenthesis, Entry dot h, right parenthesis.
Line 3: 2 forward slashes, This file contains the specifications of the
Entry, A D T in uppercase, which has.
Line 4: 2 forward slashes, two contained classes, Name and Time.
Line 5: 2 forward slashes, A compared To, function has been added
to this class.
Line 6: 2 forward slashes, asterisks till the end of line.
Line 7: hash include, double quote, Time of Day dot h, double quote.
Line 8: hash include, double quote, Name dot h, double quote.
Line 9: hash include, left angled bracket, s stream, right angled
bracket.
Line 10: hash include, left angled bracket, string, right angled
bracket.
Line 11: hash include, double quote, Relation Type dot h, double
quote.
Line 12: class Entry.
Line 13: left brace.
Line 14: public, colon.
Line 15: indented once, string Get Name, S t r, left and right
parenthesis, const, semicolon.
Line 16: indented once, 2 forward slashes, Post, colon, Returns the
first and last name of Name object.
Line 17: indented once, 2 forward slashes, with a blank in between.
Line 18: indented once, string, Get Time, S t r, left and right
parenthesis, const, semicolon.
Line 19: indented once, 2 forward slashes, Post, colon, Returns the
hours and minutes from Time Of Day, object.
Line 20: indented once, 2 forward slashes, with a colon in between.

Line 21: indented once, Entry, left and right parenthesis, semicolon.
Line 22: indented once, 2 forward slashes, Default constructor.
Line 23: indented once, 2 forward slashes, Post, colon, Entry object
has been constructed.
Line 24: indented once, 2 forward slashes, Name and Time Of Day,
objects have been constructed using.
Line 25: indented once, 2 forward slashes, their default constructors.
Line 26: indented once, Entry, left parenthesis, string, first Name
comma, string, middle Name comma, string last Name comma.
Line 27: indented 4 times, int, in it hours comma, int, in it Minutes
comma, int, in it Seconds, right parenthesis, semicolon.
Line 28: indented once, 2 forward slashes, Parameterized
constructor.
Line 29: indented once, 2 forward slashes, Post, colon, Entry object
has been constructed.
Line 30: indented once, 2 forward slashes, Name and Time Of Day
objects have been constructed using.
Line 31: indented once, 2 forward slashes, their parameterized
constructors.
Back to Figure
The words in the variable names are merged. The code contains the
following keywords: Post, private, return, and const.
Line 1: indented once, Relation Type, Compared To, left parenthesis,
Entry other Entry, right parenthesis, const, semicolon.
Line 2: indented once, 2 forward slashes, Post, colon, Returns.
Line 3: indented once, 2 forward slashes, Before in uppercase, if
instance apostrophe s, time object is earlier than other Entry
apostrophe s.
Line 4: indented once, 2 forward slashes, same in uppercase, if they
are identical.
Line 5: indented once, 2 forward slashes, after in uppercase, if
instance apostrophe s, time object is later than other Entry
apostrophe s.
Line 6: private, colon.
Line 7: indented once, Name name, semicolon.
Line 8: indented once, Time Of Day, time, semicolon.
Line 9: right brace, semicolon.

Line 10: Relation Type, Entry, colon colon, Compared To, left
parenthesis, Entry other Entry, right parenthesis, const.
Line 11: left brace.
Line 12: indented twice, return, left parenthesis, time dot Compared
To, left parenthesis, other Entry dot time, 2 right parenthesis,
semicolon.
Line 13: right brace.
Back to Figure
Line 1: Binary Search, left parenthesis, In, colon, item comma, Out,
colon, found comma, position, right parenthesis.
Line 2: While in uppercase, last, right angled bracket equals, first
and, exclamation mark, found.
Line 3: indented thrice, Set middle to, left parenthesis, first plus last,
right parenthesis, forward slash, 2.
Line 4: indented thrice, switch in uppercase, left parenthesis, item
dot Compared To, left parenthesis, data, left square bracket, middle,
right square bracket, right parenthesis.
Line 5: indented 6 times, before in uppercase, colon, Set last to
middle en dash 1.
Line 6: indented 6 times, same in uppercase, colon, Set found to
true.
Line 7: indented 9 times, Set position to middle.
Line 8: indented 6 times, after in uppercase, colon, Set first to
middle plus 1.
Back to Figure
Line 1: Is There, left parenthesis, In, colon, item, right parenthesis.
Line 2: indented once, Return value, colon, Boolean.
Line 3: Binary Search, left parenthesis, item comma, found comma,
position, right parenthesis.
Line 4: return found.
Back to Figure
The code contains the following keywords: int, while, case, found
and void.

Line 1: void Sorted List, colon, colon, Binary Search, left
parenthesis, Item Type item comma, bool ampersand found comma,
int ampersand position, right parenthesis, const.
Line 2: 2 forward slashes, Uses binary search algorithm to search
list for item.
Line 3: 2 forward slashes, If item is found comma, found is true and
position is its index, semicolon.
Line 4: 2 forward slashes, else found is false and position is
undefined.
Line 5: left brace.
Line 6: indented once, int, first equals 0, semicolon, 2 forward
slashes, Lower bound on list.
Line 7: indented once, int last equals length en dash 1, semicolon, 2
forward slashes, Upper bound on list.
Line 8: indented once, int middle, semicolon, 2 forward slashes,
Middle index.
Line 9: indented once, found equals false, semicolon.
Line 10: indented once, while, left parenthesis, last, right angled
bracket equals, first 2 ampersands, exclamation mark, found, right
parenthesis.
Line 11: indented once, left brace.
Line 12: indented twice, middle, equals, left parenthesis, first plus
last, right parenthesis, forward slash, 2, semicolon.
Line 13: indented twice, switch, left parenthesis, item dot Compared
To, left parenthesis, data, left parenthesis, middle, right square
bracket, 2 right parenthesis.
Line 14: indented twice, left brace.
Line 15: indented thrice, case, before in uppercase, colon, last
equals middle en dash 1, semicolon.
Line 16: indented 12 times, break, semicolon.
Line 17: indented thrice, case, same in uppercase, colon, found
equals true, semicolon.
Line 18: indented 12 times, position equals middle, semicolon.
Line 19: indented 12 times, break, semicolon.
Line 20: indented thrice, case, after in uppercase, colon, first equals
middle plus 1, semicolon.
Line 21: indented 12 times, break, semicolon.
Line 22: indented twice, right brace.

Line 23: indented once, right brace.
Line 24: right brace.
Back to Figure
The code contains the following keywords: int, while, index, and void.
Line 1: void Sorted List, colon, colon, Insert, left parenthesis, Item
Type item, right parenthesis.
Line 2: 2 forward slashes, Search for insertion point begins at the
end. Items are compared.
Line 3: 2 forward slashes, and shifted until insertion place is found.
Line 4: left brace.
Line 5: indented twice, int, index, semicolon.
Line 6: indented twice, index equals length en dash 1, semicolon.
Line 7: indented twice, while, left parenthesis, index, right angled
bracket equals, 0, 2 ampersands, item dot Compared To, left
parenthesis, data, left parenthesis, data, left square bracket, index,
right square bracket, right parenthesis, two equals, before in
uppercase, right parenthesis.
Line 8: indented twice, left brace.
Line 9: indented thrice, data, left square bracket, index plus 1, right
square bracket, equals, data, left square bracket, index, right square
bracket, semicolon.
Line 10: indented thrice, index, minus, minus, semicolon.
Line 11: indented twice, right brace.
Back to Figure
Line 1: indented twice, data, left square bracket, index plus 1, right
square bracket, equals, item, semicolon, 2 forward slashes, Insert
item.
Line 12: indented twice, length plus plus, semicolon.
Line 3: right brace.
Back to Figure
The words in the variable names and functions are merged. The
code contains the following keywords: include, if, while, c out, while, i
o stream, int and end l.

Line 1: 2 forward slashes, asterisks till the end of line.
Line 2: 2 forward slashes, driver in uppercase, for class Sorted List
of Entry objects.
Line 3: 2 forward slashes, asterisks till the end of line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket.
Line 5: hash include, doubt quote, Entry dot h, double quote.
Line 6: hash include, double quote, Relation Type dot h, double
quote.
Line 7: hash include, double quote, Sorted List dot h, double quote.
Line 8: hash include, left angled bracket, string, right angled bracket.
Line 9: using name space, s t d, semicolon.
Line 10: int main, left and right parenthesis.
Line 11: left brace.
Line 12: indented once, Sorted List, list, semicolon.
Line 13: indented once, Entry, entry 1, left parenthesis, double
quote, Sally, double quote, comma, double quote, Jane, double
quote, comma, double quote, smith, double quote, comma, 12
comma, 20 comma, 0, right parenthesis, semicolon.
Line 14: indented once, Entry, entry 2, left parenthesis, double
quote, Mary, double quote comma, double quote, Beth, double
quote, comma, double quote, Jones, double quote, comma, 10
comma, 30 comma, 0, right parenthesis, semicolon.
Line 15: indented once, Entry, entry 3, left parenthesis, double
quote, Bill, double quote, comma, double quote, John, double quote,
comma, double quote, Baker, double quote, comma, 8 comma, 25
comma, 30, right parenthesis, semicolon.
Line 16: indented once, list dot Insert, left parenthesis, entry 1, right
parenthesis, semicolon.
Line 17: indented once, list dot Insert, left parenthesis, entry 2, right
parenthesis, semicolon.
Line 18: indented once, list dot Insert, left parenthesis, entry 3, right
parenthesis, semicolon.
Line 19: indented once, if, left parenthesis, list dot Is There, left
parenthesis, entry 2, 2 right parenthesis.
Line 20: indented twice, c out, 2 left angled brackets, double quote,
Duplicate, colon, double quote, 2 left angled bracket, entry 2 dot Get
Name S t r, left and right parenthesis, 2 left angled brackets, double
quote, not inserted, double quote.

Line 21: indented 5 times, 2 left angled brackets, end l, semicolon.
Line 22: indented once, list dot Reset List, left and right parenthesis,
semicolon.
Line 23: indented once, while, left parenthesis, list dot Has Next, left
parenthesis, 2 right parenthesis.
Line 24: indented once, left brace.
Line 25: indented twice, entry 1 equals list dot Get Next Item, left
and right parenthesis, semicolon.
Line 26: indented twice, c out, 2 left angled brackets, entry 1 dot Get
Name S t r, left and right parenthesis, 2 left angled brackets, 2
double quotes, 2 left angled brackets, entry 1 dot Get Time S t r, left
and right parenthesis, 2 left angled brackets, end l, semicolon.
Line 27: indented once, right brace.
Line 28: right brace.
Back to Figure
Line 1: Duplicate colon, Mary Jones not inserted.
Line 2: Bill Baker, 0 8 colon 25 colon 30.
Line 3: Mary Jones, 10 colon 30 colon 0 0.
Line 4: Sally Smith, 12 colon 20 colon 0 0.
Back to Figure
Words in the commands are merged.
Line 1: hash, if n def, some class in uppercase.
Line 2: hash, define, some class in uppercase.
Line 3: dot dot dot.
Line 4: hash, end if.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: class, public, string, float.
Line 1, class Student.
Line 2, 2 forward slash, This class represents a student's name with
a grade.
Line 3, left brace.
Line 4, public, colon.

Line 5, indented once, Student, left parenthesis, float in it Grade
comma, string in it Name, right parenthesis, semicolon.
Line 6, indented once, 2 forward slash, Parameterized constructor.
Line 7, indented once, 2 forward slash, Post, colon, Student object
has been constructed with grade and name.
Line 8, indented once, blank line.
Line 9, indented once, Student, left parenthesis, right parenthesis,
semicolon.
Line 10, indented once, 2 forward slash, Default constructor.
Line 11, indented once, 2 forward slash, Post, colon, Empty Student
object has been constructed.
Line 12, blank line.
Line 13, 2 forward slash, Knowledge responsibilities.
Line 14, indented once, string, Get Name, left parenthesis, right
parenthesis, const, semicolon.
Line 15, indented once, 2 forward slash, Post, colon, Returns the
name from the Student object.
Line 16, indented once, float Get Grade, left parenthesis, right
parenthesis, const, semicolon.
Line 17, indented once, Relation Type Compared To, left
parenthesis, Student other Student, right parenthesis, const,
semicolon.
Line 18, indented once, 2 forward slash, Post, colon, Returns.
Line 19, indented once, 2 forward slash, BEFORE if other Student's
grade is greater than instance's.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: private, string, float.
Line 1, indented once, 2 forward slash, SAME if they are identical.
Line 2, indented once, 2 forward slash, AFTER if instance's grade is
less than other Student's.
Line 3, private.
Line 4, indented once, string name, semicolon, 2 forward slash, First
and last name in string form.
Line 5, indented once, float grade, semicolon.
Line 6, right brace, semicolon.

Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, class, public,
float, int, void.
Line 1, hashtag include, double quotes, Sorted List dot h, double
quotes.
Line 2, class Statistics List.
Line 3, left brace.
Line 4, public, colon.
Line 5, indented once, Statistics List, left parenthesis, if stream
ampersand in File, right parenthesis, semicolon.
Line 6, indented once, 2 forward slash, Parameterized constructor.
Line 7, indented once, 2 forward slash, Pre, colon, in File contains
no more than 100 student records.
Line 8, indented once, 2 forward slash, Post, colon, List of students
has been created from file in File.
Line 9, indented once, 2 forward slash, Has calculated average
comma, max Grade comma, number below the average.
Line 10, indented once, 2 forward slash, Knowledge responsibilities.
Line 11, indented once, float Get Average, left parenthesis, right
parenthesis const, semicolon.
Line 12, indented once, 2 forward slash, Post, colon, Returns
average of the grades.
Line 13, indented once, float Get Max Grade, left parenthesis, right
parenthesis, const, semicolon.
Line 14, indented once, 2 forward slash, Post, colon, Returns
maximum grade.
Line 15, indented once, int Get Above Average, left parenthesis,
right parenthesis, const, semicolon.
Line 16, indented once, 2 forward slash, Post, colon, Returns the
number of students whose grade was above the average.
Line 17, indented once, int Get Below Average, left parenthesis,
right parenthesis, const, semicolon.
Line 18, indented once, 2 forward slash, Post, colon, Returns the
number of students whose grade was below the average.
Line 19, indented once, float, Get Mini Grade, left parenthesis, right
parenthesis, semicolon.
Line 20, indented once, 2 forward slash, Post, colon, Returns the

minimum grade.
Line 21, blank line.
Line 22, 2 forward slash, Action responsibilities.
Line 23, indented once, void, Students Max Grade, left parenthesis,
of stream ampersand out File, right parenthesis.
Line 24, indented once, 2 forward slash, Post, colon, Student, left
parenthesis, s, right parenthesis, with the maximum grade output on
file out File.
Line 25, indented once, void, Students Above, left parenthesis, of
stream ampersand out File, right parenthesis, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: void, private, float, int.
Line 1, indented once, 2 forward slash, Post, colon, Students whose
grades were average or above output on out File.
Line 2, indented once, void, Student Below, left parenthesis, of
stream ampersand out File, right parenthesis, semicolon.
Line 3, indented once, 2 forward slash, Post, colon, Students whose
grades were below average output on out File.
Line 4, blank line.
Line 5, blank line.
Line 6, private, colon.
Line 7, indented once, float average, semicolon.
Line 8, indented once, float max Grade, semicolon.
Line 9, indented once, int num Below, semicolon.
Line 10, indented once, Sorted List list, semicolon, 2 forward slash,
List of grade, forward slash, name prize.
Line 11, right brace, semicolon.
Back to Figure
Heading: StatisticsList(In/out: inFile) (only constructor). Line 1. Get
student. Line 2. WHILE more students. Line 3, indented once. Insert
student into grade list. Line 4, indented once.
Set sum to sum plus student dot Get Grade, elft parenthesis,right
parenthesis. Line 5, indented once. IF student dot grade greater
than max So Far. Line 6, indented twice. Set max So Far to student

dot Get Grade, left parenthesis, right parenthesis. Line 7, indented
once. Get student. Line 8. Set average to sum divided by list dot
Get Length, left parenthesis, right parenthesis. Line 9. WHILE, left
parenthesis, list dot Get Next Item, left parenthesis, right
parenthesis, dot, Get Grade, left parenthesis, right parenthesis, less
than, average, right parenthesis. Line 10, indented once. Increment
num Below. Heading: Get Student (In/out: in File). Line 1. Return
value, colon, Student. Line 2. in File, double right angle bracket,
student dot grade, double right angle bracket, student dot get line.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, float, string.
Line 1, 2 forward slash, followed by asterisks till the end of the line.
Line 2, 2 forward slash, Implementation file for class Statistics List.
Line 3, 2 forward slash followed by asterisks till the end of the line.
Line 4, blank line.
Line 5, blank line.
Line 6, hashtag include, double quotes, Statistics List dot h, double
quotes.
Line 7, Statistics List, 2 colon symbols, Statistics List, left
parenthesis, if stream ampersand in File, right parenthesis.
Line 8, left brace.
Line 9, indented once, float grade, semicolon.
Line 10, indented once, float sum equals 0, semicolon.
Line 11, indented once, max Grade equals 0, semicolon.
Line 12, indented once, num Below equals 0, semicolon.
Line 13, indented once, string name, semicolon.
Line 14, indented once, in File, 2 left angled brackets, grade,
semicolon.
Line 15, indented once, 2 forward slash, Build list and calculate max
Grade.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: while, if, float, return.
Line 1, indented once, while, left parenthesis, in File, right

parenthesis.
Line 2, indented once, left brace.
Line 3, indented twice, get line, left parenthesis, in File comma,
name, right parenthesis, semicolon.
Line 4, indented twice, Student a Student, left parenthesis, grade
comma, name, right parenthesis, semicolon.
Line 5, indented twice, list dot Insert, left parenthesis, a Student,
right parenthesis, semicolon.
Line 6, indented twice, sum equals sum plus grade, semicolon.
Line 7, indented twice, if, left parenthesis, grade greater than max
Grade, right parenthesis.
Line 8, indented three times, max Grade, equals grade, semicolon.
Line 9, indented twice, in File, 2 left angled brackets, grade,
semicolon.
Line 10, indented once, right brace.
Line 11, blank line.
Line 12, indented once, average equals sum divided by list dot get
Length, left parenthesis, right parenthesis, semicolon.
Line 13, indented once, 2 forward slash, Clash number of grades
below average.
Line 14, indented once, while, left parenthesis, list dot Get Next
Item, left parenthesis, right parenthesis, dot Get Grade, left
parenthesis, right parenthesis, less than average, right parenthesis.
Line 15, indented twice, num Below, plus plus, semicolon.
Line 16, right brace.
Line 17, blank line.
Line 18, 2 forward slash followed by asterisks till the end of the line.
Line 19, blank line.
Line 20, float Statistics List, 2 colon symbols, Get Average, left
parenthesis, right parenthesis, const.
Line 21, left brace.
Line 22, indented once, return average, semicolon.
Line 23, right brace.
Line 24, blank line.
Line 25, 2 forward slash followed by asterisks till the end of the line.
Line 26, blank line.
Line 27, float Statistics List, 2 colon symbols, Get Max Grade, left
parenthesis, right parenthesis, const.
Line 28, left brace.

Line 29, indented once, return Max Grade, semicolon.
Line 30, right brace.
Line 31, blank line.
Line 32, 2 forward slash followed by asterisks till the end of the line.
Line 33, blank line.
Line 34, int Statistical List, 2 colon symbols, Get Below Average, left
parenthesis, right parenthesis, const.
Line 35, left brace.
Line 36, indented once, return num Below, semicolon.
Line 37, right brace.
Line 38, blank line.
Line 39, 2 forward slash followed by asterisks till the end of the line.
Line 40, 2 forward slash followed by asterisks till the end of the line.
Line 41, blank line.
Line 42, int Statistical List, 2 colon symbols, Get Above Average, left
parenthesis, right parenthesis, const.
Line 43, left brace.
Line 44, indented once, return list dot Get Length, left parenthesis,
right parenthesis, equals num Below, semicolon.
Line 45, right brace.
Line 46, blank line.
Line 47, 2 forward slash followed by asterisks till the end of the line.
Line 48, indented once, float Statistical List, 2 colon symbols, Get
Min Grade, left parenthesis, right parenthesis.
Line 49, left brace.
Line 50, indented twice, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 51, indented twice, return list dot Get Next Item, left
parenthesis, right parenthesis, dot Get Grade, left parenthesis, right
parenthesis, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: void, while, end l, for,
include.
Line 1, right brace.
Line 2, blank line.
Line 3, 2 forward slash followed by asterisks till the end of the line.

Line 4, blank line.
Line 5, void Statistics List, 2 colon symbols, Students Max Grade,
left parenthesis, of stream ampersand out File, right parenthesis.
Line 6, left brace.
Line 7, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 8, indented once, Student a Student equals, list dot Get Next
Item, left parenthesis, right parenthesis, semicolon.
Line 9, indented once, out File, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, The following students, left
parenthesis, s, right parenthesis, had the maximum score, colon,
double quotes.
Line 10, indented five times, 2 left angled brackets, end l, semicolon.
Line 11, indented once, while, left parenthesis, max Grade greater
than a Student dot Get Grade, left parenthesis, 2 right parenthesis.
Line 12, indented twice, a Student, equals, list dot Get Next Item,
left parenthesis, right parenthesis, semicolon.
Line 13, indented once, out File, 2 left angled brackets, a Student
dot Get Name, left parenthesis, right parenthesis, 2 left parenthesis,
end l, semicolon.
Line 14, indented once, while, left parenthesis, list dot Has Next, left
parenthesis, 2 right parenthesis.
Line 15, indented twice, out File, 2 left angled brackets, list dot Get
Next Item, left parenthesis, right parenthesis, dot Get Name, left
parenthesis, right parenthesis.
Line 16, indented six times, end l, semicolon.
Line 17, right brace.
Line 18, blank line.
Line 19, 2 forward slash followed by asterisks till the end of the line.
Line 20, blank line.
Line 21, indented once, void Statistics List, 2 colon symbols,
Students Above, left parenthesis, of stream ampersand out File,
right parenthesis.
Line 22, indented once, left brace.
Line 23, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 24, indented once, for, left parenthesis, int count equals 1,
semicolon, count less than or equal to num Below, semicolon, count
plus plus, right parenthesis.

Line 25, indented twice, list dot Get Next Item, left parenthesis,
semicolon.
Line 26, indented once, out File, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, Students who scored above the
average, colon, double quotes, 2 left angled brackets, end l,
semicolon.
Line 27, indented once, for, left parenthesis, int count equals num
Below plus 1, semicolon, count less than list dot Get Length, left
parenthesis, right parenthesis, plus 1, semicolon, count plus plus,
right parenthesis.
Line 28, indented twice, out File, 2 left angled brackets, list dot Get
Next Item, left parenthesis, right parenthesis, dot Get Name, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 29, right brace.
Line 30, blank line.
Line 31, 2 forward slash followed by asterisks till the end of the line.
Line 32, blank line.
Line 33, void Statistics List, 2 colon symbols, Students Below, left
parenthesis, of stream ampersand out File, right parenthesis.
Line 34, left brace.
Line 35, indented once, list dot reset List, left parenthesis, right
parenthesis, semicolon.
Line 36, indented once, out File, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, Students who scored below the
average, colon, double quotes, 2 left angled brackets, end l,
semicolon.
Line 37, indented once, for, left parenthesis, int count equals 1,
semicolon, count less than or equal to num Below, semicolon, count
plus plus, right parenthesis.
Line 38, indented twice, out File, 2 left angled brackets, list dot Get
NExt Item, left parenthesis, right parenthesis, dot Get Name, left
parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 39, right brace.
Line 40, 2 forward slash followed by asterisks till the end of the line.
Line 41, 2 forward slash, DRIVER for class Statistics List of Student
objects.
Line 42, 2 forward slash followed by asterisks till the end of the line.

Line 43, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 44, hashtag include, double quotes, Statistics List dot h, double
quotes.
Line 45, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 46, hashtag include, left angled bracket, string, right angled
bracket.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: using name space, void,
int, main, if, end l, string, c out, c in.
Line 1, using namespace s t d, semicolon.
Line 2, void Open Files, left parenthesis, if stream ampersand in File
comma, of stream ampersand out File, right parenthesis, semicolon.
Line 3, 2 forward slash, Post, colon, Files have been opened.
Line 4, blank line.
Line 5, blank line.
Line 6, int main, left parenthesis, right parenthesis.
Line 7, left brace.
Line 8, indented once, of stream out File, semicolon.
Line 9, indented once, if stream in File, semicolon.
Line 10, indented once, Open Files, left parenthesis, in File comma,
out File, right parenthesis, semicolon.
Line 11, indented once, if, left parenthesis, exclamation in File, 2
vertical bars, exclamation, out File, right parenthesis.
Line 12, indented once, left brace.
Line 13, indented twice, c out, 2 left angled brackets, double quotes,
Error opening files, double quotes, 2 left angled brackets, end l,
semicolon.
Line 14, indented twice, return 1, semicolon.
Line 15, indented once, right brace.
Line 16, indented once, Statistics List grades, left parenthesis, in
File, right parenthesis, semicolon.
Line 17, indented once, out File, 2 left angled brackets, double
quotes, Average, colon, double quotes, 2 left angled brackets,
grades dot Get Average, left parenthesis, right parenthesis, 2 left

angled brackets, end l, semicolon.
Line 18, indented once, out File, 2 left angled brackets, double
quotes, Minimum grade, colon, double quotes, 2 left angled
brackets, grades dot Get Mini Grade, left parenthesis, right
parenthesis, 2 left angled brackets, end l, semicolon.
Line 19, indented once, out File, 2 left angled brackets, double
quotes, Maximum grade, colon, double quotes, 2 left angled
brackets, grades dot Get Max Grade, left parenthesis, right
parenthesis, 2 left angled brackets, end l, semicolon.
Line 20, indented once, out File, 2 left angled brackets, grades dot
Get Below Average, left parenthesis, right parenthesis.
Line 21, indented five times, 2 left angled brackets, double quotes,
students had grades below the average dot, double quotes, 2 left
angled brackets, end l, semicolon.
Line 22, indented once, out File, 2 left angled brackets, grades dot
Get Above Average, left parenthesis, right parenthesis.
Line 23, indented five times, 2 left angled brackets, double quotes,
students had grades above the average dot, double quotes, 2 left
angled brackets, end l, semicolon.
Line 24, indented once, grades dot Students Max Grade, left
parenthesis, out File, right parenthesis, semicolon.
Line 25, indented once, grades dot Students Above, left parenthesis,
out File, right parenthesis, semicolon.
Line 26, indented once, grades dot Students Below, left parenthesis,
out File, right parenthesis, semicolon.
Line 27, indented once, in File dot, close, left parenthesis, right
parenthesis, semicolon.
Line 28, indented once, out File dot, close, left parenthesis, right
parenthesis, semicolon.
Line 29, right brace.
Line 30, blank line.
Line 31, 2 forward slash followed by asterisks till the end of the line.
Line 32, blank line.
Line 33, void, Open Files, left parenthesis, if stream ampersand in
File comma, of stream ampersand out File, right parenthesis.
Line 34, 2 forward slash, Post, colon, Files have been opened.
Line 35, left brace.
Line 36, indented once, string in File Name, semicolon, 2 forward
slash, User specified input file name.

Line 37, indented once, string out File Name, semicolon, 2 forward
slash, User specified output file.
Line 38, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the input file dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 39, indented once, c in, 2 right angled brackets, in File Name,
semicolon.
Line 40, indented once, in File dot open, left parenthesis, in File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 41, indented once, c out, 2 left angled brackets, double quotes,
Enter the name of the output file dot, double quotes, 2 left angled
brackets, end l, semicolon.
Line 42, indented once, c in, 2 right angled brackets, out File Name,
semicolon.
Line 43, indented once, out File dot open, left parenthesis, out File
Name dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 44, indented once, out File, 2 left angled brackets, double
quotes, Statistics for grades in file, double quotes, 2 left angled
brackets, in File Name, 2 left angled brackets, end l, semicolon.
Line 45, indented once, out File, 2 left angled brackets, fixed,
semicolon.
Line 46, right brace.
Back to Figure
Line 1, 0, Bill Bly.
Line 2, 100, Mary Jones.
Line 3, 100, Martha Jones.
Line 4, 65, Anne Margaret.
Line 5, 82.0, Susy Sunshine.
Line 6, 78, Jim Jones.
Line 7, 99, Alex Dale.
Line 8, 67.5, Claire Clear.
Line 9, 99, Chris Dale.
Line 10, 55, Mary Moonlight.
Back to Figure

Line 1, Statistics for grades in file Statistics dot d a t.
Line 2, Average, colon, 74.550003
Line 3, Minimum grade, colon, 0.000000.
Line 4, Maximum grade, colon, 100.000000.
Line 5, 4 students had grades below the average dot.
Line 6, 6 students had grades above the average dot.
Line 7, blank line.
Line 8, blank line.
Line 9, The following student, left parenthesis, s, right parenthesis,
had the maximum score, colon.
Line 10, indented once, Mary Jones.
Line 11, indented once, Martha Jones.
Line 12, blank line.
Line 13, blank line.
Line 14, Students who scored above the average, colon.
Line 15, indented once, Jim Jones.
Line 16, indented once, Susy Sunshine.
Line 17, indented once, Alex Dale.
Line 18, indented once, Chris Dale.
Line 19, indented once, Mary Jones.
Line 20, indented once, Martha Jones.
Line 21, blank line.
Line 22, blank line.
Line 23, Students who scored below the average, colon.
Line 24, indented once, Bill Bly.
Line 25, indented once, Mary Moonlight.
Line 26, indented once, Anne Margaret.
Line 27, indented once, Claire Clear.
Back to Figure
Row entries are as follows. Row 1: Student. Row 2: Line 1; Minus,
name, semicolon, string. Row 2: Line 2; Minus, grade, semicolon,
float. Row 3: Line 1; Plus, student, left parenthesis, init Grade,
colon, float, comma, init Name, colon, string, right parenthesis. Row
3: Line 2; Plus, Get Name, left parenthesis, right parenthesis, colon,
string. Row 3: Line 3; Plus, Get Grade, left parenthesis, right
parenthesis, colon, float.

Back to Figure
Row entries are as follows. Row 1: Statistics List. Row 2: Line 1;
Minus, average, colon, float. Row 2: Line 2; Minus, max Grade,
colon, float. Row 2: Line 3; Minus, num Below, colon, int. Row 3:
Line 1; Plus, statistics List, left parenthesis, in File, colon, i f stream,
right parenthesis. Row 3: Line 2; Plus, Get Average, left
parenthesis, right parenthesis, colon, float. Row 3: Line 3; Plus, Get
Max Grade, left parenthesis, right parenthesis, colon, float. Row 3:
Line 4; Plus, Get Above Average, left parenthesis, right parenthesis,
int. Row 3: Line 5; Plus, Get Below Average, left parenthesis, right
parenthesis, int. Row 3: Line 5; Plus, Get Min Grade, left
parenthesis, right parenthesis, colon, float. Row 4: Line 1; Plus,
Student Max Grade, left parenthesis, out File, colon, o f stream,
right parenthesis. Row 4: Line 2; Plus, Student Above, left
parenthesis, out File, colon, o f stream, right parenthesis. Row 4:
Line 3; Plus, Student Below, left parenthesis, out File, colon, o f
stream, right parenthesis.
Back to Figure
Row entries are as follows. Row 1: Sorted List. Row 2: Line 1;
Minus, length, colon, int. Row 2: Line 2; Minus, current Pos, colon,
int. Row 2: Line 3; Minus, data, left square bracket, MAX,
underscore, LENGTH, right square bracket, colon, item Type. Row
3: Line 1; Plus, Sorted List, left parenthesis, right parenthesis. Row
3: Line 2; Plus, Get Length, left parenthesis, right parenthesis,
colon, int. Row 3: Line 3; Plus, Is Empty, left parenthesis, right
parenthesis, colon, bool. Row 3: Line 4; Plus, Is There, left
parenthesis, item, colon, item Type, right parenthesis, colon, bool.
Row 3: Line 5; Plus, Is Full, left parenthesis, right parenthesis, colon,
bool. Row 3: Line 6; Plus, Insert, left parenthesis, item, colon, item
Type, right parenthesis. Row 3: Line 7; Plus, Delete, left parenthesis,
item, colon, item Type, right parenthesis. Row 3: Line 8; Plus, Reset
List, left parenthesis, right parenthesis. Row 3: Line 9; Plus, Has
Next, left parenthesis, right parenthesis, colon, bool. Row 3: Line 10;
Minus, Binary Search, left parenthesis, item, item Type, comma,
found, colon, bool, comma, position, colon, int, right parenthesis.

Back to Figure
The class Main points to the class Statistics List. The classes,
Student and Sorted List are placed below statistics List on either
sides. Statistics List class points to Student class and Sorted List
class. Sorted List class points to Student class.
Back to Figure
Line 1, void Open File, left parenthesis, if stream ampersand text,
right parenthesis.
Line 2, left brace.
Line 3, indented once, string in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 4, indented once, 2 forward slash, Add a G U I widget for input.
Line 5, indented once, 2File Dialog choose Input, left parenthesis,
double quotes, Choose the file to be processed, double quotes, right
parenthesis, semicolon.
Line 6, indented once, in File Name, equals choose Input dot display,
left parenthesis, right parenthesis, semicolon.
Line 7, indented once, text dot open, left parenthesis, in File Name
dot c underscore s t r, left parenthesis, 2 right parenthesis,
semicolon.
Line 8, right brace.
Back to Figure
Line 1, if stream in File, semicolon.
Line 2, Open File, left parenthesis, in File, right parenthesis,
semicolon.
Line 3, if, left parenthesis, exclamation in File, right parenthesis.
Line 4, left brace.
Line 5, indented twice, c out, 2 left angled brackets, double quotes,
Error opening File, double quotes, 2 left angled brackets, end l,
semicolon.
Line 6, indented twice, return 1, semicolon.
Line 7, right brace.
Back to Figure

The label is displayed at the top center. On the left is a heading
labeled Student List followed by a text box. The values in the text
box are as follows. 
Line 1: Bill Bly, left parenthesis, 0, right parenthesis. 
Line 2: Mary Moonlight, left parenthesis, 55, right parenthesis. 
Line 3: Anne Margaret, left parenthesis, 65, right parenthesis. 
Line 4: Claire Clear, left parenthesis, 67 point 5, right parenthesis. 
Line 5: Jim Jones, left parenthesis, 78, right parenthesis. Line 6:
Susy Sunshine, left parenthesis, 82, right parenthesis. 
Line 7: Alex Dale, left parenthesis, 99, right parenthesis. Line 8:
Chris Dale, left parenthesis, 99, right parenthesis. Line 9: Mary
Jones, left parenthesis, 100, right parenthesis. 
Line 10: Martha Jones, left parenthesis, 100, right parenthesis.
Below the Student List is a heading labeled Output followed by a
blank text box. 
On the top right, the list of contents are as follows. 
Line 1: Average, colon. 
Line 2: 74 point 5 5. 
Line 3: Max, colon. 
Line 4: 100. 
Line 5: Min, colon. 
Line 6: 0. The buttons at the bottom left, bottom middle, and bottom
right are labeled as Max Grade, Above Average Grades, and Below
Average Grades.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: void, while, end l, for.
Line 1, void Statistic List, 2 colon symbols, Students Max Grade, left
parenthesis, o string stream ampersand out String, right
parenthesis.
Line 2, left brace.
Line 3, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 4, indented once, Student a Student equals, list dot Get Next
Item, left parenthesis, right parenthesis, semicolon.
Line 5, indented once, out String, 2 left angled brackets, double
quotes, The following student, left parenthesis, s, right parenthesis,

has the maximum score, colon, double quotes, 2 left angled
brackets, end l, semicolon.
Line 6, indented once, while, left parenthesis, max Grade greater
than a Student dot Get Grade, left parenthesis, 2 right parenthesis.
Line 7, indented twice, a Student equals, list dot Get Next Item, left
parenthesis, right parenthesis, semicolon.
Line 8, indented once, out String, 2 left angled brackets, a Student
dot Get Name, left parenthesis, right parenthesis, 2 left angled
brackets, end l, semicolon.
Line 9, indented once, while, left parenthesis, list dot Has Next, left
parenthesis, 2 right parenthesis.
Line 10, indented twice, out String, 2 left angled brackets, list dot
Get Next Item, left parenthesis, right parenthesis, dot Get Name,
left parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 11, right brace.
Line 12, blank line.
Line 13, void Statistics List, 2 colon symbols, Students Above, left
parenthesis, o string stream ampersand out String, right
parenthesis.
Line 14, left brace.
Line 15, indented once, list dot Reset List, let parenthesis, right
parenthesis, semicolon.
Line 16, indented once, for, left parenthesis, int count equals 1,
semicolon, count less than or equal to num Below, semicolon, count
plus plus, right parenthesis.
Line 17, indented twice, list dot Get Next Item, left parenthesis, right
parenthesis, semicolon.
Line 18, indented once, out String, 2 left angled brackets, double
quotes, Students who scored above the average, colon, double
quotes, 2 left angled brackets, end l, semicolon.
Line 19, indented once, for, left parenthesis, int count equals num
Below plus 1, semicolon, count less than list dot Get length left
parenthesis, right parenthesis, plus 1, semicolon, count plus plus,
right parenthesis.
Line 20, indented twice, out String, 2 left angled brackets, list dot
Get Next Item, left parenthesis, right parenthesis, dot, Get Name,
left parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.

Line 21, right brace.
Line 22, blank line.
Line 23, void Statistics List, 2 colon symbols, Students Below, left
parenthesis, o string stream ampersand out String, right
parenthesis.
Line 24, left brace.
Line 25, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 26, indented once, out String, 2 left angled brackets, double
quotes, Students who scored below the average, colon, double
quotes, 2 left angled brackets, end l, semicolon.
Line 27, indented once, for, left parenthesis, int count equals 1,
semicolon, count less than or equal to num Below, semicolon, count
plus plus, right parenthesis.
Line 28, indented twice, out String, 2 left angled brackets, list dot
Get Next Item, left parenthesis, right parenthesis, dot Get Name,
left parenthesis, right parenthesis, 2 left angled brackets, end l,
semicolon.
Line 29, right brace.
Back to Figure
Line 1, void Statistics List, 2 colon symbols, All Students, left
parenthesis, o string stream ampersand out string, right parenthesis.
Line 2, left brace.
Line 3, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 4, indented once, while, left parenthesis, list dot Has Next, left
parenthesis, 2 right parenthesis.
Line 5, indented once, left brace.
Line 6, indented twice, Student student equals list dot Get Next
Item, left parenthesis, right parenthesis, semicolon.
Line 7, indented twice, out String, 2 left angled brackets, student dot
Get Name, left parenthesis right parenthesis, 2 left angled brackets,
double quotes, left parenthesis, double quotes, 2 left angled
brackets, student dot Get Grade, left parenthesis, right parenthesis,
2 left angled brackets, double quotes, right parenthesis, double
quotes, 2 left angled brackets, end l, semicolon.

Line 8, indented once, right brace.
Line 9, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: include, using namespace,
void, int, main, if, c out, return, string.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, DRIVER for class Statistics List of Student
objects.
Line 3, 2 forward slash followed by asterisks till the end of the line.
Line 4, hashtag include, left angled bracket, Q Application, right
angled bracket.
Line 5, hashtag include, left angled bracket, f stream, right angled
bracket.
Line 6, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 7, hashtag include, left angled bracket, string, right angled
bracket.
Line 8, hashtag include, double quotes, Exam Statistics Window dot
h, double quotes.
Line 9, hashtag include, double quotes, Statistics List dot h, double
quotes.
Line 10, hashtag include, double quotes, dialog dot h, double
quotes.
Line 11, blank line.
Line 12, blank line.
Line 13, using namespace s t d, semicolon.
Line 14, void Open File, left parenthesis, if stream ampersand in
File, right parenthesis, semicolon.
Line 15, 2 forward slash, Post, colon, Files have been opened
Line 16, blank line.
Line 17, int main, left parenthesis, int arg c comma, char asterisk
arg v, left square bracket, right square bracket, right parenthesis.
Line 18, left brace.
Line 19, indented once, Q Application app, left parenthesis, arg c
comma, arg c, right parenthesis, semicolon.
Line 20, blank line.

Line 21, indented once, if stream in File, semicolon.
Line 22, indented once, Open File, left parenthesis, in File, right
parenthesis, semicolon.
Line 23, indented once, if, left parenthesis, in File, right parenthesis.
Line 24, indented once, left brace.
Line 25, indented twice, c out, 2 left angled brackets, double quotes,
Error opening file, double quotes, 2 left angled brackets, end l,
semicolon.
Line 26, indented twice, return 1, semicolon.
Line 27, indented once, right brace.
Line 28, blank line.
Line 29, indented once, Statistics List grades, left parenthesis, in
File, right parenthesis, semicolon.
Line 30, indented once, Exam Statistics Window stat Window, left
parenthesis, grades, right parenthesis, semicolon.
Line 31, indented once, stat Window dot show, left parenthesis, right
parenthesis, semicolon.
Line 32, indented once, app dot exit, left parenthesis, right
parenthesis, semicolon.
Line 33, indented once, return 0, semicolon.
Line 34, right brace.
Line 35, blank line.
Line 36, 2 forward slash followed by asterisks till the end of the line.
Line 37, blank line.
Line 38, void Open File, left parenthesis, if stream ampersand text,
right parenthesis.
Line 39, left brace.
Line 40, indented once, string in File Name, semicolon, 2 forward
slash, User hyphen specified input file name.
Line 41, indented once, 2 forward slash, Add a G U I widget for
input.
Line 42, indented once, File Dialog choose Input, left parenthesis,
double quotes, Choose the file to be processed, double quotes, right
parenthesis, semicolon.
Line 43, indented once, in File Name, equals choose Input dot
display, left parenthesis, right parenthesis, semicolon.
Line 44, indented once, text dot open, left parenthesis, in File Name
dot c underscore s t r, left parenthesis, 2 right parenthesis,

semicolon.
Line 45, right brace.
Back to Figure
The label is displayed at the top center. On the left is a heading
labeled Student List followed by a text box. The values in the text
box are as follows. Line 1: Bill Bly, left parenthesis, 0, right
parenthesis. Line 2: Mary Moonlight, left parenthesis, 55, right
parenthesis. Line 3: Anne Margaret, left parenthesis, 65, right
parenthesis. Line 4: Claire Clear, left parenthesis, 67 point 5, right
parenthesis. Line 5: Jim Jones, left parenthesis, 78, right
parenthesis. Line 6: Susy Sunshine, left parenthesis, 82, right
parenthesis. Line 7: Alex Dale, left parenthesis, 99, right
parenthesis. Line 8: Chris Dale, left parenthesis, 99, right
parenthesis. Line 9: Mary Jones, left parenthesis, 100, right
parenthesis. Line 10 : Martha Jones, left parenthesis, 100, right
parenthesis. Below the Student List is a heading labeled Output
followed by a text box. The values in the text box are as follows.
Line 1: Students who scored above the average, colon. Line 2: Jim
Jones. Line 3: Susy Sunshine. Line 4: Alex Dale. Line 5: Chris Dale.
Line 6: Mary Jones. Line 7: Martha Jones. The list of contents on
the top right are as follows. Line 1: Average, colon. Line 2: 74 point
5 5. Line 3: Max, colon. Line 4: 100. Line 5: Min, colon. Line 6: 0.
The buttons at the bottom left, bottom middle, and bottom right are
labeled as Max Grade, Above Average Grades, and Below Average
Grades.
Back to Figure
Line 1: Hash i f n def, NAME. 
Line 2: Hash define, NAME. 
Line 3: Dot dot dot. 
Line 4: Hash e n d i f.
Back to Figure
Line 1, data, left square bracket, value 2, right square bracket,
equals temp, semicolon.

Line 2, data, left square bracket, value 1, right square bracket,
equals data, left square bracket, value 2, right square bracket,
semicolon.
Line 3, temp equals, data, left square bracket, value 1, right square
bracket, semicolon.
Back to Figure
Line 1: List, in Vals, semicolon. 
Line 2: for, left parenthesis, int, count, equals, 1, semicolon, count,
left angled bracket, equals, 150, semicolon, count, plus, plus, right
parenthesis.
Back to Figure
Line 1: left brace. 
Line 2: c in 2 left angled brackets, in Val, semicolon. 
Line 3: in Vals, dot, Insert, left parenthesis, in Val, right parenthesis,
semicolon. 
Line 4: right brace.
Back to Figure
Line 1: new, Data Type. 
Line 2: new, Data Type, left square bracket, Int Expression, right
square bracket. Both the lines are enclosed with a left brace on the
left side.
Back to Figure
Line 1: int asterisk, int P t r, semicolon.
Line 2: int asterisk, int Array, semicolon.
Line 3: int P t r, equals, new, int, semicolon. Creates a variable of
type int and stores its address into int P t r.
Line 4: int Array, equals, new, int, left square bracket, 6, right square
bracket, semicolon. Creates six element int Array and stores its
base address into int Array.
Back to Figure

Line 1: int asterisk, int P tr, semicolon. 2 forward slashes. Defines an
int pointer variable. 
Line 2: int P t r, equals, new int, semicolon. 2 forward slashes.
Creates a new int variable and stores its.
Line 3; indented 12 times. 2 forward slashes. Address in int P t r. 
Line 4: Patient R e c asterisk, patient P t r, equals, new, Patient R e
c, semicolon. 2 forward slashes. Defines a Patient R e c.
Line 5; indented 12 times: 2 forward slashes. Pointer variable,
creates a new variable.
Line 6; indented 12 times: 2 forward slashes. Of type Patient R e c,
and stores its address in. 
Line 7; indented 12 times: The Patient R e c pointer variable.
Line 8: Patient R e c asterisk, patient Array, equals, new, Patient R e
c, left square bracket, 4, right square bracket, semicolon.
Line 9; indented 12 times: 2 forward slashes. Defines an array of 4
variable of type. 
Line 10; indented 12 times: 2 forward slashes. Patient R e c and
stores the base address into.
Line 11; indented 12 times: 2 forward slashes. patient Array.
Line 12: Asterisk int P t r, equals, 250, semicolon. 2 forward slashes.
Stores 250 into variable whose address.
Line 13; indented 18 times: Is in int P t r.
Line 14: patient P t r, minus, right angled bracket, i d N u m, equals,
3245, semicolon. 2 forward slashes. Sets i d N u m field of the
Patient R e c struct.
Line 15; indented 18 times: 2 forward slashes. Whose address is in
patient P t r to 3245.
Line 16: patient P t r, minus, right angled bracket, height, equals, 64,
semicolon. 2 forward slashes. Sets height field to 64.
Line 17: patient P t r, minus, right angled bracket, weight, equals,
114, semicolon. 2 forward slashes. Sets weight field to 114. 
Line 18: patient Array, left square bracket, 3, right square bracket,
equals, asterisk patient P t r, semicolon. 2 forward slashes. Stores
what patient P t r points.
Line 19; indented 18 times: to in patient Array, left square bracket, 3,
right square bracket.
Line 20: patient Array, left square bracket, 3, right square bracket,
dot, weight, equals, 120, semicolon. 2 forward slashes. Changes
weight field of.

Line 21; indented 18 times. 2 forward slashes. patient Array, left
square bracket, 3, right square bracket, to 20.
Back to Figure
6 stacks of rectangles are arranged 3 in each column. Row 1,
column 1: A stack of 1 rectangle is labeled int P t r. Row 1, column
2: A stack of 1 rectangle with a value 250 is labeled asterisk, int P t
r. An arrow from int P t r points to the value 250 in asterisk, int P t r.
Row 2, column 1: A stack of 1 rectangle is labeled patient P t r. Row
2, column 2: A stack of 3 rectangles are labeled asterisk, patient P t
r. The values in the stack from top are as follows: 3245, 64, and 114.
An arrow from patient P t r points to the value 3245 in asterisk,
patient P t r. Row 3, column 1. A stack of rectangles is labeled as
patient Array. Each rectangle has the following entries made to its
left hand side, from top to bottom: left square bracket, 0, right
square bracket; left square bracket, 1, right square bracket; left
square bracket, 2, right square bracket; left square bracket, 3, right
square bracket. Three vertical dots are arranged after the array
component, left square bracket, 3, right square bracket. Row 3,
column 2: A stack of 3 rectangles are labeled asterisk, patient Array,
left square bracket, 3, right square bracket. The values in the stack
from top are as follows: 3245, 64, and 120. An arrow from the array
component, left square bracket, 3, right square bracket in the
patient Array points to 3245 in asterisk Array, left square bracket, 3,
right square bracket.
Back to Figure
Line 1: delete, Pointer. Line 2: delete, left square bracket, right
square bracket, Pointer. Both the lines are enclosed with a left brace
on the left side.
Back to Figure
Line 1: delete, int P t r, semicolon. Returns the int variable pointed to
by int P t r to the free store.
Line 2: delete, patient P t r, semicolon. Returns the struct variable
pointed to by patient P t r to the free store. 

Line 3: delete, left square bracket, right square bracket, patient
Array. Returns the array pointed to by patient Array to the free store.
Back to Figure
Line 1: int asterisk, p t r 1, equals, new, int, semicolon. 2 forward
slashes. Create a dynamic variable.
Line 2: int asterisk, p t r 2, equals, new, int, semicolon. 2 forward
slashes. Create a dynamic variable.
Line 3: A Blank line.
Line 4: Asterisk p t r 2, equals, 44, semicolon. 2 forward slashes.
Assign a value to a dynamic variable.
Line 5: asterisk p t r 1, equals, asterisk p t r 2, semicolon. 2 forward
slashes. Copy one dynamic variable to another. 
Line 6: p t r 1, equals, p t r 2, semicolon. 2 forward slashes. Copy
one pointer to another. 
Line 7: delete p t r 2, semicolon. 2 forward slashes. Destroy a
dynamic variable.
Back to Figure
Line 1: int asterisk, p t r 1, equals, new, int, semicolon. 
Line 2: int asterisk, p t r 2, equals, new, int, semicolon. Create a pair
of dynamic variables of type int and stores their locations into p t r 1
and p t r 2. The values of the dynamic variables are undefined even
though the pointer variables now have values. Left parenthesis,
Refer Figure 14 point 2 A, right parenthesis.
Line 3: Asterisk p t r 2, equals, 44, semicolon. Stores the value 44
into the dynamic variable pointed to by p t r 2. Left parenthesis,
Refer Figure 14 point 2 B, right parenthesis. 
Line 4: asterisk p t r 1, equals, asterisk p t r 2, semicolon. Copies
the contents of the dynamic variable asterisk p t r 2 to the dynamic
Variable asterisk p t r 1. Left parenthesis, Refer Figure 14 point 2 C,
right parenthesis.
Line 5: p t r 1, equals, p t r 2, semicolon. Copies the contents of the
pointer variable p t r 2 to the pointer variable p t r 1. Left
parenthesis, Refer Figure 14 point 2 D, right parenthesis. 
Line 6: delete p t r 2, semicolon. Returns the dynamic variable
asterisk p t r 2 back to the free store to be used again. The value of

p t r 2 is undefined. Left parenthesis, Refer Figure 14 point 2 E, right
parenthesis.
Back to Figure
2 rectangles labeled p t r 1, and p t r 2 are placed one below the
other. Both the rectangles hold the values, question mark. Initial
conditions. 2 expressions on the left side are as follows. Line 1. int
asterisk, p t r 1, equals, new, int, semicolon. Line 2. int asterisk, p t r
2, equals, new, int, semicolon. The diagram below the expressions
are as follows. The value in the rectangle labeled p t r 1 points to a
rectangle labeled, asterisk p t r 1. The value of asterisk p t r 1 is
question mark. The value in the rectangle labeled p t r 2 points to a
rectangle labeled, asterisk p t r 2. An expression on the right side.
asterisk p t r 2, equals, 44, semicolon. The diagram below the
expression is as follows. The value of asterisk p t r 2 is question
mark. The value in the rectangle labeled p t r 1 points to a rectangle
labeled, asterisk p t r 1. The value of asterisk p t r 1 is question
mark. The value in the rectangle labeled p t r 2 points to a rectangle
labeled, asterisk p t r 2. The value of asterisk p t r 2 is 44.
Back to Figure
Line 1: Hash include, left angled bracket, c s t d def, right angled
bracket. 2 forward slashes. For NULL.
Line 2: Dot.
Line 3: Dot.
Line 4: Dot.
Line 5: int asterisk, p t r 1, equals, new, int, semicolon.
Line 6: int asterisk, p t r 2, equals, new, int, semicolon.
Back to Figure
An expression on the left side. asterisk p t r 1, equals, asterisk p t r
2, semicolon. The diagram below the expression is as follows. The
value in the rectangle labeled p t r 1 points to a rectangle labeled,
asterisk p t r 1. The value of asterisk p t r 1 is 44. The value in the
rectangle labeled p t r 2 points to a rectangle labeled, asterisk p t r
2. The value of asterisk p t r 2 is 44. An expression on the right side.

p t r 1, equals, p t r 2, semicolon. The diagram below the expression
is as follows. A rectangle labeled p t r 1. To the right of p t r 1, is a
rectangle with a value 44. Below p t r 1 is the rectangle labeled, p t r
2 and below the rectangle with value 44 is a rectangle labeled,
asterisk p t r 1, asterisk p t r 2 which holds a value 44. The value in
p t r 1 points to asterisk p t r 1, asterisk p t r 2. The value in p t r 2
points to asterisk p t r 1, asterisk p t r 2. An expression is followed
by the diagram. delete p t r 2, semicolon. The diagram below the
expression is as follows. A rectangle labeled p t r 1. To the right of p
t r 1, is a rectangle with a value 44. Below p t r 1 is the rectangle
labeled, p t r 2 with a value question mark. p t r 1 points to nothing.
Back to Figure
Line 1: Asterisk p t r 2, equals, 44, semicolon. 2 forward slashes.
Give asterisk p t r 2 the value 44.
Line 2: Asterisk p t r 1, equals, asterisk p t r 2, semicolon. 2 forward
slashes. Copy 44 from asterisk p tr 2 into asterisk p t r 1.
Line 3: delete p t r 1, semicolon. 2 forward slashes. Delete copy of
44, and avoid an inaccessible object.
Line 4: p t r 1, equals, p t r 2, semicolon. 2 forward slashes. p t r 1
points to same value of 44 as p t r 2.
Line 5: delete p t r 2, semicolon. 2 forward slashes. The shared
value 44 is deleted.
Line 6: p t r 1, equals, NULL, semicolon. 2 forward slashes. Avoid a
dangling pointer.
Back to Figure
The diagram is divided into two columns. Column 1. 2 rectangles
placed one below the other is labeled, p t r 1, and p t r 2 with values
of question mark in each. Initial Conditions. 2 expressions. Line 1: int
asterisk, p t r 1, equals, new, int, semicolon. Line 2: int asterisk, p t r
2, equals, new, int, semicolon. 4 rectangles labeled, p t r 1, asterisk
p t r 1, p t r 2, and asterisk p t r 2 are placed 2 in a row respectively.
Asterisk p t r 1 and asterisk p t r 2 holds the value question mark. 2
arrows from p t r 1, and p t r 2 points to asterisk p t r 1, and asterisk
p t r 2 respectively. An expression. asterisk p t r 2, equals, 44,
semicolon. 4 rectangles labeled, p t r 1, asterisk p t r 1, p t r 2, and

asterisk p t r 2 are placed 2 in a row respectively. Asterisk p t r 1 and
asterisk p t r 2 holds the value question mark, and 44 respectively. 2
arrows from p t r 1, and p t r 2 points to asterisk p t r 1, and asterisk
p t r 2 respectively. An expression. Asterisk p t r 1, equals, asterisk p
t r 2, semicolon. 4 rectangles labeled, p t r 1, asterisk p t r 1, p t r 2,
and asterisk p t r 2 are placed 2 in a row respectively. Asterisk p t r 1
and asterisk p t r 2 holds the value 44. 2 arrows from p t r 1, and p t
r 2 points to asterisk p t r 1, and asterisk p t r 2 respectively. Column
2. An expression. Delete, p t r 1, semicolon. 3 rectangles are labeled
p t r 1, p t r 2, and asterisk p t r 2. Rectangle p t r 1 is placed in row
1, and p t r 2, and asterisk p t r 2 are placed in row 2. The value of p
t r 1, and asterisk p t r 2 is question mark, and 44 respectively. An
arrow points from p t r 2 to asterisk p t r 2. An expression p t r 1,
equals, p t r 2, semicolon. 3 rectangles are labeled p t r 1, p t r 2,
and asterisk p t r 2. Asterisk p t r 2 is also labeled as asterisk p t r 1.
The position of the rectangles remains the same as above. The
value of asterisk p t r 2 also labeled as asterisk p t r 1 is 44. 2
arrows from p t r 1, and p t r 2 points to asterisk p t r 1 also labeled
as asterisk p t r 2. An expression. Delete, p t r 2, semicolon. 2
rectangles placed one below the other is labeled as, p t r 1, and p t r
2 respectively. The value of p t r 2 is question mark. The rectangle p
t r 1 points to nothing. An expression. p t r 1, equals, NULL,
semicolon. 2 rectangles placed one below the other is labeled as, p t
r 1, and p t r 2 respectively. The values of p t r 1, and p t r 2 are
slash and a question mark respectively.
Back to Figure
Array before inserting the value 25. A group of rectangles stacked
vertically up. Each rectangle has the following entries made to its left
hand side, from top to bottom: data, left square bracket, 0, right
square bracket; data, left square bracket, 1, right square bracket;
data, left square bracket, 2, right square bracket; data, left square
bracket, 3, right square bracket; data, left square bracket, 4, right
square bracket; three dots arranged vertically. The values in each
rectangle, from top to bottom, are as follows: 4, 16, 39, 46, 58, and
blank. Array after inserting the value 25. A group of rectangles
stacked vertically up. Each rectangle has the following entries made
to its left hand side, from top to bottom: data, left square bracket, 0,

right square bracket; data, left square bracket, 1, right square
bracket; data, left square bracket, 2, right square bracket; data, left
square bracket, 3, right square bracket; data, left square bracket, 4,
right square bracket; left square bracket, 5, right square bracket;
three dots arranged vertically. The values in each rectangle, from
top to bottom, are as follows: 4, 16, 25, 39, 46, 58, and blank.
Back to Figure
The first rectangle which is divided into 2 parts is placed in the top
right corner. It holds the value 58 and a slash. 3 rectangles are
placed in a row below the first rectangle. The first rectangle in row 2
is labeled as head. The second and third rectangle in row 2 is
divided into 2 parts. The values of second and third rectangle are as
follows: 4, blank, and 46, blank. Another 2 rectangles which are
divided into 2 parts are placed slightly in bottom center. The values
of 2 rectangles are as follows: 16, blank, and 39, blank. An arrow
from head points to value 4. The blank part with 4 points to 16. The
blank part with 16 points to 39. The blank part with 39 points to 46.
The blank part with 46 points to 58.
Back to Figure
Row entries are as follows. Row 1: Component, left parenthesis,
Data, right parenthesis; Link, left parenthesis, Location of next node,
right parenthesis.
Back to Figure
Line 1: typedef, float, Item Type, semicolon.
Line 2: struct, Node Type.
Line 3: Left brace.
Line 4; indented once: Item Type, component, semicolon.
Line 5; indented once: Node Type asterisk, link, semicolon.
Line 6: Right brace, semicolon.
Line 7: typedef, Node Type asterisk, Node P t r, semicolon.
Line 8: Node P t r, head, semicolon. 2 forward slashes. External
pointer to list.
Line 9: Node P t r, c u r r P t r, semicolon. 2 forward slashes. Pointer

to current node.
Line 10: Node P t r, new Node P t r, semicolon. 2 forward slashes.
Pointer to newest node.
Back to Figure
Line 1: typedef, float, Item Type, semicolon.
Line 2: struct, Node Type, semicolon. 2 forward slashes. Forward,
left parenthesis, incomplete, right parenthesis, declaration.
Line 3: typedef, Node Type asterisk, Node P t r, semicolon.
Line 4: A blank line.
Line 5: struct, Node Type. 2 forward slashes. Complete declaration.
Line 6: Left brace. 
Line 7; indented once: Item Type, component, semicolon.
Line 8; indented once: Node P t r, link, semicolon.
Line 9: Right brace, semicolon.
Back to Figure
Line 1: Hash include, left angled bracket, c s t d def, right angled
bracket. 2 forward slashes. For NULL.
Line 2: Dot.
Line 3: Dot.
Line 4: Dot.
Line 5: head, equals, new, Node Type, semicolon. 
Line 6: head, minus, right angled bracket, component, equals, 12
point 8, semicolon.
Line 7: new Node P t r, equals, new Node Type, semicolon.
Line 8: new Node P t r, minus, right angled bracket, component,
equals, 45 point 2, semicolon.
Line 9: head, minus, right angled bracket, link, equals, new Node P t
r, semicolon.
Line 10: c u r r P t r, equals, new Node P t r, semicolon.
Line 11: new Node P t r, equals, new, Node Type, semicolon.
Line 12: new Node P t r, minus, right angled bracket, component,
equals, 70 point 1, semicolon.
Line 13: c u r r P t r, minus, right angled bracket, link, equals, new
Node P t r, semicolon.
Line 14: new Node P t r, minus, right angled bracket, link, equals,

NULL, semicolon.
Line 15: c u r r P t r, equals, new Node P t r, semicolon.
Back to Figure
The rectangle, asterisk head is divided into two parts that holds the
values question marks in each part. An arrow points from head to
asterisk head. A code above the block reads, head, equals, new,
Node Type, semicolon.
Back to Figure
The rectangle, asterisk head is divided into two parts that holds the
values 12 point 8, and a question mark respectively. An arrow points
from head to asterisk head. A code above the block reads, head,
minus, right angled bracket, component, equals, 12 point 8,
semicolon.
Back to Figure
The rectangles, asterisk head and asterisk new Node P t r are each
divided into two parts. Values of asterisk head are 12 point 8 and
question mark respectively. Values of asterisk new Node P t r are
question mark in each part. An arrow points from head to asterisk
head. An arrow points from new Node P t r to asterisk new Node P t
r. A code above the block reads, new Node p t r, equals, new, Node
Type, semicolon.
Back to Figure
The rectangles, asterisk head and asterisk new Node P t r are each
divided into two parts. Values of asterisk head are 12 point 8 and
question mark respectively. Values of asterisk new Node P t r are 45
point 2, and a question mark respectively. An arrow points from
head to asterisk head. An arrow points from new Node P t r to
asterisk new Node P t r. A code above the block reads, new Node p
t r, minus, right angled bracket, component, equals, 45 point 2,
semicolon.
Back to Figure

The rectangles, asterisk head and asterisk new Node P t r which is
also labeled as asterisk, left parenthesis, head, minus, right angled
bracket, link, right parenthesis are each divided into two parts. The
values of asterisk head are 12 point 8 and blank respectively. The
values of asterisk new Node P t r are 45 point 2, and a question
mark respectively. An arrow points from head to asterisk head. An
arrow points from new Node P t r to asterisk new Node P t r. An
arrow points from blank part of asterisk head to asterisk new Node P
t r. A code above the block reads, head, minus, right angled bracket,
link, equals, new Node P t r, semicolon.
Back to Figure
The rectangles, asterisk head and asterisk new Node P t r also
labeled as asterisk, left parenthesis, head, minus, right angled
bracket, link, right parenthesis are each divided into two parts. The
values of asterisk head are 12 point 8 and blank respectively. The
values of asterisk new Node P t r are 45 point 2, and a question
mark respectively. An arrow points from head to asterisk head. An
arrow points from new Node P t r to asterisk new Node P t r. An
arrow points from blank part of asterisk head to asterisk new Node P
t r. An arrow points from c u r r P t r to asterisk new Node P t r. A
code above the block reads, c u r r P t r, equals, new Node P t r,
semicolon.
Back to Figure
The rectangle, asterisk new Node P t r is divided into two parts that
holds the values each with a question mark. An arrow points from
new Node P t r to asterisk new Node P t r. A code above the block
reads, new Node P t r, equals, new, Node Type, semicolon.
Back to Figure
The rectangle, asterisk new Node P t r is divided into two parts with
values 70 point 1, and a question mark respectively. A code above
the block reads, new Node P t r, minus, right angled bracket,
component, equals, 70 point 1, semicolon.

Back to Figure
The rectangles, asterisk head and asterisk new Node P t r, asterisk,
left parenthesis, head, minus, right angled bracket, link, right
parenthesis are each divided into two parts. The values of asterisk
head are 12 point 8 and blank respectively. The values of asterisk,
left parenthesis, head, minus, right angled bracket, link, right
parenthesis are 45 point 2, and blank respectively. The values of
asterisk new Node P t r are 70 point 1, and a question mark
respectively. An arrow points from head to asterisk head. An arrow
points from new Node P t r to asterisk new Node P t r. An arrow
points from blank part of asterisk head to asterisk, left parenthesis,
head, minus, right angled bracket, link, right parenthesis. An arrow
points from c u r r P t r to asterisk, left parenthesis, head, minus,
right angled bracket, link, right parenthesis. An arrow points from
blank part of asterisk, left parenthesis, head, minus, right angled
bracket, link, right parenthesis to asterisk new Node P t r. A code
above the block reads, c u r r P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon.
Back to Figure
3 rectangles are arranged in a row. Fourth rectangle is placed below
the second rectangle. The first rectangle is labeled head. The
second, third, and fourth rectangle are each divided into two parts.
The second rectangle holds the value 12 point 8, and a blank
respectively. The third rectangle holds the value 45 point 2, and a
blank respectively. The fourth rectangle holds the value 70 point 1,
and a slash respectively. An arrow points from head to second
rectangle. An arrow points from blank part of second rectangle to
third rectangle. An arrow points from blank part of third rectangle to
fourth rectangle. A code above the block reads, new Node P t r,
minus, right angled bracket, link, equals, NULL, semicolon. A code
below the block reads, c u r r P t r, equals, new Node P t r,
semicolon.
Back to Figure

Program code. The words in the variable names are merged. The
program contains the following keywords: struct, typedef, int, c in, c
out, end l, i o stream, include, using namespace.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. This program creates a linked list of four
values read.
Line 3: from the keyboard. The list is then output.
Line 4: 2 forward slashes followed by asterisk till the end of the line.
Line 5: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 6: using, namespace, s t d, semicolon.
Line 7: typedef, int, Item Type, semicolon.
Line 8: Blank Line.
Line 9: struct Node Type, semicolon. 2 forward slashes. Forward
declaration.
Line 10: typedef, Node Type asterisk, Node P t r, semicolon.
Line 11: Blank Line.
Line 12: struct, Node Type.
Line 13: left brace.
Line 14; indented once: Item Type, component, semicolon.
Line 15; indented once: Node P t r, link, semicolon.
Line 16: right brace, semicolon.
Line 17: Blank line.
Line 18: int, main, left parenthesis, right parenthesis.
Line 19: left brace.
Line 20: Node P t r, head, semicolon. 2 forward slashes. External
pointer to list.
Line 21: Node P t r, new Node P t r, semicolon. 2 forward slashes.
Pointer to newest node.
Line 22: Node P t r, c u r r P t r, semicolon. 2 forward slashes.
Pointer to last node.
Line 23: Blank line.
Line 24: c out, 2 left angled brackets, double quotes, Enter 4 integer
values dot, double quotes, 2 left angled brackets, end l, semicolon.
Line 25: head, equals, new Node Type, semicolon.
Line 26: c in, 2 right angled brackets, head, minus, right angled
bracket, component, semicolon.
Line 27: c u r r P t r, equals, head, semicolon. Lines from 25 to 27
are highlighted.

Back to Figure
Program code. The words in the variable names are merged. The
program contains the following keywords: for, int, return, end l, c in,
c out.
Line 1; indented once: for, left parenthesis, int, count, equals, 1,
semicolon, count, left angled bracket, equals, 3, semicolon, count,
plus, plus, right parenthesis.
Line 2; indented once: left brace.
Line 3; indented twice: new Node P t r, equals, new, Node Type,
semicolon. 2 forward slashes. Create new node.
Line 4; indented twice: c in, 2 right angled brackets, new Node P t r,
minus, right angled bracket, component, semicolon. 2 forward
slashes. Set its component value.
Line 5; indented twice: c u r r P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon. 2 forward slashes. Link node into
list.
Line 6; indented twice: c u r r P t r, equals, new Node P t r,
semicolon. 2 forward slashes. Set c u r r P t r to last node.
Line 7; indented once: right brace.
Line 8; indented once: c u r r P t r, minus, right angled bracket, link,
equals, NULL, semicolon. 2 forward slashes. Mark end of list. Lines
from 1 to 8 are highlighted.
Line 9; indented once: c u r r P t r, equals, head, semicolon.
Line 10; indented once: for, left parenthesis, int, count, equals, 0,
semicolon, count, left angled bracket, equals, 3, semicolon, count,
plus, plus, right parenthesis.
Line 11; indented once: left brace.
Line 12; indented twice: c out, 2 left angled brackets, c u r r P t r,
minus, right angled bracket, component, 2 left angled brackets, end
l, semicolon.
Line 13; indented twice: c u r r P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon.
Line 14; indented once: right brace.
Line 15; indented once: return 0, semicolon.
Line 16: Right brace.
Back to Figure

Line 1: Enter 4 integer values. 
Line 2: 32 78 99 21. 
Line 3: 32. 
Line 4: 78. 
Line 5: 99. 
Line 6: 21
Back to Figure
Line 1: head, equals, new, Node Type, semicolon. A variable of type
Node Type is created. The pointer is stored into head. Variable head
will remain unchanged as the external pointer to the list.
Line 2: c in, 2 right angled brackets, head, minus, right angled
bracket, component, semicolon. The first number is read into the
component member of the first node in the list.
Line 3: c u r r P t r, equals, head, semicolon. c u r r P t r now points
to the last node, left parenthesis, the only node, right parenthesis, in
the list.
Line 4: for, left parenthesis, dot, dot, dot, right parenthesis. A count
controlled loop is used to read three integer values.
Line 5: left brace. The loop begins.
Line 6; indented once: new Node P t r, equals, new Node Type,
semicolon. Another variable of type Node Type is created, with new
Node P t r pointing to it.
Line 7; indented once: c in, 2 right angled brackets, new Node P t r,
minus, right angled bracket, component, semicolon. The current
input value is stored into the component member of the newly
created node.
Line 8; indented once: c u r r P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon. The pointer to the new node is
stored into the link member of the last node in the list.
Back to Figure
Line 1: indented once: c u r r P t r, equals, new Node P t r,
semicolon. c u r r P t r is again pointing to the last node in the list.
Line 2: right brace. The loop body repeats.
Line 3: c u r r P t r, minus, right angled bracket, link, equals, NULL,

semicolon. The link member of the last node is assigned the special
end-of-list value NULL.
Back to Figure
5 rectangles are arranged in a row. 2 other rectangles are arranged
in row 2 below the fourth rectangle. The first rectangle is labeled
head. The 2 rectangles in row 2 are labeled as new Node P t r, and c
u r r P t r respectively. The second, third, fourth, and fifth rectangle
are each divided into two parts. The values from second to fifth
rectangle are as follows: 32, blank, 78, blank, 99, blank, and 21,
slash. An arrow points from head to second rectangle. An arrow
points from blank part of second rectangle to third rectangle. An
arrow points from blank part of third rectangle to fourth rectangle.
An arrow points from blank part of fourth rectangle to fifth rectangle.
2 arrows from new Node P t r, and c u r r P t r points to fifth
rectangle.
Back to Figure
Line 1: List, left parenthesis, right parenthesis, semicolon.
Line 2: 2 forward slashes. Constructor.
Line 3: 2 forward slashes. Post, colon, Empty list has been created.
Back to Figure
Line 1: 2 forward slashes. Action responsibilities.
Line 2: void, Insert, left parenthesis, Item Type, item, right
parenthesis, semicolon.
Line 3: 2 forward slashes. Pre, colon, List is not full and item is not
in the list.
Line 4: 2 forward slashes. Post, colon, item is in the list and length
has been incremented.
Line 5: void, delete, left parenthesis, Item Type, item, right
parenthesis, semicolon.
Line 6: 2 forward slashes. Post, colon, item is not in the list.
Line 7: void, Reset List, left parenthesis, right parenthesis,
semicolon.
Line 8: 2 forward slashes. Post, colon, The current position is reset

to the first item in the list.
Line 9: Item Type, Get Next Item, left parenthesis, right parenthesis,
semicolon.
Line 10: 2 forward slashes. Assumptions, colon, No transformers
are called during the iteration.
Line 11: 2 forward slashes. There is an item to be returned,
semicolon, that is, Has Next is true when.
Line 12: 2 forward slashes. This method is invoked.
Line 13: 2 forward slashes. Pre, colon, Reset List has been called if
this is not the first iteration.
Line 14: 2 forward slashes. Post, colon, Returns item at the current
position.
Line 15: Blank line.
Line 16: 2 forward slashes. Knowledge responsibilities.
Line 17: int, Get Length, left parenthesis, right parenthesis, const,
semicolon.
Line 18: 2 forward slashes. Post, colon, Returns the length of the
list.
Line 19: bool, Is Empty, left parenthesis, right parenthesis, const,
semicolon.
Line 20: 2 forward slashes. Post, colon, Returns true if list is empty,
semicolon, false otherwise.
Line 21: bool, Is Full, left parenthesis, right parenthesis, const,
semicolon.
Line 22: 2 forward slashes. Post, colon, Returns true if list is full,
semicolon, false otherwise.
Line 23: bool, Is There, left parenthesis, Item Type, item, right
parenthesis, const, semicolon.
Line 24: 2 forward slashes. Post, colon, Returns true if item is in the
list, semicolon, false otherwise.
Line 25: 2 forward slashes. bool, Has Next, left parenthesis, right
parenthesis, const, semicolon.
Line 26: 2 forward slashes. Post, colon, Returns true if there is
another item to be returned, semicolon, false.
Line 27: 2 forward slashes. Otherwise.
Back to Figure

Line 1: class, List.
Line 2: left brace.
Line 3: public, colon.
Line 4: dot, dot, dot.
Line 5: private, colon,
Line 6; indented once: Node Type asterisk, data P t r, semicolon. 2
forward slashes. External pointer to the first node in the list.
Line 7; indented once: int, length, semicolon.
Line 8; indented once: Node Type asterisk, current P o s, semicolon.
2 forward slashes. Pointer to current position in a traversal.
Line 9: right brace.
Back to Figure
Line 1: List, colon, colon, List, left parenthesis, right parenthesis.
Line 2: 2 forward slashes. Post, colon, data P t r, equals, equals,
NULL.
Line 3: left brace.
Line 4; indented once: data P t r, equals, NULL, semicolon.
Line 5; indented once: current P o s, equals, data P t r, semicolon.
Line 6: length, equals, 0, semicolon.
Line 7: right brace.
Back to Figure
4 rectangles are arranged in a row. The first rectangle is labeled as
data p t r. The other 3 rectangles in row 1 are divided into two parts.
The fifth rectangle labeled last p t r, is placed in row 2 between the
third and the fourth rectangles. An arrow points from data p t r to
second rectangle. An arrow from the second part of second
rectangle points to the third rectangle. An arrow from the second
part of third rectangle points to the fourth rectangle which is
detached by 3 dots. An arrow from last p t r points to the fourth
rectangle.
Back to Figure
Title: Insert, left parenthesis, In, colon, item, right parenthesis.
Line 1: Set new Node P t r to new Node Type.

Line 2: Set new Node P t r, hyphen, right angled bracket, component
to item. 
Line 3: Set new Node P t r, hyphen, right angled bracket, link to
NULL. 
Line 4: Set last P t r, hyphen, right angled bracket, link to new Node
P t r.
Line 5: Set last P t r to new Node P t r.
Back to Figure
Title: Insert, left parenthesis, In, colon, item, right parenthesis,
Revised. 
Line 1: Set new Node P t r to new Node Type.
Line 2: Set new Node P t r, hyphen, right angled bracket, component
to item.
Line 3: Set new Node P t r, hyphen, right angled bracket, link to
NULL.
Line 4: blank.
Line 5: IF last P t r is NULL.
Line 6: indented once: Set data P t r to new Node P t r.
Line 7: ELSE.
Line 8: indented once: Set last P t r, hyphen, right angled bracket,
link to new Node P t r.
Line 9: indented once: Set last P t r to new Node P t r.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: void, if, else.
Line 1: void List, colon, colon, Insert, left parenthesis, Item Type
item, right parenthesis.
Line 2: 2 forward slashes, Post: New node containing item is at the
end of the linked list.
Line 3: 2 forward slashes, and last P t r points to the new node. 
Line 4: left brace.
Line 5: indented once: Node P t r new Node P t r, equals sign, new
Node Type, semicolon, 2 forward slashes, Get a new empty node.
Line 6: indented once: new Node P t r, hyphen, right angled bracket,
component, equals sign, item, semicolon, 2 forward slashes, Give

the node a component value.
Line 7: indented once: new Node P t r, hyphen, right angled bracket,
link, equals sign, NULL, semicolon, 2 forward slashes, Set its link to
NULL.
Line 8: indented once: if, left parenthesis, last P t r, 2 equals sign,
NULL, right parenthesis, 2 forward slashes, If the list was empty.
Line 9: indented twice: data P t r, equals signs, new Node P t r,
semicolon, 2 forward slashes, Point external pointer to node.
Line 10: indented once: else, 2 forward slashes, 2 forward slashes,
Otherwise.
Line 11: indented twice: last P t r, hyphen, right angled bracket, link,
equals sign, new Node P t r, semicolon, 2 forward slashes, Point last
node to new node. 
Line 12: indented once: last P t r, equals sign, new Node P t r,
semicolon, 2 forward slashes, New node becomes last node. 
Line 13: indented once: length, plus, plus, semicolon. 2 forward
slashes, Increment length.
Line 14: right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: for, int, c
out, end l. 
Line 1: c u r r P t r, equals sign, head, semicolon.
Line 2: for, left parenthesis, int count, equals sign, 0, semicolon,
count, left angled bracket, equals sign, 3, semicolon, count, plus,
plus, right parenthesis. 
Line 3: left brace. 
Line 4: indented once: c out, 2 left angled brackets, c u r r P t r,
hyphen, right angled bracket, component, 2 left angled brackets,
end l, semicolon. 
Line 5: indented once: c u r r P t r, equals sign, c u r r P t r, hyphen,
right angled bracket, link, semicolon. 
Line 6: right brace.
Back to Figure

Title: Delete, left parenthesis, In, colon, item, right parenthesis.
Line 1: blank.
Line 2: Set c u r r P t r to data P t r.
Line 3: WHILE c u r r P t r, exclamation mark, equals sign, NULL
AND c u r r P t r, hyphen, right angled bracket, component,
exclamation mark, equals sign, item .
Line 4: indented once: Set c u r r P t r to c u r r P t r, hyphen, right
angled bracket, link.
Line 5: IF c u r r P t r, exclamation mark, equals sign, NULL. 
Line 6: indented once: Delete c u r r P t r.
Back to Figure
The 3 enclosed rectangles are connected by arrow marks. An arrow
from the first rectangle points to the second rectangle, and another
arrow from the second rectangle points to the third rectangle. An
arrow from the first rectangle, labeled c u r r p t r, connects the first
and third rectangles.
Back to Figure
Title: Delete, left parenthesis, In colon, item, right parenthesis,
Revised
Line 1: Set curr P t r to data P t r.
Line 2: Set prev P t r to, null in uppercase.
Line 3: While in uppercase, curr P t r, exclamation mark, equals, null
and in uppercase, curr P t r, minus, right angled bracket,
component, exclamation mark, equals, item.
Line 4: indented once, Set prev P t r to curr P t r.
Line 5: indented once, Set curr P t r, to, curr P t r, minus, right
angled bracket, link.
Line 6: if in uppercase, curr P t r, exclamation mark, equals, null in
uppercase.
Line 7: indented once, Set prev P t r, minus, right angled bracket,
link to curr P t r, minus, right angled bracket, link.
Line 8: indented once, Delete curr P t r.
Back to Figure

Line 1: dot dot dot.
Line 2: if in uppercase, curr P t r, exclamation mark, equals, null in
uppercase, 2 forward slashes, item is found.
Line 3: indented once, if in uppercase, curr P t r, equals, equals,
data P t r, 2 forward slashes, item is in first node.
Line 4: indented twice, Set data P t r, to, curr P t r, minus, right
angled bracket, link, 2 forward slashes, delete first node.
Line 5: indented once, else in uppercase.
Line 6: indented twice, Set prev P t r, minus, right angled bracket,
link, to curr P t r, minus, right angled bracket, link, 2 forward slashes,
delete item.
Line 7: indented once, if in uppercase, curr P t r, equals, equals, last
P t r, 2 forward slashes, item is in last node.
Line 8: indented twice, Set last P t r, to, prev P t r, 2 forward
slashes, adjust last P t r.
Line 9: indented once, Delete curr P t r, 2 forward slashes,
deallocate curr P t r.
Back to Figure
The words in the pointers are merged. The code contains the
following keywords: while, if, and else.
Line 1: void List, colon, colon, Delete, left parenthesis, Item Type
item, right parenthesis.
Line 2: left brace.
Line 3: indented once, Node P t r, prev P t r, equals, null in
uppercase, semicolon, 2 forward slashes, Trailing pointer.
Line 4: indented once, Node P t r, curr P t r, equals, data P t r,
semicolon, 2 forward slashes, Loop control pointer.
Line 5: indented once, while, left parenthesis, curr P t r, exclamation
mark, equals, null in uppercase, 2 ampersands, minus, right angled
bracket, component, exclamation mark, equals, item, right
parenthesis.
Line 6: indented once, left brace, 2 forward slashes, item is found.
Line 7: indented twice, if, left parenthesis, curr P t r, equals, equals,
data P t r, right parenthesis.
Line 8: indented thrice, data P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon, 2 forward slashes, item is in first
node.

Line 9: indented twice, else.
Line 10: indented thrice, prev P t r, minus, right angled bracket, link,
equals, curr P t r, minus, right angled bracket, link, semicolon.
Line 11: indented twice, if, left parenthesis, curr P t r, equals, equals,
last P t r, right parenthesis.
Line 12: indented 4 times, last P t r, equals, prev P t r, semicolon, 2
forward slashes, item is in last node.
Line 13: indented twice, delete curr P t r, semicolon.
Line 14: indented twice, length, minus minus, semicolon.
Line 15: indented once, right brace.
Line 16: right brace.
Back to Figure
4 rectangles are placed in a row. The first rectangle is labeled, data
P t r. The other 3 rectangles in this row are divided into 2 parts. The
values of second, third and fourth rectangle are as follows: 10,
blank, 20, blank, and 30, blank. Another 3 rectangles labeled, c u r r
P t r, item, and last P t r are placed in next row. The rectangles c u r
r P t r, and item are placed in middle left. The last P t r rectangle is
placed in middle right. The value of item is 20. A rectangle labeled p
r e v P t r is placed in next row in bottom left with a value slash. An
arrow points from data P t r to 10. An arrow from the blank part with
10 points to 20. An arrow from the blank part with 20 points to 30
which is detached by 3 dots. An arrow from c u r r P t r points to the
arrow of data P t r. An arrow from last P t r points to 30. 
Back to Figure
Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase.
Line 2: indented once, 2 ampersands, curr P t r, minus, right angled
bracket, component, exclamation mark, equals, item, right
parenthesis.
Explanation: curr P t r is not, null in uppercase, and 10 is not equal
to 20, so the loop body is entered.
Line 3: prev P t r, equals, curr P t r, semicolon.
Explanation: The trailing pointer points to the first code.
Line 4: curr P t r, equals, curr P t r, minus, right angled bracket, link,

semicolon.
Explanation: The current pointer points to the second node.
Line 5: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase.
Line 6: 2 ampersands, curr P t r, minus, right angled bracket,
component, exclamation mark, equals, item, right parenthesis.
Explanation: curr P t r is not, null in uppercase, but 20 equals 20, so
the loop is exited.
Line 7: if, left parenthesis, curr P t r, exclamation mark, equals, null
in uppercase, right parenthesis.
Explanation: curr P t r is not, null in uppercase, so the item is found.
Line 8: if, left parenthesis, curr P t r, equals equals, data P t r, right
parenthesis.
Explanation: curr P t r is not equal to data P t r, so the item is not in
the first node.
Line 9: prev P t r, minus, right angled bracket, link, equals, curr P t r,
minus, right angled bracket, link, semicolon.
Explanation: The node with the item is unlinked.
Line 10: if, left parenthesis, curr P t r, equals, equals, last P t r, right
parenthesis.
Explanation: The item is not in the last node.
Line 11: delete curr P t r, semicolon.
Explanation: The node is deallocated.
Line 12: length, minus minus, semicolon.
Explanation: The length of the list is decremented.
Back to Figure
Line 1: Item Type, List, colon, colon, Get Next Item, left parenthesis,
right parenthesis.
Line 2: left brace.
Line 3; indented once: Item Type, item, semicolon.
Line 4; indented once: item, equals, current P o s, minus, right
angled bracket, component, semicolon.
Line 5; indented once: current P o s, equals, current P o s, minus,
right angled bracket, link, semicolon.
Line 6; indented once: return, item, semicolon.
Line 7: right brace.

Back to Figure
Line 1: int, List, colon, colon, Get Length, left parenthesis, right
parenthesis, const.
Line 2: left brace, return, length, semicolon, right brace.
Line 3: blank line.
Line 4: bool, List, colon, colon, Is Empty, left parenthesis, right
parenthesis, const.
Line 5: left brace, return, left parenthesis, data P t r, equals, equals,
NULL, right parenthesis, semicolon, right brace.
Line 6: blank line.
Line 7: bool, List, colon, colon, Has Next, left parenthesis, right
parenthesis, const.
Line 8: left brace, return, left parenthesis, current P o s, exclamation
mark, equals, NULL, right parenthesis, semicolon, right brace.
Back to Figure
Line 1: bool, List, colon, colon, Is Full, left parenthesis, right
parenthesis, const.
Line 2: left brace, return, false, semicolon, right brace.
Back to Figure
Line 1: bool, List, colon, colon, Is There, left parenthesis, right
parenthesis, const.
Line 2: left brace.
Line 3; indented once: Node P t r, c u r r P t r, equals, data P t r,
semicolon. 2 forward slashes. Loop control pointer.
Line 4; indented once: while, left parenthesis, c u r r P t r,
exclamation mark, equals, NULL, ampersand, ampersand, c u r r P t
r, minus, right angled bracket, component, exclamation mark,
equals, item, right parenthesis.
Line 5; indented twice: c u r r P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon.
Line 6: blank line.
Line 7; indented once: if, left parenthesis, c u r r P t r, exclamation
mark, equals, NULL, right parenthesis.
Line 8; indented twice: return, true, semicolon.

Line 9; indented once: else.
Line 10; indented twice: return, false, semicolon.
Line 11: right brace.
Back to Figure
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE. Left parenthesis,
List, dot, h, right parenthesis.
Line 3: 2 forward slashes. This file gives the specification of a list
abstract data type.
Line 4: 2 forward slashes. The list components are not assumed to
be in order by value.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: typedef,
int, void, bool, const, struct.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: typedef, int, Item Type, semicolon. 2 forward slashes. Type
of each component. 
Line 3: struct, Node Type, semicolon. 2 forward slashes. Forward
declaration.
Line 4: class List.
Line 5: left brace.
Line 6: public, colon.
Line 7; indented once: List, left parenthesis, right parenthesis,
semicolon.
Line 8; indented twice: 2 forward slashes. Constructor.
Line 9; indented twice: 2 forward slashes. Post, colon, Empty list has
been created.
Line 10: blank line.
Line 11; indented twice: 2 forward slashes. Action responsibilities.
Line 12; indented twice: void, Insert, left parenthesis, Item Type,
item, right parenthesis, semicolon.
Line 13; indented twice: 2 forward slashes. Pre, colon, List is not full
and item is not in the list.
Line 14; indented twice: 2 forward slashes. Post, colon, item is in the

list and length has been incremented.
Line 15; indented twice: void, Delete, left parenthesis, Item Type,
item, right parenthesis, semicolon.
Line 16; indented twice: 2 forward slashes. Post, colon, item is not in
the list.
Line 17; indented twice: void, Reset List, left parenthesis, right
parenthesis, semicolon.
Line 18; indented twice: 2 forward slashes. Post, colon, The current
position is rest to the first item in the list.
Line 19; indented twice: Item Type, Get Next Item, left parenthesis,
right parenthesis, semicolon.
Line 20; indented twice: 2 forward slashes. Assumptions, colon, No
transformers are called during the iteration.
Line 21; indented twice: 2 forward slashes. There is an item to be
retuned, semicolon, that is, comma, Has Next is true when.
Line 22; indented twice: 2 forward slashes. This method is invoked.
Line 23; indented twice: 2 forward slashes. Pre, colon, Reset List
has been called if this is not the first iteration.
Line 24; indented twice: 2 forward slashes. Post, colon, Returns item
at the current position.
Line 25: blank line.
Line 26; indented twice: 2 forward slashes. Knowledge responsibility.
Line 27; indented twice: int, Get Length, left parenthesis, right
parenthesis, const, semicolon.
Line 28; indented twice: 2 forward slashes. Post, colon, Returns the
length of the list.
Line 29; indented twice: bool, Is Empty, left parenthesis, right
parenthesis, const, semicolon.
Line 30; indented twice: 2 forward slashes. Post, colon, Returns true
if list is empty, semicolon, false otherwise.
Line 31; indented twice: bool, Is Full, left parenthesis, right
parenthesis, const, semicolon.
Line 32; indented twice: 2 forward slashes. Post, colon, Returns true
if list is full, semicolon, false otherwise.
Line 33; indented twice: bool, Is There, left parenthesis, Item Type,
item, right parenthesis, const, semicolon.
Line 34; indented twice: 2 forward slashes. Post, colon, Returns true
if item is in the list, semicolon, false otherwise.
Line 35; indented twice: bool, Has Next, left parenthesis, right

parenthesis, const, semicolon.
Line 36; indented twice: 2 forward slashes. Post, colon, Returns true
if there is another item to be returned, semicolon.
Line 37; indented twice: 2 forward slashes. False otherwise.
Line 38; indented twice: private, colon.
Line 39; indented thrice: Node Type asterisk, data P t r, semicolon. 2
forward slashes. Pointer to the fist node in the list.
Line 40; indented thrice: int, length, semicolon. 2 forward slashes.
Pointer to the current position.
Line 41; indented thrice: Node Type asterisk, current P o s,
semicolon. 2 forward slashes. Pointer to the current position.
Line 42; indented 15 times: 2 forward slashes. In a traversal.
Line 43; indented thrice: Node Type asterisk, last P t r, semicolon. 2
forward slashes. Pointer to the last node in the list.
Line 44: right brace, semicolon.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: include, i
o stream, c s t d def, using namespace, typedef, if, else, void,
struct.
Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE. Left
parenthesis, List, dot, c p p, right parenthesis.
Line 3: 2 forward slashes. This file implements the List class
member functions.
Line 4: 2 forward slashes. List representation, colon, A linked list
with head and tail.
Line 5: 2 forward slashes. Pointers, a length field, and a current
position pointer.
Line 6: 2 forward slashes followed by asterisk till the end of the line.
Line 7: Hash include, double quotes, List, dot, h, double quotes.
Line 8: Hash include, left angled bracket, i o stream, right angled
bracket.
Line 9: Hash include, left angled bracket, c s t d def, right angled
bracket. 2 forward slashes. For NULL.
Line 10: blank line.
Line 11: using, namespace, s t d, semicolon.

Line 12: blank line.
Line 13: typedef, Node Type asterisk, Node P t r, semicolon.
Line 14: struct, Node Type.
Line 15: left brace.
Line 16; indented once: Item Type, component, semicolon.
Line 17; indented once: Node P t r, link, semicolon.
Line 18: right brace, semicolon.
Line 19: blank line.
Line 20: List, colon, colon, List, left parenthesis, right parenthesis.
Line 21: 2 forward slashes. Post, colon, data P t r, equals, equals,
NULL.
Line 22: left brace.
Line 23; indented once: data P t r, equals, NULL, semicolon.
Line 24; indented once: current P o s, equals, data P t r, semicolon.
Line 25; indented once: length, equals, 0, semicolon.
Line 26; indented once: last P t r, equals, NULL, semicolon.
Line 27: right brace.
Line 28: blank line.
Line 29: 2 forward slashes followed by asterisk till the end of the line.
Line 30: blank line.
Line 31: void, List, colon, colon, Insert, left parenthesis, Item Type,
item, right parenthesis.
Line 32: 2 forward slashes. Post, colon, New node containing item is
at the end of the linked list.
Line 33: 2 forward slashes. Indented thrice: And last P t r points to
the new node.
Line 34: left brace.
Line 35; indented once: Node P t r, new Node P t r, equals, new,
Node Type, semicolon.
Line 36; indented once: new Node P t r, minus, right angled bracket,
component, equals, item, semicolon.
Line 37; indented once: new Node P t r, minus, right angled bracket,
link, equals, NULL, semicolon.
Line 38; indented once: if, left parenthesis, last P t r, equals, equals,
NULL, right parenthesis.
Line 39; indented twice: data P t r, equals, new Node P t r,
semicolon. 
Line 40; indented once: else.
Line 41; indented twice: last P t r, minus, right angled bracket, link,

equals, new Node P t r, semicolon.
Line 42; indented once: last P t r, equals, new Node P t r, semicolon.
Line 43; indented once: length, plus, plus, semicolon.
Line 44: right brace.
Line 45: blank line.
Line 46: 2 forward slashes followed by asterisk till the end of the line.
Line 47: blank line.
Line 48: void, List, colon, colon, Delete, left parenthesis, Item Type,
item, right parenthesis.
Line 49: left brace.
Line 50; indented once: Node P t r, p r e v P t r, equals, NULL,
semicolon. 2 forward slashes. Trailing pointer.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: while, if,
else, void, return, int, bool, const.
Line 1; indented once: Node P t r, c u r r P t r, equals, data P t r,
semicolon. 2 forward slashes. Loop control pointer.
Line 2; indented once: while, left parenthesis, exclamation mark,
equals, NULL, ampersand, ampersand, c u r r P t r, minus, right
angled bracket, component, exclamation mark, equals, item, right
parenthesis.
Line 3; indented once: left brace.
Line 4; indented twice: p r e v P t r, equals, c u r r P t r, semicolon. 
Line 5; indented twice: c u r r P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon.
Line 6; indented once: right brace.
Line 7; indented once: if, left parenthesis, c u r r P t r, exclamation
mark, equals, NULL, right parenthesis.
Line 8; indented once: left brace. 2 forward slashes. Item is found.
Line 9; indented twice: if, left parenthesis, c u r r P t r, equals,
equals, data P t r, right parenthesis.
Line 10; indented thrice: data P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon. 2 forward slashes. Item is in first
node.
Line 11; indented once: else.
Line 12; indented thrice: p r e v P t r, minus, right angled bracket,

link, equals, c u r r P t r, minus, right angled bracket, link, semicolon.
Line 13; indented twice: if, left parenthesis, c u r r P t r, equals,
equals, last P t r, right parenthesis.
Line 14; indented thrice: last P t r, equals, p r e v P t r, semicolon. 2
forward slashes. Item is in last node.
Line 15; indented twice: delete, c u r r P t r, semicolon.
Line 16; indented twice: length, minus, minus, semicolon.
Line 17; indented once: right brace.
Line 18: right brace.
Line 19: blank line.
Line 20: 2 forward slashes followed by asterisk till the end of the line.
Line 21: blank line.
Line 22: void, List, colon, colon, Reset List, left parenthesis, right
parenthesis.
Line 23: left brace.
Line 24; indented once: current P o s, equals, data P t r, semicolon.
Line 25: right brace.
Line 26: blank line.
Line 27: 2 forward slashes followed by asterisk till the end of the line.
Line 28: blank line.
Line 29: Item Type, List, colon, colon, Get Next Item, left
parenthesis, right parenthesis.
Line 30: left brace.
Line 31; indented once: Item Type, item, semicolon.
Line 32; indented once: item, equals, current P o s, minus, right
angled bracket, component, semicolon.
Line 33; indented once: current P o s, equals, current P o s, minus,
right angled bracket, link, semicolon.
Line 34: return, item, semicolon.
Line 35: right brace.
Line 36: blank line.
Line 37: 2 forward slashes followed by asterisk till the end of the line.
Line 38: blank line.
Line 39: int, List, colon, colon, Get Length, left parenthesis, right
parenthesis, const
Line 40: left brace, return, length, semicolon, right brace.
Line 41: blank line.
Line 42: 2 forward slashes followed by asterisk till the end of the line.
Line 43: blank line.

Line 44: bool, List, colon, colon, Is Empty, left parenthesis, right
parenthesis, const.
Line 45: left brace, return, left parenthesis, data P t r, equals,
equals, NULL, right parenthesis, semicolon, right brace.
Line 46: blank line.
Line 47: 2 forward slashes followed by asterisk till the end of the line.
Line 48: blank line.
Line 49: bool, List, colon, colon, Has Next, left parenthesis, right
parenthesis, const.
Line 50: left brace, return, left parenthesis, current P o s,
exclamation mark, equals, NULL, right parenthesis, semicolon, right
brace.
Line 51: blank line.
Line 52: 2 forward slashes followed by asterisk till the end of the line.
Line 53: blank line.
Line 54: bool, List, colon, colon, Is Full, left parenthesis, right
parenthesis, const.
Line 55: left brace, return, false, semicolon, right brace.
Back to Figure
Program code. The words used in the variable names and keywords
are merged. The program contains the following keywords: bool,
while, if, else, return, const.

Line 1: 2 forward slashes followed by asterisk till the end of the line.
Line 2: blank line.
Line 3: bool, List, colon, colon, Is There, left parenthesis, Item Type,
item, right parenthesis, const. 
Line 4: left brace.
Line 5; indented once: Node P t r, c u r r P t r, equals, data P t r,
semicolon. 2 forward slashes. Loop control pointer.
Line 6; indented once: while, left parenthesis, c u r r P t r,
exclamation mark, equals, NULL, ampersand, ampersand, c u r r P t
r, minus, right angled bracket, component, exclamation mark,
equals, item, right parenthesis.
Line 7; indented twice: c u r r P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon. 
Line 8; indented once: if, left parenthesis, c u r r P t r, exclamation
mark, equals, NULL, right parenthesis.
Line 9; indented twice: return, true, semicolon. 
Line 10; indented once: else.
Line 11; indented twice: return, false, semicolon.
Line 12: right brace.
Back to Figure
Line 1: No dot of unique readings, colon, 16.
Line 2: Readings without value of 200.
Line 3: 70.
Line 4: 68.
Line 5: 69.
Line 6: 72.
Line 7: 87
Line 8: 82.
Line 9: 81.
Line 10: 75.
Line 11: 78.
Line 12: 67.
Line 13: 65.
Line 14: 66.
Line 15: 61.
Line 16: 71.
Line 17: 77.

Back to Figure
Line 1: List, colon, colon, tilde, List, left parenthesis, right
parenthesis.
Line 2: 2 forward slashes. Destructor.
Line 3: 2 forward slashes. Post, colon, All linked list nodes have
been deallocated.
Line 4: left brace.
Line 5; indented once: Node P t r, temp P t r, semicolon.
Line 6; indented once: Node P t r, c u r r P t r, equals, data P t r,
semicolon.
Line 7; indented once: while, left parenthesis, c u r r P t r,
exclamation mark, equals, NULL, right parenthesis.
Line 8; indented twice: left brace.
Line 9; indented twice: temp P t r, equals, c u r r P t r, semicolon.
Line 10; indented twice: c u r r P t r, equals, c u r r P t r, minus, right
angled bracket, link, semicolon.
Line 11; indented twice: delete, temp P t r, semicolon.
Line 12; indented twice: right brace.
Line 13: right brace.
Back to Figure
Line 1: List, list One, semicolon.
Line 2: List, list Two, semicolon.
Line 3: dot, dot, dot.
Line 4: list One, equals, list Two, semicolon.
Back to Figure
List One is labeled in top left corner of the block. Below are 4
rectangles arranged in a row. The first rectangle is labeled data P t r.
The 3 other rectangles in the row are divided into 2 parts. The
values of second, third, and fourth rectangle in the row are as
follows: 10, blank, 20, blank, and 30, blank. Another 2 rectangles
labeled current P o s, and last P t r are placed in next row. The
current P o s is placed towards left side and the last P t r is placed
towards right. A rectangle labeled length with a value 9, is placed
below current P o s. An arrow from data P t r points to 10. An arrow

from the blank part with 10 points to 20. An arrow from the blank
part with 20 points to 30 which is detached by 3 dots. An arrow from
current P o s points to 20. An arrow from last P t r points to 30. List
Two is labeled in middle left of the block. Below are 4 rectangles
arranged in a row. The first rectangle is labeled data P t r. The 3
other rectangles in the row are divided into 2 parts. The values of
second, third, and fourth rectangle in the row are as follows: 3,
blank, 8, blank, and 1066, blank. Another 2 rectangles labeled
current P o s, and last P t r are placed in next row. The current P o s
with a value slash, is placed towards left side and the last P t r is
placed towards right. A rectangle labeled length with a value 5, is
placed below current P o s. An arrow from data P t r points to 3. An
arrow from the blank part with 3 points to 8. An arrow from the blank
part with 8 points to 1066 which is detached by 3 dots. An arrow
from last P t r points to 1066.
Back to Figure
Line 1: Name, name 1, left parenthesis, double quotes, Kenneth,
double quotes, comma, double quotes, Charles, double quotes,
comma, double quotes, Smith, double quotes, right parenthesis,
semicolon.
Line 2: Name, name 2, equals, name 1, semicolon.
Back to Figure
Line 1: class, Some Class.
Line 2: left brace.
Line 3: public, colon.
Line 4; indented twice: dot.
Line 5; indented twice: dot.
Line 6; indented twice: dot.
Line 7; indented once: Some Class, left parenthesis, const, Some
Class, ampersand, some Object, right parenthesis, semicolon. 2
forward slashes. Copy-constructor.
Line 8; indented twice: dot.
Line 9; indented twice: dot.
Line 10; indented twice: dot.
Line 11: right brace, semicolon.

Back to Figure
Line 1: List, colon, colon, List, left parenthesis, const, List,
ampersand, other List, right parenthesis.
Line 2: 2 forward slashes. Copy-constructor.
Line 3: blank line.
Line 4: 2 forward slashes. Post, colon, A deep cope of other List is
created and the external pointer.
Line 5: 2 forward slashes. Now points to this list.
Line 6: left brace.
Line 7; indented once: Node P t r, from P t r, semicolon. 2 forward
slashes. Pointer into list being copied from.
Line 8; indented once: Node P t r, to P t r, semicolon. 2 forward
slashes. Pointer into new list being built.
Line 9: blank line.
Line 10; indented once: if, left parenthesis, other List, dot, data P t r,
equals, equals, NULL, right parenthesis.
Line 11; indented once: left brace.
Line 12; indented twice: data P t r, equals, NULL, semicolon. 
Line 13; indented twice: return, semicolon.
Line 14; indented once: right brace.
Line 15; indented once: 2 forward slashes. Copy first node.
Line 16; indented once: from P t r, equals, other List, dot, data P t r,
semicolon.
Line 17; indented once: data P t r, equals, new Node Type,
semicolon.
Line 18; indented once: data P t r, minus, right angled bracket,
component, equals, from P t r, minus, right angled bracket,
component, semicolon.
Line 19; indented once: 2 forward slashes. Copy remaining nodes.
Line 20; indented once: to P t r, equals, data P t r, semicolon.
Line 21; indented once: from P t r, equals, from P t r, minus, right
angled bracket, link, semicolon.
Line 22; indented once: while, left parenthesis, from P t r,
exclamation mark, equals, NULL, right parenthesis.
Line 23; indented once: Copy nodes from original to duplicate.
Line 24; indented once: left brace.
Line 25; indented twice: to P t r, minus, right angled bracket, link,
equals, new, Node Type, semicolon. 2 forward slashes. Stores new

node in link of.
Line 26; indented 23 times: 2 forward slashes. Last node added to
new list.
Line 27; indented twice: to P t r, equals, to P t r, minus, right angled
bracket, link, semicolon. 2 forward slashes. to P t r points to new
node.
Line 27; indented twice: to P t r, minus, right angled bracket,
component, equals, from P t r, minus, right angled bracket,
component, semicolon. 2 forward slashes. Copy component to new
node.
Line 28; indented twice: from P t r, equals, from P t r, minus, right
angled bracket, link, semicolon. 2 forward slashes. From P t r points
to next node.
Line 29; indented 23 times: 2 forward slashes. of original list. 
Line 30; indented once: right brace. 
Line 31; indented once: to P t r, minus, right angled bracket, link,
equals, NULL, semicolon.
Line 32: last P t r, equals, to P t r, semicolon. 2 forward slashes. Set
last pointer.
Line 33: right brace.
Back to Figure
Line 1: class, Some Class.
Line 2: left brace.
Line 3: public, colon.
Line 4; indented thrice: dot.
Line 5; indented thrice: dot.
Line 6; indented thrice: dot.
Line 7; indented once: Some Class, left parenthesis, dot, dot, dot,
right parenthesis, semicolon
Line 8: 2 forward slashes. Constructor.
Line 9: blank line.
Line 10; indented once: Some Class, left parenthesis, const, Some
Class, ampersand, another Object, semicolon.
Line 11; indented twice: 2 forward slashes. Copy constructor, for
deep copying is initializations.
Line 12: blank line.
Line 13; indented once: tilde, Some Class, left parenthesis, right

parenthesis, semicolon.
Line 14; indented twice: 2 forward slashes. Destructor, to clean up
the free store. 
Line 15: private, colon.
Line 16; indented thrice: dot.
Line 17; indented thrice: dot.
Line 18; indented thrice: dot.
Line 19: right brace, semicolon.
Back to Figure
Line 1: Insert, left parenthesis, In, colon, item, right parenthesis.
Line 2: Set new Node P t r, to, new Node Type.
Line 3: Set new Node P t r, minus. right angled bracket, component
to item.
Line 4: blank line.
Line 5: IF data P t r is NULL. 2 forward slashes. Empty list.
Line 6; indented once: Set new Node P t r, minus, right angled
bracket, NULL.
Line 7; indented once: Set data P t r to new Node P t r.
Line 8; indented once: Set last P t r to new Node P t r.
Line 9: ELSE.
Line 10; indented once: Set c u r r P t r to data P t r.
Line 11; indented once: Set p r e v P t r to NULL.
Line 12; indented once: WHILE c u r r P t r exclamation mark,
equals, NULL AND c u r r P t r, minus, right angled bracket,
component, item.
Line 13; indented twice: Set p r e v P t r to c u r r P t r.
Line 14; indented twice: Set c u r r p t r to c u r r P t r, minus, right
angled bracket, link.
Line 15; indented once: Set new Node P t r to c u r r P t r.
Line 16; indented once: IF p r e v P t r, equals, equals, NULL. 2
forward slashes. Insert at first node.
Line 17; indented twice: data P t r, equals, new Node P t r. 
Line 18; indented once: ELSE. 
Line 19; indented twice: Set p r e v P t r to new Node P t r. 
Line 20; indented once: IF c u r r P t r, equals, equals, NULL. 2
forward slashes. Insert as last node.
Line 21; indented twice: Set last P t r to new Node P t r. 

Back to Figure
Line 1: void, Sorted List, colon, colon, Insert, left parenthesis, Item
Type item, right parenthesis.
Line 2: 2 forward slashes, Post colon, New node containing item is in
its proper place and.
Line 3: 2 forward slashes, component members of list nodes are in
ascending order.
Line 4: left brace.
Line 5: indented once, Node P t r, curr P t r, semicolon, 2 forward
slashes, Moving pointer.
Line 6: indented once, Node P t r, prev P t r, semicolon, 2 forward
slashes, Trailing pointer.
Line 7: indented once, Node P t r, new Node P t r, semicolon, 2
forward slashes, Pointer to new node.
Line 8: indented once, new Node P t r, equals, new Node Type,
semicolon.
Line 9: indented once, new Node P t r, minus, right angled bracket,
component, equals, item, semicolon.
Line 10: indented once, new Node P t r, minus, right angled bracket,
link, equals, null in uppercase, semicolon.
Back to Figure
The words in the pointers and keywords are merged. The code
contains the following keywords: if, else, and while.
Line 1: if, left parenthesis, data P t r, equals equals, null in
uppercase, right parenthesis, 2 forward slashes, Empty list.
Line 2: left brace.

Line 3: indented once, new Node P t r, minus, right angled bracket,
component, equals, null in uppercase, semicolon.
Line 4: indented once, data P t r, equals, new Node P t r, semicolon.
Line 5: indented once, last P t r, equals, new Node P t r, semicolon.
Line 6: right brace.
Line 7: else.
Line 8: left brace, 2 forward slashes, Find previous insertion point.
Line 9: indented once, curr P t r, equals, data P t r, semicolon.
Line 10: indented once, prev P t r, equals, null in uppercase,
semicolon.
Line 11: indented once, while, left parenthesis, curr P t r,
exclamation mark, equals, null in uppercase, 2 ampersands, curr P t
r, minus, right angled bracket, component, left angled bracket, item,
right parenthesis.
Line 12: indented once, left brace.
Line 13: indented twice, prev P t r, equals, curr P t r, semicolon.
Line 14: indented twice, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
Line 15: indented once, right brace.
Line 16: indented once, 2 forward slashes, Insert new node.
Line 17: indented once, new Node P t r, minus, right angled bracket,
link, equals, curr P t r, semicolon.
Line 18: indented once, if, left parenthesis, prev P t r, equals,
equals, null in uppercase, right parenthesis, 2 forward slashes,
Insert as first, question mark.
Line 19: indented twice, data P t r, equals, new Node P t r,
semicolon.
Line 20: indented once, else.
Line 21: indented twice, prev P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon.
Line 22: indented once, if, left parenthesis, curr P t r, equals, equals,
null in uppercase, right parenthesis, 2 forward slashes, Insert as
last, question mark.
Line 23: indented twice, last P t r, equals, new Node P t r, semicolon.
Line 24: indented once, right brace.
Line 25: indented once, length plus plus, semicolon.
Line 26: right brace.
Back to Figure

3 rectangles that are each divided into 2 parts are arranged in a row.
The values of the rectangles are as follows: 30, blank, 50, blank,
and 90, slash respectively. A rectangle labeled data P t r is placed
above, to the left of the rectangle with value 30. Another rectangle
labeled last P t r is placed above, in between the rectangles with the
values 50 and 90. An arrow from data P t r points to 30. An arrow
from the blank part with 30 points to 50. An arrow from blank part
with 50 points to 90. An arrow from last P t r points to 90. 
Back to Figure
A rectangle labeled p r e v P t r is placed in row 1, top left corner of
the block. 2 rectangles labeled c u r r P t r, and last P t r are placed
in the next row. The c u r r P t r is placed below p r e v P t r, and last
P t r is placed towards right side of the block. Another 4 rectangles
are placed in the next row. The first rectangle is labeled as data P t r.
The other 3 rectangles in the row are each divided into 2 parts. The
values of the rectangles in the row are as follows: 30, blank, 50,
blank, and 90, slash respectively. 2 rectangles are arranged in the
next row. The first rectangle is labeled as new Node P t r. The
second rectangle is divided into 2 parts. It holds the values 20 and a
question mark. An arrow from c u r r P t r points to 30. An arrow
from data P t r points to 30. An arrow from blank part with 30 points
to 50. An arrow from blank part with 50 points to 90. An arrow from
last P t r points to 90. An arrow from new Node P t r points to 20.
Back to Figure
Line 1: new Node P t r, equals, new Node Type, semicolon.
Line 2: new Node P t r, minus, right angled bracket, component,
equals, item, semicolon.
Explanation: These two statements create and initialize the new
node.
Line 3: if, left parenthesis, data P t r, equals, equals, null in
uppercase.
Explanation: List is not empty.
Line 4: else.
Line 5: indented once, curr P t r, equals, data P t r, semicolon.
Line 6: indented once, prev P t r, equals, null in uppercase,

semicolon.
Explanation: Set up for traversal.
Line 7: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 8: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.
Explanation: Because 20 is less than 30, the expression is false and
the loop body is not entered.
Line 9: new Node P t r, minus, right angled bracket, link, equals, curr
P t r, semicolon.
Explanation: link member of, asterisk new Node P t r, now points to,
asterisk curr P t r.
Line 10: if, left parenthesis, prev P t r, equals, equals, null in
uppercase, right parenthesis.
Line 11: indented once, data P t r, equals, new Node P t r,
semicolon.
Explanation: Because prev P t r is null in uppercase, the then clause
is executed and 20 is inserted at the front of the list.
Back to Figure
3 rectangles that are each divided into 2 parts are arranged in a row.
The values of the rectangles are as follows: 30, blank, 50, blank,
and 90, slash respectively. A rectangle labeled data P t r is placed
above, to the left of the rectangle with value 30. Another rectangle
labeled last P t r is placed above, in between the rectangles with the
values 50 and 90. Another rectangle is placed below the rectangle
with the value 30. This rectangle is divided into parts with the values
20 and blank respectively. An arrow from data P t r points to 20. An
arrow from the blank part with 20 points to 30. An arrow from the
blank part with 30 points to 50. An arrow from blank part with 50
points to 90. An arrow from last P t r points to 90.
Back to Figure
Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 2: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.

Line 3: indented once, prev P t r, equals, curr P t r, semicolon.
Line 4: indented once, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
A text to the side of the code reads: Because 30 is less than 60, this
expression is true and the loop body is repeated. Pointer variables
are advanced.
Back to Figure
3 rectangles labeled, p r e v P t r, c u r r P t r, last P t r are arranged
in a row with certain gaps between them. 4 rectangles are arranged
in the next row. The first rectangle in this row is labeled as data P t r.
The other 3 rectangles in the row are each divided into 2 parts. The
values of the rectangles are as follows: 30, blank, 50, blank, and 90,
slash respectively. Another 2 rectangles labeled, new Node P t r, and
asterisk new Node P t r are arranged in the next row. Asterisk new
Node P t r is divided into 2 parts that holds the value 60 and a
question mark respectively. An arrow from data P t r points to 30. An
arrow from the blank part with 30 points to 50. An arrow from the
blank part with 50 points to 90. An arrow from p r e v P t r points to
30. An arrow from c u r r P t r points to 50. An arrow from last P t r
points to 90. An arrow from new Node P t r points to 60.
Back to Figure
Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 2: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.
Line 3: indented once, prev P t r, equals, curr P t r, semicolon.
Line 4: indented once, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
A text to the side of the code reads: Because 50 is less than 60, the
expression is true and the loop body is repeated. Pointer variables
are advanced.
Back to Figure

3 rectangles labeled, p r e v P t r, c u r r P t r, last P t r are arranged
in a row. The p r e v P t r is placed towards left side of the block.
The c u r r P t r, and last P t r is placed towards right side of the
block. 4 rectangles are arranged in the next row. The first rectangle
in this row is labeled as data P t r. The other 3 rectangles in the row
are each divided into 2 parts. The values of the rectangles are as
follows: 30, blank, 50, blank, and 90, slash respectively. Another 2
rectangles labeled, new Node P t r, and asterisk new Node P t r are
arranged in the next row. Asterisk new Node P t r is divided into 2
parts that holds the value 60 and a question mark respectively. An
arrow from data P t r points to 30. An arrow from the blank part with
30 points to 50. An arrow from the blank part with 50 points to 90.
An arrow from p r e v P t r points to 50. An arrow from c u r r P t r
points to 90. An arrow from last P t r points to 90. An arrow from
new Node P t r points to 60.
Back to Figure
Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 2: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.
A text next to the code reads: Because 90 is not less than 60, the
expression is false and the loop body is not repeated.
Line 3: new Node P t r, minus, right angled bracket, link, equals, curr
P t r, semicolon.
A text next to the code reads: Link member of asterisk, new Node P
t r now points to asterisk, curr P t r.
Back to Figure
3 rectangles labeled, p r e v P t r, c u r r P t r, last P t r are arranged
in a row. The p r e v P t r is placed towards left side of the block.
The c u r r P t r, and last P t r is placed towards right side of the
block. 4 rectangles are arranged in the next row. The first rectangle
in this row is labeled as data P t r. The other 3 rectangles in the row
are each divided into 2 parts. The values of the rectangles are as
follows: 30, blank, 50, blank, and 90, slash respectively. Another 2
rectangles labeled, new Node P t r, and asterisk new Node P t r are

arranged in the next row. Asterisk new Node P t r is divided into 2
parts that holds the value 60 and a question mark respectively. An
arrow from data P t r points to 30. An arrow from the blank part with
30 points to 50. An arrow from the blank part with 50 points to 90.
An arrow from p r e v P t r points to 50. An arrow from c u r r P t r
points to 90. An arrow from last P t r points to 90. An arrow from
new Node P t r points to 60. An arrow from the blank part with 60
points to 90.
Back to Figure
Line 1: if, left parenthesis, prev P t r, equals, equals, null in
uppercase, right parenthesis.
Line 2: indented twice, prev P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon.
A text next to the code reads: Because the node is not inserted as
the first component, the else clause is executed.
Line 3: if, left parenthesis, curr P t r, equals, equals, null in
uppercase, right parenthesis.
A text next to the code reads: Because the node is not inserted as
the last component, no further action is taken.
Back to Figure
4 rectangles are arranged in a row. The first rectangle in this row is
labeled as data P t r. The other 3 rectangles in the row are each
divided into 2 parts. The values of the rectangles are as follows: 30,
blank, 50, blank, and 90, slash respectively. A rectangle labeled last
P t r, is placed above the rectangle with the value 50. Another
rectangle is placed below, in between the rectangles with the values
of 30 and 50. This rectangle is divided into 2 parts that holds the
values 60 and blank respectively. An arrow from data P t r points to
30. An arrow from the blank part with 30 points to 50. An arrow from
the blank part with 50 points to 60. An arrow from last P t r points to
90. An arrow from the blank part with 60 points to 90.
Back to Figure

Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 2: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.
A text next to the code reads: Because 90 is less than 100, this
expression is true and the loop body is repeated.
Line 3: indented once, prev P t r, equals, curr P t r, semicolon.
A text next to the code reads: The pointer variables are advanced.
Line 4: indented once, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
Back to Figure
3 rectangles labeled, p r e v P t r, last P t r, c u r r P t r are arranged
in a row respectively. All the rectangles are placed towards the right
side of the block. The value of c u r r P t r is slash. 4 rectangles are
arranged in the next row. The first rectangle in this row is labeled as
data P t r. The other 3 rectangles in the row are each divided into 2
parts. The values of the rectangles are as follows: 30, blank, 50,
blank, and 90, slash respectively. Another 2 rectangles labeled, new
Node P t r, and asterisk new Node P t r are arranged in the next row.
Asterisk new Node P t r is divided into 2 parts that holds the value
100 and a question mark respectively. An arrow from data P t r
points to 30. An arrow from the blank part with 30 points to 50. An
arrow from the blank part with 50 points to 90. An arrow from p r e v
P t r points to 90. An arrow from last P t r points to 90. An arrow
from new Node P t r points to 100.
Back to Figure
Line 1: while, left parenthesis, curr P t r, exclamation mark, equals,
null in uppercase, 2 ampersands.
Line 2: indented once, curr P t r, minus, right angled bracket,
component, left angled bracket, item, right parenthesis.
A text next to the code reads: Because curr P t r equals, null in
uppercase, the expression is false and the loop body is not
repeated.
Line 3: new Node P t r, minus, right angled bracket, link, equals, curr
P t r, semicolon.

A text next to the code reads: null in uppercase, is copied into the
link member of, asterisk new Node P t r.
Line 4: if, left parenthesis, prev P t r, equals, equals, null in
uppercase, right parenthesis.
Line 5: indented once, prev P t r, minus, right angled bracket, link,
equals, new Node P t r, semicolon.
A text next to the code reads: Because the node is not inserted as
the first component, the else clause is executed.
Line 6: if, left parenthesis, curr P t r, equals, equals, null in
uppercase, right parenthesis.
Line 7: indented once, last P t r, equals, new Node P t r, semicolon.
A text next to the code reads: The node is inserted at the end, so
last P t r is updated.
Back to Figure
4 rectangles are arranged in a row. The first rectangle in this row is
labeled as data P t r. The other 3 rectangles in the row are each
divided into 2 parts. The values of the rectangles are as follows: 30,
blank, 50, blank, and 90, blank respectively. Another 2 rectangles
are arranged in the next row. The first rectangle in the row is labeled
as last P t r. The second rectangle in the row is divided into parts
that holds the values 100, and slash respectively. An arrow from
data P t r points to 30. An arrow from the blank part with 30 points
to 50. An arrow from the blank part with 50 points to 90. An arrow
from blank part with 90 points to 100. An arrow from last P t r points
to 100.
Back to Figure
Line 1: while, left parenthesis, c u r r P t r, exclamation mark, equals,
Null, ampersand, ampersand, c u r r P t r, minus, right angled
bracket, component, exclamation mark, equals, item. 
Line 2: indented twice: ampersand, ampersand, c u r r P t r, minus,
right angled bracket, component, left angled bracket, item, right
parenthesis. Line 2 is shaded.
Back to Figure

The words in the pointers are merged.
Line 1: void Sorted List, colon, colon, Delete, left parenthesis, Item
Type, item, right parenthesis.
Line 2: left brace.
Line 3: indented once, Node P t r, prev P t r, equals, null in
uppercase, semicolon, 2 forward slashes, Trailing pointer.
Line 4: indented once, Node P t r, curr P t r, equals, data P t r,
semicolon, 2 forward slashes, Loop control pointer.
Line 5: indented once, while, left parenthesis, curr P t r, exclamation
mark, equals, null in uppercase, 2 ampersands, curr P t r, minus,
right angled bracket, component, exclamation mark, equals, item.
Line 6: indented 5 times, 2 ampersands, curr P t r, minus, right
angled bracket, component, left angled bracket, item, right
parenthesis. 
Line 6 is shaded.
Line 7: indented once, left brace.
Line 8: indented twice, prev P t r, equals, curr P t r, semicolon.
Line 9: indented twice, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
Line 10: indented once, right brace.
Line 11: indented once, if, left parenthesis, curr P t r, exclamation
mark, equals, null in uppercase, the following code is shaded: 2
ampersands curr P t r, minus, right angled bracket, component,
equals, equals, item, right parenthesis.
Line 12: indented once, left parenthesis, 2 forward slashes, item is
found.
Line 13: indented twice, if, left parenthesis, curr P t r, equals, equals,
data P t r, right parenthesis.
Line 14: indented thrice, data P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon, 2 forward slashes, item is in first
node.
Line 15: indented twice, else.
Line 16: indented thrice, prev P t r, minus, right angled bracket, link,
equals, curr P t r, minus, right angled bracket, link, semicolon.
Line 17: indented twice, if, left parenthesis, curr P t r, equals, equals,
last P t r, right parenthesis.
Line 18: indented thrice, last P t r, equals, prev P t r, semicolon, 2
forward slashes, item is in last node.
Line 19: indented twice, delete curr P t r, semicolon.

Line 20: indented twice, length, minus, minus, semicolon.
Line 21: indented once, right brace.
Line 22: right brace.
Back to Figure
A rectangle labeled p r e v P t r is placed in row 1, top left corner of
the block. The value of p r e v P t r is slash. Another 2 rectangles
labeled c u r r P t r, and last P t r are placed in the next row. The c u
r r P t r is placed below p r e v P t r, and last P t r is placed towards
right side of the block. Another 4 rectangles are placed in the next
row. The first rectangle is labeled as data P t r. The other 3
rectangles in the row are each divided into 2 parts. The values of the
rectangles in the row are as follows: 30, blank, 50, blank, and 90,
slash respectively. A rectangle labeled item is placed below data P t
r. It holds the value 30. An arrow from c u r r P t r points to 30. An
arrow from data P t r points to 30. An arrow from blank part with 30
points to 50. An arrow from blank part with 50 points to 90. An arrow
from last P t r points to 90.
Back to Figure
Line 1: while, left parenthesis, curr P t r, minus, right angled bracket,
component, exclamation mark, equals, item, right parenthesis.
Explanation: The item is found so the loop is not entered.
Line 2: if, left parenthesis, curr P t r, minus, right angled bracket,
component, equals, equals, item, right parenthesis.
Explanation: The item is found.
Line 3: indented once, if, left parenthesis, current P t r, equals,
equals, data P t r, right parenthesis. 
Explanation: The node is the first one.
Line 4: indented twice, data P t r, equals, curr P t r, semicolon.
Explanation: The external pointer points to the second node.
Line 5: if, left parenthesis, curr P t r, equals, equals, last P t r, right
parenthesis.
Explanation: The node is not the last.
Line 6: delete curr P t r, semicolon.
Explanation: asterisk, curr P t r, is returned to the heap.

Line 7: length, minus, minus, semicolon.
Explanation: The length of the list is decremented.
Back to Figure
Line 1: while, left parenthesis, dot, dot, dot, right parenthesis.
Explanation: All of the expressions are true, so the loop is entered.
Line 2: indented once, prev P t r, equals, curr P t r, semicolon.
Line 3: indented once, curr P t r, equals, curr P t r, minus, right
angled bracket, link, semicolon.
Explanation: Pointers are moved forward.
Line 4: while, left parenthesis, curr P t r, minus, right angled bracket,
component, exclamation mark, equals, item, right parenthesis.
Explanation: The node does contain the item to be deleted, so the
loop is not entered again.
Line 5: if, left parenthesis, curr P t r, minus, right angled bracket,
component, equals, equals, item, right parenthesis. 
Explanation: The item is found.
Line 6: indented once, if, left parenthesis, current P t r, equals,
equals, data P t r, right parenthesis.
Explanation: The node is not the first one.
Line 7: indented once, else.
Line 8: indented twice, prev P t r, minus, right angled bracket, link,
equals, equals, curr P t r, minus, right angled bracket, link,
semicolon.
Explanation: The node with 30 is linked to the node with 90.
Line 9: if, left parenthesis, curr P t r, equals, equals, last P t r, right
parenthesis.
Explanation: The node is not the last.
Line 10: delete, curr P t r, semicolon.
Explanation: asterisk, curr P t r, is returned to the heap.
Line 11: length, minus, minus, semicolon.
Explanation: The length of the list is decremented.
Back to Figure
Line 1, Entry, left parenthesis, Name new Name comma, Time of
Day new Time, right parenthesis.
Line 2, 2 forward slash, Creates an Entry object with new Name as

the name attribute and.
Line 3, 2 forward slash, new Time as the time attribute.
Line 4, left brace.
Line 5, indented once, name equals, new Name, semicolon.
Line 6, indented once, time equals, new Time, semicolon.
Line 7, right brace.
Back to Figure
Line 1, Relation Type Compared To, left parenthesis, Entry other
Entry, right parenthesis.
Line 2, 2 forward slash, Compares time with entry dot time.
Line 3, 2 forward slash, Post, colon, Return value is.
Line 4, 2 forward slash, BEFORE if time comes before entry dot
time, semicolon.
Line 5, 2 forward slash, SAME if time is the same as entry dot time,
semicolon.
Line 6, 2 forward slash, if time comes after entry dot time.
Line 7, left brace.
Line 8, indented once, return, left parenthesis, time dot Compared
To, left parenthesis, other Entry dot time, 2 right parenthesis,
semicolon.
Line 9, right brace.
Back to Figure
Line 1, Insert, left parenthesis, In colon, item, right parenthesis.
Line 2, dot dot dot.
Line 3, WHILE curr P t r, not equal to NULL AND.
Line 4, indented once, curr P t r, hyphen, right angled bracket,
component dot Compared To, left parenthesis, item, right
parenthesis, 2 equal to symbol, BEFORE.
Line 5, dot dot dot.
Back to Figure
Line 1, Delete, left parenthesis, In, colon, item, right parenthesis.
Line 2, dot dot dot.
Line 3, WHILE curr P t r, not equal to NULL AND.

Line 4, indented once, curr P t r, hyphen, right angled bracket,
component dot Compared To, left parenthesis, item, not equal to
SAME, right parenthesis, AND.
Line 5, indented once, curr P t r, hyphen, right angled bracket,
component dot Compared To, left parenthesis, item, right
parenthesis, 2 equal to symbol, BEFORE.
Line 6, dot dot dot.
Line 7, IF curr P t r, not equal to, NULL AND curr P t r, hyphen, right
angled bracket, component dot Compared To, left parenthesis, item,
right parenthesis, 2 equal to symbol, SAME.
Line 8, indented once, dot dot dot.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: include, using
namespace, int, main, if, while, end l, c out, return.
Line 1, 2 forward slash followed by asterisks till the end of the line.
Line 2, 2 forward slash, DRIVER for class sorted list of class Entry.
Line 3, 2 forward slash, This program tests the constructors and
return functions.
Line 4, 2 forward slash followed by asterisks till the end of the line.
Line 5, hashtag include, left angled bracket, i o stream, right angled
bracket.
Line 6, hashtag include, double quotes, Sorted List dot h, double
quotes.
Line 7, hashtag include, left angled bracket, string, right angled
bracket.
Line 8, blank line.
Line 9, using namespace s t d, semicolon.
Line 10, blank line.
Line 11, int main, left parenthesis, right parenthesis.
Line 12, left brace.
Line 13, indented once, Sorted List list, semicolon.
Line 14, indented once, Entry entry 1, left parenthesis, double
quotes, Sally, double quotes comma, double quotes, Jane, double
quotes comma, double quotes, Smith, double quotes comma, 12
comma, 20 comma, 1, right parenthesis, semicolon, 2 forward slash,
Create 1 s t entry.

Line 15, indented once, if, left parenthesis, exclamation symbol, list
dot Is There, left parenthesis, entry 1, 2 right parenthesis.
Line 16, indented twice, list dot Insert, left parenthesis, entry 1, right
parenthesis, semicolon, 2 forward slash, Insert 1 s t entry.
Line 17, indented once, Entry entry 2, left parenthesis, double
quotes, Mary, double quotes comma, double quotes, Beth, double
quotes comma, double quotes, Jones, double quotes comma, 10,
comma, 20 comma, 0, right parenthesis, semicolon, 2 forward slash,
Create 2 n d entry.
Line 18, indented once, if, left parenthesis, exclamation symbol, list
dot Is There, left parenthesis, entry 2, 2 right parenthesis.
Line 19, indented twice, list dot Insert, left parenthesis, entry 2, right
parenthesis, semicolon, 2 forward slash, Insert 2 n d entry.
Line 20, indented once, if, left parenthesis, exclamation symbol, list
dot Is There, left parenthesis, entry 2, 2 right parenthesis.
Line 22, indented twice, list dot Insert, left parenthesis, entry 2, right
parenthesis, semicolon, 2 forward slash, Try insert again.
Line 23, indented once, Name name, left parenthesis, double
quotes, Susy, double quotes comma, double quotes, Nell, double
quotes comma, double quotes, Baxter, double quotes, right
parenthesis, semicolon, 2 forward slash, Create name.
Line 24, indented once, Time of Day, time, left parenthesis, 2
comma, 30 comma, 0, right parenthesis, semicolon, 2 forward slash,
Create time.
Line 25, indented once, Entry entry 3, left parenthesis, name
comma time, right parenthesis, semicolon, 2 forward slash, Test
constructor.
Line 26, indented once, if, left parenthesis, exclamation symbol, list
dot Is There, left parenthesis, entry 3, 2 right parenthesis.
Line 27, indented twice, list dot Insert, left parenthesis, entry 3, right
parenthesis, semicolon, 2 forward slash, Insert 2 r d entry.
Line 28, indented once, list dot Reset List, left parenthesis, right
parenthesis, semicolon, 2 forward slash, Reset position.
Line 29, indented once, while, left parenthesis, list dot Has Next, left
parenthesis, 2 right parenthesis, 2 forward slash, Output list items.
Line 30, indented once, left brace.
Line 31, indented twice, entry 1 equals, list dot Get Next Item, left
parenthesis, right parenthesis, semicolon.
Line 32, indented twice, c out, 2 left angled brackets, entry 1 dot Get

Name S t r, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, entry 1 dot Get Time S t r, left parenthesis, right
parenthesis, 2 left angled brackets, end l, semicolon.
Line 33, indented once, right brace, semicolon
Line 34, blank line.
Line 35, indented once, return 0, semicolon.
Line 36, right brace.
Back to Figure
Line 1: Susy Baxter, 08, colon, 30, colon, 00. 
Line 2: Mary Jones, 10, colon, 30, colon, 00. 
Line 3: Sally Smith, 12, colon, 20, colon, 00.
Back to Figure
The label is displayed at the top center. On the left is a heading
labeled, Entries. Below the heading Entries is a blank text box. On
the right, is the lists of contents which are as follows. Line 1: First
Name, followed by a text box. Line 2: Middle Name, followed by a
text Box. Line 3: Last Name, followed by a text box. Line 4: Time of
Day, followed by time box with up and down arrows. The time 6,
colon, 32, colon, 47, A M is displayed. 2 buttons on the bottom right
corner are labeled as Insert Entry, and Delete Entry.
Back to Figure
The label is displayed at the top center. On the left is a heading
labeled, Entries. Below the heading Entries is a blank text box. On
the right, is the lists of contents which are as follows. Line 1: First
Name, followed by a text box which holds a value Sally. Line 2:
Middle Name, followed by a text Box which holds a value Jane. Line
3: Last Name, followed by a text box which holds a value Smith. Line
4: Time of Day, followed by time box with up and down arrows. The
time 6, colon, 32, colon, 47, A M is displayed. 2 buttons on the
bottom right corner are labeled as Insert Entry, and Delete Entry.
Back to Figure

The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is the text box for Entries. The value is as
follows. Line 1: Sally Smith, hyphen, 06, colon, 32, colon, 47. On the
right, is the lists of contents which are as follows. Line 1: First Name,
followed by a text box. Line 2: Middle Name, followed by a text Box.
Line 3: Last Name, followed by a text box. Line 4: Time of Day,
followed by time box with up and down arrows. The time 6, colon,
49, colon, 52, A M is displayed. 2 buttons on the bottom right corner
are labeled as Insert Entry, and Delete Entry. A Text on the bottom
center reads as, Entry inserted successfully.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: include, class, public,
void.
Line 1, 2 forward slash, followed by asterisks till the end of the line.
Line 2, 2 forward slash, SPICIFICATION FILE, left parenthesis,
Event Header dot h, right parenthesis. 
Line 3, 2 forward slash, This file gives the specification of event
handlers for a G U I dot.
Line 4, 2 forward slash, This is used to define methods that are
called when certain.
Line 5, 2 forward slash, events occur in the G U I.
Line 6, 2 forward slash, 2 forward slash followed by asterisks till the
end of the line.
Line 7, blank line.
Line 8, hashtag include, double quotes, Sorted List dot h, double
quotes.
Line 9, blank line.
Line 10, class Event Handlers, left brace.
Line 11, indented once, public, colon.
Line 12, indented once, Event Handlers, left parenthesis, Sorted List
ampersand entries In it, right parenthesis, semicolon.
Line 13, blank line.
Line 14, indented once, void insert Button Pushed, left parenthesis,
string first Name comma, string middle Name comma, string last
Name comma.

Line 15, indented 13 times, int hours comma, int minutes comma, int
seconds, right parenthesis, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: bool, string, private.
Line 1, indented once, 2 forward slash, Adds a new Entry to the
sorted list when the insert button is pressed.
Line 2, indented once, 2 forward slash, is the G U I.
Line 3, blank line.
Line 4, bool delete Button Pushed, left parenthesis, string first Name
comma, string middle Name comma, string last Name comma.
Line 5, indented 13 times, int hours comma, int minutes comma, int
seconds, right parenthesis, semicolon.
Line 6, indented once, 2 forward slash, Deletes an Entry in the
sorted list whose hours comma minutes comma and seconds.
Line 7, indented once, 2 forward slash, are identical to the Entry dot,
This method returns a Boolean dot. If it.
Line 8, indented once, 2 forward slash, returns true comma, then an
Entry was deleted, semicolon, if it returned false comma.
Line 9, indented once, 2 forward slash, an Entry was not found.
Line 10, blank line.
Line 11, indented once, string fill Text Box, left parenthesis, right
parenthesis.
Line 12, indented once, 2 forward slash, Returns a string
representation of all entries that is used by the G U I.
Line 13, indented once, 2 forward slash, to fill in a text box showing
the list of all entries.
Line 14, blank line.
Line 15, private, colon.
Line 16, indented once, Sorted List ampersand entries, semicolon.
Line 17, right brace, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: include, bool , if.
Line 1, hashtag include, double quotes, Event Handlers dot h,

double quotes.
Line 2, hashtag include, left angled brackets, s stream, right angled
brackets.
Line 3, blank line.
Line 4, Event Handlers, 2 colon symbols, Event Handlers, left
parenthesis, Sorted List ampersand entries In it, right parenthesis,
colon, entries, left parenthesis, entries In it, right parenthesis.
Line 5, left brace, right brace.
Line 6, blank line.
Line 7, void Event Handlers, 2 colon symbols, insert Button Pushed,
left parenthesis, string first Name comma, string middle Name
comma.
Line 8, indented 19 times, string last Name comma, int hours
comma, int minutes comma.
Line 9, indented 19 times, int seconds, right parenthesis.
Line 10, left brace.
Line 11, indented once, Entry entry, left parenthesis, first Name
comma, middle Name, last Name comma, hours comma, minutes
comma, seconds, right parenthesis, semicolon.
Line 12, indented once, entries dot Insert, left parenthesis, entry,
right parenthesis, semicolon.
Line 13, right brace.
Line 14, blank line.
Line 15, bool Event Handlers, 2 colon symbols, delete Button
Pushed, left parenthesis, string first Name comma string middle
Name comma.
Line 16, indented 19 times, string last Name comma, int hours
comma, int minutes comma.
Line 17, indented 19 times, int seconds, right parenthesis.
Line 18, right brace.
Line 19, indented once, Entry entry, left parenthesis, first Name
comma, middle Name comma, last Name comma, hours comma,
minutes comma, seconds, right parenthesis, semicolon.
Line 20, indented once, if, left parenthesis, exclamation mark,
entries dot Is There, left parenthesis, entry, 2 right parenthesis.
Line 21, indented once, left brace.
Back to Figure

Program code. The words used in the variable names are merged.
The program contains the following keywords: return, string, while.
Line 1, indented twice, return false, semicolon.
Line 2, indented once, right brace.
Line 3, blank line.
Line 4, indented once, entries dot Delete, left parenthesis, entry,
right parenthesis, semicolon.
Line 5, indented once, return true, semicolon.
Line 6, right brace.
Line 7, blank line.
Line 8, string Event Handlers, 2 colon symbols, fill Text Box, left
parenthesis, right parenthesis.
Line 9, left brace.
Line 10, indented once, o string stream s t r, semicolon.
Line 11, indented once, entries dot Reset List, left parenthesis, right
parenthesis, semicolon.
Line 12, indented once, while, left parenthesis, entries dot Has Next,
left parenthesis, 2 right parenthesis.
Line 13, indented once, left brace.
Line 14, indented twice, Entry entry equals, entries dot Get Next
item, left parenthesis, right parenthesis, semicolon.
Line 15, indented twice, s t r, 2 left angled brackets, entry dot, Get
Name S t r, left parenthesis, right parenthesis, 2 left angled
brackets, double quotes, hyphen, double quotes, 2 left angled
brackets, entry dot Get Time S t r, left parenthesis, right
parenthesis, 2 left angled brackets, end l, semicolon.
Line 16, indented once, right brace.
Line 17, indented once, return s t r dot s t r, left parenthesis, right
parenthesis, semicolon.
Line 18, right brace.
Back to Figure
Line 1: Event Handlers, colon, colon, Even Handlers, left
parenthesis, Sorted List, ampersand entries Init, right parenthesis,
colon. Line 2: entries, left parenthesis, entries Init, right parenthesis,
left brace, right brace.
Back to Figure

Line 1, Sorted List entries, semicolon.
Line 2, Event Handlers handlers, left parenthesis, entries, right
parenthesis, semicolon.
Line 3, Entries Window, window, left parenthesis, handlers, right
parenthesis, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: include, int, main.
Line 1, hashtag include, left angled bracket, Q Application, right
angled bracket.
Line 2, blank line.
Line 3, hashtag include, double quotes, Entries Window dot h,
double quotes.
Line 4, hashtag include, double quotes, Events Handlers dot h,
double quotes.
Line 5, blank line.
Line 6, int main, left parenthesis, arg c comma, char asterisk arg v,
left square bracket, right square bracket, right parenthesis.
Line 7, left brace.
Line 8, indented once, Q Apllication app, left parenthesis, arg c
comma, arg v right parenthesis, semicolon.
Back to Figure
Program code. The words used in the variable names are merged.
The program contains the following keywords: return.
Line 1, indented once, Sorted List entries, semicolon.
Line 2, indented once, Event Handlers handlers, left parenthesis,
entries, right parenthesis, semicolon.
Line 3, indented once, Entries Window window, left parenthesis,
handlers, right parenthesis, semicolon.
Line 4, window dot show, left parenthesis, right parenthesis,
semicolon.
Line 5, blank line.
Line 6, indented once, return app dot exec, left parenthesis, right
parenthesis, semicolon.
Line 7, right brace.

Back to Figure
The label is displayed at the top center. On the left is a heading
labeled, Entries. Below is the text box for Entries. The value is as
follows. Line 1: Sally Smith, hyphen, 06, colon, 32, colon, 47. On the
right, is the lists of contents which are as follows. Line 1: First Name,
followed by a text box which holds a value John. Line 2: Middle
Name, followed by a text Box which holds a value Eli. Line 3: Last
Name, followed by a text box. Line 4: Time of Day, followed by time
box with up and down arrows. The time 6, colon, 49, colon, 52, A M
is displayed. 2 buttons on the bottom right corner are labeled as
Insert Entry, and Delete Entry. A Text on the bottom center reads as,
The entry has missing information.
Back to Figure
Line 1, float asterisk float P t r, semicolon.
Line 2, blank line.
Line 3, float P t r equals new float, semicolon.
Line 4, asterisk float P t r equals, 38.5, semicolon.
Line 5, float P t r, equals, new float, semicolon.
Back to Figure
Line 1, int asterisk Func, left parenthesis, right parenthesis.
Line 2, left brace.
Line 3, indented once, int n, semicolon.
Line 4, indented once, dot.
Line 5, indented once, dot.
Line 6, indented once, dot.
Line 7, indented once, return ampersand n, semicolon.
Line 8, right brace.
Back to Figure
Line 1, curr P t r, equals head, semicolon.
Line 2, while, left parenthesis, curr P t r, not equal to, NULL, right
parenthesis.
Line 3, left brace.

Line 4, indented twice, c out, 2 let angled brackets, curr P t r,
hyphen, right angled bracket, value, 2 left angled brackets, end l,
semicolon.
Line 5, indented twice, curr equals, curr P t r, hyphen right angled
brackets, link, semicolon.
Line 6, right brace.
Back to Figure
Line 1, int asterisk, needle, semicolon.
Line 2, needle equals new int, semicolon.
Line 3, asterisk needle 100, semicolon.
Line 4, c out, 2 left angled bracket, asterisk needle, semicolon.
Line 5, needle equals, new int, semicolon.
Line 6, asterisk needle equals 32, semicolon.
Line 7, c out, 2 left angled brackets, asterisk needle, semicolon.
Back to Figure
Line 1, int asterisk, bird Dog, semicolon.
Line 2, int asterisk, german Short Hair, semicolon.
Line 3, bird Dog equals new int, semicolon.
Line 4, german Short Hair equals, bird Dog, semicolon.
Line 5, asterisk bird Dog equals, 42, semicolon.
Line 6, c out, 2 left angled brackets, asterisk bird Dog, semicolon.
Line 7, delete bird Dog, semicolon.
Line 8, c out, 2 left angled brackets, asterisk german Short Hair,
semicolon.
Back to Figure
tllde phone Tree, left parenthesis, right parenthesis, semicolon.
Back to Figure
Line 1 labeled a, curr P t r, hyphen, right angled bracket, link.
Line 2 labeled b, curr P t r, hyphen, right angled bracket,
component.
Line 3 labeled c, curr P t r, hyphen, right angled bracket, link,
hyphen, right angled bracket, component.

Line 4 labeled d, curr P t r, hyphen, right angled bracket, link,
hyphen, right angled bracket, link.
Line 5 labeled e, curr P t r, hyphen, right angled bracket, link,
hyphen, right angled bracket, link, hyphen, right angled bracket,
component.
Line 6 labeled f, head, hyphen, right angled bracket, link, hyphen,
right angled bracket, link, hyphen, right angled bracket, link, hyphen,
right angled bracket, component.
Back to Figure
Line 1, type def Node Type asterisk Node P t r, semicolon.
Line 2, struct Node Type.
Line 3, left brace.
Line 4, indented once, Component Type component, semicolon.
Line 5, indented once, Node P t r link, semicolon.
Line 6, right brace, semicolon.
Back to Figure
Line 1, int number, semicolon.
Line 2, int ampersand atlas equals number.
Line 3, number equals 212, semicolon.
Line 4, atlas plus plus, semicolon.
Back to Figure
Line 1, int number, semicolon.
Line 2, int asterisk, weathervane, semicolon.
Line 3, weathervane equals, ampersand number, semicolon.
Line 4, number equals, 180, semicolon.
Line 5, left parenthesis, asterisk weathervane, right parenthesis,
plus plus, semicolon.
Back to Figure
Line 1, int asterisk finger, semicolon.
Line 2, finger equals, ampersand number, semicolon.
Line 3, number equals 2, semicolon.
Line 4, asterisk finger plus plus semicolon.

Back to Figure
Line 1, type def int Component Type, semicolon.
Line 2, blank line.
Line 3, struct Node Type, semicolon.
Line 4, type def, Node Type asterisk, Node P t r, semicolon.
Line 5, blank line.
Line 6, struct Node Type.
Line 7, left brace.
Line 8, indented once, Component Type component, semicolon.
Line 9, indented once, Node P t r link, semicolon.
Line 10, right brace.
Line 11, Node P t r last P t r, semicolon.
Line 12, Node P t r list P t r, semicolon.
Line 13, Node P t r curr P t r, semicolon.
Line 14, Node P t r new Node P t r, semicolon.
Back to Figure
A rectangle labeled p r e v P t r is placed in row 1, top left corner of
the block. The value of p r e v P t r is slash. Another 2 rectangles
labeled c u r r P t r, and last P t r are placed in the next row. The c u
r r P t r is placed below p r e v P t r, and last P t r is placed towards
right side of the block. Another 4 rectangles are placed in the next
row. The first rectangle is labeled as data P t r. The other 3
rectangles in the row are each divided into 2 parts. The values of the
rectangles in the row are as follows: 30, blank, 50, blank, and 90,
slash respectively. A rectangle labeled item is placed below data P t
r. It holds the value 30. An arrow from c u r r P t r points to 30. An
arrow from data P t r points to 30. An arrow from blank part with 30
points to 50. An arrow from blank part with 50 points to 90. An arrow
from last P t r points to 90.
Back to Figure
The contents of the array are as follows. Left square bracket, 0,
right square bracket: Adams. Left square bracket, 1, right square
bracket: Baker. Left square bracket, 2, right square bracket: Carter.
Left square bracket, 3, right square bracket: James. Dot, dot, dot.

Left square bracket, num Items minus 1, right square bracket:
Xavier. The array is physically ordered. The contents of the list are
as follows. An arrow points to Adams. The second arrow points from
Adams to Baker. The third arrow points from Baker to Carter. The
fourth arrow points from Carter to James. The fifth arrow points
from James to the entries following James. The last arrow points to
Xavier. The list is logically ordered.
Back to Figure
The rows of the array are numbered from 0 to 7. The columns of the
array are also numbered from 0 to 7. The entries are as follows. Left
square bracket, 1, right square bracket, Left square bracket, 2, right
square bracket: 2. Left square bracket, 3, right square bracket, left
square bracket, 4, right square bracket: 1. Left square bracket, 5,
right square bracket, left square bracket, 3, right square bracket: 3.
The linked implementation consists of 3 blocks. The block entries
are as follows. Block 1: Row 1, colon, 1. Col, colon, 2. Number,
colon, 2. Block 2: Row, colon, 3. Col, colon, 4. Number, colon, 1.
Block 3: Row, colon, 5. Col, colon, 3. Number, colon, 3. An arrow
points from Block 1 to Block 2. Another arrow points from Block 2 to
Block 3.
Back to Figure
The array is a storage column and it represents the cart number.
The array index ranges from 0 to 9. The indices from 0 to 4 are
filled. The array entries are as follows. Left square bracket, 0, right
square bracket: 3. Left square bracket, 1, right square bracket: 7.
Left square bracket, 2, right square bracket: 2. Left square bracket,
3, right square bracket: 9. Left square bracket, 4, right square
bracket: 5. The sorted list is active and it represents the time
remaining for ach cart number. The entries of the list from the
position marked List dot begin to the position marked List dot end
are as follows: 16, colon, 10; 12, colon, 8; 4, colon, 6; 2, colon, 1; 1,
colon, 4. An arrow from the array element with index 4 to the list is
marked, Cart 5 is now being taken out and will be returned in the
ninth minute. It will thus be inserted between carts 6 and 8 in the
sorted list. Another arrow from the final element of the list to the

element in array index 4 is marked, Cart 4 will return to the end of
the storage column after cart 5 is taken out.
Back to Figure
3 diagrams are shown. In all diagrams, each stack entry has an
element and a pointer to the next element. a. Initial value of stack.
The first diagram shows the initial value of the stack. A pointer
points to the first element of the stack. The first element is 21. A
pointer points from the first element to the second element of the
stack. The second element is 76. A pointer points from the second
element to the third element of the stack. The third element is 2.
The pointer associated with the third element is marked NULL. b. my
stack dot push, left parentheses, 12, right parentheses, pushes a
new element on the stack with a value of 12. The second diagram
shows the contents of the stack after the push operation. A pointer
points to the first element of the stack. The first element is 12. A
pointer points from the first element to the second element of the
stack. The second element is 21. A pointer points from the second
element to the third element of the stack. The third element is 76. A
pointer points from the third element to the fourth element of the
stack. The fourth element is 2. The pointer associated with the
fourth element is marked NULL. c. x equals my Stack dot top, left
parentheses, right parentheses, semicolon, returns an element from
the stack and my Stack dot pop, left parentheses, right parentheses,
semicolon, pops it from the top. The value stored in variable x is 12.
The stack entries are as follows. A pointer points to the first element
of the stack. The value of the first element is 21. A pointer points
from the first to the second element of the stack. The value of the
second element is 76. A pointer points from the second to the third
element of the stack. The value of the third element is 2. The pointer
associated with the third element is marked NULL.
Back to Figure
3 diagrams show insertion and deletion operations on a queue. a. An
empty queue. The elements at queue dot front and queue dot back
are both NULL. b. Insertion into a queue. The queue has 3 elements
which are as follows. Double quotes, Betty, double quotes. Double

quotes, Mary, double quotes. Double quotes, Bill, double quotes.
The first element points to the second element. The second element
points to the third element. Queue dot front points to the first
element. Queue dot back points to the third element. A fourth
element is inserted into the queue. The fourth element is double
quotes, Marret, double quotes. Queue dot back now points to the
fourth element. c. Deletion from a queue. The elements of the
queue are as follows. Double quotes, Mary, double quotes. Double
quotes, Bill, double quotes. Double quotes, Marret, double quotes.
Queue dot front points to double quotes, Mary, double quotes.
Queue dot back points to double quotes, Marret, double quotes.
Name points to double quotes, betty, double quotes.
Back to Figure
The elements are as follows. 27, 21, 19, 16, 9, and 7. Queue Front
points to 27. An arrow is drawn from each element to its previous
element. Insert, left parentheses, 17, right parentheses, inserts 17
between elements 19 and 16.
Back to Figure
The elements of the bidirectional linked list are as follows. David,
Joshua, Leah, Miriam. The front of the list points to David and the
back of the list points to Miriam. Every element between the front
and the back of the list has a link which points to the previous
element and another link which points to the next element.
Back to Figure
The elements of the double ended queue are 12, 47, 8, 35, 92, and
56. The Deque head is 12 and the Deque Tail is 56. Every element
which is between the head and the tail has a link which points to the
previous element and another link which points to the next element.
The operation, pop underscore front, pops off the element in Deque
Head. The operation push underscore front pushes an element into
Deque Head. The operation, push underscore back, pushes an
element into Deque Tail and the operation pop underscore back
pops and element off Deque Tail.

Back to Figure
The table has 2 columns labelled Name and Description. The row
entries are as follows. 
Row 1. Name: deque. Description: A double ended queue. Also has
bidirectional list and array, left parentheses, direct random access
via an index, right parentheses, functionality.
Row 2. Name: list. Description: A bidirectional list with similar
capabilities to deque, but no direct index access.
Row 3. Name: map. Description: Associates a lookup value, left
parentheses, the key, right parentheses, with a value to be looked
up. An example use would be a telephone directory.
Row 4. Name: priority underscore queue. Description: A priority
queue of elements ordered by a key value.
Row 5. Name: queue. Description: A simple F I F O queue of
elements.
Row 6. Name: set. Description: An ordered collection of values that
can be searched. Duplicates are not allowed. Similar in capability to
the sorted list implemented in Chapter 13.
Row 7. Name: stack. Description: A simple L I F O push down stack
of elements.
Row 8. Name: vector. Description: Equivalent to an array, but able to
change its size at runtime.
Row 9. Name: array. Description: A template class version of the C
plus, plus, array that keeps track of the number of filled elements
and provides some additional features.
Back to Table
The declarations are as follows. Line 1: list, left angled bracket,
string, right angled bracket, s t r List, semicolon. 2 forward slashes.
Create an empty list of strings. Line 2: vector, left angled bracket,
int, right angled bracket, int V e c, semicolon. 2 forward slashes.
Create an empty vector of ints.
Back to Figure
The table has 2 columns labelled Name and Description of
Operation. The row entries are as follows. 

Row 1. Name: copy. Description of Operation: Copies a given range
of elements in a container.
Row 2. Name: copy underscore backward. Description of Operation:
Copies a given range of elements in a container in reverse order.
Row 3. Name: equal. Description of Operation: Compares a range of
elements in two containers for equality.
Row 4. Name: find. Description of Operation: Searches a range of
elements in a container for a match with a specified value.
Row 5. Name: max. Description of Operation: Given two elements
comparable with the less than operator returns the greater one.
Row 6. Name: min. Description of Operation: Given two elements
comparable with the less than operator returns the lesser one.
Row 7. Name: shuffle. Description of Operation: Randomly reorders
the elements in a container within a specified range.
Row 8. Name: replace. Description of Operation: Searches a
container over a given range for elements that match a given value,
replacing them with a second given value.
Row 9. Name: search. Description of Operation: Searches a
container within a given range for a series of elements that match a
series from another container. Can be thought of as a generic
equivalent of the string find operation for containers.
Row 10. Name: set underscore difference. Description of Operation:
Given two sets, returns their difference, hyphen, that is, the values
in the first set that are not present in the second set. Can be applied
over specified ranges within each set.
Row 11. Name: set underscore intersection. Description of
Operation: Given two sets, returns their intersection, hyphen, that is,
the values in the first set that are also present in the second set.
Can be applied over specified ranges within each set.
Row 12. Name: set underscore union. Description of Operation:
Given two sets, returns their union, hyphen, that is a set containing
all of the values from both sets, but without duplicates. Can be
applied over specified ranges within each set.
Row 13. Name: sort. Description of Operation: Sorts the elements of
a container within a given range.
Row 14. Name: transform. Description of Operation: Applies a
supplied function to all of the elements of a container within a given
range.

Back to Table
The elements of the list are as follows. Single quote, uppercase I,
single quote. Single quote, uppercase t, single quote. Single quote,
uppercase E, single quote. Single quote, uppercase r, single quote.
Single quote, uppercase a, single quote. Single quote, uppercase t,
single quote. Single quote, uppercase o, single quote. Single quote,
uppercase r, single quote. The element before the first element is
question mark. The element after the last element is a question
mark. List Begin points to single quote, uppercase I, single quote.
List End points to single quote, uppercase r, single quote. r end
points to the question mark before the fist element. end points to the
question mark after the last element. begin points to the first
element. r begin points to the last element. The forward iterator
goes from the beginning to the end of the list when incremented and
from to end to the beginning of the list when decremented. The
reverse iterator goes from the end to the beginning of the list when
incremented and from the beginning to the end of the list when
decremented.
Back to Figure
The declarations are as follows. Line 1: list, left angled bracket,
string, right angled bracket, colon, colon, iterator place, semicolon. 2
forward slashes. Create a forward iterator. Line 2: list, left angled
bracket, string, right angled bracket, colon, colon, reverse
underscore iterator r place, semicolon. 2 forward slashes. Create a
reverse iterator.
Back to Figure
Line 1: vector, left angled bracket, int, right angled bracket, int V e c,
left parentheses, 20, right parentheses, semicolon. 2 forward
slashes. A vector holding 20 integers, comma. Line 2, indented
multiple times: 2 forward slashes. All initialized to 0. Line 3: vector,
left angled bracket, string, right angled bracket, no Size V e c,
semicolon. 2 forward slashes. A vector holding 0 strings.
Back to Figure

Program code. The words used in the variable names are merged.
The code contains the following keywords: include, using, name
space, s t d, const, int, for, c out, end l, do, if, while, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program allows a building owner to
look up how many. 
Line 3: 2 forward slashes. Occupants are in a given apartment. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, left angled bracket, f stream, right angled
bracket, 2 forward slashes. For file I, forward slash O. 
Line 7: hash include, let angled bracket, vector, right angled bracket.
2 forward slashes. For vector template. 
Line 7 is shaded. 
Line 8: blank. 
Line 9: using name space s t d, semicolon. 
Line 10: blank. 
Line 11: const int BUILDING underscore SIZE equals 10, semicolon.
2 forward slashes. Number of apartments. 
Line 12: blank. 
Line 13: int main, left parentheses, right parentheses. 
Line 14: left brace. 
Line 15, indented once: vector, left angled bracket, int, right angled
bracket, occupants, left parentheses, BUILDING underscore SIZE,
right parentheses, semicolon. 2 forward slashes. Occupants, left
square bracket, i, right square bracket, is the number of. 
The statement in line 15 is shaded. 
Line 16, indented multiple times: 2 forward slashes. Occupants in
apartment i. 
Line 17, indented once: int total Occupants, semicolon. 2 forward
slashes. Total number of occupants. 
Line 18, indented once: int counter, semicolon. 2 forward slashes.
Total number of occupants. 
Line 19, indented once: int a p t, semicolon. 2 forward slashes. Loop
control and index variable. 
Line 20, indented once: i f stream in File, semicolon. 2 forward
slashes. File of occupant data, left parentheses, one. 
Line 21, indented multiple times: 2 forward slashes. Integer per

apartment, right parentheses. 
Line 22, indented once: in File dot open, left parentheses, double
quotes, a p t dot dat, double quotes, right parentheses, semicolon. 
Line 23, indented once: total Occupants equals 0, semicolon. 
Line 24, indented once: for, left parentheses, counter equals 0,
semicolon, counter less than BUILDING underscore SIZE,
semicolon, counter, plus, plus, right parentheses. 
Line 25, indented once: left brace. 
Line 26, indented twice: in File, 2 right angled brackets, occupants,
left square bracket, counter, right square bracket, semicolon. 
Line 27, indented twice: total Occupants equals total Occupants plus
occupants, left square bracket, counter, right square bracket,
semicolon. 
Line 28, indented once: right brace. 
Line 29, indented once: c out, 2 left angled brackets, double quotes,
N o, period, of a p t s, period, is, blank space, double quotes, 2 left
angled brackets, BUILDING underscore SIZE, 2 left angled
brackets, end l. 
Line 30, indented multiple times: 2 left angled brackets, double
quotes, Total n o, period, of occupants is, blank space, double
quotes, 2 left angled brackets, total Occupants, 2 left angled
brackets, end l, semicolon. 
Line 31: blank. 
Line 32, indented once: c out, 2 left angled brackets, double quotes,
Begin a p t, period, lookup, ellipsis, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 33, indented once: do. 
Line 34, indented once: left brace. 
Line 35, indented twice: c out, 2 left angled brackets, double quotes,
A p t, period, number, left parentheses, 1 through, blank space,
double quotes, 2 left angled brackets, BUILDING underscore SIZE. 
Line 36, indented multiple times: 2 left angled brackets, double
quotes, comma, or 0 to quit, right parentheses, colon, double
quotes, semicolon. 
Line 37, indented twice: c in, 2 right angled brackets, a p t,
semicolon. 
Line 28, indented twice: if, left parentheses, a p t greater than 0,
right parentheses. 
Line 29, indented thrice: c out, 2 left angled brackets, double quotes,

A p t, period, blank space, double quotes, 2 left angled brackets, a p
t, 2 left angled brackets, double quotes, blank space, has, blank
space, double quotes, 2 left angled brackets, occupants, left square
bracket, a p t minus 1, right square bracket. 
Line 30, indented multiple times: 2 left angled brackets, double
quotes, blank space, occupants, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 31, indented once: right brace, while, left parentheses, a p t
greater than 0, right parentheses, semicolon. 
Line 32, indented once: return 0, semicolon. 
Line 33: right brace.
Back to Figure
c out, 2 left angled brackets, double quotes, N o, period, of a p t s,
period, is, double quotes, 2 left angled brackets, occupants dot size,
left parentheses, right parentheses, 2 left angled brackets, end l.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: include, using, name
space, s t d, int, main, vector, i f stream, while, do, if, c in, c out, end
l, try, catch, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program allows a building owner to
look up how many. 
Line 3: 2 forward slashes. Occupants are in a given apartment. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 2 forward slashes. For file I forward slash O. 
Line 7: hash include, left angled bracket, vector, right angled
bracket. 2 forward slashes. For out underscore of underscore range
exception. 
Line 7 is shaded. 
Line 8: using name space s t d, semicolon. 
Line 9: blank. 

Line 10: int main, left parentheses, right parentheses. 
Line 11: left brace. 
Line 12, indented once: vector, left angled bracket, int, right angled
bracket, occupants, semicolon. 2 forward slashes. Occupants vector
with 0 elements. 
Line 12 is shaded. 
Line 13, indented once: int total Occupants, semicolon. 2 forward
slashes. Total number of occupants. 
Line 14, indented once: int a p t, semicolon. 2 forward slashes. An
apartment number. 
Line 15, indented once: int a p t Occupants, semicolon. 2 forward
slashes. Occupants in one apartment. 
Line 15 is shaded. 
Line 16, indented once: i f stream in File, semicolon. 2 forward
slashes. File of occupant data, left parentheses, one. 
Line 17, indented multiple times: 2 forward slashes. Integer per
apartment, right parentheses. 
Line 18, indented once: in File dot open, left parentheses, double
quotes, a p t dot d a t, double quotes, right parentheses, semicolon. 
Line 19, indented once: total Occupants equals 0, semicolon. 
Line 20, indented once: in File, 2 right angled brackets, a p t
Occupants, semicolon. 
Line 21, indented once: while, left parentheses, in File, right
parentheses. 
Lines 20 and 21 are shaded. 
Line 22, indented once: left brace. 
Line 23, indented twice: occupants dot push underscore back, left
parentheses, a p t Occupants, right parentheses, semicolon. 
Line 23 is shaded. 
Line 24, indented twice: total Occupants equals total Occupants plus
a p t Occupants, semicolon. 
In Line 24, the variable name, a p t Occupants is shaded. 
Line 25, indented twice: in File, 2 right angled brackets, a p t
Occupants, semicolon. 
In line 25, the variable name, a p t Occupants is shaded. 
Line 26, indented once: right brace. 
Line 27, indented once: c out, 2 left angled brackets, double quotes,
N o, dot, of a p t s, dot, is, blank space, double quotes, 2 left angled
brackets, occupants dot size, left parentheses, right parentheses, 2

left angled brackets, end l. 
In line 27, the function call, occupants dot size, left parentheses,
right parentheses, is shaded. 
Line 28, indented multiple times: 2 left angled brackets, double
quotes, Total n o, dot, of occupants is, blank space, double quotes,
2 left angled brackets, total Occupants, 2 left angled brackets, end l,
semicolon. 
Line 29: blank. 
Line 30, indented once: c out, 2 left angled brackets, double quotes,
Begin a p t, dot, lookup, ellipsis, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 31: do. 
Line 32, indented once: left brace. 
Line 33, indented twice: c out, 2 left angled brackets, double quotes,
A p t, dot, number, left parentheses, 1 through, blank space, double
quotes, 2 left angled brackets, occupants dot size, left parentheses,
right parentheses. 
In line 33, the function call, occupants dot size, left parentheses,
right parentheses, is shaded. 
Line 34, indented multiple times: 2 left angled brackets, double
quotes, comma, or 0 to quit, right parentheses, colon, blank space,
double quotes, semicolon. 
Line 35, indented once: c in, 2 right angled brackets, a p t,
semicolon. 
Line 36, indented once: if, left parentheses, a p t, greater than, 0,
right parentheses. 
Line 37, indented twice: try. 
Line 38, indented twice: left brace. 
In line 37, the keyword try is shaded. In line 38, the left brace is
shaded. 
Line 39, indented thrice: c out, 2 left angled brackets, double quotes,
A p t, dot, blank space, double quotes, 2 left angled brackets, a p t,
2 left angled brackets, double quotes, blank space, has, blank
space, double quotes, 2 left angled brackets, occupants dot at, left
parentheses, a p t minus 1, right parentheses. 
Line 40, indented multiple times: 2 left angled brackets, double
quotes, blank space, occupants, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 41, indented twice: right brace. 

In line 41, the right brace is shaded. 
Line 42, indented thrice: catch, left parentheses, out underscore of
underscore range, right parentheses. 
In line 42, the function call, catch, left parentheses, out underscore,
of, underscore, range, right parentheses, is shaded. 
Line 43, indented twice: left brace. 
Line 44, indented thrice: c out, 2 left angled brackets, double quotes,
Invalid apartment number, dot, Enter, blank space, double quotes,
semicolon. 
Line 45, indented twice: right brace. 
Lines 43, 44, and 45 are shaded. 
Line 46, indented once: right brace, while, left parentheses, a p t
greater than 0, right parentheses, semicolon. 
Line 47, indented once: return 0, semicolon. 
Line 48: right brace.
Back to Figure
Line 1: 3, blank space, 4, blank space, 0, blank space, 3, blank
space, 4, blank space, 1, blank space, 1, blank space, 2, blank
space, 3, blank space, 2, blank space, 1, blank space, 4, blank
space, 2, blank space, 3, blank space, 0, blank space, 5, blank
space, 2, blank space, 3.
Back to Figure
Line 1: N o, dot, of a p t s, dot, is, 18. Line 2: Total n o, dot, of
occupants is 43. Line 3: Begin a p t, dot, lookup, ellipsis. Line 4: A p
t, dot, number, left parentheses, 1 through 18, comma, or 0 to quit,
right parentheses, colon, 4. In line 4, the number 4 is shaded. Line
5: A p t, dot, 4 has 3 occupants. Line 6: A p t, dot, number, left
parentheses, 1 through 18, comma, or 0 to quit, right parentheses,
colon, 14. In line 6, the number 14 is shaded. Line 7: A p t, dot, 14
has 3 occupants. Line 8: A p t dot number, left parentheses, 1
through 18, comma, or 0 to quit, right parentheses, colon, 18. In line
8, the number 18 is shaded. Line 9: A p t, dot, 18 has 3 occupants.
Line 10: A p t dot number, left parentheses, 1 through 18, comma,
or 0 to quit, right parentheses, colon, 19. In line 10, the number 19
is shaded. Line 11: Invalid apartment number. Enter A p t, dot,

number, left parentheses, 1 through 18, comma, or 0 to quit, right
parentheses, colon, 15. In line 11, the number 15 is shaded. Line 12:
A p t, dot, 15 has 0 occupants. Line 13: A p t, dot, number, left
parentheses, 1 through 18, comma, or 0 to quit, right parentheses,
colon, 0. In line 13, the number 0 is shaded.
Back to Figure
The row entries are as follows. 
Row 1. Name: at. Parameters: int. Returns: reference. Description:
Returns a reference to the value at the specified location, checking
the range. 
Row 2. Name: back. Parameters: blank. Returns: reference.
Description: Returns a reference to the last element.
Row 3. Name: begin. Parameters: blank. Returns: iterator.
Description: Returns an iterator to the first element.
Row 4. Name: capacity. Parameters: blank. Returns: int.
Description: Returns the number of elements that can be held.
Row 5. Name: clear. Parameters: blank. Returns: blank. Description:
Removes all elements. Sets size to 0.
Row 6. Name: empty. Parameters: blank. Returns: bool. Description:
Returns true if there are no elements in the vector.
Row 7. Name: end. Parameters: blank. Returns: iterator.
Description: Returns an iterator beyond the end of the vector.
Row 8. Name: erase. Parameters: iterator. Returns: blank.
Description: Removes the element at the iterator position. The size
decreases.
Row 9. Name: front. Parameters: blank. Returns: reference.
Description: Returns a reference to the first element.
Row 10. Name: insert. Parameters: iterator, comma, value. Returns:
blank. Description: Inserts the value at the location specified by the
iterator. The size increases.
Row 11. Name: push, underscore, back. Parameters: value.
Returns: blank. Description: Inserts the value at the end of the
vector. The size increases.
Row 12. Name: r begin. Parameters: blank. Returns: reverse,
underscore, iterator. Description: Returns a reverse iterator to the
last element.
Row 13. Name: r end. Parameters: blank. Returns: reverse,

underscore, iterator. Description: Returns a reverse iterator before
the start of the vector.
Row 14. Name: reserve. Parameters: int. Returns: blank.
Description: Indicates that the capacity of the vector should increase
to the amount specified.
Row 15. Name: size. Parameters: blank. Returns: int. Description:
Returns the number of elements in the vector.
Back to Table
The elements of the vector are as follows. Left square bracket, 0,
right square bracket: single quote, uppercase v, single quote. Left
square bracket, 1, right square bracket: single quote, uppercase e,
single quote. Left square bracket, 2, right square bracket: single
quote, uppercase c, single quote. Left square bracket, 3, right
square bracket: single quote, uppercase t, single quote. Left square
bracket, 4, right square bracket: single quote, uppercase o, single
quote. Left square bracket, 5, right square bracket: single quote,
uppercase r, single quote. left square bracket, 6, right square
bracket: blank. Left square bracket, 7, right square bracket: blank.
Left square bracket, 8, right square bracket: blank. Left square
bracket, 9, right square bracket: blank. The size of the array is 6 and
the capacity is 10.
Back to Figure
Line 1: int o c c Data, left square bracket, right square bracket,
equals, left brace, 3, comma, 4, comma, 0, comma, 3, comma, 4,
comma, 1, comma, 1, comma, 2, comma, 3, comma, 2, comma, 1,
comma, 4, comma, 2, comma, 3, comma, 0, comma, 5, comma, 2,
comma, 3, right brace, semicolon.
Back to Figure
o c c Data plus size of, left parentheses, o c c Data, right
parentheses, forward slash, size of, left parentheses, int, right
parentheses.
Back to Figure

Line 1: array, left angled bracket, int, comma, 10, right angled
bracket, int A r r equals, left brace, 10, comma, 9, comma, 8,
comma, 7, comma, 6, comma, 5, comma, 4, comma, 3, comma, 2,
comma, 1, right brace, semicolon. 2 forward slashes. An array
holding 10 integers, comma. Line 2, indented multiple times: 2
forward slashes. initialized to 10 through 0.
Back to Figure
Line 1: int A r r, left square bracket, 3, right square bracket, equals,
17, semicolon. 2 forward slashes. Set 4 t h element to 17. Line 2: int
value equals int A r r, left square bracket, 3, right square bracket,
semicolon. 2 forward slashes. Set value to 17.
Back to Figure
array, left angled bracket, int, comma, 10, right angled bracket, int A
r r equals, left brace, 10, comma, 9, comma, 8, comma, 7, comma,
6, right brace, semicolon.
Back to Figure
c out, 2 left angled brackets, int A r r dot size, left parentheses, right
parentheses, semicolon. 2 forward slashes. Outputs 5.
Back to Figure
c out, 2 left angled brackets, int A r r dot max, underscore, size, left
parentheses, right parentheses, semicolon. 2 forward slashes.
Outputs 10.
Back to Figure
Line 1: array, left angled bracket, int, comma, 5, right angled
bracket, first A r r equals, left brace, 1, comma, 2, comma, 3,
comma, 4, comma, 5, right brace, semicolon. Line 2: array, left
angled bracket, int, comma, 5, right angled bracket, second A r r,
semicolon. Line 3: second A r r equals first A r r, semicolon. 2
forward slashes. second A r r now contains 1, comma, 2, comma, 3,
comma, 4, comma, 5. Line 4: second A r r, left square bracket, 2,

right square bracket, equals 10, semicolon. 2 forward slashes.
second A r r now contains 1, comma, 2, comma, 10, comma, 4,
comma, 5. Line 5: if, left parentheses, second A r r, greater than,
first A r r, right parentheses. 2 forward slashes. Third element of
second A r r is greater than third element of first A r r. Line 6,
indented once: c out, 2 left angled brackets, double quotes, Greater,
double quotes, semicolon. 2 forward slashes. so, double quotes,
Greater, double quotes, is output.
Back to Figure
The table has 3 columns labelled Name, Parameters, and
Description. The row entries are as follows. 
Row 1. Name: merge. Parameters: list. Description: Inserts the
elements of the parameters list into the current list, in order. The
elements are deleted from the parameter list. If the lists were
already sorted, the result is a sorted list containing both sets of
elements. 
Row 2. Name: pop, underscore, back. Parameters: blank.
Description: Removes the last element.
Row 3. Name: pop, underscore, front. Parameters: blank.
Description: Removes the first element.
Back to Table
The table has 3 columns labelled Name, Parameters, and
Description. The row entries are as follows. 
Row 1. Name: push, underscore, front. Parameters: value.
Description: Inserts the value as the first element. 
Row 2. Name: remove. Parameters: value. Description: Removes all
elements with the specified value.
Row 3. Name: reverse. Parameters: blank. Description: Reverses
the order of the elements in the list.
Row 4. Name: sort. Parameters: blank. Description: Sorts the
elements from least to greatest. 
Row 5. Name: unique. Parameters: blank. Description: Removes all
but the first element in any group of adjacent elements with the
same value. If the list is sorted, the result is that it contains only
unique values.

Back to Table
Program code. The words in the variable names are merged. The
code contains the following keywords: include, using, name space, s
t d, int, main, list, string, c out, end l, for, c in.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates various list
methods. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, left angled bracket, list, right angled bracket. 
Line 6: using name space s t d, semicolon. 
Line 7: blank. 
Line 8: int main, left parentheses, right parentheses. 
Line 9: left brace. 
Line 10, indented once: list, left angled bracket, string, right angled
bracket, demo, semicolon. 2 forward slashes. Create an empty list. 
Line 11, indented once: string word, semicolon. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Enter a line with six words, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 13, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 6, semicolon, i plus, plus, right
parentheses. 
Line 14, indented once: left brace. 
Line 15, indented twice: c in, 2 right angled brackets, word,
semicolon. 
Line 16, indented twice: demo dot push underscore back, left
parentheses, word, right parentheses, semicolon. 2 forward slashes.
Insert elements at back. 
Line 17, indented once: right brace. 
Line 18, indented once: 2 forward slashes. Access front, comma,
back, comma, and size. 
Line 19, indented once: c out, 2 left angled brackets, double quotes,
Front element, colon, blank space, double quotes, 2 left angled
brackets, demo dot front, left parentheses, right parentheses, 2 left
angled brackets, end l. 
Line 20, indented multiple times: 2 left angled brackets, double

quotes, Back element, colon, blank space, double quotes, 2 left
angled brackets, demo dot back, left parentheses, right
parentheses, 2 left angled brackets, end l. 
Line 21, indented multiple times: 2 left angled brackets, double
quotes, size of list, colon, blank space, double quotes, 2 left angled
brackets, demo dot size, left parentheses, right parentheses, 2 left
angled brackets, end l, semicolon. 
Line 22, indented once: 2 forward slashes. Create a forward iterator.
Line 23, indented once: list, left angled bracket, string, right angled
bracket, colon, colon, iterator place, semicolon. 
Line 24, indented once: c out, 2 left angled brackets, double quotes,
List contents from beginning to end, colon, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 25, indented once: 2 forward slashes. Traverse list in forward
direction. 
Line 26, indented once: for, left parentheses, place equals demo dot
begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals, demo dot end, left parentheses, right
parentheses, semicolon, place, plus, plus, right parentheses. 
Line 27, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 28, indented once: 2 forward slashes. Create a reverse iterator.
Line 29, indented once: list, left angled bracket, string, right angled
bracket, colon, colon, reverse, underscore, iterator r place,
semicolon. 
Back to Figure
Program code. The code contains the following keywords: c out, end
l, for, c in, string, list, return. 
Line 1, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, List contents from end to beginning,
colon, blank space, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 2, indented once: 2 forward slashes. Traverse list in backward
direction. 
Line 3, indented once: for, left parentheses, r place equals demo dot
r begin, left parentheses, right parentheses, semicolon, r place,

exclamation mark, equals sign, demo dot r end, left parentheses,
right parentheses, semicolon, plus, plus, r place, right parentheses. 
Line 4, indented twice: c out, 2 left angled brackets, asterisk, r
place, 2 left angled brackets, double quotes, blank space, double
quotes, semicolon. 
Line 5, indented once: c in, 2 right angled brackets, word,
semicolon. 
Line 6, indented once: place equals demo dot begin, left
parentheses, right parentheses, semicolon. 2 forward slashes. Point
forward iterator to front. 
Line 7, indented once: plus, plus, place, semicolon. 2 forward
slashes. Advance once place. 
Line 8, indented once: demo dot insert, left parentheses, place,
comma, word, right parentheses, semicolon. 2 forward slashes.
Insert an element. 
Line 9, indented once: place equals demo dot end, left parentheses,
right parentheses, semicolon. 2 forward slashes. Point forward
iterator past end. 
Line 10, indented once: minus, minus, place, semicolon. 2 forward
slashes. Move back to last element. 
Line 11, indented once: minus, minus, place, semicolon. 2 forward
slashes. Move back once more place. 
Line 12, indented once: demo dot erase, left parentheses, place,
right parentheses, semicolon. 2 forward slashes. Delete element. 
Line 13, indented once: c out, 2 left angled brackets, double quotes,
Next to last word has been erased, dot, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter a word to add at the front, colon, blank space, double quotes,
semicolon. 
Line 15, indented once: c in, 2 right angled brackets, word,
semicolon. 
Line 16, indented once: demo dot push underscore front, left
parentheses, word, right parentheses, semicolon. 2 forward slashes.
Insert at front. 
Line 17, indented once: c out, 2 left angled brackets, double quotes,
List contents from beginning to end, colon, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 18, indented once: for, left parentheses, place equals demo dot

begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, demo dot end, left parentheses, right
parentheses, semicolon, plus, plus, place, right parentheses. 
Line 19, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 20, indented once: demo dot sort, left parentheses, right
parentheses, semicolon. 2 forward slashes. Sort the elements. 
Line 21, indented once: c out, 2 left angled brackets, end l. 
Line 22, indented multiple times: 2 left angled brackets, double
quotes, After sorting, comma, list contents from beginning to end,
colon, blank space, double quotes. 
Line 23, indented multiple times: 2 left angled brackets, end l,
semicolon. 
Line 24, indented once: for, left parentheses, place equals demo dot
begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, demo dot end, left parentheses, right
parentheses, semicolon, plus, plus, place, right parentheses. 
Line 25, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 26, indented once: 2 forward slashes. Create a three element
list from an array of strings. 
Line 27, indented once: string init, left square bracket, right square
bracket, equals, left brace, double quotes, large, double quotes,
comma, double quotes, medium, double quotes, comma, double
quotes, small, double quotes, right brace, semicolon. 
Line 28, indented once: list, left angled bracket, string, right angled
bracket, demo 2, left parentheses, init, comma, init plus size of, left
parentheses, init, right parentheses, forward slash, size of, left
parentheses, string, right parentheses, right parentheses,
semicolon. 
Line 29, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, After merging with, colon, blank
space, double quotes, semicolon. 
Line 30, indented once: for, left parentheses, place equals demo 2
dot begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, demo 2 dot end, left parentheses,
right parentheses, semicolon, plus, plus, place, right parentheses. 

Line 31, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 32, indented once: demo dot merge, left parentheses, demo 2,
right parentheses, semicolon. 2 forward slashes. Merge the two
lists. 
Line 33, indented once: c out, 2 let angled brackets, end l, 2 left
angled brackets, double quotes, List contents are, colon, blank
space, double quotes, 2 left angled brackets, end l, semicolon. 
Line 34, indented once: for, left parentheses, place equals demo dot
begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, demo dot end, left parentheses, right
parentheses, semicolon, plus, plus, place, right parentheses. 
Line 35, indented twice: c out, 2 left angled brackets, asterisk, place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 36, indented twice: return 0, semicolon. 
Line 37: right brace.
Back to Figure
Line 1: Enter a line with six words, colon. Line 2: quick fox jumped
over lazy dog. Line 2 is shaded. Line 3: Front element, colon, quick.
Line 4: Back element, colon, dog. Line 5: Size of list, colon, 6. Line
6: List contents from beginning to end, colon.
Back to Figure
Line 7: quick fox jumped over lazy dog. Line 8: List contents from
end to begining, colon. Line 9: dog lazy over jumped fox quick. Line
10: Enter a word to insert after the first word, colon, brown. In line
10, the word brown is shaded. Line 11: Next to last word has been
erased. Line 12: Enter a word to add at the front, colon, the. In line
12, the word the is shaded. Line 13: List contents from begining to
end, colon. Line 14: the quick brown fox jumped over dog. Line 14:
After sorting, comma, list contents from begining to end, colon. Line
15: brown dog fox jumped over quick the. Line 16: After merging
with, colon, large medium small. Line 17: List contents are, colon.
Line 18: brown dog fox jumped large medium over quick small the.

Back to Figure
The table has 4 columns labelled Name, Parameters, Returns, and
Description. The row entries are as follows. 
Row 1. Name: empty. Parameters: blank. Returns: bool. Description:
Returns true if there are no elements in the stack. 
Row 2. Name: top. Parameters: blank. Returns: reference.
Description: Returns a reference to the value of the top element.
Row 3. Name: push. Parameters: value. Returns: blank. Description:
Inserts the value as the top element.
Row 4. Name: pop. Parameters: blank. Returns: blank. Description:
Removes the top element.
Row 5. Name: size. Parameters: blank. Returns: int. Description:
Returns the number of elements in the stack. 
Row 6. Name: swap. Parameters: stack. Returns: stack.
Description: Swaps the contents of this stack with another stack.
Row 7. Name: emplace. Parameters: value, left parentheses, s,
right parentheses. Returns: blank. Description: Takes the
parameters for the constructor of the element type and builds a new
object to push onto the stack.
Back to Table
Line 1: stack, left angled bracket, float, right angled bracket, f l t
Stack, semicolon. 2 forward slashes. Create an empty stack of
floats. Line 2: stack, left angled bracket, string, right angled bracket,
s t r Stack, left parentheses, demo, right parentheses, semicolon. 2
forward slashes. Create string stack from list demo.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include, i o
stream, stack, using, name space, s t d, int, main, string, c out, end
l, for, int, c in, while, return. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates various stack
methods. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.

Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, left angled bracket, stack, right angled bracket.
Line 6: blank. 
Line 7: int main, left parentheses, right parentheses. 
Line 8: left brace. 
Line 9, indented once: stack, left angled bracket, string, right angled
bracket, s t r Stack, semicolon. 2 forward slashes. Create an empty
stack. 
Line 10, indented once: string word, semicolon. 
Line 11, indented once: c out, 2 left angled brackets, double quotes,
Enter a line with six words, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 12, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 6, semicolon, i, plus, plus, right
parentheses. 
Line 13, indented once: left brace. 
Line 14, indented twice: c in, 2 right angled brackets, word,
semicolon. 
Line 15, indented twice: s t r Stack dot push, left parentheses, word,
right parentheses, semicolon. 2 forward slashes. Insert elements at
top. 
Line 16, indented once: right brace. 
Line 17, indented once: 2 forward slashes. Access top and size. 
Line 18, indented once: c out, 2 left angled brackets, double quotes,
Top element, colon, blank space, double quotes, 2 left angled
brackets, s t r Stack dot top, left parentheses, right parentheses, 2
left angled brackets, end l. 
Line 19, indented multiple times: 2 left angled brackets, double
quotes, Size of stack, colon, blank space, double quotes, 2 left
angled brackets, s t r Stack dot size, left parentheses, right
parentheses, 2 left angled brackets, semicolon. 
Line 20, indented once: 2 forward slashes. Output the stack. 
Line 21, indented once: c out, 2 left angled brackets, double quotes,
Stack contents, colon, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 22, indented once: while, left parentheses, exclamation mark, s
t r Stack dot empty, left parentheses, right parentheses, right
parentheses. 

Line 23, indented once: left brace. 
Line 24, indented twice: c out, 2 left angled brackets, s t r Stack dot
top, left parentheses, right parentheses, 2 left angled brackets, end
l, semicolon. 
Line 25, indented twice: s t r Stack dot pop, left parentheses, right
parentheses, semicolon. 2 forward slashes. Remove elements from
top. 
Line 26, indented once: right brace. 
Line 27, indented once: return 0, semicolon. 
Line 28: right brace.
Back to Figure
Line 1: Enter a line with six words, colon. Line 2: four score and
seven years ago. Line 2 is shaded. Line 3: Top element, colon, ago.
Line 4: Size of stack, colon, 6. Line 5: Stack contents, colon. Line 6:
ago. Line 7: years. Line 8: seven. Line 9: and. Line 10: score. Line
11: four.
Back to Figure
The table has 4 columns labelled Name, Parameters, Returns, and
Description. The row entries are as follows. 
Row 1. Name: empty. Parameters: blank. Returns: bool. Description:
Returns true if there are no elements in the queue. 
Row 2. Name: front. Parameters: blank. Returns: reference.
Description: Returns a reference to the value of the front element.
Row 3. Name: back. Parameters: blank. Returns: reference.
Description: Returns a reference to the value of the back element.
Row 4. Name: push. Parameters: value. Returns: blank. Description:
Inserts the value as the back element.
Row 5. Name: pop. Parameters: blank. Returns: blank. Description:
Removes the front element.
Row 6. Name: size. Parameters: blank. Returns: int. Description:
Returns the number of elements in the queue.
Row 7. Name: swap. Parameters: queue. Returns: queue.
Description: Swaps the contents of this queue with another queue.
Row 8. Name: emplace. Parameters: value, left parentheses, s,
right parentheses. Returns: blank. Description: Takes the

parameters for the constructor of the element type and builds a new
object to push onto the queue.
Back to Table
Program code. The code contains the following keywords: include,
using, name space, s t d. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates various
queue methods. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, left angled bracket, queue, right angled
bracket. 
Line 6: using name space s t d, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: int, main, queue, string, c out,
end l, for, c in, while, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: queue, left angled bracket, string, right
angled bracket, s t r Queue, semicolon. 2 forward slashes. Create
an empty queue. 
Line 4, indented once: string word, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Enter a line with six words, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 6, semicolon, i, plus, plus, right
parentheses. 
Line 7, indented once: left brace. 
Line 8, indented twice: c in, 2 forward slashes, word, semicolon. 
Line 9, indented twice: s t r Queue dot push, left parentheses, word,
right parentheses, semicolon. 2 forward slashes. Insert elements at
back. 

Line 10, indented once: right brace. 
Line 11, indented once: 2 forward slashes. Access front, comma,
back, comma, and size. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Front element, colon, blank space, double quotes, 2 left angled
brackets, s t r Queue dot front, left parentheses, right parentheses,
2 left angled brackets, end l. 
Line 13, indented multiple times: 2 left angled brackets, double
quotes, Back element, colon, blank space, double quotes, 2 left
angled brackets, s t r Queue dot back, left parentheses, right
parentheses, 2 left angled brackets, end l. 
Line 14, indented multiple times: 2 left angled brackets, double
quotes, Size of queue, colon, blank space, double quotes, 2 left
angled brackets, s t r Queue dot size, left parentheses, right
parentheses, 2 left angled brackets, end l, semicolon. 
Line 15, indented once: Output the queue. 
Line 16, indented once: c out, 2 left angled brackets, double quotes,
Queue contents, colon, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 17, indented once: while, left parentheses, exclamation mark, s
t r Queue dot empty, left parentheses, right parentheses, right
parentheses. 
Line 18, indented once: left brace. 
Line 19, indented twice: c out, 2 left angled brackets, s t r Queue dot
front, left parentheses, right parentheses, 2 left angled brackets,
end l, semicolon. 
Line 20, indented twice: s t r Queue dot pop, left parentheses, right
parentheses, semicolon. 2 forward slashes. Remove elements from
front. 
Line 21, indented once: right brace. 
Line 22, indented once: return 0, semicolon. 
Line 23: right brace.
Back to Figure
Line 1: Enter a line with six words, colon. Line 2: four score and
seven years ago. Line 2 is shaded. Line 3: Front element, colon,
four. Line 4: Back element, colon, ago. Line 5: Size of queue, colon,

6. Line 6: Queue contents, colon. Line 7: four. Line 8: score. Line 9:
and. Line 10: seven. Line 11: years. Line 12: ago.
Back to Figure
The table has 4 columns labelled Name, Parameters, Returns, and
Description. The row entries are as follows. 
Row 1. Name: empty. Parameters: blank. Returns: bool. Description:
Returns true if the priority queue contains no elements. 
Row 2. Name: top. Parameters: blank. Returns: reference.
Description: Returns a reference to the value of the top element.
Row 3. Name: push. Parameters: value. Returns: blank. Description:
Inserts the value according to the ordering of the type.
Row 4. Name: pop. Parameters: blank. Returns: blank. Description:
Removes the top element.
Row 5. Name: size. Parameters: blank. Returns: int. Description:
Returns the number of elements in the priority queue.
Row 6. Name: swap. Parameters: priority, underscore, queue.
Returns: priority, underscore, queue. Description: Swaps the
contents of this priority, underscore, queue with another priority,
underscore, queue.
Row 7. Name: emplace. Parameters: value, left parentheses, s,
right parentheses. Returns: blank. Description: Takes the
parameters for the constructor of the element type and builds a new
object to push onto the priority queue.
Back to Table
Program code. The code contains the following keywords: include,
using, name space, s t d, i o stream, queue. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates various
priority underscore queue methods. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket.
Line 5: hash include, left angled bracket, queue, right angled
bracket. 
Line 6: using name space s t d, semicolon.

Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: int, main, string, c out, end l,
for, c in, while, return. 
Line 1: int main, left parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: priority underscore queue, left angled
bracket, string, right angled bracket, s t r Queue, semicolon. 2
forward slashes. Create an empty priority underscore queue. 
Line 4, indented once: string word, semicolon. 
Line 5, indented once: c out, 2 left angled brackets, double quotes,
Enter a line with six words, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 6, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 6, semicolon, i plus, plus, right
parentheses. 
Line 7, indented once: left brace. 
Line 8, indented twice: c in, 2 right angled brackets, word,
semicolon. 
Line 9, indented twice: s t r Queue dot push, left parentheses, word,
right parentheses, semicolon. 2 forward slashes. Insert elements in
place. 
Line 10, indented once: right brace. 
Line 11, indented once: 2 forward slashes. Access top and size. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
Top element, colon, blank space, double quotes, 2 left angled
brackets, s t r Queue dot top, left parentheses, right parentheses, 2
left angled brackets, end l. 
Line 13, indented multiple times: 2 left angled brackets, double
quotes, Size of priority underscore queue, colon, blank space,
double quotes, 2 left angled brackets, s t r Queue dot size, left
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 14, indented once: 2 forward slashes. Access top and size. 
Line 15, indented once: c out, 2 left angled brackets, double quotes,
Top element, colon, blank space, double quotes, 2 left angled
brackets, s t r Queue dot top, left parentheses, right parentheses, 2
left angled brackets, end l. 

Line 16, indented multiple times: 2 left angled brackets, double
quotes, Size of priority underscore queue, colon, blank space,
double quotes, 2 left angled brackets, s t r Queue dot size, left
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon. 
Line 17, indented once: 2 forward slashes. Output the priority
underscore queue. 
Line 18, indented once: c out, 2 left angled brackets, double quotes,
Priority queue contents, colon, double quotes, 2 left angled brackets,
end l, semicolon. 
Line 19, indented once: while, left parentheses, exclamation mark, s
t r Queue dot empty, left parentheses, right parentheses, right
parentheses. 
Line 20, indented once: left brace. 
Line 21, indented twice: c out, 2 left angled brackets, s t r Queue dot
top, left parentheses, right parentheses, 2 left angled brackets, end
l, semicolon. 
Line 22, indented twice: s t r Queue, dot, pop, left parentheses, right
parentheses, semicolon. 2 forward slashes. Remove elements from
top. 
Line 23, indented once: right brace. 
Line 24, indented once: return 0, semicolon. 
Line 25: right brace.
Back to Figure
Line 1: Enter a line with six words, colon. Line 2: four score and
seven years ago. Line 2 is shaded. Line 3: Top element, colon,
years. Line 4: Size of priority underscore queue, colon, 6. Line 5:
Priority queue contents, colon. Line 6: years. Line 7: seven. Line 8:
score. Line 9: four. Line 10: and. Line 11: ago.
Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords: include, class, public, bool,
private, const. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for class Entry With

Date. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Date dot h, double quotes. 
Line 5: hash include, double quotes, Entry dot h, double quotes. 
Line 6: class Entry With Date, colon, public Entry. 
Line 7: left brace. 
Line 8: public, colon. 
Line 9, indented once: 2 forward slashes. Constructors. 
Line 10, indented once: Entry With Date, left parentheses, right
parentheses, semicolon. 
Line 11, indented once: Entry With Date, left parentheses, Date init
Date, comma, Time Of Day init Time, comma, Name init Name, right
parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Knowledge responsibility. 
Line 13, indented once: Date Get Date, left parentheses, right
parentheses, const, semicolon. 
Line 14, indented once: bool operator, left angled bracket, left
parentheses, const Entry With Date ampersand other Entry, right
parentheses, const, semicolon. 
Line 15, indented once: 2 forward slashes. Post, colon, Returns true
if instance comes before other Entry. 
Line 16, indented once: bool operator, right angled bracket, left
parentheses, const Entry With Date ampersand other Entry, right
parentheses, const, semicolon. 
Line 17, indented once: 2 forward slashes. Post, colon, Returns true
if instance comes after other Entry. 
Line 18, indented once: bool operator equals, equals, left
parentheses, const Entry With Date ampersand other Entry, right
parentheses, const, semicolon. 
Line 19, indented once: 2 forward slashes. Post, colon, Returns true
if instance is the same date as other Entry. 
Line 20, indented once: bool operator, left angled bracket, equals
sign, left parentheses, const Entry With Date ampersand other
Entry, right parentheses, const, semicolon. 
Line 21, indented once: 2 forward slashes. Post, colon, Returns true
if instance is less than or equal to other Entry. 
Line 22, indented once: bool operator, right angled bracket, equals
sign, left parentheses, const Entry With Date ampersand other
Entry, right parentheses, const, semicolon. 

Line 23, indented once: 2 forward slashes. Post, colon, Returns true
if instance is greater than or equal to other Entry. 
Line 24, indented once: bool operator, exclamation mark, equals
sign, left parentheses, const Entry With Date ampersand other
Entry, right parentheses, const, semicolon. 
Line 25: 2 forward slashes. Post, colon, Returns true if instance is
exclamation mark, equals sign, other Entry. 
Line 26: private, colon. 
Line 27, indented once: Date date, semicolon. 
Line 28: right brace, semicolon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the keyword include. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class Entry
With Date. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Entry With Date dot h, double
quotes. 
Line 5: blank. 
Line 6: Entry With Date, colon, colon, Entry With Date, left
parentheses, right parentheses. 
Line 7: left brace, blank space, right brace, semicolon. 
Line 8: 2 forward slashes followed by asterisks till the end of the line.
Line 9: Entry With Date, colon, colon, Entry With Date. 
Line 10, indented once: left parentheses, Date init Date, comma,
Time Of Day init Time, comma, Name init Name, right parentheses,
colon. 
Line 11, indented twice: Entry, left parentheses, init Name dot Get
First Name, left parentheses, right parentheses, comma, init Name
dot Get Middle Name, left parentheses, right parentheses, comma. 
Line 12, indented thrice: init Name dot Get Last Name, left
parentheses, right parentheses, init Time dot Get Hours, left
parentheses, right parentheses, comma. 
Line 13, indented thrice: init Time dot Get Minutes, left parentheses,
right parentheses, comma, init Time dot Get Seconds, left
parentheses, right parentheses, right parentheses. 

Line 14: left brace. 
Line 15, indented once: date equals init Date, semicolon. 
Line 16: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: bool, return,
const, this. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: Date Entry With Date, colon, colon, Get Date, left
parentheses, right parentheses, const. 
Line 3: left brace, return date, semicolon, right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: bool Entry With Date, colon, colon, operator, left angled
bracket, left parentheses, const Entry With Date, ampersand other
Entry, right parentheses, const. 
Line 6: left brace. 
Line 7, indented once: return date, left angled bracket, other Entry
dot Get Date, left parentheses, right parentheses, semicolon. 
Line 8: right brace. 
Line 9: 2 forward slashes followed by asterisks till the end of the line.
Line 10: bool Entry With Date, colon, colon, operator, right angled
bracket, left parentheses, const Entry With Date ampersand other
Entry, right parentheses, const. 
Line 11: left brace. 
Line 12, indented once: return date, right angled bracket, other
Entry dot Get Date, left parentheses, right parentheses, semicolon. 
Line 13: right brace. 
Line 14: 2 forward slashes followed by asterisks till the end of the
line. 
Line 15: bool Entry With Date, colon, colon, operator equals, equals,
left brace, const Entry With Date ampersand other Entry, right
parentheses, const. 
Line 16: left brace. 
Line 17, indented once: return, left parentheses, date, equals,
equals, other Entry dot Get Date, left parentheses, right
parentheses, ampersand, ampersand. 
Line 18, indented twice: left parentheses, Get Name, left

parentheses, right parentheses, dot, Compared To, left parentheses,
other Entry dot Get Name, left parentheses, right parentheses, right
parentheses, equals, equals, SAME, right parentheses, semicolon. 
Line 19: right brace. 
Line 20: 2 forward slashes followed by asterisks till the end of the
line. 
Line 21: bool Entry With Date, colon, colon, operator, left angled
bracket, equals sign, left parentheses, const Entry With Date
ampersand other Entry, right parentheses, const. 
Line 22: left brace. 
Line 23, indented once: return. 
Line 24, indented twice: date, left angled bracket, other Entry dot
Get Date, left parentheses, right parentheses, 2 pipes, date, equals,
equals, other Entry dot Get Date, left parentheses, right
parentheses, semicolon. 
Line 25: right brace. 
Line 26: 2 forward slashes followed by asterisks till the end of the
line. 
Line 27: bool Entry With Date, colon, colon, operator, right angled
bracket, equals sign, left parentheses, const Entry With Date
ampersand other Entry, right parentheses, const. 
Line 28: left brace. 
Line 29, indented once: return. 
Line 30, indented twice: date, right angled bracket, other Entry dot
Get Date, left parentheses, right parentheses, 2 pipes, date, equals,
equals, other Entry dot Get Date, left parentheses, right
parentheses, semicolon. 
Line 31: right brace. 
Line 32: 2 forward slashes followed by asterisks till the end of the
line. 
Line 33: bool Entry With Date, colon, colon, operator, exclamation
mark, equals sign, left parentheses, const Entry With Date
ampersand other Entry, right parentheses, const. 
Line 34: left brace. 
Line 35, indented once: return, exclamation mark, left parentheses,
other Entry, equals, equals, asterisk, this, right parentheses,
semicolon. 
Line 36: right brace.

Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords: include, using, name space, s
t d, semicolon, class, public, bool, void, private. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE for class
Appointment Calendar. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, double quotes, List dot h, double quotes. 
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 
Line 7: using name space s t d, semicolon. 
Line 8: blank. 
Line 9: class Appointment Calendar. 
Line 10: left brace. 
Line 11: public, colon. 
Line 12, indented once: 2 forward slashes. 
Line 13, indented once: Appointment Calendar, left parentheses, i f
stream ampersand in File, right parentheses, semicolon. 
Line 14, indented once: 2 forward slashes. Knowledge responsibility. 
Line 15, indented once: bool Is There, left parentheses, Name
name, comma, Date date, right parentheses. 
Line 16, indented once: 2 forward slashes. Returns true if an entry
exists with the given name and date. 
Line 17: blank. 
Line 18, indented once: 2 forward slashes. Action responsibilities. 
Line 19, indented once: Entry With Date Get Entry, left parentheses,
Name name, comma, Date date, right parentheses, semicolon. 
Line 20, indented once: 2 forward slashes. Returns entry with time
field equal to time. 
Line 21, indented once: 2 forward slashes. Pre, colon, entry with
time field equal to time exists. 
Line 22, indented once: void Insert Entry, left parentheses, Entry
With Date init Entry, right parentheses, semicolon. 
Line 23, indented once: 2 forward slashes. Inserts entry into list. 
Line 24, indented once: void Write List To File, left parentheses, o f
stream ampersand out File, right parentheses, semicolon. 

Line 25, indented once: 2 forward slashes. Writes list to out File. 
Line 26: blank. 
Line 27: private, colon. 
Line 28, indented once: List list, semicolon. 
Line 29: right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: include, using, name space, s
t d, class, public. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION FILE FOR CLASS
APPOINTMENT CALENDAR. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, list, right angled bracket. 
Line 5: hash include, left angled bracket, f stream, right angled
bracket. 
Line 6: hash include, double quotes, Entry With Date dot h, double
quotes. 
Line 7: using name space s t d, semicolon. 
Line 8: blank. 
Line 9: class Appointment Calendar. 
Line 10: left brace. 
Line 11: public, colon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: i f stream,
bool, void, private. 
Line 1, indented once: 2 forward slashes. Constructor. 
Line 2, indented once: Appointment Calendar, left parentheses, i f
stream ampersand in File, right parentheses, semicolon. 
Line 3, indented once: 2 forward slashes. Knowledge responsibility. 
Line 4, indented once: bool Is There, left parentheses, Name name,
comma, Date date, right parentheses, semicolon. 
Line 5, indented once: 2 forward slashes. Returns true if an entry
exists with the given name and date. 

Line 6: blank. 
Line 7, indented once: 2 forward slashes. Action responsibilities. 
Line 8, indented once: Entry With Date Get Entry, left parentheses,
Name name, comma, Date date, right parentheses, semicolon. 
Line 9, indented once: 2 forward slashes. Returns entry with time
field equal to time. 
Line 10, indented once: 2 forward slashes. Pre, colon, entry with
time field equal to time exists. 
Line 11, indented once: void Insert Entry, left parentheses, Entry
With Date init Entry, right parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Inserts entry into list. 
Line 13, indented once: void Write List To File, left parentheses, o f
stream ampersand out File, right parentheses, semicolon. 
Line 14, indented once: 2 forward slashes. Writes list to out File. 
Line 15: private, colon. 
Line 16, indented once: list, left angled bracket, Entry With Date,
right angled bracket, entry List, semicolon. 
Line 17: right brace, semicolon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: int, string, i f
stream, for. 
Line 1: Appointment Calendar, colon, colon, Appointment Calendar,
left parentheses, i f stream ampersand in File, right parentheses. 
Line 2: left brace. 
Line 3, indented once: int hours, comma, minutes, comma, seconds,
semicolon. 2 forward slashes. For class Time Of Day. 
Line 4, indented once: int month, comma, day, comma, year,
semicolon. 2 forward slashes. For class Date. 
Line 5, indented once: string first, comma, middle, comma, last,
semicolon. 2 forward slashes. For class Name. 
Line 6, indented once: int number Entries, semicolon. 
Line 7, indented once: in File, 2 right angled brackets, number
Entries, semicolon. 
Line 8, indented once: for, left parentheses, int counter equals 0,
semicolon, counter less than number Entries, semicolon, counter,
plus, plus, right parentheses. 

Line 9, indented once: left brace. 
Line 10, indented twice: in File, 2 right angled brackets, hours, 2
right angled brackets, minutes, 2 right angled brackets, seconds,
semicolon. 
Line 11, indented twice: Date date, left parentheses, month, comma,
day, comma, year, right parentheses, semicolon. 
Line 12, indented twice: in File, 2 right angled brackets, first, 2 right
angled brackets, middle, 2 right angled brackets, last, semicolon. 
Line 13, indented twice: Name name, left parentheses, first, comma,
middle, comma, last, right parentheses, semicolon. 
Line 14, indented twice: Entry With Date, entry, left parentheses,
date, comma, time, comma, name, right parentheses, semicolon. 
Line 15, indented twice: list, dot, Insert, left parentheses, entry, right
parentheses, semicolon. 
Line 16, indented once: right brace. 
Line 17: right brace. 
Back to Figure
return find, left parentheses, entry List dot begin, left parentheses,
right parentheses, comma, entry List dot end, left parentheses, right
parentheses, comma, entry, right parentheses, exclamation mark,
equals sign, entry List dot end, left parentheses, right parentheses,
semicolon.
Back to Figure
Program code. The code contains the keyword return. 
Line 1: Entry With Date Appointment Calendar, colon, colon, Get
Entry, left parentheses, Name name, comma, Date date, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: Time Of Day time, semicolon. 
Line 4, indented once: Entry With Date other Entry, left parentheses,
date, comma, time, comma, name, right parentheses, semicolon. 
Line 5, indented once: Entry With Date entry, semicolon. 
Line 6, indented once: list dot Reset List, left parentheses, right
parentheses, semicolon. 
Line 7, indented once: entry equals list dot Get Next Item, left

parentheses, right parentheses, semicolon. 
Line 8, indented once: while, left parentheses, entry dot Compared
To, left parentheses, other Entry, right parentheses, exclamation
mark, equals sign, SAME, right parentheses. 
Line 9, indented twice: entry equals list dot Get Next Item, left
parentheses, right parentheses, semicolon. 
Line 10, indented once: list dot Delete, left parentheses, entry, right
parentheses, semicolon. 
Line 11, indented once: return entry, semicolon. 
Line 12: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the keyword return. 
Line 1: Entry With Date Appointment Calendar, colon, colon, Get
Entry, left parentheses, Name name, comma, Date date, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: Time Of Day time, semicolon. 
Line 4, indented once: Entry With Date search Entry, left
parentheses, date, comma, time, comma, name, right parentheses,
semicolon. 
Line 5, indented once: list, left angled bracket, Entry With Date, right
angled bracket, colon, colon, iterator location, equals. 
Line 6, indented twice: find, left parentheses, entry List dot begin,
left parentheses, right parentheses, comma, entry List dot end, left
parentheses, right parentheses, comma, search Entry, right
parentheses, semicolon. 
Line 7, indented once: Entry With Date entry equals asterisk
location, semicolon. 
Line 8, indented once: entry List dot erase, left parentheses,
location, right parentheses, semicolon. 
Line 9, indented once: return entry, semicolon. 
Line 10: right brace.
Back to Figure

Program code. The words in the variable names and function names
are merged. The code contains the following keywords: void, o f
stream, while. 
Line 1: void Appointment Calendar, colon, colon, Write List To File,
left parentheses, o f stream ampersand, out File, right parentheses. 
Line 2: left brace. 
Line 3, indented once: Entry With Date entry, semicolon. 
Line 4, indented once: Name name, semicolon. 
Line 5, indented once: Date date, semicolon. 
Line 6, indented once: Time Of Day time, semicolon. 
Line 7, indented once: list dot Reset List, left parentheses, right
parentheses, semicolon. 
Line 8, indented once: out File, 2 left angled brackets, list dot Get
Length, left parentheses, right parentheses, 2 left angled brackets,
end l, semicolon. 
Line 9, indented once: while, left parentheses, list dot Has Next, left
parentheses, right parentheses, right parentheses. 
Line 10, indented once: left brace. 
Line 11, indented twice: entry equals list dot Get Next Item, left
parentheses, right parentheses, semicolon. 
Line 12, indented twice: time equals entry dot Get Time, left
parentheses, right parentheses, semicolon. 
Line 13, indented twice: out File, 2 left angled brackets, time dot Get
Hours, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, 2 left angled brackets, time
dot Get Minutes, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote. 
Line 14, indented multiple times: 2 left angled brackets, time dot Get
Seconds, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, semicolon. 
Line 15, indented twice: date equals entry dot Get Date, left
parentheses, right parentheses, semicolon. 
Line 16, indented twice: out File, 2 left angled brackets, date dot Get
Month, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, 2 left angled brackets, date
dot Get Day, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote. 
Line 17, indented multiple times: 2 left angled brackets, date dot Get

Year, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, semicolon.
Back to Figure
Program code. The words in the function names are merged. 
Line 1, indented twice: name equals entry dot Get Name, left
parentheses, right parentheses, semicolon. 
Line 2, indented twice: out File, 2 left angled brackets, name dot Get
First Name, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote, 2 left angled
brackets, name dot Get Middle Name, left parentheses, right
parentheses. 
Line 3, indented multiple times: 2 left angled brackets, single quote,
blank space, single quote, 2 left angled brackets, name dot Get Last
Name, left parentheses, right parentheses, 2 left angled brackets,
end l, semicolon. 
Line 4, indented once: right brace. 
Line 5, indented once: out File dot close, left parentheses, right
parentheses, semicolon. 
Line 6: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include,
string, f stream, i o stream, using, name space, s t d, int, for, bool.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for Appointment
Calendar. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, left angled bracket, string, right angled bracket.
Line 6: hash include, left angled bracket, f stream, right angled
bracket. 
Line 7: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 8: hash include, left angled bracket, algorithm, right angled
bracket. 

Line 8 is shaded. 
Line 9: hash include, double quotes, Appointment Calendar dot h,
double quotes. 
Line 10: using name space s t d, semicolon. 
Line 11: blank. 
Line 12: Appointment Calendar, colon, colon, Appointment Calendar,
left parentheses, i f stream ampersand in File, right parentheses. 
Line 13: left brace. 
Line 14, indented once: int hours, comma, minutes, comma,
seconds, semicolon. 2 forward slashes. For class Time Of Day. 
Line 15, indented once: int month, comma, day, comma, year,
semicolon. 2 forward slashes. For class Date. 
Line 16, indented once: string first, comma, middle, comma, last,
semicolon. 2 forward slashes. For class Name. 
Line 17, indented once: int number Entries, semicolon. 
Line 18, indented once: in File, 2 forward slashes, number Entries,
semicolon. 
Line 19, indented once: for, left parentheses, int counter equals 0,
semicolon, counter less than number Entries, semicolon, counter,
plus, plus, right parentheses. 
Line 20, indented once: left brace. 
Line 21, indented twice: in File, 2 forward slashes, hours, 2 forward
slashes, minutes, 2 forward slashes, seconds, semicolon. 
Line 22, indented twice: Time Of Day time, left parentheses, hours,
comma, minutes, comma, seconds, right parentheses, semicolon. 
Line 23, indented twice: in File, 2 forward slashes, month, 2 forward
slashes, day, 2 forward slashes, year, semicolon. 
Line 24, indented twice: Date date, left parentheses, month, comma,
day, comma, year, right parentheses, semicolon. 
Line 25, indented twice: in File, 2 forward slashes, first, 2 forward
slashes, middle, 2 forward slashes, last, semicolon. 
Line 26, indented twice: Name name, left parentheses, first, comma,
middle, comma, last, right parentheses, semicolon. 
Line 27, indented twice: Entry With Date entry, left parentheses,
date, comma, time, comma, name, right parentheses, semicolon. 
Line 28, indented twice: entry List dot push underscore back, left
parentheses, entry, right parentheses, semicolon. 
Line 28 is shaded. 
Line 29, indented once: right brace. 

Line 30: right brace. 
Line 31: 2 forward slashes followed by asterisks till the end of the
line. 
Line 32: bool Appointment Calendar, colon, colon, Is There, left
parentheses, Name name, comma, Date date, right parentheses. 
Line 33: left brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: return, list,
void, o f stream, for.
Line 1, indented once: Time of Day time, semicolon. 
Line 2, indented once: Entry With Date entry, left parentheses, date,
comma, time, comma, name, right parentheses, semicolon. 
Line 3, indented once: return find, left parentheses, entry List dot
begin, left parentheses, right parentheses, comma, entry List dot
end, left parentheses, right parentheses, comma, entry, right
parentheses. 
Line 4, indented multiple times: exclamation mark, equals sign, entry
List dot end, left parentheses, right parentheses, semicolon. 
Line 5: right brace. 
Line 6: 2 forward slashes followed by asterisks till the end of the line.
Line 7: Entry with Date Appointment Calendar, colon, colon, Get
Entry, left parentheses, Name name, comma, Date date, right
parentheses. 
Line 8: left brace. 
Line 9, indented once: Time Of Day time, semicolon. 
Line 10, indented once: Entry With Date search Entry, left
parentheses, date, comma, time, comma, name, right parentheses,
semicolon. 
Line 11, indented once: list, left angled bracket, Entry With Date,
right angled bracket, colon, colon, iterator location equals. 
Line 12, indented twice: find, left parentheses, entry List dot begin,
left parentheses, right parentheses, comma, entry List dot end, left
parentheses, right parentheses, comma, search Entry, right
parentheses, semicolon. 
Line 13, indented once: Entry With Date entry equals asterisk
location, semicolon. 

Line 14, indented once: entry List dot erase, left parentheses,
location, right parentheses, semicolon. 
Lines 9 to 14 are shaded. 
Line 15, indented once: return entry, semicolon. 
Line 16: right brace. 
Line 17: 2 forward slashes followed by asterisks till the end of the
line. 
Line 19: void Appointment Calendar, colon, colon, Insert Entry, left
parentheses, Entry With Date entry, right parentheses. 
Line 20: left brace, entry List dot push underscore back, left
parentheses, entry, right parentheses, semicolon, right brace. 
Line 20 is shaded. 
Line 21: 2 forward slashes followed by asterisks till the end of the
line. 
Line 22: void Appointment Calendar, colon, colon, Write List To File,
left parentheses, o f stream ampersand out File, right parentheses. 
Line 23: left brace. 
Line 24, indented once: Entry With Date entry, semicolon. 
Line 25, indented once: Name name, semicolon. 
Line 26, indented once: Date date, semicolon. 
Line 27, indented once: Time Of Day time, semicolon. 
Line 28, indented once: out File, 2 left angled brackets, entry List dot
size, left parentheses, right parentheses, 2 left angled brackets, end
l, semicolon. 
In line 28, entry List dot size, left parentheses, right parentheses, is
shaded. 
Line 29, indented once: list, left angled bracket, Entry With Date,
right angled bracket, colon, colon, iterator location, semicolon. 
Line 30, indented once: for, left parentheses, location equals entry
List dot begin, left parentheses, right parentheses, semicolon. 
Line 31, indented multiple times: location, exclamation mark, equals
sign, entry List dot end, left parentheses, right parentheses,
semicolon, location, plus, plus, right parentheses. 
Lines 30 and 31 are shaded. 
Line 32, indented once: left brace. 
Line 33, indented twice: entry equals asterisk location, semicolon. 
Line 33 is shaded. 
Line 34, indented once: time equals entry dot Get Time, left
parentheses, right parentheses, semicolon. 

Line 35, indented once: out File, 2 left angled brackets, time dot Get
Hours, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, 2 left angled brackets, time
dot Get Minutes, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote. 
Line 36, indented multiple times: 2 left angled brackets, time dot Get
Seconds, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, semicolon. 
Line 37, indented twice: date equals entry dot Get Date, left
parentheses, right parentheses, semicolon. 
Line 28, indented twice: out File, 2 left angled brackets, date dot Get
Month, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, 2 left angled brackets, date
dot Get Day, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote. 
Line 29, indented multiple times: 2 left angled brackets, date dot Get
year, left parentheses, right parentheses, 2 left angled brackets,
single quote, blank space, single quote, semicolon. 
Line 30, indented twice: name equals entry dot Get Name, left
parentheses, right parentheses, semicolon. 
Line 31, indented twice: out File, 2 left angled brackets, name dot
Get First Name, left parentheses, right parentheses, 2 left angled
brackets, single quote, blank space, single quote, 2 left angled
brackets, name dot Get Middle Name, left parentheses, right
parentheses. 
Line 32, indented multiple times: 2 left angled brackets, single quote,
blank space, single quote, 2 left angled brackets, name dot Get Last
Name, left parentheses, right parentheses, 2 left angled brackets,
end l, semicolon. 
Line 33, indented once: right brace. 
Line 34, indented once: out File dot close, left parentheses, right
parentheses, semicolon. 
Line 35: right brace.
Back to Figure
Line 1: 5. Line 2: 8, blank space, 20, blank space, 0, blank space,
10, blank space, 12, blank space, 2023, blank space, Boris, blank
space, Becker, blank space, Brown. Line 3: 8, blank space, 45,

blank space, 0, blank space, 10, blank space, 11, blank space,
2023, blank space, Sara, blank space, Jane, blank space, Jones.
Line 4: 12, blank space, 30, blank space, 0, blank space, 10, blank
space, 11, blank space, 2023, blank space, Susy, blank space,
Smiley, blank space, Baker. Line 5: 8, blank space, 30, blank space,
0, blank space, 10, blank space, 12, blank space, 2023, blank
space, Bill, blank space, Bradley, blank space, Britton. Line 6: 9,
blank space, 30, blank space, 0, blank space, 11, blank space, 5,
blank space, 2024, blank space, Mary, blank space, Jane, blank
space, Smith.
Back to Figure
Line 1: Enter name of entry to change, colon. 
Line 2: Enter name as first, comma, middle, comma, last. 
Line 3: Mary Jane Smith. 
Line 3 is shaded. 
Line 4: Enter date of entry to change. 
Line 5: Enter date as month, comma, day, comma and year. 
Line 6: 11, blank space, 5, blank space, 2024. 
Line 6 is shaded. 
Line 7: Entry retrieved, colon. 
Line 8: Time, 9, colon, 30. 
Line 9: Date 11, forward slash, 5, forward slash, 2024. 
Line 10: Name Mary Smith. 
Line 11: blank. 
Line 12: Enter field to change, colon, single quote, uppercase t,
single quote, left parentheses, time, right parentheses, single quote,
uppercase d, single quote, left parentheses, date, right parentheses,
single quote, uppercase n, single quote, left parentheses, name,
right parentheses. 
Line 13: uppercase d. 
Line 14: Enter date as month, comma, day, comma, and year. 
Line 15: 11 5 2023. 
Line 15 is shaded. 
Line 16: Do you wish to continue changing entries, question mark,
single quote, uppercase y, single quote, or, single quote, uppercase
n, single quote. 
Line 17: uppercase y. 

Line 17 is shaded. 
Line 18: Enter name of entry to change, colon. 
Line 19: Enter name as first, comma, middle, comma, last. 
Line 20: Bill Bradley Britton. 
Line 21: Enter date of entry to change. 
Line 22: Enter date as month, comma, day, comma, and year. 
Line 23: 10 12 2023. 
Line 23 is shaded. 
Line 24: Entry retrieved, colon. 
Line 25: Time 8, colon, 30. 
Line 26: Date 10, forward slash, 12, forward slash, 2023. 
Line 27: Name Bill Britton. 
Line 28: blank. 
Line 29: Enter field to change, colon, single quote, uppercase t,
single quote, left parentheses, time, right parentheses, single quote,
uppercase d, single quote, left parentheses, date, right parentheses,
single quote, uppercase n, single quote, left parentheses, name,
right parentheses. 
Line 30: uppercase t. 
Line 30 is shaded. 
Line 31: Enter time as hours, comma, minutes, comma, seconds. 
Line 32: 9 30 0. 
Line 32 is shaded. 
Line 33: Do you wish to continue changing entries, question mark,
single quote, uppercase y, single quote, or, single quote, uppercase
n, single quote. 
Line 34: lowercase y. 
Line 34 is shaded. 
Line 35: Enter name of entry to change, colon. 
Line 36: Enter name as first, comma, middle, comma, last. 
Line 37: Sara Jane Jones. 
Line 37 is shaded.
Back to Figure
Line 38: Enter date of entry to change. 
Line 39: Enter date as month, comma, day, comma, and year. 
Line 40: 10 11 2023. 
Line 40 is shaded. 

Line 41: Entry retrieved, colon. 
Line 42: Time 8, colon, 45. 
Line 43: Date 10, forward slash, 11, forward slash, 2023. 
Line 44: Name Sara Jones. 
Line 45: blank. 
Line 46: Enter field to change, colon, single quote, uppercase t,
single quote, left parentheses, time, right parentheses, single quote,
uppercase d, single quote, left parentheses, date, right parentheses,
single quote, uppercase n, single quote, left parentheses, name,
right parentheses. 
Line 47: uppercase n. 
Line 47 is shaded. 
Line 48: Enter name as first, comma, middle, comma, last. 
Line 49: Sarah Jane Jones. 
Line 49 is shaded. 
Line 50: Do you wish to continue changing entries, question mark,
single quote, uppercase y, single quote, or, single quote, uppercase
n, single quote. 
Line 51: uppercase y. 
Line 51 is shaded. 
Line 52: Enter name of entry to change, colon. 
Line 53: Enter name as first, comma, middle, comma, last. 
Line 54: Sara Jane Jones. 
Line 54 is shaded. 
Line 55: Enter date of entry to change. 
Line 56: Enter date as month, comma, day, comma, and year. 
Line 57: 10 11 2023. 
Line 57 is shaded. 
Line 58: No entry exists with this name and date. 
Line 59: Do you wish to continue changing entries, question mark,
single quote, uppercase y, single quote, or, single quote, uppercase
n, single quote. 
Line 60: uppercase n. 
Line 60 is shaded.
Back to Figure
Line 1: 5. Line 2: 8, blank space, 20, blank space, 0, blank space,
10, blank space, 12, blank space, 2023, blank space, Boris, blank

space, Becker, blank space, Brown. Line 3: 12, blank space, 30,
blank space, 0, blank space, 10, blank space, 11, blank space,
2023, blank space, Susy, blank space, Smiley, blank space, Baker.
Line 4: 9, blank space, 30, blank space, 0, blank space, 11, blank
space, 5, blank space, 2023, blank space, Mary, blank space, Jane,
blank space, Smith. Line 5: 9, blank space, 30, blank space, 0, blank
space, 10, blank space, 12, blank space, 2023, blank space, Bill,
blank space, Bradley, blank space, Britton. Line 6: 8, blank space,
45, blank space, 0, blank space, 10, blank space, 11, blank space,
2023, blank space, Sarah, blank space, Jane, blank space, Jones.
Back to Figure
Node 1 and Node 2 are below the root node. Node 3 and Node 4 are
below Node 1. Node 5 and Node 6 are below Node 2. Each node
has 3 fields. The first and third field of the root node point to Node 1
and Node 2, respectively. The first and third field of Node 1 point to
Node 3 and Node 4, respectively. The first and third field of Node 2
point to Node 5 and Node 6, respectively. The first and third fields of
Nodes 3 to 6 are each marked NULL.
Back to Figure
The root node is marked 20. Nodes 1 and 2 are below the root
node. Node 1 is marked 17 and node 2 is marked 28. Edges are
drawn from the root node to nodes 1 and 2. Nodes 3 and 4 are
below node 1. Node 3 is marked 6 and Node 4 is marked 19. Edges
are drawn from node 1 to nodes 3 and 4. Nodes 5 and 6 are below
node 3. Node 5 is marked 3 and node 6 is marked 8. Edges are
drawn from node 3 to nodes 5 and 6. Nodes 7 and 8 are below node
2. Node 7 is marked 27 and node 8 is marked 50. Edges are drawn
from node 2 to nodes 7 and 8. Node 9 is below node 7 and it is
marked 24. An edge is drawn from node 7 to node 9. Nodes 10 and
11 are below node 8. Node 10 is marked 36 and node 11 is marked
101. Edges are drawn from node 8 to nodes 10 and 11.
Back to Figure

The root node is marked 20. Nodes 1 and 2 are below the root
node. Node 1 is marked 17 and node 2 is marked 28. Edges are
drawn from the root node to nodes 1 and 2. Nodes 3 and 4 are
below node 1. Node 3 is marked 6 and Node 4 is marked 19. Edges
are drawn from node 1 to nodes 3 and 4. Nodes 5 and 6 are below
node 3. Node 5 is marked 3 and node 6 is marked 8. Edges are
drawn from node 3 to nodes 5 and 6. Nodes 7 and 8 are below node
2. Node 7 is marked 27 and node 8 is marked 50. Edges are drawn
from node 2 to nodes 7 and 8. Node 9 is below node 7 and it is
marked 24. An edge is drawn from node 7 to node 9. Nodes 10 and
11 are below node 8. Node 10 is marked 36 and node 11 is marked
101. Edges are drawn from node 8 to nodes 10 and 11. The caption
pointing to the root node reads, Comparison 1: 50, greater than 20.
The search goes to the right child. The caption pointing to node 2
reads, Comparison 2: 50 greater than 28. The search goes to the
right child. The caption pointing to node 8 reads, Comparison 3: 50
equals 50. The value is found.
Back to Figure
The root node is marked 20. Nodes 1 and 2 are below the root
node. Node 1 is marked 17 and node 2 is marked 28. Edges are
drawn from the root node to nodes 1 and 2. Nodes 3 and 4 are
below node 1. Node 3 is marked 6 and Node 4 is marked 19. Edges
are drawn from node 1 to nodes 3 and 4. Nodes 5 and 6 are below
node 3. Node 5 is marked 3 and node 6 is marked 8. Edges are
drawn from node 3 to nodes 5 and 6. Nodes 7 and 8 are below node
2. Node 7 is marked 27 and node 8 is marked 50. Edges are drawn
from node 2 to nodes 7 and 8. Node 9 is below node 7 and it is
marked 24. An edge is drawn from node 7 to node 9. Nodes 10 and
11 are below node 8. Node 10 is marked 36 and node 11 is marked
101. Edges are drawn from node 8 to nodes 10 and 11. The caption
pointing to the root node reads, Comparison 1: 18 less than 20. The
search goes to the left child. A caption pointing to node 1 reads,
Comparison 2: 18 greater than 17. The search goes to the right
child. The caption pointing to node 4 reads, Comparison 3: 18 less
than 19. The caption below reads, Left child that is not there.
Back to Figure

The root node is marked 36. Nodes 1 and 2 are below the root
node. Node 1 is marked 24 and node 2 is marked 48. Edges are
drawn from the root node to nodes 1 and 2. Nodes 3 and 4 are
below node 1. Node 3 is marked 12 and node 4 is marked 30. Edges
are drawn from node 1 to nodes 3 and 4. Nodes 5 and 6 are below
node 2. Node 5 is marked 42 and node 6 is marked 60. Edges are
drawn from node 2 to nodes 5 and 6.
Back to Figure
The index of the table runs from 0, 1, 2, 3, and so on, up to, length
minus 2 and length minus 1. The chain associated with index 0
consists of strings Able and Andale. The chain associated with index
1 consists of string Bernan. The chain associated with index 3
consists of strings Davis, Downey, and Drew. The chain associated
with index, length minus 2, consists of strings Yannis and Yoda.
Back to Table
The root node is labelled single quote, uppercase m, single quote.
Nodes 1 and 2 are below the root node. Node 1 is labelled single
quote, uppercase g, single quote. Node 2 is labelled single quote
uppercase r single quote. Directed edges are drawn from the root
node to nodes 1 and 2. Nodes 3 and 4 are below node 1. Node 3 is
labelled single quote uppercase b, single quote. Node 4 is labelled
single quote uppercase j single quote. Directed edges are drawn
from node 1 to nodes 3 and 4. Node 5 is below node 3 and it is
labelled question mark. A directed edge is drawn from node 3 to
node 5. Nodes 6 and 7 are below node 1. Node 6 is labelled single
quote uppercase p single quote. Node 7 is labelled single quote
uppercase u single quote. Directed edges are drawn from node 2 to
nodes 6 and 7. Node 8 is below node 7 and it is labelled question
mark. A directed edge is drawn from node 7 to node 8. Begin points
to node 3. R end points to node 5. R begin points to node 7. End
points to node 8.
Back to Figure

The table has 4 columns labelled Name, Parameters, Returns, and
Description. The row entries are as follows. 
Row 1. Name: begin. Parameters: blank. Returns: iterator.
Description: Returns an iterator to the first element. 
Row 2. Name: clear. Parameters: blank. Returns: blank. Description:
Removes all elements. Sets size to 0.
Row 3. Name: count. Parameters: value. Returns: int. Description:
Returns the number of instances of this value in the set. Will be 1 if
the value is in the set, semicolon, 0 otherwise.
Row 4. Name: empty. Parameters: blank. Returns: bool. Description:
Returns true if there are no elements in the set.
Row 5. Name: end. Parameters: blank. Returns: iterator.
Description: Returns an iterator beyond the end of the set.
Back to Table
The table has 4 columns labelled Name, Parameters, Returns, and
Description. The row entries are as follows. 
Row 6. Name: erase. Parameters: iterator. Returns: blank.
Description: Removes the element at the iterator position. The size
decreases. 
Row 7. Name: find. Parameters: value. Returns: iterator.
Description: Returns an iterator to the element with the value.
Row 8. Name: insert. Parameters: value. Returns: blank.
Description: Inserts the value into the set. The size increases.
Row 9. Name: lower underscore bound. Parameters: value. Returns:
iterator. Description: Returns an iterator to the first element that is
greater than or equal to the value.
Row 10. Name: r begin. Parameters: blank. Returns: reverse
underscore iterator. Description: Returns a reverse iterator to the
last element.
Row 11. Name: r end. Parameters: blank. Returns: reverse
underscore iterator. Description: Returns a reverse iterator before
the start of the set.
Row 12. Name: size. Parameters: blank. Returns: int. Description:
Returns the number of elements in the set.
Row 13. Name: upper underscore bound. Parameters: value.
Returns: iterator. Description: Returns an iterator to the first element
that is less than the value.

Back to Table
set underscore difference, left parentheses, start 1, comma, end 1,
comma, start 2, comma, end 2, comma, output, right parentheses,
semicolon.
Back to Figure
Line 1: set underscore difference, left parentheses, set 1 dot begin,
left parentheses, right parentheses, comma, set 1 dot end, left
parentheses, right parentheses, comma. 2 forward slashes. First
set. Line 2, indented multiple times: set 2 dot begin, left
parentheses, right parentheses, comma, set 2 dot end, left
parentheses, right parentheses, comma. 2 forward slashes. Second
set. Line 3, indented multiple times: inserter, left parentheses, set 3,
comma, set 3 dot end, left parentheses, right parentheses, right
parentheses, right parentheses, semicolon. 2 forward slashes.
Result set.
Back to Figure
Program code. The words used in the variable names are merged.
The code contains the following keywords: include, i o stream, set,
algorithm, iterator, using, name space, s t d, int, main, string, c out,
end l, for, c in. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. This program demonstrates various set
methods. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, left angled bracket, set, right angled bracket. 
Line 6: hash include, left angled bracket, algorithm, right angled
bracket. 
Line 7: hash include, left angled bracket, iterator, right angled
bracket. 
Line 8: using name space s t d, semicolon. 
Line 9: blank. 
Line 10: int main, left parentheses, right parentheses. 

Line 11: left brace. 
Line 12, indented once: set, left angled bracket, string, right angled
bracket, s t r Set, semicolon. 2 forward slashes. Create an empty
set. 
Line 13, indented once: string word, semicolon. 
Line 14, indented once: c out, 2 left angled brackets, double quotes,
Enter a line with six words, colon, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 15, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 6, semicolon, i plus, plus, right
parentheses. 
Line 16, indented once: left brace. 
Line 17, indented twice: c in, 2 right angled brackets, word,
semicolon. 
Line 18, indented twice: s t r Set dot insert, left parentheses, word,
right parentheses, semicolon. 2 forward slashes. Insert elements. 
Line 19, indented once: right brace. 
Line 20, indented once: 2 forward slashes. Access size. 
Line 21, indented once: c out, 2 left angled brackets, double quotes,
Size of set, colon, blank space, double quotes, 2 left angled
brackets, s t r Set dot size, left parentheses, right parentheses, 2
left angled brackets, end l, semicolon. 
Line 22, indented once: 2 forward slashes. Output the set. 
Line 23, indented once: set, left angled bracket, string, right angled
bracket, colon, colon, iterator place, semicolon. 
Line 24, indented once: c out, 2 left angled brackets, double quotes,
Set contents from beginning to end, colon, blank space, double
quotes, 2 left angled brackets, end l, semicolon. 
Line 25, indented once: 2 forward slashes. Traverse set in forward
order. 
Line 26, indented once: for, left parentheses, place equals s t r Set
dot begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, s t r Set dot end, left parentheses,
right parentheses, semicolon, place, plus, plus, right parentheses. 
Line 27, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 28, indented once: 2 forward slashes. Create a reverse iterator.
Line 29, indented once: set, left angled bracket, string, right angled

bracket, colon, colon, reverse, underscore, iterator r place,
semicolon. 
Line 30, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quote, Set contents from end to beginning,
colon, blank space, double quotes, 2 left angled brackets, end l,
semicolon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: for, c out,
set, end l, return. 
Line 1, indented once: 2 forward slashes. Traverse set in reverse
order. 
Line 2, indented once: for, left parentheses, r place equals s t r Set
dot r begin, left parentheses, right parentheses, semicolon, r place,
exclamation mark, equals sign, s t r Set dot r end, left parentheses,
right parentheses, semicolon, plus, plus, r place, right parentheses. 
Line 3, indented twice: c out, 2 left angled brackets, asterisk r place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 4, indented once: 2 forward slashes. Prepare to illustrate set
difference. 
Line 5, indented once: set, left angled bracket, string, right angled
bracket, s t r Set 2, left parentheses, s t r Set, right parentheses,
semicolon. 2 forward slashes. Create a copy of s t r Set. 
Line 6, indented once: s t r Set 2 dot erase, left parentheses, s t r
Set 2 dot begin, left parentheses, right parentheses, right
parentheses, semicolon. 2 forward slashes. Delete first element. 
Line 7, indented once: s t r Set 2 dot erase, left parentheses, minus,
minus, s t r Set 2 dot end, left parentheses, right parentheses, right
parentheses, semicolon. 2 forward slashes. Delete last element. 
Line 8, indented once: set, left angled bracket, string, right angled
bracket, s t r Set 3, semicolon. 2 forward slashes. Create a set for
the result.
Line 9, indented once: 2 forward slashes. Need to use inserter
because set doesn’t allow copy iterator. 
Line 10, indented once: set underscore difference, left parentheses,
s t r Set dot begin, left parentheses, right parentheses, comma, s t r

Set dot end, left parentheses, right parentheses, comma. 2 forward
slashes. First set. 
Line 11, indented multiple times: s t r Set 2 dot begin, left
parentheses, right parentheses, comma, s t r Set 2 dot end, left
parentheses, right parentheses, comma. 2 forward slashes. Second
set. 
Line 12, indented multiple times: inserter, left parentheses, s t r Set
3, comma, s t r Set 3 dot end, left parentheses, right parentheses,
right parentheses, right parentheses, semicolon. 2 forward slashes.
Result set. 
Line 13, indented once: 2 forward slashes. Output result set. 
Line 14, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, Set difference from beginning to
end, colon, blank space, double quotes, 2 left angled brackets, end
l, semicolon. 
Line 15, indented once: for, left parentheses, place equals s t r Set 3
dot begin, left parentheses, right parentheses, semicolon, place,
exclamation mark, equals sign, s t r Set 3 dot end, left parentheses,
right parentheses, semicolon, place, plus, plus, right parentheses. 
Line 16, indented twice: c out, 2 left angled brackets, asterisk place,
2 left angled brackets, double quotes, blank space, double quotes,
semicolon. 
Line 17, indented once: return 0, semicolon. 
Line 18: right brace.
Back to Figure
Line 1: Enter a line with six words, colon. Line 2: four score and
seven years ago. Line 2 is shaded. Line 3: Size of set, colon, 6. Line
4: Set contents from beginning to end, colon. Line 5: ago and four
score seven years. Line 6: Set contents from end to begining, colon.
Line 7: years seven score four and ago. Line 8: Set difference from
begining to end, colon. Line 9: ago years.
Back to Figure
The entries are as follows. Left square bracket, double quotes,
Helmand, double quotes, right square bracket: 5550101. Left square
bracket, double quotes, Jeng, double quotes, right square bracket:

5552345. Left square bracket, double quotes, Kellaug, double
quotes, right square bracket: 8881077. Left square bracket, double
quotes, Lepoutre, double quotes, right square bracket: 9994280.
Left square bracket, double quotes, Marini, double quotes, right
square bracket: 7714444. Left square bracket, double quotes, Mc
Cartney, double quotes, right square bracket: 5550003. Left square
bracket, double quotes, Meely, double quotes, right square bracket:
8884902. Left square bracket, double quotes, Melchiore, double
quotes: 5557391. Left square bracket, double quotes, Smite, double
quotes, right square bracket: 8883129. Left square bracket, double
quotes, Teernsma, double quotes, right square bracket: 7713618.
Back to Figure
Line 1: map, left angled bracket, string, comma, int, right angled
bracket, phone directory, semicolon. Line 2: phone directory dot
insert, left parentheses, pair, left angled bracket, string, comma, int,
right angled bracket, left parentheses, double quotes, Eben
Johnson, double quotes, comma, 5550001, right parentheses, right
parentheses, semicolon.
Back to Figure
Line 1: map, left angled bracket, string, comma, int, right angled
bracket, colon, colon, iterator place, semicolon. Line 2: place equals
phone directory dot find, left parentheses, double quotes, Eben
Johnson, double quotes, right parentheses, semicolon. Line 3: c out,
2 left angled brackets, asterisk place dot first, 2 left angled brackets,
double quotes, colon, blank space, double quotes, 2 left angled
brackets, asterisk place dot second, 2 left angled brackets, end l,
semicolon. Line 4: phone directory dot erase, left parentheses,
place, right parentheses, semicolon.
Back to Figure
Line 1: map, left angled bracket, s p r t ring, comma, int, right
angled bracket, phone directory, semicolon. Line 2: string name
equals double quotes, Eben Johnson, double quotes, semicolon.
Line 3: phone directory, left square bracket, name, right square

bracket equals 5550001, semicolon. Line 4: c out, 2 left angled
brackets, name, 2 left angled brackets, double quotes, colon, blank
space, double quotes, 2 left angled brackets, phone directory, left
square bracket, name, right square bracket, 2 left angled bracket,
end l, semicolon. Line 5: phone directory dot erase, left
parentheses, name, right parentheses, semicolon.
Back to Figure
The description of the C R C card is as follows. Class Name, colon,
Suits. Superclass, colon, None. Subclasses, colon, None.
Responsibilities: Create Suits, left parentheses, right parentheses.
Collaborations: blank. Responsibilities: Create Suits, left
parentheses, string, right parentheses. Collaborations: map,
comma, transform. Responsibilities: Create Suits, left parentheses,
int, right parentheses. Collaborations: blank. Responsibilities: to
String, left parentheses, right parentheses, returns string.
Collaborations: blank. Responsibilities: to Int, left parentheses, right
parentheses, returns int. Collaborations: blank. Responsibilities:
Operator, left angled bracket, returns bool. Collaborations: blank.
Responsibilities: Operator, equals, equals, returns bool.
Collaborations: blank.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include,
using, name space, s t d, string, class, public, bool, int, const, enum,
private. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for class Suits. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, string, right angled bracket.
Line 5: using name space s t d, semicolon. 
Line 6: blank. 
Line 7: class Suits. 
Line 8: left brace. 
Line 9: public, colon. 
Line 10, indented once: 2 forward slashes. Constructors. 

Line 11, indented once: Suits, left parentheses, right parentheses,
semicolon. 
Line 12, indented once: Suits, left parentheses, string, init String,
right parentheses, semicolon. 
Line 13, indented once: Suits, left parentheses, int init Int, right
parentheses, semicolon. 
Line 14, indented once: 2 forward slashes. Observers. 
Line 15, indented once: string to String, left parentheses, right
parentheses, const, semicolon. 
Line 16, indented once: int to Int, left parentheses, right
parentheses, const, semicolon. 
Line 17, indented once: 2 forward slashes. Relational operators. 
Line 18, indented once: bool operator, left angled bracket, left
parentheses, Suits other Suit, right parentheses, const, semicolon. 
Line 19, indented once: bool operator, equals, equals, left
parentheses, Suits other Suit, right parentheses, const, semicolon. 
Line 20: blank. 
Line 21, indented once: enum Suit, left brace, CLUBS, comma,
DIAMONDS, comma, HEARTS, comma, SPADES, right brace,
semicolon. 
Line 22: private, colon. 
Line 23, indented once: Suit my Suit, semicolon. 
Line 24: right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: include, using, name space, s
t d, class, public, int, string. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for class Values. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, string, right angled bracket.
Line 5: using name space s t d, semicolon. 
Line 6: blank. 
Line 7: class Values. 
Line 8: left brace. 
Line 9: public, colon. 
Line 10, indented once: 2 forward slashes. Constructors. 

Line 11, indented once: Values, left parentheses, right parentheses,
semicolon. 
Line 12, indented once: Values, left parentheses, string init String,
right parentheses, semicolon. 
Line 13, indented once: Values, left parentheses, int init Int, right
parentheses, semicolon.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: string,
const, int, bool, enum, private. 
Line 1, indented once: 2 forward slashes. Observers. 
Line 2, indented once: string to String, left parentheses, right
parentheses, const, semicolon. 
Line 3, indented once: int to Int, left parentheses, right parentheses,
const, semicolon. 
Line 4, indented once: 2 forward slashes. Relational operators. 
Line 5, indented once: bool operator, left angled bracket, left
parentheses, Values other Value, right parentheses, const,
semicolon. 
Line 6, indented once: bool operator, equals, equals, left
parentheses, Values other Value, right parentheses, const,
semicolon. 
Line 7: blank. 
Line 8, indented once: enum Value, left brace, ACE, comma, TWO,
comma, THREE, comma, FOUR, comma, FIVE, comma, SIX,
comma, SEVEN, comma. 
Line 9, indented multiple times: EIGHT, comma, NINE, comma,
TEN, comma, JACK, comma, QUEEN, comma, KING, right brace,
semicolon. 
Line 10: private, colon. 
Line 11, indented once: Value my Value, semicolon. 
Line 12: right brace, semicolon.
Back to Figure
Program code. The words in the variable names and function calls
are merged. The code contains the following keywords: include,

class, public, const, bool, private, int. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for class card. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Values dot h, double quotes. 
Line 5: hash include, double quotes, Suits dot h, double quotes. 
Line 6: class Card. 
Line 7: left brace. 
Line 8: public, colon. 
Line 9, indented once: 2 forward slashes. Constructors. 
Line 10, indented once: Card, left parentheses, right parentheses,
semicolon. 
Line 11, indented once: Card, left parentheses, Values init Value,
comma, Suits init Suit, right parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Observers. 
Line 13, indented once: Values Get Value, left parentheses, right
parentheses, const, semicolon. 
Line 14, indented once: Suits Get Suit, left parentheses, right
parentheses, const, semicolon. 
Line 15, indented once: 2 forward slashes. Relational operators. 
Line 16, indented once: bool operator, left angled bracket, left
parentheses, const Card ampersand other Card, right parentheses,
const, semicolon. 
Line 17, indented once: bool operator, right angled bracket, left
parentheses, const Card ampersand other Card, right parentheses,
const, semicolon. 
Line 18, indented once: bool operator, equals, equals, left
parentheses, const Card ampersand other Card, right parentheses,
const, semicolon. 
Line 19, indented once: bool operator, left angled bracket, equals,
left parentheses, const Card ampersand other Card, right
parentheses, const, semicolon. 
Line 20, indented once: bool operator, right angled bracket, equals,
left parentheses, const Card ampersand other Card, right
parentheses, const, semicolon. 
Line 21, indented once: bool operator, exclamation mark, equals, left
parentheses, const Card ampersand other Card, right parentheses,
const, semicolon. 
Line 22: private, colon. 

Line 23, indented once: Values my Value, semicolon. 
Line 24, indented once: Suits my Suit, semicolon. 
Line 25, indented once: int rank, left parentheses, right parentheses,
const, semicolon. 2 forward slashes. Helper function for relational o
p s. 
Line 26: right brace, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the keyword include. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class card. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, double quotes, Card dot h, double quotes. 
Line 6: blank. 
Line 7: Card, colon, colon, Card, left parentheses, right parentheses.
Line 8: left brace, right brace. 
Line 9: 2 forward slashes followed by asterisks till the end of the line.
Line 10: Card, colon, colon, Card, left parentheses, Values init Value,
comma, Suits init Suit, right parentheses. 
Line 11: left brace. 
Line 12, indented once: my Value equals init Value, semicolon. 
Line 13, indented once: my Suit equals init Suit, semicolon. 
Line 14: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: const,
return, bool, int. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: Values Card, colon, colon, Get Value, left parentheses, right
parentheses, const. 
Line 3: left brace, return my Value, semicolon, right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: Suits Card, colon, colon, Get Suit, left parentheses, right
parentheses, const. 

Line 6: left brace, return my Suit, semicolon, right brace. 
Line 7: 2 forward slashes followed by asterisks till the end of the line.
Line 8: bool Card, colon, colon, operator, left angled bracket, left
parentheses, const Card, ampersand other Card, right parentheses,
const. 
Line 9: left brace, return rank, left parentheses, right parentheses,
left angled bracket, other Card dot rank, left parentheses, right
parentheses, semicolon, right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: bool Card, colon, colon, operator, right angled bracket, left
parentheses, const Card ampersand other Card, right parentheses,
const. 
Line 12: left brace, return rank, left parentheses, right parentheses,
right angled bracket, other Card dot rank, left parentheses, right
parentheses, semicolon, right brace. 
Line 13: 2 forward slashes followed by asterisks till the end of the
line. 
Line 14: bool Card, colon, colon, operator, left angled bracket,
equals sign, left parentheses, const Card ampersand other Card,
right parentheses, const. 
Line 15: left brace, return rank, left parentheses, right parentheses,
left angled bracket, equals sign, other Card dot rank, left
parentheses, right parentheses, semicolon, right brace. 
Line 16: 2 forward slashes followed by asterisks till the end of the
line. 
Line 17: bool Card, colon, colon, operator, right angled bracket,
equals sign, left parentheses, const Card ampersand other Card,
right parentheses, const. 
Line 18: left brace, return rank, left parentheses, right parentheses,
right angled bracket, equals sign, other Card dot rank, left
parentheses, right parentheses, semicolon, right brace. 
Line 19: 2 forward slashes followed by asterisks till the end of the
line. 
Line 20: bool Card, colon, colon, operator, exclamation mark, equals
sign, left parentheses, const Card ampersand other Card, right
parentheses, const. 
Line 21: left brace, return rank, left parentheses, right parentheses,
exclamation mark, equals sign, other Card dot rank, left

parentheses, right parentheses, semicolon, right brace. 
Line 22: 2 forward slashes followed by asterisks till the end of the
line. 
Line 23: int Card, colon, colon, rank, left parentheses, right
parentheses, const. 
Line 24: left brace. 
Line 25, indented once: return my Suit dot to Int, left parentheses,
right parentheses, asterisk, 13, plus, my Value dot to Int, left
parentheses, right parentheses, semicolon. 
Line 26: right brace.
Back to Figure
The description of the C R C card is as follows. Class Name, colon,
Deck. Superclass, colon, None. Subclasses, colon, None.
Responsibilities: Create Deck, left parentheses, right parentheses.
Collaborations: deque, comma, Values, coma, Suits, comma, Card.
Responsibilities: Empty returns bool. Collaborations: deque.
Responsibilities: Is There returns bool. Collaborations: find.
Responsibilities: Size returns int. Collaborations: deque.
Responsibilities: void Shuffle. Collaborations: Random, underscore,
shuffle. Responsibilities: Deal returns card. Collaborations: Card.
Back to Figure
Program code. The code contains the following keywords: include,
class, public, bool, const. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. SPECIFICATION File for class Deck. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, double quotes, Card dot h, double quotes. 
Line 5: hash include, left angled bracket, deque, right angled
bracket. 
Line 6: blank. 
Line 7: class Deck. 
Line 8: left brace. 
Line 9: public, colon. 
Line 10, indented once: 2 forward slashes. Constructor. 
Line 11, indented once: Deck, left parentheses, right parentheses,

semicolon. 
Line 12, indented once: 2 forward slashes. Observers. 
Line 13, indented once: bool empty, left parentheses, right
parentheses, const, semicolon.
Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords: bool, const, int, void, private,
deque. 
Line 1, indented once: bool is There, left parentheses, Card a Card,
right parentheses, const, semicolon. 
Line 2, indented once: int size, left parentheses, right parentheses,
const, semicolon. 
Line 3, indented once: 2 forward slashes. Action responsibilities. 
Line 4, indented once: void Shuffle, left parentheses, right
parentheses, semicolon. 2 forward slashes. Reorders the cards. 
Line 5, indented once: Card Deal, left parentheses, right
parentheses, semicolon. 2 forward slashes. Takes one card from
deck. 
Line 6: private, colon. 
Line 7, indented once: deque, left angled bracket, Card, right angled
bracket, the Deck, semicolon. 
Line 8: right brace, semicolon.
Back to Figure
Program code. The words in the function names are merged. The
code contains the following keywords: include, for. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class Deck. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, double quotes, Deck dot h, double quotes. 
Line 6: hash include, left angled bracket, algorithm, right angled
bracket. 
Line 7: hash include, left angled bracket, chrono, right angled
bracket. 
Line 8: hash include, left angled bracket, random, right angled

bracket. 
Line 9: blank. 
Line 10: Deck, colon, colon, Deck, left parentheses, right
parentheses. 
Line 11: left brace. 
Line 12, indented once: for, left parentheses, Suits, colon, colon,
Suit, suit, equals, Suits, colon, colon, CLUBS, semicolon, suit, left
angled bracket, equals, Suits, colon, colon, SPADES, semicolon. 
Line 13, indented multiple times: suit equals Suits, colon, colon, Suit,
left parentheses, suit plus 1, right parentheses. 
Line 14, indented twice: for, left parentheses, Values, colon, colon,
Value value equals Values, colon, colon, A C E, semicolon, value, left
angled bracket, equals sign, Values, colon, colon, KING, semicolon. 
Line 15, indented multiple times: value equals Values, colon, colon,
Value, left parentheses, value plus 1, right parentheses. 
Line 16, indented twice: left brace. 
Line 17, indented thrice: the Deck dot push underscore back, left
parentheses, Card, left parentheses, value, comma, suit, right
parentheses, right parentheses, semicolon. 
Line 18, indented twice: right brace. 
Line 19: right brace.
Back to Figure
Program code. The words in the function names and variable names
are merged. The code contains the following keywords: bool, const,
return, int, void, unsigned, s t d.
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: blank. 
Line 3: bool Deck, colon, colon, empty, left parentheses, right
parentheses, const. 
Line 4: left brace, return, the Deck dot empty, left parentheses, right
parentheses, semicolon, right brace. 
Line 5: blank. 
Line 6: 2 forward slashes followed by asterisks till the end of the line.
Line 7: blank. 
Line 8: bool Deck, colon, colon, is There, left parentheses, Card a
Card, right parentheses, const. 
Line 9: left brace, return find, left parentheses, the Deck dot begin,

left parentheses, right parentheses, comma, the Deck dot end, left
parentheses, right parentheses, comma, a Card, right parentheses. 
Line 10, indented multiple times: exclamation mark, equals sign, the
Deck dot end, left parentheses, right parentheses, semicolon, right
brace. 
Line 11: blank. 
Line 12: 2 forward slashes followed by asterisks till the end of the
line. 
Line 13: blank. 
Line 14: int Deck, colon, colon, size, left parentheses, right
parentheses, const. 
Line 15: left brace, return the Deck dot size, left parentheses,
semicolon, right brace. 
Line 16: blank. 
Line 17: 2 forward slashes followed by asterisks till the end of the
line. 
Line 18: blank. 
Line 19: void Deck, colon, colon, Shuffle, left parentheses, right
parentheses. 
Line 20: left brace. 
Line 21, indented once: unsigned seed equals s t d, colon, colon,
chrono, colon, colon, system underscore clock, colon, colon, now,
left parentheses, right parentheses, dot, time underscore since
underscore epoch, left parentheses, right parentheses, dot. Count,
left parentheses, right parentheses, semicolon. 
Line 22, indented once: shuffle, left parentheses, the Deck dot
begin, left parentheses, right parentheses, comma, the Deck dot
end, left parentheses, right parentheses, comma, s t d, colon, colon,
default, underscore, random, underscore, engine, left parentheses,
seed, right parentheses, semicolon. 
Line 23: right brace. 
Line 24: blank. 
Line 25: 2 forward slashes followed by asterisks till the end of the
line. 
Line 26: blank. 
Line 27: Card Deck, colon, colon, Deal, left parentheses, right
parentheses. 
Line 28: left brace. 
Line 29, indented once: Card next equals the Deck dot front, left

parentheses, right parentheses, semicolon. 2 forward slashes, Get
the next card. 
Line 30, indented once: the Deck dot pop underscore front, left
parentheses, right parentheses, semicolon. 2 forward slashes,
Delete it from the deck. 
Line 31, indented once: return next, semicolon. 2 forward slashes,
Return it. 
Line 32: right brace.
Back to Figure
Line 1: map, left angled bracket, string, comma, Suit, right angled
bracket, lookup, semicolon. Line 2: lookup, left square bracket,
double quotes, CLUBS, double quotes, right square bracket, equals,
CLUBS, semicolon.
Back to Figure
my Suit equals lookup, left square bracket, init String, right square
bracket, semicolon.
Back to Figure
transform, left parentheses, init String dot begin, left parentheses,
right parentheses, comma, init String dot end, left parentheses, right
parentheses, comma, init String dot begin, left parentheses, right
parentheses, comma, to upper, right parentheses, semicolon.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: include, map, c c type,
algorithm, string, lookup, transform. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class suits. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, double quotes, Suits dot h, double quotes. 
Line 6: hash include, left angled bracket, map, right angled bracket. 
Line 7: hash include, left angled bracket, c c type, right angled

bracket. 2 forward slashes. For to upper. 
Line 8: hash include, left angled bracket, algorithm, right angled
bracket. 2 forward slashes. For transform. 
Line 9: hash include, left angled bracket, string, right angled bracket.
Line 10: blank. 
Line 11: Suits, colon, colon, Suits, left parentheses, right
parentheses. 
Line 12: left brace, my Suit equals CLUBS, semicolon, right brace. 
Line 13: 2 forward slashes followed by asterisks till the end of the
line. 
Line 14: Suits, colon, colon, Suits, left parentheses, string init String,
right parentheses. 
Line 15: left brace. 
Line 16, indented once: 2 forward slashes. Create a mapping
between strings and enums. 
Line 17, indented once: map, left angled bracket, string, comma,
Suit, right angled bracket, lookup, semicolon. 
Line 18, indented once: lookup, left square bracket, double quotes,
CLUBS, double quotes, right square bracket, equals, CLUBS,
semicolon. 
Line 19, indented once: lookup, left square bracket, double quotes,
DIAMONDS, double quotes, right square bracket, equals,
DIAMONDS, semicolon. 
Line 20, indented once: lookup, left square bracket, double quotes,
HEARTS, double quotes, right square bracket, equals, HEARTS,
semicolon. 
Line 21, indented once: lookup, left square bracket, double quotes,
SPADES, double quotes, right square bracket, equals, SPADES,
semicolon. 
Line 22, indented once: 2 forward slashes. Convert the string to
uppercase. 
Line 23, indented once: transform, left parentheses, init String dot
begin, left parentheses, right parentheses, comma, init String dot
end, left parentheses, right parentheses, comma. 
Line 24, indented multiple times: init String dot begin, left
parentheses, right parentheses, comma, to upper, right
parentheses, semicolon. 
Line 25, indented once: 2 forward slashes. Get the corresponding
enum. 

Line 26, indented once: my Suit equals lookup, left square bracket,
init string, right square bracket, semicolon. 
Line 27: right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: string, const, return, int, bool. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: Suits, colon, colon, Suits, left parentheses, int init Int, right
parentheses. 
Line 3: left brace, my Suit equals Suit, left parentheses, init Int, right
parentheses, semicolon, right brace. 
Line 4: 2 forward slashes followed by asterisks till the end of the line.
Line 5: string Suits, colon, colon, to String, left parentheses, right
parentheses, const. 
Line 6: left brace. 
Line 7, indented once: string suit String, left square bracket, 4, right
square bracket, equals, left brace, double quotes, CLUBS, double
quotes, comma, double quotes, DIAMONDS, double quotes,
comma, double quotes, HEARTS, comma, double quotes, SPADES,
double quotes, right brace, semicolon. 
Line 8, indented once: return suit String, left square bracket, my
Suit, right square bracket, semicolon. 
Line 9: right brace. 
Line 10: 2 forward slashes followed by asterisks till the end of the
line. 
Line 11: int Suits, colon, colon, to Int, left parentheses, right
parentheses, const. 
Line 12: left brace, return int, left parentheses, my Suit, right
parentheses, semicolon, right brace. 
Line 13: 2 forward slashes followed by asterisks till the end of the
line. 
Line 14: bool Suits, colon, colon, operator, left angled bracket, left
parentheses, Suits other Suit, right parentheses, const. 
Line 15: left brace. 
Line 16, indented once: return my Suit, left angled brackets, other
Suit dot to Int, left parentheses, right parentheses, semicolon. 
Line 17: right brace. 

Line 18: 2 forward slashes followed by asterisks till the end of the
line. 
Line 19: bool Suits, colon, colon, operator, equals, equals, left
parentheses, Suits other Suit, right parentheses, const. 
Line 20: left brace. 
Line 21, indented once: return my Suit, equals, equals, other Suit
dot to Int, left parentheses, right parentheses, semicolon. 
Line 22: right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: include, map, c c type,
algorithm, string. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. IMPLEMENTATION FILE for class Values.
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: blank. 
Line 5: hash include, double quotes, Values dot h, double quotes. 
Line 6: hash include, left angled bracket, map, right angled bracket. 
Line 7: hash include, left angled bracket, c c type, right angled
bracket. 2 forward slashes. For to upper. 
Line 8: hash include, left angled bracket, algorithm, right angled
bracket. 2 forward slashes. For transform. 
Line 9: hash include, left angled bracket, string, right angled bracket.
Line 10: blank. 
Line 11: Values, colon, colon, Values, left parentheses, right
parentheses. 
Line 12: left brace, my Value equals ACE, semicolon, right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: string, map, lookup, to upper,
return, bool, const. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: blank. 
Line 3: Values, colon, colon, Values, left parentheses, string init
String, right parentheses. 

Line 4: left brace. 
Line 5, indented once: 2 forward slashes. Create a mapping
between strings and enums. 
Line 6, indented once: map, left angled bracket, string, comma,
Value, right angled bracket, lookup, semicolon. 
Line 7, indented once: lookup, left square bracket, double quotes,
ACE, double quotes, right square bracket, equals, ACE, semicolon. 
Line 8, indented once: lookup, left square bracket, double quotes,
TWO, double quotes, right square bracket, equals, TWO, semicolon.
Line 9, indented once: lookup, left square bracket, double quotes,
THREE, double quotes, right square bracket, equals, THREE,
semicolon.
Line 10, indented once: lookup, left square bracket, double quotes,
FOUR, double quotes, right square bracket, equals, FOUR,
semicolon.
Line 11, indented once: lookup, left square bracket, double quotes,
FIVE, double quotes, right square bracket, equals, FIVE, semicolon.
Line 12, indented once: lookup, left square bracket, double quotes,
SIX, double quotes, right square bracket, equals, SIX, semicolon.
Line 13, indented once: lookup, left square bracket, double quotes,
SEVEN, double quotes, right square bracket, equals, SEVEN,
semicolon.
Line 14, indented once: lookup, left square bracket, double quotes,
EIGHT, double quotes, right square bracket, equals, EIGHT,
semicolon.
Line 15, indented once: lookup, left square bracket, double quotes,
NINE, double quotes, right square bracket, equals, NINE, semicolon.
Line 16, indented once: lookup, left square bracket, double quotes,
TEN, double quotes, right square bracket, equals, TEN, semicolon.
Line 17, indented once: lookup, left square bracket, double quotes,
JACK, double quotes, right square bracket, equals, JACK,
semicolon.
Line 18, indented once: lookup, left square bracket, double quotes,
QUEEN, double quotes, right square bracket, equals, QUEEN,
semicolon.
Line 19, indented once: lookup, left square bracket, double quotes,
KING, double quotes, right square bracket, equals, KING,
semicolon.
Line 20, indented once: 2 forward slashes. Convert the string to

uppercase. 
Line 21, indented once: transform, left parentheses, init String dot
begin, left parentheses, right parentheses, comma, init String dot
end, left parentheses, right parentheses, comma. 
Line 22, indented multiple times: init String dot begin, left
parentheses, right parentheses, to upper, right parentheses,
semicolon. 
Line 23, indented once: 2 forward slashes. Get the corresponding
enum. 
Line 24, indented once: my Value equals lookup, left square bracket,
init String, right square bracket, semicolon. 
Line 25: right brace. 
Line 26: blank. 
Line 27: 2 forward slashes followed by asterisks till the end of the
line. 
Line 28: blank. 
Line 29: Values, colon, colon, Values, left parentheses, int init Int,
right parentheses. 
Line 30: left brace, my Value, equals, Value, left parentheses, init Int,
right parentheses, semicolon, right brace. 
Line 31: blank. 
Line 32: 2 forward slashes followed by asterisks till the end of the
line. 
Line 33: blank. 
Line 34: string Values, colon, colon, to String, left parentheses, right
parentheses, const. 
Line 35: left brace. 
Line 36, indented once: string value String, left square bracket, 13,
right square bracket, equals, left brace, double quotes, ACE, double
quotes, comma, double quotes, TWO, double quotes, comma,
double quotes, THREE, double quotes, comma, double quotes,
FOUR, double quotes, comma. 
Line 37, indented multiple times: double quotes, FIVE, double
quotes, comma, double quotes, SIX, double quotes, comma, double
quotes, SEVEN, double quotes, comma, double quotes, EIGHT,
double quotes, comma, double quotes, NINE, double quotes,
comma, double quotes, TEN, double quotes, comma, double
quotes, JACK, double quotes, comma. 
Line 38, indented multiple times: double quotes, QUEEN, double

quotes, comma, double quotes, KING, double quotes, right brace,
semicolon. 
Line 39, indented once: return value String, left square bracket, my
Value, right square bracket, semicolon. 
Line 40: right brace. 
Line 41: blank. 
Line 42: 2 forward slashes followed by asterisks till the end of the
line. 
Line 43: blank. 
Line 44: int Values, colon, colon, to Int, left parentheses, right
parentheses, const. 
Line 45: left brace, return int, left parentheses, my Value, right
parentheses, semicolon, right brace. 
Line 46: blank. 
Line 47: 2 forward slashes followed by asterisks till the end of the
line. 
Line 48: blank. 
Line 49: int Values, colon, colon, to Int, left parentheses, right
parentheses, const. 
Line 50: left brace, return int, left parentheses, my Value, right
parentheses, semicolon, right brace. 
Line 51: blank. 
Line 52: 2 forward slashes followed by asterisks till the end of the
line. 
Line 53: blank. 
Line 54: bool Values, colon, colon, operator, left angled bracket, left
parentheses, Values other Value, right parentheses, const.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: return, bool, const. 
Line 1: left brace. 
Line 2, indented once: return my Value, left angled bracket, other
Value dot to Int, left parentheses, right parentheses, semicolon. 
Line 3: right brace. 
Line 4: blank. 
Line 5: 2 forward slashes followed by asterisks till the end of the line.
Line 6: blank. 

Line 7: bool Values, colon, colon, operator, equal, equal, left
parentheses, Values other Value, right parentheses, const. 
Line 8: left brace. 
Line 9, indented once: return my Value, equals, equals, other Value
dot to Int, left parentheses, right parentheses, semicolon. 
Line 10: right brace.
Back to Figure
Program code. The words in the variable names are merged. The
code contains the following keywords: include, using, name space, s
t d, int, main, c out, end l, for. 
Line 1: 2 forward slashes followed by asterisks till the end of the line.
Line 2: 2 forward slashes. Driver for class Deck. 
Line 3: 2 forward slashes followed by asterisks till the end of the line.
Line 4: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 5: hash include, double quotes, Deck dot h, double quotes. 
Line 6: using name space s t d, semicolon. 
Line 7: blank. 
Line 8: int main, left parentheses, right parentheses. 
Line 9: left brace. 
Line 10, indented once: 2 forward slashes. Create a deck of 52
cards in order. 
Line 11, indented once: Deck my Deck, semicolon. 
Line 12, indented once: c out, 2 left angled brackets, double quotes,
The deck has, blank space, double quotes, 2 left angled brackets,
my Deck dot size, left parentheses, right parentheses, 2 left angled
brackets, double quotes, blank space, cards, period, double quotes. 
Line 13, indented twice: 2 left angled brackets, end l, 2 left angled
brackets, end l, semicolon. 
Line 14, indented once: 2 forward slashes. Deal out the first ten in
order. 
Line 15, indented once: for, left parentheses, int i equals 1,
semicolon, i less than or equal to 10, semicolon, plus, plus, i, right
parentheses. 
Line 16, indented once: left brace. 
Line 17, indented twice: Card a Card equals my Deck dot Deal, left
parentheses, right parentheses, semicolon. 

Line 18, indented twice: c out, 2 left angled brackets, a Card dot Get
Value, left parentheses, right parentheses, dot, to String, left
parentheses, right parentheses, 2 left angled brackets, double
quotes, blank space, of, blank space, double quotes. 
Line 19, indented thrice: 2 left angled brackets, a Card dot Get Suit,
left parentheses, right parentheses, dot, to String, left parentheses,
right parentheses, 2 left angled brackets, end l, semicolon. 
Line 20, indented once: right brace. 
Line 21, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, The deck has, blank space, double
quotes, 2 left angled brackets, my Deck dot size, left parentheses,
right parentheses.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: c out, end l,
string, c in, if, else, end l, while. 
Line 1, indented twice: 2 left angled brackets, double quotes, blank
space, cards, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 2, indented once: 2 forward slashes. Shuffle the remaining
cards. 
Line 3, indented once: c out, 2 left angled brackets, double quotes,
Shuffling, double quotes, 2 left angled brackets, end l, 2 left angled
brackets, end l, semicolon. 
Line 4, indented once: my Deck dot Shuffle, left parentheses, right
parentheses, semicolon. 
Line 5, indented once: 2 forward slashes. Input a card. 
Line 6, indented once: c out, 2 left angled brackets, double quotes,
Enter the name of a suit, colon, blank space, double quotes,
semicolon. 
Line 7, indented once: string suit, semicolon. 
Line 8, indented once: c in, 2 right angled brackets, suit, semicolon. 
Line 9, indented once: c out, 2 left angled brackets, double quotes,
Enter the name of a card, left parentheses, ace, comma, two,
comma, ellipsis, comma, king, right parentheses, colon, blank
space, double quotes, semicolon. 
Line 10, indented once: string value, semicolon. 

Line 11, indented once: c in, 2 right angled brackets, value,
semicolon. 
Line 12, indented once: 2 forward slashes. Check if card is in the
deck. 
Line 13, indented once: Card card, left parentheses, value, comma,
suit, right parentheses, semicolon. 
Line 14, indented once: if, left parentheses, my Deck dot is There,
left parentheses, card, right parentheses, right parentheses. 
Line 15, indented twice: c out, 2 left angled brackets, double quotes,
The card is in the deck, period, double quotes, 2 left angled
brackets, end l, semicolon. 
Line 16, indented once: else. 
Line 17, indented twice: c out, 2 left angled brackets, double quotes,
The card has already been dealt, period, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 18, indented once: 2 forward slashes. Deal out the remaining
cards. 
Line 19, indented once: c out, 2 left angled brackets, double quotes,
The remaining contents of the deck are, colon, double quotes, 2 left
angled brackets, end l, semicolon. 
Line 20, indented once: while, left parentheses, exclamation mark,
my Deck dot empty, left parentheses, right parentheses, right
parentheses. 
Line 21, indented once: left brace. 
Line 22, indented twice: Card a Card equals my Deck dot Deal, left
parentheses, right parentheses, semicolon. 
Line 23, indented twice: c out, 2 left angled brackets, a Card dot Get
Value, left parentheses, right parentheses, dot, to String, left
parentheses, right parentheses, 2 left angled brackets, double
quotes, blank space, of, double quotes. 
Line 24, indented thrice: 2 left angled brackets, a Card dot Get Suit,
left parentheses, right parentheses, dot, to String, left parentheses,
right parentheses, 2 left angled brackets, end l, semicolon. 
Line 25, indented once: right brace. 
Line 26, indented once: c out, 2 left angled brackets, end l, 2 left
angled brackets, double quotes, The deck has, blank space, double
quotes, 2 left angled brackets, my Deck dot size, left parentheses,
right parentheses. 
Line 27, indented twice: 2 left angled brackets, double quotes, blank

space, cards, period, double quotes, 2 left angled brackets, end l,
semicolon. 
Line 28: right brace.
Back to Figure
Line 1: The deck has 52 cards, period. Line 2: blank. Line 3: ACE of
CLUBS. Line 4: TWO of CLUBS. Line 5: THREE of CLUBS. Line 6:
FOUR of CLUBS. Line 7: FIVE of CLUBS. Line 8: SIX of CLUBS.
Line 9: SEVEN of CLUBS. Line 10: EIGHT of CLUBS.
Back to Figure
Line 11: NINE of CLUBS. Line 12: TEN of CLUBS. Line 13: blank.
Line 14: The deck has 42 cards, period. Line 15: Shuffling. Line 16:
blank. Line 17: Enter the name of a suit, colon, Clubs. In line 17, the
word Clubs is shaded. Line 18: Enter the name of a card, left
parentheses, ace, comma, two, comma, ellipsis, comma, king, right
parentheses, colon, jack. In line 18, the word jack is shaded. Line
19: The card is in the deck, period. Line 20: The remaining contents
of the deck are, colon. Line 21: QUEEN of SPADES. Line 22: NINE
of SPADES. Line 23: TWO of SPADES. Line 24: KING of
DIAMONDS. Line 25: EIGHT of DIAMONDS. Line 26: FOUR of
SPADES. Line 27: SEVEN of HEARTS. Line 28: NINE of HEARTS.
Line 29: SIX of DIAMONDS. Line 30: TWO of DIAMONDS. Line 31:
FIVE of HEARTS. Line 32: FIVE of DIAMONDS. Line 33: TEN of
HEARTS. Line 34: KING of SPADES. Line 35: QUEEN of CLUBS.
Line 36: JACK of HEARTS. Line 37: TEN of SPADES. Line 38: SIX
of HEARTS. Line 39: JACK of DIAMONDS. Line 40: JACK of
SPADES. Line 41: TEN of DIAMONDS. Line 42: EIGHT of HEARTS.
Line 43: FOUR of DIAMONDS. Line 44: ACE of HEARTS. Line 45:
TWO of HEARTS. Line 46: THREE of SPADES. Line 47: SEVEN of
SPADES. Line 48: SIX of SPADES. Line 49: THREE of DIAMONDS.
Line 50: SEVEN of DIAMONDS. Line 51: QUEEN of DIAMONDS.
Line 52: EIGHT of SPADES. Line 53: KING of CLUBS. Line 54:
FOUR of HEARTS. Line 55: QUEEN of HEARTS. Line 56: ACE of
SPADES.
Back to Figure

Line 57: KING of HEARTS. Line 58: ACE of DIAMONDS. Line 59:
JACK of CLUBS. Line 60: THREE of HEARTS. Line 61: FIVE of
SPADES. Line 62: NINE of DIAMONDS. Line 63: blank. Line 64: The
deck has 0 cards, period.
Back to Figure
The pane on the left lists the names of the cards on the deck in 2
columns. The button below the left pane is labeled Shuffle. The pane
on the right displays the selected card which in this case is the Ace
of hearts.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include, Q t
Widgets, class, public, null p t r, private, slots, void, int. 
Line 1: hash include, left angled brackets, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: class Card Deck Main Window, colon, public, Q Main
Window. 
Line 4: left brace. 
Line 5, indented once: Q underscore OBJECT. 
Line 6: blank. 
Line 7: public, colon. 
Line 8, indented once: Card Deck Main Window, left parentheses, Q
Widget, asterisk, parent, equals, null p t r, right parentheses,
semicolon. 
Line 9, indented once: hyphen, Card Deck Main Window, left
parentheses, right parentheses, semicolon. 
Line 10: blank. 
Line 11: private slots, colon. 
Line 12, indented once: void Handle Click On Card, left parentheses,
int row, comma, int column, right parentheses, semicolon. 
Line 13, indented once: void Handle Shuffle Button Clicked, left
parentheses, right parentheses, semicolon. 
Line 14: blank. 
Line 15: private, colon. 

Line 16, indented once: Q Table Widget asterisk table, semicolon. 
Line 17, indented once: Q Label asterisk image, semicolon. 
Line 18, indented once: void Init Table, left parentheses, right
parentheses, semicolon. 
Line 19, indented once: void Init Label, left parentheses, right
parentheses, semicolon. 
Line 20, indented once: void Display Image, left parentheses, int
row, right parentheses, semicolon. 
Line 21: right brace, semicolon.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: null p t r,
this, int. 
Line 1: Card Deck Main Window, colon, colon, Card Deck Main
Window, left parentheses, Q Widget asterisk parent, right
parentheses, colon, Q Main Window, left parentheses, parent, right
parentheses. 
Line 2: left brace. 
Line 3, indented once: table equals null p t r, semicolon. 
Line 4, indented once: Init Table, left parentheses, right
parentheses, semicolon. 
Line 5, indented once: Init Label, left parentheses, right
parentheses, semicolon. 
Line 6, indented once: Q Push Button asterisk shuffle Button equals
new Q Push Button, left parentheses, double quotes, shuffle, double
quotes, right parentheses, semicolon. 
Line 7, indented once: 2 forward slashes. Create a grid layout and
add three widgets to it. 
Line 8, indented once: Q Grid Layout asterisk layout equals new Q
Grid Layout, semicolon. 
Line 9, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, table, comma, 0, comma, 0, right
parentheses, semicolon. 
Line 10, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, image, comma, 0, comma, 1, right
parentheses, semicolon. 
Line 11, indented once: layout, hyphen, right angled bracket, add

Widget, left parentheses, shuffle Button, comma, 1, comma, 0, right
parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Create a widget and
have it use the layout. 
Line 13, indented once: Q Widget asterisk deck Widget equals new
Q Widget, left parentheses, this, right parentheses, semicolon. 
Line 14, indented once: deck Widget, hyphen, right angled bracket,
set Layout, left parentheses, layout, right parentheses, semicolon. 
Line 15, indented once: 2 forward slashes. Put the widget in the
window. 
Line 16, indented once: set Central Widget, left parentheses, deck
Widget, right parentheses, semicolon. 
Line 17, indented once: 2 forward slashes. Connect the events for
cell or button clicked to their handlers. 
Line 18, indented once: connect, left parentheses, table, comma,
SIGNAL, left parentheses, cell Clicked, left parentheses, int,
comma, int, right parentheses, right parentheses, comma, this,
comma. 
Line 19, indented multiple times: SLOT, left parentheses, Handle
Click On Card, left parentheses, int, comma, int, right parentheses,
right parentheses, right parentheses, semicolon. 
Line 20: blank. 
Line 21, indented once: connect, left parentheses, shuffle Button,
comma, SIGNAL, left parentheses, clicked, left parentheses, right
parentheses, right parentheses, comma, this, comma. 
Line 22, indented multiple times: SLOT, left parentheses, Handle
Shuffle Button Clicked, left parentheses, right parentheses, right
parentheses, right parentheses, semicolon. 
Line 23: right brace.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: void, int, for.
Line 1: void Card Deck Main Window, colon, colon, Init Table, left
parentheses, right parentheses, left brace. 
Line 2, indented once: Deck deck, semicolon. 
Line 3, indented once: deck dot Shuffle, left parentheses, right
parentheses, semicolon. 

Line 4, indented once: 2 forward slashes. Create the table. 
Line 5, indented once: table equals new Q Table Widget, left
parentheses, this, right parentheses, semicolon. 
Line 6, indented once: table, hyphen, right angled bracket, set
Column Count, left parentheses, 2, right parentheses, semicolon. 
Line 7, indented once: table, hyphen, right angled bracket, set Row
Count, left parentheses, deck dot size, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 8, indented once: 2 forward slashes. For the 52 cards in a
deck. 
Line 9, indented once: for, left parentheses, int i equals 0,
semicolon, i less than 52, semicolon, i plus, plus, right parentheses. 
Line 10: left brace. 
Line 11, indented once: 2 forward slashes. Get one and convert its
value and suit to Q Strings. 
Line 12, indented twice: Card card equals deck dot Deal, left
parentheses, right parentheses, semicolon. 
Line 13, indented twice: Q String value equals Q string, colon, colon,
from S t d String, left parentheses, card dot Get Value, left
parentheses, right parentheses, dot, to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 14, indented twice: Q String suit equals Q String, colon, colon,
from S t d String, left parentheses, card dot Get Suit, left
parentheses, right parentheses, dot, to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 15, indented twice: 2 forward slashes. Use the strings to create
an item for each column in the table. 
Line 16, indented twice: Q Table Widget Item asterisk card Value
Item equals new Q Table Widget Item, left parentheses, value, right
parentheses, semicolon. 
Line 17, indented twice: Q Table Widget Item asterisk card Suit Item
equals new Q Table Widget Item, left parentheses, suit, right
parentheses, semicolon. 
Line 18, indented twice: 2 forward slashes. Put the items in the table
at the row corresponding to the current iteration. 
Line 19, indented twice: table, hyphen, right angled bracket, set
Item, left parentheses, i, comma, 0, comma, card Value Item, right
parentheses, semicolon. 
Line 20, indented twice: table, hyphen, right angled bracket, set

Item, left parentheses, i, comma, 1, comma, card Suit Item, right
parentheses, semicolon. 
Line 21, indented once: right brace. 
Line 22: right brace.
Back to Table
Line 1: card Value Item, hyphen, right angled bracket, set Flags, left
parentheses, card Value Item, hyphen, right angled bracket, flags,
left parentheses, right parentheses, ampersand, tilde, Q t, colon,
colon, Item Is Editable, right parentheses, semicolon. Line 2: card
Suit Item, hyphen, right angled bracket, set Flags, left parentheses,
card Suit Item, hyphen, right angled bracket, flags, left parentheses,
right parentheses, ampersand, tilde, Q t, colon, colon, Item Is
Editable, right parentheses, semicolon.
Back to Table
Line 1: if, left parentheses, card dot Get Suit, left parentheses, right
parentheses, equals, equals, Suits, colon, colon, DIAMONDS, 2
pipes, card dot Get Suit, left parentheses, right parentheses, equals,
equals, Suits, colon, colon, HEARTS, right parentheses. Line 2: left
brace. Line 3, indented once: Q Brush brush, left parentheses, Q t,
colon, colon, red, right parentheses, semicolon. Line 4, indented
once: card Value Item, hyphen, right angled bracket, set
Foreground, left parentheses, brush, right parentheses, semicolon.
Line 5, indented once: card Suit Item, hyphen, right angled bracket,
set Foreground, left parentheses, brush, right parentheses,
semicolon. Line 6: right brace.
Back to Figure
Program code. The words in the function names and variable names
are merged. The code contains the following keywords: void, for, int.
Line 1: void Card Deck Main Window, colon, colon, Init Table, left
parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: Deck deck, semicolon. 
Line 4, indented once: deck dot Shuffle, left parentheses, right

parentheses, semicolon. 
Line 5, indented once: 2 forward slashes. Create the table. 
Line 6, indented once: table equals new Q Table Widget, left
parentheses, this, right parentheses, semicolon. 
Line 7, indented once: table, hyphen, right angled bracket, set
Column Count, left parentheses, 2, right parentheses, semicolon. 
Line 8, indented once: table, hyphen, right angled bracket, set Row
Count, left parentheses, deck dot size, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 9, indented once: 2 forward slashes. For the 52 cards in a
deck. 
Line 10, indented once: for, left parentheses, int i equals 0,
semicolon, i less than 52, semicolon, i, plus, plus, right parentheses.
Line 11, indented once: left brace. 
Line 12, indented twice: 2 forward slashes. Get one and convert its
value and suit to Q Strings. 
Line 13, indented twice: Card card equals deck dot Deal, left
parentheses, right parentheses, semicolon. 
Line 14, indented twice: Q String value equals Q String, colon,
colon, from S t d String, left parentheses, card dot Get Value, left
parentheses, right parentheses, dot to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 15, indented twice, Q string suit equals Q String, colon, colon,
from S t d String, left parentheses, card dot Get Suit, left
parentheses, right parentheses, dot, to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 16, indented twice: 2 forward slashes. Use the strings to create
an item for each column in the table. 
Line 17, indented twice: Q Table Widget Item asterisk card Value
Item equals new Q Table Widget Item, left parentheses, value, right
parentheses, semicolon. 
Line 18, indented twice: Q Table Widget Item asterisk card Suit Item
equals new Q Table Widget Item, left parentheses, suit, right
parentheses, semicolon. 
Line 19, indented twice: 2 forward slashes. Disable editing of the
items. 
Line 20, indented twice: card Value Item, hyphen, right angled
bracket, set Flags, left parentheses, card Value Item, hyphen, right
angled bracket, flags, left parentheses, right parentheses,

ampersand, tilde, Q t, colon, colon, Item Is Editable, right
parentheses, semicolon. 
Line 20 is shaded. 
Line 21, indented twice: card Suit Item, hyphen, right angled
bracket, set Flags, left parentheses, card Suit Item, hyphen, right
angled bracket, flags, left parentheses, right parentheses,
ampersand, tilde, Q t, colon, colon, Item Is Editable, right
parentheses, semicolon. 
Line 21 is shaded.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the keyword if. 
Line 1, indented twice: 2 forward slashes. Check if it’s a red suit and
change the text color of the items to red. 
Line 2, indented twice: left brace. 
Line 3, indented thrice: Q Brush brush, left parentheses, Q t, colon,
colon, red, right parentheses, semicolon. 
Line 4, indented thrice: card Value Item, hyphen, right angled
bracket, set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 5, indented thrice: card Suit Item, hyphen, right angled bracket,
set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 6, indented twice: right brace. 
Line 7, indented twice: 2 forward slashes. Put the items in the table
at the row corresponding to the current iteration. 
Line 8, indented twice: table, hyphen, right angled bracket, set Item,
left parentheses, i, comma, 0, comma, card Value Item, right
parentheses, semicolon. 
Line 9, indented twice: table, hyphen, right angled bracket, set Item,
left parentheses, i, comma, 1, comma, card Suit, Item, right
parentheses, semicolon. 
Line 10, indented once: right brace. 
Line 11: right brace.
Back to Table

Program code. The words in the function names and variable names
are merged. The code contains the keywords void and this. 
Line 1: void Card Deck Main Window, colon, colon, Init Label, left
parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: image equals new Q Label, left parentheses,
double quotes, double quotes, comma, this, right parentheses,
semicolon. 
Line 4, indented once: Display Image, left parentheses, 0, right
parentheses, semicolon. 
Line 5: right brace.
Back to Figure
Program code. The words in the variable names and function names
are merged. The code contains the keywords void and int. 
Line 1: void Card Deck Main Window, colon, colon, Display Image,
left parentheses, int row, right parentheses. 
Line 2: left brace. 
Line 3, indented once: 2 forward slashes. Get the text of each item
in the row into a Q String variable. 
Line 4, indented once: Q String value equals table, hyphen, right
angled bracket, item, left parentheses, row, comma, 0, right
parentheses, hyphen, right angled bracket, text, left parentheses,
right parentheses, semicolon. 
Line 5, indented once: Q String suit equals table, hyphen, right
angled bracket, item, left parentheses, row, comma, 1, right
parentheses, hyphen, right angled bracket, text, left parentheses,
right parentheses, semicolon. 
Line 6, indented once: 2 forward slashes. Use the value and suit to
form a string for the file name where the card’s picture is. 
Line 7, indented once: 2 forward slashes. And pass it to a method
that reads the file to construct a Q Pix map object. 
Line 8, indented once: Q Pix map card Image, left parentheses,
double quotes, colon, Card Images, forward slash, double quotes,
plus, value, plus, double quotes, underscore, double quotes, plus,
suit, plus, double quotes, dot p n g, double quotes, right
parentheses, semicolon. 
Line 9, indented once: 2 forward slashes. Use the label’s set Pix

map method to put the picture into it, comma, making some
adjustments. 
Line 10, indented once: image, hyphen, right angled bracket, set Pix
map, left parentheses, card Image dot scaled, left parentheses, 300,
comma, 300, comma, Q t, colon, colon, Keep Aspect Ratio, right
parentheses, right parentheses, semicolon. 
Line 11: right brace.
Back to Table
Program code. The words in the function names are merged. The
code contains the keywords void and int. Line 1: void Card Deck
Main Window, colon, colon, Handle Click On Card, left parentheses,
int row, comma, int column, right parentheses. Line 2: left brace.
Line 3, indented once: Display Image, left parentheses, row, right
parentheses, semicolon. Lien 4: right brace.
Back to Figure
Program code. The words in the function names are merged. The
code contains the keyword void. Line 1: void Card Deck Main
Window, colon, colon, Handle Shuffle Button Clicked, left
parentheses, right parentheses, left brace, Init Table, left
parentheses, right parentheses, semicolon, right brace.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the keywords void, null p t r, and if. 
Line 1: void Card Deck Main Window, colon, colon, Init Table, left
parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: Deck deck, semicolon. 
Line 4, indented once: deck dot Shuffle, left parentheses, right
parentheses, semicolon. 
Line 5: blank. 
Line 6, indented once: if, left parentheses, table, equals, equals, null
p t r, right parentheses. 
Line 7, indented once: left brace. 2 forward slashes. If the table

doesn’t already exist. 
Line 8, indented twice: table equals new Q Table Widget, left
parentheses, this, right parentheses, semicolon. 2 forward slashes.
Create it. 
Line 9, indented twice: table, hyphen, right angled bracket, set
Column Count, left parentheses, 2, right parentheses, semicolon. 
Line 10, indented twice: table, hyphen, right angled bracket, set Row
Count, left parentheses, deck dot size, left parentheses, right
parentheses, semicolon. Lines 6 to 10 are shaded.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: else, for, int,
if. 
Line 1: right brace. 
Line 2: else. 2 forward slashes. If it does, comma, just clear it. 
Line 3, indented once: table, hyphen, right angled bracket, clear, left
parentheses, right parentheses, semicolon. 
Line 4, indented once: for, left parentheses, int i equals 0,
semicolon, i less than 52, semicolon, i plus, plus, right parentheses. 
Line 5, indented once: left brace. 
Line 6, indented twice: 2 forward slashes. Get one and convert its
value and suit to Q Strings. 
Line 7, indented twice: Card card equals deck dot Deal, left
parentheses, right parentheses, semicolon. 
Line 8, indented twice: Q String value equals Q String, colon, colon,
from S t d String, left parentheses, card dot Get Value, left
parentheses, right parentheses, dot to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 9, indented twice: Q String suit equals Q String, colon, colon,
from S t d String, left parentheses, card dot Get Suit, left
parentheses, right parentheses, dot to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 10, indented twice: 2 forward slashes. Use the strings to create
an item for each column in the table. 
Line 11, indented twice: Q Table Widget Item asterisk card Value
Item equals new Q Table Widget Item, left parentheses, value, right
parentheses, semicolon. 

Line 12, indented twice: Q Table Widget Item asterisk card Suit Item
equals new Q Table Widget Item, left parentheses, suit, right
parentheses, semicolon. 
Line 13, indented twice: 2 forward slashes. Disable editing of the
items. 
Line 14, indented twice: card Value Item, hyphen, right angled
bracket, set Flags, left parentheses, card Value Item, hyphen, right
angled bracket, flags, left parentheses, right parentheses,
ampersand, tilde, Q t, colon, colon, Item Is Editable, right
parentheses, semicolon. 
Line 15, indented twice: card Suit Item, hyphen, right angled
bracket, set Flags, left parentheses, card Suit Item, hyphen, right
angled bracket, flags, left parentheses, right parentheses,
ampersand, tilde, Q t, colon, colon, Item Is Editable, right
parentheses, semicolon. 
Line 16, indented twice: 2 forward slashes. Check if it’s a red suit
and change the text color of the items to red. 
Line 17, indented twice: if, left parentheses, card dot Get Suit, left
parentheses, right parentheses, equals, equals, Suits, colon, colon,
DIAMONDS, 2 pipes, card dot Get Suit, left parentheses, right
parentheses, equals, equals, Suits, colon, colon, HEARTS, right
parentheses. 
Line 18, indented twice: left brace. 
Line 19, indented thrice: Q Brush brush, left parentheses, Q t, colon,
colon, red, right parentheses, semicolon. 
Line 20, indented thrice: card Value Item, hyphen, right angled
bracket, set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 21, indented thrice: card Suit Item, hyphen, right angled
bracket, set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 22: right brace. 
Line 23, indented twice: 2 forward slashes. Put the items in the table
at the row corresponding to the current iteration. 
Line 24, indented twice: table, hyphen, right angled bracket, set
Item, left parentheses, i, comma, 0, comma, card Value Item, right
parentheses, semicolon. 
Line 25, indented twice: table, hyphen, right angled bracket, set
Item, left parentheses, i, comma, 1, comma, card Suit Item, right

parentheses, semicolon. 
Line 26, indented once: right brace. 
Line 27: right brace.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include,
using, name space, s t d, int, main, char, return. 
Line 1: hash include, left angled bracket, Q Application, right angled
bracket. 
Line 2: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 3: hash include, left angled bracket, i o stream, right angled
bracket. 
Line 4: blank. 
Line 5: hash include, double quotes, Card Deck Main Window dot h,
double quotes. 
Line 6: hash include, double quotes, Deck dot h, double quotes. 
Line 7: blank. 
Line 8: using name space s t d, semicolon. 
Line 9: blank. 
Line 10: int main, left parentheses, int a r g c, comma, char asterisk,
a r g v, left square bracket, right square bracket, right parentheses. 
Line 11: left brace. 
Line 12, indented once: Q Application, a, left parentheses, a r g c,
comma, asterisk, a r g v, left square bracket, right square bracket,
right parentheses. 
Line 13, indented once: Deck deck, semicolon. 
Line 14, indented once: Card Deck Main Window, window,
semicolon. 
Line 15, indented once: window dot show, left parentheses, right
parentheses, semicolon. 
Line 16, indented once: return, a dot exec, left parentheses, right
parentheses, semicolon. 
Line 17: right brace.
Back to Figure

Program code. The words in the variable names and function names
are merged. The code contains the following keywords: include,
class, public, private, slots, void, null p t r, int. 
Line 1: hash include, left angled bracket, Q t Widgets, right angled
bracket. 
Line 2: blank. 
Line 3: class Card Deck Main Window, colon, public Q Main Window.
Line 4: left brace. 
Line 5, indented once: Q underscore OBJECT. 
Line 6: blank. 
Line 7: public, colon. 
Line 8, indented once: Card Deck Main Window, left parentheses, Q
Widget asterisk parent equals null p t r, right parentheses,
semicolon. 
Line 9, indented once: tilde, Card Deck Main Window, left
parentheses, right parentheses, semicolon. 
Line 10: blank. 
Line 11: private slots, colon. 
Line 12, indented once: void Handle Click On Card, left parentheses,
int row, comma, int column, right parentheses, semicolon. 
Line 13, indented once: void Handle Shuffle Button Clicked, left
parentheses, right parentheses, semicolon. 
Line 14: blank. 
Line 15: private, colon. 
Line 16, indented once: Q Table Widget asterisk table, semicolon. 
Line 17, indented once: Q Label asterisk image, semicolon. 
Line 18, indented once: void Init Table, left parentheses, right
parentheses, semicolon. 
Line 19, indented once: void Init Label, left parentheses, right
parentheses, semicolon. 
Line 20, indented once: void Display Image, left parentheses, int
row, right parentheses, semicolon. 
Line 21: right brace, semicolon.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the keywords include, null p t r, and
this. 

Line 1: hash include, double quotes, Card Deck Main Window dot h,
double quotes. 
Line 2: blank. 
Line 3: hash include, double quotes, Deck dot h, double quotes. 
Line 4: blank. 
Line 5: Card Deck Main Window, colon, colon, Card Deck Main
Window, left parentheses, Q Widget asterisk parent, right
parentheses, colon, Q Main Window, left parentheses, parent, right
parentheses. 
Line 6: left brace. 
Line 7, indented once: table equals null p t r, semicolon. 
Line 8: blank. 
Line 9, indented once: Init Table, left parentheses, right
parentheses, semicolon. 
Line 10, indented once: Init Label, left parentheses, right
parentheses, semicolon. 
Line 11, indented once: Q Push Button asterisk shuffle Button
equals new Q Push Button, left parentheses, double quotes, shuffle,
double quotes, right parentheses, semicolon. 
Line 12, indented once: 2 forward slashes. Create a grid layout and
add three widgets to it. 
Line 13, indented once: Q Grid Layout, asterisk, layout, equals new
Q Grid Layout, semicolon. 
Line 14, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, table, comma, 0, comma, 0, right
parentheses, semicolon. 
Line 15, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, image, comma, 0, comma, 1, right
parentheses, semicolon. 
Line 16, indented once: layout, hyphen, right angled bracket, add
Widget, left parentheses, shuffle Button, comma, 1, comma, 0, right
parentheses, semicolon. 
Line 17, indented once: 2 forward slashes. Create a widget and
have it use the layout. 
Line 18, indented once: Q Widget asterisk deck Widget equals new
Q Widget, left parentheses, this, right parentheses, semicolon. 
Line 19, indented once: deck Widget, hyphen, right angled bracket,
set Layout, left parentheses, layout, right parentheses, semicolon. 
Line 20, indented once: 2 forward slashes. Put the widget in the

window. 
Line 21, indented once: set Central Widget, left parentheses, deck
Widget, right parentheses, semicolon. 
Line 22, indented once: 2 forward slashes. Connect the events for
cell or button clicked to their handlers. 
Line 23, indented once: connect, left parentheses, table, comma,
SIGNAL, left parentheses, cell Clicked, left parentheses, int,
comma, int, right parentheses, right parentheses, comma, this,
comma. 
Line 24, indented multiple times: SLOT, left parentheses, Handle
Click On Card, left parentheses, int, comma, int, right parentheses,
right parentheses, right parentheses, semicolon. 
Line 25: blank. 
Line 26, indented once: connect, left parentheses, shuffle Button,
comma, SIGNAL, LEFT PARENTHESES, clicked, left parentheses,
right parentheses, right parentheses, comma, this, comma. 
Line 27, indented multiple times: SLOT, left parentheses, Handle
Shuffle Button Clicked, left parentheses, right parentheses, right
parentheses, right parentheses, semicolon. 
Line 28: right brace.
Back to Table
Program code. The words in the variable names and function names
are merged. The code contains the following keywords: void, if, else,
for, int.
Line 1: void Card Deck Main Window, colon, colon, Init Table, left
parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: Deck deck, semicolon. 
Line 4, indented once: deck dot Shuffle, left parentheses, right
parentheses, semicolon. 
Line 5: blank. 
Line 6, indented once: if, left parentheses, table, equals, equals, null
p t r, right parentheses. 
Line 7, indented once: left brace. 2 forward slashes. If the table
doesn’t already exist. 
Line 8, indented twice: table equals new Q Table Widget, left
parentheses, this, right parentheses, semicolon. 2 forward slashes.

Create it. 
Line 9, indented twice: table, hyphen, right angled bracket, set
Column Count, left parentheses, 2, right parentheses, semicolon. 
Line 10, indented twice: table, hyphen, set Row Count, left
parentheses, deck dot size, left parentheses, right parentheses,
right parentheses, semicolon. 
Line 11, indented once: left brace. 
Line 12, indented once: else. 2 forward slashes. If it does, just clear
it. 
Line 13, indented twice: table, hyphen, right angled bracket, clear,
left parentheses, right parentheses, semicolon. 
Line 14, indented once: 2 forward slashes. For the 52 cards in a
deck. 
Line 15, indented once: for, left parentheses, int i equals 0,
semicolon, i less than 52, semicolon, i, plus, plus, right parentheses.
Line 16, indented once: left brace. 
Line 17, indented twice: 2 forward slashes. Get one and convert its
value and suit to Q Strings. 
Line 18, indented twice: Card card equals deck dot Deal, left
parentheses, right parentheses, semicolon. 
Lien 19, indented twice: Q String value equals Q String, colon,
colon, from S t d String, left parentheses, card dot Get Value, left
parentheses, right parentheses, dot, to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 20, indented twice: Q String suit equals Q String, colon, colon,
from S t d String, left parentheses, card dot get Suit, left
parentheses, right parentheses, dot, to String, left parentheses, right
parentheses, right parentheses, semicolon. 
Line 21, indented twice: 2 forward slashes. Use the strings to create
an item for each column in the table. 
Line 22, indented twice: Q Table Widget Item asterisk card Value
Item equals new Q Table Widget Item, left parentheses, value, right
parentheses, semicolon. 
Line 23, indented twice: Q Table Widget Item asterisk card Suit Item
equals new Q Table Widget Item, left parentheses, suit, right
parentheses, semicolon. 
Line 24, indented twice: 2 forward slashes. Disable editing of the
items. 
Line 25, indented twice: card Value Item, hyphen, right angled

bracket, set Flags, left parentheses, card Value Item, hyphen, right
angled bracket, flags, left parentheses, right parentheses,
ampersand, tilde Q t, colon, colon, Item Is Editable, right
parentheses, semicolon. 
Line 26, indented twice: card Suit Item, hyphen, right angled
bracket, set Flags, left parentheses, card Suit Item, hyphen, flags,
left parentheses, right parentheses, ampersand, tilde, Q t, colon,
colon, Item Is Editable, right parentheses, semicolon. 
Line 27, indented twice: 2 forward slashes. Check it’s a red suit and
change the text color of the items to red. 
Line 28, indented twice: if, left parentheses, card dot Get Suit, left
parentheses, right parentheses, equals, equals, Suits, colon, colon,
DIAMONDS, 2 pipes, card dot Get Suit, left parentheses, right
parentheses, equals, equals, Suits, colon, colon, HEARTS, right
parentheses. 
Line 29, indented twice: left brace. 
Line 30, indented thrice: Q Brush brush, left parentheses, Q t, colon,
colon, red, right parentheses, semicolon. 
Line 31, indented thrice: card Value Item, hyphen, right angled
bracket, set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 32, indented thrice: card Suit Item, hyphen, right angled
bracket, set Foreground, left parentheses, brush, right parentheses,
semicolon. 
Line 33, indented twice: right brace. 
Line 34, indented twice: 2 forward slashes. Put the items in the table
at the row corresponding to the current iteration. 
Line 35, indented twice: table, hyphen, right angled bracket, set
Item, left parentheses, i, comma, 0, comma, card Value Item, right
parentheses, semicolon. 
Line 36, indented twice: table, hyphen, right angled bracket, set
Item, left parentheses, i, comma, 1, comma, card Suit Item, right
parentheses, semicolon. 
Line 37: indented once: right brace. 
Line 38: right brace. 
Line 39: void Card Deck Main Window, colon, colon, Display Image,
left parentheses, int row, right parentheses. 
Line 40: left brace. 
Line 41, indented once: 2 forward slashes. Get the text of each item

in the row into a Q String variable. 
Line 42, indented once: Q String value equals table, hyphen, right
angled bracket, item, left parentheses, row, comma, 0, right
parentheses, hyphen, right angled bracket, text, left parentheses,
right parentheses, semicolon. 
Line 43, indented once: Q String suit, equals, table, hyphen, right
angled bracket, item, left parentheses, row, comma, 1, right
parentheses, hyphen, right angled bracket, text, left parentheses,
right parentheses, semicolon. 
Line 44, indented once: 2 forward slashes. Use the value and suit to
form a string for the file name where the card’s picture is. 
Line 45, indented once: 2 forward slashes. And pass it to a method
that reads the file to construct a Q Pix map object. 
Line 46, indented once: Q Pix map card Image, left parentheses,
double quotes, colon, Card Images, forward slash, double quotes,
plus, value, plus, double quotes, underscore, double quotes, plus,
suit, plus, double quotes, dot p n g, double quotes, right
parentheses, semicolon. 
Line 47, indented once: 2 forward slashes. Use the label’s set Pix
map method to put the picture into it, making some adjustments. 
Line 48, indented once: image, hyphen, right angled bracket, set Pix
map, left parentheses, card Image, dot, scaled, left parentheses,
300, comma, 300, comma, Q t, colon, colon, Keep Aspect Ratio,
right parentheses, semicolon. 
Line 49: right brace.
Back to Table
Program code. The words in the variable names and method names
are merged. The code contains the keywords void, and this. 
Line 1: void Card Deck Main Window, colon, colon, Init Label, left
parentheses, right parentheses. 
Line 2: left brace. 
Line 3, indented once: image equals new Q Label, left parentheses,
double quotes, double quotes, comma, this, right parentheses,
semicolon. 
Line 4, indented once: Display Image, left parentheses, 0, right
parentheses, semicolon. 
Line 5: right brace. 

Line 6: blank. 
Line 7: void Card Deck Main Window, colon, colon, Handle Click On
Card, left parentheses, int row, comma, int column, right
parentheses. 
Line 8: left brace. 
Line 9, indented once: Display Image, left parentheses, row, right
parentheses, semicolon. 
Line 10: right brace. 
Line 11: blank. 
Line 12: void Card Deck Main Window, colon, colon, Handle Shuffle
Button Clicked, left parentheses, right parentheses, left brace, Init
Table, left parentheses, right parentheses, semicolon, right brace. 
Line 13: blank. 
Line 14: Card Deck Main Window, colon, colon, tilde, Card Deck
Main Window, left parentheses, right parentheses, left brace, right
brace.
Back to Table
The operations are as follows. push, left parentheses, 5, right
parentheses, comma, push, left parentheses, 4, right parentheses,
comma, push, left parentheses, 3, right parentheses, comma, pop,
left parentheses, right parentheses, comma, push, left parentheses,
2, right parentheses, comma, push, left parentheses, 1, right
parentheses, comma, pop, left parentheses, right parentheses,
comma, pop, left parentheses, right parentheses.
Back to Figure
The operations are as follows. push, left parentheses, 5, right
parentheses, comma, push, left parentheses, 4, right parentheses,
comma, push, left parentheses, 3, right parentheses, comma, pop,
left parentheses, right parentheses, comma, push, left paren
Back to Figure
The operations are as follows. Push, left parentheses, 1, right
parentheses, comma, push, left parentheses, 7, right parentheses,
comma, push, left parentheses, 3, right parentheses, comma, push,

left parentheses, 2, right parentheses, comma, push, left
parentheses, 5, right parentheses, comma, pop, left parentheses,
right parentheses, comma, push, left parentheses, 10, right
parentheses, comma, pop, left parentheses, right parentheses.
Back to Figure
The operations are as follows. Push underscore back, left
parentheses, 5, right parentheses, comma, push underscore back,
left parentheses, 4, right parentheses, comma, push underscore
front, left parentheses, 3, right parentheses, comma, push
underscore front, left parentheses, 2, right parentheses, comma,
pop underscore back, left parentheses, right parentheses, comma,
push underscore back, left parentheses, 1, right parentheses,
comma, pop underscore front, left parentheses, right parentheses,
comma, pop underscore front, left parentheses, right parentheses.
Back to Figure
Program code. The code contains the following keywords: int,
vector. Line 1: int fill, left square bracket, right square bracket,
equals, left brace, 1, comma, 2, comma, 3, comma, 4, comma, 5,
comma, 6, comma, 7, comma, 8, comma, 9, comma, 10, right
brace, semicolon. Line 2: vector, left angled bracket, int, right angled
bracket, e x 1, left parentheses, fill, comma, fill plus size of, left
parentheses, fill, right parentheses, forward slash, size of, left
parentheses, int, right parentheses, right parentheses, semicolon.
Back to Figure
a. The description of the code segment is as follows. c out, 2 left
angled brackets, e x 1 dot size, left parentheses, right parentheses,
2 left angled brackets, double quotes, blank space, double quotes, 2
left angled brackets, e x 1 dot front, left parentheses, right
parentheses, 2 left angled brackets, double quotes, blank space,
double quotes, 2 left angled brackets, e x 1 dot back, left
parentheses, right parentheses, semicolon.

b. The description of the code segment is as follows. c out, 2 left
angled brackets, e x 1, left square bracket, 3, right square bracket,
2 left angled brackets, double quotes, blank space, double quotes, 2
left angled brackets, e x 1, left square bracket, 5, right square
bracket, 2 left angled brackets, double quotes, blank space, double
quotes, 2 left angled brackets, e x 1, left square bracket, 9, right
square bracket, semicolon.
c. The description of the third code segement is as follows. Line 1: e
x 1 dot erase, left parentheses, e x 1 dot begin, left parentheses,
right parentheses, plus 4, right parentheses, semicolon. Line 2,
indented once: c out, 2 left angled brackets, e x 1, left square
bracket, 3, right square bracket, 2 left angled brackets, double
quotes, blank space, double quotes, 2 left angled brackets, e x 1,
left square bracket, 4, right square bracket, 2 left angled brackets,
double quotes, blank space, double quotes, 2 left angled brackets, e
x 1, left square bracket, 5, right square bracket, semicolon.
d. The description of the fourth code segment is as follows. Line 1:
vector, left angled bracket, int, right angled bracket, colon, colon,
iterator i, semicolon. Line 2: blank. Line 3: e x 1 dot erase, left
parentheses, e x 1 dot begin, left parentheses, right parentheses,
right parentheses, semicolon. Line 4: for, left parentheses, i equals e
x 1 dot begin, left parentheses, right parentheses, plus, 2,
semicolon, i, exclamation mark, equals, e x 1 dot end, left
parentheses, right parentheses, semicolon, i plus plus, right
parentheses. Line 5, indented once: c out, 2 left angled brackets,
asterisk i, 2 left angled brackets, end l, semicolon.
Back to Figure
Program code. The code contains the following keywords: int, list.
Line 1: int fill, left square bracket, right square bracket, equals, left
brace, 12, comma, 15, comma, 7, comma, 42, comma, 43, comma,
9, comma, 11, comma, 52, comma, 30, comma, 10, right brace,
semicolon. Line 2: list, left angled bracket, int, right angled bracket,
e x 2, left parentheses, fill, comma, fill plus size of, left parentheses,
fill, right parentheses, forward slash, size of, left parentheses, int,
right parentheses, right parentheses, semicolon.

Back to Figure
a. The code segment is as follows. c out, 2 left angled brackets, e x
2 dot size, left parentheses, right parentheses, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, e x 2 dot front, left parentheses, right parentheses, 2 left
angled brackets, double quotes, blank space, double quotes, 2 left
angled brackets, e x 2 dot back, left parentheses, right parentheses,
semicolon.
b. The code segment is as follows. c out, 2 left angled brackets,
asterisk e x 2 dot begin, left parentheses, right parentheses, 2 left
angled brackets, double quotes, blank space, double quotes, 2 left
angled brackets, asterisk, left parentheses, minus, minus, e x 2 dot
end, left parentheses, right parentheses, right parentheses, 2 left
angled brackets, double quotes, blank space, double quotes, 2 left
angled brackets, asterisk, e x 2 dot r begin, left parentheses, right
parentheses, 2 left angled brackets, double quotes, blank space,
double quotes, 2 left angled brackets, asterisk, left parentheses,
minus minus e x 2 dot r end, left parentheses, right parentheses,
right parentheses, semicolon.
c. The description of the code segment is as follows. e x 2 dot
insert, left parentheses, plus, plus, e x 2 dot begin, left parentheses,
right parentheses, comma, 99, right parentheses, semicolon. Line 2:
e x 2 dot pop underscore back, left parentheses, right parentheses,
semicolon. Line 3: c out, 2 left angled brackets, asterisk e x 2 dot
begin, left parentheses, right parentheses, semicolon.
d. The description of the code segment is as follows. Line 1: list, left
angled bracket, int, right angled bracket, colon, colon, iterator i
equals e x 2 dot begin, left parentheses, right parentheses,
semicolon. Line 2: while, left parentheses, i exclamation mark e x 2
dot end, left parentheses, right parentheses, right parentheses. Line
3, indented once: if, left parentheses, i exclamation mark equals e x
2 dot end, left parentheses, right parentheses, right parentheses.
Line 4, indented twice: i equals e x 2 dot erase, left parentheses, i,
right parentheses, semicolon. Line 5, indented once: else. Line 6,
indented twice: i plus, plus. Line 7: for, left parentheses, i equals e x

2 dot begin, left parentheses, right parentheses, semicolon, i
exclamation mark equals e x 2 dot end, left parentheses, right
parentheses, semicolon, i plus plus, right parentheses. Line 8,
indented once: c out, 2 left angled brackets, asterisk i, 2 left angled
brackets, end l, semicolon.
e. The description of the code segment is as follows. Line 1: list, left
angled bracket, int, right angled brackets, colon, colon, iterator i,
semicolon. Line 2: e x 2 dot sort, left parentheses, right
parentheses, semicolon. Line 3: for, left parentheses, i equals plus
plus, left parentheses, plus plus e x 2 dot begin, left parentheses,
right parentheses, right parentheses, semicolon, i exclamation mark
equals e x 2 dot end, left parentheses, right parentheses, semicolon,
i plus plus, right parentheses. Line 4, indented once: c out, 2 left
angled brackets, asterisk i, 2 left angled brackets, end l, semicolon.
Back to Figure
Line 1: int fill, left square bracket, right square bracket, equals, left
brace, 27, comma, 16, comma, 81, comma, 42, comma, 22,
comma, 75, comma, 3, comma, 49, comma, 12, comma, 3, comma,
7, comma, 2, comma, 4, right brace, semicolon. Line 2: deque, left
angled bracket, int, right angled bracket, e x 3, left parentheses, fill,
comma, fill plus size of, left parentheses, fill, right parentheses,
forward slash, size of, left parentheses, int, right parentheses, right
parentheses, semicolon.
Back to Figure
a. The code segment is as follows. c out, 2 left angled brackets, e x
3 dot size, left parentheses, right parentheses, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, e x 3 dot front, left parentheses, right parentheses, 2 left
angled brackets, dobule quotes, blank space, double quotes, 2 left
angled brackets, e x 3 dot back, left parentheses, right parentheses,
semicolon.
b. The code segment is as follows. c out, 2 left angled brackets,
asterisk e x 3 dot begin, left parentheses, right parentheses, 2 left

angled brackets, double quotes, blank space, double quotes, 2 left
angled brackets, asterisk, left parentheses, minus, minus, e x 3 dot
end, left parentheses, right parentheses, right parentheses, 2 left
angled brackets, 2 left angled brackets, double quotes, blank space,
double quotes, 2 left angled brackets, asterisk e x 3 dot r begin, left
parentheses, right parentheses, 2 left angled brackets, double
quotes, blank space, double quotes, 2 left angled brackets, asterisk,
left parentheses, minus, minus, e x 3 dot r end, left parentheses,
right parentheses, right parentheses, semicolon.
c. The code segment is as follows. c out, 2 left angled brackets, e x
3, left square bracket, 2, right square bracket, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, e x 3, left parentheses, 6, right parentheses, 2 left angled
brackets, double quotes, blank space, double quotes, 2 left angled
brackets, e x 3, left square bracket, 8, right square bracket,
semicolon.
d. The code segment is as follows. Line 1: e x 3 dot erase, left
parentheses, e x 3 dot begin, left parentheses, right parentheses,
plus, 4, right parentheses, semicolon. Line 2, indented once: c out, 2
left angled brackets, e x 3, left square bracket, 3, right square
bracket, 2 left angled brackets, double quotes, blank space, double
quotes, 2 left angled brackets, e x 3, left square bracket, 4, right
square bracket, 2 left angled brackets, double quotes, blank space,
double quotes, 2 left angled brackets, e x 3, left square bracket, 5,
right square bracket, semicolon.
e. The code segment is as follows. Line 1: e x 3 dot insert, left
parentheses, plus, plus, e x 3 dot begin, left parentheses, right
parentheses, comma, 99, right parentheses, semicolon. Line 2: e x
3 dot pop underscore back, left parentheses, right parentheses,
semicolon. Line 3: c out, 2 left angled brackets, asterisk, e x 3 dot
begin, left parentheses, right parentheses, semicolon.
f. The code segment is as follows. Line 1: deque, left angled
bracket, int, right angled bracket, colon, colon, iterator i equals e x 3
dot begin, left parentheses, right parentheses, semicolon. Line 2:
while, left parentheses, i exclamation mark equals e x 3 dot end, left

parentheses, right parentheses, right parentheses. Line 3, indented
once: if, left parentheses, asterisk, i percentage sign 2, equals,
equals, 1, right parentheses. Line 4, indented twice: i equals e x 3
dot erase, left parentheses, i, right parentheses, semicolon. Line 5,
indented once: else. Line 6, indented twice: i plus plus, semicolon.
Line 7: for, left parentheses, i equals e x 3 dot begin, left
parentheses, right parentheses, semicolon, i exclamation mark
equals sign e x 3 dot end, left parentheses, right parentheses,
semicolon, i plus plus, right parentheses. Line 8, indented once: c
out, 2 left angled brackets, asterisk i, 2 left angled brackets, end l,
semicolon.
Back to Figure
Line 1: int fill, left square bracket, right square bracket, equals, left
brace, 1, comma, 2, comma, 3, comma, 4, comma, 5, right brace,
semicolon. Line 2: list, left angled bracket, int, right angled bracket,
e x 4, left parentheses, fill, comma, fill plus size of, left parentheses,
fill, right parentheses, forward slash, size of, left parentheses, int,
right parentheses, semicolon.
Back to Figure
c out, 2 left angled brackets, asterisk, e x 4 dot r end, left
parentheses, right parentheses, 2 left angled brackets, end l,
semicolon.
Back to Figure
The operations are as follows. Line 1: stack, left angled bracket,
char, right angled bracket, e x 5, semicolon. Line 2: e x 5 dot push,
left parentheses, single quote, r, single quote, right parentheses,
semicolon, e x 5 dot push, left parentheses, single quote, a, single
quote, right parentheses, semicolon, e x 5 dot push, left
parentheses, single quote, h, single quote, right parentheses,
semicolon, e x 5 dot push, left parentheses, single quote, c, single
quote, right parentheses, semicolon. Line 3: while, left parentheses,
exclamation mark, e x 5 dot empty, left parentheses, right
parentheses, right parentheses. Line 4, indented once: left brace, c

out, 2 left angled brackets, e x 5 dot front, left parentheses, right
parentheses, semicolon, e x 5 dot pop, left parentheses, right
parentheses, semicolon, right brace.
Back to Figure
The operations are as follows. Line 1: queue, left angled bracket,
string, right angled bracket, e x 6, semicolon. Line 2: e x 6 dot push,
left parentheses, double quotes, C o, double quotes, right
parentheses, semicolon. Line 3: e x 6 dot push, left parentheses,
double quotes, n t, double quotes, right parentheses, semicolon, e x
6 dot push left parentheses, double quotes, a i, double quotes, right
parentheses, semicolon, e x 6 dot push, left parentheses, double
quotes, n e r, double quotes, right parentheses, semicolon. Line 3:
while, left parentheses, exclamation mark, e x 6 dot empty, left
parentheses, right parentheses, right parentheses. Line 4, indented
once: left brace, c out, 2 left angled brackets, e x 6 dot top, left
parentheses, right parentheses, semicolon, e x 6 dot pop, left
parentheses, right parentheses, semicolon, right brace.
Back to Figure
The operations are as follows. Line 1: priority underscore queue, left
angled bracket, float, right angled bracket, e x 7, semicolon. Line 2:
e x 7 dot push, left parentheses, 1.8, right parentheses, semicolon.
e x 7 dot push, left parentheses, 5.2, right parentheses, semicolon,
e x 7 dot push, left parentheses, 3.4, right parentheses, semicolon.
e x 7 dot push, left parentheses, 6.7, right parentheses, semicolon.
Line 3: while, left parentheses, exclamation mark, e x 7 dot empty,
left parentheses, right parentheses, right parentheses. Line 4,
indented once: left brace, c out, 2 left angled brackets, e x 7 dot top
left parentheses, right parentheses, 2 left angled brackets, double
quotes, blank space, semicolon, e x 7 dot pop, left parentheses,
right parentheses, semicolon, right brace.
Back to Figure
Line 1: 4, blank space, 5, plus, uppercase x. Line 2: dollar sign,
uppercase x, blank space, 3, blank space, asterisk. Line 3: caret

sign, blank space, uppercase x.
Back to Figure
The statements are as follows. column 5 dot splice, left
parentheses, column 5 dot end, left parentheses, right parentheses,
comma, column 3, comma, column 3 dot place, comma, column 3
dot end, left parentheses, right parentheses, right parentheses,
semicolon.
The formula for X raised to the power of N. X^N equals X times X
times X times X times and so on times X for N times.
Back to Figure
Another way of writing the formula for X raised to the power of N.
X^N equals X times (X times X times and so on times X) for N minus
1 times.
Back to Figure
Another way of writing the formula for X raised to the power of N.
X^N equals X times X times (X times X times and so on times X) for
N minus 2 times.
Back to Figure
Concise way of writing the formula for X raised to the power of N.
X^N equals X times X^(N minus 1).
Back to Figure
A program that features a recursive version of the power function.
Program code. Line 1. Forward slash, forward slash, a line of
asterisks. Line 2. Forward slash, forward slash, Exponentiation
program. Line 3. Forward slash, forward slash, a line of asterisks.
Line 4. Hash, include, left angle bracket, i o stream, right angle
bracket. Line 5. using, name space, s t d, semicolon. Line 6. i n t,
Power, left parenthesis, i n t, x, comma, i n t, n, right parenthesis,
semicolon. Line 7. i n t, main, left parenthesis, right parenthesis.

Line 8. Left brace. Line 9, indented once. i n t, number, semicolon,
tab space, forward slash, forward slash, Number that is being raised
to power. Line 10. i n t, exponent, semicolon, tab space, forward
slash, forward slash, Power the number is being raised to. Line 11,
indented once. c in, double right angle bracket, number, double right
angle bracket, exponent, semicolon. Line 12, indented once. c out,
double left angle bracket, Power, left parenthesis, number, comma,
exponent, right parenthesis, semicolon, tab space, forward slash,
forward slash, Nonrecursive call. Line 13, indented once. return, 0,
semicolon. Line 14. Right brace. Line 15. Forward slash, forward
slash, a line of asterisks. Line 16. i n t, Power, left parenthesis, i n t,
x, comma, i n t, n, right parenthesis. Line 17. Forward slash, forward
slash, Computes x to the n power by multiplying x times the result
of. Line 18. Forward slash, forward slash, computing x to the n
minus 1 power. Line 19. Forward slash, forward slash, Pre, colon, n
greater than 0. Line 20. Left brace. Line 21, indented once. if, left
parenthesis, n, equals, equals, 1, right parenthesis. Line 22,
indented twice. return, x, semicolon, tab space, forward slash,
forward slash, Base case. Line 23, indented once. else. Line 24,
indented twice. return, x, asterisk, Power, left parenthesis, x,
comma, n, minus, 1, right parenthesis, semicolon, tab space,
forward slash, forward slash, Recursive call. Line 25. Right brace.
Back to Figure
A conditional statement. Program code. Line 1. if, left parenthesis,
n, equals, equals, 1, right parenthesis.
Back to Figure
A figure depicting how the function power of 2, 3 executes. The
function power of 2, 3 begins execution. In call 1 x is 2 and n is 3. In
call 2 x is 2 and n is 2. In call 3 x is 2 and n is 1. Call 3 returns 2.
Going back to call 2, the function returns 4. Going back to call 1, the
function returns 8.
Back to Figure

One way of expressing the factorial of a number. N factorial equals
N times (N minus 1) factorial.
Back to Figure
A recursive algorithm for the factorial of a number. Line 1. Factorial,
left parenthesis, In, colon, n, right parenthesis. Line 2. IF n is 0. Line
3, indented once. Return 1. Line 4. ELSE. Line 5, indented once.
Return n, asterisk, Factorial, left parenthesis, n minus 1, right
parenthesis.
Back to Figure
Code for the recursive factorial function. Program code Line 1. i n t,
Factorial, left parenthesis, i n t, n, right parenthesis. Line 2. Forward
slash, forward slash, Returns the factorial of n, period. Line 3.
Forward slash, forward slash, Pre, colon n, greater than or equals,
0. Line 4. Left brace. Line 5, indented once. if, left parenthesis, n,
equals, equals, 0, right parenthesis. Line 6, indented twice. return, 1,
semicolon. Note. Forward slash, forward slash, Base case. Line 7,
indented once. else. Line 8, indented twice. return, n, asterisk,
Factorial, left parenthesis, n, minus, 1, right parenthesis, semicolon.
Note. Forward slash, forward slash, General case, left parenthesis,
recursive call, right parenthesis. Line 9. Right brace.
Back to Figure
A diagram that depicts how the function factorial of 4 executes. The
function factorial of 4 begins execution. In call 1, n is 4. In call 2, n is
3. In call 3, n is 2. In call 4, n is 1. In call 5, n is 0 and during this call
the function returns 1. Going back to call 4, the function returns 1.
Going back to call 3, the function returns 2. Going back to call 2, the
function returns 6. Going back to call 1, the function returns 24.
Back to Figure
The iterative solution for the factorial function. Program code. Line 1.
i n t, Factorial, left parenthesis, i n t, n, right parenthesis. Line 2. Left
brace. Line 3, indented once. i n t, factor, semicolon. Line 4,
indented once. i n t, count, semicolon. Line 5, indented once. factor,

equals, 1, semicolon. Line 6, indented once. for, left parenthesis,
count, equals, 2, semicolon, count, less than or equals, n,
semicolon. Line 7, indented a few times. count, plus, plus, right
parenthesis. Line 8, indented twice. factor, equals, factor, asterisk,
count, semicolon. Line 9, indented once. return, factor, semicolon.
Line 10. Right brace.
Back to Figure
The recursive solution for the factorial function. Program code. Line
1. i n t, Factorial, left parenthesis, i n t, n, right parenthesis. Line 2.
Left brace. Line 3, indented once. If, left parenthesis, n, equals,
equals, 0, right parenthesis. Line 4, indented twice. return, 1,
semicolon. Line 5, indented once. else. Line 6, indented twice.
return, n, asterisk, Factorial, left parenthesis, n, minus, 1, right
parenthesis, semicolon. Line 7. Right brace.
Back to Figure
The beginning configuration in the game, Towers of Hanoi. The
game has three pegs. The first peg has four discs. The discs in the
first peg are arranged in decreasing order of size from bottom to
top.
Back to Figure
The required first step in the game, Towers of Hanoi. In the game,
there are 3 pegs. Peg 2 has three discs in decreasing order of size
from bottom to top. Peg 1 has the largest disc or disc 4. Disc 4 can
be moved to peg 3 from peg 1. This will be the final place.
Back to Figure
The next step in the game, Towers of Hanoi. The next largest disc or
disc 3 needs to moved on top of disc 4 in peg 3. The two discs on
top of it in peg 2 need to moved to peg 1.
Back to Figure

The next step in the game, Towers of Hanoi. Disc 2 needs to be
placed on top of disc 3 in peg 3. To do this, disc 1 is moved to peg
2. This frees disc 2 and it can be moved on to peg 3 on top of disc
2.
Back to Figure
The last step in the game, Towers of Hanoi. The last disc, disc 1 can
now be moved on top of disc 2 in peg 3 and the game is finished.
Back to Figure
The summary of the process in the Towers of Hanoi game. Get n
Circles Moved from Peg 1 to Peg 3. Get n minus 1 circles moved
from peg 1 to peg 2. Move nth circle from peg 1 to peg 3.
Get n minus 1 circles moved from peg 2 to peg 3.
Back to Figure
Code for the function in the Towers of Hanoi game. Program code.
Line 1. void, Do Towers, left parenthesis. Line 2, indented once. i n t,
circle Count, comma, tab space, forward slash, forward slash,
Number of circles to move. Line 3, indented once. i n t, begin Peg,
comma, tab space, forward slash, forward slash, Peg containing
circles to move. Line 4, indented once. i n t, a u x Peg, comma, tab
space, forward slash, forward slash, Peg holding circles temporarily.
Line 5, indented once. i n t, end Peg, right parenthesis, tab space,
forward slash, forward slash, Peg receiving circles being moved.
Line 6. Left brace. Line 7, indented once. if, left parenthesis, circle
Count, greater than, 0, right parenthesis. Line 8, indented once. Left
brace. Line 9, indented twice. Forward slash, forward slash, Move n
minus 1 circles from beginning peg to auxiliary peg. Line 10,
indented twice. Do Towers, left parenthesis, circle Count, minus, 1,
comma, begin Peg, comma, end Peg, comma, a u x Peg, right
parenthesis, semicolon. Line 11, indented twice. c out, double left
angle bracket, open quotes, Move circle from peg, space, close
quotes, double left angle bracket, begin Peg. Line 12, indented 3
times. Double left angle bracket, open quotes, space, to peg, space,
close quotes, double left angle bracket, end Peg, double left angle

bracket, end l, semicolon. Line 13, indented twice. Forward slash,
forward slash, Move n minus 1 circles from auxiliary peg to ending
peg. Line 14, indented twice. Do Towers, left parenthesis, circle
Count, minus, 1, comma, a u x Peg, comma, begin Peg, comma,
end Peg, right parenthesis, semicolon. Line 15, indented once. Right
brace. Line 16. Right brace.
Back to Figure
The program for Towers of Hanoi. Program code. Line 1. Forward
slash, forward slash, a line of asterisks. Line 2. Forward slash,
forward slash, Test Towers program. Line 3. Forward slash, forward
slash, This program, a test driver for the Do Towers function, reads
in. Line 4. Forward slash, forward slash, a value from standard input
and passes this value to Do Towers. Line 5. Forward slash, forward
slash, a line of asterisks. Line 6. Hash, include, left angle bracket, i o
stream, right angle bracket. Line 7. Hash, include, left angle bracket,
i o manip, right angle bracket, tab space, forward slash, forward
slash, For set w, left parenthesis, right parenthesis. Line 8. using,
name space, s t d, semicolon. Line 9. void, Do Towers, left
parenthesis, i n t, circle Count, comma, i n t, begin Peg, comma, i n
t, a u x Peg, comma, i n t, end Peg, right parenthesis, semicolon.
Line 10. Forward slash, forward slash, This function moves circle
Count circles from begin Peg to. Line 11. Forward slash, forward
slash, end Peg, comma, using a u x Peg as a temporary holding
peg. Line 12. i n t, main, left parenthesis, right parenthesis. Line 13.
Left brace. Line 14. 
i n t, circle Count, semicolon, tab space, forward slash, forward
slash, Number of circles on starting peg. Line 15, indented once. c
out, double left angle bracket, open quotes, Input number of circles,
colon, space, close quotes, semicolon. Line 16, indented once. c in,
double right angle bracket, circle Count, semicolon. Line 17,
indented once. c out, double left angle bracket, open quotes,
OUTPUT WITH, space, close quotes, double left angle bracket,
circle Count, double left angle bracket, open quotes, space,
CIRCLES, close quotes, double left angle bracket, end l. Line 18,
indented twice. Double left angle bracket, end l, semicolon. Line 19,
indented once. c out, double left angle bracket, open quotes,
CALLED FROM hash CIRCLES, close quotes, double left angle

bracket, set w, left parenthesis, 8, right parenthesis, double left
angle bracket, open quotes, BEGIN, close quotes. Line 20, indented
twice. Double left angle bracket, set w, left parenthesis, 8, right
parenthesis, double left angle bracket, open quotes, AUXIL, period,
close quotes, double left angle bracket, set w, left parenthesis, 5,
right parenthesis, double left angle bracket, open quotes, END,
close quotes. Line 21, indented twice. Double left angle bracket,
open quotes, space, INSTRUCTIONS, close quotes, double left
angle bracket, end l. Line 22, indented twice. Double left angle
bracket, end l, semicolon. Line 23, indented once. c out, double left
angle bracket, open quotes, Original, space, colon, close quotes,
semicolon. Line 24, indented once. Do Towers, left parenthesis,
circle Count, comma, 1, comma, 2, comma, 3, right parenthesis,
semicolon. Line 25, indented once. return, 0, semicolon. Line 26.
Right brace. Line 27. Forward slash, forward slash, a line of
asterisks. Line 28. void, Do Towers, left parenthesis, i n t, circle
Count, comma, i n t, begin Peg, comma, i n t, a u x Peg, comma, i n
t, end Peg, right parenthesis. Line 29. Forward slash, forward slash,
This recursive function moves circle Count circles from begin Peg.
Line 30. Forward slash, forward slash, to end Peg. All but one of the
circles are moved from begin Peg. Line 31. Forward slash, forward
slash, to a u x Peg, comma, then the last circle is moved from begin
Peg to end Peg, comma. Line 32. Forward slash, forward slash, and
then the circles are moved from a u x Peg to end Peg. Line 33.
Forward slash, forward slash, The subgoals of moving circles to and
from a u x Peg are what. Line 34. Forward slash, forward slash,
involve recursion. Line 35. Forward slash, forward slash, Pre, colon,
circle Count, greater than or equals, 0. Line 36. Left brace. Line 37,
indented once. c out, double left angle bracket, set w, left
parenthesis, 6, right parenthesis, double left angle bracket, circle
Count, double left angle bracket, set w, left parenthesis, 9, right
parenthesis, double left angle bracket, begin Peg. Line 38, indented
twice. Double left angle bracket, set w, left parenthesis, 7, right
parenthesis, double left angle bracket, a u x Peg, double left angle
bracket, set w, left parenthesis, 7, right parenthesis, double left
angle bracket, end Peg, double left angle bracket, end l, semicolon.
Line 39,indented once. if, left parenthesis, circle Count, greater than,
0, right parenthesis. Line 40, indented once. Left brace. Line 41,
indented twice. c out, double left angle bracket, open quotes, From

first, colon, close quotes, semicolon. Line 42, indented twice. Do
Towers, left parenthesis, circle Count, minus, 1, comma, begin Peg,
comma, end Peg, comma, a u x Peg, right parenthesis, semicolon.
Line 43, indented twice. c out, double left angle bracket, set w, left
parenthesis, 58, right parenthesis, double left angle bracket, open
quotes, Move circle, space, close quotes, double left angle bracket,
circle Count. Line 44, indented 3 times. Double left angle bracket,
open quotes, space, from, space, close quotes, double left angle
bracket, begin Peg, double left angle bracket, open quotes, space,
to, space, close quotes, double left angle bracket, end Peg, double
left angle bracket, end l, semicolon. Line 45, indented twice. c out,
double left angle bracket, open quotes, From second, colon, close
quotes, semicolon. Line 46, indented twice. Do Towers, left
parenthesis, circle Count, minus, 1, comma, aux Peg, comma, begin
Peg, comma, end Peg, right parenthesis, semicolon. Line 47,
indented once. Right brace. Line 48. Right brace.
Back to Figure
The output of the Towers of Hanoi program. Line 1. OUTPUT WITH
3 CIRCLES. Line 2. CALLED FROM hash CIRCLES BEGIN AUXIL.
END. INSTRUCTIONS. Line 3. Original : 3 1 2 3. Line 4. From first:
2 1 3 2. Line 5. From first: 1 1 2 3. Line 6. From first: 0 1 3 2. Line 7.
Move circle 1 from 1 to 3. Line 8. From second: 0 2 1 3. Line 9.
Move circle 2 from 1 to 2. Line 10. From second: 1 3 1 2
From first: 0 3 2 1. Line 11. Move circle 1 from 3 to 2. Line 12. From
second: 0 1 3 2. Line 13. Move circle 3 from 1 to 3. Line 14. From
second: 2 2 1 3. Line 15. From first: 1 2 3 1. Line 16. From first: 0 2
1 3. Line 17. Move circle 1 from 2 to 1. Line 18. From second: 0 3 2
1. Line 19. Move circle 2 from 2 to 3. Line 20. From second: 1 1 2 3.
Line 21. From first: 0 1 3 2. Line 22. Move circle 1 from 1 to 3. Line
23. From second: 0 2 1 3.
Back to Figure
A recursive algorithm for printing the contents of a one-dimensional
array of n elements. Line 1. Print Array. Line 2. IF more elements.
Line 3, indented once. Print the value of the first element. Line 4,
indented once. Print the array of n minus 1 element.

Back to Figure
Code for the function that prints the contents of a one-dimensional
array of n elements. Program code. Line 1. void, Print, left
parenthesis, const, i n t, data, left bracket, right bracket, comma, i n
t, first, comma, i n t, last, right brace. Line 2. Forward slash, forward
slash, This function outputs the values in data from data, left
bracket, first, right bracket. Line 3. Forward slash, forward slash,
through data, left bracket, last, right bracket. Line 4. Left brace. Line
5, indented once. if, left parenthesis, first, less than or equals, last,
right parenthesis. Line 6, indented once. Left brace, tab spaces,
forward slash, forward slash, Recursive case. Line 7, indented twice.
c out, double left angle bracket, data, left bracket, first, right bracket,
double left angle bracket, end l, semicolon. Line 8, indented twice.
Print, left parenthesis, data, comma, first, plus, 1, comma, last, right
parenthesis, semicolon. Line 9, indented once. Right brace. Line 10,
indented 3 times. Forward slash, forward slash, Empty else-clause is
the base case. Line 11. Right brace.
Back to Figure
Code for the function call in the program that prints the contents of a
one-dimensional array of n elements. Program code. Line 1. Print,
left parenthesis, data, comma, 0, comma, 4, right parenthesis,
semicolon.
Back to Figure
An array. The name of the array is data. The index positions and the
elements in those indices in the array are listed further. 0: 23. 1: 44.
2: 52. 3: 61. 4: 77.
Back to Figure
A diagram that depicts how the function Print with the parameters
data, 0, and 4 executes. Data, which is the array is not shown in the
diagram. The function Print of data, comma, 0, 4 begins execution.
In call 1, first is 0 and last is 4. data of 0 is printed. In call 2, first is 1
and last is 4. data of 1 is printed. In call 3, first is 2 and last is 4.

data of 2 is printed. In call 4, first is 3 and last is 4. data of 3 is
printed. In call 5, first is 4 and last is 4. data of 4 is printed. In call 6,
first is 5 and last is 4. data of 0 is printed. Going back to call 5.
Going back to call 4. Going back to call 3. Going back to call 2.
Going back to call 1. End of execution.
Program code. Line 1. bool, Search, left parenthesis, string, words,
left bracket, right bracket, comma, i n t, num Words, comma, string,
a Word, right parenthesis, semicolon. Line 2. Forward slash, forward
slash, Post, colon, Returns true if a Word is in words, semicolon,
false otherwise. Line 3. main, left parenthesis, right parenthesis.
Line 4. Left brace. Line 5, indented once. Forward slash, forward
slash, Declarations and definitions. Line 6, indented once. while, left
parenthesis, in File, right parenthesis. Line 7, indented once. Left
brace. Line 8, indented twice. num Words, plus plus, semicolon. Line
9, indented twice. in File, double right angle bracket, words, left
bracket, num Words, right bracket, semicolon. Line 10, indented
once. Right brace. Line 11, indented once. c out, double left angle
bracket, open quotes, Enter a word, semicolon, enter Quit to stop
processing, close quotes, double left angle bracket, end l,
semicolon. Line 12, indented once. c in, double right angle bracket,
a Word, semicolon. Line 13, indented once. while, left parenthesis, a
Word, not equals, open quotes, Quit, close quotes, right
parenthesis. Line 14, indented once. Left brace. Line 15, indented
twice. if, left parenthesis, Search, left parenthesis, words, comma,
num Words, comma, a Word, right parenthesis, right parenthesis.
Line 16, indented 3 times. c out, double left angle bracket, a Word,
double left angle brackets, open quotes, space, was found, close
quotes, double left angle bracket, end l, semicolon. Line 17,
indented twice. else. Line 18, indented 3 times. c out, double left
angle bracket, a Word, double left angle bracket, open quotes,
space, was not found, close quotes, double left angle bracket, end l,
semicolon. Line 19, indented twice. c out, double left angle bracket,
open quotes, Enter a word, semicolon, enter Quit to stop
processing, close quotes, double left angle bracket, end l,
semicolon. Line 20, indented twice. c in, double right angle bracket,
a Word, semicolon. Line 21, indented once. Right brace. Line 22.
Right brace.

}
}
Back to Figure
A binary search carried out in a dictionary. A dictionary is used to
look for the word"dimple." The dictionary is opened to the middle and
there we have the words beginning with M. The middle of the first
half of the pages is opened. There, we have words beginning with G.
The first half of the section from A to G is opened. There, we have
words beginning with C. The second half of the section from D to G
is opened.
Back to Figure
The steps in the algorithm that searches for a word in an array of
words. Line 1. Binary Search, left parenthesis, In, colon, string
words, left bracket, right bracket, comma, a Word, comma, first,
comma, last, right parenthesis. Line 2, indented once. Return value,
colon, Boolean. Line 3. IF first greater than last. Line 4, indented
once. Return false. Line 5. ELSE. Line 6, indented once. Set middle
to left parenthesis, first + last, right parenthesis divided by 2. Line 7,
indented once. IF words, left bracket, middle, right bracket is equal
to a Word. Line 8, indented twice. Return true. Line 9, indented
once. ELSE. Line 10, indented twice. IF words[middle] comes after a
Word. Line 11, indented 3 times. Search words[first] to words, left
bracket, middle minus 1, right bracket. Line 12, indented once.
ELSE. Line 13, indented once. Search words, left bracket, middle+1,
right bracket to words, left bracket, last, right bracket.
Back to Figure
Code for a program which reads words from a file and stores them
in an array and then accepts a word from a user and says if the
word is in the array. Program code. Line 1. Forward slash, forward
slash, a line of asterisks. Line 2. Forward slash, forward slash, This
program reads words from a file, storing. Line 3. Forward slash,
forward slash, them into an array. The array is sorted. Line 4.
Forward slash, forward slash, The user is prompted to enter a word.

The program. Line 5. Forward slash, forward slash, reports whether
or not the word was in the array. Line 6. Forward slash, forward
slash, of words. Line 7. Forward slash, forward slash, a line of
asterisks. Line 8. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 9. Hash, include, left angle bracket, f stream,
right angle bracket, tab space, forward slash, forward slash, For if
stream> Line 10. Hash, include, left angle bracket, string, right angle
bracket, tab space, forward slash, forward slash, For string class.
Line 11. using, name space, s t d, semicolon. Line 12. void, sort, left
parenthesis, string, grades, left bracket, right bracket, comma, i n t,
num Grades, right parenthesis, semicolon. Line 13. Forward slash,
forward slash, Post, colon, Values in grades have been put into
numeric order. Line 14. bool, Binary Search, left parenthesis, string,
words, left bracket, right bracket, comma, string, a Word, comma, i
n t, first, comma, i n t, last, right parenthesis, semicolon. Line 15.
Forward slash, forward slash, Post, colon, Returns true if a Word is
in words, semicolon, false otherwise. Line 16. i n t, main, left
parenthesis, right parenthesis. Line 17. Left brace. Line 18, indented
once. if stream, in File, semicolon. Line 19, indented once. in File,
dot, open, left parenthesis, open quotes, Words, dot, in, close
quotes, right parenthesis, semicolon. Line 20, indented once. string,
words, left bracket, 30, right bracket, semicolon. Line 21, indented
once. i n t, num Words, equals, 0, semicolon. Line 22, indented
once. string, a Word, semicolon. Line 23, indented once. in File,
double right angle bracket, words, left bracket, 0, right bracket,
semicolon. Line 24, indented once. while, left parenthesis, in File,
right parenthesis. Line 25, indented once. Left brace. Line 26,
indented twice. num Words, plus, plus, semicolon. Line 27, indented
twice. in File, double right angle bracket, words, left bracket, num
Words, right bracket, semicolon. Line 28, indented once. Right
brace. Line 29, indented once. sort, left parenthesis, words, comma,
num Words, right parenthesis, semicolon. Line 30, indented once. c
out, double left angle bracket, open quotes, Enter a word,
semicolon, enter Quit to stop processing, close quotes, double left
angle bracket, end l, semicolon. Line 31, indented once. c in, double
right angle bracket, a Word, semicolon. Line 32, indented once.
while, left parenthesis, a Word, not equals, open quotes, Quit, close
quotes, right parenthesis. Line 33, indented once. Left brace. Line
34, indented twice. if, left parenthesis, Binary Search, left

parenthesis, words, comma, a Word, comma, 0, comma, num
Words, right parenthesis, right parenthesis. Line 35, indented 3
times. c out, double left angle bracket, a Word, double left angle
bracket, open quotes, space, was found, close quotes, double left
angle bracket, end l, semicolon. Line 36, indented twice. else. Line
37, indented 3 times. c out, double left angle bracket, a Word,
double left angle bracket, open quotes, space, was not found, close
quotes, double left angle bracket, end l, semicolon. Line 38,
indented twice. c out, double left angle bracket, open quotes, Enter
a word, semicolon, enter Quit to stop processing, close quotes,
double left angle bracket, end l, semicolon. Line 39, indented twice.
c in, double right angle bracket, a Word, semicolon. Line 40,
indented once. Right brace. Line 41, indented once. return, 0,
semicolon. Line 42. Right brace. Line 43. Forward slash, forward
slash, a line of asterisks. Line 44. void, sort, left parenthesis, string,
grades, left bracket, right bracket, comma, i n t, num Grades, right
parenthesis. Line 45. Forward slash, forward slash, Post, colon,
Straight selection sort has been used to sort the values. Line 46.
Left brace. Line 47, indented once. string, temp, semicolon. Line 48,
indented once. i n t, pass Count, semicolon, tab space, forward
slash, forward slash, Outer loop control variable. Line 49, indented
once. i n t, search Index, semicolon, tab space, forward slash,
forward slash, Inner loop control variable. Line 50, indented once. i n
t, min Index, semicolon, tab space, forward slash, forward slash,
Index of minimum so far. Line 51, indented once. for, left
parenthesis, pass Count, equals, 0, semicolon, pass Count, less
than, num Grades, minus, 1, semicolon, pass Count, plus, plus,
right parenthesis. Line 52, indented once. Left brace. Line 53,
indented twice. min Index, equals, pass Count, semicolon. Line 54,
indented twice. Forward slash, forward slash, Find the index of the
smallest component. Line 55, indented twice. Forward slash, forward
slash, in grades, left bracket, pass Count, dot, dot, num Grades,
minus, 1, right bracket. Line 56, indented twice. for, left parenthesis,
search Index, equals, pass Count, plus, 1, semicolon, search Index,
less than, num Grades, semicolon. Line 57, indented a few times.
search Index, plus, plus, right parenthesis. Line 58, indented 3
times. if, left parenthesis, grades, left bracket, search Index, right
bracket, less than, grades, left bracket, min Index, right bracket,
right parenthesis. Line 59, indented 4 times. min Index, equals,

search Index, semicolon. Line 60, indented twice. Forward slash,
forward slash, Swap data, left bracket, min Index, right bracket, and
data, left bracket, pass Count, right brackets. Line 61, indented
twice. temp, equals, grades, left bracket, min Index, right bracket,
semicolon. Line 62, indented twice. grades, left bracket, min Index,
right bracket, equals, grades, left bracket, pass Count, right bracket,
semicolon. Line 63, indented once. grades, left bracket, pass Count,
right bracket, equals, temp, semicolon. Line 64, indented once.
Right brace. Line 65. Right brace. Line 66. Forward slash, forward
slash, a line of asterisks. Line 67. bool, Binary Search, left
parenthesis, string, words, left bracket, right bracket, comma, string,
a Word, comma, i n t, first, comma, i n t, last, right bracket. Line 68.
Forward slash, forward slash, Binary search is used. Line 69. Left
brace. Line 70, indented once. i n t, middle, semicolon. Line 71. if,
left parenthesis, first, greater than, last, right parenthesis. Line 72,
indented twice. return, false, semicolon. Line 73, indented once.
else. Line 74, indented once. Left brace. Line 75, indented twice.
middle, equals, left parenthesis, first, plus, last, right parenthesis,
forward slash, 2, semicolon. Line 76, indented twice. if, left
parenthesis, words, left bracket, middle, right bracket, equals,
equals, a Word, right parenthesis. Line 77, indented 3 times. return,
true, semicolon. Line 78, indented twice. else. Line 79, indented 3
times. if, left parenthesis, words, left bracket, middle, right bracket,
greater than, a Word, right parenthesis. Line 80, indented 4 times.
return, Binary Search, left parenthesis, words, comma, a Word,
comma, first, comma, middle, minus, 1, right parenthesis,
semicolon. Line 81, indented 3 times. else. Line 82, indented 4
times. return, Binary Search, left parenthesis, words, comma, a
Word, comma, middle, plus, 1, comma, last, right parenthesis,
semicolon. Line 83, indented once. Right brace. Line 84. Right
brace.
Back to Figure
The contents of the input file words dot in. Line 1. red. Line 2. blue.
Line 3. gold. Line 4. yellow. Line 5. black. Line 6. silver. Line 7.
purple. Line 8. green. Line 9. violet. Line 10. orange. Line 11. white.
Back to Figure

The sequence of interactive input in the program that locates a word
that is entered from a list of words in an array. Line 1. Enter a word;
enter Quit to stop processing. Line 2. green. Line 3. green was
found. Line 4. Enter a word; enter Quit to stop processing. Line 5.
gray. Line 6. gray was not found. Line 7. Enter a word; enter Quit to
stop processing. Line 8. red. Line 9. red was found. Line 10. Enter a
word; enter Quit to stop processing. Line 11. white. Line 12. white
was found. Line 13. Enter a word; enter Quit to stop processing.
Line 14. Quit.
Back to Figure
A diagram showing the elements in a linked list. The diagram shows
a list pointer that points to the first element in a linked list. The next
pointer of the first element points to the next element in the linked
list. The next pointer of the second element points to the next
element and so on and so forth. At the end of the linked list is the
final element with its next pointer pointing to null.
Back to Figure
The steps in the algorithm for printing a linked list in order from first
to last. Line 1. Print, List, left parenthesis, In, colon, list P t r, right
parenthesis. Line 2. Set p t r to list P t r. Line 3. WHILE p t r is not
NULL. Line 4, indented once. Print p t r, hyphen, right angle bracket,
component. Line 5, indented once. Set p t r to p t r, hyphen, right
angle bracket, link.
Back to Figure
The steps in the algorithm for printing a linked list in reverse order.
Line 1. Rev Print, left parenthesis, In, colon, list P t r, right
parenthesis. Line 2. IF list P t r is not NULL. Line 3. Rev Print rest of
nodes in list. Line 4. Print current node in list.
Back to Figure
The algorithm to print a linked list in reverse order coded as a
function. Program code. Line 1. void, Rev Print, left parenthesis,
Node P t r, list P t r, right parenthesis. Line 2. Forward slash, forward

slash, / Pre, colon, list P t r points to a list node or is NULL. Line 3.
Forward slash, forward slash, Post, colon, If list P t r is not NULL, all
nodes after list P t r have. Line 4. Forward slash, forward slash,
been output followed by the contents of list P t r, semicolon. Line 5.
Forward slash, forward slash, else no action has been taken. Line 6.
Left brace. Line 7, indented once. if, left parenthesis, list P t r, not
equals, NULL, right parenthesis. Line 8, indented once. Left brace.
Line 9, indented twice. Rev Print, left parenthesis, list P t r, hyphen,
right angle bracket, link, right parenthesis, semicolon, tab spaces,
forward slash, forward slash, Recursive call. Line 10, indented twice.
c out, double left angle bracket, list P t r, hyphen, right angle
bracket, component, double left angle bracket, end l, semicolon.
Line 11, indented once. Right brace. Line 12, indented once.
Forward slash, forward slash, Empty else-clause is the base case,
right brace.
Back to Figure
A diagram showing the elements in a linked list that will be used in
the reversing algorithm. The head points to the element 45. The
next pointer of the element 45 points to element 78. The next
pointer of the element 78 points to element 1066. The next pointer
of the element 1066 points to element 1492. The next pointer of the
element 1492 points to null.
Back to Figure
A diagram that depicts how the Rev Print function executes. The
Rev Print function with the parameter list P t r begins execution. At
call 1, list P t r points to 45. At call 2, list P t r points to 78. At call 3,
list P t r points to 1066. At call 4, list P t r points to 1492. At call 5,
list P t r points to NULL. Going back to call 4, 1492 is printed. Going
back to call 3, 1066 is printed. Going back to call 2, 78 is printed.
Going back to call 1, 45 is printed. The function stops execution.
Back to Figure
A call to a function that copies a linked list. Program code. Line 1.
Node P t r, list P t r, semicolon. Line 2. Node P t r, new List P t r,

semicolon. Line 3. Period. Line 4. Period. Line 5. Period. Line 6. new
List P t r, equals, P t r to Copy, left parenthesis, list P t r, right
parenthesis, semicolon.
Back to Figure
Program code. Line 1. P t r To Copy, left parenthesis, In, colon, list P
t r, right parenthesis, tab space, forward slash, forward slash,
Iterative algorithm. Line 2. Out, colon, Function value. Line 3. IF, list
P t r is NULL. Line 4, indented once. Return, NULL. Line 5. Forward
slash, forward slash, Copy first node. Line 6. Set, from P t r, equals,
list P t r. Line 7. Set, copy P t r, equals, new, Node Type. Line 8. Set,
copy P t r, hyphen, greater than, component, equals, from P t r,
hyphen, right angle bracket, component. Line 9. Forward slash,
forward slash, Copy remaining nodes. Line 10. Set, to P t r, equals,
copy P t r. Line 11. Set, from P t r, equals, from P t r, hyphen, right
angle bracket, link. Line 12. WHILE, from P t r, is, not, NULL. Line
13, indented once. Set, to P t r, hyphen, right angle bracket, link,
equals, new, Node Type. Line 14, indented once. Set, to P t r,
equals, to P t r, hyphen, right angle bracket, link. Line 15, indented
once. Set, to P t r, hyphen, right angle bracket, component, equals,
from P t r, hyphen, right angle bracket, component. Line 16,
indented once. Set, from P t r, equals, from P t r, hyphen, right angle
bracket, link. Line 17, indented once. Set, to P t r, hyphen, right
angle bracket, link, equals, NULL. Line 18. Return, copy P t r.
Back to Figure
Program code. Line 1. P t r To Copy, left parenthesis, In, colon, from
P t r, right parenthesis, tab space, forward slash, forward slash,
Recursive algorithm. Line 2, indented once. Out, colon, Function
value. Line 3. IF, from P t r, is, NULL. Line 4, indented once. Return,
NULL. Line 5. ELSE. Line 6, indented once. Set, to P t r, equals,
new, Node Type. Line 7, indented once. Set, to P t r, hyphen, right
angle bracket, Component, equals, from P t r, hyphen, right angle
bracket, component. Line 8, indented once. Set, to P t r, hyphen,
right angle bracket, link, equals, P t r To Copy, left parenthesis, from
P t r, hyphen, right angle bracket, link, right parenthesis. Line 9,
indented once. Return, to P t r.

Back to Figure
Program code. Line 1. Node P t r, P t r To Copy, left parenthesis,
Node P t r, from P t r, right parenthesis. Line 2. Forward slash,
forward slash, Pre, colon, from P t r points to a list node or NULL.
Line 3. Forward slash, forward slash, Post, colon, If from P t r is not
NULL, comma, a copy of the entire sub list. Line 4. Forward slash,
forward slash, starting with asterisk from P t r is on the free store
and. Line 5. Forward slash, forward slash, function value is the
pointer to front of this sublist. Line 6. Forward slash, forward slash,
else. Line 7. Forward slash, forward slash, Return value is NULL.
Line 8. Left brace. Line 9, indented once. Node P t r to P t r,
semicolon, tab space, forward slash, forward slash, Pointer to newly
created node. Line 10, indented once. if, left parenthesis, from P t r,
equals, equals, NULL, right parenthesis. Line 11, indented twice.
return, NULL, semicolon, forward slash, forward slash, Base case.
Line 12, indented once. else. Line 13, indented once. Left brace, tab
spaces, forward slash, forward slash, Recursive case. Line 14,
indented twice. to P t r, equals, new, Node Type, semicolon. Line 15,
indented twice. to P t r, hyphen, right angle bracket, component,
equals, from P t r, hyphen, right angle bracket, component,
semicolon. Line 16, indented twice. to P t r, hyphen, right angle
bracket, link, equals, P t r To Copy, left parenthesis, from P t r,
hyphen, right angle bracket, link, right parenthesis, semicolon. Line
17, indented twice. return, to P t r, semicolon. Line 18, indented
once. Right brace. Line 19. Right brace.
Back to Figure
Code that contains a function call. Program code. Line 1. new List P
t r, equals, P t r To Copy, left parenthesis, list P t r, right parenthesis,
semicolon.
Back to Figure
A diagram depicting a linked list that will be used in a program. The
list P t r points to the element 49. The next pointer of the element 49
points to the element 50. The next pointer of the element 50 points

to the element 58. 58 is the last element in the linked list. Its next
pointer points to NULL.
Back to Figure
A diagram that shows the pointer from P t r and the element that is
points to. From P t r points to the node containing 49.
Back to Figure
A diagram that shows what happens during call 2 of the function.
The pointer from P t r points to the node containing 50. A new node
is allocated and its component value is set to 50.
Back to Figure
A diagram that shows what happens during call 3 of the function.
The pointer from P t r points to the node containing 58. A new node
is allocated and its component value is set to 58.
Back to Figure
A diagram that shows what happens during call 4 of the function.
The pointer from P t r is NULL. The list remains unchanged.
Back to Figure
A diagram that shows what happens when control goes to the
preceding call which is call 3. The returned function value, NULL is
assigned to to P t r, hyphen, right angle bracket, link. to P t r points
to the element 58. The next pointer of 58 points to NULL.
Back to Figure
A diagram that shows what happens when the value of to P t r is
returned to the preceding call which is call 2. The returned function
value which is the address of the third node is assigned to to P t r,
hyphen, right angle bracket, link. The pointer to P t r now points to
the node with the element 50.

Back to Figure
A diagram that shows what happens when the value of to P t r is
returned to the preceding call which is call 1. The returned function
value which is the address of the second node is assigned to to P t r,
hyphen, right angle bracket, link. The pointer to P t r now points to
the node with the element 49.
Back to Figure
A diagram that shows how a list is ordered using the Quicksort
algorithm. The diagram shows a array of final exams to sort by
name. The array has names from A to Z. A splitting value, L is
chosen and the array is divided into two piles, A to L and M to Z.
The first pile is taken and subdivided into two piles, A to F and G to
L. The A to F pile is further broken down into A to C and D to F.
Similarly, the M to Z pile is broken down into M to R and S to Z.
Back to Figure
The steps in the Quicksort algorithm. Line 1. Quicksort, left
parenthesis, In, colon, first, comma, last, right parenthesis. Line 2.
IF there is more than one item in data, left bracket, first, right
bracket, to data, left bracket, last, right bracket. Line 3. Select split
Val. Line 4. Split the data so that. Line 5. data, left bracket, first,
right bracket, to data, left bracket, split Point, minus, 1, right
bracket, less than or equals, split Val. Line 6. data, left bracket, split
Point, right bracket, equals, split Val. Line 7. data, left bracket, split
Point, plus, 1, right bracket, to, data, left bracket, last, right bracket,
greater than, split Val. Line 8. Quicksort the left half. Line 9.
Quicksort the right half.
Back to Figure
An example of how a splitting value is selected for a array. The array
has the following elements. 9, 20, 6, 10, 14, 8, 60, and 11. 9 is first
and 11 is last. The splitting value selected is 9.
Back to Figure

After the splitting value of 9 is selected, the items less than or equal
to this value on the left side of the data and the items greater than
this value are on the right side of the data. Accordingly, the items in
the array are 9, 8, 6, 10, 14, 20, 60, and 11. The smaller data are 8
and 6. The larger data are 10, 14, 20, 60, and 11.
Back to Figure
The two halves of the array meeting at the splitting point.
Accordingly, the items in the array are the following. 6, 8, 9 which is
the smaller data followed by 10, 14, 20, 60, and 11 which is the
larger data. 9 is the split point.
Back to Figure
Code for the Quicksort function. Program code. Line 1. template, left
angle bracket, class, Item Type, right angle bracket. Line 2. void,
Quick sort, left parenthesis, Item Type, data, left bracket, right
bracket, comma, i n t, first, comma, i n t, last, right parenthesis. Line
3. Forward slash, forward slash, Pre, colon, Compared To has been
defined on Item Type. Line 4. Forward slash, forward slash, Post,
colon, data are sorted. Line 5. Left brace. Line 6, indented once. if,
left parenthesis, first, less than, last, right parenthesis. Line 7,
indented once. Left brace. Line 8, indented twice. i n t, split Point,
semicolon. Line 9, indented twice. Split, left parenthesis, data,
comma, first, comma, last, comma, split Point, right parenthesis,
semicolon. Line 10, indented twice. forward slash, forward slash,
data, left bracket, first, right bracket, dot, dot, data, left bracket, split
Point, minus, 1, right bracket, less than or equals, split Val. Line 11,
indented twice. Forward slash, forward slash, data, left bracket, split
Point, right bracket, equals, split Val. Line 12, indented twice.
Forward slash, forward slash, data, left bracket, split Point, plus, 1,
right bracket, dot, dot, data, left bracket, last, right bracket, greater
than, split Val. Line 13, indented twice. Quicksort, left parenthesis,
data, comma, first, comma, split Point, minus, 1, right parenthesis,
semicolon. Line 14, indented twice. Quicksort, left parenthesis, data,
comma, split Point, plus, 1, comma, last, right parenthesis,
semicolon. Line 15, indented once. Right brace. Line 16. Right
brace.

Back to Figure
A diagram showing the steps that are taken to move the elements
that are equal to or less than the split value on one side of the split
value and all of the elements that are greater than split value on the
other side. a) Initialization. The items in the array are 9, 20, 6, 10,
14, 8, 60, and 11. save first is 9. first is 20. last is 11. b) Increment
first until values of first greater than split value. The items in the
array are 9, 20, 6, 10, 14, 8, 60, and 11. save first is 9. first is 20.
last is 11. c) Decrement last until values of last less than or equals
split Value. The items in the array are 9, 20, 6, 10, 14, 8, 60, and 11.
save first is 9. first is 20. last is 8. d) Swap values of first and values
of last; move first and last toward each other. The items in the array
are 9, 8, 6, 10, 14, 20, 60, and 11. save first is 9. first is 6. last is 14.
e) Increment first until values of first greater than split Value or first
greater than last. Decrement last until values of last less than or
equals split Value or first greater than last. The items in the array are
9, 8, 6, 10, 14, 20, 60, and 11. save first is 9. last is 6. first is 10. f)
first greater than last so no swap occurs within the loop. Swap
values of save First and values of last. The items in the array are 6,
8, 9, 10, 14, 8, 60, and 11. save first is 6. last and split point is 9.
Back to Figure
Three functions are placed in a single file for the Quicksort
algorithm. Program code. Line 1. template, left angle bracket, class,
Item Type, right angle bracket. Line 2. void, Swap, left parenthesis,
Item Type ampersand, item 1, comma, Item Type ampersand, item
2, right parenthesis. Line 3. Forward slash, forward slash, Post,
colon, Contents of item 1 and item 2 have been swapped. Line 4.
Left brace. Line 5, indented once. Item Type, temp Item, semicolon.
Line 6, indented once. temp Item, equals, item 1, semicolon. Line 7,
indented once. item 1, equals, item 2, semicolon. Line 8, indented
once. item 2, equals, temp Item, semicolon. Line 9. Right brace.
Line 10. template, left angle bracket, class, Item Type, right angle
bracket. Line 11. void, Split, left parenthesis, Item Type, data, left
bracket, right bracket, comma, i n t, first, comma, i n t, last, comma,
i n t, ampersand, split Point, right parenthesis. Line 12. Forward
slash, forward slash, Pre, colon, Compared To has been defined on

Item Type. Line 13. Forward slash, forward slash, Post, colon, All
items greater than split value are to the left and all. Line 14. Forward
slash, forward slash, items less than or equal to split value are to the
right. Line 15. Left brace. Line 16, indented once. Item Type, split
Val, equals, data, left bracket, first, right bracket, semicolon. Line 17,
indented once. i n t, save First, equals, first, semicolon. Line 18,
indented once. bool, on Correct Side, semicolon. Line 19, indented
once. first, plus, plus, semicolon. Line 20, indented once. do. Line
21, indented once. Left brace. Line 22, indented once. on Correct
Side, equals, true, semicolon. Line 23; while, left parenthesis, on
Correct Side, right parenthesis, tab space, forward slash, forward
slash, Move first toward last. Line 24, indented twice. switch, left
parenthesis, data, left bracket, first, right bracket, dot, Compared
To, left parenthesis, split Val, right parenthesis, right parenthesis.
Line 25, indented twice. Left brace. Line 26, indented 3 times. case,
AFTER, colon, on Correct Side, equals, false, semicolon. Line 27,
indented a few times. break, semicolon. Line 28, indented 3 times.
case, SAME, colon. Line 29, indented 3 times. case, BEFORE,
colon, first, plus, plus, semicolon. Line 30, indented a few times. on
Correct Side, equals, left parenthesis, first, less than or equals, last,
right parenthesis, semicolon. Line 31, indented a few times. break,
semicolon. Line 32, indented twice. Right brace. Line 33, indented
once. on Correct Side, equals, left parenthesis, first, less than or
equals, last, right parenthesis, semicolon. Line 34, indented once.
while, left parenthesis, on Correct Side, right parenthesis, tab space,
forward slash, forward slash, Move last toward first. Line 35,
indented once. switch, left parenthesis, data, left bracket, last, right
bracket, dot, Compared To, left parenthesis, split Val, right
parenthesis, right parenthesis. Line 36, indented once. Left brace.
Line 37, indented twice. case, SAME, colon. Line 38, indented twice.
case, BEFORE, colon, on Correct Side, equals, false, semicolon.
Line 39, indented a few times. break, semicolon. Line 40, indented
twice. case, AFTER, colon, last, minus, minus, semicolon. Line 41,
indented a few times. on Correct Side, equals, left parenthesis, first,
less than or equals, last, right parenthesis, semicolon. Line 42,
indented a few times. break, semicolon. Line 43, indented once.
Right brace. Line 44, indented twice. if, left parenthesis, first, less
than, last, right parenthesis. Line 45, indented twice. Left brace. Line
46, indented 3 times. Swap, left parenthesis, data, left bracket, first,

right bracket, comma, data, left bracket, last, right bracket, right
parenthesis, semicolon. Line 47, indented 3 times. first, plus, plus,
semicolon. Line 48, indented 3 times. last, minus, minus, semicolon.
Line 49, indented twice. Right brace. Line 50, indented once. Right
brace. while, left parenthesis, first, less than or equals, last, right
parenthesis, semicolon. Line 51, indented once. split Point, equals,
last, semicolon. Line 52, indented once. swap, left parenthesis, data,
left bracket, save First, right bracket, comma, data, left bracket, split
Point, right bracket, right parenthesis, semicolon. Line 53. Right
brace.
Back to Figure
Code for the driver in the Quicksort algorithm. Program code. Line
1. Forward slash, forward slash, a line of asterisks. Line 2. Forward
slash, forward slash, Driver for the Quicksort algorithm. Line 3.
Forward slash, forward slash, a line of asterisks. Line 4. Hash,
include, left angle bracket, i o stream, right angle bracket. Line 5.
Hash, include, left angle bracket, string, right angle bracket. Line 6.
Hash, include, open quotes, Name, dot, h, close quotes. Line 7.
Hash, include, open quotes, Quicksort, dot, h, close quotes. Line 8.
using, name space, s t d, semicolon. Line 9. Name, Read Name, left
parenthesis, right parenthesis, semicolon. Line 10. Forward slash,
forward slash, Prompts for and reads a name from the standard
input device. Line 11. i n t, main, left parenthesis, right parenthesis.
Line 12. Left brace. Line 13, indented once. Name, data, left
parenthesis, 15, right parenthesis, semicolon. Line 14, indented
once. Name, name, semicolon. Line 15, indented once. Forward
slash, forward slash, Read in 15 names. Line 16, indented once. for,
left parenthesis, i n t, index, equals, 0, semicolon, index, less than,
15, semicolon, index, plus, plus, right parenthesis. Line 17, indented
once. Left brace. Line 18, indented twice. name, equals, Read
Name, left parenthesis, right parenthesis, semicolon. Line 19,
indented twice. data, left bracket, index, right bracket, equals, name,
semicolon. Line 20, indented once. Right brace. Line 21, indented
once. Forward slash, forward slash, Sort 15 names. Line 22,
indented once. Quicksort, left parenthesis, data, comma, 0, comma,
14, right parenthesis, semicolon. Line 23, indented once. Forward
slash, forward slash, Output first and last name in sorted order. Line

24, indented once. for, left parenthesis, i n t, index, equals, 0,
semicolon, index, less than, 15, semicolon, index, plus, plus, right
parenthesis. Line 25, indented twice. c out, double left angle
bracket, data, left bracket, index, right bracket, dot, Get First Name,
left parenthesis, right parenthesis, double left angle bracket, open
quotes, space, close quotes. Line 26, indented a few times. Double
left angle bracket, data, left bracket, index, right bracket, dot, Get
Last Name, left parenthesis, right parenthesis, double left angle
bracket, end l, semicolon. Line 27, indented once. return, 0,
semicolon. Line 28. Right brace. Line 29. Forward slash, forward
slash, a line of asterisks. Line 30. Name, Read Name, left
parenthesis, right parenthesis. Line 31. Left brace. Line 32, indented
once. string, first, comma, middle, comma, last, semicolon. Line 33,
indented once. c out, double left angle bracket, open quotes, Enter
first name, colon, space, close quotes, semicolon, tab space,
forward slash, forward slash, Prompt for first name. Line 34,
indented once. c in, double right angle bracket, first, semicolon, tab
space, forward slash, forward slash, Get first name. Line 35,
indented once. c out, double left angle bracket, open quotes, Enter
middle name, colon, space, close quotes, semicolon, tab space,
forward slash, forward slash, Prompt for middle name. Line 36,
indented once. c in, double right angle bracket, middle, semicolon,
tab space, forward slash, forward slash, Get middle name. Line 37,
indented once. c out, double left angle bracket, open quotes, Enter
last name, colon, space, close quotes, tab space, forward slash,
forward slash, Prompt for last name. Line 38, indented once. c in,
double right angle bracket, last, semicolon, tab space, forward slash,
forward slash, Get last name. Line 39, indented once. Name, name,
left parenthesis, first, comma, middle, comma, last, right
parenthesis, semicolon. Line 40, indented once. return, name,
semicolon. Line 41, indented once. Right brace.
Back to Figure
The output during a sample run of the quick sort program. Line 1.
Enter first name: Sam. Line 2. Enter middle name: Sloan. Line 3.
Enter last name: Smith. Line 4. Enter first name: Joe. Line 5. Enter
middle name: John. Line 6. Enter last name: Jones. Line 7. Enter
first name: Bill. Line 8. Enter middle name: Bradley. Line 9. Enter

last name: Black. Line 10. Enter first name: Jane. Line 11. Enter
middle name: June. Line 12. Enter last name: Jones. Line 13. Enter
first name: Gray. Line 14. Enter middle name: G. Line 15. Enter last
name: Green. Line 16. Enter first name: Pansy. Line 17. Enter
middle name: P. Line 18. Enter last name: Potter. Line 19. Enter first
name: Rose. Line 20. Enter middle name: Violet. Line 21. Enter last
name: Red. Line 22. Enter first name: Yellow. Line 23. Enter middle
name: Y. Line 24. Enter last name: Yarn. Line 25. Enter first name:
Calvin. Line 26. Enter middle name: Charles. Line 27. Enter last
name: Carson. Line 28. Enter first name: Alfred. Line 29. Enter
middle name: Albert. Line 30. Enter last name: Alred. Line 31. Enter
first name: Nell. Line 32. Enter middle name: Nancy. Line 33. Enter
last name: Night. Line 34. Enter first name: Carol. Line 35. Enter
middle name: Carter. Line 36. Enter last name: Carton. Line 37.
Enter first name: Zoe. Line 38. Enter middle name: Z. Line 39. Enter
last name: Zebra. Line 40. Enter first name: June. Line 41. Enter
middle name: May. Line 42. Enter last name: July. Line 43. Enter
first name: Son. Line 44. Enter middle name: Shine. Line 45. Enter
last name: Sunlight. Line 46. Alfred Alred. Line 47. Bill Black. Line
48. Calvin Carson. Line 49. Carol Carton. Line 50. Gray Green. Line
51. Jane Jones. Line 52. Joe Jones. Line 53. June July. Line 54. Nell
Night. Line 55. Pansy Potter. Line 56. Rose Red. Line 57. Sam
Smith. Line 58. Son Sunlight. Line 59. Yellow Yarn. Line 60. Zoe
Zebra.
Back to Figure
The input data for the program in question number 18.12 under
exam preparation exercises. Line 1. 10. Line 2. 20. Line 3. 30.
Back to Figure
Program listed in question number 18.12 under exam preparation
exercises. Line 1. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 2. using, name space, s t d, semicolon. Line 3.
void, Rev, left parenthesis, right parenthesis, semicolon. Line 4. i n t,
main, left parenthesis, right parenthesis. Line 5. Left brace. Line 6,
indented once. Rev, left parenthesis, right parenthesis, semicolon.
Line 7, indented once. return, 0, semicolon. Line 8. Right brace. Line

9. Forward slash, forward slash, a line of asterisks. Line 10. void,
Rev, left parenthesis, right parenthesis. Line 11. Left brace. Line 12,
indented once. i n t, number, semicolon. Line 13, indented once. c
in, double right angle bracket, number, semicolon. Line 14, indented
once. if, left parenthesis, c in, right parenthesis. Line 15, indented
once. Left brace. Line 16, indented twice. Rev, left parenthesis, right
parenthesis, semicolon. Line 17, indented twice. c out, double left
angle bracket, number, double left angle bracket, end l, semicolon.
Line 18, indented once. Right brace. Line 19. Right brace.
Back to Figure
Program listed in question number 18.13 under exam preparation
exercises. Line 1. void, Rev, left parenthesis, right parenthesis. Line
2. Left brace. Line 3, indented once. i n t, number, semicolon. Line
4, indented once. c in, double right angle bracket, number,
semicolon. Line 5, indented once. if, left parenthesis, c in, right
parenthesis. Line 6, indented once. Left brace. Line 7, indented
twice. c out, double left angle bracket, number, double left angle
bracket, end l, semicolon. Line 8, indented twice. Rev, left
parenthesis, right parenthesis, semicolon. Line 9, indented twice. c
out, double left angle bracket, number, double left angle bracket,
end l, semicolon. Line 10, indented once. Right brace. Line 11. Right
brace.
Back to Figure
Program listed in question number 18.14 under exam preparation
exercises. Line 1. Hash, include, left angle bracket, i o stream, right
angle bracket. Line 2. using, name space, s t d, semicolon. Line 3.
void, Rec, left parenthesis, string, word, right parenthesis,
semicolon. Line 4. i n t, main, left parenthesis, right parenthesis.
Line 5. Left brace. Line 6, indented cone. 
Rec, left parenthesis, open quotes, abcde, close quotes, right
parenthesis, semicolon. Line 7, indented once. return, 0, semicolon.
Line 8. Right brace. Line 9. Forward slash, forward slash, a line of
asterisks. Line 10. void, Rec, left parenthesis, string, word, right
parenthesis. Line 11. Left brace. Line 12, indented once. if, left
parenthesis, word, dot, length, left parenthesis, right parenthesis,

greater than, 0, right parenthesis. Line 13, indented once. Left
brace. Line 14, indented twice. c out, double left angle bracket,
word, dot, sub s t r, left parenthesis, 0, comma, 1, right parenthesis,
semicolon. Line 15, indented twice. Rec, left parenthesis, word, dot,
sub s t r, left parenthesis, 1, comma, word, dot, length, left
parenthesis, right parenthesis, minus 2, right parenthesis, right
parenthesis, semicolon. Line 16, indented twice. c out, double left
angle bracket, word, dot, sub s t r, left parenthesis, word, dot,
length, left parenthesis, right parenthesis, minus, 1, comma, 1, right
parenthesis, double left angle bracket, end l, semicolon. Line 17,
indented once. Right brace. Line 18. Right brace.
Back to Figure
The details of a program getting input listed in question number 18.4
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Enter positive number, 0 to end: 20.
Line 3. Enter positive number, 0 to end: 30. Line 4. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.4 under
programming warm-up exercises. Line 1. 30. Line 2. 20. Line 3. 10.
Back to Figure
The details of a program getting input listed in question number 18.5
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Total: 10. Line 3. Enter positive
number, 0 to end: 20. Line 4. Total: 30. Line 5. Enter positive
number, 0 to end: 30. Line 6. Total: 60. Line 7. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.5 under
programming warm-up exercises. Line 1. 30. Line 2. 20. Line 3. 10.
Back to Figure

The details of a program getting input listed in question number 18.6
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Total: 10. Line 3. Enter positive
number, 0 to end: 20. Line 4. Total: 30. Line 5. Enter positive
number, 0 to end: 30. Line 6. Total: 60. Line 7. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.6 under
programming warm-up exercises. Line 1. 30 Total: 30. Line 2. 20
Total: 50. Line 3. 10 Total: 60.
Back to Figure
The details of a program getting input listed in question number 18.7
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Enter positive number, 0 to end: 20.
Line 3. Enter positive number, 0 to end: 30. Line 4. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.7 under
programming warm-up exercises. Line 1. 30. Line 2. 20. Line 3. 10.
Line 4. The greatest is 30.
Back to Figure
The details of a program getting input listed in question number 18.8
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Greatest: 10. Line 3. Enter positive
number, 0 to end: 30. Line 4. Greatest: 30. Line 5. Enter positive
number, 0 to end: 20. Line 6. Greatest: 30. Line 7. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.8 under
programming warm-up exercises. Line 1. 20. Line 2. 30. Line 3. 10.

Line 4. The greatest is 30.
Back to Figure
The details of a program getting input listed in question number 18.9
under programming warm-up exercises. Line 1. Enter positive
number, 0 to end: 10. Line 2. Greatest: 10. Line 3. Enter positive
number, 0 to end: 30. Line 4. Greatest: 30. Line 5. Enter positive
number, 0 to end: 20. Line 6. Greatest: 30. Line 7. Enter positive
number, 0 to end: 0.
Back to Figure
The output of a function listed for question number 18.9 under
programming warm-up exercises. Line 1. 20 Greatest: 20. Line 2. 30
Greatest: 30. Line 3. 10 Greatest: 30. Line 4. The greatest is 30.
Back to Figure
Declarations listed in question number 18.10 under programming
warm-up exercises. Program code. Line 1. struct, Node Type,
semicolon. Line 2. type def, Node Type, asterisk, P t r Type,
semicolon. Line 3. struct, Node Type. Line 4. Left brace. Line 5. i n t,
info, semicolon. Line 6. P t r Type, link, semicolon. Line 7. Right
brace, semicolon. Line 8. P t r Type, list 1, semicolon. Line 9. P t r
Type, list 2, semicolon.
Back to Figure
The pattern for the Fibonacci series of numbers. 0, 1, 1, 2, 3, 5, 8,
13, 21, 34, 55, 89, 144, and so on.
Back to Figure
The recursive definition for the sequence F_n of Fibonacci numbers.
F_n = F_(n minus 1) + F_(n minus 2).
Calculating the Greatest Common Divisor or G C D. G C D of a,
comma, b = a, if b = 0. G C D of a, comma b = G C D of b comma,
a modulus of b, if b greater than 0.

Back to Figure
Decimal to binary conversion. 13 divided by 2 = 6. remainder 1. 6
divided by 2 = 3. remainder 0.
3 divided by 2 = 1. remainder 1. 1 divided by 2 = 0. remainder 1.
Back to Figure
The process of converting the binary number 1 1 1 0 0 1 into
decimal. 1 times 2^0 = 1. 0 times 2^1 = 0. 0 times 2^2 = 0. 1 times
2^3 = 8. 1 times 2^4 = 16. 1 times 2^5 = 32. Decimal value = 1 plus
0 plus 0 plus 8 plus 16 plus 32 equals 57.
Back to Figure

