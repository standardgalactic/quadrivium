

Programming 


I 
.t . r-. 
Programming 
Principles and Practice 
Using C++ 
Bjarne Stroustrup 
.'. Addison-Wesley 
Upper Saddle River, NJ • Boston • Indianapolis • San Francisco 
New York • Toronto • Montreal • london • Munich • Paris • Madrid 
Capetown • Sydney • Tokyo • Singapore • Mexico City 

~Ia.ny of the desigll3tions used by manufacturers and sellers to distinguish their products are claimed as 
trademarks. Where t11O$C design'llions app:ar in this book, and tIu:: publisher was aware of 3 tT"Jdcmark 
claim. the designations h,l\'e been primed with initial capitalleu",rs or in all capitals. 
A complete list of photo sources and credits appears on pages 1235- 1236. 
TIte author and publisher have taken care in the preparation of this book, but make no expressed or into 
plied warranty of any kind and assume no respon!!ibi!iLy for errors or omissions. No liability is assumed 
for incidental or comcqucntial damages in connection with or arising out of the usc of dte infonnation or 
prognum contained hcrein. 
11lC publiliher offcrs exccllent discounts on thi!! book when ordered in quantity for bulk purchases or spc-
cial sales, which may inelude electronic ver!!ions and/or custom C()\"crs and content particular to your busi· 
ness. training go.~ls. marketing focus. ~nd branding interests. For more information. please: contact: 
U.S. Corpor~Le and Go\"ernment Sales 
(800) 382-3419 
corpsalcs@pears01!tcchgroup.oont 
For salcs oULSide the United Statcs, please contact: 
Im",m:uional Sales 
imemational@p:arsolled.com 
Copyright 0 2009 Pearson EdUCllUon, Ill(:. 
StrouStrup. Bjame. 
Programming principia and practice using C++ I BjanlC Slroustrup. 
p. em. 
Includes bibliographical references and index. 
ISBN 978-{)'321·54372·1 (pbk. : alk. paper) I. C++ (Cornputer program language) I. ·litle. 
Q.A76.73.C l535822008 
005.13'3-dc22 
2008032595 
All righLS rc:scr"\'ed. Printed in the United States of America. ·n tis pUblication is ]Itutectcd by copyright. and 
p:nnission mUSt be: obtained from tIte publisher prior to any prohibited reproduction, ~ tor.lge in a mric\'al 
syst"'m. or transmission in any fOnll or by any mcans. electronic, IlIcchanic.1l, photocopying. recording, or 
lik",wisc:. For infom13tion rcg-Mding penn.issions. write to: 
PearKltl Education. Inc. 
RighLS and Contracts Departmcnt 
501 Boylston Strc:ct, Suite 900 
Boston. MA 02116 
FaJ<; (617) 671 ·3447 
ISBN·13: 978·0·321·54372·1 
ISBN· IO: 
0-32 1·54372-6 
·lo.a primed in the United States on rn:rded p.1p:r at CQurier in Kendalhille, Indiana. 
First printing, December 2008 

Preface xxiii 
Chapter 0 Noles to the Reader 
0.1 111C structure of lhis book 2 
0.1. 1 Gcncntl approach 3 
0. 1.2 Drills, exercises, etc. 
4 
0. 1.3 What comes after this book? 5 
Contents 
0.2 A philosophy of teaching and learning 6 
0.2. 1 lllC: order of topics 9 
0.2.2 Programming and programming language 
10 
0.2.3 Portability 
I I 
0.3 Programming and computer science 
12 
0.4 Creativity and problem solving 
12 
0.5 Request for feedback 
12 
0.6 References 
13 
0.7 Biographies 
14 
8jamc SrrouSll'UP 
14 
Lawrence "Pete" Pctcrsc=n 
15 
, 

Chapter 1 Computers, People, and Programming 
17 
1.1 Introduction 
18 
1.2 Software 
19 
1.3 People 21 
1.4 Computer science 
24 
1.5 Computers are evel)"vhere 25 
1.5.1 Screens and no screens 26 
1.5.2 Shipping 26 
1.5.3 l 'i::lecommunications 28 
1.5.4 Medicine 30 
1.5.5 lnfonnation 
31 
1.5.6 A "crtical view 32 
1.5.7 So what? 34 
1.6 Ideals for programmers 34 
Part I The Basics 
41 
Chapler 2 Hello. World! 
43 
2. 1 Pl.'Ograms 
44 
2.2 The classic first program 
45 
2.3 Compilation 47 
2.4 Linking 
51 
2.5 Programming environments 52 
Chapter 3 Objects. Types, and Values 
59 
3.1 Input 
60 
3.2 Variables 
62 
3.3 Input and type 
64-
3.4 Operations and operators 66 
3.5 Assignmem and initialization 69 
3.5.1 An example: dcJete repeated words 
71 
3.6 Composite assignment operators 
73 
3.6.1 An example: count repeated words 
73 
3.7 Names 
74 
3.8 Types and objects 
77 
3.9 Type safety 
78 
3.9.1 Safe conversions 79 
3.9.2 Uns •• fe conversions 80 
Chapter 4 Computation 89 
4.1 Computation 
90 
4.2 Objectives and tools 
92 
CONTENTS 

CONTENTS 
4.3 Expressions 
94 
4.3.1 Constant expressions 95 
4.3.2 Operators 96 
4.3.3 Conversions 98 
4.4 Statements 
99 
4.4.1 Selection 
10 1 
4.4.2 Iteration 
108 
4.5 Functions 
112 
4.5.1 Why bother wilh functions? 114 
4.5.2 Function declarations 
115 
4.6 Vcclor 
116 
4.6.1 Growing a vector 
118 
4.6.2 A numeric example 
119 
4.6.3 A text example 121 
4.7 Language features 
123 
Chapler 5 Errors 
1 3 1 
5. 1 
Imroduction 
132 
5.2 
Sources of errors 
134 
5.3 
Compile-time errors 
134 
5.3.1 Syntax errors 
135 
5.3.2 Type errors 
136 
5.3.3 Non·errors 
137 
5.4 
Link-time errors 
137 
5.5 
Run·time errors 
138 
5.5.1 llie caller deals with errors 
140 
5.5.2 -nle c.1.llec deals wilh errors 
141 
5.5.3 Error reporting 143 
5.6 
Exceptions 
144 
5.7 
5.8 
5.9 
5.10 
5. 11 
5.6.1 Bad arguments 
145 
5.6.2 Range errors 146 
5.6.3 Bad input 
148 
5.6.4 Narrowing errors 
151 
Logic errors 
152 
Estimation 
155 
Debugging 
156 
5.9.1 Praetical dcbug advice 
157 
Pre· and post-conditions 
161 
5.10. 1 Post·conditions 
163 
Testing 
164 
vii 

viii 
Chapter 6 Writing a Program 
171 
6.1 A problem 
172 
6.2 111inking about the problem 
173 
6.2.1 Stages of dcvelopmcnt 
174 
6.2.2 Slralcgy 
174 
6.3 Back to the ca1culaLOr! 
176 
6.3. 1 First attempt 
177 
6.3.2 Tokens 
179 
6.3.3 Implementing tokcns 181 
6.3.4 Using tokens 
183 
6.3.5 Back to the drawing board 
) 8S 
6.4 Granunars 
186 
6.4.1 A detour: English grammar 
191 
6.4.2 Writing a grammar 
192 
6.5 Turning a grammar into code 
193 
6.5. 1 Implcmcmi.ng gr.unmar rulcs 
194 
6.5.2 Expressions 
195 
6.5.3 Tcnns 
198 
6.5.4 Primary expressions 200 
6.6 Trying the first version 
201 
6.7 Trying the second version 
206 
6.8 Token streams 
207 
6.8.1 Implementing Token_slream 209 
6.8.2 Reading tokens 2 11 
6.8.3 Rcading numbcrs 212 
6.9 Program structure 
213 
Chapter 7 Completing a Program 
219 
7. 1 Introduction 
220 
7.2 Input and output 220 
7.3 Error handling 
222 
7.4 Negative numbers 
227 
7.5 Remainder: % 
228 
7.6 Cleaning up lhe code 
23 1 
7.6.1 Symbolic constants 
23 1 
7.6.2 Usc of functions 233 
7.6.3 Code layout 234 
7.6.4 Commenting 236 
7.7 Recovering from errors 
238 
7.8 Variables 
241 
7.8.1 Variablcs and dcfinitions 241 
7.8.2 Introducing namcs 
246 
7.8.3 Predefmcd names 
249 
7.8.4 Arc wc there yct? 249 
CONTENTS 

CONTENTS 
he 
Chapter 8 Technicalities: Functions, etc. 
253 
8.1 Technicalities 
254 
8.2 Declarations and definjtions 
255 
8.2.1 Kinds of declarations 259 
8.2.2 Variable and constant declarations 260 
8.2.3 Default initialization 261 
8.3 Header files 
261 
8.4 Scope 
264 
8.5 Function call and return 269 
8.5.1 Declaring arguments and return type 270 
8.5.2 Reluming a value 
271 
8.5.3 Pass-by-value 273 
8.5.4 Pass-by-const-reference 
273 
8.5.5 Pass·by-refcrellce 276 
8.5.6 Pass·by-value vs. pass-by-refercnce 279 
8.5.7 Argument check.ing and conversion 281 
8.5.8 FUllction call implementation 282 
8.6 Order of evaluation 
287 
8.6.1 E.o.:prcssion evaluation 288 
8.6.2 Global initialization 288 
8.7 Namespaces 
290 
8.7.1 using declarations and using directives 291 
Chapter 9 Technica lities: Classes, etc. 299 
9.1 User-defined types 
300 
9.2 Classes and members 301 
9.3 Interface and implementation 
302 
9.4 Evolving a class 
304 
9.4. 1 slrucl and functions 304 
9.4.2 Member functions and constructors 306 
9.4.3 Keep details private 308 
9.4.4 Defining member functions 
309 
9.4.5 Referring to the current object 312 
9.4.6 Rcportingerrors 313 
9.5 Enumerations 
314 
9.6 Operator overloading 316 
9.7 Class interfaces 3 18 
9.7.1 Argumelll types 319 
9.7.2 Copying 321 
9.7.3 Default constructors 322 
9.7.4 const member functions 
325 
9.7.5 Members and "helper functionsn 326 
9.8 TIle Oate class 
328 

" 
CONTENTS 
Part II Input and Output 337 
Chapter 10 Input and Output Streams 339 
10.1 Input and output 340 
10.2 TIle 110 stream model 341 
10.3 
Ftles 
343 
10.4 Opening a me 344 
10.5 
Reading and writing a me 346 
10.6 1/0 error handling 348 
10.7 
Reading a single value 352 
10.7. 1 B~aking the problem into manageable parts 353 
10.7.2 Separating dialog from function 
356 
10.8 
User-defined Output operators 357 
10.9 User-defined input operators 359 
10.10 A standard i.l1plllloop 359 
10.11 Reading a structured me 361 
10.1 1.1 In·memory n:presentation 
362 
10. 11 .2 Reading sU"Uctured values 364 
10.11.3 Changing n:presentations 
368 
Chapter 11 Customizing Input and Output 375 
ll.l Regularity and irregularity 376 
11 .2 Output formatting 376 
11 .2. 1 Integer output 377 
11.2.2 Integer inpm 379 
11 .2.3 Hoating-point output 380 
11 .2.4 Precision 
382 
11.2.5 Fields 383 
11.3 Ftle opening and positioning 384 
11.3.1 File open modes 385 
11 .3.2 Binary files 
386 
11.3.3 Positioning in files 389 
11.4 String streams 
390 
11.5 Linc-oriented input 391 
11 .6 Character classification 
392 
11.7 Using nonstandard separators 394 
11.8 And there is so much more 401 
Chapter 12 A Display Model 
407 
12.1 Why graphics? 408 
12.2 A display model 
409 
12.3 A first examplc 410 

CONTENTS 
Chapter 13 
Chapter 14 
12.4 UsingaGUIlibrary 
414 
12.5 Coordinales 
415 
12.6 Shapes 
416 
12.7 Using Shape primitives 
417 
12.7.1 
Graphics headers and main 
417 
12.7.2 
An almost blank window 
418 
12.7.3 
Axis 
420 
12.7.4 
Graphing a function 
422 
12.7.5 
Polygons 
423 
12.7.6 
Rectangles 
424 
12.7.7 
Ell 427 
12.7.8 
Text 
427 
12.7.9 
Images 
429 
12.7. 10 And much more 430 
12.8 Gelting tills to run 
431 
12.8.1 Source fues 
432 
Graphics Classes 437 
13.1 
Overview of graphics classes 
13.2 
Point and line 440 
13.3 
lines 443 
13.4 
Color 
445 
13.5 
line_style 
448 
13.6 
Open_polyline 450 
13.7 
Closed_polyline 451 
13.8 
Polygon 
453 
13.9 
Rectangle 
455 
13.10 Managing unnamed objects 
13.11 Text 
462 
13.12 Circle 464 
13.13 Ellipse 
466 
13.14 Marked_polyline 468 
13.15 Marks 
469 
13.16 Mark 
470 
13.17 Images 
472 
GraphiCS Class Design 
479 
14.1 Design principles 
480 
14. 1.1 Types 480 
14.1.2 Operations 482 
14.1.3 Naming 483 
14.1.4 Mutability 484 
438 
459 
,; 

xii 
Chapter 15 
14.2 Shape 485 
14.2.1 An absmlct class 487 
14.2.2 Access control 488 
14.2.3 Drawing shapes 491 
14.2.4 Copying and mutability 494 
14.3 Base and derived classes 
496 
14.3.1 Objcct layout 
497 
CONTEN TS 
14.3.2 Deriving classes and defining virtual functiollS 499 
14.3.3 Overriding 500 
14.3.4 Access 501 
14.3.5 Pure vinual funcuons 502 
14.4 Benefits of object-oricnted programming 504 
Graphing Functions and Data 509 
IS. I IntroductiOIl 
SIO 
IS.2 Graphing simple functions SIO 
IS.3 Function SI4 
15.3.1 Default argumcnts 515 
15.3.2 More examples 
517 
15.4 Axis 
518 
15.5 Approximation 521 
15.6 Graphing data 526 
15.6.1 Reading a rue 
528 
15.6.2 Gcnerallayout 
530 
15.6.3 Scaling data 53 1 
15.6.4 Building the graph 532 
Chapter 16 Graphical User Interfaces 
539 
16.1 User interface ahemativcs 
540 
16.2 Thc "Next" butlon 
541 
16.3 A simple window 
542 
16.3.1 A callback function 544 
16.3.2 A wait loop 547 
16.4 Bullon and othcr Widgets 548 
16.4.1 Widgets 548 
16.4.2 Bultons 549 
16.4.3 In_box and Oul_box 550 
16.<1.4 Menus 551 
16.5 An example 552 
16.6 Control inversion 
556 
16.7 Adding a menu 557 
16.8 Debugging CUI code 562 

CONTENTS 
xiii 
Part lit Data and Algorithms 567 
Chapte r 17 Vector and Free Store 
569 
17.1 
Introduction 
570 
17.2 
vector basics 
572 
17.3 
Memory, addresses, and poimers 
574 
17.3.1 111C sizeof operator 576 
17.4 
Free store and pointers 
577 
17.4.1 Free-store allocation 578 
17.4.2 Access through pointers 579 
17.4.3 Ranges 580 
17.4.4 Initialization 582 
17.4.5 TIle nuU poilller 583 
17.4.6 Frec-slOrc deallocation 584 
17.5 
Destructors 586 
17.5.1 Generated destructors 588 
17.5.2 Dcstructors and fTC(: store 
589 
17.6 
Access to clements 
590 
17.7 
Pointers to class objects 591 
17.8 
Messing with types: void" and casLS 
593 
17.9 
Pointers and references 
595 
17.9.1 Pointer and reference parameters 596 
17.9.2 Pointers, references, and inheritance 598 
17.9.3 An example: lists 598 
17.9.4 List operations 600 
17.9.5 List usc 
602 
17.10 The this pointer 
603 
17.10. 1 More link usc 
606 
Chapter 18 Vecto rs a nd Arrays 
6 1 1 
18.1 Introduction 
612 
18.2 Copying 
613 
18.2.1 Copy constmctol"S 
614 
18.2.2 Copy assignments 616 
18.2.3 Copy tcnninology 618 
18.3 Essential operations 
620 
18.3.1 Explicit constmclOrs 621 
18.3.2 Debugging constmctors and dcstmctors 622 
18.4 Access to ve ctor clements 
625 
18.4.1 Overloading on consl 626 

xiv 
CONTENTS 
18.5 Array, 
627 
18.5.1 Pointers to array clements 
628 
18.5.2 Pointers and arrays 631 
18.5.3 Array initialization 
633 
18.5.4 Pointer problems 
634 
18.6 Examples: palindrome 637 
18.6.1 Palindromes using Siring 
637 
18.6.2 Palindromes using arrays 638 
18.6.3 Palindromes using pointers 640 
Chapter 19 Vector, Templates, and Exceptions 645 
19.1 1ne problems 
646 
19.2 Changing size 
649 
19.2.1 Representation 
649 
19.2.2 reserve and c",pacily 
651 
19.2.3 
res i ~e 652 
19.2.4 push_back 652 
19.2.5 Assignment 
653 
19.2.6 Our veclor so far 
655 
19.3 Templates 
656 
19.3.1 l yPcs as template parameters 
656 
19.3.2 Generic programming 659 
19.3.3 Containers and inheritancc 
661 
19.3.4 Integers as template p.1ramcters 
662 
19.3.5 l cmplate argument deduction 664 
19.3.6 Generalizing vedor 665 
19.4 Range checking and exceptions 668 
19.4.1 An aside: design considerntions 
670 
19.4.2 A confession: macros 
67 1 
19.5 Resources and exceptions 
672 
19.5.1 Potential resource management problems 
673 
19.5.2 Resource acquisition is initiatization 
675 
19.5.3 Guarnntecs 
676 
19.5.4 auio-pir 
678 
19.5.5 RAIl for vedor 678 
Chapter 20 Containers and ilerators 685 
20.1 Storing and processing data 686 
20. 1.1 Working with data 
687 
20. 1.2 Gcnernlizing code 
688 
20.2 sn. ideals 
690 

CONTENTS 
xv 
20.3 
Sequences and ilerators 
694 
20.3.1 Back to the example 696 
20.4 
Linked lists 
698 
20.4.1 List operations 699 
20.4.2 Iteration 701 
20.5 
Generalizing vector yet again 
703 
20.6 
An example: a simple text editor 
704 
20.6. 1 Lines 
707 
20.7 
20.8 
20.9 
20. 10 
20.6.2 Iteration 
708 
vector, list, and string 
71 1 
20.7.1 insert and erase 713 
Adapting our vector to the STL 
715 
Adapting built-in arrays to the SlL 718 
Container overview 
719 
20.10. J Iterator categories 
722 
Chapter 21 Algorithms and Maps 
727 
2 1.1 Standard library algorithms 
2 1.2 The simplest algorithm: findO 
21.2.1 Some generic uses 
73 1 
728 
729 
2 1.3 The general search: findjfO 732 
2 1.4 Function objects 
734 
21.4.1 An abstract view of function objects 736 
21.4.2 Predicates on class members 737 
21.5 Numerical algorithm.s 
738 
21.5.1 Accumulate 
739 
21.5.2 Generalizing accumulate{) 
740 
21.5.3 Innerproduct 742 
21.5.4 Generalizing inner_productO 743 
21.6 Associative containers 
744 
21.6.1 Maps 
745 
21.6.2 map overview 
747 
21.6.3 Another map example 750 
21.6.4 unordered_map 753 
21.6.5 SelS 
755 
2 1.7 Copying 
757 
21.7.1 Copy 757 
21.7.2 Stream iterators 758 
21.7.3 Using a set to keep order 
761 
21.7.4 copy_if 761 
2 1.8 Sorting and searching 
762 

xvi 
CONTENTS 
Part IV Broadening the View 
769 
Chapter 22 Ideals and History 
77 1 
22.1 History, ideals, and prorcssionalism 
772 
22.1.1 Programmi.ng language ai.ms and philosophies 
772 
22.1.2 Progr.lIlll11ing ideals 
774 
22. 1.3 Styles/paradigms 
781 
22.2 Programming language history overview 
783 
22.2.1 TIle earliest languages 784 
22.2.2 TIle roots of modem languages 
786 
22.2.3 TIle Algol family 
791 
22.2.4 Sillluia 798 
22.2.5 C 
800 
22.2.6 C++ 804 
22.2.7 Today 807 
22.2.8 lnfonnation sources 808 
Chapter 23 Text Manipulation 
813 
23. 1 Text 814 
23.2 
Strings 
8 14 
23.3 
110 streams 
819 
23.4 
Maps 
820 
23.4. 1 Implementation details 826 
23.5 
A problem 828 
23.6 '11e idea of regular expressions 830 
23.7 
Searching with regular expressions 
833 
23.8 
Regular expression syntax 836 
23.8. 1 Characters and special chameters 836 
23.8.2 Character classes 837 
23.9 
23.10 
23.8.3 Repeats 838 
23.8.4 Grouping 840 
23.8.5 Atternation 
840 
23.8.6 Character sets and ranges 
841 
23.8.7 Regular expression errors 
842 
Matching wilh regular expressions 
References 
849 
Chapter 24 Numerics 
853 
24. 1 Introduction 854 
24.2 
Size, precision, and overflow 
854 
24.2. 1 Numeric limits 
858 
24.3 
Arrays 859 
844 
24.4 
C·slylc multidimensional arrays 
859 

CONTENTS 
24.5 
Thc Matrix library 861 
24.6 
24.7 
24.8 
24.9 
24.10 
24.5.1 Dimensions and access 862 
24.5.2 ID Matrix 
865 
24.5.3 2D Matrix 
868 
24.5.4 Matrix 110 870 
24.5.5 3D Matrix 
871 
An example: solving linear equations 
872 
24.6.1 Classical Gaussian elimination 
874 
24.6.2 Pivoting 875 
24.6.3 Testing 876 
Random numbers 
877 
The standard mathcmaticaJ functions 
879 
Complex numbers 
880 
References 
882 
Chapter 25 Embedded Systems Programming 887 
25.1 Embedded systems 
888 
25.2 Basic concepts 
891 
25.2.1 Prcdiclability 894 
25.2.2 Ideals 894 
25.2.3 Living with failure 895 
25.3 Memory managemcm 
897 
25.3.1 Free-store problems 898 
25.3.2 Alternatives to general free store 
901 
25.3.3 Pool example 902 
25.3.4 Slack example 903 
25.4 Addresses, pointers, and arrays 
905 
25.4. 1 Unchecked conversions 905 
25.4.2 A problem: dysfunctional intcrfaces 905 
25.4.3 A solution: an illlcrface class 909 
25.4.4 Inheritance and containers 912 
25.5 Bits, bytes, and words 
916 
25.5. 1 Bits and bit operations 
916 
25.5.2 bitsel 920 
25.5.3 Signed and unsigned 922 
25.5.4 Bit manipulation 
926 
25.5.5 Bitfic1ds 928 
25.5.6 An example: simple encryption 
930 
25.6 Coding standards 
935 
25.6.1 What should a coding standard be? 936 
25.6.2 Sample mles 937 
25.6.3 Real coding standards 943 
xvii 

xviii 
Chapter 26 Testing 949 
26.1 What we wam 
950 
26. 1.1 Caveat 
95 1 
26.2 Proofs 
952 
26.3 Testing 952 
26.3.1 Regression tests 
953 
26.3.2 Unit tests 
954 
26.3.3 Algorithms and non·algorithms 
961 
26.3.4 System tests 
969 
26.3.5 Testing classes 
973 
CONTENTS 
26.3.6 Finding as~umptions that do not hold 
976 
26.4 Design for testing 
978 
26.5 Debugging 
979 
26.6 Performance 
979 
26.6.1 Timing 981 
26.7 References 
983 
Chapter 27 The C Programming language 987 
27.1 C and C++: siblings 
988 
27.1.1 ClC++ compatibility 
990 
27.1.2 C++ features missing from C 
99 1 
27.1.3 The C standard library 993 
27.2 Functions 
994 
27.2. 1 No function name overloading 994 
27.2.2 Function argument type checking 995 
27.2.3 Function definitions 
997 
27.2.4 Calling C from C++ and C++ from C 
998 
27.2.5 Pointers to functions 
1000 
27.3 Minor language difTcrenccs 
1002 
27.3.1 struet tag namespace 
1002 
27.3.2 Keywords 
1003 
27.3.3 Definitions 
1004 
27.3.4 C·style casts 
1006 
27.3.5 Conversion of void· 
1007 
27.3.6 enum 
1008 
27.3.7 Namespaces 
1008 
27.4 Free store 
1009 
27.5 C·stylc strings 
lO ll 
27.5. 1 C·style strings and consl 
1013 
27.5.2 Byte operations 
1014 
27.5.3 An example: strcpyn 
lOIS 
27.5.4 A style issue 
1015 

CONTENTS 
27.6 Input/output: stdio 
10 16 
27.6.1 Output 
1016 
27.6.2 Input 
1017 
27.6.3 rues 
1019 
27.7 Constants and macros 
1020 
27.8 Macros 
1021 
27.8. 1 Function·likc macros 
1022 
27.8.2 Syntax macros 
1023 
27.8.3 Conditional compilation 
1024 
27.9 An example: intrusive containers 
1025 
Part V Appendices '035 
Appendix A Language Summary 
1037 
Al 
General 
1038 
A.l.l Tcnninology 
1039 
A.1.2 Program start and tcmlination 
1039 
A.1.3 Commcllts 
1040 
A.2 
Literals 
1041 
A.2. 1 Integcr litcrals 
104 1 
A.2.2 Floaling·point-lilcrals 
1042 
A.2.3 Boolcan lilcrals 
1043 
A.2.4 Characlcr lilcrals 
1043 
A.2.5 String litcrals 
1044 
A.2.6 Thc pointcr litcral 
1044 
A3 
Identifiers 
1045 
A.3.! Keywords 
1045 
A4 Scope, storage class, and lifetime 
1046 
AA.1 Seope 
1046 
A.4.2 Storage class 
1047 
A.4.3 Lifctimc 
1048 
AS 
Expressions 
1049 
A.5.1 Uscr-defined operators 
1054 
A.5.2 Implicit type convcrsion 
1054 
A.5.3 Constant cxpRSSions 
1056 
A.5A sizeof 
1057 
A.5.s Logical expressions 
1057 
A.5.6 new and delete 
1057 
A.5.7 Casts 
1058 
A.6 
Statements 
1059 
A7 
Declarations 
1061 
A.7.1 Definitions 
1061 
xix 

xx 
CONTENTS 
AS 
Built-in types 
1062 
A.8. 1 Pointers 
1063 
A.8.2 Arrays 
1064 
A.8.3 RefefCnces 
1065 
A.9 
Functions 
1066 
A.9.1 Overload resolution 
1067 
A.9.2 Default arguments 
1068 
A.9.3 Unspecified arguments 
1068 
A.9.4 Linkage specifications 
1069 
AIO User·defmed types 
1069 
A. IO.I Operator overloading 1069 
All Enumerations 
1070 
A 12 Classes 
1071 
A.12. 1 Member access 
1071 
A.12.2 Class member definitions 
1074 
A.12.3 Construction, dcstmction. and copy 
1075 
A.12.4 Derived classes 
1078 
A.12.5 Bitfidds 
1082 
A.12.6 Unions 
1082 
A. 13 l cmplates 
1083 
A.13.! Template arguments 
1084 
A. 13.2 "Icmplatc illStalltiauon 
1084 
A.13.3 "lcmplate member types 
1086 
A.14 Exceptions 
1086 
A 15 Namespaces 
1088 
A16 Aliases 
1089 
A 17 Preprocessor directives 
1090 
A. 17. 1 #include 
1090 
A. 17.2 #define 
1090 
Appendix B Standard Library Summary 1093 
n.1 O verview 
1094 
8.1.1 Header files 
1095 
B.1.2 Nalllespace SId 
1098 
B.l.3 Description style 
1098 
B.2 
Error handling 
1098 
B.2.1 Exceptions 
1099 
B.3 
Itcrators 
1100 
B.3.1 Itcrator model 
1101 
B.3.2 Itcrator categories 
1103 

CONTENTS 
B.4 
Containers 
1105 
8.1.1 
Overview 
1107 
B.4.2 
Member types 
1 !OS 
B.4.3 
ConstTIlctors, destructors, and assignmcnts 
11 OS 
B.4.4 
Itcrators 
1109 
8.4.5 
Element access 
1109 
8.4.6 
Stack and queue operations 
1110 
8.4.7 
List operations 
1110 
8.4.S 
Size and capacity 
1110 
8.4.9 
Other operations 
1111 
8.4.10 Associative container operations 
1111 
B.5 
Algorithms 
1112 
B.5.1 Nonmodifying sequence algorithms 
1113 
B.5.2 Modifying sequence algorilluns 
1114 
B.5.3 Utility algorithms 
1116 
B.5.4 Soning and searching 1117 
B.5.5 Set algorithms 
IllS 
B.5.6 Heaps 
1119 
B.5.7 Pcnnutations 
1120 
B.5.S min and ma;ll: 
1120 
B.G STL utilities 
1121 
B.6.1 Inserters 
1121 
B.6.2 Function objects 
11 22 
B.6.3 pair 
1123 
B.7 
1/0 streams 
11 24 
D.7.1 110 streams hicrarchy 
1126 
D.7.2 EITOr handling 
1127 
B.7.3 Input operations 
1128 
B.7.4 OmpUl operations 
112S 
B.7.5 Fonnatting 
1129 
B.7.6 Standard manipulators 
1129 
B.S 
String manipulation 
1131 
B.8.l Character classification 
1131 
8.8.2 String 
1132 
B.S.3 Regular expression matching 1133 
B.9 
Numerics 
1135 
8.9.1 Numerical1imits 
1135 
8.9.2 Standard mathematical functions 
1137 
8.9.3 Complex 
1138 
8 .9.4 valarray 
11 39 
B.9.5 Generalized numerical algorithms 
1139 
xxi 

uii 
RIO C standard library functions 
1140 
B.lO.1 Fiies 
1140 
B.10.2 -nle prinlf() family 
1141 
B.10.3 Cstyle strings 
1145 
B.I O.4 Memory 
1146 
B.IO.5 Date and time 
1147 
B.IO.6 Etc. 
1149 
B.II Other libraries 
1150 
Appendix C Getting Started with Visual Studio 
1151 
C.I Getting a program to run 
1152 
C.2 Installing Visual Studio 
1152 
C.3 Creating and running a program 
1153 
C.3. 1 Create a new project 
1153 
CO NTENTS 
C.3.2 Use the sld_lib_facilities.h header file 
1153 
C.3.3 Add a C++ source file to the project 
1154 
C.3.4 Enler your source code 
1154 
G.3.5 Build an executable program 
1154 
C.3.6 Execute the program 
11 55 
C.3.7 Save the program 
1155 
C.4 Later 
1155 
Appendix 0 Installing FlTK 
1157 
0 .1 Introduction 
1158 
0 .2 Downloading FLTK 
1158 
0 .3 Installing FLTK 
1159 
0 .4 Using FLTK in Visual Studio 
1159 
0 .5 Testingifit all worked 
1160 
Appendix E GUl lmplementation 
1161 
E.l Callback implementation 
1162 
E.2 Widget im plementation 
1163 
E.3 Window implementation 
1164 
E.4 VeClouef 1166 
E.5 An example: manipulating Widgets 
1167 
Glossary 
1171 
Bibliography 
1177 
Index 
//81 

Preface 
"Damn the torpedoes! 
Full speed ahead." 
-Admiral Farragut 
Programming is the an of expressing solutions to problems so that a computer 
C;1.Il execute lhose solutions. Much of the effon in progranuning is spem finding 
and refining solutions. Often, a problem is only fully understood through the 
process of programming a solution for it. 
111i5 book is for someone who has never progranullcd before but is willing 
to work hard to learn. It helps you understand the principles and acquire the 
practical skills of programming using the C++ programming language. My aim 
is for you to gain sufficient knowledge and experience to perform simple useful 
programming tasks using the best up-to-date techniques. How long will that 
take? As pari of a first-year university course, you can work through this book in 
a semester (assuming that yOll have a workload of four courses of average diffi-
culty). If you work by yourself, don't expect to spend less time than that (maybe 
15 hours a week for 14 weeks). 
111ree lllonths may seem a long time, but there's a lot to learn and you'll be 
\vriting your rlISI simple programs after about an hour. Also, all learning is grad-
ual: each chapter introduces new useful concepts and illustrates them with exam-
plcs inspired by real-world uscs. Your ability to express ideas in code - getling a 
computer to do what you want it to do - gradually and steadily increases as you 
go along. I never say, "Learn a month's worth of theory and then see if YOll can 
use 11." 
xxiii 

u iv 
PREFA C E 
Why would you wam to program? Our civilization runs on software. With-
out understanding software you are reduced to believing in "magic" and will be 
locked alit of many of tile most interesting, profitable, and socially usefu l techni-
cal fields of work. When I talk about programming, I think of the whole spec-
trum of computer programs from personal computer applications with GUls 
(graphical user interfaces), through engineering calculations and embedded sys-
tems control applications (such as digital cameras, cars, and cell phones), to text 
manipulation applications as found in many humanities and business applica-
tions. Like mathematics, programming - when done well - is a valuable intellec-
tual exercise that sharpens our ability to think. However, thanks to feedback 
from the computer, programming is more concrete than 1110St forms of math, and 
therefore accessible to more people. It is a way to reach out and change the world 
- ideally for the better. Finally, programming can be great fun. 
Why C++? You can't learn to program without a programming language, 
and C++ directly supports the key concepts and techniques used in real-world 
software. C++ is one of the most widely used programming languages, found in 
an unsurpassed rallge of application areas. You fmd C++ applications every-
where from the bottom of the oceans to the surface of Mars. C++ is precisely 
and comprehensively defmed by a nonproprietary international standard. Qlal-
ity and/or free implementations arc available on every kind of computer. Most of 
the programming concepts that you will learn using C++ can be Llsed directly in 
other languages, such as C, C#, Fortran, and J ava. i;"jnally, I simply like C++ as 
a language for writing elegant and efficient code. 
This is not the easiest book on beginning programming; it is not meant to 
be. I just aim for it to be the easiest book from which you can learn the basics of 
real-world progranuning. That's quite an ambitious goal because much modern 
software relics on techniques considered advallced just a few years ago. 
My fundamental assumption is limt you wam to write progralllS for the use 
of others, and to do so responsibly, providing a decent level of system quality: 
that is, I assume that YOLI want to achieve a level of professionalism. Conse-
quently, I chose the topics for this book to cover what is needed to get started 
with real-world programming, not just what is easy to teach alld leam. If you 
need a tcdmique to get basic work dOlle right, I describe it, demonstrate concepts 
and language facilities needed to support the technique, provide exercises for it, 
and expect you to work on those cxel·ciscs. If you JUSt want to understand toy 
programs, you can get along with far less than I present. On the other hand, I 
won't waste your time with material of marginal practical importance. If an ide:. 
is explained here, it's because you'll almost certainly need it. 
If your dcsire is to usc the work of others without understanding how lhinb'S 
are done and without adding significantly to Ille code yourself, this book is not 
for YOLi. If so, please consider whether yOLl would be better served by another 
book and another language. If that is approximately your view of programming. 
please also consider from where yOli got that view and whethcr it in fact is ade-
quate for your needs. People often underestimate the complexity of program-

PR EFACE 
ming as well as its value. I would hate for you lO acquire a dislike for program-
ming because of a mismatch between what you need and the part of the software 
reality I describe. There arc many parts of the "information technology" world 
that do not require knowledge of programming. 111is book is aimed to serve 
those who do wallt to write or understand nontrivial programs. 
Because of its Slnlcture and practical aims, this book can also be used as a 
second book on programming for someone who ail'eady knows a bit of C++ or 
ror someone who programs in another language and wants to learn C++. If you 
lit into one of those categories, I refrain rrom guessing how long it will take YOll 
to read this book, but I do encourage yOLi lO do many of the exercises. 'n lis will 
help you to counteract tbe conmlOn problem or writing programs in older, famil· 
iar styles rather tlmn adopting newer techniques where these arc more appropri-
ate. If you have learned C++ in one of the more traditional ways, you'll lind 
something suq>rising and useful before you reach Chapter 7. Unless your name 
is StTOustrup, what I discuss here is not "your father's C++." 
Programming is learned by writing programs. In this, programming is similar 
to other endeavors with a practical component. You cannot learn to swim, to play 
a musical insnutnent, or to drive a ,,'W JUSt rrom reading a book - you must prac-
tice. Nor "'l.n you learn to program without reading and writing lots of code. This 
book rocuses on code examples closely tied to explanatory text and diagrams. You 
need those to understand the ideals, concepts, mld principles of programming and 
to master the language constructs used to express them. 111at's essential, but by it-
selr, it will not give you the practical skills or progrmnming. For that, you need to 
do the exercises and get used to the tools ror writing, compiling, and running pro-
grams. You need lO make your own mistakes and learn to correct them. 'nlere is 
no substitute ror writing code. Besides, that's where the run is! 
On the other hand, there is more to programming - much more - than rol-
lowing a rew rules and reading the manual. This book is emphatically not ro-
cused on "the syntax of C++." Understanding the fundamemal ideals, principles, 
and techniques is the essence of a good programmer. Only well-designed code 
has a chance of becoming part or a correct, reliable, and maintainable system. 
Also, "the rundamentals" arc what last: they will still be essential arter today's 
languages and tools have evolved or been replaced. 
\<Vhat about computer science, sortware engineering, inrormation technol· 
ogy, etc.? Is that all programming? Of course not! Programming is one or the 
rundamental topics that underlie everything in computer·related fields, and it has 
a natural place in a balanced course or computer science. I provide brief intro-
ductions \0 key concepts and techniques or algorithms, data structures, user in-
terraces, data processing, and sortware engineering. However, this book is not a 
substitute ror a thorough and balanced study of those topics. 
Code can be beautirul as well as useful. TIlis book is written to help you sec 
that, to understand what it memlS for code to be beautiful, and to help you to 
master the principles and acquire the practical skills to create such code. Good 
luck with programmingl 

xxvi 
PREFACE 
A note to students 
Of the 1000+ fIrst-year studcnts we havc taught so far using drafts of this book at 
Tcxas A&M Univcrsity, about 60% had programmcd bcfore and about 40% had 
ncver seen a linc of code in their lives. Most succcedcd, so you can do it, too. 
VOli don't have to read this book as part of a course. r assume that the book 
will be widely used for self-study. However, whcther you work your way through 
as part of a course or independcntly, try to work with others. Programming has 
an - unfair - reputation as a lonely activity. Most people work belle .. and lealll 
fastcr when thcy arc part of a group with a common aim. Learning together and 
discussing problems with friends is not cheating! It is the most efficient - as well 
as Illost pleasant - way of making progress. If nothing else, working with friends 
forces you to articulate your ideas, which is just about thc most efficient way of 
tcsting your understanding and making sure you remcmber. You don't actually 
have to personally discover thc answer to evcry obscure language and program-
ming environment problem. However, please don't cheat yourself by not doing 
the drills and a fair number of cxcrcises (even if no teacher forces YOll to do 
them). Remcmber: programming is (among other t hin~ ) a practical skill that 
you need to practice to master. If you don't write code (do scveral exercises for 
each chapter), reading this book will be a pointless theoretical exercise. 
Most students - especially tllOughtful good studellts - face times whcn they 
wonder whet.her tllCir hard work is worthwhile. When (not if) tills happens to you, 
take a break, reread lhe preface, and look at Chapter I ("Computers, People, and 
Progr:unming"') and Chapter 22 ("Ideals and History"). There, I tI)' to articulate 
what I fInd exciting about programming and why I consider it a clucial tool for 
making a positive contribution to the world. If you wondcr about Illy tcaching phi-
losophy and gcncral approach, have a look at Chapter 0 (,'Notes to the Reader"). 
You might fmd the weight of this book wonying, but it should reassure you 
that pan of the reason for the heft is that I prefer to repeat an explanation or add an 
example ralher than have yOll scarch for the onc and only explanation. Tnc other 
major part of the reason is that the second half of the book is reference material and 
"additional material" prcsented for yOll to explore only if yOll are interestcd in 
more information about a specific area of programming, such as cmbedded sys· 
tems programming, text analysis, or numerical computation. 
And please don't be too impatient. Learning any major ncw and valuable 
skil.l takes lUne and is worth it 
A note to teachers 
No. This is not a traditional Computer Scicnce 101 course. It is a book about 
how to construct working software. As such, it leaves out much of what a com-
pllter scicnce student is traditionally exposcd to rruring complctcness, state mao 

PREFACE 
chines, discrete math, C homsky grammars, etc.). Even hardware is ignored on 
the assumption that students have used computers in various ways since kinder-
garten. This book docs not even try to mention most importam CS topics. It is 
about programming (or more generally about how to develop software), and as 
such it goes into more detail about fewer topics than many traditional courses. It 
tries to do juSt one thing well, and computer science is not a one-course LOpic. U 
this book/course is used as part of a computer science, computer engineering, 
electrical engineering (many of our first students were EE majors), information 
science, or whatever program, I expect it to be taught alongside other courses as 
part of a wcll-rounded imroduction. 
Please read C hapter 0 ("Notes to the Reader") for an explanation of my 
teaching philosophy, general approach, etc. Please try to convey those ideas to 
your students along the way. 
Support 
111e book's support website, www.stroustrup.comlProgramming. comains a va-
riety of materials supporting the leaching and leaming of programming using 
this book. "111e material is likely to be improved with time, but for starters, you 
can find: 
Slides for lectures based on the book 
An instructor's guide 
Header files and implementations of libraries used in the book 
Code for examples in the book 
Solutions to selected exercises 
Potentially useful links 
Errata 
Suggestions for im provements arc always welcome. 
Acknowledgments 
I'd especially like to thank my late colleague and co·teacher Lawrence "Pete" Pc· 
tersen for encouraging me to tackle the task of teaching beginners long before I'd 
otherwise have fclt comfortable doing that, and for supplying the practical teach· 
illg experience to make the course succeed. Without him, the first version of the 
course would have been a failure. We worked together on the first versions of the 
course for whidl this book was designed and together taught it repeatedly, leam-
ing from Ollr experiences, improving the course and the book. My usc of "we" in 
this book initially meant "Pete aJld me." 
xxyii 

)(Xviii 
PREFACE 
Thanks to the students, teaching assistants, and peer teachers of ENGR 11 2 
at Texas A&M University who directly and indirectly helped us conSlnlct this 
book, and to Walter Daugherity, who has also taught the course. Also thanks to 
Damian Dcchev, Tracy Hammond, Ame Tolstrup Madsen, Gabriel Dos Reis, 
Nicholas Strousmlp,j . C. van 'Winkel, Greg Versoonder, Ronnie Ward, and Lear 
Zolman for conslnlctive comments on drarts of this hook. ' 1lanks [Q Mogens 
Hansen for explaining about engine control software. l1lallks to AI A1l0, Stephen 
Edwards, Brian Kernighan, and Daisy Nguyen for helping me hide away from 
distractions to get writing done during the summers. 
Thanks to the reviewers that Addison-Wesley found for me. l1leir comments, 
mostly based on teaching either C++ or Computer Science 101 at the college 
level, have been invaluable: Richard Enbody, David Gustafson, Ron McCarty, 
and K. Narayanaswamy. Also tlmnks to my editor, Peter Gordon, for many useful 
comments and (not least) for his patience. I'm very grateful to the production 
team assembled by Addison-Wesley; they added much to the quality of the book: 
j ulie Grady (proofreader), Chris Keane (compositor), Rob Mauhar (illustrator), 
j ulie Nahil (production editor), and Barbara Wood (copy editor). 
In addition to my own unsystematic code checking, Bashar Anabta\\~ , Yinan 
Fan, and Yuriy Solodkyy checked all code fragments using Microsoft C++ 7.1 
(2003) and 8.0 (2005) and GGG 3.4.4. 
I would also like to thank Brian Kemighan and Doug Mcilroy for sening a 
very high standard for writing about programming, and Dennis Ritchie and Kristen 
Nygaard for providing valuable lessons in practicallanguagc design. 

•• 
_1-. ,-- 0 
Notes to the Reader 
"When the terrain disagrees with the map, 
trust the terrain." 
-Swiss army proverb 
T
his chapter is a grab bag of information; it aims to give you 
an idea of what to expect from the rest of the book. Please 
skim through it and read what you find illlcresling. A teacher 
will find most parts inuncdiatcly usefuL If you are reading this 
book without the benefit of a good teacher, plcase don't try to 
read and understand everyth ing in tlus chapter; just look at "~111e 
structure of this book n and the first pan of the "A philosophy of 
teaching and Icaming" sections. You may want to return and 
reread this chapter once you feel comfortable writing and execut-
ing small programs. 
1 
1 

2 
0.1 The structure of this book 
0.1.1 General approach 
0.1.2 Drills, exercises, etc. 
0.1.3 What comes afler this bookl 
0.2 A philosophy of leaching and 
learning 
0.2.1 The order of topics 
0.2.2 Programming and programming 
language 
0.2.3 Portability 
CHAPTER 0 • NOTES TO THE READER 
0.3 Programming and computer science 
0.4 Creativity and problem sol1ling 
0.5 Request for feedback 
0.6 References 
0.7 Biographies 
0.1 The structure of this book 
This book consists of four pans and a collection of appendices: 
/=!trl I, "171£ Basics," presems the fundamental concepts and techniques of 
programming together with the C++ language and library facilities 
needed to get started writing code. 111is includes the type system, arith-
metic operations, control structures, elTor handling, and the design, im-
plementation, and use of functions and user-defined types. 
Part II, "Input and Output," describes how to get numeric and text data 
from the keyboard and from fLies, and how to produce col"responding 
output to the screen and to ftlcs. Then, it shows how to present numeric 
data, text, and geometric shapes as graphical output, and how to gel 
input into a program from a graphical user interface (CUI). 
Part III, "Data and Algcnilh/1lJ,'" focuses on the C++ standard library's con-
tainers and algorithms framework (the 511." standard template library). 
It shows how containers (such as veclor, lisl, and map) arc implemented 
(using pointers, arrays, dynamic memory, exceptions, and templates) 
and used. It also demonstrates the design and usc of standard library al-
gorithms (such as sari, find, and inner_producl). 
Pari nt; "BrQ(uiening lhe Viau," offers a perspective on programming 
through a discussion of ideals and history, through examples (such as 
matrix computation, text manipulation, testing, and embedded systems 
programming), and through a brief description of ule C language. 
AppetuJi(1!J provide useful information that doesn't fit into a tutorial presen' 
tauon, such as surveys of C++ language and standard library facilities, 
and descriptions of how to get started with an integrated development ell' 
vironment (IDE) and a graphical user interface (CUI) library. 

0.1 
TH E STRUCTURE OF THIS BOOK 
Unfortunately, the world of programming doesn't really fall into four cleanly sep-
arated parts. ~nlercfo re, the "parts" of this book provide only a coarse classifica-
tion of topics. \'Ve consider it a useful classification (obviously, or we wouldn't 
have used it), but reality has a way of escaping neat classifications. For example, 
we need to lise input operations far sooner than we c.an give a dlOroligh explana-
tion of C++ standard 1/0 streams (input/output streams). Where the set of topics 
needed to preselll an idea conflicts widl the overall classification, we explain the 
minimum needed for a good presentation, rather than just referring to the com-
plete explanation elsewhere. Rigid classifications work much better for manuals 
than for tutorials. 
The order of topics is determined by programming tedmiques. rather than 
programming language fealllres; see §O.2. For a presentation organized around 
language features, see Appendi.x A. 
To case review and to help you if YOli miss a key point during a first reading 
where you have yet to discover which kind of information is crucial, we place 
three kinds of "alert markers" in the margin: 
Blue: concepts and techniques (this paragraph is an example of that) 
Green: advice 
Red: w,u·ning 
0.1 .1 General approach 
In this book, we address you directly. 'Tllat is simpler and dearer than the con-
ventional "professional" indirect form of address, as found in most scientific pa-
pers. By "you" we mean "you, the reader," and by "we" we refer either to 
"ourselves, the author and teachers," or to you and us working together through 
a problem, as we m.ight have done had we been in the same room. 
'11is book is designed to be read chapter by chapter from the beginning to 
the end. Often, you'll want to go baek to look at something a second or a third 
time. In fact, that's the only sensible approach, as you'll always dash past some 
details that you don't yet sec the point in. In such cases, you'll eventually go back 
again. However, despite the index and the cross-references, this is not a book that 
you can open on any page and start reading with any expectation of success. 
Each section and each chapter assume understanding of what came before. 
Each chapter is a reasonably self-contained unit, meant to be read in "one sit-
ting" nogically, if not always feasible on a student's tight schedule). "nmt's one 
major criterion for separating the text into chapters. Other criteria include that a 
chapter is a suitable unit for drills and exercises and that each dlapter presents 
some specific concept, idea, or technique. '11is plurality of criteria has left a few 
chapters uIlcomfortably long, so please don't takc Min onc sitting" tOO literally. In 
particular, once you have thought about the review questions, done the drill, and 
3 

4 
CHAPTER 0 • NOTES TO THE READER 
worked on a few exercises, you'll often [md that you have to go back to reread a 
few sections and that several days have gOlle by. We have clustered the chapters 
imo "parts" focused on a major lopic. such as input/ampul. These parts make 
good units of review. 
Common praise for a textbook is "It answered all my questions just as I 
thought of them!" l11at's an ideal for minor technical questions, and early read-
ers have observed the phenomenon with this book. However, thm canllot be the 
whole ideal. We raise questions that a novice would probably not think of. We 
aim to ask and answer questions that you need to consider to write quality soft-
ware for the use of Olhcrs. Lcaming to ask the right (often hard) questions is an 
essential part of lcaming to think as a prognunmer. Asking only the easy and ob-
vious questions would make you feel good, but it wouldn't help make you a pro-
grammer. 
\OVe try to respect your intelligence and to be considerate about your time. In 
our presentation, we aim for professionalism rather than cuteness, and we'd 
rather understate a poim than hype it. We try not to exaggerate the importance 
of a programming technique or a language feature, but please don't underesti-
mate a simple statement like "111is is often useful." If we quietly emphasite that 
something is important, we mean that you'll sooner or later waste days if you 
don't master it. Our usc of humor is more limited than we would have preferred, 
but experience shows that people's ideas of what is funny differ dramatic..1.lly and 
that a failed attempt at humor c..1n be confusing. 
\OVe do not pretend that our ideas or the tools offered arc perfect. No tool, li-
brary, language, or technique is "the sollllion" to all of the many challenges fac-
ing a progranuner. At best, it can help you to develop and express your solution. 
We try hard to avoid "white lies"; that is, we refrain from oversimplified explana-
tions that arc clear and easy to understand, but not true in the context of real lan-
guages and real problems. On the other hand. this book is not a reference ; for 
more precise and complete descriptions of C++, see BjaOle Stroustrup, 'flu! C++ 
Programmillg ul1lguage, Spedal Edition (Addison-Wesley, 2000), and the ISO C++ 
standard. 
0.1.2 Drills, exercises, etc. 
Programming is not just an intellectual activity, so writing programs is necessary 
to master progranuning skills. We provide two levels of programming practice: 
Drilb: A drill is a very simple exercise devised to develop practical, al-
mOst mechanical skills. A drill usually consists of a sequence of modifica-
tions of a single program. You should do evely drill. A drill is not asking 
for deep understanding, cleverness, or initiative. We consider the drills 
part of the basic fabric of the book. If you haven't done the drills, you 
have not "done" the book. 

0.1 
THE STRUCTU RE Of THIS BOOK 
Exercise;: Some exercises arc trivial and others are very hard, bUl most 
are intended to leave some scope for initiative and imagination. If you 
arc serious, you'll do quite a few exercises. At least do enough to k.now 
which arc difficult for you. Then do a few more of those. TIlat's how 
you 'Jlleam the most. Tbe exercises are meant to be manageable without 
exceptional cleverness, rather than to be tricky puzzles. However, we 
hope that we have provided exercises that arc hard enough to challenge 
anybody and enough exercises to exhaust even the best student's avail-
able lime. We do not expect you to do them all, but feel free to try. 
In addition, we recommend that you (every student) take part in a small project 
(and more if time allows for it). A project is intended to produce a complete useful 
prq,rr.un. Ideally, a project is done by a small group of people (e.g., three people) 
working together for about a month while working through the chapters in Part 
Ill. Most people find the projects the most fun and what ties everything together. 
Some people like to put the book aside and try some examples before read-
ing to lhe end of a chapter; others prefer to read a11ead to the end before trying to 
get code to run. To support readers with the fanner preference, we provide sim-
ple suggestions for practical work labeled "Try this:" at natural breaks in the 
text. A Try this is generally in the nature of a drill focused narrowly on the topic 
that precedes it. If you pass a Try this without trying - maybe because you are 
not near a computer or you find the text riveting - do return to it when you do 
the chapter drill; a Try this either complements the chapter drill or is a part of it. 
At the end of each chapter you'll find a set of review questions. They are in-
tended to point you to the key ideas explained in the chapter. One way to look at 
the review questions is as a complement to the exercises: the exercises focus on the 
practical aspects of programming, whereas the review questions try to help YOli ar-
ticulate the ideas and concepts. In thaI, they resemble go<xI interview qucstions. 
TIle "Terms" section at the end of each chapter presellls the basic vocabulary 
of programming and of C++. If you want to understand what people say about 
programming topics and to articulate your own ideas, you should know what 
each means. 
Learning involves repetition. Our ideal is to make every important point at 
least twice and to reinforce it with exercises. 
0.1.3 What comes after this book? 
At the end of Lhis book, will you be an expert at programming and at C++? Of 
course not! \Vhcn done well, progrrunming is a subtle, deep, and highly sk.illed 
an building on a variety of technical skills. You should no more expect to be an 
expert at programming in four months than you should expect to be an expert in 
biology, in math, in a natural language (such as Chinese, English, or Danish), or 
at playing the violin in four months - or in half a year, or a year. What you 
5 

• 
C HAPTER 0 • NOTES TO THE READER 
should hope for, and what you can expect if you approach this book seriously. is 
to have a really good start that allows you to \vntc relatively simple useful pro-
grams, to be able to read more complex programs, and to have a good concep-
tual and practical background for further work. 
TIle best follow-up to this initial COUTse is to work on a real project develop-
ing code to be used by someone elsc. Mlcr that, or (even better) in parallel with a 
real project, read either a professional-level gencral tcxtbook (such as Stroustrup, 
The C++ Programming Langutl§), a more specialized book relating to the needs of 
your project (such as Q! for G UI, or ACE for distributed programming), or a 
textbook focusing on a particular aspect of C++ (such as Koenig and Moo, Ac«/-
(rate(J C++ j Sutter's £y.teptiQlIal C++; or Gamma et ai., Design Itl/lems). For com-
plete references, see §O.6 or the Bibliography section at the back of me book. 
Evelltllally, YOll should learn anomcr progrnmming language. We don't con-
sider it possible to be a professional in the realm of software - even if you arc not 
primarily a programmer - without knowing more than one language. 
0.2 A philosophy of teaching and learning 
What arc we trying to help you leam? And how arc we approaching the process 
of leaching? We try to present the minimal concepts, techniques, and tools for 
you to do effective practical programs, including 
Program organization 
Debugging and testing 
Class design 
Computation 
Function and algorithm design 
Graphics (two-dimensional only) 
Graphical user interfaces (G U ls) 
Text manipulation 
Regular expression matching 
Files and stream input and output (l/O) 
Memory management 
Scientifid numericaVengineering c."llcularions 
Design and programming ideals 
TIle C++ standard library 
Soft\vare development strategies 
C-Ianguage programming techniques 

0.2 
A PHILOSOPHY OF TEACH ING AND LEARNING 
lvVorking our way through these topics, we cover the programming techniques 
called proceduraJ programming (as with the C programming language), data ab-
slraction, object-orientcd programming, and generic prob'Tamming. The main 
topic of this book is jJrogralllwillg, that is, the ideals, techniques, and tools of ex-
pressing ideas in code. -nle C++ programming I.mguage is our main tool, so we 
describe many of C++'s facilities in some detail. But please remember that C++ 
is just a tool, rather lhan the main topic of lhis book. "This is "programming using 
C++ ,tt nOt. "C++ wilh a bit of programming theory." 
Each topic we address serves at least twO purposes: it presents a technique, 
concept, or principle and also a practical language or library feature. For exam· 
pic, we usc the interface to a two-dimensional graphics system to illustrate the use 
of classes and inheritance. 111is allows us to be economical with space (and your 
time) and also to emphasize that programming is more than simply slinging code 
together to get a result as quickly as possible. TIle C++ standard library is a 
major source of such "double duty" examples - many even do triple duty. For 
example, we introduce lhe standard library vector, use it LO illustrate widely use-
ful design techniques, and show many of the programming techniques used to 
implement it.. One of our aims is to show you how major library facilities arc un-
plemellted and how they map to hardware. We insist that craftSmen must under-
stand their lools, not just consider them "magical." 
Some topics will be of greater uuerest to some programmers than to others. 
However, we encourage you nOt. to prejudge your needs (how would you know 
what you'll need in the future?) and at least look at every chapter. If you read this 
book as part of a course, your teacher will guide your selection. 
We characterize our approach as "depth-first." It is also "concrete-first" and 
"concept-based." First, we quickly (well, relatively quickly, Chapters 1- 11) assem-
ble a set of skills needed for writillg small practical programs. In doing so, we 
present a lot of tools and techniques in minimal detail. We focus on simple con-
crete code examples because people grasp the concrete faster lhan the abstract. 
"nlat's simply the way mOSl humans learn. At lhis initial smge, you should nOl 
expect to understand every Iiltle detail. In particular, you'll rmd that rrying some-
thing slightly different from what just worked can have "mysterious" effeclS. Do 
lry, though! And please do the drills and exercises we provide. Just remember 
that early on you JUSt don't have the conceptS and skills to accllrately estimate 
what's simple and what's complicated; expect surprises and leam from them. 
We move fast in this initial phase - we want to get you to the point where 
you can write imeresting programs as fast as possible. Someone will argue, "We 
mliSl move slowly and carefully; we must walk before we can run!" BUl have you 
ever watclled a baby leaming to walk? Babies really do run by themselves before 
they leam the finer skills of slow, controlled walking. Similarly, you will dash 
ahead, occasionally stumbling, to get a feel of progranuuing before slowing down 
to gain the necessary finer conlTOl and understanding. You mllst run before you 
can walk! 
7 

• 
CHAPTER 0 • NOTES TO THE READER 
Il is essential that you don'l gel stuck in an auempt to leam "everything" 
about some language detail or technique. For example, YOLI could memorize all of 
C++'s built-in types and all the rules for their usc. Of course you could, and 
doing so might make you feel knowledgeable. However, it would not make you a 
programmer. Skipping details will gel you "bumcd" occasionally for lack of 
knowledge, but it is the fastest way to gain the perspective needed to write good 
programs. Note that our approach is csscntiaJly lhe one lIsed by children learning 
their native language and also the most eJTective approach lIsed to lcach foreign 
languages. We encourage you to seck help from lcachers, friends, colleagues, in-
stmctors, Mentors, etc. on the inevitable occasions when you are stuck. Be as-
sured that nothing in these early chapters is fundamentally difficult. However, 
much will be unfamiliar and might therefore feci difficult at first. 
L-uer, we build a ll the initial skills to broaden your base of knowledge and 
skills. We usc examples and exercises to sotidify your understanding, and to pro-
vide a conceptual base for programming_ 
We place a heavy emphasis on ideals and reasons_ You need ideals to guide 
you when you look for practical solutions - to know when a solution is good and 
principled_ You need to understand the reasons behind those ideals to under-
stand why they should be your ideals, why aiming for them will help you and the 
users of your code. Nobody should be satisfied with "because that's the way it is" 
as an explanation. More importantly, an understanding of ideals and reasons al-
lows you to generalize from what you know to new situations and to combine 
ideas and tools in novel ways to address new problems. Knowing "why" is an es-
sential pan of acquiring programming skills. Converscly,jusl memorizing lots of 
poorly understood rules and language facilities is limiting, a source of errors, and 
a massive waste of time. We consider your time precious and try not to waste it. 
Many C++ language·technical details are banished to appendices and manu-
als, where you can look them up when needed. We assume that you have the ini-
tiative to search out information when needed. Use the index and the table of 
contents. Don't forget the online help facilities of your compiler, and the web. Re-
member, though, to consider every web resource highly suspect lIntil yOll have 
reason to believe better of it. Many an authoritative-looking v .. ·ebsite is put up by 
a progranuuing novice or somcone with something to sell_ Others arc simply out-
dated. We provide a collection of links and information on our support website: 
www.strouslrllp.comIProgram mi ng. 
Please don't be too impatiem for "realistic" examples. Our ideal example is 
the shortest and simplest code that dircctly illustrates a language facility, a can-
ccpt, or a technique. Most real-world examples are far messier than ours, yet do 
not consist of more than a combination of what we demonstratc. Successrui com-
mercial programs with hundreds of thousands of lines of code are based on tech-
niques that we illustrate in a dozen 50-line programs. -n IC fastest way to 
understand real-world code is through a good understanding of Ule fundamcntals. 

0 ,2 
A PHILOSOPHY OF TEACHING AND LEARNING 
On the other hand, we do not use "cute examples involving cuddly animals" 
to illustrate our points. We assume that you aim to write rea1 programs to be 
used by real people, so every example that is not presented as language-technical 
is taken from a real-world usc. Our basic tone is that of professionals addressing 
(future) professionals. 
0.2.1 The order of topics 
"111ere arc many ways to teach people how to program. Clearly, we don't sub-
scribe to the popular "the way I leamed to program is the best way to leam" the-
ories. To case leaming, we carlyon present topics that would have been 
considered advanced only a few years ago. Our ideal is for the topics we present 
to be driven by problems you meet as you learn to program, to flow smoothly 
from topic to topic as you increase your understanding and practical skills. The 
m~or flow of this book is more like a story than a dictionary or a hierarchical 
order. 
It is impossible to learn all the principles, techniques, and language facilities 
needed to write a program at once. Consequently, we have to choose a subset of 
principles, techniques, and features to start with. More gellerally, a textbook or a 
course must lead studellts tllTough a series of subsets. We consider it our respon-
sibility to select topics and to provide emphasis. We can't just present everything, 
so we must choose; what we leave out is at least as important as what we leave in 
- at each stage of the joumey. 
For contrast, it may be useful for you to sec a JiSt of (severely abbreviated) 
characterizations of approaches tlIat we decided not to take: 
"CjirJ/": '11is approach to learning C++ is wasteful of students' time 
and leads to poor programming practices by forcing sLUdents to ap-
proach problems with fewer facilities, techniques, and libraries than nec-
essary. C++ provides stronger type checking than C, a standard library 
with bener support for novices, and exceptions for error handling. 
&IIQ111-IIP: TIlis approach distracts from lcaming good and effective pro-
gramming practices. By forcing students to solve problems with insuffi-
cient suppon from the language and libraries, it promotes poor and 
wasteful programming practices. 
"!fJOIi trese/It J01IIelhillg, Jail mllJl pramt itfoiiy": This approach implies a 
bottom-up approach (by drilling deeper and deeper into every topic 
touched). It bores novices \vith technical details they have no intercst in 
and quite likely will not need for years to come. Oncc yOll can program, 
you em look up technical details in a manual. Manuals are good at that, 
whereas they are awful for initialleaming of concepts. 
, 

I. 
CHAPTER 0 • NOTES TO THE READER 
'lOp..Juwn: This approach, working from first principles toward details, 
lends 10 distract readers from the practical aspects of programming and 
force them to concentrate on high-level concepts before they have any 
chance of appreciating their importance. For example, yOll simply can't 
appreciate proper software development principles before you have 
learned how easy it is to make a mistake in a program and how hard it 
can be to correct it. 
''AbJlracljinJ'': Focusing on general principles and protecting the student 
from nasty real-world constraints can lead to a disdain for real-world 
problems, languages, tools, and hardware constraints. Often, this ap-
proach is supported by Mtcaching languages" that cannot be used later 
and (deliberately) insulate students from hardware and system concerns. 
&yhuare engineering principtesjirJI: TIlis approach and the abstract-first ap-
proach tend to share the problems of the top-down approach: without 
concrete examples and practical experience, you simply cannot appreci-
ate the value of abstraction and proper soft\'vare devcJopmellt practices. 
"Oiject-orU:tJtelifiom du.y one": Object-oriented programming is one of the 
best ways of organ.izing code and progranmung efforts, but it is not thc 
only effective way. Ll particular, we fed that a grounding in the basics of 
types and algorithmic code is a prerequisite for appreciation of the design 
of classes and class hierarchies. We do use user-dcfined typeS (what some 
people would call "objects") from day one, but we don't show how to de-
sign a class until Chapter 6 and don't show a class hierarchy ulllil Chap-
ter 12. 
'111s1 beli£ue ill 11WgiC": Ths approadl relics 011 demonstrations of power-
ful tools and techniques withom introducing the novice to the underly-
ing techniques and facilities. TIus leaves the student guessing - and 
usually guessing wrong - about why things arc the way they are, what it 
costs to use them, and where they can be reasonably applied. Illis can 
lead to ovcrrigid following of familiar patterns of work and become a 
barrier to further [earning. 
Naturally, we do not claim that these other approaclles arc never useful. Ln fact, 
we use several of these for specific subtopics where their strengths c.."lJl be appre-
ciated. However, as general approaches to leanung programming aimed at real-
world usc, we reject them and apply our mternative: concrete-first and depth-first 
with an emphasis on concepts and techniques. 
0.2.2 Programming and programming language 
We teach programming first and treat our chosen programming language as sec-
ondary, as a tool. Our general approach can be used with any general-pUl]>Ose 

0, 2 
A PHILOSOPHY OF TEACHING AND LEARNING 
programming language. Our primary aim is to help you learn general concepts, 
principles, and techniques. However, those cannot be appreciated in isolation. 
For example, details of syntax, the kinds of ideas that can be directly expressed, 
and tool support differ from programming language to programming language. 
However, many or the fundamental techniques for producing bug-free code, such 
as writing logically simple code (Chapters 5 and 6), establishing invariants 
(§9.4.3), and separating interfaces from implementation details (§9.7 and 
§14.1 -2), v<uy little from programming language to programmillg language. 
Progrdmming and design techniques must be learned using a programming 
language. Design, code organization, and debugging are not skills you can ac-
quire in the abstract. You need to write code in some programming language and 
gain practical experience with that. This implies that you must learn the basics of 
a progranuning language. We say "the basics" because the days when you could 
learn all of a major industrial language in a rew weeks are gone for good. l11e 
parts of C++ we present were chosen as the subset that most directly supports 
t.he production of good code. Also, we present C++ fcarures that you can't avoid 
encoumering either because they are necessary ror logical completeness or are 
common in the C++ community. 
0.2.3 Portability 
It is common to write C++ to lUll on a variety of machines. Major C++ applica-
tions run on machines we haven't ever heard on We consider portability and t.he use 
or a variety or machine archit.ectures and operating systems most important. Essen-
tially every example in this book is not only ISO Standard C++, but also portable. 
Unless specifically stated, the code we present should work on evel)' C++ imple-
mentation and has been tested on several machines and operating systems. 
The details or h("o\' to compile, link, and run a C++ program differ rrom system 
to system. It would be tedious to mention the details or evcl)' system and evel)' 
compiler each timc we need t.o refer to an implementation issue. In Appendix E, we 
give the most basic infomlation about getting started using VISual Studio and 
Microsort C++ on a Wmdows machine. 
U you have trouble wit.h one or the popular, but ralher elaborate, IDEs (inte-
grated development environments), we suggest you try working rrom the com-
mand line; it's surprisingly simple. For example, here is the rull set or commands 
needed to compile, link, and execute a simple program consisting or two source 
files, my_filel .cpp and my_file2.cpp, using t.he GNU C++ compiler, g++, on a 
Unix or Linux system: 
g++ -0 my_program my_file1.cpp my_file2.cpp 
my_program 
Yes, that really is all it takes. 
11 

12 
CHA PTER 0 • NOTES TO THE READ ER 
0.3 Programming and computer science 
Is programming all that there is to compuler science? Of course not! lbc only 
reason we raise this question is that people have been known to be confused 
about this. We LOuch upon major topics from computer science, such as alga-
riuuns and data structures, but our aim is to teach programming: the design and 
implementation of programs. That is bom more and less than most accepted no-
lions of compuler science: 
M (JTf:, because programming involves many lcchniC<ll skills that arc not 
usually considered pan of any science 
Ull, because we do nm systematically present the foundation for the 
pans of computer science we use 
TIle aim of this book is to be pan of a course in computer science (if becoming a 
computer scientist is your aim), to be me foundation for the first of many courses 
in software construction and maimenance (if your aim is to become a program-
mer or a software engineer), and in general to be pan of a greater whole. 
We rely on computer science throughout and we emphasize principles, but 
we teach programming as a practical skill based on theory and experience, rather 
than as a science. 
0.4 Creativity and problem solving 
TIle primary aim of this book is to help you to express your ideas in code, not to 
leach you how to get those ideas. Along the way. we give many examples of how 
we can address a problem, usually through analysis of a problem followed by 
gradual refmement of a solution. We consider programming itself a form of prob-
lem solving: only through complete understanding of a problem and its solution 
can you express a correct program for it, and only through constructing and test-
ing a program can you be certain that your understanding is complete. lllllS, 
progranuuing is inherently part of an effort to gain understanding. However, we 
aim to demonstrate this through examples, rather than through "preaching" or 
presentation of detailed prescriptions for problem solving. 
0.5 Request for feedback 
We don't think mat the perfect textbook can exist; the needs of individuals differ 
too much for that. However, we'd like to make this book and its supporting ma-
terials as good as we " ... n make them. For that, we need feedback ; a good text-
book cannot be written in isolation from its readers. Please send us reports on 

0.6 
REFERENCES 
errors, typos, unclear text, missing explanations, etc. We'd also appreciate sug-
gestions for better exercises, better examples, and topics to add, topics to delete, 
etc. Constructive comments will help future readers and we'll post errata on our 
support website: www.slrouslrup.com/Programming. 
0.6 References 
Along with listing the publications mentioned in this chapter, this section also in-
cludes publications you might find helpful. 
Alistem, Matthew H. Qmeric ltogrammillg alld Ihe STL: Usillg alld £>:Inu./ing the C++ 
Sialldard 'Template Library •. Addison-Wesley, 1999. ISBN 0201309564. 
Alistem, Matthew H. (editor). "Technical Report on C++ Standard Library Ex-
tensions." ISO/IEC Pffi"'R 19768. 
Blanchette, j asmin, and Mark Summerfield. C++ CUI Programmillg willt Q!, 4. 
Prentice Hall, 2006. ISBN 0131872493. 
Gamma, Erich, Richard Helm, Ralph j ohnson, and john M. Vlissides. Desigll 
Hi/lents: ElemetllJ qf&lJSiwle ObjecJ-Oritmled &fiware. Addison-Wesley, 1994. ISBN 
0201633612. 
Goldthwaite, Lois (editor). "'Technical Report on C++ Performance." ISO/IEC 
PDTR 18015. 
Koenig, Andrew (editor). TIlL C++ Slmu/ard. ISO/IEC 14882:2002. Wuey, 2003. 
ISBN 0470846747. 
Koenig, Andrew, and Barbara Moo. Aaelerated C++: Pnu:ticaJ ProgrrUlllllillg by £>:fJlllpl£. 
Addison-Wesley, 2000. ISBN 020170353X. 
Langer, Angelika, and Klaus Kreft. Siantlllrd C++ IOSIrea1ll.J amI LomleJ: AdlXl1lud 
Programmer; Guiil£ antI Rifm llu . Addison-Wesley, 2000. ISBN 0201 183951. 
Meyers, Scott./ijfoctive STL: 50 Specific unys 10 Improve wur Use qflhe Simu/mr/ Tem-
p/ale Library. Addison-Wesley, 2001. ISBN 0201749625. 
Meyers, SCOII. /ijfictive C++: 55 Specf!ic I#lys 10 im/Jrove lOur Programs alld Designs 
(3nl Edilioll). Addison-Wesley, 2005. ISBN 0321334876. 
Schmidt, Douglas C., and Stephen D. Huston. C++ Nctwork Programming, Vo/ume 
1: Maslerillg Complexity wilh ACE and /hI/ems. Addison-Wesley, 2002. ISBN 
0201604647. 
Schmidt, Douglas C., and Stephen D. Huston. C++ Network ltogrammillg, Volume 
2: Syslemalic ReuJe wilh ACE alld FramroJOriu. Addison-Wesley, 2003. ISBN 
0201795256. 
StrouStrup, Bjarne. The Design alld Evoluliall qfC++. Addison-Wesley, 1994. ISBN 
0201543303. 
StrOllstrup, Bjarne. "Learning Standard C++ as a New Language." C/C++ U;ers 
JounUlI, May 1999. 
13 

14 
CHAPTER 0 • NOTES TO THE READE R 
StrOuslrup, Bjarnc. 'The C++ Programmi1lg Language (Special £iii/ion). Addison-
Wesley, 2000. ISBN 0201700735. 
Stroustrup, Bjarne. "C and C++: Siblings"; "C and C++: A Case for Compati-
bility"; and "C and C++: Case Studies in Compatibility." CIC++ UJerl JOIln/a/, 
July, Aug., Sept. 2002. 
Sutler, Herb. EYceptumai C++: 47 Engineering Puuks, Programming Problems, mit/ &/11-
(iom. Addison-Wesley, 2000. ISBN 0201615622. 
A morc comprehensive list of references can be found in the Bibliography section 
at lhe back of the book. 
0.7 Biographies 
You might reasonably ask, "V\'ho arc these guys who want to teach me how to 
program?" So here is some biographical infomlation. I, Bjarne Stroustrup, wrote 
this book, and together with La\\lTcncc "Pete" Petersen, I designed and taught the 
university-level beginner's (first-year) course that was developed concurrently 
with the book, using drafts of the book. 
Bjarne Stroustrup 
I'm the designer and original implementcr of the 
C++ programming language. I have used the lan-
guage, and many other programming languagcs, 
for a wide variety of programming tasks ovcr the 
last 30 years or so. I just love elcgant and efficient 
code used in challenging applications, such as 
robot control, graphics, games, text analysis, and 
networking. I have taught design, programming, 
and C++ to people of essentially all abilities and 
interests. I'm a founding member of the ISO stan-
dards commiuce for C++ where , serve as the 
chair of the working group for language evollllion. 
This is my first introductory book. My Olher books, such as -me C++ ft<r 
grammillg Ltmgrwge and '(II(! DeJi~,'71 alld Eoo/litioll 0/ C++, were written for experi-
enced progranullers. 
I was born into a blue-collar (working-class) family in 
rhus, Denmark, and 
got my master's degree in mathematics with computer science in my hometown 
university. My Ph.D. in computer science is from Cambridge University, Eng-
land. I worked for AT&T for about 25 years, first in the famous Computer Sci-
ence Research Center of Dell Labs - where Unix, C, C++, and so much else 
were invented - and later in AT &T L..'lbs-Research. 
"m a member of the U.S. National Academy of Engineering, a Fellow of the 
ACM, an IEEE Fellow, a Bell Laboratories Fellow, and an 1\"l"'&T Fellow. As the 

0.7 
BIOGRAPHIES 
first computer scientist ever, I received the 2005 William Procter Prize for Scien-
tific Achievement from Sigma Xi (the scientific research society). 
I do have a life outside work. I'm married and have twO children, one a med· 
ical doctor and one a Ph.D. student. I read a lot (including history, science fiction, 
crime, and current affairs) and like most kinds of music (including classical, rock, 
blues, alld country). Good food with friends is an essential part of life, and I 
enjoy visiting interesting places and people, all over the world. To be able to 
e l~oy the good food, I nlll. 
For more information, see my home pages: w\'Vvv.researeh.att.com/- bs and 
www.cs.tall1u.edu/people/facultylbs. In particular, there you can find out how to 
pronounce my name. 
lawrence "Pete" Petersen 
In late 2006, Pete introduced himself as follows: "I 
am a teacher. For almost 20 years, I have taught 
programming languages at Texas A&'M. I have 
been selected by slUdents for Teaching Excellence 
Awards five times and in 1996 received the Distin-
guished Teaching Award from the Alumni Associ-
auon for the College of Engineeling. I am a 
Fellow of the Wakonse Program for Teaching Ex-
cellence and a Fellow of the Academy for Educa-
tor Development. 
As the son of an army officer, r was raised on 
the move. After compleung a degree in philosophy at the University of Washing-
ton, I served ill the anny for 22 years as a l<icld Artillery Officer and as a Research 
Analyst for Openllional Tesung_ I taught at the .. icld Artillery Officer's Advanced 
Course at Fort Sill, OkJahoma, from 1971 to 1973. In 1979 I helped organize a 
'lest Officer's Training Course and taught it as lead instmctor at nine different lo-
cations across the United States from 1978 to 1981 and from 1985 to 1989. 
In 199 1 I formed a small software company that produced management soft-
ware for university departments until 1999. My interests are in teaching, design.-
ing. and programming software that real people can use. I completed master's 
degrees in industrial engineering at Georgia 1ech and in education curriculum 
and instruction at Texas A&M. I also completed a master's program ill micro-
computers from NTS. My Ph.D. is in information and operations management 
from Texas A&M. 
My wife, Barb.ml, and I live in Bryan, 1exas. We like to travel, garden, and 
entertain; and we spend as much time as we can with our sons and their families, 
and especially with our grandchildren, Angelina, Carlos, Tess, Avery, Nicholas, 
and Jordan." 
Sadly, Pete died of lung cancer in 2007. Without him, the course would never 
have succeeded. 
15 

" 
(HAPTER 0 • NOTES TO THE READER 
Postscript 
Most chapters provide a short "postscript" trying to give some perspective on ,he 
infannation prescllIcd in the chapter. We do t.hat in lhe realization that the infor-
mation can be - and often is - daunting and will only be fully comprehended 
after doing exercises, reading further chapters (which apply the ideas of the chap-
ter), and a later review. Don't panic. Relax; this is natural and expected. You 
won't become an expert in a day, but you can become a reasonably competent 
programmer as you work your way through the book. On the way, you'll en-
COlinlef much infannalion, many examples, and many techniques that lots of 
programmers have found stimulating and fun. 

Computers, People, and 
Programming 
"Specialization is for insects." 
-R. A. Heinlein 
I
n lhis d lapter, we present some of the lhings that we think 
make progranuning important, interesting, and fun. We also 
present a few fundamental ideas and ideals. We hope to debunk 
a couple of popular myths about progranuning and program-
mers. This is a chapter to skim for now and to return to later 
when you arc struggling with some progranuning problem and 
wondering if it's all worth it. 
17 

18 
1.1 Introduction 
1.2 Software 
1.3 People 
C HAPTER 1 • C OMP U TERS , PEOPL E, ANO PROGRAMMI N G 
1.4 Computer science 
1.5 Computers are everywhere 
1.5.1 Screens and no screens 
1.5.2 Shipping 
1.5.3 Telecommunications 
1.5.4 Medicine 
1.5.5 Information 
1.5.6 Ii vertical view 
1.5.7 SowhaU 
1.6 Ideals for programmers 
1.1 Introduction 
Like most learning, learning how to program is a chicken and egg problem: We 
want to gel started, but we also want to know why what we arc about to learn 
matters. We want to learn a practical skill, but also make sure it is not just a pass· 
ing fad. We want to know that we are not going to waste our time, but don't 
want to be bored by still more hype and moralizing. For now, just read as much 
of this chapter as seems interesting and come back later when you feci the need 
to refresh your memory of why the technical details matter outside the class-
room. 
TIlis chapter is a personal statement of what we find interesting and impor-
tant about progranuning. It explains what motivates liS to keep going in tltis field 
after decades. This is a chapter to read to get an idea of possible ultimate goals 
and an idea of what kind of person a programmer might be. A beginner's techni-
cal book inevitably contains much pretty basic stuff. In this chapter, we lift our 
eyes from the tcchnicaJ details and consider the big picture: \-Vhy is progr,unming 
a worthwhile activity? What is the role of programming in our civilization? 
Wherc can a programmer make contributions to be proud of? Whcre docs pro-
gramming fit into the greater world of software development, deployment, and 
maintenance? When people talk about "computer science," "software engineer-
ing," "information technology," etc., where does prograuUlling fit into the pic-
ture? What does a programmer do? What skills docs a good progranuner have? 
To a student, the most urgent reason for understanding an idea, a technique, 
or a chapter may be to pass a test with a good grade - but there has to be more 
to leanung than that! To someone working i.n the software industry, the most ur-
gent reason for understanding an idea, a technique, or a chapter may bc to find 

1.2 
SOFTWAR E 
something thm can help with the current project and Lhat will nOt annoy the boss 
who controls Lhe next paycheck, promotions, and firings - but there has to be 
more to learning Lhan that! We work best when we feci that our work in some 
small way makes the world a beuer place for people to live in. For tasks that we 
perform over a period of years (the "things" thaI. professions and careers arc 
made of), ideals and more abstract ideas are en _cia!. 
Our civilization lUllS on software. Improving software and finding new L1ses 
for software are twO of the ways an individual can help improve the lives of 
many. Programming plays an essemial role in Lhat. 
1.2 Software 
Cood software is invisible. You "m 't sec it, feci it, weigh it, or knock on it. Soflwan 
is a collection of programs running on some computer. Sometimes, we can see 
the computer. Often, we can see only something that contains the computer, such 
as a telephone, a camera, a bread maker, a car, or a wind turbine. We can see 
what that software docs. We can be annoyed or hurt if it doesn't do what iL is 
supposed to do. We can be annoyed or hurt if what it is supposed to do doesn't 
suit our needs. 
How many computers arc Lhere in the world? We don't know; billions at 
least. 111ere may be more computers in the world than people. A 2004 estimate 
from rru (International "leleconUllUnication Union, a U N agency) lists 772 mil-
lion PCs and most computers afe not PCs. 
How man)' computers do you (more or less direclly) use every da)'? 111erc 
arc more than 30 computers in my car, twO ill m)' cell phone, one in my MP3 
player, and one in m)' camera. 111en there is my laptop (on which the page you 
arc reading is being written) ruld my desktop machine. 111e air-conditioning con-
troller that keeps the summer heat and humidit), at bay is a simple computer. 
"111ere is one controlling the computer science department's clevaLQr. If you usc a 
modern television, there will be at least aile computer in there somewhere. A bit 
of web surfmg gets ),Oll into direCL comact with dozens - possibly hundreds - of 
servers through a telecommunications system consisting of many thousands of 
computers - telephone switches, routers, ruld so 011 . 
No, I do not drive around with 30 laptops on the backseat of my car! ~nle 
point is that most computers do not look like the popular image of a computer 
(with a screen, a keyboard, a mOllse, etc.); they are small "parts" embedded iJl 
the kind of equipment we usc. So, that caf has nothing that looks like a computer, 
not even a screen to display maps and driving directions (though such gadgets 
arc popular in other cars). However, its engine contai.ns quite a few computers, 
doing things like fuel iI~ ecLion control and temperature monitoring. 111e power-
assisted steering involves at least one computer, the radio and the securit), s),stem 
19 

CHAPTER 1 • COMP UTERS, PEOPLE, AND PROGRAMMIN G 
contain some, and we suspect that even the open/close controls of the windows 
are computer controlled. Newer models even have computers that continuously 
monnor ure pressure. 
How many computers do you depend on for what you do during a day? You 
eat; if you live in a modern city, gelting the food to you is a major effort requiring 
minor miracles of planning, transport, and storage. TIle management of the dis-
tribution networks is of course computerized, as arc the communication systems 
that stitch them all together_ Modern farming is highly computerized; next to the 
cow barn you find computers used to monitor the herd (ages, health, milk pro-
duction, elc.), fann equipment is increasingly computerized, and the number of 
forms required by the various branches of government can make any honest 
farmer cry, If something goes wrong, you can read all about it in YOllr newspa-
per; of course, the articles in that paper were written on computers, sct on the 
page by computers, and (if you still read the "'dead tree edition") printed by com-
puterized equipment - often after having been eleclronically transmitted to the 
priming plant. Books are produced in the same way. If you have to commute, the 
traffic flows arc monitored by computers in a (usually vain) attempt to avoid traf-
fic jams. You prefer to take the train? "l1lat train will also be compUlerized; some 
even operate without a driver, and the train's subsystems, such as announce-
ments, braking, and ticketing, involve lots of computers. Today's entertainment 
industry (music, movies, television, stage shows) is among the largest users of 
computers. Even non-cartoon movies usc (computer) animation heavily; music 
and photography also tend to be digital (i.e., using compUlers) for both recording 
and delivery. Should you become ill, the tesls your doctor orders will involve 
computers, the medical records arc often computelized, and most of the medical 
equipment you'll encounter if you arc sent to a hospitallO be cured contains 
computers. Unless you happen to be staying in a cottage in the woods without 
access to any elew'ically powered gadgets (including light bulbs), YOli lise energy. 
Oil is found , extracted, processed, and distributed through a system using com· 
puters every step along the way, from the dJ"iH bit deep in the ground to yoUI' 
10c.,1 gas (petrol) pump. If yOll pay for that gas with a credit card, you again exer-
cise a whole host of computers. It is the same Story for coal, gas, solar, and wind 
power. 
TIle examples so far are an "operationaJ"; they arc directly involved in what 
you are doing. Once removed from that is the important and interesting area of 
design. "111e clothes you wear, lhe telephone you talk into, and the coffee ma-
chine that dispenses your favorite brew were designed and manufactured using 
computers. The superior quality of modern photographic lenses and the exqui-
site shapes in the design of modern everyday gadgets and utensils owe almost 
everything to computer-based design and production methods. 111e crafts-
menJdesignersfanistsfengineers who design our environment have been freed 

1.3 
PEOPLE 
from many physical constraints previously considered fundamental. If you get ill, 
the medicines given to cure you will bave been designed using computers. 
Finally, researdl - science itself - relics heavily on computers. The tele-
scopes that probe the secrets of distant stars couJd not be designed, built, or oper-
ated without computers, and the masses of data they produce couldn't be 
analyzed and understood without computers. An individuaJ biology field re-
sellrcher lllay not be heavily computerized (unless, of course, a camera, a digitaJ 
tape recorder, a telephone, etc. arc used), but back in the lab, the data has to be 
stored, analyzed, checked against cOlllputer illodels, and communicated to fellow 
scientists. Modem chemistry and biology - including medical research - use 
computers to an extent undreamed of a few years ago and still unimagined by 
most people. The human genome was sequenced by computers. Or - let's be 
precise - the human genome was sequenced by humans using computers. In all 
of these examples, we see computers as something t.hat enables liS to do some-
thing we would have had a harder lUne doing without computers. 
Every one of those computers runs software. Without software, they would 
just be expensive lumps of silicon, metal, and plastic: doorstops, boat anchors, 
and space healers. Every line of that software was written by some individual. 
Every one of those lines that was actually executed was minimally reasonable, if 
not COITeCt. It's amazing that it aJl works! We are talking about billions of lines of 
code (program tcxt) in hundreds of prograUlming languages. Getting all that to 
work took a staggering amount of efTort and involved an unimaginable number 
of skills. We wam further improvements to essentially every service and gadget 
we depend on. Just lhink of anyone service and gadget yOll rely on; what would 
you like to sec improved? If nothing else, we want our services and gadgets 
smaller (or bigger), faster, more reliable, with more features, easier to usc, with 
higher capacilY, better looking, and cheaper. TI1C likelihood is that the improve-
ment you thought of requircs some programming. 
1.3 People 
Computers arc built by people for the lise of people. A computer is a very generic 
tool; it can be lIsed for an unimaginable range of tasks. It takes a program to 
make it useful to someone. In other words, a computer is just a piece of hardware 
until someone - some programmer - writes code for it to do something useful. 
We often forget about the software. Even more often, we forget about the pro-
grammer. 
Hollywood and similar "popular culture" sources of disinfommtion have as-
signed largely negative images to programmers. For example, we have all seen 
lhe solitary, fat, ugly nerd with no social skills who is obsessed with video games 
and breaking into other people's complllers. He (almost always a male) is as 
21 

22 
( HAPTER 1 • COMP UTERS, PEOPLE. AND PROGRAMMING 
likely to want to destroy the world as he is to wam to save it. Obviously, milder 
versions of such caricatures exist in rcallifc, but in our experience they arc no 
more frcquem among software developers than they arc among lawyers, police 
officers, car salesmen, joumalists, arusts, or politicians. 
Tllink about the applications of computers you know from your own life. 
Were they done by a loner in a dark room? Of course nOt; lhe crealion of a suc-
cessful piece of software, compUlcrized gadgel, or system involves dozens, hun-
dreds, or thousands of people pcrfonning a bewildering set of roles: for example, 
progranuncrs, (program) designers, testers, animators, foclls group managers, ex-
perimental psychologists, lIscr imerface designers, analysts, system administra-
tors, customer relations people, sound engineers, project managers, quality 
engineers, statisticians, animators, hardware interface engineers, requirements 
enJ:,,;neers, safety officers, mathematicians, sales support personnel, troubleshoot-
ers, network designers, methodologists, softlvare tools managers, software librar-
ians, etc. 111e range of roles is huge and made even more bewildering by the titJes 
varying from organization to organization: one organization'S "engineer" may be 
another organization's "programmer" and yet another organization's "devel-
oper," "member of technical staff," or "'architect." TIlere arc even organizations 
that let tJleir employees pick their own litJes. Not all of these roles dircctJy involve 
progranmung. However, we have personally seen examples of people performing 
each of the roles mentioned while reading or writing code as an esseillial pan of 
their job. Additionally, a programmer (pcrfonning any of these roles, and more) 
may over a short period of time interact WitJl a wide range of people from appli-
cation areas, such as biologists, engine designers, lawyers, car salesmen, medical 
researchers, historians, geologists, astronauts, airplane ellJ:,,;neers, lumberyard 
managers, rocket scientists, bowling alley builders, joumalists, and animators 
(yes, this is a list drawn from personal experience). Someone may also be a pro-
grammer at limes and Jill non-programming roles at otJler stages of a professional 
career. 
TIle myth of a programmer being isolated is just that: a myth. People who 
like to work on their own choose areas of work where that is most feasible and 
usually complain bitterly about the number of "uuemlptions" and meetulgs. Peo-
ple who prefer to ulteract with other people have an easier time beQlUse modem 
software development is a team activity. The implication is tJlat social and com-
IllUlucation skills are essential and valued far more than tJle stereotypes indicate. 
On a shon list of lughly desirable skills for a programmer (however YOLI realisti-
cally defme progra1ll1lldj, you find the ability to communicate well - with people 
from a wide variety of backgrounds - infonnally, Ul meetings, in writing, and in 
formal presentations. We arc convinced that until you have completed a team 
project or twO, you have no idea of what programming is and whether yOll really 
like it. Among the things we like about programming are all tJle nice and interest-

1.] 
PEOPLE 
ing people we meet and the variety of places we get to visit as part of our profes-
sionallives. 
One implication of all this is that people with a wide variety of skills, inter-
ests, and work habits are essential for producing good sofn-vare. Our quality of 
life depends on those people - sometimes even our life itself. 
0 one person 
could fill all the roles we mention here; no sensible person would want every 
role. l oe point is that you have a wider choice than you could possibly imagine; 
not that you have to make any particular choice. As an individual you will "drift" 
toward areas of work that match your skills, talents, and interests. 
We talk about Mprogrammers" and "programming," but obviously program-
ming is only pari of the overall picture. The people who design a ship or a cell 
phone don't think of themselves as programmers. Programming is an important 
part of software development, but not all there is to software development. Simi-
larly, for most products, software development is an important part of product 
development, but not all there is to product development. 
We do not assume that you -
OUT reader - want to become a professional 
programmer and spend the rest of your working life writing code. Even the best 
progranuners - especially the be;r programmers - spend most of their lime lIor 
writing code. Understanding problems takes serious time and often requires sig-
nificant intellectual effort. That intellectual challenge is what many programmers 
refer to when they say that programming is interesting. Many of the best pro-
grammers also have degrees in subjects not usually considered part of computer 
science. For example, if YOll work on software for genomic research, you will be 
much more effective if you understand some molecular biology. If you work on 
programs for analyzing medieval literature, you could be much beuer off reading 
a bit of that literature and maybe even knowing one or more of the relevant lan-
guages. In particular, a person with an Mall I care about is computers and pro-
gramming" attitude will be incapable of interacting with his or her 
non-programmer colleagues. Such a person will not only miss OUI on the best 
parts of human interactions (i.e., life) but also be a bad software developer. 
So, what do we assume? Programmillg is an intellectually challenbring set of 
skills that arc part of many important and interesting technical disciplines. In ad-
dition, progranuning is an essential part of our world, so not knowing the basics 
of programming is like not knowing the basics of physics, history. biology, or lit-
erature. Somcone totally ignorant of programming is reduced to believing in 
magic and is dangerous in many technical roles. If you read Dilbert, think of the 
pointy-haired boss as the kind of manager you don't want to meet or (far worse) 
become. In addition, programming can be fun. 
But what do we assume you might lise programming for? Maybe you will 
use programming as a key tool in your further studies and work without becom-
ing a professional programmer. Maybe you will interact with other people profes-
sionally and personally in ways where a basic knowledge of programmi.ng will be 
23 

2' 
CHAPTER 1 • COMPUTERS, PEOPL E, AND PROGRAMMING 
an advantage, maybe as a designer, writer, manager, or scientist. Maybe you will 
do programming at a professional level as part of your studies or work. Even if 
you do become a professional progranuncr it is unlikely that you will do nothing 
but programming. 
You might become an engineer focusing on computers or a computer scien-
tiSt, but evell then you will not "program all the time." Programming is a way of 
presenting ideas in code - a way of aiding problem solving. It is 1l00hing - ab-
solutely a waste of time - unless you have ideas that are worth presenting and 
problems worth solving. 
This is a book about programming and we have promised to help you Jcam 
how to program, so why do we emphasize non-progranuning subjects and the 
limited role of programming? A good programmer understands the role of code 
and programming technique in a project. A good programmer is (at most times) 
a good team player and tries hard to understand how the code and its production 
best support the overall project. For example, imagine that I worked on a new 
MP3 player and all that I cared about was the beauty of my code and the num-
ber of neat features I could provide_ I would probably insist on t.he largest, most 
powerful computer to run my code. I might disdain the theory of sound encod-
ing because it is "not programming." I would stay in my lab, rather than go out to 
meet potential users, who undoubtedly would have bad Lastes in music an)"vay 
and would not appreciate the latest advances in CUI (graphical user interface) 
progranuuing. TIle likely result would be disaster for the project. A bigger com-
puter would mean a costlier M P3 player and most likely a shorter battery life. 
Encoding is an essential part of handling music digitally, so failing to pay allen-
lion LO advances in encoding leclmiques could lead LO increased memory require-
ments for each song (encodings difTer by as much as 100% for the same-quality 
output). A disregard for users' preferences - however odd and archaic they may 
seem to you - typically leads to the users choosing some other product. An es-
sential part of writing a good program is to understand the needs of the users and 
the constraints that those needs place on the implementation (i.e., the code). To 
complete this caricature of a bad progranuner, we just havc to add a tendency to 
deliver late because of an obsession with details and an excessive confidence in 
the correctness of lightly tested code. We encourage you to become a good pro-
grammer, with a broad view of what it takes to produce good software. TIlat's 
where both the value to society and the keys to personal satisfaction lie. 
1.4 Computer science 
Even by the broadest definition, programming is best seen as a part of something 
greater. We can see it as a subdiscipline of computer science, computer engineer-
ing, software engineering, information technology, or any other software-related 
discipline. We see programming as an enabling technology for those computer 

1.5 
COMPUTERS ARE EVERYWHERE 
and information fields of science and engineering, as well as for physics, biology, 
medicine, history, literature, and any other academic or research field. 
Consider compuler science. A 1995 U.S. goverlUllenl "blue book n de[mes it 
like this: "TIle systematic study of computing systems and computation. TIle 
body of knowledge resulting from this discipline contains theories for under· 
standing computing systems and methods; design methodology, algorithms, and 
tools; methods for the testing of concepts; methods of analysis and verification; 
and knowledge representation and implcmentation.
n As we would expect, the 
Wikipedia entry is less formal: "Computer science, or computing science, is the 
study of the theoreticaJ foundations of information and computation and their 
implementation and application in computer systems. Computer science has 
many sub-fields; some emphasize the computation of specific resulls (such as 
computer graphics), while others (such as computational complexity theory) re-
late to properties of computational problems. Still others focus on me challenges 
ill implementing computations. For example, programming language theory 
studies approaches to describing computations, while computer programming ap-
plies specific programming languages to solve specific computational problems.n 
Programming is a tool; it is a fundamental tool for expressing solutions to 
fundamental and practicaJ problem.'! so that they can be tested, improved through 
experiment, and used. Programming is where ideas and theories meet reality. 
1l1is is where computer science c:."Ul become an experimental discipline, rather 
than pure theory, and impact the world. In this context, as in many others, it is 
essential that programming is an expression of well-tried practices as well as the 
theories. It must not degenerate into mere hacking: just get some code written, 
any old way that meets an inmlediate need. 
1.5 Computers are everywhere 
Nobody knows everything there is to know about computers or software. This 
section JUSt gives you a few examples. Maybe you'll see somethillg you like. At 
least you might be convinced that the scope of computer use - and through that, 
programming - is far larger than any individual can fully grasp. 
Most people think of a computer as a small gray box attached to a screen 
and a keyboard. Such computers tend to hide under tables and be good at 
games, messaging and email, and playing music. Other computers, called lap-
tops, are used on planes by bored businessmen to look at spreadsheets, play 
games, and watch videos. This caricature is just the tip of the iceberg. Most com-
puters work out of our sight and arc part of the systems mat keep our civilization 
going. Some flll rooms; others arc smaller than a small coin. Many of the most in .. 
teresting computers don't directly imcract with a hUlllan through a keyboard, 
mouse, or sUlular gadget. 

26 
CHAPTER I • COMP UTERS, PEOPLE, AN D PROG RAMMIN G 
1.5.1 Screens and no screens 
TIle idea of a computer as a fairly large square box with a screen and a keyboard 
is common and often hard to shake off. However, consider these twO computers: 
Both of these "gadgets" (which happen to be watches) arc primarily computers. 
In fact, we COlycclurc that they arc csscmially I.hc same model computer with dif-
ferent 110 (input/output) systems. 111e left one drives a small screen (si.milar to 
the screens on conventional computers, but smaller) and the second drives linle 
electric motors controlling traditional clock hands and a disk of numbers for day-
of-momh rcadOlll. 111cir input systems arc the foul' buttons (morc easily seen on 
the right-hand watch) and a radio receiver, lIsed for synchronization with very 
higb-precision "atomic" clocks. Most of the programs controlling these tWO com-
puters are shared between them. 
1.5.2 Shipping 
TIlese two photos show a large manne dicscl engine and the kind of huge ship 
that it may power: 

1.5 
COMPUTERS ARE EVERYWHERE 
Consider where computers and software play key roles here: 
/Je5ig1l: Of course, the ship and the engine were both designed uSLIlg 
computers. ~nle list of uses is almost endless and includes architectural 
and engineering drawings, general calculations, visualization of spaces 
and parts, and simulations of the performance of parts. 
ums/me/ioll: A modern shipyard is heavily computerized. 111c assembly 
of a ship is carefully planned using computers, and the work is done 
guided by computers. Welding is done by robots. In particular, a modem 
double-hulled tanker couldn't be built without little welding robots to do 
the welding from within the space between the hulls. 111ere just isn't 
room for a human in there. Cutting steel plates for a ship was one of the 
world's first CAD/CAM (computer-aided design and computer-aided 
manufacture) applications. 
The ellgine: TIle engine has electronic fuel injection and is controlled by a 
few dozen computers. For a !DO,OOO-horsepower engine (like the one in 
the photo), that's a nontrivial task. For example, the engine management 
computers cominuously adjust fuel mix to minimize the pollution that 
would result from a badly tuned engine. Many of the pumps associated 
with the engine (and other parts of the ship) are themselves computer· 
ized. 
Mallagemen/: Ships sail where there is cargo to pick up and to deliver. TIle 
scheduling of fleets of ships is a continuing process (computerized, of 
course) so that routings change with the weather, with supply and de-
mand, and with space and loading capacity of harbors. There are even 
wcbsitcs where you ca.n watch the position of major merchant vessels at 
any lime. The ship in the photo happens to be a container vessel (the 
largest such in the world; 397m long and 56m wide), but other kinds of 
large modem ships are managed in similar ways. 
MOllitorillg: An oceangoing ship is largely autonomous; that is, its crew 
can handle most contingencies likely to arise before the next port. How-
ever, they arc also part of a globe-spanning network. TIle crew has ac-
cess to reasonably accurate weather infonnation (from and through -
computerized - satellites). TIley have CPS (global positioning system) 
and computer-controlled and computer--enhanced radar. If the crew 
needs a rest, most systems (including the engine, radar, etc.) can be mon-
itored (via satellite) from a shipping-line control room. If anything un-
usual is spotted, or if the eonnection "back home" is broken, the crew is 
notified. 
Consider the implication of a failure of one of the hundreds of computers explic-
illy mentioned or implied in this brief description. Chapter 25 ("Embedded Sys-
tems Programming") eXaJlunes this in slightly more detail. Writing code for a 
modern ship is a skilled and interesting activity. It is also useful. The COSt of 
27 

2. 
CHAPTER I • CO MPUTERS, PEOPLE, AND PROGRAMMI NG 
transport is really amazingly low. You appreciate that when you buy something 
that wasn't manufactured locally. Sea transport has always been cheaper than 
land transport; these days one of the reasons is serious usc of computers and 
information. 
1.5.3 Telecommunications 
"Illesc twO photos show a telephone switch and a telephone (that also happens to 
be a camera, an M P3 player, an FM radio, and a web browser): 
\ 
\ ". 
\ " " 
.\ 
,. , t 
l'I· ,iI' ) 
~ ( , ~~, t 
! \ \. 
Consider where computers and software play key roles here. You pick up a tele-
phone aJld dial, the person you dialed answers, and you talk. 01' maybe yOll get 
to talk to an answering machine, or maybe you send a photo from yom phone 
camera, or maybc YOll send a tCXt message (hit "send" and let the phone do the 
dialing). Obviously the phone is a computer. l11is is especially obvious if the 
phone (like most mobile phones) has a screen and allows more than traditional 
"'plain old telephone services," such as web browsing. Actually, such phoncs tend 
to contain several computers: one to manage the screen, one to t,llk to the phone 
system, and maybe more. 
l11e part of the phone that manages the screen, docs web bJ'Owsing. etc. is 
pJ'Obably the most familiar to computer users: it just nms a gmphicaJ user inter· 
face to "all the usual Sluff." What is un.known to and largely unsuspected by most 
users is lhe huge system that the litt1c phone talks to while doing its job. I dial a 
number in Texas, but you arc on vacation in New York City, yet within seconds 
your phone rings and I hear your "'Hello!" over the roar of city traffic. Many 
phones can perform that trick for essentially any two locations on earth and we 
JUSt take it for granted. How did my phone rmd yours? How is the sound lrans· 
nUlted? How is the sound encoded into data packets? l 11e answer could fill 

1.5 
COMPUTERS ARE EVERYWHERE 
many books much thicker than this one, but it involves a combination of hard-
ware and software on hundreds of computers scattcred over the geographical 
area in question_ Ir you are unlucky, a few telecommunications satellites (them-
selves computerized systems) arc also involved - "unlucky" because we cannot 
perfectly compensate for the 20,OOO-mile detour out into space; the speed of light 
(and therefore the speed of your voice) is finite (light fiber cables are much beuer: 
shorter, fasler, and carrying much more data). Most of this works remarkably 
well ; the backbone telecommunications systems arc 99.99990/0 reliable (for exam-
ple, 20 minutes of downtime in 20 years - tim's 20120*365*24*60)_ The trouble 
we have tends to be in the communications between our mobile phone and the 
nearest main telephone switch. 
111ere is software for connccting the phones, for chopping our spoken "mrds 
into data packets to be sent ovcr wires and radio links, for routing those mes-
sages, for recovering from all kinds of failures, for continuously monitoring the 
quality and reliability of the services, and of course for billing. Even keeping 
track of all the physical pieces of the system requires serious amounts of clever 
software: '#hat talks to what? What parts go into a new system? \¥hen do you 
need to do some preventive maintenance? 
Arguably the backbone telecommunications system of the world, consisting 
of semi-independent but interconnected systems, is the largest and most compli-
cated man-made artifact. To make things a bit more real: remember, this is not 
just boring old telephony with a few new bells and whistles. The various infra-
structures have merged. They arc also what the internet (the web) runs on, what 
our banking and trading systems run on, and what carry our television programs 
to the broadcasting stations. So, we can add anmher couple of photos to illustrate 
telecommunications: 
"n,e room is the "trading floor" of the America.n stock exchange on New York's 
Wall Street and the map is a representation of pans of the intemet backbones (a 
complete map would be too messy to be useful). 
As it happens, we also like digital photography and the usc of computers to 
draw specialized maps to visualize knowledge_ 

30 
(HAPTER 1 • CO M PUTERS, PEOP LE, AND PROG RAMM ING 
1.5.4 Medicine 
These two photos show a CAT (computed axial tomography) scanner and an op-
erating theater for computer-aided surgery (also called "robol-assisted surgery" 
or "robotic surgcIY"): 
Consider where computers and software play key roles here. 111C scanners basi-
cally arc computers; the pulses they send Ollt a TC controlled by a computer, and 
the readings are nothing but gibberish until quite sophisticated algorithms arc ap-
plied to convert them to something we recognize as a (three-dimensional) image of 
the relevant part of a human body. To do computerized surgery, we must go sev-
eral steps further. A wide variety of imaging techniques arc lIsed to let the surgeon 
sec the inside of the paticlll, to see the point of surgery with significam emarge-
mem or in beller light tlUUl would othen vise be possible. With the aid of a COIll-
pUler a surgeon can usc tools thal are too fine for a human hand to hold or in a 
place where a human hand could not reach withoUi U1Ulecessary cutting. TIle usc 
of minimally invasive surgery (Iaparoscopie surgery) is a simple example of this 
that has minimized the pain and recovery time for millions of people. TIle com-
puter can also help steady the surgeon's "hand" to allow for more delicate work 
tll3.11 would othen vise be possible. Finally, a "robotic" system C<"tn be operated re-
motely, thus making it possible for a doctor to help someone remotely (over tile 
internet). The computers and progra.1luning involved are mind·boggling, COIll-
plex, and interesting. TIle user-interface, equipmem control, and imaging elml-
lenges alone will keep thousands of researchers, engineers, and programmers 
busy for decades. 
We heard of a discussion among a large group of medical doctors about 
which new tool had provided the most help to them in their work: 'nle CAT 
scanner? TIle MRl scanner? The automated blood analysis machines? 11le high-
resolution ultrasound machines? PDAs? Nter some discussion, a surprising 
"wilmer" of tllis "competition" emerged: instant access to patient records. Know-
ing tile medicaJ history of a patient (earlier illnesses, medicines tried earlier, aller-
gies, hereditary problems, gcneral health, current medication, etc.) simplifies the 
problem of diagnosis and minimizes the chance of mistakes. 

1.5 
COMP UTERS ARE EVERYWHERE 
1.5.5 Information 
These two photos show an ordinary PC (well, two) and part of a server fann: 
\o\'e have fOCllsed on "gadgets" for the lIslial reason: yOll ealUlot sec, feci, or hear 
software. \'\Ie cannOt present you with a photograph of a neat program, so we 
show YOll a "gadget" that runs one. However, much software deals directly with 
"infonnation." So let's consider "ordinary uses" of "ordinary computers" rtmning 
"ordinary software." 
A "server farm" is a collection of computers providing web services. By using 
Coogle (a web search engine), we found the following infonnation supplied by 
Wikipedia (,\ web dictionary). In 2004 it was estimated that Coogle's server farm 
had the following specs: 
719 racks 
63,272 machines 
126,544 C PUs 
253THz of processing power 
126,544GB of RAM 
5,062TB of hard drive space 
A Gll is a gigabyte, that is, about 1,000,000,000 characters. A Tn, a terabyte, is 
about 1,000GB, thaI is, about 1,000,000,000,000 characters. These days, the 
"farms" arc much bigger. ~111is is a preuy extreme example, but every major com· 
pany runs programs on the web to interact with its users/customers. Examples 
are Amazon (book and Olher sales), Amadeus (airline ticketing and automobile 
rental), and eBay (online auctions). Millions of liule companies, organizations, 
and individuals also have a presence on the web. Most don't nUl their own soft-
ware, but many do and much of that is not trivial. 
'11e other. and more traditional, massive computing eITort involves account-
ing, order processing, payroll, record keeping, billing, inventory management, 
31 

32 
CHAPTER 1 • COMPUTERS, PEOPLE, AND PROGRAMMING 
personnel records, studclll records, patient records, etc. - the records that essen-
tially every organization (commercial and nonconlllcrcial, govcmmental and pri-
vate) keeps. These records arc the backbone of their respective organizations. As 
a computing effort, processing such records seems simple: mostly some informa-
tion (records) is just stored and retrieved and very liule is done to it. Examples 
include 
Is my 12:30 flight to Chic.'l.go still on lime? 
Has Gilbert Sullivan had the measles? 
Has the coffcemakcr that Juan Valdez ordered been shipped? 
What kind of kitchen chair did Jack Sprat buy in 1996 (or so)? 
How many phone calls originated from the 2 12 area code in August of 
2006? 
What was the number of coffeepots sold in J anuary and for what total 
price? 
TIle sheer scale of the databases involved makes these systems highly complex. 
To that add the need LO respond quickly (often in less than twO seconds for indio 
vidual queries) and to be correct (at least most of I.he time). TIlese days, it is not 
uncommon for people to talk about terabytes of data (a byte is the amount of 
memory needed LO hold an ordinary character). That's I.raditional ';data process· 
ing" and it is merging wil.h "me web" because mosl. access to the databases is 
now though web interfaces. 
This kind of computer usc is often referred to as ilyarlllation j)f(xcssillg. It fo· 
cuses on data - often lots of data. ~rb i s leads to challenges in the organization 
and transmission of data and lots of interesting work on how to present vast 
amounts of data in a comprehensible form: "user interface" is a very important 
aspect of handling data. For example, think of analyzing a work of older litem-
ture (say, Chaucer's CAnterbury "faUJ or Cervantes' Dml O!Jixote) to figure out what 
the author actually wrOle by comparing dozens of versions. We need to search 
through the texts with a variety of criteria supplied by the person doing the 
analysis and to display the results in a way that aids the discovery of salient 
poims. 111inking of text analysis, publishing comes to mind : today, just about 
every article, book, brochure, newspaper, etc. is produced on a computer. De-
signing software to support that well is for most people still a problem that lacks a 
really good solution. 
1.5.6 A vertical view 
It is sometimes claimed that a paleontologist can reconstruct a complete dinosaur 
and describe its lifestyle and natural environment from sl.Udying a single small 
bone. 111at may be an exaggeration, but there is something to the idea of looking 
at a simple artifact and thinking about what it implies. Consider this photo show-
ing the landscape of Mars taken by a ca.mera on one of NASA's Mars Rovers: 

I .S 
COM PU TER S AR E EV ERYWH ERE 
If you want to do "rocket science," becoming a good programmer is one way. 
TIle vilriol,.lS space programs employ lots of software designers, especially ones 
who can also understand some of the physics, math, electrical engineering, me-
chanical engineering, medical engineering, etc. that underlie the manned ,md un-
manned space programs. Getting those two Rovers to drive around on Mars for 
over four years (their estimated design life was three months) is one of the great-
est technological triumphs of ollr civilization. 
111e photo was transmitted to earth through a communication channel with 
a 25-minute transmission delay each way; there is a lot of clever programming 
and advanced math to make sllre that the picture is transmitted Llsing the mini-
llIal number of bits without losing any of them. On earth, the photo is then ren-
dered using algorithms to restore color and minimize distortion due to the optics 
and electronic sensors. 
11le control programs for the Mars Rovers are of course programs - the 
Rovers drive autonomously for 24 hours at a time and follow instructions sent 
from earth the day before. TIle transmission is managed by programs. 
~l1le operating systems used for the various computers involved in the 
Rovers, the transmission, and the photo reconstruction are programs, as arc the 
applications llsed to write this chapter. The computers on which these programs 
run arc designed and produced using CAD/CAM (computer·aided design and 
computer-aided manufacture) programs. TIle dlips that go into those computers 
arc produced on computerized assembly lines constructed using precision tools, 
and those tools also use computers (and software) in their design and manufac-
ture. The quality con11'ol for those long construction processes involves serious 
computation. All that code was written by humans in a high·lcvcJ programming 
language and translated into madline code by a compiler, which is itself such a 
program. Many of these programs interact with lIsers using G UI and exchange 
data llsing input/output streams. 
Finally, a lot of programming goes into image processing (including the pro-
cessing of the photos from the Mars Rovers), animation, and photo editing (there 
arc versions of the Rover photos floating around on the web featuring "Martians"). 
33 

J4 
C H APTE R ' 
• COMPUTE RS, PEOPLE, ANO PROGRAMMING 
1.5.7 So what? 
What do all these "fancy and complicated" applications and software systems 
have to do with learning programming and lIsing C++? '11C connection is sim-
ply that many programmers do gel to work on projects like these. These arc the 
kinds of lhings that good programming can help achieve. Also, every example 
used in this chapler involved C++ and at least some of the techniques we de-
scribe in this book. Yes, there are C++ programs in M P3 players, in ships, in 
wind mrbines, on Mars, and in the human genome project. For more applications 
using C++, see \",",,\V.research.au} - bs/applic.:"1tions.html. 
1.6 Ideals for programmers 
What do we wallt from our programs? What do we want in general, as opposed 
lO a particular feature of a particular program? We want CQI'rectllesJ and as part or 
that, rdinbilil)'. If the program doesn't do what it is supposed to do, and do so in a 
way so that we ca.n rely on it, it is at best a serious nuisance, at worst a danger. 
We want it to be well d£sig1~(J so umt it addresses a real need well; it doesn't really 
mattcr that a program is correct ir what it does is irrelcvant to us or ir it cOlTcctly 
does something in a way that rumoys us. We also Wrult it to bc tifJordable; I might 
prdcr a Rolls-Royce or an executive jet to my usual rorms or transport, but un-
less I'm a z.illionaire, COSt will enter into my choices. 
ll1ese arc aspects or sorl\\'arc (gadgets, systcms) umt can be appreciated rrom 
the outside, by non-programmers_ They must be ideals ror programmers and we 
must keep them in mind at all times, especially in the early phases or develop-
ment, if we want to produce successrul sornvarc. In addition, we must coneem 
ourselves with ideals related to the code itsclr: our code must be mail//ail/llble; that 
is, its structu.rc must be such that someone who didn't write it can understruld it 
and make changes_ A successrul program "lives" ror a long time (orten for 
decades) and will be changed again and again. For example, it will be moved to 
new hardware, it will have new reatures added, it will be modified to use new 1/0 
racilities (screens, video, sound), to interact using new natural languages, etc. 
Only a railed progrrun will never be modified. "Ib be maintainable, a program 
must be simple relative to its requirements, ruld the code must directly represent 
the ideas expressed. Complexity - the enemy or simplicity and maintainability -
can be intrinsic to a problem (in that case we JUSt have to deal with it), but it can 
also arise rrom poor expression or ideas in code. We must try to avoid that 
through good coding style - style matters! 
llis doesn't sound too difficult, but it is. Why? Programming is rundamen-
tally simple: just tell the machine what it is supposed to do. So why can program· 
ming be most challenging? Computers arc rundamentally simple; they can just 

1.6 
IDEALS FOR PROGRAMMERS 
do a few operations, such as adding twO numbers and choosing the next instruc· 
tion to cxecute based on a comparison of two numbers. "n lC problem is that we 
don't want computers to do simple things. Wc want "lhe machine" to do lhings 
that arc difficult cnough for us to want help with them, but computers are nit-
picking, unforgiving, dumb beasts. Furthennore, the world is more complex than 
we'd like to believe, so we don't really know the implications of what we request. 
We juSt want a program to "do someLhing like this" and don't want to be bOlh· 
ered with technic.11 details. We also tend to assume "common sense." Unfortu· 
nately, common sense isn't all that common among humans and is totally absent 
in computers (though some reaUy weU·designed programs can imitate it in spe· 
cific, well·understood cases). 
111is line of thinking leads to the idea I.hat "programming is understanding": 
when you can program a [ask, you understand it. Conversely, when you under-
stand a task thoroughly, you can write a program to do it. In oLher words, we can 
see programming as part of an effort to thoroughly understand a topic. A pro-
gram is a precise representation of our understanding of a topic. 
When you program, you spend significant time trying to understand the task 
you are trying to automate. 
We can describe the process of developing a program as having four stages: 
A1I(I/ysis: \>Vhat's the problem? 'What does the user want? \.vhat does the 
user need? What can the user afford? 'What kind of reliability do we 
need? 
Desigp: How do we solve the problem? What should be Lhe overall Sll"UC-
lUre of the system? Which parts docs it consist of? How do Lhose parts 
communicate wiLh each other? How does the system communicate with 
its users? 
Programming: Express the solution to the problem (Lhe design) in code. 
Write the code in a way Lhat meets all constraints (time, space, money, 
reliability, and so on). Make sure that the code is correct and maintain· 
able. 
7CShiJg: Make sure the system works correctly under all circumstances re· 
quired by systematically trying it out. 
Programming plus testing is often called implementati(J1I. Obviously, this simple split 
of software developmcnt into four parts is a simplification. llick books havc bccn 
written on each of these four topics and more books still about how they relatc to 
each other. One imponam lhing to note is that Lhesc stages of developmcnt are 
not independent and do not occur strictly in sequence. We lypically start wilh 
analysis, but feedback from testing can help improve the programming; problems 
with gctting the program working may indicate a problcm with the design; and 
35 

36 
( HAPTER 1 • COMP UTERS, PEOPLE, AND PROGRAMMING 
working with lhe design may suggest aspects of the problem that hitherto had 
been overlooked in the analysis. Actually using the system typically exposes weak-
nesses of the illmlysis. 
The crucial concept here is ftedlmclr.. We learn from experience and modify 
our behavior based on what we learn. That's essential for effective software de-
velopment. For any large project, we don't know everything there is to know 
about the problem and its solution before we start. We can try out ideas and get 
feedback by programming, but in me earlier stages of development it is casic]-
(and faster) to gel feedback by writing down design ideas, trying out those design 
ideas, and using scenarios all friends. The best design tool we know of is a black-
board (usc a whiteboard instead if you prefer chemical smells over chalk dust). 
Never design alone if you can avoid itl Don't st.-u"! coding before you have tried 
out your ideas by explaining them to someone. Discuss designs and program~ 
millg techniqucs with friends, colleagues, potential users, and so on before you 
head for the keyboard. II is amazing how much you can learn from simply trying 
to aniculate an idea. After all, a program is nothing more than an expression (in 
code) of some ideas. 
Similarly, when you get stuck implementing a program, look up from the 
keyboard. Think about the problem itself, rather than your incomplete solution. 
Talk with someone: explain what you want to do and why it doesn't work. It's 
amazing how often you find the solution just by carefully explaining the problem 
to someone. Don't debug (find program errors) alone if you don't have tot 
The focus of this book is implementation, and especially programming. We 
do not teach ';problem solving" beyond giving you plenty of examples of prob· 
lems and their solutions. Much of problem solving is recognizing a known prob· 
lem and applying a known solution technique. Only when most subproblems arc 
handled this way will you find the time to indulge in exciting and creative "out· 
of·the·box thinking." So, we focus all showing how to express ideas clearly in 
code. 
Direct expression of ideas in code is a fundamental ideal of programming. 
That's really pretty obvious, but so far we are a bit shan of good examples. We'll 
come back to this, repeatedly. When we want an integer in our code, we store it 
in an int, which provides the basic integer operations. When we want a string of 
characters, we store it in a string, which provides the most basic text manipula· 
tion operations. At the most fundamental level, the ideal is that when we have an 
idea, a concept, an entity, something we think of as a "thing," something we can 
draw on our whiteboard, something we can refer to in our discussions, some· 
thing our (non-computer science) textbook talks about, then we want that some· 
thing to exist in our program as a named entity (a type) providing the operations 
we think appropriate for it. If we want to do math, we want a complex type for 
complex numbers and a Malrix type for linear algebra. If we want to do graphics, 

CHAPTE R I REV IEW 
we wam a Shape type, a Circle type, a Color type, and a Dialo&.-boJl:. "Vhen we 
want to deal with streams of data, say from a temperature sensor, we want an 
istream type ("i" for input). Obviously, every such type should provide the ap-
propriate operations and only the appropriate operations. Illese arc just a few 
examples from this book. Beyond that, we offer tools and techniques for you to 
build your own types to directly represent whatever concepts you want in your 
program. 
Programming is part practical, part theory. If you arc just practical, you will 
produce non·scalable, unmaintainable hacks. If you arc just theoretical, you will 
produce unusable (or unafTordable) toys. 
For a different kind of view of the ideals of programming and a few people 
who have contributed in major ways to software through work with program· 
ming languages, sec Chapter 22, "Ideals and History." 
Review 
Review questions arc intended to point you to the key ideas explained in a chap' 
tel'. One way to look at them is as a complement to the exercises: the exercises 
focus on the practical aspects of programming, whereas the review questions try 
to help you articulate the ideas and concepts. In that, they resemble good inter· 
view questions. 
I. What is soft\vare? 
2. VVhy is software important? 
3. Where is software important? 
4. \¥hat could go wrong if some software fails? List some examples. 
5. \"'here docs software play an important role? List some examples. 
6. What arc some jobs related to software development? List some. 
7. What's the difference between computer science and programming? 
8. Where in the design, construction, and use of a ship is software used? 
9. What is a server farm? 
10. What kinds of queries do you ask online? List some. 
II . VVhat are some uses of software in science? List some. 
12. \¥hat are some uses of soft\vare in medicine? List some. 
13. \¥hat arc some uses of software in entertainment? List some. 
14. \¥hat general properties do we expect from good software? 
15. What docs a software developer look like? 
16. What arc the stages of software development? 
17. Why can software development be difficult? List some reasons. 
18. What arc some uses of software that make your life easier? 
19. What arc some uses of software that make your life more difficult? 
37 

J8 
CHAPTER t • COMPUTE RS, PEOP LE, AN D PROGRAM MI NG 
Terms 
"Illese terms prescnt the basic vocabulary of programming and of C++. Ir yOLi 
waIll to understand what people say about programming topics and to articulate 
your own ideas, you should know what each means. 
aITordabiJity 
analysis 
blackboard 
CAD/CAM 
communications 
correctness 
Exercises 
customer 
design 
feedback 
CUI 
ideals 
implementation 
programmer 
programming 
software 
stereotype 
testing 
user 
I. Pick an activity you do most days (such as going LO class, eating dinner, 
or watching television). Make a list of ways computers arc directly or in-
directly involved. 
2. Pick a profession, preferably one that you have some interest in or some 
knowledge of. Make a list of activities done by people in that profession 
that involve computers. 
3. Swap your list rrom exercise 2 with a rriend who picked a different pro· 
ression and improve his or her list. 'When you have both done that, COIll-
pare your results. Remember: 'Tllere is no perrect solution to ;tn 
open-ended exercise; improvements arc always possible. 
4. From your own experience, describe an activity that would not havc 
been possible without computers. 
5. Make a list or programs (sort\ivare applications) that you have directly 
used. List only examples where you obviously interact with a program 
(such as when scJcCling a new song on an M P3 player) and not cases 
where there just might happen to be a complll"er involved (such as turn· 
ing the steering wheel or your car). 
6. Make a list or ten activities that people do that do not involve computers 
in any way, even indirectly. This may be harder than you think! 
7. Identify five tasks ror which complilers arc not used today, but ror which 
you think they will be used ror at some time in the ruture. Write a rew 
sentences LO elaborate on each one that you choose_ 
8. Write an explanation (at least 100 words, but rewer than 500) or why 
you would like to be a computer progranuner. If, on the other ha.nd, you 
arc convinced that you would not like to be a programmer, explain tllat. 
In either case, present well-thought-out, logical arguments. 

CHAPTER 1 POSTSCRIPT 
9. Write an explanation (at least 100 words, but fewer than 500) of what 
role other than programmer you'd like to play in the computer industry 
(independently of whether "programmer" is your first choice). 
10. Do you think complilers will ever develop to be conscious, thinking be-
ings, capable of competing with humans? Write a short paragraph (at 
least 100 words) supporting your position. 
II . List some characteristics that most successful programmers share. Then 
list some characteristics that progranmlers arc popularly assullled to 
have. 
12. Identify at least five kinds of applications for computer programs men-
tioned in this chapter and pick the one that you find the most interesti.ng 
and that you would most likely want to participate in someday. Write a 
short paragraph (at least 100 words) explaining why you chose the one 
you did. 
13. How much memory would it take to Store (a) this page of text, (b) this 
chapter, (c) all of Shakespeare's work? Assume one byte of memory 
holds one character and just uy to be precise to about 20010. 
14. How much memory docs YOllr computer have? Main memory? Disk? 
Postscript 
Qur civilization mns on software. Software is an area of unsurpassed diversity 
and opportunities for interesting, socially useful, and profitable work. \lVhen YOll 
approach software, do it in a principled and serious manner: you want to be part 
of the sollilion, not add to the problems. 
We arc obviously in awe of the range of software that permeates our techno-
logical civilization. Not all applications of software do good, of course, but that is 
another story. Here we wamed to emphasize how pervasive software is and how 
much of what we rely on in our daily lives depends on software. It was all written 
by people like us. All the scientists, mathematicians, engineers, programmers, etc. 
who built the software briefly mentioned here stancd like you arc starting. 
Now, let's get back to the down·to-earth business of learning the technical 
skills needed to program. If you start wondering if it is worth all your hard work 
(most thoughtful people wonder about that sometime), come back and reread this 
chapter, the Preface, and bits of Chapter 0 ("Notes La the Reader"). If you start 
wondering if you can handle it all, remember Lhat millions have succeeded in be-
coming competent progranuners, designers, software engineers, etc. You can, too. 


Part I 
The Basics 


\.1 . 
r 
2 
Hello, World! 
"Programming is learned 
by writing programs." 
-Brian Kernighan 
H
ere, we presem the simplest C++ program that actually 
does anything. The purpose of writing this program is La 
Let YOli try your programming environment 
• Give you a first feci of how you can gel a computer to do 
things for you 
Thus, we present the notion of a program, the idea of trans-
lating a program from human-readable form to machine instmc-
tions using a compiler, and finally executing those machine 
Illstrucuons. 

44 
2.1 Programs 
2.2 The classic first program 
2.3 Compilation 
2.4 Linking 
2.5 Programming environments 
2.1 Programs 
(HAPTER 2 • H EllO, WORLD! 
To get a computer to do something, YOli (or someone else) have to tell it exactly 
- in excruciating detail - what to do. Such a description of "what to do" is called 
a program, and programmillg is the activity of writing and tcsting sllch programs. 
In a sense, we have all programmed before. After all, we have given descrip-
tions of tasks to be done, such as "how to drive to the nearest cincma,n "how to 
rU1d the upstairs bathroom," and "how to heat a meal in lhe microwave." "n 1C dif-
ference bct'o\lccn slIch descriptions and programs is one of degree of precision: 
humans lend to compensate for poor instructions by using common sense, but 
computers don't. For example, "turn right in the corridor, up the stairs, it'll be on 
your lcft " is probably a linc description of how to gct to the upstairs bathroom. 
However, when you look at thosc simple instn lctions, you'll lind the grammar 
sloppy and the instructions incomplete. A human casily compensates. For exam-
ple, assumc that you are sitting at the table and ask for directions to the bath-
room. You don't need to be told to get lip from yom chair to get to the cOITidor, 
somehow walk around (and not across or under) the table, not to step on the cat, 
etc. You'll not have to be told not to bring your k.nife and fork. or to remember to 
switch on the light so that you can see thc stairs. O pening the door to the bath-
room before cntering is probably also something you don't have to be told. 
In contrast, computers arc "ally dumb. ~nlcy have to have everything de-
scribed prccisely and in detail. Consider again "tum right in the con'idor, up the 
stairs. it'll be on your left." Where is the corridor? W hat's a corridor? W hat is 
;'tum right"? What stairs? How do I go up stairs? (One step at a time? l\vo 
steps? Slide up the banister?) "What is on my left? W hen will it be on my left ? To 
be able to describe "things" precisely for a computer, we need a precisely ddined 
language with a specific grammar (English is far tOO loosely structured for that) 
and a well-defined vocabulary for the kinds of actions we want performed. Such 
a language is called a programming langu~, and C++ is a programming language 
dcsigned for a wide selection of programming tasks. 
If you waUl greater philosophical detail about computers, programs, and pro-
gramming, (re)read Chapter I. Here, lei's have a look at some code, starting with 
a very simple prOb'l'am and the tools and techniques you need to get it to run. 

22 
THE ClASSIC FIRST PROGRAM 
2.2 The classic first program 
Hen: is a version of l,he classic ftrst program. It writes "Hello, World!" to your screen: 
IIThis program outputs the message "Hello, Worl d ! ~ to the monitor 
#include "SldJ ib_facililies.h" 
int mainO 
( 
II C++ programs start by executing the function main 
coul « "Hello, World!\n"; 
II output HHello, World!" 
return 0; 
) 
~nlink of this text as a set of instructions Lhat we give to the computer to execute, 
much as we would give a recipe to a cook to follow, or as a list of assembly in· 
structions for us to follow to get a new toy working. Let's discuss what each line 
of this program docs, starting with the line 
cout « "Hello. World !\n"; 
II output HHello, World!" 
1113t's the line that actually produces the output. It prints the characters Hello, 
World! followed by a newline; that is, after writing Helio, World! , the cursor will 
be placed at the strut of the next line. A CUTlOr is a little blinking character or line 
showing where you can type the next character. 
In C++, string literals arc delimited by double quotes ("); that is, "Hello, 
World!\n" is a string of characters. The \n is a "special character" indicaLing a 
newline. 111e name coul refers to a standard output stream. Characters "put into 
cout" using the output operator « will appear on the screen. TIle name cout is 
pronounced "see·out" and is an abbreviation of "character output strerun." You'll 
find abbreviations rather common in programming. Naturally, an abbreviation 
can be a bit of a nuisance the first time you see it and have to remember it, but 
once you start using abbreviations repealedly, they become second nature, and 
they arc essential for keeping program text short and manageable. 
"nle end of that line 
II output HHcllo, World!" 
is a comment. Anything written after the token II (that's the character I, called 
"slash," twice) on a line is a comment. Comments are ignored by the compiler 
and writlen for the benefit of progrrunmers who read t.be code. Here, \ve lIsed the 
comment to tell you what the beginning of that line actually did. 
45 

46 
CHAPTER 2 • HEllO, WORLD! 
Comments arc wriucl1 to describe what lhc program is intended to do and in 
gcncrallo provide information useful for humans that can't be directly expressed 
in code. TIle person most likely to benefit from the comments in your code is 
you - when you come back to that code next week, or next year, and have for-
gotten exactly why you wrolC the code the way you did. So, document your pro-
grams well. In §7.6.4, we'll discuss what makes good comments. 
A program is wrincn for two audiences. Naturally, we write code for com-
puters to execute. However, we spend long hours reading and modifying the 
code. 'nms, programmers are another audience for programs. So, writing code is 
also a form of human-to-human communication. In fact, it makes sense to COIl-
sider the human readers of our code our primary audience: if they (we) don't 
fUld the code reasonably easy to understand, the code is unlikely to ever become 
correct. So, please don't forget: code is ror reading - do all you can to make it 
readable. Anyway, the commems arc for the benefit of human readers only; the 
computer doesn't look at me text in CQUUllenLS. 
The first line of the program is a typical comment; it simply tells the human 
reader what the program is supposed to do: 
I/This program outputs the mess..lgc "Hello, World ! ~ to the monitor 
Such comments arc useful because the code itself says what the program docs, 
not what we meant it to do. Also, we can usually explain (roughly) what a pro~ 
gram should do to a human much more concisely than we can express it (in de-
tail) in code to a computer. Often such a comment is the first part of the program 
we write. If nothing else, it reminds us what we are trying to do. 
llle next line 
#indude "std_lib_facilities.h" 
is an "#indude directive." It instnlcts the computer to makc available ("to in-
clude"') facilities from a file called sld_lib_facilities.h. We wrote lhal file to simplify 
lise of the facilities aVi.ilable in all implementations of C++ ("the C++ standard li-
brary"'). We will explain its contents as we go along. It is pcrfecLly ordinary stan· 
dard C++, but it coma.ins details that we'd ramer not bother you with for another 
dozen chapters. Fo r this program, the importance of stdJib_faci lities.h is that we 
make lhe standard C++ stream 110 facilities available. Here, we just usc the stan-
dard output stream, coul, and its output operator, « . A file included using 
#include usually has the surf!."< .h and is called a IleUM or a /teader file. A header 
contains definitions of terms, such as coul, thai we use in our program. 
How docs a compuler know where to Start executing a program? It looks for 
a function called main and starts executing the instmctions it finds there. Here is 
the function main of our "Hello, World!'" program: 

2. 2 
THE Cl ASS IC FIRST PROGRAM 
inl mainO II C++ programs start by executing the (unction main 
{ 
) 
coul« "Hello, World!\n"; 
/I output "Hello. World!" 
relurn 0; 
Every C++ program must have a function called main to tell it where to Start ex-
ecuting. A function is basically a named sequence of instructions fOT the COIll-
puter to execute in the order in which they are written. A function has four pans: 
A rellln! ty/N, here inl (meaning '"'integer"), which specifics what kind of 
result, if any, lhe function will return to whoever asked for it to be exe-
cuted. The word inl is a reserved word in C++ (a keyword), so inl cannot 
be used as the name of anything else (see §A.3.1). 
A name, here main. 
A parameter lisl enclosed in parentheses (sec §8.2 and §8.6), here () ; in this 
case, the parameter list is empty. 
Ajimdioll body enclosed in a set of "curly braces," {)t which lists the ac-
tions (called J/(I/ements) that the function is to pcrfornl. 
It follows that the minimal C++ program is simply 
inl mainO { } 
'Tlmt's not of much usc, though, bec.'\use it doesn't do anything. 111e mainO ("the 
main functionj of our "Hello, World!" program has two statements in its body: 
coul « "Hello, World!\n "; II output "Hello, World!" 
relurn 0; 
First it'll write Hello, World! to the screen, and then it will return a value 0 (zero) 
to whoever called it. Since mainO is called by "the system," we won't usc that re-
turn value. However, on some systems (notably UnixlLinux) it can be used to 
check whether the program succeeded. A zero (0) returned by mainO indicates 
the program tenninated successfully. 
A part of a C++ program that specifies an action and isn't an #include direc-
tive (or some other preprocessor directive; sec §4.4 and §A. 17) is called a Jlate1l/ent. 
2.3 Compilation 
C++ is a compiled language. "nlat means that to get a program to run, you must 
first translate it from the human-readable fonn to something a machine can 
47 

48 
CHAPTER 2 • HEllO, WO RL D! 
"understand." "That translation is done by a program called a rompiler. What you 
read and write is called source {(XU or program ltxl, and what the computer excelllcs 
is called executable, Qi!jeci~, or lIIachinc code. Typically C + + source code files are 
given the suffix .cpp (e.g., hello_world.cpp) or .h (as in stdJib_facilities.h), and 
object code files arc given Lhe SUfflX .obj (on Windows) or . 0 (Uni;I{). The plain 
word (ode is therefore ambiguous and can cause confusion; usc it with care only 
when it is obvious what's meant by it. Unless otherwise specified, we use c()(k to 
mean "source code" or even "the source code except the comments," oecause 
co mll1ents really aTC there just for us humans and are not seen by the compiler 
generating object code. 
I 
C++ source code I-
C++ compiler -
Object code 
"111C compiler rcads your source code and tries to make sense of what you wrote. 
h looks to sec if your program is grammatically correct, if every word has a de-
fined meaning, and if there is anything obviously wrong that can be detected 
without trying to actually execute the program. You'll find that computers arc 
rather picky about syntax. Leaving out any detail of our program, such as an 
#include file, a semicolon, or a curly brace, will cause errors. Similarly, the com-
piler has absolutcly zero tolerance for spelling mistakes. Let us illustrate this with 
a series of examples that each have a single small error. Each error is an example 
of a kind of mistake \\'c often make: 
/I no : include here 
int main{) 
( 
) 
cout « "He llo, World!\n"; 
return 0; 
We didn't include something to tell the compiler what cout was, so the compiler 
complains. 1b correct that, let's add a header file: 
#include "std_facilities.h" 
int mainO 
( 
) 
cout « "Hello, World !\n"; 
return 0; 

2.3 
COMPILATION 
Unfortunately, tllC compiler again complains: we misspelled sld_Iib_facilities.h. 
The compilcr also objects to this: 
#include "std_lib_facilities.h" 
int mainO 
( 
cout « "Hello, World!\n; 
return 0; 
We didn'ttenrunate lhe string with a n. The compiler also objects to this: 
#include "std_lib_facilities.h" 
integer mainO 
( 
) 
(out « "Hello, World!\nn; 
return 0; 
~nle abbreviation int is used in C++ rather than the word integer. The compiler 
doesn't like lhis either: 
#include "stdJib_facilities.h" 
inl mainO 
( 
(out < "Hello, World!\n"; 
return 0; 
We used < (the less-than operator) rather than « 
(the output operator). The 
compiler also objects to this: 
#include "std_lib_facilities.h" 
int mainO 
( 
) 
(out « 'Hello, World!\n'; 
return 0; 
We used single quotes rather than double quotes to delimit the string. Finally, the 
compiler gives an elTOr for this: 
49 

50 
#include "std_lib_facilities.h" 
inl mainO 
{ 
) 
coul « "Hello, World!\n" 
return 0; 
CHAPTER 2 • HElLO, WORLD! 
We forgol to terminate the output statement with a semicolon. Note that many 
C++ statements are terminated by a semicolon (;). The compiler needs those 
semicolons to know where olle statement ends and the next begins. "n Iere is no 
really short, fully correct, and nontechnical way of summarizing where semi-
colons arc needed. For now, just copy our patlern of usc, which can be summa-
rized as: "'Put a semicolon after every expression that doesn't end with a right 
curly brace (})." 
Why do we spend twO pages of good space and mil1Ules of your precious 
lime showing you examples of trivial errors in a trivial program? To make the 
point that YOli - like all programmers - will spend a lot of time looking for errors 
in program source text. Most of the time, we look at text with errors in it. After 
all, if we were convinced that some code was correct, we'd typic.1.lIy be looking at 
some other code or taking the time off. It came as a major surprise to the early 
computer pioneers that they were making mistakes and had to devote a m.yor 
portion of their time to finding them. It is still a surprise to most newcomers to 
programmmg. 
When you program, you'll gct quite annoyed with the compiler at limes. 
Sometimes it appears to complain about unimportant details (such as a missing 
semicolon) or about things you consider "obviously right.n However, the COIll' 
piler is usually right : when it gives an error message and refuses to produce ob-
ject code from yOllr source code, there is something not quite right with your 
program; that is, the meaning of what you wrote isn't precisely defined by the 
C++ standard. 
The compiler has no COIlUTIon sense (it isn't human) and is very picky about 
details. Since it has no common sense you wouldn't like it to try to guess what 
YOll meant by something that "looked OK" but didn't conform to the definition 
of C++. If it did and its guess was different from YOllrs, you could end up spend· 
ing a lot of time trying to figure out why the program didn't do what you thought 
yOLi had told it to do. When all is said and done, the compiler saves us from a lot 
of self-inflicted problems. It saves us from many more problems than it causes. 
So, please remember: the compiler is your friend; possibly, the compiler is the 
best friend yOll have when you program. 

2.4 
LI N KI NG 
2.4 Linking 
A program usually consists of several separate parts, often developed by difTerem 
people. For example, the "Hello, World!" program consists of the part we wrote 
plus pans of the C++ standard library. 111ese separate parts (sometimes called 
Inmslalioll 
III11~S) must be compiled and the resulting object code filcs must be 
linked together to fonn an executable program. The program that links such 
parts together is (unsurprisingly) called a linker: 
C++ source code: 
hello_world.cpp ~ 
C++ compiler 
Object code from the 
Object code: 
~ 
C++ standard library: 
hello_world.obj 
ostream.obj 
~ 
Linker / 
Executable program: ~ 
hello_world.exe 
Please note that object code and executablcs arc no/ portable among systems. For 
example. when you compile for a Windows machine, you get object code for 
Windows that will not run on a Linux machine. 
A library is simply some code - usually written by others - thaI we access 
using declarations found in an #included file. A d£c/aralion is a program statement 
specifying how a piece of code can be used; we'll examine declarations in detail 
b'e, (e.g., §4.5.2). 
EITOrs found by the compiler arc called {ompile-lime errors, errors fOllnd by the 
linker arc called IiIlR-lime errors, and errors not found until lhe program is run arc 
called nm-hme errors or logic em:nJ. Generally, compile-time errors arc easier to Ull-
derstand and fix than link-lime errors, and link-time errors arc of len easier to 
find and fix than nm-time errors and logic errors. In Chapter 5 we discuss errors 
and the ways of handling them in greater detail. 
51 

52 
( HAPTER 2 • H EllO, WORLD! 
2.5 Programming environments 
To program, we usc a programming language. \lVc also lISC a compiler to trans-
late ollr source code into object code and a linker to link Ollf object code into an 
executable program. In addition, we lISC some program to e nler OLlI' source code 
text into the computer and to edit it. lncsc arc just the first and most crucial 
tools that constitute ollr programmer's tool sct or "program development c!lvi-
ronmcnl.
n 
If you work from a command-line window, as many professional program· 
mers do, you will have to issue the compile and link conmlands yourself. tr in-
stead you lISC an IDE ("interactive development environment" or "integrated 
development environment"), as many professional programmers also do, a sim-
pic dick on the correct bulton will do the job. Sec Appendix D for a description 
of how to compile and link on your C++ implementation. 
IDEs usually include an editor with helpful features like color coding to help 
distinguish between comments, keywords, and Olher parts of your program 
source code, plus other facilities LO help you debug your code, compilc it, and nUl 
it. Debu{g7'ng is the activity of finding crrors in a program and removing them; 
you'll hear a lot about that along the way. 
In this book, we use Visual C++ from Microsoft as our example program 
development ellvironment. If we JUSt say "the compiler" or refer to parts of "the 
I DE," that's the system we are referring to. However, you can lise any system 
that provides an up-to-date. standards-conforming implementation of C++. Most 
of what we say will, with very minor modific..'ltions, be true for all implementa-
tions of C++, and lhe code will run everywhere. In oLir work, we Lise several dif-
ferelll implementations . 
....;' Drill 
So far we have talked about programming, code, and tools (such as compilers). 
Now YOll have to get a program to run. This is a crucial point in this book and in 
leanting to program. This is where you start to develop practical skills and good 
programming habits. The exercises for this chapter arc focused on gelting you ac-
quainted with your software development environment. Once you get the 
"Hello, World!" program to nm, you will have passed the first major milestone 
as a programmer. 
TIle purpose of a drill is to establish or reinforce your practical programming 
skills and give you experience wilh programming environment tools. Typic..-uly, a 
drill is a sequence of modifications to a single program, "growing" it from some-
thing completely trivial to something that might be a useful part of a real pro· 
gram. A traditional set of exercises is designed to tcst your initiative, cleverness, 
or invemiveness. In contrast, a drill requires little invention from YOll. Typically, 

CHAPTER 2 DRill 
sequencing is crucial, and each individual step should be easy (or even trivial). 
Please don't try to be clever and skip steps; on average that will slow you down 
or even confuse you. 
You might think you understand everything you read and everything your 
Memor or instructor told you, but repetition and practice arc necessary to de-
velop progranuning sltills. In this regard, programming is like athJctics, music, 
dance, or any skill-based craft. Imagine people trying to compete in any of those 
fields without regular practice. You know how well they would perform. Con-
stant practice - for professionals that means lifelong constant practice - is the 
only way to develop and maintain a high·level practical skill. 
So, never skip t.be drills, no matter how tempted you are; they arc essential to 
the learning process. Just start with the first step and proceed, testing each step as 
you go to make sure you arc doing it right. 
Don't be alarmed if you don't understand every detail of the syntax you are 
using, and don't be afraid to ask for hcJp from instructors or friends. Keep going, 
do all of the drills and many of the exercises, and all will become clear in due 
mile. 
So, here is your first drill: 
1. Go to Appendix D and follow the steps required to set up a project. Set 
up an empty, console C++ project called hello_world. 
2. 1")rpe in hello_world.cpp, exactly as specified below, save it in your prac-
tice directory, and include it in your hello_world project. 
#include "sld_lib_facililies.h" 
int mainO 
/I C-+--+- programs start by execuling the funClion main 
{ 
cout « "Hello, World!\n"; 1/ Oulrul "Hello, World!· 
keep_window_openO; 
1/ wail for a character to be entered 
return 0; 
111e call to keep_window_openO is needed on some Windows ma-
chines to prevent them from closing the window before you have a 
chance to read the output. This is a peculiarity/feature of Wmdows, nOt 
of C++. We defined keep_window_opeIlO in std_lib_racilities.h to sim-
plify writing simple text programs. 
How do YOll ftnd std_lib_racilities.h? If you are in a course, ask your 
instructor. If not, download it from our support site www.strowtrup.comf 
Programming. But what if you don't have an instructor and no access 
to the web? In that case (only), replace the #include directive with: 
#include<ioslream> 
#include<String> 
#include<vectoD 
53 ~ 

I .. 
#include<algorithm> 
#indude<cmath> 
using namespace sid; 
CHAPTER 2 • HellO, WORLD ! 
inline void keep_window_openO ( char Chi cin» chi ) 
TIlis uses the standard library directly, will keep you going until Chapter 5, 
and will be explained in detail later (§8.7). 
3. Compile and run the "Hello, World!" program. QyilC likely, something 
didn't work quite right h very rarely docs for a first attempt to use a 
new programming language or a new programming environment. Find 
the problem and fix it! lfiis is a point where asking for help from a morc 
experienced person is sensible, but be sure to understand what you are 
shown so that you can do it all by yourself before proceeding further. 
4. By now, you have probably encountered some errors and had LO correct 
them. Now is the time to get a bit better acquainted with YOUT compiler's 
error-detection and crror-reporting facilities! Try thc six crrors from §2.3 
to scc how your programming cnvironmcnt rcacts. ~nl ink of at least five 
more errors you might have made typing in your program (e.g., forget 
keep_window_openO, leave the Caps Lock key on while typing a word, 
or type a comma instead of a semicolon) and try each to see what hap-
pens when you try to compile and run those versions. 
Review 
The basic idea of these review questions is to give you a chance to see if you have 
noticcd and understood the key points of the chapter. You may have to fder back 
to the tcxt to answer a qucstion; that's nonnal and expectcd. You may have to 
reread wholc sections; that too is nonnal and expectcd. Howcver, if you have to 
reread thc wholc d lapter 01' have problems with every revicw question, you 
should consider whcther yOllr style of lcanung is effectivc. Arc you reading too 
fast? Should yOll SLOp and do some of dIe Try this suggestions? Should you study 
with a fricnd so dlat you can discuss problems with thc explanations in the text? 
l. What is the purpose of the "Hcllo, World!" program? 
2. Name the four pans of a function. 
3. Namc a function dlat must appear in cvery C++ program. 
4. In dIe "Hello, World!n program, what is thc purpose of dIe line return O;? 
5. \"'hat is the purpose of the compiler? 
6. What is dIe purpose of the #include directivc? 
7. \Vhat docs a .h suffix at the cnd of a rue nillIlC signify in C++? 
8. What docs the linker do for your program? 
9. What is the difference between a source file and an object file? 
10. What is an IDE and what docs it do for you? 
II . If you understand everything in the textbook, why is it necessary to 
practice? 

(HAPTER 2 EXERCISES 
Most review questions have a clear answer in the chaptcr in which they appear. 
Howevcr, we do occasionally include questions to remind you of relcvalll infor· 
mation from other chaptcrs and sometimes even relating to thc world outside this 
book. We consider that fair; there is more to writing good software and thinking 
about the implications of doing so than fits into an individual chapter or book. 
Terms 
TIlese terms present the basic vocabulary of programming and of C++. If you 
want to understand what people say about programming topics and to articulate 
your own ideas, you should know what each means. 
/I 
cxecutable 
mainO 
« 
function 
object code 
C++ 
header 
output 
comment 
IDE 
program 
compiler 
#include 
source corle 
compile·time error 
library 
statement 
cout 
linker 
You might like to gradually develop a glossary written in yOUT own words. You 
can do that by repeating exercise 4 below for each chapter. 
Exercises 
We list drills separatcly from exercises; always complete the chaptcr drill before 
anempting an exercise. Doing so \viU save you time. 
1. Change the program to output the twO lines 
Hello, programming! 
Here we go! 
2. Expanding on what you have learned, write a program that lists the in· 
structions for a computer LO find the upstairs bathroom, discussed in 
§2.1. Can you think of any more steps that a person would assume, but 
that a computer would not? Add them to your list. This is a good start in 
"thinking like a computer." Warning: For most people, "go to the bath-
room" is a perfectly adequate instruction. For someone with no experi-
ence with hOllses or bathrooms (imagine a stone-age person, somehow 
transported into your dining room) the list of necessary instructions 
could be very long. Plcase don't use more than a page. For the benefit of 
thc reader, you may add a short description of the layout of thc housc 
YOll are imagining. 
3. Write a description of how to gel from thc from door of your dorm room, 
apartment, house, whatever, to the door of your classroom (assuming you 
55 

CHAPTER 2 • HelLO, WORLD ! 
are attending some school; if you are nOt, pick another target). Have a 
friend try to follow the instructions and annotate them with improve-
ments as he or she goes along. To keep friends, it may be a good idea to 
"field lest" those instmctions before giving them to a friend. 
4. Find a good cookbook. Read the instmctions for baking blueberry 
muffins (if you are in a country where "blueberry muffins" is a strange, 
exotic dish, usc a more familiar dish instead). Please note that with a bit 
of help and instruction, most of the people in the world can bake deli· 
cious blueberry muffins. It is not considered advanced or difficuh fine 
cooking. However, for the author, few exercises in this book arc as diffi-
cult as this one. It is amazing what you can do with a bit of practice. 
Rewrite those instmctions so that each individual action is in its own 
numbered paragraph. Be careful to list all ingredients and aU kitchen 
utensils used at each step. Be careful about crucial details, such as 
the desired oven temperature, preheating the oven, the preparation 
of the baking sheet, the way to time the cooking, and the need to 
protect your hands when removing the mufTins from the oven. 
Consider those instmctions from the point of view of a cooking 
novice (if you arc not one, get help from a friend who docs not know 
how to cook). Fill in the steps that the book's author (almost cer· 
tainly an experienced cook) left out for being obvious. 
Build a glossary of terms used. (\'\'hat's a muffin pan? What docs 
preheat do? What do you mean by "oven"?) 
Now bake some muffins and enjoy your results. 
5. Write a definition for each of the terms from "Tenus." First cry to sec if you 
c."ln do it without looking at the chapter (not likely), lhen look through the 
chapter to ftnd defmitions. You might find the difference between your first 
attempt and the book's version interesting. You might consult some suit-
able online glossary, such as w\V\v.rcsearch.att.comJ-bs/glossary.html. By 
writing your own defmition before looking it up, you reinforce the learning 
you achieved through your reading. If you have to reread a section to form 
a definition, that just helps you to understand. Feel free to usc your own 
words for the definitions, and make the definitions as detailed as you think 
reasonable. Often, an example after the main definition will be helpful. You 
may like to store the definitions in a file so thm you c.'ln add to them [rom 
the "Tenus" sections oflater dlapters. 

CHAPTER 2 PO STSCRIPT 
Postscript 
What's so important about the "HeUo, World !" program? Its purpose is to get us 
acquainted with the basic tools of programming. We tend to do an extremely 
simple example, such as "Hello, World!," whenever we approach a new tool. 
That way, we separate our learning into two parts: first we learn the basics of our 
tools with a trivial program, and later we learn about marc complicated pro-
grams without being distracted by our tools. Lcaming the tools and the language 
simultaneously is far harder than doing first one and then the other. This ap-
proach to simplifying leaming a complex task by breaking it into a series of small 
(and more manageable) steps is not limited to programming and computers. It is 
common and useful in most areas of life, especially in those that involve some 
practical skill. 
57 


1-
r 
3 
Objects, Types, and Values 
"Fortune favors the prepared mind." 
- louis Pasleur 
T
his chapter illlroduces the basics of sLOring and using data 
in a program . To do so, we first conCClllratc on reading in 
data from the keyboard. After establishing me fundamental no-
tions of objects, types, values, and variables, we introduce several 
operators and give many examples of usc of variables of types 
char, int, double, and string. 
59 

60 
CHAPTE R 3 • OBJECTS, TYPE S, AND VALUES 
3.1 Input 
J.2 Variables 
3.3 Input and type 
3.4 Operations and operators 
J.S Assignment and initialization 
3.S.1 An eumple: delete repeated 
words 
3.1 Input 
3.6 Composite assignment operators 
1.6.1 An e.u.mple: count repealed words 
3.7 Names 
3.8 Types and objects 
3.9 Type safety 
3.9.1 Safe conversions 
3.9.2 Unsafe conversions 
The "Hello, World!" program just writes to the screen. h produces Olltpul. It 
docs not read anything; it does not get input from its lIscr. llmt's rather a bore. 
Real programs lcnd to produce results based on some input we give .. hem, rather 
than just doing the same thing each time we execute them. 
To read something, we need somewhere to read into; that is, we need some-
where in the computer's memory to place what we read. We call such a "place" 
an object. An object is a region of memory with a type that specifics what kind of 
information can be placed in il. A named object is called a uariable. For example, 
character strings are put mto string variables and integers are put into inl vari-
ables. You can think of an object as a "box" into which you can put a value of the 
object's type: 
inl: 
age: I 
42 
This would represent an object of lype inl named age containing the integer 
value 42. Using a string variable, we can read a string from input and \vnte it out 
again like this: 
II read and write a fi rst n,1me 
#include "sld_lib_facililies.h" 
int mainO 
{ 
cout « "Please enter your first name (followed by 'enter'):\n"; 
string firsCname; 
/I first_name is a variablc of typc string 
cin » first_name; 
/I read characters into firs,-narnc 
cout « "Hello, "« firsCname« "!\n"; 
} 

].1 
INPUT 
The #include and the mainO are familiar fr0111 Chapter 2. Since the #include is 
needed for all our programs (up to Chapter 12), we'll leave it out of our presen-
tation to avoid distraction. Similarly, we'll sometimes present code that will work 
only if it is placed in main() or some other function by itself, like this: 
cout « "Please enter your first name (followed by 'enler'):\n"; 
'We assume that you can figure out how to put such code into a complete pro-
gram for tcsting. 
111e first line of mainO simply writes out a message encouraging the lIser to 
emer a first name. Such a message is typically called a prompt because it prompts 
lhe user to take an action. 111e next lines define a variable of type string c.'llled 
firs,-name, read input from the keyboard into that variable, and write out a 
greeting. Let's look at those three lines in turn: 
string firsCname; 1/ first_name is a variable of type string 
l 1lis sets aside an area of memory for holding a string of characters and gives it 
the name first_name: 
siring: 
firs,-name: I '------' 
A statement that introduces a new name into a program and sets aside memory 
for a variable is c.1.lled a dqinitiou. 
"n e next line reads characters from input (the keyboard) into that variable: 
dn »first_name; 1/ read characters into name 
"111e name dn refers to the standard input stream (pronounced "sec-in," for 
"character input") defined in the standard library. 111e second operand of the » 
operator ("get from") specifics where that input goes. So, if we type some first 
name, say Nicholas, followed by a newline, the string "Nicholas" becomes the 
value of first_name: 
siring: 
firs,-name: I Nicholas I 
111e newline is necessary to get the machine's attention. Until a newline is ell-
tered (the Enter key is hit), the computer simply collects characters. 11ml "delay" 
gives you the chance to change your mind, crase some characters, and replace 
61 

.2 
CHAPTER 3 • OB JECTS, TY PES, AND VALUES 
them with others before hitting Enter. The newline will not be part of lhe string 
stored in memory. 
Having gotten the input string into firsCname, we can usc it: 
coul « "Hello,"« firsCname « "!\n"; 
This prints Hello, followed by Nicholas (the value of firsC name) followed by ! 
and a newline ('\n') on the screen: 
Hello, Nicholas! 
If we had liked repetition and extra typing, we could have written three separate 
alilpUl statements instead: 
cout « "Hello, It ; 
coul « fi,sCnamc; 
cout «"!\n"; 
However, we arc indifferent typists, and - morc importantly - strongly dislike 
needless repetition (because repetition provides opportunity for errors), so we 
combined those three output operations into a single statement. 
Note the way we usc quotes around the characters in "Hello, " but not in 
rirst_name. We usc quotes when we want a literal string. When we don't quote, 
we rerer to lhe value or something with a name. Consider: 
cout « "first_name" « 
M is " «first_name; 
Here, "first_name " gives us the ten characters firscname and plain firsc name 
hrives us the value or the variable firsCname, in this case, Nicholas. So, we get 
first_name is Nicholas 
3.2 Variables 
Basically, we can do nothing or interest with a computer without slOring data in 
memory, the way we did it with the input string in the example above. ~11 1e 
"places" in which we store data are called oldectJ. 1'0 access an object we need a 
lIome. A named object is called a variable and has a specific IyJM (such as inl or 
string) that determines what can be put into the object (e.g., 123 can go into an 
int and "Hello, World!\n" e'111 go illlo a siring) and which operations can be ap' 
plied (e.g., we can multiply inls using the · operator and compare strings lIsing 
the <= operator). The data itellls we put into variables arc called vallleJ. A smte-

3. 2 
VAR IABLES 
melll that defines a variable is (unsurprisingly) called a dejillitiQTl, and a dermition 
can (and usually should) provide an initial value. Consider 
string name = "Annemarie"; 
int numbe r_oCsteps = 39; 
You can visualize these variables like this; 
int; 
string; 
numbe r_oCste ps; 
39 
name ; I Annemarie I 
You cannot pul values of the wrong type into a variable; 
string name2 = 39; 
/I error: 39 isn't a string 
int number_oCsteps = "Annemarie"; 
/I error: "Anne marie'" is not an int 
~nle compiler remembers the type of each variable and makes sure that you use 
it according to its type, as specified in its definition. 
C++ provides a rather large number Of lype5 (sec §A.8). However, yOLl can 
write pelfecl1y good progrruns using only five of those: 
int numbe,_oCsteps = 39; 
double flyin&-time = 3.5; 
char decimal_point = '. '; 
string name = "Annemarie"; 
bool tap_on = true; 
/I int for integers 
/I double for floating-point numbers 
/I char for individual characters 
/I string for character strings 
/I bool for logical variables 
TIle reason for the name double is historical: double is short fo r "double-
precision floating point." Floating point is the computer's approximation to the 
mathematical concept of a real number. 
Note I1mt each of these types has its own characteristic style of literals: 
39 
3.5 
" 
"Annema,ie n 
Clue 
/I int: an integer 
II double: a floating-point number 
II char: an individual character enclosed in single quotes 
II sIring: a sequence of characters delimited by double quotes 
/I bool: either true or false 
That is, a sequence of digits (such as 1234, 2, or 976) denotes an integer, a single 
character in single quotes (such as '1', '@', or 'x') denotes a character, a sequence 
of digits with a decimal point (such as 1.234, 0_12, or _98) denotes a floating-point 
value, and a sequence of characters enclosed in double quotes (such as "1234", 
"Howdy! ", or "Annemarie") denotes a string. For a detailed description of literals 
see §A.2. 
63 

64 
CHAPTER 3 • OBJECTS, TYPES. AND VALUES 
3.3 Input and type 
The input operation » ("gel from") is sensitive to type; that is, it reads according 
to the type of variable you read into. For example: 
/I read name and age 
int mainO 
{ 
coul « "Please enter your first name and age\n"; 
string first_name; 
II string variable 
int age; 
1/ integer variable 
cin » firsCnamc; 
II rcad a string 
cin »
agc; 
/I read aI' ir,tcgcr 
coul« "Hello, " «firsCname « " (age " «
age « ")\n"; 
) 
So, if you type in Carlos 22 the » operator will read Carlos into firsCname, 22 
into age, and produce this output: 
Hello, Carlos (age 22) 
Why won't it read (all of) Carlos 22 into firsC name? Because, by convention, 
reading of strings is terminated by what is called whikspace, that is, space, newline, 
and lab characters. Othenvise, whitespace by default is ignored by » . For exam-
ple, you can add as many spaces as you like before a number to be read; » will 
just skip past them and read the number. 
Ir you type in 22 Carlos, you'll see something that might be surprising until 
you think about it. The 22 will be read into firsCname because, after all, 22 is a 
sequence of characters. On the other hand, Carlos isn't an integer, so it will not 
be read. 111e output will be 22 followed by some random number, such as -%739 
or o. Why? You didn't give age an initial value and you didn't succeed in reading 
a value imo it. Therefore, you get some "garbage value" that happened to be in 
that part of memory when you started executing. In §10.6, we look at ways to 
handle "input fonnat errors." For now, let's just initialize age so that we get a pre-
dictable value if the input fails: 
/I read name and age (2nd version) 
int mainO 
{ 
cout « "Please enter your fi rst_name and age\n"; 

J .J 
IN I)UT AND TYPE 
) 
string firscname = "???"; II string variable 
II (U???'" means Ndon'( know the nameN) 
int age = - 1; 
II inleger variable (- 1 means Ndon', know the age") 
cin » firsCname» age; 
II read a string follO\ved by an integer 
cout « "Hello,"« firsCname«" (age"« age« ")\n "; 
Now the input 22 Carlos will output 
Hello 22 (age -1) 
Note thm we can rcad several values in a single input statement,just as we can write 
several values in a single output statement. Note also thm « is sensitive to type, just 
as » is, so we can output the int variable age and the character literal '\n' as weU as 
the string variable firscname and the string literals "Hello, " and " (age ". 
A string read using » 
is (by default) lerminaLCd by whitespace; that is, it 
reads a single word. But sometimes, we want to read more than one word. 111ere 
arc of course many ways of doing this. For example, we can read a name consist-
ing of two words like this: 
int main() 
( 
) 
cout « "Please enter your first and second names\n"; 
string fi rst; 
Siring second; 
cin »
firsl » second; 
/I read two strings 
coul « "Hello, " «first « ' '« second « '\n'; 
We simply used » twice, once for each name. When we want LO write the names 
to output we must insen a space between them. 
TRY THIS 
Get the "name and age" example to run. Then, modify it to write out the age 
in months: read the input in years and multiply (using the · operaLOr) by 12. 
Read U1C age into a double to allow for children who can be very proud of 
being 5.5 years old rather than just 5. 
65 

66 
CHAPTER 3 • OBJECTS, TYPE S, AND VALUES 
3.4 Operations and operators 
In addition La specirying what values can be stored in a variable, the type or a 
variable detcnnincs what operations we can apply to it and what they mean. For 
example: 
int count; 
cin »count; 
string name; 
d n » name; 
int c2 = count+2; 
string 52 = name +" Jr. "; 
int c3 = count-2; 
string 53 = name - "Jr. "; 
1/ » reads an integer into count 
1/ » reads a string inlo name 
/I + .. dds integers 
/I + appends characters 
1/ - subtracts integers 
/I error: - isn't defined for strings 
By "error" we mean that the compiler will reject a program trying LO subtract 
strings. The compiler knows exactly which operations can be applied to each vari-
able and can therefore prevent many mistakes. However, lhe compiler doesn't 
know which operations make sense to you for which vaJues, so it will happily ac-
cept legal operations that yield results that may look absurd LO you. For example: 
int age = - 100; 
It may be obvious to you that you can't have a negative age (why not?) but no-
body told the compiler, so it'll produce code for that definition. 
Here is a table of useful operators for some common and useful types: 
assignment 
addition 
concatenation 
subtraction 
multiplication 
division 
remainder (modulo) 
increment by 1 
decrement by 1 
increment by n 
bool 
= 
char 
= 
int 
= 
+ 
• 
I 
% 
++ 
+= n 
double 
string 
= 
= 
+ 
+ 
• 
I 
++ 
+= n 

3.4 
O PERATIO NS AND O PE RATOR S 
boo! 
char 
int 
double 
siring 
add 10 end 
+= 
decremenl by n 
- = n 
- = n 
multiply and assign 
"= 
"= 
divide and assign 
1= 
1= 
remainder and assign 
%= 
read from s into x 
s »
x 
s »
x 
s »
x 
s »
x 
s »
x 
wrile x 10 s 
s «
x 
s«x 
s «
x 
s«
x 
s «
x 
equals 
== 
== 
== 
== 
== 
not equal 
!= 
!= 
!= 
!= 
!= 
greater than 
> 
> 
> 
> 
> 
greater than or equal 
>= 
>= 
>= 
>= 
>= 
less than 
< 
< 
< 
< 
< 
less than or equal 
<= 
<= 
<= 
<= 
<= 
A blank square indicates that an operation is not dirccliy available for a lype 
(dlOugh there may bc indirect ways of using that operation; see §3.7), We'll ex-
plain these operations, and more, as we go along. The key points here are lIlal 
there are a lot of useful operators and that their meaning tends to be the same for 
similar lypeS. 
Let's try an example involving floating·point numbers: 
/I simple program 10 exercise operators 
int mainO 
{ 
) 
coul « "Please e nter a floating-point value: It; 
double n; 
cin » n; 
caul «"n == "« n 
«''\on+1 == " « n+1 
« ''\othree times n == " «
3*n 
« "\ntwice n == " « n+n 
«
"\nn squared == "« n· n 
« ''\ohalf of n == " « 
nf1 
«"\nsquare root of n == " «sqrt(n) 
«endl; 
II another name for newline ("end of line") 
Obviously, the usual arithmetic operations have their usual notauon and mean-
ing as we know them from primary school. Natura1ly, nOl everythillg we might 
.7 

.. 
CHAPTER 3 • O BJEC TS, TYPES, ANO VAL U ES 
want to do to a noating-point number, such as taking iLS square root, is available 
as an operaLOr. Many operations are represcmcd as named functions. In this case, 
we usc sqrtO from the standard library to gCllhc square roOt of n: sqrl(n). TIle 
notation is familiar from math. We'll lISC functions along the way and discuss 
them in some dcwil in §4.5 and §B.S. 
TRY THIS 
Get this little program to run. Then, modify it to read an int rather than a 
double. Note that sqrtO is nO[ dermed for an int so assign n to a double and 
take sqrlO of that. Also, "exercise" some other operations. NOte lhal for ints I 
is integer division and % is remainder (moduJo), so that 512 is 2 (and nOt 2.5 
or 3) and 5%2 is 1. The definitions of integer · , I, and % guarantee that for 
two positive ints a and b we have alb • b + a%b == a. 
Strings have rewer operators, bUl as we'll see in Chapter 23, they have plenty or 
named operations. However, the opcrdtors they do have can be used convention-
ally. For example: 
/I read first and second name 
int mainO 
{ 
) 
cout « "Please enter your first and second names\n": 
string first; 
string second; 
d n » first » second; 
siring name = first + ' , + second; 
cout « "Hello, "« name« '\n'; 
/I read Iwo strings 
/1 concatenate strings 
For strings + means concatenation; that is, when sl and s2 arc strings, sl +s2 is a 
string where the characters rrom sl arc rollowed by the characters rrom s2. For 
example, ir sl has the value "Hello" and s2 the value "World" then sl +s2 will 
have the value "HelioWorld", Comparison or strings is particularly userul: 
II read and compare names 
int mainO 
{ 
coul « "Please enter two names\n"; 
siring first; 
string second: 
cin » first » second; 
/I read two strings 
if (first == second) cout « "that's the same name twice\n"; 

3.5 
A SSICNMENT AND INITIALIZATION 
if (first < second) 
cout « first«" is alphabetically before " « second «'\n': 
if (first > second) 
cout « first« " is alphabetically after " «second «'\n': 
) 
Here, we used an if-statement, which will be explained in detail in §4.4.1.1, to se· 
lect actions based on conditions. 
3.5 Assignment and initialization 
In many ways, me most interesting operator is assignment, represel1led as =. It 
gives a variable a new value. For example: 
inta=3: 
/I a starts out with the value 3 
a: 
3 
a = 4: 
/I a gets the value 4 ("becomes 4") 
"' I 
4 
intb=a; 
/I b Slarts oul wilh a copy of a's value (that is, 4) 
a: 
4 
b: 
4 
b = a+5: 
/I b gets the value a+5 (that is, 9) 
a: 
4 
b: 
9 
a = a+7; 
/I a gelS the value a+7 (thai is, 11) 
a: 
11 
b: 
9 
11mt last assignment deserves notice. First or all it clearly shows that = does not 
mean equals - clearly, a doesn't equal a+7. It means assignmelll, that is, to place 
a new value in a variable. What is done ror a=a+7 is the rollowing: 
I. First, get the value of a; that's the integer 4. 
2. Next, add 7 to that 4, yielding the illlegcr II . 
3. Finally, put that II into a. 
•• 

70 
CHAPTE R 3 • OBJECTS, TYPES, AND VALUES 
"Ve can also illustrate assignments using strings: 
siring a = "alpha"; 
/I a starts oul with the value u alpha ~ 
a: I alpha 
a = "bela"; 
/I a gets the value " beta ~ (becomes ~ beta" ) 
a: I beta 
siring b = a; 
1/ b starts out with a copy of a's value (that is, "bela") 
a: 
bela 
b: 
bela 
b = a+"gamman ; 
II b gets the value a+"gamma" (that is, "bctagamma") 
a: 
bela 
b: 
belagamma 
a = a+"delta"; 
/I a gels the value a+"dclta" (that is, "betadclta") 
a: 
betadelta 
b: 
betagamma 
Above, we usc "starts oU( with" and "geLS" to distinguish twO similar, but logi-
cally distinct, operations: 
Initialization (giving a variable its initial value) 
Assignment (giving a variable a new value) 
These operations arc so similar lhat C++ allows us to usc the same notation (the 
=) fOT both: 
inty = 8; 
)( = 9; 
string t = "howdy! " ; 
s = "G'day"; 
/I initialize y with 8 
/I assign 9 to x 
/I initialize I with "howdy!~ 
II assign "G'dayN to s 
However, logically assignment and initialization are different. You can tcllthe two 
apart by the type specification (like inl or siring) that always starts an initializa-
tion; an assignment does not have mal. In principle, an initialization always finds 

3 .5 
ASSIGNMENT AND IN ITI ALIZATION 
the variable empty. On the other hand, an assigmnent (in principle) must clear 
out the old value from the variable before puuing in the new value. You can 
think of the variable as a kind of small box and the value as a concTCte thing, 
such as a coin, that you put into it. Before initialization, the box is empty, but 
after initialization it always holds a coin so that to put a new coin in, you (i.e., the 
assignment operator) first have to remove the old one ("destroy the old value") -
and you cannot leave the box empty. Things are not quite this literal in the com-
puter's memory, but it's not a bad way of thinking of what's going on. 
3.5.1 An example: delete repeated words 
Assignment is needed when we want to put a new value into an object. When 
you think of it, it is obvious that assignment is most useful when you do things 
many limcs. \lVe need an assignment when we want to do something again with a 
different value. Let's have a look at a little program that detects adjacent repeated 
words in a sequence of words. Such code is part of most grammar checkers: 
inl mainO 
{ 
Siring previous =" "; 
II previous word; initialized to Hnot a word" 
string curre nt; 
/I currenl word 
while (cin>>eurrenl) { 
/I read a stream of words 
if (previous == curre nt) 
II check if the word is the same as lasl 
cout « "repeated word : "« current « '\n'; 
previous = current; 
) 
This program is not the most helpful since it doesn't tell where the repeated word 
occurred in the text, but it'U do for now. We will look at this program line by line 
starting with 
siring Current; 
/I current word 
11lis is the string variable into which we inunediatcly read the current (i.e., most 
recently read) word using 
while (cin>>eurre nt) 
-Ibis ConSlnlct, called a while-st.1.tement, is interesting i.n its own right, and we'U ex-
ami.ne it further in §4.4.2.1. '11e while says that t.he statement after (cin»curre nt) 
is to be repealed as long as the input operation cin>>eurre nt succeeds, and 
cin»current will succeed as long as there are characters to read on the st.andard 
71 

72 
( HAPTER 3 • O BJECTS, TYPES. ANO VAL UES 
input. Remember that for a string, » reads whitespace-scparatcd words. You ter-
minate this loop by giving the program an end-oC-input character (usually referred 
to as end "file). On a Windows machine, lhat's Ctrl+Z (Control and Z pressed to-
gether) foUowoo by an Enter (return). On a Unix or Linux machine that's CLTl+D 
(Control and D pressed lOgether). 
So, what we do is to read a word into current and men compare it to the pre-
vious word (stored in previous). U they aTC the same, we say so: 
if (previous == current) 
II check if the word is the same as last 
cout « "repeated word: "« current « '\n'; 
111cn we have to get ready to do this again for the next word. We do that by 
copying the cune nt word into previous: 
previous = currenti 
This handles all cases provided that we can get started. 'What should this code do 
for the first word where we have no previous word to compare? 111is problem is 
dealt with by the definition of previous: 
string previous =" "; 
/I previous word; ini tialized to "not a word" 
·nle " " contains only a single character (the space character, the one we get by 
hitting the space bar on our keyboard). Tbe input operator » skips whitespace, 
so we couldn't possibly read that from inpul. 111crcfore, the first time through 
the while-statement, the test 
if (previous == current) 
fails (as we wam it to). 
One way of understanding program now is to "play computer," that is, to fol-
low the program line for line, doing what it specifies. Just draw boxes on a piece 
of paper and write their values into them. Change the values stored as specified 
by the program. 
TRY THIS 
Execute this program yourself using a piece of paper. Use the input "The cat cat 
jumped". Even experienced programmers use this technique to visualize the ac-
tions of small sections of code that somehow don't seem completely obvious. 

1.6 
COMPOSITE ASSIGNMENT OPERATORS 
TRY THI S 
Get the "repeated word detection program" to run. Test it with the sentence 
"She she laughed He He He because what he did did nol look very very 
good good". How many repeated words were there? Why? "What is the defi-
nition of word used here? What is the definition of repealed word? (For exam-
ple, is "She she" a repetition?) 
3.6 Composite assignment operators 
incrementing a variable (that is, adding I to it) is so common in programs that 
C++ provides a special syntax for it. For example: 
++counler 
means 
counler = counler + 1 
lllerc are many other common ways of changing lhe value of a variable based on 
its currem value. For example, we mighllike to add 7 to it, to sublract 9, or to mul-
tiply it by 2. SUdl operations are also supported directly by C++. For example: 
a += 7; 
b-=9; 
c 0= 2; 
/1 means a = <1+7 
/I means b == b-9 
/I means c == c·2 
In general, for any binary operator oper, a oper= b means a = a oper b (§A.5). 
For starters, thal rule gives us operators +=, -=, °=,1=, and %=. This provides a 
pleasantly compact notation that directly reflects our ideas. For example, in Illany 
application dOlllains 1= and %= are rderred to as "scaling." 
3.6.1 An example: count repeated words 
Consider the example detecting repeated adjacent words above. We could im-
prove that by giving an idea of where the repeated word was in the sequence. A 
simple variation of that idea simply counts the words and outputs the count for 
the repeated word: 
inl mainO 
{ 
73 

74 
) 
CHAPTER 3 • OBJECTS, TYPES, ANO VALUES 
inl number_oCwords = OJ 
string previous = .. "; 
1/ nol a word 
Siring current; 
while (cin»current) { 
) 
++number_oCwords; 
/1 increase word count 
if (previous == currenl) 
coul« "word number n «
number_oCwords 
«" repeated: "« current « '\n'; 
previous = current; 
We start our word counter at O. Each time we sec a word, we increment that 
counter: 
111al way, the first word becomes number 1, the next number 2, and so on. We 
could have accomplished the same by saying 
number_oCwords += 1: 
or even 
but ++nurnber_oCwords is shorter and exprcsses the idea of incrementing directly. 
NOle how similar this program is to the Olle from §3.5.1. O bviously, we juSt 
took the program from §3.5.1 and modified it a bit to serve our new purpose. 
That's a very common technique: when we need to solve a problem, we look for 
a similar problem and use our solution for that with suitable modification. Don't 
start from scratch unless you really have to. Using a previous version of a pro-
gram as a base for modification often saves a lot of lime, and we benefit from 
much of the effort that went into lhe original progr,un. 
3.7 Names 
We name our variables so that we can remember them and refer to them from 
olher parts of a program. What can be a name in C++? In a C++ program, a 
name starts with a letter and contains only letters, digits, and underscores. For 
example: 

3 .7 
NAMES 
, 
number_oCelements 
fourier_transform 
z2 
Polygon 
Tne following arc not names: 
2, 
limeSloSmarkel 
Starl menu 
II a name must start with a leUer 
/I S is not a leiter, digit. or underscore 
/I space is not a letter, digit, or underscore 
When we say M not names" we mean that a C++ compiler will nOt accept them as 
names. 
If you read system code or machine-generated code, you might sec names 
starting with underscores, such as _foo. 
ever write those yourself; such names 
arc reserved for implementation and system entities. By avoiding leading under-
scores, yOll will never find your names d ashing with some name tJ13t the imple-
mentation generated. 
Nallles are case sensitive; that is, uppercase and lowercase leiters arc distinct, 
so x and X arc different names.1l1is liltle program has at least four errors: 
#include "std_lib_faci lities.h" 
int MainO 
( 
} 
String s = "Coodbye, cruel world ! "; 
cOut « S « '\n'i 
It is usually not a good idea to define names that differ only in the case of a char· 
acter, such as one and One; that will not confuse a compiler, but it call easily 
confuse a programmer. 
TRY THIS 
Compile tJle "Goodbye, crucl world!" program and examine the error mes-
sages. Did the compiler rllld all the errors? What did it suggest as the prob-
lems? Did the compiler get confused and diagnose more tJtan four errors? 
Remove the errors one by one, Starting with tJle lexically first, and see how 
the error messages change (and improve). 
75 

76 
(HAPTER J • OBJECTS, TY P ES , AND VALUES 
The C++ language reserves many (about 70) names as "keywords." We list them 
in §A.3. 1. You can't usc those to name your variables, types, functions, etc. For 
CXillllplc: 
int if=7; 
II error: "if" is a keyword 
You can usc names of facilities in the standard library, such as string, but you 
shouldn't. Reuse of such a common name will calise trouble if YOli should ever 
wam to lise the standard library: 
int string = 7; 
1/ this will lead 10 trouble 
When you choose names for your variables, functions, types, etc" choose mean-
ingful names; that is, choose names that will help people understand )'Qur pro-
gram. Even you will have problems understanding what your program is 
supposed to do if you have liucTed it with variables with "casy to type" names 
like xl , x2, s3, and p7. Abbreviations and acronyms can confuse people, so usc 
them sparingly. "nlCSC acronyms wcre obvious to us when we wrote them, but we 
expect you'll havc trouble with at Icast one; 
mtbf 
TLA 
myw 
N8V 
"Ve c..xpect that in a few months, we'll also have trouble with at least one. 
Short names, such as x and i, arc meaningful when used conventionally; limt 
is, x should be a local variablc or a parameter (sec §4.5 and §8.4) and i should bc 
a loop index (see §4.4.2.3). 
Don't use overly long names; thcy arc hard to typc, makc lines so long that 
thcy don't fit on a screcn, and are hard to read quickly. These are probably OK: 
partiaCsum 
element_count 
stable_partition 
111cse are probably too long: 
the _ n umber_of _ elemen ts 
re mainin~free_s lots_ jn_symboU abl e 
Our "hollse style" is to use underscores to separate words in an identifier, such as 
element_count, rather than alternatives, such as elementCounl and Element-
Count. We never use names with all capital lelters, such as Al l _CAPITAl_lmERS, 

J .8 
TYPES AND OBJECTS 
because that's conventionally reserved for macros (§27.8 and §A.17.2), which we 
avoid. "Ve use an initial capital letter for types we define, such as Square and 
Graph. "111e C++ language and standard library don't use capitaileueTS, so it's inl 
rather than Inl and siring rather than Siring. TIlUS, our convention helps to mini· 
mize confusion between our types and the standard ones. 
Avoid names that are easy to mistype, misread, or confuse. For example: 
Name 
foo 
f1 
names 
fOIl 
fI 
nameS 
fI 
r; 
111e characters 0, 0, 0 , 1, I, I arc particularly prone to cause trouble. 
3.8 Types and objects 
TIle notion of type is central to C++ and most other programming languages. 
Let's take a closer and slightly more technica1 look at types, specifically at the 
types of the objects in which we store alii" data during computation. h 'U save time 
in the long nm, and it may save you some confusion. 
A l)1Je defines a set of possible values and a SCI of operations (for an object). 
An object is some memory that holds a value of a given type. 
A ualue is a set of bits in melllory interpreted according to a type. 
A variable is a named object. 
A dedaral;oll is a statement that gives a name to an object. 
A tkjimJioll is a declaration umt sets aside memory for an object. 
Infonnally, we think of an object as a box into which we can put values of a given 
type. An int box can hold integers, sllch as 7, 42, and -399. A siring box can hold 
character string values, sllch as "lnleroJ>erabilily", "tokens: !@#S%A&. ", and 
"Old McDonald had a farm ". Graphically, we can think of it like this: 
inl a = 7; 
., 
7 
intb =9; 
b, 
9 
char c = 'a'; 
c, ~ 
double x = 1.2; 
" I 
1.2 
string s1 = "Hello, World! "; 
51 : I 
13 
Hello, World! 
Siring 52 = "1.2"; 
s2: 
3 
1.2 
n 

78 
CHAPTER 3 • OBJECTS, TYPES, AND VAL U ES 
The representation of a string is a bit more complicated than that of an int be-
cause a string keeps track of the number of characters it holds. Note that a 
double stores a number whereas a string stores characLCrs. For example, x Slores 
the number 1.2, whereas 52 Slores the three characters '1', '.', and '2'.'llC quotes 
for charaCler and string literals are not slared. 
Every int is of the saUle size; that is, the compiler sets aside the same fixed 
amount of memory for each lnt On a typical desktOp computer, that amount is 4 
bytes (32 bits). Similarly, bools, chars, and doubles arc fixed size. You'll typically 
find that a desktop computer lISCS a byte (8 bits) for a bool or a char and 8 bytes 
for a double. Note that different types of objeclS take up different amounts of 
space. In particular, a char takes up less space than an int, and string differs from 
double, int, and char in that different strings take up different amounts of space. 
The meaning of bits in memory is completely dependent on the type used to 
access it. illink of it tltis way: computer memory doesn't know about our types; 
it's just memory. TIle bits of memory gel meaning only when we decide how thm 
memory is to be illlerpreted. 111is is similar to what we do every day when we usc 
numbers. What docs 12.5 mean? We don't know. It could be 512.5 or 12.5cm or 
12.5gallons. Only when we supply the unit docs the Ilotation 12.5 mean anything. 
For example, the very same bits of memory that represent the value 120 when 
looked upon as an int would be 'x' when looked upon as a char. Iflooked at as a 
string, it wouldn't make sense at all and would become a run·time error if we tried 
to usc it. We can illustrate this graphically like this, using I and 0 to indicate the 
value of bits in memory: 
I OOOOOOOO OOOOOOOO OOOOOOOO 01111000 I 
~I11is is lhe selting of the bits of an area of memory (a word) that could be read as 
an int (120) or as a char ('x', looking at the rightmost 8 bits only). A bit is a unit 
of computer memory that c.'l.n hold the value 0 or I. For the meaning of billmy 
numbers, see §A.2.I.l. 
3.9 Type safety 
Every object is given a type when it is defined. A program - or a part of a pro· 
gram - is type-safe when objects arc used only according to the rules for their 
type. Unfortunately, there arc ways of doing operations 111m arc not type-safe. For 
example, using a variable before it has been initialized is not considered type-safe: 
int mainO 
{ 
double x; 
II we Uforgot .... to initialize: 
If the value of x is undefined 

3 .9 
TYPE SAFETY 
double y = X; 
double l = 2.0+x; 
/I the value of y is undefined 
/I the meaning of + and the value of z are undefined 
An implementation is even allowed to give a hardware error when the uninitiaJiz.cd 
X is used. Always initialize your variables! 'n lere arc a few - very few - exceptions 
to this rule, such as a variable we inunediatcly use as the target of an input opera-
tion. but aJways to initialize is a good habit that'U save you a lot of grief. 
Complete ty pe safety is the ideal and therefore the general rule for the lan-
guage. Unfortunately, a C++ compiler cannot guarantee complete type safety, 
but we can avoid type safety violations through a combination of good coding 
practice and run-time checks. TIle ideal is never to usc language features that thc 
compiler cannot prove to be safe: static type safety. Unfortunately, that's tOO re-
strictive for most interesting uses of progranuning. The obvious fallback, that the 
compiler implicitly generates code that checks for type safelY violations and 
c..1tchcs all of them, is beyond C++. 'When we decide to do things that are (type) 
unsafe, we must do some checking ourselves. We'll point out sllch cases, as we 
get to them. 
TIle ideal of type safety is incredibly import'ant when writing code. 111m's why 
we spend time on it this early in the book. Please note the pitfalls and avoid them. 
3.9.1 Safe conversions 
In §3.4, we saw that we couldn't directly add chars or compare a double to an 
jnt. However, C++ provides a.n indirect way to do both. When needed, a char is 
converted to an inl and an inl is converted to a double. Fo r example: 
char c= 'x'; 
inl il = c; 
inl i2 = 'x'; 
Hcre both il and i2 get the value 120, which is the il1leger value of the charaCter 
'x' in the most popular 8-bit character set, ASCII. TIlis is a simple and safe way 
of getting the numeric representation of a characler. We call this char-to-int can· 
version safe because no infonualion is lost; that is, we can copy the resulting int 
back into a char and get the originaJ vaJue: 
char c2 = il ; 
cout « c«
" « il «"« c2« '\n'; 
TIlis will print 
x 120 x 

'" 
(HAPTER] • OBJECTS, TYPES, AND VALUES 
In this sense - that a value is always converted to an equal value or (for doubles) 
to me best approximation of an equal value - these cOllversions arc safe: 
bool to char 
bool to int 
bool to do uble 
char to inl 
char to double 
int to double 
The most useful conversion is int to double because it allows us to mix ints and 
doubles in expressions: 
double dl = 2.3; 
double d2 = dl+2; 
if (d1 < O) 
11 2 is converted to 2.0 before adding 
/I 0 is converted to 0.0 before comparison 
error("dl is negative"); 
For a really large int, we can (for some computers) sufTer a loss of precision when 
converting to double. TIils is a rare problem. 
3.9.2 Unsafe conversions 
Safe conversions arc usually a boon to the programmer and simplify writing 
code. Unfornmatc1y, C++ also allows ror (implicit) unsafe conversions. By Ull-
safe, we mean thai a value can be implicitly turned into a value of another type 
that docs nOt equal the original value. For example: 
jnt mainO 
{ 
int a = 20000; 
char c = aj 
intb= cj 
if (a != b) 
/I try to squeeze a large in! into a small char 
I/ != means ~ not equal" 
cout « "oops! :" «a« "!="« b « '\n'; 
else 
cout « "Wow! We have large characters\n"; 
) 
Such conversions are also called "narrowing" conversions, because they put a 
value into an object that may be too small ("narrow") to hold it. Unfortunately, 
few compilers warn about the unsafe initializmion of the char with an int. Tne 

3 .9 
TYPE SAFET Y 
problem is that an int is typically much larger than a char, so that it ca.l1 (and in 
this case docs) hold an int value that cannot be represented as a char. Try it to 
see what value b gels on your machine (32 is a common result); beuer still, 
experiment.: 
int mainO 
{ 
double d =0; 
while (cin>>ti) ( 
/I repeat the s!atcmCnlS below 
11.15 long as we type in numbers 
int i = d; 
/I try to squeeze a double inlo an int 
char c = i; 
/I try to squeeze an inl into a char 
in! i2 = c; 
/I gellhe integer value o( the character 
cout « "d==" «
d 
/I the original double 
« " i=="« i 
/I converted to inl 
«" i2==" «
i2 
/I int value of char 
«" char(" «c« ")\n"; 
/I the char 
) 
"n le while·statement that we use to allow many values to be tried will be ex· 
plained in §4.4.2. 1. 
TRY THI S 
Run this program with a variety of inputs. Try small values (e.g., 2 and 3); 
try large values Oarger than 127, larger than 1000); try negative values; try 
56; try 89; try 128; try non·integer values (e.g., 56.9 and 56.2). In addition to 
showing how conversions from double to int and conversions from int to 
char arc done on your machine, this program shows you what character (if 
any) your machine will print for a given integer value. 
You'll find that many input values produce "unreasonable" results. Basically, we 
are trying to put a gallon into a pint pot (about 4 liters into a 500ml glass), All of 
the conversions 
double to int 
double to char 
double to bool 
int to char 
81 

82 
int to bool 
char to bool 
CHAPTER 3 • O BJ ECTS. TYPES, AND VALUES 
arc accepted by the compiler even though they arc unsafe. lllCY aTC unsafe in lhe 
sense that the value stored might differ from the value assigned. Why can this be 
a problem? Because often we don't suspect that an unsafe conversion is taking 
place. Consider: 
double x = 2.7; 
II lOIs of code 
int y=x; 
/I Y becomes 2 
By the time we define y we may have forgotten that " was a double, or we may 
have temporarily forgoucn that double-ta-int conversion truncates (always 
rounds down) rather than using lhe convcmiona14/5 rounding. What happens is 
pcrfccLly predictable, but lhcrc is nothing in the int y = X; to rem.ind us that infor-
mation (the .1) is thrown away. 
Conversions from int to char don't have problems with truncation - neither 
int nor char can represent a fraction of an integer. However, a char C;1Il hold only 
very small integer values. On a PC , a char is I byte whereas an int is 4 bytes: 
char: D 
;nt rl :;1---'-'--' 
So, we can't put a large number, such as tOOO, into a char without loss of infor-
mation: the value is "narrowed." For example: 
int a = 1000; 
char b = a; 
/I b becomes -24 (on some machines) 
Not all int values have char equivalents, and the exact range of char values de-
pends on the particular implementation. On a PC the range of char values is 
[-128:127]. bm only [0,127] can be lIsed portably because not every computer is 
a PC, and different compUiers have dilTerent ranges for t.heir char values, SUdl as 
[0:255]. 
Why do people accept the problem of narrowing conversions? "111e major 
reason is history: C++ inherited narrowing conversions from its ancestor Ian· 
guage, C, so from clay one of C++, there existed much code that depended on 
narrowing conversions. Also, many such conversions don't actually cause prob-
lems because the values involved happen to be in range, and many programmers 
object to compilers '"lelling them what to do." In particular, the problems with un-

CHAPTER 3 DRILL 
sare conversions arc orten manageable in small programs and ror experienced 
programmers. TIley can be a source or errors in larger programs, though, and a 
significant cause or problems ror novice programmers. However, compilers can 
wam about narrowing conversions - and many do. 
So what should you do ir you think that a conversion might lead to a bad 
value? You simply check the value berore assigning as we did in the first example 
in this section. Sec §5.6.4 and §7.5 ror a simplified way or doing such checking. 
-./ Drill 
After each step or this drill, n m your program to make sure it is really doing what 
you expect it to. Keep a list or what mistakes you make so that you can try to 
avoid those in the ruture. 
I. This drill is to write a program that produces a simple ronn letter based 
on user input. Begin by typing the code from §3.1 prompting a user to 
enter his or her first name and writing "Hello, firsCname" where 
firsCname is the name entered by the user. TIlen modiry your code as 
rollows: change the prompt La "Enter the name or the person you want 
to write to" and change the ampUl to "Dear first_name,". Don't rorget 
the comma. 
2. Add an inrroductory line or two, like "How are you? I am fine. I miss 
you." Be sure to indent the first line. Add a rew more lines or your cluX)s-
ing - it's your letter. 
3. Now prompt the user ror the name or anmher rriend, and store it in 
friend_name. Add a line to your letter: "Have you seen friend_name 
latclyr 
4. Declare a char variable called friend_sex and initialize its value to O. 
Prompt the lIser to enter an m ir the rriend is male and an f ir the rriend is 
remale. Assign the value entered to the variable friend_sex. TI1en lise 
two if-statements to write the rollowing: 
If the rriend is male, write "If you sec friend_name please ask him to call 
me." 
If the rriend is female, write "Ir you sec friend_name please ask her to 
call me." 
5. Prompt the user to enter the age or the recipient and assign it to an int 
variable age. Have yOllr program write "I hear you just had a birthday 
and YOll arc age years ald." If age is 0 or less or 110 or more, call 
error("you're kidding! "I. 
83 

/ .. 
( HAPTER 3 • O BJECTS. TYPES, AND VALU ES 
6. Add this to your letter: 
Ir your friend is under 12, write "Next year you will be age+l ." 
If your friend is 17, write "Next year you will be able to vote." 
If your friend is over 70, write "I hope you arc c l~oying retirement." 
Check your program to make sure it responds appropriately to each kind 
of value. 
7. Add "Yours sincerely," followed by nvo blank lines [or a signature, fol-
lowed by your name. 
Review 
I. 'What is meant by the term prompt? 
2. 'Which operator do you use to read into a variable? 
3. If you want the user to input an integer value into yOU T program for a 
variable named number, what arc twO lines of code you could write to 
ask the user to do it and to input the value inlO YOUT program? 
4. What is \n called and what purpose does it serve? 
5. What terminates input into a string? 
6. What terminates input into an integer? 
7. How would you writc 
cout « RHello, "; 
cout « firs,-name; 
coul « "!\n"; 
as a single line of code? 
8. What is an object? 
9. What is a literaJ? 
10. What kinds of literals are there? 
II. What is a variable? 
12. What are typical sizes for a char, an int, and a double? 
13. What measurcs do we use for the size of small entities in memory, such 
as ints and strings? 
14. VVhat is the difference between = and ==? 
15. Whal is a definition? 
16. What is an initialization and how does it differ from an assignmellt? 
17. What is string concatenation and how do you make it work in C++? 
18. Which of the following arc legal names in C++? If a name is not legal, 
why not? 
ThisJitlle_pig 
latest thing 
MiniMineMine 
This_Us fine 
the_S12_method 
number 
2_For_1_special 
_Ihisjs_ok 
correct? 

CHAPTER J EXE RCISES 
19. Give five examples of legal names that you shouldn't usc because they 
are likely to cause confusion. 
20. What are some good rules for choosing names? 
21. What is type safety and why is it important? 
22. \¥hy can conversion from double to inl be a bad thing? 
23. Define a rule to help decide if a conversion from one type to another is 
safe or unsafe. 
Terms 
assignment 
cin 
concatenation 
conversion 
declaration 
decrement 
Exercises 
dermition 
increment 
initialization 
name 
narrO\vmg 
object 
operation 
operator 
type 
type safety 
value 
variable 
1. If you haven't done so already, do the Try this exercises from this cbap-
ter. 
2. Write a program in C++ that converts from miles to kilometers. Your 
program should have a reasonable prompt for the user to enter a number 
of miles. Hint: TIlere arc 1.609 kilometers to the mile. 
3. Write a program that doesn't do anything, but declares a number of vari· 
abies with legal and illegal names (such as int double = 0;), so that you 
can see how the compiler reacts. 
4. Write a program that prompts the user to enter two integer values. Store 
these values in inl variables named vall and val2. Write your program to 
determine the smallest, largest, SUIll, difference, product, and ratio of 
these values and report them to the user. 
5. Modify the program above to ask the user to enter floating·point values 
and store them in double variables. Compare the outputs of the two pro· 
grams for some inputs of your choice. Are the results the same? Should 
they be? What's the difference? 
6. Write a program that prompts the user to enter three integer values, and 
then outputs the values in numerical sequence separated by commas. So, 
if the user enters the values 10 4 6, the output should be 4, 6, 10. If twO 
values arc the same, they should just be ordered together. So, the input 4 
54 should give 4, 4, 5. 
7. Do exercise 6, but with three string values. So, if the user enters the val· 
ues "Steinbeck", "Hemingway", "Fitzgerald", the output should be 
"Filzgerald, Hemingway, Sieinbeck". 
85 

CHAPTE R 3 • O BJECTS, TYPES, AND VALUES 
8. Write a program to test an imeger value to determine if it is odd or even. 
As always, make sure your output is dear and complete. In other words, 
don't juSt output "yes" or "no." Your Output should stand alone, like 
"111e value 4 is an even number." Hint: See the remainder (modulo) op-
erator in §3.4. 
9. Write a program that converts spelled·out numbers such as "zero" and 
"two" into digits, such as 0 and 2. \"'hen the user inputs a number, the 
program should print Out the corresponding digil. Do it for the values 0, 
I, 2, 3, and 4 and write out "not a number 1 know" if the user enters 
something that doesn't correspond, such as "stupid computer!" 
10. Write a program that takes an operation followed by two operands and 
outputs the resull. For exa.mple: 
+ 100 3. 14 
• 45 
Read the operation into a string called operation and usc an if-statement 
to figure out which operation the user wants, for example, if (opera-
tion=="+"). Read the operands into variables of type double. Implement 
this for operations called +, -,., I, plus, minus, Illul, and div with their 
obvious meanings. 
I I. Write a program that prompts the user to enter some number of pennies 
(I-cent coins), nickels (5-cent coins), dimes (lO-cent coins), quarters (25-
cent coins), half dollars (50-cem coins), and one-daUar coins (IOO-cent 
coins). Query the user separately for the number of each size coin, e.g., 
"How many pennies do you have?" Then your program should print 
out something like this: 
You have 23 pennies. 
You have 17 nickels. 
You have 14 dimes. 
You have 7 quarters. 
You have 3 half dollars. 
The value of all of your coins is 573 cents. 
You lUay have to lise your imagination to get the numbers to add up 
right-justified, but Il-y; it can be done. Make some improvements: if only 
one of a coin is reportcd, make the output grammatically correct, e.g., 
"14 dimes" and "1 dime" (not "1 dimes"). Also, repon the sum in dollars 
and cenlS, i.e., $5.73 instead of 573 cents. 

CHAPTER J POSTSC RIPT 
Postscript 
Please don't underestimate the importance of the notion oftypc safety. Types an: 
at the center of most notions of correct programs, and some of the mOst effective 
techniques for constructing programs rely on the design and use of types - as 
you'll see in Chapters 6 and 9, Parts II, III, and IV. 
87 


Computation 
"If it doesn't have to produce correct results, 
I can make it arbitrarily fast." 
- Gerald M. Weinberg 
T
his chapter presents the basics of computation. In panicular, 
we discuss how to compute a value from a set of operands 
(rxjJressifm), how to choose among alLemative actions (selection), and 
how to repeat a computation for a series of values (iterahan). We 
also show how a particular sub-computation can be named and 
specified separately (ajimctir.m). Our primary concern is to express 
computations in ways that lead to correct and well-organized pro-
grams. To help you perfoml more realistic computations, we in-
troduce the vector type to hold sequences of values. 
•• 

.. 
4.1 Computation 
4.2 Objectives and lools 
4.3 Expressions 
4.3.1 Constant expressions 
4.3.2 Operators 
4.3.3 Conversions 
4.4 Statements 
4.4.1 Selection 
4.4.2 Ite ration 
4.1 Computation 
CH AI)TER 4 • COM PUTATION 
4.5 Functions 
4.5.1 Why bother with functionsr 
4.5.2 Function declarations 
4.6 Vector 
4.6.1 Growing a vector 
4.6.2 A numeric example 
4.6.3 A lelft example 
4.7 Language features 
From one point of view, all that a program ever does is to compute; I.hat is, it 
takes some inputs and produces some output. After all, we call the hardware on 
which we run the program a computer. '11is view is accurate and reasonable as 
long as we take a broad view of what constitutes input and output: 
Code 
ILI"_pu_, _....Jr--
(often messy 
often lots of code) 
I Data I 
----{ Output 
I 
111C input can come from a keyboard, from a mouse, from a touch screen, from 
[tIes, from other input devices, from other programs, from other parts of a pro-
gram_ "Other input devices" is a category that contains most really interesting 
input sources: music keyboards, video recorders, nctwork connections, tempera-
HIre sensors, digital camera image sensors, etc. The variety is essentially infinite. 
To deal with input, a program usually contains some data, sometimes re-
ferred to as its dahl JJructUreJ or its £Ialr!. For example, a calendar program may 
contain lists of holidays in various countries and a list of your appointments. 
Some of that data is part of the program from the start; other data is built up as 
the prObrranl reads input and collects useful information f!"Om it. For example, the 
calendar program will probably build your list of appointments from the input 
you give it. For the calendar, the main inputs are the requests to see the months 
and days you ask for (probably using mouse clicks) and me appointments you 
give it to keep track of (probably by typing information on your keyboard). TIle 
output is the display of calendars and appointments, plus the bultons and 
prompts for input that the calendar program writes on your screen. 

4.1 
COMPUTATION 
Input comes from a wide variety of sources. Similarly, output can go to a 
wide variety of destinations. Output can be to a screen, to files, to other output 
devices, to other programs, and to other parts of a program. Examples of output 
devices include network interfaces, music synthesizers, electric motors, light gen-
erators, heaters, etc. 
From a progr.unming point of view t.he most import:mt. and interesting cate-
gories arc "to/from another program" and "to/from other parts of a program." 
Most of the rest of tlus book could be seen as discussing that last category: how 
do we express a program as a set of cooperating parts and how can they share 
and exchange data? TIlese are key questions in programming. "Ve can illustrate 
that brr.lphically: 
Code 
Code 
Code 
l Input . t-
IDatal H 110 I- IDatal ---®-- I Datal -j Output I 
TIle abbreviation /10 stands for "input/output." In this case, the output from one 
part of code is the input for the next p~. What such "parts of a progranl" share 
is data stored in main memory, on persistent storage devices (such as disks), or 
transmitted over network cOlUlections. By "parts of a program" we mean emilies 
SUdl as a function producing a result from a set of input arguments (e.g., a square 
root from a noating-point number), a function performing an action on a physical 
object (e.g., a function drawing a line on a screen), or a function modifying some 
table witlun tile program (e.g., a function adding a name to a table of cusLOmers). 
\oVhen we say "input" and "output" we generally mean information coming 
into and out of a computer, but as you sec, we can also use the terms for infor-
mation given to or produced by a part of a program. Inputs to a part of a pro-
gram ;Ire often called argumenlJ and outputs from a part of a program are often 
called m ulu. 
By (omputtllioll we simply mean the act of producing some outputs based on 
some inputs, such as producing the result (output) 49 from the argument (input) 7 
using the computation (function) square (see §4.5). As a possibly helpful curios· 
ity, we note t.hat until the 1950s a computer was dermed as a person who did 
computations, such as an accountant, a navigator, or a physicist. Today, we sim-
ply delegate most computations 10 computers (machines) of various forms, of 
which the pockel calculator is among the simplest. 
91 

92 
CHAPTER 4 • COMPUTATION 
4.2 Objectives and tools 
Our job as programmers is lO express computations 
Correctly 
Simply 
Efficiently 
Please note the order of those ideals: it doesn't malter how fast a program is ifit 
gives the wrong results. Similarly, a COITeet and efficient program can be so COIll-
plicated that it must be thrown away or completely rewritten 10 produce a new 
version (release). Remember, useful programs will always be modified to accom-
modate lIew needs, new hardware, etc. 'Tllereforc a program - and any part of a 
program - should be as simple as possible to perform its task. For example, as-
sume that you have written the perfect program for lcaching basic arithmetic to 
children in your local school, and t11al its internal structure is a mess. Which lan-
guage did yOlilise to communicate with the children? English? English and Span-
ish? What irI'd like to use it in Finland? In Kuwait? How would you change the 
(natural) language used [or cOllllllunication with a child? Ir the intemal structure 
of the program is a mess, the logically simple (but in practice almost always very 
difficult) operation of changing the natural language lIsed to commlillicate with 
users becomes insurmountable. 
. 
Concems about correctness, simplicity, and efficiency become ours the 
minute we stan writing code for others and accept the responsibility to do that 
well ; that is, we must accept that responsibility when we decide to become pro· 
fessionals. In practical terms, this means that we can't just throw code together 
until it appears to work; we mllst concern ourselves with the structure of code. 
Paradoxically, concerns for structure and "quality of code" arc often the fastest 
way of getting something to work. When programming is done well, such con-
cerns minimiz.e the need for the IllOSt frusu·ating part of programming: debug-
ging; that is, good program structure during development can minimiz.e the 
number of mistakes made and the time needed to search for such errors and to 
remove them. 
Our main tool for organiz.ing a program - and for organiz.ing our thoughts 
as we program - is to break up a big computation into many little ones. l 11is 
technique comes in two vanat.ions: 
Ab;/mchon: Hide details that we don't need to usc a facility ("implementa-
tion details") behind a convenient and general interface. For example. 
rather than considering the details of how to sort a phone book (thick 
books have been written about how to son ), we just call the son algo-
rithm from the C++ standard library. All we need to know to son is how 
to invoke (call) that algorithm, so we can write sort(b,e) where b and e 

4.2 
OBJECTIVES AND TOOLS 
refer to the beginning and the end of the phone book, respectively. An-
other example is the way we use computer memory. Direct use of mem-
ory can be quite messy, so we access it through typed and named 
variables (§3.2), standard library vectors (§4.6, Chapters 17-19), maps 
(Chapter 21), etc. 
"Divitk and (01/(flU7''': Here we take a large problem and divide it into sev-
eral little ones. For example, if we need to build a dictionary, we can sep-
arate that job into three: read the data, sort the data, and outpulthe data. 
Each of the resulting problems is significantly smaller than the oribrlnal. 
Why docs this help? Nler all, a program built out of parts is likely to be slightly 
larger than a program where everything is optimally merged together. The rea-
son is that we are nOI velY good at dealing with large problems. l 11e way we ac-
tually deal with those - in programming and elsewhere - is 10 break them down 
into smaller problems, and we keep breaking those into even smaller parts until 
we get something simple enough to understand and solve. In tenus of program-
ming, you'll find that a 1000-line program has far more than ten times as many 
errors as a 100-line program, so we try to compose the 1000-line program out of 
parts with fewer than 100 lines. For large programs, say 10,000,000 lines, apply-
ing abstraction and divide-and-conqller is notjllsl an option, it's an essential re-
quirement. We simply cannot write and maintain large monolithic programs. 
One way of looking at the rest of this book is as a long series of examples of 
problems that need to be broken up into smaller parts together with the tools and 
techniques needed to do so. 
When we consider dividing up a program, we must always consider what 
tools we have available to express the parts and their COllullunications. A good li-
brary. supplying useful facilities for expressing ideas, can crucially affect the way 
we distribute functionality into different parts of a program. We cannot just sit 
back and "imagine" how best to partition a program; we must consider what li-
braries we have available to express the parts and their commUnic.ltion. It is early 
days yet, but not tOO soon to point OUl that if you can use an existing library, 
such as the C++ standard library, you c.ln save yourself a lot of work, not JUSt on 
programming but also on testing and documentation, TIle ioslreams save liS 
frOIll having to directly deal with tlle hardware's inpuu'olltput ports. TIlls is a first 
example of partitioning a program using abstraction. Every new chapter will pro· 
vide more examples. 
Note the emphasis on stnlcture and organization: YOll don't get good code 
just by writing a lot of statements. Why do we mention this now? At this stage 
you (or at least many readers) have little idea about what code is, and it will be 
months before you are ready to write code upon which other people could de· 
pend for their lives or livelihood. We mention it to help you get the emphasis of 
your learning right. It is very tempting to dash allead, focusing on the parts of 
93 

.. 
CHAPTER 4 • COMP UTATION 
programming that - like what is described in Lhe rest of this chapter - arc COll-
crete and immediately useful and to ignore the "softer," more conceptual pans of 
the art of software development. However, good programmers and system de-
signers know (often having learned it the hard way) that concerns abollt struc-
ture lie at the heart of good software and thai ignoring Struclm"C leads to 
expensive messes. Without structure, you arc (metaphorically speaking) building 
with mud bricks. It can be done, but you'll never get to the fifth floor (mud 
bricks lack the structural strength for that). If you have the ambition to build 
something reasonably permanent, you pay atlemion to mallers of code structure 
and organization along the way, ralhcr m,m having to come back and learn them 
after failures. 
4.3 Expressions 
TIle most basic building block of programs is an expression. An expression com-
putes a value from a number of operands. TIle simplest expression is simply a lit· 
eral value, such as 10, 'a', 3.14, or "Norah". 
Names of variables are also expressions. A variable represents the object of 
which it is the name. Consider: 
II compute area: 
int length = 20; 
int width = 40; 
inl area = length ·width; 
II a literal integer (used to initialize a variable) 
II a multiplication 
Here the literals 20 and 40 are used to initialize the variables length and width. 
TIlen, length and width arc multiplied; that is, we muhiply the valucs found in 
length and width. Here, length is simply shorthand for ''Lhe value found in the 
object named length." Consider also 
length = 99; II assign 99 to length 
Here, as the left-hand operand of the assignment, length means "the object 
named length," so that the assignment expression is read "Pm 99 into the object 
named by length." We distinguish between length used on the left-hand side of 
an assignment or an initialization ("the lvalue of length" or "the object named by 
length") and length used on the right-hand side of an assignment or initialization 
("the rvalue of length," "the value of lhe object named by length," or just "the 
value of length"). In this comext, we find it useful to visualize a variable as a box 
labeled by its name: 
int: 
length: 
99 

4. 3 
EXP RE SSIONS 
That is, length is the name of an object of type int containing the value 99. Some-
times (as an lvalue) length refers to the box (object) and sometimes (as an rvalue) 
length refers to the value in that box. 
We can make more complicated expressions by combining expressions using 
operators, such as + and · , in just the way that we arc used to. When needed, we 
can use parentheses to group expressions: 
int perimeter = (length+width)·2; II add then multiply 
Without parentheses, we'd have had to say 
which is clumsy, and we might even have made this mistake: 
int perimeter = length+width·2; 
1/ add width"*2 to length 
~Inis last error is logical and cannOi be found by the compiler. All the compiler 
sees is a variable called perimeter initializcd by a valid expression. If the result of 
lhat expression is nonsense, that's your problem. You know the mathematical 
definition of a perimctcr, but the compiler doesn't. 
The usual mathematical rules of operator precedence apply, so length+ 
width*2 means length+(width*2). Similarly a*b+cld means (a* b)+(cld) and not 
a*(b+c)/d. Sec §A.5 for a precedence table. 
llle first rule for the use of parentheses is simply "If in doubt, parenthesize," 
but please do ieam enough about expressions so that you are not in doubt about 
a*b+cld. Overuse of parentheses, as in (a*b)+(cld), decreases readability. 
'.vhy should you care about readability? Because you and possibly others 
will read your code, and ugly code slows down reading and comprehension. 
Ugly code is 110l just hard to read, it is also much harder to get correct.. Ugly 
code often hides logical errors. It is slower to read and makes it harder to con-
vince yourself - and others - that ugly code is correct. Don't write absurdly 
complicated expressions such as 
1/ too complicated 
and always try to choose meaninbtful names. 
4_3.1 Constant expressions 
Programs typically usc a lot of constants. For example, a geometry program 
might usc pi and an inch·to-centimeter conversion program will use a conversion 
factor such as 2.54. Obviously, we want to use meaningful names for those con-
stants (as we did for pi; we didn't say 3.14159). Similarly, we don't want to 
change those constants accidentally. Consequently, C++ offers the notion of a 
95 

.. 
( HAPTER 4 • COMPUTATION 
symbolic constant, that is, a named object to which you can't give a new value 
after it has been initialized. For example: 
const do uble pi = 3.14159; 
pi = 7; 
II error: assignment to consl 
int v = 2·pilf; 
/I OK: we just read pi; we don't try to change it 
Such constantS are useful for keeping code readable. YOli might have recognized 
3.14159 as an approximation to pi if you saw it in some code, but would you have 
recognized 299792458? Also, if someone asked yOli to change some code to lise pi 
with the precision of 12 digits for your computation, YOll could search for 3.14 in 
your code, but if someone incautiously had used 2217, you probably wouldn't 
find it. It would be much better just to change the definition of pi to usc the morc 
appropriate value: 
consl do uble pi = 3.14159265359; 
Consequently, we prefer not to use literals (except very obvious ones, such as 0 
and 1) in most places in our code. Instead, we use constan15 with descriptive 
names. Non·obvious literals in code (outside consl definitions) are derisively re' 
ferred to as mtlgic COILI/anls. 
In some places, such as case labels (§4.4.1.3), C++ requires a C(JIIS/anl i!xpra· 
sion, that is, an expression with an integer value composed exclusively of con· 
stants. For example: 
consl inl max = 17; 
/I a literal is a constant expression 
inl val = 19; 
max+2 
val+2 
II a constant expression (a canst int plus a literal) 
II not a constant expression: it uses a variable 
And by the way, 299792458 is one of the fundamental constants of the universe: 
the speed of light in vacuum measured in meters per second. If you didn't in· 
stantly recognize that, why would you expect not to be confused and slowed 
down by other constants embedded in code? Avoid magic constants! 
4.3.2 Operators 
We just used the simplest operators. However, you will soon need more as you 
want to express more complex operations. Most operators are convenlional, so 
we'll just explain them later as needed and YOll u'Ul look up details if and when 
you find a need. Here is a list of the most COlllmon operators: 

4 .J 
EXPRESSIONS 
Name 
f(a) 
function call 
++Ival 
pre-increment 
--Ivai 
pre-decrement 
" 
no. 
-, 
unary minus 
,'b 
multiply 
o/b 
divide 
a%b 
modulo (remainder) 
.. b 
add 
,-b 
subtract 
out«b 
write b to out 
in»b 
read from in into b 
,<b 
less than 
a<=b 
less than Of equal 
o>b 
greater than 
a>=b 
greater than Of equal 
a==b 
equal 
a!=b 
not equal 
a&&b 
logical and 
'lib 
logical or 
Ivai = a 
assignment 
Ivai -= a 
compound assignment 
Commenl 
pass a to f as an argument 
increment and use the incremented value 
decrement and usc the decremented value 
result is bool 
only for integer types 
where oul is an oslream 
where in is an islream 
result is bool 
result is bool 
result is bool 
result is bool 
not to be confused with = 
resu lt is bool 
result is bool 
result is bool 
not to be confused with == 
Ivai = Ivai-a; also for I, %, +, -
\.ye used Ivai (short for "value that can appear all the left-hand side of an assign-
ment") where the operator modifies an operand. You can find a complete list in 
§A.5. 
For examples of the usc of the logic.'ll operators && (and), II (or), and ! (not), 
sec §5.5.1, §7.7, §7.8.2, and §\O.4. 
Note that a<b<c means (a<b)<c and that a<b evaluates to a Boolean value: 
Irue or false. So, a<h<c will be equivalent to either Irue<c or false<c. In particu-
lar, a<b<c docs not mean "Is b between a and c?" as many have naively (and not 
unreasonably) assumed . lllUs, a<h<c is basically a useless cxpression. Don't 
write sllch cxpressions with two comparison operations, and be vCly suspicious if 
you find such ,In expression in someone else's code - it is Illost likely an error. 
An incremeill can be expressed in at least three ways: 
++, 
a+=l 
a=a+1 
.7 

.. 
CHAPTER 4 • COMPUTATION 
VVhich nOtation should we use? Why? We prefer the first version, ++a, because it 
more directly expresses the idea of incrementing. It says what we want to do (in· 
crement a) rather than how to do it (add 1 to a and then write the resul! to a). In 
general, a way of saying something in a program is better than another if it more 
directly expresses an idea. TIle result is morc concise and easier for a reader to 
understand. Uwe wro!c a=a+1 , a reader could easily wonder whether we really 
lUeant to increment by 1. Maybe wejust mistyped a=b+l , a=a+2, or even a=a-1 ; 
with ++a there are far fewer opportunities for such doubts. Plcase note that this is 
a logical argument about readability and correctness, not an argument about effi· 
ciency. Contrary to popular belief, modern compilers tend to generate exactly 
the same code from a=a+1 as for ++a when a is one of the buill·in types. Simi· 
larly, we prefer a *= scale over a = a·scale. 
4.3.3 Conversions 
We can "mix" different types in expressions. For example, 2.512 is a double di· 
vided by an int. \'\That docs this mean? 00 wc do intcger division or floating-
point division? Intcger division throws away tllC remainder; for examplc, 512 is 2. 
F1oating-point division is different in that there is no remainder to throwaway; 
for example, 5.012.0 is 2.5. It follows that thc most obvious aJlS\ ... ·cr to the question 
"Is 2.512 integer division or floating-point division?" is "F1oaling-point, of course; 
otherwise we'd lose information." We would prefer the answer 1.25 rather than 1, 
and 1.25 is what we gel. ~nle rule (for the typcs we have presented so far) is that 
if an opcrator has an operand of type double, we lise floating-point arithmetic 
yielding a double result; otherwise, we lise integer arithmetic yielding an int re-
sult. For example: 
512 
" 
2.512 means 
'a'+1 means 
2 (not 2.5) 
2.Sldouble(2), that is, 1.25 
int('a')+1 
In other words, if necessary, the compiler converts ("promotcs") int operands to 
doubles or char operands to int. Once the result has been calculated, the com-
piler may have to convert it (again) to lise it as an initializer or the right hand of 
an assignment. For examplc: 
double d = 2.5; 
inti=2j 
double d2 = dIi; 
/I d2 :: 1.25 
int i2 = dli j 
II i2 == 1 

4.'1 
STATEMENTS 
d2 = dIi; 
i2 = dIi; 
/I d2 == 1.25 
II i2 == I 
Beware that it is easy to forget abollt integer division in an expression that also 
contains floating-point operands. Consider the lISllal formula for convening dc-
grees Celsius to degrees Fahrenheit:! = 9/5 · c + 32. We might write 
double dc; 
cin »
dc; 
double df = 9/5-dc+32; 
/I beware! 
Unfortunately, but quite logically, this does not represent an accurate tempera-
tllre scale conversion: the value of 9/5 is 1 rat.her than the 1.8 we might have 
hoped for. 1b gel the code mathematically correct, either 9 or 5 (or both) will 
have to be convened into a double. For example: 
double dc; 
cin » dc; 
double df = 9.OIS-dc+32; 
II better 
4.4 Statements 
An expression computes a value from a set of operands using operators like the 
ones mentioned in §4.3. \'\Thal do we do when we want to produce several val-
ues? When we want to do something many times? When we want 10 choose 
among alternatives? When we want to gct input or produce output? In C++, as 
in many languages, you usc language constructs called J/a/cmclu to express those 
things. 
So far, we have seen two kinds of statements: expression statements and dec-
larations. An expression statemelll is simply an expression followed by a semi-
colon. For example: 
a = b; 
++b; 
'11Ose arc two expression statements. Note that the assignment = is an operator 
so that a=b is an expression and we need thc terminating semicolon to make 
a=b; a statement. \rVhy do we need those semicolons? The reason is largely tech-
nical. Consider 
a = b ++ b; 
II syntax error: missing semicolons 
.. 

100 
( HAPTER 4 • COMPU TATION 
Without the semicolon, the compiler doesn't know whether we mean a=b++; b; 
or a=b; ++b;.111is kind of problem is not TCStricted to computer languages; con-
sider the exclamation "'man eating tiger!" ''''ho is eating whom? Punctuation ex-
ists to eliminate such problems, for example, "man-eating tiger!" 
When Slalcmcms follow each mher, the computer executes them in the order 
in which they arc written. For example: 
int a = 7; 
cout « a« '\n'; 
Here lhe declaration, with its initialization, is executed before the output expres-
sion statement. 
In general, we want a statement to have some effect. Statements without ef-
feel arc typically useless. For example: 
1+2; 
/I do an addition, but don't use the sum 
a*b: 
/I do a mulliplication, but don't use the product 
Such statements withom effects are typically logical errors, and compilers often 
wam against them. Thus, expression statements are typically assignments, 110 
statements, or function calls. 
'Ne will mention one more type of statement: thc "empty statement." Con· 
sider the code: 
if (x == 5); 
{ y = 3; } 
111is looks like an error, and it almost certainly is. "nle ; in the first line is not 
supposed to be there. But, lIl1fOrlllnately, this is a legal construct in C++. It is 
called an cmpty slalcmelll, a statemelll doing nothing. An empty statement before a 
semicolon is rarely useful. In this case, it has the unfortunate consequence of al· 
lowing what is almost certainly an error to be acceptable to the compiler, so it will 
not alert you to the error .md you will have that much more difficulty finding it. 
What will happen if this code is run? 111e compiler will test x to sec if it has 
the value 5. If this condition is true, the following statement (the empty state-
ment) will be executed, with no effect. 111en the program continues to the next 
line, assigning the value J to y (which is what you wantcd to have happen if x 
equals 5). If, on the other hand, x docs not have the value 5, the compiler will not 
execute the empty statement (still no effect) and will continue as before to assign 
the value J to y (which is nOt what you wanted to have happen unless x equals 5). 
In other words, the if·statement doesn't matter; y is going to get the value J re· 

4.4 
STATEM ENTS 
gardless. 'Illis is a common error for novice programmers, and it can be difficult 
10 spot, so walch OUl for it. 
'Ille next section is devoted to statements used to alter the order of evalua-
tion to allow us to express more interesting computations than those we get by 
just executing statements in the order in which they were written. 
4.4.1 Selection 
In prob'Tams, as in life, we often have to select among alternatives. In C++, that is 
done using either an if-statement or a switch-stateillent. 
4.4.1.1 if·statements 
TI,e simplest form of seleClion is an if-statement, which seleCIS between two alter-
natives. For example: 
inl mainO 
{ 
inl.1 = O; 
inl b = 0; 
cout « "Please enter two integers\n"; 
cin »a»
b; 
if (a<b) 
II condition 
III st alternative (taken if condition is true): 
cout « "max(" «a« ","« b« ") is" «
b «"\n "; 
else 
112nd alternative (taken if condition is fa lse): 
coul « "max("« a« ","« b «~It) is " «a« "\n"; 
An if-statement chooses between two alternatives. If its condition is true, the first 
statemelll is executed; otherwise, the second statement is. TIlis nouon is simple. 
Most basic programming language features are. 1n fact, most basic facilities in a 
programming language arc just new notation for things you learned in primary 
school - or even before that. For example, you were probably told in kinder· 
garten that to cross the street at a traffic light, you had to wait for the light to tum 
green: '"If the traffic light is green, gon and "If the traffic light is red, wait." In 
C++ that becomes something like 
if (trafficlighl==green) goO; 
,., 

102 
CHAPTER 4 • COMP U TATI O N 
and 
if (Iraffic)ight==red) wail(); 
So, the basic notion is simple, but it is also easy La use if-slatcmcnts in a toO 
simpleminded manner. Consider what's wrong with this program (apart from 
leaving out the #include as usual): 
/I convert from inches to centimeters or cen timeters to inches 
/I a suffix 'i' or 'c' indicates the unit of the input 
inl mainO 
{ 
) 
consl double em_per_inch = 2.54; /I number of centimeters in an inch 
int length = 1, 
II length in inches or centimeters 
char unit = 0; 
couk< "Please enle r a length followed bya unit (c or i):\n"i 
dn» length » unit; 
if (unit == 'i') 
cout« length « "in == "« cm_per_inch*length « "em\n "; 
else 
cout« length « "em == " « lengthlcm_per_inch « "in\n"; 
Actually, this program works roughly as advertised: enter li and )'ou get lin == 
2.S4cm; enter 2.S4c and you'll get 2.S4cm == lin. Just try it; it's good praClice. 
The snag is lhat we didn't test for bad input. The program assumes that the 
user enters proper input. The condition unit=='i' distinguishes between lhe case 
where t.he unit is 'i' and all other cases. llnever looks for a 'e'. 
What if the user entered 1Sf (for feet) "just to see what happens"? 111e condi-
lion (unit == 'i') would fail and the program would execute the else part (the sec-
ond altemative), converting from centimeters to inches. Presumably that was not 
what we wanted when we entered 'f'. 
We must always test our programs with "bad" input, because someone will 
eventually - intentionally or accidentally - enter bad input. A program should 
behave scnsibly even if its users don't. 
Here is an improved version: 
II convert from inches to centimeters or centimeters to inches 
/I a suffix 'i' or 'c' indicates the unit of the input 
/I any other suffix is an error 

4 .4 
STATEMENTS 
int mainO 
( 
} 
const double cm_per_inch = 2.54; II number of centimeters in an inch 
int length = 1; 
II length in inches or centimeters 
char unit = ' '; 
II a space is not a unit 
eout« "Please enter a length followed by a unit (e or i):\n"; 
cin» length » unit; 
if (unit == 'i') 
eout « length « "in =="« em_perj nch· length« "em\n "; 
else if (unit == 'e') 
cout « length « "em == " « lengthlem_per_inch « "in\n"; 
else 
coul « "Sorry, I don't know a unit called '" «
unit « "'\n"; 
We first lest for unit=='i' and then for unit=='c' and if it isn't (either) we say, 
"Sorry." It may look as if we used an "else-if-statement," but there is no such 
thing in C++. Instead, we combined twO if-statemems. The general fornl of an if-
statement is 
if ( exl)/,(~Mi()11 ) Jlalmuml else Jlalmuml 
'11at is, an if followed by an (xprmiall in parentheses followed by a ;101(7n£1I1 fol-
lowed by an else followed by a Jlal(7l1l'n/. What we did was to usc an if-statement 
as the else-part of an if-statement: 
if ( expn:.ssiofl ) JlaleTl/m/ else if «(xpres.siall ) Jla/(7I/(7I/ else Jta1(7I/(n! 
For our program that gives this structure: 
if (unit == 'i') 
111 sl alternative 
else if (unit == 'e') 
11 2nd alternative 
else 
11 3rd alternative 
In this way. we can write arbitrarily complex tests and associate a statement with 
each alternative. However, please remember that one of the ideals for code is sim-
plicity, rather than complexity. YOli don't demonstrate your cleverness by writing 
the most complex program. Rather, you demonstrate competence by writing lhe 
simplest code that docs the job. 
103 

104 
CHAPTER 4 • COMPU TATION 
TRY THIS 
Use the example above as a model for a program that converts yen, curos, 
and pounds into dollars. If you like realism, you can find conversion rates on 
the web. 
4.4.1.2 switch-statements 
Actually, the comparison of unit to 'i' and to 'c' is an example of the most com-
mon form of selection: a selection based on comparison of a value against several 
constants. Such selection is so COIlUllOll that C++ provides a special statcmCIll for 
it: the switch-statement. We can rewrite our example as 
int mainO 
{ 
) 
const double cm_perj nch = 2.54; /I number of centimeters in an inch 
iot length = 1; 
II length in inches or centimeters 
char unit = 'a'; 
(oul« "Please enter a length followed by a unit (c or i):\n"; 
dn » length » unit; 
switch (unit) ( 
case 'i': 
caul «
length « "in == " « em_perjneh· length « "em\n"; 
break; 
case 'e': 
eout « length « "em == II « lengthlem_perjnch « "in\n"; 
break; 
default: 
cout « "Sorry, I don't know a unit called '" «
unit « "'\n"; 
break; 
TI1e switch·statement syntax is archaic but still clearer than nested if-statements, 
especially when we compare against many constants. The value presented in 
parentheses after the switch is compared to a set of constants. Each constant is 
presemed as part of a case label. If the value equals the constant in a case label, 
the statement for that case is chosen. Each case is terminated by a break. If the 
value doesn't match any of the case labels, the statement idemified by the default 
label is chosen. You don't have to provide a default, but it is a good idea to do so 
unless you are absolutely certain that you have listed evely alternative. If you 

4 .4 
STATEMENTS 
don't already know, programming will teach you that it's hard to be absolutely 
certain (and right) about anything. 
4.4.1.3 Switch technicalities 
Here are some technical details abom switch·statements: 
1. TIle value on which we switch must be of an integer, char, or enumera-
tion (§9.5) type. In panicular, you cannot switch on a string. 
2. 111e values in the case labels must be constant expressions (§4.3.1). In 
particular, you cannot lise a variable in a case label. 
3. You cannot usc the same valLIe for two case labels. 
4. YOll can usc several case labels for a single case. 
5. Don't forget to end each case with a break. Unfortunately, the compiler 
won't warn you if you forget. 
For example: 
int mainO 
{ 
/I you can switch only on integers, etc. 
cout « "Do you like fish?\n"; 
string s; 
d n » Si 
switch (s) ( 
II error: the value must be of integer, char, or el1um type 
case "no": 
1/ ... 
break; 
case "yes": 
) 
/I ... 
break; 
To select based on a string you have to use an if·statement or a map (Chapter 21). 
A switch-statement generates optimized code for comparing against a set of 
constants. For larger sets of constants, this typically yields more-efficient code 
than a collection of if-statements. However, this means that the case label vaJues 
must be constants and distinct. For example: 
inl mainO 
{ 
II case labels must be constants 
/I define alternatives: 
int y= 'y'; 
/I this is going to cause trouble 
105 

'06 
) 
const char n = 'n'; 
const char m = '1'; 
cout « "Do you like fishl\n "; 
char 3j 
cin »a; 
switch (a) { 
case n: 
II . .. 
break; 
( H APTER 4 • COMPU TATION 
case y: 
1/ error: variable in case label 
II . .. 
break; 
case m: 
II . .. 
break; 
case 'n': 
II . .. 
break; 
default: 
) 
II . .. 
break; 
1/ error: duplicate case label (n's value is 'n') 
O ften you want the same action for a set of values in a switch. II would be te-
dious to rcpeat the aClion so yOll can label a single action by a set of case labels. 
For example: 
int mainO /I you can label a statement with several case labels 
{ 
coul « "Please enle r a digit\n"; 
char a; 
cin »a; 
switch (a) { 
case '0': case '2': case '4': case '6': case '8': 
coul « "is even\n"; 
break; 
case ', ': case '3': case '5' : case '7': case '9': 
cout « "is odd\n"; 
break; 

4 .4 
STATEMEN TS 
} 
default: 
} 
cout « "is not a digit\n"; 
break; 
The most common error with switch-statements is to forget to terminate a case 
\vilh a break. For example: 
int mainO II e)(ample of bad code (a break is missing) 
{ 
) 
eonst double cm_perj nch = 2.54; II number of centimeters in an inch 
intlength = 1; 
II length in inches or centimeters 
char unit = 'a'; 
cout « "Please enter a length followed by a unit (c or i):\n"; 
d n »
length » unit; 
switch (unit) ( 
case 'i': 
cout « length « "in =="« em_perj nch"lenglh « "em\n"; 
ease 'e': 
eout « length « "em == " «
Iengthlcm_perj neh « "in\n"; 
Unfortunately, the compiler will accept this, and when you have finished case 'i' 
you'll just "drop through" into case 'c', so that if you enter 2i the program will 
output 
2in == 5.08cm 
2cm == O.787402in 
You have been warned! 
TRY TH IS 
Rewrite your currency convener program from the previous Try this to use 
a switch-statement. Add conversions from yuan and kroner. Which version 
of the program is easier to write, understand, and modify? Why? 
107 

108 
( HAPTE R 4 • CO MPUTATION 
4.4.2 Iteration 
We rarely do something only once. 111crcfOl'c, programming languages provide 
convenient ways of doing something several times. ll1is is called repetitioll or -
especially when you do something LO a series of clements of a data stnlCtllrc -
ileraJion. 
4.4.2.1 while-statements 
As an example of iteration, consider the first program ever to nm on a stored-
program computer (the EDSAC). It was written and run by David Wheeler in 
lhe computer laboratory in Cambridge University, England, on May 6. 1949, to 
calculate and print a simple list of squares like this: 
o 
0 
1 
1 
2 
4 
3 
9 
4 
,. 
.. 
9604 
99 
9801 
Each line is a number followed by a "tab" chanlClcr ('\1'), followed by the square 
of the number. A C++ version looks like this: 
/I calculate and print a table of squares 0- 99 
int mainO 
{ 
int i = 0; 
II start from 0 
while (i<:100) { 
cout« i« '\1'« square(i)« '\n'; 
++i ; 
II increment i (that is, i becomes i+ 1) 
} 
~nl C notation square(i) simply means the square of i. We'll later cxplain how it 
gets to mean that (§4.5). 
No, this first modcm prognun wasn't actually writtcn in C++, but the logie 
was as is shmvn here: 
We start \vi.th o. 
We see if we have rcached 100, and if so we are finished. 

4.4 
STATEMENTS 
Otherwise, we print the number and its square, separated by a tab ('\1'), 
increase the number, and try again. 
Clearly, to do this we need 
A way to repeat some statement (to lOOP) 
A variable to keep track of how many times we have been through the 
loop (a loop IXIn'abfe or a collirol varinhle), here the inl called i 
An initializer for the loop variable, here 0 
A termination criterion, here, that we want to go through the loop 100 
times 
Something to do each t.ime around the loop (the body of the loop) 
"n le language construct we used is called a while-statemem.Just following its dis-
tinguishing keyword, while, it has a condition "on top" followed by its body: 
while (i<100) 
( 
/I the loop condition testing the loop variable i 
coul« i « '\1' « square(i) « '\n'; 
++i ; 
/I increment the loop variable i 
) 
111e loop body is a block (delimited by curly braces) that writes out a row of the 
table and increments the loop variable, i. We start each pass through the loop by 
testing if i<100. If so, we arc nUl yet finished and we can execute the loop body. If 
\ve have reached the end, that is, if i is 100, we leave the while-statement and exe-
cute what comes next. In this program the end of the program is next, so we 
leave the program_ 
The loop variable for a while-statement must be defined and initialized out-
side (before) the while-statement. If we fail to defme it, the compiler will give us 
an elTOr. If we define it, but fail to initialize it, most compilers will warn us, saying 
something like "local variable i not set," but would be willing to let us execute the 
program if we insisted. Don't insist! Compilers arc almost certainly right when 
they warn about uninitialized variables. Uninitialized variables are a cOlllmon 
source of errors. In tills case, we wrote 
inli=O; 
/I slart (rom 0 
so all is well. 
Basically, writing a loop is simple. Getling it right for real-world problems 
can be tricky, though. In particular, it can be hard to express the condition cor-
rectly and to initialize all variables so that the loop starts cOITeclly. 
'09 

110 
CHAPTE R 4 • COMPUTATION 
TRY THIS 
The character 'b' is char('a'+l), Ie' is char('a'+2), etc. Usc a loop to write out 
a table of characters with their corresponding integer values: 
a 
.7 
b 
.8 
z 
122 
4.4.2.2 Blocks 
Note how we grouped the two statements that the while had to execute: 
w hile (i<100) ( 
cout « i « '\1' «square(i) « '\n'; 
++i ; 
I/increment i (that is, i becomes i+ l ) 
) 
A sequence of statements delimited by curly braces ( and ) is called a block or a 
com!xJ//lld J/alemelll. A block is a kind of statement. TIle empty block ( ) is some-
times useful for expressing that nothing is to be done. For example: 
if (a<=b) ( 
) 
else ( 
) 
intt= ai 
a = bi 
b = Ii 
/I do nothing 
/I swap a and b 
4.4.2.3 for-statements 
Iterating over a sequence of numbers is so common that C++, like most Olhcr 
programming languages, has a special syntax for it. A for-statement is like a 
while-statement except that the management of the control variable is concen-
trated at the top where it is easy to see and understand. We could have wriuen 
the "first program" like this: 
1/ calculate and print a table of squares 0- 99 
int mainO 
{ 

4.4 
STATEMENTS 
for (int i = 0; i<100; ++i) 
cout « i « '\1'« square(i)« '\n'; 
'11ls means "Execute the body with i starting at 0 incrementing i aftcr each exe-
CLition of the body until we reach 100_" A for-statcment is always equivalent to 
some while-statement. In this case 
for (int i = 0; i<100; ++i) 
coul « i « '\1' « square(i)« '\n'; 
means 
{ 
int = 0; 
/I the for-statement initializer 
while (i<100) ( 
II the for-statement condition 
cout « i « '\t' « square(i) « '\n'; 
/I the for-statement body 
++i; 
/I the for-statement increment 
} 
} 
Some novices prefer while-statements and some novices prefer for-statements. 
However, using a for-statement yields more easily understood and more main-
tainable code whenever a loop c<m be defmed as a for-statement with a simple ini-
tializer, condition, and illcrement operation. Use a while-statement only when 
that's not the case. 
Never modify the loop variable inside the body of a for-statement. That 
would violate every reader's reasonable assumption about what a loop is doing. 
Consider: 
int mainO 
{ 
for (int i = 0; i<100; ++i) ( 
/I for i in the 10:100) range 
caul« i« '\1'« squarc(i)« '\n'; 
++i; 
/I what's going on herer It smells like an error! 
} 
} 
Anyone looking at this loop would reasonably assume that the body would be exe· 
cuted 100 times. However, it isn't. The ++i in the body ensures that i is incremented 
t\vice each time around the loop so that we get an output only for the 50 even values 
of i. If we saw such code, we would assume it to be an error, probably caused by a 
sloppy conversion from a while·loop. If you want to increment by 2, say so: 
111 

112 
CHAPTER 4 • COM PUTAT ION 
/I calculate and print a table of squares of even numbers in the 10: 1 00) range 
int mainO 
{ 
fo r (int i = 0; i<100i i+=2) 
coul « i « '\1'« square(i)« '\n'i 
Please note that the cleaner, morc explicit version is shorter than the messy olle. 
11m's lypical. 
TRY THIS 
Rewrite the character value example from the previous Try this to use a for· 
loop. Then modify your program to also get a table of the integer values for 
uppercase letters and digits. 
4.5 Functions 
In the program above, what was square(i)? It is a call of a function. In pan icular, 
it is a call or the function " ... Iled square with the arbrumcnt i. A jimctioll is a named 
sequence of statements. A function can return a result (also called a return value). 
TIle standard library pl"ovidcs a lot of useful functions, such as the square root 
function sqrlO that we used in §3.4. However, we write many functions our" 
selves. Here is a plausible definition of square: 
inl square(inl x) 
II return the square of x 
{ 
) 
l ne first line of this definition te.lls us that this is a function (that's what the 
parentheses mean), that it is called square, that it takes an inl argument (here, 
called xl, and that it returns an inl (tlle type of the result always comes first in a 
function declaration); that is, we can use il like this: 
inl mainO 
{ 
) 
cout« square(2) « '\n'; II print 4 
cout« square(10) « '\n'; /I print 100 

4.5 
FUNCTION S 
"Ve don't have to use the result ofa function call (but if we didn't want the result, 
why would we call it?), but we do have to give a function exactly the arguments 
it requires. Consider: 
square(2)i 
int v1 = squareOi 
int v2 = squarei 
int \13 = square(1 ,2)i 
int v4 = square("lwo"); 
1/ probably a mistake: unused relurn value 
1/ error: argument missing 
II error: parentheses missing 
II error: too many arguments 
II error: wrong type of argument -
int expected 
Many compilers warn against unused results, and all give errors as indic."1ted. 
You might think that a compucer should be smart enough to figure out that by 
the string "two" you really meant the integer 2. However, a C++ compiler delib· 
erately isn't that smart. It is the compiler's job to do exactly what you tell it to do 
after verifying that your code is well fanned according to the definition of C++. 
If the compiler guessed about what you meant, it would occasionally guess 
wrong, and you - or lhe users of your program - would be quite annoyed. You'll 
find it hard enough to predict what your code will do without having the COIll-
piler "help you" by second·guessing you. 
TI1efimdioll body is the block (§4.4.2.2) that actually docs the work. 
( 
return 1t·1t; 
II return the ~uare of x 
For square, the work is trivial: we produce the square of the argument and return 
that as our result. Saying that in C++ is easier than saying it in English. 11131'S 
typical for simple ideas. Nter all, a prob'Tamming language is designed to state 
such simple ideas simply and pl·ecisely. 
The syntax of ajimch&ll (/ejilliJioll can be described like this: 
JyPe idt:lIl!fier ( jxlramder-lisJ ) jilluJwlI-body 
Tnat is, a type (the retum type), followed by an identifier (the naIlle of the func· 
tion), followed by a list of parameters in parentheses, followed by the body of the 
fLLnction (the statements to be executed). TIle list of arguments required by the 
function is called a parameler lisl and its clements arc called pttrameJm (or jonn,i/ tlr-
grmu:lIts). "111e list of parameters can be empty, and if we don't want to retum a re-
SUll we give \loid (meaning "nothing") as the return type. For example: 
\loid write_sorryO 
( 
/I lake no argument; return no value 
cout « "Sorry\n" ; 
113 

114 
CHAPTER 4 • (OMPUTATION 
The language-technical aspects of functions will be examined more closely III 
Chapler 8. 
4.5.1 Why bother with functions? 
We define a function when we want a separate computation with a name because 
doing so 
Makes the computation logically separate 
Makes the program text clearer (by naming the computation) 
Makes it possible to lISC the function in more than one place III our 
progrnm 
Eases testing 
We'U sec many examples of each of those reasons as we go along, and we'll occa-
sionally mention a reason. Note that real-world programs usc thousands of fUlle-
lions, some even hundred of thousands of functions. Obviously, we would never 
be able to write or understand such programs if their parts (e.g., computations) 
were not dearly separated and named. Also, you'll soon find that many functions 
are repeatedly lIserul and you'd soon tire or repeating their definitions. For exam· 
pie, you might be happy writing x·x and 7·7 and (x+nO(x+7), ete. rather than 
square(x) and square(n and square(x+n , etc. However, that's only because 
square is a very simple computation. Consider square root (c.'llled sqrl in C++): 
you prefer to write sqrl(x) and sqrt(7) and sqrt(x+n, etc. rather than repeating 
the (somewhat complicated and many lines long) code ror computing square 
root. Even better: you don't have to even look at the computation or square rOOt 
because knowing that sqrt(x) gives the square root or x is sufficient. 
In §8.5 we will address many runction technicalities, blll ror now, we'll just 
give another example. 
Ir we had wanted to make the loop in mainO really simple, we could have 
written 
void prinCsquare(int v) 
{ 
cout «v« '\I' «v·v« '\n'i 
) 
int mainO 
{ 
for (int i = OJ i<l00j ++0 prinCsquare(i)i 
) 
Why didn't we use that version using prinCsquarcO? 1l1at version is not signifi· 
cantly simpler than the version using squareO, and note that 

4.S 
FUNCTIONS 
prinCsquareO is a rather specialized function that we could not expect to 
be able to use later, whereas squareO is an obvious candidate for other 
uses 
squareO hardly requires documentation, whereas print_squareO obvi-
ously needs explanation 
llle underlying reason for both is that print_squareO perfonns two logically sep-
arate actions: 
It prints. 
It calculates a square. 
Programs arc usually easier to write and to understand if each function performs 
a single logical action. Basically, the square() version is the better design. 
Finally, why did we usc square(i) rather than simply j.j in the first version of 
the problem? Well, one of the purposes of functions is to simplify code by sepa-
rating alit complicated calculations as named functions, a.nd for the 1949 version 
of the program there was no hardware that direClly implemented ';multiply." 
Consequently, in the 1949 version of the pl'Ogram, i·j was actually a fairly com-
plicated calculation, similar to what you'd do by hand using a piece a paper. Also, 
the writer of that original version, David Wheeler, was the inventor of the func-
tion (then called a subroutine) in modem computing, so it seemed appropriate to 
usc it here. 
TRY THI S 
Implement squareO without using the multiplication operator; that is, do the 
x·x by repeated addition (start a variable result at 0 and add x to it x times). 
Then run some version of "the first program" using that squareO. 
4.5.2 Function declarations 
Did yOll notice that all the information needed to call a function was in the first 
line of its definition? For example: 
int square(int x) 
Given dUll, we know enough to say 
int x = square(44); 
We don't really need to look at the function body. In real programs, we most 
often don't want to look at a function body. Why would we want to look at the 
115 

116 
CHAPTER 4 • COM PUTATION 
body of the standard library sqrtO function? We know it calculates the square 
fOOL of its argument. '.vhy would we want to sec the body of our squareO fune-
lion? Of course we might just be curious. But almost all of the time, we af C just 
interested in knowing how to call a function - seeing the definition would just be 
distracting. Fortunately, C++ provides a way of supplying that information sepa-
rate from the complete function definition. It is called ajill/etia1l dccumllioll: 
int square(int)i 
double sqrt(double)i 
II declaration of square 
/I declaration of sqrt 
Note the terminating semicolons. A semicolon is used in a function declaration 
instead of the body used ill the corresponding function defmition: 
int square(int x) 
{ 
II definition of square 
return X·Xi 
) 
So, if you JUSt want to use a function, you simply write - or more commonly 
#include - its declaration. 111e function definition can be elsewhere. We'll dis-
cuss where that ;<elsewhere" might be in §B.3 and §S.7. "111is distinction between 
declarations and defmitions becomes essential in larger programs where we usc 
declarations to keep most of the code out of sight to allow us to concentrate on a 
single part of a program at a time (§4.2). 
4.6 Vector 
1'0 do just about anything of interest in a program. we need a collection of data to 
work 0 11. For example, we might need a list of phone numbers, a list of members 
of a football team, a list of courses, a list of books read over the last year, a cata-
log of songs for download, a set of payment options for a car, a list of the weather 
forecasts for the next week, a list of prices for a camera in different web stores. 
etc. "n 1e possibilities arc literally endless and therefore ubiquitous in programs. 
We'll get to see a variety of ways of storing collections of data (a variety of con· 
tainers of data; see Chapters 20 and 21). Here we will stan with one of the sim· 
plest, and arguably the most useful, ways of sloring data: a vector. 
A vector is simply a sequence of clements that you can access by an index. 
For example, here is a vector called v: 
sizeO 
v: 
6 
L.:....l--">.J,. 
viOl vll] vl21 v13] v(4) viS] 
v's clements: 
5 
7 
9 
4 
6 
8 

4.6 
VECTOR 
11lat is, the first clement has index 0, the second index I, and so on. We refer to 
an clement by subscripting the name of the vector wit.h the element's index, so 
here t.he value of viOJ is 5, the value of v[l] is 7, and so 011. Indices for a vedor al-
ways start with 0 and increase by 1. 111is should look familiar: the standard li-
brary veclor is simply the C++ standard library's version of an old and 
well-known idea. I have drawn the vector so as to emphasize that it "knows its 
size"; that is, a veclor doesn't just store its clements, it also stores its size. 
We could make such a vector like this: 
veclor<inl> v(6) ; 
/I vector of 6 ints 
viOl = 5; 
v[l] = 7; 
v[2] = 9; 
v13] =4; 
v14] = 6; 
v[5] = 8; 
We sec that to make a vector we need to specify the type of the clemellts and t.he 
initial number of clements. 11le clement type comes after vector in angle brack-
ets « » , here <inl>, and the initial number of clements comes after the name in 
parentheses, here (6). Here is another example: 
vector<slring> philosopher(4); 
/I vector of 4 strings 
philosopher [0] = "Kant"; 
philosopher [11 = "Plato"i 
philosopher (2] = "Humc"; 
philosopher [31 = "Kierkegaard"i 
Naturally, a vector will only accept clements of its declared clement type: 
philosopherl21 = 99; 
v[2] = "Hume"; 
/I error: trying to assign an int 10 a string 
/I error: trying to assign a string to an inl 
When we define a vector of a given size, its clements arc given a default value ac-
cording to the clement type. For example: 
vector<inl> V(6)i 
II veclor of 6 ints initialized to 0 
vector<string> philosopher(4)i II veclor of 4 strings initialized 10 ·· 
If you don't like the default, you can specify another. For example: 
vector<double> vd(1000,-1.2)i 
/I vector of 1000 doubles initialized to - 1.2 
Please note lhat you cannot simply refer to a nonexistent. clemeill of a vector: 
117 

118 
(HAPTER 4 • COMPU TATION 
vd[20000] = 4.7; 
/I run-time error 
We will discuss nm-timc errors and subscripting in the next chapter. 
4.6.1 Growing a vector 
Often, we start a vector empty and grow it to its desired size as \ ... ·c read or COIll-
pute the data we want in it. The key operation here is push_backO, which adds a 
new clement to a veclor. The new clement becomes the last element of the 
vector. For example: 
vector<double> II; 
1/ start off empty; that is, II has no elements 
v.push_back(2.n; 
v.push_back(5.6); 
v.push_back(7.9); 
v: I 0 I 
/I add an element with the value 2.7 at end ("the b.lck
N
) of v 
1/ 'V now has one element and v[0[""",2.7 
v
l
l
l ~ 
1/ add an element with the value 5.6 at end of II 
/I v now has two elements and \1[ 11==5.6 
/I add an element with the value 7.9 at end of v 
/I v now has three clements and v!21==7.9 
Note the syntax for a call of push_backO. It is called a member jill/clioll call; 
push_backO is a member function of vector and must be called using this dot 
notation: 
mi!mber:/iuution--mJi: 
objcc'-lIame . member-jii1U;tioll ~name ( argument-list ) 
'11e size of a vector can be obtained by a call to another of vector's member 
functions: sileO. Initially v.sileO was 0, and after the third call of push_backO, 
v.sileO has become 3. Size makes it easy to loop through all clemellts of a vector. 
For example: 
fo rCint i=O; i<v.size(); ++i) 
cout« "v["« i « "1==" <<v[ij<< '\n'; 

4.6 
VECTOR 
Given the definition of v and the push_backOs above, this for-loop will print 
vIOl ==2.7 
v(11==5.6 
v{2J==7.9 
If you have programmed before, you will note that a vector is similar to an array 
in C and other languages. However, you need not specify the size (length) of a 
vector in advance, and you can add as many elements as you like. As we go 
along, you'll find that the C++ standard vector has other useful properties. 
4.6.2 A numeric example 
Let's look at a more realistic example. Often, we have a series of values that we 
want to rC<ld into our program so that we can do something with them. The 
"something" could be producing a graph of the valucs, calculating the mean and 
median, finding the largest element, sorting them, combining them with other 
data, searching for "interesting" values, comparing them to other data, etc. TIlere 
is no limit to the range of computations we might perform on data, but first we 
need to gel it into our computer's memory. Here is the basic technique for getting 
an unknown - possibly large - amount of data into a computer. As a concrete 
example, we chose to read in floating-point numbers reprcseming temperatures; 
/I read some temperatures into a vector 
int mOlinO 
{ 
) 
vector<doublc> temps; 
/I temperatures 
double temp; 
while (cin» temp) 
II read 
temps.push_back(tcmp); 
/I put into ve<:Ior 
/I . . . do something . 
So, what goes 0 11 here? First we declare a vecior to hold the data and a variable 
into which we can read each number as it comes from input: 
vedorc::double> temps: 
/I temperatures 
double temp: 
111is is where the type of input we expect is mentioned. We read and store 
doubles. 
Next comes the aetllaJ read loop: 
119 

120 
CHAPTER 4 • COMPUTATION 
while (cin» temp) 
/I read 
temps.push_back(temp); 
/I put into vector 
rn le cin»lemp reads a double, and that double is pllshed into the veclor 
(placed at the back). We have seen those individual operations before. What's 
new here is that we usc the input operation, cin»lemp, as the condition for a 
while·loop. Basically, cin» temp is true if a value was read correctly and false 
othen vise, so that while-loop will read all the doubles we give it and stop when 
we give it anything else. For example, if you typed 
1.23.45.67.89.01 
then temps would get the five elements 1.2, 3.4, 5.6, 7.8, 9.0 (in that order, for ex-
ample, temps[O]==1.2). We lIsed the character 'I' to terminate the input - any-
thing that isn't a double can be lIsed_ In §10.6 we discllss how to temlinate input 
and how to deal with errors in input. 
Once we get data into a vector we can easily manipulate it. As an example, 
let's calculate the mean and median temperatures: 
1/ compute mean and median temperatures 
int mainO 
{ 
vector<double> temps; 
II temperatures 
double temp; 
while (cin» lemp) 
/I read 
temps.push_back(temp); 
II put into vector 
II compute mean temperature: 
double sum = 0; 
for (int i = 0; i< temps.size(); ++i) sum += temps[iJ; 
cout« "Average temperature: "« sumltemps.sizeO« endl; 
II compute median temperature: 
sort(temps.begin(),temps.end(»; 
II sort temps 
II Nfrom the beginning to the end" 
cout « "Median temperature: " « temps[temps.size()I2]« endl; 
We calculate the average (the mean) by simply adding all the clements into SUnl, 
and then dividing the sum by lhe number of elements (that is, temps.size()): 
II compute average temperature: 
double sum = 0; 

4.6 
VECTOR 
for (int i = 0; k lemps.size(); H i) sum += tempsli); 
coul « "Average temperature: " «sum/temps.sizeO« endl; 
Note how the += operator comes in handy. 
'Ib calculate a median (a value chosen so lhat half of the values are lower and 
the other half are higher) we need to son the clemeills. For that, we lise the stan-
dard library sort algorithm, sartO: 
/I compute median temperature: 
sort(temps.begin(),temps.end()); 
II sort ufrom the beginning to the end" 
cout « "Median temperature: " «
tempsltemps.size(12) « endl; 
'111e standard librm}' sartO takes twO arguments: the beginning of the sequence 
of clements that it is to sort and the end of that sequence. \Ve will explain the 
standard libral}' algorithms much later (Chapter 20), but fortunately, a vector 
"knows" where its beginning and end are, so we don't need to worry about de-
tails: lemps.begin() and temps.end() will do just fine. Note that beginO and 
endO are member functions of vector, just like sizeO, so we call them for their 
vector using dol. Onee the temperatures arc sorted, it's easy to find the median: 
we just pick the middle clement, the one with index temps.size{)12. If you feel 
like bcing picky (and if you do, you are starting to think like a progranuner), you 
could observe that the value we found may not be a median according to the def-
inition we offered above. Exercise 2 at the end of this chapter is designed to solve 
that litlie problem. 
4.6.3 A text example 
We didn't present the temperature example because we were particularly inter-
ested in temperatures. Many people - such as meteorologists, agronom.ists, and 
oceanographers - are very interested in temperature data and values bascd on it, 
Stich as means and medians. However, we arc nol. From a programmer's point of 
view, what's interesting about this example is its generality: the vector and the 
simple operations on it can be used in a huge range of applications. It is fair to 
say that whatcver you arc interested in, if you need to analyze data, you'll use 
vector (or a similar data structure; sec Chapter 21 ). As an example, let's build a 
simple dictionary: 
II simple dictionary: list of sorted words 
int mainO 
( 
vector<string> words; 
Siring temp; 
while (cin» temp) 
words.push_back(temp); 
/I read whitespace-separated words 
II put into vector 
121 

122 
CH APTER 4 • COMPUTATION 
cout « "Number of words: II «
words.sizeO «endl; 
sort(words.beginO,words.end()); 
1/ sort "from beginning to end" 
for (int i = 0; i< words.size(); ++i) 
if (i==O II wo rds(i- 1]!=words[iJ) 
/I is this a new wo rd~ 
coul « words[i} « "\n"; 
If we feed some words to this program, it will write !.hem om in order WiUlOli t re-
peating a word. For example, glven 
a man a plan panama 
it will wnte 
a 
man 
panama 
plan 
How do we stop reading string input? In other words, how do we terminate the 
input loop? 
while (cin» temp) 
II read 
words.push_back(lemp); 
II put into vector 
VVhcn we read numbers (in §4.6.2), we just gave some input character that 
wasn't a number. We can't do that here because every (ordinary) character can 
be read into a string. Fortunately, there are characters that arc "not ordinary." As 
mcntioned in §3.5. 1, C trl+Z terminales an input stream under Windows and 
Clrl+ D does that under U nix. 
Most of tills program is remarkably similar to what we did for lhe tempera-
tures. In fact, we wrote the "dictionary program" by elilting and pasting from the 
"temperature program ." ~nle only thing that's new is the tcst 
if (i==O II words[i- 1J! =words[i]) 
II is this a new word? 
If you deleted that tCSt the Output would be 
a 
a 

4.7 
LANGUAGE FEATURES 
m." 
panama 
plan 
We didn't like the repetition, so we eliminated it using that test. What docs the 
test do? It looks to see if the previolls word we printed is different from the one 
we are about to print (words[i- l ]!=words[i]) and if so, we print that word; other-
wise, we do not. Obviously, we can't talk about a previous word when we arc 
about to print the first word (i==O), so we first test for that and combine those 
two tests using the II (or) operator: 
if (i==0 II wordsli- l ]!=wordsli]) 
/I is Ihis a new word? 
Note that we can compare strings. ' ""e lise != (not equals) here; == (equaJs), < 
(less than), <= (less than or equal), > (greater than), and >= (greater than or 
equal) also work for strings. '11e <, >, etc. operators usc the lIsuaJ lexicographical 
ordering, so "Ape" comes before "Apple" and "Chimpanzee". 
TRY THI S 
Write a program that "bleeps" out words that you don't like; that is, you 
read in words using tin and print them again 0 11 coul. If a word is among a 
few you have defined, you write out BLEEP instead of that word. Start with 
one "disliked word" such as 
string disliked = "Broccoli"; 
When that works, add a few mOrt. 
4.7 Language features 
' 11e temperature and dictionary programs used most of the fundamental lan-
guage fealm'es we presented in this chapter: iteration (the for-sLatement and the 
while-statement), selection (the if-statement), simple arithmctic (the ++ and += 
operators), comparisons and logical operators (the ==, !=, and II operators), vari-
ables, and functions (e.g., mainO, sortO, and sizeO). In addition, we used stan-
dard library facilities, such as vector (a container of elements), cout (an output 
stream), and sortO (an aJgorithm). 
If you COUIlI, you'U fmd lhat we aClllally achieved quite a lot wilh rather few fc.,-
lUres. TIlal'S the ideal! E.,ch progra.mm.i.ng language feallire exists lO express a fun-
damental idea, and we <:'1.11 combine them in a huge (really, infin.ite) number of ways 
123 

124 
CHAPTE R <I 
• COM PUTATI O N 
to write Llseful programs. TIlis is a key notion: a computer is nOl a gadget with a 
rlXed function. Instead it is a madunc that we can program to do any computation 
we can think of, and given that we can attach computers to gadgets thm intcmct 
with the world outside the computer, we can in principle gel it to do anything. 
~ 
Drill 
Go through this drill step by step. Do not try to speed up by skipping steps. Tcst 
each step by elltering at least three pairs of values - more values would be beltel'. 
1. ,"Vrilc a program that consists of a while-loop that (each time arollnd the 
loop) reads in two ints and then prints them. Exit the program when a 
terminating 'I' is emered. 
2. Change the program to \vrilC out the smaller value is: followed by the 
smaller of the numbers and the larger value is: followed by the larger value. 
3. Augment the program so that it writes the line the numbers are equal 
(only) if they are equal. 
4. C hange the program so that it uses doubles instead of ints. 
5. C hange the program so that it writes out the numbers are almost equal 
after writing out which is the larger and the smaller if the two numbers 
differ by less than 1.0/10000000. 
6. Now change the body of the loop so that it reads just one double each 
lime around. Define twO variables to keep track of which is the smallest 
and which is the largest value you have seen so far. Each time through 
the loop write out the value emered. If it's the smallest so far, write the 
smallest so far after the number. If it is the largest so far, write the largest 
so far after the number. 
7. Add a unit to each double entered ; that is, enter values such as 10cm, 
2.5in, 5ft, or 3.33m. Accept the four units: em, Ill, in, ft. Assume conver· 
sion factors 1m == 100em, l in == 2.54em, Ht == 12in. Read the unit indio 
cator into a string. 
8. Reject values withom units or with "illegaJ" representations of units, such 
as y, yard, meter, km, and gallons. 
9. Keep track of the sum of values entered (as well as the smallest and the 
largest) and the number of values entered. When you see the final 'I' 
print the smallest, the largest, the number of valucs, and the sum of val-
ues. Note that to keep the sum, you have to decide on a unit to lise for 
that sum; use meters. 
10. Keep all the values entered (convened into meters) in a vector. At the 
end, write out those values. 

( H AI'TER 4 REVIEW 
II. Before writing out the values from the vector, sort them (that'll make 
them come Ollt in increasing order). 
Review 
1. What is a computation? 
2. What do we mean by inputs and outputs to a computation? Give examples. 
3. What arc the three requirements a programmer should keep in mind 
when expressing computations? 
4. What docs an expression do? 
5. What is the difference between a statement and an expression, as de· 
scribed in this chapter? 
6. What is an Ivalue? List me operators that require an lvalue. Why do 
thcse operators, and not the others, require an lvalue? 
7. What is a constant expression? 
8. What is a literal? 
9. What is a symbolic constant and why do we usc them? 
10. What is a magic constant? Give examples. 
II . What are some operators that we can use for integers and floating·poim 
valucs? 
12. What operators can bc used on integers but not on flo.1.ting·point numbers? 
13. \.vhat are some operators thaI can be used for strings? 
14. When would a programmer prefer a switch·statement to an if·statement? 
15. What arc some common problems with switch·statements? 
16. What is the function of each part of the header line in a for-loop, and in 
what sequence arc mey executed? 
17. When should the for·loop be used and when should the while·loop be 
used? 
18. How do you print the numeric value of a char? 
19. Describe what the line char foo(int x) means in a function dermition. 
20. When should you define a separate function for part of a program? List 
reasons. 
21. What can you do to an int that you cannot do to a string? 
22. What can you do to a string that you cannot do to an int? 
23. \.vhat is the index of the third element of a vector? 
24. How do YOLI write a for-loop that prints every clement of a vector? 
25. What docs vector<char>alphabet(26); do? 
26. Describe what push_backO docs to a vector. 
27. What do vector's member functions beginO, end(), and size() do? 
28. \.vhat makes vector so popular/useful? 
29. How do you sort the elements of a vector? 

126 
Terms 
abstraction 
beginO 
computauon 
conditional statement 
declaration 
dcfmition 
divide and conquer 
else 
endO 
expresSIOn 
Exercises 
for-statement 
function 
if-statement 
increment 
mput 
Iterauon 
loop 
Ivalue 
member function 
outpUt 
CHAPTER 4 • COMPUTATION 
push_backO 
repetition 
rvaluc 
selection 
sizeO 
sartO 
statcmcill 
switch-statement 
vector 
while-statement 
l. If you haven't already, do the Try this exercises from this chapter. 
2. If we define the median of a sequence as "the number for which exactly 
half of the elemenLS of the sequence come before it and exactly half come 
after it," fix the program in §4.6.2 so iliat it always prints out a median. 
Hint: A median need not be an clement of the sequence. 
3. Read a sequence of double vaJues into a vector. TItink of each value as 
the distance between two cities along a given route. Compute and print 
the total distance (the sum of all distances). Find and print the smallest 
and greatest distance between two neighboring cities. Find and print the 
mean distance between two neighboring cities. 
4-. Write a program to play a numbers guessing game. TIle user thinks of a 
number between 1 and 100 and your program asks questions to figure 
out what the number is (e.g., "Is the number you are thinking of less 
than 50?"). Your program should be able to idemify the number after 
asking no more than seven questions. Him: Use the < and <= operators 
and the if·else construct. 
5. Write a program that perfonns as a very simple calculator. Your caJcula· 
tor should be able to handle the five basic math operations - add, sub· 
tract, multiply, divide, and modulus (remainder) - on two input values. 
Your program should prompt the user to enter three arguments: two 
double values and a character to represent an operation. If the entry ar-
guments are 35.6, 24.1 , and '+', the program output should be "The sum 
of 35.6 and 24.1 is 59.7." In C hapter 6 we look at a much marc sophisti-
cated simple calculator. 
6. Make a vector holding the ten string values "zero", "one", ... "nine". 
Use that in a program that converts a digit to its corresponding spelled-
Ollt value; e.g., the input 7 gives the output seve n. Have the same pro-

( HAPTER 4 EXERCISES 
gram, using the same input loop, convert spelled-alit numbers into their 
digit form; e.g., the input seven gives the output 7. 
7. Modify the "mini calculator" from exercise 5 to accept (just) single-digit 
numbers wriucn as either digits or spelled out. 
8. 11lere is an old story that the emperor wanted to thank the inventor of 
the game of chess and <Isked the inventor to name his reward. TIle in-
ventor asked for one grain of rice for the first square, 2 for the second, 4 
for the third, and so on, doubling for each of the 64 squares. That may 
sound modest, but lhere wasn't thai much rice in the empire! Write a 
program to calculate how many squares arc required to give the inventor 
at least 1000 grains of rice, at least 1,000,000 grains, and at least 
1,000,000,000 grains. You'll need a loop, of course, and probably an inl 
to keep track of which square you arc at, an int to keep the number of 
grains on the current square, and an int to keep track of the grains on all 
previous squares. We suggest that you write out the value of all your Villi-
abies for each iteration of the loop SO lilat you am sec what's going Oil. 
9. Try to calculate the number of rice grains lhat the inventor asked for in 
exercise 8 above. You'll find that the number is so large that it won't fit in 
an inl or a double. Observe what happens when the number gets too 
large to represent as an inl and as a double. What is the largest number 
of squares for which you can calculate the exact number of grains (using 
an int)? Whal is the largest number of squares for which you can calcu-
late the approximate number of grains (using a double)? 
10. Write a program that plays the game "Rock, Paper, Scissors." If you arc 
not familiar with the game do some research (e.g., on the web using 
Coogle). Research is a common task for progra.mmers. Use a switch-
statement to solve this exercise. Also, the machine should give random 
answers (i.e., select the next rock, paper, or scissors randomly). Real ran-
domness is too hard to provide just now, so just build a vector with a se-
quence of values to be used as "the next value." If you build the vector 
into the program, it will aJways play the same game, so maybe you 
should let the user enter some values. Try variations to make it less easy 
for lhe user to guess whieh move lhe machine will make next. 
I I. Create a program to find all the prime numbers between 1 and 100. One 
way to do this is to write a function that will check if a number is prime 
(i.e., see if lhe number can be divided by a prime number smaller lhan it· 
self) using a vector of primes in order (so that if the vecto, is called 
primes, primes[Ol==2, primes[11==3, primes[21==5, etc.). Then write a 
loop thal goes from I to 100, cheeks each number to see if it is a prime, 
and stores each prime found in a vector. Write another loop that lists the 
primes you found. You might cheek your resull by comparing your 
vector of prime numbers with primes. Consider 2 the first prime. 

128 
CHAPTER 4 • COMPU TATION 
12. Modify the program dcscribed in the previous exercisc to take an input 
value max and then find all prime numbers from 1 to max. 
13. Create a program to find all the prime numbers bctween 1 and 100. 
There is a classic method for doing this, called the "Sieve of Eratos· 
thenes." If you don't know that method, get on the web and look it up. 
Write your program using this method. 
14. Modify the program described in the previous exercise to t.'lke an input 
value max and then find all prime numbers from 1 to max. 
15. Write a program that takes an input value n and then finds the first n 
pnmes. 
16. In the drill, you wrote a program that, given a series of numbers, found 
the max and min of that series. llle number that appears the most times 
in a sequence is callcd thc mode. Create a program that finds thc modc of 
a set of positive integers. 
17. Write a progranl that finds thc min, max, and mode of a sequence of 
strings. 
18. Write a program to solve quadratic equations. A quadratic equation is of 
the form 
ax2+bx+c=O 
If you don't know t.he quadratic fonnula for solving such an expression, 
do some research. Remember, researching how to solve a problem is 
often necessary before a programmer can teach the computer how to 
solve it. Use doubles for thc uscr inputs for a, b, and c. Since there are 
twO solutions to a quadratic equation, Output both x1 and x2. 
19. Write a program where you first enter a set of name·and·value pairs, 
such as Joe 17 and Barbara 22. For each pair, add the name to a veclor 
called names and the numbcr to a vector called scores (in corresponding 
positions, so that if names[7]=="Joe" then scores[7]==18). l cnninate 
input by the line No more ("more" will make the attempt to read anotller 
integer fail). Check that each name is unique and terminate with an crror 
message if a name is entered twice. Write au[ all the (namc,score) pairs, 
one per line. 
20. Modify the program from exercise 19 so that when you cntcr a nall1e, 
the program will output the corresponding score or "name not found". 
21. Modify the program from exercise 19 so lhat when you enter an integer, 
lhe program will Output all the names Wilh lhal score or "score nol 
found". 

CHAPTER" POSTSCR IPT 
Postscript 
From a philosophical point of view, you can now do everything that can be done 
using a computcr - the rest is details I Among other things, this shows the value 
of "details" and the importance of practical skills, because clearly you have barely 
started as a programmcr. But we are serious. The tools pl"esented in this chapter 
do allow you to express every computation: you have as many variables (includ-
ing vectors and strings) as you want, you have arithmetic, comparisons, and you 
have selection and iteration. Every computation can be expressed using those 
primitives. YOLI have tc. ... t and numeric input and output, and every input or out-
put can be expressed as tCXt (even graphics). You can even organize your compu-
tations as sets of named functions. What is left for you to do is "just" to learn to 
write good programs, t.hal is, to write programs that arc correct, maintainable, 
and reasonably efficient Important.ly, you must. try to learn to do so Wit.ll a rea-
sonable amount of effort. 


Errors 
"I realized that from now on a large part 
of my life would be spent fmding and 
correcting my own mistakes." 
-Maurice Wilkes, 1949 
I
n this chapler, we discuss correctness of programs, errors, and 
error handling. If you are a genuine novice, you'll find the dis-
cussion a bit abstract at times and painfully detailed at other 
limes. Can error handling really be this important? It is, and 
you'll learn that one way or another before you can write pro-
grams that others are willing (0 use. \¥113l we are crying to do is 
to show you what "thinking like a programmer" is about. It com-
bines fairly abstract strategy with painstaking analysis of details 
and alternatives. 
131 

132 
5.1 Introduction 
5.2 Sources of errors 
5.3 Compile-time errors 
5.3.1 Syntax errors 
5.3.2 Type errors 
S.l.) Non-errors 
5.4 Link-lime errors 
5.5 Run-time errors 
5.5.1 The caller de~ls with errors 
5.5.2 The c~lIee deals with errors 
5.S.) Error reporting 
5.6 Exceptions 
5.6. t Bad arguments 
5.6.2 Rilnge errors 
5.6.3 Bad input 
5.6.4 N'lfrowing errors 
5.1 Introduction 
CHAPTER 5 • ERRORS 
5.7 logic errors 
5.8 Estimation 
5.9 Debugging 
5.9.1 Practical debug advice 
5.10 Pre- and post-conditio ns 
S.10.1 Posi-conditions 
5.11 Testing 
We have refcrred to errors repeatedly in the previous chapters, and - having 
done me drills and some exercises - you have some idea why. Errors arc simply 
unavoidable when you develop a program, yet lhe Hnal program IIlUSt be free of 
errors, or at least free of errors that we consider unacceptable for it. 
There are many ways of classifying errors. For example: 
CmnjJl"/e-time emm: Errors found by the compiler. We c.1n further classify 
compile-time errors based on which language rules they violate, for 
cxample: 
Syntax errors 
Type errors 
Link-time errorJ: Errors found by the linker when it is trying to combine 
object files into an executable program. 
Rllll-tim~ error;: Errors found by checks in a running program. We can 
fUlther classify run-time errors as 
Errors detected by lhe computer (hardware andlor operating system) 
Errors detcCled by a library (e.g., the standard Jibrmy) 
Errors detected by user code 
Logic mTm: Errors found by the programmer looking for the causes of er-
roncous results. 

5. 1 
I N TROO UCTIO N 
It is tempting to say that our job as programmers is to eliminate an errors. 111at is 
of course the ideal, but often that's not feasible. In fact, for real-world programs it 
can be hard to know exaclly what "all errors" means. If we kicked Ollt the power 
cord from your computer while it executed your program, would that be an error 
that you were supposed to handle? In many cases, the answer is "Obviously not," 
but what if we were talking about a medical monitoring program or the control 
program for a telephone switch? In those cases, a lIser could reasonably expect 
thai somellling in the system of which your program was a part will do some· 
thing sensible even if your computer lost power or a cosmic ray damaged the 
memory holding your program. The key question becomes: "ls my program 
supposed to detect that errorr Urness we specifically say otherwise, we will as-
sume that your program 
1. Should produce the desired results for all legal inputs 
2_ Should give reasonable error messages for all illegal inputs 
3. Need not WOlTY about misbehaving hardware 
4. Need nOt won-y aboUl misbehaving system software 
5_ Is allowed to tertninate after fmding an error 
Essentially all programs for which assumptions 3, 4, or 5 do not hold can be con-
sidered advanced and beyond the scope of this book. However, assumptions 1 
and 2 arc included in lIle defmition of basic professionalism, and professionalism 
is one of our goals. Even if we don't meet that ideal 100% of the time, it must be 
the ideal. 
,"Vhen we write programs, errors are natural and unavoidable; the question 
is: how do we deal willl them? Qur guess is lIlat avoiding, fmding, and correcting 
errors takes 90010 or more of the effort when developing serious software. For 
safety-critical programs, the effort can be greater stilL You can do much better for 
sUlali prob'Tams; on the other hand, you can easily do worse if you're sloppy_ 
BasicaJly, we offer three approaches to producing acceptable software: 
O rganize software to minimize errors. 
Eliminate most of the errors we made through debugging and testing. 
Make sure the remaining errors arc not serious. 
None of these approaches can completely eliminate errors by itself; we have to 
usc all lhree. 
Experience matters immensely when it comes to producing reliable pro· 
grams, that is, programs that can be relied on to do whatlhey are supposed to do 
with an acceptable error rate. Please don't forget that the ideal is that our pro-
grams always do the right thing. We are usually able only to approximate that 
ideal, but that's no excuse ror not trying very hard. 
133 

134 
CHAPTER 5 • ERRORS 
5.2 Sources of errors 
Here arc some sources of errors: 
FfJcr sjxcificatiQn: If we are not specific about what a pmgram should do, 
we arc unlikely to adequately examine the "dark corners" and make sure 
that all cases arc handled (i.e., that every input gives a correct answer or 
an adequate error message). 
InlOmplete progralllJ: During devclopmcnt, there arc obviously cases that 
we haven't yet taken care of. That's unavoidable. ,.vhat we must aim for 
is to know when we have handled all cases. 
UlII:xjxded arguments: Functions take arguments. If a function is given an 
argumem we don't handle, we have a problem. An example is calling the 
standard library square root function with - 1.2: sqrt(-1.2). Since sqrtO 
of a double returns a double, there is no possible correct return value. 
§5.5.3 discusses tltis kind or problem. 
Unexpectcd input: Programs typically read data (rrom a keyboard. rrom 
files, rrom GU ls, rrom network connections, etc.). A program makes 
many assumptions about such input, ror example, that the user will 
input a number. What ir the user inputs "aw, simi up!" rather than the 
expected integer? §5.6.3 and §10.6 discuss this kind or problem. 
Uncxj){!c/cti stale: Most programs keep a 101 or data ("state") arollnd ror lise 
by different parts or the system. Exrullples arc address lists, phone direc-
tories, and vectors or temperature readings. \"'hat ir such data is incom· 
plete or wrong? The various parls or the program must still manage. 
§26.3.5 discusses this kind or problem. 
Logi(((1 errrJ1"J: That is, code that simply doesn't do what it was supposed 
to do; we'll just have to find and fix such problems. §6.6 and §6.9 give 
examples or finding such problems. 
This list has a practical usc. We can use it as a checklist when we afC considering 
how rar we have come with a progrrun. No program is complete umil we have 
considered all or these potential sources or errors. In ract, it is prudent to keep 
them ill mind rrom the very start or a project, because it is most unlikely that a 
progrrun that is just thrown together witham thought about errors can have its 
errors round and removed without a serious rewrite. 
5.3 Compile-time errors 
When you arc writing progr-J.ms, your compiler is your first line or ddense 
against errors. nerore generating code, the compiler rulalyzes code to detect synwx 
errors ruld type errors. Only if it finds that the program completely conrorms to 

5 .3 
COMPi lE · TIME ERRORS 
the language specific.1.tion will it allow you LO proceed. Many of the errors that the 
compiler finds are simply "silly errors" c.1.used by mistyping or incomplete edits of 
the source code. Others result from flaws in our understanding of the way parts of 
our program interact. To a beginner, the compiler often seems pett}', but as you 
leam to use the language facilities - and especially the type system -
LO directly 
express your ideas, you'll come to appreciate the compiler's abilit}' to detect prob· 
lems that would otllerwise have caused you hours of tedious searching for bugs. 
As an example, we will look at some calls of this simple function: 
int area(inllength, int width); 
II calculate area of a rectangle 
5.3.1 Syntax errors 
What if we were to c."1ll areaO like this: 
int sl = area(7; 
int sl = area(7) 
Int s3 = area(n; 
int 54 = area('n; 
1/ error: ) missing 
II error: ; missing 
II error: Int is not a type 
II error: non-terminated character (' missing) 
Each of those lines has a syntax error; that is, they ate not well formed according 
LO the C++ grammar, so the compiler will reject them. Unfortunately, syntax er-
rors are not always easy to teport in a way that you, the programmer, find easy to 
understand. TImt's because the compiler may have to read a bit funhet titan the 
elTOr to be sure that there really is an error. The effect of this is that even though 
symax errors tend to be completely trivial (you'll often find it hard to believe you 
have made such a mistake once you find it), Lhe reporting is of len oyplic and oc-
casionally rcrers to a line further on in the program. So, for syntax errors, if you 
don't see anytlung wrong with the line the compiler points 10, also look at previ-
ous lines in the program. 
Note that tile compiler has no idea what you are trying to do, so it cannot re-
pon errors in lerms of your intent, only in tenus of what you did. For example, 
given the eITOr in tile declaration of 53 above, a compiler is unlikely to say 
"You misspelled int; don't capitalize the i." 
Rather, it'll say sometlling like 
"syntax error: nussing ';' before identifier 's3' " 
" 's3' missing storage-class or type identifiers" 
"'Int' nussi.ng storage-class or type idemifiers" 
Such messages tend to be cryptic, until yOll get used to them, and to use a vocab-
ulary that can be hard to penetrate. Different compilers can give very different-
115 

136 
( H APTER 5 • ERRORS 
looking error messages for the same code. Fortunately, you SOOI1 gel used to read-
ing such stuff. After all, a quick look at those cryptic lines can be read as 
"There was a syntax error before 53, 
and it had something to do with the type of Int or 53." 
Given thal, it's not rocket science to find the problem. 
TRY THIS 
Try to compile those examples and sec how the compiler responds. 
5.3.2 Type errors 
Once you have removed syntax errors, the compiler will start reporting type er-
rors; that is, it will report mismatches between the types you declared (or forgot 
to declare) for your variables, functions, etc. and the types of values or expres-
sions you assign to them, pass as function arguments, etc. For example: 
inl xO = arena(7); 
/I error: undeclared function 
inl xl = area(7); 
II error: wrong number of arguments 
int x2 = area("seven",2); 
II error: lsI argumenl has a wrong Iype 
Let's consider these errors. 
I. For arena(7), we misspelled area as arena, so the compiler thinks we 
want to call a function called arena. (\'\That else could it "think"? 11mt's 
what we said.) Assuming there is no function called arena(), you'll get an 
error message complaining about an undeclared function. If there is a 
function called arena, and if that function accepts 7 as an argument, you 
have a worse problem: the progrnm will compile but do something you 
didn't expect it to (that's a logical error; see §S.?). 
2. For area(7), the compiler detects the wrong number of arguments. In 
C++, every function caU must provide lhe expected number of argu-
ments, of the right types, and in the right order. When the type system is 
used appropriately, this can be a powerful tool for avoiding run'lime er-
rors (see § 14.1). 
3. For area("seven",2), you might hope that the computer would look at 
"seven" and figure out that you meant the integer 7. It won't. If a func-
tion needs an integer, you can't give it a string. C++ docs support some 
implicit type conversions (see §3.9) but not string to int. TIle compiler 
docs not try to guess what you meant. \-Vltat would you have expected 
for area("Hovellane" ,2), area("7,2"), and area("sieben", "zwei")? 

5.4 
LINK-TIME ERRORS 
111ese arc just a rew examples. There arc many more errors that the compiler will 
find ror you. 
TRY TH IS 
Try to compile those examples and sec how the compiler responds. Try 
thinking or a rew more errors yourself, and try those. 
5.3.3 Non-errors 
As yOLi work with the compiler, you'll wish that it was smart enough to figure OLit 
what YOLi meant; that is, you'd like some or the errors it reports not to be errors. 
11l<Il'S natural. More surprisingly, as you gain experience, you'll begin to wish 
that the compiler would reject more code, rather than less. Consider: 
int x4 = area(10,-7); 
II OK: but what is a rectangle with a width of minus 7? 
int x5 = area(10.7,9.3); 
IIOK: but calls area(1O,9) 
char x6 = area(1oo, 9999); 
II OK, but truncates the resu It 
For 11:4 we get no error message rrom the compiler. From the compiler's point or 
view, area(10,-7) is fine: area() asks ror two integers and you gave them to it; no-
body said lhat those arguments had to be positive. 
For 11:5, a good compiler will wam about the truncation or the doubles 10.7 
and 9.3 into the ints 10 and 9 (see §3.9.2) However, the (ancient) language rules 
state that yOll can implicitly convert a double to an int, so the compiler is not al-
lowed to reject the call arca(10.7,9.3). 
111e initialization or 11:6 suffers rrom a variant of the sa.me problem as the call 
area(10.7,9.3). 111e int retumed by area(100,9999), probably 999900, will be as-
signed to a char. -m e most likely result is ror x6 to gel the "truncated" value -36. 
Again, a good compiler will give you a warning even though the (ancient) lan-
guage rules prevent it rrom rejecting the code. 
As you gain experience, you'll leam how to get the most out or the com-
piler's ability to detect errors and to dodge its known weaknesses. However, 
don't get overconfident: "my program compiled" doesn't mean thal it will nin. 
Even ir it docs run, it typically gives wrong results at first until you find the flaws 
in your logic. 
5.4 Link-time errors 
A program consists or several separately compiled parts, called trallslali(TIl III/its. 
Every runction in a program must be declared with exactly the same type in 
137 

138 
CHAPTER 5 • ERROR S 
every translation unit in which it is used. We usc header files to ensure lhat; sec 
§B.3. Every function must also be defined exactly once in a program. If either of 
lhese rules is violated, the linker will give an error. We discuss how to avoid link-
lime errors in §B.3. For now, here is an example of a program that might give a 
typical linker error: 
inl area(int length, int width); 
II calculate area of a recTangle 
int mainO 
( 
int ;II: = area(2,3); 
) 
Unless we somehow have de[med area() in another source file and linked the 
code generated from that source file to this code, the linker will complain that it 
didn't find a definition of area(). 
lne definition of areaO must have exactly the same types (both the Tetllm 
type and the argument type) as we used in OliT file, that is: 
int area(inl x, inl y) {' • . . . O,} 
/I "our" areaO 
Functions with the same name but different types will not match and will be 
ignored: 
double area(double x, double y) {r .. . -'} 
/I not "our" areaO 
inl area(int x, int y, char unit) { /* .. . *' } 
/I not "our" areaO 
Note that a misspelled function name doesn't usually give a linker error. How-
ever, the compiler gives an error immediately when it sees a call to an undeclared 
function. That's good: compile-time errors are found earlier than link-tunc errors 
and are typically easier to fix . 
The linkage rules for functions, as stated above, also hold for all other enti-
ties of a program, such as variables and types: there has to be exact..ly one defini-
Llon of an entity with a given name, but there can be many declarations, and all 
have to agree exact..ly on its type. 
5.5 Run-time errors 
If your program has no compile-time errors and no link-tunc errors, it'll lUll . 
This is where the fun really starts. When you write the program you are able to 

5.5 
RU N.TIME ERRORS 
detect errors, but it is not always easy to know what LO do with an error once you 
catch it at run time. Consider: 
int area(int length, int width) 
{ 
/I calculate area of a rectangle 
return length*width ; 
} 
int framed_area(int x, int y) 
{ 
II calculate area within frame 
return area(x-2,y-2); 
} 
inl mainO 
{ 
intx= - l ; 
inty =2; 
intz=4; 
/I .. 
int areal = area(x,y); 
int areal = framed_area(l,z); 
int area3 = framed_area(y,z); 
double ratio = double(areal)/area); 
/I convert to double to gel 
/I floating·point division 
We lIsed the vru;ables x, y, z (r,uher than using the values direcuy as arguments) to 
make the problems less obvious to the human reader and harder for the compiler 
to detect. However, these calls lead to negative values, representing areas, being as· 
signed to areal and areal. Should we accept such erroneous results, which violate 
most notions of math and physics? If not, who should detect the errors: the caller 
of areaO or the function itself? And how should sllch errors be reponed? 
Before answering those questions, look at the calculation of the ratio in the 
code above. It looks innocent enough. Did you notice somet.hing wrong with it? 
If not, look again: area3 will be 0, so that double(areal )/area3 divides by zero. 
'111is leads to a hardware-detected error that temlinates the program with some 
cryptic message relating to hardware. This is ule kind of error that you - or your 
users - will have to deal with if you don't detect and deal sensibly with run·time 
elTOrs. Most people have low tolerance for such "hardware violations" because to 
anyone not intimately familiar with the program aU the information provided is 
"Something went wrong somewhere!" That's insufficient for any constructive ac-
tion, so we feci angry and would like to yeU at whoever supplied the program. 
139 

140 
( HAPTER 5 • ERR O RS 
$0, let's tackle the problem of argument errors Wilh areaO. We have tWO ob-
vious ah'cmauves: 
a. Let lhe caBer of areaO deal with bad arguments. 
b. Let areaO (the called function) deal with bad arguments. 
5.5.1 The caller deals with errors 
Let's try lhe first alternative ("Let the lIser beware!") first. That's the one we'd 
have to choose if area() was a function in a library where we couldn't modify it. 
For better or worse, this is the most common answer. 
Protecting the caU of area(x,y) in mainO is rdat..ivcly easy: 
if (,,<=0) error("non-positive x"), 
if (y< =O) error("non-positive ylt); 
int areal = area(x,y); 
Really, the only question is what to do if we find an error. Here, we have called a 
function cuorO which we will assume will do something sensible. In fact, in 
std_lib_facilities.h we supply an errorO function that by default terminates the 
program with a system error message plus the string we passed as an argument 
to errorO. If you prefer to write out your own error message or take other ac-
tions, you catch runtime3uor (§5.6.2, §7.3, §7.8, §B.2.1). "This suffices for most 
student programs and is an example of a style that can be used for more sophisti-
cated error handling. 
If we didn't need separate error messages about each argument, we would 
simplify: 
if (x<=O II y<=O) error("non-positive area() argument"); 
int areal = area(x,y); 
To complete protecting areaO from bad arguments, we have to deal with the calls 
through framed_areaO. We could write: 
if (z<=2) 
error("non-posilive 2nd areaO argument called by framed_areaO"); 
int area2 = framed_area(l,z); 
if (y<=211 z<=2) 
error("non-positive areaO argument called by framed_areaO"); 
int areaJ = framed_area(y,z); 
"Ibis is messy, but there is also something fundamentally wrong. We could write 
this only by kllowing exactly how framed_areaO Llscd areaO. We had to know 
that framed_areaO subtracted 2 from each argument. We shouldn't have to know 
such delails! \"'hat if someone modified framed_areaO to use 1 instead of 2? 

5.5 
RUN-T IM E ERRORS 
Someone doing that would have to look at every call of framed_areaO and modify 
the error-checking code correspondingly. Such code is called "briule" bec. ... use it 
breaks easily. This is also an example of a "magic constam" (§4.3.1). We could 
make the code less brittle by giving the vaJue subtracted by framed_areaO a name: 
canst int frame_width = 2; 
int framed_area(int x, int y) 
/I calculate area within frame 
( 
retu rn area(x- frame _ widt h, y-f rame_ width); 
11mt name could be used by code calling frame_areaO: 
if (l-frame_width<=O II z-frame_width<=O) 
error("non-positive 2nd areaO argument called by framed_area()"); 
int area2 = framed_area(l ,z); 
if (y-frame_widlh<=O II z-frame_widlh<=O) 
error("non-posilive area() argument called by framed_areaO"); 
inl areal = framed_area(y,z); 
Look at that code! Are you sure it is correct? Do you find it pretty? Is it easy to 
read? AcmaJly, we find it ugly (and therefore error-prone). We have more thanlrc-
bled the size of the code and exposed an implementation detail of frame_areaO. 
·nlere has to be a beller way! 
Look at the originaJ eode: 
int areal = framed_area(l,z); 
inl areal = framed_area(y,z); 
It may be wrong, but at least we can sec what it is supposed to do. We can keep 
this code if we pllt the check inside framed_areaO. 
5.5.2 The callee deals with errors 
C hecking for vaJid arguments within framed_areaO is easy, and errorO can still 
be used to report a pmblcm: 
inl framed_areaOnt x, int yl 
/I calculate area within frame 
( 
) 
canst int frame_width = 2; 
if (x-frame_width<=O II y-frame_width<--o) 
error("non-positive areaO argument called by framed_areaO"); 
retu rn a rea(x-f ram e_ width, y-f rame_ width); 
,., 

142 
CHAPTER 5 • ERRORS 
Tbis is rather nice, and we no longer have to write a test for each caU of 
framc_areaO. For a useful function that we call 500 times in a large program, that 
can be a huge advantage. Furthermore, if anything to do with the error handling 
changes, we only have lO modify the code in one place. 
Note something interesting: we almost unconsciously slid from the "caller 
must check the arguments" approach to the "function must check its own af/:,'-u-
mcnts" approach (also called "the callec checks" because a called function is often 
called "a callec"). One benefit of the latter approach is that the argument-checking 
code is in one place. We don't have to search the whole program for calls. Further-
more, that one place is exactly where the arguments arc to be used, so we have all 
the infonnalion needed easily available to do the check. 
Let's apply this solution to areaO: 
int area(int length, int width) 
{ 
II calculate area of a rectangle 
) 
if (length<=O II width <=0) error(" non-positive areaO argument"); 
return length· width; 
T his will catch all errors in calls to areaO, so we no longer need to check in 
framed_areaO. We might want to, though, to get a better - more specific - error 
message. 
Checking arguments in the function seems so simple, so why don't people 
do that always? Inattention to error handling is one answer, sloppiness is anOlher, 
but there arc also respectable reasons: 
1# can't modjJj thejimctioll dejinition: The fu nction is in a library that for 
some reason can't be changed. Maybe it's used by others who don't 
share your notions of what constitutes good error handling. Maybe it's 
owned by someone else and you don't have the source code. Maybe it's 
in a library where new versions come regula.rly so that if you made a 
change, you'd have to change it again for each new release of the library. 
17/£ CIliled jimc/i(m doe.m't know what to do i1l cllJe tf t:mJr: l11is is typically the 
case for library functions. The library writer can detect the error, but 
only you know what is to be done when an elTor OCCllrs. 
17u: called jilllc/i(m doeSII't kllfJW where it WIlJ called from: W hen you get an 
error message, it tells you that something is wrong, but nOl how lhe exe-
cuting program got to that point. Sometimes, you want an error message 
to be more specific. 
ItrJomulIlce: For a small function the cost of a check can be more than the 
cost of calculating the result. For example, that's the case with areaO, 
where the check also more than doubles the size of the function (that is, 

5.5 
RUN-TIME ERRO RS 
the number of machine instructions that need lO be executed, nOt just 
the length of the source code). For some programs, that can be critical, 
especially if the same information is checked repeatedly as functions call 
each other, passing information along more or less und langed. 
So what should you do? Check your arguments in a function unless you have a 
good reason not to. 
After examining a few related topics, we'll return to the question of how to 
deal with bad arguments in §5.9. 
5.5.3 Error reporting 
Let'S consider a slightly different question: once you have checked a set of argu-
mentS and found an error, what should you do? Somctimes you can return an 
"crror value." For example: 
/I ask user for a yes-or-no answer; 
II return 'b' to indicaw a bad answer (i.e., not res or no) 
char ask_user(slring question) 
{ 
) 
cout « question « "1 (yes or no)\n"; 
string answer = " "; 
dn »answer; 
if (answer =="y" II answer=="yes") return 'y'; 
if (answer =="n" II answer=="no") return 'n'j 
relurn 'b'; 
/I 'b' for ~ bad arlswer~ 
/I ca(culate area of a rectangle; 
/I return - 1 to indicate a bad argument 
inl area(inllenglh, int width) 
{ 
) 
if (lenglh<=O II width <=0) return - 1; 
return lenglh·width; 
-l1mt way, we can have the called function do the detailed checking, while lelting 
each callcr handle the error as desired. l11is approach seems like it could work, 
but it has a couple of problems that make it unusable in many cases: 
Now bmh the called function and all callers must lest. The caller has 
only a simple test to do but must still write that leSt and decide what to 
do if it fails. 
143 

'44 
( 
CHAPTER 5 • ERRORS 
A caller can forget to test. That can lead to unpredictable behavior fur-
ther along in the program. 
Many functions do IlOt have an "'extra" return value thai they Gill usc to 
indicate an error. For example, a function that reads an integer from 
input (such as, dll's operator » ) can obviously return any int value, so 
there is no int that it could return to indicate failure. 
TIle second case above - a caller forgetting to test - can easily lead to surprises. 
For example: 
int f(int x, inl y, int z) 
( 
} 
int areal = area(x,y); 
if (area1<=0) error(" non-positive area"); 
int areal = framed_area(l,z): 
int arca3 = framed_area(y,z); 
double ratio = double(areal)/area3; 
II ... 
Do YOli sec the errors? 111is kind of error is hard to find bCu'lUse there is no ob-
violls "wrong code" to look at: the error is the absence of a test. 
TRY THI S 
Test this program with a variety of vaJues. Prim out the values of areal , 
areal, areal, and ratio. Insert more tests until aJl errors are caught. How do 
you know that you caught all errors? This is not a triek question; in this par-
ticular e.'(ample you can give a vaJid argument for having caught all errors. 
There is another solution that deals Wilh that problem: using exceptions. 
5.6 Exceptions 
Like most modern programming languages, C++ provides a mechanism to help 
deal with errors: exceptions. 111e fundamental idea is 10 separate detection of illl 
error (which should be done in a called function) from lhe handling of an error 
(which should be done in the calling function) while ensuring that a detected 
error cannot be ignored ; that is, exceptions provide a mechanism that allows liS 
to combine the best of the various approaches to error handling we have ex-
plored so far. Nothing makes error handling easy, but exceptions make it easier. 

S.6 
EXCEPTIONS 
llle basic idea is that if a function finds an error that it cannm handle, it does 
110t return normally; instead, it throws an exception indic.'lting what weill wrong. 
Any elil'ect or indirect « Iller can catch the exception, that is, specify what to do if 
the called code lIsed throw. A function expresses interest in exceptions by using a 
try·block (as described in the following subsections) listing the kinds of excep· 
tions it wants to handle in the catch·parts of the try-block. If no caller catches an 
exception, the program tenninates. 
We'll come back to exceptions much later (Chapter 19) to see how to use 
them in slightly more advanced ways. 
5.6.1 Bad arguments 
Here is a version of areaO using exceptions: 
class Bad_area { }; 
1/ a type specifica lly for reporling errors from areaO 
1/ calculate area of a rectangle; 
1/1hrowa Bad_area exceplion in case of a bad argument 
int arca(int length, int width) 
( 
} 
if (length<=O II width <=0) throw Bad_area()i 
return length-width; 
lllat is, if the arguments arc OK, we return ule area as always; if not, we get Ollt 
of areaO using ule throw, hoping that some catch will provide an appropriate re· 
spollSe. Bad_area is a new type we defme with no mher purpose than to provide 
something unique to throw from area() so that some catch can recognize it as the 
kind of exception thrown by areaO. User·defined types (classes and enumeration) 
will be discussed in Chapter 9. The notation Bad_areaO means "Make an object 
of type Bad_area," so throw Bad_areaO means "Make an object of type Bad_area 
and throw it." 
We C.'lll now write 
int mainO 
try { 
int x= -l i 
int y=2; 
int :Z:= 4; 
1/ . . . 
inl area1 = area(x,Y)i 
int area2 = framed_area(l ,:Z:)i 
int areal = framed_area(y,z)i 
double ratio = area1/areali 
145 

146 
CHAPTER 5 • ERRORS 
catch (Bad_area) { 
cout « "Oops! bad arguments to area()\n"; 
) 
First note that this handles all caHs to areaO, both the one in mainO and the two 
through framed_areaO. Second, note how the handling of the error is cleanly sep-
arated from the detection of the co"or: mainO knows nothing about which func-
tion did a throw Bad_areaO, and areaO knows nothing about which function (if 
any) carcs to catch the Bad_area exceptions it throws. '11is separation is espe-
cially important in large programs written using many libraries. In slIch pro-
grams, nobody can "'just deal with an error by putting some code where it's 
needed,'" because nobody would wam to modify code in both the applicmion and 
in all of the libraries. 
5.6.2 Range errors 
Most real-world code deals with collections of data; that is, it uses all kinds of tao 
bles, lists, etc. of data elements to do a job. In the context of C++, we often refer 
to "collections of daLa" as am/ail/as. TIle most common and useful standard li-
brary container is the vector we imroduced in §4.6. A vector holds a number of 
elements, and we can determine that number by calling the vector's sizeO mem-
ber function. What happens if we try to use an element with an index (subscript) 
that isn't in the valid range [O:v.sizeO)? The general notation [Iow:high) means 
indices from low to high-l , that is, including low but not high: 
low: 
high: 
,---,----;r--.I. . . 'I ---'----'----'1::::) 
Before answering that question, we should pose another question and answer it: 
"'Why would you do that?" After all, you know that a subscript for v should 
be in the range [O,v.sizeO), so just be sure that's so! 
As it happens, that's easy to say but sometimes hard to do. Consider this plausi-
ble program: 
vector<inl> v; 
/I a vector ints 
int i; 
while (cin» i) v.push_back(i); 
for (int i = 0; i<=v.sizeO; ++i) 
/I get values 
/I print values 
cout « "vl" « i « "I == " « vlil« endl; 
Do you sec the error? Please try to spot it before reading Oil. It's not an uncom-
mon error. We have made such errors ourselves - especially late at night when 

5.6 
EXCEPTION S 
we were tired. Errors are always more common when you are tired or rushed. 
We use 0 and sizeO to try to make sure that i is always in range when we do v{i]. 
Unfortunately, we made a mistake. Look at the for· loop: t.he termination 
condition is i<=v.sizeO rather than the correCl i<v.sizeO. This has the unfortunate 
consequence that if we read in five integers we'll try to write out six. We try to 
read v(5], which is one beyond the end of the vector. ~111 is kind of error is so 
cOlllmon and "famous
n that it has several names: it is an example of an gffb)'-ont! 
erro'i a range error because the index (subscript) wasn't in the rallge required by 
the vector, and a OOU1IlU error because the index was not wit.hin the limit,s (bounds) 
of the vector. 
Here is a simpler version that produces the SallIe elTect: 
vector<inl> v(5); 
inl x = v(51; 
However, we doubt that you'd have considered that realistic and worth serious 
attention. 
So what actually happens when we make such a range eiTOr? 11,e subscript 
operation of vector knows the size of the vector, so it can check (and the vector 
we arc using does; sec §4.6 and §19.4). If that check fails, the subscript operation 
throws an exception of type oueoe range. So. if the olT-by-one code above had 
been part of a program that caught exceptions, we would at least have gotten a 
decent error message: 
int mainO 
try { 
vector<inl> v; 
int X; 
II a vector inls 
while (cin» x) v.push_back(x); 
for (int i = 0; i<=v.size(); ++i) 
II set values 
II prinl values 
cout « "vl" «i «") == n «v[i) «endl; 
} catch (out_oCrange_error) { 
cen « "Oops! Range enor\n"; 
return 1; 
} catch (".J ( 
/I calch all Olher exceptions 
) 
cerr « "Exception: something went wrong\n"; 
return 2; 
Note that a range enol' is really a special case of the argument elTors we discussed 
in §5.5.2. We didn't trust ourselves to consistently check the range of vector in-
dices, so we told vedor's subscript operation to do it for us. For the reasons wc 
147 

148 
(HAPTER 5 • ERRORS 
QUtiillC, vector's subscript function (called vector: :operator[J) rcpons finding an 
error by throwing an exception. \'\!hat clse could it do? lL has no idea what we 
would like to happen in case of a range error. The author of vector CQuldn't even 
know what programs his or her code would be part of. 
5.6.3 Bad input 
We'll postpone the detailed discussion of what to do with bad input umi] §1O.6. 
However, once bad input is detected, it is dealt with using the same techniques 
and language features as argument errors and range errors. Here, we'll just show 
how you can tell if your input operations succeeded. Consider reading a floating-
point number: 
double d = 0; 
dn»d; 
We can test if the last input operation succeeded by testing dn : 
if (cin ) ( 
/I all is well, and we can try reading again 
) 
else { 
/I the last read didn't succeed, so we take some other action 
} 
~nlerc are several possible reasons for that input operation's failure. ~111 C one that 
should cOlleem yOll riglll now is that therc wasn't a double for » to read. 
During the carly stages of dcvelopmcnt, we oftcn want to indicate that wc 
have found an error but aren't yet ready to do anything particularly clever about 
it; we JUSt want to report the error and terminate the program. Later, maybe, 
we'U come baek and do somcthing more appropriate. For example: 
double some_functionO 
{ 
) 
double d = 0; 
ein» d; 
if (!ein) error("couldn't read a double in 'some_fun ctionO' "); 
/I do something useful 
The string passed to errorO can thcn be printed as a help to debugging or as a 
message to the user. How can we write errorO so as to be useful in a lot of pro-

5. 6 
EXCEI' TlON $ 
grams? It can't return a value because we wouldn't know what to do with that 
value; instead errorO is supposed to tenninate the program after getting iLS mes-
sage written. In addition, we might want to take some minor action before exit-
ing, such as keeping a window alive long enough for us to read the mcssage. 
"lnat's '1Il obvious job for an exception (sec §7.3). 
TIle standard library defines a few exceptions, such as thc out_oe range 
thrown by vector. It also supplies runtime_error which is pretty ideal for our 
needs because it holds a string that can be used by an error handler. So, we can 
write our simple errorO like this: 
void error(string 5) 
( 
throw runlime_error(s); 
When we want to deal with runtime_error we simply catch it. For simple pro-
grams, c'-ltching runtime_error in mainO is ideal: 
int mainO 
try { 
1/ our program 
return 0; 
I/O indicates success 
) 
catch (runtime_error& e) ( 
) 
cerr « "runtime error: n « e.whatO« '\n'; 
keep_window_openO; 
return 1; 
1/ 1 indicates fail ure 
l11e c..LlI e.whalO extracts the error message from the runtime_error. The & in 
catch(runlime_error& e) { 
is an indicator that we want to "pass the exception by reference." For now, please 
treat this as simply an irrelevam technicality. In §8.5.4- 6, we explain what it 
means 10 pass something by reference. 
Note that we used cerr rather than cout for our error output: cerr is exactly 
like cout except that it is meant for error output. By default both cerr and cout 
write to tlle screen, but cerr isn't optimized so it is more resilient to errors, and on 
some operating systems it can be diverted to a different target, such as a file. 
Using cerr also has the simple effect of documenting that what we write relates to 
errors. Consequently, we usc (err for error messages. 
,.9 

150 
CH APTER 5 • ERRORS 
A5 it happens, ou,-oCrange is nm a runlime_error, SO catching runtime_error 
does not deal with the out_oe range errors that we might gel from misuse of 
vectors and other standard library container types. However, both ouCoC range 
and runlime_error arc "exceptions," SO we c.'tn catch exception to deal with bOlh: 
int mainO 
try { 
/I our program 
retum 0; 
/I 0 indicates success 
) 
catch (exception& e) { 
cerr « "error: n «e.whal()« '\n'; 
keep_window_openO; 
return 1; 
II , indicates failure 
catch ( ... ) ( 
) 
cerr « "Oops: unknown exception!\n"; 
keep_window_open(); 
return 2; 
112 indicates fail ure 
"Vc added catch( ... ) to handle exceptions of any type whatsoever. 
Dealing with exceptions of both type out_oerange and type runlime_error 
through a single type exception, said to be a common base (supertype) of both, is 
a most useful and general technique that we will explore in C hapters 13- 16. 
Note again that the return value from mainO is passed to "the system" that 
invoked the program. Some systems (such as Unix) often use that value, whereas 
others (such as Windows) typically ignore il. A zero indic."ltcs successful comple-
tion and a nonzero return value from main() indic."ltes some SOrt of failure. 
\¥hen you use errorO, you'll often wish to pass tWO pieces of informmion 
along to dcscribe the problem. In that case, just concatenate the strings describing 
those two pieces of information. 111is is so common thm we provide a second 
version of errorO for that: 
void error(string s1, Siring 52) 
( 
throw runtime_error(sl +s2); 
) 
This simple eITor handling will do for a while, until our needs increase signifi-
cantly and our sophistication as designers and programmers increases corre-
spondingly. Note that we can usc errorO independemly of how many function 

5.6 
EXCEPTIONS 
calls wc have done on thc way to thc crror: errorO will find its way to the nearest 
catch or runtime_error, typically thc onc in mainO. For examples or the use or ex-
ceptions and error(), sec §7.3 and §7.7. Ir you don't catch an exccption, you'll get 
a dcrault system error (an !;uncaught exception" error). 
TRY THI S 
To sec what an uncaught exception error looks like, run a small program that 
uses errorO without catching any exceptions. 
5.6.4 Narrowing errors 
In §3.9.2 we saw a nasty kind or error: when we assign a value that's "too large 
to fit" to a variable, it is implicitly truncated. For example: 
int x=2.9; 
char c = 1066; 
Here x will get the value 2 ratller than 2.9, because x is an int and ints don't have 
values that arc fractions or an integcr,just whole integers (obviously). Similarly, ir 
wc lise the common ASCII character set, c will get the value 42 (representing tJ1C 
character 0), rather than 1066, because there is no char with the value 1066 in that 
character set. 
In §3.9.2 we saw how we could protect ourselves against such narrowing by 
testing. Given exceptions (and templates; see §19.3) we can write a runction that 
tests and throws a runtime_error exception if an assigmnent or initialization 
would lead to a changed value. For example: 
int xl = narrow_cast<inl>(2.9); 
Illhrows 
int x2 = narrow_cast<inl>(2.0); 
/I OK 
char c1 = narrow_cast<char>(l066); 
/I throws 
char c2 = narrow_cast<char>(85); 
/I OK 
The < .. . > brackets arc the same as are used for vector<int>. Thcy are used 
when we need to speciry a type, rather than a vallie, to express an idea. TIley are 
called lem/)IIl/e arguments. We can use narrow_cast when we need to convert a 
value and we arc not sure "ir it will fit"; it is defined in std_lib_facililies.h and un-
plemcntcd using errorO. ~rne word cast meaus "type conversion" and indicates 
tile operation's role in dealing with something that's broken (like a caSt ou a bro-
ken leg). Note tlmt a cast doesn't changc its operand; it produces a new value cor-
responding to its operand or the required type. 
151 

152 
CHA PTER 5 • ERRORS 
5.7 Logic errors 
Once we have removed the initial compiler and linker errors, the program runs. 
Typically, what happens next is that no Output is produced or that the output that 
the program produces is just wrong. TIlis can occur for a number of reasons. 
Maybe your understanding of the underlying prOb'l'am logic is nawcd; maybe 
you didn't write what you thought you wrote; or maybe you made some "silly 
error" in one of your control statements, or whatever. Logic errors are lIsually 
the most difficult to find and eliminate, because at this stage the computer docs 
what you asked it to. Your job now is to figure Ollt why that wasn't really what 
you meant. Basically, a computer is a very fast moron. It docs exactly what YOli 
tell it to do, and that can be most humbling. 
Let us try to illustrate this with a simple example. Consider this code for 
finding the lowest, highest, and average temperature values in a set of dat.a: 
int mainO 
( 
vector<double> temps; 
double temp = 0; 
double sum = 0; 
double high_temp = 0; 
double low_temp = 0; 
/I temperatures 
while (cin» temp) 
II read and put into temps 
temps.push_backUemp); 
for (int i = 0; k temi>s.sizeO; H i) 
( 
) 
if(tempslij > high_temp) high_temp = tempslij; 
ir(temps[i] <: low_temp) low_temp = tempslil; 
sum += temps[i]; 
II compute sum 
cout « "High tempe rature: " «
high_temp« endl; 
cout « "Low tempe rature : " «
low_temp « endl; 
/I find high 
/I find low 
cout « "Average tempe rature: " « sum/temps.sizeO « e ndl; 
) 
We tested this program by entering the hourly temperature values from the 
weather center in Lubbock, Texas, for February 16, 2004 (Texas still uses 
Fahrenheit) : 

, 
5.7 
lOGIC ERRORS 
- 16.5, -23.2, - 24.0, - 25.7, 
7.5, 
12.6, 
23.8, 
25.3, 
40.3, 
42.6, 
39.7, 
35.4, 
'n le output was 
High temperature: 42.6 
low temperature: -26.1 
Average temperature: 9.3 
- 26.1, - 18.6, 
28.0, 
34.8, 
12.6, 
6.5, 
- 9.7, 
36.7, 
-3.7, 
-2.4, 
41 .5, 
-14.3 
A naive programmer would eonelude that the program works juSt fmc. An irre· 
sponsible programmer would ship it to a customer. It would be pnldent to leSt it 
again with another set of data. 11us time usc the temperatures from July 23, 2004: 
76.5, 
88.5, 
110.2, 
73.5, 
91.7, 
103.6, 
71.0, 
95.9, 
94.9, 
73.6, 
99.2, 
91.7, 
111is time, the output was 
High temperature: 112.4 
Low tempcrature: 0.0 
Average temperature: 89.2 
70.1, 
98.2, 
88.4, 
73.5, 
100.6, 
85.2, 
n.6, 
106.3, 
85.4, 
85.3, 
112.4, 
87.7 
Oops, something is not quite right. Hard frost (O.O°F is about -lS°C) in Lubbock 
inJuly would mean lhe end of the world! Did you spot the error? Si.nce low_temp 
was initialized at 0.0, it would remain 0.0 unless one of the temperatures in the 
data was below zero. 
TRY THIS 
Get this program to run. Check that our input really does produce that out-
put. Try to "break" the program (i.e., get it to give wrong results) by giving it 
oUlcr input seLS. What is the least amount of input you can give it to get it to 
fail? 
Unfortunately, there are more errors in this program. \tVhat would happen if all 
of the temperalllrcs were below zero? The iIutialization for high_temp has the 
equivalent problem to low_temp: high_temp will remain at 0.0 unless there is a 
higher temperature in the data. ntis program wouldn't work for the South Pole 
in winter either. 
153 

154 
CHAPTER 5 • ERR ORS 
~Inesc errors are fairly typical; they will n Ot cause any errors when you com-
pile the program or cause wrong results for "reasonable" inputs_ However, we 
forgot to think about what we should consider "reasonable." Here is an improved 
program: 
int mainO 
{ 
) 
do uble temp = 0; 
do uble sum = OJ 
double high_temp = - 1000; 
double low_temp = 1000; 
inl no_oCtemps = 0; 
/I initialize to impossibly low 
/I initialize to "impossibly high ~ 
while (cin» temp) { 
II read temp 
) 
++no_of_temps; 
II CQunt temperatures 
sum += temp; 
II compute sum 
if (lemp > high_temp) high_temp = tempi 
if (temp < low_temp) low_temp = tempi 
1/ find high 
/I find low 
cout « " High tempe rature: " «
high_temp« e ndl; 
cout « "Low te mperature: " «
low_temp « e ndl; 
cout « "Average temperature : " «
sumlno_oC remps« endl; 
Does it work? How would you be certain? How would you precisely define 
"work"? Where did we get the values 1000 and - 1000? Remember that we 
wam cd about "magic constants" (§5.5.1). Having 1000 and - 1000 as literal values 
in the middle of the progrnm is bad style, but arc tbe values also wrong? AI'e 
there places whcre the temperatures go below - 1000°F (-573°C)? Are there 
places where the temperatures go above IOOO°F (538°C)? 
TRY THIS 
Look it up. Check some information sources to pick good vaJues for the 
min_temp (the "minimum temperature") and max_temp (the "maximum 
temperature") constants for our program. Those values will determine the 
limits of usefulness of our program. 

, 
5.8 
ESTIMAT ION 
5.8 Estimation 
Imagine you bave written a program that docs a simple calculation, say, comput· 
ing lhe area of a hexagon. You run il and it gives the area -34.56. You juSt know 
that's wrong. Why? Because no shape has a negative area. So, you fix thaI bug 
(whatever il was) and get 21.65685. Is that right? That's harder to say because 
we don't usually keep the fonnula for the area of a hexagon i.n our heads. vVhat 
we mUSt do before making fools of ourselves by delivering a program that pro-
duces ridiculous results is just to check that the answer is plausible. In this case, 
that's easy. A hexagon is much like a square, vVe scribble our regular hexagon on 
a piece of paper and eyeball it to be about the size of a 3-by-3 square. Such a 
square has the area 9. Bummer, our 21.65685 can't be right! So we work over 
our program again and get 9.65685, Now, that just might be right! 
-nte general poim here has nothing to do with hexagons, -nle poi.nt is that 
unless we have some idea of what a correct answer will be like - even ever so ap-
proximately - we don't have a clue whether our result is reasonable, Always ask 
yourself this question: 
1. Is this answer to this particular problem plausible? 
You should also ask the more general (and often far harder) question: 
2. How would I recognize a plausible result? 
Here, we are not asking, ';VVhat's the exact answer?" or ';''''hat's the correct an-
swer?" -nmt's what we arc writing the program to tell us. All we want is to know 
that the answer is not ridiculous, Only when we know that we have a plausible 
answer docs it make sense to proceed with further work. 
Estima/ioll is a noble art that combines common sense and some very simple 
arithmetic applied to a few facts, Some people arc good at doing estimates in their 
heads, but we prefer scribbles "on the back of an envelope" because we find we 
get confused less often that way. What we call estimation here is an informal set 
of techniques that arc sometimes (humorously) called guess/ill/ali(nI because they 
combine a bit of guessing with a bit of calculation. 
TRY TH IS 
Our hexagon was regular with 2cm sides. Did we get that answer right? Just 
do the "back of the envelope" calculation, Take a picce a papcr and scribble 
on it. Don't feel that's below you. Many famous scientists have bcen greatly 
admired for their ability to come up with an approximate answer using a 
pencil and the back of an envelope (or a napkin), TIlls is an ability - a simple 
habit, really - that can save us a lot of tinlC and confusion, 
155 

156 
( 
C HAPTER 5 • ERR ORS 
Often, making an estimate involves coming up with estimates of data that arc 
needed for a proper calculation, but that we don't yet have. Imagine you have to 
test a program that estimates driving times between cities. Is a driving time of 15 
hours and 33 minutes plausible for New York City to Denver? From London to 
Nice? Why or why not? \¥hat data do you have lO "guess" to answer these ques-
tions? Often, a quick web search can be most helpful. For example, 2000 miles is 
not a bad guess on the road distance from New York City to Denver, and it 
would be hard (and illegal) to maintain an average speed of 130m/hr, so 15 hours 
is not plausible (15*130 is just a bit less man 2000). You can check: we overesti-
mated both the distance and the average speed, but for a check of plausibility we 
don't have to be exactly right; \ve just have to guess well enough. 
TRY THIS 
Estimate those driving times. Also, estimate the corresponding flight times 
(using ordinary commercial air traveJ). Then, try to verify your estimates by 
using appropriate sources, such as maps and timetables. We'd use online 
sources. 
5.9 Debugging 
When you have wriuen (drafted?) a program, it'll have errors. Small programs 
do occasionally compile and run correctly the first time you try. But if that hap-
pens for anything but a completely trivial program, you should at first be very, 
very suspicious. If it really did run correctly the first time, go tell your friends 
and celebrate - because this won't happen every year. 
So, when you have written some code, you have to find and remove the er-
rors. TImt process is usually called debuggillg and the errors bUI!J. Thc term bllg is 
often claimed to have originated from a hardware failure caused by insects in the 
electronics in the days when computers were racks of vacuum tubes and relays 
filling rooms. Several people have been credited with the discovery and the appli-
cation of the word bllg to errors in software. ~nle most famous of those is Grace 
Murray Hopper, the inventor of the COBOL programming hmguage (§22.2.2.2). 
Whoever invented the term more than 50 years ago, bllg is evocative and ubiqui-
tous. The activity of deliberately searching for errors and removing them is 
called debllgging. 
Debugging works roughly like this: 
I. Gel the program to compile. 
2. Get t.he program t.o link. 
3. Get the program to do what. it is supposed to do. 

5.9 
DEBUGGING 
Basicall y, we go through tins sequence again and again: hundreds of times, thou-
sands of limes, again and again for years for really large programs. Each time 
something doesn't work we have to find what caused the problem and ft,'\( it. I 
consider debugging the most tedious and time-wasting aspect of programming 
and will go to great lengths during design and programming to minimize the 
amount of time spent hunting for bugs. Others find that hunt thrilling and the 
essence of programming - it can be as addictive as any video game and keep a 
prOb'l'ammer glued to the terminal for days and nights (I can vouch for that from 
personal experience also). 
Here is how 1101 to debug: 
while (lhe program doesn't appear to work) { 
/I pseudo code 
Randomly look through the program for something that "looks odd" 
Change it to look better 
Why do we bother to mention this? It's obviously a poor algorithm with lillie 
guaralllee of success. Unfortunately, that description is only a slight caricature of 
what many people find themselves doing late at night when feeling particularly 
lost and clueless, having tried "everything eise," 
l11e key question in debugging is 
/-Iuw /./J01l11i JIII/uw / I/,e program actually work£(J com:ctly' 
If you can't answer that question, you arc in for a long and tedious debug ses· 
sian, and most likely your users are in for some frustration. We keep retuming to 
this point because anything that helps answer that question minimizes debugging 
and helps produce correct and maintainable programs. Basically, we'd like to de-
sign ollr programs so that bugs have nowhere to hide. That's typically toO much 
to ask for, but we aim to structure programs to minimize the chance of error and 
m,l.. ... imize the chance of finding the errors that do creep in. 
5.9.1 Practical debug advice 
Start thinking about debugging before you write the first line of code. Once you 
have a 101 of code written it's tOO late to try to simplify debugging. 
Decide how to report errors: "Usc errorO and catch exception in mainO" will 
be your default answer in lhis book. 
Make the program easy to TC.'1d so thal you have a chance of spotting the bugs: 
Commelll YOllr code welL 111at doesn't simply mean "Add a 101 of com-
ments." YOli don't say in English what is belter said in code. Rather, yOli 
say in the comments - as clearly and briefly as yOll can - what can't be 
said c1eaJ'ly in code: 
157 

158 
111c name of the program 
111c purpose of the program 
"Vho wrote this code and when 
Version numbers 
(HAPTER 5 • ERRORS 
What complicated code fragments arc supposed to do 
What the general design ideas arc 
How the source code is org-<lIlizcd 
What assumptions arc made about inputs 
What parts of the code afC still missing and what cases a f C still nOt 
handled 
Usc meaningful names. 
"n lat doesn't simply mean "Usc long names,n 
Usc a consistent layout of code. 
Your IDE tries to help, but it can't do everything and you arc the 
one responsible. 
"nlC style used in this book is a reasonable slarling point. 
Break code into small functions, cadl expressing a logical action. 
Try to avoid functions longer than a page or two; most functions 
will be much shon eI'. 
Avoid complicated code sequences. 
Try to avoid ncstcd loops, ncsted if-statemcnts, complicated condi-
tions, etc. Unfortunately, you sometimes need those, but remember 
that complicated code is where bugs can most easily hide. 
Use library facilities rathcr than your own code when you can. 
A library is likely to be betler thought out and beuer tested than 
what you could produce as an alternative while busily solving your 
main problem. 
lllis is prett), abstract just now, but we'll show you exrunplc after example as we 
go along. 
Get the program to compile. Obviously, your compiler is your best belp here. 
hs error mcssages arc usually hclpful - even if wc always wish for better ones -
and, unlcss you arc a rcal expert, assume that the compiler is always light; if you 
arc a real expert, this book wasn't written for you. Occasionally, you will feci that 

5.9 
DEBUGGING 
lhe rules the compiler enforces are stupid and unnecessary (they rarely arc) and 
that lhinb'5 could and ought to be simple., (indeed, but they are not). However, as 
they say, "a poor craftsman curses his tools." A good craftsman knows the 
strengths and weaknesses of his tools and adjusts his work accordingly. Here are 
some conunon compile-time errors: 
Is every string literal tenninated? 
cout « "Hello,« name« '\n'; 
Is every character literal terminated? 
cout « "He llo, " «
name« '\n; 
Is evelY block tenninated? 
in! f(in! a) 
{ 
/, oops! 
/I oops! 
if (a>{I) { ' - do something -, else { ' - do something else .' } 
/I oops! 
Is every set of parentheses matched? 
if (a<=O 
/I oops! 
x = fly); 
~nle compiler generally reports tllis kind of error "late"; it doesn't know 
you meant to type a closing parenthesis after the O. 
Is every name declared? 
Did you include needed headers (for now, #include "stdJ ib_facili· 
ties.h")? 
Is every name declared before it's uscd? 
Did you spcll all names con'celly? 
int count; , • ... -, ++Counl; 
/I oops! 
char Chi 
, • ... -, Cin»c; 
/I double oops! 
Did you lenninate each cxpression statement with a semicolon? 
x = sqrt(y)+2 
z = x+3; 
/I oops! 
We present more examples in this chapter's drills. Also, keep in mind t.he classifi-
cat.ion of errors from §5.2. 
After t.he program compiles and Ii.nks, ncxt comes what. is typically the hardest 
part: figuring am why the program doesn't do what it's supposed to. You look at 
the output and uy to figure out how your code could have produced that.. Actually, 
159 

160 
CHAPTER 5 • ERRORS 
flCSl you often look at a blank screen (or window), wondering how your probrram 
could have failed to produce any output. A common [mit problem with a Windows 
console mode program is lhat the console window disappears before YOLL have had 
a chance to see the output (if any). One solution is to call keep_window_openO 
from our Sld_lib_facilities.h at the end of mainO, 111CI1 the program will ask for 
input before exiting and you can look aI the output produced before giving it the 
input that willlcl it dose the window. 
When looking for a bug. carefully follow the code stalemem by statement 
from the last poinl that you afC sure it was correct. Pretend you're the computer 
executing the program. Docs the outpUt match your expectations? or course not, 
or you wouldn't be debugging. 
Often, when you don't see the problem, the reason is that you "seen 
what you expect to sec rather than what you wrote. Consider: 
for (int i = 0; i<=mall; ++j) { 
for (inl i=O; O<mall; ++i); 
/I oops! (twice) 
/I print the elements of v 
coul « "vl"« i « "1==="« v[il« '\n'; 
1l1is last example came from a real program written by experienced pro· 
grammers (we expect it was wTinen very late some night). 
Often when you do not sec the problem, tile reason is that there is too 
much code being executed between the point where the program pro· 
duced the last good output and tile next output (or lack of output). Most 
programming environments provide a way to execute ("step through") 
the statements of a program one by one. Eventually, you'll learn to usc 
such facilities, but for simple problems and simple programs, you can 
just temporarily put in a few extra output statements (using cerr) to help 
you see what's going on. For example: 
inl my_fcl(int a, double d) 
{ 
} 
inl res = 0; 
cerr « "my_fcU " «a« ","« d « ")\0"; 
1/ . .. misbehaving code here. 
cerr « "my_felO relurns"« res« '\n'; 
rei urn res; 
Insert statements thal check invariants (that is, conditions tl13t should aI· 
ways hold; sec §9.4.3) in sections of code suspected of harboring bugs. 
For example: 
in! my_complicated_funclion(inl a, inl b, inl c) 
1/ the arguments are positive and a < b < c 

5. 10 
PRE - AND POST-CONDITIONS 
if (! (ka && a<b && b<c)) /I ! means ~ not · and && means ~ and · 
error("bad arguments for mcf"); 
1/ .. . 
If that doesn't have any cffect, insert invariillns in sections of code nOi 
suspected of harboring bugs; if yOLl can't find a bug, you are almost cer-
tainly looking in the wrong place. 
A statemell1 that states (asserts) an invariant is called an (lSJCrliQlI (or just an (mer/). 
Interestingly enougll, there an:: Illillly effective ways of programming. Differell1 
people successfully usc dramatically different techniques. Many differences in de-
bugging technique come from differences in the kinds of programs people work 
on; others seem to have to do with differences in the ways people think. To the best 
of our knowledge, there is no one best way to debug. One thing should always be 
remembered, though: messy code can easily harbor bugs. By keeping your code as 
simple, logic. .... l, and well formatted as possible, you decrease your dcbug time. 
5.10 Pre- and post-conditions 
Now, let us rctum to the question of how to deal with bad arguments to a func-
lion. ' 11e call of a function is basically the best point to think abOllt COlTect code 
and to catch errors: this is where a logically separatc computation starts (and 
cnds on the rctu1ll). Look at what we did in thc piece of advice abovc: 
int my_complicated_funclion (int a, int b, int c) 
II the arguments are positive and a < b < c 
{ 
) 
if (!(Cka && a<b && b<c» 
/I! means "not" and && means "and" 
enor("bad arguments for mef"); 
1/ . . . 
First, we statcd (ill a comment) what the function rcquired of its arguments, and 
then we checked that this requiremcm held (throwing an exception if it did not). 
' 1tis is a good basic strategy. A requircment of a function upon its argument 
is often callcd a pre-colldlium: it must be true for the function to perform its action 
correctly. -nle question is JUSt what to do if the pre-condition is violated (doesn't 
hold). We basically have two choices : 
I. Ignore it (hopc/assume lhal ail callers givc corrcct argumcnts). 
2. C hcck it (and I'cport the errol' somehow). 
,., 

'.2 
(HAPTER 5 • ERR ORS 
Looking at it this way, argument types arc just a way of having the compiler 
check the simplest pre-conditions for us and report them at compile lime. For 
example: 
int x = my_complicated_function{1, 2, "horsefealhers"); 
Here, the compiler will catch that the requircmcill ("pre-condition") thaI the third 
argument be an integer was violated. Basically, what we arc talking about here is 
what to do with the requirements/pre-conditions that the compiler can't check. 
Our suggestion is to always document pre-conditions in comments (so that a 
caner can sec what a function expects). A function with no comments docu-
mented will be assumed to bandle every possible argument value. BUl should we 
believe that callers read those comments and follow the rules? Sometimcs wc 
havc to, but thc "chcck the arguments in the callce" rule could be statcd '·Let a 
function check its pre-conditions." We should do that whencver we don't sec a 
reason not to. The reasons mOSt often given for not checking pre-conditions arc: 
Nobody would give bad arguments. 
It would slow down my code. 
It is too complicated to check. 
111e first reason can be reasonable only when we happen to know "who" 
calls a function - and in real-world code that can be very hard to know. 
TIle second reason is valid far less often lilan people think and should most 
often be ignored as an example of "premawre optimization." You can always re-
move checks if they really turn out to be a burden. You cannot easily gain the 
correctness they ensure or get back the nights' sleep you lost looking ror bugs 
those tests could have caught. 
111e lilird reason is the serious one. It is easy (once you arc an expericnced 
programmer) to find examples where checking a pre-condition would take signif-
iC<U1t1y more work than executing the function. An example is a lookup in a dic-
tionary: a pre-condition is that the dictionary entries arc sorted - and verifying 
that a dictionary is sorted " ... n be far more expensive than a lookup. Sometimes. it 
can also be difficult to express a pre-condition in code and to be sure that you ex-
pressed it COITCCtly. However, whcn you write a function, always consider if you 
can write a quick check of thc pre-conditions, and do so unless you have a good 
reason not to. 
Writing pre-conditions (even as comments) also has a significant benefit for 
the quality of your programs: it forces you to think abOLlt what a function re-
quires. If you can't state that simply and prccisely in a couplc of commcnt lines, 
you probably haven't thought hard enough about what you arc doing. Experi-
ence shows that writing those pre-condition comments and lile pre-condition tests 
helps you avoid many design mistakes. We did mention that we hated debug-

5. 10 
PRE- AN D POST-CON D IT IO NS 
ging; explicitly stating pre-conditions helps in avoiding design errors as well as 
catching usage errors early. Writing 
int my_complicated_function(int a, int b, int c) 
/I the arguments are positive and a < b < c 
{ 
if (!(O<a && a<b && b<c» 
/I! means ~ not " and && means ~ atl d " 
error("bad arguments for met"); 
/I. 
saves you time and grier compared with the apparenuy simpler 
int my_complicated_function (int a, int b, inl c) 
( 
1/ . . 
) 
5.10.1 Post-conditions 
Stating pre·conditions helps us improve our design and catch usage errors early. 
Can this idea or explicitly stating requirements be used elsewhere? Yes, one more 
place immediately springs to mind: the return value! After all, we typic.:-.1ly have 
to state what a runClion returns; that is, ir we return a value rrom a rUilction we 
arc ahvays making a promise about the return value (how else would a caller 
know what to expect?). Let's look at our area rUilction (rrom §5.6.1) again: 
II calculate are.l of a rectangle; 
/I throw a Bad_area exception in case of a bad argument 
int area(int length, inl width) 
{ 
) 
if (length<=O II width <=0) throw Bad_area(); 
return length· width; 
It checks its pre-condition, but it doesn't state it in Ule comment (that may be OK 
ror such a short runction) and it assumes that the computation is correct (fiat's 
probably OK ror such a trivial compuullion). However, we could be a bit more 
explicit: 
inl area(int length, int width) 
/I C.l1culate area of a rectangle; 
/I pre·conditions: length and width are positive 
,.3 

'64 
CHAPTER 5 • ERR O RS 
II post-condition: returns a positive value that is the area 
( 
} 
if (lenglh<=O II width <=0) enor("area() pre-condition"); 
int a = length -width; 
if (a<=O) error(nareaO post-condition"); 
return a; 
We couldn't check the complete post-condition, but we checked the part that said 
that it should be positive. 
TRY THI S 
FUld a pair of vaJucs so that the pre-condition of this version of area holds, 
but the post-condition doesn't. 
Pre- and post-conditions provide basic sanity checks in code. As such they arc 
closely connected to the notion of invariants (§9.4.3), corrccmcss (§4.2, §S.2), 
and testing (Chapter 26). 
5.11 Testing 
How do we know when to stop debugging? Well, we keep debugging until we 
have found all the bugs - or at least we try to. Ho .. \' do we know that we have 
found the last bug? We don't.. "The last bug" is a programmers' joke: there is no 
such creature; we never find "the last bug" in a large program. By the time we 
might have, we arc busy modifying the program for some new usc. 
In addition to debugging we need a systematic way to search for errors. 111is 
is called les/il/gand we'll get back to that in §7.3, the exercises in Chapter 10. and 
in Chapter 26. Basically, testing is executing a program with a large and system-
atically selected set of inputs and comparing the results to what was expected. A 
run with a given set of inputs is called a lesl case. Realistic programs can require 
millions of test cases. Basically, systematic testing cannot be done by humans typ-
ing in one test after another, so we'll have to wait a few chapters before we have 
the tools necessary to properly approach testing. However, in the meantime, re· 
member that we have to approach testing with the attitude that finding enol'S is 
good. Cons ider: 
Attitude 1: 
I'm smarter than any program! I' ll break that @*$%" code! 
Attitude 2: 
I polished this code for two weeks. It's perfect! 

C HAP TE R 5 DR il l 
Who do you think will find more errors? Of course, the very best is an experi-
enced person with a bit of "'attitude 1" who coolly, calmly, patiently. and system-
atically works through the possible fail ings of the program. Good testers arc 
worth their weight in gold. 
We try to be systematic in choosillg our test cases and always try hOlh cor-
feCt and incorrect inputs. §7.3 gives the first example of this . 
..; Drill 
Below arc 25 code fragments. Eaeh is meant to be inserted into this "scaffolding": 
#include "sld_lib_facililies.h" 
int mainO 
try { 
) 
<<your code here» 
keep_window_openO; 
return 0; 
catch (exception& e) ( 
) 
cerr « "error: n «
e.whatO« '\n'; 
keep_window_openO: 
return 1; 
catch ( ... ) ( 
) 
cerr « "Oops: unknown exception!\n"; 
keep_window_open(); 
return 2; 
E.1.ch has zero or more errors. Your task is to find and remove all errors in each 
program. \¥hell you bave removed those bugs, the resulting program will com· 
pile, run, and write "Success!n Even if you think you have spotted an error, you 
still need to enter the (original, unimproved) program fragment and test it; you 
may have guessed wrong about what the error is, or there may be more errors in 
a fragment than you spotted. Also, one purpose of this drill is to give you a feel 
for how your compiler reacts to different kinds of errors. Do not enter the scaf-
folding 25 times - that's a job for cut and paste or some similar "mechanical" 
technique. Do not fix problems by simply deleting a statement; repair them by 
changing, adding, or deleting a few characters. 
'.5 

1'66 
1. 
2. 
3. 
4. 
5. 
6. 
7. 
B. 
9. 
10. 
II. 
12. 
13. 
14. 
15. 
16. 
17. 
lB. 
19. 
20. 
21. 
22. 
23. 
2;~. 
25. 
Cout« "Success!\n"; 
coul « "Success!\n; 
cout « "Success" « !\n" 
cout « success« endl; 
(HAPTER 5 • ERRORS 
string res = 7; vector<int> v(10); v(51 = res; coul « "Success!\n"; 
vector<int> v(10); v(5) = 7; if (v(5) !=7) CQut« "Success!\n"; 
if (cond) caul « "Success!\n "; else cout« "Fail!\n"; 
bool c = false; if (e) coul« "Success!\n"; else cout « "Fail!\n "; 
siring s = "ape"; boo c = "fool "<s; if (e) coul« "Success!\n "; 
string s = "ape"; if (5=="fool") coul« "Success!\n"; 
string s = nape"; if (s=="fool ") coul < "Success!\n"; 
string s = "ape"; if (s+"fool ") coul < "Success!\n"; 
veclor<char> v(5); for (int i=O; O<v.size(); ++i); coul« "Success!\n"; 
vector<char:> v(5); for (int i=O; k=v.size(); ++il ; cout « "Success!\n"; 
siring s = "Success!\n "; ror (int i::O; k6; ++i) cout « sri]; 
ir (true) Ihen coul« "Success!\n"; else coul« "Fail!\n"; 
int x = 2000; char c = x; if (c==2000) cout « "Success !\n"; 
siring s = "Success!\n"; for (int i::O; k 10; ++i) cout « stili 
vector vIS); for (int i=O; k=v.size(); ++i) ; coul « "Success!\n"; 
inl i=O; inl j = 9; while (kl0) ++j; if (j<i) coul« "Success!\n"; 
inl x = 2; double d = 51(x-2); if (d==2·x+O.5) coul « "Success!\n"; 
slring<char> s = "Success!\n"; fo r (int i::O; i<=10; ++i) coul « sri]; 
inl i=O; while (i<10) ++j; if (j<i) cout « "Success!\n"; 
inl x = 4; double d = 51(x-2); if (d=2*x+O.5) coul « "Success!\n"; 
cin« "Success!\n"; 
Review 
1. Name four major types of errors and briefly define each one. 
2. ""hat kinds of errors can we ignore in student programs? 
3. What guarantees should every completed project ofTer? 
4. List three approaches we can take to eliminate errors in programs and 
proouce acceptable software. 
5. Why do we hate debugging? 
6. What is a syntax error? Give five examples. 
7. What is a type error? Give five examples. 
8. What is a linker error? Give three examples. 
9. What is a logic error? Give three examples. 
lO. List four potential sources of program errors discussed in the text. 
11. How do you know if a result is plausible? What techniques do yOll have 
to answer such questions? 
12. Compare and contrast having the caller of a function handle a run·time 
error vs. the called function's handling the run·time error. 
13. Why is using exceptions a belter idea than returning an "error value"? 

( HAPTER 5 EXERCISES 
14. How do you test if an input operation succeeded? 
15. Describe the process of how exceptions are thrown and caught. 
16. Why, with a vecior called v, is v[v.size()] a range error? What would be 
the result of calling tills? 
17. Defme prNoluii/ioll and POSI-amdilioll; give an example (that is not the 
areaO function from tllis chapter), preferably a computation that requires 
a loop. 
IS. When would you 1101 test a pre-condition? 
19. When would you lIoltest a post-condition? 
20. What are the steps in debugging a program? 
2 1. Why docs commenting help when debugging? 
22. How docs testing differ from debugging? 
Terms 
argument error 
assertion 
calch 
compile-time error 
container 
debugging 
error 
Exercises 
exception 
invariant 
link-time error 
logic error 
post-condition 
pre-condition 
range error 
requirement 
run-time error 
syntax error 
testing 
throw 
type error 
I. If you haven't already, do the Try this exercises from this chapter. 
2. TIle following program takes in a temperature value in Celsius and con-
verts it to Kelvin. This code has many errors in it. Find the errors, list 
them, and correct the code_ 
double ctok(double c) 
( 
int k = c + 273.15; 
return int 
int mainO 
double c = 0; 
1/ converts Celsius to Kelvin 
1/ declare input variable 
tin » d; 
1/ retrieve teml>Cfature to input variable 
double k = ctok{"c"); 
1/ convert temperature 
Coul « k « endl ; 
1/ print out temperature 
167 

168 
CH A PTER 5 • ERRORS 
3. Absolute zero is the lowest temperature that can be reached; it is - 273.lSoC, 
or OK. The above program, even when corrected, wi.1l produce erroneous 
results when given a temperature below this. Pl.ace a check in the main pnr 
gram that will produce an error if a temperature is given below - 273.1S°C. 
4. Do exercise 3 again, but this time handle the error inside ctok(). 
S. Add to the program so that it can also convert from Kelvin lO Celsius. 
6. Write a program that converts from Celsius to Fahrenheit and from 
Fahrenheit to Celsius (fomlUla in § 4.3.3). Use estimation (§5.8) to sec if 
yOUT results are plausible. 
7. Quadratic equations arc of the fonn 
a_x'! +b· x+ c = 0 
To solve these, one uses the quadratic fomlUla: 
2a 
There is a problem though: if b2- 4 llC is less than zero, then it will faiL 
Write a program t.hat can calculate x for a quadratic equation. Create a 
function that prints out the rOOts of a quadratic equation, given a, h, " 
and have it throw an exception if bl - 4ac is less than zero. Have the main 
function of the program call the function, and catch the exception if there 
is an error. YVhen lhe prog.-am detects an equation with no real roots, 
have it print out a message. How do you know that your results arc piau· 
sible? Can you check that they are correct? 
8. Write a program that reads a series of numbers and stores them in a 
vector<int>. After the user inputs all the numbers he or she wishes to, 
ask how many of the numbers the user wants to sum. For an answer .N, 
print the sum of the first N elements of the vector. For example: 
"Please enter some numbers (press 'I' at prompt to SLOp):" 
122313 2415 
"Please elller how many of lhe numbers you wish to sum, starting 
from the first:" 
J 
"TIle sum of the first 3 numbers: 12, 23, and 13 is 48." 
Handle all inputs. For example, make sure to give an error message if the 
user asks for a SUUl of more numbers than there arc in the vector. 

CHAPTER 5 POSTSCRIPT 
9. Modify the program from exercise 6 to write OUl an error if the result 
cannot be represented as an in!. 
10. Modify the program from exercise 8 to usc double instead of into Also, 
make a vector of doubles containing the X-I differences between adja-
cent values ,md write out that vector of differences_ 
11 . Write a program that writes out the fU'sl so many values of the Fibonacci 
series, that is, t.he serics that St.art.S with 1 1 2358 1321 34. 111c next 
number of the SCI;es is the sum of the twO p" cvious oncs. Find the largcst 
Fibonacci number that fits in an int. 
12. Implement a little guessing game called (for somc obscure reason) <'Bulls 
and Cows." ' 11e program has a vector of four integers in the range 0 to 9 
and it is the user's task to discover those numbers by repeated guesses. 
Say the number to be guessed is 1234 and the user guesses 1359; the re-
sponse should be "I bull and I cow" because the user gOl one digit (I) 
right and in the right position (a bull) and one digit (3) right but in the 
wrong position (a cow). TIle guessing continucs until the user gets four 
bulls, that is, has the four digits correct and in the correct ordcr. 
13. ~111 e program is a bit tedious because the answcr is hard-coded into thc 
program. Make a vcrsion where the user can play repeatedly (without 
stopping and restarting the program) and each game has a new set of 
four digits. You can get four random digits by calling the random num-
ber generd.tor randinl(10) from Sld_lib_facililies.h four times. You will 
note that if you run that program repeatedly, it will pick the same se· 
quence of four digits each time you start the program. To avoid that, ask 
the user to enter a number (any number) and call srand(n) where n is the 
number the user entered before e'llling randint(10). Such an n is called a 
Jeet~ and different seeds give different sequences of random numbers. 
14. Read (day-of-the-week,value) pairs from standard input. For example: 
Tuesday 23 Friday 56 Tuesday -3 ThurSday 99 
Collect all thc values for each day of the week in a vector<int>. Write out 
the values of the seven day-of-the-week vectors. Print out the sum of the 
values in each vector. Ignore illegal days of the week, such as Funday, but 
accept conunon synonyms such as Mon and monday. Write out the num-
ber of rejected values. 
Postscript 
Do you think we overemphasize errors? As novice programmers we would have 
thought so. TIle obvious and natural reaction is "It simply can't be that bad!" 
Well, it is that bad_ Many of the world's best brains have been astounded and 
169 

CHAPTER 5 • ERRORS 
confounded by the difficulty of writing correct programs. In our experience, 
good mathematicians are the people most likely to underestimate the problem of 
bugs, but we all quickly exceed our natural capacity for writing progratns that 
arc correct the first time. You have been warned! Fortunately, after 50 years 01" so, 
we have a lot of experience in organizing code to minimize problems, and tech-
niques to find the bugs that we - despite our best efforts - inevitably leave in Ollr 
programs as we first write thelll. The techniques and examples in this chapter arc 
a good start. 

~!. . 
r 
6 
Writi ng a Program 
"Progranuning is understanding." 
-Kristen Nygaard 
W
riting a program involves gradually refining your ideas 
of what you want to do and how you wam to express it. 
In this chapter and the next, we will develop a program from a 
fU'st vague idea through stages of analysis, design, implementa-
tion, testing, redesign and fe-implementation. Our aim is to give 
you some idea of the kind of thinking that goes on when you de-
velop a piece of code. In the process, we discuss program organi-
zation, user-defined types, and input processing. 
171 

172 
6.1 A problem 
6.2 Thinking about the problem 
6.2.1 Stages of development 
6.2.2 Strategy 
6.3 Back to the calculator! 
6.3.1 First attempt 
6.3.2 Tokens 
6.3.3 Implementing tokens 
6.3.4 Using tokens 
6.3.5 Back to the drawing board 
6.4 Grammars 
'04.1 A detour: English grammar 
6.4.2 Writing ill grammar 
6.1 A problem 
( H A PTE R 6 • W RITIN G A "ROG RA M 
6.5 Turning a grammar into code 
6.5. 1 Implementing grammar rules 
6.5.2 b pressions 
6.5.3 Terms 
6.5.4 Primary expressio ns 
6.6 Trying the first version 
6.7 Trying the second version 
6.8 Token streams 
6.8.1 Implementing Token_stream 
6.S.2 R("ading toke ns 
6.B,3 Reading numbers 
6.9 Program structure 
Writing a program starts with a problem; thal is, you have a problem th .. t you'd 
like a program to help solve. Understanding that problem is key to a good pro· 
gram. After all, a program that solves the wrong problem is likely to be of little 
usc to you, however elegant it may be. TIlere arc happy accidcnts when a pro· 
gram just happens to be useful for something for which it was never intended, 
but let's not rely on such rare luck. What we want is a program that simply and 
cleanly solves the problem we decided to solve. 
At this slage, what \,,'ould be a good program to look at? A program that 
Illustrates design and programming techniques 
Gives us a chance to explore the kinds of decisions that a programmer 
must make and the considerations that go into sudl decisions 
Doesn't require tOO many new programming language constnlcts 
Is complicated enough to require thought about its design 
Allows for many variations in its solution 
Solves an easily understood problem 
Solves a problem that's worth solving 
Has a solution that is small enough to completely present and com· 
pletely comprehend 
We chose "Get the computcr to do ordinary arithmetic on expressions wc type 
in"; that is, we wallt to writc a simple calculator. Such programs arc clcal'ly usc· 
ful; every desktop computer comes ""lth such a program, and you call even buy 
computers specially built to run nothing but such programs: pocket calculatOrs. 

6.2 
THINKING ABOUT THE PROBLEM 
For example, if you enter 
2+3.1· 4 
lhe program should respond 
14.4 
Unfonumucly, such a calculator program doesn't give us anything we don't al-
ready have available on our computer, but that would be tOO much to ask from a 
first program. 
6.2 Thinking about the problem 
So how do we start? Basically, think a bit about the problem and how to solve it. 
"irst think about what the program should do and how you'd like to interact 
with it. Later, you can think about how the program could be written to do that. 
Ti-y writing down a brief sketch of an idea for a solution, and see what's wrong 
with that first idea. Maybe discuss the problem and how to solve it with a friend. 
Trying l"O explain something to a friend is a marvelous way of figuring out what's 
wrong with ideas, even belter than writing lhem down; paper (or a computer) 
doesn't talk back at you and challenge your assumptions. Ideally, design isn't a 
lonely activity. 
Unfortunately, there isn't a general strategy for problem solving that works 
for all people and all problems. Thcre arc whole books that claim 10 help YOll be 
better at problem solving and another huge branch of literature that deals with 
program design. We won't go there. I.nslead, we'll present a page's wonh of sug· 
gestions for a general strategy for the kind of smaller problems an individual 
might face. After that, we'll quickly proceed to try a lit these suggestions on our 
tiny calculator problem. 
When reading our discussion of lhe calculator program, we recommend that 
YOll adopt a more than usually skeptical attitude. For realism, we evolve our pro· 
b"l7llll through a series of versions, presenting the reasoning that leads 10 each vcr· 
sian along the way. Obviollsly, much of that reasoning must be incomplete or 
even faulty, or we would finish the chapter early. As we go along, we provide ex· 
amples of the kinds of concerns and reasoning that designers and progra.nullers 
deal with all the time. We don't reach a version of the program that we arc happy 
with untillhe end of the next chapter. 
Please keep in mind that for this chaptcr and the next, the way we get to the 
rmal vcrsion of tbe program - the joumey through partial solutions, ideas, and mis-
takes - is aI least as important as that [mal version and more important than lhe lan-
guagc.tcclmical details \\-"e encounter along the way (we will get back to those later). 
173 

174 
CHAPTER 6 • WRITING A PRO GR AM 
6.2.1 Stages of development 
Here is a bit of terminology for program development. As YOli work all a prob-
lem you repeatedly go through lhese stages: 
Andysis: Figure out what should be done and write a description of your 
(current) understanding of thal. Such a description is called a sd 0/ re-
quirements or a Jpecjfico.tioll. We will not go into details about how slich re-
quirements arc developed and written down. 'ntat's beyond the scope of 
this book, but it becomes increasingly important as the size of problems 
IIlcrcascs. 
Design: Create an overall SllUcturc for the system, deciding which parts 
the implementation should have and how those parts should communi-
cate. As part of the design consider which tools - such as libraries - can 
help you Structure the program. 
Implementation: Write the code, debug it, and tcst that it actually docs 
what it is supposed to do. 
6.2.2 Strategy 
Here are some suggestions that - when applied thoughtfully and with imagina-
tion - help with many programming projects: 
What is the problem to be solved? The first thing to do is to try to be 
specific abolll what you are trying to accomplish. TIllS typically involves 
constmcting a description of the problem or - if someone else gave you 
sueh a statement - trying to figure out what it really means. At lhis point 
you should take the user's point of view (not the programmer/imple-
menter's view); that is, you should ask questions abOlll what the pro-
gram should do, not about how it is going to do it. Ask: "\¥hat can this 
program do for me?" and "How would I like to interact with this pro· 
gram?" Remember, most of us have lots of experience as users of com-
puters on which to draw. 
Is the problem statement clear? For real problems, it never is. Even 
for a student exercise, it can be hard to be sufficienlly precise and 
specific. So we try to clarify it. It would he a pity if we solved the 
wrong problem. Another pitfall is to ask for too much. When we lly 
to figure out what we want, we easily get too greedy/ambitious. It is 
almost always belter to ask for less to make a program easier to spec-
ify, easier to understand, easier to use, and (hopefully) casier to im-
plement. Once it works, we can always build a fancier "version 2.0" 
based on Ollr experience. 

6.2 
TH INKING ABOUT THE PROBLEM 
Docs the problem seem manageable, given the lime, skills, and tools 
available? There is IitLle point ill starting a project L1lat you couldn't 
possibly complete. If there isn't sufficient lime to implement (includ· 
ing testing) a program that docs all that is required, it is usually wise 
not to start. Instead, acquire more resources (especially more time) 
or (best of all) modify the requirements to simplify your task. 
lly breaking the program into manageable parts. Even the smallest pro-
gram for solving a real problem is large enough to be subdivided. 
Do you know of any tools, libraries, etc. L1mt might help? Tlle answer 
is almost always yes. Even at the earliest stage ofleaming to program, 
you have parts of the C++ standard library. Later, you'll know large 
parts of that standard library and how to find marc. You'll have 
graphics and CUI libraries, a matrix library, etc. Once you have 
gained a little experience, you will be able to find thousands of li-
braries by simple web searches. Remember: There is little value in 
reinventing the wheel when you arc building software for real usc. 
When learning to program it is a dilTerent matter; then, reinventing 
tile wheel to sec how that is done is often a good idea. Any time you 
save by using a good library can be spent on other pans of your 
problem, or on rest. How do you know that a library is appropriate 
for your task and of sufficient quality? ~l1lat 'S a hard problem. Part of 
the solution is to ask colleagues, to ask in discussion groups, and to 
try small examples before committing to use a library_ 
Look for parts of a solution that CRn be separately described (and po-
tentially used in several places in a pmgram or even in other pro-
grams). To find such pans requires experience. so we provide many 
exmnples throughout this book. We have already used vector, string, 
and iostreams (cin and cout). Tlus chapter gives the first complete 
examples of design, implementation, and use of program pans pro-
vided as user-defined £)'pes (Token and Token_stream). Chapters 8 
and 13- 15 present many more examples lOgelher Wilh their design 
rationales. For now, consider an analogy: If we were to design a car, 
we would start by identifying parts, such as wheels, engine. scats, 
door handles, etc., on which we could work separately before assem-
bling the complete c.'lr. There arc tcns of thousands of such parts of a 
modem c."lr. A real·world program is no dilTerent in that respect, ex' 
cept of course that the partS are code. We , ... ·ould not try to build a car 
directly out of raw materials, such as iron, plastics, and wood. Nor 
would we try to build a major program directly out of Gust) the ex-
pressions, statemenlS, and types provided by the language. Designing 
175 

176 
(HAPTER 6 • W RI TING A PROG RAM 
and implementing such parts is a major theme of this book and of 
soft\'vare development in general; see user-defined types (Chapler 9), 
class hierarchies (Chapler 14), and generic types (Chapler 20). 
Build a small, limited version of the program lhat solves a key part of the 
problem. When we start, we rarely know the problem well. We of len 
think we do (don't we know what a calculator prObrralll is?), but we 
don't. Only a combination of thinking about the problem (analysis) and 
experimentation (design and implementation) gives us the solid under-
standing that we need to wrile a good program. So, we build a smail, 
limited version 
To bring out problems in our understanding, ideas, and tools. 
To see if details of the problem statement need changing 10 make the 
problem manageable. It is rare to find that we had anticipated every-
thing when we analyzed the problem and made the initial design. 
We should take advantage of the feedback that writing cooe and 
testing give us. 
Sometimes, such a limited initial version aimed at experimentation is 
called a prototype. If (as is likely) our first version doesn't work or is so 
ugly and awkward that we don't want to work with it, we throw it away 
and make another limited version based on our experience. Repeat until 
we find a version that we arc happy with. Do not proceed with a mess; 
messes just grow with time. 
Build a full-scale solution, ideally by using parts of the initial version. 
The ideal is to grow a program from working parts rather than writing 
all the code at once. TIle alternative is to hope that by some mil"acle an 
untested idea \vill work and do what we want. 
6.3 Back to the calculator! 
How do we want to illleract with the calculator? '1mt's easy: we know how to 
usc cin and cout, but graphical user interfaces (G UIs) are not explained lIntil 
Chapter 16, so we'll stick to the keyboard and a console window. Given expres-
sions as input from the keyboard, we evaluate them and write out the resulting 
value to the screen. For example: 
Expression: 2+2 
Result : 4 
Expression: 2+2-3 
Result : 8 
Expression: 2+3-2515 
Result: 0 

6.3 
BACK TO TH E CALCU LATOR! 
·nIe expressions, c.g., 2+2 and 2+r3, should be entered by the user; the rest is pm-
duced by the program. We dIose to OUiput "Expression: " to prompt lhc user. \¥e 
could have chosen "Please enter an expression followed by a newline" but that 
seemed verbose and poinDess. On D1e other hand a pleasanDy shon prompt, sud1 
as >, seemed tOO cryptic. Sketching out such examples of usc carly on is important. 
TIley provide a very practical definition of what the program should minimally do. 
When discussing design and analysis, such examples of usc are c,111OO use ctl.JeJ. 
When faced with DIe cakulator problem for the first time, most people come 
up with a first idea like this for the main logic of lhe program: 
read_a_line 
calculate 
write_result 
/I do the work 
111is kind of "scribbles" d carly isn'l code; it's called psetuw calk. We tend to usc it 
in the early stages of design when we arc not yCt ccrtain cxactly what our nota-
tion means. For example, is "calculatc" a function call? If so, what would be its 
arguments? It is simply tOO early to answer such questions. 
6.3.1 First attempt 
At this point, wc are not really ready to write lhe calculator program. We simply 
haven't thought hard enough, but thinking is hard work and - likc most pro-
grammers - we arc anxious to writc some code. So let's take a chance, write a 
simple calculator, and sec where it leads us. 111e first idea is something like 
#include "stdJib_fadlities.h" 
inl mainO 
( 
coul« "Please enter expression (we can handle + and -): It; 
int Ivai = 0; 
int rval; 
char op; 
inl res; 
d n» lval>>op>>rval; 
if (op=='+') 
res = Ivai + rval; 
else if (op=='-') 
res = lval - rval; 
II read something like 1 +) 
/I addition 
/I subtraction 
coul « "Result : "« res« '\n'; 
keep_window_openO; 

178 
CHAPTER 6 • W RITI NG A PROGRAM 
return 0; 
) 
11lat is, read a pair of values separated by an operator, such as 2+2, compute the 
result (in this case 4), and print the resulting value. We chose the variable names 
Ivai for left-hand value and rval for right.lland value. 
'Illis (sort of) works! So what if this program isn't quite complete? It fecls 
great to gel something running! Maybe this programming and computer science 
stuff is easier than the rumors say. WcU, maybe, but let's not gel too c.micd away 
by an early success. Let's 
1. Clean up the code a bit 
2. Add multiplication and division (e.g., rJ) 
3. Add the ability to handle mOTC than one operand (e.g., 1+2+3) 
In particular, we know that we should always check that our input is reasonable 
(in our hurry, we "forgot") and that testing a value against many constants is best 
done by a switch-statement rather than an if-statement. 
lllC "chaining" of operations, such as 1+2+3+4, we will h,mdlc by adding the 
values as they are read; that is, we start with 1, see +2 and add 2 to 1 (getting an in-
tenllediate result 3), see +3 and add that 3 to our intenllediatc resuh (3), and so on. 
After a few false starts and after cOlTecnng a few synta.:x and logic errors, we get: 
#include "std_lib_faeilities.h" 
int mainO 
{ 
cout « "Please ente r expression (we can handle +, - , . , and /): "; 
int Ivai = 0; 
int rval; 
char o p; 
ein» lval; 
/I read leftmost operand 
if (!ein) e rror("no first o pe rand"); 
while (ein>>op) ( 
/I read operator and right-hand operand repeatedly 
ein» rval; 
if (lein) error("no second o pe rand"); 
swilch(o p) { 
case '+' : 
Ivai += rval; /I add: Ivai ", Ivai + rval 
break; 
case '- ' : 
Ival-= , val; /I subtract: Ivai = Ivai - rval 
break; 

6.3 
BACK TO THE CALCULATOR ! 
} 
case '. ' : 
Ivai "= rval; 
1/ multiply: Ivai = Ivai ' rval 
break; 
case 'f: 
Ivai 1= rval; 
/1 divide: Ivai = Ivai I rval 
break; 
default : 
1/ not another operator: print result 
} 
cout « "Result: "« Ival « '\n'; 
keep_window_openO; 
return 0; 
error{"bad expression"); 
lllis isn't bad, but then we try 1+2·3 and see that the result is 9 and not the 7 our 
arithmetic teachers told us was the right answer. Similarly, 1-r3 gives -3 ralher 
than the -5 we expected. We are doing the operations in the wrong order: 1+2·3 
is caJculated as (1 +2)"3 rather t.han as t.he conventionaJ 1+(2"3). Similarly, 1-2·3 is 
calculated as (1-2)·3 rat.her than as the convemional 1- (2"3). Bummer! We m.ight 
consider the convention that "multiplication binds tighter than addition" as a silly 
old convention, but hundreds of years of convention will not disappear just to 
simplify our programming. 
6.3.2 Tokens 
$0 (somehow), we have LO '"'look ahead" on the line LO see if t.here is a " (or a I). If 
so, we have LO (somehow) adjust the evaJuation order from the simple and obvi-
ous left-ta-right order. Unfortunately, trying to barge ahead here, we immediately 
hit a couple of snags: 
I. Vle don't actually require an expression to be on one line. 1;or example: 
+ 
2 
works perfectly with our code so far. 
2. How do we search for a " (or a I) among digits and plusses on several 
input lines? 
3. How do we remember where a " was? 
4. How do we handle evaJuation that's not strictly left·to·right (e.g., 1+2·3)? 
Having decided to be super-optimists, we'll solve problems 1-3 first and not 
worry about 4 until later. 

180 
CHAPTER 6 • WRITI NG A I'ROGRAM 
Also, we'll ask around for help. Surely someone will know a convenlional 
way of rcading "stuff," such as numbers and operators, from input and storing it 
in a way that lets us look at it in convenient ways. The conventional and very 
useful allswcr is "tokcnize": first input characters arc read and assembled into 
IORellJ, so if you type in 
45+11 .517 
the program should produce a list of tokens representing 
45 
+ 
11.5 
I 
7 
A token is a sequence of characters thaI represenLS something we consider a unit, 
such as a number or an operator. 11mt's the way a C++ compiler deals with its 
source. Actually, "LOkcnizing" in some form or anomer is the way most analysis 
of text starts. Fo llowing the example of C++ expression, we sec the need for 
three kinds of tokens: 
Floating-point-literals: as defined by C++, e.g., 3.14, O.274e2, and 42 
Operators: e.g., +, - , . , I, % 
Parentheses: (, ) 
TIle nonling-point-literals look as if they may become a problem: reading 12 
seems much easier than reading 12.3e-3, but calculators do tend to do noaling-
point arithmetic. Similarly, wc suspcct that we'll have to accept parentheses to 
have our c.llculator dcemed useful. 
How do we represent such tokens in our program? We could try to keep 
track of where each tokcn startcd (and cnded), but that gets messy (cspecially if 
we allow expressions to span line boundaries). Also, if we keep a number as a 
string of characters, we later havc to figurc out what its value is; that is, if we sec 
42 and store the characters 4 and 2 somewhere, we thcn later have to figure out 
thalthose characters represent the numerical value 42 (i.e., 4-10+2). "The obvious 
- and conventional - solution is to represent cach token as a (kind,vallle) pair. 
TIle kind tells liS if a token is a number, an operator, or a parcmhesis. For a nUIll-
ber, and in this example only for a number, we lise its numerical valuc as its wlue. 
So how do we express the idea of a (kilul,w/ue) pair in code? We define a type 
Token to represent tokens. Why? Remember why we lise types: they hold the 
data we need and give us uscful operations on that data. For example, ints hold 
inlegers and give us addition, subtraction, muhiplication, division, and remain-

6.] 
BACK TO THE CALCULATOR ! 
der, whereas strings hold sequences or characters and give us concatcnation and 
subscripting. The C++ language and its standard library givc us many types 
such as char. inl, double, siring, vector, and oslream, but not a Token type. In 
ract, there is a huge number or types - thOllsands or tens or thousands - that we 
would like to have, but the languagc and its standard library do not supply them. 
Among our ravorite types that arc not suppo rted are Matrix (sec Chapter 24), 
Oate (sec Chapter 9), and infinite precision integers (try searching the web ror 
MBignum"). Ir YOll lhink about it ror a second, you'll rcalize that a languagc can· 
not supply tens or thousands or types: who would define theEll, who would im· 
plement them, how would you find thcm, and how thick would the manual have 
to bc? Like most modcrn languagcs, C++ escapcs that problcm by letting us de-
fine our own types (u.ser-liejilled type;) when we need them. 
6.3.3 Implementing tokens 
What should a token look like in our program? In other words, what would wc 
like our Token type to be? A Token must be able to represent operators, such as + 
and - , and numeric values, such as 42 and 3.14. -nlC obvious implementation is 
something that can represent what "kind" a token is and hold thc numeric value 
ror tokens that have onc: 
Token: 
kind : 
value : 
plus 
Token: 
kind: 
value: 
number 
3.14 
-n lcrc arc many ways that this idea could bc reprcsentcd in C++ codc. Hcre is 
the simplest that we round userul: 
class Token { 
public: 
/I a very simple user-defined type 
char kind; 
double value; 
}, 
A Token is a type Oike int or char), so it can bc used to define variables and hold 
values. It has twO parts (called mcmhn:s): kind and value. The kc)"vord class 
means "user·dcfined lypcn; it indicatcs that a type with z.cro or more members is 
being dcrmed. ' 11e first member, kind, is a character, char, so that it conveniently 
can hold '+' and '.' to represent + and *. We can use it to make types like this: 
Token I ; 
t.kind = '+'; 
Token 12; 
/II is a Token 
/I t represents a + 
II t2 is another Token 
181 

182 
CHAPTER 6 • WRITING A PROG RAM 
12.kind = '8'; 
/I we use the digit 8 as (he ~ k i nd " for numbers 
12.value = 3.14: 
We lise the member access notation, obftd_lUllfle . memlxr_'lIllJle, (0 access a mem-
ber. YOll can read I.kind as "I's kind" and 12.value as "t2's value." We can copy 
Tokens just as we can copy inls: 
Token II = I; 
/I copy ini(ialization 
if (lI.kind != I..kind) error("impossible!"): 
t = t2; 
/I assignment 
coul «
I.value; 
/I wi ll prim 3.14 
Given Token, we can represent the expression (1.5+4)-11 using seven tokens like 
this: 
I 'I' I 
1.5 
4 
1'·'1"'1 
'8' 
'8' 
'8' 
11 
Note that for simple tokens, such as +, we don't need the value, so we don't use 
its value member. We needed a character to mean "number" and picked '8' just 
because '8' obviously isn't an operator or a punctuation character. Using '8' to 
mean "number" is a bit cryptic, but it'll do for now. 
Token is an example of a C++ user-defined lype. A user·defined type can 
have member fu nctions (operations) as well as data members. 111el"e can be 
many reasons for defining member functions. Here, we'll just provide two Jllem· 
ber functions to give us a more convenient way of initializing Tokens: 
class Token ( 
public: 
char kind; 
/I what kind of token 
double value: 
/I for numbers: a value 
Token(char chI 
II make a Token from a char 
:kind(ch), value(O) {} 
Token(char ch, double val) 
II make a Token from a char and a double 
:kind(ch), value(val) {} 
) ; 
~nlese two member funClions are of a special kind called (Olu/nll/Orl. ~nley have 
the same name as their type and are lIsed to iniliaJize ("conslnlct") Token objecLS. 
For example: 
Token 11 ('+'): 
II initialize II so thalll .kind = '+' 
Token t2('8',11.5); 
/I initialize t2 so that t2.kind = '8' and t2.value = 11 .5 

6 .3 
BACK TO THE CALCULATOR! 
In the first constructor, :kind(ch), value(O) means "Initialize kind 10 ch and set 
value to 0." In the second constructor, :kind(ch), value(val) means "Initialize kind 
to ch and set value to vat." In both cases, nothing more needs to be done to con· 
struct the Token, so the body of the function is empty: { }. The special initializer 
syntax (a mt:mm.,,- illitialiur list) starting with a colon is used only in constructors. 
Note that a constructor docs not return a value. No return lype is required 
(or allowed) for a constmctor. For more abolll constructors, sec §9.4.2 and §9.7. 
6.3.4 Using tokens 
So, maybe now we can complete our calculator! However, maybe a small aillount 
of planning ahead would be worthwhile. How would we use Tokens in the calcu-
lator? 'We can read out input into a vector of Tokens: 
Token geCtokenO; 
/I read a token from cin 
veclor<Token> 10k; 
/I we'll put (he tokens here 
int mainO 
{ 
while (ein) ( 
) 
/I . .. 
} 
Token I = geCloken(); 
lok.push_back(I); 
Now we can read an expression first and evaluate later. For example, for 11 -12, 
we gel 
'8' 
1"'1 
'8' 
11 
12 
We can look at that to find the multiplication and its operands. Having done that, 
we can easily perform the multiplication because the numbers II and 12 are 
stored as nUllleric values and not as strings. 
Now let's look at more complex expressions. Given 1+2-3, 10k will contain 
five Tokens: 
1 
1'·'1 
'8' 
2 
1'·'1 
'8' 
'8' 
] 
183 

184 
C HAPTER 6 • WRITING A PROGRAM 
Now we could fmd the multiply operation by a simple loop: 
for (int i = 0; i<tok.sizeO; ++i) { 
if (lok[i].kind=='·') ( 
/I we found a multiply! 
double d = lokli-l1.value· tok[i+l1.valuc; 
II now what? 
) 
Yes, but now what? What do we do with that product d? How do we decide in 
which order to evaluate the sub-expressions? Well, + comes before · so we can't 
juSt evaluate from [cft to right. We could try right-la-left evaluation! That would 
work for 1+r3 but not for 1"2+3. Wo rse still, consider 1+2"3+4. This example 
has to be evaluated "inside OUl": 1+(2*3)+4. And how will we handle parentheses, 
as we eventually will have to do? We seem to have hit a dead end. We need to 
back off, stOp progrnnuning for a while, and think about how we read and un-
derstand an input string and evaluate it as an arithmetic expression. 
So, this fIrst emhusiastic attempt to solve the problem (writing a caJculator) ran 
alit of steam. 111m's not unconmlOn for lirSl tries, and it serves the imponant role 
of helping us understand the problem. tn this case, it even gave us the useful notion 
of a token, which itself is an example of the notion of a (1/(lmc,w/ue) pair that we will 
encoumer again and again. However, we must always make sure that such rela-
tively thoughtless and unplanned "coding" doesn't steal too much time_ We should 
do vely little progranuning before we have done at least a bit of analysis (under-
standing the problem) and design (deciding on an overall structure of a solution)_ 
TRY THIS 
On tlle other hand, why shouldn't we be able to fmd a simple solution to this 
problem? It doesn't seem to be all that difficult. If nothing clse, trying would 
give us a better appreciation of tlle problem and the eventual solution. Con-
sider what you might do right away. For example, look at the input 12.5+2. 
We could tokenize that, decide that the expression was simple, and compute 
the answer. That may be a bit messy, btl[ straightforward, so maybe we 
could proceed in this direction and fmd something that's good enough! Con-
sider what to do if we found both a + and a • in tlle line 2+3· 4? lllalloo can 
be handled by "brute force." How would we deal with a complica.ted expres-
sion, such as 1+2·314%5+(6-7·(8))? And how would we deal with errors, 
such as 2+-3 and 2&3? Consider this for a while, maybe doodling a bit on a 
piece of paper trying to outline possible solutions and interesting or impor-
tant input expressions. 

6.3 
BACK TO THE CALC ULATOR! 
6.3.5 Back to the drawing board 
Now, we will look at the problcm again and try not to dash ahead with another 
h,llr·baked solution. One thing that we did discover was that having the program 
(calculator) evaluate only a singlc expression was tedious. We would like to be 
able to compute several expressions in a single invocation of our program; that is, 
our pseudo code grows to 
while (noC finished) ( 
read_a_line 
calculate 
write_result 
) 
II do the work 
Clearly this is a complication, but when we think about how we usc caiculaLOrs, 
we realize that doing several calculations is very common. Could we let the user 
invoke our program several times to do several calculations? We could, but pro-
gram Startup is unronunately (and unreasonably) slow on many modern operat-
ing systems, so we'd better not rely on that. 
As we look at this pseudo code, our early attempts at solutions, and our ex-
amples or use, several questions - some with telllative answers - arise: 
I. Ir we type in 45+517, how do we find the individual parts 45, +, 5, I, and 7 
in the input? (rokenize!) 
2. What tcnninates an input expression? A newline, or course! (Always be 
suspicious or "of course": "of course" is not a reason.) 
3. How do we represelll 45+517 as data so that we can evaluate it? Before 
doing the addition we must somehow turn the characters 4 and 5 into 
the integer value 45 (i.e., 4· 10+5). (So tokenizing is part of the solution.) 
4. How do we make sure that 45+517 is evaluated as 45+(517) and not as 
(45+5)n? 
5. What's the value of 517? About .71, but that's not an integer. Based on 
experience with calculators, we know that people would expect a 
noating-poilll result. Should we also allow noating-poilll inputs? Sure! 
6. Can we have variables? For example, could we write 
v=7 
m=9 
Good idea, bUllet's wait until later. Let's first get the basics working. 
Possibly the most important decision here is the answer to question 6. In 
§7.8, you'll sec Ihal if we had said yes we'd have almost doubled the size or the 
185 

.86 
( HAPTER 6 • WRITING A " ROGRAM 
initial projecl. That would have m OTC than doubled the time needed LO gel the ini-
lial version running. OUT guess is that if yOlI really arc a novice, it would have at 
least quadrupled the effon needed and most likely pushed the project beyond 
your patience. It is most important to avoid "(eature creep" early in a projecl. in-
stead, always first build a simple version, implementing the essential features 
only. O nce you have something funning, you call gel morc ambitious. It is far 
easier to build a program in stages man all at once. Saying yes to question 6 
would have had yet another bad effect: it would have made it hard to resist the 
temptation to add further "neat features" along the line. How about adding the 
usual mathematical functions? How about adding loops? Once we stan adding 
"neat rcaturcs" it is hard to stop. 
From a programmer's point or view, questions 1,3, and 4 are the most both-
ersome. T hey are also related, because once we have round a 45 or a +, wha! do 
we do with lhem? That is, how do we store them in our program? Obviously, to-
kenizing is pan or the solution, but only pan. 
What would an experienced programmer do? When we arc raced with a 
tricky technical qucstion, there orten is a standard answer. We know that people 
have been writing calculator programs ror at least as long as there have been 
computers taking symbolic input rrom a keyboard. TIlal is at least ror 50 years. 
TIlere has to be a standard answer! In SUdl a silUation, the experienced program-
mer consults colleagues ancUor the literature. It would be silly to barge on, hop-
ing to beat 50 years or experience in a moming. 
6.4 Grammars 
111ere is a standard answer to the question or how to make sense or expressions: 
first input characters are read and assembled into tokens (as we discovered). So ir 
you lype in 
45+11 .517 
the program should produce a list or tokens representing 
45 
+ 
11.5 
I 
7 
A token is a sequence or characters that represents something we consider a unit, 
sLich as a number or an operator. 

6.4 
G RAMMARS 
After tokens have been produced, the program must ensure that complete 
expressions are understood correctly. For example, we know that 45+11 .517 
means 45+(1 1.517) and not (45+11.5)17, but how do we teach the program that 
useful mle (division "binds tighter" than addition)? TIle standard answer is that 
we write a grall/lllar defining the syntax of our input and then write a program 
that implements the mles of that grammar. For example: 
/I a simple expression grammar: 
Expression: 
Term 
Expression It+" Term 
Expression "- " Term 
Term: 
Primary 
Term "." Primary 
Term "/" Primary 
Term "%" Primary 
Primary: 
Number 
"(" Expression ")" 
Number: 
floati ng-point-literal 
/1 addition 
/I subtraction 
/I multiplication 
/I division 
/I remainder (modulo) 
/I grouping 
Illis is a set of simple rules. The last rule is read '''A Number is a floating-paint-
literal." "n le next-to-Iast rule says, "A Primary is a Number or '(' followed by an 
Expression followed by 'l'." TIle mles for Expression and Term are similar; each 
is defined in terms of one of the mles that follow. 
As seen in §6.3.2, our tokens - as borrowed from the C++ defmilion - arc 
floating-poi nt-literal (as dermed by C++, e.g., 3.14, O.274e2, or 42) 
+, - , . , /, % (the operators) 
(, ) (the parentheses) 
From ollr first tentative pseudo code to this approach using tokens and a gram-
mar is actually a huge conceptual jump. It's the kind of jump we hope for but 
rarely manage without help. TIlis is what experience, the literature, and Mentors 
arc for. 
At first glance, a grammar probably looks like complete nonsense. Techn.ical 
notation often docs. However, please keep in mind that it is a general and elegant 
(as YOli will evelllually appreciate) notation for something you have been able to 
do since middle school (or earlier). You have no problem calculating 1-r3 and 
187 

'88 
CHAPTER 6 • W RIT ING A PROGRAM 
1+2-3 and 3"2+412. Il seems hardwired in your brain. However, could you ex· 
plain how you do it? Could you explain it well enough for someone who had 
never seen conventional arithmetic to grasp? Could you do so for every combi-
nalion of operators and operands? To articulate an explanation in sufficient detail 
and precisely enollgh for a computer to understand, we need a nOlation - and a 
granuTIar is a most powerful and conventional tool for thal. 
How do you read a grammar? Basically, given some input. you start with the 
"lOp rule," Expression, and search through the niles to find a match for the 10-
kens as they arc read. Reading a stream of tokens according to a grammar is 
called parsing. and a program that does that is often called a parser or a S)'1I1ax (lJIa-
Iyur. Our parser reads the tokens from left to right, JUSt like we type them and 
read thelll. Let's try something really simple: Is 2 an expression? 
I. An Expression must be a Term or end with a Term. That Term must be a 
Primary 0 1" end with a Primary. ~nl at Primary must start with a ( 0 1" be a 
Number. Obviollsly, 2 is not a (, but a floaling-poini-lileral. which is a 
Number, which is a Primary. 
2. That Primary (the Number 2) isn·t preceded by a I . ., or %, so it is a 
complete Term (rather than the end of a I, . , or % expression). 
3. That Term (the Primary 2) isn't preceded by a + or - , so it is a complete 
Expression (nuller than the end of a + or - expression). 
So yes, according to OUI" grammar, 2 is an expression. We can illustrate the pro· 
gression through the grammar like this: 
Parsing the number 2 
Expression: 
Tern} 
Expression "+" -'em} 
Expression "-" Tenn 
Term: 
Primary 
Term ... " Primary 
Term "f" Primary 
Term "%" Primary 
Primary, 
Number 
"(" Expression ~) " 
Number: 
fioating·poi.lll·literal 
ExTon 
lenll 
t 
Primary 
t 
Number 
1 
f1oating·point·literal 
t 
2 

6.4 
GRAMMARS 
l11is represents the path we rollowed through the definitions. Retracing ollr path, 
we can say that 2 is an Expression because 2 is a floating-poi nt-literal, which is a 
Number, which is a Primary, which is a Term, which is an Expression. 
Let's uy something a bit more complicated: Is 2+3 an Expression? Namrally, 
much or the reasoning is the same as ror 2: 
I. An Expression must be a Term or end with a Term, which must be a 
Primary or end with a Primary, and a Primary must start with a ( or be a 
Number. Obviously 2 is not a (, but it is a floating-poi nt-literal, which is 
a Number, which is a Primary. 
2. 11mt Primary (the Number 2) isn't preceded by a I, . , or 0/.;., so it is a com-
plete Term (rather than the end or a I, . , or % expression). 
3. 
~nlat Term (t.he Primary 2) is rollowed by a +, so it is the end or the first 
part or an Expression and we must look ror the Term arter the +. In ex-
actly the same way as we round that 2 was a Term, we find that 3 is a 
Term. Since 3 is not rollowed by a + or a - it is a complete Term (rather 
than the first part or a + or - Expression). 111erdore, 2+3 matches the 
Expression + Term mle and is an Expression. 
Again, we can illustrate this reasoning graphical! y (again leaving out tlle floating-
point-literal to Number mle to simpliry): 
Parsing the expression 2 + 3 
Expression 
Expressioll : 
Expression 
T,= 
t 
Expression " +~ Tern} 
Expression u_~ l erm 
Term 
Tern} 
Term: 
I 
I 
Primary 
Pri='Y 
Pri='Y 
Term " .~ Primary 
I 
I 
Tenn ~ /" Primary 
Term "<Ifo" Primary 
Prirllary: 
Number 
Number 
Number 
1 
1 
"(" Expression ")" 
Number: 
flooting-poim-literaJ 
2 
+ 
3 
"nlis represents tlle path we rollowed through the definitions. Retracing our path, 
we can say that 2+3 is an Expression because 2 is a leon which is an Expression, 3 
is a Term, and an Expression rollowed by + rollowcd by a Term is an Expression. 
189 

190 
CHAPTER (, • W RITI NG A PROGRAM 
"111C real rcason we are interested in granunars is that they can solve our 
problem of how to correctly parse expressions with bOlh + and . , so let's try 
45+11.5*7. However, ';playing computer" following the rules in detail as we did 
above is tediolls, so let's skip some of tJ1C intermediate steps lhal we have already 
gone through for 2 and 2+3. Obviously, 45, 11.5, and 7 arc all floating-point-
literals which arc Numbers, which arc Primarys, so we can ignore all niles below 
Primary. So we gel: 
1. 45 is an Expression foUowcd by a +, so we look for a Term 10 finish the 
Expression+ Term nile. 
2. 11 .5 is a Term followed by . , so we look for a Primary to finish lhe Term· 
Primary n ile. 
3. 7 is Primary, so 11.5*7 is a Term according to the Term· Primary nile. 
Now we can sec that 45+11.5-7 is an Expression according to the 
Expression;rerm rule. In particular, it is an Expression that first docs the 
multiplication 11.5·7 and then the addition 45+11 .5·7, jllst as if we had 
written 45+(11 .5·7). 
Again, we can illustrate this reasoning graphically (again leaving out the floating-
poinl·lileral lO Number mle 10 simplify): 
Parsing the expression 45 + 11.5 * 7 
Expression: 
T,= 
Expression "+" Term 
Expression .. -" Term 
Term: 
Primary 
Term ... ~ Primary 
Term .. ". Primary 
Term "qio" Primary 
Primary: 
Number 
"(" Expression ")" 
Number: 
f1oating-point-literal 
Expression 
I 
T,= 
J", 
I 
Number I 
45 
Expression 
Ternl t 
llrimary 
I 
Number I 
+ 
11 ~ 
Primary 
I 
Number I 
• 
1 
Again, this represents the path we rollowed t.hrough the definitions. Note how the 
Term· Primary nile ensures that 11.5 is multiplied by 7 father than added to 45. 

b.4 
G RAMMARS 
You may find this logic hard to follow at first, but many humans do read 
grammars, and simple gr<ulullars arc not hard to understand. However, we were 
not really trying to teach YOIl to understand 2+2 or 45+11 .5+7. Obviously, you 
knew that already. We were trying to find a way for the computer to "under-
stand
n 45+11 .5*7 and all the other complicated expressions you might give it to 
evaluate_ Actually, complicated grammars are not fit for humans to read, but 
computers are good at it. TIley follow such grammar rules quickly and correctly 
with the greatest of case. Following precise rules is exactly what computers arc 
good at. 
6.4.1 A detour: English grammar 
If you have never before worked with grammars, we expect that your head is 
now spinning. In fact, it may be spinning even if you have seen a grammar be-
fore, but t.'lke a look at the following grammar for a very small subset of English: 
Sentence : 
Noun Verb 
/I e.g., C++ rules 
Sentence Conjunction Sentence 
/I e.g., Birds fly but fish swim 
Conjunction : 
"and" 
"or" 
"but" 
Noun: 
"birds" 
"fi sh" 
"C++" 
Verb: 
"rules" 
"fly" 
"swim" 
A sentence is built from parts of speech (c_g_, nouns, verbs, and cOI~uncti o ns) . A 
sentence can be parsed according to these rules to determine which words arc 
nouns, verbs, etc. This simple grammar also includes semantiC<llly meaningless 
sel1lences sllch as "C++ fly and birds rules," but fixing that is a different maHer 
belonging in a far more advanced book. 
Many have been taught/shown such rules in middle school or in foreign Ian· 
guage class (e.g., English classes). 1llese grammar niles arc very fundamental. In 
fact, there are serious neurological arguments for such rules being hardwired into 
our brains! 
191 

192 
CHAPTER 6 • WRITING A PROG RAM 
Now look at a parsing tree as we used above for expressions, but lIsed here 
for simple English: 
Parsing a simple English sentence 
Sentence : 
Noun Verb 
Sentence 
Sentence Conjunction Semence 
I 
I 
I 
Conjunction : 
.""'-
"or" 
Sentence 
Conjunction 
Sentence 
"but" 
Il Il 
Noun: 
'"birds" 
Noull 
V,,,, 
Noun 
Verb 
"rlllh" 
1 
1 
1 
1 
"c++" 
Verb: 
Mrolcs" 
"fiy" 
'"birds" 
"ny" 
"bul ~ 
~ fish " 
"swim" 
~swimn 
11,is is nm all that complicated. If YOll had trouble with §6A then please go back 
and fe-read it from the beginning; it may make more sense the second lime 
through ! 
6.4.2 Writing a grammar 
How did we pick those expression grammar fules? "Experience" is the honest 
answer. ~nle way we do it is simply the way people usually write expression 
grammars. However, writing a simple grammar is pretty straiglltforward : we 
need to know how to 
1. Distinguish a rule from a token 
2. Put one rule after another (Jeqllencill~ 
3. Express alternalive patterns (af/emu/ion) 
4. Express a repeating pattem (repeti/ion) 
5. Recognize the grammar rule LO start with 

6.5 
TURN ING A GRAMMAR INTO CODE 
Different textbooks and different parser systems usc different notational conven-
tions and different terminology. For example, some call LOkens lennill,llJ and rules 
T!Q1l-tennvUlLs or pnxJuchoTlS. We simply put tokens in (double) quotes and Slart with 
the first rule. Alternatives arc put on separate lines. For example: 
list: 
"{" Sequence "}" 
Sequence: 
Element 
Element " ," Sequence 
Element: 
"A" 
"8" 
So a Sequence is either an Element or an Element followed by a Sequence using 
a comma for separation. An Element is either lhe letter A or lhe letter 8. A list is 
a Sequence in "curly brackel.S." We can generale lhese lists (how?): 
{ A } 
{ B } 
{ A,B } 
{A,A,A,A,8 } 
However, these arc not lisl.S (why not?) : 
{} 
A 
{ A,A,A,A,8 
{A,A,C,A,8 } 
{ A B e} 
{A,A,A,A,8, } 
~nlis sequence rule is not one you learned in kindergarten or have hardwired 
into your brain, bUl it is still not rocket science. See §7.4 and §7.8.1 for examples 
of how we work with a grammar to express syntactic ideas. 
6.5 Turning a grammar into code 
-nlere arc many ways of gelling a computer 10 follow a grammar. We'll use the 
simplest aile: we simply wrile one function for each grammar rule and lise our 
type Token to represent tokens. A program that implements a grammar is of len 
called a /J<1I"SeY. 
193 

194 
C HAPTER 6 • WRITING A PROGRAM 
6.5.1 Implementing grammar rules 
To implement OUT calculator, we need four functions: one to read tokens plus one 
for eadl rule in OUT gnunmar: 
geUokenO 
expression() 
fermO 
primaryO 
II read characters and compose tokens 
/I uses cin 
/I deal with + and -
/I calls leTmO and get_IokenO 
II deal with', I, and % 
/I calls primaryO and geuokenO 
/I deal with numbers and parentheses 
1/ calls expressionO and get_tokenO 
Note: Each function deals wilh a specific part of an expression and leaves every-
thing clse to mher functions; this radically simplifies each function. TIlis is mllch 
like a group of humans dealing with problems by letting each person h:mdlc 
problems in his or her own specialty, handing aJl other problems over to 
colleagues. 
What should these functions actually do? Each runction should call other 
grammar runctions according to the grammar rule it is implementing and 
ge'-lokenO where a token is required in a rule. For example, when primary() 
tries to rollow the (Expression) rule, it must call 
geUokenO 
expressionO 
/I to deal with (and ) 
/I to deal with Expression 
What should such parsing functions return? How about the answer we really 
wanted? For example, ror 2+3, expressionO could return 5. After all, the inrorma· 
tion is all there. That's what we'll try! Doing so will save us rrom am;wcling one 
or the hardest questions rrom our list: "How do I represent 45+517 as data so that 
I can evaluate it?" Instead or storing a reprcsenlation or 45+517 in memOI)', we 
simply evaluate it as we read it rrom input. '11is little idea is reaJly a major break· 
through! It will keep the program at a quarter or the size it would have been had 
we had expressionO return something complicated ror later evaluation. We just 
saved ourselves about 80% or the work. 
The "odd man out" is geCtoken(): because it deals with tokens, not exprcs· 
sions, it c.·m 't return the value or a sub·expression. For example, + and ( arc not 
expressions. So, it must return a Token. We conclude that we want 
/I functions to match the grammar rules: 
Token get_tokenO 
II read characters and compose tokens 

6.5 
TURNING A GRAMMAR INTO CODE 
double expressionO /I deal with + and -
double lermO 
1/ deal with', /, and % 
double primaryO 
1/ deal with numbers and parentheses 
6.5.2 Expressions 
Let's first write expression(). '11e grammar looks like this: 
Expression : 
Term 
Expression '+' Term 
Expression ,_, Term 
Since this is our first attempt to turn a set of grammar rules into code, we'll pro· 
ceed through a couple of false starts. '1lat's the way it usually goes with new 
techniques, and we learn useful things along the way. In particular, a novice pro-
grammer can learn a lot from looking at the dramatically different behavior of 
similar pieces of code. Reading code is a useful skill to cultivate. 
6.5.2.1 Expressions: first try 
Looking at the Expression '+' Term rule, we try first calling expressionO, then 
looking for + (and - ) and then termO: 
double cxpressionO 
{ 
} 
double left = expressionO; 
Token I = geUoken(); 
switch (I . kind) { 
case '+': 
return lefl + termO; 
case '-': 
return left - lermO; 
derault: 
return left; 
} 
// read and evaluate an Expression 
/1 get the next token 
/1 see which kind of token il is 
/1 read and evaluate a Term, 
II then do an add 
II read and evaluate a Term, 
II then do a subtraction 
1/ relurn the value of the Expression 
ltlooks good. h is almost a trivial transcripuon of the grammar. It is quite simple, 
really: first read an Expression and then see if it is followed by a + or a - , and if it 
is, read the Term. 
195 

196 
CHA PTER (, • W RI TING A PROGRAM 
Unfortunately, lhat doesn't really make sense. How do we know where the ex-
pression ends so umt we can look for a + or a - ? Remember, our program reads left 
to right and can't peck ahead to sec if a + is coming. In fact, this expressionO will 
never get beyond its first line: expressionO starts by calling expression() which 
starts by calling expressionO and so on "forever." il1is is called an i,!finite recursioll 
and will in fact lcnninatc after a short while when the computer rtms out of mem-
ory to hold the "ncvcr-cnding" sequence of calls of expressionO. Tnc term reamion 
is used to describe what. happens when a function calls itself. Not all recursions arc 
infinite, and recursion is a vcry useful programming technique (sec §8.5.8). 
6.5.2.2 Expressions: second try 
So what do we do? Every Term is an Expression, but not every Expression is a 
Term; that is, we could start looking for a Term and look for a full Expression 
only if we found a + or a - . For example: 
double expressionO 
{ 
) 
double left = lermO; 
Token t = geUokenO; 
switch (t.kind) ( 
case '+' : 
return left + expressionO; 
b '''.if I( 
case '- ': 
return left - expressionO; 
,fC'd' 
default: 
return left; 
) 
/I read and evaluate a Term 
/I gct the next token 
/I see which kind of token that is 
/I read and evaluate an Expression, 
/! then do an add 
/I read and evaluate an Expression, 
/I then do a subtraction 
/! return the value of the Term 
111is aCluaJly - more or less - works. We have tried it in the finished program 
and it parses every correct expression we throw at it (and no illegal ones). It even 
correclly evaluates most expressions. For example, 1+2 is rcad as a Term (with 
lllC value I) followed by + followcd by an Expression (which happens to bc a 
Term will) thc vaJue 2) and gives the answer 3. Similarly, 1+2+3 gives 6. We could 
go on for quite a long time about what works, but to make a long story short: 
How about 1-2-3? This expressionO will read the 1 as a Term, then proceed to 
read 2-3 as an Expression (consisting of thc Term 2 followed by the Expression 
3). It will then subtract the value of 2-3 from 1. In Olher words, it will evaluate 
1-(2-3). 111e vaJue of 1-(2-3) is 2 (positive two). However, we were taught (in 
primary school or even earlier) that 1-2-3 means (1-2)-3 and thcrcforc has thc 
value -4 (ncgative four). 

6.5 
TURNING A GRAMMAR IN TO CODE 
So we got a very nice program that just didn't do the right thing. '11at's dan-
gerous. It is especially dangerous because it gives the right answer in many cases. 
"or example, 1+2+3 gives lhe right answer (6) bec.lUse 1+(2+3) equals (1+2)+3. 
\<\That fundamentally, from a programming point of view, did we do wrong? We 
should always ask oursc!ves t.his question when we have found an error. That 
way we might avoid making the same mistake again, and again, and again. 
Fundamentally, wejust looked at the code and guessed. 111a1'S rarely good 
enough! We have to understand what our code is doing and we have to be able 
to explain why it docs the right thing. 
Analyzing ollr errors is often also the best way to find a correct solution. 
What we did here was to define expressionO to first look for a Term and then, if 
that Term is followed by a + or a - , look for an Expression. ~n1is really imple-
ments a slighliy different grammar: 
Expression: 
Term 
Term '+' Expression 
Term '-' Expression 
II addition 
Ilsubtraciion 
'11e difference from our desired grammar is exacliy that we wanted 1-2-3 to be 
the Expression 1-2 followed by - followed by the Term 3, but what we got here 
was the Term 1 followed by - followed by the Expression 2-3; that is, we wanted 
1- 2-3 to mean (1-2)-3 hut we got 1-(2-3). 
Yes, debugging can be tedious, tricky, and time-consuming, but in this case 
we arc really working through rules you learned in primary school and learned 
to avoid without too much t.rouble. 111e snag is that we have to teach the rules t.o 
a computer - and a computer is a far slower learner than you arc. 
Note that we could have defined 1-2-3 to mean 1-(2-3) rather t.han (1-2)-3 
and avoided this discussion altogether. Often, the trickiest. programming prob-
lems come when we must match conventional rules that were esmblished by and 
for humans long before we started using computers. 
6.5.2.3 Expressions: third time lucky 
So, what. now? Look again at the grammar (the correct grammar in §6.5.2): any 
Expression starts with a Term and such a Term can be followed by a + or a - . So, 
we have to look for a Term, sec if it is followed by a + or a - , and keep doing that 
umiltbere arc no more plusses or minuses. For example: 
double expressionO 
{ 
double left = termO; 
Token t = geUoken(); 
II read and evaluate a Term 
II get the next token 
197 

198 
) 
(HAPTE R 6 • W RITING A PROGRAM 
while ( I.kind=='+' IIl.kind=='-') ( I/look for a + or a -
if (I.kind == '+') 
) 
left += termO; 
/I evaluate Term and add 
else 
left -= termO: 
t = geUokenOj 
II eva[uale Term and subtract 
return leH; 
1/ finally: no more + or - ; return the answer 
TIlis is a bit messier: we had to introduce a loop to keep looking for plusscs and 
minuses. We also gOI a bit repetitive: we test for + and - twice and twice call 
geuokcnO. Because it obscures the logic of the code, let's just get rid of tbe du-
plication of the test for + and - : 
double expressionO 
{ 
) 
double left = termO; 
Token t = geuoken()j 
while(true) ( 
) 
5witch(t.kind) ( 
case '+': 
left += termO: 
t = geuoken(); 
break; 
case '- ': 
left -= termO; 
t = geUoken()j 
break; 
default: 
return left; 
) 
II read and evaluate a Term 
/1 get the next token 
/I evaluate Term and add 
/I evaluate Term and subtract 
II finally: no more + or - ; return the answer 
NOle that - except ror the loop - this is actually rather similar to our first u-y 
(§6.5.3.1). What we have done is to remove the mention or expressionO within 
expressionO and replace it with a loop. In other words, we trallslated the 
Expression in the grammar niles ror Expression into a loop looking ror a Term 
followed by a + or a - . 
6.5.3 Terms 
The grammar nile ror Term is very similar to the Expression nile: 

6.5 
TURN ING A GRAMMAR INTO CODE 
Term : 
Primary 
Term ,. , Primary 
Term '/' Primary 
Term '%' Primary 
Consequcnt.ly, thc code should bc very similar also. Here is a first try: 
double lermO 
{ 
double lefl = primary(); 
Token t = geUokenO; 
while(lrue) { 
switch (t.kind) { 
case '.' : 
left .= 
primaryO; 
1= gel_tokenO; 
break; 
case 'I' : 
left 1= primary(); 
1= gel_token(); 
break; 
case '0(0' : 
left %= primary(); 
1= geUokenO; 
break; 
default : 
return left; 
) 
Unfortunately, this doesn't compile: the remainder operation (%) is not defined 
for floating-point numbers. The compiler kindly tells us so. When we answered 
question 4 above - "Should we also allow floating-point inputs?" - with a confi-
dent "Sure!" we actually hadn't thought the issue through and fell victim to 
fia/llre creep. That ahvays happens ! So what do we do about it? We could at run-
time check that bOlh operands of % are integers and give an elTOr if they are not. 
Or we could simply leave % out of our calculator. Let's take the simplest choice 
for now. Wc can always add % later; see §7.5. 
After we eliminate t.he % case, the function works: tenns arc correcLiy parsed 
and evaluated. However, an experienced progranmlcr will notice an undesirable 
detail that makes termO unacceptable. What would happen if you cntered 210? You 
can't divide by zero. If you try, the computer hardware \vill detect it and lemlinate 
199 

200 
( HAPTER 6 • WRITING A PROGRAM 
your program with a somewhat unhelpful error message. An inexperienced pro-
grammer will discover this the hard way. So, we'd better check and give a decem 
error message: 
double termO 
{ 
) 
double left = primaryO; 
To ken t = get_token(); 
while(true) { 
) 
switch (t.kind) { 
case I.' : 
left -= primaryO; 
t = get_tokenO; 
break; 
case 'f' : 
{ 
double d = primaryO; 
if (d == 0) e rro r("divide by zero "); 
lefl /= d; 
t = geUokenO; 
break; 
default : 
return lefl ; 
) 
Why did we put lhe statements handling I into a block? l1le compiler insists. If 
you want to define and initialize variables within a switch-statement, YOli must 
place them inside a block. 
6.5.4 Primary expressions 
The grammar rule for primary expressions is also simple: 
Primary: 
Number 
'(' Expression ')' 
lllC code that implements it is a bit messy because there arc morc opportunities 
for syntax errors : 

6.6 
TRYING THE FIRST VERSION 
double primaryO 
( 
) 
Token I = geClokenO; 
swilch (I.kind) ( 
case '(' : 
1/ handle '(' expression 'I' 
{ 
double d = expressionO; 
1= gel_IokenO: 
) 
if (I.kind != ')') error("')' expected"): 
relurn d; 
case '8'; 
/1 we use '8' to represent a number 
/1 return the number's value 
relurn I.value: 
defaull: 
error{"primaryexpected"); 
) 
Basically there is nothing new compared to expressionO and term(). We use the 
same language primitives, the same way of dealing with Tokens, and the same 
programming techniques. 
6.6 Trying the first version 
To run these calculator functions, \\!C need to implement geClokenO and provide 
a mainO. TIle mainO is trivial: we just keep calling expressionO and printing Out 
its result: 
int mainO 
try { 
) 
while (cin) 
cout « expression()« '\n'; 
keep_window_openO; 
catch (exception& e) ( 
) 
cerr « e.whatO« endl: 
keep_window_open 0; 
return 1; 
catch C .• ) { 
cerr « "exception \n"; 
keep_window_open 0: 
return 2; 
201 

2')2 
CHAPTER 6 • WRITING A PROGRAM 
TIle error handling is the usual ';boilcrplate" (§5.6.3). Let us postpone the de-
scription of the implementation of geClokenO to §6.8 and test this first version of 
the calculator. 
TRY THIS 
This first version of the calculator program (including gel_fokenO) is avail-
able as file calculatorOO.cpp. Get it to run and try it OUL 
Unsurprisingly, this first version of the caJcuiator doesn't work quite as we ex· 
pecled. So we shrug and ask, "Why not?" or rather, "So, why docs it work the 
way it docs?" and "''''hat docs it do?" Type a 2 followed by a newline. No re-
sponse. Try another newline to see if it's asleep. Still no response. Type a 3 fol-
lowed by a newline. No response! Type a 4 followed by a newline. It answers 2! 
Now the screen looks like this: 
2 
3 
4 
2 
1ft. 
We carry on by typing 5+6+7. The program responds with a 5, so that the screen 
looks like this: 
2 
3 
4 
2 
5+6+7 
5 
Unless you have programmed before, you arc most likely very puzzled! In fact, 
even an experienced programmer might be puzzled. ,.vhat's going on here? At 
lhis point, you try to get out of the program. How do you do this? We "forgot" to 
program an exit command, but an error will cause the program to exit, so YOLi 
type an x and the program prints Bad token and exits. Finally, something worked 
as planned! 
However, we forgot to distinguish between input and output on the screen. 
Before we try to solve the main puzzle, let's just fix the output to better see what 
we are doing. Adding an = to indic..te Output will do for now: 

6 .6 
TRY ING THE FIR ST VERS ION 
while (cin) caul «"= " «
expressionO «
'\n'; 
1/ version I 
Now, entering the exact sequence of characters as before, we get 
2 
3 • 
=2 
5+6+7 
= 5 
, 
Bad loken 
Strange! Try to figure out what the program did. We tried another few examples, 
but let's just look at t.his.'11is is a puzzle: 
Why didn't the program respond after t.he first 2 and 3 and t.he newlincs? 
Why did the program respond with 2, rather than 4, after we entered 4? 
Why did the program answer 5, rdther than 18, after 5+6~? 
" 
111erc arc many possible ways of proceeding from such mysterious results. We'll 
examine some of those in the next chapter, but here, let's JUSt think. Could the 
program be doing bad aritpmetie? That's most unlikely; the value of 4 isn't 2, 
and the value of 5?47 f~ 18' Utlher than 5. Consider what happens when we 
enter 1 234+56+78+9101112 followed by a newline. We get 
1234+56+78+9101112 
= 1 =. 
=. =. 
= 10 
Huh? No 2 or 3. Why 4 and not 9 (that is, 4+5)? Why 6 and not 13 (that is, 6+7)? 
Look carefully: the program is outputting every third token! Maybe the program 
"cats" some of our input without evaluating it? It docs. Consider expressionO: 
double expression() 
{ 
double left = termOi 
Token t = geUoken(); 
while(lrue) { 
switeh(t.kind) { 
II read and evaluate a Term 
1/ get the next token 
203 

} 
} 
case '+' : 
leU += lermO; 
1= geUokenO; 
break; 
case '-': 
left -= lermO; 
1= gel_IokenO; 
break; 
deraull: 
relurn lefl; 
} 
C H APTER 6 • wRITING A PROGRAM 
II evaluate Term and add 
/I evaluate Term and sublract 
/I finally: no more + Of -; return the answer 
When the Token relumed by geClokenO is not a '+' or a '- ' we just return. We 
don't use t.hat token and we don't store it anywhere ror any Olher runction to usc 
later. That's nOl sman. ~lhrowill g away input without even detennining what it is 
can't be a good idea. A quick look shows that lermO has exactly the same prob-
lem. '1mt explains why our calculator ate twO tokens ror each that it used. 
Let us modify expressionO so thal it doesn't "cat" tokens. \>Vhere would we 
put that next token (I) when the program doesn't need it? We could think or 
many elaborate schemes, but let's jump to the obvious answer ("obvious" once 
you sec it): that token is going to be used by some other function that is reading 
tokens rrom the input, so let's put the token back into the input stream so that it 
can be read again by some other runction! Actually, you can put characters back 
into an istream, but that's not really what we want. We want to deal with tokens, 
nOt mess with characters. What we want is an input stream that deals with to-
kens and that yOll can put an already read token baek into. 
So, assume that we have a stream or tokens - a "Token_slream" - called 15. As-
sume rurther that a Token_stream has a member function gelO that relllms the next 
token and a member runction pUlback(t) that puts a token t back i.nto the sueam. 
We'll implement that Token_slream in §G.B as soon as we have had a look at how it 
needs to be used. Given Token_stream, we can rewrite expressionO so lhat it puts a 
token that it docs not use back into the Token_stream: 
double expressionO 
{ 
double lefl = termO; 
Token I = ts.getO; 
while(true) ( 
switch(t.kind) { 
/I read and evaluate a Term 
/I get the next Token from the Token stream 

6.6 
TRYIN G HIE FIR ST VE RSION 
} 
case '+' : 
left += termO; 
/I evaluate Term and add 
t = Is.geIO; 
break; 
case '- ': 
left -= lermO; 
1= Is.gelC); 
break; 
default : 
/I evaluate Term and subtract 
Is.pulback(l); 
II put I back into the token stream 
relurn left ; 
/I finally: no more + or -; return the answer 
} 
In addition, we must make the same change to fermO: 
double lermO 
( 
double left = primary(); 
Token I = Is.geIO; 
/I get the next Token from the Token stream 
while(true) { 
switch (I. kind) { 
case ' . ': 
left "= primary(); 
1= ts.geIO; 
break; 
case 'f: 
{ 
double d = primary(); 
jf (d == 0) error("divide by zero"); 
left 1= d; 
1= Is.get(); 
break; 
default: 
} 
ts.pulback(t); 
/I put t back into the Token stream 
return Jefl ; 
205 

206 
C H AP TE R 6 • W RITI NG A PROGRAM 
For Ollf last parser function, primaryO, we need just to change geCloken() to 
ts.get(); primaryO lIses every token it reads. 
6.7 Trying the second version 
So, we arc ready to test our second version. Type 2 followed by a newline. No re-
sponse. Try another newline to see if it's asleep. Still no response. Type a 3 fol-
lowed by a newline and it answers 2. Try 2+2 followed by a newline and it 
answers 3. Now yOUT screen looks like this: 
2 
3 
=2 
2+2 
=3 
Hm m. Maybe our introduction of putbackO and its lise III expressionO and 
fermO didn't flx the problem. Let's try another test: 
2342+3 r3 
=2 
=3 
=, 
=5 
Yes! ~fbcsc arc correct answers! But the last answer (6) is missing. We still have a 
token-look-ahead problem. However, lhis lime the problem is not that Ollr code 
"cats" characters, but that it doesn't get any output ror an expression mllil we 
enter the rollowing expression. 111e result or an expression isn't priuted immedi-
ately; the output is postponed until the program has seen the first token or the 
next expression. Unrortunately, the program doesn't see that token until we hit 
Rerum after the next expression. The prob'l'am isn't really wrong; it is just a bit 
slow responding. 
How can we fix this? One obvious solution is to require a "prim command." 
So, let's accept a semicolon arler an expression to terminate it and trigger output. 
And while we are at it, lei's add an "exit command" to allow ror gracdul exit. 
The character q (for "quit") would do nicely ror an exit command. In mainO, we 
have 
while (cin) CQul « "=" «expressionO « '\n'; 
/I version 1 

6.8 
TOKEN STREAM S 
\oVc can change that to the messier but more useful 
double val = 0; 
while (cin) ( 
Token I = Is.gel(); 
if (I. kind == 'q') break; 
if (I. kind == ';') 
lI 'q' for Nquil"" 
II ';' for Nprint nO\.vN 
cout« "="« val « '\n'; 
} 
else 
Is.putback(l); 
val = expressionO; 
Now the calculator is actually usable. For example, we get 
2-, 
=2 
2+3; 
=5 
3+4-5; 
=23 
q 
At this point we have a good initial version of the calculator. It's not quite what 
we really wa.nted, but we have a program that we can lise as the base for making 
a more acceptable version. Importantly, we can now correct problems and add 
features one by one while maintaining i..working progra.m as we go along. 
6.8 Token streams 
Before further improving our calculator, let us show t.be implememation of 
Token_stream. After ail, nothing - nothing at all - works until we get correct input. 
Vile implemented Token_stream ftrst of all but didn't want too much of a digression 
from the problcms or c.a1culation before we had shown a minimal solution. 
Input for our calculator is a sequence of tokens, just as we showed for 
{1.5+4)-11 above (§6.5.1). vVhat we need is something that reads characters rrom 
the standard input, cin, and prescnts lhe program with the next token when it 
asks for it. In addition, we saw that we - that is, our c.a1culalor program - Orlen 
read a token too many, so that we must be able to put it back for later usc. This is 
typical and fundamental; when you see 1.5+4 reading strictly left to right, how 
207 

C HAPTER b • W RITI NG A PROG RAM 
could you know that lhe number 1.5 had been completely read without reading 
the +? Until we sec the + we might be on our way to reading 1.55555. So, we 
need a "stream" that produces a token when we ask for one llsing getO and 
where we can put a token back into the stream using putbackO. Everything we 
usc in C++ has a type, so we have to start by defining the type Token_stream. 
You probably nOliccd the public: in the definition of Token above. ~n1 e rc , it 
had no apparent reason. For Token_stream, we need it and must explain its func-
tion. A C++ user-defined type often consists of twO pans: the public interface (la-
beled "public:") and the implementation details {labeled "private:"). " le idea is to 
separate what a user of a type needs for convcniellt usc from thc dctails that wc 
need in order to implement the type, but that we'd rather not have users mcss with: 
class Token_Slrearn { 
public: 
II user interface 
private: 
II implementation details 
/I (not directly accessible to users ofToken_strcaml 
}, 
Obviously, users and implementers arc oftcn just us "playing diffcren, rolcs," but 
making the distinction between the (public) interface meant for users and the 
(private) implementation details used only by the implementer is a powerful tool 
for structuring code. 111C public intcrfacc should contain (only) what a uscr 
needs, which is typically a set of functions, including constmctors to initializc ob-
jects. TIle private implementation contains what is necessary to implement those 
public functions, typically data and functions dealing with messy details thai the 
users need not know about aJld shouldn't directly usc. 
Let's elaborate the Token_stream type a bit. What docs a user w;mt from it? 
Obviously, we want get() and putbackO functions - tllat's why we invented the 
notion of a token stream. TI1C Token_stream is to make Tokens out of characters 
that it reads for input, so we need to be able to make a Token_stream ilnd to de-
fme it to read from cin. TIlUS, tlle simplest Token_stream looks like tllis: 
class Token_stream ( 
public: 
Token_stream()i 
Token getO; 
void putback(Token I); 
private: 
/I implementation details 
}, 
/I make a Token_stream that reads from cin 
/I get a Token 
/I put a Token back 

6.8 
TOKEN STREAMS 
TIlat's all a user needs to use a Token_stream. Experienced programmers will 
wonder why cin is the only possible source of characters, but we decided to take 
our input from the keyboard. We'll revisit that decision in a Chapter 7 exercise. 
Why do we usc the "verbose" name putbackO rather than the logically suffi· 
cient put()? We wanted to emphasize the asymmetry between gel() and pulback(); 
this is an input stream, not somel.hing that you can also usc for general output. 
Also, islream has a putbackO function: consistency in naming is a useful property 
of a system. It helps people remember and helps people avoid errors. 
We can 1I0W make a Token_shearn and use it: 
Token_stream ts; 
Token t = ts.get(); 
11_ .. 
ts.putback(l); 
/I a Token_stream called Is 
/I get next Token from Is 
/I put the Token t back into ts 
That's all we need to write the rest of the calculator. 
6.B.1 Implementing Token_stream 
Now, we nccd LO implement those lhrcc Token_stream functions. How do we repre-
sent a Token_stream? That is, what data do we need to store in a Token_stream for 
it to do its job? V\.'c! need space for ,my token we put back into the Token_stream. 1b 
simplifY, let's say we c.l.1l put back at most one token at a lime. 1113t happens LO be 
sufficient for our program (and for many, many similar programs). TImt way, we 
just need space foJ' one Token and an indic.'l.tor of whether that space is full OJ' 
empty: 
class Token_stream ( 
public: 
Token_stream(); 
Token get(); 
/I make a Token_stream that reads from d n 
/I gct a Token (gel() is defined elsewhere) 
void putback(Token t); 
private: 
/I put a Teten back 
bool full; 
II is there a Token in the buffer? 
Token buffer; 
II here is where we keep a Token put back using putbackO 
); 
Now we can define ("writc
n
) the three member functions. 111e consuuctor and 
putback() are easy, because they do so little, so we will define tllOse first. 
209 
111C constrllCl'Or just sets full to indicme that the buffer i.s empty: 
,wrt, ,[.,.IJ.-{ S (' 
Token_slream::Token_streamO 
,"1 
I a .k V--..--t 
:full(false), buffel(O) 
/I no Token in buffer 

210 
{ 
} 
CHAPTER 6 • WRITING A PROGRAM 
VVhen we define a member of a class outside the class definition itself, we have to 
mention which class we mean the member to be a member of. We use the notation 
for thal. In this case, we define Token_stream's constructor. A constructor is a 
member with the same name as its class. 
Why would we define a member outside its class? TIle main answer is clar-
ity: the class definition (primarily) stales what the class call do. Member function 
definitions arc implementations that specify how things arc done. We prefer to 
put them "elsewhere" where they don't distract. Our ideal is to have every logical 
entity in a program fit on a screen. C lass defmitions typically do that if the mem-
ber function definitions arc placed elsewhere, bUl 11m if they are placed within the 
class definition ("in-class"). 
We initialize the class members in a member itliualizer list (§6.3.3); full (false) 
sels a Token_stream's member full to false and buffer(O) initializes the member 
buffer with a "dummy token" we invented just for that purpose. ~nle definition 
of Token (§6Jjj) says that every Token must be initialized, so we couldn't just ig-
nore Token_stream: : buffer. 
TIle putbackO member function puts its argument back into the Token_stream's 
buffer: 
void Toke n_stream: : putback(Toke n t) 
{ 
buffer = I; 
/I copy ! !o buffer 
full = true; 
/I buffer is now full 
} 
The keyword void (meaning "nolhing") is used to indicate that putbackO doesn't 
retum a value. If we wanted to make SUfe that we didn't try to LIse putbackO twice 
without readitlg what we put back itl between (using getO), we could add a test: 
void Token_stream: :putback(Toke n t) 
( 
if (full) error("putbackO into a full buffer"); 
buffe r = I; 
/I copy! !o buffer 
full = true; 
II buffer is now full 
} 
The lest of full checks the precondition "111ere is no "Ibken in the butTer." 

6.8 
TO KEN STREAMS 
6.8.2 Reading tokens 
All the real work is done by getO. If there isn't already a Token in Token_stream:: 
buffer, get() must read dmfactcrs from cin and compose them imo Tokens: 
Token Token_stream: :getO 
} 
{ 
if (full) { 
II do we already have a Token ready? 
/I remove Token from buffer 
full=false; 
return buffer; 
char chi 
cin » chi 
/I note that » skips whitcspace (space, newline, lab, etc.) 
switch (ch) { 
case '; ': 
case 'q': 
/I for Nprint'" 
/I for ~ q uil" 
case '(' : case ')': case '+' : case '- ': case '. ': case 'f : case "Yo': 
return Token(ch); 
/I let each character represent itself 
case '.': 
case '0': case '1': case '2': case '3': case '4': 
case '5': case '6': case "': case '8': case '9': 
{cin.putback(ch); 
/I put digit back into the input stream 
double val; 
cin »val; 
return Token('8',val); 
} 
default : 
error("Bad token"); 
} 
/I read a floating-point number 
/I let '8' represent ~ a number" 
Let'S examine getO in detail. .. i rst we check if we already have a Token in the 
buffer. If so, we can just retum that: 
if (full) { 
/I do we already have a Token readyr 
/I remove Token from buffer 
full=false; 
return buffer; 
} 
211 

212 
CHAPTER 6 • WR ITIN G A PROCRAM 
Only if full is false (that is, there is no token in the buffer) do we need to Illess 
with characters. In that case, we read a character and deal with it appropriately. 
We look for parentheses, operators, and numbers. Any other character gelS us 
the call of cn orO lhat tcnninatcs the program: 
default: 
error("Bad token "); 
lllC cn orO function is described in §5.6.3 and we make it available in Sld_lib_fa-
cililies.h. 
We had to decide how to represent the different kinds of Tokens; that is, we 
had to choose values for the member kind. For simplicity and case of debugging. 
we decided to let the kind of a Token be the parentheses and operators thelll-
selves. This leads to extremely simple processing of parentheses and operators: 
case '(': case ')': case '+': case '- ': case '.': case 'I': 
return Token(ch); 
I/let each character represent itself 
To be honest, we had forgotten ';' for "print" and 'q' for hquit" in our first ver-
sion. \rVe didn't add them umil we needed them for our second solution. 
6.8.3 Reading numbers 
Now we just have to deal with numbers. 1113t's acrually n ot that easy. How do 
we really find the value of 123? Well, that's 100+20+3, but how about 12.34, and 
should we accept scientific notation, such as 12.34e5? We could spend hours or 
days to gel this right, but fortunately, we don't bave la. Input streams know wha! 
C++ literals look like and how to tum them into values of type double. All we 
have to do is to figure OUI how to tell dn to do that for us inside gel() : 
case '.': 
case '0': case '1': case '2': case 'J ' : case '4': case '5': case '6': case '7': 
case '8': case '9': 
(
cin_putback(ch); 
1/ put digit back inlO Ihe input stream 
double val; 
d n » val; 
return Token('8',val); 
) 
1/ read a floating-point number 
I/let '8' represent "a number" 
We - somewhat arbitrarily - chose '8' to represent "a number" in a Token. 
How do we know that a number is coming? Well, if we guess from experi-
ence or look in a C++ reference (e.g., Appendix A), we find that a numeric literal 
must start with a digit or . (the decimal point). So, we test for that. Next, we want 

6.9 
PROG RAM STR UCTURE 
to let dn read the number. but we have already read the first character (a digit or 
dOl), so just letLing d n loose on the rest will give a wrong result. We could try to 
combine the value of the first character with the value of "the rest" as read by 
d n; for example, if someone typed 123, we would get 1 and d n would read 23 
and we'd have to add 100 to 23. Yuck! And that's a trivial case. Fortunately (and 
not by accident), d n works much like Toke n_stream in that you can put a char· 
acter back into it. So instead of doing any messy aritlunetic, we just put the initial 
character back into d n and then let d n read tile whole number. 
Please note bow we again and again avoid doing complicated work and in· 
stead find simpler solutions - often relying on library facilities. l 1lat's the essence 
of prot,'1"amming: the continuing search for simplicity. Sometimes that's - somc-
whm facetiously - expressed as "Good programmers are lazy." In that sense (and 
only in that sense), we should be "lazy"; why write a lot of code if we can find a 
way of writing far less? 
6.9 Program structure 
Sometimes, the proverb says, it's hard to sec the forest for tile U"ecs. Similarly, it is 
easy to lose sight of a program when looking at all iLS functions, e1asses, etc. So, 
let's have a look at the program with its details omitted: 
class Token { I" ... "I}; 
class Token_stream {' " ... "'}; 
Toke n_stream:: Toke n_streamO : full(false), buffe r(O) {I" . . . "/ } 
void Token_stream:: putback(Token t) { ' " ... "/} 
Token Token_stream: :getO {' " ... "'} 
Token_stream Is; 
double expression(); 
/I provides getO and pu!backO 
/I declara~n so that primaryO can call expressionO 
do uble primaryO {' " .. . "/ } 
double lermO { ' * ... */ } 
do uble expressio nO { ' * ... */ } 
/I deal with numbers and parentheses 
/I deal with·, /, and % 
/I deal with + and -
inl mainO {/- ... -/ } 
/I main loop and deal wilh errors 
111e order of the declaralions is importill1l. You cannot use a name before it has 
been declared, so ts must be declared before ts.gc10 uses it, and e rrorO must be 
213 

214 
CHAPTE R 6 • WRITING A PROGRAM 
declared before the parser functions because they al1 use il. 111(rc is an interest-
ing loop in the call graph: expressionO calls te rm() which calls primaryO which 
calls expressionO. 
We can represent !.hat graphica11y Oeaving Ollt calls to errorO - Cvcl)'onc calls 
errorO) : 
lllis means that we can't JUSt define those three functions: there is no order that al-
lows us to define every function before it is used. We need at least one declaration 
that isn't also a definition. We chose to declare ("forward declare") expressionO. 
But does this work? It docs, for some definition of Mwork." It compiles, runs, 
correctly evaluates expressions, and gives decent error messages. But docs it 
work in a way that we like? The UI1SlIllHising answer is "Not really." We tried the 
first version in §6.6 and removed a serious bug. lllis second version (§6.7) is not 
much belleI'. BUl that's fine (and expected). It is good enough for its main pur-
pose, which is to be something that we can use to verify our basic ideas and get 
feedback from. As such, it is a success, but try it: it'U (still) drive you nuts! 
TRY THIS 
Get the calculator as presented above to run, see what it does, and try to fig-
ure out why it works as it docs. 

( HAPTER 6 REVIEW 
~ 
Drill 
~nlis drill involves a series of modifications of a buggy program to tum it from 
something useless into something reasonably useful. 
I . Take the ca.iculaLQr from the file calculalor02buggy.epp. Get it to com-
pile. You need to find and fix a few bugs. TIlOse bugs are not in the text 
in the book. 
2. Change the clmracter used as the exit command from q to x. 
3. Change the character used as the print command from ; to =. 
4. Add a grecting line in main(): 
"Welcome to our simple calculator. 
Please enter expressions using floating-point numbers." 
5. Improve that greeting by mentioning which operators are available and 
how to print and exit. 
6. Find the three logic errors deviously inserted in calculator02buggy.cpp 
and remove them so that the calculator produces correct results. 
Review 
l. What do we mean by "Programming is understanding"? 
2. TIle chapter details the creation of a calculator program. Write a short 
analysis of what the calculator should be able to do. 
3. How do you break a problem lip into smaller manageable parlS? 
4. Why is creating a small, limited version of a program a good idea? 
5. Why is feature creep a bad idea? 
6. What arc the three mai.n phases of software development? 
7. What is a "lise case"? 
8. What is the purpose of testing? 
9. According to the omline in the chapter, describe lhe difference between a 
Term, an Expression, a Number, and a Primary. 
10. In the chapter, an input was broken do\.vn intO ilS component Terms, Ex-
pressions, Primarys, and Numbers. Do this for (17+4)/(5- 1). 
II . Why does the program not have a function called numberO? 
12. What is a token? 
13. What is a grammar? A grammar mle? 
14. What is a class? What do we usc classes for? 
15. ''''hat is a constructor? 
16. In the expression function, why is the default for the switch-statement to 
"put back" the token? 
215 

I 216 
(HAPTER 6 • WRITING A PROGRAM 
17. What is "look-ahead"? 
18. What docs putbackO do and why is it useful? 
19. Why is the remainder (modulus) operation, %, difficult to implement in 
the termO? 
20. What do we lISC the two data members of the Token class for? 
21. \-Vhy do we (sometimes) split a class's members into private and public 
members? 
22. What happens in the Token_stream class when there is a token in the 
buffer and the getO function is called? 
23. vVhy wcre the '; ' and 'q' characters added to the switch-statement iIllhc 
getO function of the Token_stream class? 
24. When should we start testing OUf program? 
25. What is a "user-defmed type"? Why would we want one? 
26. What is the interface to a C++ "user-defined type"? 
27. Why do we want to rely all libraries of code? 
Terms 
analysis 
class 
class mcmbcr 
data mcmbcr 
desib"l 
dividc by zero 
Exercises 
grammar 
implcmcntation 
intcrracc 
mcmbcr runctioll 
pru·scr 
private 
prototype 
pscudo codc 
public 
symax analyzer 
token 
use case 
l. If you haven't already, do the Try this exercises from this chaptcr. 
2. Add the ability to use {) as well as () in the program, so that {(4+5)*6} I 
(3+4) will be a valid expression. 
3. Add a ractorial operator: use a suffix 1 operator to represelll "ractorial." 
For cxample, the expression 71 means 7 * 6·5 · 4 · 3·2 *1. Make 1 bind 
tighter than · and /; that is, 7*81 means 7·(8!) rather than (7*8)!' Begin 
by modifying the grammar to account for a higher-level operator. To 
agree with the standard mathematical definition of raCtorial, lct O! cvalu-
alet0 1. 
4. Define a class Name_value that holds a smng and a value. Give it a con-
structor (a bit like Token). Rework exercise 19 in Chapter 4 to use a 
vector<Name_value> instead of two vectors. 
5. Add the article the to the "English" graJIilllar in §6.4.1 , so that it can de-
scribe sentences such as "The birds fly but the fish swim." 

CHAPTER 6 EXERCISES 
6. Write a program that checks if a sentence is correct according to !.he 
"English" grammar in §6.4. 1. Assume that every sentence is tenninated 
by a rull SLOp (.) surrounded by whitespace. For example, birds fly but 
the fish swim . is a sentence, but birds fl y but the fish swim (tenninating 
dot missing) and birds fly bur the fish swim. (no space before dOL) are 
not. For each sentence entered, the program should simply respond 
"OK" or '"'not OK." Hint : Don't bother with tokens; just read into a 
string using » . 
7. Write a grammar ror logical expressions. A logical expression is much 
like an arithmetic expression except that the operators are ! (not), -
(complement), & (and), I (or), and " (exclusive or). ! and - are prefix 
unary operators. A " binds tighter than a I (just as • binds tighter !.han +) 
so that xly"z means xl(y"z) rather than (xly)"z. "nle & operator binds 
tighter than " so that x"y&z means x"(y&z). 
8. Redo the "Bulls and Cows" game rmm exercise 12 in Chapter 5 to usc 
rour leuers rather lhan four digits. 
9. Write a program that reads digits and composes them into integers. For 
example, 123 is read as !.he cilaraclers 1, 2, and 3. The program should 
output "123 is 1 hundred and 2 lens and 3 ones". TIle number should be 
output as an int value. Handle numbers with one, two, three, or rour 
digits. Hint: To get the integer value 5 of the character '5' subtract '0', 
that is, '5'- '0'==5. 
10. A pcmlUlalion is an ordered subset or a set. For example, say you wanted 
to pick a combination to a vault. 1"ere are 60 possible numbers, and you 
need three different numbers ror the combination. TIlere are 1-\60,3) per· 
mutations ror the combination, where Pis defined by !.he rormula 
a! 
P(a,b) = (a-b)!' 
where ! is used as a suffix ractorial operator. For example, 41 is 4*3*2*1. 
Combinations are similar to pennutations, except that the order or the 
objects doesn't matter. For example, ir you were making a '"'banana split
n 
sundae and wished to use three different flavors of ice cream out or five 
lhal you had, you wouldn't care ir you used a scoop or vanilla at the be· 
ginning or the end; you would still have used vanilla. The rormula ror 
combinations is: 
C(a,b) = P (a i b). 
b! 
217 

218 
C HAPTER 6 • WRITING A PROGRAM 
Design a program that asks users for two numbers, asks them whether 
they want to calculate permutations or combinations, and prints out the 
result. This will have several parts. Do an analysis of the above require-
ments. Write exacLly what the program will have to do. -n1CI1 , go into 
the design phase. Write pseudo code for the program, and break it into 
sub-components. This program should have error checking. Make sure 
that aJl erroneous inputs will generate good error messages. 
Postscript 
Making sense of input is one of the fundamental programming activities. Every 
program somehow faces that problem. Making sense of something directly pro-
duced by a human is among the hardest problems. For example, many aspects of 
voice recognition arc still a research problem. Simple variations of this problem, 
such as our calculator, cope by using a grammar lO define the inpul. 

',L 
,.-- 7 
Completi ng a Program 
"It ain't over till the fat lady sings." 
-Opera proverb 
W
riting a program involves gradually refming your ideas 
of what you want to do and how you want to express il. 
In Chapter 6, we produced the initial working version of a calcu-
lator program. Here, we'll ferme it. Completing the program -
that is, making it fit for users and maintaincrs - involves improv-
ing the user interface, doing some serious work on error han-
dling, adding a few useful features, and restructuring the code for 
ease of understanding and modification. 
'" 

22. 
7.1 Introduction 
7.2 Input and output 
7.3 Error handling 
7." Negative numbers 
7.S Remainder: % 
7.6 Cleaning up the code 
7.6.1 Symbolic constants 
7.6.2 Use of functions 
7.6.3 Code layout 
7.6.4 Commenting 
7.1 Introduction 
C HAPTER 7 • COMPL ETI NG A PR O GRAM 
7.7 Recovering from errors 
7.8 Variables 
7.8.1 Variables and definilions 
7.8.2 Introducing names 
7.8.3 Predefined names 
7.8.4 Ate we there yeU 
When your program first starts running "reasonably," you're probably about 
halfway finished. For a large program or a program that could do harm if it mis-
behaved, you will be nowhere near halfway finished. Once the program "basi· 
cally works," the real fun begins! That's when we have enough working code to 
experiment with ideas. 
In this chaptcr, we will guide you through the considerations a professional 
programmer might have trying to improve the calculator from Chapter 6. Note 
that the questions asked about the program and the isslles considered here are far 
more interesting than the calculator ilSelf. What we do is to give an example of 
how real programs evolve under the pressure of requirements and constraints 
and of how a programmer can gradually improve code. 
7.2 Input and output 
If yOLl look back to the beginning of Chapter 6, you'll find that we decided to 
prompt the user with 
Expression : 
and to rqxm back answers with 
Result: 
In the heat of getting the prOb'Ta.m to run, we forgot all about that. 111m's pretty 
typical. We can't think of everything all the time, so when we StOp to reOect, we 
find that we have forgotten something. 
For some programming tasks, the initial requirements cannot be changed. 
That's usually too rigid a policy and leads to programs that arc unnecessarily 
poor solutions to the problems that they arc written to solve. So, let's consider 

7, 2 
INPUT AND O UTPUT 
what we would do, assuming that we can change tile specification of what exactly 
the progr.un should do. 00 we really want the program to write Expression : and 
Result:? How would we know? Just "thinking" rarely helps. We have 10 try and 
sce what works bcsl. 
2+3; S·7; 2+9; 
currellll), givcs 
=5 
= 35 
= 11 
If we added Expression : and Result :, we'd get 
Expression: 2+3; 5*7; 2+9; 
Result : 5 
Expression: Result: 35 
Expression: Result: 11 
Expression : 
We arc sure that some people will like onc style and others will like the other. In 
such cases, we can consider giving people a choice, but for this simple ca..lculator 
.. that would be overkill, so wc must decide. We think that writing Expression : and 
Result : is a bit too "beavyn and distracting. Using those, the actual expressions 
and results are ani), a minor part of what appears on the screen, and since ex-
pressions and results are what mattcrs, nothing should distract from them. On 
the other hand, unless we somehow separate what the user types from what the 
computer OutpuLS, the result can be confusing. During initial debugging, we 
added = as a result indicator. We would also like a shon "prompt" to indicate that 
the program wants input. TIle > character is of len used as a prompt: 
> 2+3; 
=5 
> 5°7; 
=35 
> 
l 11is looks llIuch beuer, and we can get it by a minor change to the main loop of 
main(): 
double val = 0; 
while (dn) ( 
cout « "> "; 
/I print prompt 
221 

222 
Token t = ts.get(); 
if (t.kind == 'q'l break; 
if (t.kind == '; ') 
( HAPTE R 7 • COMPLETI NG A PROG RAM 
coul « "= " «val « '\n'; 
/I print result 
} 
else 
Is.putback(l); 
val = expression(); 
Unfortunately, the result of putting severaJ expressions on a line is still messy: 
> 2+3; 5°7; 2+9: 
=s 
> =35 
>= 11 
> 
' 11C basic problem is that we didn't think of multiple expressions on a linc when 
we started out (at least we pretended not to). YVhat we want is 
> 2+3; 5"7; 2+9; 
=s 
=35 
= 11 
> 
This looks right, but unforlunaLCly mere is no really obvious way of achieving il. 
We first looked at mainO. Is there a way to write out > only if it is not immedi-
ately followed by a =? We cannot know! We need to write > before the get(), but 
we do not know if gel() actually reads new characters or simply gives us a Token 
from characters that it had already read from the keyboard. In other words, we 
would have to mess with Token_stream to make this final improvement. 
For now, we decide that what we have is good enough. If we find that we 
have to modify Token_stream, we'll revisit this decision. However, it is unwise to 
make major structural changes to gain a minor advantage, and we havcn't yct 
thoroughly tcsted the calculalOr. 
7.3 Error handling 
TIle first thing to do once yOll have a program that "basically works" is to try to 
break it; that is, we try to feed it input in the hope of getting it to misbehave. We 
say "hope" because the challenge here is to find as many errors as possible, so 

7.3 
ERROR HAND LIN G 
that you can fix them before anybody else finds them. If you go into this exercise 
with the attitude that '"my program works and I don't make errors!" you won't 
find many bugs and you'll feci bad when you do find one. You'd be playing head 
games with yourseln The right auitude when tesling is "I'll break it! I'm smarter 
than any program - even my own!" So, we feed the calculator a mix of correct 
and incorrect expressions. For cxample: 
1+2+3+4+5+6+7+8 
1- 2- 3-4 
!+2 . 
" 
(1+3; 
(1+); 
1-2fJ%4+5-6; 
0; 
1+; 
+1 
1++; 
110 
1/0; 
1++2; 
-2; 
-2 · .. · 
1 ijl~~7890 1 23456 ; 
'a'; 
q 
1+q 
1+2; q 
TRY THI S 
Feed a few such "problematic" expressions to the calculator and try to figure 
out in how many ways you can get it to misbehave. Can you get it to crash, 
that is, to get it past our error handling and give a machine error? We don't 
think you c."ln. Can you get it to exit without a usdul error message? You 
can. 
Technically, this is known as telting. '111ere are people who do this - break pro-
grams - for a living. 'lesting is a very important part of software development 
and can actually be fun. Chapter 26 exanlines tesling in some detail. One big 
223 

224 
CHAPTER 7 • COMPLETING A PROGRAM 
question is: "Can we lest the program systematically, so thm we find all of the eT-
rors?" "Illerc is no general answer to this qucstion; that is, there is no answer that 
holds for all programs. However, you can do rather well for lUany prOb'Tams 
when you approach testing seriously. You try to create test cases systcmaticaJly, 
and just in case your strategy [01' selecting tests isn't complete, you do some "'un-
reasonable" tests, such as 
Mary had a little lamb 
srtvrqliewcbet7rewaewre-wqcntrretewru754389652743nvcqnwq; 
!@#$%,.'\&"O-:; 
Once, when testing compilers, I got inLO the habit of feeding email reporting COIll-
piler errors straight to the compiler - mail headers, user's explanation, and all. 
l1ml wasn't "sensible" because "nobody would do that." However, a program 
ideally catches all errors, not just the sensible ones, and soon that compiler was 
very resilient against "strange input." 
The first really annoying thing we noticed when testing the calculator was 
that the window closed immediately after inputs such as 
+1 ; 
() 
!+2 
A lillie thought (or some tracing of the progTam's execution) shows that the prob-
lem is that the window is closed immediately after the error message has been 
written. This happens because our mechanism for keeping a window alive was to 
wait for you to enter a dmracter. However, in all three cases above, the program 
detected an error before it had read all of the characters, so that there was a char-
acter left on the input line. 111e program can't tell such "leftover" characters from 
a character entered in response to the Ente r a character to close window prompt. 
That "leftover" character then closed the window. 
We could deal with that by modifying mainO (sec §5.6.3): 
catch (runtime_error& e) ( 
cer, « e.what()« endl; 
/I keep_windmv_opcnO: 
} 
cout « "Please ente r the characte r - to close the window\n"; 
char chi 
while(cin » ch) 
II keep reading until we find a -
if (ch=='-') return I; 
return 1; 

7. 3 
ERROR HANDLING 
Basically, we replaced keep_window_openO with our own code. Note that we 
still have our problem ir a - happens to be the next character to be read after an 
error. bUl that's rather unlikely. 
When we encountered this problem we wrote a version or keep_win-
dow_openO that takes a string as its argument and closes the window only when 
you enter that string arter getting the prompt, so a simpler solution is: 
catch (runtime_error& e) { 
cerr « e.whatO« endl; 
keep_window_open(tI_tl); 
return 1; 
Now examples such as 
. 1 
11_ 
() 
will cause the calculator to give the proper error mcssages, then say 
Please ente. - - to exit 
and not exit until you enter the string -
. 
The calculator takes input rrom the keyboard. That makes testing tedious: 
each time we make an improvement, we have to type in a lOt or test cases (yet 
again!) 10 make sure we haven't broken anything. II would be much beller ir we 
could store our test cases somewhere and run them with a single conunand. Some 
operating systems (notably Uni.x) make it lrivialto get cin LO read rrom a rde with-
out modir)'ing the program, ,md similarly to divelt the output rrom coul to a file. Ir 
that's not convenient, we must modify the program to usc a (ile (see Chapler 10). 
Now consider: 
1+2; q 
and 
1+2 q 
We would like both to print the result (3) and then exit the program. Curiously 
enough, 
t+2 q 
225 

226 
CHAPTER 7 • COMPLETING A PROGRAM 
docs that, but the apparently cleaner 
1+2; q 
cliciLS a Primary expcCled error. Where would we look for this error? Ll main{) 
where ; and q are handled, of course. We added those "print" and "quit" COIll-
mands rather quickly to get the calculator to work (§6.G). Now we arc paying for 
that hastc. Consider again: 
double val = OJ 
while (dn) { 
cout « ">"; 
Token t = ts.geIO; 
if (t.kind == 'q'l break; 
if (I. kind == ';') 
coul « "= " « val « '\n'; 
else 
ts.putback(t); 
val = expression j); 
If we find a semicolon, we straightaway proceed to call expressionO without 
checking for q. 111c first thing that expression does is to look for a primaryO, and 
now it finds q. 111c letter q isn't a primary so we gel our error message. So, we 
should test for q after testing ror a semicolon. While we were at it, we rclt thc 
necd to simplify thc logic a bit, so the completc mainO reads: 
inl mainO 
try 
{ 
} 
while (cin) { 
} 
coul « "> "; 
Token I = IS. gel(); 
while (I.kind == ';') 1=ls.gel(); 
Ileal ';' 
if (I.kind == 'q ') { 
keep_window_openO; 
relurn 0; 
} 
Is.pulback(t); 
coul« "= " «
expressionO« endl; 
keep_window _open(); 
return 0; 

7.4 
NEGATIVE NUMBERS 
catch (exception& e) { 
cerr « e.whatO« endl; 
keep_window_open("-"); 
return 1; 
catch ( ..• ) { 
cerr « "exception \n"; 
keep_window_open("-")i 
return 2; 
111is makes for reasonably robust elTor handling. So we can start considering 
what else we can do to improve the calculator. 
7.4 Negative numbers 
If you tested the calculator, you found that it couldn't handle negative numbers 
elegamly. For example, this is an error: 
-,/2 
We have to write 
10-')/2 
.. 
11mt's not acceptable. 
Finding such problems during late debugging and testing is common. Only 
now do we have the opportunity to sec what our design really docs and get the 
feedb<lck that allows us to refine our ideas. When planning a project, it is wise to 
try to preserve time and flexibility to benefit from the lessons we leam here. All 
too often, "release 1.0" is shipped without needed refinements because <l tight 
schedule or a rigid project management strategy prevents "late" changes to the 
specification; "late" addition of "features" is especially dreaded. In reality, when a 
program is good enough for simple use by its designers but not yet ready to ship, 
it isn't "late" in the devc10pmeill sequence; it's the earliest time when we can ben-
efit from solid experience with the program. A realistic schedule takes that into 
account. 
In this c.'l.se, we basically need to modify the granunar to allow unary minus. 
"nlC simplest change seems to be in Primary. We have 
Primary: 
Number 
"(" Expression ")" 
227 

228 
and we need something like 
Primary: 
Number 
"(" Expression tI)" 
"- " Primary 
"+" Primary 
CHAPTER 7 • COMPLETI NG A PROGRAM 
We added unary plus because that's what C++ docs. When we have lInary 
minus, someone always tries unary plus and it's easier juSt to implement that 
than to explain why it is useless. TIle code that implements Primary becomes 
double primaryO 
{ 
Token t = ts.gel(); 
switch (I. kind) { 
case '(': 
II handle '(' expression ')' 
{ 
double d = expression(); 
t = ts.getO; 
if (t.kind != 'I') e rror(''')' expected"); 
return d; 
) 
case '8' : 
return I.value; 
case '-' : 
return - primary(); 
case '+': 
return primaryO; 
/I we usc '8' to represent a number 
/I return the number's value 
default : 
error{tlprimaryexpected"); 
) 
11131'5 so simple that it actually worked the first time. 
7.5 Remainder: % 
When we first analyzed the ideals [or a calculator, we wanted the remainder 
(modulo) operator: %. However, it is not defined [or floating-point numbers, so 
we backed ofT. Now we can consider it again. It should be simple: 

7 .5 
REM AINDER : % 
I. We add % as a Token. 
2. We convert the doubles to ints so that we can usc "I" all those ints. 
Here is the added code in term(): 
case '''I,,': 
double d = term(); 
int il = int(left); 
int i2 = int(d); 
return il%i2; 
"n 1e int(d) is an explicit nota.lion for turning the double into an int by truncating 
(that is, by throwing away whatever was after the decimal point). Unfortunately, 
it's redundant (sec §3.9.2), but we prefer to indicate that we know a conversion is 
happening, that is, that we didn't just accidellla1ly and implicitly convert a dou· 
ble to an into This works in that we now get the correct results for integer 
operands. For example: 
>2%3; 
= 0 
>3%2; 
=1 
>5%3; 
=2 
.. 
How should we handle operands that are not integers? What should be the result 
of 
> 6.7%3.3; 
~11 1erc is no really good answer, so we'll prohibit the lise of % on a floating·point 
argument. We check if the floating·point operands have fractional parts and give 
an error message if they do. Here is the resulting term(): 
double termO 
( 
double left = primaryO; 
Token t = ts.get(); 
while(true) { 
switch (I.kind) { 
II gel the next token from Token_stream 
229 

230 
} 
} 
CHAPTER 7 • COMPLETING A PROGRAM 
case I ",,: 
r.'...., ..... ', 
leU .= lefmO; 
1= Is.get()i 
break; 
case 't : 
....... 
( 
double d = term(); 
if (d == 0) e rror{"divide by zero"); 
left 1= d; 
} 
t = Is.get(); 
break; 
case '0)/0': 
( 
double d =,!erm(); 
int i1 = int(left); 
if (it != left) error ("Iefl-hand operand of % not int"); 
int i2 = inl(d); 
if (i2 != d) error ("right-hand operand of % not int"); 
if (i2 == 0) error("%: divide by zero"); 
left = il%i2; 
t = ts.getO; 
break; 
} 
default: 
ts.putback(t); 
relurn le ft i 
} 
II put! back into the Token_stream 
What we do here is to usc != to check if lhe double to int conversion changed 
the value. If not, all is well and we can use %. 
TIle problem of ensuring inl operands for % is a variant of the narrowing 
problem (§3.9.2 and §5.6.4), so we could solve it using narrow_cast: 
case '0/0': 
} 
int il = narrow3 ast<inl>(left); 
int i2 = narrow_cast<inl>(le rm()); 
A1 (i2 == 0) e rror("%: divide by zero"); 
left = il 0/0i2; 
1= ts.geIO; 
break; 

7. 6 
ClEANING UP THE CO DE 
That's certainly shorter, and arguably dearer, but it doesn't give quite as good 
elTor messages. 
7.6 Cleaning up the code 
""e have made several changes to the code. ~nley are, we think, all improve-
ments. but the code is beginning to look a bit messy. Now is a good time to re-
view the code to sec if we can make it clearer and shorter, add and improve 
comments, etc. In other words, we arc nm finished with the program until we 
have it in a state suitable for someone else to take over maintenance. Except for 
the almost tolal absence of comments, the calculator code really isn't that bad, 
but let's do a bit of cleanup. 
7.6.1 Symbolic constants 
Looking back, we find the usc of '8' to indicate a Token containing a numeric 
value odd. It doesn't really mailer what value is used to i.ndicate a number Token 
as long as the value is distinct from all other values indicating different kind of 
Tokens. However, the code looks a bit odd and we had to keep reminding our-
selves in comments: 
case '8': 
return t.value; 
case '-': 
return - primary(); 
• 
/I we use '8' 10 represent a number 
/I return the number's value 
-10 be honcst, we also made a few mistakes, typing '0' rather than '8', because we 
forgot which value we had chosen to use. In other words, using '8' directly in the 
code m.anipulating Tokens was sloppy, hard to remember, and error-prone; '8' is one 
of U10se "magic constants" we warned against in §4.3. 1. \,yhat we should have done 
was to introduce a symbolic name for the constant we used to represent Ilumber: 
const char number = '8'; 
/1 \.kind==numbcr means that 1 is a number Token 
TIle consl modifier simply tells lhe compiler that we arc defining a number that 
is not supposed to change: number='O' would cause the compiler to give an error 
message. Civen that definition or number, we don't have to use '8' expliciliy any-
more. -n le code fragment from primary above now becomes: 
case number: 
return t.value; 
case '-' : 
return - primary(); 
/I return the number's value 
231 

C HAPTER 7 • COMPLETIN G A PROGRAM 
This requires no commem. We should not say in comments what can be clearly 
and directly said in code. Repeated commeills explaining something are often an 
indication that tile code should be improved. 
Similarly, the code in Token_stream: :getO that recognizes numbers becomes 
case '.': 
case '0': case '1 ': case '2': case '3': case '4': 
case '5': case '6': case '7': case '8': case '9': 
dn.putbackq; 
/I put digit back into the input stream 
double val; 
, ~ 
dn» val; 
/I read a floating-point number 
return Token(number, val); 
We could consider symbolic names for all tokens, but that seems overkill. After 
all, '(' and '+' arc about as obvious a notation for ( and + as anyone could come 
up with. Looking through the tokens, only ';' for "print" (or "terminate expres· 
sion") and 'q' for "quit" seem arbitrary. \Vhy not 'p' and 'e'? In a larger pro-
gram, it is only a matter of time before such obscure and arbitrary notation 
becomes a cause of a problem, so we introduce 
const char quit = 'q'; 
const char print = ';'; 
lIt.kind==quit means that t is a quit Token 
II t.kind==print means that t is a print Token 
Now we can write mainO's loop like this: 
while (dn) { 
coul «
"> "; 
Token t = ts.gel(); 
) 
while (I. kind == print) t=ls.getO; 
if (I.kind == quit) { 
keep_window_opcnO; 
return 0; 
) 
ts.putback(t); 
coul« "= " «expressionO « endl; 
Introducing symbolic names for "prim" and "quit" makes the code easier to read. 
In addition, it doesn't encourage someone reading mainO to make assumptions 
about how "print" and "quit" arc represeilled on input. For example, it should 
come as no surprise if we decide to change the represemation of "quit" to 'e' (for 
"exit"). That would now require no change in mainO. 

7.6 
CLEANING UP THE CO DE 
Now the strings "> " and "= " stand out. Why do we have these "magical" lit-
erals in the code? How would a new programmer reading mainO guess their pur-
pose? Maybe we should add a comment? Adding a comment might be a good 
idea, but introducing a symbolic name is more effective: 
canst string prompt = "> "i 
canst string result = "= "i 
/I used 10 indicate that what follows is a result 
Should we want to change lhe prompt or tile result indicator, we can JUSt modify 
those consts. 111e loop now reads 
while (cin) { 
} 
coul « prom pi; 
Token I = Is.getO; 
while (I. kind ==print) f=fs,gel(); 
if (I. kind == quit) { 
kcep_window_open(); 
return OJ 
ts.putback(t); 
cout « result «expressionO« endl; 
7.6.2 Us. of fUl1jlions 
TI1C functions \\-·c usc should reflect the Slmcture of our program, and the names 
of the functions should identify the logically separate pans of ollr code. Basically, 
our program so far is rather good in this respect: cxpressionO, termO, and 
primaryO directly reflect our understanding of the expression grammar, and gelO 
handles the input and token recognition. Looking at mainO, though, we notice 
that it docs two logically separate things: 
1. mainO provides general "scaffolding": start the program, end the pro-
gram, and handle "fatal" errors. 
2. main() handles the c..1.1culation loop. 
Ideally, a function performs a single logical action (§4.5.1 ). Having mainO per-
form both of these actions obscures the stmcture of the program. TIle obvious 
solution is to separate out lhc e .. l.lculation loop in a separate function calculaleO: 
void calculateO 
( 
II expression evaluation loop 
233 

234 
C HAPTER 7 • COMP LETI NG A PRO GRAM 
while (eio) ( 
cout « prompt; 
Token t = ts.get(); 
while (t.kind == prinO I=ts.get(); 
if (I.kind == quit) return; 
Is.putback(l); 
II first discard all "prints" 
II quit 
cout «
result «cxpressionO« endl; 
} 
int main() 
try ( 
} 
calculale(); 
keep_window_openO; 
return 0; 
catch (runtimc_crror& e) { 
} 
cerr « e.whal()« e ndl; 
keep_window_opcn("- -"); 
return 1; 
catch (, .. ) ( 
} 
eerr « "exception \nil ; 
keep_window_open("-"); 
return 2; 
II cope with Windows console mode 
TIlis rcnccts the structure much morc directly and is therefore easier to under-
stand. 
7.6.3 Code layout 
Looking through the code ror ugly code, we find 
switch (ch) { 
case 'q': case ';': case '%': case 'I': case 'I': case '+': case '_': case I.': case '/': 
relurn Token(ch); 
/I lei each character represent itself 
This wasn't tOO bad bcfo~ we added 'q', ';', and '%', but now it's beginning to 
become obscure. Code that is hard to read is where bugs can more easily hide. 
And yes, a potential bug lurks here! Using one line per case and adding a couple 
of comments help. So, Token_stream's getO becomes 

7.6 
CLEANIN G UP THE CODE 
Token Token_stream: :getO 
{ 
} 
/I read characters from cin and compose a Token 
if (full) { 
/I check if we already have a Token ready 
full=false; 
return buffer; 
} 
char Chi 
cin » Chi 
/I notc that » skips whitespace (space, newline, tab, etc.) 
switch (ch) { 
case quit: 
case print: 
case '(': 
case ')' : 
case '+' : 
case '- ': 
case '.': 
case 'f : 
case '%': 
return Token(ch); 
case '.': 
/I let each character represent itself 
II a floating-point-literal can start with a dot 
case '0': case '1': case '2': case '3': case '4': 
case '5': case '6': case '7': case '8': case '9': 
II numeric literal 
cin.putback(ch); 
/I put digit back into the input stream 
double val; 
cin »
val; 
II read a floating-point number 
return Token(number,val); 
default : 
error("Bad token"); 
We could of course have PUt each digit case on a separate linc also, but that 
didn't seem to buy us any clarity. Also, doing so would prevent getO from being 
viewed in its entirety on a screen at once. Our ideal is for each function to fit on 
the screen: one obviolls place for a bug to hide is i.n the code that we can't sec be-
calise it's ofT the screen horizontally or vertically. Code layout mallers. 
Note also that we chan ged the plain 'q' to the symbolic name quit. This im-
proves readability and abo guarantees a compile-time error if we should make 
t.he mistake of choosing a value for quit that clashes wit.h another token name. 
2J5 

236 
(HAPTER 7 • COMPLETING A PROGRAM 
When we dean up code. we might accidentally imrodtiCC errors. Always 
retest the program after cleanup. Belter still, do a bit of testing after each set of 
minor improvements so that if something weill wrong you ca.n still remember ex-
actly what you did. Remember: Tcst early and often. 
7.6.4 Commenting 
\oVc added a few comments as we went along. Good comments are an imponant 
pan of writing code. We tend to forgel about comments in the heat of program-
ming. Wllcn yOll go back to the code to clean it up is an excellent time to look at 
each part of the program to sec if the comments yOll originally wrote arc 
1. Still valid (YOLI might have changed lhe code since you wrolC the comment) 
2. Adequate for a reader (they usually arc nOll 
3. Not so verbose that they distract from the code 
~Io emphasize that last concern: what is best said in code should be said ill code. 
Avoid comments that repeat an action that's perfectly clear 10 someone who 
knows the programming language. For example: 
x = b+c; 
II add band c and assign the result to x 
You'll find sLich comments in this book, but only when we are trying to explain 
the use of a language feature that might not yet be familiar to you. 
Comments are for things that code expresses poorly. An example is intent: 
code says what it docs, not what it was intended to do (§5.g. t). Look at the cal-
culator code. ~111cre is something missing: the functions show how we process ex-
pressions and tokens. but there is no indication (except the code) what we meant 
expressions and tokens to be. TIle grammar is a good candidate for something to 
put in comments or into some documentation of the c.,lcu!ator. 
'" Simple calculator 
Revision history: 
Revised by Bjarne Slroustrup May 2007 
Revised by Bjarne Stroustrup August 2006 
Revised by Bjarne Stroustrup August 2004 
Originally written by Bjarne Stroustrup 
(bsGlcs.lamu.edu) Spring 2004. 
This program implements a basic expression calculator. 
Input from cin; output to coul. 

7.6 
ClEANING UP THE CO DE 
' / 
The grammar (or input is: 
Statement: 
Print: 
Quit: 
Expression 
Print 
Quit 
q 
Expression: 
Term: 
Term 
Expression + Term 
Expression - Term 
Primary 
Term' Primary 
Term I Primary 
Term "/" Primary 
Primary: 
Number 
( Expression ) 
- Primary 
+ Primary 
Number: 
floating-poi nt-literal 
Input comes from cin through the Token_stream called Is. 
Here we used the block commelll, which Slan s with a '* 
and cominues until a */. 
In a real program, the revision history would comain indications of what correc-
tions and improvements were made. 
Note that the comments arc not the code. In fact, this grammar simplifies a 
bit: compare the mle for Statement with what really happens (c.g., have a peek at 
the code in the following section). TIle comment fails to explain the loop in 
calculateO that allows liS to do several calculations in a single mn of the pro-
gram. We'll return to that problem in §7.8.1. 
237 

C HAPTE R 7 • COMPLETING A PRO G RAM 
7.7 Recovering from errors 
Why do we exit when we find an error? T hat seemed simple and obvious at the 
time, bm why? Couldn't wejust write an error message and carry on? After all, 
we often make little typing errors and such an error doesn't mean that we have 
decided not to do a calculation. So lct's try to recover rrom an error. l liat basi· 
cally means that we have to catch exceptions and cominue arter we have cleaned 
up any messes that were lcrt behind. 
Until now, all errors have beell represented as exceptions and handlcd by 
mainO. Ir we want tD recover rrom elTors, caleulaleO must catch exceptions and 
u-y to clean up the mess before trying to evaluate the next expression: 
void calculateO 
{ 
while (ein) 
Iry { 
coul « prompti 
Token t = Is.get(); 
while (t.kind == print) t=ts,gelOi 
if (I-kind == quit) return; 
Is.putback(l)i 
II fi rst discard all Hprints" 
/I quil 
cout « result « expressionO «endl; 
} 
} 
calch (exception& e) { 
} 
cerr « e.whatO« endl; 
dean_up_messO; 
/I write error ml.'SS3ge 
\oVe simply made the while-loop's block into a try·block that writes an error mes· 
sage and d eans up the mess. Once that's done. we carry on as always. 
\<\That would "clean up the mess" entail? Basically, getting ready to compute 
again arter an error has been handled means making sure that all our data is in a 
good and predictable state. In the calculator, the only data we keep oUlSide an in· 
dividual runction is the Token_stream. So what we nccd to do is to ensure that 
we don't have tokens related to the aborted calculation sitting around to conruse 
the next calculation. For example, 
will calise an error, and 2*3; 4+5 will be Icrt in the Token_stream's bufTer arter the 
second + has triggered an exception. We have lWO choices: 

7. 7 
RECOV ERING FROM ERR ORS 
I. Purge all tokens from the Token_stream. 
2. Purge all tokens from the current calculation from thc Token_stream. 
lllC first choice discards all (including 4+5:), whereas the second choice just dis· 
cards 2*3: , leaving 4+5 to be evaluated. Either could be a reasonable choice and 
either could surprise a user. As it happens, both arc about equally simple to im· 
plement. We chose the second altemauve because it simplifies testing. 
So we need to read input until we find a semicolon. This seems simple. We 
have gelO to do our reading for us so we can write a clean_up_messO like this: 
void clean_up_messO 
/I naive 
{ 
while (true) { 
/I skip until we find a prinl 
Token t = Is.geIO; 
if (I,kind == print) return: 
} 
} 
Unfortunately, that doesn't work all that well. \-Vhy not? Consider this input: 
l @z; 1+3: 
"1l1e @ gets us into the catch·clause for the while·loop. Then, we call clean_up_ 
mess() to find the next semicolon. 111en, clean_up_messO calls getO and reads 
the z. "1l1at gives another error (because z is not a token) and we find ourselves 
in mainO's catch( .. ,) handler, and the program exits. Oops! We don't get a 
chance to evaluate 1+3. Back to the drawing board! 
'ATe could try more elaborate trys and catches, but basically we arc heading 
into an even bigger mess. Errors arc hard to handle, and errors during error han· 
dling arc even worse than other errors. So, let's try to devise some way to flush 
characters Out of a Token_stream that couldn't possibly throw an exception. The 
only way of getting input into our calculator is getO, and that can - as wc just 
discovered the hard way - throw an exception. So we need a new operation. The 
obvious place to put that is in Token_stream : 
class Token_stream { 
public: 
Token_strearn(); 
Token get(): 
void putback(Token I): 
void ignore(char c): 
/I make a Token_slream that reads from cin 
/I get a Token 
/I put a Token back 
II discard cl1<1ractcrs up to and including a c 
239 

CH APTER 7 • COMPLETING A PROGRAM 
private: 
booS full; 
II is there a Token in the buffer? 
Token buffer; 
/I here is where we keep a Token put back using putbackO 
); 
~l11is ignoreO function needs to be a member of Token_stream because it needs 
to look at Token_stream's buffer. We chose to make "the thing to look for" an ar-
gument to ignoreO - after all, the Token_stream doesn't have to know what the 
calculator considers a good character to lise for error recovery. We decided that 
argument should be a character because we don't want to risk composing Tokens 
- we saw what happened when we tried that. So we get 
void Token_stream : :ignore(char c) 
/I c represents the kind of Token 
{ 
/I first look in buffer: 
if (full && c==buffer.kind) { 
full = false; 
return; 
full = false; 
/I now search input: 
char ch = 0; 
while (cin>xh) 
if (eh==e) return; 
111is code first looks at the buffer. If there is a e there, we arc finished after dis-
carding that e; otherwise, we need to read characters from cin until we find a e. 
We can now write clean_up_messO rather simply: 
void clean_up_messO 
{ 
ts.ignore(print); 
Dealing with errors is always tricky. It requires much experimentation and test-
ing because it is extremely hard LO imagine what errors can occur. Trying to 
make a program foolproof is always a very technical activity; amateurs typically 
don't care. Qyality error handling is one mark of a professional. 

7.8 
VARIABLES 
7.8 Variables 
Having worked on style and error handling, we can return to looking for im-
provemcnts in thc calculator functionality. We now have a program that works 
quite well; how can we improve it? '11e first wish list for the calculator included 
variables. Having variables gives us better ways of expressing longer calcula-
tions. Similarly, for scientific calculations, we'd like built-in named values, such as 
j>i and e,just as we have on scientific calculators. 
Adding variables and constants is a major extension to the calculatOr. It will 
touch most parts of the code. This is the kind of extension that we should not 
embark a ll without good reason and sufficient lime. Here, we add variables and 
constants because it gives us a chance to look over the code again and try alit 
some more programming techniques. 
7.8.1 Variables and definitions 
Obviously, the key to both variables and built-in constants is for the c.-uculator 
program to keep (IUlIll£,l/{IJue) pairs so that we can access the value given the 
name. We can define a Variable like this: 
class Variable { 
public: 
} ; 
string name; 
double value; 
Variable (string n, double v) :name(n), value(v) () 
We will use the name member LO identify a Variable and the value member to 
SLOre the value corresponding to that name. TIle constnlctor is supplied simply 
for notational convenience. 
How Colll we store Variables so that we can search for a Variable with a given 
name string to find its value or to give it a new value? Looking back over the 
programming tools we have encOLintered so far, we find only one good answer: a 
vector of Variables: 
vector<Variable> var_table; 
We can put as many Variables as we like into the vector var_table and search for 
a given name by looking at the vector clements one after another. We can write a 
get_valueO function that looks for a given name string and returns its correspon-
ding value: 
241 

242 
C HAPTER 7 • COMPL ETI NG A PROG RAM 
double get_value(shing 5) 
{ 
II return the value of the Variable named s 
for (int i = 0; kvaUable.size(); Hi) 
if (va,_lable[iJ.name == 5) return var_table[il.valuei 
error("gel: undefined variable ". 5); 
TIle code really is quite simple: go through every Variable in var_table (starting 
with lhe first element and continuing until the last) and see if its name matches 
the argumcm string s. If that is the case, return its value. 
Similarly, we can define a seCvalue() function 10 give a Variable a new value: 
void scCvalue(slring s, double d) 
/I set the Variable named s to d 
{ 
) 
for (int i = 0; iaaUable.size(); ++i) 
if (vauableliJ.name == s) ( 
var_lablelil.value = d; 
return; 
) 
error(nset: undefined variable ". 5); 
We can now read and write "variables" represented as Variables in var_lable. 
How do we gel a new Variable into var_lable? What docs a user or our calculator 
have to write to define a new variable and later to get its value? We could con· 
sider C++'s notation 
double va, = 7.2; 
lllat would work, but all variables in this calculator hold double values, so say· 
ing "double" would be redundant. Could we makc do with 
var = 7.2; 
Possibly, but then we would be unable to tcllthc differcllcc between the declara-
tion or a new va!'iablc and a spelling mistake: 
var1 = 7.2; 
varl = 3.2; 
II define a new variable called varl 
/I define a new variable called var2 

7.8 
VARIAULES 
Oops! Clearly, we meant var2 = 3.2; but we didn't say so (except in the com-
ment). We could live with this, but we'll follow the tradition in languages, such as 
C++, that distinguish declarations (with initializations) from assignments. We 
could usc double, but for a calculator we'd like something short, so - drawing 
on another old tradition - we choose the keyword let: 
let var = 7.2; 
rnle grammar would be 
Calculation: 
Statement 
Print 
Quit 
Calculation Statement 
Statement: 
Declaration 
Expression 
Declaration: 
"let" Name "=" Expression 
Calculation is the new top production (nile) of the grammar. It expresses the loop 
(in calculate(») that allows us to do several calculations in a run of the calculator 
, program. It relics on the Statement production to handle expressions and decla-
rations. "Ve c.ln handle a statement like this: 
double slatementO 
{ 
) 
Token t = ts.getO; 
switch (I.kind) ( 
case lei: 
return declarationO; 
default: 
ts.pulback(t); 
return expression(); 
) 
Vlc can now lise slalement() instead of expression() in calculate(): 
243 

244 
( HAPTER 7 • COMP LETI NG A PROGRAM 
void calculateO 
{ 
while (dn) 
try ( 
cout« prompt; 
Token I = ts.gel(); 
while (I.kind == print) 1=ls.get(); 
if (I. kind == quit) return; 
ts.pulback(t); 
II first discard all h prjnts ~ 
II quit 
cout« result « statementO« endl; 
} 
catch (c)(ceplion& e) { 
} 
cerr « e.whatO« endl; 
clean_up_messO: 
1/ write error message 
We now have to write d eclaration(). \-Vhat should it do? It should make slIre that 
what comes after a let is a Name followed by a = followed by an Expression . 
That's what our grammar says. What should it do with the name? \P\'c should 
add a Variable with that name string and the value of the expression to OUI" 
veclor<Variable> called var_table. Once that's done we can retrieve the value 
using get_valueO and change it using set_valueO. However, berore writing this, 
we have to decide what should happen ir we defmc a variable twice. For example: 
letv1=7; 
letv1=8; 
We chose to consider such a redefinition an error. lyPically. it is simply a spelling 
mistake. Instead oh..,har we wrote, we probably meam 
letv1= 7; 
letv2=8; 
There arc logically two pans to defming a Variable with the name var with the 
value val: 
1. Check whether there already is a Variable called var in var_table. 
2. Add (var,val) to vaUable. 
We have no use rar uninitialized variables. We defined the runctions is_declaredO 
and define_nameO to represent those (wo 10gic.1.lly separate operations: 

7.6 
VA RI ABLES 
bool is_declared(string var) 
{ 
) 
/I is var already in vau.1ble? 
fo r (int i = 0; i<vauable.sizeO; ++i) 
if (var_table[i).name == var) relurn I.rue; 
return false; 
double define_name(slring var, double val) 
/I add (var,val) 10 vt1uable 
) 
if (is_declared(var» eHor(var," declared twice"); 
var _table. push _back(Va riable(va r, val» ; 
return val; 
Adding a new Variable to a vector<Variable> IS easy; that's what vector's 
push_backO member rUllction does: 
var _table. pu s h_back(Variable(var, val); 
'11C Variable(var,val) makes the appropriate Variable and push_backO then adds 
that Variable to the end or var_table. Given that, and assuming that we can han-
dle lei and name tokens, deciarationO is straightforward to write: 
double deciarationO 
II assume we have seen Hlet"" 
/I handle; name .: expression 
/I declare a variable ca lled "namc"" with the initial value "cxprcssionH 
Token I = ts.get(); 
if (I.kind != name) error ("name expected in declaration"); 
string var_name = I. name; 
Token tl = ts.gel(); 
if (tl.kind != '=') error("= missing in declaration of ", var_name); 
double d = expression(); 
define_name(var_name,d); 
return d; 
245 

, .. 
C H APTE R 7 • COM PLETING A PROGRAM 
Note that we returned the value stored in lhe new variable. "1l1at's useful when 
the initializing expression is nontrivial. For example: 
let v = d!(t2-tl); 
111is declaration will define v and also prim its value. Additionally, priming the 
value of a declared variable simplifies the code in calculateO because every state-
menlO returns a value. General rules tend to keep corle simple, whereas special 
cases tend to lead to complications. 
This mechanism for keeping track of Variables is what is orten called a JYmbol 
table and could be radically simplified by the lise of a standard library map; sec 
§2 1.6. I. 
7.8.2 Introducing names 
ll1is is all very good, but unfortunately, it doesn't quite work. By now, that 
shouldn't come as a surprise. Our first cut never - well, hardly ever - works. 
Here, we haven't even finished the program - it doesn't yet compile. We have 110 
'=' token, but that's easily handled by adding a case to Token_stream : :get() 
(§7.6.3). But how do we represent let and name as tokens? Obviously, we need to 
modify get() to recognize these tokens. How? Here is one way: 
const char name = 'a'; 
const char let = 'L'; 
/I name token 
/I declaration token 
const string declkey = "let"; 
/I declaration keyword 
Token Token_stream: :get{) 
{ 
) 
if (full) { full=false; return buffer; } 
char Chi 
dn » Chi 
switch (ch) { 
/I as before 
default: 
) 
if (isalpha(ch)) ( 
dn.putback(ch); 
Siring s; 
) 
cin>>s; 
if (s == declkeYl return Token(lel); /I declaration keyword 
return Token(name,s); 
error("Bad token"); 

7. 8 
VAl(lABlES 
Note first or all Ule call isalpha(ch). lllis call answers ule question "Is ch a letter?"; 
isalphaO is pari or the standard library that we get rrom stdJ ib_faci lities.h. For 
more character classification rUllclions, see §1 1.6. 111e 10glc ror recognizing 
names is the same as that ror recognizing numbers: find a first character or the 
right kind (here. a letter), then put it back using putbackO and read in the whole 
n:tllle uSll1g » . 
Unronunatc1y, ulis doesn't compile; we have no Token Ulat can hold a string, 
so the compiler rejects Token(name,s). Fortunately, that's easily fixed by adding 
that possibility to the definition or Token: 
strucl Token { 
} ; 
char kind; 
double value; 
string name; 
Token(ehar eh) :kind(eh), value(O) {} 
Token(char eh, double val) :kind(eh), value(val) {} 
Token(ehar eh, string n) :kind(eh), name(n) {} 
We chose 'L' as the representation or the let token and the string lei as our key-
word. Obviously, it would be trivial to change that keyword to double, var, #, or 
wbatever by cbanging the string declkey that we compare s to. 
Now we try the program again. Ir you type this, you'll see that it all works: 
lel )( =3.4; 
lei y =2j 
)( + Y * 2j 
However, this doesn't vmrk: 
lel )( = 3.4j 
lei y = 2; 
)(+y·2; 
What's the difference between those twO examples? Have a look to see what 
happens. 
The problem is that we were sloppy with our definition or Name. We even 
"rorgot" to define our Name production in the grammar (§7.8.~. What charac-
ters can be pari or a name? Letters? Certainly. Digits? Certainly, as long as they 
arc not the starting character. Underscores? Eh? 111e + character? Well? Eh? 
Look at the code again. After the initial letter we read into a string using » . 'That 
accepts every character until it sees whitespace. So, ror example, )(+y*2; is a single 
name - even the trailing semicolon is read as part or lhe name. Thal's unin· 
tended and unacceptable. 
247 

248 
CHAPTER 7 • COM P LETING A PROGRAM 
What must we do instead? First we must specify precisely what we want a 
name to be and then we must modify getO to do that. Here is a workable specifi-
cation of a name: a sequence of Icuers and digits starting with a \ctter. Given this 
definition, 
a 
ab 
a1 
Z12 
asdsddsfdfdasfdsa434RTHTDl2345dfdsa8fsd888fadsf 
arc names and 
as' 
a car 
arc not. Except for leaving Ollt the underscore, this is C++'s rule. "Vc GUl imple-
ment that in the default case of get(): 
default : 
if (isalpha(ch» { 
siring s; 
) 
s += chi 
while (cin.gel(ch) && (isalpha(ch) II isdigit(ch))) s+=ch; 
cin.putback(ch); 
if (s == dedkey) return TokenUet); /1 declaration keyword 
return Token(name,s); 
erro r("Bad token"); 
Instead of reading directly imo the Siring s, we read characters and put those into 
s as long as they are letters or digits. The s+=ch statement adds (appends) the 
character ch to the end of the string s. TIle curious statement 
while (dn.gel(ch) && (isalpha(ch) II isdigil(ch» s+=ch; 
reads a character into ch (using cin's member function gelO) and checks if it is a 
letter or a digit. If so, it adds ch to s and reads again. TIle get() member function 
works just like » except that it doesn't by default skip whitespacc. 

7.8 
VARIAB LES 
7.8.3 Predefined names 
Now that we have names, we can easily predefine a few common ones. For ex-
ample, if we imagine that our calculator will be used for scientific calculations, 
we'd want pi and e. Where in the code would we define t.hose? In mainO before 
the call of calculateO or in calculatcO before the loop. We'll put them in mainO 
because those definitions rcally aren't part of any calculation: 
int mainO 
try ( 
II predefine names: 
define_name("pi" ,3.1415926535); 
define_name("e n ,2.7182818284); 
) 
calculaleO; 
keep_window_open(); 
return 0; 
catch (exception& e) ( 
) 
cerr « e.what() « endl; 
keep_window_open(II-"); 
return 1; 
catch ( ... ) ( 
) 
cerr « "exception \n"; 
keep_window_open("--"); 
return 2; 
7.8.4 Are we there yet? 
II cope with Windows console mode 
Not really. We have made so many changes that we need to test everything 
again, d ean up the code, and review the comments. Also, we could do more def· 
initions. For example, we "forgot'" to provide an assignment operator (see exer· 
cise 2), and if we have an assignment we might want to distinguish between 
variables and constants (exercise 3). 
Initially, we backed off from having named variables in our calculator. Looking 
back over the code that implements lhem, we may have twO possible reactions: 
I. Implementing variables wasn't all that bad; it took only about three 
dozen lines of code. 
249 

254) 
(HAPTER 7 • COMPLETING A PROGRAM 
2. Implementing variables was a major extension. It touched just about 
every fu nction and added a completely new concept to the calculator. It 
increased the size of the calculator by 451)/0 and we haven't even imple-
mented assignment! 
In the context of a first program of significant complexity, the second reaction is 
the correct one. More generally, it's the right reaction to any suggestion that adds 
something like 50% to a program in terms of both size and complexity. When 
that has to be done, it is more like writing a new program based on a previolls 
one than anything clse, and it should be treated that way. In particular, if you can 
build a program in stages as we did with the calculator, and test it at each stage, 
you are far beller off doing so than trying to do the whole program all at once. 
~ 
Drill 
1. Starting from the me calculatorOBbuggy.cpp, get the calculator to compile. 
2. Go through the entire program and add appropriate comments. 
3. As you commented, you found errors (deviously inserted especially for 
you to find). F"tx them; they are not. in the text of the book. 
4. Testing: prepare a set of inpUls and usc them to test the calculator. Is 
your list pretty complete? What should you look for? Include negative 
values, 0, very small, very large, and "silly" inputs. 
5. Do lhe testing and rL'( any bugs that you missed when you commented. 
6. Add a predermed name k meaning 1000. 
7. Give the user a square root function sqrl(), for example, sqrl(2+6.7). Nat-
urally, the value of sqrl(x) is the square root of x; for example, sqrl(9) is 
3. Use t..he standard library sqrtO function that is available through the 
header sld_lib_facilities.h. Remember to update the comments, includ-
ing the grammar. 
8. Catch attempts to take the square root of a negative number and PI;nt an 
appropnate error message. 
9. Allow the user to usc pow(x,i) to mean "Multiply x with itself i times"; 
for example, pow(2.5,3) is 2.5·2.5-2.5. Require i to be an integer using 
the technique we used for %. 
10. Change the "declaration keyword" from lei to N. 
II. Change lhe "quit keyword" from q to exit. That will involve defining a 
string for "quit" just as we did for "let" in §7.8.2. 
Review 
I. \\That is the purpose of working on lhe program after the first version 
works? Give a list of reasons. 

CHAPTER 7 EXERCISES 
2. Why docs "1+2; q" typed into the calculator not quit after it receives an 
cr!"Or? 
3. Why did we choose to makc a constant character ca.lled number? 
4. We split mainO into two separate functions. What docs the new function 
do and why did we split main()? 
5. Why do wc split code into multiple functions? State principles. 
6. VVhat is t.he purpose of commenting and how should it be done? 
7. ,.vhat docs narrow_cast do? 
8. What is the usc of symbolic cOl1Sm.nts? 
9. Why do we care aboUl codc layout? 
10. How do we handle % (remainder) of floating-point numbers? 
II. VVhat docs is_deciaredO do and how does it work? 
12. In.e input reprcsentation for let is marc than onc character. How is it ac-
cepted as a single tokcn in the modified code? 
13. What are mc rules for what names can and cannot be in the calculator 
program? 
14. Why is it a good idea to build a program incrcmentally? 
15. \lVhen do YOll start to test? 
16. VVhen do you retest? 
17. How do yOll dccidc what should be a separate function? 
18. What is .. he lise of symbolic constants? 
19. Why do you add colillllCnts? 
20. What should be in comments and what should not? 
21. When do we considcr a program finished? 
Terms 
codc layoul 
commenung 
error hlll1dling 
feature creep 
Exercises 
maintenance 
recovcry 
revision history 
I. Allow underscores in the calculator's names. 
scaffolding 
symbolic constam 
testing 
2. Providc an assignment opcrator, =, so that you can change me value of a 
variable after YOll introduce it using let. 
3. Providc namcd constants that yOll really can't change the valuc of. Hint: 
You havc to add a mcmber to Variable that distinguishes bctween con-
stants and variables and chcck for it in seevalueO. If yOll want to Ict the 
lIscr dcfmc constants (rather than just having pi and e dcfined as con-
stants), you'll have to add a notation to Ict thc uscr exprcss that, for ex· 
ample, const pi = 3.14; . 
251 

CHAPTER 7 • COM PLETING A PROGRAM 
4. The geCvalueO, seCvalueO, is_deciaredO, and declare_nameO func-
tions all operate on the global variable var_table. Define a elass called 
SymboUable with a member va' _lable of type veclor<Variable> and 
member functions gelO, selO, is_deciaredO, and deciareO. Rewrite the 
c.:-uculator to usc a variable of type SymboUable. 
5. Modify Token_slream: :gelO to retum Token(print) when it sees a new-
line. "Otis implies looking for whitespace characters and treating newline 
('\n') specially. You might find the standard library function isspace(ch), 
which retums true if ch is a whitespace character, useful. 
6. Part of what every program should do is to provide some way of helping 
its user. Have the calculator print out some instmctions for how to use 
the calculator if the user presses the H key. 
7. Change t.he q and h commands to be quit and help, respectively. 
8. "Ine grammar in §7.6.4 is incomplete (we did wam you against overre-
liance on comments); it. docs not define sequences of stat.ements, SUell as 
4+4; 5-6; and it docs not incorporate the grammar changes outIined in 
§7.8. Fix that grammar. Also add whatever yOll feci is needed to tIlat 
conunent as tIle first comment of the calculator program and its overall 
comment. 
9. De[me a class Table that contains a vector<Variable> and provides mem-
ber functions getO, scI(), and deciareO. Replace the var_lable in the cal-
culator witII a Table called symboUable. 
10. Suggest tIuee improvements (not mentioned in tIlis chapter) to the calcll-
lator. Implement one of them. 
11. Modify tIle calculator to operate on ints (only); give errors for overflow 
and underflow. 
12. Implement an assignment operator, so that we can change the value of a 
variable after its initialization. Discuss why that can be useful and how it 
can be a source of problems. 
13. Revisit novo programs you wrote for the exercises in Chapter 4 0 " 5. 
Clean up that code according to tIle rules outlined in tllis chapter. See if 
you find any bugs in lhe process. 
Postscript 
As it happens, we have now seen a simple example of how a compiler works. 
The calculator analyzes input broken down into tokens and understood accord-
ing to a grammar. That's exactly what a compiler docs. Aft.er analyzing its Ol!J-Put 1 y 
.J \ 
a compiler then produces a representation (object code) lhat we can later execute. 
"111e calculalor immediaLCly executes the expressions it has analyzed; programs 
doing tlmt are called interpreters rather lhan compilers. 

'. 
c.J- . 
r- 8 
Techn ical ities: 
Functions, etc. 
"No amount of genius can overcome 
obsession with detail." 
- Traditional 
I
n this chapter and the next, we change our focus from pro-
gramming to OUf main tool for programming: the C++ pro-
gmJ1uning language. \OVe prescllllanguagc-technic.1.I demils to give 
a slightly broader view of C++'s basic facilities and to provide a 
more systematic view of those facilities. These chapters aJso act as 
a review of many of the progranuning notions prcsclllcd so far 
and provide an opponuniry to explore Ollf tool without adding 
new programming techniques 01' concepts. 

254 
CHAPTER 8 • TECHNI CA LI TIES: FUNCTIONS, ETC. 
8.1 Technicalities 
8.2 Declarations and definitions 
8.2.1 Kinds of declarations 
8.2.2 Variable iIInd conslant declarillions 
8.2.1 Def.ull! initialiution 
8.5.4 Pass-by-(onsl' r('ference 
8.5.5 Pass· by-reference 
B.S.6 Pass· by-value vs. pass·by-re'ere"ce 
B.s.7 Argume nt checking and 
conversion 
8.5.8 FUndion cilll implementation 
8.3 Header files 
8.4 Scope 
8.6 Order of evaluation 
8.5 Function call and return 
8.6.1 hpression evaluation 
8.6.2 Global initiilliUo1ion 
8.5.1 Declaring arguments and return 
type 
8.7 Namespaces 
8.S.2 Returning a value 
8.5.1 Pass·by-value 
8.1 Technicalities 
8.7.1 using declarations and using 
directives 
Given a cboice, we'd mllch rather talk about programming tJum about program-
ming language features; that is, we consider how to express ideas as code far 
more interesting than lhe technical details of the programming language that we 
use to express those ideas. 10 pick an analogy from nalLtral languages: we'd 
much rather discuss the ideas in a good novel and the way those ideas arc ex-
pressed than study the grammar and vocabulary of English. What matters are 
ideas and how those ideas can be expressed in code, not the individual language 
featurcs_ 
However, we don't always have a choice. When YOLI start programming, 
your programming language is a foreign language for which you need to look at 
"grammar and vocabulary." "n lis is what we will do in this chapter and the nc.xt, 
but please don't forget: 
Qur primary study is programming. 
Qur output is programs/systcms. 
A programming language is (only) a tool. 
Keeping this in mind appears to be amazingly difficult. Many programmers come 
to care passionately about apparently minor details of language syntax and se-
mantics. In particular, tOO many get the mistaken belief that the way things are 
done in their first programming language is "the one trtle way." Please don't fall 
into that trap. C++ is in many ways a very nice language, but it is not perfect ; 
neither is any other programming language. 
Most design and programming concepts arc universal, and many sLich COIl-
cepts arc widely supported by popular programming languages. "l113t means that 
the fundamental ideas and techniques we Icam in a good programming course 
carry over from lanb'l.lage to language_ TIley can be applied - with varying de-

8.2 
D EClARATI O NS AND D EFINITIONS 
l:,tTCCS of ease - in all ianguagcs. The language technicalities, however, are specific 
to a given language. Fortunately, programming languages do not develop in a 
vacuum, so much of what you learn here will have reasonably obvious coumer-
parts in other languages. In particular, C++ belongs to a group of languages that 
also includes C (C hapter 27), Java, and C*, so quite a few technicalities are 
shared with those languages. 
Note that when we are discussing language-technical issues, we deliberately 
usc nondcscriptive names, such as f, g, X, and y. We do that to emphasize the 
technical nature of such examples, to keep those examples very short, and to try 
to avoid confusing you by mixing language tecllllicalities and genuine program 
logic. When you see nondescriptive names (such as should never be used in real 
code), please focus on the language·technical aspects of the code. Technical ex· 
amples typically contain code that simply illustrates language rules. If you com-
piled and ran them, you'd get many "variable not used" warnings, and few such 
technical program fragments would do rulything sensible. 
Please note llmt what we \\'Tite here is nOt a complete description of C++'s 
syntax and semaillics - not even for the facilities \ve describe. The ISO C++ strul-
dard is 756 pages of dense technical language and The C++ Programming Langflagr 
by Stroustrup is 1000+ pages of text aimed at experienced programmers. We do 
not uy to compete with those in completeness and comprehensiveness; we COIll-
pete with them in comprehensibility and value for time spent reading. 
8.2 Declarations and definitions 
A (lee/amlioll is a statement that introduces a name into a scope (§8.4) 
specifying a type for what is nruned (e.g., a variable or a function) 
optionally, specifying an inilializer (e.g., rul initializer value or a function 
body) 
For exrunple: 
inl a = 7; 
consl double cd = 8.7; 
double sqrl(dauble); 
veclor<Token> v; 
/I an int variable 
/I a double-prl'Cision floating-poinl constant 
II a function taking a double argument 
/I and returning a double result 
/I a vector--of-Tokens variable 
Before a name can be used in a C++ program, it mUSt be declared. Consider: 
inl mainO 
{ 
caul « 
f(i) « '\0'; 
255 

CHAPTER 8 • TEC HNICALITIES; FUNCTIONS, ETC. 
The compiler will give at least three "undeclared identifier" errors for this: cout, 
f, and i arc not declared anywhere in this program fragmem. We can get coul de-
clared by including the header std_lib_facililies.h,which contains iLS declaration: 
#include "std_lib_facililies.h " 
int mainO 
{ 
coul « f(i)« '\n'; 
) 
/I we find the declaration of cout in here 
Now, we get only two "undefined" errors. As you write real-word programs, 
you'll find that most declarations arc found in headers. 111at's where we define 
interfaces to useful facilities defll1ed "elsewhere." Basically, a declaration defines 
how something can be used; it defincs the interface of a function, variable, or 
class. Please note one obvious but invisible advantage of this use of declarations: 
we didn't have to look at the details of how cout and iLS « operators were de-
fined; we just #included their declarations. We didn't even have to look at their 
declarations; from textbooks, manuals, code examples, or other sources, we just 
know how coul is supposed to be used. 111e compiler reads the declarations in 
the header that it needs to "understand" our code. 
However, we still have to declare r and i. We could do that like this: 
#include "std_lib_fadlities.h" 
inl f(int); 
inl mainO 
{ 
// declaration of f 
/I we find the declaration of cout in here 
int i = 7; 
/1 declaration of i 
coul « f(i)« '\n'i 
) 
~nlis will compile because every name has been declared, but it will not link 
(§2.4) because we have not defined ro; that is, nowhere bave we specified what 
fO actually docs. 
A declaration that (also) fully specifics the entity declared is called a eldinifioll. 
For example: 
inl a= 7i 
veClor<double> Vi 
double sqrl(double d) {r .. . -I ) 

8.2 
DECLARATIO NS AND DEFINITIONS 
Every definition is (by definition ©) also a declaration, but only some declara-
(ions arc also definitions. Here are some examples of declarations that are not 
definitions; each must bc matched by a definition elsewhere in the code: 
double sqrl(double); 
extern inl a; 
// no fu nction body here 
/, "extern plus no initializer" means Hnol definitionH 
When we contrast definitions and declarations, we follow convention and use 
deilnmh()11J 10 mean "declarations that are not definitions" even though that's 
slighlly sloppy terminology. 
A definition specifics exactly what a name refcrs to. In particular, a defmition 
of a variable sets aside memory for that variable. Consequently, you can't define 
something twice. For example: 
double sqrl(double d) ( ' * ... */} 
/I definition 
double sqrl(double d) ( /* ... */ } 
/I error: double definition 
int a; 
/I definition 
int a; 
/I error: double definition 
In contrast, a declaration that isn't also a defmition simply tells how you can use 
a name; it is just an interface and doesn't allocate memory or specify a function 
body. Consequently, you can declare something as often as you like as long as 
you do so consistently: 
inl x=7; 
extern int x; 
extern int x; 
double sqrt(double); 
/I definition 
/I declaration 
/I another declaration 
double sqrt(double d) ( ' * ... */ ) 
double sqrl(double); 
/I declaration 
/I definition 
/I another declaration of sqrt 
double sqrt(double)i 
/I yet another declaration of sqrt 
int sqrt(double); 
/I error: inconsistent declarations of sqrt 
Why is that last declaration an error? necause there cannot be tWO functions 
called sqrt taking an argument of type double and returning difTerent types (int 
and double). 
TIle extern keyword used in lhe second declaration of x simply states that 
lhis declaration of x isn't a defmition. It is rarely useful. We recommend lllat you 
don't usc it, but you'll see it in other people's code, especially code that uses too 
many global variables (see §8.4 and §8.6.2). 
257 

258 
C HAPTER 8 • TECHNICALITIES: FUNCTION S, ETC. 
Declarations: 
Definitions: 
,=-=:.::c,.:""---:-:--:-:--:c--, 
I double sqrl(double d) ~ 
~oubl e sqrt(double d) 
~ ~ II calculate the 
I double sqrt<double d) 
II square root of d 
) 
extern int Xi 
~ 
~==
. ==~L _
r-
;"'-x= -7; ----, 
extern ml Xi 
r--
. 
Why docs C++ orrer both declarations and definitions? 111C declaration/def-
inition distincuon reflects the fundamental distinction between what we need LO 
usc something (an interface) and what we need for that something to do what it is 
supposed to (an implementation). For a variable, a declaration supplies the type 
but only the definition supplies the object (the memory). For a function, a decla-
ration again provides the type (argument types plus return type) but only the def· 
inition supplies the function body (the executable statements). Note that function 
bodies are stored in memory as part of the progrnm, so it is fair to say that func-
tion and variable definitions consume memory, whereas declarations don't. 
The declaralionldefinition distinction a1lows us to separate a program into 
many parts that can be compiled separately. TIle declarations allow each part of a 
program to maintain a view of the rest of Lhe progrnm without bothering with 
the definitions in other parts. As all declarations (including the one definition) 
must be consistent, the use of names in the whole program will be consistent. 
We'll discuss that further in §B.3. H ere, we'll just remind you of the expression 
parser from Chapter 6: expressionO calls termO whicl} calls primaryO which c.tlls 
expressionO. Since every name in a C++ program has to be declared before it is 
used, there is no way we could just define those three functions: 
double expression(); 
double primaryO 
{ 
) 
1/ . 
expressionO; 
1/ .. 
double te rmO 
{ 
1/. 
/I jusl a dcclaralion, nol a definilion 

8.2 
DECLARATION S AND DEFIN ITIONS 
primaryO; 
1/ .. 
double expression() 
( 
1/ ... 
lerm(); 
1/ . 
\,Ve can order those four functions any way we like; there will always be one call 
(0 a function defined below it. Somewhere, we need a ';forward" declaration. 
111ercfore, we declared expressionO before the definition of primaryO and all is 
well. Such cyclic calling pauerns are very conunon. 
\"'hy docs a name have to be declared before it is used? Couldn't we just re· 
quire the language implementation to read the program Gust as we do) and find 
lhe definition to sec how a funClion must be called? We could, but that would 
lead to "interesting" technical problems, so we decided against that. 111e C++ 
definition requires declaration before usc (except for class members; see §9.4.4). 
After all, this is already the convention for ordinary (non.program) writing: when 
you read a textbook, you expect the author to define tenninology before using it; 
otherwise, you have to guess or go to the index all the lime. The "declaration be-
fore usc" mle simplifies reading for both humans and compilers. In a program, 
there is a second reason that "declare before usc" is important. In a program of 
thousands of lines (maybe hundred of thousands of lines), most of the functions 
we want to call will be defined «elsewhere." 111ai "elsewhere" is often a place we 
don't really want to know about. Having to know the declarations only of what 
we usc saves liS (and the compiler) from looking through huge amounts of pro-
gram text. 
8.2.1 Kinds of declarations 
-nlere arc many kinds of entities that a programmer can define in C++. ~r" e 
most mteresllng arc 
Variables 
Constants 
Functions (sec §S.5) 
Namcspaccs (sec §S.7) 
Types (classes and enumerations; see Chapter 9) 
Templates (sec Chapter 19) 
25. 

260 
C HAPTER 8 • TE C H NICALITIES: FU NC TI O NS, ETC. 
8.2.2 Variable and constant declarations 
' n lC declaration of a variable or a constant specifics a name, a type, and option· 
ally an initializcr. For example: 
int aj 
double d = 7; 
veclor<int> vi(10); 
II no initializcr 
II initializer using the = syntax 
/I initializer using the 0 syntax 
You can fmd the complete grammar in The C++ Fmgmmmillg Ul1lgUIl{f by SlrOUSlnlP 
or in the ISO C++ standard. 
Constants have the same declaration syntax as variables. TIley difTer in hav-
ing const as part of their type and requiring an initializer: 
const inl x = 7; 
const inl x2(9); 
const int Yi 
/I initializer using the = syntax 
/I initializer lIsing the 0 syntax 
II efror: no initializer 
111e reason for requiring an initializer for a const is obvious: how could a consl 
be a constant if it didn't have a value? It is almost always a good idea to initialize 
variables also; an uninitialized variable is a recipe for obscure bugs. For example: 
void f(int 2:) 
( 
} 
int Xi 
/I uninitialized 
1/ . . . no assignment to x here , 
X = 7; 
/I give x a value 
1/ . . . 
111is looks innocent enough, but what if the first . . included a lise of x? For 
example: 
void f(int z) 
( 
} 
int Xi 
1/ un initialized 
/I . .. no assignment to x here. 
if (z>x) ( 
/I . .. 
} 
1/ . . . 
x = 7i 
/I give x a value 
1/ . .. 

8 .3 
HEADER FILES 
Because x is uninitialized, executing z>x would be undefined behavior. TIle eom-
p<1I;son z>x could brive different results on different machines and different results 
in different nlllS of the program on the same machine. In principle, z>x might 
cause the program to terminate with a hardware error, but most orten that doesn't 
happen. Instead we get unpredictable results. 
Naturally, we wouldn't do somethi.ng like that deliberately, but if we don't 
consistemly initialize variables it will eventually happen by mistake. Remember, 
most <;silly mistakes" (such as using an uninitialized variable before it has been 
assigned to) happen when you arc busy or tired. Compilers try to warn, but in 
complicated code - where such errors arc most likely to occur - compilers arc 
110t smart enough co catch all such errors. TIlerc afe people who arc nOt in the 
habit of initializing their variables, often because they learned to program in lan-
bruages that didn't allow or encourage consistenl initialization; so you'll sec exam-
ples in other people's code. Please just don't add to the problem by forgetling to 
initialize the variables you define yourself. 
8.2.3 Default initialization 
You might have noticed that we often don't provide an initializer for strings, 
... ectors, etc. 1-o r example: 
... ector<string> v; 
string s; 
while (cin>>s) .... push_back(s); 
-nlis is not an exception to the nile that variables must be initialized before usc. 
What is going on here is that we have defined string and vector to be initialized 
with a default value whenever we don't supply one explicitly. -n lUS, v is empty (it 
has no elements) and s is the empty sU'ing ("tI) before we reach the loop. The 
mechanism for guaranteeing default initialization is called a cUjiwil cons/ruc/Qr, see 
§9.7.3. 
Unfortunately, the langtIage doesn't allow us to make such bruarantees for 
built-in t)'pes. A global variable is default initialized to 0, but you should mini-
mize the usc of global va1ues. -nle most usdul variables, local variables and class 
members, arc uninitializcd unless you provide ail initialize .. (or a default eOIl-
structor). You have been warned! 
8.3 Header files 
How do we manage o Lir declarations and definitions? After all, they havc to bc 
consistent, and in real-world programs there can be tens of thousands of declara-
tions; programs with hundreds of thousands of declarations arc not rarc. Typi-
cally, whell we write a program, mOst of the definitioll5 we Lise are not written by 
261 

2'2 
CHAPTER 8 • TECHNICALITIE S; FUNCTIONS, ETC. 
us. For example, the implementations of coul and sqrt() were '\!Tiucn by someone 
else many years ago. We juSt usc them. 
"nlC key to managing declarations of facilities defined "'elsewhere" in C++ is 
the header. Basically, a header is a collection of declarations, I ypically defined in a 
file, so a header is also called a heal/.er file. Such headers arc then #induded in our 
source files. For example, we might decide to improve the organization of the 
source code for our calculaLOf (Chapters 6 and 7) by separating out the token 
management. \OVe could define a header file token.h containing declarations 
needed to usc Token and Token_stream: 
token.h: 
II declarations: 
class Token { 1* ... O/ }; 
class Token_stream { r ... */ }; 
loken.cpp: 
/ 
cal,"laIO~ 
#include "token.h" 
Ildefinitions: 
void Token_stream: : putback(Token t) 
#include "token.h" 
( 
/1 uses: 
buffer = t; 
... 
full = true; 
Token_stream ts; 
) 
... 
Token t = ts.get(); 
... 
. .. 
ts.pulback(t); 
... 
'11e declarations of Token and Token_stream are in the header token.h. ' 11eir 
dcflllitions are in token.cpp. '11e .h suffIx is the most common for C++ headers, 
and the .cpp suffIx is the Illost common for C++ source files. Actually, the C++ 
language doesn't care about file suffLXes, but some compilers and IllOSt program 
development environments illsist, so please usc this convention for yOllr source 
code. 
In principle, #include "file.h" simply copies the declarations from file.h into 
your file at the point of the #indude. For example, we could write a header f. h: 
/I f.h 
int f(int); 
and include it in our file f.cpp: 

8.3 
HEADER FI LES 
/I f.cpp 
#include "f_h" 
int g(int i) 
{ 
return W ); 
) 
When compiling I.cpp the compiler would do the #include and compile 
int f(in!); 
int g(int i) 
{ 
return Hil; 
Since #includes logically happen before anything else a compiler docs, handling 
#includes is pan of what is called preprowsillg (§A.17). 
10 ease consistency checking, we #include a header both in source ftIes that 
use its declarations and in source fLIes that provide definitions for those declara-
tions. 111at way, the compiler catches errors as soon as possible. For example, 
imagine that the implementer of Token_stream: :putback() made mistakes: 
Token Token_stream: :putback(Token t) 
{ 
bu ffer. push _ back(t); 
return t; 
) 
This looks innocent enough. ro ftunately, the compiler catches the mistakes be-
cause it sees the (#included) declaration of Token_shearn : :putbackO. Compar-
ing that declaration with our defmition, the compiler finds that putbackO should 
not return a Token and that buffer is a Token, rather than a vector<Token>, so 
we can't use push_backO. Such mistakes occur when we work on our code 1.0 im-
prove it, but don't quite get a change consistent throughout a program. 
Similarly, consider these mistakes : 
Token t = ts.gett(); 
II ... 
tS.l>utback(); 
1/ error: no member gell 
1/ error: argument missing 
111e compiler would immediately give errors; the header token.h gives it all the 
infonnation it needs for checking. 
263 

264 
( HAPTER 8 • TECHNICALITIE S: FUNCT IONS, ETC. 
Our std_lib_facililies.h header contains declarations for me standard library 
facilities we lISC, slich as caut, vector, and sqrt(), together with a couple of simple 
utility fUllctions, slIch as errorO, that are not part ofthe standard library. In §12.8 
we show how to lISC the standard library headers directly. 
A header will typically be included in Immy source mes. TImt means that a 
header should only contain declarations that can be duplicated in several files (such 
as function declarations, class definitions, and definitions of numeric conslll.llts). 
8.4 Scope 
A scope is a region of program text. A name is declared in a scope and is valid (is 
"in scope") from the point of its declaration umilthc end of I,hc scope in which it 
was declared. For example: 
void fO 
{ 
gO; 
II error: gO isn't (yet) in scope 
} 
void gO 
{ 
fO; 
/I OK: f() is in scope 
} 
void hO 
{ 
} 
inlx=y; 
inty=x; 
gO; 
/I error: y isn't (yet) in scope 
/I OK: x is in scope 
/I O K: gO is in scope 
Names in a scope can be seen from within scopes nested within it. For example, 
the call of fO is within the scope of gO which is "nested" in the global scope. 11le 
global scope is the scope that's nOl ncstcd in any Olher. 111C rule that a name 
must be declared before it can be used still holds, so fO cannot call gO. 
There are several kinds of scopes that we use to control where our names 
can be used: 
TIle global JCOjJe: the area of text outside any other scope 
A IIflllll!JpaU JlojJe: a named scope nested in the global scope or in another 
namcspace; see §8.7 
A ,laJJ JrojJe: the area of text within a class; see §9.2 

8. 4 
SCOPE 
A local scope: betwecn { . .. } braces of a block or in a function argument 
lisl 
A J/a/t11lt!11/ Jloj)(: e.g., in a for-statement 
rn l C main pUll)Ose of a scope is to keep names local, so that they won't interfere 
with namcs declarcd elsewhere. For example: 
void f(inl xl 
/I f is global; x is local to f 
{ 
int z = x+7i 
liz is local 
) 
inl g(int x) 
/I g is global; x is local 10 g 
{ 
int r = x+2; 
/I f is local 
return 2*f; 
) 
Or graphicaUy: 
Global scope: 
fD 
gD 
Here f() 's " is difTerent from gO's x. 'nlCY don't "clash" because they arc not in 
the same scope: fO's " is local to f and gO's " is local to g. 1'\\'0 incompatible dec-
larations in the same scope are often referred to as a claJlI.. Similarly, the f deHned 
and used within gO is (obviously) not the function fO. 
Here is a logically equivalent but more realistic example of the lise of local 
scope: 
int max(int a, inl b) 
{ 
return (a>=b) ? a : b; 
) 
inl abs(int a) 
{ 
return (.1<0) 1-.1 : ai 
) 
/I max is global; a and b are local 
II not max()'s a 
2.5 

266 
C HAPTER 8 • TE CHN ICALITIES: FUNC TIONS, ETC. 
You find maxO and absO in the standard library, so you don't have to write them 
yourself. TIle ?: construct is called an ant/llne/ic if or a cQnditiolla! exprt!S1ioll. '11C 
value of (a>=b)la:b is a if a>=b and b Olhcrwisc. A conditional expression saves 
us from wriLing long-winded code like this: 
int max(inl a, int b) 
( 
} 
int Ill; 
if (a>=b) 
m=a; 
else 
m=b; 
return m; 
/I max is global; a and b arc local 
/I m is local 
So, with the noticeable exception of the global scope, a scope keeps names local. 
For most purposes, locality is good, so keep names as local as possible. When I 
declare my variables, functions, etc. within functions, classes, namcspacc, Ctc., 
they won't interfere with yours. Remember: real programs have Inilll)' thousands 
of named entities. To keep sueh programs manageable, most names have to be 
local. 
Here is a larger technical example illustrating how names b'O alit or scope at 
the end or statements and blocks (including function bodies): 
/Ina r, i, or v here 
class My_vector { 
vector<int> Vi 
public: 
intlargeslO 
( 
II v is in class scope 
int r = 0; 
/I r is local (smallest nonnegative inl) 
} 
for (int i = 0; i<v.size(); ++i) 
r = max(r,abs(v[iJ)); 
II i is in the for's statement scope 
/I no i here 
return r; 
II no r here 
}; 
II no v here 
int Xi 
int y; 
II global variable -
avoid those where you can 

8.4 
SCOPE 
int fO 
{ 
int Xi 
X = 7; 
{ 
} 
II local variable 
lIthe local x 
intx =y; 
++x; 
II local X initialized by global y 
lIthe X from the previous line 
++X; 
II the x from the first I ine of f() 
relurn I; 
Whenever you can, avoid such complicated nesting and hiding_ Remember: 
"Keep it simple!" 
111e larger the scope or a name is, the longer and more descriptive its name 
should be: I , y, and f are horrible as global names. TIle main reason that yOll 
don -t want global variables in your program is that it is hard to know which runc-
lions modiry them. In large programs, it is basically impossible to know which 
rUllctions modiry a global variable. Imagine that you arc trying to debug a pro-
gram and you find that a global variable has an unexpected value. Who gave it 
that value? \Vhy? What runctions write to that value? How would you know? 
111e runction that wrote a bad vallie to that variable may be in a source file yOll 
have never seen! A good program will have only very few (say, one or lWO), ir 
any, global variables. For example, the calculator in Chapters 6 and 7 had two 
global variables: the token stream, Is, and the symbol table, names. 
Note that most C++ constructs that define scopes nest: 
Functions within classes: member runelions (sec §9.4.2) 
class C ( 
public: 
void fO ; 
void gO 
{ 
II a member function can be defined wi thin its class 
/I . .. 
} 
/I . .. 
} ; 
void C::fO 
{ 
1/ . .. 
} 
II a member definition can be outside its class 
This is the most common and userul case. 
267 

268 
CHAPTER 8 • TECHNICALITIES: FUNCTIONS, ETC. 
C lasses wiLhin classes: member classes (also called nested classes) 
class C { 
public: 
}; 
struct M { 
II . 
} ; 
1/ • •• 
This tends LO be useful only in complicated classes; remember that the 
ideal is to keep classes small and simple. 
Classes within functions: local classes 
void fO 
{ 
} 
class L ( 
II . 
); 
1/ . .. 
Avoid this; if you fcdthe need for a local class, yOUT function is probably 
far too long. 
Functions within functions: local functions (also c.'dled nested functions) 
void fO 
{ 
void gO 
/I illegal 
{ 
/I ... 
II . .. 
Illis is not legal in C++; don't do il. The compiler will reject it. 
Blocks within functions and mher blocks: nested blocks 
void f(inl .. , inl y) 
{ 
if (oy) { 
} 
else { 
1/ . .. 
II. 
{ 

8. 5 
FUNCTION CAll AND RET URN 
II . 
} 
1/ ..• 
Nested blocks are unavoidable, but be suspicious of complicated nesting: 
it can easily hide errors. 
C++ also provides a language feature, namespaee, exclusively for expressing 
scoping; see §8.7. 
Note OUT consistent indentation to indic."1te nesting. Without consistent in-
dentation, nested constructs become unreadable. For example: 
II dangerously ugly cooe 
strue! X { 
void Wnt x) { 
strue! Y { 
int fO { return 1i } int m j }i 
int m i 
m=xi Y m 2j 
return f(m2.fOJi } 
int m i void g(int m) { 
if (m ) fCm+2)i else ( 
g(m+2)i )} 
XU () void m30 { 
} 
void mainO ( 
X a j a.f(2);} 
}; 
Hard-to-read code usually hides bugs. When you use an IDE, it tries to automat-
ically make your code properly indented (according to some definition of ;;prop-
erlyn), and there exist "code beautifiers
n that will reformat a source code file for 
you (often alTering you a cllOicc of formats). However, the ultimate responsibility 
for your code being rcadable rests with you. 
8.5 Function call and return 
Functions are the way we represent actions and computations. Whenever we 
wam to do something that is worthy of a name, we write a fu nction. The C++ 
language gives us operators (such as + and .) with which we can produce new 
values from operands in expressions, and statements (such as for and if) with 
2" 

270 
( H APTE R 8 • TECHNICALITIES; FUNCTIONS, ETC. 
which we can control Lhc order of execution. To organize code made Ollt of these 
primitives, we have functions. 
To do its job, a function usually needs arguments, and many functions rctum 
a resull. ~ntis section focllses on how arguments are specified and passed. 
8.5.1 Declaring arguments and return type 
Functions arc what we lISC in C++ to name and rcprcsem computalions and ac-
tions. A function declaration consists of a rctum type followed by the name of the 
function followed by a list of fomml arguments in parentheses. For example: 
double fcl(inl a, double d); 
II declaration of fel (no body) 
double fcl(inl a, double d) { return a"d; } 
II definition of fel 
A definition contains the function body (the StalCmcnts to be executed by a call), 
whereas a declaration that isn't a definition just has a semicolon. Formal argu-
ments are often called parallldm. U you don't want a function to take arguments, 
just leave out the formal arguments. For example: 
inl currcnC powerOi 
/I current_power doesn't lake an argument 
If you don't want to return a value from a function, give void as its return type. 
For example: 
void increase_power(int level); 
/I increase..power doesn't return a value 
Here, void means "doesn't return a value" or "return nothing." 
You can name a parameter or not as it suits you in both declarations and def· 
initions. For example: 
/I search for s in vs; 
II vs[hintl might be a good place 10 start the search 
/I return the index of a match; - 1 indicates Nnol found~ 
int my_find (veClor<string> vs, string s, int hint); 
int my_find (vector<string>, string, int); 
II naming arguments 
/I not naming arguments 
In declarations, formal argument names are not logically necessary, just very usc· 
ful for writing good comments. From a compiler's point of view, the second dec· 
laration of my_iindO is JUSt as good as the first: it has all the information 
necessary to caU my_find O. 
Usually, we name all the arguments in the definition. For example: 

8.5 
FU NCTION CAll AND RETU RN 
int my_find (vector<slring> vs, string s, int hint) 
/I search for s in vs starting at hint 
{ 
if (hint<O II vs.sizeO<=hint) hint = 0; 
for (int i = hint; kvs.sizeO; ++i) 
II search starting from hint 
if (vs[il==s) return i; 
if (o<hint) { 
II if we didn't find s search before hint 
for (int i = 0; khint; ++i) 
if (vslil==s) return i; 
return-l ; 
} 
rille hint complicates the code quite a bit, but the hint was provided under the as· 
sumption that users could usc it to good effect by knowing rougWy where in the 
vector a string will be found. However, imagine that we had used my_find O for a 
while and then discovered that callers rarely used hint well, so that it actually 
hurt performancc. Now we don't need hint anymore, but there is lots of code 
"out there" that calls my_findO with a hint. We don't want to rewrite that code 
(or can't because it is someone else's code), so we don't want to change the decla-
ration(s) of my_findO . Instead, we just don't use the last argument. Since we 
don't usc it we can leave it unnamed : 
int my_find(vector<string> vs, string s, int) 
{ 
for (int i = 0; i<vs.size(); Hi) 
if (vs(;]==5) return i; 
return -1 ; 
/I 3 rd argument unused 
You can find the complete grammar for function definitions in nle C++ I+ogram-
millg Lallgufl{f by Slrousrrup or in the ISO C++ standard. 
8.5.2 Returning a value 
V.'e return a value from a function using a return statement: 
T fO 
II fO returns aT 
{ 
} 
v V; 
/I. 
return v; 
Tx=f(); 
271 

CHAPTER 8 • TEC HNICALITIES: FUNCTIONS, ETC. 
Here, the value returned is exactly the value we would have gotten by initializing 
a variable of type T by a value of type V: 
VVi 
II ... 
T t(V)i 
/I initialize t with v 
11mt is, value return is a form of initialization. A fu nction declared to return a 
value must return a value. In particular, it is an error to "fall through the end of 
the fUllction": 
double my_abs(int x) 
( 
/I warning: buggy code 
if (x < O) 
return -Xi 
else if (x > 0) 
relurn Xi 
} 
II error: no value returned if x is 0 
Actually, the compiler probably won't notice that we "forgot" the case x==O. In 
principle it could, but few compilers arc that smart. For complicated functions, it 
ca.n be impossible for a compiler to know whether or not you return a value, so 
be careful. Here, "being careful" means to make really sure that you have a re-
turn statement or an errorO for every possible way out of the function. 
For historica.l reasons, mainO is a special case. Falling lhrough the boltOm of 
mainO is equivalent to returning the value 0, meaning "successful completion" of 
the program. 
In a function that docs not return a value, we can usc return without a value 
to cause a return from the function. For exalllple: 
void print_until_s(consl vcctor<slring> v, canst string quit) 
( 
) 
for(int i=O; i<v.sile(); •• i) ( 
if (vliJ==quit) return; 
coul « vli] « '\n'i 
) 
As yOll ca.1l see, it is acceptable to "drop through the bottom" of a void fUllclion. 
~nlis is equivalent to a return;. 

8.5 
FUNCTIO N CALL A ND RET URN 
8.5.3 Pass·by·valu. 
~n1e simplest way of passing an argument to a function is to give li1e function a 
copy of the value you lise as the argument. An argument of a function fO is a 
local variable in fO li1at's initialized each time fO is called. For example: 
/I pass-by-valuc {give the function J copy of the value passed) 
int f(int xl 
{ 
x=x+1; 
return X; 
/I give the local x a new value 
int mainO 
( 
) 
intxx=O; 
cout « f(xx) «endl; 
cout «
xx « endl; 
int yy = 7; 
cout « f(yy)« endl; 
cout « yy« endl; 
/I write: 
II write: 0; f() doesn't change xx 
/I write: B 
I/write: 7; f() doesn't change yy 
Since a copy is passed, the x=x+ 1 in fO docs nm change the values xx ,md yy passed 
in the two calls. We ca.11 illustrate a pass-by-valuc argument passing like this: 
xx: 
" 
l ~ call: 
0 
I Copy the value I 
0 
yy: 
" 
2'" call: I 
7 
I Copy the value I 
7 
Pass-by-value is pretty straightforward and its cost is the cost of copying li1e value. 
8.5.4 Pass-by-const-reference 
Pass-by-value is simple, straightforward, and efficient when we pass small values, 
such as an int, a double, or a Token (§6.3.2). But what if a valuc is large, SUci1 as 
an image (often, several million bits), a large table of values (say, thousands or in-
tegers), or a long string (say, hundreds or characters)? 111en, copying can be 
273 

274 
CHAPTER 8 • TEC HNICALI TIE S: FUNCTIONS, ETC. 
costly. We should not be obsessed by cost, blll doing unnecessary work can be 
embarrassing because it is an indication that we didn't directly express our idea 
of what we wamed. For example, we could write a function to print out a vector 
of floating-point numbers like this: 
void prinl(veclor<double> v) 
/I pasS-by-villue; appropriate? 
{ 
) 
cout«
"{ "; 
for (int i = 0; kv.size(); ++i) ( 
cout« \I[i]; 
if (i! =v.sizeO-l ) cout« ", "; 
) 
cout «" }\n
lt
; 
We could lise this printO for vectors of all sizes. For example: 
void f(int x) 
{ 
) 
vector<double> vdl(10); 
/I small vector 
veclor<double> vd2(1000000); 
II large vector 
veclor<double> vd3(x); 
/I vector of some unknown size 
II . . . fill vd l , vd2, vd3 with values .. . 
prinl(vdl ); 
print(vd2); 
prinl(vdJ)i 
~111is codc works, but the first call of printO has to copy ten doubles (probably 80 
bytes), the second call has lO copy a million doubles (probably 8 megabytes). and 
we don't know how much the third call has to copy. The question we mUSt ask 
ourselves here is: "\\Thy are we copying anything at all?" We just wanted to print 
the vectors, not to make copies of their elements. Obviously, there has to be a 
way for liS to pass a variable to a function without copying it. As an analogy, if 
you were given the task to make a list of books in a library, the librarians 
wouldn't ship you a copy of the library building and all its contents; they would 
send you lhe address of the library, so that YOll could go and look al the books. 
So, we need a way of giving our printO function "the address" of the vector to 
printO rather than the copy of the veclor. Such an "address" is called a rrfer~1Ia 
and is used like tlus: 

8 .5 
FUNCTION CAL L AND RETU RN 
void prin1(eonsl veclor<double>& v) 
( 
eoul « "{ "; 
or (inl i = 0: i<v.size(): ++i) ( 
coul « vO]: 
/I pass-by-const-reference 
if (i!=v.sizeO-l) coul « ", "; 
coul « " }\n"; 
) 
'11e & means "referencen and the consl is there to stop printO modifying its ar-
gument by accident. Apart from the change to the argument declaration, all is the 
same as before; the only change is that instead of operating on a copy, print() 
now refers back to the argument through the reference. NOle the phrase "refer 
back"; such arb'UmeI1ts arc called references because they "refern to objecLS de-
fined elsewhere. We can call this prinlO exactJy as before: 
void f(int x) 
( 
veclor<double> vdl (10); 
/I small vector 
veelor<double> vd2(1000000); 
!! Iarge vector 
veClor<double> vd3(x); 
/I vector of some unknown size 
/I ... fill vdl , vd2, vd3 with values .. . 
print(vd1 ); 
print(vd2); 
print(vd3); 
We can illustrate that graphically: 
v: 
'--------'~ 
Refcr to vd2 in 2,01 call 
vd2: 
Refer to vd1 in 1 
~ call 
vd1 : 
A const reference has the useful property that we Co:'l.Il't accidemally modify the 
object passed. For example, if we made a silly error and tried to assign to an cle-
ment from .. vithin prinl(), the compiler would catch it: 
275 

27. 
CHAPTER 8 • TECHNICALITIES: FUNCTIONS, ETC. 
void prinl(consl vector<double>& v) 
{ 
II pass-by-const-reference 
II . .. 
vii] =7; 
II . .. 
II error: v is a const (is nOl mutable) 
) 
Pass-by-const-rcfcrcncc is a useful and popular mechanism. Consider again the 
my_find O function (§B.S.l) tbat searches for a string in a vector of strings. Pass-
by-value could be unnecessarily cosLly: 
int my_find (vector<slring> vs, string S)i 
/I pass-by-value: copy 
If the vector contained thousands of strings, you might notice the time spent 
even on a fast computer. So, we could improve my_findO by making it take its ar-
guments by const reference: 
II pass-by-const-reference: no copy, rcad-only access 
int my_find(const vcdor<string.>& vs, const slring& S)i 
8.5.5 Pass-by-reference 
But what if we did want a function to modify its argumcnts? Sometimes, that's a 
perfectly reasonable thing to wish for. For example, wc might want an init() func-
tion thal assigned values to vector clements: 
void inil(veclor<double>& v) 
{ 
/I pass-by· reference 
fo r (int i = 0; i<v.size(); ++i) vii] = i; 
) 
void g(int x) 
{ 
) 
veclor<double> vd1 (10); 
vector<double> vd2(1000000); 
veclor<double> vd3(x); 
init(vd1); 
init(vd2); 
init(vd3); 
/I small vector 
II large vector 
II vector of some unknown size 

6 .5 
FUNCTION CAll ANO RETUR N 
Here, we wanted init() to modify the argument vector, so we did not copy (did 
not use pass-by-value) nor declare thc reference const (did not usc pass-by-const-
value), but simply passcd a "plain reference" to the vector. 
Let us consider references from a more technical point of view. A refercnce is 
a construct that allows a user to declare a new name for an object. For example, 
inl& is a reference to an int, so we can write 
int i = 7i 
int& r = ii 
r = 9i 
i = 10i 
II r is a reference to i 
II i becomes 9 
, ~rl 
-
-,,0--, 
coul « r «"« i« '\n'i 
II write: 10 10 
lllat is, any usc of r is really a use of i. 
References can be useful as shorthand. 1-"Or example, we might have a 
veclor< vector<double> > Vi 
II vector of vector of double 
and we need to refer to some element v[f(x)][g(y)J several times. Clearly, vlf(x)][g(yll 
is a complicated expression that we don't want to repeat more often than we have 
to. If we JUSt need its value, we could write 
double val = v[r(x)JIg(y)J; 
II val is the value of vli(xll [g(yl) 
and usc val repeatedly. But what if we need to both re:.d from v[f(x)JIg(y)) and 
write to v(f(x)J[g(y))? TIlen, a reference comes in handy: 
double& var = v(f(xlllg(yl]i 
II var is a reference to v[f(x)1Ig1y)1 
Now we can read and write v(f(x)](g(y)] through var. For example: 
var = varl2+sqrt(var)i 
·111is key property of references, that a reference can be a convenient shorthand 
for some object, is what makes them useful as arguments. For example: 
/I pass-by-refcrence (let the function refer back to the variable passed) 
inl f(inl& x) 
{ 
x= x+l i 
return Xi 
277 

278 
( HAP TER 8 • TE CH NICALITI ES : FUNCTIONS, ETC. 
int main() 
( 
intxx=O; 
/I write: I 
coul« f(xx)« endl; 
coul« xx « e ndl; 
/I write: I; fO changed the value of xx 
int yy = 7; 
/I write: 8 
cout« f(yy)« end!; 
cout « yy« endl; 
/I write: 8; fO changed the value of yy 
) 
We can illustrate a pass·by-rcfcrence argument passing like this: 
x: 
' " call (x refe.rs 10 xx) 
xx: 
o 
2nd c:t11 (x refers 10 yy) 
yy: 
7 
Compare this LO the similar example in §8.5.3. 
Pass-by-refcrcncc is clearly a very powerful mechanism: we C:"1n have a function 
operate directly on any object to whidl we pass a reference. For example, swapping 
tWO values is an immensely important operation in many algOlilhms, SUdl as son-
ing. Using references, we can wnte a function that swaps doubles like this: 
void swap(double& d1 , double& d2) 
( 
double temp = d1 ; 
d1 = d2; 
II COP)' dl 's value to temp 
II copy d2's value 10 d2 
d2 = temp; 
/I copy d 1 's old value to d2 
) 
int main() 
( 
) 
double x = 1; 
double y = 2; 
cout « "x == "« x«
" y== "« y« '\n'i 
swap(x,y); 
cout « "x== " «x«" y==" «y« '\n'; 
/I write: X== I y==2 
II write: x==2 Y== 1 

6 .5 
FUNCTION CAll AND RETURN 
111e standard library provides a swapO for every type that you can copy, so you 
don't have to write swapO yourself for each type. 
8.5.6 Pass·by.value vs. pass·by-referenee 
\"'hen should you usc pass-by-value, pass-by-rcfercnce, ,md pass-by-const-reference? 
Consider [lrSt a teclUlical example: 
void f(i nt a, int& r, eonst int& erl 
I 
++a; 
II change the local a 
++r; 
/I change the object referred to by r 
++er; 
/I error: cr is const 
} 
If you want to change the value of the object passed, you must use a non-const 
reference: pass-by-value gives you a copy and pass-by-const-referencc prevents 
you from changing the value of the object passed. So we can try 
void g(int a, int& r, canst int& crl 
I 
} 
++a; 
++r; 
int x = cr; 
inl mainO 
I 
) 
inl x = 0; 
int y=O; 
inl z=O; 
g(x,y,zl; 
gI1,2,3); 
gI1,y,3); 
/I change the local a 
/I change the object referred to by r 
/I read the object referred to by cr 
/I x==O; y== 1; z==O 
/I error: reference argument r needs a variable to refer to 
/I OK: since cr is const we can pass a literal 
So, if you want to change the value of an object passed by reference, you have to 
pass an object. Technically, the integer literal 2 is just a value (an rvalue), rather 
than an object holding a value_ What you need for gO's argument r is an lvalue, 
that is, something that could appear on the left-hand side of an assignment. 
Note that a const reference doesn't need an lvalue. It can perform conver-
sions exactly as initialization or pass-by-value. Basically, what happens in that last 
call, g(1,y,3), is that the compiler sets aside an int for gO's argument Cf to refer to: 
279 

280 
CHAPTER 8 • TECHNICALITIES: FUNCTIONS, ETC. 
g(1,),,3); 
/I means: inl _compiler....generated = 3; g( 1 ,y,_compiler-&eneraled) 
SUdl a compiler-generated object is called a temporary object or just a IClII/Xffat)'. 
Our rule of thumb is: 
I . Use pass·by-value to pass very small objects. 
2. Use pass-by-consi-referellcc to pass large objects that you don't need to 
modify. 
3. Return a result rather than modifying an object through a reference 
argument. 
4. Use pass-by-rcferencc only when you have to. 
Illese rules lead to the simplest, least error-prone, and most efficient code. By 
"very small" we mean one or twO ints, one or twO doubles, or something like 
that. If we see an argument passed by non-const-reference, we must assume that 
the called function will modify that argument. 
11mt third rule reflects that you have a dloice when you want to usc a func· 
tion to change the value of a variable. Consider: 
int incr1(inl a) { return a+1; } 
void incr2(inl& a) ( ++a; ) 
II return the new value as the result 
II modify object passed as reference 
inlx=7; 
x = incr1(x); 
incr2(x); 
II pretty obvious 
II pretty obscure 
Why do we ever usc non-consl-reference arguments? Occasionally, they are es-
sential 
For manipulating containers (e.g., vector) 
For functions that change several objects (we can have only one return 
value) 
For example: 
void larger(vector<in1>& v1 , veclor<in1>& v2) 
{ 
} 
II make each element in vi the larger of Ihe corresponding 
II elements in vl and v2; 
II similarly, make each elemenl of v2 the smaller 
if (v1.sizeO!=v2.sizeO error("larger(): different sizes"); 
for (int i=O; i<v1 .sizeO; ++i) 
if (vl[i]<v2[i]) 
swap(v1 [i],v2[i]); 

8.5 
FUNCTION CALL AND RETURN 
void fO 
{ 
vector<int> VJI:; 
vector<int> vy; 
1/ read vx and vy from input 
larger(vx,vy); 
/I ... 
Using pass-by-rcferenee arguments is the only reasonable choice for a function 
like largerO. 
It is usually best to avoid functions that modify several objects. In theory, 
there arc always altematives, sLich as returning a class object holding several val-
ues. However, there arc a lot of programs "OLlt there" expressed in terms of func-
tions that modify Olle or more arguments, so you arc likely to encounter them. 
For example, in Fortran - the major programming language used for numerical 
calculation for abOLlt 50 years - all arguments are passed by reference. Many nu-
mel;c programmers copy Fortran designs and call functions written in Fonran. 
Such code often uses pass-by-rcfercnce or pass-by-const-reference. 
If we usc a reference simply to avoid copying, we use a const reference. Con-
sequently, when we see a non-const-reference argument, we assume that the 
function changes the value of its argument; that is, when we see a pass-by-non-
const-reference we assume that not only can that function modify the argument 
passed, but that it will, so that we have to look extra carefully at the call to make 
sure that it docs what we expect it to. 
8.5.7 Argument checking and conversion 
Passing an argument is the initialization of the function's formal argument with 
the actual argument specified in the call. Consider: 
void f(T Xl; 
fry); 
T x=y; 
II initialize x with y (sec §8.2.2) 
TIle call f<y) is legal whenever the initialization T x=y; is, and when it is legal both 
x's get the same value. For example: 
void {(double); 
void g(int y) 
{ 
fry); 
double x(y); 
) 
281 

282 
CHAPTER 8 • TECHNICALITIES: f U NCTI O N S, ETC. 
Note that to initialize J{ with y, we have to convert an int to a double. ~nl C same 
happens in the call of fO. TIle double value received by fO is the same as the one 
stored in x. 
Conversions arc often useful, but occasionally they give surprising results 
(see §3.9.2). Consequently, we have to be careful with them. Passing a double as 
an argument to a function that requires an int is rarely a good idea: 
void ff(int); 
void gg(double xl 
{ 
ff(x); 
/I how would you know i( this makes sense? 
) 
If you really mean to truncate a double value to an int, say so cxplici Lly: 
void ggg(double xl 
{ 
int xl = x; 
1/ truncate x 
) 
int x2 = int(x); 
H(xl ); 
ff(x2)i 
(f(x); 
ff(int(x)); 
/I truncate x 
11m! way, the next programmer to look at this code can sec that yOll thought 
about the problem. 
8.5.8 Function call implementation 
But how docs a computer really do a function call? 111c expression(), lermO, and 
I>rimaryO functions from Chapters 6 and 7 a~ perfcct for illusU"aling this cxccpt 
for one detail: they don't take any arguments, so we can't use them to explain 
bow arguments are passed. But wait! They 1IIusl take some input; if they didn't, 
they couldn't do anything useful. They do take an implicit argument: they usc a 
Token_stream called Is to get their input; Is is a global variable. That's a bit 
sneaky. We can improve these functions by letting them take a Token_slream& 
argument. Here they are with a Token_slream& parameter added and everything 
lhat doesn't conccm function call implementation removed. 

8.5 
FUNCTION CAll AND RET U RN 
First, expressionO is completely straightfonvard; it has one argument (Is) 
and twO local variables (left and I): 
double expression(loken_slream& Is) 
( 
) 
double left = lerm(ls)j 
Token I = IS. gel OJ 
1/ . .. 
Second. lermO is much like expressionO, except that it has an additional local 
variable (d) that it uses to hold the result of a divisor for 'I' : 
double term(Token_slream& Is) 
( 
double left = primary(ls)j 
Token t = ts.gelOi 
1/ ••• 
1/ . .. 
case 'f : 
double d = primary(ls)j 
/I. 
111ird, primaryO is much like lermO except that it doesn't have a local variable 
leU: 
double primary(Token_stream& IS) 
{ 
Token I = Is. gel OJ 
swilch (t.kind) ( 
case '(': 
) 
( 
double d = expression(ls)j 
/I . .. 
) 
1/ . .. 
Now they don't usc any "sneaky global variables" and are perfect for our illus-
tration: they have an argument, they have local variables, and they call each 
283 

284 
CHAPTE R 8 • TECH NICALI TIES; FUNCTIONS, ETC. 
other. You may w anllO take the opportunity LO rdresh your memory of what the 
complete expression(), telmO, and primary() looks like, but the salient features as 
rar as function call is conccm ed are presented here. 
When a function is caJlcd, the language implementation sets aside a data 
StruCtUTC containing a copy of all its parameters and local variables. For example, 
when expressionO is first called, the compiler ensures that a structure like this is 
created: 
Call of expression(): ~t''-;, ____ --I 
I.ft 
t 
Implementation 
stuff 
· nlC "implementation Stuff'" varies from implementation to implememation, but 
that's basically the information that the function needs to rctum LO its caller and 
to rctum a value to its caller. Such a data structure is called a jill/dion adivation 
rea.ml, and each funcuon has ilS own detailed layout of ilS activation record. Note 
that from the implementation's point of view, a parameter is just another local 
variable. 
So far, so good, and now expressionO caUs term(), so the compiler ensures 
that an activation record for lhis call of termO is generated : 
Call of expressionO: 
Call of termO: 
IS 
lef' 
t 
Implementation 
.ruff 
IS 
left 
t 
d 
Implementation 
stuff 
Din:Clioll of 
Slack growlh 
Note that termO has an extra variable d that needs to be stored, so we set aside 
space for that in the call even though the code may never get arollnd to using it. 
111at's OK. For reasonable functions (such as every function we directly or incH-
recdy use in this book), the run-time COSt of laying down a function activ:llion 
record doesn't depcnd on how big it is. The local variable d will be initialiled 
only if we exeeUie its case 'r. 
Now termO calls primaryO and we get 

8 .5 
FUNCTION CAll AND RET URN 
Call or expression(): 
Is 
left 
I 
Implementation 
stufT 
Call or termO: 
Is 
left 
I 
d 
Implementation 
stuff 
G ill or primaryO: 
I. 
I 
d 
Implementation 
stufT 
Oireoion or 
Slack growth 
111is is staning to get a bit repetitive, but now primaryO Gllls expression(): 
Can or expressionO: 
G.,11 or lermO: 
Call or primary() : 
Call or expression() 
ts 
left 
I 
Implementation 
stuff 
ts 
left 
I 
d 
hnWementation 
stu 
ts 
I 
d 
Implementation 
stufT 
IS 
left 
I 
ImWementation 
.tu 
Direction or 
stack b'l'Owth 
2.5 

2. 6 
C HAPTER 8 • TECHNICALITIES: f UNCTI O NS, ETC. 
So this call of expressionO geLS its own activation record, different from the first 
c.-til of expression(). llmt's good or else we'd be in a terrible mess, since left and t 
will be different in the twO calls. A function that directly or (as here) indirectly 
calls itself is called rmmiue. As yOll sec, recursive functions follow naturally from 
the implementation technique we usc for function call and rerum (and vice versa). 
So, each time we call a function the .sineR. rf acliuaJio1/ records, usually just called 
the l lndf, grows with one record. Conversely, when the function returns, jts 
record is no longer used. For example, when that last call of expression() returns 
to primaryO, the Slack will revert to this: 
Call of expression() 
Call of termO 
Call of primaryO 
Is 
left 
I 
Implementation 
stulT 
Is 
left 
I 
d 
Implementation 
stulT 
Is 
I 
d 
Implementa tion 
stuff 
Direction of 
stack growth 
And when that call of primary() retums to termO, we gel back to 
Call of expression() 
Call of te rm() 
Is 
left 
I 
Implementation 
stulT 
Is 
left 
I 
d 
Implementation 
stuff 
Direction of 
stack b"l'owth 

8.6 
OROER OF EVALUATION 
And so on. The stack, also called the call Jtadi., is a data structure that grows and 
shrinks at one end according to the nile: first in, first out. 
Please remember that the details of how a call stack is implemented and used 
vary from C++ implementation to C++ implementation, but the basics arc as 
outlined here. Do you need to know how function calls arc implemented to lise 
them? Of course not; you have done well enough before this implementation 
subsection, but many programmers like to know and many usc phrases like 
"activation record'"' and "call stack,'" so it's better to know what they mean. 
8.6 Order of evaluation 
'nle evaluation of a program - also called the execution of a program - proceeds 
through the statements according to the language rules. When this "thread of ex· 
eClllion" reaches the defin.ition of a variable, the variable is constructed; that is, 
memory is set aside for the object and the object is initialized. \V"hen the variable 
goes out of scope, the variable is destroyed; thai is, the object it refers to is in 
principle removed and the compiler can lise its memory for something clse. For 
example: 
string program_name = "silly"; 
veclor<string> V; 
void fO 
{ 
/I v is global 
string S; 
/I sis local 10 f 
} 
while (cin» s && s!="quiltl) ( 
} 
II . 
Siring stripped; 
/I stripped is local to the loop 
Siring noeletters; 
for (int i=O; k s.size(); ++i) 
/I i has statement scope 
if (isalpha(s{iJ)) 
stripped += s[i]; 
else 
noUetters += sri]; 
v.p ush_ back(sl ripped); 
II ... 
Global variables, such as program_name and v, arc in.itialized before the frrst stt1te· 
ment of mainO is cxecUled. TIley "live" until the program tenninalCS, ,md then 
they are destroyed. TIley are constructed in the order in which they are defmed 
287 

288 
( HAPTER 8 • TECHNICALITIES: FUN CTIONS, ETC. 
(that is, program_name before v) and destroyed in the reverse order (that is, 'tI be-
fore program_name). 
\\'hen someone calls fO, first s is constructed; that is, s is initialized to the 
empty string. It will Jive until we return from roo 
Each time we enler the block that is the body of the while-loop, stripped and 
noeletters arc constructed. Since stripped is defined before noUellers, Slripped 
is conSlnlctcd before noUeUers. TIley live until the end of the loop, where they 
arc destroyed in the reverse order of construction (that is, noUeu ers before 
stripped) before the condition is reevaluated. So, if ten strings arc seen before we 
cncoumer the string quit, stripped and noeletters will each be CQIlSlnlClCd and 
destroyed ten times. 
Each lime we reach lhe for-loop, i is constlucted. Each time we exit the for· 
loop, i is destroyed before we reach the v.push_back(stripped); statement. 
Please l10te that compilers (and linkers) arc clever beasts and they arc 011· 
lowed to - and do - optimize code as long as lhe results arc equivalent to what 
we have described here. In particular, compilers arc clever at not allocating and 
deallocaling melllory more often than is really necessary. 
8.6.1 Expression evaluation 
111e order of evaluation of sub·expressions is governed by rules designed to 
please an optimizcr rather than to make life simple for the progranuner. 11ml's 
unfortunate, but you should avoid complicated expressions anY'..,ay, and there is 
a simple rule that can kecp you out of trouble: if you change the value of a vari· 
able in an expression, don't read or wTite it ovice in that same expression. For 
example: 
v(i] = ++i; 
v(Hij = i; 
int x = ++i + ++i; 
cout « ++i«
' t «
i « '\rat; 
(Hi,Hi); 
/I don't: undefined order of evaluation 
/I don't: undefined order of evaluation 
/I don't: undefined order of evaluation 
II don't: undefined order of evaluation 
/I don'l: undefined order of evaluation 
Unfortunately, not all compilers warn if you write such bad code; it's bad be· 
caLIse you can't rely on the results being the same if you move your code to an· 
other computer, usc a different compiler, or usc a different optimizer selling. 
Compilers really differ for such code;just don't do it. 
Note in particular that = (assigmllem) is considered just another operator in 
an expression, so there is no guarantee that the left·hand side of an assignment is 
evaluated before the right·hand side. "lltat's why VIHil = i is undefined. 
8.6.2 Global initialization 
Global variables (and namespacc variables; sec §S.7) in a single translation unit 
arc initializ.ed in the order in which they appear. For example: 

8 .6 
O RDER OF EVALUATION 
/I file fl.epp 
inlx1=1 ; 
int y1 = x1+2; 
/I Y 1 becomes 3 
111is initialization logically takes plaee "before the code in mainO is exeeuled." 
Using a global variable in anything but the most limited circumstances is usu-
ally not a good idea. We have mentioned the problem of the progranuner having 
no really elTective way of knowing which pans of a large program read and/or 
write a global variable (§8.4l. Another problem is lhat the order of initialization of 
global variables in dilTerenttranslation units is not defined. For example: 
/I file f2.epp 
extern int y1 ; 
inl y2 = y1+2; 
/I y2 becomes 2 or 5 
Such code is to be avoided for several reasons: it uses global variables, it gives lhe 
global variables short names, and it uses complicated initialization of the global 
variables. If the globals in rue f1 .cpp arc initialized before the globals in f2.cpp, y2 
will be initialized to 5 (as a prob'Tammer might naively and reasonably expect). 
However, if the gJobais in file f2.cpp are initialized before the globals in f1 .cpp, y2 
will be initialized to 2 (because the memory used for global variables is initialized 
to 0 before complicated initialization is attempted). Avoid such code, and be very 
suspicious when you see global variables with nontrivial initializers; consider any 
initializer that isn't a constant expression complicated. 
BUl what do YOLI do if you really need a global variable (or constant) with a 
complicated initializer? A plausible example would be that we wanted a default 
value for a Dale type we were providing fOT a library supporting business trans-
actions: 
consl Dale defauICdale(1970, 1,1); 
II the default date is 1.1rlUary 1, 1970 
How would we know that defaulCdale was never used before it was initialized? 
Basically, we can't know, so we shouldn't write that definition. llle technique 
that we usc most often is to call a function that retums the value. For example: 
consl Dale default_daleO 
( 
return Dale(1970,1,1); 
/I return the default Dale 
lllis constructs the Dale every time we call default_daleO. rIltat is often fine, but 
if defaull_dateO is called often and it is expensive to construct Dale, we'd like to 
construct the Dale once only. That is done like this: 
289 

290 
CHAPTER 8 • TECHNICALITIES: FUNCTIONS, ETC. 
const Oate& default_dateO 
{ 
) 
slatic consl Dale dd(1970,1,1); 
return dd; 
/I initialize dd first time we gel here 
A sialic local variable is initialized (constructed) only the first time its fUllction is 
called. Note that we returned a reference to eliminale unnecessary copying and, 
in particular, we returned a const reference to prevent the called function from 
accidentally changing lhc value. TIle arguments about how to pass an argument 
(§8.5.6) also apply to returning values. 
8.7 Namespaces 
We lise blocks LO organize code within a function (§8.4). \ Vc usc classes to organ-
ize functions, data, and types imo a type (Chapler 9). A function and a class both 
do t,,:o things for liS : 
Thcy allow LIS to define a number of "emities" without worrying that 
their names clash with other names in our program. 
They give us a name to refer to what we have defined. 
\<\That we lack so far is something to organize classes, functions, data, and types 
into an identifiable and named pan of a program without defining a type. 'Ille 
language mechanism for such grouping of declarations is a 1/(lllleJj)(lce. For exam· 
pic, we might like to provide a graphics library with classes called Color, Shape, 
Line, Function, and Text (sec Chapter 13): 
namespace Graph_lib { 
) 
struct Color (/* ... *'}; 
struct Shape {/* ... *' }i 
strucl Line: Shape (/* ... *'}; 
strucl Function : Shape U* ... */}; 
strucl Text: Shape {/* ... *'}; 
1/ .. 
inl gui_mainO (/* ... *'} 
Most likely somebody else in lhe world has used those names, but now lhat 
doesn't matter. You might define something called Text, but our Text doesn't in-
terfere. Graph_lib : :Text is one of our classes and your Text is not.. We have a 
problem only if you have a class or a namespace called Graph_lib with Text as its 

8 .7 
NAMESPACES 
member. Graph_lib is a sliglllly ugly name; we chose it because the "pretty and 
obvious" name Graphics had a greater chance of already being used somewhere. 
Let's say thm your Text was part of a text manipulation library. '11e same 
logic that made us put our graphics facilities into namespace Graph_lib should 
make you put your text manipulation facilities into a namespace called some-
thing like TextLib: 
namespace TextLib ( 
class Text ( ' - .. . • , }; 
classGlyph{ ' · ... ·, ); 
class Line {' - . .. -I}; 
/I ... 
} 
Had we both used the global namespace, we could have been in real trouble. 
Someone tI)'ing to use both our libraries would have had really bad name clashes 
for Text and line. Worse, if we both had users for our libraries we would not 
have been able to change our names, such as Line and Text, to avoid clashes. 'vVe 
avoided that problem by lIsing namespaces; that is, our Text is GraphJib: :Text 
and yours is TextLib: :Text. A name composed of a namespace name (or a class 
name) and a member name combined by :: is called a }illly qualified /lame. 
8.7.1 using declarations and using directives 
Writing fully qualified names can be tedious. For example, the facilities of the 
C++ standard library are defined in nrullespace std and can be used like lhis: 
#include<string> 
#include-<iostream> 
int mainO 
( 
std : :string name; 
/I gel the siring library 
/I get the ioslream library 
sid : :cout « "Please enter your first name\n"; 
sid : :cin » name; 
sid : : caul « "Hello, " « name « '\n'; 
} 
Having seen the standard library string and cout lhousands of limes, we don't 
really want to have to refer to them by their "proper" fully qualified names 
std: :string and std: :cout all the tUne. A solmion is to say that ;;by string, I mean 
sid: :string," "by cout, I mean std: :coul," ctc.: 

292 
using std : :slring; 
using sid : :coul; 
1/ .. . 
CH APTER 8 • TECH N ICA LITIES: FUNCTIONS, ETC. 
1/ string means std::slring 
II cout means std::cout 
That construct is called a using declaration; it is the progranuning equivalent to 
lIsing plain "Greg" to refer to Greg Hansen, when there are no other Cregs in the 
room. 
Sometimes, we prefer an even stronger "shorthand" for the usc of namcs 
from a namcspacc: "If you don't fmd a declaration for a name in this scope, look 
in std." The way to say that is to usc a using directive: 
using namespace sid; 
II make names from sid directly accessible 
So we get this common slyle: 
#include<string> 
#include<ioslream> 
using namespace Sid; 
inl main() 
{ 
string name; 
1/ get the Siring library 
/I get the ioslream library 
/I make names from sid directly acc~sib l e 
coul « "Please enler your first name\n"; 
dn » name; 
coul « "Hello, "« name« '\n'; 
) 
111e d n is sid : :dn, lhe siring is sid: :slring, elC. As long as you usc SldJib_fadl. 
ilies.h, you don't need to worry about standard headers and the sid namesp"ce. 
It is usually a good idea to avoid using directives for any namespace except 
for a namespace, such as Sid, thai's extremely well known in an application area. 
TIle problem with ovemse of using directives is that you lose track of which 
names come from where, so that YOLl again start to get name clashes. Explicit 
qualification with namespace names and using declarations doesn't suffer from 
that problem. So, putting a namespace directive in a header me (so that users 
can't avoid it) is a very bad habit. However, to simplify our initial code we did 
place a using directive for sid in sld_lib_fadlilies.h. '1mt allowed LIS to write 
#include "SldJib_fadlilies.h" 
inl mainO 
{ 

CHAPTE R 8 DR il l 
string name; 
cout « "Please enter your first name\n"; 
d n » name; 
cout « "Hello, " « name« '\n'; 
\Ve promise never LO do that for any namespaec except std . 
...; Drill 
I. Create three flies: my.h, my.cpp, and use.cpp. The header me my.h 
contains 
extern int foo; 
void prinUooO; 
void prinl(inl); 
TIle source code me my.cpp #includes my.h and stdJib_fadlities.h, de· 
fines prinCfooO to print the value of foo using cout, and print(int i) LO 
print the value of i using coul. 
~111e source code file use.cpp #includes my.h, defines main() to set 
the value of foo to 7 and print it using print_fooO, and to print the value 
of 99 using printO. Note that use.cpp does not #include Sld_lib_fadli. 
ties.h as it doesn't directly use any of those facilities. 
Gel these files compiled and lUn. On Windows, you need to have 
both use.cpp and my.cpp in a project and lise { char cc; dn»cc; ) in 
use.cpp to be able to see your output. 
2. Write three functions swap_v(int,inl), swap3(int&,int&), and swap_cr(consl 
int&, consl inl&). Each should have the body 
( int tempi temp = a, a=b; b=tempi ) 
where a and b are tlle names of the arguments. 
Try calling each swap like this 
intx =7; 
int y =9i 
swap_l(x,y}; II replace r by II, r, or cr 
swap_l(7,9); 
const int ex = 7; 
const int cy = 9; 
swap_l(cx,cy); 
swap_l(7.7,9.9); 
293 

CHAPTER 8 • TECHNICALITIES: FUNCTIONS, ETC. 
double dll = 7.7; 
double dy = 9.9; 
swap_l(dll,dY)j 
swap_l{dll,dY)j 
Which calls compiled, and why? After each swap that compiled, print 
the value of the arguments after the caU to see if they were actually 
swapped. If you arc surprised by a result, consult §a.6. 
3. Write a program using a single me containing three namespaces X, Y, and 
Z so that the following MainO works conectly: 
inl MainO 
{ 
} 
X::vat= 7i 
X::ptinl()j 
/I prinl X's var 
using namespace Vi 
vat = 9; 
ptinl()j 
/I prinl V's var 
( 
using Z: :varj 
using Z: :ptintj 
vat=ll j 
print(); 
/I print Z'S var 
} 
print()j 
X: :print()j 
/I print V's var 
/I print X's var 
Each namespace needs to define a variable called var and a function 
called prinlO that outputS the appropriate var using cout. 
Review 
I. What is the differencc between a declaration and a definition? 
2. How do we syntactically distinguish between a function declaration and 
a function definition? 
3. How do we syntactically distinguish between a variable declaration and 
a variable definition? 
4. \"'h)' can't you use the functions in the calculator program from Chapter G 
without declaring them first? 
5. Is int aj a definition or just a declaration? 
6. Why is it a good idea to initiaJize variables as they are declared? 
7. vVhat "'m a function declaration consist or? 

CHAPTER 8 TERMS 
8. What good docs indentation do? 
9. \"'hat arc header files used for? 
10. \"'hat is the scope of a declaration? 
II . What kinds of scope arc there? Give an example of each. 
12. What is the difference ben"een a class scope and local scope? 
13. \Vhy should a programmer minimize the number of global variables? 
14. What is the difference between pass·by-value and pass-by·reference? 
15. What is the difference between pass-by-reference and pass-by-consl-
reference? 
16. What is a swap()? 
17. Would you ever define a function with a veclor<double>-by-value pa-
rameter? 
18. Give an example of undefined order of evaluation. Why can undefined 
order of evaluation be a problem? 
19. What do x&&y and "liy, respectively, mean? 
20. Which of the following is standard-confornling C++: functions within 
functions, functions within classes, classes within classes, classes within 
functions? 
21 . What goes into an activation record? 
22. What is a call stack and why do we need one? 
23. \¥hat is the purpose of a namespace? 
24. How does a namespace differ from a class? 
25. \¥hat is a using declaration? 
26. \¥hy should you avoid using directives in a header? 
27. \¥hat is namespace sId? 
Terms 
activation record 
argument 
argument passmg 
call stack 
class scope 
consl 
declaration 
definition 
extern 
fonvard declaration 
function 
function definition 
global scope 
header file 
initializer 
local scope 
namespace 
namespace scope 
nested block 
parameter 
pass-by-co nsl-reference 
pass-by-rcfercnce 
pass-by-value 
recursion 
return 
return value 
scope 
statement scope 
teclmicalities 
undeclared identifier 
using declaration 
using directive 

CHAPTER 8 • TEC H NICA LITI ES: FUNC TIONS, ETC. 
Exercises 
I. Modify the calculator program from Chapter 7 to make the input stream 
an explicit parameter (as shown in §8.5.8). Also give the Token_stream 
constructor and isfream& parameter so that when we figure out how to 
make our own istreams (e.g., attached to files), we can usc the calculator 
for those. 
2. Write a function printO that prints a vector of ints to cout. Give it twO ar-
guments: a string for "labeling" the output and a vector. 
3. Create a vector of Hbonacci numbers and print them using the function 
from exercise 2. 10 create the vector, write a function, fibonacci(x,y,v,n), 
where integers x and y are ints, v is an empty vector<int>, and n is lhe 
number of clements to put into v; vlO) will be x and v(1) will be y. A 
Fibonacci number is one that is part of a sequence where each clemelll is 
the sum of the twO previous olles. For example, starting with I and 2, we 
get I, 2, 3, 6, 9, 15, 24, . . .. Your fibonacciO function should make such 
a series starting with its x and y arguments. 
4. An inl can hold integers only up to a maximum number. Find an ap-
proximation of that ma.ximum number by using fibonacciO. 
5. Write two functions that reverse lhe order of clements in a vector<int>. 
For example, 1, 3, 5, 7, 9 becomes 9, 7, 5, 3, I. The first reverse function 
should produce a new vector with me reversed sequence, leaving its orig-
inal vector unchanged. TIle other reverse function should reverse the cl-
ements of its vector without using any orner vectors (hint: swap). 
6. Write versions of the functions from exercise 5, but with a vector<string>. 
7. Read five names into a vector<string> name, then prompt the user for the 
ages of the people named and store the ages in a vector<double> age. ~Illen 
print out the five (name[i],agelil) pairs. Son me names (sorl(name.beginO, 
name.end(») and print out the (nameliJ,age[il) pairs. "Ille tricky part here 
is to get the age vector in the correct order to match the sorted name 
vector. Hint: Before sorting age, t.'lke a copy and use thm to make a copy of 
age in me right order after sorting age. 111el1, do that exercise again but al-
lowing an arbitrary number of naIlles. 
8. Write a simple function rand intO that produces a pseudo-random number 
in the range [O:MAXINT). Hint: Knuth, The Art f!!Compuler Programming, 
Volume 2. 
9. Write a function that - using randintO from the previous exercise -
COIU-
putes a pseudo-random integer in the range [a:b): rand_in_range(int a, 
inl b). Note: TIus function is very useful ror writing simple games. 
10. Write a function that given two vector<double>s price and weight com-
putes a value (an "'index") that is the sum or all pricelWweightliJ. Note 
that we must have weight.sizeO<=price.size(). 

CHAPTER 8 PO ST SC RIPT 
11. Write a function man'O that relUrns the largest element of a vector 
argument. 
12. Write a function that finds the smallest and the largest elemelll of a 
vector argument and also computes the mean and the median. Do not 
use global variables. Either return a slruct containing the results or pass 
them back through reference arguments. Which of the two ways of re-
turning several result values do you prefer and why? 
13. Improve prinC unliLs() from §8.5.2. Test it. What makes a good set of 
test cases? Give reasons. ~nl en , write a prinCuntil_ssO that prints until it 
sees a second occurrence of its quit argument. 
14. Write a function that takes a veclor<slring> argument and returns a 
vcctor<inl> containing the number of characters in each slIing. Also fmd 
the longest and the shorlest Siring and the lexicographically first and last 
Siring. How many separate functions would you usc for these Lasks? 
Why? 
15. Can we declare a non-reference function argument consl (e.g., void 
((consl in!);)? What might that mean? Why might we wam to do that? 
Why don't people do that often? Try it; write a couple of small programs 
to see what works. 
Postscri"t 
We could have put much of this chapter (and much of the next) into an appen-
di.'(. However, you'll need most of the facilities described here in Part 11 of this 
book. You'l! also encounter most of the problems that these facilities were in-
vented to help solve very soon. Most simple programming projects that you 
might undertake will require you to solve such problems. So, to save time and 
minimize confusion, a somewhat systematic approach is called for, rather than a 
series of "random" visits to manuals and appendices. 
2.7 


Technicalities: 
Classes, etc. 
"Remember, things take time." 
-Piet Hein 
I
n this chapler, we keep our focus on OUT main tool for pro-
gramming: the C++ programming language. We present lan-
guage technicalities, mostly related to user-defined types, that is, 
to classes and enumerations. Much of the presentation of lan-
guage features takes the form of the gradual improvement of a 
Date type. That way, we also get a chance to demonstrate some 
useful class design techniques. 
299 

300 
CHAPTER 9 • TECHNI CA LITIES: ClASSES, ETC. 
9.1 User·defined types 
9.2 Classes and members 
9.3 Inlerface and implementation 
9.4 Evolving a class 
9.4.1 shuct and functions 
9.4.2 Member functions ilnd 
constructors 
9.4.3 Keep d("lails private 
9.4.4 Defining member functions 
9.4.5 Referring 10 the current object 
9.4.6 Reporting errors 
9.1 User-defined types 
9.5 Enumerations 
9.6 Operator overloading 
9.7 Class interfaces 
9.7.1 Argument types 
9.7.2 Copying 
9.7.3 Default constructors 
9.7.4 consl member functions 
9.7.5 Members and " helper functions" 
9.B The Dale class 
111C C++ language provides you with some built-in types, such as char, in I, and 
double (§A.8). A type is called built-in if the compiler knows how to represent 
objects of the type and which operations can be done on it (such as + and -) with-
out being told by declarations supplied by a programmer in source code. 
Types that arc not built-in arc called wer-dqined typa (UDTs). TIley can be 
standard library types - available to all C++ programmers as part of every ISO 
Standard C++ implementation - such as Siring, vector, and ostream (Chapter 
10), or types that we build for ourselves, such as Token and Token_stream (§6.S 
and §6.6). ru soon as we get the necessary technicalities under our bell, we'll 
build graphics types such as Shape, line, and Text (Chapter 13). TIle standard li-
brary types arc as much a part of the language as the built-in types, but we still 
consider them user·defined because they arc built from the sallle prim..itives and 
with the same techniques as the types we built ourselves; the standard library 
builders have no special privileges or facilities that you don't have. Like the built-
in types, most uscr-defUled types provide operations. For example, vector has II 
and sizeO (§4.6.1, §B.4.8), ostream has « , Token_stream has getO (§li.8), and 
Shape has add(Point) and seCcolorO (§14.2). 
Why do we build typcs? The compiler docs not know all the types we might 
like to lise ill our programs. It couldn't, because there are fa r too many useful 
types - no language designer or compiler implementer could know them all. We 
invent new ones every day. Why? What are types good for? Typcs are good for 
directly representing ideas in code. When we write code, the ideal is to represent 
ollr ideas directly in our code so that we, our colleagues, and the compiler can 
understand what we wrote. When we want to do integer arithmetic, int is a great 
help; when we want to manipulate text, string is a great help; when we want to 
manipulate calculator input, Token and Token_stream are a great help. TIle help 
comes in twO forms: 

9. 2 
( LASSES AND MEMBE RS 
Repre~71latioTl : A type "knows" how to represent the data needed in an 
object. 
Ojx mli01u: A type "knows" what operations can be applied to objects. 
Many ideas follow this patlern: "something" has data to represent its current 
value - sometimes called the cun"Cnt Jlale - and a set of operations that can be 
applied. "nlink of a computer file, a web page, a toaster, a CD player, a coffee 
cup, a car engine, a cell phone, a telephone directory; all can be characterized by 
some data and al1 have a more or less fIXed set of standard operations that you 
mn perform. In each case, the result of the operation depends on the data - the 
"currellt state" - of an object. 
So, we wam to represent such an "idea" or "concept" in code as a data S lru C~ 
ture plus a set of functions. The question is: "Exactly how?" This chapter pres-
ents the technicalities of the basic ways of doing that in C++. 
C++ provides (wo kinds or user-defined types: classes and enumerations. 
111C class is by rar the most general and important, so we first roclls on classes. A 
class directly rcpresents a concept in a program. A c/'lJJ is a (user-defined) type 
that specifics how objects or its type are represented, how those objects can be 
created, how they arc used, and how they can be destroyed (see §17.5). If you 
think or something as a separate entity, it is likely that you should define a class 
to represent that "thing" in your program. Examples are vector, matrix, input 
stream, string, FFT (rast Fourier transronn), valve controller, robot arm, device 
driver, picture on screen, dialog box, graph, window, temperature reading, and 
clock. 
In C++ (as in most modern languages), a class is the key building block ror 
large programs - and very useful ror small ones as well, as we saw ror our calcu-
lator (Chaptcrs 6 and 7). 
9.2 Classes and members 
A class is a user-defined type. It is composed or built-in types, other user-defined 
types, and runctions. The parts used to define the class are called memberJ. A class 
has zero or more members. For example: 
class X ( 
public: 
int nli 
1/ data member 
int mf(int v) ( int old = m i m=Vi return old; ) 
); 
1/ function member 
Members can be of various types. Most are eilher data members, which define 
the represemation or an object or the class, or runction members, which provide 
"" 

302 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
operations on such objects. We access members using the objcd.membt'r notation. 
For example: 
X va,; 
var.m = 7; 
int x = var.mr(9)i 
/I var is a variable of type X 
/I assign to var's data member m 
1/ call var's member function mf() 
You call read var.m as var's m. Most people pronoullce it "vaf dOl m" or ""ar's m," 
The type of a member determines what operations we can do on it. We call read 
and wnte an int member, call a function member, Ctc. 
9.3 Interface and implementation 
Usually, we think of a class as having an interface plus an implementation. 111c 
interface is the part of the class's declaration that its users access direcliy. '11C im-
plementation is that part of the class's declaration that its users access only indio 
rectly through the interface. The public interface is identified by the label public: 
and lhe implementation by the label private :. You can think of a class declaration 
like this: 
class X { 
II this class's name is X 
public: 
/I publ ic members: 
/I 
- the interf,lce 10 users (accessible by ali) 
/I functions 
/I typt.'S 
II d<lta (often best kept private) 
private: 
/I private members: 
/I 
- the implementation details (used by members of this class only) 
II functions 
/I types 
/I data 
} ; 
Class members arc private by default ; lhal is, 
class X ( 
}; 
means 
int mf(int); 
II . 

9 .3 
IN TERFA CE AND IM PLEMENTATION 
class X { 
private : 
); 
so thai 
X x; 
int mf(int); 
1/ . .. 
int y = x.mfO; 
II variable )[ of Iype X 
1/ error: mf is private (i.e., inaccessible) 
A user cannot directly refer to a private member. Instead, we have to go through 
a public function that can usc it. For example: 
class X ( 
int m; 
int mf(int); 
public : 
int f(int i) { m=i; return mf(i); } 
); 
x x; 
inl y = x.f(2); 
We usc the distinction between private and public to represent the important dis-
tinction between an interface (the user's view of the class) and implementation 
details (the implementer's view of the class). We explain that and give loIS of ex-
amples as we go along. Here we'll just mention that for something that's just 
data, this distinction doesn't make sense. So, lhere is a useful simplified notation 
for a class that has no private implememation details. A struet is a class where 
members arc public by default: 
struct X { 
int m; 
1/ . .. 
) ; 
means 
class X ( 
public: 
) ; 
int m; 
1/ .. 
303 

304 
CHAPTE R 9 • TECHNICA LITI ES; CLASSES, ETC. 
structs arc primarily used for data structures where the members can take any 
value; that is, we can't define any meaningful invariam (§9.4.3) . 
9.4 Evolving a class 
Let's illustrate the language facilities supporting classes and the basic techniques 
for using them by showing how - and why - we might evolve a simple data 
structure illlo a class with private implementation details and supporting opera-
tions. We usc the apparently trivial problem of how to represent a date (such as 
Augusl14, 1954) in a program. TIle need for dmes in many programs is obvious 
(commcrciai lransaclions, weather dma, calendar programs, work records, invcn-
LOry management, etc.). TIle only qucstion is how we might represent them. 
9.4.1 struct and functions 
How would we represent a date? When asked, most people answer, "\I\'ell, how 
about the year, the month, and the day of the month?" "n mt's nOt the only an· 
swer and not always the best answer, but it's good enough for our uses, so that's 
what we'll do. Our first attempt is a simple struct: 
/I simple Date (100 simple?) 
sltuet Date { 
) ; 
int y; 
int m; 
int d; 
/I year 
/I month in }'ear 
/I day of month 
Date today; 
/I a Date variable (a named object) 
A Date object, such as today, will simply be three ints: 
Date: 
~ I >;»5 
.. 
12 I 
d. 
"nlcre is no "magien relying on hidden data stHlCtures anywhere related to a 
Date - and that will be the case for every version of Date in this chapter. 
So, we now have Dates; what can we do with them? We can do everything in 
the sense that we can access the members of today (and any other Date) and read 
and write them as we like. The snag is that nothing is really convenient. Just 
about anything that we want to do with a Date has to be written in tenns of reads 
and writes of those members. For example: 

9.4 
EVOLVING A CLASS 
/I set today to December 24, 2005 
loday.y = 2005; 
loday.m = 24; 
loday.d = 12; 
111is is tedious and eITOr·pronc. Did you spOt the crror? Everything that's te· 
dious is error·pronc! For examplc, does this make sense? 
Date Xi 
x.y =-3; 
x.rn = 13; 
x.d = 32i 
Probably not, and nobody would write that - or would they? How about 
Dale y; 
y.y = 2000; 
y.m = 2; 
y.d = 29; 
Was year 2000 a leap year? Are you sure? 
What we do then is to provide some helper runctions to do the most com-
mon operations ror us. That way, we don't have to repeat the same code over 
and over again and we won't make, find, and fix the same mistakes over and 
over ag<tin. For just about every type, initializat.ion and assignment are among the 
most common operations. For Date, increasing the value of the Date is another 
common operation, so we write: 
/I helper functions: 
void init_day(Date& dd, int y, int m, inl d) 
{ 
II check that (y,m,d) is a valid date 
II if it is, use il to initialize dd 
void add_day(Oate& dd, inl n) 
{ 
II increase dd by n days 
) 
We can now try to lise Dale: 
305 

( I-lAPTER 9 • TECHNICA LITIES: CLASSES, ETC. 
void fO 
( 
} 
Dale loday, 
iniCday(today, 12, 24, 2005), 
add_day(loday,1), 
II oops! (no day 2005 in year 12) 
Hrst we note the usefulness of such "operations" - here implemented as helper 
functions. Checking that a date is valid is sufficiently difficult and tedious that if 
we didn't write a checking function once and for all, we'd skip the check occa· 
sionally and get buggy programs. VYhenever we derme a type, we want some op· 
erations for it. Exactly how many operations we want and of which kind will 
vary. Exactly how we provide them (as functions, member functions, or opera· 
tors) will also vary. but whenever we decide to provide a type, we ask ourselves, 
""\Vhich operations would we like for this type?" 
9.4.2 Member functions and constructors 
We provided an initialization function for Dales, one that provided an important 
check on the validity of Dates. However, checking functions arc of litlie use if we 
fail to usc them. For example, assume that we have defined the output operator 
«
for a Date (§9.8): 
void iO 
( 
} 
Date today, 
1/ . .. 
coul « today « '\n', 
1/ . .. 
in iC dayUoday,2008 ,3,30); 
/I . .. 
Date tomorrow; 
tomorrow.y = today.y; 
tomorrow. III = loday.lll; 
tomorrow.d = today.d+ 1, 
cout« tomorrow « '\n'; 
/I use today 
/I add 1 to today 
/I use tomorrow 
Here. we "forgot" to immediately initialize today and "someone" used it before 
we gOt around to calling inil_dayO. "Someone else" decided that it was a waste of 
time to call add_dayO - or maybe hadn't heard of il - and constructed tomorrow 
by hand. As it happens, this is bad code - very bad code. Sometimes, probably 
most of the lime, it works, but small changes lead to serious errors. For example, 
writing out an uninitialized Date will produce garbage output, and incrementing 

9.4 
EVOLV tNG A C LASS 
a day by simply adding 1 to its member d is a time bomb: when today is the last 
day of the mamh the increment yields an invalid date. The worst aspect of this 
'·very bad code" is thaI it doesn't look bad. 
111is kind of thinking leads 10 a demand for an initialization function thaI 
can't be forgotten and for operations that arc less likely to be overlooked. Ille 
basic tool for that is lIIemtxr/imdions, that is, functions declared as members of the 
class within the class body. For example: 
/I simple Date 
II guarantee initial ization with constructor 
/I provide some notational convenience 
struc! Dale ( 
); 
int y, m, d; 
Dale(inl y, int m, int d); 
void add_day(int n); 
/I year, month, day 
/I check for valid date and initialize 
/I increase the Date by n dilYs 
A member function with the same name as its class is special. It is called a 
collJlmelor and will be used for initialization ("construction") of objects of the class. 
It is an error - caught by the compiler ~ to forget to initialize a class that has a 
constructor that requires an argument, and there is a special convenient syntax 
for doing such initialization: 
Date my_birthday; 
/I error: my_birthday not initialized 
Date loday(12,24,2007); 
/I oops! run-time crror 
Date lasl(2000, 12, 31); 
/I OK (colloquial style) 
Date chrislmas = Date(1976,12,24); 
/I also OK (verbose style) 
11le attempt to declare my_birlhday fails because we didn't specify the required 
initial value. -n1e attempt to declare today will pass the compiler, but the check-
ing code in the constructor wiII catch the illcbral date at run time (12124/2007 -
there is no day 2007 of the 24th month of year 12). 
'Ille definition of last provides tbe initial value - the arguments required by 
Date's constniClor - in parentheses immediately after the name of the variable. 
111at's Ihe most common style of initialization of variables of a class that has a 
constructor requiring arguments. We can also use the more verbose style where 
wc explicitly create an object (here, Dale(1976,12,24») and thcll usc that 10 initial· 
ize the variable using the = initializer syntax. Unless you actually like typing, 
you'll soon tire of that. 
We can now try to usc our ncwly defmed variables: 
lasl.add_day(l ); 
add_day(2); 
/I crror: what date? 
307 

308 
CHAPTER 9 • TEC HNI CALI TI ES: CLASSES, ETC. 
Notc that the member funClion add_dayO is called for a particular Date using the 
dot member-access notation. We'll show how to define member functions in §9.4.4. 
9.4.3 Keep details private 
We still have a problem: What if someone forgets to usc the member function 
add_dayO? What if someone decides to change the mOlll.h directly? After all, we 
"forgot" to provide a facility for that: 
Date birlhday(l960, 12,31): 
++birlhday.d; 
Dale today(1970,2,J); 
today.m = 14; 
/I De<:ember 31, 1960 
1/ ouch! invalid dale 
/I ouch! invalid dale 
As long as we leave the representation of Date accessible 10 everybody, some-
body will - by accident or design - mess it upi that is, someone will do some-
thing that produces an invalid value. In lhis case, we created a Date with a value 
that doesn't correspond to a day on the calendar. Such invalid objects are time 
bombs; il is JUSl a mauer of time before someone innocenlly lIses the invalid 
value and gets a lun-time elTor or - usually worse - produces a bad result. 
Such concerns lead us to conclude that lhe representation of Date should be 
inaccessible to users except through the public member functions that we supply. 
Here is a first cut: 
/I simple Date (control access) 
class Date ( 
int y. m, di 
/I year, month, day 
public: 
Date(inl y. int m, inl d); 
/I check for valid date and initialize 
void add_day(inl n); 
/I increase the Date by n days 
int month() { return mi } 
int dayO ( relurn di ) 
int year() ( return Yi ) 
) ; 
We can usc it like this: 
Dale birlhday(1970, 12, 30); 
birthday.m = 14i 
caul « birlhday.monlhO «endl; 
II OK 
II error: Date::m is private 
II we provided a way to read m 

9.4 
EVOLVING A CLASS 
~nle notion of a "valid Date" is an important special case of the idea of a valid 
value. We try to design our types so that values are guaranteed to be valid: that 
is, we hide the representation, provide a constructor that creates only valid ob-
jects, and design all member functions to expect valid values and leave only valid 
values behind when they retum. 111e value of an object is often called its slale, so 
the idea of a valid value is often referred to as a valid slale of an object. 
111e alternative is for us to check for validity every time we usc an object, or 
juSt hope that nobody left an invalid value lying around. Experience shows that 
"hoping" can lead to "pretty good" programs. However, producing "pretty good" 
programs that occasionaHy produce erroneous results and occasionally crash is 
no way to win friends and respect as a professional. We prefer to write code that 
can ue demonstrated to be correct. 
A mle for what constitutes a valid value is called an illlKU1anl. ~n' e invariant 
for Dale ("'A Date must represent a day in the past, present, or future") is unusu-
ally hard to state precisely: remember leap years, the Georgian calendar, time 
zones, etc. However, for simple realistic uses of Oates we can do it. For example, 
if we arc analyzing intemet logs, we need nOI be bmbered with the Georgian,Ju-
lian, or Mayan calendars. If we can't think of a good invariant, we are probably 
dealing with plain data. If so, lise a struct. 
9.4.4 Defining member functions 
So far, we have looked at Dale from the point of view of all interface designer 
and a user. But sooner or later, we have to implement those member functions. 
First, here is a subset of the Date class reorganized to suit the common style of 
providing the public interface lirst: 
/I simple Date (some people prefer implementation details last) 
class Date { 
public: 
Date(inl y, int m, int d); II constructor: check for valid date and initialize 
void add_day(int n); 
II increase Ihe Dale by n days 
int month(); 
II . .. 
private: 
int y, m, d; 
II year, month, day 
); 
People put the public interface lirst because the interface is what most people arc 
interested in. In principle, a user need not look at the implementation details. In 
reality, we are typic. ... lIy curious and have a quick look to sec if the implementation 
309 

310 
( HAPTER 9 • TECHNICALIT IES: CLASSES , ETC. 
looks reasonable and if the implementer used sollle technique that we could learn 
from. However, unless we arc the impicmcntcrs, we do lend to spend much more 
time with lhe public interface. The compiler doesn't care about the order of class 
members; it takes the declarations in any order you care to prcscl1llhcm. 
'-\Then we defIne a member outside its class, we need to say which class it is a 
member of. We do that using the das.s_'ltlllle:: memlxr_,ulIne nOl'ation: 
Date : :Oate(int yy, int mm, inl dd) I/constructor 
:y(yy), m(mm), d(dd) 
1/ note: member initializers 
( 
} 
void Date: :add_day(int nl 
( 
/I . . . 
} 
int monlhO /I oops: we forgot Date:: 
( 
return m j 
/I not the member function, can', access III 
} 
The :y(yy), m(mm), d(dd) nOlation is how we initialize members. We could have 
written 
Date: : Date(int yy, int mm, int dd) 
( 
} 
y = yy; 
m = mm; 
d = dd; 
/I constructor 
but then we would in principle first have default initialized the members and then 
assigned values to them. We would then also open the possibility of accidentally 
using a member before it was initialized. TIle :y(yy), m(mm), d (dd) notation 
more directly expresses our intent. TIle distinction is exactly the same as the one 
between 
int x; 
/I . . 
x = 2; 
/I first define the variable x 
II later assign to x 

9.4 
EVOLVING A CLASS 
and 
int x=2; 
II define and immediately inilialize with 2 
For consistency, it is even possible to express that last initialization using the 
"arb"LIt11ent"!parcnthesis notation: 
int x(2); 
/I initialize x with 2 
Date sunday(2004,8,29); 
/I initialize sunday with (2004,8,29) 
vVe can also derine member functions right in the class defmirion: 
II simple Date (some people prefer implementation details last) 
class Dale ( 
public: 
Dale(int yy, int mm, int dd) 
:y(yy), m(mm), d(dd) 
{ 
/I . . 
} 
void add_day(int nl 
{ 
/I ... 
} 
int monthO { return m; } 
II .. . 
private: 
int y, m, d; 
II year, month, day 
} ; 
, 11e first thing we notice is that the class declaration became larger and "messier." 
In this example, the code for the constructor and add_dayO could be a dozen or 
more lines each. This makes the class declaration several times larger and makes 
it harder to rind the interface among the implementation details. Consequenti)" 
we don't dcrine large functions within a class declaration. 
However, look at the derinition of monthO. 11mt's slraightfor,vard and 
shorter tlmn the version that places Date: :monthO out of the class declaration. 
For sllch short, simple functions, we might consider \-\!Titing the definition right in 
the class declaration. 
311 

312 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
Note that monthO can refer to m even though m is defined after (below) 
month(). A member can refer to another member of its class independently of 
where in the class that Olhcr member is declared. The mle that a name must be 
declared before it is lIsed is relaxed within the limited scope of a class. 
Writing the definition of a member funcuon within the class definition has 
twO effects: 
The function will be il/lil/ed; that is, the compiler will try to generate code 
for a call to the iulinc function without using a function caillo gel to that 
code. 111is can be a significant pcrfonnancc advantage for functions, 
slIch as monthO, lhal hardly do anything bUl are used a lot. 
All uses of the class will have to be recompiled whenever we make a 
change to the body of an inlined function. If the function body is out of 
the class declaration, recompilation of users is needed only when the 
class declaration is itsclf changed. Not recompiling when the body is 
changed can be a huge advantage in large programs. 
"nlc obvious rule of thumb is: Don't put member function bodies in t.he class 
declaration unless you know that you need the pcrfonnance boost from inlining 
tiny functions. Large functions, say five lines of code, don't benefit from inlining. 
We rarcly inline a function that consists of more than one or twO expressions. 
9.4.5 Referring to the current object 
Consider a simple usc of t.he Date class so far: 
class Date ( 
II . .. 
int monthO ( return m; } 
II. 
private: 
int y, m, d; 
II year, month, day 
) ; 
void f(Date d1 , Date d2) 
( 
cout« d1 .monlhO« ' , «
d2.monthO« '\n'; 
) 
How docs Date: :monthO know to print Out d1 .m in the first call and d2.m in the 
second? Look again at Date:: monthO; its declaration specifics no function argu-
ment! How docs Date:: monthO know for which object it was called? A class 
member function, such as Dale: :month(), has an implicit argument. which it uses 

9.4 
EVOLVING A CLA SS 
to identify the object for wruch it is called. So in the first cail, m correctly refers to 
dl .m and in the second call it refers to d2.m. See §17.10 for more uses of this im· 
plicit argument. 
9.4.6 Reporting errors 
''''hat do we do when we find an invalid date? \"'here in the code do we look for 
invalid dates? From §5.6, we know that the answer to the first question is 
"llu·ow an exception," and the obvious place to look is where we first construct a 
Dale. If we don't create invalid Dales and also write our member functions cor· 
rectly, we will never have a Date with an invalid value. So, we'll prevent users 
from ever creating a Date with an invalid state: 
/I simple Date (prevcnt inva lid dates) 
class Date { 
public: 
class Invalid { }; 
/I to be used as exception 
Date(int y, int m, int d); 
II . .. 
II check for valid date and initialize 
private: 
int y, m, d ; 
bool checkO; 
/I year, month, day 
II return truc if date is valid 
} ; 
We put the testing of validity into a separate checkO funClion because checki.ng 
for validity is logically distinct from initialization and because we might want to 
have several constructors. As you can sec, we can have private functions as well 
as private data: 
Date : :Dale(int yy, int mm, int dd) 
: y(yy), m(mm), d(dd) 
{ 
if (!check()) throw InvalidO; 
} 
/I initialize data members 
II check for validity 
bool Dale ::checkO 
II return true if date is valid 
{ 
if (m<l II 12<m) return false; 
II . .. 
Given that defmition of Date, we can write: 
313 

314 
C HAPTER 9 • TECHNICALITIES: ClASSES, ETC. 
void fCint x, int y) 
try ( 
) 
Date dxy(2004,x,y); 
coul «
dxy« '\n'; 
d xy.add_day(2); 
calch(Date:: Invalid) ( 
error("invalid date n); 
) 
1/ see §9.8 (or J declaration of « 
II errorO defined in §5.6.3 
We now know that «
and add_dateO will have a valid Date on which to operate. 
Before completing the evolution of our Dale class in §9.7, we'll take a detour 
to describe a couple of gcncrallanguagc facilities that we'll need lO do that well: 
enumerations and operator overloading. 
9.5 Enumerations 
An enum (an ClI/llIeTalion) is a very simple user-defined type, specifying its set of 
values (its clllmeralfm) as symbolic constants. FOT example: 
co urn Month ( 
jao=l , feb, mar, apr, may, jun, jul, aug. sep, oct, nov, dec 
); 
"IllC "body" of an enumeration is simply a list or its enumerators. You can give a 
specific value ror an enumerator, as we did ror jan here, or leave it to the com-
piler to pick a suitable value. Ir you leave it to the compiler to pick, it'U give each 
enumerator the value or the previous enumerator plus one. '1ms, our definition 
or Monlh gave the months consecutive values starling with 1. We could equiva-
lently have wriuen 
cnum Month { 
); 
jan=l , feb=2, mar=3, apr=4, may=5, jun=6, 
jul=7, aug=8, sep=9, ocl=10, nov=11, dec=12 
However, that's tedious and opens the opporlunity ror errors. In ract, we made 
twO typing errors before getting this latest version right; it is better to let tile com· 
piler do simple, rcpetitive "mechanical" things. ·n le compiler is bettcr at such 
tasks than we arc, and it doesn't get bored. 
Ir we don't initialize the first cnumerator, tllC count starts with O. For example: 

9 .5 
ENUMERATIONS 
enum Day { 
monday, tuesday, wednesday, thursday, friday, saturday, sunday 
); 
Here monday==O and sunday==6. In practice, staning with 0 is often a good 
choice. 
Vile c..,n lise our Month like lills: 
Month m = feb; 
m =7; 
int n = m j 
Month mm = Month(7)j 
/I error: can't assign an int to a Month 
/I OK: we can get (he numeric value of a Month 
/I convert int to Mon(h (unchecked) 
Note that a Month is a separate type. It has an implicit conversion to int, but 
there is no implicit conversion from int to Month. This makes sense because 
every Month has an equivalent integer value, but most ints do not have a Month 
equivalent. For example, we really do want this initialization to fail: 
Month bad = 9999; 
/I error: can't convert an int to a Month 
If you insist on lIsing the Month(9999) notation, on your head be it! In many 
cases, C++ will not try to stop a pmgrammer from doing something potentially 
silly when the programmer explicitly insists; after all, the programmer might ac· 
tually know better. 
Unfonunately, we cannot definc a conStructor for an enumeration to check 
in.itializer values, but it is trivial to write a simple checking function: 
Month inuo_month(int x) 
{ 
if (x<jan II dec<x) error{ tlbad month"); 
return Month(x); 
Given lilat, we can write 
void f(int m) 
( 
) 
Month mm = inCto_month(m); 
II ... 
\<Vhat do we lise enumerations for? Basically, an cnumeration is useful whencver 
we need a set of related named integer constants. That happens all tile timc when 
315 

31. 
CHAPTER 9 • TECHNICA LITI ES: ClASS ES, ETC. 
we try to represent sets of alternatives (up, down; yes, no, maybe; on, off; n, ne, 
e, se, 5, SW, w, nw) or distinctive values (red, blue, green, yellow, maroon, crim-
son, black). 
Note that an enumerator is /lot in the scope of its enumeration type; it is in 
the sallle scope as the name of its enumeration type. For example: 
c num Traffic_sign { red, yellow, green}; 
int var = red; 
/I nOte: nOt Trafflc_sign::red 
TIlis can cause problems. Imagine the potcmial for confusion if you have short 
popular names, such as red, on, ne, and dec, as global names. For example, does 
ne mean "nonheast" or "not equal"? Docs dec mean "decimal" or "Oecember"? 
1ltis is the kind of problem we warned against in §3.7, and we can easily get such 
problems if we define an cnum with short, conveniem enumerator names in the 
global scope. In fact, we immediately get this problem when we try to usc our 
Month enumeration together with iostreams because there is a "manipulator" 
called dec for "decimal" (sec §11.2. 1). To avoid such problems, we often prefer to 
define enumerations in more limiLCd scopes, such as within a class. ~nl at also al-
lows us to be explicit about what an enumerator value refers to, such as 
Month : :jan and Color: :red. We present the technique for doing that in §9.7. 1. If 
we absolutely need global names, we try to minimize the chance of name clashes 
by using longer nmIles, by using unusual names (or unusual spellings), and by 
capitalization. However, our prefen'ed solution is to make names as local as is 
reasonable. 
9.6 Operator overloading 
You can define almost all C++ operators for class or enumeration operands. 
That's often called opera/Qr QUa'/oadillg. We usc it when we want to provide con-
vemional notation for a type we design. For example: 
en urn Month { 
Jan=1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, OCI, Nov, Dec 
); 
Month operator++(Month& m) 
{ 
) 
m = (m==Dec) 1 Jan : Monlh(m+1 ); 
return m; 
II prefix increment operator 
1/ "wrap around" 

9 .6 
OPERATOR OVERLOADING 
~nle ? : constmct is an "arithmetic if": m becomes Jan if (m==Oec) and 
Month(m+l) otherwise. It is a reasonably elegant way of expressing lhe fact that 
months "wrap around" after December. TIle Month type can now be used like 
this: 
Month m = sepi 
++m; 
/I m becomes Dcl 
++m; 
++m; 
++m; 
/I m becomes Nov 
/I m becomes Dec 
/I m becomes Jan (~wrap around") 
You might not think Lhat incrementing a Month is common enough to warrant a 
special operator. '11at may be so, but how about an outpUl operator? We can de-
fine one like this: 
vector<string> month_lbl; 
oSlream& operator« (ostream& os, Month m) 
{ 
return os « month_tbl[m]i 
) 
~nlis assumes that month_fbi has been initialized somewhere so that (for exam-
ple) month_tbl[MarJ is "March" or some other suitable name for that month; see 
§1O.11.3. 
You can define just about any operator provided by C++ for your own 
types, but only existing operators, such as +, - , ., /, %, [I, 0, 'II, !, &, <, <=, >, and 
>=. You cannot defme your own operators; you might like to have " or $= as op-
erators in your program, but C++ won't let you. You caJl define operators only 
wil.h their conventional number of operands; for example, you can defme unary 
- , bUI not unary <= (less Lhan or equal), and binary +, but nOI binary ! (not). Ba-
sically, the language allows yOll to use the existing syntax for the types yOll de-
fine, but not to extend that syntax. 
An overloaded operator must have at least one user-defined type as operand: 
int operator+(int,int); 
/I error: you can't overload built-in + 
Vector operator+(const Vector&, const Vector &); 
/I OK 
Vector operator+=(const Vector&, inl); 
/I OK 
It is generally a good idea not to define operators for a type unless you are really 
certain limt it makes a big posil.ive change to your code. Also, define operaLOrs 
317 

318 
CHAPTER 9 • TECHNICALITIES: ClASS ES, ETC. 
only with their conventional meaning: + should be addition, binary · multiplica-
tion, [J access, () call, etc. This is just advice, not a language rule, but it is good 
advice: conventional lise of operators, slich as + for addition. can significantly 
help us understand a program. After all, such lISC is the result of hundreds of 
years of experience with mathematical notation. Conversely, obscure operators 
and unconventional use of operators can be a significant distraction and a SOUTce 
of errors. We will not elaborate on this point. Instead, in the following chapters. 
we will simply lise operator overloading in a few places where we consider it 
appropriate. 
Note that lhe most interesting operators to overload aren't +, - , ., and I as 
people often assume, but =, ==, !=, <, n, and O. 
9.7 Class interfaces 
We have argued that the public interface and the implementation parts of a class 
should be separated. As long as we leave open the possibility of using structs for 
lypeS that are "plain old data," few professionals would disagree. However, how 
do we design a good interface? \rVhat distinguishes a good public intcrface from a 
mess? Part of that answer can be given only by example, but there arc a few gen-
eral principles that we can list and which are given some support in C++: 
Keep interfaccs complete. 
Keep interfaces minimal. 
Provide constructors. 
Support copying (or prohibit it) (see §14.2.4). 
Use types to provide good argument checking. 
Identify nonmodifying member functions (see §9.7.4). 
Free all resources in the destructor (see §17.5). 
See also §5.5 (how to detect and report nm·time errors). 
111e first two principles can be summarized as "Keep the interface as small as 
possible, but no smaller." We want our interface to be small because a small inter-
face is easy to learn and easy to remember, and the implementer doesn't waste a 
lot of time implementing unnecessary and rarely used facilities. A small interface 
also means that when something is wrong, there are only a few functions to 
check to find the problem. On average, the more public member functions, the 
harder it is to find bugs - and please don't get us started on the complexities of 
debugging classes with public data. But of course, we want a complete interface; 
otherwise, it would be useless. We couldn't use an interface that didn't allow liS 
to do all we really needed. 
Let's look at the other - less abstract and more directly supported - ideals. 

9.7 
CLASS INTERFAC ES 
9.7.1 Argument types 
''''hcn we defincd the conStlUCLOr for Date in §9.4.3, wc uscd threc ints as thc ar· 
b'umcnlS. 1nat caused somc problcms : 
Date dl(4,5,2005); 
Dale d2(2005,4,5); 
/I oops: year 4, day 2005 
/I April 5 or May 4? 
111C first problem (an illegal day of !.he month) is easily dealt with by a test in the 
constnlctor. However, the second (a month vs. day-of-the-mon!.h confusion) can't 
be caught by code written by the user. lllc second problem is simply that the 
convemions for writing month and day-in-month differ; for example, 4/5 is 
April 5 in the United StalCs and May 4 in England. Sincc wc can't calculate our 
way out of this, wc must do somcthing clse. TIle obvious solution is to use thc 
t)1)C system: 
II simple Dale (use Monlh type) 
class Date ( 
public: 
enum Month { 
jan=1, feb, mar, apr, may, jun, jul, aug, sep, oel, nov, dec 
}; 
Dale(int y, Month m, int d); 
/I check for valid date and initialize 
1/ . . 
private: 
int y; 
/I year 
} ; 
Month m; 
inl d; 
/I day 
Whcn we use a Month type, the compiler will catch us if we swap month and 
day, and using an enumcration as the Month type also gives us symbolic names 
to use. It is lIsually easier LO read a.nd write symbolic names than to play around 
with numbcrs, a.nd therefore less error-prone: 
Dale dxl (l998, 4, 3); 
/I error: 2nd argument not a Month 
Dale dx2(1998, 4, Date:: mar); 
/I error: 2nd argument not a Month 
Date dx2(4, Date:: mar, 1998); 
/loops: run-time error: day 1998 
Date dx2(Dale: : mar, 4, 1998); 
/I error: 2nd argument not a Month 
Date dx3(1998, Date: : mar, 30); 
/I OK 
319 

320 
CH APTE R 9 • TE C H NICALITIES: ( LASSES. ETC. 
This takes care of most "accidents." Note the usc of the qualification of the cnLl-
mcralor mar with the class name Date: Date:: mar. This is the way we say thaI 
it's Date's mar. \<\'c don't say Date.mar because Dale isn't an object (it's a type) 
and mar isn't a data member (it's an enumcraLOr - a symbolic constant). Usc :: 
after a class name (or a namespace name; §S.7) and. (dOL) arLC .. an object name. 
When we have a choice, we calch errors at compile time ralher than at Iun 
time. \OVc prefer for lhe compiler to find the error rather than for us to uy to fig-
ure Qut exactly where in the code a problem occurred. Also, errors caught a l 
compile time don't require checking code to be written and executed. 
Thinking like that, could we calch the swap or the day or the momh and the 
year also? We could, but the solution is not as simple or as elegant as ror Month ; 
arter all, mere was a year 4 and you might wam to represent it. Even ir we re-
stricted ourselves to modern times there would probably be too many relevant 
years ror us LO list them all in an enumeration_ 
Probably the best we could do (witham kllowing quite a lot about the in-
tended usc or Dale) would be something like this: 
class Year { 
/I year in lmin:max) range 
static const int min = 1800; 
static const int max = 2200; 
public: 
class Invalid { }; 
Year(int x) : y(x) { if (x<min II maxo) throw In ... alidO; ) 
int yearO { return Yi } 
private: 
int Yi 
} ; 
class Date { 
public: 
enum Month { 
jan=1, feb. mar. apr, may. jun, jul. aug. sep, oct. no .... dec 
}; 
Date(Year y. Month m. int d )i 
II ... 
private : 
}; 
Year Yi 
Month m; 
int d; 
II day 
II check for v"lid date ;md initialize 

9 . 7 
ClASS INTERFACES 
Now we get 
Date dx1(Year(1998), 4, 3); 
Date dx2(Year(1998), 4, Date: :mar); 
Dale dx2(4, Date: : mar, Year(l998)); 
Dale dx2(Dale: :mar, 4, Year(1998)); 
Dale dx3(Year(1998), Dale: :mar, 30); 
II error: 2nd argument not a Month 
/I error: 2nd argument not a Month 
/I error: 1 st argument nOI a Year 
II error: 2nd argument not a Month 
II OK 
-n lis wcird and unlikely crror would still not bc caught until run time: 
Dale dx2(Year(4), Date: : mar, 1998); 
/I run-time error: Year::lnvalid 
Is the extra work and notation to get years checked worthwhile? Naturally, that 
depends on the constraints on the kind of problem you are solving using Dale, 
but in this case we doubt it and won't use class Year as we go along. 
vVhen we program, we always have to ask oursclves what is good enough 
for a given application. Wc usually don't havc the luxury of being ablc to scarch 
"forever" for the pcrfect solution aftcr we have already found onc that is good 
enough. Search further, and we might even come up with something that's so 
elaboratc that it is worse than thc simple early solution. This is onc meaning of 
the saying ""nle best is the enemy of the good" (Voltaire). 
Notc the lise of static canst in the definitions of min and max. 111is is the 
way we define symbolic constants of integer types within classes. For a class 
member, we use slatic to make sure that there is just one copy of the value in the 
program, rather than one per object of the class. 
9.7.2 Copying 
vVe always have to create objects; that is, wc must aJways consider initialization 
and constructors. Arguably they arc thc most important members of a class: to 
write them, you have to decide what it takes to initialize an object and what it 
means for a value 10 be valid (what is the invariant?).JuSI thinking about initial-
ization will help you avoid errors. 
-n lC next thing 10 consider is of len: Can we copy our objects? And if so, how 
do we copy them? 
For Date or Month. the answer is that we obviously want to copy objccts of 
thatlypc and that the mcaning of mfrY is trivial: just copy all of the members. Ac· 
tually, this is the default casc. So as long as you don't say anything else, the com-
piler will do exactly that. For example, if YOll copy a Month as an initializer or 
right·hand side of an assignment, all its members arc copied: 
Date holiday(1978, Date : :jul, 4); 
Date d2 = holiday; 
Date d3 = Date(1978, Date: :jul, 4); 
/I initialization 
321 

322 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
holiday = Oate(1978, Date: :dec, 24); 
d3 = holiday; 
II assignment 
This will all work as expected. TIle Oale(1978, Datc : :dec, 24) notation makes the 
appropriate unnamed Date object, which you can then use appropriately. For 
example: 
cout« Dale(1978, Date: :dec, 24); 
111is is a usc of a constructor that acts much as a literal for a class type. It often 
comes in as a handy alternative to first defining a variable or const and then 
usmg It once. 
What if we don't wam the default meaning of copying? We can either define 
our own (sec §18.2) or make the copy constructor and copy assignment private 
('co §14.2.4). 
9.7.3 Default constructors 
Ullinitializcd variables can be a seriOliS source of errors. 1'0 counter that problem, 
we have the notion of a constructor to guarantee that every object of a class is ini-
tialized. For example, we declared the COllstnlctor Date: :Date(int,Monlh,int) to 
ensure that every Dale is properly initialized. In the case of Dale, that means that 
the programmer must supply three arguments of the right types. For example: 
Date d1 ; 
Date d2(1998); 
Date d3(l ,2,3,4); 
Date d4(1,"jan",2); 
Date d5(I,Date: :jan,2); 
Date d6 = d5; 
II error: no inilializer 
/I error: too few arguments 
/I error: too many arguments 
/I error: wrong argument type 
/I OK: usc the three-argument constructor 
/I OK: usc the copy constructor 
Note that even though we defined a constructor for Dale, we can still copy Oates. 
Many classes have a good notion of a default value; that is, there is an obvi· 
ous answer to the question "What value should it have if 1 didn't give it an ini· 
tializer?" For example: 
siring sl; 
veclof<string> v1; 
veclor<slring> v2(10); 
/I default value: the empty string •• 
/I default value: the empty vector; no elements 
/I vector of 10 default strings 
This looks reasonable. It evcn works the way thc comments indicate. ~l1lat is 
achieved by giving vector and string default amsh-uclorJ that implicitly provide the 
desired initialization. 

9 . 7 
CL A SS INTERFACES 
For a type T, TO is the notation for the defaull value, as defmed by the default 
constmcLOr, so we could write 
string sl = string(); 
veclor<string> v1 = veclor<string>O; 
/I default value: Ihe empty string ·" 
II default value: 
veclor<siring> v2(10,string()); 
II the empty vector; no elements 
II vector of 10 default strings 
However, we prefer the equivalent and colloquial 
string sl ; 
vector<string> v1 ; 
vector<string> v2(10); 
/I default value: the empty string ,. 
II default value: the empty vector; no elements 
/I vector of 10 default strings 
l:Or buill-in types, such as int and double, the defaull constructor notation means 
0, so intO is a complicated way of saying 0, and doubleO a long-winded way of 
saying 0_0. 
Beware of a nasty syntax problem with the () notation for initializers: 
siring s1("lke"); 
string s2(); 
II string initialized to " Ike ~ 
II function laking no argumenl returning a string 
Using a default constructor is not just a matter of looks. Imagine that we could 
have an uninilializcd string or vector. 
string s; 
far (int i=O, ks.sizeO, ++i) /I oops: loop an undefined number of limes 
taupper(s[i]); II oops: modify the contents of a random memory location 
veclar<string> v; 
v.push_back("bad"); 
II oops: write to random address 
If the values of s and v were genuinely undefined, s and v would have no notion 
of how many elements they contained or (using the common implementation 
techniques; sec §17.5) where those elements were supposed to be stored. -nle re-
sults would be usc of random addresses - and that can lead to the worst kind of 
errors. Basically. without a constructor, we c..1.nnot establish an invariant - we 
c..1.nnOI ensure that the values in those variables arc valid (§9.4.3). We must insist 
that stich variables are initialized. We could insist on an initializer and then write: 
string sl = ""; 
veclar<slring> v1(O); 
veclar<slring> v2(10, ""); 
/I vector of 1 0 empty strings 
323 

32. 
CHAPTER 9 • TECHNI CA LI TI ES; CLASSES, ETC 
But we don't think that's particularly pretty. For siring, '''' is rather obvious for 
"empty string." For vector, 0 isn't tOO obscure for "empty vectOr." However, for 
many Iypes, it is not easy to find a reasonable notation for a default value. For 
many types, it is beneT to define a conslm clOr that gives meaning to the creation 
of an object without an explicit initializer. Such a constructor takes no arguments 
and is called a (UjilUll C01lslnlClar. 
TIlere isn't an obvious default value for dates. That's why we didn't define a 
default constructor for Dale so far, but let's provide one Gust to show we can): 
class Date ( 
public: 
II . 
DateO; 
II . 
private: 
) ; 
int Yi 
Month m; 
int d ; 
/I default construdor 
We have to pick a default date. The first day of the 21st century might be a rca-
sonable choice: 
Date:: DateO 
:y(2001), m(Date::jan), d(l) 
If \\Ie didn't like (0 build the default value right into the constructor code, \\Ie 
could lise a constant (or a variable). To avoid a global variable and its associated 
initialization problems, we use the technique rrom §8.6.2: 
Dale& defaulCdateO 
( 
} 
static Date dd(200l,Date: :jan, 1); 
return dd; 
We used static (0 get a variable (dd) that is created only once, rather than each 
time default_dateO is called, and initialized the first time default_dateO is called. 
Given default_dateO, it is trivialLO define a default constructor ror Date: 

9 .7 
CLASS INTER FACES 
Dale:: DaleO 
: y(default_dateO. yearO), 
m(defauILdateO.monlhO), 
d(d efaull_daleO. day(» 
Note that the default constructor does not need to check its value; the construc-
tor for default_date already did that. Given this default Dale constructor, we can 
now have vectors of Oates: 
vector<Dale> birlhdays(10); 
Without the default constnlctor, we would have had to be explicit: 
veclo r<Date> bi rthdays(l O,defau IL dateO); 
9.7.4 const member functions 
Some variables are meant to be changed - that's why we call them "variables" -
blll some arc not; that is, we have "variables" representing itnmutable values. 
~l1lOse. we typically call 1Ql/.JttmtJ or just consts. Consider: 
void some_function(Date& d, const Date& starLoCterm) 
{ 
) 
int a = d.dayO; 
int b = starLoUcrm.day(); 
d.add_day(J); 
starLor_term.add_day(J); 
/10K 
/I should be OK (why?) 
/I fine 
/I error 
Here we intend d to be mmable, but starLoClerm to be immutable; it is nOl ac-
ceptable for some3unction() to change starLoCterm. How would the compiler 
know that? It knows because we told it by declaring starLoCterm consl. So far, 
so good, but then why is it OK to read the day of starLoUerm using day()? As 
the definition of Dale stands so far, slarLoCterm.dayO is an error because the 
compiler docs not know that dayO doesn't change its Date. We never told it, so 
the compiler assumes that dayO may modify its Dale and reports an error. 
\Ale can deal with this problem by classifying operations on a class as modify-
ing and nonmodirying. TIlal'S a pretty fundamental distinction that helps us un-
derstand a class, but it also has a very practical importance: operations that do 
not modify the object can be invoked for const objects. For example: 
325 

326 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
class Dale ( 
public: 
1/ . .. 
jnt dayO const; 
Month month() const; 
jnt year() const; 
void add_day(int n); 
void add_month(int n); 
void add_year(int n )i 
private: 
jnt Yi 
/I year 
II const member: can', modify the object 
II const member: can', modify the object 
II const member: can', modify the object 
/I non-const member: can modify the object 
/I non-const member: can modify the object 
/I nan-const member: can modify the object 
M o nth m j 
jnt d; 
/I day of month 
); 
Dale d(2000. Date: :jan, 20); 
const Date cd(2001, Date: :feb, 21); 
coul « d.dayO« 
11 
_ "« cd.day()« e ndl; /10K 
d.add_day(l ); 
/I OK 
cd.add_day(l ); 
II error: cd is a const 
We usc const right after the argument list in a member rUllclion declaration to in-
dicate that the member function can be called for a const object. Once we have 
declared a member function const, the compiler holds us to our promise not to 
modify the object. For example: 
int Oate:: dayO const 
( 
++d; 
II error: attempt to change obiect from canst member function 
return d; 
) 
Naturally, we don't usually try to "cheat" in this way. What the compiler pro-
vides for the class implementer is primarily protection against accident, which is 
panicularly useful for more complex code. 
9.7_5 Members and Ilhelper functions" 
'Whcn we design our interfaces to be minimal (though complete), we have to 
Icave out 100s of operations that arc merely useful. A function that can be simply. 
elcgamly, and efficiently implemented as a freestanding function (lhat is. as a 

9 ,7 
CLASS INTERFAC ES 
nonmcmber function) should be implemcnted outside the class. That way, a bug 
in that function cannot directly corrupt tllC data in a class object. Not accessing 
the rcprcsemation is important because the usuaJ debug technique is "round up 
thc usual SUSPCCIS
n
; that is, when sometlljng goes wrong with a class, we first 
look at the functions that directly acccss thc rcpresentation: one of those almost 
certainly did it. If there are a dozcn sllch functions we will be much happier than 
if there were 50. 
Fifty functions for a Date class! You must wonder if we arc kidding. We are 
110t: a few years ago I surveyed a number of cOllul1ercially used Date libraries 
and found them full of functions like nexCSundayO, nexLworkdayO, etc. Fifty is 
nOt an unreasonable number for a class designed for the convenience of the users 
ralher than for case of comprehension, implementation, and maintenance. 
Note also that if the representation changes, only the functions that directly 
access the rcprcscntation need to be rewritten. 111at's another strong practical 
rcason for keeping imcrfaccs minimal. In our Date example, we might decide 
that an integer representing the number of days since J anuary 1, 1900, is a much 
better representalion for our uses than (year,monlh,day). Only the member func-
tions would have to be changed. 
Hcre are some examples of helper jillutj(ms: 
Date nexCSunday(consf Date& d) 
{ 
) 
II access d using d.day(), d.monthO, and d.yearO 
II make new Date to return 
Dale nexLweekday(consl Dale& d) (I- . . . -I ) 
boolleapyear(int y) (r . , -I ) 
boot operator==(const Dale& a, canst Dale& b) 
{ 
return a. yearO==b. yearO 
&& a.monlh()==b.month() 
&& a_dayO==b_dayO; 
boot operalor!=(consf Date& a, const Date& b) 
{ 
return !(a==b); 
) 
327 

32. 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
Helper functions arc aJsa called amveniena jimetians, auxiliary fiwetiolls, and many 
other things. TIle distinction between these functions and other nonmember 
functions is logical; that is, "helper function" is a design concept, not a program-
ming language concept 'The helper functions often take arguments of the classes 
that they are helpers of. TIlere are exceptions, though: note leapyear(). Often, we 
use namcspaccs to identify a group of helper functions; see §8.7: 
namespace Chrono { 
) 
class Date (10 ... 01}; 
bool is_date(int y, Dale : :Month m, int d)i 
II true for valid date 
Date nexCSunday(const Date& d) ( r .. . o/ } 
Date nexl_weekday(const Date& d ) { / • . .. O,} 
boolleapyear(int y) { ' " ... "/ } 
/I see exercise 10 
bool operalor==(const Date& a, consl Dale& b) U· ... */} 
II . . 
Note the == and != functions. TIley are typical helpers. For many classes, == and 
!= make obvious sense, but since they don't make sense for all classes, the com-
piler can't write them for you the way it writes the copy constructor and copy 
asslg11mem. 
Note also that we introduced a helper function is_dateO. l1mt function re-
places Date:: checkO because checking whether a date is valid is largely inde-
pendent of the representation of a Date. For example, we don't need to know 
how Date objects are represented to know that "January 30, 2008" is a valid date 
and ~Fe bruary 30, 2008" is not. "111ere still may be aspects of a date that might 
depend on t.he representation (e.g., can we represent '1anuary 30, l066"?), but (if 
necessary) Date's constructor can lake care of that. 
9.8 The Date class 
So, let's just put it all together and see what that Date class might look like when 
we combine all of the ideas/concerns. Where a function's body is just a ... com· 
mem, the actual implementation is tricky (please don't try to write those just yet). 
Fim we place the declarations in a header Chrono.h: 
/I file Chrono.h 
namespace Chrono ( 
class Date ( 

9.8 
THE DATE CLASS 
public: 
enum Month ( 
jan=l, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec 
); 
class Invalid {}; 
/I to throw as exception 
Date(int y, Month m, int d); 
II check for valid date and initialize 
DateO; 
II default constructor 
/I the deiault copy operations are fine 
I/nonmodifying operations: 
int dayO canst { return d; ) 
Month monthO canst { return m i } 
int yearO canst { return Yi } 
/I modifying operations: 
void add_day(int n); 
void add_month(int n); 
void add_year(int n)i 
private: 
); 
int y; 
Month m; 
inl d; 
bool is_date(inl y, Date: :Month m, int d); 
boolleapyear(int y); 
/I true if y is a leap year 
/I true for valid date 
bool operator==(const Dale& a, canst Dale& b); 
bool operator!=(consl Dale& a, consl Dale& b); 
ostream& operator«(ostream& as, canst Date& d)i 
islream& operator»(istream& is, Oate& dd); 
) /I Chrono 
"lllC dcfinitions go into Chrono.cpp: 
329 

330 
CHAPTER 9 • TECHNICALITIES: CLA SSES, ETC. 
/I Chrono.cpp 
namespace Chrono { 
1/ member function definitions: 
Oate:: Date(inl yy, Month mm, int dd) 
: y(yy), m (mm), d(dd) 
{ 
if (! is_date(yy,mm,dd» throw Invalid()i 
} 
Date& default_dateO 
( 
} 
static Date dd(2001 ,Date: :jan,1); 
II start of 21 51 century 
return dd; 
Date:: DaleO 
{ 
} 
: y( defau 11_ dateO. year()), 
m(default_date().month(), 
d (defaull_ dateO .dayOl 
void Date :: add_day(in! n) 
( 
1/. 
void Date : :add_month(int n) 
{ 
1/ . .. 
} 
void Date : :add_year(inl nl 
{ 
if (m==feb && d==29 && lIeapyear(y+n» { 
/I bcWM€ of leap years! 
m = mar; 
1/ usc March 1 instead of February 29 
d = 1; 
} 
y+=nj 

9.8 
THE DATE CLASS 
/I helper functions: 
bool is_dalc(inl y, Dale::Month m, int d) 
( 
II assume that y is valid 
if (d<=O) return false; 
II d must be positive 
int days_in_month = 31; 
II most months have 31 days 
switch (m) { 
case Date: :feb: 
li the length of February varies 
daysjn_month = (leapyear(y»129:28; 
break; 
case Date : :apr: case Date: :jun: case Dale: :sep: case Date:: nov: 
days_in_monlh = 30; 
lithe rest have 30 days 
break; 
) 
if (daysjn_month<d) return false; 
return true; 
} 
bool leapyear(inl y) 
( 
II see exercise 10 
) 
bool operator==(const Dale& a, const Date& b) 
( 
) 
return a.yearO==b.yearO 
&& a.monthO==b.monthO 
&& a.day()==b.dayO; 
bool operator!=(const Date& a, const Datc& b) 
( 
return I(a==b); 
} 
ostream& operator«(ostream& os, consl Date& d) 
( 
331 

JJ2 
CHAPTER 9 • TECHNICALITIES: CLASSES, ETC. 
) 
return os« '(' «
d.yearO 
«
',' «
d.month() 
«
',' « d.dayO« 'I'; 
istream& operator» (islream& is, Datc& dd) 
{ 
int y, m, d; 
char chl, ch2, ch3, ch4; 
is» chl » y» ch2» m » chJ » d » ch4i 
if (!is) return is; 
if (chl !='(' II ch2 !=',' II ch3!=',' II ch4!=')') ( 
is.clear(ios_base:: failbit); 
return is; 
) 
return is; 
cnum Day ( 
II oops: format error 
II set the fai l bit 
sunday, monday, tuesday, wednesday, thursday, friday, saturday 
) ; 
Day day_oC week(const Date& d) 
{ 
/I . 
Date ncxCSunday(const Oate& d) 
{ 
/I ... 
Date ncxl_weekday(const Date& d) 
{ 
1/ . .. 
) 
} /I Chrono 
Thc fUIlClions implementing » and « 
for Date will be explained in detail in 
§1O.7 and 10.8. 

( HAI' TER 9 TE RMS 
~ 
Drill 
1l1is drill simply involves geuing the sequence of versions of Date to work. For 
each version define a Date called today initialized loJ une 25, 1978. Then, define 
a Date called tomorrow and give it a value by copying today into it and increas-
ing its day by one using add_dayO. Finally, output today and tomorrow using a 
«
defined as in §9.8. 
Your check for a valid date may be very simple. However, don't accept a 
month that is nOt in the {1,12] range or day of the month that is not in the [1,3 1] 
range. Test each version with at least one invalid date (e.g., 2004, 13, -5). 
I. 'nle version from §9.4.1 
2. 'Ille version from §9.4.2 
3. 'n le version from §9.4.3 
4. 111e version from §9.7.1 
5. The version from §9.7.4 
Review 
I. \¥hat are the two parts of a class, as described in the chapter? 
2. What is the difference between the interface and the implementation in a 
class? 
3. What arc the limitations and problems of the original Date struct that is 
created in the chaptcr? 
4. Why is a constructor used for the Dale type instead of an iniCdayO 
function? 
5. ' ","hat is an invariant? Give examples. 
6. When should functions be put in the class definition, and when should 
they be defined outside the class? \-Vhy? 
7. When should operator overloading be used i.n a program? Give a list of 
operators that you might want to overload (each with a reason). 
8. Why should the public interface to a class be as small as possible? 
9. What docs adding const to a member fUllction do? 
10. Why arc "helper functions" best placed outside the class definition? 
Terms 
built-in types 
class 
consl 
construclOr 
deslJUctor 
enum 
enumcration 
enumerator 
helper fUllction 
implementation 
inlini.ng 
interface 
invariant 
representation 
struct 
structure 
user-defUled types 
valid state 

CHAPTE R 9 • TECHNICAllTI ES: CLASSES, ETC. 
Exercises 
1. List sets of plausible operations for the cxamplcs of rcal-world objects in 
§9.1 (such as toaster). 
2. Design and implement a Name_pairs class holding (name,age) pairs where 
name is a string and age is a double. Represent lhat as a vector<5tring> 
(called name) and a vector<double> (called age) member. Provide illl 
input operation read_namesO that reads a series of names. Provide a 
read_agesO operation that prompts the user for an agc for eacll nillnc. 
Provide a printO operation that prints alit the (namelil,age(il) pairs (onc 
per line) in the order delemlined by the name vector. Provide a sarlO op-
eration that sons the name vector in alphabetical ordcr and reorganizes 
the age vector to match. Implemcnt all "operations" as member functions. 
"ICst thc class (of course: test early and often). 
3. Rcplace Name_pair: :printO with a (global) operator« and define == 
and != for Name_pairs. 
4. Look at the headache-inducing last example of §8.4. Indent it properly 
and explain the meillling of each construct. Note that the example doesn't 
do anything meaningful; it is pure obfuscation. 
5. 1l1is exercise and the next few require you to design and implement a 
Book class, such as you can imagine as part of software for a library. 
Class Book should have members for the ISBN, title, author, and copy-
right date. Also store data on whether or not the book is checked out. 
Create functions for returning those data values. Create functions for 
chccking a book in and out. Do sinlple validation of data entered into a 
Book; for cxample, accept ISBNs only of the foml n-n-n-x where n is an 
integer and x is a digit or a letter. 
6. Add operators for the Book class. Have the == operator c1leck whether 
the ISBN numbers are the same for t\'vo books. Have != also compare 
the ISBN numbers. Have a « print out tlle title author, and ISBN on 
separate lines. 
7. Create an enumerated type for the Book class called Genre. Have the 
types be fiction, nonfiction, periodical, biography, children. Give each 
book a Genre and make appropriate changes to the Book constmctor 
and member functions. 
8. Create a Patron class for tlle library. TIle class will have a user's name, li-
brary card number, and library fees (if owed). Have functions that access 
these methods, as well as a function to set thc fcc of the user. Have a 
helper method that returns a Boolean (bool) depending on whether or 
not the user owes a fcc. 
9. Create a Library class. Include vectors of Books and Patrons. Include a 
struct called Transaction. Have it include a Book, a Patron, and a Dale 

CHAPTER 9 EXERCISES 
from the chapter. Make a veClor of Transactions. Create functions to add 
books to the library, add patrons to the library, and check Olll books. 
Whenever a user checks out a book, have the library make sure that 
both the user and the book arc in the library. If they aren't, report an 
error. Then check to make sure that the user owes no fees. If the uscr 
docs, report an error. If not, create a Transaction, and place it in the vec-
tor of Transactions. Also create a method that will return a vector that 
contains the names of all Patrons who owe fees. 
10. Implement leapyearO from §9.8. 
I I. Design and implement a set of useful helper function for the Date class 
with functions such as next_workdayO (assume that any day that is not a 
Saturday or a Sunday is a workday) and week_oCyearO (assume lhal 
week I is the week wit.hJanuary 1 in it and that the first day of a week is 
a Sunday)_ 
12. Change the representation of a Date to be the number of days since 
January I, 1970 (kJlOwn as day 0), represented as a long, and re-
implement t.he funClions from §9.8. Be sure to reject dates outside the 
range we can represent. that way (feel free to reject days before day 0, i.e., 
no negative days). 
13. Design and implement a rational number class, Rational. A rational 
number has two parts: a numerator and a denominator, for example, 5/6 
(fi ve~sixths , also known as approximately .83333). Look up the defini-
tion if you need to. Provide assignment, addition, subtraction, multiplica-
tion, division, and equality operators. Also, provide a conversion to 
double. Why would people want to usc a Rational class? 
14. Design and implement a Money class for calculalions involving dollars 
and ccnts where arithmetic has to be accurate to the last cent using the 
4/5 rounding rule (.5 of a cem rounds up; anything less than .5 rounds 
down). Represent a monetary amount as a number of cents in a long, 
but input and output as dollars and cents, e.g., $123.45. Do not worry 
about amounts thai don't fit into a long. 
15. Refine the Money class by adding a currency (given as a constmctor ar-
gument). Accept a floating-point initializer as long as it can be exactly 
represented as a long. Don't accept illegal operations. For example, 
Money·Money doesn't make sense, and USD1 .23+DKKS_OO makes sense 
only if you provide a conversion table defining the conversion factor be-
tween U.S. dollars (USD) and Danish kroner (DKK). 
16. Give an example of a calculation where a Rational gives a mathemati-
cally better result than Money. 
17. Give an example of a calculation where a Rational gives a mathemati-
cally better result than double. 
335 

CHAPTER 9 • TECHNICALITIE S: CLASSES, ETC. 
Postscript 
There is a lot to user-defined types, much more than we have presented here. 
User·defined types, especially classes, are the heart of C++ a.nd the key to many 
of the most effective design techniques. Most of the rest of the book is about the 
design and use of classcs. A class - or a set of classes - is the mechanism through 
which we represent our concepts in code. Here we primarily introduced the 
language·technical aspects of classes; elsewhere we focus on how to elegantly ex· 
press useful ideas as classes. 

Part II 
Input and Output 


\ 1. 
'-'0 
Input and Output Streams 
"Science is what we have learned about 
how to keep from fooling ourselves." 
-Richard P. feynman 
I
n this chapter and the next, we presem the C++ standard 
library facilities for handling input and output from a variety 
of sources: I/O streams. We show how to read and write files, 
how to deal with errors, how to deal with formancd input, and 
how to provide and usc I/O operators for user-defined types. 
ll1is chapter focuses on the basic model: how to read and write 
individual values, and how to open, read, and write whole files. 
The final example illustrates the kinds of considerations that go 
into a larger piece of code. 111e next chapter addresses details. 
339 

340 
CHAPTER 10 • INPUT AND OUTPUT STREAMS 
10.1 Input and output 
10.2 The 110 stream model 
10.3 Files 
10.4 Opening a file 
10.5 Reading and writing a file 
10.6 110 error handling 
10.7 Reading a single value 
10.7.1 Breaking the problem into 
manageable parts 
10.8 User-defined oulpul operators 
10.9 User-defined input operators 
10.10 A standard inpulloop 
10.11 Reading a structured file 
10.11.1 In-memory representation 
10.11 .2 Reillding slruclured values 
10.11 .3 Changing representations 
10.7.2 Separating dialog from function 
10.1 Input and output 
Without data, computing is pointless. We need to get data into Ollr progr.un La do 
intercsting computations and we need to get the results out again. In §4.1 , we men-
tioned the bewildering variety of data sources and targets for output. If we don't 
watch out, \ve'll end up writing prognuns that can receive input only from a specific 
source and deliver output only to a specific output device. That may be acceptable 
(and sometimes even necessary) for specialized applications, such as a digital cam-
era or a sensor for an engine fuel it~ector, but for more common tasks, we need a 
way to separate the way our program reads and '>vIites [rom the actual input and 
output devices used. If we had to dit'ecuy address eadl kind of device, we'd have to 
change our program each litne a new screen or disk came on the market, or limit 
our users to ule screens and disks we happen to like. llmt would be absurd. 
Most modern operating systems separate the detailed handling of lIO de-
vices into device drivers and then access the device drivers through an 110 Ii· 
brary that makes I/O fromlto different sources appear as similar as possible. 
Generally, the device drivers arc deep in the operating system where most users 
don't sec them, and the I/O library provides an abstraction ofl/O so that the pro-
grammer doesn't have to think about devices and device drivers: 
Data source: 
Input device 
Device driver 
Input library 
Our program 
Data destination: 
Output library H Device driver H Output device 

10 .2 
THE I/ O STREAM MODEl 
When a model like tlus is used, all input and all output can be seen as streams of 
bytes (characters) handled by the input/output library. Our job as programmers 
of an application then becomes 
1. 1b set up 110 streams to the appropriate data sources and destinations 
2. To read and write fromlto those StreanlS 
11le details of how our characters arc actually transmitted to/from the devices arc 
dealt with by the 110 library and the device drivers. In this chapter and the next, 
we'lI see how I/O consisting of streams of formatted data is done using lhe C++ 
standard library. 
From the programmer's point of view there arc many different kinds of input 
and output. One classification is 
Streams of (many) data items (usually to/from files, network connec-
tions, recording devices, or display devices) 
Interactions with a user at a keyboard 
Interactions with a user through a graphical imerfacc (outputting objects, 
receiving mouse clicks, etc.) 
~11 1is classification isn't the only classification possible, and the distinction be-
tween the three kinds of 1/0 isn't as clear as it might appear. For example, if a 
stream of output characters happens to be an HTI1' document aimed at a 
browser, the result looks remarkably like user interaction and can comain graph-
ical clements. Conversely, the results of interactions with a G UI (graphical user 
imerface) may be presellled to a program as a sequence of characters. However, 
this classification fits our tools: the first twO kinds of 110 arc provided by the 
C++ standard library 110 streams and supported rather directly by most operat-
ing systems. We have been using the iostream library since Chapter I and will 
focus on that for this and the next chapter. The graphical output and graphical 
user interactions are served by a variety of different libraries, and we will focus 
onlhat kind of 110 in Chapters 12 to 16. 
10.2 The I/O stream model 
TIle C++ standard library provides the type istream to deal with streams of 
input and the type ostream to deal with streams of output. We have used the 
standard islream called cin and the standard oslream called cout, so we know 
the basics of how to usc this part of the standard library (usually called the 
iostream librmy). 
An ostream 
Turns values of various types into character sequences 
Sends those characters "somewhere" (such as to a console, a file, the 
main memory, or another computer) 
341 

342 
CHAPTER 10 • INPUT AND O UTPUT STREAMS 
We can represent an ostream graphically like this: 
Values of various types 
Character sequences 
;';Somewhere" 
(12,34) 
osloeam 
Buffer 
TIle buffer is a data stnlcturc that the ostream uses intcmally to store the data you 
give it while conUllUnicaling with the operating system. If you notice a "delay" be-
tween your writing to an oslream and the characters appearing at their destination, 
it's usually because they arc still in the bulTer. Buffering is imJXlrtant for pcrfonn. 
ance, and perfomuUlcc is important if you deal with large alllOunts of data. 
An istream 
Tums character sequences into values of various types 
Gets those characters from somewhere (such as a console, a file, the 
main memory, or another computer) 
We can represent an istream brraphicaUy like this: 
Values of various typcs 
Charactcr sequences 
"Somewherc" 
(12,34) 
istream 
Buffer 
As with an ostream, an istream uses a buffer to conununicatc with thc operating 
systcm. "Vil.h an istream, the buffering can be quite visible to the user. When you 
usc an istream that is anached to a keyboard, what you type is left in the buffer 
until you hit Enter (return/ newline) and you can usc the erasc (Backspacc) kcy 
" to changc your mind" (until you hit Enter). 

10 .3 
FIl.ES 
One of the m~or uses of output is to produce data for humans to read. 
111ink of email messages, scholarly articles, web pages, billing records, business 
reports, contact lists, tables of contents, equipment status readouts, etc. There-
fore, oslreams provide many features for fOfll13tting text to suit various tastes. 
Similarly, much input is wTitten by humans or is fonnatled to make it easy for 
humans to read it. Therefore, istJeams provide features for reading the kind of 
output produced by oslreams. "\'e'll discuss fonnatling in §ll .2 and how to read 
non-character input in §11.3.2. Most of the complexity related to input has to do 
with how to handle errors. To be able to give more realistic examples, we'll start 
by discussing how the iostream model relates to mes of data. 
10.3 Files 
"Ve typically have much more data than can fit in the main memory of our COIll-
puter, so we store most of it on disks or other large-capacity storage devices. Such 
devices also have the desirable property that data doesn't disappear when the 
power is turned ofT - the data is persistent. At the most basic level, a file is simply 
a sequence of bytes numbered from 0 upward: 
0: 
I: 2: 
I 
1:::=::::::::::::,-1 -'--'--' 
A file has a format; that is, it has a set of rules that determine what the bytes 
mean. For example, if we have a text file, the first 4 bytes wiJ[ be the first four 
characters. On the other hand, if we have a file that uses a binary representation 
of integers, those very same first 4 bytes will be taken to be the (binary) represen-
tation of the first integer (see §11 .3.2). ~nle format serves the same role for files 
on disk as types serve for objects in main memory. We can make sense of the bits 
in a file if (and only if) we know its format (see §11.2-3). 
For a file, an ostream converts objects in main memory into streams of bytes 
and writes them to disk. An islream does the opposite; that is, it takes a Stream of 
bytes from disk and composes objects from them: 
E Disk ~ <: 110 system > 
---
Flies 
iostreams 
(sequences of byees) 
Main 
memory 
Objects 
(or various types) 
Most of the time, we assume that these "bytes on disk" arc in fact characters in 
our usual character set. That is not always so, but we C.'lIl get an awfully long way 
343 

344 
CHAPTER 10 • INPUT AND OUTPUT STREAMS 
with thal assumption, and other representations afC not that hard to deal with. 
We also talk as if all rues were on disks (that is, on rotating magnetic storage). 
Again, that's not always so (think of flash memory), but at this level of program-
ming the actual storage makes no difference. TImt's one of the beauties of the file 
and stream abstractions. 
To read a file, we must 
I . Know its name 
2. Open it (for reading) 
3. Read in the characters 
4. Close it (though lim is typically done implicitly) 
To write a file, we must 
1. Name it 
2. Open it (for writing) or create a new rlle of that name 
3. Write Out OUf objects 
4. Close it (though that is typically done implicitly) 
We already know the basics of reading and writing because an ostream attached 
to a fLle behaves exacliy as cout for what we have done so far, and an istream at-
tached LO a me behaves exactly as cin for what we have done so far. We'll present 
operations that can only be done for ftles later (§11.3.3), blll for now we'll just 
see how to open ftles and then concentrate on operations and techniques that 
apply to all ostreams and all istreams. 
10.4 Opening a file 
If you want to read from a file or write to a file you have to open a stream specif· 
ically for that file. An ifstream is an islream for reading from a file, an o(stream is 
an ostream for writing to a file, and an (stream is an ioslream that can be used 
for both reading and writing. Before a file stream can be used it mUSt be attached 
to a file. For example: 
coul « "Please enter input (ile name: It; 
string name; 
cin » name; 
ifsh eam ist(name,c_str()); 
1/ ist is an input stream for the file named name 
if (!ist) error("can't open input fil e ",name); 
Defining an ifstream with a name string opens the file of that name for reading. 
~nl e function c_str() is a member of string that produces a low·level C·style string 

10.4 
OPENING A FilE 
(rom a C++ string. Such C-style strings arc required by many system interfaces. 
l11e test o( !isl checks that the me was properly opened. After that, we can read 
(rom the file exactly as we would (rom any otller istream. For example, assuming 
that the input operator, » , was defined for a type Point, we could write 
vector<Point> points; 
Poinl p; 
while (isl» p) points.push_back(p); 
Output to Hies is handled in a similar (ashion by of streams. For example: 
cout « "Please enter name of oulput rile: "; 
string oname; 
d n »
oname; 
of sire am ost(oname.c_str()); Ilost is an output Siream for a file named name 
if (!ost) error("can't ope n output file " ,oname); 
Defining an of stream with a name string opens the file with that name (or writ· 
ing. "nle test o( ! ost checks that the file was properly opened. After that, we can 
wlite to lhe file exactly as we would to any other ostream. For example: 
for (int i=O; i<points.size(); ++i) 
ost « '('« poinlsfil.x « ',' « points(i).y « ")\n"; 
When a file stream goes out o( scope its associated me is closed. ''''hen a file is 
closed its associated buffer is "flushed
n
; that is, the characters from the buffer are 
written to the file. 
It is usually best to open Hies early in a program before any serious computa-
tion has taken place. After all, it is a waste to do a lot o( work just to fmd that we 
c.1..n't complete it because we don't have anY' ... here to write our results. 
Opening the me implicitly as part of lhe creation of an ostream or an istream 
and relying on the scope of the stream to take care of closing the me is the ideal. 
For example: 
void fiIU rom_file(vector<Poinl>& points, string& name) 
( 
ifstream isl(name.c_str()); 
/I open (j Ie for rcading 
if (!ist) e rror("can't open input file " ,name); 
II . .. usc isl ... 
Illhe file is implicitly closed when we leave the function 
) 
345 

CHAPTER 10 • INPUT AND OUTPUT ST REAMS 
You can also perform explicit open() and close() operations (§B.7. I). However. 
relying on scope minimizes the chances of someone trying to usc a file stream be-
fore it has been aU.ached to a stream or after it was closed. For example: 
ifslream ifs; 
/I . . . 
ifs » foo; 
/I . . 
ifs.open(name.ios_base:: in); 
/I . .. 
ifs.close(); 
/I . . . 
ifs» bar: 
/I . . 
/I won'l succeed: no file openl.xl for ifs 
/I open file named name for reading 
II close file 
/I won'l succeed: ifs' file was closed 
In real·world code the problems would typically be much harder to spot. Fortu· 
nately, you can', open a file stream a second lime withom first closing it. Fo r 
example: 
fstream fs; 
fs.open("foo", ios_base: :in); 
/I close() missing 
fs.open("foo", ios_base: :oul): 
if (fs) error("impossible"): 
/I open for input 
/I won'l succeed: ifs is already open 
Don't forget to test a stream after opening it. 
Why would you usc openO or closeO explicitly? Well, occasionally the life-
time of a connection to a file isn't conveniently limited by a scope so you have to. 
But that's rare enough for us not to have to worry about it here. More 10 the 
paim, you'll find such usc in code written by people using styles from languages 
and libraries that don't have the scopcd idiom used by ioslreams (and the rest of 
the C++ standard library). 
As we'll sec in Chapter 11, there is much more to files, but for now we know 
enough to usc them as a data source and a destination for data. 111al'lI allow us 
to write programs that would be unrealistic if we assumed that a user had to di-
rectly type in all the inpul. From a progranuner's point of view, a great advantage 
of a file is that you can repeatedly read it during debugging until your progran1 
works correctly. 
10.5 Reading and writing a file 
Consider how you might read a set of results of some measurements from a file 
and represent them in memory. This might be the temperature readings from a 
weather station: 

10.5 
READING AND WR ITING A FILE 
o 60.7 
1 60.6 
2 60.3 
3 59.22 
"n lis dma fLle contains a sequence of (hour of day,lempermure) pairs. '11e hours 
are numbered 0 to 2J and the temperatures are in Fahrenheit. No funher fomlatling 
is assumed; that is, the file docs not contain any special header information (such as 
where the reading was taken), units for the vaiues, punctuation (such as parenthe· 
ses around each pair of values), or termination indic.."llor. This is the simplcst case. 
We could represent a temperature reading by a Reading type: 
slrucl Reading { 
/I a temperature reading 
int hour; 
/I hour after midnight 10:231 
double temperature; 
/I in Fahrenheit 
Reading(int h, double t) ;hour(h), temperature(t) {} 
); 
Given that, we could read like this: 
vector<Reading> temps; 
/I store the readings here 
inl hour; 
double temperature; 
while (ist » hour » temperature) { 
if (hour < 0 1123 <hour) error(" hour out of range"); 
temps.push_back(Reading(hour,temperature»; 
111is is a typical input loop. TIle istream called ist could be an input file stream 
(irstrcam) as shown in the previous section, (an alias for) the standard input 
strcam (d n), or ally other kind of istream. For code like this, it doesn't maner ex· 
actly from where the istream gets its data. All that our program cares about is 
that ist is an istream and that the data has the expected fonnat. The next section 
addresses the interesting question of how to detect errors in the input data and 
what wc c.."ln do after detecting a fonnal error. 
Writing to a file is Llsually simpler than reading from one. Again, once a 
stream is initialized we don't have to know exacdy what kind of stream it is. In 
particular, we can use the output me stream (of stream) from the section above 
just like any other ostream. For example, we might want to output the readings 
with ead l pair of values in parenthescs: 
for (int i=O; k temps.size(); ++i) 
ost « '(' « temps[iJ.hour « ','« tempslil.temperature « ")\n"; 
347 

348 
CHAPTER 10 • INP UT AND OUTPUT STREAMS 
The resulting program would then be reading the original temperature rcading 
me and producing a new me with the data in (hour,tcmperature) formal. 
Because the file streams automatically close their mes when they go Ollt of 
scope, the complete program becomes 
#include "sld_lib_facilities.h " 
slruel Reading ( 
1/ a ternl)eraturc reading 
int hour; 
1/ hour after midnight [0:231 
double temperature; 
II in Fahrenheit 
Reading(inl h, double I) :hour(h), temperature(t) (} 
} ; 
int mainO 
( 
) 
cout« "Please enter input file name: "; 
siring name; 
dn » name; 
ifstream ist(name.cstrO); 
/1 isl rcads from the file named "name" 
if (!ist) error("can't open input file " ,name)i 
cout« "Please enler name of output file: " ; 
cin» name; 
of stream OSl(name.cstr()), 
Ilost writes to a file named "name" 
if (!osl) error("can't open output fife " ,name); 
vector<Reading> temps, 
II store the readings here 
int hour, 
double temperature; 
while (ist » hour » temperature) { 
if (hour < 0 1123 <hour) error("hour out of range"), 
temps. pu sh _back(Rcadi n g(hou r, tem peralu re» ; 
for (int i=O; k temps.sizcO; ++i) 
osl« '(' « tempslil.hour« ',' 
«tempslil.temperature« ")\n"; 
1 0.6 1/0 error handling 
When dealing with input we must expecl crrors and deal with them. What kind 
or errors? And how? Errors occur because humans make mistakes (misundcr-

10 .6 
1/0 ERROR HANDLING 
standing instructions, mistyping, letting the cat walk on the keyboard, etc.), be· 
cause files fail to meet specifications, because we (as programmers) have the 
wrong expectations. etc. The possibilities for input errors are limitless t However, 
an istream reduces all to four possible cases, called the Jlream slate: 
Stream states 
goodO 
eof() 
failO 
badO 
The operations succeeded. 
We hit end of input (Nend of file·). 
Something unexpected happened. 
Something unexpected and serious happened. 
Unfortunately, the distinction between fail O and badO is not precisely defined 
and subject to varying opinions among progranuners defining I/O operations for 
new types. However, the basic idea is simple: If an input operation encounters a 
simple fonnat error, it lets the stream fail() , assuming that yOll (the lIser of our 
input operation) might be able to recover. If, on the olher hand, something really 
nasty, such as a bad disk read, happens, the input operation lets the stream go 
badO, assuming that there is nothing much YOll "'m do except to abandon the at· 
tempt to get data from that stream. lllis leaves us with this general logic: 
inti = O; 
cin » i; 
if (!cin) ( I/we get here (only) if an input oper.llion f.liled 
if (cin.bad()) error("cin is bad"); /I stream corrupted: ICI's get out of hcre! 
if (cin .eofOl ( 
1/ no more input 
/I this is often how we want a sequence of input operations to end 
) 
if (cin.fail()) ( 
1/ stream encountered something unexpected 
cin.clear(); 
II make ready for more input 
II somehow recover 
) 
TIle !cin can be read as "dn is not good" or "Something went wrong with cin" 
or "~nle state of cin is not goodO." It is the opposite of "The operation suc· 
ceeded." Note the cin.clearO where we handle faH O. "When a stream has failed, 
we might be able to recover. To try to recover, we explicitly take lhe stream out of 
the failO Slate, so that we can look at characters from it again; clearO docs that -
after cin.clearO the state of cin is good{). 
34. 

35() 
C HAPTER 10 • INP UT AND OUTPUT ST RE AMS 
Here is an example of how we might use the stream state. Consider how to 
read a sequence of integers that may be terminated by the character · or an "end 
of file" (Clrl+Z on Wmdows, Orl+D on Unix) imo a vector. For example: 
1 23 4 5* 
1l1is could be done using a function like this: 
void fill_vector(istream& isl. vedor<int>& v, char terminator) 
) 
/I read integers from is! into v until we reach eofO or terminator 
inl i=O; 
while (isl» i) v.push_back(j); 
if (ist.eof()) return; 
II fine: we found the end of file 
if (ist.bad(» crror("isl is bad "); 
/I stream corrupted; let's get out of here! 
if (ist.fail(» ( /I clean up the mess as best we can and report the problem 
ist.clear(); 
II clear stream slate, 
/! so that we can look for terminator 
char C; 
isl» c; 
/I read a character, hopefully terminator 
if (c!= lerminalor) ( /I unexpected character 
ist.unget(); 
/I put that character back 
iSl.clear(ios_base:: failbil) ; 
/I set the state to failO 
) 
) 
Note that when we didn't Hnd the temunator, we still returned. After all. we may 
have collected some data and the caller of fill_vectorO may be able to recover from 
a fail(). Since we cleared the state to be able to examine the character, we have to 
set the stream stale back to fail(). We do that with iSloclear(ios_base: :failbit). Note 
this potentially confusing use of clear(): clear() with an al"j;>'l.Ullent actually sets the 
iostream state flags (bits) mentioned and (only) clears flags l10t mentioned. By set· 
ting the state to fail(), we indicate that we encountered a format el1-ar, rather than 
something more serious. We put the character back into ist using ungel() ; the 
caller of fill_veclor() might have a usc for it. TIle ungetO function is a shaner vcr· 
sion of putbackO that relics on lhe stream remembering which character it last 
produced, so that you don't have to mention it. 
If you called fill_vectorO and wam to know what terminated the read, you 
a m test for faiiO and eofO. You could also calch the runlime_error exception 
thrown by crrorO, but it is understood that getting more data from islream in the 

10.6 
110 ERROR HANDLING 
badO state is unlikely. Most callers won't bother. TIlis implies that in almost an 
cases the only thing we want to do if we encounter badO is to throw an excep-
tion. 'lb make life easier, we can tell an istream to do that for us: 
/I make ist throw if it goes bad 
ist. except ions(ist .except io nsOlios_base: : badbit); 
'11e notation may seem odd, but the effect is simply that from that statement on-
ward, ist will throw the standard library exception ios_base: :failure if it goes 
badO. We need to execute t.hat exceplions() call only once in a program. TIml'll 
allow us to simplify all input loops by ignoring bad(): 
void fill_vector(islream& isl, veclor<inl>& v, char terminator) 
{ 
/I read integers from ist into v until we reach eafO or terminator 
inti=O; 
while (ist» i) v.push_back(i); 
if (ist.eof()) return; 
II fine: we found the end of file 
II not goodO and nOI bad{) and nOI eafO, is! must be fail O 
ist.clearO; 
II dear stream state 
char c; 
ist»c; 
/I read a character, hopefully terminator 
if (c != terminator) ( 
II ouch: not the terminator, so we must fail 
ist.unget(); 
II maybe my caller can use that character 
ist.dear(ios_base: : fai lbit); 
/I set the state to {ai 10 
' 11e ios_base that appears here and lhere is the part of an iostream that holds 
constants such as bad bit, exceptions such as failure, and other useful stuff. You 
refer 10 them using the :: operalor, for example, ios_base: :badbit (see §10.6 and 
§B.7.2). We don't plan to go into the iostream library in that mudl detail; it could 
take a whole course to explain all of iostreams. For example, iostreams can han-
dle different character sets, implement different buffering strategies, and also can-
lain facilities for fonnalling monetary amounts in various languages; we once 
had a bug report relating to the formatting of Ukrainian currency. You can read 
up all whatever bits you need to know about if you need 10j sec The C++ Pr0-
gramming Language by Strousmlp, and Langer, Standard C++ IOStreams and LomieJ. 
You can test an ostream for exactly tile same states as an islream : good(), 
fail() , eofO, and bad(). However, for the kinds of program s we write here, errors 
351 

352 
CHAPTER 10 • INPUT AND OUTP UT STREAMS 
arc much rarer for outpullhan for input, so we don't do it as often. For programs 
where output devices have a morc significant chance of being unavailable, filled, 
or broken, we would test after each output operation just as we test after each 
input opcralion. 
10.7 Reading a single value 
So, we know how to read a series of values ending willI the end of file or a termi-
nator. We'll show mOTC examples as we go along, hut let's just have a look at the 
evcr popular idea of repeatedly asking for a value until an acceptable one is en-
tered. 111is example will allow us to examine several common design choices. 
We'll discuss these ahematives through a series of altcmativc solutions to the 
simple problem of "how to get an acceptable value from the USeT.
n We stan with 
an unpleasantly messy obvious "first try" and proceed through a series of im-
proved versions. Our fundamental assumption is that we arc dealing with inter-
active input where a human is typing input and reading the messages from the 
program. Let's ask for an integer in the range Ito 10 (inclusive): 
cout « "Please enter an integer in the range 1 to 10 (inclusive) :\n"; 
intn=O; 
while (cin» n) { 
II read 
if (1<=n & & n<=10) break; 
II check range 
cout « "Sorry" 
«
n «
" is not in the 11 :10J range; please try again\n"; 
l1lis is pretty ugly, but it "son of works." If you don't like using the break (§A.6), 
you can combine the reading and the range checking: 
cout « "Please enter an integer in the range 1 to 10 (inclusive):\n"; 
int n = 0; 
while (cin» n && !(1<=n && n<=10» 
II read and check range 
cout « "Sorry " 
«
n «" is not in the [1 :101 range; please Iry again\n"; 
However, that's just a cosmetic change. Why docs it only "son of work"? It 
works if the user carefully enters integers. If the user is a poor typist and hilS t 
raUler Ulan 6 (t is just below 6 on most keyboards), the program will leave the 
loop without changing the value of n, so that n will have an out-of-range value. 
We wouldn't call that quality code. A joker (or a diligent tcster) might also send 
an "end of file" from the keyboard (Ctrl+Z on a Windows machinc and Ctrl+D 
on a Unix machine). Again, we'd leave the loop with n out of range. In other 
words, to gel a robust read we have to deal with three problems: 

10.7 
READING A SINGLE VAlUE 
I. TIle user typing an out·of·range value 
2. Getting no value (end of file) 
3. "Ille user typing something of the wrong type (here, not an integer) 
' \That do we want to do in those three cases? l1lat's often the question when 
writing a program: what do we really want? Here, for each of those three errors, 
we have three ahematives: 
I. Handle the problem in the code doing the read. 
2. TIu"Ow an exception to let someone clse handle the problem (potentially 
terminating the program). 
3. Ignore the problem. 
As it happens, those arc three very common altematives for dealing with an error 
condition. "nlllS, this is a good example of the kind of thinking we have to do 
about errors. 
It is tempting to say that the third altemalive, ignoring the problem, is always 
unacceptable, but that would be patronizing. If I'm writing a trivial program for 
my own usc, I can do whatever I like, including forgetting about error checking 
with potential nasty results. However, for a program that I might want to usc for 
more than a few hours after I l't'fote it, I would probably be foolish to leave such 
errors, and if I want to share that program with anyone, I should not leave such 
holes in the error checking in the code. Please note that we deliberately usc the 
first·pcrson singular here; "we" would be misleading. We do not consider alter-
native 3 acceptable even when just two people are involved. 
TIle choice between altematives I and 2 is genuine; that is, in a given pro· 
gram there can be good reasons to choose either way. First we note that in most 
programs there is no local and elegant way to deal with no input from a user sit· 
ting at the keyboard: after the input stream is closed, there isn't much point in 
asking the user to enter a number. We could reopen d n (using d n.dearO), but 
the user is unlikely to have closed that stream by accident (how would you hit 
Clrl+Z by accident?). If the program wants an integer and finds "end of fite,n the 
part of the program trying to read the integer must usually give lip and hope that 
some other part of the program can cope; that is, our code requesting input from 
the user mUSt throw an exception. TIlis implies that the choice is not between 
throwing exceptions and handling problems locally, but a choice of which prob· 
lems (if any) we should handle locally. 
10.7.1 Breaking the problem into manageable parts 
Let's try handling both an out-of·range input and an input of the wrong type 
locally: 
cout « "Please enter an integer in the range 1 to 10 (inclusive):\n"; 
intn = O; 
353 

354 
( HAPTER 10 • INPUT AND OUTPUT ST REAM S 
while (true) { 
dn »
n; 
if (cin) { 
II we gal an integer; now check it 
if (1<=n && n<=10) break; 
coul « "Sorry" 
«
n «
" is not in the 11:10] range; please try again\n"; 
) 
else if (ein.rail()) ( 
cin.dear(); 
II we found something that wasn't an integer 
II set the stale back to goodO; 
) 
else ( 
) 
II we wanl to look at the characters 
cout « "Sorry, that was not a numbe r; please try again\n"; 
char chi 
while (cin» ch && !isdigil(ch)) ; 
/llhrow away non·digits 
if (!cin) error(nno input"); 
II we didn't find a digit: give up 
cin.unget(); 1/ put the digit back, so that we can read the number 
enor(ltno input"); 
/I eof or bad: give up 
/I if we get here n is in I I : 1 OJ 
This is messy, and rather long-winded. In facl, it is so messy mal we could not 
recommend t.hat people write such cooe each time they needed an integcr from a 
user. On the other hand, we do need to deal with the potential errors because 
people do make them, so what can we do? TIle reason that the code is messy is 
that code dealing with several different concems is all mixed together: 
Reading values 
Prompting the user for input 
Writing error messages 
Skipping past "bad" input characters 
Testing the input against a range 
TIle way to make cooe clearer is often to separate logically distinct concems into 
separate Functions. For example, we can separate out Ille cooe for recovering after 
seeing a ';bad" (i.e., unexpected) character: 
void skip_to_intO 
( 
if (cin.fail(» ( 
/I we found something that wasn't an integer 
cin.dearO; 
/I we'd like to look at the characters 
char eh; 

10 .7 
READING A SINGLE VALU E 
while (cin»ch)( 
II throwaway non-digits 
if (isdigit(ch)) { 
cin.ungetO; II put the digit back, 
II so that we can re.ld the number 
relurn; 
} 
} 
error("no input"); 
/I eof or bad: give up 
Given the skip_IojnlO "utility function," we can write 
cout « "Please enter an integer in the range 1 10 10 (inclusive):\n"; 
inln =O; 
while (true) { 
if (cin» n) { 
/I we gOI an integer; now check it 
if (1<=n && n<=10) break; 
coul « "Sorry " « n 
«" is nol in the (1:10J range; please Iryagain\n "; 
) 
else ( 
coul « "Sorry, that was not a number; please try again\n"; 
skip_Io_inIO; 
) 
II if we get here n is in 11:101 
Illis code is beuer, but it is still tOO loug and tOO messy to usc Illany times in a 
program. We'd never get it consistently right, except aftcr (too) much testing. 
What operation would we really like to have? One plausible answer is "a 
function that reads an in I, any int, and ,morner tlmt reads an int of a given range": 
int geUnlO; 
II read an int from cin 
int gcUnt(intlow, int high); 
/I read an int in Ilow:highl from cin 
If we had those, we would at least be able to use them simply and correctly. TIley 
arc not that hard to write: 
inl geUntO 
{ 
int n = O; 
while (true) { 
355 

356 
} 
C HAPTER 10 • INPU T AND OU TPUT STR EAM S 
if (cin » 
n) return n ; 
cout « 
~ So rr y, that was not a numbe r; please try again\n"; 
skip_lojnl(); 
Basically, geUnlO stubbornly keeps reading lIntil it finds some digits lhat it can 
interpret as an imeger. If we wam to get out of geUnln, we must supply an inte-
ger or end of file (and end of fLle will cause geU IlIO LO throw an exception). 
Using that general geU IlI(), we can write the range-checking SCUIlI(): 
int geUnt(int low, int high) 
( 
} 
coul « 
~ Pl ea s e enler an integer in the range" 
«
low «" to " «
high « " (inclusive) :\n"; 
while (true) ( 
} 
int n = geUnt(); 
if (Iow<=n && n<=high) relurn n ; 
coul « "Sorry " 
«
n «
" is not in the [" « low« ':'« high 
«"I range; please try again\n"; 
"Illis geUIlIO is as stubborn as the other. It keeps gelling ints rrom the non-range 
gel_intO until the int it gets is in the expected range. 
We ""tn now reliably read integers like this: 
inl n = geUnt(1,10); 
cout « "n: "« n « endl; 
int m = geUnt(2,300); 
cout « "m: " « m « endl; 
Don't rorget to catch exceptions somewhere, lhough, ir you want decent error 
messages ror the (probably rare) case when geUnlO really couldn't read a num-
ber ror us. 
10.7.2 Separating dialog from function 
~nle geUntO runcuons still mix up reading wlth writing messages to the user. '1mt's 
probably good enough ror a sim ple program, but in a large program we might want 
to vary the messages written to the user. We might wam to call geUnlO like this: 

10.8 
USER-DEFINED OUTPUT OPERATORS 
int strength = getj nt(l, 10, "enter strength", "Not in range, try again"); 
cout « "strength : "« strength « endl; 
int altitude = geUnt(O,50000, 
"Please enter altitude in feet", 
"Not in range, please try again"); 
cout « "altitude: " «
altitude « "f above sea level\n"; 
We could implement that like this: 
int geUnt(int low, int high, canst slring& greeting, canst slring& sorry) 
( 
caul «
greeting « ": [" « low « 
I: I « high « "J\n "; 
while (true) ( 
int n = geUnt(); 
if (low<=n && n<=high) return n j 
coul « sorry « ": [" «
Iow « ':' «
high « "J\n"; 
) 
It is hard to compose arbitrary messages, so we "stylized" the messages. l1mt's 
often acceptable, and composing really Oexible messages, such as arc needed to 
support many natural hUlguages (e.g., Arabic, Bengali, Chinese, Danish. English, 
and French), is not a task for a novice. 
Note that our solution is still incomplete: the get_inlO without a range still 
"blabbers." -nle deeper point here is that "utility functions" that we use in many 
pans of a program shouldn't have messages "hardwired" into them. Further, li-
brary functions that arc meant for usc in many programs shouldn't write to the 
user at all - after all, the library writer may not even k.now that the program in 
which the library runs is used on a machine with ;I human \vutching. That's one 
reason that our errorO function doesn't just write an error message (§5.6.3); in 
general, we wouldn't know where to write. 
10.8 User-defined output operators 
Defining the output operator, « , for a given type is typically trivial -nle main 
design problem is that different people might prefer I.he Olltput to look difTereIll, 
so it is hard to agree on a single fonnal.. However, even if no single omput format 
is good enough for all uses, it is often a good idea to define « for a user-defined 
type. -n lat way, we can at least trivially write out objects of the type during de-
bugging and early development. Later, wc might provide a more sophisticated « 
that allows a user to provide formatting infonnation. Also, if we wa.nt Olltput that 
357 

358 
CHAPTER 10 • INP UT AND OUTPUT STR EAMS 
looks different from what a « provides, we can simply bypass the « and write 
OUI the individual parts of the lIser-defmed type the way we happen to like them 
in ollr application. 
Here is a simple output operator for Dale from §9.8 that simply prints the 
year, month, and day comma-separated in parentheses: 
oslream& operator«(oslream& os, const Date& d) 
{ 
return os« '(' « d.yearO 
« I,' «
d.monthO 
« ',' «
d.dayO« ')'; 
} 
nlis will prim August 30, 2004, as (2004,8,30), This simple list-of-elemellts repre-
sCnLalion is what we tend to lISC for types willl a few members unless we have a 
better idea or more specific needs. 
In §9.6, we mention that a user-defined operator is handled by calling its 
function. Here we can sec an example of how that's done. Given the definition of 
«
for Date, the meaning of 
cout «
dl ; 
where d1 is a Date is the call 
operator«( cout,d 1); 
Note how operator«O takes an oslream& as its first argument and returns it 
again as its return value. That's the way the output stream is passed along so that 
you can "chain" output operations. For example, we could output two dates like 
this: 
coul « d1 «
d2; 
"nlis will be handled by first resolving the first « and after that the second « : 
coul « dl «
d2; 
/I means operator«(cout,d l)« d2; 
/I means operator«(operator«(cout,d 1 ),d2); 
That is, first output dl to cout and then output d2 to the output stream that is the 
result of the first omput operation. In fact, we can use any of those three variants 
to write OUi dl and d2. We know which one is easier to read, though. 

10. 10 
A STANDARD INPUT lOOP 
10.9 User-defined input operators 
Defining the input operator, » , for a given type and input fonnat is basicaUy an 
exercise in error handling. It can therefore be quite tlicky. 
Here is a simple input operator for the Date from §9.8 that will read dates as 
written by the operator « defined above: 
istream& operator»(islream& is, Date& dd) 
{ 
int y, m, d; 
char ch1, ch2, ch3, ch4; 
is» chl »y» ch2» m »ch3» d » ch4; 
if (!is) return is; 
if (chl! ='(' II ch2!=',' 11 ch3!=',' II ch4!=')') ( /loops: format error 
is.clear(ios_base: :failbit); 
return is; 
) 
dd = Dale(y,Date: :Monlh(m),d); 
II update del 
return is; 
~l1lls » will read items like (2004,8,20) and try to make a Date out of those three 
integers. As ever, input is harder to deal with than output. TIIere is simply more 
that can - and of len docs - go wrong with input than with output. 
If this » doesn't find something in the ( inleger , illleger , integer ) format, it will 
leave the stream in a not-good state (fail, eof, or bad) and leave the target Dale 
unchanged. TIle clear() member function is used to set the state of the islream. 
Obviously, ios_base:: failbit puts the stream into the failO state. Leaving the tar-
get Dale unchanged in case of a failure to read is the ideal; it tends to lead to 
cleaner code. TIle ideal is for an operator»O not to consume (throwaway) any 
characters that it didn't lise, but that's tOO difficult in this case: we might have 
read lots of characters before we c.'lught a fannat error. As an example, consider 
(2~, 8, 3D}. Only when we see the fmal } do we know that we have a fomlal 
error on Ollr hands and we cannot in general rely on putting back many charac-
ters. One character ungelO is all that's universally guaranteed. If this 
operator» O reads an invalid Date, such as (2004,8,32), Date's constructor will 
throw an exception, which will get us out of this operator»(). 
1 0.1 0 A standard input loop 
In §1O.5, we saw how we could read and write files. However, that was before we 
looked more carefully at errors (§1O.6), so the input loop simply assumed that we 
359 

360 
(HAPTER 10 • INPUT AND OUTPUT STR EAMS 
could read a file from its beginning until cnd of file. That can be a reasonable as-
sumption, because we often apply separate checks to cnsure thal a file is valid. 
However, we often want to check ollr reads as we go along. Here is a general 
strategy, assuming that ist is an istream: 
My_lype var; 
while (i51»1Ia,) ( 
/I read until end of file 
) 
/I maybe check that var is valid 
/I do something with var 
/I we can rarely recover from bad; don', try unless you really have 10: 
if (ist.bad(» error(ltbad input stream"); 
if (ist.fail()) ( 
/I was it an acceptable terminator? 
) 
/I carryon: we found end of file 
1l1al is, we read a sequence of values into variables and when we can't read any 
morc values, we check the stream Slale to sec why. As in §IO.6, we call improve 
this a bit by Ictting thc istream throw an exception of type failure if it goes bad. 
111at saves LIS the bother of checking for it all the time: 
/I somewhere: make is! throw an exception if it goes bad: 
ist. except ions(ist .except ionsOlios_base: : bad bit); 
We could also decide to designate a character as a terminator: 
My_type var; 
while (ist»var) { 
/I read lIntil end of file 
II maybe check that var is valid 
/I do something with var 
) 
if (ist.fail()) { 
II use 'I' as terminator andlor separator 
ist.clear(); 
char chi 
if (!(ist»ch && ch=='I'» error("bad termination of input"); 
) 
/I carryon: we found end of file or a terminator 
If we don't want to accept a terminator - that is, to accept only end of file as the 
end; we simply delete the tcst before the call of errorO. Howevcr, tcnninalOrs arc 
very useful when you read files with nested constructs, slich as a file of monthly 

10. 11 
READIN G A STRUCTURED FI LE 
readings containing daily readings, containing hourly readulgs, etc., so we'll keep 
considering the possibility of a tenuinating character. 
Unfortunately, that code is still a bit messy. In particular, it is tedious to re· 
peat the terminator test if we read a lot of files. We could write a function to deal 
with that: 
/I somewhere: make isllhrow if il goes bad: 
ist. exce ptions(ist .exce ptionsOlios_ base: : bad bit); 
void end_oUoop(istream& ist, char term, const slring& message) 
( 
if (ist.fail()) { 
II use term as lerminalor aneVor separalor 
ist.ciear(); 
char Chi 
if (isl»ch && ch==term) return; 
1/ all is fine 
error(message); 
) 
111is reduces the input loop to 
My_type var; 
while (isl»var) { 
1/ read unlil end of file 
1/ maybe check that var is valid 
1/ do something with var 
) 
end_oUoop(ist,'I', "bad termination of file"); 
I/Iesl if we can continue 
1/ carryon: we found end of file or a terminator 
"Inc end_oUoopO docs nothulg unless the stream is in the faii O state. We con-
sider that sunple enough and general enough for many purposes. 
10.11 Reading a structured file 
Let'S try to usc th is "standard loopn for a concrete example. As usual, we'll use the 
example to illustrate widely applicable design and programming leclmiques. As-
sume that you have a file of temperature rcadulgs that has been structured like this: 
A file holds years (of months of readings). 
A year starts with { year followed by an integer giving the ~ar, such 
as 1900, and ends with ). 
361 

362 
C HAPTER 10 • INP U T AN O OUTPUT STR EAMS 
A year holds months (of days of readings). 
A month starts with { month followed by a three-letter month name, 
such as jan, and ends with }. 
A reading holds a lime and a temperature. 
A reading starts with a ( followed by day of the month. hour of the 
day, and lcmperaLUre and ends with a ). 
For example: 
{ year 1990 } 
{year 1991 ( month jun }) 
(year 1992 { month jan ( 1061.5)} {month feb (11 64) (2 2 65.2)}) 
{year 2000 
( month feb (1168 ) (2 3 66.66 ) ( 10 67.2)} 
{month dec (1515 -9.2 ) (15 14 -8.8) (14 0 -2) } 
This formal is somewhat peculiar. File formalS often arc. 111crc is a move toward 
more regular and hierarchically structured flles (such as HTML and XML files) 
in the industry, but the reality is stilllhat we can rarely control the input format 
offered by the files we need to read. 111e files arc the way they are, and we JUSt 
have to read them. If a format is too awful or files contain too many errors, we 
can write a fonnat conversion program to produce a fomlat that suits our main 
program better. On the other hand, we can typically choose the in·memolY rep-
resentation of data to suit our needs, and we can often pick output formats to suit 
needs and tastes. 
So, let's assume that we have been given the temperature reading fonnat 
above and have to live with it. Fortunately, it has self·idelllifying components. 
such as years and months (a bit like HTML or XML). On the other hand, the 
format of individual readings is somewhat unhelpful. For example, there is no in· 
formation mat could help us if someone flipped a day·of·the·molllh value with an 
hour of day or if someone produced a file with temperatures in Celsius and the 
program expected them in Fahrenheit or vice versa. We JUSt have to cope. 
10.11 .1 In-memory representation 
How should we represent mis data in memory? "n le obvious first choice is three 
classes, Year, Month, and Reading, to exactly match the input. Year and Month 
arc obviously useful when manipulating the data; we want to compare tempera· 
tures of different years, calculate monthly averages, compare different months of 
a year, compare the same month of different years, match up temperature read· 
ings with sunshine records and humidity readings, etc. Basically, Year and Month 

10.11 
READI NG A STR UCTURED FILE 
match the way we think aboLit temperatures and weather in general: Month 
holds a month's worth of information and Year holds a year's worth of infonna-
tion. But what about Reading? TImt's a low-level notion matching some picce of 
hardware (a sensor). 111e data of a Reading (day of month, hour of day, tempera-
ture) is "odd" and makes sense only within a Month. It is also unStructured : we 
have no promise that readings come in day-of-the-molllh or hour-of-the-day 
order. Basically, whenever we want to do anything of interest with the readings 
we have to SOrt them. 
For representing the temperature dala in memory, we make these assumptions: 
If we have any readings for a month, then we tend to have lots of read-
ings for that month. 
If wc have any readings for a day, then we tend to have lots of readings 
for that day. 
\Vhen that's thc case, it makes sense to represent a Year as a vcctor of 12 Months, 
a Month as a vector of about 30 Days, and a Day as 24 tcmperatures (one per 
hour). lllat's simple and easy to manipulate for a wide variety of uses. So, Day, 
Month, and Year are simple dala structures, cach with a constructor. Since we 
plan to create Months and Days as part of a Year bcfore we know what tempera-
lUre readings we have, we need to have a notion of "nOl a reading" for an hour of 
a day for which we havcn't (yet) read data. 
canst int noCa_reading = - 7m; 
!!less than absolute zero 
Similarly, we noticed that we often had a month WilhoUl data, so we introduced 
the notion "not a month" to represent that directly, rather than having to scarcll 
through alllhe days to be sure that no data ~ .... as lurking somewhere: 
canst int noCa_month = -1; 
TIle tllree key classes then become 
struct Day { 
vector<double> hour; 
oay(); 
/I initialize hours 10 "not a reading" 
); 
Day: :oay() 
: hour(24) 
{ 
for (int i = 0; i<hour.size(); ++i) hour[i1=noca_reading; 
363 

CHAPTER 10 • INPUT AND OUTP UT STRE AMS 
struct Month { 
1/ a month of temperature readings 
int month ; 
1/ [0:11[ January is 0 
vector<Oay> day; 11 [1 :31[ one vector of readings per day 
MonthO 
1/ at most 31 days in a month (daylOI wasled) 
:month(not_a_monlh), day(32) {} 
) ; 
struct Year ( 1/ a year of temperature readings, organized by month 
int year; 
1/ positive == A.D. 
vector<Month> month; 
1/10:11[ January is 0 
Year() :month(12) {} 
1/12 months in a year 
); 
Each class is basic.-uly a simple vector of "parLS,n and Month and Year have an 
identifying member month and year, respectively. 
There are several "magic constants" here (for example, 24, 32, and 12). We 
try to avoid such litera] constants in code. These arc pretty fundamental (the 
number of months in a year rarely changes) and will not be used in the rest of the 
code. However, we left them in the eode primarily so that we could remind you 
of the problem with "magic eonstantsn; symbolic constants arc almost always 
preferable (§7.6.1). Using 32 for the number of days in a month definitely re' 
quires explanation; 32 is obviously "magic" here. 
10.11 .2 Reading structured values 
TIle Reading class will be used only for reading input and is even simpler: 
struet Reading ( 
int day; 
int hour; 
double temperature; 
) ; 
istream& operator»(istream& is, Reading& r) 
/I read a temperature reading from is into r 
1/ format: ( 3 4 9.7 ) 
/I check format, but don't bother with dala validity 
{ 
char chl ; 
if (is»chl && chl !='(') ( 
II could it be a Reading? 
is.ungel(); 

10. 11 
READING A STRUC TURED FILE 
} 
} 
is.clear(ios_base : :failbit); 
return is; 
char ch2; 
int d; 
int h; 
double I; 
is »
d »
h »
t »ch2; 
if (! is II ch2!=')') error(tlbad reading"); 
r.day = di 
r.hour = h; 
r.temperature = ti 
return is; 
/I messed-up reading 
Basically, we check if the fomml begins plausibly, and if it doesn't we set the file 
state to fail O and return. This allows us to try to read the information in some 
other way. On the other hand, if we find the format wrong after having read 
some data so that there is no real chance of recovering, we bail out with errorO. 
rn 1e Month input operation is much the same, except that it has to read an ar-
bitrary number of Readings rather than a fixed set of values (as Reading's » did): 
islream& operatol'»(istream& is, Month& m) 
/I read a month from is into m 
/I format: I month feb . . . } 
{ 
char ch = 0; 
if (is» ch && ch!='{') ( 
is.ungeIO; 
is.clear(ios_base: :failbil); /I we fai led to rcad a Month 
return is; 
string month_marker; 
string mm; 
is » month_marker » mm: 
if (!is II month_marker!="monthn) error("bad start of month "): 
m.month = month_to_int(mm): 
Reading r; 
365 

366 
} 
int duplicates = 0; 
int invalids = 0; 
while (is» r) { 
if (is_valid(r)) { 
CHAPTE R 10 • INPU T AND OUTPUT STREAMS 
if (m.day(r.day].hour(r.hour] != nOI_a_reading) 
++duplicates; 
} 
} 
else 
m.day[r.day].hour[r.hour] = "temperature; 
++invalids; 
if (invalids) e rror("invalid readings in month" ,invalids); 
if (duplicates) e rror(lIduplicale readings in month", duplicates); 
end_oCloop(is, '}', "bad end of month"); 
return is; 
We'll gel back to month_tojntO later; it convertS the symbolic notation for a 
month, such as jun, to a number in the [0: 11] range. NoLC the usc of end_ofJoop() 
from §1O.1O to check for the terminator. We keep coum of invalid and duplicate 
Readings; someone might be interested. 
Month's » does a quick check that a Reading is plausible before storing it: 
canst int implausible_min = -200; 
const int implausible_max = 200; 
bool is_valid(const Reading& r ) 
/I a rough test 
{ 
} 
if (r.day<111 31<r.day) re turn false; 
if (r.hour<O II 23<r.hour) return false; 
if (r.temperature<implausible_minll implausible_max<r.temperature) 
return false; 
return true; 
Finally, we can read Years. Year's » is similar to Month's » : 
istream& operator»(istream& is, Year& y) 
/I read a year from is into y 
/I format: ( year 1972 .. . ) 
{ 

10. 11 
READIN G A STR UCTURED FILE 
char chi 
is» Chi 
if (ch!='{') ( 
) 
is.unget(); 
is.ciear(ios: : failbit); 
return is; 
siring year_marker; 
int yy; 
is» year_marker » yy; 
if (!is II year_marker! ="year") error("bad start of year"); 
y.year = yy; 
while(lrue) ( 
Month m; 
/I get a clean In each time around 
if(!(is» m» break; 
y.monthlm.monthl = mj 
) 
end_ofJoop(is,'}', "bad end of year"); 
return is; 
We would have preferred "boringiy similar" to just "similar," but there is a sign if~ 
icant difference. Have a look at the read loop. Did you expect something like the 
following? 
Month m; 
while (is» m) 
y.monlh[m.monlhl = m; 
You probably should have, because that's the way we have written all the read 
loops so far. ~nlat 's actually what we first wrote, and it's '\ovrong. The problem is 
that operator» (istream& is, Month& m) doesn't assign a brand·new value to m; 
it simply adds data from Readings to m. l1ms, the repeated is» m would have 
kept adding 1'0 our one and only m. Oops! Each new month would have gotten aU 
the readings from all previous months of that year. vVe need a brand-new, clean 
Month to read into each time we do is>>m. The easiest way to do that was to put 
the definition of m inside the loop so that it would be initialized e.1ch time around. 
The alternatives would have been for opcralor» (istream& is, Month& m) to as-
sign an empty month to m before reading into it, or for the loop to do lhat: 
367 

368 
CHAI)TE R 10 • INPUT AND OUTPUT STREAM S 
Month m ; 
while (is» m) ( 
y.month(m .month] = m; 
m = Month(); 
I/"reinitialize" m 
} 
Let's try to usc it: 
1/ open an input file: 
cout « "Please enter input file name\n"; 
string name; 
dn » name; 
ifslream ifs(name,c_slr(»; 
if (!irs) e rror("can'l ope n input file" ,name); 
ifs.exceptions(ifs.exceplions()lios_base: :badbit); 
/I throw for b.ldO 
/I open an output file: 
cout « "Please e ntcr output file name\n"; 
dn » name; 
of sire am ofs(name.c_str()): 
if (lo£s) error("can" o pen output file" ,name); 
II read an arbitrary number of years: 
vecto r<Year> ySj 
while(true) { 
Year Yi 
/I get a freshly initialized Year each time around 
if (!(ifs»
y» break; 
ys.push_back(y); 
} 
cout « "read "« ys.sizeO« n years of readings\n"; 
for (inl i = 0; kys.size(); ++i) prinCyear(ofs,ys[iJ)i 
We leave prinl_yearO as an exercise. 
10.11 .3 Changing representations 
"to gel Month's » to work, we need to provide a way or reading symbolic repre-
sentations or the month. loor symmetry, we'll provide a matching write using a sym-
bolic representation. TIle tedious way would be to write an if-statement convcn: 
if (s=="jan") 
m = 1; 

10. 11 
READI NG A ST RUCTU RED FlU 
else if (s=="feb") 
m =2; 
~n lis is not just tedious; it also builds the names of the months into the code. It 
would be better to have those in a table somewhere so that the main program 
could stay unchanged even if we had to change the symbolic representation. We 
decided to represent the input representation as a veclor<slring> plus an initial-
ization rUllction and a lookup runction: 
void iniU npuU bl(vector<slring>& Ibl) 
/I initialize vector of input representations 
( 
Ibl. pu sh _ back(" jan"); 
I bl. pu sh_back("feb"); 
Ibl. pu sh_back(" mar"); 
Ibl. pu sh_back(" apr"); 
Ibl. pu sh_ back(" may"); 
Ibl.push_back("jun"); 
Ibl. pu sh_ back(" j ul"); 
Ibl.push_back(IIaug"); 
Ibl. pu sh _ back( II sep "); 
Ibl. push _ back(" ocl"); 
Ibl. pu sh_ back(" nov"); 
Ibl. push _ back(" dec"); 
inl monlh_lojnl(slring s) 
/I is s the name of a month? If ~ return its index 10: I II otherwise-l 
( 
) 
for (inl i=O; i<12; H i) if (monlhj npuU bHi]==s) return i; 
relurn - l ; 
In case you wonder: tbe C++ standard library docs provide a simpler way to do 
this. See §21.6.1 for a map<slring,int>. 
When we wam to produce output, we have the opposite problem. \¥e have 
an int representing a Illonth and would like a symbolic representation to be 
printed. Our solution is fundamentally similar, but instC<ld or using a table to go 
rrom siring to inl, we use one to go rrom inl to string: 
vectoT<slring> month_prinU bl; 
1/ month_prinuhIIOI=="January-
3.' 

37. 
C H AI'TER 10 • INPUT A ND OU TP U T STREAMS 
void iniCprinUbl{veclor<slring>& fbi) 
/I initialize vector of output representations 
{ 
) 
tbl. p ush_back(" Jan uary"); 
fbi. p ush_back(" February"); 
Ibl.push_back(" March"); 
tbl.push_back(It April"); 
tbl.push_backC" May"); 
thl.push_backC"June"); 
tbl. p ush_ back(" lui y"); 
tbl. push_ back(" August"); 
tbl. push _ back(" Septem ber M); 
tbl. pus h_ back(" October"); 
tbl.push_back("November"); 
tbl. pus h _ back(" December"); 
string inUo_month(int i) 
/I months [0: I I I 
{ 
if (kO 11 12<=i) error( tlbad month index"); 
return month-p,inUbl{iJ; 
For this to work, we need to call the initialization functions somewhere, such as at 
lhe beginning o f mainO: 
/I first initialize representation tables: 
init_prinUbl(monlh_prinUbl); 
iniUnpuClbICmonthj nput_tbl); 
So, did you actually read all of that code and the explanations? Or did your eyes 
glaze over and skip to the end? Remember that lhe easiest way of learning to write 
good code is to read a lot of code. Believe it or not, the techniques we used for this 
example are simple, but not trivial to discover without help. Reading data is fun-
damentaJ. Writing loops correctly (initializing every variable lISed con ectiy) is fun-
damental. Converting between representations is fundamental. That is, you will 
learn to do such things. 111e only questions are whether you'll learn to do them 
well and whether you learn the basic techniques before losing tOO much sleep. 

C HAPTER 10 REVIEW 
.../' Drill 
l. Stall a program to work with points, discusscd in §IO.4. Begin by defin-
ing the data type Point that has two coordinate members x and y. 
2. Using the code and discussion in §10.4, prompt the user to input seven 
(x,}) pairs. As the data is entered, store it in a vector of Poinls called 
original_points. 
3. Print the data in original_points to see what it looks like. 
4. Open an of Sire am and autpUl each point to a me named mydata.lxl. On 
\.vindows, we suggest the . Ixt suffIX to make il easier 10 look al the data 
with an ordinary tCXt editor (such as WordPad). 
5. Close the of sir cam and then open an ifstream for mydata.txt. Read the 
data from mydata.txt and store it in a new vector called processed_points. 
6. Prim the data clements from both vectors. 
7. Compare the twO vectors and print Something's wrong! if the number 
of clements or the values of clements differ. 
Review 
I. When dealing with input and output, how is the variety of devices dealt 
with in most modem computers? 
2. \.vhat, fundamentally, does an istream do? 
3. What, fundamentally, docs an oslream do? 
4. \.vhat, fundamentally, is a me? 
5. \.vhat is a me format? 
6. Name four different types of devices that can require 110 for a program. 
7. What arc the four steps for reading a ftle? 
8. What arc the four steps for writing a ftle? 
9. Name and define the four stream states. 
10. Discuss how the follO\ving input problems can be resolved: 
u. TIle user typing an out-of-range value 
b. Gelling no value (end of me) 
c. TIle user typing something of the wrong type 
11. In what way is input usually harder than Output? 
12. In what \vay is output usually harder than input? 
13. Why do we (often) want to separate input and output from computation? 
14. \.vhat are the two most common uses of the islream member function 
d ear()? 
15_ What arc the usual function declarations for «
and » for a user-defined 
type X? 
371 

Terms 
badO 
buffer 
clearO 
closeO 
device driver 
eofO 
failO 
filc 
Exercises 
(HAPTER 10 • INPUT AND OUTPUT STREAMS 
goodO 
ifslream 
input device 
Lllput operator 
ioslream 
islream 
of sire am 
openO 
oslream 
output device 
output operator 
so"Cam state 
structured file 
tenumator 
ungelO 
1. Write a program that produces the sum of all the numbers in a file of 
whites pace-separated integers. 
2. Write a program that creates a me of data in the form of the temperature 
Reading type defined in §10.5. Ell the me with at least 50 temperature 
readings. Call this program store_temps.cpp and the file it creates 
raw_temps.txt. 
3. Write a program that reads the dala from raw_temps.lxt created in 
exercise 2 into a vector and then calculates the mean and median tcm-
peratures in your data set. Calilhis program temp_stats.cpp. 
4. Modify the store_temps.cpp program from exercise 2 to include a tem-
perature suflix c for Celsius or f for Fahrenheit temperatures. 111en mod-
ify the temp_slats.cpp program to test each temperature, convening the 
Celsius readings to Fahrenheit before pUlling them into the vector. 
5. Write the function prin,-yearO mentioned in §1O.11.2. 
6. Defme a Romanj nt class for holding Roman numerals (as ints) with a 
« and » . Provide Roman_inl with an as_intO member that retu01s the 
int value, so that if r is a Roman_inl, we can write coul « "Roman" «
r 
« " equals" «
r.as_intO« '\n';. 
7. Make a version of the calculator from Chapter 7 that accepts Roman nu-
merals rather than the usual Arabic oncs, for e.xample, XXI + ClV == CXXV. 
8. Write a program that accepts two fue names and produccs a new file that 
is the contents of the first file followed by the contents of the second; that 
is, the program concatenates the two files. 
9. Write a program that takes two fues containing sorted whitcspacc-scparated 
words and merges them, preserving order. 
10. Add a command from x to the calculator from Chapter 7 that makes it 
take input from a fue x. Add a COllU11and to y to the. calculator that makes 
it write its output (both standard output and error output) to file y. Write 
a collection of test cases based on ideas from §7.3 and usc lhal to test the 
calculator. Discuss how you would use these commands for testing. 

CHAI)TER 10 POSTSCRIPT 
11. Write a program that produces the sum of all the whitespace-separ;ued 
integers in a text file. For example, "bears: 17 elephants 9 end" should 
output 26. 
12. Write a program that given a me name and a word outputs each line that 
contains that word together with the line number. I-Unt: getlineO. 
Postscript 
Much of computing involves moving lots of data from one place to another, for 
example, copying text from a me to a screen or moving music from a computer 
onto an M P3 player. Often, some transfonnarion of lhe data is needed on the way. 
TIle iostrcam library is a way of handling many such tasks where the data can be 
seen as a sequence (a stream) of values. Input and output can be a surprisingly 
large part of common programming tasks. 111is is partly because we (or our pro-
grams) need a lot of data and partly because the point where data enters a system 
is a place where lots of errors can happen. So, we must try to keep our 110 simple 
and try to minimize the chances that bad data "slips through" into our system. 
373 


'el-
f" 11 
Customizing 
Input and Output 
"Keep it simple: 
as simple as possible, 
but no simpler." 
-Albert Einstein 
I
n this chapter, we CQllccmrate on how to adapt the general 
iOSlream framework prescmcd in Chapter 10 to specific needs 
and tastes. This involves a lot of messy details dictated by human 
sensibilities to what they read and also practical constraints on 
the uses of files. The final example shows the design of an input 
stream for which you can specify the set of separators. 
375 

37' 
CHAPTER 11 
• CUSTOMIZING IN PUT ANO OUTP UT 
11.1 Regularity and irregularity 
11.2 Output formatting 
11 .2.1 Inleger o utput 
11 .2.2 Inleger input 
11 .2.3 Floaling-poinloutput 
11.2.4 Precision 
11 .2.5 Fields 
11.3 File opening and positioning 
11 .3.1 File open modes 
11.3.2 Binary files 
11 .3.3 Positioning in files 
11 .4 String streams 
11 .5 Line-oriented input 
11.6 Charader classification 
11.7 Using nonstandard separators 
11.8 And there is so much more 
11.1 Regularity and irregularity 
The iostrcam library - the input/output part of the ISO C++ standard library -
provides a unified and extensible framework for input and output of lext. By 
"text" we mean JUSt about anything that can be represented as a sequence of 
characters. 111U5, when we talk about input and Output we call consider the ime-
ger 1234 as text because we can write it using the four characters 1, 2, 3, and 4_ 
So far, we have treated all input sources as equivalenl. Somctimes, that's not 
enough. For example, files differ from other input sources (such as communica-
tions connections) in that we can address individual bytes. Sinularly, we worked 
on the assumption that the type of an objcct completely detenllincd the layout of 
iLS input and output. "That's not quite right and wouldn't be sufficient. For exam-
ple, we often want to specify the number of digits used to represent a floating-
point number on output (iLS precision). 111is chapter presenLS a number of ways 
in which we can tailor input and output to our needs. 
As programmers, we prefer regularity; treating all in-memory objects uni-
fonnly, treating all input sources equivalently, and imposing a single standard on 
the way to represent objects entering and exiting the system give the cleanest, 
simplest, most maintainable, and often the most efficiem code. However, OUI' 1'1'0-
grams exist to serve humans, and humans have strong preferences. Thus, as pro-
granuners we must strive for a balance between program complexity and 
accommodation of users' personal tastes. 
11.2 Output formatting 
People care a lot about apparently nunor details of the outpUt they have to read. 
For example, to a physicist 1.25 (rounded to two digits after the dot) can be vel)' 
different fmm 1.24670477, and to an aecountam (1.25) can be legally different 

11 .2 
OUTPUT FORMATT ING 
from ( 1.2467) and totally different from 1.25 (in financia.l documents, parentheses 
arc sometimes used to indicate losses, that is, negative vaJues). As programmers, 
we aim at making our output as clear and as close as possible to the expectations 
of the "consumers" of our program. Output streams (ostreams) provide a variety 
of ways for fonnauing the Outplll of built-in types. For user-defmed types, it is up 
to the programmer to define suitable « operations. 
TIlere seems to be an infinite number of details, refinements, and options for 
output and quite a few for input. Examples are the character used for the decimaJ 
point (usually dot or comma), the way to output monetary vaJues, a way to rep-
resent true as the word true (or vrai or sandt) rather than the number 1 when 
output, ways to deal with non-ASCII character sets (such as Unicode), and a way 
to limit the number of characters read into a string. These facilities tend to be un' 
interesting until you need them, so we'll leave their description to manuals and 
speciaJized works such as Langer, Standard C++ lOS/reams at/ll Lomks; Chapter 21 
and Appendix 0 of 171.(: C++ Programming Language by Stroustrup; and §22 and 
§27 of the ISO C++ standard. Here we'll prescot the most frequently useful fea-
tUfes and a few general concepts. 
11.2.1 Integer output 
Integer values can be output as octaJ (the base-S number system), decimal (our 
lISUaJ base-IO number system), and hexadecimal (the base-l 6 number system). lf 
you don't know about these systems, read §A.1.2.l before proceeding here. Most 
output uses decimaJ. HexadecimaJ is popular for oucputting hardware-related in-
fomlatioll. -nle reason is that a hexadecimal digit exactly represents a 4-bit vaJue. 
"Ilms, two hexadecimal digits can be used to present the value of an S-bit byte, 
four hexadecimal digits give the value of 2 bytes (that's often a half word), and 
eight hexadecimal digits c...n present the vaJue of 4 bytes (that's often the size of a 
word or a register). When C++'s ancestor C was first designed (in the 1970s), 
octal was popular for representing bit pattents, but now it's rarely used. 
We can specify the OLitput (decimal) value 1234 to be decimal, hexadecimaJ 
(often called "hex"), and octaJ: 
coul « 1234 « "\((decimal)\n" 
« hex« 1234 « "\t(hexadecimal)\n" 
«
oct « 1234 « "\((octal)\n"; 
"Ille '\I' character is "tab" (shon for "tabulation character"). This prints 
1234 
(decimal) 
4d2 
(hexadecimal) 
2322 
(octal) 
377 

378 
CHAPTER 11 • CUSTOMIZING INPUT AND OUTPUT 
The notations « hex and «oct do not output values. Instead, « hex informs 
the stream that any further imeger values should be displayed in hexadecimal 
and « oel informs the stream that any further integer values should be dis-
played in octal. For example: 
coul « 1234« '\1' «
hex « 1234 « '\1' «
oct « 1234 « '\n'; 
coul « 1234 « '\n'; 
lithe oclal base is still in effect 
1234 
4d2 
2322 
2322 
/I integers will conlinue to show as octal until changed 
Note that the last Outpul is OCtal; that is, oct, hex, and dec (for decimal) persist 
("'stick," "arc sticky") - they apply to every imegcr value output umil we tell the 
stream otherwise. Tenns such as hex and oct that arc used to change the behav-
ior of a SlJ'cam arc called /f/aniplllaJoYJ. 
TRY TH IS 
Output your birth year in decimal, hexadecimal, and octal form. Label each 
value. Line up your output in columns using the tab character. Now output 
your age. 
Seeing values of a base different from 10 can often be confusing. For example, un-
less we tell you otherwise, you'll assume that 11 represents the (decimal) number 
II , rather than 9 (11 in octal) or 17 (11 in hexadecimal). To alleviate such problems, 
we can ask the oslream to show the base of each imeger primed. For example: 
coul « 1234 « '\1' «
hex «
1234 « '\t' «oct« 1234 « '\n'i 
cout« showbase« dec; 
/I show bases 
cout « 1234 « '\1' « hex «
1234 « '\1'« oct « 1234 « '\n'i 
111is prints 
1234 
4d2 
2322 
1234 
Ox4d2 02322 
So, decimal numbers have no preflX, octal numbers have the preflX 0, and hexa-
decimal values have the preflX Ox (or OX). This is cxactly the notation for integer 
literals in C++ source code. For example: 

11.2 
O U TPUT FO RMATTING 
coul « 1234 «
'\1' « Ox4d2« '\1' « 02322« '\n'; 
In decimal form, this will prim 
1234 
1234 
1234 
As you might have noticed, showbase pcrsislS, just likc oel and hex. l11c manip· 
ulator noshowbase rcverscs the action of showbase, reverting to thc default, 
which shows each numbcr without its base. 
In summary, thc integcr Olltput manipulators arc: 
Inleger oulpul manipulalions 
od 
dec 
he< 
showbase 
noshowbase 
use base-a (octal) notation 
use base-l 0 (decimal) nalalion 
use base-16 (hexadecimal) notation 
prefix 0 for octal and 0)( for hexadecimal 
don't use prefixes 
11.2.2 Integer inpul 
By dcfau lt, » assumes that numbcrs use thc decimal notation, but you can tell it 
to read hexadccimal or octal integers: 
inl a ; 
inl b; 
inl C; 
inl d; 
cin »a» hex » b » ocl » c» dj 
coul « a« '\1' « b « '\1' «c« '\1' «
d « '\n'; 
If you type in 
1234 
4d2 
2322 
2322 
this will prim 
1234 
1234 
1234 
1234 
Note that this implies that Oel, dec, and hex "stick" for inpm, just as they do for 
output. 
379 

CHAPTER II • CUSTOM IZING INPU T AND OUTPUT 
TRY THIS 
Complete the code fragment above to make it into a program. Try the sug-
gested input; then type in 
1234 
1234 
1234 
1234 
Explain the results. Try other inputs to see what happens. 
You can get » to accept and correctly interpret the 0 and Ox prefixes. To do that, 
you "unsct" all tlle defaults. For example: 
cin.unsetf(ios: :dec); /I don'l assume decimal (so that Ox can mean hex) 
cin.unsetf(ios: :oct); II don't assume octal (so that 12 can mean twelve) 
cin.unsetf(ios:: hex); II dan', assume hexadecimal (so that 12 can mean twelve) 
'1le stream member function unselfO clears the flag (or flags) given as argument. 
Now, if yOLi write 
cin »a» b» c » d; 
and clller 
1234 
Ox4d2 02322 02322 
you gCl 
1234 
1234 
1234 
1234 
11 .2.3 Floating-point output 
If you deal directly with hardware, you'll need hexadecimal (or possibly octal) 
notation. Similarly, if you deal with scientific computation, you must deal with 
the fannalling of floating-point values. TIley arc h,mdled using ioslream manipu-
lators in a l11aJ1I1er very si..m.i.lar to that of decimal values. For example: 
coul « 1234.56789« "\I\I(general)\n" 
II , ,\, to line up columns 
«
fixed« 1234.56789« "\I(fixed)\n" 
«scientific « 1234.56789« "\I(scientific)\n"; 
This prints 

11 .2 
OUTPUT FO RMATTING 
1234.57 
1234.567890 
1.234568e+003 
(general) 
(fixed) 
(scientific) 
The manipulators fixed and scie ntific are used to select floating·point formats. 
Curiously. the standard library doesn't have a general manipuialOr to give the 
default format. However, we ean define one, as we did in s td ~ l ib_facilities.h . 
"111is does require knowledge of the inner workings of the ioslream library: 
inline ios_base& general(ios_base& b) 
/I to complement fixed and scientific 
/I clear all floating-point format flags 
( 
b.self(ios_base: : fmHlags(O). ios_base : : floalfield)i 
return bi 
) 
Now, we c:m write 
cout « 1234.56789 « '\1' 
«fixed « 1234.56789 « '\I' 
«scientific« 1234.56789« '\n'; 
coul « 1234.56789« '\n'i 
cout « general «
1234.56789« '\1' 
«
fixed « 1234.56789 « '\t' 
«scientific « 1234.56789« '\n'i 
' 1,is prints 
II flo.lting format "sticks" 
/I warning: general isn't standard 
1234.57 
1234.567890 1.234568e+003 
1.234568e+003 
/I scientific manipulator "sticks~ 
1.234568e+003 
1234.57 
1234.567890 
In summalY, the basic floating-point output-fOnnalung manipulators are: 
Floating-point formats 
fixed 
scientific 
general 
usc fixed-point notation 
usc mantissa and exponent notation; the mantissa is always in the 11 :10) 
range; that is, there is a single nonzero digit before Ihe decimal point 
choose fixed or scientific to give the numerically most accura1e 
representation, within Ihe precision of general. The general format is 
1he default, but to explicitly set it you need a definition of general(). 
381 

382 
CHAPTER 11 
• CUSTOMIZING INPUT AND OUTPUT 
11.2.4 Precision 
By default, a floating.point value is primed using six lotal digits using the general 
format. The most appropriate formal is chosen and the number is rounded to 
give the best approximation that can be printed using only six digits (the default 
precision for the general form). For example: 
1234.567 prints as 1234.S7 
1.2345678 prints as 1.23457 
The rounding rule is the usual 415 rule: 0 to 4 round down and 5 to 9 round up. 
Note thal floacing-point fannauing applies only to floating-point numbers, so 
1234567 prims as 1234567 (because it's an integer) 
1234567.0 prints as 1.23457e+OO6 
In the latler case, the oslream determines that 1234567.0 (.;"lllnO( be printed using 
the fixed fonnat using only six digits and switches to scienlific formallO preserve 
the most accurate representation. Basically the general format chooses between 
scientific and fixed fonnats lO present the user with the most accurate represen-
tation of a floating-point value within the precision of the general format, which 
defaults at SL" total digits. 
TRYTHIS 
Write some code LO print the number 1234567.89 three times, flrst using 
general, then fixed , then scientifi c. Which output fonn presents the user 
with the most accurate representation? Explain why. 
A programmer can set the precision using the manipulalOr setprecision(). 
For example: 
coul « 1234.56789« '\(' 
«
fixed «1234.56789 « '\I' 
«
scientific « 1234.56789 « '\n'i 
eoul « general « setprecision(5) 
«
1234.56789« '\1' 
«
fixed «
1234.56789 « '\t' 
«
scientific « 1234.56789« '\n'; 
cout « general« selprecision(8) 
«
1234.56789« '\1' 
«
fixed «
1234.56789« '\1' 
«
scienlific « 1234_56789« '\n'; 

11 .2 
OUTPUT FORMATTING 
111is prints (note the rounding) 
1234.57 
1234.567890 1.234568e+OO3 
1234.61234.56789 
1.23457e+OO3 
1234.5679 
1234.56789000 
1.23456789e+OO3 
~nl e precision is dcfined as: 
Floating·point precision 
general 
scientific 
fixed 
precision is the 10lai number of digils 
precision is the number of digits after the decimal point 
precision is the number of digits after the decimal point 
Use the default (general fonnat with precision 6) unless thcre is a rcason not to. 
TIle usual reason nOl to is "Because we need greater accuracy of the output." 
11.2.5 Fields 
Using scientific and flXcd formats, a programmer can control exactly how much 
spacc a valuc takes up on outpul. That's dearly useful for printing tables, etc. 
111C cquivalent mechanism for il1leger valucs is called.fie/ds. You can specify ex-
actly how maIly character positions an integer vaJue or string value \vill occupy 
using the "set field widtll" manipulator setw(). For eXillnple: 
cout « 123456 
/I no field used 
« '1'« setw(4)« 123456« 'I' 
1/123456 doesn't fit in a 4-char field 
«setw(8)« 123456« 'I' 
1/ set field width 10 8 
«123456« "!\n"; 
1/ field sizes don't stick 
~nl is prints 
12345611234561 12345611234561 
Note first the twO spaces before the third occurrence of 123456. 111a\'s what we 
would expect for a six-digit number in an eight-character ficld. However, 123456 
did not get truncated to fit into to a four-character ficld. \oVhy IlOl? 112341 or 134561 
might be considered plausible outputs for the four-character ficld. However, that 
would have completely changed the vaJue printed without any warning to the 
poor reader that something had gone wrong. 1ne ostream doesn't do that; in-
stead it breaks the output fonnat. Bad formaning is almost always prefcrable to 
"'bad output data." in lhe most common uses of fields (such as printing out a 
table), lhe "overflow" is visually very noticcable, so t.hat it can be corrected. 
383 

384 
CHAPTER 11 
• CUSTOMIZING INP UT AND OUTPUT 
Fields can also be used for £1oaling-point numbers and strings. For example: 
cout « 12345 «'1'« setw(4) «
11345 « 'I' 
«setw(8) «
12345« 'I' «
12345 « "!\n"; 
coul « 1234.5 «'1'« setw(4)« 1234.5« 'I' 
«setw(8) « 1234.5« '1' « 1234.5« "1\11"; 
cout « "asdfg" « '1'« selw(4) « "asdfg" « 'I' 
«setw(S) « "asdfg" « '1' « "asdfg" « "1\0"; 
This prints 
123451123451 123451123451 
' 234.51' 234.51 1234.511234.51 
asdfslasdfgl asdfglasdfgl 
Note that the field width >;doesn't stick,'" In all three cases, the first and the last 
values are printed in the default "as many characters as it takes" fOnJl a l. In other 
words, unless you set the field width immediately before an output operation, the 
notion of "field" is not used. 
TRY THIS 
Make a simple table including the last name, frrst name, telephone number, 
and email address for yourself and at least five of your friends. Experiment 
,vith different field \vidths until you are satisfied that the table is well presented. 
11.3 File opening and positioning 
As seen from C++, a file is an abstraction of what the operating system provides. As 
described in §1O.3, a file is simply a sequence of bytes numbered rrom 0 upward: 
0: 
I: 2: 
L.......L...L....I.I ~::::::::::::::::.LI --'-L....L-.J 
111e question is how we access those bytes. Using iostreams, this is largely deter· 
mined when we open a file and associate a stream with it. The properties of a 
Stream determine what operations we can perfonn after opening the me, and their 
meaning. 111e simplest example or this is that if we open an islream ror a me, we 
C<l.n read from the file, whereas ir we open a me with an ostream, we call write to it. 

II .) 
FILE OPENING AND POSITIONING 
11 .3.1 File open modes 
YOll can open a file in one of several modes. By default, an ifstream opens its file 
for reading and an of stream opens its file for writing. 111at takes care of most 
common needs. However, you can choose between several alternatives: 
Filestream open modes 
ios_base: :app 
ios_base: :ate 
ios_base: :binary 
ios_base: :in 
ios_base: :out 
ios_base: :Irunc 
append (i.e., add to the end of the file) 
Hat end~ (open and seek to end) 
binary mode -
beware of system-specific behavior 
for reading 
for writing 
truncate fi le to O-Iength 
A file mode is optionally specified after the name of the file. For example: 
of sire am ofl(namcl)j 
/I defaults to ios_base::out 
ifstream if1 (name2}j 
/I defaults to ios_base::in 
of sire am ofs(name, ios_base: :app)i 
II of streams are by default oul 
fstream fs("myfile", ios_base: :inlios_base: :oul) j 
II both in and out 
The I in that last example is the "bitwise or" operator (§A.5.5) that can be used to 
combine modes as shown. "n le app option is popular for writing log files where 
you always add to the end. 
In each case, the exact efTect of opening a file may depend on the opcnlting 
system, and if an operating system cannot honor a request to open a file in a cer-
tain way, the result will be a stream that is not in the goodO state: 
if (!fs) 
/I oops: we couldn't open thai file thaI way 
llle most common reason for a failure to open a me for reading is that the file 
doesn't exist (at least not with the name we used): 
ifstream ifs("redungs"); 
if (!ifs) 
II error: c..1n't open "readings" for reading 
In this case, we guess lhat a spelling error might be the problem. 
385 

386 
CHAPTER 11 • CUSTOMIZING INPUT AND OU TP UT 
Note that typically, an operating system will create a new file if you try to 
open a nonexistent file for outPUL, but (fortunately) not if you ul ' to open a nOIl-
existent file for input: 
of stream ofs("no-such.file"); 
o f sire am ifs("no-file·of·this·name ")i 
/I create new file called no-such-file 
/I error: iis will be nOI be goodO 
11 .3.2 Binary files 
In memory, we can represent the number 123 as an integer value or as a slring 
value. For example: 
int n = 123; 
string s = "123"; 
In the first case, 123 is stored as a (binary) number in an amoulll of memory that 
is the same as for all other ints (4 bytes, that is, 32 bits, on a PC). Had we chosen 
the value 12345 instead, the same 4 bytes would have been used. In the second 
case, 123 is SLQred as a string of three characters. Had we chosen the string value 
"12345" it would have used five characters (plus the fixed overhead for managing 
a string). We could illustrate this like this (using the ordinary decimal and char-
acter representation, rather than the bi.nary representation actually used within 
the computer): 
123 as characters: 1 12131' I I I' I' II I 
12345 as characters: 1 121314151' 1' 1 I I 
123 as binary: 
123 
I 
I 
12345 as binary: 
12345 I 
I 
When we usc a character representation. we must use some character to repre-
sent the end of a number in memory. just as we do on paper: 123456 is one nUIll-
ber and 123 456 are nvo numbers. On "paper," we use the space character to 
represent. the end of the number. In memory. we could do the same: 
123456" ,hmc<m' l' I 2 131 4 I 51 ' I I' I 
123<156",hmc<"" 1' 12131 141SI' 1 I 
"nle distinction between storing rlXed-sized binary representation (e.g., an int) 
and variable-sized character string representation (e.g., a siring) also occurs in 
files. By default, ioslreams deal with character representations; that is, an islream 
reads a sequence of characters and tums it into an object of lhe desired type. An 

11 .3 
FILE OPENING ANO POSITIONING 
ostream takes an object of a specified type and transfonns it into a sequence of 
characters which it writes alit. However, it is possible to request istream and 
oslream to simply copy bytes to and from files. 'l113t's called bliltlry /10 and is re-
quested by opening a me with the mode ios_base: : binary. Here is an example 
that reads and writes binary files of integers. 1l1e key lines that specificaJly deal 
with "binary" arc explained below: 
int mainO 
( 
} 
/I open an istream for binary input from a fi le: 
caul « "Please enler input file name\n"; 
Siring name: 
tin » name; 
ifslream ifs(name.c_slr(),ios_base: :binary); 
/I note: stream mode 
II ~binaryN tclls the stream nOI to Iry anything clever with the bytes 
if (! ifs) error("can't open input file n, name); 
/I open an ostream for binary output 10 a file: 
cout « "Please enler output file name\n": 
tin » name: 
of sire am ofs(name,c_strO,ios_base: :binary): 
II nole: stream mode 
/I "binary" tells the stream not 10 try anything clever with the bytes 
if (lofs) error("can'l open output file ",name): 
veclor<int> Vi 
/I re.,d from binary file: 
int ii 
wh ile (ifs. read (as _bytes( i) ,sizeof(i nt))) 
v.push_back(i): 
/I ... do something with v . 
II wrilC to binary file: 
for(inl i=O: i<v.size(); ++i) 
ofs. wrj le(as_ bytes( vi ill, sizeof(int) : 
return 0; 
/I note: reading bytes 
/I note: writing bytes 
\-Ve open the files using ios_base: :binary as the stream mode: 
ifslream ifs(name.c_slr(), ios_base: :binary); 
of stream ofs(name.c_slrO, ios_base: :binary); 
387 

388 
C HAPTER 11 
• CU STO M IZING INP UT AND OU TPU T 
In both cases, we chose the trickier, but often more compact, binary representa-
tion. When we move from character-oriented 110 to binary I/O we give up our 
usual » and « operators. Those operators specifically turn values into charac-
ter sequences using the default conventions (e.g., the string "asdf" Ulrns into the 
characters a, 5, d, f and the imcgcr 123 turns into the characters 1, 2, 3). If we 
wanted thal, we wouldn't need to say binary - the default would suffice. We usc 
binary only if we (or someone else) thought that we somehow could do bener 
than the default. We usc binary LO tell the stream not to try anything clever with 
the bytes. 
What "cleverness" might we do to an inl? TIle obvious is to store a 4-bytc inl 
in 4 bytes; that is, we can look at the represcntation of the int in memory (a se-
quence of 4 bytes) and transfer those bytes to the file_ Later, we can read those 
bytes back the same way and reassemble the int: 
ifs. read (as_bytes (i), sizeof(int) 
ofs. wri te(as_bytes( v[i» ,sizeof(i nt» 
/I note: reading bytes 
I/Ilote: writing bytes 
The ostream writeO and the istream readO bOlh take an address (supplied here 
by as_by teO) and a number of bytes (charaClers) which we obtained by using the 
operaLOr sizeof. l11at address should refer to the first byte of memory holding 
the value we want to read or write. For example, if we had an int with the value 
1234, we would get the 4 bytes (using hexadecimal notation) 00, 00, 04, d2: 
as bytes(i) 
i: 
00 
00 
.. 
d2 
The as_bytesO function is needed to get the address of the first byte of an objecl's 
representation. It can - using language facilities yet to be explained (§17.8 and 
§19.3) - be defined like this: 
template<class T> 
char* as_bytes(T& i) 
( 
II treat a T as a sequence of bytes 
void* addr = &i; 
/I get the address of the fi rst byte 
II of memory used to store the object 
return static_casl<char*>(addr); 
Illreal that memory as bytes 
The (unsafe) type conversion using static_cast is necessary to get to the "raw 
bytes" of a variable. The notion of addresses will be explored in some detail in 
Chapters 17 and 18. Here, we just show how to treat any object in memory as a 
sequence of bytes for the usc of readO and writeO. 

I 1.3 
FIL E OPENING AND POSrT10NING 
~Illi s binary 110 is messy, somewhat complic. ... ted, and error·prone. However, 
as programmers we don't always have the freedom to choose file formals, so oc-
casionally we must lise binary I/O simply because that's the format someone 
chose for the files we need 1"0 read or wrile. Altematively, there may be a good 
logical reason for choosing a non-character representation. A typical example is 
an image or a SOllnd file, for which there is no reasonable character representa-
tion: a phmob>T<lph or a piece of music is basically just a bag of bits. 
'Ille character 1/0 provided by default by the ioslream library is portable, 
human readable, and reasonably supported by the type system. Use it when you 
have a choice and don't mess with binary 110 unless you really have to. 
11 .3.3 Positioning in files 
Whenever you call, just read and write mes from the beginning to the end. 
'Ilmt's the easiest and least error-prone way. Many times, when you feel that you 
have to make a change to a file, the better solution is to produce a new file COIl-
taining the change. 
However, if you must, you can use positioning to select a specific place in a file 
for reading or writing. Basically, evely file that is open for reading has a "read/get 
position
n and evely fLle that is open for writing has a "write/put position": 
I\Jt position: 
2 
G CI position: 
0: 
I: 
A filc: 
-nlis c. ... n be used like this: 
fstream fs(name.c_str()); 
II open for input and output 
if (! fs) error("can't open ",name); 
fs.seekg(5); 
/I move reading position (g for "gen to 5 (the 6th character) 
char ch; 
fs»chi 
/I re.ld and increment reading position 
cout « "character 6 is"« ch « '(' « int(ch)« ")\n"; 
fs.seekp(1); /I move writing position (p for "pun to 1 
fS« 'Y'i 
1/ write and increment writing position 
Please be careful: there is next to no run-time error checking when you use posi-
tioning. In particular, it is undcfmcd what happens if you try 10 seek (using 
seckgO or seekp()) beyond the end of a file, and operating systems really do dif-
fer in what happens then. 
389 

390 
CHAPTER 11 
• CUSTOMIZ ING INPUT AND OUTPUT 
11.4 String streams 
You can usc a string as the source of an istream or lhe target for an oslream. An 
istream that reads from a string is called an istringslream and an ostream that 
stores characters written to it in a string is called an oslringstream. For example, 
an istringstream is useful for extracting numeric values from a siring: 
double stUo_double(string 5) 
1/ if possible, convert characters in s to floating.point value 
{ 
iSlringstream isIs); 
double d; 
/I make a stream so that we can read (rom s 
is »
d ; 
if (!is) error("double format error: ",5); 
return d; 
) 
double dl = slr_to_doublc("12.4"); 
double d2 = str_to_double("1.34e-3"); 
/I testing 
double dJ = str_lo_double( tltwelve point three"); 
/I will call error() 
If we try to read beyond the end of a stringstream's string, me stringstream will 
go into eofO state. This means that we can use "thc usual input loop" for a 
stringstream; a string stream really is a kind of istream. 
Conversely, an ostringstream can be useful for formatting output for a sys-
tem that requires a simple string argument, such as a CUI system (see § 16.5). 
For example: 
void my_code(string label, Temperature temp) 
{ 
) 
II . 
oslringstream os; 
/I stream for composing a message 
os « setw(8) « label « ": " 
«
fixed «setprecision(5) « temp.temp « temp.unit; 
someobjecl.d isplay{Poi nt(l 00, 1 (0), os. st rO. c_str(»; 
II ... 
"I11e strO member function of osltingstream retums me string composed by out-
put operations to an ostringstream. The c_strO is a member function of siring 
that retums a C-style string as required by many system interfaces. 
TIle stringstreams are generally used whcn we want 10 separate actual 1/0 
from processing. For example, a string argument for str_to_doubleO will usually 
oribrinale in a file (e.g., a web log) or from a keyboard. Similarly, the message we 

11 .5 
LIN E-ORIENTED INPUT 
composed in my_codeO will eventually end up wriuen to an area of a screen. For 
example, in § 11.7, we use a stringstream LO filter undesirable characters out of 
our input. Thus, stringstreams can be seen as a mechanism for tailoring 110 to 
special needs and tastes. 
A simple usc of an ostream is to construct strings by concatenation. For 
example: 
int seq_no = gel_nexCnumber(); 
ostringstream name; 
name« "myfile" «seq_no; 
oislrea m logH le( name. sh O.c_sl rO); 
II get the number of a log fi Ie 
lIe.g., m)'filel7 
II e.g., open myfilc17 
Usually, we initialize an istringstream with a string and then read the characters 
from I.hat string using input operations. Conversely, we typically initialize an 
oSlringslream 1.0 the empty string and then fill it using output operations. '11cre 
is a more direct way of accessing characters in a stringstream that is sometimes 
useful: ss.slrO returns a copy of 5S'S string, and ss.str(s) sets in ss's string to a 
copy of s. § 11.7 shows an example where 5s.slr(s) is essential. 
11.5 line-oriented input 
A » operator reads into objects of a given type according to that type's standard 
formal. For example, when reading i.nto an int, » will read until it encounters 
something that's not a digit, and when reading into a siring, » will read until il. 
encOllnters whilespace. -nle standard library istream library also provides facili-
ties for reading individual dIameters and whole lines. Consider: 
string name; 
dn» name; 
II input: Dennis Ritchie 
cout « name « '\n'; 
II output: Dennis 
' Vhat if we wanted to read everything on that line at once and decide how to for-
mat it later? ' 1mt could be done using the function getlineO. For example: 
string name; 
getline(dn,name); 
coul « name« '\n'; 
II input: Dennis Ritchie 
II output: Dennis Ritchie 
Now we have tbe whole line. Why would we waill that? A good answer would 
be <-Because we want to do something that can't be done by » ." Often, the an-
swer is a poor one: "Bec.1use the user typed a whole line." If that's the best you 
can think of, stick to » , because once yOll have the line entered, YOll usually 
have 1.0 parse it somehow. For example: 
391 

392 
CHAPTER 11 
• CUSTOMIZ ING INP UT AND OUTPUT 
string firsCnamej 
string second_name; 
stringstream ss(name)i 
ss» firsCnamej 
ss»second_namej 
/I input Dennis 
/I input Ritchie 
Reading directly into firsCname and second_name would have been simpler. 
One conmlOn reason for wanting to read a whole Jine is that the definition of 
whitcspacc isn't always appropriate. Sometimes, we wanl to consider a newline 
as different from other whitespace characters. For example, a text communica-
tion with a game might consider a line a semence, rather than relying on conven-
tional punctuation: 
go left until you see a picture on the wall to your right 
remove the picture and open the door behind it. take the bag from there 
In that case, we'd first read a whole line and then extract individual words from thaI. 
string command; 
get Ii n e( cin, command); 
/I read the line 
stringstream ss(command)i 
vector<string> words; 
string s; 
while (ss»s) words.push_back(s); 
II extract the individual words 
On the Olher hand, had we had a choice, we would most likely have preferred to 
rely on some proper punctuation rather than a line break. 
11.6 Character classification 
Usually, we read integers, floating-point numbers, words, etc. as defined by for-
mat conventions. However, we can - and sometimes must - go down a level of 
abstraction and read individual characters. That's more work, but when we read 
individual characters, we have full control over what we are doing. Consider wk-
enizing an expression (§7.8.2). For example, we want 1+4-x<=y/z· s to be sepa-
rated into the eleven tokens 
1+4 -x<=y / z·S 
Wc could usc » to read the numbers, but trying to rcad the identifiers as strings 
would cause x<=y to be read as one string (since < and = arc not whitespace char-

11.f> 
(f-IARACTER CLASS IFICATION 
actcrs) and z* to be read as one suing (since * isn't a whitespace character either). 
Instead. we could write 
char ch; 
while (cin.get(ch» { 
if (isspace(ch» ( 
II if ch is whitcspacc 
II do nothing (i.c., skip whitespacel 
} 
if (isdigit(ch» { 
II read a number 
clse if (isalpha(ch)) ( 
II read an identifier 
} 
else { 
II deal with operators 
} 
The islream: :gelO function reads a single character into its argument. It docs not 
skip whitespace. Like » , getO returns a reference to its istream so that we can 
test its state. 
When we read individual characters, we usually want to classify them: Is tills 
character a digit? Is this character uppercase? And so forth. There is a set of stan-
dard libra!"y functions for that: 
Character classification 
isspace(c) 
isalpha(c) 
isdigit(c) 
isxdigit(c) 
isupper(c) 
islower(c) 
isalnum(c) 
iscnt,l(c) 
ispunct(c) 
isprint(c) 
isgraph(c) 
Is c whitcspace (" , '\I', '\n', etc.)? 
Is c a letter ('a' . .'z', 'A' .. 'l ') (note: not '_')? 
Is c a decimal digit ('O' . .'9')? 
Is c a hexadecimal digit (decimal digit or 'a' . .'f' or 'A' . .'f')? 
Is c an uppercase letterf 
Is c a lowercase letter! 
Is c a letter or a decimal digit? 
Is c a control character (ASCIl 0 . .31 and 12l)? 
Is c not a letter, digit, whilespace, or invisible control character? 
Is c printable (ASCII ' ' . .'-'J? 
Is c isalphaOlisdigitOlispunclO (note: not space)? 
393 

394 
CHAPTER 11 
• CUSTOMIZIN G IN PUT AND OUTP UT 
Note the way that classifications can be combined using the "or" operator (I). For 
example, isalnum(c) means isalpha(c)lisdigit(c); that is, "Is c either a letter or a 
digit?" 
In addition, the standard library provides two useful functions for getting rid 
of case differences: 
Character case 
toupper(c) 
tolower(c) 
c or e's uppercase equivalent 
c or CiS lowercase equivalent 
'111CSC arc useful when YOLI want to ignore case differences. For example, in input 
from a user Right, right, and rigHT mostlikcly mean lhc same thing (rigHT most 
likely being the result of an unfortunate hit on the Caps Lock key). After apply-
ing tolowerO to each character in each of those strings, we get right for each. We 
ca.1l do that fo r an arbitrary string: 
void tolower(string& s) 
{ 
/I put s into lower case 
for (int i=O; ks.lengthO; ++i) s[i] = tolower(s[iJ); 
V\'e use pass-by-rererence (§8.5.5) to aClllally change the string. Had we wanted 
to keep the old string we could have written a runction to make a lowercase copy. 
Prerer tolowerO to toupperO because that works belter ror text in some natural 
languages, sllch as German, where nOl every lowercase character has an upper-
c"lse equivalent. 
11.7 Using nonstandard separators 
~nli s section provides a semi·realistic example or the use or iostreams to solve a 
real problem. VV-hen we read strings, words are by derault separated by white-
space. Unrortunately, istream doesn't ofTer a facility for us to define what charac-
ters make up whitespace or in some other way directly change how » reads a 
string. So, what do we do if we need another definition of whitespace? Consider 
the example rrom §4.6.3 where we read in "words" and compared them. 1110se 
words were whitcspace-separated, so if we read 
As planned, the guests arrived; then, 
We would get the "words" 

11. 7 
US ING NONSTAN DARD SE PA RATORS 
As 
planned, 
the 
guests 
arrived; 
then, 
TIlis is not what we'd find in a dictionary: "planned," and "anived;" are not words. 
TIley arc words plus distracting and irrelevam punctuation charncters. For most 
purposes we must treat punctuation just like whitespacc. How might we get rid of 
such punctuation? \o\'e could read charncters, remove the punctuation characters -
or rum them into whitcsp:1ce - and then read the "cleaned-up" input again: 
siring linc; 
gelline(cin,line); 
II read inlo line 
for (int i=O; i<iine.sizeO; ++i) /I replace each puncluation character 
by a space 
switch(line[i)) ( 
case 'i' : case '.': case ',': case 'l ': case '1': 
line[i) =' '; 
stringslream ss(line); 
veclor<string> VS; 
string word; 
while (ss» word) 
vs.push_back(word); 
/I make an iSircam ss reading from linc 
/I rcad words withoul puncluation characters 
Using that to read the line we gCt the desired 
As 
planned 
the 
guests 
arrived 
then 
Unfortunately, the code above is messy and rather special-purpose. What would 
we do if we had another definition of punctuation? Let'S provide a more general 
ru1(1 lIseful way of removing unwanted characters from an input stream. What 
would that be? What would we like our user code to look like? How about 
395 

3% 
(HAPTE R 11 
• CUSTOMIZ ING I N PUT AN D OUTPUT 
ps.whilespace("j :,. "); 
/I treat semicolon, colon. comma, and dot as .... ..,iICSp.1CC 
string word; 
while (ps»word) vs.push_back(wordl j 
How would we deflne a stream that would work like ps? The basic idea is to read 
words from an ordinary input stream and then treat the user-specified "white-
space" characters as whitespacc; that is, we do not give "whitcspacc" characters 
to the user, we just lise them to separate words. For example, 
as. not 
should be the two words 
as 
nol 
We can define a class to do that for us. It must gel characters from all istream and 
have a » opcraLOr that works just like iSlream's except that we can tell it which 
characters it should consider La be whitcspacc. For simplicity, we will not provide 
a way of treating existing whitcspacc characters (space, newline, etc.) as non-
whitespacc; we'll just allow a uscr to speciry additional "whitcspace
n characters_ 
Nor will wc provide a way to completely remove the designated charactcrs rrom 
thc strcam; as berore, we will just tum them into whitespacc_ Let's call that class 
Punet_stream: 
class PuncLstream ( 
II like an islream, but the user can add to 
II the sct of whitespace characters 
public: 
Punet_stream<istream& is) 
: source{is), sensitive(true) { } 
void whitespace(const string& s) 
{white = s; } 
II make s the whitcspace set 
void add_white(ehar c) { white += c; } 
II add to the whitcspace set 
bool is_whitespaee(ehar eli 
II is c in the whitespacc sct? 
void case_sensitive(bool b) {sensitive = b; } 
bool is_ease_sensitiveO { return sensitivej } 
Punct_stream& operator»(string& s); 
ol'erator boolO; 

11. 7 
USING NO NSTA N DARD SEPARATORS 
private: 
} ; 
iSlream& source; 
istringstream buffer; 
siring white; 
bool sensitive; 
/I character source 
/I we let buffer do our formtllling 
II characters considered "whitespace" 
/I is the stream case-sensitive? 
rnle basic idea is - just as in the example above - to read a line at a time from 
the iSlream, convert "whitespace" characters into spaces, and then use the 
slringslream to do formatting. In addition to dealing with user-defined white-
space. we have given Punet_stream a related facility: if we ask it to, using 
case_sensitiveO, it can convert case-sensitive input into non-case-sensitive inpul. 
For example, if we ask, we can get a PUllct_stream to read 
Man biles dog! 
m," 
bites 
dog 
Punecstream's constructor takes the istream to be used as a character source 
and gives it the local name source. TIle constructor also defaults the stream to 
the usual case-sensitive behavior. We can make a Punet_stream that reads from 
cin regarding semicolon, colon, and dot as whilcspace, and that turns all charac-
ters into lower case: 
Punet_stream ps(cin)i 
ps,whilespace("; :_"); 
ps, case_se nsil ive(false); 
/I ps reads from cin 
/I semicolon, colon, and dot are also whitespace 
II not case-sensitive 
Obviollsly, the most interesting operation is the input operator » . It is also by 
far the IllOSt difficult 10 define, O ur general strategy is to read a whole line from 
the istream into a string (called line). We then convert all of "our" whitespace 
characters to the space character (' '). That done, we put the line into the 
istringslream G.'dled buffer. Now we can usc the usual whitespace-separating » 
to read from burrer. The code looks a bit more complicated than this bec."1usc we 
simply try reading from the buffer and try to fill it only when we find it cmpty: 
Puncl_stream& Punet_stream: :operator» (string& s) 
{ 
397 

3 .. 
) 
(HAPTER 11 • CUSTOMIZING IN PUT AND OUTPUT 
while (!(buffer>>s» ( 
/I try 10 read from buffer 
) 
if <buffer.badO II !source.gaodO> return -this; 
buffer.clearO; 
string line: 
gelline(source,line): II get a line from source 
/I do character replacement as needed: 
for (int i =0; kline.size(); ++i) 
if (is_whilespace(line[ij)) 
line[iJ= ' '; 
else if (!sensitive) 
1110 space 
line[i) = lolower(lineIiJ); /I to lower case 
buffer.str(lin e); 
II put SIring into slrC3m 
return -this; 
Let's consider this bit by bie Consider first the somewhat unusual 
while (!(buffer»s» { 
If there arc characters in the istringstream called buffer the read buffer»s will 
work, and s will receive a "whitcspacc"-scparatcd word; then there is nothing 
morc to do. '1-131 will happen as long as there are characters in buffer for us to 
read. However, when buffer» s fails - that is, if !(buffer»s) - we lTlust replen-
ish buffer from source. Note that the buffer»s read is in a loop; after we have 
tried to replenished buffer, we need to try another read, so we get 
while (!(bufier»s)) ( 
/I try to read from buffer 
) 
if (buffer.badO II !source.goodOl return · this; 
buffer.dearO; 
/I replenish buffer 
If buffer is badO or the source has a problem, we give up; othenvise, we clear 
buffer and try again. We need to clear buffer because we get into that "replenish 
loop" only if a read failed, typically because we hit eoru for buffer; that is, there 
were no more characters in buffer for us to read. Dealing with stream state is al-
ways messy and it is often the source of subtle errors thai require tedious debug-
ging. Fortunately the rest of the replenish loop is pretty straightforward: 

11 .7 
USING NONS TA NDA RD SEPA RATORS 
string line; 
getline(source,linc); /I get a line from source 
/I do character replacement as needed: 
fo r (int i =0; i<line.sizeO; ++il 
if (is_whitespace(line[iJ)) 
line[iJ= ' '; 
/I to space 
else if (!sensitive) 
line[il = tolower(line[iJ); II to lower case 
buffer.str(line); 
/I put string into stream 
'Ne rcad a line into buffer. Then we look at each character of that line to sec if we 
need to change it. The is_whitespaceO function is a member of PuncCstream, 
which we'U define later. TIle tolowerO function is a standard library function 
doing the obvious, such as turning A into a (sec §1 1.6). 
Once we have a properly processed line, we need to gel it intO our istring-
stream. 111at's what buffer.str(line) does; it ean be read as "Set the stringstream 
buffer's string LO line." 
Note that we "forgot" to ICSt the state of source after reading from it using 
getlineO. We don't need to because we will eventually reach the !source.goodO 
test at Lhe tOp of the loop. 
As ever, we rcturn a reference to the stream itself, *'his, as the result of » ; 
see §17.1O. 
Testing for whitespace is easy; we just compare a character to each character 
of the string that holds our whitespace set: 
bool Punct_stream: :is_whitespace(char c) 
( 
) 
for (int i = 0; i<white.size(); ++i) if (c==white[iJ) return true; 
return false; 
Remember that we left the istringstream to deal with the uSLIal whitespace char· 
acters (e.g., newline and space) in the usual way, so we don't need to do anything 
special about those. 
This leaves one mysterious function: 
PunCCSlream: :operator boolO 
( 
return !(source.fail() 11 source.bad()) && source.goodO; 
399 

400 
CHAPTER 11 • CU STOMIZING INP UT AND OU TPU T 
TIle conventional lise of an istrcam is to lCSllhc result of » . For example: 
while (ps»s) {'- .. . -' } 
That means that we need a way of looking at the result of ps>>s as a Boolean 
value. TIle result of ps»s is a PuncCstream, so we need a way of implicitly LUm-
ing a PuncCstream into a bool. "l1tat's what PuncCslream's operator boolO docs. 
A member function called operator boolO dcfmes a conversion to bool. In partic-
ular, it returns true if the operation on the PuncCstream succeeded. 
Now we can write our program. 
int mainO 
( 
) 
II given text input, produce a sorted list of all words in that text 
II ignore punctuation and case differences 
II eliminate duplicates from the output 
PuncCSlream ps(cin); 
ps.whitespace(" ; :,.?!()\"{}<>I&$@#"ioll-I-"); /I nOle \" means " in string 
ps. case _sensit ive(false); 
cout « "please e nter words\n"; 
veclor<string> vs; 
string word; 
while (ps»wordl vs.push_back(wordl; 
/I read words 
sort(vs.beginO,vs.endO); 
II sorl in lexicographical order 
for (int i=O; i<vs.size(); ++i) 
/I write dictionary 
if (i==O II vs(iJ!=vsli- 1J) cout « vsliJ «endl; 
1l1is will produce a properly sorted list of words from input. The (cs( 
if (i==O II vs[i] !=vs[i-l J) 
will suppress duplicates. Feed this program the input 
There are only two kinds of languages: languages that people complain 
about, and languages that people don't use. 
and it will outpul 
and ... 
complain 

11 .8 
AND THERE IS SO MUC H MORE 
don't 
languages 
of 
only 
people 
that 
there 
Iwo 
us. 
Why did we get don't and not dont? We len the single quote out of the white-
spaceO c."1I1. 
Caution: Punet_stream behaves like an istream in many important and useful 
ways, but it isn't really an istream. For example, we can't ask for its state using rd-
state(), eofO isn't defined, and we didn't bother providing a » t.hat reads integers. 
Importantly, we caIUlOt pass a Punet_stream to a function expecting an istream. 
Could we define a Punetj stream tllat really is an istream? We could, but we don't 
yet have the programming experience, the design concepts, and the language facil-
ities required to pull ofT that SlUm (if you - much later - want to return LO this 
problem, you have to look up stream buITers in an expen-Ievcl guide or manual). 
Did you find PuncCslream easy to read? Did you find the explanations easy 
LO follow? Do you think you could have written it yoursclP If you were a genuine 
novice a few days ago, the honest answer is likely to be "No, no, no!" or even 
""NO, no! Nooo!! - Are you crazy?" \Ve understand - and the answer to the last 
question/outburst is "No, atlcast we think not." TIle purpose of the example is 
-Ib show a somewhat realistic problem and solution 
1b show what can be achieved with relatively modest means 
1b provide an easy-to-use solution LO an apparently easy problem 
To illustrate the distinction between the interface and the implementation 
1"0 become a progra.mmer, you need to read code, and not just carefully polished 
solutions to educational problems. This is an example. In another few days or 
weeks, this will become easy for you to read, and YOll will be looking at ways to 
improve the solution. 
One way to think of this example is as equivalent to a teacher having dropped 
some genuine English slang into an English-for-beginners course to give a bit or 
color and enliven the proceedings. 
11.8 And there is so much more 
"11le details of I/O seem infinite. TIley probably are, since they arc limited only by 
human inventiveness and capriciousness. For example, we have not considered 
.. " 

40' 
CHAPTER 11 • CUSTOMIZING IN PUT AN D OUTPUT 
the complexity implied by naturaJlanguages. What is written as 12.35 in English 
will be conventionally rcprcsclllcd as 12,35 in most Olher European languages. 
Naturally, the C++ standard library provides facilities for dealing with that and 
many Olher natural-language-specific aspects of 1/0 . How do you write Chinese 
characters? How do you compare strings written using MaJayaJalll characters? 
111erc arc answers, but th ey are far beyond the scope of tills hook. If you need to 
know, look in more specialized or advanced books (such as Langer, Slll1uUml C++ 
IOStreanu mm Lomles, and Stroustrup, 'flte C++ Programming Lal1guage) and in li-
brary and system documentation. Look for locale; that's the tenn usually applied 
to facilities for dealing with nalural languagc differences. 
AnOlher source of complexity is buffering: the standard library ioslreams 
rely on a concept called streambuf. For advanced work - whether for perfonn· 
ance or functionality - with iostreams these istreambufs are unavoidable. If YOLI 
feel the need to define your own ioslreams or to lUne iostreams to new data 
sourceS/sinks, see C hapter 2 1 of 7M C++ Programming umguage by Stroustrup or 
your system documentation. 
When using C++, you may also encounter the C standard printfO/scanfO 
family of I/O functions. If you do, look them up in §27.6, §B. I 0.2, or in the excel· 
lent C textbook by KeOlighan and Ritchie ('The C Programming Language) or one of 
the innumerable sources on the web. Each language has its own 1/0 facilities; 
they all vary, most arc quirky, but most reflect (in various odd ways) the same 
fundamental concepts that we have presented in Chapters 10 and II. 
111e standard library 1/0 facilities arc summarized in Appendix B. 
TIle related topic of graphical user interfaces (G UIs) is described in Chap· 
ters 12-16. 
~ 
Drill 
1. Stan a program called Tescouipul.cpp. Declare an integer birth_year 
and assign it the year yOll were bam . 
2. Output your birth_year in decimal, hexadecimal, and octal fonn. 
3. Label each value with the name of the base used. 
4. Did you line up your output in columns using the tab character? If not, 
doil. 
5. Now output your age. 
6. Was there a problem? What happened? Fix your output to decimal. 
7. Go back to 2 and cause your output to show the base for each output. 
8. Try reading as octal, hexadecimal, etc.: 
cin » a >>ocl >> b » hex » c» d; 
cout « a « '\1'« b « '\1'« c « '\1'« d « '\n' ; 
Run this code with the input 

CHAPTER!! TE RM S 
1234 1234 12341234 
Explain U1C results. 
9. Writc somc code to print ule number 1234567.89 three times, fIrst using 
general, then fixed , then scientific forms. Which output form presents 
the user with ule most accurate representation? Explain why. 
10. Make a simple table including last name, fIrst name, telephone number, 
and email address for yourself and at least five of your friends. Expcri· 
ment with different field widths until you arc satisfied that the table is 
weU presented. 
Review 
1. Why is 110 tricky for a programmer? 
2. What docs the notation «
hex do? 
3. What arc hexadecimal numbers used for in computer science? "Vhy? 
4. Name some of the options you may want to implement for formatting in· 
teger output. 
5. \tVhat is a manipulator? 
6. What is the prefix for decimal? For octal? For hexadecimal? 
7. 'What is Ule default output fonnal for floating·point values? 
8. What is a field? 
9. Explain what setprecision() and setw() do. 
10. What is the purpose of file open modes? 
II. Which of the following manipulatOrs does not ;<stick": hex, scientific, 
setprecision, showbase, setw? 
12. What is the difference between character 110 and binary I/O? 
13. Cive an example of when it would probably be beneficial to use a binalY 
file instead of a text file. 
14. Give twO examples where a slringstream can be useful. 
15. What is a file position? 
16. What happens if you position a me position beyond lhe end of file? 
17. When would you prefer line·oriented input to type·specific input? 
18. What docs isalnum(c) do? 
Te rms 
binary 
character c1assific.'uion 
decimal 
file positioning 
fixed 
general 
hexadecimal 
irregularity 
line·oriented input 
manipulator 
nonstandard separator 
noshowbase 
OCtal 
output fonnatting 
regularity 
scientific 
setprecision 
showbase 
403 

CHAPTER 11 • CUSTOMIZING INPUT AND OUTPUT 
Exercises 
1. Write a program that reads a text me and converts its input to all lower 
case, producing a new file. 
2. Write a program that removes all vowels from a file ("disellwowcls"). For 
example, Once upon a time! becomes nc pn tm!. Surprisingly of tell, the 
result is still readable; try it on your friends. 
3. Write a program called multU nput.cpp that prompts the user to enter 
several integers in any combination of octal, decimal, or hexadecimal, 
using thc 0 and Ox base suffixes; interprets the numbers correctly; and 
converts them to decimal fonn. 'Tllen your program should Output the 
values in properly spaced columns like this: 
0,. 
0123 
'5 
hexadecimal converts to 
octal 
converts to 
decimal 
converts to 
., 
83 
'5 
decimal 
decimal 
decimal 
4. Write a program that reads strings and for each string outputs the char-
acter classification of each character, as defined by the character classifi-
calion functions preseilted in §11.6. Note that a character c.1n have 
several classifications (e.g., x is bOlh a letter and an alphanumeric). 
5. \,yrite a program that replaces punctuation with whitespace. For exam-
ple, ,. - don't use the as-if rule." becomes " dont use the asif rule ". 
6. Modify the program from the previous exercise so that it replaces don't 
with do not, can't with cannot, etc.; leaves hyphens within words intact 
(so that we get " do not use the as-if rule "); and converts all characters 
to lower case. 
7. Use the program from the previous exercise to make a dictionary (as an 
alternative to the approach in §11.7). Run the result on a multi·page text 
file, look at the result, and see if you can improve the program to make a 
better dictionary. 
8. Split the binary 110 program from §11.3.2 into two: one program that 
convens an ordinary text file imo binary and Olle program that reads bi-
nary and converts it to text. Test these programs by comparing a text file 
with what you get by converting it to binary and back. 
9. Write a function vector<string> split(const slring& s) that returns a 
vector or whitespace-separated substrings rrom the argument s. 
10. Write a function vector<string> spli((const string& s, canst slring& w ) 
that returns a vector or whitcspace-separated substrings rrom the argu-
ment s, where whitespace is defined as "ordinary whitcspace" pillS the 
characters in w . 
11. Reverse lhe order of characlers in a lext ftle. For example, asdfghjkl be-
comes Ikjhgfdsa. Hint: "file open modes." 

C HAPTER 1 1 POSTSCRIPT 
12. Reverse the order of words (defined as whitespace-separated strings) in a 
file. For example, Norwegian Blue parrot becomes parrot Blue Norwegian. 
You arc allowed to assume that all the strings from the file will fit into 
memory at once. 
13. Write a program that reads a text file and writes out how many charac-
ters of each character classification (§11.6) arc in the me. 
14. Write a program that reads a file of whitespace·separated numbers and 
outputs a file of numbers using: scientific format and precision 8 in four 
fields of20 characters per line. 
15. Write a program to read a file of whites pace-separated numbers and out-
put them in order (lowest value first), one value per line. Write a value 
only once, and if it occurs more than once write the count of its occur-
rences on its line. For example, "75573 1175" should give 
3 
5 
3 
7 
2 
117 
Postscript 
Input and output are messy becallse our human tastes and conventions have not 
followed simple-to-stale rules and straightforward mathematical laws_ As program-
mers, we arc rarely in a position to dictate that our users depart from their prefer-
ences, and when we are, we should typically be less arrogant than to think that we 
can provide a simple altemative to conventions built up over time_ Consequently, 
we must expect, accept, and adapt to a certain messiness of input and output while 
still trying to keep our programs as simple as possible - bUl no simpler. 
4.15 


1-. 
r 12 
A Display Model 
"The world was black and white then. 
[It] didn't turn color 
until sometime in the 193 Os." 
- Calvin's dad 
T
his dlaptcr presents a display model (the output part ofGU I), 
giving examples of use and fundamental notions such as 
so'CCn coordinates, lines, and color. line, Lines, Polygons, Axis, and 
Text arc examples of Shapes. A Shape is an object in memory that 
we can display and manipulate on a screen. 111c next twO chapters 
\vill explore these classes further, with Chapter 13 focllsing on their 
implementation and Chapter 14 0 11 design issues. 
407 

408 
12.1 Why graphicsl 
12.2 A. display model 
12.3 A. first example 
12.4 Using a GUllibrary 
12.5 Coordinates 
12.6 Shapes 
12.1 Why graphics? 
(HAPTER 12 • A DISPLAY MODEL 
12.7 Using Shape primitives 
12.7.1 Graphics heilders and main 
11.7.2 A.n almost blank window 
12.7.3 A.xis 
12.7.4 Graphing a function 
12.7.5 Polygons 
12.7.6 Rectangles 
12.7.7 Fill 
12.7.8 Text 
12.7.9 Images 
12.7.10 And much more 
12.8 Getting this to run 
12.8.1 Soulce files 
Why do we spend four chapters on graphics and one on GU ls (graphical user 
interfaces)? After all, this is a book about programming. not a graphics book. 
There is a huge number of interesting software topics that we don't disclIss, and 
we can at best scratch the surface on the topic of graphics. So, "\>\Thy graphics?" 
Basically, graphics is a subject that allows us to explore several important areas or 
sortware design, programming, and programming language racilities: 
Graphics are Uk:}U1. '111ere is much more to progranuning than graphics 
and much more to sortware than code manipulated through a CU I. 
However, in many areas good graphics arc either essential or very im· 
portant. For example, we wouldn't dream or studying scientific comput· 
ing, data analysis, or JUSt about any quantitative subject without the 
ability to graph data. Chapter 15 gives simple (but general) racilities ror 
graphing data. 
Graphics arejim. There arc rew areas or computing where the efTect or a 
piece or code is as immediately obvious and - when finally rree or bugs 
- as pleasing. We'd be tempted to play with graphics even if it wasn't 
useful! 
Graphics jJ1vvide lots 0/ il/terestillg cQ(ie to read. Pan of learning to program is 
to read lots or code to get a recl ror what good code is like. Similarly, the 
way to become a good writer of English involves reading a lot of books, 
articles, and quality newspapers. Because or the direct correspondence 
between what we sec on the screen and what we write in our programs, 
simple graphics code is more re<lclable than most kinds or code of similar 
complexity. 111is chapter will prove that you call read graphics code arter 
a rew minutes or introduction; Chapler 13 will demollstrate how yOll c.'l.1l 
write it arter another couple or hours. 

12.2 
A D ISPL AY MODel 
Cm/)/dcs art a ferlile J(jUf(£ rf design eXflmples. It is actually hard to design and 
implement a good graphics and CUI library. Graphics arc a very rich 
source of concrete and practical examples of dcsign decisions and dcsign 
techniqucs. Some of the most useful techniques for designing classes, de-
signing functions, separating software i1llo layers (of abstraction), and 
constructing libraries can be illustrated with a relatively small amount of 
graphics and G U I code. 
Gmpflics prouule a good 1i,lnxillcli()1/ 10 wlllli is commcJII/y calkd objecl-orienled pro-
grmnmillgmullhe lallgJlagefialurtJ Ihal support il. Despite rumors to the con-
trary, objcct-oriented programming wasn't invented to be able to do 
graphics (see Chapter 22), but it was soon applied to that, and graphics 
provide some of the Illost accessible examples of object-oriented designs. 
Some rf" Ihe key graphics (Qntepls are lIQlllriuial. So they arc worlh teaching, 
ralher than leaving it to your own initiative (and patience) to seck out in· 
formation. If we did not show how graphics and CUI were done, you 
might consider them "mabric," thus violating one of the fundamental 
aims of this book. 
12.2 A display model 
111e iostream library is oriented toward reading and writing streams of characters 
as thcy might appear in a list of numeric values or a book. The only direct sup-
ports for the notion of graphical position arc the newline and tab characters. YOli 
can embed notions of color and two·di.mensional positions, etc., in a one-
dimensional stream of characters. That's what layout (ty pesetting, "markup") 
languages such as TraIT, Tex, Word, l-rrrP, and XM L (and their associated 
graphic.."ll packages) do. For example: 
<hr.> 
<h2> 
Organization 
<lh2> 
This list is organized in three paris: 
<ul> 
<lub 
<li><b>Proposals<lb>, numbered EPddd, ... <I1i> 
<li><b>lssues<lb>, numbered Elddd, ... <I1i> 
di><b>Suggestions<lb>, numbered ESddd, ... <I1i> 
<p>We try to ... 
<p> 
111is is a piece of HTM L specifying a header « h2> ... <lh2» a list « ub ... 
<lub) wilh list items « il> ... <iiI>) and a paragraph « p» . We left out most of 

410 
CHAPTER 12 • A DISPLAY MODEL 
the acmal tcxt because it is irrelevam here. lne poim is that you can express lay-
out notions in plain text, but the connection between the characters written and 
what appears on the screen is indirect, governed by a program that interprets 
those "markup" commands. Such techniques arc fundamcntaHy simple and im-
mensely useful (jUSt about everything you read has been produced using them), 
bUl tllCY also have their limitations. 
In this chapter and the next [our, we present an altcmativc: a notion of graph-
ics and of graphical user interfaces that is direcuy aimed at a computer screen. 
The fundamental concepts arc inherently graphical (and two-dimensional, 
adapted to the rectangular area of a computer screen), such as coordinates, lines, 
rectangles, and cireles. TIle aim from a progranmung point of view is a direct cor-
respondence between the objects in memory and the images on the screen. 
The basic model is as follows: ""e compose objccts with basic objects provided 
by a graplucs system, such as lines. We "attach" thesc graphics objects to a \vindow 
object, representing our physic.-u screen. A program that wc can think of as the dis-
play itself, as "a display engine," as "our graplucs library," as "the CUI library," or 
even Qmmorously) as "the small gnome writing on the back of the screen" then 
takes the objects wc have added to our window and draws them on the screen: 
Circle 
Display 
engme 
attachO 
draw() 
"Wmdow" 
Square 
allachO 
111e "display engine" draws lines on the screen, places strings of text on the 
screen, colors areas of the screen, etc. For simplicity, we'll use the phrase "our 
CU I library" or even "the system" for the display engine even though Ollr CU I 
library docs much more than just drawing the objects. In the same way that our 
code lets the G U I library do mOst of the work for us, the CU I library delegates 
much of its work to the operating system. 
12.3 A first example 
Our job is to define classes from which we can make objects that we want to see 
on the screen. For example, we might want to draw a graph as a series of con-
nected lines. Here is a small program prescilling a very simple version of that: 

12 .3 
A FIRST EXA MPLE 
#indude "Simple_window.h" 
#ind ude "Craph .h" 
int mainO 
( 
/I get access to our window library 
II get access to our graphics libr.lry faci lities 
using namespace Craph_lib; /I our graphics facilities are in GraphJib 
} 
Point 11(100,100); 
/I to become top left corner of window 
Simple_window win(II,600,400, "Canvas"); II make a simple window 
Polygon poly; 
poly.add(Point(JOO,200»; 
poly.add(Point(J50,100»; 
poly.add(Point(400,200)); 
poly.scCcolor(Color: :rcd); 
win.attach (poly); 
win.waiCfor_button(); 
II make a shape (a polygon) 
/I add a point 
/I add another point 
II add a third point 
/I adjust properties of poly 
/I connect poly to the window 
/I give control to the display engine 
When we nm this program, the screen looks something like this: 
411 

412 
CHAPTER 12 • A DISPLAY MODEl 
Let's go through the program line by line to sec what was done. First we include 
the headers for our graphics interface libraries: 
#include "Simplc_window.h" 
II get access to our window library 
#include "Graph.h" 
/1 gel access to our graphics library faciJilies 
Then, in mainO, we start by telling the compiler that Ollf graphics facilities arc to 
be found in Graph_lib: 
using namespace Graph_lib; 
1/ our graphics facilities are in GraphJib 
Then, we dc[mc a poim that we will usc as the [OP left corner of our window: 
Point 11(100,100); 
/I to become top left corner of window 
Next, we create a WiJldow on the screen: 
Simple_window win(tl,600,400, "Canvas"); 
II make a simple window 
We use a class representing a window in our Graph_lib iIllcrfacc library c.'tlled 
Simple_window. The name orlhis particular Simple_window is win ; that is, win 
is a variable or class Simple_window. The initializer list ror win starts with the 
point. to be used as the top Icrt corner, tI, rollowed by 600 and 400. ~n ose are the 
width and height, respectively, or the window, as displayed on the screen, meas~ 
ured in pixels. We'll explain in more detail later, but the main point here is that 
we specify a rectanglc by giving its width and height. The string Canvas is lIsed 
to label the window. Ir you look, you can sec the word Canvas in the top lert cor-
ner of the window's rrame. 
On our screen, the window appeared in a position chosen by the GU lli· 
brary. In §13.7.2, we'll show how to choose a particular position, but ror now, 
we'll just take what our library picks; that's orten just right anyway. 
Next, we put an object in lile window: 
Polygon poly; 
poly.add(Point(JOO,200»; 
poly.add (Poi nt(35O, 1 00»; 
poly.add(PoinI(4OO,200»; 
1/ make a shape (a polygon) 
1/ add a point 
1/ add another point 
1/ add a third point 
We define a polygon, poly, and then add points to it. In our graphics library, a 
Polygon starts empty and we can add as many points to it as we like. Since we 
added three points, we get a triangle. A point is simply a pair or values giving the 
x and y (horizontal and verticaJ) coordinates within a window. 

12.3 
A FIRST EXAMPLE 
JUSt to show oIT, we then color the lines of our polygon red: 
poly.scCcolor(Color: :red); 
II adjust properties of poly 
Finally, we auach poly to our window, win: 
win .allach(poly); 
II connect poly to thc window 
If t.he program wasn't. so fast, you would notice that so far nothing had happened to 
the SQ"CCn: nOlhing at all. vVe created a \v1.ndow (an object of class Simple_window, 
to be precise), created a polygon (called poly), painted that polygon red (Color:: 
red), and auached it to the window (called win), but we have not yet asked for lhat 
window to be displayed on the screen. TIlat's done by the final line of the program: 
win.waiCfor _button(); 
II give control to Ihe display engine 
"10 get a CUI system to display objects on the screen, you have to give control to 
"the system." Our wail_for_hullonO docs t.hat, and it also waits for you to 
"press" ("dick") the "Next" button of Ollr Simple_window before proceeding. 
"n lis gives you a chance to look at the window before the program fmishcs and 
the window disappears. When you press the bulton, the program terminates, 
dosing the window. 
In isolation, our window looks like this: 
You'll notice that we "cheated" a bit. Where did that button labeled "Next" come 
from? We buill it into our Simple_window class. In Chapter 16, we'll move from 
413 

.,. 
CHAPTER 12 • A DISPLAY MODEL 
Simple_window to "plain" Window, which has no potentially SPUriOLIS facilities 
built in, and show how we can write our own code to comrol interaction wit.h a 
window. 
For the next three chapters, we'll simply usc that "Next" bunan to move 
from one "display" to the next when we want to display infonnation in stages 
("frame by frame"). 
You arc so used to the operating system putting a frame around each window 
that YOli might not have noticed it specifically. However, the pictures in .. his and 
the following chapters wcre produced on a Microsoft Windows system, so you 
gel lhe usual three buttons on the lOp right "for free." This can be useful: if your 
program gets in a real mess (as it surely will sometimes during debugging), you 
can kill it by hitting the x bunon. When you run your program on another sys· 
telll, a different frame will be added to fit that system's conventions. Our only 
contribution to the frame is the label (here, Canvas). 
12.4 Using a CUI library 
In this book, we will not usc the operating system's graphical and G U I (graphi-
cal user interface) facilities directly. Doing so would limit our programs to run on 
a single operating system and would also force us to deal directly with a lot of 
messy details. As with text I/O, we'll usc a library to smooth over operating sys-
tem differences, I/O device variations, etc. and to simplify ollr code. Unfortu-
nately, C++ does nOI provide a standard GUI library the way it provides the 
standard stream 1/0 library, so we usc one of the IllallY available C++ GUlli-
braries. So as not to lie YOll directly into aile of those GUI libraries, and 1'0 save 
you from hitting the full complexity of a G U I library all at once, we usc a set of 
simple interface classes that can be implemented in a couple of hundred lines of 
code for just about any G U I library. 
111e G U I toolkit that we arc using (indirectly for now) is called FLTK (Fast 
Light Tool Kit, pronounced "full tick") from w, ... w.f1tk.org. Our code is portable 
wherever FLTK is used (Windows, Unix, Mac, Linux, etc.). Our imerface classes 
can also be re-implemented using other toolkits, so code using them is potentially 
even more portable. 
TIle programming model presented by our interface classes is far simpler 
than what conunoll toolkits afTer, For example, our complete graphics and G U I 
interface library is about 600 lines of C++ code, whereas the extremely terse 
FLTK documentation is 370 pages_ You can download lhat from www_fltk.org, 
but we don't recommend you do that just yet. You can do without that level of 
detail for a while. TIle general ideas presented in C hapters 12- 16 can be used 
with any popular G U I toolkit. We will of course explain how our interface 
classes map to FLTK so that you will (eventually) see how you can lise that (and 
similar toolkits) di.'cctly, if necessary. 

12 .5 
CO O RDINATE S 
We can illustrme the partS of our "graphics world" like this: 
l Our code I 
~ 
l Our interface library I 
" 
A l7'phics/GUI library 
(here FLTK) 
"-
The operating system 
Our screen I 
(e.g., Windows or Linux) 
Our intcrface classes ptovide a simple and user-extensible basic notion of twO-
dimensional shapes with limited support for the usc of color. To drive that, we 
present a simple notion of G U I based on "callback" functions triggered by the 
use of user-defined buttons, etc. on the screen (Chapter 16). 
12.5 Coordinates 
A computer screen is a rectangular area composed of pixels. A pixel is a tiny spot 
that can be given some color. Ille most common way of modeling a screen in a 
program is as a rectangle of pixels. Each pixel is idemified by an x (horizontal) co-
ordinate and a )' (vertical) coordinate. 111e x coordinates start with 0, indicating 
the leftmost pixel, and increase (tOward the right) to the rightmost pixeL The ), 
coordinates Start with 0, indicating the topmost pixel, and increase (toward the 
bottom) to the lowest pixel: 
0,°1----------200,0 __ 
50,50 
0,100 
I 
100,200 
415 

" 6 
CHAPTER 12 • A DISPLAY MODEl 
Please note that y coordinates "grow downward." Mathematicians, in particular, 
find this odd, but screens (and windows) come in many sizes, and the top lert 
point is about all that they have in common. 
TIle number of pixels available depends on the screen: I024-by-768, 1280-by-
1024, 1450-by-l050, and 1600-by-1200 are CDIlUTIon screen sizcs. 
In the context of interacting with a computer using a screen, a window is a 
rectangular region of the screen devoted to some specific purpose and controlled 
by a program. A window is addressed exactly as a screen. BasicaJly, we sec a win-
dow as a small screen. For example. when we said 
Simple_window win(tI,600,400, "Canvas"); 
we requested a rectangular area 600 pixels wide and 400 pixels high that we can 
address 0-599 (left to right) and 0-399 (top to bottom). loe area of a window that 
you can draw on is commonly referred to as a ((11/f)(l$. TIle 600-by400 area refers to 
"lhe inside" of the window. that is, the area inside the system-provided frame; it 
docs not include the space the system uses for the title bar, quit butlon, etc. 
12.6 Shapes 
Our basic toolbox for drawing on the screen consists of about a dozen classes: 
Window 
(Lin. slyl.) 
( Color ) 
( Poinl ) 
Une 
Lines 
Pol 
on 
Axis 
Rectan Ie 
• 
An arrow indicates that the class pointing can be used where the class pointed to 
is required. For example, a Polygon can be used where a Shape is required; that 
is, a Polygon is a kind of Shape. 
We will start out presenting and using 
Simple_window, Window 
Shape, Text, Polygon, Line, Lines, Reclangle, Funclion, etc. 
Color, Line_slyle, Point 
Axis 

12 . 7 
US ING SHAPE PRIMITIVES 
Later (Chapter 16), we'll add CUI (user interaction) classes: 
Bullon, In_box, Menu, etc. 
We could easily add many more classes (for some definition of ';easy"), such as 
Spline, Grid, Block_chart, Pie_chart, etc. 
However, defining or describing a complete CUI framework with all it:s facilities 
is beyond the scope of this book. 
12.7 Using Shape primitives 
In this section, we will walk you through some of the primitive facilities of our 
graphics library: Simple_window, Window, Shape, Ted , Polygon, line, lines, 
Rectangle, Color, line_style, Point, Axis. TIle aim is to give you a broad view of 
what you can do with those facilities, but nO{ yet a detailed understanding of any 
of those classes. In the next chapters, we explore the design of each. 
We will now walk through a simple program, explaining the code line by line 
and showing the effect of each on the screen. When you rUIl the program you'll 
see how the image changes as we add shapes to the window and modify existing 
shapes. Basically, we are "animating" the progress through the code by looking at 
the program as it is executed. 
12.7.1 Graphics headers and main 
First, we include the header files derming Ollr interface to the graphics and CUI 
facilities: 
0' 
#include "Window.h" 
/I a plain window 
#include "Graph.h" 
#include "Simple_window.h" 
#include "Graph .h" 
/I if we wanllhal "Nexl" bullon 
As yOll probably guessed, Window.h contains the facilities related to windows 
and Graph .h the facilities related LO drawing shapes (including text) into win-
dows. 'Illese facilities are defined in the Graph_lib namespace. To simplify nota-
tion we lise a namespace directive to make the names from Graph_lib directly 
available in Ollr program: 
using namespace G ra ph~lib ; 
417 

418 
(HAPTER 12 • A DISPLAY MOD EL 
As usual, mainO contains the code we want to execute (directly or indirectly) and 
deals with exceptions: 
inl main 0 
t.y 
( 
1/ ... here is our code . 
) 
catch(eJeception& e) ( 
) 
1/ some error reporting 
return 1; 
catch( ... ) ( 
/I some more error reporting 
return 2; 
) 
12.7.2 An almost blank window 
We will not discuss error handling here (sec Chapter 5, in particular, §5.6.3), but 
go straight to the graphics within main(): 
Point 11(100,100); 
/I top left corner of our window 
Simple_window win(tJ,600,400, "Canvas "); 
/I screen coordinate tl for top left corner 
/I window size(600"400} 
/I title: Canvas 
win. waiUor_button(); 
/I display! 
Tltis creates a Simple_window, lhal is, a window with a "Next" bunon, and dis-
plays it on the screen. Obviously. we need to have #included the header 
Simple_window.h rather than Window.h to get Simple_window. Here we are 
specifie about where on the screen the window should go: its LOp left comer goes 
at Poinf(1oo, 1(0). 111at's ncar, but not tOO near, the tOp left comer of the screen. 
Obviously, Point is a class with a conStructor that takes a pair of integers and in-
terprets them as an (x,}) coordinate pair. We could have written 
Simple_window win(Poinl(l 00, 100),600,400, "Canvas"); 

12.7 
US ING SHAPE PRI MITIVES 
However, we want to lise the point (100,100) several times so it is more conven-
ient to give it a symbolic name. 111e 600 is the width and 400 is the height of lhe 
window, and Canvas is the label we want put on the frame of the window. 
To actually get the window drawn on the screen, we have to give control to 
the GUI system. We do this by calling win.wail_ror_buttonO and the result is: 
In the background of ollr window, we see a laptop screen (somewhat cleaned up 
for the occasion). For people who arc curious about irrelevant details, we can tell 
you that I lOok the photo standing ncar the Picasso library in Antibes looking 
across the bay to Nice. -111e black console window partially hidden behind is the 
one nmning Ollr prOb'TIllll. Having a console window is somewhat ugly and un-
necessary. but it has the advantage of giving us an effective way of k.illing our 
window if a partially debugged program gets into an infmite loop and refuses to 
go away. If you look carefully, YOll'lI notice that we have the Microsoft C++ COIll-
piler nmning, but you could just as well have lIsed some other compiler (such as 
Borland or GNU). 
Fo r the rest of the presentation we will eliminate the distractions around Ollr 
window and just show that window by itself: 
41. 

420 
CHAPTER 12 • A DI SPLAY MODEl 
·nlC actual size of the window (in inches) depends on the resolution of your 
screen. Some screens have bigger pixels than other screens. 
12.7.3 Axis 
An almost blank window isn't very interesting, so we'd better add some infonna-
lion. What would we like to display? Just to remind you that graphics is nOt all 
fun and games, we will Slart with something serious and somewhat complicated: 
an axis. A graph without a.xes is usually a disgrace. You just don"t know what the 
data rcprescills Wilholll axes. Maybe you explained it all in some accompanying 
text, but it is far safer to add axes; people often don't read the explanation and 
often a nice graphical representation gelS separated from its original comext. So, 
a graph needs a.xes: 
"xis xa(Axis: :x, Point(20,300), 280, 10, "x axis"); 
II an Axis is a kind of Shape 
II Axis::x means horizontal 
II starting at (20,300) 
11280 pixels long 
1110 "notches" 
Illabcl the axis "x axis" 
1/ make an Axis 
win.altach(xa); 
II attach xa to the window, win 
win.seUabel("Canvas #2"); 
win.waiCfor_button(); 
II relabel the window 
II display! 

12. 7 
USING SHAP E PRIMITIVES 
~nle sequence of aClions is: make the a.xis object, add it to the window, and fi· 
nally display it: 
'yVe can see that an Axis: :x is a borizomalline. We see the required number of 
"notches" (10) and the label "x axis." Usually, the label will explain what the axis 
and the notches represent. Naturally, we chose to place the x axis somewhere 
ncar the bOllom of the window. In real life, we'd represent the heighl and width 
by symbolic constants so that we could refer to "just above the bottom" as somc· 
thing like y_max-bottom_margin rathcr than by a "magic constant," such as 300 
(§4.3. 1, §15.6.2). 
To help idclllify our output wc relabelcd thc screen to Canvas #2 using 
Window's member function seUabelO. 
Now, let's add a J axis: 
Axis ya(Axis: :y, Point(20,300), 280, 10, "y axis"); 
ya.seCcolor(Color: :cyan); 
/I choose a color 
ya.label.scLcolor(Color: :dark_red); 
/I choose a color for the text 
win.allach(ya); 
win.setJabel("Canvas *3"); 
win.waiU01_buttonO; 
II display! 
Just to show ofT some facilities, we colored our J axis cyan and our label dark red. 
421 

422 
CHAPTER 12 • A DISPI.AY MODEL 
,,'" 
We don't actually think thal it is a good idea to usc different colors for x and y 
axes. \<\'c just wanted to show you how yOll C<'lll set the color of a shape :md of in-
dividual clements of a shape. Using lots of color is not necessarily a good idea. In 
pallicuiar, novices tend to usc color with morc enthusiasm than taSle. 
12.7.4 Graphing a function 
What next? We now have a window with axes, so it seems a good idea to graph 
a function. We make a shape rcprcscming a sine function and attach it: 
Function sine(sin,O, l00,Poinl(20,150), 1000,50,50); 
1/ sine curve 
/I plot sinO in the range [0: I 00) with (0,0) al (20,150) 
/I using 1000 points; scale x v.llues '50, scale y values -50 
win.atlach(sine); 
win.seClabel("Canvas #4"); 
win. wai'-for _ bu 110 n (); 
Here, the fun elion named sine will draw a sine curve using the standard library 
runction sinO to generate values. We cxplain dctails about how to graph func-
tions in §15.3. For now, JUSt notc t.hat to graph a runction wc havc to say whcre it 
starts (a Point) and ror what set or input valucs we want to sec it (a range), and 
we need to givc somc inrormation about how to squecle that infornlalion into 
our window (s<:"1Iing): 

12.7 
USING SHAPE PRIMITIVES 
. 
.., 
Notc how the curvc simply stops when it hits the edge or the window. Points 
drawn outside our window recta.ngle arc simply ignored by the G U I system and 
never secil. 
12.7.5 Polygons 
A graphed runction is an example or data presentation. Wc'lI sce much more or 
that in Chapter 15. However, we can also draw differcnt kinds or objects in a 
window: geometric shapes. We use geometric shapes ror graphical illustrations, 
to indicate user interaction elements (such as bUllons), and generally to make Ollr 
presentations morc interesting. A Polygon is characterized by a sequence or 
points, which the Polygon class connects by lines. TIle first line connects the first 
point to the second, the second line connects the second point to the third, and 
the last line COlU1CCts the last point to the first: 
sine.seCcolor(Color: : blue); 
Polygon poly; 
pol y .add( Poi nt(300, 200» ; 
poly.add(Point(350,100»; 
poly.add(Poinl(400,200»; 
poly.sec color(Color: :red); 
II we changed our mind about sine's color 
II a polygon; a Polygon is a kind of Shape 
/I three points make a triangle 
423 

424 
poly.set_style(Line_style: : dash); 
win.attach(poly); 
win .seClabel("Canvas #5"); 
win.waiCfoT_button(); 
CHAPTER 12 • A DI SPLAY MODEl 
111is time we change the color of the sine curve (sine) just to show how. ~IltCIl , 
we add a triangle, just as in our first example from §12.3, as an example of a 
polygon. Again, we set a color, and finally, we set a style. TIle lines of a Polygon 
have a "style." By default that is solid, but we can also make those lines dashed, 
dOlled, etc. as needed (sec § 13.5). We get 
\ 
t . 
"" 
12.7.6 Rectangles 
A screen is a rccHmglc, a window is a rectangle, and a piece of paper is a rectan-
gle. In fact, an awful lot of the shapes in our modern world arc rccuUlglcs (or at 
least rectangles with rounded corners). ~nlcre is a reason for this: a rectangle is 
the simplest shape LO deal with. Fo r example, it's easy 1'0 describe (LOp lerl corner 
plus width plus height, or top lefl corner plus bottom right corner, or whalever), 
it's easy to lell whelher a poim is inside a rectangle or olltside it, and it's easy 10 
get hardware to draw a rectangle of pixels fast. 
So, most higher· level graphics libraries deal beller with rectangles than with 
other closed shapes. Consequently, we provide Rectangle as a class separate from 
the Polygon class. A Rectangle is characterized by its lOp left corner plus a width 
and height: 

12.7 
USING SH APE PR IMITIVES 
Rectangle r(Poinl(200,200), 100, SO); 
II top left corner, width, height 
win.attach(r); 
win.seUabel("Canvas #6" ); 
win. wail_for_button(); 
From lhal, we gel 
,,.. 
Please nOle lhat making a polyline with rour points in the right places is nOl 
enough LO make a Rectangle. It is easy to make a Closed_polyline that looks like 
a Rectangle on the screen (you can even make an Open_polyline that looks juSt 
like a Rectangle); ror example: 
Closed_polyline poly_rect; 
poly_,ect.add(Point(l00,SO»; 
poly_,ect.add(Poinl(l00,SO»; 
poly _ rect .add( Poi nI(200, 1 00»; 
poly -,eel .add( Poi nl(l 00, 1 00)); 
42> 

426 
C HAPTER 12 • A DI SPLAY MOD El 
.... 
In fact, the image on the screen of such a poly_reet is a rectangle. However. the 
poly _reet object in memory is nOt a Rectangle and it docs not "'know" anything 
about rectangles. ~nl C simplest way to prove that is to add another point: 
pol y _recl.add{Poinl(SO, 75»; 
No rectangle has five points: 
.... 
It is imponalll for our reasoning abOllt our code lha! :l Rectangle doesn't just 
happen to look like a rectangle on the screen; it maintains the fundamental guar-

12.7 
US IN G SHAPE PRIMITIVE S 
"Iltees of a rectangle (as we know them from geometry). We write code that de-
pends on a Rectangle really being a rectangle on the screen and staying that way. 
12.7.7 Fill 
\o\'c have been drawing our shapes as outlines. We can also "fill" a rectangle with 
color: 
r.scefill_color(Colot: : ye llow); 
/I color the inside of the rectangle 
pol y.seestylc(lin c_stylc( lin e_style: : dash ,4»; 
poly _reet. seest yle(li ne_sl yle(li ne_style: : dash,2»); 
win.setJabel(IICanvas #7"); 
win.wait_for _buttonOi 
We also decided lhat we didn't like lhe line style of Ollr triangle (poly), so we set 
its line style to "fat (thickness four times normal) dashed." Similarly, we changed 
the style of poly_reet (now no longer looking like a rectangle): 
, ... 
If you look carefully at poly_tcel, you'll sec that the outline is printed on tOp of 
the fill. 
It is possible to fill any closed shape (sec §13.9). Rectangles arc just special in 
how easy (and fast) they arc to rul 
12.7.8 Text 
Finally, 110 system for drawing is complete WilhoUl a simple way of writing text -
dr.:lwing each charncter as a set of lines just doesn't cut it. \.ye label the window itself, 
and a.xcs can have labels, but we can also place text anywhere using a Text object: 
427 

428 
CHAPTER 12 • A DISPLAY MODEL 
Text t(Point(150,15O), "Hello, graphical world ! "); 
win.atlach(l); 
win.setJabel{"Canvas #8"); 
win.wail_for_button(); 
.... 
From the primitive graphics elements you see in this window, you can build dis-
plays of just abOllt any complexity and subtlety. For now, just notc a peculiarity 
of the code in this chapter: there arc no loops, no selection statements, and all 
data was "hardwired" in. The output was JUSt composed of primitives in the 
simplest possible way. O nce we stan composing these primitives using data and 
algOlithms, things will stan to gel interest.ing. 
We have seen how we can control the color of text: the label of an Axis 
(§ 12.7.3) is sim ply a Text object. In addition, we can choose a font and SCI the size 
of the characters: 
t.seCfont(Font: : times_bold); 
t.seUonCsize(20); 
win.set_labe l("Canvas #9"); 
win.wail_for_buttonO; 
Vic enlarged the characters of lhe Text string Hello, graphical world! to point size 
20 and chose the Times font in bold: 

12 .7 
US ING SHAP E PRIMITIVES 
12.7.9 Images 
\.vc can also load images from files: 
Image ii(Point(100,50), "image.jpg"); 
win.allach(ii); 
win.seClabel("Canvas #10"); 
win. wai Uor _bu lIonO; 
1/400·2 12-pixel jpg 
As it happens, the file called image.jps is a photo or two planes breaking the 
sound barrier: 
. 
"" 
429 

·'" 
CHAPTER 12 • A DISPLAY MO DE L 
That phoLO is relatively large and we placed it right on tOp of our text and 
shapes. So, LO clean up Ollr window a bit, let liS move it a bit out of the way: 
ii.move(100,200); 
win.set_labeH"Canvas #11 "); 
win.waiC fof_button()j 
. "" 
Note how the pans of the photo that d idn't fit in the window arc simply not rep-
resented. What would have appeared outside the window is "clipped" away. 
12.7.10 And much more 
And here, without further CQIlUllCnt, is some more code: 
Circle c(Point(100,200),SO); 
Ellipse e (Point(100,200), 75,25); 
e,seccolor(Color: :dark_,ed)i 
Mark m(Poinl(l00,200),'x'); 
oSlringslream OSS; 
ass« "screen size: " « ,c max()« '''''« y_maxO 
«
"; window size : "« win.x_maxO« 11."« win.y_max()j 
Text sizcs(Point(l 00,20) ,ass .sh O) i 
Image cal(PoinI(225,225), "snow_cpp.gif")i 
cal.set_mas k(Point(4{I ,4{1) ,200,150) i 
II 320"240-pixel gif 
II display center p<lrt of image 

12 .8 
GETTING THIS TO RUN 
win.attach(c); 
win.altach(m); 
win.attach(e); 
wi n .attach(sizes); 
win.attach(cal); 
win.set_label("Canvas #12"); 
win. waiCfor_button(); 
Can you guess what this code docs? Is it obvious? 
...... "'01_"'V 
.... 
111e connection between the code and what appears on the screen is direct. If 
you don't yet see how that code caused mat Output, it soon will become clear. 
Note the way we used a stringslream (§11.4) to fonnat the text object displaying 
sizes. 
12.8 Getting this to run 
We have seen how to make a window and how to draw various shapes in it. In 
the following chapters, we'll sec bow mose Shape classes are defined and show 
marc ways of using them. 
Getting this program to run requires morc than the programs we have pre-
sented so far. In addition to our code in mainO, we need to get the interface library 
code compiled and linked to our code, and finally, nothing will nm unless the FLTK 
library (or whatever GUI system we usc) is installed and con'ectly linked to ours. 
431 

432 
CHAPTER 12 • A DI SPL AY MODEL 
One way of looking at the program is that it has four distinct p<lrts: 
Our program code (mainO, etc.) 
OUf interface library (Window, Shape, Polygon, etc.) 
l1)c FLTK library 
TIle C++ standard library 
Indirectly, we also lISC the operating system. Leaving out the OS and the stan-
dard library, we can illustrate the organization of our graphics code like this: 
Poinl.h : 
sltucl Point { ... }; 
Graph.h: 
/I graphing interface: 
strucl Shape { ... }; 
FLTK headers 
Window.h: 
/I window interface: 
class Window { ... }; 
GUl.h : 
FLTK code 
window.cpp: 
/I CUI interface: 
struct In_box { ... }; 
Window code 
Simplc_window.h : 
/I window interface: 
class Simple_window { ... }; 
chapter12.cpp: 
#include "Graph.h" 
#include "Simple_window.h" 
int mainO { ... } 
Appendix D explains how to get all of tllls to work togctllcr. 
12.8.1 Source files 
Our graphics and G VI interface library consists of just fivc header files and tlll'eC 
code files: 

CHAPTER 12 REVI EW 
Headers: 
Point.h 
Window.h 
Simple_window.h 
Graph.h 
GUth 
Code files: 
Window.cpp 
Graph.cpp 
GUtcpp 
Until Chapter 16, you can ignore the GU I files . 
..;' Drill 
111e drill is the graphical equivalent LO the "Hello, World!" program. Its purpose 
is to get you acquainted with the simplest graphical output tools. 
l. Get an empty Simple_window with the size 600 by 400 and a label My 
window compiled, linked, and run. Note that you have to link the FLTK 
library as described in Appendix 0 ; #include Graph.h, Window.h, and 
GUth in your code; and include Graph.cpp and Window.cpp in your 
project. 
2. Now add the examples from §12.7 one by one, testing between each 
added subsection example. 
3. Go through and make one minor change (e.g., in color, in location, or in 
number of points) to eacll of the subsection examples. 
Review 
1. Why do we usc graphics? 
2. When do we try not to use graphics? 
3. Why is graphics interesting for a programmer? 
4. VVhat is a window? 
5. In which namespace do we keep our graphics i.nterface classes (our graphics 
library)? 
6. vVhat header files do you need to do basic graphics using our graphics 
library? 
433 

4" 
7. 
8. 
9. 
10. 
II. 
12. 
13. 
14. 
15. 
16. 
17. 
18. 
Terms 
C H APTER 12 • A DI SPL AY MODEL 
What is the simplest window to use? 
What is the minimal window? 
What's a window label? 
How do youlabcl a window? 
How do screen coordinates work? Window coordinates? Mathematical 
coordinatcs? 
'What arc examples of simplc "shapes" that we can display? 
What command auaches a shape to a window? 
Which basic shape would yOll Lise to draw a hexagon? 
How do you write text somewhere in a window? 
How would YOli put a photo of your best friend in a window (using a 
program you wrote yourself)? 
You made a Window object, but nothing appears on yOUT screen. What 
arc some possible reasons for that? 
You have made a shape, but it doesn't appear in the window. What arc 
some possible reasons for that? 
color 
coordinates 
display 
graphics 
CUI 
CUI library 
HTTP 
JPEC 
line style 
sofnvare layer 
window 
XML 
fill color 
FLTK 
Exercises 
linage 
We recommend that you use Simple_window for these exercises. 
1. Draw a rectangle as a Rectangle and as a Polygon. Make the lines of the 
Polygon red and the lines of the Rectangle blue. 
2. Draw a 100-by-30 Reclangle and place the text "Howdy!" inside it. 
3. Draw your initials 150 pixels high. Use a thick line. Draw eadl initial in 
a different color. 
4. Draw a checkers board: B-by-B alternating white and red squares. 
5. Draw a red L/4-inch frame around a rectangle that is three-quarters the 
height of your screen and two-thirds lhe width. 
6. 'VVhat happens when you draw a Shape that doesn't fit inside its win-
dow? 'VVhat happens when you draw a Window that doesn't fit on your 
screen? Write nvo programs that illustrate these two phenomena. 
7. Draw a nvo-dimensional house seen from the front, the way a child 
would: with a door, nvo windows, and a roof with a chimney. Feel free to 
add details; maybe have "'smoke" come out of the chimney. 

CHAPTER 12 POSTSC RIPT 
8. Draw the Olympic five rings. If you can't remember the colors, look 
them up. 
9. Display an image on the screen, e.g., a pholO of a friend. Labelt.he image 
both with a tide on the .. vindow and with a caption in the window. 
10. Draw the file diagram from §12.8. 
II . Draw a series of regular polygons, one inside the other. The innermost 
should be an equilateral triangle, enclosed by a square, enclosed by a 
pentagon, etc. For the mathematically adept only: leI all the points of 
each N-polygon tOucll sides of the (N+ 1 )-polygon. 
12. A superellipse is a two-dimensional shape defined by the equation 
I~I' + Iii" 
= I; 
m,1l> O. 
Look up JIII)(:rrUi~ on the web to get a better idea of what such shapes look 
like. Write a program that draws "starlike" pattenlS by colUlccting POUlts on 
a supercUipsc. Take a, b, m, n, and N as arguments. Select N POUlts on the 
supcrcllipse defined by a, b, m, and n. Make the points equally spaced for 
some defmition of ;;e<Jual." Connect each of mose N points to one or more 
other POUlts (if you like you can make me number of points COlUlcct to an-
other argument or just usc N- 1, i.e., all me orner poUlts). 
13. Find a way to add color to the supcrellipse shapes from the previous ex-
ercise. Make some lines one color and other lines anomer color or other 
colors. 
Postscript 
' 1le ideal for program design is to have our concepts direcliy rcpresellted as enti-
ties in our program. So, we often represent ideas by classes, real-world entities by 
objects of classes, and actions and computations by funcliOllS. Graphics is a do-
main where this idea has an obvious application. We have concepts, such as cir-
cles and polygons, and we represent them in our program as class Circle and 
class Polygon. Where graphics is unusual is mat when writing a graphics pro-
gram, we also have the opportunity to sec objects of those classes on the screen; 
that is, the state of our program is directly represcnted for us to observe - in 
most applications we arc not that lucky. TIlis direct correspo ndence between 
ideas, code, and output is what makes graphics programmulg so attractive. 
Please do remember, though, that graphics arc just illustrations of the general 
idea of lISUlg classes to directly represent concepts in code. That idea is far more 
general and usdul : just about anything we can think of can be represented in 
code as a class, an object of a class, or a set of classes. 
435 


1-
'- 13 
Graphics Classes 
"A language that doesn't 
change the way you think 
isn't worth learning." 
-Traditional 
C
harter 12 gave an idea of what we could do in terms of graph-
ics using a set of simple interface classes, and how we can do 
it. This cilapler prcsems llu111Y of the classes offered. 111C focus here 
is on the design, usc, <md implementation of individual interface 
classes such as Point, Color, Polygon, and O pen_polyline and 
their uses. The following chapter will present ideas for designing 
sets of related classes and will also present more implementation 
techniques. 
437 

438 
13.1 Overview of graphics classes 
13.2 Point and Line 
13.3 Lines 
13.4 Color 
13.5 Line_style 
13.6 Open_polyline 
13.7 Closed_polyline 
13.8 Polygon 
13.9 Rectangle 
CHAPTER 13 • GRAP HI CS CLASS ES 
13.10 Managing unnamed objects 
13.11 Text 
13.12 Circle 
13.13 Ellipse 
13.14 Marked_polyline 
13.15 Marks 
13.16 Mark 
13.17 Images 
13.1 Overview of graphics classes 
Graphics and G U I libraries provide lots of facilities. By "lots" we mean hundreds 
of classes, often With dozens of functions applying to each. Reading a description, 
manual, or documentation is a bit like looking at an old-fashioned botany lext-
book listing details of thousands of plants organized according to obscure classi-
fying traits. It is daunting! It c.'m also be exciting - looking at the facilities of a 
modem graphics/GUllibrary can make you feel like a child in a candy store, but 
it C'111 be hard to figure out where to start and whal is really good for Y0lt. 
One purpose of our interface library is to reduce the shock delivered by the 
complexity of a full-blown graphics/CU I library. We preselll just two dozen 
classes with hardly any operations. Yet they allow you to produce useful graphi-
cal OlitpUt. A closely related goal is to imroduce key graphics and CU I concepts 
through those classes. Already, you can write programs displaying results as sim-
ple graphics. After this chapter, your range of graphics programs will have in-
creased to exceed most people's initial requirements. After Chapler 14, you'll 
understand most of the design techniques and ideas involved so that you can 
deepen your understanding and extend your range of graphical expression as 
needed. You can do so either by adding to the facilities described here or by 
adopung another C++ graphics/C U I library. 
'n te key interface classes are: 
Graphics interrace classes 
Color 
Line_style 
Point 
used for lines, text, and filling shapes 
used to draw lines 
used to express locations on a screen and within a Window 

13 . 1 
OVERVIEW OF GRAPH ICS CLASSES 
Graphics interface classes (continued) 
Line 
Open_polyline 
Closed_polyline 
Polygon 
Te.:t 
lines 
Rectangle 
Circle 
Ellipse 
f unction 
A.:is 
Mark 
Marks 
Marked_polyline 
Image 
a line segment as we sec it on Ihe screen, defined by its two end 
Points 
a sequence of connected line segments defined by a sequence 
of Points 
like an O pen_polyline, except that a line segment connects thc 
last Point to the first 
a Closed...,polyline where no two line segments intersect 
a string of characters 
a set of line segments defined by pairs of Points 
a common shape optimized for quick and convenient display 
a circle defined by a center and a radius 
an ellipse defined by a center and two axes 
a function of one variable graphed in a range 
a labeled axis 
a point marked by a character (such as .: or 0 ) 
a sequence of points indicated by marks (such as .: and 0 ) 
an O pen_polyline with its points indicated by marks 
the contents of an image file 
Chaptcr 15 examines Function and Axis. Chapter 16 presents the main CUI in· 
tcrface classes: 
GU I interface classes 
Window 
Simple_window 
Bullon 
Menu 
an area of Ihe screen in which we display our graphics objects 
a window with a ·Next" bulton 
a rectangle, usually labeled, in a window that we can press to 
run one of our functions 
a box, usually labeled, in a window into which a user can type a 
Siring 
a box, usually labeled, in a window into which our program can 
write a Siring 
a vector of Buttons 
43. 

440 
CHAPTER 13 • GRAPHICS ClASSES 
TIle source code is organized into files like this: 
Graphics interface source files 
Poinl.h 
Point 
Graph.h 
Window.h 
Simple_window.h 
GUI.h 
all other graphics interface classes 
Window 
Simple_window 
Button and the other CUI classes 
definitions of functions from Graph.h 
definitions of functions from Window.h 
definitions of functions from GUl.h 
Graph.cpp 
Window.ccp 
GUl.cpp 
In addition to the graphics classes, we present a class that happens to be useful 
for holding collections for Shapes or Widgets: 
A container of Shapes or Widgets 
a vector with an interface that makes it convenient for holding 
unnamed elements 
When yOll read the following sections, pIcase don't move too fast. 111cre is litlie 
that isn't pretty obvious, but the purpose of this chapter isn't just to show you 
some pretty pictures - you see prettier pictures on your computer screen or tele-
vision every day. TIle main points of this chapter arc 
To show the correspondence between code and the pictures produced. 
To get you used to reading code and thinking about how it works. 
To get you to think about the design of code - in particular to think 
about how to represent concepts as classes in code. Why do those classes 
look the way they do? How else could they have looked? We made 
many, many design decisions, most of which could reasonably have been 
made differently, in some cases radically differently. 
So please don't nlsh. U you do, you'll miss something important and you might 
then find the exercises unnecessarily hard. 
13.2 Point and Line 
~nle most basic part of any graphic system is the point. To define tmin! is to define 
how we organize our geometric space. Here, we usc a conventional, computer-

13.2 
POIN T AN D LI N E 
oricntcd layout of two·dimensional points defined by (x,y) integer coordinates. As 
described in § 12.5, x coordinates go from 0 (representing the left·hand side of the 
screen) to max_xO (representing the right·hand side of the screen); y coordinates 
go from 0 (representing the tOp of the screen) to max_yO (representing the botmm 
of the screen). 
As defined in Point.h, Point is simply a pair of ints (the coordinates): 
slrucl Point ( 
int x, y; 
Point(int xx, int yy) : x(xx), y(yy) ( ) 
Poinl() :x(O), y(O) { } 
) ; 
bool operator==(Point a, Point b) { return a.x==b.x && a.y==b.y; } 
bool operator!=(Point a, Point b) { return !(a==b); ) 
In Graph.h, we find Shape, which we describe in detail in Chapter 14, and Line : 
strucl Line : Shape ( 
line(Poinl pl, Point p2); 
} ; 
/I a Line is a Shape defined by two Points 
1/ construel a Line from Iwo Points 
A Line is a kind of Shape. 111at's what ": Shape" means. Shape is called a base 
d(lJS for Line or simply a baJe of Line. Basically, Shape provides the facilities 
needed to make the definition of Line simple. Once we have a feci for the partie· 
ular shapcs, such as Line and Open_polyline, we'll explain what that implies 
(Chapter 14). 
A line is defmed by two Points. Leaving out the "scaITolding" (#indudes, 
etc. as described in § 12.3), we can create lines and cause them to be drawn like 
this: 
1/ draw two lines 
Simple_window winl(Poinl(l00.l00),600,400. "two lines"); 
Line horizontal(Point(100,l00),Point(200,l00»; 
1/ make a horizontal line 
Line verlical(Point(l50,50).Point(l50,l50»; 
II make a verlical line 
winl .atlach(horizontal); 
1/ attach the lines to the window 
winl .allach(vertical); 
/I display! 
441 

442 
( HAPTER J3 • GRAPHICS ClASSES 
Executing that, we gel 
As a user imcrfacc designed for simplicity, line works quite well. YOli don't need 
LO be Einstein to guess that 
line verlical(PoinI(150,SO),Point(150,15O»; 
creales a (vertical) line from (150,50) to (150,150). "nlcrc arc, of course. imple-
mentation details, but yOll don't have to know those to make lines. 111C imple-
mentation of line's constructor is correspondingly simple: 
line:: line(Point pl , Point p2) 
/I construct a line from IwO points 
{ 
) 
add(pl); 
add(p2); 
1/ add pIta this shape 
/I add p2 to this shape 
That is, it simply "adds" twO points. Adds LO what? And how docs a line get 
drawn in a window? 111e answer lies in the Shape class. As we'll describe in 
Chapter 14, Shape can hold points defining lines, knows how to draw lines de" 
fined b)' pairs of Points, and providcs a function add() lhal allows an object to 
add to its Shape. TIle ke)' point (sic!) here is that defining Line is trivial. Most of 
lhe implemcntation work is donc by "the system" so that we can conCClllratc on 
writing simple classes thal arc easy to usc. 

13 .3 
LIN ES 
From now on we'll leave Out the definition of the Simple_window and the 
calls of allachO. l 110se arc just more "scaffolding" that we need for a complete 
program but that adds little to lhe discussion of specific Shapes. 
13.3 Lines 
As it tums OUl, we rarely draw just one line. We tend to think in terms of objects 
consisting of many lines, such as triangles, polygons, paths, mazes, grids. bar 
graphs, mathematical functions, graphs of data, etc. One of lhe simplest such 
"composite graphical object classes" is lines : 
slrucllines : Shape { 
/I related lines 
void drawJinesO consl; 
void add(Poinl pl , Poinl p2); 
/I add a line defined by two poinls 
); 
A lines object is simply a colleClion of lines, each defined by a pair of Poinls. Fo r 
example, had we considered the two lines from the line examplc in §13.2 as part 
of , 1 single graphical object, we could have defined them like this: 
lines x; 
x.add(Poinl(lOO,loo), Poinl(20Q,100» ; 
x.add(Point(15O,5O), Poinl(15O,15O»; 
/I first line: horizontal 
/I second line: verlical 
lllis brives output 11m! is indistinguishable (to the last pixel) from the line version: 
+ 
443 

444 
CHAPTER 13 • GRA PH ICS CLASSES 
111C only way we can tell that this is a different window is that we labeled them 
differently. 
TIle difference between a set of Line objects and a set of lines in a lines ob· 
ject is completely one of our view of what's going on. By using Lines, we have ex· 
pressed our opinion that the two lines belong lOgemC!' and should be 
manipulated together. For example, we can change the color of all lines lhal arc 
part of a Lines object with a single command. On lhe Olher band, we can give 
lines that are individual line objects different colors. As a more realistic example, 
consider how to dermc a grid. A grid consists of a number of evenly spaced hori· 
zontal and vertica1lines. H owever, we think of a grid as one "thing," so we define 
those lines as part of a Lines object, which we call grid: 
inl x_size = win3.x_maxO; 
int y_size = win3.y_maxO; 
int x-8rid = 80; 
/I get the size of our window 
int Y-8rid = 40; 
lines grid; 
for (inl x=x-8rid; x<x_size; x+=x-8rid) 
grid.add(Point(x,O),Point(x,y_size»; 
for (inl y = y...,grid; y<y_size; y+=Y-8rid) 
grid .add(Poi nt(O, y), Poi nt (x_size, y»; 
/I vertical line 
/I horizontal line 
Note how we get the dimension of our window using x_maxO and y _max(). 111is 
is also the first example where we are writing code that computcs which objects 
we want to display. It would have been unbearably tedious to define this grid by 
defining one named variable for each grid line. From thal code, we get 

13.4 
COLOR 
Let'S reLUrn (0 the design of lines. How are the mcmber functions of class 
lines implemcnted? lines provides juSt twO operations. The addO function sim-
ply adds a Iinc defined by a pair of points to thc set of lines to bc displayed: 
void lines: :add(Point pl , Point p2) 
( 
Shape:: add(pl); 
Shape: :add(p2); 
Yes, the Shape:: qualification is needed because Olhcrwise the compilcr would 
see add(pl) as an (illegal) attempt to call lines' addO rathcr than Shape's addO. 
-nlC drawJinesO function draws thc lincs defined using addO: 
void lines: : draw~ lin esO const 
( 
if (colorO,visibililyO) 
for (int i=l ; i<number_oCpointsO; i+=2) 
fUi ne(poi nt(i-l). x, poi nt ( i ~ 1). y,poi n I (i), x ,pain t (i), y); 
) 
That is. lines: :drawJinesO takes two points at a time (starting wiul points 0 and 
I) and draws the line bctween them using ule underlying library's line-drawing 
fUllction (fl_drawO). Visibility is a property of U1C lines' Color object (§13.4), so 
we have to chcck Ulat the lines arc meant to be visible before drawing them. 
As we cxplain in Chapter 14, draw_Jines() is called by "thc system." "Ve don't 
need to check that the number of points is even - lines' addO can add only pairs 
or poims. -n lc runctions numbcr_oCpointsO and point() are defined in class 
Shape (§ 14.2) and have uleir obvious meaning. These two runctions provide 
rCild-only access to a Shape's points. -nle member runction draw_linesO is de· 
fined tD be canst (sec §9.7.4) because it docsn't modiry lhe shape. 
We didn't supply lines with a constructor because the model or starting out 
with no points and then addOing points as needed is more flexible than any con· 
stnlctor could be. We could have provided constructors ror simple cases (such as 
1, 2, and 3 lines) or ror an arbitrary number or lines, but there didn't seem to bc 
a real need. Ir in doubt, don't add runctionality. You can always add to a design if 
need is demonstrated, but you can rarely removc racilities from code lhat has 
round its way into usc. 
13.4 Color 
Color is the type we usc to represent color. We can use Color like this: 
grid.set_color(Color: :red); 
445 

446 
C HAPTER 13 • GRAPHI CS C LA SSES 
111is colors the lines dcrmcd in grid red so that we get 
Color defines the notion of a color and gives symbolic names to a few of the 
morc conunon colors: 
slrucl Color { 
enum Colof_type ( 
); 
red=FL_REO, 
blue=Fl_BLUE. 
green=FL_GREEN, 
yellow=Fl_YEllOW, 
white=FL_WHITE, 
black=FL_BLACK, 
magenta=FL_MAGENTA, 
cyan=Fl_CYAN, 
dark_red=FL_DARK_RED, 
dark...green=Fl_DARK_GREEN, 
dark_ycllow=Fl_DARK_YELLOW, 
dark_blue=Fl_DARK_BLUE, 
dark_magenta=Fl_OARK_MAGENTA, 
dark_cyan=Fl_DARK_CYAN 
enum Transparency { invisible = 0, visiblc=255 }; 
Color(ColoUype ee) :c(FI_Color(cc)), v(visible) () 

13.4 
COLOR 
Color(ColoUype cc, Transparency vv) : c(FI_Color(cc» , v(vv) {} 
Color(inl cc) :c(FI_Color(cc», v(visible) () 
ColorCTransparency vv) : c(FI_ Color()), v(vv) { } 
/I default color 
int as_intO consl { return Ci ) 
char visibililyO canst { return Vi } 
void set_visibilityCTransparency vv) {v=vv;} 
private : 
char Vi 
/I invisible and visible for now 
FI_Color Cj 
) ; 
~nle purpose or Color is 
To hide the implementation's notion or color, FLTK's FI_Color type 
1'0 give the color constants a scope 
To provide a simple version or transparency (visible and invisible) 
You c.."ln pick colors 
From the list or named colors, ror example, Color: :dark_blue. 
By picking from a small Mpalelte" or colors that most screens display well 
by specirying a value in the range 0-255; ror example, Color(99) is a 
dark green. For a code example, see §13.9. 
By picking a value in the ReB (red, green, blue) system, which we will 
nOt explain here. Look it up ir you need it. In particular, a search ror 
"ReB color" on the wcb gives many sources, such as www.hypcrsolu-
tiolls.orglrgh.hwll and ww,v.piu.edul-nisglcis/web/cgilrgb.html. See also 
exercises 13 and 14. 
Note the usc or constructors to allow Colors to be o·cated cither rrom the 
Color_type or rrom a plain into The member c is initialized by each constructor. 
You could argue that c is too short and too obscure a name to use, but since it is 
lIsed only within the small scope or Color and not intended ror general use, that's 
probably OK. We made the member c private to protect it rrom direct use rrom 
our lIsers. loo r Ollr representation or the data member c we lise the FLTK type 
FI_Color lhat we don't really want to expose to our users. However, looking at a 
color as an int representing its ReB (or other) value is very common, so we sup-
plied as_intO ror that. Note that asjntO is a canst member because it doesn't ac-
tually change the Color object that it is used ror. 
TIle transparency is represented by the member v which can hold the values 
Transparency: :visible and Transparency: :invisible, with their obvious meaning. 
It may surprise you that an "invisible color" can be useful, but it can be most us e~ 
ful to have part or a composite shape invisible. 
447 

CHAPTER 13 • GRAP HICS ClASS ES 
13.5 Line_style 
When we draw several lines in a window, we can distinguish them by color, by 
style, or by bOlh. A line style is me pattern used to outline the line. \Ve can use 
line_style like mis: 
grid.set_style(line_style : :dot); 
lllis displays the lines in grid as a sequence of dots rather than a solid line: 
~nlat "minned out" me grid a bit, making it more discreet. By adjusting the width 
(thickness) we can adjust the grid lines to suit our taste and needs. 
TIle line_style type looks like mis: 
struclline_style { 
enum line_style_lype { 
solid=Fl_SOllD, 
dash=Fl_DASH, 
} ; 
dot=Fl _DOT, 
dashdot=Fl _DASHDOT, 
dashdoldot=Fl_DASHDOTDOT, 
/I ...... . 
1/ . .. . 
/I ..... .. 
1/ . .. . 
/I .... .. 
line_slyle(line_slyle_type ss) :s(ss), w (O) { ) 
line_style(line_style_type lSi, int ww) :s(1sl), w (ww) {} 
line_style(inl ss) :s(ss), w (O) { } 

13.5 
UNCSTYLE 
int widthO const { return Wi } 
int styleO const ( return S j } 
private : 
int s; 
int W j 
} ; 
"nle programming tedmiqucs for defming line_style are exactly the same as the 
oncs we used for Color. Here, we hide the fact that FI.;T'K uscs plain ints to repre-
sent line styles. Why is somcthing like that worth hiding? Because it is exactly sllch 
a detail that might change as a Library evolves. TIle next FLTK release might vcry 
well have a FU inestyle type, or we might rctarget our interface classcs to SOUlC 
otller C U I library. In either case, we wouldn't like to have our code and our uscrs' 
code littered with plain ints tllat wc just happened to know represent line styles. 
Most of the time, we don't worry about Style at all; we juSt rely on the de-
fault (default width and solid lines). This default line width is defined by the COIl-
structors in the cases where we don't specify one explicitly. Setting defaults is one 
of the things tllat constructors arc good for, and good defaults can significantly 
help users of a class_ 
Note that Line_style has two "components": the style proper (e_g_, lise dashed 
or solid lines) and width (the thickness of the line used). TIle width is measured in 
integers_ TIle default width is 1. We can requcst a fat dashed line like tills: 
grid. seCstyle(Li n e_styl e(li ne_style : : dash ,2»); 
449 

450 
CHAPTER 13 • G RAPHICS CL ASS ES 
Note that color and style apply to alIlincs of a shape. That is one of the advan-
tages of grouping many lines into a single graphics object, such as a lines, 
Open_polyline, or Polygon. If we wam to comrolthc color or style for lines sep-
arately, we must define them as separate lines. For example: 
horizontal.sel_color(Color:: red); 
vertical.scl_color(Color: : green); 
This gives us 
13.6 Open_polyline 
An Open_polyline is a shape that is composed of a series of connected line seg-
ments defined by a series of points. fbly is the Creek word for "many," and jJO/)'lille 
is a fairly conventional name for a shape composed of many lines. For example: 
Open_polyline opl; 
opl.add(Point{l00,l00»; 
opl.add(Poinl(150,200»; 
opl.add(Poinl(250,250» ; 
opl.add(Poinl(JOO,200)); 
rnlis draws lhc shape lhal you gel by COIUlCCting thc points: 

Uasically, an Open_polyline is a fancy word for what we encountered in kindcr-
ganen playing "Connect the Dots." 
Class Open_polyline is defined like this: 
strucl Open_polyline : Shape { 
/I open sequence of lines 
void add(poinl p) {Shape: :add(p); ) 
) ; 
Yes, lImt's the complete definition. TIlere is literally nothing to Open_polyline ex-
cept its name and what it inherits from Shape. Open_polyline's addO function is 
there simply to allow the users of an Open_polyline to acccss the addO from Shape 
(tbat is, Shape : :addO). \r\'e don't even need to define a draw_linesO because Shape 
by default interprets the Poinls add Oed as a sequence of connected lincs. 
13.7 Closed_polyline 
A Closed_polyline is just like an Open_polyline, except that we also draw a line 
from the last point to the first. For example, we could usc the same points we 
used for the OlJen_polyline in §13.6 for a Closed_polyline : 
Closed_polyline cpl; 
cpl.add(Point(100,l00»; 
clJl.add(Poi nl(15O ,200)); 
cpl.add(Point(25O,25O)); 
cpl.add(Poi nl(300 ,200)) ; 
451 

452 
CHAPTER 13 • GRAPHICS ClASSES 
111c result is (of course) identical to that of §13.6 except [or that final closing line: 
TIle definition of Closed_polyline is 
strUt t Closed_polyline: Open_polyline ( 
/I closed sequence of lines 
void draw_linesO consl; 
}; 
void Closed_polyline: :draw_linesO consl 
( 
} 
Open_polyline: :draw_linesO; 
/1 first dr(lw the "open polyline part" 
IIthcn draw closing line: 
if (colorO.visibility()) 
fUi ne(poi nt(n umber _oCpoints()-l ). '" 
poi nt(n umber _ oCpoi nts()-l ). y, 
point(O).x, 
point(O).y); 
Closed_polyline needs its own draw_linesO to draw that closing line connecting 
the last point to lhc first. Fortunately, we only have to do the little detail where 
Closed_polyline differs from what Shape olTers. 111at'5 important and is somc-
times called "programmillg by diffcrcnce." We need to program only what's dif-
fercm about our derived class (herc, Closed_polyline) compared to what a base 
class Olcre, Open_polyline) a lTers. 
So how do we draw that dosing line? ' <\fe use the FLTK line-dnlwing fu nction 
fUincO. It Lakes four inis rcpresenting two points. So, here thc undcrlying b'1 .... phics 
libllllY is again used. 
otC, howcver, that - as in every other casc - the mcntion of 

13 .8 
POLYGON 
FLTK is kept \\~thin the implementation of our class rather than being exposed to 
our users. No user code needs to mention fUineO or to know about interfaces 
where points appear implicit..ly as integer pairs. If we wanted to, we could replace 
FLTK \,~th another GUI library \\'ilh vel)' litt..le impact on our users' code. 
13.8 Polygon 
A Polygon is very similar to a C1osed~p o l y lin e . "n le only difference is that for 
Polygons we don't allow lines to cross. For example, the Closed_polyline above 
is a polygon, but we can add another point: 
cpl.add (Pain I (1 00,250» i 
111e result is 
According to classical definitions, this Closed_polyline is not a polygon. How do 
we define Polygon so that we correctly capture the relationship to Closed-Jloly· 
line without violating the rules of geometry? The presentation above contains a 
strong hint. A Polygon is a Closed_polyline where lines do not cross. Alterna-
tively, we could emphasize the way a shape is built out of points and say that a 
Polygon is a Closed_polyline where we cannot add a Point that defines a linc 
segmem that imersects one of the existing lilles of the Polygon. 
Given that idea, we define Polygon like this: 
slrucl Polygon : Closed_polyline ( II closed sequence of non intersecting lines 
void add(Point p); 
void draw_linesO const; 
) ; 
453 

454 
void Polygon: :add(Point p) 
( 
CHAPTER 13 • GRAPH ICS ClASSES 
/I check that the new line doesn't intersect existing lines 
Shape::add(p); 
} 
Here we inherit Closed_polyline's dcfmition of draw_linesO, thus saving a fair bit 
of work and avoiding duplication of code. Un[onunatcly, we have to check each 
add(). That yields an inefficient (order N-squarcd) albroritlUll - defining a Polygon 
\\~lh N points requires N"(N'-1)12 call of inlerseCiO. In effect, we have made lhe as-
sumption thm Polygon class will be used for polygons of a low number of points. 
For cXilll1plc, creating a Polygon with 24 Points involves 24-(24-1)12 == 276 c.,tlls 
of interseclO. "n lat's probably acceptable, but if we wanted a polygon with 2000 
points it would cost liS about 2,000,000 c.:11Is, and we might look for a better algo-
rithm, which might require a modified imerface. 
Anyway, we can create a polygon like t..his: 
Polygon poly; 
poly.add(Poinl(l00,l00»; 
poly.add(Poinl(150,200»; 
poly.add(Poinl(250,250»; 
poly.add(PoinI(300,200»; 
Obviously, t..his creates a Polygon t.hat (t.o t.he last. pixel) is identical to our original 
Closed_polyline : 

13.9 
RECTANGLE 
Ensuring t.hat a Polygon rcally represents a polygon turned out to bc surprisingly 
messy. TI1C chcck for intcrscction that we left out of Polygon: :addO is arguably 
the most complicated in the whole graphics library. If you are iIllcrested in fiddly 
coordinate manipulation of geometry, have a look at the codc. And even then wc 
are not. done. Consider trying to make a Polygon with only t\\l0 Points. We'd bct-
ter protect against that: 
void Polygon: :drawJinesO const 
{ 
) 
if (number_oCpointsO < 3) error("less than 3 points in a Polygon"); 
Closed_polyline:: draw_linesOi 
TIle trouble is t.hat Polygon's invariant "the points represent a polygon" can't. be 
verified until all points have been defmed; thal is, we are nOt - as strongly rec· 
ommcnded - establishing Polygon's invariant in its constructor. Placing the "at 
1C<lst three points" check in Polygon::draw_linesO is a fairly disreputable trick. 
See also exercise 18. 
13.9 Rectangle 
'11e most common shape on a screen is a rectangle. The reasons for that are 
partly cultural (most of our doors, windows, pictures, walls, bookcases, pages, 
etc. arc also rectangular) and partly technical (keeping a coordinate witllin rectan-
gular space is simpler than for any other shaped space). Anyway, rectangles arc 
so common that G UI systems suppOrt them directly rather than treating them 
simply as polygons lImt happen to have four comers and right angles. 
slruct Rectangle: Shape ( 
Rectangle(Point xy, int hh, int WW)i 
Rectangle(Point x, Point y)i 
void draw_linesO const; 
int hcightO const { return hi } 
int widfhO const { relurn Wi } 
private: 
inl h; 
inl w; 
); 
/I height 
II width 
455 

456 
CHAPTER 13 • GRAPHICS CLASSES 
We can specify a rectangle by two points (top left and botlom right) or by one 
point (top Icft) and a width and a hcighL The conSlnlctors c.'m be defmed like t.his: 
Rectangle: :Rectangle<Point xl', int WW, int hh) 
: w(ww), h(hh) 
{ 
if (h<=O II w<=O) 
error(ltBad rectangle: non·positive side"): 
add(xy); 
) 
Rectangle: :Rectangle(Point x, Point y) 
:w(y.x-x,x), h(y.y-x.y) 
{ 
if (h<=O II w<=O) 
e rror("8ad rectangle: non-positive width or height"); 
add(x); 
) 
Each constructor initializes the members h and w appropriately (using lhe Olem" 
ber initialization syntax; see §9.4.4) and stores away the top left corner paim in 
the Rectangle's base Shape (using addO). In addition, it docs a simple sanity 
check: we don't really want Rectangles with negative width or height. 
One of the reasons that some graphicsJG U I SySLCllls U"eat rectangles as special 
is that the algorithm for determining which pixels arc inside a rectangle is far sim-
pler - and therefore far faster -
than for other shapes, such as Polygons and 
Circles. Consequently, the notion of "fIll color" - that is, the color of the space in-
side lhe rectangle - is more commonly used for rectangles lhan for other shapes. 
We can set the fill color in a constructor 0 1' by the operation seCfilCcolorO (pro-
vided by Shape LOgelher wilh the other services related to color): 
Rectangle reetoo(PoinI(15O, 100),200, 100); 
Rectangle reet11 (Point(5O,5O),Point(25O, 150)); 
Rectangle reet12(Point(5O,15O),Point(250,25O)); 
Rectangle reet21 (Point(250,5O),2oo, 100); 
Rectangle rect22(Point(25O, 150),200, 100); 
rectoo. scCfill_ colo r(Colo r: : yellow); 
rcct11 .scCfill_colo r(Colo r:: blue); 
reet12.scCfill_colo r(Colo r:: red); 
rcct21 .scCfill3 0Io r(Colo r: :grccn); 
~ntis produces 
II juS! below reell1 
/I juS! to the right of rect 11 
/I just below rect21 

1 j.9 
RECTAN GL E 
\Vhcn you don't havc a fill color, the rectanglc is transparelll; that's how you can 
see a corner of the yellow reetOO. 
We can move shapes around in a window (§14.2.3). For eXillllple: 
rect11.move(400,O); 
/I to the right of rect21 
rcct11 .seCfiICcolor(Color: : while); 
win12.scUabel("rectangles 2"); 
111is produces 
457 

'58 
CHAPTER 13 • GRAPH ICS CLASSES 
Note how only part of the while recl11 fiLS in the window. What doesn't fit is 
"clipped"; thal is, it is not shown anywhere on the screen. 
Note also how shapes are placed one on top of another. ~111is is done J USt like 
you would put sheets of paper on a table. 111C first one yOli put will be onlhc bOl-
tom. OUf Window (§E.3) provides a simple way of reordering shapes. YOll c.1.11 tell 
a window to put a shape on tOp (using Window: :put_on_topO). For example: 
win12.pul_on_lop(reclOO); 
win12.seClabel{"rectangles 3"); 
111is produces 
NOle that we t.:1.11 sec the lines that make up the rectangles even though we have 
filled (all but one of) them. Jr.-ve don't like those outlines, we can remove them: 
rectOO,seCcolor(Color: : invisible); 
rect11 .sel_color(Color: : invisible); 
rect12.set_color(Color:: invisible); 
rect21.sel_color(Color: : invisible); 
rect22.seCcolor(Color: : invisible); 
We get 

13 . 10 
MANAGING U NNAMED O BJECTS 
Note that with bOlh fill color and line color set lO invisible, rect22 ca.n no longer 
be seen. 
Because it has to deal with both line color and fill color, Rectangle's 
draw_lincsO is a bit messy: 
void Rectangle: :drawJinesO consl 
{ 
} 
if (fill_colorO. visibility()) ( 
1/ fill 
} 
fI_ color(£ill_ colo rO .as_in to); 
fUectf(poin t (0). x, point(O). y, w, h); 
if (color().visibilily()) ( 
II lines on lop of fill 
fI_ eolor( colorO .asj nIO); 
f1_rect(poi nl(O).x, poi nI(O). y, w, h); 
} 
As you em sec, FLTK provides functions for drawing rectangle flll (ft rceUO) and 
rectangle oullines (fUectO). By default, we draw both (wim the lines/outline on tOp). 
13.10 Managing unnamed objects 
So faJ', we have named all our graphicli objects. When we want lots of objects, 
this becomes infeasible. As an example, let us draw a simple color chart of the 
256 colors in FLTK's paleue; that is, let's make 256 colored squares and draw 
459 

C HAPTER 13 • GRAI)HI (S ( LASSE S 
them in a 16-by-16 matrix that shows how colors with similar color valucs relate. 
First, here is thc result: 
Naming those 256 squares would not only be tedious, it would be silly. TIle obvi-
ous "name" of the top left square is its location in the matrix (0,0), and any Olher 
square is similarly identified ("named") by a coordinatc pair (i,j ). ,"Vhat we need 
for this example is the equivalent of a matrix of objects. We thought of using a 
vectof<Rectangle>, but that tumcd out to be not quite flexible enough. For eXaIn-
pic, it can be useful to have a collection of unllaIned objects (clements) that arc not 
all of the same type. We discuss that flexibility issue in §14.3. Here, we'll just pres-
ellt our solution: a vector type that can hold named and unnamed objects: 
template<class T> class Vector_ref ( 
public: 
} ; 
II ... 
void push_back(T&); 
void push_back(P); 
II add a named object 
II add an unnamed object 
T& operator[J(int i); 
II subscripting: read and write access 
canst T& operatorlJ(int i) canst; 
inl sizeO canst; 
TIle way you usc it is very much like a standard library vector: 
Vector_rekReclangle> rect; 

13. 10 
MANAGIN G U NNAMED OBJE CTS 
Rectangle x (Poin I (1 00,2(0), Poinl(200 ,3(0» ; 
reCl.push_back(x)i 
II add named 
recl.push_back(new Reciangle(Point(50,60),Point(80,90))); 
/I add unnamed 
for (in I i=O; krect.size(); ++i) recl[i).move(10,10); 
/I usc rcct 
vVe expbin the new operator in Chapter 17, and the implementation of Vector_ref 
is presented in Appendix E. For now, it is sufficient to know that we can lise it to 
hold unnamed objects. Operator new is followed by the naille of a type (here, Rec-
tangle) optionally followed by an initializer list (here, (Poinl(50,60),Poinl(80,90))). 
Experienced programmers will be relieved to hear that we did not introduce a 
memory leak in this example. 
Given Rectangle and Vector_ref, we can play with colors. For example, we 
can write a simple color chart of the 256 colors shown above: 
Vector_ref<Rectangle> vr; 
for (int i = 0; k16; ++i) 
for (inl j = 0; j<16i ++j) { 
vr. pu sh_back(n ew Rectangle( Poi nl(i *20,; *20) ,20,20»; 
vrl yr. size()-l J .seUiII_ color{i *16+;); 
wi n20 .attach(vr[ yr. sizeO- 11); 
We make a Veclor_ref of256 Rectangles, organized grdphically in the Window as 
an 8-by-S matrix. We give the Rectangles the colors 0, 1, 2, 3, 4, and so on. After 
each Rectangle is created, we attach it to the window, so that it will be displayed: 
.. , 

462 
( HA PTE R 13 • GRAPHICS CLASSES 
13.11 Text 
Obviously, we WanllO be able to add text to our displays. For example, we might 
want to label our "oddn Closed_polyline from §13.8: 
Te,,' t(Point(200,200),"A closed polyline that isn't a polygon"); 
l.set_color(Color:: blue); 
We get 
Basically, a Text object defines a line of text starting at a Point. TIle Point will be 
the bottom left corner of the text. TIle rcason for restricting the string to be a sin-
gle linc is to ensure portability across systems. Don't try lO put in a newline char-
acter; it Illay or Illay not be represemed as a newline i.n yOllr window. String 
streams (§11.4) arc useful for composing strings for display in Text objects (exam-
ples in §12.7.7 and §12.7.8), Text is defined like this: 
strucl Text : Shape { 
lithe point is the bottom left of the first letter 
Texl(Point x, const string& s) 
: lab(s), (nt(fUonl()), fnl_sz(f1_size()) 
( add (x); } 
void drawJinesO const; 

13. 11 
TEXT 
void seUabel(const string& s) ( lab = s; ) 
string labelO const { relurn lab; } 
void seUonl(Font 0 { fnt = f; } 
Font fonlO consl ( relurn Font(fnt); } 
void seUonCsize(int s) { fn,-sz = s; } 
inl fonCsizeO const { return fnt_5z; } 
private: 
string lab; 
!! Iabel 
Font fnl; 
int fnl_sz; 
}; 
Text has its own draw_linesO because only the Text class knows how its string is 
stored: 
void Text: :draw_linesO consl 
{ 
fC draw(la b. c_strO ,poin I (0). x, point(O). y); 
} 
rnlC color of the characters is detcnnincd exaclly like lhe lines in shapes composed 
of lines (snell as Open_polyline and Circle), so you can choose a color using 
set_colorO and see what color is currcnlly used by calarO. The character size and 
fant are handled analogously. There is a small number of predefined fonts: 
class Font { 
/I character (a nt 
public: 
enum FonUype { 
helvelica=FL_HELVfTICA, 
helvelica_bald=Fl_HELVnICA_BOlD, 
helvetica_i1alic=Fl_HELVfTICA_ITALlC, 
helvetica_boldj talic=Fl_HElVnICA_BOLD_ITAlIC, 
courier=Fl_COURIER, 
courier_bold=FL_COURIER_BOLD, 
cou rie r _ital ic=Fl_ CO U R IER_ITA LI C, 
courie r _bold_italic=Fl_ CO U RI ER_ B OLD_ITA LI C, 
timcs=Fl_TIMES, 
times _bold=FL_ TI MES _BOLD, 
times _italic=Fl_ TIM ES_IT All C, 
.. , 

... 
CHA PTER 13 • G RAPHI CS ClASSES 
Ii mes _ boldj lali c=Fl_ TIMES _BOLO _IT All C, 
symbol=FL_SYMBOl, 
); 
screen=FL_SCREEN, 
screen_bold=FL_SCREEN_BOLD, 
zapCdingbats=Fl _ZAPF _DINGBATS 
Font(FonUype to :f(fO {} 
Font(inl to :f(ff) {} 
int as_intO consl { return fi } 
private: 
int f; 
) ; 
111c Sl yle or class definition lIsed to defme Font is the srune as we used t'O define 
Color (§13.4) and line_style (§13.5), 
13.12 Circle 
J ust to show that the world isn't completely rectangular, we provide class Circle 
and class Ellipse. A Circle is defmcd by a center and a radius: 
struel Circle : Shape ( 
Circle<Point p, int rr); 
/I cenler and rad ius 
void draw_linesO consl; 
Point cente rO consl ; 
int radiusO const { return ' ; } 
void seCradius(int rr) ( r=u; } 
private: 
int ' j 
) ; 
We can usc Circle like this: 
Circle cl (Poinl(100,200),SO); 
Circle c2(Poinl(150,200),100); 
Circle cJ(Poinl(200,200),150); 

13.12 
CIRCL E 
This produces three circles of different sizes aligned with their centers in a hori· 
zontalline: 
"n le main pcculiarity of Circle's implementation is t.hat the point stored is nOt the 
center, but thc top left comer of the square bounding lhe circle. We could have 
stored either but chose the one FLll<. uses for its optimized circle·drawing routine. 
"n l<lt way, Circle provides another example of how a class can be used to present a 
different (and supposedly nicer) view of a conccptlhan its implementation: 
Circle: :Circle(Poinl p, int rr) 
: r(rr) 
{ 
/I center and radius 
add(Point(p.x-r,p. y-r» ; 
II slore lOp left corner 
) 
Point Circle: :cenlerO const 
{ 
return Point(point(O).x+r, point(O).y+r); 
void Circle: :draw_linesO canst 
{ 
if (COIOfO.visibilily()) 
ftarc(poin I (0). x, poi nI(O). y, r+ r, r+r,0,360); 
) 
465 

... 
CHAPTER 13 • G RAPHI CS CLASS ES 
NOle the lise of fI_arcO to draw the circle. ·fbe initial twO arguments specify the 
top left corner, ule next twO arguments specify the width and the height of the 
smallest rectangle that encloses the circle, and the final two arguments specify the 
beginning and end angle to be drawn. A circle is drawn by going the full 360 de-
grees, but we can also usc fCarc() to write parts of a circle (and parts of an el-
lipse); sec exercise 1. 
13.13 Ellipse 
An ellipse is similar to Circle but is defined with both a major and a minor axis, 
instead of a radius; that is, to define an ellipse, we give the center's coordinates, 
the distance from the cenler to a point on the x axis, and the distance from the 
center to a poilll on the )' axis: 
strucl Ellipse : Shape { 
Ellipse(Point p, int w, inl h); 
1/ center, max and min d i~tance from center 
void draw_lines{) consl: 
Point cenler{) consl: 
Point focusl {) conSl: 
Point focus20 consl; 
void seCmajor(inl ww) { w=ww; ) 
int majorO const { return W; } 
void seCminor(int hh) { h=hh: ) 
int minorO const { return h; } 
private: 
} ; 
int Wi 
int h; 
We can usc Ellipse like this: 
Ellipse el (Point(200,200),5O,SO); 
Ellipse e2(Point(200,200),100,5O); 
Ellipse eJ(Point(200,200), 100, 150): 
~Iltis gives LIS three ellipses with a common center but different-sized axes: 

13 . 13 
ELLIPSE 
Note that an Ellipse with major()==minor() looks exactly like a circlc. 
Another popular view of an ellipse specifics two foci plus a sum of distances 
from a point to the foci. Given an Ellipse, we can compute a focus. For example: 
Point Ellipse: :focus1() const 
( 
ret u rn Point( center().x+sqrt(double( w· w - h • h)) ,center(). y); 
) 
Why is a Circle not an Ellipse? Geometrically, every circle is an ellipse, but nOt 
every ellipse is a circle. In particular, a circle is an ellipse where the twO foci arc 
equal. Imagine that we defined our Circle to be an Ellipse. We could do that at 
the cost of needing an extra value in its representation (a circle is defined by a 
point and a radius; an ellipse needs a center and a pair of axes). We don't like 
space overhead where we don't need it, but the primary reason for our Circle not 
being an Ellipse is that we couldn't define it so without somehow disabling 
se'-majorO and se,-minor(). After all, it would not be a circle (as a mathemati-
cian would recognize it) if we could use seCmajorO to get major()!=minorO - at 
least it would no longer be a circle after we had done that. We can't have an ob· 
ject that is of one type sometimes (i.e., when major()!=minorO) and another type 
some mher time (i.e., when major()==minor(»). \>Vhat we can have is an object 
(an Ellipse) thaI can look like a circle sometimes. A Circle, on the mher hand, 
never morphs into an ellipse with (' ... ·0 unequal a.xes. 
46' 

.68 
CHAPTER 13 • GRAPHI CS CLASSES 
When we design classes, we have to be careful nOt to be too clever and not to 
be deceived by OLir "intuition" into defining classes that don't make sense as 
classes in our code. Conversely, we have to take care thaI our classes represent 
some coherent concept and are not just a collection of data and function mem-
bers.Just throwing code together without thinking about what ideas/concepts we 
arc representing is "hacking" and leads to code that we can't explain and that mh-
ers can't maintain. If you don't feci altruistic, remember that "others" might be 
you in a few months' time. Such code is also harder to debug. 
13.14 Marked_polyline 
We orten want to "label" poinLS on a graph. One way of displaying a gntph is as 
an open polyline, so what we need is an open polyline wilh "marks" at lhe 
points. A Marked_polyline docs lhat. For example: 
Marked_polyline mpl("l234"); 
mpl.add(Point(100,100)); 
mpl.add(Point(150,200)); 
mpl.add(Point(250,250)); 
mpl.add(Point(300,200» ; 
"nlis produccs 
TI1C definition of Marked_polyline is 

13 . 15 
MARKS 
struct Marked_polyline : Open_polyline ( 
Marked_polyline(const string& m) :mark(m) { } 
void draw_linesO const; 
private: 
siring mark; 
}; 
By deriving from Open_polyline, we get the handling of Points "for free"; all we 
have to do is to deal with the marks. In particular, draw)inesO becomes 
void Marked_polyline: :draw_linesO consl 
( 
Open_polyline: :draw_linesO; 
for (int i=O; knumber_oCpointsO; Hi) 
draw_mark(point(i),mark[i%mark.sizeOJ): 
,11e call Open_polyline::draw_linesO takes care of the lines, so we just have to 
deal with the "marks." We supply the marks as a string of characters and use 
them in order: the mark[i%mark.sizeOl selects the character to be used next by 
cycling through the characters supplied when the Marked_polyline was created. 
111e % is the modulo (remainder) operator. lbis draw_linesO uses a little helper 
function draw_markO to actually output a letter at a g1ven pouu: 
void draw_mark(Point xy, char c) 
( 
} 
static consl int dx = 4; 
stalic consl inl dy = 4: 
string m(l,c); 
rI_ draw(m. c st rO ,xy. x-dx,xy. y+dy); 
11le dx. and dy constants arc lIsed to center the letter over the point. "n le string m 
is constructed to contain the single character c. 
13.15 Marks 
Sometimes, we want to display marks \vithOlH lines connecting them. We provide 
the class Marks for that. For example, we can mark the four points we have used 
for our various examples without connecting them with lines: 
... 

470 
Marks PP("X")i 
pp.add(Point(l00,lOO»; 
pp .add (Poi nI(150,200»; 
pp .add (Poi nl(250 ,250»; 
pp.add(Point(300,200»; 
111is produces 
• 
CHAPTER 13 • GRAP HI CS CLASS ES 
• 
• 
One obvious lISC of Marks is to display data that represents discrete events so that 
drawing connecting lines would be inappropriate. An example would be (height, 
weight) data for a group of people. 
A Marks is simply a Marked_polyline wilh the lines invisible : 
struct Marks: Marked_polyline ( 
); 
Marks(consl siring& m) :Marked_polyline<m) 
( 
seCcolor(Color(Color:: invisible»; 
) 
13.16 Mark 
A Point is simply a location in a Window. It is not something we draw or some-
thing we can sec. If we wam to mark a single Point so that we can sec it, we can 

13 . 16 
MARK 
indicate it by a pair orIines as in § 13.2 or by using Marks.llmt's a bit verbose, so 
we have a simple version of Marks that is initialized by a point aJld a character. 
For example. we could mark the celllers of OLlr circles from § 13.12 Iike this: 
Mark ml (PoinI(100,200),'. '); 
Mark m2(Poinl(150,200),'y'); 
Mark m3(Poinl(200,200),'z'); 
cl .set_color(Color:: blue); 
c2.set_color(Color:: red); 
cl.set_color(Color:: green); 
• 
, 
A Mark is simply a Marks wilh its initial (and typical only) point given immediately: 
shucl Mark : Marks ( 
); 
Mark(Point . y, char c) : Marks(string(1,c» 
( 
add(xy); 
) 
l11c string(l ,c) is a constnlCtor for string, initializing the string to contain the sin-
gle character c. 
471 

CH APTER 13 • GRAPHI CS CLASSES 
All Mark provides is a conveniem notation for creati.ng a Marks object with a 
single point marked with a single character. Is Mark worth our effort to define it? 
Or is it juSt "spurious complication and confusion"? TIlere is no clear, logical an-
swer. vVe went back and forth on this question, but in the end decided that it was 
useful for users and the effon to define it was minimal. 
Why use a character as a "mark"? We could have used any small shape, but 
characters provide a useful and simple set of marks. It is often useful to be able to 
use a variety of "marks" to distinguish different sets of points. Characters such as 
x, 0 , +, and · are pleasamly symmetric around a cemer. 
13.1 7 Images 
The average personal computer holds thousands of images in filcs and can access 
millions more over the web. Naturally, we want to display some of those images 
in even quite simple programs. For example, here is an image (rita_p.llh .gif) of 
the projected path of the Hurricane Rita as it approached the Texas Gulf Coast: 
H Sult ..... d 004nd. 73 .. ph 
o Su""~d wInd'lIII "'Ph 
POI .... 'I .. O-v ,-3 Tro<' ..... . 
Potential D-V_ Tr •• ~ ..... . 
HIIfTk .... W.t.h 

1). 17 
IMA G ES 
We can selCCt part of that image and add a photo of Rita as seen from space 
(rita.jpg): 
Image rila(Point(O,O), "rita.jpg"); 
Image path(PoinI(O,O)," rita_path.gifll); 
path.seCmask(Point(SO,250),600,400); 
/I select I ikely landfall 
win.attach(path); 
win .altach{rita); 
TIle seCmaskO operation selects a sub-picture of an image to be displayed. Here, 
we selected a (600,400)-pixe\ image from rita_path.gif (loaded as path) with its 
top lefllllost point at path's point (50,600). SeieCling only pmt of an image for dis-
play is so common that we chose to support it directly. 
Shapes arc laid down in the order they are attached, like pieces of paper on a 
desk, so we got path "on the bottom" simply by attaching it before rita. 
Images c.m be encoded in a bewildering variety of formats. Here we deal 
with only twO oftbe most common,JPEC and G IF: 
struct Suffix { 
enum Encoding (none, jpg, gif); 
l; 

474 
C HAPTER 13 • GRA PHI CS ClASS ES 
In our graphics imcrfacc library, wt: represent an image in memory as an objeCl 
of class Image: 
strucllmage : Shape { 
Image(Point xy, string file_name, Suffix: :Encoding e = Suffix: :none) j 
- lmageO { delete Pi } 
void draw_linesO const; 
void seCmask(Point "y, inl ww, inl hh) 
{ w=ww; h=hh; cx=xy.x; cY=XY.Yi } 
private: 
); 
int w,h; 
/I define "masking box ~ within image relative to 
1/ position (ex,cy) 
int u,eYi 
fUmage· Pi 
Text fn ; 
111C Image constructor tries to open a rLle with the name given to it. Then it tries 
to create a picture using the encoding specified as an optional argument or (morc 
often) as a file suffix. If the image cannot be displayed (e.g., because the file wasn't 
found), the Image displays a Bad_image. The definition of Bad_image looks like 
this: 
struct 8adj mage : FUmage ( 
8ad_image(int h, int w) : FUmage(h,w,O) { } 
void draw(int x,int y, int, int, int, int) ( draw_empty(x,y); } 
); 
The handling of images within a graphics library is quite complicated, but the 
main complexity of OUT graphics interface class Image is in the file handling in 
the constructor: 
1/ somewhat overelaborate constructor 
/I because errors related to image files can be such a pain to debug 
Image: :lmage(Point xy, string s, Suffix: :Encoding e) 
:w(O), h(O), fn(xy, "") 
( 
add(xy); 
if (!can_open(s» ( 
/I can we open s? 
fn .set_label("cannot open \""+s+'\"'); 

13 .17 
IMAGE S 
) 
p = new Bad_image(30,20); 
II the ""error image" 
return; 
) 
if (e == SUffi K: :none) e = gel_encoding(s); 
switch(e) ( 
II check if it is a known encoding 
case SuffiK: :jpg: 
p = new FU PEG_lmage(s.c_str(»; 
break; 
case SUffiK: :gif: 
p = new FI_GIF _Image(s.cslr(»; 
break; 
default : 
/I unsupported image encoding 
fn.seIJabel("unsupporled file Iype \''''+s+'\'''); 
p = new Badj mage(30,20); li the "error image" 
We use the suffix to pick the kind of object we create to hold the image (a 
FU PEG_lmage or a FI_GIF _Image). We create that implementation object using 
new and assign it to a pointer. lbis is an implementation detail (see Chapter 17 
for a discussion of operator new and pointers) related to the organization of 
FI..:TK and is of no fundamemal importance here. 
Now, we JUSt have to implement can_openO to test if we can open a named 
file for reading: 
boo! can_open(consl string& s) 
( 
) 
II check if a file named s exists and can be opened for reading 
ifstream ff(s.cstr(»; 
return H; 
Opening a me and then closing it again is a fairly clumsy, bUl effective, way of 
portably separating errors 1·e1ated to "can't open the file" from errors related to 
the format of the data in the file. 
YOli can look up the gecencodingO function, if you like. It simply looks for a 
suffix and looks up that suffIX in a table of Iul0wn suffIxes. 1l1at lookup table is a 
standard library map (sec Chapter 18). 
475 

47. 
CHAPTER 13 • GRAPHICS ClASSES 
~ 
Drill 
1. Make an 800-by-1000 Simple_window. 
2. PlIl an B-by-8 grid on the leftmost 800-by-BOO part of thal window (so 
that each square is 100 by 100). 
3. Make the eight squares on the diagonal starting from the top lert corner 
red (use Rectangle). 
4. Find a 200-by-200-pixcJ image (jPEG or GIF) and place three copies of 
it on the grid (each image covering [our squares). If you can't find an 
image that is exacLly 200 by 200, use seCmaskO to pick a 200-by-200 sec-
tion of a larger image. Don't obscure the fed squares. 
5. Add a lOO-by-lOO image. Have it move around from square to square 
when you click the "Nextlt button. Just put wail_for_buttonO in a loop 
with some code that picks a new square for your image. 
Review 
I. Why don't we "just" lISC a commercial or open-source graphics library 
directly? 
2. Abollt how many classes from our graphics interface library do you need 
to do simple graphic output? 
3. What are the header fLIes needed to use the graphics interface library? 
4. \oVhat classes define closed shapes? 
5. Why don't we just usc line for every shape? 
6. What do the arguments to Point indicate? 
7. Whal are lhe components of line_style? 
8. What arc the components of Color? 
9. \oVhat is RBG? 
10. \oVhat are the differences between two lines and a lines containing twO 
lines? 
11 . \oVhat properties can yOll set for every Shape? 
12. How many sides does a Closed_polyline defined by five Points have? 
13. \oVhat do you see if YOll define a Shape but don't attach it to a Window? 
14. How does a Rectangle differ from a Polygon with four Points (com ers)? 
15. How docs a Polygon differ from a C l osed~p o l ylin e ? 
16. What's on tOp: fill or outline? 
17. Why didn't we bother defining a Triangle class (after all, we did define 
Rectangle) ? 
18. How do you move a Shape to another place in a Window? 
19. How do you label a Shape with a line of text? 
20. 'What properties can yOll set for a text string in a Text? 

ClMPTER !J EXE RCISES 
21. What is a fOIll and why do we care? 
22. \.vhat is Vector_ref for and how do we usc it? 
23. What is the difference between a Circle and an Ellipse? 
24. W hat happens if you try to display an Image given a me name that doesn't 
refer to a rtle containing an image? 
25. How do you display part of an image? 
Terms 
closed shape 
color 
ellipse 
fill 
font 
font size 
GIF 
Exercises 
Lmage 
image encoding 
invisible 
JPEG 
line 
line style 
open shape 
point 
polygon 
polyline 
ULUlamed object 
Vector_ref 
visible 
For each "defme a class" exercise, display a couple of objects of the class to dem-
onstrate that they work. 
I . Define a class Are, which draws a part of an ellipse. Hint: fl_arcO. 
2. Draw a box with rounded comers. Define a class Box, consisting of four 
lines and four arcs. 
3. Define a class Arrow, which draws a line with an arrowhead. 
4. Define functions nO, sO, eO, wO, centerO, neO, seO, swO, and nwO. Each 
takes a Rectangle argument and returns a Point. These functions define 
"connection points" on and i.n the rec[angle. For example, nw(r) is the 
northwcst (top left) corner of a Rectange called r. 
5. Define the functions from exercise 4 for a Circle and an Ellipse. Place the 
connection points on or outside the shape bm not outside the bounding 
rectangle. 
6. Write a program that draws a class diagram like the one in §12.6. It will 
simplify matters if you start by defining a Box class that is a rectangle 
with a text label. 
7. Make an RGB color chart (e.g., see www.lnelceillraJ.comJrgb·color-
chan.hunl). 
8. Define a class Hexagon (a hexagon is a regular six·sided polygon). Usc 
the center and the distance from the cemer 10 a comer point as conSlnLC' 
tor arguments. 
9. Tile a part of a window with Hexagons (usc at least eight hexagons). 
477 

I 
478 
CHAPTER 13 • GRAPHICS CLASSES 
10. Define a class Regular_polygon. Usc the center, the number of sides 
(>2), and the distance from the center to a corner as construclOr argu-
ments. 
11. Draw a 300-by-200-pixcl ellipse. Draw a 400-pixel-long x axis and a 300-
pixel-longy axis through the center of the ellipse. Mark the foci. Mark a 
point on the eUipse that is not on one of the axes. Draw the two lines 
from the foci to the point. 
12. Draw a circle. Move a mark around on the circle (let it move a bit each 
time you hit the "Next" button). 
13. Draw lhc color matrix from §13.10, but without lines around each color. 
14. Define a right triangle class. Make an octagonal shape Olll of eight right 
triangles of different colors. 
15. "Tile" a window with small right triangles. 
16. Do the previous exercise, but with hexagons. 
17. Do lhc previous exercise, but using hexagons of a few different colors. 
18. Define a class Poly that represents a polygon but checks that its points 
really do make a polygon in its constructor. Hint: You'll have to supply 
the points to the constructor. 
19. Define a class Star. One parameter should be the number of points. 
Draw a few stars with differing numbers of points, differing line colors, 
and differing fill colors. 
Postscript 
C hapter 12 showed how to be a user of classes. TItis chapter moves us one level 
up the "food chain" of programmers: here we become tool builders in addition to 
being tool users. 

\t 
"-· 14 
Graphics Class Design 
"Functional, durable, beautiful." 
-Vitruvius 
T
he purpose of the graphics chapters is dual: we walll to 
provide useful tools for displaying infomlalion. but we also 
usc the family of graphical interface classes to illustrate general 
design and implementation techniques. In particular, this chapter 
presents some ideas of interface design and the notion of inheri-
tance. AJong the way, we have to take a slight detour to examine 
the language features that most directly suppon object-oriented 
programming: class derivation, virtual fu nctions, and access con-
trol. We don't believe that design can be disclissed in isolation 
frolll lISC and implemcmation, so our discussion of design is 
rather concrete. Maybe you'd beuer think of this chapter as 
"Graphics Class Design and Lllplcmcntation," 

14.1 Design principles 
14.1.1 Types 
14.1.2 Operations 
14.1.3 Na.ming 
14.1.4 Muta.bility 
14.2 Shape 
14.2.1 An abstra.ct class 
14.2.2 Access control 
14.2.3 Dra.wing shapes 
14.2.4 Copying ;lnd mutability 
14.1 Design principles 
C HAPTER 14 • G RAPHI CS CLASS DESIGN 
14.3 Base and derived classes 
14.3.1 Objectla.yout 
14.3.2 Deriving cl.lsses and defining 
virtua.l functions 
14.3.3 Overriding 
14.3.4 Access 
14.3.5 Pure virtua.l functions 
14.4 Benefits of object·oriented 
programming 
"Vhat arc the design principles for our graphics interface classcs? First: What 
kind of question is that? What arc "design principles" and why do wc need to 
look at those instead of gening on with the serious business of producing ncat 
pictures? 
14.1.1 Types 
Craphics is an example of an application domain. So, what we arc looking at 
here is an example of how to prcsent a set of fundamental application concepts 
and facilities to programmers (like us). If the concepts arc presented confusingly, 
inconsistently, incompletely, or in other ways poorly represented in our code, the 
difficulty of producing graphicru output is increased. We want our graphics 
classes to minimize the effort of a programmer uying to leam and to usc them. 
Our ideal of program design is to represent the concepts of the application 
domain directly in code. TIl.H way, if you understand the applicmion domain, 
you understand the code and vice versa. For example: 
Window - a window as presented by the operating system 
Line - a line as you sec it on the screen 
Point - a coordinate point 
Color - as you see it on the screen 
Shape - what's common for all shapes in our graphics/CUI view of the 
wol'ld 
TIle last example, Shape, is different from the rest in that it is a generalization, a 
purel)' abstract notion. We never see just a shape on the screen: we see a particu-
lar shape, such as a line or a hexagon. You'll find that renectcd in the definition of 
our types: try to make a Shape variable and the compiler will SlOp you. 

14 . 1 
DESIGN PRINCIPLES 
The sct of our graphics imerfacc classes is a library; the classes are meant to 
be used together and in combination. They arc meant to be used as examples to 
follow when you define classes to represent other I,'l'aphieal shapes and as build-
ing blocks for such classes. We are not just defining a set of unrelated classes, so 
we can't make design decisions for each class in isolation. Together, our classes 
preselll a view of how to do graphics. We must ensure that this view is reason-
ably elegant and coherent. Civen the size of our library and the enormity of the 
domain of graphical applications, we cannot hope for completeness. Instead, we 
aim for simplicity and extensibility. 
In fact, no class library directly models all aspects of its application domain. 
"n mt's not only impossible; it is also pointless. Consider writing a library for dis-
playing geographical information. Do you want to show vegetation? National, 
state, and other political boundaries? Road systems? Railroads? Rivers? High-
light social and economic data? Seasonal variations in temperature and humid-
ity? 'Wind patterns in the atmosphere above? Airline routes? Mark the locations 
of schools? The locations of fast-food "restaurants"? Local beauty spots? "All of 
IImt t" may be a good answer for a comprehensive geographical application, but it 
is not an answer for a single display. It may be an answer for a library supporting 
such geographical applications, but it is unlikely that such a library could also 
cover other graphical applications such as freehand drawing, editing photo-
graphic images, scientific visualization, and aircraft control displays. 
So, as ever, we have to decide what's important to us. In this case, we have to 
decide which kind of graphics/C U I we want to do well. Trying to do everything 
is a recipe for failure. A good library directly and cleanly models its application 
domain from a particular perspective, emphasizes some aspects of the applica-
tion, and deemphasizes olhers. 
111C classes we provide here arc designed for simple graphics and simple 
graphical user interfaces. They are primarily aimcd at users who need to present 
data and graphical output from numeridscientifidengineering applications. You 
can build youI' own classes "on top or' ours. If that is not enough, we c."(pose suffi-
cient FLTK details in our implementation for you to get an idea of how to use lhat 
(or a similar "full-blown" graphiCS/CUI library) directly, should you so desire. 
However, if you decide to go that route, wait until you have absorbed Chapters 17 
and 18. TI10se chapters contain infonnation abOllt pointers and memory manage-
ment tllal YOll need for successful direct use of most graphics/CUI librru;es. 
O ne key decision is to provide a lot of "little" classes with few operations. 
}or example, we provide Open_polyline, Closed_polyline, Polygon, Reclangle, 
Marked_polyline, Marks, and Mark where we could have provided a single class 
(possibly called "polyline") with a lot of arguments and operations that allowed us 
to specify whicll kind of polyline an object was and possibly even mutate a polyline 
from one kind to another. TIle extreme of this kind of thinking would be to pro-
vide every kind of shape as pall of a single class Shape. We think that using many 
481 

482 
C HAPTER 14 • GRAP H ICS ClASS D ESIGN 
small classes most closely and most usefully models our domain of graphics. A sin-
glc class providing "everything" would leave the user messing with data and op-
tions without a framework to help understanding, debugging, and perfonnancc. 
14.1.2 Operations 
We provide a minimum of operations as part of each class. OUT ideal is the mini-
ma] interface that allows us to do what we want. VVherc we want greater cOllven-
ience, we can always provide it in the foml of added nOlUllcmbcr functions or yel 
anOlher class. 
vVe want lile interfaces of our classes to show a common style. For CXrullp]C, 
all functions performing similar operations in different classes have the same 
name, take arguments of the same types, and where possible require those argu-
ments in the same order. Consider the conSlm cLOrs: if a shape requires a localion, 
il takes a Point as its first argument: 
line In (Poi nl(l 00,200), Poinl(300 ,400)); 
Mark m(PoinI(100,200),'x'); 
II display a single point as an HX" 
Circle e(Point(200,200),250); 
All functions that deal with points usc class Point to represent them. That would 
seem obvious, but many libraries exhibit a mixture of styles. For example, imag-
ine a function for dra\ving a line. We could usc one of two styles: 
void draw_line(Poinl pl, Point p2); 
void draw-'ine(int xl , inl yl, int xl, int y2); 
II from pI to p2 (our slyle) 
II from (xl ,yl ) 10 (x2 ,),2) 
We could even allow both, but for cons is leney, improved type checking, and im-
proved readability we usc the first Style exclusively. Using Point consistently also 
saves us from confusion between coordinate pairs and the other common pair of 
integers: width and height. For example, consider: 
draw_reetangle(Poinl(l00,200), 300, 400); 
draw_rectangle (100,200,300,400); 
/I our style 
/I alternative 
-Inc first call draws a rectangle with a point, width, and height. 11l:'lt's rea-
sonably easy to guess, but how about the second call? Is that a rectangle defined 
by points (100,200) and (300,400)? A rectangle defined by a point (100,200), a 
width 300, and a height 400? Something complClcly different (though plausible 
to someone)? Using the Point type consistently avoids sllch confusion. 
Incidentally, if a function requires a width and a heighl, they are always pre-
sented in that order (jUSt as we always give an x coordinate before a y coordi-
nate). Gelling such little details consislem makes a surprisingly large difference to 
the case of usc and the avoidance of mn-time errors. 

14. 1 
D ESIGN PRI NCIPL ES 
Logically identical operations have the same name. For example, every func· 
tion that adds points, lines, etc. to any kind of shape is called add(), and any fUllc, 
tion that draws lines is called draw_linesO. Such uniformity helps us remember 
(by offering fewer details to remember) and helps us when we design new classes 
("just do the usual"). Sometimes, it even allows us to write code that works for 
Illany different types, bec.'lIse the operations on those types have an identical pat· 
tem. Such code is called gt!1/tmc: sec Chapters 19-21. 
14.1.3 Naming 
Logically different operations have different names. Again, that would seem ob· 
vious, but consider: why do we "attach" a Shape to a Window, but "add" a Line 
to a Shape? In both cases, we "put something into something," so shouldn't that 
similarity be reflected by a common name? No. "Inc similarity hides a funda· 
mental difference. Consider: 
Open_polyline opl; 
opl.add(Point(100,100»; 
opl. add(Poi nl(150 ,200»; 
opl.add(Poi nl(25O ,150»; 
Here, we copy three points into opl. The shape opl docs not c.,re about "our" 
points after a call to addO; it keeps its own copies. In fact, we rarely keep copies 
of the points - we leave that to the shape. On the other hand, consider: 
win.aUach(opl); 
Hel'e, we creale a connection between the window win and our shape opl; win 
docs not make a copy of opl - it keeps a reference to opl. So, it is our responsi· 
bility to keep opl valid as long as win uses it. That is, we must not exit opl's 
scope while win is using opl. We can update op1 and the next time win comes lO 
draw opl our changes will appear all the screen. We can illustrate the difference 
between atfachO a.nd addO graphically: 
Open_polyline: 
(180,180) 
(150,l8I) 
(250,250) 
Window: 
483 

... 
C HAPTER 14 • GRAPHI CS C LASS DESIGN 
Basically, add() uses pass·by·valuc (copies) and attachO uses pass-by-rcfcrcncc 
(shares a single object). We could have chosen to copy graphical objects into 
Windows. However, that would have given a different programming model, 
which we would have indicated by using addO rather than attachO. As it is, we 
just "'attach" a graphics object to a Window. TIml has important implications. For 
example, we can 'I create an object, attach it, allow me object to be destroyed, and 
expect the resulting program to work: 
void HSimple_window& w ) 
{ 
Rectangle r(Point(100,200),SO,30); 
w.attach(r); 
} 
/I oops, the lifetime of r ends here 
int mainO 
{ 
) 
Simple_window win(Point(l00, 100),600,400, "My window"); 
1/ . . . 
f(win): 
/I asking for trouble 
1/ . . . 
win.wail_for_bullonO; 
By the time we have exited from f() and reached waiC fo T_bultonO, there is no r 
for the win to refer to and display. In Chapter 17, we'll show how to create objects 
within a function and have them survive after the return from the function. Until 
then, we must avoid aHaching objects that don't survive until the call of 
wait_foT_bullonO. We have Vector_ref (§13.1O, §E.4) to help with that. 
NOle that had we declared fO to take its Window as a const referellce argu-
ment (as recommended in §8.5.6), the compiler would have prevented our mis-
take: we can't attach(r) to a canst Window because attachO needs to make a 
change to the Window to record the Window's interest in r. 
14.1.4 Mutability 
When we design a class, "Who can modify the data (representation)?'" and 
"How?" are key questions that we must answer. We try to ensure that modifica-
tion to the state of an object is done only by its own class. llle public/private dis-
tinction is key to this, but we'll show examples where a more flexible/subtle 
mechanism (protected) is employed. This implies that we can't just give a class a 
data member, say a string called label; we mUSt also consider if it should be pos-
sible to modify it after construction, and if so, how. We must also decide if code 

14 .2 
SHAPE 
other than our class's member functions need LO read the value of label, and if so, 
how. For example: 
struel Circle ( 
II ... 
private: 
int r; 
1/ radius 
); 
Circle c(Point(100,200),SO); 
c.r = -9; 
1/ OK? No -
compile-time error: Circle::r is private 
As you might have noticed in Chapter 13, we decided to prevent direct ac· 
cess LO most data members. Not exposing the data directly gives us the opportu· 
nity to check against "silly" values, such as a Circle with a negative radius. For 
simplicity of implementation, we take only limited advantage of this opportunity, 
so do be careful with your values. TIle decision not LO consisl'emly and com· 
pletely check reflects a desire to keep the code shoTt for presentation and the 
knowledge tlm if a user (you, us) supplies "silly" values the result is simply a 
mcssed·up image on the screen and not corruption of precious data. 
We treat the screen (seen as a set of Windows) purely as an output device. 
We can display new objects and remove old ones, but we never ask "the system" 
for information that we don't (or couldn't) know ourselves from the data struc· 
tures we have built up representing our images. 
14.2 Shape 
Class Shape represents the general notion of some!.hing that can appear in a 
Window on a screen: 
h is the notion that tics our graphical objects to our Window abstraction, 
which in lurn provides the connection to the operating system and the 
physic.-u screen. 
It is tlle class t.hat deals with color and the style used to draw lines. 1b do 
that it holds a Line_style and a Color (for lines and for rill). 
It can hold a sequence of Points and has a basic notion of how to draw 
them. 
Experienced designers will recognize that a class doing !.hree things probably has 
problems with generality. However, here, we need something far simpler !.han !.he 
most general solution. 
"5 

... 
(HAPTER 14 • GRAPHICS CLASS DESIGN 
We'll first present the complete class and then discuss its details: 
class Shape ( 
1/ deals with color and style and holds s,equence of lines 
public: 
void drawO const; 
1/ deal with color and draw lines 
virtual void mOlle(int dx, int dy); /I move the shape +=dx: and +=dy 
void scCcolor(Color col); 
Color colarO canst; 
void secstyle(Line_style Sly); 
Line_style SlylcO consl; 
void scCfill_color(Color col); 
Color fill_calorO const; 
Point point(int i) const; 
/I read-only access to points 
int number_oCpointsO consl; 
virtual -Shape() ( ) 
protected: 
Shape(); 
virtual void drawJines() const; 
void add(Point pl; 
void sc,,"-point(int i, Point pl; 
II draw the appropriate lines 
II add p to points 
/I points[i]=p; 
private: 
); 
veclor<Point> points; 
Color leolor; 
line_style Is; 
Color feolor; 
/I not used by all shapes 
/I color for lines and characters 
/I fill color 
Shape(const Shape&); 
/I prevent copying 
Shape& operator=(const Shape&); 
This is a relatively complex class designed to support a wide variety of graphics 
classes and to represent the general concept of a shape on the screen. However, it 
still has only four data members and 15 functions. Furthermore, those functions 
arc all close to trivial so that we can COnCenlnHC on dcsign issues. For the rest of 
this section we will go through the mcmbers onc by one and explain thcir role in 
the design. 

14 .2 
SHAP E 
14.2.1 An abstract class 
Consider first Shape's constructor: 
protected: 
Shape(); 
l lle constmctor is protecled. TImt means that it can only be used direct.ly rrom 
classes derived rrom Shape (using the :Shape notation). In other words, Shape 
can only be used as a base ror classes, such as line and Open_polyline. TIle pur-
pose or thm "prolecled: " is to ensure that we don't make Shape objects directly. 
For c..xample: 
Shape ss; 
II error: cannot construct Shape 
Shape is designed to be a base class only. In this case, nothing particularly nasty 
would happen ir we allowed people to create Shape objects direct.ly, but by limit-
ing usc, we keep open the possibility or modifications to Shape lhat would render 
it unsuitable ror direct usc. Also, by prohibiting the direct creation or Shape ob-
jects, we direet.ly model the idea that we cannot have/sec a general shape, only par-
ticular shapes, such as Circle and Closed_polyline. lbin.k about it! \¥hat docs a 
shape look like? The only reasonable response is the counter question "\¥hat 
shape?" TIle notion or a shape that we represent by Shape is an abstract concept. 
"n l;lt's an important and rrequent.ly userul design notion, so we don't want to 
compromise it in our program. Allowing users to directly create Shape objects 
would do violence to our ideal or classes as direct representations or concepts. 
l l le constructor is defined like this: 
Shape:: Shape() 
{ 
} 
: Icolor(fI_color(», 
Is(O), 
fcolor(Color: : invisible) 
II default color (or lines and characters 
II de(ault style 
/I no fill 
It is a default constructor, so it sets the members to their default. Here again, the 
underlying library used ror implementation, FLTK, "shines through." However, 
FLTK's notions or color and style are not mentioned directly by the uses. l l ley 
arc only part or the implementation or our Shape, Color, and line_slyle classes. 
"n le veclor<Poinls> deraults to an empty vector. 
A class is abstract ir it c..1.n be used only as a base class. "n le mher - more cam-
mon - way or achieving that is called a pure virluaJfimctioll; see §14.3.5. A class 
48' 

... 
(HAPTER 14 • GRAPHI CS CLASS DESIGN 
that can be used to create objectS - that is, the opposite of an abstract class - is 
called a CQIlCr(ie class. Note that abstrrul and concrete are simply lcdmical words for 
an everyday distinction. We might go to the SLOre to buy a camera. However, we 
can't just ask for a camera and takc it home. VVhat brand of camera? Which par-
ticular model camera? TIle word camera is a generalization; it refers to an abstract 
notion. An Olympus E-3 refers to a specific kind of camera, which we (in ex-
change for a large amount of cash) might acquire a particular instance of: a par-
ticular camera with a unique serial number. So, "camera"' is much like an abstract 
(base) class; "Olympus E-3" is Illuch like a concrete (derived) class, and the ac-
lual camera in my hand (if I bought it) would be much like an object. 
1ne declaration 
virtual-ShapeO { } 
defines a virtual desouctor. We won't use lhal for now, so we leave lhe explana-
lion to §17.5.2, where we show a usc. 
14.2.2 Access control 
Class Shape declares al1 data members private: 
private: 
vector<Point> points; 
Color Icolor; 
line_style Is; 
Color fcolor; 
Since lhe data members or Shape are declared private, we need to provide access 
runctions. 111ere are several possible styles for doing this. We chose one that we 
consider simple, convenient, and readable. If we have a member representing a 
property X, we provide a pair of functions X() and seCXO for reading and wriling, 
respectively. For example: 
void Shape: :set_color(Color col) 
( 
leolor = col; 
) 
Color Shape: : colorO canst 
( 
return Icolor; 
) 

14 .2 
SHAPE 
"me main inconvenience of this style is that you can't give the member variable 
the same name as its readout function. As ever, we chose the most convenient 
names for the functions because they are part of the public interface. It matters 
far less what we call our private variables. Note the way we use const to indicatc 
thatlhe readout functions do not modify their Shape (§9.7.4). 
Shape keeps a vector of Points, called points, that a Shape maintains in sup-
port of its derived classes. We provide the function addO for adding Points to 
points: 
void Shape: :add(Point p) 
( 
poin ts. pu sh _ back(p); 
II protected 
Naturally, points start out empty. We decided to provide Shape with a complete 
functional intcrface rather than giving uscrs - even member functions of classes 
derived from Shape - direct access to data members. To some, providing a func-
tional interface is a no-brainer, because they feel that making any member of a 
class public is bad design. rib others, our design seems overly restrictive because 
we don't allow direct write access to the members to all members of derived 
classes. 
A shape derived from Shape, such as Circle and Polygon, knows what its 
points mean. rille base class Shape does not "understand" the poi.nts; it only 
stores them. '1lerefore, the derived classes nced control over how points are 
added. For example: 
Circle and Rectangle do not allow a user to add points; that just wouldn't 
make sense. What would be a rectangle with an extra point? (§12.7.6) 
lines allows only pairs of points to be added (and nOl an individual 
point; §13.3). 
Open_polyline and Marks allow any number of points to be added. 
Polygon allows a point to be added only by an addO that checks for 
intersections (§13.8). 
We made addO protected (that is, accessible from a derived class only) to ensure 
that derived classes takc control over how points arc added. Had addO been 
public (everybody can add points) or private (only Shape can add points), this 
close match of functionality to our idea of shapes would not have been possible. 
Similarly, we made sel_poinlO protected. In general, only a derived class can 
know what a point means and whether it can be changed withollt violating an in· 
varianl. For example, if we have a Regular_hexagon class defined as a set of six 
points, changingjust a single point would make the resulting figure "not a regular 
489 

490 
CHAI'TER 14 • GRAPHI CS CLASS DES IGN 
hexagon." On the other hand, if we changed one of the points of a rectangle, the 
result would still be a rectangle. In fact, we didn't fmd a need for seCpointsO in 
our example classes and code, so seCpoinlO is there, just to ensure that the rule 
that we can read and set every attribute of a Shape holds. For example, if we 
wanted a Mutable_rectangle, we could derive it from Rectangle and provide op-
erations to change the points. 
We made the vector of Points, points, private to protect it against undesired 
modification. To make it useful, we also need to provide access to it: 
void Shape: !sel_point(int i, Point p) 
{ 
pointslil = p; 
) 
Point Shape::poinl(inl i) const 
{ 
return points[i]i 
) 
int Shape: :number_oCpoints() eonst 
{ 
return points.sizeO; 
) 
/I not used; not necessary so far 
Ll derived class member functions, these functions arc lIsed like this: 
void lines: :draw_linesO consl 
/I draw lines connecting pairs of points 
for (inl i=l ; knumber_oC poinls(); i+=2) 
fU ine(po inl(i - 1 ). x, poi nt(i -1). y, point(i) .x, poi nt(i). y); 
You might worry about allt.hosc uivial access functions. Are they not inefficient? Do 
they slow down the program? Do they increase Lhe size of the program? No, Lhey 
will all be compiled away ("inlined") by the compiler. Calling number_oCpoints() 
will take lip exactly as many bytes of memory and execute exactJy as Illany insU"uc· 
Lions as calling points.size() directly. 
TIlese access control considerations and decisions are important. \o\'c could 
have provided this c1ose·lo·minimal version of Shape: 
slruel Shape ( 
/I closc·to·minimal definition -
too simple ~ not U5(.'£i 
Shape(); 
void draw() eonsl; 
/I deal with color and call drawJines 

14 .2 
SHAPE 
virtual void drawJinesO canst; II draw the appropriate lines 
virtual void move(int dx, int dy); /I move the shape +=dx and +=dy 
); 
veclor<Point> points; 
Color leolor; 
Line_style Is; 
Color feolor; 
/I not used by all shapes 
What value did we add by those extra 12 member functions and t'o'>O lines of access 
specifications (private: and protected:)? The basic answer is that protecting the rep-
resentation ensures that it doesn't change in ways unanticipated by a class designcr 
so that we can write better classes with less e£T0I1. TIlis is the argument about "in-
variants" (§9.4.3). Here, ,ve'lJ point out such advantages as we derme classes derived 
from Shape. One simple example is that earlier versions of Shape used 
FI_Color Ieolor; 
intlinc_style; 
~nlis lumed alit to be too limiting (an int line style doesn't elegantly SUppOil line 
width, and FI_Color doesn't accommodale invisible) and led to some messy code. 
Had these two variables been public and used in a user's code, we could have im-
proved our interface library only at the cost of breaking that code (because it 
mentioned the names line_color and line_style). 
In addition, the access functions often provide notational convenience. For 
example, s.add(p) is easier to read and write than s.points.push_baek(p). 
14.2.3 Drawing shapes 
We have now described almost all but the real heart of class Shape: 
void drawO canst; 
/I deal with color and call drawJines 
virtual void draw_linesO canst; /I draw the lines appropriately 
Shape's most basic job is to draw shapes. We could not remove all other func-
tionaJity from Shape and leave it with no data of its own without doing major 
conceptual harm (sec §14.4); drawing is Shape's essential business. It does so 
using FLTK and lhe operating system's basic machinery, but from a user's point 
of view, it provides jllst two functions: 
drawO applies style and color and then calls drawJinesO. 
dr.aw_linesO puts pixels on the screen. 
~nle drawO function doesn't usc any noveltcchniqlles. It simply caJls FLTK func-
tions to set the color and style to what is specified in lhe Shape, calls drawJinesO 
491 

492 
(HAPTER 14 • GRAPHICS ClASS DESIGN 
to do lhe actual drawing on the screen, and then tries to restore the color and 
shape to what they WCfe before the call: 
void Shape : :drawO consl 
{ 
I/there is no good portable way of retrieving the current style 
fI_color(lcolor.asjnt()); 
1/ set color 
fUinc_stylc(ls.stylcO,ls.width()); 
II set style 
drawJ ines(); 
fI_color(oldc); 
fUin c_slyle(O); 
/I reset color (to previous) 
/I reset line style to default 
Unfortunately, FLTK doesn't provide a way of obtaining the current slyle, so the 
style is just set to a default. That's the kind of compromise we sometimes have to 
accept as the cost of simplicity and portability. We didn't think it worthwhile to 
try to implement that facility in our interface library. 
Note that Shape::drawO doesn't handle fill color or the visibility of lincs. 
Those arc handled by the individual draw_lineO functions that have a bener idc..'l 
of bow to interpret them. In principle, all color and style handling could be dele-
gated to the individual draw_lineO functions, but that would be quite repetitive. 
Now consider how we might handle draw_linesO. If you think about it for a 
bit, you'll realize that it would be hard for a Shape function to draw all that needs 
to be drawn for every kind of shape. To do so would rcquirc that every last pixel 
of each shape should somehow be SLQred in the Shape object. If we kept the 
vecior<Point> model, we'd have to store an awful lot of points. Worse, "the 
screen" (that is, the graphics hardware) already docs that - and docs it belter. 
To avoid that extra work and extra storage, Shape takes another approach: it 
gives each Shape (that is, each class derived from Shape) a chance to define what 
it means to draw it. A Text, Rectangle, or Circle class may each have a clever way 
of drawing itself. In fact, most such classes do. After all, such classes "know" ex· 
actly what they are supposed to represent. For example, a Circle is defmed by a 
point and a radius, rather than, say, a lot of line segments. Generating the re' 
quired bits for a Circle from the point and radius if and when needed isn't really 
all that hard or expensive. So Circle defines its own draw_lincsO whiclt we want 
to call instead of Shape's draw_linesO. TItat's what the virtual in the declaration 
of Shape: :draw_lincsO means: 
shuet Shape ( 
II . .. 

14 .2 
SHAPE 
virlual void drawJinesO consl; 
/I let each derived class define its 
II own draw_linesO if it so chooses 
1/ . . 
} ; 
slrue! Circle : Shape { 
/I . .. 
void draw_linesO consl: 
II"ovcr ride ~ Shape::drawJinesO 
/I ... 
} ; 
So, Shape's drawJinesO must somehow invoke one of Circle's functions if the 
Shape is a Circle and one of Reclangle's functions if the Shape is a Reclangle. 
111at's what the word virlual in the drawJinesO declaralion ensures: if a class de· 
rived from Shape has derliled its OW11 drawJinesO (with the same type as Shape's 
drawJinesO), that drawJinesO will be called rather than Shape's draw_linesO. 
Chapter 13 shows how that's done for Ted, Circle, Closed_polyline, etc. Defining 
a function in a derived class so that it can be used through the interfaces provided 
by a base is c.-uled ovenidillg. 
Note that despite its centrill role in Shape, draw_linesO is protected ; it is not 
meant to be called by "the gcneraluser" - that's what drawO is for - but simply 
as an "implementation detail" used by drawO and the classes derived from 
Shape. 
~nllS completes our display model from §12.2. The system that drives the 
screen knows about Window. Window knows about Shape and can call Shape's 
draw{). Finally. drawO invokes the draw_linesO for the particular kind of shape. 
A call of gui_mainO in our user code starts the display engine. 
drawJ inesO 
drawJinesO 
s ...... 
Circle 
draw_linesO 
s ...... 
drawO 
drawO 
,----------, 
drawO 
Wmdow 
aliachO 
Our code 
Make obj«:ts 
Atlach objects 
Display 
engme 
493 

494 
CHAPTER 14 • GRAPHICS CLASS DESIGN 
What gui_mainO? So far, we haven't actually seen gui_rnainO in Ollf code. lnstead 
we usc wail_for_bullon(), which invokes the display engine in a more simple-
minded manner. 
Shape's moveO function simply moves every poim stored rcl:uivc to the cur-
rcnt IX'sition: 
void Shape : :move(int dx, int dy) 
{ 
/I move the shal>C +=dx and +=dy 
} 
for (int i = 0; i<points.sizeO; ++i) { 
poinls[i].X+=dx; 
points[il.y+=dy; 
} 
Like draw_linesO, moveO is virtual because a derived class may have data that 
needs to be moved and that Shape docs not know aboul. "or example, sec Axis 
(§12.7.3 and §15.4). 
The move() function is not logically necessary for Shape; we just provided it 
for convenience and to provide another example of a virtual function. EvelY kind 
of Shape that has points that it didn't store in its Shape must dcfinc its own 
move(). 
14.2.4 Copying and mutability 
TI1C Shape class dcclarcd thc copy constructor and thc copy assigruncnt opcralor 
pnvatc: 
private: 
Shape(const Shape&); 
/I prevent copying 
Shape& operator=(const Shape&)i 
~lll C cffcct is that on.ly mcmbers of Shape can copy objects of Shape using the de-
fault copy operations. That is a common idiom for preventing accidcntal copy-
ing. For example: 
void my_fcl (const Open_polylinc& op, const Circlc& c) 
{ 
Open_polyline op2 = 0Pi 
/I error: Shape'S copy constructor is private 
vector<Shape> Vi 
v.push_back(c); 
/I error: Shape's copy constructor is private 

14 .2 
SH APE 
1/ . .. 
op = op2; 
/I error: Shape's assignment is private 
} 
BUI copying is useful in so many places! Just look at that push_baek(); without 
copying, it is hard even to usc vectors (push_backO puts a ropy of its argument into 
its vector). Why would anyone make trouble for programmers by preventing copy-
ing? You prohibit the default copy operations for a type if they are likely 10 cause 
trouble. As a prime example of "trouble," look at my_feU). We cannot copy a Circle 
into a Shape-sized element "slot" in v; a Circle has a J<ldius but Shape docs not so 
sizeof(Shape)<sizeof(Circle). lf that v.push_back(e) were allowed, the Circle would 
be "sliced" and any future use of the resulting Shape element would most likely 
lead to a crash; the Circle operations would assume a radius member (r) th."lt hadn't 
been copied: 
Shape: points 
line_color 
Is 
Circle: .--:-::-- , 
points 
line_color 
Is 
, 
'11e copy construction of op2 and the assignment lO Op suffer from exactly the 
same problem. Consider: 
Marked_polyline mp("x"); 
Circle c(p,10); 
my_fct(mp,e); 
/I the Open-POlyline argument refers to a Markectpolyline 
Now the copy operations of the Open_polyline would "slice" mp's string mem-
ber mark away. 
Basically, class hierarchies plus pass-by-reference and default copying do nOt 
mi.". \\Then you design a class that is meant 10 be a base class in a hierarchy, dis-
able its copy constructor and copy assigrunelll as was done for Shape. 
Slicing (yes, that's really a technical ternt) is not the only reason to prevent 
copying. There a,'e quite a few concepts that arc best represented withoul copy 
operations. Remember that lhe graphics system has to remember where a Shape 
is stored to display it 10 the screen. 111at's why we "attach" Shapes to a Window, 
rather than copy. "111e Window would know nOlhing about a copy, so a copy 
would in a very real sense not be as good as its original. 
495 

4% 
CHAPTER 14 • GRAPHICS CLASS D ESI G N 
If we want to copy objects of types where the default copy operations have 
been disabled, we can write an explicit function to do the job. Such a copy fune-
lion is often called doneO. Obviously, you can write a done() only if the fune-
lions for reading members are sufficient for expressing what is needed to 
construct a copy, but that is the case for all Shapes. 
14.3 Base and derived classes 
Let'S take a more technical vicw or base and derived classes; that is, Jet us for this 
section (only) change the focus of disclission from programming, application de-
sign, and graphics to programming language features. When designing our 
graphics interface library, we relied on three key language mechanisms: 
Den'va/ian: a way to build one class from another so that the new class 
can be used in place of the original. For example, Circle is derived from 
Shape, or in other words, "a Circle is a kind of Shape" or "Shape is a 
base of Circle." The derived class (here, Circle) gets all of the members 
of its base (here, Shape) in addition to its own. This is often called inheri-
tallce because the derived class "inherits" all of the members of its base. 
In some contexts, a derived class is called a subdllJJ and a base class is 
called a superc!ass. 
VirtuaijilllcliollS: the ability to define a function in a base class and have a 
function of the same name and type in a derived class called when a user 
calls the base class funClion. For example, when Window Ct'1lls draw_linesO 
for a Circle, it is the Circle's drawJinesO that is executed, rather than 
Shape's own drawJinesO. TIus is often Ct'l.lIed nlll-tlmc poljmOlphisllI, CIytUlIIlIC 
dispatch, or nm-tilll£ dispatdl because the function called is determined at nm 
time based all the type of the object used. 
Primite OJu/ protected members: We kept the implementation details of our 
classes private to protect them from direct usc that could complicate 
maintenance. TIlat's often called cllwpsuialioll. 
TIle usc of inheritance, run-Urne polymorphism, and encapsulation is the most COIll-
man defmilioll of object-oricnled programming. TI1US, C++ directly supports object-
orie11led programming in addition to other programming styles. For example, in 
C hapters 20-21 , we'll see how C++ supports generic programming. C++ bor-
rowed - with explicit acknowledgments - its key mechanisms from Simula67, tlle 
first language to directly support object-oriented programming (sec Chapter 22). 
TIlat was a lot of technical terminology! But what docs it all mean? And how 
docs it actually work on our computers? Let's first draw a simple diagram of our 
graphics intcrface classes showing their inhclitance relationships: 

14.] 
BASE AND DE RIVED CLASSES 
Shape 
Circle 
Ellipse 
Text 
Line 
Open....j)Olyline 
Lines 
~ .... 
=::k:::ed7='=t:i:::n~
e 
Closed....polyline 
Polygon 
"m e arrows point rrom a derived class to its base. Such diagrams help visualize 
class relationships and orten decorate the blackboards or programmers. Com-
pared to commercial rrameworks this is a tiny "class hierarchy" with only 16 
classes, and only in the case or Open_polyline's many descendants is the hierar-
chy more than one deep. Clearly the common base (Shape) is the most impor-
tant class here, even though it represents an abstract concept so that we never 
directly make a shape. 
14.3.1 Object layout 
How are objects laid out in meillOlY? As we saw in §9.4.1, members or a class de-
fine the layout or objects: data members are stored one arter another in mernaI)'. 
When inheritance is used, the data members or a derived class are simply added 
arter those or a base. For example: 
Shape: points 
line_color 
I. 
Circle: points 
line_color 
Is 
r 
A Circle has the data members or a Shape (arter all, it is a kind or Shape) and can 
be used as a Shape. In addition, Circle has "its own
n data member r placed after 
the inherited data members. 
497 

' 98 
(HAPTER 14 • GRAPHICS ClASS DESIGN 
To handle a virtual function caU, we need (and have) one more piece of data 
in a Shape object: something to tell which function is really invoked when we call 
Shape's draw_linesO. The way that is usually done is to add the .lddrcss of a 
table of functions. This table is usually referred to as the vtbl (fol' '-virlual table" 
or "virtual function table") and its address is of len called the vptr (for "vinual 
pointer"). We discuss pointers in Chapters 17-18; here, they act like references. 
A given implementation may use different names for vtbl and vplr. Adding the 
vptr and the vtbls to the picture we get 
Open_polyline: points 
Shape:dr;nwJines() 
Open_polyline's vtbl: 
line_color 
/
c.) 
Is 
vpl 
Circle : 
~ 
Shape:move() 
points 
Circle's vlbl: 
f../ () 
line_color ~ 
Is 
~ 
Cirde:draw_llnesO 
vpl 
• 
( ... ) 
Since draw_linesO is the fIrst vinual function, it gets the first slot in the vtbl, fol-
lowed by that of move(), lhe second virtual function. A class can havc as lllaJl)' vir-
tual functions as you want it lO have; its vtbl will be as large as needed (one slot per 
vinual function). Now when we call x.drawJines(), ule compiler generates a call to 
the function found in lhe draw_linesO slot in lhe vtbl for x. Basic.....ny. the code just 
follows the arrows on lhe diagram. So if " is a Circle, Cirde::draw_linesO will be 
called. If x is of a type, say Open_polyline, that uses the vtbl exactly as Shape de-
fined it, Shape::draw_linesO will be called. Similarly, Circle d idn't define its own 
moveO so x.moveO will call Shape::moveO if x is a Circle. Basically, code gener-
ated for a virtual function call simply finds the vplr, uses that to get to the right 
vtbl, and calls the appropriate function there. The cost is about twO memory ac-
cesses plus the COSt of an ordinary function call. Ths is simple and fast. 
Shape is an abstract class so you can't actually have an object that's just a 
Shape, but an O pe n_polyline will have exactly the same layoUl as a "plain shapc" 
since it doesn't add a data member or define a virtual function. TIlere is just one 
vlbl for each class with a virtual function, not one for eadl object, so the vtbls tend 
nm to add significantly to a program's object code size. 
Note that we didn't draw any non·virtual functions in this picture. We didn't 
need to because there is nothing special about the way such functions arc called 
and they don't increase the size of objects of their type. 
Defining a function of the same name and type as a virtual function from a 
base class (such as Circle: :draw_linesO) so that the function from the derived 
class is put into the vlbl instead of the version from the base is called Qverriding. 
For example, Circle: :draw_linesO overrides Shape: :drawJinesO. 

14 .3 
BASE AND DERIVED ClASSES 
Why are we telling you about vtbls and memory layout? Do you need to 
know about that to use object-oriented programming? No. However, many peo-
ple strongly prefer to know how things are implemented (we are among those), 
and when people don't understand something, myths spring up. vVe have met 
people who were terrified of vinual functions "because they were expensive." 
Why? How expensive? Compared to what? Where would the cost matter? We 
explain the implementation model for vinual functions so that you won't have 
such fears. If you need a vinual function call (to select among alternatives at run 
time) you can't code the functionality to be any raster or to use less memory 
using other language rea lures. You can see that ror yourself. 
14.3.2 Deriving classes and defining virtual functions 
\o\'e speciry that a class is to be a derived class by mentioning a base arter the class 
name. For example: 
struct Circle : Shape {/ • ... -/ ); 
By default, lhe members or a struct arc public (§9.3), and that will include public 
members or a base. We could equivalently have said 
class Circle : public Shape { public: /- ... -/ }; 
These twO declarations or Circle are completely equivalelll, but you can have 
many long and rruitless discussions with people about which is belter. We arc or 
the opinion lhat time can be spent more productively on other topics. 
Beware or rorgetting public when you need it. For example: 
class Circle: Shape { public: r ... -/}; 
/I probably a mistake 
111is would make Shape a private base or Circle, making Shape's public runc· 
tions inaccessible ror a Circle. That's unlikely to be what you meant. A good 
compiler will wam about this likely error. There are uses ror private base classes, 
but those are beyond the scope or this book. 
A virtual runction must be declared virtual in its class declaration, but ir you 
place the runction definition outside the class, the keyword virtual is neither re' 
quired nor allowed out there. FOI" example: 
struct Shape { 
II ... 
); 
virtual void draw_linesO consl; 
vi,tual void move(); 
II ... 
'99 

500 
CHAPTER 14 • GRAPHI CS ClASS DESIGN 
virtual void Shape: :draw_linesO const {/- . .. -'} 
void Shape : : moveO { / - .. . -'} 
14.3.3 Overriding 
1/ error 
/10K 
When YOll want to oven-ide a virtual function, you must lise exactly the same 
name and type as in the base class. 1-or example: 
struct Circle: Shape { 
); 
void drawJines(inl) const; 
void drawlinesO const; 
void drawJines(); 
II . .. 
/I probably a mistake (int argument?) 
/I probably a mistake (misspelled name?) 
/I probably a mistilke (const missingrJ 
Here, the compiler will sec Llwcc functions that arc independent of Shape:: 
draw_linesO (because they have a different name or a different type) and won't 
override it. A good compiler will warn about thcse likely mistakes. TIlerc is noth-
ing you can or must say in an overriding function to ensure that it actually over-
rides a base class function. 
The drawJinesO example is reaJ and can therefore be hard to follow ill all 
details, so here is a purely technical example that illustrates overriding: 
slrucl 8 { 
); 
virlual void fO consl { coul« "8 :: f H;} 
void gO const { coul « "8::g "; } 
struct 0 : 8 { 
/I not virtual 
void fO canst { cout« "O: :f H; } 
void gO {coul « "O::g "; } 
II overrides B::f 
) ; 
struct DO : 0 { 
voidf() {cout«"OO::f "; } 
II doesn't override D::f (not const) 
void gO canst { cout« "OO::g "; } 
); 
Here, we have a small class hierarchy with (just) one virtual function fO. \Ve can 
try using it. In particular, we can try to caJl fO and the non-virtual gO, which is a 
function that doesn't know what type of object it had to deal with exceptlhat it is 
a B (or something derived from B): 

14 .3 
BASE AND DERIVED CLASSES 
void call(const B& b) 
{ 
) 
/I a D is J kind of e, so calin can accept a D 
/I a DO is a kind of 0 and a 0 is a kind of S, so call{) can accept a DO 
b.fO; 
b.gO; 
int mainO 
{ 
) 
B b ; 
Dd; 
DOdd; 
call(b); 
call(d); 
call(dd); 
b.f(); 
b.g(); 
d.fO; 
d.gO; 
dd.fO; 
dd.gO; 
You'll get 
B:: f B: :g D: :f B: :g O: :f B: :g B:: f B::g D:: f O::g DO : :f DD ::g 
When you understand why, you'll know the mechanics of inheritance and virtual 
fu nctions. 
14.3.4 Access 
C++ provides a simple model of access to members of a class. A member of a 
class can be 
P,ilXlle: If a member is private, its name can be used only by members of 
the class in whicll it is declared. 
501 

502 
C HAPTER 14 • GRAPHICS ClASS DESIGN 
Protected: If a member is protected, its name can be used only by mem-
bers of the class in which it is declared and members of classes derived 
from that. 
Public: If a member is public, it!! name can be used by all functions. 
Or graphically: 
AU users 
IDerived class's members I 
IClass's own members I 
.... j .... .... " , 
• ••• "1 
l Private members 
I 
A base can also be private, protected, or public: 
If a base of class 0 is private, its public and protected member names 
can be used only by members of D. 
If a base of class 0 is protected, its public and protected member names 
can be used only by members or O and members of classes derived from O. 
If a base is public, its name can be used by all functions. 
111csc definitions ignore the concept of <;fricnd" and a few minor details, which 
arc beyond the scope of this book. If you want to become a language lawyer you 
need to study Stroustrup, 1k Design alld £Wlu/ion qfC++ and Tltt C++ Program-
millg Lallguau, and the 2003 ISO C++ standard. \ <\Te don't recommend becoming 
a language lawyer (someone knowing every liule detail of the language defini· 
tion); being a progrnmmcT (a software developer, an engineer, a user, whatever 
you prefer to call someone who actually uses the language) is much more fun 
and typically much morc useful to socicty. 
14.3.5 Pure virtual functions 
An abstract class is a class that can be used only as a base class. We use abstract 
classes to represent concepts that are abstract; that is, we use abstract classes for 
concepts that are generalizations of colllmon characteristics of related emities. 
lllick books of philosophy have bcen writtcn trying to precisely define flbstmc/ COII-
at)! (or abj!rac/ioll or genera/iullio1l or ... ). Howevcr you dcfmc it philosophically, the 
notion of an abstract concept is immensely useful. E.xamples are "animal" (as op-

14 .3 
BAS E AN D DERI VED CLASSES 
posed to any particular kind of animal), "device driver" (as oppose to the driver 
for any particular kind of device), and "publication" (as opposed to any particular 
kind of book or magazine). In programs, abstract classes usually define interfaces 
to groups of related classes (class hiemrcliieJ). 
In § 14.2. 1, we saw how to make a class abstract by declaring its constmctor 
proted ed. There is another - and much more common - way of making a class 
abstract: state that one or more of its virtual functions needs to be overridden in 
a derived class. For example: 
class B { 
/I abstract base class 
public: 
); 
virtual void fO =0; /I pure virtual function 
virtual void gO =0; 
B h i 
II error: B is abstract 
"The curious =0 notation says that the virtual functions B: :fO and B: :gO are 
"pure"; that is, they must be ovelTiddcn in some derived class. Since B has pure 
virtual functions, we cannot create an object of class B. Overriding the pure vir-
tual functions solves this "problem": 
class 01 : public B { 
public: 
) ; 
void fOi 
void gO; 
01 dl ; 
/10K 
Note that unlcss all pure virtual functions arc overridden, the resulting class is 
still abstract: 
class 02 : public B { 
public: 
); 
void ro; 
/I no gO 
D2 d2; 
/I error: 0 2 is (sti II) abstract 
503 

C HAPTER 14 • GRA PHI CS C LASS DESIGN 
class D3 : public 0 2 { 
public: 
void gO; 
); 
0 3 d3; 
/I ok 
Classes with pure virtual functions tend to be pure interfaces; that is, they tend to 
have no data members (the data members will be in the derived classes) and con' 
sequently have no constructors (if there arc no data members to initialize, a con' 
structor is unlikely to be needed), 
14.4 Benefits of object-oriented programming 
'Nhen we say that Circle is derived from Shape, or that Circle is a kind of Shape, 
we do so to obtain (either or bOlh) 
II/terface il/hen'lallCe: A function expecting a Shape (usually as a reference 
argument) can accept a Circle (and can usc a Circle through the interface 
provided by Shape), 
Implemenlatio1l il/hen'lallce: When we define Circle and its member func-
tions, we can take advantage of the facilities (SUcil as data and member 
functions) offered by Shape, 
A design that docs not provide interface inheritance (that is, a design for which 
an object of a derived class crumot be used as an object of its public base class) is 
a poor and error'prone design. For example, we might define a class called 
Never_do_lhis with Shape as its public base. 111en we could override Shape: : 
drawO with a function that didn't draw the shape, but instead moved its center 
100 pixels to the left. That "desib'll" is fatally flawed because even though 
Never_do_lhis provides the interface of a Shape, its implementation does not 
maintain the semantics (meaning, behavior) required of a Shape. Never do that! 
Interface inheritance gets its name because its benefits come from code using 
the interface provided by a base class ("an interface"; here, Shape) and not hav, 
ing to know about the derived classes ("implementations"; here, classes derived 
from Shape), 
Implementation inheritance gets its name because the benefits come from the 
simplification in the implementation of derived classes (e,g" Circle) provided by 
the facilities offered by the base class (here, Shape), 
Note that our graphics design critically depends on interface inheritance: the 
"graphics engine" calls Shape: :drawO which in tum calls Shape's virtual function 
draw_linesO to do the real work of putting images on t.he screen. Neither the 
"graphics engine" nor indeed class Shape kllOWS whicll kinds of shapes exist. In 
particular, our "graphics engine" (FLTK plus the operating system's graphics facil-

CHAPTER 14 DRill 
ities) was written and compiled years before our graphics classes! We juSt define 
particular shapes and attachO them to Windows as Shal>es (Window::attachO 
takes a Shape& argument; see §E.3). Furthennore, since class Shape doesn't know 
abOLn your graphics classes, you don't need to recompile Shape each time you de· 
fine a new graphics interface class. 
In other words, we can add new Shapes to a program without modifying 
existing code. This is a holy grail of software design/development/maintenance: 
extension of a system without mod ifying it. There are limits to which changes we 
can make without modifying existing classes (e.g., Shape offers a rather limited 
range of services), and the technique doesn't apply well to all programming prob· 
lems (sec, for example, Chapters 17-19 where we define vector; inheritance has 
little to ofTer for that). However, interface inheritance is one of the most powerful 
techniqucs for designing and implementing systems that are robust in the face of 
change. 
Similarly, implementation inheritance has much to offcr, but it is no panacea. 
By placing useful services in Shape, we save ourselvcs the bother of repeating 
work over and over again ill the derived elasses. That can be most significant in 
rea1·world code. However, it comes at the cost that any change to the interface of 
Shape or any change to the layout of the data members of Shape necessitates a 
recompilation of all derived classes and their users. For a widely used library, 
such .. ecompilation can be simply infeasible. Naturally, there arc ways of gai.ning 
most of the benefits while avoiding most of the problems; sec §14.3.5 . 
..( Drill 
Unfortunately, we can't constmct a drill for the understanding of genera1 design 
principles, so here we focus on the language features that support object·oriented 
programming. 
1. Define a class 81 with a virtual function vfO and a non-virtua1 function 
fO. Define both of these functions within class 81. lmplemem each func· 
tion to output its name (e.g. "81::vfO"). Make the runctions public. 
Make a 81 object and caU each function. 
2. Derive a class 01 rrom 81 and override vfO. Make a 01 object and call 
vfO and fO for it. 
3. Define a reference to 81 (a 81&) and initia1ize that to the 01 object you 
just defined. Call vf() and f() ror that reference. 
4. Now define a function called f() for 01 and repeat 1-3. Explain the results. 
5. Add a pure virtuaJ runction called pvfO to 81 and try to repeat 1-4. Ex-
plain the result. 
6. Define a class 02 derived rrom 01 and override pvfO in 02. Make an ob· 
ject or class 02 and invoke fO, vfO, and pvfO for it. 
505 

CHAPTER 14 • GRAPHICS CLASS DESIG N 
7. Define a class 82 with a pure virtual function pvf(). Define a class 021 
with a string data member and a member function that overrides pvfO ; 
021: : pvfO should output the value of the string. Define a class 022 that 
is just like 021 except that its data member is an int. Define a function fO 
that takes a 82& argument and calls pvfO for its argumem. Call fO with a 
021 and a 022. 
Review 
1. What is an application domain? 
2. 'What are ideals for naming? 
3. What C.'lll we name? 
4. What services does a Shape offer? 
5. How docs an abstract class diITer from a class that is not abstract? 
6. How can you make a class abstract? 
7. vVhat is comrolled by access comrol? 
8. Wlmt good can it do to make a data member private? 
9. What is a virtual function and how does it differ from a non-virtual 
function? 
10. What is a base class? 
11 . What makes a class derived? 
12. What do we mean by object layout? 
13. \,yhat can you do to make a class easier to lest? 
14. What is an inheritance diagram? 
IS. What is the difference between a protected member and a private one? 
16. Whatlllembers of a class can be accessed from a class derived from it? 
17. How docs a pure virtual function differ from other vinual functions? 
18. Why would you make a member function virtual? 
19. Why would you make a virtual member function pure? 
20. What docs overriding mean? 
21. How docs interface inheritance differ from implementation inheritance? 
22. What is object-oriented programming? 
Terms 
abstract class 
access comrol 
base class 
derived class 
dispatch 
encapsulation 
inheritance 
mutability 
object layoUl 
object·oriented 
polymorphism 
private 
protected 
public 
pure virtual function 
subclass 
superdass 
virtual function 
virtual function call 
virtual function table 

CHAPTER 14 EXERCISES 
Exercises 
1. Define two c1asscs Smiley and Frowny, which are both derived from class 
Circle and have two eyes and a mouth. Next, derive c1asscs from Smiley 
and Frowny, which add an appropriate hat to each. 
2. Try to copy a Shape. What happens? 
3. Define an abstract class and try to define an object of that lype. What 
happens? 
4. Define a class Immobile_Circle, which is just like Circle blll can't be 
moved. 
5. Define a Striped_rectangle where instead of fill, the rectangle is "filled" 
by drawing one·pixcl·wide horizontal lines across the inside of the reClan' 
gle (say, draw every second line like that). You may have to play with the 
width of lines and the line spacing to get a pattern you like. 
6. Define a Striped_circle using the technique from Striped_rectangle. 
7. Define a Striped_closed_polyline usi.ng the technique from Striped_rec-
tangle (this requires some algorithmic inventiveness). 
8. Define a class Octagon to be a regular octagon. Write a tcst that exer' 
cises all of its functions (as defmed by you or inherited from Shape). 
9. Define a Group to be a container of Shapes with suitable operations ap· 
plied to the various members of the Group. Him: Vector_ref. Use a 
Group to define a checkers (draughts) board where pieces can be moved 
under program control. 
10. Dcfme a class Pseudo_window that looks as much like a Window as you 
can make it without heroic efforts. It should have rounded corners, a 
label, and comrol icons. Maybe you could add some fake "coments," 
such as an image. It need not actually do anything. It is acceptable (and 
indeed recommended) to have it appear within a Simple_window. 
II. Define a Binary_tree class derived from Shape. Give the number of lev· 
els as a parameter (levels==O means no nodes, levels==l means one 
node, levels==2 means one top node with two sub·nodes, levels==] 
means one top node with two sub·nodes each with tvvo sub·nodes, etc.). 
Let a node be represented by a small circle. Connect the nodes by lines 
(as is conventional). P.S. In computer science, trees grow downward from 
a top node (amusingly, but logically, often c.L1led the root). 
12. Modify Binary_tree to draw iLS nodes using a vinuaJ function. Then, de· 
rive a new class from Binary_tree that overrides Lllat vinual function to 
lise a different representation for a node (e.g., a uiangle). 
13. Modify Binary_tree to take a paranleter (or parameters) to indicate what 
kind or line to use to COlUlect the nodes (e.g., an arrow pointing dO\vn or 
a red arrow pointing up). Note how this exercise and the last use twO al· 
ternative ways of making a class hierarchy more nexible and useful. 
51" 

S08 
C H APTER 14 • GRAPHI CS CLASS DESIGN 
14. Add an operation to Binary_tree that adds text to a node. You may have 
to modify the design of Binary_lree to implement this elegantly. Choose 
a way to identify a node; for example, you might give a string "Irrlr" for 
navigating left, right, right, left, and right down a binary tree (the root 
node would match both an initial I and an initial r). 
15. Most class hierarchies have nothing to do with graphics. Define a class 
Iterator with a pure virtual fUllction RexiO that returns a double . Now 
derive Vector_iterator and lisUterator from Iterator so that next() for a 
Vector_iterator yields a pointer to the next element of a vector<double> 
and lisUterator does the same for a list<double>. You initializc a Vec-
tor_iterator with a vector<double> and the first call of nexiO yields a 
poillter to its first element, if any. If there is no next clement, retum O. 
Test this by using a function void print(lterator&) to print the clements of 
a vector<double> and a list<double>. 
16. Defme a class Controller with four virtual functions onO, offO, seUevel(int), 
and showO. Derive at least t\vo classes from Controller. One should be a 
simple tCSt class where showO prints out whether the class is set to on or off 
and what is the current level. The second derived class should somehow 
control the line color of a Shape; the exact meaning of "level" is up to you. 
Try to fmd a third "tiling" to control with such a Controller class. 
17. The exceptions defined in the C++ standard library, such as exception, 
runtime_exception, and oULoCrange (§5.6.3), arc organized into a class 
hierarchy (with a useful virtual function whatO retuming a string suppos· 
edly explaining what went wrong). Search your information sources for 
the C++ standard exception class hierarchy and draw a class hierarchy 
diagram of it. 
Postscript 
The ideal for software is not to build a single program 11m does everything. The 
ideal is to build a lot of classes that closely reflect our concepts and that work to· 
gether to allow us to build our applications elegantly, with minimal effort (rela· 
tive to tile complexity of ollr task), with adequate perfomla.nce, and with 
confidence that the results pnxiuced arc correct. Such programs are comprehen· 
sible and maintainable in a way that code that was simply thrown together to get 
a particular job done as quickly as possible is not. Classes, encapsulation (as sup· 
ported by private and protected), inheritance (as supported by class derivation), 
and run-timc polymorphism (as supported by virtual functions) are among Ollr 
most powerful tools for structuring systems. 

'ct.. ,. 15 
Graphing Functions 
and Data 
"The best is the enemy of the good." 
-Voltaire 
I
f you are in any empirical field, you need to graph data. If you 
are in any field that uses math to model phenomena, you need 
1O graph functions. This chapter discusses basic mechanisms for 
such graphics. As usual, we show the usc of the mcdlanisms and 
also discuss their design. The key examples arc graphing a func-
tion of one argument and displaying values read from a fLie. 
509 

510 
CHAPTE R 15 • GRAPHING FUNCTIONS AND DATA 
15.1 Introduction 
15.2 Graphing simple functions 
15.3 Function 
15.3.1 Default a rgume nts 
15.3.2 More elamples 
15.4 Axis 
15.1 Introduction 
15.5 Approximation 
15.6 Graphing data 
15.6.1 Read ingafile 
\5.6.2 C("nerallayoul 
15.6.3 Scaling dala 
15.6.4 Building the graph 
Compared to the professional software systems you'll usc if slich visualization be-
comes your main occupation, the facilities presented here are primitive. Our pri-
mary aim is nOl elegance of omput, but understanding of how such graphical 
output can be produced and of the programming techniques used. You'll find the 
design techniques, programming techniques, and basic mathematical tools pre-
sented here of longer-term value than the graphics facilitics prescntcd. 111crcforc, 
plcase don't skim too quickly over the codc fragments - they contain marc of in-
terest than just the shapes they computc and draw. 
15.2 Graphing simple functions 
Let's start. Let's look at examples of what we can draw and what codc it takes to 
draw them. In particular, look at the graphics interface classes uscd. Here, first, 
are a parabola, a horizontal line, and a sloping line: 

IS .2 
GRAPHI NG SIMPL E FUNCTIONS 
Actually, sincc tltis chaptcr is about graphing functions, that horizontal linc isn't 
just a horizontallinc; it is what wc gct from graphing thc function 
double one(double) { return 1; } 
TIlis is about thc simplest function we could think of: il is a function of onc argu-
ment that for evcry argument returns 1. Since we don't need that argumcnt to 
compute thc result, we need not name it. For cvery x passed as an argument to 
oneO we get the y value 1; that is, tile line is defined by (x,y)==(x,l ) for all x. 
Like all beginning mathematical arguments, this is somewhat trivial and 
pedantic, so let's look at a slightly more complicated function: 
double slope(double xl { return xI2; ) 
lbis is the function tlml generated the sloping line. For every x, we gel the y value 
xI2. In otller words, (x,yl==b:,xI2). The point where tile two lines cross is (2,1). 
Now we can try something marc interesting, the square function that seems 
to reappear regularly in this book: 
double square(double xl { return x·x; } 
If you remember your high school geometry (and even if you don't), this defines 
a parabola with its lowest point at (0,0) and symmetric on the )' axis_ In other 
words. (x,y)==(x,x·xl. So, the lowest point where the parabola touches the slop-
ing line is (0,0). 
Here is the code that drew tllOse three functions: 
const int xmax = 600; 
const int ymax = 400; 
II window size 
const int x_orig = xmaxl2; 
/I position of (0,0) is center of window 
const int y_orig = ymaxl2; 
canst Point orig(x_orig,y_orig); 
canst int r_min = - 10; 
ca nst int r_max = 11 ; 
/I range [- 10:11 ) 
canst int n_points = 400; 
/I number of points used in range 
canst int x_scale = 30; 
/I scaling factors 
canst int y_scale = 30; 
Simple_window win(Point(l00, 100),xmax,ymax, "Function graphing"); 
511 

512 
C H APTER 15 • G RAPHING FUNCTION S AND DATA 
Function s(one,,_min,r_max,orig,R_poinls,x_scale,y_scale); 
Fu net ion s2(slope, r _m in, r _max, orig. " _poi nts,x_scale, y _seal e); 
Fu net ion s3(sq uare,r _mi n, r _max,orig, " _poi nts,x_scale, y _scale); 
win.attach(s); 
win .attach(s2); 
win .attach(sJ); 
win .waiCfor _buttonO; 
First, we define a bunch of constants so that we won't have to liuer our code with 
"magic numbers," Then, we make a window, define the funcoons, attach thelll to 
the window, and finally give contral lO the graphics system to do the actual drawing. 
All of this is repetition and "boilerplate" except for the definitions of the three 
Functions, 5, 52, and 53: 
Function s(one,,_min,,_max,orig,"_points,x_scale,y_scale); 
Fu n cl ion 52(s10 pe, r _mi n, r _max,orig, n_poi nts,x_scale, y _scale); 
Fu n cl ion s3(sq uare, r _mi n, r _max,orig, n_points,x_sca Ie, y _scale); 
Each Function specifics how its first argument (a function of one double arh'1.l· 
mcnt returning a double) is to be drawn in a window. The second and third ar· 
guments give the range of x (the argument to the function to be graphed). TIle 
fourth argument (here, orig) tells the Function where the origin (0,0) is to be 10· 
cated within the window. 
If you think that the many arguments arc confusing, we agree. Our ideal is to 
have as few arguments as possible, because having many arguments confuses 
and provides opportunities for bugs. However, here we need them. We'll explain 
the last three arguments later (§15.3). First, however, let's label our graphs: 

15.2 
G RAPHING SIMPLE FUNCTIONS 
We always try to make our graphs self-explanatory. People don't always read the 
surrounding text and good diagrams get moved around, so that the surrounding 
text is "Iose" Anything we put in as part of the picture itself is most likely to be 
noticed and - if reasonable - most likely to help the reader understand what we 
arc displaying. Here, we simply put a label on each graph. The code for "label-
ing" was three Text objects (sec §13.11): 
Texl ts(Point(l00,y_orig-40),lone"); 
Text ts2(Point(I00,y_orig+y_origl2-20), 1IxJ211); 
Text tsJ(Point(x_orig- l00,20), " .11 • .11"); 
win.seUabel("Function graphing: label functions"); 
win. wait_fa r _ bu llanO; 
From now on in this chapter, we'll omit the repetitive code for attaching shapes to 
the window, labeling the window, and waiting for the user to hit "Next." 
However, that picture is still not acceptable. We noticed that xJ2 touched .11 • .11 
at (0,0) and that one crosses xJ2 at (2,1) but that's far too subtle; we need axes to 
give the reader an unsubtle clue about what's going on: 
111e code for the axcs was twO Axis objects (§15.4): 
const int xlength = xmax-40; /I make the axis a bit smaller than the window 
const int ylenglh = ymax-40; 
Axis x(Axis: :x,Point(20,y_orig), xlength, xlengthlx_scaJe, "one notch == 1"); 
Axis y(Axis: :y,Point(x_orig, ylength+20), 
ylength, ylengthly_scale, "one notch == 1 "); 
513 

514 
CHAPTER 15 • GRAPHING FUNCTIONS AND DATA 
Using xlength/x_scale as the number of notches ensures that a notch represents 
the values 1, 2,3, etc. Having the axes cross at (0,0) is conventional. If you preFer 
them along the len and boltom edges as is conventional for the display of dam 
(sec §15.6), you can of course do that instead. Another way of distinguishing the 
a.xes from the data is to usc color: 
x.sel_color(Color:: red); 
y.sel_color(Color:: red); 
And we gel 
111is is acceptable, though for aesthetic reasons, we'd probably want a bit of 
empty space at the lOp to match what we have a l the bouom and sides. It might 
also be a better idea LO pllsh the label for the x axis further LO the left. ''''e left 
mesc blemishes, so that we could mention them - there arc always more aes· 
thelie details that we can work on. One part of a pl'Ogrammcr's art is to know 
when to stop and use the time saved on something better (such as leanting new 
techniqucs or sleep). Remember: "The best is the enemy of the good." 
15.3 Function 
TIle Function graphics interface class is defined like this: 
struct Function : Shape { 
II the function parameters are not stored 

15.3 
FUNCTION 
Function(Fct f, double fl , double f2, Point orig, 
int count = 100, double xscale = 25, double yscaJe = 25); 
) ; 
Function is a Shape with a constructor that generates a lot of line segments and 
stores them in its Shape part. TIlose line segments approximate the values of 
function f. "n le values of f are calculated counl times for values equally spaced in 
the Ifl: r2) range: 
Function: :Function(Fct f, double rl , double r2, Point xy, 
int count, double xscale, double yscale) 
/I graph fIx) for x in 1r1 :r2) using count line segments with (0,0) displayed at xy 
/I x coordinates are scaled by xscale and y coordinates scaled by yscalc 
{ 
) 
if (r2-rl<=0) error("bad graphing range"); 
if (count <=0) error("non-positive graphing count "); 
double dist = (r2- rl)/count; 
double r = rl; 
for (int i = 0; kcount; ++i) { 
add(Point(xy.x+inl(r"xscale),xy_y-int(f(r)·yscale»); 
r += dis.; 
) 
TIle xscale and yscale values are used to scale the x coordinates and the y coordi-
nates, respectively. We typically need to scale our values to make them fit appro-
priately into a drawing area of a window. 
Note that a Function object doesn't store the values given to its constructor, 
so we can't later ask a function where its origin is, redraw it with different scaling, 
etc. All it does is 10 store points (in its Shape) and draw itself on the screen. If wc 
wamed the flexibility to change a Function after constnlction, we would have to 
store the values we wanted to dumge (see exercise 2). 
15.3.1 Default arguments 
Note the way the Function constructor arguments xscale and yscale were given 
initializers in t.he declaration. Such initializers arc called de/lIltl (lrgumellts and their 
values are used if a caller doesn't supply values. For example: 
Function stone, r_min, r_max,orig, n_points, x_scale, y_scale); 
Function s2(slope, r_min, r_max, orig, n_points, x_scale); 
/I no yscale 
Function s3(square, r_min, ,_max, orig, n_points); /I no xscale, no yscale 
Function s4(sqrt, orig, r_min, r_max); 
/I no count, no xscalc, no yscale 
515 

516 
CHAPTER 15 • G RAPHING FUNC T IONS AND DATA 
This is equivalent to 
Function s(one, ,_min, ,_max, orig, "_points, x_scale, y_scale); 
Function s2(slope, ,_min, ,_max,orig, " _points, x_scale, 25); 
Function s3(square, ,_min, ,_max, orig, "_points, 25, 25); 
Function s4(sqrt. orig, ,_min, ' _max, 100, 25, 25); 
Default arguments are used as an alternative to providing several overloaded 
functions. Instead of defining one constructor with three default arguments, we 
could have defined four constnlClors: 
struct Function : Shape ( 
/I alternative, not using default arguments 
); 
Function(Fct f, double rl, double f2, Point orig, 
int count, double "scale, double yscale); 
/1 default scale of y: 
Function{Fct f, double rl, double r2, Point orig, 
int caunt, double xscale); 
/I default scale of x and y: 
Function(Fct f, double rl, double r2, Point orig, int count); 
/I default count and default scale of x or y: 
Function(Fct f, double rl, double r2, Point orig); 
It would have been more work to define four constructors, and with the four-
constructor version, the nature of the default is hidden in the constructor defini-
tions rather than being obvious from the declaration. Default arguments arc 
rrequently used for constructors but can be useful for all kinds of runelions. You 
can only define derauh arguments ror trailing arguments. For example: 
shuct Function : Shape { 
Funetion(Fct f, double rl, double r2, Point orig, 
int count = 100, double xseale, double yscale); 
II error 
) ; 
lr an argument has a default argument, all subsequent arguments must also have 
one: 
slruet Function: Shape { 
Funclion(Fct f, double rl, double r2, Point orig, 
int count = 100, double xscale=25, double yscale=25); 
); 
Sometimes, picking good derault arguments is easy. Examples or that arc the de-
rault for string (the empty string) and the default for vector (the empty vector). 

15,3 
FU NCTION 
In other cases, such as Function, choosing a default is less easy; we found the 
ones IVe used afcer a bit of c.'<perimemation and a failed attempt. Remember, you 
don't have to provide default arguments, and if you find it hard to provide one, 
just leave it to your user to specify that argument. 
15.3.2 More examples 
\-\'e added a couple more functions, a simple cosine (cos) from the standard Ii· 
brary, and - just to show how we can compose functions - a sloping cosine that 
follows the 'KI2 slope: 
double slopin&-cos(double x) { return cos(x)+slope(x); } 
Here is the result: 
TIle code is 
Function s4(cos,r_min,r_max,orig,400,20,20); 
s4.scCcolor(Color:: blue); 
Function s5(sloping...cos, r_min,r_max,orig,400,20,20); 
x.label.move(-160,O); 
x.notches.seccolor(Color:: dark_red); 
In addition to adding those twO functions, we also moved the x a.xis's label and 
Gust to show how) slightly changed the color of its notches, 
Hnally, we graph a log, an exponential, a sine, and a cosine: 
517 

518 
(HAPTER 15 • GRAPHING FUNCTIONS AND DATA 
Fu netion f1 (log,O.OOOOO1 , f _max,orig,200,30 ,30); 
Function f2(sin,,_min,,_max,orig,200,30,30); 
f2.seCcolor(Color: : blue); 
fu nclion £J( COS,, _mi n.r _max,orig,200 ,30,30); 
Fu nclion f4( exp.' _min, r _max ,orig,200,30,30) i 
II logO logarithm, base e 
/I sinO 
/I cosO 
1/ expO exponential cAx 
Since 10g(0) is undefined (mathematically, minus infinity), we started the range 
for log al a small positive number. The result is 
Rather than labeling those functions we used color. 
Standard mathematical functions, such as cosO, sinO, and sqrlO, arc declared 
in the standard library header <cmath>. Sec §24.8 and §B.9.2 for lists of the SUIIl-
dard mathematical functions. 
15.4 Axis 
We usc A)(is wherever we present data (e.g., §15.6.4) because a graph without in-
formation that allows us to understand its scale is most often suspect. An Axis 
consists of a line, a number of ';notches" on that line, and a text label. The Axis 
constructor computes the a..xis line and (optionally) the lines used as notches on 
that line: 
slruct Axis: Shape { 
enum Orientation (x, y, z }; 
Axis(Orientation d, Point xy, int length, 
int number_oCnotches=O, siring label = ""); 

15.4 
AXIS 
); 
void draw_linesO const; 
void move(int dx, int dy); 
void set_eolor(Color e); 
Text label; 
Lines notches; 
TIle label and notches objects are left public so that a user can manipulate them. 
For example, you can give the notches a different color from the line and moveO 
the label to a more convenient location. Axis is an example of an object com· 
posed of several semi·independent objects. 
The Axis constructor places the lines and adds the "notches" if num-
bef_oCnolehes is greater than zero: 
Axis: :Axis(Orientation d, Point xy, inllength, int n, string lab) 
: labeI(Point(O,O),lab) 
if (length<O) error("bad axis length"); 
switch (dH 
case Axis: :x: 
Shape: :add(xy); 
/I axis line 
Shape:: add(Point(xy.x+length, xy.y)); 
) 
if (1<n) { 
/I add notches 
int dist = length/n j 
int x = xy.x+dist; 
for (int i = 0; i<n; ++i) ( 
notch es. add(Point(x, xy. y), Point(x, xy. y-5» ; 
x += dist; 
) 
) 
label. move(length/3, xy. y+ 20); 
break; 
/I put the label under the line 
ease Axis: :y: 
( 
Shape : :add(xy); 
II a y axis goes up 
Shape: : add(Point(xy.x,xy. y-Iength»; 
if (1<n) ( 
/I add notches 
int dist = length/n j 
int y = xy.y-dist; 
519 

520 
} 
} 
C HAPTER 15 • GRAPHING FUNCTIONS AND DATA 
for (int i = 0; k ni ++i) { 
notches.add(Point(xy.x,y),Point(xy.x+S,y»; 
y -= disl; 
} 
label. move(xy." - 1 0 ,.y. y-Ie ngth- l 0); 
break; 
/I put the label at top 
caseAxis: :z: 
error("z axis not implemented "); 
} 
Compared to much real-world code, tills constructor is very simple, but please have 
a good look at it because it isn't quite bivinl and it illustrates a few useful techniques. 
Note how we store the line in the Shape pan of lhe Axis (using Shape: :addO) but 
the notches arc stored in a separate object (notches). 11ml way, we c.:m manipulate 
the line and the notches independently; for example, we c.m give each its own color. 
Similarly, a label is placed in a fixed position relative to its axes, but since it is a 5Cp,,1.-
rate object, we can always move it to a better spot. "'~ lise the enullleration O rien-
tation to provide a convenient and non-error-prone nota.oon for lIsers. 
Since an Axis has three parts, we must supply functions for when we want to 
manipulate an Axis as a whole. For example: 
void Axis: :draw_linesO const 
{ 
Shape: :draw_Jines()i 
notches.drawOi 
II the notches may have a different color from the line 
label.drawOi 
II the label may have a different color from the line 
} 
We lise draw() rather than drawJinesO for notches and label to be able to usc 
the color stored in them. ' 11e line is stored in the Axis:: Shape itself and uses the 
color stored there. 
We can set the color of the line, the notches, and the label individually, but sty-
listically it's lIsually better not to, so we provide a fUllction to set all three to the same: 
void Axis: :sc,-color(Color c) 
{ 
} 
Shape: :sel_color(c)i 
notches .set_ color(c); 
label. seC color( c); 

15.5 
APPROXIMATION 
Similarly, Axis::move() moves all the parts of the Axis together: 
void Axis: :move(int dx, int dy) 
{ 
) 
Shape: :move(dx,dy); 
notches.move(dx,dy); 
label.move(dx,dy); 
15.5 Approximation 
Here we give another small example of graphing a function: we "animaten the 
calculation of an exponential function. The purpose is to help you get a feel for 
mathematical functions (if you haven't already), to show the way graphics can be 
used to illustrate computations, to give you some code to read, and finally to 
warn about a conunon problem with computations. 
One way of computing an exponential function is La compute the series 
(" == 1 + x+ .rl2! + xll3! + .0/4! + ... 
111e more terms of this sequence we calculate, Ihe more precise our value of (" 
becomes; that is, the more tenns we calculate, Ihe more digits of the result will be 
mat.hematically correct. What we will do is La compute this sequence and graph 
the result after each ternl. The exclamation point here is used wilh the common 
mat.hematieal meaning: fact.orial; that. is, we graph these functions in order: 
expO(x) = 0 
/I no terms 
exp1(x) = 1 
/I one term 
exp2(x) = 1+x 
/I two terms; pow(x, t )lfac(l )::.=x 
exp3(x) = 1+x+pow(x,2)1fac(2) 
exp4(x) = 1+x+pow(x,2)1fac(2)+pow(x,3)/fac(3) 
exp5(x) = 1+x+pow(x,2)1fac(2)+pow(x,3)1fac(3)+pow(x,4)/fac(4) 
Each function is a slightly better approximation of tf than the one before it. Here, 
pow(x,n) is tlle standard library function that returns x". There is no factorial 
function in the standard library, so we must define our own: 
inl fac(inl n) 
{ 
/I factorial(n); nl 
inl r = 1; 
while (n>1) { 
r·=n; 
--n; 
521 

522 
CH A PTER 15 • GRAPHIN G FU NCTIONS AND DATA 
return f; 
For an alternative implementation of facO, sec exercise 1. Civen facO, we can 
compute the nth tern) of the senes like this: 
double term(double X, int n) { return pow(x,n)/fac(n); } 
1/ nth term of series 
Given termO, calculating the exponential to the precision of n terms is now casy: 
double expe(double x, int Il) 
( 
double sum = 0; 
/I sum of n terms for x 
for (int i=O; i<n; ++i) sum+=lerm(x,i); 
return sum; 
How can we graph tills? From a programming point of view, the difficulty is that 
ollr graphing class, Function, lakes a function of one argument and e"peO takes 
tWO argumenLS. Given C++, as we have seen it so far, there is no rcally elegant 
solution to this problem, so for now, we'll usc a simple and incJcgam solUlion 
(but sec exercise 3). We can take the precision, n, out of the argument list and 
make it a variable: 
double expN(double x) 
( 
return expe(x,expN_number_oCterms); 
) 
Now expN(x) calculates an exponential to the precision detcrmined by the valuc 
of expN_number_oCterms. Let's usc that to produce some graphics. First, we'll 
pmvide some axcs and the "real" exponential, the standard library expO, so that 
wc can see how close our approximation using expNO is: 
Fu nClion real_ exp( exp, r _m in, r _max,orig,200,x_scale, y _scale); 
real_cxp.seccolor(Color:: blue); 
111cn, we can loop through a series of approximations increasing the number of 
terms of our approximation, 11 , each time amund: 

15.5 
APPROXIMAT ION 
for (int n = 0; n<50; ++n) { 
ostringstream ss; 
) 
ss « "exp approximation; n==" «
n ; 
wi n. sel_label (ss.strO. c_slrO); 
expN_number_oCterms = n; 
/I gel next approximalion: 
Function e(expN,r_min,r_max,orig,200,x_scale,y_scalel; 
win.attach(e); 
win.wait_for_buttonO; 
win.detach(e); 
ote the final detach(e) in that loop. The scope of the Function object e is the 
block of the for-statement. Each time we enter that block we get a new Function 
called e and each time we exit the block that e goes away, to be replaced by the 
next. 111e window must not remember the old e because it will have been de-
stroyed. l 1lUs, detach(e) ensures that the window docs not try to draw a de-
stroyed object. 
-nlis first gives a window with just the axes and the "real" exponential ren-
dered in blue: 
one MIItn .,,, 1 
\o\Te sec that exp(O) is 1 so that our blue "real exponential" crosses lhe J axis in (0,1). 
If you look carefully, you'll see L1mt we actually drew the zero term approxi-
mation (expO(x)==O) as a black line right on top of L1le x axis_ Hitting "Next," we 
523 

524 
C HAPTER 15 • GRAPH ING FUNCTIONS AN D DATA 
gel the approximation usingjusl one tcrm. NOle that we display the number of 
terms lIsed in the approximation in the window label: 
one nDtc:h". 1 
That's the function exp1(x)==l , the approximation usingjusl one term of the se-
quence. 1t malcilcs the exponential perfectly at (0,1), but we can do better: 
With twO terms (1+x), we gel the diagonal crossing the y axis at (0,1). With three 
terms (1+x+pow(x,2)1fac(2»), we can see the beginning of a convergence: 

15.5 
APPROXIMATION 
one noICh· , 
With ten terms we arc doing rather well. cspeciaJly for values larger than -3: 
If we don't think tOO much about it, we might believe that we could get bener 
and better approximations simply by using more and more temlS. However, 
there are limits. and after 13 terms something strange starts to happen. Hrst, the 
approximations start to get slightly worse, and at 18 terms vertical lines appear: 
525 

526 
CHAPTER 15 • G RAPHING FUNCTIONS AND DATA 
one i"IOICI'I'" 1 
Remember, nanling-point aritrunctic is nOt pure math. Floating-point numbers 
are simply as good an approximation LO real numbers as we can gel with a fixed 
number of bits. What happened was that our calculation started LO produce val-
ues t.hat couldn't be represented as doubles so that Olll' results started to diverge 
from the mathematically correct answers. For more information, sec Chapter 24. 
'1us last picture is also a good illustration of the principle that "it looks OK-' 
isn't the same as "tested." Before giving a probrram to someone else to usc. first 
test it beyond what at first seems reasonable. Unless you know belter, miming a 
program slightly longer or with slightly dilTerent data could lead to a real mess -
as in this casc. 
15.6 Graphing data 
Displaying data is a highly skilled and highly valucd craft. When done wcll, it 
combines technical and artistic aspccts and can add signilicandy to our under-
standing of complcx phcnomena. However, that also makes graphing a huge area 
that for the most part is unrelatcd to programmiJlg tcchniqucs. Here, wc'll just 
show a simple examplc of displaying data read rrom a lilc. The data shown rep-
resents the agc groups of Japanese people over almost a century. 111C data to lhe 
right of the 2008 line is a projeClion: 

15.6 
GRAPHING DATA 
. .. , , '.f 
age 15.J;4 ------------1-------_ 
.g~ G-U 
.----
.,e li5' 
We'll usc tltis example to discuss the progranulling problems involved in present-
ing sLich data: 
Reading a file 
5caJing dam to fit the window 
Displaying the data 
I ... ,bcling the graph 
We will not go into artistic details. Basically, this is "graphs for gceks,'" not "graph, 
ical art." Clearly, you can do better artistically when you need to. 
Given a set of data, we must consider how best to display it. To simplify, we 
will only deal with data that is easy to display using two dimensions, but that's a 
huge part of the data most people deaJ ,vith. Note that bar graphs, pie chans, and 
similar popular displays rcally are JUSt two·dimcnsional data displaycd in a fancy 
way. "nlree-dimcnsional data can oflcn bc handled by producing a series of twO-
dimensionaJ images, by superimposing several two-dimensional graphs onto a 
single window (as done in the '1apanese age" example), or by labeling individual 
points with information. If we want to go beyond that, we'll have to write new 
graphics classes or adopt another graphics library. 
So, Ollr data is basically pairs of values, such as (year,number of children). If 
we have more data, sllch as (year,number of children, number of adults,number 
of elderly), we simply have to decide wltich pair of values - or pairs of values -
we ,vant to draw. In our example, we simply graphed (year,number of children), 
(year, number of adults), and (year,number of elderly). 
111erc are many ways of looking at a set of (x,y) pairs. When considering 
how to graph such a set it is important to consider whether one value is in some 
527 

528 
C HAPTE R 15 • G RAPHI NG FUNCT IONS AND DATA 
way a function of me Olher. For example, for a (year,steel production) pair it 
would be quite reasonable to consider the steel production a function of the year 
and display the data as a continuous line. Open_polyline (§13.6) is the obvious 
choice for graphing such data. If y should not be seen as a function of x, for ex-
ample (gross domestic product per person,population of counlry), Marks 
(§ 13. 1S) can be used to pial uncolillccted poims. 
Now, back to our Japanese age distribution example. 
15.6.1 Reading a file 
The file of age distributions consists of lines like this: 
( 1960:30646 ) 
(1970 : 24697 ) 
(1980,23689) 
~nlC first number after the colon is the percentage of children (age 0-14) in the 
population, lhe second is lhe percentage of adults (age 15-64), and the third is the 
pcrccllwge of U1C elderly (age 65+). Our job is to read those. Note that the fOI1l1;u, 
ring of the data is sliglllly irregular. As lISUal, we have to deal with such details. 
"Ib simplify that task, we first define a type Distribution to hold a data item 
and an input opcrator to read such data items: 
struct Distribution { 
int year, young, middle, old; 
); 
istream& operator» (istream& is, Distribution& d) 
/I assume formal: ( year : young middle old ) 
{ 
char chl = 0; 
char ch2 = 0; 
char ch3 = 0; 
Distribution dd; 
if (is » chl » dd.year 
» ch2 » dd.young» dd.middle » dd.old 
»ch3) { 
if (chl! = '(' II ch2! =':' II chJ !=')') { 
is.clear(ios_base : : failbit ); 
return is; 
) 

15. <> 
GRAPHING DATA 
else 
return is; 
d =ddi 
return is; 
TIlis is a straightfonvard application of the ideas from Chapler 10. If tills code isn't 
dear to you, please review tllat chapter. We didn't need to defme a Distribution 
type and a »
operator. However, it simplifies tile code compared to a bnlte-force 
appl'Oadl of "juSt read tile numbers and graph tllem." Our usc of Distribution splits 
tile cooe up into logical parts to help comprehension and debugging. Don't be shy 
about introducing types ')USt to make the code dearer." We deftne classes LO make 
the cooe cOlTcspond more directly to the way we tllink aboUl tile concepts in our 
code. Doing so even for ';small" concepts that are used only very locally in our 
code, such as a line of data representing the age distribution for a year, can be most 
helpful. 
Given Distribution, the read loop becomes 
string file_name = "japanese-age-data_txt"; 
ifstream ifs(filc_name.c_slr(»; 
if (! ifs) error("can'l open ",file_name); 
1/ . 
Distribution d; 
while (ifs>>d) ( 
} 
if (d.year<base_year II end_year<d.year) 
error("year out of range"); 
if (d.young+d.middle+d.old != 100) 
crror("percentages don't add up"); 
1/ ... 
TIlat is. we try to open tile me japanese-age-dafa.txt and exit the program if we 
don't find that file. h is often a good idea 1I0t to "hardwire" a file name into the 
source code the way we did here, but we consider tills program an example of a 
small "one-orr effort, so we don't burden the cade with facilities that arc more 
appropriate for long-lived applications. On the other hand, we did pul japanese-
age-data.lxt into a named string variable so the program is easy to modify if we 
want to usc it - or some of its code - for something else. 
The read loop checks that tile year read is in the expected range and tllat the 
percentages add up to 100. That's a basic sanity check for the data. Since » 
checks the format of each individual data item, we didn't bother with further 
checks in the main loop. 
529 

530 
CHAPTER 15 • GRAPH ING FUNCTIONS AND DATA 
15.6.2 General layout 
So what do we want to appear on the screen? You can sec our answer at the be-
ginning of §15.6. The data seems to ask for three Open_polylines - one for each 
age group. These graphs need to be labeled, and we decided lO write a "caption
n 
for each line at the left-hand side of the window. In UllS case, lhat seemed clearer 
than the common alternative: to place the label somewhere along the line itself. 
In addition, we usc color to distinguish the graphs and associate their labels. 
We wam to label the x axis with the years. The vertica1line through the year 
2008 indicates where the graph goes from hard data to projected data. 
We decided to just use the window's label as the citJe for our graph. 
Getting graphing code both correct and good-looking can be surprisingly 
tricky. The main reason is that we have to do a 10l or fiddly calculations or sizes 
and offsets. To simpliry that, we start by defining a set or symbolic constants that 
defines the way we use our screen space: 
canst int xmax = 600; 
II window size 
canst int ymax = 400; 
canst int xoUset = 100; 
/I distance (rom left·hand side of window 10 y axis 
canst int yoUset = 60; 
/I distance from bottom of window 10 x axis 
canst int xspace = 40; 
/I space beyond axis 
canst int yspace = 40; 
canst int xlength = xmax-xoffset-xspace; 
canst int ylength = ymax-yoffset-yspace; 
II length of axes 
Basically this defines a rectangular space (the window) with another rectangle 
(defmed by the axes) within it: 
yspace 
ymax 
ylength 
xoffset 
xspace 
xlenglh 
yoffset 

15.6 
GRAPHI NG DATA 
We find that without sllch a "schematic view" of where things arc in our window 
and the symbolic constilllts lhat define it, we get lost and become frustrated when 
our output doesn't reflect our wishes. 
15.6.3 Scaling data 
Next we need to define how to fit our data into that space. We do that by scaling 
the data so that it fits into the space defined by the axes. To do that we need the 
scaling factors that are the ratio between the data range and the axis range: 
consl inl base_year = 1960; 
consl inl end_year = 2D40; 
consl double xscale = double(xlenglh)/(end_year-base_year); 
consl double yscale = double(ylength)/l00; 
We want our scaling factors (xscale and yscale) to be floating-point numbers - or 
our calculations could be subject to serious rounding en·ors. To avoid integer di-
vision, we convert our lengths to double before dividing (§4.3.3l. 
\Ve call now place a data point on the x axis by subtracting its base value 
(1960), scaling with xscale, and adding the xoffset. A J value is dealt with simi-
larly. We find that we can never remember to do that quite right when we try to 
do lhat repeatedly. It may be a trivial calculation, but it is fiddly and verbose. 1'0 
simplify the code illld minimize that chance of error (and minimize frustrating de· 
bugging), we define a little class to do the calculation for us: 
class Scale { II data value to coordin(1te conversion 
int cbase; 
inl "base; 
double scale; 
II coordinate base 
1/ base of values 
public: 
); 
Scale{int b, int vb, double s) :cbase(b), vbase(vb), scale(s) {} 
int operator()(inl v) consl { return cbase + (v- vbase)·scale; ) 
We walll a class because the calculation depends on three constant values that we 
wouldn't like to unnecessarily repeal. Given that, we Cilll define 
Scale xs(xoffset,base_year,xscale); 
Scale ys(ymax-yoffset,O,-yscale); 
Note how we make the scaling factor for ys negative to reflect the fact that y co-
ordinates grow downward whereas we lIsually prefer higher values to be repre-
sented by higher points on a graph. Now we can use xs to convert a year to an x 
coordinate. Similarly, we can lise xy to convert a percentage to a y coordinate. 
531 

C HAPTER 15 • GRAPHING FUNCTIONS AND DATA 
15.6.4 Building the graph 
Finally, we have all the prerequisites for writing the graphing code in a reason-
ably elegant way_ We start creating a \vindow and placing the axes: 
Window win(Point(l00, l00),xmax,ymax, "Aging Japan"); 
Axis x(Axis: :x, Point(xoffset,ymax-yoffset), xlength, 
(end_year-base_year)/10, 
"year 
1960 
1970 
1960 
1990 
" 
"2000 
2010 
2020 
2030 
2040"); 
x.label.move(-l00,O) ; 
Axis y(Axis: : y, Point(xoffset,ymax- yoffsel), ylenglh, 10, "% of population"); 
Line curn: nCyear(Poi nl( xs(2008), ys(O», Point(xs(2008), ys(l 00»)); 
cu rren Cyear. seCstyle(Li n e_style: : dash); 
~nl C axes cross at Point(xoffsel,ymax-yoffset) representing (1960,0). Note how 
the notches are placed to reflect the data. On the y axis, we have ten notches each 
representing 10% of the population. On the x axis, each notch represents ten 
years, and the exact number of notches is calculated from base_year and 
end_year so that if we change that range, the axis would automatically be recal-
culated. 111is is one benefit of avoiding "magic constants" in the code. 111e label 
on the x axis violates that rule: it is simply the result of fiddling with the label 
string until the numbers were in the right position under the notches. To do bet· 
ter, we would have to look to a sel of individual labels for individual "notches." 
Please note the curious fOnllauing of the label string. We used tWO adjacent 
su;ng literals: 
"year 
"2000 
1960 
2010 
1970 
2020 
1980 
2030 
1990 
2040" 
" 
Adjacent string literals arc concatenated by the compiler, so that's equivalent to 
"year 
1960 
1970 
1980 
1990 
2000 
2010 
2020 
2030 
2040" 
11mt can be a useful "trick" for laying out long string literals to make Ollr code 
more readable. 
The currenC line is a venicaJ line that separates hard data from projected 
data. Note how xs and ys arc lIsed to place and scale the line just right. 
Given the axes, we can proceed to the data. We define three Open_polylines 
and ftll them in the read loop: 

15 .6 
GRAPHIN G DATA 
Open_polyline children; 
Open_polyline adults; 
Open_polyline aged ; 
Distribution d; 
white (ifs>>d) { 
if (d.year<base_year II end_year<d.year) error("year oul of range"); 
if (d.young+d.middle+d.old != 100) 
error("percenlages don't add up"); 
inl x = "s(d .year): 
chi Idren .add( Poi nl(x, ys( d . you ng»): 
ad ulls .add (Point (x, ys( d. middle»): 
aged .add(Poin I(x, ys(d. old»); 
"111e use of xs and xy makes scaling and placement of the dala trivial. "Little 
classes," such as Scale, can be immensely important for simplifying notation and 
avoiding unnecessary repetition - thereby increasing readability and increasing 
the likelihood of correctness. 
10 make the graphs more readable, we label each and apply color: 
Text children_label(Poinl(20,children.point(O).y), "age 0·14"); 
children.seCcolor(Color:: red); 
children_label.sel_color(Color: : red); 
Text adullsJabel(Point(2(I,adulls.point(0).y), "age 15·64"); 
adulls.sel_color(Color: :blue): 
adulls_label.seccolor(Color: : blue); 
Text agedJabel(Point(20,aged.point(O).y), "age 65+"); 
aged.seCcolor(Color: : dark_green); 
aged_label.sct_color(Color: :dark-&reen); 
Finally, we need to auach the various Shapes to the Window and start the CUI 
system (§14.2.3): 
wi n .attach{ ch ild fen); 
wi n .at tach(ad u lis); 
win.attach(aged); 
win. at tach (ch ildre n_label); 
win .atlach (adu IIsJabel); 
win.atlach(agedJabel); 
533 

534 
( HAPTER 15 • GRAP HING FUNC TIONS AND DATA 
win.attach(x); 
win.attach(y); 
win.altach(currenl_year); 
All the code could be placed inside mainO, but we prefer to keep the helper classes 
Scale and Oistribution outSide together Wilh Dislribution's input operalOr. 
In case you have forgotten what we were producing, here is the output again: 
_ 
A~nr: Jap .. " 
:. r,.. 'X 
" .. , , , . 
_Ie 15-54 r-------------t----__ _ 
.,e 6St 
~,. .,71 ._ .,. r.. 
21.1 
N2I 
!Ill 
N4I 
..; Drill 
Function graphing drill: 
I. Make an empl)' 600-by-600 Window labeled "Function graphs." 
2. Note that you'll need to make a project with the properties specified in 
the "installation of FLTK" nOte from the course website. 
3. You'll need to move Graph.cpp and Window.cpp into your project. 
4. Add an x axis and a y axis each of length 400, labeled " 1 = = 20 pixcls" 
and with a notch every 20 pi.xcJs. The axes should cross at (300,300). 
5. Make both axes red. 
In the following, use a separale Shape for each function to be graphed: 

CHAPTER 15 REVIEW 
I. Graph the function double one(double x) ( return 1; ) in the range 
[-10, 11] with (0,0) at (300,300) using 400 points and no scaling (in the 
window). 
2. CluUlge it to lise x scale 20 and y scale 20. 
3. From now 0 11 use that range, scale, etc. for all graphs. 
4. Add double slope(double xl ( return xflj ) to the window. 
5. Label the slope with a Text "x/2" at a point juSt above its boltom left end 
point. 
6. Add double square(double x) ( return x-x; ) to the \-."indow. 
7. Add a cosine to the window (don't write a new function). 
8. Make the cosine blue. 
9. Write a function sloping....cosO that adds a cosine to slopeO (as defmed 
above) and add it to the window. 
Class definition drill: 
1. Defme a slruct Person containing a string name and an int age. 
2. Define a variable of type Person, initialize it with "Goofy" and 63, and 
Wlite it to the screen (CaUl). 
3. Define an input (» ) and an output « <) operator for Person; read in a 
Person from the keyboard (cin) and write it out to the screen (cout). 
4. Give Person a constructor initializing name and age. 
5. Make the representation of Person private, and provide consl member 
functions nameO and ageO to read the name and age. 
6. Modify » and « to work with the redefined Person. 
7. Modify the conSlmC('Qr to check that age is [0:150) and that name doesn't 
contain any of the characters ; : " , [ J • & " % S # @ !. Use errorO in case 
of error. Tesl. 
8. Read a sequence of Persons from input (cin) imo a veclor<Person>; 
write them out again to the screen (CaUl). Test with correct and erro· 
neOllS input. 
9. Change the representation of Person to have first_name and second_name 
instead of name. Make it an error not to supply both a first and a second 
name. Be slire to fIX » and « also. Test. 
Review 
1. What is a function of one argumem? 
2. When would you usc a (continuous) line to represent data? \!\Then do 
you usc (discrete) points? 
3. What function (mathematical fonnula) defines a slope? 
4. What is a parabola? 
535 

CHAPTER 15 • GRAPHING FUNCTIONS AND DATA 
5. How do you make an x axis? Ay axis? 
6. What is a dcfault argumem and when would you use one? 
7. How do you add functions together? 
8. How do you color and label a graphed function? 
9. What do we mean when we say that a series approximates a function? 
10. Why would you sketch out the layout of a graph before wriling the code 
to draw it? 
11. How \ ... ·ould you scale your graph so that the input will fit? 
12. How would you scale the input without trial and error? 
13. \lVhy would you fornlat your input rather than just having the file can· 
tain "the numbers"? 
14. How do you plan me generallayoUl of a graph? How do you rcflect mat 
layout in your code? 
Terms 
approximation 
default argument 
function 
scaling 
screen layout 
Exercises 
1. Here is another way of defining a factorial function: 
int fac(int n) { return n>11 n·fac(n-1) : 1; ) II factorial n! 
It will do fac(4) by first deciding that since 4>1 it must be 4-fac(3), and 
mat's obviously 4-3-fac(2), which again is 4-r2-fac(1 ), which is 4-3*2·1. 
Try to see that it works. A function that c.111s itself is said to be rtffirsiue. 
The alternative implementation in §15.5 is called I~eralive becilusc it iterates 
through the values (using while). Verify that the recursive facO works and 
gives the same results as the iterative facO by calculating the factorial of 0, 
r, 2, 3, 4, up until and including 20. Which implementation of facO do you 
prefer, and why? 
2. Define a class fet that is JUSt like function except that it stores its con· 
structor arguments. Provide fct with "reset" operations, so that you can 
use it repeatedly for differem ranges, differem functions, etc. 
3. Modify Fet from the previous exercise to take an extra argument to can· 
trol precision or whatever. Make the type of that argument a template pa· 
rameter for extra flexibility. 
4. Graph a sine (sinO), a cosine (cosO), the sum of those sin(x)+cos(x), and 
the sum of the squares of those sin(x)-sin(x)+cos(x)-cos(x) on a single 
graph. Do provide axes and labels. 

CHA PTER IS POSTSC RIPT 
5. "Animate" (as in §IS.5) the series 1- 1/3+1/S- 1n +119- 1/11- .... It is 
known as Lcibniz's series and converges to piJ4. 
6. Design and implement a bar graph class. Its basic data is a veclor<double> 
holding .N values, and eacl) value should be represented by a "bar" that is 
as a rectangle where the heiglll rcprcsems the value. 
7. Elaborate the bar graph class to allow labeling of the graph itself and its 
individual bars. Allow the use of color. 
8. Here is a coUection of heights in centimeters together with the number of 
people in a group of that height (rounded to the nearest Scm): (170,7), 
(175,9), (180,23), (185,17), (190,6), (195,1). How would you graph that 
data? If you can't think of anything better, do a bar graph. Remember to 
provide axes and labels. Place the data in a file and read it from that fIle. 
9. Find another data set of heights (an inch is about 2.54cm) and graph 
them with your program from the previous exercise. For example, search 
the web for "height distribution" or "height of people in the United 
States" and ignore a lot of rubbish or ask your friends for their heights. 
Ideally, you don't have to change anything for the new data set. Calcu· 
lating the scaling from the data is a key idea. Reading in labels from 
input also helps minimize changes when you want to reuse code. 
10. What kind of data is unsuitable for a line graph or a bar graph? Find an 
example and find a way of displaying it (e.g., as a coUection of labeled 
points). 
11. Find the average maximum temperatures for each month of the year for 
two or more locations (e.g., Cambridge, England, and Cambridge, 
Massachusetts; there arc lots of towns called "Cambridge") and graph 
them together. As ever, be careful with axes, labels, usc of color, etc. 
Postscript 
Graphical representation of data is important. We simply understand a well-
crafted graph better than the set of numbers that was used to make it. Most peo-
ple, when they need to draw a graph, use someone else's code - a library. How 
are such libraries constructed and what do you do if you don't have one handy? 
'What arc the fundamental ideas underlying "an ordinary graphing tool"? Now 
YOLi know: it isn't magic or brain surgery. We covered only two-dimensional 
graphs; three·dimensional graphing is also very useful in science, engineering, 
marketing, etc. and can be even more fun. Explore it someday! 
537 


.t .. 
r 16 
Graphical User Interfaces 
"Computing is not about 
computers any more. 
It is about living." 
- Nicholas Negroponte 
A 
graphicaJ user interface (G U 1) allows a lIscr to interact 
with a program by pressing buttons, selecting from menus, 
cmering dam in various ways, and displaying textual and graphi-
cal entities on a screen. TImt's what we are used to when we in-
teract with our computers and with wcbsilCS. In this chapter, we 
show the basics of how code can be written to define and control 
a GUI application. In particular, we show how to write code that 
imcracLS with emities on the screen using callbacks. Our GUI 
facilities arc built "on lOp of' system facilities. The low-level 
features and interfaces are presented in Appendix E, which uses 
features and techniques prescmcd in Chapters 17 and 18. Here 
we focus on usage. 
539 

16.1 User interface alternatives 
16.2 The "NeJCtH button 
16.3 A simple window 
16.3.1 It c.arollback function 
16.3.2 It wail loop 
16.4 Bulton and other Widgets 
16.4.1 Widgets 
16.4.2 Bul10ns 
16.4.3 In_box and Out_box 
16.4.4 Menus 
CHAPTER 16 • GRAPHICAL USER INTERFACES 
16.5 An example 
16.6 Control inversion 
16.7 Adding a menu 
16.8 Debugging GUt code 
16.1 User interface alternatives 
Every program has a uscr imcrface. A program rulming on a small gadget may 
be limiLCd to input from a couple of push buttons and to a blinking light for out· 
put. Other computers are connected to the outside world only by a wire. Here, 
we will consider the common case in which our program communicates with a 
user who is watching a screen and using a keyboard and a pointing device (such 
as a mouse). In this case, we as programmers have three main choices: 
UM ronsok inplll and olltplll: TIus is a strong comender for tecluucallprofes· 
sional work where the input is simple and textual, consisting of com· 
mands and shan data items (such as me names and simple data values). 
U the output is textual, we can display it on the screen or store it in files. 
TIle C++ standard library iostreams (Chapters 10- 11 ) provide suitable 
and convenient mechanisms for this. If graphic."1l output is needed, we 
can use a graphics display library (as shown in Chapters 12-15) without 
making dramatic changes to our programming style. 
Use a gmphilll/ user inlerfaa (GUI) library: This is what we do when we 
want our user interaction to be based on the metaphor of manipulating 
objects on the screen (pointing, clicking, dragging and dropping, hover· 
ing, etc.). Often (but not always), that style goes together with a high de· 
gree of graphically displayed information. Anyone who has used a 
modern computer knows examples where that is convenient. Anyone 
who wants to match the "fccl" of Windows/Mac applications must use a 
CUI style of interaction. 
UJC a web browJer illler.foa : For that, we need to use a markup Qayout) lan-
guage, such as HTM L or XML, and usually a scripting language. Show-
ing how to do this is beyond the scope of this book, but it is often the 
ideal for applications that require remote access. In that c.,se, the com-

16. 2 
THE "NEXT w BUTTON 
munication bel\\'een the program and the screen is again textual (using 
streams of characters). A browser is a CUI application that translates 
SOUle of that text into graphical elements and translates the Ulouse clicks, 
etc. into textual data that can be sent back to the program. 
"Ib many, the lise of C U I is the essence of modem progranuning, and sometimes 
the interaction with objects on the screen is considered the central concem of pro-
gramming. We disagree: CUI is a fonn of 1/0 , and separation of the main logic 
of an application from 110 is among our major idea1s for software. Wherever 
possible, we prefer to have a clean interface between our main program logic and 
the parts of the prOb'Tafll we usc to get input and produce output. Such a separa-
tion allows us to change the way a program is presented to a user, to POrt our 
programs to usc different 1/0 systems, and - most importantly - to think about 
the logic of tlle program and its interaction with users separately. 
' 11at said, CUI is important and interesting from several perspectives. This 
chapter explores both tlle ways we can integrate graphical elements into our appli-
c .. uions and how we can keep interface concems from dominating our thinking. 
16.2 The "Next" button 
How did we provide that "Next" button that we used to drive the graphics exam· 
pies in Chapters 12- 15? There, we do graphics in a window using a bmton. Ob-
viously, that is a simple form of CUI programming. In fact, it is so simple that 
some would argue that it isn't "tme CUI." However, let's see how it was done be-
cause it will lead direClly into the kind of programming that everyone recognizes 
as CU I progranuning. 
Our code in Chapters 12- 15 is conventionally structured like this: 
/I create objects ancVor manipulate objects, display them in Window win: 
win.waiCfof _buttonOi 
/I create objects and/or manipulate objects, display them in Window win: 
win.waiCfof_button(); 
/I create objecls ancVor manipulate objecls, display !hem in Window win: 
win. wail_fo r _bu Iton(); 
Each time we reach wail_for_buttonO, we can look at our objects on the screen 
until we hit the button to get the output from the next parl of the program. From 
lhe point of view of program logic, this is no different front a program that writes 
lines of output to a screen (a console window), Slopping now and then to receive 
input from the keyboard. For example: 
54' 

542 
CHAPTER 16 • GRAPHICAL US ER INTERFACES 
/I define variables ancVor compute values, produce output 
d n » var; 
II wait for input 
/I define variables ,1n{Vor compute values, produce output 
d n » var; 
/I wait for input 
/I define variables an{Vor compute values, produce output 
d n »vari 
/I wait for input 
From an implementation point of view, these twO kinds of programs arc quite dif-
ferent. \\Then your program executes cin» var, it stops and wailS for "the sys-
tem"' to bring back characters you typed. However, the system (the graphical 
user interface system) thaI looks after your screen and tracks the mOllse as YOll 
usc it works on a ramer difTerent model : the CUI keeps track of where the 
mouse is and what the user is doing with the mouse (clicking, etc.). When your 
program wants an action, it must 
Tell the CU I what to look ror (e.g., "Someone clicked the 'Next' button") 
Tell what is to be done when someone does that 
Wait umilthe G U I detects an acLion that the program is inteTCSted in 
VVhat is new and different here is that the G U I does not just reLUm to our pro· 
gram; it is designed to respond in diIfercm ways to different user actions, such as 
clicking on one or many buttons, resizing windows, redrawing the window arter 
it has been obscured by another, and popping up pop·up menus. 
For Slarters, we just want to say, "Please wake me lip when someone clicks my 
button"; that is, "Please continue executing my program when someone clicks the 
mOllse button and the cursor is in the rectangular area where the image or my but· 
ton is displayed." TIlis is just about the simplest action we could imagine. How-
ever, such an operation isn't provided by "t.he system" so we wrote one ourselves. 
Seeing how that is done is the first step in understanding GUI programming. 
16.3 A simple window 
Basically, "the system" (which is a combination or a GUI library and the operat· 
ing system) continuously tracks where the mOllse is and whether its buttons arc 
pressed or not. A program can express interest in an area or the screen and ask 
"the system" to call a runcLion when "something interesLing" happens. In this par· 
ticular case, we ask the system to call one or our runctions (a "callback runction") 
when the mouse button is clicked "on our button." To do that we must 
Define a button 
Get it displayed 

16.3 
A SIMPLE W INDOW 
Define a function for the G U I to call 
1'C1l the CUI about that button and that function 
Wait for the CUI to call our function 
Let'S do that. A button is part of a Window, so (in Simple_window.h) we define 
ollr class Simple_window to contain a member nexCbutton : 
struct Simple_window: Graph_lib:: Window ( 
Simplc_window(Point xy, int w, int h, const string& title )i 
void wait_for_buttonO; 
private : 
/I simple event loop 
); 
Button next_button; 
bool bUlton_pushed; 
I/the "Next" button 
/I implementation detail 
static void cb_next(Address, Address); 
/I callback for next_button 
void nedO; 
/I action to be done when next_button is pressed 
Obviously, Simple_window is derived from Graph_lib's Window. All our win· 
dows must be derived direcuy or indirectly from Graph_lib: :Window because it is 
ute class utat (UlroUgh FLTK) COlillects our notion of a window witll the system's 
window impleillemation. For det..ws of Window's implememation, see §E.3. 
Our button is initialized in Simple_window's constructor: 
Simple_window: :Simple_window(Point xy, int w, int h, const slring& tille) 
: Wi nd ow(xy, w, h, title), 
nex,-buUon(Point(x_maxO-70,0), 70, 20, "Next", cb_next), 
buuon_pushed(false) 
attach (nex,-butto n); 
Unsurprisingly, Simple_window passes its location (xy), size (w,h), and tiue (title) on 
to Graph_lib's Window to deal wiul. Next, u1e constructor initia1izcs nex'-button 
with a location (Point(x_maxO-70,O); Utat's roughly the top right com er), a size 
(70,20), a label ("Next"), and a "callb.:,ck" function (cb_next). The firsl four parame· 
ters cxact.ly parallel whm we do for a Window: we place a rectangular shape on ute 
screen and label it. 
Finally, we attachO our next_button to our Simple_window; thaI is, we tell 
the window that it must display u1e button in its position and make sure that ute 
CUI system knows about it. 
543 

544 
CHAPTER 16 • GRAPHI CAL USER INTERFACES 
The button_pushed member is a pretty obscure implementation detail; we 
usc it to keep track of whether the button has been pushed since last we executed 
next().ln faCl,just about everything here is implementation details, and therefore 
declared private. Ignoring the implementation details, we sec: 
struct Simple_window: Graph_lib: :Window { 
Simple_window(Point xy. int w, int h, const string& title ); 
waiC for_buttonO; 
II simple event loop 
II ... 
); 
That is, a user can make a window and wait for its button to be pushed. 
16.3.1 A callback function 
"The funclion cb_nextO is the new and interesting bit here. 111is is the function 
that we want the GUI system to call when it detects a click on ollr hulton. Since 
we give the function to the GUI for the CUI to "call back to us," it's commonly 
called a calilxuk function. \lVc indicate ch_nextO's intended use with the prefix cb_ 
for "callback." That's just to help us - no language or library requires that nam-
ing convention. Obviously, we chose the name cb_next because it is to be the 
callback for our "Next" button. The definition of cb_next is an ugly piece of 
"boilerplate." 
Before showing that code, let's consider what is going on here: 
I Our program I 
I 
" O"u-,-gc- ap"ru"'C'cs",c=u"'r"in'--,,-,:cfa-,-e"li:-b-,ary
---" 
,,' Example of a layer 
The operating system graphics/G UI facilities 
I Device driver layer I 
Our program runs on top of several "layers" of code. It uses Ollr graphics library 
that we implement using the FLTK library, which is implememed using operat-
ing system facilities. In a system, there may be even more layers and sub-layers. 
Somehow, a click detected by the mouse's device driver has to cause our function 

16.3 
A SIMPLE WINDOW 
cb_nexiO to be called. We pass the address of cb_nexiO and the address of our 
Simple_window down through the layers of software; some code "down there" 
t.hen calls cb_nexiO when lhe "Next" button is pressed. 
TIle CUI system (and the operaling system) can be used by programs writ-
ten in a variety of languages, so it cannot impose some nice C++ style on all 
users. In panicular, it docs not know about our Simple_window class or our 
Bulton class. In fact, it doesn't know about classes or member functions at all. 
-nle type required for a callback function is chosen so that it is usable from the 
lowest level of progranuning, including C and assembler. A callback function re-
turns no value and takes two addresses as its arguments. We can declare a C++ 
member function that obeys those rules like this: 
slatic void cb_nexUAddress, Address); 
/I callback for next_bullon 
-nle keyword slatic is there to make sure that cb_nexiO can be called as an m·di· 
nary function, that is, not as a C++ member function invoked for a specific ob-
ject. Having the system call a proper C++ member function would have been 
much nicer. However, t.he callback interface has to be usable from many lan-
guages, so this is what we get: a static member function. TIle Address arguments 
specify that cb_nextO takes arguments that ru'e addresses of "something in mem-
ory." C++ references are unknown to most languages, so we can't usc those. The 
compiler isn't told what the types of those "solllethings" arc. We arc close to the 
hardware here and don't get the usual help from the language. "The system" will 
invoke a callback function with the first argument being the address of the CU I 
emity ("-Widget") for which the callback was triggered. We won't usc that first ar-
gument, so we don't bother to name it. TIle second argument is the address of the 
window containing that Widget; for cb_nexlO, that will be our Simple_window. 
\Ve can use that infonnation like this: 
void Simple_window: :cb_nexUAddress, Address pw) 
/I cal! Simple_window::nextO for the window located at pw 
{ 
reference_to<Simple_window>(pw).nexlOi 
) 
TIle reference_lo<Simple_window>(pw) tells the compiler that the address in 
pw is to be considered the address of a Simple_window; that is, we can usc 
reference_to<Simple_window>(pw) as a reference to a Simple_window. In 
Chapters 17 ruld 18, we will return to the issue of addressing memory. In §E.l, 
we present the (by then, trivial) definition of reference_lo. For now, we are jLlst 
glad that we finally obtained a reference to oLir Simple_window so that we can 
access OLir data and functions exactly as we like and are Llsed to_ Finally, we get 
out of tllis system-dependent code as quickly as possible by calling our member 
function nextO. 
545 

546 
CHAPTER 16 • G RAPHI CAl US ER INTERFACES 
We could have wriuen all the code we wanted to exeCLlle in cb_next(), bUl 
we -like most good CUI programmers - prefer to keep messy low-level stuff 
separate from our nice user code, so we handle a callback with two functions: 
cb_nexlO simply maps the system conventions for a callback into a call 
to an ordinary member function (nextO). 
nedO does what we wam done (without having to know about the messy 
conventions of callbacks). 
The fundamental reason for using two functions here is the general principle that 
"a function should perform a single logical action" : cb_nextO gets LIS out of U1C 
low-level system-dependent part of the system and nC)ltO performs our desired 
action. Whenever we wam a callback (from "the system") to one of our win· 
dows, we define such a pair of functions; for example, see §16.5-7. Before going 
further, let's repeat what is going on here: 
We defme our Simple_window. 
Simple_window's constructor registers its nexCbuUon with the CUI 
system. 
When we dick the image of nexCbutlon on the screen, the CUI calls 
cb_nextO. 
cb_nedO converts the low-level system infonnation into a call of our 
member function nedO for our ".'indow. 
nextO performs whatever action we want done in response to the button 
dick. 
TImt's a rather elaborate way of getting a function called. But remember that we 
are dealing with the basic mechanism for communicating an action of a mouse 
(or other hardware device) to a program. In particular: 
There are typically many programs nmning. 
The program is written long after the operating system. 
The program is written long after the CUI librru),-
The program can be written in a language that is difTerent from that 
used in the operating system. 
The technique deals with all kinds of interactions (not just our little but· 
ton push). 
A window can have many buuons; a program can have mrulY windows. 
However, once we understand how nextO is called, we basically understand how 
to deal with every action in a program with a CUI interface. 

1 &.3 
A SIMPLE WINDOW 
16.3.2 A wait loop 
So, in this - our simplest case - what do we want done by Simple_window's 
next() each time the button is "pressed
n? Basically, we want an operation that 
stops the execution of our program at some point, giving us a chance to see what 
has been done so far. And, we want nextO to restart our program after that wail: 
/I create some objects and/or m<lnipulatc some objects, display them in a window 
win.wai'-for_buttonO; 
/I next() causes the program to proceed from here 
/I create some objects andlor manipulate some objects 
Actually, tlmt's easily done. Let's first define wai'-for_buuonO: 
void Simplc_window:: wai'-for_buttonO 
/I modified cven! loop: 
} 
II handle all events (as per default). quit when buttoo-pushcd becomes true 
/I this allows gr<lphics without control inversion 
while (! bullon_pushed) FI : :wait(); 
button_pushed = false; 
FI:: redraw(); 
Like most CU I systems, FLTK provides a function that StOPS a program until 
something happens. rn le FLTK version is called wailO. Actually, wailO takes care 
of lots of things because our program gets woken up whenever anything that af-
fects it happens. For example, when nmning under Microsoft \oVindows, it is the 
job of a program to redraw its window when it is being moved or becomes unob-
scured after having been hidden by another window. It is also the job of the 
Window to handle resizing. The FI : :waitO handles all of these tasks in the default 
manner. E.ach lime wailO has dealt with something, it retums to give our code a 
chance lO do something. 
So, when someone clicks our "Next
n bulton, wailO calls cb_nextO and re-
turns (to Ollr "wait loop"). To proceed in wail_for_buHonO, nextO just has to set 
the Boolean variable button_pushed to Irue. lllat's easy: 
void Simple_window: :nexlO 
{ 
bulton_pushed = Irue; 
Of course we also need lO define button_pushed somewhere: 
bool bullon_pushed = false; 
547 

CHAPTER 16 • GRAPHICAL USER INTERFACES 
After waiting, wait_for_buttonO needs to reset button_pushed and redrawO the 
window to make sure that any changes we made can be seen on the screen. So 
that's what it did. 
16.4 Button and other Widgets 
We define a button like this: 
strucl Button : Widget { 
Bullon(Point xy, int w, int h, const string& label, Callback cb); 
void atlach(Window&); 
) ; 
So, a Bulton is a Widget with a location (xy), a size (w,h), a text label (label), and 
a callback (cb). Basically, anything that appears on a screen with an action (e.g., a 
callback) associated is a Widget. 
16.4.1 Widgets 
Yes, wiLlgel really is a technical tenn. A more descriptive, but less evocative, name for 
a widget is a C01ltrol. We use widgeLS to define fom1S of interaction \,~th a program 
through a GUI (graphical user i.nterface). Our Widget illl'erface class looks like this: 
class Widget { 
/I Widget is a handlc to an FI_widgct -
il is "not* an FI_widgct 
II we try to keep our interface classes at arm's length from FLTK 
public: 
Widgel(Point xy, int w, int h, const string& 5, Callback cb); 
virtual void move(inl dX,int dy); 
virtual void hide(); 
virtual void showO; 
virtual void attach(Window&) = 0; 
Poinlloc; 
int width ; 
int height; 
string label; 
Callback dojt; 
protected: 
) ; 
Window· own; 
FI_Widget O pw; 
II cvery Widget belongs to a Window 
II connection to the FLTK Widget 

16.4 
BUTTON AND OTH ER WIDGETS 
A Widget has two imeresting functions that we can usc for Bullon (and also for 
any other class derived from Widget, e.g., a Menu ; sec §16.7): 
hideO makes the Widget invisible. 
showO makes the Widget visible again. 
A Widget StaTU out visible. 
Just like a Shaj>e, we can move{) a Widget in iu Window, and we must 
atlachO it to a Window before it can be used. Note that we declared atlachO to 
be a pure virtual function (§14.3.5): every class derived from Widget must define 
what it mcans for it 10 be attached 10 a Window. In fact, it is in atlachO that the 
system-level widgets arc created. TIle allach() function is called from Window as 
part of its implementation of Window's own atlach(). llasically, connecting a win-
dow and a widget is a delicate little dance where each has 10 do its own j>art. TIle 
result is that a window knows about iu widgets and that each widget knows 
about its window: 
Widget 
Wmdow ~ 
~ 
Widget 
Note thai a Window doesn't know what kind of Widgets it deals with. As de-
scribed in §14.4-S, we arc using basic object-oriented programming to ensure 
that a Window can deal with every kind of Widget. Similarly, a Widget doesn't 
know what kind of Window it deals with_ 
We have been slightly sloppy, leaving data members accessible. TIle own and 
j>W members arc strictly for the implementation of derived classes so we have de-
clared them j>rotected. 
The definitions of Widget and of the widgets we lise here (Button, Menu, 
ctc.) arc found in CUI-h. 
16.4.2 Bullons 
A Bullon is the simplest Widget we deal wilh. All it does is to invoke a callback 
when we click on it: 
549 

55<1 
CH APTER 16 • G RAPHI CAL USE R INTER FACES 
class Button: public Widget { 
public: 
}; 
Bulton{Point "Y, int ww, int hh, const string& s, Callback cb) 
:Widgel(xy,ww,hh,s,cb) {} 
void attach(Window& win); 
ll1at's aiL TIle attach() function contains all the (relatively) messy FLTK code. 
We have banished the explanation to Appendix E (not to be read until after 
Chapters 17 and 18). For now, please just notc that defining a simple Widget isn't 
particularly difficull. 
We do not deal with the somewhat complica.ted and messy issue of how but-
tons (and other Widgets) look on the screen. 111C problem is that there is a ncar 
infinity of choices and that some styles are mandated by certain systems. Also, 
from a programming technique point of view, nothing really new is needed for 
expressing the looks of buttons. If you get desperate, we note that placing a 
Shape on top ofa button doesn't affect the button's ability to function - and you 
know how to make a shape look like anything at all. 
16.4.3 In_box and Out_box 
We provide two Widgets for getting text in and out of our program: 
struct In_box : Widget ( 
}; 
In_box(Point xy, int w, int h, const shing& s) 
:Widget(xy,w,h,s,O) () 
int geUntO; 
string geCstringO; 
void attaeh(Window& win); 
struel Out_box: Widget { 
} ; 
OuCbox(Point xy, int w, int h, const string& s) 
:Widget(xy,w,h,s,O) {) 
void put(int); 
void pul(eonst string&); 
void attach(Window& win); 
An In_box can accept text typed into it, and we can read that text as a string 
using geCstringO or as an integer using get_int(). If you want to know if text has 
been entered, you can read using gecstringO and see if YOll get the empty string: 

16.4 
BUTTON AND OT HER WIDGETS 
Siring s = some_inbox.get_stringO; 
if (s =="") { 
/I deal with missing input 
An OuCbox is used to present some message to a user. In analogy to In_box, we 
ean putO eit.her integers or strings. §16.5 gives examples of the use of In_box and 
Out_box. 
We could have provided geUloatins-pointO, geCcomplexO, etc., but we 
did not bOlhcr because you can take the string, slick it i.ntO a stringstream, and 
do IDly input formatting you like that way (§11 .4). 
16.4.4 Menus 
\-Vc offer a very simple notion of a menu: 
struct Menu : Widget { 
); 
en urn Kind { horizontal, vertical }; 
Menu(Point xy, int w, int h, Kind kk, canst string& label); 
Vecto,_,ekButton> selection; 
Kind k; 
int offset; 
int attach(Button& b); 
int attach(Button - p); 
void showO 
{ 
/I attach bullon 10 Menu 
/I allach new button 10 Menu 
/1 show all buttons 
for (unsigned int i = 0; kselection.sizeO; ++i) 
selection [i]. showO; 
) 
void hideO; 
/I hide all bullons 
void move(int dx, int dy); 
II move all buttons 
void attach(Window& win); 
II attach all buttons to Window win 
A Menu is basically a vector of buttons. As usual, the Point xy is the tOp left cor-
ncr. 11le width and height are used to resize buttons as they are added to the 
menu. For examples, see §16.5 and §16.7. Each Illenu button ("a menu item") is 
an indcpcndem Widget presented to the Menu as an argument to attachO. In 
turn, Menu provides an attachO operation to attach all of its Buttons to a 
Window. Tbe Menu keeps track of its Bultons using a Vector_ref (§13.IO, §E.4). 
If you want a "pop·up" menu, you have to make it yourself; see §16.7. 
551 

552 
CHAPTER 16 • GRAPHICAL USER INTER FACES 
16.5 An example 
To gel a better feci for the basic CU I facilities, consider the window for a simple 
application involving input, outpul, and a bit of graphics: 
This program allows a user to display a sequence of lines (an open polyline; 
§13.6) specified as a sequence of coordinate pairs. The idea is that the user re-
peatedly enters (x,}) coordinates in the "next x" and "next y" boxes; after each 
pair the user hits the "next point" bulton. 
Initially, the "current (x,y)" box is empty ,md the program waits for the user 
to elUer the first coordinate pair. That done, the starting poim appears in the 
"current (x,y)" box, and each new coordinate pair entered results in a line being 
drawn: A line from lhc current point (which has its coordinates displayed in the 
"current (X,y)" box) to the newly entered (x,]) is drawn, and that (x,]) becomes 
the new current point 
This draws an open polyline. 'When the user tires of this activity, there is the 
"quit" bUllon for exiting. l1lat's pretty stTaightfon'o'ard, and the program cxer· 
cises several useful G UI facilities: text input and Olltput, line drawing, and multi· 
pIc buttons. TIle window above shows the result after entering twO coordinate 
pairs; after seven we can gel lhis: 

16.5 
A N EXAMPLE 
Let'S define a class for representing such windows. It is pretty straightfonvard: 
struCl lines_window : Window { 
lines_window{Point xy, int w, int h, const string& title ); 
Open_polyline lines; 
private: 
) ; 
Button next_button; 
Button quiCbutton ; 
1/ add (next_x/nexcy) to lines 
In_box nexCx; 
In_box nexCy; 
OuCbox xy_out; 
static void cb_next(Address, Address); 
II callback for nexcbutton 
void next(); 
static void cb_quiHAddress, Address); 
void quitO; 
II callback for quicbutton 
l11e line is represented as an Open_polyline. The buttons and boxes are de-
clared (as Buttons, tn_boxes, and OuCboxes) and for each bullon a member 
function implementing the desired action is defined together with its "boilerplate" 
callback function. 
lines_window's constructor initializes everything: 
553 

554 
( HAPTER 16 • GRAP HICAL USER INTERFACES 
lines_window: :Lines_window(Point xy, int w, int h, consl string& title) 
: Window(xy,w,h,title), 
nexCbullon(Point(,cmax()-l50,O), 70, 20, "Ned point", cb_nexl), 
quiCbutlon{Point(x_max()-70,O), 70, 20, "Quil", cb_quil), 
nexex(point(x_max()-310,O), SO, 20, "next x: "), 
nexCy(Point(x_maxO-210,O), SO, 20, "next y: "l, 
xy_out(Point(l00,O), 100, 20, "current (x,y):") 
} 
altach(nexc bu 110 nj; 
aUach(quicbutlon)i 
atlach(nexCx)i 
atlach(nexCY)i 
atlach (xy_o ul)i 
attach(lines); 
llmt is, each widget is constructed and then attached to the window. 
Dealing with the "Quit" hunon is trivial: 
void Lines_window: :cb_quil(Address, Address pw) 
( 
referencc_Io<Lines_window>(pw).quitO; 
) 
void lines_window: :quit() 
( 
hideOi 
II curious FlTK idiom for delete window 
) 
/I "Ihe usual" 
111is is just "the usual": a callback function (here, cb_quiIO) that forwards to the 
runClion (here, quitO) that does the real work. H ere the real work is to delete the 
Window. 11m's done using the curious FI..;T'K idiom or simply hiding it. 
All the real work is done in the "Next point" button. Its callback runction is 
just the usual: 
void lines_window: :cb_nexl(Address. Address pw) 
( 
re(erence_lo<lines_window>(pw).next()i 
) 
/I "the usual" 
The nexlO runction defines what the "Next point" button actually does: it reads a 
pair or coordinates, updates the Open_polyline, updates the position readout, 
and redraws the window: 

16.5 
AN EXAMPLE 
void Lines_window: :nextO 
( 
) 
inl x = ncxCx.geUnl(); 
int y = nexcy.geUnIO; 
I ines.add (Poin I (x, y»; 
II update current position readout: 
slringslream ss; 
55« '(' « x« ',' « y « ')'; 
xy _out. put(ss.SI rO); 
redrawO; 
111at's all pretty obvious. We gel integer coordinates from the In_boxes lIsing 
geUnlO. We usc a slringstream to fonnat the string to be put into the OuCbox j 
the slrO member function lets us gel to the string within the stringstream. The 
final redraw() here is needed to present the results to the user; Ulllil a Window's 
redrawO is called, the old image remains on the screen. 
So wh,lt's odd and different about this prognlm? Let's see its main(): 
#include "GUl.h" 
int mainO 
try ( 
lines_window win(Poinl(l00, 1(0),600,400, "lines"); 
return gui_main(); 
catch(cxccption& c) { 
) 
cerr« "exception: " « e.whatO« '\n'; 
return 1; 
catch ( ... ) { 
) 
ccrr « "Some exception\n"; 
return 2; 
TIlere is basically nothing there! The body of mainO is just the definition of our 
window, win, and a call to a function gui_mainO. TIlere is not another function, 
if, switch, or loop - nothing of the kind of code we saw in Chapters 6 and 7 -
just a definition of a variable and a call 10 the function gui_mainO, which is itself 
555 

556 
CHAPTER 16 • GRAPHICAL USER INTERFACES 
just a call of FLTK's runO. Looking further, we can find that rUIlO is simply the 
illfmile loop: 
while(wait(»i 
Except for a few implcmcillalion details postponed to Appendix E, we have seen 
all of the code that makes Ollr lines program run. We have seen all of the funda-
mental logic. So what happens? 
16.6 Control inversion 
What happened was that we moved the control of the order of execution from the 
program to the widgets: whichever widget the user activates, runs. For example, 
click on a button and its callback runs. When that callback rctums, the program 
settles back, waiting for the user to do something clsc. Basically, waitO tells "the 
sysLCm" to look Ollt for the widgets and invoke the appropriate callbacks. In the-
ory, waitO could teU you, the programmer, which widget requested attention and 
Icave it to you to call the appropriate function. However, in FLTK and most other 
G U 1 systems, waitO simply invokes the appropriate c."tllback, saving you the 
bot.her of writing code to select il. 
A "conventional program" is organized like this: 
Application 
Call 
Input 
function 
A "GU I program" is organized like this: 
Application 
Callback r S::-y-Sl-em
- --' 
Prompt 
User 
responds 
"Clicks" 
User 
invokes 
action 

16. 7 
ADDING A MENU 
One implication or this "control inversion" is that the order or execution is com-
pletely determined by the actions or the user. l 11is complicates bOlh program or-
ganization and debugging. It is hard to imagine what a user will do and hard to 
imagine every possible effect or a random sequence or callbacks. "Illis makes sys-
tematic testing a nightmare (sec Chapter 26). TIle techniques for dealing with 
that arc beyond the scope or this book, but we encourage you to be ext.ra careful 
with code driven by users through callbacks. In addition to the obviolls contTol 
now problems, there arc also problems of visibility and difficulties with keeping 
track of whidl widget is connected to what data. To minimize hassle, it is essen-
tial to keep the CUI portion of a program simple and to build a CUI program 
incrementally, testing at each stage. When working on a CU I program, it is al-
most essemiallo draw little diagrams or the objects and their interactions. 
How docs the code triggered by the various callbacks commun.icate? TIle 
simplest way is for the functions to operate on data stored in the window, as was 
done in the example in §16.5. There, the lines_window's nextO function, in-
voked by pressing the "Next point" bulton, reads data from the In_boxes (nexex 
and nexey) and updates the lines member variable and the Ouebox (xy-oul). 
Obviously, a fUllction i.nvoked by a callback can do anything: it could open files, 
connect to the web, etc. However, for now, we'Jt just consider the simple case in 
which we hold our data in a window. 
16.7 Adding a menu 
Let's explore the control and communication issues raised by "control inversion" 
by providing a menu for our "lines" program. First, we'Jt simply provide a menu 
that allows the user to change the color of all lincs in t.he lines member variable. 
""e add lhe menu color_menu and its callbacks: 
slrud lines_window: Window { 
Lines_window(Poinl xy, inl w, int h, consl slring& litle); 
Open_polyline lines; 
Menu color_menu ; 
sialic void cb_,ed(Address, Address); 
/I callback for red button 
sialic void cb_blue(Address, Address); 
/I callback for blue button 
stalic void cb_black(Address, Address); 
/I callback for black button 
/I the actions: 
void red_pressedO { change(Color:: red); } 
void blue_pressedO { change(Color: :blue); ) 
void black_pressedO {change(Color: :black); } 
557 

'''' 
CHAPTER 16 • GRAPHI CAL USER INTERFACES 
void change(Color c) ( lines.seLeolor(c); ) 
/I . . . as before ... 
}; 
Writing all of those almost identical callback functions and "action" functions is 
tedious. However, it is conceptually simple, and offering something that's signifi· 
camly simpler to type in is beyond the scope of this book. When a menu button 
is pressed, it changes the lines to lhe requested color. 
Having defmed the color_menu member, we need to initialize it: 
Lines_window: :lines_window(Point xy, int w, int h, const slring& title) 
: Window(xy,w,h,tille), 
( 
} 
/I .. . as before ... 
color_men u (Poinl(x_maxO-70,40),70, 20,Menu: : ve rtical, II color") 
II . .. as before ... 
color_menu .attach(new Button(Poin((O,O),O,O, "red" ,cb_red»; 
color_menu. attach(new Button(Point(O,O),O,O, "blue" ,cb_blue)); 
colof_menu . attach(new Button(Point(O,O),O,O, "black" ,cb_black)); 
attach(colo,_menu); 
TIle bullons are dynamically attached to the menu (using attachO) and can be re-
moved and/or replaced as needed. Menu::attachO adjusts size and location of 
the button and attaches them to the window. That's aU, and we gel: 

16.7 
ADDING A MENU 
Having played with this ror a while, we decided that what we really wamed was a 
'·pop·up menu"; that is, we didn't want to spend precious screen space on a menu 
except when we are using it. So, we added a "color menu" button. When we 
press that, up pops the color menu, and when we have made a selection, the 
menu is again hidden and the button appears. 
Here first is the window after we have added a rew lines: 
We see the new "color menu" button and some (black) lines. Press "color menu" 
and the menu appears: 
559 

560 
CHAPTER 16 • GRAPHICAL USE R INTE RFACES 
Note that the "color menu" hunan is now hidden. We don't need it until we arc 
finished with the menu. Press "blue" and we get: 
~nlC lines arc now blue and lhe "color menu" button has reappeared. 
~Io achieve this we added the "'color menu" button and modified the 
"pressed" runctions to adjust the visibility of Lhe menu and the bunan. Here is 
the complete Lines_window after all oLir modifications: 
struct Lines_window: Window { 
lines_window(Point "y. int w, int h, const string& tille ); 
private: 
/I data: 
Open_Jwlyline lines; 
II widgets: 
Button next_button; II add (nexcx,nex,-y) to lines 
Bulton quit_button; II end program 
In_box nex'-x; 
In_box nexCy; 
Out_box xy_oul; 
Menu colof_menu; 
BuHon menu_bunon; 
void change(Color c) { lines.sel_color(c); } 
void hide_menuO { color_menu.hideOi menu_button.showO; } 

16.7 
ADDING A MENU 
l; 
/I actions invoked by callbacks: 
void red_pressedO { changc(Color:: red); hidc_menu(); } 
void blue_pressed() ( change(Color: :blue); hide_menuO; } 
void black_pressedO (change(Color: :black); hide_menuO;} 
void menu_pressedO { menu_button.hideO; color_menu.showO; } 
void next(); 
void quitO; 
/I callback functions: 
stalic void cb_fed (Address, Address}, 
static void cb_blue(Address, Address): 
stalic void cb_black(Address, Address); 
slatic void ch_menu(Address, Address), 
static void cb_ned(Address, Address); 
static void cb_quit(Address, Address); 
Note how all but the eonstmetor is private. Basically, that window class is the 
program. All that happens, happens through its callbacks, so no code from out-
side the window is needed. \.ve sorted the declarations a bit hoping to make the 
class more readable. The constructor provides arguments LO all of its sub-objects 
and attaches them to the window: 
Lines_window: :Lines_window(Point xy, int w, int h, const string& title) 
: Window(xy,w,h,tille), 
colol_menu(Point(x_max(}-70,30),70,20,Menu: : vertical, "color"), 
menu_butlon(Point(x_maxO- 60,30), 50, 20, "color menu", cb_menu), 
nexCbullon(Point(x_max(}-150,0), 70, 20, "Next point", cb_nextJ, 
quit_bullon(Point(x_maxO-70,0), 70, 20, "Quit", cb_quiO, 
ned_x(Poinl(x_max(}-310,OJ, 50, 20, "next x: tI), 
nexcy(Point(x_max(}-210,OJ, SO, 20, "next y: tlJ, 
xy_ouI(Point(l00,OJ, lOD, 20, "current (x,y):") 
attach (nex,-bu lion); 
attach (q uit_ bu lion); 
attach(nexCx); 
atlach(nex,-y); 
altach(xy_out); 
xy_out.put("no point"); 
color_menu.nllach(new Bulton(Poinl(O,O),O,O," red" ,ch_red)); 
colof_menu. allach(new Button(Point(O,O),O,O, "blue" ,cb_blue)); 
colof_menu. allach(new Button(Point(O,O),O,O, "black" ,cb_black»; 
atlach(colo,_menu); 
561 

562 
) 
CHAPTER 16 • GRAP HICAL US ER INTERFACES 
colOT_menu .hide(); 
attach (men u _button); 
attach (lines); 
Note that the initializcrs arc in the same order as the data member definitions. 
111at's the proper order in which to write the inicializers. In fact, member initial-
izcrs are always cxccUlcd in the order their data members were declared. Some 
compilers (helpfully) give a warning if a base or member constrtJctor is specified 
OLit of order. 
16.8 Debugging CUI code 
Once a G U I prOgr'dITI starts working it is often quite casy to debug: what YOLI sec 
is what you gel. However, there is often a most frustrating period before the first 
shapes and widgets stan appearing in a window or even before a window ap-
pears on the screen. lI'Y this mainO: 
int mainO 
{ 
) 
Lines_window (Point(l00, 100),600,400, "lines"); 
return gui_mainO; 
Do yOLi see the error? Whether YOll see it or not, you should try it; lhe program 
will compile and run, but instead of the lines_window giving you a chance to 
draw lines, you get at most a flicker on the screen. How do you find errors in 
sllch a program? 
By carefully using well-tried program parts (classes, function, libraries) 
By simplifying all new code, by slowly "'growing" a program from its 
simplest version, by carefully looking over the code line for line 
By chccking all linker settings 
By comparing to already working programs 
By explaining the code to a friend 
~111e one lhing that you will find it hard to do is to trace the execution of lhe 
code. U you have leamed to use il debugger, you have a chance, butjusl inserting 
"'output statements" will not work in this case - the problem is that no Output ap-
pears. Even debuggers will have problems because there are several things going 
on at once ("multi-threading") - your code is nOt the only code trying to interact 
with the screen. Simplification of the code and a systematic approach to under-
standing the code arc key. 

16.8 
DEBUGG ING GU I CODE 
So what was the problem? Here is me correct version (from §16.5): 
int mainO 
( 
Lines_window win(Point(loo, 100),600,400, "lines"); 
return gui_malnO; 
We "forgot" the name of the Lines_window, win. Since we didn't actually need 
that name that seemed reasonable, but the compiler then decided that since we 
didn't usc that window, it could ulmlediately destroy it. Oops! l1mt window ex-
isted for something on the order of a millisecond. No wonder we missed it. 
Another common problem is to put one window exactly on top of another. 
111is obviously (or rather not at all obviously) looks as if there is only one win-
dow. Where did the other window go? We can spend significa.nt time looki.ng for 
nonexistent bugs in the code. 111e same problem can occur if we put one shape 
on lOp of another. 
Finally - to make matters still worse - exceptions don't always work as we 
would like tltem lD when we use a G U I library. Since our code is managed by a 
G U I library, an exception we throw may never reach our handler - the library 
or the operating system may "cat" it (that is, they may rely on error·handling 
mechanisms that differ from C++ exceptions and may indeed be completely 
oblivious of C++). 
Common problems found during debugg1ng include Shapes and Widgets 
not showing because mey were not attached and objects misbehaving because 
they have gone out of scope. Consider how a programmer might factor out the 
crealion and attachment of buttons in a menu: 
/I helper function for loading buttons into a menu 
void load_disaster_me nu(Me nu& m) 
( 
) 
Point orig<O,O); 
Button bl(orig,O,O, "flood " ,cb_f1ood); 
Button b2(orig,O,O, "fire" ,cb_fire); 
/I ... 
m.attach(bl); 
m.attach(b2); 
/I ... 
int mainO 
{ 
/I . 
563 

564 
CHAPTER 16 • GRAP HI CAL US ER INTERFACES 
Me nu disaslers(Point(100, 100),60,20,Me nu : : horizontal, "disaste rs"); 
load_ d isasler _men u(disaslers); 
win.allach(disaslers); 
1/ . . . 
~fbis will not work. All those buttons arc local to the load_disaster_menu func-
tion and attaching them to a menu will not change thaL An explanation can be 
found in § I 8.5.4 (DQu't return (l povlter to a lrod variable), and an illustration of the 
memory layout for local variables is presented in §8.5.8. TIle essence of the SLOry 
is th at after load_disaster_menuO has Tctumcd, those local objects have been de-
stroyed and the disaste rs menu refers to nonexistent (destroyed) objects. l l lC re-
sult is likely to be surprising and not pretty. TIle solution is to usc unnamed 
objects created by new instead of named local objects: 
/I helper function for loading buttons into a menu 
void load_disaster_menu(Menu& m ) 
( 
) 
Point orig(O,O); 
m.attaeh(new BuUon(orig,O,O, "flood " ,eb3 Iood»; 
m.attaeh(new Button(orig,O,O, "fire" ,eb_fire»; 
II ... 
111c correct solution is even simpler than the (all too common) bug. 
~ 
Drill 
1. Make a completely new project with linker settings for FLTK (as de-
scribed in Appendix D). 
2. Using the facilities of Graph_lib, type in the line-drawing program from 
§16.5 and get it to run. 
3. Modify the program to use a pop-up menu as described in §16.7 and get 
it to run. 
4. Modify the program to have a second menu for choosing line styles and 
get it to run. 
Review 
1. ''''hy would you want a graphica.l Llser interface? 
2. When would you wam a non-graphical user imcrface? 

CHAPTER 16 EXERCISES 
3. What is a software layer? 
4. Why would you want to layer software? 
5. What is the fundament."lI problem when communicating with an operat· 
ing system from C++? 
6. What is a callback? 
7. What is a widget? 
8. What is another name ror widget? 
9. What docs the acronym FLTK mean? 
10. How do you pronounce FLTK? 
II. What other CUI toolkits have you heard of? 
12. Which systems use the tenn widget and which prerer collirol? 
13. What are examples or widgets? 
14. When would you use an inbox? 
15. What is the type or the value stored in an inhox? 
16. \Vhen would you use a button? 
17. \Vhell would you use a menu? 
18. \.vhat is cOlllrol inversion? 
19. What is the basic strategy ror debugging a CUI program? 
20. Why is debugging a CU I program harder than debugging an "ordinary 
program using streams for I/O"? 
Terms 
butlOn 
callback 
console 110 
control 
colllrol inversion 
Exercises 
dialog box 
CUI 
menu 
sornvare layer 
user interface 
visible/hidden 
waiting ror input 
wait loop 
widget 
l. Make a My_window that's a bit like Simple_window except that it has 
two buttons, next and quit. 
2. Make a window (based on My_window) with a 4-by·4 checkerboard or 
square buuons. When pressed, a button perrorms a simple action, such 
as printing its coordinates in an output box, or turns a slightly different 
color (uillil another button is pressed). 
3. Place an Image on tOP or a Button; move both when the button is pushed. 
Use this random number generator to pick a new location ror tbe "image 
button": 
int rint(intlow, int high) { return low+rand()%(high- Iow); } 
It returns a random int in the range [Iow,high). 
565 

566 
( HAPTER 16 • GRAPHICAL USER INTERFA CES 
4. Make a menu with items mal make a circle, a square, an equilateral tri-
angle, and <l hexagon, respectively. Make an input box (or two) for giv-
ing a coordinate pair, and place the shape made by pressing a menu item 
at that coordinate. Sorry, no drag and drop. 
5. Write a program that draws a shape of your choice and moves it to a 
new point each lime you dick "Next." "nlC new point should be deter-
mined by a coordinate pair read from an input strcrul], 
6. Make an "analog clock," that is, a clock with hands that move. You gel 
the time of day from the operating system through a library c.:-ul. A m~ o r 
part of this exercise is to find the functions that give you the lime of day 
and a way of waiting for a short period of time (e.g., a second [or a clock 
tick) and to learn to usc them based on the documentation you found. 
Hint: cloekO, sleep(). 
7. Using the techniques developed in the previous exercises, make an 
image of an airplane "Oy around" in a window. Have a "stan " and a 
"StOp" button. 
S. Provide a currency converter. Read the conversion rates from a file on 
startup. Enter an amount in an inpm window and provide a way of se-
lecting currencies to convert to and from (e.g., a pair of menus). 
9. Modify lhe calculator from Chapter 7 to get its input from an input box 
and return its results in an output box. 
10. Provide a program where you can choose among a set of functions (e.g., 
sinO and logO), provide parameters for those functions, and then grapb 
them. 
Postscript 
C V I is a huge topic. Much of it has to do with style and compatibility \\~th exist-
ing systems. Furthermore, much has to do with a bewildering variety of widgets 
(such as a C VI library offering many dozens of alternative button styles) that 
would make a traditional botanist feel quite at home. However, little of that has 
to do with fundamental programming techniques, so we won't proceed in that di-
rection. Other topics, such as scaling, rotation, morphing, three-dimensional ob-
jects, shadowing, etc., require sophistication in graphical andlor mathematical 
topics which we don't assume here. 
One thing you should be aware of is that most C VI systems provide a "C V I 
builder" that allows you to design your window layouLS graphically and attach 
callbacks and actions to buttons, menus, etc. specified graphically. For many ap-
plications, such a CVI builder is well worth using to reduce the tedium of writ· 
ing "scaffolding code" such as our callbacks. However, always try to understand 
how the resulting programs work. Sometimes, the generated code is equivalent to 
what you have seen in this chapter. Sometimes more elaborate and/or expensive 
mechanisms arc used. 

Part III 
Data and Algorithms 


-'. . 
"'- '7 
Vector and Free Store 
"Use vector as the default!" 
-Alex Stepanov 
T
his chapter and the next four describe the containers and 
algorithms part of the C++ standard library, traditionally 
called tllC STL. We describe the key facilities from the S11.. and 
some of their uses. In addition, we present the key design and 
programming techniques used to implemem the S11.. and some 
low-level language features used for thal. Among those are point-
ers, arrays, and free store. 111e focus of this chapter and the next 
two is the design and implementation of the most common and 
most useful STL camainer: vector. 
..9 

570 
CHAPTER 17 • VECTOR AND FREE STORE 
17.1 Introduction 
17.2 vector basics 
17.3 Memory, addresses, and pointers 
17.3.1 The sizeof operator 
17.4 Free store and pointers 
17.4.1 Free·slore allocation 
17.4.2 Access through pointers 
17.4.3 Ranges 
17.4.4 Initialization 
17.4.5 The null pointer 
17.4.6 Free·slore deallocalion 
17.5 Destructors 
17.5.1 Generated destructors 
17.5.2 Destructors and free store 
17.1 Introduction 
17.6 Access to elements 
17.7 Pointers to class objects 
17.8 Messing with types: void- and 
casts 
17.9 Poinlers and references 
17.9.1 Poinler and refe rence 
parameters 
17.9.2 Pointers, references, and 
inheritance 
17.9.3 An ellilmple: lisls 
17.9.4 list operilliions 
17.'.S list use 
17.10 The this pointer 
17.10.1 Morelinkuse 
The most useful container in the C++ standard library is vector. A vector pro-
vides a sequence of elements of a given lype. You can refer to an clement by its 
index (subscript), extend the vedor by using push_backO, ask a vector for thc 
number of its elements using sizeO, and have access to the vector checked 
against attempts to access out-of-range elements. The standard library vector is a 
collvenient, nexible, efficient (in lime and space), statically type-safe container of 
clements. The standard string has similar properties, as have other useful stan-
dard container types, such as list and map, which we will describe in Chapter 20. 
However, a computer's memory doesn't directly suppOrt sllch useful types. All 
that the hardware directly supports is sequences of bytes. For example, for a 
veclor<double>, the operation v.push_back(2.3) adds 2.3 to a sequence of doubles 
and increases the clement count of v (v.sizeO) by I. At the lowest level, the com-
puter knows nothing about anything as sophislic.,ted as push_backO; all it knows 
is how to read and write a few bytcs at a time. 
In this and the following two chapters, we show how to build vector from the 
basic language facilities available to every programmer. Doing so allows us to il-
lustrate useful concepts and programming techniques, and to see how they arc 
expressed using C++ language fealures. The language facilities and program-
ming techniques we encounter in the vector implementation arc generally useful 
and very widely used. 
Once we have seen how vector is designed, implemeIlled, and used, we can 
proceed to look at other standard library containers, such as map, and examine 
the elegant and efficient facilities for their usc provided by the C++ standard li-
brary (Chapters 20 and 21). These facilities, called algorithms, save us from pro-
granuning common tasks involving data ourselves. Instead, we can lise what is 

17.1 
INTRODUCTION 
available as part or every C++ implementation LO ease the writing and testing or 
Ollr libraries. We have already seen and used one or the standard library's most 
usdul algorithms: sartO. 
We approach the standard library vector through a series or increasingly so-
phisticated vector implementations. First, we build a very simple vector. 111en, 
we see what's undesirable about that vector and fix it. When we have done that a 
rew times, we reach a vector implementation that is roughly equivalent to the 
standard library vector - shipped wilh your C++ compiler, the one that you 
have been using in the previolls chapters. This process or gradual refinemem 
closely mirrors the way we typically approach a new programming task. Along 
the way, we encollnter and explore many classical problems related to the usc or 
memory and data structUI"CS. The basic plan is this: 
Clmpta- 17 ~hu dmpter): How can we deal with varying amounLS or mem-
ory? In particular, how can differem vectors have difTerelll numbers or 
elements and how can a single vector have difTerelll numbers or cle-
lUcIUS at different times? 'lOis leads us to examine rree store (heap stor-
age), pointers, casts (explicit type conversion), and rdcrences. 
Chapter 18: How can we copy vectors? How can we provide a subscript 
operation ror them? We also introduce arrays and explore their relation 
to pointers_ 
ClUI!)/tT 19: How can we have vectors with different clement types? And 
how can we deal with out-or-range en'ors? To answer those questions, 
we explore the C++ template and exception racililies. 
In addition to the new language racilities and techniques that we introduce to 
handle the implementation or a flexible, efficient, and type-safe vector, we will 
also (re)use many or the language racilities and programming techniques we have 
already seen. Occasionally, we'll take the opportunity to give those a slighuy 
more rormal and technical definition. 
So, this is the point at which we finally get to deal directly with memory. 
Why do we have to? Our vector and siring arc extremely usdul and convenient; 
we can just use those_ After all, containers, such as vector and string, are de-
signed to insulalC us rrom some or the unpleasant aspects or rcal memory. How-
ever, unless we arc content to believe in magic, we must examine the lowest level 
or memory management. Why shouldn't you "just believe in magic"? Or - to 
put a more positive spin on it - why shouldn't you "just truSt that the imple-
menters or vector kllew what they were doing"? After all, we don't suggest that 
you examine ule device physics that allows our computer's memory to runction. 
Well, we arc progranuners (computer scientists, SOrtlVare developers, or what-
ever) rather than physicists. Had we been studying device physics, we would have 
had to look into the details or computer memory design_ However, since we arc 
smdying progranulling, we must look into the delailed design or programs_ In the-
ory, we could consider the low-level memory access a.nd ma.nagement racilides 
571 

572 
CHAPTER 17 • VECTOR AND FREE STORE 
"implementation details" just as we do the device physics. However, if we did that, 
you would l10ljust have to "believe in magic"; you would be unable to implement 
a new container (should you need one, and tlml's not uncommon). Also, you 
would be unable to read huge amounts of C and C++ code that directly uses 
memory. As we will sec over the next few chapters, pointers (a low-level and direct 
way of referring to an object) are also useful for a variety of reasons not related to 
memory management. It is not easy to lise C++ well without sometimes lIsing 
pOlllters. 
More philosophicaHy, I am among the large group of computer professionals 
who are of the opinion that if you lack a basic and practical understanding of 
how a program maps onto a computer's memory and operations, you will have 
problems getting a solid grasp of higher-levcl topics, such as data StniClUl'eS, algo-
rithms, and operating sysLCms. 
17.2 vector basics 
We start our incrememal design of vector by considering a very simple usc: 
vector<double> age(4); 
ageI01=0.33j 
ageI1]=22.0; 
ageI21=27.2; 
ageI3J=54.2; 
II a vector with 4 clements of type double 
Obviously, this creales a veCior with four clements of type double and gives 
those fOLir clements the values 0.33, 22.0, 27.2, and 54.2. 111c four elements arc 
numbered 0, 1, 2,3. TIle numbering of elements in C++ standard library COil' 
tainers always starts from 0 (zero). Numbering from 0 is very common, and it is a 
universal convention among C++ programmers. The number of clements of a 
veCiOT is called its size. So, the size of age is 4. TIle clements of a veclor arc num-
bered (indexed) from 0 to size- I. For example, the clements of age are numbered 
o to age.size()-1. We C.'lll represent age grapbic..1.lIy like this: 
age: 
r-.;--'-----' 
agelOJ: ageI1] : age(2): age(3) : 
0.33 
22.0 
27.2 
54.2 
How do we make this "graphical design" real in a computer's memory? How do we 
get the values stored and accessed like lha!? Obviously, we bave to deflllc a class and 
we wam to call this class vector. Fun.hcnnore, it needs a data member to hold its 

17. 2 
V ECTO R BASICS 
size and one to hold its clements. But how do we represent a set of clements where 
the number of elements CUI vary? We could lise a standard library vector, but that 
would - in this conte..xt - be cheating: we are building a vector here. 
So, how do we represent that arrow in the drawing above? Consider doing 
without it. \oVe could dcflnc a fixed-sued data structure: 
class vector { 
} ; 
int size, ageO, agel , age2, age3; 
1/ . . . 
Ignoring some notational details, we'll have something like this: 
age: 
size: 
age[O] : ageI1]: age[2]: age[3]: 
4 I 0.33 I 22.0 I 27.2 I 54.2 I 
"111m's simple ,md IUce, but the first time we try to add an clement with push_backO 
we arc sunk: we have no way of adding an c1emem; the number of elements is fIXed 
to fOllT in the program text. \oVe need something more than a data strucntre holding 
a fixed number of clements. Operations that change the number of elements of a 
vector, such as push_backO, can't be implemented if we defined vector to have a 
fIXed number of clements. Basically, we need a data member that points to the set of 
clements so that we can make it point to a different set of clements when we need 
more space. We need something like the memory address of the first clement. In 
C++, a data type that CUI hold an address is c.-uled a poVIler and is syntactically dis-
linb'1Jished by the SUffIX · , so that double· means "pointer to do uble." Given that, 
we can define our first version of a vector class: 
II a very simplified vector of doubles (like vector<double» 
class vecto r ( 
int 51:; 
double· clem; 
public: 
vector(int s); 
lithe size 
II pointer to the fi rst element (of type double) 
/I constructor: alloca.te s doubles, 
II let elem point to them 
II store s in sz 
int sizeO eonst { return sz; } 
II the current size 
} ; 
Berore proceeding with the vector design, let liS study the notion of "pointer" in 
some detail. l 11e notion or "pointer" - together with its closely rela.ted notion of 
"array" - is key to C++'s nOlion of "memory." 
573 

574 
CHAPTER 17 • VECTOR AN D FREE STO RE 
17.3 Memory, addresses, and pointers 
A computer's memory is a sequence of bytes. We can number the bytes from 0 to 
the last one. We call such "n number that indicates a location in mCIllOlY'" an 
(u/dreSJ. You can think of an address as a kind of integer value. ' 11C first byte of 
memory has the address 0, the next the address I, and so on. "Vc <:",11 visualize a 
megabyte of memory like this: 
o 
2 
210_1 
1 1 1·.·.· .. ·.· ... · .... ·.· ............ · ..................................... · .. ··.0 
Everything we pul in memory has an address. For example: 
int var = 17; 
This will sel aside an "int-sized" piece of memory for val' somewhere and put the 
value 17 into that memory. We can also store and manipulate addresses. An ob-
ject that holds an address value is called a poilllt.,.. For example, the type needed to 
hold the address of an int is called a "poimer to int" or an "int pointer" and the 
notation is int· : 
inl- ptr = &var; 
II ptr holds lhe address of var 
The "address of' operator, unary &, is used to get the address or an object. So, ir 
var happens to start at address 4096 (also known as 21 ~), ptr will hold the value 
4096, 
Basica.lly, we view our computer's memory as a sequence or bytes numbered 
rrom 0 to the memory size minus I. On some machines that's a simplification, 
but as an initia1 programming model or the memory, it will suffice. 
Each type has a corresponding pointer type. For example: 
char ch = 'C' j 
char· pc = &ch j 
int ii = 17j 
intO pi = &iij 
II pointer 10 char 
II pointer 10 int 
Ir we want to see the va1ue or the object pointed to, we can do that using the 
"conleills or operator, unary · . For example: 

17.3 
MEMORY, ADDRESSES, AND PO INTERS 
cout « "pc==" « pc« " i contents of pc==" « 'pc« "\n"; 
couf « "pi=="« pi« It; contents of pi==" « ' pi « "\n"i 
'Ille olltpm for ' pc will be lhe character c and lhe omput for ' pi will be lhe inte-
ger 17. TIle output for pc and pi will vary depending on where the compiler alia· 
cated our variables ch and ii in melllory. The notalion used for the pointer value 
(address) may also vary depending on which conventions your system uses; hexa-
decimal notation (§A.2.1.1) is popular for pointer values. 
~nl e cOlllell1s 0/ operator (often called the deniercla operator) can also be used 
all the left-hand side of an assignment: 
' pc = 'x'; 
'pi = 27i 
' pi= 'pe; 
1/ OK: you can assign 'x' 10 lhe char pointed to by pc 
II OK: an intO points to an int so 'pi is an int 
1/ OK: you can assign a char (pc) to <In int (pi) 
Note that even though a pointer value can be printed as an integer, a pointer is 
not an integer. "What docs an inl point to?" is nOt a well-formed question; ints 
do nOl. poim, pointers do. A pointer type provides the operations suitable for ad-
dresses, whereas int provides the (arithmetic and logical) operations suitable for 
integers. So pointers and integers do not implicitly mix: 
int i = pi; 
pi = 7; 
/I error: can't assign an intO to .1n jnt 
II error: can't assign an int to an int· 
Similarly, a pointer to char (a charO) is not a pointer LO inl (an int O). For example: 
pc= pi; 
pi = pc; 
1/ error: can', assign an intO to a charo 
1/ error: can', assign a char" to an intO 
Why is il an error to assign pc to pi? Consider one answer: a char is usually 
much smaller than an inl, so consider this: 
char chl = 'a'; 
char ch2 = 'b'; 
char ch3 = 'c'; 
char ch4 = 'd'; 
intO pi = &ch3; 
' pi = 12345; 
' pi = 67890; 
II poinllo ch, a char-sized piece of memory 
/I error: we cannol assign a charo to an intO 
II but lei's pretend we could 
II write to an int-sized piece of memory 
575 

57. 
CHAPTER 17 • VECTOR AND FREE STORE 
Exacliy how lhe compiler allocates variables in memory is implementation de-
fined, but we might very well get something like this: 
ehl: 
pi : 
Now, had the compiler allowed the code, we would have been writing 12345 to 
the memory sLarting at &chl. TImt would dcfmitcly have changed the value of 
some nearby memory, such as ch2 or ch4. If we were really unlucky (which is 
likely), we would have ovcnvrittCIl part of pi itscln In that case, the next assign -
ment · pi=67890 would place 67890 in some completely diffcrclll part of memory. 
Be glad that such assigmnem is disallowed, but this is one of the vcry rew protec-
tions offered by the compiler at this low level of programming. 
In lhe unlikely case that you really need to convert an int to a pointer or to 
convert one pointer type to another, you have to usc reinlerpreCcast; sec §17.8. 
We arc really close to the hardware here. 111is is not a particularly comfort-
able place to be for a programmer. We have only a few primitive operations avail-
able and hardly any support from the language or the standard library. However, 
we had to get here to know how higher-level facilities, such as vector, arc imple-
mented. We need to understand how to write code at this level because not all 
code can be "high-level" (sec Chapter 25). Also, we might better appreciate the 
convenience and relative safety of the higher levels of software once we have ex-
perienced their absence. Our aim is always to work at the highest level of ab-
straction that is possible given a problem and the constraints on its solution. In 
this chapter and in C hapters 18-19, we show how to gct back to a more comfort-
able level of abstraction by implementing a vector. 
17.3.1 The sizeof operator 
So how much memory docs an inl really take up? A pointer? The operator 
sizeof answers such questions: 
cout « "the size of char is n« sizeof(char)«
" « sizeof ('a')« '\n'; 
cout « "the size of int is " « sizeof(inl) «"« sizeof (2+2)« '\n'; 
int· p = O; 
coul « "the size of int· is"« sizeof(int-)«
" « sizeof (1') « '\n'; 
As you can sec, we can apply sizeof either to a Iype name or to an expression; for 
a type, sizeof gives the size of an object of that type and for an expression it gives 
the size of the type of the resull. The result of sizeof is a positive integer a.nd the 
unit is sizeof(char), which is defined to be 1. Typically, a char is stored in a bYle, 
so sizeof reports the number of bytes. 

17.4 
FREE STORE AND POINTERS 
TRY THI S 
Execute the example above and see what you get. Then extend the example 
to determine the size of baal, double, and some other type. 
111e size of a type is no! guaranteed to be the same on every implementation of 
C++. 111cse d.'ys, sizeof(int) is typically 4 on a laptop or desktop machine. With an 
8-bit byte, that means that an int is 32 bits. However, embedded-systems processors 
with 16-bit ints and high-perfonnance architeClures with 64-bit ints are common. 
How much memory is used by a vector? We C.'lIl try 
vector<inl> v(TOOO); 
cout « "the size of vector<inl>(TOOO) is " «sizeof (v)« '\n'; 
111e Output will be something like 
the sizc of vcctor<int>(l000) is 20 
~nle explanation will become obvious over this chapter and the next (sec also 
§19.2.1), but clearly, sizeof is not counting the clements. 
17.4 Free store and pointers 
Consider the implementation of vector from the end of §17.2. From where docs lhe 
vector get the space for the elements? How do we gel the poimer clem to poim to 
them? ' '''hen you start a C++ program, the compiler sets aside memory for your 
code (sometimes called axk s/orage or text Jtorage) and for the global vruiables you de-
fine (ca.lled Jtatic Jtomge). It also sets aside some memory to be used when you c.'l1l 
functions, and lhey need space for their arguments ruld local variables (t.hat's called 
JlacA s/orage or at/tommie Jlorage) . The rest of the computer's memory is potentially 
available for other uses; it is "free." We can illustrate that graphic.,Uy: 
memory layout: 
Code 
Static: data 
.......... 
Sud< 
577 

578 
CHAPTER 17 • VECTOR AND FR EE STO RE 
TIle C++ language makes this "free store" (also called the heap) available lhrough 
an operator called new. For example: 
double p = new double(4); 
/I allocate 4 doubles on the free store 
This asks the C++ run-time system to allocate 4 doubles on the free Slore and re-
turn a pointer to the first double to us. We usc that pointer to initialize our 
pointer variable p. We can rcprcscnllhis graphic."llly: 
llle rrcc store: 
p: 
I 
~ 
"f 
I 
I 
I 
I 
The new operator retums a pointer to the object it creates. If it created several 
objects (an array), it returns a poimcr to the first of those objects. If that object is 
of type X, the paimer returned by new is of type X· . For example: 
char- q = new doubleI41i 
II error: double" assigned to char· 
Thal new returns a pointer to a double and a double isn't a char, so we should 
not (and calmot) assign it to the pointer to char variable q. 
17.4.1 Free-store allocation 
We request memory to be allQC(lted on thefoe store by the new operator: 
11le new operator returns a poil1lcr to the allocmed memory. 
A poimer value is the address of the ftrst byte of t.he memory. 
A pointer points to an object of a specified type. 
A pointer docs llot know how many elements it points to. 
The new operator can allocate illdividual clements or sequcnces (arrays) or cle-
ments. For example: 
int- pi = new int; 
int- qi = new int[4]; 
II allocate one int 
/I allocate 4 ints (an array of 4 ints) 

17.4 
FREE STORE ANO POINTERS 
double pd = new double; 
/I allocate one double 
double· qd = new double[n); 
1/ allocate n doubles (an array of n doubles) 
Note thlt the number of objects allocated can be a variable. l1tat's important becausc 
that allows us to sclca how Ill,my objccts we allocate at rUIl time. If n is 2, we get 
pi: 
qi: 
Pointers to objects of different types arc different types. For example: 
pi = pd; 
pd= pi; 
/I error: can', assign a double* to an intO 
II error: can', assign an intO to a double' 
\-Vhy not? Artcr all, we can assign an inl to a double and a double to an jnt. TIle 
reason is the [ ) operator. It relics on thc size of the element type to figure alit 
where to find an element. For example, qi[2] is twO int sizes further on in mem-
ory than qilOI, and qd[2] is two double sizes further on in memory than qdIO). If 
the size of an inl is different from the size of double, as it is on many computers, 
we could get some rather strange rcsults if we allowed qi to point to the memory 
allocated for qd. 
That's the "'practical expianation.
n 111e theoretical explanation is simply 
"'Allowing assignment of pointers to differelll types would allow type errors." 
17.4.2 Access through pointers 
In addition to using the dereference operator " on a pointer, we can use the sub-
script operator []. For example: 
double· p = new double[4]; 
double x = "p; 
double y = p(2); 
1/ allocate 4 doubles on the free store 
1/ read the (firs!) object pointed to by p 
1/ read the 3rd object pointed to by p 
Unsurprisingly, the subscript operator counts from 0 just like vector's subscript 
operator, so p12] refers to the third clement; prO] is the first clcmenl so plO] means 
exactly the same as "p. TI1C I ] and · operators can also be lIsed for writing: 
579 

580 
. p = 7.7; 
pl2J = 9.9; 
CHAPTER 17 • VECTOR AND FREE STO RE 
II write to the (first) object I>ointed to by p 
II write to the 3rd objecl pointed to by p 
A pointer poims to an object in memory. The "contents orn operator (also called 
the dmference operator) allows liS to read and write the object pointed to by a 
pointer p: 
double x = .p; 
. p = B.8; 
/I read the object pointed to by p 
/I write to the object pointed 10 by P 
\>\'hcn applied to a poimer, the t I operator (rcats memory as a sequence of ob-
j ects (o f the type specified by the pointer dccla'dlion) with the first one paimed to 
by a pointer p: 
double x = pIJ]; 
pll] = 4.4; 
double y = pIO); 
II read the 41h object pointed to by p 
/I write to the 4th object pointed \0 by p 
/I plO] is the same as ' p 
l1lat's all. 111crc is no checking, no implementation clcvcrncss, jusl simple access 
to OLir computer's memory: 
plOI: 
pil I: 
p121: 
p131: 
8.9 
9.9 
4.4 
~l1Us is exactly the simple and optimally efficient mechanism for accessing melll-
ory that we need to implemellt a vector. 
17.4.3 Ranges 
The major problem with pointers is thai a pointer doesn't "know" how many clc-
mems it points to. Consider: 
double· pd = new doublel1l; 
pd[2] = 2.2; 
pd[4] = 4.4; 
pd[- ll = - 1.1; 
Docs pd have a third element pd[2]? Does it have a liftll element pd[4J? If we 
look at the delinition of pd, we lind that the answers arc yes and no, respectively. 
However, the compiler doesn't know that; it docs not keep track of pointer val· 
ues. Qur code will simply access memory as if we had alloc.'ued enough memory. 
It will even access pd[-ll as if the location three doubles berore what pd poilllS 
to was part of our allocation: 

17. 4 
FREE STO RE AND POINTERS 
pd : 
pdl-31 : 
pdl-21: 
pdl-11 : 
pdlOI: 
pdl1l: 
pd121: 
pd131: 
pd141: 
-3.3 
2.2 
4.4 
We have no idea what the memory locations marked pdI-3] and pd[4] are used 
ror, However, we do know that they weren't meant 1.0 be lIsed as pan or ollr array 
or three doubles pointed to by pd. Most likely, they arc p.1.rts or other objects ,md 
we just scribbled allover those. That's not a good idea. In ract, it is typically a dis-
astrously poor idea: "disastrous" as in "My program crashes mystel'iously'" or 
"My program gives wrong output." Try saying that aloud; it doesn't sound nice at 
all. We'll go a long way to avoid that. Out-of-range access is particularly nasty be-
cause apparently unrelated parts or a program arc affected. An OUt-or-rangc read 
brlves us it "" lI1dom" value that may depend on some completely unrelated com-
putation. An out-of-rangc write can put some object into an "impossible" state or 
simply give it a totally unexpected and wrong value. Such writes typically aren't 
noticed until long arter they occurred, so they arc particularly hard to find. Worse 
slill: nm a program with an out-or-range error twice with sligluly different input 
ami it may give different results. Bugs or this kind ("transient bugs") are some or 
the most difficult bugs to find. 
We have to ensure that such Out-or-range access doesn't happen. O ne or the 
reasons we usc vector rather than directly using memory alloc.-lI.ed by new is tllat 
a veclor knows its size so that it (or we) can easily prevent out-or-range access. 
One thing that can make it hard to prevent out-or-rangc access is that we can as-
sign one double· to another do uble independently or how many objects each 
points to. A pointer really doesn't know how many objects it points to_ For example: 
double· p = new do uble; 
double* q = new do uble[1OOO]i 
/I allocate a double 
/I allocate 1000 doubles 
q[700] = 7.7; 
q = p; 
double d = q[700]; 
/I fine 
II lei q point to the same as p 
/I out-of-range access! 
Here, in just three lines or code, q[700] rcrers to twO different memory 10Cl.ltions, 
and the last usc is an out-of-range access and a likely disaster. 
Second value or q 
l<i rSl value or q 
581 

50' 
CHAPTER 17 • VECTOR ANO FREE STORE 
By now, we hope that you are asking, "But why can't pointers remember the 
size?" Obviously, we could design a "pointer" that did exactly that - a vector is 
almost that, and if you look through the C++ literature and libraries, you'll find 
many "smart poimers" that compensate for weaknesses of the low-level buill-in 
pointers. However, somewhere we need to reach the hardware level and under-
stand how objecLS arc addressed - and a machine address docs not "know" what 
it addresses. Also, understanding pointers is essential for understanding lots of 
real-world code. 
17.4.4 Initialization 
As ever, we would like to ensure that an object has been given a value before we 
usc it; that is, we want to be sure that our pointers are initialized and also thm the 
objects they point to have been initialized. Consider: 
double* pO; 
double* p1 = new double; 
double* p2 = new double{S.S); 
double- p3 = new double[S]; 
/I uninitialized: likely trouble 
/I get (allocate) an uninitialized double 
II get a double initialized to 5.5 
/I get (allocate) 5 uninitialized doubles 
Obviously, declaring pO without initializing it is asking for trouble. Consider: 
This will assign 7.0 LO some location in memory. We have no idea which pan of 
memory that will be. It could be harmless, but never, never ever, rely on that. 
Sooner or later, we get the same result as for an out·of-range access: "My pro· 
gram crashed mysteriously" or "My program gives wrong output." A scary per-
centage of serious problems with old-style C++ programs ("C-slyle programs") 
is caused by access through uninitialized pointers and out-of-range access. We 
must do all we can to avoid such access, partly because we aim at professional-
ism, partly because we don't care to waste our time searching for that kind of 
error. There arc few activities as frustrating and tedious as tracking down this 
kind of bug. It is much more pleasant and productive to prevcnt bugs than to 
hunt for them. 
Memory allocated by new is not initialized for built-in types. If you don't like 
that for a single object, you can specify value, as we did for p2: · p2 is 5.5. Note 
the usc of ( ) for initialization. TItis contrasts to the lise of [ I to indicate "array." 
TIlere is no facility for specifying an ittitializer for an array of objects of built-
in types allocated by new. For arrays, we have to do some work ourselves if we 
don't like the default initializer. For example: 
double- p4 = new double(SI; 
for (int i = 0; kS; Hi) p4[il = i; 

17.4 
FREE STORE AND POIN TERS 
Now p4 points to objects of type double containing lhe values 0.0, 1.0, 2.0, 3.0, 
and 4.0. 
As usual, we should worry about un initialized objects and make sure we give 
them a value before we read them. Beware that compilers often have a "debug 
mode" where they by default initialize every variable to a predictable value (usu-
ally 0). TImt implies that when turning off the debug features to ship a program, 
when running an optimizer, or simply when compiling on a different machine, a 
program with uninitialized variables may suddenly run differently. Don't get 
c.."1ught with an unin.itialized variable. 
When we define our own types, we have better control of initialization. If a 
type X has a default constructor, ''''e get: 
X· pxl = new X; 
X· px2 = new XI17]; 
II one default-initialized X 
111 7 default-initialized Xs 
If a type Y has a cOnstrucLOr, but not a default constructor, we have to explicitly 
initialize: 
Y· pyl = new Yi 
Y· py2 = newY[17]i 
Y· py3 = new Y(13); 
II error: no default constructor 
II error: no default constructor 
/I OK: initialized to V( 13) 
17.4.5 The null pointer 
If you have no other pointer to usc for initializing a pointer, use 0 (zero): 
double" pO = Oi 
/I the null pointer 
When assigned to a pointer, the value zero is called the null pointer, and often we 
test whether a pointcr is valid (i.e., whcther it points to somcthing) by checking 
whcthcr it is o. For examplc: 
if (pO != O) 
/I consider pO valid 
lllis is not a perfect test, because pO may contain a "random" value that happens 
to be nonzero or the addrcss of an object that has been deleled (see §17.4.6). 
However, that's often the best we can do. We don't actually have to lllel1lion 0 
explicitly because an if-statement really checks whether its condition is nonzero: 
if (pO) 
II consider pO valid; equivalent to pO!""O 
We prefer this shortcr form, considering it a marc direct expression of the idea 
"pO is valid," but opinions vary. 
583 

S84 
CHAPTER 17 • VECTO R ANO FREE STORE 
We need 10 use the null poimer when we have a pointer that sometimes 
points to an object and sometimes nolo That's rarer than many people think; COIl-
sider: if YOli don't have an object for a pointer to point to, why did you define 
that pointer? Couldn't YOLI wait until you have an object? 
17.4.6 Free-store deallocation 
The new operator allocates ("gets") memory from the free store. Since a cam-
pUler's memory is limited, it is usually a good idea to retum memory to lhe frec 
Siore once we are finished using it. 11m! way, the free store can reuse that mem-
ory for a new allocation. For large programs and for long-running programs such 
freeing of memory for rellse is essential. For example: 
double· calc(int res_size, int max) 
!/Ieaks memory 
{ 
) 
double· p = new double{maxl; 
double- res = new doublelres_sizel; 
/I use p to calculate results to be put in res 
return res; 
double* r = calc(l 00,l000); 
As wriuen, each call of calcO "leaks" the doubles allocated for p. For example, 
the call calc(l00,l000) will render the space needed for 100 doubles unusable for 
the rest of the program. 
The operator for retuming memory to the free store is called delete. We 
apply delete to a pointer retumed by new to make the memory available to the 
free store for future allocation. The example now becomes 
double* calc(int res_size, int max) 
{ 
) 
/I the caller is responsible for the memory allocated for res 
double* P = new double{max); 
double res = new doublelres_sizel; 
/I use p to calculate results to be put in res 
deletell p; 
/I we don't need that memory anymore; free it 
return res; 
double* r = calc(l00, 1000); 
/I use r 
delete( I r; 
II we don't need that memory anymore: free it 

17.4 
FREE STO RE AND PO IN TER S 
Incidentally, this example demonstrates one of the major reasons for using free 
store: \ve can create objects in a function and pass them back to a caller. 
'11ere arc two fonns of delete: 
delete p frees the memory for an individual object allocated by new. 
deletel l p frees the memory for an array of objects allocated by new. 
It is the programmer's tedious job to usc the right version. 
Deleting an object twice is a bad mistake. For example: 
inl· p = new int(5); 
delete Pi 
/I fine: p poinls to an object created by new 
/I ... no usc of p here ... 
delete p; 
/I error: p painls to memory owned by the free-store manager 
TIlere arc two problems with the second delete p: 
You don't own the object pointed LO anymore so the free-store manager 
may have changed its imernal data structure in such a way that it can't 
correctly execute delete p again. 
111e free-store manager may have "recycled" the memory pointed to by p 
so that p now points to another object; deleting that orner object (owned 
by some other part of the program) will cause errors in your program. 
Both problems occur in a real program; rney are not just theoretical possibilities. 
Deleting the null pointer doesn't do anything (because the null pointer doesn't 
point to an object), so deleting the null pointer is hannless. For example: 
int· p =Oi 
delete Pi 
delete Pi 
/I fine: no action needed 
/I also fine (slill no action needed) 
Why do we have to bother with freeing memory? Can't the compiler figure out 
when we don't need a piece of memory anymore and just recycle it without 
human intervention? It can. That's called aul01Tlu.tic garbu.ge collection or just garbage 
(011«1;011. Unfortunately, automatic garbage collection is not cost-free and not ideal 
for all kinds of applications. If you really need automatic garbage collection, you 
can plug a garbage collecmr into your C++ program. Good garbage colicclOrs 
arc available (sec \\T\.v\.v.research.att.com/-bs/C++.hunl). However, in this book 
we assume that you have to deal with your own "garbage," and we show how to 
do so conveniently and efficiently. 
When is it important not to leak memory? A program that needs to run "for-
ever" can't afford any memory leaks. An operating system is an example of a pro-
gram that "runs forever," and so arc most embedded systems (see Chapter 25). A 
585 

CHAPTER 17 • VECTOR AND FREE STORE 
library should not leak memory because someone might use it as part of a system 
lim shouldn't leak memory. In general, it is simply a good idea not to leak. Many 
programmers consider leaks as proof of sloppiness. However, that's slightly over-
stating the point. When you run a program under an operating system (Uni\:, 
Windows, whatever), all memOlY is alilomatically returncd to the system at the 
end of the program. It follows that if you know that your program will not usc 
more memory than is available, you might reasonably decide LO "leak" until the 
operating system does the deallocauon for you. However, if you decide to do that, 
be sure that your memory consumption estimate is correct, or people will have 
good reason to consider you sloppy. 
1 7.5 Destructors 
Now we know how to store the elements for a vector. We simply allocate suffi· 
cient space for the elements on the free store and access them through a pointer: 
/I a very simplified vector of doubles 
class vector ( 
/lihe size 
int 5Z; 
double· elem; 
public: 
/I a pointer 10 Ihe clements 
}; 
vectorOnt 5) 
:sz(s), 
elem(new doublers» 
{ 
/I constructor 
/I initialize sz 
/I initialize elem 
for (int i=O; ks; ++i) elem[il=O; /I initialize elements 
int sizeO const ( return 5Z;} 
/I the current size 
II ... 
So, sz is the number of elements. We iniLialize it in the constmctor and a user of 
vector can get the number of elements by calling sizeO. Space for the clements is 
allocated using new in the constructor, and the pointer returned from the free 
Slore is stored in the member pointer clem. 
Note that we initialize lhe elements to their default value (0.0). ' 1le st:Uldard 
library vector docs that, so we thought it best to do the same from tile start. 
Unfortunately, our first primitive vector leaks memory. In lIle constnlctor, it 
allocates memOlY for the elements using new. To follow the mle stated in §17.4, 
we must makc sure that lIus memory is freed using delete. Consider: 

17.5 
DESTRUCTORS 
void f(int nJ 
( 
) 
vector v(n); 
II . .. 
/I allocate n doubles 
When we leave fO, the elements creaLCd on the free store by v are nm freed. We 
could define a clean_upO operation for vector and call that: 
void f2(int nl 
( 
vector v(n); 
/I define a vector (which allocates another n ints) 
11 • •• usev ... 
v.clean_up(); 
/I clean_upO deletes elem 
That would work. However, one of the most common problems with free store is 
that people forget to delete. The equivalent problem would arise for clean_up() ; 
people wouJd forget to call it. We can do beller than that. The basic idea is to 
have the compiler know about a function that does the opposite of a constructor, 
juSt as it knows about the constructor. Inevitably, such a function is ca.lled a 
deJ/ruclor. In the same way that a constructor is implicitly called when an object of 
a class is created, a destructor is implicitJy called when an object goes out of 
scope. A constnlctor makes sure that an object is properly created and initialized. 
Conversely, a destructor makes sure that an object is properly cleaned up before 
it is destroyed. For example: 
/I a very simplified vector of doubles 
class vector ( 
II the size 
int SZ; 
double- elem; 
public: 
II a pointer to the elements 
); 
vector(int sl 
/I constructor 
:sz(s), elem(new double[s]) 
II allocate memory 
{ 
for (int i=O; ks; ++ i) elem[i}=O; II initialize elements 
) 
-vector() 
( de lele{) elem; } 
II . . . 
/I destructor 
II frcc memory 
587 

588 
Given that, we can write 
void f3(int n) 
{ 
CH APTER 17 • VECTOR AND FREE STORE 
int- p = new int(n]; 
/I allocate n inls 
vector v(n)i 
/I define a vector (which allocates another n ints) 
II ... use pand v .. . 
delete(] p; 
/I deallocate the ints 
} 1/ vector automatically cleans up after v 
Suddenly, that delete[) looks rather tedious and eITor-prone! Given vector, there 
is no reason to allocate memory using new just to deallocate it using deletel) at 
the end of a function. 111at's what vector docs and docs belter. In particular, a 
vector cannOt forgel to call ils dCSlnlCtOl" to deallocate the mcmOlY lIsed for the 
clements. 
We arc 11m going to go into great detail about the uses of dCSU1Jctors here, but 
they arc great for handling rcsourtts that we need to frrs! acquire (from somewhere) 
and later give back: files, threads, locks, etc. Remember how iostreams clean up 
after themselves? They flush buffers, close flies, free buffer space, etc. ' 1mt's done 
by their destructors. Every class that "owns" a resource needs a destructor. 
17.5.1 Generated destructors 
If a member of a class has a destructor, then that destmctor will be called when 
the object containing the member is destroyed. For example: 
struct Customer { 
}; 
string name; 
veclor<string> addresses; 
II. 
void some_fclO 
{ 
Customer fred; 
II initialize fred 
II use fred 
When we exit some_feU), so that fred goes out of scope, fred is destroyed; that 
is, the destructors for name and addresses are called. Ths is obviously necessary 
for destructors to be useful and is sometimes expressed as "The compiler gener· 
ated a destructor for Customer, which calls lhe members' destructors." llmt is 

17 .5 
DESTRUCTORS 
indeed often how the obviolls and necessary guarantee that destructors are called 
is implemented. 
TIle destructors for members - and for bases - arc implicitly called from a 
derived class deslruclOr (whether user-defined or generated). Basically, alJ the 
niles add up to: "Destructors arc called when the object is destroyed" (by going 
out of scope, by delete, etc.). 
17.5.2 Destructors and free store 
Destructors arc concepluaHy simple but are the foundation for many of the most 
effective C++ programming techniques. TIle basic idea is simple: 
\Vhatever resources a class object needs 10 function, it acquires in a con-
stnlctor. 
During the object's lifetime it may release resources and acquire new ones. 
At the end of the object's lifetime, the destructor releases all resources 
still owned by the object. 
TIle matched construclOr/destructor pair handling free-store memory for vector 
is the archetypical example. We'll gct back to that idea with more examples in 
§19.5. Here, we will examine an important application that comes from the usc of 
free-store and class hierarchies in combination. Consider: 
Shape" fel() 
( 
) 
Text II(Poinl(200,200)," Annemarie"); 
II ... 
Shape p = new Text(Point(l00, 100), "Nicholas"); 
return p; 
void fO 
( 
Shape" q = fet{): 
II . .. 
delete q; 
111is looks fairly plausible - and it is. It all works, but let's see how, because that 
exposes an elegant, important, simple technique. Inside felO, the Text object II is 
properl)' destroyed at the exit from fetO. Text has a string member, which obviously 
needs to have its destructor called - Siring handles its memory acquisition and re-
lease exactly like vector. For II, that's easy; the compiler JUSt calls Text's generated 
dcstructor as described i.n §17.5.1. But what abollt the Text object that was rctumed 
589 

590 
CHAPTER 17 • VECTOR AND FR EE STORE 
from fclOr n c calling function fO has no idea that q points LO a Text; all it knows is 
lhat it points to a Shape. 111cn hO\,.. docs delete p get to c."1l1 Text's dCSlnlClor? 
In §14.2. 1, we breezed past the fact that Shape has a destruCLOr. In fact, Shape 
has a virtual dCSlIlictOf. That's the key. ''''hen we say delete p, delete looks at p's 
type to sec if it needs to call a destructor, and if so it calls it. So, delete p calls 
Shape's destructor -Shape(). But -ShapeO is virtual, so - using the virtual c."1l1 
mechanism (§14.3.1) - that call invokes the destructor of Shape's dCI; vcd class, in 
this Cdse - red O. !-lad Shape::-Shape() not been virtual, Text: :-TextO would not 
have been called and Text's string member wouldn't have been properly destroyed. 
As a rule of thumb: if yOli have a class with a virtual function, it needs a 
virtual destructor. '11e reason is: 
I. If a class has a virtual function it is likely to be used as a base class, and 
2. If it is a base class its derived class is likely to be allocated using new, and 
3. If a derived class object is alloc. .... ted using new and manipulated through 
a pointer to its base, then 
4. It is likely to be deleted through a pointer to its base 
Note that destructors are invoked implicitly or indirectly through delete. They 
are not called directly. That saves a lot of tricky work. 
TRY THIS 
Write a little program using base classes and members where you define the 
conStl1.lctors and destructors to output a line of infonnarion when they are 
called. Then, create a few objects and see how their constructors and de--
structors are called. 
17.6 Access to elements 
For vector to be usable, we need a way to read and write elements. Fo r starters, 
we can provide simple gelO and set() member functions: 
/I a very simplified vector of doubles 
class vector { 
int sz; 
/I the size 
double- elem; 
/I a pointer to the elements 
public: 
vector(inl s) :sz(s), elem(new double[s]) ( ) 
-vectorO ( deletell elem; ) 
/I constructor 
/I destructor 

17.7 
POINTERS TO ClASS O I~ JECT S 
) ; 
int sizeO const { return sz; ) 
double gel(int n) { return elem!n]; } 
void set(inl n, double v) { elem!nl=v; ) 
/I the current size 
/I access: read 
II access: write 
Both gelO and sel() access the clements using the [ J operator on the elem pointer: 
elem[n). 
Now we can make a vector of doubles and use it: 
vector v(5); 
for (int i=O; i<v.sizel); ++i) ( 
v.sel{i,l .' *i); 
coul « "v["« i« "1=="« v.get(i)« '\11'; 
TIlis will output 
v[O]==O 
v[11==1.' 
\'[21==2.2 
v[31==3.3 
v[41==4.4 
TIlis is still an overly simple vector, and the code using getO and setO is rather 
ugly compared to the usual subscript nolation. However, we aim to Stan small and 
simple and then grow our programs step by step, testing along the way. As ever, 
this stl<lteb'Y of growth and repealed testing minimizes errors and debugging. 
17.7 Pointers to class objects 
~nle notion of "pointer" is generaJ, so we can point to just about anything we can 
place in memory. For example, we can use pointers to vectors exactly as we usc 
pointers to chars: 
vector· f(int s) 
{ 
) 
vector· p = new vector(s); 
/I fill 'p 
return Pi 
/I allocate a vector on free store 
591 

5'2 
( HA PTER 17 • VECTO R AND FREE STORE 
void ffO 
{ 
) 
veclo r· q = ((4); 
/I use 0q 
delete q; 
/I free veclor on free store 
NOle that when we delete a vector, its destructor is called. For example: 
vector· p = new veclor(S)j 
delete Pi 
/I allocate a vector on free 5tore 
/I deallocate 
Creating the vector 011 the free store, Lhe new operator 
First allocates memory for a vector 
TI1en invokes the vector's constructor to initialize that veclor; the COIl-
structor allocates memory for the vector's clemellts and initializes those 
clements 
Deleting the vector, the delete operator 
Frrst invokes the veclor's dCSlnlctor; the destructor invokes the dcstnlc-
tors for the clements (if they have destructors) and then dcallocatcs the 
memory used for the veclor's clements 
' 11cn dcallocates the memory used for lhc vector 
Note how nicely that works recursively (see §8.5.8). Using t.be real (standard Ii· 
brary) vector we can also do: 
vector< vector<double> >. p = new vector<vector<double> > (10)i 
delete Pi 
Here delete p invokes the deslmctQr for vector< veclor<double> >j this destnlctor 
in tum invokes the destructor for its vector<double> clements, ,md all is neatly 
cleaned up, leaving no object undestroyed and leaking no memory. 
Bcc.'luse delete invokes destmctors (for types, such as vector, that have one), 
delete is often said to destroy objects, not JUSt deallocate them. 
k usual, please remember that a "naked" new outside a constmctor is an 
opportunity to forget to delete it. Unless you have a good (that is, really simple, 
such as Vector_,ef from §13.1O and §E.4) strategy for deleting objects, try to 
keep news in constmctors and deletes in destructors. 
So far, so good, but how do we access the members ofa vector, brlven only a 
pointer? Note that all classes support the operator. (dot) for accessing members, 
given the name of an object: 

17.8 
M ESS ING WIT H TYPES: VOIO' ANO CAS TS 
vector v(4); 
int " = v.size(); 
double d = v_gel(3); 
Similarly, all classes support the operator - > (arrow) for accessing members, 
given a pointer to an object: 
vector· p = new veclor(4); 
inl " = p->size(); 
double d = p->geH3); 
Like . (dot), -> (arrow) can be used for both data members and function mem-
bers. Since built-in types, such as inl and double, have no members, -> doesn't 
apply to buih-in types. D OL and arrow are often called member access operatorJ. 
17.8 Messing with types: void' and casts 
Using pointers and free-slore-allocated arrays, we are very close to the hardware. 
Basically, our operations on pointers (initialization, assignment, -, and I J) map di-
rectly to machine instructions. At this level, the language alTers only a bit of nota-
tiona.! convenience and the compile-time consistency offered by the type system. 
Occasionally, we have to give up even tlmt last bit of protection. 
Naturally, we don't wam to make do without !.he protection of !.he type sys-
tem, but sometimes there is no logical altemative (e.g., we need to interact with 
anotl,er language tlmt doesn't know about C++'s types). TI,ere arc also an un-
fortunate number of cases where we need to interface with old code that wasn't 
designed with static type safety in mind. For that, we need twO things: 
A type of pointer that points lO memory without knowing what kinds of 
objects reside in lhat memory 
An operation to tell the compiler what kind of type to assume (withoUl 
proof) for memory pointed to by one of those pointers 
11,e type void" means "pointer to sOllle melllory that the compiler doesn't know 
the type of." We usc void- when we wam to transmit an address between pieces 
of code that really don't know each other's types. Examplcs are the "address" ar-
guments of a callback function (§ 16.3.1) and the lowest level of memory alloca-
tors (such as the implementation of the new operator). 
'n lere arc no objects of type void, but as we have seen, we usc void to mean 
"no value relUrned": 
void v; 
void fO; 
/I error: there are no objects of type void 
/I fO rclurns nothing -
fO does not return an object of type void 

594 
(HAPTER 17 • VECTO R AND FREE STOR E 
A pointer to any object type can be assigned to a void". For example: 
void" pvl = new inti 
/I OK: int· converts to void' 
void" pv2 = new doubleflO]; 
/! OK: double" converts to void" 
Since the compiler doesn't know what a void" points to, we must tell it : 
void f(void " pv) 
{ 
} 
void" pv2 = pv; 
double* pd = pVi 
' pv = 7; 
1/ copying is OK (copying is what void's are for) 
/I error: cannot conven void' to double" 
I! error: cannot dereference a void' 
/! (we don't know what type of object it points to) 
pv{2J = 9; 
1/ error: cannot subscript a void' 
into pi = static_cast<into>(pv); 
II OK: explicit conversion 
II ... 
A static_cast can be used to explicitly convert between relaled pointer types, stich 
as void" and double (§A.5.7). The name "static_cast" is a deliberately ugly 
name ror an ugly (and dangerous) opeJ<lOon - usc it only when absolutely neces· 
sary. You shouldn't find it necessary very orten - ir at aiL An operation such as 
staticcast is called an explidl type CDllUemQ1l (because that's what it docs) or collo-
quiallya CIlJI (because it is used to support something that's broken). 
C++ olTers twO casts that are potentially even nasticr than static_cast : 
reinte rpreCcasl can cast betwecn unrelated types, sllch as int and double. 
consCcast can "cast away const." 
Fo r example: 
Register· in = reinterpret_casI<Registero>(OxfO; 
void f(consl Buffer· p) 
{ 
Buffer* b = consccast<Buffer*>(p); 
II . .. 
111C first exam ple is thc elassical nccessary and proper usc or a reinterpreccasi. 
We tell the compiler that a certain part or memory (the memory starting with 10· 
cation OxFF) is to bc considered a Register (presumably with special scmantics). 
Such code is necessary when you write things like device drivers. 

17.9 
POINTERS AN D REFERENCES 
in: I OxFF I 
O~r
:-"----' 
III the second example, cons,-cast strips the consl from the consl Buffe r· c l.lIed 
p. Presumably, we kllOW what we are doing. 
At least static_cast can't mess with the poimer/imeger distinction or with 
"const-ness," so prefer sialic_cast if you feci the need for a cast. When you think 
yOll need a c.."lSt, reconsider: Is there a way to write the code without the cast? Is 
there a way to redesign that part of the program so that the caSt is not needed? 
Unless you are interfacing to other people's code or to hardware, there usually is 
a way. If not, expect subtle and nasty bugs. Don't expect code using reinter-
pre,-cast to be portable. 
17.9 Pointers and references 
YOLI can think of a reference as an automatically dereferenccd immutable pointer or 
'IS an altemalive name for an object. Poimers and references differ in these ways: 
Assignment to a poimer changes the poimer's value (not the pointed-to 
vallie). 
1"0 get a pointer YOli generally need to use new or & . 
To access an object pointed to by a pointer yOll lise · or [ J. 
Assignment to a reference changes what the reference refers to (not the 
reference itself). 
YOll cannot make a reference refer to a different. object after initialization. 
Assignment of references does deep copy (assigns to the referred-to ob-
ject); assignment of pointers docs not (assigns to the pointer object itself). 
Beware of Ilull l>ointers. 
For example: 
int x= 10; 
intO p = &x; 
. p = 7; 
int x2 = . p; 
int O p2 = &x2; 
p2 = p; 
P = &x2; 
II you need & to get a pointer 
/I use • to assign to x through p 
/I read x through p 
/I get a pointer to another int 
/I p2 and p both point to x 
/I make p point to another object 
595 

596 
CHAPTER 17 • VECTOR ANO FR EE STORE 
The equivalent example for references is 
inty = 10; 
int&r =y; 
r = 7; 
inty2=r; 
int& ,2 = y2; 
r2 = ' i 
r = &y2; 
II the & is in the type, not in the inilializer 
/I assign to y through r (no' needed) 
/I read y through r (no' needed) 
/I gel a reference 10 another int 
/I the value of y is assigned to y2 
/I error: you can't change the value of a reference 
/I (no assignment of an in'· to an int&) 
Note the last example; it is not just this construct that will fail- there is no way to 
get a reference to refer to a different object after initialization. If you need to point 
to something different, use a pointer. For ideas of how to usc pointers, sec §17.9.3. 
A reference and a polmer are both implemented by using a meIllOry address. 
They just lise that address differently to provide you - the programmer - slighliy 
different facilities. 
17.9.1 Pointer and reference parameters 
When you want to change the value of a variable to a value computed by a func-
tion, you have lhree choices. For example: 
int incr_v(int x) {return x+1; } 
II compute a new value and return it 
void incr_p (int* p) { ++. p ; } 
II pass a pointer 
II (dereference it and increment the result) 
void incr_r{int& r ) {++r; } 
II pass a reference 
How do YOll choose? Vi'e think returning the value often leads to the most obvi-
ous (and therefore least en'or-prone) code; that is: 
inl x = 2; 
x = incr_v(x); 
II copy x to incr_vO; then copy the result out and assign it 
We prefer that style for small objects, SUdl as an int. However, passing a value 
back and fonh is not always feasible. For e.xample, we might be writing a func-
tion that modifies a huge data structure, such as a vector of 10,000 ints; we can't 
copy those 40,000 bytes (at least twice) with acceptable efficiency. 
How do we choose between using a reference argument aJld using a pointer 
argument? Unfortunately, either way has bOlh attractions and problems, so again 
the answer is less than clear-cut. You have to make a decision based on the indi-
vidual function and its likely uses. 

17 .9 
POINTER S AND REFE RENCES 
Using a pointer arh'llment alerts the programmer that something might be 
changed. For example: 
inl x = 7; 
incr_p(&x) 
lIthe & is needed 
incr_r(x); 
"Il,e need to usc & in incr_p(&x) alerts the user that x might be changed. In con-
trast, incr_r(x) "looks innocent." This leads to a slight preference for the pointer 
verSion. 
On the mher hand, if you usc a poilller as a function argument, the function 
has to beware that someone might call it with a null pointer, that is, with a 
pointer with the value zero. For example: 
incr_p(O); 
int* p = O; 
incr_p(p); 
II crash: incr_pO will try to dereference 0 
1/ crash: incr_pO will try to dereference 0 
11,is is obviously nasty. The person who writes incr_pO can protect against this: 
void incr_p(int- p) 
( 
if (p==O) error("null pointer argument to incr_pO"); 
++.p; 
II dereference the pointer and increment the object pointed to 
But now incr_pO suddenly doesn't look as simple and attractive as before. Chap-
ter 5 disCLIsses how to cope with bad arguments. In contrast, users of a reference 
(sudl as incr_,O) arc entitled to assume that a reference refers to an object. 
If "passing 1l00hing" (passing no object) is acceptable from the point of view 
of the semantics of the function, we must usc a pointer argument. Note: 1113t's 
not the case for an increment operation - hence the need for throwing an excep-
lion for p==O. 
So, the real answer is: "The choice depends on the nature of the function": 
For tiny objects prefer pass-by-value. 
For functions where "no object" (represented by 0) is a valid argument 
use a pointer parameter (and remember to test for 0). 
Otherwise, use a reference parameter. 
See also §8.5.6. 
597 

CHAPTER 17 • VECTOR AND FREE STO RE 
17.9.2 Pointers, references, and inheritance 
In §14.3, we saw how a derived class, such as Circle, could be used where an ob-
ject of its public base class Shape was required. We can express that idea in terms 
of pointers or references: a Circle- can be implicitly converted to a Shape* be-
cause Shape is a public base of Circle. For example: 
void rOlale(Shape* s, inl n); 
/I rotate 's n degrees 
Shape p = new Circle(Point(l00, 100),40); 
Circle c(PoinI(200,200),SO); 
rolale(&c,45); 
And similarly for references: 
void rOlale(Shape& S, inl n); 
Shape& r = C; 
rolale(c,75); 
II rotate s n degrees 
l1us is cmcial for mOst object-oriented programming techluqucs (§ 14.3-4). 
17.9.3 An example: lists 
Lists arc among the most common and useful data structures. Usually, a list is 
made out of "links" where eacb link holds some infonnation and pointers to 
other links. This is one of the classical uses of pointers. For example, we could 
represent a short list of Norse gods like this: 
InorseJ<ods I 
"-
Freia 
Odin 
Thor 
'---
-
I---
---
c-
-
A list like this is called a dQubfJ-linked tisl because given a link, we can find both 
the predecessor and the successor. A list where we can find only the successor is 
called a singi)'-tiIlJud list. We usc doubly-linked lists when we want to make it easy 
to remove an clement. We can define these links like this: 
slruct link { 
siring value; 

17.9 
POINTER S AND REFERE NCES 
) ; 
link· prey; 
l ink· SUCCi 
link(consl string& v, link· p = 0, link- s = 0) 
: value(v), prev(p), succ(s) ( ) 
111at is, given a link, we can get to its successor using the SUCt pointer and to its 
predecessor using the prey poimer. We usc the null pointer to indicate that a link 
doesn't have a successor or a predecessor. We can build our list of Norse gods 
like this: 
link- no rse....gods = new link("Thor",O,O); 
no rse....gods = new link("O din " ,norse....gods,O); 
no rse....gods->succ->prev = norse....gods; 
no rse_gods = new link("Frc ia" ,norse....gods,O): 
no rsc_s ods->succ- >prev = norse....godsi 
We built that list by creating the links and tying them together as in the picture: 
first 1110r, then Odin as the predecessor of Thor, and finally Freia as the prede-
cessor of Odin. You can follow the pointer to sec that we gOI it right, so thai each 
succ and prey points to the right god. However, the code is obscure because we 
didn't explicit1y define and name an insert operation: 
link- insert(link· p, link- n) 
/I insert n before p (incomplete) 
( 
n->succ = Pi 
p->prev->succ = n; 
n->prev = p->prev; 
p->prev = n: 
return n: 
/I P comes after n 
/I n comes after what used to be p's predecessor 
/I p's predecessor becomes n's predecessor 
/I n becomes p's predecessor 
111is works provided that p really points to a link and t1mt the link pointed to by 
p really has a predecessor. Please convince yourself that this really is so. When 
t11inking abom pointers and linked structures, such as a list made out of links, we 
invariably draw litt1e box-and-arrow diagrams on paper to verify that our codc 
works for small examples. Please don't be too proud to rely on this efTective low· 
tech design technique. 
That version of insertO is incomplete because it doesn't handle the cases 
where n, p, or p->prev is O. We add the appropriate tests for the null pointer and 
gel the messier, but COlTect, version: 
599 

600 
CHAPTER 17 -
VECTOR AND FREE STO RE 
link- insert(link- p, link· n) 
II insert n before p; relurn n 
( 
) 
if (n==O) return Pi 
if (p==O) return n; 
n->succ = Pi 
II P comes after n 
if (p->prev) p->prev->succ = nj 
n->prev = p->prevj /I p's predecessor becomes n's predecessor 
p->prev = nj 
II n becomes p's predecessor 
return nj 
Given that, we could write 
linke norse_sods = new link("Thor")i 
norse-8ods = inserl(norse....gods,new link(nOdin")); 
norse-8ods = inserl(norse....gods,new Link(nFreia"»; 
Now all the error-prone liddling with the prey and succ poimers has disappeared 
from sight. Poimer liddling is tedious and error-prone and Jhouid be hidden in 
well-written and well-tested functions. In panicular, many errors in conventional 
code come from people forgetting to test pointers against 0 - JUSt as we (deliber-
ately) did in the lim version of insert(). 
Note that we used default arguments (§15.3.1 , §A.9.2) to save users from 
mentioning predecessors and successors in every constructor use. 
17.9.4 List operations 
The standard library provides a list class, which we will describe in §20.4-. It 
hides all link manipulation, but here we will elaborate on our notion of list based 
on the link class to get a feci for what goes on "under the covers" of list classes 
and sec more examples of pointer usc. 
What operations docs our link class need to allow its lIsers to avoid "pointer 
liddling"? 111m's to some extent a matter of tasle, but here is a useful set: 
'11e constructor 
insert: insert before an element 
add : insert after an clement 
erase: remove an cIemem 
find : find a Link with a given value 
advance: get the 11th slIccessor 
We could write these operations like this: 

17.9 
POINTERS AND REFER ENCES 
link" add{link" p, link· n) 
/I inserl n after p; return n 
{ 
1/ much like inserl (see exercise 11) 
) 
link" erase(link" p) 
/I remove 'p from lisl; return p's successor 
{ 
) 
if (p==O) return 0; 
if (p->succ) p->succ- >prev = p->prev; 
if (p->prev) p->prey->succ = p->succ; 
return p- >succ; 
Link" find(link· p. const string& s) 
/I find s in list; 
while(p) ( 
) 
if (p->value == 5) return p; 
p = p->succ; 
return 0; 
/I return 0 for "nol found ~ 
link" advance(link" p. int n) 
/I move n posilions in lisl 
/I relurn 0 (or "not found" 
/I posi1ive n moves forward, negative backward 
{ 
) 
if (p==O) return 0; 
if «kn) { 
while (n--) { 
) 
) 
if (n<o) { 
if (p->succ == 0) return 0; 
p = p->succ; 
while (n++) { 
) 
return p; 
if (p->prev == 0) return 0; 
p = p->prev; 
60' 

602 
( HAPTER 17 • VECTOR AND FREE STO RE 
NOle the lise of the postfix n++. This form of increment ("posl·incremcm") yields 
the value before the incrcmelll as its value. 
17.9.5 list use 
ru a little exercise, let's build 1'.\10 lists: 
link· norsc-!;ods = new Link("Thor"); 
norsc....gods = insert(norsc....gods,new Link("Odin"»; 
norsc....gods = insert(norsc....gods,new link("Zeus"»i 
norse....gods = insert(norsc....gods,new Link("freia"»: 
Link" greek....gods = new Link(tl Hera
tl ); 
greck....gods = insert(greek....gods,new link("Athena")): 
greek-sods = inserl(greek....gods,new Link("Mars")); 
greek....gods = insert(greek....gods,new Link(IIPoseidon"» ; 
"Unfortunatcly," we made a couple of mistakes: Zeus is a Greek god, rather than a 
Norse god, and the Greek god of war is Ares, not Mars (Mars is his L1.tin/Roman 
name). We can fIX that: 
Link- p = find(greek-J;ods, "Mars"); 
if (p) p->value = "Ares"; 
NOlC how wc wcre cautious about findO rcturning a o. Wc think that wc know 
that it can't happen in this case (aftcr all, we just inserted Mars into grcck_gods), 
but in a rcal example somconc might change that code. 
Similarly, we can move Zeus into his correct Pantheon: 
Link- p = fi nd(norse-8ods, "Zeus"); 
if (p) { 
) 
erase(p); 
insert(greek-8ods,p); 
Did you notice the bug? It's quite subtle (unless you are used to working directly 
with links). What if the Link we eraseO is the one pointed to by norse_sods? 
Again, that doesn't actually happen here, but to write good, maintainable code, 
we have to take that possibility into account: 
Link- p = find(norse-8ods, "Zeus"); 
;f (p){ 
if (p==norse-8ods) norse_gods = p->succ; 

17.10 
THE THIS POINTER 
erase(p); 
greek_gods = inserl(greek_gods,p); 
) 
While we were at it, we also corrected the second bug: when we insert Zeus IxjQl"e 
the first Creek god, we need to make greek--sods point LO Zeus's Link. Pointers 
are extremely useful and nexible, but subtle. 
Finally, let's print out those IisLS: 
void print_all(Link- p) 
{ 
coul «"{ "; 
while (p) ( 
coul « p->value; 
if (p=p->succ) coul « ", "; 
) 
coul «" }"; 
prinCall(n orse--S0ds); 
cout«"\n"; 
pri nt_aU(greek--sods); 
cout«"\n" ; 
111is should give 
{ Freia, Odin, Thor } 
{ Zeus, Poseidon, Ares, Athena, Hera } 
17.10 The this pointer 
Note that each of our list functions takes a link- as its first argument and ac-
cesses data in that object. That's the kind of function that we often make member 
functions. Could we simplify Link (or link lISC) by making the operations mem-
bers? Could we maybe make the pointers private so that only the member func-
tions have access to them? We could: 
class Link ( 
public: 
string value; 
603 

CHAPTER 17 • VECTOR AND FREE STORE 
Link(const string& v, Link· p = 0, Link" s = 0) 
: value(v), prev(p), succ(s) ( ) 
Link" insert(Link" n) ; 
/I insert n before this object 
Link" add(Link" n) ; 
/I insert n after this object 
Link" erase() ; 
/I remove this object from list 
Link" (ind(const string& s); 
/I find s in list 
canst Link· find (const string& s) const; 
/I find s in list 
Link" advance(int n) const; 
/I move n positions in list 
Link" nextO canst { return SUCC i } 
l ink" previousO const ( return prev; ) 
private : 
) ; 
link" prev; 
link" S UCC; 
This looks promising. We defined the operations that don't change lhe state of a 
link into canst member functions. \Ve added (nonmodifying) nextO and previous() 
functions so that users could iterate over lists (of Links) - mose arc needed now that 
direct access to succ and prev is prohibited. We left the value as a public member be· 
cause (so far) we have no reason not to; it is "jUSt data." 
Now let's try 10 implement Link : :insertO by copying our previous global 
insertO and modifying it suitably: 
Link· Link : :inserI(Link" n) 
{ 
II insert n before p; return n 
Link" p = this; 
II pointer 10 this object 
ir (n==O) return p; 
II nothing to insert 
if (p==O) return n; 
II nothing to insert into 
n->succ = Pi 
II P comeS after n 
ir (p->prev) p->prev->succ = n; 
n->prev = p->prev; 
II p's predecessor becomes n's predecessor 
p->prev = ni 
II n becomes p's predecessor 
return n; 
) 
But how do we get a pointer to the object for which Link:: insertO was called? 
Without belp from the language we ea.n't. However, in every member function. 
the identifier this is a pointer that points to the object for which lhe member fune-
lion was called. Alternatively, we could simply usc this instead of p: 

17. 10 
THE T HI S PO INTER 
Link- Link :: insert(Link- n) 
{ 
/I insert n before this object; return n 
} 
if (n==O) return this; 
if (this==O) return n; 
n->succ = this; 
II this object comes a(ter n 
if (this->prev) this- >prev->succ = n; 
n->prev = this->prev; 
/I this object's predecessor 
/I becomes n's predecessor 
this->prev = n; 
/I n becomes this object's predecessor 
return ni 
T his is a bit verbose, but we don't need to mention this to access a member, so 
we can abbreviate: 
link- link: :insert(link- n) 
{ 
II insert n before this object; return n 
if (n==O) return this; 
if (this==O) return n; 
n->succ = this; 
/I this object comes after n 
if (prev) prev->succ = ni 
n- >prev = prey; 
/I this object's predecessor becomes n's prt"CIecessor 
prev = ni 
/I n becomes this object's predecessor 
return ni 
} 
In other words, we have been using the this pointer - the pointer to the currelll 
objcct - implicitly every time we accessed a member. It is only when we need to 
refer to the whole object that we need to mention it explicitly. 
Note tllat this has a specific meaning: it points to the object for which a memo 
ber function is called. It docs not point to any old object. The compiler ensures 
tlmt we do not change the value of this in a member function. For example: 
slruct S ( 
}; 
1/ . .. 
void mutate(S- p) 
{ 
} 
this = Pi 
/I error: "this" is immutable 
II ... 
605 

CHAPTER 17 -
VECTOR AND FREE STORE 
17.10.1 More link use 
Having dcalt wilh the implemcntation issues, we can see how the use now looks: 
Linke norse....gods = new Link( tlThor"); 
norse....gods = norse....gods->insert(new Link("Odin tl»; 
norse_gods = norse....gods->inserl(new Link(tlZeustl»; 
norse....gods = norse....gods->inserl(new Link("Freia")); 
Linke greek....gods = new Link(" Heralt); 
greek....gods = greek....gods->inserl(new Link("Alhenalt»; 
grcek....gods = greek....gods->inserl(new Link("Marslt»; 
greek....gods = greek....gods->inserl(new Link("Poseidonlt)); 
That's very much like before. As before, we correct our "mistakes." Correct the 
name of the god of war: 
Link- p = greek....gods->find(HMars"); 
if (p) p->value = "Ares"; 
Move Zeus into his correct Pantheon: 
Linke p2 = norse....gods->find("Zcus"); 
;f(p2) ( 
) 
if (p2==norse....gods) norse_sods = p2->nextO; 
p2->erase()i 
greek....gods = greek....gods->insert(p2); 
Finally, let's print out those lists: 
void prinl_all(Link- p) 
{ 
coul « "{ to; 
while (p) ( 
coul « p->valuei 
if (p=p->ncxl()) coul « ", "; 
) 
coul «
"}" ; 

CHAPTER 17 DR ILL 
prinCall(norsc_sods); 
(out«''\n''; 
pri nt_all(greek-8ods); 
cout«"\n"; 
111is should again hrive 
{ Freia, Odin, Thor) 
{ Zeus, Poseidon, Ares, Athena, Hera } 
So, which version do you like better: the one where insertO, etc. arc member 
functions or the one where they are freestanding functions? In this case the dif· 
ferences don't matter much, but see §9.7.5. 
One thing to observe here is that we still don't have a list class, only a link 
class. 11mt forces us to kecp worrying about which poimer is the pointer to the 
first clement. \ oVe can do better than that - by defining a class List - but designs 
along the lines presented here arc very conmlon. -The standard library list is pre-
sented in §20.4. 
~ 
Drill 
111is drill has twO parts. TIle first exerciseslbuilds your understanding of free-
store-allocated arrays and contrasts arrays with vectors: 
I. Allocate an array of ten inls on the free store using new. 
2. Print the values of the ten ints to caul. 
3. Deallocate the array (using delete[ J). 
4. Write a function print_array10(ostream& os, int· a) that prints out the 
values of a (assumed to have ten clements) to os. 
5. Allocate an array of ten ints on the free store; initialize it with the values 
100, 10 I, 102, etc.; and print out its values. 
6. Allocate an array of II ints on the free store; initialize it with the values 
lOO, lO I, lO2, etc.; and print alit its values. 
7. Write a function prinCarray(ostream& as, int- a, int n) that prints out 
the values of a (assumed to have n clements) to as. 
8. Allocate an array of 20 ints on the free store; initialize it with the values 
100, 101, 102, etc.; and print out its values. 
9. Did you remember to delete the arrays? (If not, do it.) 
10. Do 5, 6, and 8 using a vector instead of an array and a print_vectorO in· 
stead of prinCarrayO. 
607 

CHAPTER 17 • VECTOR AND FREE STORE 
The second part focuses on pointers and their relation to arrays. Using print_array() 
from the last drill: 
l. Allocate an int, i11itialize it to 7, and assign its address to a variable pl . 
2. Print out the value of pl and of the int it points to. 
3. Allocate an array of seven ints; initialize it to 1,2,4,8, etc.; and assign its 
address to a variable p2. 
4. Print out the value of p2 and of the array it points to. 
5. Declare an int· called p3 and uutialize it with p2. 
6. Assign pl to p2. 
7. Assign p3 to p2. 
8. Print out the values of p1 and p2 and of what they point 10. 
9. Deallocate all the memory you allocated from the free store. 
10. Allocate an array of ten ints; initiaJize it to 1, 2,4, 8, etc.; and assign its 
address to a variable pl . 
II. Allocate an array of ten ints, and assign its address to a variable p2. 
12. Copy the vaJues from the array pointed to by pl into the army pointed to 
by p2. 
13. Repeat 10-12 using a vector rather than an array. 
Review 
I. Why do we need data structures with varying numbers of elements? 
2. What four kinds of storage do we have for a typical program? 
3. What is free store? What other name is commonly used for it? "\'\'hat op-
erators support it? 
4. What is a derefcrence operator and why do we need one? 
S. "What is an address? How are memory addresses manipulated in C++? 
6. What infonnation about a pointed-to object does a pointer have? What 
useful information does it lack? 
7. "\'\'hat Cc"1I1 a pointer point to? 
8. What is a leak? 
9. What is a resource? 
10. How C<Ul we initialize a pointer? 
II . What is a nuli pointer? When do we need to use one? 
12. When do we need a pointer (instead of a reference or a named object)? 
13. What is a destructor? When do we want one? 
14. When do we want a virtual destructor? 
IS. How are destructors for members called? 
16. What is a cast? When do we need to use one? 
17. How do we access a member of a class through a pointer? 
18. What is a doubly-linked list? 
19. What is this and when do we need l"O lise it? 

CHAPTER 17 EXERCISES 
Terms 
address 
address of: & 
alloe-ltion 
cast 
container 
comcnts of: • 
deallocation 
delete 
delete[J 
dereference 
Exercises 
desuuctor 
free store 
link 
list 
member acccss: -> 
member destructor 
memory 
memory leak 
new 
null poimer 
pointer 
range 
resource leak 
subscripting 
subscript: [ J 
this 
type conversion 
virtual destructor 
void· 
1. What is the outpm format of pointer values on your implementation? 
Hint: Don't read the documentation. 
2. How many bytes arc there in an int? In a double? In a bool? Do not use 
sizcof except to verify your answer. 
3. \>Vrite a function, void to_lower(char· s), that replaccs all uppercase char-
acters in the C-style string s with their lowercase equivalents. For exam-
ple, "Hello, World! " becomes "hello, world !" Do not use any standard 
library functions. A C-style string is a lero-tenninated array of charac-
ters, so if you fmd a char with the value 0 you are at the end. 
4. Write a fUIlction, char· strdup(const char·), that copics a C-style string 
into memory it allocates on the free store. Do not use any standard li-
brary functions. 
5. Write a function, char· findx(const char· s, canst char· x), that finds the 
first occurrence of the C-style string x in s. 
6. This chapter docs not say what happens when you run out of memory 
using new. That's called memory exhauslirm. Find out what happens. You 
have two obvious alternatives: look for documentation, or write a pro-
gram with an infinite loop that allocates but never deallocatcs. Try both. 
Approximately how much memory did you manage to allocate before 
failing? 
7. Write a program that reads characters from cin into an alTay that you al-
locate on the free store. Read individual characters until an exclamation 
mark (!) is entered. Do not lise a sid: :string. Do not worry about mem-
ory exhaustion. 
8. Do exercise 7 again, but this time read into a sId : :string rather than to 
memory yOll put on the free store (string knows how to lise the free store 
[or you). 

61. 
CHAPTER 17 • VECTOR AND FREE STO RE 
9. Which way does lhe stack grow: up (toward higher addresses) or down (to-
ward lower addresses)? Which way does the free store initially grow (that 
is, before you usc delete)? Wrile a program to dctcnninc the answers. 
10. Look at your solution of exercise 7. Is there any way thal input could gel 
the array to overflow; that is, is there any way you could enter morc 
characters than you allocated space for (a serious error)? Docs anything 
reasonable happen if you try to enter more characters than you allo-
cated? Look up tealiocO and usc it to extend your allocation if needed. 
11. Complete the "list of gods" example from §17.1O.! and run it 
12. 'Why did we define two versions of findO? 
13. Modify t.he link class from §IZlO.l to hold a value of a slruel God. 
struet God should have members of type string: name, mythology, vehi-
cle, and weapon. For example, God("Zeus", "Greek", "", "lightning") 
and God("Odin", "Norse", "Eight-legged flying horse called Sieipner", 
''''). Write a princaUO function that lists gods with their attributes one 
per line. Add a member function add_orderedO that places its new ele-
ment in its correct lexicographical position. Using the Links with the val-
ues of type God, make a list of gods from three mythologies; then move 
the elements (gods) from that list to three lexicographically ordered lists 
- one for each mythology. 
14. Could the '"list of gods" example from §17.10.1 have been written using a 
singly-linked list; that is, could we have left the prev member Ollt of Link? 
Why might we want to do that? For what kind of examples wOlild it 
make sense to lise a singly-linked list? Re-implement that example using 
only a singly-linked list. 
Postscript 
Why bother with messy low-level Sluff like poimers and free store when we can 
simply usc vector? Well, one answer is that someone has to design and implement 
vector and similar abstractions, and we'd like to know how that's done. 111ere arc 
programming languages that don't provide facilities equivalent to pointers and 
thus dodge the problems with low-level programming. Basically, progranuners of 
such languages delegate the laSks that involve direct access to hardware to C++ 
programmers (and progranuners of other languages suitable for low-level pro-
granun..ing). Our favorite reason, however, is si.mply that you can't really claim to 
understand computers and progranillllng until you have seen how software meets 
hardware. People who don't know about pointers, memory addresses, etc. often 
have the strangest ideas of how their progratlillllng language facilities work; such 
wrong ideas can lead to code that's "interestingly poor." 

I. 
r 18 
Vectors and Arrays 
"Caveat emptor!" 
- Good advice 
T
his chapter describes how vectors are copied and accessed 
through subscripting. To do that, we discuss copying in 
general and consider vector's relation to lhe lower-level notion of 
arrays. We present arrays' relation to pointers and consider the 
problems arising from their use. We also present the five essential 
operations that must be considered for every type: construction, 
default construction, copy construction, copy assignment, and 
destruction. 
611 

i12 
18.1 Introduction 
18.2 Copying 
18.2.1 Copy constructors 
18.2.2 Copy assignments 
18.2.3 Copy terminology 
18.3 Essential operations 
18.3.1 Explicit conslructors 
18.3.2 Debugging conslructors and 
deslruclors 
18.4 Access to vector elements 
18.4.1 Oyerloading on consl 
18.1 Introduction 
CHAPTER 18 • VECTORS AND ARRAYS 
18.5 Arrays 
18.5.1 Pointers 10 array elemenls 
18.5.2 Pointers and arrays 
18.5.3 Array initialization 
18.5.4 Pointer problems 
18.6 hamples: palindrome 
18.6.1 Palindromes using string 
18.6.2 Palindromes using arrays 
18.6.3 Palindromes using pointers 
To get into the air, a plane has to accelerate along the runway until it moves fast 
enough to "jump" into the air. 'While the plane is lumbering along the runway, il 
is little more than a particu1arly heavy and awkward truck. Once in the air, it 
soars to become an altogether different, elegant, and efficient vehicle. It is in its 
true clement. 
In this chapter, we are in the middle of a "run" to gather enough progr.un· 
ming language features and techniques to get away from the constraints and diffi-
culties of plain computer memory. We want to get to the point where we can 
program using types that provide exactly the properties we want based on logical 
needs. To "get there" we have to overcome a number of fu ndamental constr<lints 
related to access to the bare machine, such as the following: 
An object in memory is of fIXed size. 
An object in memory is in one specific place. 
ll1e computer provides only a few fundamental operations on such ob-
jects (such as copying a word, adding the values from two words, etc.). 
Basically, those arc the constraints on the built-in types and operations of C++ 
(as inherited from C; sec §22_2.5 and Chapter 27). In Chapter 17, we saw the be-
gillilings of a vector type that controls all access to its elements and provides us 
with operations that seem "natural" from the point of view of a lIser, nnher limn 
from the point of view of hardware. 
This cllapter focuses on the notion of copying. TIlls is an important but 
rather technical point: What do we mean by copying a nontrivial object? 1'0 what 
extent arc the copies independent after a copy operation? What copy operations 
arc there? How do we specify them? And how do they rdate 1"0 other fundamen-
tal operations, such as initialization and cleanup? 

18.2 
COPYIN G 
Inevitably, we get to discuss how memory is manipulated when we don't 
have higher-Ievcltypcs such as vector and string. We examine arrays and point-
ers, their relationship, their usc, and the traps and pitfalls of their use. This is es-
semial information to anyone who geLS to work with low-level uses of C++ or C 
code. 
Please note that the details of vector arc peculiar to vectors and the C++ 
ways of building new higher-level types from lower-level ones. However, every 
;thigher-lcvel" type (string, vector, list, map, etc.) in every language is somehow 
built from the same machine primitives and reOecLS a variety of resolutions to the 
fundamental problems described here. 
18.2 Copying 
Consider our vector as it was at the end of Chapter 17: 
class vecior ( 
int sz; 
/I Ihe size 
double- elem; 
public: 
II a poinler 10 Ihe elemenls 
); 
vector(int 5) 
:sz(s), elem(new doublels1) { } 
-vectorO 
{delcte{] clem; } 
II . .. 
Let's try to copy one of these vectors: 
void f(int n) 
( 
II consTructor 
/I allocates memory 
/I destructor 
/I deallocates memory 
vector v(3); 
v.set(2,2.2); 
vector v2 = v; 
II. 
II define a vector of 3 elements 
/I sel v12] to 2.2 
II what happens here? 
) 
Ideally, v2 becomes a copy of v (that is, = makes copies); that is, v2.sizeO==v.size() 
and the v2[il==vlil for all i's in the range [O:v.sizeO). Furthermore, all memory is 
returned to the free store upon exit from fO. llmt's what the standard library 
vector docs (of course), but it's nm what happens for our still-far-too-simple 
veclor. Our task is to improve our vector to gel it to handle such examples cor-
reclly, but first let's figure out what our CUlTellt version actually does. Exaclly 
613 

,1' 
CHAPTER 18 • VECTORS AND ARRAYS 
what docs it do wrong? How? And why? Once we know that, we Ct"Ul probably fix 
the problems. More importantly, we have a chance to recognize and avoid similar 
problems when we sec them in other contexts. 
TIle default meaning of copying fol' a class is "Copy all the data members." 
11mt often makes perfect sense. For example, we copy a Point by copying its co· 
ordinates. But for a pointer member, just copying the members causes problems. 
In particular, [or the vectors in our example, illllcans that after the copy, we have 
v.sz==v2.sz and v.elem==v2.elem so that our vectors look like this: 
v:.: :: 7~ 
2.2 
That is, v2 doesn't have a copy of v's elements; it shares v's clements. We could 
write 
v.seI(1 ,99); 
v2.set(O,88); 
/I set vl ll to 99 
!/ set v210l toB8 
cout « v.get(O) «' , «
v2.get(1); 
"nle result would be the Output 88 99. 1l1at wasn't what we wanted. Had there 
been no "hidden" connection between v and v2, we would have gotten the output 
00, because we never wrote to vIOl or to v2[1], You could argue that the behavior 
we got is "interesting," "!lead" or "sometimes useful," but that is not what we in-
tended or what the standard library vector provides. Also, what happens when 
we return from fO is an unmitigated disaster. Then, the destructors ror v and v2 
are implicitly called; v's destructor frees the storage lIsed ror the clements lIsing 
delete[] elem; 
and so docs v2's destructor. Since elem points to the same memory 1QC.."ltion in 
both v and v2, that memory will be freed twice with likely disastrous results 
(§17.4.6). 
18.2.1 Copy constructors 
So, what do we do? We'll do the obvious: provide a copy operation that copies 
the elements and make sure thalthis copy operation gets called when we initialize 
one vector with another. 
Initialization of objects or a class is done by a constructor. So, we need a con-
stnlctor that copies. Such a constructor is obviously called a wfry cow/me/or. It is 

18.2 
CO PYING 
defined to take as its argument a reference LO the object from which to copy. So, 
for class vector we need 
veclor(const veclor&); 
~n lis constructor will be called when we try LO initialize one vector with another. 
We pass by reference because we (obviously) don't want LO copy the argument of 
the constructor that defines copying. We pass by canst reference because we 
don't want to modify Ollr argument (§8.5.6). So we refine veclor like this: 
class vector { 
int Sl; 
double- elem; 
void copy(const vector& arg); 
public: 
) ; 
veclor(const veclor&) ; 
/I . . 
/I copy elements from arg into ' clem 
II copy constructor: define copy 
111e copyO simply copies the elemellls from an argument vector: 
void veclor: :copy(const vector& arg) 
II copy elements IO:arg.sz-l l 
for (inl i = 0; i<arg.Sl; Hi) elem[il = arg.elemlil; 
) 
TIle copyO member function assumes that there are sz elements available both in 
its argument arg and in the veclor it is copying into. To help make sure that's 
true. we make copyO private. Only functions that arc part of the implementation 
of veclor can call copyO. These fu nctions need to make sure that the sizes matcll. 
11le copy constructor sets the number of elements (sz) and allocates memory 
for the elements (initializing clem) before copying elcmelll values from the argu-
ment vector; 
veclor: : veelo,(consl veclo,& arg) 
II allocate elemenls, lhen initialize them by copying 
:sz(arg.sz), elcmCnew double(arg.szj) 
copy(arg); 
615 

616 
CHAPTER 18 • VECTOR S AND ARRAYS 
Given this copy constructor, consider again our example: 
vector \'2 = v; 
lllis dcrmition will initialize v2 by a call of vector's copy constructor with v as its 
argument. Again given a vector wilh three clements, we now gel 
v: [3~~==~----'[1 ==~====~2~.2CJ 
v2: ~3=r=====r-------[=====r=====r~
2.~2~ 
Given that, the destructor can do the right thing. Each set of clements is cOn'cclly 
freed. Obviously, the ova vectors are now independent so that we can cll,lI1l;,TC the 
value of clements in v without affecting v2 and vice versa. For example: 
v.set(1,99); 
v2.sel(O,88); 
II set vlll 1099 
IIset v2[01 1088 
cout « v.get(O)« " « v2.geI(1); 
l1lis will output 0 O. 
Instead of saying 
vector v2 = v; 
we could equally well have said 
vector v2(v); 
When v (the initializcr) and \'2 (the variable being initialized) arc of me same type 
and that rype has copying conventionally defined, those twO notations mean ex-
actly the same and yOll ct1.n lise whichever notation you like better. 
18.2.2 Copy assignments 
""e handle copy construction (initialization), but we can also copy veclors by as-
signment. As with copy initialization, the default meaning of copy assignment is 
l11emberwisc copy, so with veclor as defined so far, assignment will cause a dou-
ble deletion (exactly as shown for copy constructors in § 18.2.1) plus a memory 
leak. For example: 
void f2(inl n) 
( 
veclor v(3); 
/I define a veclor 

18.2 COPYING 
) 
v.sel(2,2.2); 
veclar v2(4); 
v2 = v; 
/I . .. 
II assignment: what happens here? 
We would like v2 to be a copy of v (and that's what the standard library vector 
does), but since we have said nothing about the meaning of assignment of our 
veclor, the default assignment is used; that is, the assignment is a memberwise 
copy so that v2's sz and elem become identical to v's sz and elem, respectively. 
We can illustrate that like dus: 
When we leave f20, we have the same disaster as we had when lcaving fO in 
§18.2 before we added the copy constructor: the elements pointed to by both v 
and v2 are freed t".ice (using delete(1). In addition, we have leaked the memory 
initially allocated for v2's four elements. We "forgot" to free those. The remedy 
for this copy assignment is fundamentally the same as for the copy itutialization 
(§18.2.1). We define an assigmnent lhat copies properly: 
class vcclor { 
int SZ; 
double" elem; 
void copy(const veclor& arg); 
II copy elements from arg into ' elem 
public: 
veclor& operator=(consl vector&) ; 
II copy assignmenl 
/I . .. 
) ; 
vector& vector: :operator=(const vector& a) 
/I make Ihis \'€Clor a copy of a 
( 
doublc" P = new double[a.szJ; 
/I allocate new space 
copy(a); 
II copy elements 
deletell elemi 
II deallocate old space 
elem = Pi 
sz = a.sz; 
return "this; 
II now we can reset elem 
/I return a self-reference (see § 1 7.10) 
617 

618 
CHAPTER 18 • VECTO RS AND A RR AY S 
Assignment is a bit more complicated than construction because we must deal 
with the old clcmclllS. OUf basic strategy is to make a copy of the elements from 
the source vector: 
double- p = new double[a.5z)i 
copy(a); 
/I allocate new space 
111cn we free the old clements from the target vector: 
deleteU cle m; 
II deallocate old space 
Finally, we let c lem point to the new clements: 
clem = Pi 
52 = a.52; 
/I now we can reset clem 
We can represent the resull graphically like tlus: 
~
!=:=====:: ____ ~~====~~~~~~~~~G~.~.v~c~nlbia:c::k,to 
YO 
3 
22 
c 
• 
the lrec store by 
delete[] 
.2: >-3,--,-_S",
' '-clz
l :', .... ~L_-'-_--.l _
_ 
L------.J 
-..., 
2.2 
\PVc now have a vector mal docsn'tlcak memory and doesn't free (delete[ !) any 
memory twice. 
'When implementing the assignmclll, you could consider simplifying the 
code by freeing the memory for the old elemenLS before creating t.he copy, but it 
is usually a very good idea not to throwaway information before you know that 
yOll can replace it. Also, if you did that, strange things would happen if you as· 
signed a veclor to itself: 
veclor v(10); 
v=v; 
/I self-assignment 
Please check that our implementation bandies that case corrcctly (if not with op· 
timal efficiency). 
18.2.3 Copy terminology 
Copying is an issue in most programs and in most programming languages. TIle 
basic issuc is whcther you copy a pointer (or reference) or copy the infonllation 
pointed to (referred to): 

18.2 
COPYING 
Sh,lI/ollJ copy copics only a pointer so that thc twO pointcrs now refer to 
thc samc objcct. 111at's what poimers and references do. 
Deej) copy copies what a pointer points to so that the two po inters now 
refer to distinct objcctS. That's what vectors, strings, etc. do. We define 
copy constniclOrs and copy assignments when we want deep copy for 
objects of our classcs. 
Here is an example of shallow copy: 
intO p = new inl(77); 
intO q = p; 
/I copy the poinlCr p 
. p = 88; 
II change the value of the int pointed to by p and q 
'ATe can illustratc that like this: 
p: 
In contrast, we can do a decp copy: 
intO p = new int(77); 
intO q = new inWp); /I allocate a ne\v int, then copy the value pointed to by p 
. p = 88; 
/I change the value of the int pointed to by p 
'vVe can illustrate that like this: 
Using tim terminology, we can say lhat the problem wilh our anginal ved or was 
that it did a shallow copy, rather than copying the clements pointcd to by its elem 
pointer. Our improved vector, like tile standard libral), vector, docs a deep copy 
by allocating new space for the elements and copying their values. Types tllat pro· 
vide shallow copy (like poiIllers and references) are said to have poinler ~1"11I!ics or 
riferclu utl/anhCs (tlley copy addresses). Types that provide deep copy (like string 
and vector) arc said to have value sellulIl!ics (tlley copy tile values pointed to). From 
a uscr perspective, types with value semantics behave as if no pointers were in-
volved - just values tllat c.."ln be copied. One way of tllinking of types with value 
semantics is tlmt tlley "work just like integers" as far as copying is conccmed. 
.,9 

,2. 
CHAPTER 18 • VECTORS AND ARRAYS 
18.3 Essential operations 
We have now reached the point where we can discuss how to decide which COIl-
structors a class should have, whether it should have a destructor, and whether 
you need to provide a copy assignment. There arc five essential operations to 
consider: 
Constructors from one or more arguments 
Default constructor 
Copy constructor (copy object of same type) 
Copy assignment (copy object of same type) 
Destructor 
Usually we need one or more constructors that take arguments needed to initial-
ize an objecl. For example: 
string s("Triumph"); 
vector<double> v(10); 
II initialize s to the character string "Triumph' 
/! make v a vector of 10 doubles 
As you can see, the meaning/use of an initializer is completely up to the construc-
tOf. The standard siting's constructor uses a character string as an initial value, 
whereas the standard vector's constructor uses an integer as the initial number of 
clements. Usually we usc a constructor to establish an invariant (§9.4.3). If we 
can't define a good invariant for a class that its constructors can establish, we 
probably have a poorly designed class or a plain data structure. 
Constructors that take arguments are as varied as the classes they serve. The 
remaining operations have more regular patterns. 
How do we know if a class needs a default constructor? We need a default 
consuuctor if we want to be able to make objects of the class without specifying 
an initializer. ·nle most COllllllon example is when we want to put objects of a 
class into a standard library vector. 11le following works only because we have 
default values for int, string, and veclor<inl>: 
vector<double> vi(10); 
/I vector of 10 doubles, each initialized to 0.0 
vector<string> vs(10); 
1/ vector of 10 strings, each initialized to ". 
vector<vector< inl> > vvi(10); /I v(.'ctor of 10 vectors, each initialiwd to vectorO 
So, having a default constructor is often useful. TIle question then becomes: 
"\>\Then docs it make sense to have a default constructor?" An answer is: "When 
we can establish the invariant for the class with a meaningful and obvious default 
value." For value types, such as inl a.nd double, the obvious value is 0 (for double, 
t.hat becomes 0.0). For Siring, the empty siring, "", is the obvious choice. For 

18.3 
ESSENTIAL OPERATIONS 
vector, the empty vedor serves well. For every type T, TO is the default value, if a 
default exists. For example, doubleO is 0.0, stringO is '''', and vector<inl>() is the 
empty vector orints. 
A class needs a destructor if it acquires resources. A resource is something 
you "get from somewhere" and that you must give back once you have finished 
using it. llle obvious example is memory that you get from the free store (using 
new) and have to give back to the free store (using delete or delete[J). Our 
vector acquires memory to hold its clements, so it has m give that memory back; 
therefore. it needs a destnlctor. Other resources that you might encounter as 
your programs increase in ambition and sophistication are files (if you open one, 
you also have to dose it), locks, thread handles, and sockets (for communication 
with processes and remote computers). 
Another sign that a class needs a destructor is simply that it has members 
that arc pointers or references. If a class has a pointer or a reference member, it 
often needs a destructor and copy operations. 
A class that needs a destructor almost always also needs a copy conSlmctor 
and a copy assignmcnt. The reason is simply that if an object has acquired a re-
source (and has a pointer member pointing to it), the default meaning of copy 
(shallow, melllberwise copy) is almost certainly wrong. Again, vector is the clas-
sic example. 
In addition, a base class for which a derived class may have a destructor 
needs a virtual destructor (§17.5.2). 
18.3.1 Explicit constructors 
A constructor that mkes a single argument defines a conversion from its argu-
ment type to its class. 1l1is can be most useful. For example: 
class comple" ( 
public: 
comple,,(double); 
/I defines double-to-complex conversion 
complex(double,double); 
II . .. 
); 
comple" zl = 3.14; 
II OK: convert 3.14 to (3. 14,0) 
complex z2 = complex(1.2, 3.4); 
However, implicit conversions should be used sparingly and with calilion, be-
c.ause they can cause unexpected and undesirable effects. For example, our 
vector, as defined so far, has a constructor that takes an into This implies that it 
defines a conversion from int to vector. For example: 
621 

622 
class vector { 
}; 
1/ . .. 
vector(inf); 
1/ . .. 
vector v = 10; 
v= 20; 
CHAPTER 18 • VECTOR S AND ARRAYS 
II odd: makes a vector of 10 doubles 
II eh? Assigns a new vector of 20 doubles to v 
void f(const vector&); 
f(10); 
/I eh? Calls f with a new vector of 10 doubles 
It seems we are getting more than we have bargained for. Fortunately, it is simple 
to suppress this usc of a constructor as an implicit conversion. A constructor de-
fined explicit provides only the usual construction semantics and not lhe implicit 
conversions. For example: 
class vector { 
1/ . .. 
explicit vector(inl); 
1/ . .. 
}; 
vedar v = 10; 
v = 20; 
vector vO(10); 
1/ crror: no int-lO-vecl0r<double> conversion 
/I error: no int-lo-vCC10r<double> conversion 
/10K 
void f(const vector<double>&); 
f(10); 
II error: no int-to-vector<double> conversion 
f(vector<double>(10» ; II OK 
10 avoid surprising conversions, we - and the standard - define vector's single-
argument constructors to be explicit. It's a pity that constructors arc not explicit 
by default; if in doubt, make any constructor that can be invoked with a single ar-
gument explicit. 
18.3.2 Debugging constructors and destructors 
Constructors and destructors are invoked at well-defined and predictable points 
of a program's execution. However, we don't always write explicit caJls, such as 
vector(2); rather we do something, such as declaring a vector, passing a vector as 
a by-value argument, or creating a vector on the free store using new. This can 
cause confusion for people who think in terms of syntax. Illere is not just 11 sin-
gle syntax that lriggers a constructor. It is simpler to think of constructors and de-
structors this way: 

18.3 
ESSENTIAL O PERATIONS 
Whenever an object of type X is created, one of X's constructors is invoked. 
Whenevef an objeet of type X is destfoyed, X's dest1uctor is invoked. 
A destructOf is called whenever an object of its class is destroyed; that happens 
when names go OUi of scope, the program terminates, or delete is used on a 
pointef to an object. A constructor (some appfopriate constructor) is invoked 
whenever an object of its class is created; that happens when a variable is initial-
ized, an object is created using new (except for built-in types), and whenever an 
object is copied. 
But when docs that happen? A good way to get a feci for that is to add print 
statements to constructors, assignment operations, and destructors and then just 
try. For example: 
slrue! X ( 
/I simple lest class 
inl val; 
void out(consl slring& s) 
( cerr « this« "->" «s« ": H «
val « "\n"; ) 
XO{ oul("XO"); val=O; } 
/I default constructor 
X(int v) ( oul( "X(int)"); val=v; } 
X(const X& x){ out("X(X&) "); val=x.val; ) 
/I copy constructor 
X& opcrator=(const X& a) /I copy assignment 
( out("X: :opcrator=()"); val=a.va1; return · this; } 
- XO ( out(H_XO"); ) 
/I destructor 
} ; 
Anything we do with this X will leave a tfacc that we can study. For example: 
x glob!2}; 
1/ a global variable 
X copy(X a) { return a; } 
X copy2(X a) { X aa = a; return aa; } 
X& reUo(X& a) { return a; } 
X· make(int i) ( X ali); return new X(a); } 
slruct XX { X a; X b; }; 
inl mainO 
( 
X loc(4); 
X loc2 = lac; 
lac = X(5); 
/I local variable 

624 
( 
loe2 = copy(loc); 
loe2 = copy2(1oc); 
X loc3(6); 
X& r = reUo(1oc); 
delete make(7); 
delete make(8); 
veclor<X> v(4); 
xx loc4; 
X· P = new X(9); 
delete Pi 
X· pp = n ew X[5]i 
delete pp; 
Try executing that. 
TRY THIS 
CHAPTE R 18 • VE CTO RS AND ARRAYS 
/I an X on the free store 
/I an array of Xs on the free store 
We really mean it: do run this example and make sure you understand the 
result. If you do, you'U understand m Ost of what there is to know about con-
struction and destruction of objects. 
Depending on the quality of your compiler, you may note some "missing copies" 
relating to our calls of copyO and copy20. We (humans) can sec that those fune-
lions do nOlhing: they just copy a vallie unmodified from input to output. If a 
compiler is smart enough to nolice that, it is allowed to eliminate the c'll1s to the 
copy constructor. In othcr words, a compilcr is allowed to assumc that <l copy 
constructor copies and docs nothing but copy. Some compilers are smart enough 
to eliminate many spurious copies. 
Now consider: why should we bother with this "silly class x"? It's a bit like 
the finger exercises t.hat musicians have to do. After doing them, other things -
things that matter - become easier. Also, ir you have problems with constructors 
and destructors, you can i.nsert such print statements in constructors ror your real 
classes to sec that they work as intended. For larger programs, this exaet kind or 
tracing becomes tedious, but similar techn.iques apply. For example, you can de· 
termine whether you have a memory leak by seeing ir the number or constmc· 
uons minus the number or destmctiolls equals lero. Forgetting to define copy 
COl1stmclors and copy assiglUllents ror classes that allocate memory or hold point· 
ers to objects is a common - and easily avoidable - source or problems. 
If your problems get too big to handle by sllch simple means, you will have 
learned enough to be able to start using the proressional tools ror finding such 
problems; they arc often referred to as "leak detectors." The idcal, or course, is 
not to leak memory by using teclmiqucs that avoid sllch leaks. 

18.4 
ACCESS TO VECTOR ELEMENTS 
18.4 Access to vector elements 
So far (§17.6), we have used se(() and getO member functions to access elements. 
Such uses are verbose and ugly. We want our usual subscript nouuion: v[i). The 
way to get that is to define a member function called operator[J. Here is our frrst 
(naive) tly: 
class vector { 
int sz; 
double· elem; 
public: 
/I . .. 
IIlhe size 
II a pointer to the elements 
double operator[J(inl n) { return elem[n]; } 
} ; 
/I return clement 
'1lallooks good and especially it looks simple, but unfortunately it is tOO simple. 
Letting the subscript operator (operator[JO) return a value enables reading but 
not writing of clements: 
vector v(10); 
inl x = v[2]; 
v[31 = x; 
II fine 
Ilerroe vl31 is not an Ivalue 
Here, v[iJ is interpreted as a call v.operator(J(i), and that call returns the value of 
v's clement number i. For this overly naive vector, v[3] is a floating·poilll value, 
not a floating-point variable. 
TRY TH IS 
Make a version of this vector that is complete enough to compile and see 
what error message your compiler produces for v[3]=x;. 
Our next try is to let operator[J return a pointer to the appropriate clement: 
class vector { 
int sz; 
double" elem; 
public: 
/I .. 
/I the size 
/I a pointer to thc elements 
double" operator[l{int n) ( return &elemln1; } 
} ; 
Given that definition, we can write 
/I return pointcr 
.25 

.,6 
veclaT v(10); 
for (in! i=Oj i<v.size(); ++i) ( 
·v[i] = i; 
cout« · v[i]; 
) 
CHAPTER 18 • VECTORS AND ARRAY S 
/I works, but still too ugly 
Here, v[i] is interpreted as a call v.operator[](i), and that call rctums a pointer 10 
v's clement number i. The problem is that ""'C have to write · to dereference that 
pointer to get to the clement. TImt's ahnost as had as having to wnte setO and 
get(). Retuming a reference from the subscript operator solves lhis problem: 
class vector { 
1/ . . . 
double& operator[ ](int nl ( return elem[n]i } II return reference 
) ; 
Now we can write 
vector v(10); 
for (inl i=O; i<v.size(); ++i) { 
v[il = i; 
cout« v[il; 
) 
/I works! 
/I viii returns a reference clement i 
We have achieved the convcnuonal notation: v[il is interpreted as a (,Ill v.opcra-
lor[](i). and that returns a reference to v's clement number i. 
18.4.1 Overloading on const 
The operator[]() defined so far has a problem: it cannot be invoked for a const 
vector. For example: 
void {(const vector& cv) 
{ 
double d = cv[l ]; 
/I error, but should be fi ne 
cv[l] = 2.0; 
1/ error (as it should be) 
) 
TIle reason is our vector: :operator[]() could potentially change a vector. It doesn't, 
butlhe compiler doesn't know mat because we "forgot" to tell it. 111e solution is to 
provide a version mat is a const member function (see §9.7.4). "That's easily done: 
class vector ( 
1/ . .. 
double& operator[](int n); 
1/ for non-canst vectors 

1 a.s 
ARRAYS 
double operator[J(inl n) const; II for const vectors 
} ; 
We obviollsly couldn't return a double& from the eonst version, so we re-
turned a double value. We could equally well have returned a const double &, 
but since a double is a small object there would be no point in returning a refer-
ence (§8.5.6) so we decided to pass it back by value. We can now write: 
void ff(const vector& cv, veclor& v) 
( 
) 
double d = cv11l; 
ev(l] = 2.0; 
double d = v(I]; 
vl11 = 2.0; 
/I fine (uses Ihe canst r]) 
/I error (uses the const I H 
/I fine (uses the non-const III 
/I fine (uses the non-conSI III 
Since veclors arc often passed by const reference, this const version of opera· 
tor[]() is an essential addition. 
18.5 Arrays 
For a while, we have llsed amry to refer to a sequence of objects allocated on the 
free store. We can also allocate arrays elsewhere as named variables. In fact, they 
arc common 
As global variables (but global variables are most often a bad idea) 
As local variables (but arrays have serious limitations there) 
As function arguments (but an array doesn't know its own size) 
As class members (but member arrays can be hard to initialize). 
Now, yOll might have detected that we have a not-50-subtle bias in favor of vectors 
over arrays. Use vector where you have a choice - and you have a choice in most 
contexts. However, arrays existed long before vectors and are roughly equivalent 
to what is offered in aLher languages (notably e), so you must know arrays, and 
know them well, to be able to cope with older code and with code written by peo-
ple who don't appreciate the advamages of vector. 
So, what is an array? How do we define an array? How do we use an array? 
An (lrmy is a homogeneoLis sequence of objects alloc.-ued in contiguous memory; 
that is, all clements of an array have the same type and there arc no gaps between 
the objects of the sequence. The clements or an array are numbered from 0 up-
ward. Ll a declaration, an array is indicated by "square brackets": 
consl int max = 100; 
int gai[max]; 
II a global array (of 100 ;nts); "lives iorever" 
627 

628 
void f(int nJ 
( 
) 
char lac[20); 
inllai(60)i 
double ladln]; 
II . 
CHAPTER 18 • VE CTO RS AND ARR AYS 
II local array; " I ives~ until the end of scope 
/I error: array size not a constant 
Note the limitation: the number of clements of a named arm)' must be known at 
compile time. If you want the number of eiClUclllS to be a variable, you mllst put 
it on lhe free store and access it through a poimer. 'Tllat's what vector docs with 
its array of clements. 
J ust like the arrays on free store, we access named arrays using the subscript 
and dereference operators (I J and .). For example: 
void f2() 
( 
) 
char lae(20); 
lae[7] = 'a 'i 
· Iac = 'b'; 
lac(- 21 = 'b'; 
lac(200] = 'e'; 
II local array; "lives'" until the end of scope 
/I equivalent to lacIOI='b' 
/I huh? 
1/ huh? 
111is function compilcs, but we know that "compiles" doesn't mean "works cor· 
reedy." The use of [ I is obvious, but there is no range checking, so f20 compiles, 
and the result of writing to lac[-21 and lacl2001 is (as for all out-of-range access) 
usually disastrous. Don't do it. Arrays do not range check. Again, we arc dealing 
directly Witll physical memory here; don't expect "system support." 
But couldn't the compiler see that lac has just 20 clements so that lac(2001 is 
an error? A compiler could, but as far as we know no production compiler does. 
TIle problem is that keeping track of array bounds at compile time is impossible 
in general, and catching errors in the simplest cases (like the one above) only is 
not very helpful. 
18.5.1 Pointers to array elements 
A pointer can point to an clement of an array. Consider: 
double ad [10]; 
double- p = &adI51; 
II point to ad[51 

18 .5 
A RR AYS 
We now have a pointer p to the double known as ad(51: 
We can subscript and dereference lhat pointer: 
. p =7; 
pl'l = 6, 
pl-31 = 9, 
Wegct 
TIlat is, we can subscript the pointer with both positive and negative numbers. 
As long as the resulting clement is in range, all is well. However, access outside 
the range or the array pointed imo is illegal (as with rree-Slore-allocated arrays; 
see §17.4.3). Typically, access outside an array is not detected by the compiler and 
(sooner or later) is disastrous. 
Once a pointer points into an array, addition and subscripting can be used to 
make it point to another clement or the array. For example: 
p += 2; 
1/ move p 2 clements to the right 
We get 
And 
p -= 5; 
II move p 5 clements to the left 
629 

CHAPTER 18 • VECTORS AND ARRAYS 
We get 
p: 
Using +, - , +=, and -= to move pointers around is called painter tln·tflmctic. Obvi· 
ollsly, if we do that, we have to take great care to ensure that the result is nOt a 
pointer to memory outside the array: 
p += 1000; 
double d = .p; 
. p = 12.34; 
/I insane: p points into an array with just 10 elements 
/I illegal: probably a bad value 
/I (definitely an unpredictable value) 
/I illegal: probably scrambles some unknown data 
Unfortunately, not all bad bugs involving pointer arithmetic are that easy to spot. 
llle best policy is usually simply to avoid poinler arithmetic. 
llle most common lise of poimer arithmetic is incrementing a pointer (using 
++) to point to the next element and decrementing a pointer (using --) to point 
to the previous element. For example, we could print the vallie of ad's elements 
like this: 
for (double· p = &ad[O]; p<&adll0]; ++p) coul « . p « '\n'; 
Or backward: 
for (double* p = &ad[9]i p>=&ad[O]i --p) Coul« *p « '\n'i 
lllls use of pointer arithmetic is not uncommon. However, we find the last ("back· 
ward") example quite easy to get wrong. Why &ad191 and not &ad[10]? \,yhy >= 
and not >? These examples could equaUy well (and equally efficiently) be done 
using subscripting. Such examples could be done equally well using subscripting 
into a vedor, which is more easily range checked. 
Note that most real·world uses of pointer arithmetic involve a pointer passed 
as a runction argument. In that case, the compiler doesn't have a clue how many 
clements arc in the array pointed into: yOll are on your own. l1mt is a situation 
we prefer to stay away from whenever we can. 
Why docs C++ have (anow) pointer arithmetic at all? It can be such a bother 
and doesn't provide anything new once we have subsclipting. For example: 

18.5 
ARRAY S 
double p1 = &ad(O], 
double· ,,2 = p1+7, 
double" p3 = &pll71; 
if (p2! = p3) coul « "impossible!\n"; 
Mainly, the reason is historical. TIlese n iles werc crafted for C decades ago and 
can't be removed without brcaking a lot of code. Partly, there can be some con-
venience gained using pointer arithmetic in some important low· level applic<I' 
lions, stich as memory managers. 
18.5.2 Pointers and arrays 
'The name of an array refers to all the clements of the array. Consider: 
char ch(l00}; 
'Ille size of ch, sizeof(ch), is 100. However, lhe mune of an array tums into ("decays 
to") a paimer with the slightest excuse. For example: 
char· p = ch, 
Here p is initialized to &ch(O] and sizeof(p) is something like 4 (not 100). 
TIlis can be useful . For example, consider a function strlenO that counts the 
number of characters in a zero·tenninated array of characters: 
int strlen(const char· p) 
/I similar to the standard library stden() 
( 
} 
inl count = 0, 
while (.p ) ( ++counl, ++p; ) 
return counl, 
We can now call this with strlen(ch) as well as strlen(&chIO». You might point 
out lhat this is a very minor notational advantage, and we'd have to agree. 
One reason for having array names convert to pointers is to avoid acciden-
tally passing large amounts of data by value. Consider: 
inl slrlen(consl char am 
( 
int counl = 0; 
II similar \0 the standard library strienO 
while (a(count]) { ++(ounl; ) 
return count, 
} 
631 

632 
char lois [l00000J; 
void fO 
{ 
) 
int nchar = slrlen(lots); 
/I . . . 
CHAPTER 18 • VECTORS AND ARRAYS 
Naively (and quite reasonably), you might expect this call to copy the 100,000 
characters specified as the argument to sirlen(), blll mat's not what happens. In-
stead, lhe argument declaration char pll is considered equivalent to char· p and 
the call strlen(lots) is considered equivalent to strlen(&lots[O)). 111is saves you 
from an expensive copy operation, but it should surprise you. \lVhy should it sur-
prise you? Because in every other casc, when you pass an object and don't ex' 
plicitly declare an argument to be passed by reference (§8.5.3-6), that object is 
copied. 
Note thal the pointer you get from treating the name of an array as a pointer 
to its first clement is a value and not a variable, so you cannOl assign to it: 
char ac[10]; 
ac = new char [20]; 
&ac[O] = new char [20]; 
/I error: no assignment to array name 
II error: no assignmenllo pointer value 
Finally! A problem that the compiler will catch! 
As a consequence of this implicit array-name-to·pointer conversion, you can't 
even copy arrays using assignment: 
int x[looJ; 
inl y{loo]; 
II ... 
X=Yi 
I/error 
inl z[loo] = y; 
/I error 
~nl is is consistent, but often a bOlher. If yOll need to copy an array, you must 
write some more elaborate code to do so. For example: 
far (int i=O; i<loo; ++i) x(i]=y(i]; 
memcpy(x. y.1 00· sizeaf(i n I»; 
capy(y.y+100, x); 
/I copy' 00 ints 
/I copy 1 OO'sizeof(int) bytes 
Ilcopy 100 inls 
Note thaI t.he C language doesn't. support anything like vector, so in C, you must 
lise arrays extensively. 111is implies t.hat a lot of C++ code uses arrays (§27.1.2). 
[n particular, C-style strings (zero-terminated arrays of characters; see §27.5) are 
very common. 

18 .5 
ARRAYS 
If wc want assignmcnt, wc havc to use somcthing like vector. TI1C vector 
eCluivaicnt to the copying code above is 
veclor<inl> x(100); 
veclor<inl> y(100); 
II. 
x = y; 
/I copy 100 ints 
18.5.3 Array initialization 
Arrays have one significant advantage over vectors and Olhcr llser-defmcd con-
tainers: the C++ language provides notational support for the initialization of ar-
r-dyS. For example: 
charac!l = "Beorn"; 
II array of 6 chars 
Count those characters. TIlere arc five, but ac becomes an array of six characters 
bccausc the compiler adds a temtinating zcro character at th e end of a string literal: 
ac: I'B' I'e' I'o' I'r' I'n'l 0 I 
A zero·terminated string is the nonn in C and many systems. We call such a zero· 
terminated array of characters a C-.st;·k .slrillg. All string literals arc C-stylc strings. 
For example: 
char· pc = "Howdy"; 
/I pc points 10 an array of 6 chars 
Graphically: 
pc: 
'H' '0' 'w' 'd' 'y' 0 
Note that the char with the numcric vaiue 0 is not the character '0' or any other 
letter or digit. The purpose of that temtinating zero is to allow functions to find 
the end of tlle string. Remcmber: An array does not know its sizc. Relying on tlle 
temtinating zero convention, we can write 
int strlcn(const char- p ) 
{ 
} 
int n = 0; 
while (p [n l) Hn; 
return n; 
/I similar to the standard library strfen() 

634 
CHAPTER 18 • VECTORS AND ARRAYS 
Actually, we don't have to define slrlenO because it is a standard library function 
defmed in the <slring.h> header (§27.S, §B.1O.3). Note that strlenO coums the 
characters, but not the temlinating 0; that is, YOli need 11+ I chars LO SLOre /I char-
acters in a C-stylc string. 
Only character arrays can be initialized by literal Slrings, but all arrays can be 
initialized by a list of values of their e1emem type. For example: 
inl ail] = { 1, 2, 3, 4, 5, 6}; 
int ai2(100) = { 0,1,2,3,4,5,6,7,8,9}; 
double ad(1001 = { }; 
char charsll = {'a', 'b', 'e'}i 
/I array of 6 inls 
lithe last 90 elements are initialized to 0 
/I all elements initialized to 0.0 
/I no terminating O! 
Note that the number of elements of ai is six (not seven) and the number of cle-
ments for chars is three (not four) - the "add a 0 at the end" rule is ror literal 
character strings only. Ir an array isn't given a size, that size is deduced rrom the 
initializer list. l1lat's a rather useful reature. Ir there arc rewer initializer valu$!s 
than array clements (as in the definitions or ai2 and ad), the remaining elements 
arc initialized by the element type's default value. 
18.5.4 Pointer problems 
Like arrays, pointers arc orten overused and misused. Orten, the problems people 
get themselves into involve both pointers and arrays, so we'll summarize the 
problems here. In particular, all serious problems with pointers involve trying to 
access somcthing that isn't an object or the expected type, and many or those 
problems involve access outside the bounds or an array. Here we will consider 
Access through the null pointer 
Access through an uninirialized pointer 
Access ofT the end or an array 
Access to a deallocated object 
Access to an object that has gone out of scope 
In all cases, the practical problem ror the programmer is that the actual access 
looks perrectly innocent; it is "just" that the pointer hasn't been given a value 
that makes the usc valid. Worse (in the case or a write through the pointer), the 
problem may manirest itselr only a long time later when some apparently unre-
lated object has been corrupted. Let's consider examples: 
DOII 'I uaw Ihrough 1M lIull poil/ler: 
int· p = 0; 
·p=7; 
/I ouch! 

18.5 
ARRAY S 
Obviollsly, in real-world programs, this typicaJly occurs when there is some code 
in between the initialization and the usc. In particular, passing p lO a function or 
receiving it as the result from a function arc common examples. We prefer not to 
pass null poimers around, but if you have la, test for the null pointer before lise: 
and 
int o. p = fc,-Iha,-can_return_,,-O(); 
if (p==O) { 
} 
else { 
} 
II do something 
/I use P 
'p = 7; 
void fcUhat_can_receive_a_O(int' p ) 
{ 
if (p==O) { 
} 
else { 
} 
II do something 
/I use P 
"p = 7; 
Using references (§17.9. 1) and using exceptions to signal errors (§S.6 and §19.5) 
arc the main tools for avoiding l1ull pointers. 
Do inili(l/ize )'our poiJ/lm : 
int o. p; 
. p = 9; 
II ouch! 
In particular, don't forget to initialize pointers that arc class members. 
Dml 'I acceJJ m:mexistl:1ll array elemellts: 
inl a(10]; 
inl· p = &a(10]; 
"p=11 ; 
/lauch! 
a(10) = 12; 
/I ouch! 
635 

'36 
CH APTER 18 • VECTOR S AND ARRAY S 
Be careful with the first and last elemenLS of a loop, and try not to pass arrays 
around as poimcrs to their first elements. Instead usc vectors. If you really must 
usc an array in morc than one function (passing it as an argument), then be extra 
careful and pass its size along. 
DOll'l access through a deleted po/iller: 
int- p = new int(7); 
/I . .. 
dele te Pi 
/I . . . 
• p = 13; 
II ouch! 
TIle delete p or the code after it may have scribbled all over . p or used it for 
something else. Of all of these problems, we consider this one the hardest to sys-
tcmatica11y avoid. The most effective defense against this problem is not to have 
"naked" news that require "naked" deletes: lISC new and delete in constructors 
and dCSlnlCLQfS or lise a container, such as Vector_ref (§E.4), to handle deletes. 
DOIl'1 return (l pointer to a {()(QI variable: 
int· fO 
( 
} 
/I . .. 
int x=7; 
II . 
return &x; 
int· p = fO; 
/I . .. 
• p = 15; 
!lauch! 
TIle return from fO or the code after it may have scribbled all over . p or used it 
for something elsc. The reason for thal is that the local vmiablcs of a function arc 
allocated (on the stack) upon entry to the function and deallocated again at the 
exit from the function. In particular, desu-uctors arc called for local variables of 
classes with destructors (§17.5. 1). Compilers could catch mOst problems related 
to rCluming pointers 10 local variables, but few do. 
Consider a logically equivalent example: 
vector& ffO 
( 
vector x(7); 

18 .6 
EXAMPLES: PAliNDROME 
II. 
return x; 
1/1he vector x is destroyed here 
II. 
vector& p = UO; 
II . . . 
p!41 = 15; 
1/ ouch! 
Qtite a rew compilers catch this variant or the return problem. 
It is cOlllmon ror programmers to underesumate these problems. However, 
many experienced programmers have been defeated by the innumerable varia-
tions and combinations or these simple array and pointer problems. '11e soluuon 
is nOt to litter your code with poimers, arrays, news, and deletes. If you do, 
"being careful" simply isn't enough in realistically sized programs. Instead, rely 
on vectors, RAJ! ("Resource Acquisition Is Initialization"; see § 19.5), and other 
systematic approaches to the management or memory and other resources. 
18.6 Examples: palindrome 
Enough teclmical examples! Let's try a little puzzle. A palindrome is a word that is 
spclled the same rrom both ends. For example, OIl11a, petep, and ma/a)'alllln are 
palindromes, whereas ida and Ii()mesid are not. There are nvo basic ways or deter-
mining whether a word is a palindrome: 
Make a copy of the letters in reverse order and compare that copy to the 
original. 
See ir thc first letler is the same as the last, then see ir lhe second letter is 
the same as lhe second 10 last, and keep going until you reach the middle. 
Here, we'll take the second approach. 111ere arc many wa),s or expressing this 
idea in code depending on how we represent the word and how we keep track or 
how far we have come with the comparison or characters. We'll write a little pro-
gram that tests whether words arc palindromes in a rew different ways just to see 
how different language features affect the way the code looks and works. 
18.6.1 Palindromes using string 
First, we try a version using the standard libraty string with int indices to keep 
track of how rar we have come with Ollr comparison: 
bool is_palindrome(const string& s) 
{ 
int first = 0; 
1/ index of firsl leiter 
637 

CHAPTER 18 • VECTORS AND AR RAYS 
int last = s.lengthO- l; 
I/inde)( of last leller 
while (first < last) ( 
II we haven't reached the middle 
if (s[first]!=s[last]) return false; 
) 
++first; 
--last; 
return true; 
II move forward 
II move backward 
We return true if we reach the middle without finding a difference. We suggest 
that you look at this code to convince yourself that it is correct when there arc no 
letters in the string, just one letter in the string, an even number of letters in the 
string, and an odd number of leIters in the string. Of course, we should not just 
rely on logic to see that our code is conecl. We should also test. We can exercise 
is_palindromeO like this: 
int mainO 
{ 
string s; 
while (cin»s) ( 
cout «s«
" is"; 
) 
if (!is_palindrome(s)) cout «
" not"; 
cout «" a palindrome\n "; 
Basically, the reason we are using a string is that "strings arc good for dealing 
with words:' It is simple to read a whitespace·separated word into a string, and a 
string knows its size. Had we wanted to test is_palindromeO with strings contain· 
ing whitespace, we could have read using getlineO (§11.5). 111al would have 
shown allllLl and as 4fjl Stl tO be palindromes. 
18.6.2 Palindromes using arrays 
What if we didn't have strings (or vectors), so that we had to use an array to 
store the characters? Let's sec: 
bool is_palindrome(const char sU, int n) 
{ 
/I s points to the first character of an array of n characters 
int first = 0; 
int last = n-1; 
II index of first letter 
II index of last letter 

18 .6 
EXAMPLES: PALINDROM E 
while (first < last) ( 
/I we haven't reached the middle 
if (slfirst)l=s[lasl» return false; 
++firsti 
--last; 
return Irue; 
II move for.vard 
1/ move backward 
To exercise is_palindromeO, we first have to get characters read into the array. 
One way to do I.hat safely (i.e., without risk of overflowing the array) is like this: 
istream& read_word(istream& is. char· buffer, int max) 
II read at most ma)(- l characters from is into buffer 
( 
) 
is.width(max); 
is» buffer; 
return is; 
II read al moSI max- l characters in the ne)(1 » 
/I read whitespace-Ierminated word, 
/I add zero after the last character read inlO p 
Setting the istream's width appropriately prevents buffer overflow for the next » 
operation. Unfortunately, it also means that \\'e don't know if the read terminated 
by whites pace or by the buffer being full (so that we need to read more charac-
ters). Also, who remembers the details of the behavior of widthO for input? TIle 
standard library string and vector are really better as input buffers because they 
expand to fit the amount of input. The terminating 0 character is needed because 
most popular operations on arrays of characters (e style strings) assume 0 termi-
nation. Using read_wordO we can write 
int mainO 
( 
canst int max = 128; 
char s[max]; 
while (read_word(cin,s,max)) { 
cout « s«" is"; 
) 
if (! is_palindrome(s,strlen(s))) cout « " nol"; 
cout «" a palindrome\n"; 
TIle s(rlen(s) call rctums the number of characters in the array after the call of read_ 
wordO, and cout<<s outputs the characters in the array up to the tenninating o. 
.,. 

CH APTE R 18 • VECTORS AND ARRAY S 
We consider this "array solution" significantly messier than the "string solu-
tion," and it gets much worse if we try to seriously deal with the possibility of 
long strings. See exercise 10. 
18.6.3 Palindromes using pointers 
Instead of using indices to identify characters, we could use pointers: 
bool is_palindrome(const char· first, canst char· last) 
II first points to the first leller, last to the last leller 
{ 
while (first < last) ( 
II we haven't reached the middle 
if (Ofirsl!=olast) return false; 
++first; 
II move forward 
--last; 
/I move backward 
return true; 
) 
Note that we can actually increment and decremem pointers. Increment makes a 
pointer point to the next clement of an array and decrement makes a pointer 
point to the previous clement. If the array doesn't have such a next clement or 
previous clement, you have a serious uncaught out-of-range error. That's another 
problem with pointers. 
We call tlus is_palindromeO like this: 
int mainO 
{ 
) 
canst int max = 128; 
char slmax1; 
while (read_word(cin,s,max» ( 
coul « s«" is"; 
) 
if (! is_palindrome(&sIOl,&s[slrlen(s)-l») coul «" nOI"; 
coul « " a palindrome\n"; 
Just for fUll, we rewTite is_palindrome() like this: 
bool is_palindrome(const char· first, canst char· last) 
/I first points to the first leller, last to the last leiter 
{ 

( HAPTE R 18 ORl ll 
if (lirsklasl) { 
if (*firsl!=*last) return false; 
retu rn is_pali nd rom e( ++fi rsl ,--Iasl); 
) 
return true; 
) 
111is code becomes obvious when we rephrase the definition of palilldrome: a word 
is a Ih'llindrome if the first and the last characters arc the same and if the substring 
you gel by removing the first and the last characters is a palindrome. 
yI Drill 
In Ulls chapter, we have two drills: one to exercise arrays and one to exercise vectors 
in roughly u1e same maimer. Do both and compare ule efTon involved in each. 
Array drill: 
I. Define a global int array ga often ints initialized to 1, 2, 4, 8, 16, etc. 
2. Define a function fO taking an int array argument and an int argument 
indicating the number of elements in the array. 
3. In fO : 
a. Define a local int array la of ten inls. 
b. Copy the values from ga into la. 
C. Print OUl the elements of la. 
d. Define a pointer p to int and initialize it with an array allocated on the 
free store with the same number of clements as the argument array. 
e. Copy the values from the argument array into the free·store array. 
f. Print OUl the clements of the free,slore array. 
g. Deallocate the free·store array. 
4. In main(): 
a. Call fO with ga as its argument. 
h. Define an array aa with ten elements, and initialize it with ule first ten 
factorial values (1, 2·1, 3·2·1, 4*3·2·1, etc.). 
C. Call fO with aa as its argument. 
Standard library vector drill: 
I. Define a global vector<inl> gv; initialize it with ten ints, 1, 2, 4, 8, 16. etc. 
2. Define a function fO taking a vector<inl> argument. 
3. In fO: 
a. Define a local vector<inl> Iv with ule same number of clements as the 
argument vector. 
641 

642 
CHAPTER 1 B • VECTORS AND ARRAYS 
h. Copy the values from gv intO Iv. 
c. Print out lhe elements of Iv. 
d. Defmc a local veclor<int> 1\12; initialize it to be a copy of the argu-
ment array. 
e. Print Ollt the clements of Iv2. 
4. In main() : 
a. Gall fO with gv as its argumellt. 
b. Define a vector<int> vv, and initialize it with the first ten factorial val-
ues (I , 2*1, 3*2*1 , 4*3"'2*1, etc.). 
c. Call fO with vv as its argument. 
Review 
1. What does "Caveat cmptorl" mean? 
2. What is the default meaning of copying for class objects? 
3. When is the default meaning of copying of class objects appropriate? 
When is it inappropriate? 
4. What is a copy constructor? 
5. ""hat is a copy assignment? 
6. What is the difference between copy assignment and copy initialization? 
7. What is shallow copy? What is deep copy? 
8. How does the copy of a vector compare to its source? 
9. What are the five "essential operations" for a class? 
10. W hat is an explicit constructor? W here would you prefer one over the 
(default) alternative? 
11. W1tat operations may be invoked implicitly for a class object? 
12. What is an array? 
13. How do you copy an array? 
14. How do you initialize an array? 
15. When should you prefer a pointer argumem over a reference argument? 
Why? 
16. What is a C·style string? 
17. What is a palindrome? 
Terms 
array 
alTay initialization 
copy asslgrunem 
copy constructor 
deep copy 
default constructor 
essential operations 
explicit consnuClor 
palindrome 
shallow copy 

CHAPTE R 18 EXERCISES 
Exercises 
1. Write a function, char· strdup(const char·), that copies a C-style string 
into memory it allocates on the free store. Do not usc any sta.ndard library 
functions. Do not use subscripting; usc the dereference operator · instead. 
2. Write a function, char· findx(const char· s, const char· xl, that finds the 
frrst occurrence of tile C·style string x in s. Do not lise any standard library 
functions. Do not lise subscripting; use tile dereference operator · instead. 
3. Write a function, int slrcmp(const char· s1, const char· s2), that com-
pares C-style strings. Let it return a negative number if s1 is lexicograph-
ically before 52, zero if s1 equals s2, and a positive number if s1 is 
lexicographically after s2. Do not usc any standard library functions. Do 
not use subscripting; usc the dereference operator · instead. 
4. Consider what happens if you give strdupO, findxO, and slrcmpO an ar-
gument that is not a C·style string. Try it! First figure out how to get a 
char· that docsn't point to a zero-terminated array of characters and then 
use it (never do this in real - non-experimental - code; it can create 
havoc). Try with free-store-allocated and stack-allocated "fake C-style 
strings." If the results still look reasonable, turn ofT debug mode. Re-
design and re-implement those three functions so that tlley take anotller 
argument giving the ma.ximum number of elements allowed in argument 
strings. 111el1, test that with correct C-style strings and "bad" strings. 
5_ Write a function, string caCdot(const slring& s1, consl slring& s2), that con-
catenates twO strings witll a dot in between. For example, cat_dot{"Niels", 
"Bohr") will retum a string containing Niels.8ohr. 
6. Modify cat_dotO from the previous exercise to take a string to be lIsed as 
the separator (rather than dot) as its third argument. 
7. Write versions oCthe caCdot()s from the previous exercises to take C-style 
strings as arguments and rctUl1l a free-store-allocated C-style string as tile 
result. Do not use standard library functions or typcs in the implementa-
tion. Test these functions with several strings. Be sure to free (using delele) 
all tile memory you allocated from free Store (using new). Compare the ef-
fon involved in tltis exercise with the effon involved for exercises 5 and 6. 
8. Rewrite all the functions in §18.6 to use the approach of making a back-
ward copy of the string and then comparing; for example, lake "home", 
generate "emoh", and compare those twO strings to see that they arc dif-
ferent, so home isn't a palindrome. 
9. Consider tile memory layout in §173. Write a program that tells tllC order 
in which static storage, tile stack, and the free store arc laid out in mem-
ory. In which direction does the stack grow: upward toward higher ad-
dresses or downward toward lower addresses? In an array on free store, 
are clements with higher indices allocated at higher or lower addresses? 
643 

644 
CHAPTER 18 • VECTORS AND ARRAYS 
10. Look at the "array solution" to the palindrome problem in §lB.6.2. FIX it 
to deal with long strings by (a) reporting if an input string was tOO long 
and (b) allowing an arbitrarily long string. Comment on the complexity 
of the tWO versions. 
11. Look up (e.g., on the web) skiJ) list and implement that kind oflist. 111is is 
not an easy exercise. 
12. Implement a version of the game "Hulll the Wumpus." "Hulll the WUIll-
pus" (or just "Wump") is a simple (non·graphical) compliler game origi-
nally invented by Gregory Yob. The basic premise is that a rather smelly 
monster lives in a dark cave consisting of connected rooms. Your job is to 
slay the wumpus using bow and arrow. In addition to the wumpus, the 
cave has two hazards: bottomless pits and giant bats. If you elller a room 
with a bottomless pit, it's the end of the game for you. If you enter a 
room with a bat, the bat picks you up and drops you into another roolll. 
If you enter the room with the wumpus or he enters yours, he eats you. 
When you emer a room you will be told if a hazard is nearby: 
"I smell the \'rompus": It's in an adjoining roolll. 
"I feel a breeze": One of the adjoining rooms is a bottomless pit. 
"I hear a bat": A giant bat is in an adjoining room. 
For your convenience, rooms arc numbered. Every room is con-
nected by tUlUleiS to three other rooms. YV"hen entering a room, you are 
tOld something like ';You are in room 12; there are mnnds to roolllS 1, 
13, and 4; move or shoot?" Possible answers arc m13 ("Move to room 
13") and s13-4-3 ("Shoot an arrow through rooms 13, 4, and 3"). The 
range of an arrow is three rooms. At the start of the game, yOll have five 
arrows. The snag about shooling is that it wakes up the wumpus and he 
moves to a room adjoining the one he was in - that could be your room. 
Probably the trickiest part of the exercise is to make the c.we by select-
ing which rooms arc connected with which other rooms. You'll probably 
want to use a random number generator (e.g., randintO from sld_lib_fadl-
Hies.h) to make different runs of the program lise different caves and to 
move around the batS and the wumpus. Hint: Be sure to have a way to 
produce a debug Output of the state of the cave. 
Postscript 
The standard library vector is built from lower-level memory management facili-
ties, such as pointers and arrays, and its primary role is to help liS avoid the com-
plexities of those facilities. YV"henever we design a class, we must consider 
initialization, copying, and destruction. 

.L 
r 19 
Vector, Templates, and 
Exceptions 
"Success is never fmal." 
-Winston Churchill 
T
his chapter completes the design and implementation of 
the most common and most useful STL container: vector. 
Here, we show how to implement comainers \vhere the number 
of elements can vary, how to specify containers where the cle-
ment type is a parameter, and how to deal with range errors. As 
usual, the techniques used are generally applicable, rather than 
simply restricted to the implementation of vector, or even to the 
implementation of containers. Basically, we show how to deal 
safely with varying amoums of data of a variery of types. In ad-
dition, we add a few doses of realism as design lessons. The tech-
niques rely on templates and exceptions, so we show how to 
dermc templates and give the basic techniques for resource man-
agcmem thal are the keys LO good usc of exceplions. 
64. 

CHAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
19.1 The problems 
19.2 Changing size 
19.2.1 Representation 
19.2.2 reserve and capacity 
19.2.3 resize 
19.2.4 push_back 
19.2.5 A.ssignment 
19.2.6 Our vector so far 
19.3 Templates 
19.3.1 Types as template parameters 
19.3.2 Generic programming 
19.3.3 Containers and inheritance 
' 9.3.4 Integers as template parameters 
19.3.5 Template argument deduction 
19.3.6 Generalizing vector 
19.1 The problems 
19.4 Range checking and exceptions 
19.4.1 An aside: design considerations 
19.4.2 A confession: macros 
19.5 Resources and exceptions 
19.5.1 Potential resource management 
problems 
19.5.2 Resource acquisition is 
initialization 
19.5.3 Guarantees 
19.5.4 auto_ph 
19.5.5 RAil for vector 
At the end of Chapter 18, our vector reached the point where we can 
Create vectors of double'precision floating·point elements (objects of 
class vector) with whatever number of elements we want 
Copy our vectors using assigmnent and initialization 
Rely on vectors to correctly release their memory when they go Out of 
scope 
Access vector elements using the conventional subscript notation (on 
both the right-hand side and the left·hand side of an assigmnent) 
111at's all good and useful, but to reach the level of sophistication we expect 
(based on experience with the standard library vector), we need to address three 
more concerns: 
How do we change the size of a vector (change the number of clements)? 
How do we catch and report Out-or-range vector element acccss? 
How do we specify the element type or a vector as an argument? 
For example, how do we define vector, so that this is legal: 
vecfor<double> vd: 
double d; 
while(cin» d) vd.push_back(d); 
vector<char> vc(1oo); 
II elemenls of Iype double 
II grow vd to hold all the elements 
II elements of type char 

19.1 
THE PROBLEMS 
int n; 
cin»n; 
vc.resize(n); 
1/ make vc have n elements 
Obviously, it is nice and useful to have vectors that allow this, but why is it im-
portant from a programming poilll of view? What makes it interesting to some-
one collecting useful progranuning techniques for future use? We arc using two 
kinds of nexibility. We have a single elllil"Y, the vector, for which we can vary two 
things: 
TIle number of elements 
TIle type of elements 
1110se kinds of variability arc useful in rather fu ndamental ways. We always col-
lect data. Looking around my desk, I see piles of bank statements, credit card 
bills, and phone bills. Each of those is basically a list of lines of information of 
various types: strings ofleuers and numeric values. In front of me lies a phone; it 
keeps lists of phone numbers and names. In the bookcases across the room, there 
is shelf after shelf of books. Our programs tend to be similar: we have containers 
of clements of various types. We have many dilTerem kinds of containers (vector 
is just the most widely useful), and they contain infonnatioll such as phone num· 
bers, names, transaction amounts, and documents. Essentially all the examples 
from my desk and my room originated in some computer program or anOlher. 
111e obvious exception is the phone: it is a computer, and when I look at the 
numbers on it I'm looking at the output of a program JUSt like the ones we're 
writing. In fact, those numbers may very well be stored in a veclor<Number>. 
Obviollsly, not. all containers have the same number of elements. Could we 
live with a vector that had its size fL'tcd by its initial definition; that is, could we 
write our code without push_backO, resizeO, and equivalclll operations? Sure 
we could, but that would put an UlU1ecessary burden on the programmer: the 
basic trick for living with fLxed-size containers is to move the clements to a bigger 
container when the number of clements grows tOO large for the initial size. For 
example, we could read into a vector without. ever changing the size of a vector 
like this: 
1/ read elements into a vector without using push_back: 
veclor<double>· p = new veclor<double>(10); 
inl n = 0; 
1/ number of elements 
double d; 
while(cin » d) { 
if (n==p->size()) ( 
vector<double>· q = new vector<double>(p->sizeW2); 
copy(p->begin(), p->end(), q->begin()); 
647 

... 
} 
} 
( HAPTER 19 • VE CTOR , TEMPLATES, AND EXC EPTIONS 
delete p; 
p = q; 
(·p)[n] = di 
++n; 
'1131'5 not prell)'. Are you convinced thai we gOI it right? How can you be sure? 
NoLC how we suddenly started to use poimers and explicit melllory management. 
What we did was to imitate the style of programming we have to usc when we 
are "close to the machine," using only the basic memory management techniques 
dealing with ftxed-size objects (arrays; see § 18.5). One of the reasons to usc con-
tainers, such as vector, is to do better than that; that is, we want vector to handle 
such size changes internally to save us - its users - the bother and the chance to 
make mistakes. In other words, we prefer containers that can grow to hold the 
exact number of elemenlS we happen to need. For example: 
veclor<double> d; 
double dj 
while(cin>>d) vd.push_back(dlj 
Are such changes of size common? If they are not, facilities for changing size are 
simply minor conveniences. However, such size changes are very commoll. The 
most obvious example is reading an unknown number of values from input. 
Olher examples arc collecting a sel of results from a search (we don't in advance 
know how many results there will be) and removing clements from a collection 
one by one. Thus, the question is not whether we should handle sile changes for 
containers, but how. 
"Why do we bother with changing sizes at all? WIlY not "just alloc.,te enough 
space and be done with it I"? That appears to be the simplest and most efficient 
strategy. H owever, it is that only if we can reliably allocate enough space without 
allocating grossly too much space - and we can't. People who try that tend to 
have to rewrite code (if they carefully and systematically checked for overflows) 
and deal with disasters (if they were careless with their checking). 
Obviously, not all vectors have the same type of clements. \rVe need vectors of 
doubles, temperature readings, records (of various kinds), strings, operations, 
CUI buttons, shapes, dates, pointers to windows, etc. The possibilities arc endless. 
11lere arc many kinds of containers. This is an important point, and because 
it has important implications it should be not be accepted without thought. 'Why 
can't all containers be vectors? If we could make do with a single kind of can· 
tainer (e.g., vector), we could dispense with aIllhe concerns about how to pro-
gram it and just make it pan of me language. If we could make do with a single 
kind of container, we needn't bother learning about different kinds of cOlllainers; 
we'd just use vector all the lime. 

19. 2 
CHANG ING SIZE 
Well, data structures are the key to most significant applications. There are 
many thick and useful books abom how to organize data, and much of that in-
formation could be described as answers to the question "How do 1 best store my 
data?" So, the answer is that we need many difTerem kinds of containers, but it is 
too large a subject to adequately address here. However, we have already used 
vectors and strings (a siring is a container of characters) extensively. In the next 
chapters, we will see lists, maps (a map is a tree of pairs of values), and matrices. 
Because we need Illany difTerent containers, the language fcatures and program-
ming techniques needed to build and use containers arc widely useful. If fact, t.he 
techniques we use to store and access data are among the most fundamental and 
most useful for all nontrivial forms of computing. 
At the most basic memory level, all objects arc of a fl ...... ed size and no types 
exist. What we do here is to introduce language facilities and programming tech· 
niques that allow us to provide containers of objects of various types for which 
we can vary the nUlllber of elements. 111is gives us a fundamentally useful de-
gree of nexibility and conveniencc. 
19.2 Changing size 
\.vhat facilities for changing size docs the standard library vector a fTer? It pro-
vides three simple operations. Given 
vector<double> v(n)j /I v.sizeO==n 
we can change its size in three ways: 
v.resile(10)i 
v = v2 j 
/I v now has 10 elements 
II add an elemenl wilh Ihe value 7 to the end of v 
/I v.sizeO increases by 1 
/I assign another vector; v is now a copy of v2 
/I v.sizeO now equals v2.sizcO 
TIle standard library vector offers more operations that can change a vector's 
size, stich as eraseO and insert() (§B.4.7), but here we will just see how we ean 
implement those three operations for our vector. 
19.2.1 Representation 
In §19.1 , we show the simplest strategy for changing size: just allocate space for 
the new number of elements and copy the old elemellts into the new space. How-
ever, if you resize often, that's inefficient. In practice, if we change the size once, 
we usually do so many times. In particular, we rarely see JUSt one push_backO. 
649 

650 
CHAPTER 19 • VECTOR, TEMPLATES, AND EXCE PTIO NS 
So, we can optimize our programs by anticipating such changes in size. In fact, all 
vector implementations keep track of both the number of elements and an 
amount of "free spacen reserved for "future expansion." For example: 
class vector { 
/I number of elements 
/I address of fi rst element 
int SZ; 
double elem; 
inl space; 
/I number of elements plus "free space"rSIOIS" 
II for new elements (" the current allocation") 
public: 
1/ ... 
} ; 
We can represent this graphically like this: 
sz: 
elem: 
space: 
. -_. -_ ... ------'. 
Free space 
0: 
, 5%: 
(uninitialized) 
::i-{;::O ........... , .... "1 ..................... r-.. ! 
~ 
Ele.ments --------•• - •••••••••••••• ------.----
-.~r -­
(initialized) 
' .. 
'. ---. -. ------..... ---_. -_. _. -_ .... 
.. ' 
.' -' 
Since we count elements starting with 0, we represent sz (the number of cle-
ments) as referring La one beyond the last clement and space as referring to one 
beyond the last allocated slot. The pointers shown are really elem+sz and 
elem+space. 
VVhen a vector is first constmcted, space is 0: 
sz: 
elem: 
space: 
---------------. -. 
-.... -._-_ .. _------
We don't Start allocating eXLra slots until we begin changing the number of c1e-
mellls. Typically, space==sz, so there is no memory overhead unless we use 
push_backO. 
The default constmctor (creating a vector with no clements) sets all three 
members to 0: 
vector: :vectorO :sz(O), elem(O), space(O) { } 

19.2 
CHANGING SIZE 
111at gives 
_____ ._0 ___ 0_ .. _ ... 
sz: 
elem: 
space: §. 
· 
.. L . 
--- ---- -----............ -.. ..; 
: 
" "1"--
.. 
------_. ----.-
~nlm one-beyond-the-end clement is completely imaginary. The default constructor 
docs no free-store alloc.'luon and occupies minimal storage (but see exercise 16)_ 
Please note that Ollr vector illustrates techniques that can be used to imple-
ment a standard vector (and other data structures), but a fair amount of freedom 
is given to standard library implementations so that std: :vector on your system 
may usc different techniques. 
19.2.2 reserve and capacity 
"l1le most fundamental operation when we change sizes (that is, when we change 
the number of clements) is vector: :reserve()_ That's the operation we usc to add 
space for new elements: 
void vector: :reserve(int newalloc) 
{ 
) 
if (newalloc<=space) return ; 
double p = new double[newallocli 
for (int i=Oi kSZi ++i) plil = elem[i]i 
delete[J elemi 
elem = Pi 
space = newalloc; 
II never decrease allocalion 
II allocate new space 
1/ copy old elements 
1/ deallocate old space 
Note that we don't initialize the clements of the reserved space. After all, we arc 
just reserving space; using that space for clements is the job of push_backO and 
resizeO. 
Obviously the amount of free space available in a vector can be of interest to 
a user, so we (like the standard) provide a member function for obtaining thm 
information: 
int vector: :capacityO const { return space; } 
'1113t is, ror a vector callcd v, v.capacityO-v.sizeO is the number of clements we 
could push_backO to v without causing reallocation. 
651 

.52 
(HAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIO NS 
19.2.3 resize 
Given reserveO, implementing resize() for ollr vector is fairly simple. 'A'e have to 
handle several cases: 
TIle new size is larger than the old allocation. 
TIle new size is larger than the old size, but smaller than or equal to the 
old allocation. 
The new size is equaJ to the old size. 
The new size is smaller than the old size. 
Let's sec what we get: 
void vector:: resize(int newsize) 
{ 
) 
/I make (he vector have newsize elements 
/I initialize each new element with the default value 0.0 
reserve(newsize); 
ror (int i=SZi i<newsize; •• i) elem[i] = 0; 
5Z = newsize; 
/I initialize new elements 
We let reserveO do the hard work of dealing with memory. The loop initializes 
new clements (if there are any). 
We didn't explicitly deal with any cases here, but you can verify lhat all are 
handled correcliy nevenheless. 
TRY THI S 
What cases do we need to consider (and test) if we want to convince our-
selves that this resizeO is correct? How about newsize == o? How about 
newsize ==-77? 
19.2.4 push_back 
When we first think of it, push_backO may appear complicated to implement, 
but given reserveO it is quile simple: 
void vector: :push_back(double d) 
) 
1/ increase vector size by one; initialize the new clement with d 
if (space==O) reserve(8); 
else if (52==space) reserve(2*space); 
elemlszJ = d; 
/I add d at end 
1/ starr with space for 8 clements 
1/ get more space 
++52; 
/I increase the size (sz is the number of clements) 

19.2 
CHANGI NG SIZE 
In other words, if we have no spare space, we double me size of lhe allocation. In 
practice that turns out to be a very good choice for the vast majority of uses of 
vector, and that's the strategy used by most implementations of lhe standard Ii· 
brary vector. 
19.2.5 Assignment 
We could have defined vector assignment in several different ways. For example, 
we could have decided mat assignment was legal only if the two vectors involved 
had the same number of eiemellls. However, in §18.2.2 we decided that vector 
assigmllelll should have the most general and arguably the most obvious mean-
ing: after assignment v1 =v2, the vector v1 is a copy of v2. Consider: 
V2: 
Obviously, we need to copy the clements, but what about lhe spare space? Do we 
"copy- the "free space" at the end? We don't: me new vector \-vill get a copy of 
the clements, but since we have no idea how that new vector is going to be used, 
we don't bother with extra space at the end: 
V2: 
111e simplest implementation of that is: 
Allocate memory for a copy. 
Copy the clements. 
Delete the old allocation. 
Set the sz, elem, and space to the new values. 

654 
CHAPTER 19 • VECTOR, TEMPLATES, AND EX CEPTION S 
Like this: 
vector& vector: :operalor=(const vector& a) 
{ 
) 
II like copy constructor, but we must deal with old elements 
double- p = new double[a.sz]; 
for (int i = 0; ka.sz; ++i) p[i] = a.eJem[i]; 
delete[J elem; 
space = 5Z = a.5Z; 
clem = p; 
return "'this; 
II allocate new space 
/I copy clements 
1/ deallocate old space 
1/ sel new size 
II set new elements 
/I return self-reference 
By convention, an assignment operator returns a reference to the object assigned 
to. The notation for that is ·this, which is explained in §17. 1O. 
This implementation is correct, but when we look at it a bit we realize that 
we do a lot of redundant allocation and dcallocatiol1. \¥hat if the vedor we as-
sign to has morc elements man the one we assign? \¥hal if the vector we assign 
to has the same number of elements as the vector we assign? In many applica-
tions, that last case is very common. In either case, we can just copy the clements 
into space already available in the target vector: 
veclor& vector: :operator=(consl vector& a) 
{ 
) 
if (this==&a) return · this; 
/I self-assignment, no work needed 
if (a.u:<=space) { 
/I enough space, no need for ne\v allocation 
for (int i = 0; ka.sz; ++i) elem[i] = a.elem[i]; 
/I copy elements 
sz = a,sz; 
return -this; 
) 
double* p = new double[a.szli 
for (int i = 0; ka.sz; ++i) p[il = a.elem[il; 
deletell elem; 
space = sz = a.sz; 
elem = Pi 
return ·this; 
/I allocate new space 
/I copy elements 
/I deallocate old space 
/I set new size 
/I set new elements 
/I return a self-reference 
Here, we first test for self-reference (e.g., v=v); in that case, we just do nOlhing. 
~fba t test is logically redundant but sometimes a significant optimization. It docs, 

19.2 
CHANG ING SIZE 
however, show a common usc of the this poimcr checking if t.he argument a is the 
same object as the object for which a member function (here, operalor=O) was 
called. Please convince yourself that this code actually works if we remove the 
Ihis==&a line. The a.sz<=space is also just an optimization. Please convince 
yourself t.hat this code actually works if we remove the a.sz<=space case. 
19.2.6 Our vector so far 
Now we have ill1 almost real vector of doubles: 
II an almost rcal vector of doubles: 
class vector { 
/, 
' / 
invariant: 
for O<=n<sz elemlnl is clement n 
sz<=space; 
if SZ<slhlce there is space for (space- sz) doubles after elemlsz- l1 
inl SZ; 
double· elem; 
inl space; 
/I the size 
/I pointer to the elements (or 0 ) 
/I number of elements plus number of free slots 
public: 
) ; 
veclorO : sz(O), elem(O), space(O) { } 
veclor(int s) :sz(s), elem(new double[s]), space(s) 
{ 
for (inl i=O; i<sz; Hi) elemlil=O; 
) 
veclor(consl vector&); 
veclor& operalor=(const veclor&); 
- veclor() ( delele[] elem; ) 
/I elements are initialized 
/I copy constructor 
/I copy assignment 
/I destructor 
double& operator[ ](int n) { relurn elem[n); } 
/I access 
const double& operator{l(int n) const ( return elem[n); } 
int sizeO const ( return sz; ) 
int capadtyO const ( return space; ) 
void resize(int newsize); 
void push_back(double d); 
void reserve(int newalloc); 
II growth 
655 

656 
(HA PTE R 19 • VECTO R, TEMPLATES, AND EXCEPTIONS 
Note how it has the: essential operations (§l S.3): constructor, defauh conStmctor, 
copy operations, destructor. It has an operation for accessing data (subscripting: 
II) and for providing information about that data (si:teO and capacilyO), and for 
controlling growth (resize(), push_backO, and reserveO). 
19.3 Templates 
Blit we don', just want vectors of doubles; we want to freely specify the clement 
type for OUf veclars. For example: 
veclor<double> 
veclor<inl> 
veclor<Month> 
vector<Window"> 
vector< vector<Record> > 
vector<char> 
II vector o( pointers to Windows 
/I vector of vectors of Records 
To do that, we must sec how to define templates. We have used templates from 
day one, bUll/mil now we haven't had a need to define one. The standard library 
provides what we have needed so far, but we muslll't believe in magic, so we 
need to examine how the designers and implememers of the standard library pro-
vided facilities sllch as the vedor type and the sortO function (§2 1.1, §B.5.4). 
This is not just of theoretical interest, because - as usual - the tools and tech-
niques lIsed for the standard library are among the most useful for our own code. 
For example, in C hapters 21 and 22, we show how templates can be used for im-
plementing the standard library containers and algorithms. In Chapter 24, we 
show how to design matrices for scientific computation. 
Basically, a template is a mechanism that allows a progranuner to use types as 
parameters for a class or a runn ion. ~rn e compiler then generates a specific class 
or function when we later provide specific types as arguments. 
19.3.1 Types as template parameters 
''''e wam to make the clement type a parameter to vector. So we take our veclor 
and replace double with T where T is a parameter that can be given "values" such 
as double, inl, Siring, veclor<Record>, and Window· . TIle C++ notation ror in-
troducing a type parameter T is lemplale<class T> prefix, meaning "ror all types 
T." For c.xample: 
/Ian almost real vector ofTs: 
template<class T> class veClor ( 
inl51:; 
/I the size 
/I read "for all types T ~ (just like in math) 

19 .3 
TEMPLATES 
Pelem; 
inl space; 
public: 
/I a pointer 10 Ihe elements 
/1 size+free_space 
vectorO : sz(O), elem(O), space(O) { } 
vector(int s); 
vector(const vector&): 
vector& operator=(const vector&); 
.... vectorO {deletell elem; } 
/I copy constructor 
/I copy assignment 
/I destructor 
T& operator{J(int n) { return elem[n]; } 
/I access; return reference 
const T& operator[J(inl n) const { return elem[n}: } 
); 
int size() const ( return sz; ) 
int capacityO const { relurn space: } 
void resize(inl newsize); 
void push_back(consl T& d): 
void reserve(inl newalloc); 
/I the current size 
/I growth 
lnat's just our vector of doubles from § 19.2.6 with double replaced by the tem-
plate parameter T. Wc can usc this class template vector Like this: 
vector<double> vd: 
veclor<inl> vi: 
vector<double> vpd: 
/I T is double 
/lTisint 
/I T is double-
vector< vector<int> > vvi: /I T is vector<int>, in which T is int 
One way of thinking about what a compiler does when we lise a template is that 
it generates the class with the actual type (the template argument) in place of the 
template parameter. For example, when the compiler sees vector<char> in the 
code, it (somewhere) generates sOlllelhing like this: 
class vector_char ( 
int sz: 
/I the size 
char· elem: /I a pointer to the elements 
/I size+free_space 
int space: 
public: 
vector_char(); 
vector_char(int s): 
657 

658 
) ; 
(HAI'TER 19 • VECTO R, TEMPL ATES, AND EXCEPT IONS 
vector_char(const vectol_char&); 
II copy constructor 
vectof_char& operator=(const vector_char &); /I copy assignment 
II destructor 
char& operatorll (int n); 
II access: return reference 
const char& operator[J (int n) const; 
int sizeO const; 
int capacityO const; 
void resize(int newsize); 
void push_back{const char& d); 
void reserve(int newallac); 
II the current size 
1/ growth 
For vector<double>, the compiler generates roughly the vector (of double) from 
§ 19.2.6 (using a suitable internal name meaning vector<double» . 
Sometimes, we call a class template a type generator. The process of generating 
types (classes) from a class temptate given template arguments is called Jpea"aliuz-
(ioll or template install/ill/wlI. For example, vector<char> and vector<Poly_line· > are 
said to be specializations or vector. In simple cases, such as our vector, instantia-
tion is a pretty simple process. In the most general and advanced cases, template 
instantiation is horrendously complicated. Fortunately r01" the user or templates, 
that complexity is in the domain or the compiler writer, not the template user. 
Template instantiation (generation or template specializations) takes place at com-
pile lime or link time, not at lUn time. 
Naturally, we can usc member functions of such a class template. For example: 
void fct(vector<string>& v) 
( 
) 
inl n = v.sizeO; 
v.push_back("Norah"); 
II . 
\-\Thcn such a member function of a class template is used, the compiler generates the 
appropriate function. For ex.'l.Illple, when the compiler sees v.push_back("Norah"), it 
generates a function 
void vector<slring>:: push_back(const slring& d) {/ • . .. • /} 

19.3 
TEMPLATES 
from the template definition 
templale<c1ass T> void vector<T>: :push_back(const T& d) {/- ... -/ }; 
TImt way, there is a function for v.push_back("Norah") to call. 1.11 other words, 
when you need a function for a given argument type, the compiler will write it 
for you based on its template. 
Instead of writing template<class T>, you can write template<typename T>. 
TIle two constlUCts mean exactly the same thing, but some prefer typename "be· 
cause it is clearer" and "because nobody gets confused by typename thinking 
that you can't use a built-in type, such as int, as a template argument." We are of 
the opinion that class already means type, so it makes no difference. Also, class is 
shorter. 
19.3.2 Generic programming 
Templates arc the basis for generic programming in C++. In fact, the simplest 
definition of "generic programming" in C++ is "using templates." TImt definition 
is a bit tOO simpleminded, though. We should not define fundamental program-
ming conccpts in terms of programming language features. Programming lan-
guage features exist to support programming techniques - not the other way 
around. As with most popular notions, there are many definitions of "generic 
programming." We think that the most useful simple definition is 
Gt7lCic programming: Writing code that works with a variety of types pre-
sented as arguments, as long as those argument types meet specific syntactic 
and semantic requirements. 
For example, the clements of a vector must be of a type that we can copy (by copy 
constrllction and copy assiglilllent), and in Chapters 20 and 21 we will see teill' 
plates that require arithmetic operations on their arguments. When what we para· 
mctelizc is a class, we get a daJJ lemplale, what is often called a param~/eriud fJfx or a 
JxmlJllel~7ized cla.JJ. When what we parameterize is a function, we get a jill/clio" lem-
plale, what is often called a parameterized jimclioll and sometimes also called an algo-
rilll1ll. TIlliS, generic progranuning is sometimes referred to as "algorithm-oriented 
programming" ; the focus of the design is more tlle algoritluns than the data types 
they use. 
Since the notion of parameterized types is so central to programming, let's 
explore the somewhat bewildering tenllinology a bit further. ~nl at way we have a 
chance not to get too confused when we meet such notions in other contexts. 
~fbis form of generic programming relying on explicit tcmplate parameters is 
often c.'llled paralfl£tric pol),morphism. In contrast, the polymorphism you get from 
using class hierarchies and virtual functions is called ad hoc po/prwrp/tiJrn and that style 
65. 

660 
CHAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
of programming is called objed-orinl1td programming (§14.3-4). TIle rcason that both 
styles of programming are called polymmphum is that each style relies on the pro-
granuner to presclll many versions of a concept by a single intClfacc. EVI)"nl)lpllism is 
Greek for "many shapes:' referring to the many differe1ll types you can manipUlate 
Lhrough a conunon interface. In the Shape examples from Chapters 16- 19 we liter· 
ally accessed many shapes (such as Text, Circle, and Polygon) through the interface 
defined by Shape. \¥hen we use vecfors, we usc many vecfors (such as vector<inl>, 
vedor<double>, and vector<Shape» through the interface defined by the veclor 
template. 
There are several differences between object-oriented programming (using 
class hierarchies and virtual functions) and generic programming (using telll-
plates). TIle most obvious is that the choice of function invoked when you usc 
generic programming is determined by the compiler at compile tinIe, whereas for 
object-oriented programming, it is not detennined until nm time. For example: 
v.push_back(x); 
s.draw(); 
/I put J( into the vector v 
/I draw the shape s 
For v.push_back(x) the compiler will determine the element type for v and usc 
the appropriate push_backO, but for s.draw() the compiler will indirectly call 
some drawO function (using s's vtbl; see § 14.3.1). llis gives object-Oliemed pro-
granuning a degree of freedom that generic programming lacks, but leaves run-
of-the-mill generic programming more regular, easier to understand, and betler 
performing (hence the "ad hoc" and "parametric" labels). 
To sum up: 
Gmerlc programming: supported by templates, relying on compile-time 
resolution 
Oijul-<mcTlled programmillg: supported by class hierarchies and virtual 
functions, relying on run-time resolution 
Combinations of the two are possible and useful. For example: 
void draw_all(vedor<Shape">& v) 
{ 
for (inl i=O; i<v.size(); ++i) v(i1->draw(); 
) 
Here we call a virtual function (drawO) on a base class (Shape) using a virtual 
function - that's certainly object-oriented programming. However, we also kept 
Shapc"s in a vcctor, which is a parameterized type, so we also used (simple) 
genenc programmlllg. 

19.3 
TEM PLATES 
So - assuming you have had your fill of philosophy for now - what do peo-
ple actually use templates for? For unsurpassed nexibility and perfomlance, 
Usc templates where performance is essential (e.g., numerics and hard 
real time; see Chapters 24 and 25). 
Usc templates where nc.x.ibility in combining information from several 
types is essential (e.g., the C++ standard library; see Chapters 20-21 ). 
Templmes have many useful properties, such as great nexibility and near·optimal 
performance, but unfortunately they arc not perfect. As usual, the benefits have 
corresponding weaknesses. For templates, the main problem is that the flexibility 
and performance come at the cost of poor separation between the "inside" of a 
template (its definition) and its interface (its declaration). 111is manifests itself in 
poor error diagnostics - often spectacularly poor error messages. Sometimes, 
these error messages come much later in the compilation process than we would 
prefer. 
\OVhen compiling a usc of a template, the compiler "looks into" the template 
and also into the template argument types. It does so to gel lhe infonnation to 
generate optimal code. To have all that information available, current compilers 
tend to require that a template must be fully defined wherever it is used. 11lat i.n· 
cludes all of its member functions and all template functions called from those. 
Consequently, template writers tcnd to place template definitions in header fLies. 
~nlis is not actually required by mc standard, but until improved implementa· 
tions are widely available, we recommend that yOll do so for your own tem· 
plates: place the definition of any template that is to be used in more than one 
translation unit in a header fLie. 
Initially, write only very simple templates yourself and proceed carefully w 
gain experience. One useful development technique is to do as we did for vector: 
First develop and test a class using specific types. Once that works, replace the 
specific types with template parameters. Use template-based libraries, such as the 
C++ standard library, for generality, type safety, and performance. Chapters 20 
and 2 1 arc devoted to the containers and algorithms of the standard library and 
will give yOli examples of the use of templatcs. 
19.3.3 Containers and inheritance 
111ere is one kind of combination of object·oriented programming and generic 
programming lhat people always try, but it doesn'l work : attempting to use a 
container of objects of a derived class as a container of objects of a base class. For 
example: 
vector<Shape> vs; 
vector<Circ1e> vc; 
66' 

662 
CHAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
\IS = ve; 
/I error: vector<Shape> required 
void f(vector<Shape>&); 
fIve); 
/I error: veclor<Shape> required 
But why not? After all, YOli say, I can convert a Circle to a Shape! Actually, no, 
you can'l. You can convert a Circle- to a Shape* and a Circle& to a Shape&, but 
we deliberately disabled assignment of Shapes, so that YOli wouldn't have to 
wonder what would happen if you put a Circle with a radius into a Shape vari-
able 11m doesn't have a radius (§ 14.2.4). What would have happened - had we 
allowed it - would have been what is called "slicing" and is the class object equiv-
alent to integer truncation (§3.9.2). 
So we try again using pointers: 
veclor<Shape-> vps; 
vector<Circle*> VpC; 
vps = "pc; 
II error: veclor<Shape"> required 
void f(vector<Shape*>&); 
f(vpc) ; 
II error: vector<Shape"> required 
Again, the type system resists; why? Consider what f() might do: 
void f(veclor<Shape*>& v) 
{ 
v. push_back (new Reciangle(Poi n I (0,0), Point( 1 00, 1 00»); 
) 
Obviously, we can put a Reclangle· into a veclor<Shape*>. However, if that 
veclor<Shape*> was elsewhere considered to be a vector<Circle*>, someone 
would get a nasty surprise. In particular, had the compiler accepted the example 
above, what would a Rectangle* be doing in vpc? Inheritance is a powerrul and 
subtle mechanism and templates do not implicitly extend its reach. 111ere are 
ways or using templates to express inheritance, but they are beyond the scope or 
this book. Just remember that "0 is a B" docs not imply "c<o> is a C<B>" ror an 
arbitrary template C - and we should value that as a protection against acciden-
tal type violatio ns. See also §25.4.4. 
19.3.4 Integers as template parameters 
Obviollsly, it is userul to parameterize classes with types. How about parameter-
izing classes with "other things," such as integer values and string values? Basi-
cally, any kind or argument can be useful, but we'll consider only type and 
integer parameters. Otller kinds o r parameters are less rrequently userul, and 
C++'s support ror other kinds or parameters is sucll that their usc requires quite 
detailed knowledge or language reatures. 

19.3 
TEMPLATES 
Consider an example of the most common use of an integer value as a tem-
plate argument, a container where the number of elements is known at compile 
time: 
templale<class T, inl N> slrucl array { 
T elem(NJi 
/I hold elements in member array 
1/ rely on the default constructors, destructor, and assignment 
T& operalor(J (int n); 
/I access: return reference 
canst T& operator[J (int nl consl; 
yo dataO { return elem; } 
/I conversion to y-
canst yo dataO consl { return elem; } 
int sizeO consl {return N; } 
) ; 
We can use array (see also §20.7) like this: 
array<inl,256> gb; 
1/256 integers 
array<double,6> ad = {O.O, 1.1, 2.2, 3.3, 4.4, 5.5}; 
/I note the initializer! 
const inl max = 1024; 
void some_fel(inl n) 
( 
array<char,mao loc; 
array<char,n> oops; 1/ error: the value of n not known to compiler 
II . .. 
) 
array<char,mao loc2 = lOCi 
II . .. 
lac = 10c2; 
II . .. 
1/ make backup copy 
II restore 
Clearly, array is very simple - much simpler and less powerful than vector - so 
why would anyone want to use an array rather than a vector? One answer is "ef-
ficiency." We know the size of an array at compile time, so t.he compiler can allo-
cate static memory (for global objects, such as gb) and stack memory (for local 
objects, such as loc) rather than using the free store. When we do range check-
ing, the checks can be against constants (the size parameter X ). For most pro-
grams the efficiency improvement is insignificant, but if you are writing a crucial 
system component, such as a network driver, even a small diJTerence can matter. 
66J 

664 
CHAPTE R 19 • VECTO R, TEMPLATES, AND EXCE PTIONS 
More importantly, some programs simply can't he allowed to use free stOre. Such 
programs are typically embedded systems programs and/or safcty-criticru pro-
grams (sec Chapter 25). In such programs, array gives us many of the advantages 
of vector without violating a critical restriction (no free-store use). 
Let'S ask the opposite question: not "Why can't we just usc vector?" but 
"Why notjusl usc built-in arrays?" As we saw in §18.5, arrays can be rather ill 
behaved: they don't know their own size, they convert to pointers at the slightest 
provocation, they don't copy properly; array doesn't have those problems. For 
example: 
double· p = ad; 
double· q = ad.dataO; 
/I error: no implicit conversion to pointer 
/I OK: explicit conversion 
template<class C> void prinloul(const C& c) 
{ 
for (in I i = 0; i<c.size(); ++i) cout « clil « '\n'; 
} 
lllis printoutO can be called by an array as well as a vector: 
printout(ad); 
vector<int> vi; 
/I . .. 
printout(vi); 
II call with array 
II call with vector 
111is is a simple example of generic programming applied to data access. It works 
because the interface used for array and vector (sizeO and subscripting) is the 
same. Chapters 20 and 21 will explore this style of programming in some detail. 
19.3.5 Template argument deduction 
For a class template, you specify the template arguments when yOli create an ob· 
ject of some specific class. For example: 
array<char,1024> buf; 
array<double,lO> b2; 
IIforbuf, T ischarand N is 1024 
II for b2, T is double and N is 10 
For a function template, the compiler usually deduces the template arguments 
from the function argumenlS. For example: 
lemplale<class T, inl N> \loid fil l(array<T,N>& b, consl T& val) 
{ 
for (inl i = 0; i<N; ++i) b[i) = val; 
} 

19 .3 
TEMP LATES 
void to 
{ 
till(buf, 'x'); 
fill(b2,0.0); 
} 
/I for nllo, T is char and N is 1024 
/I because Ihafs what buf has 
/I for fill(), T is double and N is 10 
/I because that's what b2 has 
Technically, fill{buf, 'x') is shorthand for filkchar, 1024>(buf, 'x'), and fill(b2,0) is 
shorthand for filkdouble,10>(b2,O), but fonunately we don't often have to be 
that specific. "n le compiler figures it out for us. 
19.3.6 Generalizing vector 
\¥hen we generalized vector from a class "vector of double" to a template "vector 
of T," we didn't review the definitions of push_backO, resizeO, and reserveO. We 
must do that now because as they are defined in §19.2.2 and §19.2.3 they make 
assumptions that are tme for doubles, but not lme for all lYJ>CS that we'd like to 
use as vector element types: 
How do we handle a vector<x> where X doesn't have a default vaJue? 
How do we ensure that elements are destroyed when we are finished 
with them? 
Must we solve those problems? We could say, "Don't try to make vectors of 
types without default values" and "Don't use vectors for types with destructors 
in ways that cause problems." For a facility that is aimed at "general use," such re· 
strictions arc annoying to users and give the impression that the designer hasn't 
thought the problem through or doesn't really care about lIsers. Often, such SllS-
picions are correCl, but the designers of the standard library didn't leave these 
warts in place. To mirror the standard library vector, we must solve these two 
problems. 
We can handle types withollt a default by giving the user the option to spec-
ify the value to be used when we need a "default vaIue": 
template<class T> void veclor<T>: :resize(int newsize, T def = T(»; 
That is, use TO as the default value unless the user says otherwise. For example: 
vector<double> vl ; 
vl .resize(l00); 
vl .resize(200, 0.0); 
v1.resize(300, 1.0); 
/I add 100 copies of double(), that is, 0.0 
II add 100 copies of 0.0 -
menlioning 0.0 is redundanl 
/I add 100 copies of 1.0 
665 

... 
C HAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
struct No_default ( 
No_default(int); 
/I the only constructor for No_default 
/I . .. 
}; 
veclor<No_defaull> v2(10); 
vectof<No_defaull> v3; 
v3.resize(1(M), No_default(2»; 
v3.resize(200); 
lIerror: tries to make 10 No_default(~ 
/1 add 100 copies of No_default(2) 
/I error: tries to make 100 No_def;lUItOS 
~nle dcstnlctor problem is harder to address. Basically, we need to deal with 
something really awkward: a data structure consisting of some initialized data 
and some uninitialized data. So far, we have gone a long way to avoid uninitial-
izcd data and the programming errors that usually accompany it. Now - as illl-
p[emcntcrs of vector - we have to face that problem so thal we - as users of 
veclor - don't have to in our applications. 
First, we need to find a way of getting and manipulating uninitialized storage. 
Fortunately, the standard library provides a class allocator, which provides unini-
tialir.ed memory. A slightly simplified version looks like this: 
template<class T> class allocator ( 
public: 
}; 
II . . . 
P allocate(int n); 
/I allocate space for n objects of type T 
void dealiocate(T· p, int n); 
II deallocate n objects of type T starting at p 
void construct(P p, const T& v); 
void destroy(P p); 
/I construct a T with the value v in p 
1/ destroy the T in p 
Should you need the full story, have a look in The C++ Programming Language, 
<memory> (§B.l.l), or the standard. However, what is prescnted here shows the 
four fundamental operators that allow us to 
Allocate memory of a size suitable to hold an object of type T without 
initializing 
Construct an object of type T in uninitialized space 
Destroy an object of type T, thus retllmillg its space to the unillitialized 
stale 
Deallocate uninitialized space of a size suitable for an object of type T 

19 .3 
TEMPLATES 
Unsurprisingly, an allocator is exactly what we need ror implememing vec-
tor<T>: :reserveO. We start by giving vector an allocator parameter: 
template<class T, class A = aliocator<T> > class vector ( 
); 
A alloc; 
II use allocate to handle memory for elements 
II ... 
Except rOJ" providing an allocmor - ,md using the standard one by ddault instead 
or using new - all is as berm·e. As users or vector, we can ignore allocators until 
we find ourselves needing a vector that manages memory ror its elements in 
some unusual way. As imp1cmenters or vector and as students trying to under-
stand rundamental problems and learn rundamental techniques, we must see 
how a vector can deal with ulunitialized memory and presem properly con-
structed objects to its users. TIle only code affected is vector member runctions 
that directly deal with memory, such as vector<T>:: reserve(): 
templale<class T, class A> 
void veclor<T,A>: :reserve(inl newalloc) 
( 
if (newalloc<=space) return; 
1/ never decrease allocation 
1* p = alloc.allocale(newalloc); 
1/ allocate new space 
for (inl i=O; i<sz; ++i) alloc.construcl(&p[iJ,elem[iJ); 
1/ copy 
for (inl i=O; ksz; ++i) alloc.destroy(&elem[i]), 
/I destroy 
alloc.deallocale(elem,space); 
/I deallocate old space 
clem = p; 
space = newalloc; 
) 
We move an clement to the new space by constructing a copy in uninitialized 
space and then destroying the original. We can't use assignment because ror 
types such as SIring, assig.mlCllt assumes that t.he target area has been initialized. 
Given reserveO, vector<T,A>:: j>ush_backO is simple to wTite: 
templale<class T, class A> 
void vector<T,A>: :push_back(const T& val) 
( 
) 
if (space==O) reserve(8), 
else if (sz==space) reserve(2·space); 
a 1I0c. co nslrucl(&elem[sz], val); 
++SZ; 
/I start with space for 8 elements 
/I get morc space 
/I add val at end 
1/ increase the size 
66' 

... 
CHAPTER 19 • VECTO R, TEMPLATES, AND EXCE PTIONS 
Similarly, veclor<T,A>: :resize() is nOt too difficult: 
template<class T, class A> 
void vector<T,A>: :resize(int newsize, T val = TO) 
( 
reserve(newsize); 
for (int i=sz; knewsize; ++i) alloc.construcI(&elem[il,val); 1/ construci 
for (int i = newsize; k sz; ++i) alloc.deslroy(&elem[i)) ; 
II destroy 
5Z = newsize; 
) 
Note that because some types do not have a default constmctor, we again pro-
vide the option to supply a value to be lIsed as an initial value for new clemenLS. 
The other new thing here is the destruction of "surplus clements" in the case 
where we are resizing to a smaller vector. Think of the destructor as turning a 
typed object imo "raw memory." 
"Messing with allOCalors" is pretty advanced stuff, and tricky. Leave it alone 
until you are ready to become an expert. 
19.4 Range checking and exceptions 
We look at our vector so far and fmd (with horror?) that access isn't range checked. 
The implementation of operator[) is simply 
template<class T, class A> T& vector<T,A>: :operator[](int nl 
( 
return elcm[n); 
So, consider: 
vector<int> v(100); 
v[- 200] = v[2001; 
/I oops! 
int i; 
cin»i; 
v[i] = 999; 
/I maul an arbitrary memory local ion 
111is code compiles and runs, accessing memory not owned by our vector. This 
could mean big trouble! In a real prognun, such code is unacceptable. Let'S try to 
improve our vector to deal with this problem. The simplest approach would be 
to add a checked access operation, called at(): 

19.4 
RANGE CH ECKING AND EXCEPTIONS 
slruct oUI_oCrange { r ... "' }; 
/I class used 10 reporl range access errors 
lemplate<class T, class A = aliocalor<T> > class vector ( 
/I . .. 
} ; 
T& al(inl n); 
const T& at(inl n) const; 
T& operalorl1(inl n); 
consl T& operalor( Hinl n) consl; 
/I. 
/I checked access 
/I checked access 
/I unchecked access 
" unchecked access 
lemplate<d ass T, class A > T& veclor<T,A>: :at(int n) 
( 
} 
if (n<O II sz<=n) throw ouCoLrangeO; 
relurn elem[n]; 
Icmplate<d ass T, class A > T& vector<T,A>: :operator[1(inl n) 
/I as before 
( 
return clem[n]; 
) 
Given that, we could write 
void prinCsome(veclor<inl>& v) 
( 
} 
inl i=-1; 
d n » i; 
while(i!= - t ) try { 
cout « "vl" «
i « "]==" «v.at(i)« "\n"; 
catch(ouCoCrange) { 
cout « "bad index: » «
i « "\n"; 
Here, we use at() to get range-checked access and we calch o UI_oLrange in case 
of an illegal access. 
TIle general idea is to usc subscripting with r I when we know that we have a 
valid index and alO when we might have an out-of-range index. 
.. , 

67. 
( HAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
19.4.1 An aside: design considerations 
So far, so good, but why didn't we just add the range check to operatorllO? Well, 
the standard library vector provides checked all) and unchecked operatorllO as 
shown here. Let's try to explain how that makes some sense. There arc basically 
fOllr arguments: 
I . Cmnpatibi1if)': People have been using unchecked subscripting since long 
before C++ had exceptions. 
2. EjJioouy: You can build a checked-access operator on top an optimally 
fast unchecked-access operator, but you cannOt build an optimally fast 
access operator on lOp of a d lccked-access opcralor. 
3. Cnu/minl.J: In some environments, exceptions arc unacceptable. 
4. OptiO/Ul/ checkillg: lllC standard doesn't actually say that you can't range 
check vector, so if you want checking, usc an implementation that checks. 
19.4.1.1 Compatibility 
People rcally, really don't like to have their old code break. For example, if yOll 
have a Ill.illion lines of code, it could be a very costly affair to rework it all to usc 
exceptions correctly. We can argue tllat the code would be better for the extra 
work, but then we are not the ones who have to pay (in time or money). Furtller' 
1U0re, maintainers of existing code usually argue that unchecked code may be un· 
safe in plinciple, but their particular code has been tested and used for years and 
all the bugs have already been found . We can be skeptical about tlmt argument, 
but again nobody who hasn't had to make such decisions about real code should 
be tOO judgmental. Naturally, there was no code using the standard library vector 
before it was introduced into the C++ standard, but there were many millions of 
lilles of code tllat used very similar vectors tlmt (being pre·standard) didn't usc ex· 
ceptions. Much of tlmt code was latcr modified to use the standard. 
19.4.1 .2 Efficiency 
Yes, range chccking can be a burden in extreme cases, such as buffers for net· 
work interfaces and matrices in high·performance scientific computations. How· 
ever, the cost of range checking is rarely a concern in the kind of "ordinary 
computing" that most of us spend most of our time on. TI1lIS, we recommend 
and usc a range·checked implementation of vector whenever we can. 
19.4.1.3 Constraints 
Again, the argument holds for some progranmlers and some applications. In fact, 
it holds for a whole lot of programmers and shouldn't be lightly ignored. How· 
ever, if you arc starting a new program in an environment that doesn't involve 
hard real lime (sec §25.2.1), prefer exception·based error handling and range~ 
checked vectors. 

19.4 
RANGE CH EC KING AND EXCEPTION S 
19.4.1.4 Optional checking 
111e ISO C++ standard simply states that oUl-of-range vector access is not guar-
anteed to have any specific semantics, and that such access should be avoided. It 
is perfectly standards-conforming to throw an exception when a program tries an 
out-of-range access. So, if you like vector to throw and don't need to be con· 
cerned by the fIrst three reasons for a particular application, use a range-checked 
implementation of vector. 11mt's what we arc doing for this book. 
The long and the short of this is that real-world design can be messier than 
we would prefer, but there are ways of coping. 
19.4.2 A confession: macros 
Like our vector, most implementations of the standard library vector don't guar-
antee to range check the subscript operator (II) but provide atO that checks. So 
where did those sid : :OuI_oCrange exceptions in our programs come from? Basi-
cally, we chose "option 4" from §19.4.1: a vector implementation is not obliged 
to range check [ 1, but it is not prohibited from doing so either, so we arranged for 
checking to be done. What you might have been using is our debug version, 
called Vector, which does check [J. That's what we use when we develop code. It 
cuts down on errors and debug time at little cost to performance: 
struct Range_error: out_oCrange { 
II enhanced vectOf range errOf reporting 
int index; 
Range_error(int i) :oul...oCrange(" Range error"), index(i) () 
} ; 
template<c1ass T> slruct Vector : public sId: :vector<T> { 
typedef type name sid: :vector<T>: :size_type size_type; 
}; 
VectorO { } 
Vector(size_type n) :std: :vector<T>(n) () 
Vector(size_type n, const T& v) :std : :vector<T>(n,v) {} 
T& operator[](unsigned int i) /I rather than return at(i); 
( 
} 
if (kOlllhis->size()<=i) throw Range_error(i); 
return std : :vector<T>: :operator[](i); 
const T& operator[J(unsigned int i) const 
( 
jf (kOllthis->size()<=i) throw Range_error(i); 
return std : :vector<T>: :operator[J(i); 
671 

672 
CHAPTER 19 • VEC TOR , TEM P LATES, AND EXC EPTI O NS 
We use Range_error to make the olTending index available for debugging. 
The typedef introduces a convenient synonym; see §20.5. 
11lis Vector is very simple, arguably too simple, bm it has been useful in debug-
ging nonuivial programs. ~nlC a1tcmalive is to use a systematically checked imple-
mentation of the complete standard library vector - in fact, that lIury indeed be what 
you have been using; we have no way of knowing exactly what degree of checking 
your compiler and library provide (beyond what the standard guarantees). 
In std_lib_facililies.h, we use the nasty trick (a macro substitution) of redefin-
ing vector to mean Vector: 
1/ disgusting macro hack to get a range-checked vector: 
#define vector Vector 
That means that whenever yOlI wrote vector, the compiler saw Vector. ' 1lis trick 
is nasty because what you see looking at the code is not what the compiler sees. In 
real-world code, macros are a significant source of obscure errors (§27.8, §A.17). 
We did the same to provide range-checked access for string. 
Unfortunately, there is no standard, portable, and clean way of gelling range 
checking from an implementation of vector's [ 1. It is, however, possible to do a 
much cleaner and more complete job of a range-checked vector (and string) Ulan 
we did. However, that usually involves replacement of a vendor's standard Ii· 
brary implementation, adjusting installation options, or messing with standard Ii· 
brary source code. None of those options is appropriate for a beginner's first 
week of programming - and we used string in Chapter 2. 
19.5 Resources and exceptions 
So, vector can UITOW exceptions, and we reconunend that when a function cannot 
perfonn its required action, it throws an exception to tellUlat to iLS callers (Chap-
tcr 5). Now is the time to consider what to do when we write code ulat must deal 
with exceptions Ulrowll by vector operations ,md other functions Ulat we calL TIle 
naive answer - "Use a try-block LO catch the exception, write an error message, 
and ulen terminate the program" - is tOO crudc for mOSt nontrivial systems. 
One of the fundamental principles of progranuning is that if we acquire a fe· 
source, we must - somehow, direcuy or indirectly - return it to whatever part of 
the system manages that rcSOLLrce. Examples of resources are 
Memory 
Lock> 
Fmc handles 
"nlrcad handles 
Sockets 
Windows 

! 9.5 
RE SO URCES AND EXCEPT!O NS 
Basically, we define a resource as something that is acquired and must be given 
back (released) or reclaimed by some "resource manager." TIle simplest example 
is free-store memory that we acquire using new and return to the free store using 
delete. For example: 
void suspicious(int S, int xl 
{ 
int- p = new jnl[S]i 
1/ acquire memory 
/I ... 
delete[] Pi 
1/ release memory 
) 
As we saw in §17.4.6, we have to remember to release the memory, and that's not 
always easy to do. "\¥hen we add exceptions to the picture, resource leaks can be-
come colllmon; all it takes is ignorance or some lack of care. In particular, we 
view code, such as suspiciousO, that explicit1y uses new and assigns the resulting 
pointer to a local variable wit1l great suspicion. 
19.5.1 Potential resource management problems 
One reason for suspicion of apparent1y innocuous pointer assignments such as 
int- p = new inl[s]i 
1/ acquire memory 
is that it can be hard to verify t.hat the new has a corresponding delete. At least 
suspiciousO has a delete[] Pi statement that might release the memory, but let's 
i.magine a few things that might cause that release not to happen. "\¥hat could we 
put in the ... pan to cause a memory leak? TIle problematic examples we find 
should give you cause for thought aJld make you suspicious of such code. They 
should also make you appreciate the simple and powerful alternative to such code. 
Maybe p no longer points to the object when we gel to the delete: 
void suspicious(int S, int xl 
{ 
int· p = new int[s]i 
/I acquire memory 
/I. 
if (x) P = q; 
II make p point to another object 
1/ . .. 
deleteD p; 
1/ release memory 
We put that if (xj t11ere to be Sllre that you couldn't know whether we had 
changed the value of p. Maybe we never get to the delete: 

674 
CHAPTER 19 • VECTOR, TEMPLATE S, AND EXCEPTION S 
void suspicious(int 5, int xl 
{ 
int- p = new int[s); 
II acquire memory 
1/ . . . 
if (x) return; 
1/ . . . 
deletelJ Pi 
/I release memory 
Maybe we never get to lhe delete because we threw an exception: 
void suspiciousOnt 5, inl x) 
{ 
) 
inl· p = new intis}; 
/I acquire memory 
veClor<int:> V; 
1/ . .. 
if (x) p ix) = v.at{x); 
/I . .. 
de lele{) Pi 
/I release memory 
It is this last possibility thal concerns us most here. When people first encounter 
this problem, they lend to consider it a problem with exceptions rather than a re-
SOLlrce management problem. Having misdassified the roOl cause, they come up 
with a solution that involves catching the exception: 
void suspicious(int 5, int xlI/messy code 
{ 
) 
int· p = new inI[5]; 
II acquire memory 
vector<int:> Vi 
1/ . .. 
try { 
if (x) pix) = v.at(x); 
1/ . . . 
} catch ( ... ) { 
deletell Pi 
throWi 
) 
1/ . . . 
dele le[] Pi 
/I catch every exception 
/I release memory 
/I re-throw Ihe exceplion 
/I release memory 

19 .5 
RESO URCES AND EXCEPTIONS 
'nlis solves the problem at the cost of some added code and a duplication of the 
resource release code (here, deleteU p;). In other words, this solution is ugly; 
worse, it doesn't generalize well. Consider acquiring more resources: 
void suspicious(vector<inb& v, int s) 
{ 
) 
int- p = new intIs1; 
vector<inbv1; 
1/ . .. 
int- q = new intIs]; 
vector<double> v2; 
/I . .. 
deletell p; 
delete[J q; 
Note that if new fails to find free-store memory to allocate, it will throw the stan-
dard library exception bad_alloc. 111e try ... catch technique works for this ex-
ample also, but you' ll need several try-blocks, and the code is repetitive and ugly. 
We don't like repetitive and ugly code because "repetitive" translates into code 
that is a maintenance hazard, and "ugly" translates into code that is hard to get 
right, hard to read, and a maintenance hazard. 
TRY TH IS 
Add try-blocks to this last exam ple to ensure that all resources are properly 
released in all cases where an exception might be thrown. 
19.5.2 Resource acquisition is initialization 
Fortunately, we don't need to plaster our code with complicaLCd try ... catch 
statements to deal with potential resource leaks. Consider: 
void f(veclor<int>& v, int s) 
{ 
) 
vector<int> p(s); 
veclor<int> q(s); 
/I .. 
TIlis is better. More impoltantly, it is obuiousiy better. TIle resource (here, free-store 
memory) is acquired by a COl1strucLOr and released by the matching destructor. 
'75 

676 
CHAPTE R 19 • VECTOR , TEMPLATES, AND EX CE PTI ONS 
\OVc actually solved tills particular "exception problem" when we solved the mem-
ory leak problems for vectors. The solution is general; it applies to aU kinds of re-
sources: acquire a resource in the constructor for some object that manages it, and 
release it again in the matching dcslrucLOr. Examples of resources that arc usually 
best dealt with in tills way include database locks, sockets, and 110 buffers 
(ioslreams docs it for you). 111is technique is usually referred to by the awkward 
phrase "Resource Acquisition Is Initialization," abbreviated to RAIL 
Consider the example above. \Nh.ichevcr way we leave fO, lhe destructors for 
p and q are invoked appropriately: since p and q aren't pointers, we GUl' 1. assign to 
them, a return statemclll will not prcvcllllhc inv()C;1.tion of dcstmctors, and neilher 
will thro\vi.ng an exception. 11lis general mle holds: when lhe thread of execution 
leavcs a scope, the destructors for every fully constructed object and sub-object are 
invoked. An object is considered constnlcted when its constmctor completes. E.'\{. 
ploring the detailed implications of those two Statements might cause a headache, 
but they simply mean that construcl'Ors and dcstmctors arc invoked as needed. 
In panicular, use vector rather than explicit new and delete when you need 
a nonconstant amount of storage within a scope. 
19.5.3 Guarantees 
\Vhat can we do where we can't keep the vector within a single scope (and its 
sub·scofx:s)? For example: 
vector<int>· make_vecO 
/I make a filler! vector 
{ 
} 
vector<int>* p = new vector<int>; /I we allocate on frcc store 
1/ . . . filil he vector with data; Ihis may throw an exception ... 
return Pi 
111is is an example of a common kind of code: we call a fUJ1Ction to constmct a 
complicated data st.mcture and retum that data structure as the result. 111e snag 
is that if an exception is thrown while "ftlling" the vector, make_vecO leaks that 
vector. An unrelated problem is that if the function succeeds, someone will have 
to delete the object retumed by make_vecO (see §17.4.6). 
We can add a try·block to deal with the possibility of a throw: 
vector<int>* make_vecO 
/I make a filled vector 
{ 
veclor<int>* p = new veclor<int>; /I we allocate on free store 
try { 
} 
/I fill the vector with data; this may throw an exception 
return Pi 

19 .5 
RESOUR CES AND EXCEPTIONS 
) 
catch ( ... ) { 
delete p; 
throw; 
) 
/I do our local cleanup 
/I re-throw to allow our caller to deal with the (act 
/I thaI some_functionO couldn't do what was 
/I required of it 
111is make_vecO function illustrates a very common style of error handling: it 
tries to do its job and if it can't, it cleans up any local resources (here the vector 
on the free store) and indicates failure by throwing an exception. Here, the excep-
tion thrown is one that some other function (vector: :atO) threw; make_vecO sim-
ply re-throws it using throw; . ~nlis is a simple and effective way of dealing with 
errors and can be used systematically. 
7M basic guarantee: The purpose of the try ... catch code is to enSLIre that 
make_vecO either sLicceeds or throws an exception without having 
leaked any resources_ Tllat's often called the basic guaranlee. All code that 
is part of a program that we expect to recover from an exception throw 
should provide the basic guarantee_ All standard library code provides 
the basic guarantee. 
The strong guamlllee: If, in addition to providing the basic guarantee, a 
function also ensures that all observable values (aU values not local to 
lhe function) arc the same after failure as they were when we called the 
function, lhat function is said lO provide the strong guamntee. The strong 
guaramee is the ideal when we wrile a function: either the function suc-
ceeded at doing everything it was asked to do or else nothing happened 
except lhat an exception was thrown to indicate failure. 
rhe no-throw guarantee: Unless we could do simple operations without any 
risk of failing and throwing an exception, we would not be able to ,mte 
code 1O meet the basic guarantee and the strong guarantee. Fortunately, 
essentially all built-in facilities in C++ provide the no-throw guarantee: 
they simply can't throw. To avoid throwing, simply avoid throw itself, 
new, and dynamic_cast of referencc types (§A.5_7). 
Tlle basic guarantee and the strong guarantee arc most useful for thinking about 
corrcclIless of programs. RAl I is essential for implementing code wnnen accord-
ing to those ideals simply and with high pcrfonnance. For more detailed infoTUla-
tion see Appcndi." E of The C++ Itogrmnmulg La1lguage. 
Naturally, we should always avoid undefined (and usually disastrous) opera-
tions, such as dereferencing 0, dividing by 0, and accessing an array beyond its 
range_ Catching exceptions docs nOl save you from violations of the fundamental 
language rules. 

678 
CHAPTER 19 • VECTOR , TEMPLATES, AND EXCEPTIONS 
19.5.4 auto_plr 
So, make_vecO is a useful kind of function that obeys the basic !Ulcs for good re-
source management in the presence of exceptions. It provides the basic guarantee 
- as all good funClions should when we want to recover from exception throws. 
Unless something nasty is done with nonlocal data in the "fill the vCCLOr with 
data" pan, it even provides the strong guarantee. However, that Iry ... catch code 
is still ugly. The solution is obvious: somehow we must lise RAlI ; that is, we 
need to provide an object to hold that vector<int> so that it can delete lhc vector 
if an exception occurs. In <memory>, the standard library provides the auto_pt, 
for that: 
veclor<int>* make_vecO 
/I make a filled vector 
( 
) 
auto_ptr< vector<int> > p(new vector<int»; 
II allocate on free store 
II fi ll the vector with data; this may throw an exception 
relurn p.release(); 
II return the pointer held by p 
An auto_plr is simply an object thal holds a pointer for you within a function. 
We immediately initiaJize it with the object we got from new. You can use - > and 
• on an aulo_ptr exactly like a pointer (e.g., p-> at(2) or (· p).at(2»), so we think 
of auto_ptr as a kind of pointer. However, don't copy an auto_ph without first 
reading the auto_ptr documentation; the semantics of auto_plr arc different from 
those of every other lype you have seen. TIle releaseO operation tcJls the 
auto_plr to give us our ordinary pointer back, so that we can retum that pointer 
and so that the auto_plr doesn't destroy lhe object pointed to when we retum. If 
you feci tempted to use aUlo_ptr in more intercstillg ways (e.g., to copy one), re-
sist that temptation. Holding a pointer to guarantee deletion at the end of a scope 
is what aUlo_ptr is for, and other uses require you to master some rather special-
ized skills. 1llls auto_ptr is a very specialized facility to handle examples like this 
last version of make_vecO simply and efficiently. In particular, auto_plr allows us 
to repeat our recommendation to look upon explicit try-blocks with suspicion; 
most can be replaced by some variant of the "Resource Acquisition Is Initializa-
tion" tedmique_ 
19.5.5 RAil for vector 
Even using a smart pointer, such as auto_ptr, may seem to be a bit ad hoc. How 
can we be sure that \ ... ·e have spolled all pointers that require protection? How can 
we be sure that we have released all pointers to objects that should not be de-
stroyed at the end of a scope? Consider reserveO from § 19.3.5: 

19.5 
RESO U RCES AND EXCEPT IONS 
template<class T, class A> 
void vector<T,A>: :reserve(int newalloc) 
{ 
if (newalloc<=space) return; 
p p = alloc.allocate(newalloc); 
/I never decrease allocation 
/I allocate new space 
for (int i=O; ksz; ++i) alloc.construcU&p[i],elemliJ); 
II copy 
for (int i=O; ksz; ++i) alloc.destroy(&elemfiJ); 
/I dewoy 
alloc.deallocate(elem,space); 
elem= p; 
/I deallocate old space 
space = newalloc; 
Note that the copy operation for an old clement, alloc.construct(&p[ij,elem[iJ), 
might throw an exception. So, p is an example of the problem \ .. "e warned about 
in §195. 1. Ouch! We could apply the auto_plr solution. A better solution is to 
step back and realize that "memory for a vector" is a resource; that is, we can de-
fine a class vector_base to represent the fundamental concept we have been using 
all the time, the picture with the three clements defining a vector's memory use: 
--
sz: 
elem: 
space: 
0: 
sz-l:
. 
=t--C::o-'''''''''''''''''''.-r: ': T::: : : : :: :: ::: :::: : ] ::; : ,: 
Elements 
(initialized) 
----
In code, that is (after adding the allocator for completeness) 
template<class T, class A> 
struct vector_base { 
); 
A alloc; 
/I allocator 
Pelem; 
inl SZ; 
int space; 
/I start of allocation 
/I number of elements 
/I amount of allocated space 
vector_base(const A& a, int n) 
: alloc(a), elem(a.allocale(n)), sz(n), space(n) { } 
-vector_baseO ( alloc.deallocate(elem,space); } 
" 

680 
CHAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
Note that vector_base deals with memory rather than (typed) objects. Our 
vector implementation can usc that LO hold objects of the desired clement type. 
Basically, vector is simply a convenient interface to vector_base: 
templale<class T, class A = allocator<T> > 
class vector : private vecto,_basc<T,A> { 
public: 
1/ . . 
); 
We can then rewrite reserveO to something simpler and morc correct: 
template<class T, class A> 
void veclor<T,A>: :reserve(inl newallac) 
{ 
if (newalloc<=space) rcturn; 
II never decrease allocation 
vecto,_base<T,A> b(alloc,newalloc); 
II allocate new space 
for (int i=Oj ksz; ++i) alloc,conSlruel(&b,elem[iJ,elem[i])i 
1/ copy 
for (int j=Oj kszj ++i) alloc,deslroy(&elem[i]); 
1/ destroy old 
swap< vector_base<T,A> >(·this,b); 
/I swap representations 
\,yhen we exit reserveO, the old allocation is automatically freed by vector_base's 
destmclOr - even if that exit is caused by the copy operation thro\\,j.ng an excep-
tion. The swapO function is a standard library algorithm (from <algorithm» that 
exchanges the value of twO objects. We used swap< vectof_base<T,A> >(·this,b) 
rather than the simpler swap(-this,b) because -this and b are of different types 
(vector and vector_base, respectively), so we had to be explicit about which swap 
specialization we wanted. 
TRY THIS 
Modify reserve to use auto_ptr. Remember to release before returning. 
Compare that solution to the vector_base one. Consider which is easier to 
write and which is easier to get correct. 

CHAPTER 19 REVIEW 
~ 
Drill 
I. Defme template<class T> shud S {T val; }; . 
2. Add a constmcLOr, so that you can initialize with a T. 
3. Deftne variables of types S<int>, S<char>, S<double>, S<string>, and S< 
vedor<int> >; initialize them with values of your choice. 
4. Read those values and print them. 
5. Add a function template getO that retums a reference to val. 
6. Put the definition of getO outside the class. 
7. Make val private. 
8. Do 4 again using getO. 
9. Add a sel() function template so that you can change val. 
to. Replace getO and setO with an operator[ 1. 
11. Provide const and non-const versions of operator[j. 
12. Define a function template<class T> read_val(T& v) that reads from cin 
into v. 
13. Use read_ valO to read into each of the variables from 3 except the 
S< vector<int> > variable. 
14. Bonus: Define template<class T> oslream& operalor« (oslream&, vec-
10r<1>&) so that read_valO will also handle the S< vector<int> > variable. 
Remember to test after each step. 
Review 
I. Why would we want to change the size of a vector? 
2. "Vhy \\'ould we want to have different element typCS for different veclors? 
3. Why don't we just always define a vector with a large enough size for all 
eventualities? 
4. How much spare space do we allocate for a new vector? 
5. When must we copy vector elements to a new location? 
6. Which vector operations can change the size of a vector after construction? 
7. What is the value of a vector after a copy? 
8. Which two operations defme copy for vector? 
9. What is the default meaning of copy for class objects? 
10. What is a template? 
11 . What are the two most useful types of template arguments? 
12. What is generic programming? 
13. How does generic programming differ from objeCt-orienled programming? 
68' 

682 
CHAPTE R 19 • VEC TOR, TEMPLATES, AND EXCEPTIONS 
14. How does array differ from vector? 
15. How does array differ from the built·in array? 
16. How docs resizeO differ from reserve()? 
17. \"'hat is a resource? Define and give examples. 
18. What is a resource leak? 
19. What is RAIl? What problem does it address? 
20. What is auto_plr good for? 
Terms 
#define 
atO 
auto_ptr 
basic guaramee 
exception 
guarantees 
IIlstanuauon 
Exercises 
macro 
push_backO 
RAIl 
resizeO 
resource 
re-throw 
self-assignment 
specialization 
strong guarantee 
template 
template parameter 
this 
throw; 
For each exercise, create and test (with output) a couple of objects of the defined 
classes to demonstrate that your design and implementation actually do what yOll 
think they do. Where exceptions are involved, this can require careful thought 
about where enoTS can occur. 
1. Write a template function lhat adds a vector of clements of an object of 
any type to which clements can be added. 
2. Write a template function that takes a vector<T> vt and a vector<U> vu 
as arguments and retums the sum of all vt[iJ-vulils. 
3. Write a template class Pair that can hold a pair of values of any type. Use 
this to implement a simple symbol table like the one we used in the cal· 
culator (§7.8). 
4. Modiry class link from §17.9.3 to be a template with the type of value as 
the template argument. Then redo exercise 13 from Chapter 17 with 
link<God>. 
5. Defme a class Int having a single member of class int. Define construc· 
tors, assigmnem, and operators +, - , . , I ror it. Test it, and improve its de-
sign as needed (e.g., define operators « and » for convenient 1/0 ). 
6. Repeat the previous exercise, but wilh a class Number<T> where T can 
be any numeric type. Try adding % to Number and see what happens 
when you try to use % for Number<double> and Number<int>. 
7. Try your solution to exercise 2 with some Numbers. 

CHAPTER 19 EXERCISES 
8. Implement an allocator (§19.3.6) using the basic alloc.-ttion functions 
maliocO and freeO (§B.1O.4). Get vector as defined by the end of §I9.4 
to work for a few simple test cases. 
9. Re-implement veclor::operator=() (§I9.2.5) using an allocator (§I9.3.6) 
for lllelllOlY management. 
10. Implement a simple auto_ph supporting only a constructor, destructor, 
->, *, and release(). In particular, don't try to implement an assignment 
or a copy constructor. 
11. Design and implement a counted_ptr<T> that is a type that holds a 
pointer to an object of type T and a pointer to a "usc count" (an int) 
shared by all counted pointers to the same object of type T. The use 
count should hold the number of counted pointers pointing to a given T. 
Let the counted_ptr's constructor allocate a T object and a usc coum on 
the free store. Give the counted_ph an initial value for the T. ''''hen the 
last counted_ph for a T is destroyed, counted_ptr's destructOr should 
delele t..he T. Give the counted_ph operations that allow us to use it as a 
pointer. "Dlis is an example of a "smart pointer" used to ensure that an 
object doesn't get destroyed lIntil after its last user has stopped using it. 
Write a set of test cases for counted_plr using it as an argument in calls, 
container elements, etc. 
12. Define a File_handle class with a constructor that takes a string argu-
ment (the me name), opens the me in the constructor, and closes it in the 
destructor. 
13. Write a Tracer class where its constructor prints a string and its deslluc-
tor prints a string. Give the strings as constructor arguments. Usc it to 
see where RAI l management objects will do their job (i.e., experiment 
with Tracers as local objects, member objects, global objects, objects allo-
cated by new, etc.). Then add a copy constructor and a copy assignment 
sO that you can lise Tracer objects to sec when copying is done. 
14. Provide a GU I interface and a bit of graphical output to the "Hunt the 
Wumpus" game from the exercises in Chapter 18. Take the input in an 
input box and display a map of thc part of the cave currently known to 
lhe player in a window. 
15. Modify the program from the previous exercise to allow the user to mark 
rooms based on knowledge and guesses, such as "maybc bats" and "bot-
tonuess pit." 
16. Sometimes, it is desirable tlmt an empty vector be as small as possible. 
For example, someone might use vector< vector< vector<inl> > > a lot, 
but have most clement veClors empty. Define a vector so that sizeoHvec-
tor<inb)==sizeof(int·), that is, so that the vector itself consists oluy of a 
pointcr to a rcpresentation consisting of tllC elements, tlle number of ele-
ments, and the space pointer. 
683 

584 
CHAPTER 19 • VECTOR, TEMPLATES, AND EXCEPTIONS 
Postscript 
Templates and exceptions arc immensely powerful language features. They sup-
port programming techniques of great flexibility - mostly by allowing people to 
separate conccOlS, that is, to deal with olle problem at a time. For example, using 
templatcs, we can defme a container, such as vector, separately from t.he ddini-
lion of an element type. Similarly, using exceptions, we can write the code that 
detects and signals an crror separately from the code that handles that ClTor. '11C 
third major theme of this chapter, changing the size of a vector, can be seen in a 
similar light: push_backO, resizeO, and reserveO allow us to separate the defini-
tion of a vector from the specification of its size. 

\:1. . 
,.. 20 
Containers and Iterators 
"Write programs that do one thing 
and do it welL Write programs 
to work together." 
-Doug M cilroy 
T
his chapter and the next present the S1L, the containers 
and algorithms part of the C++ standard library. 111C STL 
is an extensible framework for dealing with data in a C++ pro-
gram. Mter a rlfSl simple example, we prescm the general ideals 
and the fundamemal concepts. We discuss iteration, linked-list 
manipulation, and STL containers. The key notions of sequence 
and iterator are used to lie containers (data) together with algo-
rithms (processing). This chapter lays the groundwork for the 
general, efficient, and useful algorithms presented in the next 
chapter. As an example, it also presents a framework for texl ed-
iting as a sample application. 
685 

686 
C HA PTE R 20 • CON TA IN ERS AND ITERATO RS 
20.1 Storing and processing data 
20.1.1 Working with data 
20.1.2 Generalizing code 
20.2 STl ideals 
20.3 Sequences and ilerators 
20.3.1 Back to the example 
20.4 linked lists 
20.4.1 list operations 
20.4.2 Iteration 
20.5 Generalizing vector yet again 
20.6 An example : a simple lext editor 
211.6.1 Lines 
20.6.2 lIeralion 
20.7 vector, list, and Siring 
20.7.1 insert and erase 
20.8 Adapting our vector to the STL 
20.9 Adapting built·in arrays to the STL 
20.10 Container overview 
20.10.1 tleralor categories 
20.1 Storing and processing data 
Before looking into dealing with larger collections of data items, let's consider a 
simple example that points to ways of handling a large class of data-processing 
problems. J ack and Jill arc each measuring vehicle speeds, which they record as 
floating-poim values. Jack was brought up as a C programmer and stores his val-
ues in an array, whereas Jill stores hers in a vector. Now we'd like to lise their 
data in our program. How might we do this? 
We could have J ack's and J ill's programs write out the values to a file and 
then read them back into our program. Tllat way, we are completely insulated 
from their choices of data structures and interfaces. Often, such isolation is a 
good idea, and if that's what we decide to do we "Ill use the techniques from 
Chapters 10- 11 ror input and a vector<double> for our calculations. 
But, what if using rues isn't a good option for the task we want to do? Let's 
say that the data-gathering code is designed to be invoked as a function call to de-
liver a new set of data every second. O nce a second, we call J ack's and J ill's fUllc-
tions to deliver data for LIS to process: 
double- get_fromjack(int~ count); II Jack puts doubles into an array and 
/I returns the number of elements in 'counl 
vector<double>- geCfromjill(); 
/I Jill fills the vector 
void fctO 
{ 
) 
int jack_count = 0; 
double jack_data = geUromjack(&jack_countJ; 
vector<double>· jill_data = get_fromjillO; 
/I ... process . 
deletel] jack_data; 
delete jill_data; 

20 . 1 
STORING AND PROCESSIN G DATA 
The assumption is that the data is stOred on the free sLOre and that we should 
delete it when we are finished using it. Another assumption is that we can't 
rewrite Jack's and Jill's code, or wouldn't want to. 
20.1.1 Working with data 
Clearly, this is a somewhat simplified example, but it is not dissimilar to a vast 
number of real·world problems. If we can handle this example elegantly, we can 
handle a huge number of common programming problems. The fundamental 
problem here is that we don't control the way in which our "data suppliers'" store 
the data they give us. It's our job to either work with the data in the fonn in 
which we get it or to read it and store it the way we like better. 
What do we want to do with that data? Sort it? Find the highest value? Find 
the average value? Find every value over 65? Compare Jill's data with J ack's? 
See how many readings there were? TIle possibilities are endless, and when 
writing a real program we ,.viIl simply do the computation required. Here, we 
just want to do something to learn how to handle data and do computations in· 
volving lots of data. Lee's first do something really simple: find the element with 
the highest value in each data set. We can do that by inserting this code in place 
of the " ... process . .. ,., comment in fel() : 
/I ... 
double h =-1; 
double jack_high; 
double· jill_high; 
II jack_high will point to the element with the highest value 
II jill_high willlX'int to the element with the highest value 
for (int i=O; kjack_count; ++i) 
if (h< jack_dataliH 
jack_high = &jack_data iii; /I save address of largest element 
h = - 1; 
for (in I i=O; i< jill_data ->sizcO; Hi) 
if (h«·jiICdala)[i]) 
jill_high = &(·jill_data)(i); II save address of largest element 
coul « "Jill's max : "« ·jill_high 
«"; Jack's max: " « ·jack_high; 
/I. 
NOle the ugly notation we use to access J ill's data: (·jiICdata)[ij. TIle function 
fromjillO returns a pointer to a vector, a vector<double> .... To get to the data, we 
first have to dereference the pointer to get to the vector, ·jill_data, then we can 
subscripl that. However, *jill_datalil isn't whal we wanl; that means ·(jill_dataliJ) 
.. 7 

... 
CHAPTER 20 • CONTA INE RS AND ITE RATO RS 
because [ J binds tighter than .. so we need the parentheses around · jill_data and 
gel (·ji ll_dala)[iJ. 
TRY THI S 
If you were able to change Jill's code, how would you redesign its interface to 
get rid of the ugliness? 
20.1.2 Generalizing code 
VVhat we would like is a unifonn way of accessing and manipulating data so that 
we don't have to write our code differently each time we get data presented to us 
in a slightly different way. Let's look at Jack's and Jill's code as examples afhow 
we can make our code more abstract and uniform. 
Obviously, what we do for Jack's data strongly resembles what we do forJill's. 
However, there arc some annoying difTcrcnces : jack_count vs. jill_data->si-lc() 
and jack_datam vs. (· jill_dataHil. We could eliminate the lauer difference by intro-
ducing a reference: 
vector<double>& v = -jill_data; 
for (int i=O; i<v.sizeO; Hi) 
if (h<v{i]) jill_high = &vlil; 
1l1is is tantalizingly dose to the code for J ack's data. 'What would it take to write 
a function that could do the calculation forJill's data as well as forJack's? We can 
think of several ways (see exercise 3), but for reasons of generality which will be-
come clear over the next two chapters, we chose a solution based on pointers: 
double- high(double- first, double- last) 
II return a pointer to the clement in Ifirst,last) that has the highest value 
( 
} 
doubleh=-l ; 
double- high; 
for(double- p = first ; p!=lasti ++p) 
if (h<·p) high = Pi 
return high; 
Given that, we can write 
double- jack_high = high(jack_data,jack_data+jack_count); 
vector<double>& v = -jill_data; 
double- jill_high = high(&v(O),&v(O)+v.size()); 

20.1 
STO RING AND PROCESS IN G DATA 
111is looks better. We don't introduce so many variables and we write the loop 
and the loop body only once (in highO). If we want to know the highest values, 
we can look at · jack_high and -jill_high. For example: 
cout « "Jill's max: " « -jill_high 
« "; Jack's max: " « *jack_high; 
Note that highO relics on a veCLOr storing its elements in an array, so that we can 
express our "lind highest clement" algorithm in tenus of pointers into an array. 
TRY THI S 
We left two potentially serious errors in this little program. One can cause a 
crash, and the other wiil give wrong answers if highO is used in many other 
progTams where it might have been useful. TIle general techniques that wt: 
describe below will make them obvious and show how to systematically 
avoid tllem. For now, juSt fmd them and suggCSt remedies. 
TItis highO function is limited in that it is a solution to a single specific problem: 
It works for arrays only. We rely on the elements of a vector being stored 
in an array, but there are many more ways of storing data, such as lists 
and maps (sec §20.4 and §2 1.6.1). 
It can be used for vectors and arrays of doubles, but not for arrays or 
vectors with other clement types, such as vector<double> and char[10). 
It finds the clement with the highest value, but lhere are many more sim-
ple calculations that we want to do on such data. 
Let'S explore how we can support this kind of calculation on sets of data in far 
greater generality. 
Please note that by deciding to express our "find highest clement" algorithm 
in terms of pointers, we "accidentally" generalized it to do more than we re-
quired: we can - as desired - lind the highest clement of an array or a vector, 
but we can also find the highest clement in part of an array or in part of a vector. 
For example: 
1/ . .. 
vector<double>& v = ·jill_dataj 
double* middle = &v(Oi+v.sizeOf1; 
double* highl = high(&vtOl. middle); 
double* high2 = high(middle, &vIO]+v.size()); 
1/ . .. 
II max of firsl half 
/I max of second half 

690 
CHAPTER 20 • CONTA IN ERS AND ITERATOR S 
Here highl will point to the clement with the largest value in the first half of the 
vector and high2 will point to the clement with the largcst value in the second 
haJf. Graphically, it will look something like this: 
&v(OJ 
Middle 
&v[OI + v.sizeO 
,-'-1--\ - --,-I'----\----.I.l:J 
highl 
high2 
We used palmer arguments for highO. That's a bit low-level and c."m be error-
prone. We suspect that for many progranuncrs, the obvious function for finding 
the clement with the largest value in a vector would look like this: 
double- find_highest(veclor<double>& v) 
{ 
) 
double h =-1; 
double· high = 0: 
for (int i=O; i<v.sizeOi ++ i) 
if (h<v[il) high = &v[i]; 
return high; 
However, that wouldn't give LIS the flexibility we "accidentally" obtained from 
highO - we can't use fjnd_highestO to find the clement with the highest value in 
part of a vector. "Ve actually achieved a practical benefit from writing a function 
that could be used fOT both arrays and vectors by "mcssing with pointers." \oVe 
will remember that: generalization can lead to functions that arc useful for more 
problems. 
20.2 STl ideals 
111e c++ standard library provides a framework for dealing with data as se~ 
quences of clements, called the STL. STL is usually said to be an acronym for 
"standard template library." 111e STL is thc part of the ISO C++ standard Ii· 
brary that provides containers (such as vector, list, and map) and generic algo-
rithms (such as sort, find, and accumulate). l11Us we can - and do - refer to 
facilities, such as vector, as being part of both "the 5TL" and "the standard li-
brary." Other standard library features, such as ostream (Chapter 10) and C-style 
string functions (§B.I0.3), arc not part of the STL. To beller appreciate and un-
derstand the 5TL, we will first consider the problems we must addrcss when 
dealing with data and lhe ideals we have for a solution. 

20 . 2 
STL IDEALS 
There are two major aspects of computing: the computation and the data. 
Sometimes we focus on the computation and talk about if·statements, loops, 
functions, error handling, etc. At other times, we focus on the data and talk about 
arrays, vectors, strings, flIes, etc. However, to get useful work done we need both. 
A large amount of data is incomprehensible without analysis, visualization, and 
searching for "the interesting bits." Conversely, we can compute as much as we 
like, but it's going to be tedious and sterile unless we have some data to tie our 
computation to something real. Furthermore, the "computation part" of our pro-
b'Tam has to clegantJy interact with tJle "data pan." 
Computation 
Read 
Write 
Input 
Output 
\,yhen we talk about data in tills way, we think of lots of data: dozens of Shapes, 
hundreds of temperature readings, thousands of log records, millions of points, 
billions of web pages, etc.; tllat is, we talk about processing containers of data, 
streams of data, etc. In particular, this is not a discussion of how best to choose a 
couple of values to represent a small object, such as a complex number, a temper-
ature reading, or a circle. For such types, see Chapters 9, 11, and 14. 
Consider some simple examples of something we'd like to do with "a lot of 
data": 
Sort tile words in dictionary order. 
Find a number in a phone book, given a name. 
Find the highest temperature. 
Find all values larger than 8800. 
Find the first occurrence of the value 17. 
Sort the telemetry records by U1llt number. 
Sort tJle telemetry records by time stamp. 
Find the first value larger than "Petersen." 
Hnd the largest amount. 
Find the first difference between two sequences. 
Compute the pair-wise product of the clements of two sequences. 
Fmd the highest temperature for each day in a month. 
Hnd tJle top ten best sellers in tile sales records. 
Count the number of occurrences of "Stroustrup" on the web. 
Compute tile sum of the elements. 
6" 

6'2 
(HAPTER 20 • CONTAINERS AND ITERATORS 
NOle U1a( we can describe each of these casks without actually mentioning how 
the data is stored. Clearly, we must. be dealing with something like lists, vectors, 
files, input streams, etc. for lilesc tasks to make sense, but we don't have to know 
the details about how the data is stored (or gathered) to talk about what to do 
with it. What is important is the type of the values or objects (the element type), 
how we access those values or objects, and what we want to do with them. 
111cse kinds of tasks are very common. Naturally, we want to write code per-
forming such tasks simply and efficiently. Converse1y, the problems for us as pro-
brrammcrs are: 
"nlere is an infinite variation of data types ("kinds of data") . 
TIlere is a bewildering number of ways to Slore collections or data clc-
ments. 
"111ere is a huge variety or tasks we'd like to do with collections or data. 
To minimize the efTect or these problems, we'd like our code to take advantage or 
commonalities among types, among the ways or storing data, and among our 
processing tasks. In other words, we wam to generalize our code to cope with 
these kinds or variations. We really don't want to hand-crart each solution rrom 
scratch; that would be a tedious waste or Urne. 
To get an idea or what support we would like ror writing our code, consider 
a more abstract view or what we do with data: 
Collect data into containers 
Such as vector, list, and array 
Organize data 
For printing 
For rast access 
Retrieve data items 
By index (e.g., the 42nd clement) 
By value (e.g., the first record with the "age field " 7) 
By properties (e.g., all records with the "temperature field" >32 and 
< lOO) 
Modirya container 
Add data 
Remove data 
Son (according to some criteria) 
Perrorm simple numeric operations (e.g., multiply all elements by 1.7) 

20.2 
STl IDEALS 
We'd like to do these t.hings without getting sucked into a swamp of details abollt 
differences among containers, differences in ways of accessing clements, and dif-
ferences among clement types. If we can do that, we'll have come a long way to-
ward our goal of simple and efficient usc of large amounts of data_ 
Looking back at the programming tools and techniques from the previous 
chapters, we note that we can (already) write programs that arc sinular independ· 
ently of the data type used: 
Using an inl isn't all that different from using a double. 
Using a veclor<int> isn't all that different from using a veClor<slring>. 
Using an alTay of double isn't all that different from using a vec-
lor<double>. 
We'd like to organize Ollr code so that we have to write new code only when \ .... e 
want to do something really new and different. In particular, we'd like to provide 
code for common progranuning tasks so that we don't have to rewrite our solu· 
tion each time we rmd a new way of storing the data or find a slightly different 
way of interpreting the data. 
Hnding a value in a vedor isn't all that different from finding a value in 
an array. 
Looking for a siring ignoring case isn't all that different from looking at 
a string considering uppercase leuers different from lowercase ones. 
Graphing experimental data with exact values isn't all that different from 
graphing data with rounded values. 
Copying a file isn't all that different from copying a vector. 
vVe want to build on these observations to write code that's 
Easy to read 
Easy to modify 
Regular 
Short 
Fast 
10 minimize our programming work, we would like 
Uniform access to data 
Independently of how it is stored 
Independently of its type 
T ypc-safe access to data 
Easy traversal of data 
Compact storage of data 

... 
Fast 
Retrieval of dam 
Addition of data 
Deletion of data 
C HAPTER 20 • CONTAINERS AND lTERATORS 
Standard versions of the most common algorithms 
Such as copy, find , search, sort, sum, . . . 
TIle STL provides that, and morc. We will look at it not just as a very useful sct 
of facilities, bLll also as an example of a library designed for ma:'(imai flexibility 
and performance. The STL was designed by Alex Stcpanov to provide a frame-
work for general, correct, and efficient algorithms operating on data structures. 
~111e ideal was the simplicity, generality, and elegance of mathematics. 
111e alternative to dealing with data using a framework with clearly articu-
lated ideals and principles is for each progranuncr 10 craft each program out of 
the basic language facilities using whatever ideas seem good at the time. "nmt'S a 
lot of extra work. Furthennore, the result is often an unprincipled mess; rarely is 
the result a program that is easily understood by people other than its original de-
sibrrler, and only by chance is the result code that we can use in other contexts. 
Having considered the motivation and the ideals, let's look at the basic defi-
nitions of the STL, and then finally get to the examples that 'U show us how to ap-
proximate those ideals - to write better code for dealing with data and to do so 
with greater ease. 
20.3 Sequences and iterators 
"111e central coneept of the STL is the sequence. From the STL point of view, a 
collection of dam is a sequence. A sequence has a beginning and an end. We can 
traverse a sequence from its beginning to its end, optionally reading or writing 
the value of each element. We identify the beginning and the end of a sequence 
by a pair of iterators. An ileralor is an object that identifies an element of a se-
quence. \.ye can think of a sequence like this: 
Here, begin and end are iterators; they identify the beginning and the end of the 
sequence. An STL sequence is what is usually called "half-open"; that is, the ele-
ment identified by begin is part of the sequence, but the e nd iterator points one 

20,3 
SEQ UEN CES AND ITER ATO RS 
beyond the end of the sequence. The usual mathematical notation for such se-
quences (ranges) is [begin:end)_ The arrows from one element to the next indi-
cate that if we have an iterator to one element we can gel an iterator to the next. 
\¥hat is an itermor? An iteralor is a rather abstract notion: 
An iteralor points to (refers to) an element of a sequence (or one beyond 
the last element). 
You can compare two iteralors using == and 1=. 
You c,.'l.1l refer to the value of the element pointed to by an iterator using 
the lInary .. operator ("dereference" or ;;colllents or'). 
YOLI can get an iterator to the next element by using ++. 
For example, if p and q arc iterators to clements of the same sequence: 
Basic standard ilerator operations 
p==q 
p!=q 
' p 
-p=val 
val=*p 
++p 
true if and only if p and q point to the same element or both point to one 
beyond the last element 
!(p==q) 
refers to the element pointed to by p 
writes to the element pointed to by p 
reads from the element pointed to by p 
makes p refer to the next element in the sequence Of to one beyond the last 
clement 
Clearly, the idea of an itcrator is related to the idea of a pointer (§17.4). In fact, a 
pointer to an element of an array is an iterator. However, many iteralOrs arc not 
just pointers; for example, we could define a range-checked iteralar that throws 
an exception if you try to make it point outside its [begin:end) sequence or tries 
to dereference end. It turns out that we gel enormous flexibility and generality 
from having iterator as an abstract notion rather than as a specific type. 1l1is 
chapter and the next will give several examples. 
TRY THI S 
Write a function void copy(int· il, int- el, int- f2) that copies the elements of 
an array of ints defmcd by [£1 :el) into another [12:f2+(el-fl»). Usc on]y the 
iterator operations mentioned above (not subscripting). 
.95 

... 
CHAPTE R 20 • CONTAINERS AN D ITERATORS 
iteralors are used to connect OUf code (algorithms) to our data. The writer of 
the code kllOWS about the iterators (and not about the details of how the itcrators 
actually get to the data), and the data provider supplies itcrators rather than ex-
posing details about how the data is stored to all users. The result is pleasingly 
simple and offers an important degree of independence between algorithms and 
containers. 1'0 quote Alex SlcprulOV: "The reason STL algorithms and containers 
work so well together is that they don't know anything about each other." In-
stead, hoth understand about sequences defmed by pairs of ileratOrs. 
sa ri, find , search, copy, .. " m y~ve ry_own_a lgo ri lhm , youf_code, 
vector, list, map. array, .. " my_conlainer, your_container, ... 
In other words, my code no longer has to know about the bewildering variety of 
ways of storing and accessing data; it just has to kllOW about iterators. Con~ 
versely, if I'm a data provider, I no longer have to write code to serve a bewilder-
ing variety of users; I just have to implement an iterator for my data. At the most 
basic level, an iterator is defined by just the . , ++, ==, and != operators. That 
makes them simple and fast. 
The STL framework consists of about ten containers and abollt 60 algo-
rithms connected by iterators (see Chapter 21). In addition, many organizations 
and individuals provide containers and algorithms in the style of the STL. TIle 
STL is probably the currently best-known and most widely lIsed example of 
generic progranuning (§19.3.2). If you know the basic concepts and a fewexam-
ples, you can use the rest. 
20.3.1 Back to the example 
Let's see how we can express the "find the eiemelll with the largest value" prob-
lem using the STL notion of a sequence: 
template<dass Iterator > 
Iterator high(lterator first, Herator last) 
II return an iterator to the element in Ifirst:lastl that has the highest value 
{ 
) 
!teratar high = first; 
far (lteratar p = first; p!=last; ++p) 
if (· high<·p) high = p; 
return high; 

20 .3 
SEQUENCES AND ITERATORS 
Note that we eliminated the local variable h that we had used to hold the highcst 
value seen so far. \¥hcn we don't know thc namc of the actual type of the ele-
mClus of the scqucnce, the initialization by - 1 secms completely arbitrary ,md 
odd. llmt's because it was arbitrmy and odd! It was also an error waiting to hap-
pen: in our example - 1 worked only because we happened nOt to have any nega-
tive velocities. We knew that "magic constants," such as - 1, are bad for code 
maintenance (§4.3.1, §7.6.1, §1O.11.1, etc.). Here, we see that they can also limit 
the utility of a function and can be a sign of incomplete thought abollt thc solu-
tion; that is, "magic constants" can bc - and often are - a sign of sloppy thinking. 
Note that t.his "generic" highO can be used for any elemcnt type that can be 
compared using <. For example, wc could use highO to find thc Icxicographically 
last string in a veclor<slring> (see exercise 7). 
11\e highO template function can be used for any sequcnce defincd by a pair 
of itcrators. For example, we can exactly rcplicate our example program: 
doublc- gcUromjack(int- coun!); II Jack puts doubles into an array and 
1/ returns the number of elements in ·count 
vcctor<double>· geUromj ill(); 
1/ Jill fills the vector 
void (ctO 
( 
) 
int jack30unt = 0; 
double jack_data = ge,-from_jack(&jack_count); 
vector<double>· jill_data = geUromj illO; 
double jack_high = high(jack_data,jack_data+jack_count); 
vcctor<double>& v = · jill_data; 
double· jill_high = high(&v[OI,&v[OI+v.size()); 
cout « "Jill's high "« · jill_high « "i Jack's high " « · jack_high; 
II ... 
delete[J jack_data; 
delete jill_data; 
For the twO calls here, the lIerator template argument type for highO is double*. 
Apal1 from (finally) getting the code for highO correct, there is apparcntly no dif· 
ference from our previous solution. To be precise, there is no difference in the 
codc that is executed, but there is a most important difference in the generality of 
our code. 111e templated version of highO can be used for every kind of se-
qucnce that can be described by a pair of iterators. Before looking at the detailed 
conventions of the STL and the useful standard algorithms that it providcs to 
save LIS from writing COlllmon tricky code, let's consider a couple of more ways 
of storing collections of data clements. 
697 

... 
( HAPTER 20 • CONTAINERS AND ITERATORS 
TRY THI S 
We again left a serious error in !.hat program. Find it, fLX it, and suggest a 
general remedy for that kind of problem. 
20.4 Linked lists 
Consider again the graphical representation of the notion of a sequence: 
Compare it to the way we visualize a vector in memory: 
beginO,' }L--' 
0: 
1: 
Basically, the subscript 0 identifies the same clement as does the iteratol' v.beginO, 
and the subscript v.sizeO identifies the ol1c-bcyond·thc-last clement also identified 
by the iterator v.end(). 
TIH~ elements of the vector arc consecutive in memory. '113t'5 not required 
by STL's notion of a sequence, and it so happens liml there are many algorithms 
where we would like to insert an e1emCIll in between two existing clements with-
out moving those existing clements. The graphical represelllation of thc abstract 
nOlion suggests the possibility of inscrting clcmelllS (and of delcting clcmcnts) 
withollt moving othcr elements. l1le 5TI.. notion of iterators supports that. 
111C data structure most dircctly suggested by tile 511... seqLlcncc diagram is 
callcd a li"ked lui. 111e arrows in the abstract model are usually implcmented as 
pointers. An clemcnt of a Iinkcd list is part of a "link" consisting of the clemelll 
and one or more pointers. A linked list where a link has just one pointer (to the 
next link) is called a sillgly-IiilRed lui and a list where a link has pointers to both tile 
previoLis and the next link is called a doubly-tinka' luI. We will sketch thc imple-
mentation of a doubly-linked list, which is what the C++ standard library pro-
vides under the name of list. Graphic.ll1y, it can be represented like this: 

2004 
UNKED LISTS 
'n,is can be represented in code as 
template<class Elem> struct Link ( 
link· prev; 
II previous link 
link· SUCCi 
/I successor (next) link 
Elem valj 
/I the value 
); 
tcmplatc<class Elem> st,u Cl list ( 
link<Elem>* firstj 
link<Elem>* lastj /I one beyond the last link 
) ; 
l11e layout of a link is 
pOft 
suee 
Oem 
~Inerc are many ways of implementing linked lists and presenting them to USCTS. 
A description of the standard library version can be found in Appendix B. Here, 
we'll just outline the key properties of a list - you can insert and delete elements 
without disturbing existing elements - show how we can iterate over a list, and 
give an example of list use. 
When you try to think about lists, we strongly encourage you to draw little 
diagrams to visualize !.he operations you are considering. Linked-list manipula-
tion really is a topic where a picture is worth lK words. 
20.4.1 List operations 
What operations do we need for a list? 
111e operations we have for vector (constnlctors, size, etc_), except sub-
scripting 
Insert (add an clement) and crase (remove an elemem) 
Something !.hat can be used to refer to clements and to traverse the list: 
an iterator 
In the STL, !.hat iterator type is a member of its class, so we'll do the same: 
6 .. 

'00 
CHAPTE R 20 • CONTAINERS ANO ITERATORS 
template<class Elem> class list ( 
/I representation and implementation details 
public: 
) ; 
class iterator; 
/I member type: iterator 
iterator beginO; 
/I iterator to first element 
iterator end( ); 
/I iterator to one beyond last element 
iterator insert(iterator p, consl Elem& v); 
iterator erase(iterator pI; 
/I insert v into list after p 
/I remove p from the I isl 
void push_back{consl Elem& v); 
II insert 11 at end 
void push_front(const Elem& v); 
1/ insert 11 at (ronl 
void pop_frontO ; 
II remove the first element 
void pop_backO; 
/1 remove the last element 
Elem& fronl O; 
Elem& back(); 
II . 
II the first element 
/I the last element 
Just as "our" vector is nOllhc complete standard library vector, this list is not lhe 
complete definition of the standard library list. Illere is nothing wrong wlth this 
list; it simply isn't complete. TIle purpose of "our" list is to convey an under-
standing of what linked lists are, how a list might be implemented, and how to 
use the key features. For more information see Appendix B or an expert-level 
C++ book. 
~nle iterator is central in the defmition of an STL list. lleraton; are used to 
identify places for insertion and elements for removal (erasure). Illey arc also 
used for "navigating" through a list rather than using subscripting. Illis use of it-
craton; is very similar to the way we used pointers to traverse arrays and vectors 
in §20.1 and §20.3.1. Illis style of iterators is the key to the standard library aI-
goritlmu (§2 U -3). 
Why not subscripting for list? We could subscript a list, but it would be a 
surprisingly slow operation: 151[1000] would involve starting from the first cle-
ment and then visiting each link along the way until we reached element number 
1000. If we want to do that, we can do it ourselves (or use advance(); see §20.6.2). 
Consequently, the standard library list doesn't provide the innocuous-looking 
subscript syntax. 
We made list's iterator type a member (a nested class) bec.."luse there was no 
reason for it to be globaL It is used only with lists. Also, this allows tiS to name 
every container's iterator type iterator. In the standard library, we have 
list<T>: :iterator, vector<T>: :iterator, map<K, v>: :iterator, and so on. 

20.4 
LI N KED LI STS 
20.4.2 Iteration 
rille list itcrator must providc . , ++, ==, and ! =. Since thc standard library list is a 
doubly-linked list, it also provides -- for iterating "backward" toward the front 
of the list: 
lemplale<class Bern> class lisI<Elem>: :iterator { 
Link<Elem>· curr; 
/I current link 
public: 
); 
iteralor{Link* p) :curr{p) {} 
ilerator& operalor++() {curr = cUrr- >succ; relurn · Ihis; } /I forwa rd 
iteralor& operator--O { curr = curr->prev; return · this; } II backward 
Elem& operator·O { return val; } II get yalue (dereference) 
bool operator==(consl ilerator& b) consl { return curr==b.curr; } 
bool operator!= (consl iteralor& b) consl { return curr! =b.curr; } 
TIlese functions arc short and simple, and obviously efficient: there are no loops, 
no complicated expressions, and no "suspicious" Function calls. If the implemcn-
tauon isn't clear to you, just have a quick look at the diagrams above. TIlls Jist it-
erator is just a pointer to a link with the required operations. Note that even 
though the implementation (the code) For a list<Elem>:: iterator is very different 
From the simplc pointer we have used as an iterator For vectors and arrays, the 
mcaning (the semantics) of the operations is identical. Basically, the List iterator 
provides suitable ++, --, *, ==, and != for a Link poimer. 
Now look at highO again: 
tempJale<class Iterator > 
Iterator high(lterator first, Iterator last) 
II return an iterator to the element in [first,last) that has the highest Yalue 
{ 
Iterator high = first; 
for (lterato, p = first; p!=lasl; ++p) 
if (*high<·p) high = p; 
return high; 
) 
We can usc it for a list: 
void fO 
{ 
lisl<int> 1st; 
701 

'02 
) 
CHAPTE R 20 • CONTAINERS AND ITERATORS 
int x; 
while (cin »
x) Isl.push_front(x); 
lisl<inl>: :iterator p = high(lst,begin(), Ist.end(); 
cout« "the highest value was" « . p « endl; 
Here, the "value" of the Iterator argument is list<int>: :iterator, and the imple-
mentation of ++, . , and ! = has changed dramatically from the alTay case, but the 
meaning is still the same. The template function highO still traverses the data 
(here a list) and finds t.be highest value. We can insert an element anywhere in a 
Jist, so we used push_irontO to add cJemcllls at the from JUSt to show that we 
could. We could equally well have used push_backO as we do for vectors. 
TRY TH 15 
The standard library vector doesn't provide push_frontO, Why not? Imple-
ment push_IrontO for vector and compare it to push_hackO. 
Now, finally, is the time to ask, "But what if the list is empty?" In other words, 
"What if Ist.begin()==lst.cndO?" In that case, . p will be an attempt to derefer-
ence the one-beyond-the-last elemem, Ist.endO : disaster! Or - potentially worse 
- the result could be a random value t.bat might be mistaken for a correct answer. 
The last formulation of the question strongly hints at the solution: we can 
test whether a list is empty by comparing beginO and endO - in fact, we can tCSt 
whether any Sll.. sequence is empty by comparing its beginning and end: 
beg;n ~~ 
r-- -, 
L _____ .J 
That's the deeper reason for having end poilll one beyond the last element rather 
than at the last clement: the empty sequence is not a special case. We dislike spe-
cial cases because - by definition - we have to remember to write special·case 
code for them. 
In our example, we could use that like this: 
lisl<inl>: :iteralor p = high(lst.beginO. Ist.end(»; 
if (p==lst.end(» 
/I did we reach the endr 
cout « "The list is empty"; 
else 
cout « "the highest value is " « . p« endl; 

20.5 
GEN ER ALIZING VECTOR YET AGAIN 
We usc this kind of test systematically with STL algorithms. 
Because the standard library provides a list, we won't go funher into the im-
plementation here. Instead, we'll have a brief look at what lists arc good for (see 
exercises 12-14 if you arc interested in Jist implementation details). 
20.5 Generalizing vector yet again 
Obviously, from the examples in §20.3-4, the standard library vector has an 
iterator member type and beginO and endO member functions (just like sid: :Iisl). 
However. we did not provide those for our veclor in Chapter 19. What docs it 
really take for different containers to be used more or less illlerchangeably in the 
STL generic programming slyle presented in §20.3? First, we'll outline the solu-
tion (ignoring allocators to simplify) and then explain it: 
template<class T> class vector { 
public: 
); 
Iypedef unsigned long size_type; 
typedef T value_type; 
typedef 1* iterator; 
typedef const 1* consUterator; 
II ... 
iterator begin(); 
consUterator beginO const; 
iterator endO; 
consUterator endO canst; 
size_type size(); 
II . . . 
A typedef creates an alias for a type; that is, for our vector, iterator is a syn-
onym, another name, for the type we chose to usc as our iterato!": 1* . Now, for a 
vector called v, we can write 
veclor<inl>: :iteralor p = find(v.beginO, v.endO,32): 
and 
for (vector<inl>: :size_lype i = 0; i<v.size(); ++i) cout« v[iJ« '\n'; 
703 

704 
CHAPTER 20 • CONTA INERS AND tTERATORS 
The point is that to write that, we don't actually have LO know what types arc 
named by iterator and size_lype. In particular, the code above, because it is ex-
pressed illlcnns of ilerator and size_type, will work with vectors where size_type 
is not an unsigned long (as it is not on many embedded systems proccSSOI's) and 
where iterator is nOt a plain pointel; but a class (as it is 0 11 many popular C++ 
implementations). 
'IllC standard defines list and the other standard containers similarly. For 
example: 
lemplate<dass Elern> class list { 
public: 
); 
class Link; 
typedef unsigned long size_type; 
typedef Elem value_type; 
class iteratorj 
/I see §20A.2 
class consCiteratorj 
II like iterator, 
/I but not allowing writes to elements 
II ... 
iterator begin(); 
consUterator besinO const; 
iterator endO; 
consUterator en dO const; 
II ... 
That way, we can write code that docs not care whether it uses a list or a vector. 
All the standard library algorithms arc defined in terms of these member type 
names, such as iterator and size_lype, so that they don't unnecessarily depend 
on the implementations of containers or exactly which kind of container they op-
erate on (sec C hapter 21). 
20.6 An example: a simple text editor 
The essential feature of a list is that you can add and remove d ements without 
moving other dements of the list. Let's try a simple example that illustrates that. 
Consider how to represent the characters of a text document in a simple text edi-
tor. TIle representation should make operations on the document simple and rea-
sonably efficient. 

20.6 
AN EX AMP LE : A SIMPLE TEXT EDITOR 
\.yhich operations? Let's assume that a document will fit in your computer's 
main memory. TImt way, we can choose any representation that suits us and simply 
convert it to a stream or bytes when we want to store it in a file. Similarly, we can 
read a stream or bytes rrom a me and convert those to our in-memory representa-
tion. "nlat decided, we can concentrate on choosing a convenient in-memory repre-
SCIltation. Basically, there are five things that alii' representation must support well: 
Constructing it rrom a stream or bytes rrom input 
Inserting one or more characters 
Deleting one or more characters 
Searching ror a string 
Generating a stream or bytes ror output to a me or a screen 
111e simplest representation would be a vector<char>. However, to add or delete 
a character we would have to move every rollowing character in the document. 
Consider: 
This is he slarl of a very long document. 
There are lois of ... 
\<\'e could add the t needed to get 
This is the start of a very long document. 
There are lots of _ . . 
However, ir those characters were stored in a single vector<char>, we'd have to 
move every character rrom h onward one position to the right. "n mt could be a 
lot or copying. In ract, ror a 70,000-character-long document (such as th.is chapter, 
couming spaces), we would on average have to move 35,000 characters to insert 
or delete a character. The resulting real-time delay is likely to be noticeable and 
annoying to users. Consequently, we "break down" our representation imo 
"chunks" so that we can change pan or the document without moving a lot or 
characters around. \Ve represent a document as a list or "lines," list<Line>, where 
a Line is a veclor<char>. For example: 
Lind 
This Is the start of a we 
Ion document 
There are tots of ... 
Now, when we insclted that I, we only had to move the rest or lhe characters on that 
line. Funhennon::, when we need to, we can add a new line wilhout moving any 
705 

706 
CHAPTER 20 • CONTAINERS AND JTERATORS 
characters. For example, we could insert "This is a new line." after "document." to 
get 
This is the start of a ve ry long docume nt. 
This is a new line. 
The re are lots of . .. 
All we needed to do was to insert a new "line" in the middle: 
Lind 
This is the start of iI we 
long document 
There are lots of ... 
[ ___ L_, 
-.-----~ 
This is a new line 
The logical reason thai it is important to be able to insert new links in a list wilh-
out moving existing links is that we might have iterators pointing to those links 
or pointers (and references) poiming to the objects in those links. Such iterators 
and pointers arc unaffected by insertions or deletions of lines. For example. a 
word processor Illay keep a vector<list<line>:: ite ratoD holding iterators to the 
beginning of evcry title and subtitle in the current Docume nt : 
. 
• , 
20.1 
202 
20.3 
: 
. 
. ~ - -- - - - -.j 
Line 1 
Strin and processin data 
Line 307 
STL Ideals 
Line 870 
S uences and iterators 
We can add lines to "paragraph 20.2" without invalidating the iterator to "para-
graph 20.3." 
In conclusion, we lise a list oflincs rather than a vector or lines or a vector or 
all the characters ror both logical and pcrfonnance reasons. Please note lh:l.l situ-
ations where these reasons apply are rather rare so that the "by derault, usc 
vector" rule or lhumb still holds. You need a specific reason to prefer a list over a 
vector - even ir you think or your data as a list or elements! (Sec §20.7.) A list is a 

20.6 
AN EXAMPLE: A SIMPLE TEXT EDITO R 
logical concept that you can represent in your program as a (linked) list or as a 
vedor. The closest STL analog to our everyday concept or a list (e.g., a to·do list, 
a list or groceries, or a schedule) is a sequence, .md most sequences are best rep· 
resented as vectors. 
20.6.1 lines 
How do we decide what's a ';line" in our document? There are three obvious 
choices: 
I . Rely on newline indicators (e.g., '\n') in user input. 
2. Somehow parse the document and usc some "natural" punctuation (e.g., .). 
3. Split any line lhat grows beyond a givcn length (e.g., 50 cllaracters) into 
two. 
111cre arc undoubtedly also some less obvious choices. For simplicity, we use al-
ternative 1 here. 
We will reprcsent a document in Ollr editor as an object or class Document. 
Stripped or all refinements, our document type looks like this: 
typedef veclor<char> line; 
1/ a line is a vector of characters 
strucl Document ( 
}; 
lisl<line> linei 
II a document is a list of lines 
II line!ij is the ilh line 
DocumentO ( line.push_back(line(»; ) 
Every Document starts alit with a single empty line: Document's constructor 
makes an empty line and pllshes it into the list or lines. 
Reading and spliuing into lines can be done like this: 
istream& operator»(islream& is, Documenl& d) 
{ 
ehar chi 
while (is»ch) ( 
d.line.back().push_back{eh); 
1/ add Ihe character 
if (eh=='\n') 
d.line.push_back(Line() i 
/I add anOlher line 
} 
return is; 
} 
707 

708 
CH APTER 20 • CONTA INER S AND ITERATORS 
Both vector and list have a member function backO that returns a reference to 
the last clement. To usc it, yOli have to be sure that there really is a last clement 
for backO LO reFer to - don't lISC it on an empty comaincr.ll1at's why we defined 
an empty Document to have one empty Line. Note umt we store every character 
from input, evell lhc newline characters ('\n'). Storing those newline characters 
gready simplifies Output, but you have to be careful how you define a character 
COlint Gust counting characters will give a number that includes space and new-
line characters). 
20.6.2 Iteration 
If the document was just a vector<char> it would be simple to iterate over it. 
How do we iterate over a list of lines? Obviously, we can iterate over the list 
using lisl<line>: :ileralor. However, what if we wamed to visit the characters one 
after another without any fuss about line breaks? We could provide an ilerator 
specifically designed for our Document : 
class TexUterator { 
/I keep track of line and character position within a line 
list<line>!! iterator In; 
line: :ileralor pos; 
public: 
); 
/I start the iterator at line II's character position pp: 
TexU leralor(list<line>: :ilerator 11, line: :iterator pp) 
:In(1l), pos(pp) {} 
char& operator*O { return *pos; } 
TexUleralor& operator++O; 
bool operalor==(const TexUterator& other) const 
{ return In==other.ln && pos==other.pos; } 
bool operator!=(const TexCileralor& other) const 
{ relurn !(*Ihis==other); } 
TexUterator& Text_iterator: :operator++O 
{ 
) 
if (pos==(*ln).end()) { 
++In ; 
/I proceed to next line 
pos = (*In).beginO; 
++pos; 
return *this; 
/I proceed to next character 

20.6 
AN EXAMPLE: A SIMPLE TEX T EDITOR 
To make TexUterator useful, we need to equip class Document with conven· 
tional beginO and end() functions: 
struct Document { 
lisf<line> line; 
TexUterator beginO 
/I first character of firSI line 
{ return TexUterator(line.beginO, (·Iine.begin()).begin()); } 
TexUterator endO 
/I one beyond the last line 
( return TexUterator{line.endO, (*Iine.end()).end()); ) 
} ; 
We need the curious p line.begin(».beginO notation because we wam the begin-
ning of what line.beginO points to; we could alternatively have used line.beginO-> 
beginO because the standard library iteracors SUppOI1 ->. 
\oVe can now iterate over the characters of a document like this: 
void print(Document& d) 
{ 
for (TexUteralor p = d.begin(); p!=d.end(); ++p) cout « · Pi 
} 
Presenting the document as a sequence of characters is useful for many lhings, 
but usually we traverse a document looking for something more specific than a 
character. For example, here is a piece of code to delete line n: 
void erase_line(Document& d, int n) 
{ 
if (n<O II d.line.size()<=n) returni 
/I ignore out·or-range lines 
d .Ii ne. erase(advan ce( d .Ii n e. begi n (), n»; 
11le call advance(n) moves an iterator n elements fon vard; advance() is a stan-
dard library function, but we could have implcmemed it ourselves like this: 
template<d ass Iter> Iter advance(lIer p, int n) 
{ 
} 
while (n>o) { ++Pi -- n; ) 
return Pi 
/I go forward 
709 

·10 
CHAPTER 20 • CONTA INERS AND IT ERATORS 
Note that advanceO can be used to simulate subscripting. In fact, for a vector 
called v, ·advance(v.beginO,n) is roughly equivalclll to vln1. Note that "roughly" 
means that advance() laboriously moves past ule first n- 1 clements one by one, 
whereas the subscript goes straight to the mh elemcm. For a list, we have to lISC 
the laborious method. It's a price we have to pay for the morc ncxiblc layout of 
the clements of a list. 
For an itcrator thal can move both forward and backward, such as the itcra-
tor for list, a negative argument to the standard library advanceO will move lhe 
itcrator backward. For an ilcralor that can handle subscripting, such as the ilcra' 
tor for a veclar, the standard library advanceO will go dirccliy to the right cle-
ment rather than slowly moving along using ++_ Clearly, the standard library 
advanceO is a bit smarter than ours. 111at's worth noticing: typically, the stan-
dard library facilities have had more care and time spel1l on them than we could 
afford, so prefer the standard facilities to "home brew." 
TRY THIS 
Rewrite advance() so that it will "go backward" when you give it a negative 
argument. 
Probably, a search is the kind of iteration that is most obvious to a user. We search 
for individual words (such as milkshake or Gavin), for sequences of letters that 
C..'l.B't easily be considered words (such as secret\nhomestead - i.e., a line ending 
with secret foUowed by a line starting WitJ1 homestead), for reb'Ular expressions 
(e.g., [bBJ\w' ne - i.e., an upper- or lowercase B followed by 0 or more letters fol-
lowed b), ne; sec Chapter 23), etc. Let's show how to handle tJ1e second eLSe, find-
ing a string, using our Document layout. We usc a simple -
non-optimal 
algoritJun: 
Find tJ1e first character of our search string in the document. 
See if that character and the following characters match our search 
string. 
If so, we arc finished; if not, we look for tJ1e next occurrence of that first 
character. 
For generality, we adopt tJ1e STL convention of defining the text in which to search 
as a sequence defined by a pair of iteralors. "111at way we can Lise our search func-
tion for any pan of a document as well as a comple!"e document. If we find an oc-
currence of aUf string in the document, we return an iterator to its frrst characler; if 
wc don't find an occurrence, we return an iterator to the cnd of tJle sequence: 

20. 7 
VECTO R, LIST. AND STR ING 
TexUterator find_txt(TexU terator first, TexUteralor last, canst string& s) 
( 
if (s,sizeO==O) return last; /I can't find an empty siring 
char first_char = slDl; 
while (true) ( 
) 
TexU teralor p = find(first,last,firsCchar); 
if (p==last II match(p,last,s)) return p; 
Returning the end of the sequence to indic.ate "not found"" is an important STL 
convention. ' 11e matchO function is trivial; it just compares two sequences of 
characters. Try writing it yoursclr. 1l1e find O used to look for a character in the 
sequence of characters is arguably the simplest standard library algorithm 
(§21.2). We can usc our find_lxtO like this: 
TexCilerator p = 
fin d _txt(my _doc, begi n () , my_doc, endO, "secret\n h om estead"); 
if (p==my_doc.end()) 
cout « "not found"; 
else ( 
/I do something 
Our "text processor" and its operations are very simple. Obviously, we arc aim~ 
ing for simplicity and reasonable efficiency, rather than at providing a "fe<lture-
rich" editor. Don't be fooled imo thinking that providing dfoiel1t insertion, 
deletion, and seard l for arbitrary character sequences is trivial, though. We chose 
this example to illustrate the power and generality of the STL concepts sequence, 
iterator, and comainer (such as list and vector) together with some STL pro-
gramming conventions (techniques), such as returning the end of a sequence to 
indicate failure. Note that if we wanted to, we could develop Document into an 
511.. container - by providing TexU terator we have done the key part of repre-
senting a Document as a sequence of values. 
20.7 vector, list, and string 
Why did we lise a list for the lines and a vector for the characters? More pre-
cisely, why did we use a list for the sequence of lines and a vector for the se-
quence of characters? Furthermore, why didn't we usc a string to hold a line? 
711 

712 
CHAPTER 20 • CON TAINERS AND lTERATO R$ 
We can ask a slightly morc general variant of this question. We have now 
seen four ways to store a sequence of characters: 
chari! (array of characters) 
vector<char> 
string 
list<char> 
How do we choose among them for a given problem? For really simple tasks, 
they arc imcrchangcablc; that is, they have very similar interfaces. For example, 
given an iteratof, we can walk through each using ++ and usc · to access the 
characters. If we look at the code examples related to Document, we can actually 
replace our vector<char> with list<char> or string without any logical problems. 
Such interchangeability is fundamentally good because it allows us to choose 
based on performance. However, before we consider pcrfonnancc, we should 
look allogicaJ propenies ohhese types: what can each do that the others can't? 
ElemU : Doesn't know its own size. Doesn't have beginO, end(), or any of 
the other useful container member functions. Can't be systematically 
range checked. Can be passed to functions written in C and C-style 
functions. TIle clements arc allocated contiguously in memory. The size 
of the array is fixed at compile lime. Comparison (== and !=) and output 
« <) usc the pointer to the first clement of the array, not the clements. 
vector<Elem>: Can do just about everything, including insert() and 
eraseO. Provides subscripting. List operations, such as insertO and 
eraseO, typically involve moving characters (that can be inefficient for 
large clements and large numbers of clements). Can be range checked. 
TIle clements arc allocated contiguously in memory. A vector is expand-
able (e.g., usc push_backO). Elements of a veclor arc stored (contigu-
ously) in an array. Comparison operators (==, !=, <, <=, >, and >=) 
compare clements. 
string: Provides all the common and useful operations plus specific text 
manipulation operations, such as conc."l.tenation (+ and +=). TIle cle-
ments are not guaranteed to be contiguous in memory. A string is ex· 
pandable. Comparison operators (==, !=, <, <=, >, and >=) compare 
clements. 
listd lem>: Provides all the common and usual operations, except sub· 
scripting. We can insertO and deleteO without moving Olher clements. 
Needs two words extra (for link pointers) for each clement. A list is ex· 
pandable. Comparison operators (==, !=, <, <=, >, and >=) compare 
clements. 

20.7 
VEC TOR, LIST, AND STRING 
AIl we have seen (§17.2, §18.5), arrays are useful and necessary for dealing with 
memory at the lowest possible level and for interfacing with code written in C 
(§27. 1.2, §27.5). Apart from that, vector is preferred because it is easier to usc, 
more flexible, and safer. 
TRY THI S 
What does that list of differences mean in real code? For each array of char, 
vector<char>, list<char>, and string, define one with the value "Hello", pass 
it to a function as an argument, write out lhe number of characters in the 
string passed, try to compare it to "Hello" in that function (to see if you re-
ally did pass "Helio"), and compare the argument to "Howdy" to see which 
would come first in a dictionary. Copy the argument into another variable of 
the sanle type. 
TRY THI S 
Do the previous Try this for an array of int, vector<int>, and lisl<int> each 
with the value {1, 2, 3, 4, 5). 
20.7.1 insert and erase 
1l1e standard library vector is our default choice for a container. It has most of 
the desired features, so we use a1tematives only if we have to. Its main problem is 
its habit of moving clements when we do list operations (inserlO and eraseO); 
that can be costly when we deal with vectors with many elements or vectors of 
large clements. Don't be too worried about that, though. We have been quite 
happy reading half a million floating-poim values into a vector using push_backO 
- measurements confirmed that pre-allocation didn't make a noticeable differ-
ence. Always measure before making significam changes in the imerest of per-
formance; even for experts, guessing about performance is very hard. 
AIl pointed out in §20.6, moving elements also implies a logical constraint: 
don't hold iterators or pointers to clements of a vector when you do JiSt opera-
tions (such as inserl(), eraseO, and push_backO): if an clement moves, your itera-
tor or pointer will point to the wrong clement 0 1' to no clement at all. This is the 
principal advantage of lists (and maps; sec §2 1.6) over vectors_ If you need a co[-
lection of large objects or of objects that you point to from many places in a pro-
gram, consider using a list. 
Let'S compare insertO and erase() for a vector and a list: First we take an ex-
ample designed only to illustrate the key points: 
713 

71. 
CHAPTER 20 • CON TAINERS AN O ITERATORS 
vector<int>: :ite rator p = v.begin(); 
++p; ++p; ++p; 
II take a vector 
/I poinl lo its 3rd element 
vector<int>: :ite rator q = Pi 
++q ; 
/I poinllo its 4th element 
v ~ P-cp ~ 
1 0 11 1 2 1 3 1 -15i''''''':'''''''''''''''''''''''''''''', 
p = v.inserl(p,99); 
/I p points at the inserted element 
P' 
q'D 
v: ~r::-o r;,T:2cr: .. 
S-~3 'i-:. T:S'-" ------------------. 
L:...l-'--'-'=-="-"--L.:...L::.J_, , , , , " , , , " , " , , , , . 
NOle that q is now invalid. "nlc clements may have been reallocated as the size of 
the vector grew. If v had spare capacity, so that it grew in place, q most likely 
points to the clement with the value 3 rather than lhe element with the value 4, 
but don't try to take advantage of that. 
p = v.erase(p); 
/I p points at the clement after the erased onc 
P G:J 
q .. D 
v ~ I . .. 
1 0 l ' 1 2 1 3 1 .. r~ I.·.·.·.·.·.·.·.·,·.·,',,·,·,·,·,',·,': ','i 
'I1ml is, an inse rtO followed by an eraseO of the inserted element leaves us back 
where we started, but with q invalidated. H owever, in between, we moved all the 
clements after the insertion point, and maybe all clements were rcloc.·ued as v grew. 
To compare, we'll do exactly the same with a list: 
lisl<inl>: :iterator p = v.begin(); 
++p; ++p; ++p; 
lisl<inl>: :iterator q = p; 
++q; 
" 
/1 take a list 
/I point to its 3rcl element 
/I point to its 4th elemenl 
P' 
q' 

20 .8 
ADAPTING OUR VECTOR TO THE STl 
p = v.inserl(p,99); 
/I P poinls at the inserted elemenl 
v ~[~}-{!J 
Note that q still poi.nts to the clement with the value 4. 
p = v.erase(p); 
"I' points at the elemenl after the erascd onc 
Again we find ourselves back where we started. However, for list as opposed to 
for vector, we didn't move any elemcnts and q was valid at all times. 
A list<char> takcs up at least three times as much mcmOly as the other three 
alternatives - on a PC a list<char> uses 12 bytcs per clement; a veclor<char> 
uses I byte per element. For large numbers of characters, that can be significant. 
In what way is a vector superior to a string? Looking at the lists of their 
properties, it seems that a string can do all that a vector can, and more. That's 
pan of the problem: since string has to do more things, it is harder to optimize. In 
fact, vector tends to be optimized for "memory operations" such as push_backO, 
whereas siring tends not to be. Instead, string lends to be optimized for handling 
of copying, for dealing with short strings, and for i.nteraction with C-style st.rings. 
In the text editor example, we chose vector because we were using insert() and 
delete(). 11131 is a perfonnance reason, though. 111e major logical difference is 
that you can have a vector of just about any clemcnt type. We have a choice only 
when we arc thinking about characters. In conclusion, prefer vector to string un-
less you need string operations, such as concatenation or reading whitespace-
separated words. 
20.8 Adapting our vector to the STL 
After adding beginO, end(), and the typedefs in §20.5, vector now JUSt lacks insertO 
and eraseO to be as close an approximation of std: :vector as we need it to be: 
lemplate<class T, class A = allocator<T> > class vector { 
int SZ j 
/I the size 
T* elem; 
/I a pointer to the elements 

716 
CHAPTER 20 • CONTAINERS AND ITERATORS 
int space; 
A alloe; 
pUblic: 
/I number of elements plus number of free space "sIOls" 
/I use allocate to handle memory for elements 
); 
1/ . .. all the other stuff from Chapter 19 and §20.5 .. . 
Iypedcf r- iteratof; 
/I Elemo is the simplest I>ossibie iterator 
iterator insert(iterator P, const T& val); 
itcrator erase(iterator p); 
We again Llsed a pointer to the clement typc, P , as the iterator type. ' nmt's the 
simplest possible solution. We left providing a range-checked iterator as an exer-
cise (exercise 18). 
Typically, people don't provide list operations, such as insert() and eraseO, 
for data types that keep their clements in contiguous storage, such as vector. 
However. list operations, such as insertO and eraseO, arc immensely lIserul and 
surprisingly efficient ror short vectors or small numbers or clements. \,Ve have re· 
peatedly seen the usefulness or push_backO, which is another operation tradi· 
tionally associated with lists. 
Basically, we implement veClor<T>: :eraseO by copying all clements artcr thc 
element we erase (remove, delete). Using the definition or vector rrom §19.3.6 
with the additions above, we get 
template<dass T, class A> 
veClor<T,A>:: iterator vector<T,A>: :erase(iterator p) 
{ 
if (p==end(» return p; 
for (iterator pos = p+1; pos!=end(); ++pos) 
·(pos-1l = ·pos; 
/I copy element ~o ne position to the left" 
alloc.destwy(&· pos); 
/I destroy surplus copy of last element 
--SZ; 
return p; 
) 
It is easier to ullderstand such code ir YOll look at a graphical representation: 
SZ: 
elem: 
space: 
................. 
=
t-r:;;;J~' ......... ',' . 
L 
, ...... . .... . ......... ,. .... ; 
: 
' 
: 
' 
.......... -.... -'-.. _·····················r·.' 
Elemellts 
(initialized) 
". "" . ...................••........ 

20.8 
ADAPTING OU R V EC TOR TO THE STL 
111e code for eraseO is quite simple, but it may be a good idea to tryout a couple of 
examples by drawing them on paper. Is the empty vector cOlTectly handled? Why 
do we need the p==endO test? What if we erased the last clemem of a vector? 
Would this code have been easier to read if we had used the subscript notation? 
Implementing vector<T,A>: :insertO is a bit more complicated: 
template<class T, class A> 
veclor<T,A>: :ilerator veclor<T,A>:: insert(ilerator p. const T& val) 
( 
int index = p- beginO; 
if (sizeO==capacily(» reserve(rsi:ze()); 
/I make sure we have space 
/I firs! copy las! elemen! into uninitialized space: 
alloc.construct(elem+sz, * backO); 
++sz; 
iteralor pp = begin()+index; 
/I the place to put val 
for (ilerator pas = endO-l ; pos!=pp; --pos) 
· pos = *(pos-l ); 
II copy elements one position to the right 
• (begin()+offset) = val; 
I/ " insert ~ val 
return pos; 
Please note: 
An iterator may not point outside its sequence, so we use pointers, such 
as elem+space, for that. 111at's one reason that allocators are defined in 
terms of pointers and nOt iterators. 
When we usc reserve(), the clements may be moved LO a new area of 
memory. 111erefore, we must remember the iJ1dex of the element to be 
erased, rather than the itcrator to it. When vector reallocates its ele· 
ments, iteraLOrs into that veclor become invalid - you can think of them 
as pointing to the old memory. 
Qur usc of the allocator argument, A, is intuitive, but inaccurate. If you 
should ever need to implement a container, you'll have to do some care· 
ful reading of the standard. 
It is sublieties like these lImt make us avoid dealing with low· level memo 
ory issues whenever we can. Naturally, the standard library vector - and 
all other standard library containers - gel that kind of importam seman· 
tic detail right. 111at's one reason to prefer the standard library over 
"home brew." 
For pel{ollua.nce reasons, you wouldn't use insertO and eraseO in thc m.iddle of a 
IOO,OOO·d emcnt vector; for that, lists (and maps; sec §21.6) are better. However, tllC 
717 

718 
C HAPTER 20 • CONTAINERS AND ITERATORS 
inserl() and eraseO operations are available for all vectors, and their pcrfonmmcc is 
unbeatable when you are just moving a few words of data - or even a few dozen 
words - because modem computers are really good at this kind of copying; sec ex-
ercise 20. Avoid Oinked) lists fOT representing a list of a few small clements. 
20.9 Adapting built-in arrays to the STl 
We have repeatedly pointed out the weaknesses of the built-in arrays: they im-
plicitly convert to pointers at the slightest provocation, they can't be copied llsing 
assignment, they don't know their own size (§ 18.5.2), etc. ""e have also pointed 
OUl their main strength: they model physical memory almost perfectly. 
To get the best of bOlh worlds, we can build an array container that provides 
the benefits of arrays without the weaknesses. A version of array was introduced 
into the standard as pan of a Technical Report. Since a feature from a TR is not 
required to be part of every implementation, array may not be part of the imple· 
mentation you use. However, the idea is simple and useful: 
template <class T, int N> 
/I not quitc thc standard array 
strud array { 
} ; 
typedefT value_type; 
typedefTo iterator; 
typedef T" consUterator; 
typedef unsigned int size_type; 
lIthe type of a subscript 
T elems[N]; 
/I no explicit construct/copy/destroy net.'<led 
iterator beginO { return elems; } 
consUterator beginO canst { return elems; } 
iterato, endO ( return elems+N; ) 
consU terator endO canst { return elems+N; } 
size_type sizeO canst; 
T& operator[](int nl { return elems[n]; } 
canst T& operator[](int nl canst { return elems[n]; } 
canst T& aUint nl canst; 
T& aUint n); 
T O dataO { return elems; } 
1/ range-checked access 
1/ range-checked access 
canst T ° data() canst { return elems; } 

20. 10 
CONTAINER OVERVIEW 
111is definition isn't complete or completely standards·conforming, but it will 
give yOll the idea, It will also give you something to use if your implementation 
doesn't yet provide the standard array. If available, it is in <array>, Note that be· 
cause array<T,N> "knows" lhat its size is N, we can (and do) provide assignment, 
==, 1=, etc. just as for vectOr, 
As an example, let's use an array with the STL version of highO from §20.4.2: 
void fO 
{ 
array<double,6> a = {O.O, 1.1, 2.2, 3.3, 4.4, 5.5}; 
array<double,6>: :iterator p = high(a.beginO, a.end()); 
cout « "Ihe highest value was " « . p « endl; 
} 
Note that we did not lhink of array when we wrote highO, Being able to usc 
highO for an array is a simple consequence of following standard conventions for 
both. 
20.10 Container overview 
~111 C Sll.. provides quite a few containers: 
Standard containers 
vector 
lisl 
deque 
m. p 
mu1timap 
a contiguously allocated sequence of elements; use it as 
the default container 
a doubly-linked list; use it when you need to insert and 
delete elements without moving existing elements 
a cross between a list and a vector; don't use it until you 
have expert-level knowledge of algorithms and machine 
architecture 
a balanced ordered tree; use it when you need to access 
elements by value (see §21.6.1 - J) 
a balanced ordered tree where there can be multiple 
copies of a key; use it when you need to access elements 
by value (see §21,6. 1- J) 
a hash table; an optimized version of map; use for large 
maps when you need high performance and can devise a 
good hash function (see §21.6.41 
719 

no 
CHAPTER 20 • CONTAINERS AND ITERATORS 
Standard containers (continued) 
unordered_multi map 
,,' 
multiset 
unordered_set 
unordered_mulliset 
array 
a hash table where there can be multiple copies of a key; 
an optimized version of multimap; use it for large maps 
when you need high performance and can devise a good 
hash function (see §21.6.4) 
a balanced ordered tree; use it when you need to keep 
track of individual v<Jlues (see §2 1.6.5) 
a balanced ordered tree where there can be multiple 
copies of a key; use it when you need to keep track of 
individual values (see §21.6.S) 
like unordered_map, but jusl with values, not (key,value) 
pairs 
like unordered_multimap, but just with values, not 
(key,value) pairs 
a fixed-size array that doesn't suffer most of the problems 
related to the built-in arrays (see §20.6) 
You can look up incredible amounts or additional inromlalion on these comain-
ers and their use in books and online documentation. Here are a rew quality in-
rormation sources: 
Austem, Mau, ed. "Technic.."ll Report on C++ Standard Library Extensions," 
ISO/IEC Pum 19768. (Colloquially known as TRI .) 
Austern, Matthew H. Generic Programming and the SrL. Addison-Wesley, 1999. 
ISBN 0201309564. 
Koenig, Andrew, ed. 'The C++ Stmuwnl. Wiley, 2003. ISBN 0470846747. ( at 
suitable ror novices.) 
Lippman, Stanley B.,Josee Lajoie, and Barbara E. Moo. 17/£ C++ Pn'l/£r. Addison-
Wesley. 2005. ISBN 0201721481. (Use only the 4th edition.) 
Musser, David R., Gillmer J. Derge, and Atul Saini. SrL 'Iiltonal mui Reference 
Gllide: c++ Programming with the Stwuwrd Template Libr(llY, &Cfmd Edition. 
Addison-Wesley, 2001. ISBN 0201379236. 
Stroustrup, Bjame. 'The C++ Programming Language. Addison-Wesley, 2000. ISBN 
0201700735. 
TIle documentation ror the SC I implememation or the STI.. and the iostream li-
brary: WW\\I.sgi.comflech/st..!. Note that they also provide complete code. 
TIle documemauon or the Dinkumware implementation or the standard library: 
www.dinkumwarc.comfmanuals/derault.aspx. (Beware or several library ver-
sions.) 
TIle documentation or the Rogue Wave implementation or the standard library: 
www2.roguewave.com!supportJdocslindex.dm. 

20.10 
CONTAINER OVERVIEW 
Do you feel cheated? Do you think we should explain all about containers 
and their use to you? That's just not possible. There are too many standard facil-
ities, too many useful techniques, and too many useful libraries for you to absorb 
them all at once. Programming is too rich a field for anyone to know all facilities 
and techniques - it can also be a noble art. As a programmer, you muSt acquire 
the habit of seeking out new information about language facilities, libraries, and 
techniques. Progranmllng is a dynanllc and rapidly developing field, so just being 
comem with what you know and are comfortable with is a recipe for being left 
behind. !;Look it up" is a perfectly reasonable answer to many problems, and as 
your skills grow and mature, it willmore and more often be tlle answer. 
On the other hand, you will find that once you understand veclor, list, and 
map and the standard algorithms presemed in Chapter 21, you'll find other STL 
and STL-style containers easy to use. You'll also find that YOll have the basic 
knowledge to understand non-SlL containers and code using them. 
What is a container? You can find the definition of an sn.. container in all of 
the sources above. Here we will just give an informal definition. An sn .. container 
Is a sequence of elements [beginO:endO). 
Container operations copy clements. Copying can be done with assign-
ment or a copy constructor. 
Names its element type value_type. 
Has iterator types called iterator and const_iterator. lterators provide · , 
++ (both prefix and postfIX), ==, and != with the appropriate semantics. 
'111e itermors for list also provide -- for moving backward in the se-
quence; that's called a bidireciWnal itemtor. TIle itcrators for vector also pro-
vide --, 11, +, and - and are called rat,,/om-aca.u lJtralors. (Sec §20.10.l.) 
Provides inserlO and eraseO, fronlO and backO, push_backO and 
pop_backO, sizeO, etc.; vector and map also provide subscripting (e.g., 
operdlor ( I). 
Provides comparison operators (==, '=, <, <=, >, and >=) that compare 
the clements. Containers use lexicographical ordering for <, <=, >, and 
>=; that is, they compare the elements in order starting with the first. 
TI1C aim of this list is to give you an overview. For more detail see Appendix B. 
For a more precisc specification and complete list, sec The C++ Programming Li· 
brill] or the standard. 
Some data types provide much of what is required from a standard container, 
but not all. We sometimes refcr to those as "almost containcrs." The most inter-
esting of those arc: 

722 
"AlmoSI containers" 
T(n] built-in array 
string 
valarray 
(HAPTER 20 • CONTAINERS AND ITERATORS 
no sizeO or other member functions; prefer a container, such as 
vector, string, or aHay, over a built-in array whcn you have a 
choice 
holds only characters but provides operations useful for text 
manipulation, such as concatenation (+ and +=); prefer Ihe 
standard siring to other strings 
a numerical vector with vector operations, but with many 
restrictions to encourage high-performance implementations; 
use only if you do a lot of vector arithmetic 
In addition, many people and many organizations have produced containers that 
meet the standard container requirements, or abllost do so. 
If in doubt, use vector. Unless you have a solid reason not to, lise vector. 
20.10.1 Iterator categories 
We have talked about iterators as ir all iterators are imerdulIlgcable. ~111e)' are in-
terchangeable if you do only the simplest operations, such as traversing a se-
quence once reading each value once. Ir you want to do more, such as iterating 
backward or subscripting, ),ou need one or the more advanced iterators. 
Iterator categories 
input iterator 
output iterator 
forward iterator 
bidirectional iterator 
We can iterate forward using ++ and read element values 
using o . This is the kind of iterator that istream offers; see 
§2 1.7.2. If (-p).m is valid, p->m can be used as a 
shorthand. 
We can iterate forward using ++ and write element values 
using -. This is the kind of iterator that ostream offers; see 
§2 1.7.2. 
We can iterate forward repeatedly using ++ and read and 
write (unless the elements are const, of course) element 
values using ' . If (Op).m is valid, p->m can be used as a 
shorthand. 
We can iterate forward (using ++) and back-. .... ard 
(using --I and read and write (unless the elements are 
consl) element values using -. This is the kind of iteratOf 
that list, map, and set offer. [f (Op).m is valid, p- >m can 
be used as a shOf1hand. 

CHAPTER 20 DR ILL 
Iterator categories (continued ) 
random·access iterator 
We can iterate forward (using ++) and backward (using - - ) 
and read and write (unless the elements are consl) element 
values using · or ( J. We can subscript and add an integer 
to a random-access iterator using + and subtract an integer 
using - . We can find the distance between two random· 
access iterators to the same sequence by subtracting one 
from the other. This is the kind of ilerator that vector offers. 
If (-p).m is valid, p->m can be used as a shonhand. 
From the operations offered, we can sec that wherever we can usc an output iter· 
atDr or an input iterator, we can use a fonvard iterator. A bidirectional iterator is 
also a forward iterator and a random·access iterator is also a bidirectional itera· 
tor. Graphically, we can represent the iterator categories like this: 
Input lie, .... 
ouIpiit-
Note that since the iterator categories arc not classes, this hierarchy is not a class 
hierarchy implemented using derivation . 
...;' Drill 
I. Define an array of ints with the ten elements { 0, 1,2,3, 4, 5, 6, 7, 8, 9 }. 
2. Define a vector<inl> with those ten elements. 
3. Define a list<inl> with those len elements. 
4. Define a second array, vector, and list, each initialized as a copy of the 
first array, vector, and list, respectively. 
5. Increase the value of each element in the array by 2; increase the value of 
each element in the vector by 3; increase the value of each element in the 
lis, by 5. 
72.1 

CHAPTER 20 • CONTAINERS AND ITERATORS 
6. Write a simple copyO operation, 
template<class Iterl, class lter2> (opy(lter fl , Iterl el, Itcr2 12); 
that copies [fl ,el ) to [f2,f2+(el-fl » just like the standard library copy 
function. Note that if fl==el the sequence is empty, so that there is noth-
ing to copy. 
7. Use your copyO to copy the array into the vector and to copy the list into 
the array. 
B. Use the standard library findO to see if the vector contains the value 3 
and print out its position if it does; use findO to see if the list contains the 
value 27 and print Out its position if it docs. TIle "position" of the first el-
ement is 0, the position of the second elemelll is 1, elc. NOle that if find() 
returns the end of the sequence, the value wasn't found. 
Remember to tCSt after each step. 
Review 
I. Why docs code wriuen by differelll people look different? Give examples. 
2. What are simple questions we ask of data? 
3. What are a few difTerem ways of storing data? 
4. \¥hat basic operations can we do to a collection of data items? 
5. \¥hat arc some ideals for the way we store our data? 
6. \¥hat is an STL sequence? 
7. \¥hat is an S1L iterator? \¥hat operations does it support? 
8. How do you move an iterator to the next clement? 
9. How do you move an iterator to the previous element? 
10. What happens if you try to move an iterator past the end of a sequence? 
11. What kinds of iteralors can you move to the previous elemelll? 
12. Why is it useful to separate data from algorithms? 
13. \¥hat is the STL? 
14. \¥hat is a linked list? How does it fundamentally difTer from a vector? 
15. What is a link (in a linked list)? 
16. \¥hat does insertO do? What does eraseO do? 
17. How do you know if a sequence is empty? 
18. What operations does an iteratar far a list provide? 
19. How do you iterate over a container using the STL? 
20. \lVhen would you use a string rather than a vector? 
2 1. \¥hen would you use a list rather than a vector? 
22. \¥hat is a container? 
23. \¥hat should beginO and end() do for a container? 
24. \¥hat containers does the STL provide? 
25. \¥hat is an iterator category? \lVhat kinds of iteratars does the STL ofTer? 
26. ' oYhat operations are provided by a random-access iterator, but not a bi-
directional iterator? 

Ct-IAI'TER 20 EXERCISES 
Terms 
algorithm 
array container 
beginO 
container 
contiguous 
doubly-linked list 
element 
Exercises 
empty sequence 
end() 
erase() 
inserl() 
iteration 
iterator 
linked list 
sequence 
si ngly~link ed list 
size_type 
STL 
typedef 
value_type 
1. If you haven't already, do all Try this exercises in the chapter. 
2. Get the J ack-and:Jill example from §20.1.2 to work. Use input from a 
couple of small files to test it. 
3. Look at the palindrome e.'l:amplcs (§18.6); redo theJ ack-and:Jill example 
from §20.1.2 using that variety of techniques . 
• L Find and ftx the errors in theJ ack-and:Jill example from §20.3. ! by using 
STL techniques throughout. 
5. Define an input and an output operator (» and « ) for vector. 
6. Write a rmd-and-replace operation for Documents based on §20.6.2. 
7. Find the lexicographical last string in an unsorted vector<string>. 
8. Define a function that counts the number of characters in a Document. 
9. Define a program that counts the number of words in a Document. Pro-
vide twO versions: one that dermes "word" as "a whitespace-separated se-
quence of characters" and one that defines "word" as "a sequence of 
consecutive alphabetic characters." For example, with the fonner defini-
tion, alpha_numeric and as12b are both single words, whereas with the 
second definition they arc both two words. 
10. Define a version of the word-counting program where the user can spec-
ify the set of whitespace characters. 
11. Given a list<inl> as a (by-reference) parameter, make a vector<double> 
and copy the clements of the list into it. Verify that the copy was com-
plete and correct. 111en print the clements sorted in order of increasing 
value. 
12. Complete the definition of list from §20.4.1-2 and get the highO exam-
ple LO n lll . Allocate a link to represent one past the end. 
13. We don't really need a "real" ol1e-past-the-end link for a Jist. Modify 
your solution LO the previous exercise to use 0 to represent a pointer to 
tbe (nonexistent) one-past-the-end link (list<Elem>: :endO); that way, the 
size of an empty list can be equal to the size of a single pointer. 
14. Define a singly-linked list, slist, in the style of sid : : list. Which operations 
from list could you reasonably eliminate from slist because it doesn't 
have back pointers? 

Tl6 
CHAPTER 20 • CONTAINERS AND rTERATOR S 
IS. Define a pvector to be like a vector of pointers except that it contains 
pointers to objects and its desuuctor deletes each object. 
16. Define an ovector that is like pvector except that the ( I and • operators 
rerum a reference lO the object poimed to by an element rather than the 
pointer. 
17. Define an ownership_vector that hold paimers to objects like pvector, 
but provides a mechanism for the user to decide which objects are owned 
by the veClOr (i.e., which objects are deleted by the deslnlctOr). Hint: 
Tills exercise is simple if you were awake for Chapter 13. 
18. Define a range·checked iterator for vector (a random·access iteTat'Or). 
19. Define a range·checked vector for list (a bidirectional iterator). 
20. Run a small timing experiment to compare the cost of using vector and 
list. You can find an explanation of how to time a program in §26.6.1. 
Generate N random int values in the range [O:N). fu each int is gener-
ated, insert it into a vector<int> (which grows by one element each time). 
Keep the vector sorted; that is, a value is inserted after every previous 
value that is less than or equal to the new value and before every previ-
ous value that is larger than the new value. Now do the same experimem 
using a lisl<int> to hold the ints. For which N is the list faster than the 
vector? Try to explain your result. This experiment was first suggested 
by John Bentley. 
Postscript 
If we have N kinds of containers of data and M things we'd like to do with tllem, 
we can easily end up writing N* M pieces of code. If the data is of K different 
types, we could even end up 'with N* M* K pieces of code. The STL addresses this 
proliferation by having tile element type as a parameter (taking care of tile K fac· 
tor) and by separating access to data from algoritluns. By using iterators to access 
data in any kind of container from any algorithm, we can make do with N+ M al-
goritllms. 1llis is a huge simplification, For example, if we have 12 containers and 
60 algoritllms, the brute-force approach would require 720 functions, whereas the 
S11.. strategy requires only 60 functions and 12 definitions of ilerators: we just 
saved ourselves 90% of tile work, In addition, the STL provides conventions for 
defining algorithms mat simplify writing correct code and composable code, so 
the saving is greater stilL 

Algorithms and Maps 
"In theory, practice is simple." 
-Trygve Reenskaug 
T
his chapler completes our presentation of the funclamclllal 
ideas of the STL and OUf survey of the facilities it offers. 
Here, we focus on algorithms. Our primary aim is to imrocluce 
you to about a dozen of the most useful ones, which will save 
you days, if not months, of work. Each is presented with exam-
ples of its uses and of programming techniques that it supports. 
OUf second aim here is to give you sufficient tools to write your 
own - elegant and efficient - algorithms if and when you need 
morc than what the standard library and other available libraries 
have to offer. In addition, we introduce three morc containers: 
map, set, and unordered_map. 
m 

'28 
21.1 Standard libraryalgorilhrns 
21.2 The simplest algorithm: findO 
21.2.1 Some generic uses 
21.3 The general search: findjfO 
21.4 Function objects 
21.4.1 An abstract view of function 
objects 
21.4.2 Prediciltes on class members 
21.5 Numerical algorithms 
21.5.1 Accumulate 
21.5.2 Gen("ralizing accumulaleO 
21.5.3 Inner product 
21.5.4 Generalizing innec produclO 
C H APTER 2 1 • ALGO RITHM S AN D MAP S 
21 .6 Associative containers 
21 .6.1 Maps 
21 .6.2 map overview 
21 .6.3 Ano ther map example 
21.6.4 unordered_map 
21.6.5 Sets 
21.7 Copying 
21.7.1 Copy 
21.7.2 Stream ite ralors 
21.7.3 Using a set to keep order 
21.7.4 copyjf 
21.8 Sorling and searching 
21.1 Standard library algorithms 
The standard library offers about 60 algorilhms. All are useful for somconc 
sometimes; we focus on some mat are often uscful for many and on somc that 
are occasionally very useful for someone: 
Selected standard algorithms 
r=find(b,e,v) 
r=find_if(b,e,p) 
x=count(b,e,v) 
x=counUHb,e,p) 
sorl(b,e) 
sort(b,e,p) 
copy(b,e,b2) 
unique_copy(b,e,b2) 
merge(b,e,b2,e2,r) 
r=equaCrange(b,e,v) 
r points to the first occurrence of v in Ib:e). 
r points to the fi rst element x in Ib:e) so that 
p(x) is true. 
x is the number of occurrences of v in Ib:e). 
x is the number of elements in Ib:e) so that 
pIx) is true. 
Sort Ib:e) using <. 
Sort [b:e) using p. 
Copy Ib: e) to Ib2:b2+(e-b»); there had better 
be enough elements after b2. 
Copy Ib: e) to [b2:b2+(e-b» ; don't copy 
adjacent duplicates. 
Merge two sorted sequences [b2:e2) and 
Ib:e) into Ir:r+(e-b)+(e2-b2» . 
r is the subsequence of the sorted range Ib:e) 
with the value v, basically, a binary search for v. 

2 1.2 
THE SIMPLEST ALGORITHM: FINDO 
Selected standard algorithms (continued ) 
equal(b,e,b2) 
x=accumulate(b,e,i) 
x=accumulate(b,e,i,op) 
Do all elements of Ib:ej and Ib2 :b2+(e-b)) 
compare equal? 
II: is the sum of i and the elements of Ib: e). 
like the other accumulate, but with the 
"sum" calculated using op. 
x:inner_product(b,e,b2,i) 
x is the inner product of Ib:e) and 
Ib2:b2+(e-b». 
x=inner_product(b,e,b2,i,op,op2) 
like the other inner-product, but with op 
and op2 instead of + and · . 
By derault, comparison ror equality is done using == and ordering is done based 
on < (lesHhan). The standard library algorithms are found in <algorithm>. For 
more information, sec §B.5 and the sources listed in §20.7. "111ese algorithms take 
one or more sequences. An input sequence is defmed by a pair or iterators; an 
output sequence is defined by an itcrator to its first element. Typically an algo-
rithm is parameterized by one or 1110~ operations that can be defined as funcuon 
objects or as functions. The algorithms usually report "failuren by returning the 
cnd of an input sequence. For example, find(b,e,v) retllms e if it doesn't find v. 
21.2 The simplest algorithm: findO 
Arguably, the simplest useful algorithm is lindO. lL finds an element with a given 
value in a sequence: 
lemplate<class In, class T> 
In find(ln first, In last, const T& val) 
II find the first element in [first,last) that equals val 
{ 
) 
while ([irsl!=last && *first != val) ++first; 
return first; 
Let's have a look at the definition of lindO. Naturally, you can use find O without 
knowing exactly how it is implemented - in ract, we have used it already (e.g., 
§20.6.2). However, the defm,ition of findO illustrates many useful design ideas, so 
it is worth looking at. 
First of all, findO operates on a sequence defined by a pair of iterators. We arc 
looking for the value val in the halr-open sequence [firsl:lasl). The result retunled 

7JO 
(HAPTER 21 • ALGORITHMS AND MAPS 
by find O is an ilcratof. That result points either to the HrSl clcmcm of the sequence 
with the value val or to last. Returning an iterator to the one-bcyond-the-Iast cle-
melll of a sequence is the most common S11. way of reporting +;nOl found." $0 we 
can usc findO like Lhis: 
void f(vector<inl>& v, inl xl 
{ 
) 
vector<int>: :ilerator p = find (v.beginO,v.endO,x)i 
if (p!=v.end()) ( 
/I we found x in v 
) 
else ( 
I/nox in v 
II. 
Here, as is COlllmon, the sequence consists of all the clcmcills of a container (an 
$TL vector). We check the returned ilcralor against the end of our sequence to 
sec if we found our value. 
We now know how to usc findO and therefore also how to usc a bunch of 
other algorithms that follow the same conventions as {indO. Before proceeding 
with more uses and morc algorithms, !et's just have a closer look at t.hat. definition: 
template<class In, class T> 
In find(ln firsl, In last, const T& val) 
) 
/I find the first element in [firs!,las!) that equals val 
while (firsl!=last && · firsf!= val) ++firsf; 
return first; 
Did you find that loop obvious at first glance? We didn't. It is actually minimal, 
efficient, and a direct representation of the fundamental aJgorithm. However, 
until you have seen a few examples, it is not obvious. Let's write it. "the pedes-
m,m wayn and see how that version compares: 
template<class In, class T> 
In find(ln first, In last, const T& val) 
II find the first element in 1first,last) that C<luals val 
{ 

21 .2 
TH E SIMPLEST ALGORITHM : FINDO 
) 
for (In p = first; p!=last; ++p) 
if (*p == val) return p; 
return last; 
These two definitions arc logically equivalent, and a really good compiler will 
generate the same code for both. However, in reality many compilers arc not 
good enough to eliminate that extra variable (p) and to rearrange the code so that 
all the testing is done in one place. Why worry and explain? Partly, because the 
style of the first (and prefcrred) version of findO has become very popular, and 
you must understand it to read mher people's code; panly, because performance 
matters exactly for small, frequently used functions that deal with lots of data. 
TRY THIS 
Are you sure those t\\TO definitions are logically equivalent? How would you 
be sure? Try constructing an argument for their being equivalent. That 
done, try both on some data. A famOllS computer scientist (Don Knuth) oncc 
said, "I have only proven the algorithm correct, nOt tested it." Even mathe-
matical proofs can contain errors. To be confident, you need to both reason 
and test. 
21.2.1 Some generic uses 
"lllC findO algorithm is generic. That means that it can be used for different data 
types. In fact, it is generic in two ways; it can be used for 
Any STL-Sty1e sequence 
Any element type 
Here are some examples (consult the diagrams in §20.4 if you get confused): 
void f(vector<inl>& v, inl x) 
/I works for vector of int 
{ 
vector<int>:: iterator p = find(v.beginO,v.endO,x); 
if (p! =v.end()) (1* we found x *1} 
II . .. 
Here. the iteration operations lIsed by find O arc those of a vector<inl>: :iterator; 
that is. ++ (in ++firsl) simply moves a pointer to the next location in memory 
(where the next clement of the vector is stored) and * (in ·first) dereferences such 
731 

732 
( HAPTER 2 1 • ALGORITHMS AND MAPS 
a pointer. The itcrator comparison (in firsl!=lasl) is a pointer comparison, and 
the value comparison (in °firsl!=val) simply compares two integers. 
Let's try wilh a list 
void f(Iist<slring>& v, string )It) 
( 
/I works for lis! of string 
list<string:>:: iteratol p = find (v.begin(),v.endO,x); 
if (p !=v.end()) {Ie we found x 01} 
II . 
} 
Here, the iteration operations used by findO arc those of a list<st,ing>: :ilerator. 
lne operators have the required meaning, so that the logic is the same as for the 
vector<int> above. The implementation is very different, though; that is, ++ (in 
++first) simply follows a pointer in the link part of the clement to where the next 
element of the list is stored, and · (in Ofirst) finds the value part of a link. TIle it-
erator comparison (in firsl!=lasl) is a pointer comparison of link-s and the value 
comparison (in · first!=val) compares strings using string's != operator. 
So, HndO is extremely flexible: as long as we obey the simple rules for itertl-
tors, we can usc findO to find clements for any sequc.nce we can think of and for 
any container we care to defme. For example, we can use find O to look for a 
character in a Document as defined in §20.6: 
void f(Documenl& v, ehar x) 
/I works for Document of char 
( 
} 
TexUterator p = find (v.begin(),v.endO,x); 
if (p!=v.end(» {r we found )( -/ } 
II . 
This kind of flexibility is the hallmark of the STL algorithms and makes them 
more useful than most people imagine when they first encounter them. 
21.3 The general search: find_if 0 
We don't actually look for a specific value all that often. More often, we arc inter-
ested in fmding a value that meets some criteria. We could get a much more use-
ful find operation if we could define our search criteria ourselves. Maybe we 
want to find a value larger than 42. Maybe we want to compare strings withou!. 
taking case (upper case vs. lower case) intO account. Maybe we want to find the 
first odd value. Maybe we want to find a record where the address field is "17 
Cherry Tree lane". 

21 .3 
THE GENE RAL SEARC H: F1ND _IFO 
"nlc standard algorithm that scarches bascd on a user-supplied critcrion is 
find_if 0 : 
template<class In, class Pred> 
In findj f(ln first, In lasl, Pred pred) 
{ 
while (firsl!=lasl && !pred(·first» ++first; 
return first; 
Obviously (when you compare the sourcc code), it is just like findO except that it 
uses !pred(Ofirst) rather th,m °firsl! =val; t.hat. is, it. stops searching once the predi-
cate predO succeeds ratller than when an element. equals a value. 
A predicate is a function that. rcLUms true or false. Clearly, findj fO requires 
a predicat.c that takes one argument. so that it can say pred(·first) . We can easily 
write a predicat.e that checks some property of a value, such as "Does t.he string 
contain the Ieuer x?" "Is the value larger than 42?" "Is the number odd?" For ex-
ample, we Co:'lIl find the first odd value in a vector of ints like this: 
boot odd(int x) { return )(%2;) 
/I % is the modulo operator 
void f(vector<int>& v) 
{ 
vector<int>:: ilerator p = fi nd_if(v.beginO, v.end(), odd); 
if (p!=v.end()) (I" we found an odd number o/} 
II. 
For t.hat call of findjfO, findjfO calls oddO for each clement lIntil it finds lhe 
first odd value. 
Similarly, we can find the first clement of a list with a value larger than 42 
like t.his: 
boollarger_than_ 42(int x) ( return x>42; ) 
void f(lisl<double>& v) 
{ 
} 
list<double>: :iteralor p = find_if(v.begin(), v.end(), IargeUhan_42); 
if (p! =v.end()) { J. we found a value > 42 0/ ) 
II . .. 
m 

CHAPTER 2 1 • ALGOR ITHMS AND MAPS 
111is last example is nOl very satisfying, though. \-Vhal if we next wanted to find 
an element larger than 41? We would have to write a new function. Find an ele-
ment larger than 19? Write yet another function. 111ere has to be a better way! 
If we want to compare to an arbitrary value v, we need somehow to make v 
an implicit argument to findjfO's predicate. We could try (choosing v_val as a 
name that is less likely to clash with other names) 
int v_val; 
IIlhe value to which larger_than_vO compares its argument 
boollarger_than_vCint xl { return x>v_val;} 
void f(lisl<double>& v, int x) 
( 
) 
v_val = 31; 
II set v_val to 31 for Ihe nexl call of larger_than_v 
list<double>:: ileralor p = find_ifCv.beginO, v.endO, larger_lhan_ v); 
if (p!=v.endOl { /* we found a value> 31 -' ) 
v_val = x; II set v_val lo x for the next call of larger_lhan_v 
list<double>: :iterator q = find_if(v.beginO, v.endO, largeUhan_v); 
if (q!=v.end()) {I- we found a value > x·' ) 
/I . .. 
Yuck! We arc convinced that people who write sllch code will eventually get what 
they deserve, but we pity their users and anyone who gets to maintain their code. 
Again : there has to be a better way! 
TRY THIS 
Why arc we so disgusted with that use of v? Give at least three ways this 
could lead to obscure errors. List three applications in which you'd particu-
larly hate to find such code. 
21.4 Function objects 
So, we want to pass a predicate to findjfO , and we want that predicate to COIll-
pare elements to a value we specify as some kind of argumem. In particular, we 
want to write something like this: 

21.4 
FUN CTION OBJECTS 
void f(list<double>& v, int x) 
{ 
list<double>: :iterator p = find_if(v.beginO, v.endO, larger_than(31»; 
if (p!=v.end(» ( r we found a value > 31 */ ) 
lisl<double>: :iterator q = find_if(v.beginO, v.endO, Larger_than(x»; 
if (q !=v.end(» {/* we found a value> x */} 
II .. . 
Obviously, larger_than must be somethiJlg that 
We can call as a predicate, e.g., pred(*first) 
Can store a value, such as 31 or x, for usc when called 
For that we need a "function object,n that is, an object that can behave like a func-
tion. We need an object because objects can store data, such as the value with 
which to compare. For example: 
class larger_than ( 
int V; 
r ub1ic: 
largeUhan(int w) : v(vv) ( ) 
bool operalorO(int x) const { return X>V; ) 
} ; 
/I store the argument 
II compare 
Interestingly, lhis definition makes the example above work as specified. Now we 
just have to figure out why it works. When we say larger_than(31) we (obviously) 
make an object of class larger_Ihan holding 31 in its data member v. For cxample: 
fi ndj f(v. beginO, v .endO,largeUhan (31 » 
Here, we pass that object to findjfO as its parameter called pred. For each cle-
ment of V, find_if() makes a call 
prcd(*nrst) 
111is invokes the call operator, called operator(), for our fUllction object llsing the 
argument ·first. TIlc resuit is a comparison of the clement's value, ·€irsl, with 31. 
What we see here is that function call can be seen as an operator, the "( ) op-
erator,n just like any other operator. TIle "() operator" is also called thejimclioT/ 
7J5 

736 
( HAI)TER 21 • ALGORITHMS AND MAPS 
call &jJeralar and the ajJjJlico.twn C!jJeratrtr. So ( ) in pred(*first) is given a meaning by 
Larger_than: :operatorO, just as subscripting in vIi] is given a meaning by 
vector: :operator[ 1. 
21 .4.1 An abstract view of function objects 
We have here a mechanism that allows for a "function
n to "carry around" data 
that it needs. Clearly, function objects provide us with a very general, powerful, 
and convenient mechanism. Consider a Illorc general notion of a function object: 
class F { 
II abstract example of a function object 
S S; 
/I state 
public: 
}; 
F(const S& 5S) :S(5S) (I· establish initial stale */ ) 
T operatorO (const S& 55) const 
( 
1/ do something with 55 to s 
/I return a value of type T (T is often void, bool. or 5) 
} 
const S& staleO const { return s;} II reveal state 
void reset(const S& ss) { s = ss; ) 
II reset state 
An object of class F holds data in its member s. If needed, a function object can 
have many data members. Another way of saying that something holds data is 
that it ';has state." When we create an F, we can initialize that state. Whenever we 
waHl to, we can read that state. For F, we provided an operation, stateO, to read 
that state and another, resetO, to write it. However, when we design a function 
object we are free to provide any way of accessing its state that we consider ap-
propriate. And, of course, we can directly or indirectly call the function object 
using the normal function call notation. We defined F to take a single argument 
when it is called, bUl we can define function objects with as many parameters as 
we need. 
Use of function objects is the main method of parameterization in the STL. 
\'\Te use function objects to specify what we are looking for in searches (§21.3), for 
defining sorting criteria (§21.4.2), for specifying arithmetic operations in numeri-
cal algorithms (§2 I.S), for defining what it means for values to be equal (§21.8), 
and for much more. The usc of function objects is a major source of flexibility 
and generality. 
Function objects are usually very efficient. In particular, passing a small func-
tion object by value to a template function typically leads to optimal perform-

2 1.4 
FUNCTI O N OB JECT S 
ance. The reason is simple, but surprising to people more familiar with passing 
functions as arguments: typically, passing a function object leads to significantly 
smaller and faster code than passing a function! ll1is is true only if the object is 
small (something like zero, one, or two words of data) or passed by reference and 
if the function call operator is small (e.g., a simple comparison using <) and de· 
fined to be iuline (e.g., has its definition within its class itself). Most of the exam· 
pies in this chapter - and in titis book - follow this pattern. ~nle basic reason for 
the high performance of small and simple function objects is that they preserve 
sufficient type information for compilers to generate optimal code. Even older 
compilers with unsophisticated optimizers call generate a simple ;'greater·than" 
machine instruction for the comparison in larger_than rather than calling a func· 
tion. Calling a function typically takes 10 to 50 times longer than executing a 
simple comparison operation. In addition, the code for a function call is several 
times larger than the code for a simple comparison. 
21.4.2 Predicates on class members 
As we have seen, standard algorithms work well with sequences of elements of 
basic types, such as inl and double. However, in some application areas, contain· 
ers of class values arc far marc common. Consider an example that is key to ap· 
plications in many areas, sorting a record by several criteria: 
struct Record { 
Siring name; 
char addr[241; 
/I standard string for ease of use 
/I old style to match database layout 
/I . . . 
l; 
vector<Record> Vf; 
Sometimes we want to SOrt vr by name, and sometimes we want to sort it by ad· 
dress. Unless we can do both elegantly and efficiently, our techniques arc of lim· 
ited practical interest. Fortunately, doing so is easy. We can write 
1/ . 
sorl(vr.beginO, vr.endO, Cmp_by_name()); 
1/ ... 
sort(vr.begin(), vr.endO, Cmp_by_addr()); 
1/ ... 
/I sort by name 
/I sort by addr 
Cmp_by_name is a function object that compares two Records by comparing their 
name members. Cmp_by_addr is a funclion object that compares twO Records by 
737 

738 
CHAPTER 2 1 • ALGORITHMS AND MAPS 
comparing their addr members. To allow the user to specify such comparison 0;-
leria, ehe standard library sort algorithm takes an optional third argument specify. 
ing the sorting crilcl;a. Cmp_by_nameO creates a Cmp_by_name for sortO to usc 
to compare Records. TIlat looks OK - meaning lhat we wouldn't mind maintain-
ing code that looked like that. Now all we have to do is to define Cmp_by_name 
and Cmp_by_addr: 
/I different comparisons for Record objects: 
slruct Cmp_by_name { 
}; 
bool operatorO(const Record& a, consl Record& b) const 
( return a.name < b.namci ) 
struct Cmp_by_addr ( 
}; 
bool operator()(const Record& a, const Record& b) const 
( return slrncmp(a.addr, b.addr, 24) < o; } 
II !!! 
The Cmp_by_name class is pretty obvious. The function call operator, opera-
torOO, simply compares the name strings using the standard string's < operator. 
However, the comparison in Cmp~by~addr is ugly. That is because we chose an 
ugly representation of the address: an array of 24 characters (not zero termi-
nated). We chose that part..ly to show how a function object can be used to hide 
ugly and en'or-prone code and partly because this particular representation was 
once presented to me as a challenge: "an ugly and important reahvorld problem 
that the STL can't handle." Well, the STL could. TIle comparison function uses 
thc standard C (and C++) library function strncmpO that compares fiXed-length 
character arrays retuming a negative number if the second "su'ing" comes lexico· 
graphically after the first. Look it up should you ever need to do such an obscure 
comparison (e.g., §B.IO.3). 
21.5 Numerical algorithms 
Most of the standard library algorithms deal with data management issues: they 
copy, sort, search, etc. data. However, a few help with numerical computations. 
TIlese numerical algorithms can be important when you compute, and they 
serve as examples of how you can express numerical algorit..luns within the STL 
framework. 
TIlere arc just four STL-style standard library numerical algorithms: 

2 1. 5 
NUMERICAL ALGORITHM S 
Numerical algorithms 
x:accumulale(b,e,i) 
x=i n ner _producl(b,e, b2, i) 
r=partial_su m(b, e, r) 
r=adjacenCdifference(b,e,b2,r) 
Add a sequence of values; e.g., for (a,b,c,d) 
produce a+b+c+d. The type of the result x is the 
type of the initial value i. 
Multiply pairs of values from two sequences and 
sum the results; e.g., for (a,b,c,d) and (e,f,g.h) 
produce aOe+b·f+c Og+doh.1he type of the result 
x is the type of the initial value i. 
Produce the sequence of sums of the first n 
clements of a sequence; e.g., for (a,b,c,d) 
produce {a, a+b, a+b+c, a+b+c+d). 
Produce the sequence of differences between 
elements of a sequence; e.g., for (a,b,c,d) 
produce (a,b-a,c-b,d-<). 
~nley are found in <numeric>. We'll describe the first two here and leave it for 
you to explore the other twO if you feet the need. 
21.5.1 Accumulate 
"Ille simplest and most useful numerical algoritlun is accumulateO. In its simplest 
form, it adds a sequence of values: 
template<class In, class T> T accumulate(ln first, In last, T init) 
( 
) 
while (firsl! =lasl) ( 
init : init + · first; 
++first; 
) 
relurn inil; 
Given an initial value, init, it simply adds every value in the [first:last) sequence 
to it and returns the sum. TIle variable in which the sum is computed, inil, is 
often referred to as the aaumu/ator. For example: 
inial) : (1, 2, 3, 4, 5 ); 
cout « accumulate(a, a+sizeof(a)/sizeof(int), 0); 
111is will prim 15, that is, 0+ I +2+3+4+5 (0 is the initial value). Obviously, accu-
mulateO can be used for all kinds of sequences: 
739 

740 
C H APTER 2 1 • ALGORITH MS AND MAPS 
void f(vector<double>& vd, in'· p, int nJ 
( 
double sum = accumulale(vd.begin(), vd.e ndO, 0.0); 
int 5um2 = accumulate(p,p+n,O); 
The type of the result (the sum) is the type of the variable that accumulaleO lIses 
to hold the accumulator. TIlls gives a degree of OexibililY that can be important. 
Fo r example: 
void f(int· p, int nl 
( 
) 
int 51 = accumulate(p, p+n, 0); 
long sl = accumulate(p, p+n, 10ng(0»; 
double 52 = accumulate(p, p+n, 0.0); 
/I sum into an inl 
II sum the ints inl0 a long 
1/ sum the ints inl0 a double 
A long has more significant digits than an int on some computers. A double can 
represent larger (and smaller) numbers than an int, but possibly with less preci-
sion. We'll revisit the rolc of range and precision in numerical computations in 
Chapter 24. 
Using the variable in which you want the result as the initializer is a popular 
idiom for specifying the type of the accumulator: 
void f(vector<double>& vd, int· p, int n) 
( 
) 
double sl = 0; 
sl = accumulate(vd.beginO, vd.endO, sl); 
int s2 = accurnulate(vd.beginO, vd.endO, s2); 
float s3 = 0; 
accurnulale(vd.begin(), vd.endO, s3); 
/I oops 
/I oops 
Do remember to initialize the accumulatOr and to assign the result of accumu-
lateO to the variable. In this example, s2 was used as an initializer before it was it· 
self initialized ; the result is therefore undefined. We passed s3 to accurnulateO 
(pass·by·value; see §8.5.3), but the result is never assigned anywhere; that compi. 
lation is just a waste of time. 
21.5.2 Generalizing accumulateO 
So, the basic three·argument accumulateO adds. However, there are many other 
useful operations, such as multiply and subtract, that we might like to do 0 11 a se· 

2 1.S 
NUMERICAL ALGORITHMS 
quence, so the STL offers a second four-argument version of accumulateO where 
we ca.Il specify the operation to be used: 
template<class In, class T, class BinOp> 
T accumulate(ln first, In last, T init, BinOp op) 
{ 
} 
while (firsl!=last) ( 
} 
init = op(init, ·first); 
++firsl; 
return init; 
Any binary operation that accepts tWO arguments of the accumulator's type ca.n 
be used here. For example: 
array<double,4> a = ( 1.1, 2.2, 3.3, 4.4 }; 
1/ see §20.9 
coul «
accumulate(a.beginO,a.endO, 1.0, multiplies<double>(»; 
Illis will prillt 35.1384, that is, 1.0* 1.1*2.2-a.3*4.4 (1.0 is the initial value). "nle bi-
nary operator supplied here, multiplies<double>O, is a standard library function 
object that multiplies; multiplics<doublc> multiplies doubles, multiplies<inl> mul· 
tiplies ints, etc. There are other binary function objects: plus (it adds), minus (it 
subtracts), divides, and modulus (it takes the remainder). TIley are all defined in 
<functional> (§B.6.2). 
Note that for products of floating-point numbers, the obvious initial value is 1.0. 
As in the sartO example (§21.4.2), we are often interested in data within class 
objects, rather than just plain built-in lypeS. For example, we might want to calcu-
late the totaJ COSt of items given the unit prices and number of units: 
slrucr Record ( 
double un ii_price; 
int units; 
/I number of units sold 
II ... 
) ; 
We ca.n let the accumulate's operator exrract the units from a Record element as 
well as multiplying it to tile accumulator value: 
double price(double v, consl Record& r) 
{ 
return" + r.uniC price • r.unils; /I calculate price and accumulate 
741 

742 
C H APTER 21 • ALGORITHMS AND MAl'S 
void f(const vector<Record>& vr) 
{ 
) 
double total = accumulale(vr.beginO, vr.endO, 0.0, price); 
" .. 
We were "lazy" and used a function, rather than a function object, to calculate the 
price - just to show that we could do that also. We tend to prefer function objects 
If they need to SLOr e a value between calls, or 
1£ they are so short that inlining can make a difference (at most a handful 
of primitive operations) 
In this example, we might have chosen a function object for the second reason. 
TRY TH 15 
Defme a veclor<Record>, in.itialize it with four records of your choice, and 
compute their total price using the functions above. 
21 .5.3 Inner product 
Take two vectors, multiply each pair of clements with the same subscript, and 
add all of those sums. That's called the limer product of the twO vectors and is a 
most useful operation in many areas (e.g., physics and linear algebra; see §24.6). 
If you prefer code to words, here is the S11.. version: 
template<class In, class In2. class T> 
T inner_produCl(ln first, In last. In2 firsl2, T init) 
/I note: this is the way we multiply twO vectors (yielding a sC<llar) 
while(firsl!=lasl) { 
) 
inil = init + (·firsl)· (Ofirst2); 
++first; 
++first2; 
return inili 
/I multiply pairs of clements 
~nus generalizes the notion of inner product to any kind of sequence of any type 
of clemclll. Iv; an example, consider a stock market index. The way that works is 

2 1.5 
NUMERICAL ALGOR ITHMS 
to take a set of companies and assign each a "weighl." For example, in the Dow 
Jones Industrial index Alcoa had a weight of 2.4808 when last we looked. To get 
the current value of the index, we multiply each company's share price: with its 
weight and add all the resulting weighted prices together. Obviously, that's the 
inner product of the prices and the weights. For example: 
II calculate the Dow Jones Industrial index: 
vector<double> dow_price; 
/I share price for each company 
dow _p rice. push_ back(81 .86); 
dow_price.push_back(34.69}; 
dow_price.push_back(54.4S); 
/I . .. 
lisl<double> dow_weighl; 
/I weight in index for each company 
dow_weight.push_back(S.8549); 
dow_weight.push_back(2.4808); 
dow_weighl.push_back(3.8940); 
/I ... 
double djU ndex = inner_producl( /I multiply (weight,value) pairs and add 
dow_price.beginO, dow_price.endO, 
dow_weighl.beginO, 
O.O}; 
coul « "DJ! value " «
djU ndex « '\n'; 
Note that inner_produclO takes two sequences. However, it takes only threc ar· 
guments: only the beginning of the second sequence is mentioned. The second 
sequence is supposed to have at least as many clements as the first. If not, we 
have a run·time error. As far as inner_produclO is concerned, it is OK for the sec· 
and sequence to have more clements than the first; those "surplus elements" wi ll 
simply not be used. 
' 11e twO sequences need not be of the same type, nor do they need to have 
tIle same clement types. To illustrate this point, we used a vector to hold the 
prices and a lisl to hold t.he weights. 
21.5.4 Generalizing inner_productO 
'11e inner_productO " 'til be generalized JUSt as accumulaleO was. For inner_prod-
uctO we need twO extra arguments, though: one to combine the accumulator with 
the new value, exactly as for accumulaleO, and one for combining the ciemem 
value pairs: 
743 

744 
C H APTE R 21 
• ALGOR ITHMS AND MAPS 
template<class In, class In2, class T, class BinOp, class BinOp2 > 
T inner_product(1n first, In last, 1"2 fifSl2, T init, BinOp op, BinOp2 op2) 
{ 
while(firsl!=last) ( 
inil = op(init, op2(-first, -first2»; 
++first; 
++first2; 
return init; 
) 
til §21.6.3, we rerum to the Dow Jones example and usc this gencrruized 
inncr_productO as part of a more elegant solution. 
21.6 Associative containers 
After vector, the most useful standard library container is probably the map. A 
map is an ordered sequence of (key, value) pairs in which you can look up a value 
based on a key; for example, my_phone_bookl "Nicholas"J could be the phone 
number of Nicholas. The only potential competitor to map in a popularity con-
test is unordered_map (see §21.6.4), and that's a map optimized for keys that are 
strings. Data structures similar to map and unordered_map arc known under 
many names, such as a.uociaJiue arrays, hash tahles, and red-black trees. Popular and 
useful concepts always seem to have many names. In the standard library, we col-
lectively call all such data structures assOOatiue am/aillerJ. 
The standard library provides eight associative contai.ners: 
Associative containers 
m. p 
set 
unordered_map 
unordered_set 
multimap 
mullisel 
unordered_mullimap 
unordered_multiset 
an ordered container of (key,value) pairs 
an ordered container of keys 
an unordered container of (key, value) pairs 
an unordered container of keys 
a map where a key can occur multiple times 
a sel where a key can occur multiple times 
an unordered_map where a key can occur multiple times 
an unordered_set where a key can occur multiple limes 
These containers arc found III <map>, <sel>, <unordered_map>, and <un-
ordered_set>. 

2 1.6 
ASSO CIATIVE CONTAINER S 
21.6.1 Maps 
Consider a conceptually simple task: make a list of the number of occurrences of 
words in a t'ext. TIle obvious way of doing this is to keep a list of words we have 
seen together with the number of times we have seen each. When we read a new 
word, we see if we have already seen it; if we have, we increase its COUilt by one; 
if not, we insert it in our list and give it the value I. We could do that using a list 
or a vector, but then we would have to do a search for each word \"'c read. TIlat 
could be slow. A map stores its keys in a way that makes it easy to sec if a key is 
present, thus making the searching part of our task trivial: 
int mainO 
{ 
map<Slring,inl> wordSi 
string Si 
II keep (word,frequency) pairs 
while (cin»s) ++words[sl; II nOle: words is subscripted by a siring 
} 
Iypedef map<Slring,int>: :consUterator Iter; 
for (Iter p = words.beginO; p!=words.endO; ++p) 
cout « p- >first « ": "« p->second« '\n'; 
The really interesting part of the program is ++words[s). As we can see from the 
fITSt line of mainO, words is a map of (string,int) pairs ; that is, words maps 
strings to ints. In other words, given a string, words can give us access to its cor· 
responding int. So, when we subscript words with a string (holding a word rcad 
from our input), wordsls1 is a reference to the int corresponding to s. Let's look 
at a concrete example: 
wordsl"sultan") 
If we have not seen the string "sullan" before, "sultan" will be entered into words 
Wilh the default value for an inl, which is O. Now, words has an entry ("sultan" ,O). 
h follows that if we haven't seen "sultan" before, ++words["sullan"] will associate 
the value 1 with the string "sultan". In detail: the map will discover that "sultan" 
wasn't found, insert a ("sultan",O) pair, and then ++ will increment that value, 
yielding 1. 
Now look again at the program: ++words[s] takes every "word" we get from 
input and increases its value by one. The ftrst time a new word is seen, it gets the 
value 1. Now the meaning of the loop is clear: 
while (cin»s) ++wordsls]; 
745 

746 
CHAPTER 21 • ALCORITHMS AND MAPS 
This reads every (whitespace-separatcd) word on input and computes the num-
ber of occurrences for each. Now all we have to do is to produce the output. We 
can iterate though a map, just like any oilier STL container. The clements of a 
map<Slring,int> are of type pair<string,int>. The flrst member of a pair is called 
fi rst and the second member second, so lhe output loop becomes 
typedef map<string,inl>: :consUterator lIer; 
for (lfer p = words.beginO; p!=words.endO; ++p) 
coul « p->first « n: " «
p->second « '\n'; 
The typedef (§20.5 and §A.16) is just for notational convenience and readability. 
As a test, we can feed the opening statements of the first edition of 1M C++ 
Programming lAnguage to our program: 
c++ is a general purpose programming language designed to make pro-
gramming more enjoyable for the serious programmer. Except for minor 
details, C++ is a superset of the C progrnnunillg language. In addition to 
the facilities provided by C, C++ provides flexible and efficient facilities 
for defining new types. 
We gel the output 
C: 1 
C++:3 
C,: 1 
Excepl: 1 
In : 1 
a: 2 
addition: 1 
and : 1 
by: 1 
defining: 1 
designed : 1 
delails,: 1 
efficient: 1 
e njoyable: 1 
facilities: 2 
flexible: 1 
for: 3 
general: 1 
is: 2 

2 1.6 
ASSOCIATIVE CONTAINERS 
language: 1 
language.: 1 
make: 1 
minor: 1 
more: 1 
new: 1 
of: 1 
programmer.: 1 
programming: 3 
provided : 1 
provides: 1 
purpose: 1 
serious: 1 
superset: 1 
the: 3 
to: 2 
types.: 1 
If we don't like to distinguish between upper- and lowercase letters or would like 
to eliminate punctuation, we can do so: see exercise 13. 
21.6.2 map overview 
$0 whm is a map? TIlere is a variety of ways of implementing maps, but the STL 
map implementations tend to be balanced binary search trees; more specifically, 
they arc red-black tTees. We will not go into details, but now you know the tech-
nical terms, so you can look them up in the literature or on the web, should you 
want to know more. 
A tree is built up from nodes (in a way similar to a Jist being built from links; 
sec §20.4). A Node holds a key, its corresponding value, and pointers to two de-
scendant Nodes. 
Map node: Key lint 
Vaiue second 
Node-left 
_·right 
Here is the way a map<fruil ,int> nlight look in memory assuming we had in-
serted (Kiwi,IOO), (Qoince,O), (Plum,8), (Apple,7), (Grnpe,2345), and (Ornnge,99) 
into it: 
747 

748 
CHAPTE R 2 1 • ALG ORITHMS AND MAPS 
Fruits: 
Orangt: 99 
Grnp< 2345 
Appl< 7 
KiM 100 
Plum 8 
: One ~~-b"s; -: 
!... ______________ J 
Given that the name of the Node member that holds the key vaJue is first, the 
basic rule of a binary search tree is 
lefl->firstdirst && firsl<right- >first 
TImt is, for every node, 
Its left sub-node has a key that is less than the node's key, and 
TIle node's key is less than the key of its right sub-node 
You can verify that this holds for each node in the tree. That aJlows us to search 
"down the tree from its root." Curiollsly enough, in computer science literature 
trees grow downward from their roots. In the example, the root node is (Orange, 
99). We just compare our way down the tree until we fllld what we are looking 
for or the place where it should have been. A tree is called Ixdnnad when (as in 
the example above) each sub-tree has approximately as many nodes as every 
other sub-tree that's equaJly far from the rOOL Being balanced minimizes the av-
erage number of nodes we have to visit to reach a node. 
A Node may also hold some more data which the map will use to keep its 
tree of nodes balanced. A tree is balanced when each node has about as many de-
scendants to its left as to its right. If a tree with .N nodes is balanced, we have to at 
most look at 10~ (.N) nodes to Ulld a node. That's much better than the average 
of M2 nodes we have to examine if we had the keys in a list and searched from 
the begilUung (the worst case for such a linear search is X ). (Sec also §2 1.6.4.) 
For example, have a look at an unbaJanced tree: 
Fruits: 
Orange 99 
Grnp< 2345 
Qyinc< 0 
Appl< 7 
Kiwi 100 

21.6 
ASSOCIATIVE CONTAINERS 
lois tree still meets the criteria that the key of every node is greater than that of 
its left sub-node and less than that of its right sub-node: 
left->firsldirsl && firsl<right->first 
However, this version of the tree is unbalanced, so we now have three "hops" to 
reach Apple and Kiwi, rather than the two we had in the balanced tree. For trees 
of many nodes the difference can be very significant, so the trees used to imple-
ment maps are balanced. 
We don't have to understand about trees to use map. It is just reasonable to 
assume that professionals understand at least the fundamentals of their tools. 
W hat we do have to understand is the interface to map provided by the standard 
library. Here is a slightly simplified version: 
templale<class Key, class Value, class emp = less<Key> > class map ( 
1/ . 
); 
typedef pair<Key,Value> value_lype; /I a map deals in (Key, Value} pairs 
typedef sometypel iterator; 
II probably a pointer to a tree node 
typedef sometype2 consCilerator; 
iterator begin(); 
iterator e ndO; 
II points to first element 
/I points one beyond the last element 
Value& operator[](const Key& k); 
If subscript with k 
iterator find (const Key& k); 
If is there an entry for k? 
void erase(iteralor pI; 
II remove element pointed to by p 
pair<iteralor, banI> inserl(const value_type&); II insert a (key,value) pair 
1/ ... 
You can find the real version in <map>. You can imagine the iterator to be a Node" 
but you cannot rely on your implementation using that specific type to implement 
iterator. 
"Dle similarity to the interfaces for vector and list (§20.5 and §B.4) is obvious. 
TIle main difference is that when you iterate, the elements are pairs ~ of type 
pair<Key,Value>. That type is another useful sn type: 
templale<class T1, class 12> strue! pair { 
typedef T1 firsUype; 
typedef 12 second_type; 
749 

751l 
); 
( HAPTER 21 • ALGORITHMS AND MAPS 
T1 first; 
T2 second; 
pairO :first(Tl{)), second(T2()) ( ) 
pair(consl T1& x, consl T2& y) :first(x), second(y) () 
lemplate<class U, class v> 
pair(const pair<U,V>& p) :firsl(p.firsl), second(p.second) ( ) 
template<class T1 , class 12> 
pair<T1 ,T2> make_pair(Tl x, T2 y) 
( 
re turn pair<T1 ,T2>(x,y); 
We copied the complete deflIlition of pair and its useful helper function make_pairO 
from the standard. 
Note that when you iterate over a map. the elements will come in the order 
defined by the key. For example, if we iterated over the fruits in the example, we 
would get 
(Apple,n (Grape,l00) (Kiwi,2345) (Orange,99) (Plum,B) (Quince ,O) 
111c order in which we inserted those fruits doesn't matter. 
TIle inser(() operation has an odd rerum value, which we most orten ignore 
in simple programs. It is a pair of an iterator to the (key, value) clement and a 
bool which is true if the {key, value) pair was insened by this call of inserlO. If the 
key was already in the map, the insertion fails and the bool is false. 
Note that you can define the meaning of the order used by a map by supply· 
ing a third argument (Cmp in the map declaration). For example: 
map<slring, double, No_case> m; 
No_case defines case-insensitive compare; see §21.8. By default the order is de· 
fined by less<Key>, meaning less-than. 
21.6.3 Another map example 
To better appreciate the utility of map, let's return to the Dow Jones example 
from §21.5.3. TIle code there was eOlTect if and only if an weights appear in the 
same position in their vector as their corresponding name. 111at'S implicit and 
could easily be the source of an obscure bug. TIlcre are many ways of attacking 
that problem, but one attractive one is to keep each weight together with its COIll-
pany's Licker symbol, e.g., ("AA",2.4808). A "ticker symbol" is an abbreviation of 

21 ,6 
ASSOC IATIVE CONTAINERS 
a company !laille used where a terse representation is needed. Similarly we can 
keep the company's ticker symbol together with its share price, e.g., 
("AA",34.69). Finally, ror those or us who don't regularly deal with lhe U.S. stock 
market, we can keep the company's ticker symbol together with the company 
name, e.g., ("AA","Akoa lne.
n ); that is, we could keep three maps or cOiTespon· 
ding values. 
i<irst we make the (symbol,price) map: 
map<Slring,double> dow_price; 
/I Dow Jones Industrial index (symbol,price); 
/I for up-ta-date quotes see www.djindexes.eom 
dow_price{"MMM") = 81.86; 
dow_price ("AA"} = 34.69; 
dow_price ["MO"} = 54.45; 
/I . .. 
TIle (symbol,weight) map: 
map<string,double> dow_weight; /I Dow (symbol.wcightJ 
dow_weight.insert(make_pair("MMM", 5.8549)); 
dow_weight.insert(make_pair(" AA" ,2.4808)); 
dow_weigh t. i nsert(ma ke _pai r(" MO" ,3 .8940) l; 
/I . . 
We used insertO and make_pairO to show that the clements or a map reaJly are 
pairs. The eXillllple also illustrates lhe value or notation; we find the subscript no-
Lation easier to read and - less important - easier to write. 
-nle (symbol,name) map: 
map<string,slring> dow_name; 
1/ Dow (symbol,name) 
dow_name["MMM") = "3M Co."; 
dow_namef"AA"l = "Alcoa Inc."; 
dow_nameI"MO"1 = "AUria Group Inc."; 
/I . .. 
Given those maps, we can convenicmly extract all kinds or information. For 
example: 
double alcoa_price = dow_price ("AAA"); 
double boeins.-price = dow-price ["BA"); 
/1 read values from a map 
if (dow-price.find("INTC") != dow_price.end(» II fi nd an entry in a map 
cout « "Intel is in the Dow\n"; 
751 

752 
C HAPTER 2 1 • ALGOR ITH M S AND MAPS 
Iterating through a map is easy. We just have LO remember lha! lhe key is caJled 
first aud the value is called second : 
typedef map<String,double>: :consUteralor Dowj teratofj 
/I write price (or each company in the Dow index: 
for (Dow_iterator p = dow_price.beginOj p!=dow_price.endOj ++p) { 
const string& symbol = p->firslj 
/I the "ticker" symbol 
cout « symbol «'\1' 
«
p->sccond «'\I' 
«
dow_name[symboIJ« '\n'j 
) 
We can even do some computation directly using maps. In particular, we call ca1-
culatc the index, just as we did in §2 1.5.3. We have to extract share values and 
weights from their respective maps and multiply them. We can easily write a 
function for doing that for any tWO map<String,double>s: 
double weighted_value( 
{ 
) 
consl pair<slring,do uble>& a, 
const pair<string,do uble>& b 
) lIextract values and multiply 
return a.second .. b.second; 
Now we just plug that function into the generalized version of inner-productO 
and we have the value or our index: 
double djUndex = 
inner_product{dow_price.beginO, dow_price.endO, II all companies 
dow_wcight.beginO, 
II their weights 
0.0, 
/I initial value 
plus<double>(), 
/I add (as usual) 
weighted_value); 
II extract values and weights 
II and multiply 
Why might someone keep such data in maps rather than vedors? We used a 
map to make the association between the different values explicit. 11mt's one 
common reason. Another is that a map keeps its clements in the order defllled by 
its key. When we iterated through dow above, we output the symbols in alpha-
belical order; had we used a vector we would have had to son . 111e most com-

{ 
2 1.6 
ASSOCIATIvE CONTAINERS 
mon reason to use a map is simply that we want to look up values based on the 
key. For large sequences, finding something using findO is far slower than look-
ing it up in a sorted structure, such as a map. 
TRY TH IS 
Get this liule example to work. Then add a few companies of your own 
choice, with weights of your choice. 
21 .6.4 unordered_map 
10 find an clement in a vector, findO needs to examine all the clements from the 
beginning to the clement with the right value or to the end. On average, tile COSt 
is proportional to the length of the vector (N); we call that cost O(N}. 
To find an clement in a map, the subscript operator needs to examine all tile 
elements of the ITee from the root to the clement with the right value or to a leaf. 
On average the cost is proportionaJ to the depth of the trec. A balanced binary 
trce holding N clements has a maximum depth of lo~(N); the cost is O(1o&(N )). 
O(lo&(N)) - lhat is, cost proportional to 10&(N) - is actually pretty good com-
pared to O(N): 
J{ 
15 
128 
1023 
16,383 
log,(N) 
4 
7 
10 
14 
~nle actual cost will depend on how soon in our search we find our vaJues and 
how expensive comparisons and iterations arc. It is usually somewhat more ex-
pensive to chase pointers (as the map lookup does) than to increment a pointer 
(as findO does in a vector). 
For some types, notably integers and dmracter strings, we can do even better 
than a map's tree search. We will not go into details, but the idea is that given a 
key, we compute an index into a vector. That index is called a haJh value and a 
container that uses this technique is lypically called a haJh tabk. The number of 
possible keys is far larger thall the number of slots in the hash table. For example, 
we often use a hash function to map from the billions of possible strings into an 
index for a vector with 1000 clements. This can be tricky, but it can be handled 
well and is especially useful for implementing large maps. TIle main virtue of a 
hash table is that on average the cost of a lookup is (ncar) constant and inde· 
pendent of the number of elements in the table, that is, 0(1). Obviously, that C.1.1l 
be a significant advantage for large maps, say a map of 500,000 web addresses. 
For more information about hash lookup, you can look at the documentation for 
unordered_map (available on the web) or just about any basic text on data Struc-
lures (look for hash table and hashi1lg). 
753 

754 
( HAPTER 2 1 • ALGORITHMS AND MAPS 
We can illustrate lookup in an (unsoncd) vector, a balanced binary tree, and 
a hash wblc graphically like this: 
Lookup in unsoncd vector: 
···+++++1 
Lookup in map (balanced binary (fcc): 
Lookup in unordered_map (hash table): 
'. ' . 
TIle STL unordered_map is implemented using a hash table, just as the 511... 
map is implcmcmcd using a balanced binary tree, and an STL vector is imple-
mented using an array. Part of the utility of the STL is to fit all of these ways of 
storing and accessing data into a common framework together with algorithms. 
The rule of thumb is: 
Usc vector unless you have a good reason not to. 
Usc map if you need to look up based on a value (and if your key type 
has a reasonable and efficient less-than operation). 
Usc unordered_map if you need 10 do a lot of lookup in a large map and 
YOli don't need an ordered traversal (and if you can lind a good hash 
function for your key type). 
Here, we will nO( describe unordered_map in any detail. You can use an un-
ordered_map with a key of type string or int exacLly like a map, except Lllat 
when you iteratc ovcr the clements, the clements will not be ordered. For exam· 
pie, we could rewrite part of the Dow Jones example from §21.6.3 like this: 

21.6 
ASSOCIATIVE CON TAINERS 
unordered_map<string,double> dow_price; 
typedef unordered_map<slring,double>: :consU lerator Dow_iterator; 
for (Dow_ilerator p = dow_price.beginO; p!=dow_price.endO; ++p) { 
const string& symbol = p->first; 
/I the "ticker" symbol 
cout« symbol « '\t' 
«p->second « '\1' 
«dow_namelsymboll « '\n'; 
) 
Lookup in dow might now be faster. However, that would not be significant be· 
cause there arc only 30 companies in that index. Had we been keeping the prices 
of all the companies on the New York Stock Exchange, we might have noticed a 
performance difference. We will, however, notice a logica1 difference: the omput 
from the iteration will now nOt be in a1phabetica1 order. 
The unordered maps arc new in the context of the C++ standard and not 
yet quite "first-class members,1t as they are defined in a Technical Report rather 
than in the standard proper. TIley arc widely available, though, and where they 
arc not you can often find their ancestors, called something like hash_map. 
TRY THIS 
Write a small program using #include<unordered_map>. If thaI. doesn't 
work, unordered_map wasn't shipped with your C++ implementation. If 
you really need unordered_map, you have to download one of the available 
implementations (e.g., see www.boost.org). 
21.6.5 Sels 
We can think of a set as a map where we are not interested in the values, or 
rather as a map without values. We can visualize a set node like t.his: 
Sci node: 
Key first 
Node-left 
Node· right 
We can l"epreSeill the set offmits used in the map example (§21.6.2) like this: 
755 

756 
CHAPTER 21 • ALGORIT HMS AND MAPS 
Fmits: 
Orange 
Crape 
Qymce 
:-~; b-e~~d-I~~ ': 
!.. • • _ • • • _- • • _ • • _ • • • ' 
What are sets useful for? As it happens, there arc lots of problems that require us 
to remember if we have seen a value. Keeping track of which fruits are available 
(independently of price) is one example; building a dictionary is anothcr. A 
slightly different style of usage is having a set of "records
n
; that is, the clements 
arc objects that potentially contain "lots or' infonnation - we simply lise a memo 
ber as the key. For example: 
stfuci Fruit { 
string name; 
int count; 
I; 
double uniCprice; 
Date lasCsale_date; 
II ... 
struct Fruit_order ( 
I; 
bool operatorO(consl Fruit& a, const Fruit& b) const 
{ 
return a.name<b.name; 
set<Fruit, Fruit_order> inventory; 
Here again, we sec how using a function object can significantly increase the 
range of problems for which an STL component is useful. 
Since set doesn't have a value type, it doesn't support subscripting (operalorOO) 
either. We must use "list operations;' SUdl as insertO and eraseO, instead. Unfortu-
nately, map and set don't support Jlush_backO either - the reason is obvious: I.hc 
set and not UIC programmer del.cnlllllcs where the new vallie is inserted. Instead 
use in seriO. For example: 
i nve nlory. i nsert(Fru it(" qui nee" .5)); 
inventory.insert(Fruit("apple", 200, 0.37»; 

2 1.7 
COPYING 
One advantage of set over map is that you can use the vallie obtained from 
an ilerator directly. Since there is no (key,value) pair as for map (§21.6.3), the 
dereference operator gives a value of the eleillent type: 
Iypedef set<fruit>: :consUterator 51; 
for (51 p = inventory.beginO, p!=inventory.endO; ++p) cout« *p « '\n'; 
Assuming, of course, that you have defined « for Fruit. 
21.7 Copying 
In §21.2, we deemed findO "the simplest useful algorithm." Naturally, lhat point 
can be argued. Many simple algorithms arc useful - even some t.hat arc trivial 10 
write. \oVhy bother to write new code when you can use what others have written 
and debugged for you, however simple? When it comes to simplicity and utility, 
copyO gives findO a run for its money. The sn.. provides three versions of copy: 
Copy operations 
copy(b,e,b2) 
Copy Ib:c) to Ib2:b2+(e-b»). 
unique_copy(b,e,b2) 
Copy Ib:e) 10 Ib2:b2+(e-b»; suppress adjacent copies. 
copy_if(b,e,b2,p) 
Copy lb:e) to Ib2:b2+(e-b»), but only elements that meet 
the predicate p. 
21.7.1 Copy 
TIle basic copy algorithm is defined like this: 
templale<c1ass In, class Out> Out copy(ln first, In last, Out res) 
( 
) 
while (first! =last) ( 
· res = · first; /I copy element 
++rcs; 
++first; 
return res; 
Givcn a pair of iterators, copyO copies a scquence into another sequence speci-
fied by an itcrator to its first clement. For example: 
757 

758 
(HAPTER 21 • ALGORITHMS AND MAPS 
void f(vector<double>& vd, list<int>& Ii) 
{ 
II copy the elements of a list of ints into a vector of doubles 
if (vd.sizeO < li.sizeO) error("larget container too small"); 
copy(li.beginO, li.end(), vd.begin(); 
II . .. 
Note that the type of the input sequence of copyO can be differclll from the type 
of the output sequence. TIlal'S a useful generality of sn... algorithms: they work 
for all kinds of sequences without making unnecessary assumptions about their 
implementation. We remembered to check that there was enough space in the 
output sequence to hold the clements we put there. It's the programmer's job to 
check such sizes. 511.. algoritluns arc programmed for maximal generality and 
optimal performance; they do not (by default) do range checking or other poten, 
tially expensive tests to protect their users, At times, you'll wish they did, but 
when you want checking, you can add it as we did above. 
21 .7.2 Stream iterators 
You will have heard the phrases "copy to output" and "copy from input.
n 11mt's a 
nice and useful way of thinking of some forms of 110 , and we can actually use 
copy to do exactly that. 
Remember that a sequcnce is something 
With a beginning and an end 
Where we can get to the next element using ++ 
Where we can get the value of the current clement using · 
We can easily represent input and output streams that way. For example: 
oSlreamj leralor<slring> oo(coul); 
/I assigning to ·00 is to write to cout 
·00 = "Hello, "i 
++00: 
·00 = "World !\n ": 
/I meaning cout « "Hello, " 
/I "get ready for next output operation ~ 
/I meaning cout « 'World! \ n" 
YOLI can imagine how this could be implemented. ~l1l e standard library provides 
an oslream_ileralor type that works like that; oSlreamj leralor<T> is an iterator 
that you can lise to write valucs of type T. 
Similarly, the standard library provides tllC type iSlream_ileralor<T> for read-
ing valucs of type T: 

2 1. 7 
COPYING 
islream_ileralor<slring> ii(dn): /I reading ·ii is to read a string from cin 
// meaning cin» sl 
siring s1 = · ii; 
Hii; 
string s2 = · ii; 
/I Nget ready for the next input operation
N 
/I meaning cin» s2 
Using oSlrearn_iterator and istrearn_iterator, we can use copyO for our 110. For 
example, we can make a "quick and dirty" dictionary like this: 
int rnainO 
( 
} 
string from, to; 
dn » from »to; 
ifstream is(from.c_slrO); 
of stream os(lo.c_str(»; 
istrearn_iterator<string> ii(is); 
istrearn_iterator<string> eos; 
oslrearn_ilerator<string> oo(os, "\nil); 
vector<string> b(ii,eos); 
sort(b.beginO ,b.end()): 
copy(b.beginO ,b.endO ,00); 
/I get source and target fi le names 
1/ open input stream 
/1 open output stream 
/1 make input iterator for stream 
1/ input sentinel 
/1 make output ilerator for stream 
1/ b is a vector initialized from input 
/I sort the buffer 
/I copy buffer to output 
The iterator eos is the stream iterator's representation of "end of inpllt." When 
an istream reaches end of input (of len referred to as eof), its iSlreamj terator will 
equal the default istreamjterator (here called cos). 
Note that we initialized the vector by a pair of iterators. As the initializers for 
a container, a pair of iterators (a,b) means "Read the sequence [a:b) into the con· 
tainer." Naturally, the pair of iterators that we used was (ii,eos) - the beginning 
and end of input. That saves us from explicitly using » and push_backO. We 
strongly advise against the alternative 
vector<string> b(ma,,_size); 
copy(ii,eos,b.begin() ; 
/I don't guess about the amount of input! 
People who try to guess the maximum size of input usually find that they have 
underestimated, and serious problems emerge - for them or for their users -
from the resulting buffer overOows. Such overflows are also a source of security 
problems. 
759 

7'" 
CHAPTER 21 • ALGORITHMS AND MAPS 
TRY THI S 
First get the program as written to work and test it with a small flle of, say, a 
few hundred words. Then try the emphaticaUynot rt!COTIIJ1Ie7Ilkd version that 
guesses about the size of input and see what happens when the input buffer b 
overflows. Note that the worst-case scenario is that the overflow led to noth-
ing bad in your particular example, so that you would be tempted to ship it 
to users. 
In our little program, we read in the words and then sorted them. 111al seemed 
an obvious way of doing things at the time, but why should we put words in "the 
wrong place" so thal we later have to sort? Worse yet, we find that we Slore a 
word and print it as many times as it appears in the input. 
We can solve the latter problem by using unique_capyO instead of capyO. A 
uniquc_copyO simply doesn't copy repeated identical vaJues. For example, using 
plain copyO the program will take 
the man bit the dog 
and produce 
bit 
dog 
man 
the 
the 
If we used unique_copyO, the program would write 
bit 
dog 
man 
the 
Where did those newlines come from? Outputting wilh separators is so COlllmon 
lhal. the ostreamj terator's constmctor allows YOll to (optionally) specify a string 
to be primed after each value: 
ostreamj terator<string.> oo(os, "\n"); 
/I make output iterator for stream 

2 1. 7 
COPY ING 
Obviously, a newline is a popular choice ror Output meant ror humans to read, 
but maybe we prefer spaces as separators? We could write 
ostreamjterator<string> oo(os," "); 
/I make output iterator for stream 
This would give us the output 
bil dog man the 
21.7.3 Using a sel lo keep order 
There is an even easier way or getting that output; use a sel rather than a vector: 
inl mainO 
( 
string from, 10; 
cin » from » 10; 
/I get source and target fi Ie names 
ifslream is(from.c_strO); 
of stream os(to.c_slr()); 
/I make input stream 
/I make output stream 
istreamj terator<string> ii(is); 
istreamj terator<string> cos; 
oSlream_ilerator<slring> oo(os," "); 
/I make input iterator for stream 
/I input sentinel 
II make output iterator for stream 
set<string> b(ii,eos); 
copy(b.beginO ,b.endO ,00); 
/I b is a sel initialized from input 
/I copy buffer 10 output 
) 
\"'hen we insert values into a SCI, duplicates arc ignored. Furthermore, the cle· 
ments or a set are kept in order so no sorting is needed. With the right tools, 
most tasks arc easy. 
21.7.4 copy_if 
The copyO algorithm copies unconditionally. TIle unique_copyO algorithm sup' 
presses adjacent elements with the same value. The third copy algorithm copies 
only elements ror which a predicate is O'1Ie: 
lemplalfx class In, class Out, class Pred> 
Oul copyjf(ln first, In last, Out res, Pred p) 
/I copy elements that fulfi ll the predicate 
761 

762 
( 
) 
CHAPTER 2 1 • ALGOR ITHMS AND MAPS 
while (first ! =Iast) ( 
jf (p(·first)) ·res++ = -firsl; 
++firstj 
) 
return res; 
Using our larger_than function object from §21.4, we t.'ln find all clements of a 
sequence larger than 6 like this: 
void Hconsl vector<inl>& v) 
( 
) 
/I copy all elements with a value larger than 6 
vector<inl> v2(v.size()); 
copyjf(v.begin(), v.endO, v2.beginO, LargeUhan(6» i 
1/ . .. 
TImnks to a mistake I made, this algoritlull is missing from the 1998 I SO Stan-
dard. This mistake has now been remedied, but yOlI can still find implementa-
tions without copyjf. lf SO, juSI usc the definition from this section. 
21.8 Sorting and searching 
Often, we want our data ordered. We can achieve that either by using a data 
structure that maintains order, such as map and sel, or by sorting. 111C most 
common and useful sort operalion in me STL is me sortO that we have already 
used several times. By default, sartO uses < as the sorting criterion, but we can 
also supply our own criteria: 
template<class Ran> void sort(Ran first, Ran last); 
template<class Ran, class Cmp> void sort(Ran first, Ran last, Cmp cmp); 
As an example of sorting based on a user-specified criterion, we'll show how to 
sort strings wimout takin g case into account: 
strucl No_case { 
bool operator()(const string& x, canst string& y) cons! 
( 

21 .8 
SORTIN G AN D SEAR C H IN G 
) 
); 
for (int i = 0; i<x.length(); ++i) ( 
if (i == y.length()) return false; 
II y<x 
char xx = tolower(x[i]); 
char yy = tolower(y[i); 
if (xx<yy) return true; 
1/ x<y 
if (yy<xx) return false; 
/I y<x 
relurn true; 
II x<y (fewer characters in x) 
void sort_and_print(vector<string>& vc) 
{ 
) 
sorl( vc. begin(), vc.endO, No _ caseO); 
for (vector<slring>: :consUleralor p = vc.begin(); p!=vc.end(); ++p) 
coul «·p « '\n'; 
Once a sequence is sorted, we no longer need to search from the beginning using 
findO; we can use the order to do a binary search. Basically, a binary search 
works like this: 
Assume that we are looking for the value x; look at the middle clement: 
If the element's value equals x, we found it! 
If the element's value is less than x, any clement with value x must be to 
the right, so we look at the right half (doing a binary search on that half). 
If the value of x is less than the element's value, any clement with value x 
must be to the left, so we look at the left half (doing a binary search on 
that half). 
If we have reached the last clement (going left or right) without finding x, 
then there is no element with that value. 
For longer sequences, a binary search is much faster than findO (which is a linear 
search). The standard library algorithms for binary search arc searchO and 
equaCrangeO. ' '''hat do we mean by "longer"? It depends, but ten elements arc 
usually sufficient to give searchO an advantage over findO. For a sequence of 1000 
elements, searchO will be something like 200 times faster than find(); see §21.6.4. 
The binary_search algorithm comes in twO variants: 
templale<class Ran, class T> 
bool binary_search(Ran first, Ran last, const T& val); 
763 

' 64 
( HAPTE R 21 • ALGOR IT HMS AND MAPS 
te mplate<class Ran, class T, class Cmp> 
boot binary_search(Ran first, Ran last, const T& val, Cmp cmp); 
These algorithms require and assume mat their input sequence is soncd. If it isn't, 
"interesting things," such as infinite loops, might happen. A binary_searchO simply 
tells LIS whether a value is present: 
void f(vector<string>& vs) 
{ 
II vs is sorted 
if (binary _search(vs.beginO,vs.endO, "starfruil"» { 
/I we have a starfruit 
) 
II. 
So, binary_searchO is idem when an we care about is whether a value is in a se-
quence or nolo U we care about the element we find, we can usc lower_boundO, 
upper_bound{), or equal_rangeO (§23.4, §B.5.4). In the cases where we care 
which clement is found, lhe reason is usually that it is an object containing more 
information than just the key, that there can be many elements with the same 
key, or that we want to know which clement met a search criterion. 
'0/" Drill 
After each operation (as defmed by a line of this drill) print the vector. 
1. Define a struct Ite m { string name j int iid; do uble value; , - ... o, }; and 
make a veClo r<ltem>, vi, and fill it with ten items from a ftle. 
2. Sort vi by name. 
3. Sort vi by iid. 
4. SOrt vi by value; print it in order of decreasing value (i.e., largest value 
first). 
5. Insert Item("horse shoe",99,12.34) and lte m("Canon 5400", 9988A99.95). 
6. Remove (crase) (1."'0 Ite ms identified by name from vi. 
7. Remove (crase) (1."'0 Ite ms identified by iid from vi. 
8. Repeat the exercise with a list<ltem> rather than a vecto r<lIem>. 
Now try a map: 
I. Define a map<string,inl> called msi. 
2. Insert ten (name,value) pairs into it, e.g., msil"lecture"J=21. 

CHAI)TER 2 1 REVIEW 
3. OUtput the (name,value) pairs to caul in some format of your choice. 
4. Erasc the (name, value) pairs from msi. 
5. Write a function that reads value pairs from dn and places them in msi. 
6. Read ten pairs from input and enter them into msi. 
7. Write the elements of msi to caul. 
8. O utput the sum of the (integer) values in msi. 
9. Define a map<int,slring> called mis. 
10. Enter the values from msi into mis; that is, if msi has an element ("Iec-
ture n ,21), mis should have an element (21, "lecture"). 
II. Output the elements of mis to caul. 
More vector use: 
I. Read some floating-point values (at least 16 values) from a me into a vec-
tor<double> called vd. 
2. Output vd to caul. 
3. Make a vector vi of type vector<ini> with the same number of elements 
as vd j copy the clements from vd into vi. 
4. Output the pairs of (vd[i],viliI) to cout, one pair per line. 
5. Output the sum of the elements of Yd. 
6. Output the difference between the sum of the clements of vd and the 
sum of the elements of vi. 
7. 111ere is a standard library algorithm called reverse that takes a sequence 
(pair of iteTaLOrs) as arguments j reverse vd, and output vd to caul. 
8. Compute the mean value of the clements in vd ; output it. 
9. Make a new vector<double> called vd2 and copy all elements of vd with 
values lower t.han (less than) the mean into vd2. 
10. Sort. vd j output. it again. 
Review 
I. \\That. arc examples of useful STL algorithms? 
2. What. does (indO do? Give at least five examples. 
3. What does counUf() do? 
4. What does sort(b,e) usc as its sorting criterion? 
5. How does an STL algorithm take a container as an input argument? 
6. How docs an STL algorithm take a container as an output argument? 
7. How docs an STL algorithm usually indicate "not found" or "failure"? 
8. ' >Vhat is a function object? 
9. In which ways docs a function object differ from a function? 
10. What is a predicate? 
11. What docs accumulateO do? 
12. What docs inner_productO do? 
76. 

766 
CHA PTE R 21 
• ALGORITHMS AND MAPS 
13. 'What is an associative container? Give at least three examples. 
14. Is list an associative container? Why not? 
15. What is the basic ordering property of binary tree? 
16. What (roughly) does it mean for a tree to be balanced? 
17. How much space per element does a map take up? 
18. How much space per element does a vector take up? 
19. Why would anyone use an unordered_map when an (ordered) map is 
available? 
20. How does a set difTer from a map? 
2 1. How docs a multLmap differ from a map? 
22. Why usc a copyO algoritlun when we could "'jUSt wrile a simple loop"? 
23. What is a binary search? 
Terms 
accumulateO 
algorithm 
application: () 
associative container 
balanced tree 
binary_searchO 
copyO 
copy_if 0 
equal_rangeO 
Exercises 
find O 
findjfO 
function object 
genen c 
hash function 
inner_productO 
lower_boundO 
map 
predicate 
searching 
sequence 
,e' 
sorlO 
sorting 
stream iterator 
unique_copyO 
unordered_map 
upper_boundO 
1. Go Lhrough the chapter and do all Try this exercises that you haven't al-
ready donc_ 
2. Find a reliable source of STL documentation and list every standard li-
brary algorithm. 
3. Implement counlO yourself. Test il. 
4. Implement counCa O yourself. Test il. 
5. What would we have to do if we couldn't return endO to indicate "not 
found"? Redesign and rcimplement find O and eounlO to take iterators to 
the ftrst and last elements. Compare the results to the standard versions. 
6. In the Fruit example in §21.6.5, we copy Fruils into the sel. What if we 
didn't want to copy the Fruils? We could have a sel<Fruil·> instead. 
However, to do that, we'd have to define a comparison operation for that 
sel. Implement the Fruit example using a sel<Fruil*, FruiCcomparison>. 
Discuss thc differences between the two implementations. 

CHAPTER 21 EXERCISES 
7. Write a binary search function for a vector<inl> (without using the stan-
dard one). You can choose any interface you like. Te~l it. How confident 
arc you that your binary search function is correct? Now write a binary 
search function for a lisl<slring>. Test it. How much do the two binary 
search functions resemble each other? How much do you think they 
would have resembled each other if you had not known about the Sl1.? 
8. Take the word-frequency example from §21.6.1 and modify it to output 
its lines in order of frequency (rather than in lexicographical order). An 
example line would be 3: C++ rather than C++: 3. 
9. Define an Order class with (customer) name, address, data, and vee-
tor<Purchase> members. Purchase is a class with a (product) name, 
uniCpriee, and eounl members. Define a mechanism for reading and 
writing Orders to and from a file. Define a mechanism for printing 
Orders. Create a file of at least ten Orders, read it illlo a vector<OrdeD , 
sort it by name (of customcr), and write it back out to file. Create an-
other file of at least ten Orders of which about a third arc the same as in 
the first file, read it into a list<OrdeD, sort it by address (of customer), 
and write it back out to fLle. Merge the two fLIes into a third using 
std:: merge(). 
10. Compute the total value of the orders in the two ftles from the previolls exer· 
cise."le value of an individual Purchase is (of course) its unit_price·count. 
11 . Provide a CU I interface for emering Orders into files. 
12. Provide a CUI imerface for querying a fLle of Orders; e.g., "Find all or-
ders from Joe," "rmd the tOlal value of orders in fLle Hardware," and 
"List all orders in ftIe Clothing." Hint: First design a non·CUI interface; 
then, build the CUI on lOp of that. 
13. Write a program to "clean up" a text file for usc in a word query pro· 
gram; that is, replace punctuation with whitespace, put words imo lower 
case, replace 0011 '1 with 00 1101 (etc.), and remove plurals (e.g., ships be-
comes JIIiP). Don't be too ambitious. For example, it is hard to detennine 
plurals in general, so just remove an s if you fmd both sllip and JIIips. Use 
that program on a real·world text me with at least 5000 words (e.g., are· 
search paper). 
14. Write a program (using the output from the previous exercise) to answer 
questions such as: "How many occurrences of ship are tllere in a me?" 
"Much word occurs most frequently?" "Which is the longest word in 
the file?" "Which is the shortest?" "List all words starting with s." "List 
all four·letter words." 
15. Provide a CUI for the program from tile previous exercise. 
767 

768 
CHAPTER 21 • ALGOR ITHMS AND MAPS 
Postscript 
The STL is the pan of the ISO C++ standard library concerned with containers 
and algoritluns. As such it provides very general, ncxiblc. and useful basic lools. 
It can save us a lot of work: reinventing the wheel can be fun, but it is rarely pro-
ductive. Unless there are strong reasons not to, use the STL containers and basic 
a1gorilluns. What is more, the 5TL is an example of generic programming, show-
ing how concrete problems and concrete solutions can give rise to a collection of 
powerful and general tools. If you need to manipulate data - and most program-
mers do - the STL provides an example, a set of ideas, and an approach that 
arLeIl can help. 

Part IV 
Broadening 
the View 


~ ,. 22 
Ideals and History 
"When someone says, 
'I want a programming language 
in which I need only say what I wish done,' 
give him a lollipop." 
- Alan Perlis 
T
his chapter is a very brief and very selective history of pro-
gramming languages and the ideals they have been designed 
to serve. The ideals and the languages that express them arc the 
basis for professionalism. Because C++ is the language we usc in 
this book, we focus on C++ and languages lhat influenced C++. 
TIle aim is to give a background and a perspective to the ideas pre-
sellted in this book. For each language, we present its designer or 
designers: a language is not JUSt an abstract creation, but a concrete 
solution designed by individuals in response to problems they faced 
at the time. 

m 
22.1 History, ideals, and 
professionalism 
22.1.1 Programming language aims and 
philosophies 
22.1.2 Programming ideals 
22.1.3 Stylesfparadigms 
( HAPTER 22 • IDEALS AND H ISTORY 
22.2 Programming language history 
overview 
22.2.1 The earliest languages 
22.2.2 The roots of modern languages 
22.2.3 The Algol family 
22.2.4 Simula 
22.2.5 C 
22.2.6 C++ 
22.2.7 Today 
22.2.8 Information sources 
22.1 History, ideals, and professionalism 
"History is bunk," Henry Ford famously declared. TIle contrary opinion has 
been widely quoted since antiquity: "He who docs not know history is con-
demned to repeat it." TIle problem is to choose which parts of history to know 
and which parts to discard: "95% of everything is bunk" is another relevant 
quote (with which we concur, though 95% is probably an underestimate). Our 
view of the relation of history to current practice is that there can be no profes-
sionalism without some understanding of history. If you know too liule of the 
background of your field, you are gullible because the history of any field of 
work is littered with plausible ideas that didn't work. "nle "real meat" of history 
is ideas and ideals that have proved their worth in practical use. 
We \ ... ·ould have loved to talk about the origins of key ideas in many more lan-
guages and in all kinds of software, such as operating systems, databases, graph-
ics, networking, lhe web, scripling, elC., bUl you'll have to ftnd those important 
and useful areas of software and programming elsewhere. We have barely enough 
space to scratch the surface of the ideals and history of programming languages. 
TIle ultimate aim of programming is always to produce useful systems. In 
the heal of discussions about prograuuning techniques and programming lan-
guages, that's easily forgotten. Don't forgel that! If you need a reminder, take an-
other look at Chapter 1. 
22.1.1 Programming language aims and philosophies 
What is a programming language? \¥hat is a programming language supposed 
to do for us? Popular answers to "\¥hat is a programming language?" include 
A tool for instructing machines 
A nOlation for algorithms 
A means of conununication among programmers 
A tool for experimentation 

22.1 
HISTORY, IDEALS, AND PROFESSIONA U SM 
A means of controlling computerized devices 
A way of expressing relationships among concepts 
A means of expressing high-level designs 
Our answer is ''All of the above - and more!" Clearly, we arc thinking about 
general-purpose programming languages here, as we will throughOUl this chap-
ter. In addition, there arc special-purpose languages and domain-specific lan-
guages serving narrower and typically more precisely defined aims. 
What properties of a progranuning language do we consider desirable? 
Portability 
Type safety 
Precisely defmed 
High performance 
Ability to concisely express ideas 
Anything that eases debugging 
Anything that eases testing 
Access to all system resources 
Platform independence 
Runs on all platforms 
Stability over decades 
Prompt improvements in response to d UUlges in application areas 
Ease of learning 
Small 
SuppOrt for popular programming styles (e.g., object-oriented progrd.m-
ming and generic programming) 
Whatever helps analysis of programs 
LotS of facilities 
Supported by a large community 
Supportive of novices (students, learners) 
Comprehensive facilities for experts (e.g., infrastructure builders) 
Lots of sofn\lare development tools available 
Lots of software componentS available (e.g., libraries) 
Supported by an open software conununity 
Supported by major platform vendors (Microsoft, IBM, etc_) 
Unfortunately, we can't have all this at the samc timc. "l11at's sad because every 
one of these "properties" is objectively a good thing: each provides benefitS, and 
m 

774 
C HAPTER 22 • IDEALS AND HI STORY 
a language that doesn't provide them imposes added work and complications on 
its users. The reason we can't have it all is equally fundamental: several of the 
propcnics are mutually exclusive. For example, you cannOt be 100% platform in-
dependent and also access all system resources; a program that accesses a re-
source lhat is nOt available on every platfoml cannot run everywhere. Similarly. 
we obviously want a language (and the lOols and libraries we need to usc it) liml 
is small and easy LO learn, but that can't be achieved while providing comprehen-
sive suppOrt for programming on all kinds of systems and for all kinds of appli-
cation areas. 
This is where ideals become important. Ideals arc what guide the technical 
choices and trade-ofTs that every language, library, tool, and program designer 
must make. Yes, when you write a program you arc a designer and must make 
design choices. 
22.1.2 Programming ideals 
'TIle preface of 1M C++ Programming Language starts, "C++ is a general purpose 
programming language designed to make programming more enjoyable for the 
serious programmer." Say what? Isn't programming all about delivering prod~ 
uCts? About correctness, quality, and maintainability? About lime-to-market? 
About supporting software engineering? 'TIlat, tOO, of course, but we shouldn't 
forget the programmer. Consider another example: Don Knuth said, "'11e best 
thing about the Alto is that it doesn't run faster at night." 11le AltO was a com-
puter from the Xerox Palo AltO Research Center (PARC) that was one of the first 
"personal computers," as opposed to the shared computers for which there was a 
1m of competition for daytime access. 
Our tools and techniques for programming exist to make a programmer, a 
human, work better and produce better results. Please don't forget that. So what 
guidelines can we articulate to help a programmer produce the best software with 
the least pain? We have made our ideals explicit throughout the book so this sec-
tion is basically a summary. 
The main reason we want our code to have a good structure is that the struc-
ture is what allows us to make changes without excessive effort. "n1e better the 
structure, the easier it is to make a change, find and fix a bug, add a new fealllre, 
port it to a new architecture, make it nm faster, etc. 111at's exactly what we mean 
by "good." 
For the rest of this section, we will 
Revisit what we are trying to achieve, that is, what we want from our code 
Present two general approaches to soft\vare development and decide that 
a combination is better than either altemative by itself 
Consider key aspects of program stmcture as expressed in code: 
Direct expression of ideas 

22.1 
HI STORY, ID EALS , AND PROFESS IONAL ISM 
Abstraction level 
Modulmity 
Consistency and minimalism 
Ideals arc meant to be used. They arc tOols for thinking, nOt simply fancy 
phrases to trOt out to please managers and examiners. Our programs are meant 
to approximate our ide."lis. \"'hen we get stuck in a program, we step back to sec 
if our problems come from a departure from some ideal; sometimes that helps. 
\¥hen we evaluate a program (preferably before we ship it to users), we look for 
departures from the ideals that might cause problems in the future. Apply ideals 
as widely as possible, but remember that practical concerns (e.g., pcrfonnance 
and simplicity) and weaknesses in a language (no language is perfect) will often 
prevent you from achieving more than a good approximation of the ideals. 
Ideals can guide us when making specific technical decisions. For example, 
we can't juSt make every single decision about imerfaces for a library individu· 
ally and in isolation (§14.1). TIle result would be a mess. Instead we must go 
back to our first principles, decide what is important about this particular library, 
and then produce a consistent set of interfaces. Ideally, we would articulate OLir 
design principles and trade·offs for that particular design in the documentation 
and in comments in the code. 
During the start of a project, review the ideals and sec how they relate to the 
problems and the early ideas for their solution. This can be a good way to get 
ideas and to refine ideas. Later in the design and development process, when you 
arc stuck, step back and sec where your code has most departed from the ideals 
- this is where the bugs are mOst likely to lurk and the design problems are most 
likely to occur. This is an alternative to the default technique of repetitively look· 
ing in the same place and trying the same techniques to find the bug. "TIle bug is 
always where yOlI are not looking - or you would have found it already." 
22.1.2.1 What we want 
lYrically, we want 
ComcflleSJ: Yes, it can be difficult to define what we mean by "correct," 
but doing so is an important part of the complete job. Often, others de-
fine for us what is correct for a given project, but then we have to inter· 
pret what they say. 
MamlaituWility: Every successful program will be dmnged over time; it will 
be ported 1.0 new hardware and software platfonns, it will be extended 
with new facilities, and new bugs will be found that must be flXed. 111e 
scctions below about ideals for program structure address this ideal. 
Ftr/uT7IIalla : Performance ("efficiency") is a relative term. Pcrfomlance has 
to be adequate for the program's pUqlOse. It is often claimed that efficient 
code is necessarily low· level and that concerns with a good, high-level 
775 

CHAPTER 22 • IDEALS AND HI STORY 
structure of the codc cause inefficiency. On the contrary, we find that ac-
ceptable perfonnance is often achieved though adherence to the ideals 
and approaches we recommend. The STL is an example of code that is si-
multaneously abstract and very efficient. Poor pcrfonnance can as easily 
arise from an obsession with low-level details as it can from disdain for 
such details. 
01l-~ tkJiuny: Delivering the perfect program a year late is usually not 
good enough. Obviously, people expect the impossible, but we need to 
deliver quality software in a reasonable time. There is a myth that "com-
pleted on time" implies shoddiness. On the contrary, we find that em-
phasis on good stmcture (e.g., resource management, invariants, and 
interface design), design for testability, and use of appropriate libraries 
(often designed for a specific application or application area) is a good 
way to meet deadlines. 
Tbis leads to a concern for structure in our code: 
If there is a bug in a program (and every large program has bugs), it is 
easier to fmd in a program with a clear structure. 
If a program needs to be understood by a new person or needs to be 
modified in some way, a clear structure is comprehensible with far less 
e!Tort than a mess of low-level details. 
If a program hits a performance problem, it is often easier to tUlle a high-
level program (one that is a good approximation of the ideals and has a 
well-defined structure) than a low·level or messy one. For starters, the 
high-level one is more likely to be understandable. Second, the high-level 
one is often ready for testing and tuning long before the low-level one. 
Note the point about a program being understandable. Anything that helps us 
understand a program and helps us reason about it is good. Fundamentally, reg-
ularity is better than irregularity - as long as the regularity is not achieved through 
oversimplification. 
22.1 .2.2 General approaches 
TIlere are n\-'O approaches to writing correct software: 
&llum-up: Compose the system using only components pmvcd to be correct. 
Top-duum: Compose the system a Lit of components assumed to comain 
errors and calch all errors. 
Interestingly, the most reliable systems combine these two - apparently contrary 
- approaches. The reason for that is simple: for a large real-world system, neither 
approach will deliver tlle needed correctness, adaptability, and maintainability: 

22.1 
HI STORY, IDEALS. AND PRO FESSIONALISM 
We can't build and "prove" enough basic components to eliminate all 
sources of errors. 
We C."lIl't completely compensate for the flaws of buggy basic components 
(libraries, subsystems, class hierarchies, etc.) when combining them in the 
final system. 
However, a combination of approximations to the two approaches can deliver 
more than either in isolation: we can produce (or borrow or buy) components 
that arc sufficiently good, so that the problems that remain can be compensated 
for by error handling and systematic testing. Also, if we keep building beuer 
components, a larger part of a system can be constructed from them, reducing 
the amount of "messy ad hoc code" needed. 
Testing is an essential part of software development. It is discussed in some 
detail in Chapter 26. lcsting is the systematic search for errors. "Test early and 
often" is a popular slogan. We try to design our programs to simplify testing and 
to make it harder for errors to "hide" in messy code. 
22.1 .2.3 Direct expression of ideas 
When we express somcthing - be it high.level or low·level - the ideal is to ex· 
press it directly in code, rather tha.n though work·arounds. TIle fundamental 
ideal of representing our ideas directly in code has a few specific variants: 
Rejft'eJelll ideas directly in COlle. For example, it is better to represent a.n argu· 
ment as a specific type (e.g., Month or Color) than as a more general one 
(e.g., int). 
Repmenl illllepertdmt ideas indepmdenliy in axle. For example, with a few ex· 
ceptions, the standard sartO can sort any standard container of any ele· 
mCilt type; the concepts of soning, sorting criteria, container, and clement 
type arc independent. Had we built a "vector of objects allocated on the 
free store where the elements arc of a class derived from Object with a 
beforeO member function defined for usc by vector: :sort()" we would 
have a far less general sartO bec.,use we made assumptions about storage, 
class hierarchy, available member functions, ordering, etc. 
RepresmJ r(wtionships amollg it/.eas dinctly i1l cOlk. The most common relation· 
ships that can be dircctly represented are inheritance (e.g., a Circle is a 
kind of Shape) and parameterization (e.g., a vector<T> represents what's 
common for all vectors independently of a particular clement type). 
Combine /{leas expressed in ,ode jru iy - where and 01l1y where combinations milk 
smJe. For example, sartO allows us to use a variety of element types and 
a variety of containers, but the elements must support < (if they do not, 
we usc the sortO with an extra argument specifying the comparison crite· 
ria), and the containcrs we son must support random·access itcrators. 
777 

77B 
(HAPTER 22 • IDEALS AND HISTORY 
Exprw simpk idellJ simply. Following the ideals listed above can lead to 
overly general code. For example, we may end up with class hierarchies 
with a more complicated taxoIlomy (inheritance structure) than anyone 
needs or with seven parameters to every (apparently) simple class. To 
avoid every user having to face every possible complication, we try to 
provide simple versions that deal with the most common or most impor-
tant cases. For example, we have a sort(b,e) that implicitly sorts using 
less-than in addition to the general version sort(b,e,op) that sorts using 
op. If we could (and we will be able to in C++Ox; sec §22.2.8), we'd also 
provide versions sort(c) for sOrting a standard container using less-than 
and sorl(c,op) for sorting a standard container using op. 
22.1.2.4 Abstraction level 
We prefer to work alille IliglleJ/fi(Lfibie level 0/ abJlraclioll; that is, Ollr ideal is to ex· 
press our solutions in as general a way as possible. 
For example, consider how to reprcselll enu·ies for a phone book (as we might 
keep it on a PDA or a cell phone). We could represent a set of {name, value) pairs 
as a vecfor<pair<string,Value_type» . Ho\ ... ·ever, if we essentially always accessed 
that set using a name, map<String,Value_type> would be a higher level of abstrac-
tion, saving us the bother of writing (and debugging) access functions. On the 
Olher hand, vector<pair<string,Value_type» is itself a higher level of abstraction 
than two arrays, slring[max) and Value_typeImaxJ, where the relationship be· 
tween the string and its value is implicit. The lowest level of abstraction would be 
something like an int (number of clements) plus two void· s (paiming to some 
fonn of representation, known to the programmer but not to the compiler). In our 
example, every suggestion so far could be seen as tOO low·level because it focuses 
on the representation of the pair of values, rather than their function. We could 
move closer to the application by dertning a class that directly reflected a use. For 
exrullplc, we could write our application code using a class Phonebook with an in· 
terface designed for convenient usc. That Phonebook class could be implementcd 
using anyone of thc representations suggested. 
'Tlle reason for prcfcn·ing tlle higher level of abstraction (when we have an 
appropriate abstraction mechanism and if our language supportS it with accept· 
able efficiency) is that such formulations arc closer to thc way we tllink about our 
problems and solutions than solutions that have been expressed at the level of 
computer hardware. 
'Tlle reason given for dropping to a lower level of abstraction is typically "cffi· 
ciency." TIlls should be donc only when really needed (§25.2.2). Using a lower·level 
(more primitivc) language feature does not necessarily give better pcrfonnancc. 
Somctimes, it eliminates optimization opportunities. For exrunp1c, using a Phone-
book class, we have a choice of inlplementations, say, bet\veen string(max] plus 
Valuc_typelmaxl ruld map<String,Value_type>. For some applications the fanner is 
more efficient and for otllers the latter is. Naturally, pcrfonnrulce would not be a 

2 2. 1 
HI STOR Y. IDEA LS, AND PROFESS ION ALI SM 
major cOllcem in an application involving only your personal directory. However, 
this kind of trade-off becomes interesting when we have LO keep track of - and mao 
nipulate - millions of entries. More seriously, after a wltile, the usc of low· level fea· 
tures soaks up the programmer's time so that opportunities for improvements 
(pcrfollnance or otherwise) arc missed bec..1.USC of lack of time. 
22.1.2.5 Modularity 
Modularity is an ideal. We wam to compose our syStelllS out of "components" 
(functions, classes, class hierarchies, libraries, elc.) that we can build, understand, 
and test in isolation. Ideally, we also wallt to design and implement such compo-
nents so that they can be used in more than one program ("reused"). Ra« is the 
building of systems out of previously tested components that have been used else· 
where - and the design and use of such components. We have touched upon this in 
our discussions of classes, class hierarchies, interface design, and generic program· 
mingo Mucll of what we say about "programming styles" (in §22.1.3) relates to the 
design, inlplementation, and usc of potentially "reusable" components. Please note 
that nOt every component can be used in more than one program; some code is sim· 
ply too specialized ,md is not easily improved to be usable elsewhere. 
Modul;u'ity in code should reOecl import.1.l1t logical distinctions in the appli· 
c'1tion. We do not "increase reuse" simply by putting two completely separate 
classes A and B into a "reusable component" called C. By providing the union of 
A's and 8 's interfaces, the introduction of C complicates our code: 
User I 
User 2 
"'. / 
c 
Here, User 1 and User 2 both usc C. U nless you look into C, you might think 
that User I and User 2 gained benefits from sharing a popular component. Bene· 
fits from sharing ("reuse") would (in this case, wrongly) be assumed to include 
better testing, less total code, larger user base, etc. Unfortunately, except for a bit 
of oversimplification, this is not a partiOllarly rare phenomenon. 
\.vhat would help? Maybe a common interface to A and B could be provided: 
User I 
User 2 
User I 
User 2 
\, / 
77'J 

780 
CHAPTER 22 • IDEALS AND HI STORY 
These diagrams arc intended to suggest inheritance and parameterization, respec-
tively. In both cases, the imcrfacc provided must be smaller than a simple union 
of A's and B's interfaces for the exercise to be worthwhile. In other words, A and 
B have to have a fundamental commonality for users to benefit from. Note how 
we again came back to interfaces (§9.7, §25.4.2) and by implication to invariants 
(§9.4.3). 
22.1.2.6 Consistency and minimalism 
Consistency and minimalislll arc primarily ideals for expressing ideas. So we 
might dismiss them as being abollt appearance. However, it is rcally hard to pres-
ent a messy design elegantly, so demands of consistency and minimal ism can be 
used as design criteria and affect even the most nnnlllc details of a program: 
Don't add a feature if you are in doubt about its utility. 
Do give similar facilities similar interraces (and names), but only if the 
similarity is fundamental. 
Do give different facilities different names (and possibly different inter-
face style), but only if the differences are fundamental. 
Consistent naming, interface style, and implementation style help maimenance. 
\lVhen code is consisteIlt, a new programmer doesn't have to learn a new set of 
conventions for every part of a large system. The S1L is an example (Chapters 
20-2 1, §B.4-6). When such consistency is impossible (for example, for ancient 
code or code in another language), it can be an idea to supply an interface that 
matches the style of the rest of the program. TIle alternative is to let the foreign 
("strange," "poor") style infect every part of a program that needs to access the 
offending code. 
One way of preserving minimalism and consistency is to carefully (and con-
sistently) document every interface. 1l1at way. inconsistencies and duplication 
are more likely to be noticed. Documenting pre-conditions, post-conditions, and 
invariants can be especially useful as can careful attention to resource manage-
ment and error reporting. A consistent error-handling and resource management 
strategy is essential for simplicity (§19.5). 
To some programmers, the key design principle is KISS ("Keep It Simple, 
Stupid"). We have even heard it claimed that KISS is the only worthwhile design 
principle. However, we prefer less evocative fonnulations, such as "Keep simple 
things simple" and "Keep it simple: as simple as possible, but no simpler." The 
latter is a quote from Albert Einstein, which renecLS that there is a danger of sim· 
plifying beyond the point where it makes sense, lillis damaging Lile design. TIle 
obvious question is, "Simple for whom and compared to what?" 

22.1 
HI STORY, ID EALS. AN D PROF ESS IONA LI SM 
22.1.3 Styles/paradigms 
When we design and implement a program, we aim for a consistent style. C++ 
supports four major styles that can be considered fundamental: 
Procedural programming 
Data abstraction 
Object-oriented programming 
Generic programming 
These arc sometimes (somewhat pompously) called "progranuning paradigms." 
"nlere are many more "paradigms," such as functional programming, logic pro-
gramming, rule-based programming, constraints-based programming, and as-
pect-oriellled programming. However, C++ doesn't suppon those direcuy, and 
we just can't cover everything in a single beginner's book, so we'll leave those to 
"future work" together with the mass of details that we must leave out about the 
paradigms/styles we do cover: 
ltoadural programming: the idea of composing a program out of functions 
operating on arguments. Examples arc libraries of mathematical func-
tions, such as sqrtO and cosO. C++ sup pons ulis style of programming 
through the notion of functions (Chapter 8). The ability to choose to 
pass arguments by value, by reference, and by const reference can be 
most valuable. Often, data is organized into data structures represented 
as structs. Explicit abstraction mechanisms (such as private data mem-
bers or member functions of a class) arc not used. Note that this style of 
programming - and functions - is an integral part of every other style. 
Data abs/me/ion: the idea of first providing a set of types suitable for an ap-
plication area and lhen writing the program using those. Matrices pro-
vide a classical example (§24.3-6). Explicit data hiding (e.g., the lise of 
private data members of a class) is heavily used. The standard string and 
vector are popular examples, which show ule strong relationship be-
tween data abstraction and parameterization as used by generic pro-
gramming. This is called "abstraction" because a type is used through an 
interface, rather than by direcuy accessing its implementation. 
Oijed-oriellleli programming: the idea of organizi.ng types into hierarchies to 
express their relationships directly in code. TIle classical example is the 
Shape hierarchy from Chapter 14. TIlis is obviously valuable when the 
types really have fundamental hierarchical relationships. However, there 
has been a strong tendency to overuse; lhat is, people built hierarchies of 
types that do not belong together for fundamental reasons. When people 
derive, ask why. "\That is being expressed? How does tlie base/derived 
distinction help me in this particular case? 
781 

782 
CHAPTER 22 • IDEALS AND HISTO RY 
Generic programming: the idea of taking concrete algorithms and "lifting" 
them to a higher level of abstraction by adding parameters to express 
what can be varied withollt changing the essence of an algoritilin. '11C 
highO example from Chapler 20 is a simplc example of lifting. loc 
findO and sortO algorithms from the STL arc classical algorithms ex-
pressed in very general forms lIsing t,'"Cl1cric programming. Sec Chapters 
20-21 and the followingcxamplc. 
All together now! OrLen, people mlk about programming slylcs ("paradigms
n
) as 
if they wcre simple disjointed altcmativcs: either you usc generic programming 
or you usc object-oriented progranuning. If your aim is 10 express solutions to 
problems in the best possible way, you will usc a combination of styles. By "best," 
we mean easy to read, easy to write, easy to maintain, and sufficiently efficient. 
Consider an example: the classical "Shape example'" originated with Simula 
(§22.2.6) and is usually seen as an example of object-oriented programming. A 
first solution might look like this: 
void draw_all(veclor<Shape>& v) 
( 
(or(inl i = 0; i<v.sizeO; Hi) v[il- >draw(); 
} 
This docs indeed look "rather objea-oriemed." It critically relics on a class hierar-
chy and on the virtual function call fmding the right drawO function for every 
given Shape; that is, for a Circle, it calls Circle: :drawO and for an Open_polyline, 
it caUs Open_polyline: :drawO. But the veclor<Shape·> is basically a generic pro-
gramming construct: it relies on a paramcter (the clement type) that is resolved at 
compile time. We could emphasize that by using a simple standard libnuy algo-
rithm to express the iteration over all clements: 
void draw_all(veclor<Shapc*>& v) 
( 
for_each(v.bcgin(), v.endO,mem_fun (&Shape : : draw» ; 
} 
The third argument of for_cachO is a function to be ,,·dled for each element of 
the sequence specified by t.he first. two arguments (§B.5.1 ). Now, that third func-
tion call is assumed to be an ordinary function (or a function object) called using 
the f(x) syntax, rather than a member fu nction, called by the p->fO syntax. So, 
we use the standard library function mem_funO (§B.6.2) to say that we really 
want to call a member function (the virtual function Shape: :drawO). TIle point is 
that for_cachO and mem_funO, being templates, really aren't very "OO-like"; 
mey clearly belong to what we usually consider generic programming. More in-
teresting still, mem_funO is a freestanding (template) function returning a class 

22.2 
PROGRAMMING LANGUAGE HISTORY OV ER VIEW 
object. In Olher words, it can easily be classified as plain data abstraction (no in-
heritance) or even procedural programming (no data hiding). So, we could claim 
that this one line of code uses key aspects of all of the four fundamental styles 
supported by C++. 
But why would we write the second version of the "draw all Shapes" exam-
ple? It fundamentally does the same as the first version; it even takes a few more 
characters to write it in that way! We could argue that expressing the loop using 
for_cachO is "more obvious and less error-prone" than writing out the for-loop, 
but for many that's not a terribly convincing argument. A bener one is that 
"for_cachO says what is to be done (iterate over a sequence) rather than how it is 
to be done." However, for most people the convincing argument is simply that 
"it's useful": it points the way to a generalization (in the best generic program-
ming tradition) that allows us to solve more problems. Why are the shapes in a 
vector? Why not a list? Why not a general sequence? So we can write a third 
(and more general) version: 
tcmplatc<class Iter> void draw_all(lter b, lie, e) 
( 
for_each(b,e,mem_fun(&Shape: : draw»); 
) 
TItis will now work for all kinds of sequences of shapes. In particular, we can 
even call it for the clements of an array of Shapes: 
Point p(O,l00); 
Point p2(SO,SO); 
Shape all = { new Circle(p,50), new Triangle(p,p2,Poinl(25,25» }i 
draw_all(a,a+2); 
For lack of a better term, we calI progranuning using the most appropriate mix of 
styles multi-paradigm programming. 
22.2 Programming language history overview 
In the very beginning, programmers chiseled the 7.eros and ones into stones by 
hand! Well, almost. Here, we'll start (almost) from the beginning and quickly in-
troduce some of the major developments in the history of programming lan-
guages as they relate to programming using C++. 
There arc a lot of programming languages. The rate of language invention is 
at least 2000 a decade, and the rate of "language death" is about the same. Here, 
we cover abnOSl 60 years by briefly mentioning len languages. For morc informa-
cion, see Imp:lfresearch.illOSl.ComlhopVHOPL.hunl. 111ere, you can fmd links to 
all the articles of the three ACM 5lGPLAN HOPL {History of Programming 
783 

784 
CHAPTER 22 • IDEALS AND HISTORY 
Languages) conferences. These arc extensively peer-reviewed papers - and there-
fore far more truStworthy and complete than the average web source of informa-
tion. TIle languages we discuss here were all represented at HOPL. Note thal if 
you type the full title of a fatnous paper imo a web search engine, there is a good 
dml1cc that you'll find the paper. Also, most computer scicmisLS mentioned here 
have home pages where you can find much information about their work. 
OUT presentation of a language in this chapter is necessarily very brief: each 
language mcmioned - and hundreds not mentioned - deserves a whole book. 
We arc also very selective in what we mention about a language. We hope you 
takc this as a challenge to leam more rather than thinking, "So that's alilhere is 
to language X!" Remember, every language mentioned here was a major accom-
plishment and made an important contribution to our world. There is just no 
way we could do justice to these language in this short space - but not mention-
ing aJlY would be worse. We would have liked to supply a bit or code ror each 
language, but sorry, this is not the place for such a project (see exercises 5 and 6). 
Far too often, an artiract (e.g., a programming language) is presellled as sim-
ply what it is or as the product or some anonymous "development process." -n lis 
misrepresents history: typically - especially in the early and fommtive years - a 
language is the result of the ideals, work, personal tastes, and extemal cOllSl.J'a.ims 
on one or (typically) more individuals. Thus, we emphasize key people associated 
with the languages. IBM, Bell Labs, Cambridge University, etc. do not design lan-
guages; individuals from such organizatiollS do - typically in collaboration with 
friends and colleagues. 
Please note a curious phenomenon that orten skews our view of histOly. Pho-
tographs or ramous scientists and engineers arc most orten taken when they arc 
famous and disringuished, members or national ac.ldemies, Fellows of lhe Royal 
Society, Knights or S1. J ohn, recipients of the Turing Award, etc. -
in other 
words, when they are decades older than when they did their most spectacular 
work. Almost all were/arc among the most productive members of their profes-
sion until late in life. H owever, when you look back to the birth of your favorite 
language features and probrramming techniques, lly to imagine a young man 
(there arc still far too few WOUlen in science and engineering) trying to figure out 
ifhe has sufficient cash to invite a girlfriend out to a decent restauraI1l 0 1' a parent 
trying to decide if a crucial paper can be submitted to a conference at a time and 
place t.hat can be combined with a vacation for a young family_ 111e gray beards, 
balding heads, and dowdy clothes come much later. 
22.2.1 The earliest languages 
\¥hen - starting in 1948 - the first "modern" stored-program electronic comput-
ers appeared, each had its own language. 111ere was a one-ta-Olle correspondence 
between the expression or an algorithm (say, a calculation or a planelmy orbit) 
and instructions for a specific machinc. Obviously, the scientist (the users were 
most often scientists) had notes with mathcmatical rormulas, but the program 

22.2 
PROGRAMMING LANG U AGE HI STORY OV ERVIEW 
was a list or machine instructions. The first primitive lists were decimal or octal 
numbers - exactly matching their representation in the computer's memory. 
Later, assemblers and "auto codes" appeared; that is, people developed languages 
where machine instructions and machine facilities (such as registers) had sym-
bolic names. So. a programmer might write "LD RO 123" to load the contents or 
the memory with the address 123 into register O. However, cach machine had its 
own set or instructions and its own language. 
David ''''heeler rrom the University or Cambridge Computer Laboratory is 
the obviolls candidate ror representing programming language designers or that 
time. In 1948, he wrote the first real program ever to run on a stored·program 
computer (the "table or squares" program we saw in §4.4.2.1). He is one or about 
ten people who have a claim on having written the first compiler (ror a machine-
specific "auto code"). He invented the runction call (yes, even something so ap· 
parently simple needs to have been invented at some point). He wrote a brilliant 
paper on how to design libraries in 1951 ; that paper was at least 20 years ahead 
or its time! He was co-author with Maurice Wtlkes (look him up) and D.]. Gill or 
the first book about programming. He received the first Ph.D. in computer sci-
ence (rrolll Cambridge in 1951) and later made major contributions to hardware 
(cache architectures and early local-area networks) and algorithms (e.g., the TEA 
encryption algorithm [§25.5.6] and the "BUI·rows-"Wheeler transrorm" [the com-
pression algorithm used in bzip2]). David "Wheeler happens to have been Bjame 
Stroustn lp's Ph.D. thesis adviser - computer science is a young discipline. David 
·Wheeler did some or his most important work as a grad student. He worked on 
to become a proressor at Cambridge and a Fellow or the Royal Society. 
References 
Burrows, M., and David Wheeler. "A Block Sorting Lossless Data Compression 
Algorillllll." Technical Report 124, Digital Equipment Corporation, 1994. 
Bzip2link : ww\v.bzip.orgf. 
Cambridge Ring website: http://koo.corplls.calll.ac.uklprojects/earlyatmlcr82. 
78' 

786 
CHAPTER 22 • IDEALS AND HISTO RY 
Campbell-Kelly, Martin. "David J ohn Wheeler." BiograJ)hi.cal Memoirs 0/ Fellows 0/ 
the Royal Society, Vol. 52, 2006. (His technicaJ biography.) 
EDSAC: http://en.wikipcdia.orglwikilEDSAG. 
Knuth, DonaJd. The Ar' 0/ Unnputer Programming. Addison-Wesley, 1968, and 
many revisions. Look for "David Wheeler" in the index of each volume. 
TEA link: http://cn.wikipcdia.orglwikifIiny_Encryplioll_Algoritlun. 
Wheeler, O. J. "The Usc of Sub-routines in Progr<umncs," Proceedings of the 
1952 ACM National Meeting. (TImt's the library design paper fi'om 1951.) 
Wilkes, M. V , D. Wheeler, and D. J Gill. Preparation 0/ Progral1ufar a1/ Ekctronic 
Digi1al Computer. Addison-Wesley Press, 1951; 2nd edition, 1957. The first book 
on programmmg. 
22.2.2 The roots of modern languages 
Here is a chart of important early languages: 
1950s: 
1960s: 
COBOL 
BCPL 
PUI 
1970s: 
Algol68 
Classic C 
1l1CSC languages arc important partly because they were (and in some cases still 
are) widely used or because they became the ancestors to important modem Ian· 
guages - often direct descendants with the same name. In this section, we ad· 
dress the lhree early languages - Fortran, COBOL, and Lisp - to which most 
modem languages trace their ancestry. 
22.2.2.1 Forlran 
The introduction of Fonran in 1956 was arguably the most significant step in the 
development of programming languages. ;<Fortran" stands for ;<Fonnula Transla-
tion," and the fundamental idea was to generate efficient machine code from a 
nOtation designed for people rather than machines. The model for the Fortran 
nOtation was what scientists and engineers wrote when solving problems using 

22,2 
PROGRAMMING LANG UAG E HISTORY OVERVI EW 
mathematics, radlcr dmn dIe machine instructions provided by the (then very 
new) clectronic computers. 
From a modem perspective, Fortran can be seen as the first auempt to di-
rectly represent an application domain in codc. It allowed proh'Tammers to write 
linear algebra much as they found it in textbooks. Fortran provided arrays, loops, 
and standard mathematical functions (using the standard mathematical nOlation, 
such as x+y and sin(x)). 111ere was a standard libraty of mathematical functions, 
mechat1isms for 110, and a user could defme additional functions atld libraries. 
"nle notation was largely machine independent so that Fort.ran code could 
often be moved from computer to computer with only minor modification. This 
was a /lUge improvement over the state of the art. 11lerefore, FOnratl is considered 
dIe first high·level programming language. 
It was considered essential that the machine code generated from the Fortratl 
source code was dose to optimally efficient: machines were room·sized and enor· 
mously expensive (many times the yearly salary of a team of good program· 
mers), they were (by modem standards) ridiculously slow (such as 100,000 
instructions/second), and they had absurdly small memories (such as 8K bytes). 
However, people were fitting useful programs into those machines, and an im· 
provement in nmation Oeading to better progranuller productivity and portabil· 
ity) could not be allowed to get in the way of that. 
Fortran was hugely successful in its L:'lfget domain of scientific and engineering 
calculations and has been under cominuous evolution ever since. TIIC main ver-
sions of the Fortran language arc II, IV, 77, 90, 95, 03. It is still debated whether 
Fortran77 or FOItran90 is more widely used today. 
787 

788 
CHAPTER 22 • IDEALS AND HI STORY 
The rust definition of and implementation of Fortran were done by a team at 
IBM lcd by John Backus: "We did not know what we wanled and how to do il. It 
just sort of grew." How could he have known? Nothing like that had been done 
before, but along the way they developed or discovered the basic structure of 
compilers: lexical analysis, syntax analysis, semantic analysis, and optimization. 
To t.his day Fortran leads in the optimization of numerical computations. One 
thing that emerged (after the initial Fortran) was a notalion for specifying gram-
mars: the Backus-Naur Form (BNF). It was first used for AJgol60 (§22.2.3.1) 
and is now used for most modem languages. We use a version of BNF for our 
grammars in Chapters 6 and 7. 
Much later, J ohn Backus pioneered a whole new branch of programming 
languages ("functional programming"), advocating a mathematical approach to 
programming as opposed to the machine view based on reading and writing 
memory locations. Note that pure math docs not have the notion of assignment, 
or even actions. Instead you "simply" state what must be true given a sct of con-
ditions. Some of the roots of functional programming are in Lisp (§22.2.2.3), 
and some of the ideas from functional programming are reflected in the STL 
(Chapter 21). 
References 
&ckus,John. "Can Programming Be Liberated from lhe von Neumallll Style?" 
Camnllm;whom q{th£ ACM, 1977. (His Turing award leclllre.) 
Backus, John. "The History of FORTRAN I, II, and III." ACM SIGPLAN 
NotiaJ, Vol. 13 No.8, 1978. Special Issue: History of Programming Languages 
Conference. 
Hutton, Grahanl. Programming in Haskell. Cambridge University Press, 2007. 
ISBN 052 1692695. 
150/1 EC 1539. Programming Languages - rortran. (The "Fortran 95" standard.) 
Paulson, L. C. ML far 11/£ f%rkvlg Programmer. Cambridge University Press, 199 1. 
ISBN 0521390222. 
22.2.2.2 COBOL 
COBOL ("The Common Business-Orientcd Language") was (and sometimcs 
still is) for business programlllers what Fortran was (and sometimes still is) [01' 
scientific programmers. TI1C emphasis was on data manipulation: 
Copying 
Storing and retrieving (record keeping) 
Printing (rcports) 

22.2 
PROGRAMMING LANGUAGE H ISTORY OVERVIEW 
Calculation/computation was (often correctly in COBOVs core application do-
mains) seen as a minor matter. It was hoped/claimed that COBOL was so close 
to "business English" t..hat managers could program and programmers would 
soon become redundanl. That is a hope we have heard frequently repeated over 
the years by managers keen on cutting the COSt of progranuning. It has never 
been even remotely tnle. 
COBOL was initially designed by a commiuee (CODASYL) in 1959-60 at 
the initiative of the U.S. Department of Defense and a group of major computer 
manufacturers to address the needs of business-related computing. The design 
built directly on the FWW·MATIC language invented by Grace Hopper. One of 
her contributions was the use of a close-to-English syntax (as opposed to the 
mathematica1 notation pioneered by Fortran and still dominant today). Like For-
tran - and likc all successful languages - COBOL underwent continuous evolu-
tion. The major revisions were 60, 61 , 65, 68, 70, 80, 90, and 04. 
Grace Murray Hopper had a Ph.D. in mathematics from Ya1e University. 
She worked for the U.S. Navy on the very first computers during World War II. 
She returned to the navy after a few years in the early computer industry: 
'-Rear Admiral Dr. Grace Murray Hopper (U.S. Navy) was a remarkable 
woman who grandly rose to lhe challenges of programming the first 
computers. During her lifetime as a leader in the field of software devel-
opment concepts, she contributed to the transition from primitive pro-
gt"a11l11ung tcchluqucs to thc use of sophistic.a.ted compilcrs. She believed 
that 'wc·vc always done it that way' was not necessarily a brood reason to 
continue to do so." 
- AlUla Borg, at lhe "Crnce Hopper Celebration of 
Women in Computing" conference, 1994 
78. 

CH APTER 22 • IDEALS AND HISTORY 
Grace Murray Hopper is often credited with being the first person to call an 
error in a computer a "bug." She certainly was among the early users of the term 
and documented a usc: 
As can be seen, that bug was real (a moth), and it affected the hardware directly. 
Most modem bugs appear to be in the software and have Icss graphical appeal. 
References 
A biography of C. M. Hopper: http://tergcstcsofl.com/-eddysworldlhopper.htm. 
ISO/lEe 1989:2002. by""""Ji"" 7idnwlogy - Progmmming Longuarp - COBOL. 
Samlllet,J ean E. "TIle Early History of COBOL." ACM SIGPLAN Nohen, Vol. 13 
No.8, 1978. Special Issue: History of Programming Languages Conference. 
22.2.2.3 Lisp 
Lisp was originally designed in 1958 by John McCarthy at MIT for linked·list 
and symbolic processing (hence its name: "LISt Processing"). Initially Lisp was 
(and is often still) interpreted, as opposed to compiled. There arc dozens (most 
likely hundreds) of Lisp dialects. In fact, it is often claimed that "Lisp has an im-
plied plural." The current most popular dialects are Conunon Lisp and Scheme. 
~ni s famil y of languages has been (and is) the mainstay of artificial intelligence 
(AI) research (though delivered products have often been in C or C++). One of 
the main sources of inspiration for Lisp was the (mathematical notion of) lambda 
calculus. 
rortran and COBOL were specifically designed to help ddivcr solutions to 
real'world problems in their respective application areas. TIle Lisp community 
was much more concerned with programming itself and the elegance of pro' 
grams. Often these efforts were successful. Lisp was the first language to separate 
its definition from the hardware and base its semantics on a form of math. If Lisp 
had a specific application domain, it is far harder to define precisely: "AI" or 
"symbolic computation" don't map as clearly into common everyday tasks as 
"business processing" and "scientific programming." Ideas from Lisp (and from 
the Lisp community) can be found in many more modem languages, notably the 
functional languages. 

22 .2 
PROGRAMMING LANG UAG E HISTORY OVERVIEW 
J ohn McCarthy's B.S. was in mathematics from the California Institute of 
lcchnology and his Ph.D. was in mathematics from Princeton University. You 
may notice that there are a lot of math majors among the programming language 
designers. After his memorable work at M IT, McCarthy moved to Stanford in 
1962 to help found the Stanford AI lab. He is widely credited for inventing the 
term artificial ill/elligmu and made many contributions to that field. 
References 
Abelson, Harold, and GeraldJ. Sussman. Structure (lIId lllterprttahon qf01mjmter Pro-
grams, &cond Edition. Mrf Press, 1996. ISBN 0262011530. 
ANSI INCITS 226-1994 (formerly ANSI X3.226:1994). Amen'can National Slall-
dan/for Programmil/g umgllagr - 01111111011 USP. 
McCarthy,J ohn. "Hi:ilory of LISP." ACM SIGPLAN Notice;, Vol. 13 No.8, 1978. 
Special Issue: History of Programming Languages Conference. 
Steele. Guy L.Jr. O1mml111 Ii.sp: The Uu~. Digital Press, 1990. ISBN 1555580416. 
Steele, Guy L. Jr., and Richard Gabriel. "TIle Evolution of Lisp." Proceedings of 
the ACM History of Programming Languages Conference (HOPL·2). ACM 
SIGPLAN Notim, Vol. 28 No.3, 1993. 
22.2.3 The Algol family 
In the late 1950s, many fclt that progranuning was getting tOO complicated, too ad 
hoc, and too unscientific. ~fbey fclt that the variety of programming languages 
was unnecessarily great and that those languages were put together with insuffi-
cient concern for generality and sound fundamental principles. TIus is a sentiment 
that has surfaced many times since then, but a group of people came together 
under the auspices of IFIP (the International Federation of Infonnation Process-
ing), and in just a couple of years they created a new language that revolutionized 
the way we think about languages and their definition. Most modem languages -
including C++ - owe much to this effort. 
791 

792 
CHAPTER 22 • IDEALS AND HI STO RY 
22.2.3.1 AIgol60 
111C "ALGOritlunic Language," Algol, which resulted from the effofts of the 
I FIP 2.1 group, was a breakthrough of modern programming language concepts: 
Lexical scope 
Use of grammar to define the language 
Clear separation of syntactic and semantic rules 
Clear separation of language definition and implementation 
Systematic use of (static, i.e., compile-time) types 
Direct support for structured programming 
The very notion of a "general-purpose progranuning language" came with AlgoL 
Before that, languages were scientific (e.g., Fonran), business (e.g., COBOL), list 
manipulation (e.g" Lisp), simulation, eLC. Of these languages, AlgoJ60 is most 
closely related to Fortran. 
Unfortunately, A1go160 never reached major nonacademic usc. It was seen as 
"too weird" by many in the industry, "too slow" by Fonran progranmlers, "nOI 
supportive of business processing" by COBOL programmers, "nOI flexible 
enough" by Lisp programmers, "too academic" by most people in the induslry 
(including the managers who controlled investment in tools), and "100 Euro· 
pean" by many Americans. Most of the criticisms were correct. For example, the 
AIgol60 repon didn'l define any lIO mechanism! However, similar criticisms 
could have been leveled at just about any cOlllemporary language - and Algol set 
the new standard for many areas. 
One problem \vith Algol60 was that no one knew how to implement it. That 
prOblem was solved by a team of programmers led by Peter Naur (the editor of 
the Algol60 report) and Edsger Dijkstra: 

22.2 
PROGRAMM ING LANG U AG E HI STORY OVERVIEW 
Peter Naur was educated (as an astronomer) at the University of Copen-
hagen and worked at the l echnical University of Copenhagen (DTH) and for 
the Danish computer manufacturer Regnecemralen. He learned programming 
early (1950-5 1) in the Computer Laboratory in Cambridge, England (Demnark 
didn't have computers that early) and later had a distinguished career spanning 
the academia/industry gulf. He was co-inventor of BNF (the"Backus-Naur 
1;0.,))") used to describe grammars and a very early proponent of formal reason-
ing about programs (BjaOle Stroustfup first - in 1971 or so - learned the usc of 
invariants from Peter Naur's technical articles). Naur consistently maintained a 
thoughtful perspective on computing, always considering the human aspects of 
programming. In fact, his later work could reasonably be considered part of phi-
losophy (except that he considers conventional academic philosophy utter non-
sense). He was the first professor of Datalogi at the University of Copenhagen 
(the Danish tenn (wlalogi is best translated as "infonllalics"; Peter Naur hates the 
tcnll computer oScUm!e as a misnomer - computing is not primarily about computers). 
Edsger Dijkstra \\!3.S another of computer science's all·time greats. He studied 
physics in Leyden but did his early work in computing in Mathematisch Ceo· 
lmm in Amsterdam. He later worked in quite a few places, including Eindhoven 
University of Technology, Burroughs Corporation, and the University of Texas 
(Austin). In addition to his seminal work on Algol, he was a pioneer and strong 
pmpollent of the use of mathematical logic in programming, algorithms, and Olle 
of the designers and implementers of THE operating system - one of the first 
operating systems to systematically deal with concum:ncy. THE stands for 
"Technische Hogeschool Eindhoven" - the university where Edsger Dijkstra 
worked at the time. Arguably, his most famous paper was "Go-To Statement 
Considered Harmful ," which convincingly demonstrated the problems with un-
stmctured control flows. 

(HAPTER 22 • IDEALS AND HISTORY 
TIle Algol family tree is impressive: 
A1go158 
A1go160 
A1go168 
Ole Simula67 and PascaL These languages are the ancestors to many (probably 
most) modern languages. 
References 
Dijkstta, Edsger W. "Algol 60 Translation: An Algol 60 Translator for lhe xl and 
Making a Translator for Algol 60." Report MR 35/61. Mathematisch Cemmm 
(Amsterdam), 1961. 
Dijkstra, Edsger. "Go·To Statement Considered Harmful." O,wmulIicatiollJ 0/ the 
ACM, Vol. II No.3, 1968. 
Lindsey, C. H. "111e HislOry of AlgoI68." Proceedings of the ACM History of 
Progranuning Languages Conference (HOPL-2). ACM SIGPLAN Notice;., Vol. 
28 No.3, 1993. 
Naur, Peter, ed. "Revised Report on the Algorillullic Language Algol 60." NS 
Regnecemralen (Copenhagen), 1964. 
Naur, Peter. "Proof of Algorithms by General Snapshots." BIT; Vol. 6, 1966, pp. 
310-16. Probably the first paper on how to prove programs correct. 
Naur, Peter. "The European Side of the Last Phase of the Development of 
ALGOL 60." ACM SICPLAN Notiw, Vol. 13 No.8, 1978. Special Issue: His· 
tory of Programming Languages Conference. 
Periis, Alan]. "The American Side of the Development of AlgoL" ACM SIC-
PLAN Notius, Vol. 13 No.8, 1978. Spcciallssue: History of Programming Lan· 
guages Conference. 
van Wtingaarden, A., B.]. Mailloux,]. E. L. Peck, C. H. A. Kosler, M. SintzoIT, 
C. H. Lindsey, L. G. L. T. Meertens, and R. C. Fisker, eds. Rcuised Report 01/ the 
Algoril/lll1ic umguage Algol 68 ($cpt. 1973). Springer·Verlag, 1976. 
22.2.3.2 Pascal 
TIle Algol68 language mentioned in the Algol family tree was a large and ambi-
tious project. Like Algo160, it was the work of "the Algol cOllullittee" (lFIP work-
ing group 2.1), but it took "forever" to complete and many were impatient and 
doubtful that something useful would ever come from that projecl. One member 
of the A1gol committee, Niklaus Wirth, decided simply to design and implement 
his own successor to Algol. In contrast to Algo168, that language, called Pascal, 
was a simplification of Algo160. 

22.2 
PROGRAMMING LANGUAGE HI STORY OVERVIEW 
Pascal was completed in 1970 and was indeed simple and somewhat inflexi· 
ble as a result. It was orten claimed to be intended just ror teaciling, but early pa-
pers describe it as an alternative to Fortran on the supercomputers or the day, 
Pascal was indeed easy to learn, and arter a very portable implementation be· 
came available it became very popular as a teaching language, but it proved to be 
no threat to Fortran. 
Pascal was the work or Proressor Niklaus Wirth (photos rrom 1969 and 
2004) or the Technical University or Switzerland in Zurich (ETH). His Ph.D. (in 
elect,'ieal engineering and computer science) is rrom the University or Calirornia 
at Berkeley, and he maintains a lirelong connection with Calirornia. Proressor 
Wirth is the closest thing the world has had to a proressionallanguage designer. 
Over a period or 25 years, he designed and implemented 
Algol W 
PI.J360 
Euler 
Pascal 
Modula 
Modula·2 
Oberon 
Oberon·2 
Lola (a hardware description language) 
NikJaus Wirth describes this as his unending quest ror simplicity. His work has 
been most influential. Studying that series or languages is a most interesting exer· 
cise. Proressor Winh is the only person ever to present twO languages at HOPL. 
In the end, pure PascaJ proved to be toO simple and rigid for industrial suc· 
cess. In the 1980s, it was saved rrom extinction primarily through the work or 

CHAPTE R 22 • ID EAL S AND HI STORY 
Anders Hejlsberg. Anders Hejlsberg was one of the three founders of Borland. 
He first designed and implemented Turbo Pascal (providing, among other things, 
more flexible argument-passing facilities) and later added a C++-like object 
model (but with just single inheritance and a nice module mechanism). He was 
educated at the Technical University in Copenhagen, where Peter Naur occasion-
ally lectured -
it's somelimes a vely small world. Anders Hejlsberg later de-
signed Delphi for Borland and Coif for Microsoft. 
The (necessarily simplified) Pascal family tree looks like this: 
Turbo Pascal 
Borland Pascal 
Delphi 
Pascal 
Pascal-2 
Modula 
Modula-2 
~O~b~c~m~ny-~ Oberon·2 
References 
BoriandlTurbo Pascal. http://en.wikipedia.orglwikifTurbo_Pasc.1.1. 
Hejlsberg, Anders, Scolt Willamuth, and Peter Golde. TIre ON< Prog1WIIIIIUIg Lmlgll(~, 
&emul £liJjq,,_ Microsoft _NET Development Series. ISBN 0321334434. 
Wrrth, Niklaus. "TIle Programming Language Pascal." Acla byrmllllJia, Vol. I Fasc 1, 
1971. 
\Virth, Niklaus. "Design and lmplementation of Modula_" Sojtware- Prartice and 
Exj)tril1/{:e, Vol. 7 No. 1, 1977. 
Wirth, Niklaus_ "Recollections about the Development of Pascal." Proceedings of 
the ACM History of Programming L1.nguages Conference (HOPL-2). ACM 
SlGPLAN .N'otias, Vol. 28 No.3, 1993. 
Wirth, Niklaus. Modula-2 (lJUJ Oberon. Proceedings of the lllird ACM SICPLAN 
Conference on the History of Prograillmillg Languages (HOPL-llI). San 
Diego, CA, 2007. http://port.1.Lacm.orgltoc.cfm?id= 1238844-. 
22.2.3.3 Ada 
"nle Ada progranuning language was designed to be a language for all the pro-
gramming needs of the U.S. Department of Defense. In particular, it was to be a 
language in which to deliver reliable and maintainable code for embedded sys-
tems programming. Its most obvious ancestors are Pascal and Simula (see 

22 .2 
PROGRAMMING LANGU AG E HI STORY OVERVIEW 
§22.2.6). ~111 e leader of the group that designed Ada was jean Ichbiah - a past 
chainnan of the Simula Users' Croup. TIle Ada dcsign emphasized 
Data abstraction (but no inheritance until 1995) 
Strong static type checking 
Dircct language support concurrency 
"111e design of Ada aimed to be the embodiment of software engineering in pro-
gramming languages. Consequently, the U.S. 000 did not design the language; 
it designed an elaborate process for designing the language. A huge number of 
people and organizations contributed La the design process, which progressed 
through a series of competitions. to produce the best specification and next to 
produce the best language embodying the ideas of the winning specification. 
111is inunense 20-year project (1975-98) was from 1980 managed by a depart-
ment called Aj PO (Ada j oint Program Office). 
In 1979, the resulting language was named after Lady Augusta Ada Lovelace 
(a daughter of Lord Byron, the poet). Lady Lovclace could be claimed to have 
been the first programmer of modern times (for some definition of "'modern") be-
calise she had worked with Charles Babbage (the Lucasian Professor of Mathe-
matics in Cambridge - that's Newlon's chair!) on a revolutionary mechanical 
computer in the I840s. Unfortunately, Babbage's machine \ \f3S unsuccessful as a 
practical 1001. 
~nmnk.s to lhe c1aborate process, Ada has been considered thc ultimate design. 
by-committee language. TIle lead designer of the wuming design team, j ean Ichbiah 
from the French company Hone)'\vcll Bull, emphatic.'llly denied that. However, I 
suspeCt (based on discussion with him) that he could have designed a better lan-
guage, had he not been so constrained by the process. 
797 

". 
CHAPTER 22 • IDEALS AND HI STORY 
Ada's Lise was mandated for military applications by the 0 00 for many 
years, leading to the saying "Ada, it's nOtjusl a good idea, it's the law!" Initially, 
the usc of Ada was just "mandated," but when many projects received "waivers" 
to L1SC other languages (typically C++), the U.S. Congress passed a law requiring 
lhe use of Ada in most military applications. That law was later rescinded in the 
face of commercial and technical realities. Bjame StrOuSlfup is one of the vcry 
few people to have had his work banned by the U.S. Congress. 
"nlat said, we insist that Ada is a much beuer language than its reputation 
would indicate. We suspect that if the U.S. DoD had heen less heavy-handed 
about its usc and the exact way in which it was to be used (standards for applic.1.-
tion dcvelopmelll processes, sofnvare development tools, documentation, etc.), it 
could have become noticeably more successful. To this day, Ada is important in 
aerospace applications and similar advanced embedded systems application 
areas. 
Ada became a military standard in 1980, an ANS I standard in 1983 (the first 
implementation was done in 1983 - three years cifier the first standard!), and an 
ISO standard in 1987. The ISO standard was extensively (but of COllfse compati-
bly) revised for a 1995 ISO standard. Notable improvements included more flex-
ibility in the concurrency mcchanisms and support for inheritance. 
References 
Barnes,John. Programmi1lg ill Ada 2005. Addison-Wesley, 2006. ISBN 0321340787. 
Consolidated Ada Reference Manual, consisting of the international standard 
(ISO/lEG 8652:1995). bfonnntum Teduwlogy - Progrwmllillg LmI{§mgt!S - Ada, as up-
daLOd by changes from 7idmiaJ Omig<>",um 1 ~SO/IEC 8652: 1995TC 1 :2000). 
Official Ada homepage: www.usdoj.gov/crt/adal. 
Whitaker, William A. ADA - The Project: The DoD High Order lLmguage Hf1rkillg 
Croup. Proceedings of the ACM History of Programming Languages Confer-
ence (HOPL-2). ACM SICPIAN NoticeJ, Vol. 28 No.3, 1993. 
22.2.4 Simula 
Simula was developed in the early to mid-1960s by Kristen Nygaard and Olc-
Johan Dahl at the Norwegian Computing Center and Oslo University. Simula is 
indisputably a member of the Algol family of languages. In fact, Simula is almost 
completely a superset of Algo160. However, we choose to single alit Simula for 
special attention because it is the source of mOst of the fundamental ideas that 
today are referred to as "object-oriented programming." It was the first language 
to provide inheritance and virtual functions. 111e words c/llJJ for "user-defined 
type" and virtual for a function that can be overridden and called through the in-
terface provided by a base class come from Simula. 

2 2,2 
PROGRAMMING LANG U AGE HI STORY OVERVIEW 
Simula's conllibution is not limited to language features. It came with an ar· 
ticulated notion of object-oriented design based on the idea of modeling re.."ll· 
world phenomena in code: 
Represent ideas as classes and class objects. 
Represelll hierarchical relations as class hierarchies (inheritance). 
l lms, a program becomcs a set of interacting objects rather tlmll a monolith. 
Kristen Nygaard - the co-inventor (with Ole:Johan Dahl, to the left, wearing 
glasses) of Sinmla 67 - was a giant by most measures (including height), with an 
intensity and generosity to match. He conceived of the fundamental ideas of 
object-oriented programming and design, notably inheritance, and pursued their 
implications over decades. He was never satisfied with simple, short-term, and 
shortsighted answers. He had a constant social involvement that lasted over 
decades. He can be given a fair bit of credit for Norway staying out of the Euro-
pean Union, which he saw as a potential centralized and bureaucratic nightmare 
that wOlild be insensitive to the needs of a small country at the far edge of the 
Union - Norway. rnthe mid-1970s Kristen Nygaard spent significant time in the 
computer science department of the University of Aarhus, Denmark (where, at 
the tillie, Bjame StrOlIstrup was studying for his master's degree). 
Kristen Nygaard's master's degree is in mathematics from the University of 
Oslo. He died in 2002, just a month before he was (together with his lifelong 
friend Ole:Johan Dahl) to receive the ACM's Tliring Award, arguably the highest 
professional honor for a computer scientist. 
'99 

800 
CHAPTER 22 • IDEALS AND HI STORY 
Olc:Johan Dahl was a morc conventional academic. He was vcry imcrested 
in specification languages and formal mclllOds. In 1968, he became the first full 
professor of informatics (compuler science) at Oslo University. 
In August 2000 Dahl and ygaard wcre made Commanders of the O rder of 
Saint Olav by the King of 
onvay. Even truc gccks can gain recognition in their 
hometown! 
References 
Bin"wistlc, G., O:}. Dahl, B. Myhrhaug, and K. Nygaard: SlMULA &gUl. Student-
liucratur (Lund. Sweden), 1979. ISBN 9 144062125. 
Hoimcvik,j. R. "Compiling SIM U LA: A Historical Study ofTcdmological Gen-
esis." /1:."'££ AIIIUlb of tIlt Hutory o/Unllpuhilg, Vol. 16 No.4, 1994, pp. 25-37. 
Kristen Nygaard's homcpage: http:lnlcim.ifi.uio.nol- kristcn/. 
Krogdahl, S. "111C Birth of Simula." Proceedings or the HiNC I Conrerence in 
Trondheim,June 2003 (l FIP we 9.7, in cooperation with IFIP TC 3). 
Nygaard, Kristen, and Ole:Johan Dahl. "~111e Development of the SIM ULA 
Languages." ACM SIGPLAN Notius, Vol. 13 No.8, 1978. Special Issue: HistOl), 
or Programming Languages Conference. 
SIMULA Standard. DATA proaSJillg - Progrmll1l11ilg !allguageJ - SIM ULA. Swedish 
Standard, Stockholm, Sweden (1987). ISDN 9 171622349. 
22.2.5 C 
In 1970, it was "well known" that serious systems programming - in particular 
the implementation or an operating system - had to be done in assembly code 
and could not be done portably. That was much as the situation had been ror sci· 

22.2 
PROGRAMMIN G LANG U AGE HISTORY OVERVIEW 
emific programming before Fortran. Several individuals and groups set out to 
challenge that orthodoxy. In the long run, the C programming language (Chap-
ter 27) was by rar the most successful of those effons. 
Dennis Ritchie designed and implemented ule C programming language in 
Bell 1clephone Laboratories' Computer Science Research Center in MUlTaY Hill, 
New J ersey. 111e beauty of C is that it is a deliberately simple programming lan-
guage sticking very close to the fundamental aspects of hardware. Most of the 
current complexities (most of which reappear in C++ for compatibility reasons) 
were added after his original design and in several cases over Dennis Ritchie's 
objections. Part of C's success was its early wide availability, but its real strength 
was its direct mapping of language features to hardware facilities (sec §2S.4- S). 
Dennis Ritchie has succinctly described C as "a strongly typed, but weakly 
checked language"; that is, C has a static (compile-time) type system, and a pro-
gram that uses an object in a way that differs from its definition is not legal. How-
ever, a C compiler can't check thal. 111al made sense when the C compiler had to 
run in 48K bytes of memory. Soon after C came into usc, people devised a pro-
gram. called lint, that separately from the compiler verified conformance to the 
type system. 
Together with Ken 11lOl11pson, Dennis Ritchie is the co-inveillor of Unix, 
easily the most inOuential operating system of aU times. C was - and is - associ-
ated with the Uni." operating system and through that with Linux and the open-
source movement. 
DelU1is Ritchie is retired from Lucent Bell L'lbs. For 40 years he worked in Bell 
L'lboratories' Computer Science Research Center. He is a graduate of Harvard 
University (physics); his Ph.D. is in applied mathematics from Harvard University. 
801 

802 
CHAPTER 22 • IDEALS AND HI STO RY 
In the early years, 1974-1979. many people in Bell L1.bs influenced the de-
sign of C and ilS adoption. Doug McIlroy was everybody's favorite critic, discus-
sion partner, and ideas man. He influenced C, C++. Unix, and much morc. 
Brian Kernighan is a programmer and writer cxtraordinairc. Both his code 
and his prose arc models of clarity. lllC style of this book is in part derived from 
lhe tutorial sections of his masterpiece, fI,e C Progl"tlllllllillg UlIIgtUl/:,'t (known as 
"K&R"' after its co-authors Blian Kernighan and Dennis Ritchie). 
It is not enollgh to have good ideas; to be useful on a large scale, those ideas 
have 10 be reduced to their simplest form and articulated dearly in it way that is 

22.2 
PROG RAMMING LANG UAGE HI STORY OVER VIEW 
accessible to large numbers of people in their target audience. Verbosity is among 
the worst enemies of such presentation of ideas; so is obfuscation and over-
abstraction. Purists often scoff at the results of such popularization and prefer 
"original results" presented in a way accessible only to expertS. We don't: geuing 
a nontrivial, blll valuable, idea into the head of a novice is difficult, essential to 
the growth of professionalism, and valuable to society at large. 
Over the years, Brian Kernighan has been involved with many influential pro· 
gramming and publishing projectS. 1 .. \10 examples arc AWK - an early scripting 
language named by the initials of itS authors (Aha, Weinberger, and Kernighan) -
and AM PL, "A Mathematical Programming Language." 
Brian Kemighan is currently a professor at Princeton Univcrsity; he is of 
COUfse an excellent teacher, specializ.ing in making otherwise complex topics 
clear. For morc than 30 years he worked in Bell Laboratories' Computer Science 
Research CelUer. Bell Labs later became AT&T Ben Labs and later still split into 
AT &T Labs and Lucent Bell Labs. He is a graduate of the University of Toronto 
(physics); his Ph.D. is in electrical engineering from Princeton University. 
TIle C language family tTee looks like this: 
CPL 
Kcn Thompson. 
BTL, 19n __ 
BCPL 
Classic C 
--- Martin Richards, 
Cambridge, 1967 
'Christophcr Strochey, 
Cambridge, mid'1960s 
" 
The origins of C lay in the never-completed C PL project in England, the 
BCPL (Basic C PL) language that Martin Richards did while visiting MIT on 
leave from Cambridge University, and an interpreted language, called B, done by 
Ken Thompson. Later, C was standardized by ANSI and the ISO and there were 
a lot of iJillucnces from C++ (e.g., function argument checking and consts). 
C PL was ajoint project between Cambridge University and Imperial College 
in London. Initially, the project had been done in Cambridge, so "C" officially 
stood for "Cambridge." When Imperial College became a partner, the official ex-
planation of the "c" beca . .me "Combined." In reality (or so we arc told), it always 
stood for "Christopher" after Christopher Slrachey, CPL's main designer. 
References 
Brian Kernighan's home page: http://cm.bell-labs.comlcmlcs1wholbwk. 
Dennis Ritchie's home page: hup:lfcm.bell-Iabs.comlanlcs/who/dmr. 
ISO/IEIC 9899: 1999. Programming umguaga - C. (The C standard.) 
""3 

C HAPTER 22 • IDEAlS AND HISTORY 
Kemighan, Brian, and Dennis Ritchie. 17te C Programming umguage. Prentice Hall. 
1978. Second Edition, 1989. ISBN 0131103628. 
A list of members of the IkU Labs' Computer Science Research Center: http://an.bcll-
labs.com/an/csJalumni.hUlll. 
Ritchards, Martin. BCPL - The Language and Its (;om/)11er. Cambridge University 
Press, 1980. ISBN 052 1219655. 
Ritchie, Dennis. "111e Developmem of the C Programming Language. Proceed· 
ings of the ACM History of Programming Languages Conference (HOPL-2). 
ACM SIGPLAN No/iuJ, Vol. 28 No.3, 1993. 
Salus, Peter. A Qjar/er Gel/iliry 9/UNIX. Addison-Wesley, 1994. ISBN 0201547775. 
22.2.6 C++ 
C++ is a general-purpose programming language with a bias toward systems 
programming lhat 
Is a belter C 
Supports data abstraction 
Supports object-oriented progranuning 
Supports generic programming 
It was originally designed and implemellted by Bjarne Stroustrup in Bell Tele-
phone Laboratories' Computer Science Research Center in Murray Hill, New 
J ersey, that is, down the corridor from Dennis Ritchie, Brian Kernighan, Ken 
l11Ompson, Doug McIlroy, and other Unix greats. 

22.2 
PROGRAMMING LANGU AGE HISTORY OVERVIEW 
Bjarne Stroustrup received a master's degree (in mathematics with computer 
science) from the universil)' in his hometown, Arhus in Denmark. TIlen he went 
to Cambridge. where he got his Ph.D. (in computer science) working for David 
\¥heeler. ~nl e main contributions of C++ were to 
Make abstraction techniques alTordable and manageable for mainstream 
projects 
Pioneer the use of o bj ect~oriented and generic programming techniques 
in application areas where efficiency is a premium 
Before C++, t.hese techniques (often sloppily lumped t.ogether under the label of 
"object-oriented progranuning") were mostly unknown in the indust.ry. As with 
scientific programming before Fortran and systems programming before C, it. 
was Mwell known" that these techniques were too expensive for real-world use 
and also too complicated for "ordinary progranuners" to master. 
' 11e work on C++ starled in 1979 and led to a commercial release in 1985. 
After its initial design and implementation, Bjarne Stroustmp developed it. further 
toget.her with friends at Bell L.:.bs and elsewhere until its standardization officially 
starled in 1990. Since then, the definition of C++ has beell developed by first 
ANSI (the national standards body for the United States) and since 1991 by ISO 
(the international standards organil.ation). Bjarne Stroustrup has taken a major 
part in that elTon as the chairman of the key subgroup in charge of new language 
features. , 11e first international standard (C++98) was ratified 1998 and the sec· 
ond is in the works (C++Ox). 
"n e most significant development in C++ after its initial decade of growth 
was the S11.. - lhe standard library's facilities for containers and algorithms. It 
was the outcome of work - primarily by Alexander Stepanov - over decades 
aiming at producing lile most general and efficient software, inspired by the 
beauty and utility of mathematics. 
805 

CHAPTER 22 • IDEALS AND HI STORY 
Alex Stepanov is the inventor of the S11.. and a pioneer of generic program-
tning. He is a graduate of the University of Moscow and has worked on robolics, 
algorithms, and more, using a variety of languages (including Ada, Scheme, and 
C++). Since 1979, he has worked in U.S. ac.,demia and industry, notably at CE 
Labs, AT&T Bell L,bs, Hewlett-Packard, Silicon Craphics, and Adobe. 
1978-89 
'11e C++ family tree looks like this: 
C with Classes 
1979- 84 
c++ 
ARM C++ 
1989 
C++98 
"C with Classes" was Bjarne StrOuslnlp's initial synthesis of C and Simula 
ideas. It died inunediately following the implementation of its successor, C++. 
Language discussions often focus on elegance and advanced features. How-
ever, C and C++ didn't become twO of the most successful languages in the bis-
tory of computing that way. '11eir strengths were nexibility, performance, and 
stability. Major software systems live over decades, often exhaust their hardware 
resources, and often suffer completely unexpected changes of requirements. C 
and C++ have been able to thrive in that environment. Our favorite Dennis 
Ritchie quote is, "Some languages arc designed to prove a point; others arc de-
signed to solve a problem." By "others," he primarily meant C. Bjal1le Strollslnlp 
is fond of saying, "Even I knew how to design a prettier language than C++." 
The aim for C++ - as for C - was not abstract beauty (though we strongly ap-
preciate that when we can get it), but utility. 
I have often regretted nOt being able to use C++Ox features in this book. It 
would have simplified many c.xamples and explanations. However, unordered_map 
(§21.6.4), array (§20.9), and regexp (§23.5-9) arc examples from lhe C++Ox stan· 
dard library. C++Ox will also feature better checking of templates, simpler and morc 
general in.itializmion, and in places a more robust notation. Sec my HOPL-lII p"pcr. 
References 
Alcxander Slepanov's publications: \V\vvv.stepanovpapers.com. 
Bjame StrouStlUP'S home page: www.researcll.att.com/ -bs. 
ISO/IEC 14882:2003. Programming Languages - C++. (Ille C++ standard.) 
Stroustrup, Bjamc. "A History of C++: 1979-1991. Proceedings of the ACM 
History of Programming Languages Conrerence (HOPL·2). ACM SIGPLAN 
Nolim, Vol. 28 No.3, 1993. 
Stroustrup, Bjarne. 771£ Design and Evolution o/"C++. Addison-Wesley, 1994. ISH 
02015'13303. 
Stroustrup, Bjarne. '(he C++ Programming Language (Special £ilil;on). Addison-Wes-
ley, 2000. ISBN 020 1700735. 

22 .2 
PROGRAMMING LANGUAGE HI STORY OVERVIEW 
StrouStrup, Bjarnc. "C and C++: Siblings" ; "C and C++: A Case for Compati-
bility"; and "C and C++: Case Studies in Compatibility." 7k C/C++ UjC"J 
JOlimal.July, Aug., and Sept. 2002. 
SU'OllStrup, Bjame. ;'Evolving a Language in and for the Real World: C++ 1991-
2006. Proceedings of the Third ACM SIGPLAN Conference on the History 
of Programming Languages (HOPL-III). San Diego, CA, 2007. http://ponaL 
acm.orgltoc.cfm?id=1238844. 
22.2.7 Today 
What programming languages are currently lIsed and for what? That's a really 
hard question to answer. The family u'ee of curremlanguages is - evcn in a most 
abbreviated fonn - somcwhat crowded and messy: 
Lisp 
CfnranV 
J ava95 
Simula67 
EifTeJ 
C89 
c++ 
C++98 
ADA 
ADA98 
Cit2.0 
Pascal 
Object Pascal 
COBOL04 
COB0L89 
Q
sualBasv 
In fact, most of the statistics we find on the web (and elsewhere) are hardly better 
than rumors because they measure things that are only weakly correlated with 
usc, stich as numbcr of wcb postings containing the name of a programming lan-
guage, compiler shipments, academic papers, books sales, etc. All such measures 
favor the new over the established. Anyway, what is a programmer? Someone 
who uses a programming language every day? How about a student who writes 
small programs just to learn? A professor who just talks about programming? A 
physicist who writes a progranl almost every year? Is a professional programmer 
who - almost by definition - uses several programming languages every week 
counted many times or just once? We have seen each of these questions an-
swered each way for different statistics. 
However, we feel obliged to give you an opinion, so in 2008 there arc about 
10 million professional programmers in the world. For that opinion we rely on 
007 

( HAPTER 22 • IDEALS AND HISTORY 
lOG (a data-gathering firm), discussions with publishers and compiler suppliers, 
and various web sources_ Feel free to quibble, but we know the number is larger 
than I million and less than 100 million for any halfway reasonable definition of 
"programmer." Which language do they use? Ada, C, C++, Cf', COBOL, For-
tran,Java, PERL, PHP, and VISual Basic probably Gust probably) account for 
significantJy more than 90% of all programs. 
In addition to the languages mentioned here, we could list dozens or even 
hundreds more. Apart from trying to be fair to interesting or important lan-
guages, we see no point. Please seck out infonnation yourself as needed. A pro-
fessional knows several languages and leams new ones as needed. 111ere is no 
"onc true language" for all people and all applications. In faCl, all major systcms 
\\-'c can think of use morc than one language. 
22.2.8 Information sources 
Each individual languagc dcscription above has a reference list. TIlese are refer-
ences covering several languages: 
More language designer links/photos 
wvvw.angclfirc.comltx4/cus/pcoplc/. 
A few examples of languages 
http://dmoz.orgJComputcrs/ProgrammingJLanguages/. 
'lextbooks 
Scott, Michael L. Programming Language Pragmatic;. Morgan Kaufmann, 2000. 
ISBN 155860442 l. 
Sebesta, Robert W. eon«pt.s if Programming Languaga. Addison-Weslcy, 2003. 
ISBN 032 1193628. 
History books 
Bergin, T.]., and R. G. Gibson, eds. History o/"Programming ulJIgull{P - II. Addison-
Wesley. 1996. ISBN 020189502 l. 
Hailpcm, Brcm, and Barbara C. Ryder, cds. Procecdings of tJle 11Urd ACM SIG-
PLAN Conference on the HistOry of Programming Languagcs (HOPL-III). 
San Diego, CA, 2007. http://ponal.acm.orgJtoc.cfm?id=1238844. 
Lohr, Stevc. Go 70: rM Story of the Math Mqjors, Bridge Pln)'I!rS, BlgJilecrs, Chess Wn-
arm, Maueridr Scientist.s and lamoclast.s- rM Programmers Wllo Createtl "Ie Software 
Revolution. Basic Books, 2002. ISBN 9780465042265. 
Sammet, Jcan. Programming Lnnguages: History and Fwuuwumtau. Prentice-Hall, 
1969. ISBN 0137299885. 
Wcxelblat, Richard L., cd. History o/"Programmillg LallgJlageS. Academic Press, 1981. 
ISBN 0127450408. 

CHAPTER 22 REVIEW 
Review 
1. YVhat are some uses of history? 
2. \¥hat are some uses of a programming language? List examples. 
3. List some fundamental properties of programming languages that are ob-
jectively good. 
4. What do we mean by abstraction? By higher level of abstraction? 
5. \¥hat arc our four high.level ideals for code? 
6. List some potential advantages of high. level programming. 
7. What is reuse and what good might it do? 
8. YVhat is procedural programming? Give a concrete example. 
9. What is data abstraction? Give a concrete example. 
10. What is object·oriented programming? Give a concrete example. 
11. What is generic programming? Give a concrete example. 
12. What is multi-paradigm programming? Give a concrete example. 
13. YVhen was the first program run on a stored-program computer? 
14. \'Vhat work made David YVheeler noteworthy? 
15. What was the primary contribution of J ohn Backus's firsllanguage? 
16. What was the frrst language designed by Grace Murray Hopper? 
17. In which field of computer science did J ohn McCarthy primarily work? 
18. YVhat were Peter Naur's contributions to Algo160? 
19. What work made Edsger Dijkstra noteworthy? 
20. What languages did Niklaus Wirth design and implement? 
21. What languages did Anders Hejlsberg design? 
22. What was J ean Ichbiah's role in the Ada project? 
23. What style of progranuning did Simula pioneer? 
24. Where (outside Oslo) did Kristen Nygaard leach? 
25. What work made Ole:Johan Dailinoteworthy? 
26. Ken TIlompson was the main designer of which operating system? 
27. ""hat work made Doug Mcl1roy noteworthy? 
28. What is Brian Kernighan's most famous book? 
29. \¥here did Dennis Ritchie work? 
30. \VIlat work made Bjarne Stroustrup noteworthy? 
3 1. What languages did Alex Stepanov use trying to design the S1L? 
32. List ten languages not described in §22.2. 
33. Scheme is a dialect of which language? 
34. What are C++'s two most prominent ancestors? 
35. What docs the C in C++ stand for? 
36. Is Fortran an acronym? If so, what for? 
37. Is COBOL an acronym? If so, what for? 
38. Is Lisp an acronym? If so, what for? 
39. Is Pascal an acronym? If so, what for? 
40. Is Ada an acronym? If so, what for? 
41 . Which is the best programming language? 

810 
CHAPTER 22 • IDEALS AND HISTORY 
Terms 
In this chapter "Terms" are really languages, people, and organizations. 
Languages, 
Ada 
Algol 
BCPL 
C 
C++ 
COBOL 
Fortran 
Lisp 
Pascal 
Scheme 
Simula 
People: 
Charles Babbage 
John Backus 
Olc:Johan Dahl 
Edsgcr Dijkstra 
Anders Hejlsbcrg 
Grace Murray Hopper 
Jean lchbiah 
BI;an Kernighan 
John McCarthy 
Doug Mcllroy 
Peter Naur 
Kristen Nygaard 
Demus Ritchie 
Alex Stcpanov 
Bjame SLrOUSlrUP 
Ken Thompson 
David Wheeler 
NiklaliS Wirth 
Organizations: 
Bell Laboratories 
Borland 
Cambridge University (Eng-
land) 
ETH (Swiss Federal Technical 
University) 
IBM 
MIT 
Norwegian Computer Center 
Princeton University 
Stanford University 
Technical University of 
Copenhagen 
U.S. Deparnnent of Defense 
U.S. Navy 

CHAPTER 22 EXERCISES 
Exercises 
1. Define programming. 
2. Define programming langJl~. 
3. Go through the book and look at the chapter vignettes. Which ones were 
from computer scientists? Write one paragraph summarizing what each 
of those scientists contributed. 
4. Go through the book and look at the chapter vignettes. Which ones were 
nOt from computer scientists? Identify the country of origin and field of 
work of each. 
5. Write a "Hello, World!" program in each of the languages mentioned in 
this chapter. 
6. For each language memioned in this chapter, look at a popular textbook 
and see what is used as the frrst complete program. Write that program in 
all of the other languages. Warning: TIlis could easily be a tOO-program 
project. 
7. We have obviously "missed" many important languages. In particular, 
we essentially had to cut all developments after C++. Make a list of five 
modern languages that you think ought to be covered and write a page 
and a half - along the lines of the languages sections in this chapter - on 
three of those. 
B. Whal is C++ used for and why? Write a 10- to 20·page report. 
9. What is C used for and why? Write a 10- to 20-page report. 
10. Pick one language (not C or C++) and write a 10- to 20-page description 
of its origins, aims, and facilities. Give plenty of concrete examples. Who 
uses it and for what? 
11 . Who currently holds the Lucasian Chair in Cambridge? 
12. Of the language designers mentioned in this chapter, who has a degree in 
mathematics? "Vito does not? 
13. Of the language designers mentioned in lhis chapter, who has a Ph.D.? 
In which field? Who does not have a Ph.D.? 
14. Of the language designers mentioned in this chapter, who has received 
tlle Turing Award? What is that? Find the actual Turing Award citations 
for tlle winners mentioned here. 
15. Write a program tlm, given a file of (name,year) pairs, such as 
(Algoi,1960) and (C,1974), graphs the names on a timdi.ne. 
16. Modify the program from the previous exercise so that it reads a liIe of 
(name,year,(ancestors)) ntples, such as (Fonran,19S6,()), (Algoi,1960,(For-
trail)), and (C++,198S,(C,Simula)), and graphs tllem on a timeline with 
arrows from ancestors to descendants. Use tills program to draw improved 
versions of the diagrams in §22.2.2 and §22.2.7. 
811 

.,2 
CHAPTER 22 • IDEALS AND HISTORY 
Postscript 
Obviously, we have only scratched the surface of both the history of program-
ming languages and of the ideals that fuel the quest for better software. We COIl-
sider hisLOry and ideals sufficiently important to feel really bad about lila(, We 
hope LO have conveyed some of our excitement and some idea of the immensity of 
the quest for better software and better programming as it manifest itself though 
the design and implementation of programming languages. That said, please re-
member that programming - the development of quality software - is the funda-
mental and important topic; a programming language is just a tool for that. 

\ 1 . . ,.- 23 
Text Manipulation 
"Nothing is so obvious that it's obvious ... . 
The use of the word 'obvious' indicates 
the absence of a logical argument." 
- Errol Morris 
T
his chapter is mostly about extracting information from 
texl. We store lots of our knowledge as words in docu-
ments, such as books, email messages, or "printed" tables, just to 
later have to extract it into some form that is morc useful for 
compuwuon. Here, we review me standard library facilities most 
used in text processing: strings, iostreams, and maps. Tllen, we 
introduce regular expressions (rege)(s) as a way of expressing 
patterns in texl. rmally, we show how to use rCbrular expressions 
to fmd and cxu'act specific data elements, stich as ZIP codes 
(postal codes), from texl and to verify the [om lat of text flies. 
813 

814 
23.1 Text 
23.2 Strings 
23.3 VO streams 
23.4 Maps 
23.4.1 Implementation details 
23.5 A problem 
23.6 The idea of regular expressions 
23.7 Searching with regular expressions 
23.1 Text 
CHAPTER 23 • TEXT MANIP ULATI O N 
23.8 Regular expression syntax 
23.S.1 Characters and special 
characters 
23.8.2 Character classes 
23.S.3 Repeals 
23.8.4 Grouping 
23.S.S Alternation 
23.8.6 Character sets and ranges 
23.8.7 Regular elrpression errors 
23.9 Matching with regular expressions 
23.10 References 
We manipulate text essentially all the time. Our books arc full of text, much of 
what we see on our computer screens is text, and our source code is text. Our 
communication channels (of all sorts) overflow with words. Everything that is 
communicated between tvvO humans could be represented as text, but let's not go 
overboard. Images and sound are usually best represented as images and sound 
(i.e.,just bags of bits), but just about everything else is fair game for program text 
analysis and transfonnation. 
We have been using iostreams and strings since Chapter 3, so here, we'll just 
briefly review those libraries. Maps (§23.4) are particularly useful for text pro-
cessing, so we present an example of their use for email analysis. After this re-
view, this chapter is concerned with searching for pattel'lls in text using regular 
expressions (§23.3-10). 
23.2 Strings 
A Siring contains a sequence of characters and provides a few llseful operations, 
such as adding a character to a string, giving the length of the Siring, and COIl-
catenating strings. Actually, the standard string provides quite a few operations, 
but most are useful only when yOll have to do fairly complicated text manipula-
tion at a low level. Here, we just mention a few of the more useful. You can look 
up their details (and the full set of string operations) in a manual or expert-level 
textbook should you need them. TIley are found in <string> (note: not 
<slring.h» : 

23 .2 
STRINGS 
Selected string operations 
sl = s2 
S += X 
sfil 
sl+s2 
sl ==s2 
sl<s2 
s.sizeO 
s.lenglhO 
s.cstrO 
s.beginO 
s.end{) 
s.inserl(pos,x) 
s.append(pos,x) 
s.erase(pos) 
pos = sJind(x) 
in>>s 
gelline(in,s) 
out<<s 
Assign s2 to sl ; s2 can be a Siring or a (-style siring. 
Add x at end; x can be a character, a Siring. or a (-style string. 
Subscripting. 
Concatenalion; the characters in the resulting string will be a 
copy of those from sl followed by a copy of those from s2. 
Comparison of siring va lues; sl or s2, but not both, can be a C· 
style string. Also != . 
lexicographical comparison of string values; sl or s2, but not 
both, can be a (·style string. Also <=, >, and >=. 
Number of charaders in s. 
Number of characters in s. 
C-style version of characters in s. 
Iterator to first character. 
Iterator to one beyond the end of s. 
Insert x before sipos]; x can be a Charadef', a Siring. or a (·style 
string. s e>epands to make room for the charaders from x. 
Insert x after sipos); x can be a character, a string. or a (·style 
string. s e>epands to make room for the characters from x. 
Remove the character in sipos]. s's size decreases by 1. 
Find x in s; x can be a character, a Siring. or a ( ·style string; pos 
is the index of the first character found, or npos (a position off 
the end of s). 
Read a whitespace-separated word into s from in. 
Read a line into s from in. 
Write from S to out. 
TIle 110 operations arc explained in Chapters 10 and 11 and summarized in 
§23.3. Note that the input operations into a Siring expand the siring as needed , 
so that overOow cannot happen. 
The inserlO and appe ndO operations move characters to make room for 
new characters. 'Ille eraseO operation moves characters "fonvard" in the siring 
to make sure that no gap is left where we erased a character. 
815 

116 
CHAPTER 23 • TEXT MANIP ULATION 
The standard library string is really a template, called basic_string, that sup-
ports a variety of character sets, slich as Unicode, providing thousands of charac-
ters (such as [, n, 00, 0, Q, and ~~ in addition to "ordinary characters"). For 
example, if you have a type holding a Unicode character, slIch as Unicode, you 
can write 
TIle standard string, string, which we have been using, is simply the basic_siring 
of an ordinary char: 
typedef basic_string<char> string; 
/I string means basic_slring<char> 
\Ve do nOt cover Unicode dlaraclcrs or Unicode strings here, but if you need 
them you can look them lip, and YOll'lI find that they can be handled (by lhc lan-
guage. by siring, by ioslreams, and by regular expressions) much as ordinary 
charaClers and strings. If you need to usc Unicode characters, it is best to ask 
someone experienced for advice; to be useful, your code has to follow not just 
the language rules but also some system conventions. 
In the context of text processing, it is impoltam that JUSt about anything can 
be represented as a string of characters. For example, here on this page, the num· 
ber 12.333 is represented as a string of six characters (surrounded by whitespace). 
If we read this number, we mUSt convert those characters to a floating·point num· 
ber before we can do arithmetic operations on the number. Ths leads to a need 
to convert values to 51 rings and slrings to values. In §llA, we saw how to turn 
an integer into a siring using a slringslream. This technique can be generalized 
to any type that has a « operator: 
lemplale<class T> Siring to_string(const T& 1) 
{ 
} 
oslringstream as; 
05« I; 
return os.slrO; 
For example: 
string 51 = to_string(12.333); 
string 52 = to_string(1+So6-99m; 
The value of sl is now "12.333" and the value of s2 is "17". In fact , to_SlringO 
can be used not just for numeric values, but for allY class T with a « operator. 

23.2 
STRING S 
The opposile conversion, from slrings to numeric values, is about as easy, and as 
useful: 
struel bad_from_string : sld::bad_cast 
/I class for reporting sIring cast errors 
{ 
consl char· whalO consl 
II override bad_casl's whalO 
( 
relurn "bad casl from siring"; 
) 
); 
lemplale<class T> T from_slring{consl slring& s) 
( 
istringslream isIs); 
T I; 
if (!(is» I» Ihrow bad_from_slringO; 
relurn I; 
For example: 
double d = from_slring<double>("12.JJJ"); 
void do_somelhing(eonsl slring& s) 
"Y 
( 
inl i = from_slring<int>(s); 
II .. 
catch (bad_from_string e) { 
error ("bad input siring" ,5); 
) 
The added complication of from_slringO compared to lo_slringO comes because 
a Siring can represent values of many types. TIlls implies that we must say which 
type of value we want to extract from a siring. It also implies that the siring we 
are looking at may not hold a representation of a value of the type we expect. For 
example: 
int d = from_string<int>("Mary had a little lamb"); 
/I oops! 
817 

818 
CHAPTER 23 • TEXT MANI PULATION 
So mere is a possibility of error, which we have represented by the exception 
bad_fram_slring. In §23.9, we demonstrate how from_slringO (or an equivalent 
function) is essential for serious text processing because we need to extract nu-
meric values from text fields. In §16.4.3, we saw how an equivalent function 
gcUIlIO was used in G U I code. 
Note how to_slringO and rrom_stringO are similar in function. In fact, they 
arc rougWy inverses of each other; that is (ignoring details of whilcspace, round· 
ing, elc.), for every "reasonable type T" we have 
5==10 _stri n g(from _stri ng<1>(5)) 
II for all s 
and 
/I for all t 
Here, "reasonable" means that T should have a default constructor, a » operator, 
and a matching « operator defined. 
Note also how me im plementations of lo_slringO and from_stringO bOlh use 
a stringstream to do all the hard work. This observation has been used to define 
a general conversion operation between any two types with matching « and » 
operations: 
slrucl badJexical_casl : sid: :bad_casl 
{ 
consl char· whatO consl ( return "bad cast"; } 
}; 
template<typename Target. type name Source> 
Target lexical_cast{Source arg) 
{ 
) 
sid : :slringslream inte rpreter; 
Target result; 
if (!(inte rpreter « arg) 
II ! (inte rprete r » result) 
[I !(inte rprete r » sid: :ws).eofOl 
throw bad_lexical_castO; 
return result; 
II read arg into stream 
/I read result from stream 
II stuff left in stream? 
The curious and clever !(inle rpreler»std :: ws).eoro reads any whitespace that 
might be left in me stringstream after we have extracted the result. \<Vhitespace is 
allowed, but there should be no more characters in the input and we can check 

2) .) 
1/0 STREAMS 
that by seeing if we arc at "end of file." So if we arc trying to read an int from a 
string using lexical_cast, "123" and "123 " will succeed, but "123 5" will not be-
cause of that last 5. 
"nlis rather elegant, though oddly named, lexicaCcast is provided by the 
boost library, which we will usc for regular expression matching in §23.6-9. It 
will also be pan of future versions of the C++ standard. 
23.3 1/0 streams 
Considering the connection between strings and alher types, we get to 110 
st.reams. 111e 110 stream library doesn't just do input and output; it also per· 
forms conversions betwecn string formats and types in memOly. The standard li-
brary 110 streams provide facilities for reading, writing, and formatting strings of 
characters. TI1C iostream library is deso·ibed in Chapters lO and II , so here we'll 
JUSt summarize: 
Stream VO 
in »x 
out «x 
in.get(c) 
getline(in,s) 
Read from in into x according to x's type. 
Write x to out according to x's type. 
Read a charJcter from in into c. 
Read a line from in into the string s. 
11le standard streams arc organized into a class hierarchy (§ 14.3): 
istream 
ostream 
istrin tream 
ifstream 
iostream 
ostrin stream 
of stream 
strin stream 
fstream 
Together, these classes supply us with the ability to do 110 to and from files and 
strings (and anything that can be made to look like a ftle or a string, such as a 
keyboard and a screen; sec Chapter lO). As described in C hapters 10 and 11, the 
iostreams provide fairly elaborate formatting facilities. TIle arrows indicate inher-
itance (see §I4.3), so that, for example, a stringstream can be used as an iostream 
or as an istream or as an ostream. 
Like string, ioslreams can be used with larger character sets such as Uni-
code, much like ordinary characters. Please again note that if YOll need to usc 
Unicode I/O, it is best to ask someone experienced for advice; to be useful, your 
code has to follow not just the language rules but also some system conventions. 
819 

8W 
( H APTER 23 • TEXT MANIPU LATION 
23.4 Maps 
Associative arrays (maps, hash tables) are key (pun imended) to a lot of text pro-
cessing. The reason is simply that when we process text, we collect information, 
and that information is often associated with text strings, such as names, ad· 
dresses, postal codes, SociaJ Security numbers, job titles, etc. Even if some of 
those text strings could be converted into numeric values, it is of len morc con-
venient and simpler to treat them as text and lise lhat text for identification. "nlC 
word-counting example (§2L6) is a good simple example. If you don't feel com-
fortable using maps, please reread §21.6 before proceeding. 
Consider email. We of len search and analyze email messages and cmaillogs 
-
usually with the help of some program (e.g., TIlUndcrbird or Omlook). 
Mostly, those programs save us from seeing the complete sourcc of the messages, 
hut all the infonnation abom who sent, who received, where the message wCnt 
along the way, and much more is presented to the progra.ms as text in a message 
header. 111at's a complete message. TIlere arc thousands of tools for analp.ing 
the headers. Most lise regular expressions (as described in §23.5- 9) to extract in-
fonnation and some fonn of associative arrays to associate related messages. For 
example, we often search a mail file to collect all messages with the same sendcr, 
thc same subject, or containing infonllation on a particular topic. 
Here, we will use a very simplified mail file to illustratc some of the tedl-
niqucs for extracting dam from text mes. TIle headers arc real RFC2822 headers 
from wv-/w.faqs.orglrfcslrfc2822.hulll. Consider: 
From: John Doe <jdoe@machine.exampJe> 
To : Mary Smith <mary@exampJe.nel> 
Subject: Saying Hello 
Date: Fri, 21 Nov 1997 09:55 :06 - 0600 
Message-ID : <1234@loeal.machine.example> 
This is a message just to say hello. 
So, "Hello". 
From: Joe Q. Public <john.q.public@example.com> 
To: Mary Smith <@machine.tld :mary@example.nel>"jdoe@test .example 
Date: Tue, 1 Jul2oo3 10:52:37 +0200 
Message-ID: <5678.21- Nov-1997@example,com> 
Hi everyone. 

23.4 
MAPS 
To: "Mary Smith : Personal Account" <smith@home.example> 
From : John Doe <jdoe@maehine.example> 
Subject: Re: Saying Hello 
Date: Fri, 21 Nov 1997 11 :00:00 - 0600 
Message-ID: <abed.1234@loeal.maehine.lld> 
In- Reply-To: <3456@example.net> 
Refe re nees: <1234®loeal. maehi n e. exam pic> <.l456@cxamplc.net> 
This is a reply to your reply. 
Basically, we have abbreviated the me by throwing most of the infonnation away 
and cased the analysis by terminating each message by a line containing just ----
(four dashes). Vi'e will write a small "toy application" that finds all messages sent 
by ''john Doc" and write alit their "Subjeel." If we can do that, we can do many 
interesting things. 
First, we mllst consider whether we want random access to the data or JUSt to 
analyze it as it streams by in an input stream. \,ye choose the fomler because in a 
real program, we would probably be interested in several senders or in several 
pieces of infonnation fmm a given sender. AJso, it's actually the harder of the two 
tasks, so it will allow us to examine more techniques. In particular, we get to use 
iterators again. 
Our basic idea is to read a complete mail file into a structure (which we call a 
Mail_file). 'n lis stnlctllre will hold all the lines of the mail me (in a 
veelor<string» and indicators of where each individual message starts and ends 
(in a vector<Message» : 
Mail file: 
vedor<Message> 
.. . 
\ 
1----
I 
\ 
..ctoK>trlng> 
l---drom'JOhn Doe 
I 
...iTo, Mary Smith 
I 
Subject: Saying Hello J 
I,--=:=L:tc ... 
I 
J 
. . . 
821 

822 
CHAPTER 23 • TEXT MANIPU LATION 
To this, we will add itcrators and beginO and end() functions, so that we can iter-
ate through the lines and through t.he messages in the usual way. "111is "boiler-
plate" will allow liS conveniem access to the messages. Given that, we will write 
our "toy application" to gather all the messages from each sender so thallhcy are 
easy to access together: 
muhimap<String,Message·> 
j ohn Doe" 
john Doe" 
"John O. Pubtic" 
Mail file: 
vector<Message> 
Finally, we will write out all the subject headers of messages from "John Doc" to 
illustrate a usc of the access structures we have created. 
We usc many of the basic standard library facilities: 
#include<string> 
#indude<vector> 
#include<map> 
#indude<fslream> 
#include<ioslream> 
using names pace Sid; 
We define a Message as a pair of iterators into a vector<string> (our vector of lines): 
typedef vector<string>: :consCiterator Line_iter; 

23.4 
MAPS 
class Message ( /I a Message points to the first and the last lines of a message 
line_iter first; 
Line_iter last; 
public: 
} ; 
Message(Line_iler pl , line_iler p2) :firs((pl ), lasl(p2) { } 
line_iter beginO const ( return first; } 
linej ler en dO const { return last; } 
1/ . . . 
We define a MaiU ile as a structure holding lines or text and messages: 
typedef vector<Message>: :consUterator Mess_iter; 
shuct MaiUile ( 
/I a Mail_file holds all the lines from a file 
}; 
/I and simplifies access to messages 
/I file name 
string name; 
vector<string> lines; 
vector<Message> m; 
/I the lines in order 
II Messages in order 
MaiUile(const string& n); /I read file n into lines 
Mess_iter beginO const { return m.beginOi } 
Messj ter endO const { return m.endOi } 
Note how we added itcrators to the data structures to make it easy to systemati· 
cally traverse them. We arc not actually going to usc standard library algorithms 
here, but ir we wanted 1'0, the iterators arc there to allow it. 
To find infomtation in a message and extract it, we need two helper runctions: 
/I find the name of the sender in a Message; 
/I return true if found 
/I iffound, place the sender's name in s: 
bool find_from_addr(const Message· m, slring& s); 
/I return the subject of the Message. if any. othc .... vise • ": 
Siring find_subjecl(conSI Message m); 
Finally, we can write some code to extract inrom13tion rrom a file: 
823 

824 
CHAPTER 23 • TEXT MANIPULATION 
int mainO 
( 
) 
Mail_file mfile(lImy-mail-file.txt"); 
II initialize mfile from a file 
/I first gather messages from each sender together in a muhimap: 
mullimap<Slring, const Message·> sender; 
for (M ess_iter p = mfile.begin(); pl=mfile.end(); ++p) ( 
const Message& m = · Pi 
string S; 
if (find_fro m_addr(&m,$» 
sender. i n sert(make_pair(s,&m» ; 
) 
/I now iterate through the multi map 
/I and extract the subjects of John Doe's messages: 
typedef multimap<string, const Message->: :consUteralor M e l; 
pair<MCI,MCI> pp = sender.equal_,ange("John Doe"); 
for(MCI p = pp.firsl ; p!=pp.second; ++p) 
cout « find_subjeCl(p->secondl« '\n'; 
Let LIS examine the usc of maps in detail. We used a multimap (§20.10, §B.4) be-
cause we wanted to gather many messages from the same address together in one 
place. The standard library multimap docs that (makes it easy to aceess clements 
with the same key). Obviollsly (and typically), we have 1"\\"0 parts to our task: 
Build lhe map. 
Use the map. 
We build the multi map by traversing all the messages and inserting them into the 
multimap using insertO: 
for (Messjter p = mfile.beginO; p! =mfile.endO; ++p) ( 
const Message& m = . p; 
) 
string s; 
if Ifind_from_addr(&m,s)) 
sender.inserl(make_pair(s,&m»; 

2) ,4 
MAPS 
What goes into a map is a (key, value) pair, whidl wc make with make_pairO_ We 
use our '·homemade" find_from_addrO to find the name of thc sender. We use 
the empty string to indicate that an address wasn't found. 
Why do we introduce the refercnce m and pass its addrcss? Why don't we 
just usc p dircctly and say find_from_addr(p,s)? Because evcn though we k.now 
that Messj ler refers to a Message, there is no guarantee that it is implemented as 
a pointer. 
Why did we first put the Messages in a veclor and then later build a 
mullimap? 'Why didn't we just put the Messages into a map immediately? The 
reason is simple and fundamental: 
First, we build a generaJ structure that we can use for many things. 
111en, we usc that for a particular application. 
'n1at way, we build up a coUection of more or less reusable components. Had we 
inUl1ediatcly built a map in the Mail_file, we would have had to redefine it when-
ever we wanted to do some different task. In particular, our mullimap (significantly 
called senders) is sorted based on the Address field of a message. Most other appli-
cations would not find that order particularly useful: they might be looking at Re-
turn fields, Recipients, Copy-to fields, Subject fields, time stamps, etc. 
TIlis way of building applications in stages (or ta)'ers, as the parts are some-
times called) can dramaticaJly simplify the design, implementation, documenta-
tion, and maintenance of programs. TIle point is that each part docs only one 
thing and does it in a straightforward ' \faY. On the other hand, doing everything 
at once would require cleverness. Obviously, our "extracting information from 
an email header" program was just a tiny example of an application. The value of 
keeping separate things separate, modularization, and gradually building an ap· 
plication increases with size_ 
To extract infonllation, we simply find all the entries with the key "John 
Doe" using the equal_rangeO function (§B.4.1O). TIlcn we iterate through all the 
clemems in the sequence [first,second) returned by equal_,angeO, extracting the 
subject by using find_subjectO: 
typedef multimap<string, const Message>: :consUterator MCI; 
pair<MCI,MCI> pp = sender.equal_range("John Doe")i 
for (MCI p = pp.firsli pl=pp.second; ++p) 
cout « find_subject(p->second) « '\n'; 
When we iterate over the elemcnts of a map, we get a sequence of (key,value) 
pairs, and as with all pairs, the frrst clement (here, the string key) is called firsl 
and the second (here, the Message value) is called second (§21.6). 
825 

826 
CHAPTER 23 • TEXT MANIPU LATION 
23.4.1 Implementation details 
Obviously, we need to implement the functions we usc. It was tempting to save a 
tree by leaving this as an exercise, bUl we decided to make this example complete. 
The MaiLfile constructor opens the flle and constructs the lines and III vectors: 
MaiUile:: MaiUile(const string& n) 
/I open fi Ie named On" 
{ 
) 
II read the lines (rom "n" into "lines· 
II find the messages in the lines and compose them in m 
1/ for simplicity assume every message is ended by a ,,----" line 
ifslteam in(n .c_slrO); 
if (!jn){ 
II open the fi Ie 
cerr« "no "« n« '\n'; 
exit(1)j 
II terminate the program 
string Sj 
while (gelline(in,s» lines.push_back(s)j 
II build the vector of lines 
Linejter first = lines.beginO; 
/I build the vector of Messages 
for (Linej ter p = lines.beginO; p!=lines.endO; ++p) { 
if (.p == "----") { 
II end of message 
m. p ush_back(Message(first, p»; 
first = p+1; 
11---- nol pari of message 
) 
) 
The error handling is rudimentary. If this were a program we planned LO give to 
friends LO use, we'd have to do belter. 
TRY THIS 
What would be "better error handling"? Modify Mail_file's constructor to 
handle likely fonnatting errors related to the use of" ----". 
The find3 rorn_addrO and find_subjectO functions are simple placeholders until 
we can do a bener job of identifying information in a file (using regular exprcs· 
sions §23.6-1O): 

2 3.4 
MAPS 
int is_prefix(const string& s, canst string& p) 
/I is p the first part of s? 
) 
int n = p.size(); 
if (string(s,O,n)==p) return n; 
return 0; 
bool find_from_addr(const Message' m, string& s) 
{ 
) 
for(linejter p = m->begin(); p!=m->endO; ++p) 
if (int n = is_prefix(Op, "From: "» { 
s = string("p,n); 
return true; 
) 
return false; 
string find_subject{const Message& m) 
{ 
) 
for{line_iter p = m.begin(); p! =m.end(); Hp) 
if (int n = is_prefix(' p, "Subject: "» return string("p,n); 
return ""; 
Note the way we use substrings: string(s,n) constmcts a string consisting of the 
tail of s from s[n] onward (s[n] .. s[s.size()-l J), whereas string(s,O,n) constmcts a 
string consisting of the characters s[OJ .. s{n- 1J. Since thcse operations actually 
constmct new strings and copy dlaracters, they should be used with care where 
pcrfom13llce matters. 
Why are the find_from_addrO and find_subjeclO functions so different? For 
example, one relUms a bool and the other a siring. They are different because 
we wanted to make a }Xlint: 
find_frorn_addrO distinguishes between finding an address line with an 
empty address (" ") and finding no address line. In the first case, 
find_frorn_addrO rerums (rue (because it found an address) and sets s to 
'''' (because the address just happens to be empty). In the second case, it 
rerums false (because there was no address line). 
find_subjectO returns "" if there was an empty subject or if there was no 
subject line. 
827 

828 
(HAPTER 23 • TEXT MANIPU LATION 
Is the distinction made by find_irom_addrO useful? Nccessaly? We think lhallhc 
distinction can be usefu l and lhat we definitely should be aware of it. It is a dis-
tinction that comes up again and again when looking for information in a data 
fLle: did we find the field we were looking for and was there something llseful in 
it? In a real program, bOlh the find_from_addrO and find_subjeclO functions 
would have been wriucn in the style of find_from_3ddrO to allow users to make 
that distinClion. 
This program is nOt tuned for pcrfonnance, but it is probably fast enough for 
most uses. In particular, it reads iLS input fLle only once, and it docs not keep mul-
tiple copies of the tcxt from that file. For large files, it may be a good idea LO re-
place the mullimap with an unordered_multimap, but unless you measure, you'll 
never know. 
See §21.6 for an introduction to the standard library associative containers 
(map, multimap, set, unordered_map. and unordered_multimap). 
23.5 A problem 
110 streams and string help us read and write sequences of characters, help us 
store them, and help with basic manipulation. However, it is very common to do 
operations on text where we need to consider the cOlllext of a string or involve 
many similar strings. Consider a trivial example. Take an email message (a se-
quence of words) and see if it cOlllains a U.S. state abbreviation and Z IP codc 
(twO lcttcrs followed by five digits): 
string Sj 
while (cin»s) ( 
if (s.sizeO==7 
&& isalpha(sIO)) && isalpha(sll]) 
&& isdigil(sI2]) && isdigit(sI3J) && isdigit(s[4]) 
&& isdigil(sI5)) && isdigit(s[6J» 
coul « "found "« s« '\fl'; 
Hcre, isleller(x) is true if x is a leite r and isdigil(x) is true if x is a digit (sec §ll.6). 
TI1cre arc sevcral problems with this simplc (tOO simple) solution: 
It's verbose (four lincs, eight function c.'llls) . 
We miss (intentionaHy?) evcry ZIP code number not separatcd from itS 
COntcxt by whitespace (SUd1 as "TX77845", TX77845-1234, and ATX77845). 
We miss (intentionally?) every ZIP codc number with a spacc bctwcen 
thc letters and the digitS (such as TX 77845). 

23 .5 
A PROBLEM 
We accept (intentionally?) every ZIP code number with the lellers in 
lower case (such as tx77845). 
If we decided to look for a postal code in a different format (such as C8l 
OFD), we have to completely rewrite the code. 
TIlere has to be a better way! Before revealing that way, let's juSt consider the 
problems we would encoulller if we decided to stay with the "good old simple 
way" of writing more code to handle more cases. 
If we want to deal with more than one format, we'd have to start adding 
if-statements or switch-statements. 
If we want to deal with upper and lower case, we'd explicitly have to 
convert (usually to lower case) or add yet another if-statement. 
"Ve need to somehow (how?) describe the context of what we want to 
find. TIlat implies t.hat we must deal with individual characters rather 
than with strings, and that implies that we lose many of the advantages 
provided by ioslreams (§7.8.2). 
If you like, you can try to write the code for that, but it is obvious that on this 
track we are headed for a mess of if-statements dealing with a mess of special 
cases. Even for this simple example, we need to deal with alteOlatives (e.g., both 
five· and nine-digit ZIP codes). For Illany other examples, we need to deal with 
repetition (e.g., any number of digits followed by an exclamation mark, such as 
123! and 123456!). Eventually, we would also have to deal with both preflXcs and 
suflixes. As we observed (§11.l- 2), people's tastes in Output fortnats arc not lim-
ited by a progranuner's desire for regularity and simplicity. Just think of the be-
wildering variety of ways people write dates: 
2007-06-05 
June 5, 2007 
jun 5, 2007 
12 June 2007 
61.512007 
516107 
At this point - if not eal·lier - the experienced progra.nuner declares, "TIl ere has 
to be a better way!" (Ulall writing more ordinary code) alld proceeds to look for 
it. ~nle simplest and most popular solution is using what arc called regular ex/ms-
Slims. Regular expressions are ule backbone of much text processing, ule basis for 
the Unix grep conunand (see exercise 8), and an essential part of lallguages heav-
ily lIsed for such processing (such as AWK, PERL, and PHP). 
8'" 

83. 
(HAPTER 2 3 • TEXT MANIPU LAT ION 
The regular expressions we will usc arc implemented by a library that will be 
pan of the next C++ standard (C++Ox). It is compatible with the regular expres-
sions in PERL. lbis makes many explanations, tutorials, and manuals available. 
ror example, see the C++ standard COI11l1uttee's working paper {look for "WG21 " 
on the web),J olm Maddoc's boosl: :regex documentation, and most PERL tutori-
als. Here, we will describe the fundamental concepts and some of the most basic 
and useful ways of using regular expressions. 
TRY THIS 
The last two paragraphs "carelessly" used several names and acronyms with-
out explanation. Do a bit of web browsing to see what we are referring to. 
23.6 The idea of regular expressions 
111c basic idea of a regular expression is that it defines a pallem that we can look 
for in a text. Consider how we might concisely describe the pattern for a simple 
ZIP code, such as TX77845. Here is a first attempt: 
wwddddd 
Here, w represents "any letter" and d represents "any digit." We usc w (for 
"word") because I (for "letter") is too easily confused with the digit I. "Tllis nota-
tion works for this simple example, but let's try it for the nine-digit ZIP code for-
mat (such as TX77845-5629). How about: 
wwddddd-dddd 
lllatiooks OK, but how come that d means "any digit" bUl - means "plain" dash? 
Somehow, we ought to indicate that w and d are special: they represent character 
classes rather than themselves (w means "an a or a b or a c or ... " and d means "a 
1 or a 2 or a 3 or . . . "). That's too subtle. Let's prefix a letter that is a name of a class 
of characters with a backslash in the way spcciaJ characters have always been indi-
cated in C++ (e.g., \n is newline in a string literal). This way we get 
\w\w\d\d\d\d\d-\d\d\d\d 
This is a bit ugly, but at least it is unambiguous, and the backslashes make it obvi-
ous that "sometlling unusual is going on." Here, we represent repetition of a char-

23.6 
THE IDE A OF REGULAR EXPRE SS IONS 
acter by simply repeating. That can be a bit tedious and is potentially error-prone. 
Qtick: Did we really gel the five digits before the dash and four after it right? We 
did, but nowhere did we actually Jl!)' S and 4, SO you had to count to make sure. 
We could add a COLInt after a character to indicate repetition. For example: 
\w2\dS-\d4 
However, we really ought to have some syntax to show that the 2, S, and 4 in that 
paltem are counts, rather than juSt the alphanumeric characters 2, S, and 4. Let'S 
indicate counts by putting them in curly braces: 
\w{2)1d{5)-Id{4) 
That makes ( special in the same way as \ (backslash) is special, but that can't be 
helped and we can deal with thal. 
So far, so good, but we have to deal with twO more messy details: the final 
four digits in a ZIP code are optional. We somehow have to be able to say that 
we will accept both TX7784S and TX7784S- 5629. 111ere are two fundanlental ways 
of expressing that: 
\w(2)\d(S} or \w (2}\d(S}-\d(4} 
and 
\w (2)\d(S} and optionally -\d(4} 
To say that concisely and precisely, we first have LO express the idea of grouping 
(or sub-pattern) to be able to speak about the \w (2}\d(S} and -\d(4} pans of 
\w(2}\d(S}-\d{4}. Conventionally, we use parentheses to express grouping: 
~w {2)1d {5» ){ - Id (4)) 
Now we have split the pattern into two sub-patterns, so we just have to say 
what we want to do with them. As usual, the cost of introducing a new facility is 
lO introduce another special character: ( is now "special" just like \ and (. Con-
ventionally I is used to express "or" (alternatives) and 1 is used to express some-
thing conditional (optional), so we might write: 
~w {2 )1d{5»I ~w {2)1d{5) -Id {4 » 
and 
831 

832 
CHAPTER 23 • TEXT MANIP ULATION 
~w{2}\d {S}}{ - \d{'}} I 
As with the curly braces in the count notation (e.g., \w(2l), we lise lhc question 
mark (1) as a suffiX. For example, (-\d{4})1 means "optionally -\d{4}"; that is, we 
accept four digits preceded by a dash as a sumx. Actually, we arc not using the 
parentheses around the pattern for the five-digit ZIP code (\w{2)\d{5}) for any-
thing, so we could leave them out: 
Iw{2} \d{S}{ - \d{'}} I 
To complete our solUlion to the problem stated in §23.5, we could add an op-
tional space after lhe twO letters: 
Iw{2} lId{S}{-\d{4}}l 
That " 1" looks a bit odd, blll of course it's a space character followed by the ?, 
indicating that the space character is optional If we wanted to avoid a space 
being so unobtrusive that it looks like a bug, we could put it in parentheses: 
Iw{2}{ }lId{S}{{- \d{4}}l 
If someone considered that still too obscure, we could invent a notation for a 
whitcspace character, such as \5 (s for "space"). That way we could write 
Iw{2}l s 1\d{S} (-\d{' )} I 
But what if someone wrote (wo spaccs after the letters? As defined so far, the pat-
tem would accept TX77845 and TX 77845 but not TX 77845. lllat's a bit subtlc. 
We need to be able LO say "'zero or marc whites pace dmraclers," so we introduce 
t.he sufflX • to mean "'zero or more" and get 
Iw{2}1s '\d{S){ - \d{ 4}} I 
This makes sense if you followed every step of the logical progression. This nOla-
tion for patterns is logical and extremely terse. Also, we didn't pick our design 
choices at random: this particular notation is extremely common and popular. 
tor many text-processing tasks, you need to read and write this notation. Yes, it 
looks a bit as if a ca.t walked over the keyboard, and yes, typing a single character 
wrong (even a space) completely changes the meaning, but please JUSt get used to 
it. We can't suggest anything dramatically heller, and this style of notation has al-
ready been wildly popular for more than 30 years since it was first introduced for 
the Unix grep command - and it wasn't completely new even then. 

23.7 
SEA RCHI NG WITH RE GU LAR EXPR ESS IONS 
23.7 Searching with regular expressions 
Now, we will use the ZIP code pattern from the previous section to find ZIP 
codes in a me. The program defines the pattern and then reads a me line by line, 
searching for the pattern. If the program finds an occurrence of the pattern in a 
line, it writes out the line number and what it found: 
#indude <boost/regex.hpp> 
#ind ude <iostream> 
#indude <siring> 
#indude <fstream> 
using namespace std; 
int mainO 
{ 
ifstream in("file. txt"); 
1/ input file 
if (! in) cerr « "no file\n"; 
boost:: regex pat ("\\w{2}\\s ·\\d{5}(- \\d{4))'f"); 
cout «"pattern : " « pat « '\n'; 
int lineno = 0; 
Siring line; 
/I inpul buffer 
while (getline(in,line)) { 
++Iineno; 
II ZIP code pauern 
boost: :smalch matches; 
/I matched strings go here 
if (boost:: regex_search(line, matches, pal) 
cout « lineno« ": " «
matches(OJ« '\n'; 
} 
l1us requires a bit of a detailed explanation. First consider: 
#include <boostlregex.hpp> 
boost: : regex pat ("\\w{2}\\s*\\d{5}(-\\d(4))'f"); II ZIP code pauern 
boost: :smatch matches; 
/I matched strings go here 
if (boost:: regex_search(1ine, matches, pat») 
We are using the boost implementation of the regex library that will soon be part 
of the standard library. 1b lise that library, you may have to install it. To indicate 
which facilities arc from the regex library, we use explicit qualifications with the 
library's namespace boost, e.g., boost:: regex. 
.33 

834 
C HAPTER 2] • TEXT M AN IPULATION 
Back to regular expressions! Consider: 
boost: :regex pat ("\\w{2}\\s-'\d{5}(- \\d{4})1"); 
coul « "pattern : "« pat « '\n'i 
Here we first define a patlern, pat (of type regex), and then write it to outpul. 
Note that we wrote 
"\\w{2}1" ' lid {5}{ - IId{ 4} I'" 
If you run the program, you'll sec the output: 
pattern : \w {2}\s-\d{S}(-\d{4})f 
In C++ string literals, backslash is the escape character (§A.2.4), so to gel a (sin-
gle) \ into a literal string we have to write \\. 
A regcx pattern really is a kind of string, so we can output it using « . A 
regex is notj llJl a siring, but the somewhat sophisticated mechanism for pattern 
matching lhat is created when you initialize a regex (or assign to one) is hidden 
and beyond the scope of this book. However, once we have initialized a regex 
with our pattern for ZIP codes, we can apply it to each line of our file: 
boost: :smatch matches; 
if (boost: :regex_search(line, matches, pat» 
cout « lineno « ": " «
matcheslO] « '\n'; 
111e regex_search(line, matches, pat) searches the line for anything that matdles 
the regular expression stored in pat, and if it finds any matches, it stores them in 
matches. Naturally, if no match was found, regex_search(line, matches, pat) re-
~urns false. 
The matches variable is of type smatch. The s stands for O;sub." Basically, an 
smatch is a vector of sub-matches. The first clement, here matches[OJ, is the com· 
plete match. We can treat matches[iJ as a string if i<matches.sizeO. So if - for a 
given regular expression - the maximum number of sub-patlcms is N, we find 
matches.size()==N+1. 
So, what is a sub-pattem? A good first answer is, "Anything in parentheses in 
the pattern." Looking at "\\w{2}\\s·\\d{5}(- \\d{4})?", ,\-"e see the parentheses 
around the four-digit extension of the ZIP code. 111at's the only sub-pattern we 
sec, so we guess (correctly) that matches_size()==2. We also guess that we can 
easily access those last four digits. For exanlple: 
while (getiine(in,line» { 
boost: :smatch matches; 

23.7 
SE AR CHI NG W ITH REG ULAR EXPRESSIONS 
) 
if (boost: :rcge,,-search(line, matches, pat)) { 
cout « lineno « ": " « matches[O]« '\n'; 
if (1<malches.sizeO && malches[l ].malched) 
cout «"\I: "« malches[l ]« '\n'; 
) 
II whole match 
II sub-match 
Strictly speaking, we didn't have to test l<malchcs.size() because we already had 
a g<XKIlook at the pauem, but we fclt like being paranoid (because we have been 
experimenting with a variety of patterns in pat and they didn't all have just one 
sub· pattern) . We can ask if a sub· match succeeded by looking at its matched memo 
ber, here matches[l J.malched. In case you wonder: when matches[ij.malched is 
false, the unmatched sub-pattern malches[i] prints as the empty string. Similarly, a 
sub·pattern tllal doesn't exist, such as malches(17] for the pattern above, is treated 
as an umnatdled sub-pattern. 
We tried this program with a fIle containing 
address TX77845 
fHf Ix 77843 asasasaa 
ggg TX3456-23456 
howdy 
zzz TX23456-3456sss ggg TX33456-1234 
cvzcv TX77845- 1234 sdsas 
xuTx77845xu 
TXl234~l23456 
and got the output 
pattern : "\w(2}\s-\d{5)(-\d(4} )1" 
1 : TX77845 
2: Ix 77843 
5: TX23456-3456 
: -3456 
6: TX7784~l234 
: - 1234 
7: rx77845 
8: TXl234~ l234 
: - 1234 
Note that we 
Did nm get fooled by the ill-formatted "ZIP code" on the linc with ggg 
(what's wrong witll that one?) 
835 

83. 
( HAPTER 23 • TEXT MANIP U LATION 
Only found the first ZI P code from the line with zzz (we only asked for 
one per line) 
Found the correct suffIxes on lines 5 and 6 
Found the ZIP code "hidden" among lhe xxx's on line 7 
Found (unfortunately?) the ZIP code "hidden" in TX12345-123456 
23.8 Regular expression syntax 
'ATe have seen a rather basic example of regular expression matching. Now is the 
time to consider regular expressions (in the foml they are used in the regex li-
brary) a bit morc systematically and completely. 
R~guklr (xprwifJIu ("regcxps" or "rcgcxs") is basically a liule language for ex-
pressing patterns of characters. It is a powerful (expressive) and terse language, 
and as slich it can be quite cryptic. After decades of usc, there arc many subtle 
features and several dialects. Here, we will just describe a Oarge and useful) sub· 
set of what appears to be the currently most widely used dialect (tile PERL one). 
Should you need more to express what you need to sayar to understand the reg· 
ular expressions of Olhcrs, go look on the web. Tutorials (of wildly dilTering qual· 
ity) and specifications abound. In particular, the boosl: : regell: specification and 
its standard colluruuee equivalent (in WG21 TRI ) are easily found . 
The library also supports the ECMAscript, POSIX, awk, grep, and egrep 
nOlations and a host of search options. l1lis can be extremely useful, especially if 
you need to match some patlern specified in another language. You can look up 
those options if you fecllhe need to go beyond the basic facilities described here. 
However, remember that "using the most features" is not an aim of good pro· 
gramming. Whenever you can, take pity on the poor maintenance programmer 
(maybe yourself in a couple of months) who has to read and understand your 
code: write code mal is not unnecessarily clever and avoid obscure features 
whenever you can. 
23.8.1 Characters and special characters 
A regular expression specifics a pattern that can be used to match characters 
from a string. By default, a character in a pattern matches itself in a string. For ex· 
ample, the regular expression (pattern) "abc" will match the abc in Is Ihere an 
abc here? 
The real power of regular expressions comes from "'special characters" and 
character combinations that have special meanings in a paltern: 

23.8 
":ECUlAR EXPR ESSIO N SYNTAX 
Characters wilh special meaning 
any single character (a ~ wildcard") 
[ 
character class 
{ 
count 
I 
• 
+ 
I 
s 
begin grouping 
end grouping 
next character has a special meaning 
zero or more 
one or more 
optional (zero or one) 
alternative (or) 
start of line; negation 
end of line 
For example, 
'.y 
matches any three-letter string starting with an x and ending with a y, such as 
ny, x3y, and xay, but not yxy, 3xy, and xy. 
Note that ( .. . ), . , +, and 1 arc suffix operators. For example, \d+ means 
"one or more decimal digits." 
If you want to lise one of the special charactcrs in a pattern, you have to "cs-
cape it" using backslash; for example, in a pattern + is thc onc-or-morc operator, 
but \+ is a plus sign. 
23.8.2 Character classes 
11le most common combinations of characters are representcd in a terse foml as 
"special charactcrs"': 
Special characters for charader classes 
\d 
a decimal digit 
U:digil:lJ 
• 
a lowercase character 
[( :lower:1l 
" 
a space (sp.1ce, tab, etc.) 
(( :space:1J 
I" 
an uppercase character 
([ :upper:JJ 
Iw 
a leiter (a- z or A- ZJ or digit (0-9) or an underscore U 
([:alnum:JJ 
837 

838 
CHAPTE R 23 • TE XT MAN IPULATION 
Special characters for character classes (continued ) 
II) 
It 
IS 
\U 
\W 
not \d 
flO! \ 1 
not \5 
not \ u 
not \w 
I"[:digil :)) 
("{:Iower:)] 
' ''[ :space:1I 
I"[: upper:]] 
["[:alnum:lJ 
Note lhm an uppercase special character means "not the lowercase version of that 
special character," In particular, \W means "not a leuer" rather than "an upper-
c..1SC leuer," 
"m e entries in the third column (e.g., U:digit:JJ) give an ahcmativc syntax 
using a longer name. 
Like the string and iostream libraries, the rege)( library can handle large 
character selS, sllch as Unicode. As with Siring and iostream, we just mention 
lhis so liml yOll can look for help and morc infonnation should you need it. Deal-
ing with Unicode text manipulation is beyond the scope of this book. 
23.8.3 Repeals 
Repeating patlcm s arc specified by the suffIX opermors: 
Repetition 
t n ) 
( n, ) 
(n,m) 
eXilctly n times 
n or more times 
at least n and at most m times 
zero or more, that is, to,} 
+ 
one or more, thai is, {1,} 
? 
option.ll (zero or one), that is, (O,1) 
For example, 
A,' 
matches a ll A followed by zero or more X5, such as 

2 3.8 
REGU LAR EXPRE SS ION SYNTAX 
Au 
Axxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
If you want at least onc occulTence, usc + rather than · . For example, 
malches an A followed by one or mon: xs, such as 
A, 
Au 
Axxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
but not 
A 
The common case of zero or one occurrcnce ("optionan IS represented by a 
question mark. For example, 
Id- l\d 
matches the two digits with an optional dash between them, such as 
1- 2 
12 
but not 
1- -2 
~Io specify a specific number of occurrences or a specific range of occurrences, 
usc curly braces. For example, 
\w{2)-\d{4,5} 
matches exaClly twO letters and a dash (- ) followed by foul' or five digitS, such as 
Ab- 1234 
XX- 54321 
22-54321 
but not 
839 

840 
Ab-123 
?b-1234 
Yes, digits are \w characters. 
23.8.4 Grouping 
C H APTER 2 3 • TEXT MANIPULAT ION 
To specify a regular expression as a sub-pattern, you group it using parentheses. 
For example: 
1Id-,) 
lllis defines a sub-paltern of zero or more digits followed by a colon. A group 
can be used as part of a morc elaborate pattern. For example: 
1Id-,)/IId+) 
This specifics an optional and possibly empty sequence of digits followed by a 
colon followed by a sequence of one or more digits. No wonder people invented 
a terse and precise way of saying slich things! 
23.8.5 Alternation 
The "or" character (I) specifics an alternative. For example: 
SubjeCl: (FW:IRe:)l(.*) 
TIlis recognizes an email subject linc with an optional FW: or Re : followed by 
zero or morc characters. For example: 
Subject: FW: Hello, world! 
Subjecl: Re: 
Subject: Norwegian Blue 
but not 
SUBJECT: Re : Parrots 
Subject FW: No subject! 
An empty alternative is not allowed: 
(Idef) 
/I error 

23 .8 
REG ULA R EXPRESSIO N SYNTAX 
However. \\'e can specify several alternatives at once: 
(bsIBslbSIBS) 
23.8.6 Character sets and ranges 
rn le special characlers provide a shonhand for the most common classes of char-
acters: digits (\dl; letters, digits, and underscore (\wl; etc_ (§23.7.2l. However, it is 
easy and often uscfulto define our own. For example: 
l\w @1 
la-z] 
[a-zA-Z] 
IPpl 
[\w\-) 
lasdfghjkl; '1 
I . I 
I.I{(,,-+?IIS] 
a word character, a space, or an @ 
the lowercase characters from a to z 
upper- or lowercase characters from a to z 
an upper- or lowercase P 
a word character or a dash (plain - means range) 
the characters on the middle line of a u.s. QWERTY keyboard 
a dot 
a character with special meaning in a regular expression 
In a character class specifica.tion - (dash) is used to specify a range, such as 11-3] 
(1, 2, or 3) and Iw-z] (w, x, y, or zl. Please usc such ranges carefully: not every 
language has the same letters and not every letter encoding has the same order-
ing. If you fed the need for any range that isn't a sub-range of t.he most common 
letters and digits of the English alphabet, consult the documentation. 
Note that we can lise the special characters, sllch as \w (meaning "any word 
character"), within a character class specification. So, how do we get a backslash 
<\l into a character class? As usual, we "escape it
n with a backslash: " . 
When the first character of a character class specification is II , that II means 
negation. For example: 
Illaeiouy] 
III\dJ 
Illaeiouy1 
not an English vowel 
not a digit. 
<Ul English vowel or a II 
In the last regular expression, the II wasn't the first character after the I, so it was 
JUSt a character, not a negation operator. Regular expressions can be subtle. 
An implementation of regex also supplies a set of named character classes for 
use in matching. For example, if you want to match any alphanumeric character 
(that is, a Iettcr or a digit: a-z or A-Z or 0-9) you can do it by the regular expres-
sion [[ :alnum:]). Here, alnum is the nrulle of a set a charactcrs (the set of alpha-
Ilumeric chru·acters). A patlern for a nonempty quoted string of alphanumeric 
characters would be "U: alnum :ll+". To put that regular expression into a string, 
we have to escape the quotes: 
841 

342 
CHAPTER 23 • TEXT MANIPULATION 
string s = "\" [[:alnum :]I+\""; 
Furthermore, to put that string into a regcx, we must escape lhe backslashes as 
well as the quotes and usc the () style of initialization because regex's constmctor 
from a Siring is explicit: 
regex 5("\\\"11 : alnum : 1J+\\\''''); 
Using regular expressions leads LO a lot of notational conventions. Anyway, here 
is a list of the standard character classes: 
Character classes 
alnurn 
alpha 
blank 
cntrl 
d 
digit 
graph 
lower 
print 
punet 
, 
space 
upper 
w 
xdigit 
any alphanumeric character 
any alphabetic character 
any whitespace character thai is not a line separator 
any control character 
any decimal digit 
any decimal digit 
any graphical character 
any lowercase character 
any printable character 
any punctuation character 
any whitespace character 
any whitespace character 
any uppercase character 
any word character (alphanumeric characters plus the underscore) 
any hexadecimal digit character 
An implementation of regex may provide more character classes, but if yOll de-
cide to usc a named class not listed here, be sure to check if it is portable enough 
for your intended usc. 
23.8.7 Regular expression errors 
'What happens if we specify an illegal regular expression? Consider: 
regex pat1 ("(lghi)"); 
regex pat2("[c-a]"); 
II missing alternative 
/I not a range 

23 .11 
REGU LAR EXPRESS ION SYNTAX 
When we assign a pattem to a regeJl., the patlem is checked, and if the regular ex· 
pression matcher can't use it for matching hec.1.use it's illegal or too cOlllplic.1.ted, 
a bad_eJl.pression exception is th rown. 
Here is a little program that's useful for getting a feci for regular expression 
matching: 
#include <boost/regeJl..hpp> 
#include <iosiream> 
#include <string> 
#include <{stream> 
#include<sSlream> 
using namespace std; 
using namespace boost; 
/I if you use the boost implementation 
/I accept a pattern and a set o( lines from input 
/I check Ihe pattern and search (or lines with that pattern 
int mainO 
( 
regeJl. pattern; 
Siring pat; 
coul« "enter pattern : "; 
gelline(cin,pat); 
/I read pattern 
try { 
pattern = pat; 
/I this checks pal 
coul« "pattern : " « pattern « '\n'; 
calch (bad_eJl.pression) { 
) 
caul« pal « " is not a valid regular eJl.pression\n"; 
eJl.it(l); 
coul « "now enter lines:\n"; 
Siring line; 
II inpul buffer 
inllineno = 0; 
while (getline(cin,line» { 
++Iineno; 
smalch matches; 
843 

144 
CHAPTER 2] • TEXT MANIPULATION 
if (regex_search(line, matches, pattern» ( 
) 
else 
cout « "line " «
Iineno « ": " «
line « '\n'; 
for (int i = 0; kmalches.sizeO; ++i) 
cout « "\Imatches[" « i « "]: " 
« 
matches[i) « '\n'; 
cout « "didn't match\n"; 
TRY THIS 
Get the program to run and usc it to try out some pattcms, slich as abc, x. · x, 
(, . ), \([ "W\), and \w+ \w+( Jr\.)l, 
23.9 Matching with regular expressions 
rnlcrc arc twO basic uses of regular expressions: 
Seardling for a string that matches a regular expression in an (arbitrarily 
long) stream of data - regex_searchO looks for its patlclll as a substring 
in the stream 
Malchi1lg a regular expression against a string (of known Si7.c) -
regex_rnatchO looks for a complete match of its patlcrn and the string 
111c search for ZIP codes in §23.6 was an example of searching. Herc, wc will 
cxaminc an eXiUllple of matching. Consider extracting data from a tablc like t.his: 
KlASSE 
ANTAL DRENCE 
ANTAL P1CER 
ElEVER IALl 
OA 
12 
11 
23 
1A 
7 
8 
15 
18 
4 
11 
15 
2A 
10 
13 
23 
3A 
10 
12 
22 
4A 
7 
7 
14 
4B 
10 
5 
15 
SA 
19 
8 
27 
6A 
10 
9 
19 

23.9 
MATCHING WITH REGULAR EXPRESSIONS 
KLASSE 
ANTAL DRENGE 
ANTAL PIGER 
ElEVER IALl 
6B 
9 
10 
19 
7A 
7 
19 
26 
7G 
3 
5 
a 
71 
7 
3 
10 
BA 
10 
16 
26 
9A 
12 
15 
27 
OMO 
3 
2 
5 
01>1 
2 
01'2 
0 
5 
5 
l OB 
4 
4 
a 
I OCE 
0 
IMO 
a 
5 
13 
2CE 
B 
5 
13 
3DCE 
3 
3 
6 
4MO 
4 
5 
6CE 
3 
4 
7 
aCE 
4 
4 
a 
9CE 
4 
9 
13 
REST 
5 
6 
" 
Aile klasser 
184 
202 
3a6 
~nlis table (of the number of students in Bjame Stroustrup's old primary school 
in 2007) was c."'{tracted from a context (a web page) where it looks nice and is 
fairly typical of the kind of data we need to analyze: 
It bas numeric data fields. 
It has character fields with strings meaningful only to people who under-
stand the context of the table. (fIere, that point is emphasized by the use 
of Danish.) 
The character strings include spaces. 
~nl e "fields" of this data are separated by a "separation indicator," which 
in this case is a tab character. 
We chose this table to be "fairly typical" and "not too difficult," but note one sub-
tlety we must face: we can't actually see the differcnce between spaces and tab 
characters; wc have to leave that problem lO our code. 
845 

(HAPTER 23 • TEXT MANIPULATION 
We will illustrate the lise of regular expressions to 
Verify that this table is properly laid out (i.e., every row has the right 
number of fields) 
Verify that the numbers add up (the last line claims to be the sum of the 
columns above) 
If we can do lhat, we can do juSt about anything! For example, we could make a 
new table where the rows with lhe same initial digit (indicating the year: first 
grades start with I) arc merged or sec if the number of students is increasing or 
decreasing over lhe years in question (sec exercises 10- 11 ). 
To analyze the table, we need twO patterns: one for the header line and one 
for lhe rest of the lines: 
regex header( " I\(\\w 1+( 
regex rowe "I\ [\\w ]+( 
,\\w 1+)·5"); 
\\d+)( \\d+)( \\d+)S"); 
Please remember thal we praised the regular expression syntax ror terseness and 
utility; we did nOt praise it ror case or comprehension by novices. In ract, regular 
expressions have a well-eamed reputation ror being a "write-only language." Let 
liS st<'l.rt with lhe header. Since it docs nOt contain any numeric dala, we could just 
have thrown away that first line, but - to get some practice - let us pm·se it. It con-
sists or rour "word fields" ("alphanumeric fields") separated by tabs. TIlese fields 
can contain spaces, so we cannot simply usc plain \w to spcciry its characters. In-
stead, we lise I\w ], that is, a word character (leIter, digit, or underscore) or a 
space. One or more or those is written [\w J+. We want the first of those at the start 
or a line, so \ve get I\« \w J+). The "hat" (1\) mem1.S "start of line." Each or the rest 
or the fields can be expressed as a tab rollowed by some words: ( ,\w 1+). Now we 
take an arbitrary number or those rollowed by an end or line: ( [\w I+)·S. 'Ille 
dollar sign ($) means "end or line." Now to write that as a C++ string literal, we 
have to add extra backslashes, and we get 
nl\[\\w J+( 
[\\w I+)*S" 
Note how we can't sec that the tab characters arc really tabs, but in Lhis case they 
expand in the typesetting so as to rcveal themselves. 
Now ror the more interesting part or Lhe exercise: the pattern ror the lines rl'Om 
which we want to extract the nUllleric dala. 111C Grst field is as before: I\(\w J+. It is 
rollowcd by exactly tllree numeric fields, each preceded by a lab: ( \d+), so that we 
gel 
I\[\w J+( 
\d+)( 
\d+)( 
\d+)$ 

23 .9 
MATCH ING WITH REGULAR EXPRESSIONS 
which, after putting it into a string literal, is 
""[\\w 1+( 
\\d+)( 
\\d+){ 
\\d+)$" 
Now all we have to do is LO use those patterns. First we will juSt validate the table 
layout: 
inl mainO 
( 
ifstream in("lable.txl"); 
II input fi Ie 
if (! in) enor("no input file\n"); 
string line; 
II input buffer 
int line no = 0; 
II header line 
regex header( ""[\\w 1+( 
regex row( ""[\\w J+( 
[\\w I+)·S"); 
\\d+)( 
\\d+)( 
\\d+)S"); 
/I data line 
) 
if (gelline(in,line)) { 
smatch matches; 
II check header line 
if (!regex_match(line, matches, header)) 
en or("no header"); 
) 
while (gelline(in,line)) ( 
++Iinenoj 
smatch matchesj 
II check data line 
if (! regex_match(line, matches, row)) 
error("bad line" ,to_string(lineno» ; 
) 
For brevity, we left out the #includes. We arc checking all the characters on each 
line, so we usc resex_match rather than resex_search. The difTerence between 
those two is exactly that regex_malch must match every character of its input to 
succeed, whereas regex_search looks at the input trying to find a substring that 
matches. Mistakenly typing regcx_match when YOll meant rcscx_search (or vice 
versa) can be a most frustrating bug LO find. However, both of those functions 
usc their "matches" argument identically. 
We can now proceed to verify the data in that table. We keep a slim of the 
number of pupils in the boys ("drenge") and girls ("piger") columns. For each 
row, we check that last field ("ELEVER IAI.:T" ) really is the sum of the first twO 
fields. 111e last row ("Aile klasscr") purports to be the sum of lhe colunlllS above. 
847 

848 
CHAI' TER 23 • TEXT MANIPULATI ON 
To check that, we modify row to make the text field a subm3tch so that we can 
recognize "Allc klasscr"; 
int mainO 
( 
ifslream in("table.txl"); 
/I input file 
if (!in) c rror("no input file"); 
siring linc; 
II input buffer 
int lineno = 0; 
regex header( ""[\\w ]+( 
regex row( ""([\\w )+)( 
~\w I+)OS"); 
\\d+)( 
\\d+)( 
\d+)S"); 
if (getline(in,line» ( 
II check header line 
) 
boost: :smatch matches; 
if Oboosl: :regex_match(line, matches, header» ( 
e rror("no header"); 
/I column totals: 
int boys = 0; 
int girls = 0; 
while (getline(in,line» ( 
++Iineno; 
smatch matches; 
if (! regex_match(line, matches, row» 
(err « "bad line : "« lineno« '\n'; 
if (in.cofO) coul « "at eot\n"; 
II check row: 
int curf_boy = from_string<int>(matches[2]); 
int curr-&irl = from_string<int>(matches(3]); 
inl curr_total = from_string<int>(matches[4J); 
if (curr_boy+curr-&irl!= curr_total) error("bad row sum \n il); 
if (matches[l!=="Alle klasser") ( 
// Iast line 
) 
if (curr_boy 1= boys) error(lIboys don't add up\n"); 
if (curr-&irl 1= girls) error(IIgirls don't add up\n"); 
if (!(in»ws).eofO) error("characters after total line"); 
return 0; 

23 . 10 
REFEREN CES 
) 
1/ update totals: 
boys += curt_boy; 
girls += curr....girl; 
error("didn't find total line"); 
111e last row is semantically different from the other rows - it is their sum. \o\'e 
recognize it by its label ("Aile klasser"). We decided to accept no more non-white-
space characters arter that last one (using the technique from lexical_cast (§23.2)) 
and to give an error if \ve did not find it 
We used the from_string function from §23.2 to extract an integer vaJue from 
the data fields. We had aJready checked that those fields consisted exclusively of 
digits so we did nOI have to check that the string·lo·int conversion succeeded. 
23.10 References 
Reb'ular expressions arc a popular and useful tool. l11ey arc available in Illany 
programming lanbruagcs and in many fonnats. 111CY arc supported by an elegant 
theory based on formaJ languages and by an efficient. implementation technique 
based on state machines. 111e full generality of regular expressions, their theory, 
their implementation, and the use of state machines in general are beyond the 
scope of this book. However, because these topics arc rather standard in com-
puter science cun'icula and because regular expressions arc so popular, it is not 
hard to find morc information (should you need it or just be interested). 
For more information, sce: 
AllO, Alfred V., Monic.., S. Lam, Ravi Sethi, and Jeffrey D. Ullman. (;q,lIj)#t'TJ: 
AiflD/)/(J, 7CchlliqlleJ, alld -rooiJ, SeW!IlJ & Jitioll (usually called "111e Dragon 
Book"). Addison-Wesley, 200Z ISBN 0321 547985. 
Auslem , Matt, cd. "Draft Technical Report on C++ Library Extensions." 
ISO/IEC D"n < 19768, 2005. www.open·std.orgljtcl/sc22/w(l. l/docs/papers/ 
2005/n I836.pdf. 
BoosLorg. A repository for libraries meant 10 work weU with the C++ standard 
library. www.boost.org. 
Cox, Russ. "Regular E,xpression Matching Can Be Simple and Fast {but Is Slow in 
J ava, Perl, PHP, Python, Ruby, .. . ).'" http://swtch.com/-rscIrcgexplrcb'Cxp l.hunl. 
Maddoc,J . boost::reb'Cx documentation. www.boosLorgllibs/regexldodi.:ndcx.html 
Schwam, Randal L., 10m Phoenix, and Brian D. Foy. uamillg ltrl, rollrth EdiliQII. 
O 'Reilly, 2005. ISBN 0596101058. 
84. 

850 
CHAPTER 23 • TEXT MA N IPULATION 
~ 
Drill 
1. Find out if regclI: is shipped as part of your standard library. Hint: Try 
sid : : regell: and tr1 :: rege).:. 
2. Get the little program from §23.7.7 to work; t.hat may involve getting 
boost:: regex installed on yOlll' system (if it isn't already) and figuring 
out how to set the project and/or command·line options to link to the 
regell: library and usc the regell: headers. 
3. Usc the program from drill I to test the palterns from §23.7. 
Review 
I. Where do we find "texl"? 
2. What are the standard library facilities most frcqucnt..ly useful for text 
analysis? 
3. Docs insertO add before or after its position (or itcrator)? 
4. 'What is Unicode? 
5. How do you convert to and from a string representation (to and from 
some other type)? 
6. \Vhat is the difference between cin» s and getline(cin,s) assuming s is a 
string? 
7. List the st<mdard streams. 
8. What is the key of a map? Give examples of lIseful key types. 
9. How do you iterate over the clements of a map? 
10. What is the differcncc between a map and a multi map? Which useful 
map operation is missing for multimap, and why? 
II . 'What operations arc required for a fon vard iterator? 
12. What is the difference between an empty field and a nonexistent field? 
Give nvo examples. 
13. Why do we need an escape character to express regular expressions? 
14. How do you get a regular expression into a regex variable? 
15. What docs \w+\s\d(4} match? Give three examples. What string literal 
would you use to initialize a regex variable with that pattern? 
16. How (in a program) do you ftnd alit if a string is a valid regular expression? 
17. What does regex....searchO do? 
18. What does regex_matchO do? 
19, How do you represent the character dot (.) in a regular expression? 
20. How do you represent the notion of "at least three" in a regular c.'{pression? 
21. Is 7 a \w character? Is _ (underscore)? 

(t-tAPTER 23 EXERCISES 
22. What is the nOlation for an uppercase charactcr? 
23. How do you specify your own character set? 
24. How do you extract the value of an integer field? 
25. How do you represent a noating·point number as a regular expression? 
26. How do you extract a noating-point value from a match? 
27. What is a sub·match? How do you access one? 
Terms 
match 
multimap 
pattern 
Exercises 
regex_matchO 
regex_searchO 
regular expression 
search 
smatch 
sub-pattern 
I. Get the email me exam ple to nllli test it using a larger file of your own 
creation. Be sure to include messages that are likely to trigger errors, 
such as messages with twO address lines, several messages with the same 
address and/or same subject, and empty messages. Also test the program 
with something that simply isn't a message according to that program's 
specification, such as a large file containing no . . . lines. 
2. Add a mullimap and have it hold subjects. Let the program take an input 
string from the keyboard and print out every message with that string as 
its subject. 
3. Modify the email example from §23.4 to usc regular expressions to find 
the subject and sender. 
4. Fmd a real email message me (containing real email messages) and mod· 
ify the email example to extract subject lines from sender names taken as 
input from the user. 
S. Find a large email message file (thousands of messages) and then time it 
as wriuen with a multi map and with that multi map replaced by an un-
orde red_multimap. Note that our application docs not take advantage of 
the ordering of the multimap. 
6. Write a program that finds dates in a text file. Write Out each line COIl-
taining at least one date in the format line-numbe r: line. Start with a 
regular expression for a simple formal, e.g., 1212412000, and test the pro-
gram with that. Then, add more formats. 
7. Write a program (similar to the one in the previolls exercise) that finds 
credit card numbers in a me. Do a bit of research to find alit what credit 
card fonnats arc really used. 
851 

852 
CHAPTE R 23 • TEXT MANIPULATION 
8. Modify the program from §23.8.7 so that it takes as inputs a pattern and 
a fIle name. Its output should be the numbered lines (line- number: linc) 
that contain a match of the pattern. If no matches arc found, no Olltput 
should be produced. 
9. Using eorO (§B.7.2), it is possible to detcnninc which line of a table is the 
last. Use that to (try (0) simplify the table-checking program from §23.9. 
Be sure to test your program with files that end with empty lines after the 
table and with files that don't end WiUI a newline at all. 
10. Modify the tablc-chcck.ing program from §23.9 to write a new table 
where the rows with the same initial digit (indicating the year: first 
grades stan with 1) arc merged. 
11. Modify the table-checking program from §23.9 to sec if the number of 
snldenlS is increasing or decreasing over the years in question. 
12. Write a program, based on the program thai finds lines containing dales 
(exercise 6), that finds all dates and reformats them to ule ISO 
yyyy/mm/dd formal. The program should take an input file and produce 
an output file that is identical to the input file except for the changed date 
fommtting. 
13. Docs dot (.) match '\n'? Write a program to find OUL 
14. Write a program Ulat, like the one in §23.8.7, can be used to experiment 
with pauern matching by typing in a pattern. However, have it read a file 
into memory (representing a line break with the newline character, '\n'), 
so that you C."Ul experiment with patterns spanning line breaks. Test it 
and document a dOlen test patterns. 
15. Describe a pattern that cannot be expressed as a regular expression. 
16. For expens only: Prove that the pattern found in the previolls exercise 
really isn't a regular expression. 
Postscript 
It is easy to get trapped into the view that computers and computation arc all 
about numbers, that computing is a fonn of math. Obviously, it is not.Just look 
at your computer screen; it is full of tCXt and pictures. Maybe it's busy playing 
music. For every application, it is imponant to usc proper tools. In the context of 
C++, that means using appropriate libral·ies. For text manipulation, the regular 
expression library is often a key tool - and don't forget the maps and ule stan-
dard algorithms. 

' .. L '-:24 
Numerics 
"For every complex problem 
there is an answer that is 
clear, simple, and wrong." 
-H. l. Mencken 
T
his chapter is an overview of some fundamental language 
and library facilities supporting numeric computation. We 
present the basic problems of sizc, precision, and truncation. The 
central part of the chapter is a discussion of multidimensional ar-
rays - both C-stylc and an N-dimensional matrix library. We intro-
duce T<mdom numbers as frequently needed for testing, simulation, 
and games. Finally, we list the standard mathematical functions 
and briefly introduce the basic functionality of the standard li-
brary complex numbers. 
853 

854 
24.1 Introductio n 
24.2 Size, precision, and overflow 
24.2.1 Numeric limits 
24.3 Arrays 
24.4 C-slyle multidimensional arrays 
24.5 The Matrix library 
24.5.1 Dimensions and access 
24.5.2 10 Matrix 
24.5.3 20 Matrix 
24.5.4 Matrix I/O 
24.5.5 3D Matrix 
24.1 Introduction 
CHA PTER 2 4 • NUMER ICS 
24.6 An example: solving linear 
equations 
24.6.1 Classical Gaussian elimination 
24.6.2 Pivoting 
24.6.3 Testing 
24.7 Random numbers 
24.8 The standard mathematical 
f unctions 
24.9 Complex numbers 
24.10 References 
For some people, numerics - that is, serious numeric..1 computations - arc every-
thing. Many scientists, engineers, and statisljcians are in this category. For many 
people, numerics are sometimes essential. A computer scicmist occ..'1sionally col-
laborating with a physicist would be in this category. For most people, a need ror 
numerics - beyond simple aJithmetic or integers and floating·point numbers - is 
rare. The purpose or tills chapter is to address language·technical details needed 
to deal with simple numerical problems. We do not auempt to teach numerical 
analysis or the finer points or floating·point operations; such topics arc rar be· 
yond the scope or this book and blend Witil domain-specific topics in the applica· 
tion areas. Here, we present 
Issues related to the built·in types having fIXed size, such as precision and 
overflow 
Arrays, both the built·in notion of multidimensional arrays and a Matrix 
library that is better suited to numerical computation 
A most basic desCliption or random numbers 
The standard library mathematica1 functions 
Complex numbers 
The emphasis is on the Matrix library that makes handling or matrices (multi-
dimensional arrays) trivial. 
24.2 Size, precision, and overflow 
When we Lise the built-in types and L1sual computational techniques, numbers 
arc stored in fIXed amounts or memory; that is, tile imeger types (int, long, etc.) 
arc only approximations of the mathematical notion or integers (whole numbers) 

24. 2 
SIZE, PRECISION, AND OVER FLOW 
and the floating-point types (float, double, etc.) are (only) approximations of t.he 
mathematical notion of real numbers. TItis implies that from a mathematical 
point of view, some compmations arc imprecise or wrong. Consider: 
float x = 1.01333; 
float sum = 0; 
for (int i=O; k 333; ++i) sum+=x; 
cout « setprecision(15) « sum« "\n"; 
Running this, we do not gel I as someone might naively expect, but rather 
0.999999463558197 
We expected something like that. What we see here is an effect of a rounding 
error. A floating-point number has only a fixed number of bits, so we can always 
"fool it" by specifying a compmation that requires more bits to represent a result 
than the hardware provides. For example, the rational number 1/3 cannot be rep-
resented exacuy as a decimal number (however many decimals we usc). Neither 
can 11333, so when we add 333 copies of x (ule machine's best approximation of 
1/333 as a float), we get someuling that is slightly different from I. \,yhenever we 
make significant usc of floating-point numbers, rounding errors will occur; the 
only question is whether tlle error significantly affects tlle result. 
Always check that yOllr results arc plausible. When you compule, you must 
have some notion of what a reasonable result would look like or you could easily 
get fooled by some "silly bug" or computation elTor. Be aware of the possibility 
of rounding errors and if in doubt, consult an expert or read up on numerical 
techniques. 
TRY THIS 
... 
Replace 333 in the example with 10 and run the example again. What result 
would you expect? What result did you get? You have been warned! 
TIle effects of integers being of fixed size can sUlface more dramatically. The 
reason is that floating-point numbers arc by definition approximations of (real) 
numbers, so they tend to lose precision (i.e., lose the least significant bits). hlte-
gers, on L1le other hand, tend to overflow (i.c., lose the most significant bits). lllat 
tends to make floating-point errors sneaky (and often unnoticed by novices) and 
integer errors spectacular (and typically hard not to notice). Remember that we 
prefer errors to manifest themselves early and spectacularly so that we call fix 
them. 
855 

856 
Consider an integer problem: 
short int y = 40000; 
int i = 1000000; 
cout « y« " 
" «
j*j« "\n" i 
Running this, we got the output 
- 25536 
-n7379968 
CHAPTER 24 • NU MERICS 
·nlat was expected. \oVhal we see here is the effeCl of overflow. lmcgcr types rep-
resent (relatively) small integers only. There just aren't enough biLS LO cxacLiy rep-
!'cscm every number we need in a way that's amenable to efficient computation. 
Here, a 2-bytc short integer could not represent 40,000 and a 4-bytc int can't rep-
resent 1,000,000,000,000. The exact sizes arc++ built-in types (§A.8) depend on 
the hardware and the compiler; sizeof(x) gives you the size of x in bytes for a 
variable x or a type x. By definition, sizeof(char)==1 . We can illustrate sizes like 
this: 
char 
shorl 
D 
CD 
int, IOng,~, ~fI~o~a~
1 r--'-~=:=~:::;:~ 
do" ble LI ---"----"----'----'---1--1----'----' 
'n)CSC sizes arc for Windows using a Microsoft compiler. C++ supplies integers 
and flmlling-poim numbers of a variety of sizes, but unless you have a very g<Xld. 
reason for something clse, slick to char, int, and double. In mosl (but of course 
not all) programs, the remaining integer and floating-point types arc more trouble 
than Lhey arc wonh. 
You can assign an integer to a floating-point number. U the integer is larger 
than the floating-point type c..,n rcprcsclll, YOLI lose precision. For example: 
coul « "sizes: "« sizeof(int)« " « sizeo((floal)« '\n'; 
int x = 2100000009; 
II large int 
float f = Xi 
coul «x « ' , «
f « e ndl; 
cout « setprecision(15)« x«' '« f« '\0'; 
On our machine, this produced 
Sizes: 4 4 
2100000009 2.1e+OO9 

24.2 
SIZE, PRECI SION , AND OVERFLOW 
21 00000OO9 2100000000 
A float and an int take up the same amount of space (4 bytes). A float is repre-
sellted as a "mantissa" (typically a value between 0 and I) and an exponent 
(mantissa*IO ....... ), so it calUlot represent exactly the largest int. (If we tried to, 
where would we find space for the mantissa after we had taken the space needed 
for the exponent?) As it should, f represented 2100000009 as approximately cor-
rect as it could. However, that last 9 was too much for it to represent exactly -
and lhllt was of course why we chose that number. 
On the other hand, when you assign a floating-point number to an imeger, 
you get truncation; that is, the fractional part - the digits after the decimal point 
- is simply thrown away. For example: 
float f = 2.8; 
int x = f; 
cout« x«"« f « '\n'; 
~n le value of x will be 2. It will not be 3 as you might imagine if you arc lIsed to 
"4/5 rounding rules." C++ float-to'int conversions truncate rather than round. 
When you calculate, you must be aware of possible overflow and truncation. 
C++ will not catch such problems for you. Consider: 
void f(int i, double fpd) 
( 
) 
chare=i; 
short s = i; 
i = i+1 ; 
long Ig = i-i; 
float fps = fpd; 
i = fpd; 
fps = i; 
void gO 
{ 
char ch = 0; 
/I yes: chars really are very small integers 
II beware: an int may not fit in a short int 
II what if i was the largest int? 
II beware: a long may not be any larger than an int 
/I beware: a large double may not fit in a float 
/I truncates: e.g., 5.7 -> 5 
II you can lose precision (for very large int values) 
for (in I i = 0; i<500; Hi) 
coul« int(ch++)« '\1'; 
) 
If in doubt, check, experimem! Don't JUSt despair and don't JUSt read the docu-
mentation. Unless you are experienced, it is easy to misunderstand the highly 
technical documentation related to numerics. 
857 

858 
(HAPTER 24 • NUMERICS 
TRY THIS 
Run gO. Modify fO to prim out c, s, i, etc. Test it with a variety of values. 
Ille representation of integers and their conversions will be examined fur-
ther in §25.5.3. When we can, we prefer to limit ourselves to a few data types. 
That can help minimize confusion. For example, by not using float in a program, 
but only double, we eliminate the possibility of double-to-floal conversion prob-
lems. In fact, we prefer to limit OUf usc to inl, double, and complex (see §24.8) 
for computation, char for characters, and bool for logical entities. Vlc deal with 
the rest of the arithmeuc types only when we have to. 
24.2.1 Numeric limits 
In <limits>, <11mils.h>, and <float.h>, each C++ implementation specifics prop-
erties of the built-in types, so that programmers can use those properties to check 
against limits, set sentinels, etc. These values are listed in §B.9. 1 and can be criti-
cally important to low-level tool builders. If you think you need them, you arc 
probably too close to hardware, but there arc other uses. For example, it is nOt 
uncommon to be curious abollt aspects of the language implememation, such as 
"How big is an inl?" or "Are chars signed?"' Trying to find the definite and cor-
rect answers in the system documentation can be difficult, and the standard only 
specifies minimum requirements. However, a proh'1'am giving the answer is trivial 
to write: 
cout« "number of bytes in an int: " «sizeof(inl) « '\n'; 
coul« "largest int: "« INT_MAX« endl; 
coul « "smallest int value : " « numeric limits<int>: :minO« '\n'; 
if (numeric-,imils<char>: : is_signed) 
cout « "char is signed\n"; 
else 
coul « "char is unsigned\n"; 
coul« "char with min value: "« numeric_limits<char>: :minO« '\n'; 
cout « "min char value: "« int(numeric_limils<char>: :min())« '\n'; 
When you write code imended to run on several kinds of hardware, it occasion-
ally becomes immensely valuable to have t.his kind of information available to 
the program. -nle alternative would typically be to hand·code the answers into 
the program, thereby creating a maintenance hazard. 
TIlese limits can also be useful when you want LO detect overnow. 

24.4 
C-STYlE MULTIDIMENSIONAl ARRAYS 
24.3 Arrays 
An amry is a sequence of elements where we can access an element by its index (p0-
sition). Another word for tlmt general notion is ueclor. Here \ve arc particularly eOIl-
cellled Witll arrays where the clements arc themselves arrays: multidimensional 
arrays. A common word for a multidimensional array is IfUltrix. The variety of 
names is a sign of the popularity and utility of tile general concept The standard 
veclor (§B.4), array (§20.9), and the built-in array (§A.8.2) are one-dimensional. So, 
what if we need twO dimensions (e.g., a matrix)? If we need seven dimensions? 
We can visualize one- and two-dimensional arrays like tllis: 
I I I I I 
A vector (e.g., Malrix<int> \/(4»), 
also called a one·dimensional array, 
or even a I-by-N mauix 
A 3·by4 matrix (e.g., Matrix<int,2> m(3,4»), 
also called a two-dimensional array 
Arrays arc fundamemal to most compming ("number cnmching"). Most intercst-
ing scientilic, engineering, statistics, and linancial computations rely heavily on 
alTays. 
We often refer to an array as consisting of rows and columns: 
A colulI1n 
A row 
, __ _____ ___ .,/ 
\.I ......... ~ ......... t ......... ~ ....... l A3by4ma~,
. 
. 
~. i-... --... ..... ---i ___ mm} ________ _ ) r~~~:: a two-dnnenSlonal array 
. 
. 
. 
A column is a sequence of elements wiLh the same rrrst {xl coordinate. A row is a 
SCI of elements with the same second (y) coordinate. 
24.4 C-style multidimensional arrays 
' 11e c++ built-in array c."'l.n be used as a multidimensional array. We simply treat 
a multidimensional array as an array of arrays, that is, an array with arrays as el-
ements. For example: 
85' 

.60 
int ail4J; 
double ad[3][4]; 
char ac[3][4][Sl; 
ai[l] = 7; 
ad[2][3] = 7.2; 
ac[2][J][4] = 'e'; 
Il l-dimensional array 
1/ 2-dimensional array 
11 3-dimensional array 
CHAPTER 24 • NUMERI C S 
1l1is approach inherits the virtues and the disadvantages of the one-dimensional 
array: 
Advantages 
Direct mapping LO hardware 
Efficient for low-level operations 
Direct language support 
Problems 
C-slyle multidimensional arrays arc alTays of arrays (sec below). 
Fixed sizes (i.e., fixed at compile time). If yOll want to determine a 
siz.e at run time, you'll have to usc free store. 
Can't be passed cleanly. An array turns imo a pointer to its first cle-
ment at the sliglllcst provocation. 
No mnge checking. As usual, an array doesn't know it's own size. 
No array operations, not even assignment (copy). 
Built·in arrays arc widely used for numeric computation. "Iltcy are also a mqjo/" 
source of bugs and complexity. For most people, they are a serious pain to write 
and debug. Look them up if you are forced to use them (e.g., 'l7!e C++ Program-
ming L(lngu(lge, Appendix C, pp. 836-40). Unfortunately, C++ shares its multi· 
dimensional arrays with C, so there is a lot ·of code "out there" using them. 
The most fundamental problem is that you can't pass multidimensional ar· 
rays cleanly, so you have to fall back on pointers and explicit calculation of loca· 
tions in a multidimensional array. For example: 
void fl(int a[J][5J); 
II useful for 13]lSI matrices only 
void f2(inl [ ][5J, int diml); 
111 st dimension can be a variable 
void n (inl [5 ][ I, int dim2); 
/I error: 2nd dimension cannot be a variable 
void £4(inl[ H ], int diml, inl dim2); /I error (and wouldn't work anyway) 

2 4.5 
Tt-lE MATR IX LIBR A RY 
void f5(int· m, int diml , int dim2) II odd, but works 
{ 
for (int i=Oj i<diml j ++i) 
for (int j = OJ j<dim2; ++j) mWdim2+jJ = OJ 
) 
Here. we pass m as an int- even though it is a two-dimensional array. As long as 
the second dimension needs to be a variable (a parameter). there really isn't any 
way of telling the compiler that m is a (dim1 ,dim2) array. so we just pass a pointer 
to the SL.'lrt of the memory that holds it. ' 11e expression mWdim2+jJ really means 
mli,il, but because the compiler doesn't know that m is a two-dimensional array, 
we have to calculate the position of mli,jJ in memory. 
This is tOO complicated, primitive, and error-prone for our taste. It can also 
be slow because calculating the location of an element explicitly complicates opti-
mization. Instead of trying to teach you all about it, we will concentrate on a 
C++ library that eliminates the problems with the built-in arrays. 
24.5 The Matrix library 
What arc the basic "things" we want from an array/matTi." aimed at numerical 
computation? 
"My code should look very much like what I find in my math/engineer-
ing textbook text about arrays." 
Or about vectors, matrices, tensors 
Compile-time and run-time checked. 
Arr.tys of any dimension 
Arrays with any number of elements in a dimension 
An-ays arc proper variables/objects. 
You ca.1l pass them around 
Usual array operations: 
Subscripting: ( ) 
Slicing: r J 
AssignmeIll: = 
Scaling operations (+=, -=, -=, %=, etc.) 
Fused vector operations (e.g., resli] =alil°c+b[2J) 
[)()( product (res = sum of a[i]-blil; also known as the inner_product) 
861 

862 
C H APTER 24 • N UM ERIC S 
Basically, lransfonns conventional array/vector notation into the code 
yOll would laboriously have had to write yourself (and n ms at least as ef-
ficiently as that). 
You can extend it yourself as needed (no "mab';c" was used in its imple-
mentation). 
~nlC Matrix library does that and only that. If you waIll more, such as advanced 
array functions, sparse arrays, control over memory layout, etc., you must write 
it yourself or (preferably) lISC a library that beneT approximates your needs. 
However, many such needs can be served by building algorithm and data struc-
tures on top of Matrix. The Matrix library is not part of lhe ISO C++ standard li-
brary. You find it on the course site as Matrix.h. It defines its facilities in 
namcspacc Numeric_lib. We chose the name "matrix" because "vector" and 
"array" are even more ovem sed in C++ libraries. ~nle plural of matrix is IIUI/riUJ 
(with 1IU1/ri:.:eJ as a rarer form), Where "Matrix" refers to a C++ language emity, 
we will use Matrixes as the pluraiLO avoid confusion, 111e implementation of lhe 
Matrix library uses advanced techniques and will nOt be described here. 
24.5.1 Dimensions and access 
Consider a simple example: 
#include "Matrix.h" 
using namespace Numeric lib; 
void (int nl , int n2, int n3) 
{ 
Matrix<double,1> adl (nl); 
Matrjx<int,1> ail (nl); 
adl (7) =0; 
adl [7] =8; 
Matrix<double,2> ad2(nl ,n2); 
1/ elements are doubles; one dimension 
1/ elemcnts arc ints; onc dimension 
1/ subscript using ( ) -
Fortran style 
1/11 also works -
C style 
I/l-dimensional 
Matrix<double,3> ad3(nl ,n2,n3); 
1/3-dimensional 
ad2(3,4) = 7.5; 
1/ true multidimensional subscripting 
ad3(3,4,5) = 9.2; 
So, when you define a Matrix (an object of a Matrix class). you specify the clement 
type and the number of dimensions. Obviously, Matrix is a template, and the ele· 
ment type and the number of dimensions arc template panmleters. 111e result of 
giving a pair of arguments to Matrix (e.g., Matrix<double,2» is a type (a class) of 
which yOll can define objects by supplying arguments (c.g., Matrix<double,2> 

24 .5 
THE MATRIX LIBRARY 
ad2(nl,n2»); those arguments speeify the dimensions. So, ad2 is a nvo-dimensionai 
array with dimensions nl and n2, also known as an nl-by-n2 matrix. To gel an 
e1emelll of the declared clement type from a onc-dimell5ional Matrix, you sub-
script with one index; to get an clement of the declared element type from a two-
dimensional Matrix, you subscript with twO indices; and so on. 
Like built-in arrays, and vedars, our Matrix indices are zero-based (rather 
than I-based like Fortran arrays); that is, the clements of a Matrix arc numbered 
[O,max), where ma..x is the number of elements. 
This is simple and "straight out of the textbook." If you have problems with 
this, you need to look at an appropriate math textbook, nOt a programmer's 
manual. The only "cleverness" here is that you can leave out the number of di-
mensions for a Matrix: "one·dimensional" is the default. Note also that we can 
usc I I for subscripting (C and C++ style) or ( ) for subscripting (Fortran style). 
Having bOlh allows us to better deal with multiple dimensions. The [xl subscript 
notation always takes a single subscript, yielding the appropriate row of the 
Matrix; if a is an II-dimensional Matrix, alx] is an /I- I-dimensional Matrix. 111c 
(x,y,z) subscript notation takes one or more subscripts, yielding the appropriate 
clement of the Matrix; the number of subscripts Illust equal the number of di-
menSIons. 
Let's see what happens when we make mistakes: 
void [(inl nl , int n2, int n3) 
( 
) 
Matrix<int,O> aiD; 
/I error: no 00 matrices 
Matrix<da uble, 1> adl (5); 
Matrix<inl,l> ai(5); 
Malrix<double,1> adll m i 
adl (7) = 0; 
ad1 = ai; 
adl = adl1 ; 
/I Matrix_error exception (7 is out of range) 
II error: different element types 
/I Matrix_crror cxception (different dimensions) 
Malrix<double,2> ad2(nl); 
ad2(3) = 7.5; 
ad2(1 ,2,3) = 7.5; 
/I error: length of 2nd dimension missing 
/I error: wrong number of subscripts 
II error: wrong number of subscripts 
Malrix<double,3> ad3(nl ,n2,n3); 
Matrix<double,3> ad33(nl ,n2,n3); 
ad3 = ad33; 
II OK: same element type, same dimensions 

... 
(HAI'TE R 24 • NUMERICS 
We catch mismatches between the declared number of dimensions and their use 
al compile time. Range errors we catch at run time and throw a Malril,_error 
exception. 
IllC first dimension is the row and the second the column, so we index a 20 
matrix (two-dimensional array) with (row,column). We can also usc the [..ow][co1-
umn] notation because subscripting a 2D matrix with a single index gives the 10 
matrix that is tllC row. We can visualize that like this: 
a[O]: 
alll: 
a[2): 
00 
10 
20 
01 
02 
11 12 
21 
22 
011J121 
/ 
All 
1,2) 
~ . 
13 
23 
TIlis Matrix will be laid out in memory in "row-first" order: 
A Matrix "knows" its dimensions, so we can address the clements of a Matrix 
passed as an argument very simply: 
void init(Matrix<int,2>& a) 1/ initialize each element to a characteristic value 
{ 
} 
for (int i=O; ka.diml0; ++i) 
for (int j = 0; j<a.dim2(); Hj) 
a(i,j) = 10· i+j; 
void print(eonst Matrix<int,2>& a) /I printlhe elements of a row by row 
{ 
} 
for (int i=O; i<a.diml0; Hi) { 
for (int j = 0; j<a.dim2(); ++j) 
cout «a(i,j) «'\1'; 
coul« '\n'; 
So, diml() is the number or clements in the first dimension, dim20 the number or 
clements in the second dimension, and so on. l11e type or the clements and the 
number or dimensions are pan or the Matrix type, so we C.1Ilnot write a function 
that takes any Matrix as an argument (but we could write a template to do that): 
void init(Malrix& a); 
/I error: element type and number of dimensions missing 

14.5 
THE MATR I X LIBRARY 
Note that the Malrix library doesn't supply matrix operations, sllch as adding 
two 40 Malrixes or multiplying a 20 Malrix with a lD Malrix. Doing so ele-
gantly and efficiently is currently beyond the scope of this library. MatrL,( li-
braries of a variety of designs could be built on top of the Malrix library (sec 
exerCLse 12). 
24.5.2 1 D Matrix 
Wh,H can we do to the simplest Malrix, the ID (one-dimensional) Malrix? 
We C'111 leave the number of dimensions out of a declaration because 1 D is 
the default: 
Malrix<inl,1> al (10); 
Malrix<inl> a(10); 
II a 1 is aiD Matrix of ints 
II means Matrix<int, I> a(1 0); 
So, a and al arc of the same type (Matrix<int,1» . We can ask for the size (the 
number of elements) and the dimension (the number of elements in a dimen-
sian). For a I 0 Matrix, those arc the same. 
a.sizeO; 
a.diml0; 
/I number of elements in Matrix 
/I number of elements in 1st dimension 
\>Ve can ask for tile elements as laid out in memory, that is, a pointer to the first 
element: 
int- p = a.dataO; 
II extract data as a pointer to an array 
l 1lis is useful for passing Matrix daLa to C Slyle functions taking pointer argu· 
ments. We can subscript: 
ali); 
II ith element (Fortran style), but range checked 
a[i); 
II ith element (C style), range checked 
a(I ,2); /I error: a is a 'D Matrix 
It is comlllon for algorithms to refer to part of a Matrix. Such a "part" is called a 
sliceO (a sub-Matrix or a range of elements) and we provide twO versions; 
a.slice(i); 
/I the clements from the a Iii to the last 
a.slice(i,n); 
lithe n elements from the a[llto a [I+n- 11 
Subscripts and slices can be used on lhe left-hand side of an assignment as well as 
on the right. lllcy refer LO the elements of their Matrix without making copies of 
them. For example: 
865 

866 
C H APTER 24 • NU MERI CS 
a.slice(4.4) = a.slice(0,4); 
/I assign first half of a to second half 
For example, if a starts out as 
{ 1 23 4 567 8 } 
we get 
{1 23 41 23 4 } 
Note that the most common slices are the "initial elements" of a Matrix and the 
"last elements"; that is, a.slice(O,j) is the range [0:;) and a.s lice(j) is the range 
[j:a.sizeO). III particular, the example above is most easily written 
a.slice(4) = a.slice(O,4); 
/I assign first half of a to second half 
11mt is, the notation favors the common cases. You ca.1l specify i and n so that 
a.slice(i,n) is outside the range of a. However, the resulting slice will refer only to 
the elements actually in a. For example, a.slice(i,a.size()) refers to the range 
[i:a.sizeO), and a.slice(a.size()) and a.slice(a.sizeO,2) are empty Matrixes. "ntis 
happens to be a useful convention for many algorithms. ''''e borrowed that con-
vention from math. Obviously, a.slice(i,O) is an emply Matrix. We wouldn't write 
that deliberately, but there arc algorithms that are simpler if a.slice(i,n) where n 
happens to be 0 is an empty Matrix (rather than an error we have to avoid). 
We have the usual (for C++ objects) copy operations that copy all elements: 
Matrix<inl> a2 = a; 
/I copy initialization 
a = al; 
/I copy assignment 
We can apply a built-in operation to each element of a Matrix: 
a -= 7; 
a = 7; 
Il scaling: alil·=7 for each i (also +=. -=.1=. etc.) 
/I alil =7 for each i 
Illis works for every assignmcllI and every composite assignlllent operator (=, 
+=, - =, 1=, "=, %=, "=, &=, 1=, »=, «=) provided lhe element type supports that 
operator. We can also apply a function to each element of a Malrix: 
a.apply((); 
a.apply(f,7); 
/I a[il =f(a[ill for each element alii 
/I a[i!=f(aIiL7) for each elemenl alii 

24 .5 
THE MATRIX lIHRARY 
The composite assignment operators and applyO modify the elements of lheir 
Matrix argumcnt. If we instead want to create a new Matrix as the result, we can 
use 
b = apply(abs,a)j 
/I make a new Matrix with b(i)::abs(a(i)) 
This abs is the standard library's absolute valuc function (§24.8). Basic.1..IIy, 
apply(f,x) relates to x.apply(f) as + relates to +=. For example: 
b = a·7j 
a .= 7j 
Y = apply(f,x)j 
x.apply(f)j 
/I blil = alil '7 for each i 
/I alii", a[il *7 for each i 
II y[i] = i(x[i]) for each i 
/I x[iI:. f(x[i]) for each i 
Here we get a==b .md x==y. 
In Fonran, this second apply is called a "broadcast" function and is typically 
written f(x) rather than apply(f,x). To make this facility available for every func-
tion f (rather than juSt a selected few functions as in Fortran), we need a name for 
the "broadc."l.St" opcrmion, so we (rc)use apply. 
In addition, to match the two-argument version of the member apply, 
a.apply(f,x), we provide 
b = apply(f,a,x); 
I/b[i[",f(ali[,x) for each i 
For example: 
double scale(double d, double s) { return d·s; ) 
b = apply(scale,a,n; 
II b[il :::: alW7 for each i 
Note that the "freestanding" applyO takes a function that produces a result from 
its argument; applyO then uses those results to initialize the resulting Matrix. Typ-
ically it docs not modify the Matrix to which it is applied. rnle member applyO 
difTers in that it takes a function that modifies its argumem; that is, it modifies cl-
ements of the Matrix to which it is applied. For example: 
void scaleJ n_place(double& d, double s) { d .= 
5; ) 
b.apply(scaleJ n_place,7)j 
II blil . ", 7 for each i 
We also supply a couple of the most useful functions from traditional numerics 
libraries: 
Matrix<inl> aJ = 5cale_and_add(a,8,a2); 
int r = doCproduct(aJ,a); 
/I fused mulliply and add 
/I dOl producl 
'.7 

... 
CHAPTER 24 • NUMERICS 
11l(~ scale_and_addO operation is often referred to asfitsed lJIullijJly-add or simply 
/mll; its defmilion is result(i)=arg1(i)"arg2+arg3(i) for cadI i in the Matrix.. ~111C dot 
product is also kllown as the inner_product and is described in §21.5.3; its defini-
tion is resull+=argl (i)-arg2(j) for each i in the Matrix where result stalts out as O. 
Onc-dimcnsional arrays arc very COIIDll0 n ; you can rcprcsCnl one as a built-in 
array, a vector, or a Matrix. You use Matrix if yOll need the matrix operations pro-
vided, such as "=, or if the Matrix has to interact with highcr~imcns ional Matrixcs. 
You can explain the utility of a library like this as "It matches the math bet-
ter" or "It saves you from ,"vOting all those loops to do things for each clement." 
Either way, the resulting code is significantly shorler and there arc fewer oppor-
tlmities to make mistakes writing it. TIle Matrix operations - such as copy, as-
sigmllem to all clements, and operations on all clements - each save LIS from 
reading or writing a loop (and from wondering if we got the loop exactly right). 
Matrix supports two cons tructors for copying data from a built-in array into a 
Matrix_ For example: 
void some_function(double p, int n) 
{ 
double vain = { 1.2, 2.3, 3.4, 4.5 }j 
Matrix<double> data(p,n); 
Matrix<double> constants(val); 
II . 
) 
~nleSe arc often useful when we have our data delivered in terms of arrays or 
vectors from parts of a program not using Matrixes. 
Note that lhe compiler is able to deduce the number of clements of an initial· 
ized array, so we don't have to give the number of clements when we define 
constants - it is 4. On the other hand, the compiler doesn't know the number of 
clements given only a pointer, so for data we have to specify both the poimer (p) 
and the number of clements (n). 
24.5.3 2D Matrix 
-nle general idea of the Matrix library is that Matrixes of different dimensions 
really arc quite similar, except where yOLl need to be specific about dimensions, 
so most of what we said about a 10 Matrix applies to a 20 Matrix: 
Matrix<inl,2> a(3,4); 
inl s = a.size(); 
inl d1 = a.dim1 0; 
inl d2 = a.dim20; 
inl· p = a.data(); 
II number of elements 
/I number of elements in a row 
/I number of clements in a column 
/I extract data as a pointer to a C·style array 

24 .5 
THE MATRIX LIBRARY 
We can ask for the total number of elements and the number of elements of eaeh 
dimension. We c..""tIl get a pointer to the clements as they arc laid out in memory 
as a matrix. 
We can subscript: 
a(i,j); 
a(iJ; 
ali][jl; 
II {i,Pth element (Fortran style), but range checked 
II ith row (C style), range checked 
II (i,Plh clement (C style) 
For a 20 Matrix, subscripting with IiI yields the 10 Matrix that is the ist row. 
111is means that we can extract rows and pass them to opera Lions and functions 
that require ai D Matrix or even a built·in array (a[i},dataO). Note mat a(i,j) may 
be faster than a[illj], though that will depend a lot on me compiler and optirnizcr. 
c j---------t --------f ---------f --------_ 1 _:-'::'=~;'2> al3.4) 
We can lake slices: 
a.slice(i); 
a.slice(i,n); 
II the rows from the alii to the last 
II lhe rows from the alii to the a(i+n- \ J 
a.slice(O,2) "-... 
,- -~ ---------~ ---------~ --------l---------l--· 
: 
, ............ -_ ... _. ; 
... . --... --. --.. -.. to .... _ .. -.... _-.-.. __ -.-.... _-.-.-.. _-__ 'J' 
Matrix<int,2> a(3,4) 
~ 
a[21.slice(2) 
Note that a slice of a 20 Matrix is itself a 20 Matrix (possibly with fewer rows). 
"n le distributed operations arc the same as for 10 Matrixes. ll1ese opera-
tions don't care how we organiz.e the clements; they just apply to all elements in 
lhe order those clements are laid down in memory: 
Matrix<int,2> a2 = a; 
01 = 012; 
a 0= 7; 
a.al>ply(f); 
a.apply(f,7); 
b=apply(f,a); 
b=apply(f,a,7); 
II copy initialization 
II copy assignment 
II scaling (and +::, -=, 1=, etc.) 
II a(i,j)=f{a(i,p) for each element a(i,jl 
II a(i,j)=f(a{i,j),7) for each element a(i,j) 
II make a nC\v Matrix with b(i,j)==f(a{i,j)) 
II make a new Matrix with b(i,j)==i(a(i,j),7) 
... 

870 
CHAPTER 2 4 • NUMERICS 
It tllrns Ollt that swapping rows is often useful, so we supply that: 
a.swap_rows(7,9); 
II swap rO\vs al71 <-> a[91 
TIlerc is no swap_columns(). If you need it, write it yourself (exercise 11). Be-
cause of the row-first layout, rows and columns arc nOl completely synuncu'ical 
concepts. Illis asymmetry also shows up in that Ii] yields a row (and we have not 
provided a column selection operator). In that (i,j,k), the first index, i, selects the 
row. TIle asymmetry also reflects deep malhCmalical properties. 
'n lcrc seems to be an infinite number of "things" that arc lwo-dimensional 
and thus obvious candidates for applications of20 Matrixcs: 
enum Piece {none, pawn, knight, queen, king, bishop, rook }; 
Matrix<Piece,2> board(8,8); 
/I a chessboard 
consl int while_slarl_row = 0; 
const int black_starCrow = 7; 
Piece inil_pos[J = (rook, knight, bishop, queen, king, bishop, knight, rook); 
Matrht<Piece> slarC row(inil_pos); 
1/ initialize elements from init_pos 
Matrix<Piece> clear_row(8) ; 
1/8 elements of the default value 
"nle initialization of clear_row takes advantage of none==O and that cle-
ments arc by default initialized to o. We would have liked to write 
Matrix<Piece> sfarC row 
= {rook, knight, bishop, queen, king, bishop, knight, rook}; 
However, that won't work until the next version of C++ (C++Ox), so we must 
usc the trick of initializing an array (here, inie pos) and usc thai to initialize the 
Matrix.. We can usc starCrow and clear_row like this: 
board[white_start_rowl = start_row; 
for (int j = 1; i<7; ++i) board[i) = clear_row; 
boardlblack_starCrowl = slarCrow; 
1/ reset white picces 
1/ clear middle of the board 
1/ resct black pieces 
NOle when we extract a row, using Ii], we get an Ivalue (§4.3); that is, we c:m as-
sign to the result of boardli]. 
24.5.4 Matrix 1/0 
"m e Matrix library provides very simple 110 for tD and 2D Matrixes: 
Matrix<double> a(4); 

24.5 
TH E MATRIX LIBRARY 
dn» a, 
cout « a, 
ll1is will rcad four whitcspacc-scparatcd doubles delimited by curly braccs; for 
cxamplc: 
( 1.23.45.67.8 } 
~111 C output is very similar, so that you can read in what YOll wrote out. 
111c 110 for 20 Matrixes simply reads and writes a curly-brace-delimited se-
quencc of 10 Matrixes. For example: 
Matrix<int,2> m(2,2); 
ein» m; 
eout « m, 
111is will read 
{ 
{ 1 2) 
{3 4) 
) 
111C output will bc vcry similar. 
111C Matrix « and » operators arc provided primarily to makc thc writing 
of simple programs simple. For more advanced uses, it is likely that you will nced 
to replace lhem with your own_ Conscquently, thc Matrix « and » are placed 
in tlle MatrixlO.1l header (rather than in Matrix.h) so that you don't have to in-
clude it to lise Matrixes. 
24.5.5 3D Matrix 
Basically, a 30 (and higher-dimension) Matrix is just like a 20 Matrix, except 
with more dimensions_ Consider: 
Matrix<int,l> a(10,20,3O); 
a.size(); 
a.dim1 0, 
a.dim20, 
a.dim30; 
int· p = a.datal), 
a(i,j,k), 
ali], 
// number of elements 
/I number of elements in dimension 1 
/1 number of clements in dimension 2 
/I number of elements in dimension 3 
/I extract data as a pointer to a C-style array 
/I (i,j,k)th element (Fortran style), but range checked 
/I ith row (C style), range checked 
871 

a[iJ[jl(k]; 
a.slice(i); 
a.slice(i,j)i 
Matrix<int,3> a2 = ai 
a= ali 
a·= 7i 
a.applY<Oi 
a.apply(f,ni 
b=apply(f,a)i 
b=apply(f,a,ni 
a.swap_rows(7,9)i 
( HAPTER 24 • NUMERICS 
/I (i,j,k)th element (e style) 
/I the elements from the ith to the last 
1/ the elements from the ith to the jth 
/I copy initialization 
1/ copy assignment 
/I scaling (and +=, -=, 1=, etc.) 
/I a{i,j,k)=i(a(i,j,k)) for each element a(i,j,k) 
1/ a(i,j,k)=f(a(i,j,k),7) for each element a(i,i,k) 
/I make a new Matrix with b(i,j,k)==f(a(i,j,k)) 
II make a new Matrix with b(i,j,k)==f(a(i,j,k),7} 
/I swap rows al71 <-> al91 
If you understand 20 Matrixes, you understand 3D Matrixes. For example, herc 
a is 3D, so ali] is 20 (provided i is in range), a[iJlj] is 10 (provided j is in range), 
and a[iJlj][kJ is the in! clement (provided k is in range). 
We tend to see the world as three-dimensional. 11mt leads to obvious uses of 
3D Matrixes in modeling (e.g., a physics simulation using a Cartesian grid): 
int grid_nx; 
1/ grid resolution; set a! stanup 
in! grid_" y; 
in! grid_nz; 
Malrix<double,3> cube(grid_nx, grid_"y, grid_nz}; 
And then if we add time as a fourth dimension, we get a 40 space needing a 40 
Matrix. And so on. 
24.6 An example: solving linear equations 
"Ille code for a numerical computation makes sense if you understand the math 
that it expresses and lends to appear to be utter nonsense if you don't. 'lllC CX· 
ample used here should be rather trivial if you have leamed basic linear algebra; 
if not, just see it as an example of transcribing a textbook solution into code with 
minimal rewording. 
The example here is chosen to demonstrate a reasonably realistic and impor· 
tant use of Matrixes. We will solve a set (any set) of linear equations of this form: 
a. ,x, + ... + a x = h 
~ 
... . . 
Here, the x's designate the 11 unknowns; a's and b's arc given constants. For sim· 
plicity, we assume that the unknowns and the constants arc floating·point values. 

24.6 
AN EXAMPLE: SOLVING LINEAR EQUATIONS 
111e goal is to find values for the unknowns I.hat simultaneously satisfy the 1/ 
equations. 111cse equations can compactly be expressed in temlS of a matrix and 
two vectors: 
Ax = b 
Here, A is the square n·by-n matrix defined by the coefficients: 
A= 
a.... 
a ..... 
TIle vectors x and b arc lhe vectors of unkllowns and constants, respectively: 
x, 
b, 
x = 
and b = 
x 
h 
• 
• 
111is system may have zero, one, or an infinite number of solutions, depending 
on the coefficients of the matrix A and the vector b. There arc various methods 
for solving linear systems. We usc a classic scheme, called Gaussian elimination 
(see Freeman and Phillips. RIrallel Nummml AlgvritlllllJ; Stewart, Matrix AlgorithlJls, 
VOlume I; and Wood, Inlrrxluchim to NUlJIeriali AI/alysis). First, we transform A and b 
so that A is an upper-triangular matrix. By upper-triangular, we mean all the co-
efficients below the diagonal of A arc zero. In other words, the system looks like 
this: 
au 
a,. 
x, 
h, 
0 
= 
0 
0 
a 
x 
h 
.-
• 
• 
11lis is easily done. A zero for position a(iJ') is obtained by multiplying the equa-
tion for row i by a conStant so that a(i,j) equals another clement in columnj, say 
a{kJ). That done, we just subtract lhe two equations and a{iJ') = 
0 and the 
Olher values in row i change appropriately. 
If we can get all the diagonal coefficients to be nonzero, then the system has a 
unique sollilion, which can be found by "back substitution." The last equation is 
easily solved: 
a x = b 
.... . . 
Obviously, x[n) is b[II]la(II,Il). That done, eliminate row /I from the system and pro-
ceed to find the value of xIn- IJ. and so on, until the value for xIlJ is computed. 
873 

874 
CHA PTER 24 • NUMERICS 
For each II, we divide by a(n,n) so the diagonal values must be nonzero. If t.hat 
docs not hold, the back substitution method fails, meaning that the system has 
zero or an infinite number of solutions. 
24.6.1 Classical Gaussian elimination 
ow let us look at the C++ code to express lhis. First, we'll simplify OUf notation 
by conventionally naming the two Matrix types that we arc going to lise: 
Iypedef Numericlib: :Malrix<double, 2> Matrix; 
typedef Numeric_lib: :Matrix<double, 1> Vector; 
Next we will express our desired compulation: 
Vedor classical....gaussian_climination(Malrix A, Vector b) 
( 
) 
dassical_elimination(A, b); 
return back_substitution<A, b); 
11mt is, we make copies of our inputs A and b (using call by value), call a func-
tion to solve lhe system, and lhen calculate the result to relUIll by back substitu-
tion. The point is thai our breakdown of the problem and our notation for the 
solution are right out of the textbook. To complele OllT solution, we have 10 im-
plement dassical_eliminationO and back_substitutionO. Again, the solution is in 
the textbook: 
void dassical_elimination(Matrix& A, Vector& b) 
{ 
canst Index n = A.diml0; 
II traverse from 1 sl column to the next-to-Iast 
II fil ling zeros into all elements under the diagonal: 
for (Index j = 0; j<n- l ; ++j) ( 
) 
canst double pivot = A(j, j); 
jf (pivot == 0) throw Elim_fai lure(j); 
II fill zeros into each element under the diagonal of the ith row: 
for (Index i = j+l; i<n; ++i) ( 
) 
canst double mult = A(i, j) I rivot; 
Ali).slice(j) = scale_and_add(AljI.slice(j), - mull, A[i).slice(j)); 
b(i) -= mult • b(j); 
II make the corresponding ch.ltlge to b 

24 .6 
AN EXAMPLE : SOLVING LINEAR EQU ATIONS 
~nle "pivot" is the element that lies on the diagonal of the row we arc currently 
dealing with. It mUSt be nonzero because we need to divide by it; if it is zero we 
give up by throwing an exception: 
Vector back_substitution(const Matrix& A, const Vector& b) 
( 
) 
consllndex n = A.diml(); 
Vector x(n); 
for (Index i = n - 1; i >= 0; --i) { 
) 
double s = b(i)-doCproduct(A[i).slice(i+ 1 ),x.slice(i+ 1»; 
if (double m = A(i, i) 
x(i)=s / m; 
else 
throw Back_subsCfailure(i); 
relurn X; 
24.6.2 Pivoting 
We can avoid the divide·by·zero problem and also achieve a more robust solution 
by sorting the rows to get zeros and smaH values away from the diagonal. By 
"more robust" we mean less sensitive to rounding errors. However, the values 
change as we go along placing zeros under the diagonal, so we have to also reo 
order to get small values away from the diagonal as we go along (that is, we can't 
just reorder the matrix and then use the classical algOriliUll): 
void elim_wilh_partiaLpivoUMatrix& A, Veclor& b) 
( 
consllndex n = A.dim1 (); 
for (Index j = 0; j < n; Hj) { 
Index pivot_row = j; 
II look for a suitable pivot: 
for (Index k= j +1; k < n; ++k) 
if (abs(A(k, j» > abs(A(pivoUow, j»)) pivoC row = j; 
II swap the rows if we found a better pivot: 
if (pivouow != j) { 
A.swap_rows(j, pivot_row); 
sid: :swap(b(j), b(pivocrow»; 
) 
875 

876 
} 
CHAPTER 2 4 • NU MERI CS 
/I elimination: 
for (Index i=j + 1; i < n; ++i) ( 
consl double pivot = A(j, j); 
} 
if (pivol==O) error( tlean'l solve: pivot==O"); 
consl double mull = AO, j)/pivot; 
Alil.slice(j) = scale_and_add(A[jl.slice(j), -mull, A(i].slice(j»j 
b (i) -= mull · b(j); 
We usc swap_rowsO and scalc_and_multiplyO to make the code more conven-
tional and to save us from writing an explicit loop. 
24.6.3 Testing 
Obviously. we have to tCSt our code. Fonunately, there is a simple way to do that: 
void solvc_random_systemOndex nl 
{ 
} 
Matrix A = random_matrix(n); 
/I see §24.7 
Vector b = random_vector(n); 
cout« "A = "« A« endl; 
cout « 
lib = " « b « endl; 
try ( 
} 
Vector x = classical-&aussian_climination(A, b); 
coul « "classical elim solution is x = " «x« endl; 
Vector v = A .. X; 
coul «
" A· X = " «\I«endl; 
calch(consl e)(ceplion& e) ( 
cerr« e.whaIO« sid : :endl; 
} 
We can get to the catch clause in lhree ways: 
A bug in the code (but, being optimists, we don't think there are any) 
An input that trips up classical_elimination (we should have used 
elim_wilh_partial_pivot) 
Rounding errors 

24.7 
RAN DOM NUMBERS 
However, Ollr test is not as realistic as we'd like because gelluincly random matri-
ces m·c unlikely to c.'1USC problems ror classicaCeliminalion. 
To veriry our solution, we print out A -x, which had better equal b (or close 
cnough ror our purpose, given rounding errors). The likelihood or rounding er-
rors is the reason we didn't just do 
if (A· xl=b) error("subslilulion failed "); 
ikc.'1use floaling-point numbers arc juSt approximations to real numbers, we have 
to accept approximately correct answers. In general, using == and != on the re-
sult or a floating-point computation is best avoided: floating point is inherenuy an 
approximation. 
"l1le Malrix library doesn't define multiplication or a matrix with a vector, so 
we did Ulat ror ulls progrmn: 
Veclor operalor*(consl Malrix& m, consl Veclor& u) 
{ 
) 
conSllndex n = m.dim1 0j 
Veclor v(n ) j 
for (Index i = OJ i < nj Hi) v(i) = doCproducl(mli], u )j 
relurn V j 
Again, a simple Malrix operation did most of the work ror us. "n le Malrix output 
operations came rrom MalrixlO.h as described in §24.5.3. The random_malrixO 
and random_veciorO runctions arc simple lIses or random numbers (§24.7) and 
arc left as an exercise. Index is a Iypedef (§A. IS) ror ule index type used by the 
Malrix library. We brought it into scope with a using declaration: 
using Numeric lib: :Index j 
24.7 Random numbers 
Ir you ask people ror a random number, most say 7 or 17, so it has been sug-
gestcd that those arc the "most random" numbers. People essentially never give 
the answer O. Zero is seen to be such a nice rollnd number umt it is not perceived 
as '·random" and could thererore be deemed ule "least l-andom" number. From a 
mathcmatic-,I point or view ulis is uller nonsense: it is not an individual number 
ulat is random. What we often need, and what we often rerer to as random num-
bers, is a sequence or numbers Ulat conrorm to some distribution and where you 
cannot easily predict ule next number in the sequence given the previous OIles. 
877 

878 
( HAPTER 24 • NUME RI CS 
Such numbers arc most useful in testing (that's one way of generating a lot of test 
cases), in games (that is one way of making sure that the next nm of lhe game 
difTers from the previolls nm), and in simulations (we can make a simulated en-
tity behave in a "random" fashion within the limits of its parameters). 
As a pracLicaJ tool and a mathematical problem, random numbers reach a 
high degree of sophistication to matdl their rcal-world importance. Here, we will 
just touch the basics as needed for simple ('csling and simulation. In <cstdlib>, 
the standard library provides 
inl randO; 
RAND_MAX 
void srand(unsigned inl); 
II returns values in the range [O:RAND_MAXI 
II the largest value that randO can produce 
II seed the random number generator 
Repeated caJls of randO produce a pseudo-random sequence of ints unifonnly 
distributed in the range [0: RAND_MAXI. We call the sequence of values pseudo-
random because it is generated by a mathematical formula so that it repea LS itself 
after a while (i.e., it is predictable and nOI perfectly random). In particular, if we 
call randO repeatedly in a program , it will give the same sequence every time the 
program is run. lnat's extremely useful for debugging. When we want different 
sequences, we call srandO with different values. For each different argument to 
srandO, we get a different sequence from randO. 
For example, consider the function rando m_vecta rO that was used in §24.6.3. 
A call random_vectar(n) produces a Matrix<do uble,1> with n elemenLS with ran-
dom values in the range [O:n]: 
Vecta r randa m_vecta r(lndex n) 
( 
Vecto r v(n); 
fa r (Index i = 0; i < n; ++i) 
v(i) = 1.0 • n • randO I RAND_MAX; 
return v; 
) 
Note the usc of 1.0 to make sure that we usc floating-point arithmetic. It would 
be embarrassing if we had used integer division with RAND_MAX and always 
gOllen the value o. 
Getting an integer in a specific range, snch as [O: max), is harder. Most peo-
ple's first attempt looks like this : 
int val = randO%max; 

24.8 
T HE STA NDA RD M AT HEM ATI CA L FUNC TI ONS 
'nus used to be a really bad idea because this simply picks ofT the low-order biLS 
of the random number and those biLS are not properly randomized by many tra-
ditional random number generators. Today, it appears to be ben er on many sys-
tems, but for portable code, "hiden the random number calculation in a function: 
int rand_int(inl max) { return randO%max; } 
int randj nt(inl min, int max) (return randj nt(max- min)+min; ) 
'111at way, you can replace the defilution of rand_intO if you find a poor imple-
mcntation of rand(). For industrial-strength software or if you need a nonunifonn 
distribution, use one of the quality random number libraries that are widely 
available, such as Boost: :random. To gel an idea of the quality of your system's 
random number generator, do exercise 10. 
24.8 The standard mathematical functions 
11le standard mathematical functions (cos, sin, log, etc.) are provided by t.he 
standard library. 111eir declarations arc found in <cmath>. 
Standard mathematical functions 
abs(x) 
ceil(x) 
floor(x) 
sqrl(x) 
cos(x) 
sin(x) 
tan(x) 
acos(x) 
asin(x) 
atan(x) 
sinh(x) 
cosh(x) 
tanh(x) 
exp(x) 
log(x) 
logI0(x) 
absolute value 
smallest integer >= x 
largest integer <= x 
square root; x must be nonnegalive 
cosine 
sine 
tangent 
arccosine; result is nonnegative 
arcsine; result nearest to 0 returned 
arctangent 
hyperbolic sine 
hyperbolic cosine 
hyperbolic tangent 
base-e exponential 
natural logarithm, base--e; x must be positive 
base-! 0 logarithm 
879 

880 
CHAPTE R 24 • NUMERICS 
The standard mathematical functions are provided for types floal , double, long 
double, and complex (§24.9) arguments. If YOLI do floating-point computations, 
you'll fmd these functions useful. If you need more details, documentation is 
widely available; your online documentation would be a good place to start. 
If a standard malhemalic.."li function cannot produce a mathematically valid 
result, it sets the variable efrno. For example: 
e rrllO = 0; 
double 52 = sqrl(- l )i 
if (errno) (err « "something wenl wrong with something somewhere"; 
if (errno == EDOM) 
II domain error 
cerr « "sqrt() not defined for negative argument"; 
pow(very_largc,2)i 
II not a good idea 
if (errno==ERANGE) 
1/ range error 
(err « "paw(" «veryJarge«" ,2) too large for a double"; 
If you do serious mathematical computations you must check errno to ensure 
that it is still 0 arter you get your result. If not, something went wrong. Look at 
your manual or online documentation to sec which mathematical runctions can 
set ermo and which values they use ror errno. 
As indicated in the example, a nonzero errno simply means "Something 
went wrong." It is not uncommon ror rUllcuolls not in the standard library to set 
errno in case or error, so you have to look more carerully at the value or errno to 
get an idea or exactly what went wrong. If you ICSt CHno immcdiately arter a 
standard library runclion and ir you made sure that errno==O bcrorc calling it, 
you can rely on the values as we did with EDOM and ERANGE in the cxample. 
EDOM is set ror a domain error (i.e., a problem with the rcsult). ERANGE is sct 
ror a rangc error (i.e., a problcm with tlle argumcnts). 
Error handling based on errno is somcwhat primitive. h dates rrom the first 
(1975 vintage) C mathematical runcUons. 
24.9 Complex numbers 
Complex numbers arc widely used in scientific and engineering computations. 
We assume that if yOll need them, yOll will know about their mathematical prop' 
erties, so we'll JUSt show you how complex numbcrs are expressed in the ISO 
C++ standard library. You find the declaration or complex numbers and their as· 
sociated standard mathematic..1.l rUllcuons in <complex>: 
templale<class Scalar> class complex { 
/I a complex is a pair of scalar values, baSically a coordinate pair 
Scalar re, im; 

24 .9 
COMPLEX NUMBERS 
public: 
complex(const Scalar & r, const Scalar & i) :re(r), im(i) () 
complex(const Scalar & r) :re(r),im(Scalar ()) () 
complexO :re(Scalar ()}, im(Scalar ()) { } 
Scalar realO { return rej } 
/I real par! 
Scalar imagO { return im j } 
/I imaginary par! 
/I operators: = += -= ' = 1= 
}; 
'11C standard library complex is guaranteed to be supported for scalar types float, 
double, and long double. In addition to the members of complex and lhe standard 
mathematical functions (§24.8), <complex> offers a host of useful operations: 
Complex operators 
z1+z2 
z1-zl 
z"zl 
z1/z2 
z1==zl 
z1!=zl 
norm(z) 
conj(z} 
polar(x,y) 
real{z) 
imag(z) 
abs(z) 
arg(z) 
out « z 
in »z 
addition 
subtraction 
multiplication 
division 
equality 
inequality 
the square of abs(z) 
conjugate: if z is (re,im}, then coni(z) is (re,- im) 
make a complex given polar coordinates (rho,theta) 
real part 
imaginary part 
also known as rho 
also known as theta 
complex output 
complex input 
Note: complex docs not provide < or %. 
Use complex<T> exactly like a built·in lype, such as double. For example: 
typedef complex<double> dcmplx; 
/I sometimes complex<double> 
II gets verbose 
881 

882 
CHAPTER 24 • NUMERI CS 
void f(dcmplx z, veclor<dcmplo& vel 
{ 
) 
dcmplx z2 = pow(z,2); 
dcmplx %3 = 12*9.3+vc[3J; 
dcmplx sum = accumulate(vc.begin(), vc.end(), dcmplx()); 
1/ . .. 
Remember lhat nOt all opcralions that we are lIsed to from int and double arc 
defined for a complex. For example: 
if (z2<%3) II error: there is no < for complex numbers 
Note lhal the representation (layout) of lhc C++ standard libra.y complex num-
bers is compatible with their corresponding types in C and Fonran. 
24.10 References 
Basically, the issues discussed in this chapter, such as rounding errors, Matrix op-
erations, and complex arithmetic, are of no interest and make no sense in isola-
lion. We simply describe (some of) the support provided by C++ to people with 
the need and knowledge of mathematical concepts and techniques to do numen-
cal computations. 
In case you are a bit rusty in those areas or simply curious, we can recom-
mend some infollllation sources : 
TIle Macl'Utor History of Mathematics archive, Illlp:!/wWw-gap.dcs.sl-and.ac.ukJ 
- history 
A great link for anyone who likes math or simply needs to use math 
A great link for someone who would like to see the human side of math-
ematics; for example, who is the ouly major mathematician to win an 
Olympic medal? 
Famous mathematicians: biographies, accomplishments 
Curio 
Famous curves 
Famous problems 
Mathematical topics 
Algebra 
Analysis 
Numbers and number theory 

CHAPTER 24 DRILL 
Geomctry and topology 
Mathematical physics 
Malilemalical astronomy 
TIle histOlY of mathematics 
Freeman, T L., and Chris Phillips. Parallel Numerical Algonlll1l1.J. Prentice Hall, 
1992. 
Cullberg,J an. Mallu!IIwha - From tIle Birth of Number;. W. W. Norton, 1996. ISBN 
039304002X. One of the most el~ oya ble books on basic and useful malilemat-
ics. A (rare) math book that you can read for pleasure and also usc to look up 
specific topics, such as matrices. 
Knuth, Donald E. 'fill: Art of Olmpllter Programming, Volllllle 2: Scnimwldical Algo-
n·tJl/lI.J, TlJird &Iitioll. Addison-Wesley, 1998. ISBN: 0201896842. 
Stewart, C. W. Matri-.: AlgrmllmIJ, Volume I: BaJic Decompositi01IJ. SlAM, 1998. ISBN 
0898714141. 
Wood, Alistair. Ilitrot:lllctioll to Nummcal Alla/ysu. Addison-Wesley, 1999. ISBN 
020194291X . 
./ Drill 
I. Print the size of a char, a short, an int, a long. a float, a double, an int*. 
and a double (usc sizeof, not <limits» . 
2. Print out the size as reported by sizeof of Matrix<inl> a(10), Malrix<inl> 
b(10J, Matrix<double> c(10), Malrix<int,2> d(10,10), Matrix<int,3> e(10, 
10,10). 
3. Print alit the number of clemenLS of each of the Matrixes from 2. 
4. Write a program that takes ints from d n and outpuLS the sqrtO of each 
int, or "no square root" if sqrt(x) is illegal for some x (i.e., check your 
sqrlO rellirn values). 
5. Read ten floating-point values from input and put them into a Ma-
trix<double>. Matrix has no push_backO so be careful to handle an at-
tempt to enter a wrong number of doubles. Print out the Matrix. 
6. Compute a multiplication table for [O,n)*(O,m) and represent it as a 20 
Matrix. Take n and m from cin and print out the table nicely (assume 
that m is small enough lilat the results fit on a line). 
7. Read ten complex<double>s from cin (yes, cin supporLS » for complex) 
and put them into a Matrix. Calculate and output the sum of the ten COIll-
plex numbers. 
8. Read SLX ints into a Matrix<int,2> m(2,3) and print them out. 
883 

884 
CHA PTER 24 • NU MERI CS 
Review 
1. \OVho uses numerics? 
2. \.vhal is precision? 
3. What is ovcrnow? 
4. ,.vhat is a conunon size of a double? Of an int? 
5. How can you detect ovcrnow? 
6. Where do you rmd numeric limits, such as the largest int? 
7. VVhal is an array? A row? A column? 
8. What is a C-stylc multidimensional array? 
9. What arc the desirable properties of language support (e.g., a library) for 
matrix computation? 
10. What is a dimension of a matrix? 
11 . How many dimensions can a matrix have (in theoryfmath)? 
12. What is a slice? 
13. ''''hat is a broadcast operation? List a few. 
14. What is the difference between Foman-style and C-style subscripting? 
15. How do you apply an operation to each clement of a matrix? Give 
examples. 
16. VVhal is a fused operation? 
17. Define dol pnxJucl. 
18. What is linear algebra? 
19. \lVhat is Gaussian elimination? 
20. What is a pivot? (In linear algebra? In Mreallife"?) 
21. Whm makes a number random? 
22. \-Yhm is a uniform distribution? 
23. Where do you find the standard mathematical functions? For which ar-
gument types are they defined? 
24. What is the imaginary part of a complex number? 
25. What is the square root of - I? 
Terms 
array 
C 
column 
complex Humber 
dimension 
dot product 
elcment-\vise operation 
errno 
ForlTan 
fused operation 
lInagmary 
Matrix 
multidimensional 
randOIll number 
real 
row 
scaling 
'"" 
sizeof 
slicing 
subscripting 
uniform distribution 

CHAPTER 24 EXERCISES 
Exercises 
I. The function arguments r for a.apply(O and apply(f,a) arc differelli. 
Write a doubleO function for each and usc each to double the elements 
of an array { 1 2345 }. Define a single doubleO function that can be used 
for both a.apply(double) and apply(double,a). Explain why it could be a 
bad idea to write every function to be used by applyO that way. 
2. Do exercise I again, but with function objects, rather than functions. 
Hint: Matrix.h contains examples. 
3. Expert level only (tlus crumot be done with the facilities described in this 
book): Write an apply(f,a) tim can take a void (1&), a T (const T&), and 
their function object equivalents. Him: Boost: :bind. 
4. Get the Gaussian elinunation program to work; that is, complete it, get it 
to compile, and test it with a simple example. 
S. li)' the Gaussian elimination program with A=={ {O 1} {1 O} } and b=={ 5 
6 } and watch it fail. TIlcn, cry elim_with_partiatpivotO. 
6. In the Gaussian elimination example, replace the vector operations 
doCproductO and scale_and_addO with loops. Test, and comment on 
lhe clarity of the code. 
7. Rewrite the Gaussian elimination program without using the Matrix li-
brary; tlmt is, usc built-in arrays or vectors instead of Matrixes. 
8. Animate the Gaussian c1inunacion. 
9. Rewrite the nonmember applyO functions to return a Matrix of the reo 
turn type of the function applied; that is, apply(f,a) should return a 
Matrix<R> where R is the return type of f. Warning: The solUlion re· 
quires infonnation aboUl templates nOt available in tltis book. 
10. How random is your randO? Write a program that takes twO integers n 
an d as inputs and calls randint(n) d times, recording the result. Output 
the number of draws for each of [0: n) and "eyeball" how similar tile 
counts are. Try witll low values for n and with low values for d to sec if 
drawing only a few random numbers causes obvious biases. 
II . Write a swap_columns() to match swap_rowsO from §24.S.3. Obviously, 
to do that you have to read and understand some of the existing Matrix 
libral), code. Don't won)' too much about efficiency: it is not possible to 
gel swap_columnsO to run as fast as swap_rows(). 
12. Implement 
Matrix<double> operatorO(Matrix<double,2>&,Matrix<double>&); 
and 
Matrix<double,N> operator+(Matrix<double,N>&,Matrix<double,N>&) 
If you need to, look up the matllematical definitions in a textbook. 
885 

886 
CHAPTER 24 • NUMERICS 
Postscript 
If you don't feci comfonable with mathematics, you probably didn't like this 
chapter and you'll probably choose a field of work where you arc unlikely to 
need the infonnation presented here. On the other hand, if you do like mathe-
matics, we hope that you appreciate how closely the fundamental concepLS of 
mathematics can be represented in code. 

, t 
, 
' 
,.. 25 
Embedded Systems 
Programming 
" 'Unsafe' means 'Somebody may die.' " 
-Safety officer 
W
e present a view of embedded systems programming; 
that is, we discuss topics primarily related to writing pro-
grams for "gadgets" that do not look Like conventional computers 
with screens and keyboards. We focus on the principles, program-
ming techniques, language facilities, and coding standards needed 
to work "close to the hardware." The main language issues ad-
dressed are resource management, memory management, pointer 
and array use, and bit manipulation. The emphasis is on safe use 
and on alternatives to the use of the lowest-level features. We do 
not attempt to presclll specialized machine architectures or direct 
access to hardware devices; that is what specialized literature and 
manuals are for. As an example, we present the implementation of 
an encryption/decryption algorithm. 
887 

888 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
25. 1 Embedded syste ms 
25.5 Bits, bytes, and wo rds 
25.2 Basic concepts 
25.2.1 Predictability 
25.2.2 Ideals 
25.2.3 living with failure 
25.3 Memo ry ma nageme nt 
25.3.1 Free·store problems 
25.3.2 Alternatives to general free store 
25.3.3 Pool example 
25.3.4 Stack example 
25.4 Addresses, po inte rs, and a rrays 
25.4.1 Unchecked conversions 
25.4.2 A problem: dysfunctional 
interfaces 
25.4.3 A solution: an interface class 
25.4.4 Inheritance and containers 
25.1 Embedded systems 
25.5.1 8ils and bit operations 
25.5.2 bitsel 
25.5.3 Signed and unsigned 
25.5.4 8it manipulation 
25.5.5 8itfields 
25.5.6 An elample: simple encryption 
25.6 Coding sta ndards 
25.6.t What should a coding standard 
b,l 
25.6.2 Sample rules 
25.6.3 Real coding standards 
Most computers in thc world arc not immediately recognizable as computers. 
l 11ey arc simply a part of a larger system or "gadget." For example: 
Ctm: A modern car may have many dozens of computers, controlling the 
fuel injection, monitoring engine performance, adjusting lhe radio, can· 
troning the brakes, watching for underinflated tires, controlling the wind· 
shield wipers, etc. 
'felepflO1U!S: A mobile telephone contains at least two computers; typic. ... lIy 
one of those is specialized for signal processing. 
AirplmU!S: A modern airplane contains computers for everything from 
n mning the passenger entertainment system to wiggling the wing tips for 
optimal flight properties. 
WlllffllS: In.ere arc cameras with five processors and for which each lens 
even has its own separate processor. 
CmJiI mrds (of the "smart c. ... rd" variety) 
Me(Jicol equij)lIIn11 monitors and rontrotlus (e.g., CAT scanners) 
EWltOrJ (lifts) 
PDAs (Personal Digital Assistant) 
Prinler COli/rollers 
Sowul ~JIt:IIIJ 
MP3pla)"m 

25. 1 
EMBEDDED SYSTEMS 
Kitc/u:I/ a/J/Jlimu:n (such as rice cookers and bread machines) 
Telephont: slIJitc/leJ (typically consisting of thousands of speciali7.cd computers) 
Pump (J)1I/rollm (for water pumps and oil pumps, etc.) 
H'i!klillg robolS: some for usc in light or dangerous places where a human 
welder cannot go 
W/I/d tUTb,iU:J: some capable of generating megawalts of power and 70m 
(210ft) tall 
$ea-W{/II gate (ollirollm 
A.uelllbly t-lil/~ qua/if)t lIIoni/oTJ 
&,r (Ode TeadeTJ 
OIT awmbly robotJ 
CeIIlrjjilgt (OlIlro/1en (as used in many medical analysis proccsses) 
Dllk-lbive col/fro/1m 
These computers arc parts of larger systems. Such '"'large systems" usually don't 
look like computers and we don't usually think of them as computers. W'hen we 
see a car coming down the street, we don't say, "Look, there's a distributed COIll-
puter system!" V·lell , the CM is aM a distributed computer system, but its opera-
tion is so integrated with the mechanical, electronic, and electrical parts that we 
can't really consider the computcrs in isolation. -The constraints on their compu-
tations (in lime and space) and the very definition of program correctness cannot 
be separated from the larger system. Often, an embedded computer controls a 
physical device, and the correct behavior of the computer is defined as the COf-
rect oper.ltion of the physic-'ll device. Consider a large marine diesel engine: 
889 

890 
(HAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
Note the man at the head of cylinder number 5. TIus is a big engine, the kind of 
engine that powers the largest ships. If an engine like this fails, you'll rcad about 
it on the fronl page of your morning newspaper. On this engine, a cylinder COIl-
trol system, consisting of three computers, sits on each cylinder head. Each cylin-
der camral system is cOllnected to the engillc camral system (another three 
computers) through twO independent networks. '11C engine control system is 
then conncClcd to the comrol room where the machine engineers can communi-
cate with it through a specialized G U I system. 111c complete system can also be 
remotely monitored via radio (through satellites) from a shipping-line control 
center. For morc examples, see Chapter 1. 
So, from a programmer's point of view, what's special about the programs nm· 
!ling in the computers that are parts of mat cnginc? More generally, what are ex· 
amples of concc01S that become prorninent for various kinds of embedded systems 
that we don't typically have to worry too much about for "ordinary programs"? 
Often, rtlwbility is critical: Failure can be spectacular, expensive (as in "bil· 
lions of dollars"), and potentially lethal (for the people on board a wreck 
or the animals in its enviromnent). 
Often, m OIlTUJ (II/emory, proaSJ()r 9de5, jxJwn") are limited: "111at's not likely 
to be a problem on the engine computer, but think of cell phones, sen· 
sors, PDAs, computers on board space probes, etc. In a world where 
dual·processor 2G Hz laptops with 2G B of memory are common. a criti· 
cal computer in an airplane or a space probe may have JUSt 60M Hz and 
256KB, and a small gadget just sub· I M Hz and a few hundred words of 
RAM. Computers made resilient to environmental hazards (vibration, 
bumps, unstable electricity supplies, heat, cold, humidity, workers step· 
ping on them, etc.) arc typically far slower than what powers a student's 
laptop. 
Often, real-lime mjx»1.Se is eJJeIllial: If the fuel injector misses an injection 
cycle, bad things can happen to a very complex system generating 
100,000Hp; IlUSS a few cycles - that is, fail to function con-ectly for a sec· 
ond or so - and strange things can start happening to propellers mat can 
be up to 33ft (10m) in diameter and weigh up to 130 tons. You really 
don't want that to happen. 
Often, (ll)'stemIllUJljinu:tiQTI IlI/interruptedJor yam: Maybe the system is nm· 
ning in a communications satellite orbiting the earth, or maybe the sys· 
tem is just so cheap and exists in so many copies that any significant 
repair rate would ruin its maker (think of MP3 players, credit cards with 
embedded chips, and automobile fuel il~ectors ). In the United States, the 
mandated reliability criterion for backbone telephone switches is 20 min· 
utes of downtime in 20 years (don't even think of taking such a switch 
down each time you want to change its program). 

25 2 
BASIC CONCEPTS 
Often, lUll/tis-on mllilllerulllct is iTyeasible {Jr Ut'IJ' ran:: You can take a large ship 
into a harbor to service the computers every second year or so when 
other parts of the ship require service and the necessary computer spe-
cialists arc available in the right place at the right time. Unscheduled, 
hands-on maintenance is infeasible (no bugs are allowed while the ship is 
in a m;yor storm in the middle of the Pacific). You simply can't send 
someone to repair a space probe in orbit around Mars. 
Few systems suffer aU of these constrai.nts, and any system that suffers evell one is 
the domain of experts. QUI' aim is not to make you an ;'instant cxpert
n
; attempting 
to do that would be quite silly and very irresponsible. Our aim is to acquaint you 
with the basic problems and the basic concepts involved in their sollllion so that 
you can appreciate some of the skills needed to build such systems. Maybe you 
could become interested in acquiring such valuable skills. People who design and 
implement embedded systems arc critical to many aspects of our technological 
civilization. lois is an arca where a professional can do a 1m of gcxxi. 
Is this relevant to novices? To C++ programmers? Yes and yes. TIlere are 
many more embedded systems processors than there are convemional PCs. A 
huge fraction of programming jobs relate to embedded systems programming, so 
yOllr first real job may involve embedded systems programming. Furthermore, 
the list of examples of embedded systems tbat started this section is drawn from 
what I bave personally seen done using C++. 
25.2 Basic concepts 
Much programming of computers that arc parts of an embedded system can be 
just like Olher programming, so most of the ideas presemed in this book apply. 
However, the emphasis is often different : we must adjust our usc of program-
ming language facilities to the constraints of the task, and often we must manipu-
late our hardware at the lowest level: 
CoTT«lnru: 111is is even more important than usual. "Correctness
n is not 
just an abstract concept. In the contc.xt of an embedded system, what it 
means for a program to be correct becomes not just a question of pro-
ducing the correCl results, bUl also producing them at the right time, in 
the right order, and using only an acceptable set of resources. Ideally, the 
details of what constitutes correctness are carefully specified, but often 
such a specification ca.n be completed only after some experimentation. 
Often, critical experiments C .. 1Jl be performed only after the complete sys-
tem (of which the computer running the program is a part) has been 
built. Completely specifying correctness for ail embedded system can at 
the same time be extremely difficult and extremely important. Here, "ex-
lremel), difficult" can mean "impossible given the time and resources 
891 

.'2 
CHA PTER 25 • EMBEDDED SYSTEMS PROGRAMM ING 
available"; we must try Ollr best using all available tools and techniques. 
Fortunately, the range of specification, simulation, testing, and other 
techniques in a given area can be quite impressive. Here, "extremely im-
portant" can mean "failure leads to injury or ruin." 
Fillllt tolerance: We must be careful to specify the set of conditions that a 
program is supposed to handle. For example, for an ordinary student 
program, you might find it unfair if we kicked lhe cord out of the power 
supply during a demonstration. Losing power is not among the condi-
tions an ordinary PC application is supposed to deal with. However, los-
ing power is not uncommon for embedded systems, and some arc 
expected to deal with that. For example, a critical part of a system may 
have dual power sources, backup batteries, etc. Worse, "But I assumed 
that the hardware worked correctly" is no excuse for some applications. 
Over a long time and over a large range of conditions, hardware simply 
doesn't work con'ectly. For example, some telephone switchcs and some 
aerospace applications are written based on the assumption that sooner 
or later some bit in the computer's memory will juSt "decide" to change 
ilS value (e.g., from 0 to I). Ahematively, itlllay "decide" that it likes the 
value I and ignore attemplS to change that 1 to a O. Such erroneous be-
havior happens evelHually if you have enough melllory and usc it for a 
long enough time. It happens sooner if you expose the memory to hard 
radiation, such as you find beyond the earth's atmosphere. When we 
work on a system (embedded or not), we have to decide what kind of 
tolerance to hardware failure we must provide. The usual default is to as-
sume that hardware works as specified. As we deal with more critical 
systems, that assumption must be modified. 
No duwlllime: Embedded systems typically have to nm for a long time 
witham changes to the software or intervention by a skilled operator 
with knowledge of the implementation. "A long time" can be days, 
months, years, or tJle lifetime of the hardware. 1l1is is not unique for elll-
bedded systems, but it is a difference from the vast majority of "ordinary 
applications" and from all examples and exercises in this book (so far). 
This "must run fOl'ever" requirement implies an emphasis on error h.m-
dling and resource management. What is a "resource"? A l'esonrce is 
something of which a machine has only a limited supply; from a pro-
gram you acquire a resource through some explicit action ("acquire the 
resource," "allocate") and return it ("release," "free," "deallocate") LO the 
system explicitly or implicitly. Examples of resources are melllory. file 
handles, network connections (sockets), and locks. A progrdm that is 
part of a long·nmning system must release every resource it requires ex-
cept a few that it permanently owns. For example, a program that forgelS 

25.2 
BASIC CONCEPTS 
to c10sc a filc cvery day will on most operating systcms not survive for 
marc than about a momh. A program that fails to deallocate lOO bytes 
every day will waste morc than 32K a year - that's enough to crash a 
small gadget after a fcw momhs. ~nl C nasty thing about such resource 
'"leaks" is that thc program will work perfectly for months before it sud-
denly ceases to function. If a program will crash, wc prcfer it to crash as 
soon as possible so that we yOm remedy the problem. In particular, we 
prefer it to crash long before it is given to users. 
Rcal-hine (Dluiraillls: \Ve can classify an embedded system as hard real lime 
if a ccrtain response must occur before a deadline. If a response muSt 
occur beforc a deadline most of the time, but we can afford an occasional 
time ovelTun, we classify the system as .frji rrallime. Examples of soft real 
time arc a controller for a car window and a stereo amplifier. A human 
will not notice a fraction of a second's delay in the movement of the win-
dow, and only a trained listener would be able to hear a millisecond's 
delay in a cbange of pitch. An example of hard real time is a fuel injector 
that has to "squirt" at exactly the right time relative to tlle movement of 
the piston. If tlle timing is off by even a fraction of a millisecond, per-
formancc suffers and the engine starts to deteriorate; a major timing 
problem could completely stOp the engine, possibly leading to accident 
or disaster. 
Prediclahl1ily: ' 1us is a key notion in embedded systems code. Obviously, 
the term has many intuitive meanings, but here - in the context of pro-
gramnung embedded systems - we will use a specialized technical mean-
ing: an operation is predictable if it takes the same amount of time to 
execute every time it is executed on a given computer, and if all such op-
erations take the same amount of tillle to execute. For exmnple, when x 
and y are integers, x+y takes the same amount of time to execute every 
time and xx+yy takes the same amount of time when xx and yy arc twO 
other integers. Usually, we can ignore minor variations in execution 
speed related to machine architecture (e.g., differences caused by caching 
and pipelining) and simply rely on there being a flXed, constant upper 
limit 011 the time needed_ Operations that arc not predicl<lble (in this 
sense of the word) can't bc used in hard rcal·time systems and must bc 
L1scd with great carc in all real-time systems. A classical examplc of an 
unpredictable operation is a linear search of a list (e.g., find O) where the 
number of elements is unknown and not easily bounded. Only if we can 
reliably predict the number of elements or alleast the maximulll number 
of elements docs SUcll a search become acceptable in a hard real-time sys-
tem; that is, to guaralltee a response within a given fixed time we must be 
able to - possibly aided by code analysis tools - calculate the time 
needed for every possible code sequence leading up to the deadline. 
893 

.94 
CHAPTER 25 • EMBEDDED SYSTE MS PROGRAMMING 
OmCUTTfmq: An embedded system typically has to respond to events from 
the CXlcmaJ world. This lcads to programs where many things happen 
"at oncc" because they correspond to real events that really happen at 
once. A program that simultaneously deals with several actions is called 
(oncurreTll or /Jamllel. Unfortunately the fascinating, difficult, and impor-
tant issue of concurrency is beyond lhe scope of this book. 
25.2.1 Predictability 
From the point of view of predictability, C++ is pretty good, but it isn't perfect. 
All facilities in the C++ language (including virtual function calls) arc pre-
dictable, except 
Free-store allocation using new and delete (see §25.3) 
Exccplions (§19.5) 
dynamic_cast (§A.5.7) 
-n tCSe facilities must be avoided for hard real-time applications. 111e problems 
with new and delete are described in detail in §25.3 ; those arc fundamental. 
Note that the standard library Siring and the standard containers (yector, map, 
etc.) indirectly use free store, so they are not predictable either. "111e problem Witll 
dynamic_cast is a problem Witll current implementations but is not fundamental. 
The problem with exceptions is that when looking at a particular throw, the 
programmcr cannot - without looking at large sections of code - know how 
long it will take to find a matching catch or even if there is such a catch. In an 
embedded systems prohrram, there had better be a catch because we can't rely on 
a C++ programmer sitting ready to use the debugger. The problems with excep· 
tions can in principle be dealt with by a tool that for eaell throw tells YOli exaClly 
which catch will be invoked and how long it will take the throw to get therc, but 
currently, that's a research problem, so if you need predictability, you'll have to 
make do with error handling based on return codes and olher old· fashioned and 
tedious, but predictable, techniques. 
25.2.2 Ideals 
When writing an embedded systems program there is a danger tllat the quest for 
performance and reliability will lead the programmer to regress to exclusively 
using low·level language facilities. 111at strategy is workable for individual small 
pieces of code. However, it can easily leave the overall design a mess, make it dif· 
ficult to be confident about correctness, and increase the time and money needed 
to build a system. 
As ever, our ideal is to work at the highest level of abstraction that is feasible 
given the constraints on Ollr problem. Don't get reduccd to writing glorified as-
sembler code! As ever, represent your ideas as directly in code as YOll can (given 

25.2 
BASIC CONCEPTS 
all constraints}. As ever, try hard to write the clearest, cleanest, most maintainable 
code. Don't optimize until you have to. Performance (in time or space) is often es-
semial for an embedded system, but trying to squeeze performance out of cvery 
little piece of code is misguided. Also, for many embedded systems the key is t"O 
be con ca and fast enough; beyond "fast enough" the system simply idles until an-
other action is needed. Trying to write every few lines of code to be as efficient as 
possible takes a lot of time, causes a lot of bugs, and often leads to missed oppor-
OIllilies for optimiza.tion as algorithms and data structures get hard to underst.a..nd 
and hard to change. For example, that "low-level optimization" approach often 
leads to missed opportunities for memory optimization because almost similar 
code appears in many places and can't be shared because of incidental differences. 
J ohn Bentley - famous for his highly efficient code - offers two "laws of 
optimization": 
First law: Don't do it. 
Second law (for experts only): Don't do it yet. 
Before optimizing, make sure that you understand the system. Only then can you 
be confident that it is - or can become - correct and reliable. Focus on algo-
rithms and data structures. Once an early version of the system runs, carefully 
measure and tunc it as needed. Fonunately, pleasant surprises are not uncom-
mon: clean code sometimes runs fast enough and doesn't take up excessive mem-
ory space. Don't count on that, though; measure. Unpleasant surprises arc not 
uncommon either. 
25.2.3 Living with failure 
Imagine that we arc to design and implement a system that may not fail. By "not 
fail" let's say that we mean "will run without human intervention for a month." 
What kind of failures must we protect against? We can exclude dealing with the 
sun going nova and probably also with the system being trampled by an ele-
phant. However, in general we cannot know what might go wrong. For a specific 
system, we can and must make assumptions about what kinds of errors arc Illore 
common than others. Examples: 
Power surges/failure 
ConnectOr vibrating out of its sockct 
System hit by falling debris crushing a processor 
Falling system (disk might be destroyed by impact) 
X-rays ".using some memory bits to change value in ways impossible ac-
cording to the language definition 
Transient errors arc usually the hardest to find. A tmnsient nror is one that hap-
pens "sometimes" but not every time a program is run. For example, we have 
.. , 

.96 
CHAPTE R 25 • EMB EDDED SYSTEMS PROGRAMMING 
heard of a processor that misbehaved only when the tempcraUlre exceeded 
130°F (54°C). It was never supposed to gel that hot; however, it did when the 
system was (unintentionally and occasionally) covered up on the factory floor, 
never in the lab while being tested. 
Errors that occur away from the lab arc the hardest to fix. You will have a 
hard lime imagining the design and implementation effort involved in lcning the 
JPL engineers diagnose software and hardware failures on the Mars Rovers 
(twenty mjnutcs away from lhe lab for a signal traveling at the speed of light) and 
update the software to fIx a problem once understood. 
Domain knowledge - that is, knowledge about a system, its environment, 
and its lISC - is essential ror designing and implementing a system with a good re-
silience against errors_ Here, we will touch only upon generalities_ Note that 
every "generality" we mention here has been the subject or thousands or papers 
and decades or research and development. 
PrnxlIl reroum leaks: Don't leak. Be specific about what resources your 
program uses and be sure you conserve them (perrectly). Any leak will 
kill your system or subsystem eventually. 111e most rundamental re-
sources are time and memory. Typically, a program will also lise other 
resources, such as locks, communication channels, and files. 
Replicate: If a system critically needs a hardware resource (e.g., a COIll-
puter, an Output device, a wheel) to runcLion, then the designer is raced 
with a basic choice: should the system cOIll.-un several copies or the criti-
cal resource? We can either accept railure ir the hardware breaks or pro-
vide a spare and let the sortware switch to using the spare. For example, 
the ruel injector controllers for the marine diesel engine are triplicated 
computers cOillecled by duplicate networks. Note that "the spare" need 
not be identical to the original (e.g., a space probe may have a primary 
strong antenna and a weaker backup). Note also that "the spare" can 
typically be used to boost perrormance when the system works withom 
a problem. 
Seffcheck: Know when the program (or hardware) is misbehaving. Hard-
ware component's (e.g_, storage devices) can be very helpful in this re-
spect, monitoring themselves ror errors, correcting minor errors, and 
reporting major railures. Software can check ror consistency of its data 
structures, check invariants (§9.4.3), and rely on intemal "sanity checks" 
(assertions). Unfortunately, self-checking can itselr be unreliable, and 
care must be taken that repolling an error docsn't itselr cause an error -
it is really hard to completely check error checking. 
Have a quick way oul o/misbelwuillgCOt.Ie: Make systems modular. Base error 
handling on modules: each module has a specific task to do. If a module 
decides it can't do its task, it can rcport that to some ot.her module. Keep 
the error handling within a module simple {so thal il is 1110re likely lO be 

25.3 
MEMORY MANAG EME NT 
correct and efficient), and have some other module responsible for seri-
ous errors. A good reliable syStem is modular and multi-level. At each 
level, serious errors arc reponed to a module at the next level - in the 
end, maybe to a person. A module that has been notified of a serious 
error (aile that another module couldn't handle itself) can then take ap' 
propriate action - maybe involving a restart of the module that detected 
the error or running with a less sophisticated (but more robust) 
hbackup" module. Defining exactly what "a module" is for a given sys-
lem is part of the overall system design, but you can think of it as a class, 
a library, a program, or all the programs on a computer. 
Monitor Jllbs}JlmlJ in case they can't or don't notice a problem themselves. 
In a multi-level system higher levels can monitor lower levels. Many sys-
tems that really aren't allowed to fail (e.g., the marine engines or space 
station controllers) have three copies of critical subsystems. llus triplica-
tion is not done juSt to have two spares, but also so that disagreements 
about which subsystem is misbehaving can be settled by 2-l0-1 votes. 
Triplication is especially useful where a multi-level organization is diffi· 
cult (i.e., at thc highest level of a system 01' subsystem that may not fail). 
\oVe can design as much as we like and be as careful with the implementation as 
we know how to, but the system will still misbehave. Before delivering a system 
to users, it must be systematically and thoroughly tested; see Chapter 26. 
25.3 Memory management 
"Ille twO most fundamental resources in a computer arc time (to execute instruc-
tions) and space (memory to hold data ancl code). In C++, there arc three ways 
to allocate memOly to hold data (§17.4, §A.4.2): 
Slatic memory: allocated by the linker and persists as long as the program 
runs 
SIIlCR (automatic) memory: allocated when we c.,11 a function and freed when 
we rerurn from the function 
Dpl(lmic (he(lp) mallory: allocated by new and freed for possible reuse by 
delete 
Let's consider these from the perspective of embedded systems programming. In 
particular. we will consider memory management from the perspective of tasks 
where predictability (§25.2.1) is considered essential, such as hard real·time pro--
granuning and safety·critical programming. 
Static memory poses no special problem in embedded systems program-
ming: all is taken care of before the program starts to nm and long before a sys· 
tem is deployed. 
897 

898 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
Stack memory can be a problem because it is possible LO usc too much of it, 
but this is not hard to take care of. "111C designers of a system must dCtenllinc thal 
for no execution of the program will the stack grow over an acceptable limit. TIUs 
usually means that the maximum nesting of function calls must be limited; that is, 
we must be able to demonstrate that a chain of calls (e.g., f1 calls f2 calls ... calls fn) 
will never be too long. In some systems, lhat has caused a ban on recursive calls. 
Such a ban can be rc.uonable for some systems and for some recursive functions, 
but it is not fundamental. For example, I kn/YW mat factorial(10) will call factorial at 
most ten rimes. However, an embedded systems progranUTIcr might very well pre-
fer an iterative implementation of factorial (§ IS.5) to avoid any doubt or accidelll. 
Dynamic memory allocation is usually banned or severely restricted; that is, 
new is either banned or its use restricted lO a startup period, and delete is 
banned. The basic reasons are 
Prediclllbilily: Free-store allocation is not predictable; that is, it is not guar-
anteed to be a constant time operation. Usually, it is not: in many imple-
mentations or new, the time needed to allocate a new object can increase 
dramatically after many objects have been allocated and deallocated. 
Fragme71laliQtl: 111e rree store may rragment; that is, arter allocating and 
deallocating objects the remaining unused memory may be "rrag-
mented" into a lot or little "holes'" or unused space that arc useless be· 
cause each hole is too small to hold an object or the kind used by the 
application. Thus, the size or userul rree store can be rar less than the size 
or the initial rree store minLis the size or the allocated objects. 
The next section explains how this unacceptable state or affairs can arise. 111e 
bottom line is that we must avoid programming techniques that lise both new 
and delete ror hard real-tilllC or sarety-critical systems. The rollowing sections ex-
plain how we can systematically avoid problems with the rree store lIsing stacks 
and pools. 
25.3.1 Free-store problems 
\¥hat's the problem with new? Well, really it's a problem with new and delete 
used together. Consider the resuit or this sequence or allocations and deallocaliOTlS: 
Message· geU npuI(Device&)i 
whileV· ... ·/) ( 
Message p = geUnput(dev)i 
1/ . .. 
1/ make a Message on the free store 
Node· nl = new Node(argl ,a rg2); 
/I . 

25 .3 
MEMORY MAN AGEMEN T 
delete p; 
Node- n2 = new Node (arg3,arg4); 
1/ . .. 
Ench time around the loop we creme twO Nodes, nnd in the process of doing so 
we create a Message and delete it again. Such code would not be unusual as pan 
of building a data structure based on input from some "device." Looking at this 
code, we might expect to "consume" 2"sizeof(Node) bytes of Illemory (plus free-
store overhead) each time around the loop. Unfortunately, it is not guaranteed 
that the "consumption" of memory is restricted to the expected and desired 
2"sizeo(Nodc) bytes. In fact, it is unlikely to be the case. 
Assume a simple (though not unrealistic) memory manager. Assume also 
that a Message is a bit larger than a Node. We can visualize the use of free space 
like this, using orange for the Message, green for the Nodes, and plain while for 
"a hole" (that is, "unused space"): 
After creating n1 (one Message and aile Node) 
Arter deleting p (one "hole" and aile Node) 
I I 
After creating n2 (two Nodes and a small "hole") 
II 1. -1 
After creating n1 the 2nd lime through the loop 
II I II 
After CI'eating n2 the 2nd time through the loop 
,--'.1 
~1_-,--,IL1I_J......II-,-I-,1 After creating n2 the 3rd time through thc loop 
So, we are leaving behind some unused space ("a hole") on the free store each 
lime we execute the loop. That may be just a few bytes, but if we can't lise those 
holes it will be as bad as a memory leak - and even a small leak will eventllally 
kill a long-nmning program_ Having the free space in our memory scattered in 
many "holes" too small for allocating new objects is called 1IIe7/lOly.!ragmelllal;m/. 
Basically, the free-store manager will eventually use up all "holcs" that arc big 
enough to hold the kind of objects that the program uses, leaving only holes that 
are too small to be useful. T his is a serious problem for esselllially all long-run-
ning programs that usc new and delete extensively; it is not uncommon to find 
unusable fragments taking up most of the memory. That usually dramatically 
899 

( HAPTER 2S • EMBEDDED SYSTEMS PROGRAMMING 
increases the time needed to execllle new as it has to search through lots of ob-
jects and fragments for a suitably sized chunk of memory. Clearly this is not the 
kind of behavior we can accept for an embedded system. This can also be a seri-
ous problem in naively designed nOIl'Cmhedded systems. 
Why can't "the language" or "the system" deal with this? Alternatively, can't 
we just write our program to not create such "holes"? Let's first cxamine the 
most obvious solution to having aJl thosc little useless "holcs" in oLir mcmory: 
let's move the Nodes so that all the frec space gets compacted into one contigu-
ous area that we can use to allocate more objects. 
Unfortunately, "the system" can't do that. TIle reason is that C++ code 
refers direct..ly to objects in memory. For example, the poimers n1 and n2 contain 
real memory addresses. If we moved the objects pointed to, those addresses 
would no longer point to the right objects. AssUlllc limt we (somewhere) keep 
pointers to the nodes we creaLCd. ,.ve could rcpresent the relevant part of our 
data sll"Ucture likc this: 
111111 
I I I I I I I I 
Nodes with pointers to nodes 
Now we compact memory by moving an object so that alllile unused memory is 
in one place: 
Unfortunately, we now have made a mess of those pointers by moving the ob· 
jects they pointed to without updating the pointers. ,,y-hy don't we just update 
lile pointers when we move the objects? We could write a program to do that, but 
only if wc knew the details of the data structurc. In general, "the system" (lile 
C++ run-time suppOrt system) has no idea where the pointers arc; that is, givcn 
an object, the question "Which pointers in the progntm point to this object right 
now?" has no good answer. Even if that problem could be easily solved, this ap-
proach (known as compacting garbage co/ke/ion) is not always the right one. For ex-
ample, to work. well, it typically requires more than twice the memOly that the 
program ever needs to be able to keep track of pointers and to move objects 
around in. That extra memory may not be available on an cmbedded system. In 
addition, an efficient compacting garbage collcctor is hard to make predictable. 
We could of course answer that "Where are the pointcrs?" question for our 
own data structures and compact those. 111at would work, but a simpler ap-

25.3 
MEMORY MANAGEMENT 
proach is to avoid fragmemation in the first place. In the example he.re, we could 
simply have allocatcd bOlh Nodes before allocating the message: 
while( . . . ) ( 
Node· nl = new Node; 
Node· n2 = new Node; 
Message" p = geUnpul(dev); 
II . .. store ini()(mation in nodes ... 
delete p; 
II . 
However, rearranging code to avoid fragmentation isn't easy in general. Doing so 
reliably is at best very difficult and often incompatible with other rules for good 
code. Consequently, we prefer to restrict the usc of free store to ways that don't 
cause fragmemation in the first place. Often, preveilling a problem is better than 
solving it. 
TRY THI S 
Complete the program above and print out the addresses and sizes of the ob-
jects created to sec: if and how "holes" appear on your machine. If you have 
time, you might draw memory layouts like the ones above to better visualize 
what's going all. 
25.3.2 Alternatives to general free store 
So, we mustn't cause fragmentation. What do we do then? TIIC first simple ob-
selvation is that new cannOt by itself cause fragmelllalion; it needs delete to crc-
atc the holes. So we start by banning delete. TIlat implies that once an object is 
allocated, it will stay part of the program forever. 
In the absence of delete, is new predictable; that is, do all new operations 
take the same amount of time? Yes, in all common implementations, but it is not 
actually guaranteed by the standard. Usually, an embedded system has a startup 
sequence of code that establishes tlle system as "ready to run" after initial power· 
up or restart. During that period, we can allocate memory any way we like lip to 
an allowed maximum. We could decide to usc new during Startup. Altcmativcly 
(or additionally) we could set aside global (static) memory for future usc. For rea-
sons of program structure, global data is often best avoided, but it can be sensible 
to lise that language mechanism to pre-allocate memory. ~Ine exact rules for lhis 
should be laid down in a coding standard for a system (sec §25.6). 
90' 

902 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
111crc arc twO data structures that arc particularly useful for predictable 
memory allocation: 
Slacks: A stack is a data SlnlClurC where you can allocate an arbitrary 
amount of memory (up to a given maximum size) and deallocate the last 
allocation (only); that is. a stack can grow and shrink only at the top. 
There can be no fragmentation, because there can be no "hole" between 
two allocations. 
1txJ/s: A pool is a collection of objects of the same size. We can "lIoc<uc 
and dcalloc.llc objects as long as we don't allocate morc objects than lhe 
pool can hold. "Inere can be no fragmentation because all objects arc of 
the same size. 
For both slacks and pools, both allocation and dcallocation arc predictable and fast. 
So, for a hard real-lime or critical system we can define stacks and pools as 
needed. Iklter yet, we ought to be able to use stacks and pools as specified, imple· 
mented, and tested by someone clse (as long as the specification meets our needs). 
Note that the C++ standard containers (vector, map. etc.) and the standard 
Siring arc not to be used because they indirectly usc new. You can build (buy or 
borrow) "standard·like" containers to be predictable, but the default ones that 
come with your implementation are not constrained for embedded systems usc. 
Note thal embedded systems typically have very stringent reliability require· 
ments, so whatever solution we choose, we must make sure not to compromise 
Ollr programming style by regressing into using lots oflow·levcl facilities directly. 
Code that is full of pointers, explicit conversions, etc. is unreasonably hard to 
guarantee as correct. 
25.3.3 Pool example 
A pool is a data structure from which we can allocate objects of a given type and 
later deallocate (free) such objects. A pool contains a maximum number of ob-
jects: that number is specified when the pool is created. Using green for "allo-
cated object" and blue for "space ready for allocation as an object," we can 
visualize a pool like this: 
A Pool can be defined like this: 
lemplate<class T, int N>class Pool { 
/I Pool of N objects of type T 
public: 
PaolO; 
P gelO; 
void free (P ); 
int availableO canst; 
/I make pool of N Ts 
/I get il T from the pool; return 0 if no free Ts 
/I return a T given out by getO to the pool 
/I number of (ree Ts 

25. 3 
MEMORY MANAGEMENT 
private: 
/I space for TINI and data to keep track of which Ts are allocated 
/I and which are not (e.g .• a list of free objects) 
) ; 
Each Pool object has a type of elements and a maximum number of objects. We 
can use a Pool like this: 
PookSmall_buffer, 10> sb_pooli 
PookSlal us j nd icator,200> i nd kalor _pool; 
Small_buffer* p = sb_pool.geIO; 
1/ . . . 
sb_pooUree(p)i 
It is the job of the programmer to make sure that a pool is never exhausted. TIle 
exact meaning of "make sure" depends on the application. For some systems, the 
programmer must wTite the code such that gelO is never called urness there is an 
object to allocate. On other systems, a programmer can test the result of getO 
and take some remedial action if that result is O. A characteristic example of the 
biter is a telephone system engineered to handle at most 100,000 calls at a ume. 
For each cali, some resource, such as a dial buffer, is allOCo:'lted. If the system runs 
out of dial buffers (e.g., dial_buffer_pooLgetO returns 0), the system refuses to 
set up new connections (and may "kill" a few existing calls to create capacity). 
The would-be caller can try again later. 
Naturally, our Pool template is only one variation of the general idea of a 
pool. For example, where the restraints on memory allocation are less Draconian, 
we call define pools where the number of clements is specified in the constructor 
or even pools where the number of elements can be changed later if we need 
more objects than initially specified. 
25.3.4 Slack example 
A J/lICH is a data structure from which we can allocate chunks of memory and 
deallocate the last allocated chunk. Using green for "allocated memory" and blue 
for "space ready for allocation," we can visualize a stack like lhis: 
Top of stack 
Stack: 
As indicated, this stack "grows" toward the right. 
"-I 
We could define a stack of objects, just as we defined a pool of objects: 
903 

C H APTER 25 • EMBEDDED 5YSTEMS PROGRAMM ING 
templale<class T, int N> class Stack { 
II . 
/I stack ofTs 
}; 
However, IllOSt systems have a need ror allocation or objects or varying sizes. A 
stack c.·m do that whereas a pool cannot, so we'll show how to define a stack 
rrom which we allocate "raw" memory or varying sizes rather than ftxed-sized 
objects: 
template<int N>class Stack { 
/I slack of N bytcs 
public: 
StackO; 
void* get(int n); 
void fTeeO; 
int availableO consl; 
private: 
/I make an N-byte stack 
1/ allocate n bytes from the stack; 
II return 0 if no free space 
II return the last value returned by gelO to the stack 
II number of available bytes 
II space for chariNI and data to keep track of what is allocated 
1/ and what is not (c.g., a top-of-stack pointer) 
}; 
Since getO returns a void" pointing to the required number or bytes, it is our job 
to convert that memory 10 the k.inds or objects we want. We ca.n use such a stack 
like this: 
Stack<50*1024> my_free_store; I/S0K worth of stor.lge to be used as a stack 
void· pvl = my_free_store.get(1024); 
int· buffer = static_cast<int·>(pvl); 
void· pv2 = my_frce_store.get(sizeof(Conncction»; 
Connection· pconn = new(pv2) Connection(incoming,oulgoing,buffcr); 
ll1e use or slatic cast is described in §17.8. rn le new(pv2) cOllstmct is a "place-
ment new." It means "Constmct an object in the space pointed 10 by pv2." It 
doesn't allocate anything. The assumption here is that the type Connection has a 
constructor that will accept the argument list (incoming,outgoing,buffe r). If 
that's not the case, the program won't compile. 
Naturally, our Stack template is only one variation or the gene .. !1 idea or a 
Slack. For example, where the restraints on memory allocation are less Dracon-
ian, we can define stacks where the number or bytes available rOJ" allocation is 
specified in the conslructOr. 

25. 4 
ADDRESSES. POINTERS, AND ARRAYS 
25.4 Addresses, pointers, and arrays 
Predictability is a need or some embedded systems; reliability is a concern or all. 
11lis leads to attempts to avoid language reatures and programming techniques 
that have proved error-prone (in the context or embedded systems programming, 
ir not necessarily everywhere). Careless usc or pointers is the main suspect here. 
~I\\'O problem areas stand OLlt: 
E.,xplicit (unchecked and unsare) conversions 
Passing pointers to array clements 
-nle rormer problem can typically be handled simply by severely restricting the 
usc or explicittypc conversions (casts). TIle pointer/array problems arc more sub-
tic, require understanding, and arc best dealt with using (simple) classes or li-
brary racilities (such as array, §20.9). Consequently, this section rocuses on how 
to address the lauer problems. 
25.4.1 Unchecked conversions 
Physical resources (e.g., control registers ror cxtemal devices) and their most 
basic sortware controls typically exist at specific addresses in a low-level system. 
We have to enter sllch addresses into Ollr programs and give a type to sllch data. 
For example: 
See also §17.8. -nlis is the kind or programming you do with a manual or online 
documentation open. TIle correspondence between a hardware resource - the 
address or the resource's register(s) (expressed as an integer, a rlen a hexadecimal 
integer) - and pointers to the sortware that manipulates the hardware resource is 
brittle. You have to get it right without much help rrom lhe compiler (because it is 
not a programming language issue). Usually, a simple (nasty, completely 
unchecked) reinlerpreCcasl rrom an inl to a pointer lype is the essential link in 
the chain or connections from an application to its nontrivial hardware resources. 
Where explicit conversions (reinlerpreCcasl, slatic_cast, etc.; sec §A.5.7) arc 
Ilot essential, avoid them. Such conversions (casts) are necessary rar less rre-
quently than is typic."lily assumed by programmers whose primary experience is 
Witll C and C-slyle C++. 
25.4.2 A problem: dysfunctional interfaces 
As mentioned (§18.5.1), an array is orten passed to a runction as a pointer to an 
clement (orten, a pointer to lhe first element). 11lereby, they "lose" their size, so 
that lhe receiving runction cannot dircclly tell how many clements are pointed (0, 
905 

CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
if any. 111is is a cause or many subtle and hard-to-fLX bugs. Here, we examine ex· 
amples of those array/pointer problems and present an alternative. We stall with 
an example or a very poor (but unrorlunately not ran::) imerrace and proceed to 
improve it. Consider: 
void poor(Shape p, inl sz) 
/I poor interlace design 
{ 
for (inl i = 0; k sz; Hi) pm.draw(); 
} 
void f(Shape q, vector<Circle>& sO) 
( 
Polygon sl[10J; 
Shape s2[10); 
/I initialize 
/I very bad code 
Shape pl = new Rectangle(PoinI(0,0),Point(10,20)); 
} 
poar(&sO(O],sO.size()); 
1/: 1 (pass the array (rom the vector) 
poor(sl ,10); 
/I : 2 
poor(s2,20); 
/I :3 
poor(pl ,l ); 
11 : 4 
delete pl ; 
pl = 0; 
poor(pl ,l); 
poor(q,max); 
11::5 
/I ::6 
111e function paorO is an ex.a.mple of poor interface design: it provides an inter-
race tllat provides the caJler ample opporlunity for mistakes but ofTers the imple-
menter essentially no opportunity to defend against such mistakes. 
TRYTHIS 
Before reading further, try to sec how many errors you can find in fO. Specif-
ically, which of the calJs of paorO could cause the program to crash? 
At first glance, the calls look fine, but this is the kind of code that costs a pro-
granuner long nights of debugging and gives a quality engineer nightmares. 
1. Passing the wrong clement type, e.g., poor(&sOIOI,sO.size()). Also, sO might 
be empty, in which case &sO(O] is wrong. 

25.4 
ADDRESSES, POINTER S, AND ARRAY S 
2. Use ofa "magic constant" (here, correct): poor(sl ,10). Also, wrong ele-
ment type. 
3. Usc of a "magic constant" (here, incorrect): poor(s2,20). 
4. Correct (easily verified): first call poor(pl ,l). 
5. Passing a null pointer: second C .. 1.11 poor(pl ,l ). 
6. May be COITect: poor(q,maJt:). We can't be sure from looking at this code 
fragmem. 10 sec if q points to an array with at least max elements, we 
have to fmd the definitions of q and max and detennine their values at 
ollr poilll of usc. 
In each case, the errors are simple. vVe are not dealing with some subtle algorith-
mic or data struclllre problem. ~nle problem is that poorO's interface, involving 
an array passed as a poimer, opens the possibility of a collection of problems. You 
may appreciate how the problems were obscured by our use of "technical" un-
helpful names, such as pl and sO. However, mnemonic, blll misleading, names 
can make such problems even harder to spot. 
In theory, a compiler could catch a few of these errors (such as the second 
call of poor(p 1,1) where 1'1 ==0), but realistically we arc saved from disaster for 
this particular example only because the compiler catches the auempt to define 
objects of the abstract class Shape. However, that is unrelated to poorO's inter-
face pmblcms, so we should not take too much comfOrl from that. In the follow-
ing, we usc a variant of Shape that is not abstract so as not to get distracted from 
the interface problems. 
!-low come the poor(&sO[O],sO.size(» call is an error? 111e &sOIO] refers to lhe 
first element of an array of Circles; it is it Circle· _ We expect a Shape- and we 
pass a pointer to an object of a class derived from Shape (here, a Circle-). That's 
obviously acceptable: we need that conversion so that we can do object-oriented 
programming, accessing objects of a variety of types through their conmlOn in-
terface {here, Shape} (§14.2). However, poorO docsn't just use that Shape- as a 
pointer; it uses it as an array, subscripting its way through that array: 
for (in I i = 0; ksz; Hi) p[il.drawO; 
'n mt is, it looks at the objects starting at memory locations &p[OJ, &p[l I, &p[2J, etc.: 
&plOI 
&plll 
&p12J 
" 
,
'\ 
:" 
~L-----"-
1 _1-,---, 
In tenus of memory addresses, these pointers arc sizeof(Shape) apart (§17.3. 1). 
Unfortunately for poorO's caller, sizeof(Circle) is larger than sizeof(Shape), so 
that the memory layolll can be visualized like this: 
907 

908 
CHAPTER 25 • EMBEDDED SYSTEMS PR OG RAMMI NG 
&p[O[ 
&p[l] 
&p[2[ 
>·.· 
.... :;l-1-.... ;;}.·.·.··.· .. ·; 
1St Circle 2nd Circle 3rd Circle 
11mt is, paorO is calling drawO with a pointer into the middle of the Circles! ll1is 
is likely to lead to immediate disaster (crash). 
TIle call poor(sl,10) is sneakier. It relies on a "magic constam" so it is imllledi-
ately suspect as a maintenance hazard, but there is a deeper problem. TIle only rca-
son the usc of an array of Polygons doesn't immediately suffer the problem we saw 
for Circles is that a Polygon didn't add data members to its base class Shape 
(whereas Circle did; sec §13.8 and § 13. 12); that is, sizeo[(Shape)==sizeof(Polygon) 
and - morc generally - a Polygon has the same memory layout as a Shape. In 
OI.hcr words, we were "jusl lucky"; a slight change in the definition of Polygon will 
callse a crash. $0 poor(sl,10) works, but it is a bug waiting to happen. 111is is elll-
plmic..'1lly not quality code. 
What we see here is the implementation reason for the general language mle 
that "a 0 is a B" docs not imply "a Container<D> is a Container<B>n (§19.3.3). 
For exmllple: 
class Circle: public Shape ( ' • ... -' ); 
void fv(vector<Shapc>&); 
void f(Shape &); 
void g(vector<Circlc>& vd, Circle & d) 
{ 
lid); 
r(vd); 
'10K : implicit conversion from Circle to Shape 
/I error: no conversion from veclor<Circle> 10 vector<Shapc> 
OK, so the use of poorO is very bad code, but can SLich code be considcred em-
bedded systems code; that is, should this k.ind of problem concern us in areas 
where safety or performance matters? Can we dismiss it as a hazard for pro-
grammers of non·critical systems and just tcHlhem, ---Don't do that"? \o\'ell, Illany 
modem embedded systems rely critically on a CUI, which is almost always or-
ganized in the object-oriented manner of our example. Examples include the iPod 
L1ser interface, the interfaces of some cell phones, and operator's displays on 
"gadgets" up to and including airplanes. Another example is that controllcrs of 
similar gadgets (such as a variety of electric Illolors) can constitute a classical 
class hierarchy. In Olher words, this kind of code - and in particular, this kind of 

25.4 
ADDRESSES, POINTERS, AN D ARR AYS 
function declaration - is exactly the kind of code we should worry about. We 
need a safer way of passing information about collections of data without causing 
other significant pmblems. 
So, we don't want to pass a built-in array to a function as a pointer plus a 
size. What do we do instead? TIle simplest solution is to pass a reference to a 
container, such as a vector. The problems we saw for 
void poor(Shapc* p, int sz); 
simply cannOl occur for 
void general(vector<Shape>&); 
If you arc programming where std : :vector (or the equivalent) is acceptable, sitn-
ply usc vector (or the equivalent) consistently in imerfaccs; never pass a built-in 
array as a pointer plus a size. 
If you can't restrict yourself to vector or equivalents, you enter a territory 
that is more difficult and tile solutions there involve techniques and language fea-
[Ures that arc not simple - even though the lise of the class (Array_ref) we pro-
vide is straightforward. 
25.4.3 A solution: an interface class 
Unfortunately, we cannot usc std::veclor in many embedded systems becallse it 
relics on free store. We can solve that problem either by having a special imple-
mentation of vector or (more easily) by using a container that behaves like a 
vector but doesn't do memory management. Before outlining such an interface 
class. let's consider what we want from it: 
It is a reference to objects in memory (it does not own objects, allocate 
objects, delete objects, etc.). 
It "knows" its size (so that it is potentially range checked). 
It "knows" the exact type of its elements (so that it cannot be the source 
of type errors). 
It is as cheap to pass (copy) as a (pointer,coum) pair. 
It docs 1101 implicitly convert to a pointer. 
It is easy to express a subrangc of the range of elements described by an 
interface object. 
It is as easy to lise as built-in arrays. 
IvVe will only be able to approximate "as easy to lise as built-in arrays." \oVe don't 
want it to be so easy to usc that errors start to become likely. 
909 

910 
CHAPTER 2S • EMBEDDED SYSTEMS PROGRAMMING 
Here is one such class: 
te mplale<class T> 
class Array_ref ( 
public: 
Array_reHP pp, int s) :p(pp), sz(s) { } 
T& operato r[ )(int n) { return p[n]; } 
consl T& o perator[ ](inl n) const ( return p[n); } 
bool assign(Array _ref a) 
( 
if (a.n!=a) return false; 
for (int i=O; i<sz; Hi) ( p(i]=a.p[iJ; ) 
} 
void reset(Array_,ef a) ( reset(a.p,a.sz); } 
void reset(P pp, int s) { p=pp; SZ=S; } 
int sizeO consl { return SZ; } 
/I default copy operations: 
/I 
Array_ref doesn't own any resources 
/I 
Array_ref has reference semantics 
private: 
} ; 
T* p; 
int sz; 
Array_ref is d ose to minimal: 
No push_backO (that would require free store) and no alO (that would 
require exceptions). 
Array_ref is a form of reference, so copying simply copies (p,sz). 
By initializing with difTerenl arrays, we can have Array_refs that are or 
the same type but have difTerent sizcs. 
By updating (p,size) using resetO, we can change the size or an existing 
Array_ref (many a1goriliuns require specification or subranges). 
No iterator interface (but that could be easily added if we needed it). In 
fact, an Array_.ref is in conception very d ose to a range described by twO 
itcrators. 

25 .4 
ADDRESSES, POINTE RS, AND ARRAYS 
An Array_ref does nm own its elements; it docs no memory management; it is 
simply a mechanism for accessing and passing a sequence of clements. In that, it 
differs from the standard library array (§20.9). 
"Ib ease the creation of Array_refs, we supply a few llseful helper functions: 
templale<c1ass T> Array_rckT> make_ref(T- PI', inl s) 
( 
return (1'1') 1 Array_rekT>(pp,s) : Array_rekT>(O,O); 
If we initialize an Array_ref with a pointer, we have to expliciliy supply a size. 
111at'S an obvious weakness because it provides us with an opportunity to give 
the wrong size. It also gives us an opportunity to usc a pointer that is a result of 
an implicit conversion of an array of a derived class to a pointer to a base class, 
such as Polygon(10] to Shape (the original horrible problem from §25.4.2), but 
sometimes we simply have to trust the programmer. 
We decided to be careful about null pointers (because they are a common 
source of problems), and we took a similar precaution for empty vectors: 
template<c1ass T> Array_rekT> makeJef(vector<T>& v) 
( 
return (v.size()) 1 Array_rekT>(&v!OI,v.size()): Array_rekT>(O,O); 
} 
Tbe idea is to pass the vector's array of clements. We concern ourselves with 
vector here even though it is often not suitable in lile kind of system where 
Array_ref can be useful. "Ine reason is that it shares key properties with contain-
ers that can be used there (e.g., pool-based containers; sec §25.3.3). 
Finally, we deal with built-in arrays where the compiler knows the size: 
template <class T, inl s> Array_refd> make_ref(T (&pp)[sJ) 
( 
return Array_rekT>(pp,s); 
} 
"nle curious T(&pp)(s1 notation declares the argument pp to be a reference to an 
array of s elements of type T. TImt allows us to initialize an Array_ref with an 
array, remembering its size. We c. .. n't declare an empty array, so we don't have to 
test for zero clements: 
Polygon arrOI; 
II error: no elements 
911 

912 
C H APTER 25 • EM BEDDE D SYSTE MS PROG RAMM ING 
Given Array_ref, we can try to rewrite our example: 
void better(Array_,ekShape> a) 
{ 
for (int i = 0; i<a.size(); ++i) a[i].drawO; 
) 
void (Shape· q, veclor<Cirde>& sO) 
{ 
) 
Polygon sl{10]; 
Shape 52[20J; 
/I initialize 
Shape· pl = new Rectansle(Point(O,O),Point(10,20»; 
beller(makeJef(sO»; 
1/ error: Array_rekShape> required 
beUer(makcJef(sl)); 
/I error: Array_rekShape> required 
beUer(makCJcf(s2»; 
/I O K (no conversion required) 
beUer(makeJef(pl ,l»; 
/I OK: one element 
delete pl ; 
pl = 0; 
belter(make_,ef(pl,l »; 
1/ OK: no clements 
beUer(make_,ef(q,max»; II OK (if max is OK) 
We sec improvements : 
TIle code is simpler. TIle programmer rarely has to think about sizes, 
but when necessary they arc in a specific place (the creation of an 
Array_ref), rather than sc."1ttercd throughout the code. 
The type problem with the Circle[J.to-ShapeIl a.nd Polygon[]-to-ShapeIl 
conversions is caught. 
~nle problems with the wrong number of clements for 51 and 52 arc im-
plicitly dealt with. 
111e potenual problem with max (and other clement COUllts for pointers) 
becomes more visible - it's the only plaee we have to be explicit about 
size. 
\OVe dca1 implicitly ,md systemalimlly with null pointers and empty vectors. 
25.4.4 Inheritance and containers 
But what if we wanted to treat a collection of Circles as a collection of Shapes, 
thaI is, if we really wanted betterO (which is a variant of our old friend 
draw_aIlO; see § 19.3.2, §22. 1.3) to handle polymorphism? Well, basically, we 

25.4 
ADDRESSES, POINTERS, AND ARRAYS 
can't. In §19.3.3 ,md §25.4.2, we saw that the type system has very good reasons 
for refusing to accept a vector<Circle> as a vector<Shape>. For the same reason, 
it refuses to accept an Array_rekCircle> as an Array_rekShape>. If you have a 
problem remembeling why, it might be a good idea to reread §19.3.3, because 
the point is pretty fundamental even though it can be inconvenient. 
Furtl1ermore, to preserve run-time polymorphic behavior, we have to manip-
ulate our polymorphic objects through pointers (or rderences): the dOl in 
p[iJ.drawO in betterO was a giveaway. We should have expected problems with 
polymorphism the second we saw that dOl rather than an arrow (-» . 
So what can we do? First we must lise poimers (or references) rather than ob-
jects directly, so we'll try to usc Array_rekCircleo>, Array_rekShapeo>, etc. 
rather than Array_,ekCircle>, Array_rekShape>, etc. 
However, we still Gllmot convcll an Array_rekCircleo> to an ArraYJef<Shapeo> 
bec.:'luse we might then proceed to plll clements into lhe Array_,ekShapeo> that 
are not Circle s. But there is a loophole: 
Here, we don't want to modify our Array_,ekShape>; we just want to 
draw the Shapes! This is an interesting and useful special case: our argu-
ment ag-dinst the Array_rekCircle">to·Array_,ekShapeo> conversion 
doesn't apply to a case when: we don't modify the Array_,ekShapeo>. 
All arrays of pointers have the same layout (independently of what kinds 
of objects they point to), so we don't get into the layout problem from 
§25.4.2. 
~n mt is, there would be nOlhillg wrong with treating an Array_rekCirclco> as 
an immut(lh/~ Array_rck Shape>. So, we ''just'' have to find a way to treat an 
Array_rekCirclco> as an immutable Array_rckShapc">. Consider: 
veclor<Circleo> 
Circle 
Smiley3ace 
(derived from 
Circle) 
Silly_face 
(derived from 
Smiley_face) 
-nlere is no logical problem treating that array of Circle" as an immutable array 
of Shape" (from an Array_ref). 
913 

914 
CHAPTER 25 • EM8EDDED SYSTEMS PROGRAMMING 
We seem to have strayed into expert territory. In facl, this problem is gen· 
uinely tricky and is unsolvable with the 10015 supplied so far. However, let'S sec 
what it takes to produces a close-la-perfect altcmative 10 our dysfunctional - but 
all too popular - imcrface style (pointer plus clement count; sec §25.4.2). Plcase 
remember: Don't go into "cxpcn territory" just to prove how clever you arc. 
Most often , it is a better strategy to find a library where sOllle experts have done 
the design, implementation, and testing for YOLI. 
First, we rework better() to something that lIses pointers and guarantees that 
we don't "mess with" the argument container: 
void bettcr2(conSI Array_rekShapc· const> a) 
{ 
for (int i = 0; i<a.size(); ++i) 
if (a[i)) 
a[i]- >draw(); 
We are now dealing with pointers, so we should check for null poimers. To make 
SLire that bcttcr2() docsn't modify our anays and vectors in unsafe ways through 
Array_rcf, we added a couplc of consls. TIle first consl ensures that we do !lot 
apply modifying (mutating) operations, such as assign() and rcscl(), on OUI' 
ArraY_fcr, The second consl is placed after the · to indicate that we want a COIl-
stant pointer (rather than a pointer to constants); that is, we don't want to modify 
the clement pointers even if we have operations available for thal. 
Next, we have to solve the central problem: how do we express the idea that 
ArraY_fekCircle*> can be converted 
To something like Array_rekShape"> (that we call usc in better20) 
BlIt only to an immutable version of Array_rekShapc-> 
"Ve can do that by adding a conversion operator to Array_ref: 
tcmplale<class T> 
class Array_ref ( 
public: 
/I as before 
template<class Q> 
operator consl Array _rckconst Q>() 
{ 
/I check implicit conversion of elements: 
slalic cast<Q>(*static cast<P>{O)); 

25 .<1 
ADDRESSES, POINTERS, AND ARRAYS 
/I cast Array_ref: 
return Array _rekconst Q>(reinterpreCcast<Q->(P),SZ)i 
) 
/I as before 
); 
This is headache-inducing, but basically: 
~nl e oper:nor casts to Array _,ekcost Q> for every type Q provided we 
can cast an clement of Array_rckY> LO an clement of Array_rekQ> (we 
don't use the result of that cast; we just check that wc can cast the cle-
ment types). 
We construct a new Array_rek const Q> by using brute force (rcinter-
prcc casl) to get a pointer to the desired clement type. Brute-force solu-
lions often cOlile at a cost; in tltis c.'lse, never use an Array_ref conversion 
from a class using multiple inheritance (§A.12.4). 
Note that const in Array_rekcon5t Q>: that's what ensures that we can-
not copy a Array_rekconst Q> into a plain old mutable Array_rekQ>. 
\Ve did warn you that this was "expert territory" and "headache-inducing." How-
ever, this version of Array_rcf is easy to use (it's only the definition/implementa-
lion that is tricky): 
void f(S haj>e- q, vcctor<Circle >& s2) 
( 
Polygon- s1(10); 
Shape 52(20); 
/I initialize 
Shapc· p1 = new Rectangle(Point(O,O),10); 
betler2(make_ref(sO»; 
II OK: converts to Array_rekShape' consl> 
betler2(make_ref(s1) ; 
II OK: converts to Array_rekShape'consl> 
betler2(make_,ef(s2»; 
/I OK (no conversion needed) 
betler2(make_ref(p1 ,1» ; 
II error 
betler2(make_ref(q,max» i /I error 
rn le altempts to lise pointers result in errors because they are Shape s whereas 
better2() expects an Array_,ekShapc· >; that is, betler2() expects something that 
holds pointers rather than a pointer. If we want to pass pointers to betler2(), we 
have to put them into a container (e.g., a built-in array or a vector) and pass that. 
For an individual pointer, we could lise the awkward make_,ef(&p1 ,1)_ However, 
915 

9" 
CHAPTER 25 • EMBEDDED SYSTEMS PROG RAMM ING 
there is no solution for arrays (with morc than onc element) that doesn't involve 
creating a container of pointers to objects. 
In conclusion, we can creale simple, safe, easy-to-uSc, and efficient interfaces 
to compensate for the weaknesses of arrays. That was the major aim of this sec-
tion. "Every problem is solved by another indirection" (quote by David Wheeler) 
has been proposed as "the fi rst law of computer science," That was the way we 
solved this imcrfacc problem. 
25.5 Bits, bytes, and words 
We have talked about hardware memory concepts, such as bilS, bytes, and words, 
before, but in general programming those arc nOt the ones we think much about. In-
stead we think in tenus of objects of specific types. SUdl as double, string, Matrix, 
and Simple_window. Here, we will look at a level of programming where we have 
to be more aware of the realities of the underlying memOll" 
1f you are uncertain about your knowledge of binary and hexadecimal repre-
sentations of integers, this may be a good lime to review §A.2.1.1. 
25.5.1 Bits and bit operations 
·n link of a byte as a sequence of 8 biLS: 
7: 6: 5: 4: 3: 2: 1: 0: 
J. JoJ. JoJoJ· JITD 
NOle the convention of numbering biLS in a byte rrom the right (the least signifi· 
cant bit) to the lert (the most significant bit). Now think or a word as a sequence 
or 4 bytes: 
J 
Oxll 
J 
0,'0 
J 
O,de 
J 
Oxad 
Again, we number right 10 lert, that is, least significant byte to most significant 
byte. 111ese pictures oversimpliry what is round in the real world: there have 
been computers where a byte was 9 biLS (but we haven't seen one ror a decade), 
and machines where a word is 2 bytcs are nOt rare. However, as long as you re-
member to check your systems manual before taking advantage or "8 bits" and 
"4 bytes," you should be fme. 
In code meant to be portable, use <Ii mils> (§24.2. 1) to make SUfe youI' as-
sumptions about sizes are correct. 
How do we represent a set of bits in C++? TIle answer depends a ll how 
mall)' bits we need and what kinds of operations we want to be convenient and 
efficient. We call use the integer types as seLS of bits : 

25.5 
BITS, BYTES, AND WORDS 
bool - I bit, but takes up a whole byte of space 
char - 8 bits 
short - 16 bits 
int - typically 32 bits, but many embedded systems have l6-bit inls 
long int - 32 bits or 64 bits 
111e sizes quoted are typical, but different implementations Illay have different 
sizes, so if you need to know, test. In addition, the standard library provides ways 
of dealing with bits: 
sld::veclor<bool> - when we need more than 8·sizeof(long) bits 
sld::bilsel - when we need more than 8·sizeof(long) bits 
sid: :sel - an unordered collection of named bits (see §21.6.5) 
A file: lots of bits (sec §25.5.6) 
Furthennore, we can usc two language features to represent bits: 
Enumerations (enums); see §9.5 
Bitfic1ds; see §25.5.5 
' 111is variety of ways to represent "bits" reflects the fact that ultimately everything 
in computer memory is a set of bits, so people have felt the urge to provide a va-
riety of ways of looking at bits, naming bits, and doing operations on bits. Note 
that the built·in facilities all deal with a set of a fixed number of bits (e.g., 8, 16, 
32, and 64) so that the computer can do logical operations on them at optimal 
speed using operations provided directly by hardware. In contrast, the standard 
libr:uy facilities all provide an arbitrary number of bilS. This may limit perfoml-
ance, but don't prejudge efficiency issues: the library facilities can be - and often 
are - optimized to nm well if you pick a Ilumber of bits that maps well to the un· 
derlying hardware. 
Let's first look at the illlegcrs. For these, C++ basically provides the bitwise 
logical operations that the hardware directly implements. '111ese operations apply 
to each bit of their operands: 
Bitwise operations 
0' 
& 
ood 
, 
exclusive or 
« 
left shifl 
» 
right shift 
complement 
Bit n of xly is 1 ifbit n of x orbit n of y is I. 
Bit n of x&y is 1 if bit n of x and bil n of y is 1. 
Bit n of x"y is 1 if bil n of x or bit n of y is 1 but not if bolh are 1. 
Bil n of x<<s is bit n+5 of x. 
Bil n of lC>>S is bil n-5 of x. 
Bit n of -x is the opposite of bit n of x. 
917 

.,. 
CHAPTER 25 • EMBEDDED SYSTEMS PROG RAMMIN G 
You might find the inclusion of "exclusive or" (", sometimes called "xor") as a 
fundamental operation odd. However, that's the essential operation in much 
graphics and encryption code. 
The compiler won't confuse a bitwise logical « for an output operator, but 
you might. To avoid confusion, remember that an output operator takes an 
ostream as its left-hand operand, whereas a bitwise logical operator takes an inte-
ger as its left-hand operand. 
Note that & difTers from && ,md I difTers from II by operating individually all 
every bit of its operands (§A.5.5), producing a result with as many bits as its 
operands. In contrast, && and II jusl rctum true or raise. 
Let's try a couplc of examples. We usually express bit pattem s using hexa-
decimal notation. For a half byte (4 bits) we have 
He< 
Bits 
He, 
Bits 
0,0 
0000 
0,8 
1000 
0" 
0001 
0,. 
1001 
0<2 
0010 
0 .. 
1010 
0" 
0011 
O,b 
1011 
0,. 
0100 
0" 
1100 
0" 
0101 
O,d 
1101 
0,. 
0110 
O,e 
1110 
0" 
0111 
Od 
1111 
For numbers up to 9 we could have used decimal, but lIsing hexadecimal helps 
us to remember that we are thinking about bit pattems. For bytes and words, 
hexadecimal becomes really useful. TIle bits in a byte can be expressed as two 
hexadecimal digits. For example: 
Hell byte 
Bits 
0,00 
00000000 
O,Of 
0000 1111 
OdO 
1111 0000 
Oxff 
11111111 
Oxaa 
10101010 
0<.5' 
01010101 

25.5 
BITS, BYTES, AND WO RD S 
So, using unsigned (§25.5.3) (0 keep things as simple as possiblc, we can \vOtc 
unsigned char a = Oxaa; 
unsigned char xO = -a; 
/I complement of a 
.: 11 I 0 l' I 0 l' I 0 l' I 0 lOx •• 
-.: I 0 11 I 0 11 I 0 11 I 0 11 I Ox55 
unsigned char b = OxOf; 
unsigned char xl = a&b; 
/I a and b 
.: l' I 0 l' I 0 l' I 0 11 I 0 lOx •• 
b: I 0 I 0 I 0 I 0 11 11 11 11 I Oxf 
.&b: I 0 I 0 I 0 I 0 11 I 0 11 I 0 lOx. 
unsigned char x2 = a"b; 
/I exclusive or: a xor b 
.: l' I 0 l' I 0 l' I 0 l' I 0 lOx •• 
b: I 0 I 0 I 0 I 0 11 11 11 11 I Oxf 
. ' b: l' I 0 l' I 0 I 0 l' I 0 l' I Oxa5 
unsigned char xl = a« l ; 
/I left shift 1 
.: l' I 0 l' I 0 l' I 0 l' I 0 lOx •• 
• «1: 101110111011101010x54 
Notc that a 0 is "shiftcd in" from beyond bit 7 to fill lip the byte. l11C leftmost bit 
(bit 7) simply disappears. 
unsigned char x4 == a»2; /I right shift 2 
.: 11 I 0 l' I 0 l' I 0 l' I 0 lOx •• 
a» 2 101011101110111010x2a 
Notc thal a 0 is "shifted in" from beyond bit 0 to fill lip the byte. l 11e rightmost 2 
bits (bit 1 and bit 0) simply disappear. 
919 

92. 
CHAPTER 25 • EMBEDDED SYSTEMS I'ROGRAMM ING 
We can draw bit patterns like this and it is good to get a feci for bit patterns, 
but it soon becomes tediolls. Here is a little program that converts integers to 
their bit representation: 
int mainO 
{ 
int i; 
while (cin»i) 
cout « dec « i « "==" 
) 
«
hex « "Ox" « i « "==" 
«
bilset<8-sizcof(int» (i) « '\n'i 
To print the individual biLS of the integer, we usc a standard library bilsel: 
bilset<8·sizeof(i nt»(i) 
A bilsel is a fixed number orbits. In this case, we usc the number orbits in an inl 
- 8-sizeof(int) - and initialize that bilset with OUf integer i. 
TRY THI S 
Get the bits example to work and try out a few values to develop a feel for bi-
nary and hexadecimal reprcsent.1tions. If you get confused about the repre-
sentation of negative values, juSt try again after reading §25.5.3. 
25.5.2 bitsel 
The standard library template class bilset from <bitsel> is used to represent and 
manipulate sets of bits. Each bitset is of a rlXed size. specified at construction: 
bitset<4> flags; 
bitset<128> dword_bits; 
bilsel<l 2345> lOiS; 
A bilset is by default initialized to "all zeros" bUl is typically given an initializer; 
bilsel iniliaJizers can be unsigned integers or strings of zeros and ones. For 
example: 
bitset<4> flags = Oxb; 
bitset<128> dword _bits(stri ng(" 1 01 01 01 01 01 01 01 0")); 

25.5 
BITS, BYTES, AND WORDS 
bilsel<12345> lOIs; 
Here lois will be all zeros, and dword_bils will have 112 zeros followed by the 16 
bits we explicitly specified. If you try to iniliaJize with a string that has characters 
different from '0' and '1', a std ::invalid_argument exception is thrown: 
string s; 
cin»s; 
bitset<12345> my_bits(s); 
/I may throw std::invalid_argument 
We can usc the usual bit manipulation operators for bilsets. Assume that bl, b2, 
and b3 are bitsets: 
b1 = b2&b3; /I and 
b1 = b21b3; 
/I Of 
b1 = b2 Ab3; /I XOf 
b1 = -b2; 
/I complement 
bl = b2<<2; /I shift left 
bl = b2» 3; /I shift right 
Basically. for bit operations (binvise logical operations), a bilsel acts like an 
unsigned int (§25.5.3) of an arbitralY, useT+Specified size. "What you can do to an 
unsigned int (with the exception of arithmetic operations), you can do to a 
bilsel. In particular, bilsets are useful for 110: 
cin» b; 
coul« hitset<Il>(' e'); 
/I read a bitsel from input 
/I output the bit pattern for the character 'c' 
When rcad;'llg \mo a bi\se\ , an ;'nput stream \oaks {or UfOS and oncli. Considef·. 
10121 
This is read as 101 leaving 21 unread in the stream. 
As for a byte and a word, the bits of a bilset are numbered right to left (from 
the least significant bit toward the most significant), so that, for example, the nu-
merical value of bit 7 is 21: 
7: 6: 5: 4: 3: 2: 1: 0: 
1110111010111' 1' 1 
For bitsels, the numbering is not just a convention because a bitsel supports sub-
scripting of bits. For example: 
921 

922 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
int mainO 
{ 
} 
const int max = 10; 
bitsel<max> b; 
while (cin»b) { 
} 
cout« b« '\n'; 
for (int i =0; kmax; ++i) cout « b(i]; 
cout« '\0'; 
II reverse order 
If you need a morc complete picture of bilsels, look them up in your online doc-
umentation, a manual, or an expen-level textbook. 
25.5.3 Signed and unsigned 
Like most languages, C++ supports both signed and unsigned integers. Un-
signed integers are trivial to represent in memory: bitO means 1, bill means 2, 
bil2 means 4, and so on. However, signed integers pose a problem: how do we 
distinguish between positive and negative numbers? C++ gives the hardware de-
signers some freedom of choice, but almost all implementations usc the twO's 
complement representation. The leftmost (most significant bit) is takcn as the 
"sign bit": 
I 
I I 
I I I I 
I 
16-bit (unsigned) int 
If thc sign bit is 1, the number is negative_ Almost univcrsally, the two's comple-
mcm representation is used_ To save paper, we consider how we would represent 
signed numbers in a 4-bit integer: 
Positive: 
Negative: 
o 
0000 
1111 
- I 
1 
0001 
1110 
-2 
2 
0010 
1101 
-3 
4 
0100 
1011 
-5 
7 
0111 
1000 
-8 
The bit pauem for -(x+l ) can be described as the complement of the bits in x 
(also known as - x; see §25_5.1 ). 

25.5 
BITS, BYTES, AND WOR DS 
So far, we have just used signed integers (e.g., int). A slightly better set of 
rules would be: 
Use signed integers (e.g., int) for numbers. 
Use unsigned integers (e.g., unsigned int) for sets orbits. 
111at'S not a bad rule of thumb, but it's hard to stick to because some people pre-
fer unsigned integers for some fomlS of arithmetic and we sometimes need to use 
their code. In particular, for historical reasons going back to the early days of C 
when ints were 16 bits and every bit mattered, v.sizeO for a veclor is an unsigned 
integer. For example: 
vector<inl> v; 
II . . . 
for (inl i = 0; kv.size(); ++i) coul « vli] « "n'; 
A "helpful" compiler may warn us that we are mixing signed (i.e., i) and un-
signcd (i.e., v.sizeO) values. Mixing signed and unsigned variables could lead to 
disaster. For example, the loop variable i might overflow; that is, v.sizeO might be 
larger than the largest signed int. Then, i would reach the highest value that 
could represent a positive integer in a signed int (the number of bits in an int 
minus I to the power of two, minus 1, e.g., 2 15- 1). 1l1en, the next ++ couldn't 
yield the next-highest integer and would instead result in a negative value. "111e 
loop would never terminate! Each time we reached the largest integer, we would 
start again from the smallest negative int value. So for 16-bit inls that loop is a 
(probably very serious) bug if v.sizeO is 32*1024 or larger; for 32-bit inls the 
problem occurs if i reaches 2*1024*1024*1024. 
So, technically, most of the loops in this book have been sloppy and could 
have caused problems. in other words, for an embedded system, we should ei-
ther have verified that the loop could never reach the critical point or replaced it 
with a different form of loop. To avoid this problem we can usc either the 
size_type provided by vector or itcrators: 
for (veclor<inl>: : size_type i = 0; k v_size(); ++i) cout « v[i] «'\n'; 
for (vector<inl>:: iteralor p = v.begin(); p! =v.end(); ++p) cout « . p « '\n'; 
111C size_type is guar.ultced to be unsigned, so thc first (unsigned intcger) form 
has onc more bit to play with than the int version above. That can be significant, 
but it still gives only a single bit of range (doubling the number of iterations that 
can be done). "1l1e loop using iteraLOrs has no such limitation. 
923 

924 
(HAPTE R 25 • EMBEDDED SYSTEMS PROG RAMMI NG 
TRY THIS 
TIle following example may look innocent, but it is an infinite loop: 
void infinileO 
{ 
unsigned char max = 160; 
II very large 
for (signed char i=O; k max; ++i) coul « inl(i)« '\n'; 
) 
Run it and explain why. 
Basically, there are tWO reasons for using unsigned integers as integers, as op-
posed to using them simply as sets orbits (i.c., not using +, - , ., and /) : 
To gain that extra bit of precision 
To express the logic.'ll property that the integer can't be negative 
TIle former is what programmers gct om of using an unsigned loop variable. 
111C problem with using both signed and unsigned types is that in C++ (as in 
C) they convert to each other in surprising and hard·to-rclllcmbcr ways. Consider: 
unsigned inl ui = - 1; 
int si = ui; 
int si2 = ui+2; 
unsigned ui2 = ui+2; 
Surprisingly, the first initialization succeeds and ui gets the value 4294967295, 
which is the unsigned 32-bit imeger with the same representation (bit pattern) as 
the signed integer - 1 ("all ones"). Some people consider that neat and lise - I as 
shonhand for "all ones"; others consider that a problem. TIle same conversion 
rule applies from unsigned to signed, so si gelS the value - 1. As we would expect, 
si2 becomes I (- 1+2 == I), and so docs ui2. The result for ui2 ought to surprise 
you for a second: why should 4294967295+2 be I? Look at 4294967295 as a 
hcxadecimal number (Oxffffffff) and things become clearer: 4294967295 is the 
largest unsigned 32-bit integer, so 4294967297 cannot be represented as a 32-bit 
integer - unsigned or not. So we say either that 4294967295+2 overflowed or 
(more precisely) that unsigned integers supPOI1 modular arithmetic; that is, arith-
metic on 32-bit integers is modulo-32 aritiUllctic. 
Is everything clear so far? Even if it is, we hope we have convinced you that 
playing with that extra bit of precision in an unsigned integer is playing with fire. 
It can be confusing and is therefore a potential source of errors. 

2 5.5 
BITS, BYTES. AND WORDS 
What happens ir an integer overflows? Consider: 
Inl i= O; 
while (H i) prinl(i); 
/I prinl i as an integer followed by a space 
What sequence or values will be printed? Obviously, this depends on the dcfini· 
tiOIl or Inl (no, ror once, the use or the capital J isn't a typo). For an integer type 
with a limited number or bits, \\'e will eventually overOow. If Int is unsigned (e.g., 
unsigned char, unsigned int, or unsigned long long), the ++ is modulo mit.lunelic, 
so after the largest number that can be represented we get 0 (and the loop temli· 
nates). Ir Inl is a signcd imeger (e.g., signed char), the numbers will suddenly tum 
negative and start working their way back up to 0 (where the loop will tcnninate). 
For example, rora signed char, we will sec 12 ... 126127 - 128-127 ... -2-1. 
What happens ir an integer overflows? The answer is that we proceed as ir 
we had enough bits, but throwaway whichever part or the result doesn't fit in the 
integer into which we store our result. That strategy will lose us the leftillost 
(most signific.'lnt) bilS. That's lhe same effect we sec when we assign: 
int si = 257; 
char c = si; 
II doesn't fit into a char 
II implicit conversion 10 char 
unsigned char ue = si; 
signed char sc = si; 
print(si); print(e); prinl(uc); J>rint(se); coul « '\n'; 
si = 129; 
c = si; 
ue = si; 
sc = si; 
II doesn't fi, into J signed char 
print(si); print(c); print(uc); print(sc); 
We gCt 
257 1 
129 - 127 
129 
-127 
TIle explanation or this result is that 257 is tWO more than will fit into 8 bilS (255 
is "8 ones") and 129 is nvo more than can fit into 7 bits (127 is "7 ones") so the 
sign bit gets set. Aside: This program shows that chars on our machine are un· 
signed (c behaves as ue and differs rrom sel. 
TRY THIS 
Draw out the bit patterns on a piece or paper. Using paper, then figure Out 
what the answer would be ror si= 128. Then run the program to see ir your 
machine agrees. 
925 

926 
CHAPTER 25 • EMBEDDED SYSTE MS PROGRAMM ING 
An aside: Why did we introduce that prinlO function? We could try: 
cout «
i«"i 
However, if i was a char, we would then output it as a character rather as an iIue-
geT value. So, to treat all iIllcger types uniformly, we defined 
templale<class T> void print(T i) {coul « i« '\I'i } 
void print(char i) (coul « int(i) « '\1'; } 
void print(signed char i) ( cout «
inl(i) « '\I'; } 
void prinl(unsigned char i) (coul « int(i)« '\1'; } 
To conclude: YOll C."lll usc unsigned integers exactly as signed integers (including 
ordinary arithmetic), but avoid that when you can because it is tricky and error-
prone. 
Try never to use unsigned just to gel another bit of precision. 
If you need one extra bit, you'U soon need another. 
Unfonunmc]y, you can't completely avoid unsigned arithmetic: 
Subscripting for standard library containers lIses unsigned . 
Some people like unsigned arithmetic. 
25.5.4 Bit manipulation 
\Vby do we actually manipulate bils? Well, most of us prefer not to. "Bit fid· 
dling" is low-level and error'prone, so when we have alternatives, wc take them. 
However, biLS are both fundamemal and very useful, so many of liS can't just pre· 
tend they don't exist. TIus may sOllnd a bit negative and discouraging, but that's 
deliberate. Some people really loue to play with biLS and bytes, so it is worth re· 
membering tim bit fiddling is somelhing yOll do when you must (quite possibly 
having some fun in the process), but biLS shouldn't be everywhere in your code. 
To quote John Bentley: "People who play with bits will be bitten" and "People 
who play with bytes will be byuen." 
So. when do we manipulate bils? Sometimes the natural objecls of our appli· 
cmion simply arc bils, so that some of the natural operations in our application 
domain are bit operations. Examples of such domains are hardware indicators 
("flags"), low-level communications (where we have to extract values of various 
types out of byte streams), graphics (where we have to compose pictures OUl of 
several levels of images), and encryption (see the next section). 

25.5 
BITS, BYTES, AND WORDS 
For example, consider how to extract (low-level) information from an integer 
(maybc because we wanted to transmit it as bytes, the way binary 110 docs): 
void f(short val) 
{ 
II assume 16-bit, 2-byte short integer 
unsigned char left = val&Oxff; 
unsigned char right = (val>>8)&Oxff; 
1/ . .. 
II leftmost (least significant) byte 
II rightmost (most significant) byte 
bool negative = val&Ox6000; 
/I 
II sign bi! 
) 
Such operations arc common. They are known as "shift and mask." We "shift" 
(using « or » ) to place the bits we want to consider to the rightmost (least sig-
nificant) part of the word where they are easy to manipulate. We "mask" using 
and (&) together with a bit pattem Qlere Oxff) to eliminate (set to zero) the bits we 
do not want in me result. 
When we want to name bits, we often use enumerations. For example: 
enum Printer_flags ( 
acknowledge=l, 
paper_empty=l« l , 
busy=l<<2, 
ou,-oCblack=l<<3, 
oul_oCcolor=1«4, 
/I . 
); 
TIlis defines each enumerator to have exaClly the value that its name indicaLCs: 
out_oLcolor 
,. 
Ox10 
00010000 
out_oLblack 
8 
0,8 
0000 1000 
busy 
• 
0,. 
00000100 
paper_empty 
2 
0,2 
00000010 
acknowledge 
1 
0" 
00000001 
Such values arc useful because they can be combined independently: 
unsigned char x = out_oCcolor I ou,-oLblack; 
x 1= paper_empty; 
II x becomes 24 (16+8) 
1/ x becomes 26 (24+2) 
Note how 1= can be read as "set a bit" (or as "set some bits"). Similarly, & can be 
read as "Is a bit set?" For example: 
927 

9,. 
CHAPTER 25 • EMBEDDED SYSTEMS I'ROGRAMMING 
if (x& ouCoCcolor) { 
1/ .. . 
} 
We can still usc & to mask: 
/I is out_oCeolor sct? (yes, it is) 
unsigned char y = x &(out_oCcolor I ouC oCblack)i 
1/ x becomes 24 
Now y has a copy of the biLS from x's positions 4 and 3 (oul_oCcolor and 
ouc oCblack). 
It is very common to usc an cnum as a set of biLS. When doing that, we need 
a conversion to gel thc rcsuh of a bitwise logical opcrmion "back into" the enum. 
For example: 
Flags 2 = Printe,_f1ags(ouCoCcolor I ouCoCblack); /I the cast is necessary 
TIle reason that the cast is needed is that the compiler "'"lnnot know that the result 
of a uL of_color I oul_oCblack is a valid value for a Flags variable. ~nlC compiler's 
skepticism is warranted: after all, no enumerator has a value 24 (ou'-o'-,olor I 
ouL oCblack), but in this case, we know the assignment to be reasonable (but lhe 
compiler docs not). 
25.5.5 Bitfields 
As mentioned, the hardware interface is one arca where bits occur frequently. 
Typically, an interface is defined as a mixture of bits and numbers of variOliS 
sizcs. 111cse "bits and numbers" are typically named and occur in specific posi-
tions of a word, often called a dt:uia register. C++ has a specific language facility to 
dcal with such flXed layouts: bi!foldJ. Consider a page number as uscd in the page 
manager dcep in an operating system. Here is a diagram from an operating sys-
tem manual: 
position : 
31: 
9: 
" 
" " " 
0' 
PPN: 
122 
13 
13 
l' l' l' l' I 
name: 
PFN 
unused 
CCA 
I dirty I global 
nonreachable valid 
~nle 32·bit word is used as two numeric fields (one of 22 bits and one of 3 bits) 
and four flags (1 bit each). The sizes and positions of these pieces of data are 
fiXcd. There is even an unused (and unnamed) "field" in the middle. We can ex-
press this as a struct: 

25.5 
BITS, BYTES, AND WORDS 
struct PPN { II R6000 Physical Page Number 
unsigned int PFN : 22 ; 
II Page Frame Number 
int : 3 ; 
II unused 
unsigned int CCA : 3; 
II Cache Coherency Algorilhm 
boof nonreachabfe : 1 ; 
bool dirty : 1 ; 
bool valid : 1 ; 
bool global : 1 ; 
}; 
We had to read the manual to sec that PFN and CCA should be interpreted as un-
signed integers, blll otherwise we could wlitc out that stfUcl directly from the di-
agram. Bitfields rill a word left to right. You give the number of bits as an intcger 
value after a colon. You can't specify an absollile position (e.g., bit 8). If you 
"consume" more bits witll bitfields tllall a word can hold, tlle fields tllat don't fit 
arc put into the next word. Hopefully, that's what you want. Once defined, a bit-
field is used exactly like other variables: 
void part_oL VM_system(PPN • p ) 
( 
II ... 
if (p->dirly) ( 1/ contents changed 
II copy 10 disk 
} 
) 
II. 
p->dirty = 0 ; 
Bitfields primarily save you the botller of shifting and masking to get to infonna-
Lion placed in the middle of a word. For example, given a PPN called pn we could 
extract the CCA like this: 
unsigned int x = pn.CCA; 
II exlracl CCA 
Had we used all int called pni LO represent tlle same biLS, we could instead have 
written: 
unsigned inl y = (pni» 4)&Ox7; 
II extract CCA 
That is, shift pn right so that tlle CCA is tlle leftmost bil, then mask all other bits 
olT with the Ox7 (i.e., last three bits set). If you look at the machine code, you'll 
most likely find lhat the generated code is identical for those two Jines. 
929 

930 
CHAPTE R 25 • EMBEDDED SYSTEMS PROGRAMMING 
"111C "acronym soup" (CCA, PPN, PFN) is typical of code at this level and 
makes little sense Ollt of contcxl. 
25.5.6 An example: simple encryption 
As an example of manipulation of data at the level of the data's representation as 
bits and bytes, let us consider a simple encryption algorithm: the Tiny Encryp-
tion Algorithm (TEA). It was originally written by David Wheeler of Cambridge 
University (§22.2.1). 1t is small but the protection against undesired decryption is 
excellent. 
Don't look too hard at the code (unless you rcally want to and arc willing to 
risk a headache). We present the code simply to give you the flavor of some real-
world and useful bit manipulation code. If you want to make a study of encryp-
tion, you need a separate textbook for thal. For more information and variants of 
the a1goritlun in other languages, see http://en.wikipcdia.orglwikirliny_Encryp-
tion_AJgoritlun and the TEA website of Professor Simon Shepherd, Bradford 
University, England. TIle code is not meant to be self-explanatory (no COIlUllents!). 
The basic idea of enciphering/deciphering (also know as cncryption/decryption) 
is simple. I want to send you some text, but I don't want others to read it. TIlerefore, 
I transfonn the text in a way that renders it unreadable to people who don't know 
exactly how I modified it - but in such a way that you can reverse my lr.msfonna-
tion and read the text. That's c.-uJcd enciphering. To encipher I usc an algorithm 
(which we must assume an uninvited listener knows) and a string called the "key." 
You and J both have the key (and we hope that the uninvited listener docs not). 
When you get the enciphered text, you decipher it using the "kcy"; that is, you re-
constitute the "dear text" that I sent. 
TEA takes as argument an array of two unsigned longs (v(OJ,v(l l) represent-
ing eight characters to be enciphered, an array of two unsigned longs (wIOJ,w(lJ) 
into which the enciphered output is written, and an array of four unsigned longs 
(k[0] .. k[3j), which is the key: 
void encipher( 
( 
const unsigned long ·const v, 
unsigned long ·const w, 
canst unsigned long· canst k ) 
unsigned long y = vIOl; 
unsigned long z = v[l ]; 
unsigned long sum = 0; 
unsigned long delta = Ox9E3779B9; 
unsigned long n = 32; 

25.5 
BIT S, BYTE S, AN D WO RD S 
) 
while(n-- > 0) { 
) 
y+= (z«
4 A z»5) + z A sum + k(sum&3Ji 
sum += delta; 
z+= (y«4 A y»5) + y A sum + k[sum» 11 &3]; 
w[OI=Yi w(1 1=zi 
NolC how all data is unsigned so that we can perform bitwise operations on it 
without fear of surprises caused by spceialtreatmem related to negative numbers. 
Shifts «< and » ), exclusive or (A), and bitwise and (&) do the essential work 
with an ordinary (unsigned) addition thrown in for good measure. This code is 
specifiea.lly wrillen for a machine where there arc 4 bytes in a long. The code is 
littered with "magic" COI1Slants (e.g., it assumes that sizeof(long) is 4). 111at's 
generally not a good idea, but this particular piece of software fits on a single 
sheet of paper. A5 a mathematical fonnula, it fits on the back of an envelope or -
as originally intended -
in the head of a programmer with a good memory. 
David Wheeler wamed to be able to encipher things while he was traveling with-
out bringing nOles, a laptop, etc. In addition to being small, this code is also fast. 
"111e variable n determines the number of iterations: the higher the number of it-
erations, the stronger the encryption. To the best of our knowledge, for n==32 
TEA has never been broken. 
Here is the corresponding deciphering function: 
void decipher( 
( 
) 
const unsigned long ·const v, 
unsigned long · const w. 
const unsigned long· const k) 
unsigned long y = v[OJ; 
unsigned long z = v[ll; 
unsigned long sum = OxC6EF3720; 
unsigned long delta = Ox9E3779B9i 
unsigned long n = 32; 
II sum = della«S, in general sum", delta· n 
while(n-- > 0) { 
z - = (y«4 A y»5) + y A sum + k(sum» ll & 3J; 
sum -= delta; 
y_= (z«4 A z»5) + z A sum + k[sum&3); 
wlOI=Yi w[1]=z; 
931 

932 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
We ca.1l usc TEA like this to produce a file to be scm over an unsafe connection: 
int mainO 
( 
II sender 
) 
consl int nchar = 2*sizeof(long)i 
consl int kchar = rnchari 
siring op; 
string key; 
siring infilc; 
siring outfile; 
1/ 64 bits 
1/ 128 bits 
cout« "please enter input file name, output file name, and key :\n"; 
dn » infile» oulfile» key; 
while (key.sizeO<kchar) key += 'O'i 
II pad key 
ifstrcam inf(infile.c_str()); 
of stream outf(outfile.c_slr()); 
if (!inf 11 !oulO e rror("bad file name"); 
const unsigned long* k = 
reinlerpreCcast<const unsigned long·>(key.data(»; 
unsigned long Qulptr(2); 
char inbuflncharl; 
unsigned long* inptr = rcinlcrprcl_cast<unsigned long*>(inbuO; 
int count = 0; 
while (inf.get(inbuf[countJ)) { 
) 
outf « hex; 
II use hexadecimal output 
if (++count == nchar) ( 
) 
en cipher(i n pi r, outptr, k); 
/I pad with leading zeros: 
outf « setw(8) «setfill('O') « oulptr[Ol «
' , 
«setw(8)« setfill('O')« outptr[l]«' '; 
count = 0; 
if (count) ( 
II pad 
) 
while(count != nchar) inbuf[count++l = '0'; 
e ncip her(i n pi r, 0 utpt r, k); 
outf« outplr[OI « ' , «
outptr[l l «
' '; 

25.5 
BITS, BYTES, AND WORDS 
933 
111e essemial piece of code is the while loop; the rest is JUSt support. ~nle while 
loop reads characters into the input buffer, inbuf, and every time it has eight 
characters as needed by TEA it passes them to encipherO. TEA doesn't care 
about characters; in fact, it has no idea what it is enciphering. For example, you 
could encipher a photo or a phone conversation. All TEA cares about is that it is 
given 64 bits (two unsigned longs) so that it can produce a cO'Teslxmding 64 bits. 
So, we take a pointer to the inbuf and C.'lS1 it to an unsigned long- and pass thaI 
to TEA. We do the same for the key; TEA will use the first 128 bits (four un-
signed longs) of the key, so we "pad" the user's input to be sure that there are 128 
bits. 111e last statement pads the text with zeros 10 make up the multiple of 64 
bits (8 bytes) required by TEA. 
How do we transmit the enciphered tc.xt? \Ve have a free choice, but since it 
is '"just bits
n rather than ASCII or Unicode characters, we c.'ln't really U"eal it as 
ordinary text. Binary 110 (sec §11.3.2) would be an option, but here we decided 
to output the output words as hexadecimal numbers: 
5b8fb57c 806fbcce 2db72335 23989d1d 991206bc 0363a308 
8f8ll1ac 38f3f2f3 9110a4bb c5e1389f 64d7efe8 ba133SS9 
4ccOOfaO 6f77e537 bde7925f f87045fO 472bad6e dd228bc3 
aS686903 Slcc9a61 fc19144e d3bcde62 4fdb7dc8 43dS6SeS 
£1d3f026 b2887412 97S80690 d2ea4f8b 2d8fb3b7 936cfa6d 
6a13ef90 fd036721 b8003Se1 7467d8d8 d32bb67e 29923fde 
197d4cd6 768749S1 418e8a43 e9644c2a eb10e848 ba67dcd8 
711S211£ dbe32069 e4e92f87 8bf3e33e b18f942c c965b87a 
44489114 18d4f2bc 256da1bf c57b1788 9113c372 12662c23 
eeb63c45 82499657 a8265f44 7c866aae 7c80a631 e9147Se1 
S991ab8b 6aedbb73 71b642c4 8d78f68b d602bfe4 d1eadde7 
S5f20835 1a6d3a4b 202c36b8 66a1eOf2 77199)f3 lld1dOab 
74a8cfd4 4ce54f5a eSfda09d acbd£110 2S9a1a19 b96h3a9 
456fd8a3 1e78591b 07c8f5a2 101641ec dOc9d7e1 60dbebll 
Mad8e72 ad30b839 201£c553 a34a79c4 217ca84d 30f666c6 
d018e61c d1c94ea6 6ca73314 cd60de£1 6e16870e 4Sb94dcO 
d7b44fcd 96e0425a 72839f71 d5b6427c 214340f9 874S882f 
0602c1a2 b437c7S9 caOe3903 bd4d8460 eddOS51e 3ld34dd3 
c3f943ed d2cae477 4d9dOb61 f647c377 Od9d303a ce1de974 
f9449784 df4603S0 5d42b06c d4dedbS4 17811b5f 4f723692 
14d67edb lldaS447 67bcOS9a 4600£047 63e43ge3 2e9d15f7 
4f21bbbe 3d7cSe9b 433564fS c3ff2597 3a1ea1df 305e2713 
9421d209 2b52384f f78fbae7 d03c1£S8 6832680a 207609f3 
9£2c5a59 ee31£147 2ebc3651 e017d9d6 d6d60ce2 2be1£2f9 
eb9de5a8 95657e30 cad37fda 7bce06f4 457daf44 eb257206 
418c24a5 de687477 5c1b3155 £744fbff 26800820 92224e9d 
43c03aS1 d168f2d1 624c54fe 73c99473 1bce8fbb 624S2495 
5de382c1 1a78944S aaOO178a 3e583446 dcbd64c5 ddda1e73 

.34 
CHAPTE R 25 • EMBEDDED SYSTEMS PROG RAMMI NG 
fa168da2 60bcl0ge 7102ce40 9fed3aOb 4424SeSd f612ed4c 
b5c16lf8 97££2£00 Idbf5674 45965600 b04cOafa b537&7 70 
9&b9bee7 16245160 Od3e556b 6de6eda7 d159blOe 7ldScla6 
b8bb87de 316aO£c9 62cOla3d 0 ... 24a51£ 86365842 52dabf4d 
372&018b 9a5df281 35c9f8d7 07c8(9):)4 36b6d9aS aOBae934 
23gefb&5 5fe3fa6f 659dfSOS faf4c378 4c2048d6 e8bf4939 
31167a93 43d17818 998ba244 55dba8ee 79ge07e7 43d26aef 
d5682864 OSe641dc bS948ec8 03457e3£ 80c934 fe ccSad4f9 
Odc16bb2 aSOaalef d62eflcd f8fbbf67 30c17fl2 718f4d9a 
43295fed 561de2aO 
TRY THIS 
The key was bs; what was the text? 
Any sccUlity expert WilllCll you that it is a dumb idea to store clear text and 
enciphered flies together and also express an opinion about padding, about using 
a two·leuer key, etc., but this is a programming book, rather than a book on com· 
pliler security. 
\"'e tested the programs by reading the enciphered text and getting the OIigi· 
nal back. When writing a program, it is always nice to be able to conduct a sim· 
pie test of correcllless. 
Here is lhe central part of the deciphering program: 
unsigned long inplr(2)i 
char oulbuf[nchar+1)i 
outbu[[nchar)=Oi II terminator 
unsigned long- oulplr = reinterpret_cast<unsigned long->(outbuOj 
inf.setf(ios_base:: hex ,ios_base:: basefield)j 
/I use hcxtldecimal input 
while (inf» inptr(OI» inptr[1]) { 
deci ph er(i n pi r,Ou I ph, k) i 
outk<outbufi 
) 
Note the use of 
inf.setf(ios_base: : hex ,ios_base:: basefield) i 
to read the hexadecimal numbers. For decryption, it's the output buffer, oulbuf, 
that we treat as bits using a cast. 

2 5 .6 
COD ING STA NDARDS 
Is TEA an example of embedded systems programming? Not specifically, 
but you can imagine it being used wherever privacy is needed or financial trans-
actions are conducted -
that could include many "gadgets." Anyway, TEA 
demonstrates many of the characteristics of good embedded systems code: it is 
based on a well-undersLOod (mathematical) model that makes us confident about 
its correctncss, it's small, it's fast, and it relies direcuy on hardware properties. 
The interface style of encipherO and decipherO is not quite to our taste. How-
ever, encipherO and decipherO were designed to be C as well as C++ functions, 
so no C++ facilities that are not also supported by C could be used. In addition, 
the many "magic constants" came from direct hand translation from the math. 
25.6 Coding standards 
There arc lllany sources of errors. TIle most serious and hardest to remedy relate 
to high-level design decisions, such as overall error-handling strategies, confor-
mance to certain standards (or lack thereof), algorithms, the representation of 
data, etc. These problems are no' the ones we address here. Instead, we focus on 
errors that arise from codc that is poorly wriuen, ulat is, code that uses program-
ming language facilities in unnecessarily error-prone ways or expresses ideas in 
ways that obscure their meaning. 
Coding standards try to address the latter kinds of problems by defming a 
"house style" that guides programmers to a subset of the C++ language that is 
deemed appropriate for a given application. For example, a coding standard for 
embedded systems programming may prohibit the use of new. Typically a cod-
ing standard also tries to ensure that code written by two programmers is more 
similar than if they had chosen freely from all possible styles. For example, a cod-
ing standard may require for-statements be used for loops (thereby banning 
while-statements). This can make code more uniform, and in large projects that 
can be imponant for maintenance. Please note that a coding standard is aimed at 
improving code for a specific kind of programming given a specific kind of pro· 
grammers. TIlere is no one coding standard suitable for all C++ applications and 
all C++ programmers. 
So, the problems that a coding standard tries to address arc problems that 
arise from the way we express aUf solutions rather than the problems that arise 
from inherent complexities of the problem we arc trying to solve with our appli-
c,ltion. We could say umt coding standards are trying to address incidental com· 
plexities rather Ulat inherent complexities. 
TIle Ill~or sources of such incidental complexities arc 
Overly c!cuer progralllmerJ, who usc features they don't understand or de-
light in complicated solutions 
Undereducated programmers, who don't lise lhe most appropriate language 
and library features 
935 

936 
( HAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
Unnu,ewuy fl(J.l'Ut.liQfIS ill prQgramming style, causing code pcrfonning similar 
tasks to look different and confuse maintaincrs 
JnappropriaJe programming language, leading to usc of language [eatures that 
aTC poorly adapted to a particular applic. ... tion area or to a particular 
group of progranuncrs 
blJl!!ficil!7l/ library use, leading to lots of ad hoc manipulation of low-level 
resources 
bzappropriale coding .standards, causing extra work or prohibiting the best 
solution to some classes of problems, thus becoming a source of the kind 
of problems that the standards were imroduccd LO solve 
25.6.1 What should a coding standard be! 
A good coding standard should help a programmer write good code; that is, it 
should help the programmer by giving answers to lots of little questions that each 
programmer would Olherwise have to spend time deciding on a case-by-case 
basis. 111ere is an old engineer's proverb that says, "Form is liberating." Ideally, a 
coding Sla.ndard should be prescriptive, stating what should be done. That seems 
obvious, but many coding standards are simply a list of prohibitions, with no 
guidance about what to do after having obeyed a long list of don'ts. JUSt being 
told what not lO do is rarely helpful and often annoying. 
The niles of a good coding standard should be verifiable, preferably by a pro-
gram; that is, once we have written the code, we should be able to look at it and 
easily answer the question, "Have I broken any m le of my coding standard?" 
A good coding standard should present a rationale for the rules. Program-
mers should nOt just be told, "Because tlmt's the way we do it!" When they are, 
they resent it. Worse, programmers invariably try to subvert parts of a coding 
standard that they see as pointless and as preventing them from doing a good 
job. Don't expeet to like everything about a coding standard. Even the best eod-
ing standard is a compromise, and most prohibit certain practices assumed to 
cause problems - even if they never caused you a problem. For example, incon-
sistent naming rules arc a source of confusion, but different people have strong 
attachments to some naming conventions and strong dislikes of others. For ex-
ample, I consider the CamelCodingSlyle of identifiers "pug ugly" and strongly 
prefer underscore_style as cleaner and inherently more readable, and many peo-
ple ab'Tee. On the other hand, many reasonable people disagree. Obviously, no 
naming standard can please everyone, but in this case, as in many others, a con· 
sistent slyle is definitely better than the lack of a standard. 
-lb summarize: 
A good coding standard is designed for a specific application domain 
and a specific group of programmers. 

25.6 
COD ING STANDA RDS 
A good coding standard is prescriptive as well as restrictivc. 
Recommending some "foundation" library facilities is often the most 
dfective use of prescriptive rules. 
A coding standard is a set of rules for what code should look like, 
Typically specifying naming and indentation rules; e.g., "Usc 
'Stroustrujl layollt.'" 
Typically specifying a subset of a language; e.g., "Don't use ne w or 
throw." 
Typically specifying rules for commenting; e.g., "Every function 
must have a comment explaining what it docs." 
Often requiring the usc of certain libraries; e.g., "Usc <iostream> 
rather than <stdio. h>" or "Usc vector and string raliler lilal1 built-in 
arrays and C-style strings." 
Common aims of most coding standards arc to improve 
Reliability 
Portability 
Maintainability 
Testability 
Reusability 
Extensibility 
Readability 
A good coding standard is better than no standard. We wouldn't start a 
major (multi-pcrson, multi-year) industrial project without one. 
A poor coding standard can be worse than no standard. For example, 
C++ coding standards that restrict programming to someliling like the 
C subset do hann_ Unfortunately, poor coding standards arc not un· 
common. 
All coding standards arc disliked by programmers, even the good ones. 
Most programmers want to write their code exactly the way Liley like it. 
25.6.2 Sample rules 
Here, we would like to give you a flavor of a coding standard by listing some 
rules_ Naturally, we pick rules that we hope will be useful to you. However, we 
have never seen a real-world coding standard that could be described in fewer 
than 35 pages, and most are mudllongcr. So, we don't rry to give yOll a complete 
.37 

938 
CHAPTER 25 • EMB EDDED SYSTEMS PR OGRAMMING 
set of rules here. Furthcnnorc, every good coding standard is designed for a par-
ticular application area and for a particular set of programmers. So, we don't 
make any pretenses of universality. 
~nlC rules arc numbered and contain a (brief) rationale. Many rules contain 
examples for easier comprehension. We distinguish between nCOllllllC7u/litioIlJ, 
which a programmer may occasionally decide to ignore, and finn nile;, which 
must be followed. In a real set of rules, a finn rule can usually be broken (only) 
with writlcn permission from a supervisor. Each violation of a recommendation 
or a firm rule requires a comment in the code. Any exceptions to a rule can be 
listed in lhe rule. A firm rule is identified by a capital R in its number. A recolll-
mendation is identified by a 10,,·:erc.'lSe ,. in its number. 
The rules are classified as 
General 
Preprocessor 
Naming and layout 
Class rules 
Function and expression rules 
Hard real-time 
Critical systems 
The "hard real-time" and "critical systems
n rules apply only to projects clas-
sified as such. 
Compared to a good real-world coding slandard, our terminology is under-
specified (e.g., what docs "critical" really mean?) and the rules overly terse. Simi-
larities betweelllhese rules and theJ SF++ rules (sec §25.6.2) arc not accidental; I 
helped fomm late theJ SF++ rules. However, the code examples in this book do 
not conform to the n iles below - after all, the book code is not critica.l embedded 
systems code. 
General rules 
RlOO: Anyone function or class shall contain no more than 200 logical sourcc 
lines of code (non-comments). 
N elISOll: Long functions and long classes tend to be complex and th erefore dif-
ficult to comprehend and test. 
rIOI : Anyone function or class should fit on a screen and serve a single logi-
cal purpose. 
R C(lJolI: A programmer looking at only part of a function or class is more 
likely to overlook a problem. A function that tries to perform several logical 
functions is likely to be longer and more complex that one that doesn't. 

25.6 
CO D IN G STANDA RD S 
R102: All code shall conform to ISO/lEG 14882:2003(E) standard G++. 
Reason: Language extensions or variations from ISO/lEG 14882 are likely to 
be less stable, to be less well specified, and to limit pormbility. 
Preprocessor niles 
R200: No macros shall be used except for source COIltTOJ using #ifdef and 
#ifndef. 
Reason: Macros don't obey scope and type rules. Macro usc is not obvious 
when visually examining somce text. 
R20l: #indude shall be used only to include header ( •. h) files. 
R((lson: #include is used to access interface declarations - not implement.-uion 
details. 
R202: All #include directives shall precede all non'preprocessor declarations. 
RC(LSoll: An #indude in t.he middle of a me is more likely to be overlooked by 
a reader and to cause inconsistcncies from a name resolved differelllly in dif-
ferem places. 
R203: Header files ( •. h) shall nOt contain non-const variable definitions or 
non-inline non-template function definitions. 
Rc(tjon: Header files should contain interface declarations - not implementa-
tion details. However, constants arc often seen as part of the interface, some 
very simple functions need to be inline (and therefore in headers) for per-
formance, and CUlTent template implementations require complete template 
definitions in headers. 
Naming Qlld layout 
R300: Indentations shall be used and be consist.ent within the same source 
rile. 
R etLWIl: Readability and style. 
R301: Each new statement starts on a new line. 
R C(1J01I: Readability. 
EWlIllple: 
£ '((1I11/)le: 
int a = 7; x = a+7; f(x,9); 
inta= 7; 
/10K 
x=a+7; 
/10K 
f(x.9); 
/I OK 
/I violation 
if (p<q) cout « .p; 
II violation 
.3. 

940 
(HA I'TER 25 • EMBEDDED SYSTEMS PROGRAMM ING 
£WIIII/,/e: 
if (p<q) 
cout « · Pi 
/I OK 
R302: Identifiers should be given descriptive names. 
Identifiers may contain common abbreviations and acronyms. 
When Llsed conventionally, x, y, i, j, etc. arc descriptive. 
Use the number_oCelcme nts style rather than the 
numberOfIlemenls style. 
Hungarian nmation shaJl not be used. 
Type, template, and namespacc names (omy) start with a c..'lpitallcttcr. 
Avoid excessively long names. 
Er:ample: Device_driver and Buffer_pool. 
Ri!m(»l: Readability. 
Note: Identifiers starting with an underscore arc reserved to the language im-
plementation by the C++ standard and thus banned. 
£"ceptiQll: 'When calling an approved library, the names from that library may 
be used. 
Excepti(m: Macro names used for #include guards. 
R303: Identifiers shall not differ only by 
A mixture of C'1se 
TIle presence/absence of the underscore character 
TIle imerchange of the lelter 0 with the number 0 or lhe letter D 
111e interchange of the letter I with the number I or me Jeuer f 
111e interchange of the letter S with the number 5 
The interchange of the leuer Z with the number 2 
111e interchange of the Jeuer 11 wilh the lellc!' II 
EYilmple: Head and head 1/ violation 
Reason: Readability. 
R304: No identifier shall be in all capital JeUers and underscores. 
Emmple: BLUE and BLUE_CHEESE 1/ violalion 
& (lJ()1I: All capital letters arc widely used for macros that may be used III 
#ind ude files for approved libraries. 
Function and expression rules 
r400: Identifiers in an inller scope should not be idemical to idemifiers in an 
outer scope. 

2S. 6 
CO DIN G STA NDARDS 
E.ample: 
int var = 9; { int var = 7; ++var;} 
/1 violation: var hides var 
Rell.JoII: Readability. 
R401: Declarations shall be declared in the smallest possible scope. 
Reason: Keeping initialization and use close minimizes chances of confusion; 
letting a variable go out of scope releases its resources. 
R402: Variables shaH be initialized. 
Example: 
int var; 
1/ violation: var is not initialized 
Reason: Uninilialized variables are a common source of errors. 
E.ceplioll: An array or a container that is immediately filled from input need 
not be initialized. 
R403: Casts shall not be used. 
Reason: Casts are a common source of errors. 
EWejJlion: dynamic_cast may be used. 
E.cePli<m: New·style casts may be used to convert hardware addresses into 
pointers and void· received from sources external to a program (e.g., a CUI 
library) into pointers of a proper type. 
R404: Built-in arrays shall not be used in interfaces; that is, a pointer as func-
lion argument shall be assumed to point to a single clement. Use Array_ref to 
pass arrays. 
Rell.JOTI: An array is passed as a poimer and its number of elemems is not 
carried along to the called function. Also, the combination of inlplicit array-lo-
pointer conversion and inlplicit derived-to-basc conversion can lead to mem-
DIy corruption. 
Class rnleJ 
RSOO: Use class for classes with no public data members. Use struct for classes 
with no private data members. Don't use classes with both public and private 
data members. 
Reason: Clarity. 
r501: If a class has a destructor or a member of poimer or reference lype, it 
must have a copy constructor and a copy assigmTIent defined or prohibited. 
Reason: A destructor usually releases a resource. The default copy semamics 
rarely does "the right thing" for pointer and reference members or for a class 
with a destructor. 
941 

942 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMM ING 
RS02: If a class has a virtual function it must have a virtual destructor. 
Reason: A class has a virtual function so that it can be used through a base class 
interface. A fu nction that knows an object only through that base class may 
delete it and dCI;vcd classes need a chance to clean up (in their destructors). 
r503: A constructor that accepts a single argumelll must be declared explicit. 
R~fljQ1l: To avoid surprising implicit conversions. 
Hard real-lime rules 
R800: Exceptions shall not be lIsed. 
RcaJQI/: Not predictable. 
R80! : new shall be used ouly during startup. 
&a.sQII: NOl predictable. 
Eyteptioll: placement-new (with the standard meaning) may be used for mem-
ory allocated frolll slacks. 
R 802: delele shall nOl be lIsed. 
Reason: Not predictable; can calise fragmentation. 
R803: dynamic cast shall not be used. 
Re(lJon: Not predictable (assuming COlllmon implemcntation tcchniquc). 
R804: l11C standard library containers, cxcept sid: :array, shall not be uscd. 
Re(lJ()ll: Not predictable (assuming common implemcmation techniquc). 
Critical systemr roles 
R900: Incremcnt and dccrement operations shall not be uscd as sub-cxprcssions. 
£wlIlI/,le: 
inl x = vl++i1; 
/I viol<3lion 
++i; 
int x = vii); 
/10K 
Re(lJon: Such an increment might be overlooked. 
R901 : Codc should not depend on prcccdcncc rules below thc Icvel of mith· 
metic cxpressions. 
EWlIllple: 
&alllple: 
if( a<b 11 c<=d) 
/I violation: parenthesize (a<b) and (c<=d) 

2S.6 
CODING STANDARDS 
R ,YU(J1I: confusion about precedence has been repeatedly found in code writ-
ten by programmers with a weak C/C++ background. 
We left gaps in the numbering so that we could add new 11.l1es without ch,mglng 
the numbering of existing ones and still have the general classific..1.tion recognized 
through the numbering_ It is very common for ntles to become known by their 
number, so that renumbering would be resisted by the users. 
25.6.3 Real coding standards 
"111ere arc lots of C++ coding standards. Most arc cOlporate and not widely 
available. In many cases, that's probably a good thing except possibly for the pro-
grammers of those corporations. Here is a list of sLw.dards that - when used ap-
propriately in areas to which they apply - call do some good: 
Henricson, Mats, and Erik Nyquist. IndlutriaJ Strength C++: Rule.! and RecommmM-
liolls. Prentice Hall, 1996_ ISBN 0131209655. A set of ntles wrilten in a 
telcconullunications company. Unfortunately, these ntles are somewhat dated: 
the book was published before the ISO C++ standard. In particular, templates 
don't enter lhe picture to the extent they would have had these ntles beell writ-
ten today. 
Lockheed Martin Corporation_ "Joint Strike Fighter Air Vehicle Coding Standards 
for the System Development and Demonstration Program_n Document Number 
2RDUOooOI Rev C. December 2005. Colloquially known as 'j SF++n; a sct of 
niles written at Lockheed-Martin Aero for air vehicle (read "airplanen) sofnvare. 
"nlese niles really were written by and for programmers who produce software 
ufXln which human lives depend. w\vw.research.att.com/-bslJSF-AV-rulcs.pdf. 
Programming Research. High-imegrity C++ Coding Standard Manual Version 
2.4-. www.progranuningresearch.com. 
Sutler, Herb, and Andrei Alexandrescu. C++ Coding Slmuwrds: 101 Rulej, GuiLk-
lillej, and &jl Prach'(£j. Addison-Wesley, 2004. ISBN 032 1113586. 111i5 is marc 
of a "met<! coding standard"; that is, instead of specific 11.l1es it has guidance on 
which rules are good and why_ 
Note that there is no substitute for knowing your applicalion area, your pro-
gramming language, and the relevant programming teclmique. For most applica-
tions - and certainly for most embedded systems programming - you also need 
to know your operating system andlor hardware architecture. If you need to usc 
C++ for low-level coding, have a look at the ISO C++ conmuuee's report on per-
formance (ISO/IEC TR 18015, www.research_atLcom/ -bslpcrfoml<U1ceTR.pdf); 
by «performance" theylwe primarily mean "embedded systems programming_" 
Language dialects and proprietary languages abound in the embedded sys-
tems world, blll whenever yOll can, use standardized language (such as ISO 
C++), tools, and libraries. That will minimize your learning curve and 1l1crcase 
the likelihood that your work will last. 
943 

944 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
~ 
Drill 
I. RUll lhis: 
int v = 1; for (int i = OJ i<sizeof(v)·S; ++i) { cout« v « 
I '; v «=1; } 
2. Run mal again with v declared to be an unsigned int. 
3. Using hcxadccilllallitcrals, define short unsigned ints: 
a. With every bit set 
h. 111e lowest (least significant bit) set 
c. 
~nl e highest (most significaJll bit) set 
d. TIle lowest byte all set 
c. 111e highest byte all set 
f. 
Every second bit set (and lhe lowest bit 1) 
g. Every second bit set (and the lowest bit 0) 
4. Print each as a decimal and as a hexidecimal. 
5. Do 3 and 4 using bit manipulation operations (I, &, « ) and (only) the lit-
erals 1 and O. 
Review 
1. What is an embedded system? Give len examples, out of which at least 
three should not be among those mentioned in this dmptcr. 
2. What is special about embedded systems? Give fivc concerns that are 
common. 
3. Define predictability in the context or embedded systems. 
4. Why can it be hard to maintain and repair an embedded system? 
5. Why can it be a poor idea to optimize a system ror perrormance? 
6. Why do we prefer higher levels or abstraction to low-level code? 
7. What are transient errors? Why do we particularly fear them? 
8. How can we design a system to survive railure? 
9. Why can't we prevent every railure? 
10. What is domain knowledge? Give examples or application domains. 
11. Why do we need domain knowledge to program embedded systems? 
12. What is a subsystem? Give examples. 
13. From a C++ language point or view, what are the three kinds or storage? 
14. When would you like to use rree store? 
15. Why is it often infeasible to use rree store in illl embedded system? 
16. When can you safely use new in an embedded system? 

CHAPTER 25 REVIEW 
17. What is the potential problem ,.vlth sid:: vector in the context of embed-
ded systems? 
IS. What is the potential problem with exceptions in the context of embed-
ded systems? 
19. What is a recursive function call? Why do some embedded systcms pro-
granullers avoid them? What do they use instead? 
20. What is memory fragmentation? 
2 1. ,,yhat is a garbage collector (in the context of programming)? 
22. What is a memory leak? Why can it be a problem? 
23. 'What is a resource? Give examples. 
24-. "Vhat is a resource leak and how can we systematically prevent it? 
25. Why can't we easily move objects from one place in memory to another? 
26. What is a stack? 
27. What is a pool? 
28. 'Why doesn't the use of stacks and pools lead LO memory fragmentation? 
29. Why is reinlerpreCcasl necessary? 'Why is it nasty? 
30. "Vhy arc pointers dangerous as function arguments? Give examples. 
31. What problems can arise from using pointers and arrays? Give ex'Ullples. 
32. ''''hat arc ahemauves LO using pointers (to arrays) in interfaces? 
33. What is "the first law of computer science"? 
34. What is a bit? 
35. What is a byte? 
36. Whal is the lIsual number of bits in a byte? 
37. What operations do we have on sets of bits? 
3S. W hat is an "exclusive or" and why is it useful? 
39. How can we represent a set (sequence, whatever) of bits? 
40. How do we conventionaHy number bits in a word? 
41. How do we conventionally number bytes in a word? 
42. ''''hat is a word? 
43. What is the usual number of bits in a word? 
44. What is the decimal value of Oxf7? 
45. What sequence of bits is Oxab? 
46. What is a bilsel and when would you need one? 
47. How docs an unsigned int differ from a signed inl? 
4S. When would yOll prefer an unsigned inl to a signed inl? 
49. How would you write a loop if lhe number of clements to be looped over 
was very high? 
50. Whal is lhe value of an unsigned inl after yOll assign -3 to it? 
51 . Why would we wam to manipulate bits aJld bytes (rather than higher-
level types)? 
52. What is a bitficld? 
53. For what arc bilfic1ds used? 
945 

946 
CHAPTER 25 • EMBEDDED SYSTEMS PROGRAMMING 
54. What is encryption (cncipheri.ng)? Why do we lise it? 
55. Can you encrypt a photo? 
56. Whal does TEA stand for? 
57. How do you write a number to ampuL in hexadecimal notation? 
58. Whal is the purpose of coding standards? List reasons for having them. 
59. Why can't we have a universal coding standard? 
60. List some properties of a good coding standard. 
G I. How can a coding standard do harm? 
62. Make a list of at least ten coding rules that you like (have found useful)? 
Why are they useful? 
63. Why do we avoid ALL_CArn AL identifiers? 
Terms 
address 
bit 
bitfield 
bitsel 
coding standard 
embedded system 
Exercises 
encryption 
exclusive or 
gadget 
garbage collector 
hard real ti.me 
I,ak 
pool 
predictability 
real time 
resource 
soft real time 
unsigned 
I. If you haven't already, do the Try this exercises in this chapter. 
2. Make a list of words that can be spelled with hexadecimal notation. Read 
o as 0, read 1 as ~ read 2 as to, etc. For example, Fool and Beef. Kindly 
eliminate vulgarities from the list before submitting it for grading. 
3. Initialize a 32·bit signed integer with the bit patterns and print the result: 
all zeros, all ones, alternating ones and zeros (starting with a leftmost 
one), alternating zeros and ones (starting with a leftmost zero), the 
1I001100llOO ... pattern, the 001100110011 ... pattern, the pattelll of 
all-one bytes and all-zero bytes starting with an all-ones byte, the pattern 
of aU-one bytes and all-zero bytes starting with an all-zeros byte. Repeat 
that exercise with a 32-bit unsigned imcger. 
4. Add the bitwise logical operators &, I, A , and - to the calculator from 
Chapler 7. 
5. Write 311 infinite loop. Execule it. 
6. Write an infinite loop that is hard to recognize as an infinite loop. A loop 
that isn't really infinite because it terminates after completely consuming 
some resource is acceptable. 
7. Write out the hexadecimal values from 0 LO 400; \\!Tite out the hexadeci-
mal values from -200 to 200. 
8. Write Ollt the numerical values of e.'lch character on your keyboard. 

CHAPTER 25 POSTSCRIPT 
9. WIthout using any standard headers (such as <limits» or documenta-
tion, compute the number of bits in an inl and detenlline whether char is 
signed or unsigned on your implementation. 
10. Look at the bitfield example from §25.5.5. Write an example that initial-
izes a PPN, then reads and prim each field value, then changes each field 
value (by assigning 1'0 the field), and prints the result. Repeat this exer-
cise, blll store the PPN information in a 32-bit unsigned integer and use 
bit manipulation operators (§25.5.4) to access the biLS in the word. 
11. Repeat the previous exercise, but keep the bilS in a bitset<32>. 
12. Write out the d ear text of the example from §25.5.6. 
13. Usc TEA (§25.5.6) to communicate "securely" between two computers. 
Email is minimally acceptable. 
14. Implement a simple vector that can hold at most N clements allocated 
from a pool. Test it for N==1000 and integer clements. 
15. Measure the time (§26.6.1) it takes to allocate 10,000 objects of random 
sizes in the [lOOO:O)-byte range using new; then measure the time it takes 
to deallocate them using delete. Do tllis twice, once dealJocaling in the 
reverse order of allocation and once deallocating in random order. Then, 
do the equivalent for allocating 10,000 objects of size 500 bytes from a 
pool and freeing them. 111en, do the equivalent of allocating 10,000 ob-
jects of random sizes in the [lOOO :O)-byte range on a stack and then free 
them (in reverse order). Compare the measurements. Do each measure-
ment at least three times to make sure the results are consistent. 
16. Fonnulate 20 coding style rules (don't just copy those in §25.6). Apply 
them to a program of more than 300 lines that you recently WTOle. Write 
a short (a page or two) comment on the experience of applying those 
rules. Did you find elTors in the code? Did the code get dearer? Did some 
code get less clear? Now modify the set of rules based on this experience. 
17. In §25.23-4 we provided a class Array_ref claimed to make access to ele-
ments of an array simpler and safer. In particular, we claimed to handle 
inheritance correctly. Try a variety of ways 10 get a Rectangle* into a 
veetor<Cirde*> using an Array_rekShape*> but no casts or other opera-
tions involving undefined behavior. This ought to be impossible. 
Postscript 
So, is embedded systems programming basically "bit fiddling"? 
Ol at all, espe-
cially if YOll deliberately try to minimize bit fiddling as a potential problem with 
correctness. However, somewhere in a system bits and bytes have "to be fid-
dled"; the question is just where and how. In most systems, the low-level code 
can and should be localized. Many of the most interesting systems we deal with 
are embedded, and some of the mOst interesting and challenging programming 
tasks are in this field. 
.. 7 


'cL . ,.-: 26 
Testing 
"I have only proven the code correct, 
not tested it." 
-Donald Knuth 
T
his chapter covers testing and design for correctness. ~ln cse 
are huge topics, so we can only scratch lheir surfaces. T he 
emphasis is on giving some practical ideas and techniques for leSl-
ing units, such as functions and classes, of a program. We discuss 
the use of interfaces and the selection of tests to run against them. 
We emphasize the importance of designing systems to simplify 
testing and the use of testing from the earliest slages of develop-
ment. Proving programs correct and dealing with performance 
problems are also briefly considered. 
... J 

950 
26.1 What we want 
26.1.1 Caveat 
26.2 Proofs 
26.3 Testing 
26.3.1 Regression tesls 
26.3.2 Unit tests 
26.3.3 Algorithms and non.algorithms 
26.3.4 System tests 
26.3.5 Testing classes 
26.3.6 Finding assumptions thai do not 
hold 
26.1 What we want 
C HAPTER 2 6 • TE STING 
26.4 Design for testing 
26.5 Debugging 
26.6 Performance 
26.6.1 Timing 
26.7 References 
Let's try a simple experiment. Write a binary search. Do it now. Don't wait until 
the end of the chapter. Don't wait until after lhe next section. It's important that 
you try. Now! A binary search is a search in a soncd sequence that stans at the 
middle: 
If the middle clement is cquallO what we arc searching for, we arc fin-
ished. 
If the middle element is less than what we are searching for, we look at 
the right-hand half, doing a binary search on that. 
If the middle clement is greater than what we are searching for, we look 
at the left-hand half, doing a binary search on that. 
llle result is an indicator of whether the search was successful and some-
thing that allows us to modify the element, if found, such as an index, a 
pointer, or an iterator. 
Use less-than «) as the comparison (sorting) criterion. Feci free to usc any data 
struCUIre you like, any calling conventions you like, and any way of retul'l1ing the 
result that you like, but do write the search code yourself. In this rare case, lIsing 
someone else's function is counterproductive, even with proper acknowledg-
ment. In particular, don't usc the standard library algorithm (binary_search or 
equal_range) that would have been your first choice in most situations. Take as 
much time as you like. 
So now you have writtcn your binary search function_ If not, go back to the 
previous paragraph. How do you know that your search function is correct? If 
you haven't already, wlite down why you arc convinced that this code is correct. 
How confident are you about your reasoning? Are there parts of your argument 
that might be weak? 

2 6 . 1 
W HAT WE WANT 
11mt was a trivially simple piece of code. h implemcntcd a very regular and 
well-known algorithm. Your compiler is on the OIuer of 200K lines of code, your 
operating systeIll is 10M to 50M lines of code, and the safety-critical code in the 
airplane you'll fly on for your next vacation or conference is SOOK to 2M lines of 
code. Docs that make you feel comfortable? How do the techniques you used for 
your bin; .. ), search function scale to real-world software sizes? 
Curiously, given all that complex code, most software works correctly most 
of the time. \r\'e do not COunt anything running on a game-infested consumer PC 
as "critical." Even more importantly, safety-critical software works correctly just 
about all of the time. We cannot recall an example of a plane or a car crashing be-
cause of a software failure over the last decade. Stories about bank software get-
ting seriously confused by a check for $0.00 arc now very old; such things 
essentially don't happen anymore. Yet software is written by people like you. You 
know that you make mistakes; we all do, so how do "they" get it right? 
'1l1e most fundamental answer is that "we" have figured out how to build re-
liable systems out of unreliable parts. We try hard to makc every prob"'am, evel)' 
class, and every function con'Cct, but we typica.!ly fail our first attempt at thal. 
~1l 1en we debug, test, and redesign to find and remove as many errors as possible. 
However, in any nontrivial system, some bugs will still be hiding. vVe know that, 
but we can't find them - or rather, we c."l.n't find them with the time and effort we 
are able and willing to expend. 'Illen, we redesign the system yet again to recover 
from unexpected and "impossible" events. ~1l1e result can be systems that arc 
spectacularly reliable. Notc that such reliable systems may stili harbor errors -
they usually do - and still occasionally work less well than we would like. How-
ever, they don't crash and always deliver m.inimally acceptable service. For exam-
ple, iI phone system may not managc to connect every call when demand is 
exceptionally high, but it never fails to connect many calls. 
Now, we could be philosophical and discuss whether an unexpected error 
lhat we have cOl~ ec tured and catered for is really an error, but let's not. It is more 
profitable and productive for systems builders "just" to figure how to make our 
systems more reliable. 
26.1.1 Caveat 
Tcsting is a huge topic. There arc several schools of thought about how testing 
should be done and different industries and application areas have different tradi-
tions and standards for lesting. TIlat's natural - you l'Cally don't nced the same 
reliability standard for video games and avionics software - but it leads to eo n~ 
fusing differences in terminology and tools. Tt'eat this chapter as a source of ideas 
for your personal projects and as a source of ideals if you encounter testing of 
m~or systems. TIle testing of m~or systems involves a variety of combinations 
of tools and organizmional structures that it would make litt1e sense to try to de-
scribe here. 
951 

952 
CHAPTER 26 • TESTING 
26.2 Proofs 
Wait a minute! Why don', we just prove lhat our programs arc correct, rather 
than fussing arollnd with tests? As Edsgcr Oijkst:r.l succinctly pointed out, "Tcst-
ing can reveal ,he presence of errors, not their absence." "n tis leads to an obviolls 
desire 10 prove programs correct "much as mathematicians prove theorems." 
Unfortunately, proving nontrivial programs correct is beyond the stale of the 
art (outside very constrained applications domains), the proofs themselves call 
contain errors (as can the ones mathematicians produce), and the whole ficld of 
program proving is an advanced topic. So, we try as hard as we can to structure 
our programs so that we can reason about them and convince ourselves that they 
arc correcl. However, we also lest (§26.3) and try to organize our code to be re-
silient against remaining errors (§26.4). 
26.3 Testing 
In §.? l l, we described testing as "a systematic way to search for errors.'" Let's 
look at techniques for doing thal. 
People distinguish between unit teJlillg and J}Jll1n leJhiJg. A "unit" is something 
like a function or a class that is a part of a complete progr.ull. If we tC!lt such units 
in isolation, we know where to look for the cause of problems when we find an 
error; any error will be in the unit that we are testing (or in the code we lise to 
conduct the tests). 111is contrasts with system testing, where we test a complete 
system and all we know is that an error is "somewhere in the system." Typically, 
errors found in system testing ~ once we have done a good job at unit testing-
relate to undesirable interactions between units. l11ey afe harder to find than er-
rors within individual units and often more expensive LO fix. 
Obviously, a unit (say, a class) can be composed of Olher units (say, functions 
and other classes), and systems (say, an electronic commerce system) can be com-
posed of mher systems (say, a database, a CUI, a networking system, and an 
order validation system), so the distinction between unit testing and systems test-
ing isn't as clear as you might have thought, but the general idea is that by testing 
our units well, we save ourselves work - and om end users pain_ 
One way of looking at testing is that any nontrivial system is built Ollt of 
units, and these units arc themselves built Ollt of smaller units_ So, we stan testing 
ule smallest units, then we test the units composed from ulose, and we work our 
way up until we have tested the whole system; Ulat is, "the system" is JUSt the 
largest unit (until we use that as a unit for some yctlarger system). 
So, let's first consider how to lest a unit (such as a function, a class, a class hi-
erarchy, or a template). l csters distinguish between white-box testing (where you 
can look at the detailed implementation of what you are testing) and black -box 
testing (where YOll can look only at the interface of what you are testing). We will 

26.3 
TE STING 
not make a big deaJ of this distinction; by all means read the implementation of 
what you lest. But remember that somcone might later come and rewrite I.hat im· 
plementation, so try not to depend on anything that is not guaranteed in the in-
terface. Ll fact, when testing anything, ule basic idea is to throw anything we C<"111 
at its interface to sec if it responds reasonably. 
Mentioning that someone (maybe yourself) might change the code after you 
tested it brings us to regression testing. Basically, whenever you make a change, 
you have to retest to make sure that you have not broken anything. So when you 
have improved a unit, you renm its unit tests, and before yOll give the complete 
system to someone else (or usc it for something reaJ YOllrself), you nm the com-
plete system lCSI.. 
Running such complete tests of a system is often called regressifm testillg be· 
cause it usually includes running tests that have previously found errors to sec if 
these errors arc still fIXed. If not, the program has "regressed" and needs to be 
fIXed again. 
26.3.1 Regression tests 
Building up a large collection of tests that have been useful for finding errors in 
the past is a major part of building an effective test suite for a system. Assume 
that you have users; they will send you bugs. Never throwaway a bug report! 
Professionals use bug·tracking systems to ensure that. Anyway, a bug report 
demonstrates either an error in the system or an error in a user's understanding 
of the system. Either way it is useful. 
Usually, a bug report contains far too much extraneous infonnation, and the 
first task of deaJing with it is to produce the smallest program umt exhibits the re-
ported problem. TIlis often involves cutting away most of the code submitted: in 
partieular, we try to eliminate the use of libraries and application code that docs 
not affect the error. Finding umt minimal test program often helps us localizc the 
bug in the system's code, and that minimal program is whal is added fa the reo 
gression ~cs { suite. TIl~ way we find thaI minimal program is to keep removing 
code until the error disappears - and thcn reinsert the last bit of code we re. 
moved. '11is we do until we run out of candidates for removal. 
Just nmning hundreds (or tens of thousands) of tests produced from old bug 
rcpor~ may not seem verr systematic, but what we arc really doing here is to sys· 
~em auc~ lly lise the expenence of users and developers. "nle regression test suite 
IS a ~naJor part of a developer group's institutional memory. For a large system, 
IVe sunply can't rely on having the original developers available to explain details 
of the d esi~1 and implementation. '11e regression suite is what keeps a systcm 
from mlltatlllg away frOill what the developers and uscrs have agreed to be its 
proper behavior. 
953 

954 
C HAPTER 2 6 • TESTING 
26.3.2 Unit tests 
OK. Enough words for now! Let's try a concrete example: let's teSI a binary 
scarcll. Here is the specification from the ISO standard (§25.3.3.4): 
template<class Forwardlterator, class T > 
boo] binary_search(Forwardlterator fint , FOIWardlterator last. 
const T& value); 
template<class ForwardIterator, class T, class Compare> 
bool binary_search(ForwardIterator first , Focwardlterator last. 
OODst T& value , Compare romp ); 
Requires: TIle clements c of [first ,last ) arc partitioned with respect LO the 
expressions c < value and !(value < c) or comp (e, value) and !comp 
(value, e). Also, for all clements c of [first , last ), c < value implies !(value 
< e) or comp (c, value) implies !comp (value, c), 
Returns: tme if there is an iteralar i in lhe range [first ,last ) that satisfies 
tbe co .... csponding conditions: !(*i < value ) && !(value < · i) or camp (· i, 
value ) = = raIse && comp (value , ·i) == raise. 
Complexity: At most logOast - first ) + 2 comparisons. 
Nobody said that a ronnal specification (well, semiformal) was easy to read ror 
the uninitiated. However, if you actually did the exercise of designing and imple-
mellling a binary search that we strongly suggested at the begilUling of the chap-
ter, you have a pretty good idea of what a binary search docs and how to test it. 
TIlis (standard) version takes a pair of fonvard iterators (§20.10.1 ) and a value as 
arguments and returns true ir the value is in the range defined by the iterators. 
rIlle iteraLOrs mUSt define a sorted sequence. The comparison (sorting) criterion 
is <. We'll leave the second version or binary_search that takes a comparison cri-
terion as an extra argument as an exercise. 
Here, we will deal only with errors that are not caught by the compiler, so ex-
amples like these arc somebody else's problem: 
binary_sea rch (1 ,4 ,5); 
veclor<inl> v(10); 
/I error: ,1n int is not ,1 forward iterator 
binary _seareh(v.beginO,v.endO, "7"); 
binary_sea reh (v. begi nO. v .end(»; 
/I error: can't search for a string 
/I in a vector of iots 
/I error: forgot the v<1lue 
How can we J)'Jtellltltiadly test binary_seareh()? Obviously we can't just try every 
possible argument for it, because every possible argument would be every possi· 
ble sequence of every possible type of value - that would be an infinite number 
of tests! So, we must choose tests and to choose, we need some principles for 
making a choice: 

2().3 
TESTING 
Tcst ror likely mistakes (find the most errors). 
Test ror bad mistakes (find the enut"s with the worst potential consequenccs). 
By "bad," we mean errors that would have the direst consequences. In general, 
that's a ruzzy notion, but it C,1n be made precise ror a specific program. For exam' 
pic, ror a binary search considered in isolation, all errors arc about equally bad, 
but ir we used that binary_search in a program where all answers were carerully 
double-checked, getting a wrong answer rrom binary_search might be rar more 
acceptable than having it not return because it went into an infinite loop. In that 
case, we would spcnd greater effort tricking binary_search into an infinite (or 
vcry long) loop Lhan wc would trying to mck it into giving a wrong answer. Note 
our usc or "tricking" here. Testing is - among other things - an exercise in ap-
plying creative thinking to the problem or "how can we get this code LO misbe-
have?" ' 1le best testers arc not just systematic, but also quite devious (in a good 
cause, or course). 
26.3.2.1 Testing strategy 
How do we go abollt breaking binary_search? We start by looking at binary_ 
search's requirements, that is, what it assumes about its inputs. Urnortunatcly, 
rrom our perspective as testers, it is dearly stated that [first,last) must be a sorted 
sequence; that is, it is the caller's job LO ensure that, so we can't rairly try to break 
binary_search by giving it unsorted input or a (first,last) where laSld irst. Note 
thai the requirements ror binary_search do not say what it will do ir wc give it 
input that doesn't meet its requirements. E1sewhcre in the standard, it says that it 
may throw an exception in that case, but it is not required to. TIlese racls are 
good to remember rOt" when we test uses or binary_search, though, because a 
caller railing to establish the requirements or a runction, such as binary_search, is 
a likely source or en-ars. 
'We can imagine the follo\',nng kinds or en-ors ror binary_search: 
Never returned (e.g., infinite loop) 
Crash (e.g., bad derderence, inrmite recursion) 
Value not round even though it was in the sequence 
Value round even though it wasn't in the sequence 
In addition, we remember the rollowing "oppornmilies" ror user errors: 
~n e sequence is not sorted (e.g., {2,1,5,-7,2,10»). 
~nle sequence is not a valid sequence (e.g., binary_search(&a[l00l, 
&.[SO[,n)). 
How might an implementer have made a mistake (rar testers to find) ror a simple 
call binary_search(pl ,p2,v)? Errors orten occur for "special cases." Ll particular, 
.55 

, .. 
(HAPTER 2 6 • TESTING 
when considering sequences (of any sort), we always look for the beginning and 
the end. In particular, the empty sequence should always be tested. So, let'S con-
sider a few arrays of integers that are properly ordered as required: 
{1 ,2,3,5,8,13,21 } 
() 
{O 
{1,2,J,4 } 
( 1,2,3,4,5 ) 
( 1, 1, 1,1 , 1, 1, 1 ) 
( 0,1,1,1,1,1,1,1,1,1,1 ,1,1 ) 
( 0,0,0,0,0,0,0,0,0,0,0,0,0,1 ) 
/I an "ordinary sequence~ 
II the empty sequence 
/I just one element 
/I even number of elements 
/I odd number of elements 
1/ all elements equal 
/I different element at end 
/I different element at end 
Some test sequences are best generated by a program: 
veclor<inl> vl ; 
for (inl i=O: i<100000000; H i) v.push_back(j); II a very large sequence 
Some sequences with a random number of clements 
Some sequences with random elements (but still ordered) 
TIlis is not as systematic as we'd have liked. After all, we "just picked" some se-
quences. However, we used some fairly general rules of thumb that often arc use-
ful when dealing with sets of values; consider: 
TIle empty set 
Small sets 
L,rge sets 
Sets wilh extreme distl"ibutions 
Sets where "what is of interest" happens near the end 
Sets with duplicate elements 
Sets with even and with odd numbers of elements 
Sets generated using random numbers 
"Ve use the random sequences just to sec if we can get lucky (i.e., find an error) 
with something we didn't think about. h's a brUle-force technique, bUl relatively 
cheap in tcrms of our time. 
Why "odd and even"? Well, lots of algorithms panitioll their input se-
quenccs, e.g., into the first half and the last half, and maybe the programmer con-
sidered only the odd or the even c..lSe. More generally, when we partition a 
sequence, the point where we split it becomes the end of a subsequence, and we 
know that errors arc likely near ends of sequences. 

2 6 .3 
TESTI NG 
In general, we look for 
Extreme cases Qarge, small, strange dislribmions of input, etc.) 
BoundaJ)' conditions (anything ncar a limit) 
Wh:H that really means, depends on the particular program we arc testing. 
26.3.2.2 A simple test harness 
We have two categories of tests: tests that should succeed (e.g., searching for a 
value that's in a sequence) and tcSts that should fail (e.g., searching for a value in 
an empty sequcnce). For each of our sequences, let's conSlnlct some succeeding 
and some failing tests. We will start from the simplest and most obvious and 
proceed to improve until we have something that's good enough for our 
binary_search exmnple: 
inl all = ( 1,2,3,5,8,13,21 ); 
if (binary _search(a,a+sizeof(a)/sizeoU·a), 1) == false) coul « "failed"; 
if (binary_search(a,a+sizeoHa)/sizeoWa),5) == false) coul« "failed "; 
if (binary_search(a,a+sizeof(a)/sizeoWa),8) == false) coul « "failed "; 
if (binary _search(a,a+sizeof(a)/sizeoWa),21) == false) coul « "failed"; 
if (binary_search(a,a+sizeof(a)/sizeoWa),-7) == true) coul « "failed "; 
if (binary _search(a,a+sizeof(a)/sizcof(*a),4) == true) coul « "failed "; 
if (binary_search(a,a+sizeof(a)/sizeof(*a),22) == true) cout « "failed "; 
rn lis is repetitive and tedious, but it will do for a start. In fact, many simple tests 
arc nothing but a long list of caBs like this. TIlis naive approach has the virtue of 
being extremely simple. Even the newest member of the test team can add a new 
test to the set. However, we can usually do better. For example, when something 
failed here. we arc notlOld which test failed. TIlat's unacceptable. So: 
int a[] = ( 1,2,3,5,8,13,21 ); 
if (binary_search(a,a+sizeof(a)/sizeof(*a),l ) == false) cout« "1 failed"; 
if (binary_search(a,a+sizeof(a)/sizeof(*a),5) == false) cout« "2 failed"; 
if (binary _search(a,a+sizeof(a)/sizeof(·a),8) == false) cout « "3 failed"; 
if (binary_search(a,a+sizeof(a)/sizeof(*a),21) == false) coul« "4 failed "; 
if (binary _search(a,a+sizeof(a)/sizeof(·a),-7) == true) cout « "5 failed "; 
if (binary_search(a,a+sizeof(a)/sizeof(*a),4) == true) coul« "6 failed "; 
if (binary_search(a,a+sizeof(a)/sizeof(·a),22) == true) coul« "7 failed "; 
Assuming that we will evcIllually have dozens of tests, this will make a huge dif-
fercnce. For tesling I'eah vorld systems, we often have many thousands of tests, so 
being precise about what test failed is essential. 
957 

9sa 
C H APTER 26 • TE STING 
Before going further, note anolher example of (semi-systematic) tcsting tech-
niquc: we tested with correct values, choosing some from the ends of the se-
quence and some frolll "the middle,'" For lhis sequence we could have tried all 
values, but typic illy that's not a realistic option. For the failing values, we chose 
one from each end and one in the middle. Again, this is not perfectly systematic, 
but we begin to sec a pattem that is lIseFul whenever we deal with sequences of 
values or ranges of values - and that's very COllllllo n. 
What's wrong with these inilial lcSLS? 
We write the same things repeatedly. 
vVc number the tests manually. 
TIle output is very minimal (not very helpful), 
After looking at this for a while, we decided to keep om tests as data in a file. 
Each test would contain an identifying label, a value to be looked up, a sequence, 
and an expected result. For example: 
{ 27 7 { 1 235813 21} 0 } 
111is is test number 27. It looks for 7 in the sequence ( 1,2,3,5,8,13,21 ) expecting 
the resuit 0 (meaning false). 'Why do we put the test inputs in a file rather than 
placing them right into the text of the test program? Well, in this c. ... se we could 
have typed the tests straight into the program text, but having a lot of data in a 
source code file can be messy. and often, we usc programs to generate test cases. 
Machine-generated tcst cases arc typically in data liles, Also, we can now write a 
test prognun that we can run with a variety of files of test cases: 
struct Test { 
} ; 
string label; 
int val; 
vector<int> seq; 
bool res; 
istream& operator»(islream& is, Test& t); /I use the described format 
int error_count = 0; 
Test t; 
while (cin» t) ( 
bool r = binary_search( I.seq.beginO, I.seq.endO, t.val); 

2 6 .3 
TESTING 
if (r !=t.res) { 
cout « "failure: test "« t.label 
«" binary_search : " 
«
t.seq.sizeO«" elements, val=="« t.va! 
«" ->"« t.res« '\11'; 
++error_count; 
return error_count; 
} 
int mainO 
{ 
int errors = lescallOi 
cout « "number of errors: "« errors« "\n"; 
} 
Here is some test input using the sequences we listed above: 
( 1.1 1 ( 1 ,2,3,5,8, 13,21 ) 1 } 
( 1.2 5 { 1,2,3,5,8,13,21 } 1 } 
( 1.3 8 { 1,2,3,5,8,13,21 } 1 } 
(1 .421 { 1,2,3,5,8,13,21) 1 } 
( 1.5 - 7 { 1,2,3,5,8,13,21 } 0 } 
( 1.64 ( 1,2,3,5,8,13,21 ) O} 
( 1.7 22 ( 1,2,3,5,8,13,21 ) 0 } 
{2 l {} O} 
{3.11 {1} 1 } 
{3.20 { 1 }O } 
{3.3 2 { 1 }O } 
Here we sec why we used a string label rather than a number: thal way we can 
"number" our tests using a more nexible system - here using a decimal system to 
indicate separate tests for the same sequence. A more sophisticated formal would 
eliminate the need to repeat a sequence in our test data me. 
26.3.2.3 Random sequences 
vVhen we choose values to be used in tcsting, we try to outwit the implemellters 
(who are often ourselves) and to usc values that focus on areas where we know 
bugs can hide {e.g., complicated sequences of conditions, the ends of sequences, 

CHAPTER 26 • TESTING 
loops, etc.). However, that's also what we did when we tried to write and debug 
the code. So, we might repeat a logical mistake from the design when we design 
the tests and completely miss a problem. This is one reason it is a good idea to 
have someone different from the developer(s) involved with designing the tests. 
We have one technique that occasionally helps with that problem: just generate (a 
lot of) random values. For example, here is a function t.hat writes a test descrip-
tion to cout using randj nt() from §24.7: 
void make_test(const string& lab, int n, int base, int spread) 
1/ write a test description with the label lab to cout 
{ 
II generate a sequence of n elements starting at base 
I/the average distance between elements is spread 
coul « "(" « lab « n"« n «" {": 
veclor<int> v: 
int elem = base: 
for (in I i = 0: k n; ++i) { 
1/ make elements 
elem+= randj nt(spread): 
v.push_back(elern): 
int val = base+ land_int(elem-base): 
bool found = false: 
1/ make search value 
fOl (int i = 0: i<n ; ++i) { 
1/ print clements and see if val is found 
if (v{iJ==val) found = lrue; 
cout « v(i]«" "; 
coul« "}"« found«
" }\n"; 
Note that we did not use binary_search to sec if the random val was in the random 
sequence. We can't use what we are testing to detennine the correct value of a tCSl. 
Actually. binary_search isn't a part.icularly suitable example of the brule-
force random number approach to testing. We doubt I..hat tltis will find atl)' bugs 
that arc not picked up by our "hand-crafted" tests, but often I.his technique is use-
ful. Anyway, let's make a few random tests: 
int no_oUests = rand_inU1(0); 
for (int i = 0; kno_oUests; ++i) ( 
siring lab = "rand_Iesc"; 
rna ke_test(lab+ to _Slri ng(i), 
1/ make about 50 rests 
1/ to_string from §23.2 

26.] 
TES TI NG 
randj nt(SOO), 
0, 
randj nt(SO»j 
/I number of clemen!s 
/I base 
1/ spread 
Generated tests based on random numbers are particularly useful when we need 
to test the cumulative effects of many operations where the result of an operation 
depends on how earlier operations were handled, that is, when a system has 
state; see §5.2. 
111e reason LhaL random numbers arc nOt. all that useful for binary_search is 
that each search of a sequence is independent of all oLher searches of Lhat se-
quence. 111at of course assumes that the implementation of binary_search hasn't 
done something terminally stupid, such as modifying its sequence. "VVe have a 
better test for that (exercise 5). 
26.3.3 Algorithms and non-algorithms 
We have used bina r y~sea r c h () as an example. It's a proper aJgoriLhm with 
Well-specified requirements on its inputs 
A well-specified elIect on its inputs (in this case, no elIects) 
No dependencies on objects that are not its explicit inputs 
Without serious constraints imposed by the environment (e.g., no speci-
fied time, space, or resource-sharing requirements) 
It has obvious and expliciLly staled pre-and post-conditions (§S.lO). In oLller words, 
it's a tester's dream. Often, we arc not so lucky: we have La test messy code Llmt (at 
best) is defined by a somewhat sloppy English tex.! and a couple of diagrams. 
Wait a minute! Are we indulging in sloppy logie here? How can we talk 
about COITeClness and testing when we don't have a precise specification of what 
the code is supposed to do? 11le problem is that much of what needs to be done 
in software is not easy to specify in perfectly clear mathematical temu. Also, in 
many cases where it in theory could be specified like lhat, tlle math is beyond the 
abilities of the programmers who write and test the code. So we are left with the 
ideal of perfectly precise spccificatiOlu and a reality of what someone (such as us) 
can manage under real-world conditions and time pressures. 
So. assume that you have a messy fUlletion tlIat you have to test. By "messy" 
we mean: 
III/JUls: Its requirements on its (explicit or implicit) inputs are not specified 
quite as well as we would like. 
Oul/mls: Its (explicit or implicit) OUtpLHS are not specified quite as well as 
we would like. 
961 

%, 
C HAPTER 26 • TESTING 
!USOIITCeS: Its use of resources (time, memory, liles, CIC.) arc not specified 
quite as well as we would like. 
By "explicit or implicit" we mean that we have to look nOljust 31 the formal pa-
rameter and the return value, bUl also on any effects all global variables, 
ioslreams, files, frcc-store memory allocation, etc. So, what can we do? First of 
all, such a function is almost cCriainly tOO long - or we could have stated its re-
quirements and effects more dearly. Maybe we arc talking about a fUllction that 
is live pages long or uses "helper functions" in complicated and nOll-obvious 
ways. You may think tJlal five pages is a lot for a function. It is, but we have seen 
much, much longer functions than thaL Unfortunately, they arc not uncommon. 
If it is our code and if we had time, we would first of all try to break such a 
"messy function" up into smaller functions that each come closer to our ideals of 
a weU·specified function and first test those. However, here we will assume that 
our aim is to test the software - that is, to systcmatically find as many C!Tors as 
possible - rather than (just) fixing bugs as we find them. 
So, what do we look for? Our job as testers is to find crrors. Where are bugs 
likely to hide? What characterizes code that is likely to contain bugs? 
Subtle dependencies on "other code": look for usc of global variables, 
non-canst-reference arguments, pointers, etc. 
Resource management: look for memory management (new and delete), 
file usc, locks, etc. 
Look for loops: check end conditions (as for binary_searchO). 
if-statements and switches (often referred to as "branchillg"): look for er-
rors in th eir logic. 
Let's look at examples of each_ 
26.3.3.1 Dependencies 
Consider this nonsense function: 
int do_dependenUinl a, int& b ) 
/I messy function 
{ 
) 
II undiSCiplined dependencies 
inl val; 
cin»val; 
vec(val) += 10; 
cout« a; 
b++; 
return b; 

26 .] 
TESTING 
To test do_ dependentO. we can't just synthesize sets of arguments and see what 
it docs with them. We have to take into account that it uses the global variables 
cin. cout, and vee. -l1mt's pretty obvious in this little nonsense function, but in 
real code this may be hidden in a larger amount of code. Fortunately, there is 
software that can help us find such dependencies. Unfortunately, it is not always 
easily available or widely used. Assuming that we don't have analysis software to 
help us, we go through the function line by line, listing all its dependencies. 
To test do_ dependentO, we have to consider 
Its inputs: 
~l1l e vallie of a 
~nle value of b and the value of the int referenced by b 
"n lC input from d n (imo val) and the state of d n 
~nle state of cout 
"Inc value of vee, in panicular, the value of vec["al] 
Its outputs: 
~nle return value 
TIle value of the int referenced by b (we incremented it) 
Tne state of dn (beware of stream state and format state) 
"nle state of cout (beware of stream state and fomlat state) 
111e state of vec (we assigned to vee[vall) 
Any exceptions that vee might have thrown ("ec[val] might be out of 
range) 
11lis is II long list. In fact, that list is longer that the function itself. TIlis goes a 
long way toward explaining OUI' dislike of global variables and our concerns 
abollt non·eonst references (and pointers). There really is something very nice 
abollt a function that JUSt reads its arguments and produces a result as a return 
value: we can easily understand and test il. 
Once the inputs and Outputs arc identified, we are basically back to the 
binary_searchO case. We simply generate tests with input values (for explicit and 
implicit inputs) to see if they give the desired outputs (considering both implicit 
and explicit outputs). With do_ dependentO, we would pmbably start with a 
vcry large val and a negative val, to sec what happens. It looks as if vec had bct· 
ter be a range·checked vector (or we can very simply generate really bad errors). 
Wc would of course check what the documentation said about all those inputs 
and outputs, but with a mcssy function like that we have little hope of the spcrifi-
cation being complete and precise, so we will JUSt break the functions (i.e., find 
errors) and Start asking questions about what is correcl. Often, such testing and 
qucstions should lead to a redesign. 
%3 

964 
26.3.3.2 Resource management 
Consider this nonsense function: 
C H APTER 26 • TESTING 
void do_resourcesl(int a, int b, const char· s) /I messy function 
/I undisciplined resource use 
} 
FILE" f = [ope n(s, "r"); 
intO p = new inlla1; 
if (b<=O) throw Bad_argO; 
intO q = new intlb); 
delete[l Pi 
/I open file (C style) 
II allocate some memory 
/I maybe throw an exception 
/I allocate some more memory 
1/ deallocate the memory pointed 10 by p 
To test do_resourcesl 0, we have to consider whether evcly resource acquired 
has been properly disposed of, that is, whether every resource has been either re-
leased or passed to some other function. 
Here, it is obviolls that 
The fLie named s is not closed 
The mcmOlY allocated for p is leaked if b<=O or if the second new throws 
The memory for q is leaked if Ikb 
In addition, we should always consider the possibility that an attempt at opening 
a file might fail. To get this miserable result, we deliberately used a very old-
fashioned programming style (fopenO is the standard C way of opening files). 
\Ve could have made the job for testers more slraightfon vard by writing 
void dOJesources2(int a, int b. canst char- s) II less messy function 
( 
} 
ifs.ream iSiS); 
vector<inl>vl (a); 
if (b<=O) throw Bad_arGO; 
vedor<inb v2(b); 
/I open file 
II create vector (owning memory) 
/I maybe throw an exception 
/I create another vector (owning memory) 
Now evcry resource is owned by an object with a destructor that will release il. 
Considering how we could write a function more simp!), (more cleanly) is some-
times a good way to get ideas for testing. TIle "Resource Acquisition Is Initializ.a· 
lion'" (RAIn technique from §19.5.2 provides a general strateg), for this kind of 
resource management problem. 
Please note thaI resource management is not JUSt checking that every piece of 
memory alloc,lted is deleted. Sometimes we receive resources from elsewhere (e.g., 

26.3 
TE STI NG 
as an argument), and sometimes we pass resources Oul of a function (e.g., as a return 
value). It can be quite hard to detcnnine what is right about SUdl cases. Consider: 
FILP do_resources3(int a, int· p, const char· s) 
/I undisciplined resource passing 
{ 
} 
fllP f = fopen(s, "r"); 
delete p; 
delete var; 
var = new int[27]; 
return f; 
/I messy function 
Is it right for do_resources30 to pass the (supposedly) opened file back as the re-
turn value? Is it right for do_resources30 to delete the memory passed to it as 
the aJ"b'llment p? We also added a really sneaky use of the global variable var (ob-
viouslya pointer). Basically, passing resources in and out of functions is common 
and useful, but to know if it is correct requires knowledge of a rcsource manage-
ment strategy. Who owns the resource? Who is supposed to deletclrelease it? 
111e documentation should clearly and simply answer those questions. (Dream 
on.) In either case, passing of resources is a fertile area for bugs and a tempting 
target for tesling. 
Note how we (deliberately) complicated the resource management example 
by using a global variable. Things can get really messy when we start to mix the 
sources of likely bugs. As progranuners, we try to avoid that. As testers, we look 
for such examples as easy pickings. 
26.3.3.3 Loops 
We have looked at loops when we discussed binary_searchO. Basically most er-
rors occur at the ends: 
Is everything properly initialized when we start the loop? 
Do we correctly end with the last case (often the last element)? 
Here is an eXillllple where we get it wrong: 
int doJoop(veclor<inb& v) 
II undiSCiplined loop 
{ 
int i; 
int sum; 
/I messy fUllct ion 
while(i<=vec.size()) sum+=v[i); 
return sum; 
%5 

... 
CHAPTE R 26 • TESTING 
There arc three obvious errors. (What are they?) In addition, a good tester will 
immediately spot the opportunity for an overflow where we arc adding to sum: 
Many loops involve data and might calise some sort of overflow when 
they arc given large inputs. 
A fatuous and particularly nasly loop error, the burTer overflow, ralls into the 
category that can be caught by systematically asking the twO key questions about 
loops: 
char buf(MAX]; 
/I fixed-size buffer 
char- read_lineO 
/I dangerously sloppy 
( 
) 
inti=O; 
char Chi 
while(cin.get(ch) && ch!='\n') buf(i++1 = chi 
bu([i+l1 = 0; 
return buf; 
Of coursc,you wouldn't write something like that! C\'Vhy not? What's sO wrong 
with read_lineO?) However, it is sadly common and comes in many variations, 
such as 
/I dangerously sloppy: 
gets(buO; 
/I read a line into buf 
scanf("%s",buO; 
1/ read a line into buf 
Look up getsO and scanfO in your documentation and avoid them like the 
plague. By "dangerous," we mean that such buffer overnows arc a staple of 
"cracking" - that is, break·ins - on computers. Some implementations now wam 
against getsO and its cousins for exactly tllis reason. 
26.3.3.4 Branching 
Obviously, when we have to make a choice, we may make the wrong choice. 
This makes if-statements and switch-statements good targets for testers. TIlerc 
are two mitior problems to look for: 
Arc all possibilities covered? 
Arc the right actions associated with the right possibilities? 

26.] 
TE STING 
Consider this nonsense function: 
void do_branchl(int x, int y) II messy function 
II undisciplined use of if 
{ 
) 
if (x<O) { 
if (y<O) 
cout« "very negative\n"; 
else 
cout« "somewhat negative\n"; 
else if (x>O) { 
if (y<O) 
cout « "very positive\n"; 
else 
cout « "somewhat positive\n"; 
) 
rn le most obvious en or here is that we "forgot" me case where x is O. When test· 
ing against zero (or for positive and negative values), zero is often forgotten or 
lumped with the wrong case (e.g., considered negative). Also, there is a more sub· 
tic (but not uncommon) error lurking here: the actions for (x>O && y<O) and (DO 
&& y>=0) have "somehow" been reversed. "This happens a lot wim cut-and·paste 
editing. 
'11e more complicated the use of if·statements is, the more likely such errors 
become. From a tester's point of view, we look at such code and try to make sure 
that every branch is tested. For do_branchl 0 the obvious test set is 
do_branch1 (-1 ,-1)i 
do_branch1(-1 , 1)i 
do_branch1 (1 ,-1)i 
do_branch1{1 ,1); 
do_branchl(-l ,O); 
do_branchl(O,-l )i 
do_branchl(1,O)i 
do_branchl (O,l)i 
do_branch1 (0,0); 
Basically, that's the bnlte·force "try all the alternatives" approach after we noticed 
that do_branchl0 tested agaillst 0 using < and >. To catch me wrong actions for 
positive values of x, we have to combine the calls with their desired Output. 
967 

... 
CHAPTER 26 • TESTING 
Dealing with switch-statements is fundamcntaHy similar to dealing with ii-
statements. 
void do_branchl (inl x, int y) 
/I messy function 
1/ undisciplined use of switch 
{ 
} 
if (y<O && y<=3) 
switch (xl { 
case 1: 
coul « "one\n"; 
break; 
case 2: 
cout « "two\n"; 
case 3: 
cout « "three\n"; 
} 
Here we have made fOUf classical mistakes: 
We range checked the wrong variable (y instead of x). 
"Ve forgot a break statement leading to a wrong action for )(==2. 
We forgot a default case (thinking we had taken care of that with lhe if-
statement). 
We w rolC ydJ when we meant to say (ky. 
As testers, we always look for unhandlcd cases. Please nme that 'just rlXing the 
problem" is not enough. II may reappear when we arc not looking. As testers, we 
want to write tests that systematically catch crrors. If we juSt ftxed this simple 
code, we may very well get our fix wrong so that it either doesn't solve the prob-
lem or introduces new and different errors. 111e purpose of looking at the code is 
not really to spot errors (though that's always useful), but to design a suimble set 
of tests that will catch all errors (or, more realistically, will catch many errors). 
Note that loops have an implicit "if": they test whether we have reached the 
end. 111US loops arc also braJlching statements. When we look at programs COIl-
taining branching, me [rrst question is always, "'Have we covered (tested) every 
branch?" Surprisingly that is nOt always possible in real code (because in real 
code, a function is called as needed by other functions and not necessarily in all 
possible ways). Consequently, a common question for testers is, "\Vhat is your 
code coverage?" and the answer had better be, "We tested most branches," fol-
lowed by an explanation of why the remaining branches arc hard to readl. 1000f0 
coverage is the ideal. 

2 6 .3 
TE STI N G 
26.3.4 System tests 
Testing any significant system is a skilled job. For example, the testing or the COIll-
puters that control telephone systems takes place in specially constructed rooms 
with racks rull or computers simulating thc traffic or tens or thousands or people. 
Such systems cost millions and are the work or teams or very skilled engineers. 
After it is deployed, a main telephone switch is supposed to work continuously 
ror 20 years with at most 20 minutes or downtime (ror any reason, including 
power railures, flooding, and earthquakes). We will not go into detail here - it 
would be easier to leach a physics rreshman to calculate course corrections ror a 
Mars probe - but we'll try to give you some ideas that could be usdul ror a 
smaller project or ror understanding the testing or a larger system. 
First or all, please remember that the plllpose or testing is to find errors, es-
pecially potentially rrequent and pOlentiaHy serious en·ors. It is not simply to 
write and run the largest number or tests. TIlis implies that some understanding 
or the system being tested is highly desirable. Even more than ror unit testing, cr· 
fective system testing relics on knowledge or the application (domain knowl-
edge). Developing a system takes more than just knowledge or programming 
language issues and computer science; it requires an understanding or the appli· 
calion areas and or the people who use the applications. "nlis is somellung we 
find important ror motivating us to work with code: we get to sec so many inter· 
esting applications and meet interesting people. 
For a complete system to be tested, it has to be built out or all or its parts 
(units). "nlis can take significant time, so many system tests are run just once a 
day (often at night while the developers are supposed to be asleep) arter all unit 
tests have been done. Regression tests arc a key component here. TIle areas or a 
program in which we are most likely to find errors are new code and areas or 
code where errors were round earlier. So running the collection or old tests (the 
rq,rression tests) is essential; without those a large systcm will nevcr become sta-
ble. Wc would introduce new bugs as rast as we removed old ones. 
Note that we take it ror granted that when we fix a rew errors, we acciden-
tally introduce a rew new ones. We hope the number or new bugs is lower than 
the number or old ones that we removed, and that the consequences or the new 
ones are less severe. However, at least until we have rerun our regression tests 
and added new tests ror our new code, we must assume that our system is bro-
ken (by our bug fLxes). 
26_3.4.1 Testing GUls 
Imagine sitting in front of a screen trying to be systematic about testing a pro-
gram with an elaborate graphical user interrace. \rVhere do I click lhe mOllse? In 
what order? What values do I enter? In what order? For any sigIuficant program, 
this is hopeless. TI1cre are so many possibilities that we could consider hiring a 
969 

.7. 
CHAPTER 2 6 • TESTING 
whole bunch of pigeons to peck at the screen at random (they work for bird 
feed!). Hiring large numbers of "ordinary novice users" and seeing where they 
"peck" is indeed not uncommon and also necessary, but it is not a systematic 
strategy. Any rcaJ solution has to involve some repeatable sequence of tcsts. 111i5 
typically involves designing an interface to the application that bypasses the 
CUI. 
Why is it necessary to sit a human in front of a CUI application and " pcck~? 
The rcason is simply that testers cannot anticipate every action llml a devious, 
clumsy, naive, sophisticated, or hurried user can make. Evell with the best and 
most systematic testing, we still need real people LO try out the system. Experi-
ence shows that for any significant system real users will do things that even ex· 
perienced designers, implementers, and testers have failed to anticipate. Or as a 
programmer's proverb has it, "As soon as you build a foolproof system. nature 
produces a belter fooL" 
So, the ideal for testing is that the CUI simply composes calls to some well· 
defined interface to the "main program"; that is, the CUI simply provides 1/0, 
and any significant processing is done in isolation from 1/0. Doing this implies 
that we can provide a different (non-graphical) interface: 
User 
User 
I 
I 
CUI 
Text 1/0 
~ 
~ 
"Main program" 
11mt allows us to write or generate scripts for the "main program" just as we did 
for our unit testing (§26.3.2)_ 111cn we can test the "main program" in isolation 
from the CUI: 

26.3 
TESTING 
Test output 
Script 
~/ 
Text 110 
~ 
"Main program" 
Intcrestingly, this also allows us to sem.i-systematica.lly test the GUI: we can run 
scripts using the text 110 and watch the effect on the CU I (assuming that we 
send the output frOill the main program to the CU I as well as lhe text-lIO inler-
face). More radically, we might bypass the "main application" while we test lhe 
CU I by providing text commands that go "directly" to the CUI through a little 
text-to-C U I·command "translator": 
Test output 
Script 
T ~/ 
CUI 
, 
Text 110 
a 
'----... /" 
n s 
I a 
t 
0 , 
lllis illuslratCS twO important aspects of good testing: 
ParLS of a system should (as far as possible) be testable in isolation. Only 
"uniLS" with clearly defined interfaces arc testable in isolation. 
TesLS should (as far as possible) be repeatable. Essentially no test that in-
volves a human is repeatable. 
971 

972 
CHAPTER 26 • TESTING 
This is also an example of the "design for testing" that we have alluded to: some 
programs arc far easier to test than others, and if we think about testing from the 
very onset of OUf design, we can build systems that arc beuer organized and eas-
ier to test (§26.2), Better organized? Consider: 
User 
I 
Program with 
CUI 
This diagram is obviously simpler than u1e diagrams above. We CaJl start build-
ing this system with less forethought - just use our favorite GUllibrary wher-
ever in the code we need to communicate with the user. It will probably also 
require less code than OUf hypothetical application with both text and graphical 
1/0. How then can our application using an explicit interface and morc parts be 
better organized than a "simple and straightforward" application where the CUI 
logic is dispersed throughout the code? 
Well, to have twO interfaces, we need to carefully define the interface be-
tween the "main program
n and 110. In fact, we have to define a common 110 in-
terface layer (similar to the "translator" we used to lcst the CUI in isolation from 
the "main program": 
CUI 
Text I/O 
~ 
~ 
110 interface 
"Main program" 

26 .3 
TESTING 
We have seen an example or this: the graphical interrace classes in Chapters 13-
16 provided an example. 111ey isolate a "main program" (that is, the code you 
wrote) from the "ofT·the-sheW' CUI system: FLTK, Windows, Linux's CU I, 
whatever. With this design we can usc any 110 system. 
Is this importam? We think it is immensely so. First, it helps testing, and 
withollt systematic tcsting it is hard to be serious about correctness. Second, it of. 
rers portability. Considcr the following scenario: You have started a small com-
pany and writtcn your initial application for an Apple because you happen to like 
that computcr. 
ow, your company is getting sllccessful, and you notice that 
most or your potential customers run their programs on Windows machines and 
non-Mac Linux systems. \"'hal do you do? With the "simple" organization of the 
code with (Apple Mac) CUI commands scattered throughout your code, you 
must rewrite everything. That's OK, because it (relying on ad hoc testing) proba-
bly has many hidden errors. But consider the altemative where the "main pro-
gram" kept the CUI at arm's length (to simplify systematic testing). Now you 
simply interrace another CUI to your interface classes (the "translator" on the di-
agram) and keep most code unchanged across systems: 
GUI 3 
GUI 2 
GUl l ~~ 
Text 110 
110 interface 
"Main program" 
Actually, this design is an example of the use or "thin" explicit interraces to ex-
plicitly separate parts of a program. Il is similar to the usc of "layers" that we saw 
in §12.4. l Csting really reinforces the desire to have a program partitioned into 
clearly delimited parts (with interraces that we can use for testing). 
26.3.5 Testing classes 
l csting a class is technically unit testing, but since there arc typically several 
member functions and some state involved, testing a class takes on aspects of sys· 
tem testing. This is even more true if the class we are trying to test is a base class, 
973 

974 
CHAPTER 26 • TEST IN G 
so that we have to consider it in several contexts (as defined by different derived 
classes). Consider the Shape class from §14.2: 
class Shape ( 
/I deals with color and style, and holds sequence of lines 
public: 
void drawO canst; 
/I deal with color and draw lines 
virtual void move(int dx, int dy); 
void seccolor(Color col); 
Color colorO consl; 
void scCstyle<line_style sty); 
Line_style style() const; 
void sel_fill_color(Color col); 
Color fill_colorO const; 
Point poinl(inl i) const: 
int number_oCpointsO const; 
virlual -Shape() ( ) 
/I move the shape +=dx and +=dy 
/I read-only access 10 points 
protected : 
ShapeO; 
virtual void draw_linesO const; 
void add(Point pI; 
/I draw the appropriate lines 
/I add p 10 points 
void seCpoinl(int i,Point pI; 
private: 
/I points[i[=p; 
}; 
vector<Point> points; 
II not used by all shapes 
Color !color; 
/I color for lines and characters 
line_style Is; 
Color fcolor; 
/I fill color 
Shape(const Shape&); 
/I prevent copying 
Shape& operator=(const Shape&); 
How would wc go about tcsting thal? Let's first consider what (from a testing 
point of view) makes Shape different frOIll binary_search: 
Shape has scveral functions. 
A Shape has a mutable state (we can add points, change color, ctc.); that 
is, lhe effect of one function can affect the behavior of anothcr function. 

26. 3 
TE STIN G 
Shape has virtual functions; that is, the behavior of a Shape depends on 
what (if any) class has been derived from it. 
Shape is not an algOl;thm. 
A change to a Shape can bave an effect on t.he screen. 
111e last point is really nasty. This basically means that we have to have a human 
sit and watch to see if a Shape behaves as intended. 11lis is not conducive to sys-
tematic, repeatable, and affordable testing. As mentioned in §26.3.4.! , we'll often 
go out of our way to avoid that. However, for now, we will assume an alert 
watcher who'll note if the image on the screen deviates from what was required. 
Note an important detail: a user can add points, but not remove them. A user 
or a Shape can read points, but not change them. From the point of view of lest-
ing, anything that does not (or at least isn't supposed to) cllllnge eases our work. 
What can we test and what can't we test? To test Shape, we must try to test 
in isolation and in combination with a couple of derived classes. However, to test 
that Shape works correctly for a particular derived class, we have to test that de-
rived class. 
We note that basically a Shape has a state (value) defined by four data 
members: 
vector<Poinl> points; 
Color leolor; 
/I color for lines and characters 
Line_style Is; 
Color fcolor; 
II fill color 
All we G,n do to a Shape is to make changes to those and see what happens. For· 
tunately, the only way to change the data members is through the interface de-
fined by the member functions. 
The simplest Shape is a Line, so we start (using the most naive style) by mak-
ing one and then making all the changes we can: 
Line In(Point(10,10), Point(l00, 100)); 
In.drawO; 
II see if it appears 
/I check the points: 
if (In.number_oCpoinlsO != 2) cerr« "wrong number of points"; 
if (In.poinl(0)!=Point(10, 10» cerr« "wrong point 1"; 
if (In.point(l)!=Point(l00, 100)) cerr« "wrong point 2"; 
for (int i=O; i<10; Hi) { 
In.move(i+S,i+S); 
In.drawO; 
} 
II see if it moves 
.75 

976 
CHAPTER 26 • TESTING 
for (int i=O; i<10; ++i) { 
In.move(i-5,i-5); 
In.drawO; 
II see jf it moves back to where it started 
if (point(O)!=Point(10, 10)) cerr« "wrong point 1 after move"; 
if (point(l )!=Point(l00,l00» cerr« "wrong point 2 after move "; 
for (int i = 0; i<100; ++i) { 
/I see if the color changes correctly 
In. seC color(Color(i· ' 00» ; 
} 
if (In.colorO != j· l 00) (err « "bad set_colo r"; 
In.draw(); 
for (int i = 0; i<l00; Hi) { 
/I see if the style changes correctly 
In. seCstyle(li ne_style(j· 5); 
} 
if On.styleO != jeS) cerr « "bad sel_style"; 
In.drawO; 
In principle, this tCStS creation, movement, color, and style. In reality, we need to 
pick our leSt cases far more carefully (and deviously), just as we did for 
binary_search. Again, we will almost certainly conclude that reading in a descrip-
tion of what tests to run from a file is a beuer solution and we'll find a beuer way 
of reporting errors_ 
Also, we'll find that no human can kcep up with the changes to the Shape, so 
we have just two alternatives. We can 
Slow down the program so that a human can keep up 
Find a representation of the Shape that we can have a program read and 
analyze 
What is almost completely missing so far is testing of add{Poinl). For that, we'd 
probably use an Open_polyline. 
26.3.6 Finding assumptions that do not hold 
TIle specification of binary_search clearly stated thai the sequence in which we 
scaldl must be sorted. TImt deprived us of many opportunities for sneaky unit 
tests. But obviously there arc opportunities for writing bad code that we have not 
devised tests to detect (except for the system tests). Can we usc our understand-
ing of a system's "units" (functions, classes, etc.) to devise better tests? 
Unfortunately, the simplest answer is no. As pure testers, we cannot change 
the code, but to detect violations of an interface's rcquiremems (pre-conditions), 

26.3 
TESTING 
someone must either check before each call or as part of the implementation of 
each c,111 (see §5.5). However, if we are testing our own code, we can insert such 
tcsts. If we arc testers and the people who write the code will listen to us (that's 
1I0t always the case), we can teU them about the unchecked requirements and 
have them ensure that they arc checked. 
Consider again binary_search: we couldn't test that the input sequence 
[firsl:lasl) really was a sequence and mat it was sorted (§26.3.2.2). However, we 
could write a function that docs check: 
templale<c1ass Iter, class T> 
bool b2(lter first, Iter last, canst T& value) 
{ 
/I check if Ifirst:lastl is a sequence: 
if (Iastd irst) throw Bad_sequence(); 
II check if Ihe sequence is ordered: 
if (2<1asl- first) 
for (ller p = firsl+l ; p<last; ++p) 
if (·p<-(p- 1» throw NOI_orderedO; 
II all's OK, call binary_search: 
return binary _search(firsl,last,value); 
Now, there are reasons why binary_search isn't written with such tests, including 
these: 
111e test for lastdirst can't be done for a forward iterator; for example, 
the iterator for std : :Iist docs not have a < (§B.3.2). In general, mere is no 
really good way of testing lhat a pair of iterators defines a sequence 
(starting to iterate from first hoping to meet last is not a good idea). 
Scantling the sequence to check that the values are ordered is far more 
expensive man executing binary_search itself (the real purpose of 
binary_search is not to have to blindly walk through the sequence look-
ing for a value the way sid : :find does). 
So what could we do? We could replace binary_search with b2 when we are tCSt-
ing (only for calls to binary_search with random-access iterators, though). Alter-
natively, we could have the implementer of binary_search insert code that a 
tester could enable: 
.77 

978 
( HAPTER 26 • TESTING 
template<dass Iter, class T> 
1/ warning: contains p~udo code 
bool binary_search (Ite r first, Ite r last, const T& value) 
( 
) 
if (Iesl e nabled) { 
) 
if (Iter is a random access iterator) ( 
II check if [first last) is a sequence: 
if (lasld irst) throw Bad_scquence()i 
/I check if the sequence is ordered: 
if (first! =la51) { 
Iter prey = first; 
for (Iter p = ++firsti p! =laslj ++p, ++ prey) 
if (·p<·prev) throw Not_orderedOj 
/I now do binary_search 
Since the meaning of test e nabled depends on how testing of code is arranged 
(for a specific system in a specific organization), we have left it as pseudo code: 
when testing yOllr own code, you could simply have a lesCenabled variable. We 
also left the Iter is a random access iterator test as pseudo code because we 
haven't explained "iterator traits." Should you really need such a test, look up 
ileralor traits in a more advanced C++ textbook. 
26.4 Design for testing 
When we start writing a program, we know that we would like it to evelllually be 
complete and correct. We also know that to achieve that, we must test it. Conse-
quentJy, we try to design ror correctness and testing rrom day one. In ract, many 
good programmers have as their slogan "Test early and orten" and don't write 
any code before they have some idea about how they would go aboUl testing it. 
Thinking abOlll testing early helps to avoid errors in the first place (as well as 
helping to find them later). We subscribe to that philosophy. Some programmers 
even write unit tests before they implement a unit. 
111c cxample in §26.3.2.1 and the exan1plcs in §26.3.3 illustrate these key 
notions: 
Usc well-defined interraees so that you can write tests ror the usc or tJlcse 
interraces. 
Have a way or rcpresellling operations as text so that they can be stored, 
analyzed, and replayed. TIlls also applies to output operations. 

26 .6 
PERFORMANCE 
Embed tests of unchecked assumptions (assertions) in the calling code to 
catdl bad aJ'guments before system testing. 
Minimize dependencies and keep dependencies explicil. 
Have a dear resource management strategy. 
Philosophically, this could be scen as enabling unit-testing techniques for sub-
systems and complete systems. 
If performance didn't malter, we could leave lhe test of the (otherwise) un-
checked assumptions (requirements, pre-conditions) enabled all the time. How-
ever, there arc usually reasons why they are not systematically checked. For 
example. we saw how checking whether a sequenee is sorted is both complic.'1ted 
and far more expensive than using binary_sort. Consequently, it is a good idea to 
design a system that allows us to selectively enable and disable such checks. For 
many systems, it is a good idea 10 leave a fair number of the cheaper dlecks en-
abled even in the final (shipping) version : sometimes "impossible" things happen 
and we would prefer to know about them from a specific error message ralher 
than from a simple crash. 
26.5 Debugging 
Debugging is an issue of technique and attitude. Of these, attitude is the more un· 
portant. Please revisit Chapter 5. Note how debugging and testing diJTer. Both 
catch bugs, but debugging is much more ad hoc and typically concerned witll re-
moving known bugs and implementing features. \Vhatever we can do to make 
debugging more like tcsting should be done. It is a slight exaggeration to say that 
we love tesling, but we definitely hate d ebu~rj ng. Good early unit testing and de-
sign for tesling help minimize debugging. 
26.6 Performance 
Having a prObrram correct is not enough for it to be useful. Even assuming that it 
has sufficient facilities to make it useful, it must also provide appropriate per-
formance. A good program is "efficient enough"; that is, it will run in an accept-
able time given the resources available. Note thal absolute efficiency is 
uninlcresting, and an obsession with geuing a program to run fast can seriously 
damage development by complicating code (leading to more bugs and more de-
bugging) and making maintenance (including porting and performance tuning) 
more difficult and costly. 
So. how can we know that a program (or a unit of a program) is "efficient 
enough"? In the abstract we cannot know, and for many programs the hardware 
is so fast that the question doesn't arise. We have seen products shipped that were 
compiled in debug mode (i.e., running about 25 timcs slower than necessary) to 
9,., 

980 
C HAPTER 26 • TE STI NG 
enable better diagnostics for errors occurring after dcploymem (this can happen 
to even the best code when it has to coexist with code developed "elsewhere"). 
Consequently, the answer to the "Is it efficient enough?" question is : "Mea' 
sure how long interesting lest cases take." To do that, you obviously have to 
know your end users well enough to have an idea of what they would consider 
"interesting" and how much time such interesting lIses can acceptably take. Logi-
cally, we simply clock our tests with a stopwatch and check that none consumes 
an unreasonable amount of time. This becomes practical when we usc functions 
such as clockO (§26.6.1) to do the timing for us, and we call automatically com-
pare the time taken by tests with estimates of what is reasonable. Alternatively (or 
additionally) we can record how long tests take and compare them to earlier tests 
runs. 111is way we get a form of regression test for perfonnance. 
Some of the worst performance bugs arc caused by poor algorithms and mil 
be found by testing. One reason for tcsting with large sets of data is to expose in· 
efficient algoritlmls. As an example, assume that an application has to make sums 
of the elements in rows of a matrix (using the Matrix library from Chapter 24). 
Someone supplied an appropriate function: 
double row_sum(Matrix<double,2> m, int n)i 
/I sum of elements in mIni 
Now someone uses that to gencrate a vector o f sums where vln] is the sum of the 
elements of the first n rows: 
double row_accum(Matrix<double,b m, int n) 
II sum of elements in mIO:n) 
{ 
) 
double s = 0; 
for (int i=O; kn; ++n) s+=row_sum(m,i); 
return Si 
/I compute accumulated sums of rows of m: 
vector<double> v; 
for (int i = 0; i<m.dim10; ++i) v.push_back(row_accum(m,i+1)); 
You c<m imagine this to be part of a unit test or executed as part of the application 
exercised by a system test. In either case, you will notice something strange if the 
matrix ever gets really large: basically, the time needed goes up with the square 
of the size of m. VVhy? What we did was to add all the clements of tile first row, 
then we added all the elements in the second row (revisiting all tile elements of 
the first row), then we added all the clements in the tllird row (revisiting all tile cl· 
ements of the first and second rows), etc. 

26 .6 
PER FO RMAN CE 
If you think this example was bad, consider what would have happened if 
the row_sumO had had to access a database to get its data. R('ading from disk is 
many thousands of times slower lhan reading from main memory. 
Now, you may complain: ;';Nobody would write something that stupid!" 
Sorry, but we have seen much worse, and usually a poor algorilhm (from the per· 
fonnance point of view) is nOt that easy to spot when buried in application code. 
Did you spot the performance problem when you first glanced at the code? A 
problem can be quitc hard to spot unless you are specifically looking for that par-
ticular kind of problem. Here is a simple real-world example found in a server: 
for (int i=O; kSlrle n(s); ++i) {' . do something with slil .' } 
Often, s was a string with about 20K characters. 
Not all performance problems have to do with poor algorithms. In fact (as 
we pointed out in §26.3.3), much of the code we write does not classify as proper 
algorithms. Such '·non-algorithmic" performance problems typically fall under 
the bro.1d classification of "poor design." They include 
Repeated recalculation of information (e.g., the row-summing problem 
above) 
Repeated checking of the same fact (e.g., checking that a.n index is in 
range each lime it is used in a loop or checking an argument repeatedly 
as it is passed unchanged from function to function) 
Repeated visits LO the disk (or to lhe web) 
Note the (repeated) re/x atefl. Obviously, we mean "unnecessarily repeated," but 
the point is that unless you do something many times, it will nOt have an impact 
all performance. We arc all for thorough checking of function arguments and 
loop variables, but if we do the same check a million times for the same values, 
those redundant checks JUSt might hun performance. If we - by measurement -
find that performance is hurt, we will try to sec if we can remove a repeated ac-
tion. Don't do that unless you arc sure that perfollllance is really a problem. Pre-
mature optimization is the source of many bugs and much wasted time. 
26.6.1 Timing 
!-low do you know if a piece of code is fast enough? How do you know how long 
an operation takes? Weil, in many cases where it matters, you can simply look at 
a clock (stopwatch, wall clock, or wristwatch). 111at'S not scientific or accurate, 
but if t.hat's not feasible, you can often conclude that the program was fast 
enough. It is not good to be obsessed Wilh perfonnance. 
If you need to measure smaller increments of time or if you can't sit around 
with a stopwatch, you need to get your computer to help you ; it knows the time 
981 

982 
CHAPTER 26 • TESTING 
and can give it to yOll. For example, on a Unix system, sim ply prcGxing a com-
mand with time will make the system print out the time taken. You might usc 
time to figure out how long it takes to compile a C++ SOUfce file x.cpp. Nor-
mally, you compile it like this: 
g++ x.cpp 
·10 get that compilation timed, you juSt add time: 
time g++ x.cpp 
111is will compile x.cpp and also print the time taken on the screen. TIlis is a sim-
pic and effective way of timing small programs. Remember to always do several 
timing mns because Mother activities" on your machine might interfere. If you gct 
roughly the same answer lhree times, you can usually OUSt the resull. 
BUl what if yOli want to measure something that takes juSt milliseconds? 
\.vhal if yOll want to do your own, morc detailed, measurements of a parl of a 
program? You use the standard library function clockO LO measure the time lIsed 
by a function do_somethingO like this: 
.include <ctime> 
#include <iostream> 
using namespace sid; 
int mainO 
{ 
int n = 10000000; 
clock_t t1 = clockO; 
if (11 == clock_I(-1)) { 
II repeat do_somethingO n times 
II start time 
II clock_t(- l ) means "clockO didn't work ~ 
(err« "sorry, no clock\n"; 
exit(l); 
} 
for (int i = 0; kn; i++) do_somelhingO; 
II timing loop 
clock_t 12 = clock(); 
II end time 
if (t2 == clock_t(- l » { 
cerr « "sorry, clock overflow\n"; 
exit(2); 
} 

26. 7 
REFERENCES 
) 
cout « "do_somethingO " «
n «
" times took " 
«
double(t1-I1)/CLOCKS_PER_SEC« " seconds" 
« n (measurement granularity: " 
«ClOCKS_PER_SEC«
" of a second)\n "; 
The clockO function retums a result of type clock_I. TIle explicit conversion 
double(t2-t1 ) before dividing is necessary because clock_I might be an integer. 
Exactly when the clockO starts running is implememaLion defined; clockO is 
meant to measure time intervals within a single run of a program. For the values 
11 and t2 retumed by c1ockO, double(t2-tT)/CLOCKS_PER_SEC is the system's 
best approximation of the lime in seconds between the two calls. You'll find 
CLOCKS_PER_SEC ("clock ticks per second") in <clime>. 
If clockO isn't provided for a processor or if a time interval is too long to 
measure, clockO retums clock_t<-1). 
TI1C clockO function is meant to measure intervals from a fraction of a sec-
ond to a few seconds. For example. if (as is nOt. uncommon) clock_I is a 32-bit 
signed int and CLOCKS_PER_SEC is 1000000, we can use clockO to measure from 
o to just over 2000 seconds (about half an hour) in microseconds. 
Again, don't believe any lime measurement that you cannot repeat with 
roughly the same result three limes. What docs "roughly the same" mean? 
"Wtdlin 10010" is a reasonable answer. Remember that modem computers arefasl: 
1,000,000,000 inSlnlctions per second is common. 111is implies that you won't be 
able to measure anything unless you can repeat it tens of thousands of times or it 
docs something really slow, such as writing to disk or accessing the web. In the 
laner case, you just have to get it to repeat a few hundred tUnes, blll you have to 
worry that so much is going on that you might not understand the results. 
26.7 References 
Stone, Debbie, Caroline Jarrett, Mark WoodrofTe, and Shailey Minocha. User Ill/er-
face Design atul Evaluahim. Morgan Kaufmann, 2005. ISBN 0120884364. 
'¥hiuaker, James A. Huw 10 BreaR Sifiwllre: A Prllctical Gui.de 10 Testing. Addison-
We,ley, 2003. ISBN 0321194330. 
983 

984 
CHA PTER 26 • TESTING 
".; Drill 
Get the lcst of binary_search to run : 
1. Implement the input operator for Test from §26.3.2.2. 
2. Complete a ftlc OftCSls for the sequences from §26.3: 
a. {1,2,3,5,8, 13,2l} 
/I an "ordinary sequence ~ 
b. {) 
c. {1 } 
d. {1 ,2,3,4 } 
/I even number of elements 
c. {1,2,3,4,5} 
/I odd number of elements 
f. {1, 1, 1, 1, 1, 1, 1 } 
/I alJ elements equal 
g. (0,1,1,1,1,1,1,1,1,1,1,1,1 } 
/I different element at end 
h. (0,0,0,0,0,0,0,0,0,0,0,0,0,1 } 
/I different clement at end 
3. Based on §26.3.1.3, complete a program .. hat generates 
a. A very large sequence (what would you consider very large, and why?) 
b. Ten sequences with a random number of clements 
c. Ten sequences with 0, 1, 2 ... 9 random clements (but still ordered) 
4. Repeat these tests for sequences of soings, such as ( Bohr Darwin Einstein 
lavoisier Newton Turing). 
Review 
1. Make a list of applications, each with a brief explanation of the worst 
thing tlm can happen if there is a bug; e.g., airplane control - crash: 231 
people dead; $500M equipment loss. 
2. Why don't we just prove our programs correct? 
3. What's the difference between unit testing and system testing? 
4. What is regression testing and why is it important? 
5. What is the purpose of testing? 
6. Why doesn't binary_search just check its requirements? 
7. If we can't check for all possible errors, what kinds of errors do we pri~ 
marily look for? 
8. Where al·e bugs most likely to occur in code manipulating a sequence of 
elemellls? 
9. Why is it a good idea to test for large values? 
10. Why do we often represent tests as data rather than as code? 
II. Why and when would we lise lots of tests based on random values? 
12. Why is it hard to test a program using a CUI? 
13. What is needed to test a "unit" in isolation? 
14. What is the connection between testability and portability? 

C HAPTER 26 EXERCISES 
15. What makes testing a class harder than testing a function? 
16. Why is it impommt lhal tests be repeatable? 
17. Whm can a tester do when finding mat a "unit" relies on unchecked as~ 
sumptions (pre-conditions)? 
18. What can a designer/implementer do to improve testing? 
19. How docs testing differ from debugging? 
20. \"'hen docs performance matter? 
2 J. Give twO (or more) cxamples of how to (easily) create bad perfonnance 
problems. 
Terms 
assumptions 
black·box testing 
branching 
d ockO 
design for tcsting 
inputs 
Outputs 
Exercises 
post-condition 
pre-condition 
proof 
rcgrcsslon 
resource usage 
state 
system test 
test covcrage 
test harness 
testing 
timing 
unit test 
white· box testing 
I. Run your binary search algorithm [rom §26. ! wilh the tests prescnted in 
§26.2.1. 
2. Modify thc lesling of binary_search LO deal with arbitrary element types. 
"111cn, test it with siring sequences and noaling-point sequcnces. 
3. Repeat the exercise in §26.2.1 with the version of binary_search thal 
takes a comparison criterion. Make a list of new opportunities for errors 
illlroduced by that extra argument. 
4. Devise a fonnm for test data so t.hat you can define a sequence once and 
n m several tests against. it. 
5. Add a tesltO the set. of binary_search tests to try to cat.ch the (unlikely) 
error of a binary_search modifying the sequence. 
6. Modify the calculmor from C hapter 7 minimally to let it take input from a 
ftle and produce output. to a file (or usc your operating syslem's facilities 
for redirecting 110 ). TIlcn devise a reasonably comprehensive test for it. 
7. Test I.he "simple lext editor" from §20.6. 
8. Add a text-based interface to the graphics interface library from Chaplcrs 
12-15. For example, the string Cirde(PoinI(O,1),15) should generate a 
can Circie(Poinl(O,1),15). Use this text interface to make a "kid's draw-
ing" of a two·dimensional hOllse with a roof, two windows, and a door. 
985 

... 
CHAPTER 26 • TESTI NG 
9. Add a text-based output format for the graphics interface library. For 
exam ple, when a call Circle(Poinl(O,1),15) is executed, a string like 
Cirde(Point(O,1),15) should be produced on an autpUl stream. 
10. Usc the tcxt-based interface from exercise 9 to write a better test for t.he 
graphical interface library. 
11 . Time the sum example frOIll §26.6 with m being square matrices with di· 
mensions 100, 10,000, 1,000,000, and 10,000,000. Use random element 
values in the range [-10: 10). Rewrite the calculation of v to usc a more ef· 
ficient (not 0 (n"2») algorithm and compare the timings. 
12. Write a program that generates random floating-point numbers and SOrt 
them using sid : :sorIO. Measure lhe time used to SOrt 500,000 doubles 
and 5,000,000 doubles. 
13. Repeat the experiment in the previous exercise, but with random strings 
of lengths in the [0: 100) range. 
14. Repeat the previous exercise, except using a map rather than a vector so 
that we don't need to son . 
Postscript 
As prognunmers, we dream about writing beautiful programs that just work -
preferably the Hrst time we try them. TIle reality is different: it is hard to get pro· 
grams right, and it is hard to get them to stay right as we (and our colleagues) 
work to improve them. Testing - including design for testing - is a major way of 
ensuring that the systems we ship actually work. Whenever we reach the end of 
a day in our highly technological world, we really ought to give a kind thought to 
the (often forgotten) tcsters. 

1. . 
1"27 
The C Programming 
Language 
"C is a strongly typed, 
weakly checked, 
programming language." 
-Dennis Ritchie 
T
his chapter is a bl;ef overview of the C progranuning lan-
guage and iLS standard library from the point of view of 
someone who knows C++. It lists the C++ features missing 
from C and gives examples of how a C programmer can cope 
withollt those. C/C++ incompatibilities are presemed, and CJC++ 
interoperability is discussed. Examples of 110, list manipulation, 
memory managemem, and string manipulation are induded as 
illustration. 
987 

988 
CHAI'TER 27 " THE C PROGRAMMING LANGUAGE 
27.1 C and c++: siblings 
27.4 Free store 
27.1.1 CJC++ compatibility 
27.1.2 C++ features missing from C 
27.1.3 The C standard library 
27.2 Functions 
27.2.1 No function name overloading 
27.2.2 Function argument type 
checking 
27.2.3 Function definitions 
27.2.4 Calling C from C++ and c++ 
from C 
27.2.5 Pointers to functions 
27.3 Minor language differences 
27.3.1 struct tag names pace 
27.3.2 Keywords 
27.3.3 Definitions 
27.3.4 C·style casts 
27.3.5 Conversion of void" 
27.3.6 en um 
27.3.7 Namespaces 
27.1 C and c++: siblings 
27.5 C-slyle strings 
27.5.1 C·style strings and conSI 
27.5.2 Byte operations 
27.5.3 An example: sltcpytl 
27.5.4 A style issue 
27.6 Input/output : stdio 
27.6.1 Output 
27.6.2 Inpul 
27.6.3 Files 
27.7 Constants and macros 
27.8 Macros 
27.8.1 Function·like macros 
27.8.2 Syntax macros 
27.8.3 Conditional compilation 
27.9 An exampl : intrusive containers 
-111C C programming language was designed and implemcntcd by Dcnnis Ritchie 
at lkll Labs and popularized by the book rile C Programmillg umguage by Brian 
Kernighan and Dennis Ritchie (colloquially known as "K&R"), which is arguably 
still the best introduction to C and one of the great books on programming 
(§22.2.5). TIle text of the original definition of C++ was an edit of lhe text of the 
1980 definition of C , supplied by Dennis Ritchie. After this initial branch, both 
languages evolved further. Like C++, C is now defined by an ISO standard. 
We see C primarily as a subset of C++. ' 1lUS, from a C++ point of view, the 
problem of describing C boils down to two issues: 
Describe where C isn't a subset of C++. 
Describe which C++ features are missing in C and which facilities and 
techniques can be used to compensate. 
Historically, modern C and modern C++ are siblings. Both arc direct descen· 
dants of "Classic C," thc dialect of C popularized by the first edition of 
Kernighan and R.itchie's 77u! C Progmmming wngtulge plus structure assignment 
and enumerations: 

2 7. 1 
C AND C++; SIBLING S 
1967 
~~u!y 
, , , , , , , , , 
1978 
1980 
1985 
• 
1989 
1998 
, , , , , , , , , , , , , , 
C with Classes 
EadyC++ 
'11e version orc that is used almost exclusively today is C89 (as described in the 
second edition or K&R), and that's what we are describing here. '11ere is still 
some Classic C in usc and a rew examples or C99, but those should not cause 
you any problems when YOLI know C++ and C89. 
Both C and C++ were "bam" in the Computer Science Research Celller or 
Bell Labs in MUI1<lY Hill, New J ersey (ror a while, my office was a couple or doors 
down and across the corridor rrom those or Dennis Ritchie and Brian Kem.igh,m): 
989 

( HAPTER 27 " T HE ( PROGRAMMING LANGUAGE 
Both languages arc now defined/controlled by ISO standards committees. For 
each, many supported implementations arc in usc. Often, an implementation 
supports both languages with the desired language chosen by a compiler switch 
or a source file suffix. Both afe available on more platforms than any other Ian· 
guage. Both were primarily designed for and arc now heavily used for hard sys· 
tem programming tasks, such as 
Operating system kemels 
Device drivers 
Embedded systems 
Compilers 
Communications systems 
lllere arc no performance differences between equivalent C and C++ pro· 
grams. 
Like C++, C is very widely used. Taken together, the C/C++ commlmity is 
the largcst software development cOIlUllUnity on earth. 
27.1.1 ( /(++ compatibility 
It is not uncommon to hear referenccs to "C/C++." However, there is no such 
language, and the usc of "C/C++" is typically a sign of ignorance. Wc use 
"C/C++" only in the context of C/C++ compatibility issues and when talking 
about the large shared C/C++ technical community. 
C++ is largely, but not completely, a superset of C. With a few very rare ex-
ceptions, constructs that are both C and C++ have the same meaning (seman· 
tics) in both languages. C++ was designed to be "as close as possible to C, but 110 
closer": 
For case of transition 
For coexistence 
Most incompatibilities relate to C++'s stricter type checking. 
An example of a program that is legal C but not C++ is one that uses a C++ 
keyword that is not a C keyword as an identifier (sec §27.3.2): 
int class(int new, inl boo]); 
r C, but not c++ "' 
Examples where the semantics differ for a construct that is legal in both Ian· 
guages are harder to find, but here is one: 
int s = sizeoi('a'); 
'0 
sizcof(inl), often 4 in C and I in C++ "' 

27. 1 
C AND C++: SIBLINGS 
-nlc typc or a character literal, sllch as 'a', is int in C and char in C++. However, 
ror a char variable ch \ .... e have sizcof(ch)==l in both languages. 
Inrormation related to compatibility and language differences is nOl exactly 
exciting. -m ere arc no new neat programming techniques to leill·n. You might like 
printfO (§27.6), but with that possible exception (and some reeble attempts at 
geek humor), this chapter is bone dry. Its purpose is simple: to allow YOll to read 
and write C ir you need to. -n lis includes pointing Olll the hazards that are obvi-
OliS to experienced C programmers, but lypically unexpected by C++ program-
mers. \OVe hope you can learn to avoid those hazards with minimal grief 
Most C++ programmers will have to deal with C code at some point or an-
other, just as most C programmers will have to deal with C++ code. Much or 
what we describe in this chapter will be ramiliar to most C programmers, but 
some will be considered "expert level." 111e reason ror that is simple: not every· 
one agrees about what is "expert level" and we just describe what is common in 
real-world code. Maybe understanding compatibility issues can be a cheap way 
or gaining illl unrair reputation as a "C expert." But do remember: real expertise 
is in the usc or a language (in this case C), rather thilll i.n understanding esoteric 
language rules (as arc exposed by considering compalibility issues). 
References 
ISO/IEC 9899: 1999. Programmillg ulIIguageJ - C. 111is defines C99; most imple-
mentations implement C89 (orten with a rcw extensions). 
ISO/IEC 14882:2003-04·0 1 (second edition). Programmillg LanguageJ - C++. From 
a prognmuner's point or view, this standard is idemicalto the 1997 version. 
Kcmighan, Briilll W., and Dennis M. Ritchie. VII! C Pmgrmllmillg Language. Addison-
W",ky. 1988. ISBN 0131103628. 
Stroustrup, Bjame. "Learning Standard C++ as a New Language." CIC++ UJerJ 
]olfnUl/, May 1999. 
Stroustrup, Bjame. "C and C++: Siblings"; "C and C++: A Case ror Compati-
bility": and "C and C++: Case Sllldies in Compatibility." rite CIC++ UJm 
] olfnUl/, July, Aug., illld Sept. 2002. 
l11e papers by Stroustrup arc most easily round on my publications home page. 
27.1 .2 C++ features missing from C 
From a C++ perspective, C (i.e., C89) lacks a lot or fealllres, such as 
Classes and member runctions 
Use struCi and global runctions. 
991 

992 
CHAPTER 27 • THE C PROGRAMMING LANGUAGE 
Derived classes and virtual functions 
Usc structs, global fUllctions, and pointers to functions (§27.2.3). 
Templates and inlinc functions 
Usc macros (§27.8). 
Exceptions 
Usc error codes, error return values, etc. 
Function overloading 
Give each function a distinct name. 
new/delete 
Usc maliocO/freeO and separate initialization/cleanup code. 
References 
Usc pointers. 
consl in constant expressions 
Usc macros. 
Declarations in for-statements and declarations as statements 
Place al1 declarations at the lOp of a block or introduce a new block 
for each set of definitions. 
bool 
Usc into 
stalic_cast, reinlerpreCcast, mId consCcasl 
Usc C -slylc casts, e.g., (inl)a rather than static<int>(a). 
II comments 
Usc '* ... *' comments. 
LOlS of useful code is written in C, so lhis list should remind us that no one lan-
guage feature is absolutely necessary. Most lanb'llage reatures ~ even most C lan· 
guage reatures - arc there ror the convenicnce (only) of the programmer. After 
all, givcn sufficient time, cleverness, and patience, every program can be written 
in assembler. Note that because C and C++ share a machine model that is very 
close LO the real machine, they arc well suited 10 emulate varieties of program-
ming styles. 

27 . 1 
C AN D C++: SIBLINGS 
The rest of this chapter explains how to write useful programs without those 
features. Our basic advice for using Cis: 
Emulate the programming techniques that the C++ features wcrc dc-
signed to suppOrt with the facilitics provided by C. 
When writing C, write in thc C subset of C++. 
Use eompiler waming levels that ensurc function argumcnt checking. 
Use lim for large programs (see §27.2.2). 
Many of the dewils of ClC++ incompatibilities are rather obscure and technical. 
However, to read and write C, you don't actually have to remember most of those: 
~11 1e compiler will remind you whcn yOll are using a C++ fcature that is 
not in C. 
If YOli follow the rulcs abovc, you arc unlikely to cnCOlllllcr anything 
that means something different in C from what it means in C++. 
\Vilh the absence of all those C++ facilities, some facilities gain importance in C: 
Arrays and pointers 
Macros 
typedef 
sizeof 
Casts 
We give exrunples of a few such uses in this chapter. 
I introduced the /I comments into C++ from C's ancestor BCPL whcn I got 
really fed up with typing r ... ·1 comments. The II comments are accepted by 
most C dialects including C99, so it is prob'lbly safe just to use them. Here. we 
will lise /* ... ·1 exclusively in examples meant to be C. C99 introduced a few 
more C++ features (as well as a fcw fcaturcs that arc incompatible with C++). 
but here we will stick to C89, because that's far more widely used. 
27.1.3 The C standard library 
Naturally, a C++ library facility that depends on classes and tcmplatcs is not 
available ill C. This includes 
vector 
map 
set 
string 
'tne ST1. algorithms: e.g., sortO, findO, and copyO 
iostreams 
rege" 
993 

C HAPTER 27 • THE C PROGRAMMING LANG UAGE 
For these, there are often C libraries based on arrays, poimers, and functions to 
help compensate. The main pans of the C standard library are 
<sldlib.h>: general utilities (e.g., maliocO and freeO; see §27.4) 
<sldio.h>: standard 110; see §27.6 
<slring.h>: C·style string manipulation and memory manipulation; sec 
§27.5 
<malh.h>: standard floating.poim mathematic.'ll functions; see §24.8 
<errno.h>: error codes for <malh.h>; see §21k8 
<Iimits. h>: sizes of integer types; sec §24.2 
<time.h>: date and time; see §26.6.1 
<assert.h>: debug assertions; see §27.9 
<ctype. h>: character dassific.'ltion; see §11 .6 
<stdbool.h>: Boolean macros 
For a complete description, sec a good C textbook, sllch as K&R. All of these Ii· 
braries (and header files) arc also available in C++. 
27.2 Functions 
In C: 
There can be only one function of a given name. 
Funcuon argument type checking is optionaL 
There arc no references (and therefore no pass·by-reference). 
~There arc no member functions. 
Thcre arc no inline functions (except in C99). 
lllere is an alternative function definition syntax. 
Apal1 from that, thillgs arc much as YOll arc used to in C++. Let liS explore what 
that means. 
27.2.1 No function name overloading 
Consider: 
void print(int); 
, . print an int . / 
void print(const char· ); 
, . print a string · / 
/" error! ./ 
The second declaration is an error because there cannot be two functions with 
lhe same name. So you'll have to invent a suitable pair of names: 

27.2 
FU NCTIONS 
void prinU nl(int); 
void prinCslring(const char·); 
,. print an int . / 
, . print a string ., 
111is is occ.asionally claimed to be a virtue: now you can't accidelllally usc the 
wrong function to print an inl! Clearly we don't buy that argumelll, and the lack 
of overloaded fu nctions docs make generic programming ideas awkward to im· 
plemelll because generic programming depends on semantically similar functions 
having the same name. 
27.2.2 Function argument type checking 
Consider: 
int mainO 
( 
f(2); 
A C compiler will accept this: you don't have to declare a function before you call 
it (though you can and should). 111ere rna}' be a defin.ition of fO somewhere. TIlat 
to could be in anOlher translation unit, but if it isn't, the linker will complain. 
Unfortunately, that definition in another source file might look like this: 
int f(char· p) 
( 
) 
intr=O; 
while (. p++) r++; 
return r; 
TIle linker will not report that elTor. You will get a run·time error or some ran· 
dam result. 
How do we manage problems like that? Consistent usc of header files is a 
practical answer. If every function you call or define is declared in a hcader that is 
consistently #included whenever needed, we get checking. However, in large pro-
grdlllS that can be hard to achieve. Consequently, most C compilers have options 
that give wamings for calls of undeclared functions: lise them. Also, from the ear-
liest days of C, there have been programs that can be used to check for all kinds 
of consistency problems. They arc usually called lilli. Usc a lint for every non-
trivial C program. You wiJl find that lint pushes you toward a style of C usage 
995 

( HAPTER 27 • THE C PROGRA MMING LANGUAGE 
that is rather similar to using a subset of C++. One of the observations that led 
to the design of C++ was that the compiler could easily check much (but not all) 
of what lim checked. 
You can ask to have function arguments checked in C. You do that simply by 
declaring a function with its argument types specified (just as in C++). Such a 
declaration is called a jimction protoiJ-pe. However, beware of function declarations 
that do not specify arguments; those arc 1I0t function prototypes and do not imply 
fu nction argument check.ing: 
int g(double); 
int hO; 
void m y~fctO 
( 
) 
gO; 
g("asdr" ); 
g (2); 
g (2,3); 
hO; 
h("asdf"); 
h(2); 
h(2,3); 
r prototype -
like C++ function declaration -, 
,,, not a prototype -
the argumentlypes are unspecified ,,' 
/- error: missing argument '" 
r error: bad argument type '" 
r OK: 2 is converted to 2.0 ., 
r error: one argument too many "/ 
r OK by the compiler! May give unexpt>etcd results ,,' 
/. OK by the compiler! May give unexpected results ,,' 
/" OK by the compiler! May give unexpected results ,,' 
, ,, OK by the compiler! May give unexpected results ,,' 
The declaration of gO specifics no argument type. 111is does not mean lhat gO 
doesn't accept arguments; it means "Accept any set of arguments and hope Lhey 
afe correct for the called fu nction." Again, a good compiler wa l"lls and lint will 
catch the problem. 
c •• 
void fO; // preferred 
void f(void); 
void f( • . • ); /I accept any arguments 
( equivalent 
void f(void); 
void f(void); 
void fO; ,- accept any arguments -, 
"111cre is a special set of rules for converting arguments where no function proto-
type is in scope. For example, chars and shorts are converted to inls, and floals 
arc converted to doubles. If you need to know, say, what happens to a long, look 
it up in a good C textbook. Our recommendation is simple: don't call functions 
without prototypes. 

27.2 
FU NCTI O N S 
NOle that even though the compiler will allow an argument of the wrong 
type to be passed, such as a char· to a parameter of type int, the use of such an 
argument of a wrong type is an error. As Dennis Ritchie said, "C is a strongly 
typed, weakly checked, progranmling language." 
27.2.3 Function definitions 
You can define functions exactly as in C++ and such definitions arc function 
prototypes: 
double square(double d) 
( 
) 
void ffO 
( 
double" = square(2); 
double y = square(); 
double y = square("Hello"); 
double y = square(2,3); 
r OK: converl 2 to 2.0 and call *' 
/* argument missing *' 
/* error: wrong argument type *' 
r error: too many arguments *' 
A definition of a function with no arguments is not a function prototype: 
void fO {'- do something *'} 
void gO 
( 
(2); 
,- OK in C; error in C++ -, 
) 
Having 
void fOi 
'* 
no argument type specified *' 
mean "fO can lake any number of arguments or any type" seemed really strange. 
In rcspomie, I invented a new notation where "nothing" was explicitly stated 
using the keyword void (void is a rour·letter word meaning "nothing"): 
void {(void); '* 
no arguments accepted *' 
997 

(HAPTER 2 7 -
THE C PROGRAMMING LA NGU AG E 
I soon regretted that, though, since that looks odd and is completely rcdundant 
when argument type checking is uniformJy applied. Worse, Dennis Ritchie (the fa-
ther of G) and Doug McIlroy (the ultimate arbiter of tas!'e in the Bell Labs Com-
puteI' Science Research Cemer; see §22.2.5) both called it "an abomination.
n 
Unfortunately, thm abomination became very popular in lhe C conununit),. Don't 
usc it in C++, though, where it is not only ugly, but also logically redundant. 
C also provides a second, Algol60-style function definition, where the param-
eter types arc (optionally) specified separately from their names: 
int old_style{p,b,x) char- Pi char b; 
{ 
/" ... -, 
111is "old-style definition" predmes C++ and is not a prototype. By derauit, an 
argument without a declared type is an int. So, x is an int parameter or 
old_styleO. We can call old_styleO like this: 
old_styleO; 
old_style{"hello", 'a', 17); 
old_style(12, 13, 14); 
, - OK: all arguments missing -, 
,- OK: all arguments are of the right type . , 
, - OK: 12 is the wrong type, ., 
r but maybe old_style() won't use p -, 
TIle compiler should accept these calls (but would warn, we hope. rol' the first 
and third)_ 
Our recommendation about runction al'gullleut checking: 
Use rUllclion prototypes consistently (usc header files). 
Set compiler warning levels so that argument type errors arc caught. 
Use (some) lim. 
TIle result will be code that's also C++. 
27.2.4 Calling C from C++ and C++ from C 
You can link fLIes compiled with a C compiler together with filcs compiled with a 
C++ compiler provided the two compilers were designed for that. For example, 
you can link object files generated from C and C++ lIsing your GNU C and 
C++ compiler (GCG) together. You call also link objeci files generaled rrom C 
and C++ using yOllr Microsoft C and C++ compiler (MSC++) togcther.l11is is 
common and userul because it allows you to usc a larger sel or libraries than 
would be available in just onc of those two languages_ 
C++ provides stricter type checking than C. In particular, a C++ compiler 
and linker check that two functions f(inl) and f(double) arc consistently defined 
and used - even in different source files_ A linker ror C doesn't do that kind or 

27 .2 
FUNC TIONS 
checking. 10 call a function defined in C from C++ and to have a fUIlClion de-
fined in C++ called from C, we need to tell the compiler what we arc doing: 
II calling C function from C++; 
extern "C" double sqrt(double)i 
II link as a C function 
void my_c_plus_plus_fcIO 
( 
double sr = sqrl(2)i 
Basically extern "C" tells the compiler to use C linker conventions. Apart from 
that, all is nonna! from a C++ point of view. ln fact, the C++ standard sqrt(double) 
usually is the C standard library sqrt(double). Nothing is required from the C 
program to make a function callable from C++ in this way. C++ simply adaptS 
to the C linkage convention. 
We can also usc extern "C" to make a C++ function callable from C: 
1/ C++ function callable from C 
extern "C" jnl call_HS· p, inl i) 
( 
return P->f(i)i 
) 
In a C program, we can now callthc member function f() indirectly, like this: 
r call C++ function from C -, 
inl caJU (S- p, inl i); 
strucl S· make_S(int,const char-); 
void my_c_fct(int i) 
( 
) 
,-.... , 
struct S· p = make_S(x, "foo")i 
inl x = caIU(p,i)i 
r ... -, 
No mention of C++ is needed (or possible) in C for this to work. 
... 

1000 
( HAPTE R 27 • THE C PROGRAMMING LANGUAG E 
The bcnclit of lhis intcropcrabiliry is obvious: code can be written in a mix. 
of C and C++. In particular, a C++ program can lISC libraries wrinen in C, and 
C programs can usc libraries written in C++. Funhcrmorc, most languages (no-
tably Fortran) have an interface for calling la/from C. 
In the examples above, we assumed that C and C++ could share the class 
object pointed to by p. TImt is true for most class objects. In particular, if you 
have a class like this, 
II in C++: 
class complex { 
double re, im; 
public: 
/I all the usual operations 
); 
you can get away with passing a pointer to an object to and from C. YOll c..'m even 
access re and im in a C program lIsing a declaration: 
l- inC -' 
struct complex { 
double re, im; 
'* 
no operations *' 
); 
~111C rules for layout in any language can be complex, and the rules for layout 
among languages can even be hard to specify. However, you can pass built·in 
types between C and C++ and also classes (structs) without virtual functions. If 
a class has virtual functions, you should JUSt pass pointers to its objects and leave 
the actual manipulation to C++ code. llle call_H) was an example of this: fO 
might be virtual and then that example would illustrate how to call a virtual func· 
tion from C. 
Apan from sticking to the bui[t~in types, the simplest and sarcst sharing of 
types is a slruct defined in a common ClC++ header file. However, that strategy 
seriously limits how C++ can be used, so we don't restrict ourselves to it. 
27.2.5 Pointers to functions 
What can we do in C if we wa.nt to use object-oriented techniques (§14.2-4)? Ba· 
sically, we need an a.llemative to virtual functions. For most people, the first idea 
that springs to mind is to use a slruct wit.h a "type field
n that describes what kind 
of shape a given object represents. For example: 

27.2 
FUNCTIONS 
struct Shape1 { 
}; 
enum Kind ( circle, rectangle} kind; 
r ... *' 
void draw(struct Shape1 * p) 
{ 
} 
switch (p- >kind) ( 
case circle: 
'* 
draw as circle *' 
break; 
case rectangle: 
} 
r draw as rectangle *' 
break; 
int f(struct ShapeP pp) 
( 
} 
draw(pp); 
/* ... *' 
~nl is works. There arc two snags, though: 
For each "pseudo-virtual" function (such as drawO), we have to write a 
new switch-statement. 
E..1.ch time we add a new shape, we have to modify every "pseudo-virtuaJn 
function (such as drawO) by adding a case to the switch·statement. 
"n le second problem is quite nasty because it means that we can't provide our 
"pscudo-vinuaJn functions as part of a library, because our users will have to 
modify those functions quite often. TIle mOst effective alternative involves point-
ers to functions: 
Iypedef void (*PfclO)(struct Shape2*); 
Iypedef void (·Pfct1int)(slruct Shape2· ,intI; 
slruct Shape2 ( 
} ; 
PfctO draw; 
Pfct1int rotate; 
'* ... */ 
1001 

1002 
CHAPTER 27 • THE C PROGRAMMING LANGUAGE 
void draw(struct Shape2· p) 
( 
(p->drawHp); 
) 
void rotate(struct Shape2e p, int d) 
( 
(p->rotale)(p,d) ; 
) 
This Shape2 can be uscd juSl like Shape1 . 
int f(slruct Shaper pp) 
( 
) 
draw(pp); 
/* . .. 0/ 
With a little extra work, an object need not hold one pointer to a function for 
each pseudo-virtual function. Instead, it can hold a pointer to an array of poilUers 
to functions (much as virtual functions arc implemented in C++). TIle main 
problem with using such schemes in real-world programs is to gel the initializa-
tion of all those paimers to functions right. 
27.3 Minor language differences 
This section gives examples of minor ClC++ differences that could uip yOll up if 
you have never heard of them. Few seriously impact programming in that the dif-
ferences have obvious work-aroullds. 
27.3.1 struct tag namespace 
In C , the names or strucls (there is no class keyword) are in a separate name-
space rrom other identifiers. 111ercfore, every name or a slruct (called a smlClure 
latJ must be prerL'(ed wilh the keyword struct. For example: 
struct pair {int lII,y; ); 
pair pl ; 
, - error: no identifier " pa jr ~ in scope *' 
struct pair p2; 
1* O K *' 
int pair = 7; 
slruct pair p3; 
pair = 8; 
'* 
OK: the struct tag pair is not in scope *' 
,. OK: the slrucl tag pair is not hiddcn by the int *' 
,- OK: ~ pair" refers to thc int *' 

2 7.3 
MINOR LANG U AGE DIFFERENCES 
Amazingly enough, thanks to a devious compatibility hack, this also works in 
C++. Having a variable (or a function) with the same name as a slrucl is a fairly 
COlllmon C idiom, though not one we recommend. 
If you dan', wimt to write slruct in front of every stTUCmre nrunc, usc a typeder 
(§20.5). 111e foUowing idiom is conunon: 
Iypeder slruct { int x,y; } pair; 
pairpl = { 1,2 }; 
In general, you'll find typeders more common and more useful in C, where you 
dan', have the option of defining new types with associated operations. 
In C, names of nested structs are placed in the same scope as the strucl in 
which they arc nested. For example: 
slrucl S { 
slructT { r ... o/}; 
'" 
... "' 
); 
slruct T x; 
' " OK in C (not in C++) "' 
In C++, you would write 
S: :T x; 
/I OK in C++ (not in C) 
\rVhenever possible, don't nest slrucls in C: their scope rules differ from what 
most people naively (and reasonably) expect. 
27.3.2 Keywords 
Many keywords in C++ arc not keywords in C (bec."'l.use C doesn't provide the 
functionality) and can be used as identifiers in C: 
c++ keywords that are not C keywords 
and 
and_eq 
asm 
bitand 
bitor 
bool 
1003 
catch 
class 
campi 
cons'-cast 
delete 
dynamic3 ast 
explicit 
e"port 
false 
friend 
inline 
mutable 
namespace 
new 
not 
no'-eq 
operator 
0 ' 
or_eq 
private 
protected 
public 
reinterpre,-cast 
static_cast 
template 
this 
throw 
true 
t,y 
typeid 
typcname 
using 
virtual 
wchar_t 
'"' 
"ot_eq 

1004 
C HAPTER 27 • THE C PROGRAMMING LANGUAGE 
Don't usc these names as identifiers in C, or your code will not be portable to 
C++. If you usc one or thesc names in a header file, that header won't be useful 
from C++. 
Some C++ kC)"\lords arc macros in C : 
c ++ keywords that are C macros 
.nd 
n01 
biland 
0' 
bilar 
bool 
true 
campi 
wchar_1 
false 
'0' 
In C, they a f C defined in <iso646.h> and <stdbool.h> (bool, true, false). Don't 
take advantage of the fact that they are macros in C. 
27.3.3 Definitions 
c++ allows definitions in more places than C. For example: 
for (int i = 0; kmax; Hi) xm = y[i]; 
while (strucl S· p = nexl(q)) { 
,-... -, 
} 
void f(int i) 
{ 
/I definition of i nol allowed in C 
1/ definition of p not allowed in C 
if (i< 0 II max<=i) erro r("range error"); 
int a[max); 
/I error: declaration after statement not allowed in C 
r ... . , 
} 
C (C89) doesn't aJlow declarations as initiaJizers in for-statements, as conditions, 
or after a statement in a block. We have to vI/rite somcthing likc 
int i; 
for (i = 0; k max; ++i) x[ij = ylij; 
struct S" p; 
while (p = next(q» ( 
r ... .. , 
} 
void f(int i) 
{ 
if (k 0 II max<=i) error("range error"); 

27.3 
M INOR LANGUAGE DIFFE REN CES 
( 
inl almaxl; 
,-... *' 
) 
) 
In C++, an uninitialized declaration is a definition; in C, it is just a declaration so 
that there can be twO of them: 
inl X; 
inl x; 
I" defines or declares a single integer called x in C; error in C++ *' 
In C++, an entity must be defined exactly once. This gets a bit more interesting 
if the two ints are in different translation units: 
I" in file X.c: *' 
int x; 
'* 
in file y.c: *' 
inl X; 
No C or C++ compiler will find any fault with either x.c or y.c. However, if x.c 
and y.c arc compiled as C++, the linker will give a "double definition" error. If 
x.c and y.c arc compiled as C, the linker accepts the program and (correctly ac· 
cording to C niles) considers there to be just one x that is shared between code in 
x.c and y.c. If you want a program where a global variable x is shared, say so 
explicitly: 
I" in file x.c: *' 
inl x= O; 
'* 
in file y.c: *' 
extern int x; 
'* 
the definition *' 
'* a declaration, not a definition *' 
Better still, lise a header file: 
'* 
in file x.h: *' 
extern int x; 
I" in file x.c: *' 
#include "x.h" 
intx = O; 
'* 
a declaration. not a definition *' 
'* 
the definition *' 
1005 

1006 
r in file y.c: 0' 
#indude "x.h" 
( HAPTER 27 • TH E C PROGRAMM ING LANGUAGE 
/* the declaration of x is in the header 0/ 
Belter still, avoid the global variable. 
27.3.4 C·style casts 
In C (and C++), you can explicitly convert a value v to a type T by this minimal 
notation: 
This "e -Style cast" OJ' "old-style cast" is beloved by poor typists and sloppy 
thinkers because it's minimal and you don't have to know what it takes to make 
a T from v. On the other hand, this style of cast is rightfully fcared by mainte-
nance programmers because it is just about invisible and leaves no clue aboul the 
writer's intcm. ~nlC C++ casts (lIew-Jt)'le CIlSIJ or template·style {(LlIJ; sec §A.5. 7) were 
introduced to make explicit type conversion easy to spot (ugly) and specific. In 
C , you have no choice: 
intO p = (intO)7; 
int x = (int)7.5; 
' " reinterpret bit pattern: reinterpreccast<int">(O) 0' 
' "truncate double: static_cast<int>(7.5) '" 
typcdcf struct 51 { /* . .. "'} 51; 
Iypcdcf struct 52 {' " ... "' } 52; 
51 a; 
const 52 b; 
51 " P = (51 ")&a; 
52* q = (52")&b; 
51" r = (51*)&a; 
' * uninitialized consts arc allowed in C */ 
'" reinterprct bit piHtcrn: rcinlcrpreccasl<ST*>(&a) '" 
, ,, cast away const const_cast<S2">(&b) '" 
, . remove const and change type; probably a bug */ 
We hesitate to recommend a macro (§27.8) even in C , but it may be an idea lO ex-
press intent like this: 
#define REINTERPRET_CAST(T,v) «THv» 
#define CON5T_CA5T(T,v) ((T)(v)) 
S1" P = REINTERPRET_CAST (51* ,&a); 
S2" q = CONST_CAST(S2*,&b); 

27.3 
M INOR LANGUAGE DIFFERENCES 
lllis docs not give the type checking done by reinterpreccast and const_cast, 
but it docs make these inherently ugly operations visible and the progranuner's 
intent explicit 
27.3.5 Conversion of void· 
In C, a void· may be used as the right-hand operand of an assignment to or ini-
tialization of a variable of any poimer type; in C++ it may nol. For example: 
void· alloe(si:ze_t Xli 
void t (int n) 
{ 
} 
int- p = aUoc(n·sizeof(int»; 
, .. 
- -., 
, . OK in C; error in C++ ./ 
Here, the void· result of alloeO is implicitly converted to an inl- . In C++, we 
would have to rewrite that line to 
int O P = (int*)alloe(n*si:zeof(intj)i 
/* OK in C and C++ *' 
We used the C-style cast (§27.3.4) so that it would be legal in both C and C++. 
' >Vhy is the void·-to-T" implicit conversion illegal in C++? Because sllch con-
versions C<1Il be unsafe: 
void to 
{ 
} 
chari=Oi 
charj = Oi 
char· p = &i; 
void· q = Pi 
intO pp = q; 
. pp = - 1i 
'* unsafe; legal in C, error in C++ ., 
/* overwrite memory sltlrling at &i *' 
Here we can't even be SUfe what memory is ovenvriuen. Maybe j and part of p? 
Maybe SOllle memory used to manage lhe call of to (f's Slack frame)? \oVhatever 
data is being ovenvnlten here, a caU of fO is bad news. 
Note lhal (the opposiLC) conversion of a 1* to a void* is perfectly safe - you 
c..1.Il't construct nasty examples like the one above for that - and those arc al-
lowed in both C and C++. 
1007 

1008 
CHAPTER 2 7 • THE C PROGRAMMI N G LAN GUAG E 
Unfortunately, implicit void*'IO-P conversions are common in C and possi· 
bly the major C/C++ compatibility problem in real code (sec §27.4). 
27.3.6 enum 
In C, you can assign an int to an enum without a cast. For example: 
e num color { red, blue, green }; 
int x = green; 
' " O K in C and C++ "' 
enum color col = 7; 
' " O K in C; error in C++ ., 
One implication of this is that we can use increment (++) and decrement (--) on 
variables of enumeration type in C. 111at can be convenient but docs imply a 
hazard: 
enurn color x = blue; 
++Xi 
r x becomes green; error in C++ "' 
++Xi 
I" x becomes J; error in C++ "' 
"F.·lIling olT the end" of the enumerators mayor may not have been whm we 
wanted. 
Note that like structure tags, the names of enumerations arc in their own 
namespace, so you have to prefix them with the keyword enum each time you 
lise them: 
color c2 = blue; 
enum colo r c3 = red ; 
r error in C: color no! in scope; O K in C++ . / 
/ . OK ./ 
27.3.7 Namespaces 
111el1: arc no namespaces (in the C++ sense of the word) in C. So what do you 
do when you want to avoid nallle clashes in large C programs? TypicaJly, people 
lise prefixes or sufftxes. For example: 
r in bs,h: ./ 
typedef struct bs_slring {/* . . . • / } bs_string; 
typedef int bs_bool ; 
/* in pete.h: */ 
/* Pete's string */ 
r Bjarne's string . / 
/. Bjarne's Boolean type */ 
typedef char· pete_siring; 
typedef char pete_bool ; 
'* 
Pete's Boolean type */ 
~n1i s technique is so popuhlr that it is usually a bad idea to lise one' o r two-letter 
prefixes. 

2 7.4 
FREE STORE 
27.4 Free store 
C does not provide the new and delete operaLOrs dealing with objects. To use 
free SLOre, you use functions dealing wit.h memory. The most important functions 
arc defined in the "general utilities" standard headcr <stdlib.h>: 
void " malloc(si:z:e_1 S:Z:)i 
/* allocate sz bytes "' 
void free(voidO pI; 
'0 
deallocate the memory pointed to by p ./ 
void · calloc(size_1 n, size_t u); '0 
allocilte n"sz bytes initialized to 0 °/ 
void · realloc(void O p, size_t u); ' " n!illiocilte the memory pointed to by p 
to a space of size sz 0' 
~nle typedef size_t is an unsigned type also defined in <stdlib.h>. 
Why docs maliocO return a void· ? Because maliocO has no idea which type 
of object YOll want to put in that memory. Initialization is your problem. For 
example: 
strucl Pair ( 
); 
canst char" p; 
int val; 
slrucl Pair p2 = ("apple",78); 
slrucl Pair· pp = (slrue! Pair·) malloc(sizeof(Pair»; 
pp->p = "pear"; 
pp->val = 42; 
' " initialize 0/ 
Note that we cannot write 
0pp = ("pear", 42}i 
' " error: not C or C++98 0' 
in either C or C++. However, in C++, we would define a constructor for Pair 
and write 
Pair· pp = new Pair("pear", 42); 
In C (but not C++; see §27.3.4), you can leave out the cast before malloc(), but 
we don't recommend thai : 
intO p = malloc(sizeof(int)"n); '0 
avoid this 0' 
Leaving out the cast is quite popular because it saves some typing and because il 
calches the rare error of (illegally) forgetting to include <sldlib.h> before using 
1009 

1010 
CHAPTER 27 • THE C PROGRAMMING LANGUAGE 
maliocO. However, it can also remove a visual due that a size was wrongly 
calculated: 
p = malloc(sizeof(char)*m); 
r probably a bug -
not room for mints *' 
Don't use malloc()'freeO in C++ programs; new'delete require no casts, deill 
with initialization (constructors) and cleanup (destructors), report mcmory allo-
cation errors (through an exception), and arc just as fast. Don't delete an object 
allocated by maliocO or freeO an object allocated by new. For example: 
int· p = new inI[200]; 
/I . .. 
free(p); 
II error 
X* q = (X*)malloc(n·sizeor(X»; 
/I .. 
delete q; 
/I error 
This might work, but it is not portable code. Furthermore, for objects with con-
structors or destructors, mixillg C-style and C++-style frec-store management is 
a recipe for disaster. 
TIle real locO function is typically used for expanding buffers: 
int max = 1000; 
int count = 0; 
int e; 
char· p = (char·)malloc(max); 
while «c=gclchar())!=EOF) ( 
r read: ignore chars all eaf line *' 
if (count==max- 1) ( 
'* 
need to expand buffer */ 
max += max; 
'* 
double the buffer size *' 
p = (char·)realloc(p,max); 
if (p==O) quitO; 
) 
p[count++J = c; 
) 
For an explanation of the C input operations, sec §27.6.2 and §B.IO.2. 
TIle realloeO function mayor may not move the old allocation into newly al-
located memory. Don't even think of lIsing reallocO on memory allocated by new. 
Using the C++ standard library, the (roughly) equivalent code is 
veclor<char> buf; 
char c; 
while (cin.get(c)) buf.push_back(c); 

2 7.5 
C-STY l E STRING S 
Rerer to the paper "Lcaming Standard C ++ as a New Language" (see the refer· 
ence list in §27. 1) ror a more lhorough discussion or input and allocation strategies. 
27.5 C-style strings 
In C, a string (orten cruled a C .string or a C-.sI)'k .shillg in C++ litcrature) is a zcro· 
terminated alTay or characters. For example: 
char· I> = "asdf"; 
char s[l= "asdf"; 
p: 
9 
l'a'I's'I'd'I'rl 0 I 
s l'a'I's' I'd'I'f'l 0 I 
In C, we callnot have member runetions, we cannot overload runctions, and we 
cannot define an operator (such as ==) ror a slruct. It rollows that we need a set 
or (nonmember) runctions to manipulate C-stylc soings. 111e C and C++ stan-
dard Iibr'lIies provide such runctions in <slring.h>: 
sizc_t slrle n(consl char· s); 
char· slrcat(char· s1, canst char· s2); 
int strcmp(const char· s1, canst char· s2); 
char" strcpy(char" sl ,const char" s2); 
char" slrchr(consl char "s, int c); 
char· slrslr(const char ·sl , consl char "s2); 
char· strncpy(char", consl char", sizc_I nl; 
charo strncat(charO, canst char, sizc_t nl; 
' " count the characters "/ 
/" copy s2 onto the end of sl ., 
r compare lexicographically "' 
r copy s2 into 51 "/ 
I" find c in s "' 
/" find s2 in sl 0/ 
' " strcpy, max n chars 0' 
r strcat with max n chars ., 
int slrncmp(const char", canst char", sizC_1 nl; '0 
strcmp with max n chars "/ 
This is not the rull set, but these are the most lIserul and most llsed runctions. \tVe 
will bricny illustrate their lise. 
,"Ye can compare strings. TIle equality operator (==) compares pointer val· 
ues: the standard library runction strcmpO compares C ·style string values: 
canst char" s1 = "asdf"; 
canst char" s2 = "asdf"; 
if (sl ==s2) { 
} 
/0 do 51 and 52 point to the same array? 0' 
/" (typically not what you want) 0/ 
1011 

1012 
C H APTER 2 7 • T H E C PR OG RAM M ING LANG U AGE 
if (stremp(sl,s2)==O) ( '0 do s 1 and 52 hold the same characlers? 0' 
) 
TIle slremp() function docs a three-way comparison of its two arguments. Given 
the values of sl and s2 above, slrcmp(sl ,s2) will retum 0, meaning a perfect 
match. If sl was lexicographically befo"e s2 it would retum a negative number, 
and if sl was lexicographically after s2 it would retum a positive number. TIle 
term lexicographical means roughly "as in a dictionary." For c. .... ample: 
strcmp("dog", "dogn)==o 
slrcmp("apen, "dodo")<O 
/0 "ape" comes before "dodo" in a dictionary */ 
slrcmp("pig", "eow")>O 
/* "pig" comes after "cow" in a dictionary *' 
'nle value of the pointer comparison sl ==s2 is not guaranteed to be 0 (false). An 
implementation may decide to use the same memory to hold all copies of a char-
acter literal, so we would get the answer I (true). Usually, strcmpO is the right 
choice for comparing C-stylc strings. 
We can find the length of a C-slyle string using strlenO: 
int Igt = strlen(sl); 
Note that strlenO counts characters excluding the terminating O. In this case. 
strlen(sl )==4 and it takes 5 bytes to store "asdf". 'n lis little difference is the 
source of many off-by-one errors. 
We can copy one C-style string (including the tenllinating 0) into another: 
strepy(sl ,s2); 
'0 copy characters from s2 into sl *' 
It is your job to be sure that me target string (array) has enough space to hold the 
characters from the source. 
The strncpyO, strncal(), and strncmpO functions arc versions of strcpy(), 
strcat(), and slrcmpO that will consider a maximum of n characters, where n is 
their third argument. Note that if there arc more than n characters in the source 
string, strncpyO will not copy a terminating 0, so that the result will not be a valid 
C-style string. 
~nle slrchrO and strslrO functions fmd their second argument ill the string 
that is their first argument and retum a pointer to the first character of the match. 
Like find(), tlley searcll from left to right in the string. 
It. is amazing b0t11 how much GUI be done with these simple functions and how 
easy it is to make minor mist.l.kcs. Consider a simple problem of concatell<uing a 

27 .5 
C~STYLE STRI NG S 
user name with an address, placing the @ character in between. Using std:string 
lhis can be done like this: 
siring s = id + '@' + addr; 
Using the standard C-slyle string function we ea.n write t.hat as 
char· cal(const char· id, const char· addr) 
{ 
} 
inl sz = strlen(id)+slrlen(addr)+2; 
char· res = (char·) malloc(sz); 
strcpy(res,id); 
resislrlen(id)+l ) = '@'; 
sl rcpy(res+strlen (id )+2,add r); 
res[sz-1)=O; 
return res; 
Did we gel that right? Who will freeO the string relumed from catO? 
TRY THI S 
Test catO. Why 2? We left a beginner's performance error in catO; find it and 
remove it. We '"'forgot" to conunem our code. Add comments suitable for 
someone who can be assumed to know the standard C-string functions. 
27.5.1 C.style strings and const 
Consider: 
char· p = "asdf"; 
pl21 = 'x'; 
rll1is is legal in C but not in C++. In C++, a string literal is a constant, an im-
mumble value, so p[2)='x' (to make the value pointed to "asxfM) is illegal. Unfor-
tunately, few compilers will c<Hch the assignment to p that leads to the problem. 
If you arc lucky, a run-time error will occur, but don't rely on that. Instead, write 
consl char· p = "asdf"; 
/I no ..... you can't write to "asdf" through p 
111is recommendation applies to both C and C++. 
1013 

1014 
CHAPTER 27 • THE C PROGR AMMING lA NGUAG E 
TIle C strchrO has a similar but even harder-to-spot problem. Consider: 
char" strchr(const char" s, int C)i r fi nd c in constant s (not C++) ., 
const char aa[] = "asdf"; 
char· q = slrchr(aa, 'd')i 
. q = 'x'; 
r aa is an array of constants "' 
'" finds 'd' ., 
r change 'd' in a to 'x' "' 
Again, this is illegal in C and C++, but C compilers can't catch it. Sometimes this 
is referred to as tr(lIlSlIIutatioll: it tums consts into non-cons15, violating reasonable 
assumptions about code. 
In C++, the problem is solved by the standard library declaring strchr() 
diITerelllJy: 
char canst· strchr(const char" s, int c); 
II find c in constant s 
char· strchr(char" s, int cl; 
/I find c in s 
Similarly for slrstrO. 
27.5.2 Byte operations 
In the distant dark ages (the early 1980s), before the invention of void·, C (and 
C++) programmers used the string operations to manipulate bytes. Now the 
basic memory manipulation standard library functions have void" parameters 
and rerum types to warn users about their direct manipulation of essentially un-
typed memory: 
,. copy n bytes from s2 to s 1 (like strcpy): "' 
void· memcpy(void" 51, const void· 52, 5ize_t n); 
,. copy n bytes from s2 to s 1 ( [s l:s 1 +n) may overlap with [s2 :s2 +n) ): ., 
void· memmove(void· sl , canst void· s2, 5b:e_t nl; 
r compare n bytes from s2 to sl (like strcmp): ·' 
int memcmp(consl void" sl , canst void· s2, sizc_t n); 
' " find c (converted to an unsigned char) in the first n bytes of s: ., 
void" memchr{const void" s, int c, size_t n); 
' " copy c (converted to an unsigned char) 
into each of the first n bytes that s points to: ., 
void· mem5ct(void" s, int c, size_l n); 

27.5 
C-STYLE STRING S 
Don't usc these functions in C++. In particular, memsetO typically interferes 
with the guarantees offered by constructors. 
27.5.3 An example: s!repyO 
111e definition of slrcpyO is both famous and infamous as an example of the terse 
style that C (and C++) is capable of: 
char· strcpy(char· p, const char· q ) 
{ 
) 
while (*p++ = *q++); 
return p; 
\"'e leave to you the explanation of why t.his actually copies the C-style string q 
into p. 
TRY THIS 
Is tltis implementation of strepyO correct? Explain why. 
If you can't explain why, we won't consider you a C programmer (however com-
petent you are at programming in otller languages). Every language has its own 
idioms, and tllis is one of C's. 
27.5.4 A style issue 
We have quietly taken sides in a long-standing, often furiously debated, and 
largely irrelevant style issue. We declare a pointer like this: 
char· p; 
/I P is a pointer to a char 
and not like this: 
char . 1'; 
r p is something that you can dereference to get a char ., 
11le placement of the whitespllce is completely in'elevant to the compiler, but 
programmers carc. Q UI' style (conunon in C++) emphasizes the type of the vari-
able being declared, whereas the other style (more common in C) emphasizes the 
lise of the variable. Note that we don't recommend declaring many variables in a 
single declaration: 
char c, "p, a[177], · f(); 
,. legal, but confusing *' 
1015 

1016 
C H APTER 27 • TH E C PROGRAMMING LANGUAGE 
Such declarations are nOt uncommon in older code. Instead, usc multiple lines 
and take advantage of the extra horizontal space for comments and initializers: 
char c = 'a'; ,- termination characler for input using fO-' 
char- p = OJ ,- last char read by fO -, 
char a[177]; ,- inpul buffer -, 
char- fO; 
,- read inlo buffer a; return pointer 10 first char read -, 
Also, choose meaningful names. 
27.6 InpuUoutput: stdio 
There are no iostreams in C, so we usc the C standard I/O defined in <sldio.h> 
and commonly referred to as stdio. The stdio equivalents to cin and coul arc 
sldin and sldou!. Sldio and ioslream usc can be mixed in a single program (for 
the same I/O streams), but we don't recommend that. If you feel the need to mix, 
read up on stdio and iostreams (especially i ~s_bas e : :sync_wilh_sldioO) 111 an 
cxpcn-levcl textbook. See also §B.10. 
27.6.1 Output 
The most popular and useful function of stdio is printfO. The most basic usc of 
printfO just prints a (C-style) string: 
#include<stdio.h> 
void f(consl char- p) 
( 
) 
prinlf(IIHello, World!\n"); 
printf(p); 
That's not particularly interesting. The intcresting bit is that printfO can take an 
arbitrary number of arguments, and the initial string controls if and how those 
extra arguments arc printed. The declaration of prinUO in C looks like this: 
int printf(eonsl char· format, . . . )i 
111C •• • means "and optionally more arguments." We t..1.11 call printfO like this: 
void f1 (double d, char- s, int i, char chI 
( 
printf(ndouble %g string %s int %d char %e\n", d, s, i, eh); 
) 

27. 6 
INPUT/OUTPUT: STOIO 
Here. %g means '"Print a noating-point number using the general formac ," %s 
means "Prine a C-style string," %d means "Prim an integer using decimal digits," 
and %c means '"Print a character." Each such format specifier picks the next sa-
far-unused argument, so %g prints d, %s prints s, %d prints i, and %c prints ch. 
You c..1n find the full list of printfO formats in §B.IO.2. 
Unfortunately, printf() is not type safe. For example: 
char an = { 'a', 'b' }; 
/ - no terminating 0 -, 
void f2(char- 5, int i) 
( 
) 
printWgoof %s\n", i); 
printf("goof %d : %s\n", i)i 
prinlf("goof %s\n", a)i 
/- uncaught error -/ 
/- uncaught error -/ 
/- uncaught error -/ 
111e elTect of the last printfO is interesting: it prints every byte in memory follow-
ing al11 until it encounters a O. That could be a lot of characters. 
111is lack of lype safety is one reason we prefer ioslreams over stdio even 
though sedio works identically in C and C++. TIle other reason is that the stdio 
functions arc not extensible: you cannot extend printfO to print values of your 
own types, the way you can using iostreams_ For example, there is no way you 
c.."ln define your own %Y to print some strucl Y. 
TIlere is a useful version of printfO that takes a me descriptor as its first 
argument: 
int fprintf(FILP stream, const char- format, .. _ ); 
For example: 
fprintr(stdo ut, "Helio, World!\n "); 
FILE- ff = fopen("My_file", "W")i 
fprintf(ff, "Hello, Worldl\n"); 
File handles arc described in §27.6.3. 
27.6.2 Input 
/I exactly like printf("Hello, World!\ n"); 
/1 open My_file (or writing 
/1 write "Hello, World!\n" to My_file 
111c most popular stdio functions include 
int scanf(consl char- format, ... )i 
int getchar(void)i 
, - read from sidin using a (ormat -/ 
, - get a char (rom stdin -/ 
1017 

1018 
CHAPTER 27 • TH E C PROGRAMMING LANG UAGE 
int getc(FILE* stream)i 
char* gets(char* S)i 
1* get a char from stream *' 
/* gel characters from sIdin *' 
The simplest way of reading a string of characters is using getsO. For example: 
char a[12]i 
gets(a); 
' * read into char array pointed to by a until a '\n' is input *' 
Never do that! Consider gels() poisoned. Togelher with its close COUSIll 
scanf("o/os"), gelsO used to be the root cause of about. a quarter of all successful 
hacking atlempLS. It. is still a major security problem. In lhe trivial example 
above, how would you know that at most I I characters would be input berore a 
newline? You can't know that.. TI1US, getsO almost certainly leads to memory cor-
luption (of the bytes after the buffer), and memory corruption is a major tool of 
crackers. Don't think that you can guess a maximum bufTer size that is "large 
enough for all uses." Maybe the "person" at the other end of the input stream is a 
program that docs not meet your criteria for reasonableness. 
The scanro function reads using a format just as printfO writes using a for-
mat. Like printfO it can be very convenient: 
void fO 
{ 
int ii 
char Ci 
double di 
char* s = (char· )malloc(100)i 
r read into variables passed as pointers: *' 
scanf("%i %c %g %s", &i, &c, &d, s); 
/* %s skips initial whitespace and is terminated by whitespace */ 
Like printfO, scanfO is not type safe. TIle fonnat characters and the arguments 
(all pointers) must match exactly, or strange things will happen at run lime. Note 
also that lhe %s read into s may lead to an overflow. Don't ever use gelsO or 
scanf("%s")! 
So how do we read characters safely? We can use a form of %s that places a 
limit on the number of characters read. For example: 
char bu[[20]i 
scanf("%19s" ,buO; 
We need space for a terminating 0 (supplied by scanfO). so 19 is the maximum 
number of characters we can read into buf. However, that leaves us with the 

27.6 
INPUT/ OUTPUT: STOIO 
problem of what to do if someone docs type more than 19 characters. 11lC~ 
"exira" characters will be left in the input stream to be "found" by later input 
operations. 
111e problem with scanfO implies that it is often prudent and easier to lise 
gelcharO. lllC typic1.l way of reading charactcrs wilh gelcharO is 
while«"=getchar(»! =EOF) { 
/- ... -, 
) 
EOF is a stdio macro meaning '·end of file"; sec also §27.4. 
lllC C++ standard library rutemative to scanW%s") and gelsO doesn't suf-
fer from these problems: 
Siring s; 
dn » s; 
II read a word 
gelline(dn,s); 
II read a line 
27.6.3 Files 
In C (or C++), files can be opened using fopenO and closed using fcloseO. 
These functions, together with the representation of a file handle, FILE, and the 
EOF (end-of-file) macro, arc found in <sldio.h>: 
FILE ·fopen(consl char· filename, consl char· mode); 
inl fclose(FllE ·stream); 
Basically, YOll lise fLIes like this: 
void f(const char· fn, consl char· fn2) 
( 
FllP (i = fopen(fn, "r"); 
FllP fo = fopen(fn2, "WH); 
r open fn for reading *' 
, - open in for writing *' 
if (fi == 0) error("failed to open input file"); 
if (fo == 0) error("failed to open outpul file"); 
r read from filc using stdio input functions, c.g., getcO *' 
r write from fi lc using stdio output functions, c.g., fprintfO·' 
fclose(fo); 
fclose(fi); 
1019 

1020 
CHA PTER 27 • THE C PROGRAMMING LANGUAGE 
Consider this: there are no exceptions in C, so how do we make sure that the 
files are dosed whichever enor happens? 
27.7 Constants and macros 
In C, a eonsl is never a compile-time constant: 
consl int max = 30; 
consl int x; 
' " canst nol initialized: O K in C (error in C++) ·, 
void f(i nt v) 
{ 
int al [max); ,. error: array bound nOI a constanl (OK in C++) "' 
' " (max is not allowed in a constant expression!) "' 
int a2lx]; 
' " error: array bound nol a constant "' 
switch (v) { 
case 1 : '" ... '" 
break; 
case max: 
} '" 
... "' 
break; 
' " error: case label not a constanl (OK in C++) "' 
The technical reason in C (though not in C++) is thaI a const is implicitly acces-
sible from other lranslation units: 
' " file x.c: "' 
const inl x; 
/" file xx.c: "/ 
consl int x = 7; 
/. initialize elsewhere ./ 
/" here is the real deiinition "/ 
In C++, that would be two different objects, each called x in its own file. Instead 
of using const to represent symbolic constams, C programmers lend to lise 
macros. For example: 
#define MAX 30 

27.8 
MACROS 
void f(int v) 
( 
) 
int alfMAX); 
switch (v) ( 
case 1: , 
.. ... .. , 
break; 
case MAX : 
) 
,,, ... '" 
break; 
/' OK ., 
~111 e name of the macro MAX is replaced by the characters 30, which is the value 
of the macro; that is, the number of elements of al is 30 and the value in the sec· 
ond case label is 30. We usc all capital lelters for the MAX macro, as is conven· 
tional. ~111is naming convention helps minimize errors caused by macros. 
27.8 Macros 
Beware of macros: in C there arc no really effective ways of avoiding macros, but 
their usc has serious side effects because they don't obey the usual C (or C++) 
scope and t)1>e rules. Macros arc a form of text substitution. See also §A.I7.2. 
How do we try to protect ourselves from the potential problems of macros 
apart from (relying on C++ alternatives and) minimizing their use? 
Give all macros we define ALL_CAPS names. 
Don't give anything that isn't a macro an ALL....CAPS name. 
Never give a macro a short or "cute" name, such as max or min. 
Hope that everybody else follows this simple and common convention. 
111e main uscs of macros arc 
Definition of "constants" 
Definition of function·like constructs 
"Improvements" to the syma:1( 
Comrol of conditional compilation 
In addition, there is a wide variety of less common uses. 
We consider macros seriously overused, but there arc no reasonable and 
complete alternatives LO the use of macros in C programs. Xl can even be hard to 
1021 

1022 
( HAPTER 27 • THE C PROGRAMMING LANG U AGE 
avoid them in C++ programs (especially if you need to write programs that have 
to be portable to very old compilers or to platforms with unusual constraints). 
Apologies to people who consider the techniques described below "dirty 
mcks
n and believe such arc best not mentioned in polite company. However, we 
believe that programmillg is to be done in the real world and that these (very 
mild) examples of uses and misuses of macros can save hours of Kricf for the 
novice programmer. Ignorance about macros is not bliss. 
27.8.1 Function-like macros 
Here is a rairly typical function-like macro: 
#define MAX(x, y) «x» =(y)1(x):(y)) 
\·Ve use the capital MAX to distinguish it from the many functions called max (in 
various programs). Obviously, this is very different from a function: there arc no 
argument types, no block, no relUnl statement, etc., aJld what are all those pa]1!n-
theses doing? Consider: 
int aa = MAX(t ,2); 
double dd = MAX{aa++,2); 
char cc = MAX(dd,aa)+2; 
111is expands 10 
int aa = ((1» =( 2)1(1):(2»; 
double dd = «aa++» =(2)?( aa++):(2»; 
char cc = «dd» =(aa)?(dd):(aa»+2; 
Had "all the parentheses" not been there, the last expansion would have ended 
up as 
char cc = dd>=aaldd :aa+2; 
That is, ec could easily have gotten a different value from what you would rea-
sonably expect looking at the definition of ce. When you define a macro, remem-
ber to put every use of an argument as an expression in parentheses. 
On the other hand, not all the parentheses in lhe world could save the sec-
ond expansion. The macro parameter x was given the value aa++, and since x is 
used twice in MAX, a can get incremented twice. Don't pass an argument with a 
side effect to a macro. 
As it happens, some genius did define a macro like that and sulck it in a pop-
ular header file. Unfortunately, he also called it max, rather than MAX, so when 
the C++ standard header defines 

27.6 
MAC ROS 
template<class T> inline T max(1 a,T b) ( return a<blb:a; ) 
the max gets expanded with the arguments T a and T b, and the compiler sees 
template<class T> inline T «(1 a»=( T b)"f( T a):( T b» ( return a<b?b:a; ) 
The compiler error messages are "interesting" and not very helpful. In an emer-
gency, you can "unddine" a macro: 
#undef max 
Fortunately, that macro was not all that important. However, there arc tens of 
thousands of macros in popular header HIes; you can't undefine them all without 
causing havoc. 
Not all macro parameters are used as expressions. Consider: 
#define AlLOC(T,n) «P)malloc(sizeof(T)·n» 
-n lis is a real example that can be very useful for avoiding errors stemming from 
a mismatch of the intended lype of an allocation and its lise in a sizeof: 
double· p = malloc(sizeof(inW10); 
,. likely error ., 
Unfortunately, it is nontrivial to write a macro that also catches memory exhaus-
tion. TIlis might do, provided that YOll define error_var and errorO appropriately 
somewhere: 
#define AllOC(T,n) (error_var = (P )malloc(sizeof(T)·n), \ 
(erro,_var==O)\ 
l(errof("memoryallocation failure"),O)\ 
:error_var) 
-nle lines ending with \ arc not a typesetting problem; it is the way you break a 
macro definition across lines. When writing C++, we prefer to usc new. 
27.8.2 Syntax macros 
YOlt can define macros that make the source code look more to your taste. For 
example: 
#define forever for(;;) 
#define CASE break; case 
#define begin { 
#define end } 
1023 

1024 
(HAPTER 27 • TH E ( PROG RAMMING LANG UAGE 
We strongly recommend against this. Mati) people have tried this idea. ·nley (or 
the people who maintain their code) find that 
Many people don't share their idea of what is a better syntax. 
TIle "improved" syntax is nonstandard and surprising; others b'Ct confused. 
There are uses of the "improved" syntax that cause obscure com pi l e~time 
errors. 
What you see is not what the compiler sees, and the compiler reports er-
rors in the voc'-lbulary it knows (and sees in source code), not in yours. 
Don't write syntactic macros to "improve" the look of code. You and your best 
friends might find it really nice, but experience shows that you'll be a tiny minor· 
ity in the larger community, so that someone will have to rewrite your code (as· 
suming it survives). 
27.8.3 Conditional compilation 
Imagine you have two versions of a header file, say, one for Linux and one for 
Windows. How do you select in your code? Here is a common way: 
#ifdef WINDOWS 
#indude "my_windows_header.h" 
#elsc 
#indude "my_linux_hcader.h" 
#endif 
Now, if someone had defined WINDOWS before the compiler sees tills. tile effect is 
#indude "my_windows_header.h" 
Otherwise it is 
111e #ifdef WINDOWS test doesn't care what WINDOWS is defined to be; it just 
tests that it is defmed. 
Most major systems (including all operating system variants) have macros 
defined so that you can check. 111e check whether you are compiling as C++ or 
compiling as C is 
#ifdef _ cplusplus 
/I in C++ 
#else 
l" in C -/ 
#endif 

27.9 
AN EXAMPLE: INTRUSIVE CONTAINERS 
A similar construct, often called an inell/de guard, is commonly used LO prevent a 
header file from being #included twice: 
r my_windows_hcadcr.h: "' 
#ifndef MY_WINDOWS_HEADER 
#define MY_WINDOWS_HEADER 
'0 
here is the header information "' 
#endif 
111C #ifndef tcst checks that somcthing is not defincd; i.e., #ifndef is lhe opposite 
of #ifdef. Logically, these macros used for source file control arc very different 
from the macros we use for modifying source code. ~nl ey just happen to use the 
same underlying mechanisms to do their job. 
27.9 An example: intrusive containers 
TIle C++ standard library containers, such as veclor and map, arc non·intrusive; 
that is, they require no data in the types used as elements. ~Ina t is how they gen-
eralize nicely to essentially all types (built-in or user-defined) as long as those 
types can be copied. There is another kind of container, an intrusive container, that 
is popular in both C and C++. We will use a non·intrusive list to illustrate C-
style usc of structs, poimers, and free store. 
Let's define a doubly-linkcd list with nine operations: 
void inil(slruct lisl" lsi); 
slrucl lisl" ereale(); 
'0 
inilialize 1st to empty 0' 
void clear(slruct list O 151); 
void destroy(slruct listO lsI); 
'0 make a new empty list on free store 0' 
' " free all elements of 1st 0' 
' " free all elements of 1st. then free 1st 0' 
void push_back(slrucl listO lsI, slruct link" p); 
void push_fronl(slruct List". slruct link" p); 
' " inscrt q before p in 1st: "' 
'0 
add p at end of 1st 0' 
r add p at fronl of 1st 0' 
void insert(strucl list" 151, slrucl link" p, slruct Link" q); 
slrucllink" erase(slrucl Lisl" 151, slruct link" P)i '0 
remove p from 1st "' 
' " return link n "hopsH before or after p: "' 
slruct link" advance(slrucl Linko p, inl n); 
The idea is to define these operations so that their users need only use List"s and 
Linkos. This implies that the implementation of these functions could be changed 
radically without affecting those users. Obviously, the naming is inOucnccd by 
the ST1... List and Link can be defined in the obvious and trivial manner: 
1025 

1026 
CHAPTER 27 - THE C PROG RAMM ING LANGUAGE 
struCi list { 
struellink· firsl; 
slruellink· lasl; 
); 
slruCi link { 
/- link for doubly-linked list */ 
); 
shuet link- pre; 
struCi link- sue; 
Here is a graphical representation of a list: 
liSI:,.,-,:-__ -, 
fl"t 
last 
link:r-_-''--_-, 
pre 
pre 
sue 
sue 
--------------
'-'=-_----.J 
sue 
It is nOt our aim to dcmonstrate clever representation techniqucs or clever algo-
rithms, so there arc none of those here. However, do notc that there is no men-
tion of any data held by the links (the e1emcnts of a lisl). Looking back at thc 
fUIletions provided, we nOte that we are doing something very similar 10 defining 
a pair of abstract classes link and list "nlc data for links will bc supplied later. 
link- and list- are sometimes called handles to opaque types; that is, giving 
link· s and list·s to our functions allows us to manipulate e1ement:s of a list with-
OUI knowing anything about the internal structure or a link or a list 
To implement our list rUllctions, we first #indude some standard library 
headers: 
#include<stdio.h> 
#include<stdlib.h> 
#include<assert.h> 
C doesn't have namespaces, so we need not worry about using declarations or 
using direetives_ On the other hand, we should probably won)' that we have 
grabbed some very common short names (link, insert, init, etc.), so this set or 
rUllclions cannot be used "as is" outside a toy program. 
Initializing is trivial, but note the usc or assertO: 

27. 9 
AN EXAMPLE: INTRUSIVE CONTAINERS 
void init(strue! ListO lsI) 
{ 
/0 initialize 0p to the empty lisl 0/ 
assert(lsl); 
Ist->first = Ist->Iast = 0; 
We decided not to deal with error handling for bad pointers to lists at nm time. 
By using assertO, we simply give a (run-time) system error if a list pointer is null. 
111e "system enor" will give the rue name and line number of the failed assertO; 
assertO is a macro deflned in <aSserf.h> and the checking is enabled only during 
debugging. In the absence of exccptions, it is not easy to k.now what to do with 
bad pointers. 
"n le createO fUllction simply mak.es a List on the free SLOrc. It is a sort of 
combinauOIl of a constructor (initO initializes) and new (mallocO allocates): 
strue! List" e,eateO 
{ 
I" make a new empty list 0' 
) 
strue! List" 1st = (struet List")malloe(sizeof(struct list"»; 
init(lst); 
return 1st; 
"nle dearO function assumes that all Links arc created on the free store and 
frccOs them: 
void dear(struet List" 1st) 
I" free all clements of 1st "' 
{ 
) 
assert(lst); 
{ 
) 
struct Linko curr = Ist->first; 
while(curr) { 
) 
struet linko next = curr->suc; 
free(eurr); 
eurr = next; 
Ist->first = Ist->Iast = 0; 
Note the \vay we traverse using the sue member of Unk. We can't safely access a 
member of a struet object after that object has been freeOd, so we introduce the 
variable next to hold our position in the List while we freeO a Link. 
1027 

1028 
C H APTER 27 • THE C PROGRAMM ING LANGUAGE 
If we didn't allocate all of Ollf Links on the free store, we had better not call 
clearO, or clear() will create havoc. 
111C deslroyO function is essentially the opposite of createD. that is, a son of 
combination of a dcstrucLOr and a delete: 
void deslroy(slrucl Lisl * 151) '* 
free all elements of 151; then free 1st *' 
( 
assert(lst); 
clear(lsl); 
(ree(lsl); 
Note that we are making no provisions for calling a cleanup function (destruc-
tor) for the clements represented by links. 111is design is not a completely faith-
ful imitation of C++ techniques or generality -
it couldn't and probably 
shouldn't be. 
The push_backO function - adding a link as the new last link - is preuy 
straightforward: 
void push_back(struct list- 1st, slruct link- p) 
/* add p at end of 1st -/ 
( 
) 
assert{lsl); 
( 
) 
slruct Link- lasl = Isl->lasl; 
if (lasl) { 
) 
else { 
) 
lasl->suc = p; 
p->pre = lasl; 
Ist->fifSt = p; 
p->pre = 0; 
Ist->Iast = p; 
p->suc = 0; 
/. add p after last -/ 
r p is the first element -/ 
/ - P is the new last clement -/ 
However, we would never have gotten it right without drawing a few boxes and 
armws on our doodle pad. Note that we "forgot" to consider the case where the 
argument p was nulL Pass 0 instead of a poimer to a Link and this code will fail 
miserably. Tllis is not inherently bad code, but it is 1/01 industrial strength. Its pur-
pose is to illustrate COillmon and useful techniques (and, in this casc, also a cam-
mon \\'caknessfbug). 

27.9 
AN EXAMPL E: INTRUSIVE CONTA INER S 
The eraseO function can be written like this: 
slruct Link· erase(slrucl Lisl· lSI, slruct Link- p) 
/, 
' / 
{ 
} 
remove p from lSI; 
return a pointer to the link after p 
asserl(lsl)j 
if (p==O) return OJ 
, - OK 10 erase(O) -, 
if (p == Isl->first) { 
} 
if (p->suc) { 
else { 
Isl->firSI = p->suc; 
p->suc->pre = OJ 
return P->SUCj 
r the successor becomes first -' 
Isl->first = Ist->Iasl = OJ r the list becomes emply -, 
return OJ 
else if (p == Isl->lasl) { 
if (p->pre) ( 
} 
else { 
} 
} 
else { 
} 
Ist->Iast = Il->pre; '* the predecessor becomes last -, 
p->pre->suc = 0; 
Ist->firsl = Ist->Iast = 0; 
,- the list becomes emply ., 
return 0; 
p->suc->pre = p->pre; 
p->pre->suc = p->suc; 
return p->suc; 
We will leave the rest of the functions as an exercise, as we don't need them for 
our (all tOO simple) test. However, now we must face the cemral mystery of this 
design: Where is the data in the clements of the list? How do we implement a 
simple list of names represented by a C-slyJe string? Consider: 
1029 

1034) 
CH APTER 27 • TH E C PRO GRAMMING LANGUAG E 
slruct Name { 
) ; 
struct Link Ink; 
char· p; 
'* 
the l ink required by list operations *' 
,. the name string *' 
So far, so good, though how we gel to use that Link member is a mystery; but 
since we know that a list likes its Links on the free store, we write a fUllction cre-
ating Names on the free store: 
slruct Name- make_name(char* nl 
{ 
) 
slrucl Name· p = (struel Name*)malloc(sizeof(slruct Name»; 
p->p = n j 
return Pi 
Or graphic. ... Uy: 
list-
first 
Link: /
WI 
-
I pre 
-
pre 
I- . . . . . . . . . . . pre 
sue 
-
sue 
._-------.--.. sue 
n 
n 
n 
Now let's lISC that: 
int mai nO 
{ 
struCllist names; 
struc' list- curT; 
init(&names); 
r make a few Names and add them to the list: *' 
pu sh_back(& names,(shu ( I link· lmake_ name(" Norah "» i 
push_back(&names,(shuct Link*)make_name("Annemarie"))j 
push_back(& nam es,{struct Link-)make_name{"Kris")); 
, - remove the second name (with index 1): ., 
erase{&names ,ad vanceC names. first, 1)); 
-

CHAPTER 27 RE VIEW 
1031 
) 
curr = names.first; 
,- write out all names -, 
inl count = 0; 
for (; curr! =O; curr=curr->suc) { 
count++; 
printf("element %d: %s\n", count, «struct Name· )curr)->p); 
) 
So we "cheated." We used a cast to lfeat a Name- as a link-. in that way, the user 
knows about the "library-type" link. However, the "'library" doesn't know about 
the "application·type" Name. Is that allowed? Yes, it is: in C (and C++), you can 
treat a poimer to a struct as a pointer to its first element and vice versa. 
Obviously, this list example is also C++ exactly as written. 
TRY THIS 
A common refrain among C++ programmers talking with C programmers 
is, "Everything you can do, I can do beuer!" So, rewrite the intrusive list ex-
ample in C++, showing how to make it shoner and easier to use without 
making the code slower or the objects bigger. 
~ 
Drill 
I. Write a "'Hello, World!" program in C, compile it, and run it. 
2. Define two variables holding "Hello" and "World!" respectively; concate-
nate them with a space in between; and output them as Hello, World!. 
3. Define a C function that takes a char· parameter p and an int parameter 
x and print out their values in this fonnat: p is "foo" and x is 7. Call it 
with a few argument. pairs. 
Review 
Ll lhe following, assume that by C we mean ISO standard C89. 
I. Is C++ a subset of C? 
2. Who invclllcd C? 
3. Name a highly regarded C textbook. 
4. In what organization were C and C++ invcmed? 
5. Why is C++ (almost) compatible with C? 
6. Why is C++ only almast compatible with C? 

, 1032 
7. 
8. 
9. 
10. 
II. 
12. 
13. 
14. 
15. 
16. 
17. 
18. 
19. 
20. 
21. 
22. 
23. 
24. 
25. 
26. 
27. 
28. 
29. 
30. 
3 1. 
32. 
33. 
34. 
35. 
Terms 
CHAPTE R 2 7 • THE C PROGRAMM ING LANGUAGE 
List a dozen C++ fearures not presenl in C. 
What organization "owns" C and C++? 
List six C++ standard library components that crumot be used in C. 
'Which C standard library components can be used in C++? 
How do you achieve function argument type checking in C ? 
What C++ features related to functions are missing in C? List at least 
three. Give examples. 
How do you call a C function from C++? 
How do you call a C++ function from C? 
Which types are layout compatible between C and C++? (just) give ex· 
amples. 
'What is a stmcture tag? 
List 20 C++ keywords that are not keywords in C. 
Is "int x;" a definition in C++? In C ? 
What is a C-sty1c cast and why is it dangerous? 
'What is void* and how docs it differ in C and C++? 
How do enumerations differ in C and C++? 
What do you do in C to avoid linkage problems from popular names? 
What are the three most common C functions from free-store usc? 
What is the definition of a C-style string? 
How do == and strcmpO differ for C-style strings? 
How do you copy C-style strings? 
How do you lind the length of a C-style string? 
How would you copy a large array of ints? 
What's ruce about printf()? What arc its problemsnimitations? 
Why should you never use gels()? 'What can you usc instead? 
How do you open a file for reading in C? 
What is the difference benveen const in C and const in C++ ? 
Why don't we like macros? 
What are common uses of macros? 
What is an include guard? 
#defin e 
DelUlis Ritdue 
non-mtnlsive 
#ifdef 
FILE 
opaquecypc 
#ifndef 
fopenO 
overloading 
Bell Labs 
fonnat string 
printfO 
Brian Kernighan 
Lmrusivc 
strcpyO 
C/C++ 
K&R 
structure tag 
compatibility 
lexicographical 
three-way comparison 
conditional compilation 
linkage 
void 
C -style cast 
macro 
void· 
C-style string 
maliocO 

CHAI'TER 27 EXERCISES 
Exercises 
For these exercises it may be a good idea to compile all programs with both a C 
and a C++ compiler. If you lise only a C++ compiler, you may accidentally use 
non·C features. If YOll usc only a C compiler, type errors may remain undetected. 
I. Implement versions of strlenO, strcmp(), and strcpyO. 
2. Complete the intnlsive list example in §27.9 and test it using every 
function. 
3. "Pretty up" the intnlsive list example in §27.9 as best you can to make it 
convenient to use. Do catch/handle as many errol's as you can. It. is fair 
game to change the details of the slruct defInitions, to usc macros, whatevel'. 
4. If you didn't already, write a C++ version of the intrusive list example 
in §27.9 and test it using every function. 
S. Compare lhe results of exercises 3 and 4. 
6. Change t.he representation of link and List from §27.9 without. changing 
the lIser interface provided by the functions. AlIOC<"1tc Links in an array of 
links and have the members first, last, pre, and sue be inls (indices into 
the array). 
7. What are the advantages and disadvantages of intrusive containers com· 
pared to C++ standard (non·intrusive) containers? Make lists of pl'OS 
and cons. 
8. \¥hat is the lexicographical order on your machine? Write out every 
character on your keyboard together with its integer value; then, write 
the characters out in the order detennined by their integer value. 
9. Using amy C facilities, including lhe C standard library, read a sequence 
of words from stdin and write them to stdout in lexicographical order. 
H.int : 111e C sort function is called qsort(); look it up somewhere. Alter-
natively, insert the words into an ordered list as you read them. 111ere is 
no C standard library list. 
10. Make a list of C language features adopted from C++ or C with Classes 
(§27.l). 
11. Make a list of C language features not adopted by C++. 
12. Implement a (C·style string, int) lookup table with operations such as 
find(struct table-, const char-), insert(struct table-, const char-, in!), 
and remove(struct table-, const char·). The representation of lhe table 
could be an array of a struct pair or a pair of arrays (const char· 1l and 
int-); you choose. Also choose return types for your functions. Docu· 
ment your design decisions. 
13. Write a program lhal does the equivalent of string s; cin»s; in C; that 
is, define an input operation lhat reads an arbitrarily long sequence of 
whitespace·terminated characters into a zero·terminated array of chars. 
14. Write a function that takes an array of ints as its input and finds the 
smallest and the largest clements. It should also compute the median and 
mean. Usc a struct holding the results as the return value. 
1033 

1034 
CHAPTER 27 • TH E C PROGRAMMING LANGUAGE 
15. Simulate single inheritance in C. Let each "base class" contain a pointer 
to an array of pointers to functions (to simulate virtual functions as free-
standing functions taking a pointer to a "base class" object as their first 
argument); see §27.2.3. Implement "derivation" by making the "base 
class" the type of the first member of the derived class. For each class, ini-
tialize lhe array of "virtual functions" appropriately. To test the ideas, im-
plement a version of "the old Shape example" with the base and derived 
drawO just printing out the name of their class. Usc only language fea-
tures and library facilities available in standard C. 
16. Use macros to obscure (simplify the nOtation for) the implementation in 
the previous exercise. 
Postscript 
We did mention that compatibility issues arc not all that exciting. However, there 
is a lot of C code "outlhere" (billions of lines of code), and if you have to read or 
write it, this chapter prepares you to do so. Personally, we prefer C++, and the 
information in this chapter gives part of the reason for that. And please dOIl't 
underestimate that "intrusive List" example - hOlh "intrusive Lists" and opaque 
types arc important and powerful techniques (in both C and C++). 

Part V 
Appendices 


el . 
f'" A 
Language Summary 
"Be careful what you wish for; 
you might get it." 
- Traditional 
T
his appendix summarizes key language elements or c++. 
The summary is vcry selective and specifically geared lO 
novices who want to explore a bit beyond the sequence or topics 
in the book. The aim is conciseness, not completeness. 
1037 

'"'" 
14..1 General 
14..1.1 Terminology 
14..1.2 Program start and termination 
14..1.3 Comments 
A.2 Literals 
14..2.1 Inleger lite rals 
14..2.2 floating-point·literals 
A.2.3 Boole;an liter;llis 
"'.2.4 Charade r lile rals 
04.2.5 Siring literals 
A.2.6 The pointer lite ral 
A.3 Identifiers 
A.3.1 keywords 
14..4 Scope, storage class, and lifetime 
04.4.1 Scope 
A.4.2 SIOtJlge class 
" .4.3 lifetime 
A.S Expressions 
A.5. t User-defined operillo rs 
04.5.2 Implicil'ype conversion 
A.5.3 Conslant expressions 
A.S.4 sizeof 
A.5.5 logical expressions 
A.5.6 new and delete 
14..5.7 Casts 
14..6 Statements 
14..7 Declarations 
14..7.1 Definitions 
A.8 Built-in types 
14..8.1 Pointers 
A.S.2 Arrays 
14..8.3 References 
A.l General 
AP PENDIX A • LANGUAGE SUMMARY 
A.9 Functions 
14..9.1 Overload resolution 
A.9.2 Default arguments 
A.9.3 Unspecified arguments 
A.9.4 linkage specifications 
1\.10 User·defined types 
A.l0.l Operator overloading 
1\.11 Enumerations 
1\.12 Classes 
A.12.1 Member access 
A.12.2 Class member definitions 
A.12.3 Construction, destruction, and 
copy 
A.12.4 Derived classes 
A.12.5 Bitfields 
A.12.6 Unions 
1\.13 Templates 
A.13.1 Template arguments 
A.13.2 Template instantiation 
A.n .3 Template member types 
1\.14 Exceptions 
A.15 Namespaces 
A.16 Aliases 
A.17 Preprocessor directives 
A.17.1 . include 
A.17.2 #define 
111is appendix is a reference. It is not intended to be read fTOm beginning to end 
like a chapter. II (morc or less) systematically describes key clements of the C++ 
language. It is not a complete reference, though; it is just a summary. Its focus 
and emphasis were determined by student questions. Often, you will need to 
look at the chapters for a more complete explanation. 'n tis summary docs Ilot at· 
tempt to equal the precision and terminology of the standard. Instead, it attempts 
to be accessible. For more information, see Stroustrup, The C++ Programming Lall-

A.I 
GENERAL 
guage. ~111e defmition of C++ is the ISO C++ sla.ndard, but that document is nei· 
ther intended for nor suitable for novices. Don't forget to usc your online docu-
mentation. If you look at this appendix while working on the early chapters, 
expect much to be "mysterious," that is, explained in later chapters. 
For standard library facilities, sec Appendi. ... B. 
rnle standard for C++ is defined by a conunittee working under the auspices 
of the ISO (the international organization for standards) in collaboration with na' 
tional standards bodies, such as INCIT'S (United States), BSI (United Kingdom), 
and AFNOR (France).llle current defmition is ISO/IEC 14882:2003 Slmuulrdfor 
ItogTtlllllllillg umguage C++. It is available elccLrouically and as a book (on paper): 
77le C++ Sialldard, published by Wliey, ISBN 0470846747. 
A.l .l Terminology 
rille C++ standard defines what a C++ program is and what the various con-
structs mean: 
Cm!fimllillg: A program that is C++ according to the standard is called 
(OI/onllillg (or colloquially, legal or valid). 
Impleme1llation tlefinetl: A program can (and usually does) depend on fea-
tures (such as the size of an int and the numeric value of'a') that arc only 
well defined on a given compiler, operating system, machine architecture, 
etc. rIlle implementation-defined fealUres are listed in the standard and 
must be documented in implementation documentation, and many are 
reflected in standard headers, such as <limits> (sec §B.l.l). So, being con-
forming is not the same as being portable to all C++ implementations. 
Ulupecifietl: rnle meaning of some constructs is lIIujJecjjied, U!u/4illetl, or 1101 
wlfonnillg bul 1101 rtqllin·llg a diagnostic. Obviously, such features are best 
avoided. rnlis book avoids them. The unspecified features to avoid 
include 
Inconsistent definitions in separate source files (use header files COIl-
sistently; see §8.3) 
Reading (uul writing the same variable repeatedly in an expression 
(the main example is a[il=++i; ) 
Many uses of explicit type conversion (casts), especially of reinter-
preCcasl 
A.l .2 Program start and termination 
A C++ program must have a single global function called mainO. TIle program 
starts by executing mainO. TIle rctum type of mainO is int (void is 1101 a conform· 
ing alternative). enle value returned by mainO is the progranl's return value to 
1039 

'040 
APPEND IX A • LANG UAGE SUMMA RY 
';thc system." Some systems ignore that value, but succcssfullcrmination is indi-
ca.tcd by returning zero and failure by rCluming a nonzero value or by an un-
caught exception (bUl an unc.1.ught exception is considered poor style), 
~nlC arguments to mainO can be implementation defined, but every imple-
mentation must accept two versions (though only one per program): 
inl main(); 
1/ no arguments 
int main(inl argc, char- argvl]); /I argvl! holds argc C-stylc wings 
111c definition of mainO need not explicitly retum a value. If it doesn't, "drop-
ping through the bottom," it returns a zero. 11lis is the minimal C++ program: 
inl mainO { } 
if you define a global (namcspacc) scope object with a constructor and a destruc-
tor, the constmcl'Or will logically be executed "before mainO" and the destructor 
logically executed "after mainO" (technically, executing those constructors is parl 
of invoking mainO and executing the dcstructors part of TCtuming from mainO). 
Whenever you can, avoid global objects, cspecially global objects requiring non· 
trivial construction and destruction. 
A.1.3 Comments 
What C<'l.n be said in code, should be. However, C++ offers two comment styles 
to allow the programmer to say things thal are not well expressed as code: 
II this is a line comment 
,. 
this is a 
block comment 
., 
Obviously, block comments arc mostly used for multi-line commelllS, though 
some people prefer single-line commems even for multiple lines: 
IIlhis is a 
II multi-line comment 
"expressed using three line comments 
r and this is a single line of comment expressed using a block comment -, 
Comments are essemial for documeming the illtCIll of code; sce also §7.6.4. 

A.2 
LITERALS 
A.2 literals 
Literals represent values of various types. For example, the literal 12 represents 
the integer value Mtwelve," "Morning" represents the character string value Mom-
il/g, and true represent the Boolean value fme. 
A.2.1 Integer literals 
/I/ttger Jiterau come in three varieties: 
Decimal: a series of decimal digits 
Decimal dibrits: 0, 1, 2, 3, 4, 5, 6,7,8, and 9 
Octal: a series of octal digits starting with 0 
Octal digits: 0, 1, 2, 3, 4, 5, 6, and 7 
Hexadecimal: a series of hexadecimal digits starting with Ox or OX 
Hexadecimal digits: 0, 1,2,3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, A, 13, C, D, E, 
and F 
A suffix u or U makes an integer literal unsigned (§25.5.3), and a SUlTlX I or L 
makes it long; for example, 10u and 123456Ul. 
A.2.1.1 Number systems 
We usually write out numbers in decimal notation. 123 means 1 hundred plus 2 
tens plus 3 ones, or 1°100+2·10+r 1, or (using " to mean "to the power or) 
1"10112+rl0111+3*101l0. Another word for decimal is base-IO. TIlere is nothing 
really special about to here. What we have is 1*base Il2+2*baseIl1+3*base"O 
where base==10. TIlere are lots of theories about why we use base-tO. One the-
ory has been "built into" SOUle natural languages: we have ten fingers and each 
symbol, such as 0, I, and 2, that directly stands for a value in a positional num-
ber system is called a digit. Digit is Latin ror "finger." 
Occasionally, other bases are used. Typically, positive integer values in COIll-
pUler memory are represented in base-2 (it is relatively casy to reliably represent 
o and I as physical states in materials), and humans dealing with low-level hard-
ware issues sometimes usc base-8 and more often base-16 to rerer to the cOlllem 
ormemOlY· 
Consider hexadecimal. We need to name the 16 values rrom ° 
to 15. Usu-
ally, we Lise 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, 13, C. D, E, F, where A has t.he decimal 
value 10, 13 the decimal value 11 , and so on: 
A==IO, 1l==11, C==12, D==13, E==14, F==15 
We can now write the decimal value 123 as 78 using the hexadecimal notation. 
~Ib sec that, note that in the hexadecimal system 78 means '·16+11, which IS 
(decimal) 123. Conversely, hexadecimal 123 means "16"2+2·16+3, which is 
1041 

1042 
APP ENDIX A • LAN GU AGE SU MMARY 
"256+2"16+3, which is (decimal) 291 . U you have never deah with non-decimal 
integer representations, we strongly recommend you try converting a few num-
bers LO and from decimal and hexadecimal. Note that a hcxadccimru digit has a 
VCIY simple correspondence to a binary value : 
Hexadecimal and binary 
he> 
binary 
binary 
o 
0000 
8 
1000 
1 
0001 
9 
1001 
2 
0010 
A 
1010 
3 
0011 
8 
1011 
4 
0100 
C 
1100 
5 
0101 
D 
1101 
• 
0110 
E 
1110 
7 
0111 
F 
1111 
This goes a long way toward explaining the popularity of hexadecimal notation. 
In particular, the value of a byte is simply expressed as two hexadecimal digits. 
In C++, (fortunately) numbers arc decimal unless we specify otherwise. To 
say that a number is hexadecimal, we prcflX ox ("X for hex"), so 123==OX78 and 
OX123==291 . We can equivalently use a lowercase x, so we also have 123==Ox78 
and Ox123==291 . Similarly, we can use lowercase a, b, c, d, e, and f for the hexa-
decimal digits. For example, 123==Ox7b. 
Octal is base-8. We need onl y eight octal digits: 0, 1, 2, 3, 4, 5, 6, 7. In C++, 
base-8 Ilumbers are represented starting with a 0, so 0123 is not the decimal num-
ber 123, but 1*8"2+2*8+3, that is, 1*64+2*8+3, or (decimal) 83. Conversely, octal 
83, that is, 083, is 8*8+3, which is (decimal) 67. Using C++ notation, we get 
0123==83 and 083==67. 
Binary is base-2. We need only two digits, 0 and 1. We cannot directly repre-
sent base-2 numbers as litcrals in C++. Only base-8 (OCtal), base-lO (decimal), 
and base-16 (hexadecimal) are directly supported as literals and as input and out-
put formats for integers. However, binary numbers are useful to know even if we 
cannOt directly represent them in C++ texl. For example, (decimal) 123 is 
which is "64+"32+"16+1*8+0*4+"2+1 , which is (binary) 1111011. 
A.2.2 Floating-point-lite,als 
A jloaling-point-literal contains a decimal pOllll (.), an exponem (e.g., e3), or a 
floating-point suffix (d or f). For example: 
123 
II int (no decimal point, suffix, or exponent) 
123. 
II double: 
123.0 

A2 
LITERAL S 
123.0 
/I double 
.123 
/I double: 
0.123 
0.123 
/I double 
1.23eJ 
II double: 
1230.0 
1.23e-J 
II double: 
0.00123 
1.23e+J 
II double: 
1230.0 
l<'oating-point-litcrals have type double unless a sufiix indicates otherwise. For 
example: 
1.23 
/I double 
1.23f 
/I float 
1.2JL 
II long double 
A.2.3 Boolean literals 
rIne literals of lype bool arc true and false. The integer value of lrue is 1 and the 
itllcgcr value of false is O. 
A.2.4 Character literals 
A (hllT(Utu liteml is a character enclosed in single quotes, for example, 'a' and '@' . 
In addition, there arc some "special characters": 
Name 
ASCII name 
C+. name 
newline 
Nl 
In 
horizontal tab 
HT 
" 
vertical tab 
VT 
Iv 
oockspace 
BS 
Ib 
carriage return 
CR 
I.-
form feed 
FF 
V 
alert 
BEl 
I. 
backslash 
I 
II 
question mark 
1 
II 
single quote 
I' 
double quote 
" 
I" 
octal number 
000 
1000 
hexadecimal number 
hhh 
\xhhh 
1043 

1044 
APPENDIX A • LANGUAGE SUMMARY 
A special character is rtprcscmcd as its "C++ name" enclosed in single quotes, 
for example, '\n' (newline) and '\1' (tab). 
The characLCr set includes the following visible characters: 
abcdefghijklmnopqrsluvwxyz 
ABCDEFGHIJKlMNOPQRSTUVWXYZ 
0123456789 
!@#S%"'&·(L +I-·u(]: n;'<>7,J 
In portable code, you C<'l.nnOt rely on morc visible characters. 111e value of a 
character, such as 'a' for a, is implementation dependent (but casily discovered, 
for example, coul « int('a'»). 
A.2.S String literals 
A Jlrillg literal is a series of characters enclosed in double quotes, for example, 
"Knuth " and "King Canute", A newline c.'lnnot be part of a string; instead lise the 
special character \n to represelll newline in a string: 
" King 
Canute " 
"King\nCanute" 
II error: newline in string literal 
/I OK: correct way to get a newline into a string literal 
Two string literals separated only by whitespace arc taken as a single string lit~ 
eraJ. For example: 
" King" "Canute" 
II equivalent 10 "KingCanutc" (no space) 
Note lhat special characters, such as \n, can appear in string literals. 
A.2.6 The pointer literal 
'TIlere is only one poi1ller lilira': tIle null poilller, O. Any constaIll expression lhat 
evaluates to 0 can be used as the null pointer. For example: 
l· p1=O; 
inl· p2 = 2-2; 
inl· p3= 1; 
inI 2= O; 
inl· p4 = 2; 
IIOK: null pointer 
II OK: null pointer 
II error: 1 is an inl, not a pointer 
II error: z is nol a conslant 
What is happening here is that the value 0 is implicitly converted to the null 
pointer. The null pointer is typically (but not always) represented as an all-r.eros 
bit pauern, just like o. 

A.3 
IDENTIFIERS 
In C++ (but not in C, so beware of C headers), NULL is defined to mean 0 
so that you can write 
int· p4 = NU LL; 
II (given the right definilion of NUll) Ihe null pointer 
In C++Ox. the keyword nullplr will denote the null pointer. For now, we recom-
mend just using 0 for the null pointer. 
A.3 Identifiers 
An idnltjJier is a sequence of characters starting with a letter or an underscore fol-
lowed by zero or more (uppercase or lowercase) letters, digits, or underscores: 
inl foo_bar; 
inl FooDar; 
inl foo bar; 
inl fooSbar; 
/10K 
/10K 
/I error: space can't be used in an identifier 
/I error: S can't be used in an identifier 
Identifiers starting with an underscore or containing a double underscore arc re-
served for lise by the implementation; don't use them. For example: 
int _foe ; 
int foo_bar; 
int foo_ bar; 
int foo_; 
A.3.1 Keywords 
/I don't 
II OK 
/I don't 
/10K 
KeYWOrtU arc identifiers lIsed by the language ilSelf to express language conStn.lClS. 
Keywords (reserved identifiers) 
.nd 
and_eq 
"m 
auto 
bitand 
bitor 
bool 
break 
case 
catch 
char 
class 
campi 
const 
consCcast 
continue 
default 
delete 
do 
double 
dynamic_cast 
else 
enum 
explicit 
export 
extern 
false 
float 
[0' 
friend 
goto 
;[ 
in line 
int 
long 
mutable 
namespace 
new 
not 
noCeq 
operator 
0' 
'045 

'046 
APPENDIX A • LANGUAGE SUMMARY 
Keywords (reserved identifiers) (continued) 
of_eq 
private 
protected 
public 
register 
reinterpret-cast 
return 
shorl 
signed 
sizeof 
static 
stalic_cast 
strucl 
switch 
template 
this 
throw 
true 
" Y 
typedef 
Iypeid 
typename 
union 
unsigned 
using 
virtual 
void 
volatile 
wchar_t 
while 
'0' 
xor_eq 
A.4 Scope, storage class, and lifetime 
Every name in C++ (with the lamentable exception of preprocessor namcs; sec 
§A. 17) exists in a scope; that is, the name belongs La a region of text in whidl it 
can be used. Data (objects) are stored in memory somewhere; the kind of mem-
ory lIsed to store an object is called its slamge claJJ. -The lifetime of an object is 
from the time it is first initialized until it is finally destroyed. 
A.4.1 Scope 
-m ere arc five kinds of JCOjxJ (§8.4): 
Global JrojJe: A name is in global scope unless it is declared inside some 
language construct (e.g., a class or a function) . 
.Nillllesptue scojJe: A name is in a namespace scope if it is defined within a 
namcspace and not inside some language construct (e.g., a class or a 
function). Technically, the global scope is a namespace scope with "the 
empty name.
n 
Local JcojJe: A Ilame is in a local scope if it is declared inside a fu nction 
(this includes funcliol1 parameters). 
C/aJJ scope: A name is in a class scope if it is the name of a member of a 
class. 
Statelllent JrojJe: A I1mlle is in a statement scope if it is declared in the ( ... ) 
pan of a foro, while-, switch-, or if-statement. 
111e scope of a variable extends (only) to the end of the statement in which it is 
defined. For example: 
for (int i = 0; i<v.size(); ++i) { 
II i can be used here 
} 
if (i< 27) 
/I the i from the fOf-Statement is not in scope here 

A.4 
SCO PE , STORAGE ClASS, AND LIFETIME 
Class and namcspacc scopes have names, so that we can refer to a member from 
"elsewhere." For example: 
void mj 
/I in global scope 
names pace N { 
void ro 
II in narnespace scope N 
( 
) 
int v; 
/I in local scope 
:: f() j 
Il calllheglobalfO 
void fO 
( 
N: :fO; 
/I call N's fO 
) 
What would happen if you called N: :f() or : :f()? See also §A.15. 
A.4.2 Storage class 
111erc arc three J/omge c!ruses (§ 17.4): 
Au/omillic Jtomge: Variables defined in functions (including function pa· 
r.unelers) arc placed in automatic storage (i.e., "on the stack"') unless ex' 
plicitly declared to be static. Automatic storage is allocated when a 
function is called and deallocated when a call retums; thus, if a function 
is (directly or indirectly) called by itself, multiple copies of automatic 
data C.-11l exist: one for each call (§8.5.8). 
Stahc Jtomge: Variables declared in global and namespacc scope arc stored 
in static storage, as are variables explicitly declared static in functions 
and classes. The linker allocates static storage "before lhe program stans 
nmning." 
Fru Jtore ~leajJ}.· Objects created by new arc allocated in the free store. 
For example: 
veclor<inl> vg(10); 
/I constructed once at program start ("before mainO") 
vector<inl>· f(int J() 
{ 
static veclor<inl> vs(x)j 
vector<inl> vf(J(H) j 
/I constructed in first call of fO only 
/I constructed in each ca II of fO 
1047 

'048 
for (int i=l; i<10; ++i) { 
vector<int> "I(i); 
/I . .. 
AP PEN DIX A • LANGUAGE SUMMARY 
/I constructed in each iteration 
} 
/1 v1 destroyed here (in each iteration) 
return new vector<int>(vO; 
II constructed on frcc store as a copy of vf 
} II vf destroyed here 
void ffO 
{ 
) 
vector<inp· I> = f(10); 
/I ... 
delete p; 
/I get vector from fO 
1/ delete the vector from f 
111C slillica.lIy allocated variables vg and vs are dcstroyed at program tennination 
("after mainO
n), provided they have been constructed. 
Class members are nm allocated as such. When you allocate an object some-
where, lhc non-static members arc placed there also (with the same storage class 
as the class object to which they belong). 
Code is stored separately from dam. For example, a member function is 110/ 
stored in each object of itS class; one copy is slOred with the rest of the code for 
the program. 
Sec also §14.3 and §17.4. 
A.4.3 lifetime 
Before an object can be Oegally) used, it must be initialized. This initialization can 
be explicit using an initializer or implicit using a constructor or a rule for default 
initialization of built-in types. The lifetime of an object ends at a point determined 
by its scope and storage class (e.g., sec §17.4 and §B.4.2): 
Lowl (alltomatic) objects are constructed if/when the thread of execution 
geLS lo them and destroyed at end of scope. 
Temporary oI!;ects are created by a specific sub-expression and destroyed at 
the end of their full expression. A full expression is an expression that is 
not a sub-expression of some other expression . 
.N(wICspau objeds and stalic class mcmbm arc constructed at the start of the pro-
gram ("before mainO") and destroyed at the end of the progrnlll ("after 
mainO"). 
Lo«d sialic objects arc constructed if/when the thread of execution gelS to 
them and (if constructed) destroyed at lhe end of the program. 
m e-store objects arc constructed by new and optionally destroyed using 
delete. 

A.S 
EXPRESSIONS 
A temporary variable bound to a reference "lives'" as long as the reference. For 
example: 
const char· slrins-Ibl[J = { "Mozart", "Crieg", "Haydn", "Chopin" }; 
const char· f(inl i) ( return strins-tbl[i); ) 
void g(string s){} 
void hO 
( 
canst slring& r = r(O); 
g{I{' »; 
string s = [(2); 
coul « "r(3): " «[(3) 
«"s: "«
s 
II bind temporary string to r 
/I make a temporary string and pass it 
/I initialize s from temporary string 
/I make a temporary string and pass it 
«" r: "« r«
'\n'; 
111e result is 
r(3): Chopin s: Haydn r : Mozart 
111e string temporaries generated for the calls [(1), [(2), and [(3) are destroyed at 
the end of the expression in which they were created. However, the temporary 
generated for 1(0) is bound to r and "lives" untillhe end of hO. 
A.S Expressions 
This section summarizes C++'s operators. We usc abbreviations that we find 
mnemonic, such as m for a member name, T for a type name, p for an expression 
yielding a pointer, " for expression, v for an lvalue expression, and lSi for an ar-
gument list. TIle result type of the arithmetic operations is detennined by "the 
usual arithmetic conversions" (§A.5.2.2). The descriptions in this section arc of 
the buill-in operators, not of any operator you might define on your own, though 
when you define your own operators, you are encouraged to follow the semantic 
rules described for built-in operations (§9.6). 
Scope resolulion 
N :: m 
:: m 
m is in the namespace N; N is the name of a namespace or a class. 
m is in the global namespace. 
Note that members can themselves nest, so that you can gel N: :C: :m; see also 
§8.7. 
'04' 

10SO 
Poslfix expressions 
, . m 
p-> rn 
pix) 
f(lst) 
l(ls!) ... .--
typeid(x) 
typeidm 
dynamic_casl<T>(x) 
static_casl<T>(x) 
consCcast<T>(x) 
reinterpreC cast<T>(x) 
APPENDIX A • LANGUAGE SUMMARY 
member access; x must be a class object 
member access; p must point to a class object; e<luivalent to (·p).m 
subscripting; equivalent to - (pH) 
funClion call: call f with the argument list 151 
constructioo: construct a T with the argument list 1st 
(post) increment; the value of v++ is the value of v before incrementing 
(pasO decrement; the value of \1-- is Ihe value of \I before decrementing 
run-lime Iype identification for x 
run-time type identification for T 
run-time checked conversion of x to T 
compile-time checked conversion of x 10 T 
unchecked conversion to add or remove const from x's type to get T 
unchecked conver'5ion of x to T by reinterpreting the bit pattern of x 
"111C Iype id operator and its uses are not covered in this book; see an expert-level 
reference. Note that casts do not modify their argument. Instead, they produce a 
result o f their type, which somehow corresponds to the argument value; sec 
§A.5.7. 
Unary expressions 
sizeofm 
sizeof(x) 
... --. 
!, 
&. 
' p 
newT 
new T(lst) 
new(lsl) T 
the size of a T in bytes 
the size of an object of x's type in bytes 
(pre) increment; equivalent to y+=1 
(pre) decrement; equivalent to y-=1 
complement of x; - is a bitwise operation 
not x; returns true or false 
address of y 
contents of object pointed to by p 
make a T on the free store 
make a T on the free store and initialize it with Isf 
construct a T at location determined by 151 

A.S 
EXPRESSIONS 
Unary expressions (continued) 
new(lst) T(lst2) 
delete p 
deleteD p 
m, 
construct a T allocation determined by 1st and initialize it with Ist2 
free the object pointed to by p 
free the array of objects pointed to by p 
C-style cast; convert x to T 
Note lhat lhe objeet(s) pointed to by p in delete p and deJete[J p Illust be allo-
cated using new; see §A.5.6. Note that (T)x is far less specific - and therefore 
more error-prone - than the more specific cast operators; see §A.5.7. 
Member selection 
x. ·ptm 
p->·ptm 
the member of x identified by the pointer-to-member ptm 
the member of · p identified by the pointer-ta-member ptm 
Not covered in this book; see an expert-level reference. 
Multiplicative operators 
x·y 
Multiply x by y. 
xJy 
Divide x by y. 
x'Yoy 
Modulo (remainder) of x by y (not for floating-point types). 
-n ,c effect of x/y and x%y is undefined if y==O. TIle effect of x%y is im plementa-
tion defined if x or y is negative. 
Additive operators 
Hy 
Add x and y. 
x- y 
Sublrad y from x. 
Shift operators 
x<<y 
Shift x left by y bit positions. 
x»y 
Shift x right by y bit positions. 
1051 

1052 
APPENDIX A • LANGUAG E SUMMARY 
For the (built-in) use of » and « for shifting bits, see §25_5.4. Whcn their Icft-
most operators arc iostreams, these operalOrs are used for I/O; see Chaptcrs lO 
and I I. 
Relational operators 
x<y 
x less than y; returns a bool 
x<=y 
x less than or equal to y 
Dy 
X greater than y 
D=y 
X greater than or equal to y 
Thc result of a relational operator is a bool. 
Equality operators 
x==y 
x equals y; returns a bool 
x!=y 
x nol equal to y 
Note t.hat x!=y is !(x==y). The result. of an cquality operat.or is a bool. 
Bitwise and 
x&y 
bitwise and of x and y 
Note that & (like ", I, -, » , and « ) delivers a set of bits. For eXillllple, if a and b 
arc unsigned chars, a&b is an unsigned char wit.h each bit being the result of ap-
plying & to t.he corresponding bits in a and b; sec §A.5.5. 
Bitwise xor 
x"y 
bitwise exclusive or of x and y 
Bitwise or 
'Iy 
bitwise or of x and y 
Logical and 
x&&y 
logical and; returns true or false; evaluate y only if x is true 

A .S 
EX PR ESS IONS 
logical or 
'Ii, 
logical or; returns true or false; evaluate y only if x is false 
See §A.5.5. 
Conditional expression 
xly:z 
if x the result is y; otherwise the resuli is z 
For example: 
templale<class T> T& max(T& a, T& b) { return (a>b)1a:b; } 
·111e '·question mark colon opcralOr" is explained in §8.4. 
Assignments 
v"=x 
v!=x 
v%=x 
v+=x 
v-=x 
v>>=x 
v<<=x 
v&=x 
v"=x 
vj=x 
assign x to v; result is the resulting v 
roughly v=v"(x) 
roughly v=v/(x) 
roughly v=v%(x) 
roughly v=v+(x) 
roughly v=v-(x) 
roughly v=v» (x) 
roughly v=v« (x) 
roughly v=v&(x) 
roughly v=v"(x) 
roughly v=vj(x) 
By "roughly v=v*(x)" we mean that v"=x has that value c.'{ccpt that v is evaluated 
only once. For example v(++i]"=7+3 means (++i, v[i]=v[W(7+3)) rather than 
(vl++il=v[++W (7+3» (which would be undefmed; see §8.6.1 ). 
Throw expression 
throw x 
thrrnv the value of x 
111c type or II throw-expression is void. 
1053 

1054 
APPENDIX A .. LANGUAGE SUMMARY 
Comma expression 
',Y 
Execute x then y; the result is y. 
Each box holds operators with the same precedence. Operators in higher boxes 
have higher precedence than operators in lower boxes. For example, a+b"c 
means a+(b"c) rather man (a+b)"c because " has higher precedence than +. Simi-
larly, . p++ means "(p++), not (" p )++. Unary operators and assignment operators 
arc right-associative; all others arc Jeri-associative. For example, a=b=c means 
a=(b=c) and a+b+c means (a+b)+c. 
An lvalue is an expression that identifies an object that could in principle be 
modified (but obviously an IvaIuc that has a const type is protected against mod-
ification by the type system) and have its address taken. TIle complement to 
lvaluc is rvalue, that is, an expression that identifies something that may not be 
modified or have its address taken, such as a value returned from a function 
(&f(x) is an error because f(x) is an rvalue). 
A.S.l UserMdefined operators 
"111e rules defined here are for built-in types. If a tIser·defined operator is used, an 
expression is simply transfonned into a c.,11 of the appropriate user--defined opera-
tor function, and the niles for function call detennine what happens. For example: 
classMine{ / .. . . . */ )i 
bool operator==(Mine. Mine); 
void f(Mine a. Mine b) 
{ 
} 
if (a==b) { 
1/ . .. 
} 
II a==b means operator==(a,bl 
A user-defined type is a class (§A12, C hapter 9) or an enumeration (§A.ll , §9.5). 
A.S.2 Implicit type conversion 
Integral and floating-point types (§A.8) can be mixed freely in assignments and 
expressions. W herever possible, vaJues are converted so as not to lose infonna-
lion. Unfortunately, value-destroying conversions arc aJso perfOnlled implicitly. 
A.S.2.1 Promotions 
The implicit conversions that preserve values are commonly referred to as /Jroll/(}o 
lio1LJ. Before an arithmetic operation is perfonned, in/egral promo/ion is lIsed to cre-

A. 5 
EXPRESSIONS 
ate ints out or shorter integer types. This reflects the original purpose or these 
promotions: to bring operands to the "natural" size ror arithmetic operations. In 
addition, float to double is considered a promotion. 
Promotions arc used as part or the usual arithmetic conversions (see 
§A.5.2.2). 
A.S.2.2 Conversio ns 
TIle rundamental types can be converted into each other in a bewildering num-
ber of ways. 'When writing code, you should always aim to avoid undefined be-
havior and conversions that quietly throwaway information (see §3.g and 
§25.5.3). A compiler can wam about many questionable conversions. 
Integral amverJi01u: An integer can be converted to another integer type. 
An enumeration value can be converted to an integer type. H thc desti-
nation type is unsigned, the resulting value is simply as many biLS from 
the source as will fit in the destination (high-order bits are thrown away if 
necessary)_ If the destination type is signed, the value is unchanged if it 
can be represented in the destination type; otherwise, the value is imple-
mentation defmed. NOte that bool and char are integer types. 
Floating-jxJi1lt ((J1IfJ(1"Ji(J1u: A floating-point value can be converted to an-
other floating-point type. If the source value can be exacuy represented 
in the destination type, the result is the original numeric value. H the 
source value is between two adjacent destination values, the result is one 
of those values. Otherwise, the behavior is undefined. Note that float to 
double is considered a promotion. 
fbilltu and rifuttla amVt:rJi01u: Any pointer to an object type can be implic· 
itly converted to a void- (§17.8, §27.3.5). A pointer (reference) to a de-
rived class can be implicitly converted to a pointer (reference) to an 
accessible and unambiguous base (§14.3). A constant expression (§A.5, 
§4.3. 1) that evaluates to 0 can be implicitly converted to any pointer 
type. A P can be implicitly converted to a canst P . Similarly, a T& can 
be implicitly converted to a const T&. 
Bookan C01IIJt'f"SiJms: Pointers, integrals, and floating·point values can be im-
plicitly converted to bool. A nonzero value converts to true; a zero value 
converts to false. 
Rooting-integral amVt:rJiom: When a floating-point value is converted to an 
integer value, the fractional part is discarded. In other words, conversion 
from a floating-point type to an integer type truncates. The behavior is 
undefined if the truncated value cannot be represented in the destination 
type. Conversions from integer to floating types are as mathematically 
correct as the hardware allows. Loss of precision occurs if an integral 
value cannot be represented exactly as a value of the floating type. 
lOSS 

1056 
APPEND IX A • LANG U AGE SU MMARY 
Usual arithmetic aJllutrsiom: These conversions are performed on lhe 
operands of a binary operator to bring them to a common type, which is 
then used as the type of the result: 
1. If either operand is of type long double, the other is conven ed to 
long double. Otherwise, if either operand is double, lhe other is 
converted to double. Otherwise, if either operand is float, lhe other 
is converted to float. Otherwise, integral promotions arc perfonncd 
on both operands. 
2. Then, if either operand is unsigned long, the other is converted to 
unsigned long. Otherwise, if Olle operand is a long inl and lhe olher 
is an unsigned int, then if a long int can I'cprCSCill all the values of 
an unsigned int, the unsigned int is converted to a long int; other-
wise, both operands arc converted to unsigned long int. Otherwise, 
if either operand is long, the Olher is converted to long. O therwise, 
if either operand is unsigned, the other is conven ed to unsigned. 
Omen vise, both operands are int. 
Obviollsly, it is best not to rely too much on complicated mixtures of types, so as 
to minimize me need for implicit conversions. 
A.S.2.3 User-defined conversions 
In addition to the standard promOlions and conversions, a programmer can de-
fine conversions for user-defined types. A constnlCtor that takes a single argu-
ment defines a conversion from its argument type to its type. If the constmctor is 
explicil (sec §18.3.1), the conversion happens only when me programmer explic-
itly requires the conversion. Othcn vise, the conversion can be implicit. 
A.S.3 Constant expressions 
A a)TIslalll ~xpmsi()n is an expression that can be evaluated at compile time and in-
volves only int operands. r111at's a slight simplification, but good enough for 
mOst purposes.) For example: 
canst int a = 2·3; 
consl int b = a+3; 
Constant expressions are required in a few places, such as array bounds, case la-
bels, enumerator initializers, and int template arguments. For example: 
int var = 7; 

A.S 
EX PRESSIONS 
switch (x) ( 
case n : 
case 41+2: 
case var: 
1/ . .. 
} ; 
A.S.4 sizeof 
/10K 
/10K 
II error (var is not a conSlant expression) 
In sizeof(x), x can be a type or an expression. If x is an expression, the value of 
sizeof(x) is me size of me resulting object. If x is a type, sizeof(x) is lhe size of an 
object of type x. Sizes arc measured in bytes. By dermilion, sizeof(char)==1. 
A.S.S logical expressions 
c++ provides logical operators for integer types: 
Bitwise logical operations 
x&y 
bilwise and of x and y 
xly 
bitwise or of x and y 
xJ\y 
bit· .... ise exclusive or of x and y 
Logical operations 
x&&y 
logical and; returns true Of false; evaluate y only jf x is true 
xlly 
logical or; returns true or false; evaluate y only if x is false 
TIle bitwise operators do their operation on each bit of their operands, whcreas 
the logical operators (&& and II) treat a 0 as the value false and anything clse as 
the value true. TIle definitions of the operations are: 
& 
o 
1 
o 
o 
o 
1 
o 
A.5.6 new and delete 
o 
1 
o 
o 
1 
o 
1 
o 
1 
o 
o 
Memory on the free store (dynamic store, heap) is allocated using new and de-
allocated ("freed") using delete (for individual objects) or deleteO (for an array). 
1057 

1058 
APPENDIX A • LANG UAGE SU MMAR Y 
If memory is exhausted, new lhrows a bad_alloc exception. A successful new op-
eration allocmes at least 1 byte and rctums a pointer to the allocated object. The 
type of object allocated is specified after new. For example: 
inl- pl = new inti 
inl- p2 = new int(7); 
int- p3 = new int[l00]i 
II ... 
1/ allocate an (uninitialized) int 
/I allocate an inl initialized to 7 
/I allocate 100 (uninilialized) ints 
delete p1; 
delete p2; 
deletell p3; 
II deallocate individual object 
/I deallocate array 
If you allocate objectS of it built-in type using new, they will not be initialized un-
less you specify an initializcr. If you allocate objects of a class with a constructor 
using new, a constructor is called; the default constIlictor is called unless you 
specify an initializer (§17.4.4). 
A delete invokes the destruclOr, if a.ny, for its operand. Note that a destructor 
may be virNa! (§A.12.3.1). 
A.S.7 Casts 
lnere arc rour type·conversion operators: 
Type-conversion operators 
x=dynamic_cast<O*>(p) 
x=dynamic_cast<O&>(*p) 
x=slal ic_caSI<T>(y) 
x=reinterpreCcast<T>(v) 
x=consCcasl<T>(v) 
x=(1)y 
K=T(y) 
Try to convert v into a 0* (may return 0). 
Try to convert *p into a 0& (may throw bad_cast). 
Convert v into a T if a T can be converted into v'5 type. 
Convert v into a T represented by the same bit pattern. 
Convert v into a T by adding or subtracting consl. 
C-style cast: do any old cast. 
Functional cast: do any old cast 
TIle dynamic caSt is typically used ror class hierarchy navigation where p is a 
pointer 10 a base class and 0 is derived rrom that base. It returns 0 ir v is not a 
d° . Ir yOli want dynamic_cast to throw an exception (bad_cast) instead or return· 
ing 0, cast to a rererence instead or to a pointer. TIle d ynamic cast is the only cast 
that relies on run·time checking. 
Static cast is used ror "reasonably well·behaved conversions," that is, where v 
could have been the result or an implicit conversion rrom a T; see § 17.8. 

A.6 
STATEM ENTS 
Rcinterpret cast is used for reinterpreting a bit patlcrn. h is not guaranteed to 
be portable. In fact, it is best to assume that every use of reinlerpreCcasl is non-
portable. A typical example is an int-w-pointer conversion to get a machine ad-
dress into a prOhYTam; see §17.8 and §25.4. 1. 
The C-slyle and functional casts can perform any conversion that can be 
achieved by a slatic_cast or a reinterpreCcast, combined with a canst_cast. 
Casts are best avoided. In most cases, consider their use a sign of poor pro-
gramming. Exceptions to this rule are presented in §17.8 and §25.4. 1. 111e C-
style cast and function-style casts have the nasty property that you don't have to 
understand exactly what the cast is doing (§27.3.4). Prefer the named casts when 
you cannot avoid an explicit type conversion. 
A.6 Statements 
Here is a grammar for C++'s statementS (~ m eans "optional"): 
statelllent: 
declaratioll 
{ statement-lis/opt } 
try { statnru:nl-list .. } lumcller-lisl 
~xp,.r:ss;Ol/ .. ; 
selectioll-statement 
;terahon-slatelllt 1lt 
(abele,J-S/(liemtllt 
conirol-slaklll£nl 
sele(tion-slatemenl: 
if ( (Oluli/;o1l ) statemrol 
if ( (Ofulilion ) slalemenl else slatemenl 
switch ( (o1ldi/;oll ) Jlale7l/e1/t 
;Ieral;oll-slalemm/: 
while ( conditiOi/ ) slale-l1Iml 
do slal("1T1C711 while ( exjJrt:ssioll ) ; 
for (jOr-;nil-slaIt7/1e111 (OIUJition .. ; exjm:JJiOl/.,. ) slulnllc,I 
ltlbclelJ-S/(IIe!lIn,/: 
case coIIJ/IlIlI-exPrt:ssioll : sla/emml 
default : J/Il/ell/eul 
identifier : Jla/aTlC7II 
1059 

1060 
control-statement: 
break ; 
continue; 
return expreJSiQ11~ i 
gOlo idclltjfier i 
stale-l1Im/-/ul: 
slatement Jlaletn£1II-!ul<l>l 
rondihfJ1/: 
(xprcJSioll 
APPENDIX A • LANG UAGE SU MMA RY 
l;ype-speajier dec/arolor = rxpmsi()1l 
j{Jl'-inil-s/a/emt'll/: 
expression ; 
iype-sp;;;" declarator = o:jJmJi01l ; 
Iull/dleT-lisl: 
catch ( a«plion-licculraholl ) { sta/e7lle1/t-{ist~ } 
h"'l(lkr-fiJlllillUlIt:r-li.s/~ 
Note that a declaration is a statement and that there is no assignment statement 
or procedure call statement; assignments and function calls arc expressions. 
More infommtion: 
Iteration (for and while); sec §4.4.2. 
Selection (if, switch, case, and break); see §4.4.1. A break "breaks out of" 
the nearest enclosing switch-statement, while-statement, do-statement, or 
for-statement; that is, the next statement executed will be the statement 
rollowing t.hat enclosing statement. 
Expressions; see §A.5, §4.3. 
Declarations; see §A.6, §B.2. 
Exccptions (try and catch); see §5.6, § 19.4. 
Here is an example concocted simply to demonstrate a variety or statements 
(what docs it do?): 
int- f(int p(J, int n) 
( 
if (p==O) throw Bad_p(n); 
vector<inl> Vi 
inl x; 

A.7 
D ECl ARATI O N S 
) 
while (cin»x) ( 
) 
if (x==te rminator) break; 
/I exit whi le loop 
v.push_back(xl; 
for (int i = 0; i<v.size() && i<ni H i) ( 
if (v(i]=="p) 
return Pi 
else 
++p; 
) 
return 0; 
A.7 Declarations 
A dularahon consists of three pans: 
11Ie name of the entity being declared 
"n le type of the entity being declared 
The initiaJ value of the entity being declared (optional in most cases) 
We c.1n declare 
Objects of built· in types and uscr·dertncd types (§A.8) 
User-dertned types (classes and enumerations) (§A.lO-ll, Chapter 9) 
l cmplates (class templates and function templates) (§A. 13) 
AI;a"" (§A. I 6) 
Namespaces (§A.15, §B.7) 
Functions (including member functions and operators) (§A.9. Chapter 8) 
Enumerators (values for enumerations) (§A.II, §9.5) 
Maceo, (§A.I7.2, §27.8) 
A.7.1 Definitions 
A declaration that initializes, sets aside memory, or in other ways provides all the in-
fommtion necessary for using a name in a program is called a tkfinitiml. Each type, 
object, and function in a program must have exactly one defin.ition. Examples: 
double to; 
/I a declaration 
double fO {'" ... "' }; 
/I (also) a definition 
1061 

1062 
APPENDIX A • LAN GUAG E SU MMARY 
extern consl int Xi 
int y; 
/I a declaration 
/I (also) a definition 
int I = 10; 
/I a definition with an explicit initializer 
A const must be initialized. lllis is achieved by requiring an initializer for a consl 
unless it has an explicit extern in ilS declaration (so that the initializer must be on 
its definition elsewhere) or it is of a type with a default constructor (§A.12.3). 
Class members that are consts must be initialized in every constructor using a 
member initializer (§A.1 2.3). 
A.8 Built-in types 
c++ has a host of fundamental types and types constructed from [undamental 
types using modifiers: 
Built-in types 
bool x 
char )( 
short x 
int x 
float x 
double x 
void" P 
T"p 
T ·consl p 
T alnJ 
T& , 
T f(arguments) 
consl T x 
long T x 
unsignedTx 
signed T x 
x is a Boolean (values true and false). 
x is a character (usually 8 bits). 
x is a short int (usually 16 bits). 
x is the default integer type. 
x is a floating-point number (a ~short doub l e~)_ 
x is a r double-precision") floating-point number. 
p is a pointer 10 raw memory (memory of unknown type). 
p is a pointer 10 T. 
P is a constant (immutable) pointer to T. 
a is an array of n Ts. 
, is a reference to T. 
f is a fundion taking arguments and returning a T. 
x is a constant (immutable) version of T. 
x is a 10ngT. 
x is an unsigned T. 
x is a signed T. 
Here, T indicates "some type," so you can have a long unsigned int, a long 
double, an unsigned char, and a canst char· (pointer to constant char). However, 
this system is not perfectly general; for example, there is no short double (that 
would have been a float), no signed bool (that would have been memullgless), no 

A.B 
BUILT· IN TYPES 
shorllong inl (that would havc been redundalll), and no long long long long inl. 
Some compilers anticipate the C++Ox standard and accept long long inl (read that 
as "very long intcger"). A long long is guaranteed to hold at least 64 bits. 
"nlC jloaling-poilll typeJ are floal, double, and long double. They arc C++'s 
approximation of real numbers. 
"nlC illleg" IJpeJ (sometimes called intel:,'ral tyjKs) are baal, char, shari, inl, 
long, and (in C++Ox) long long and thcir unsigned variams. Note that an enu-
meration type or valuc can often be used where an integer type or value is 
needed. 
In.e sizes of built· in types arc discussed in §3.B, §17.3.1, and §25.5.1. Pointers 
and arrays arc discussed in Chapters 17 and lB. References arc discussed in 
§8.5.4- 6. 
A.S.l Pointers 
A pointer is an address of an object or a function. Pointers arc stored in variables 
of pointer types. A valid object pointer holds the address of an object: 
inl x = 7; 
inl· pi = &x; 
inl xx = ·pi; 
1/ pi points to x 
1/ 'pi is the value of the object pointed to by pi, that is, 7 
An invalid pointer is a pointer that docs not hold me value of an object: 
in'· pi2; 
·pi2=7; 
pi2 = 0; 
·pi2=7; 
1/ uninitialized 
1/ undefined behavior 
1/ the nu ll pointer (pi2 is still invalid) 
1/ undefined behavior 
pi2 = new inlm ; 
1/ now pi2 is valid 
inl xu = ·pi2; 
1/ fine: xxx becomes 7 
We try to have invalid pointers hold the null pointer (0), so that we can test it: 
if (p2 == 0) ( 
I/Nifinvalid~ 
1/ don't use ·p2 
Or simply 
if (p2) ( 
II Nif valid" 
1/ use ' p2 
1063 

1064 
APPENDIX A • LANGUAGE SUMMARY 
Sec §17.4 and §18.5.4. 
111C operations on a (non-void) object poil1lcr are: 
Pointer operations 
'. 
dereferenccli ndi rectioo 
p [ij 
derefercnceJsubscri pi i ng 
p=q 
assignment and initialization 
.==q 
equality 
p! : q 
inequality 
p+i 
add integer 
p-i 
subtract integer 
.-q 
distance: subtract pointers 
... 
pre-increment (move forward) 
... 
post-increment (move forward) 
--. 
pre-decrement (move backward) 
.--
post-decrement (move backward) 
p+=i 
move forward i elements 
p-=i 
move backward i elements 
Note that any form of pointer arithmetic (c.g., ++p and p+=7) is allowed only for 
pointers into an array and that the eITecI of dercfcfCncing a pointer poil1ling Out-
side the array is undefined (and most likely not checked by the compiler or the 
language run-lime system). 
~111C only operations on a void- pointer are copying (assignment or initializa-
tion) and casting {type conversion}. 
A pointer to function (§27.2.5) can only be copied and called. For example: 
Iypedef void (·Handle_lype)(int)i 
void my_handler(int); 
Handle_type handle = my_handler; 
handle(10); 
1/ equivalent to my_handler( 10) 
A.8.2 Arrays 
An amry is a fixed-length contiguous sequence of objects (clements) of a given type: 
int a[10]; 
1/ 10 ints 

A.8 
IW l lT- IN TYPES 
If an array is global, its clements will be initialized to the appropriate default 
value for the type. For example, the value of a[7] will be o. If the array is local (a 
vm; able declared in a function) or allocated using new, clements of built-in types 
will be uninitialized and clements of class types will be initialized as required by 
the class's constll.lctors. 
~l1l e name of an array is implicitly convened to a pointer to its first clement. 
For example: 
inl
O p =a; 
I/p points toalO) 
An array or a pointer to an clement of an array call be subscripted using the [ J 
operator. For example: 
. 17J = 9; 
inl xx = pI6]; 
Array clements arc numbered starting with 0; see §18.5. 
Arrays arc not range checked, and since they arc often passed as pointers, the 
information to range check them is not reliably available to users. Prefer vector. 
~11 1e size of an array is the sum of the sizes of its elements. For example: 
inl a(max]i 
II sizeo((a)==sizeof(a [OI)Omax:::::sizeof(int)*max 
You can define mld lise an array of an array (a two-dimensional array), an array 
of an aITay of an array, etc. (multidimensional arrays). For example: 
double da[l00J[200)(300); 
1/300 clements of type 
1/200 elements of type 
1/ , 00 type double 
da[7][9J[11] = 0; 
Nomrivial uses of multidimensional arrays arc subtle and en·or-prone; see §24.4. 
If you have a choice, prtfer a Matrix library (such as the one in Chapter 24). 
A.S.3 References 
A /"Ift:rena is an alias (alternative name) for an object: 
inta= 7; 
int&r= ai 
r = 8; 
1/ a becomes 8 
References arc most common as function parameters, where they are lIsed to 
avoid copying: 
1065 

1066 
void f(consl string& S)i 
II ... 
APPEND IX A • LANGUAGE SUMMARY 
{("this string could be somewhat costly 10 copy, so we use a reference"); 
Sec §8.5.4-6. 
A.9 Functions 
A jimelioT! is a named piece of code taking a (possibly empty) set of arguments and 
optionally returning a value. A function is declared by giving the return type fol-
lowed by its name followed by the parameter list: 
char Hstring, inl); 
So, f is a fu nction taking a string and an int returning a char. If the function is just 
being declared, the declaration is terminated by a semicolon. If the function is 
being defined, the argument declaration is followed by the function body: 
char f(slring 5, inl i) ( return s[i); } 
TIle function body must be a block (§B.2) or a try-block (§5.6.3). 
A function declared to return a value must return a value (using the relurn-
statement) : 
char f(siring s, int i) { char c = s[i]; } 
1/ error: no value returned 
The mainO function is the odd exception to that rule (§A.1.2). Except for mainO, 
if you don't want to return a value, declare the function void; that is, use void as 
the "return type": 
void incremenl(inl& xl ( ++x; ) 
1/ OK: no return value required 
A fUllction is called using the call operator (application operator), (), with an ac· 
ceptable list of arguments: 
char xl = f(1,2); 
II error: fO's first argument must be a string 
siring s = "Bailie of Haslings"; 
char x2 = f(s); 
1/ error: fO requires two arguments 
char xl = f(s,2); 
1/ OK 
For more infonnation about functiolls, see C hapter 8. 

A.9 
f UN CTIO N S 
A.9.1 Overload resolution 
0ua(()(U1 resolulion is the process of choosing a function to call bascd on a set of ar-
guments. }<o r cxample: 
void prinl(inl); 
void prinl(double); 
void prinl(consl sid : :slring&); 
prinl(l23); 
print(1.23); 
print("123"); 
/I use print{int) 
/I use print(double) 
/I use print(const siring&) 
It is the compiler's job to pick the right function according to the language n iles. 
Unfortunately, in order to cope with complicated examples, the language lules 
arc quite complicated. Here we present a simplified version. 
Finding the right version to call from a set of overloaded funcLions is done by 
look.ing for a best match between the type of the argument expressions ruld the 
parameters (formal arguments) of the functions. To approximate our notions of 
what is reasonable, a series of criteria is tried in order: 
I. Exact match, that is, match using no or only trivial conversions (for ex-
ample, array name to pointer, function name to pointer to function, and 
T to canst T) 
2. Match using promotions, that is, integral promotions (bool to inl, char 
to inl, shorl to int, and their unsigned counterparts; see §A.8) and float 
to double 
3. Match using standard conversions, for example, int to double, double to 
int, double to long double, Derived· to Base (§ 14.3), T* to void· (§17.8), 
int to unsigned int (§25.5.3) 
4. Match using user-defined conversions (§A.5.2.3) 
5. Match using the ellipsis ... in a function declaration (§A.9.3) 
If two matches arc found at the highest level where a match is found, the call is 
rejected as ambiguous. The resolution rules are this elaborate primarily to take 
into account the elaborate rules for built·in numeric types (§A.5.3). 
For overload resolution based on multiple arguments, we first find the best 
match for each argument. If one function is at least as good a match as all other 
functions for every argument and is a better match than all other functions for 
one argument, that function is chosen; otherwise the call is ambiguous. }<or 
example: 
1067 

1068 
APPENDIX A • LAN G UAGE SU MMARY 
void f(int, const string&, do uble); 
void {(int, const char*, intI; 
f(1, "hello", l )i 
f(1 ,string("he llo"), 1.0); 
f(1, "hello ", 1.0); 
II OK: call {(jnt, consl char', int) 
II OK: caU mnl, consl string&, double) 
II error: ambiguous 
In the last call, the "hello" matches const char- without a conversion and consl 
string& only with a conversion. On the other hand, 1.0 matches double without 
a conversion, but int only with a conversion, so neilher fO is a bener match limn 
the olher. 
If these simplified rules don't agree with what your compiler says and what 
you thought reasonable, please first consider if your code is more complicated 
than necessary. If so, simplify your code; if nOl, consult an expert-level reference. 
A.9.2 Default arguments 
A general function sometimes needs more arguments than arc needed for the most 
common cases. To handle mat, a programmer may provide default arguments to 
be used if a caller of a function doesn't specify an argumclll. For cxmnplc: 
void f(int, inl=O, int=O); 
((1,2,J ); 
f(1,2); 
f(l ); 
/I calls f(1 ,2,0) 
/I calls ((1 ,0,0) 
Only trailing arguments call be defaulted and left Ollt in a call. For example: 
void g(int, int =7, int); 
f(1,,1); 
1/ error: default for non-trailing argument 
/I error: S(.'Cond argument missing 
O verloading can be an altcmativc to using default arguments (and vice versa). 
A.9.3 Unspecified arguments 
It is possible to specify a function without specifying t.he number or types of its 
arguments. ~nllS is indicated by an ellipsis ( ... ), meaning "and possibly more ar-
guments," For example, here is the declaration or and some calls lO whm is ar-
guably the most ramous C function, printfO (§27.6.1, §B. IO.2): 
void prinlf(const char' format ... ); II lakes a formal SIring tlnd maybe more 
inl x = 'x'; 
prinlf("he llo , wo rld! "); 

A. 1 0 
USE R-D EFINED TYPES 
J>rintH"J>rinl a char '%c'\o" ,x); 
J>rintf("print a siring \"%s\"" ,x); 
II print the int x as a char 
/I shoot yourself in the foot 
"111C "fomlat specifiers" in the fonnat string, such as %c and %s, detennine if and 
how fu nher arguments arc used. As demonstrated, this Ct1.n lead to nasty type er-
rors. In C++, unspecified arguments arc best avoided. 
A.9.4 linkage specifications 
C++ code is often used in the same program as C code; that is, pans of a pro-
gram arc written in C++ (and compiled by a C++ compiler) and other parts in 
C (and compiled by a C compiler). To case that, C++ a lTers linkage specifiwliQlIJ 
for the progranuner to say that a fu nction obeys C linkage conventions. A C link-
age specification can be placed in front of a function declaration: 
Alternatively it can apply to all dedaraLions in a block: 
extern "C" { 
void callable_from_C(inl); 
int and_this_one_also(double, int-); 
r ... -/ 
For details of usc, sec §27.2.3. 
C doesn't alTer function overloading, so you can put a C linkage specifica-
tion on at most one version of a C++ overloaded function. 
A.l0 User-defined types 
lnere arc twO ways for a programmer to define a new (user-defined) type: as a 
class (class, slruct, or union ; sec §A.12) and as an enumeration (enum; sec §A. I1). 
A.l0.l Operator overloading 
A programmer can define the meaning of most operators to take operands of one 
or more user-defined types. It is not possible to change the standard meaning of 
an operator for built-in types or to introduce a new operator. The name of a user-
defined operator ("overloaded operator") is the operator prefixed by the key· 
word operator; for example, the name of a function defining + is operator +: 
Malrix operalor+(const Malrix&, const Matrix&); 
,.69 

1070 
APPEND IX A • LA NGUAGE SU MMARY 
For examples, see sid: :oslream (Chapters 10- 11), sid : :vector (Chapters 17- 19, 
§B.4), sld::complex (§B.9.3), and Matrix (Chapter 24). 
All but the following operators can be user-defined: 
1, 
• 
sizeof 
Iypeid 
Functions defining lhe following operators must be members of a class: 
= 
II 
() 
-> 
All other operators can be defined as member functions or as freestanding functions. 
Note that every user-defined type has = (assignment and initialization), & 
(address of), and , (comma) defined by default 
Be restrained and conventional with operator overloading. 
A.11 Enumerations 
An ellumeratiOIl defines a type with a set of named values (t:1IulIIeraJo/,,S): 
enum Color (green, yellow, red }; 
By defauh the value of the first enumerator is 0, so that green==O, and the values 
increase by one. so that yellow==l and red==2. It is also possible to explicitly de-
fine the value of an enumerator: 
enum Day { Monday=l , Tuesday, Wednesday}; 
Here, we get Monday==l , Tuesday==2, and Wednesday==3. 
NOle that enumerators arc not in the scope of their enumermion but belong 
to its enclosing scope: 
int x = green; 
/I OK 
int y = Color: :green; /I error 
Enumerators and enumeration values implicitly convert to integers, but integers 
do not implicitly convert to enumeration lypes: 
inl x = green; 
Color c = green; 
c = 2; 
c = Color(2); 
int y = C; 
II OK: implicit Color-la-in! conversion 
/10K 
// error: no implicit int-to-Color conversion 
II OK: (unchecked) cxplicit convcrsion 
1/ OK: implicit Color-ta-int conversion 

A.12 
CLASSES 
For a discussion of the uses of enumerations, see §9.5. 
A.12 Classes 
A dms is a type for which the user defines the representation of iLS objeclS and the 
operations allowed on those objecLS: 
class X ( 
public: 
/I user interface 
private : 
/I implementation 
) ; 
A variable, function, or type defined within a class declaration is called a member 
of lhe class. See Chapter 9 for class technicalities. 
A.12.1 Member access 
A public member can be accessed by users; a private member can be accessed 
only by lhe class's own members: 
class Date { 
public: 
/I. 
int nexl_dayO; 
private: 
int y, m, d; 
}; 
void Dale: :nexCdayO { return d+1 ; } 
/I OK 
void f(Date d) 
( 
int nd = d .d+1; 
1/ . . . 
II error: Date::d is private 
A strud is a class where members arc by default public: 
slrud S { 
/I members (public unless explicitly declared private) 
}; 
1071 

10n 
APPENDIX A • LANGUAGE SUMMARY 
For morc details of member access, including a discussion of protected, see §14.3.4. 
Members of an object can be accessed through a variable or referenced using 
the . (dot) operator or through a pointer using the -> (arrow) operator: 
slruct Date { 
int d, m, y; 
int darO const { return d; } /I defined in-class 
int month() const; 
/I just declared; defined elsewhere 
int year() canst; 
II just declared; defined elsewhere 
}; 
Date Xi 
x.d = 15; 
int y = x.dayO; 
Date* p = &x; 
p->m = 7; 
/I access through variable 
/I call1hrough va riable 
int z = p->month(); 
1/ access through pointer 
/I call through pointer 
Members of a class can be referred to using the :: (scope resolution) opcramr: 
int Date: :yearO const { return Yi } 1/ out-of-class definition 
Within a member function, we can refer to other members by their unqualified 
name: 
struct Date ( 
}; 
int d, m, y; 
int dayO consl ( return d; } 
/I . 
Such unqualified names refcr to the member of the object for which the mcmber 
fUIlClion was called: 
void f(Date d1 , Date d2) 
{ 
} 
d1 .dayO; 
d2.dayO; 
/I . .. 
1/ will access dl.d 
I/will access d2.d 

A.1 2 
ClASSES 
A.12.1.1 The this pointer 
If we wam to be explicit when referring to the object for which the member func-
cion is called, we ean use the predefined poilllcr this: 
struct Date { 
intd, m,y; 
} ; 
int monthO canst { return this->m; } 
II ... 
A mcmber function declared canst (a canst member function) cannOl modify the 
value of a member of the object for which it is called: 
struCi Date { 
}; 
int d, m, Yi 
int monthO canst { ++m; } /I error: monlhO is canst 
II ... 
For more information about canst member functions, see §9.7.4. 
A.12.1.2 friends 
A function that is not a mcmber of a class can bc grallled access LO all members 
through a friend declaration. For example: 
II needs access to Matrix and Vector members: 
Vector operator-(const Matrix&, consl Veclor&); 
class Vector ( 
friend 
}; 
Vector operator-(const Matrix&, const Vector&); /I grant access 
II ... 
class Matrix { 
friend 
}; 
Veclor operator-(const Matrix&, const Veclor&)i II grant access 
II ... 
1073 

1074 
APP ENDIX A • LANGUAGE SUMMARY 
As shown, this is usually done for functions that need to access two classes, An-
Olher usc of friend is to provide an access function that should not be c.'dled 
using the member access syntax, For example: 
class Iter { 
public: 
inl distance_to(const iter& a) canst; 
friend int diHerence(const Iter& a, const Iter& b); 
II . 
) ; 
void f(lter& p, lIer& q ) 
{ 
) 
int x = p,distance_to(q); 
int y = difference(p,q); 
1/ , , , 
II invoke using member syntax 
II invoke using "mathemalical synlax" 
Note that a function dcclared friend cannot also be declarcd virtual. 
A.12.2 Class member definitions 
Class members that arc integer constants, functions, or types can be defincdlini-
tialized either ;1I-C1as.s or oul-o/-cIaJ.S: 
slruct S { 
) ; 
sialic const int c = 1; 
static consl inl c2; 
void fO { } 
void f20 ; 
struct SS { int a; }; 
slruct SS2; 
The members that were not defined in-class must be defined "elsewhere": 
constint S::c2 =7; 
void S: :f20 { } 
slruct S: :SS2 { int m; }; 

A.12 
( LASSES 
TIle static canst int members arc an odd special case. TIley just derUle symbolic 
integer constaills and do not take up memory in the object. Non·static data memo 
bers do not require separate definition, cannot be separately defined, and cannot 
have in·class initializers: 
strucl X { 
}; 
inl Xi 
int y=7; 
/I error: non·slatic data members 
/I cannot have in·elass initializers 
sialic inlz = 7i 
/I error: non·const data members 
1/ cannot have in-class initializers 
Sialic consl string ae = "7"; 
/I error: non.integrallypc 
/I cannot have in-class initializers 
static const inl oe = 7; 
/I OK: slatic canst integral type 
inl X::x = 7; /I error: non-stalic data members cannot be defined oul-of-class 
If you want to ensure initialization of non-Sialic, non·consl data members, do it 
in constJ"tlctoTS. 
Function members do not occupy space in an object: 
struct S { 
}; 
int m; 
void fO; 
Here, sizcof(S)==sizof(int). TIlat's not actually guaranteed by the standard, but it 
is true for all implementations we know of. But nOte that a class with a virtual 
function has one "hidden" member to allow virtual calls (§ 14.3.1). 
A.12.3 Construction, destruction, and copy 
You can define the meaning of i.nitialization for an object of a class by defining 
one or more amJ/rucJors. A constructor is a member function with the same name 
as ilS class and no return type: 
class Date { 
public: 
Oate(int yy, int mm, int dd) :y(yy), m(mm), d(dd) { } 
II ... 
private: 
int y,m,d; 
}; 
107S 

1076 
AP PENDIX A • LANGUAGE SUMMA RY 
Date d1(2006,11, 15); 
Date d2; 
II OK: initialization done by the constructor 
/I error: no initializers 
Date d3(11,15); 
/I error: bad initializers (three initializers required) 
Note thai data members can be initialized by using an initializer list in the con-
structor (a base and member initializer list). Members will be initialized in the 
order in which they arc declared in the class. 
Constructors are typically used to establish a class's invanalll and to acquire 
resources (§9.<k2-3). 
Class objects arc constructed "from the bottom up," slarting with base class 
objects (§14-.3.1) in declaration order, followed by members in declaration order, 
followed by the code in the constructor itself. Unless the programmer docs some-
thing really strange, this ensures that every object is constructed before use. 
Unless declared explicit. a single-argument constructor defines an implicit 
conversion from its argument type to its class: 
class Date ( 
public: 
Date(string); 
explicit Date(long); 
/I use an integer encoding of date 
II ... 
) ; 
void f(Date); 
Date dl = "June 5, 1848"; 
/I OK 
f("June 5, 1848"); 
II OK 
Date d2 = 2007-12-31+6-31+5; 
f(2007-12-31+6-31 +5); 
Date d3(2007-12-31+6"31+5); 
II error: Date(longJ is explicit 
II error: Date(long) is expl icit 
Date d4 = Date(2007° 12°31 +6°31+5); 
f(Date(2007 °12" 31 +6 ° 31 +5» ; 
II OK 
/10K 
/10K 
Unless a class has bases or members that require c."'plieit argumentS, and unless the 
class has other constructors, a default conSlnictor is automatically generated. ~nl is 
default constructor initializes each base or member that has a default constructor 
(leaving members without default constructors uninitializcd). For example: 
struct 5 ( 
) ; 
string name, address; 
int X; 

A. 12 
CLASS ES 
TIlis S has an implicit constructor SO iliat initializes name and address, but not x. 
A.12.3.1 Destructors 
YOll can define the meaning of an object being destroyed (e.g., going out of scope) 
by defining a lieS/nic/or. TIle name of a destructor is - (the complement operator) 
followed by the class name: 
class Vector ( 1/ vector of doubles 
public: 
explicit Vector(int s) : sz(s), p(new double(s}) () /I constructor 
- VeelorO ( deletel) Pi } 
/I destructor 
// ... 
private: 
); 
inl SZi 
double* Pi 
void «int ss) 
( 
Vector V(S)i 
II . 
) 1/ v will be destroyed upon exit from fO; Vector's dL'SlruClor will be called for v 
DcsU1.1ctOrS that invoke the destructors of members of a class can be generated by 
the compiler, and if a class is to be used as a base class, it usually needs a virtual 
destructor; see §17.5.2. 
A destructor is typically used to "'clean lip" and release resources. 
Class objects are destructed "from the LOp down" starling with the code in 
the destructor itself, followed by members in declaration order, foUm ... ·ed by the 
base class objects in declaration order, that is, in reverse order of construction 
(§A.12.3.1). 
A.12.3.2 Copying 
You can dcfme the meaning of copying an object of a class: 
class Vector ( 1/ vector of doubles 
public: 
explicit Vector(int s) : sz(s), p(new doublels» { } 
- VectorO {deletell Pi } 
Vector(const Vector&)i 
Vector& operator-(eonst Vector&)i 
// ... 
1/ constructor 
1/ destructor 
/I copy constructor 
/1 copy assignment 
lOn 

1078 
private: 
); 
in! S1:; 
double- Pi 
void f(i nt 5S) 
( 
Vector V(5); 
AP PENDIX A • LANG UAGE SUMMA RY 
Vector v2 = Vi 
II use copy constructor 
/I . .. 
v = v2 , 
/I. 
/I use copy assignment 
By default (that is, unless you define a copy constmcLOr and a copy assignment), 
the compiler will generate copy operations for you. The default meaning of copy 
is mcmbcrwisc copy; sec also §14.2.4 and § 18.2. 
A.12.4 Derived classes 
A class can be defined as derived from Olher classes, in which case it inherits the 
members or the classes from which it is derived (its base classes): 
struct B ( 
int mb; 
void fbO { }; 
); 
class 0 : B { 
inl mdi 
void fdO; 
); 
Here 8 has twO members, mb and fbO, whereas 0 has four members, mb, fbO, 
md, and fdO . 
Like members, bases can be public or private: 
Class DO : public 81 , private 82 { 
/I . .. 
); 
So, me public members or 81 become public members or 00, whereas the public 
members or 82 become private members or ~O . A derived class has no special ac· 

A. 12 
CLASSES 
cess to members of its bases, so 00 docs not have access to the private members 
of 81 or 82. 
A class with more than one direct base class (such as 00) is said to usc mulli-
pie illlu:riltlllcc. 
A pointer to a derived class, 0 , can be im pliciuy converted to a pointer to its 
base class, 8 , provided 8 is accessible and is unambiguous in o. For example: 
slrucl 8 {}; 
strucl 81 : 8 (); 
slrucl 82: 8 ( ); 
slrucl C ( }; 
II B is a public base of B I 
II B is a public base of B2 
slrucl 00 : 81 , 82, private C {}; 
00· p = new 00; 
81 · pb1 = p; /10K 
8· pb = Pi 
/I error: ambiguous: 81 ::8 or B2 ::8 
C· pc = p; 
/I error: DO::C is private 
Similarly, a reference to a derived class can be implicitly converted to an unam-
biguous and accessible base class. 
"'Or more information about derived classes, sec §14.3. For more infomlatio n 
about protecled, sec an expert-level textbook or reference. 
A.12.4.1 Virtual functions 
A virilia/fimction is a member function that defines a calling interface to functions 
of the same name taking the same argument types in derived classes. When call· 
ing a virtual function, the function invoked by ule call will be ule one defined for 
ule most derived class. The derived class is said to override the virtual function 
in the base class. 
class Shape { 
public: 
virtual void drawO; 
/I "vinual" means "can be overridden" 
virtual .... ShapeO { } 
/I virtual destructor 
II .. 
); 
class Circle : public Shape ( 
public: 
); 
void drawO; 
.... Circie()i 
II .. 
/I override Shape::draw 
/I override Shape::-Shapc() 
1079 

'080 
APPENDIX A • LANG UAGE SUMMA RY 
Basically, the virtual functions of a base class (here, Shape) define a calling inter-
face for the derived class (here, Circle): 
void f(S hape& s) 
{ 
) 
II . . . 
s.draw(); 
void gO 
{ 
Circle c(Po int(O,O). 4); 
fCc); 
II wi ll call Circle's draw 
) 
Note that fO doesn't know about Circles, only about Shapes. An object of a class 
with a virtual fUllCtion contains olle extra pointer to allow it to find the set of 
overriding functions; sec §14.3. 
Note thai a class with virtual functions usually needs a virtual destmctor (as 
Shape has); sec §17.5.2. 
A.12.4.2 Abstract classes 
An ahstrad ckus is a class that can be used only as a base class. You cannot make 
an object of an abstract class: 
Shape s; 
II error: Shape is abstract 
class Circle: public Shape ( 
public: 
void drawO; /I override Shape::draw 
II . .. 
) ; 
Circle c(p,20); 
/I OK: Circle is not ,lbstract 
The most common way of making a class abstract is to define at least one pure 
virtual function. A pllrt: virtuaijmdiQ1l is a virtual function that requires overriding: 
class Shape ( 
public: 
); 
virtual void drawO = 0; 
/I . .. 
/I =0 means "pure" 

A.12 
CLASSES 
So, §14.3.5. 
'11e rarer, but equally effective, way of making a class abstract is to declare 
ail its constructors protected (§14_2.1). 
A.12.4.3 Generated operations 
When you define a class, it will by default have several operations defined for its 
objects: 
Default constructor 
Copy operations (copy assignment and copy initialization) 
Destructor 
E..1.ch is (again by default) defined LO apply recursively to each of its base classes 
and members. Construction is done "bottom-up," that is, base before members. 
Destruction is done "top-down," that is, members before bases. Members and 
bases are constructed in order of appearance and destroyed in the opposite order_ 
TIlal way, constructor and destructor code always relies on well-defined base and 
member objects_ For example: 
struct 0 : 81 , 82 { 
Ml ml ; 
M2m2; 
l; 
Assuming that 81 , 82, Ml , and M2 arc defined, we can now write 
void f() 
{ 
o d; 
/I defauh inilializalion 
o d2 = d; 
II copy inilializalion 
d = DO; 
/I default inilializalion followed by copy assignmenl 
} II d and dz are deslroyed here 
For example, the default initialization of d invokes four default constructors (in 
order): 81 :: 81 0, 82 : : 82(), Ml : :Ml 0, and M2: :M20 . If one of those doesn't exist 
or can't be called, the construction of d fails. The destruction of d invokes four 
destruCLOrs (in order): M2: :- M20 , Ml : :-Ml 0 , 82 : :-820, and 81 : :-81 0 . If one 
of those doesn't exist or can't be called, the destruction of d fails. Each of these 
constructors and destructors can be either user-defmed or generated. 
"nle implicit (compiler-generated) default constructor is not defmed (gener-
ated) if a class has a user-defmed constructor. 
1081 

'082 
APPENDIX A • LANGUAGE SUMMARY 
A.12.5 Bilfields 
A bi!fold is a mechanism for packing many small values into a word or to match 
an extcmally imposed bit-layout format (such as a device register). For example: 
slruct PPN ( 
unsigned int PFN : 22; 
inl : 3; 
1/ UI'uscd 
unsigned int CCAj 
bool nonrcacheablCj 
bool dirt y; 
bool valid; 
bool global; 
) ; 
Packing lhe bitficlds into a word left to right leads to a layout of bits in a word 
like this (sec §25.5.5): 
position: 
31 : 
,; 
" 
]; " " " 
PPN: 
In 
13 
13 
I' I' I' I' I 
name: 
.,. 
unused 
CC. 
I dirty I global 
nonreilchable valid 
A bitficld need not have a name, but ifit doesn't, you can't access it. 
Surprisingly, packing many small values into a single word docs not neces' 
sarily save space. tn fact, lIsing olle of those values often wastes space compared 
to using a char or an int LO represent even a single bit. The reason is lhat it takes 
several instmctions (which have to be stored in memory somewhere) LO extract a 
bit rrom a word and to write a single bit or a word without modirying other bits 
or a word. Don't try to lise bitficlds to save space unless you need lots or objects 
with tiny data fields. 
A.12.6 Unions 
A /llIioll is a class where aU members arc allocated starting at the same address. A 
union can hold only one element at a time, and when a member is read it must 
be the same as was last written. For example: 
union U ( 
) 
inl Xi 
double di 
U a; 
a.x = 7; 

A.1 3 
TEMPLATE S 
int xl = a.x: 
/I OK 
a.d = 7.7: 
int xl = a.x: 
/I oops 
TIle ru[c rc([uiring consistent reads and writes is not checked by the compiler. 
You have been wamed. 
A.13 Templates 
A lem/Jltlle is a class or a function paraJl1elerized by a set of types andlor integers: 
template<class T> 
class vector { 
public: 
1/ . . . 
int sizeO const: 
private: 
int sz: 
P Pi 
} ; 
template<class T> 
int veclor<T>: :sizeO const 
{ 
return sz: 
} 
In a template argument list, class means type; typename is an equivalent altema-
tive. A member function of a template class is implicitly a tcmplate function with 
thc samc template arguments as its class. 
Integer template arguments must be constant expressions: 
template<typename T, jnt sz> 
class Fixed_array { 
public: 
T a[sz]; 
/I. 
int sizeO const { return sz: }: 
}; 
Fixed_array<char,256> xl : 
int var = 226: 
Fixed_array<char,var> x2; 
/10K 
/I error: non-const template argument 
1083 

1084 
APPENDIX A • LANGUAGE SU MMARY 
A.13.1 Template arguments 
Arguments for a template class arc specified whenever its name is used: 
veclor<int> v1 ; 
vector v2; 
veclor<int,2> v3; 
vector<2> v4; 
II OK 
II error: template argument missing 
1/ error: too many template arguments 
II error: type template argument expected 
Arguments for template functions arc typically deduced from the function 
arguments: 
template<class T> 
T find (vector<l>& v, int i) 
{ 
return vii); 
) 
vector<inl> v1; 
vector<double> v2; 
II. 
int x1 = find (v1,2); 
int x2 = find (v2,2); 
/I findO's Tis inl 
II findO's T is double 
It is possible to define a template function for which it is not possible (0 deduce 
its template arguments from its function arguments. In that case we must specify 
the missing template arguments explicitly (exactly as for class templates). For 
example: 
template<class T, class U> P rnake(conSI U& u) { return new T(u)j } 
int· pi = make<int>(2)j 
Node· pn = make<Node>(make_pair("hello", 17) j 
This works if a Node can be initialized by a pair<const char· ,int> (§B.6.3). Only 
trailing template arguments can be left out of an explicit argumelll specialization 
(to be deduced). 
A.13.2 Template instantiation 
A version of a template for a specific set of template arguments is called a sjJecialiUl-
liol1. The process of generating specializations from a template and a set of argu-
ments is called template i,u/all/iahol/. Usually, the compiler generates a specialization 
from a template and a set of template arguments, but the programmer can also de-

A. 1 ) 
TEMPLATE S 
finc a specific specialization. "Illis is usually done when a gcncrallcmplate is un-
suitable for a particular sct of argumcnts. For examplc: 
template<class T> struet Compare { 
II general compare 
bool operatorO(const T& a, canst T& b) eonst 
{ 
return a<b; 
) 
) ; 
template<> strucl Compare<eonst char· > { 
/I compare C-style strings 
bool operator()(const char· a, consl char· b) consl 
{ 
return slrcmp(a,b)==O; 
) 
) ; 
Compare<inl:> e2; 
II general compare 
Compare<const char·> c; II C-style string compare 
bool b1 = c2(1,2); 
II use general compare 
bool b2 = c("asd", "dfg"); 
II use C-style sIring compare 
For functions, the rough equivalent is achieved through overloading: 
templale<class T> bool compare(const T& a, canst T& b) 
{ 
return a<b; 
) 
bool compare (const char· a, const char· b) 
II compare C·style strings 
{ 
return strcmp(a,b)==O; 
) 
bool b3 = compare(2,3); 
/I usc general compare 
bool b4 = compare("asd". "dIg"); 
/I use C-style string compare 
Separate compilation of templates (i.e., keeping declarations only in header files 
and unique definitions in .cpp files) does not work portably, so if a template 
nceds to be used in several .cpp files, put its complete defmition in a headcr fLie. 
'085 

'.86 
AP PEND IX A • LANG UAGE SUMMARY 
A.13.3 Template member types 
A template can have members that are types and members that are not types (such 
as data members and member functions). This means that in general, it can be 
hard to tell whether a member name refers to a type or to a non-type. For language-
technical reasons, the compiler has to kll0W, so occasionally we must tell it. For 
that, we usc t.he keyword Iypename. i<OT example: 
) 
lemplate<class T> strucl Vee ( 
); 
typedef T value_type; 
/I a member type 
sialic int count; 
II a data member 
II . .. 
template<dass T> void my_fcl (Vec<T>& v) 
( 
int x = Vec<T>: :count; II by default members names 
1/ arc assumed to refer to non-types 
v.count = 7; 
/I a simpler way to refer to a non.type member 
type name Vec<T>: :valuc_type xx = Xj 
1/ "Iypcnamc" is needed here 
II . 
For morc information aboullcmplatcs, sce Chaptcr 19. 
A.14 Exceptions 
An cxccption is uscd (with a throw statcmcnt) LO tcll a caJJcr about an CITor that 
cannot bc handled locally. For example, move Bad_size Out of Vector: 
struct Bad_size { 
int sz; 
Bad_size(int s) : ss(s) { } 
); 
class Vector { 
); 
Vector(int s) { if (s<O II maxsize<s) throw Bad_size(s); } 
II . .. 
Usually, we throw a type that is defined specifically to rcpresent a particular 
crror. A caBer can catch an exccption: 

A.14 
EXCEPTIONS 
void f(int x) 
{ 
try ( 
) 
Vector v(x); 
/I may throw 
/I . .. 
catch (Bad_size bs) ( 
) 
cerr« "Vector with bad size (" «bs.sz« ")\n"; 
/I . .. 
A <;catch all" clause can be used to catch every exception: 
try { 
/I . 
) catch (,',) ( /I catch all exceptions 
/I . .. 
) 
Usually, the RAJI ("Rcsource Acquisition Is Lutialization") techluque is bener (sim· 
pier, easier, mor<: reliable) than using lots of explicit Irys and catchcs; sec §19.5. 
A throw without an argument (i.e., throw;) re-throws the cun-ent exception. 
For example: 
try { 
/I. 
} catch (Some_exception& e) ( 
II do local cleanup 
throw; 
II let my caller do the rest 
) 
You can ddine your own types for usc as exceptions. "n le standard library de-
fines a few exception types that you can also usc; see §B.2.1. Never use a built-in 
type as an exception (someone else might have done that and yOllr exceptions 
might be confused with those). 
When an exception is thrown, the run-time support system for C++ 
searches "up the call stack" for a catch-clause with a type that matches the type of 
the object thrown; that is, it looks through try-statements in the function that 
threw, then through the function that called the function that threw, then through 
the function that called the function that called, etc., until it finds a match. If it 
doesn't find a match, the program temunates. In eacll function encountered in 
1087 

1088 
AP PENDIX A • LANGUAGE SUMMARY 
this search of a matching catch-clause and in each scope on the way, dcstructors 
arc called to clean up. This process is called stacie unwinding. 
An object is considered constructed once its constructor has completed and 
will then be destroyed during unwinding or any other exit from its scope. TIus 
implies that partially constructed objects (with some members or bases COIl-
structed and some not), arrays, and variables in a scope arc correctly handled. 
SubobjcClS arc destroyed if and only if they have been COllSlruclCd. 
Do nOl throw an exception so that it leaves a destructor. 111i5 implies that a 
destructor should not fail. For example: 
X: :-XO (if (in_a_reaCmess()) throw MessO;} /I never do Ihis! 
The primary reason for this Draconian advice is that if a destructor throws (and 
doesn't itself catch the exception) during unwinding, we wouldn't know which 
exception to handle. It is worthwhile to go to great lengths to avoid a destructor 
exiting by a throw because we know of no systematic way of writing correct code 
where lhat can happen. In particular, no standard library facility is guaranteed to 
work if that happens. 
A.1S Namespaces 
A lUlI1leJjJace groups related declarations together and is used to prevent name 
clashes: 
int aj 
names pace Foo { 
int a; 
void f(int i) 
( 
a+= i; 
Ill hal'S Foo's <1 (Foo::a) 
) 
) 
void f(int); 
int mainO 
( 
a = 7; 
f(2); 
Foo: :f(J); 
Ilrhat's rhe global a (::a) 
Illhar's the global f (::0 
/I that's Foo's f 

A. 16 
ALIA SES 
/I thaI's the global f (::f) 
} 
Names can be explicitly qualified by their namespace name (e.g., Foo: :f(3») or by 
:: (e.g., : :f(2»), indic.'l.ling the global scope. 
All names rrom a names pace (here, the standard library namespace, sid) can 
be made accessible by a single namcspace directive: 
using namespace sid; 
Be restrained in the lise or using directives. The notational convenience offered 
by a using directive is achieved at the cost or potential name clashes. In particu' 
lar, avoid using directives in header files. A single name rrom a namespace can be 
made available by a namespace declaration: 
using Foo: :g; 
g(2); 
I/that's Foo's g (Foo::g) 
For more infonnation about namcspaces, sec §8.l. 
A.16 Aliases 
Vi'e can define an alias ror a name; lhat is, we can define a symbolic name that 
means exactly the same as what it rerers to (for most uses of the name): 
typedef int- Pint; 
/I Pint means pointer to int 
namespace longJibrary_name { r ... -I} 
namespace lib = lons-library_name; /I Lib means long . ...Iibrary_''''lme 
int x = 7; 
int& r =x; 
/I r means x 
A reference (§8.5.5, §A.8.3) is a run·time mechanism, referring to objects. The 
typedef (§20.5, §27.3. 1) and namespace aliases arc compile-time mechanisms, re-
ferring to names_ In particular, a Iypedef docs not introduce a new type, JUSt a 
new name for a type. For example: 
typedef char- Pchar; 
Pchar p = "Idefix"; 
char· q = p; 
int x = slrlen(p)i 
/I Pchar is a name for char· 
/I OK: p is a char· 
/I OK: p and q are both char·s 
II OK: p is a char· 
'08' 

1090 
APPENDIX A • LANGUAGE SUMM ARY 
A.17 Preprocessor directives 
Every C++ implementation includes a prtproa.ssor. In principle, the preprocessor 
runs before the compiler proper and transforms the source code we wrotc into 
what the compiler sees. In reality, this action is integrated into the compiler and 
uninteresting except when it causes problems. Every line starting with # is a pre-
processor directive. 
A.17.1 #include 
We have used the preprocessor extensively to include headers. For example: 
#indude "We.h" 
This is a directive that tells the preprocessor to include the contents of file.h at 
the point of the source text where the directive occurs. For standard headers, we 
can ruso usc < ... > instead of " . . . ". For example: 
#include<vecfol'> 
11mt is lhe recommended notation for standard header inclusion. 
A.1 7.2 #define 
TIle preprocessor implements a form of character manipulation called mucro sub-
stitulio1/. For example, we can define a name for a character string: 
#define FOO bar 
Now, whenever FOO is seen, bar will be substituted: 
int FOO = 7; 
int FOOL = 9; 
Given that, the compiler will see 
int bar = 7; 
inl fOOL = 9; 
Note that the preprocessor knows enough about C++ names nOl to replace the 
FOO that's part of FOOl. 
You can also define macros that take parameters: 
#defin e MAX(x,y) «(x»(y» l (x) : (y)) 

A.17 
PREPROCE SSO R DIRECTIVES 
And we can use it like this: 
int xx = MAX(FOO+1 ,7); 
int yy = MAX(++xx,9)i 
This will expand to 
int xx = «(bar+1»( 7))?(ba r+1 ): (7)); 
int yy = «(++xx»( 9))?(++xx) : (9)); 
Note how the parentheses were necessary to get the right result for FOO+ 1. Also 
note that xx was incremented twice in a very non-obvious way. Macros are im-
mensely popular - primarily because C programmers have few alternatives La 
using them. Common header files define thousands of macros. You have been 
warned! 
If you must use macros, the convention is to name them using ALL_CAPI-
TAL_LETTERS. No ordinary name should be in all eapitallclters. Don't depend on 
others to follow this sound advice. For example, we have found a macro called 
max in an othenvise reputable header file. 
See also §27.8. 
, .. , 


'c!. r -· B 
Standard Library Summary 
"All complexities should, 
if possible, 
be buried out of sight." 
-David J. Wheeler 
T
his appendix sununarizes key C++ standard library facili-
ties. 111e summary is selective and geared to novices who 
want to gel an overview of the standard library facilities and ex-
plon~ a bit beyond the sequence of topics in the book. 
1093 

1094 
APPENDIX B • STANDARD LIBRARY SUMMARY 
B.l 
B.2 
B.3 
B.' 
Overview 
B.l .1 He~de,files 
B.l .2 N",mcspace sid 
8.1 .3 Description style 
Error handling 
B.2.1 Exceptions 
lIeralors 
B.3. 1 lIer;llor model 
B.3.2 lIerillor categories 
Containers 
B.4.1 Overview 
B.4.2 Member types 
B.4.3 Conslruclors, deslruclors, and 
assignments 
B.4.4 lIeratars 
B.4.5 Element access 
B.4.6 Slack and queue operations 
B.4.7 Ust operations 
B.4.8 Si:l:c and capacity 
8.4.9 Other operations 
8.4.10 Associative container operations 
8.5 Algorithms 
B.S.l Nonmodifying sequence 
algorithms 
B.5.2 Modifying sequence algorithms 
B.5.3 Utility algorithms 
B.S.4 Sorling and searching 
8.5.5 Sel algorithms 
B.S.6 Heaps 
B.5.7 Permutations 
B.S.8 min and maJI 
B.l Overview 
B.6 STL utilities 
B.6.1 Inserters 
B.6.2 function objects 
B.6.J pair 
B.7 I/O streams 
B.7.1 110 streams hierarchy 
B.7.2 Error handling 
B.7.J Input operations 
B.7.4 Output operations 
B.7.5 Formatting 
B.7.6 Standard manipulators 
B.8 String manipulation 
B.8.1 Character classifkation 
8.8.2 Siring 
B.8.J Regular expression matching 
B.9 Numerics 
8.9.1 Numerical limits 
B.9.2 Standard mathematkal functions 
B.9.J Complex 
B.9.4 valarray 
B.9.5 Generalized numerical algorithms 
B.10 C standard library functions 
8.10.1 files 
8.10.2 The printfO family 
8.tO.J C-style strings 
8.10.4 Memory 
8.10.S Date and time 
8.10.6 Elc. 
H.11 Other libra ries 
TIlis appendix is a reference. It is not intended to be read from beginning 10 end 
like a chapter. II (more or less) systcmatically describes key elements of tJle C++ 
standard library. h is not a complete reference, though; it is JUSt a summary with 
a few key examples. Often, you will need to look at the chapters for a more com-
plete explanation. Note also that this summary docs nOt attempt to equallhe pre-
cision and terminology of the standard. For more information, sec StrouStn lp, 
The C++ Programming umgut/gr:. TIle complete definition is the ISO C++ stan-
dard, but that document is not intended for or suitable for novices. Don't forget 
to use your online documentation. 
' Vhat usc is a selective (and therefore incomplete) summary? You can 
quickly look for a known operation or quickly scan a section to sec what com-

3.1 
OVERVIEW 
mon operations are available. You may very well have to look elsewhere for a de-
tailed explanation, bUl that's fine: now you have a due as to what to look for. 
Aiso, this summary contains cross-references to tutorial material in the chapters. 
111is appendix provides a compact overview of standard library facilities. Please 
do not try to melllOl;ze the information here; that's not what it is for. On the con-
trary, this appendix is a tool that can save you from spurious memorization. 
111is is a place to look for useful facilities - instead of trying to invent them 
yourself. Everything in the standard library (and especially everything featured 
in tills appendix) has been useful to large groups of people. A standard library fa-
cility is almost cenainly better designed, better implemented, beller documented, 
and more portable than anything you could design and implement in a hurry. So 
whell you can, prefer a standard library facility over "home brew." Doing so will 
also make your code easier for others to understand. 
If you are a sensible person, you'll find the sheer mass of facilities intimidat-
ing. Don't worry; ignore what you don't need. If you are a "details person," 
you'll find much missing. However, completeness is what the expert-level guides 
and your online documentation a fTer. In either c.1se, you'll find much that will 
seem mysterious, and possibly interesting. Explore some of it! 
B.1.1 Header files 
TIle interfaces to standard library facilities are defmed in headers. The list below 
contains a few headers that are not part of tile C++ 1998 ISO standard, but that 
will be part of the next standard and are widely available. The latter ones are 
marked "C++Ox," and their lise may require installation andlor use of a names pace 
different from std (e.g., tr1 or boost). Usc this section to gain an overview of what 
is available and to help guess where a facility might be defined and described: 
The STL (containers, iterators, and algorithms) 
<.algorilhm> 
<.array> 
<bilse!> 
<deque> 
<functional> 
<iterator> 
<list> 
<map> 
<memory> 
<queue> 
<s.1> 
algorithms; sort(), findO, etc. (§ B.S, §2 1.1J 
fixed-sized array (C++Ox) {§20.9J 
array of bool (§2S.S.2J 
double-ended queue 
function objects (§B.6.2J 
ilerators (§BA.4) 
doubly-linked list (§B.4, §20.4) 
(key, value) map and multimap (§B.4, §21.6.1 - 3) 
allocators for containers 
queue and priority_queue 
sel and multiSCI (§B.4, §21.6.5J 
1095 

1096 
APPEND IX B • STANDARD LIBRARY SUMMARY 
The STL (containers, ileralors, and algorithms) (continued ) 
<slack> 
<unordered_map> 
<unordered_set> 
<utility> 
stack 
hash maps (C++Ox) (§21.6.4) 
hash sets (C++Ox) 
operators and pair (§B.6.3) 
<vector> 
I/O streams 
<iostream> 
dstream> 
<sslream> 
<iosfwd> 
<ius> 
<streambUD 
<istream> 
<ostream> 
<iomanip> 
vector (dynamically expandable) (§B.4, §20.8) 
1/0 stream objects I§B.7) 
file streams (§S.7.11 
string streams (§ B.7. 1) 
declare (but don', define) 110 stream facilities 
I/O streams base classes 
stream buffers 
input streams I§B.7) 
output streams (§B.7) 
formatting and manipulators (§B.7.6) 
String manipulation 
<string> 
<regex> 
Numerics 
<complex> 
<random> 
<valarray> 
< numeric> 
<limits> 
string (§B.B.2) 
regular expressions (C++O)() (Chapter 23) 
complex numbers and arithmetic (§B.9.J) 
random number generation (C++Ox) 
numeric arrays 
generalized numeric algorithms, e.g., accumulateO (§B.9.5) 
numerical limits (§B.9.1) 

3. 1 
OVERVIEW 
Utility and language support 
<exception:> 
<sldexcept> 
<locale:> 
<typeinfo:> 
<new:> 
exception types (§B.2.1) 
exception hierarchy (§B.2.1) 
culture-specific formatting 
standard type information (from typeid) 
allocation and deal location functions 
C standard libraries 
<cSlring> 
C-style string manipulation (§B.l 0.3) 
<csldio:> 
C-style 1/0 (§B.l 0.2) 
<ctime:> 
clockO, time(), etc. (§B.l 0.5) 
<cmath:> 
standard floating-point math fund ions (§B.9.2) 
<cstdlib:> 
elc. functions: abortO, abs(j, malloc(), qsorl(), etc. (Chapter 27) 
<cerrno> 
C-style error handling (§24.8) 
<cassert> 
assert macro (§27.9) 
<clocale:> 
culture-specific formalling 
<climils> 
C-style numerical limits (§8.9.1) 
<dloal> 
C-style floating-point limits (§B.9.1 ) 
<cslddef> 
C language support; size_I, etc. 
<csldarg:> 
macros for variable argument processing 
<cseljmp:> 
slejmp() and longjmpO (never use those) 
<csignal:> 
signal handling 
<cwchar> 
wide characters 
<cctype> 
character type classification (§B.8.1) 
<cwctype> 
wide character type classification 
For each of the C standard librmy headers, there is also a version witholll the ini-
tial c in its name and with a trailing .h, such as <time.h> for <Clime>. 111e .h ver-
sions define global names rather than names in names pace std. 
Some - but not all - of the facilities defined in these headers are described in 
the sections below and in the chapters. If you need more information, look at 
your online documentation or an expert·level C++ book. 
'09' 

1098 
AP PENDIX B • STANDA RD LIBRARY SUMMARY 
B.1.2 Namespace sId 
The standard library facilities arc defined in namcspacc Sid, so to usc them, you 
need an explicit qualification, a using declaration, or a using directive: 
sid : :slring s; 
using sid : :veclof; 
veclor<inl>v(7); 
using namespace sid; 
map<string,double> m; 
/I explicit qualification 
II using declaration 
II using directive 
In this book, we have used the using dircClivc for sid. Be very fm gaJ with using 
directives; sec §A.15. 
8.1.3 Description style 
A full description of even a simple standard library operation, such as a construc-
tor or an algorithm, can take pages. Consequently, we usc an extremely abbrevi-
ated style of prcsemation. For example: 
Examples of notation 
p=op(b,e,x) 
foo(x) 
bar(b,e,x) 
op does something to the range Ib :ej and x, returning p. 
foo doc'S something to x, but returns no result. 
Does x have something to do with Ib :e jr 
We cry to be mnemonic in our choice of idemifiers, so b,e will be iterators speci-
fying a range, p a poimer or an iterator, and x some value, all depending Oil COIl-
text. In this notation, only the commentary distinguishes no result from a 
Boolean result, so you can confuse those if you try hard enough. For an opera-
tion retuming bool, lhe explanation usually ends with a question mark. 
Where an algorithm follows the usual pattem of returning the end of an 
inpm sequence to indicate "failure," "not found," etc. (§B.3.1), we do not mention 
that explicitly. 
B.2 Error handling 
The standard library consists of components developed over a period of almost 
40 years. 111l1s, their style and approaches to error handling are not consistent. 

B.2 
ERROR HANDLING 
Gstyle libraries consist of functions, many of which set ermo to indicate 
that an error happened; see §24.8. 
Many algorithms operating on a sequence of clements return an iterator 
to the one-past-the-Iast clement to indicate "not found" or "failure." 
The 110 streams library relies on a state in each stream to reflect errors 
and may (if the user requests it) throw exceptions to indicate errors; see 
§'O.6, §B.7.2. 
Some standard library components, such as vector, string, and bitset, 
throw exceptions to indicate errors. 
TIle standard library is designed so that all facilities obey "the basie guarantee'" 
(sec §19.5.3); that is, even if an exception is thrown, no resource (such as mem-
ory) is leaked and no invariant for a standard library class is broken. 
8,2,1 Exceptions 
Some standard library facilities rcpon errors by throwing exceptions: 
Standard library exceptions 
bitset 
dynamic_cast 
iostream 
new 
regex 
string 
typeid 
vector 
throws invalid_argument, ouCoCrange, overflow_error 
throws bad_cast if it cannot perform a conversion 
throws ios_base: :failure if exceptions are enabled 
throws bad_alloc if it cannot allocate memory 
throws regex_error 
throws length_error, ouCoCrange 
throws bad_typeid if it cannot deliver a type_info 
throws ouCoCrange 
"I11ese exceptions may be encountered in any code that directly or indirccuy uses 
these facilities. Unless you ImUla that no facility is used in a way that could throw 
an exception, it is a good idea to always catch one of the root classes of the stan-
dard libnuy exception hierarchy (such as exception) somewhere (e.g., in mainO). 
We strongly recommend that yOLl do not throw built-in types, such as int and 
C-slyle strings. Instead, throw objects of ty pes specifically defined to be used as 
exceptions. A class derived from u1e standard library class exception can be used 
for that: 
class exception { 
public: 
1099 

1100 
APPENDIX B • STANDARD LI BR ARY SUMMARY 
}; 
cxceplio n(); 
exceplion(const exception&)i 
exceplion& operator=(consl exception&); 
virtual -exceptionO; 
virtual const char· what() const; 
The whatO function can be used to obtain a string that is supposed to indicate 
something about the error that caused the exception. 
This hierarchy of standard exception classes may help by providing a classifi· 
cation of exceptions: 
---
Iensth--
-
--
You can define an exception by deriving from a standard library exception like 
this: 
struet M y_error : runl ime_error { 
M y_error(int x): interestin&-.value(x) () 
inl inlerestins-valuei 
consl char· whatO const { return "My_error"; } 
}; 
B.3 Iterators 
Iteralors arc the glue that lics standard library algorithms to their data. Con-
versely, you can S3Y that iterators are the Illechanism used to minimize an algo-
rithm's dependence on the data structures on which it operates (§20.3): 

B. 3 
ITERATO RS 
sort, find , search, copy, ... , my_very_own_algorithm, your_code, ... 
vector, list, map, array, ... , my_container, your_container, ... 
B.3.1 Iterator model 
An iterator is akin to a poimer in tbat it provides operations for indirect access 
(e.g., • for dercferencing) and for moving to a new clement (e.g., ++ for moving 
to the next clement). A sequence of clements is defined by a pair of iterators defin-
ing a half-open range [begin: end): 
TImt is, begin points to the first element of the sequence and end points to one be-
yond the last elemelll of the sequence. Never read from or write to ·end. Note that 
the empty sequence has begin==end; that is, [p:p) is the empty sequence for any 
iterator p. 
To read a sequence, an algorithm usually takes a pair of iterators (b,e) and it-
erates using ++ until the end is reached: 
while (b!=e) { 
/I use!= rather than < 
/I do something 
++b; 
/I go to next element 
) 
Algorithms that search for something in a sequence usually return the end of the 
sequence to indicate "not found"; for example: 
p = find(v.begin(),v.end(),x); 
if (p!=v.end(» { 
II x found at p 
) 
else { 
II look for x in v 
1/ x nOt found in Iv.begin():v.end()) 
) 
1101 

1102 
APPENDIX B • STANDARD llBRARY SUMMARY 
So< §20.3. 
Algorithms that write to a sequence orten arc given only an itcrator to its first 
clement. In that case, it is the programmer's responsibility not to write beyond 
the end of that sequence. For example: 
template<c1ass Iter> void (Iter p, int nl 
{ 
while (n>O)" p = --n; 
} 
veclor<inl> v(10); 
f(v.begin(), v.size()); 
f(v.beginO,1000); 
/10K 
/I big trouble 
Some standard library implementations range check - that is, throw an exception 
- for that last call of (0, but you can't rely on that for portable code; many im-
plementations don't check. 
111C operations on iterators arc: 
Iterator operations 
++p 
p++ 
--p 
p--
' p 
pin] 
p- >rn 
p==q 
p!=q 
Pre-increment: make p refer to the next element in the 
sequence or to one-beyond·thc-Iast-elemcilt (~a dvance one 
element"); the re§ulting value is p+1. 
Post-increment: make p refer to the next element in the 
sequence or to one-beyond·the-Iast-element ("advance one 
elemcnn; the resulting value is p (before the increment). 
Pre-decrement; make p point to previous element ("go back 
one element"); the resulting value is p- 1. 
Post-decrement: make p point to previous element (~go b.lck 
one element"); the re§uiting value is p (before the decrement). 
Acce§s (dereference): "p refers to the clement pointed to by p. 
Acce§s (subscripting); pin] refers to the element pointed to by 
p+n; equivalent to "(p+n). 
Acce§s (member access); equivalent to (·pl.m. 
Equality: true if p and q point to the same element or both 
point to one-beyond-the-Iast-element. 
Inequality: !(p==q). 

B.3 
lTERATORS 
Iterator operations (continued) 
p<q 
p=q 
p>q 
p>=q 
p+=n 
p-=n 
q=p+n 
q=p-n 
advance(p,n) 
x=difference(p,q) 
Does p point to an element before what q points to? 
p<q II p==q 
Does P point to an element after what q points to? 
p>q II p==q 
Advance n: make p point to the nth element after the one it 
points to. 
Advance - n: make p poinl to the nth element before the one it 
points 10. 
q points to the nth element after the one pointed to by p. 
q points to the nth element before the one pointed to by p; 
afterward, we have q+n==p. 
Advance: like p+=n; advanceO can be used even if p is not .1 
random-access iterator; it may take n steps (through a lis!). 
Difference: like q-Pi differenceO can be used even if p is not 
a random-access iterator; it may take n steps (through a list). 
Note that nOI every kind of iterator (§B.3.2) supports every ileralor operation. 
8.3.2 Iterator categories 
TIle standard library provides five kinds of iterators (five I;iterator categories"): 
Iterator categories 
input iterator 
output iterator 
forward iterator 
We can iterate forward using ++ and read each element 
once only uSing · . We can compare iterators using == and 
!=. This is the kind of iterator that islream offers; see 
§21.7.2. 
We can iterate forward using ++ and write each element 
once only using ' . This is the kind of iterator that ostream 
offers; see §21 .7.2. 
We can iterate forward repeatedly using ++ and rcad and 
write (unless the elements are consl) elements using · . If it 
points to a class object, it can use -> to access a member. 
1103 

1104 
APPENDIX B • STANDARD LI BRARY SU MMARY 
lIerato, categories (continued ) 
bidirectional iteratar 
We can iterate fOl'\vard (using ++) and backward (using --) 
and read and write (unless the elements arc const) 
elements using *, This is the kind of iterator that list, map. 
and set offer. 
randomaccess iteratar 
We can iterate forward (using ++ or +=) and backward 
(using -
or -=) and read and write (unless the elements 
are consl) elements using · or n. We can subscript, add an 
integer to a random-access iteralor using +. and subtract an 
integer using - . We can find the distance between two 
random-access iterators to the same sequence by 
subtracting one from the other. We can compilre ilcrators 
using <, <=, >, and >=.1his is the kind of iterator that 
vector offers. 
Logically, these iterators arc organized in a hierarchy (§20.8): 
Input-
......... -
_ .... -
Nme that since the iterator categories are not classes, this hierarchy is nm a class 
hierarchy implemented using derivation. If you need to do something advanced 
with iterator categories, look for ilerator_trails in an advanced reference. 
Each container supplies iterators of a specified category: 
vector - random access 
list - bidirectional 
deque - random access 
bitsel - none 

11.'1 
CONTA INERS 
set - bidirectional 
mulliset - bidirectional 
map - bidirectional 
multimap - bidirectional 
unordered_set - forward 
unordered multiset - forward 
unordered_map - fonvard 
unordered_multimap - fonvard 
B.4 Containers 
A container holds a sequence of objects. The clements of the sequence are of the 
member type called value_type. The most commonly useful containers are: 
Sequence containers 
array<T,N:> 
deque<T> 
list<T:> 
fixed-size array of N elements of type T (C .. Ox) 
double-ended queue 
doubly-linked list 
vector<T:> 
dynamic array of elements of type T 
Associative containers 
map<K,V:> 
multimap<K, V:> 
set<K:> 
muJtiset<K:> 
unordered_map<K, V:> 
unordered_multi map<K, V:> 
unordered_set<K:> 
unordered_multiset<K:> 
map from K to V; a sequence of (K,V) pairs 
map from K to V; duplicate keys allowed 
sel of K 
set of K (duplicate keys allowed) 
map from K to V using a hash function (C++Oxj 
map from K to V using a hash function; duplicate 
keys allowed (C++Ox) 
set of K using a hash function (C .. Ox) 
set of K using a hash function; duplicate keys 
allowed (C++Oxj 
1105 

1106 
APPENDIX B • STA NDARD LIBRARY SUMMA RY 
Container adaptors 
priority_queue<T> 
queue<T> 
stack<T> 
priority queue 
queue with pushO and popO 
stack with pushO and popO 
111csc containers arc defined in <vedo!'>, <liSI>, elc. (sec §B.l.l). 111c sequence 
containers are contiguously allocated or linked lists of elements of their 
value_type (T in the notation lIsed above). The associative containers arc linked 
stnlCturcs (trees) with nodes of their value_type (pair(K,V) in the notation used 
above}. The sequence of a set, map, or multimap is ordered by its key values (K). 
111e sequence of an unordercd_· does not have a guaranteed order. A multimap 
differs from a map in that a key value may occur many times. Container adap-
tors are containers with specialized operations constructed from otber containers. 
If in doubt, use vector. Unless you have a solid reason not to, use vector. 
A container uses an "allocator" to allocate and dealloc.:'lte memory (§19.3.6). 
We do not cover allocators here; if necessary, see an expert-level reference. By de-
fauit, an allocator uses new and delete when it needs to acquire or release mem-
ory for its elements. 
Where meaningful, an access operation exists in two versions: one for consl 
and one for non-canst objects (§18.4). 
This section lists the common and almost conUllon members of the standard 
containers. For more details, sec Chapter 20. Mcmbers that arc peculiar to a spe· 
cific container, such as list's spliceO, are not listed ; sec an expert-level reference. 
Some data types provide much of what is required from a standard container, 
but not all. We sometimes refer to those as "almost containers." The most inter· 
esting of those are: 
HAl most containers" 
T(n) 
built-in array 
string 
valarray 
no sizeO or other member functions; prefer a container, such as 
vector, Siring, or array, over array when you have a choice 
holds only characters but provides operations useful for text 
manipulation, such as concatenation (+ and +=J; prefer the standard 
string to other strings 
a numerical vector with vector operations, but with many restrictions 
to encourage high-performance implementations; use only if you do a 
lot of vector arithmetic 

BA 
CONTAINE RS 
8.4.1 Overview 
111e operations provided by the standard containers can be sUITUllanzed like lhis: 
Container: 
constructor, Copy constructor, 
derault constructor, beginO, end(), 
rbeginO, rendO, ==, !=, <, <=, >, >=, 
=, swap(), size(), max....size(), empty(), 
insert(), eraseO, dear() 
Sequential container: 
assignO, frontO, back(), 
push_back(), pop_backO, 
resizeO 
list: 
push_frontO, 
pop_fronIO, 
spliceO, 
removeO, 
remoye_ifO, 
uniqueO, 
merge(), 
sortO, 
reyerseO 
vector: 
operator[J, 
at(), 
capacilyO, 
reserve() 
deque: 
opera lorn, 
at(), 
push_frontO, 
pop3 roniO 
~~ativecontain en: 
key_compO, 
value_compO, findO , 
countO, lower_boundO, 
equal_rangeO 
sel, 
multiset, 
and 
multimap 
array: 
operator[], 
at() 
map: 
operator[] 
1107 

1108 
APPEND IX B • STAN DARD LIBRARY SUMMARY 
8.4.2 Member types 
A container defines a set or member types: 
Member types 
value_lype 
size_type 
difference_type 
iterator 
consCiterator 
reverse_iterator 
consc ,eversc_ilerator 
reference 
cansl_reference 
pointer 
canst_pointer 
key_lype 
mapped_type 
key_compare 
allocatof_type 
type of element 
type of subscripts, clement counts, etc. 
type of difference between iteralors 
behaves like value_type-
behaves like const value_lype-
behaves like valuc_type-
behaves like const value_lype-
valuc_lype& 
consl value_lype& 
behaves like value_type-
behaves like const value_type 
type of key (associative containers only) 
type of mapped value (associative containers only) 
type of comparison criterion (associative containers only) 
type of memory manager 
8.4.3 Constructors, destructors, and assignments 
Containers provide a variety of constructors and assignment operations. For a 
container callcd C (e.g., veclo r<double> or map<Slring,int» we have: 
ConslruCiors, destruCiors, and assignment 
C c; 
co 
C ( (n); 
C c(n,x); 
C c(b,e); 
c is an empty container. 
Make an empty container. 
C initialized with n elements with default element value (not (or 
associative containers). 
C initialized with n copies of x (not fOf associative containers). 
( initialized with elements from Ib:e). 

6.4 
CONTAINER S 
ConstruClors, destructors, and assignment (continued ) 
C c(c2); 
- CO 
cl=c2 
c.assign(n,x) 
c.assign(b,e) 
c is a copy of c2. 
Destroy a C and all of its elements (usually invoked implicitly). 
Copy assignment; copy all elements from c2 to cl ; after the 
aSSignment cl==c2. 
Assign n copies of x (not for associative containers). 
Assign from [b :e). 
Note lhat for some containers and some clement types, a constructor or an cle-
ment copy may throw an exception. 
B.4.4 Iterators 
A container " 111 be viewed as a sequence either in the order defined by lhe con-
!ainer's ite rator or in reverse order. For an associative container, lhe order is 
based on the container's comparison criterion (by default <): 
Iterators 
p=c.begin() 
p=c.endO 
p=c.rbeginO 
p=c.rend() 
p points to first element of c. 
p points to one past last element of c. 
p points to first element of reverse sequence of c. 
p points to one past last element of reverse sequence of c. 
8.4.5 Element access 
Some clements can be accessed directly: 
Element access 
c.b onlO 
c.backO 
cIi) 
c.al(i) 
reference to first element of c 
reference to last element of c 
reference to element i of c; unchecked access (not for list) 
reference to element i of c; checked access (vector and deque only) 
Some implementations - especially debug versions - always do range checking, 
but you c.'mnot portably rely on that for correctness or on the absence of checking 
for perfonnance. 'VVhere such issues are important, examine your implementations. 
1109 

1110 
AP PENDIX B • STANDARD LIBRARY SUMMARY 
B.4.6 Stack and queue operations 
The standard vector and deque provide efficient operations at the end (back) of 
their sequence of clements. In addition, list and deque provide the equivalent op-
erations on the Start (front) of their sequences: 
Stack and queue operations 
c.push_back(x) 
c.pop_backO 
c.push_front{x) 
c.pop_frontO 
Add x !o the end of c. 
Remove last element from c. 
Add x to c before first clemenl (list and deque only). 
Remove fi rSI elemen! from c (list and deque only). 
Note that push_frontO and push_backO copy an clement into a container. TIlis 
implies that the size of the container increases (by one). If the copy constructor of 
the clement type can throw an exception, a push can fail. 
Note that pop operations do not retum a value. Had they done so, a copy 
constructor throwing an exception could have seriously complicated the imple-
mentation. Usc frontO and backO (§B.4.5) to access stack and queue clements. 
We have not recorded the complete SCI of requirements here; feci free to guess 
(your compiler will usually tell you if you guessed wrong) and to consult more 
detailed documentation. 
B.4.7 list operations 
Containers provide list operations: 
list operations 
q=c.inserl(p,x) 
q=c.inserl(p,n,ll) 
q=c. i nserl( p, first,last) 
q=c.erase(pl 
q=c. erase(first, last) 
c.clearO 
Add x before p. 
Add n copies of x before p. 
Add elements from Ifirst:last) before p. 
Remove element at p from c. 
Erase Ifirst:lasl) of c. 
Erase all clements of c. 
For insertO functions, the result, q, points to the last clement inserted. Fo r eraseO 
functions, q points to the clement that followed the last clement erased. 
8.4.8 Size and capacity 
TIle size is lhe number of clements in the container; the capacity is the number of 
clements that a container can hold before allocating morc memory: 

IJA 
CONTAINER S 
Size and capacity 
x=c.size() 
c.emptyO 
x=c.max_sizeO 
x=c.capacityO 
c.reserve(n) 
c.resize(n) 
x is the number of elements of c. 
Is c empty? 
x is the largesl possible number of elements of c. 
x is the space allocated for c (vector and siring only). 
Reserve space for n elements for c (vector and string only). 
Change size of c to n (vector, string, list, and deque only). 
When changing the size or the capacity, the clements may be moved to new stor-
age locations. That implies that iterators (and pointers and references) to ele-
ments may become invalid (e.g., point to the old clement locations). 
8.4.9 Other operations 
Containers can be copied (sec §BA.3), compared, and swapped: 
Comparisons and swap 
cl ==c2 
c1 !=c2 
cl <c2 
c1<=c2 
cbc2 
c1>=c2 
swap(c1,c2) 
cl .swap(c2) 
0 0 all corresponding elements of cl and c2 compare equal~ 
00 any corresponding elements of cl and c2 compare not equal? 
Is c1 lexicographically before c2? 
Is c1 lexicographically before or equal to c2? 
Is c1 lexicographically after c2? 
Is c1 lexicographically after or equal to c2? 
Swap elements of cl and c2. 
Swap elements of cl and c2. 
When comparing containers with an operator (e.g., <), their clements arc com-
pared using the equivalent clement operaLOr (i.e., <). 
B.4.10 Associative container operations 
Associative containers provide lookup based on keys: 
Associative container operations 
elkl 
p=c.find(k) 
Refers to the element with key k (containers with 
unique keys). 
p points to the first element with key k. 
1111 

1112 
APPENDIX B • STANDARD LIBRARY SUMMARY 
Associative container operalions (continued) 
p=c.lower_bound(k) 
p=c.upper_bound(k) 
pai rep 1 ,p2)=c.eq uaCrange(k) 
r=c.key_comp{) 
r=c.value_compO 
p points to the first element with key k. 
p points to the first element with key greater than k. 
[pl,p2) are the elements with key k. 
r is a copy of the key·comp<"trison object. 
r is a copy of the mapped_value-comparison 
object. If a key is not found, c.end{) is returned. 
TIle first iterator of the pair returned by equaCrange is lower_bound and 
the second is upper_bound. You can pl;m the value of all clements with the key 
"Marian" in a muitimap<string,int> like this: 
string k = "Marian"; 
typedef multimap<string,int>:: iterator MI; 
pair<MI,MI> pp = m.equaCrange(k); 
if (pp.first!=pp.second) 
cout« "elements with value ' ''« k«" ':\n"; 
else 
cout« "no element with value' " « k « " '\n"; 
for (MI p = pp.first; p!=pp.second; ++p) cout« p->second« '\n'; 
We could equivalently havc used: 
pair<MI,MI> pp = make_pair(m.lower_bound(k),m.upper_bound(k»; 
However, that would take about nvicc as long to execute. TIle equal_range, 
lower_bound, and upper_bound algorithms are also provided for sorted se-
quences (§B.5.4). TIle definition of pair is in §B.6.3. 
8.5 Algorithms 
"There are about 60 standard algorithms defined in <algorithm>. TI1CY all opel" 
ate on sequences defined by a pair of iterators (for inputs) or a single iterator (for 
outputs). 
When copying, comparing, etc. two sequences, the first is represented by a 
pair of iterators [b:e) but the second by just a single iterator, b2, which is consid· 
ered the start of a sequence holding sufficient elements for the algorithm, for ex· 
ample, as many clements as the first sequence : [b2:b2+(e-b»). 
Some algorithms, such as sort, require random-access iterators, whereas 
many, such as find, only read lheir elements in order so that they can make do 
with a forward iterator. 

B.5 
ALGO RI THMS 
1113 
Many algorithms rollow the usual convention or returning the end or a se· 
quence to represent "not round." We don't mention that ror each algorithm. 
B.S.l Nonmodifying sequence algorithms 
A nonmO(:liryillg algolithm juSt reads the clements or a sequence; it does not re-
arrange the sequence and docs nOt change the value or the elements: 
Nonmodifying sequence algorithms 
f=for_each(b,e,O 
p=find(b,e,v) 
p=find_if(b,e,O 
p=find_firsCof(b,e,b2,e2) 
p=find_firscof(b,e,b2,e2,O 
p=adjacenCfind(b,e) 
p=adjacenCfind(b,e,O 
equaHb,e,b2) 
equal(b,e,b2,f) 
pair(pt,p2)=mismatch(b,e,b2) 
pair(p 1 ,p2)=mismatch(b,e, b2, f) 
p=search(b,e,b2,e2) 
p=search(b.e,b2,e2,f) 
p=find_end(b,e,b2,e2) 
p=find_end( b,e,b2,e2,f) 
p=search_n(b,e,n,v) 
p=search_n(b,e,n,v,f) 
x=counl(b,e,v) 
x=counCif(b,e,v,f) 
Do f for each clement in [b:e); return f. 
p points 10 Ihe first occurrence of v in [b:e). 
p points to the first clement in [b:eJ so that W p). 
p points 10 the first element in [b:e) so that "p=="q for some 
q in [b2:e2). 
p points to the first clement in [b:e) so that «.p, "q) for some 
q in [b2:e2). 
p points to the first p in [b:e) such that · p=="(p+l). 
p points to the first p in (b:e) such that f(·p,"(p+l» . 
0 0 all elements of [b:e) and [b2: b2+(e-b)) compare equal? 
Do all elements of [b:e) and [b2: b2+(e-b») compare equal 
using {("p, "q) as the test? 
(pl,p2) points to the first pair of elements in Ib:e) and 
[b2: b2+(e-b» for which !("pl=="p2). 
(pl,p2) points to the first pair of elements in Ib:e) and 
(b2:b2+(e-b» for which !Wpl, "p2). 
P points to the first . p in [b:e) such that . p equals an element 
in Ib2:e2). 
p points to the first . p in [b:e) such that {(-p, 0q) for an 
element "q in Ib2:e2). 
p points to the last · p in [b :e) such that · p equals an element 
in Ib2:e2). 
p points to the lasl . p in [b:e) such that f(- p: q) for an 
element 0q in [b2:e2). 
p points to the first element of Ib:e) such that each element in 
Ip:p+n) has the value v. 
p points to the first element of Ib:e) such that for each 
element "q in [p:p+n) we have f(Oq,v). 
)( is the number of occurrences of v in Ib:e). 
x is the number of elements in Ib:e) SO that W p,v). 

1114 
APPENDIX B • STANDARD LIBRARY SUMMARY 
Note that nothing stops the operation passed to fOf_each from modifying cle-
ments; that's considered acceptable. Passing an operation that changes the cle-
ments it examines to some other algorithm (e.g., count or ==) is not acceptable. 
An example (of proper use): 
bool odd(int xl { feturn x&l ; } 
int n_even(const vector<inl>& v) 
/I count the number of even values in v 
{ 
re turn v.size()-counUf(v.beginO,v.e ndO,odd); 
} 
B.5.2 Modifying sequence algorithms 
The modifying algorililllls (also called /JIulaling Jequenu algorilhllu) can (and often 
do) modify the clements of their argument sequences. 
Modifying sequence algorithms 
p=transform(b,e,out,f) 
p=lransform(b,e,b2,out,f) 
p=eopy(b,e,out) 
p=copy_baekward(b,e,out) 
p=unique(b,e) 
p=unique(b,e,f) 
p=unique_eopy(b,e,out) 
p=uniquc3 0py(b,e,oul,f) 
replaee(b,e,v,v2) 
replaee(b,e,f,v2) 
p=replace_eopy(b,e,out,v,v2) 
Apply · p2=f(-p1) to every · pl in Ib:e) writing to the 
corresponding · p2 in [out :out+(e-b)); p=out+(e-b) 
Apply · p3=Wpl, · p2) to every element in "pl in Ib:e) and 
the corresponding element "p2 in Ib2:b2+(e-b» , writing to 
. pJ in [out:oul+(e-b»; p=oul+(e-b) 
Copy [b:e) to [OUI:p). 
Copy Ib:e) to loul:p) starting with its last element. 
Move elements in [b:e) so that Ib:p) has adjacent duplicates 
removed (== defines ~duplicale~). 
Move elements in Ib: e) SO that Ib:p) has adjacent duplicates 
removed (f defines "duplicate"'). 
Copy Ib:e) to 10ut:p); don't copy adjacent duplicates. 
Copy [b:e) to loul:p); don't copy adjacent duplicates (f 
defines "duplicate"). 
Replace elements "q in jb:e) for which °q==v with v2. 
Replace elements 0q in Ib:e) for which f(·q) with v2. 
Copy Ib:e) to [oul :p), replacing elements "q in [b:e) for 
which "q=v with v2. 

B.5 
ALGORITHMS 
Modifying sequence algorithms (continued ) 
p=replace_copy(b.e.out.f.v2) 
p=remove(b,e.v) 
p=remove(b,e.v,f) 
Copy Ib:e) to lout:p), replacing clements *q in Ib:e) fOf 
which Wq) with v2. 
Move elemenls *q in Ib:e) so Ihal lb:p) becomes the 
elements (Of" which Wq==v). 
Move elements *q in Ib:e) so that Ib:p) becomes the 
elements (Of" which !Wq). 
Copy elements from Ib:e) for which !(Oq==v) to 10ut:pJ. 
Copy elements from Ib:eJ for which !f(*q,v) to lout:p). 
Reverse the order of elements in [b:eJ. 
Copy Ib:e) into lout: p) in reverse order. 
1115 
p=remove_copy{b,e.out,v) 
p=remove_copy_if(b,e,out,O 
reverse(b,e) 
p=reverse_copy(b,e,out) 
rotate(b,m,e) 
Rotate elements: treatlb :e) as a circle with the first element 
right after the last. Move °b to om and in general move "(b+i) 
to "« b+(i+(e-m))%(e-b)). 
p=rotate_copy(b,m,e,out) 
random_shuffle(b,e) 
random_shuffle(b.e,O 
Copy (b:e) into a rotated sequence loul :p). 
Shuffle elements of lb:e) into a distribution using the default 
uniform random number generator. 
Shuffle elements of [b:c) into a distribution using f as a 
random number generatOf". 
A shu me algorithm shumes its sequence lUuch in the way we would shume a pack 
of cards; that is, after a shume, the elements are in a random order, where «ran-
dom" is defined by the distribution produced by the random number generator. 
Please note that these algorithms do not k.now if their argument sequence is a 
container, so they do not have the ability to add or remove clements. TIlliS, an al-
goritiuu such as re move cannot shorten its input sequence by deleting (erasing) 
clements; instead, it (re)moves the clements it k.eeps to the front of lhe sequence: 
typcdef vector<in(>: :iterator VIii 
void prin,-digits(const string& 5, VII b, VII e) 
{ 
cout « Sj 
while (b! =e) {cout « °b j ++b;} 
cout « '\n'; 

1116 
APPENDIX B • STANDARD liBRARY SUMMARY 
void ffO 
{ 
) 
int aU = { 1,1,1, 2,2, 3, 4,4,4, 3,3,3, 5,5,5,5, 1,1,1 }; 
vector<inl> v(a,a+sizeof{a)/sizeof(in I»; 
print_digits("all: ",v.beginO, v.end{»; 
vector<inl>: :iterator pp = unique(v.begin(),v.end{»; 
prinCdigits("head : II ,v.beginO,pp); 
prinCdigits("tail : ",pp,v.end()); 
Pl>= remove( v. begin (), pl>,4); 
prinCdigits(" head: II ,v.beginO,pp); 
I>rinCdigits{"tail: ",pp,v.endO); 
TIle resulting output is 
all: 
1112234443335555111 
head : 1234351 
tail: 
443335555111 
head : 123351 
tail: 
1443335555111 
B.S.3 Utility algorithms 
Technically, these utility algOli!.hms are also modifying sequence algorithms, but. 
we thought it a good idea to list them separately, lcst they get overlooked. 
Utility algorithms 
swap()(,y) 
Swap )( and y. 
iter_swal>(p,q) 
Swap .p and . q. 
swap_,anges(b,e,b2) 
Swap Ihe elements of Ib:e) and [b2:b2+(e-b». 
fill(b,e,v) 
Assign v to every element of [b:e). 
fiICn(b,n,v) 
Assign v to every element of [b: b+n). 
generate(b,e,f) 
Assign fO to every element of [b:e). 
generate_n(b,n,f) 
Assign fO to every element of [b:b+n). 
uninitialized_fill (b,e,v) 
Initialize all elements in [b:e) with v. 
uninitialized_copy(b,e,out) 
Initialize all elements of loul :out+(e-b)) with the 
corresponding element from Ib:e). 

(l .S 
ALGORIT HM S 
1117 
Note that uninitialized sequences should occur only at the lowest level of pro-
gramming, usually inside the implementation of containers. Elements that are 
targets of uninitialized_fill or uninitialized_copy must be of built-in type or 
uninitialil.ed. 
B.5.4 Sorting and searching 
Sorting and searching are fundamental and the needs of programmers arc quite 
varied. Comparison is by default done using the < operator and equivalence of a 
pair of values a and b is detennined by !(a<b)&&!(b<.a) rather than requiring op-
erator ==. 
Sorting and searching 
sorUb,e) 
sort(b,e,f) 
stable_sorUb,c) 
stablc_sorl(b,c, f) 
partial_sort(b,m,e) 
partial_sorl(b,m,e,f) 
partial_sorCcopy(b,e,b2,e2) 
partial_sorCcopy(b,e,b2,e2,f) 
nth_elemenl(b,e) 
nlh_clemenl(b,e,f) 
p=lowcr _bou nd (b,c, v) 
p=lower_bound(b,c,v,f) 
p=u pper _bou nd(b,e, v) 
p=upper_bound(b,e,v,f) 
binary_scarch(b,e,v) 
bina ry _search(b,e, v,f) 
pair(p 1, p2)=eq ual_range(b,e ,v) 
Sonlb :e). 
Son Ib:e) using W p, -q) as the sorting criterion. 
Sort (b:e), mainIJining order of equivalent elements. 
Son lb:e) using Wp, .q) as the sorting criterion, mainlaining 
order of equivalent elements. 
5onlb:c) to get Ib :m) inlo order; (m :c) need not be soned. 
Sort Ib:e) using Wp, . q) as the sorting criterion 10 gel Ib :m) 
into order; [m:e) need not be sorted. 
Son enough of Ib:e) to copy the c2-b2 first elements to 
[b2:e2). 
Sort enough of Ib:e) to copy the e2-b2 first elements to 
[b2:e2); use f as Ihe comparison. 
Put the nth element of Ib:e) in its proper place. 
Pul the nth element of Ib:e) in its proper place using f for 
comparison. 
p points to the first occurrence of v in [b:e). 
p points to the first occurrence of v in [b:e) using f for 
comparison. 
p points to the first value larger than v in Ib: e). 
p points 10 the first value larger than v in [b:e) using f for 
comparison. 
Is v in the sorted sequence Ib:e)? 
Is v in the sorted sequence Ib:e) using f for comparison? 
[pl,p2) is the subsequence of [b:e) with the value v; basically, 
a binary search for v. 

1118 
APPENDIX B • STANDARD LIBRARY SU MMARY 
Sorting and searching (continued ) 
pair{p1 ,p2)=equal_,ange{b,e, v,f) 
p=merge{b,e,b2,e2,out) 
p=merge{b,e,b2,e2,out, f) 
inplace_merge(b,m,e) 
inplace_merge{b,m,e,f) 
p=part it ion(b,c, f) 
p=stablc_part ition (b,e, f) 
For example: 
vector<int> V; 
lisl<double> 151; 
Ip1 ,p2) is the subsequence of Ib:e) with the value v using f fOf' 
comparison; baSically, a binary search for v. 
Merge two sorted sequences Ib2:e2) and Ib:e) into lout:p). 
Merge two sorted sequences Ib2:(2) and Ib:e) into 
lout,out+p) using f as the comparison. 
Merge two sorted subsequences Ib:m) and Im:e) into a sorted 
sequence [b:e). 
Merge two sorted subsequences Ib:m) and Im:e) into a sorted 
sequence Ib:e) using f as the comparison. 
Place elements for which Wpl) in Ib:p) and other elements in 
Ip:e). 
Place elements for which f{*p1) in Ib: p) ancl other elements in 
Ip: el. preserving relative order. 
v.push_back(3); v.push_back(1); 
v.push_back(4); v.push_back(2); 
Ist.push_back(0.5); Ist.push_back(I.5); 
Isl.push_back(2); Isl.push_back(2.5); 
II lsi is in oreler 
sorl(v.beginO,v.end () ; 
/I put v in order 
vector<double> v2; 
me rge(v.beginO,v.endO,lst.beginO,lst.end(),back_inserter(v2»; 
for (int i = 0; i<v2.sizeO; ++i) cout « v2[iJ« ", "; 
For inserters, sec §B.6. 1. ~nl e OUlp llt is 
0.5, 1, 1.5, 2, 2, 2.5, 3, 4, 
TIle equal_range, lower_bound, and upper_bound algoritluns a]"e used just 
like lheir equivalents for associative containers; sec § B.4. 1O. 
B.5.5 Set algorithms 
These algorithms treat a sequence as a set of eicmellls and provide the basic SCt 
operations. The input sequences arc supposed to be soned and the output se-
quences arc also sorted: 

B. 5 
ALGO RITHM S 
Set algorithms 
includes(h,e,h2,e2) 
inciudes(b,e,b2,e2,O 
p=seLunion{b,e,b2,e2,Out) 
p=seLunion(b,e,b2,e2,out,O 
p=seLinlerseclion(b,e,b2,e2,oul) 
p=seLinterseclio n(b,e,b2,e2,out,O 
p=sel_difference(b,e,b2,e2,oul) 
p=seLdifference(b,e,b2,e2,out,(J 
p=seLsymmelric_difference(b,e,b2,e2,oul) 
p=seLsymmelric_difference(b,e,b2,e2,oul,f) 
B.5.6 Heaps 
1119 
Areall elements of Ib2:e2) also in Ib:e)? 
Areall clements of Ib2:e2) also in Ib:e) using f 
for comparison? 
Construct a sorted sequence [oul:p) of 
elements that are in either Ib:e) or Ib2:(2). 
Construct a sorted sequence lo ul:p) of 
elements that are in either Ib:e) or [h2:(2) 
using f for comparison. 
Construct a sorted sequence [o ul : p) of 
elements that are in both [b:e) and Ib2:(2). 
Construct a sorted sequence [o ul : p) of 
elements that are in both lb:e) and lb2:(2) 
using f for comparison. 
Construct a sorted sequence [o ul : p) of 
elements that are in Ib:e) but not in Ib2:e2). 
Construct a sorted sequence [o ul :p) of 
elements that arc in [b:e) but not in Ib2:(2) 
using f for comparison. 
Construct a sorted sequence [o ul:p) of elements 
that are in Ib:e) or [b2:e2) but not in both. 
Construct a sorted sequence [o ul :p) of 
elements that are in Ib:e) or [b2:(2) but not in 
both using f for comparison. 
A heap is a data StruclUre that keeps the clement with highest value first. 111C 
heap algorithms allow a programmer to treat a random-access sequence as a heap: 
Heap operations 
make_heap{b,e) 
make_heap(b,e,O 
push_heap(b,e) 
push_heap(b,e,(J 
Make SC<luence ready to be used as a heap. 
Make sequence ready to be used as a heap, using f for 
comparison. 
Add element to heap (in its proper place). 
Add element to heap, using f for comparison. 

1120 
APPENDIX B • STANDARD LIBRARY SUMMARY 
Heap operations (continued ) 
pop_heap(b,e) 
pop_heap(b,e,O 
sorCheap(b,e) 
sorCheap(b,e,O 
Remove largest (first) element from heap. 
Remove element from heap, using f for comparison. 
Sort the heap. 
Sort the heap, using f for comparison. 
111e point of a heap is to provide fast addition of clements and fast access to the 
clement with the highest value. ~nlC main use of heaps is to implcmcill priority 
queues. 
B.S.7 Permutations 
Pennutations arc used to generate combinations of clements of a sequence. For 
example, the permutations of abc are abc, acb, bac, bea, cab, and chao 
Permutations 
x=nexc permutation(b,e) 
x=nexLpermutation(b,e,f) 
x=prev_permulalion(b,e) 
x=prev_permutation(b,e,O 
Make (b:e) the next permutation in lexicographical 
order. 
Make [b:e) the next permutation in lexicographical 
order, using f for comparison. 
Make [b:e) the previous permutation in 
lexicographical order. 
Make [b:e) the previous permutation in 
lexicographical order, using f for comparison. 
111C rcturn valuc (x) for nexLpermulation is false if [b :e) alrcady contains thc 
last permutation (cba in the cxample); in that case, it returns the first permutation 
(abc in the cxample). The return value for prey_pe rmutation is false if [b:e) al-
ready contains the first pennutation (abc in the example); in that case, it returns 
the last permutation (cba in the example), 
8.5.8 min and max 
Vailic comparisons arc uscful in many comexts: 

8.6 
STL UTI LITIES 
min and max 
lI=max(a,b) 
lI=max(a,b,f) 
lI=min(a,b) 
lI=min(a,b,f) 
p= max_elemenl(b,e) 
p=m~element ( b , e , f) 
p=min_element(b,e) 
p=min_element(b,e,f) 
lellicographical_compare(b,e,b2,e2) 
lexicographical_compare(b,e,b2,e2,f) 
B.6 STL utilities 
x is the larger of a and b . 
x is the larger of a and b using f for 
comparison. 
x is the smaller of a and b. 
x is the smaller of a and b using r (or 
comparison. 
p points to the largest element of [b:e). 
p points to the largest element of [b:e) 
using f for the element comparison. 
p poinl5to the smallest element o( [b :e). 
p points to the smallest element of [b :e) 
using f for the element comparison. 
Is Ib:el<[b2 :e2j? 
Is [b:el<lb2:e2), using f for the element 
comparison? 
TIle standard library provides a few facilities for making it easier 10 lise standard 
library algorithms. 
8.6.1 Inserters 
Producing output through an iterator into a container implies that clements 
pointed to by the iterator and following it can be overwritten. This also implies 
the possibility of overflow and consequent memory corruption. For example: 
void f(vector<inl>& vi) 
{ 
filCn(vi,beginO, 200,7 Ii 
/I assign 7 to viIOI .. ! 1991 
If vi has fewer than 200 clements, we are in trouble. 
In <iteratoD, the standard library provides three iterators to deal with this 
problem by adding (inserting) clements to a container rather than overwriting old 
clements. TIU"Cc functions are provided for generating those inserting ileralors: 
1121 

1122 
Inserters 
r=backjnserter(c) 
r=fronUnserter(c) 
r=inserter(c,p) 
APPENDIX B • STANDARD LIBRARY SUMMARY 
· r=x causes a c.push_back()!). 
·r=x causes a c.push_hont(x). 
· r=x causes a c,inserl(p,x). 
For inserter(c,p), p must be a valid itcrator for the container c. Naturally, a con-
tainer grows by one clcmelll each time a value is written to it through an insert it-
eratOr. When wriuen to, an inserter inserts a new clement into a sequence using 
push_back(x), c.push_irontO, or insertO rather than overwriting an existing cle-
ment. For example: 
void g(veclor<int>& vi) 
( 
fi IC n(back_inserter(vi), 200,7); /I add 200 7s to the end of vi 
} 
B.6.2 Function objects 
Many of t.he standard algorithms lake function objecLS (or functions) as argu-
mems to comrolthc way they work. Common lIses are comparison criteria, pred-
icates (functions returning bool), and arithmetic operations. In <functional>. the 
standard library supplies a few common function objects. 
Predicates 
p=equaUo<T>O 
p=noCequaUo<T>() 
p=grealef<T>O 
p=less<T>() 
p=Sfeale,_equakT>() 
p=less_equakT>O 
p=logical_and<T>O 
p=logical_of<T>O 
p=logical_not<T>O 
For eXil.m plc: 
p(x,y) means x==y when x and y are of type T. 
p(x,y) means x!=y when x and y are of type T. 
p(x,y) means x>y when x and y are of type T. 
p(x,y) means xq when x and y are of type T. 
p(x,y) means x>=y when x and y are of type T. 
p(x,y) means x<=y when x and y are of type T. 
p(x,y) means x&&y when x and y are of type T. 
p{x,y) means xlly when x and y ,lre of type T. 
p(x) means !x when x is of type T. 

B.6 
STL UT ILITIES 
vector<inb v; 
1/ . . . 
SO rt( v. begi n (),,,.e nd (), greater<i nbO); 
II son v in decreasing order 
Note that logical_and and logicaCor always evaluate both their arguments 
(whereas && and II do not). 
Arithmetic operations 
f=plus<T>O 
f=minus<T>O 
f=multiplies<T>O 
f=divides<T>() 
(=modulus<T>() 
f=negate<T>O 
Adaptors 
f(x,y) means Hy when x and y are of type T. 
((x,y) means x-V when x and y are of type T. 
f(x,y) means x·y when x and y are of type T. 
f(x,y) means xly when x and y are of type T. 
f(x.y) means x%y when x and y are of type T. 
fIx) means -x when x is of type T. 
f=bind2nd(g,y) 
f(x) means g(x,y). 
f=bindlsl(g,x) 
f(y) means g(x,y). 
(=mem_fun(mO 
f(p) means p->mfO. 
f=mem_fun_ref(mfJ 
f(r) means r.mfO. 
f=nol1(g) 
fIx) means 19(x). 
f=nol2(g) 
f(x,y) means !g(x,y). 
B.6.3 pair 
In <utility>, the standard library provides a few "utility components," including 
pair: 
template <class 11, class 12> 
struct pair { 
typedefTl firsUype; 
typedef T2 second_type; 
11 first; 
12 second; 
1123 

1124 
}; 
AP PENDIX B • STANDA RD LIBRARY SUMMARY 
pair()i /I default constructor 
pair(const T1& x , const T2& y); 
// copy operations: 
template<class U , class V > pair(eonst pair<U , V>& P l; 
template <class T1 , class T2> 
pair<T1 ,T2> make_pair(T1 x, T2 y) { return pair<Tl ,T2>(x,yl; } 
111e make_pair function makes the usc of pairs simplc. For example, hcrc is tllC 
outline of a function that retums a value and an error indicaLOr: 
pair<double,error_indicator> my_fcl(double d ) 
{ 
} 
erma = 0; 
/I clear ( -style global error indicator 
/I do a lot of computation involving d computing x 
error_indicator ee = errnOi 
crrno = 0; 
/I clear C-style global error indicator 
rcturn make_pair(x,ee); 
111is example of a uscful idiom can bc uscd like this: 
pair<inl,errorj ndicator> res = my_fct(123.456)i 
if (res.second==O) { 
/I use res.first 
} 
else { 
1/ oops: error 
} 
8.7 1/0 streams 
111C 110 stream library provides formaued and unformattcd buffered 1/0 of tcxt 
and numeric valucs. 111e definitions for I/O stream facilitics are found III 
<istream>, <ostream>, etc.; sce §B.l.l. 
An oslream converts typed objects to a stream of charaClers (bytes): 

S.7 
1/0 STREAMS 
Valucs Or various types 
Charactcr scqucnccs 
"Somc\vhere" 
(12,34) 
ostream 
Buffer 
An islream converts a strcam or characters (bytcs) to typed objects: 
Valucs or various types 
Character scqucnces 
"Somcwhere" 
(12,34) 
istrum 
BulTer 
An ioslream is a strcam that can act as both an islream and an oslream. The 
buffcrs in the diagrams arc "so-cam buffers" (sireambufs). Look them up in an 
expen-lcvcl tcxtbook ir you ever need to define a mappi.ng rrom an ioslream to a 
new kind or device, fUe, or memory. 
111cre are lhrce standard streams: 
Standard VO streams 
cout 
the standard character output (often by default a screen) 
cin 
the standard character input (often by default a keyboard) 
eerr 
the standard character error output (unbuffered) 
1125 

1126 
APP ENDIX B • STA NDARD LIBRARY SUMMA RY 
B.7.1 1/0 51 reams hierarchy 
An IUr\!lUn can be connected to an input device (c. g., a keyboard), a [de, or a 
lit ring. Similarly, an oslre:un ca.n be connected to an omplll device (c.g., a tcxt win-
dow), a me, or a slrlns. 111C 1/0 stream facilities are organizcd in a class hierarchy: 
istream 
os ....... 
istrin tream 
ifstream 
iostrearn 
ostrin tl'Nlll 
ofslrearn 
strin stream 
fstream 
A srrcam can be opened either by a constructor or by an oj,..!nO call: 
Siream types 
Ilrlngilltrlll\m(m) 
Make an empty string stream with mode m. 
IIlrlngIlIrCam(I,m) 
Make a string stream containing tiring I with mode m. 
'. lrcftmO 
Make a file stream for later opening. 
'1Ire;m(. ,m) 
Open file called i with mode m and make a file stream to refer 
to it. 
r.,opcn{i,m) 
r..I._opanO 
Open file called II with mode m and have 'l refer to it. 
Is r8 openr 
For me streams, the file name is a C·style string. 
You can open a file in one of several modes: 
Stream modes 
lo._baila! tltPp 
append (i.e., add to the end of the file) 
IOI_baSi!IIIIi! 
"at end" (open and seek to end) 
lo. _baiiel :blnary 
binary mode -
beware of system-specific behavior 
lu._bliliH :In 
for reading 
lo. _balit l :oul 
for writing 
lo._bAsall lrunt:: 
truncate file to 0 length 

n.7 
JlQ STR EAMS 
In each case, the exact effect of opening a me may depend on the operating sys-
tem, and if an operating system cannot honor a request LO open a me in a certain 
way, the result will be a stream that is not in the 8oodO Slate. 
An example: 
oi lrlng!ilrcant Oi; 
1/ 0 for ~UU")lI , H 
of8lre:ul1 of(ltmy_tIIl!lt); 
II (Iof) crror("couldn" ol,en ' n'y~fU e' for wrIHng"); 
n,y_colle(oli)l 
1/ usc .1 Mtlng 
my~code(ol) ; 
1/ usc dOle 
See § 11.3. 
0.7.2 Error handling 
An I08tream can be in one of four states: 
Stream slales 
goodl) 
I!of() 
,,111) 
b.dl) 
The operations succeeded. 
We hit end of inpu' ("end of file"'). 
Something unexpected happened (e.g., we looked fO( a digit and found '/1'1. 
Something unexpected and serious happened (e.g., disk read error). 
By using i,ll/lcaplloMiO, a programmer can request an Iuslream to throw an ex-
ception if it rulTIS from MooliO inLO anOlher state (see §1O.6). 
Any operation atlempLCd on a stream that is nOl in the goodO state has no ef-
fect; it is a "no op." 
An lo.lream can be used as a condition. In that case, the condition is lnle 
(succeeds) if ute stale of the IOitrm'm is good(). That is the basis for the common 
idiom for reading a stream of values: 
X III I/,In "Inpul buffer" (or huldllll:! une v,llue u( lypc X 
whllt! (c:ln»
/I) ( 
1/ du ~omc'h lnl:! whh x 
II we gCI hcre whcn » tcJuld.,'I re"d ,ulolhcr X (rum eln 
1127 

1128 
APPENDIX B • STANDARD LIBRARY SUMMARY 
B.7.3 Input operations 
Input operations arc found in <istream> except for the ones reading imo a siring; 
those arc found in <String>.: 
Formatted input 
in »
. 
getline(in,s) 
Read from in into x acc()(ding to . 's Iype. 
Read a line from in into the siring s. 
Unless Olhcnvisc stated, an istrcam operation retums a reference LO its istream, 
so that \ ... ·c Co:'11l "'chain" operations, for example, cin»x:» y; . 
Unformatted input 
x: in.getO 
in.get(c) 
in.gel{p,n) 
in.gcl(p,o,t) 
in.getline(p,n) 
in.gellinelp,n,t) 
in.read(p,n) 
x=in.gcountO 
Read one character from in and return its integer va lue. 
Read a character from in into c. 
Read al most n characters from in into the array starting at p. 
Read at most n characters from in into the array starting at Pi 
consider I a terminator. 
Read at most n characters from in into the array starting at P; 
remove terminator from in. 
Read at most n characters from in into the array starting at P; 
consider I a terminator; remove terminator from in. 
Read al most n characters from in into the array starting at p. 
)I is number of characters read by most recent unformatted input 
operation on in. 
TIle gelO and gellineO functions place a 0 at the end of the characters (if any) 
written to plOJ ... ; gellineO removes the tenninator (I) from the input, if found, 
whereas gelO docs not. A read(p,n) does not write a 0 to the array after the char-
acters read. Obviously, the fonnaued input operators arc simpler to use and less 
error-prone than the unformatted ones. 
B.7.4 Output operations 
Output operations are found in <oslream> except for the ones writing Out a 
Siring; those arc found in <SIring>: 

B.7 
IJO STR EAMS 
Output operations 
oul « 
/I 
Write /I to oul according to /I'S type. 
out.pul(t) 
Write the character t to out. 
out.wrhtl(p,n) 
Write the characters pI0) .. pln- 11 to out. 
Unless otherwise statcd, an 6I1ft!!u" operation returns a reference to its ollircam, 
so that we can "chain" operations, for example, Coui «x<<y; . 
8.7.5 Formatting 
"nle format of stream 110 is controlled by a combination of object type, stream 
state, locale information (see <locale» , and explicit operations. Chapters lO and 
L L explain much of this. Here, we just list the standard manipulators (operations 
modifying lhe stale of a stream) because they provide the most straightforward 
way of modifying fonnalling. 
Locales are beyond thc scope of this book. 
8.7.6 Standard manipulators 
TI1C standard library provides manipulators corresponding to the various fonnat 
states and state changes. The standard manipulators arc defined in <1011>, 
<I ~ tr tlam> , c08Ircam>, <Iostrcam>, and c lom3l'llp> (for manipulators that take 
arguments): 
va manipulators 
II<cboulnlphll 
Iccnoboolalpha 
Iccshowbaiitl 
• ccnOl howbaUi 
.ccilhowpolnl 
ilccnol howpolnl 
l«thowpo. 
Iccnoilhowl>OiI 
1» .klpWI 
8» no8klllWil 
Iccupptirc~ jj i! 
Use symbolic representation of trut! and tlll'tl (input and 
output). 
I.unillltt(loil_bailtl t I boolall)ha). 
On output prefix oct by 0 and htx by Ox. 
l.uni CltWol_bUut t .hOwballc) . 
Always show decimal point. 
I,Unl tltt(lo._b3Jtl! Ilhowl)olnt). 
Show + for positive numbers. 
l.unl lltt(lol _b3iitllllihowpOil). 
Skip whitespace. 
I,Uniltltf(lol_bau;lllklpWI). 
Use uppercase in numeric output, e.g., ·1.2E10 and OXIA2 
rather than 1.2tl10 and Oli 102. 
"29 

1130 
APPENDIX B • STANDARD LIBRARY SUMMARY 
VO manipulators (continued) 
s« no uppercase 
s<<internal 
s« le(t 
s« right 
s« dec 
s« hex 
s«ocl 
s<<iixed 
s<<scienlific 
s«endl 
s«ends 
s<<fIush 
P>W5 
s« resetiosflags(O 
s<<setiosflags(O 
s<<setbase(b) 
s<<setfill(c) 
s<<setprecision(n) 
s<<setw(n) 
x and e rather than X and E. 
Pad where marked in formatting pattern. 
Pad after value. 
Pad before value. 
Integer base is 10. 
Integer base is 16. 
Integer base is 8. 
Floating-point format dddd.dd. 
Scientific format d.ddddEdd. 
Put '\n' and flush. 
Put '\0' . 
Flush stream. 
Eal whitespace. 
Clear flags f. 
Set flags f. 
Output integers in base b . 
Make c the fill character. 
Precision is n digits. 
Next field width is n characters. 
Each of these operations returns a reference to its first (stream) operand, s. 
For example: 
coul « 1234« ',' « hex« 1234« ','« oct« 1234« endl; 
produces 
1234,4d2,2322 
and 
cout« 'I' «setw(4)« setrill('#')« 12« ") ( n «12« ")\n"; 
produces 
(##12) (12) 

B,B 
STRING MANIPULATION 
1'0 explicitly set the general output fonnat for floating-point numbers use 
b.setf(ios_base: :fmtflags(O), ios_base: :floatfieldl 
See Chapter I I. 
B.B String manipulation 
111e standard library offers character classification operations in <cctype>, 
strings with associated operations in <string>, regular expression matching in 
<regell> (C++Ox), and support for C-sryle suings in <cslring>. 
8.8.1 Character classification 
~n1 e characters from the basic execution character set can be classified like this: 
Charader classification 
isspace(c) 
isalpha(c) 
isdigil(c) 
isxdigil(c) 
isupper(c) 
islower(c) 
isalnum(c) 
iscntrl(c) 
ispunct(c) 
isprint(c) 
isgraph(c) 
Is c whitcspace (' " '\I', '\n', etc.)? 
Is c a reUer ('a' .. 'z', 'A',,'Z'J? (Note: not '_'.) 
Is c a decimal digit ('O' .. '9')r 
Is c a hexadecimal digit (decimal digit or 'a' .'f' or 'A' .. 'F')? 
Is c an uppercase lett err 
Is c a lowercase letterr 
Is c a leuer or a decimal digilr 
Is c a control character (ASCII 0 .. 31 and 127)? 
Is c not a letter, digit, whitespace, or invisible control character? 
Is c printable (ASCII ' ' .. '-')r 
Is c isalphaOlisdigitOlispunctO? (Note: not space.) 
In addition, the standard library provides two useful functions for getting rid of 
case differences: 
Upper and lower case 
toupper(c) 
c or c's uppercase equivalent 
lolower(c) 
c or c's 100vercase equivalent 
Extended character sets, sucl1 as Unicode, are supported but are beyond the 
scope of this book. 
1131 

1132 
APPEND IX B • STANDARD LIBRARY SU MMARY 
0.0.2 String 
The standard library string class, siring, is a specialization of a general string tem-
plate hi'!l IIrln8 for the character type ChAt; that is, IIrl"8 is a sequence of t hars: 
Siring operations 
1>-.2 
••• I:ttl() 
Ii.ltlnglh() 
I.C_IIfO 
li.beglnO 
l.tlndO 
8.ln.l.lrUpOI,II) 
8.al,p,md{p08,1I) 
1,~ 'aI8( p olI) 
l.pu8h_backtc) 
,.o8_ •• flnd(lI:) 
11'1»' 
Assign 82: to i ; 12 can be a string or a C-style string. 
Append II: at end of I ; .It can be a character, a sIring. or a C-style 
string 
Subscripting. 
Concatenation; the result is a new string with the chMacters from 
• followed by the characters from 12. 
Comparison of string values; 11 or ti2, but not both, can be a C-
style SIring. 
Comparison of Siring values; • or d , but not both, can be a C-
style stri ng. 
lexicographical comparison of string values; " or 12, but not 
both, can be a C-style string. 
l exicographical comparison of string values; • Of 12, bUI nOl 
both, can be a C-style string. 
lexicographical comparison of Siring values; l or 82, but not 
bolh, can be a C-style string. 
lexicographical comparison of string values; l or 82:, but not 
both, can be a C-style string . 
Number of charactCfS in 8. 
Number of characters in •. 
e-style string version (zero terminated) of characters in I . 
Iterator to first character. 
Iterator to one beyond the end of •. 
Insert II before ' Ipo.); II can be a character, a string, or a C-style 
string. 
Insert JI after Ilpo.); II can be a character, a string.. or a C-style string. 
Remove the character in ,11'011. 
Append the character C. 
Find JI in .; II can be a character, a string. or a C-style string; P(U 
is the index of the first character found, or "POI (a position off 
the end of i l. 
Read a word inlo . from In. 

B.8 
STRING MAN IPULATION 
B.0.3 Rcgular c~prcll ion matching 
Thc rcgular cxprcssion library is not yct part or the standard library, but it will 
soon be and it is widely availablc, so wc list it hcrc. Sec Chapter 23 ror morc dc-
tailed explanations. TI1C main cre8"I(> runctions arc 
Searchi1lg ror a string that matches a regular exprcssion in an (arbitrarily 
long) stream or data - supported by rft8Cli_,etirc:hO 
Matching a rcgular expression against a string (or known sizc) - sup-
ported by rCSCI( Jtl31ChO 
ReplacCIlumt or matchcs - supported by r"scli terJlilc:e(); not described in 
tlus book; see an expert-level text or manual 
TI1C result or a ,eSOli jeatc:hO or a tcg"" malc:hO is a collcction or matches, typi-
cally represented as an , ltuHch: 
rliSli" row( HI\I\\W I+{ 
IId.)( IId.1( IId.)$")1 
wllllll (golllnll{ln,lIntl)) { 
II t.hcdc d.11.1 lint! 
,m;}fch matches I 
If (In)se,, Jtlatch(lInc, miuchcj, row)) 
crror("bad IInc" I UncnO)1 
1/ ChlXk ruw: 
Inl floldl . lrol11 Ilrlnsclnl>(nUHChoI11 ))! 
IMI flcld2. frOM'_lltlnsclnl>(matchti,ll ll l 
Inlfleld3. (rOlu_llrlnsclnl>(nlIlIChcI13J)1 
/I , , , 
rnlC syntax or rcgular cxpressions is based on characters with special meaning 
(Chaptcr 23): 
Regular expression special characters 
I 
• 
• 
any single character (a uwildcard") 
character class 
count 
begin grouping 
end grouping 
next character has a special meaning 
zero or more 
one or more 
1133 

1134 
APPENDIX B • STANOARD LIBRARY SUMMARY 
Regular expression special characters (continued) 
l 
$ 
Repetition 
( n ) 
( n, ) 
(n,m) 
+ 
l 
optional (zero or one) 
ahernative (or) 
start of line; negation 
end of line 
exactly n times 
n or more times 
at least n and al most m times 
zero Of more, that is, to,} 
one or more, that is, {I,} 
optional (zero or one), that is (O,l ) 
Character classes 
alnurn 
alpha 
blank 
cntrl 
d 
digit 
graph 
lower 
print 
pund 
, 
space 
upper 
w 
"digit 
any alphanumeric character or the underscore 
any alphabetic character 
any whitespace character thaI is not a line separator 
any control character 
any decimal digit 
any decimal digit 
any graphical character 
any lowercase character 
any printable character 
any punctuation character 
any whilespace character 
any whitespace character 
any uppercase character 
any word character (alphanumeric characters) 
any hexadecimal digit character 

0.9 
NUMERI CS 
Several character classes are supported by shorthand notation : 
Charader class abbrevialions 
III 
a decimal digit 
lI,dlglllll 
~ 
a lowercase character 
II I lowtirt 11 
" 
a space (space, lab, elc.) 
Ul8paftliU 
Iu 
an uppercase character 
Ifl1lfJpat ill 
Iw 
a letter, a decimal digit, 0( an underscore Cl 
II hlll1l1m lll 
III 
not \d 
1' 111/1811'11 
11 
not \I 
[AlllowClfllI 
IS 
not \!! 
1"(u pltc:tHII 
IU 
not \u 
IAlluPPCirtlJ 
IW 
nol \w 
l"IHtlnllmlll 
B.9 Numerics 
"n e c++ standard librmy provides the most basic building blocks for mathemat· 
ical (sciemific, engincering, elc.) calculations. 
B.9.1 Numcricailimiis 
Each C++ implementation spccifies properties of the built·in types, so that pro· 
grammers C'1n usc those properties to cl1eck against limiLS, set sentincls, etc. 
From <lltnll8>, we get 1111nlerlcJlmili <1> for each built-in or library type T. 
In addition, a programmer can define numeric Ilmlli<X> for a user·defmed nu· 
meric type X. For example: 
cia:,. nume,' J" .. Ilhic floal> { 
I)ublici 
' IMlc coni l boollj_i pl.lclalll{!d • "U{!J 
, Ialic (on lll Itll rAdii, . 2; 
If b.1M.! o( CKlxJftcnt (hI thl ~ t t.lM.', blllJry) 
. lililc cOl1jl Inl dlghi • 24; If nUfni:lcr or t.ltll>: dll!1t~ In nhllltlu.1 
j Ulllc onllllni dlglli10 . 6, If numher or b.l§c· 1 0 digits 111 rtll1tlllss,1 
j lililc con81 booll!l_i lg"tld • lruell 
italic eM 81 bfu.lII!lJnltgt f . (A l u~, 
8liulc con81 bool1 8~l! lIIe l • (alie, 
1135 

1136 
); 
APP ENDIX B • STANOARD LIBRARY SUMMARY 
static float minO { return 1.17549435E-38F; } 
static float maxO { return 3.40282347E+38F; } 
/I example value 
"example value 
static float epsilonO { relurn 1.19209290E-07F; } 
static float round_crrorO { return O.5F; } 
'I example value 
II example value 
static float inrinityO { return ,- some value -I; } 
slatic float quieCNaN (} { return ,- some value -I; } 
static float signaling.,NaN(} { return ,- some value -I; } 
sialic float denorm_min(} { return minO; } 
static consl int min_exponent = -125; 
static consl int min_exponent10 = -37; 
static consl int max_exponent = +128; 
slatic const inl max_exponenltO = +38; 
static const bool hasj nfinity = true; 
slatic const bool has_quieCNaN = true; 
static const bool has_signaling.,NaN = true; 
/I example value 
/I example value 
/I example value 
/I example value 
static consl floaCdenorm_style has_denorm = denorm_absent; 
static consl bool has_denorm_loss = false ; 
static const bool isjec559 = true; 
static consl bool is_bounded = true; 
static consl bool is_modulo = false; 
slatic consl boollraps = Iruc; 
/I conforms to IEC·559 
static const bool tinyness_bcfore = true; 
From <Iimils.h> and dloat.h>, we gel macros specifying key properties of inte' 
gers and floating·point numbers, including: 
limit macros 
CHAR_8IT 
CHAR_MIN 
CHAR_MAX 
number of bits in a char (usually 8) 
minimum char value 
maximum char value (usually 127 if char is signed and 255 if 
char is unsigned) 
smallest int value 
largest int value 

8.9 
NUMERICS 
Limit macros (continued) 
LONG_MIN 
LONG_MAX 
FLY_M IN 
FLY_MAX 
FLY_DIG 
FLT_MAX_10_EXP 
D8L_MIN 
DOL_MAX 
DBL_EPSILON 
smallest int value 
largest int value 
smallest positive float value (e.g., 1.175494351 e-38F) 
largest float value (e.g., 3.402823466e+38F) 
number of decimal digits of precision (e.g., 6) 
largest decimal exponent (e.g., 38) 
smallest double value 
largest double value (e.g., 1.7976931348623158e+308) 
smalleslsuch IhaI 1.0+D8L_EPSILON! = 1.0 
B.9.2 Standard mathematical functions 
'111C standard library provides the most common mathematical functions (de-
fined in <cmath> and <complex» : 
Standard mathematical functions 
abs(x) 
ceil(x) 
floor(x) 
sqrt(x) 
cos(x) 
sin(x) 
tan(x) 
acos(x) 
asin(x) 
alan(x) 
sinh(x) 
cosh(x) 
lanh(x) 
exp(x) 
log(x) 
log10(x) 
absolute value 
smallest integer >= x 
largest integer <= x 
square root; x must be nonnegative 
cosine 
sine 
tangent 
arccosine; result is nonnegative 
arcsine; result nearest to 0 returned 
arctangenl 
hyperbolic sine 
hyperbolic cosine 
hyperbolic tangent 
base-e exponential 
natural logarithm, base-e; x must be positive 
base-l0 logarithm 
1137 

1138 
APPENDIX B • STANDARD LIBRARY SUMMARY 
There are versions taking flOi't. doublQ. 10118 double, and c:on1J)IQ. arguments. 
For each function, the return type is t.he same as the argument type. 
If a standard mathematical function cannot produce a mathematically valid 
result, it sets the variable errno. 
B.9.3 Complex 
The standard library provides complex number types C:OmphHccfloilt>. eom-
I)ltlJlcdoubl@>, and c:oml)lell<lons double>. A C:ORlplelCcSe.illilF> where SC:ith., is 
some other type supporting lhc lISUal arithmetic operations usually works but is 
not guaranteed to be portable. 
lenll)lillecdil!i!i SC:illilr> clit~1i eOml)hl. { 
/I iI cOmplll\; 1, il pair flf ~({l l ilf vil l ~WIi , 1 ~1i l{:i\ lI y il cO(Jrdlniltn pllir 
StilllU re, Illll 
I,·bll., 
c:ompIQx(c;:on!l1 !leillil," r, t oniit SCJlilf &- I) Ire(r). 1",(1) () 
compIQ/II(cOn!i1 Seithn " rl I ' Q (r),lm (Se~ ID r ()) ~) 
eo m~lt,!Jl() tr@(S@litf()), hn(SeDIDr ()) () 
Seiliu rVilO ( r@tufI1 rQI ) 
SeDI", Imil8() ( ,@1urn 1m. ) 
1I11'Il i PMt 
II h1lilj\hwy ptH! 
Ii olwratofl'::: t '" ... ", 4", I"" 
), 
In addition to the members of complex, Ce0I111)IQ olfers a host of useful operations: 
Complex operators 
11-+1l1 
,1- lll 
11·1:1 
11/1:1 
,"lu ll 
lllw;d 
nOrm(l) 
«lolt·I 
IJOltu(K,yl 
f@ill(ll 
addition 
subtraction 
multiplication 
division 
equality 
inequality 
the square of ib§(l) 
conjugate: if I is (f@,lm) then COHJ(I) is (rQ,- lm) 
make a complex given polar coordinates (rho,theta) 
real part 

B.9 
NUMERICS 
Complex operators (confinued) 
imag(z) 
imaginary part 
abs(z) 
also known as rho 
arg(z) 
also known as theta 
out « z 
complex output 
in »
z 
complex input 
TIle standard mathematical functions (see §B.9.2) arc also available for complex 
numbers. Note: complex does not provide < or %; sec also §24.9. 
B.9.4 valarray 
TIle standard valarray is a single-dimensional numerical array; that is, it provides 
arithmetic operations for an array type (mudl as Matrix in Chapter 24) plus sup-
port for slices and stridcs_ 
B.9.5 Generalized numerical algorithms 
11lese algorithms from <nume ric> provide general versions of common opera-
tions on sequences of llulllelic;i1 values: 
Numerical algorithms 
x = accumulate(b,e,i) 
x = accumulate(b,e,i,O 
x = inne' _producl(b,e,b2,i) 
x = inner_product(b,e,b2,i,f,f2) 
p=partia'-su m(b,e,out) 
p=partiaCsu m (b,e ,out,O 
p=adjacent_ d ifference(b ,e,out) 
p=adjacenCdifference(b ,e,ou t, 0 
x is the sum of i and the elements of [b: e)_ 
Accumulate, but with f instead of +_ 
x is the inner pnxluct of [b:e) and Ib2:b2+(e-b)), 
that is, the sum of i and (· pl)·(· p2) for all pl 
in [b:e) and all corresponding p2 in 
Ib2:b2+(e-b». 
inner_producl, but with f and f2 instead of + 
and *, respectively. 
Element i of loul :p) is the sum of elements O.i 
of [b:e). 
partial_sum, using f instead of +. 
Element i of lout:p) is *(b+i)-*(b+i-l ) for i>l; 
if e-b>O then ·out is *b. 
adjacent_difference, using f instead of - . 
1139 

" 4<1 
APPENDIX B • STANDARD LIBRARY SUMMARY 
B.10 C standard library functions 
~nc standard library for the C language is with very minor modifications incor-
porated into the C++ standard library. TIle C standard library provides quite a 
few functions that have proved lIseful over the years in a wide variety of contexts 
- especially for relatively low-level programming. Here, we have organized them 
into a few conventional categories: 
C-style I/O 
C-stylc strings 
Memory 
Date and time 
Etc. 
There are more C standard library functions than we present here; sec a good C 
textbook, such as Kernighan and Ritchie, The C Programming Lal/gl/age (K&R), if 
you need to know mort. 
B.l0.l File. 
The <Ci ldlo> 110 system is based on "mes." A me (a flU· ) can refer to a file or lO 
one of the standard input and output streams, i tdln, i ldoul, and litthm. l1le 
SlaJldard streams are available by default; Olher files need to be opened : 
File open and close 
f. rOIH!Il(I.m) 
I"deloi@U) 
Open a file stream for a file named i with the mode m. 
Close file stream f; return 0 if successful. 
A "mode" is a string containing one or more directives specifying how a me is to 
be opened: 
File modes 
"r" 
reading 
"w'! 
writing (discard previous contents) 
" ilft 
append (add at end) 
",." 
reading and writing 
"w+" 
reading and writing (discard previous contents) 
"bl! 
binary; use together with one or more other modes 

B.IO 
C STAN DARD LIBRARY FUNCTIONS 
'1lcrc may be (and usually are) more options on a specific system. Some options 
can be combined; for examplc, tnlnm("too", "rb") tries to open a file c:.-tllcd too for 
binary reading. TIle 110 modes should be the same for stdio and 1 00i tr~a lU S (§B.7.1) 
0.10.2 The prln!lO (~mlly 
111C most popular C standard library functions are the 1/0 functions. However, 
wc recommend IOlilre"llls because that library is type safe and extensible. The 
fonnatted output function, ,Jrintf(), is widely used (also in C++ programs) and 
widely imitated in other programming languages: 
1),Io!' 
n · l) rlnl r('m! ,it rK~ ) 
Print the "format string" fml to Ildou! inserting the 
arguments afSIi as appropriate. 
Print the "format string" rOll to file r, inserting the arguments 
a,s, as appropriate. 
Printlhe "formal string" 'mi lo the (-style string I , inserting 
the arguments ' fIJIi as appropriate. 
Fo r each version, n is the number of characters written or a negative number if 
the omput failed. The rclllrn value from prlnttO is essentially always ignored. 
l1le declaration of 1l,lntfO is 
InIIJflntf{cOI1li1 clllar· formill ",)1 
In other words, it takes a C·slylc string (typicaJly a string literal) followed by an 
arbitrary number of arguments of arbitrary type. 111e meaning of those "extra 
arguments" is controlled by conversion specifications, such as !)t,c (print as char· 
acter) and 'l'Ld (print as decimal integer), in the fonnat string. For example: 
Inl x • Sl 
conlil I;;hi" · I) !IIi "Aidf", 
,Hh,U("lhe v"IYe ot III Iii '')IJd' iIlnd Ihe VAIYQ or Ii Is '''''i,,"'' , X, ~ ) I 
A character following a % eOlllrols the handling of an argument. ~nle first % ap-
plies to the first "extra argument" (here, ~,d applies to x), the second % to the sec-
ond "extra argumenl" (here, %! applies to Ii), and so 0 11. In particular, the outpUl 
of that call to IHlnlt() is 
followed by a newline. 
1141 

1142 
APPENDIX B • STANDARD LIBRARY SUMMARY 
In general, the correspondence between a % conversion directive and the 
type to which it is applied cannot be checked, and when it c.'l.n, it usually is not. 
For example: 
printf("the value of x is '%5' and the value of s is '%d'\n",x,s); 
II oops 
The set of conversion specifications is quite large and provides a great degree of 
nexibility (and possibilities for confusion). Following the %, therc may be: 
an optional minus sign that specifics left adjustment of the conven ed 
value in the field. 
+ an optional plus sign that specifics that a value of a signcd type will al-
ways begin with a + or - sign. 
o an optional zero that specifics that leading zcros arc used for padding of 
a numeric value. If - or a precision is specificd, this 0 is ignored. 
# 
an optional # that specifics that floating-point values will be printed with 
a decimal point evcn if no nonzero digits follow, that trailing zeros will be 
printed, that OCtal valucs will be printed with an initial 0, and lhat hexa-
decimal values will be printed with an initial Ox or OX. 
d an optional digit string specifying a field width; if the conven ed value 
has fewer characters than the field width, it will be blank-padded on the 
left (or right, if the left-adjustment indicator has been given) to make up 
the field width; if the field width begins with a zero, zero padding will be 
done instead of blank padding. 
an optional period that serves to separate the field width from the next 
digit string. 
dil an optional digit string specifying a precision that specifics the number of 
digits to appear after the decimal poi.nt, for e- and f-conversion, or the 
maximum number of characters to be printed from a string. 
• a field width or precision may be • instead of a digit string. In this case, 
an integer argument supplies the field width or precision. 
h an optional character h, specifying that a foUowing d, 0 , x, or u corre-
sponds to a short integer argument. 
an optional character I (the letter I), specifying that a following d, 0 , x, or 
u corresponds to a long integer argument. 
L an optional character L, specifying thal a following e, E, g, G, or f corrc-
sponds to a long double argument. 
% indicatiJlg that the character % is to be printed ; no argument is used. 

6.10 
C STANDARD LIBR ARY FUNCT IONS 
c a character t.hat indicates the type of conversion LO be applied. l 11e con· 
version characters and their meanings are: 
d TIle integer argument is converted to decimal notation. 
"I1le integer argument is converted LO decimal notation. 
o The integer argument is converted to OCtal notation. 
x The integer argument is converted to hexadecimal notation. 
X The integer argument is converted to hexadecimal notation. 
TIle float or double argument is converted to decimal notation in 
the style (-Jddd.ddd. The number of d's after the decimal point is 
equal to the precision for the argument. If necessary, the number is 
rounded. If the precision is missing, six digits are given; if the preci-
sion is explicitly 0 and # isn't specified, no decimal point is primed. 
e "I1le float or double argument is converted LO decimal notation in 
the scientific style (-Id.dtide+dd or (- Id.ddde-dd, where therc is one 
digit before the decimal point and the number of digits aftcr the dec-
imal point is equal to the precision specification for the argument. If 
necessary, the number is rounded. If the precision is missing, six dig-
its are given; if the precision is explicitly 0 and # isn't specified, no 
digits and no decimal point are printed. 
E
As e, but with an uppercase E used 10 idemify lhe exponent. 
g TIle float or double argument is printed in style d, in style r, or in 
slyle e, whichever gives the greatesl precision in minimum space. 
G As S' but Wilh an uppercase E used 10 idemify the exponelll. 
c TIle character argument is printed. Null characters are ignored. 
s TIle argument is taken to be a string (character pointer), and charac-
ters from the string are printed until a null character or until the 
number of characters indicated by the precision specification is 
reached; however, if the precision is 0 or missing, all characters up to 
a null arc printed. 
p TIle argument is taken to be a pointer. TIle representation printed is 
implementation dependent. 
u 111e unsigned integer argument is converted to decimal notation. 
n 11le number of characters written so far by lhe caU of printf(), 
fprintfO, or sprinlfO is written to the int pointed 10 by the pointer to 
int argument. 
In no case docs a nonexistent or small field width cause truncation of a 
field; padding takes place only if the specified field width exceeds the ac-
tual width. 
1143 

1144 
APPENDIX 8 • STANDARD LIBRARY SUMMARY 
Because C docs not have user-dcHncd types in the sense that C++ has, there afC 
no provisions for dcfming Output fannats for user-defined types, such as cOlUplex, 
vector, or tiring. 
Tne C standard output, 8ldoul. corresponds to coul. The C standard inplll, 
, Idln, corresponds to cln. The C standard error output, ' td tln, corresponds to 
cerro TIus correspondence between C standard I/O and C++ 110 streams is so 
close that C-style 110 and I/O streams can share a buffer. For example, a mix of 
('oul and sidoul operations can be used to producc a single output stream (that's 
not uncommon in mixed C and C++ code). 11lis flexibility carries a cosl. For 
better perfomlancc, don't mix sldio and lost ream operations for a single stream 
and call iOfl~ba fl e :;l yn c~wllh_' tdi o(fa l , ) before the first 110 operation. 
TIle stdio library provides a function, IcanfO, that is an input operation with 
a style that mimics ,)rlnItO. For c.'(ample: 
Inl x; 
chit' . lbuClll7.:el; 
Inl l _ sCltnWthe value of x Is '%d' Imet Ihe v~ lu e 01 , Is '%o,'\n" ,&X,I); 
Here, ,canfO tries to read an integer into x and a sequence of non-whitespace 
characters into . Non-format characters specify that the input should comain 
that characler. For example, 
Ihe y"hle of x hi '123' and the Yl1lue of Ii III 'Itrlns '\n" 
will read 12:1 into x and , trlnR foUowed by a 0 into I. If the call of ' CD I1f() succeeds, 
the result vallie (I in the call above) will be the number of argument pointers as· 
signed to (hopefully 2 in the example); otherwise, EOF. This way of specifying 
input is error-prone (e.g., wbat would happen if you forgot the space after III rinK 
on that input line?). All arguments to ,u nto must be pointers. We strongly rec-
ommend against the usc of ,canfO. 
So what c. ... n we do for input if we arc obliged to lise stdio? One popular an· 
swer is, "Usc the standard library function selsO": 
/I wry diln"(,rou~ emit': 
ch"r IilbuC,llel; 
char- IJ _ Rell(' " 
/I reild il line 11\10 s 
The call I}- Ket' (I) reads dlaracters into , until a newline or an end of file is ell-
countered and a 0 character is placed after the last character written to Ii. If an 
end of file is encountered or if an error accun'ed, p is set to NUI.L (that is, 0); 

B. 1 0 
C STANDARD LIBRARY FUNCTIONS 
otherwise it is SCt to s. Ncver usc gets(s) or its rough equivalent (scanf(""Ios",s))! 
For years, they werc thc favoritcs of virus writers: by providing an input that 
overflows thc input buffer (s in the example), a program can bc corrupted and a 
computer potcntially taken over by an attacker. Thc sprintfO function suffers 
similar buffer·overflow problems. 
111e stdio library also providcs simplc and useful charactcr read and write 
functions: 
sldio characler funclions 
x=getc(st) 
x=pulc(c,sl) 
x=getchar() 
x=pulchar(c) 
x=ungetc(c,st) 
Read a character from input stream sl; return the characters integer 
value; x==EOF if end of file or an error occurred. 
Write the character c to the output stream 51; return the integer 
value of the character written; x==EOF if an error occurred. 
Read a character from stdin; return the character's integer value; 
x==EOF if end of file or an error occurred. 
Write the character c to stdoul; return the integer value of the 
character written; x==EOF if an error occurred. 
Put c back onto the input stream st; return the integer value of the 
character pushed; x==EOF if an error occurred. 
Note lhat the result of these functions is an int (not a char, or EOF couldn't bc rc· 
turned). For example, this is a typical C·style input loop: 
inl Chi ,. not char ch; -, 
while «ch=getchar())!=EOF) {' . do something O, } 
Don't do two consccutivc ungetchOs on a stream. '11C rcsult of that is undefincd 
and (therefore) non·pOItablc. 
'11ere arc lUore stdio functions; sec a good C tcxtbook, such as K&R, if you 
nced to know more. 
8.10.3 C-slyle slrings 
A C·stylc string is a zcro-terminated array of char. This notion of a string is sup-
poncd by a set of functions defined in <cstring.> (or <slring.h>; note: 111)/ <string.» 
and <csldlib>. '11cse functions operate on C·style strings through char· pointers 
(canst char· pointers for mcmory that's only read): 
1145 

"46 
APPENDIX B • STANDARD LIBRARY SUMMARY 
C-style string operations 
• _,Irlan(,) 
p_'lrcpy(",:Z) 
p_'lrCIt(".:I) 
x.,lrCm,)(I, , 2) 
p.,lrncpy(t,t:Z, nJ 
p.,lrnc.I(M2,n) 
•• , lrnc:mp(I,.2,n) 
p_'lrchr("c) 
p.,trrchr(l,c) 
p.,I,. 'r("iZ) 
p.'lrpbrk(",2) 
lI_alof(,) 
• _.101(.) 
,,_alol(.) 
1I.,lrIOd(" p) 
Count the characters (excluding the terminating 0) . 
Copy d into I; 1':II+n) and 1. 2112+") may not overlap; p.'; 
the terminating 0 is copied. 
Copy , 2 onto the end of I; ,,_,; the terminating 0 is copied. 
Compare lexicographically: if IcJ2 then II is negative; if •••• 2 
then •• .0; if p.2 then li is positive. 
IIrCPY; max n characters; may fail to copy terminating 0; p.,. 
, Irclt; max n characters; may fail to copy terminating 0; p_'. 
. lrCmp; max n characters . 
Make p point to Ihe first c in •. 
Make p point 10 the last c in I. 
Make p point 10 the first character of , that starts a substring 
equal to . 2. 
Make p point to the first character of I also found in i l . 
Extract a double from •. 
Extract an Inl from j . 
Extract a long Inl from , . 
Extract a double from Ii set I' to the first character after the 
doublet. 
Extract a long Inl from Ii set p to the first character afler the 
long. 
Extract an unllsned lon8 1nl from I; set p to the first character 
afler the Ions. 
Note that in C++, ' tn:hrO and Ilrtll' O arc duplicated to make lhem type safe (they 
can't tum a con,l cha,· into a Chl1f· the way the C equivalents can); see also §27.5. 
An extraction function looks into its C·style string argument for a conven· 
lionally formatted representation ofa number, such as "12411 and II 1.4". lf no 
such representation is found, the extraction function retums O. For example: 
Int I{ . alol(llfortytwo"); 
B.l0.4 Memory 
"Ine memory manipUlation functions operate on "raw memory" (no type known) 
through void· pointers (con81 void· pointers for memory that's only read): 

IUO C STANDARD LIBRARY FUNCTIONS 
C-slyle memory operations 
q_memmovc(p,p2,n) 
lI_mement pip, I):/:,n) 
q_mcmehr(p,(,n) 
I)_ealloe(n,.) 
free(pl 
Copy n bytes from p2 to p (like flrcpy); [p:p+n) and 
Ip2: p2+n) may not overlap; (I- P. 
Copy n bytes from p2 to p; (,_p. 
Compare n bytes from p2 to the equivalenl n bytes from I) 
(like Ilremp). 
find e (converted 10 an un81gned char) in pI01 .. pln- 1) and 
lei q point to that element; q.o if c is not found. 
Copy c (converted to an un"gncd char) into each of 
1)IO) .. ln- 11; (,-p. 
Allocate n-, bytes initialized to 0 on free store; 1)-0 if n-, 
bytes could not be allocated. 
Allocate l uninilialized bytes on free store; p_O if I bytes 
could not be allocated. 
Allocate I bytes on free store; p must be a pointer returned 
by maliocO or e.tllocO; if possible reuse the space poinled 
to by p; if thaI is not possible copy all bytes in the area 
pointed to by p to a new area; q- O if . bytes could not be 
allocated. 
Deallocate the memory pointed 10 by p; p must be a 
pointer returned by malloe(), calloeO, or realloeO. 
Note that maliocO, etc. do not invoke constructors and heeO doesn't invoke de· 
st.ructors. Do not usc these functions for types with constructors or destructors. 
Also, m tlm ~e t () should never be used for any type with a constructor. 
TIle mem'" functions are found in «lit ring> and the allocation rUllctions in 
<cUclllb>. 
See also §27.5.2. 
8.10.5 Date and time 
In <clime>, yOli can find several types and runctions related to date and time. 
Date and lime Iypes 
IImtU 
1m 
an arithmetic type for holding short ti me intervals (maybe just intervals 
of a few minutes) 
an arithmetic type for holding long time intervals (maybe centuries) 
a , Iruel for holding date and time (since year t 900) 
1147 

1148 
APPENDIX B • STAN OARO LIBR ARY SU MMAR Y 
slruct 1m is defined like this: 
slruct 1m { 
J; 
int 1m_sec; 
1/ second of minute [0:61 I; 60 and 61 represent leap seconds 
int 1m_mini /I minute of hour [0,591 
int 1m_hour; 1/ hour of day 10,231 
int Im_mday; 1/ day of month 11,31 J 
int Im_mon; /I month of year (0,111; 0 means January (note: not [1 : 121) 
int 1m_year; 1/ year since 1900; 0 means year 1900, and 102 means 2002 
int tm_wdaYi 1/ days since Sunday 10,6]; a means Sunday 
int Im_yday; /I days since January 1 [0,3651; 0 means January , 
int tmjsdslj /I hours of Daylight Savings Time 
Date and time functions: 
clock_1 dockO; 
II number of clock ticks since the start of the program 
lime_t time(time_t- pi); 
1/ CUffent calendar time 
d ouble diiftimeUime_t 12, time_t 11 ); 1112- 11 in seconds 
1m· locaUime(consl time_l- pI); II local time for the ·pt 
Im* gmtime (consl lime_I· pt); II Greenwich Mean Time (GMn tm for 'Pt, or 0 
lime_t mktime(tm* ptm); 
char· asctime(const tm· plm); 
II C-style string representation for ·ptm 
char· clime(consl time_l- I) ( relurn asclime(iocallime(t)); ) 
An example o r the result or a call o r asclime() is "Sun Sep 16 01 :03:52 1973\0". 
H ere is an example or how clock can be used to time a runction (do_some-
thing()): 
int main(int argc, char- argv[]) 
{ 
inl n = aloi(argv[l l); 
clock_I t1 = clockO; 
/I start time 
if (tl == clock_t{- l )) ( 
II clock_t(- I) means "clockO didn't work" 
cerr « "sorry, no dock\n"; 
exit(1); 

B.IO 
C STANDARD LIBRARY FUNCTIONS 
) 
for (int i = 0; i<n; i++) do_somelhing(); 
/I timing loop 
clock_t 12 = clock(); 
II end time 
if (12 == clock_t{-1)) { 
cerr « "sorry, clock overflow\n"; 
exiI(2); 
cout« "do_something() " «
n « " times took " 
«
double(t2-I1)1ClOCKS_PER_SEC« " seconds" 
« " (measurement granularity: " «CLOCKS_PER_SEC 
« " of a second)\n"; 
"111C explicit conversion double(t2-I1) before dividing is necessary beC<"lusc 
clock_1 might be an integer. For values t1 and t2 returned by clockO, double(t2-
11)/ClOCKS_PER_SEC is lhe system's best approximation of the time in seconds 
between the two c .. l.ils. 
If clockO isn't provided for a processor or if a time interval was too long to 
measure, clockO retums clock_t(-1). 
B.l0.6 Etc. 
In <cstdlib> we Hnd: 
Etc. stdlib (unclions 
aborlO 
exil(n) 
sysfem(s) 
qsorl(b,n,s,cmp) 
bsearch(k,b,n,s,cmp) 
d=randO 
srand(d) 
Terminate the program "abnorma ll y.~ 
Terminate the program with value n; n==O means 
successful termination. 
E)(ecute the C·style string as a command (system 
dependent). 
Sort array starling at b with n elements of size s using the 
comparison function cmp. 
Search for k in the soned array starting at b with n elements 
of size s using the comparison funClion cmp. 
d is a pseudo-random number in the range 
IO:RAND_MAX]. 
Start a sequence of pseudo·random numbers using d as the 
>Oed. 
1149 

1150 
APPENDIX B • STAN DARD LIBRARY SUMMARY 
TIle compmison function (emil) used by <IsoriO and btlcarch() must have the type 
In' ("Cnl,J)(cunlt void" p, ( ontlt void" q)i 
111<lt is, 110 type infonnatioll is known to the sOrt funclion that simply "sees'" its 
array as a sequence of bytes. The integer returned is 
Negative if "Jl is considered less than "'I 
Zero if · p is considered equal to "q 
Positive if ",) is considered greater than "(' 
ate that eJcll() and "bortO do not invoke destructors. If you want destructors 
called for constructed automatic and static objects (§A.4.2), throw an exception. 
For morc standard library functions sec K&R or some other reputable C lan-
guage reference. 
B.11 Other libraries 
Looking through the standard library facilities, you'll undoubtedly have failed to 
find something you could use. Compared to the challenges faced by program-
mers and the number of libraries available in the world. the C++ standard li-
brary is minute. 111ere are many libraries for 
Graphical user interfaces 
Advanced math 
Database access 
Networking 
XML 
Date and time 
Ftle system manipulation 
3D graphics 
Animation 
Elc. 
However, such libraries are not part of the standard. You c.'1n find them by 
searching the web or by asking friends and colleagues. Please don't get the idea 
thal the only useful libraries are those that are part of the standard library. 

· .t ,. C 
Getti ng Started with 
Visual Studio 
"The universe is not only queerer 
than we imagine, 
it's queerer than we can imagine." 
-J. B. S. Haldane 
T
his appendix CXp11li1l1l Ihe steps YOII have to go 1-hrough to 
tiller a pl'ogr:lm. compile it, and have it !'till using MicrOHort 
Visual Srudio. 
1151 

1152 
APPENDI X C • GETTING STARTED W IT H VI SUAL 5TUDIO 
C.l Gelting a program to run 
C.2 Installing Visual Studio 
C.3 Creating and running a program 
C l .1 Create a new project 
( .l.2 Use the std_lib_facililies.h header 
file 
Cl.l Add a C++ source file to the 
project 
C.l .4 Enter your source code 
Cl.S Build an executable program 
C l .6 b ecute the program 
Cl.7 Save the program 
C.4 later 
C.l Getting a program to run 
To gCt a program to run, you need to somehow place the files together (so that 
when a filc refers to another - e.g., your source me refers to a header file - it 
finds it). YOli then nced to invoke the compiler and the linker (if nothing else, 
then to link to thc C++ standard library), and finally you need to run (execute) 
the program. 111cre are several ways of doing that, and different systems (e.g., 
Windows and Linux) have differcm conventions and tool sets. However, you can 
nm all of the examples from this book on all major systems lIsing any of the 
major tool sets. This appendix explains how to do it for one popular system, Mi· 
crosoft's Visual Studio. 
Personally, we find few exercises as frustrating as getting a first program to 
work on a new and strange system. 111is is a task for which it makes sense to ask 
for help. However, if you do get help, be sure lhat the helper teaches you how to 
do it, rather than just doing it for yOLl. 
C.2 Installing Visual Studio 
Visual Studio is an interactive development environment (I DE) for Windows. If 
Visual Studio is not installed on your computer, you may purchase a copy and 
follow the instructions that come with it, or download and install the free Visual 
C++ Express from www.microsoft.comlexpress/down1oad.l1Ie description here 
is based on Visual Studio 2005. Other versions may differ slightly. 

C.3 
CREATING AND RUNN ING A PROGRAM 
C.3 Creating and running a program 
The steps arc: 
1. Create a new project. 
2. Add a C++ source file to the project. 
3. Enter your source code. 
4. Build an executable fIle. 
5. Execute the program. 
6. Save the program. 
C.3.1 Cre~tc ~ new project 
In Visual Studio, a "project" is a collection of files that together provide what it 
takes to create and run a program (also called an apj)/ication) under Windows. 
I. Opcn the Visual C++ IDE by clicking the Microsoft Visual Studio 2005 
icon, or select it from Start > Programs> Microsoft Visual Studio 
2005 > Microsoft VISUal Studio 2005. 
2. Open the File menu, point to New, and click Project. 
3. Under Project Types, select Visual C++. 
4. In the Templates section, select Wm32 Console Application. 
5. In the Name text box type the name of your project, for example, 
Hello,World!. 
6. Choose a directory for your project. The default, C:\Documents and 
Scttings\Your Name\My Documents\Visual Studio 2005 Projects, is 
usually a good choice. 
7. Click OK. 
8. TIle WIN32 Application Wizard should appear. 
9. Select Application Settings on the left side of the dialog box. 
10. Under Additional Options select Empty Project. 
II . Click Fmish. All compiler settings should now be initialized for your 
console project. 
C.3.2 USC the stdJ lb_lacltitie .h hc~dcr file 
For your fIrst programs, we strongly suggest that you use the custom header file 
iilet IIb_'acllllle" h from WW\'1.stroustrup.com/progranuninglstd_libJacilities.h. 
1153 

1154 
APPENDIX C • GETTING STARTED WITH VISUAL STU DIO 
Place a copy of it in the directory you chose in §C.3.1, step 6. (Note: Save as text, 
IlOt HTML.) To usc il, you need the line 
#include " . .I.Jstd_lib_facililies.h" 
in your program. The ".J .. r tells the compiler that you placed the header in 
C:\Documents and Settings\Your Name\My Documents\Visual Studio 2005 
Projects where it can be used by all of your projects, rather than right next to 
your source file in a project where you would have to copy it for each project. 
C.3.3 Add a c++ source file to the project 
You need at least one source fLle in your program (and often many): 
I. Click the Add New Item icon on the menu bar (usually the second icoll 
from the left). 'nmt will open the Add New Item dialog box. Select 
Code under the VISUal C++ category. 
2. Scicct the C++ HIe (.cpp) icon in the template window. Type the name 
of your program file (HeUo,World!) in the Name text box and click 
Add. 
YOli have created an empty source code file. You arc now ready to type your 
source code program. 
C3.4 Enter your source code 
At this poim you can either enter the source code by typing it directly into the 
IDE, or you can copy and paste it from another source. 
C3.5 Build an executable program 
W hen you believe you have properly entered the source code for your program, 
go to the Build menu and select Build Solution or hit the triangular icon point-
ing to the right on lhe list of icons near the top of the IDE window. 11\e IDE will 
try to compile and link your program. If it is successful, the message 
Build: 1 succeeded, 0 failed, 0 up·lo-dale, 0 skipped 
should appear in the Output window. Otherwise a number of error messages 
will appear. Debug the program to correct the errors and Build Solution again. 
If you used the triangular icon, the program will automatically start rtmning 
(executing) if there were no errors. If you used the Build Solution menu item, 
you have to explicitly start the program, as described in §C.3.6. 

C.4 
LATER 
C.3.6 Execute the program 
Once al[ errors have been eliminated, execute the program by going to the 
Debug menu and selecting Start Wtthout Debugging. 
C.3.? Save the program 
Under the File menu, dick Save All.lfyo Li forget and try to dose the IDE, the 
IDE will remind you. 
C.4 later 
TIle IDE has an apparent infinity of features and options. Don't worry about 
those early on - or you'll get completely lost. If you manage to mess up a project 
so that it "behaves odd[y," ask an experienced friend for help or build a new proj-
ect from scratch. Over time, slowly experimem with new features and options. 
1155 


\ t . r 0 
Installing FLTK 
"If the code and the comments disagree, 
then both are probably wrong." 
-Norm Schryer 
T
his appendix describes how 10 download. i", .. ll. and link 
to the FL1'K gl'ilphicl ond CUI toolkit. 
1157 

1158 
0.1 Introduction 
0.2 Downloading FLTK 
D.) Installing FLTK 
0.4 Using FLTK in Visual Studio 
0.5 Testing if it all worked 
D.1 Introduction 
APPENDIX 0 
• INSTALLING FLTK 
We chose FLTK, the Fast Light Tool Kit (pronounced "full lick"), as the base for 
our presentation of graphics and CUI issues because it is portable, relatively sim-
ple, relatively conventional, and relatively casy to instalL We explain how to in-
stall FLTK under Microsoft Visual Studio because that's what most of our 
students use and because it is the hardest. U you usc some mher system (as some 
of our students also do), juSt look in the main folder (directory) of the down-
loaded ftlcs (§D.3) for directions for yOllr favorite system. 
'Whenever YOli lise a library mat is nal pan of the ISO C++ slalldard, you (or 
someone else) have to download it, install it, and correctly use it from your own 
code. 111at's rarely completely trivial, and installing FLTK is probably a good exer-
cise - because downloading and installing even the best library can be quite frus-
trdting when you haven't tried before. Don't be tOO reluctant to ask advice from 
people who have tried before, but don't just let them do it for you: learn from tl1em. 
Note that there might be slight differences in files and procedures from what 
we describe here. For example, there may be a new version of FLTK or you may 
be using a different version of Visual Studio from what we describe in §D.4 or a 
completely different C++ implementation. 
D.2 Downloading FLTK 
Before doing anything, first see if FLTK is already installed on your machine; sec 
§D.5. If it is not there, the first thing to do is to get the files onto your computer: 
1. Go to http://ntk.org. (In an emergency, instead download a copy from 
our book support website: www.stroustrup.comiProgramminglFLTK.) 
2. C lick Download in the navigation menu. 
3. Choose FLTK l.l.x in the drop-down and dick Show Download Loca-
tions. 
4. Choose a download location and download the .zip file . 
The file you gel will be in .zip formal. -nlat is a compressed format suitable for 
transnuuing lots of files across the net. You'll need a program on your machine to 
"unzip" it into normal files ; on Windows, WinZip and 7-Zip are examples of 
sllch programs. 

0.4 
US IN G FlTK IN VI SUAL STUDIO 
0.3 Installing FLTK 
Your main problem in following our insouctions is likely to be one of two: some-
thiJlg has changed since we wrote and tested them (it happens), or the tenmnol-
ogy is alien to you (we can't help with that; sorry). In the latter case, find a friend 
to translate. 
I. Unzip the downloaded file and open the main folder, fllk-l.l.? In a 
Visual C++ folder (e.g., vc2005 or venet), open fltk.dsw. If asked abOllt 
updating old project files, choose Yes to All. 
2. From the Build menu, choose Build Solution. "nlis may take a few min-
utes. TIle source code is being compiled into static link libraries so that 
you do not have to recompile the FL'rK source code any time you make 
a new project. When the process has finished, close Visual Studio. 
3. From the main FLTK directory open the lib folder. Copy (not just 
move/drag) all the .lib files except README.lib (there should be 
scven) into C:\Prograrn Files\Microsoft Visual Studio\Vc\lib. 
4. Go back to the FLTK main directory and copy the FL folder into 
C:\Program Files\Microsoft Visual Studio\Vc\include. 
Expens will tell you that there arc better ways to install than copying into 
C:\Program Files\Microsoft Visual Studio\Vc\lib and C:\Program Files\Mi-
crosoft Visual Studio\Ve\include. TIley arc right, but we are nOt trying to make 
you VS experts. If the experts insist, let lhem be responsible for showing you the 
better alternative. 
0.4 Using FLTK in Visual Studio 
I. Create a new project in Visual Studio with one change to the usual pro-
cedure: creale a "\Vin32 project" instead of a "console application" when 
choosing your project type. Be sure to create an "empty project"; other-
wise, some "software wizard" will add a lot of stuff to your project that 
you arc unlikely lO need or understand. 
2. In Visual Studio, clloose Project from the main (top) menu, and from 
the drop-down menu choose Properties. 
3. In lhe Properties dialog box, in the left menu, click the Linker folder. 
This expands a sub-menu. In this sub-menu, click Input. In the Addi-
tional Dependencies text field on the right, enter the following text: 
fltkd.1ib ws0ck32.Ub comctl32.lib fltkjpegd.lib fltkimagesd.lib 
[The following step may be lIImecessary because il is now the default.] 
In the Ignore Specific Library text field, enter the following text: 
libcd.lib 
1159 

1164) 
APPEND IX D • I NSTAL LI NG FLT K 
4. [Ths step may be unnecessary because IMDd is now the default.] In the 
left menu of the same Properties window, dick C/C++ to c.xpand a dif-
ferent sub-menu. Click the Code Generation sub-menu item. In the right 
menu, change the Runtime Library drop-down to Multi-threaded 
Debug DLL (/MDd ). Click OK lO d ose the Properties window. 
D.S Testing if it all worked 
Create a single new .cpp file in your newly created project and enter the follow-
ing code. It should compile without problems. 
#include <FUFl.h> 
#include <fVFI_Box,h> 
#include <fl/FI_Window.h> 
int mainO 
( 
FI_Window window(200, 200, "Window title"); 
FeRo" box(O,O,200,200, "Hey, I mean, Hello, World! "l; 
window.showO; 
return FI: :runO; 
If it did not work: 
"Compiler error stating a .lib file could not be found": Your problem is 
most likely in the installation section. Pay attention to step 3. which in-
volves putting the link libraries (.lib) files where your compiler can easily 
find them. 
"Compiler error stating a.h file could not be opened": Your problem is 
most likely in the installation section. Pay attention to step 4, which in-
volves putting the header (.h) flies where your compiler can easily find 
lhem. 
"Linker error involving unresolved external symbols": Your problem is 
most likely in the project section. 
If that didn't help, fmd a friend to ask. 

CUI Implementation 
"When you finally understand 
what you are doing, 
things will go right." 
-Bill Fairbank 
T
his appendix presents implementation details of callbacks, 
Window, Widget, and Vector_ref. In Chapter 16, we 
couldn't assume the knowledge of pointers and casts needed ror 
a more complete explanation, so we banished that explanation to 
tltis appendix. 
1161 

1162 
E.1 Callback implementation 
E.2 Wldjl@1 implementation 
E.3 Window implementation 
E.4 Vector_'ll' 
E.5 An example: manipulating Wld8l!ls 
APPENDIX E • GUI IMPLEMENTATION 
E.l Callback implementation 
We implemcnted callbacks like this: 
\lold Slmpl l!~wlndow ll c b_n Ci'. t(Addr cu . Addre" addr) 
II LLlll ~ltfi l)lc_w lm luw :: IICX I () (Of IIII.' wln(tuw IOC,IIl'd ,II pw 
Once you have understood Chapter 17, it is pretty obvious that an AdtlrC!j must 
he a void· . And, of course, rctClHHlecu ocSlniplc_wllldoW>('lthlr) must somehow 
create a reference to a Slml)lc window from the void· called add,. However, un· 
less you had previous programming experience, there was nothing "pretty obvi· 
ous" or ;'of course" about that before you read Chapter 17, so let's look at the use 
of addresses in detail. 
As described in §A.17, C++ offers a way of giving a name to a type. For 
example: 
TIlis means that the name AddrClIi can now be used instead of \lold · . Here, we 
used Addrc" to emphasize that an address was passed, and also to hide the fact 
that void· is the name of the type of pointer to an object for which we don't 
kllOW the type. 
So cb_neJlfO receives a void· called iultlr as an argument and - somehow -
promptly convens it to a SltnIJlll_wlndow&: 
rThe rClllrlll\CtU O is a templatc function (§A.13): 
IllnllJlalll<cliljj W> W& tc'crenCc_IO(AddrcU pw) 
II Ire,1t ,lt1 .ltldrl'~!.u.! ,dl'll'nLl' 10 .1 W 

E.2 
WIDGET IMPLEMENTATION 
{ 
return 'stalic cast<W">(pw); 
) 
Here, we used a template function to write ourselves an operation that aeLS as a 
cast from a void' to a Simple_window&. The type conversion, staliccast, is de-
scribed in §17.8. 
The compiler has no way of verifying our assertion that addr poinLS to a 
Simple_window, but the language rule requires the compiler to lruSt the pro-
grammer here. Fortunately, we arc right. The way we know that we arc right is 
that FL"TX is handing us back a pointer that we gave to it. Sillce we knew the 
type of the pointer when we gave it to FLTK, we can usc reference_to to "get it 
back." Illis is messy, unchecked, and not all that uncommon at the lower levels 
of a system. 
Once we have a reference to a Simple_window, we C.lll use it to call a mem-
ber function of Simple_window. For example (§16.3): 
void Simple_window: :cb_ned (Addrcss, Address pw) 
/I call Simplc_window::ncxtO for the windm¥ located at pw 
referencc_to<Simplc_window>(pw),ncxtO; 
) 
"Ve usc the messy callback function cb_ned O simply to adjust the types as 
needed to call a perfectly ordinary member function ned O. 
E.2 Widget implementation 
Our Widget interface class looks like this: 
class Widget { 
/lWidgel is a handle to a FI_widget -
it is °not· a FI_widget 
/I we try 10 keep our interface classes at arm's length from FLTK 
public: 
() 
Widget(Point xy, inl w, int h, canst string& s, Callback cb) 
:Ioc(xy), width(w), height(h), label(s), do_it(cb) 
virlual- WidgetO { } 
/I destructor 
virlual void move(inl dx,int dy) 
( hid eO; pw- >posilion(loc,x+=dx, loc.y+=dy); showO; } 
1163 

"64 
APPENDIX E a CUI IMPLEMENTATION 
vl,lu. 1 void hldoO ( pw-.hldoO, ) 
vl,tual void iihowO ( pW->lhowOI ) 
vlrtunl void iUHICh(Wlridow&) . 0, /I c,llh Wltl»cl dcflt'l'~ .11 k"I~ 1 
/1 (Jill! .KIIU!1 (ur ,I wlnduw 
POlnllo(a 
Ittl width , 
Inl holShl' 
! lrlns lablllJ 
Cillibiltk doJt/ 
prOICC:I\lt! 1 
) , 
Window· own , 
ill_Wldget- (JWI 
IlllVt'ty Wld!}!.'1 bdu"~~ 10 .1 Wlnduw 
//.1 Widget "knuw!" It! FI_Wltlgcl 
Note that our Widsci keeps track of its FLTK widget and the Window with 
which it is associated. Note that we need pointers for that because a Wid SCI can 
be associated with different Windows during its life. A reference or a named ob-
ject wouldn't suffice. (Why not?) 
It has a location (Ioc), a rectangular shape (Width and heIShl), and a 13blll. 
Where it gets interesting is that it also has a callback function (do II) - it con-
nects a WldSClI's image on the screen to a piece of our code. TIle meaning of the 
operations (nlOv~O , iihowO, hld.,O, and "lIithO) should be obvious. 
Wldgel has a "half-finished" look to it. It was designed as an impicillcillation 
class that users should not have to see very often. It is a good candidatc for a re-
design. We are suspicious about all of those public data membcrs, and "obvious" 
operations typically need to be reexamined for unplanned subtlcties. 
Wldscl has virtual function and can be used as a base class, so it has a vlrlual 
destructor (§17.5.2). 
E.3 Window implementation 
When do we usc pointers and when do we use references instead? We examine 
that gencral question in §8.5.6. Here, we'll just observe that somc programmers 
like pointers and tllal we need pointers whcn \ ... ·c want to point to diffcrent objects 
at different timcs in a program. 
So far, we have not shown one of the central classes in our graphics and G U I 
library, Window. The most significant reasons are lhat it uses a pointer and that 

E.3 
WINDOW IM PLEMEN TATION 
its implementation using FLTK requires free store. As found in Wlndow.h, here 
It IS: 
cllI.5!I Window I public ill Whldow { 
I)ublle: 
Illct the !y~tl'm plLk the IUL.ltIOI1: 
Wlndow(hH w, Int Ii, ( Onl l llltlng& IltltI), 
IIlupldt LOlller In xy: 
WlndowWolnl ky, It" WI Inl hi (0".1111,1118& tlllel)1 
VI,IUill ... Wlndown { ) 
Inl lumur:() eonl l ( return W) ) 
Inl y_,tlil JlO eunllt ( nHum h/ ) 
vuld IllHu:h( h"pe& I) {lhilIH,!II,,-iJ iih_bn k(&I») ) 
vuld iHMeh(Wldget&)1 
vuld dtltaeh(Shll(ltl& 8)1 
void dela h(Wldgel& w); 
II f'ernUW w (ruin sh,lpe5 
Illemuve w (rum whu.luw 
II (tle.1Ulv,ltcS Lolllb,lt k:s) 
void IJUI on IUI)(Shapc& I)) 
ptUttletcd: 
II put p Ul11UP of til her ~11tI 1)c' 
void drawn) 
1"lvale: 
vCClorcShilpc·> 8hllpClIi 
Inl w,h, 
vultl lnltO; 
II slMpe5 .JII.1elled It) Wlilduw 
II wlmluw ~Ile 
So, when we atMehO a ShlllHl we store a pointer in IIhiiJlti8 so that the Window 
can draw it. Since we can later detac:ho that shape, we need a poimer. Basically, 
all .,1111 hOed shape is still owned by our code; we just give the Winduw a refer-
ence to it. Window : tlulnchO converts its argumem to a poimer so that it can 
store it. As shown above, l'IlIaehO is trivial; dtltllchO is slightly less simple. look-
ing in Wlndow,cl)I), we find: 
1165 

" 66 
APPENDIX E • CUI IM PLEMENTATION 
void Window: :detach(Shape& s) 
/I guess that the last anached will be first released 
{ 
for (unsigned int i = shapes.sil-eO; (kij --i) 
if (shapes[i-l l==&s) shapes.erase(&shapes[i-l U; 
T he eraseO member function removes ("crases") a value from a vector, decreas-
ing the vector's size by one (§20.7.1). 
Window is meant to be used as a base class, so it has a virtual destructor 
(§17.5.2). 
E.4 Vector_ref 
Basically, Vectocref simulates II vector of references. You c.m initialize it with ref· 
erences or wilh pointers: 
If an object is passed to Vector_ref as a reference, it is assumed to be 
owned by the ca.llcr who is responsible for its lifetime (e.g., the object is a 
scoped variable). 
If an object is passed to Vector_ref as a pointer, it is assumed to be allo-
c.1.ted by new and it is Vector_ref's rcsponsibility to delete it. 
An clement is stored as a pointer -
not as a copy or the object -
into the 
Vector_ref and has rererence semantics. For example, YOll c.1.1l put a Circle into a 
Vector_rekShape> without suffering slicing. 
te mplate<class T> class Vector_ref { 
vector<T·> v; 
vector<T"> owned; 
public: 
Vector_,efO {} 
Vector_,ef(T" a, T" b = 0, T· c = 0, T· d = 0); 
-Vector_ref 0 { for (int i=O; i<owned.sizeO; ++i) delete owned!il; } 
void push_back(T& s) { v.push_back(&sl; ) 
void push_back(T· p) { v.push_back(pl; owned.push_hack(pl; ) 
T& operatorI](int i) { return · vIil; ) 

E.S 
AN EXAMPLE: MANIPULATING WIDGETS 
consl T& operator(](int i) canst ( return ·v[i); } 
int size() consl { return v.sizeO; } 
} ; 
Vector_rer's dCSlnlC10r deletes every object passed to it as a pointer. 
E.S An example: manipulating Widgets 
Here is a complete program. It exercises many of the WidgetJWindow features. It 
is only minimally commented. Unfortunately, such insufficient commenting is 
not uncommon. It is an exercise to get this program to nln and to explain it. 
Basically, when you run it, it appears to define four buttons: 
#include" .JGUl.h" 
using namespace Graph_libi 
class W7 : public Window ( 
/I four ways to make it appear that a button moves around: 
// showlhide, change location, create new one, and attach/detach 
public: 
W7(int h, int w, const siring& I); 
Bullon· pl; 
BuUon· p2; 
bool sh_le£ti 
Bullon* mvpi 
bool mvJeft ; 
Bullon* cdp; 
bool cd_left; 
Bullon* adpl; 
Bullon· adp2; 
bool ad_left; 
void sh(); 
void mv(); 
void cdO; 
void adO; 
1/ show/hide 
1/ move 
/I creatcldcstroy 
/I activate/deactivate 
/I actions 
1167 

1168 
} ; 
APPEND IX E • CUI IM PLEMENTATION 
Iitalic void c b~!i h(Atldrc8l, Addre.! add,) 
II c.lllb.ltks 
( rctcrllnctUo<W7>(addr).lhOI ) 
ItAlic volll c b~n1V (A ddrcjl, Addreu add,) 
( fefcrtlnCC_locW7>(addr).mv(); ) 
, Mtle void cb_cd(AddrciII, Addre" :uJdr) 
«rdere" c_locW7>(adtlr).cd(); ) 
jllltle void cb_nd(Addrc:u, AddrciJII :uldr) 
( rcftlrCllc4,uocW7>(atltlr).ad()1 ) 
However, a W7 (Window experiment number 17) really has six buttons; it just 
keeps two hidden: 
W7= :W7(lnt h, I", w, (o"sI8trlng&! I) 
:Wlndow(h,w,I), 
I!lhJeh(lrue), mv)cfUlrue), CtUefl(lruc), :,dJc'l(ltUc) 
1,1 • new Ihlllon(Polnl(l00,l00),50,lO, "jhow" ,cb_lhl; 
Ill. new Button(Polnl(104lt100),50,20,"hldc",cb_lih); 
n'IVp • new BUllon(Pulnl(l00,200),50,20,"movc" ,cb_mv); 
(tip . new SUllon(l'olnI(100,JOO),SO,lO, "c:reatu" ,c b~cd ); 
adp1 • new Uulloll{l'olnI(100,400 ),~O ,lO."aC: llv:U c" ,c b~"d ); 
adp2 • new UUllon(llolnI(200,400),80,lO,"deac:llvlile" ,c b~"d ); 
Mlach(-p1); 
all"ch(-p2); 
,UUlch(-mvIJ)i 
allach(-cdp); 
pl->hlde(); 
alUtclW. dpl); 
There are four callbacks. Each makes it appear that the buuon you press disap· 
pears and a new one appears. However, this is achieved in four different ways: 
void W1: :.hO 
( 
II hide .1 butlutl, ~huw .1nUll1ef 
If (.hJcft) ( 
1,'I->hldtlO; 
pl->!!hOw(); 

E.5 
AN EXAMPLE : MAN IPULATING WIDG ETS 
} 
else ( 
pl->shOWOj 
p2->hide(); 
} 
shJeft = !shJeft; 
void W7:: mvO 
II move the button 
{ 
} 
if (mv_lefO ( 
mvp->move(l oo,O); 
} 
else { 
mvp->move(-loo,O); 
} 
mv_left = !mvJeft j 
void W7: :cdO 
/I delete the button and create a new one 
{ 
} 
cdp->hide(); 
delete cdp j 
string lab = "create"j 
inl x = 100; 
if (cdJ eft) ( 
lab = "delete"; 
x = 200; 
cdp = new Button(Point(x,JOO), SO, 20, lab, cb_cd)j 
attach(-cdp)j 
cdJeft = !cdJeft ; 
void W7: :adO 
/I detach the button from the window and attach its replacement 
{ 
if (ad_left) ( 
detach(-adp1); 
attach(·adp2); 
} 
else ( 
detach(*adp2); 
attach(*adp1)j 
} 
1169 

1170 
ad lell - lldJelll 
Inl malnO 
i 
W7 w(400,800, lImulell); 
rei urn gul_ntalnOJ 
APPEN DI X E • CUI IMPLEMENTATION 
111is program dcmonstrales the fundamental ways of adding and subtracting 
widgcLS lolfrom a window - or just appearing to. 

Glossary 
"Often, a few well-chosen words 
ar worth a thousand pictures." 
-Anonymous 
A glOJJdry is a brief explanation of words used in a text. TIlls is a rather shon glos-
sary of the tenns we thought most essential, especially in lhe earlier stages of 
lcaming programming. The index and lhe "Terms" sections of the chapters 
might also help. A morc extensive glossary, relating specifically to C++, can be 
found at wv .... v.rescarch.atl.com/ -bs/glossary.html, and there is an incredible vari-
ety of specialized glossaries (of greatly valying quality) available on the web. 
Please nme that a term can have several related meanings (so we occasionally list 
some) and that most terms we list have (of len weakly) rdated meanings in other 
contexts; for example, we don't define abJtracl as it relates to modern paiming, 
legal practice, or philosophy. 
abstract class a class that camlot be directly used to create objects; often used to 
define an interface to derived classes. A class is made abstract by having a pure 
virtual funClion or a protected constructOr. 
abstraction a description of something that selectively and deliberately ignores 
~lides) details (e.g., implementation details); selective ignorance. 
addttss a value that allows us to find an object in a computer's memory. 
algorithm a procedure or fonnula for solving a problem; a finite series of com· 
putalional steps to produce a result. 
alias an alternative way of referring to an object; of len a name, pointer, or refer· 
ence. 
1171 

1172 
GLOSSARY 
application a program or a collection of programs that is considered an emily 
by its users. 
approximation something (e.g., a value or a design) that is d ose to the perfecl 
or ideal (value or design). Often an approximation is a resuit of trade-offs 
among ideals. 
argument a value passed to a function or a template, in which it is accessed 
through a parameter. 
an'3.y a homogeneous sequence of clements, usually numbered, e.g., (O:max). 
assertion a statement inserted into a program to state (assert) that something 
must always be true at lhis point in the program. 
base class a class used as the base of a class hierarchy. Typically a base class has 
one or morc virtual functions. 
bit the basic unit of infonnation in a computer. A bit can have the value 0 or the 
value I. 
bug an error in a program. 
byte the basic unit of addressing in most computers. Typically, a byte holds 8 
bits. 
class a user-defined type lhat may conlajn data members, function members, 
and member lypes. 
code a program or a part of a program; ambiguously used for both source code 
and object code. 
compiler a program thatlums source code imo object code. 
complexity a hard-to-preciscly-define notion or measure of the difficulty of con-
structing a solution to a problem or of the solution itsclf. Sometimes c07llpkxiJy 
is used to (simply) mean an estimate of the number of operations needed to ex· 
ecute an algorithm. 
computation the execution of some code, usually taking some input and pro-
ducing some output. 
concrete class class for which objects can be created. 
constant a value that cannot be changed (in a given scope); not mutable. 
constructor an operation that initializes ("constructs") an object. Typica.lly a con-
struCLOr establishes an invariam and often acquires resources needed for an ob-
ject LO be used (which arc then typically released by a destructor). 
container an object that holds elelllents (other objects). 
correctness a program or a piece of a program is correct if it meets its specifica-
tion. Unfortunately, a specification can be incomplete or inconsistent, or can 
fail to meet users' reasonable expectations. TItuS, to produce acceptable code, 
we sometimes have to do more than just follow the fomlal specification. 
cost the expense (e.g., in programmer time, run time, or space) of producing a 
program or of executing it. Ideally, cost should be a function of complexity. 
data values lIsed in a compmation. 
debugging the act of searching for and removing errors from a program; usually 
far less systematic than testing. 

GLOSSARY 
declaration the specification of a name with its type in a program. 
definition a declaration of an emity that supplies all infomlation necessary to 
complete a program using the emilY. Simplified definition: a declaration that 
allocates memory. 
derived class a class derived from one or more base classes. 
design an overall description of how a piece of software should operate to meet 
its specification. 
destructor an operation that is implicitly invoked (called) when an object is de-
stroyed (e.g., at the end of a scope). Often, it releases resources. 
error a mismatch between reasonable expectations of program behavior (often 
expressed as a requirement or a users' guide) and what a program actually 
does. 
executable a program ready to be run (executed) on a computer. 
feature creep a tendency to add excess fUllctionality to a program "just in case." 
file a container of pellllanelU information ill a computer. 
noating-point number a computer's approximation of a real number. such as 
7.93 and 10.78e-3. 
function a named unit of code that C.·1.1l be invoked (called) from different parts 
of a program; a logical unit of computation. 
generic programming a style of progranuning focused 011 the dcsign and effi-
cient implementatioll of algoritluns. A generic algorilhm will work for all arb'll-
ment types that meet its requirements. In C++, generic programming typically 
uses templates. 
header a file containing declarations used to share interfaces bet\veen parts of a 
program. 
hiding the act of preveming a piece of information from being directly seen or 
accessed. For example, a name from a nested (inner) scope can prevem that 
same name from an outer (enclosing) scope from being directly used. 
ideal the perfect version of something we arc striving for. Usually we have to 
make trade-oITs and settle for an approximation. 
implementation (1) tile act of writing and testing code; (2) tile code that imple-
ments a program. 
infinite loop a loop where the termination condition never becomes true. Sec 
iteration. 
infinite recursion a recursion that doesn't end until the machine runs Out of 
memory to hold the calls. In reality, such recursion is never infinite but is ter-
minated by some hardware error. 
information hiding the act or separating interface and implementation, thus 
hiding implementation details not mealll ror the user's attention and providing 
an abstraction. 
initialize giving an object its first (initial) value. 
input values used by a computation (e.g., function arguments and characters 
typed on a keyboard). 
1173 

1174 
GLOSSARY 
integer a whole number, such as 42 and -99. 
interface a declaration or a set of declarations specifying how a piece of code 
(such as a function or a class) can be called. 
invariant something that must be always tn le at a given point (or points) of a 
program; typically used to describe the state (SCI of values) of an object or t.he 
state of a loop before entry into the repeated statement. 
ileration the act of repeatedly executing a piece of code; sec recursion. 
iterator an objcct that identifies an clemcnt of a sequence. 
library a collection of types, functions, classes, etc. implementing a set of facilities 
(absuactions) meant to be potentially used as prut of more that one program. 
lifetime the time from the initialization of an object umil it becomes unusable 
(goes out of scope, is deleted, or the program tenninatcs). 
linker a program that combines object code files and libraries into an executable 
program. 
literal a notation that directly specifies a value, such as 12 specifying lhe integer 
value "twelve." 
loop a piece of code executed repeatedly; in C++, typically a for-statement or a 
while-statement. 
mutable changeable; the opposite of immutable, constant, and variable. 
object (I) an initialized region of memory of a kllown type which holds a vallie 
of tim type; (2) a region of memory. 
object code output from a compiler intended as input for a linker (for the linker 
to produce e. .... ecutable code). 
object file a me containing object code. 
object-oriented programming a slyle of programming focused on the design 
and use of classes and class hierarchies. 
operation something that can perform some action. such as a function and an 
operator. 
output values produced by a computation (e.g., a function resuit or lincs of char-
acters written on a screen). 
overflow producing a value that calUlot be stored in its intended target. 
overload defining two functions or operators with the same name blll dilTerelll 
argumelll (opela nd) types. 
override defining a runction in a derived class with the same name and argu-
mcnt types as a virtual function in the base class, thus making the function 
callable through the interface defined by the base class. 
paradigm a somewhat pretentious term for design or programming style; often 
used with the (erroneous) implication that there exists a paradigm that is supe· 
rior to all others. 
parameter a declaration of an explicit input to a function or a template. When 
called, a function can access lhe arguments passed through the nallles of its 
parameters. 

GLOSSARY 
pointer (I) a value used to identify a typed object in memory; (2) a variable 
holding such a value. 
post-condition a condition that must hold upon exit from a piece of codc, such 
as a function or a loop. 
pre-condition a condilion that must hold upon elllry into a piece of codc, such 
as a function or a loop. 
program code (possibly with associatcd data) that is sufficiently complcte to be 
executed by a computer. 
programming the art of expressing solutions to problems as code. 
programming language a language for expressing programs. 
pseudo code a description of a computation written in an infomlal nalation 
rather than a programming language. 
pure virtual function a virtual function that must be overridden in a derived 
class. 
RAIl ("Resource Acquisition Is Initializationn) a basic tcdmique for resource 
management based on scopes. 
range a scqucnce of values that can be described by a start point and an end 
point. For cxample, (0:5) means the values 0, 1, 2,3, and 4. 
regular expression a notation for pattcOls in character strings. 
recursion the act of a function calling itself; see also iteration. 
reference (I) a value dcscribing the location of a typed value in memory; (2) a 
variable holding SUell a valuc. 
requirement (I) a description of the desired behavior of a program or part of a 
program; (2) a desoiption of the assumptions a function or tcmplate makes of 
its arguments. 
resource something that is acquircd and must later be released, such as a file 
handle, a lock, or memory. 
rounding conversion of a value to the mathematically nearest value of a less pre-
cise type. 
scope the region of program text (source code) in whiell a name can be referred 
to. 
sequence clcments that can bc visited in a linear order. 
software a collection of pieces of code and associated data; often used inter-
changeably with program. 
source code code as produced by a programmer and (in principle) readable by 
other programmers. 
source me a file containing source code. 
specification a description of what a piece of code should do. 
standard an officially agreed upon definition of something, such as a program-
ming language. 
state a set of values. 
string a sequence of characters. 
1175 

1176 
GLOSSARY 
style a set of techniques for programming leading to a consistent use of language 
features; sometimes used in a very restricted sense to refer just to low-level 
rules for naming and appearance of code. 
subtype derived type; a type that has alIlhe propenies of a type and possibly more. 
supertype base type; a type t.hat has a subset of the propertics of a type. 
system (I) a progrnm or a set of programs for performing a task on a computer; 
(2) a shorthand for "operating system;' that is, the fundamclllal execution en-
viromllCnt and tools for a computer. 
template a class or a function parameterized by one or more types or (compile-
time) values; the basic C++ language construct supponing generic programming. 
testing a systematic search for errors in a progrnm. 
trade-off the result of balancing several design and implementation criteria. 
truncation loss of information in a conversion from a type into another that can-
not exactly represent the value to be converted. 
type something that defines a set of possible values and a set of operations for an 
object 
uninitialized the (undefined) state of an object before it is initialized. 
unit (I) a standard measure that gives mcaning to a value (e.g., km for a dis-
tance); (2) a distinguished (e.g., named) part of a larger whole. 
use case a specific (typically simple) lise of a program meaIll LO test its function-
ality and demonstrate its purpose. 
value a set of bits in memory interpreted according to a type. 
variable a named object of a given type; contains a value unless uninitialized. 
virtual function a member function that can be overridden in a derived class. 
word a basic unit of memory in a computer, usually the unit used to hold an 
integer. 

Bibliography 
Aho, Alfred v., Monica S. Lam, Ravi Sethi, and J effrey D. Ullman. Compilers: P'll1cip/~J, 
7'edllllf/UCS, {/lui roots, Second £Iilioll (usually called "TIle Dragon Book"). Addison-\Vcs]cy, 
2007. ISBN 032 1547985. 
Andrews, Mike, and Jruncs A. Whittaker. How to Brmfl. Siftware: Fundional mul Srom"ty Test-
ingo/"mh Applim/iQ1/J IIl1d fffb Servias. Addison-Wesley, 2006. ISBN 0321369440. 
Austcrn, MatthelV H. Genmc Programming mui 1M STL: Using allll Exleuding lhe C++ Standmzl 
7!:mplate [ibmry. Addison-V.'Cslcy, 1999. ISBN 0201309564. 
Austcrn, Matt, cd. Dr41 7(chnim/ Rep0l1 011 C++ Siandard Library £r/msiolls. ISOIlEC 
PDTR 19768. W\vw.opcn-std.orgljtc1/sc22/w'(21/docsfpapcrs/2005/n 183 6.pdf. 
Bergin, Thomas]., and Richard C. Gibson, cds. History rfProgramming Languages - Volume 
2. Addison-vVcslcy, 1996. ISBN 0201895021. 
Blanchctlc, J asmin, and Mark Summcrfield. C++ CUI Programmillg with QL 4. Prentice 
Hall, 2006. ISBN 013 1872493. 
Boost.org. ~A Rcpository for Libraries Meant 10 Work V.'elI wilh the C++ Standard Li-
brary." www.boost.org. 
Cox, Russ. ~ RcguI ar Expression Malching Can Be Simple and Fast (but Is Slow inJava, 
Perl, PHP, PYlhon, Ruby, ... J." http ://swtch.com/ -rsdregexp/regexpl.html. 
dmoz.org. http://dmoz.orgiComputerslProgramminglLanguages. 
Freeman, T L., and CJllis Phillips. RlTa1le1 Numerical Algonihllls. Premice Hall, 1992. ISBN 
0136515975. 
Gamma, Erich, Richard Helm, RalphJohnson, and John M. Vlissides. Jk.sigll Pattems: Ek-
///C1It.s o/"Rrmtlblr Olij"ecl-Oriell/ed Srf"twarr. Addison-Wesley, 1994. ISBN 0201633612. 
Goldthwaite, Lois, cd. 71xhllical Repor/ QII C++ lbfonllmu:e. ISOIIEC PDTR 18015. 
www.rescarch.all.cOlnl-bs/pcrformanecTR.pdf. 
Gullberg, Jan. Ma/hell/(I/iCJ -
From IIle Birth 0/" Jol/lmbers. W. W. Nonon, 1996. ISBN 
039304002X. 
Hailpcm, Brcnt, and B.1l"bara G. Ryder, eds. Ftrxeetiuw rj/lze 77tinl ACM SIGPLANCmgeretlU OIl 
/lze HUJOI)' if" Programming Lmq;uage.s (HOPL-J!l). San Diego, CA, 2007. http://portal.acm.orgl 
loc.cfm?id=1238844. 
1177 

1178 
81BlIOGRAPHY 
Hcnricson, Mats. and Erik Nyquist. huiustnal Sirmgth C++: Ruffs oml &rommnuulhans. 
Prentice Hall, 1996. ISBN 013 1209655. 
ISO/lEG 9899: 1999. ProgrammuJg ulI/guagtJ - C. -nlc C standard. 
ISOIIEC 14882:2003. Programming IAI'guogc; - C++. ll1c C++ standard. 
Kernighan, Brian W .. and DClUlis M. Ritchie. 'rnc C Programming Lallgtlagt. Premiec Hall. 
first edition, 1978; second edition, 1988. ISBN 013 1103628. 
Knuth, Donald E. 1k Arl f/"Computer Programming, fIi"lII~ 2: Semllll/mmmi Algrmihms, 77u'rd 
Edition. Addison·Wesley, 1998. ISBN 0201896842. 
Koc::nig, Alldrcw. cd. 1M C++ SlamumJ. ISOflEC 14882:2002. Wiley, 2003. ISBN 
0470846747. 
Koenig, Andrew, and Barbara E. Moo. Acctin-oled C++: Itacl/wl Programmillg by Examp/e. 
Addison-Wesley, 2000. ISBN 020170353X. 
Langer. Angdika. and Klaus Kreft. SlmU/(IIri C++ IOSITtalllS (lnd Ux(/ltS: At/w I/ad Program-
mtr; Guide (II/(I Rijtrel/a. Addison-Wesley, 2000. ISBN 020 11 8395 1. 
Lippman, Stanley B.,j osce Lajoie, and Barbara E. Moo. '{k C++ Primtr. Addison·\o'l'eslcy. 
2005. ISBN 020 1721481. (Usc only the 4th edition.) 
Lock.heed Martin Corporation. ':Joint Strike Fighter Air Vehicle Coding Standards ror the 
System Development and Demonstration Program .~ Document Number 2RDUooOO I 
Rev C. December 2005. Colloquially k.nown as "J SF++." www.rt:search.al.l.com/- bsi 
j SF·AV·mles.pdr. 
Lohr, Steve. Go 70: 1M Slory rflht Mnlh Mf!iqrs, 8ridgt Pfa)m, ~11tm, Chm WiUlnu, Mau-
mck &in/lisls (lnd Irotux:!iI.lls - 7'ht Programmrrs Who Crtaltd Iht Siflwart RroolllllfJ/!. Basic 
Books, 2002. ISBN 9780465042265. 
Maddoc. j . boost::rt:gcxp documentation. www.boosLorg and www.boost.orgldodlibs! 
1_36_0Ilibslrt:gexldodhtmllindex.htmi. 
Meyers. ScOtt. El1utilx S ri: 50 Sjxcjfo. Way'J 10 lmprout lollr Use 0/ lilt Slml(uml 7ellll)lalt Li· 
bmry. Addison·Wesley, 2001. ISBN 0201749629. 
Meyers, ScOtt. Iijf«tif~ C++: 55 Sjxcffic Wl)'s to Improut Yollr F'rogmllls alld Dt-figm, 7'hird &Ii-
tim,. Addison·' Vesley, 2005. ISBN 0321334876. 
Musser, David R., eillmer J. Derge, and Atul Saini. S7L 'lillorial t/1111 Rijrrt7ll:t Gllitk: C++ 
Progrmlllning wilh Iht Slal/(umi 'ft,np/ale Libral)" S((ol/(I £ililioll. Addison·\Vesley, 2001. 
ISBN 020 1379236. 
Programming Research. Higll-inlegrily C++ Oxling Sla//(umi Mallllal Vmion 2.4. www.pro· 
grammingresearch.com. 
Richards, Martin. BCPL - 'nit IAngl/agt and lis Compiltr. Cambridge University Press. 
1980. ISBN 0521 219655. 
Ritchie, Dennis. M-nle Development of lhe C Programming Language." /trx:«r/ing'f f!!lht 
ACM HiJlory 0/ Programmillg IAnguagr.s CoI!forrna (110PL·2). ACM SIGPLAN .NiJlim, Vol. 
28 No.3, 1993. 
Salus, Peter. A <1!!arltr O:lIlury rfUNIX. Addison·Wesley, 1994. ISBN 020 1547775. 
Sammet, jean. Programming UlllguagtJ: HiJlory and FillllulT1I(1Ilals, Prentice Hall. 1969. IS I3 N 
0 137299885. 
Schmidl, Douglas C., and Stephen D. Huston. C++ Nrtwork Programmillg, VOlUlllt I : Masler-
ing Comp/txily l<!iJh ACE (/lid Rillml.f. Addison·Wesley, 2002. ISBN 020160'1647. 
Schmidt, Douglas C., and Stephen D. Huston. C++ .Network Progrmlllllli/g, VoJlllllt 2: Splnn-
atic RtuM wilh ACE III/(i H(llIItWOrRs. Addison·Wesley, 2003. ISBN 0201795256. 

BIBLIOGRAPH Y 
Schwanz, Rand:al L., Tom Phoenix, :and Brian D. Fay: Leamjllg Perl, roUl'II, Etlilion. 
O'Reilly, 2005. ISBN 0596 101058. 
ScOH. ~'Iiehacl L. Progrmnmjllg Lal/g/lagt Pragllwlia. Morgan Kaufmanll. 2000. ISBN 
155860442 1. 
Sebesta. Robert W. O)//(('I"S 0/ /togrml/lI/jllg Languages, Sixth Et/j/jl)ll. Addison·\Veslcy, 2003. 
ISBN 0321 193628. 
Shcphcrd, Simon. "-nle -liny Encryption Algorithm rffiA) .~ w,vw.tay!oredge.com/rcfer· 
cned Mathcmatic.srr EA· XrEA pdf and http://143.53.36.235:8080Itca.hun. 
Stcp:anov, Alexander. www.stepanovpapcrs.eolll. 
Stcwart, C. W. Millril Algolllhll/J, VoIUlllt I: &uit o«'ompruitiollJ. S IA.~ , 1998. ISBN 
0898714141. 
Stonc. Debbic, Caroline J anctt, Mark WoodroITe, and Shailey Minoc.ha. U$a' llIltifaa lJt· 
sign (llId Evaluation. Morgan K.1ufmann, 2005. ISBN 0120884364. 
StroUSlnlP, Bjam c. ~A History of C++: 1979- 1991." Itocttdings '!Ilk ACM HUltJry '!I Pro-
gmmming LanguagtJ Cotjir(lll( (HOPL-2). ACM SIGPLAJ{ Notiw, Vol. 28 No.3. 1993. 
Slroustnlp, Bjarne. ~ CkJigll ami Evolution '!I C++. Addison·Wesley, 1994. ISBN 
0201543303. 
Stroustmp, Bjame. MLcaming Standard C++ as a Ncw L.11lguab'C.~ CIC++ UJe'S ]ounwl, 
May 1999. 
Stroustrup. Bjame. 7k C++ Programmillg UlIIgJltl§ (SJXciaI Etiitio/~ . Addison·Wesley, 2000. 
ISBN 020 1700735. 
SlrOuStrup, Bjame. "C and C++: Siblings"; "C and C++: A Case for Compatjbility ~; 
and ~C and C++: Case Sludies in Compatibility."' -nit CIC++ UJe'S ]ollrlud,july, Aug .. 
and Sepl. 2002. 
SlroUSlrup. Bjame. ~ Evolving a Language in and for lhe Real World: C++ 1 991 -2006.~ 
PromdingJ o/Ik 7hird ACM SIGPLAN C()Iym:llu 011 lIlt NUIOIY 0/ Progmmmillg Languagts 
(HOPL-Ill). San Diego, CA, 2007.lltlp:l/portal.aelll.orgftoc.efm?id= 1238844. 
Stroustrup, Bjarne. Author's home page, www.researeh.att.eom/- bs. 
Sutter, Herb. Exctj)liO/wl C++: 47 EIIg7l1u ring PuultS, ltogrammillg Problt1lU, tltlll Solutions. 
Addison·Wesley, 2000. ISBN 0201615622. 
Sutter, Herb, and Andrei Alexandreseu. C++ Coding Slmuum/s: !OI Rll/tJ, Guilit/ina, allli 
Btsl Pf(lltias. Addison·Wesley, 2004. ISBN 0321 113586. 
University of SI. Andrcws. TIle MaeTutor History of Malhematics archive. hup:J/ww,\,. 
gap.des.st ·and.ac.uk/ - hislory. 
Wexelblal, Richard L .. ed. HiJtory 0/ Programming Languagf!S. Academic Press, 1981. ISBN 
0127450408. 
Whittaker, James A. How 10 Br(aR Srfh~'Qrt: A Prtuti((lJ C/lid~ 10 '1t.slillg. Addison·Wesley, 
2003. ISBN 032 1194330. 
Wood, Alistair. Intrrx/uch'on 10 NUmnUa/ Alia/Jill. Addison·Wesley, 1999. ISBN 020134291X. 
1179 


!. &t Not, 1050 
I::. StY Not equal (inequality), 67, 1052, 
1064 
M ••• " . &tString literal, 62 
::. &t Preprocessor dirccti,'es, 1090-
1091 
S. &t End of line, 837, 1134 
%. &. 
Output fonnat specifier, 1141 
Remainder (modulo); 68 
'Yo::. Sa Remainder and assign, 1053 
&.&. 
Address of, 574, 1050 
Bitwise logical operations (and), 
917, 1052,1057 
Reference to (in declarations), 273-
277, 1062 
&&. Sa Logical and, 1053, 1057 
&::. Sa Bitwise logical operations (and 
and assign), 1053 
' ... '. Se( Char<lcter literals, 159, 1043-
1044 
n.M-
Expression (grouping), 95, 831, 
837, 840 
Function call, 282, 735- 736 
Function of (in declarations), 112-
114, 1062 
Regular expression (grouping), 1133 
Index 
". &. 
Contcnts of (dcreference), 579- 580 
Multiply, 1051 
Pointer to (in declarations), 573, 
1062 
Repetition (in regex), 832, 837-
838, 1133-Jt34 
*' end of block comment, 237 
.::. Se( Multiply and assign (scale), 67 
+. Se( 
Add, 66, 1051 
Concatenation (of strings), 68-69, 
815, 1132 
Repetition in rcgCl(, 837-839, 
1133-1134 
++. &( Increment, 66, 695 
+::. Sa 
Add and assign, 1053 
Move forward, 1064 
Siring (add at end), 815, 1132 
• (comma), &t 
Comma operator, 1054 
List separator, 1066, J084 
-.&. 
Minus (subtraction), 66, 1051 
Regular c."prcssion (range), 84 1 
- -. Sa Decrement, 66, 1102, 1050 
- > (arrow). &t Member access, 593, 
1050-1051. 1072, 1102 
1181 

'182 
-=. Set 
Move b;lekward, 1064 
Subtract alld assib'll. 67, 1053, 1103 
. (dot). &e 
Member access. 302, 592-593, 
1050-1051 
Reb'lJlar expression, 837, 1133 
... (ellipsis). Sa 
Arguments (unchecked), 1068-
1069 
Catch all exceptions, 150 
I. Se .. Divide, 66, 1051 
II. Sa Line comment, 45 
/ •...• ,. &e Block commcnt, 237 
1=. & .. Divide and assib'll, 67, 1053 
: (colon). &e 
Base and member initializcrs, 310, 
471, 543 
Conditional expression, 266 
Label, 104- 107,302,502, 1059 
... &t Scope (reso[ution), 29 1, 310, 
1049 
; (semicolon). &t Statement (tennina-
tor), 50, 99 
<. See Less than. 67, 1052 
«. Se .. 
Bitwise logical operations (left 
shift). 917, 1051 
Output,357-359, 1129 
<=. S .... Less than or equal, 67, 1052 
«=. &t Bitwise logical operations 
(shift left and assign), 1053 
< ... >. &trlcmplate (arguments and 
paramcters), 151, 656-657 
:. Sa 
Assignment, 66, 1053 
Initialization, 69-73, 1173 
==. &t Equal. 67, 1052 
>. Sa 
Greater than, 67, 1052 
Input prompt, 221 
Template (argument-list terminatOr), 
656-657 
>=. &t Greater dIan or equal, 67. 1052 
». Sa 
Bitwise logical operations (right 
shift), 917, 1051 
INDEX 
Input, 61,359 
»=. &t Bitwise logical operations 
(shift right and assign), 1053 
,. Sa 
Conditional expression ?:, 266, 
1053 
Regular expression, 83 1-832, 837, 
838-839, 1134 
II. &t 
Array of (in declaration), 627, 1062 
Regular expression (character 
class). 837, 1133 
Subscripting, 579-590. 628, 1064 
\ (backslash). Sa 
C haracter literal, 1043 
E SCH[>C character, 1133 
Regular expression (escape charac-
ter). 830-831 , 837, 841 
' . Sa 
Bitwise logical operations (exclu· 
sive or), 917- 918, 1052, 1057 
Regular expression (not), 837, 
1134 
A=, &t Bitwise logical operations (xor 
and assign), 1053 
_. &tUnderscore, 75, 76, 1045 
1I.&t 
Block delimiter, 47, 11 0 
Regular expression (range), 83 1. 
837-839, 1133- 1134 
I. Sa 
Bitwise logical opemtions (bitwise 
or), 917, 1052, \057 
Regular expression (or), 83\ - 832. 
837,840-84 1, 1134 
I =. Sa Bitwise logical operations (or 
and assign). 1053 
II. &t Logical or, 1053, 1057 
-.Sa 
Bitwise logical opera lions (comple-
ment), 917,1050 
Destructors, 586-588 
o (zero). &t 
Null pointer, 583-584 
PrerDc, 378, 380 
prinlfO format sl>ccifier, 1142 
Ox. set l~rtx ,378. 3 80 

INDEX 
A 
ii, append ftle mode, 11 40 
\a alen, charnclcr lilcral. 1043 
aOOrl(), 1149 
ab$(), absolUiC valuc, 879, 1137 
complex. 88 1, 1139 
AbslrnCI classes. 487. 1171 
class hiernrchies, 503 
creating. 487. 503-50'1, 1080-1081 
Shape example, 487-488 
Abstracl·fir.it approadl to progranuning, 
10 
Abstraclion, 92-93. 1171 
level, ideals, 778-779 
Access cOlllrol. 302, '196. 50 1-502 
base classes. 501 -502 
encapsulation. 496 
members. 484- 485 
private, 496, 50 1- 502 
private by default, 302-303 
private us. public, 302-304 
privale: label. 302 
protcctcd. 496, 502 
prolectc<i: label, 502 
public. 302. 496, 50 1-502 
public by default, 303-304. ,xt also 
slrucl. 
public: label. 302 
Shape example, 488-49 1 
accumulaleO. 729, 739-740, 1139 
accumulator. 739 
generalizing. 740-742 
acosO, arccosine. 879, 1137 
Action. 47 
Activation record. 284. SaaJ.so Stacks. 
Ad hoc polymorphism, 659- 661 
Ada lallgua~. 796-798 
Adaptors 
bindlslO. 11 23 
bind2ndO, 11 23 
container, 1 106 
funaion objects, 1123 
mem_funO. 1123 
mem_fun_refO, 1123 
noll 0 . 1123 
noI2{), 1123 
priority_queue, 1106 
queue, 1106 
5Iad:, 1106 
addO. 445, 483-484, 600-602 
Add (plus) +, 66, 1051 
Add and assign +=, 66, 73, 1053 
Additive operators, 105 1 
Address, 574, 11 71 
unchecked conversions, 905 
Address of (unary) &, 574, 1050 
adjaeent_differeneeO, 739, 1139 
adjaeenU indO, 1113 
advanceO, 600-602, 708-710, 1103 
AJTordability, software, 34 
Age distribution example, 527-528 
Alert markers, 3 
Algol family of languages, 791-798 
Algol60 language, 792-794 
<algorithm>, 729, 1095 
Algorithms, 1171 
and containers, 696 
header liles, 1095-1096 
numerical. 1139 
passing arguments to. Sa Function 
objccts. 
Algorithms, numerical, 739, 1139 
aeeumulateO, 729, 739-742, 1139 
adjacenCdifference{), 739, 1139 
inner_produet(). 729, 739, 742-744, 
1139 
parlial_sumO, 739. 1139 
Algorithms, sn... 1112- 111 3 
<algorithm>, 729 
binary_searchO, 764 
comparing elements, 729 
copyO, 728. 757-758 
copy_ifO, 757 
copying clements, 728 
counlO, 728 
count...,ifO,728 
i!(luaIO, 729 
equal_r;mgeO. 728, 763-764 
find(), 728, 729- 732 
fi nd_if 0 , 728, 732-734 
heap, 111 9- 1120 
luwer_boundO, 764 
max, 1121 
1183 

1184 
Algorithms, ST1. (tOIl/iliUM) 
mergeO, 728 
merging sOl'lcd sequences, 728 
min, 11 2 1 
modifying sequence, 1114- 11 16 
mutating sequence, 11 14-1116 
nonmodifying sequence, 1113-
1114 
numerical. &t Algorithms, !lumeri-
aU. 
pcmllltalions, 11 20 
searchO. 763- 76,1 
searching, 1117- 1118. &to (UJo 
findO; findjfO. 
sct, 111 8- 11 19 
shumc. 1115- IIJ6 
5Or10, 728, 762- 763 
soning. 728, 762- 763, 1117-
111 8 
summing clements, 729 
tcsting, 961- 968 
unique_copyO, 728, 757, 760- 761 
upper _ooundO, 764 
utility, 1116- 111 7 
value comparisons, 1120- 11 2 1 
Aliases, 1089, 11 71. $«aho References. 
Allocating memory 
See aw Dcalloc;tling lllemory: 
Memory. 
alioca tor_lype, 1108 
bad_alloc c.:'l:ccption, 1058 
C++ and C, 1009- 10 iO 
(allocO, 11 47 
embedded systems, 897-898, 902-
904 
free store, 578-579 
mallocO. 1009, 1147 
new, 1057-1058 
pools, 902-903 
real1ocO, 101O 
stacks, 903-904 
allocatouype. 1108 
Almost containers, 721-722, 1106 
alnurn, regex character class, 842, 
1134 
alpha, regex character class, 842. 1134 
IN DE X 
Alternation 
patterns, 192- 193 
regular exprcssions, 840- 84 1 
Ambiguous function call, 1067- 1068 
Analysis, 35, 174. 177 
and, synonym for &. 1003, 100'1 
and_t'q, synonym for &=, 1003, 100'1 
app mode, 385, 1126 
appendO. 815, 11 32 
Append 
files, 385. 1140 
string +=, 815 
Applic.;ttion 
collection of programs. 1172 
operator 0, 735- 736 
Approximation. 52 1- 526, 1172 
Arccosine. acosO, 879 
Arcsine, asinO, 879 
Arctangent, atanO, 879 
argO, of complex number, them. 881. 
1139 
Argumellt deduction. 664-665 
Argumellt errors 
callee rcsl>Orlsibility. 141 - 143 
caller responsibility, 140- 141 
reasons for. 142- 143 
Arguments, 270, 1172 
fonnal. & ( Parameters. 
fUlictions, 1068- 1069 
passing. &t Passing argumcnts. 
program input. 91 
source of o:ccplions, 145- 1'16 
tcmplatcs, 1083- 1084 
l)'pCs, class interfaccs, 3 19-321 
unchecked. 995- 996, 1068- 1069 
unexpected. 134 
Arithmetic if f:, 266. &( abo Condi-
tional expression. 
Arithmetic operations. &t Numerics. 
array standard library class, 718-719. 
1105 
<array>. 1095 
Arrays, 627-628, 1172 
Sa abo Containers: vector. 
II declaration, 627 
1 J dereferencing. 628 

INDEX 
accessing clements, 628. 863-865 
assignment, 633 
associative. &1: Associative contain· 
ers. 
built-in, 718- 719 
C-style strings, 633-634 
copying, 632 
dereferencing. 628 
clement numbering, 627 
initializ.ing, 582-583, 633-634 
multidimensional, 859-861. 1065 
palindrome example, 638-640 
passing pointers to arrays, 905-
912 
pointers to clements, 628-631 
range checking, 628 
subscripting II. 628 
tenninating z.ero. 633 
vector alternative. 909- 912 
Arrays and pointers, 630- 636 
debugging, 634- 637 
asinO, arcsine. 879, 1137 
asm. assembler insert, 1003 
Assemblers, 785 
Assertions 
assertO, \026- \027 
<casser!:>, 1097 
debugging. 161 
definition, lin 
assignO, 1 \09 
Assignment =, 69- 73 
alTays, 633 
assignment and initializ..1tion, 69-
73 
composite assignment operators, 
73-74 
containers, 1108-1109 
Date example. 305-306 
enumerators, 314 
c. .... prcssions, 1053 
string, 815 
vector, resizing, 653- 655 
Assignmellt operators (composite), 66 
%=, 73, 1053 
&=, 1053 
"=, 73, 1053 
+=, 73, 1053, 1103 
- =, 73, 1053. 1103 
1=, 73, 1053 
«=, 1053 
»=, 1053 
"=, 1053 
1=, 1053 
Associative arrays. &1: Associative con· 
tainers. 
Associative containers, 744, 1 \05 
email example, 820- 824 
header files. 744 
map, 744 
mullimap, 744, 824- 825 
multisel, 744 
operations, 1111 - 1112 
sel, 744 
unordered_map, 744 
unordered_multimap, 744 
unordered_multisel, 744 
unordered_set, 744 
Assumptions, tcsting, 976-978 
alO, range-checked subscripting, 668-
669, 1109 
alanO, arctangent, 8i9, 1137 
ate mode, 385, 11 26 
alofO, string to double, 1146 
aloiO, string to into 1146 
alolO, string to long, 1146 
AT&T Bell Labs, 803 
AT&T L1bs, 803 
aUachO lIS. addO example, 483-484 
Automatic storage. 577 
auto_ptr, 678 
Axis example, 420-422, 439, 518-521 , 
532- 534 
B 
b, binary file mode, 1140 
Babbage, Charles, 797 
backO, last clement, 708, 1109 
backJ nserlerO, 1122 
Backus, john, 788 
Backus-Naur (BNF) Form, 788, 793 
badO slre<UII slate, 349, 1127 
1185 

1186 
bad_aUoc exception. 1058 
B.1lanced trees, 748-750 
Base-2 number system (binary), 1042 
Base-8 number system (octal). 1041 -
1042 
Base-IO 
logarithms, 879 
number system (decimal), 1041-
1042 
Base-I 6 number system (hexadecimal), 
104 1- 1042 
Base and member inilializers, 3 10, 471, 
543 
Base classes, 485-488, 496-499, 1172 
abstract classes, 487, 503-504, 
1080-1081 
access COntrol. 50 1-502 
derived classes, 1078-1079 
description, 496-497 
initialization of, 417, 543 
interface, 503-505 
object layout, 497-499 
overriding, 500-50 1 
Shape example, 487-488 
vinual function calls. 493. 498-
499 
vplr, 498 
viM, 498 
Basc-c exponemials, 8i9 
Basic guarantee, 677 
basic_siring, 816 
BCPL language, 803 
begioo 
itcr:l.Ior, 1109 
numeric example, 121- 122 
Siring, 8 15, 1132 
veclor, 695 
Bell "Ielephone Laboratories (Bell 
~1 bs), 801 , 803- 806, 988- 989 
Bentley,John, 895, 926 
Bidirectional iterator, 1104 
bidirectional iterators, 722-723 
Big-O notation, complexity, 573 
Binary 110 , 386-389 
binary mode, 385, 1126 
Binary number system, 1042 
INDEX 
Binary search, 728, 747, 763- 764 
binary_searchO. 764, 11 17 
bindlstO adaptor, 11 23 
bind2ndO adaptor, 1123 
bitand, synonym for &, 1003, 1004 
Bitlid ds. 917, 928- 930, 1082 
bitor. synonym for I, 1003. 1004 
Bits, 78, 9 16, 1172 
bitlicids. 9 17 
bool.917 
char, 9 17 
enumerations, 9 17 
integer types, 9 17 
manipulating, 926-928 
signed. 922-926 
size. 9 16-9 17 
nvo's complement. 922 
unsigned, 922- 926 
<bilsel>, 1095 
bilst't, 920-922 
bitwise logical operations. 922 
construction, 92 1 
exceptions, 1099 
110 .922 
Bitwise logical operations. 9 17-920. 
1057 
and &, 9 17-9 18, 1052, 1057 
and and assign &=, 1053 
complement -. 917 
exclusive or ", 9 17-9 18.1052, 
1057 
exclusive or and ,LSsib'll "=, 1053 
left shift « . 9 17 
left shift and assign « =. 1053 
or 1, 917-918. 1052. 1057 
or and ,LSsign, 1 =, 927 
right shift » , 917 
right shift and assi&"1 »=. 1053 
Black·box testing. 952- 953 
Blackboard, 36 
blank, charactcr class, regell:. 842, 1134 
Block, 1 JO 
debugging. 159 
delimiter 0 , 47, 1 JO 
nesting within functions, 268-269 
try block, 144- 145 

INDEX 
Block comment /* ... */, 237 
Blue marginal alerts, 3 
BNF (Backus-Naur) Fonn, 788, 793 
Body, functions, 113 
bool, 63, 66-67, 1062 
bit space, 917 
biLS in memory, 78 
C++ and C. 992, 1003, 1004 
silt, 78 
boolalpha. manipulator, 1129 
Boolean conversions, 1055 
Borland, 796 
Bottom·up approach, 9, 776-777 
Bounds error, 147 
Branching, testing, 966- 968. See abo 
Conditional statements. 
break, case label tel1nination, 104- 107 
Broadcast functions, 867 
bsearch(), 1149 
Buffer, 342 
nushing, 239-240 
iostream, 402 
overnow, 639, 759, 966. &e abo 
gctsO, scanf(). 
Bugs, 156, li n 
See (lbo Dcbugging; -resting. 
finding the last, 164- 165 
first documenled, 790 
regression testS, 953 
Built-in types, 300, 1062 
arrays, 718- 719, 1064- 1065 
bool, 77, 1063 
characters, 77, 855, 1063 
default constructors, 323 
exceptions, 1087 
noating-poim, 77, 855-858, 1063 
integers, 77,855-858,922-926, 1063 
poimers, 574-586, 1063- 1064 
references, 277- 278, 1065- 1066 
Button example, 439, 548-550 
attaching to menus, 558 
detecting a click, 544-546 
"Next," 418-420, 54 1-542 
Byte, 78, lin 
operations, C-style strings, 1014-
1015 
c 
.e sufEx, 995 
.cpp, suffIX, 48, 1154 
G* language, 796 
C++ language, 804-806 
See abo Progranuuing; Programs; 
Software. 
coding standards, list of, 943 
portability, II 
usc for teaclling, xxiv, 6-9 
C++ and C, 988- 990 
C functions, 994-998 
C linkage convention, 999 
C missing features, 991-993 
calling one from !he other, 998- 1000 
casts, 1006- 1007 
compatibility, 990- 991 
eonst, 1020- 1021 
eonstanLS, 1020- 102 1 
container example, 1025-1031 
definitions, 1004- 1006 
cnum, 1008 
cxlcrn "C", 999 
family tree, 989 
free·store, 1009- 10 11 
input/output, 1016- 1020 
keywords, 1003-1004 
layout rules, 1000 
macros, 1020-1025 
malloc(), 1009 
namespaces, 1008 
nesting slrucls, 1003 
old-style casLS, 1006 
opaque types, 1026 
perfonnance, 990 
rcallocO, 10 10 
structure tags, 1002-1003 
type checking, 998-999 
void, 996 
void", 1007- 1008 
"C flfst " approach to programming, 9 
C language, 800-804 
See abo C standard library. 
C++ compatibility, 988-990. &r 
also C++ and C. 
11B7 

1188 
C language (amlinlltd) 
K&R. 802, 988-989 
linkage collvention, 999 
missing features. 991-993 
C standard library 
C -stylc strings. 1145-1146 
header files, 1097 
input/output. See C-stylc liD 
(sldio). 
memory, 1146- 11 47 
C-slyle caSts, 1006-1007, 1051. 1058 
C-stylc: 110 (sidio) 
%, conversion specification, 1141 
conversion sf)(:cifiI:3tions, 1141 -
1143 
file modes. 1140- 11 4 1 
fues, opening and d osing, 1140-
1l4 ! 
fprintfO. 10 17, 1141 
getchO. 1018, 1145 
getchar{). 1010, 1017- 1019, 1145 
se150, 1018, 1144-1145 
output [annaLS, user-defmed types, 
11 44 
padding, 1143 
printfO, 1016- 1017, 1141 
sc.anfO, 1017- 1019, 1144- 1145 
stderr, 1144 
stdin, 1144 
stdoul. 1144 
rnmc.1Iion, 11 43 
C-stylc strings, 633-634, 1011 -1013, 
1145 
byte operations. 1014-1015 
from string, c_slrO. 344, 8 15 
consl, 1013-1014 
copying. 10 12- 1013, 1015 
cxccuting as a command, systemO, 
11 49 
lexicographical comparison, 1012 
operations, 1146 
poimcr declaration, 1015- 1016 
strcal(). concatenatc, 1012- 1013 
strchrO, find character, 1014 
strcmpO, comp<kTC, 10 11- 10 13 
strcpy(), cop}" 1012- 1013, 1015 
strlenO, length of, 1012 
slrncatO, 10 12- 10 13 
slrncmp(), 1012- 10 13 
slrncpyO. 1012-10 13 
three-way comparison. 1012 
CAD/CM-1, 27, 33 
INDEX 
Calculator cxamplc, 172. 185- 186 
analysis and design. 174-177 
expressiono , 194-198 
geuokenO, 194 
grammars and programming, 186-
193 
parsing. 188- 191 
primaryO, 194, 206 
symbol tablc, 246 
termO, 194, 195-200, 204-205 
Token, 182- 183 
Token_stream, 204- 212. 239-240 
Call stack, 287 
C.,lIIXtck functions, 544-546 
Callback implementation, 1162- 11 63 
Calling functions. &t Function calls. 
calloeO, 1147 
Cambridge University. 803 
capacityO, 65 1- 652, 1II 1 
Capitallellefli. &t Case. 
Case (of ehal.leters) 
fOnlltllling, 393-394 
identifying, 393 
islowerO,393. 113 1 
map container. 750 
in names, 74- 77 
sensitivity, 393-394 
lolower(), changing case, 394, 113 1 
IOllpper(j, clmnging case, 394, 
113 1 
case labcls. 104- 107 
<casseTb , 1097 
Casting away canst. 594-595 
Casts 
Srt aJ.ro Type com'ersion. 
C++ and C, 992, 1003 
C-style casts, 1006- 1007 
casting away consl, 594 
consl_cast, 1058 
dynamic_cast, 894, 1058 

INDEX 
lexicaCcast example, 8 19 
narrow_cast example. 151 
reinterpre,-casl. 594 
static cas!, 594, 905, 1058 
unrelated types, 594 
CAT scans, 30 
catch. 145, 1003 
Catch all exceptions ... , 150 
Catching exccptions, 144-150, 238-
240. 1087 
cb_nexiO example. 544- 546 
<cctype>, 1097. 1131 
edIO.879, 1137 
cerr, 149, 1125, 114'1 
<cerrno>, 1097 
<dioal>, 1097 
Chaining operations, 178-179 
char type, 63, 66- 67, 78 
oits, 917 
ouih-in. 1062 
propenics, 712-713 
signed ur. unsigned, 858, 925 
Character classes 
list of, 1134- 1135 
in regular exprcssions, 837-838, 
842 
Character classification, 393- 394, 
113 1 
CharaCter literals, 159, 1043 - 1O '~4 
CHAR_HIT limit macro, 1136 
CHAR_MAX limit macro. 1136 
CHAR_MIN limit macro. 1136 
d n. 61 
C equivalent. Sa stdin. 
standard character input, 61, 341. 
11 25 
Circle example, 464-467, 489 
us. Ellipse, 467 
Cireular reference. See Reference (cir-
cular). 
class, 181 , 1002-1003 
Class 
aostract, 487, 503-504, 1080- 108 1. 
&t {/Lw Abstract class. 
base, 496-497 
coding standards, 941 -942 
concrete, 487-488, 1172 
cons! member functions. 1073 
constructors, 1075- 1077, 1081 
copying. 1077- 1078, 1081 
creating objects. Sa Concrcte 
classes. 
dcfault consm.tctors, 322-325 
defining, 210, 30 I , 1071, 1172 
derived. 496 
destructors, 1077. 1081 
encapsulation, 496 
friend declaration. 1073- 1074 
generated operations. 1081 
grouping related, 503-504 
hierarchies, 503 
history of, 799 
implcmeillation, 302-304 
inheritance, 496-497, 504- 505 
interface, 504-505 
member acccss. Sa Access COntrol. 
naming. See Namespaces. 
nesting. 268 
ooject layout, 497-499 
organizing. &t Namespaces. 
parameterized. 659-66 1. Sa aIJc 
Templates. 
private, 302-304, 496. 501 -502, 
1071 - 1072 
protected, 487, 496, 501-502 
public, 302- 304. 496, 50 1-502, 
1071 - 1072 
nm-time polymorphism, 496 
suoclasses, 496-497. See alw De-
rived class. 
supcrclasses, 496-497. Sa aLw Base 
class. 
templates, 658-661 
testing. 973-976 
this pointer, 1073 
types as parameters. SaTem-
plates. 
union, 1082-1083 
unqualified name, 1072 
uses for, 30 I 
Class interfaces, 3 18, 1071 
argument types, 319-321 
1189 

1190 
const member functions, 325-326 
constants, 325-326. &e abo const. 
copying, 321-322 
helper functions, 326-328 
immutable: vaiues, 325, 326 
initializing objects, 322-325 
members. 326-328 
mutable values, 326-328 
public w. private, 302-304 
symbolic constants, defining, 32 1 
uninitializcd variables. 322-325 
C lass members, 301, 1071 
-> (arrow), 1072 
. (dot}, 302, 1072 
:: (scope resolution), IOn 
accessing, 302. Sa abo Access con-
trol. 
allocated at same address, 1082-
1083 
bidiclds, 1082 
class imcrfaces, 326-328 
data, 301 
definitions. 1074- 1075 
function. 309-313 
in -class definition, 1074-1075 
sialic const int members, 1075 
Token example, 181- 182 
Token_streilm example, 210 
Out-or-class definition, 1074-1075 
Class scope, 264, 1046 
Class template 
parameterized class, 659- 66 1 
param(:terized type, 659- 661 
specialization, 658- 659 
type generators. 658-659 
classic_elimination() example, 874- 875 
Cleaning up code 
comments, 236-237 
functions, 233-234 
layout, 234-236 
logical separations, 233-234 
revision history, 236- 237 
scaffolding, 233-234 
symbolic constants, 23 1-233 
clearO, 349-352, 1110 
<climits>. 1097 
<clocale>, 1097 
clockO, 98 1-983 
clock_t, 1147 
cloneO example, 496 
closeO rue, 346 
INDEX 
Closcd_I)Olyline example, 451 -453 
us. Polygon, 453 
<cmath>, 879, 1097, 1137 
cnlrl, 842, 1134 
COBOL language, 788-790 
Code 
definition, 1172 
layout, cleaning lip, 234-236 
libraries, uses for. 175 
stomge, 577 
structure, ideals. 776 
test coverage, 968 
Coding standards, 935-936 
C++, list of, 943 
complexity, sources of. 935-936 
ideals, 936-937 
sample rules, 938- 943 
Color example, 421 -422, 445-447 
color chat example, 459- 461 
fLlI, 427- 428, 456-458, 492 
transparency, 447 
Columns, matrices, 864-865, 870 
Comments, 45-46 
block ' •.. . ·', 237, 1040 
C++ and C. 992 
cleaning up, 236-237 
w. code, 237 
line II, 45-46, 1040 
role in debugging, 157- 158 
Common Lisp language. 790 
Communication skills, programmers, 22 
Compacting garb..1gc collection, 900-
901 
CompMison, 67 
S« abo ==: <. 
C-stylc strings. 101 1- 1012 
characters, 711 
containers, 1111 
key_compare. 1108 
lexicographical. C-style srrinb'S, 
1012 

INDEX 
lexicographicaCcompare(), 1121 
minimax algorit.luns. 11 20-1121 
string. 815 
three-way. 10 12 
Compatibility. &e C++ and C. 
Compile-time errors. &e Errors, 
compile-time. 
Compiled languagcs, 47-48 
Compilers. 48. 1172 
compile·time errors. 51 
conditional compilation, 1024-
1025 
syllla.'I: checki.ng. 48-50 
compl, synonym for - , 1003, 1045 
complex 
!=, nO( equal (inequality). 881. 
1138 
" multiply, 881, 1138 
+, add (plus), 881, 1138 
- , subtract (minus), 88 1. 1138 
« , output. 881, 1139 
==. equal, 881. 1138 
», input. 881. 1139 
I. divide, 881, 1138 
alisO, absolute value, 881 , 1139 
coniO, cOl~ugate, 881 
Fortran language, 882 
imagO, imaginary part, 881 
normO, squarc of alisO, 88 1 
number types. 1138-1 139 
polarO, polar coordinate. 881 
realO, real part, 881 
rho. 881 
square of absO, 881 
theta, 88 1 
<complex> 1096 
complex operators. 881, 1138-1139 
standard mat.h functions, 1137 
Complex numbers, 880-882 
Complexit.y, 11 72 
sources of, 935-936 
Composite assiglUllelll operators, 73-74 
Compound statements, 110 
CompUL1.tion, 91 
Sa abc Programs; Software. 
corrcCUless, 92-94 
data SU1.lctures, 90 
efficiency, 92-94 
inpuuoutput, 91 
objeClives, 92-94 
organizing programs, 92-94 
programmer ideals. 92-94 
simplicity, 92- 94 
state, definition, 90 
Computation UI. data, 691- 693 
Computer-assisted surgery, 30 
Computer science, 12.24-25 
Computers 
CAT scans, 30 
computer-assisted surgery, 30 
i..n daily life, 19-21 
i..nfOimation processing. 31- 32 
Mars Rover, 32-33 
medicine, 30 
pen-asivencss of, 19- 21 
server fanns. 3 1 
shipping, 26-28 
space exploration, 32-33 
telecommunications, 28-29 
timekeeping, 26 
world tmal. 19 
Concatenation of strings. 66 
+,68-69, 815. 1132 
+=, 68-69, 815, 1132 
Concept-based appro.1.ch to program-
ming, 6 
Concrete classes, 487-488, 1172 
Concrete-first appro..1.ch to program-
ming, 6 
Concurrency, 894 
Conditional compilation, 1024-1025 
Conditional expression t:, 266, 1053 
Conditional statements 
Sa auo Branching. tcsting. 
for, 110- 11 2 
if, 101 - 103 
switch, 104-107 
while, 108-109 
Conforming progrnms, 1039 
Confusing variable namcs, 77 
coniO, complex conjugatc, 881. 11 38 
CoI~ugatc, 88 1 
1191 

1192 
Consistency. ideals, 780 
Console, as user interface, 540 
Console input/output, 540 
Console window, displaying. 160 
COoSI, 95-96 
Sa also Constant; SL1tic storage, 
sialic coosl. 
C++ and C, 992, 1020- 1021 
C-style Strlngs, 1013-1014 
class intcrfaces, 325-326 
declarations, 260-261 
initializing, 260 
member functions. 325-326. 1073 
overloading on, 626-627 
passing arguments by, 273-276, 
279-281 
type, 1062 
·coosl, immutable pointer, 1062 
Constant 
Sa alw consl. 
expressions, 1056- 1057 
consLcast, casting away const, 594, 1058 
coosUleralor, 1108 
Constraints, veclar range checking, 670 
Constructors, 306-309, 1075-1077 
See abo Dcstructors; lnitializers. 
containers, 1108-1109 
copy, 614- 616, 620-624 
Dale example 307, 319-321 
debugging, 622-624 
default,322-325,1081 
error handling 309, 675-677 
esscmial operations, 620-624 
exceptions, 675-677 
explicit, 621- 622 
implicit coIlversions, 621 - 622 
initializalion of bases and members, 
310,471, 543 
invariant, 309, 676-677 
nced for default, 620- 621 
Token example, J 82- 183 
Token_stream example, 210 
Container adaptors, 1106 
Containers, 146, 720-72 1, 1172 
Sa also Arrays; lisl; map; vector. 
and algorithms, 696 
INDEX 
almost containers, 72 1- 722. 1106 
assignmcnts, 1108- 1109 
associative, 1105, 1111 - 11 12 
capacityO, 1110- 1111 
of cllaracters. Set string. 
comparing, III1 
constructors, 1108- 1109 
contiguous storage, 712 
copying, 1111 
destructors, 1108-1109 
clement access, 1109 
embedded systems. 912-9 16 
header ftles, 1095- 1096 
infonnation sources about, 720-721 
iterator categories. 722- 723 
iterators. I 109 
list operations, 1110 
member typcs, 1108 
operations overview. 11 07 
queue operations, 11 10 
sequence. 1105 
sizeO, 111O- 1111 
stack operations. 1110 
standard library, 1105-1111 
swapping, 1111 
templatcs, 661-662 
Contents of · (dereference. indirec' 
tion), 579-580 
Comiguous storage, 712 
Comrol characters, iscntri(), 393 
Comrol inversion, GUIs. 556-557 
Control variables. 109 
Comrols. Sa Widgets. 
Conversion specifications. priotfO. 
1141 - 1143 
Convcrsion 
Sa aJ.w 1}'pc conversion. 
character c.1se, 394 
representation, 368-370 
unchecked. 905 
Coordinates 
Set also Poiot. 
computcr screens. 1115-'116 
graphs, 422-423 
copyO, 757- 758, 1114 
Copy assignmenLS, 616- 618, 620-624 

INDEX 
Copy constructors. 614-616, 620-624 
copy_backwardO, 1114 
copy_if 0 .757 
Copying, 613-6 19 
arrays, 632 
Cstyle strings, 1012-1013, 1015 
class interfaces, 32 I -322 
cont.tiners. I I I I 
I/O streams. 758-761 
objects, 494-496 
sequences, 728, 757- 762 
vector. 6 13-618, 1108-1109 
Correctness 
definition, 1172 
ideals, 92-94, 775 
importance:: of, 891-892 
software, 34 
cosO. cosine. 5 17-518, 879, 1137 
coshO. hyperbolic cosine, 1137 
Cost, definition. 1172 
count(). 728. 1113 
counUfO, 728, 1113 
coul, 45 
C equivalent. &to sidoul. 
~Hdlo. World!n example. 45-46 
printing error messages, 149. &e 
abo cerro 
st'lIldard output, 341 , 1125 
Critical systems, coding standards, 
942-943 
<cslddef>. 1097 
<csldio>. 1097 
<csldlib>. 1097, 11 47, 1149 
c_slrO. 1132 
<cslring>. 1097. 1131, 1147 
<clime>, 1097, 1147 
Current object, 3 12-3 13. &to also this 
pointer. 
Cursor. definition, 45 
<cwchar>. 1097 
<cwclype>. 1097 
D 
d, any decimal digit, regcx, 842, 1134 
\d. decimal digit, regex. 837, 1135 
\ 0 , not a decimal digit. regex, 838, 1135 
d suffix, 1042 
Dahl, Ole-johan, 798-800 
Data 
&to (llJo Containers; Sequences; 
veclor; map; lisl. 
abstraction, 781 
collections. &to Containers. 
Uf. computation, 69 I -693 
generalizing code, 688-690 
in memory. &to Free store. 
processing. overview, 686-690 
separating from algorithms, 696 
slOring. &to Containers. 
structure. St(! Containers; sIrucl; 
class. 
traversing. See Iteration; herators. 
unifonn access and manipulation, 
688-690. &to alJo STL. 
Data member, 30 I , 484-485 
Data structure. &to Data; slrucl. 
Data type. &toTypc. 
Date and lime, 1147- 1149 
Date example. Set Chapters 6-7. 
DBl_EPSll0N limit macro, 1137 
DBl_MAX limit macro, 1137 
DBl_MIN limit macro, 1137 
Deallocating memory, 584-586, 1057-
1058. &to alJo delete; delete[ I. 
Debugging, 52, 156, 1172 
&to also Errors; Testing. 
arrays and pointers, 634- 637 
assertions, 161 
block tenninatioll. 159 
bugs, 156 
charac[er literal temlination, 159 
commenting code, 157-158 
compile-time errors, 159 
consistent code layout, 158 
conSlructors, 622-624 
declaring names, 159 
displaying the console window, 
160 
expression tcmlinatioll, 159 
fInding the last bug, 164-165 
function size, 158 
1193 

1194 
Debugging ((I}I!tillutd) 
CUb, 562-564 
input data, J 64 
invariants, 160-161 
keeping it simple, 158 
logic errors, 152- 154 
matching parentheses, 159 
nanling convcntions, 158 
post-conditions, 163- 164 
pre-conditions. 161 - 163 
process description, 156- 157 
reporting errors, 157 
stepping through code, 160 
string literal tcnnination, 159 
systematic approach, 164-165 
test cases, 164,225 
testing, 979 
tracing code execution, 160- 161 
transient bugs, 581 
using library facilities, 158 
widgets, 563-564 
dec manipulator, 378-379. 1130 
Decimal digits, isdigilO, 393 
Decimal integer literals, 1041 
Decimal number system, 377- 379, 
1041 - 1042 
Deciphering (decryption), example, 
930-935 
Declaration operators, 1062 
& reference lO, 273-277, 1062 
() functiollof, 112- 114, 1062 
• pointer to, 573, 1062 
[I array of, 627, 1062 
Declarations, 51, 1061- 1062 
C++ and C, 992 
c1asscs, 302 
collections of. Sa Header files. 
constants, 260-26 1 
definition, 5 1, 77, 255, 1173, 1061-
1062 
w. definilions, 257- 258 
entitics used for, 259 
ellern keyword. 257 
forward, 259 
function, 255-256, 1066 
funclion arguments, 270-271 
INDEX 
function retum lype, 270-271 
grouping. Stt Namespaccs. 
managing. Sa Header files. 
need for, 259 
order of, 2 13-2 14 
parts of, 1061 
subdividing programs, 258- 259 
"undeclarcd idcmificr" errol'S, 256 
uses for, 1061 
variables, 258, 260- 261 
Deeremeilling--, 97- 98 
iterator, 110 1- 1104 
pointer, 630 
Deep copy, 6 19 
Default eonstntetors. 323-324 
altemati\'cs for, 324-325 
for built·in types. 323 
initializing objects, 322-323 
necd for, identifying, 620- 62 1 
uscs for, 323-324 
.:define, 1090- 1091 
Definitions. 77, 256-257. 1173 
Sa abo Declarations. 
C++ and C, 1004-1006 
w. declarations, 257-258 
fUllction, 112- 114,270-271 
delete 
C++ and C. 992, 1003 
dealtocaullg free storc, 1057- 1058 
dcstn lctors, 586-590 
embeddcd systems, 894, 898-90 1, 
90 1-902 
free·store deallocation, 584-586 
in unary exprcssions. 105 1 
delelell, 585, 105 1. 1057-1058 
Delphi language, 796 
Dependencies, testing. 962- 963 
Depth·first approach to programming. 
6 
dCllue, double ended queuc, 1105 
<deque>, 1095 
Derefcrellcclilldirectioll 
' ,579-580. Set also COlltents of. 
->,593. Sc.-e also Member access. 
[I, 116- 117. &t(llso$ubscripting. 
Derivation, classes, 496 

INDEX 
Derived classes, 496. 1173 
access conlfOL 501-502 
base classes, 1078- 1079 
inhelilll.nce, 1078- 1079 
multiple inheritance, 1079 
object layout, '~97-499 
overview, 496-497, 1078-1079 
private bases and members, 501-
502 
protected bases and members, 502 
public bases and members, 502 
specifying, 499 
virtual functions, 1079- 1080 
Design, 35. 174, 177, 1173 
Design for testing, 978- 979 
Destructors, 586-588, 1077, 1173 
See abo Constructors. 
containers, 1108-1109 
debugging, 622-624 
default, 1081 
esscntial operations, 620-624 
execptions. 675-677 
and frec store, 589- 590 
freeing resources, 3 18, 675- 677 
generated. 588-589 
RAIl, 675-677 
virtual, 589-590 
where needed, 621 
Device drivers. 340 
Dictionary examples, 121 - 123, 756 
differeneeO, 1103 
difference_type. 1108 
digit, character class, 842, 1134 
Digit, word origin, 1041 
Dijkstra, Edsger, 792-793, 952 
Dimensions, matrices, 862-865 
Direct c."pressioll of ideas, ideals, 777-
778 
Dispatch, 496 
Display model, 409- 410 
Divide I, 66,105 1 
Divide lind assign 1=, 67, 1053 
Divide and conquer, 93 
Divide-by-zero error, 199- 200 
dividesO, 1123 
Domain knowledge, 896 
Dot product. Set inner_producIO. 
double floating-point type, 63, 66-67, 
78, 1062 
Doubly-linked lists, 598, 698. Set auo 
list. 
drawO example 
fill color, 492 
line visibility, 492 
Shape, 491-494 
draw_linesO example 
Set auo drawO example_ 
Closed_polyline, 452 
Marked_polyline, 469 
Open_polyline, 451 
Polygon, 454-455 
Rectangle, 459 
Shape, 491- 494 
Dynamic dispatch, 496_ Set auo Virtual 
functions_ 
Dynamic memol)'_ Set Free store. 
dynamiccast, type conversion, 1058 
exceptions, 1099 
predictability, 894 
E 
Efficiency 
ideals, 92 -9 '~ , 775- 776 
vector range checki.ng, 670 
Einstein, Albert, 780 
Elements 
Set also vector. 
numbering, 627 
pointers to, 628- 63 1 
variable number of, 628 
Ellipse example, 466-468 
m. Circle, 467 
else, in if-statements, 102-103 
Email example, 820-830 
Embedded systems 
coding standards, 935- 937, 943 
concurrency, 894 
containers, 912-9 16 
correctness, 891 - 892 
delete operator, 894 
domain knowledge, 896 
1195 

,,% 
Embedded systems (wlllillued) 
dynamiccasl, 894 
error handling, 895-897 
examples of. 888-890 
exceptions, 894 
fault tolerance, 892 
fragmentation, 898, 899 
free-store, 898-902 
hard real time, 893 
ideals, 894- 895 
maintenance, 891 
mcmOly management, 902- 904 
new operator, 894 
predictability, 893, 894 
real-time constraints, 893 
real-time response, 890 
reliability, 890 
resource leaks, 893 
resource limitations, 890 
soft real time, 893 
special concerns, 890- 891 
Ellipsis ." 
arguments (unchecked), 1068-
1069 
catch all exceptions, 150 
Empty 
emplyO, is comainer empty?, 11 11 
lists. 702 
sequences, 702 
statements, 100 
Encapsulation, 496 
Enciphering (Encryption), example, 
930-935 
endO 
itcrator. 1109 
Siring, 815, 1132 
vector, 695 
End of line $ (in regular expressions), 
837, 1134 
End of file 
eorO, 349. 1127 
me streams, 360 
lIO error. 349 
stringstream, 390-391 
Ending programs. See Terminating. 
programs. 
endl manipulator, 1130 
ends manipulator, 1130 
INDEX 
English grammar us. programming 
grammar, 191- 192 
cnum, 314-317, 1008. See alsQ Enumer-
ations. 
Enumerations, 314-317. 1070 
enum, 314-3 17, 1008 
enumerators. 3 14-317, 1070- 1071 
EOF macro. 10 19-1020 
cofO stream state, 349, 1127 
cqualO, 729, 1113 
Equal ==, 67, 1052 
Equality operators, expressions, 1052 
cqualJ angcO, 728, 763- 764 
cquaUoO, 1122 
e raseO 
list, 713-715, 1110 
list operations, 600- 602 
string, 815. 11 32 
vector, 715- 718 
crrno, error indicator, 880, 1138 
crrorO example, 140- 141 
passing multiple strings, 150 
~ ullca ught c. ... ception" elTor, 151 
Error diagnostics, templates, 661 
Error handling 
See alsQ Errors; Exceptions. 
% for floaring-point numbers, 
228-231 
catching exceptions, 238- 240 
fLies fail to open, 385 
GUls.563 
hardware replication, 896 
liD errors. See 110 errors. 
liD streams, 1127 
mathematical elTQrs, 880 
modular systems. 896- 897 
monitoring subsystems, 897 
negative numbers, 227- 228 
positioning in files, 389 
predictable en-ors, 895 
recovering from errors, 238- 240 
regular expressions, 842-844 
resource leaks, 896 
self-checking, 896 

INDEX 
SllJ (St:Uldard Template Library), 
1098-1100 
tcsting for errors, 224-227 
transiclll errors, 895-896 
vector resource exceptions, 677 
Error messages 
Sa a/.w I.'rroro; Reponing errors; 
runtime_error. 
exceptions, printing, 148- 149 
templates, 661 
writing your OWI\, 140 
Errors, 1173 
oS« al.w D<:bugging; Tcsting. 
classifying, 132 
compile-time, 48-50, 132, 134-135 
detection ideal. 133 
crrorO, 140- 141 
estimating resultS, 155- 156 
incompletc prograIltS. 134 
input format, 64-65 
link·time, 132, 137-138 
logic, 132, 152-154 
poor sl>ccifications, 134 
rcco\'ering from, 238-240. Set also 
Exceptions. 
sources of, 134 
syntax, 135-136 
translation units, 137-138 
type mismatch, 136-137 
undcclared identifier. 256 
unexpected argulllents, 134 
unexpected input, 134 
unexpected state, 134 
Errors, nm-time, 132. 138-140 
See also Exceptions. 
callee responsibility, 141-143 
caller responsibility, 140-141 
hardware violations. 139 
reasons for, 142- 143 
reponing, 143-144 
Estimating development resources, 175 
Estimating results. 155- 156 
Examples 
age distribution. 527- 528 
calculator. Sa C1.Iculator example. 
Dale. Stt Date example. 
deciphering, 930-935 
deleting repeated words, 71-73 
dictionary, 121- 123, 756 
Dow J oncs tracking, 750-753 
email analysis, 820-830 
embedded systems, 888- 890 
enciphering (encryption), 930-
935 
exponential function, 5 17-5 18 
finding largest elemcnt, 687-690, 
696--697 
fruits, 747-750 
Gaussian climination, 874-876 
graphics. 410-414, 432 
graphing data, 527-528 
graphing functions, 517-518 
GUI (graphical user interface), 
552-556, 560-561,563-564 
Hello, World!, 45-46 
intrusive containers, 1025-1031 
lines_window, 552-556, 560-561, 
563-564 
link, 598--607 
list (doubly linked), 598-607 
map container, 747-753 
Matrix. 872-877 
palindromcs, 637-641 
Pool allocator, 902-903 
Punccstream, 397-401 
reading a single value, 353-357 
reading a Structurcd me. 361-370 
regular expressions, 844-849 
school table. 844-849 
searching, 828-836 
sequences, 696--698 
Stack allocator, 903- 904 
TEA ('Iiny Encryption Algorithm), 
930-935 
tcxt editor, 704-711 
vector. Sa vector example. 
Widget manipulation. 552-556, 
1167- 1170 
windows, 552-556 
word frequency, 745-477 
writing a program. Sa Calculator 
example. 
1197 

1198 
Examples (continual) 
writing rues, 346-348 
ZI P code detection, 828-836 
cc)(ception>, 1097 
Exceptions, 144- 148, 1086 
Sa abc Error handling: Errors. 
bounds error, 147 
C++ and C, 992 
c .. tch, 145,238-240, 1087 
cerr, 149 
cout, 149 
d CSlniClors, 1088 
embedded systems, 894 
error messages, printing, 148-149 
exception, 150, 1099- 1100 
failure to catch, 15 1 
GUIs,563 
input, 148-151 
narrow_casl example. 151 
olT·by~nc error, 147 
ouc oCrange, 147 
overview, 144-145 
RAJ I (Resource Acquisition ls Ini-
tialization), 1087 
range errors, 146-148 
fe-throwing, 677, 1087 
runtime_error, 140, 149. 15 1 
Slack unwinding, 1088 
standard library exceptions. 1099-
1100 
tcnninating a program. 140 
throw, 145. 1086 
truncation. 151 
type conversion, 151 
uncaught exception, 151 
ust:r-dcrUlcd types. 1087 
\'('clor range checking, 668-669 
vector resources. Sa veclor. 
E.,xecutable code, 48. 1173 
Executing a program. II . 11 54 
ellitO. terminating a program. 1149 
ellplicit constructor. 62 1- 622. 1003 
Expression, 94-95. 1049-1054 
coding smlldards, 940-9;11 
constant expressions. 1056-1057 
conversiolU. 1054-1056 
debugging, 159 
INDEX 
grouping 0, 95, 83 1, 837. 840 
lvaiue, 94-95, 1054 
magic constants, 96, 141, 231-233, 
697 
memory management. 1057- 1058 
mixing types. 98-99 
non'obvious literals, 96 
0l>crmor p!'(:cedellce, 95 
opc.rators,97, 1049- 1059 
order of opc.r.uiolls. 179 
p!'(:cedellce, 1054 
preserving values, 1054-1055 
promotions, 98-99, 1054-1055 
rvalue, 9 '~-95 , 1054 
scol>C !'(:solution, 1049 
I)'IX couversion, 98-99, 1058-
1059 
usual arithmctic conversions. 1056 
E;'(pression statement. 99 
Empty statement. 1001 
elliern. 257, 999 
Exlr.lCling text from files, 820-825. 
828-830 
F 
f/f sufflX, 1042 
fail() stream state, 349, ) 127 
Falling through end of functions. 2i2 
faiSt', 1003-1004 
Fault tolerance, 892 
fclosc(), 10 19- 1020, 1140 
Feature ottp. 186, 199, 1173 
Feedback. programming, 36 
l-icJds, fonnauing. 383-384 
FILE, 1019-1020 
E le 110, 343-344 
binary 110. 387 
convening represcntations. 368-
370 
c!oscO. 346 
closingfiles, 346, 1140-1141 
modes, 1140-1141 

INDEX 
open(), 346 
opening flies. Su Opening files. 
positioning in flies, 389 
reading. Su Reading fIIcs. 
writing. Sa Writing flies. 
Eles, 11 73 
&ealJo Etc 110 . 
C++ and C, 1019-1020 
opening and closing, C·sty[c lIO, 
1140-1 141 
fillO, 1116 
Ell color cxamplc, 456-459, 492 
filCnO, 111 6 
findO, 728-731 
associativc containcr ol>cr,lIions, 
1111 
finding links, 600~602 
generic usc, 731~732 
non modifying sequencc alga· 
rithms, 11 13 
string operations, 815, 1132 
find~end O , 1113 
find_firsCof(), 1113 
findjf(), 728, 732-734 
Finding 
Set abo Matching; Scarching. 
associative container operations, 
11 11 
clcmcnts, 728 
links, 600-602 
pattcrns, 828- 830, 833-836 
strinb'S, 815, 1132 
fixed format, 383 
fixed manipulator, 381, 1130 
f10ill t)1>C, 1062 
<float.h>, 858, 1136 
Floating']>oint, 63, 855, 1173 
% remainder (modulo), 199 
assigning integers to, 856-857 
assigning to intcgcrs, 857 
collvcrsions, 1055 
fixed fonnat, 383 
generill format, 383 
input, 180, 199-200 
intCb ..... JI convcrsions, 1055 
litcrals, 180, 1042- 1043 
mantissa, 857 
OUtput, formatting, 380- 381 
prccision, 382-383 
and fCill numbcrs, 855 
rounding, 382-383 
scientific format, 383 
trullcation, 857 
vector example, 11 9- 121 
000rO, 879, 1137 
FLT_DlG limit mllCro, 1137 
FLTK (Fast Light "Ioolkit), 414, 11 58 
code ]>ortability, 414 
color, 447, 459-461 
current style, obtaining, 492 
downloading, 1158 
fill,459 
in graphics code, 432 
installing, 1159 
lines, drawing, 449, 452-453 
outlines, 459 
rectangles, drawing, 459 
tesling, 1160 
in VISUal Studio, 1159-1160 
waiting for user action, 547-548, 
556-557 
FLT_MAX limit macro, 1137 
FLT_MAX~ 1 0_EX P limit macro, 1137 
FLT_MIN limit macro, 1137 
flush manipulator, 1130 
Hushing a buITer, 239-240 
FOnlS for Graphics example, 463-464 
fopenO, 1019-1020, 1140 
for·stalement, 110-112 
Ford, Henry, 772 
for_each(), 1113 
Formal arguments. Su Parameters. 
Fonnatting 
SaalJolIO strcams, 11 28-1129. 
SaalJoC-style 110, 1016-1019. 
Saa/so Manipulators, 1129-1130. 
case, 393-394 
fields, 383-384 
precisioll, 382-383 
whitcspace, 393 
1199 

1200 
Fortran language, 786-788 
array indexing, 863 
complel, 882 
subscripting, 863 
Forward declarations, 259 
For-vard ilcrawrs, 722-723, 1103 
fprintf(), 1017, 1141 
Fragmclll.1Iion, embedded systems, 
898, 899 
free(), deallocate, 1009-1010, 1147 
Free store (heap slOrage) 
allocltion, 578-579 
C++ and C, 1009- 10 II 
deallocation, 584--586 
delete, 584-586, 586-590 
and dCSlruCIOf'S. Sa destructors. 
embedded systems, 898-902 
garbage collection, 585 
leaks, 58.1- 586, 586-590 
new, 578-579 
object lifetime, 1048 
Freeing memory. Sa Dcallocating 
memory. 
friend, 1003, 1073-1074 
from_slring() example, 817-818 
fronlO, first clement, 1109 
fronl_inserter(), 1122 
fslream{), 1126 
dstream>, 1096 
fstream type, 344-346 
Fully qualified names, 291-293 
function example, 439, 5 15-518 
FUllction, 47, 112- 114 
Sa abo Member functions. 
acccssingclass members, 1073- 1074 
arguments. &e Function argu-
ments. 
in base classes, 496 
body, 47, 113 
C++ and C , 994-998 
callback, CUls, 544-546 
calling, 1066 
cleaning up, 233- 234 
coding standards, 940-94 1 
common style, 482-483 
debugging, 158 
declarations, 115-116, 1066 
ddinition, 11 2, 269,1 173 
in derived classes, 493, 496 
falling through, 2n 
INDEX 
fom)al arguments. See Function pa-
rameters. 
friend declaration, 1073-1074 
generic code, 483 
global variables, modifying, 267 
graphing. Sa FunClion example. 
inline. 3 12, 992 
link.a~ specifications, 1069 
naming. Sa Namespaces. 
nesting, 267 
organizing. Set Namespaces. 
ovcrload resolution, 1067- 1068 
overloading, 3 16-318, 516, 992 
parameter, 113. Sa abo Function 
parameters. 
poimer to, 1000-1002 
posHonditions, 163-164 
prc-<:onditions, 161-163 
pun:: virtual, 1175 
requirements, 151 , Set abo Pre· 
conditions. 
return type, 47, 270-271 
return, 112- 113,271-272, 1066 
standard mathematical, 518, 1137-
1138 
types as p.1rameters. Set Tcmplates. 
uses for, 114-115 
virtual, 1000- 1002. Set also Virtual 
functions. 
Function activation record, 284 
Function argument 
Sa aJ.w Function parameter: 
Parameters. 
chccking, 281 - 282 
conversion, 28 1-282 
declaring, 270- 271 
fomlal. Set Parameters. 
naming, 270- 27 1 
omitting, 270 
passing. Sa Function call. 
FUllction call, 282 
() operator, 735-736 

IND EX 
C<1.11 stack, 287 
c:cpression() call example, 284-287 
function activation record, 284 
history of, 785 
memory for. 577 
pass by consl rderence, 273-276, 
279-281 
pass by lIon·consl reference, 279-
28 1 
pass by rderence, 276-28 1 
pass by value, 273, 279-28 1 
recursive. 286 
stack growth, 284-287. ~alJo 
Function activation record. 
temporary objects, 280 
Function·like macros, 1022-1023 
Function member 
definition, 301-302 
same lIame as class. ~ 
Construc· 
tors. 
Function object, 734-736 
o function call operator, 735-736 
abstract view, 736- 737 
adaptors, 1123 
arithmetic operations, 1123 
parameterization, 736-737 
predicates, 737-738, 1122-1123 
Function pammeter (fomlal argument) 
... ellipsis, ullchecked arguments, 
1068 
pass by const referellce, 273-276, 
279-281 
pass by Ilon-coost reference, 279-281 
pass by reference, 276-28 1 
pass by value, 273, 279-28 1 
temporary objects, 280 
unused, 270 
Function template 
algorithms, 659- 661 
argument deduction, 664- 665 
parameterized functions, 659-661 
<functional>, 1095, 11 22-1123 
Functional cast, 1058 
Functional programming, 788 
Fused multiply·add, 868 
G 
Gadgets. Set Embedded systems. 
Garbage collection, 585, 900-90 I 
Gaussian elimination, 874-875 
gcounl(), 1128 
general fornlat, 383 
general manipulator, 381 
generate{), 111 6 
generate_nO, 111 6 
Generic code, 483 
Generic programming, 659-66 1, 782, 
1173 
Geometric shapes, 423 
gelO, 1128 
gelc(), 1018, 1145 
getchar(), 1019, 1145 
getline(), 391-392, 815, 819, 11 28 
gets!), 1018 
C++ alternative » , 1019 
dangcrous, 1018 
scanfO, II44-1145 
geuokenO example, 194 
GIF images, 473-475 
Global scope, 264, 267, 104-6 
Global variables 
functions modifying, 267 
memory for, 577 
order of initialization, 288-290 
Coing 0 0l of scope, 266-267, 287 
goodO stream state, 349, 1127 
GP. ~ 
Generic programming. 
Grammar example 
alternation, pattenlS, 192-193 
English granmIar, 191-192 
Expression e.xample 186-191 , 195-
198,200-201 
parsing, 188-191 
repetition, pattcnlS, 192-193 
rules w. tokens, 192- 193 
sequencing rules, 192-193 
terminals. Sa Tokens. 
writing, 187, 192-193 
Graph.h, 417-4 18 
Graphical uscr intcrfaces. &t CUb. 
Graphics, 408 
1201 

1202 
Graphics (col/HI/ued) 
See also Color; Graphics example; 
Shape. 
display modeL 409-410 
displaying, 472-475 
drawing on screen, 419-420 
encoding, 473 
fIlling shapes, 427 
fonnaLS, 473 
geometric shapes, 423 
G I F, 473-475 
graphics libraries, 474-475 
graphs, 422-423 
images from files, 429-430 
importance of, 408-409 
j PEG, 473~475 
line style, 427 
loading from files, 429-430 
screcn coordinates, 4 1 5~416 
selecting a sub-picture from, 473 
user interface. See G U Is (graphical 
user interfaces). 
Graphics example 
Graph.h, 417-418 
G UI system, giving control to, 
419 
header files, 417-418 
mainO, 4 17-418 
Poinl.h, 440 
poinLS, 42 2~423 
Simp l e~window. h , 440 
wait~for_hu\ton O , 419 
Window.h, 440 
Graphics example, design principles 
access control. See Access control. 
a\tachO us. addO, 483~484 
class diagram, 497 
class size, 481 -482 
common style, 482-483 
data modification access, 484-485 
generic code, 483 
inheritance, interface, 504-505 
inheritances, implementation, 504~ 
505 
mutability, 484-485 
naming, 483-484 
IND EX 
object-oriented progranuning, ben-
efits of, 504~505 
operations, 482-483 
private data members, 484-485 
protected data, 484-485 
public data, 484-485 
types, 480-482 
width/height, specifying, 482 
Graphics example, GUI classes, 438~ 
440 
&e abo Graphics example (interlaces). 
Bulton, 439 
In~box , 439 
Menu, 439 
Out_box, 439 
Simple~window , 418-420, 439 
Widget, 548-550, 1163-1164 
Window, 439,1 164- 1166 
Graphics example, interfaces, 438-
439 
See aUQ Graphics example (G U I 
classes). 
Axis, 420-422, 439, 518-52 1 
Circle, 464-467, 489 
Closed_polyline, 451-4-53 
Color, 445-447 
Ellipse, 466-468 
Function, 439, 514-518 
Image, 439, 472-475 
line, 441-444 
lines, 443-445, 489 
line_style, 448-450 
Mark,470-472 
Marked_polyline, 468-469 
Marks, 469-470, 489 
Open_polyline, 450-451 , 489 
Point, 422-423, 44 1 
Polygon, 423- 424, 453-455, '~89 
Rectangle, 424-427, 455-459, 489 
Shape, 440-44 1, 445, 485-499. 
504- 505 
Text, 427-429, 462-464 
Graphing data example, 527-534 
Graphing functions example, 5 10-514, 
52 1-526 
GraphJih namcspace, 417-418 

INDEX 
Graph example 
See also Grids. 
Axis, 420--422 
coordinates, 422--423 
drawing, 422- 123 
points. labeling. 468-469 
grealerO, 1122 
Greater thilll >, 67, 1052 
Greater than or equal >=. 1052 
greater_equaIO, 11 22 
Green marginal alerts, 3 
Grids, drawing, 444- 445, 448-450 
Grol'ping reglllar expressions, 831, 
837, 840 
Guaramees, 676- 678 
GUI system, giving control to, 419 
Guidelines. Sa Ideals. 
GUls (graphical user interfaces), 540-
541 
Sa abo Graphies CJlample (G U I 
classes). 
caUback functions, 544-546 
callback implementation, 1162-
1163 
ch_nexlO examplc, 544-546 
common problems, 562- 564 
control inversion, 556- 557 
conlrols. Sa Wldgcts. 
coordinates, eomputcr screens, 
415--4 16 
debugging, 562-564 
error handling, 563 
examples, 552- 556, 560-56 1, 
563-564 
exceptions, 563 
Fr.:rK (Fast Light l oolkit), 414 
layers of code, 544-545 
ne~tO CJlample, 546 
pixels, 415-416 
portability, 4 14 
standard library, 414-415 
system tests, 969-973 
toolkit, 414 
veclor of references, simulaling, 
1166- 11 67 
vector Jcf example, 1166-1 167 
H 
wait loops, 547-548 
wail_for_bullonO examplc, 547-548 
waiting for user action, 547-548, 
556-557 
Widget example, 548-556, 1163-
1164, 1167- 1170 
Window example. 552-556, 1164-
11 66 
.h file suffix, 46 
Half open sequenecs, 694- 695 
Hard real-time, 893, 942 
Hardware replication, error handling, 
896 
Hardware violations, 139 
Hash function, 753-754 
Hash tables, 753 
Hash values, 753 
Hashcd container. See unordered_map. 
Hashing, 753 
Header files, 46, 1173 
C standard libralY, 1097 
declarations, managing, 261- 262 
definitions, managing, 261-262 
graphics example, 417- 4 18 
including in source files, 262-264, 
1090- 1091 
multiple inclusion, 1025 
standard library, 1095-1097 
Headers. See Headcr files. 
Heap algorithm, 1119- 1120 
Heap memory, 897- 898. See (liso Free 
store. 
Hejlsberg, Anders, 796 
~H ello , World!" program, 45- 47 
Helper functions 
!= inequality, 328 
== equality, 328 
class interfaces, 326-328 
Dale example, 305-306, 327 
namcspaces, 328 
validity checking date values, 306 
hex manipulator, 378-379, 1130 
Hexadecimal digits, 393 
1203 

1204 
Hexadecimal number system. 377- 379, 
1041 - 1042 
Hiding information, 1173 
Hopper. Grace Murray, 789- 790 
Hyperbolic cosine, cosh(), 879 
Hyperbolic sine, sinhO, 879 
Hyperbolic tangent, lanh(), 879 
I 
1/0 errors 
badO stream state, 349 
dearO, 349-352 
end of file, 349 
eoiO stream state, 349 
eITOr handling. 1127 
fai tO stream state, 349 
goodO stream state, 349 
ios_base, 351 
stream Stales. 349 
recovering from, 349-352 
unexpected errors, 349 
ungetO, 349-352 
110 streams, 1124-- 11 25 
«
output opcr<lIor. 8 19 
»
input operator. 8 19 
cerr, standard elTOT output stream, 
149, 11 25, 1144 
do smndard input. 341 
class hierarchy, 819, 1126- 11 27 
CQut standard OUtpUi. 341 
error handling, 1127 
fomlauing, 1128- 1 J 29 
fstream, 384-386, 389, 1126 
ge10, 819 
gellioeO. 8 19 
header files, 1096 
ifstrcilm, 384-386, 1126 
input operations, 1128 
input streams, 34 1-343 
iostream library, 34 1- 343, 1124-
1125 
islream, 34 1-343, 11 25-11 26 
iSlringstream, 11 26 
of sIre am, 384-386, 1126 
oSlream, 341-343. 11 24-11 6 
INDEX 
oSlringslream.384-386, 1126 
output operations, 1128- 11 29 
Output streatns, 341 - 343 
standard manipulators, 378. 1129-
113 1 
standard streams, 1125 
states, 11 27 
stream bc:havlor, changing. 378 
stream buffers, slreamoufs, 1125 
stl'eam lIlodes, 1126 
sIring, 819 
slringslream, 390-39 1, 1126 
throwing exceptions, 1127 
unfonnatted input, 1128 
IBM, 786- 788 
Ichbiah.Jean, 797 
I DE (interactive development environ-
ment), 52 
Ideals 
abstraction level, 778- 779 
boHom·up approach. 776- 777 
class interfaces. 3 18 
code SlrUcturc. 776 
coding standards, 936- 937 
consistency, 780 
COlTeCt approaches. 776- 777 
correctness. 775 
definition, 1173 
direct expression of ideas. 777- 778 
efficiency, 775-776 
embedded systems, 894-895 
imponance of, 8 
KISS, 780 
maintainability, 775 
minimalism, 780 
modularity. 779- 780 
on·time delivery, 776 
overview. 774-775 
perfonnance, 775- 776 
software. 34- 37 
top·down appfO.1ch. 776-777 
Identifiers. 1045. Sa abo Names. 
reserved. 75- 76. See alw Keywords. 
if-statements, 101-103 
=ifdd, 1024-1025 
::ifndef, 1025 

INDEX 
ifslream type, 344-346 
imagO, imaginary pan, 881 , 1139 
Image example, 439, 472-475 
Images. Set Graphics. 
Imaginary pan, 881 
Immutable values, class interfaces, 
325-326 
Implementation, 1173 
class, 302-304 
inheritance, 504-505 
programs, 35 
lmplementation·defined feature, 1039 
Implicit conversions, 62 1-622 
In·class member definition, 1074- 1075 
in mode, 385, 11 26 
In_box example, 439, 550-551 
#include, 46, 262-264, 1090 
Include guard, 1025 
includes{), 111 9 
Including headers, 1090- 1091. Set olw 
:tinclude. 
Incremenling ++, 66, 695 
iler.J.tors, 694-695, 721 , 1101-1104 
pointers, 630 
variables, 73-74, 97- 98 
Indenting nested code, 269 
Inequality != (not equal), 67, 1052, 
1064 
complex, 88 1, 1138 
containers, 1111 
helper function, 328 
iteralors, 695, 1102 
siring, 67, 815, 1132 
Infinite loop, 1173 
Infinite rcolrsion, 196, 1173 
Infonn:lIion hiding, 1173 
Infonn:uion processing, 31-32 
Inheritancc 
class diagr.un, 497 
defiuition, 496 
derivcd classes, 1078- 1079 
embedded systems, 912- 916 
history of, 799 
implementation, 504-505 
interface, 504-505 
multiple, 1079 
pointers tI.f. references, 598 
tcmplates, 66 1-662 
Initialization, 69-73. 1173 
arrays. 582-583. 633-634 
constants, 260. 324-325, 1062 
conSlmctors, 306-309 
Dale example, 305-309 
default. 26 1. 322-323, 1048 
invariants, 309, 676-677 
menus, 558 
pointer targets, 582-583 
pointers, 582-583, 635 
Token example, 183 
inJine, 1003 
Inline 
functions, 992 
membcr functions, 312 
inner-producl{), 729 
Set olw Dot product. 
description, 742-743 
generalizing, 743- 744 
matrices, 868 
multiplying sequences, 1139 
standard library, 729, 739 
inplace_mergeO, 1118 
Input, 60-62 
Setolw 110 slrcams; Input ». 
binary 110, 386-389 
C++ and C, 1017-1019 
calculator example, 177, 180, 183-
184, 199-200, 204-206 
case sensitivity, 64 
cin, standard input stream, 61 
dividing functions logically, 353-
356 
fLIes. Set FLle 110. 
fomlat errors, 64-65 
individual characters, 392-394 
integers, 379-380 
iSlringslream, 390 
line-oriellled input, 391-392 
newline character \n, 61-62, 64 
potemial problems, 352-357 
prompting for, 61, 177 
separating dialog from function, 
356-357 
1205 

1206 
Input (rontinud) 
a series of values, 350-352 
a si.ngle value, 352-357 
source of exceptions, 148-151 
Slringslream, 390-391 
tab character \ 1, 64 
terminaring, 61-62 
type sensitivity, 64- 65 
whitespacc, 64 
Input » , 61 
case sensitivity, 64 
complex, 881, 1139 
formatted input, 1128 
multiple values per statement, 65 
strings, 815, 1132 
text input, 815, 819 
uscr·dcfmcd, 359 
whitcspace, ignoring, 64 
Input devices, 340-341 
Input itcrators, 722- 723, 1103 
Input loops, 359-36\ 
Input/output, 341-343 
See abo InpUl: Outpm. 
buffering, 342, 402 
C++ and C. See sldio. 
computation overview, 91 
device drivers, 340 
errors. Sa liD errors. 
files. Sa File 110 . 
fOm1.1Uing. £r Manipulators; printfO. 
iiTCgularity, 376 
istream, 34 1-348 
natural language differences, 402 
ostream, 341-348 
regularity, 376 
streams. Sa 110 streams 
strings, 8 19 
text in GUIs, 550-55 1 
whitespaee, 393, 394-401 
Input prompt >, 221 
Input streams, 34 1-343. Sa alw 110 
streams. 
Inputs, testing, 961 
insertO 
list, 600-602, 713-715 
map container. 750, 75 1 
string, 8 15, 1110, 1132 
... ector, 715-718 
inserterO, 1122 
Inserters, 112 1- 1122 
Inserting 
list clements, 713- 715 
into strings. 8 15,1 110.1 132 
... eclOT clements, 715-718 
Installing 
INDEX 
FLTK (Fast Light Toolkit), 1159 
VISual Studio, 1152 
Instantiation, templates, 658-659, 
1084- 1085 
int, integer type, 66-67, 78, 1062 
bits in memory, 78. 9 17 
Integers, 77-78. 854-855, 1174 
assigning floating·point numbers 
to, 857 
assigning to floating·point num· 
bers. 856-857 
decinlal, 377-379 
input, fom1:1tting, 379-380 
largest, finding, 879 
literals, 104 1 
number bases, 377-379 
octal, 377-379 
output, fomlatting, 377-379 
reading, 379-380 
smallest, rmding, 879 
Integral conversions. 1055 
Luegral promotion, 1054-1055 
Interactive development environment 
~ DE), 52 
Interrace das~. Sa Graphics example 
(interfaces). 
Interfaces, 1174 
classes. S« C lass interfaces. 
inheri1:1Jlce, 504-505 
user. Sa User interfaces. 
internal manipulator, 1130 
INT~MAX limit l11:1cro. 1136 
IN T~MIN limit macro, 1136 
Intrusive containers, example, 1025-
1031 

INDEX 
Invariants, 309, 1174 
Su abo PosHonditions; Pre-condi-
tions. 
assertions, 161 
debugging, 160-161 
dcCault construclOrs, 620 
documenting, 780 
Dale example, 309 
invention of. 793 
Polygon example, 455 
Invisible. See Transparency. 
<iomanip>, 1096, 1129 
<ios>, 1096, 1129 
<iosfwd>, 1096 
ioslream 
butTers, 402 
C++ and C. 1016 
exceptions, 1099 
library, 341-343 
<ioslream>, 1096, 1129 
Irregularity, 376 
is_openO, 1126 
isalnumO classify character, 393, 1131 
isalphaO classify character, 247, 393, 
1131 
iscnlrlO classify character, 393, 113 1 
isdigilO classify character, 393, 113 1 
isgraphO classify character, 393, 1131 
islowerO classify character, 393, 1131 
isprintO classify character, 393, 1131 
ispunclO classify character, 393, 1131 
isspaceO classify character, 393, 1131 
islream, 341 -343, 1125- 1126 
» , text input, 815, 1128 
» , user·defined, 359 
binary lIO, 386-389 
connecting 10 input device, 1126 
rue 110. fstream, 343-348,1126 
gelO, get a single character, 393 
gellineO, 391 -392, 1128 
siringstreams, 390-391 
unformatted input, 39 1-393, 1128 
using IOgcther with stdio, 10 16-
1017 
<islream>, 1096, 11 24, 1128- 11 29 
islream_iterator type, 758-761 
iSl.ringslream, 390 
isupperO classify character, 393, 1131 
isxdigitO classify character, 393, 1131 
Iteration 
See abo lteralOrs. 
control valiablcs, 109 
defmition, 1174 
example, 708-711 
for·statements, 110- 112 
linked lists, 701 - 703, 708- 711 
loop variables, 109 
Stri.Il~ , 815 
through values. See vector. 
while·statements, 108- 109 
ilerator, 1108 
<;Ieralor>, 1095, 1121 
Itcrators, 694- 696, 1100- 11 01 , 1174 
See abo STL iterators. 
bidirectional iterator, 722- 723 
category, 722-723, 1103-1105 
containcrs, 1109, 1104-1105 
cmpty list, 702 
cxample, 708- 711 
fonvard iterator, 722- 723 
header files, 1095- 1096 
input iterator, 722-723 
operations, 695, 1102- 1103 
Output iterator, 722-723 
VS. poimcrs, 1101 
random-access iterator, 723 
sequence of clements, 110 I- II 02 
iter _swap(), 1116 
J 
japanese age distribution example, 
527-528 
jPEG images, 473-475 
K 
Kernighan, Brian, 802-803, 988-989 
key_compO, 1112 
key_compare, 1108 
1207 

1208 
ker_type. 1108 
Key,value p.1irs, cOlilainers for, 744 
Keywords, 1003-1004, 1045- \046 
KISS, 780 
Knuth, Don, 774-775 
K&R, 802, 988 
l 
III suffix, 104 1 
\ 1, "lowercase character," rege)(, 837, 
1135 
\ l , "not lowe rc.1se.~ rege)(, 939, 1135 
Label 
access control, 302, 502 
caSC'. 104- \07 
graph example. 5 18-521 
of statement, 1059 
L:u gcst imcgcr, finding, 879 
b.ws of optimization, 893 
Layers of cooe. CUb, 544-545 
Layout mles, 939-940, 1000 
Leaks, memory, 584-586, 586-590, 
899 
Leap year, 305 
left manipulator, 1130 
Legal programs, 1039 
lenglhO, 815, 1132 
Length of strings, finding, 8 15, 1012, 
1132 
less(), 1122 
Less than <, 1052 
Less than or equal <:::, 67. 1052 
less_equal(). 11 22 
Leiters, identifying, 247, 393 
Ic)(ical_east.8 19 
LcxicOb'TIlphical comparison 
< comparison. 815, 1132 
<::: comparison, 1132 
> comparison, 1132 
>= comp.1rison, 1132 
Gstyle strings, 1012 
le.icographicaLcomparc(), 1121 
Libraries, 51, 1174 
&to alw Standard library. 
role in debugging, 158 
INDEX 
uses for, 175 
Lifctiml:, ObjCCls, 1048- 1049, 1174 
Limit macros, 11 36- 1137 
Limits, 858 
<limits>, 858, 1096, 1135 
<limits.b , 858, 1136 
Line comment II, 45 
Line example, 44 1-443 
w. Lines, 444 
Linc-oricmcd input, 39 1-392 
Linear equations example, 872-877 
baclu ubstitulion(), 874-875 
dassic climination(),874-875 
Gaussian elimination, 874-875 
pivoting, 875-876 
testing, 876-877 
Lines example, 443-445, 489 
us. Line, 444 
Lines (graphic), drawing 
Saalw drawJ inesOi Graphics. 
on graphs, 518-52 1 
line slYles, 448-450 
multiple lines, 443-445 
single lines, 441-443 
styles, 427, 449 
visibility, 492 
Lines (of text), identifying. 707 ..... 708 
line_style example, 448--450 
lines_window example, 552-556, 560-
561, 563-564 
link example. 598-607 
Link-time errors. &t Errors, link·time. 
Linkage convelilion, C. 999 
Linkage specifications, 1069 
Linked lists. 698. &to alw Lists. 
Linkers, 51, 1174 
Linking programs, 5 1 
Links, 598-602, 606-607, 699 
Lint, consistency checking program, 801 
Lisp language, 790- 791 
lisl, 700, 1107-1 111 
addO, 600-602 
advanceO, 600-602 
back(), 708 
erase(), 600-602.7 13- 715 
(indO, 600-602 

INDEX 
inserl O, 600~602 , 713-715 
operations, 600-602 
properties, 712-713 
referencing last element, 708 
sequence containers, 1105 
subscripting, 700 
disl>, 1095 
Lists 
containers, 1110 
doubly linked. 598, 698 
empty, 702 
erasing clements, 713-715 
examples, 598-600, 704-711 
lindillg links, 600-602 
getting the nth clemem, 600-602 
inserting clements, 600-602, 713-
71 5 
iteration, 701- 703, 708-71 1 
link manipulation, 600-602 
links, examples, 598-600. 606-607, 
699 
operations, 699-700 
removing elements, 600-602 
singly linked, 598, 698 
this pointer, 603-605 
Literals, 62, 1041, 1174 
character, 159, 1043-1044 
decimal integer, 1041 
in expressions, 96 
f/F suffix, 1042 
Ooating-point, 1042- 1043 
hexadecimal integcr. 1041 
integer, 1041 
IlL suffix, 1041 
magic constants, 96, 14 J, 23 I -233, 
697 
non-obvious, 96 
null poimer, 0, 1044-1045 
numbcr systems, 1041-1042 
octal integer, 1041 
special characters, 1043- 1044 
string, 159, 1044 
tellllinalion, debugging, 159 
for types, 63 
u/u suffix, 1041 
unsigned, 104 1 
Local (automatic) objects, lifetime, 1048 
Local classes, nesting, 268 
Local functions, nesting, 268 
Local scope, 265- 266, 1046 
Local variables, army pointers, 636-637 
Locale, 402 
<locale>, 1097 
logO, 879, 1137 
log100, 879, 1137 
Logic errors. Set Errors, logic. 
Logical and &&, 1052, 1057 
Logical operations, 1057 
Logical or II, 1053, 1057 
10gical_andO. 1122 
logical_notO, 1122 
logical_orO, 1122 
Logs, graphing, 517-518 
lo ng imegcr, 917, 1062 
LONG_MAX limit macro, 1137 
LONG_MIN limit macro, 1137 
Look-ahead problem, 202-207 
Loop, 109, 111 , 1174 
examples, parser, 198 
inlinite, 196, 1173 
testing, 965-966 
variable, 109, III 
Lovelace, Augusta Ada, 797 
lower, 842, 1134 
10wer_boundO, 764, 1112, 1117 
Lower case. See Case. 
Ll,celll Bell Labs, 803 
Lvalue, 94-95, 1054 
M 
Machine code. Set Executable code. 
Macro substitution, 1090-1091 
Macros, 1021-1022 
conditional compilation, 1024-
1025 
t define, 1022-1024, 1090-1091 
function·like, 1022-1023 
.::'ifdef, 1024-1025 
.::'ifndef, 1025 
tinclude, 1024, 1090 
include guard, 1025 
1209 

1210 
Macros (continI/ell) 
naming conventions, 102 1 
syntax, 1023-1024 
uses for, 1021 
Maddoc.J ohn, 830 
Magic constants, 96, 141 ,23 1-233, 
697 
Magical appro.leh 10 programming. 10 
mainO, 46-47 
arguments to, 1040 
global objects, 1040 
return values. 47, 1039-1040 
starling a program, 1039- 1040 
Mailllainability, sofnvare, 34, 775 
Maintenance. 891 
make_heapO. 11 19 
make_pairO, 751, 1124 
nlake_vecO, 677 
maliocO, 1009, 1147 
Manipukllors, 378, 1129- 1131 
complete list of, 1129-1130 
dec, 1130 
endl, 11 30 
fixed, 1130 
hex. 1130 
noskipws, 1129 
oel, 11 30 
resetiosilags{), 1130 
scientific, 1130 
setiosflags(), 1130 
setprecision(}, 1130 
skipws. 11 29 
Mantissa, 857 
map, associative array. 744- 750 
Sa (1iJO set; unordered_map. 
II, subscripting, 745, 1111 
b..llanced trees, 748- 750 
binary search lI'ees, 747 
case sensitivity, N03 ase example, 
762- 763 
counting words example. 745- 747 
Dow J ones example, 750- 753 
em:!il example, 820-836 
eraseO, 749, 1110 
finding clements in. 745. 749, 
1111 - 1112 
fruits example. 747- 750 
inserlO, 750, 751. II 10 
iterators, I 105 
key storage, 745 
make_pairO, 751 
INDEX 
N03 ase example, 750, 762-763 
Node example. 747- 750 
red·black trees, 747 
14. set. 756 
standard libralY, 1107- 111 2 
tree structure, 747-750 
without values. Sa sci. 
<map>, 744, 1095 
mappefUyfX!, 1108 
Marginal alerts, 3 
M<lrk example, 470-472 
Marked_polyline example. 468-469 
M<lrks example, 469-470, 489 
Mars Rover, 32-33 
Matching 
Sa abo Finding; Searching. 
rcgu~kf e.xprcssions, regex, 1133-1135 
te.Xt pattcms. &r Regular e.xprcssions. 
Math functions, 5 18, 1137- 1138 
Mathematics. &t NUlllerics. 
Mathematical functions, standard 
amO. absolute value, 879 
acosO, arccosine. 879 
asinO, arcsine, 879 
alanO, arctangent, 879 
cei10 , 879 
<cmath>. 879, 1096 
<complex>, 88 1 
cosO, cosine, 879 
coshO, hyperbolic cosine, 879 
erroo, error indicator, 880 
error handling. 880 
expO, natural exponent, 879 
noorO, 879 
logO, nalurallogarithm, 879 
log I 00 , base· 10 logarithm. 879 
sinO, sine, 879 
sinhO, hyperbolic sine, 879 
sqrlO, square root, 879 
tanO, tangent, 879 
lanhO. hyperbolic tangent, 879 

IND EX 
Matriccs, 863- 865, 869 
Malrix library cxample. 863-865, 869 
0 , subscripting (Fonran style), 863 
II, subscripting (C style), 860, 863 
accessing array clemcllls, 863-865 
applyD, 867 
broadcast functions, 867 
dearJow, 870 
columns, 864-865, 870 
dimensions, 862-865 
dot product, 868 
fused multiply-add, 868 
initializing, 870 
inner_product, 868 
inputloUlpUl, 870-871 
linear equations example, 874- 877 
multidimensional mauiccs, 862-872 
rows, 864- 865, 870 
scale_and_addO, 868 
sliceO. 865-866, 869 
start_row. 870 
subsClipting, 863-865, 869 
swap_columnsO, 870 
swap_fowsD, 870 
maxO, 1120-11 21 
max_elemenID. 1121 
max_sizeO, I1 11 
McCarthy, John, 791 
Mcilroy, Doug, 802, 998 
Medicine, computer usc, 30 
Member, 301- 303 
Sa also Class. 
allocated at same address, 1082-
1083 
class, nesting_ 268 
definition, 1071 
definitions, 1074-1075 
in-class definition, 1074- 1075 
out-or-class definition, 1074- 1075 
sialic consl inl members, 1075 
Member access 
Set also Access control. 
. (dot), 1072 
-> (arrow), 593, 1072 
:: scope resolution, 310, 1072 
notation, 182 
operators, 593 
Ihis pointer, 1073 
by unqualified name, 1072 
Member function 
Set aiJo Class members; Constructors; 
Dcsmlctors; Date example. 
calls, 118 
nesting, 267 
Token example, 182-183 
Member initializer list, 183 
Member selection, expressions, 1051 
Member types 
containers, 1108 
templates, 1086 
memchrO, 1147 
memcmpO, 11 47 
memcpyO, 1147 
mem_funO adaptor, 1123 
mem_funJefO adaptor, 1123 
memmoveO, 1147 
Memory, 574- 576 
addresses, 574 
allocating. Set Allocating memory_ 
automatic storage, 577 
bad3 110c exception, 1058 
C standard library functions, 
11 46-1147 
for code, 577 
deallocatillg, 584- 586 
embedded systems, 902- 904 
exhausting. 1058 
free store, 577-579 
freeing. Set Deallocating memory. 
for function calls, 577 
for global variables, 577 
heap. See Free store. 
layout, 577 
object layout, 497-499 
object size, getting, 576-577 
pointers to, 574- 576 
sizeof, 576-577 
stack storage, 577 
static storage, 577 
text storage, 577 
<memory>, 1095 
memselO, 1147 
1211 

1212 
Menu example, 439, 55 1, 557-562 
mcrgeO, 728, 1118 
Messages to the user, 55 1 
minO, 1120-11 21 
min_clementO, 1121 
Minimalism, ideals, 780 
Minus - . Sa Subu<{ction. 
minusO, 1123 
Missing copies, 624 
Mn~ 791 , 803 
Modifying sequence algorithms, 1114-
1116 
Modular systems, error handling, 
896- 897 
Modularity, ideals, 779- 780 
Modulo (remainder) %, 66. Su abo 
Remainder. 
modulusO, 1123 
Monitoring subsystems, error hmldling, 
897 
moveO, 494, 549 
Move backward - =, 1064 
Move forward +=, 1064 
Multi·parndigm progrnnulling irUlgtl<1gcs, 
783 
Multidimensional matrices, 862- 872 
muliimap, 744, 824-825, 11 05 
<muliimap>, 744 
Multiplicative operators, expressions, 
105 1 
multiplies(), 1123 
Multiply *, 66, 1051 
Multiply and assign .=. 67 
multiset, 744, 1105 
<muliiset>, 744 
Mutability, 484-485, 1174 
class interfaces, 326-328 
and copying, 494-496 
mutable, 1003 
Mutating sequence algorithms, 1114-
111 6 
N 
\ n newline, cllaraCter literal, 61- 62, 
64, 1043 
I NDEX 
Named character classes, in regular ex· 
pressions, 841 - 842 
Names, 74- 77 
_ (underscore), 75, 76 
capital letters, 76- 77 
case sensitivity, 75 
confusing, 77 
conventions, 74- 75 
declarations, 255-256 
descriptive, 76 
function, 47 
length, 76 
overloaded, 138,500, 1067- 1068 
reserved, 75-76. &t (Iiso Keywords. 
namespace, 269, 1003 
Namespaces, 290, 1088 
Sa (liM! Scope. 
:: scope resolution, 291 
C++ and C, 1008 
fully qualified names, 29 1-293 
helper functions, 328 
objects, lifetime, 1048 
scope, 264, 1046 
Sld,29 1- 292 
for the 5'11.., 1098 
using declarations, 29 1- 293 
using directives, 291-293, 1089 
variables, order of initialization. 
288-290 
Naming conventions, 74-77 
coding standards, 939-940 
enumerators, 3 16 
functions, 483-484 
macros, 102 1 
role in debugging, 158 
scope, 267 
narrow_cast example. 15 1 
Narrowing conversions, 80-83 
Narrowing errors, 151 
Natural language dilTcrc.nccs, 402 
Natural logarithms, 879 
Naur, Peter, 792- 793 
negaleO, 1123 
Neg-otive numbers, 227-228 
Nested blocks, 268- 269 
Nested classes, 268 

INDEX 
Nested functions, 268 
Nesting 
blocks within functions, 268-269 
classes within classes, 268 
classes within funcLions, 268 
functions within classcs, 267 
functions within functions, 268 
indenting nested codc, 269 
local classes, 268 
local functions, 268 
member classes, 268 
member funcLions, 267 
slrucls, 1003 
new, 578, 582 
C++ and C, 992, 1003 
and delete, 1057- 1058 
embedded systems, 894, 898- 901, 
901 - 902 
example, 578-579 
c.xceptions, 1099 
types, constructing, 1050, 1051 
<new>, 1097 
New-style caslS, 1006 
nexl_permulalionO, 1120 
NO-Lhrow guarantee, 677 
noboolalpha, 1129 
No_case example, 750 
Node example, 747-750 
Non-algorithms, testing. 961- 968 
Non-errors, 137 
Non-imrusi\'e containers, 1025 
Nonmodifying sequence algorithm, 
11 13-1114 
Nonstandard separators, 394-40 1 
normO, 881, 1138 
Norwegian Computing Cemer, 798-
800 
noshowbase, 379, 1129 
noshowpoint, 1129 
noshowpos, 1129 
noskipws, 11 29 
nol, synonym for !, 1003, 1004 
Not·confoffiling constructs, 1039 
Not !, 1050 
notl 0 adaptor, 1123 
nol20 adaptor, 1123 
Notches, graphing data example, 5 18-
52 1,532-534 
Not equal != (inequality), 67, 1052, 
1064 
nol_eq, synonym for !=, 1003, 1004 
nocequaUoO, 11 22 
nouppercase manipulator, 1130 
nth_elemenIO, 1117 
Null pointer, 583-584, 634- 635, 
1044- 1045 
Number example, 187 
Number systems 
basc·2, binary, 1042 
base-8, octal, 377-380,1041 - 1042 
base-10, decimal, 377-380, 1041 -
1042 
base-16, hexadecimal. 377-380, 
1041 - 1042 
<numeric>, 1096, 1139 
Numerical algorithms. See Algorithms, 
numerical. 
Numeries,854- 855 
absolute values, 879 
arithmetic function objects, 1123 
arrays. See Malrix library example. 
<cmath>, 879 
columns, 859 
comple)(, 88 1, 1138-1139 
<complex>, 881 
floating-poim rounding errors, 
856-857 
header fllcs. 1096 
integer and floating·poim, 856-857 
integer overflow, 854-857 
largest imeger, finding, 879 
limit macros, 1136- 1137 
limits, 858 
mantissa. 857 
mathematical functions, 879-880 
Malri)( library example, 86 1-872 
multi-dimensional array, 859-86 1 
numericJimils, 1135-1136 
numerical algoritluns, 1139 
overflow, 854- 858 
precision, 854-858 
randO, random number, 878 
1213 

1214 
Numerics (amnll/I(ll ) 
random numbers, 877- 879 
real numbers, 855. Sa a1.w Hoating-
poim. 
results, plausibility checking, 855 
rounding errors, 855 
rows, 859 
size, 854-858 
sizeof{), 856 
smallest imeb'Cr, fmding, 879 
srand{), seed random number gen· 
erator, 878 
standard mathematical functions, 
879- 880, 1137-1138 
lnlllcation, 857 
vaiarray, 1139 
whole numbers. Sa Integers. 
Nygaard, Kristen, 798- 800 
o 
.obj file sumx, 48 
Object code, 48, 1174. Sit also Exe· 
cutable code. 
Object-orientcd progrolmming, 1174 
"from day one.~ 10 
us. generie programming, 660 
for graphics. benefits of, 504- 505 
history of, 781- 783. 798- 799 
Object, 60. 1174 
aliases. Sa References. 
behaving like a fUllction. Sa Func-
Lion object. 
constructing, 182- 183 
copying, 1077- 1078, 1081 
cun'ent (this), 3 12-3 13 
Date example. 328-332 
initializing, 322-325. Sa alsQ COil-
stmctors. 
layout in memory, 304, 497-499 
lifetime, 1048- 1049 
named. &t Variables. 
Shape example, 487 
sizf'OfO.576- 577 
staLe, 30 I. Sa also Value. 
type, 77- 78 
INDEX 
value. Sa Value. 
ocl man.ipulator, 378-379. 1130 
Oclal number system, 377-379, 1041-
1042 
Off·by-onc error, 147 
of stream, 345-346 
Old·style casts. 1006 
O n'lime delivcry, ideals, 776 
Onc-dimensional (10) matrices. 865-
868 
\ 000 octal, character literal, 1043 
OOP. £t Objcct-oriemcd PfOb"famming. 
Opaque types, 1026 
opcnO, 346, 11 26 
Open modcs, 385-386 
Open shapcs, 450-451 
Opening files, 344-346 
&t also File 110. 
app mode (-append"), 385 
ate mode ("at end"), 385 
binary liles. 386-389 
binary mode. 385 
C·slyle 110, 1140- 1141 
failure to open, 385 
rue streams, 344- 346 
in mode ('"for reading"), 385 
nOllexistcllt files, 385-386 
open modes, 385-386 
out mode ("for Wtiling"). 385 
tcsling after opening. 346 
trunc mode ("tnlllcate"), 385 
Opt'n_polyline example. 450-45 1, 489 
OpelOltions, 66-69, 30 I, 1174 
chaining. 178- 179 
graphics classes, 482-483 
operator, 1003 
Operator overloading, 316 
C++ Slandard opelOltors. 317-
318 
fCStrictions. 3 17 
tlser-defined operators. 317 
uses for, 316-3 18 
Operator, 97 
! nOI, 1050 
!: nOl·equal (inequality), 1052 
& (unary) address of, 574, 1050 

INDEX 
& (binary) bilwiS(: and, 917, \052, 
1057 
&& logical and, \052, \057 
&= and and assign, 1053 
% remainder (modulo), 105 1 
%= remainder (modulo) and as-
sign, \053 
° (binary) multiply, 105 1 
° (unary) object COlllenlS, poillling 
to, \050 
0= multiply and assign. 1053 
+ add (plus), 1051 
++ incn:melll, \050 
+= add and assign, \053 
- subtract (minus), \051 
-- decrement, 1050 
-= subtract and assign, \053 
- > (arrow) member access, 1050-
\05 1 
_ (dOl) member access, 1050, \051 
I divide. \051 
1= divide and assign, \053 
:: scope resolution. 1049 
< less than, 1052 
« shift left, 105 1. Su also oslream. 
«= shift left and assign, 1053 
<:- less than or equal, \052 
:- assign, \053 
:-= equal, 1052 
> greater than, 1052 
>= greater than or equal. \052 
» shirl right, 105 1. Su (Usc 
islream. 
»= shift right and assign, 1053 
f: conditional expression (arith· 
metic if), \053 
[I subscript, \050 
" bitwise exclusive or, \052, 1057 
"= xor and assign, 1053 
I bitwise or. 1052, \057 
I = or and assign, \053 
II logic.11 or. \053, \057 
~ complement. 1050 
additive operators, 105 1 
cons,-c.asl, \050, 1058 
delete, 1051. \057- 1058 
delelell, 1051, 1057- 1058 
derererence. Set ComenlS or. 
dynamic_cast, 1050, \058 
expressions, 1049- 1059 
new, 1050, 1051, 1057-1058 
reinlerpre,-casl, 1050, 1058 
si~ C<J f, 1050, 1057 
slaticcast, 1050, 1058 
throw, 1053 
Iypeid, 1050 
Optimization, laws of, 893 
or, synonym ror I, 1003, 1004 
Order or evaluation, 287-288 
or_eq, synonym for 1=. 1003, 1004 
ostream, 341-343, 11 24- 1125 
«, text output, 815, 819 
«, user·derUled, 357-359 
binary 110, 386- 389 
connecting to output device, 1126 
rue 110, fslre3m, 343-348, 1126 
stringslreams.390-391 
using together with sldio, 1016-
1017 
<ostream>, \096, 1124, 11 29 
ostream_iterator type, 758- 761 
ostringslream, 390 
oul mode, 385, 1126 
Out·or·class member derUlition, 1074-
\075 
Out·of·range conditions, 581 
Ou,-box example, 439, 550-55 1 
oul_oerange, 147 
Output, 1174 
Set also Input/output; 110 stn::ams. 
devices, 340-341 
to rue. Set Ftle 110, writing rues. 
floating·point values, 380-381 
fomlat specifier %, 1141 
fonnalting. St( LlpUt/OutpUt (for-
matting). 
integers, 3n-379 
iterator, 722- 723. 1103 
operations, 1128- 1129 
streams. Set 110 stream model. 
10 string. See siringsiream. 
tcsting, 96 1 
1215 

1216 
Output « , 47, 67, 1129 
complex, 881 , 1139 
sIring, 81 5 
text output, 815, 819 
user-defined,357-359 
Overflow, 854-858, 1174 
Overloading, 1067- 1068, 1174 
alternative to, 516 
C++ and C, 992 
on eonsl, 626- 627 
linkage, 138 
operators. Set OperatOr overloading. 
and overriding 500 
resolution, 1067-1068 
Override, 500-50 1, 11 74 
p 
Padding, C-style 110, 1143 
pair. 1123-11 24 
reading sequence elementS, 11 12-
1113 
searching, 11 17-11 18 
sorting, 1117- 1118 
Palindromes, example, 637-638 
Paradigm, 781- 783, 1174 
l'arameteriz..1tioll. function objects, 
736-737 
Parameterized type, 659- 661 
Parameters, 1174 
functions, 47, 113 
list, 113 
naming, 270-271 
omitting, 270 
templates, 656-659, 662-664 
Parametric polymorphism, 659-661 
Parsers, 188, 193 
functions required, 194 
granunar rules, 192-193 
Expression example, 187, 195- 198, 
200-201 
rules w. tokens. 192- 193 
Parsing 
exprcssions, 188- 191 
grammar, English, 191- 192 
grammar, progranuning, 188-191 
tOkens, 188- 191 
partial_sortO, 1117 
parlial_sorCcopyO, 1117 
parliaU um{), 739, 1139 
parlilionO. 1118 
Pascal language, 794-796 
Passing arguments 
INDEX 
by eonst referencc, 273-276, 279-28 1 
copies of, 273 
modified arguments, 276-279 
by non-const reference, 279-28 1 
by reference, 276-28 1 
teml>Orary objects, 280 
unmodified arguments, 275 
by value, 273, 279-281 
Patterns. Sa Regular expressions. 
Perfonnanee 
C++ and C, 990 
ideals, 775- 776 
tcsting, 979-981 
tinung, 98 1- 983 
Permutations, 1120 
Petersen, Lawrence, 15 
Pictures. Set Graphics. 
Pivoting, 875-876 
Pixels, 415-4 16 
plusO, 11 23 
Point example, 44 1 -423 
poinler, 1108 
Pointers, 579-580 
S« aI.s6 Array; Iterators; Memory. 
• contents of, 579-580 
• poillter to (in declarations), 573, 
1062 
- > (arrow) member access, 593, 
1050-105 1 
(J subscripting, 579-580 
arithmctic, 630-631 
array. S« Pointers and arrays. 
casting. &t Type conversion. 
to class objects, 59 1-593 
conversion. Sa l "}rpc conversion. 
to current object, this, 603- 6005 
debugging, 634-637 
declaralion, C-style strings, 1015-
lOI6 

INDEX 
decrementing, 630 
definition, 573-574, 1175 
dcleted, 636 
explicit type conversion. Set Typc 
conversion. 
to functions, 1000- 1002 
incrementing, 630 
initializing, 582-583, 635 
!M. ilel'3tors, 110 1 
literal (0),1044- 1045 
10 local variables, 636-637 
moving around, 630 
to nonexistent elcmellts, 635-636 
null, 0, 583-584, 634-635, 1044-
1045 
NULL macro, 1144 
lJJ. objects pointed to, 579 
out-or-range conditions, 581 
palindromes, example, 640-641 
ranges, 580-582 
reading and writing through, 579-
582 
semantics, 619 
size, getting, 576-577 
subscripting Il, 579- 580 
this, 654- 655 
unknown, 593-595 
void·, 593-595 
Pointers and arrdys 
converting array names to, 63 1-
633 
pointc.rs to array clemc.nts, 628-
631 
Poimers and inheritancc 
polymorphism, 912-916 
a problem 905- 909 
a solution, 909- 912 
uscr-derUlcd interface class, 909-9 12 
vector a1ternativc, 909-912 
Pointers and references 
differences, 595-596 
inheritance, 598 
list example, 598-607 
this pointc.r, 603- 605 
parameters, 596-597 
polar(), 881, 1138 
Polar coordinates, 881, 1138 
Polygon example, 423-424, 453-455, 
48. 
lJJ. Closed_polyline, 453 
invariants, 455 
Polyline example 
closed, 451-453 
marked, 468-469 
open, 450-451 
lJJ. rectangles. 425-427 
Polymorphism 
ad hoc, 659-661 
embedded systems, 912- 916 
paramctrie, 659-661 
TUn·tinIc, 496 
templates, 660-661 
Pools, embedded systems, 902- 903 
Pop·up menus, 559 
pop_backO. 1110 
pop_frontO, 1110 
pop_heapO. 11 20 
l>Onability, I I 
C++, 1039 
FLIT, 414, 1158 
l>Ositioning in files, 389 
Post-conditions, 163- 164, 961-962, 
1175. Set abo Lwanants. 
l>Ost-deeremelll - - , 1050, 1064 
Post-incremcnt ++, 1050, 1064 
l>Ostfix expressions, 1050 
Pre-conditions, 161- 163, 961-962, 
1175. See abo Invariants. 
Pre-dcerelllelll --, 1050, 1064 
Prc-ineremc.1ll ++, 1050. 1064 
Precedence, in expressions, 1054 
Precision, numeric, 382-383, 854-858 
Predicates, 733 
on class members, 737-738 
function objects, 1122-1123 
passing. Set FunClion objects. 
searching, 733-734 
Predictability, 893 
error handling, 895 
features to avoid, 894 
memory allocation, 898, 902 
Preprocessing, 263 
121 7 

1218 
Preprocessor din.:ctivcs 
: define, macro substitution, 1090-
109 1 
:ifdef, 1024 
:ifndef, 1025 
tinclude, including headers, 1090-
1091 
Pn:::proccssor, 1090 
coding standards, 939 
prev_permutation(), 11 20 
Princeton University, 803 
print, chamcter class, 842, 1134 
Printable chamcters, idemifying. 393 
printfO family 
%, conversion spc:cific.ation, 1141 
conversion spc:cificatlons, 1141-
1143 
gelsO, 10 18, 1144-1145 
output fonnalS, uscr-defined types. 
1144 
padding, 1143 
printfO, 1016- 1017, 1141 
scanfO, 1017- 1019, 1144-1145 
slderr, 1144 
sldin, 1144 
stdio. 11 44- 1145 
stdout, 1144 
synchronizing with 110 streams, 
1016-1017 
truncation, 1143 
Printing 
error messages, 148-149 
variable valucs, 246 
priority_queue comainer adaptor, 1106 
Private, 308 
base classes, 502 
implcmcmation details, 208, 302-
304, 308-309 
members, 484-485, 496, 501-502 
private: label, 302, 1003 
Problelll analysis, 173 
de"clopment stages, 174 
estimating resources, 175 
problem statement, 174- 175 
prototyping, 176 
strategy, 174- 176 
INDEX 
Problem st.1tement, 174-175 
Procedural progr.lmming languages, 
781 
Programmers 
Sa (dso Programming. 
commun.icmion skills, 22 
computation ideals, 92-94 
skills n:::quin.:ments, 22-23 
stereotypes of, 21-22 
worldwide numbers of, 807 
Progranuning, xxiii, 11 75 
Sa al.w Computation; Software. 
abstract-first approadl, 10 
analysis stage, 35 
author's philosophy, 6-9 
boltom-up approach, 9 
C first approach, 9 
concept-baM:d appro.-tch, 6 
concrete-first approach, 6 
depth·first approach, 6 
design stage, 35 
environmenlS, 52 
fcedb.1ck, 36 
generic, 1173 
implementation, 35 
magical approacll, 10 
object-oriented, 10, 1174 
programming stage, 35 
softwan.: engineering principles 
first appro.1ch, 10 
stages of, 35 
testing stage, 35 
top-down approach, 10 
writing a program. Sa Calculator 
example. 
Progranuning languages, 783- 784, 
786, 807 
Ada, 796- 798 
Algol family, 791- 798 
AlgoI60,792- 794 
asM:mblers, 785 
auto codes, 785 
BCPL.803 
C, 8OO- 804 
Ct, 796 
C++,804-806 

INDEX 
COBOL, 788-790 
Common Lisp, 790 
Delphi. 796 
Fortran, 786- 788 
Lisp. 790-791 
Pascal, 794-796 
Scheme, 790 
Simula. 798-800 
Turbo Pascal. 796 
Programming philosophy, 772- 773, 1175. 
Set aLso C++ programs; Program-
ming idcals; Programming lan-
guages. 
Programming ideals 
abstraClion level, 778- 779 
aims_ 772- 774 
bOllom-up approach, 776-777 
code structure, 776 
consistency, 780 
correct approaches, 776- 777 
correctncss, 775 
data abstraction, 781 
desirable propenies, 773 
direct expression of ideas, 777-778 
efficiency, 775-776 
gencric programming, 782 
KISS, 780 
maintainability, 775 
minimalism, 780 
modularity. 779-780 
multi-paradigm, 783 
object-oriellied programming, 781-
783 
olHimc delivery, 776 
ovel>'icw, 774-775 
paradigms, 781- 783 
pcrfonnancc, 775-776 
philosophies, 772-774 
procedural. 78 1 
styles, 781-783 
top·down approach, 776-777 
Programming, history. 783-784 
Sa aLso Programming languages. 
BNF (B.,ckus-Naur) Fornl, 788, 
793 
classes, 799 
CODASYL committee, 789 
early languages, 784-786 
first documented bug. 790 
first modern stored program, 784-
786 
first progmnuning book, 785 
function calls, 785 
functional programming, 788 
inheritance, 799 
K&R, 802 
lim, 801 
object-oriemed design, 798- 799 
STL (Standard "Ie mplate Library). 
805-806 
virtual functions. 799 
Programs, 44. 1175 
Sa abo Computation; Software. 
audiences for, 46 
compiling. Sa Compilation. 
computing values. S« Expressions. 
confornling, 1039 
experimental. S« Prototyping. 
flow, u-acing, 72 
implementation defmed, 1039 
legal, 1039 
linki.ng, 51 
not-confonning constructs. 1039 
run. Sa VISUal Studio; Command 
line. 
startingc.'lccution, 46-47, 1039- 1040 
slOred on a com pUler, 108 
subdividing, 175-176 
terminating, 206-207, 1039-1040 
text of. S« Source codc. 
translation units, 51 
troubleshooting. S« Debugging. 
unspecified constructs, 1039 
valid, 1039 
writing, example. S« CaiUllator 
example. 
,mung your first, 45-47 
Program organization 
Sa abo Progranuning ideals. 
abstraction, 92-93 
divide and conquer, 93 
Projects, Visual Studio, 11 53-1154 
1219 

1220 
Promotions, 98-99, 1054-1055 
Prompting ror input, 6 1 
>, input prompt, 221 
calculator example, 177 
sample code, 220-223 
Proofs, testing, 952 
protected, 484-485, 496, 502, 1003 
Prototyping, 176 
Pseudo code, 177, 1175 
Public, 302, 1003 
base class, 500-501 
interface, 208, 488-49 1 
member, 302 
public by default, shuet, 303 
public: label, 302 
punct, punctuation character elass, 
842, 1134 
Punet_stream example, 397-401 
Pure virtual functions, 487, 1175 
push_bacl<O 
growing a vector, 118-119 
queue operations, 11 10 
resizing vector, 652-653 
stack operations, 1110 
string operations, 1132 
push_irontO, 1110 
push_heapO, 1119 
putO, 1129 
putbackO 
nanung convention, 209 
putting tokens back, 204-205 
return value, disabling, 2 10 
pulcO. 1145 
putcharO, 1145 
Putting back input, 204-206 
Q 
qsorlO, 1149 
<queue>, 1095 
queue container adaptor, 1106 
~Icue operations, 111 0 
R 
\r calTiage return, character liteml. 
1043 
INDEX 
r, reading fue mode, 1140 
r+, reading and writing fue mode, 1140 
RAIl (Resource Acquisition Is Initial-
izalion) 
definition, 1175 
exceptions, 675-676, 1087 
testing, 964-965 
for vector, 678- 680 
randO, 878, 1149 
<random>, 1096 
Random numbers, 877-879 
Random-access itcrators, 723, 1104 
Range 
definition, 1175 
errors, 146-148 
pointers, 580-582 
regular expressions, 841- 842 
Range dlcckillg 
1), 628-631 , 668- 671 
arrays, 628- 63 1 
alO, 668-669 
compatibility, 670 
constraintS, 670 
design considerations, 670-671 
efficienc)" 670 
c;>;:ccplions, 668-669 
macros, 671- 672 
optional checking, 671 
overview, 668- 669 
pointer, 628-63 1 
vector, 668-671 
rbeginO, 1109 
RC-lhrowing exceptions, 677, 1087 
rcadO, unfonnattcd input, 1128 
Readability 
expressions, 95 
indenting nested code, 269 
nestcd code, 269 
Reading 
dividing functions logically, 353-
356 
files. See Rcading files. 
with iterators, 1101 - 1102 
numbers. 212- 213 
potential problems, 352-357 
separating dialog from function , 
356-357 

INDEX 
<I series of values, 350-352 
a single value, 352-357 
into Slrings, 815 
tokens, 183- 184 
Reading flies 
binary 110, 387 
convening n:presentalions, 368-
370 
to end of file, 360 
example. 346-348 
fstream type. 344-346 
ifstream typ<:, 344- 346 
in-memory reprcsemation, 362-
364 
input loops, 359-361 
iSlream type. 343-348, 387 
oslream type, 387 
process steps, 344 
structured files, 361-370 
structured values, 3 6'~-36 8 
symbolic reprcsclltations, 368-370 
temlinator cl13racter, specifying, 
360 
realO, 881 , 1138 
Real numbers, 855 
Real part, 881 
Real-time constraints, 893 
Re'll-tillle response, 890 
reallocll. 1010, 1147 
Recovering frolll errors, 238-240, 349-
352. 5« aOO Error handling; 
Exceptions. 
R« tangle example, 424-427, 455-459. 
489 
Recursion 
definition. 1175 
infinite, 196, 1173 
looping, 198 
Recursive function calls, 286 
Red-black trees. 747. S« aOO Associative 
containers; map_ 
Red margin alerts, 3 
Reference scmantics, 619 
References. 227, 1175 
Sa aOO Aliases. 
& in decl:u~llions. 273-277 
to arguments. 274--276 
circular. See Circular referencc_ 
to last veclor clement, baekO, 708 
UJ. pointers. 5« llointers and refer-
ences. 
<regell>. 1096, 1131 
regex. Su Regular expressions. 
regell_error exception, 1099 
regell_malehO, 11 33 
w. regex_searehO, 847 
regell_searchO, 1133 
w. regell_malehO, 847 
Regression tests, 953 
Regular expressions, 830- 832, 836. 
11 75 
Sa alJo regell pattem matching. 
character classes, 837-838 
error handling. 842- 844 
grouping, 831, 837. 840 
syntax. S« regex operators. 
uses for, 830 
ZI P code example, 844-849 
regex pattem matching, 830-832 
$ end of line, 837, 1134 
o grouping, 831, 837. 840 
• zero or more occurrences, 832, 
837-838 
+ one or more occurrences, 837. 
838-839 
- range specification. 841 
. wildcard, 837 
? optional occurrence, 83 1-832, 
837, 838-839 
[I charaCter class, 837 
\ escape charactcr. 830-831. 837 
\ as literal, 8'11 
" ncgation, 837 
II start of line, 837 
{} count, 83 1, 837-839 
I altemative (or), 831 -832, 837. 
840-84 1 
altemalion, 840-841 
characlcr classes. Set reg .... charac· 
ler classes. 
character sets, 841- 842 
definition, 834 
grouping. 840 
malches. 834 
1221 

222 
regcx pattem matching «(()1!tilUl((I) 
pattem matching, 836-837 
ranges, 841 -842 
regcl_rnatchO, 1133 
regex_scarchO, 1133 
repealing patterns, 838-840 
searching with, 833-836. 844 
smatch,834 
special characters . ..s:a- regc .. opera· 
tors. 
sub'paucms. 83 1, 834 
regex operators, 837, 1133-1134 
regex character classes, 84 1-842 
alnum, 842 
alpha. 842 
blank, 842 
enlrl, 842 
d,842 
\0 , 838 
\ d, 837 
digit, 842 
graph. 842 
\ l, 838 
\1, 837 
lower. 842 
print, 842 
plmcl, 842 
regclcmalchO us. regelcsearchO, 847 
5, 842 
\5, 838 
\5,837 
space, 842 
\ U, 838 
\ U, 837 
upper, 842 
w.842 
\w,837 
\w.837 
xdigil, 842 
Regularity. 376 
reinierpreccast, 594- 595, 1058 
casting unrelated types, 594 
hardware access, 905 
Relational operators. 1052 
Reliability, software, 34. 890 
Remainder and assign %=. 1053 
INDEX 
Remainder % (modulo), 66, 105 1 
correspondence to • and I, 68 
flo.1ting·point, 199, 228-23 1 
integer and floating·point. 66 
removeO, 1115 
remove_copyO, 1115 
remove_copyjfO, 1115 
rendO, 1109 
Repeated words examples. 71- 74 
Repeating patterns, 192-193 
Repetition, 1134. Sa also Iterming: regex. 
replaceO, 111 4 
replace_copyO, 1114- 1115 
Reporting elTOrs 
Date example, 313-3 \4 
debugging, 157 
errorO, 140-141 
n Ul·time, 143-144 
syntax errors, 135- 136 
Representation, 30 I. 649-651 
Rcquirements, 11 75 
&talJo Invariants: Post-conditions: 
Pre-conditions. 
for functions, lSI 
reserveO, 651- 652, 717, 111 1 
Reserved names, 75-76. Sa abo Key· 
words. 
reseliosnagsO manipulator, 1130 
resizeO, 652, 111I 
Rcsoura::, 1175 
leaks, 893, 896 
limitations, 890 
management. Sa Resource man· 
agement. 
tcsting, 962 
vector example, 672- 673 
Resource Acquisition Is Initialization 
(RAIQ, 1175 
exccptions, 675-676, 1087 
testing, 964-965 
for vector. 678- 680 
Resource management. 672-677 
Sa abo vector example. 
allto_ptr, 678 
basic b'Uarantee, 677 
error handling, 677 

INDEX 
guarantees, 676-678 
make_vecO, 677 
no·throw b'u:tr.tntee, 677 
problems, 673- 675 
RAi l, 675-676, 678- 680 
resources, examples, 672-673 
strong guarantee, 677 
tcsting, 964- 965 
Results, 91 . Sn flUo Return valucs. 
rl.'turn statemem, 271 - 272 
Return types, functions, 47, 270- 271 
Return values, 112 
fUlletions, 1066 
110 return value, void, 2 10 
omitting. 113 
retuming.271- 272 
rc\·crseO. 1115 
reverses opyO, 11 15 
revcrsejlcralor, 1108 
Revision history, 236-237 
Rho, 881 
Richards, Marlin, 803 
right manipulator, 1130 
Ritchie, Dennis, 801, 806, 988-989. 
998 
Robot·assisted surgery, 30 
rolate(), 1115 
rolate_copyO, 1115 
Rounding, 382, 1175 
Set abo rln mcation. 
errors, 855 
floating·point values, 382-383 
Rows, matrices, 864- 865, 870 
Rules, for programming. Sa Ideals. 
Rules, b'Tammatical, 192- 193 
Run·time d ispatch, 496. Sa abo Vinual 
functions. 
Run·time errors. Sa Errors, run·time. 
Run·time polymorphism, 496 
runlimc_crror, 140, 149, 151 
R" aiues. 94- 95, 1054 
s 
5, character class, 842, 1134 
\S, "not s pace,~ regc., 838, 1135 
\ 5, "space," regex, 837, 1135 
Safe collversions, 79- 80 
Safety, type. Sa Typc, safety. 
Scaffolding, cleaning up, 233-234 
Kalc_and_addO example, 868 
scale_and_mulliplyO example, 876 
Scaling data, 531 
scanfO, 1018, 1144- 1145 
Scenarios. Sa Use cases. 
Scheme language, 790 
Kientific fonnat, 383 
scientific manipulator. 381, 1130 
Scope, 264-265, 1046- 1047, 11 75 
class, 264, 1046 
enumerators, 3 16 
global, 264, 267, 1046 
gOlng OUi of, 266-267 
kinds of, 264-265 
local, 265- 266, 1046 
namespace, 264, 269, 1046 
resolution ::, 291 , 1049 
statement, 265, 1046 
Scope ,lIld ncsting 
blocks \vilhin functions, 268-269 
classes within classcs, 268 
classes within functions, 268 
functions within classes, 267 
functions \vithul functions, 268 
indenting nested code, 269 
local classes, 268 
local functions, 268 
member classes. 268 
member functions, 267 
nested blocks, 268-269 
nested classes, 268 
nested fUllctiolls, 268 
Scope and object lifctimc, 1048-1049 
free·store objects, 1048 
local (automatic) objects, 1048 
namespaee objects, 1048 
SlattC class members, 1048 
temporary objects, 1048 
Scope and storage class, 1047- 1048 
automatic storage, 1047 
free ston:: Qleap), 1047 
slatie storage, 1047 
1223 

122' 
Screens 
Sa abo GUls (graphical user inter· 
faces). 
data graph layout. 530-531 
drawing on, 419-420 
labeling, 421 
searrnO. 763-764, 1113 
Searching 
Sa also findO; find_if 0 ; Hnding; 
Matching. 
algorithms for, 11 17-111 8 
binary searches, 747, 763-764 
in C, 1149 
for characters, 711 
(kcy,valuc) pairs. by key. &( Asso-
ciativc containers. 
for links, 600-602 
molp clements. Sa unordered_map. 
prcdicatcs, 733 
with regular expressions, 833-836, 
844- 849, 1133- 1135 
search_nO, 11 13 
Self reference. Sa Ihis. 
Self assib'llITlCnt, 654 
Self-checking, error handling, 896 
Separators. nonstandard, 394-401 
Sequence containers. 1105 
Sequences, 694, 1175 
algorithms. Sa standard library al-
gorithms. 
diffcrcntts between adjacent cle-
ments, 739 
empty, 702 
example, 696-698 
half open, 694- 695 
Sequencing rules. 192- 193 
Server farms, 31 
WI, 744, 755-757 
iterntors, 11 05 
ill. map, 756 
subscripting, 756 
wtO. 590- 591 
<set>. 744, 1095 
Sct algorithms, 11 18- 11 19 
selbase{) manipulator. 1130 
se,-diffel1'nce{), 111 9 
selfiliO manipulator, I 130 
seUnler!teClionO, 1119 
INDEX 
seliosilags() manipulator, 1130 
selprecisionO manipulator, 382- 383, 
1130 
se,-symme1ric differenceO, 11 19 
sel_unionO. 1119 
setwO manipulator, 1130 
Shallow copies, 619 
Shape example, 485-486 
abstract classes, 487-488 
access controL 488-491 
attaching to Window, 533-534 
as base class, 441, 487-488 
c1oneO, 496 
copying objects, 494-496 
drawo , 491-494-
draw_linesO, 491 -494 
fill color. 492 
implemelltmion inhcriCIllCC. 504-505 
interface inheritance, 504-505 
line visibility, 492 
moveO, 494 
mutability, 494-496 
number_oCpoints{), 445 
object layout, 497-499 
object-oriented programming, 50 '~-
505 
point t), 445 
slicing shapes. 495 
vinual functioll calls, 493, 498-
499 
Shifl operators, 1051 
Shipping, computer usc. 26- 28 
short, 917, 1062 
Shonhand notation, regular expres· 
sions, 1135 
showbase, manipulator, 379, 1129 
showpoint, manipulator. 1129 
showpos, manipulator, 11 29 
Shume algorithm, 11 15- 11 16 
Signed and unsigned integers, 922-
926 
signed type, 1062 
Simple_window, 418-420, 439 
Simplicity ideal, 92- 94 

INDEX 
Simula language, 798-800 
sinO, sine, 879, 1137 
Singly-linked lists, 598, 698 
sinhO, hyperbolic sine, 879, 1137 
Size 
bit strings, 916-917 
containers, litO- III I 
getting, sizeofO, 576-577 
of numbers, 854-858 
veclors, gctting, 118-1 I9 
sizeO 
containcr capacity, IIII 
number of clcments, 118, 815 
stringlcngth, 815, 1132 
veclors, 118, 121 
sizeofO, 576-577, 1057 
object size, t050 
value size, 856 
size_lype, 704, 1108 
skipws, 1129 
sliceO, 865-866, 869 
Slicing 
matrices, 865-866, 869 
objects, 495 
Smallest integer, finding, 879 
smalch,834 
Soft real-time, 893 
Software, 19, 1175 
Set: also Programming; Programs. 
alTordability,34 
correctness, 34 
ideals, 34-37 
mai.ntainability, 34 
reliability, 34 
troubleshooting. Set: Debugging. 
useful design, 34 
uses for, 19-32 
"Software engineering principles first" 
approach to progranulling, 10 
Software layers, GUls, 544-545 
sorlO, 728, 762-763, 1117 
sorcheapO, 1120 
Sorting 
algorithms for, 1117- 1118 
in C, qsorlO, 1149 
sorlO, 728, 762-763, 1117 
Source code 
definition, 48, 1175 
elllering, 1154 
Source files, 48, 1175 
adding to projects, 1154 
space, 842, 1134 
Space exploration, computer usc, 32-33 
Special characters, 1043-1044 
regular expressions, 1133- 11 34 
Specialization, 658- 659, 1084-1085 
Specifications 
definition, I J 75 
source of errors, 134 
Speed of light, 96 
sprinlfO, 1141 
sqrtO, square root, 879, 1137 
Square of absO, norm, 881 
srandO, 878, 1149 
<sslream>, 1096 
stable_parlitionO, 1118 
stable_sortO, 1117 
<slacb, 1096 
slack container adaptor, 1106 
Stack of activation records, 284 
Stack storage, 577 
Stacks 
container operations, 1110 
embedded systems, 902, 903-904, 
897-898 
growth, 284-287 
unwinding, 1088 
Stages of programming, 35 
Standard 
confonnancc, 801 , 935, 1039 
ISO, 1039, 1175 
manipulators. See Manipulators. 
mathematical functions, 879- 880 
Standard library 
See also C standard library; STL 
(Standard Template Library). 
algorithms. Set: Algorithms. 
comple". See comple". 
containers. See Containers. 
C·stylc 110. &t: printfO family. 
C·style mings. &t: C·stylc suings. 
date and time, 1147- 1149 
1225 

1226 
Standard library (col/tinlled ) 
function objects. See Function ob-
jccts. 
110 strmlllS. St:t Input; Input/output; 
Output. 
ilcrators. See lter-HOrs. 
mathematical functions . .S« Mathe· 
matical functions (standard). 
numerical algorithms. Sa Algo-
rillullS (numerical); Numerics. 
string. Sa string. 
lime, 982-983, 1147-1149 
valarray. &e valarray. 
Standard library header files, 1095-
1097 
algorithms, 1095-1096 
C standard libraries, 1097 
containers, 1095- 1096 
110 streams, 1096 
itcralors, 1095-1096 
numerics, 1096 
string manipulation, 1096 
utility and language support, 1097 
Standard library 1/0 streams, 1124-
1125. See 000 110 streams. 
Standard library string manipulation 
character classification, 113 1 
conL1.incrs. &t vector; map; sci: 
unordered_map. 
input/output. Sa lIO streams. 
regular expressions. Sa regcx. 
string manipulation. Sa siring. 
Stanford University, 791 
Starting programs, 1039- 1040, Sa alw 
mainO· 
State, 90, 1175 
lIO stream, 1127 
of objects, 30 I 
source of errors, 134 
testing, 961 
valid state, 309 
validity checking, 309 
Statement scope, 265, 1046 
Statements, 47 
grammar, 1059-1061 
named sequence of, Sa Functions. 
INDEX 
temunator ; (senucolon), 50, 99 
Static storage, 577, 1047 
class members, lifetime, 1048 
embedded systems, 897- 898. 905 
sialic, 1047 
static consl, 32 1. &t aIJo consl. 
Sialic consl inl members, 1075 
slatic local variables, order of ini· 
tialization, 290 
sid namespace, 29 1- 292,1098 
slderr, 1144 
<stde)(ccpl:>, 1097 
sldin, 1016, 1144. Sa abo stdio. 
stdio, standard CliO, 1016, 1144-
1145 
EOF macro, 10 19-1020 
errno, error indicator, 880 
fcloseO, 1019- 1020 
fILE, 1019- 1020 
fopenO, 10 19-1020 
getcharO, 1019, 1044 
ge150. 1018, 1144·- 1145 
input, 1017-1019 
output, 10 16- 10 17 
printf(), 1016- 1017, 1141- 1144 
SCilnfO, 1018, 1144 
slderr, cerr equivalent. 114,l 
sldin, cin equivalent. 1016. 1144 
sldoul, caul equivalent, 1016, 1144 
std_'ib_facililies.h header file, 1153-
1154 
sldou!. 1016, 1144. Saabostdio. 
Stepanov, Alexander, 694, 696, 805-
80G 
Stepping through code, 160 
Stereotypes of programmers. 2 1- 22 
sn. (Standard "Icmplate Library), 
690.11 10-1124 
..w abo C standard library; Stan· 
dard library. 
algorithms. &t S11.. algolithms. 
containers . ..w S11 .. containers. 
fUllction objects. Sa STL function 
objects. 
history of, 805- 806 
ideals, 690-694 

INDEX 
iterators. Set STL iterators. 
namesp:lce, sid, 1098 
STL algorithms, 11 12-1121 
&e Algorithms (STL). 
alternati\'es to, 1150 
built·in arrays, 718-719 
computation UJ. data, 691 -693 
heap, 111 9-11 20 
maxO. 1120- 1121 
minO, 1120- 1121 
modifying sequence. 1114- 1116 
mutating SC(llience, 1114- 1116 
nonmodifying sequence. 1113-
11 14 
pcnnutations, 1120 
searching, 111 7-1118 
set, 1118- 1119 
shumc, 1115-11 16 
sorting, 1117-1118 
utility, 111 6- 11 17 
value comparisons, 1120- 11 21 
S"TLcont.1incrs, 720- 72 1, 1105- 11 12 
almost. 72 1- 722, 1106 
assignlllents, 1 108-1109 
associative. 11 05, 1111- 111 2 
capacity, 1110- 111 1 
comparing. 1III 
constntClOrs. 1108- 1109 
container adaptors, 1106 
copying. 1111 
destnlctors, 1108-1109 
c!emelll access, 1109 
information sources about, 720-
721 
iterator categories for, 722- 723, 
1104-1105, 1109 
list ol>crations, II 10 
membcr tYl>Cs, I 108 
opcr..uions o\'efview. I 107 
qucue operations. 11 10 
sequence, 1105 
5;1.e. 111O- 111 1 
st;!ck operations, 1110 
swapping, 1111 
Sl"L function objects. 1122- 1123 
adaptors, 11 23 
arithmctic operations, 1123 
inserters, 1121-1 122 
prcdicates. 738-738, 1122-1123 
STL iterators. 1100-1105 
basic OI>Cntlions, 695 
categories, 1103-1105 
definition, 694, 1100-1101 
description, 695-696 
cmpty lists, 702 
example. 708-7 11 
operations, 1102- 1103 
Uf. pointers, 110 I 
sequence of clemcnts, 1101- 1102 
Storage class, 1047- 1048 
automatic storage, 1047 
frec storc (heap), 1047 
slatic storage, 1047 
Storing data. Sa Containers. 
slrO. Siring extractor, 390-391 
SlrcalO, 101 2-1013, 1146 
slrchrO, 1014, 1146 
slrcmpO, 1012- 1013, 11 46 
slrcpyO, 1012-10 13, 1015, 11 '~ 6 
Stn::am 
buffers, 1125 
iterators, 758-76 1 
modes, 1126 
states, 349 
t}1>Cs, 1126 
slreambuf, 402, 1125 
<streambuf>, 1096 
<string>, 1096, 1128 
String literal, 62, 1044 
siring, 66, 815, 1175 
Sa aI.w l ex!. 
+ concatcnation, 68-69, 815. 1132 
+'" append, 8 15 
< lexicographical comp;uison, 815 
« Output. 815 
'" assign, 815 
== equal, 8 15 
» input, 8 15 
II subscripting, 815 
almost container, 1106 
appendO,8 15 
basicstring. 8 16 
1227 

1228 
string (amtinutd) 
C++ to C Slyle conversion, 815 
c_slrO. C++ to Cstylc COllversion. 
345, S15 
eraseO, removing characters, SIS 
exceptions, 1099 
findO. SIS 
from_slringO, S17-S18 
getlineO. SIS 
input temlinator (whitesp.lce), 65 
InserlO, adding characters, SIS 
lenglhO, number of characters, SIS 
lexicaCcast example, SI9 
literals, debugging, 159 
operations, SIS, 1132 
operators, 66-67, 6S 
palindromes. example, 637- 638 
pattelll matching. Set Regular ex-
prcsslons. 
properties, 712- 713 
size, 78 
sizeO, number of characters, SIS 
standard library, SI6 
siring to value conversion, 817- 818 
slringslream, 816- S1S 
subscripting il, SIS 
lo_stringO example, 816- S18 
values to string conversion, 8 16 
V.i . vector, 715 
whitespace, 8 1S-S 19 
slringslream. 390-391 , SI6-S18, 11 26 
SlrlenO, 1012, 1146 
SlrncalO, 1012-1013, 1146 
slrncmpO, 1012-1013, 1146 
slrncpyO, 1012-1013, 1146 
Strong guarantee, 677 
Stroustrup, Bjallle 
advisor, 785 
biography, 14-15 
Bell L.lbs colleagues. 80 1- S04, 989 
education on invariants, 793 
inventor of C++, 804-S06 
Kristen Nygaard. 799 
slrpbrlcO. 1146 
slrrchrO. 1146 
slrslr(). 11 46 
strtod(), 1146 
5Irtol(), 1146 
5lrloul0 , 1146 
INDEX 
slruct, 303-304. Sat/Iso Data stnJclUrcs. 
SlruCI tag namespaee, 1002-1003 
Structure 
of data. Set Data stntctures. 
of programs, 213-2 14 
Structured liles, 361-370 
Style, definition. 1176 
Sub· patterns, 83 1, S34 
Subclasses, 496, 1116. Sa also Derived 
classes. 
Subdividing programs, 175- 176 
Subscripting, 116-117 
o Fortran style, 863 
II C Stylc, 669, 863 
arrays, 628. S63 
atO, eheckcd subscripting. 669, 
1109 
Malr;)( exam pic. 863-865, S69 
pointers, 1064 
string, 815. 1132 
veclor, 579-580, 592-593. 625-
626 
Substrings. S27 
Subtract and assign -=, 67, 1053. 1103 
Subtraction - (minus) 
comple .. , S81, 1138 
definition, 1051 
integers. 1064 
iterators, 1104 
pointers, 1064 
Subtype, definition, 1176 
Summing valucs. Set accumulateO. 
Superclasses, 496, 1176. Sa also Base 
classes. 
swapO. 279, 1111 , 1116 
Swapping 
columns, 870 
containers, 1I11 
ranges. 1116 
rows, 870, S76 
swapJ"nses{). 1116 
switeh-statelllclllS 
break, case tcrmination, 104- 107 

INDEX 
nse labels, 104-107 
most comlllon error, 107 
Uf. string·based selection, 105 
Symbol tables, 246 
Symbolic COnStantS 
5« also Enumcrations. 
clcaning up, 23 1-233 
defining, wiLh slatic consl, 321 
Symbolic names, tokens, 232 
S),mbolic rcpresentations, reading, 
368-370 
Syntax analyzers, 188 
Syntax checking, 48-50 
Syntax errors 
examples, 48-50 
overview, 135-136 
reponing. 135-136 
Syntax macros, 1023- 1024 
systcmO, 1149 
Systcm, definition, 1176 
System tests, 969-973 
T 
\I tab character, 108, 1043 
lanO, t<Ulgelll, 879, 1137 
tanhO, hyperbolic tangent, 879, J 137 
TI~A (liny Encryption Algorithm), 
785. 930- 935 
l echnical University of Copenhagen, 
793 
-telecolllllJunications, 28-29 
-Iemperature data, example, 119-J 2 J 
template, 1003 
-Iemplatc, 656, 1083, 1176 
argumcnts, 1083- 1084 
class, 658- 661. Sa abo Class tem· 
plate. 
compiling, 66 1 
containers, 661- 662 
crror diagnostics, 66 1 
runction, 659- 665, &'t' aiJo FUllc, 
tion tcmplate. 
generic programming, 659-66 1 
inheritance, 66 1- 662 
inst.1ntialioll, 658- 659, 1084-1085 
illlcgcr parameters, 662- 664 
member types, 1086 
parameters, 656- 659, 662- 664 
parametric polymorphism, 659-
661 
specialization, 1084- 1085 
type parameters, 656-659 
Iypename, 1086 
weaknesses, 66 1 
-rb nplate·stylc casts, 1006 
Temporary objects, 280, 1048 
Tenninals, in grammars. Su -rOkcns. 
Tennillation 
abortO a progrrun, 1149 
on exceptions, 140 
exitO a program, 1149 
input, 61- 62, 177 
normal program termination. 
1039- 1040 
for Siring input, 65 
zcro, for C·style strings, 633 
-Icnninator character. specifying, 360 
Tcsting, 952-953, 1176 
Sa aJ.w Debugging. 
algorithms, 961 -968 
for bad input, 102- 103 
black box, 952- 953 
branching, 966-968 
bug rel>orlS, retention period, 953 
calculator example, 223-227 
classes, 973-976 
code coverage, 968 
debugging, 979 
dependencies, 962-963 
designing for, 978-979 
faulty assumptions, 976-978 
Iiles. after opening, 346 
FL"I"K, 1160 
inputs, 961 
loops, 965- 966 
non·algorithms, 96 I -968 
outputs, 961 
pcrrom13llce, 979-983 
pre· and post-conditions, 961 - 962 
proofs, 952 
RAIl, 964- 965 
1229 

'23{) 
Testing (conhium:l) 
~grcss ion tests, 953 
rcsoura: management, 964-965 
resources, 962 
stage of programming, 35 
Slate, 961 
system tests, 969- 973 
tCSt cases, definition, 164 
leSt harness, 957-959 
liming, 981-983 
white box, 952-953 
l ating units 
fomlai specification, 954-955 
random sequences, 959-96 1 
strategy for, 955-957 
systematic tcsting, 954- 955 
test harness, 957-959 
Text 
character strings. See siring: C-stylc 
strings. 
email example. 820-825, 828-830 
extracting text (rom fdes, 820-825. 
828-830 
finding patterns, 828-830, 833-
836 
in graphics. Set Text. 
implementation details, 826-828 
inputloutput, GU Is, 550-551 
maps. Su map. 
storage. 577 
substrings, 827 
vector example, 121- 123 
words frequency example, 745-
7'17 
Text example, 427- 429, 462-464 
Text editor example. 708- 711 
111ela, 881 
this pointer, 603-605, 654- 655 
Tnompson, Ken, 801-803 
-!luee-wa), comp.1rison, 1012 
lluowing exceptions, 145, 1086 
110 stream, 1127 
fe-throwing. 677 
standard library. 1099-1100 
throw, 145. 1053. 1086- 1088 
\lector, 672-673 
Time 
date and time, 1147-1149 
measuring, 981 -983 
1i mekccping. computer usc, 26 
time_I, 1147 
INDEX 
T Ul), Encryption Algorithm (ll~A), 
785, 930-935 
1m, 1147 
Token example, 181- 184 
Token_strt'am example, 204-2 12 
tolowerO, 394.113 1 
Top·down approach, 10, 776- 777 
to_slringO example. 816-8 18 
loupJJC!r{), 394, 113 1 
Tracing code execution, 160- 16 1 
Trade-off, definition, 1176 
transformO. 1114 
Transient errors, handling, 895- 896 
Translation units, 51. 137- 138 
TransparcnC)', '~ 47. 457 
Tree smlClurc, map container, 747-750 
true. 1003, 1004 
trunc mode, 385. 1126 
Truncation, 82, 1176 
C·stylc 110, 11 43 
c.xceplions, 15 1 
floating·point numbers, 857 
try-catch. 144-150, 668- 669, 1003 
Turbo Pascal language. 796 
Two·dimensional m,uriccs, 868-870 
1\\"0'5 complcmetlt, 922 
1}'}>C convcrsiOIl 
casting, 594- 595 
consLcast, casting awa), eonst, 
594-595 
exceptions, 151 
explicit, 594 
in expressions, 98- 99 
function arguments, 281- 282 
implicit, 621-622 
int to pointer. 576 
opcratOI'S, 1058-1059 
poimers, 576, 594-595 
reinlerpreLcasl,594 
safety, 79- 83 
static_cast, 594 

INDEX 
siring to valuc, 817-818 
tnlllcation, 82 
valuc to string, 816 
-rypc conversion, implicit, 621-622 
bool, 1055 
compiler warnings, 1055- 1056 
fioating-poilll and illlcgral, 1055 
illlegral promotion, 1054-1055 
pointcr and refcrcncc, 1055 
preserving values, 1054- 1055 
prolllOlions, 1054- 1055 
user-dcfincd, 1056 
usual arithmetic, 1056 
"lyPc safety, 78- 79 
implicit convcrsions, 80-83 
narrowing convcrsions, 80-83 
poimers, 580-583, 634-637 
range error, 146-148.580-582 
safc conversions, 79-80 
unsafc conversions, 80- 83 
typedef, 703 
Iypeid, 1003, 1050, 1099 
<lypeinfo>, 1097 
Iypename, 1003, 1086 
Type, 60, 77, 1176 
aliases, 703 
buill-in. &e Built-in types. 
chccking, C++ and C , 998- 999 
generators, 658- 659 
graphics classes, 480-482 
mislJ},l(eh errors, 136-137 
mixing ill expressions, 98- 99 
naming. &e Namcspaces. 
objccts. 77- 78 
operations, 30 I 
organizing. &e Namespaces. 
paramcterized, 659- 661. Su aiJo 
"Iemplatcs. 
as parameters. &e Tcmplates. 
poimers. &e Poimer. 
promotion, 98- 99 
representation of objcct, 304, 497-
499 
safety, 78- 79, 82 
subtype, 1176 
supcrtype, 1176 
u 
tmncm.ion, 82 
user-defincd. &e UDTs_ 
uses for, 300 
values, 77 
variables. Set Variables, types. 
ufu suffIX. lO,n 
\U, "not uppercase," regex, 838, 1135 
\ u, "uppercase character," regex, 837, 
1135 
UDT (User-defined type). SetClass; 
Enumeration. 
U nary expressions, 1050-1051 
"Uncaught exception" crror, 151 
U nehccked conversions, 905 
"Undeclared idcntifier" error, 256 
Undcfulcd ordcr of cvaluation, 261 
ungel(), 349-352 
ungelcO, 1145 
Uninitia1ized variables, 322-325, 11 76 
uninilialized_copyO, 1116- 111 7 
uninilialized_fiIlO, 1116- 1117 
union, 1082- 1083 
uniqueO, 1114 
unique_copyO, 728, 757, 760- 761 , 1114 
UnittesLS 
formal spccificluion, 954- 955 
random sequences, 959-961 
strategy for, 955-957 
systematic testing, 954-955 
test harness, 957-959 
Unnamed objecLS, 459-461 
<unordered_map>, 744, 1096 
unordered_map, 744 
See also map. 
finding ciemenlli, 753- 755 
hash tables, 753 
hash values, 753 
hashing, 753 
itcrators, I 105 
unordered_mullimap, 744, 1105 
unordered_mullisel, 744, 1105 
<unordere<Cse1>, 744, 1096 
unordered_scI, 744, 1105 
1231 

1232 
Unsafe conversions, 80-83 
un5elfO, 380 
Unsigned and signed, 922-926 
unsigned type, 1062 
Unspecified constructs, 1039 
upper, character class, 842, 1134 
upper_boundO, 764,1112, 1117 
Uppercase. S« Case. 
uppercaS4', 1129 
U.S. Department of Defense, 796 
U.S. Navy, 789-790 
Usc cases, 177, 1176 
User-defined conversions, 1056 
User·defined operators, 1054 
User·defined types (UD,}'s), 300 
Sa al.w Class; Enumeration. 
exceptions. 1087 
operator overloading, 1069-1070 
operators, 1070 
standard library types, 300 
User interfaces 
console inpuuoutpUl. 540 
graphical. &t GUJ. 
web browser, 540-541 
using declarations, 29 1-293 
using directives, 29 1-293, 1089 
Usual arithmetic conversions, 1056 
Utilities, STL 
function objects, 1122- 1123 
inserters, 11 2 1- 11 22 
make-pairO, 11 24 
pair, 1123- 11 24 
<utility>, 1096, 1123-1124 
Utility algorithms, 1116- 1117 
Utility and language support, header 
files, 1097 
v 
\v vertical ("b, character literal, 1043 
valarray, 1106, 1139 
<valarray>, 1096 
Valid programs, 1039 
Valid state, 309 
Validity checking, 309 
constmctors, 309 
ellumerations.3 15 
invariants, 309 
n iles for. 309 
Value semantics, 619 
value_compO, 11 12 
Values, 77-78, 1176 
INDEX 
symbolic constants for. Set: Enu-
merations. 
and variables, 62, 73-74, 242 
value_type. 1108 
Variables, 62-63, 116- 117, 1061- 1062 
++ increment. 73-74 
= assignment, 69-73 
cllanging values, 73-74 
com]>osite assignment operators, 
73-74 
constructing. 287- 288 
declarations, 258. 260-26 1 
going out of scope, 287 
incrementing ++, 73-74 
initializatioll. 69- 73 
input, 60 
naming, 74-77 
type of, 66-67 
uninitialized, class interfaces. 322-
325 
value of, 73-74 
<vector>, 1096 
vector example, 570-573, 612-618, 
646-656 
-> access through poimer. 593 
. (dot) access, 592-593 
= assignment, 653 
[I subscripting, 625-626, 668-672 
a!locators. 666 
atO, checked subscripting, 669 
changing size, 646-656 
copying, 6 13- 618 
destructor, 506-590 
dement type as p..1rameter, 656-
659 
eraseO (removing clements). 715-
718 
exceptions. 668- 669, 678-680 
e~plicil constmctors, 621-622 
inheritance. 661-662 

INDEX 
insertO (addingclemems), 715-718 
ovcrloading on consl, 626- 627 
push_bacKO, 652-653, 667 
representation, 650-65 1 
reset'\-'e(), 65 1, 667, 679- 680 
resizeO, 652, 668 
subscripting, 579-580, 592-593, 
625-626 
veclor, standard library, 1107- 1111 
< lcss than, I I 1 1 
= assignment, 1109 
== c(lualit}', 1111 
II subscripting, 1109 
assignO, 1109 
alO, checked subscripting, 1109 
back(), rcfcrencc 10 last clement, 
1109 
begin(), itcralOl' to first clcmcnt, 
1109 
C<lpacilyO, 111 1 
consUleralor, 1108 
COIlStm ctors, 1108-1 t 09 
destmctor, 1109 
difference_type, 11 08 
end(), one beyond last clement, 
1109 
eraseO, removing clcmenLS, 1110 
frontO, reference to first clcment, 
1109 
insertO, adding clemellts, 1110 
iterator, 1108 
member functions, lisLS o f. 1108-
111 1 
mcmber t)-pt:s, list of, 1108 
Ilush_badl:O, add clcmem at end, 
111 0 
sizeO, numbcr of clements, 11 1 1 
size_type, 1108 
valu~U ype , 1108 
vecior of references, simulating, 1166-
1167 
VectorJ d examplc, 440, 1[66- 1167 
virtual, 1003 
Vin ual dcstructors, 590. Sa a/sc De-
structors. 
Vinual function, 493, 498-499 
dcclaring, 499- 500 
definition, 493, 1176 
history of, 799 
object la),out, 497-499 
ovcniding, 500- 50 1 
pure, 502-504 
Shape example, 493, 498-499 
"plr, 498-499 
vlbl, 498 
Visibility 
Su also Scope; Transparency. 
menus, 560-56 1 
of namcs, 264- 269, 290- 293 
widgcts, 549 
Visual Studio 
FLTK (Fast Light Toolkit), 1159-
11 60 
installing, 1152 
m nning programs, 11 53- 1154 
void, 113 
function rcsults, 113, 270, 272 
pointcr to, 593-595 
putbac"!), 2 10 
void', 593-595, 1007- 1008, 1062 
vptr, virtual fUllction poimcr, 498-499 
vlbl, virtual function table, 498 
w 
w, writing file mode, 842, 1134, 1140 
W+ , writing and reading file mode, 1140 
\ W, "not word characterr rege., 837, 
1135 
\ w, "word ch aracter,~ regell, 837, 1135 
waitO, 547-548, 556-557 
Wait loops, 547- 548 
waiUor_bultonO example, 547- 548 
Waiting for user action, 547-548, 556-
557 
wchar_t, 1003, 1004 
"'~b browser, as user interface, 540-54 1 
Wheeler, David, 108, 785, 930 
while-statements, 108- 109 
White-box tcsling, 952-953 
"Whites pace 
formatting, 393, 394-40 1 
1233 

234 
vVhitcspacc (contilllled) 
idcmifying, 393 
in inpUl, 64 
Siring, 8 18-819 
ws, manipulator, 1130 
Widget example, 548-549 
Bullon, 4 18-420, 54 1-550 
contTOI inversion, 556-557 
debugging, 563-564 
hideO,549 
implementation, 1163- 1164 
In_box-O,550-55 1 
line drawing example, 552-556 
Menu, 55 1, 557-562 
moveO, 549 
OUI_boxO, 550-55 1 
put_on_topO,1165 
showo,549 
technical example, 1167- 1170 
text input/output, 550-55 1 
visibility, 549 
Wild cards, regular expressions, 1133 
Wilkes, Maurice, 785 
Window c;>;ample, 416, 439 
canvas, 416 
creating, 4 18- 420, 542-544 
disappearing, 563 
drawing area, 416 
implementation, 11 64-1166 
line drawing example, 552-556 
INDEX 
puCOIl_10pO, 1165 
with "Next" button, 418-420 
Willdow.h example, 417- 418 
Wirth, Niklaus, 794-795 
Word frequency, eXillllp1c, 745 
Words (of memory), 1176 
wri le(), unfomlatted output, 1129 
Writing files, 344 
Set: also File 110. 
appending to, 385 
binary 110, 387 
example, 346-348 
fsJream type, 344-346 
of stream type, 345-346 
ostream type, 343-348, 387 
ws manipulator, 1130 
x 
xdigit, 842, 1134 
\xh hh, hexadecimal character lite"I), 
1043 
xor, synonym for ", 1003, 1004 
xor_eq, synonym for "=, 1003. 1004 
z 
lcro-temlinated array. 1011 . Sec also C· 
style string. 
ZIP code example, 844-849 

Page 14. 
Page 15. 
Page 26. 
Page 26. 
Page 26. 
Page 26. 
Page 28. 
Page 28. 
Page 29. 
Page 29. 
Page 30. 
Page 30. 
I~ ge 3 1. 
I~ge 31. 
I~ge 33. 
I~ge 785. 
Page 785. 
Photo Citations and Credits 
Photo of Bjame StrouStrup, 2005. Source: Bjam e StrouStrup. 
Photo of Lawrence '"Pete" Petersen, 2006. Source: Dept. of Computer Science, 
Texas A&1I'1 University. 
Photo of digital watch from Casio. Source: ww ...... casio.com. 
Photo of analog watch from G.1sio. Source: w'\f\".casio.com. 
MAN marine diesel engine 12K98ME: MAN Burgmeister & Waine. Source: 
MAN Diesel AlS, Copenhagen, Denmark. 
Emma Maersk; the world's largest container ship; home port Arhus, Den" 
mark. Source: Ccny Lnages. 
Digilal telephone switchboard. Source: Alamy Images. 
Sony-Ericsson \V·920 cell phone with music system, cell phone, and web COIl-
nectivity. Source: \\f\\f\v.sonyericsson.com. 
Trading floor of the New York Stock Exchange in Wall Strcet. Source: A1amy 
Images. 
A represemation of parts of the internet backbone by Stephen C . Eick. 
Source: S. C . Eick. 
CAT scanner. Source: A1amy Images. 
Computer-aided surgery. Source: Da Vinci Surgical Systems, \\f\vw.intu-
itivcsurgical.com. 
Ordinary computer setup (the lert-hand screen is connC<:tcd to a Unix desktop 
box, the right"hand sercen is a \¥indows laptop). Source: Bjarne StrouStrup. 
Computer rack from a server farm. Source: lstoc.kpholO. 
View rrom a Mars rover. Source: NASA, w\\f\v. nasa.gov. 
11le EDSAC team 1949_ Maurice \Vilkc::s center, David Wheeler without a 
tic. Source: TIle Cambridge Univcrsity Computer Laboratory. 
David Wheeler lecturing circa 1974. Source: Uni,'ersity of Cambridgc Com-
pliler Laboratory. 
1235 

1236 
Page 787. 
P-J.gc 789. 
Page 790. 
Page 791. 
Page 79 1. 
Page 792. 
Page 792. 
P"dgC 793. 
Page 795. 
Page 795. 
P"dgC 797. 
Page 797. 
Page 799. 
Page 800. 
Page 800. 
Page 801. 
Page 801. 
Page 802. 
P"dgC 802. 
Page 804. 
Page 805. 
P-dgC 989. 
PHOTO CI TATION S AND CREDITS 
John Backus 1996. Copyright: Louis Fabian Bachrach. For a collection orpha-
tographs of compUler pioneers, sec Christopher Morgan: H'iumu mm Ihar 
WOI/(/.m: portraits ill rompuh"lIg. ACM Press. 1997. ISBN 0-8979\-960-2 
Crace Murray Hopper. Source: Computer History Muscum. 
Grace Murray Hopper's bug. Source: Computer History Museum. 
John C. McCarthy, 1967, at Stanford. Source: Stanford University. 
John C . McCarthy, 1996. Copyright: Louis Fabian Bachrach. 
Peter Naur photographed by Brian Randell in Munich ill 1968 when they to-
gether edited the report that launched the field of Software Engineering. Rc< 
produced by pcmlission from Brian Randell. 
Peter Naur, from oil painting by Duo Duo Zhuang 1995. Reproduced by per· 
mission from Erik Frokja!r. 
Edsger Dijkstra. Source: Wikimcdia Commons. 
Niklaus Wlrth. Source: N. 'Wirth. 
Niklaus 'Wirth. Source: N. Wlrth. 
Jean Ichbi .. h. Source: Ada Infonnation CIc .. ringholise. 
Lady Lovelace, 1838. Vintage print. Source: Ada Information Clearinghouse. 
Kristen Nygaard and Olejohan Dahl, circa 1968. Source: University of Oslo. 
Kristen Nygaard, circa 1996. Source: University of Oslo. 
Olelohan Dahl, 2002. Source: University of Oslo. 
Dennis M. Ritchie and Ken 1nomp501l, approx. 1978. Copyright: AT&T Bell 
Labs. 
Dennis M. Ritchie, 1996. Copyright: Louis Fabian Bachrach. 
Doug Mdlroy, circa 1990. Source: Gerard Holzmann. 
Brian W. Kernighan. circa 2004. Source: Brian Kernighan. 
Bjarne Stroustrup, 1996. Source: Bjame StrouSlrup. 
Alex Stepanov, 2003. Source: Bjarne Stroustrup. 
AT&T Bell Labs' Murray Hill Research celller, approx. 1990. Copyright: 
AT&T Bell Labs. 


An Introduction to Programming 
by the Irwentor oj C++ 
.:. Pre/)(lralion for Programming ill the Real fYorLd 
T ne book assumes that you aim c\'c ntu<l Uy co ",rill: non-trivial program$, whether for work in ~fIW.ln· 
no'dopn~nl Or ill $OfTlC other lcdlllical field . 
. :. Focus on FundamentaL Concepts and Techlliques 
'fhe book explains fimdamelll.lt conccJllj a nd l ech llique~ in gn::llterdl!pl h than troiditiooaJ introducI;OIl$. 
Th is appro;,,:h will gi~ )'ou a .wIid fouooaiion for writing USl!fut, COCfeCl, maintainabk, and dTlCknl code . 
. :. Programming wilh Today's C++ 
The book U lin int roduc tion 10 programming in gt:nc.r .. l. including objccl-onc:mcd progrnmming alld 
generic programming. [I ;$ lllw a :JOlid introduction 10 the C ++ p"lSr.lmminglangll.lb"t';, oncofthc n~ l 
w;del)· uliCd language:! for n;:tl-world :lOftwarc. "11)C bo<* prcscnt$ rn()(krn C++ progrl'wuning teehniqua 
from the sian. im roducing ,I~ C++ 51:mdan:l libr.HY to simplify prop:mmming ,;uk, . 
. ;. For Beginners-And An)'one Who Wanls 10 Learn Somelhing New 
T he book iJ primuiJr dc...igned for people who havc 11(:11:r programmL..,.j before. :Ind i, has ocen to ted 
wj[h marc ,hall 1,000 fir.tt-yc;,.r un il ..... Ni,y s ' lIdelll ~. HowL'VCr. p r:u;,i. ioncl"$ :'lId adl'<lnced $Iudent.s , .. ill 
gain new in~i gh l aud gu id;lIlce by Stting how ;t rccogniud master appro;lches .he r lcm C"nu orhis " n 
.:. Provides a Broad View 
r ile fm. halfofthc IJ.ook (OVCN a ,,'ide ~ nge ofl'Wl11ill l concq:JIJ. design and prognullming tedl11i<lllU. 
lallgu:.gefc:twl1";$, and librnria. T hose will clla!>]c rOll 10 wrile programs involving input. ouqxil. compu-
'ation. :lnd ~jm plc J.:r:tphio. The second hll l( C"I']OO::S morc $pcci:..li:....-.d topics. soch ;u lex, proceS$ing ;lIId 
( r~ting, and providd abund~nl rd.;~ncc 1I101teri.11. Source code aoo suppMt ~upplemcnu :m~ :1\~.il;,lJIc 
from the alidllX's wcruite. 
ABOUT THE AUTHOR 
Dr. Rj:lrne Slmustrup is [he designer and original impkmen.cr of C++ _'00 the ;'Ul horoC 
TIll C++ ' 'rfJ!7l1J11millg UJNglllW (AddioSon-WClky). He il lhe College ofEngi[)(cring Ch"ir 
in Computer Scicocc Profeuor ;l. TCXlU ."\&M Uni".;ni.),.;\ memhCf 0([ 11(: U. S. N.lliol.1aJ 
r\catkmr of l::.n)l:iutCTing, ~ "d :In AT&T f"ellow. Ur l"on- mo-.·ing to Ilcadem ia . hc "" orkcd for 
rlaadCl' in AT&T Bell Grohs. J.Jc is a founding IlIcmUer ofl he ISO C++ stand;uds 1'00um;w:c. 
lolcflM_Com/lW 
www.strcustrup.coaVPrll.il.lnvntng 
C-""'''Y'-.oAol.-
c-IIhoiOf:ISJlICI"'-"'OdIrltI~1Ia 
·t~ Addison-Wesley 
Pearson EdUcatiOn 
569.99 U.S. I S76.99 CANADA 

